00:31:45 <f1rstmistake> Hi, my name is Joe. New to HasKell. Anybody know how to remove "--disable-library-stripping" flag when installing package using cabal? Note: I'm using cross-compilation GHC for iOS target.
00:42:07 <Cale> f1rstmistake: Does it show up in the .cabal file?
00:45:55 <f1rstmistake> Hi Cale. No.
00:46:19 <f1rstmistake> I have checked it, nothing say 'library-stripping'
00:47:51 <f1rstmistake> It seems like '--disable-library-stripping' is sent to ghc-pkg by cabal.
00:49:27 <Cale> to ghc-pkg?
00:49:31 <Cale> That's weird
00:51:19 <f1rstmistake> wait, i'll give more trace output.
00:51:25 <joelteon> Where do I figure out where logStrBuilder is from?
00:51:29 <Cale> --disable-library-stripping looks like a cabal configure flag, only the version of cabal I have here (1.18.1.2) doesn't list it.
00:51:44 <joelteon> wai-extra-2.0.1 won't build because it imports a library that no longer defines that function.
00:51:46 <Cale> (it has --disable-executable-stripping though)
00:51:47 <joelteon> I need to find it.
00:51:56 <Cale> GHC itself doesn't have any flags like that
00:51:57 <johnw> joelteon: wai-extra is being fixed as we speak
00:52:39 <joelteon> oh ok
00:52:43 <joelteon> c:
00:53:23 -f1rstmistake(~f1rstmist@180.244.90.40)- Hi Cale, it looks like this:
00:53:50 <f1rstmistake> Using Cabal library version 1.18.1.2
00:53:50 <f1rstmistake> ./dist-i386/setup/setup configure --verbose=3 --builddir=dist-i386 --ghc
00:53:51 <f1rstmistake> ...
00:53:52 <f1rstmistake> -â€”disable-library-profiling --disable-shared...
00:53:54 <f1rstmistake> unrecognized option `--disable-library-stripping'
00:55:35 <Cale> weird
00:57:28 <Cale> f1rstmistake: I recall that stripping needed to be turned off in Xcode for iOS cross compiling, but I don't know what that option is turning up there. It's not documented anywhere that I can see.
00:58:28 <f1rstmistake> Cale: I think that's executable-stripping using --disable-executable-stripping. I also got that issue yesterday.
01:00:09 <f1rstmistake> (Actually I haven't solved executable stripping issue last time, both passing --disable-executable-stripping or setting it to false in .cabal will always call 'strip' when installing package.
01:00:18 <f1rstmistake> (Weird).
01:05:27 <DigitalKiwi> I'm cold so it's time for `cabal install cabal-install` :)
01:05:53 <DigitalKiwi> that and it was way out of date
01:11:22 <f1rstmistake> @Cale It seems like --disable-library-stripping automatically added by cabal version 1.18.1.2
01:11:23 <lambdabot> Unknown command, try @list
01:13:42 <Cale> When it's running ghc-pkg? That doesn't make sense as far as I can tell, because that's not an option to ghc-pkg (which deals with the package database, and doesn't touch binaries)
01:15:48 <f1rstmistake> Hi Cale. I just try removing 'executable-stripping: False' and it seems like now '--disable-library-stripping' is not sent anymore.
01:16:09 <Cale> hm, interesting :)
01:17:23 <f1rstmistake> But now i got another error message:
01:17:34 <f1rstmistake> Please create a package description file <pkgname>.cabal.  Failed to install texmath-0.6.5.2
01:19:22 <davidtan> hi guys, i'm new to and am learning haskell. is this the right place to ask basic questions?
01:20:09 <shachaf> Yes.
01:20:10 <Saizan> davidtan: yep
01:20:51 <davidtan> ok. I've been following learnyouahaskell.com and i got stuck with understanding the Eq typeclass definition.
01:21:11 <davidtan> it defines the function x == y not (x /= y)
01:21:40 <davidtan> I get that == will return not (/=) but how does Haskell know to evaluate x == y to True
01:21:49 <shachaf> Because you define it for your type.
01:22:15 <davidtan> where is it defined. it appears absent to me in the Eq type class definition
01:22:46 <aristid> davidtan: it's defined in the instance
01:23:29 <davidtan> ahhh, ok. so you either have to manually define it when u create an instance or Haskell will do it for you when u use deriving?
01:23:40 <davidtan> ok that explains. Thanks!
01:24:48 <aristid> davidtan: yes. you can also define (/=) in the instance, the definition in Eq is just a default
01:27:39 <davidtan> if you do define (/=) in the instance, does it have to conform to the definition in Eq or will it simply override. For example, in the instance if I do x == x = True and x /= x = True will it lead to error or just give me True
01:28:11 <aristid> davidtan: it will "work" but it would be morally very bad
01:28:32 <davidtan> haha, ok. got it. thanks a lot aristid!
01:28:54 <aristid> davidtan: usually a typeclass comes with "laws" that are not checked by ghc. that (/=) is the opposite of (==) is one such law.
01:29:57 <davidtan> that sounds confusing. does that mean that some type class functions have to be strictly followed, and some don't (in this case the relationship between == and /=).
01:31:21 <joelteon> johnw: who's fixing it? :D
01:31:45 <joelteon> oh hey, idea
01:31:49 <joelteon> RSS feeds of packages on hackage
01:31:49 <johnw> what?
01:32:37 <joelteon> johnw: you said wai-extra is being fixed
01:33:02 <johnw> by the authors
01:33:22 <joelteon> well, is this a known issue i'm hitting?
01:35:25 <johnw> I'm pretty sure, but I may be wrong here; I know that snoyberg just mentioned to me a moment ago that wai-extras had been broken
01:36:34 <joelteon> oh ok
01:41:18 <aristid> davidtan: the "laws" are completely independent from the default implementation of any function. it just so happens for Eq that the default implementation is also a law :)
01:41:49 <aristid> davidtan: there is another unchecked law for Eq, i think: x == y must give the same result as y == x
01:42:16 <shachaf> There are many laws for Eq. Sometimes they are followed. Sometimes not.
03:57:40 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
03:57:40 --- topic: set by monochrom!monokrom@216.138.220.146 on [Sat Nov 23 20:32:31 2013]
03:57:40 --- names: list (clog Jeanne-Kamikaze KingOfKarlsruhe nominolo chidy H1FuelCell jcvfen zcourts OscarZ ts33kr hunt3r ADexter_ simukis_ ckinni ifesdjeen ulfdoz skchrko michas MindlessDrone Internet13 jetho Icewing erkin rekahsoft elediaz MoALTz ustunozgur nilg madjestic rnons zemmy zammy mno2 pi3r campnic sopvop Jonno_FTW Lethalman_ RoryHughes implementation lman canta fronx AshleyWaffle vektor xinming_ gelardi_ marr Philonous wchun Kaini hashcat DrCode tharper angerman stass)
03:57:40 --- names: list (randomclown oleo Okasu yitz nadirs jesyspa merijn paullik mindriot101 BoR0 raichoo whaletechno Mortivus zett_zelett piotr Axman6 Mon_Ouie ZioCrocifisso Zepheus dredozubov cyphase davidtan klaut issamou boegel Mustache frx mbuf arpunk mawuli bennofs yogurt_truck edon etehtsea fran Kosmos nik_89 juhp augur webframp funfunctor ozataman ompaul jem|osx akegalj apaku thunderrd pxqr tiffany carter s2r2 fijimunkii mirpa_ edwardk amritanshu_RnD athan tpsinnem shachaf)
03:57:40 --- names: list (yusukesuzuki JuanDaugherty Null-A RichyB hamishmack ananthakumaran scott_ stepkut hamid jackneill shesek [mth]_ floatingman ninegrid_ ninegrid otto_s leachim6 Rylee preflex mauke dsmith shennyg foobar__ dsrx vsayer jhinkle vili n00dle necrobious Argue_ kusut Fylwind rien tsurutom synonymous shanse Ralith mm_freak_ joaopizani sclv mgsloan ss_ Shin-LaC ryantrinkle jfischoff japesinator k4nar flubba chrisblake dgpratt chatsiri_ Igloo tromp_ sagittarian)
03:57:40 --- names: list (jmcarthur_mobile ormaaj Claudius1aximus jaspervdj WraithM Sgeo predator117 fxrh ByronJohnson Tene ocharles maoe yriw jmbto twirlobite nycs kerrick [[zz]] joaoh82 julmac jackhill cognominal wollw Excureo jefimenko kinslayer ValicekB kmicu alderz_ joneshf-work dlundy threesome jmcarthur boothead majoh arrdem kqr smileface Soft Tarential lahwran [Derek] lpsmith DarkFox eevar Zariel wagle_ sw1nn_ Spockz supki horlicks1 Aikawa_ Pupnik flori_ Kneiva_ fmapE_)
03:57:40 --- names: list (ParahSailin kaol deggisv2 mephx_ Nahra_ Ikarus dogmaT_ asjo` aninhumer s4msung_ satoshi_nakom0t0 Kobata_ waterlaz nullfxn nivox Guest26454 bigos Dashkal mikecaruso ankesh11 codesoup runde arnsholt mantovani stepcut pastorius udevd Eelis liyang zalzane mornfall jlamothe MK_FG crs_ saml dsantiago FreakyPenguin L8D rawtass nicoo zarul isomorphic hpk schlumpi ahihi pootler sipa edsko jrmithdobbs jedai m1dnight HalfWayMan aleksejs_ ofan \q davorb ktosiek m3ga)
03:57:40 --- names: list (evax Plasmastar johnw mrmonday pietore eagleflo identity Nik05 thoughtpolice a11235 earthy Martty_ bd_ mlinksva f8l jibi kseo ant0wn1 euclid xintron effy _Vi mobius araujo pyon edk jcp divyansr leroux rarasd coeus dolio nkkvt dsirenko mceier Cradam cdk guampa mak` xorox90 zero7_ idnar Myk267 tomh-__ liesen__ conehead_ davidbe_ xkb raphie dziga lostman bicgena CADD thomasschroeter jzelinskie nullcone_ stephe AlainODea tobyp akraut bkolera si14_ bb010g ehd)
03:57:40 --- names: list (kwos bishboria mimico__ etrepum DarkLinkXXXX_ Sibi_ leifw reiddraper Sieben__ nkpart lacrosse eribeiro posco_ srid bgyss kcliu_ aloiscochard juvenn puzza007 charlesofarrell_ Raynos Janiczek vivekrai__ zpconn wilfredh donri strax mrb_bk ehamberg keelo maxs_ bobry jodaro pfoetchen OlegYch benbangert earldouglas lasts_ ForNeVeR idoru spaceships edunham q66 jml Brando753 unsymbol fflam theorbtwo Sonderblade bernalex stiell price xrl_ majackson akiress_ bmuk)
03:57:40 --- names: list (jayne Kabaka bens swistak35 zso jibcage maaku Jimx- marky MasseR Svedrin copton fergusnoble c_14 NickHu TakSuyu andyland Hafydd Heffalump Polarina jroesch kfish sweeks ocfx sdx23 obcode helmut neptunepink pfurla ChongLi DonVitoC- adbge bbloom joneshf-laptop Whazor saurik h_chiro_ capisce ZsoL ziman noam wormphlegm gbarboza brainproxy vnz yeltzooo epta brisbin wting joelteon luigy justinjaffray zeiris talzeus averell Deewiant milessabin Martingale kludge`)
03:57:40 --- names: list (troydm gniourf benmachine Boney ndngvr Spaceghost albel727 sajith TDJACR notdan vmeson biscarch jcurbo newsham andrewsw mendez dario` DarwinIsGod adlan bsmt shapr DigitalKiwi gereedy _5kg tahu ski vendethiel speckle Wardje tarmil phienone lokydor zq Adios mixi Paprikachu joachifm spion mikeI leocassarani exicer shiona deech KitB tinyghost FreeFull aji sababa thetallguy hpd cbw jonke AleXoundOS jle` descender caligula no0y dreixel noddy drbop ixian kylcarte)
03:57:40 --- names: list (dmwit rieper jrib tippenein necronian shutdown_-h_now bjorkintosh kragniz bergmark jix dmead banjiewen squimmy Fubar^ Walther pranz1 xahry Morley93 klugez Jaak knyon saiam zomg paz_ Nickeeh Jaxan Enigmagic zacts ArkB fionnan r``t sunfun jdoliner- qwandor kini quaestor adelbertc_ Guest21673 lightquake msavoury ps-auxw mist11 DustyDin1o orospakr The_third_man Baughn Taneb johntromp tawm Artpicre AntiSpamMeta koninkje_away pjstadig binarystarz lopex Reiser)
03:57:40 --- names: list (cschneid mimi_vx amontez duairc vobi abesto Xorlev kloeri machisuji cynick nbouscal seanparsons Edoxile thirsteh zebr myme Blkt mechairoi Boreeas upgrayeddd peddie greymalkin hdevalence|away raid drmegahertz tero- drdo lambdabot ivan\ Adeon _d3f maksbotan tridactyla jorj SegFaultAX opto alexsdutton companion_cube cjay byorgey M-ou-se ejls junsuijin qz integral Iceland_jack tristan_1 bxc_ ido_ ircbrowse flux loans d-snp anders^^ xymox yano gallais jungnam)
03:57:40 --- names: list (CaveJohnson jrslepak zasimov tych0- td123 fall_ kaw_ popx Khisanth djahandarie thorkilnaur kbotnen kakos brandonw ivan` pnielsen raek iron_houzi marcopolo2 dnewby fikusz jdoliner_ jchee Tesseraction Kruppe smarter ciaranm Guest78473 bgamari smith_ cizra ghorn geekosaur Thulsadum tg atomicturtle pikhq DistantStar thebnq ryanakca wrunt twn MitchW nklein jrw ttuegel bgresham ninzine dv- sfvisser GGMethos saep aristid Meistarin Kuba MetaCosm felipe_ Natch)
03:57:40 --- names: list (mastensg gemelen m09 gdsx cmsd2 katis dumbhat mero cryzed phryk Nafai ibid Cr8 _br_ CindyLinz pdxleif Ornedan kekimmo adnap Eridius Hardolaf pyrtsa jliikka sordina1 Gracenotes_ emma ginmania1 BlastHardcheese blast_hardcheese chrisirc _janne betawaffle cross finnrobi b2coutts bstrie mgaare_ iulian mux pharaun ccasin stchang RevJohnnyHealey rdevilla AshyIsMe quicksilver theDon jj2baile go|dfish GaveUp dpwright AtnNn Valodim zerokarmaleft ahf jamesjb xaimus)
03:57:40 --- names: list (og01 kshannon Hodapp davorak relrod confound dqd rhodesd aoh annulus simon Kinnison _mkrull mlh Dodek flazz pyr aegray_ voyd bunzen g0dmoney- apples marmaton jazu_ mrd jzl_ dmilith zaphar_ps srhb dsp_ mandu jb55_ vhz michaelpj eyem ggherdov nitin2 mau_ Psycho_pr boyscared franckverrot pyykkis zeroskillor CosmicRay natte Cale Ycros milli dested mokus drbean pseudolio b_jonas sm MooGoo tehroflmaoer apo_ bholst mr- stevely_ larsrh so yggr aford jlouis davean)
03:57:40 --- names: list (Jello_Raptor meretrix dan64 acfoltzer dyreshark neurocyte dawik bitemyapp munro_ Gothmog_ pqmodn wto Eagle_Erwin SquidTamer noplamodo_ joshbohde b0c1 bartavelle bitraten1 prophile vpm Phill123 hive-mind FireFly mononofu FliPPeh xnyhps Tehnix lulf_ osfameron asm89 def-lkb jlewis tomaw vikraman epsylon dp_wiz jfhall_ mike2 barrucadu froztbyte Corey verrens tromp spacebug_ ethercrow stbuehler `0660 d3lxa jonasw moop jcande Bwild_ Ulrar mlen drewr rasmusto_)
03:57:40 --- names: list (franksh Arnar_ skypers malorie_ koala_man bcoppens_ mmaruseacph2 chipdude Derander_ mrshoe zz_robj_ nikola joeyh demolithion prinsen_ Javafant dcoutts sunnavy edwtjo [swift] mietek Lemmih_ krakrjak_ sddhrthr1 Licenser alios_ Athas robert_ lattenwald juuhaa mm_bureau tensorpudding flebron hc mirsal Twey sondove otterdam Rembane daoo OrangeDuck killy9999 mshroyer jbauman linduxed kryft helgikrs hiredman pcapriotti bearclaw_ heath Bigcheese lab-notes geoffh)
03:57:40 --- names: list (Belgarion0 profmakx slobo gargawel orzo fryguybob pi8027 rs0 brixen radioxid tessier shepheb anhall_ joshsz dropdrive aseidl joogi wunki bezik burp dixie magicman boegel|work xplat deavid Ke `bps SLi inr vvv Dtgr hellome BMeph ibab jaimef croys gseitz lusory Ptival nurupo SHODAN mavam solarus Nimatek mikeplus64 jxport yam _1126 Razz liori petanqk chirpsalot niko dustinswan mangaba_leitosa levi Gunni JPohlmann Elision Sornaensis XMunkki sgs opqdonut ion)
03:57:40 --- names: list (dtkatch pp^_ int-e maurer cpa cods stelleg Watcher7 paulschellin Chousuke Vorpal numberten dflemstr Sagi tomejaguar taruti tomprince marienz Fuuzetsu Laney Tordek statusfailed kenkku_ Liskni_si necroyeti lispy Annamaria jang1 pierreghz mortberg PatrickRobotham Cryovat macron frontendloader Draggor lasanbr yeshuah kxra gpampara_off hvr simpson heikkih lieven_ Amadiro nwf knyppeldynan valdyn otulp honkfestival __main__ zoktar peltchu scolobb ReinH inarru_)
03:57:40 --- names: list (TheBrayn bind1 Clint Excedrin topi` scshunt robbert` Yawgmoth SirChurchill mollerst1and mattp__ ConstantineXVI jorendorff_away imalsogreg nemesit|znc kittenso1p zenzike lpaste ortmage_ binq gridaphobe dju Lindrian Raynes eL_Bart0- Starfire endojelly PHO_ bbee m6n Entroacceptor FUZxxl dilinger nablack farn Cerise satshabad dschoepe IbnFirnas_ kosmikus ssbr ft pfeyz osnr ashooby aszlig mrowe_away ent ljhms dabradley Tribal mythmon fabjan helgar mena tpatja)
03:57:40 --- names: list (simonnn rmunroe luite_ fayden haasn petantik Will| tamiko gsnedders peder castor2 BrianHV lzm mviljamaa alexsdut2on Phlogistique jonsterling sa1 geal othiym23 IanKelling colah _flow_ ernst cic gspr uu1101 mp adimit k00mi zol Saizan henk erikl_ yac KaneTW bogner Vq jamwt1 zeroXten sohum @ChanServ)
03:57:45 <Hafydd> bennofs: no.
03:58:24 <AlainODea> exicer: it depends on what forces the evaluation. In ghci, it would be show and ((+2) 1) would be evaluated before ((+2) 5)
03:59:09 <bennofs> exicer: map (+1) [1,2,3,4,5] creates a new list with the expressions (they are also called "thunks" in ghc) [1+1, 2+1, 3+1, 4+1, 5+1]
03:59:12 <Hafydd> bennofs: oh. I am mistaken. never mind.
03:59:54 <exicer> AlainODea: I'm doing a bit of web scraping, but the site in question is a bit odd - navigation takes place with forms, and the result of submission is not relative to the current "position" within the site. As such, the order of form submissions matters, and I have some vague idea that lazyness might mess me up.
04:00:15 <bennofs> exicer: these expressions aren't evaluated yet. They only get evaluated when something demands it's value. So when I say map (+1) [1,2,3,4,5] !! 2, only 3+1 gets calculated
04:00:27 <exicer> Hm, okay
04:00:59 <Hafydd> exicer: the order in which elements of a list are evaluated couldn't possibly affect the I/O performed by your program, unless you're using an unsafe function.
04:01:11 <bennofs> exicer: The order of evaluation shouldn't matter, except when you using unsafePerformIO/unsafeInterleaveIO/...
04:01:41 <Hafydd> (Up to nontermination)
04:01:59 <exicer> Oh ? I realise that is the case with most things.. uh let me try to think of an example
04:02:07 <AlainODea> exicer: laziness shouldn't affect that.  Actions in a do block are sequenced.  Do not use unsafe* unless you really have no choice.  They are expert "here be dragons" functions
04:02:30 <exicer> Ah, right I see
04:02:31 <exicer> ok cool!
04:02:37 <exicer> I'm not using anything unsafe :p
04:06:19 <AlainODea> exicer: there are valid cases, but web scraping definitely doesn't need them.  The IO monad (what I'm overgeneralizing to do blocks) works like most imperative languages.  It enables a lot of other neat things, but for your case it allows network I/O and sequencing so you can run a stepwise web-scraping process
04:09:52 <jamil_1> hi all
04:09:54 <jamil_1> http://paste.ubuntu.com/6628830/
04:10:23 <jamil_1> what do I get "> " after getLine
04:10:29 <AlainODea> exicer: jekor's Haskell from Scratch videos really helped me learn Haskell's stengthimperative strengths. http://www.youtube.com/playlist?list=PLxj9UAX4Em-Ij4TKwKvo-SLp-Zbv-hB4B
04:10:56 <bennofs> jamil_1: do you mean why "> " only shows up after getLine?
04:11:08 <jamil_1> bennofs: yes
04:11:20 <bennofs> jamil_1: that is buffering
04:12:13 <jamil_1> bennofs: thats what I guessed, can I turn it of, or perhaps some version of putStr that doesn't buffer ?
04:12:19 <bennofs> jamil_1: you can test this by adding 'hSetBuffering stding NoBuffering' to your main function
04:12:29 <bennofs> jamil_1: You need to import System.IO for this function
04:12:37 <bennofs> s/stding/stdin/
04:12:55 <bennofs> :t hSetBuffering
04:12:56 <lambdabot> Not in scope: `hSetBuffering'
04:13:03 <bennofs> @let import System.IO
04:13:05 <lambdabot>  Defined.
04:13:07 <bennofs> :t hSetBuffering
04:13:07 <lambdabot> Handle -> BufferMode -> IO ()
04:13:23 <foobar__> is there any method to flush out things in buffer
04:13:31 <bennofs> :t hFlush
04:13:32 <lambdabot> Handle -> IO ()
04:13:37 <foobar__> cool
04:15:03 <jamil_1> thanks bennofs its working now
04:15:14 <jamil_1> though I had to set it for stdout
04:15:32 <bennofs> woops, right :)
04:17:44 <navaati> hi
04:18:11 <navaati> is ghc 7.8 finally gonna be released in 2013 ?
04:19:14 <navaati> (santa please !)
04:26:33 <bennofs> navaati: Well, you can help: https://ghc.haskell.org/trac/ghc/query?status=!closed&milestone=7.8.1&order=priority
04:31:14 <m1dnight> hurrah, i have users in a database
04:31:15 <m1dnight> hurrah!
04:31:20 <m1dnight> merrryyyyy christmas!
04:31:28 <m1dnight> ./endmsg
04:31:46 <Taneb> m1dnight, are you in New Zealand or a similar time zone?
04:34:03 <navaati> bennofs: ouch, far from my skill level oO. Would giving money speed up things ^^ ?
04:34:37 <Iceland_jack> :t merryChristmas
04:34:38 <lambdabot> Channel -> Xmas ()
04:34:42 <Iceland_jack> :t merryChristmas "#haskell"
04:34:43 <lambdabot> Xmas ()
04:34:54 <BoR0> > merryChristmas "#haskell"
04:34:55 <lambdabot>  No instance for (GHC.Show.Show (L.Xmas ()))
04:34:55 <lambdabot>    arising from a use of `M129495805577884030815517.show_M1294958055778840308...
04:34:55 <lambdabot>  Possible fix:
04:34:55 <lambdabot>    add an instance declaration for (GHC.Show.Show (L.Xmas ()))
04:35:03 <bennofs> :i Xmas
04:35:12 <bennofs> :t Xmas
04:35:13 <lambdabot> Not in scope: data constructor `Xmas'
04:35:21 <BoR0> @src merryChristmas
04:35:21 <lambdabot> Source not found. Whoa.
04:35:26 <bennofs> What is Xmas?
04:36:03 <Iceland_jack> bennofs: Good question!
04:36:30 <m1dnight> Taneb: no, Belgium!
04:38:35 <aristid> m1dnight: is the evening of the 24th the important one in belgium as well?
04:39:22 <BoR0> :t (merryChristmas >>=)
04:39:23 <lambdabot> Not in scope: `merryChristmas'
04:39:42 <BoR0> :t merryChristmas
04:39:42 <lambdabot> Not in scope: `merryChristmas'
04:39:46 <BoR0> so it's gone now
04:40:35 <m1dnight> aristid: yeah, we celebrate it the evening of the 24th
04:40:36 <Iceland_jack> Christmas greetings are fickle creatures
04:40:44 <m1dnight> because on the 25th everybody has a holiday
04:40:55 <m1dnight> so you can get shitfaced and sleep it off
04:41:10 <m1dnight> I don't do that though. I have exams :(
04:41:10 <Taneb> That sounds... very pragmatic
04:41:46 <m1dnight> haha :p
04:41:48 <m1dnight> it's just the way
04:42:06 <aristid> m1dnight: which language part of belgium are you in?:D i wonder if those christmas traditions differ between the two
04:42:53 <m1dnight> flemish part o/
04:43:00 <m1dnight> I don't think they differ all that much
04:43:18 <aristid> m1dnight: ok so the flemish part doesn't do it the same way as the crazy dutch people do
04:44:31 <m1dnight> ooh you mean Netherlands
04:44:45 <m1dnight> or what?
04:45:24 <aristid> m1dnight: yes, the netherlands contain dutch people
04:46:00 <m1dnight> yeah, but the netherlands aren't "part of belgium" :p
04:46:06 <m1dnight> they are a different country :D
04:47:49 <aristid> m1dnight: yes but same language (different dialects) as the flemish part of belgium
04:48:04 <aristid> m1dnight: so i was wondering if the flemish part of belgium shares christmas traditions with the netherlands
04:48:17 <satoshi_nakom0t0> yea
04:48:35 <sipa> i am unfamiliar with the dutch ones, being flemish myself
04:48:49 <sipa> but i expect them to be similar
04:49:09 <aristid> i find the dutch ones to be confusing, but i think sinterklaas with the zwarte piets is the more important date there
04:49:33 <sipa> ah, sinterklaas & zwarte piet also exist in belgium
04:49:47 <Wardje> and is also more important that xmas for the children
04:49:50 <Wardje> than*
04:50:09 <sipa> though i believe in .nl it is mostly on dec 5th, while in .be it's mostly dec 6th
04:51:21 <aristid> and in wallonia they also have zwarte piet?:)
04:51:50 <sipa> no idea
04:54:13 <sipa> apparently they have a similar character, though not black
04:54:21 <sipa> according to wikipedia
04:54:48 <aristid> heh
05:44:06 <zett_zelett> I want to calculate primes efficiently.
05:45:02 <Hodapp> sieve!
05:46:44 <mauke> wget
05:49:17 <aristid> mauke: that is not very efficient for small primes.
05:49:23 <zett_zelett> http://lpaste.net/7291379679917768704
05:49:27 <zett_zelett> I have two approaches.
05:49:43 <zett_zelett> I want to understand why the first one is less efficient.
05:50:12 <benmachine> zett_zelett: x ++ [y] is always a performance red flag for me
05:50:27 <benmachine> zett_zelett: ++ takes time proportional to the length of the left-hand list
05:50:36 <benmachine> so biglist ++ smalllist does not very much, slowly
05:53:08 <zett_zelett> benmachine: I donâ€™t think that this is it. However, I can try and change it to y:x.
05:53:26 <benmachine> zett_zelett: that won't really work, because your algorithm assumes they are in ascending order
05:54:02 <benmachine> but indeed that might not be it
05:54:02 <benmachine> just my first instinct
05:55:43 <zett_zelett> benmachine: It does not assume they are in ascending order?
05:56:01 <benmachine> zett_zelett: ahh, you're right
05:56:20 <benmachine> I read "filter" as "takeWhile"
05:56:23 <benmachine> well, that's probably the reason then :P
05:56:29 <benmachine> or at least, that's another thing
05:56:47 <zett_zelett> I think the problem might be that buildList might not share the list l.
05:57:26 <benmachine> in what sense could it share it?
05:58:11 <zett_zelett> I was thinking, that it might recalculate the list for the argument h:l (or l ++ [h]).
05:58:22 <benmachine> it won't
05:58:27 <zett_zelett> Okay.
05:59:56 <zett_zelett> Background: I wanted to solve problem 10 from project Euler.
06:00:32 <zett_zelett> So I need to calculate primes fast, but I canâ€™t manage to calculate them fast enough.
06:07:10 <bernalex> I use concatMap foo bar. bar returns [a], and foo is [a] -> String. how do I append (++) something to each result of foo?
06:08:29 <bernalex> as an example, if concatMap foo bar returns "two" and "words", and concatmap makes this "twowords", how do I a " " to each result, making this "two words "?
06:08:53 <Hafydd> bernalex: concatMap ((++" ").foo) bar
06:09:25 <bernalex> Hafydd: aha. great! thanks.
06:09:38 <Hafydd> Or: concat $ intersperse " " $ map foo bar -- if you don't want the trailing space.
06:12:29 <tromp> or tail . concatMap (' ':)
06:12:46 <tromp> tail . concatMap ((' ':) . foo)  i mean
06:13:10 <tromp> but intersperse clearer...
06:14:08 <Hafydd> Or, indeed, just "unwords" instead of concat . intersperse " "!
06:21:20 <bernalex> OK I don't know how to fix this problem
06:22:08 <bernalex> I have an xs that's [(String, String)], and want to run foo on every fst xs and bar on every snd xs. any ideas?
06:23:03 <bernalex> the thing I started before having the realisation that it wouldn't work per se is: concatMap ((++"tst\n").formatCounter) counters
06:23:19 <bernalex> where counters = map (count . snd) xs
06:23:40 <bernalex> so in the ++"tst\n", the corresponding fst xs should be.
06:24:18 <dv-> > map (\(a,b) -> (?foo a, ?bar b)) ?xs
06:24:19 <lambdabot>  mueval-core: internal error: PAP object entered!
06:24:19 <lambdabot>      (GHC version 7.6.3 for x86_64_unknown_linux)
06:24:19 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
06:24:39 <dv-> ha
06:26:56 <aristid> :t ?dv
06:26:56 <lambdabot> (?dv::t) => t
06:27:15 <bernalex> dv-: I'll look into it, thanks
06:32:57 <bernalex> dv-: works fine now that I wrapped my head around it. thanks for the idea.
06:33:11 <yitz> > map (map toUpper *** map toLower) [("Hello","There"),("Mr.","Bernalex")] -- bernalex
06:33:12 <lambdabot>  [("HELLO","there"),("MR.","bernalex")]
06:33:48 <Hafydd> > map (uncurry $ on (,) reverse) [("I","am"), ("the","very"), ("model","of"), ("a","modern"), ("Major","General")]
06:33:49 <lambdabot>  [("I","ma"),("eht","yrev"),("ledom","fo"),("a","nredom"),("rojaM","lareneG")]
06:34:27 <yitz> Hafydd: doesn't bernalex want to run a *different* function on each component?
06:34:49 <Hafydd> Oh, then I misread.
06:37:22 <osa1> I can't find index page of haddock documentations in cabal-sandbox folder, where can I find it or how can I generate it?
06:38:48 <osa1> projects have their own haddock files generated in .cabal-sandbox/share/doc/<my platform>/<project>/html
06:39:48 <Feuerbach_> osa1: yeah, it's not generated atm
06:39:55 <Feuerbach_> there's an issue at github about that
06:40:57 <osa1> Feuerbach_: do you know which issue?
06:42:34 <Feuerbach_> https://github.com/haskell/cabal/issues/1337
06:44:18 <osa1> uh .. opened 7 months ago
06:47:02 <notdan> osa1: well there is a milestone
06:47:41 <notdan> ugh why the fuck is github hijacking my keyboard :|
06:49:39 <goraci> hi strange behavior at GHCI can someone explain this ? double x = x*2
06:49:39 <goraci> <interactive>:2:10: parse error on input `='
06:50:32 <quicksilver> yes, that's a definition to put in a file
06:50:43 <quicksilver> ghci isn't a file, you mostly evaluate expressions or run commands in it
06:50:54 <quicksilver> you can type "let double x = x*x2" though
06:51:15 <goraci> ah ok thanks
06:55:28 <AlainODea> goraci: for the most part ghci's prompt is like a do block.  You pretty much use the syntax you'd use inside a main function or any other IO action
06:57:07 <quicksilver> or not
06:57:10 <quicksilver> or just plain expressions
06:57:15 <quicksilver> which is how I use it 99% of the time
06:58:10 <AlainODea> quicksilver: true. You can do IO too though.  It's not limited to pure code
06:58:27 <saml> what kind of IO are you doing?
06:58:38 <goraci> ok thanks since it's io it pretty obvious then
06:58:59 <saml> > double x = x*2
06:59:00 <lambdabot>  <hint>:1:10: parse error on input `='
06:59:11 <saml> > let x = x*2
06:59:12 <lambdabot>  not an expression: `let x = x*2'
06:59:25 <augur_> morning party people!
06:59:44 <quicksilver> AlainODea: yes, I am aware of that :)
07:00:02 <saml> > let x = x*2 in x -- please x = 0
07:00:05 <lambdabot>  mueval-core: Time limit exceeded
07:00:10 <goraci> haha but in imperative lang this - x = x*2 100% legit )
07:00:28 <saml> i thought haskell can deduce x to be 0
07:00:31 <saml> maybe it was guard
07:02:34 <bernalex> for performance, what should I use for a wc implementation for file contents? I assume string is pretty much the worst I could use
07:03:50 <aristid> bernalex: Text
07:03:58 <aristid> assuming you care about unicode
07:04:00 <bernalex> aristid: that was my inital guess as well. thanks.
07:04:07 <bernalex> aristid: hmmm. I might? it's wc.
07:04:23 <aristid> if you want to count characters and not bytes, yes.
07:04:34 <AlainODea> bernalex: I would reach for memory mapped IO, but it's inconvenient and you'd need to factor in memory limits and slicing
07:04:34 <bernalex> I want to count chars, yes.
07:04:39 <bernalex> so Ã¦ should be one char, not two.
07:04:56 <aristid> bernalex: wc -c counts bytes :)
07:05:09 <aristid> but wc -m does indeed count characters
07:05:15 <bernalex> aristid: I want wc w/o options.
07:05:24 <bernalex> and that counts chars, words and lines.
07:05:40 <aristid> The
07:05:41 <aristid>      default action is equivalent to specifying the -c, -l and -w options.
07:05:47 <bernalex> AlainODea: I want something that doesn't require any wild tricks. actually, I'm quite happy to use string.
07:06:00 <aristid> bernalex: no the default counts bytes, words and lines
07:06:05 <bernalex> aristid: oh, really
07:06:08 <AlainODea> bernalex: scratch mmap then ;)
07:06:18 <aristid> bernalex: maybe you really want characters anyways?
07:06:26 <aristid> because screw wc let's do this properly!
07:06:30 <bernalex> AlainODea: indeed. echo 'Ã¦' | wc says "3".
07:06:45 <aristid> you can call me aristid
07:07:03 <bernalex> aristid: I want my coreutils implementation (starting with wc) to replicate GNU coreutils, but I'm happy to make improvements, heh.
07:07:05 <bernalex> aristid: yes, sorry.
07:07:15 <AlainODea> bernalex: one for each byte of Ã¦ an one for the newline
07:07:22 <bernalex> AlainODea: yep.
07:07:43 <bernalex> aristid: using chars instead of bytes would make more sense IMO, so maybe do it "right", heh.
07:08:46 <aristid> bernalex: ok, just _how_ right do you want to do it?
07:08:47 <bernalex> aristid: the thing is though that I want this code to be super newbie friendly and usable for tutorials. it's just to give newbies some insight in how a haskell program might look. so if unicode means a bunch of headaches and non-intuitive code for newbies, then I might drop it. I'm not very worried about performance. it would just be neat to not be two orders of magnitude slower than wc.
07:09:01 <aristid> bernalex: do you want to eliminate combining characters? :)
07:09:11 <AlainODea> bernalex: wc -U8 seems to be the way to do UTF-8
07:09:18 <bernalex> so as right as I can get without making the program more than a (full hd) screenful.
07:09:46 <aristid> bernalex: ah just using Text should do the trick then i think
07:09:48 <bernalex> AlainODea: I'm not duplicating any options right now. as mentioned, it's meant to be a "here's a really small haskell program, so you can see how we use it in practice".
07:10:10 <bernalex> so I want to duplicate all of coreutils without any options. just tiny illustrative programs.
07:10:29 <AlainODea> bernalex: makes sense.  I was fishing for the option that would make wc a good reference for you Haskell character counter
07:10:33 <bernalex> of course I don't know if anyone will *care* about this, or if it's a good idea, and so forth. but hey, at least I'll learn some myself. :-P
07:11:20 <AlainODea> bernalex: learning is more important that usefulness unless someone's paying for usefulness and you're on the clock
07:17:18 <goraci> what mainstream web framework now in Haskell ? Yesod ?
07:21:22 <bernalex> hm. anyone know of a practical example with using Text? in my own code I just do mapM readFile files and send them to a function that takes FileContent, which is typed to String.
07:21:32 <AlainODea> goraci: Snap and Yesod are the ones I've tried. In my opinion, Snap is well-suited to REST and Yesod is well-suited to full-stack (Rails-style) applications.
07:22:45 <goraci> AlainODea: i found Snap very different from Yesod though, it uses Snaplets and it's architecture more like Lift in scala
07:22:48 <bernalex> ah, there are readFile functions that are FilePath -> IO Text
07:22:52 <AlainODea> bernalex: the Data.Text variants usually have hGet* functions that directly read from a Handle (like stdin) to the internal Text representation
07:23:53 <AlainODea> goraci: Yep. Snap and Yesod take very different approaches
07:24:02 <aristid> bernalex: i believe that function will load the entire file into memory, but for a small demonstration program that should be fine
07:24:13 <bernalex> aristid: there is a lazy one as well
07:24:14 * implementation throws happstack in
07:25:02 <AlainODea> bernalex: the Lazy Data.Text variants may solve the memory issue. There are a few blogs kicking around about performance tuning of character IO in Haskell. They escape me at the moment
07:25:11 <aristid> bernalex: ah, true
07:25:27 <aristid> bernalex: and for something as simple as wc, real error handling isn't needed anyways
07:25:43 <bernalex> hm. how do I import something as? i.e. I don't want qualified, I want to import Foo.Bar (foobar as fubar).
07:26:12 <bernalex> where foobar is a function in the Foo.Bar module.
07:26:27 <geekosaur> you can't
07:26:36 <bernalex> ahmagahwd haskell
07:26:43 <bernalex> just when I thought you were perfect
07:26:54 <geekosaur> but you can import it qualified and then assign it in your module
07:27:01 <AlainODea> bernalex: import qualified the module and then define a function with the name you want
07:27:10 <bernalex> yes, I realise this is what I have to do.
07:27:15 <AlainODea> geekosaur: I lost the race :D
07:31:01 <aristid> bernalex: you could switch to agda! it can do that :D
07:31:43 <bernalex> uhm is there not a T.Text? readFile returns Text, so I thought I could set type FileContent = T.Text
07:32:51 <quicksilver> thre is T.Text if you imported Data.Text as T, yes.
07:33:02 <quicksilver> but if you important Data.Text as Fish, the type is Fish.Text
07:34:01 <bernalex> oh, I was being silly. I hadn't imported Data.Text, only Data.Text.Lazy.IO
07:36:22 <bernalex> Couldn't match type `Text' with `Text'
07:36:22 <bernalex> || Expected type: Text -> Text
07:36:23 <bernalex> ||   Actual type: Text -> Text
07:36:23 <bernalex> errrrrr
07:37:37 <geekosaur> er, usually ghc is better about that. probably one is strict and one is lazy
07:38:05 <geekosaur> btu ghc usually adds enough qualification to be able to distinguish them
07:38:11 <bernalex> geekosaur: it was expecting Data.Text not Data.Lazy.Internal, so yeah. but a bit wtf to see a bunch of those errors.
07:44:47 <AlainODea> bernalex: I have found type errors with Data.Text to be very confusing.  I am still relying mostly on luck or existing code particularly when the OverloadedStrings language extension is enabled
07:47:43 <bernalex> ok so now my code looks horrible with a bunch of T.blah TT.blah and TIO.blah. lol.
07:48:11 <bartavelle> you can import all the text thingies under T, so that you just have T
07:48:36 <bernalex> oh ffs
07:48:44 <bernalex> TT.words is not compatible with lazy text
07:48:58 <bartavelle> :)
07:49:15 <bernalex> ah. lazy words is in Data.Text.Lazy, not Data.Text.Lazy.Internals.
07:49:45 <geekosaur> in general you don't want to import a .Internals module directly unless you're working on the internals
07:49:59 <geekosaur> the actual type comes from there, yes, but it is re-exported by the public module
07:50:36 <bernalex>  Couldn't match expected type `Int' with actual type `Int64'
07:50:42 <bernalex> everything is terrible
07:51:40 <AlainODea> bernalex: where is it expecting Int?
07:52:07 <bernalex> evidently you can't use regular length you need TTTTLOMSRCOHCSRO.length.
07:52:44 <AlainODea> :t length
07:52:45 <lambdabot> [a] -> Int
07:52:58 <AlainODea> :t Data.Text.length
07:52:58 <lambdabot> Data.Text.Internal.Text -> Int
07:53:40 <bernalex> using prelude length with lazy Text gives Couldn't match expected type `[a0]' with actual type `Text'
07:53:53 <bernalex> so I use Data.Lazy's length, but that returns Int64
07:54:06 <bernalex> *Data.Text.Lazy
07:54:22 <bernalex> there's a Data.Text length, but that doesn't take lazy Text.
07:55:01 <AlainODea> bernalex: isn't lazy Text an instance of the Text typeclass.  I'm guessing here as I'm on my phone
07:55:52 <bernalex> AlainODea: I'm not sure. all I know is I got a billion "omg you sent Text -> Text but I expected Text -> Text" previously, so maybe not.
07:57:50 <AlainODea> bernalex: my brain just exploded when I hoogled Data.Text and looked at the source.  It does some significant gymastics internally
07:59:19 <geekosaur> there is no Text typeclass
07:59:56 <bernalex> MEH. I'm going to go eat pinnekjÃ¸tt with tatoes and purÃ©ed kohlrabi.
08:00:21 <bernalex> maybe after I've had enough beers I can fix this mess.
08:01:19 <aristid> bernalex: pureed kohlrabi cannot be fixed.
08:02:40 <AlainODea> geekosaur: you are correct.  It appears that there is a common stream data structure being used under the hood.  I took a wild guess, it was a bad guess :)
08:03:58 <bernalex> I got so lost trying to rewrite my program that my laptop ran out of power, and I had to boot it for the first time in months.
08:05:23 <aristid> bernalex: about your problem with Text's length being an Int64: fromIntegral can convert between Int and Int64 (in both directions).
08:05:43 <bernalex> aristid: I'm writing that down in a random terminal for after dinner -- thanks!
08:09:33 <Eduard_Munteanu> Interesting... I wasn't aware 'forall f. (forall x. Foo (f x) => ...)' was different from 'forall f x. Foo (f x) => ...'. Makes sense though.
08:09:57 <quchen> Eduard_Munteanu: What's the difference?
08:10:53 <Saizan> Eduard_Munteanu: is it?
08:10:58 <Tekmo> Yeah, it's not obvious to me why they are different either
08:11:35 <Eduard_Munteanu> The former can be instantiated to forall f. Foo (f X) for some X.
08:11:36 <aristid> hi Tekmo !
08:11:51 <Tekmo> aristid: Hi!
08:11:52 <Tekmo> How are you doing?
08:11:55 <aristid> hi Eduard_Munteanu as well :D
08:11:57 <aristid> Tekmo: fine
08:12:00 <Eduard_Munteanu> aristid: hey
08:12:06 <mekeor> hello :)
08:12:13 <aristid> Tekmo: you?
08:12:18 <Tekmo> aristid: Great!
08:12:30 <Saizan> Eduard_Munteanu: i'd expect the latter too
08:13:11 <aristid> Eduard_Munteanu: can you show a code example? i find this confusing :)
08:13:32 <Eduard_Munteanu> Ok, let me find a simple example.
08:13:52 <Tekmo> Eduard_Munteanu: So if I understand this correctly, the issue is that for the former you can't partially apply it to some type `x` because of the nesting, whereas the latter allows you to "commute" the `f` and `x`?
08:15:30 <Eduard_Munteanu> Tekmo: yes, not sure how to interpret it
08:20:52 <bitonic> I vaguely remember a feature that let you specify which package to import a module as part of the import statement
08:21:09 <bitonic> like some sort of pragma.  did I imagine that?
08:21:51 <Eduard_Munteanu> bitonic: see PackageImports
08:21:54 <bennofs> no. It's called PackageImports
08:22:20 <bennofs> bitonic: see http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/syntax-extns.html#package-imports
08:22:41 <bitonic> Eduard_Munteanu, bennofs: danke
08:33:45 <joelteon> does anybody know what package "logStrBuilder" is supposed to be from, or how I find out? no results in hoogle or hayoo, and it's making wai-extra not build.
08:35:01 <Tekmo> joelteon: The `fast-logger` package
08:35:12 <joelteon> thank you, Tekmo
08:35:17 <joelteon> apparently 2.0.3 stopped exporting it
08:35:22 <Tekmo> The way I found out was to Google "hackage logStrBuilder"
08:35:27 <joelteon> I had just discovered that when you told me
08:35:35 <joelteon> yeah, sometimes my google-fu is not so strong
08:35:54 <Tekmo> joelteon: I find that either "hackage <query>" or "haskell <query>" works most of the time
08:36:17 <joelteon> Okay, cool
08:36:27 <Hafydd> Just searching for the name, verbatim, of what you're asking about is "google-fu" now.
08:36:28 <quchen> Google often links to outdated package versions though
08:36:33 <joelteon> Oh, actually, googling logStrBuilder gives me fast-logger as the *first result*.
08:36:50 <joelteon> maybe I should've googled it.
08:48:43 <Eduard_Munteanu> Hm, might have been a false alarm.
08:53:47 <quchen> Eduard_Munteanu: The forall thing?
08:54:06 <Eduard_Munteanu> quchen: yes
08:54:12 <Eduard_Munteanu> Perhaps I should state my purpose...
08:54:18 <quchen> So I can stop being confused? :-)
08:55:38 <Eduard_Munteanu> I'm trying to quantify over type functions 'f :: k -> * -> *' which are functorial for all types in the first argument.
08:56:39 <Eduard_Munteanu> It seems to me   forall f k. Functor (f k) => ...   isn't quite it.
08:57:34 <benmachine> Eduard_Munteanu: what do you mean by the first argument?
08:57:39 <Eduard_Munteanu> Because if Functor (f Foo), but not Functor (f Bar), it quantifies over the former.
08:57:39 <ski> sounds like you want `forall f. (forall k. Functor (f k)) => ..f..' ?
08:57:52 <Eduard_Munteanu> ski: yep, something like that
08:58:22 <ski> (btw, note that this `k' isn't the same as the above `k')
08:58:55 <Eduard_Munteanu> benmachine: e.g. data Tag = Foo | Bar, newtype TaggedMaybe (tag :: Tag) a = TaggedJust a | TaggedNothing
08:58:56 <ski> so perhaps you really want `forall f. (forall (k :: *). Functor (f k)) => ..f..' (or replacing `*' with some other kind, perhaps a kind variable)
08:59:39 <ski> Eduard_Munteanu : imo, higher-rank constraints would be quite useful in some circumstances
08:59:47 <Eduard_Munteanu> ski: I think so, does that work? the parens on the lhs of => would be a constraint, but it seems malformed
09:00:14 <ski> afaik, GHC doesn't currently implement such constraints, no
09:00:18 <Eduard_Munteanu> I've tried it before and it worked but I was mistakenly shadowing another variable.
09:01:30 <Eduard_Munteanu> Then something like   forall f. (forall (k :: k). Functor (f k) => ()) -> ...   should work but it doesn't seem enough either.
09:07:15 <epta> How to get IO [y] from IO [x] and (x -> IO (Maybe y)) ? List and Maybe collapsed bacause of dropped Nothing's
09:08:04 <Feuerbach> epta: hint: catMaybes
09:08:26 <epta> Feuerbach: yep, it's the simplest part
09:09:00 <benmachine> if f :: x -> IO (Maybe y) then mapM f :: [x] -> IO [Maybe y]
09:09:01 <Feuerbach> the other parts are >>= and mapM
09:09:26 <benmachine> and fmap catMaybes :: IO [Maybe y] -> IO [y]
09:10:03 <yitz> epta: fmap catMaybes $ theIOx >>= mapM f
09:11:20 <yitz> epta really wants mapMaybeM, but that's not defined anywhere currently.
09:14:08 <epta> :t fmap catMaybes (undefined :: IO [x]) >>= mapM (undefined :: x -> IO (Maybe y))
09:14:09 <lambdabot> IO [Maybe y]
09:14:20 <epta> Not IO [y]
09:15:03 <epta> :t fmap catMaybes $ (undefined :: IO [x]) >>= mapM (undefined :: x -> IO (Maybe y))
09:15:04 <lambdabot> IO [a]
09:18:04 <yitz> @type catMaybes
09:18:04 <lambdabot> [Maybe a] -> [a]
09:23:21 <yitz> @quote JohnMcCarthy
09:23:22 <lambdabot> JohnMcCarthy says: LISP will become obsolete when someone makes a more comprehensive language that dominates LISP practically and also gives a clear mathematical semantics to a more comprehensive set of features.
09:26:57 <Eduard_Munteanu> Is there an abstraction for tagged functors, namely 'f :: k -> * -> *' such that given any 'a :: k', Functor (f a)? The closest I found so far is Joker from Data.Bifunctor.Joker, but I'd like a typeclass / polymorphic abstraction.
09:29:50 <yitz> aha, here's another great quote from McCarthy's "History of LISP" (1979):
09:29:56 <yitz> At the time, it seemed dubious to regard the latter operation as a function, since its value depended on the contents of memory at the time the operation was performed, so it didn't act like a proper mathematical function. However, the advantages of treating it grammatically as a function so that it could be composed were also apparent.
09:30:21 <yitz> And so began the confusion about what a "function" is in programming!
09:32:20 <aristid> yitz: now if we had a time machine to tell mccarthy what to do... haskell what have been invented 3 decades earlier
09:32:28 <aristid> -what+would
09:32:33 <ski> (hm, doesn't SICP talk call them procedures ?)
09:32:45 <ski> (s/talk call/call/)
09:34:41 <JonFairbairn> Anyone know about characterset problems in Network.CGI?
09:34:43 <yitz> aristid: right. we just needed to tell him that this notion of "function" would soon be adopted in a myriad of FORTRAN-like languages where even the composability is lost.
09:35:28 <yitz> actually, later McCarthy was on the Algol committee, and that didn't seem to bother him.
09:36:05 <aristid> oh noes
09:36:10 <JonFairbairn> Until recently my code worked: getInput for a request containing %E2%80%99 would return an apostrophe, but now it just gives me one byte
09:36:33 <yitz> JonFairbairn: which library?
09:36:57 <JonFairbairn> yitz, cgi-3001.1.7.5
09:38:22 <JonFairbairn> yitz, (same problem with cgi-3001.1.8.4)
09:42:37 <yogert> Using the Aeson library, how can I recover from a parser failure? For instance, the (.:?) operator only seems to take affect when a field is absent, or "null". What about when it is of the wrong type?
09:42:51 <yitz> JonFairbairn: The Unicode character obtained by utf-8 decoding "\xE2\x80\x99" is Unicode Character 'RIGHT SINGLE QUOTATION MARK' (U+2019) 8217
09:43:42 <yitz> JonFairbairn: so apparently cgi now treats those escape sequences as utf-8.
09:45:14 <yogert> I'd like to parse something that looks like "{ \"foo\": { \"bar\": 1 }}", but there are cases where the inner object is empty, causing the parser to fail: {"foo":{}}
09:46:29 <JonFairbairn> yitz, Yes, thatâ€™s what I would expect. But what I get is not â€™ but |
09:47:13 <yitz> JonFairbairn: speaking of unicode - just tried changing to a nick with Ã³ in it and freenode wouldn't allow it. grr.
09:47:50 <JonFairbairn> yitz, Thatâ€™s why Iâ€™m not JÃ³nFairbairn on here!
09:49:59 <yitz> JonFairbairn: a vertical bar? weird.
09:50:25 <yitz> JonFairbairn: so i misunderstood. it used to treat it as utf-8 but now does the wrong thing?
09:51:11 <JonFairbairn> yitz, Actually, not a vertical bar (124) but character 25 (which comes out looking like vertical bar on my terminal)
09:52:14 <JonFairbairn> yitz, Yes. It used to work, but now doesnâ€™t. Unfortunately Iâ€™m not sure what changed. I updated various libraries at various times for various reasons, and it was only when I happened to recompile this web app that I noticed the problem)
09:52:25 <yitz> yogert: i believe that when .:? fails to parse what it is expecting, that is considered not present and you'll get a Nothing
09:52:54 <Hafydd> > chr 25
09:52:55 <lambdabot>  '\EM'
09:53:06 <Hafydd> > text $ chr 25
09:53:07 <lambdabot>  Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
09:53:08 <lambdabot>  Expected type: GHC.Base.String
09:53:08 <lambdabot>    Actual type: GHC.Types.Char
09:53:44 <Hafydd> > text $ [chr 25]
09:53:47 <yitz> @type showHex
09:53:48 <lambdabot> (Integral a, Show a) => a -> ShowS
09:54:19 <yitz> > showHex 25 . ("," ++) . showHex (25+128) $ ""
09:54:21 <lambdabot>  "19,99"
09:54:24 <yitz> aha
09:54:32 <yitz> it's the %99
09:54:40 <JonFairbairn> Yes.
09:55:23 <JonFairbairn> So itâ€™s just giving me the bottom byte.
09:56:52 <Hafydd> yitz: I'm pretty sure that if that were allowed, it would break a lot of clients.
09:57:54 <Hafydd> which are not prepared to perform case-insensitive Unicode matching.
09:58:24 <Hafydd> And perhaps a more compelling reason is that it's not easy for everyone to type such a nick.
09:58:33 <yogert> yitz: Well it seems cause the parse of the entire object to fail. What I'm looking to do is have Aeson treat conflicting types as it does "null", allowing me to treat the field as a Maybe.
09:59:24 <rose__> in ordinary case statements, you can have multiple cases fall through to the same action. Is there an equally clean way to do that in Haskell?
09:59:27 <geekosaur> it's not just that, but that IRC doesn't really have the concept of encoding --- some poeple use utf8, some use iso8859-1, etc.
09:59:30 <rose__> *ordinary languages
09:59:34 <geekosaur> oh waiut
09:59:42 <geekosaur> similar discussion iin two different channels, oops
09:59:54 <geekosaur> oh no, that was here too
10:00:04 * geekosaur could have used more sleep last night...
10:00:05 <aristid> geekosaur: some clients automatically detect if a line is not valid utf8 and if so, fall back to iso8859-1 or so :)
10:00:09 <aristid> sleep is good
10:00:13 <geekosaur> yes, mine being one of them
10:01:44 <JonFairbairn> rose__, I wouldnâ€™t call that behaviour clean. You can the same function in each case that you want to be the same
10:07:30 <ParahSailin> when i upload a package to hackage, do i have to do something to make the haddock docs appear?
10:08:00 <yitz> yogert: so just get it as a generic value and then let your code examine it itself
10:08:28 <ParahSailin> or does haddock get generated for packages on its own?
10:08:40 <geekosaur> docs will be generated
10:08:47 <yitz> JonFairbairn: looked at the cgi source. no utf-8 decoding going on there, just % unescaping.
10:08:48 <geekosaur> unless there's some dependency missing
10:09:14 <yitz> JonFairbairn: so this change has to do with your environment - web server, locale, etc. - not the cgi library.
10:09:46 <JonFairbairn> yitz, Thanks. But surely the % unescaping should give me all the bytes, not just the bottom one.
10:09:53 <yitz> indeed
10:11:24 <yitz> JonFairbairn: use queryString to get the original %-escaped query string to verify that you are getting what you think from the server.
10:12:08 <JonFairbairn> Already tried that. It does, and if I run formDecode over it, I get the proper unicode characters.
10:12:30 <yitz> this is beginning to become quite mysterious
10:12:47 <JonFairbairn> yitz, True
10:14:04 <yitz> JonFairbairn: well perhaps can you just go that route then if it works?
10:15:33 <JonFairbairn> yitz, I was contemplating that when I posted here. It seems odd that I would have to do that.
10:16:04 <yitz> JonFairbairn: the cgi library doesn't get very much attention these days. people tend to prefer the many other non-cgi ways of putting up a simple web service these days.
10:16:29 <JonFairbairn> Ah, I see.
10:16:35 <yitz> JonFairbairn: on the other hand, cgi is still in the platform, so if you bring a bug to light you are doing a great service.
10:16:39 <JonFairbairn> This is quite old code of mine.
10:17:09 <yitz> JonFairbairn: yes. i have plenty of old cgi code like that too :)
10:17:18 <JonFairbairn> yitz, who should I report it to? I emailed andersk a while ago but got no response.
10:17:48 <yitz> JonFairbairn: that's even a greater service to point out. report it on the haskell-platform mailing list.
10:17:55 <JonFairbairn> OK
10:24:33 <yogert> yitz: Hmm, sorry but I'm not sure I follow. Do you mean just parsing the string to the Aeson JSON representation, and handle it myself?
10:24:44 <yogert> Without using the Parser monad?
10:24:48 <yitz> Hafydd: all true. but small consolation for people whose names contain such characters, like JÃ³nFairnbairn.
10:28:16 <yitz> yogert: you can decode it as an aeson Object, then you can look inside the object and see what you've got.
10:28:51 <yitz> decode theJSON :: Maybe Object -- instead of Maybe Int or whatever
10:28:55 <yogert> yea
10:29:28 <yitz> yogert: that will be more work to deal with though of course.
10:30:30 <yogert> And that is the only solution you are aware of? The object has something like 55 fields. : / I was hoping to avoid all of that. For awhile I was looking for a way to get the Aeson.TH module to handle this heh
10:31:26 <yitz> yogert: the haddock for .:? says: Retrieve the value associated with the given key of an Object. The result is Nothing if the key is not present, or empty if the value cannot be converted to the desired type.
10:31:54 <yitz> yogert: so if the value of the field isn't the right type, the parse will fail.
10:31:58 <bernalex> what's the most efficient type of numbers to use? I only need whole numbers, and reasonably small (likely less than a million)
10:32:40 <yogert> Yeah. I just figured there might be an easy way to achieve the desired effect.
10:34:58 <benzrf> hi
10:35:02 <yitz> yogert: you can break the parse into smaller pieces and use decode or decodeEither on each piece if you need different behavior when different pieces fail.
10:35:03 <benzrf> I don't know anything about arrows...
10:35:12 <benzrf> but they are meant to represent things that act like functinos, right?
10:35:13 <benzrf> *functions
10:36:17 <yitz> bernalex: people generally use Int for that, since it best fits whatever platform you're on.
10:36:26 <bernalex> yitz: OK
10:36:28 <bernalex> thanks
10:36:57 <yitz> bernalex: if you really need super speed, you can get hacky and look up how to use GHC unboxed primitives.
10:37:17 <bernalex> yitz: I just want the speediest that's really really cheap. the code is for newbies.
10:37:39 <yogert> yitz: Okay, Ill give that a shot. Thanks for the help, I really appreciate it. : )
10:38:25 <yitz> bernalex: so go with Int. but remember that they silently do weird things if they get much bigger than your range.
10:38:48 <bernalex> yitz: I think it should be fine. it's an illustrative program for newbies either way.
10:38:52 <benzrf> > (first (+1)) (3, "hi")
10:38:53 <lambdabot>  (4,"hi")
10:38:56 <benzrf> o:
10:39:50 <yitz> benzrf: my use of Control.Arrow is pretty much restricted to first, second, ***, &&&, and >>>.
10:40:04 <yitz> benzrf: for ordinary functions
10:40:17 <benzrf> is there a way to apply arrows?
10:41:05 <bernalex> OK I'm not sure what's going on. why does this not typecheck: concatMap formatFile (zip counters paths) ++ total counters ? total ::  [Counter] -> T.Text, formatFile ::  (Counter, FilePath) -> T.Text, and counters is [Counter] and paths is [FilePath].
10:41:09 <ion> > (3, "hi") ^. _1 +~ 1
10:41:10 <lambdabot>  Could not deduce (GHC.Num.Num
10:41:10 <lambdabot>                      ((GHC.Integer.Type.Integer
10:41:10 <lambdabot>                        -> Control.Lens.Internal.Setter.Mutator GHC.Integer.Ty...
10:41:10 <lambdabot>                       -> s -> Control.Lens.Internal.Setter.Mutator t))
10:41:10 <lambdabot>    arising from the ambiguity check for `e_1311'
10:41:12 <benzrf> >>> is flip .
10:41:12 <benzrf> right?
10:41:21 <yitz> benzrf: each Arrow instance will have its own way of using them. the Arrow typeclass only talks about how to compose them and use them with tuples.
10:41:23 <benzrf> ah
10:41:30 <benzrf> what use is Arrow then?
10:41:30 <ion> > (3, "hi") & _1 +~ 1
10:41:34 <lambdabot>  (4,"hi")
10:41:46 <benzrf> oh wait
10:41:46 <benzrf> ok, I think I follow
10:41:48 <benzrf> that's handy
10:42:10 <benzrf> how are arrows different from categories then?
10:42:44 <yitz> bernalex: formatFile does not return a list so you can't concapMap it
10:42:52 <yitz> *concatMap
10:43:00 <benzrf> concatMap is (=<<) :D
10:43:15 <bernalex> yitz: oh, of course, Text is not a [Char]
10:43:43 <yitz> bernalex: maybe you want T.concatMap
10:43:51 <yitz> bernalex: and <> instead of ++
10:44:45 <bernalex> yitz: what is <> and where is it from?
10:45:16 <yitz> Data.Monoid, an alias for mappend. which for Text is an alias for T.append
10:45:28 <yitz> so you can use any of those really
10:46:07 <bernalex> hm. OK so now I have TT.concatMap formatFile (zip counters paths) `TT.append` total counters
10:46:22 <bernalex> (TT is import qualified Data.Text.Lazy as TT. I will clean that up sometime)
10:47:06 <bernalex> and I get: Couldn't match type `(Counter, FilePath)' with `Char'|| Expected type: Char -> Text||   Actual type: (Counter, FilePath) -> Text|| In the first argument of `concatMap', namely `formatFile'"
10:48:02 <yitz> i might have defined formatFile :: Counter -> FilePath -> T.Text and then written mconcat (zipWith formatFile counters paths) <> total counters
10:50:00 <yitz> bernalex: oh right sorry you can't use T.concatMap for this.
10:50:28 <bernalex> yitz: hoogle doesn't give me anything relevant for <>
10:50:40 <bernalex> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc is the closest
10:50:52 <yitz> bernalex: so use T.concat (map formatFile..., or use zipWith as I did above
10:50:59 <yitz> @type (<>)
10:51:00 <lambdabot> Monoid m => m -> m -> m
10:51:12 <yitz> @hoogle <>
10:51:13 <bernalex> yitz: I have mconcat (zipWith formatFile counters paths) <> total counters
10:51:13 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
10:51:13 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
10:51:13 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
10:51:27 <bernalex> yitz: I'm just trying to figure out where I need to import <> from
10:51:30 <yitz> oh the hoogle database is way behind
10:51:38 <yitz> Data.Monoid
10:51:43 <bernalex> thanks
10:52:44 <bernalex> ouch. now none of my printf's typecheck.
10:53:00 <goraci> how can explain Applicative functor in couple of words )) ?
10:53:06 <goraci> who*
10:53:22 <yitz> bernalex: the nice thing about this syntax is that it will still work if you change the return types of formatFile and total to be Builder instead of Text
10:53:33 <bernalex> yitz: yes, thanks!
10:54:59 <yitz> goraci: it's like a monad, but you can't refer to the results of previous steps in a calculation.
10:56:02 <goraci> A functor is a morphism between categories
10:56:14 <bernalex> so what do you do when you want to print a Text? i.e. what's the common way. I used printf with String previously, but printf takes a String not a Text
10:56:26 <yitz> goraci: the standard idiom for using an Applicative looks like applying a function to several arguments, except with some funny symbols in between.
10:57:42 <yitz> goraci: oh what is the mathematical definition of an applicative category you mean?
10:57:52 <goraci> yitz: well ok that make some sense )
10:57:54 <yitz> s/category/functor/
10:59:29 <goraci> yitz: i am not a mathematician but i like haskell and try to do some stuff with it )
11:00:03 <benzrf> what does an arrow represent that is more than what a category does?
11:01:51 <benzrf> and what the hell are lenses :{
11:02:20 <yitz> goraci: http://en.wikibooks.org/wiki/Haskell/Applicative_Functors
11:02:30 <yitz> @where typeclassopedia
11:02:30 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
11:02:53 <benzrf> goraci: applicatives are more or less meant to define what it means to map a multi-arg function across multiple functors
11:03:08 <goraci> i wonder if every haskeller has master degree in mathematics )
11:03:09 <benzrf> goraci: but it's complicated because you have to account for how the structure of the functors combines
11:03:14 <benzrf> goraci: i'm 16 :3
11:03:18 <Eduard_Munteanu> Lenses are to functional structures what getters/setters are to OO stuff.
11:03:22 <benzrf> but idk if I qualify as a haskeller
11:03:32 <benzrf> Eduard_Munteanu: ive heard that before but I do not understand it at all...
11:03:43 <benzrf> wait, so
11:03:59 <benzrf> the idea is that given a complicated structure, you can easily replace or get parts of it using lenses?
11:04:29 <Eduard_Munteanu> benzrf: yes, lenses representing arbitrary things you can target within that structure.
11:04:34 <benzrf> and I've heard of lenses composing, is the idea there that you can take a lens that extracts b from a and one that extracts c from b and compose them?
11:04:52 <edwardk> goraci: An applicative functor is a "strong lax monoidal endofunctor over the category of Haskell data types" in practice, it lets you smash together applicative results, but not change what you'll do in the future based on what you've seen, where monads will let you do that.
11:05:06 <yitz> benzrf: http://cdsmith.wordpress.com/2011/07/30/arrow-category-applicative-part-i/
11:05:10 <Eduard_Munteanu> benzrf: a lens that "points" to those things, yes
11:05:15 <goraci> http://www.haskell.org/haskellwiki/Typeclassopedia#Functor  - dammit it's pretty clear explanation here thanks will look through
11:05:18 <edwardk> > ((1,2),3)^._1._2 -- benzrf: yes
11:05:20 <lambdabot>  2
11:05:37 <yitz> benzrf: and then http://cdsmith.wordpress.com/2011/08/13/arrow-category-applicative-part-iia/
11:05:50 <edwardk> > ((1,2),3) & _1._2 .~ "benzrf"
11:05:51 <benzrf> goraci: if a functor lets you apply a function within a context, applicatives let you merge several values together with their contexts
11:05:51 <lambdabot>  ((1,"benzrf"),3)
11:06:07 <simpson> edwardk: I attempted to write a thing that traces parsers. However, I guess that parsers generate a lot of stuff! Any hints would be appreciated: http://lpaste.net/97486
11:06:15 <benzrf> goraci: applicatives are sort of like ways to combine mutliple functor values with a function handling the values inside
11:06:41 <Eduard_Munteanu> edwardk: hey... by chance, are there things like tagged functors in 'lens' et al.? I'm cleaning up that lens-designated initializers stuff.
11:07:07 <Eduard_Munteanu> Something like Joker but more typeclassy perhaps.
11:07:07 <simpson> edwardk: My motivation is that I have a parsers-based parser that behaves differently when using Parsec vs. Trifecta to do the actual parsing, and I'd really like to see the try/commit machinery in action to see if I can nail down what I'm doing wrong.
11:07:13 <edwardk> simpson: what does the output look like?
11:07:34 <simpson> edwardk: On a dozen-character input, it OOMs my 1GiB laptop. :3
11:07:47 <edwardk> fair enough
11:07:47 <edwardk> let me know if you find a bug in trifecta! =)
11:08:02 <edwardk> maybe instead have it just log directly to disk?
11:08:22 <edwardk> the issue is you have to hold the whole structure in memory right now
11:08:40 <notdan_> Hi. I've installed the clang/ghc workaround but I am still getting some clang related errors: http://pastebin.com/YF9dnNSX
11:08:41 <mauke> The paste YF9dnNSX has been copied to http://lpaste.net/97487
11:08:54 <notdan_> the workaround I am using: http://www.haskell.org/pipermail/haskell-cafe/2013-October/111174.html
11:09:16 <benzrf> ok, how is it useful to single out lenses as their own data type or whatever instead of making them regular functions?
11:09:21 <Eduard_Munteanu> edwardk: e.g. I have  type TaggedLensLike tag f s t a b = LensLike (TaggedT f) s t a b, but I was wondering if I can use something that instantiates to a plain lens when you don't need the tag.
11:09:26 <notdan_> I guess it doest have anything to do with CPP flags
11:09:30 <Eduard_Munteanu> Er, s/tag//
11:09:31 <edwardk> benzrf: they are just functions
11:09:32 <notdan_> but it's so goddamn annoying :(
11:09:35 <benzrf> oh?
11:09:40 <Eduard_Munteanu> Blah.
11:09:44 <benzrf> :t (.~)
11:09:44 <lambdabot> ASetter s t a b -> b -> s -> t
11:09:48 <benzrf> ???
11:09:56 <benzrf> stab
11:09:59 <edwardk> benzrf: type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t -- note that isn't a newtype
11:10:04 <benzrf> ohhh
11:10:08 <Eduard_Munteanu> type TaggedLensLike tag f s t a b = LensLike (TaggedT tag f) s t a b
11:10:15 <benzrf> fstab
11:10:22 <benzrf> i had to regenerate mine after switching laptops
11:10:32 <benzrf> *hard drives
11:10:35 <simpson> edwardk: Right, and this is a non-trivially-sized grammar. I was thinking that maybe I could annotate the structure in some lazier (or more impure) way, but I couldn't think of a good way to do so.
11:10:40 <edwardk> @let _2' f (a,b) = (,) a <$> f b
11:10:41 <lambdabot>  Defined.
11:11:08 <edwardk> simpson: i think you're going to need to have it write to something that isn't main memory.
11:11:17 <Eduard_Munteanu> Anyway, I should probably paste my stuff.
11:11:25 <benzrf> what do s, t, a, and b represent here?
11:11:29 <simpson> edwardk: My main target is the series of deep clauses that are, somewhere high up, guarded by a `try`; I never get to see those errors because the entire branch gets discarded, so I can't see which part of the grammar is bad.
11:11:48 <edwardk> simpson: e.g. use MonadIO m for the base
11:11:59 <Eduard_Munteanu> benzrf: source, target structures, and source, target substructure
11:12:11 <benzrf> uh
11:12:12 <benzrf> @_@
11:12:24 <benzrf> I am confused ;_:
11:12:29 <simpson> edwardk: Ah, and instead of logging with WriterT, just print directly. I like it.
11:12:32 <Eduard_Munteanu> benzrf: e.g. when you transform (a, b) to (a', b), you have a   Lens (a, b) (a', b) a a'
11:12:55 <benzrf> wait
11:13:01 <benzrf> that looks like setters only
11:13:02 <benzrf> not getters
11:13:12 <edwardk> i tend to avoid guarding more than an LL(k) style fragment with try, it never ends well
11:13:13 <edwardk> basically use try to get well-bounded lookahead.
11:13:13 <edwardk> benzrf: have you watched SPJ's video on lenses?
11:13:13 <edwardk> benzrf: that may be a better starting point
11:13:25 <benzrf> pfft, videos
11:13:34 <benzrf> I prefer to glean my knowledge from intensive irc q/a's
11:13:41 <benzrf> just ask #ruby
11:13:45 <edwardk> benzrf: http://skillsmatter.com/podcast/scala/lenses-compositional-data-access-and-manipulation
11:13:45 <edwardk> benzrf: by choosing an appropriate functor you can 'get' with that too. SPJ shows how we do that in there.
11:13:56 <ciaranm> why not just ask SPJ in person?
11:14:00 <benzrf> i wish
11:14:03 <ciaranm> for a one on one tutorial
11:14:06 <yitz> benzrf: neither. just write code.
11:14:12 <benzrf> 'write code'
11:14:16 <benzrf> pfft, i don't do THAT
11:21:04 <Eduard_Munteanu> :( ... Joker isn't polykinded in the ignored argument
11:22:03 <shachaf> Joker?
11:22:14 <Eduard_Munteanu> shachaf: http://hackage.haskell.org/package/bifunctors-4.1.1/docs/Data-Bifunctor-Joker.html
11:22:55 <shachaf> Ah, clowns and jokers.
11:23:44 <edwardk> Eduard_Munteanu: send a patch
11:23:50 <Eduard_Munteanu> :D
11:24:18 <Eduard_Munteanu> I will, I still have to write the TH generator.
11:24:45 <edwardk> Joker should just be TaggedT ;)
11:26:12 <skyflash> Can anyone here recommend a cross-platform audio library suitable for playing a PCM data stream (with a Haskell binding of course)?
11:26:42 <Eduard_Munteanu> edwardk: should I prefer TaggedT '(record, fieldName) to an adhoc newtype for that purpose? I can avoid carrying the record around entirely but it might aid error messages.
11:27:16 <Eduard_Munteanu> skyflash: SDL?
11:27:35 <edwardk> well, i don't even remember if tagged-transformer is still being updated
11:27:51 <edwardk> ultimately an ad hoc newtype is probably fine and clearer in intention
11:29:08 <Eduard_Munteanu> I could extend Mutator to a tagged Mutator, but I guess I like the idea of having a dedicated newtype better.
11:39:43 <epta> @hoogle (a -> b -> m c) -> m a -> m b -> m c
11:39:44 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
11:39:44 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
11:39:44 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
11:39:47 <rose_> Does anyone have a good answer to this SO question regarding sending mail via Google SMPT? 25 votes and no good answers. http://stackoverflow.com/questions/12468516/haskell-sending-a-mail-via-google-smtp?rq=1
11:39:58 <rose_> *SMTP
11:40:04 <Eduard_Munteanu> :t liftM2
11:40:05 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:41:13 <Eduard_Munteanu> rose_: you might be able to run ssmtp or some other external mail agent
11:41:31 <rose_> can you provide references?
11:41:55 <Eduard_Munteanu> @google "ssmtp"
11:41:56 <lambdabot> Plugin `search' failed with: user error (https not supported)
11:42:06 <Eduard_Munteanu> @google ssmtp
11:42:07 <lambdabot> Plugin `search' failed with: user error (https not supported)
11:42:22 <rose_> I'm about to try out this: https://github.com/dpwright/HaskellNet-SSL/blob/master/examples/gmail.hs
11:42:22 <Eduard_Munteanu> rose_: https://wiki.archlinux.org/index.php/SSMTP
11:43:30 <Eduard_Munteanu> rose_: it's commonly used with Git, Mutt or other things that tend to expect a local MTA
11:43:45 <rose_> MTA?
11:43:54 <Eduard_Munteanu> rose_: stuff like Sendmail
11:44:45 <Eduard_Munteanu> Except ssmtp is a lot simpler and it's meant to proxy stuff to a foreign SMTP server (more of a MUA in that sense).
11:44:48 <dv-> mutt supports smtp natively now
11:45:04 <Eduard_Munteanu> Yeah, Git too. But some still use ssmtp.
11:47:06 <aristid> dv-: doesn't having something like ssmtp setup also have the benefit that you can send mail from outside mutt as well?
11:48:00 <dv-> yes i suppose that's true
11:50:10 <aristid> dv-: but then i'm a gmail web interface user.
11:52:49 <dv-> i used to use the web interface, but i really hated how it kept changing
11:53:24 <aristid> dv-: i was considering to switch to thunderbird but then the interface pissed me off. maybe i should try mutt or so though
11:55:26 <dv-> yeah mutt is small, fast and comes with gnupg support
11:56:11 <aristid> dv-: gpg key management is infinitely tedious
11:56:34 <epta> How to get m (t c) from (f :: a -> b -> c), (x :: t a) and (y :: m b)?
11:56:35 <Eduard_Munteanu> The UI is rather awful, yeah
11:57:13 <Eduard_Munteanu> epta: what constraints on 'm' and 't'?
11:57:44 <epta> m is IO, t is Maybe :)
12:02:15 <skyflash> Eduard_Munteanu: I looked at SDL but didn't see how to do PCM audio (at least via the exported audio interface).
12:02:52 <skyflash> Eduard_Munteanu: Thanks for the suggestion though.
12:02:58 <Eduard_Munteanu> :t \ma mb -> (mb >>=) <$> (ma >>= ?f)
12:02:59 <lambdabot> (Monad m, Monad f, Functor f, ?f::a1 -> f (a -> m b)) => f a1 -> m a -> f (m b)
12:03:25 <Eduard_Munteanu> Er.
12:13:43 <supki> edwardk: I update tagged-transformer if I notice you've broken it ;)
12:13:55 <edwardk> hah
12:24:46 <joneshf-laptop> what does this mean in cabal init: Include documentation on what each field means
12:24:47 <joneshf-laptop> ?
12:25:08 <Eduard_Munteanu> joneshf-laptop: it adds comments to the generated cabal file
12:25:41 <joneshf-laptop> oh
12:25:43 <joneshf-laptop> thanks
12:26:08 <blochchain> say i want type Board to be a synonym for [[Bool]] and I want to give it its own instance of Show. how do i do this?
12:26:23 <Eduard_Munteanu> blochchain: you can't
12:26:30 <blochchain> odd
12:26:37 <blochchain> what's the best alternative?
12:26:57 <Eduard_Munteanu> blochchain: newtype... it's not odd, it can't treat two [[Bool]] differently
12:27:08 <Eduard_Munteanu> Which is what synonym means.
12:27:12 <blochchain> yeah
12:28:13 <Eduard_Munteanu> blochchain: or use a separate show-like function
12:28:13 <dagano> i am trying to acquire wadler's paper : "how to make ad-hoc polymorphism less ad-hoc"...can anyone supply a link?  I am too dumb to google
12:31:33 <jrw> dagano: you might want to read a paper on googling before attempting anything more advanced...
12:31:50 <dagano> thanks, comedy king
12:32:00 <Eduard_Munteanu> I think they meant they can't find it, not that they won't Google it.
12:32:30 <jrw> dagano: this one? http://www.cse.iitk.ac.in/users/karkare/courses/2010/cs653/Papers/ad-hoc-polymorphism.pdf
12:32:49 <dagano> jrw: exactly, thanks. i was having trouble.
12:38:36 <epta>  @undo do { b <- mb;  return $ (`f` b) `fmap` ma }
12:38:58 <epta> @undo do { b <- mb;  return $ (`f` b) `fmap` ma }
12:38:58 <lambdabot> mb >>= \ b -> return $ (`f` b) `fmap` ma
12:39:18 <epta> @pl \f ma mb ->  mb >>= \ b -> return $ (`f` b) `fmap` ma
12:39:18 <lambdabot> (fmap .) . flip . (fmap .) . flip
12:39:48 <supki> :t (<**>)
12:39:48 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
12:40:38 <epta> supki: how to expand it to smth like `(a -> b -> c) -> Maybe a -> IO b -> IO (Maybe c)'?
12:40:39 <supki> :t liftA2
12:40:40 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
12:41:45 <Eduard_Munteanu> epta: what do you need it for?
12:42:03 <Eduard_Munteanu> Perhaps you can use MaybeT.
12:52:02 <aristid> it seems like the most important modern-i/o-thingie piece that i use a lot in my code is Producer
12:52:09 <supki> :t (. fmap return) .: ((. return) . (liftA2 . liftA2))
12:52:09 <lambdabot> (Monad f, Monad m, Applicative m, Applicative f) => (a -> b -> c) -> f a -> m b -> m (f c)
12:52:09 <aristid> which is equivalent to ListT actually
12:52:27 <aristid> so i wonder if just having ListT is enough to get a pleasant replacement for pipes/whatever
12:52:51 <aristid> (ListT being the proper one, not the one in mtl)
12:52:56 <gamegoblin> Is there a prelude function for "not null" ?
12:53:07 <Feuerbach> gamegoblin: no
12:53:13 <simpson> gamegoblin: Nope, but it's easy enough to make your own. Why?
12:53:24 <goraci> @newtype
12:53:25 <lambdabot> Unknown command, try @list
12:53:35 <gamegoblin> Just curious if I didn't have to do a quick f = not . null
12:53:45 <shachaf> (not.null) is a function.
12:53:49 <goraci> what's newtype is ? and what the difference from type ?
12:53:59 <shachaf> @google type newtype data
12:54:00 <lambdabot> http://stackoverflow.com/questions/5889696/difference-between-data-and-newtype-in-haskell
12:54:00 <lambdabot> Title: types - Difference between `data` and `newtype` in Haskell - Stack Overflow
12:54:12 <shachaf> That's not the page I was going for.
12:54:21 <shachaf> Though it answers the question.
12:54:23 <shachaf> @google haskellwiki type newtype data
12:54:23 <lambdabot> http://www.haskell.org/haskellwiki/Type
12:54:23 <lambdabot> Title: Type - HaskellWiki
12:54:30 <shachaf> Hm. Maybe I imagined it.
13:09:00 <FreeSlave> Hello. I'm new to Haskell and I can't figure out what's wrong here http://codepad.org/GzfAFCCl
13:09:00 <FreeSlave> GHC claims line 17, it says Could not deduce (a ~ Int), but I don't know how to fix that
13:09:46 <aristid> FreeSlave: you probably need a fromIntegral in some places
13:12:09 <FreeSlave> aristid: yeah, thanks. 'fromIntegral countCaught / fromIntegral count' instead of 'countCaught / count' helped
13:14:18 <Cale> FreeSlave: Are you using hugs? You should probably try to get hold of GHC
13:14:54 <Cale> (It probably won't really matter for a while, but Hugs is pretty outdated, and I don't know whether anyone's even working on it at this point.)
13:15:43 <FreeSlave> Cale: I use ghc. Maybe codepad uses Hugs, I just post code to there
13:16:00 <Cale> oh
13:16:20 <Cale> I hadn't noticed that wasn't part of your paste :)
13:17:15 <aristid> hah, codepad
13:19:18 <FreeSlave> I usually use codepad, but now I see you prefer lpaste here, ok.
13:22:04 <quchen> Yeah I think Codepad is Hugs-based
13:23:15 <aristid> FreeSlave: codepad isn't bad, but for haskell its choice of compiler is questionable:)
13:23:59 <quchen> Codepad has evaluation, lpaste has an IRC bot and HLint.
13:37:51 <HugoDaniel> oh oh oh
13:48:25 <epta> Is there a way to add "/" or "\" (depends on platform) to the end of the FilePath?
13:49:07 <quchen> epta: (</> "") should do the trick
13:49:28 <epta> quchen: nope
13:49:32 <shachaf> The meaning of ending a FilePath with that character is also platform-dependent, I'm pretty sure.
13:49:58 <shachaf> And keep in mind that some platforms use neither / nor \ . I don't know whether any of them have Haskell implementations.
13:50:15 <geekosaur> not so far as I am aware
13:51:27 <epta> shachaf: "/" or "\" means that FilePath describes directory (or folder). Nope?
13:53:15 <navaati> epta: since there can't be a file and a directory with the same name, nope
13:53:26 <navaati> it's unamiguous
13:53:34 <geekosaur> there can, sort of, on os/400 :p
13:53:35 <navaati> unambiguous*
13:53:42 <geekosaur> or whatever it's called these days
13:53:45 <navaati> geekosaur: shhh
13:53:53 <epta> I'll be fine with linux/windows btw
13:54:15 <navaati> btw do you have an example of an os using neither / nor \ ?
13:54:28 <ininin> :q
13:54:31 <geekosaur> and vms requires you to access a directory as [path.to]directory.dir, not as [path.to.directory] with no filename component
13:54:40 <geekosaur> IIRC
13:54:41 <shachaf> Mac OS.
13:54:47 <navaati> ininin: bad window eh :p
13:54:48 <geekosaur> old mac os used :, yes
13:55:12 <geekosaur> which is why the finder still translates : to /
13:55:39 <navaati> oh ? i have had my hand on a mac os 9 and i don't remember that. i was very young tho
13:55:42 <epta> So, what I wanna do is to split prefix "/a/b/c" from "/a/b/c/d/e/f" and get "d/e/f" (not "/d/e/f")
13:56:11 <geekosaur> navaati, you wouldn't have noviced unless you used Applescript or MPW
13:56:11 <geekosaur> probably
13:56:34 <navaati> geekosaur: ah, you mean that there was no address bar or so ?
13:56:45 <navaati> must be that
13:56:46 <geekosaur> not as such
13:57:08 <geekosaur> control-clicking the folder basename in the titlebar would show a popup of upper folders
13:57:11 <geekosaur> (still does, in fact)
13:57:38 <quchen> epta: There are a couple of helper functions in the FilePath module. http://hackage.haskell.org/package/filepath-1.3.0.1/docs/System-FilePath-Posix.html
13:57:46 <quchen> splitSearchPath for example looks relevant.
13:58:02 <geekosaur> you didn't get to see what actual pathnames looked like unless you used a programming language
13:58:13 <geekosaur> or possibly inspected a log from some programs
13:59:06 <blochchain> i know this is a simple question but I'm having a hard time finding a straight answer. is there a way that I can cause haskell lists to be indexable in O(1) using one of those {- ... -} statements at the beginning? specifically, I'm using [Bool]
13:59:47 <jonasw> Use a more appropriate data structure instead of a linked list
13:59:50 <lispy> blochchain: what statements?
13:59:54 <geekosaur> lists are linked lists, there is not currently a pragma that lets you use list syntax with arrays/vectors (but there should be in ghc 7.8)
14:00:02 <lispy> blochchain: Do you mean a language extension?
14:00:13 <blochchain> lispy, yeah
14:00:18 <geekosaur> I was assuming they meant a {-# pragma #-}, yeh
14:00:24 <blochchain> ah, that stinks
14:00:25 <aristid> geekosaur: list syntax with arrays? cool, link?
14:00:33 <blochchain> that's a huge hole in the language IMO
14:00:44 <epta> quchen: and have to do that using splitSearchPath?
14:00:46 <aristid> blochchain: no it's not. haskell has arrays. use them.
14:00:49 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists
14:01:09 <blochchain> aristid, syntax matters
14:01:32 <blochchain> when trying to make something as simple as Conway's game of life, I shouldn't have to choose between readable and fast
14:01:43 <ciaranm> and you don't
14:01:47 <zett_zelett> Merry Christmas!
14:01:53 <epta> quchen: best that I've found is stripPrefix from system-filepath http://hackage.haskell.org/package/system-filepath-0.4.8/docs/Filesystem-Path.html#v:stripPrefix
14:02:23 <epta> quchen: but the problem is that I still need to pass one argument as a dir name with "/" or "\" at the end
14:02:27 <blochchain> ciaranm: elaborate
14:02:40 <aristid> blochchain: a small "fromList" doesn't kill the readability of your program.
14:02:44 <epta> quchen: so there is no any benefits over Data.List.stripPrefix
14:02:48 <ciaranm> blochchain: learn more haskell
14:03:17 <quchen> Vector isn't unreadable anyway.
14:03:58 <aristid> the thing that annoys me a bit about vector is that the different storage types are not very interoperable
14:04:08 <navaati> for conway, wouldn't be repa the best ? (not sure)
14:04:17 <quchen> epta: You can use splitPath to get all the components of a FilePath, then do your grouping, and joinPath the results.
14:04:19 <aristid> what if i want my map over storable items to return an unboxed vector?
14:04:21 <quchen> For example.
14:06:22 <blochchain> i don't really understand why a list of a statically-sized type (Int, Bool, etc.) should be a linked list anyway. Seems like a vestige of the lisp days.
14:06:49 <geekosaur> a linked list is the functional version of an imperative for loop
14:06:54 <aristid> geekosaur: hmm i think that extension is not one i would add to all my modules, as it reduces type inference
14:07:30 <quchen> aristid: What's the difference between unboxed vectors and storable ones anyway? Both are unboxed, right?
14:07:31 <blochchain> aristid: using fromList is still pretty serious overkill compared to using a classic array
14:07:57 <aristid> quchen: i believe the latter can be used for interoperation with C code better
14:08:03 <blochchain> geekosaur: it would be possible to emulate that in a compiled language like haskell
14:08:20 <blochchain> geekosaur: while using an array
14:08:22 <quchen> aristid: Yes, but what's the advantage of Vector.Unboxed then?
14:08:34 <quchen> Why not always use Vector.Storable?
14:08:38 <aristid> quchen: it supports more types
14:08:52 <geekosaur> blochchain, there are interpreters. and arrays have setup overhead which is silly to pay for short lists used as loops
14:08:59 <quchen> Oh right, the constraint.
14:09:00 <Cale> Also, it's probably significantly faster
14:09:05 <aristid> quchen: i was actually pondering today if a version that blends these two together makes sense: use storable for types that support it and unboxed otherwise
14:09:09 <geekosaur> and you lose loop fusion
14:09:30 <blochchain> geekosaur: where xs :: a, tail xs = xs + sizeof(a)
14:09:31 <geekosaur> which *does* matter for compilation: you can more easily make the whole thing go away
14:09:39 <blochchain> that's all you need to do
14:09:40 <Cale> Storable will use the Storable instances available to work out how to serialise structures into memory, while the unboxed thing is just going to use their existing representation only without the box.
14:10:20 <aristid> Cale: hmm that's not very accurate for (a,b) isn't it? i think that is stored as a tuple of arrays with Unboxed
14:10:43 <Cale> Oh, well, if there's an instance at all for pairs, yeah.
14:10:47 <quchen> So Storable is really just about memory representation for the FFI, while Unboxed is for performance (primarily, at least)
14:11:09 <Cale> quchen: yes
14:12:36 <blochchain> geekosaur: "you can more easily make the whole thing go away" i don't understand this... what's easier than just freeing the memory?
14:12:42 <blochchain> (allocated on the heap)
14:12:55 <geekosaur> [24 22:03] <geekosaur> and you lose loop fusion
14:13:41 <blochchain> as long as the operations are pure I don't see why you'd lose loop fusion
14:14:09 <FreeSlave> http://lpaste.net/97496 can I avoid typing of :: Float here?
14:14:38 <aristid> FreeSlave: i don't see any :: FLoat there
14:15:53 <FreeSlave> And that's because it can't be compiled. But it's fine if I explicitly specify type for first 6 arguments
14:16:41 <FreeSlave> interesting that ghci is ok with it
14:16:54 <Cale> Ah, the reason why numeric defaulting doesn't apply here and choose Double is that a non-prelude class is constraining the type of experiment
14:17:18 <Cale> GHCi has extended defaulting rules which are more aggressive, because it's annoying to specify types when you're playing with the interpreter
14:17:27 <danilo2> Hello :) I've got several functions in Template Haskell - one of them is generating a function and second is generating some instances reifying the function on the beginning. So I use it like $(mkFunc "test") $(genInst 'func) . Is it possible to merge them in one TH function, which will call the first and the second? I cannot do it the normal way, because we cannot reify things, that are not yet generated in TH.
14:17:52 <Cale> FreeSlave: You might try {-# LANGUAGE ExtendedDefaultRules #-} at the top of the file
14:18:11 <Cale> FreeSlave: or just specifying the type of any one of the variables should do
14:18:46 <FreeSlave> Cale: thanks, both variants work
14:19:10 <Cale> FreeSlave: It also might be worth pointing out that you can put multiple definitions into a single let
14:19:29 <Cale> (so long as you line them all up so they start in the same column as the first definition did)
14:23:07 <Eduard_Munteanu> danilo2: the Dec you generate for the function is pretty much the same as the one you get when you reify it, no?
14:24:41 <Eduard_Munteanu> Perhaps you only generate an Exp for the RHS of a function already declared?
14:24:49 <navaati> is this fpcenter stuff usable for classical (non web) programming and shit ?
14:24:54 <danilo2> Eduard_Munteanu: no, If I'm generating it, I'm generating FunD, which has got a list of Pat etc. I want to reify it **after** type inferencer gets it and read from the reify the inferenced type specification
14:25:20 <danilo2> Eduard_Munteanu: Right no I'm doing it using 2 TH functions and maybe I'll stick with it if there is no other method
14:32:18 <pxqr> can someone explain why this expression (timeout 1 (forever (return ()))) will hang on?
14:33:36 <geekosaur> pxqr, because you're not forcing evaluation within the timeout, so you exit the timeout with an unevaluated thunk that then gets run at some other point
14:34:01 <geekosaur> non-strict evaluation requires some care when you do things like that
14:34:15 <navaati> :t timeout
14:34:16 <lambdabot> Not in scope: `timeout'
14:34:23 <bennofs> @let import System.Timeout
14:34:24 <lambdabot>  Defined.
14:34:27 <bennofs> :t timeout
14:34:28 <lambdabot> Int -> IO a -> IO (Maybe a)
14:34:37 <navaati> bennofs: thx
14:34:47 <bennofs> geekosaur: How would it not force evaluation in the IO monad?
14:35:19 <bennofs> geekosaur: doesn't it need to evaluate until the 'last' return to get the result?
14:35:30 <geekosaur> bennofs, and?
14:35:51 <bennofs> geekosaur: well, how would the returned thunk look like?
14:36:01 <geekosaur> nothing is *doing* the evaluation there. and IO is not some magic area that is always strictly evaluated
14:36:15 <geekosaur> it looks like any other thunk
14:36:19 <pxqr> geekosaur: does timeout uses async exceptions to interrupt provided action?
14:37:08 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.6.0.1/System-Timeout.html says yes
14:38:17 <pxqr> then why does (timeout 1 (forever (return ())) >> return ()) hang on too?
14:38:35 <geekosaur> what makes you believe that does any more evaluation than the first one>?
14:39:04 <bennofs> geekosaur: Why doesn't timeout 1 $ forever $ putStrLn "bar" hang?
14:39:34 <pxqr> geekosaur: i just don't understand where exactly (Maybe a) is forced
14:40:06 <geekosaur> mm, I wonder if timeout was changed to force evaluation (at one point at least it did not).
14:40:36 <geekosaur> if it was then there is an additional sting in the tail, which is that the runtime's checking for interrupts is done at allocations, and neither of those expressions of yours does any allocation
14:41:21 <pxqr> but then that is not truly async exceptions
14:41:41 <geekosaur> hm, I do not see any forced evaluation in there
14:42:05 <Feuerbach> geekosaur: the allocation story sounds true to me. I think this was discussed before
14:42:09 <bennofs> I don't understand how timeout in the IO monad can be implemented without forcing evaluation
14:42:17 <Feuerbach> I'm pretty sure this has nothing to do with laziness or forcing
14:42:37 <geekosaur> bennofs, Control.Exception.evaluate exists for a reason
14:43:08 <bennofs> @ty evaluate
14:43:09 <lambdabot> a -> IO a
14:43:49 <Feuerbach> geekosaur: well, timeout does *execute* the action. That's even more than evaluation
14:43:51 * geekosaur is looking at the source to timeout and it does not do anything to force evaluation
14:44:20 <bennofs> Hmm, should fmap (const ()) $ timeout 1 $ forever (return ()) terminate then?
14:44:54 <geekosaur> I know people trip over "oh that didn't actually evaluate anything, just returned a thunk" all the time when timing stuff
14:45:07 <geekosaur> and not just with pure code
14:45:29 <Feuerbach> this case is different
14:45:39 <bennofs> geekosaur: But I think that's only when the laziness is hidden in the value of the monad, i.e if I wrote timeout 1 $ return $ let x = x in x
14:53:11 <pxqr> indeed (timeout 1 (forever newEmptyMVar)) will not hang on. so the problem may be caused by implementation of async exceptions?
14:54:08 <bennofs> pxqr: It's a fundamental problem in GHC that the thread scheduler is only run when allocations occur
14:54:16 <pxqr> ah
14:54:20 <bennofs> pxqr: so when there are no allocations, the thread is never changed
14:54:25 <pxqr> ok, i understand that now
14:54:37 <pxqr> thanks all
14:55:24 <geekosaur> and yes, known and somewhat difficult to fix issue as ghc's runtime is currently designed
14:57:15 <bennofs> pxqr: Btw, I found GHC.Conc.yield to explicit force a context switch. So timeout 1 $ forever $ yield >> return () terminates
14:58:17 <Feuerbach> which is the same as timeout 1 $ forever $ yield :)
14:58:37 <pxqr> bennofs: it is also exported by Control.Concurrent
14:59:15 <bennofs> pxqr: ah thanks, hayoo only showed GHC.Conc :)
14:59:41 <bennofs> hmm or maybe it was only the first result
15:06:21 <Eduard_Munteanu> Where am I supposed to look for indexed monads these days?
15:06:34 <Eduard_Munteanu> The 'indexed' package seems a bit old.
15:46:12 <dhrosa_> Hello, how would I express the following computation in haskell? I have a list of objects of type Pos, and I have a function f :: Grid -> Pos -> Grid
15:46:29 <dhrosa_> I would like to take the first Pos object, apply f to it, and then apply the result of f to the next pos in the list
15:46:45 <dhrosa_> and use the result of f as the Grid parameter of the next call to f*
15:47:01 <scott_> That sounds like a fold
15:47:11 <jedavis> sounds like foldl f (head l) (tail l)
15:47:36 <jedavis> (apologies if non-idiomatic; just started last week)
15:48:11 <quchen> jedavis: There's foldl1 if you want a fold like that. Crashes on empty list though.
15:48:22 <scott_> I think more like foldl f startingGrid positions
15:48:51 <dhrosa_> hmm, so the first iteration will be (g1 = f startingGrid pos1)
15:48:58 <dhrosa_> oh
15:49:01 <dhrosa_> yeah I think that works
15:49:19 <dhrosa_> then g2 = (f g1 pos2)
15:49:30 <dhrosa_> right?
15:49:38 <scott_> Yeah
15:49:39 <Peaker> dhrosa_: a style tip: If you have a function that looks like:   a -> b -> a    it's nicer to have:    b -> a -> a     because after giving the "b" you have (a -> a) which is nice to work with. For example, if you have: f,g :: Pos->Grid->Grid    then you can use:   f p1 . g p2     to get a Grid->Grid function
15:49:48 <jedavis> quchen: ah, I see.  Thanks!
15:50:37 <Peaker> dhrosa_: in your last example,  instead of "g1" and "g2", you can use:   newGrid = (f pos2 . f pos1) startingGrid
15:50:46 <Peaker> dhrosa_: (if you flip the argument order)
15:51:37 <dhrosa_> Peaker: I understand that, but in a lot of places in my code, the a -> b ordering makes sense too
15:52:08 <dhrosa_> for example, I have a function validPos :: Grid -> Pos -> Bool, and filtering a list of valid positions makes more sense with filter (validPos grid) posList
15:52:15 <Peaker> dhrosa_: do you have an example?
15:52:34 <Peaker> dhrosa_: validPos :: a -> b -> c   not a -> b -> a
15:52:52 <dhrosa_> oh I see
15:53:24 <Peaker> dhrosa_: it indeed makes sense that you can convert a Grid to a (Pos -> Bool) function. It may make sense to have Grid as first or second arg in different functions
15:54:31 <identity> A thumb rule might be to choose the ordering that results in the least amount of flips ;)
15:54:50 <identity> i.e. if you're flipping your function all the time, reorder the function
15:55:28 <dhrosa_> another reason was that most of my other functions take a Grid as the first param, I'll re-evaluate my code and see if Grid second is better in some places
15:58:09 <dhrosa_> I didn't see that my question was really a fold because I was used to fold parameters being of the same type
15:58:18 <identity> nope
15:58:21 <identity> :t foldl'
15:58:22 <lambdabot> (a -> b -> a) -> a -> [b] -> a
15:58:36 <dhrosa_> yep
15:58:39 <identity> folds are everywhere
15:58:40 <Peaker> :t foldr (.) id
15:58:40 <identity> it's great
15:58:41 <lambdabot> [b -> b] -> b -> b
15:59:03 <Peaker> dhrosa_: if you use my ordering, and you have a list of positions you want to apply to the Grid via f, then you can:  compose (map f positions) grid
15:59:10 <Peaker> dhrosa_: where  compose = foldr (.) id
15:59:14 <Peaker> (that's a pattern I like)
15:59:40 <dhrosa_> yeah I've used a compose function exactly like that in code before, I'm surprised it isn't standard
15:59:47 <dhrosa_> I feel like composing a list of functions is common
15:59:50 <Peaker> yeah it should be
16:00:11 <identity> i'm not sure I've done that before
16:00:18 <identity> maybe I didn't quite catch the pattern
16:00:25 <Peaker> ala Endo foldMap = foldr (.) id, I think
16:00:29 <identity> naturally, a compound composition like that sounds pretty useful
16:00:57 <Peaker> > ala Endo foldMap [(*2), (+3)] 10
16:01:00 <lambdabot>  26
16:02:56 <zRecursive> :t Endo
16:03:18 <lambdabot> (a -> a) -> Endo a
16:03:46 <quchen> zRecursive: Endo is the monoid wrapper for (a -> a) with mappend = (.), mempty = id
16:03:58 <zRecursive> What's usagae of Endo ?
16:04:21 <zRecursive> quchen: thx
16:04:54 <identity> :info Endo
16:04:58 <identity> @info endo
16:04:59 <lambdabot> endo
16:05:01 <identity> @info Endo
16:05:01 <lambdabot> Endo
16:05:05 <identity> eh
16:05:07 <identity> :i Endo
16:05:25 <zRecursive> @hoogle Endo
16:05:26 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
16:05:27 <lambdabot> Data.Monoid newtype Endo a
16:05:27 <lambdabot> System.Posix.Terminal EndOfFile :: ControlCharacter
16:08:36 <Peaker> zRecursive: if you want to treat (a->a) functions as a Monoid
16:09:59 <zRecursive> sure
16:14:00 <twirlobite> which IRC channel could I go to in order to discuss the repercussions on modern computing science theory if (for some reason) the proof for the incomputability of the halting problem were shown to be wrong?
16:14:50 <aristid> #haskell-blah
16:15:07 <Axman6> also possibly #haskell-in-depth
16:15:19 <Axman6> not sure about any more general channels
16:16:32 <twirlobite> thank you!
16:17:42 <bitonic`> is there some library to mock an HTTP server?  for example I'd like to introduce failures artificially in kept-alive connections
16:17:56 <Axman6> not sure if #haskell-in-depth is in use any more
16:35:12 <heath> I don't have a copy of windows on this machine, and the one machine I do have a copy of it on isn't nearby currently. If you download the Haskell Platform on Windows. are you given a copy of the man pages for ghc as well?
16:44:50 <heath> k, guess i'll hop on one of the family member's computers and find out
16:52:31 <raphie> can anyone help me with typeclasses? this has my problem: https://gist.github.com/RaphiePS/08252cd79c1104177111
16:52:51 <johnw> you can't do that
16:53:14 <raphie> johnw: why?
16:53:27 <heath> no man pages
16:53:29 <heath> just ghc --help
16:53:50 <johnw> let me find you a good description
16:54:01 <twiceler> raphie: Suppose somebody decides that a [a] is Num. Then which instance will you obey?
16:54:18 <bennofs> What is the best way to limit they keys in a map to a given list of keys? I'd also like to know which keys are in the list, but not in the map
16:54:29 <raphie> twiceler: oooh, I never thought of that. so GHC is preventing an ambiguous case for me :)
16:54:57 <twiceler> raphie: Yep. I think you can turn on OverlappingInstances though (perhaps FlexibleInstances too) and cross your fingers
16:54:58 <raphie> so should I just look up all the types inside Num and make them instances?
16:55:09 <johnw> raphie: in general you can never do "instance Foo a where", even if a has constraints
16:55:26 <johnw> raphie: you could make a wrapper
16:55:42 <johnw> newtype WrapNum a = WrapNum a ; instance Adder (WrapNum a) where...
16:55:51 <johnw> then have a function "wrapNum :: Num a => a -> WrapNum a"
16:56:01 <johnw> this makes your intent explicit
16:56:04 <raphie> my issue is that running something like (1 +++ 2) will cause complains about ambiguous types, and I need to do something like (1 :: Int +++ 2)
16:56:07 <twiceler> raphie: Honestly, I often do stuff like this, at least temporarily, and just chuck a whole bunch of unsafe language extensions at it. You will probably need UndecidableInstances as well, because the things are of the same size
16:56:56 <twiceler> twiceler: Because GHC needs to check, well: Num => Addable, to see if something is addable, I need to check Num... perhaps Addable => Num (which would be problematic!)
16:56:57 <johnw> you'll probably need overlapping instances too
16:57:25 <bennofs> i.e. I'd like a function [k] -> Map k a -> ([k] {- Keys that are in the input list, but not in the map -}, Map k a {- All keys of this map should be a member of the input list -})
16:57:28 <raphie> ahh, ok, thanks. wouldn't ever use something like this in production, just wanted to show my friend the raw power :)
16:58:10 <johnw> bennofs: you mean, filter the map for every k in [k], but also remember which k were not used?
16:58:26 <bennofs> johnw: I think that's it, yes
16:58:27 <raphie> gosh, I think #haskell is the most responsive/helpful language room I've ever visited
16:59:14 <johnw> :t \xs m -> (filter (not . Map.elem m) xs, Map.filter (not . elem xs) )
16:59:14 <lambdabot> Couldn't find qualified module.
16:59:18 <johnw> something like that
16:59:43 <johnw> sorry, s/not . elem xs/elem xs/ at the end
16:59:51 <bennofs> yes
16:59:59 <johnw> and like you'll need to flip on both of them
17:00:08 <johnw> but that's the idea
17:00:13 <bennofs> But for the keys, so it's Map.filterWithKeys ... :)
17:00:18 <johnw> right
17:01:02 <raphie> is there a handy library function that lets you map with an accumulator like fold?
17:01:12 <johnw> mapAccumL?
17:01:16 <raphie> say I want to add a increasing-by-1-each-time number to each number in a list
17:01:18 <johnw> :t mapAccumL
17:01:18 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
17:01:33 <bennofs> raphie: zipWith
17:01:41 <johnw> oh yeah, in that case
17:01:48 <bennofs> > zipWith (+) [1..5] [4,3,2,1,4]
17:01:49 <lambdabot>  [5,5,5,5,9]
17:01:57 <raphie> oh, genius
17:01:58 <johnw> > zip [1..] [1,2,3]
17:02:00 <lambdabot>  [(1,1),(2,2),(3,3)]
17:02:15 <raphie> I could use iterate for the more general case!
17:02:22 <bennofs> raphie: or maybe scan
17:02:24 <bennofs> @ty scanr
17:02:25 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
17:02:54 <raphie> what's the name for iterate...
17:02:57 <raphie> anamorphism?
17:03:03 <raphie> or is it catamorphism
17:03:14 <johnw> :t iterate
17:03:15 <lambdabot> (a -> a) -> a -> [a]
17:03:25 <johnw> it's an anamorphism
17:03:56 <johnw> which means you should be able to implement it pretty easily with unfoldr
17:04:10 <raphie> yeah! I used that a while back to make a groupBy function
17:04:37 <raphie> groupBy 2 [1,2,3,4] -> [[1,2], [3,4]]
17:05:28 <twiceler> raphie: hmpph.. I have to learn this. I always import Data.List.Split (chunksOf)
17:05:32 <twiceler> :i unfoldr
17:05:34 <twiceler> :t unfoldr
17:05:36 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
17:06:01 <johnw> :t unfoldr (Just . join (,))
17:06:01 <lambdabot> a -> [a]
17:06:05 <bennofs> johnw: any idea what functions to use for my map problem?
17:06:27 <johnw> :t unfoldr (Just . over both f . join (,))
17:06:28 <lambdabot> (Show a, FromExpr a) => a -> [a]
17:06:42 <bennofs> over both = bimap
17:06:44 <bennofs> @ty bimap
17:06:45 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
17:06:56 <johnw> over both f = bimap f f
17:06:59 <bennofs> oops, right
17:07:06 <bennofs> I always get confused :P
17:07:11 <johnw> :t \f -> unfoldr (Just . over both f . join (,))
17:07:12 <raphie> twiceler: this was my implementation: https://gist.github.com/RaphiePS/1fc18f933c73c4e96c5d
17:07:12 <lambdabot> (a -> a) -> a -> [a]
17:07:27 <johnw> :t \f -> unfoldr (Just . f &&& f . join (,))
17:07:28 <lambdabot>     Couldn't match type `(Maybe c0, c0)' with `Maybe (a0, a1)'
17:07:28 <lambdabot>     Expected type: a1 -> Maybe (a0, a1)
17:07:28 <lambdabot>       Actual type: a1 -> (Maybe c0, c0)
17:07:36 <johnw> :t \f -> unfoldr (Just . (f &&& f) . join (,))
17:07:37 <lambdabot> ((c', c') -> c') -> c' -> [c']
17:07:44 <johnw> ah, I prefer using over both :)
17:08:10 <twiceler> okay
17:08:24 <raphie> ooh, I've been wondering about convention: is it more common to put helper functions before or after the function they're used in?
17:08:43 <johnw> raphie: (take n xs, drop n xs) == splitAt n xs
17:09:01 <twiceler> raphie: I do it inside the function
17:09:54 <raphie> johnw: ooh, this is much nicer then: https://gist.github.com/RaphiePS/ccfcd29aaa86b3283099
17:10:17 <raphie> er, add an xs after n
17:11:02 <johnw> :t \f -> unfoldr (Just . join (,) . f)
17:11:03 <lambdabot> (b -> b) -> b -> [b]
17:11:39 <raphie> :t join
17:11:40 <lambdabot> Monad m => m (m a) -> m a
17:11:48 <raphie> :t (,)
17:11:48 <lambdabot> a -> b -> (a, b)
17:12:01 <johnw> > join (,) a
17:12:02 <lambdabot>  (a,a)
17:12:51 <raphie> ok, another random question: has anyone heard of Euler's / Heun's method?
17:14:57 <twiceler> raphie: I just added my favorite implementation of groupN in a comment there
17:15:06 <twiceler> raphie: And no, sorry
17:16:30 <raphie> twiceler: ooh, that's even more elegant. nice!
17:16:47 <raphie> every day I get more and more psyched about the power of haskell
17:17:54 <twiceler> raphie: I wish I could find a one-liner using just Prelude stuff. Well... I wish it was in the Prelude! Or at least Data.List
17:18:15 <erisco> what is the cabal package for Data.List.Ordered?
17:18:37 <bennofs> @hoogle Data.List.Ordered
17:18:39 <lambdabot> package ordered
17:18:39 <lambdabot> package unordered-containers
17:18:39 <lambdabot> package unordered-containers-rematch
17:19:37 <erisco> is not in ordered or unordered-containers
17:19:58 <bennofs> it's in data-ordlist
17:20:20 <erisco> bennofs, thanks
17:20:39 <raphie> can anyone explain why you sometimes get conflicts/collisions with cabal and if there's a way to fix them?
17:20:56 <raphie> I'm most used to using NPM, where packages get local copies of all their dependencies
17:21:12 <johnw> twiceler: groupN n = uncurry (:) . second (groupN n) . splitAt n
17:21:37 <bennofs> @let import qualified Data.Set as S
17:21:38 <lambdabot>  Defined.
17:21:43 <raphie> :t uncurry
17:21:44 <lambdabot> (a -> b -> c) -> (a, b) -> c
17:22:23 <twiceler> johnw: Awesome! the arrow-ified version of what I wrote
17:23:01 <twiceler> johnw: Wait... But the base case. I'm not sure it will work
17:23:06 <bennofs> @let import qualified Data.Map as M
17:23:07 <lambdabot>  Defined.
17:23:10 <johnw> oh, I think you're right
17:23:44 <johnw> ok, not so great then
17:24:27 <twiceler> johnw: Yeah, it's just a point-free version of the non-base case
17:26:00 <bennofs> > let f k m = let ks = S.fromList k; mks = M.keysSet m in (S.toList $ mks `S.difference` ks, S.toList $ ks `S.difference` mks) in f [1,2,3] $ M.fromList [(1,3), (2,4), (5,4)]
17:26:00 <lambdabot>  ([5],[3])
17:40:03 <erisco> I don't believe Hoogle that there are not functions along the lines of [(a,b)] -> [(a,[b])]
17:42:04 <dhrosa_> erisco: what are you trying to do? are you just packaging the b's into singleton lists, or what?
17:42:24 <twiceler> :t (head &&& map snd) . groupBy ((==) `on` fst)
17:42:25 <lambdabot>     Couldn't match type `[(b1, b2)]' with `(a0, b0)'
17:42:26 <lambdabot>     Expected type: [[(b1, b2)]] -> [b0]
17:42:26 <lambdabot>       Actual type: [(a0, b0)] -> [b0]
17:43:01 <twiceler> :t map (head &&& map snd) . groupBy ((==) `on` fst)
17:43:02 <lambdabot> Eq b => [(b, b1)] -> [((b, b1), [b1])]
17:43:12 <twiceler> that's my guess :)
17:43:38 <twiceler> :t map ( (fst . head) &&& map snd) . groupBy ((==) `on` fst)
17:43:38 <lambdabot> Eq b => [(b, b1)] -> [(b, [b1])]
17:43:43 <twiceler> that's really my guess
17:44:49 <bennofs> @ty map mconcat . groupOn ((==) `on` fst)
17:44:49 <lambdabot>     Not in scope: `groupOn'
17:44:50 <lambdabot>     Perhaps you meant one of these:
17:44:50 <lambdabot>       `BSC.group' (imported from Data.ByteString.Char8),
17:44:55 <bennofs> @ty map mconcat . groupBy ((==) `on` fst)
17:44:55 <lambdabot> (Eq b, Monoid b, Monoid b1) => [(b, b1)] -> [(b, b1)]
17:45:15 <bennofs> @ty map (mconcat . map return) . groupBy ((==) `on` fst)
17:45:16 <lambdabot> (Eq b, Monad m, Monoid (m (b, b1))) => [(b, b1)] -> [m (b, b1)]
17:45:30 <bennofs> @ty map (mconcat . map (:[])) . groupBy ((==) `on` fst)
17:45:31 <lambdabot> Eq b => [(b, b1)] -> [[(b, b1)]]
17:45:56 <bennofs> @ty map (mconcat . map (fmap (:[]))) . groupBy ((==) `on` fst)
17:45:57 <lambdabot> (Eq b, Monoid b) => [(b, a)] -> [(b, [a])]
17:49:44 <rose_> Could anyone who has used mongodb via Haskell answer this SO question? http://stackoverflow.com/questions/20768151/mongodb-via-haskell-how-to-write-runcommand-query
17:55:55 <erisco> hmm... Ordering is ordered
17:56:26 <Eduard_Munteanu> Is there a way to interface with types in a foreign library without depending on it? Say I'm writing Program which uses LibA, and I want LibA to interface with LibB such that the latter is only required if Program depends on specific bits of LibA.
17:56:37 <Eduard_Munteanu> (not foreign in the FFI sense)
17:57:14 <bitemyapp> does anybody here use WAI Simple? Getting src/Web/Simple/Controller.hs:184:41: Not in scope: `serverName' when trying to build 0.6.0
17:57:20 <bitemyapp> 0.6.1 appears to be latest in the git repo.
17:57:32 <bitemyapp> Should I just use Scotty or some other micro-framework?
18:03:20 <erisco> @pl \x y -> fst x == fst y
18:03:20 <lambdabot> (. fst) . (==) . fst
18:04:21 <bennofs> @ty (==) `on` fst
18:04:22 <lambdabot> Eq b => (b, b1) -> (b, b1) -> Bool
18:04:40 <bennofs> is That what you want?
18:04:56 <erisco> :t on
18:04:57 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
18:04:59 <benbangert> trying to parse a binary file where parts determine how to decode additional structures
18:05:08 <Eduard_Munteanu> :t comparing fst
18:05:09 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
18:05:21 <benbangert> kind of lost on Data.Binary as it seems unclear how to operate within the Get monad, any better examples? or should I try for Autoparsec?
18:05:40 <Eduard_Munteanu> benbangert: you mean Attoparsec I guess
18:05:51 <benbangert> Eduard_Munteanu: yea
18:06:15 <benbangert> in this case I'm parsing a tree structure that was written by C, so there's a 'branch' var that indicates how many leaf children to read next
18:06:33 <erisco> bennofs, yes thank-you
18:07:12 <erisco> I ended up writing (Eq b) => (a -> (b, a)) -> [a] -> [(b, [a])]
18:07:19 <erisco> fmap (\xs -> (fst . head $ xs, fmap snd xs)) . groupBy ((==) `on` fst) . fmap f
18:08:27 <erisco> hm, wonder what is the smartest thing for (a -> b, a -> c) -> a -> (b, c) other than a lambda
18:08:49 <twiceler> :t (&&&)
18:08:50 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
18:09:20 <twiceler> :t (fst . head) &&& map snd
18:09:21 <lambdabot> [(c, b)] -> (c, [b])
18:12:20 <erisco> twiceler, I have not played with arrows yet but that is interesting. thanks
18:12:46 <johnw> we're really just using tuple-manipulation functions, not Arrows per se
18:12:53 <twiceler> erisco: they end up being really handy. Just like (<$>) = fmap in Control.Applicative
18:26:05 <raphie> can anyone recommend a good ORM library that doesn't use Templates? those give me the willies
18:28:28 <bitemyapp> raphie: maye you don't want an "ORM"?
18:28:41 <raphie> bitemyapp: what would I want instead?
18:28:41 <johnw> you can use persistent without TH, it will just require a whole lot of boilerplate you'll need to write yourself
18:29:12 <raphie> johnw: I got scared off by the weird data def syntax
18:29:23 <johnw> I'd recommend getting over your fear :)
18:30:02 <raphie> so there aren't any libs that make it easy using "vanilla" data defs?
18:30:09 <bitemyapp> ha, even HaskellDB uses TH.
18:30:21 <raphie> I mean, johnw, if Persistant is absolutely the best I'm willing to learn it, but I tend to shy away from DSL's
18:30:30 <johnw> i love persistent and esqueleto
18:31:24 <AlainODea> raphie: direct SQL is not so bad.  Having an ORM in the way tends to be a scalability headache in the long run.
18:31:27 <bitemyapp> esqueleto is probably the way to go for querying SQL databses at the moment.
18:31:35 <bitemyapp> with raw SQL if/when needed.
18:31:40 <raphie> well, I'm actually using Mongo at the moment
18:31:50 <raphie> so really an ODM ;)
18:31:54 <bitemyapp> if you do a good job of abstracting domain needs into functions that hide the SQL DB implementation, you can swap out backends fairly easily.
18:32:08 <bitemyapp> raphie: it's a fairly direct translation from documents to records.
18:32:16 <bitemyapp> good luck with migrations though. *gag gag gag*
18:32:26 <dhrosa_> hello, I'm using Parsec for the first time, http://lpaste.net/97497 how might I write this so that if neither of the three parsers work, a Nothing is returned?
18:32:55 <dhrosa_> and yes, i'm aware lpaste has told me liftM would be shorter
18:33:10 <raphie> heh. basically I've got a node app which uses mongo for data, and I want to run some NLP stuff on the data, and I'd rather gag myself with a spoon than do that sort of stuff with JS
18:34:09 <bitemyapp> raphie: hahaha. yeah. well, if you're using MongoDB, why not use a MongoDB library in Haskell?
18:34:20 <AlainODea> raphie: you don't need a mapping at all. Having a MongoDB Haskell library and your own data layer modules is sufficient
18:34:32 <bitemyapp> http://hackage.haskell.org/package/mongoDB and http://hackage.haskell.org/package/persistent-mongoDB come to mind.
18:34:41 <bitemyapp> I'm with AlainODea.
18:34:48 <raphie> bitemyapp / AlainODea: will I have to manually parse the docs into my haskell data structs though?
18:34:59 <bitemyapp> You don't need as much thick layering of abstraction when you're using a higher level language like Haskell or Clojure.
18:35:13 <bitemyapp> raphie: please look at the links I just provided.
18:35:21 <AlainODea> raphie: you'd use Aeson probably.  What kind of docs does MongoDB store?
18:35:26 <bitemyapp> raphie: don't ask questions documentation can answer better than we could. Find out if the libraries could serve your needs first.
18:35:29 <bitemyapp> AlainODea: stop.
18:35:40 <bitemyapp> AlainODea: you're enabling. I linked the official MongoDB client library for Haskell.
18:35:46 <bitemyapp> AlainODea: raphie needs to become accustomed to reading.
18:36:01 <johnw> bitemyapp: please do not be rude
18:36:05 <bitemyapp> if the official MongoDB client driver is somehow insufficient, alternatives can be explored.
18:36:35 <bitemyapp> johnw: I'll try to better sugar-coat next time, but I don't like enabling laziness.
18:36:39 <raphie> @hoogle =:
18:36:40 <lambdabot> No results found
18:36:51 <bitemyapp> particularly when directly relevant links have been provided.
18:37:01 <johnw> bitemyapp: thanks
18:38:16 <raphie> well, hoogle doesn't turn up anything for =: so can anyone explain what it does? I googled too, didn't turn up anything. doing my research this time :)
18:39:04 <johnw> raphie: =: is something that is defined by a specific package, so you'd need to look it up in the docs for that package
18:39:12 <johnw> is this with the MongoDB library?
18:39:58 <raphie> yeah johnw, the example has this: let post = ["author" =: "Mike", "text" =: "My first blog post!", "tags" =: ["mongoDB", "Haskell"]]
18:40:17 <raphie> I'm assuming it's some sort of shorthand for a map?
18:40:24 <raphie> Map with a captial M, I mean
18:40:59 <johnw> raphie: you'll find that operator here: http://hackage.haskell.org/package/bson-0.2.3/docs/Data-Bson.html
18:41:02 <AlainODea> :t Database.MongoDB.(=:)
18:41:03 <lambdabot> Couldn't find qualified module.
18:41:08 <johnw> bson is re-exported by MongoDB
18:42:35 <raphie> johnw: ahhhhh so really a document's type is [Field] and (=:) constructs a Field. cool. just for future reference (and so I don't have to bother you guys), how did you search for that within a package? is there a way to hoogle in that way?
18:43:09 <johnw> i went to hackage, and searched for "mongo"
18:43:24 <johnw> then I selected MongoDB, and browsed the module documentation looking for any occurence of =:
18:43:42 <johnw> i made a guess that it was coming from the re-export of a more basic library, which I saw on the first module's page
18:43:59 <raphie> ahh, so it requires a bit of intuition :) thanks though, you've been super-helpful
18:44:09 <johnw> yeah, these things become more familiar with time
18:44:22 <johnw> there's a certain logic to this stuff, which I admit may seem a bit confusing at first
18:45:25 <AlainODea> raphie: I import the imports of the example code and use ghci's :type for stuff like this after cabal installing (or cabal sandbox) the necessary packages found using johnw's method
18:46:36 <raphie> AlainODea: clever!
18:46:57 <raphie> again sorry if this is a basic question, but I haven't seen { ... } syntax before, so what does this mean?
18:47:00 <raphie> run $ find (select [] "posts") {sort = ["author" =: 1, "text" =: 1]} >>= rest
18:47:08 <bitemyapp> :browse is a life-saver when exploring.
18:47:16 <raphie> is that shorthand for a map or something?
18:47:33 <bitemyapp> raphie: looks like an imitation of record syntax to me.
18:47:54 <bitemyapp> probably so you can compose the queries like data?
18:48:53 <raphie> but is {sort = ["author" =: 1, "text" =: 1]} something native to haskell, or imported by the lib?
18:48:59 <raphie> the { ... } part
18:49:27 <novochar> Why can you reassign a variable with a do block but not within a where clause?
18:50:00 <erisco> novochar, because the former uses shadowing
18:50:05 <novochar> Also, is the reassignment of the variable considered to be type conversion?
18:50:05 <AlainODea> raphie: it is record syntax.  Check the type of the receiving function.  It likely takes a data type that is defined using Record syntax
18:50:17 <erisco> novochar, it is not reassignment it is shadowing
18:50:32 <ParahSailin> you can't "reassign" a variable
18:50:49 <raphie> AlainODea: ohhhh! right, perfect. sorry for the newbishness
18:51:44 <novochar> erisco: Do you have a link which describes how this works?
18:52:16 <AlainODea> raphie: no worries. Ask away. We're teaching you to fish here. bitemyapp is right on that. I need to teach not provide quick answers :)
18:52:21 <erisco> novochar, do notation is syntatical sugar.  x <- y   is   y >>= \x -> ...
18:52:54 <erisco> novochar, so the do block desugars to nested lambdas, which is why you can shadow variable names
18:53:47 <novochar> let x = 1; let x = 2 is equivalent to x >>= \x -> 1 >>= \x -> 2?
18:54:04 <bitemyapp> novochar: uh sorta, but the bind part is important.
18:54:09 <novochar> or x >>= \x -> 2 >>= \x -> 1?
18:54:14 <bitemyapp> novochar: bind is how you're passing control to the enveloping monad.
18:54:26 <bitemyapp> doesn't the bot have a desugaring command?
18:54:50 <erisco> novochar, no it is not equivalent to that
18:55:45 <bitemyapp> can we just invoke @undo against some example code to get the point across?
18:55:52 <twiceler> Ah.. this brings up something I was thinking about
18:55:53 <erisco> bitemyapp, I do not know
18:56:18 <johnw> bitemyapp: @undo
18:56:24 <twiceler> Is this true: do { let x = foo; ...} desugars to do { x <- return foo; ... }
18:56:30 <johnw> @undo do { x <- f ; print x }
18:56:30 <lambdabot> f >>= \ x -> print x
18:56:38 <erisco> novochar, let x = 1; let x = 2; is more like   let x = 1 in (let x = 2 in ...)
18:56:49 <erisco> > let x = 1 in (let x = 2 in x)
18:56:50 <lambdabot>  2
18:57:11 <erisco> the inner 'x' shadows the outer 'x'
18:57:23 <twiceler> @undo do { let x = 3; return x }
18:57:23 <lambdabot> <unknown>.hs: 1: 26:Parse error: }
18:57:24 <johnw> twiceler: I don't know if that's exactly the desugaring, since let can have multiple assignments there
18:58:30 <erisco> twiceler, afaik the binding does not interfere with the monad
18:58:42 <twiceler> So is it do { let x = foo; ...} desugars to let x = foo in do { ... }
18:59:00 <erisco> twiceler, afaik yes it is more like that
18:59:33 <twiceler> Cool, thanks. I've always just been baffled by the let syntax inside do notation
19:01:27 <erisco> do { b <- a; let c = b; return c; }  is probably   a >>= \b -> let c = b in c
19:01:48 <erisco> so the bindings are not all hoisted out of the do block
19:02:21 <erisco> a >>= \b -> let c = b in return c; that is
19:03:13 <mmmm> Is the Monoid type class not defined for Int in the standard library?
19:03:51 <bitemyapp> mmmm: http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html ?
19:04:32 <mmmm> I guess my question is more, why is it not
19:04:49 <erisco> mmmm, would you use + or *?
19:05:12 <mmmm> yes fair point
19:05:47 <pavonia> There are Sum and Product monoid, IIRC
19:05:47 <bitemyapp> highlander. there can be only one :)
19:05:57 <pavonia> :t Sum
19:05:58 <lambdabot> a -> Sum a
19:06:04 <bitemyapp> :i Sum
19:06:16 <bitemyapp> :(
19:06:23 <pavonia> > getSum $ Sum 10 <> Sum 20
19:06:24 <lambdabot>  30
19:06:53 <pavonia> > getProduct $ Product 10 <> Product 20
19:06:55 <lambdabot>  200
19:07:26 <mmmm> ok excellent thanks, that explains it
19:09:06 <mmmm> I pass on any ounce of festive cheer I have left whilst segueing into bed, thanks once again
19:09:46 <novochar> thanks
19:14:17 <nstdloop_> How useful is newtype?
19:14:40 <johnw> very
19:14:51 <nstdloop_> I'm reading the haskellwiki page on it
19:14:53 <johnw> but it's always optional, if you care nothing about performance or efficiency
19:14:57 <nstdloop_> and I sort of get why it might be a bit clean
19:15:07 <nstdloop_> but I don't see why it would be REALLY useful
19:15:11 <johnw> however, the general rule is: use it every time that you can
19:15:21 <johnw> it avoid a runtime box around the value
19:15:57 <nstdloop_> So this is the main use: "So if you want to declare different type class instances for a particular type, or want to make a type abstract, you can wrap it in a newtype and it'll be considered distinct to the type-checker, but identical at runtime."
19:16:11 <erisco> nstdloop_, for example Sum and Product are likely newtypes. they are useful for alternative class instances
19:16:14 <johnw> data Box a = Box a, at runtime is effectively a pointer to an a; newtype Box a = Box a is just an a
19:16:26 <nstdloop_> Aaag
19:16:29 <nstdloop_> Aaah*
19:16:38 <nstdloop_> That makes a lot of sense.
19:22:18 <novochar> When you utilize runghc (or even runhaskell), are you interpreting your code, skipping the compilation step?
19:23:27 <nstdloop> runhaskell == runghc
19:23:56 <nstdloop> (usually)
19:24:44 <novochar> Sure
19:25:50 <geekosaur> in any case --- yes and no. ghc has a bytecode compiler (can't save or load the resulting bytecode though), sort of a low-rent jvm thing
19:26:42 <geekosaur> bytecode backend doesn't have an optimizer
19:28:42 <danilo2> Hello! Is there a function in Haskell (or is it even possible to write one), which would have signature " eval :: a -> IO b " and will move given argument to IO. By move I understand look the whole structure and collect all IO operations, so "b" will not have nested IO operations? for example "eval" on [IO Int] would be equal to sequence
19:29:41 <nstdloop> danilo2: Could you clarify exactly what kind of behavior you want from this function?
19:29:56 <novochar> It's kind of being compiled, in this case to bytecode, except that it isn't being stored and the resulting code can't be retrieved. So it's like compiling, but not, and it's like an interpreter except that..?
19:30:50 <nstdloop> Typically something with type of a -> b isn't really going to work, because by nature of having a truly polymorphic type you can't read, change or instantiate values of either type, much less transform one to the other
19:31:10 <nstdloop> Do you mean a -> IO a?
19:31:31 <novochar> It's like an interperter since it interprets without a normal compilation step, but it's not an interpreter since it really does have an intermediate compilation-like step
19:31:42 <novochar> Is that accurate??
19:31:52 <novochar> Sorry for the double question mark symbols
19:32:50 <danilo2> nstdloop: I've just answered my question, sorry it was a stupid one. Thats probably because I'm tired. No - I was looking for a generic method of converting any data structure holding IO values to a structure packed in IO. For example for (data Vector a = Vector a a a) it would move (Vector (IO Int)) to IO(Vector Int)
19:33:09 <nstdloop> Ah. Ok.
19:33:11 <danilo2> nstdloop: But, the only solution for this is to make type class and instances for each datatype
19:33:50 <nstdloop> Sure.
19:34:35 <danilo2> By the way: does anybody know if would it be possible using Haskell's generics?
19:35:07 <novochar> Wait, bytecode is an instruction set for an interpreter. So it's like a typical interpreter, but without an optimizer. Is this right geekosaur?
19:36:13 <geekosaur> yes
19:36:30 <novochar> Thank you.
19:36:37 <geekosaur> (well, one could interpret directly instead of compiling to an intermediate bytecode, but I don't think even Hugs does that)
19:36:40 <nstdloop> danilo2: Not really sure if this is what you are looking for, but a quick hoogle search for a -> IO a gives evaluate
19:36:43 <nstdloop> which is defined here
19:36:43 <nstdloop> http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Exception-Base.html#g:7
19:37:09 <geekosaur> and, for a counterexample, perl does not compile to bytecode but does generate an AST which it evaluates
19:37:09 <nstdloop> actually
19:37:13 <nstdloop> ya this isn't what you need
19:37:15 <danilo2> nstdloop: No, evaluate on [IO Int] does not gives you IO [Int] (like sequence)
19:37:18 <nstdloop> on further inspection
19:37:26 <danilo2> nstdloop: :)
19:37:38 <benzrf> :i Lens
19:37:45 <benzrf> oh wait only :t works
19:37:48 <benzrf> :k Lens?
19:37:49 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
19:37:51 <benzrf> :k Lens
19:37:51 <lambdabot>     Type synonym `Lens' should have 4 arguments, but has been given none
19:37:52 <lambdabot>     In a type in a GHCi command: Lens
19:39:16 <danilo2> nstdloop: Heh, I do not think it is possible using "standard" methods. Such function would have signature (a -> IO a) for all types of a except of IO, where its signature would be (IO a -> IO a). So typeclasses or generics are the only options. I'm just wondering if generics can handle it.
19:39:53 <benzrf> does lambdabot have :i?
19:40:07 <pavonia> nope
19:40:29 <benzrf> so lame
19:40:49 <pavonia> @info foo
19:40:51 <lambdabot> foo
19:40:51 <benzrf> the args to lens are s t a b, right?
19:41:20 <benzrf> where s is the source structure, t is target structure, a is the type of the source field, b is the type of the target field
19:41:58 <johnw> yep
19:42:17 <johnw> and there is Lens' s a, for when t ~ s and b ~ a
19:42:29 <benzrf> ok
19:42:38 <benzrf> isnt that just a setter though?
19:42:50 <johnw> a Lens is a getter and a setter of exactly one element
19:43:00 <benzrf> getter AND setter?
19:43:02 <johnw> yes
19:43:06 <johnw> same with Lens'
19:43:09 <benzrf> wait, how can I view the definition for a type synonym?
19:43:14 <benzrf> @type
19:43:15 <lambdabot> <no location info>: not an expression: `'
19:43:18 <benzrf> P:
19:43:26 <johnw> I look it up in the source code
19:43:31 <benzrf> <_<
19:43:57 <benzrf> Control.Lens right>
19:44:22 <johnw> @hoogle Lens'
19:44:22 <lambdabot> No results found
19:44:33 <johnw> Control.Lens.Type
19:44:57 <benzrf> agh ive been writing ruby and I keep trying to type pry instead of ghci
19:45:11 <benzrf> which package is c.l in?
19:46:14 <blochchain> how should i use the function iterate on a function of type a -> IO a
19:46:36 <blochchain> as the list is of the form [a, IO a, IO IO a, IO IO IO a, ...]
19:46:41 <c_wraith> blochchain: you can't.
19:46:44 <c_wraith> :t iterate
19:46:45 <lambdabot> (a -> a) -> a -> [a]
19:46:56 <blochchain> yeah i was suspecting I'd need an alternative
19:46:57 <c_wraith> blochchain: the function's input and output types must be the same
19:47:15 <blochchain> what if i started with an IO a and lifted etc. etc.
19:47:18 <benzrf> blochchain: american psycho + bitcoins?
19:47:19 <c_wraith> you can write iterateM, but it very rarely useful - it often doesn't terminate
19:48:09 <benzrf> couldn't you make a lazy version of iterateM somehow?
19:48:27 <c_wraith> that depends on what property you want.
19:48:36 <c_wraith> You can do something like..
19:48:48 <benzrf> > which package is c.l in?
19:48:49 <lambdabot>  <hint>:1:22: parse error on input `in'
19:48:57 <benzrf> *Control.Lens
19:48:57 <c_wraith> :t scanl1 (<=<) . cycle
19:48:58 <lambdabot> Monad m => [c -> m c] -> [c -> m c]
19:49:03 <c_wraith> err
19:49:06 <c_wraith> :t scanl1 (<=<) . repeat
19:49:07 <lambdabot> Monad m => (c -> m c) -> [c -> m c]
19:49:09 <benzrf> :t scanl1
19:49:10 <lambdabot> (a -> a -> a) -> [a] -> [a]
19:49:16 <benzrf> :t scanl
19:49:16 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
19:50:14 <johnw> :t fix $ \loop m y -> do { x <- m y; liftM2 (:) (return x) (loop m x) }
19:50:14 <lambdabot> Monad m => (a1 -> m a1) -> a1 -> m [a1]
19:50:26 <benzrf> christ
19:50:28 <c_wraith> yeah.  that's the useless one
19:50:38 <benzrf> :t fix
19:50:39 <lambdabot> (a -> a) -> a
19:50:44 <johnw> :t fix $ \loop m y -> do { x <- m y; liftM (x:) (loop m x) }
19:50:45 <lambdabot> Monad m => (a -> m a) -> a -> m [a]
19:50:48 <c_wraith> That one's an infinite loop in almost every case
19:50:48 <benzrf> > fix (+2)
19:50:52 <lambdabot>  mueval-core: Time limit exceeded
19:50:55 <benzrf> > fix (+0)
19:50:58 <lambdabot>  mueval-core: Time limit exceeded
19:51:01 <johnw> i use fix for writing recursive lambdas
19:51:01 <benzrf> ??
19:51:06 <benzrf> @src fix
19:51:06 <lambdabot> fix f = let x = f x in x
19:51:09 <c_wraith> > fix (1:)
19:51:11 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:51:21 <benzrf> ._.
19:51:47 <johnw> @let iterateM m y = do { x <- m y; liftM (x:) (iterateM m x) }
19:51:48 <lambdabot>  Defined.
19:51:55 <c_wraith> johnw: yeah, that iterateM is basically useless.
19:52:01 <benzrf> can anybody tell me already!
19:52:04 <benzrf> what package is control.lens in
19:52:09 <johnw> lens
19:52:09 <c_wraith> lens
19:52:12 <benzrf> ok thx
19:52:51 <pavonia> google would have you told that within seconds
19:52:58 <benzrf> pfft
19:52:59 <johnw> c_wraith: yeah, it really is, unless you used unsafeInterleaveIO I guess
19:53:00 <benzrf> google is less fun
19:53:06 <larss> do you have to provide a module name before you can reuse functions from one file to another? there is no such thing as global (outside of any namespace) identifiers in C++?
19:53:21 <benzrf> larss: this is #haskell  not #cpp
19:53:24 <benzrf> or whatever channel
19:53:48 <johnw> @let iterateM m y = do { x <- m y; liftM (x:) (unsafeInterleaveIO $ iterateM m x) }
19:53:49 <lambdabot>  .L.hs:157:21: Not in scope: `unsafeInterleaveIO'
19:54:06 <larss> i phrased that in a clumsy way, I am asking if there is a haskell equivalent of global functions in C++
19:54:08 <benzrf> > scanl1 (+) [1, 2, 3, 4]
19:54:09 <lambdabot>  [1,3,6,10]
19:54:12 <c_wraith> unsafeInterleaveIterateM
19:54:36 <c_wraith> I guess it'd be IO, instead of M
19:55:22 <c_wraith> larss: imports guide the linking process, not the command line.  As such, you need to import things you'll use.
19:55:46 <c_wraith> larss: it's barely different than an #include
19:55:52 <lispy> larss: in ghci but not Haskell
19:56:21 <lispy> larss: the Haskell module system does let you import things such that you require (or not) a module prefix and you can set the prefix.
19:57:08 <larss> is there a way for an exported function to be global, outside of any module?
19:57:29 <geekosaur> does there need to be?
19:57:51 <larss> no, I am just asking if there is
19:57:54 <lispy> larss: in ghci but not Haskell
19:58:08 <dhrosa_> as in, you want a funcion to in scope, even if you didn't import it
19:58:09 <dhrosa_> ?
19:58:20 <geekosaur> that would be the Prelude
19:58:43 <lispy> and in the ghci case you still use a module prefix.
19:58:58 <lispy> you just don't have to import it before hand as long as you've fully qualified it
19:59:04 <geekosaur> also note that even C++ is moving away from that, with namespaces and with standard functions being moved to namespace std
19:59:07 <lispy> I guess that's different than using an anonymous namespace
19:59:16 <larss> dhrosa_: no, I am asking if it is possible for haskell function to exist outside of any module
19:59:18 <geekosaur> which is more or less the same kind of deal as Haskell's Prelude
19:59:34 <geekosaur> and the answer, again, is no
20:00:14 <geekosaur> and even C++ has recognized that namespaces make sense
20:00:28 <benzrf> alright, what's the point of the functor in Lens?
20:00:32 <larss> what if I omitt module name, is some default module used?
20:00:33 <lispy> now if they would see the value in imports...
20:00:54 <lispy> benzrf: watch edward kmett's videos, the spj talk on lens, or ask in #lens :)
20:01:01 <lispy> benzrf: it's a compilcated topic actually
20:01:06 <geekosaur> it looks for the name in the current module, which may have it from an import (either the implicit import of Prelude, or an unqualified module import)
20:01:07 <johnw> the spj talk on lens is by far the best place to begin
20:01:51 <flebron> > map chr $ scanl (+) 77 [24,13,0,7,-89,35,37,10,-9,10,1,-7,-12,18,-82,-1,26,-17]
20:01:52 <lambdabot>  "Merry Christmas! :)"
20:02:02 <Nebster173> Hello
20:02:27 <Nebster173> Nebster173> What does this mean?
20:02:28 <Nebster173> <Nebster173> âˆƒy(P(y) âˆ§ Q(y))
20:02:55 <lispy> benzrf: http://www.reddit.com/r/haskell/comments/1o1z8x/simon_peyton_jones_on_lenses_at_the_haskell/
20:02:57 <benzrf> there exists a y such that:
20:02:57 <johnw> There exists some y such that P(y) is a true proposition and Q(y) is true
20:02:59 <flebron> There exists a y, such that P(y), and Q(y).
20:03:00 <benzrf> ah
20:03:49 <lispy> flebron: cute
20:04:16 <larss> geekosaur: if I write a file without a module name at the top of a file my functions are placed in prelude module?
20:04:21 <lispy> > map chr $ scanr (+) 77 [24,13,0,7,-89,35,37,10,-9,10,1,-7,-12,18,-82,-1,26,-17]
20:04:22 <lambdabot>  ")\DC1\EOT\EOT*Exception: Prelude.chr: bad argument: (-3)
20:04:31 <Cale> larss: No, the module is named Main by default
20:04:33 <geekosaur> larss: no, Main
20:04:39 <larss> ah ok
20:05:23 <benzrf> lispy: what was that supposed to do
20:05:26 <geekosaur> there are ways to change that but I'm not sure what would happen if you forced it to be Prelude (I suspect an import error when the real Prelude was imported)
20:05:50 <flebron> Presumably spell out "Happy January 5th", the opposite of christmas I guess? :p
20:05:51 <lispy> benzrf: show me what happens when you change to scanr :)
20:06:00 <benzrf> oh i didnt see flebron's
20:06:18 <benzrf> > map ord "Merry Christmas! :)"
20:06:19 <lambdabot>  [77,101,114,114,121,32,67,104,114,105,115,116,109,97,115,33,32,58,41]
20:06:22 <benzrf> hmm
20:06:33 <lispy> my irc client seems to have gone crazy, brb
20:07:27 <lispy> ah, that's better
20:09:49 <benzrf> > map ord "Merry Christmas! :)"
20:09:49 <lambdabot>  [77,101,114,114,121,32,67,104,114,105,115,116,109,97,115,33,32,58,41]
20:10:09 <benzrf> > map ord $ scanl 77 (-) "Merry Christmas! :)"
20:10:10 <lambdabot>  Couldn't match expected type `GHC.Types.Char'
20:10:10 <lambdabot>              with actual type `a0 -> a0 -> a0'
20:10:32 <benzrf> > scanl1 (-_ $ map ord "Merry Christmas! :)"
20:10:33 <lambdabot>  <hint>:1:43:
20:10:34 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
20:10:40 <benzrf> > scanl1 (-) $ map ord "Merry Christmas! :)"
20:10:42 <lambdabot>  [77,-24,-138,-252,-373,-405,-472,-576,-690,-795,-910,-1026,-1135,-1232,-1347...
20:10:43 <benzrf> ?
20:10:52 <benzrf> oh
20:10:53 <benzrf> ugh
20:11:02 <larss> so what if two files both use implicit Main module?
20:11:46 * flebron used zipWith (-) (tail chars) chars to make his list
20:11:47 <geekosaur> link error, since the Main module must have a main :: IO a in it
20:11:49 <zq-_-_> :t ord
20:11:50 <lambdabot> Char -> Int
20:11:54 <geekosaur> and you can't have two of them
20:12:03 <larss> I guess there is no way to use them together in the same project without providing explicit module name, so no name clashes can occur?
20:12:18 <benzrf> flebron: gah i was thinking of rotate
20:12:42 <larss> geekosaur: I see
20:12:54 <geekosaur> and modules without a main :: IO a must have a `module SomeModuleName where` at the top
20:15:32 <larss> unless they are just used in ghci as someone said
20:17:02 <geekosaur> yes. ghci is more or less "desk calculator" mode
20:26:13 <marx2> `instance Eq Foo where', with no implemenation of == or /=, compiles silently and results in infinite loop at runtime because == and /= are implemented in terms of one another. is there a way to make ghc catch this?
20:26:25 <haasn> http://lpaste.net/97500 who says haskell isn't object oriented?
20:28:16 <Cale> marx2: There was a bunch of chatter not so long ago about how to add an extension for "minimal complete instance" declarations.
20:28:25 <Cale> I don't know what came of it
20:29:28 <flebron> Can Agda force a Functor to be honest? What about monads?
20:29:44 <Kron> it can with a shotgun wedding
20:34:12 <Cale> flebron: yes
20:34:31 <c_wraith> Cale: the extension has been implemented.  I don't recall if it made it into 7.8
20:35:13 <c_wraith> marx2: so the answer is "yes, but not in a version of GHC that is released yet."
20:35:22 <raphie> is there a place to ask about weird cabal errors? I'm having trouble installing skein-1.0.8 (a dependency of snap)
20:35:28 <Cale> flebron: In fact, it's even totally straightforward, you just add a member to the class for each of the equations.
20:35:34 <flebron> Cale: Cool :) I'll give Agda a spin this summer.
20:35:49 <Cale> (or record type)
20:36:42 <geekosaur> raphie: here, although the cabal experts may not be around at the moment
20:37:58 <marx2> thanks
20:39:02 <marx2> I am wondering if this will also work for third part classes? will it actually detect type class functions that are implemented in terms of one another?
20:39:41 <Cale> marx2: iirc, the proposal was just to let you specify what's required in the class declaration somehow
20:39:53 <c_wraith> marx2: https://ghc.haskell.org/trac/ghc/ticket/7633
20:40:55 <marx2> ah ok, got it
20:41:21 <c_wraith> marx2: be sure to read the whole discussion, the design changes several times
20:41:30 <raphie> geekosaur: ahhhh it was because OSX 10.9 uses Clang instead of GCC
20:41:41 <geekosaur> yes
20:42:22 * geekosaur has moved only one machine to 10.9, but installed haskell platform via macports so it's using macports gcc instead of apple clang
21:08:49 <rose_> Why am I getting a 'Parse error in pattern'? http://lpaste.net/97501
21:10:40 <geekosaur> line 4 of that paste (line 88) starts with a ! instead of a |
21:11:56 <geekosaur> not sure why it accounts it at the start of the definition, but that's probably because it's still parsing as a pattern
21:12:19 <geekosaur> ghc's parser is not so smart, compared to its typechecker etc.
21:24:52 <raphie> how do y'all feel about yesod vs. snap vs. scotty?
21:25:19 <edwardk> they each fill a niche
21:25:41 <edwardk> hrmm. http://lpaste.net/97502
21:27:44 <edwardk> was playing around with probability measures, was able to get a decent version of them for Beta, binomial, and a few other cases, using Covector Double for measures, but then I went to handle Poisson, negative binomial, etc. and it became clear i needed a more general way to construct the approximation
21:27:58 <raphie> edwardk: could you elaborate on the niches?
21:28:30 <edwardk> raphie: yesod is heavy weight, uses a lot of extensions, compiles somewhat slow, but gives a lot of correctness at compile time
21:29:24 <edwardk> raphie: snap is, well, probably the prettiest option. not sure i'm sold on heist (sorry mightybyte!) for templating, but its pretty straightforward, has a good story for how to build up sites compositionally with snaplets
21:29:56 <edwardk> scotty is IIRC, ultra-minimalist
21:30:44 <raphie> I gave scotty and snap a quick whirl and both seemed inferior to my usual Nodejs setup. so I'll try yesod :)
21:32:13 <Hat_and_Cloak> raphie: inferior in which regard? speed?
21:32:51 <raphie> understandability, heh
21:32:54 <raphie> very unscientific
21:33:33 <raphie> Scotty had paltry docs and confusing errors, Snap turned me off once it got into Lenses and stuff just to serve simple HTML
21:34:05 <Hat_and_Cloak> Hmm, thanks
21:34:35 <edwardk> raphie: the lens machinery pays out when you got to build more complicated sites.
21:35:03 <raphie> edwardk: howso?
21:35:26 <Cale> raphie: Perhaps look at Happstack too?
21:35:50 <edwardk> raphie: "snaplets" let you encapsulate bits of functionality. the lenses are how they find their configuration in the larger site configuration.
21:36:09 <edwardk> the #snapframework guys could answer better than i can
21:36:37 <raphie> edwardk: so like middleware?
21:36:56 <edwardk> its more like a "path" into the application state
21:37:42 <edwardk> when used right your little snaplets don't need to know all that much about how they wind up bolted into the final site
21:40:02 <raphie> edwardk: I'll take a closer look :)
21:40:14 <raphie> why does cabal installing something sometimes require a force reinstall?
21:42:45 <zq-_-_> not haskell related, bu what is the dfference between type propagation and type inference?
21:42:48 <edwardk> force reinstalls are needed when installing the new thing won't work with some version of something you have installed. you can often install several things at the same time to force a consistent plan
21:43:05 <jle`> is there any reason why Bool is an enum?
21:43:15 <jle`> besides the fact that it can be?
21:44:03 <raphie> edwardk: huh. I'm reading more Snap tutorials, and it just seems like too much "magic"
21:44:26 <edwardk> wait, you're coming from node and making that statement? ;)
21:44:58 <raphie> well node is a lot simpler!
21:45:22 <raphie> it doesn't tell me "oh there's this thing called a Lens don't worry about it, we use some sort of macro to make it, move along please"
21:45:25 <edwardk> scotty/happstack are pretty far down on the simple end of the spectrum if you're looking for something more minimalist
21:45:51 <jle`> so it's the TH that threw you off
21:45:53 <jle`> not the lenses themselves
21:46:10 <jle`> er, not the use of lense itself
21:46:28 <edwardk> the lens stuff pays out well, if you already know about lenses, it makes snap "fit in" to the rest of the haskell ecosystem very nicely. however, if you've never used lenses before they add something new to learn
21:47:08 <jle`> it did take me a while to understand that lense as a concept is completely unrelated to template haskell
21:47:50 <raphie> edwardk: so would you recommend Happstack or Yesod?
21:47:54 <raphie> which has less magic, heh
21:48:04 <edwardk> raphie: both of those are pretty heavy on the magic
21:48:39 <edwardk> raphie: if you want to understand every nut and bolt go with happstack or even something like scotty, though the latter is relatively barren
21:49:03 <raphie> hmm, does happstack have less TH?
21:49:24 <edwardk> if you want something you can grow into understanding all of the parts, go with snap. if you want something you'll pretty much always have TH magic to deal with for, then go with yesod. ;)
21:49:37 <edwardk> yes
21:50:13 <Hat_and_Cloak> while at it, can anyone provide accessible resource on lens outside fpcomplete and haskell.org?
21:50:57 <edwardk> Hat_and_Cloak: http://skillsmatter.com/podcast/scala/lenses-compositional-data-access-and-manipulation is a pretty decent starting point for understanding lens
21:51:31 <edwardk> Hat_and_Cloak: you can access http://lens.github.io/ as well
21:52:33 <Hat_and_Cloak> edwardk: Thanks, much appreciated :)
21:56:12 <novochar> Is there a popular task runner / build tool within the Haskell community?
21:56:27 <novochar> I found Hake, but it's last commit was 2 years ago
21:56:46 <Cale> novochar: Most people use Cabal to build Haskell projects
21:57:19 <Cale> http://hackage.haskell.org/package/shake sounds like a nice alternative to make though, if you have something else in mind
22:00:30 <Cale> http://www.youtube.com/watch?v=xYCPpXVlqFM -- there's a talk about Shake here
22:17:57 <jle`> novochar: hake isn't really maintained
22:18:06 <jle`> but Shake is well-maintained by neil mitchell
22:18:25 <jle`> and commonly used
22:18:54 <jle`> if you're looking for a make/rake dsl in haskell, shake is your man
22:18:57 <jle`> er
22:18:58 <jle`> library
22:19:05 <jle`> or woman
22:47:14 <bmuk> How do I improve the performance of calls to readProcess
22:59:49 <benbangert> so uh, I'm in a monad, and I want to repeat the monad N times to read N structures and pull a list out of the monad....is there a function I'm missing
22:59:52 <benbangert> ?
23:00:11 <simpson> :t replicateM_ -- this, maybe?
23:00:12 <lambdabot> Monad m => Int -> m a -> m ()
23:00:22 <simpson> :t sequence -- Also, this
23:00:22 <lambdabot> Monad m => [m a] -> m [a]
23:01:12 <benbangert> ahh, yea, lemme try that
23:01:36 <scott_> If you want the list, maybe you want replicateM without _
23:01:39 <scott_> :t replicateM
23:01:40 <lambdabot> Monad m => Int -> m a -> m [a]
23:01:59 <simpson> Oh, right, sorry.
23:02:49 <benbangert> scott_: yea, that seems the right one
23:03:28 <benbangert> now to convert the Word16 to an Int
23:03:52 <benbangert> is there another version of toInteger that just gives me an Int?
23:04:22 <zRecursive> :t fromIntegral
23:04:22 <lambdabot> (Integral a, Num b) => a -> b
23:05:09 <scott_> > replicate (fromIntegral (2::Integer)) 'a'
23:05:10 <lambdabot>  "aa"
23:05:45 <benbangert> ahhh
23:14:00 <benbangert> sweet, that did the trick
23:14:13 * benbangert loves it when the amount of code keeps dropping
23:14:18 <scott_> :)
23:20:40 <benbangert> I love having so little code to do soooo much
23:27:49 <dhrosa_> are lenses and zippers the same concept?
23:28:03 <startling> I don't think so.
23:28:14 <startling> There's some lensy stuff in 'lens' for doing zippers, though.
23:29:14 <speckle> Hello! Regarding GUIs in Haskell: do you all think it is more practical to define widgets using a markup language, and have Haskell interface with the markup language, instead of directly specifying layouts programmatically?
23:31:11 <Olive`> speckle I think that's a good idea.
23:31:49 <Olive`> I like the HTML/CSS model a lot, even though they both have their shortcomings.
23:32:16 <triliyn> dhrosa_: I think prisms are intimately related to zippers
23:32:56 <triliyn> It seems to me that they are the same concept, but I haven't studied either enough to say that with confidence
23:33:18 <startling> triliyn: I'd love to see something like that but I don't think it's true.
23:33:40 <speckle> Yeah Olive`, I am not a huge fan of HTML/CSS, but it's disappointing how declarative DSLs haven't caught on for widgets on the desktop.  I think we could do much better with the expressiveness of a language like Haskell.  Thanks!
23:33:45 <startling> Prisms just map multiple-argument constructors to and from tuples of the same number of arguments.
23:34:05 <startling> This notion of "contructor" is generalized, but ...
23:34:42 <triliyn> I might have the wrong name
23:34:55 <triliyn> There was a thingy in lens with "review" and "preview" I think?
23:35:03 <startling> > preview _Just (Just 12)
23:35:05 <lambdabot>  Just 12
23:35:11 <startling> > review _Just 12
23:35:12 <lambdabot>  Just 12
23:35:26 <startling> > preview _Left (Left 12) -- this is a better example
23:35:28 <lambdabot>  Just 12
23:35:32 <triliyn> Right
23:35:38 <startling> _Right.
23:35:44 <triliyn> :P
23:35:48 <startling> :)
23:35:53 <startling> How does this relate to zippers?
23:36:12 <startling> n.b. preview and review are much more general than this.
23:36:51 <triliyn> hmm
23:37:00 <pavonia> :t _Just
23:37:01 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
23:37:17 <triliyn> Acutally, now that I think of it... maybe the similarity I saw was just lens itself?
23:37:30 <startling> > preview _1 (1, 2) -- preview takes any traversal and returns the first element so traversed, if it exists.
23:37:32 <lambdabot>  Just 1
23:37:40 <startling> > preview traverse [1, 2, 3]
23:37:41 <lambdabot>  Just 1
23:38:06 <triliyn> It's a method of "focusing" on a piece of a structure and a way to inject new values into that piece
23:38:15 <startling> hmmmm, ok.
23:38:16 <triliyn> But you could say that of lens as a whole
23:38:23 <triliyn> I  think
23:38:24 <startling> the missing concept is "shifting", I think.
23:38:44 <triliyn> hmmm
23:38:47 <startling> edwardk_, is there a notion of shifting lenses (a la zippers)?
23:39:18 <startling> maybe that's what C.L.Zipper does ? (I've yet to figure it out).
23:46:28 <AshyIsMe> speckle: you could probably do something quite nice with Fay and a packaged up webkit
23:48:14 <issam> hi guys
23:48:23 <issam> I can't make this work :(,
23:48:25 <issam> countOnes ls = if ls == [] then return 0
23:48:26 <issam> 	else
23:48:26 <speckle> AshyIsMe, thanks, I'll take a look.
23:48:26 <issam> 	(if (head ls) == 1 then return (countOnes (tail ls) + 1) else return countOnes (tail ls) )
23:48:39 <issam> sorry is should Pastebin it
23:49:00 <issam> http://pastebin.com/Wirp8tB5
23:49:04 <mauke> The paste Wirp8tB5 has been copied to http://lpaste.net/97503
23:49:38 <issam> http://pastebin.com/agFdzGBm
23:49:41 <issam> this is with the error
23:49:42 <mauke> The paste agFdzGBm has been copied to http://lpaste.net/97504
23:50:20 <notdan> issam: why do you have 'return' in the code?
23:50:37 <dhrosa_> issam: haskell return is different from return in other languages
23:51:16 <notdan> anyway, the second returns bind in the following way: (return countOnes) (tail ls)
23:52:22 <notdan> the more idiomatic way to write that snippen would be to do something like this: http://lpaste.net/97503
23:52:55 <issam> oh i see
23:53:03 <issam> so I write the value without return
23:53:22 <notdan> Yes
23:53:39 <issam> thanks :)
23:53:53 <issam> one question though, why does haskell's return differ?
23:54:13 <issam> and thanks for the concise code
23:54:18 <issam> much cleaner
23:54:51 <dhrosa_> a lot of things you would normally do with if's can be written much more cleanly using pattern mtaching, like notdan's code
23:55:14 <issam> yes
23:55:37 <notdan> Well in Haskell functions are a little bit like equationsl; countOnes, for instance, is a pure mathematical function, and return is more of a procedural-oriented keyword, if I can put it this way
23:55:38 <issam> what about the use of Guards? does it constitute best practices?
23:55:50 <notdan> return in Haskell is useful if you do things like IO
23:56:01 <notdan> 'return' in fact is part of the Monad typeclass in Haskell
23:56:02 <issam> makes sense
23:56:07 <hamid> issam, the "return" value is actually a function i really needed someone to tell me this when i was learning haskell at the beginning :P
23:56:14 <issam> lol
23:56:28 <dhrosa_> return in haskell is used to place values into Monads
23:56:46 <hamid> issam, i meant the "return" itself.
23:57:01 <pavonia> @type return
23:57:02 <lambdabot> Monad m => a -> m a
23:57:06 <notdan> oh yeah, it was very wrong of me to call 'return' a keyword btw
23:57:13 <notdan> it is most definitely a function
23:57:14 <issam> yes
23:57:31 <issam> that makes it clearer
23:58:14 <dhrosa_> for example, return 2 in a list context is [2], return 2 in a Maybe contest is (Just 2), etc
23:58:25 <startling> issam: "Monad" is sort of an interface; "return" is part of the interface that says "turn a thing of type 'a' into a thing of type 'm a' for this Monad m'.
23:59:54 <issam> Cool, but maybe i could understand it with examples :), where is it commonly used
