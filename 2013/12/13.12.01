00:14:27 * hackagebot gtk 0.12.5.0 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.12.5.0 (HamishMackenzie)
00:14:27 * hackagebot commodities 0.0.1 - Library for working with commoditized amounts and price histories  http://hackage.haskell.org/package/commodities-0.0.1 (JohnWiegley)
00:48:06 <johnw> hmm.. wonder why it reported that twice
00:49:25 * hackagebot commodities 0.1.0 - Library for working with commoditized amounts and price histories  http://hackage.haskell.org/package/commodities-0.1.0 (JohnWiegley)
01:14:27 * hackagebot gtksourceview2 0.12.5.0 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview2-0.12.5.0 (HamishMackenzie)
01:24:28 * hackagebot webkit 0.12.5 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.12.5 (HamishMackenzie)
01:34:04 <eccstartup> Am I still online?
01:34:38 <yoni0505> yes
01:34:48 <eccstartup> Where is hamlet-1.1.7.4.tar.gz in http://hdiff.luite.com/packages/archive/hamlet/ ?
01:36:10 <eccstartup> Is looks like a package a few days ago, but not in `hdiff`.
01:36:29 <eccstartup> It is in hackage!
01:36:50 <johnw> i'm not sure what hdiff's status is wrt Hackage 2
01:38:20 <eccstartup> I can see that gtk-0.12.5.0 is there.
01:38:31 <eccstartup> http://hdiff.luite.com/packages/archive/gtk/
01:38:54 <eccstartup> If it works well, hamlet should be there.
01:54:31 * hackagebot webkit-javascriptcore 0.12.5.0 - JavaScriptCore FFI from webkitgtk  http://hackage.haskell.org/package/webkit-javascriptcore-0.12.5.0 (HamishMackenzie)
01:57:05 <martsbradley> let fn = ((++) "foo")
01:57:13 <martsbradley> is not the same as
01:57:13 <martsbradley> let fn = (++  "foo")
01:57:27 <martsbradley> First one gives
01:57:32 <martsbradley> Prelude> fn "bar"
01:57:32 <martsbradley> "foobar"
01:57:40 <martsbradley> Second one gives
01:57:42 <martsbradley> Prelude> fn "bar"
01:57:42 <martsbradley> "barfoo"
01:57:43 <johnw> yes
01:58:03 <jle`> the first one is the function  (++) which appends the second to the first, in order
01:58:09 <jle`> the second one is an operator ++
01:58:10 <johnw> the second is an operator section, the first is calling ++ as a prefix operator
01:58:29 <johnw> (or as a function, as jle` said)
01:58:35 <jle`> the missing item "goes" in to the left
01:58:48 <jle`> like if you write (++ "foo"), it's like there's a missing string to the left
01:59:28 <jle`> it's convenient when you want to map things and only want to supply the second argument
01:59:50 <jle`> > map (++ "foo") ["bar","baz","jazz"]
01:59:51 <lambdabot>   ["barfoo","bazfoo","jazzfoo"]
01:59:57 <jle`> imagine doing that without sections
02:00:17 <johnw> > map (flip (++) "foo") ["bar","baz","jazz"]
02:00:18 <lambdabot>   ["barfoo","bazfoo","jazzfoo"]
02:00:49 <martsbradley> Yes seen that in ghci just now.
02:01:08 <jle`> > map (/ 2) [4, 8, 16]
02:01:09 <lambdabot>   [2.0,4.0,8.0]
02:01:44 <jle`> the fact that you can use sections the other way though always felt redundtant to me
02:01:51 <jle`> > map (2 /) [4, 8, 16]
02:01:52 <lambdabot>   [0.5,0.25,0.125]
02:01:54 <jle`> why not just do
02:02:03 <jle`> > map ((/) 2) [4, 8, 16]
02:02:04 <lambdabot>   [0.5,0.25,0.125]
02:02:19 <jle`> i guess looking at it, there is a stylistic thing.
02:02:31 <jle`> actually i kind of like the former now.
02:02:41 <martsbradley> Thanks folks, I must have missed this during my attempted learnings
02:03:16 <jle`> martsbradley: it's okay, i fumbled over this several times before getting the hang of it
02:07:23 <ibotty> hi short question, is there a theoretical or practical reason why ghc cannot derive `Show` instances for existential quantified data types?
02:09:32 * hackagebot these 0.4 - An either-or-both data type, with corresponding hybrid error/writer monad transformer.  http://hackage.haskell.org/package/these-0.4 (JohnWiegley)
02:12:32 <Cale> ibotty: Usually you can't even write such an instance by hand?
02:13:49 <ibotty> but for many you can... Show is possible if you have, say,
02:13:49 <ibotty> > data A = forall a . Show a => A a
02:13:50 <lambdabot>   <hint>:1:1: parse error on input `data'
02:14:26 <ibotty> or am i missing something?
02:15:16 <Cale> Well, yeah
02:15:49 <Cale> I guess what it could do is to try to write the instance the way it usually would anyway, and typecheck that.
02:16:24 <ibotty> that's what i expected it would do. well, maybe that's going to be my excuse to dive a little into ghc :D
02:16:56 <ibotty> i just wanted to know why it refuses. whether there is an example that it is harmful, or something like that
02:17:13 <ibotty> thank you for your reply :)
02:29:33 * hackagebot gitlib-libgit2 2.2.0.1 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-2.2.0.1 (JohnWiegley)
02:49:35 * hackagebot commodities 0.2.0 - Library for working with commoditized amounts and price histories  http://hackage.haskell.org/package/commodities-0.2.0 (JohnWiegley)
02:53:15 <SwashBuckla> henk: check out Elm! http://elm-lang.org
02:53:49 <Iceland_jack> SwashBuckla: What's Elm?
02:55:02 <SwashBuckla> Iceland_jack: I'll tell you Iceland_jack. It's a Functional Reactive Programming language based on Haskell which supposedly makes writing GUIs easier
02:55:10 <Iceland_jack> SwashBuckla: ;P
02:55:11 <SwashBuckla> I'm studying it for my dissertation
02:55:18 <SwashBuckla> (you tool, you)
02:55:21 <Iceland_jack> haha
02:55:45 <Iceland_jack> I don't know what you're talking about
02:56:05 <Cale> Is this some new kind of troll?
02:56:54 <Iceland_jack> Cale: We know each other, I think I mentioned Elm to SwashBuckla (iirc)
02:57:29 <Cale> I see :)
02:57:30 <SwashBuckla> yeah you got me into it Iceland_jack
02:57:36 <BlairA>  On a slight side note does it make writing GUIs any easier? (I've been meaning to try it for a while)
02:57:47 <SwashBuckla> BlairA: I think it does
02:58:10 <SwashBuckla> I'm doing user participation studies to see if people actually find it easier, for some observable definition of easy
02:58:50 <SwashBuckla> The thesis of which Elm is a product describes Elm as allowing a natural separation of data, logic and presentation code
03:00:00 <nadirs> so, with the same language you define structure (HTML), presentation (CSS) and logic/behavior (JS)?
03:00:22 <nadirs> (sorry to jump in, btw)
03:01:10 <nadirs> Swizec? *That* Swizec?
03:01:17 <Swizec> ?
03:01:38 <nadirs> http://swizec.com/blog/
03:03:30 <SwashBuckla> nadirs: yes. Take a look at the thesis on http://www.seas.harvard.edu/sites/default/files/files/archived/Czaplicki.pdf
03:03:57 <nadirs> thanks
03:04:20 <SwashBuckla> nadirs: top of page 42
03:06:02 <nadirs> although, by looking at the generated markup, it's not exactly the cleanest result you'd get by actually writing the thing using native languages
03:06:30 <nadirs> but that's understandable, I guess
03:06:33 <SwashBuckla> nadirs: True.
03:09:33 <nadirs> SwashBuckla: on the other hand, by looking at the PDF you linked, the DSL itself looks very clean and expressive (I'm a beginner at Haskell, just for the record)
03:15:06 <isomorphic> @src foldr1
03:15:06 <lambdabot> foldr1 _ [x]    = x
03:15:06 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
03:15:06 <lambdabot> foldr1 _ []     = undefined
03:19:38 * hackagebot crunghc 0.1.0.0 - A runghc replacement with transparent caching  http://hackage.haskell.org/package/crunghc-0.1.0.0 (AkioTakano)
03:22:34 <henk> SwashBuckla: thanks
03:23:16 <SwashBuckla> nadirs: I'm also a complete beginner in Haskell and Elm
03:23:49 <SwashBuckla> but I am excited by it, and Iceland_jack's enthusiasm and expertise motivated me to check it out
03:33:14 <nadirs> on a completely unrelated note: has anyone given a try at the 99problems for Haskell?
03:33:22 <nadirs> link ‚Üí http://www.haskell.org/haskellwiki/H-99%3a_Ninety-Nine_Haskell_Problems
03:34:12 <PatrickRobotham_> I've got Ninety Nine problems but a runtime error ain't one.
03:34:30 <Iceland_jack> > [1..99] ++ [error "what!"]
03:34:31 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:35:15 <nadirs> PatrickRobotham_: haha I saw that coming :P
03:40:21 <hagb4rd> hello.. short question: can i make lambdabot join other channels on freenode by command`? (without to host it by myself)
03:40:36 <hagb4rd> or by asking you O:-)
03:54:41 * hackagebot lord 2.20131201 - A command line interface to online radios.  http://hackage.haskell.org/package/lord-2.20131201 (rnons)
03:59:33 <henk> SwashBuckla: meh, another website which simply shows not a damn thing without scripts ‚Ä¶
04:01:54 <nadirs> henk: I think Elm is not aimed to end-user accessibility, but rather to (non-GUI-)developer ease of GUI building
04:02:06 <nadirs> but I might be wrong
04:03:31 <henk> nadirs: I‚Äôm trying to find out, but I‚Äôm already put off by seeing a blank page unless I enable scripts for the site ‚Ä¶
04:04:19 <Iceland_jack> henk: I encourage you to enable scripts to at least give code examples a look :)
04:07:00 <henk> yeah, I probably will ‚Ä¶ I‚Äôm weak.
04:09:08 <adimit> hspec question: I'd like to have auto-discovery of specs via the preprocessor (i.e. my tests all live in a top-level spec :: Spec function,) but for the tests I need to first read in a bunch of files (i.e. execute an IO action with a result and pass that to the Spec.) How do I do that?
04:09:39 <adimit> hpsec only provides before and after :: IO () -> Spec -> Spec. I'd need specWith (or so) :: IO a -> (a -> Spec) -> Spec.
04:13:53 <benmachine> adimit: surely all you do is have an IO Spec that gets the tests you want, and then main is do spec <- fetchTests; hspec spec
04:15:06 <adimit> benmachine: that won't work with automatic spec discovery.
04:15:22 <benmachine> oh I see
04:15:31 <adimit> since I don't have a main function. It's a hack, I know, but I quite like it.
04:15:32 <benmachine> no I don't quite see
04:15:38 <benmachine> oh
04:15:44 <benmachine> how does it work
04:16:03 <adimit> All my spec files need to have the suffix "Spec.hs" and be below the "Spec.hs" file with the prepocessor directive.
04:16:10 <adimit> (in the directory hierarchy.)
04:16:24 <adimit> they need to contain a toplevel binding of the form spec :: Spec
04:17:01 <adimit> and *this* is the thing that runs the tests. That's why I can't just run an IO action in main, then pass it around.
04:17:13 <benmachine> hmm
04:17:15 <adimit> (its result around)
04:17:26 <benmachine> well, if it's only for tests, you could consider unsafePerformIO
04:17:33 <benmachine> you've got one hack, why not have another :P
04:17:44 <adimit> yeah, that's what I'm currently doing, but I'd have liked a more principled way :-D
04:18:26 <nadirs> question about ". (dot) function": is there a standard/built-in equivalent of `.` but with reversed arguments? Like "reversedDot a b = b . a"?
04:18:43 <benmachine> nadirs: from Control.Arrow there's >>>
04:18:51 <benmachine> which is more general but works as a reversed .
04:19:07 <nadirs> benmachine: thanks!
04:19:13 <benmachine> adimit: hmm. you can embed doing IO in an Example
04:19:37 <adimit> benmachine: exactly. But I cannot share its result across examples.
04:19:56 <adimit> nadirs: alternatively, you can do flip (.)
04:20:42 <benmachine> adimit: ho hum. then yeah, I don't think the API is set up to do what you want
04:21:02 <benmachine> it might make more sense for the preprocessor thing to be changed so that it looks for IO Spec at the toplevel
04:21:09 <benmachine> but that's outside your domain
04:21:20 <nadirs> adimit: I was looking for a single function (so I don't have to redefine something that exists already). But thanks for the alternative
04:23:37 <adimit> benmachine: I've looked at the hspec code, and it seems that it should be rather trivial to extend it by something like mkSpecWith :: IO a -> (a -> Spec) -> Spec. I'll just file bug report & patch, and do it the unsafePerformIO way for now.
04:23:46 <adimit> benmachine: thank you for your help!
04:23:57 <benmachine> np :)
04:28:26 <bennofs> Is there a way to tell cabal to install an executable component prior to running tests?
04:29:20 <fizruk> bennofs, why would you need that?
04:29:38 <bennofs> because I wan't to run tests against the executable?
04:29:39 <adimit> bennofs: not that I know of. (if I understand you correctly, you'd like cabal to install, say "happy" and have it available as an executable binary before running tests?)
04:30:28 <bennofs> yes, when I'm using sandboxes, and manually do cabal install exeComponent before running cabal test, cabal test already sets the path correctly (adding .cabal-sandbox/bin to PATH)
04:31:17 <adimit> bennofs: the best way I can think of to do that is to add the executable to the tests' build-depends.
04:31:23 <adimit> it should then always be available.
04:31:44 <adimit> (I don't know if that'll work, you'll have to try it out.)
04:33:27 <bennofs> adimit: that fails with an error
04:33:27 <bennofs> cannot satisfy -package-id ghc-server-0.1-inplace
04:33:29 <bennofs> when building tests
04:33:45 <adimit> then you need to cabal install ghc-server first.
04:33:53 <adimit> (within the sandbox.)
04:34:11 <adimit> or you can do cabal install --only-dependencies --enable-tests.
04:34:16 <adimit> That'd automatically install it.
04:34:55 <isomorphic> Why isn't there a double instance of maxBound?
04:35:10 <mikeplus64> > 1/0 :: Double
04:35:11 <lambdabot>   Infinity
04:35:15 <fizruk> bennofs, looks like you just add package itself to the deps: http://hackage.haskell.org/package/hashable-1.1.2.2/hashable.cabal
04:35:34 <isomorphic> Oh‚Ä¶
04:35:42 <isomorphic> > Infinity :: Double
04:35:43 <lambdabot>   Not in scope: data constructor `Infinity'
04:36:08 <bennofs> adimit: that only works if ghc-server was a library
04:36:41 <benmachine> isomorphic: that's a fair question, although you'd wonder where nan fit into the story
04:37:33 <isomorphic> benmachine:  I think the idea in proliferation of these types is to make life exciting.  I mean, why have Null, null, Nil, and 0?
04:38:48 <benmachine> bennofs: I think if I wanted to test an executable, I'd test it before installing it, inplace
04:39:21 <benmachine> although admittedly I wouldn't know how to do that exactly >_>
04:40:03 <bennofs> I guess I'll have to use the Custom build type for that :|
04:40:03 <isomorphic> Reason I ask the question - I'm using repa and I need to construct a min operation - my plan is to use a fold.  But I need an initial value that's 'neutral' with respect to min.   Infinity is perhaps the right answer - is there a way of constructing an infinite double value?
04:40:39 <bennofs> > infinity
04:40:40 <lambdabot>   *Exception: stack overflow
04:40:43 <bennofs> :O
04:40:48 <bennofs> lambdabot weirdness
04:41:02 <bennofs> (I think infinity doesn't exist in plain haskell)
04:41:13 <FireFly> @ty infinity
04:41:14 <lambdabot> Natural
04:41:26 <benmachine> isomorphic: (1/0)'ll do it
04:41:28 <FireFly> Heh.
04:41:43 <benmachine> I don't know of a better way
04:42:05 <isomorphic> Heh..  Slightly crazy way to achieve it‚Ä¶ Lemme see what happens
04:42:05 <benmachine> > read "Infinity" :: Double
04:42:06 <lambdabot>   Infinity
04:42:12 <benmachine> ^ that's also an option
04:42:26 <bennofs> > 1/-0
04:42:27 <lambdabot>   Not in scope: `/-'
04:42:27 <lambdabot>  Perhaps you meant one of these:
04:42:27 <lambdabot>    `-' (imported from P...
04:42:30 <bennofs> > 1/(-0)
04:42:31 <lambdabot>   -Infinity
04:43:51 <FireFly> > 0 == -0
04:43:52 <lambdabot>   True
04:43:57 <FireFly> fun
04:45:06 <bennofs> > 1/(-0) == 1/0
04:45:07 <lambdabot>   False
04:45:17 <bennofs> :| That's indeed weird
04:45:37 <bennofs> > (0 :: Double) == (-0 :: Double)
04:45:37 <Iceland_jack> That's just standard floating points
04:45:38 <lambdabot>   True
04:45:56 <Iceland_jack> > (1/(-0), 1/0)
04:45:57 <lambdabot>   (-Infinity,Infinity)
04:46:25 <bennofs> So a == b and c == d doesn't imply a/c == b/d :(
04:47:03 <Iceland_jack> bennofs: https://en.wikipedia.org/wiki/IEEE_floating_point
04:47:14 <Entroacceptor> infinity is wrong anyway
04:48:14 <haasn> > infinity > 1000
04:48:15 <lambdabot>   True
04:48:35 <Iceland_jack> A lot of things ‚Äòbreak‚Äô when working with floating point numbers, that's how it is in (almost) every language
04:48:51 <Iceland_jack> normally associative operations are non-associative
04:48:54 <frxx> almost?
04:48:55 <nadirs> what module does infinity belong to?
04:49:05 <bennofs> I know that floating point is crazy, but I didn't know yet that this property break
04:49:15 <bennofs> :i infinity
04:49:19 <bennofs> @index infinity
04:49:20 <lambdabot> bzzt
04:49:29 <bennofs> ew?
04:49:37 <nadirs> bennofs: in ghci I get "Top level: Not in scope: `infinity'"
04:49:39 <Iceland_jack> bennofs: ?
04:49:51 <bennofs> @index Just
04:49:51 <lambdabot> Data.Maybe, Prelude
04:50:02 * haasn did not know that command exists
04:50:45 <haasn> nadirs: might be defined in lambdabot
04:51:05 <haasn> nadirs: oh, or this: http://hackage.haskell.org/package/numbers-3000.2.0.0/docs/Data-Number-Natural.html#v:infinity
04:51:21 <haasn> yeah, that makes sense, considering ‚Äònumbers‚Äô is a pretty standard package
04:51:29 <nadirs> haasn: Hoogle doesn't find it (http://www.haskell.org/hoogle/?hoogle=infinity)
04:51:43 <bennofs> > 4 / (-(3-3)) == 4 / (-3+3)  -- Oh
04:51:44 <lambdabot>   False
04:52:06 <bennofs> ok, one might argue that I'm dividing by zero anyway
04:52:09 <nadirs> > -3+3
04:52:10 <lambdabot>   0
04:52:33 <Iceland_jack> bennofs: What do you mean one might argue :) how is that *not* what you're doing?
04:52:33 <nadirs> I thought it would have yielded -6
04:53:17 <haasn> > 1/1e-100 == 1/(-1e-100)
04:53:18 <lambdabot>   False
04:53:29 <haasn> oh, except it's correct in this case
04:53:37 <haasn> > 1e-100 == (-1e-100)
04:53:38 <lambdabot>   False
04:53:39 <bennofs> Iceland_jack: well, I still find the behaviour weird. But division by zero should be undefined anyway, so I shouldn't expect anything
04:53:48 <haasn> > 1e-1000 == (-1e-1000)
04:53:49 <lambdabot>   True
04:54:27 <bennofs> > 0/0
04:54:28 <Iceland_jack> bennofs: Be happy you have the standard, things were a lot worse once: you couldn't imagine
04:54:28 <lambdabot>   NaN
04:54:32 <Iceland_jack> bennofs: http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
04:59:45 <Iceland_jack> > let a = (0/0, sqrt (-1.0)) in (a, uncurry (==) a)
04:59:46 <lambdabot>   ((NaN,NaN),False)
04:59:51 * hackagebot snaplet-mysql-simple 0.1.1.2 - mysql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-mysql-simple-0.1.1.2 (ibotty)
04:59:53 * hackagebot snaplet-mysql-simple 0.1.1.3 - mysql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-mysql-simple-0.1.1.3 (ibotty)
05:02:03 <isomorphic> Turns out 1/0 works for my application‚Ä¶
05:02:19 <frxx> @pl (\w m -> Map.insertWith (+) w 1 m)
05:02:19 <lambdabot> flip (Map.insertWith (+)) 1
05:12:59 <bennofs> > 1 < sqrt(-1)
05:13:00 <lambdabot>   False
05:13:03 <bennofs> > 1 > sqrt(-1)
05:13:04 <lambdabot>   False
05:13:07 <bennofs> > 1 == sqrt(-1)
05:13:08 <lambdabot>   False
05:13:10 <bennofs> ha :p
05:20:55 <lasticot> does someone how to have a git hub repository link toward another rep? For instance https://github.com/jordi-chacon/pongerl/tree/master/dep.
05:21:03 <lasticot> know*
05:22:42 <donri> lasticot: git help submodules
05:22:51 <donri> singular
05:23:16 <lasticot> donri: ok thanks
05:24:40 <quchen> ocharles: Where's my first door!
05:24:49 <quchen> I woke up for *nothing*! :-(
05:27:52 <quchen> bennofs: Division by zero isn't undefined, depending on what 'division' is. For floats it makes a lot of sense to have 1/0 = infinity, and for the same reasons it's also important to have +0 and -0.
05:28:58 <quchen> > (1/0, 1/(-0), 1/(1/0), 1/(1/(-0)))
05:28:59 <lambdabot>   (Infinity,-Infinity,0.0,-0.0)
05:29:05 <quchen> That's pretty handy for numerical code.
05:40:53 <berdario> Hi, I have a possibly dumb question: "Why are from* functions so prevalent in Haskell?" I remember struggling at the beginning to understand which conversion functions actually fitted my use case, but after reading about HM type inference, and playing a bit with F# and Ocaml, I'm wondering why there's this difference
05:40:54 <bennofs> Can I use CPP to indentify the cabal version in a Setup.hs file?
05:41:50 <hpc> berdario: the from functions tend to be unsafe and only there so you don't have to write them yourself
05:41:53 <hpc> @src fromJust
05:41:53 <lambdabot> fromJust Nothing  = undefined
05:41:53 <lambdabot> fromJust (Just x) = x
05:41:56 <berdario> for example, for float conversion, F# has the float function, of type (int -> float) but that actually uses an op_Explicit defined for each type to return int http://msdn.microsoft.com/en-us/library/vstudio/dd233220.aspx
05:42:11 <hpc> berdario: if you find yourself using lots of froms, consider pattern matching, fmap, and other combinators
05:42:33 <berdario> hpc: unsafe? I know that fromJust is unsafe... but I thought it was the exception
05:42:44 <hpc> oh, you mean like fromInteger
05:42:47 <berdario> yes
05:42:54 <berdario> fromInteger, fromRational, fromList
05:43:03 <berdario> they always return a parametric type
05:43:13 <berdario> (like, there's a fromList for Set, for Vector, etc.etc.)
05:43:39 <hpc> it's the easiest way to convert up/down the numeric class tree
05:43:49 <bennofs> fromList may loose information
05:43:54 <hpc> fromList is special in that it's more of a constructor
05:44:13 <bennofs> Having a conversion that looses information doesn't seem like a good idea to me
05:44:44 <bennofs> For example, it could happen that you accidently convert your list to a Set and back. Then your lists is sorted, implicitly
05:44:59 <hpc> > M.fromList [("yes", 1), ("no", 0), ("file not found", 67)]
05:45:01 <lambdabot>   fromList [("file not found",67),("no",0),("yes",1)]
05:46:16 <berdario> hpc, wouldn't having a lot of functions toInt32, toWord8, toFloat, toDouble that take parametric input be at least as convenient?
05:46:28 <frxx> not sure how realistic it is that someone would accidentally type toList (fromList list) without realizing what is going on
05:46:30 <berdario> I looked up on hoogle
05:46:31 <berdario> http://www.haskell.org/hoogle/?hoogle=from+-package+-template-haskell+-containers+-old-time
05:46:34 <berdario> http://www.haskell.org/hoogle/?hoogle=to+-package+-template-haskell+-containers+-old-time
05:47:05 <hpc> berdario: it would work, but not as conveniently
05:47:09 <berdario> and I fail to see when I should expect a to* function, and when I should expect a from*
05:48:21 <berdario> hpc: is there an example for that? (I was thinking of asking this on StackOverflow, but then I thought that maybe it wasn't interesting enough... and maybe that was the reason for the fact that I cannot find anything)
05:48:51 <bennofs> berdario: I think that fromBla builds up a structure from a simpler structure and toBla tears down data to a simpler structure
05:48:53 <hpc> @src floor
05:48:53 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:50:44 <berdario> bennofs, thanks... but I tend to think that Int32 is as simple as Int... am I just mistaken?
05:50:54 <hpc> berdario: to use your examples of toInt32, toWord8, toFloat, toDouble
05:51:00 <berdario> btw, I know one advantage of this approach over F# http://stackoverflow.com/a/15461699/293735
05:51:06 <hpc> berdario: how do you refer to all of those conversions polymorphically?
05:51:22 <hpc> when you want an operation that's generic on all such things
05:51:57 <berdario> having an implicit fromInteger for literal, lets us write something like (2.0 / 2)
05:52:35 <hpc> we already have that, but suppose you get more complex
05:52:46 <hpc> \x y z -> (floor x + floor y) / z
05:52:55 <hpc> :t \x y z -> (floor x + floor y) / z
05:52:56 <lambdabot> (Fractional a, Integral a, RealFrac a1, RealFrac a2) => a1 -> a2 -> a -> a
05:53:19 <berdario> hpc, well... toInt32 would be (Integral a) => a->Int32, isn't this the kind of polymorphims you intended?
05:53:43 <hpc> berdario: so, \x y z -> toInt32 (floor x + floor y) / z
05:54:10 <hpc> but what if we wanted Integer, or Word8?
05:54:13 <cyrix> berdario what if you want result to be Num?
05:54:18 <cyrix> :t let x = (10::Int) in 10 + (fromIntegral x)
05:54:19 <lambdabot> Num a => a
05:54:23 <hpc> now we have to write 20-some different functions
05:54:48 <hpc> for each of [word/int][8/16/32/64], word, int, integer, ...
05:54:54 <berdario> it would have type (RealFrac a) => a -> a -> Int32 -> Int32
05:54:57 <hpc> meanwhile...
05:55:03 <hpc> :t \x y z -> fromInteger (floor x + floor y) / z
05:55:04 <lambdabot> (Fractional a, RealFrac a1, RealFrac a2) => a1 -> a2 -> a -> a
05:56:21 <hpc> berdario: you can't write the function with that generic type if you don't have fromInteger / one of the other froms that might work
05:56:36 <berdario> yes, I agree that it's more generic
05:56:50 <berdario> but I'm not sure that this makes the code shorter and easier to understand
05:57:15 <berdario> I mean: often I find that the output of one function isn't of the type I was expecting
05:57:24 <berdario> (my fault for not writing a signature, I know)
05:57:51 <berdario> and that's due to the fact that the output type is something like (Fractional a)
05:58:29 <berdario> and then, when doing type inference, it gets specialized to the wrong type, because of a bug in a function that uses its result
05:58:50 <berdario> maybe the problem is that I've only wrote small scripts in haskell
05:59:13 <cyrix> berdario you can easily simulate toInt32 with fromIntegral if you wish.  (fromIntegral x :: Int32)
05:59:26 <berdario> if I had to implement libraries to be used by someone else, having a generic output type could be convenient indeed
05:59:59 <berdario> cyrix: yes, yes... I'm used inside the ghci to always specify the type I want the conversion to work to
06:01:07 <berdario> but still, I've seen a lot of people using (fromIntegral x :: Int32) or similar things, and I was starting to wonder if having a toInt32 by default wouldn't actually save people from writing such things over and over again
06:03:13 <bennofs> Is transformers a boot package?
06:04:54 <berdario> now that I think about it... I'm thinking that Haskell is "behaving differently" from Ocaml and F#... but maybe this is actually an inherited choice from Miranda?
06:08:00 <berdario> uhm, there're no Miranda examples on rosettacode :/
06:08:28 <benmachine> berdario: are you aware that there is a toInteger and toRational?
06:08:58 <benmachine> fromIntegral = fromInteger . toInteger, so it's as much a to-function as a from-function in that sense
06:09:05 <benmachine> it's just how it ended up being named
06:09:28 <benmachine> analogously, realToFrac = fromRational . toRational
06:09:53 <bennofs> it should be called throughInteger (that's a bad name, i know) or something :p
06:09:54 <berdario> benmachine: yes, but I'm still trying to grok the implications
06:10:02 <donri> someone should use the new role-based coercions to implement -fcoerce-type-errors a la -fdefer-type-errors ;)
06:10:24 <bennofs> coerce type errors? What should that do?
06:10:27 <benmachine> donri: excuse me, my eyes seem to be bleeding
06:10:28 <berdario> if someone could point me to a mailing list archive or something where this choice was first discussed it'd be wonderful :)
06:10:42 <donri> bennofs: insert "coerce" anywhere there's a type error ;)
06:10:48 <benmachine> berdario: what choice do you mean?
06:11:05 <benmachine> donri: -funsafeCoerce-type-errors
06:11:12 <benmachine> what could go wrong??
06:11:27 <donri> benmachine: yeah but that would actually be useless, while it sorta *could* work with Coercible
06:11:42 <berdario> benmachine: implementing fromIntegral instead of functions like those I mentioned before
06:12:14 <bennofs> Is Data.Sequence slower than Data.DList for append-only and traverse once usage?
06:12:36 <donri> bennofs: very possibly yes
06:12:56 <donri> cons and function composition is dirt cheap
06:13:34 <donri> Seq adds quite a lot of overhead, it's actually slower than [] for the right uses of []
06:13:39 <donri> (relatively)
06:13:52 <donri> (even without dlist)
06:13:56 <bennofs> Hmm, what packages can I depend on in Setup.hs?
06:14:08 <berdario> uhm, Miranda had a generic num type
06:14:29 <berdario> (it had only 3 primitive types apparently: num, bool and char )
06:14:44 <berdario> so, this behaviour obviously doesn't come from Miranda
06:14:58 * hackagebot Dust 2.2.2 - Polymorphic protocol engine  http://hackage.haskell.org/package/Dust-2.2.2 (BrandonWiley)
06:16:38 <donri> berdario: i think the number type class hierarchy in haskell is generally considered not optimal, but having a single number type to cover everything would be worse
06:17:08 <berdario> donri: I agree wholeheartedly‚Äé
06:17:28 <berdario> uhm, were type classes seen in Haskell for the first time?
06:17:46 <donri> berdario: if you write highly generic code you'll only rarely need type conversions, ie. mostly between classes of types instead of types
06:19:08 <donri> (it might be you run into this need more often in ghci because of lack of type information there. on the other hand ghci has extended default rules...)
06:19:58 <berdario> yes
06:19:58 * hackagebot Dust-tools 1.2.2 - Network filtering exploration tools  http://hackage.haskell.org/package/Dust-tools-1.2.2 (BrandonWiley)
06:20:33 <berdario> btw, I think I found it: ‚ÄúHow to make ad-hoc polymorphism less ad hoc‚Äù by Philip Wadler and Stephen Blott
06:21:36 <berdario> unfortunately, I just found a postscript... and it seems I cannot search for text inside it
06:24:50 <berdario> uhm, no... at the time, it proposed a Coerce typeclass and functions like convertInttoFloat
06:29:06 <cyrix> sortBy (comparing snd) xs <- how to reverse the sorting order?
06:29:30 <donri> :t Down
06:29:31 <lambdabot> a -> Down a
06:29:49 <benmachine> cyrix: flip
06:29:50 <sipa> @hoogle Down
06:29:50 <donri> > Down 2 `compare` Down 1
06:29:50 <lambdabot> Graphics.UI.GLUT.Callbacks.Window Down :: KeyState
06:29:51 <lambdabot> GHC.Exts Down :: a -> Down a
06:29:51 <lambdabot> GHC.Exts newtype Down a
06:29:51 <lambdabot>   LT
06:29:59 <benmachine> cyrix: to get the opposite result, pass the arguments in the opposite order :)
06:30:16 <benmachine> the Down newtype is also an option, yes
06:31:22 <donri> sipa: Data.Ord in recent base
06:31:27 <Iceland_jack> sortBy (flip (comparing snd))
06:31:38 <Iceland_jack> If you don't have the relevant version of base
06:31:49 <cyrix> I tried flip comparing snd. why are parenths needed?
06:32:05 <donri> hm why isn't there a getDown accessor though
06:32:05 <cyrix> or rather, why is it flip (comparing snd) instead of (flip comparing) snd
06:32:06 <Iceland_jack> flip comparing snd == (flip comparing) snd
06:32:28 <Iceland_jack> Look at the type of ‚Äòcomparing snd‚Äô
06:32:31 <Iceland_jack> @ty comparing snd
06:32:32 <lambdabot> Ord a => (a1, a) -> (a1, a) -> Ordering
06:32:37 <Iceland_jack> then think of what you want to do
06:32:42 <donri> :t flip comparing
06:32:43 <lambdabot> Ord a => b -> (b -> a) -> b -> Ordering
06:32:57 <cyrix> ok makes sense
06:34:13 <Iceland_jack> namely (using incorrect Haskell):
06:34:13 <Iceland_jack>     X `comparing snd` Y = snd X `compare` snd Y
06:34:13 <Iceland_jack> while
06:34:13 <Iceland_jack>     X `flip (comparing snd)` Y = snd Y `compare` snd X
06:37:05 <jotatiua_4583> hello
06:37:15 <Iceland_jack>     instance Ord a ‚áí Ord (Down a) where
06:37:15 <Iceland_jack>         Down x `compare` Down y ‚âî y `compare` x
06:37:18 <Iceland_jack> hey jotatiua_4583
06:39:06 <JuanDaugherty>  ‚  <- what is that, it's not rendered comprehensibly in xchat or the log.
06:39:17 <benmachine> JuanDaugherty: looks like an a with a ^ on it
06:39:25 <Iceland_jack> An a with a circumflex
06:39:40 <benmachine> tell xchat to use UTF-8
06:39:40 <JuanDaugherty>         Down x `compare` Down y ‚ y `compare` x
06:39:47 <benmachine> oh
06:39:52 <Iceland_jack> that is :=
06:40:08 <JuanDaugherty> <Iceland_jack> that is :=
06:40:31 <benmachine> JuanDaugherty: between the two y is a symbol composed of : and =
06:40:45 <benmachine> meaning "defined to be", typically
06:40:51 <nilg> I found a typo in Learn You a Haskell for Great Good, where should I report it?
06:41:04 <JuanDaugherty> so why is it  ‚ in "  Down x `compare` Down y ‚ y `compare` x"
06:41:21 <Iceland_jack> JuanDaugherty: Because you're using an incorrect encoding
06:41:30 <pooperpoop> I want to fuck you in the ass iceland_jack
06:41:36 <pooperpoop> and then put my mouth under your ahole
06:41:38 <Iceland_jack> well you'll have to get in line
06:41:39 <pooperpoop> and start licking it
06:41:42 <nooodl> @where ops
06:41:42 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
06:41:44 <JuanDaugherty> you mean xchat and the public log of this channel are, right?
06:41:46 <pooperpoop> while you let some hot steaming turds into my mouth
06:41:52 <pooperpoop> oh yeah
06:42:01 <pooperpoop> but first you have to dine on some corn on the cob
06:42:04 <pooperpoop> and chocolate exlax
06:42:05 <Iceland_jack> pooperpoop: Do you have a Haskell question?
06:42:07 --- mode: ChanServ set +o geekosaur
06:42:08 <pooperpoop> I looooov corn
06:42:11 <pooperpoop> in my poop
06:42:15 <benmachine> nilg: good question, the author used to hang out in here but I haven't seen them recently
06:42:19 <pooperpoop> geekosaur
06:42:20 --- mode: geekosaur set +b *!*pooperpoo@200.79.253.*
06:42:20 --- kick: pooperpoop was kicked by geekosaur (pooperpoop)
06:42:45 <geekosaur> laaaaaaaaame
06:43:09 <benmachine> they waited 10 hours before saying that
06:43:22 --- mode: geekosaur set -o geekosaur
06:43:24 <benmachine> all gotta have hobbies I guess
06:43:38 <nilg> I'll shoot him an email
06:43:44 <Iceland_jack> I'm not sure what happened but I believe I got asked out on a date
06:43:54 <binq> Lol
06:44:00 <JuanDaugherty> popularity has a price. #lisp gets a disproportinate amount of it for its pop
06:44:04 <JuanDaugherty> (ulation)
06:44:12 <benmachine> preflex: seen BONUS
06:44:12 <preflex>  BONUS was last seen on #haskell 2 years, 215 days, 19 hours, 9 minutes and 40 seconds ago, saying: yeah i think that's better as well
06:44:17 <benmachine> :(
06:44:53 <JuanDaugherty> anyway whatever coding you're using isn't rendering in xchat or the public log though no doubt it does whereever you pasted it from
06:46:20 <geekosaur> actually it rendered fine here (in xchat) although your repaste shows the a-circumflex
06:47:13 <benmachine> in the public log, I see the original symbol fine but none of the √¢s
06:47:25 <geekosaur> U+2254 COLON EQUALS
06:47:32 <benmachine> apart from that one just now
06:48:15 <geekosaur> (and spurious a-hat is often a sign of something decoding as iso8859-1 instead of utf8)
06:48:43 <benmachine> right
06:51:09 <RenRenJuan> on Mac it renders as a circumflex (in the log anyway)
06:52:24 <geekosaur> seriously, make sure you're using utf8
06:54:36 <bennofs> Wow, I didn't know GHC could do this: Patterns not matched: GHC.Types.C# #x with #x `notElem` ['-']
06:54:51 <bennofs> (the `notElem` part)
07:00:02 <geekosaur> even better, if you try hard enough you can get it to leak that the thing inside the box is the wrong size :p
07:03:13 <JuanDaugherty> geekosaur: acknowledged, and confirmed that default coding on DOS 7 renders as simple equal sign
07:07:02 <teneen> is it possible to overwrite an instance of a certain type?
07:07:53 <geekosaur> no, although if you use newtype you can define your own instance for it
07:08:49 <Dasuraga> teneen: it's possible to specify a more precise instance if you use UndecidableInstances
07:09:20 <teneen> I wish I could be able to prevent some instances from being imported
07:09:24 <Dasuraga> for example you can have a class C , specify an instance for (C a)=> (C [a]), but then specify another instance for String=[Char]
07:09:28 <teneen> it's a more general solution
07:09:38 <binq> but then you also have to reimplement all the other things it was an instance of in the newtype right?
07:09:51 <Dasuraga> teneen: could you be more specific?
07:10:09 <Dasuraga> is it exactly the same instance you want to implement? Or is it a specific case of a more general instance?
07:10:20 <augur> hm
07:10:27 <augur> row polymorphism is interesting
07:10:33 <teneen> Dasuraga: I just wish I could do "import A hiding (instance E R, instance T F...)"
07:11:26 <teneen> is this even doable in ghc in it's current state?
07:11:59 <Taneb> teneen, no, that's impossible
07:12:19 <Taneb> I don't like instances, they're coarse and rough and get everywhere
07:12:34 <teneen> Taneb: why not?
07:12:52 <Taneb> Because GHC can't
07:13:13 <Taneb> There are some very good reasons for it but I'm not enlightened enough to explain, sorry
07:14:09 <Dasuraga> teneen: the problem is that if the module has the instance declaration, it will depend on it
07:14:22 <jerv> is it possible to find out if some particular type is in some particular type class?
07:15:10 <teneen> Dasuraga: that's exactly what I want
07:15:29 <teneen> I'll implement the new instance which the module should use
07:16:18 <Dasuraga> are you saying you're importing a module A , but you want to change the instance the module A uses? even inside module A?
07:16:36 <Dasuraga> instances are implemented as a map from datatypes to functions, each datatype has its set of functions
07:17:27 <Dasuraga> you can't modify that map, so you have to chose only one instance implementation
07:18:45 <binq> teneen: why can't you use newtype like geekosaur mentioned
07:19:29 <geekosaur> because they want to change existing uses of the type, they can't make the existing module use the newtype instead
07:19:36 <geekosaur> (but they can't change it anyway, so...)
07:19:41 <teneen> binq: it's not a general easy solution to the problem, everytime I'll have to go through that hassle
07:19:50 <skypers> @hoogle IO Bool -> m a -> m ()
07:19:51 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
07:19:51 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
07:19:51 <lambdabot> Control.Exception.Base finally :: IO a -> IO b -> IO a
07:20:04 * hackagebot dlist 0.6.0.1 - Difference lists  http://hackage.haskell.org/package/dlist-0.6.0.1 (SeanLeather)
07:20:25 <teneen> for the newtype solution I'll have to provide instances for all typeclasses even the ones I need not changed
07:20:33 <geekosaur> jerv: there's no instance search I'm aware of. if the instance is in scope, ghci's :info will show it to you
07:20:44 <timthelion> Is the function "apply: a -> (a -> b) -> b \n apply a f = f a" defined somewhere? Hoogle didn't find it.
07:21:03 <geekosaur> jerv: but it won't help you find a module which has such an instance
07:21:04 <Iceland_jack> timthelion: ($) close enough
07:21:14 <Iceland_jack> you can use flip ($)
07:21:18 <Iceland_jack> @ty flip ($)
07:21:19 <lambdabot> b -> (b -> c) -> c
07:21:42 <Iceland_jack> Some libraries define (&) as flip ($)
07:21:46 <timthelion> aha :)
07:21:47 <timthelion> thanks
07:21:51 <Iceland_jack> @ty (&)
07:21:52 <lambdabot> a -> (a -> b) -> b
07:22:18 <Iceland_jack> I personally like (|>) = flip ($) but de gustibus
07:22:26 <timthelion> Iceland_jack: can't get by in continuation passing style without it.
07:22:38 <Iceland_jack> What do you mean?
07:22:43 <skypers> 16:14 < Iceland_jack> Some libraries define (&) as flip ($)
07:22:52 <skypers> again, I think it should be in Data.Function
07:22:57 <skypers> and exported by Prelude
07:23:13 <Cale> I find (&) a bit silly myself.
07:23:22 <skypers> do you prefer ($$) ?
07:23:30 <Cale> Put the functions to the left of their arguments.
07:23:38 <Iceland_jack> If we're going to use operators for everythiing then (|>) makes a lot more sense
07:23:48 <skypers> Cale: lens abuse of that style
07:23:49 <Iceland_jack> it takes longer to type but poo
07:23:57 <skypers> because it‚Äôs more convenient
07:23:59 <Iceland_jack> It's what Elm uses incidentally
07:24:04 <Cale> It's no more convenient
07:24:13 <Cale> It's just unconventional
07:24:18 <skypers> Iceland_jack: (|>) from Sequence ?
07:24:20 <Iceland_jack> No
07:24:31 <Iceland_jack> just (|>) = flip ($)
07:24:46 <timthelion> Iceland_jack: Ironically, I'll be using |>, since I'm writing in elm ;)
07:24:56 <Iceland_jack> timthelion: You can always write 'apply a f' as 'f a' so you never really need it
07:25:02 <xcthulhu> Isn't flip ($) an instance of (>>>) in Control.Arrow?
07:25:13 <Iceland_jack> xcthulhu: (>>>) is more general
07:25:19 <Cale> xcthulhu: no
07:25:27 <Cale> flip (.) is
07:25:30 <xcthulhu> Iceland_jack: That's why I thought it was an instance...
07:25:39 <Iceland_jack> gah, yes my bad xcthulhu
07:25:59 <Iceland_jack> It's flip (‚àò), not flip ($)
07:26:33 <timthelion> Iceland_jack: yes you do, if you're writing in the style shown in Wadler's 1992 paper"The essence of functional programming."(I'm doing CPS parsing) where f might have a very long string of CPSified lambdas before you get to the a...
07:27:06 <xcthulhu> Hmm... could you instance flip ($) as (>>>) given suitable meets and joins?
07:27:19 <Cale> hm?
07:27:27 <Cale> :t flip ($)
07:27:27 <lambdabot> b -> (b -> c) -> c
07:27:31 <Cale> :t (>>>)
07:27:31 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
07:27:32 <timthelion> Iceland_jack: http://homepages.inf.ed.ac.uk/wadler/papers/essence/
07:27:39 <Cale> no
07:27:49 <Iceland_jack> timthelion: Do give an example
07:27:51 <Cale> There's no way to make those types unify
07:28:36 <Iceland_jack> Note that you can always use (\f x -> x f) for flip ($) so I don't see how you ever *need* it
07:29:33 <xcthulhu> Iceland_jack: Well, it's a common pattern in clojure and f# to use chains of (|>) in computation
07:29:40 <xcthulhu> Since it's like a unix pipe
07:30:12 <Iceland_jack> I'm aware, what is the actual point though?
07:30:15 <timthelion> Iceland_jack: Open up the link, and look at some of the example code on page 13
07:30:44 <timthelion> Iceland_jack: you would't want to put your a after all those lambdas ;)
07:30:54 <timthelion> Iceland_jack: so |> is really much nicer...
07:30:56 <Iceland_jack> timthelion: Read what I wrote
07:31:25 <xcthulhu> Iceland_jack: Well, in clojure it saves on lots of parens, or long let statements...
07:31:28 <Iceland_jack> I said I liked (|>), I didn't say ‚Äúit never looks better with it‚Äù
07:31:56 <Iceland_jack> I simply said you didn't need it, and you don't
07:32:28 <xcthulhu> Iceland_jack: It's fair to say it's not idiomatic haskell, either
07:32:47 <Iceland_jack> xcthulhu: What exactly? Wadler's code?
07:33:03 <Iceland_jack> Afaik Clojure has no |> macro, it does have -> et al
07:33:53 <jerv> Noobie question: how come when we define a function add :: a -> a -> a that adds up two elements, that we can still pass an integer and a float? Are they the same type in Haskell?
07:34:13 <Iceland_jack> jerv: We don't define the type as: a ‚Üí a ‚Üí a
07:34:20 <Iceland_jack> But rather use something called type classes
07:34:45 <xcthulhu> Iceland_jack: No, the little (|>) combinator (some call it "thrush")
07:34:46 <Iceland_jack> You can think of Integer and Float belonging to the same set called Num:
07:34:46 <Iceland_jack>     Num = { Integer, Float, ... }
07:34:46 <geekosaur> also note that numeric literals are polymorphic
07:34:51 <jerv> so (Num a) => a->a->a says that you can pass two types of the class Num, right?
07:34:54 <geekosaur> :t 5
07:34:55 <lambdabot> Num a => a
07:35:01 <Cale> jerv: They have to be the same type
07:35:07 <Iceland_jack> jerv: Yes, two of the same type
07:35:17 <Cale> jerv: Whatever type 'a' is, it must be the same between the two parameters and the result
07:35:30 <Cale> But it may be Integer, or Float, or any other instance of Num
07:35:42 <Iceland_jack> so if you have:
07:35:42 <Iceland_jack>     add :: (Num a) => a -> a -> a
07:35:42 <Iceland_jack> it can be
07:35:42 <Iceland_jack>     add :: Integer -> Integer -> Integer
07:35:45 <Iceland_jack> or
07:35:48 <Iceland_jack>     add :: Float -> Float -> Float
07:36:02 <jerv> so when I call add 3.0 2, is the type of 2 Int or Float?
07:36:14 <jerv> I'm guessing Float?
07:36:15 <Iceland_jack> jerv: Float
07:36:16 <Cale> It'll default to Double
07:36:24 <jerv> Ok
07:36:32 <Iceland_jack> if 3.0 has type Float, 2 will have type Float
07:36:32 <Cale> :t 3.0
07:36:33 <lambdabot> Fractional a => a
07:37:08 <Iceland_jack> xcthulhu: Thrush is ->, not |> afaict: if you care you can show me links that say otherwise
07:37:09 <jerv> so type polymorfisme refers to the fact that the type variable can be any instance of the type class?
07:37:17 <xcthulhu> Iceland_jack: Also, yeah, I'm aware that clojure's thrush is -> (or ->>) rather than (|>) (which I believe is from f#
07:37:47 <skypers> 16:27 < jerv> so (Num a) => a->a->a says that you can pass two types of the class Num, right?
07:37:53 <skypers> btw, a type is not ‚Äúof‚Äù a class
07:37:54 <Iceland_jack> xcthulhu: I'm not sure why this conversation came up to be honest, -> is a macro in Clojure: not a combinator
07:38:00 <skypers> it _can_ be _in_ a class
07:38:06 <jerv> I understand
07:38:15 <skypers> like the math concept of class actually
07:38:30 <skypers> Int can be in the class of Eq, Ord or Num
07:38:37 <jerv> Is the main goal of type classes to add abstraction or to make the type system more pure?
07:38:37 <skypers> well, it is, actually.
07:38:51 <xcthulhu> Iceland_jack: A link?  We can just reason it out.  1 |> +2 == 3 , and in clojure (-> 1 #(+ % 2)) again is 3, right?
07:38:53 <skypers> add abstraction, yes
07:39:01 <skypers> it lets you overload a concept for a type
07:39:13 <jerv> Aha of course
07:39:17 <jerv> I see it now
07:39:20 <skypers> the (==) concept states that given two values, you got a boolean
07:39:29 <jerv> right right :) nice I got it
07:39:30 <Iceland_jack> xcthulhu: It's not a function, combinators are functions. /
07:39:30 <jerv> thanks
07:39:31 <skypers> you can overload that for a specific type
07:39:33 <skypers> :)
07:39:35 <Rylee> @src (==)
07:39:36 <lambdabot> x == y = not (x /= y)
07:39:36 <Iceland_jack> There is no need to reason it out
07:39:52 <Rylee> @src (/=)
07:39:53 <lambdabot> x /= y = not (x == y)
07:40:08 <skypers> yeah, optional implementations
07:40:08 <Rylee> hehehehe
07:40:19 <skypers> one can only implement either (==) or (/=)
07:40:21 <skypers> or both
07:40:23 <xcthulhu> Iceland_jack: You are right, it's a macro.  However, #(-> %1 %2) is exactly the same as |>, up to the fact that clojure is untyped.
07:41:04 <Iceland_jack> Whether it's untyped doesn't matter, I don't know why you started talking about this in the first place
07:42:21 <xcthulhu> Iceland_jack: I was talking about how something like |> has it's use in other functional programming, as it basically is like a unix pipe; I gave clojure and F# as examples, and used some terminology a bit loosely.
07:42:26 <xcthulhu> So I'm sorry for that
07:45:47 <Iceland_jack> You seem to be trying to convince me of something I'm already aware of then :)
07:50:52 <blablub> why do i have to write "someFun $ \arg -> ..." instead of just "someFun \arg -> ..." -- why is the ($) needed?
07:55:29 <henk> I need to handle lengths of time in two formats in my program and convert between these two formats: seconds (basically Int(eger), I‚Äôd guess) and H:M:S (String?). I got the advice to create my own datatypes. Are there better, easier, existing ways of handling this or are my own datatypes the best solution?
07:59:26 <JuanDaugherty> hackage is ur friend henk
07:59:53 <skypers> I‚Äôm thinking something very bad about serious game development within Haskell
07:59:57 <skypers> it‚Äôs seriously annoying
08:00:03 <skypers> I‚Äôm always lifting stuff up
08:00:11 <JuanDaugherty> (when it's working)
08:00:12 <skypers> always dealing with Maybe and Either
08:00:27 <skypers> I wonder how could I make it more convenient to use
08:00:38 <henk> oh, I just found DiffTime from Data.Time.Clock which is probably well suited for the seconds. But the HMS part of the question remains ‚Ä¶
08:00:38 <skypers> I‚Äôm using a monad like EitherT
08:00:44 <skypers> and it‚Äôs actually terrible to use
08:00:51 <bennofs> skypers: maybe you're interrested in the errors package?
08:00:57 <bennofs> @hackage errors
08:00:57 <lambdabot> http://hackage.haskell.org/package/errors
08:01:05 <skypers> bennofs: well, how does it solve the issue?
08:01:13 <blablub> skypers: be sure to use enough sweet combinators
08:01:30 <skypers> well I have a lot of stuff
08:01:39 <skypers> a monad GL to handle OpenGL errors
08:01:40 <henk> JuanDaugherty: Sorry, I know that it‚Äôs very powerful to search for things, but I‚Äôm not sure how to employ it in this case. Am I missing something obvious? (I‚Äôm more or less a noob to programming, haskell, and hackage ‚Ä¶)
08:01:48 <skypers> another Monad to accumulate logs higher
08:01:54 <skypers> it‚Äôs kindof messy
08:01:58 <skypers> kind of*
08:02:18 <JuanDaugherty> henk, no just look in pkg (browse) for date/time related
08:03:11 <skypers> errors seems to use the package either
08:03:17 <skypers> that I already use
08:03:28 <bennofs> yes, but it provides some nice combinators to use with either
08:03:37 <bennofs> like converting between Either/Maybe
08:04:00 <bennofs> and a lot of standard partial operations lifted to Either/Maybe
08:04:04 <henk> JuanDaugherty: ah, ok. I tried that already, but could not find anything which I was able to identify as usable for lengths of time in H:M:S format.
08:04:42 <JuanDaugherty> prolly because it's a trivial string variant of something already done
08:04:45 <skypers> yeah I see that
08:04:47 <skypers> but hm
08:04:55 <skypers> I think I have issues with my monads
08:04:59 <skypers> it‚Äôs really messy
08:05:03 <skypers> I got an example
08:05:06 <skypers> please wait
08:05:28 <henk> JuanDaugherty: Yeah, maybe ‚Ä¶ Am I correct that this means I need to write my own datatype and some function converting from DiffTime to HMSTime?
08:05:42 <henk> HMSTime being my datatype
08:06:19 <JuanDaugherty> apparently for processing the input you describe
08:06:22 <skypers> bennofs: https://github.com/skypers/skyoralis/blob/master/Graphics/Rendering/Sky/Core/DeferredRenderer.hs#L81
08:06:28 <skypers> in that function (deferredRenderer)
08:06:36 <henk> JuanDaugherty: ok, thank you
08:06:39 <skypers> if I want to log things between each functions
08:06:41 <skypers> I just can‚Äôt.
08:06:53 <skypers> because those are in GL, wichis is basically EitherT
08:07:01 <skypers> and Core is basically WriterT
08:07:18 <skypers> one option would be to write the function in the Core m
08:07:21 <skypers> monad*
08:07:47 <skypers> but I‚Äôd need to deal with A¬†LOT of Maybe then (coreGL convert each EitherT return values into a Maybe)
08:08:07 <JuanDaugherty> henk, while I'd be surprised if there's nothing pre-existing that parses that, I can't tell you what does
08:08:42 <skypers> I feel like I‚Äôm stuck
08:08:47 <bennofs> skypers: wait, right now your code is in the EitherT monad
08:08:53 <skypers> well
08:08:59 <skypers> coreGL $ do
08:09:04 <skypers> everthing in that
08:09:07 <skypers> is in EitherT
08:09:26 <skypers> when coreGL returns
08:09:32 <skypers> it returns a Maybe
08:09:45 <skypers> it basically just extracts the Right part
08:10:02 <skypers> otherwise it pushes into the WriterT the Left part
08:10:10 <skypers> (since Core is a WriterT)
08:10:12 <bennofs> And what's the problem now?
08:10:14 <skypers> in my sense
08:10:17 <skypers> it‚Äôs quite of nice
08:10:19 <skypers> well bennofs
08:10:37 <skypers> now, I want to log something between the function createGBuffer and the next one
08:10:40 <skypers> how?
08:10:48 <skypers> I need to unwrap those functions from coreGL
08:10:57 <skypers> and make two coreGL calls
08:11:00 <skypers> lifted up
08:11:06 <skypers> and handle the returned Maybe
08:11:10 <skypers> it‚Äôs seriously annoying
08:11:43 <skypers> have you gotten it?
08:11:47 <bennofs> yes
08:12:01 <sdrodge> I was reading this article: http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion and became somewhat confused over the point where it's claimed that fix calculates the least-defined fixpoint...
08:12:12 <sdrodge> Consider this function: (\x -> take 2 $ (1:x))
08:12:14 <skypers> bennofs: I thought such a way to do was nice
08:12:17 <henk> JuanDaugherty: Well, I tried finding something for a while but have not until now. So I‚Äôm giving up and do it this way now ‚Ä¶ I‚Äôd be happy if I could avoid creating my own datatype.
08:12:34 <skypers> because I can call a lot of GL functions and errors will be automatically lifted up
08:12:35 <bennofs> Couldn't you just nest another WriterT over GL?
08:12:37 <skypers> OH
08:12:41 <skypers> I think
08:12:43 <skypers> YES!
08:12:48 <skypers> this is the best way to do
08:12:49 <skypers> actually
08:12:55 <skypers> I designed GL to only handle errors
08:12:55 <bennofs> (With some appropriate combinator to lift that up)
08:12:57 <skypers> not logs!
08:13:04 <sdrodge> fix (\x -> take 2 $ (1:x)) evaluates to [1,1] instead of bottom... so in what sense is the claim that it finds the least fixed point correct?
08:13:10 <skypers> I just have to use RWST as GL
08:13:15 <skypers> and it‚Äôll make it
08:13:29 <skypers> bennofs: yeah
08:13:36 <skypers> I have some nice ‚Äúcombinators‚Äù
08:13:47 <skypers> I think I‚Äôm going to suggest my GL package here
08:13:52 <skypers> because it‚Äôs quite of nice
08:13:56 <bennofs> skypers: you could also do someFunction $ coreGL $ runWriterT $ do .... where someFunction takes care of passing though the log
08:14:08 <bennofs> through*
08:14:26 <skypers> yes
08:14:32 <skypers> nice idea
08:14:52 <JuanDaugherty> henk, in haskell ur not supposed to be stingy with types
08:15:17 <skypers> thank you for your help bennofs
08:16:08 <bennofs> henk: You can even make a monoid instance for your own data type, as time deltas form a monoid under addition :)
08:17:49 <haasn> :t loeb
08:17:50 <lambdabot> Not in scope: `loeb'
08:17:55 <henk> JuanDaugherty: I‚Äôll remember that, I just haven‚Äôt really understood how that works yet and was therefore trying to avoid it (; Reading and learning about it now.
08:19:12 <henk> bennofs: uhm ‚Ä¶ monoid ‚Ä¶ right. I have even less of a clue what they are than how to define my own datatype. Do I need that right now or does it save me some trouble learning about that now or should I first get my datatype working in principal?
08:20:09 <Iceland_jack> henk: You don't need monoids at all
08:20:34 <Iceland_jack> Are you doing this for school henk?
08:25:18 <klrr_> @let loeb x = fmap (\f -> f (loeb x)) x
08:25:20 <lambdabot>  Defined.
08:25:22 <klrr_> :t loeb
08:25:23 <lambdabot> Functor f => f (f b -> b) -> f b
08:25:38 <bennofs> I'm still confused when to use something like pipes and when to use WriterT. Is there any rule of thumb for deciding between the two?
08:25:46 <bennofs> For example, I could write my code in a Producer LogMessage IO or in a WriterT LogMessage IO
08:26:00 <henk> Iceland_jack: No, for myself. I could not find a task/time tracking tool I was really happy with and I want to learn haskell. So I‚Äôm writing my own in haskell (;
08:26:25 <Iceland_jack> bennofs: Pipes and Writer? Those are totally different things
08:26:48 <bennofs> Iceland_jack: but a Producer from Pipes can be used as an alternative to Writer
08:27:10 <Iceland_jack> so can writing to a temporary file and then reading back from it
08:28:13 <bennofs> but for logging purposes, would you use a WriterT (DList LogMessage) or a Producer LogMessage ?
08:28:31 <skypers> > loeb [+1] [2]
08:28:32 <lambdabot>   A section must be enclosed in parentheses thus: (+ 1)
08:28:33 <bennofs> The Producer LogMessage has the advantage that I can easily compose it with a Consumer LogMessage to print out the logs
08:28:37 <skypers> > loeb [(+1)] [2]
08:28:38 <lambdabot>   Couldn't match expected type `[t1] -> t0' with actual type `[b0]'
08:29:11 <bennofs> @ty loeb [(+1),(+3)]
08:29:12 <lambdabot>     Occurs check: cannot construct the infinite type: b0 = [b0]
08:29:12 <lambdabot>     Expected type: [b0] -> b0
08:29:12 <lambdabot>       Actual type: [b0] -> [b0]
08:29:34 <bennofs> > loeb [(!!1),(!!2),3] -- skypers
08:29:35 <lambdabot>   No instance for (GHC.Show.Show b0)
08:29:36 <lambdabot>    arising from a use of `M5100036878687...
08:29:46 <bennofs> > loeb [(!!1),(!!2),const 3] -- skypers
08:29:48 <lambdabot>   [3,3,3]
08:29:55 <haasn> > loeb [length]
08:29:56 <lambdabot>   [1]
08:30:06 <skypers> wat
08:30:27 <bennofs> > loeb [length, length, head + 3]
08:30:28 <lambdabot>   No instance for (GHC.Num.Num ([GHC.Types.Int] -> GHC.Types.Int))
08:30:28 <lambdabot>    arising...
08:30:40 <skypers> loeb like‚Ä¶
08:30:42 <bennofs> > loeb [length, length, fmap (+3) head]
08:30:44 <lambdabot>   [3,3,6]
08:30:45 <skypers> Sebastien Loeb
08:30:56 <skypers> oh
08:30:58 <skypers> woah
08:31:03 <skypers> that‚Äôs pretty amazing
08:31:11 <bennofs> it's like spreadsheeds :)
08:31:48 <skypers> > loeb (Just show)
08:31:49 <lambdabot>   Just "Just \"Just \\\"Just \\\\\\\"Just \\\\\\\\\\\\\\\"Just \\\\\\\\\\\\\\...
08:31:52 <skypers> ahah
08:31:55 <bennofs> haha
08:32:01 <Rembane> You dawg...
08:32:03 <skypers> :D
08:32:09 <bennofs> > loeb Just isNothing
08:32:10 <lambdabot>   Couldn't match type `Data.Maybe.Maybe
08:32:10 <lambdabot>                         (Data.Maybe.M...
08:32:13 <bennofs> > loeb $ Just isNothing
08:32:14 <lambdabot>   Just False
08:32:31 <skypers> :t loeb ((+))
08:32:31 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> a0
08:32:32 <lambdabot>     Expected type: a0 -> (a0 -> a0) -> a0
08:32:32 <lambdabot>       Actual type: a0 -> a0 -> a0
08:32:35 <bennofs> haha
08:32:50 <haasn> > loeb Nothing
08:32:52 <lambdabot>   Nothing
08:32:58 <skypers> :t loeb (\a -> a . (+))
08:32:59 <lambdabot>     Occurs check: cannot construct the infinite type:
08:32:59 <lambdabot>       a0 = ((a0 -> a0) -> b0) -> b0
08:32:59 <lambdabot>     Expected type: ((a0 -> a0) -> b0) -> a0 -> b0
08:33:01 <skypers> damn
08:33:10 <bennofs> @ty loeb $ (\x y -> y 3)
08:33:11 <lambdabot> Num a => a -> b
08:33:16 <Taneb> > loeb [\x -> 3 + x !! 1, const 2]
08:33:16 <chrisdone> :t loeb
08:33:17 <lambdabot> Functor f => f (f b -> b) -> f b
08:33:17 <lambdabot>   [5,2]
08:33:37 <bennofs> @ty let f 3 = 0; loeb (\x y -> y 3) f
08:33:37 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
08:34:30 <bennofs> @ty let f 3 = 0 in loeb (\x y -> y 3) f
08:34:30 <lambdabot>     No instance for (Num (a0 -> a1)) arising from the literal `3'
08:34:31 <lambdabot>     Possible fix: add an instance declaration for (Num (a0 -> a1))
08:34:31 <lambdabot>     In the first argument of `y', namely `3'
08:35:06 <chrisdone> good morning
08:35:13 <skypers> > loeb [Just $ show tail, Just 1, Nothing, Just 2]
08:35:15 <lambdabot>   Couldn't match expected type `[b0] -> b0'
08:35:15 <lambdabot>              with actual type `Da...
08:35:17 <skypers> arf
08:35:32 <chrisdone> s/\$/.
08:37:19 <bennofs> > loeb (\x y -> if x == 7 then 4 else succ $ y $ succ x) 1
08:37:20 <lambdabot>   10
08:38:08 <skypers> :t loeb extract
08:38:09 <lambdabot> Not in scope: `extract'
08:38:50 <bennofs> loeb for f = (->) x is just fix :|
08:38:56 <bennofs> @ty fix :: ((a -> b) -> a -> b) -> a -> b
08:38:57 <lambdabot> ((a -> b) -> a -> b) -> a -> b
08:38:58 <skypers> > loeb (2,fmap (+1) fst)
08:39:00 <lambdabot>   (2,3)
08:39:05 <skypers> ahah
08:39:10 <skypers> that‚Äôs so amazing
08:44:38 <mrmonday> if I have a sublist, is there an easy way to get everything except that sublist from a list? eg if I had ls = [0, 1, 2, 3, 4, 5]; sublist = [2, 3]; I want to get [0, 1, 4, 5]
08:45:22 <ion> > [0..5] \\ [2,3]
08:45:23 <lambdabot>   [0,1,4,5]
08:45:30 <klrr_> :t \\
08:45:31 <lambdabot> parse error on input `\\'
08:45:34 <klrr_> :t (\\)
08:45:35 <lambdabot> Eq a => [a] -> [a] -> [a]
08:46:26 <mrmonday> ooh, that's really cool
08:46:28 <mrmonday> thanks :)
08:47:31 <skypers> how does (\\)? is it an applicative filter?
08:47:35 <skypers> +work*
08:48:34 <bennofs> a \\ b is a without the elements from b
08:48:37 <bennofs> iirc
08:48:39 <skypers> yeah
08:48:44 <skypers> got it then
08:48:49 <bennofs> @src (\\)
08:48:50 <lambdabot> (\\) = foldl (flip delete)
08:49:03 <skypers> @src delete
08:49:03 <lambdabot> delete = deleteBy (==)
08:49:04 <benmachine> > [0,0,0] \\ [0,0]
08:49:05 <lambdabot>   [0]
08:49:08 <benmachine> > [0,0,0,0] \\ [0,0]
08:49:09 <lambdabot>   [0,0]
08:49:27 <skypers> :t delete
08:49:28 <lambdabot> Eq a => a -> [a] -> [a]
08:49:50 <skypers> > 3 `delete` [1..5]
08:49:51 <lambdabot>   [1,2,4,5]
08:50:43 <benmachine> :t foldr delete [0,0,0,0] [0,0]
08:50:43 <lambdabot> (Eq a, Num a) => [a]
08:50:47 <benmachine> > foldr delete [0,0,0,0] [0,0]
08:50:48 <lambdabot>   [0,0]
08:51:01 <bennofs> I don't understand how ContT is supposed to solve the callback hell.
08:51:20 <benmachine> bennofs: have you seen that sigfpe post about reinverting control
08:51:52 <benmachine> http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
08:53:51 <Hodapp> I read that one a bit ago! Pretty fascinating
08:58:57 <bennofs> So I could make a wait function: wait event = ContT $ \f -> event $= Just (f ())
08:59:08 <bennofs> Ah ok, that looks pretty nice! :)
09:01:08 <cyrix> > [0.0,3.0..5]
09:01:09 <lambdabot>   [0.0,3.0,6.0]
09:01:16 <cyrix> what the heck is going on there?
09:02:45 <bennofs> @src enumFromThenTo
09:02:45 <lambdabot> Source not found.
09:02:45 <Hodapp> cyrix: Floating-poing ranges, to avoid round-off problems, go 0.5 past the upper limit, or something like that.
09:02:53 <Hodapp> > [1.0..1.8]
09:02:54 <lambdabot>   [1.0,2.0]
09:03:03 <henk> How do I enter the secondsToHMS function from http://lpaste.net/96432 in ghci? The newlines seem to be a problem and I don‚Äôt know how to separate the functions inside the 'where'.
09:03:30 <geekosaur> it's easier to put it in a source file and load that into ghci
09:03:56 <geekosaur> there is :{ :} for multiline stuff, or you can collapse it into a single line
09:03:59 * monochrom seconds putting into file and :load
09:05:04 <mjoseph_> > :t (.)
09:05:05 <lambdabot>   <hint>:1:1: parse error on input `:'
09:05:11 <Iceland_jack> :t (.)
09:05:12 <lambdabot> (b -> c) -> (a -> b) -> a -> c
09:05:12 <geekosaur> let secondsToHMS :: DiffTime -> HMSTime; secondsToHMS seconds =  HMSTime h m s where { (mLeft, s) = seconds `divMod` 60; (h, m) = mLeft `divMod` 60 }
09:05:13 <monochrom> people work too hard to coerce REPLs into IDEs
09:05:23 <geekosaur> but really, just put it in a source file
09:05:26 <mjoseph_> :t pure
09:05:27 <lambdabot> Applicative f => a -> f a
09:05:41 <mjoseph_> :t pure (.)
09:05:42 <lambdabot> Applicative f => f ((b -> c) -> (a -> b) -> a -> c)
09:05:46 <mjoseph_> :t (pure .)
09:05:47 <lambdabot> Applicative f => (a -> b) -> a -> f b
09:05:51 <chrisdone> to be fair, slime handles multi-line input just fine
09:06:00 <radish> so i've got an mvar question - if i do { putmvar; takemvar } will it update pending changes between that?
09:06:04 <chrisdone> i wouldn't call it coercing repls into ides. i'd just acll that a repl that doesn't suck
09:06:16 <mjoseph_> What's the difference between "pure (.)" and "(pure .)" ?
09:06:18 <radish> is it like fifo queue thing?
09:06:21 <chrisdone> the multiline stuff in ghci is mental
09:06:25 <mjoseph_> Or: why are these two different?
09:06:26 <Iceland_jack> mjoseph_: (pure .) ‚â° (\x -> pure . x)
09:06:33 <chrisdone> i don't know who thought of it or what medications they were on at the time of writing
09:06:37 <FireFly> (pure .) is (.) pure
09:06:38 <mjoseph_> Iceland_jack: thank you
09:06:39 <Iceland_jack> Do you know ‚Äòsections‚Äô mjoseph_?
09:07:04 <mjoseph_> Iceland_jack: I thought I did, I will have to think again in this context.
09:07:09 <Iceland_jack> (‚Ä¢ a) is (\x -> x ‚Ä¢ a)
09:07:09 <Iceland_jack> (a ‚Ä¢) is (\x -> a ‚Ä¢ x)
09:08:18 <Athas> andM would be a useful function.
09:09:04 <jmcarthur> Athas: what's its type?
09:09:45 <jmcarthur> Monad m => [m Bool] -> m Bool  ?
09:09:56 <Athas> jmcarthur: Monad m => (a -> m Bool) -> [a] -> Bool.
09:10:03 <jmcarthur> ah, allM
09:10:04 <Athas> Er, Monad m => (a -> m Bool) -> [a] -> m Bool.
09:10:13 <Athas> Oh, yes, sorry.
09:10:27 <jmcarthur> @hackage monad-loops
09:10:27 <lambdabot> http://hackage.haskell.org/package/monad-loops
09:10:30 <jmcarthur> Athas: ^^
09:10:39 <Athas> Nice, I was just about to ask whether such a package exists.
09:10:52 <Athas> It seems like such an obvious thing to lift all those convenience things.
09:11:04 <Athas> For that matter, they should probably be generalised to Traversables, if possible...
09:11:05 <bennofs> > [0.0,4.0,6.0]
09:11:06 <lambdabot>   [0.0,4.0,6.0]
09:11:11 <bennofs> > [0.0,4.0..6.0]
09:11:12 <lambdabot>   [0.0,4.0,8.0]
09:11:15 <jmcarthur> a lot of them probably should be, indeed
09:11:39 <jmcarthur> Athas: the lens package might also have some of these. not sure
09:12:24 <Athas> lens has a million dependencies as I recall.  I'd rather avoid that for now.
09:12:29 <chrisdone> speaking of which, since my elisp skillz levelled up, i think i can make a repl with syntax highlighting
09:12:43 <chrisdone> and structured-haskell-mode editing operations
09:12:47 <henk> geekosaur: Ah, cool, thank you. Actually it already is in a file and I copied it to test it in ghci. The file is a program, but now that I think about it, I guess I can still just load that file and use everything defined in it, right?
09:12:59 <geekosaur> yes
09:13:18 <jmcarthur> Athas: it does, but they are all well maintained dependencies at least
09:13:19 <bennofs> > [0.0,50.0..70]
09:13:20 <lambdabot>   [0.0,50.0]
09:13:25 <geekosaur> that's how ghci is designed to be worked with
09:13:33 <bennofs> > [0.0,50.0..80]
09:13:33 <lambdabot>   [0.0,50.0,100.0]
09:13:41 <hopf> So, I'm trying to understand stream fusion by solving a project euler problem with it, but my program outputs "<<loop>>" when compiled with -O2. Any suggestions for tracking down why?
09:14:34 <jmcarthur> hopf: look for recursive definitions that you didn't intend to be recursive
09:14:37 <henk> geekosaur: very nice, thanks (:
09:15:18 <jmcarthur> hopf: a common example is thinking that something like   let x = blah blah x blah blah  will define a new x in terms of an existing x, when in fact it will define a new x in terms of itself
09:15:32 <jmcarthur> hopf: build with -Wall to help find cases like that
09:15:50 <hopf> jmcarthur: okie dokie!
09:16:11 <jmcarthur> hopf: shadowing is generally discouraged in haskell anyway, and if you have no shadowing then this is easier to spot
09:17:35 <n0b> is there an established priority queue package?
09:19:31 <hpc> a quick hoogle turns up http://hackage.haskell.org/package/queuelike-1.0.9/docs/Data-Queue-PQueue.html
09:19:39 <hpc> which claims to be efficient
09:19:59 <hpc> and also has trie queues and mutable queues
09:23:26 <n0b> that seems to be exactly what I'm looking for, thanks hpc! :)
09:26:56 <lemao> dcoutts: there? yesterday you mention that ghc generates a main.c that calls haskell's main function. Where can I find this bit of c code?
09:27:09 <radish> would it be good practice to do IO in this case - i want to set a variable once and never change it again and not pass it around anywhere
09:27:46 <jmcarthur> radish: i think this question needs more context
09:28:10 <jmcarthur> radish: what you just described so far sounds like a thunk, which doesn't require IO
09:28:37 <jmcarthur> but there could be other interpretations of your question
09:28:40 <radish> jmcarthur: i have this variable i reference everywhere after i set it - its already created in IO
09:28:55 <jmcarthur> what do you mean by variable? IORef?
09:28:59 <radish> jmcarthur: but it never changes so i'm just passing around the same value
09:29:18 <radish> jmcarthur: just some value
09:29:29 <jmcarthur> then i would just pass around the value
09:29:41 <jmcarthur> radish: if passing it around becomes annoying, perhaps a reader monad would help
09:29:59 <jmcarthur> that comes with its own annoyances though, if the only goal is to handling "bookkeeping"
09:30:04 <radish> jmcarthur: i think thats what i want by the sound of it
09:30:09 <jmcarthur> i prefer to use just abstractions when i have a model in mind
09:30:13 <radish> jmcarthur: all i want is a read only value
09:30:15 <jmcarthur> s/just/such/
09:30:45 <hopf> jmcarthur: that did the trick, thanks
09:30:50 <jmcarthur> in any case, a reader monad would, i think, be preferable to craziness with IO
09:30:59 <jmcarthur> hopf: np!
09:31:09 <radish> jmcarthur: okay i'll look into that
09:33:45 <jmcarthur> interesting. it looks like canonical (beta-normal, eta-long) de bruijn terms do not actually require lambda constructors. all you need is the overall type, variables, and applications. the eta-long property encodes expressions' arities for you anyway.
09:34:07 <jmcarthur> s/expressions'/functions'/
09:35:40 <jmcarthur> not sure how important beta-normal is for this. probably important, since it implies that the left side of an application can't be a lambda
09:36:11 <Saizan> jmcarthur: have you defined a type for such a representation?
09:36:29 <jmcarthur> Saizan: yeah, although it's kind of messy right now
09:36:36 <jmcarthur> was thinking about cleaning it up and posting it somewhere
09:37:15 <jmcarthur> i haven't finished writing conversions to/from other representations either
09:37:20 <jmcarthur> so i have no proof yet
09:39:14 <jmcarthur> Saizan: the gist is to start with something like the representation in http://www.cs.nott.ac.uk/~txa/publ/msfp10.pdf and change Nf to be a function instead of a data type.
09:40:09 <jmcarthur> Saizan: and from there you basically just have to be more explicit about some of the type parameters
09:41:47 <Saizan> right
09:45:21 * hackagebot SFML 0.2.0.0 - SFML bindings  http://hackage.haskell.org/package/SFML-0.2.0.0 (AlfredoDiNapoli)
09:45:33 <jmcarthur> ooh
09:45:34 <Saizan> i'd find the ergonomics worse though
09:46:18 <jmcarthur> yes, i think i agree with that so far.
09:47:58 <jmcarthur> in haskell it might not be so bad. you could use a data family with newtype instances so you can still be explicit about whether it's a lambda or neutral term. you would just have to use type classes to do the "pattern matching" on the types
09:48:58 <jmcarthur> the injectivity of the data family might also eliminate some of this messiness with explicit type parameters
09:52:50 <quchen> Does Haddock automatically generate HTML source pages if hscolour is installed?
09:53:10 <monochrom> no
09:54:16 <monochrom> iirc, if you run haddock yourself, you have to first run hscolour yourself, then run haddock and use an option to point to the output files of hscolour. it is elaborate, I never actually tried.
09:55:15 <monochrom> what I do is "cabal haddock --hyperlink-source" or "cabal install --enable-documentation --haddock-hyperlink-source"
09:55:19 <jmcarthur> quchen: if you are using cabal-install, use --haddock-hyperlink-source
09:55:24 <jmcarthur> ah
09:55:42 <jmcarthur> i have docs enable in my .cabal/config, so just what i said works for me
09:55:44 <c_wraith> I've never run haddock outside of "cabal haddock" anyway
09:55:52 <jmcarthur> i never think about having to invoke docs explicitly
09:56:01 <quchen> jmcarthur: If you just enable docs in your config, it won't generate source links
09:56:10 <jmcarthur> right, you still have to use the flag as i said
09:56:15 <jmcarthur> which is a crying shame
09:56:27 <monochrom> http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config :)
09:56:47 <jmcarthur> i wish cabal was configurable in the straightforward way darcs is
09:57:06 <quchen> I really wonder why there is no such flag.
09:57:16 <quchen> It seems like such an easy addition.
09:57:18 <jmcarthur> where you can just put some real flags into a config file instead of having to depend on some special translation layer from config fields to flags
10:09:05 <bennofs> Cale: I think there is an error in the documentation for MaybeT. It says that the instance for MonadPlus is not provided, but this is not true
10:11:53 <bennofs> Also, MaybeT is missing the Applicative instance
10:18:27 <benmachine> bennofs: that was once true, certainly; probably MaybeT hasn't been updated since it became false because it's no longer necessary :)
10:19:13 <benmachine> oh no, I'm silly
10:19:17 <benmachine> it wasn't once true
10:19:25 <benmachine> but in any case the package is now unnecessary, MaybeT is in transformers
10:20:03 <bennofs> Oh, I didn't know that. Thank you!
10:20:24 * hackagebot ex-pool 0.1.0.1 - Another fork of resource-pool, with a MonadIO and MonadCatch constraint  http://hackage.haskell.org/package/ex-pool-0.1.0.1 (KimAltintop)
10:24:53 <ibotty> a short snap/configurator question. how can i specify a snaplet's configuration within the main snap config file
10:35:27 <Iceland_jack> /join theendhouse
10:35:27 <Iceland_jack>      
10:42:19 <mm_freak_> "Most programming languages do not have the auto-propagating capability, but the ones that do are called reactive programming languages.  And if the language is also functional, then it‚Äôs called a functional reactive programming language."
10:42:24 <mm_freak_> i start to understand why conal gets mad
10:42:57 <simpson> What's that from?
10:43:10 <mm_freak_> http://yinsochen.com/flapjax-functional-reactive-programming-in-javascrip/
10:43:22 <geekosaur> o.O
10:43:40 <simpson> > in JavaScript
10:43:41 <lambdabot>   <hint>:1:1: parse error on input `in'
10:43:44 <simpson> I think I found the problem.
10:44:27 <zomg> I wonder if there's anything like Capybara for Haskell...
10:44:36 <mm_freak_> i'm looking for an FRP library for javascript‚Ä¶  i've evaluated ~15 libraries, and only two of them have even understood what FRP is to begin with
10:44:56 <zomg> Capybara is basically a browser testing library for Ruby which makes it pretty easy to control browsers for tests (through selenium webdriver)
10:45:06 <coyoda> How can I make a heterogeneous list of a type with two type variables?
10:45:52 <tovarish> coyoda, [Either a b] no?
10:45:55 <mm_freak_> flapjax seems to be pretty solid, but apparently unmaintained‚Ä¶  bacon.js can be used like an FRP library, but it allows you to cheat too easily
10:46:14 <zomg> mm_freak_: I think the fact something is JavaScript implies it's very easy to cheat
10:46:18 <coyoda> i.e. data Conversion a b = Conversion { ‚Ä¶ } and then [Conversion a b] where a and b aren't the same for every element in the list
10:46:32 <zomg> I see Angular projects all the time which stick jquery selectors into angular controllers, even though angular pretty much says to not do that and instead use directives
10:46:55 <mm_freak_> zomg: i know‚Ä¶  the question is:  does the library actually expose cheating APIs?
10:47:12 <mm_freak_> bacon.js certainly does
10:47:22 <zomg> Yeah Angular doesn't, haven't really looked at bacon
10:47:32 <mm_freak_> what is angular anyway?
10:47:47 <zomg> Lets you easily do two-way databinding into DOM
10:47:48 <coyoda> tovarish: That won't work because a and b all have to be the same.
10:48:08 <tovarish> coyoda, ho, if I understand clearly, you can't
10:48:11 <zomg> Pretty much the easiest and fastest way to build dynamic UI's in JavaScript in my experience
10:48:17 <tovarish> but you have untyped language that will allow it
10:48:34 <coyoda> tovarish: Yeah, but I don't want it to be untyped.
10:48:54 <tovarish> in that case you need a dependent type language
10:49:38 <mm_freak_> nice
10:49:44 <nadirs> zomg: agreed! Angular is the second coolest piece of software I know
10:49:46 <mm_freak_> seems like i want to combine that with flapjax/bacon
10:50:18 * yogurt_truck prefers FRP over angular
10:50:31 <mm_freak_> yogurt_truck: you don't, because they solve different problems
10:50:34 <yogurt_truck> if I can't do FRP, then I'd choose react over angular
10:50:44 <coyoda> tovarish: I think Haskell can still do some things like this using existentials.
10:50:51 <mm_freak_> at least according to the docs
10:51:09 <tovarish> coyoda, I don't know what is existentials
10:51:12 <zomg> React seems decent enough but it's kinda meh 'cause it requires you to use a separate compiler for it + puts all the markup into the script
10:51:37 <yogurt_truck> mm_freak_: O.o, both are meant to create reactive UIs in a declarative way, without all the usual JS nonsense
10:51:41 <zomg> I fiddled around with it a bit and it just seems to be a bit less clear in what it's doing and such
10:51:46 <mm_freak_> yogurt_truck: no
10:52:05 <mm_freak_> FRP is unrelated to UIs, though it can be used to create UIs
10:52:23 <mm_freak_> i mainly apply FRP in server/networking contexts
10:52:32 <yogurt_truck> mm_freak_: i'm talking in the context of UIs, obviously. since the convo is about angular and GUIs with JS
10:52:38 <nadirs> I know nothing about FRP. Is, for instance, meteor.js reactive?
10:52:55 <mm_freak_> nadirs: it might be reactive, but it's not functional-reactive
10:53:12 <zomg> I'm not sure what all the fuss about FRP is tbh =)
10:53:14 <yogurt_truck> mm_freak_: and angular is in direct competition with FRP libs for browser GUIs
10:53:15 <zomg> especially for UI's
10:53:42 <zomg> I can just tell angular to bind a thing into an input field and then I can use a script to put a value into the thing and it also updates from the DOM if the user touches it
10:53:52 <zomg> about as simple as I can possibly think it could be =)
10:54:00 <mm_freak_> yogurt_truck: is it?  from the documentation it seems i'd rather use it /together/ with an FRP library
10:54:08 <yogurt_truck> zomg: then you don't see what all the fuss about "functional" is
10:54:18 <geekosaur> mostly the fuss is that currently gui programming in haskell is annoying
10:54:26 <geekosaur> and annoyingly non-functional
10:54:27 <zomg> yogurt_truck: yes, I'm an idiot
10:54:47 <yogurt_truck> zomg: because what you've just described is FRP without the F (and the concepts of FRP such as signals, etc)
10:54:54 <yogurt_truck> zomg: have you seen Elm?
10:54:55 <mm_freak_> zomg: your data model is still unmanaged given angular‚Ä¶  FRP manages your data model
10:55:29 <nadirs> I just found this article (http://paulstovell.com/blog/reactive-programming), only read 5 lines, and I thought I should share it :P
10:55:36 <zomg> yogurt_truck: in passing
10:55:50 <yogurt_truck> mm_freak_: you'd use angular together with an FRP for GUI development? what parts of these two would you combine?
10:56:12 <zomg> mm_freak_: I suppose I just haven't really seen any very good examples of why I would want to use FRP in context of something like angular
10:56:13 <yogurt_truck> FRP lib*
10:56:38 <mm_freak_> from the introduction i've understood angular as a connector between your abstract data and a concrete GUI representation of it‚Ä¶  when your data changes, the GUI does accordingly
10:56:45 <mm_freak_> is that correct/close?
10:57:01 <zomg> the most I saw about FRP stuff with regards to building UIs in the browser was chaining a bunch of functions into each other and it being mashed into a DOM node in the script
10:57:20 <bennofs> mm_freak_: and your data also changes when your GUI changes iirc
10:57:32 <mm_freak_> yeah
10:57:33 <zomg> which at least from my POV seems like a worse way of achieving things than adding an attribute to a DOM node and being done with it =)
10:58:07 <yogurt_truck> mm_freak_: Angular does the whole thing. You bind the data to model and "views", etc. Look at the tutorial
10:58:56 <zomg> Yeah in angular you have a "scope" to which you assign stuff to, basically the data model. You can listen for changes in the scope, or bind values from the scope into dom
10:58:57 <yogurt_truck> zomg: it's not just DOM nodes
10:59:10 <yogurt_truck> zomg: that's low level stuff that the Elm compiler handles
10:59:23 <mm_freak_> so it's basically event-free
10:59:25 <zomg> well like I said I haven't seen any examples that would actually show me why I should be using it
10:59:44 <yogurt_truck> zomg: your Elm GUI can use element-y stuff (blocks of stuff), as well as freeform graphics. all are handled in a purely functional way
10:59:47 <zomg> I just see some trivial and useless samples of what it is which really doesn't explain how my life is easier by doing it =)
11:00:13 <yogurt_truck> I translated a JS thing to Elm the other day
11:00:18 * yogurt_truck looks for it
11:01:10 <yogurt_truck> zomg: http://share-elm.com/sprout/529b85d2e4b06194fd2d2d07
11:01:22 <mm_freak_> zomg: to be fair i haven't tried angular, but apparently its main strength is that your data becomes strongly connected to your GUI
11:01:25 <mm_freak_> is that correct?
11:01:26 <yogurt_truck> zomg: I translated that from a sketch.js example
11:02:00 <yogurt_truck> zomg: you see how the whole program is purely functional, and the inputs are "signals" that you can compose/merge/etc
11:02:07 <zomg> mm_freak_: the stuff in your scopes becomes two-way connected yes
11:03:09 <mm_freak_> zomg: then the difference is that FRP is modular‚Ä¶  you can develop the semantics of a single input box without caring or even knowing about the rest of the GUI/data
11:03:22 <yogurt_truck> mm_freak_: there's a _lot_ of stuff that usually has to be done manually, for keeping a UI reactive, in plain JS (or JS with crap like jQuery, etc). Angular, React, and Knockout, target that
11:03:47 <nadirs> mm_freak_: thath would probably be a directive in angular
11:05:05 <zomg> mm_freak_: yeah in angular for example a single input box is defined in terms of filters and such, so you can have some data which gets transformed by the input box into what it displays and back again into your original format when user changes it
11:05:35 <mm_freak_> that sounds horrible (to an FRP developer)
11:06:17 <yogurt_truck> zomg: with FRP/Elm you can basically fold over time :)
11:06:35 <mm_freak_> i'm glad you write "FRP/elm" =)
11:06:45 <mm_freak_> because elm isn't FRP
11:06:54 <zomg> lol
11:06:56 <yogurt_truck> it is an implementation of FRP
11:07:00 <mm_freak_> no, it's not
11:07:02 <zomg> I mean as nice as yogurt_truck's example looks
11:07:07 <zomg> this is exactly what I meant by trivial/useless
11:07:09 <yogurt_truck> mm_freak_: yes. it is.
11:07:12 <zomg> this isn't something I would build with angular
11:07:12 <zomg> :D
11:07:34 <mm_freak_> yogurt_truck: compare elm's Signal to the formal definition of FRP
11:07:48 <zomg> Like right now I'm using Angular to build a browser-based WYSIWYG editor
11:07:51 <mm_freak_> Signal is both behavior and event, which does not make sense in FRP
11:08:00 <zomg> with a whole ton of controls, buttons and all that nonsense
11:08:02 <yogurt_truck> mm_freak_: it is asynchronous FRP that uses discrete signals instead of the bogus idea of continous signals, and avoid problems of classical FRP such as global delays and needless recomputations
11:08:14 <jmcarthur> yogurt_truck: then it's not FRP
11:08:21 <mm_freak_> yogurt_truck: so it's not FRP
11:08:26 <jmcarthur> FRP has a very precise definition
11:08:39 <mm_freak_> yogurt_truck: also your claims about continuous time implementations are wrong
11:08:47 <jmcarthur> you may argue that it "should" be defined differently, but that's a different matter
11:08:53 <mm_freak_> see netwire, reactive-banana and (to some extent) sodium
11:09:18 <yogurt_truck> mm_freak_, jmcarthur: what is the very precise definition of FRP?
11:09:43 <mm_freak_> yogurt_truck: http://conal.net/papers/icfp97/
11:10:00 <mm_freak_> the paper includes a formal definition
11:10:08 <yogurt_truck> mm_freak_: yeah, there's been more research after that, you know
11:10:17 <jmcarthur> Behavior a = T -> a; Event = Bag (T, a)    (using Bag instead of list is my idea, but i think more accurately describes the original intent than the original definition)
11:10:33 <jmcarthur> *Event a
11:10:36 <yogurt_truck> mm_freak_: Elm is the result of evaluating the weaknesses of previous implementations of FRP, and it takes influences from several
11:10:39 <mm_freak_> yogurt_truck: there has been more research after newtonian physics, yet einstein physics is not newtonian physics
11:11:00 <mm_freak_> if you disagree with FRP, make something better, but don't call it FRP ;)
11:11:29 <jmcarthur> yogurt_truck: FRP is the name for the solution, not for the problem. just because a project seeks to solve the same problem doesn't make it the same solution.
11:11:29 <mm_freak_> yogurt_truck: btw, i didn't say elm is bad
11:11:33 <mm_freak_> i said elm is not FRP
11:11:55 <mm_freak_> i disagree with elm's model, which is why i don't use it
11:12:11 <yogurt_truck> jmcarthur: classical FRP is not a solution, which is why Elm exists
11:12:12 <datura> mm_freak_: i think quite a number of people use "FRP" in a much broader sense than the original definition
11:12:25 <mm_freak_> yogurt_truck: so reactive-banana is not a solution?
11:12:43 <mm_freak_> datura: definitely and unfortunately
11:13:09 <datura> mm_freak_: well, is there a better word for what they mean?
11:13:27 <mm_freak_> datura: most really just mean reactive programming or declarative UIs
11:13:39 <mm_freak_> one interesting thing to note is that FRP has nothing to do with UIs
11:13:41 <jmcarthur> yogurt_truck: what you are calling "classical FRP" is FRP. Elm is something else. we're not trying to say reactive is "right" and Elm is "wrong" or that one is "good" and the other is "bad", just that one is "FRP" and the other is "not FRP"
11:14:28 <datura> mm_freak_: someon in #scala recently wrote "if it's not continous, it's not reactive", iirc?
11:14:29 <yogurt_truck> mm_freak_: nope.
11:14:43 <yogurt_truck> is Arrowized FRP not FRP either btw?
11:15:04 <jmcarthur> Arrowized FRP is not necessarily FRP, but can be. it depends on the exact model used
11:15:16 <mm_freak_> datura: well, the time semantics has to be continuous‚Ä¶  it does not mean that you actually get continuous time =)
11:15:32 <yogurt_truck> jmcarthur: but Elm can't be FRP?
11:15:33 <mm_freak_> yogurt_truck: netwire 5's AFRP is FRP
11:15:43 <yogurt_truck> mm_freak_: it _can't_ be continuous
11:16:00 <yogurt_truck> time is not continuous in reality itself
11:16:03 <mm_freak_> yogurt_truck: you don't understand what the "continuous" applies to
11:16:26 <mm_freak_> time /semantics/ has to be continuous‚Ä¶  the implementation doesn't even have to deal with time as a value
11:16:33 <benmachine> since when is reality-time not continuous
11:16:51 <MahmoudBinAwad> Is it considered offtopic here to ask about compilation techniques for non strict semantics?
11:16:58 <yogurt_truck> mm_freak_: those semantics cannot be respected
11:17:04 <mm_freak_> MahmoudBinAwad: nah, go ahead =)
11:17:09 <mm_freak_> yogurt_truck: why?
11:17:18 <mm_freak_> netwire and reactive-banana respect them
11:17:24 <datura> same with "everything happens at the same time" - it's a usefull illusion for the user
11:17:33 <yogurt_truck> mm_freak_: because updates in a machine are not instantaneous
11:17:34 <jmcarthur> yogurt_truck: neither can the semantics for sets and natural numbers. that doesn't make it useless.
11:17:40 <mm_freak_> yogurt_truck: they don't have to be
11:18:20 <MahmoudBinAwad> benmachine, time isn't even dense arguably
11:18:20 <MahmoudBinAwad> There is a quantum of time, which incencidentally is the quantum of length times th elight speed
11:19:02 <benmachine> MahmoudBinAwad: aiui that's just the smallest measurable unit of time, it doesn't follow that life is a movie made of frames 1 planck second long
11:19:02 <MahmoudBinAwad> mm_freak_, ah well, is there any reason why CPS in non strict semantics doesn't work?
11:19:07 <jmcarthur> eh, i'm done. whenever a conversation about programming devolves into philosophical arguments about the fundamentals of the universe, you know it's not going anywhere
11:19:10 <yogurt_truck> jmcarthur: that doesn't cause problems in use of the theory
11:19:27 <benmachine> jmcarthur: sorry, that was only me being offtopic
11:19:32 <mm_freak_> yogurt_truck: i think conal's mistake was to call it "continuous time semantics", because the "continuous" seems to be generally misunderstood =)
11:19:41 <jmcarthur> benmachine: no, not you
11:19:44 <MahmoudBinAwad> benmachine, it doesn't, that is an interpretation thereof
11:20:07 <jmcarthur> mm_freak_: i don't think it was a mistake, and i don't think it's the "continuous" part that is being misunderstood, but the "semantics" part
11:20:09 <yogurt_truck> jmcarthur: the assumption of instantaneous updates in a semantics of continuous signals does mask some important issues, are you denying the problem of global delays and unnecessary updates in previous implementations of FRP
11:20:11 <mm_freak_> MahmoudBinAwad: there is no fundamental reason i'm aware of‚Ä¶  it's just that the STG model works very well
11:20:22 <mm_freak_> jmcarthur: true
11:20:31 <MahmoudBinAwad> It does follow however that time is not continous from that mathematical model
11:21:16 <yogurt_truck> more over, not all user input is continuous (in fact, a lot of it is not), so the continuous signal approach is even less fitting for a GUI
11:21:33 <jmcarthur> yogurt_truck: FRP has two parts, Behaviors and Events, for just this reason
11:21:36 <yogurt_truck> (given that we were talking about FRP for UI)
11:21:47 <mm_freak_> yogurt_truck: here is what "continuous time semantics" means:  you can construct 'lastValue :: a -> Event a -> Behavior a', but you can't construct 'changes :: Behavior a -> Event a'
11:21:55 <MahmoudBinAwad> mm_freak_, well, you can interpreted it as in that time moves in 'steps', but that's an interpretation, the point is that the model is not contineous in the mathematical sense, as in, you can't take a limit
11:21:56 <MahmoudBinAwad> The very idea of 'a smallest possible unit' of time defeats a limit
11:22:15 <mm_freak_> yogurt_truck: it gives you precise rules of what is possible and what is not
11:22:33 <benmachine> MahmoudBinAwad: wikipedia seems to think that the Planck time isn't in any meaningful sense *known* to be a smallest possible unit
11:22:39 <yogurt_truck> jmcarthur: which is why Elm uses the fact that there is an isomorphism between the two
11:22:44 <jmcarthur> haha
11:22:50 <jmcarthur> which is why Elm is not FRP
11:23:08 <yogurt_truck> (actually, RT FRP did it, not Elm)
11:23:15 <mm_freak_> MahmoudBinAwad: i'm not arguing about physical time at all =)
11:23:25 <jmcarthur> yogurt_truck: all these things that claim they are FRP are not necessarily so just because they say so
11:23:40 <jmcarthur> although i am not familiar with RT FRP and can't speak about it
11:23:49 <yogurt_truck> jmcarthur: there are about 4 types of FRP besides the first description in 1997, if you can't accept this, then that's your problem
11:24:03 <jmcarthur> yogurt_truck: i agree that there are many solutions to the same problem, not that they are all FRP
11:24:06 <MahmoudBinAwad> benmachine, what model are we talking about here then?
11:24:33 <benmachine> MahmoudBinAwad: what I'm talking about is certainly off-topic for this channel, do you want to go to #haskell-blah?
11:24:35 <jmcarthur> yogurt_truck: and i think you are being very closed minded about this and many other things in this conversation (re: your claims about the fundamentals of the universe and their applicability to programming)
11:24:45 <mm_freak_> yogurt_truck: i have a monoid here‚Ä¶  well, it's not associative, so i'll call it a non-associative monoid
11:24:48 <MahmoudBinAwad> As far as I know it follows from the quantum of energy that the planck time is the quantum of time.
11:24:55 <yogurt_truck> _I_ am being closed minded???
11:24:57 <jmcarthur> mm_freak_++
11:25:01 <yogurt_truck> this is hilarious.
11:25:02 <yogurt_truck> ok then.
11:25:03 <mm_freak_> yogurt_truck: i have a natural number here‚Ä¶  well, it's negative, so i'll just call it a negative natural number
11:25:07 <jmcarthur> okay i'm out. i don't want to feed the fire any more
11:25:15 <mm_freak_> me neither
11:25:30 <MahmoudBinAwad> fair enough
11:25:30 <MahmoudBinAwad> Anyway, is there a major caveat with CPS for implementing non strict semantics?
11:25:31 <mm_freak_> apparently terms with formal definitions aren't valuable anymore
11:26:17 <MahmoudBinAwad> benmachine, two hashes apparently
11:26:32 <benmachine> MahmoudBinAwad: I'm in one-hash now
11:26:44 <yogurt_truck> "FRP has a very precise definition from the original paper in 1997. Arrowized FRP, Real-Time FRP, and these other things are not FRP". and then _I_ am the closed minded one. brilliant.
11:26:54 <yogurt_truck> mm_freak_: never said that, but ok.
11:27:10 <zomg> You guys still arguing about what FRP is and isn't? =)
11:27:19 <benmachine> MahmoudBinAwad: (I should add that the off-topicness was my fault, I didn't mean to sound accusatory or anything)
11:27:29 <mm_freak_> zomg: there is no reason to argue, because FRP has a precise formal definition =)
11:27:35 <zomg> hehe
11:27:41 <MahmoudBinAwad> benmachine, I am confused, I think there's something wrong with my bouncer, it reports both as empty
11:27:54 <pavonia> MahmoudBinAwad: no '?' at the end
11:28:00 <zomg> Hmm looks like there's a pretty nice WebDriver library on Hackage
11:28:01 <benmachine> MahmoudBinAwad: huh. well, to be honest I wasn't that invested in the topic anyway :P
11:28:07 <zomg> but it's a bit lower level than Capybara
11:28:17 <mm_freak_> yogurt_truck: yes, you said that‚Ä¶  there are things that aren't FRP, so you're calling them "better FRP" or something
11:28:30 <mm_freak_> i said that elm is not FRP, you disagreed
11:28:30 <zomg> FRP.5
11:28:35 <mm_freak_> so you're saying exactly that
11:28:57 <mm_freak_> there is one thing i agree with:  it seems like after the web 2.0 movement comes an FRP 2.0 movement =)
11:28:58 <yogurt_truck> mm_freak_: no, I did not say these "things are not FRP but I'm calling them that".
11:29:07 <jmcarthur> mm_freak_: on a more productive note, i'm curious about netwire 5. do you have a writeup of where it fits into the space of FRP libraries?
11:29:12 <jmcarthur> or anything of that sort?
11:29:21 <tiffany> since when is elm not frp?
11:29:29 <n0b> here we go again
11:29:33 * jmcarthur facepalms
11:29:43 <mm_freak_> jmcarthur: http://hub.darcs.net/ertes/netwire
11:29:52 <MahmoudBinAwad> Well, this is weird, my bouncer is not giving me 8 lines at a time.
11:29:52 <MahmoudBinAwad> learly this proves time is discrete
11:29:54 <jmcarthur> mm_freak_: thanks!
11:31:51 <yogurt_truck> tiffany: Yes, apparently Elm is not FRP. And Arrowized FRP is not FRP. And Real-Time FRP isn't either. Only the implementation of the very first description of FRP in 1997 can be called FRP.
11:32:08 <jmcarthur> no
11:32:12 <mm_freak_> yogurt_truck: AFRP is FRP
11:32:21 <jmcarthur> only implementations that fit the definition of FRP are FRP
11:32:34 <jmcarthur> AFRP can be FRP, but is not necessarily
11:32:41 <tiffany> why is the implementation important over the semantics?
11:32:44 <jmcarthur> in particular, if it conflates behaviors and events, it is not frp
11:33:09 <jmcarthur> s/in particular/to highlight some AFRP libraries that are not really FRP/
11:33:18 <mm_freak_> the original formulation of AFRP does not conflate them
11:33:48 <jmcarthur> mm_freak_: ah, then i was confused about AFRP, because i thought it did and then somebody later "unconflated" them or something
11:33:53 <mm_freak_> AFRP is FRP with a different programming interface
11:34:00 <mm_freak_> for example instead of 'Behavior a' you simply have 'a'
11:34:43 <mm_freak_> Wire/SF are pretty much what Moment is for reactive-banana and what Reactive is for sodium
11:34:44 <jmcarthur> tiffany: it's not really, it's just that sometimes i interchange the word "library" with "implementation"
11:37:07 <yogurt_truck> tiffany: I think some people have a problem with the fact that the core ideas of FRP can and have evolved, creating different variants of FRP throughout the years
11:37:25 <monochrom> people conflat "open-minded" and "postmodernism"
11:38:48 <mm_freak_> yogurt_truck: i'm curious as to what exactly is wrong with FRP‚Ä¶  i'm using FRP productively
11:38:49 <chrisdone> people also conflate open-mindedness with being uncritical
11:40:07 <danilo2> Hello :) I know there is Cabal library in Hackage, but I want to ask you if there is an easy way to use functions defined in cabal-install package. It provides only executable so the only way to use functions defined there is to copy the source code ?
11:40:33 <mm_freak_> danilo2: see the Distribution.* module tree
11:40:44 <Hodapp> can we make a unit of measure for 'conflation of meanings' for which the reference is "the amount that OOP's definition became skewed and bastardized over time"?
11:41:01 <danilo2> mm_freak_: I'm tlaking about the Distribution.Client.* tree - it is not exposed by any library, is it?
11:41:06 <jmcarthur> Hodapp: nanokays
11:41:13 <mm_freak_> danilo2: not sure
11:41:14 <chrisdone> danilo2: yeah‚Ä¶ sadly, the useful code is burried in executable
11:41:16 <Hodapp> jmcarthur: but that wasn't Kay's fault, exactly
11:41:27 <chrisdone> i can only assume it's written like this by accident
11:41:28 <yogurt_truck> mm_freak_: 1. what kind of FRP? 2. that you're productive with X is tangential. I know COBOL programmers that use COBOL "productively", that means nothing.
11:41:29 <Hodapp> jmcarthur: he kept his definition more or less the same
11:41:43 <yogurt_truck> well, OOP is another matter
11:41:57 <jmcarthur> Hodapp: it was a reference to nanodijkstras, which are kay's invention iirc
11:42:02 <chrisdone> mm_freak_: cabal-install's modules aren't exposed
11:42:08 <Hodapp> jmcarthur: ahh, the unit for arrogance?
11:42:11 <jmcarthur> yup
11:42:14 <danilo2> mm_freak_, chrisdone: would it be ok if I file a bug to move this code to a library? I do not think it will take much time to create "Main.hs" file, which will be executable using this library?
11:42:14 <yogurt_truck> at least we _have_ some definitions to refer to, in our little FRP debate
11:42:18 <chrisdone> sadly‚Ä¶ it'd be cool if it were, one could customize it like xmonad
11:42:21 <mm_freak_> yogurt_truck: 1. FRP, 2. obviously i don't want to be using something bad, so tell me why FRP is bad
11:42:23 <Hodapp> I'd heard "Mandelbrot" as the unit for arrogance too
11:42:41 <chrisdone> danilo2: no idea -- but it sounds good. if you open an issue, link me
11:42:42 <yogurt_truck> (whereas OOP is borderline meaningless by now, based on the absolute lack of universally agreed definitions of it)
11:43:00 <danilo2> chrisdone: brb
11:43:16 <jmcarthur> i think FRP has already fallen prey to the OOP problem
11:43:21 <mm_freak_> yogurt_truck: (the same may happen to FRP)
11:43:23 <yogurt_truck> 1. in what variant?
11:43:28 <mm_freak_> yogurt_truck: FRP
11:43:32 <chrisdone> jmcarthur: what's the oop problem?
11:43:45 <yogurt_truck> mm_freak_: what variant of FRP?
11:43:48 <h0rrorvacui> I'm late to this convo? Whats wrong with oop?
11:43:51 <mm_freak_> yogurt_truck: there is only one
11:43:55 <jmcarthur> chrisdone: the question of what is and is not OOP
11:44:02 <Hodapp> chrisdone: The fact that "OOP" has become a completely meaningless, vague term that encompasses a ton of other distinct things to the point that basically nothing can be described as *not* being OOP
11:44:07 <yogurt_truck> mm_freak_: classical FRP? RT-FRP? Event-driven FRP? Arrowized FRP? what variant?
11:44:16 <jmcarthur> h0rrorvacui: nothing. everything. who knows?
11:44:22 <chrisdone> jmcarthur: nod. FP has that too
11:44:25 <yogurt_truck> mm_freak_: what? there are several variants.
11:44:29 <simpson> Disregard object-oriented; acquire object-based.
11:44:38 <jmcarthur> chrisdone: indeed, albeit to a somewhat lesser extent, i think
11:44:39 <mm_freak_> yogurt_truck: time-varying values with discrete events and continuous time semantics aka FRP, the original formulation
11:44:42 <yogurt_truck> FP is not as bad as OOP
11:44:43 <chrisdone> jmcarthur: nod
11:45:02 <chrisdone> i think alan kay's definition of object-oriented is quite clear
11:45:06 <yogurt_truck> in FP we at least have the universal idea of a function
11:45:06 <h0rrorvacui> Is it not all just abstractions?
11:45:12 <chrisdone> but his definition is not the popular one
11:45:31 <jmcarthur> h0rrorvacui: we are not criticizing OOP right now. maybe later. ;)
11:45:34 <chrisdone> h0rrorvacui: it's all just stuff in the end, right? here, hold my beer while i draw a diagram
11:45:35 <yogurt_truck> william cook wrote a little proposal for a definition of OOP
11:45:39 <yogurt_truck> (btw)
11:45:46 <jmcarthur> a lot of people have
11:45:46 <Hodapp> Knuth made a joke about some similar things. He joked that he called it "literate programming" to hopefully cash in on the same thing that took effect with "structured programming", in that everyone claimed to do it because no one wanted to be doing "unstructured programming".
11:46:02 <Hodapp> because no one could ever want to do "illiterate programming".
11:46:10 <mm_freak_> yogurt_truck: the structure of your list of "FRP variants" is ill-typed, btw
11:46:10 <jmcarthur> brilliant
11:46:14 <chrisdone> Hodapp: heh, yeah. and then nobody does literate programming as deemed by knuth
11:46:25 <yogurt_truck> mm_freak_: I already told you. You can refer to the Elm thesis for notes on the problems of the instant-update assumption of continuous semantics, etc.
11:46:28 <chrisdone> literate haskell, for example, is just "comment inverted haskell"
11:46:33 <chrisdone> knuth's literate programming is mental
11:46:55 * monochrom was a contributor to the divergence of the meaning of OOP. he said, "sure, [1,2,3] is an object in Haskell, length is a method, length [1,2,3] is dispatching the method on the object. oh, some methods require two objects to dispatch, ever heard of multiple dispatch? :) "
11:46:58 <danilo2> chrisdone: https://github.com/haskell/cabal/issues/1597
11:47:08 <jmcarthur> in haskell it's slightly easier because definitions within a module are less order dependent anyway
11:47:22 <chrisdone> http://this-plt-life.tumblr.com/post/39828288063/when-i-encounter-a-web-style-literate-program
11:47:30 <yogurt_truck> mm_freak_: yeah, ok, sure. but read the thesis, if you care
11:47:34 <jmcarthur> literate programming is roughly the same as order-independent programming with a shitload of comments
11:47:39 <mm_freak_> yogurt_truck: i have, btw
11:47:42 <Hodapp> order-independent?
11:47:46 <jmcarthur> i made it up
11:47:58 <yogurt_truck> mm_freak_: then why are you asking me what is explained there?
11:48:24 <yogurt_truck> mm_freak_: if you don't buy the thesis' explanations, then I can't do better, and so you might want to take this to the Elm mailing list then
11:48:42 <jmcarthur> Hodapp: i just mean that you can reorder the parts of your program, possibly with some annotations to explain how it should fit together in the end, without affecting the meaning
11:48:54 <mm_freak_> yogurt_truck: because the author of elm couldn't figure out how to write an efficient implementation of real FRP, so he instead created his own denotation and implemented that one
11:49:06 <mm_freak_> yogurt_truck: he solved an implementation problem by switching to a different abstraction
11:49:24 <mm_freak_> yogurt_truck: nobody says that FRP is bad, it's just nontrivial to implement
11:49:29 <yogurt_truck> oh so now it's "real FRP"
11:49:37 <yogurt_truck> ok, then. I'm done now.
11:49:40 <mm_freak_> no, it's not
11:50:06 <nadirs> chrisdone: what does PLT stand for?
11:50:21 <chrisdone> jmcarthur: there's also the <aspect>
11:50:22 <chrisdone> jmcarthur: aspect: templatey aspect of it
11:50:24 <yogurt_truck> like I said. If the thesis didn't do it for you, I won't be able to either. Take it to the Elm mailing list. I'm sure the author of Elm would be thankful if you let him know that "Elm has actually never been FRP"
11:50:33 <chrisdone> nadirs: programming language theory
11:50:35 <jmcarthur> yogurt_truck: attaching "FRP" to the name of something makes it FRP no more than attaching "Object" to the name of something makes it object oriented
11:50:55 <yogurt_truck> jmcarthur: yup. OK.
11:50:59 <mm_freak_> yogurt_truck: the author knows that ;)
11:51:00 <Hodapp> Objective FRP++
11:51:03 <nadirs> chrisdone: a-ha, thanks, couldn't figure out the T :P
11:51:23 <mm_freak_> yogurt_truck: which leaves only one explanation:  elm is called FRP for marketing reasons
11:51:26 <mm_freak_> nothing else
11:51:35 <mm_freak_> it's not FRP and has never been FRP
11:51:50 <chrisdone> nadirs: yeah, to be fair, barely anything on that blog contains actual theory =)
11:51:54 <mm_freak_> that said, elm is nice
11:52:01 <mm_freak_> it's just that it's not FRP
11:52:02 <yogurt_truck> ah, now we're speculating on the intentions of Elm's author
11:52:08 <yogurt_truck> great. keep it up.
11:52:46 <Hodapp> yogurt_truck: No need to really speculate. evancz is here periodically.
11:53:06 <mm_freak_> =)
11:53:08 <nadirs> chrisdone: though it's hilarious, thanks for posting it, this one (http://this-plt-life.tumblr.com/post/55420560033/when-somebody-offers-me-promises-as-a-replacement-for) cracked me up
11:53:09 <chrisdone> monochrom: i liked spj's characterization of haskell as ‚Äúvalue-oriented programming‚Äù
11:53:16 <chrisdone> nadirs: haha, yeah
11:53:35 <chrisdone> http://this-plt-life.tumblr.com/post/41439555366/when-oleg-shows-a-newbie-how-to-solve-a-problem
11:53:44 <yogurt_truck> Hodapp: OK
11:54:30 <nadirs> chrisdone: please bear with my un-knowledge, who's Oleg?
11:54:39 <chrisdone> @quote oleg
11:54:39 <lambdabot> oleg says: The cited code is elegant, but it is not correct.
11:55:05 <yogurt_truck> so, in short: Elm is not FRP, and has never been FRP. The author called it FRP for marketing reasons. right?
11:55:11 <apo> Hm, what's a pretty way to apply a list of functions to two parameters, e.g. [f a b, g a b, h a b]? I've got map (\x -> x a b) [f,g,h] right now. Is there something better?
11:55:19 <chrisdone> nadirs: ah, he's big in the haskell community for having written tonnes of articles and research in FP, in haskell, scheme and *ML in particular
11:55:37 <silver> nadirs, http://okmij.org/ftp/
11:56:03 <mm_freak_> yogurt_truck: the last thing is my personal speculation
11:56:27 <mm_freak_> elm is no more FRP than Perhaps is a Bool
11:56:31 <jmcarthur> it could also have been a mistake
11:56:31 <chrisdone> my current understanding of OOP is that it's fundamentally about black boxes with state
11:57:00 <nadirs> chrisdone: I'll go sit in the corner untill the bell rings :P
11:57:08 <nadirs> *until
11:57:08 <jmcarthur> chrisdone: oh you want to start this now, do you?
11:57:10 <chrisdone> so VOP makes a nice opposite of that, where you have very few big black boxes with state
11:57:46 <nadirs> I basically only know about Simon Peyton Jones...
11:57:58 <jmcarthur> i like the idea of objects as F-coalgebras, but really, nothing is going to encompass all the things people say are OO
11:57:59 <chrisdone> e.g. in haskell the work i do is not contained in black boxes, it's littered in small functions all over my codebase
11:58:52 <Hodapp> chrisdone: http://michaelochurch.wordpress.com/2011/08/28/object-disoriented-programming/ would seem to agree with your sentiments on OOP
11:58:53 <chrisdone> jmcarthur: well look at alan kay's original notion, which was like cells communicating with eachother via messages, but what business goes on inside them is of no concern to the others
11:59:00 <jmcarthur> yup
11:59:24 <Hodapp> jmcarthur: I had a guy once insist to me that OO wasn't just programming, it was an entire set of guidelines to design your life by.
11:59:26 <simpson> Hodapp: Disregard mchurch at all costs.
11:59:28 <jmcarthur> i think by kay's definition, erlang processes are very much like OO
11:59:29 <chrisdone> that kind of 'encapsulation' really bugs me, in haskell, where hiding details for the sake of 'abstraction' is far less valuable
11:59:35 <chrisdone> jmcarthur: indeed!
11:59:35 <jmcarthur> Hodapp: haha
11:59:50 <Hodapp> simpson: I thought he made a good point at that article.
12:00:07 <Hodapp> chrisdone: it seems to lead to lots of premature generalization.
12:00:21 <Hodapp> and then "oh, whoops, that perfect little abstraction... er, let's find a way around that."
12:00:42 <simpson> Hodapp: IYSS.
12:00:43 <jmcarthur> i expose implementations when they reflect the semantics precisely, otherwise i hide them
12:00:44 <chrisdone> i guess it's more valuable in lisp or whatever when your compiler doesn't give you any help
12:01:08 <Hodapp> simpson: Have you read the article?
12:01:35 <jmcarthur> i also hide them when i just don't know whether they reflect the semantics precisely
12:01:39 <chrisdone> jmcarthur: i really like the opaque + .Internal module that the community has sort of implicitly started agreeing on somehow
12:01:41 <simpson> Hodapp: No; that particular author is not worth reading.
12:01:49 <Hodapp> chrisdone: it appears that original OOP is now more like agent-oriented programming, or something like that.
12:01:54 <jmcarthur> chrisdone: yes, i approve of this convention
12:02:17 <monochrom> chrisdone: I like saying "value" too. perhaps we should learn from Knuth and say "valued programming", skip the "oriented" meme, and force people to decide between valued programming and unvalued programming!
12:02:29 <chrisdone> monochrom: aha!!! nice!
12:02:35 <jmcarthur> functional programming is value-oriented programming :P
12:02:44 <Hodapp> monochrom: it worked out so well with "functional" vs. "nonfunctional" programming...
12:03:16 <chrisdone> Hodapp: right
12:03:25 <Hodapp> what is VOP?
12:03:28 <chrisdone> back in SICP days it was called ‚Äúblack box abstraction‚Äù or something like that
12:03:40 <chrisdone> Hodapp: ‚Äúvalue-oriented programming‚Äù. tongue and cheek opposite of OOP
12:03:43 <jmcarthur> structured programming had a very precise definition that most people accepted and a name that most people wanted to say they adhered to. we need both, to be successful.
12:04:18 <Hodapp> the article points out that an 'object' basically ends up being the same abstraction as an RPC server.
12:04:26 <Hodapp> and said abstraction is really not a good default one.
12:04:51 <jmcarthur> "valuable programming"
12:05:23 <chrisdone> value-oriented appeals to sales people who want to GET VALUE FROM YOUR PRODUCTS
12:05:35 <jmcarthur> value-oriented is also really accurate
12:05:54 <jmcarthur> the trouble is communicating what a "value" is
12:06:11 <monochrom> people conflat "value" with "value" :)
12:06:20 <jmcarthur> and also avoiding the "everything is a value" fallacy
12:06:25 * monochrom conflates "conflate" with "conflat"
12:06:25 <silver> lol
12:06:38 <silver> potatos gonna potate
12:06:40 * monochrom also conflates "monochrome" with "monochrom", but that was an old story
12:07:10 <haasn> can GHC optimize f (Foo a b c d e f) = Foo a b c d e f into f x = x -- if the type of Foo does not change?
12:07:28 * chrisdone conflates confondere a confondere
12:08:02 <monochrom> I don't know. but I know how to test
12:08:05 <chrisdone> haasn: check the core!
12:08:12 <roconnor> haasn: no and they are not even the same in the CPO semantics
12:08:37 <nadirs> chrisdone: that's italian! who's italian?
12:08:46 <monochrom> oh haha forgot that f is strict
12:09:23 <chrisdone> does that actually change it?
12:09:29 <nadirs> (or did my chat tool just translated?)
12:09:47 <roconnor> haasn: well maybe GHC can do somthing like that in some contexts, but not in general
12:09:48 <chrisdone> even though f is strict it's immediately constructing another thunk anyway
12:10:10 <chrisdone> maybe there'd be some sharing issue
12:10:22 <jmcarthur> haasn: it can certainly inline f
12:10:29 <jmcarthur> haasn: having the same effect in the end
12:10:30 <haasn> monochrom: both versions of f are strict (?)
12:11:00 <jmcarthur> ah woops, yeah, it's strict
12:11:06 <roconnor> > let {f1 (x,y) = (x,y); f2 x = x; test (_,_) = True} in (test (f1 undefined), test (f2 undefined))
12:11:08 <lambdabot>   (*Exception: Prelude.undefined
12:11:12 <jmcarthur> so it's not as cheap as id
12:11:23 <roconnor> .. that didn't go as expected
12:11:24 <jmcarthur> hmm
12:11:26 <jmcarthur> no, it is
12:11:34 <chrisdone> nadirs: haha. no, sono stato io
12:11:36 <monochrom> what both versions? you only defined one f, and it defines f (Foo a b c d e f) = Foo a b c d e f
12:11:40 <jmcarthur> id is strict too
12:11:52 <roconnor> > let {f1 (x,y) = (x,y); f2 x = x; test (_,_) = True} in test (f1 undefined)
12:11:53 <lambdabot>   *Exception: Prelude.undefined
12:11:57 <Saizan> monochrom: ".. into f x = x"
12:12:05 <nadirs> chrisdone: che bello!
12:12:16 <chrisdone> id is strict?
12:12:16 <haasn> http://bpaste.net/show/154606/
12:12:19 <roconnor> oh right
12:12:20 <haasn> chrisdone: yes
12:12:22 <chrisdone> what's your definition of strict?
12:12:31 <roconnor> haasn: so sorry, I am mistaken
12:12:37 <monochrom> I see, then I am referring to f (Foo a b c d e f) = Foo a b c d e f
12:12:39 <jmcarthur> chrisdone: if i force the result i force the argument
12:12:39 <Saizan> f is strict iff f _|_ = _|_
12:12:49 <haasn> what Saizan said
12:13:05 <chrisdone> fair enough
12:13:10 <monochrom> anyway, I have tested it
12:13:22 <haasn> I was going to go with f x `seq` () = x `seq` ()
12:13:29 <haasn> or whatever
12:13:54 <jmcarthur> i predict that ghc will perform this optimization
12:13:59 <jmcarthur> monochrom?
12:15:10 <monochrom> http://lpaste.net/96445
12:15:25 <jmcarthur> woohoo!
12:16:07 <kristof> How do I define an anonymous function that utilizes recursion of itself?
12:16:12 <chrisdone> makes sense
12:16:17 <roconnor> kristof: use let or fix
12:16:28 <kristof> roconnor: That defeats the purpose of anonymity
12:16:28 <monochrom> once again, science triumphs, theory predicts practice, practice obeys theory
12:16:41 <roconnor> kristof: use crazy Mu data types
12:16:42 <kristof> roconnor: But I guess you can't escape having to name things that you want to call, rigth?
12:16:46 <jmcarthur> kristof: why does that defeat the purpose?
12:16:53 <haasn> I checked it on a more complicated example: http://lpaste.net/96446
12:17:04 <jmcarthur> kristof: the function you apply fix to can be point free
12:17:07 <haasn> It performs the optimization (as per treeInsert') when compiling with -O2, but not when compiling with -O0
12:17:09 <jmcarthur> > fix (1:)
12:17:09 <roconnor> kristof: But I don't think fix defeats the purpose of anonymity
12:17:10 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:17:14 <haasn> interesting
12:17:20 <monochrom> to those people who are fans to the "in practice, they are different" meme: ‚ä•
12:17:26 <chrisdone> haasn: that makes sense, -O0's desugaring phase barely does anything
12:17:30 <kristof> roconnor: jmcarthur I was talking about let, not fix. ...Need to look up the fix function, now.
12:17:34 <nadirs> kristof: there was that y-combinator, but don't ask me.
12:17:44 <jmcarthur> monochrom: evaluates monochrom's claim... brb
12:17:46 <haasn> I think the difference between my first example and my more complicated one could also be that here, Tree is polymorphic
12:18:04 <roconnor> monochrom: my theory had the disadvantage of being entirely wrong
12:18:15 <donri> mm_freak_: using reactive-banana for fastirc eh
12:18:25 <roconnor> monochrom: the two functions are denotationally the same.
12:19:01 <monochrom> I also forgot that id is strict for a moment
12:19:04 <roconnor> @src fix
12:19:05 <lambdabot> fix f = let x = f x in x
12:19:06 <mm_freak_> donri: most likely yeah
12:19:14 <donri> mm_freak_: blasphemy!
12:19:26 <mm_freak_> donri: but i'm working on an STM-based FRP implementation
12:19:32 <mm_freak_> for that kind of application
12:19:33 <donri> =)
12:19:39 <donri> pipes-concurrency?
12:19:44 <chrisdone> nadirs: sei nuovo ad askell? =p
12:19:46 <mm_freak_> donri: insufficient
12:19:54 <monochrom> kristof: fix is as close to inline and anonymity as you can get.
12:20:10 <monochrom> perhaps s/inline/in situ/
12:20:45 <roconnor> monochrom: you can get closer
12:20:56 <monochrom> how do I get closer?
12:21:16 <roconnor> monochrom: with datatypes that are not positive.
12:21:55 <nadirs> chrisdone: sono gi√† alcuni mesi, ma √® come se avessi iniziato da qualche giorno (gli ho dedicato poco tempo purtroppo) :P
12:21:55 <monochrom> so I define a recursive datatype that gives me the same expressive power as fix?
12:22:17 <LadyAurora> Do I see a Romance language?
12:22:40 <jmcarthur> newtype Foo a = Foo (Foo a -> a)
12:22:40 <nadirs> chrisdone: ho letto LYAH e sto leggendo RWH, e ho fatto qualcuno dei 99problems, ma nulla pi√π :P
12:23:01 <roconnor> monochrom: yes.
12:23:07 <dwcook> I'm surprised I understood much of that.
12:23:11 <nadirs> LadyAurora: yes, sorry for the foreign-ness ;)
12:23:27 <chrisdone> nadirs: haaha :D
12:24:02 <mm_freak_> donri: netwire (AFRP in general) does not work for that kind of application, because you would need to have your entire application in a Wire/SF
12:24:23 <mm_freak_> donri: that's why i chose reactive-banana for now
12:24:37 <donri> mm_freak_: yeah i think this is related to what has confused me about your claims about frp making sense for irc ;) (only really having studied netwire)
12:25:07 <mm_freak_> i might stick with it (it's a great library after all), but my STM approach is promising as well and i get signal inhibition again =)
12:25:29 <donri> like the whole push vs pull thing
12:25:36 <datura> mm_freak_: what exactly is signal inhibition?
12:25:58 <nadirs> chrisdone: and I (sort of) understood Functors/Applicatives/Monads thanks to this beautiful blog: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
12:26:29 <donri> datura: it's when you consume angel's trumpets and have your neurosignals inhibited
12:26:31 <chrisdone> nadirs: nulla? ma dai, un p√≤? aspett√†, non ho imparato niente quando ero nuovo per‚Ä¶ tre anni, haha! ma sul serio, 6 mese? cos√¨. non ci sono italiani haskeller D:
12:26:34 <mm_freak_> datura: denotationally it's 'type Behavior a = Time -> Maybe a' + a set of continuity laws
12:26:46 <zomg> nadirs: yeah that one is definitely one of the best articles about the topic :D
12:27:21 <mm_freak_> datura: based on a topological space Time you can express that only non-empty intervals may produce (Just) or inhibit (Nothing)
12:27:32 <chrisdone> nadirs: yeah i like those pictures =)
12:27:55 <nadirs> zomg: a comment in that post sums it up: ¬´wow - no donate or buy me a coffee link. I feel like I've stolen from you. Absolutely fantastic way of explaining the essence of monads.¬ª
12:28:10 <roconnor> what sort of continuity laws let you go from continous time to a discrete type without being constant?
12:28:43 <mm_freak_> roconnor: huh?
12:28:51 <mm_freak_> not sure i understand your question
12:29:09 <nadirs> chrisdone: in the list of this IRC I can spot adinapoli, which is a professional (italian!) haskeller (I know him by his blog, I'm not a stalker, I promise!)
12:29:16 <roconnor> mm_freak_: am I right to think about Time as (isomorphic to) the real number line?
12:29:16 <jmcarthur> i think roconnor refers to transitions in Maybe always being discrete
12:29:38 <jmcarthur> Just to Nothing or Nothing to Just has no in-betweens
12:30:00 <chrisdone> nadirs: alfredo √® mio amico di penna (sul irc / email =p)!
12:30:06 <mm_freak_> roconnor: that's a useful approximation, yeah
12:30:17 <jmcarthur> s/discrete/discontinuous/
12:30:29 <mm_freak_> roconnor: note that time is continuous, not the value
12:30:32 <zomg> chrisdone: Tutti frutti?
12:30:35 <mangaba_leitosa> nadirs: are there Haskell job positions in Italy? :-)
12:30:37 <chrisdone> nadirs: i guess there are 3 =p
12:30:39 <chrisdone> zomg: lol
12:30:56 <mm_freak_> the 'Time' value is, the 'Maybe a' value (obviously) isn't
12:31:07 <chrisdone> zomg: babidiboobidi?
12:31:13 <roconnor> mm_freak_: well I am interested in the topology of "Time" because if it has the same topology as the real line then any function from Time to Maybe x that is Nothing at one point must bet Nothing at every point by continutity.
12:31:21 <nadirs> chrisdone: none that I know of. I'm stuck in a PHP/Java position, at the moment :(
12:31:27 <monochrom> Âï•?
12:31:39 <zomg> chrisdone: yeah based on my empiric study of the italian language I'd say the answer to that is yes
12:31:49 <mm_freak_> roconnor: oh, it's not a continuous function =)
12:32:00 <jmcarthur> just a continuous domain
12:32:03 <mm_freak_> obviously that wouldn't work
12:32:06 <mm_freak_> yeah
12:32:16 <roconnor> mm_freak_: non-continuous functions are almost by definition not computable.
12:32:55 <roconnor> BTW, this is why I think any model of FRP based on Time as a continous value is going to be broken.
12:32:56 <mm_freak_> roconnor: f t | t < 0 = False | otherwise = True
12:33:03 <mm_freak_> roconnor: valid
12:33:14 <mm_freak_> roconnor: f 0 = True; f _ = False
12:33:16 <mm_freak_> roconnor: invalid
12:33:40 <mm_freak_> i'm still working on formulating the laws, but that's the gist
12:33:41 <nadirs> mangaba_leitosa: none that I know of. I'm stuck in a PHP/Java position, at the moment (reposted because I mistook the poster's name :P)
12:33:48 <chrisdone> nadirs: da dove sei in italia? in il nord c'√® un lavoro haskell. ma‚Ä¶ non √® pi√π bello
12:34:15 <nadirs> I'm in Florence (in central italy).
12:34:24 <Saizan> :O
12:34:33 <chrisdone> lo so =p
12:34:40 <roconnor> mm_freak_: okay.
12:34:44 <chrisdone> Saizan: hey, aren't you italian too?
12:34:44 <mm_freak_> roconnor: although it will probably boil down to just applying conal's original laws generalized to Behavior (Maybe a)
12:34:50 <chrisdone> i forgot about that
12:35:00 <Saizan> chrisdone: yeah, i went to uni in florence
12:35:04 <chrisdone> \o/
12:35:36 <mm_freak_> roconnor: as a side note, obviously time-varying values in FRP can't be continuous functions of time, because that would rule out stuff like this:  myInputBox :: Behavior Text
12:35:55 <roconnor> indeed
12:36:03 <nadirs> Saizan: hey, nice to meet you, then :)
12:37:07 <nadirs> chrisdone: how come you know italian? Have you lived here for a while?
12:37:15 <Saizan> nadirs: cheers :)
12:37:41 <chrisdone> nadirs: https://www.youtube.com/watch?v=krtnt191Drg&t=0m30s
12:38:31 <zomg> oh that movie... :D
12:38:34 <zomg> so good
12:38:42 <chrisdone> nadirs: yeah, i live in trento. moved here for a haskell job =) now i left that job and work at fp complete, but i like it here in italy ;)
12:38:50 <nadirs> chrisdone: haha, Waltz's italian is flawless.
12:39:15 <LadyAurora> Italy? Is that the country that still has one of the best football leagues in Europe despite said league being hugely corrupt?
12:39:18 <nadirs> chrisdone: hey, that's great! FP complete is cool
12:39:25 <mangaba_leitosa> nadirs: I see :-)
12:40:01 <chrisdone> nadirs: yeah, Waltz sounds so natural!
12:40:08 <mangaba_leitosa> chrisdone: hmm, so there ARE haskell jobs in italy? :-)
12:40:11 <zomg> There was this brilliant mashup of TF2 and the Bear Jew scene from inglorious basterds
12:40:16 <zomg> but I can't find it anymore :(
12:40:26 <chrisdone> mangaba_leitosa: maybe one or two =p
12:40:28 <nadirs> LadyAurora: eh, that's because football as a system is corrupted.
12:40:35 <danilo2> Hello :) I'm plaing with cabal-instlal code - it ocmpiles when I'm using cabal configuration, but does not compile If I'm paste it to my configuration - I'm getting information about syntactic error(missing binary operator before token "(")  in such line "#if MIN_VERSION_directory(1,2,0)" - the extensions seem the same... what can cause such error?
12:40:41 * hackagebot Glob 0.7.3 - Globbing library  http://hackage.haskell.org/package/Glob-0.7.3 (MattiNiemenmaa)
12:40:44 <mangaba_leitosa> chrisdone: and why did you leave it?
12:41:35 <chrisdone> mangaba_leitosa: the manager who hired me to do haskell left, and a new manager was brought in who liked java
12:41:44 <chrisdone> you can figure the rest out yourself
12:41:53 <zomg> lol
12:41:56 <zomg> sounds familiar
12:42:03 <zomg> I left a company after I had to start doing Java as well
12:42:03 <zomg> haha
12:42:10 <mangaba_leitosa> chrisdone: :-(
12:42:13 <nadirs> chrisdone: that sounds so italian. We basically still leave in the 15th century...
12:42:56 <chrisdone> nadirs: haha ‚Ä¶ =(
12:43:18 <Saizan> yeah, when i chat from someone on the other side of the atlantic i assume they are from India
12:43:20 <zomg> tbh the only thing I know about italy is they make some good electronic music :P
12:43:26 <zomg> italodisco fuck yeah :D
12:43:27 <Hannibal_Smith> nadirs, it's more an "Nobody was fired for choosing Java"
12:43:41 <nadirs> chrisdone: where I work, I once tried proposing for a Python solution instead of PHP, but the answer was that the company has to conservative.
12:44:16 <nadirs> Hannibal_Smith: I guess you're right :/
12:44:29 <zomg> Hannibal_Smith: that sounds like some perverse version of the old IBM slogan
12:44:37 <Hannibal_Smith> Ahahaha
12:45:22 <zomg> Well, not sure if it was an official slogan but I remember hearing something similar in context to old IBM
12:45:26 <dwcook> zomg, it's not this one, is it? https://www.youtube.com/watch?v=c-VVQmRZr1E
12:45:29 <chrisdone> nadirs: also here they wanted php and drupal =/
12:45:55 <chrisdone> nadirs: i worked for one day with php and said basta!
12:45:59 <zomg> dwcook: possibly, but apparently a bunch of bad people from NBC have blocked me from viewing it
12:46:11 <nadirs> chrisdone: haha, sadly I can relate
12:46:37 <dwcook> Lame. Parody's supposed to be fair use.
12:46:50 <zomg> Probably another automatic copyright claim thing
12:47:38 <zomg> dwcook: yes, that was it :D checked it through a VPN :P
12:47:49 <dwcook> \o/
12:48:01 <zomg> TF2 has produced so much good stuff on youtube..
12:48:02 <zomg> :D
12:48:15 <nadirs> chrisdone: do you work directly with John Wiegley and Bartosz Milewski?
12:49:06 <chrisdone> nadirs: yes =)
12:49:26 <quchen> Directly, over the internet. :-√æ
12:49:38 <chrisdone> =p
12:49:50 <nadirs> chrisdone, quchen: yeah, I mean on the same project :)
12:50:25 <Hannibal_Smith> Milewski is doing a lot of Haskell marketing on his blog
12:50:49 <mgsloan> nadirs: Although Bartosz isn't working at FP Complete anymore, I still see him occasionally, which is great!  He's always upto something interesting
12:51:12 <mgsloan> Lately he's been learning category theory and HoTT and the like
12:51:18 <ocharles> am I right in thinking Hackage 2 was an almost complete rewrite?
12:51:25 <chrisdone> ocharles: s/almost//
12:51:29 <ocharles> chrisdone: :)
12:51:50 <chrisdone> tho, the codebase /feels/ like it's a few years old
12:51:57 <nadirs> mgsloan: that kind of environment seems so stimulating :D
12:52:14 <fizruk> solirc, ping
12:52:16 <chrisdone> strings and undue laziness and xhtml
12:53:02 <mgsloan> nadirs: It's been pretty excellent - it's not all roses, but I can't complain by any means!
12:53:15 <solirc> fizruk: Hey!
12:53:53 <mgsloan> ocharles: Yeah, the codebase is a few years old, I was at hacpdx a bit more than a year ago, and at that point it'd already been a few years in the works
12:54:03 <mgsloan> ocharles: There were lots of gaps where noone was working on it
12:54:15 <quchen> chrisdone: The discrepancy between using something and knowing what abominations lurk inside it is pretty large.
12:55:00 <fizruk> solirc, do you possess any knowledge of having hsc2hs not ruining dependencies installation on travis ci? perhaps I'm asking the wrong guy though :)
12:55:19 <zomg> quchen: you just described using wordpress pretty well
12:55:19 <zomg> haha
12:55:27 <fizruk> solirc, https://travis-ci.org/fizruk/trass/builds/14777184
12:55:28 <chrisdone> and most of the internet
12:55:41 <chrisdone> apparently paypal are switching to nodejs
12:55:49 <chrisdone> so‚Ä¶ you know, if you were thinking of not using paypal
12:55:49 <quchen> Oh look a website written in HTM-----quirksmode
12:55:51 <chrisdone> there's another reason
12:55:51 <quchen> WHYYYY
12:56:10 <zomg> chrisdone: but nodejs is cool!
12:56:17 <zomg> paypal is cool if they use nodejs!
12:56:18 <quchen> chrisdone: I'm pretty sure NodeJS is one of the lesser reasons not to use them.
12:56:21 <zomg> they'll become cool again
12:56:22 <zomg> :D
12:56:24 * geekosaur already avoids paypal like the plague
12:56:42 <chrisdone> this is how i felt when i was at lxjs and they were talking about nodejs http://2.bp.blogspot.com/-pIsbBmUQHIo/UMSktNJRd3I/AAAAAAAABPo/aV4DAPfnIA8/s1600/wave.gif
12:56:46 <zomg> tbh paypal is convenient for sending payments
12:56:54 <zomg> if I have the option of using paypal to pay something, I will use it
12:56:59 <quchen> chrisdone: This PLT life? :-)
12:57:05 <nadirs> zomg: so hip! https://twitter.com/hipsterhacker/status/406558113664229376
12:57:16 <zomg> because it's much easier than having to dig out my credit card, filling all the deets for that, then worrying about them not doing something stupid with the info..
12:57:19 <chrisdone> quchen: the gif is from there, tho i don't remember the caption for it =p
12:57:46 <quchen> chrisdone: Can't beat the one about SPJ and IO
12:57:57 <zomg> nodejs is not bad in my opinion, it's pretty good for certain kinds of things
12:58:14 <zomg> probably partially due to a very good library support for those certain kinds of things
12:58:23 <solirc> fizruk: I think it's currently broken and epta is working on a solution.
12:59:07 <zomg> someone needs to port Socket.IO to Haskell
12:59:08 <zomg> =)
12:59:30 * chrisdone frowns at zomg
12:59:37 <epta> solirc: I'm not working, I'm waiting for joshk actually
12:59:48 <zomg> What? You don't think having a good library for easy two way communications is a good thing? :D
12:59:58 <nadirs> quchen: that one seriously made me fall from the chair
13:02:01 <quchen> nadirs: I don't understand it but it made me laugh anyway
13:02:33 <fizruk> epta, solirc: okay, so it'll be working again soon? but what's actually broken? hsc2hs package on hackage seem to be updated more than a year ago
13:03:02 <epta> fizruk: it's not in PATH now
13:03:30 <nadirs> quchen: I find it so funny because they make it seem like if SPJ couldn't do better than using workarounds (while in reality he seems the CS version of Chuck Norris)
13:04:23 <epta> fizruk: so now we need to build new vm image and deploy it (@joshk is the travis guy who'll do that)
13:05:12 <fizruk> epta, oh I see :) thanks for the info!
13:07:28 <skypers> wooh
13:07:34 <skypers> cabal can work on ARM architecture?
13:07:40 <skypers> like, a raspberry pi?
13:07:54 <skypers> well cabal, ghc, any haskell progra
13:07:54 <nadirs> Oh my, this is QWOP! http://this-plt-life.tumblr.com/post/36425230125/when-i-try-to-design-an-extension-or-alternative-to
13:07:56 <skypers> ms*
13:08:43 <moto9> i'm always unsure about the parsing priority of `fun` binary operators, x * 10 `div` 7
13:09:17 <Saizan> moto9: infixl 9 unless declared otherwise, iirc
13:09:46 <moto9> ah
13:09:47 <nadirs> @info div
13:09:47 <lambdabot> div
13:10:13 <nadirs> that's it? Anyway `div` is infixl 7
13:10:24 <Saizan> there's no @info
13:10:32 <nadirs> > :i div
13:10:33 <lambdabot>   <hint>:1:1: parse error on input `:'
13:10:38 <nadirs> uff
13:11:21 <jmcarthur> @info fhdsjkh
13:11:21 <lambdabot> fhdsjkh
13:11:24 <jmcarthur> hmm
13:11:37 <Saizan> @info do x <- foo; bar
13:11:37 <lambdabot> foo >>= \ x -> bar
13:12:52 <jmcarthur> preflex : seen jmcarthur
13:13:07 <jmcarthur> lambdabot narrowly escapes this one
13:13:40 <monochrom> heh, info -> undo
13:15:44 * hackagebot pandoc-citeproc 0.2 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.2 (JohnMacFarlane)
13:21:58 <nadirs> goodbye everyone
13:22:42 <mreh> this truly is the nadir of his visit
13:24:35 <Hafydd> Heh heh.
13:29:33 <mgsloan> Clearly nadirs is non-monotonic :D
13:35:11 <danilo2> Hi! I've got a simple question - I'm trying to learn how cabal works under the hood. When we perform cabal update, there appears file 00index.tar.gz containing all the cabal configurations for all the packages available in hackage. I understand, that when we run cabal list, this tar.gz file is read and each cabal config is parsed and printed out?
13:38:46 <monochrom> yes
13:39:20 <monochrom> and when you say "cabal install xxx", only this list is consulted to figure out dependencies
13:39:23 <danilo2> monochrom: Thank you. Btw. it seems you know cabal good, could I ask you one more question?
13:39:29 <monochrom> yes
13:40:21 <danilo2> monochrom: I would like to extend cabal list with printing more informations - like tags of packages - how can I do it the simplest way?
13:40:39 <monochrom> I don't know. I don't use "cabal list" to begin with.
13:41:06 <benmachine> danilo2: if you want to chat about cabal development, there's #hackage (although here is fine too)
13:41:22 <monochrom> but everything you can do is already listed in "cabal list --help". if it doesn't offer an option, it doesn't offer that option.
13:41:45 <danilo2> benmachine: Ok, thanks - with next question I'll go there
13:42:07 <danilo2> monochrom: It does not offer,m but I want to extend it, because I need it :) Than you
13:43:59 <joelteon> how do I export one constructor from an ADT?
13:44:14 <donri> Type(Term)
13:44:40 <monochrom> example: module Whee(Maybe(Nothing)) where
13:44:44 <danilo2> monochrom: Do you know what is the difference between "00-index.tar" and "00-index.tar.gz" and how is it possible, that caal list works so fast, when manual extraction is over a minute?
13:44:50 <tomejaguar> Is there a good reason you have to export the type to export the constructor?  I never understood that.
13:44:53 <joelteon> oh, ok
13:45:13 <geekosaur> danilo2, one is uncompressed, the other is gzip-compressed
13:45:17 <monochrom> 00-index.tar is decompressed from 00-index.tar.gz. normally, only 00-index.tar is read.
13:46:01 <geekosaur> once it has been uncompressed, it can be read pretty quickly by skipping through the headers; with the compressed version, the whole file must be read
13:46:07 <geekosaur> (as it is uncompressed)
13:46:10 <monochrom> the only reason is that "data X = X" is allowed but now "module Whee (X)" is ambiguous.
13:46:19 <joneshf-laptop> records seem to be more of a pain that a help, is there a reason to prefer records for a simple product type?
13:46:28 <joneshf-laptop> meaning like 2-3 fields
13:46:32 <danilo2> geekosaur, monochrom: ah I see :) Thank you! :)
13:46:37 <c_wraith> at 2-3 fields, probably not.
13:46:38 <tomejaguar> joneshf-laptop: I rarely use records.
13:46:46 <monochrom> s/is ambiguous/would be ambiguous if .../
13:47:02 <tomejaguar> monochrom: Yes I understand, thanks.
13:47:20 <monochrom> perhaps a better solution is to disallow "data X = X" to begin with
13:47:24 <Javran> hi, I'm reading "monadic parser combinators" and have some problem about block comment parser: http://codereview.stackexchange.com/questions/36468/block-comment-parser-implementation-for-monadic-parser-combinators , I'll appreciate it if you can give me some hints or suggestions. Thanks.
13:47:44 <tomejaguar> monochrom: Gosh.  Never! :)
13:48:16 <monochrom> it is pedagogically terrible
13:48:31 <monochrom> but I admit that it is fine for pros
13:48:43 <c_wraith> It's really convenient when you only have one constructor and have already learned the meaning, though. :/
13:50:24 <monochrom> since I am exposed to pedagogy most of the time (like, I'm in #haskell), my worldview is distorted in such a way that I want languages to be rosy flowers, semantics to be sparkling stars, ...
13:51:06 <monochrom> and programmers to be saints
13:51:19 <tomejaguar> Bless you all, my children.
13:51:22 <silver> all of them?
13:51:53 <monochrom> well, I just said "distorted", didn't I? :)
13:52:52 <silver> because we have, well you know, Oleg, we can make him pope if you want to
13:55:26 <quchen> monochrom: -XExtendedMonomorphismRestriction!
13:56:09 <donri> well they solved similar ambiguity with keywords, e.g. module ... (type (+)) where
13:56:17 <donri> we could abuse "data" for term-level ;)
13:56:35 <datura> Javran: shouldn't notCommendEnd be not(commentEnd) followed by any char so it does consume something?
13:56:42 <donri> but it's evil to not export every type that is part of the public api anyway
13:57:54 <monochrom> well, the real problem is when importing. just yesterday I had to import IOMode(ReadMode) but I really only used ReadMode
13:58:10 <tomejaguar> monochrom: Exactly.
14:01:33 <Peaker> tomejaguar: when exporting, it would be problematic to export a constructor or any value -- without exporting its type
14:01:44 <Peaker> I think it should even be a warning that you export values that the importer cannot express the types of
14:01:51 <afraca> IO is weird. I get that you want to wrap it in a monad. I get you then have a strict sequence of operations. But I¥m having a problem now. lets say i have f :: FilePath -> IO (Maybe a)
14:01:58 <Peaker> (Ideally, using the same imports)
14:02:21 <afraca> readCalendar fp = do
14:02:21 <afraca> 	handle <- openFile fp ReadMode
14:02:21 <afraca> 	content <- hGetContents handle
14:02:21 <afraca> 	result <- run parseCalendar content
14:02:21 <afraca> 	hClose handle
14:02:34 <Peaker> afraca: for more than 2 lines please use lpaste
14:02:45 <afraca> Will do Peaker.
14:03:14 <Peaker> afraca: I don't see f within that code?
14:03:30 <afraca> No, it was sort of placeholder. sorry .
14:03:40 <nooodl> i think here readCalendar is a concrete example for a possible "f"
14:03:44 <tomejaguar> Peaker: Agreed, it's importing where it is strange.
14:03:46 <nooodl> with a = Calendar?
14:03:49 <afraca> hold on
14:04:26 <ReinH> are those... tabs? o_O
14:04:38 <ReinH> someone's gonna have a bad time
14:04:40 <afraca> http://lpaste.net/96452
14:04:42 <Peaker> tomejaguar: I use name prefixing like:  data Expr = ExprApply .. | ExprLam .. ...    so that it is safe to import Expr(..) (name-collision-wise)
14:04:48 <Javran> datura: thanks, that works. I should have realized that if inp is not a endcomment, one char can be consumed safely.
14:04:57 <ReinH> afraca: you seriously don't want to use tabs with Haskell
14:05:24 <afraca> Will do Rein
14:05:25 <KolgVX> Peaker: whyy not import qualified instead? makes more sense
14:05:26 <ReinH> afraca: btw you probably want to return result at the end
14:05:27 <nooodl> afraca: "return result"?
14:05:34 <donri> -fwarn-tabs should be on by default!
14:05:34 <afraca> ehm, yeah...
14:05:40 <donri> (it's not even enabled by -Wall!)
14:05:58 <Peaker> KolgVX: well, I do that too. But often I want to have field names, so I have to do:   data Apply = Apply { applyFunc :: Expr, applyArg :: Expr } ; data Expr = ExprApply Apply | ...
14:06:18 <Peaker> KolgVX: a bit cumbersome, but much nicer to be able to pass around "Apply" than to pass (Expr, Expr) after pattern-matching the ExprApply case
14:06:37 <ReinH> donri: o_O
14:06:46 <Peaker> KolgVX: but indeed I use qualified to avoid this when possible
14:06:48 <afraca> ReinH: i can¥t just type ®return result® ....
14:06:54 <ReinH> afraca: why not?
14:07:10 <afraca> iCalendar.hs:252:19:Couldn't match type `Maybe' with `IO'
14:07:10 <afraca>   Expected type: IO Calendar
14:07:10 <afraca>     Actual type: Maybe Calendar
14:07:10 <afraca>   In the return type of a call of `run'
14:07:10 <afraca>   In a stmt of a 'do' block: result <- run parseCalendar content
14:07:33 <afraca> (Or is pasting multiple lines a no go even when It≈õ not code? )
14:07:45 <ReinH> afraca: please don't paste multiple lines at all :)
14:07:48 <ReinH> it's disruptive
14:07:56 <Peaker> afraca: what type is "run parseCalender content" ?
14:08:07 <ReinH> afraca: what is... yes that
14:08:10 <afraca> run :: Parser a b -> [a] -> Maybe b
14:08:17 <Peaker> afraca: it doesn't sound like it should involve IO at all, so shouldn't use "<-" syntax in an IO do block
14:08:22 <skypers> is there a function like print but with no newline?
14:08:31 <ReinH> skypers: putStr . show
14:08:36 <skypers> yeah‚Ä¶
14:08:39 <Peaker> afraca: Don't use "hClose" in combination with lazy IO
14:08:39 <ReinH> skypers: print is just putStrLn . show
14:08:40 <skypers> I mean a single function
14:08:42 <afraca> Peaker: I·∏ø reading from a file
14:08:46 <ReinH> skypers: define one
14:08:48 <skypers> why?
14:08:52 <Peaker> afraca: the "hGetContents" does that
14:08:58 <Peaker> afraca: though openFile + hGetContents is simply "readFile"
14:08:58 <skypers> why isn‚Äôt print putStr . show
14:09:08 <skypers> printLn should be putStrLn . show
14:09:18 <ReinH> Peaker: when you say result <- run parseCalendar content you are in the Maybe monad
14:09:18 <Peaker> afraca: readCalender fp = run parseCalendar <$> readFile fp
14:09:25 <afraca> Peaker: Fascinating . So that could just go isolated on it¥s own.
14:09:29 <ReinH> you want let result = run parseCalendar content
14:09:29 <Peaker> ReinH: but his do block is in the IO monad
14:09:31 <afraca> Peaker: Thanks, will try
14:09:44 <ReinH> Peaker: but it needs to call >>= on something
14:09:49 <ReinH> and it's not an IO aciton
14:10:01 <Peaker> ReinH: why? There's no use of the Maybe monad here at all
14:10:10 <ReinH> Peaker: run returns a Maybe
14:10:15 <ReinH> that's the Maybe monad right there
14:10:19 <Peaker> right, but the Monad instance isn't used
14:10:23 <Peaker> (of Maybe)
14:10:26 <ReinH> yes it is, by >>=
14:10:46 <ReinH> run parseCalendar context >>= \result -> ...
14:10:54 <Peaker> it's not, the "do" block there is a bunch of IO statements -- it's just an error
14:11:01 <Peaker> (he didn't mean to use >>= on Maybe)
14:11:04 <afraca> I can make a new paste with the information like signatures combined if that makes it clearer
14:11:11 <ReinH> Peaker: I know he didn't mean to, but he did
14:11:23 <ReinH> and he just wants to use a let binding
14:11:24 <Peaker> ReinH: what he did is write something that doesn't compile, let alone use any Monad instance at all :)
14:11:58 <Peaker> It's silly to argue whether something that doesn't type-check mean one thing or another (I guess this is a very old debate?)
14:12:09 <ReinH> Peaker: well, if you want to understand the error...
14:12:31 <Peaker> Except even in that old debate, I am guessing that for cases that are errors -- there is no useful meaning (beyond "error")
14:12:44 <afraca> Peaker ¥s line did work
14:12:47 <ReinH> Peaker: the error is that run provides a Maybe, not an IO
14:13:27 <ReinH> and >>= there is supposed to be of type IO a -> (a -> IO b) -> IO b
14:13:42 <ReinH> but it's of type IO a -> (a -> Maybe b)
14:14:28 <ReinH> How do I ask lambdabot for the type of (>>=) applied to IO?
14:14:29 <afraca> Wait a minute....
14:14:32 <ReinH> for future reference?
14:14:43 <danilo2> Hello! I've seen, that Hackage 2 supports package tags and indeed, when we look at some packages, they've got assigned tags, but how are the tags asigned? In package cabal files there is no word about the tags, or am I missing something?
14:14:43 <ReinH> afraca: What Peaker told you works, I'm just explaining the error
14:14:58 <afraca> Not it didn¥t work like the signature...
14:15:26 <afraca> ReinH: I¥ll make a new paste
14:15:26 <ReinH> afraca: if you change your result <- ... line to let result = ...
14:15:33 <ReinH> and `return result` at the bottom of the do block
14:15:35 <ReinH> it should work
14:15:38 <afraca> ReinH: let ¥s see
14:15:42 <dcoutts_> danilo2: that's not really fully implemented yet. The idea is that we start with the categories from the .cabal file (with some manual adjustments) and then some extra curated tags
14:16:57 <ReinH> this is also, iinm, readCalendar = run parseCalendar <$> hGetContents =<< flip withFile ReadMode
14:17:27 <afraca> http://lpaste.net/96453
14:17:28 <danilo2> dcoutts_: Hmm what are categories? Do you plan to support "normal" tags in the future? I mean - package author would be able to asign tags by hand?
14:17:55 <dcoutts_> danilo2: oh sure, they can assign them manually in the web ui
14:18:02 <danilo2> dcoutts_: ah I see what you mean by categories. So right now you're doing mapping category -> [tag] ?
14:18:15 <dcoutts_> danilo2: right, except that bit it's currently working.
14:18:37 <danilo2> dcoutts_: But will we be abl to set them in cabal files olso? Not only via web interface?
14:18:39 <afraca> ReinH , Peaker: You guys are saints for being patient. Thanks . And I¥ll fix the tabs soon
14:19:02 <dcoutts_> danilo2: at the moment the only thing that's working is the manually assigning tags in the web ui (and they're not really used much yet so there's not a lot of incentive to set them)
14:19:08 <Peaker> ReinH: you can look at the error that way, or you can look at it as use of <- where he meant let.
14:19:29 <ReinH> Peaker: right, I'm trying to explain *why* it's supposed to be a let instead of <-
14:19:39 <dcoutts_> danilo2: yes that's what the [category] -> [tag] gives you: the ability  to set them in cabal files
14:19:56 <Peaker> ReinH: since he's using lazy I/O there, it's not a good idea to use "hClose .." and then "return result".  shouldn't mix "hClose" with lazy I/O. And thus the intermediate "result" and its "return" are not needed
14:20:24 <ReinH> Peaker: and do syntax doesn't mean it's "inside" any particular monad. That's implied by the type.
14:20:34 <c_wraith> :t do 5
14:20:35 <lambdabot> Num a => a
14:20:39 <ReinH> Peaker: that's why I suggested withFile
14:20:39 <c_wraith> No monad there
14:20:48 <danilo2> dcoutts_: Oh, I didnt know we can assign more than one cateogry to a library. That's cool
14:20:54 <ReinH> c_wraith: exactly
14:20:55 <afraca> Have you seen my latest paste: http://lpaste.net/96453 . That≈õ just a messy error
14:20:59 <c_wraith> ReinH: withFile is just as bad for lazy IO
14:21:00 <Peaker> ReinH: "withFile" is also not a good idea to mix with lazy I/O
14:21:04 <ReinH> ok
14:21:05 <Peaker> ReinH: "do" syntax is always inside some particular Monad
14:21:06 <Eduard_Munteanu> Does haskell-mode attempt to find the toplevel cabal project directory if I open a file directly, without changing the current dir to the project root?
14:21:06 <ReinH> my bad
14:21:10 <ReinH> Peaker: no, it isn't
14:21:16 <ReinH> do syntax is sugar, no more, no less
14:21:27 <Peaker> ReinH: well, it could be a polymorphic "Monad m => ... m ..." of course :)
14:21:27 <c_wraith> > do () -- Peaker
14:21:27 <lambdabot>   ()
14:21:36 <Peaker> c_wraith: arguably a bug :)
14:21:45 <ReinH> @undo do ()
14:21:45 <lambdabot> ()
14:21:56 <Peaker> Yes, I know how "do" is desugared
14:22:02 <ReinH> So how is it a bug?
14:22:06 <ReinH> It's a simple rewrite rule
14:22:53 <Peaker> because it is not sensible to use "do" with a value that does not even have the right shape, let alone is not a Monad instance (the latter is perhaps OK, if we want to admit generalized "do" for Applicative, etc).  It is likely an error
14:23:26 <afraca> So ehm... How should I go out and fix that sample ( http://lpaste.net/96453 )  In the error it¥s not even a Maybe to be seen....
14:23:27 <ReinH> do "with a value"?
14:23:40 <Peaker> "do <expr>", s/value/expr
14:23:49 <danilo2> dcoutts_: I understand, that when I'm using multiple words in "category" section I'll assign multiple categories to a single package?
14:23:54 <c_wraith> I'd be happy with a warning on any use of do that doesn't desugar to using at least one of >> or >>=
14:23:54 <Peaker> When we have "do x" -- it would be nice if that was always OK to translate it to: "do { a <- x ; return a }"
14:23:57 <ReinH> afraca: what are you using for parsing?
14:24:11 <dcoutts_> danilo2: yes
14:24:15 <ReinH> afraca: and what is line 256?
14:24:28 <afraca> ReinH: a uu-tc package from hackage (for my course)
14:24:30 <ReinH> c_wraith: makes sense
14:24:34 <dcoutts_> danilo2: in retrospect of course we should have called it "tag" rather than category
14:24:38 <afraca> oh wait
14:24:42 <afraca> nevermind -_-
14:24:54 <ReinH> afraca: beacuse it's no longer a do-related error :)
14:24:57 <afraca> ReinH: work¥s beautiful now
14:25:02 <ReinH> great
14:25:02 <enthropy> Peaker: that translation seems allowed by a monad law
14:25:10 <Eduard_Munteanu> Peaker: you could argue it's a naked identity monad though :)
14:25:13 <ReinH> afraca: do keep in mind what they said about hClose not working well with lazy IO
14:25:22 <danilo2> dcoutts_: Exactly! I was thinking about it - why they are separated. Because I do not think we need tags AND categories together, or am I wrong? Btw. Have you seen this?: https://github.com/haskell/cabal/issues/1597#issuecomment-29581237
14:25:25 <enthropy> oh I see now
14:25:28 <afraca> ReinH: How can I avoid it here?
14:25:51 <afraca> ReinH: I still need to go by the signature for readCalendar
14:26:00 <enthropy> sometimes it's not allowed because `x' doesn't have to be monad
14:26:08 <dcoutts_> danilo2: well that's why we don't plan to separate them, the categories are (or rather will be) interpreted on hackage as tags
14:26:20 <ReinH> afraca: call withFile and pass it your do block
14:26:20 <Peaker> enthropy, Eduard_Munteanu: Sure, but it isn't allowed in "do ()"
14:26:37 <dgp> Hi all. Very new to haskell. I'm looking for a way to use the type parameter of a type constructor inside a definition of a type class. Something like "class C (Constr a) where ...". Google leads me to multiparameter type classes, but that's not exactly it... . Any advice is appreciated!
14:26:43 <Peaker> I think GHC ought to give an error about "do ()"
14:27:13 <afraca> ReinH: Thanks, will do (no pun intended)
14:27:13 <ReinH> readCalendar fp = withFile fp ReadMode \h -> do ...
14:27:21 <Peaker> dgp: You can use either MPTC's or Type Families
14:27:23 <afraca> ReinH: :)
14:27:27 <Maior> Peaker: why?
14:27:28 <danilo2> dcoutts_: Nice to hear that! Thank you for the clarification! :)
14:27:32 <Eduard_Munteanu> dgp: class C a where foo :: Constr a -> ...   -- sounds like that's what you want
14:27:33 <ReinH> afraca: you want to make sure withFile sees the entire IO action so it knows when it is allowed to close the handle
14:27:38 <enthropy> > let f x@(~(~y)) = x + y in f 2
14:27:39 <lambdabot>   4
14:27:53 <Peaker> Maior: read the above -- it means you cannot validly transform:  "do x" to "do { a <- x ; return a }"
14:28:19 <Peaker> Eduard_Munteanu: I think the different instances probably are different type constructors?
14:28:19 <Maior> oops, thanks
14:28:20 <enthropy> Peaker: I don't think it makes sense for a language to make the definition more complicated to restrict things nobody is going to use
14:28:25 <afraca> ReinH: I see
14:28:35 <Eduard_Munteanu> Ah, it won't do in that case, yeah.
14:28:41 <Peaker> enthropy: That's an argument against type-checking and perhaps soundness in the type system
14:28:42 <ReinH> afraca: see this SE answer http://stackoverflow.com/questions/9406463/withfile-vs-openfile
14:28:59 <enthropy> > 2 * do 1 + 2
14:29:00 <lambdabot>   6
14:29:15 <enthropy> it's a paren-killer
14:29:19 <danilo2> dcoutts_: If I might, I would ask you one more question, because you're cabal developer - I want to create my own "cabal list" options - to print for example categories or to be able to print the result in json format - would you like me to create pull request with my code or such functionality will never be needed / allowed in cabal ?
14:29:26 <afraca> ReinH: And then I can get rid of the manual opening and closing right?
14:29:40 <Peaker> enthropy: "do <list of statements>" where each <statement> is of the form: "<expr>" or "Pattern <- <expr>" (or "let" ...) and each <expr> is of type "m a" of the same "m" sounds like a sensible definition to me
14:29:56 <dcoutts_> danilo2: you probably mean cabal info
14:29:59 <Peaker> enthropy: do you use that in real code?
14:30:00 <afraca> ReinH: And I get h as my handle
14:30:07 <enthropy> not yet
14:30:16 <dcoutts_> danilo2: which already includes category
14:30:18 <Peaker> enthropy: I hope you don't, because it isn't sensible :)
14:30:18 <dgp> Eduard_Munteanu: Peaker is right, I wanted to imply that it should work for different constructors Constr
14:30:24 <sipa> dgp: can you be more specific?
14:30:27 <ReinH> afraca: yep, but you can call it \handle if you want :)
14:30:27 <enthropy> usually the stuff after the do uses some <-
14:30:39 <danilo2> dcoutts_: I mean "cabal list" - which lists available packages - I want to get info about categories in the output and I would love the ouptut to be listed in JSON format also
14:31:09 <dcoutts_> danilo2: cabal list needs replacing with a more general search functionality
14:31:15 <Peaker> dgp: class Foo a where type Bar a ; ....    is how you define an associated type "Bar a" which is also called a "type family" and is like a type-level function mapping "a" to "Bar a".  Then you have:  instance Foo (Maybe a) where type Bar (Maybe a) = a ; ...
14:31:25 <Eduard_Munteanu> dgp: ok, say you have 'data Foo a' and 'data Bar a'. Is it ok to have an instance for Foo and any 'a', and another for Bar and any 'a'?
14:31:28 <dcoutts_> danilo2: which is doable now, I wrote a new search engine for hackage, and we can reuse that directly
14:32:13 <Eduard_Munteanu> dgp: it would help if you provided a type for the typeclass method you intend to write, if you know it
14:32:17 <dcoutts_> danilo2: as for json, cabal is currently a user-oriented tool, not a machine tool. If we want to change that, there's lots of things. And I'm not so sure it's a good idea, better is to extract appropriate libs.
14:33:01 <dgp> Peaker: reading into Type Families now thanks
14:33:24 <enthropy> Peaker: what is your opinion on a `do' for applicatives?
14:33:54 <Peaker> enthropy: sounds nice :)  Haven't used it, though
14:34:00 <ReinH> enthropy: Personally I still like the banana brackets
14:34:24 <ReinH> There's a TH library that lets you do [i| f a b |] for f <$> a <*> b
14:34:28 <Eduard_Munteanu> Are there samples of the 3 indent styles provided by haskell-mode?
14:34:33 <enthropy> Peaker: well that's kind of along the same argument as "do shoudn't require a Monad m => when it's not needed"
14:34:44 <ReinH> Eduard_Munteanu: wait, haskell-mode provides 3 indent styles? Haskell-mode for what?
14:34:49 <enthropy> @hackage applicative-quoters
14:34:49 <lambdabot> http://hackage.haskell.org/package/applicative-quoters
14:34:49 <ReinH> emacs?
14:34:54 <Eduard_Munteanu> ReinH: yes, sure
14:35:04 <Peaker> ReinH: that's not enough though, since your "f" is going to often be something ugly like: \x y z -> <some pure stuff involving x y z>   where "do" for Applicatives can let you just name x,y,z directly with <-
14:35:09 <ReinH> Eduard_Munteanu: vim's indent support is so shit compared to emacs :/
14:35:10 <dgp> Eduard_Munteanu: Yes, Bar and Foo can have different 'a' types, but the types within the class definition should be dependent on them. I have data TreeSol a = ... and class Sol s where ... (and a function in the class should depend on a, and all Sols should take one type parameter)
14:35:28 <dgp> Thanks for both of your help.
14:35:43 <Peaker> enthropy: I agree that both are generalizations, but the Applicative generalization is sensible and meaningful, and the "do x" degenerate generalization is senseless and useless -- more likely an error than anything
14:35:51 * hackagebot system-random-effect 0.1.2.0 - Random number generation for extensible effects.  http://hackage.haskell.org/package/system-random-effect-0.1.2.0 (ClarkGaebel)
14:36:07 <ReinH> Peaker: Er, how is that not enough? Then you just have [i| f x y z |] right?
14:36:36 <danilo2> dcoutts_: I see, hmm so If I need right now something like "cabal list", but with categories, I should copy and change some code from cabal-install and wait for new search functionality? Btw. Would you make a library out of cabal-install in the near future, as some people (invcluding me) have discussed on github bugs page?
14:36:48 <Peaker> ReinH: imagine:  do { x <- <loooong expr> ; y <- <another long expr> ; pure (x+y)*(x-y) }
14:37:11 <Peaker> ReinH: [i| (??) <loooong expr> <another long expr> |] ?
14:37:28 <Eduard_Munteanu> Peaker: I sort of agree, but I think it isn't wise to disable that because you can't overload do syntax if you do that, I think. E.g. indexed monads.
14:37:31 <dcoutts_> danilo2: or use cabal list --simple-output, and script that with cabal info
14:37:37 <ReinH> Peaker: dunno, seems like meaningfulName = <loooooooong expr> would be useful
14:37:51 <dcoutts_> danilo2: I just commented on that ticket you pointed me to
14:37:58 <ReinH> both specifically and in general for improving readability
14:38:03 <Peaker> ReinH: that won't help, because you still need to put (x+y)*(x-y) somewhere
14:38:12 <danilo2> dcoutts_: yeah, but then the index.tar.gz will be opened as many times as count of the results - so it could be very slow
14:38:16 <ReinH> Peaker: that goes in f, surely?
14:38:43 <Eduard_Munteanu> Peaker: for instance, how do you check if it's monadic, and what is a Monad after all?
14:38:47 <Peaker> ReinH: so the (x+y)*(x-y) expr needs to be put into its own definition in a where clause? And then the "x" and "y" get bound to far-away expressions :(
14:38:49 <ReinH> Peaker: so you want an applicative do that lets you write complex applicatives directly. Ok :) I'm not sure I do.
14:39:02 <ReinH> pun not intended
14:39:13 <ReinH> I should have asked SimonM about applicative do :/
14:39:14 <Eduard_Munteanu> AFAICT the current 'do' is just syntactic.
14:39:16 <ReinH> missed opportunity
14:39:19 <ReinH> Eduard_Munteanu: yes, it's sugar
14:39:21 <danilo2> dcoutts_: Your comment sounds very good and the separation ver logic! Do you think would you separate it in "near future"?
14:39:39 <dcoutts_> danilo2: one approach would be to make the fields listed be configurable from the command line
14:39:53 <Peaker> Eduard_Munteanu: If nothing in right of <- uses and (<-) binding from earlier, and all the types used conform to Applicative, it is Applicative
14:40:10 <Peaker> I agree it might be a good idea to use "ado" for Applicative-do, but Simon Marlow's use case for Applicative do, OTOH, is also convincing
14:40:16 <Eduard_Munteanu> ReinH: sure, I wanted to stress it's *only* sugar for syntax, it doesn't touch anything else besides (>>=)
14:40:23 <dcoutts_> danilo2: the thing is that one usually wants the list output to be relatively short, but a minority of users want extra fields
14:40:45 <dcoutts_> danilo2: hard to say, it's quite a bit of work
14:40:59 <ReinH> Peaker: I think we'd need to get the typeclass redesign in place to prevent unexpected behaviors if some do's became applicative
14:41:28 <Eduard_Munteanu> Peaker: you could just build the expression and you get an 'f (f a)' if it isn't an Applicative after all.
14:41:58 <Eduard_Munteanu> If it isn't Applicative-ish, I mean.
14:42:01 <danilo2> dcoutts_: Exactly - that would be the best option. If I could say what I want - is the best possible solution. I think when the new search functionality comes out I'll create (for my usage) the JSON output - if you wuld like, you could merge it - I think such functionality (with flag --json) would be usable sometimes for people writing scripts
14:42:26 <Peaker> Eduard_Munteanu: but the types shouldn't change shape due to the change, only the constraints should change
14:42:45 <Peaker> Eduard_Munteanu: if it is supposed to be an "f a" for an Applicative "f", at worst it could become "f a" for a Monadic f
14:43:09 <dcoutts_> danilo2: btw, what kind of script are you thinking of?
14:43:29 <danilo2> dcoutts_: Ok last question if I could :) Why dont you (cabal developers) use argument parser library as Options.Applicative but you're parsing them more "low level" way? I think there would be big benefits of using such library and much shorter code to handle the params.
14:43:33 <Eduard_Munteanu> Peaker: er, if you do that you depend on Applicative and Monad, not just their methods
14:44:24 <dcoutts_> danilo2: we have severe limitations on the dependencies we can use. Trust me, parsers (the lack thereof) are the bane of my life when working on Cabal.
14:44:26 <danilo2> dcoutts_: The script I'm talking about displays in a graphical way available packages and assign them colorfull tags - so I need to list available packages with tag information
14:44:31 <Eduard_Munteanu> Peaker: would be nicer if we just picked a single, independent combinator to write 'ado' and perhaps 'do' too in terms of it.
14:44:49 <ReinH> dcoutts_: what would be your option parsing library of choice btw?
14:44:50 <Eduard_Munteanu> Peaker: said combinator not having a fixed type
14:45:12 <dcoutts_> danilo2: sounds like you'd be better off just copy'n'pasting a little bit of the cabal-install code. Most of it is actually already exposed from the Cabal+tar packages
14:45:13 <danilo2> dcoutts_: Oh :( Where the limitations cpome from ? :(
14:45:47 <Peaker> Eduard_Munteanu: hmm. but it is nice to have uniform syntax for "effectful bindings" that is desugared to <*> when possible and >>= when not possible
14:46:26 <dcoutts_> ReinH: actually for option parsing I'm reasonably happy with what we have. It's introspectable so we can auto-generate auto-completions, and we can automatically get a config file corresponding to the command line interface.
14:46:33 <danilo2> dcoutts_: I'm doing it exactly this way, but still - I'm feeling it is not good solution, because in the future I'll have to constainly update it and because of that I prefer for example contributing to cabal-install instead of creating some copy pasted code, that can get obsolete very fast
14:46:34 <Peaker> though "ado" could always do the former, and "do" always do the latter. It would not work for SimonM's case
14:47:32 <dcoutts_> danilo2: it can't got out of date very fast. The index format is a standard interface and there's a large installed base.
14:48:04 <dcoutts_> danilo2: the limitation comes from the fact that GHC depends on Cabal. This means we cannot use parsec for example.
14:48:18 <dcoutts_> despite the fact that parsec is in the platform
14:48:26 <ReinH> dcoutts_: huh... neat I'll check that out
14:48:45 <ReinH> dcoutts_: optparse-applicative is very shiny though ;)
14:49:05 <Eduard_Munteanu> Peaker: maybe do can be a function: a typeclass that joins an arbitrary number of f (f (f... a))) applications
14:49:10 <dcoutts_> ReinH: the ~/.cabal/config file parser+printer is generated from the cabal-install command line spec.
14:49:22 <danilo2> dcoutts_: You cannot use parsec in Cabal, but in Cabal-install you can ? Cabal is not parsing any arguments as far as I know :)
14:49:54 <dcoutts_> danilo2: our command line system is shared with Cabal. And that system is not a problem. The parser problem is with .cabal files and other things we have to parse.
14:50:07 <Eduard_Munteanu> Peaker: AFAICT you can already do something like that if you use the free monad of a functor, which can be either an Applicative or a Monad.
14:50:12 <danilo2> ReinH: optparse-applicative is really great! I'm using it for some months now and its the best opt parser I've found
14:50:34 <dcoutts_> ReinH: actually I think I prefer the more declarative approach. optparse-applicative is more for implementing the declarative stuff
14:50:46 * dcoutts_ finds optparse-applicative rather confusing actually
14:50:49 <Peaker> Eduard_Munteanu: you can convert m (m (m ...)) to the Free form and then flatten the Free monad
14:50:53 <Peaker> dcoutts_: why?
14:50:53 <MorphinTime> So ehh, wht s the major caveat of implementing non strict semantics with a CPS?
14:50:59 <Peaker> dcoutts_: I find it nice
14:51:05 <Eduard_Munteanu> Peaker: yeah, something like that
14:51:17 <ReinH> dcoutts_: I added some lensiness to good old getOpts and it was rather nice
14:51:20 <Peaker> Eduard_Munteanu: but I don't see why do that and not directly use >>= or <*> from the desugaring
14:51:24 <danilo2> dcoutts_: Oh, that's sad :( Anyway, thank you for all the informations an help! :)
14:51:25 <Peaker> Eduard_Munteanu: (flatten as you go)
14:51:39 <dcoutts_> ReinH: yes, getOpt isn't that bad
14:51:52 <ReinH> dcoutts_: https://gist.github.com/reinh/7880188e1b251bb51e6e
14:52:39 <Eduard_Munteanu> Peaker: not sure, can you write any Applicative function using (>>=) in such a way that you don't get multiple applications of 'f'?
14:53:16 <Peaker> @src ap
14:53:17 <lambdabot> ap = liftM2 id
14:53:21 <ReinH> dcoutts_: Kleisli monoid ftw :)
14:53:25 <dcoutts_> ReinH: right, we use (primitive) lenses too
14:53:45 <Peaker> Eduard_Munteanu: sure, since Applicative form can trivially be converted to monadic form without extra flattening (using liftM2 id ^^)
14:53:46 <dcoutts_> ReinH: so we can parse cli and pretty-print cli, and config files.
14:53:53 <ReinH> seems good
14:54:09 <Eduard_Munteanu> Peaker: you can't really use liftM2 id if you want to make it generic enough.
14:54:21 <ReinH> dcoutts_: foldr (>>=) is such a nice idiom
14:54:28 <FreeFull> :t liftM2 id
14:54:29 <lambdabot> Monad m => m (a2 -> r) -> m a2 -> m r
14:54:39 <Peaker> Eduard_Munteanu: af <*> ax -->  af >>= \f -> ax >>= \x -> return (f x)
14:54:41 <Eduard_Munteanu> Peaker: I'm wary of picking Monad in particular because I'd like it to work for indexed monads too.
14:55:05 <Peaker> Eduard_Munteanu: >>= can come from IndexedMonad instead, even with today's "do" afaik (RebindableSyntax ext?)
14:55:25 <FreeFull> Applicative often has different behaviour with regards to sharing compared to Monad
14:55:26 <Eduard_Munteanu> Peaker: yes, but that's because it only uses (>>=) as a name and doesn't care about the type
14:55:41 <Eduard_Munteanu> I'd like to preserve that property. :)
14:55:45 <FreeFull> Monad instances tend to have less sharing
14:55:53 <Peaker> FreeFull: Applicative can do what Monad can, but not vice versa
14:55:54 <Eduard_Munteanu> Preferably pick an independent combinator.
14:56:07 <Peaker> FreeFull: so it's better to use Applicative and then choose
14:56:28 <FreeFull> Peaker: I think you mean it the other way around
14:56:30 <Peaker> FreeFull: (if Applicative is Applicable)
14:56:38 <FreeFull> But it is better to pick Applicative over Monad in general
14:56:43 <FreeFull> Or even Functor if that is a choice
14:56:51 <Peaker> FreeFull: by "do", I mean as the implementer of the type, not as the user of that Applicative
14:56:57 <FreeFull> Ah
14:57:49 <Peaker> basically, I meant that having different kinds of sharing from Monads and Applicatives might suggest using the Monad instance over the Applicative instance for some cases (where you want less sharing) -- but IMO you should instead customize the Applicative type to do what you want
14:57:58 <Eduard_Munteanu> Well, if you start with 'ado' instead you could decide what to do with the result based on the type. If the result is an 'f a', it's applicative-ish, if you get f (f ... a) you have to bring a Monad constraint in.
14:58:37 <Eduard_Munteanu> Effectively making 'do' a function that's applied to an 'ado' block.
14:58:40 <Peaker> Eduard_Munteanu: can you give an example of that happening? Maybe I'm misunderstanding you, but I just don't see why you'd ever get anything of the form: f (f ... a)
14:58:55 <Peaker> Eduard_Munteanu: with desugaring into >>= or into <*>
14:59:11 <Peaker> if you desugar into nested fmaps, maybe?
14:59:32 <Eduard_Munteanu> Peaker: if you desugar monadic 'do' blocks in terms of <*>
14:59:44 <FreeFull> Monadic do blocks should stay as is
14:59:47 <Eduard_Munteanu> Well, not (<*>) per se.
15:02:52 <jerv> I'm trying to figure out how to achieve backtracking in haskell with list comprehensions. Could someone give some example code on for example a function that takes an argument n and returns a list of all strings {0,1}^n?
15:02:54 <Peaker> Eduard_Munteanu: well, it just wouldn't work because (a -> f b) wouldn't work as   f (a -> b)     to use <*> it would have to avoid depending on the "a"
15:02:58 <Eduard_Munteanu> :t (\a b -> Just (a + b)) <$> Just 5 <*> Just 3
15:02:59 <lambdabot> Num a => Maybe (Maybe a)
15:03:06 <Hodapp> embed Python as a DSL in Haskell!
15:03:08 * Hodapp runs
15:03:46 <Peaker> > let foo n = replicateM n [0,1] in foo 3
15:03:47 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
15:04:03 <Eduard_Munteanu> Peaker: right but do syntax doesn't know the types, so if you give it the right combinator it may build a tower of fs.
15:04:14 <Hodapp> what is <*>?
15:04:28 <FreeFull> <*> is ap
15:04:31 <FreeFull> :t (<*>)
15:04:32 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:04:35 <monochrom> <*> is an important operator for Applicative
15:05:03 <Eduard_Munteanu> Peaker: I guess I do mean like fmap after all
15:05:06 <FreeFull> It takes a data structure of functions, and a datastructure of values, and applies the functions to the values
15:05:11 <Hodapp> Control.Monad.ap?
15:05:18 <FreeFull> Note that b in that type signature might be a function
15:05:19 <kau> hi guys
15:05:31 <jerv> Peaker: do you perhaps have a more beginner alternative with natural recursion and list comprehension?
15:05:33 <Peaker> Eduard_Munteanu: yeah, but I don't think you should do the fmap thing and later try to figure out how to flatten. instead, just flatten immediately with <*> or >>= as needed
15:05:38 <kau> A simple question: what is the operator >> called?
15:05:39 <monochrom> also, read "f <$> x <*> y" as "(f <$> x) <*> y", that will give you the right types
15:05:44 <Peaker> jerv: sure, will write one, sec
15:05:52 <FreeFull> kau: I saw it referred to as "then"
15:05:52 <jerv> thanks
15:05:54 * hackagebot system-random-effect 0.2.0 - Random number generation for extensible effects.  http://hackage.haskell.org/package/system-random-effect-0.2.0 (ClarkGaebel)
15:06:24 <kau> FreeFull: thanks
15:06:36 <kau> it doesn't look like a good name choice :)
15:06:45 <Eduard_Munteanu> Peaker: yeah, I guess it would have an impact on runtime
15:06:47 <monochrom> the best name choice is already >>
15:06:57 <Eduard_Munteanu> You can't make Free a newtype.
15:07:17 <Eduard_Munteanu> Or if you go the typeclass route you still pass dicts around.
15:07:32 <kau> monochrom: how would you say it?
15:07:46 <Eduard_Munteanu> Might be possible to write fusion rules for it though.
15:07:54 <monochrom> the second best name choice is silence. just write code out on whiteboard or irc.
15:08:09 <Eduard_Munteanu> (IIRC that's something Free is alright at)
15:08:25 <monochrom> indeed, using do-notation, it doesn't even appear syntactically
15:08:33 <Peaker> jerv: foo 0 = [[]] ; foo n = [prefix:opt | opt <- foo (n-1), prefix <- [0,1]]
15:08:34 <kau> right
15:08:42 <Peaker> jerv: is that what you had in mind?
15:08:52 <monochrom> are you a modem? only modems are required to convert code to voice.
15:09:05 <FreeFull> Well, modems have their own way
15:09:43 <kau> But I like to think that >> is very much like a ";" in imperative programming, and wanted to explain that to friends
15:09:57 <quchen> Is there a name for functions that are mathematically but not computationally associative? For example (++) performs very poorly when nested left-associative.
15:09:59 <monochrom> if you say, "how to search on google", then "then" or any name is just as bad as ">>".
15:10:16 <jerv> Peaker: exactly that, thanks!
15:10:18 <monochrom> then say exactly that
15:10:47 <monochrom> you can always say "this funny operator"
15:10:50 <Eduard_Munteanu> kau: might be easier to introduce (>>=) directly, then relate to (>>)
15:10:56 <topi`> I tried to do "cabal install BitSyntax" but got a failure about ambiguous module name prelude - so I'd need to choose between base and haskell98
15:10:59 <topi`> but how?
15:11:16 <topi`> the "cabal" came from debian's cabal-install package. Any ideas?
15:11:18 <quchen> monochrom: Were you talking to me there?
15:11:22 <monochrom> no
15:11:30 <kau> Eduard_Munteanu: OK
15:12:13 <dcoutts_> topi`: the package needs updating for newer ghc. You could probably do that yourself with a little work.
15:12:41 <Eduard_Munteanu> kau: they can relate to "int a = init_a(); char b = use(a, 3); ..."
15:13:37 <topi`> dcoutts_: the ghc installed now is versin 7.4.1 .. which one would I need?
15:14:13 <kau> Eduard_Munteanu: my idea is that imperative programming can be viewed as a special case of functional programming. I don't know if it's reasonable to say so.
15:14:35 <monochrom> they are special cases of each other mutually
15:14:37 <dcoutts_> topi`: I'm not suggesting you use an older ghc, rather that you edit the package to make it work with your current ghc.
15:15:02 <Eduard_Munteanu> Depends on your definition of functional... many functional languages are quite imperative wrt purity.
15:15:09 <Eduard_Munteanu> -ish
15:15:09 <dcoutts_> topi`: you'd use cabal unpack to get the source, remove the dependency on haskell98 and then build. That may be enough, or may have to fix a couple imports after that.
15:15:51 <Eduard_Munteanu> In fact it's only valid for a few selected FP languages like Haskell.
15:17:01 <kau> monochrom: yeah I think so
15:17:43 <Eduard_Munteanu> *select
15:17:52 <topi`> dcoutts_: thanks
15:18:23 * monochrom becomes naughty. s/select/epoll . "it's only valid for a few epoll FP languages" hehehe
15:19:05 * Hodapp throws a crispbread at monochrom
15:19:51 <Hodapp> Eduard_Munteanu: what do you mean, imperative with respect to purity?
15:19:58 <monochrom> optparse-applicative has an omission. maybe I should improve it and send a patch
15:20:27 <troydm> monochrom: it's not maybe, contribute for greater good!
15:21:47 <monochrom> here is the omission. suppose I want the command line to be "whee number1 number2 ...". so, a case of calling up "arguments" in optparse-applicative
15:22:03 <Eduard_Munteanu> Hodapp: take lisps for example, they still do IO quite imperatively
15:22:25 <Eduard_Munteanu> Hodapp: not only IO but mutation generally
15:22:39 <Hodapp> yeah, most Lisps don't care a lick about side effects
15:23:00 <augur> i wonder if richer types can make parallelism easier to get implicitly. like, if you know you have some associative widgets because the types enforce it, you can parallelize implicitly, etc.
15:23:16 <monochrom> the first problem: it only allows me to specify a "String -> Maybe a". therefore, I cannot give an informative error message when it's Nothing
15:23:19 <Peaker> I don't think putting Common Lisp (as an example Lisp) and Haskell in the same category ("Functional") makes any sense. I think Common Lisp should be in the same category as Python
15:23:57 <Peaker> monochrom: informative error message? pfft. What's that?
15:24:00 <Eduard_Munteanu> @quote kmc.*functional
15:24:00 <lambdabot> No quotes match. I don't think I can be your friend on Facebook anymore.
15:24:21 <Hodapp> augur: Did you read the MS Research paper on Generalized Stream Fusion?
15:24:30 <Peaker> "Functional" doesn't mean much. "Purely functional" might mean something
15:24:37 <augur> Hodapp: no
15:24:39 <yitz> Peaker: cl is very unlike haskell, but also very unlike python
15:24:49 <Hodapp> augur: https://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/haskell-beats-C.pdf
15:25:03 <Eduard_Munteanu> Peaker: well, the quote I was looking for goes like "oh, a functional language has such and such" yields a conclusion that said language can only be Haskell :)
15:25:04 <augur> Hodapp: ill check it out
15:25:26 <Peaker> yitz: why very unlike Python? except for the syntax difference and the macros it enables, it's quite similar IMO
15:25:42 <monochrom> the second problem: the usage message does not allow me to insert the part about "number1 number2 ..."
15:26:10 <MorphinTime> augur, do you happen to know something about CPS and non strict semantics?
15:26:25 <Peaker> Eduard_Munteanu: because only Haskell is really in a separate category from the imperative "functional" languages (IMO)
15:27:20 <augur> MorphinTime: not especially, why
15:27:25 <Eduard_Munteanu> Yeah, it's a bit sad there's only one usable language in that category.
15:29:15 <yitz> Peaker: macros are a central defining feature of cl. nothing at all like that in python.
15:29:24 <edwardk_> well, ermine is over there in the corner hanging out, too. agda to a lesser degree as well ;)
15:29:40 <c_wraith> what about Clean?
15:30:11 <Eduard_Munteanu> All these have almost no programming ecosystem around them, AFAICT
15:30:29 <c_wraith> yeah, Haskell is the only one with a bunch of use
15:30:44 <c_wraith> I was more asking if Clean belonged in that category, though.  I think it does.
15:30:50 <Eduard_Munteanu> I think that's how edwardk_ justifies his efforts being targeted at Haskell rather than Agda. :)
15:30:56 <yogurt_truck> miranda!
15:31:03 <yogurt_truck> :)
15:31:06 <Eduard_Munteanu> (e.g. "I can run my code")
15:31:07 <Peaker> yitz: sure, that's a significant difference (along with the syntax required), but the rest of the language is very similar, other than the lisp-2 horribleness :)
15:31:08 <watermind> Peaker: by imperative you mean effectful right?
15:31:14 <MorphinTime> augur, because I wonder why every non strict language seems to be implemted with graph reduction rather than CPS, I wondet what the obvious advantage it
15:31:14 <MorphinTime> it seems reasonable for me to be able to CPS with thunks
15:31:14 <MorphinTime> I might ask over in #scheme though, maybe they knoow more of this issue
15:31:28 <Peaker> edwardk_: what is ermine used for? How old is it?
15:31:54 <augur> MorphinTime: im not the right guy to ask about implementations
15:32:45 <watermind> MorphinTime: what other non-strict languages are you thinking about, if you don't mind me asking?
15:33:12 <c_wraith> MorphinTime: there are cases involving sharing where it's not at all clear how to implement them without a bunch of redundant calculation when CPS-encoded
15:33:20 <MorphinTime> augur, no one seems to be, I had hoped people knew the answer to this here
15:33:56 <edwardk_> Peaker: we use it for financial reporting mostly.
15:34:07 <MorphinTime> watermind, mostly other implementations of haskell
15:34:07 <MorphinTime> c_wraith, you can't graph share in CPS any more?
15:34:07 <c_wraith> MorphinTime: This is actually a key issue in design of many libraries.  It's often the case that neither the CPS version nor the datatype version is faster in all cases, and both stick around
15:34:18 <edwardk_> Peaker: https://www.youtube.com/watch?v=o3m2NkusI9k
15:34:30 <c_wraith> MorphinTime: consider [] vs DList, for instance
15:34:39 <watermind> MorphinTime: right, I was wondering if there were some new non-strict languages on the horizon
15:34:40 <Peaker> edwardk_: cool, we're wondering if we could work with ermine as a backend for Lamdu (type checking + inference, etc)
15:34:47 <edwardk_> Peaker: it has been a fairly slow-burning background project here for a couple of years
15:36:13 <MorphinTime> c_wraith, with CPS version you mean the tail recursive version here?
15:36:13 <MorphinTime> Because that's not entirely what I mean, I believe you can still express things like infinite streams in CPS
15:36:26 <Peaker> edwardk_: does ermine have usable APIs or just a CLI/compiler?
15:36:59 <Peaker> edwardk_: and can the type checking/inference be done incrementally? i.e: Type-check an expression with holes, get types on AST, then add information (e.g: set hole value or type) and continue type inference?
15:37:34 <Peaker> edwardk_: sorry if this isn't a good time to be pestering you :)
15:37:40 <c_wraith> MorphinTime: No, not at all. really mean things like DList, which use ([] -> []) as a representation, rather than [].  It makes some operations asymptotically faster - but it makes other asymptotically slower.
15:38:07 <c_wraith> MorphinTime: or in the free package, the Free type vs the F type.
15:39:06 <MorphinTime> DList is something else than a doubly linked list?
15:39:17 <simpson> It's a difference list.
15:39:52 <MorphinTime> c_wraith, how is a module implemented in CPS or not, an implementation is right?
15:39:53 <MorphinTime> As far as I know, Haskell's type system stops a general rewrite of entire code to CPS form
15:40:23 <c_wraith> MorphinTime: you can still choose to represent an abstraction with either a data type with multiple constructors or as a function.
15:40:35 <MorphinTime> Ahhh
15:40:40 <c_wraith> MorphinTime: and you can implement the same api for either interface
15:40:52 <c_wraith> err, for either *implementation
15:41:17 <MorphinTime> Ohh, in that way
15:41:48 <Cale> MorphinTime: Here's the trick. The usual list append, xs ++ ys takes O(length ys) steps to fully evaluate. This often results in asymptotically unfortunate runtimes.
15:41:48 <c_wraith> so you can always have the choice of CPSing your data structures or not, with the current implementation
15:41:59 <MorphinTime> But I still don' see wht that has to do with implementing lazy evalation in a compler in terms of the CPS strategy
15:42:03 <Cale> So instead of working with lists, you can work with functions which add elements to the beginning of a list
15:42:25 <Cale> i.e. you replace the type [a] with the type [a] -> [a], as c_wraith referred to
15:42:37 <Cale> and you replace the empty list [] with id
15:42:48 <Cale> and the singleton list [x] with (x:)
15:42:50 <c_wraith> It was just intended as an analogy - CPS just makes different tradeoffs, as seen in these cases.
15:42:54 <Cale> and (++) with (.)
15:43:20 <Cale> Since composition of functions is constant time, this can help performance a good deal!
15:43:24 <c_wraith> It's not better or worse - so you generally want an implementation strategy that allows either
15:43:44 <Cale> For example, consider this tree type:
15:43:56 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
15:44:06 <Cale> We could write an inorder traversal like:
15:44:12 <Cale> inorder Tip = []
15:44:24 <Cale> inorder (Branch x l r) = inorder l ++ [x] ++ inorder r
15:44:30 <c_wraith> and since Haskell has an implementation that allows both arbitrary functions and graph reduction, you can choose whether to represent your data with functions or graph-reduced values.
15:44:36 <Cale> However, this is worst case quadratic time
15:44:51 <MorphinTime> c_wraith, ah yes, I see, I was a bit confused.
15:45:14 <Cale> So, to improve its performance, we could write this instead:
15:45:21 <Cale> inorder' Tip = id
15:45:32 <Cale> inorder' (Branch x l r) = inorder' l . (x:) . inorder' r
15:45:35 <Cale> and then
15:45:41 <Cale> inorder t = inorder' t []
15:45:48 <Cale> and that's linear time
15:46:12 <Cale> DList just captures that trick into an explicit data type
15:46:20 <MorphinTime> I am still a bit confused as to how this relates though
15:46:53 <Cale> (I'd actually rarely ever use the DList library, it's mostly just useful for the instance of Monoid if you need it)
15:47:02 <MorphinTime> But basially what I'm gathering is tha there is no theoretical reason stoping you from using CPS in non strict languages, it's a tradeof?
15:47:03 <MorphinTime> Well, I know how difference lists work
15:47:25 <Cale> okay
15:47:46 <Cale> I suppose I should go back and figure out what your actual question is :D
15:48:31 <MorphinTime> Cale, if there is a theoretical prohibation to implement lazy evaluation using the CPS strategy.
15:48:57 <watermind> Cale: interesting, basically it's amounts to doing the usual optimization using an accumulator, to obtain linear order, but abstracting over the accumulator
15:49:13 <MorphinTime> As in, does CPS stop some part of lazy evaluation / non strict semantcs because it's not extremely apparent to me right now
15:49:17 <Cale> watermind: Yeah, it's a better way of thinking about the same
15:49:22 <watermind> Cale: but while that works for constructing the datatype, how do you inspect it?
15:49:24 <Hodapp> what is CPS?
15:49:34 <Cale> watermind: By applying the function to an empty list
15:49:35 <watermind> Cale: it seems like you'd have to realise as a list
15:49:57 <Cale> Hodapp: Continuation passing style
15:50:02 <alexander__b> I have a couple of weeks to figure out a topic and write a paper. any ideas on something that would benefit the haskell community? I was initially thinking of discussing source code quality metrics, and which ones apply cross-paradigm (so denotative/declarative pure functional and imperative oop being the paradigms)
15:50:51 <watermind> Cale: right, doesn't this make access worse if you're using an abstract data type? you always need to reconstruct the list, and you also seem to lose sharing... am I right?
15:51:10 <Cale> MorphinTime: Lazy evaluation only implies two things: that the order of evaluation is outermost-first, and that any evaluation done to a bound variable (or specifically function parameter) is shared between the occurrences of that variable in its scope.
15:51:28 <c_wraith> watermind: you are right.  That's the downside.  concatenation is faster.  access is slower.
15:51:37 <watermind> c_wraith: right, interesting
15:52:48 <MorphinTime> Cale, that last thing is a complicated way of saying call by name?
15:53:04 <monochrom> no, call by name lacks sharing
15:53:11 <Cale> MorphinTime: I can never remember what call by name means, personally.
15:53:27 <c_wraith> call-by-need is lazy evaluation
15:53:30 <monochrom> call by name is a complicated way to say lazy but don't share :)
15:53:30 <MorphinTime> Cale, let me ask you this then, is it possible to write a conformant haskell implementation which implements its non strict semantics using CPS, with lazy evaluation or not
15:53:49 <Cale> I don't see why not.
15:53:57 <c_wraith> Haskell's spec doesn't require laziness.  Just non-strictness
15:54:16 <Cale> Anything which implements nonstrict semantics, including plain outermost-first evaluation will satisfy the requirements of the Report.
15:54:17 <MorphinTime> Cale, call it capture-avoiding substitution evaluation
15:54:59 <MorphinTime> As in, the evaluation strategy is to insert the entire code into the function body in an hygienic way.
15:54:59 <MorphinTime> Cale, I know, I want to know if that can be done with CPS nad if not why not
15:55:00 <Cale> (I prefer to use terms which describe the evaluation order, since in my head I'm always going to think of everything in terms of expression rewriting)
15:56:59 <Cale> MorphinTime: Of course it can?
15:57:24 <Cale> Given an evaluation order, you can CPS transform anything.
15:57:52 <MorphinTime> Excellent, that is what I wanted to know
15:57:52 <MorphinTime> if there was some theoretical limitation
15:57:52 <MorphinTime> Okay, so te reason no Haskell implementation uses it is some tradeof, not a theoretical limitation
15:57:52 <MorphinTime> I was wondering if CPS might force strictness i some case I hadn't considered
15:58:34 <MorphinTime> Yes, I had that idea, so the reason no Haskell compiler uses this is ...?
15:58:34 <MorphinTime> Because I see no reason not to use it, I wonder what te caveat t
15:58:42 <Cale> I'm not sure what CPS transforming the code would actually buy you
15:58:50 <Cale> There's already no call stack
15:58:59 <edwardk> cps transform all the things
16:00:03 <MorphinTime> Cale, GHC has a call stack right?
16:00:10 <Cale> (Well, nothing that someone writing Haskell code should think of as a call stack anyway -- Simon Marlow might still think of it as a call stack)
16:00:27 <Cale> MorphinTime: No, it doesn't.
16:00:54 <Cale> It uses its stack for pattern matches which are waiting for their scrutinee to be sufficiently evaluated to match.
16:02:12 <Cale> So, in some intermediate language, you can think of the stack as basically consisting of pending case expressions.
16:03:08 <Cale> (once all the other forms of pattern matching and strictness get rewritten into case expressions)
16:03:18 <piezoid> hi, is there a .cabal/config flag equivalent to Setup haddock --hoogle ?
16:03:38 <MorphinTime> Cale, GHC can stack overflow right?
16:03:42 <Cale> MorphinTime: yes
16:04:00 <Cale> MorphinTime: But it's not because of too many function applications, it's because of too many waiting pattern matches.
16:04:32 <Cale> (it's not a call stack that's overflowing)
16:06:31 <MorphinTime> Ahh, I see, hmm
16:06:35 <monochrom> I know how to eliminate the stack cost by increase the time cost
16:07:13 <MorphinTime> I have no idea how someting like that would be implemented
16:07:13 <MorphinTime> So like, pattern matches are implemented in a special way
16:07:25 <Cale> Well, for example, let's look at foldl
16:07:27 <Cale> :t foldl
16:07:28 <lambdabot> (a -> b -> a) -> a -> [b] -> a
16:07:33 <Cale> @src foldl
16:07:33 <lambdabot> foldl f z []     = z
16:07:33 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:07:47 <Cale> foldl (+) 0 [1,2,3]
16:07:55 <MorphinTime> Like func 0 = ...; func n = ... ; actually generates different code than doing it with if ... then ... else?
16:07:56 <Cale> -> foldl (+) (0 + 1) [2,3]
16:08:04 <Cale> -> foldl (+) ((0 + 1) + 2) [3]
16:08:13 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
16:09:09 <Cale> Up to this point, foldl hasn't needed any stack space (or maybe one slot for pattern matching the list, though the way we've written things here, the list is already in the right form to be pattern matched on)
16:09:20 <Cale> But now...
16:09:28 <Cale> -> ((0 + 1) + 2) + 3
16:09:47 <Cale> (+) can't produce any part of its result without pattern matching both its arguments
16:10:26 <Cale> So, the pattern match inside the outermost (+) goes on the stack
16:10:35 <Cale> and we evaluate (0 + 1) + 2
16:10:47 <Cale> and then the same thing happens and we evaluate (0 + 1)
16:11:09 <Cale> and then finally that succeeds, evaluating to 1, and then 1 + 2 is evaluated to 3 and finally 3 + 3 evaluates to 6
16:11:34 <Cale> That might not be the *best* example, because the pattern matching which is going on is internal to (+)
16:12:14 <Cale> But foldl (+) 0 [1..10000000] can blow the stack, for this reason
16:12:37 <Cale> It's not really the fault of foldl, it's (+) that's using the stack
16:13:12 <Cale> But foldl is what makes the big expression in the first place, so modifying foldl to introduce a bit of additional strictness can help avoid the stack usage.
16:13:37 <Cale> (In fact, GHC is smart enough to do this automatically if optimisations are turned on)
16:13:43 <Cale> @src foldl'
16:13:43 <lambdabot> foldl' f a []     = a
16:13:43 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
16:14:00 <piezoid> so even "f a b = ..." is a pattern match ?
16:14:29 <Cale> piezoid: Only matching against constructors counts for this (or bang patterns)
16:15:20 <Cale> piezoid: Or if you prefer, you can imagine that the simple irrefutable patterns use a place on the stack momentarily, but any expression will be evaluated enough already to match one of those.
16:15:51 <MorphinTime> Cale, so this is beause (+) is a binary function behind the screens?
16:15:52 <Cale> (so it won't be there for long, even so)
16:15:57 <piezoid> isn't 1 + 2 the same than f 1 2 ?
16:16:09 <Cale> piezoid: it is, where f = (+)
16:16:34 <MorphinTime> Cale, hmm, say you have a lazy language with variadic functions, a lazy lisp say
16:16:38 <MorphinTime> There this story no longer holds rigt?
16:16:40 <Cale> MorphinTime: It's because (+) is strict -- it can't produce any result without pattern matching on both arguments
16:16:51 <Cale> It has nothing to do with the number of parameters
16:17:08 <Cale> > iterate (\x -> x + 1) 0 !! 10000000
16:17:13 <lambdabot>   mueval: ExitFailure 1
16:17:13 <lambdabot>  mueval: Prelude.undefined
16:17:15 <Cale> > iterate (\x -> x + 1) 0 !! 1000000
16:17:17 <lambdabot>   *Exception: stack overflow
16:17:20 <Cale> There we go
16:17:20 <MorphinTime> It relies on th idea that all functions have a constant amount of arguments?
16:17:30 <Cale> ... not so far as I'm aware
16:17:48 <Cale> That's just things being well-typed
16:18:08 <Cale> (Though polymorphic things can take arbitrary numbers of arguments)
16:18:09 <quchen> Is there a common function that likes to associate to the left computationally? Like (++) likes to be right-associated?
16:18:30 <Cale> (-) is infixl
16:18:48 <Cale> Or do you mean something more specific by "likes to be"
16:18:50 <raphie_> is there a special kind of map that will let me apply the function to n list elements?
16:18:53 <quchen> Cale: Woops, forgot mentioning that the function should be associative in the mathematical sense
16:19:20 <quchen> (++) is associative, but computationally right-associative as it makes calculating it much easier
16:19:22 <Cale> raphie_: No, but you could write one.
16:19:29 <raphie_> as in: exampleFn (+) 2 [1, 2, 3, 4] -> [3, 7]
16:19:47 <Cale> Oh, that's not even what I was thinking.
16:20:08 <raphie_> yeah code is clearer than English :) any idea?
16:20:32 <Cale> > chunksOf 2 [1,2,3,4,5,6,7]
16:20:33 <lambdabot>   [[1,2],[3,4],[5,6],[7]]
16:20:39 <Cale> > map sum . chunksOf 2 $ [1,2,3,4,5,6,7]
16:20:40 <lambdabot>   [3,7,11,7]
16:20:40 <raphie_> perfect
16:20:53 <Cale> I believe chunksOf is from Data.List.Split
16:20:59 <Cale> which is from the split package on Hackage
16:21:12 <quchen> Cale: It's also in the Platform as of 1-2 releases ago
16:21:22 <quchen> So most people have it by default
16:21:37 <Cale> Most people actually have a complete copy of the Platform? :O
16:21:48 <quchen> I would think so, yes
16:22:09 <Cale> (I just download GHC and then install cabal-install, followed by whatever else I happen to need as it arises)
16:22:41 <quchen> I have this script that I pipe into Bash that installs everything and then some. Reinstall everything in a coffee break.
16:22:59 <Cale> y u pipe into bash?
16:23:39 <Cale> actually, I do that often enough myself, but not with pre-written scripts
16:23:39 <quchen> Mostly so I can run "runhaskell reinstall.hs" and see whether the output isn't a runtime error, and then use "runhaskell reinstall.hs | bash".
16:23:46 <Cale> ah, okay
16:23:53 <Cale> yeah
16:24:12 <quchen> I've seen those posts about piping to your shell recently
16:24:17 <m_m> Hi. I am searching a new programming language to learn (in work I've mostly python and php). So something fresh and new will be a right choice. Can you tell my why i should choose haskell ? I like the functional way of programming.
16:24:30 <MorphinTime> Cale, hmm, so say I have f x y z = 3
16:24:30 <MorphinTime> Even though f takes 3 arguments the story does not apply right?
16:24:46 <Maior> m_m: http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html
16:25:20 <quchen> m_m: Haskell is certainly one of the more radical functional programming languages: it makes very few compromises. Most other languages have some sort of non-functional elements.
16:25:34 <Maior> I still don't understand how IO works in OCaml
16:25:39 <Maior> but anyway, that's OT, sorry
16:25:40 <quchen> Haskell, where even mutable values are immutable
16:26:19 <m_m> It is mostly for academical use ? Or for commercial too ?
16:26:26 <quchen> @quote Jafet research
16:26:26 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatics, phone apps, and web services.
16:26:38 <hpc> Maior: welcome to #haskell, where the IO monad is off topic
16:26:53 <Maior> hpc: can't quite tell if joking or not...
16:27:10 <quchen> To be fair there's no IO *Monad* in OCaml.
16:27:30 <quchen> m_m: You can (and people do) write real-world programs in Haskell.
16:27:59 <Maior> m_m: lots of commercial stuff
16:28:54 <quchen> Cale: Why "y u pipe into bash"? Was that to imply silliness?
16:29:06 <m_m> I see that Haskell have a lot of web frameworks.  Is there anything like Django for Python or Rails for ruby ?
16:29:28 <quchen> m_m: I think there are three big ones: Yesod, Happstack, Snap.
16:29:39 <quchen> And then a couple of smaller ones. (Scotty?)
16:30:41 <quchen> m_m: Few people learn Haskell for its web frameworks though. I learned it because I found it interesting, and as it turns out it is also useful (but that wasn't what got me started).
16:31:45 <Cale> MorphinTime: right, evaluating any application of that function would use essentially no stack space, because there's no matching to be done, it can just produce the result 3 immediately.
16:32:01 <chrisdone> quchen: http://www.reactiongifs.com/wp-content/uploads/2013/01/happy-twins.gif
16:32:32 <quchen> For me this is probably a distinguishing feature of Haskell: the language itself is interesting. (That doesn't mean it's a never-ending journey. You can be proficient in Haskell without "sudying the interesting parts".)
16:32:48 <quchen> chrisdone: ooookaayy....
16:32:58 <quchen> Whatever that means
16:33:46 <quchen> "Program won't work? Let's learn about using Profunctor!" :-D
16:33:51 <MorphinTime> Cale, it still has to remember its call site in some way no?
16:33:51 <MorphinTime> Remember where to return to?
16:33:51 <MorphinTime> Or is this your ggresive inlining?
16:34:04 <Cale> MorphinTime: Nope, there's nothing to return to.
16:34:22 <Cale> MorphinTime: Well, there will be something pattern matching against the expression, and that's where we need to return
16:34:46 <Cale> (all evaluation happens ultimately because something is pattern matching)
16:35:41 <Cale> (Even if that thing is some function for turning the data into a string to be displayed on the screen)
16:35:47 <raphie_> does anyone know of a round-to-a-decimal-place function?
16:35:53 <raphie_> round only takes integers
16:35:56 <raphie_> er, spits out integers
16:35:59 <madjestic> is there an example of drawing 2 triangles, using modern opengl (vertex/fragment shaders)?  I have difficulties understanding how to draw 2 vertex arrays, as opposed to a single one, as in all haskell examples that I can find, or examples rely on fixed opengl pipline
16:36:01 <Cale> MorphinTime: Remember that evaluation is outermost-first
16:36:02 <MorphinTime> I have the feeling haskell is implemented in ways I never thought possible
16:36:24 <raphie_> and I'd like to be able to put in, say, roundF 10.005 2 -> 10.01
16:36:27 <Cale> Probably!
16:36:44 <MorphinTime> Oh yeah gotcha
16:36:45 <MorphinTime> I honestly have no clue how to compile outer-most first evaluation to anything
16:37:02 <MorphinTime> Just wrap it in thunks all day everyday?
16:37:41 <monochrom> raphie_: as a first attempt, I would multiply by 100, round, dividing by 100
16:38:19 <Cale> MorphinTime: Thunks are involved, for sure.
16:39:43 <Cale> MorphinTime: All variables are pointers to code. The first time that code is entered, the value is computed and the pointer is rewritten to point at a shorter piece of code which produces the result immediately. The reason that you enter one of these pointers is to decide which constructor it is, for the purposes of deciding which branch of a case to go down.
16:39:43 <liyang> raphie_: perhaps you want to keep your numbers in units of 0.01, rather than using a floating point representation.
16:40:40 <radish> if i want to create a copy of a record with a single change, what's the best method for that?
16:40:43 <Cale> MorphinTime: http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
16:40:52 <raphie_> liyang: this specific problem I'm solving wants me to round
16:41:13 <raphie_> monochrom: that solution does 10.006 -> 10.01 but 10.005 -> 10.00
16:41:48 <radish> data Box = Box ox oy sz
16:41:57 <enthropy> > fromIntegral (round (10.005 * 1000)) / 1000
16:41:58 <lambdabot>   10.005
16:41:59 <Cale> MorphinTime: That'll give you a pretty good low-level idea of what's going on. Though, it's no longer tagless, they reintroduced pointer tagging for small types where it's possible to decide which constructor the thing evaluated to by examining the pointer tag.
16:42:05 <enthropy> > fromIntegral (round (10.005 * 100)) / 100
16:42:06 <lambdabot>   10.01
16:42:30 <enthropy> raphie_: how did you get "10.005 -> 10.00"?
16:42:31 <monochrom> raphie_: it also does 10.015 -> 10.02. look up "round to even"
16:42:38 <Cale> (i.e. with maximum 3 constructors on 32-bit and maximum 7 constructors on 64 bit)
16:42:43 <radish> i want to fn box = Box ox (oy +1) sz
16:43:20 <raphie_> > let myRound f = (fromIntegral $ round $ 100 * f) / 100 in f 10.005
16:43:21 <lambdabot>   Could not deduce (Debug.SimpleReflect.Expr.FromExpr t)
16:43:22 <lambdabot>    arising from the ...
16:43:34 <raphie_> er
16:43:37 <raphie_> > let myRound f = (fromIntegral $ round $ 100 * f) / 100 in myRound 10.005
16:43:39 <lambdabot>   10.01
16:43:42 <Cale> Also, maybe it's no longer spineless either? I don't recall the details there as well as the situation for tags.
16:43:54 <Cale> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.19.411&rep=rep1&type=pdf
16:44:22 <raphie_> that is so weird! in my ghci it spits out 10.0
16:44:34 <MorphinTime> Cale, tag is this case is anothe word for essentially dynamic type I take it?
16:44:54 <monochrom> I once gave out a programming contest problem specifying "round to even". it revealed widespread ignorance of the contestant. they all wrote elaborate handwritten code to round to even, not knowing that the IEEE754-compliant platform already does it for free.
16:45:52 <Cale> MorphinTime: Tag as in using the low-order bits of pointers to encode a few bits of additional information.
16:46:19 <Cale> (because memory is aligned to multiples of 4 or 8 anyway)
16:46:28 <chrisdone> SBCL does tagging like this too
16:46:32 <monochrom> > map round [1.5, 2.5, 3.5, 4.5]
16:46:33 <lambdabot>   [2,2,4,4]
16:46:52 <chrisdone> monochrom: lol
16:47:43 <chrisdone> why does round produce those values? seems like it favors even values
16:47:50 <Cale> It does
16:47:57 <Cale> Intentionally
16:48:02 <monochrom> because Knuth recommends round-to-even
16:48:17 <chrisdone> monochrom: i see
16:48:21 <Cale> If you always round up or always round down, then you bias your data
16:48:21 <simon> "unbiased rounding"
16:48:22 <chrisdone> why?
16:48:40 <chrisdone> ah
16:48:42 <monochrom> the Goldberg "what everyone should know about floating point" article may also have it
16:48:48 <Cale> Rounding to even means that you expect to round up and down about half the time, unless your data is inherently number theoretical
16:50:16 <monochrom> http://floating-point-gui.de/errors/rounding/
16:51:17 <chrisdone> banker's rounding
16:51:30 <monochrom> http://en.wikipedia.org/wiki/Rounding#Stochastic_rounding
16:51:53 <monochrom> someone should implement stochastic rounding for Haskell using unsafePerformIO!
16:52:33 <monochrom> ooohhh! alternating tie-breaking looks more interesting!
16:52:52 <chrisdone> q = unsafePerformIO (return (-0.5)) -- decided by random dice roll
16:53:10 * pharaun wants infinite decimials
16:54:07 <chrisdone> pharaun: i suppose if you keep your system in Rational you can have that
16:54:17 <quchen> monochrom: There's a large difference between stochastic rounding and arbitrary demonic rounding :-√æ
16:54:27 <pharaun> chrisdone: i know :) i quite like Rational for most stuff
16:54:33 <arkeet> round whichever way gives me more profit.
16:54:51 <pharaun> arkeet: s/me/pharaun/
16:55:20 <Hodapp> arkeet: umm, could we have this same algorithm (in terms of its effects), but write it in a way that blames the person that is losing?
16:55:25 <arkeet> I wonder if anyone in canada goes to the trouble of paying cash for things that get rounded down to the nearest 5 cents, and electronically for things that would get rounded up
16:55:28 <mgsloan> > showCReal 100 $ pi ** pi
16:55:29 <lambdabot>   "36.46215960720791177099082602269212366636550840222881873870933592293407436...
16:55:53 <mgsloan> (Not that I'm recommending you use those)
16:56:06 <monochrom> arkeet: I stochastically choose between cash and credit card. does that count? :)
16:56:25 <arkeet> no, because that's unbiased I think.
16:57:05 <quchen> having P(cash) = 0 is still stochastic, but degenerate.
16:57:20 <kenkku> does anyone know how to get a hold of the raw text of a http-conduit request?
16:57:24 <quchen> Also it's very biased. And it doesn't mean that you never pay cash either.
16:57:30 <Cale> arkeet: The cost of worrying about it is probably worth more than you'd ever make
16:57:33 <quchen> Let's stop paying and rounding now. :-√æ
16:57:42 <arkeet> Cale: that was my conclusion as well.
16:57:51 <monochrom> when I pay cash, the coins I use are unbiased. (pun!)
16:57:58 <arkeet> so I never personally did it.
16:58:13 <chrisdone> ‚ÄúLook after the pennies, and the pounds will take care of themselves.‚Äù
16:58:23 <arkeet> "Time is money."
16:58:25 <quchen> monochrom: Silly fact, most coins are slightly biased because of the patterns on each side
16:58:36 <chrisdone> ‚ÄúFrance is bacon.‚Äù
16:58:41 <Cale> Pennies are worthless. In fact, I wish they'd get rid of the nickel and dime too.
16:58:55 <chrisdone> Cale: worthless in which currency?
16:59:05 <quchen> Cale: They could at least print their value on the coin.
16:59:13 <chrisdone> you can get a pack of sweets in the uk for 20p
16:59:17 <arkeet> quchen: they do.
16:59:22 <kenkku> chrisdone: but what can you get for a penny?
16:59:26 <monochrom> "I/O is the nickels and dimes of programming. get rid of the nickels and dimes"
16:59:30 <Cale> chrisdone: Well, I'm thinking of Canadian dollars
16:59:37 <chrisdone> kenkku: 1p sweets =p
16:59:42 <quchen> arkeet: "United states of America in God we trust by the way this is twenty-five cents" doesn't count :-(
16:59:50 <arkeet> quchen: I'm talking about Canada.
16:59:52 <kenkku> chrisdone: and does someone actually sell those? ;P
16:59:56 <quchen> arkeet: Oh.
16:59:58 <Cale> chrisdone: You practically can't get anything here for less than a dollar anymore.
17:00:08 <Hodapp> Tin of sardines.
17:00:11 <scott_> arkeet: I've chosen my method of payment based on thatÖ but I usually don't have any cash
17:00:12 <chrisdone> kenkku: these days they're more like 2p, sadly. Back In My Day, most shops sold 1p sweets
17:00:22 <kenkku> ha
17:00:27 <scott_> arkeet: Err, I was a bit scrolled up, I guess you said that a while back
17:00:28 <kenkku> the good ole Back In My Day
17:00:55 <quchen> I heard in Finland they mostly have round prices, and there are very few copper coins in circulation.
17:00:58 <chrisdone> Cale: ah, i see
17:01:00 <quchen> Finland must be nice.
17:01:02 <monochrom> but you can still pay sales tax less than a dollar. I just did yesterday. $5 DVD, $0.64 tax. (I paid cash)
17:01:04 <carter> khyperia: you should also now practice using cabal sandboxes
17:01:09 <kenkku> quchen: we don't use 1 and 2 cent coins
17:01:26 <chrisdone> oh, interesting
17:01:26 <monochrom> (but I confess that last week, I paid $5.64 by credit card several times)
17:01:27 <quchen> kenkku: But 5s? Hm. At least a start.
17:01:27 <kenkku> all cash transactions are rounded to 5 cents
17:01:35 <chrisdone> nice
17:01:37 <arkeet> for anyone not familiar with canadian currency, the 1 cent coin is no longer distributed, and cash transactions are ‚Üë
17:01:42 <kenkku> it's not just finland
17:01:50 <kenkku> but many countries do still use 1 and 2 cent coins
17:01:56 <chrisdone> frankly i don't really care about change ranging below, say, 20 cents
17:02:10 <kenkku> from what I've heard and seen, they tend to gather in your wallet in large amounts :P
17:02:27 <Cale> If they decided to do away with everything less than 1 dollar, I would be okay with it.
17:02:32 <quchen> kenkku: Not if you periodically dump them in some box.
17:02:49 <quchen> And when the box is very very heavy you take it to the bank. On the way there you complain how heavy the box is.
17:02:52 <quchen> And how nice Finland must be :-D
17:02:54 <monochrom> do away with everything less than 1 btc.
17:03:02 <pharaun> arkeet: i always found that odd
17:03:08 <arkeet> which?
17:03:11 <chrisdone> Cale: so you can't buy things for like $1.50? it's always rounded to 1 dollar?
17:03:16 <pharaun> rounding up (re 1 cent thing)
17:03:22 <Cale> chrisdone: 1 or 2
17:03:24 <kenkku> quchen: nice, only children do that here - and not with 1&2c coins, of course ;)
17:03:25 <pharaun> why not just have it random up/down
17:03:35 <arkeet> because that requires randomness
17:03:45 <spaceships> i would love to see the end of things that cost 1 cent below a whole number :P
17:03:45 <chrisdone> Cale: nod, i can see why that'd just be easier to have a dollar be the lowest denomination
17:03:47 <kenkku> but I guess adults need a reason to use a piggy bank too
17:03:55 <quchen> kenkku: When your buttcheek hurts because you have a lump of copper in your back pocket it's time to get a box.
17:04:16 <kenkku> this is precisely why I like to use a card :P
17:04:23 <Hodapp> spaceships: It's only $1,999.99!
17:04:23 <quchen> kenkku: Alternatively you can pay cash with copper. You need to be tough to do that, people can build up a lot of hate in the line behind you.
17:04:23 * arkeet recently moved from canada to USA and misses not carrying pennies around everywhere.
17:04:28 <monochrom> pharaun: did you see my <monochrom> someone should implement stochastic rounding for Haskell using unsafePerformIO!
17:04:28 <mgsloan> So does this mean that penny stocks would be rounded up to $1?
17:04:34 <chrisdone> it's true that where i live in italy i don't remember buying anything for less than a euro
17:04:35 <Cale> monochrom: Doing away with everything less than 1 BTC would be pretty severe!
17:04:40 <mgsloan> Please let me know when the centless regime is going to be imposed :)
17:04:42 <Cale> At least, for now it would.
17:04:42 <kenkku> especially now that there's contactless payments (cue tinfoil hats appearing now)
17:05:24 <raphie_> oh god I just finished my first real haskell program and it ran perfectly on the first try this is true bliss
17:05:34 <raphie_> well, first try after I fixed all the compiler errors
17:05:37 <chrisdone> Another happy customer!
17:05:41 <pharaun> monochrom: haha i didnt, :p
17:05:42 <kenkku> raphie_: that's cheating!
17:05:42 <Cale> If you only had very large denominations of currency, it would make trading for small things a bit interesting. I guess people would make longer-term deals to have the little things they wanted.
17:05:50 <kenkku> raphie_: it should compile on the first try
17:06:07 <raphie_> kenkku: I'm not quite ninja-level yet :)
17:06:10 <kenkku> if something I wrote compiled on the first try, I'd probably think "that's weird, must be an error"
17:06:13 <quchen> For suitable definitions of "compile" and "first".
17:06:41 <monochrom> my program works the first time it works
17:06:43 <chrisdone> quchen: for definitional compilations of first suits
17:07:19 <monochrom>  <-- tautology generator
17:07:40 <quchen> monochrom, the Djinn for tautologies
17:07:41 <kenkku> a tautology generator generates tautologies
17:07:49 <quchen> @djinn a
17:07:50 <lambdabot> -- f cannot be realized.
17:07:51 <raphie_> well regardless of exact terminology, it was very refreshing to not have to play "let's track down the undefined value!" like I have to with JavaScript
17:07:55 <quchen> @monochrom a  -- gogo!
17:07:55 <lambdabot> Unknown command, try @list
17:08:15 <monochrom> people who like monochrom may also like: http://www.vex.net/~trebla/humour/tautologies.html
17:08:43 <chrisdone> Cale: it's funny, i was watching an American street performer video the other day. it struck me as odd that people kept coming over and putting paper in the guy's hat instead of coins. there was no metal hitting metal ringing sound. paper dollars =)
17:09:19 <chrisdone> ‚Äúdollar‚Äù‚Äîtinny word! POUND‚Ä¶ there's a good, woody, word!
17:09:25 <arkeet> I am sick of vending machines rejecting $1 bills. =(
17:09:46 <quchen> arkeet: Ha, and you think Euro coins are better?
17:09:50 <chrisdone> haha, putting paper in vending machines is always risky in the uk
17:09:59 <Cale> I disagree, "dollar" is woody as well.
17:10:06 <khyperia> I'm confused about how cabal -w works. Do I pass in the path to ghc.exe or the directory that it's in?
17:10:18 <monochrom> what is cabal -w?
17:10:20 <arkeet> I just noticed that this isn't -blah.
17:10:22 <chrisdone> the minimum you can put in is ¬£5, sometimes the machines eat it
17:10:23 <Cale> "rouble", now there's a woody word
17:10:46 <quchen> chrisdone: Runtime error, your money has been shredded. Please come again.
17:10:52 <monochrom> "rubble" is a rocky word :)
17:10:54 <khyperia> http://www.haskell.org/cabal/users-guide/installing-packages.html monochrom, search for "-w "
17:11:09 <dcoutts_> khyperia:  -w --with-compiler=PATH           give the path to a particular compiler
17:11:17 <khyperia> ah
17:11:28 <monochrom> "cabal configure --help"
17:11:30 <dcoutts_> khyperia: it's the full filepath, not just the dir
17:11:46 <chrisdone> ‚ÄúFunctor!‚Äù ‚ÄúLater, darling.‚Äù
17:12:25 <khyperia> "cannot find the program "ghc" at '--with-compiler=[...]' or on the path"
17:12:41 <quchen> khyperia: And you don't want to add GHC to $PATH?
17:12:56 <khyperia> Well, I have a haskell-platform version of ghc, and I have ghc HEAD
17:13:10 <khyperia> and I'm trying to get it to use the HEAD version without overwriting the platform one.
17:13:19 <quchen> I see.
17:14:00 <quchen> So what's the command you're using then? Could it be that your path parameter contains whitespace or something like that?
17:15:04 <khyperia> cabal install --only-dependencies -w --with-compiler=..\ghcHead\bin\ghc.exe
17:15:26 <geekosaur> mh
17:15:34 <arkeet> I wonder if those backslashes are causing problems.
17:15:41 <arkeet> try forward slashes, and an absolute path maybe?
17:15:50 <geekosaur> I also bet that doesn't absify the path if it changes directory
17:16:07 <dcoutts_> khyperia: -w is the short form of --with-compiler, you don't need to use both
17:16:24 <dcoutts_> khyperia: look at the output of --help, that's what I was copy'n'pasting from
17:16:28 <khyperia> ah
17:16:34 <haasn> so has anybody used ‚Äòotherwise‚Äô outside of a base-case condition?
17:16:37 <khyperia> and yep, I got something that works
17:16:46 <khyperia> I'll copy-paste it once console stops whizzing by
17:16:50 <quchen> haasn: I think that's the only idiomatic usecase.
17:17:16 <chrisdone> i've never used it outside, i don't think, no
17:17:42 <haasn> quchen: I was thinkings of situations in which ‚Äòotherwise‚Äô instead of ‚ÄòTrue‚Äô could make the code read better, other from the idiomatic one :)
17:17:52 <enthropy>  chooseMentor wise otherwise = ...
17:17:53 <khyperia> cabal install --only-dependencies -w C:/Users/___/Documents/ghcHead/bin/ghc.exe
17:19:02 <quchen> enthropy: That's a new "otherwise" though.
17:19:09 <quchen> One with an evil shadow.
17:19:55 <chrisdone> @src and
17:19:56 <lambdabot> and   =  foldr (&&) True
17:20:02 <chrisdone> and = foldr (&&) otherwise
17:20:03 <chrisdone> =p
17:20:22 <chrisdone> or maybe or is better
17:20:24 <chrisdone> @src or
17:20:24 <lambdabot> or    =  foldr (||) False
17:20:30 <chrisdone> or    =  foldr (||) otherwise
17:20:32 <chrisdone> =)
17:20:56 <chrisdone> nahh, it's pretty hard to use otherwise anywhere else
17:22:14 <arkeet> is it poor style to use True instead of otherwise in a guard?
17:23:06 <chrisdone> yeah
17:23:13 <arkeet> =(
17:23:29 <chrisdone> it's just not the normal way
17:23:34 <chrisdone> CONFORM
17:24:18 * chrisdone smacks arkeet with a conformity stick @ _@ /
17:25:49 <chrisdone> ocharles: yay http://ocharles.org.uk/blog/posts/2013-12-01-24-days-of-hackage-intro.html
17:32:46 <carter> ocharles: ooo
17:32:48 <carter> darn it
17:32:59 <carter> i'm not due for alpha till after xmas
17:34:26 <chrisdone> alpha?
17:35:02 <ReinH> chrisdone: is the conformity stick spikey?
17:35:13 <ReinH> It should be spikey
17:35:32 <ReinH> For maximal incentive to conform
17:37:13 <chrisdone> ReinH: some would say too spikey, even on the handle, which discourages use of the conformity stick. but they're not Real conformists
17:37:38 <chrisdone> ReinH: finished the simon marlow haskellcast while walking my pretend dog earlier this evening. good one! who's next?
17:40:29 <ReinH> chrisdone: dunno
17:41:00 <ReinH> chrisdone: someone on reddit said that my questions about "inheriting" monad behavior from applicative were "nonsensical"
17:41:22 <ReinH> They said "you can't define >>= from <*> so it doesn't make any sense"
17:41:27 <chrisdone> ReinH: those reddit people are mean
17:41:34 <ReinH> But... you CAN define it from fmap and pure...
17:41:35 <chrisdone> hmm
17:41:40 <ReinH> So...
17:41:47 <ReinH> well
17:41:49 <ReinH> fmap and join, sorry
17:42:09 <ReinH> the point being: implementing "join" is what gives your monad its monad semantics if it inherits fmap and pure
17:42:21 <ReinH> I don't think this is a nonsensical argument
17:42:25 <ReinH> it might be wrong, but it makes sense
17:42:45 <ReinH> Also perhaps "inherits" is inaccurate or wrong
17:42:49 <ReinH> But that's not what they said
17:42:50 <ReinH> :/
17:43:05 <chrisdone> sure, join is the monoidal operation and that's the important bit
17:43:10 <haasn> ReinH: well, what was the original question? :)
17:44:17 <chrisdone> oh yeah, i can now start reading Category Theory for Scientists on my kobo hd ^_^
17:44:29 <ReinH> haasn: listen to the podcast? :p
17:44:59 <ReinH> chrisdone: is that a thing?!
17:45:00 <ReinH> WANT
17:45:02 <chrisdone> ReinH: i was shopping when you were talking about the applicative/monad stuff
17:45:06 <ReinH> the book, not the kobo
17:45:09 <chrisdone> so i don't quite remember what was said
17:45:12 <ReinH> heh np
17:45:17 <chrisdone> yeah! http://arxiv.org/abs/1302.6946
17:45:28 <ReinH> I might have been very handwavy but it made enough sense for Simon to provide an interesting answer
17:45:35 <ReinH> which afaik is enough to call it a success
17:45:41 <ReinH> afai concerned, rather
17:46:02 <ReinH> nice one
17:46:03 <haasn> ReinH: takes way too much time and bandwidth (I'm on a mobile connection and about to fall asleep)
17:46:42 <ReinH> haasn: :p
17:52:00 <haasn> ReinH: provide plaintext transcripts of your podcasts (serious idea)
17:52:13 * haasn volunteers to not do it
17:52:48 <chrisdone> GSoC project to transcribe audio to text!
17:52:52 <cariveri> in "IO (Either ParseError X)"   how do I get the X?
17:53:02 <haasn> chrisdone: doesn't youtube implement something like this?
17:53:08 <chrisdone> it does indeed
17:53:22 <haasn> enable autocaptions for your podcasts ;)
17:53:50 <chrisdone> i thought the point was so that you didn't have to have a video/audio
17:54:20 <haasn> cariveri: by pattern matching on the Either (inside the IO monad)
17:56:37 <cariveri> haasn: what does that mean inside of it? I tried let x = y where (Right y) = ioResult
17:57:01 <haasn> cariveri: http://www.haskell.org/haskellwiki/Introduction_to_IO
17:57:33 <haasn> (also if you pattern match on an Either like that your program will just crash if the result is Left)
17:57:58 <cariveri> haasn: LEft is taken care of long before
17:58:11 <haasn> if Left is taken care of then you shouldn't have an Either at that point in time, should you?
18:01:13 <ReinH> haasn: just editing the audio is quite enough work, thanks :p
18:02:14 <ReinH> haasn: you have no idea how much work it is to make me sound halfway intelligent ;)
18:02:21 <ReinH> And even then I'm still apparently "nonsensical" to some people
18:02:30 <haasn> ReinH: is the video transcript edited?
18:02:35 <ReinH> haasn: no
18:02:38 <ReinH> ain't noone got time for that
18:02:41 <haasn> ah fair enough
18:02:54 <haasn> yeah, you'd notice the cuts either way
18:04:01 <ReinH> yeah
18:04:11 <haasn> so is the audio version significantly shorter?
18:04:17 <haasn> maybe I should take them with me on long train rides :)
18:04:28 <ReinH> haasn: We usually get an hour out of 1h30m
18:04:48 <ReinH> or so
18:05:12 <haasn> Hmm. I need podcasts tailored specifically for 7, 13 and/or 25 minutes, so I don't miss my stop
18:05:48 <ReinH> haasn: There is a pause button.
18:05:59 <haasn> Oh, I could listen to them in the bus as well. That should extend it to just about an hour in the worst case scenario. Perfect!
18:06:21 <ReinH> :D
18:16:31 <cariveri> haasn: ok. Thanks anyways
18:19:28 <monochrom> w00t, I talked about two problems with "arguments" in optparse-applicative. I found that the second problem does not exist, I did not explore enough
18:19:41 <monochrom> s/found/now find/
18:22:28 <monochrom> arguments1 Just (metavar "FILES" <> help "files to be tested")
18:22:47 <CAP5743> hola
18:22:49 <CAP5743> feos
18:23:08 <monochrom> this will enable the usage line to say "Usage: progname FILES", and the detailed help message to say "FILES     files to be tested"
18:23:28 <haasn> optparse-applicative++
18:23:33 <CAP5743> monochrom gilipollas
18:23:42 <CAP5743> tu eres gilipollas
18:23:50 <CAP5743> se entiende esto?
18:24:00 <haasn> @where ops
18:24:01 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
18:24:05 <monochrom> I am now just not happy with arguments1 :: (String -> Maybe a) -> ... instead of (String -> Either String a) -> ...
18:24:10 --- mode: ChanServ set +o monochrom
18:24:12 --- mode: ChanServ set +o geekosaur
18:24:16 --- mode: monochrom set +b *!*@77.224.247.181
18:24:16 --- kick: CAP5743 was kicked by monochrom (CAP5743)
18:24:20 --- mode: geekosaur set -o geekosaur
18:24:30 --- mode: monochrom set -o monochrom
18:24:56 <monochrom> actually, haasn, do you know what CAP5743 said?
18:25:09 <haasn> monochrom: https://en.wiktionary.org/wiki/gilipollas told me enough to infer it
18:25:34 <monochrom> I see, thanks, yeah hehe
18:25:48 <haasn> (combined with knowledge of other indogermanic languages ;))
19:18:51 <monochrom> https://github.com/treblacy/random-read
19:21:17 <joneshf-laptop> if i have a data type parameterized by two types, can i have this be a functor where `fmap` need to examine both values in order to operate on it?
19:21:34 <joneshf-laptop> like if i had: data Some a b = Thing a b
19:21:37 <joneshf-laptop> can i make a functor?
19:23:55 <chrisdone> you can have a Bifunctor
19:23:57 <monochrom> you can only make "instance Functor (Thing a) where fmap f (Thing x y) = Thing x (f y)"
19:24:02 <chrisdone> http://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor.html
19:24:18 <monochrom> that is, fmap :: (d -> c) -> Thing a d -> Thing a c
19:26:17 * hackagebot gtk2hs-buildtools 0.12.5.1 - Tools to build the Gtk2Hs suite of User Interface libraries.  http://hackage.haskell.org/package/gtk2hs-buildtools-0.12.5.1 (HamishMackenzie)
19:26:27 <joneshf-laptop> thanks
19:26:29 <joneshf-laptop> that'll work
19:27:06 <joneshf-laptop> speaking of
19:34:19 <joneshf-laptop> actually
19:34:25 <joneshf-laptop> that only sort of helps
19:34:40 <chrisdone> you only sort of asked =p
19:34:44 <joneshf-laptop> there doesn't seem to be some sort of dependency on one or the other
19:34:45 <joneshf-laptop> ;)
19:35:02 <chrisdone> dependency?
19:35:03 <joneshf-laptop> actually
19:35:11 <joneshf-laptop> i dont think i'm thinking about it properly
19:35:46 <joneshf-laptop> no, i'm not
19:35:47 <joneshf-laptop> nevermind
19:44:54 <ReinH> monochrom: who was responsible for the "one Functor per type" law? Wadler?
19:46:43 <monochrom> I don't know. who invented Functor?
19:47:16 <c_wraith> blame math
19:47:36 <PatrickRobotham> It's a more general case of the "One type class instance per type" law
19:47:52 <PatrickRobotham> not a more general, more specific
19:48:04 <ReinH> PatrickRobotham: not quite
19:48:21 <ReinH> iirc it's provable that there can be exactly zero or one valid functor instances
19:48:36 <ReinH> It doesn't have to do with which one you choose to implement
19:49:21 <PatrickRobotham> Only one way to implement fmap huh?
19:49:37 <ReinH> For a given type, there are either zero or one valid ways to make it a functor
19:49:45 <ReinH> up to isomorphism, probably
19:50:02 <shachaf> What does "up to isomorphism" mean here?
19:50:05 <arkeet> "up to isomorphism" doesn't make sense.
19:50:16 <arkeet> hi shachaf
19:50:23 <shachaf> hi arkeet
19:50:32 <ReinH> (a,b,c) could be (a -> d), (b -> d), or (c -> d)?
19:51:03 <arkeet> ????
19:51:05 <ReinH> ?
19:51:31 <ReinH> you can define Functor for (a,b,c) to map a, b or c
19:51:48 <arkeet> I don't know what "Functor for (a,b,c)" means
19:51:51 <ReinH> really?
19:51:54 <arkeet> yes
19:52:12 <monochrom> what does "one Functor per type" mean anyway?
19:52:24 <shachaf> In Haskell, if F is a functor, then any function :: (a -> b) -> F a -> F b that satisfies the fmap laws (even just the id law) will be fmap.
19:52:36 <ReinH> Well, actually it would be (,,) a b, so never mind
19:55:14 <PatrickRobotham> Hmm, can we make a functor F such that for all a, F a is isomorphic to int?
19:55:21 <arkeet> yes
19:55:24 <arkeet> it's called Const Int
19:55:37 <arkeet> data Const r a = Const r
19:55:44 <arkeet> fmap f (Const r) = Const r
19:56:01 <c_wraith> Const is a good functor.
19:56:09 <Iceland_jack> One of the finest.
19:56:10 <PatrickRobotham> I'm wondering if we can do some kind of type based dispatch
19:56:22 <c_wraith> you mean...  type classes?
19:56:36 <PatrickRobotham> that is, if f :: Int -> Int, make fmap f (Const r) = Const (f r)
19:57:16 <Cale> fmap's type doesn't allow that
19:57:18 <Cale> :t fmap
19:57:19 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:57:21 <PatrickRobotham> You see what I'm driving at presumably.
19:57:32 <Cale> It's polymorphic in a and b
19:57:42 <shachaf> At things so horrible you can't even express them in Haskell.
19:57:45 <PatrickRobotham> Ah, the polymorphism is important.
19:57:59 <PatrickRobotham> shachaf: You might say they're... unnatural.
19:58:45 <Ralith> PatrickRobotham: parametricity!
19:58:46 <Ralith> also hi
19:58:51 <heath> hi bear
19:59:43 <monochrom> quite on the contrary, type-case is quite natural, just horrible.
20:00:39 <Cale> Well, if you're allowed to type case, naturality becomes a theorem which you need to prove yourself
20:01:05 <joneshf-laptop> forgive my naivity, why does fmap's type not allow that?
20:02:32 <ReinH> arkeet: with tuples I was thinking of `over _1' vs `over _2' and so on
20:02:34 <Cale> joneshf-laptop: The implementation of fmap knows nothing about the types a and b, it just knows that it has a function of type (a -> b), and some structure of type f a
20:03:05 <Cale> joneshf-laptop: In particular, it can't tell whether a = Int, even at runtime.
20:03:17 <arkeet> maybe you can do something with a GADT?
20:03:39 <arkeet> then again, who knows what you're actually trying to do
20:03:45 <joneshf-laptop> oh
20:03:50 <Cale> (In fact, especially at runtime, since by then all the types have been erased)
20:03:50 <c_wraith> there are reasons GADTs and Functors don't often play friendly.
20:04:04 <joneshf-laptop> i misunderstoodthe question
20:04:26 <ReinH> Ok, here's what I was referring to. FINALLY found the citation:
20:04:27 <ReinH> "Unlike some other type classes we will encounter, a given type has at most one valid instance of Functor. "
20:04:38 <ReinH> from http://www.haskell.org/haskellwiki/Typeclassopedia
20:05:07 <ReinH> And it is indeed a result of the free theorem, so I wasn't so off base with Wadler
20:06:11 <ReinH> The proof seems quite straightforward http://article.gmane.org/gmane.comp.lang.haskell.libraries/15384
20:11:04 <ReinH> carter: :p
20:11:13 <carter> ReinH: seriously
20:11:20 <carter> soooo many low hanging fruit
20:11:26 <ReinH> carter: ok seems good what should I fix?
20:11:44 <carter> whats one part of ghc you really want to dig into / play with?
20:12:04 <ReinH> Uh, the parallel runtime but dragons
20:12:11 <ReinH> So maybe something that doesn't involve C that will make my eyes bleed
20:12:35 <carter> wanna help write 1-2 new primops?
20:12:46 <carter> hrmm
20:12:54 <carter> nah, that gets into pretty printing asm
20:12:54 <ReinH> maybe?
20:12:58 <ReinH> heh
20:13:07 <carter> crazy C >>>>> pretty printing asm
20:13:12 <ReinH> hahaha
20:13:32 <carter> when do you have the bandwidth for hobby hacking in the next month or so?
20:13:43 <carter> you could look at the open tickets on trac too
20:13:49 <carter> but theres many
20:14:10 <ReinH> Hmm
20:14:17 <carter> https://ghc.haskell.org/trac/ghc/wiki/Newcomers has some "gimmes"
20:15:10 <ReinH> carter: cool thanks
20:15:51 <carter> https://ghc.haskell.org/trac/ghc/ticket/2507 may be a good one
20:16:19 <carter> 'cause the complexity isn't ghc related
20:18:29 <ParahSailin> carter: there are some primops that i've wondered about the feasibility of writing
20:18:35 <carter> ask
20:18:41 <carter> and i may say "no clue, try it out"
20:18:44 <carter> or "yessss"
20:18:47 <carter> or "nooooooo"
20:18:53 <carter> or "yessss nooooooo"
20:19:00 <carter> or some permutation thereof
20:19:48 <ReinH> carter: oh god term language support nope nope nope nope
20:19:58 <carter> ReinH: :)
20:20:08 <ReinH> let's talk about pretty-printing asm again...
20:20:09 <carter> it is an example where the hard bit isn't ghc :)
20:20:11 <carter> hehe
20:24:52 <ReinH> carter: I think Trac needs a new milestone called "not yet" https://ghc.haskell.org/trac/ghc/ticket/2450 ;)
20:25:11 <carter> thats called bottom
20:25:17 <ReinH> sure
20:50:23 <cschneid> I'm trying to use optparse-applicative, but it hangs now. https://gist.github.com/cschneid/7688320358714f44202b -- it stops hanging when I remove the `many` call in the sockopt part. How can I debug a (presumably?) infinite loop
20:50:35 <dwcook> Is there anywhere compiled a list of laws or assumptions of Haskell broken by floating point types such as Double?
20:51:23 <cschneid> Damn it, as soon as I ask, I find the answer. the `value` call in that section was making the parser pass every time, so many never terminates.
20:51:29 * hackagebot extensible-effects 1.2.0 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-1.2.0 (BenFoppa)
20:52:03 <dwcook> Or maybe not something Haskell-specific, since the floating-point witchery seems not to be Haskell-specific.
20:55:07 <dwcook> At a glance, this seems to be thorough, although it doesn't address any Haskell-specific problems there may be: http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
21:01:33 <Iceland_jack> dwcook: What Haskell-specific problems are you referring to?
21:05:28 <dwcook> Iceland_jack, mostly I'm wondering if there are any.
21:06:52 <dwcook> I suppose I was mostly thinking about how you can't necessarily compare for equality, but that's not Haskell-specific either.
21:07:00 <Iceland_jack> That's right
21:11:31 * hackagebot gconf 0.12.5.0 - Binding to the GNOME configuration database system.  http://hackage.haskell.org/package/gconf-0.12.5.0 (HamishMackenzie)
21:11:33 * hackagebot gstreamer 0.12.5.0 - Binding to the GStreamer open source multimedia framework.  http://hackage.haskell.org/package/gstreamer-0.12.5.0 (HamishMackenzie)
21:11:35 * hackagebot svgcairo 0.12.5.0 - Binding to the libsvg-cairo library.  http://hackage.haskell.org/package/svgcairo-0.12.5.0 (HamishMackenzie)
21:14:37 <Iceland_jack> dwcook: I'm not sure what your issue is but maybe secion 6.4 of the report will prove helpful http://www.haskell.org/onlinereport/basic.html
21:15:36 <mm_freak_> this week i'll be starting my first commercial project that combines haskell, NixOS, coffee and bacon.js =)
21:15:48 <Iceland_jack> That sounds like breakfast mm_freak_ :)
21:16:19 <mm_freak_> i might switch to fay in the future, but i won't have time to write an fay FRP implementation this time
21:17:09 <mm_freak_> alternatively i might try GHCJS
21:17:20 <dwcook> Iceland_jack, no specific issue, I'm just curious whether it would be worth the trade-off to use a precise but possibly less efficient type in general.
21:17:46 <Iceland_jack> What type are you referring to?
21:18:22 <dwcook> Iceland_jack, for the specific cases where they overlap, Rational and Double.
21:18:47 <Iceland_jack> You can try both and profile
21:19:19 <dwcook> I suppose this really is a case-per-case thing
21:19:28 <Iceland_jack> I doubt you need more precision than Double provides
21:19:59 <dwcook> Anyway, it was just something that sparked my curiosity, raised the question "Why not use Rationals for everything?"
21:20:00 <c_wraith> often times, you want more uniform precision than Double provides..  At which time fixed-point types come in really nice
21:20:14 <Iceland_jack> because Rationals are expensive
21:20:15 <mm_freak_> Iceland_jack: there are two ways Double precision can be insufficient
21:20:29 <mm_freak_> one way is the inability to represent 2^(-100000)
21:20:35 <mm_freak_> the other is the inability to represent 1/3
21:20:54 <mm_freak_> the latter is especially relevant to applications dealing with money
21:21:10 <c_wraith> mm_freak_: there's a third way.  The ability to add 1 to 2^55
21:21:17 <dwcook> Double is utterly unsuitable for currency anyway
21:21:23 <c_wraith> (or so..  I forget exactly where precision loss appears)
21:21:26 <dwcook> As is floating-point in general
21:21:41 <mm_freak_> > floatDigits (0 :: Double)
21:21:42 <lambdabot>   53
21:21:57 <dwcook> As long as your application didn't need to store fractional pennies, something isomorphic to Integer could well serve
21:22:06 <mm_freak_> > 2^53 + 1 == (2^53 :: Double)
21:22:07 <lambdabot>   True
21:22:22 <Iceland_jack> Are people just throwing the word isomorphic around now
21:22:33 <mm_freak_> dwcook: like Rational?
21:22:48 <c_wraith> Yeah, that.  There are cases where that non-uniformity of precision really hurts.  Though more with Float than Double
21:22:49 <dwcook> Okay, "isomorphic" was too general a term I think
21:22:59 <chrisdone> "like"?
21:23:19 <dwcook> Integer itself could serve, really
21:23:30 <arkeet> dwcook: Data.Fixed
21:23:30 <arkeet> =
21:23:31 <arkeet> )
21:23:39 <mm_freak_> dwcook: how about, "fixed fractional type"? =)
21:24:02 <mm_freak_> or rather "fixed precision"
21:24:02 <c_wraith> indeed.  Haskell is a language where additional numeric types aren't terrible to use.  Just use a fixed-point type!
21:24:35 <mm_freak_> also you want to use a fixed-point type with base 10 for currency
21:24:56 <arkeet> that's Data.Fixed =)
21:25:08 <mm_freak_> the inability to represent 1/5 of a dollar exactly might hurt =)
21:25:17 <dwcook> At a glance, that does seem appropriate
21:26:38 * hackagebot gtk3-mac-integration 0.2.0.4 - Bindings for the Gtk/OS X integration library.  http://hackage.haskell.org/package/gtk3-mac-integration-0.2.0.4 (HamishMackenzie)
21:26:40 * hackagebot gtk-mac-integration 0.2.0.4 - Bindings for the Gtk/OS X integration library.  http://hackage.haskell.org/package/gtk-mac-integration-0.2.0.4 (HamishMackenzie)
21:39:46 <ReinH> mm_freak_: what is 1/3 of a dollar? :p
21:40:41 <mm_freak_> ReinH: 100/3 of a cent ;)
21:41:00 <ReinH> thanks
21:41:25 <mm_freak_> > toRational (1/5 :: Double) == 1/5
21:41:26 <lambdabot>   False
21:41:58 <ReinH> > 1 / 3 :: Centi
21:41:59 <lambdabot>   0.33
21:42:06 <mm_freak_> Double doesn't understand 20 cents =)
21:42:56 <ReinH> > (1 / 5 :: Centi) == 0.20
21:42:56 <lambdabot>   True
21:42:59 <ReinH> wewt
21:43:09 <mm_freak_> > toRational (1/5 :: Centi) == 1/5
21:43:10 <lambdabot>   True
21:43:16 <mm_freak_> > toRational (1/5 :: Double) == 1/5
21:43:17 <lambdabot>   False
21:43:23 <ReinH> seems good
21:44:04 <mm_freak_> > toRational (1/5 :: Double)
21:44:05 <lambdabot>   3602879701896397 % 18014398509481984
21:44:29 <ReinH> close enough
21:44:49 <mm_freak_> yeah, since‚Ä¶
21:44:54 <mm_freak_> > 1/5 - toRational (1/5 :: Double)
21:44:55 <lambdabot>   (-1) % 90071992547409920
21:44:58 <ReinH> nothing could go wrong
21:45:10 <mm_freak_> might work to your advantage when paying your rent
21:45:20 <mm_freak_> after only a few trillion years you will save a cent =)
21:45:21 <ReinH> I would save fractional pennies!
21:45:26 <ReinH> indeed!
21:45:32 <ReinH> or spend an extra cent
21:45:35 <ReinH> the house always wins
21:45:41 <mm_freak_> true
21:48:41 <chrisdone> Let's build a house out of enthusiasm!
21:51:31 <rhodesd> happy! happy!, joy joy, you're not smiling!
21:52:59 <chrisdone> \ (o_ o) /
21:59:14 <pavonia> What does "newtype instance Foo = ..." denote?
21:59:50 <arkeet> that's an instance for a data family
22:00:27 <arkeet> that happens to be a newypte
22:01:43 <pavonia> What is an instance for a data family? You mean like when a data family is declared in a type class?
22:02:05 <arkeet> no, a standalone data family.
22:03:05 <arkeet> http://www.haskell.org/haskellwiki/GHC/Type_families
22:07:19 <pavonia> arkeet: So there not only are type families but also data and newtype families?
22:07:28 <arkeet> there are also data families.
22:07:44 <arkeet> which are really just data types and type families stuck together.
22:08:03 <arkeet> newtype instances are just instances for data families that happen to be newtypes.
22:11:12 <pavonia> So this is the actual example from the vector package I'm looking at: newtype instance Vector    (Complex a) = V_Complex  (Vector    (a,a))
22:13:32 <pavonia> Vector is a data family. V_Complex is creating a newtype for Complex. But what is that newtype doing then?
22:13:48 <arkeet> it's making Vector (Complex a) a newtype of Vector (a,a)
22:13:54 <arkeet> with V_Complex being the constructor.
22:14:58 <pavonia> Oh, that's another application of that family
22:15:01 <arkeet> yes.
22:15:31 <pavonia> Ah, okay, thank you!
22:17:45 <newbie-haskel> i am learning haskel by converting c code into haskel, whats the best way of writing int a[10][10]; a[0][10] = 4?
22:17:47 <zRecursive> @wn assess
22:17:49 <lambdabot> *** "assess" wn "WordNet (r) 3.0 (2006)"
22:17:50 <lambdabot> assess
22:17:50 <lambdabot>     v 1: evaluate or estimate the nature, quality, ability, extent,
22:17:50 <lambdabot>          or significance of; "I will have the family jewels
22:17:50 <lambdabot>          appraised by a professional"; "access all the factors when
22:17:51 <lambdabot> [8 @more lines]
22:19:10 <arkeet> newbie-haskel: I don't think that's a good way to learn haskell.
22:19:44 <arkeet> and literal translations don't work.
22:20:07 <pavonia> just like in spoken languages
22:20:12 <arkeet> :)
22:20:19 <arkeet> newbie-haskel: if you haven't checked it out yet, have a look at learn you a haskell
22:20:21 <arkeet> @where lyah
22:20:21 <lambdabot> http://www.learnyouahaskell.com/
22:20:47 <arkeet> it's probably the best introduction around
22:20:58 <newbie-haskel> ohk.. whats haskels counterpart for 2d array stuffs?
22:21:26 <arkeet> there are some array libraries
22:22:08 <zRecursive> @hoogle Array
22:22:09 <lambdabot> Foreign.Marshal.Array module Foreign.Marshal.Array
22:22:09 <lambdabot> Data.Text.Array data Array
22:22:09 <lambdabot> Data.Array data Array i e :: * -> * -> *
22:22:40 <w0rm_x> or use lists
22:23:18 <pavonia> "length :: Unbox a => Vector a -> Int" <-- That type wouldn't work with type families, would it?
22:26:54 <ReinH> newbie-haskel: what do you need a 2d array for?
22:29:35 <enthropy> pavonia: you could have  type family Unbox a :: Constraint
22:29:47 <enthropy> not sure if that leads to anything useful though
22:30:03 <pavonia> No, I mean for Vector a
22:30:23 <newbie-haskel> @ReinH i have a c program with does 2d array manipulation im trying to convert the same into haskel
22:30:23 <lambdabot> Unknown command, try @list
22:31:15 <lolcathost> newbie-haskel: Well, you could make quite a literal translation using mutable arrays inside ST or IO, but perhaps there is a better way!
22:31:32 <enthropy> so Vector could have different representations depending on what 'a' is
22:31:40 <mikeplus64> newbie-haskel: see Data.Array
22:31:55 <enthropy> which is the standard motivation for the type families
22:31:56 <mikeplus64> newbie-haskel: http://hackage.haskell.org/package/array-0.4.0.1/docs/Data-Array.html
22:32:34 <mikeplus64> newbie-haskel: http://www.haskell.org/haskellwiki/Arrays this page has a lot of useful info too
22:34:31 <pavonia> enthropy: Vector here is a data family. If a type family would be used, "a" couldn't be inferred from that type signature. But as we have a a data/newtype constructor, we can deduce what concrete type "a" is of. Is that correct?
22:35:03 <newbie-haskel> thanks lemme check.. wil b back if im struck somewhere :D
22:36:58 <arkeet> do read LYAH though =)
22:37:47 <marx2> why does this work: `x <- (return 10 :: IO Int)'  but this doesn't: `x <- (return 10 :: Identity Int)'
22:38:13 <shachaf> Neither of them "works" on its own.
22:38:22 <pavonia> Are you trying this from GHCi?
22:38:23 <shachaf> The context is different.
22:38:32 <marx2> pavonia yes
22:38:53 <pavonia> That's why, GHCi is running in the IO monad
22:40:35 <marx2> given that I expected this to work: do x <- (return 10 :: Identity Int); return x
22:40:45 <marx2> but I am getting "    No instance for (Show (Identity Int)) arising from a use of `print'"
22:41:17 <scott_> It did work, but ghci tried to show the result and it doesn't know how to (there is no Show instance for (Identity Int))
22:41:53 <marx2> shouldn't it show Int?
22:42:26 <scott_> Your do block returns Identity Int
22:42:32 <scott_> You can get the Int out of Identity Int with runIdentity
22:42:32 <marx2> uh right
22:42:37 <scott_> :t runIdentity
22:42:38 <lambdabot> Identity a -> a
22:43:23 <marx2> so runIdentity is Identity equivalent of unsafePerformIO? :)
22:43:32 <ReinH> No.
22:43:49 <marx2> why not?
22:44:50 <ReinH> because it is not a backdoor into the Identity monad that allows Identity computation to be run at any time? It's just a field accessor.
22:45:41 <scott_> data Identity a = Identity { runIdentity :: a }
22:46:03 <scott_> runIdentity just accesses the wrapped value
22:46:08 <marx2> what makes it equivalent is that they are both  m a -> a for their respective monads
22:46:29 <ReinH> marx2: they are equivalent up to their type signature, sure.
22:46:47 <ReinH> So are (+2) and (*100)
22:47:18 <nisstyre> scott_: why call it runIdentity? To be in line with the naming conventions for things like runResourceT, etc...?
22:47:32 <ReinH> scott_: (it's a newtype btw)
22:47:48 <marx2> ReinH it's more than their type signature, they both pull the value out of the monad context
22:48:17 <scott_> nisstyre: I think so
22:48:30 <ReinH> No, they don't.
22:48:48 <ReinH> That's a  sloppy way to think about monads that I don't agree with.
22:48:54 <marx2> am I being nitpicked or do you have a point?
22:49:01 <marx2> if you do I am missing it
22:49:01 <ReinH> never mind
22:50:42 <nisstyre> marx2: short answer to your question about Show, it can show Int, yes, but Identity Int is a completely different type
22:52:21 <marx2> yeah I got it
22:54:11 <pavonia> Why is there no Show instance, btw? That should be pretty straight forward
22:54:41 <nisstyre> you can easily derive an instance
22:55:01 <nisstyre> also, marx2, try commenting out the first instance and uncomment one of the other two here http://ideone.com/tL8pFM
22:55:11 <nisstyre> see the differences in all of them?
22:55:43 <frxx> ReinH it's not a backdoor, but it still allows Identity computation, no? with computation being "just return the value"
22:55:54 <nisstyre> er that last one was a typo
22:56:23 <nisstyre> should be Show (Identity a)
22:57:14 <nisstyre> the middle one should give you an error
23:01:22 <ReinH> frxx: It's not generally try that an m a is a "monad context" that contains a "value", or that you can get the a out with some m a -> a
23:01:29 <ReinH> *true
23:02:17 <nisstyre> ReinH: can you define "context" for me?
23:03:31 <nisstyre> ReinH: also the actual monad is a type, not a value, unless you mean extracting a value from some type that is a monad
23:03:58 <nisstyre> *some value whose type is a monad
23:04:08 <ReinH> nisstyre: I'm just using the terms that were used to explain why runIdentity is like unsafePerformIO
23:05:15 <nisstyre> ReinH: because they both have the type signature Monad m => m a -> a ?
23:05:15 <ReinH> Identity is a newtype wrapper around a value and a value of type Identity a "contains" a value of type a in a very obvious way
23:05:24 <ReinH> IO is not and IO a does not "contain" an a
23:05:41 <arkeet> @quote /bin/ls
23:05:41 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
23:05:43 <ReinH> nisstyre: that was the argument, yes
23:05:46 <nisstyre> ReinH: okay I agree
23:05:52 <nisstyre> it contains an IO computation
23:06:00 <nisstyre> which has yet to be "run"
23:06:12 <ReinH> arkeet: that's one of the quotes I was looking for
23:06:38 <arkeet> I think continuations are a good way to think about monads.
23:06:51 <nisstyre> arkeet: ehhh, idk
23:06:59 <nisstyre> a continuation is sort of similar if you squint yeah
23:07:16 <nisstyre> but you can't really "pause" an IO computation can you?
23:07:24 <marx2> IO can contain an a.  (return a).  or to think of it in a different way, Identity "computes" the value of a b just returning the stored value.  they are still equivalent (equivalent /= equal)
23:07:24 <arkeet> or at least one way to approach them.
23:08:25 <arkeet> I should try to figure out Codensity.
23:08:44 <ReinH> arkeet: I think "fmap + pure + join" is a decent way to think of monads :)
23:09:27 <ReinH> marx2: IO does not contain an a.
23:09:43 <marx2> it can contain an a ->  (return 10) :: IO
23:09:49 <ReinH> No, it can't.
23:09:51 <ReinH> But you're free to keep thinking that until you are faced with a situation where it becomes clear that they don't.
23:10:23 <marx2> how does it not contain 10 in here?  (return 10) :: IO
23:10:37 <marx2> it seems that you are trying hard to "win" this argument
23:10:42 <ReinH> ...
23:10:47 <ReinH> fine
23:10:52 <ReinH> it's not worth convincing you
23:11:43 <nisstyre> marx2: you seem to think that because both IO a -> a and Identity a -> a  ‚äÜ Monad m => m a -> a that they are "equivalent", right?
23:12:14 <nisstyre> but IO has completely different semantics from Identity
23:12:50 <marx2> I did not say that IO and Identity are equivalent. I said that unsafePerformIO and runIdentity are.  they both run the action, and return the result, outside of monadic context
23:12:53 <nisstyre> IO is an _action_, meaning it forces a side-effect to happen
23:13:24 <nisstyre> :t unsafePerformIO
23:13:24 <lambdabot> Not in scope: `unsafePerformIO'
23:13:35 <nisstyre> well, it has the type I gave
23:13:41 <nisstyre> IO a -> a
23:15:03 <marx2> right. they are equivalent, and not just because of the types
23:15:38 <nisstyre> marx2: I don't see why that's the case personally
23:15:40 <marx2> fromJust , unsafePerformIO, and runIdentity all do the equivalent thing for their respective monads
23:16:02 <nisstyre> marx2: well fromJust is a partial function
23:16:03 <Iceland_jack> For a wrong definition of ‚Äúequivalent‚Äù sure
23:16:08 <ReinH> For some value of "equivalent" that doesn't have any rigorous definition, and for some form of "contain" that doesn't have any rigorous definition, runIdentity and unsafePerformIO are "equivalent" because they both allow you to get the value "contained" by their respective monads
23:16:09 <nisstyre> whereas runIdentity is total
23:16:18 <pavonia> What does it mean if cabal is trying to configure packages that are already installed? Is it using the dependency information from Hackage in that case too?
23:16:53 <ReinH> This is neither a correct nor a useful way of looking at monads, but whatever
23:16:59 <Iceland_jack> ‚Äòundefined‚Äô is equivalent to runIdentity as well
23:17:10 <Iceland_jack>     runIO ‚à∑ IO a ‚Üí a
23:17:10 <Iceland_jack>     runIO = undefined
23:17:14 <ReinH> you've managed to make your terms meaningless enough that it's difficult to argue against
23:17:40 <marx2> > runIdentity (Identity 10)
23:17:41 <lambdabot>   10
23:17:47 <marx2> > fromJust (Just 10)
23:17:48 <lambdabot>   10
23:17:59 <Iceland_jack> > fromJust Nothing
23:18:00 <ReinH> marx2: yes, it's clear that because Identity is a monad that contains a value, you think that all monads contain values
23:18:00 <lambdabot>   *Exception: Maybe.fromJust: Nothing
23:18:01 <marx2> unsafePerformIO (return 10 :: IO) => 10
23:18:16 <ReinH> it's also clear that we won't be able to convince you that this isn't true
23:18:23 <ReinH> but it's going to be fun to watch people try and fail
23:18:34 <marx2> ReinH would you whine less if I said "performs computation and returns the value out of monadic context" ?
23:18:48 <ReinH> marx2: Oh, I'm "whining", am I?
23:18:52 <ReinH> How about don't be a jerk?
23:18:56 <Iceland_jack> Jesus marx2, stop digging
23:19:06 <marx2> how about not resorting to insults?
23:19:18 <ReinH> marx2: how did I insult you?
23:19:40 <marx2> read up two lines
23:19:45 <ReinH> Be specific
23:19:55 <marx2> ...
23:20:07 <johnw> "IO Int contains an Int as much as /bin/ls contains a list of file names"
23:20:11 <ReinH> I can't read your mind, and two lines isn't meaningful in a context where line order is not necessarily preserved
23:20:50 <ReinH> If you're referring to me calling you a jerk?
23:21:03 <ReinH> If you don't behave like a jerk, I won't call you a jerk. Seems fair.
23:21:50 <ReinH> This is by far the least interesting or productive conversation I've had in #haskell in quite a while, so congratulations for that.
23:21:57 <johnw> marx2: Copointed abstracts deriving an 'x' from any 'm x', but it is not very principled; Comonad can do this too (via 'extract'), but comes with requirements that are not satisfied by Maybe, for example
23:21:58 <marx2> that's a cute way to rationalize calling someone a jerk not being an insult
23:22:29 <ReinH> marx2: That's not what I did. I said I called you a jerk because you are acting like a jerk. I didn't deny that it is an insult.
23:22:38 <ReinH> But holy shit you are the most annoyingly pedantic person I've dealt with in here.
23:23:04 <ReinH> The irony being that usually pedantic people care about correctness
23:23:36 <marx2> ReinH actually you tried to pretend you didn't insult me for a while, but then you realize it made you look silly
23:23:47 <ReinH> marx2: No, I didn't. I asked you how I insulted you.
23:23:57 <ReinH> marx2: if you're going to be a pedantic jerk, at least do me the favor of being correct.
23:24:30 <marx2> asking "how I insulted you" in response to me telling you not to insult people implies that you didn't.
23:24:31 <johnw> ReinH, marx2: does this discussion need to happen before all of #haskell?
23:24:37 <dainanaki> If you guys are going to keep bickering, could you take it off of #haskell?
23:24:38 <ReinH> holy crap
23:24:47 <ReinH> Ignored.
23:25:02 <ReinH> Apologies.
23:25:14 <Iceland_jack> No problem ReinH, it's a slow morning anyway
23:25:32 <ReinH> I don't usually let the trolls get to me, but holy crap.
23:26:21 <marx2> I knew that is coming, ignore someone but then keeps talking about him
23:27:25 <frxx> I am still curious why unsafePerformIO can't be thought of as similar to runIdentity :)
23:27:48 <johnw> I think it's only similarity is in the sense of Copointed
23:27:53 <Iceland_jack> frxx: Identity contains a single value, but monads don't in general
23:28:00 <ReinH> frxx: because there is not a principled way to "get a value out of a monad"
23:28:00 <johnw> but since Copointed hardly has any intrinsic meaning, that pretty much says it all
23:28:36 <johnw> i mean, I could write "runJohn :: Identity a -> a; runJohn (Identity 10) = 20"
23:28:52 <johnw> oh, wait, I was thinking of Identity Int
23:28:53 <johnw> n/m
23:29:24 <ReinH> runIdentity also tends to not crash your program
23:29:34 <Iceland_jack> That's why people kept quoting: "IO Int contains an Int as much as /bin/ls contains a list of file names"
23:29:40 <johnw> the similarity is superficial at best
23:29:48 <Iceland_jack> See http://stackoverflow.com/questions/8567743/how-to-extract-value-from-monadic-action, http://stackoverflow.com/questions/7314789/taking-out-a-value-out-of-a-monad-haskell
23:29:52 <johnw> one might even say specious
23:30:08 <ReinH> johnw: I'm pretty sure I tried to say that at least 3 different ways, but oh well ;)
23:30:37 <Iceland_jack> Specious describes it well :)
23:30:41 <marx2> how about this definition of them similar?   if you "return x", and then call runIdentity (or unsafePerform IO), you get x back
23:30:46 <marx2> them being similar*
23:30:58 <marx2> your runJohn fails that
23:31:04 <Iceland_jack> marx2: Look at the Null definition
23:31:17 <johnw> runJohn was all wrong, just a brain mistake that was
23:31:30 <Iceland_jack>     data Null a = Null
23:31:31 <Iceland_jack>     instance Monad Null where { return a = Null; _ >>= f = Null }
23:31:37 <johnw> fromJust Nothing = ‚ä•
23:31:52 * hackagebot socket-activation 0.1.0.1 - systemd socket activation library  http://hackage.haskell.org/package/socket-activation-0.1.0.1 (DavidFisher)
23:31:57 <Iceland_jack> 'return 5 ‚à∑ Null Int' will equal Null
23:31:57 <marx2> Iceland_jack so you can't run the equivalent of runIdentity/unsafePerformIO for Null monad
23:32:02 <marx2> or rather, you can't write
23:32:27 <Iceland_jack> Because there is not ‚Äòthe value‚Äô inside monads
23:32:54 <Iceland_jack> *is no
23:33:07 <marx2> Iceland_jack maybe not. still doesn't prove runIdentity, fromJust and unsafePerformIO aren't similar
23:33:25 <Iceland_jack> Please don't talk about ‚Äòproofs‚Äô
23:33:33 <Iceland_jack> they have a common type signature, that's about it
23:33:36 <johnw> marx2: runIdentity is a total function, fromJust is a partial one, and unsafePerformIO has effects.  They are three completely different functions
23:33:50 <Iceland_jack> what johnw said
23:33:50 <pavonia> What was Edward Kmett's IRC nick again?
23:33:56 <johnw> edwardk
23:34:03 <pavonia> Thanks!
23:34:06 * ReinH wonders how long it will take for the rest of you to figure out that marx2 is a troll
23:34:09 <johnw> He's in Banff giving a talk this weekend, which is why he's not around
23:34:19 <ReinH> johnw: which is rude... I wanted to talk to him :p
23:34:26 <marx2> Iceland_jack but in the case of specific monads (IO, Identity) they do similar things
23:34:28 <Iceland_jack> ReinH: I'm a sucker for arguments :)
23:34:36 <Iceland_jack> so what
23:34:38 <ReinH> Iceland_jack: me too, to my own detriment :)
23:34:55 <Iceland_jack> so does head ‚à∑ [a] ‚Üí a and last ‚à∑ [a] ‚Üí a
23:35:07 <marx2> Iceland_jack yes they do
23:35:40 <johnw> marx2: are you just thinking in terms of the abstract type?  like, if it fits the pattern "m a -> a", then they are similar?
23:35:54 <nisstyre> ReinH: well his name makes me consider it more
23:36:03 <nisstyre> johnw: I already asked that
23:36:13 <nisstyre> <nisstyre> marx2: you seem to think that because both IO a -> a and Identity a -> a  ‚äÜ Monad m => m a -> a that they are "equivalent", right?
23:36:20 <johnw> marx2: http://hackage.haskell.org/package/pointed-4.0/docs/Data-Copointed.html
23:36:28 <nisstyre> but he doesn't think that
23:36:37 <nisstyre> he thinks that they have the same semantics
23:36:40 <johnw> that's the similarity you're thinking about, but there's no Maybe or IO instance for a reason
23:36:48 <johnw> nisstyre: huh
23:36:57 <johnw> nisstyre: well, the truth will out eventually
23:37:04 <nisstyre> johnw: he thinks IO contains a "value" in the same way that Maybe does
23:37:07 <ReinH> johnw: The clearest statement of intent I've seen is that the equivalence relationship is the observation that f (return x) = x
23:37:15 <nisstyre> or Identity rather
23:37:16 <johnw> even Maybe only "contains" a value half of the time!
23:37:17 <marx2> same semantics being:  run the IO monad and return the value outside of the monadic context
23:37:18 <nisstyre> since Maybe might not
23:37:21 <nisstyre> yeah
23:37:52 <johnw> well, that was fun; anybody have another question?
23:37:52 <marx2> (the value being the result of the computation. in the case of Identity monad, computation is just id)
23:38:13 <ReinH> what can we say about functions for which this equivalence holds? If it's that their monads somehow "contain values" then this is circular reasoning
23:38:27 <arkeet> so I'm reading the scrollback.
23:38:28 <arkeet> wat
23:38:31 <ReinH> arkeet: yeah.
23:38:35 <Iceland_jack> yup.
23:38:48 <mm_freak_> a channel without monads isn't worth joining
23:38:57 <ReinH> mm_freak_: you can join but you can never leave
23:39:01 <ReinH> Hotel California Monad
23:39:10 <nisstyre> marx2: how does that work for the Monad instance ((-> r) ?
23:39:11 <Iceland_jack> *groan*
23:39:15 <ReinH> Iceland_jack: :D
23:39:19 <nisstyre> er ((->) r)
23:39:20 <marx2> nisstyre I never said it works for all monads
23:39:26 <nisstyre> marx2: ok, fair enough
23:40:04 <mm_freak_> oh, are we back to burritos?
23:40:15 <nisstyre> marx2: then this has nothing at all to do with monads
23:40:30 <johnw> at least burritos contain something
23:40:33 <marx2> nisstyre it has to do with some Monads
23:40:38 <ReinH> usually, deliciousness
23:40:39 <johnw> a real monadic burrito would be... interesting
23:40:40 <marx2> IO, Identity, Maybe
23:40:49 <nisstyre> marx2: yes but it's just a fact which isn't really relevant to what you're saying
23:40:50 <Iceland_jack> marx2: Not this again‚Ä¶
23:41:01 <mm_freak_> here is an interesting container monad:  data Unit a = Unit
23:41:09 <ReinH> So you can take a function for making burritoes and make a burrito out of it
23:41:18 <mm_freak_> it contains a certain number of values of type 'a'
23:41:23 <Iceland_jack> mm_freak_: Already covered ;) look for data Null a = Null above
23:41:42 <mm_freak_> =)
23:41:59 <ReinH> There is literally nothing more here than "exists f such that f (return x) = x"
23:42:17 <mm_freak_> anyway, reader monads can still be thought of as arrays, so the container analogy still applies
23:42:34 <johnw> or how about this one: https://gist.github.com/7746286
23:42:40 <johnw> it "contains" ‚ä•!
23:42:42 <marx2> nisstyre, you can replace runIdentity with unsafePerformIO in here and get the same result. so they are equivalent by defintion.  runIdentity (return 10)
23:43:08 <nisstyre> marx2: maybe in some weird platonic sense
23:43:13 <Iceland_jack> johnw: #haskell makes me hungry sometimes :)
23:43:16 <mm_freak_> however, here is one where the analogy breaks down:  data Reentry k a = Reentry a (Map k (Reentry a))
23:43:21 <Ralith> that's not what "by definition" means
23:43:32 <marx2> I thought you ignored me?
23:43:49 <Iceland_jack> marx2: That was ReinH ‚Ä¶?
23:43:56 <nisstyre> mm_freak_: how about type Cont r = ContT r Identity
23:44:01 <ReinH> Did... did he just mistake me for someone else?
23:44:08 <Iceland_jack> <Ralith> that's not what "by definition" means
23:44:08 <Iceland_jack> <marx2> I thought you ignored me?
23:44:10 <ReinH> Trolly troll is a troll.
23:44:16 <Iceland_jack> ReinH: :D
23:44:17 <mm_freak_> nisstyre: i'm pretty sure Cont is isomorphic to some container type =)
23:44:24 <marx2> and he still keeps pretending, this is hilarious :)
23:44:31 <ReinH> mm_freak_: to a burrito, yes
23:45:04 <ReinH> Here we observe the troll in its native habitat.
23:45:54 <pdxleif> expected type: Prelude.FilePath, Actual type: Filesystem.Path.CurrentOS.FilePath
23:45:58 <pdxleif> boo
23:46:03 <ReinH> I wonder how long we're going to be talking about how runIdentity is like unsafePerformIO. Does the troll eventually tire of its prey?
23:46:22 <mm_freak_> i think the best metaphor about monads i've read is the "warm fuzzy thing" metaphor‚Ä¶  and i'm serious about that =)
23:46:40 <arkeet> protip: given any foo :: M a -> a (for some Monad M), foo (return x) will always be x (or possibly something less defined)
23:46:50 <ReinH> mm_freak_: My favorite metaphor about monads is how they're like a monoid of endofunctors.
23:47:02 <ReinH> I really like the allusion.
23:47:04 <marx2> ReinH can you be any more childish?  first you insult me, then you ignore me (or rather, petend to), while still keep talking about me
23:47:57 <mm_freak_> marx2: allow us to return to more useful topics after a bunch of easy jokes =)
23:48:04 <arkeet> (follows from the free theorem for foo . return :: a -> a)
23:48:10 <mm_freak_> in other words, stop the insults, both sides
23:48:35 <ReinH> arkeet: right, just as there can be at most one valid functor instance of a given type
23:49:10 <arkeet> (also ignoring the existence of unsafeCoerce)
23:49:27 <ReinH> which follows similarly from the free theorem for foo id = id :: a -> a
23:49:36 <arkeet> no, that uses a different free theorem.
23:49:49 <ReinH> arkeet: It does?
23:49:53 <ReinH> go on :)
23:49:54 <arkeet> it uses the one for (a -> b) -> F a -> Fb
23:49:58 <arkeet> F b
23:50:09 <ReinH> right, I meant a different foo
23:50:14 <arkeet> @free fmap' :: (a -> b) -> F a -> F b
23:50:14 <lambdabot> g . h = k . f => $map_F g . fmap' h = fmap' k . $map_F f
23:50:21 <ReinH> where foo = fmap
23:51:26 <arkeet> from which it follows that fmap' f = fmap f . fmap' id
23:51:51 <arkeet> ($map_F is fmap)
23:52:03 <mm_freak_> @djinn () -> Bool
23:52:03 <lambdabot> f _ = False
23:52:10 <ReinH> arkeet: which is fine... I always thought fmap should be mapF :)
23:52:23 <mm_freak_> there should be an alternative @djinn that rejects non-unique solutions
23:52:36 <arkeet> or maybe it could just warn?
23:52:46 <ReinH> @whiskey, the @djinn alternative?
23:52:46 <lambdabot> Unknown command, try @list
23:52:46 <mm_freak_> or that
23:52:57 <mm_freak_> @whisky, please
23:52:57 <lambdabot> Unknown command, try @list
23:53:00 <ReinH> :p
23:53:11 <ReinH> I am an equal oportunity whiske?y drinker
23:53:21 <mm_freak_> whatever that means for you =)
23:53:47 <Iceland_jack> @choose whiskey cake
23:53:47 <lambdabot> cake
23:53:50 <Iceland_jack> oh well
23:53:58 <mm_freak_> what?!
23:54:01 <mm_freak_> @choose 1 2 3 4 5 6
23:54:01 <lambdabot> 3
23:54:50 <ReinH> arkeet: ah, of course it was roconnor http://article.gmane.org/gmane.comp.lang.haskell.libraries/15384
23:55:18 <arkeet> :)
23:55:52 <ReinH> arkeet: so it's the free theorem for (a -> b -> f a -> f b, but foo id = id is used.
23:55:55 <ReinH> Ok, sure.
23:56:02 <arkeet> I think that's what I said?
23:56:37 <johnw> arkeet: I updated these for you
23:56:43 <ReinH> arkeet: I think it is too, I'm just making sure I understand
23:59:07 <arkeet> johnw: I saw that
23:59:17 <arkeet> did you catch my other pull request
23:59:22 <johnw> let me check
23:59:32 <arkeet> nope
23:59:46 <johnw> ah, I'll do that now
