00:00:00 <johnw> so really it's flip fmap
00:00:07 <arkeet> yes
00:00:12 <johnw> thanks, arkeet
00:00:19 <johnw> i will use it
00:01:21 <Sgeo> Also, quasiquoters can't be nested in each other
00:01:23 <Sgeo> >:(
00:01:27 <arkeet> :t let _1 f (a,x) = f a <&> \b -> (b,x) in _1
00:01:28 <lambdabot> Functor f => (t -> f t1) -> (t, t2) -> f (t1, t2)
00:02:12 <mgsloan> Sgeo: With haskell-src-meta, they could be.  Just noone's written a library to make it convenient
00:02:29 <arkeet> mgsloan: isn't it more like |] always terminates a quasiquote?
00:02:30 <mgsloan> (although haskell-src-meta isn't exactly complete)
00:02:53 <mgsloan> arkeet: Well, that too, you'd need a different syntax for the internal quasiquotes
00:02:56 <mgsloan> Good point!
00:02:57 <arkeet> exactly
00:03:51 <Sgeo> Or, just have the quasiquoter decide when the syntax ends
00:03:55 <Sgeo> ala Factor
00:04:01 <mgsloan> That'd be pretty interesting
00:07:40 <mgsloan> Sgeo: Have you taken a look at "Sugar Haskell"?  It seems pretty darn promising, though I'm not sure if it's really available for use
00:07:53 <Sgeo> Hadn't heard of it before now
00:09:15 <ion> Was it the thing implemented in Java?
00:09:43 <mgsloan> It was implemented by the same guys as "SugarJ", so maybe so
00:10:15 <ion> It was very interesting otherwise, but a Java dependency is a bit too much for some of us. :-P
00:10:30 <mgsloan> I hear ya :D
00:10:53 <mgsloan> Could provide a nice template for a ghc plugin, though
00:11:01 <ion> yeah
00:11:10 <mgsloan> Although I think the current plugin system is oriented more towards the backend of the compiler
00:11:19 <mgsloan> Not 100% sure
00:19:40 * hackagebot artery 0.1 - A simple, arrow-based reactive programming  http://hackage.haskell.org/package/artery-0.1 (FumiakiKinoshita)
00:23:21 <johnw> i wonder if he meant archery...
00:24:08 <johnw> k
00:29:41 * hackagebot laborantin-hs 0.1.4.0 - an experiment management framework  http://hackage.haskell.org/package/laborantin-hs-0.1.4.0 (LucasDiCioccio)
00:38:22 <notadog> Hi, I am new to haskell, and my program runs correctly when I run it with runhaskell/runghc, but if I compile with ghc --make program.hs and then do ./program it doesn't run properly.
00:39:57 <notadog> The program is a simple window with 9 buttons that each read a command from a file and then execute it.
00:40:12 <identity> notadog: can you provide more detail, perhaps source code andexpected output / bad output?
00:40:17 <identity> oh, it's a GUI program?
00:41:55 <notadog> Both actually, when run with arguments it runs as a CLI program, without arguments it runs a GUI.
00:44:11 <notadog> Expected output/system interaction is that when I press the button labeled "urxvt -e vim" it runs  that using rawSystem. This happens when using runhaskell but not whencompiling then running.
00:47:37 <identity> notadog: I believe it may have something to do with the fact that you don't have a terminal to run that in, so to speak. I'm not quite sure, however. You might want to look at something like ..
00:47:41 <identity> @hoogle process
00:47:42 <lambdabot> package process
00:47:42 <lambdabot> package process-conduit
00:47:42 <lambdabot> package process-extras
00:48:03 <identity> probably process
00:48:32 <identity> @hoogle shell
00:48:33 <lambdabot> System.Process shell :: String -> CreateProcess
00:48:33 <lambdabot> package shell-escape
00:48:33 <lambdabot> package shell-pipe
00:48:41 <identity> shell might do the trick for you
00:49:00 <identity> e.g. createProcess (shell "your command")
00:49:00 <Philonous> notadog, Just a very wild guess here, but try compiling with --threaded
00:49:33 <identity> ah, rawSystem is also in process
00:49:54 <identity> but that might also work yes
01:08:02 <notadog> thanks identity and Philonous, adding the -threaded flag fixed it. I guess because I am using forkIO(function that runs the program/command and returns '()')
01:28:34 <brtaylor92_> I have a question about type notation in declarations.  I was reading some example code earlier on how to get user input as a particular type, and it defined a function getInt :: IO Int. I"m more used to seeing things like function :: a -> b. Why does getInt not use the -> notation?
01:30:10 <arkeet> because it's not a function
01:31:12 <johnw> getInt is an "IO action", which when evaluated will do something and yield an Int; it doesn't therefore require an argument
01:31:34 <brtaylor92_> so what does the statement :: IO Int mean?
01:32:01 <johnw> is it not a function in the mathematical sense, since it's functionality is constant -- it's the result that varies when executed.  In imperative languages they call this a function too, but not in Haskell
01:32:24 <brtaylor92_> right - my apologies for that. I started in on Haskell yesterday. Still new to the terminology.
01:32:27 <johnw> ":: IO Int" means that the type of the identifier is an IO action that yields an Int
01:32:42 <jle`> brtaylor92_: you can think of it as an object that contains instructions to retrieve an int
01:33:02 <jle`> instructions for a computer
01:33:51 <brtaylor92_> So in the general case you can't just do ":: a b" unless a is an action? (action here means has a side effect? what defines an action?)
01:33:53 <jle`> when you do something like main = getLine, you are saying that "my program *is* this object that contains instructions to retrieve a string."  Then, when you r program is compiled, whatever instruction object is set to main will be the instruction set that is run
01:34:04 <jle`> by the computer
01:34:10 <johnw> brtaylor92_: that's a long road, which I would recommend delaying for a bit
01:34:33 <brtaylor92_> does the first part of the question at least have an easy answer?
01:34:56 <johnw> not without the right common vocabulary
01:35:22 <johnw> stick with pure functions and how to work with them first, that will build some clarity
01:35:28 <jle`> ^^
01:35:59 <johnw> (although all functions are pure, by that I mean functions of the type "a -> b")
01:36:23 <jle`> there is an example that you probably have encountered in your life before
01:36:25 <brtaylor92_> Alright.  My first instinct for picking up a new language is to go rewrite some old class exercises in it, but I suppose that's not the best way to go about learning Haskell; too many IO requirements...
01:36:32 <jle`> of an object that contains instructions
01:36:33 <johnw> right
01:36:54 <johnw> a great thing to do in Haskell would be to define your own List type, and write a bunch of functions for manipulating lists in various ways
01:37:33 <johnw> that will get you comfortable with functions, composition, recursion, folds, etc.
01:39:12 <Philonous> brtaylor92_, In haskell, types can depend on other types. For example the type (Maybe a). This in and of itself has nothing to do with side effects or actions.
01:39:39 <brtaylor92_> what's the proper pronunciation of the "->" ? My first instinct was to think of it as " a -> b" meaning "from a to b", but since f(x,y) = z isn't "x y ->z" but rather "x->y->z", that's clearly not right
01:40:15 <jle`> you can
01:40:19 <Philonous> brtaylor92_, Actually f (x,y) = z is (x,y) -> z (iff x,y and z have types x,y and z respectively)
01:40:20 <jle`> put an imaginary parentheses there
01:40:23 <jle`> cognitively
01:40:30 <jle`> pretend it's a comma for now
01:40:30 <johnw> a maps to b, a to b, etc.  your instinct was a good one
01:40:34 <jle`> until you learn about currying
01:40:41 <johnw> x -> y -> z is the same thing as x -> (y -> z)
01:41:22 <johnw> so, x maps to a function which maps y to z.  The fact that you can use it like a function taking two arguments is a very cool trick called currying, which jle` mentioned
01:41:31 <jle`> if we're going to talk about currying
01:41:40 <jle`> you know the function  (+)
01:41:44 <jle`> which takes two arguments and adds them
01:41:46 <jle`> > (+) 1 2
01:41:48 <lambdabot>  3
01:41:48 <brtaylor92_> ah, ok... so on some level, all haskell functions are single argument? and then we can just sugar that away?
01:41:54 <johnw> brtaylor92_: exactly
01:42:17 <jle`> brtaylor92_: it's technically not sugar, because of the way function calls associate
01:42:23 <brtaylor92_> this channel has a lambdabot... I like you guys more by the minute
01:42:43 <jle`> for example if you have (+) 1 2, it's the same as ((+) 1) 2
01:42:47 <brtaylor92_> are we using associate in the way I expect? (as in associative property of e.g. addition and so on?)
01:42:53 <johnw> yes
01:42:54 <brtaylor92_> ok, yes we are
01:43:10 <jle`> anyways, what do you get when you just do (+) 1?
01:43:16 <jle`> :t (+) 1
01:43:17 <lambdabot> Num a => a -> a
01:43:19 <brtaylor92_> 1, I assume?
01:43:27 <jle`> look at the type of (+)
01:43:29 <jle`> :t (+)
01:43:29 <lambdabot> Num a => a -> a -> a
01:43:40 <jle`> a -> (a -> a)
01:43:51 <jle`> it takes a number and returns a function that takes a number that returns a number
01:44:02 <jle`> so (+) 1 is a function that takes a number and returns a number
01:44:09 <jle`> @let incr = (+) 1
01:44:11 <lambdabot>  Defined.
01:44:14 <jle`> :t incr
01:44:14 <lambdabot> Num a => a -> a
01:44:19 <jle`> > incr 2
01:44:22 <lambdabot>  3
01:44:25 <brtaylor92_> putting those parens around the english version - plus takes a number and returns (a function that takes a number and returns a number)?
01:44:31 <jle`> mhm
01:44:45 <jle`> so when i have (+) 1, it is a function that takes any number and adds 1 to it
01:44:52 * hackagebot SFML-control 0.2.0.1 - Higher level library on top of SFML  http://hackage.haskell.org/package/SFML-control-0.2.0.1 (AlfredoDiNapoli)
01:45:20 <dmj`> jle`: explaining infix operators as well might be useful here
01:45:36 <brtaylor92_> I did already see how infix works in one of the tutorials
01:45:39 <brtaylor92_> it makes enough sense
01:45:50 <jle`> what's another common function that takes two arguments.
01:45:52 <jle`> hm
01:45:55 <brtaylor92_> well, how it works may be too broad - how to use it
01:45:56 <johnw> brtaylor92_: welcome to Haskell btw :)
01:46:01 <brtaylor92_> johnw: thanks =)
01:46:28 <brtaylor92_> one of those things I've been meaning to pick up for a couple years, finally feel like I have both the math background and the free time to do it
01:46:35 <Philonous> I think it's intuitively clear what the "plus one" function does. In haskell you can just write it as (+1)
01:46:58 <Philonous> Or ((+) 1)
01:47:02 <jle`> (+) 1 is slightly different than (+1) but very subtle-y
01:47:14 <brtaylor92_> Philonous: on the simple grounds that I didn't see what it did until jle` wrote it out long form, I'm going to disagree
01:47:28 <jle`> (+1) is actually syntactical sugar
01:47:34 <johnw> yeah, (+) 1 is technically (1+)
01:47:43 <jle`> (1+) is sugar :P
01:47:44 <Philonous> brtaylor92_, If I told you to apply the "plus one" function to 4 you couldn't guess what I mean?
01:47:47 <brtaylor92_> I'm going to have to move my ` to somewhere more convenient
01:48:01 <jle`> well, it is not immediately apparent that (+) 1 is the "plus one" function
01:48:07 <jle`> he initially thought it was just the number 1
01:48:10 <brtaylor92_> I could guess what you meant, but that's more of a notational issue - I wouldn'tve been able to write out the type, or tell you why that function was valid
01:48:32 <brtaylor92_> jle`: rather, I thought its result was the number 1
01:48:34 <akegalj> :t fmap
01:48:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:48:42 <brtaylor92_> I hadn't thought of it in terms of a function returning a function
01:48:43 <Philonous> brtaylor92_, Yes ok, all I meant was that you already had a notion of partial application.
01:48:51 <jle`> brtaylor92_: have you learned about map?
01:49:04 <jle`> partial application's immediate usefulness is in map and stuff.
01:49:07 <akegalj> how come i can apply fmap (+1) (+2) when fmap takes f a as second argument ?
01:49:23 <akegalj> where f is functor
01:49:31 <Philonous> akegalj, ((->) r) is a functor
01:49:32 <jle`> akegalj: your second argument is, believe it or not, a functor
01:49:52 <jle`> all functions are functors
01:49:54 <dmj`> akegalj: What is the Functor instance for functions?
01:49:56 <jle`> fmap is (.) or something?
01:49:57 <brtaylor92_> map as in something like (map (3*) someList) to multiply all elements by 3?
01:50:04 <jle`> brtaylor92_: yes
01:50:10 <jle`> ah you got it
01:50:14 <johnw> the result of fmap (+1) (+2) is the same thing as (\x -> (x + 2) + 1), if that helps
01:50:21 <jle`> see, withohut partial application, we'd have to do something like
01:50:30 <jle`> > map (\x -> 3*x) [1..10]
01:50:32 <lambdabot>  [3,6,9,12,15,18,21,24,27,30]
01:50:43 <brtaylor92_> jle`: yeah, I had a good intuition for what map would do from python. just did a quick search for haskell syntax.
01:50:44 <jle`> but now we can just generate new functions on our own whim
01:50:55 <dmj`> akegalj: fmap (+1) (+2) == (+1) `fmap` (+2) == (+1) . (+2)
01:50:59 <jle`> in python you would have had to do the same thing, define out your function in terms of x
01:51:07 <jle`> but now we don't even need to mention x
01:51:12 <jle`> or any 'points' for that matter
01:51:28 <jle`> compare map (\x -> 3*x) [1..10] to map (3*) [1..10]
01:51:43 <johnw> jle`: in the case of operators, there's the additional syntax rule of an "operator section"
01:51:47 <brtaylor92_> what's the \ syntax?
01:51:50 <jle`> oh
01:51:53 <akegalj> dmj, jle` Philonous : whau, thats cool. But i need to think it over to grasp it
01:51:54 <jle`> it's anonymous function
01:52:01 <arkeet> analogous to lambda in python
01:52:15 <arkeet> ( \ is read "lambda")
01:52:20 <jle`> it's shorthand for saying something like (myfun x = 3*x), but without a name.
01:52:22 <brtaylor92_> ah, alright
01:52:25 <arkeet> (because it looks vaguely like λ)
01:52:31 <jle`> if you squint hard enough :)
01:52:35 <brtaylor92_> the important half of lambda
01:52:50 <jle`> > filter (< 3) [1..10]
01:52:52 <lambdabot>  [1,2]
01:53:01 <Philonous> akegalj, If you want to figure out what fmap is just look at it's type: fmap :: (a -> b) -> (r -> a) -> (r -> b)
01:53:15 <jle`> btw the (< 3), (3*), etc. is syntactical sugar
01:53:22 <jle`> the number goes in "the missing spot"
01:53:36 <brtaylor92_> the parens make it sugar, or..?
01:53:44 <jle`> so in (< 3) 2, the 2 goes in the empty left side of the <
01:53:47 <Sgeo> > (+ 2 * 3) 4
01:53:49 <lambdabot>  10
01:53:54 <akegalj> Philonous: thats what bothers me, thats not the type of fmap?
01:53:56 <Sgeo> > (* 2 + 3) 4
01:53:57 <lambdabot>  The operator `GHC.Num.*' [infixl 7] of a section
01:53:57 <lambdabot>      must have lower precedence than that of the operand,
01:53:57 <lambdabot>        namely `GHC.Num.+' [infixl 6]
01:53:57 <lambdabot>      in the section: `* 2 + 3'
01:54:12 <jle`> it's sugar because you aren't supposed to be able to use operators without both sides
01:54:20 <Philonous> akegalj, Yes it is, if you specialise f to ((->) r)
01:54:22 <jle`> remember, < is different than (<)
01:54:26 <johnw> akegalj: think about what it means for a functor to be a functor
01:54:32 <johnw> a function to be a functor
01:54:40 <jle`> (<) is a prefix function, < is an operator between two ord's
01:54:52 <jle`> so when you do something like (< 3), it's not really supposed to make sense
01:55:00 <brtaylor92_> jle`: I suppose that's my question - what about the ()s makes one a prefix and one an infix?
01:55:03 <jle`> so the sugar is that it interprets (< 3) as a function with something "waiting" to go on the left side
01:55:18 <jle`> brtaylor92_: it's er...enforced by the language
01:55:29 <jle`> if your function is only made up of symbols
01:55:35 <jle`> then it is automatically an infix operator
01:55:44 <jle`> and you can turn it into a prefix function with (<)
01:55:48 <dmj`> jle`: important to note order matters (<3) vs. (3<)
01:56:01 <jle`> yeah in the second case, the 'missing spot' is on the right
01:56:01 <Philonous> akegalj, So fmap :: (a -> b) -> f a -> f b. Not set f = ((->) r) and it becomes fmap :: (a -> b) -> ((->) r a) -> ((->) r b) or written infix: fmap :: (a -> b) - > (r -> a) -> (r -> b)
01:56:01 <akegalj> Philonous, johnw : oh.. i think i get it... so second argument may be function couse when supplied with aditional argument it would become a functor? something like this?
01:56:10 <brtaylor92_> is it a language design decision, or a necessary result of some other language feature?
01:56:20 <jle`> brtaylor92_: i think it's pretty convenient
01:56:22 <Philonous> akegalj, s/not/now
01:56:31 <jle`> haskell people love defining their own operators
01:56:41 <brtaylor92_> I can understand that decision
01:56:43 <brtaylor92_> err
01:56:45 <brtaylor92_> desire
01:56:53 <jle`> i don't think it is a consequence of another feature
01:57:08 <jle`> it's just an enforced naming convention
01:57:14 <jle`> just like how all variables have to start with a lowercase letter
01:57:23 <jle`> or in ruby, variables that start with $ are global variables
01:57:31 <dmj`> Philonous: great explanation
01:57:31 <johnw> akegalj: given a functor "f a", it can be thought of as a "context" (f) related to a "type" (a).  In the case of a function, the context is the argument and the type is the return value, so when you fmap, you are mapping a function over the return value without affecting the argument
01:57:50 <brtaylor92_> I was just wondering if the "any function with only symbols is an infix operator" was because that's how haskell works, and it couldn't be any other way without changing other parts of the language, or if it was a convenient thing to add
01:58:08 <jle`> well
01:58:10 <brtaylor92_> I'm still not phrasing that question very well...
01:58:17 <akegalj> Philonous: can you explain me the ((->) r) syntax?
01:58:20 <jle`> no, it was a conscious design decision
01:58:23 <johnw> brtaylor92_: except for the special case of unary minus :)
01:58:37 <jle`> but it conforms with what you would expect
01:58:37 <brtaylor92_> johnw: having taken a compilers course recently, </3 unary minus
01:58:52 <jle`> 4 + 3 should be 'expected' to be infix, blah
01:59:04 <brtaylor92_> ok
01:59:05 <jle`> cognitively
01:59:06 <brtaylor92_> makes sense
01:59:09 <Philonous> akegalj, (->) is a type constructor, like Maybe. So you can partially apply it
01:59:20 <johnw> akegalj: ((->) r) would have been (r ->) if type operators could be sectioned
01:59:22 <Philonous> akaposi, It's not usually written in prefix form but you can
01:59:29 <Sgeo> Haskell has so many features that can make writing hard-to-follow code easy
01:59:42 <Sgeo> I think, maybe Ada is safer, although I don't really know Ada
02:00:00 <dmj`> brtaylor92_: by default any function with symbols as defined in the haskell report is infix, o/w it is prefix. so map if prefix by default, `map` is infix. + is infix by default, (+) is now prefix
02:00:04 <jle`> wait until you see that data and type constructors can be infix'd.
02:00:09 <jle`> now that's annoying.
02:00:12 <jle`> (at first)
02:00:13 <Sgeo> But... user-defined precedence of operators, somewhat tricky to determine memory usage in some cases
02:00:22 <Philonous> akegalj, ((->) a b) is the same as (a -> b)
02:00:59 <brtaylor92_> another question - why && || and not vs && || ! - does ! do something else? is there builtin factorial?
02:01:01 <akegalj> Philonous, johnw : is (->) explecitly defined somewhere?
02:01:17 <Philonous> akegalj, No, it's built into the compiler
02:01:19 <Sgeo> Ada has a rule where you can't have a and b or c without parenthesizing one of the parts... it provides a form of safety that I think Haskell rejects in favor of concision
02:01:19 <johnw> akegalj: no, it's syntax
02:01:21 <jle`> ask about (/=) too
02:01:52 <dmj`> pretty sure (!) is for arrays, definitely not in prelude
02:01:59 <dmj`> @typ (!)
02:02:00 <lambdabot> Ix i => Array i e -> i -> e
02:02:06 <johnw> I think ! works on maps too
02:02:21 <jle`> (!) is usually unsafe, right?
02:02:23 <akegalj> Philonous, johnw : ok. So Functor f => ((->) r)   ==  (r a) ?
02:02:25 <jle`> that's why it looks so alarming?
02:02:26 <johnw> :t (Data.Map.!)
02:02:27 <lambdabot> Ord k => M.Map k a -> k -> a
02:02:56 <jle`> apparently so
02:03:06 <johnw> akegalj: for the function functor, f a ~ r -> a
02:03:20 <johnw> since f in that case is ((->) r)
02:03:29 <brtaylor92_> jle`: so what does it do?
02:03:45 <jle`> brtaylor92_: oh in arrays it's an indexing
02:03:47 <johnw> and thus you write instance Functor ((->) r) where fmap f x = f . x
02:03:51 <jle`> like a[3], you'd do a ! 3
02:04:07 <jle`> it's unsafe because it's a partial function
02:04:09 <dmj`> johnw: Ah didn't know that, cools
02:04:18 <jle`> in haskell we don't like partial funconis
02:04:22 <jle`> funconis?
02:04:23 <akegalj> johnw: that instance is also builtint?
02:04:27 <akegalj> builtin *
02:04:27 <dmj`> > (fromList [(1,1)] :: Map Int Int) ! 1
02:04:29 <lambdabot>  Not in scope: type constructor or class `Map'
02:04:29 <lambdabot>  Perhaps you meant `M.Map' (imported from Data.Map)Not in scope: `fromList'
02:04:29 <lambdabot>  Perhaps you meant one of these:
02:04:29 <lambdabot>    `IM.fromList' (imported from Data.IntMap),
02:04:29 <lambdabot>    `M.fromList' (imported from Data.Map),
02:04:29 <Philonous> akegalj, I don't know what that means. But ((->) r) or "(r -> )" or "the type of all functions from type r" is an instance of the Functor type class
02:04:31 <johnw> akegalj: it's part of the Prelude
02:04:54 <brtaylor92_> jle`: thought you used !!3 for indexing? is !! just repeated application of ! and not its own token?
02:05:02 <jle`> :t (!!)
02:05:04 <lambdabot> [a] -> Int -> a
02:05:05 <jle`> :t (!)
02:05:06 <lambdabot> Ix i => Array i e -> i -> e
02:05:10 <akegalj> Philonous, johnw : i think i finaly grasp it now. thnx :)
02:05:15 <dmj`> (M.fromList [(1,1)] :: M.Map Int Int) ! 1
02:05:17 <johnw> (!!) is a different operator name from (!)
02:05:20 <jle`> they are indexing for different types
02:05:21 <dmj`> > (M.fromList [(1,1)] :: M.Map Int Int) ! 1
02:05:22 <lambdabot>  Couldn't match expected type `GHC.Arr.Array i0 e0'
02:05:23 <lambdabot>              with actual type `Data.Map.Base.Map GHC.Types.Int GHC.Types.Int'
02:05:35 <jle`> i think operators have to be saprated by spaces
02:05:41 <jle`> actually (!) is not a keyword/token
02:05:44 <jle`> it's just a normal function
02:05:47 <johnw> > 4+3
02:05:48 <lambdabot>  7
02:05:51 <johnw> they don't have to be
02:05:51 <jle`> that you can probably write yourself at this point
02:06:01 <brtaylor92_> jle`: differences between array and list?
02:06:06 <johnw> > [1,2,3]!!1
02:06:07 <lambdabot>  2
02:06:07 <jle`> yes, look at the types
02:06:08 <akegalj> Philonous, johnw : so every function that is missing one argument is functor, and generaly every function
02:06:19 <dmj`> > (M.fromList [(1,1)]) M.! 1
02:06:21 <lambdabot>  1
02:06:22 <johnw> akegalj: what is a function that is missing an argument?
02:06:28 <jle`> but you could define your own (!!) and (!) for any data type you wanted
02:06:34 <jle`> you could even define a (!!!)
02:06:40 <akegalj> johnw: i know.. it's a function
02:06:48 <jle`> @src (!!)
02:06:49 <lambdabot> xs     !! n | n < 0 = undefined
02:06:49 <lambdabot> []     !! _         = undefined
02:06:49 <lambdabot> (x:_)  !! 0         = x
02:06:49 <lambdabot> (_:xs) !! n         = xs !! (n-1)
02:06:49 <illissius> Hi. Anyone know somewhere I can download binaries for a reasonably recent version of GHC 7.8 for x86-32?
02:06:50 <jle`> magic gone :)
02:06:59 <illissius> (linux)
02:07:00 <johnw> akegalj: every function is a functor over its return type, if that's what you mean...
02:07:06 <dmj`> is 7.8 out yet?
02:07:23 <illissius> no
02:07:23 <Feuerbach> no
02:07:37 <jle`> if you know about pattern matching and recursion then you should be able to understand it
02:07:51 <jle`> and guards
02:07:54 <jle`> heh
02:07:56 <akegalj> johnw: yes... can that return type be function or does it need to be value?
02:08:04 <johnw> akegalj: it can be any type
02:08:13 <johnw> a -> b -> c is a functor over b -> c
02:08:27 <akegalj> johnw: oh, thats cool
02:08:27 <jle`> you can also see that it is clearly a partial function
02:08:30 <johnw> which is itself a functor over c :)
02:08:36 <brtaylor92_> jle`: don't follow the last rule... we're stripping off the beginning of the list one element at a time until we hit the index = 0 case?
02:08:38 <jle`> (it is not defined over all inputs)
02:08:43 <jle`> brtaylor92_: exactly
02:08:45 <Philonous> Since (a -> b -> c) = (a -> (b -> c)) you can just set r = (b -> c)
02:09:03 <akegalj> Philonous, johnw: yes, thats great
02:09:05 <johnw> Philonous: in that case, isn't r = a?
02:09:08 <jle`> basically [1,2,3,4] !! 2 ==> [2,3,4] !! 1 ==> [2,3] !! 0 = 2
02:09:09 <Philonous> Err, r = a
02:09:20 <Philonous> johnw, Yes, that was unfortunate
02:09:32 <jle`> i probably spoiled a good exercise for you though unfortunately
02:09:39 <johnw> akegalj: functors are quite amazing creatures, and pretty undersold; there is lots of good meat in that subject
02:09:57 <akegalj> Philonous, johnw : yea, i didnt quite understood before why are functors so cool, but i get it now. thnx all
02:09:59 <brtaylor92_> jle`: I wouldn't have thought to do it recursively yet. I'm assuming haskell has no concept of a for loop?
02:10:08 <johnw> in fact, if people spent more time with functors, monads would be pretty trivial to understand
02:10:23 <jle`> brtaylor92_: could you think of how a for loop would work with all variables being immutable?
02:10:25 <dmj`> > forM_ [1..3] $ \x -> print x
02:10:26 <lambdabot>  <IO ()>
02:10:43 <brtaylor92_> jle`: it wouldn't. somewhat rhetorical question on both our parts, I suspect
02:10:43 <jle`> what would it even mean to have a (pure) for loop?
02:10:48 <jle`> mhm
02:10:57 <jle`> would you expect the answer to be collected in a list?
02:11:05 <jle`> or something
02:11:08 <jle`> how would you even get the result?
02:11:32 <Philonous> jle`, like in foldr ?
02:11:42 <brtaylor92_> nah, I understand that they don't make sense with immutable variables (is there a better term than variables? being immutable makes the term a bit contradictory). just going to take some getting used to not having
02:12:08 <jle`> brtaylor92_: of course. most of the 'difficulty' of haskell/fp is getting rid of your mental constructs you've built over the past several years
02:12:48 <jle`> brtaylor92_: but really like Philonous mentioned, the closest 'equivalent' to a for loop is fold
02:13:04 <jle`> it fulfils the role that for loops sort of fulfilled in imperative programming
02:13:06 <jle`> sorta kinda
02:13:09 <johnw> brtaylor92_: I asked that same question about the semantics of the word 'variable', but in fact it means something different from "the memory location that represents its value may vary"; we use variable in the mathematical sense of "this point varies with the result of the function"
02:13:55 <jle`> you actually could implement (!!) as a fold but it is less efficient, and it doesn't mesh well with laziness
02:13:57 <johnw> said another way, without variables all functions would reduce to constants
02:14:50 <jle`> you will learn about folds soon and in their proper context, hopefully
02:15:05 <dmj`> fold will return a summary value (which for loops could be used for), but for loops could be used like map as well, to transform a list
02:15:28 <Philonous> dmj`, You can implement map in terms of foldr
02:16:48 <jle`> map is a specialized fold...but i am not sure i ever gained anything from seeing it that way.  maybe you can think of it as for loops vs while loops.
02:17:09 <jle`> by 'you' i am not sure who i am referring to
02:17:54 <johnw> map is an "identity monoid homomorphism", whereas foldr generalizes to any monoid homomorphism, of which the identity is of course one
02:19:27 <timthelion> johnw: great example on why ensuring the most general algorithm is usually NOT good either from a design or preformance standpoint ;)
02:19:33 <brtaylor92_> ok, I actually followed most of that.
02:19:42 <reinoud> hi
02:19:46 <jle`> hi reinoud
02:20:07 <reinoud> hi
02:20:14 <reinoud> is colah around?
02:20:17 <reinoud> seen colah?
02:20:24 <reinoud> ah, no bot here
02:20:33 <johnw> preflex: seen colah
02:20:33 <preflex>  colah was last seen on #haskell 283 days, 14 hours, 22 minutes and 1 second ago, saying: For early prototyping, I'll probably just brute force things. But doing things right would be nice in the long run.
02:20:49 <jle`> immortal words
02:21:16 <Philonous> jle`, Why would (!!) implemented as a fold be less efficient and not mesh well with laziness?
02:21:28 <jle`> Philonous: how would you implement (!!) with fold?
02:21:54 <reinoud> yo!
02:22:11 <jle`> (i ask this in earnest as i am curious)
02:22:22 <reinoud> tnx johnw
02:22:26 <jle`> making sure that it works on an infinite list
02:22:40 <Philonous> jle`, Oh, never mind, you're right, I did something silly.
02:22:45 <reinoud> hmmm i wonder what happened to Christopher, he hasn't been online on his normal groups for quite some time it seems
02:23:14 <jle`> there should be some kind of short-circuit fold
02:23:17 <jle`> is there one?
02:23:25 <johnw> map snd $ filter ((== k) . fst) $ zip [0..] xs
02:23:42 <johnw> hmm.. doesn't play with infinite lists
02:23:43 <timthelion> jle`: mapM of course
02:23:44 <Feuerbach> jle`: yes, foldr
02:24:04 <jle`> timthelion: thanks!
02:25:02 <timthelion> jle`: I ran into the need for that in Elm(which doesn't have Tail call optimization but does have a native foldr)  Unfortunately no monads either.
02:25:42 <Feuerbach> foldr does need TCO
02:26:11 <timthelion> Feuerbach: Elm has "native(implemented as a javascript for loop) foldr
02:26:18 <jle`> it still boggles me that "native" means "native javascript"
02:26:29 <jle`> pure javascript
02:26:39 <jle`> i always have to do a double take
02:27:06 <timthelion> jle`: The crazy thing, is when you start compiling to Elm, and then you have "this part is hand compiled to the \"native\" elm code"...
02:27:08 <jle`> thinking about js, in context, 'native' over something else
02:27:16 <reinoud> off for now
02:27:18 <Feuerbach> timthelion: is it lazy?
02:27:36 <johnw> jle`: let fromLeft (Left x) = x; xs !! k = fromLeft $ foldM (\i x -> if i == k then Left x else Right (i + 1)) 0 [1..]
02:27:49 <timthelion> Feuerbach: all values of type a -> b are, but values of type a are not.
02:27:55 <timthelion> Feuerbach: No, it is strict.
02:28:02 <Feuerbach> ok, there you go
02:28:26 <johnw> s/[1..]/xs
02:28:33 <Feuerbach> in Haskell laziness is very important for foldr
02:28:46 <Feuerbach> it gives that capability to short-circuit
02:28:46 <jle`> i'll admit i never have actually used foldr
02:29:07 <johnw> i often use foldr when I'm folding a list to produce a list
02:29:08 <timthelion> Feuerbach: this leads to surprisingly many unexpected problems.  For example if /= to if' where if test a b = case test of True -> a ; False -> b
02:29:12 <johnw> otherwise I use foldl' a lot more
02:29:22 <timthelion> I meant to define if' there :P
02:29:56 <timthelion> Feuerbach: Oh! Aha! You're right :D
02:30:05 <Feuerbach> johnw: why not mapAccumL or something?
02:30:19 <Feuerbach> johnw: also, unfoldr
02:30:30 <johnw> Feuerbach: sure, I never think of that function because I've never used it before
02:30:40 <johnw> i thought about ufoldr too, but it yields a list
02:30:55 <johnw> i.e., at every decision point I need to provide an 'a', and it will gather those 'a's together
02:31:05 <skypers> hey, how do I know to know if I have some patches a remote repo doesn’t within darcs?
02:31:36 <timthelion> Feuerbach: I think that Evan(the author of Elm) didn't really understand lazyness when he designed the language.  I was talking to him a while back, and he was surprised to learn that a parser composed of multiple maps and folds in haskell compiles to a single pass.
02:31:42 <jle`> is there some function that wraps an item in a Just if a condition is true or is Nothing otherwise
02:32:17 <jle`> @hoogle (a -> Bool) -> a -> Maybe a
02:32:19 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
02:32:19 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
02:32:19 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
02:32:33 <johnw> timthelion: so he didn't understand stream fusion?
02:32:46 <johnw> jle`: mfilter
02:32:47 <Feuerbach> I don't think so. You could use a combination of guard and (<$), for example
02:32:53 <timthelion> johnw: Is that what stream fusion is?
02:33:13 <johnw> > mfilter (< 3) (Just 3)
02:33:15 <lambdabot>  Nothing
02:33:16 <johnw> > mfilter (< 3) (Just 4)
02:33:17 <lambdabot>  Nothing
02:33:25 <johnw> > mfilter (< 3) (Just 2)
02:33:26 <lambdabot>  Just 2
02:33:42 <Feuerbach> oh, I was thinking about a different use case
02:33:48 <johnw> timthelion: http://stackoverflow.com/questions/578063/what-is-haskells-stream-fusion
02:34:43 <johnw> basically, mfilter takes a MonadPlus and applies a predicate to its mapped type, which if false yields mzero, otherwise it leaves the value alone
02:34:54 <johnw> mapped value, I should say
02:35:02 <jle`> @src mfilter
02:35:02 <lambdabot> Source not found.
02:35:08 <Feuerbach> if you literally mean "a single pass over data", then laziness is sufficient there. If you also want that pass to be very efficient (e.g. not performing unnecessary allocations), then it's achieved by fusion
02:35:39 <jle`> sounds like \x -> guard p >> return x
02:35:48 <jle`> p x
02:35:57 <timthelion> johnw: no, stream fusion is "the next step" plain old lazyness will make a single pass of the thing.
02:35:58 <johnw> i think it's just: mfilter p m = do { guard x; m }
02:36:03 <johnw> s/x/p
02:36:09 <johnw> timthelion: ah, ok
02:36:23 <jle`> ah
02:36:40 <jle`> so it just takes away the awkwardness of guard p; m
02:36:46 <johnw> yeah
02:36:47 <jle`> so you only need one line
02:36:49 <jle`> that's handy
02:37:03 <Feuerbach> it'd have a different signature
02:37:07 <johnw> i use it a fair bit, it can be very cute sometimes
02:37:18 <Feuerbach> jle` wanted (a -> Bool) -> a -> Maybe a
02:37:26 <johnw> ah
02:37:29 <jle`> well
02:37:31 <brtaylor92_> next newbie question: do pointers still exist?
02:37:33 <jle`> it's just as useful admittedly
02:37:40 <johnw> if p x then Just x else Nothing?
02:37:47 <jle`> johnw: yeah, that
02:37:50 <jle`> but standard library
02:37:51 <Feuerbach> \x -> x <$ guard (p x)
02:37:57 <johnw> mfilter p . Just ;)
02:38:05 <jle`> haha
02:38:21 <jle`> brtaylor92_: if there are things that can be called pointers, they are abstracted far, far away
02:38:40 <jle`> i guess you sort of use them for MVars?
02:38:44 <jle`> the 'idea' of pointers
02:38:47 <brtaylor92_> figured that would be the case, but it seemed worth asking
02:38:49 <jle`> but they don't correspond to actual address in memory
02:39:19 <jle`> when you are learning haskell i recommend you detach the idea of the language from the idea of the computation
02:39:31 <jle`> imagine things happening on a infinitely abstract super haskell oracle
02:39:38 <johnw> jle`: it's almost like 'find' for the Identity functor, if you could do away with the newtype wrapper
02:39:48 <johnw> (Identity Foldable, I mean)
02:40:06 <jle`> it's more important to think of the ideas themselves than their implementation at first
02:40:10 <johnw> :t Data.Foldable.find Identity
02:40:12 <lambdabot>     Couldn't match type `Identity a0' with `Bool'
02:40:12 <lambdabot>     Expected type: a0 -> Bool
02:40:12 <lambdabot>       Actual type: a0 -> Identity a0
02:40:30 <johnw> i always forgot how to ask lambdabot to specialize an instance method
02:40:41 <jle`> every time i use explicit identity it just feels slightly awkward :|  maybe i'll get used to it
02:40:52 <johnw> > Data.Foldable.find (<3) (Identity 4)
02:40:54 <lambdabot>  Not in scope: `Data.Foldable.find'
02:40:54 <lambdabot>  Perhaps you meant one of these:
02:40:54 <lambdabot>    `Data.Foldable.fold' (imported from Data.Foldable),
02:40:54 <lambdabot>    `Data.Foldable.foldMap' (imported from Data.Foldable)
02:41:20 <jle`> lambdabot always hangs out your laundry to dry. no sympathy.
02:41:36 <johnw> funny, I can see the function in Haddock, I wonder if it's new
02:43:26 <timthelion> johnw: In a few years/decades haddock will know which version of a package has which functions of what types. and then through type unification and functional dependency analysis, cabal will be able to choose the "latest building version of a package" and version upper bounds will be forever forgotten.
02:43:50 <johnw> i would love that; I have no foundness for upper bounds
02:44:17 <jle`> timthelion: i was thinking about picking up elm to work on a js project. do you recommend ti?
02:44:35 <jle`> i appreciate elements of the language but i am reluctant to move away from the haskell ecosystem
02:45:32 <timthelion> jle`: Well, it is certainly easy to get something on the screen.  But if you are used to a robust type system(the ability to use a lot of type variables ect) and type errors that are clear than you'll be a bit dissapointed
02:45:52 <jle`> i just want to build a js games that my friends can play
02:46:03 <timthelion> jle`: then it's cool.
02:46:44 <timthelion> jle`: It is good for small projects, but it really strains Elm's limited type system and expressiveness to do more complex things
02:47:01 <jle`> i see
02:47:09 <jle`> well i struggle to find a platform as ubiquitous as javascript
02:47:18 <jle`> and it seemed like elm was my best bet for developing on it
02:47:23 <timthelion> jle`: for example, there is no way to send information up the signal graph(it is non cyclic) so if you want your game to pause based on game logic, you may have to re-write it
02:47:26 <jle`> with semantics that i appreciated the most
02:47:37 <jle`> timthelion: huh that's interesting.
02:47:43 <jle`> is that a problem for the haskell FRP libraries?
02:47:47 <zomg> jle`: I would be careful about using languages that compile into JS if you're making games
02:48:01 <arkeet> have you tried out haste or ghcjs?
02:48:04 <zomg> performance in javascript can occasionally be a bit of a problem but that obviously depends on what kind of games you're making
02:48:30 <timthelion> jle`: Elm doesn't really have anything to do with FRP. Evan just calls it that because he *thinks* they have something in comon.  Elm is a data flow language...
02:48:47 <jle`> heh
02:49:15 <jle`> i have looked at haste/ghcjs but there is some cognitive dissonance in working with a language so removed from javascript
02:49:25 <jle`> what kind of js does elm produce?
02:49:28 <jle`> is it close to idiomatic?
02:49:39 <timthelion> jle`: I cannot comment on haskell FRP, I have looked at bannana and been so offended by the indentation of the let statements that I burnt it as devils spawn and never looked back.
02:49:54 <jle`> apparently Purescript's compiled js is pretty idiomatic
02:50:02 <timthelion> jle`: it produces rather readable JS...
02:50:22 <timthelion> jle`: but it's a very very 1:1 translation.
02:50:31 <jle`> hm
02:50:42 <zomg> Fay might be worth a look as well
02:50:50 <timthelion> jle`: it's practically like the line numbers match up
02:51:24 <timthelion> jle`: I didn't mean to insult Elm when I said it wasn't FRP. I personally think that FRP is shit.
02:53:44 <jle`> i see
02:54:17 <jg> hi all. I don't want to pass Strings around in my program. Is there an idiomatic way in haskell to wrap them in some better domain-related type?
02:54:35 <jle`> jg: i think people like using type synonyms
02:54:39 <jle`> is that what you mean?
02:54:50 <jg> jle`: so type UserName = String ?
02:55:13 * timthelion has always been frustrated by that part of curry notation.
02:55:14 <jle`> yes
02:55:25 <timthelion> Type synonyms hide the types.
02:55:43 <jle`> it's just an extra click in the haddocs
02:56:01 <jg> jle`: but will the compiler complain then if i try to pass a String instead of a UserName?
02:56:05 <zomg> Although I kind of agree with timthelion, synonyms is better than having String -> String -> String
02:56:10 <arkeet> no, type synonyms don't hide anything.
02:56:13 <jle`> jg: no
02:56:14 <jg> :(
02:56:20 <zomg> so you can have something like Name -> Password -> Address
02:56:21 <jle`> it's like [Char] and String
02:56:44 <timthelion> jle`: yes, but it prevents the ability to just look and within less than a seccond know everything about a functions behavior.
02:56:49 <arkeet> use a newtype if you want the type system to enforce stuff
02:56:51 <jle`> idk using type synonyms for something like naming your function types feels kinda iffy to me.  i haven't seen it done actually
02:57:06 <arkeet> jle`: FilePath ?
02:57:20 <jle`> arkeet: FilePath is a general type synonym
02:57:24 <arkeet> yes
02:57:24 <jle`> maybe i was referring more to things like
02:57:26 <jle`> one-offs
02:57:27 <arkeet> I don't know what you mean then
02:57:32 <arkeet> oh sure
02:57:34 <jle`> just for one function
02:57:37 <jle`> or a couple
02:57:41 <arkeet> yeah that makes no sense
02:57:41 <jle`> instead of being meant for general usage
02:57:49 <jle`> i misunderstood you then
02:57:53 <timthelion> jle`: I'm not saying it's the end of the world, just that foo = username::String -> password::String -> loginAccepted::Bool would be IMO nicer
02:58:17 <jle`> timthelion: is that valid syntax?
02:58:19 <arkeet> no
02:58:23 <jle`> :'(
02:58:24 <timthelion> jle`: unfortunately no
02:58:32 <zomg> I think a nice editor would just be able to tell you what the synonyms are when hovered over them
02:58:39 <zomg> But of course being a vim user that's just fantasy
02:58:40 <zomg> haha
02:59:03 <jle`> zomg: maybe one day when haskell-mode works like it says in the docs
02:59:20 <zomg> or maybe the fpcomplete editor can do it someday
02:59:24 <timthelion> jle`: but this is: foo = String -- ^ username\n -> String -- ^ password\n -> Bool -- ^ logginAccepted
02:59:28 <jle`> fpcomplete editor does do it
02:59:28 <zomg> been meaning to look at that but haven't really gotten around to it
02:59:34 <zomg> ah cool :)
02:59:39 <jle`> but i'm not going to switch my entire dev environment
02:59:41 <jle`> for it
02:59:43 <jle`> heh
02:59:45 <zomg> yeah :P
02:59:59 <zomg> depends on how well it works tbh
03:00:08 <zomg> but so far I haven't been super convinced about web based environments
03:00:23 <jle`> but i am considering having code samples on my site be automatically loaded onto the ide for people to play with. i can see it as a good playing-around/learning tool
03:00:32 <jle`> similar to some kind of notebook interface that ghci lacks
03:00:34 <zomg> Yeah definitely
03:01:28 <jg> okay, seems newtype is what i want
03:01:28 <zomg> Would love to work on something like the fpcomplete editor thing but I already have a job for now
03:01:32 <mgsloan> Stay tuned for a local version :D
03:02:01 <jle`> i wouldn't mind a local version
03:04:01 <timthelion> mgsloan: will the local version of FPCE let you keep your projects as normal files on your system?
03:05:42 <zomg> I think I saw a module on Hackage to bundle webkit inside your haskell program
03:06:14 <zomg> Could probably set the web version up inside something like that and just provide some special interfaces to access the local environment if being ran inside that
03:06:18 <timthelion> zomg: there is a gtk webkit binding
03:06:40 <zomg> Yeah though I think the QtWebKit works better from what I've heard
03:07:02 <timthelion> zomg: I don't know how usefull GTK is to FPCE since mac doesn't have good build chain support.
03:07:09 <zomg> though it could just be the propaganda of all the Qt engineers I worked with at Nokia convincing me to like Qt
03:07:12 <zomg> =)
03:07:56 <zomg> timthelion: yeah, QtWebKit runs on Linux, OS X and Windows as far as I know
03:07:59 <timthelion> zomg: Mac actually has(seemingly intentionally) broken versions of automake ect, making GTK require much magic to build.
03:10:16 <brtaylor92_> ooc, broken how?
03:10:22 <mgsloan> timthelion: Not sure for the initial release.  But personally, I'd definitely prefer having that as well - it'll probably make it in.  Particularly if you give feedback about it!  Much of our prioritization is based on user feedback
03:10:40 <mgsloan> (I mean, probably make it in at some point)
03:11:04 <timthelion> mgsloan: Unfortunately my user feedback isn't very valulable to them.  I'm simply not interested in anything not open source.
03:12:02 <mgsloan> timthelion: Fair 'nough!  Is that due to not being able to customize it as much?
03:13:49 <mgsloan> Things'll get more and more extendable as time goes on
03:14:46 <timthelion> mgsloan: I actually don' care about customization.  Just a philosophical thing.
03:16:53 <mgsloan> Cool cool
03:17:48 <zomg> mgsloan: out of curiosity, you guys have room for more devs to work on the editor/environment? =)
03:18:38 <mgsloan> zomg: I think there will be postings when there's more hiring
03:18:58 <zomg> Alright, yeah just saw there was some vague "we might have some jobs" message on the fpcomplete site
03:19:01 <zomg> hehe
03:19:07 <zomg> But would be pretty interesting to work on something like that for a change if I run into a need of finding new employment
03:19:28 <mgsloan> Ahh, right, well, can't hurt to send your resume!  I'm not too involved in that side of things
03:19:55 <alpounet> unless the resume is actual Haskell code
03:19:55 <zomg> Yeah definitely will send it in if that happens :)
03:20:03 <alpounet> :]
03:20:37 <zomg> Although I'm not that strong with Haskell yet, I have over 10 years of web dev experience under my belt so I'm relatively confident I could contribute
03:22:18 <mgsloan> Cool!!  Yeah, the web side of thing is pretty darn tricky.  Good news is most of our clientside code is written in fay
03:22:52 <mgsloan> so we get all the benefits of static typing, which can also check the client / server message datatypes
03:23:08 <zomg> Yeah Fay is pretty nice
03:23:37 <mgsloan> chrisdone and I have been doing most of the clientside stuff (serverside stuff too, of course)
03:23:40 <timthelion> mgsloan: you guys are gamblers, you must have started writing FAY code long before any jokes about stability.
03:23:54 <timthelion> mgsloan: that's not an insult ;)
03:24:06 <mgsloan> :D We've got many kloc of fay nowadays
03:24:37 <mgsloan> There've been amazingly little hitches with it
03:25:05 <mgsloan> having chrisdone on board has helped a bunch with that, certainly
03:25:11 <zomg> My only Haskell github contribution so far is actually some XMLHttpRequest bindings for fay-dom :P
03:25:24 <mgsloan> back before he started there was this thing where every import statement acted like a #include >.<
03:25:41 <mgsloan> ooh
03:26:04 <zomg> pretty simple stuff but it was missing from there and had built it for some test stuff I wrote so figured I'll just send a PR
03:27:03 <mgsloan> We should really put up some of our more general fay modules.  They'd need polish etc, but I don't think there'd be any resistance to releasing them
03:29:59 <zett_zelett> Can one think of value constructors as isomorphism coming from the direct product of the types it takes? Like data Circle = Circle Float Float Float is in fact a definiton of an isomorphism Circle : Float×Float×Float → Circle?
03:31:01 <zett_zelett> So that data Circle = Circle is an isomorphism Acircle : TerminalObject → Circle?
03:31:27 <zett_zelett> Er, Circle : TerminalObject → Circle?
03:36:58 <benmachine> zett_zelett: I would think of data constructors as giving rise to isomorphisms rather than being isomorphisms themselves
03:37:14 <benmachine> because after all Circle in your second example isn't even a function
03:38:07 <mgsloan> and when you add more constructors (sum types), they're prisms from the lens library!
03:38:08 <benmachine> zett_zelett: you should also consider how this story extends to data Maybe a = Nothing | Just a
03:38:25 <mgsloan> (or rather, give rise to prisms)
03:38:48 <benmachine> I'd say it's really more the = there which gives the isomorphism, rather than the constructors themselves
03:40:26 <mgsloan> right, because if you used anonymous sums (I guess you could treat Either as an anonymous sum), you could have an iso even when there're multiple constructors
03:41:52 <mgsloan> zett_zelett: Also, I'm not much of a categorialist, but wouldn't that be an initial object, not a terminal object?
03:42:03 <mgsloan> terminal objects don't tend to appear on the left hand side of arrows :D
03:42:40 <mgsloan> So yeah, the different invocations of the constructor would correspond to morphisms from the initial object
03:42:43 <mgsloan> I suppose
03:49:25 <monoidal> impredicative types: can someone explain this inconsistency - http://lpaste.net/96963
03:50:56 <zett_zelett> No, but I think the terminal object is the limit of the empty Diagram and something like data Shape = Circle Float Float could be interpreted as “Shape is a new limit of the diagram Float Float, also Circle gives an Isomorphism from the other limit of that Diagram, i.e. of type Float×Float → Shape, but since we like to curry, it’s actually of type Float → Float → Shape”.
03:53:36 <zett_zelett> So in this interpretation we’d see data Shape = Circle as “Shape is a new limit of the empty diagram, and we also get an isomorphism from the other limit of that diagram, that is of our terminal object 1, whatever it’s called, so we have an isomorphism Circle :: 1 → Shape, but since it’s an arrow from a terminal object, let’s just interpret it as an element of Shape and let’s write Circle :: Shape
03:53:46 <zett_zelett> And I wonder if this analogy/way of thinking works out.
04:04:36 <benmachine> zett_zelett: it's a good analogy, yes
04:04:46 <benmachine> and yes, the morphism is from the terminal object
04:04:55 <benmachine> morphisms from the initial object tend to be boring
04:05:07 <benmachine> well, depending on your category of course
04:05:14 <mgsloan> Hmm, yeah, I'm not much of a categorialist hah
04:05:19 <mgsloan> also 4 am
04:07:47 * mgsloan goes to sleep
04:10:10 <zett_zelett> Okay, thanks benmachine.
04:32:32 <skypers> hey
04:32:41 <skypers> if I pass a newtype value in a function
04:32:45 <Iceland_jack> I second monoidal's question, why does [id, id] ∶ (∀a. a → a) work but (id `Cons` Nil) ∶ List (∀a. a → a) doesn't
04:32:54 <skypers> can’t I unnewtype it in a where statement?
04:32:57 <skypers> like hm
04:33:26 <skypers> foo f = do { print a; print b } where f = Foo (a,b)
04:33:27 <Iceland_jack> skypers: You can create an unwrapping function or pattern match
04:33:52 <skypers> I thought inversed pattern matching worked
04:34:11 <skypers> oh
04:34:14 <skypers> it might be
04:34:17 <skypers> Foo (a,b) = f
04:34:18 <skypers> right?
04:34:19 <Iceland_jack> yes
04:34:29 <skypers> it’s weird
04:34:34 <skypers> it should work in both situations
04:34:38 <Iceland_jack> Why?
04:34:50 <skypers> because = is commutative right?
04:34:57 <skypers> a = b ==> b = a
04:35:02 <Iceland_jack> = is not equality
04:35:08 <skypers> I know
04:35:14 <Iceland_jack> You can't define:
04:35:14 <Iceland_jack>     5 = a
04:35:21 <skypers> oh
04:35:23 <skypers> yeah
04:35:26 <skypers> you’re right
04:35:35 <skypers> it would be weird indeed :)
04:35:38 <Iceland_jack> You can also do:
04:35:38 <Iceland_jack>     foo (Foo (a, b)) = do { print a; print b }
04:35:40 <skypers> thank you
04:35:50 <skypers> yeah but I don’t that way to do
04:36:01 <skypers> I like thinking top-down
04:36:05 <skypers> not bottom-up :)
04:36:23 <Iceland_jack> or (when defining Foo) do:
04:36:24 <Iceland_jack>     newtype Foo a b = Foo { getFoo :: (a, b) }
04:36:31 <skypers> yeah
04:36:35 <skypers> but hm
04:36:55 <skypers> I don’t actually know if such a function will be often used
04:37:19 <Iceland_jack> It's helpful if you'll be composing it much
04:37:36 <skypers> just once :)
04:37:37 <Iceland_jack> instead of:
04:37:37 <Iceland_jack>     mySwap (Foo (a, b)) = Foo (b, a)
04:37:47 <Iceland_jack> you can do:
04:37:47 <Iceland_jack>     mySwap = Foo . swap . getFoo
04:37:51 <skypers>     StandaloneModel (g,p,mat,mp) = sm
04:37:53 <skypers> now it works
04:37:55 <skypers> thank you :)
04:38:15 <Iceland_jack> You're welcome, hope it answered your question
04:38:21 <skypers> sure
04:38:44 <skypers> the think is I need every part of the tuple
04:38:59 <skypers> but I could use somethink like
04:39:11 <Iceland_jack> Are you modeling your data as a 4-tuple?
04:39:11 <skypers> (g,p,mat,mp) = getAll sm
04:39:13 <skypers> indeed
04:39:16 <skypers> yes
04:39:28 <Iceland_jack> Why not a record?
04:39:47 <skypers> because I want newtype
04:39:50 <Iceland_jack> Why?
04:39:56 <skypers> it’s really an association of types
04:40:02 <skypers> p is linked to the g
04:40:05 <skypers> mp to the mat
04:40:14 <skypers> and (m,mp) to the (g,p)
04:40:22 <skypers> so a 4-tuple sounds quite okay to me
04:40:37 <Iceland_jack> I don't see how that has anything to do with tuples
04:40:38 <skypers> why do you recomend avoid it?
04:40:48 <skypers> why not?
04:41:43 <Iceland_jack> Why not? Well you went from “it's an association of types” (which I'm not sure what you mean by) to “which is why I should use a tuple”
04:42:00 <skypers> well
04:42:02 <skypers> my point here
04:42:03 <skypers> is this:
04:42:07 <skypers> if I use a data
04:42:13 <skypers> it lets me currify the ctor
04:42:17 <skypers> and I don’t really want that
04:42:21 <Iceland_jack> ..currify?
04:42:25 <skypers> yeah
04:42:26 <skypers> like
04:42:31 <Iceland_jack> You can also “currify” the tuple constructor
04:42:38 <Iceland_jack> @ty (,,,)
04:42:39 <lambdabot> a -> b -> c -> d -> (a, b, c, d)
04:42:46 <Iceland_jack> That's a very bad argument for not using data
04:42:54 <skypers> hm
04:42:59 <skypers> you’re damn right
04:43:05 <skypers> I should go back to data
04:43:16 <skypers> it’ll be easier to pattern match
05:02:26 <monoidal> Iceland_jack: now I found out that if you give an explicit type to Cons, it works
05:02:45 <monoidal> Iceland_jack: i.e. (Cons :: (forall a. a -> a) -> List (forall a. a -> a) -> List (forall a. a-> a)) id Nil
05:03:46 <Iceland_jack> oh interesting monoidal
05:03:51 <Iceland_jack> It doesn't work for: id:[]
05:04:01 <Iceland_jack> > let { u :: [forall a. a -> a]; u = [id] }
05:04:01 <Iceland_jack> > let { u :: [forall a. a -> a]; u = id:[] }
05:04:01 <Iceland_jack> <interactive>:5:36:
05:04:03 <lambdabot>  can't find file: L.hs
05:04:03 <lambdabot>  not an expression: `let { u :: [forall a. a -> a]; u = id:[] }'
05:04:32 <monoidal> > let u :: [forall a. a -> a]; u = [id]
05:04:34 <lambdabot>  not an expression: `let u :: [forall a. a -> a]; u = [id]'
05:04:43 <Iceland_jack> (sorry '>' is just my ghci prompt)
05:04:45 <monoidal> > let u :: [forall a. a -> a]; u = [id] in ()
05:04:47 <lambdabot>  Illegal polymorphic or qualified type: forall a. a -> a
05:04:47 <lambdabot>  Perhaps you intended to use -XImpredicativeTypes
05:05:27 <Iceland_jack> So I guess you'll have to do: ((:) :: (forall a. a -> a) -> [forall a. a -> a] -> [forall a. a -> a]) id []?
05:05:34 <monoidal> yes
05:05:49 <Iceland_jack> Any idea why [id] behaves differently from id:[]?
05:06:49 <monoidal> it seems [x1,x2,..,xn] behaves slightly differently from x1:x2:...:xn:[] in this regard
05:07:00 <monoidal> bit like f $ x has special behavior for rank-n types
05:07:04 <Iceland_jack> Yes
05:07:19 <skypers> still no idea how to compare two repositories in darcs?
05:07:21 <Iceland_jack> I would be interested in hearing the details of it
05:07:28 <skypers> in order to see if I have to send patches?
05:07:31 <skypers> whether*
05:07:40 <benmachine> ImpredicativeTypes are a bit if-you-break-it-you-get-to-keep-the-pieces I think
05:08:19 <Iceland_jack> benmachine: True but I still find [a] begin different from a:[] interesting
05:08:20 <donri> skypers: it should ask you if you try to send
05:08:37 <skypers> yes it does, but I’d like to see differences
05:08:43 <skypers> maybe darcs diff <repo> would work
05:09:22 <Iceland_jack> And more importantly, how one could emulate that difference with a custom type
05:09:31 <benmachine> darcs send --dry-run?
05:09:43 <donri> skypers: send --interactive?
05:09:55 <donri> perhaps that's the default...
05:10:10 <donri> but when listing patches interactively, you can view them with various commands
05:19:35 <jophish_> Yo yo yo
05:19:42 <jophish_> I can't seem to build OpenGLRaw with clang
05:19:48 <jophish_> (as a preprocessor)
05:20:25 <cmtptr> probably just not enough yos
05:20:56 <zomg> jophish_: I recall clang had some issues in general, might be worth trying gcc
05:21:11 <jophish_> I don't have gcc on this system :(
05:21:18 <zomg> OS X?
05:21:20 <jophish_> can I use cpphs instead?
05:21:27 <jophish_> zomg: how did you guess :)
05:21:43 <zomg> because the combo of clang and OS X have been causing me a variety of headaches in the past
05:21:46 <zomg> :D
05:22:21 <zomg> I'm not super familiar with the preprocessing stuff so can't really say whether cpphs would work
05:22:24 <zomg> Probably worth a try at least
05:25:08 <dsfsw> Can I help the typechecker to deduce this: http://dpaste.com/1504989/plain/ ?
05:27:37 <dsfsw> I want to be able to pass either Car or Table to foo.
05:27:52 <dsfsw> I could define Foo as a product type, but that would require additional value constructors.
05:27:59 <dsfsw> which I'd like to avoid.
05:30:07 <donri> dsfsw: you'll have to either make it dynamically typed, or make it a sum type
05:30:54 <dsfsw> donri: What do you mean by dynamically typed?  Wrapped into Dynamic?
05:31:03 <donri> you can have record sums, although the fields won't necessarily be total
05:31:19 <dsfsw> donri: Could you show an example?
05:31:41 <donri> dsfsw: example of what?
05:31:47 <dsfsw> Record sums
05:32:43 <quchen> data Foo = Person { name :: String, height :: Int } | Pet { name :: String } -- dsfsw
05:33:05 <donri> Dynamic is one way to do dynamic types. you can also do what it does directly. you only need the existential of Dynamic for things like homogeneous containers
05:33:13 <dsfsw> quchen: I thought that's a product type, not a sum type.
05:33:29 <quchen> dsfsw: Tuples are products, "|" are sums.
05:33:54 <donri> (also, records are products)
05:34:20 <quchen> Right. The above could be seen as  (String*Int) + String
05:34:49 <quchen> So the entire thing is a sum of records, the first record being (String*Int), the second is (String).
05:35:12 <dsfsw> Oh, you're right regarding the products.
05:37:31 <dsfsw> quchen: Indeed, your example works. But what if Person and Pet are provided my a library?
05:37:46 <dsfsw> by*
05:38:09 <donri> consider Void. (Bool,Void) has no values because we have to provide a Void. that's 2*0=0. Either Bool Void has two (Left False and Left True). that's 2+0=2
05:38:19 <quchen> If you want to have shared record access functions you'll need the definitions to be together.
05:38:29 <donri> (ignoring bottom here of course)
05:38:30 <quchen> There is (currently) no way to overload records.
05:40:19 <dsfsw> donri: Thanks for explaining. Note that I read Chris Taylor's "Algebra of Algebraic Data Types," just messed up the terms in my head.
05:40:36 <quchen> If what you want is to put both Car and Table in a common type, use something like "Either Car Table" (i.e. Car+Table).
05:42:38 <dsfsw> quchen: Right, but that would require an additional value constructor.  So I'd have to pass Left $ Car ... to foo, not just Car.  I thought there might be a way to avoid such value constructors entirely.
05:43:27 <donri> dsfsw: you can type-class "car" :P
05:43:35 <donri> can't pattern match on it though
05:43:46 <donri> though you can type-class unCar and use view patterns ;)
05:44:03 <dsfsw> Could you show an example of the latter?
05:44:56 <quchen> dsfsw: There is no pretty way of getting a "type-level case".
05:45:21 <donri> instance IsCar Car where car = Car; unCar (Car x y) = (x,y)
05:45:52 <donri> or perhaps better
05:46:08 <donri> instance IsCar Car where car = Car; viewCar = id
05:46:18 <dsfsw> donri: I think you misunderstood the "additional value constructors" part. I was talking about Left and Right, not Car.
05:46:23 <donri> case x of (viewCar -> Car _ _) -> "CAR!"
05:46:33 <donri> dsfsw: yes
05:47:09 <donri> ok so you'll need to make viewCar a Maybe
05:47:11 <donri> but
05:47:35 <dsfsw> Sorry, why would I need that?
05:47:37 <maybefbi> How do I stop closing the LevelDB database often in this code? http://lpaste.net/96964
05:48:02 <donri> instance IsCar Vehicle where car = VehicleCar . Car; viewCar (VehicleCar c) = Just c; viewCar _ = Nothing
05:48:38 <donri> now you can use "car" to make VehicleCar, and "viewCar" to view the Car in a VehicleCar
05:49:17 <dsfsw> donri: Sorry, but I don't see how it's relevant to the stated problem.
05:50:40 <donri> data Vehicle = VehicleCar Car | VehicleSpaceShip SpaceShip
05:50:56 <donri> car "Ford" 1950 :: Vehicle
05:53:41 <donri> dsfsw: instead of (Car "Ford" 1950) we write (car "Ford" 1950) and it also works for Vehicle without writing (VehicleCar (Car "Ford" 1950))
05:56:10 <donri> dsfsw: (lens also solves these problems for you, with lots of generic combinators and automatic code generation)
05:56:15 <dsfsw> donri: Could you paste the above code? I can't follow it here.
05:56:57 <maybefbi> donri: i came in the middle of your conversation, so I did not catch the problem. Also paste is somewhere nice.
05:58:05 <donri> dsfsw: well ignore the viewCar bit if that confuses you. class IsCar a where car :: String -> Int -> a; instance IsCar Car where car = Car; instance IsCar Vehicle where car model year = VehicleCar (Car model year)
05:58:19 <donri> maybefbi: ?
05:58:55 <maybefbi> ¯\_(ツ)_/¯
06:02:34 * dsfsw looks
06:03:33 <maybefbi> I need some help writing my code inside a ResourceT which would be inside a Consumer _ _ IO (). As it currently stands I have the solution, but the ResourceT gets run often and because of that the LevelDB connection keeps closing
06:03:58 <maybefbi> The code is here: http://lpaste.net/96964 the section I want to change is putOne
06:04:13 <maybefbi> and the part which calls it putMany
06:05:02 <maybefbi> I want the LevelDB connection to close less often
06:05:37 <dsfsw> donri: Thanks, but it doesn't solve the problem.  Now, I have to match on VehicleCar in foo, not Car.  That's what I meant by additional value constructors.  Here's the new foo: foo x = case x of VehicleCar (Car _ _) -> "CAR!"; _ -> "Something else" :: Vehicle -> String
06:05:46 <dsfsw> Or am I misunderstanding it?
06:05:52 <donri> dsfsw: yeah that's what viewCar was for
06:06:23 <donri> but it's not a big win really
06:06:34 <donri> unless you have many things containing cars
06:06:35 <dsfsw> donri: Ah, I got your point.
06:06:51 <jophish_> How can I upgrade ghc for use with cabal
06:07:04 <jophish_> there's a bug in 7.6 which is fixed in 7.7
06:07:18 <donri> 7.7 is a development version
06:07:31 <donri> bbl
06:07:37 <jophish_> I'm hitting this: https://github.com/bsl/bindings-GLFW/issues/8
06:09:27 <merijn> jophish_: 7.7 is a development version, but tbh upgrading is not that difficult if you already have a working GHC. Just the usual configure/make business cabal should automatically use the GHC in your path
06:09:51 <merijn> jophish_: I switch between GHC versions by modifying which GHC is first in my path and cabal Just Works (TM) for me
06:10:05 <jophish_> merijn: al, awesome
06:10:06 <jophish_> ah*
06:11:58 <danharaj> :t traverse . traverse . traverse
06:12:00 <lambdabot> (Applicative f, Traversable t, Traversable t1, Traversable t2) => (a -> f b) -> t (t1 (t2 a)) -> f (t (t1 (t2 b)))
06:12:54 <jophish_> building ghc isn't quite trivial
06:25:15 <jophish_> I hope it build more quickly than gcc
06:25:29 <identity> jophish_: building ghc is not very hard IMO
06:25:42 <identity> and it definitely builds much faster than gcc
06:25:45 <jophish_> a little more complex than ./configure && make
06:25:53 <jophish_> but it's building now
06:26:01 <identity> it's basically that
06:26:09 <identity> except you need to download dependencies if you don't ahve them
06:27:18 <jophish_> ratbags, linker errors
06:28:15 <jophish_> libgmp
06:46:26 <jophish_> Taking its time...
06:50:43 <merijn> jophish_: ah, Ubuntu, I guess?
06:50:50 <jophish_> merijn: osx
06:51:20 <merijn> Really? It worked flawlessly on OSX for me? But maybe I already had all the dependencies for some other reason
07:01:06 <jophish_> hmm, can't load .so/.DLL for: libHSbindings-DSL-1.0.20.dylib (dlopen(libHSbindings-DSL-1.0.20.dylib, 9): image not found)
07:01:10 <jophish_> trying to install glfw-b
07:03:11 <jophish_> How can I install this dylib for bindings-DSL
07:04:38 <geekosaur> it should have been installed with bindings-DSL
07:04:53 <bennofs> hvr: Could you maybe update the cabal package in the multi-ghc PPA for travis to include this fix? http://www.reddit.com/r/haskell/comments/1sh67u/the_reason_why_cabal_update_takes_so_long/ Not sure if that helps, but maybe it will give a speed up for travis builds?
07:05:34 <geekosaur> unless for some reason that package was built static instead of dyn
07:05:41 <jophish_> geekosaur: that seems to be the case
07:06:19 <jophish_> geekosaur: how can I change this?
07:08:00 <geekosaur> reinstall with --enable-shared?
07:08:22 <jophish_> geekosaur: installing from source worked
07:15:37 * hackagebot newsynth 0.1.0.0 - Exact and approximate synthesis of quantum circuits  http://hackage.haskell.org/package/newsynth-0.1.0.0 (PeterSelinger)
07:20:38 * hackagebot themplate 0.1 - themplate  http://hackage.haskell.org/package/themplate-0.1 (BennoFuenfstueck)
07:42:29 <kuznero> Hi All!
07:46:58 <Feuerbach> hey
07:50:51 <jmcarthur> hey
07:51:26 <Fuuzetsu> How does one work in emacs with the cabal sandboxes?
07:51:38 <Fuuzetsu> (things like loading into GHCi &c)
07:55:21 <jophish_> Error: Could not find module: Control.Comonad with any suffix
07:55:22 <jophish_> grr
07:55:28 <jophish_> trying to install comonad
07:58:18 <quchen> jophish_: Via cabal?
07:58:24 <jophish_> quchen: yeah
07:58:27 <jophish_> and the same from source
07:58:55 <jophish_> I don't really understand what this error means
08:00:50 <jophish_> Is there any way to purge all things haskell from my system and start again
08:00:58 <jophish_> I think I've screwed things up a little bit
08:01:29 <quchen> jophish_: Delete ./.{cabal,ghc}
08:01:34 <quchen> jophish_: Delete ~/.{cabal,ghc}
08:01:35 <quchen> Pardon
08:01:41 <geekosaur> OS X, no? ~/Library/Haskell
08:01:58 <jophish_> there are things in /usr/local too
08:01:59 <quchen> You may want to save your ghci.conf though
08:02:12 <jophish_> I've not touched that configuration
08:02:27 <quchen> If you didn't sudo around in /usr/local, deleting .ghc and .cabal should give you a clean start.
08:02:47 <merijn> quchen: Not on OSX
08:02:56 <quchen> :-C
08:03:02 * quchen backs away slowly
08:03:06 <merijn> jophish_: Did you specify a prefix for installing GHC?
08:03:10 <ion> ಠ_ಠ
08:03:14 <jophish_> merijn: /usr/local
08:03:27 <merijn> quchen: To mimic the rest of the software all haskell stuff is installed in ~/Library/Haskell
08:03:37 <jophish_> I'll remove everything I can find, reinstall haskell-platform and reinstall ghc 7.7
08:03:40 <merijn> jophish_: Ah, I usually recommend against that
08:04:03 <merijn> jophish_: I tend to use something like "~/ghc" as a prefix, that way you can just "rm -rf ~/ghc" and be done :)
08:04:34 <ion> I always do this. https://gist.github.com/ion1/2815423
08:04:41 <merijn> jophish_: You can leave the stuff in /usr/local, installing platform should overwrite those anyway
08:04:49 <quchen> merijn: That's why my GHC binary is in ~/Programs/haskell/ghc-7.6.3/lib/ghc-7.6.3/ghc-7.6.3  ;-)
08:05:15 <merijn> ion: Right, that mostly what I do
08:10:44 * hackagebot bencoding 0.4.2.0 - A library for encoding and decoding of BEncode data.  http://hackage.haskell.org/package/bencoding-0.4.2.0 (SamTruzjan)
08:13:56 <Fuuzetsu> Is there Data.Tree pretty printer somewhere?
08:14:47 <Feuerbach> there was one in Data.Tree, afair
08:14:55 <mr-> drawTree?
08:15:02 <Feuerbach> yes
08:15:09 <frx> write your own, it's a fun practice
08:17:07 <Fuuzetsu> oh, I just found pretty-tree
08:17:09 <khyperia> Argh... why is mueval POSIX-only? Kinda puts a big restriction on it.
08:17:15 <Fuuzetsu> let's see how it compares to drawTree…
08:17:32 <Fuuzetsu> frx: I'd rather do something useful than practice with tree drawing ;P
08:18:28 <Fuuzetsu> Oh, drawTree _is_ in pretty-tree package
08:18:57 <mr-> Data.Tree also has a drawTree
08:18:59 <Feuerbach> there's one in containers
08:21:46 <quchen> Feuerbach: That one's only for debugging though
08:22:25 <quchen> Oh, Data.Tree is in containers. Nevermind then, I thought you were referring to the Map/Set ones.
08:24:42 <merijn> khyperia: Because it uses ulimits and other unix tools to restrict what the process executing code can do
08:25:16 <merijn> khyperia: I'm not aware of the right way to do those on windows, so I can imagine the authors couldn't be arsed to research windows enough to do that
08:27:19 <khyperia> ah
08:27:43 <Lindrian> What does the @ syntax do?
08:28:01 <Lindrian> I've seen it used as variable@(stuff in here)
08:28:12 <Lindrian> and the variables/names declared in the parens are later used
08:28:16 <Cale> Lindrian: In patterns, it lets you bind a variable to the whole thing that the following pattern matches
08:28:23 <Lindrian> ah right
08:28:37 <ion> > let f theWholeParameter@(x:pattern) = (theWholeParameter, x, pattern) in f "hello"
08:28:38 <lambdabot>  ("hello",'h',"ello")
08:28:39 <Cale> > let f (t@(x,y)) = (t,x,y) in f (4,5)
08:28:40 <lambdabot>  ((4,5),4,5)
08:28:48 <merijn> Lindrian: "foo@(x, y)" match x and y to parts of the tuple and foo as the entire tuple
08:29:00 <Lindrian> yep
08:29:01 <ion> @quote stereo
08:29:01 <lambdabot> xplat says: Welcome to #haskell-blah, where your bot commands are executed in triumphant stereo!
08:29:01 <Lindrian> thanks guys
08:29:12 <jophish_> after nuking everything, comonad failed to install again
08:29:25 <merijn> jophish_: Run with -v3 and pastebin the output?
08:30:01 <merijn> jophish_: Oh wait, this is with 7.7, right?
08:30:15 <merijn> Since comonad is an edwardk package maybe it's one of the Proxy-onslaught victims
08:30:49 <jophish_> merijn: http://pastebin.com/ck602TY2
08:30:58 <jophish_> merijn: yes, 7.7
08:31:11 <mauke> The paste ck602TY2 has been copied to http://lpaste.net/96966
08:31:39 <jophish_> line 5064 has the error
08:32:40 <jophish_> I'm doing Ludum Dare, and have spent the last 4 hours installing haskell packages :/
08:33:29 <jophish_> merijn: what's proxy-onslaught?
08:33:34 <Feuerbach> why on earth are you using 7.7 then?
08:33:45 <danharaj> 7.7 is an unstable branch
08:33:54 <danharaj> you are going to spend much more than 4 hours installing packages.
08:34:14 <jophish_> Feuerbach: danharaj, there's a bug in 7.6 which prevents me linking glfw-b in osx
08:34:28 <Feuerbach> if you succeed, though, the maintainers will be grateful for your patches :)
08:34:40 <merijn> jophish_: Proxy is a part of Data.Typeable, 7.7 changed the implementation and it broke tons of packages which haven't been fixed yet, since 7.7 is a development branch
08:34:50 <jophish_> sorry, bindings-glfw
08:34:50 <jophish_> https://github.com/bsl/bindings-GLFW/issues/8
08:35:23 <merijn> jophish_: Oh, you're on 10.9?
08:35:33 <jophish_> merijn: yup
08:35:56 <merijn> jophish_: Have you checked the topic too? There's issues with 10.9, because Apple dropped gcc from the new XCode in 10.9
08:36:07 <jophish_> yeah, I've installed gcc
08:36:12 <jophish_> no more preprocessing errors
08:37:02 <merijn> I'm not sure if there's any more nastiness that comes from mixing 7.7 and OSX 10.9, tbh
08:37:15 <jophish_> apart from comonad, everything is going smoothly
08:37:29 <Cale> Weird package to have a problem with
08:37:39 <jophish_> Is there likely to be a quick fix?
08:38:25 <Cale> There's so much noise to go through in your paste, I can't really tell what went wrong
08:38:42 <jophish_> I could paste with v or v2
08:39:38 <jophish_> http://lpaste.net/96967 v2
08:39:39 <merijn> jophish_: Maybe run "cabal get comonad" which should unzip it into a local directory and then run "cabal build" in that directory to see any build errors?
08:39:46 <Cale> It looks like everything went fine, and then it got to the end and couldn't find the thing it just installed?
08:39:50 <jophish_> exactly
08:40:22 <jophish_> cabal doesn't seem to have a get command merijn (For me)
08:40:28 <jophish_> I've got it from source though
08:41:01 <Cale> cabal unpack
08:41:09 <jophish_> there are no build errors
08:41:31 <Cale> What happens when you cabal install (with no extra args) from the directory where you just built it?
08:41:47 <jophish_> Cale: http://lpaste.net/96968
08:42:02 <Cale> Okay, so basically the same
08:42:26 <Cale> what is in dist/build?
08:42:57 <jophish_> Cale: http://lpaste.net/96969
08:43:09 <jophish_> comonad.hi is in there
08:43:15 <jophish_> Comonad.hi*
08:43:31 <Cale> But no dyn_hi
08:43:48 <jophish_> ah yes
08:43:58 <jophish_> do I need to build with some flags?
08:44:03 <Cale> I don't really know what a dyn_hi is for.
08:44:33 <Feuerbach> try to install a fresh cabal-install, perhaps. What's your current version?
08:45:13 <Cale> Try building with --disable-shared
08:45:31 <jophish_> Feuerbach: I can't seem to install cabal-install
08:45:37 <jophish_> broken dependencies
08:45:43 <Cale> cabal install --disable-shared and see what happens
08:45:45 <jophish_> I've just reinstalled haskell-platform
08:46:27 <jophish_> Cale: disable-shared seemed to do the trick
08:46:42 <Cale> cool
08:46:55 <jophish_> I have a feeling I'm going to need the shared library though
08:47:08 <Cale> static linking ftw
08:47:20 <jophish_> trying to build semigroupoids: Perhaps you haven't installed the "dyn" libraries for package ‛comonad-4.0’?
08:47:31 <Cale> Do the same there
08:47:42 <Cale> You might want to edit your ~/.cabal/config
08:47:56 <jophish_> shared : False?
08:47:58 <Cale> yeah
08:48:40 <jophish_> ok, I'll remove haskell-platform and start again
08:48:42 <jophish_> one last time
08:48:52 <Cale> The main reasons to use shared libraries are to cut down on binary file size and memory usage when running multiple Haskell programs at once
08:49:01 <Cale> Those probably don't matter much to you
08:49:13 <donri> doesn't it also make linking faster
08:49:20 <Cale> I don't know
08:49:24 <Cale> Maybe!
08:50:57 <kwstas> hello there! is there any way to export all functions of a module implicitly?
08:51:03 <jophish_> hmm, cabal-install fails to install
08:51:06 <jophish_> can't build array
08:51:46 <Cale> jophish_: That's interesting. array is one of the libraries which comes with GHC, isn't it?
08:52:04 <Cale> jophish_: Probably you have too new a version of array, because you're running the development GHC
08:55:24 <jophish_> Array fails with:  Not in scope: type constructor or class ‛Typeable2’
08:55:28 <Cale> jophish_: I suppose you might try relaxing the bounds by editing the .cabal file for cabal-install by hand, or perhaps there's a dev release of that too
08:55:34 <Cale> Yeah, Typeable2 is gone
08:55:36 <Cale> In new GHC
08:55:38 <Feuerbach> kwstas: yes, just omit the export list
08:55:43 <jophish_> what's it's replaced with?
08:55:49 <jophish_> what is it*
08:55:56 <Cale> Typeable has been made kind-polymorphic
08:56:02 <jophish_> ah
08:56:24 <jophish_> can cabal install dev releases from things?
08:56:30 <jophish_> or is it stuck on one version
08:56:37 <Cale> Not unless people upload them to hackage
08:57:26 <Feuerbach> you could add-source them in a sandbox
08:57:41 <Cale> oh, well, yeah
08:57:43 <Feuerbach> (but your cabal version doesn't do sandboxes, I guess)
08:57:53 <Cale> You can cabal install them by hand
08:57:56 <Cale> If you have the source
08:57:56 <kwstas> Feuerbach: Thanks a lot...
08:58:10 <Cale> (like we did with comonad)
08:58:10 <jophish_> Feuerbach: what makes you think that?
08:58:33 <jophish_> Cale: yeah, I've been doing a lot of that, I was hoping there was a nice automated way
08:58:34 <Feuerbach> because it doesn't know the 'get' command, if I recall correctly
08:59:12 <jophish_> ah
08:59:29 <Feuerbach> just type cabal --version
08:59:44 <jophish_> cabal-install version 1.16.0.2
08:59:46 <merijn> Yeah, unpack is deprecated in the most recent cabal, yeah
08:59:54 <Feuerbach> you can install a fresh cabal using a stable GHC, btw
09:00:01 <Feuerbach> it's just a program
09:00:27 <merijn> I know
09:00:37 <merijn> It usually warns you that there is an update
09:01:09 <jophish_> yeah, I can't install the new cabal-install
09:01:27 <jophish_> hmm, things seem to be getting a little firther installing the gl bindings this time
09:01:40 <Feuerbach> jophish_: my point was that you *can*
09:01:48 <Feuerbach> (not sure if it was clear enough)
09:03:10 <Feuerbach> some of your problems may even be caused by the fact that you're using a very old cabal with a very new ghc
09:03:30 <jophish_> I'll install cabal from source if this doesn't work
09:03:31 <merijn> 1.16 isn't *that* old
09:03:38 <merijn> The most recent cabal is like 1.18
09:04:36 <Feuerbach> it's old. it was released more than a year ago. During that time, a lot of things have changed in ghc
09:05:04 <donri> hey even 1.18 is old
09:05:09 <donri> notably, it wasn't released this week
09:06:19 <bz> :k (|)
09:06:21 <lambdabot> parse error on input `|'
09:06:25 <bz> :t (|)
09:06:26 <lambdabot> parse error on input `|'
09:06:31 <Feuerbach> donri: not sure if it was sarcasm :) but yeah, the bigger the gap between ghc and cabal is, the more likely you are to run into problems
09:06:31 <Lindrian> Why does do ”merry”; return ”christmas” return "christmas" 5 times?
09:06:39 <Fuuzetsu> bz: that's a reserved symbol
09:06:42 <Iceland_jack> Lindrian: You're in the list monad
09:06:46 <Lindrian> right
09:06:50 <donri> Feuerbach: oh i didn't follow the conversation at all
09:06:55 <Iceland_jack> > do "testing"; "hi"
09:06:56 <Lindrian> without return i get "christmas" repeated 5 times as a string
09:06:56 <lambdabot>  "hihihihihihihi"
09:06:58 <int-e> > length "merry"
09:06:59 <lambdabot>  5
09:07:03 <Lindrian> but with return I get it as a list of lists, why?
09:07:16 <mr-> Lindrian: it's the list monad
09:07:18 <Iceland_jack> Lindrian: return "hi" = ["hi"]
09:07:28 <simpson> > return 42 :: [Int]
09:07:29 <Iceland_jack> > return "hi" :: [String]
09:07:29 <lambdabot>  [42]
09:07:30 <lambdabot>  ["hi"]
09:07:34 <Feuerbach> donri: jophish_ is using Cabal 1.16 with GHC HEAD
09:07:46 <Lindrian> So what does return do? Wraps it in a monad?
09:07:49 <merijn> > do { x <- "merry"; return x }
09:07:50 <lambdabot>  "merry"
09:07:52 <Iceland_jack> Lindrian: basically
09:08:03 <merijn> Lindrian: List monad roughly does what a list comprehension does
09:08:06 <Lindrian> > return "abc"
09:08:07 <lambdabot>  No instance for (GHC.Show.Show (m0 [GHC.Types.Char]))
09:08:08 <lambdabot>    arising from a use of `M77777778222731583632716.show_M77777778222731583632...
09:08:08 <lambdabot>  The type variable `m0' is ambiguous
09:08:08 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
09:08:08 <lambdabot>  Note: there are several potential instances:
09:08:15 <merijn> > [ x | x <- "merry"]
09:08:16 <lambdabot>  "merry"
09:08:19 <Iceland_jack> > concatMap (const (return "christmas")) "merry"
09:08:20 <lambdabot>  ["christmas","christmas","christmas","christmas","christmas"]
09:08:22 <merijn> > [ 1 | x <- "merry"]
09:08:23 <lambdabot>  [1,1,1,1,1]
09:08:37 <merijn> > do { x <- merry; return 1 }
09:08:38 <lambdabot>  Not in scope: `merry'
09:08:40 <merijn> eh
09:08:45 <merijn> > do { x <- "merry"; return 1 }
09:08:46 <lambdabot>  [1,1,1,1,1]
09:08:58 <merijn> @undo do { x <- "merry"; return 1 }
09:08:59 <lambdabot> "merry" >>= \ x -> return 1
09:09:18 <merijn> Lindrian: And >>= for lists is concatMap
09:09:23 <merijn> :t concatMap
09:09:23 <lambdabot> (a -> [b]) -> [a] -> [b]
09:09:30 <Iceland_jack> Since we aren't really inspecting the values of "merry" we can equally do:
09:09:30 <Iceland_jack> > do [undefined, undefined, undefined, undefined, undefined]; return "christmas" -- Lindrian
09:09:31 <lambdabot>  ["christmas","christmas","christmas","christmas","christmas"]
09:10:16 <Lindrian> right
09:10:24 <Iceland_jack> Does that clear things up?
09:10:24 <Lindrian> i just didnt know that return basically wraps things in a monad
09:10:32 <simpson> :t return
09:10:32 <lambdabot> Monad m => a -> m a
09:10:39 <Iceland_jack> > return 5 :: Maybe Int
09:10:40 <lambdabot>  Just 5
09:10:41 <Iceland_jack> > return 5 :: [Int]
09:10:42 <lambdabot>  [5]
09:10:42 <Twey> What's the correct way to convert a Float (actually, a Double) to a Foreign.C.Types.CFloat?
09:10:44 <Iceland_jack> > return 5 :: Either a Int
09:10:45 <lambdabot>  Right 5
09:11:04 <Twey> Er, I mean a GLfloat — I guess that's not necessarily the same thing
09:13:46 <jophish_> hmm, cabal bootstrap fails with 404
09:14:56 <Twey> Oh, I guess realToFrac does the job.
09:15:24 <benmachine> if you're lucky it'll even be rulesed away
09:16:35 <Twey> Ooh.
09:16:49 <Lindrian> Is this a correct transformation? (.)(:) x y z --> ((:) x . y) z --> (x . y):(z)
09:17:00 <Lindrian> I
09:17:16 <jophish_> merijn: Feuerbach, I have cabal head and ghc head installed
09:17:16 <Lindrian> I'm supposed to find the type of (.)(:), and I tried to expand the function with some in parameters
09:17:39 <nooodl> (.) (:) x would be ((:) . x)
09:17:42 <jophish_> I'd like to install vinyl-gl, should I cabal install vinyl-gl --disable-shared?
09:17:57 <Iceland_jack> Lindrian: When you have
09:17:58 <Iceland_jack>     a b c d
09:17:58 <Iceland_jack> it's parsed as
09:17:58 <Iceland_jack>     ((a b) c) d
09:17:58 <Lindrian> nooodl: doesnt it take 3 in parameters?
09:18:32 <jophish_> comonad installed!
09:19:09 <Iceland_jack> so
09:19:09 <Iceland_jack>       (.) (:) x y z
09:19:09 <Iceland_jack>     = ((.) (:) x) y z
09:19:10 <Iceland_jack>     = ((:) . x) y z
09:19:28 <Feuerbach> jophish_: even shared?
09:19:29 <Lindrian> Iceland_jack: alright
09:19:43 <jophish_> Feuerbach: I didn't specify --disable-shared
09:19:48 <Lindrian> what happens next Iceland_jack?
09:19:49 <Feuerbach> cool
09:19:52 <Iceland_jack> Lindrian: so we know that ‘x’ must be a function
09:19:56 <jophish_> but I don't have shared : True in config
09:20:13 <nooodl> (.) (:) x y z  ->  ((:) . x) y z  ->  ((:) (x y)) z  ->  (x y:z)
09:20:16 <Lindrian> yep
09:20:35 <Lindrian> nooodl: babysteps please :(
09:20:35 <Feuerbach> in 7.7 shared is on by default, I think
09:20:40 <jophish_> hmm, linear isn't installing now
09:20:44 <Iceland_jack> Lindrian: Basically what nooodl said, you begin by applying the first argument
09:20:44 <Lindrian> why does the dot go away?
09:20:56 <Iceland_jack> Lindrian:
09:20:56 <Iceland_jack>       (a . b) x
09:20:56 <Iceland_jack>     = a (b x)
09:20:57 <Iceland_jack> right?
09:21:24 <Iceland_jack> so ((:) . x) y = (:) (x y)
09:21:36 <Lindrian> ah okay
09:21:37 <nooodl> (whoa Iceland_jack is fast at these nicely indented, multiline expansions)
09:22:00 <Iceland_jack> nooodl: I hope people don't consider them flooding, I try to keep them to a minimum
09:22:36 <DigitalKiwi> flooding hahah with bots like these!
09:22:48 <jophish_> http://lpaste.net/96971
09:22:55 <Lindrian> Iceland_jack: thanks!
09:23:08 <jophish_> Feuerbach: merijn, This seems to be a fairly standard issue, nothing related to the build system ^
09:23:14 <Iceland_jack> Lindrian: After ((:) . x) y z = ((:) (x y)) z, we get (x y :) z
09:23:23 <Iceland_jack> which is just what nooodl said; x y : z
09:23:29 <Iceland_jack> Hope that helps
09:23:52 <Lindrian> it does
09:23:53 <Lindrian> thanks
09:24:02 <Feuerbach> jophish_: yes, it's a roles & GND issue
09:24:05 <Iceland_jack> The operators make it look trickier than it is
09:24:22 <jophish_> Feuerbach: My haskell-foo isn't quite strong enough to understand that
09:24:27 <Feuerbach> or not?
09:24:46 <Feuerbach> it doesn't say anything about roles, apparently
09:24:57 <Iceland_jack> (.) cons x y z = (cons . x) y z = (cons (x y)) z = x y `cons` z may be easier to work out
09:25:29 <Feuerbach> jophish_: I'd start by looking on the issue tracker — this might have been reported and discussed before
09:25:36 <Feuerbach> I mean the linear's issue tracker
09:26:38 <jophish_> Feuerbach: this seems to be something similar: https://github.com/ekmett/linear/issues/19
09:26:42 <jophish_> but the change was pulled
09:29:00 <Lindrian> Iceland_jack: how should I think when they are nested like this (:(.))
09:29:57 <sipa> that's identical to \x -> (x:(\y z -> (y . z)))
09:30:35 <Lindrian> i get an error
09:31:05 <jophish_> what did ghc mean by:  use a standalone 'deriving instance' declaration
09:31:10 <jophish_> in http://lpaste.net/96971
09:32:19 <Feuerbach> just google for standalone deriving
09:35:27 <bz> is there a section equivalent to " (,) 9 "?
09:35:47 <danharaj> if you turn on -XTupleSections
09:35:47 <geekosaur> -XTupleSections
09:35:49 <danharaj> (9,)
09:35:53 <danharaj> :t (9,)
09:35:54 <lambdabot> Num t => t1 -> (t, t1)
09:36:29 <danharaj> :t (9,,"Squid)
09:36:30 <lambdabot>     lexical error in string/character literal at end of input
09:36:39 <danharaj> :t (9,,"Squid")
09:36:40 <lambdabot> Num t => t1 -> (t, t1, [Char])
09:37:02 <danharaj> :t (9,,"Squid",,,\x -> x)
09:37:03 <lambdabot> Num t => t1 -> t2 -> t3 -> (t, t1, [Char], t2, t3, t4 -> t4)
09:37:04 <FreeFull> Tuple sections let you avoid having to write lambdas
09:38:27 <jophish_> hmm, deriving instance Apply (f a) => Apply (Point f a)
09:38:32 <jophish_> this doesn't seem to be quite right
09:40:28 <jophish_> I don't think that I quite understand the syntax
09:42:15 <dan> trying to learn me a haskell for great good, and i'm having a little trouble conceptually understanding the fibonacci sequence, and why i cant write a function for part of it
09:42:53 <Cale> dan: ?
09:42:56 <dan> i have the canonical 1:1:zipWith solution, but just for trying to understand types, i wanted to have another function that let me call the n-th element from that (infinite) list
09:43:09 <Cale> okay
09:43:17 <Cale> You can do that, sure.
09:43:27 <newsham> to get the nth element you need to write a list indexing function (or use one from the lib)
09:43:31 <Kaidelong> well there is !!, if you want a very simple answer
09:43:31 <dan> so, 'fibs' is my function to make my list of fibonacci numbers. i know (now) that i could just do fibs !! 10 to get the 10th number
09:44:05 <merijn> I suspect he wants to implement something equivalent to !! himself
09:44:20 <newsham> its possible to write a fibs function that takes an arg to give you just the nth fib number, of course
09:44:48 <Kaidelong> well you do it by essentially converting the number to unary, in a sense. Counting.
09:44:51 <Kaidelong> in a loop
09:44:51 <dan> hrm, not quite re-implementing !!, just wrapping it, because i know i still struggle with types
09:45:40 <dwcook> dan, what, specifically, are you having trouble understanding?
09:45:41 <dan> so, if fibs is my function to make my infinite list, I wanted say fib (Integral a) => a -> a; fib x = fibs !! x
09:45:56 <merijn> Ah
09:46:01 <merijn> :t (!!)
09:46:02 <dan> which, again, i know is trivial and unnecessary, but i cant seem to get the types right
09:46:03 <dwcook> dan, not quite, since (!!) takes an Int in particular.
09:46:05 <dwcook> @type (!!)
09:46:06 <newsham> nthFib n = fibs !! n    ?
09:46:09 <lambdabot> [a] -> Int -> a
09:46:09 <lambdabot> [a] -> Int -> a
09:46:10 <Feuerbach> jophish_: well, as we said earlier, the goal of getting many libraries compiled by 7.7 is very ambitious. Unfortunately, I don't have time right now to look into those errors closely
09:46:12 <newsham> wrapping it like so?
09:46:20 <merijn> dan: !! only works with Int
09:46:31 <dan> ahh, ok, let me see
09:46:34 <merijn> dan: So you'd want something like "Integral a => Int -> a"
09:46:38 <Cale> dan: Note that you can almost always leave the type out and ask GHCi what it thinks
09:46:47 <newsham> btw you can write the function without a type signature and then ask haskell what the type signature is
09:46:55 <newsham> or do it from the bot in here
09:47:08 * dwcook jumps out of the conversation, since people are repeating things already :P
09:47:09 <Kaidelong> @ty let getFib = (fibs !!) where fibs = 1 : scanl 1 (+) fibs in getFib
09:47:11 <lambdabot> (Num (a -> a -> a), Num ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a), Num a) => Int -> a -> a -> a
09:47:11 <newsham> ?type let f n = fibs !! n in f
09:47:12 <lambdabot> Not in scope: `fibs'
09:47:33 <jophish_> Feuerbach: no worries.
09:47:40 <Kaidelong> Well I did something wrong
09:47:42 <jophish_> I've managed to narrow things down to this: http://lpaste.net/96973
09:48:22 <newsham> ?let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
09:48:24 <lambdabot>  Defined.
09:48:27 <newsham> ?type let f n = fibs !! n in f
09:48:28 <lambdabot> Num a => Int -> a
09:48:56 <danharaj> :t genericIndex
09:49:01 <lambdabot> Integral a => [b] -> a -> b
09:50:19 <jophish_> I can get things to compile without instances of R1-4 and Core
09:50:25 <jophish_> I don't even know what they do!
09:50:42 <dan> hrm, ok. im getting there but not quite yet; i think i just need to look at types more closely before trying to move forward
09:51:32 <merijn> dan: The basic problem was that (!!) wanted an Int and there is not magical conversion in haskell. So if !! wants an int and your function just directly passes on its argument, your function needs to get an Int too
09:51:58 <merijn> dan: That, or you would have to explicitly convert your function's argument to Int using fromIntegral
09:51:59 <newsham> dan: if you have specific type questions, this is an excellent place to ask
09:52:01 <merijn> :t fromIntegral
09:52:03 <lambdabot> (Integral a, Num b) => a -> b
09:53:03 <jophish_> what is the Core typeclass?
09:54:08 <dan> I guess I'm not clear on when/why I might need to include a variable along with the type, and when I wouldn't. What made my nthFib work, as far as type-declarations go, was nthFib :: Int -> Integer. but if I'm supplying an argument, why isn't it something like: nthFib :: (Integral a) => Int -> a ?
09:54:40 <merijn> dan: Are you testing in ghci?
09:54:52 <dan> for the other (admittedly basic) examples, I've represented all my input variables with a's (b's, c's, etc) in the type declaration
09:55:00 <merijn> dan: i.e. specifying the function in ghci using let?
09:55:01 <jophish_> or the R1 typeclass
09:55:09 <dan> yes, inside ghci. well, i write the funcs in a module, then i (re)load the module
09:55:17 <dan> so, no not in ghci :)
09:55:20 <merijn> ah, that should work
09:55:29 <merijn> dan: "Integral a => Int -> a" should work
09:55:34 <merijn> oh!
09:55:44 <merijn> dan: Is "fibs" a top level value?
09:55:55 * merijn smells Dreaded Monomorphism Restriction
09:56:10 <Iceland_jack> <Lindrian> Iceland_jack: how should I think when they are nested like this (:(.))
09:56:11 <Iceland_jack> When you have something like (• a) it's equal to (\x -> x • a)
09:56:35 <merijn> dan: Also, does "fibs" have a type signature?
09:56:36 <dan> erm? fibs is a function in the same module?
09:56:50 <jophish_> Module ‛GHC.TypeLits’ does not export ‛Sing’
09:57:00 <dan> fibs :: [Integer]
09:57:05 <merijn> dan: Bingo
09:57:12 <Iceland_jack> @ty (: "test")
09:57:13 <lambdabot> Char -> [Char]
09:57:16 <Twey> jophish_: What version of GHC?
09:57:17 <Iceland_jack> @ty \t -> t : "test"
09:57:18 <lambdabot> Char -> [Char]
09:57:33 <merijn> dan: If "fibs" is a list of Integer, how can nthFib return something other than an Integer when it uses fibs? :)
09:57:33 <jophish_> The Glorious Glasgow Haskell Compilation System, version 7.7.20131212 -- Twey
09:58:14 <merijn> dan: Easily fixed by making it "fibs :: Integral a => [a]" and "nthFib :: Integral a => Int -> a"
09:58:16 <dan> cause of um, haha. alright, that makes sense, that should've been pretty obvious
09:58:24 <newsham> dan: its possible for the programmer to write a type signature which is more restrictive than what is allowed
09:58:33 <newsham> and the compiler will honor what you ask
09:58:33 <Twey> Hm
09:58:57 <dan> oh ok, so yeah, I should just look a bit at typeclassopedia
09:59:04 <newsham> i. you could make "nthFib :: Int -> Int"  even though you wrote it in a way to allow a more generic "Integral a => Int -> a"
09:59:26 <Kaidelong> newsham: weren't there exceptions to that when you involve certain extensions?
09:59:28 <jophish_> Twey: perhaps they are in another module
09:59:34 <merijn> dan: GHC just checks the types work out, not if they types are as liberal as possible. For example if you write "id x = x" then it'd have type "a -> a" but if I added "id :: Int -> Int" it would still only be allowed to use Int by GHC, even though it could work on more types
10:00:08 <Twey> jophish_: AFAIK it should be there
10:00:11 <jophish_> where could I search for these symbols?
10:00:19 <newsham> kaide: no need to go into every nuance right now
10:00:24 <dan> ahh, ok, that makes perfect sense, i just wasn't aware of which were more or less restrictive, among Int, Integer, Integral
10:00:34 <Twey> I don't have 7.7 to try it out right now, but the docs say Sing is in GHC.TypeLits
10:00:38 <dan> ok, that makes mroe sense now, and things are working smoothly, thanks!
10:00:48 <merijn> dan: Int and Integer are concrete types, both require explicit conversion between the two
10:01:00 <merijn> dan: Integral is a typeclass of which both Int and Integer are instances
10:01:28 <merijn> dan: Also, with your definition of fibs, the following wiki article might be relevant to you:
10:01:31 <merijn> @where dmr
10:01:31 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
10:01:50 <merijn> dan: Because without the type if will do weird things, so better read that first so you're aware :)
10:01:51 <dan> ahh, ok. that makes sense. and rings a bell, i think Int has a max, while Integer can be an arbitrarily large value?
10:02:14 <merijn> dan: Integer uses libgmp which can go up to bigger than your RAM will allow :)
10:02:24 <dan> yep. alright, back to some tutorials before I try to jump into projecteuler i guess
10:02:36 <dan> I see. thanks!
10:02:36 <merijn> dan: The haskell report defines Int to be *at least* 27 bits (in GHC it can be 32 or 64 depending on version)
10:02:41 <Iceland_jack> dan: You can think of Integral as being a set = {Int, Integer, Word, Word8, Word16, …, Int8, Int16, … }
10:02:56 <Iceland_jack> It's a good enough intuition
10:03:30 <jophish_> Twey: the string SingI doesn't appear anywhere in my ghc source tree
10:04:21 <jophish_> (in any .hs files
10:04:21 <merijn> dan: Unrelated, I personally think project euler is a fairly poor source of exercises
10:04:29 <Twey> Strange
10:04:53 <monochrom> GHC Int and Word sizes follow your choice of 32-bit GHC or 64-bit GHC.
10:04:58 <jmcarthur> i'm with merijn. after the first couple you do, they end up all having the same basic strategy, as far as programming goes
10:05:14 <jmcarthur> <do some stuff with lists in a short function>
10:05:40 <merijn> jmcarthur: Hence why I started adding stuff to
10:05:42 <Lindrian> Iceland_jack: what does that mean?
10:05:44 <merijn> @where exercises
10:05:44 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
10:05:50 <Lindrian> Iceland_jack: the fat dot that is
10:05:51 <merijn> Could use some more links, though :)
10:05:59 <Iceland_jack> Lindrian: I use the fat dot to refer to any operator
10:06:02 <jophish_> Twey: just searched through every file in the source tree, SingI doesn't appear
10:06:06 <jophish_> was it deprecated?
10:06:09 <Iceland_jack> you can replace it with +, *, ++, ...
10:06:17 <monochrom> Project Euler is supposed to be exercises in insane number theory, not programming.
10:06:18 <Iceland_jack> (+ a) = \x -> x + a
10:06:25 <Iceland_jack> (a +) = \x -> a + x
10:06:57 <Lindrian> Iceland_jack: so in (:(.)) = \x -> x : (.)
10:07:03 <Iceland_jack> exactly
10:07:11 <monochrom> for example if you're using a loop or list based on trial division to find a lot of primes, you're already doing it wrong.
10:07:11 <Lindrian> Iceland_jack: but this would result in a type error as . returns a function, and : expects a list
10:07:17 <Iceland_jack> yes
10:07:22 <Lindrian> yay im learning
10:07:48 <Twey> jophish_: I highly doubt that
10:08:06 <Twey> It might have been moved
10:08:17 <jmcarthur> monochrom: right, but i wouldn't say the process of coming up with the right way helps you learn the programming language you are using all that much
10:08:26 <Iceland_jack> Lindrian: When you have a (: xs), xs must always be a list
10:08:36 <jmcarthur> maybe that is all you mean
10:08:49 <monochrom> jmcarthur, did you read my <monochrom> Project Euler is supposed to be exercises in insane number theory, not programming. ?
10:09:05 <jophish_> Is there a way to find the file path for imports
10:09:09 <volty> hi, groupBy digits s where digits a b = isDigit a && isDigit b // can this be reworked with function composition over parameters (without closure) ?
10:09:36 <jmcarthur> monochrom: yes, but i gave it a slightly different interpretation. it's okay, i understand why you said this now.
10:09:43 <jophish_> I have no idea where libraries are on my system
10:09:44 <Twey> volty: digits = on (&&) isDigit
10:10:36 <jmcarthur> :t on
10:10:37 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
10:13:12 <volty> Twey: thx :)
10:13:30 <jophish_> Twey: SingI is nowhere to be found :/
10:17:45 <cariveri> whats the haskell equivalent of a next_ptr -> RingElement ? something with Enum?
10:19:36 <monochrom> what is next_ptr?
10:19:48 <cariveri> a pointer to the next element
10:19:56 <monochrom> or what is next_ptr -> RingElement?
10:20:17 <cariveri> a pointer on an element organizeds in a ring
10:20:19 <dwcook> You might be interested in a list?
10:20:34 <cariveri> dwcook: lists dont rebegin
10:20:39 <dwcook> > let xs = 1:2:3:4:xs in xs
10:20:41 <lambdabot>  [1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2...
10:20:45 <dwcook> cariveri, oh really?
10:21:04 <cariveri> hm
10:21:04 <monochrom> I will just say: I don't know.
10:21:33 <dwcook> The thing I just did there is the same as cycle [1,2,3,4], by the way
10:21:36 <dwcook> > cycle [1,2,3,4]
10:21:38 <lambdabot>  [1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2...
10:21:45 <cariveri> dwcook: yea I see. its nice.
10:22:00 <dwcook> Is that what you were asking for?
10:22:03 <cariveri> and it works on any Enum type?
10:22:09 <dwcook> It works on any list type at all
10:22:24 <monochrom> Enum is completely unrelated
10:22:39 <cariveri> ok. and a pointer for getting the next element quickly?
10:22:42 <Kaidelong> lists are essentially a result in the form of (result,continuation)
10:22:43 <dwcook> Ah, perhaps you wanted something like: cycle [begin..end], where begin and end are elements of your Enum type
10:22:50 <dwcook> The next element is always the head of the list
10:23:06 <monochrom> must it be a pointer? why must it be a pointer?
10:23:12 <Kaidelong> that captures cyclical structures
10:23:16 <int-e> @type tail -- this is essentially a pointer dereference
10:23:18 <lambdabot> [a] -> [a]
10:23:30 <dwcook> Though be careful – the empty list has no head or tail
10:23:41 <dwcook> Thus, I suggest pattern matching as appropriate
10:23:44 <int-e> but that's an implementation detail. I think the question is really to specific, too low-level, to give useful answers.
10:23:54 <int-e> to -> too
10:24:25 <cariveri> yes. I think thats it. lists are surprisingly powerful
10:24:55 <jophish_> Twey: singi has been removed
10:25:08 <jophish_> https://github.com/VinylRecords/Vinyl/pull/21
10:25:26 <Kaidelong> I think they might be misnamed since lists are better considered as nondeterministic functions
10:25:31 <Kaidelong> ala prolog
10:25:39 <Kaidelong> especially when you consider how they behave as a monad
10:26:14 <benmachine> Kaidelong: eh, I don't think you can say that's the be-all and end-all of lists
10:26:15 <dwcook> Kaidelong, how would you consider lists to be functions?
10:26:22 <monochrom> maybe we should call it dragon
10:26:58 <dwcook> monochrom, so then we should call cyclic lists ouroboros?
10:27:16 <monochrom> yes
10:27:33 <Kaidelong> dwcook: you poll them for alternatives, in a less pure setting [a] could be seen as () -> Maybe a
10:27:34 <int-e> it'll be a burrito feast
10:27:51 <adek> Do you guys know how can I deal with this: http://pastebin.com/LrC8QFwF
10:27:53 <mauke> The paste LrC8QFwF has been copied to http://lpaste.net/96975
10:28:31 <dwcook> Kaidelong, I don't follow. I thought you were talking about functions in the mathematical sense, but it seems not.
10:28:54 <monochrom> data Dragon a = Nil | Cons a (Dragon a); data Ninja a = Poof | Just a
10:29:07 <dwcook> :D
10:29:33 <dwcook> The ninja dragon lets you see only parts of its body at a time
10:29:53 <dwcook> The parts that aren't trying to eat you, for example
10:30:13 <monochrom> data Hydra a = Node a (Dragon (Hydra a))
10:30:50 <dwcook> data Tweedle a b = Dee a | Dum b
10:30:55 <Kaidelong> aren't mathematical functions stricly deterministic anyway?
10:31:14 <bergmark> adek: unordered-containers might be missing a module in the cabal file, but that's unlikely. It could also be that the package just broke somehow, I usually clear my .ghc to resolve these things
10:31:15 <dwcook> Kaidelong, in the sense that they are pure. They can return lists or sets, however.
10:31:44 <Kaidelong> ah okay, well that's kind of how I saw lists
10:32:05 <Kaidelong> a purely mathematical way to see nondeterminstic functions rather than a data structure in and of itself
10:32:29 <dwcook> highPriestLOL, would you mind not using your nick as a status update? Try using /away instead
10:33:33 <adek> bergmark: I even added unordered-containers explicitly to dependencies in cabal, but it didn't work either. Will try rm -rf .ghc
10:36:54 <darthdeus> is there a difference between using `otherwise` and `_`? which one is prefered?
10:37:26 <dwcook> > otherwise
10:37:27 <lambdabot>  True
10:37:36 <monochrom> otherwise equals True. _ does not equal True.
10:37:41 <dwcook> darthdeus, otherwise is the same as True, _ is a pattern that matches anything not yet matched.
10:38:20 <bergmark> darthdeus: only use otherwise in pattern guards, in patterns you will shadow the variable
10:38:21 <dwcook> So, for example, you could have a case after one for otherwise, although it's probably considered bad style
10:38:22 <darthdeus> hmm, but practically if i'm using it as a "catch all" match in a case statement, there is no difference, right?
10:38:39 <dwcook> One difference is what I just said
10:38:51 <darthdeus> i wouldn't be able to use _ in that case?
10:39:02 <dwcook> You could easily use _, and then any further cases won't be reached
10:39:36 <darthdeus> sorry i'm not following
10:39:57 <darthdeus> both of them match all the time, right?
10:40:02 <dwcook> No.
10:40:08 <dwcook> otherwise matches against True only.
10:40:12 <dwcook> Well
10:40:15 <darthdeus> hmm
10:40:16 <dwcook> it doesn't match.
10:40:20 <dwcook> But it's equal to True.
10:40:33 <dwcook> You wouldn't use otherwise when pattern matching, only in a guard.
10:40:46 <dwcook> (Otherwise it's the same as catching any value and giving it the name otherwise)
10:40:50 <darthdeus> so this example from "write yourself a scheme" is wrong? http://lpaste.net/96976
10:41:06 <monochrom> yes
10:41:07 <dwcook> Looks like it.
10:41:12 <darthdeus> it compiles though
10:41:27 <bergmark> darthdeus: you'll get a warning if you compile with -Wall
10:41:35 <monochrom> it is morally wrong. how about this: replace "otherwise" by "foldr". it is still valid. but will you endorse it?
10:42:18 <dwcook> darthdeus, otherwise is a valid variable name. You can use it for your own variables. It's just confusing because its common usage is to be a synonym for True.
10:42:20 <darthdeus> bergmark: cool, didn't see that, my emacs doesn't seem to use -Wall
10:42:29 <darthdeus> ah okay, now i understand
10:42:40 <dwcook> darthdeus, the last case would better be written as _ instead of otherwise, since the value isn't used.
10:43:30 <darthdeus> dwcook: but if i can create my own variable named `otherwise`, doesn't the last case match the value into a local variable named `otherwise`, instead of matching against the predefined value?
10:43:52 <dwcook> darthdeus, correct, it's like you had written otherwise = atom
10:44:00 <dwcook> let otherwise = atom in …
10:44:13 <monochrom> why does lpaste no announce any more?
10:44:18 <darthdeus> dwcook: that makes sense, but why is the compiler complaining then? it says pattern match failure
10:44:28 <darthdeus> but it won't fail if it makes a local variable
10:44:43 <dwcook> darthdeus, what is the exact error message?
10:45:27 <darthdeus> oh lol i'm stupid, it's showing an error on a different match in other function :X
10:45:36 <dwcook> Thought as much.
10:45:46 <dwcook> Not about the stupid part. I don't think you're stupid.
10:45:52 <bergmark> :-)
10:45:57 <darthdeus> :D
10:46:17 <darthdeus> it complains here main = do args@(x:y:_) <- getArgs ... which i guess isn't a best way of doing this
10:46:51 <dwcook> That fails to match on any list of fewer than two elements.
10:47:21 <darthdeus> yeah, i just realized that now ... i never thought about this stuff when programming in ruby :X
10:48:14 <darthdeus> doing haskell stuff is really eye-opening in many ways
10:48:34 <dwcook> In Ruby, I imagine one of two things could have happened if you had ignored something like this: (1) a runtime error; or (2) some behavior you didn't specifically choose
10:49:29 <dwcook> In the second case, you could have been fortunate. But I prefer to make my own luck and decide how I want things to behave. :)
10:50:19 <darthdeus> yeah these kinds of runtime errors are quite common in the dynamic language world i'd say ... after i started learning haskell i finally see these things, most of the time :D
10:50:43 <dwcook> In Haskell, you trade getting it right up front for (relative) runtime safety.
10:51:40 <darthdeus> which is a good thing
10:52:06 <dwcook> Though for better runtime safety, you also need to avoid functions that have error cases, such as head and tail. The Prelude has an unfortunate number of those.
10:52:39 <darthdeus> how often do you need head/tail when you can match with (:) though?
10:52:47 <Kaidelong> failing in runtime has its advantages if it is done right because you have more information and can provide more informative error messages
10:52:48 <merijn> darthdeus: Not frequently
10:53:12 <monochrom> darthdeus: see my http://www.vex.net/~trebla/haskell/crossroad.xhtml
10:53:17 <benmachine> darthdeus: you literally never need head and tail
10:53:20 <merijn> darthdeus: I can't remember the last time I used head :p
10:53:34 <merijn> I occasionally use tail to write infinite fibonacci :p
10:53:39 <benmachine> I mean, that's true in a boring trivial sense, but it's also pretty true "genuinely" as wel
10:53:54 <darthdeus> monochrom: thanks i'll check it out
10:53:54 <benmachine> head maybe sometimes, but usually pattern matching is everything
10:54:20 <jophish_> GHC.MatchGroup seems to have gone, what can I use as a replacement?
10:54:36 <bergmark> darthdeus: i use headMay from the safe package pretty often
10:56:19 <darthdeus> so many good things in here
10:58:22 <nlogax> Interesting `head's in Idris http://i.imgur.com/fW5VR1a.png
10:59:15 <Cale> nlogax: of course
10:59:47 <darthdeus> should I do  (Number . read) "42"  or   (read "42") :: Int ? is there a difference? since neither of these will parse floats
10:59:48 <dwcook> Is that statically verified not to accept empty lists?
11:00:23 <dwcook> darthdeus, I don't think that first one is correct. What's this Number type constructor?
11:00:28 <darthdeus> hm sorry i'm being confusing, Number is a custom type constructor
11:00:38 <darthdeus> i confused it with Nume
11:00:40 <darthdeus> Num*
11:00:48 <Iceland_jack> Num is not a function :)
11:00:56 <dwcook> Num wouldn't work there either.
11:01:10 <Cale> (Unless it counts as a type level function which constructs a Constraint ;)
11:01:12 <darthdeus> yeah Number is defined as constructor of  Number Integer
11:01:27 <dwcook> In any case, if you wrote a type constructor in that position, it would have a different result from the second one you mentioned.
11:01:47 <dwcook> i.e., values of different types
11:02:09 <merijn> darthdeus: There is no real difference between "(Number . read) "42"" and "Number (read "42" :: Int)"
11:02:20 <merijn> darthdeus: I would personally prefer some variation of the former
11:02:48 <darthdeus> merijn: cool, that's kinda what i had in mind but didn't formulate my question well :)
11:02:56 <Cale> Probably you can avoid giving the explicit type signature, depending on what type Number has.
11:03:00 <merijn> darthdeus: The type annotation for read is usually only used when GHC does not have enough information to infer which implementation of "read" it should use
11:03:08 <Iceland_jack> If you have a chain of more than 2 functions I generally prefer (a . b . … . z) 42
11:03:24 <Cale> Yeah, or even a . b . ... . z $ 42
11:03:26 <merijn> darthdeus: If Number lets GHC infer the type properly, it's better style not to explicitly annotate
11:03:26 <Iceland_jack> but for your case 'Number (read "42")' is good enough
11:03:29 <darthdeus> should I always provide the annotation or only when it doesn't compile?
11:03:36 <Iceland_jack> darthdeus: You don't need the annotation there
11:03:36 <darthdeus> okay
11:03:56 <dwcook> I wouldn't provide annotation if its context provides a concrete type
11:03:56 <Cale> darthdeus: When it's ambiguous. Giving type annotations for top-level definitions is also good practice
11:03:57 <merijn> darthdeus: In general, only annotate when 1) it doesn't compile *AND* 2) you know why the annotation fixes that
11:04:00 <darthdeus> it's amazing how it can almost always infer the types ... unlike scala which almost always needs you to specify the types
11:04:11 <Cale> darthdeus: right
11:04:17 <Iceland_jack> Since you said that Number was defined as something like 'data Number = Number Integer'
11:04:19 <Cale> darthdeus: That's because no subtyping
11:04:19 <dwcook> On the other hand, I annotate top level definitions as often as possible
11:04:30 <Iceland_jack> so if you do 'Number foo' Haskell will know that foo has type Integer
11:04:35 <Cale> Subtyping makes inference impractical.
11:04:38 <dwcook> Simply because it's easier for me to reason about that way
11:04:39 <merijn> darthdeus: And as Cale points out, top-level types are helpful for you/other programmers (i.e. I don't debug code without top level annotation)
11:04:54 <merijn> dwcook: I implicitly assumed that annotating top-level was obvious :)
11:05:05 <darthdeus> right, i always annotate top level thingies :)
11:05:12 <merijn> I was thinking of where/inline annotations
11:05:14 <darthdeus> i can't even read my own code without those
11:05:17 <osa1> how relevant are G-machines defined in "The Implementation of Functional PLs" and "Implementing Fun Langs: A Tutorial" t0 current GHC implementation?
11:05:20 <Cale> I don't *always* annotate top-level things
11:05:32 <merijn> Cale: That means the terrorists win!
11:05:53 <dwcook> merijn, yeah, they could be hiding bombs in those unseen type annotations!
11:05:54 <merijn> osa1: It's still based on G-machines, afaik
11:06:07 <merijn> osa1: A spineless, tagless G-machine, to be precise
11:06:09 <monochrom> I use my good judgement on handwritten types. except where haddock requires handwritten types.
11:06:20 <Cale> osa1: G-machines are still relevant. A good starting point if you want to understand how GHC compiles Haskell code is to read the Spineless Tagless G-Machine paper, though it's not quite spineless or tagless anymore.
11:06:21 <dwcook> f :: Building -> Bomb -> Kaboom
11:06:39 <Cale> http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
11:06:40 <dwcook> (The only value of type Kaboom is undefined)
11:06:52 <Iceland_jack> dwcook: No IO? :)
11:07:02 <Iceland_jack>     type Kaboom = IO ()
11:07:02 <dwcook> Iceland_jack, isn't it bad enough that it crashes your program?
11:07:05 <osa1> Cale: thanks for the paper
11:07:06 <dwcook> Ooh, yes
11:07:06 <Iceland_jack> No!
11:07:08 <monochrom> Haskell is a language for which I can safely say "go with your heart" because Haskell tends to cultivate good taste in you.
11:07:21 <osa1> where can I see, for example, instructions of current G-machine in GHC source code?
11:07:22 <kakos> In ghci, is there a way to view the raw internal representationof a value?
11:07:22 <dwcook> launchTheMissiles :: IO ()
11:07:24 <gnuvince> Is it in Haskell that you can have _foo patterns to ignore a parameter, while still giving it a meaningful name?
11:07:25 <Iceland_jack> I will use
11:07:25 <Iceland_jack>     main ∷ Kaboom
11:07:26 <Iceland_jack>     main = …
11:07:28 <osa1> just to have an idea
11:07:29 <Iceland_jack> from now on
11:07:32 <dwcook> :D
11:07:33 <monochrom> (I wouldn't say "go with your heart" for many other languges)
11:07:54 <byorgey> gnuvince: yes
11:08:20 <byorgey> gnuvince: you don't have to ignore a parameter named _foo.  It's just that you won't get a warning about it if you do.
11:08:32 <merijn> gnuvince: Well, for some value of ignore, the unused parameter warning doesn't apply to variables starting with a _
11:08:58 <gnuvince> byorgey: thanks
11:09:08 <gnuvince> merijn: thanks
11:09:16 <gnuvince> That's exactly what I wanted.
11:10:32 <Cale> The cases where I won't provide top-level type annotations tend to be cases where 1) I'm writing the program for my own sake. and 2) I know exactly what I'm doing, and am pretty sure I'll get it right the first time anyway.
11:11:08 * hackagebot simple-sql-parser 0.1.0.0 - A parser for SQL queries  http://hackage.haskell.org/package/simple-sql-parser-0.1.0.0 (JakeWheat)
11:11:44 <Cale> There are also cases where the type annotations can be awkward to provide just because they're longer than the definition. Occasionally I'll try leaving them out there as well, but will usually end up adding them in later when I have to deal with a type error involving that definition.
11:11:46 <Cale> :)
11:12:03 <Oobaew83> Hey, how do I print a unicode in haskell?
11:12:06 <Cale> (GHC consistently produces much better error messages if you annotate)
11:12:28 <Iceland_jack> Oobaew83: putChar 'λ'?
11:12:49 <Oobaew83> Iceland_jack: I have the code though. How do I translate the code to the character?
11:12:55 <Cale> Oobaew83: You do nothing special. All the standard text I/O should work fine if your locale is set to use UTF-8
11:13:11 <Cale> Oobaew83: chr or toEnum
11:13:18 <Cale> > toEnum 4382 :: Char
11:13:19 <lambdabot>  '\4382'
11:13:32 <Oobaew83> toEnum 26C0
11:13:33 <monochrom> for some definitions I go further than types. I write a complete specification in comments.
11:13:37 <Oobaew83> > toEnum 26C0
11:13:38 <lambdabot>  Not in scope: data constructor `C0'
11:13:53 <Cale> You'll have to prefix the hexadecimal code with 0x
11:14:00 <Oobaew83> > toEnum 0x26C0
11:14:01 <lambdabot>  *Exception: Prelude.Enum.().toEnum: bad argument
11:14:03 <Cale> Or use '\x26C0'
11:14:11 <Oobaew83> > toEnum \x26C0
11:14:12 <lambdabot>  <hint>:1:8: parse error on input `\'
11:14:21 <geekosaur> you need to specify a type
11:14:25 <Oobaew83> > toEnum '\x26C0'
11:14:27 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
11:14:27 <lambdabot>              with actual type `GHC.Types.Char'
11:14:28 <sipa_> > '\x26C0'
11:14:29 <lambdabot>  '\9920'
11:14:30 <Iceland_jack> > '\x26C0'
11:14:31 <lambdabot>  '\9920'
11:14:38 <sipa_> > printLn '\x26C0'
11:14:38 <Oobaew83> http://www.fileformat.info/info/unicode/char/26c0/index.htm
11:14:39 <lambdabot>  Not in scope: `printLn'
11:14:39 <lambdabot>  Perhaps you meant one of these:
11:14:39 <lambdabot>    `print' (imported from Prelude),
11:14:39 <lambdabot>    `printf' (imported from Text.Printf)
11:14:49 <sipa_> > print "\x26C0"
11:14:50 <lambdabot>  <IO ()>
11:14:54 <geekosaur> Oobaew83, toEnum, needs to know WHICH enum
11:15:14 <Oobaew83> geekosaur: I need to know which enum xD
11:15:16 <geekosaur> which is why Cale specified one, and all your attempts to not specify one were type errors
11:15:19 <geekosaur> Char
11:15:20 <Iceland_jack> Char
11:15:22 <geekosaur> as Cale showed
11:15:34 <monochrom> yeah, did you read what Cale wrote?
11:15:42 <Iceland_jack> If you do: putChar (toEnum …) you don't need to specify the type
11:15:50 <monochrom> why do people never read? why are people write-only?
11:15:50 <Oobaew83> I failed to parse what Cale wrote.
11:16:00 <Cale> Sorry about that
11:16:22 <monochrom> ok, and your exception handler for parse errors is just ignore?
11:16:25 <Cale> I've only been giving the channel about 50% of my attention :)
11:16:36 <Oobaew83> monochrom: no it's Nothing
11:16:51 <Cale> > fromEnum 0x26c0 :: Char
11:16:52 <lambdabot>  Couldn't match expected type `GHC.Types.Char'
11:16:53 <lambdabot>              with actual type `GHC.Types.Int'
11:16:59 <Cale> > toEnum 0x26c0 :: Char
11:17:00 <lambdabot>  '\9920'
11:17:00 <Cale> derp
11:17:09 <Oobaew83> oh man
11:17:12 <Oobaew83> lol
11:17:13 <Cale> > fromEnum '\x26c0' :: Char
11:17:14 <lambdabot>  Couldn't match expected type `GHC.Types.Char'
11:17:14 <lambdabot>              with actual type `GHC.Types.Int'
11:17:16 <Cale> > fromEnum '\x26c0'
11:17:17 <lambdabot>  9920
11:17:20 <Cale> Edit fail! :)
11:17:40 <darthdeus> shouldn't this work?
11:17:41 <darthdeus> > liftM ((+3) . read) $ return "3" :: Maybe String
11:17:42 <Cale> fromEnum doesn't need an annotation of course, because '\x26c0' is obviously a Char
11:17:42 <lambdabot>  No instance for (GHC.Num.Num GHC.Base.String)
11:17:43 <lambdabot>    arising from a use of `GHC.Num.+'
11:17:43 <lambdabot>  Possible fix:
11:17:43 <lambdabot>    add an instance declaration for (GHC.Num.Num GHC.Base.String)
11:18:15 <sipa_> darthdeus: (+3) can't be a applied to a String
11:18:36 <darthdeus> sipa_: but i'm doing read first which converts it to Int no? since (+3) exects a Num
11:18:45 <Cale> darthdeus: You probably meant to also have a show in there?
11:18:52 <darthdeus> > liftM ((+3) . read) $ Just "3"
11:18:53 <darthdeus> this owrks
11:18:53 <lambdabot>  Just 6
11:19:03 <Cale> darthdeus: The type of the whole expression you've specified to be Maybe String
11:19:05 <darthdeus> but not with return "3" :: Maybe String, which I thought would be equivalent
11:19:09 <darthdeus> oh lol
11:19:11 <Cale> darthdeus: So (+3) had better produce a String
11:19:13 <jophish_> I installed ghc from source, and I'd like to remove it from my system, how can I do this?
11:19:20 <Iceland_jack> > liftM ((+3) . read) $ return "3" :: Maybe Int -- exactly what you wrote but with s/String/Int/
11:19:21 <lambdabot>  Just 6
11:19:39 <magicman> > liftM ((+3) . read) $ (return "3" :: Maybe String)
11:19:40 <lambdabot>  Just 6
11:19:41 <darthdeus> I suck at operator precedence :) what i meant to write is this
11:19:44 <darthdeus> > liftM ((+3) . read) $ (return "3" :: Maybe String)
11:19:44 <magicman> Alternatively, that.
11:19:45 <lambdabot>  Just 6
11:19:46 <darthdeus> yeah
11:20:17 <Cale> jophish_: find the files under /usr/local/bin /usr/local/lib and /usr/local/share and delete them by hand
11:20:30 <Cale> (as far as I know, that's all you can do...)
11:21:25 <Oobaew83> aw, the unicode doesn't look like the picture.
11:21:37 <Cale> Oobaew83: ?
11:21:40 <magicman> > let f x@(:){} = head x in f [1,2,3] -- On the one hand, I'm not surprised that works. On the other hand, it looks freaky.
11:21:41 <lambdabot>  1
11:21:53 <Cale> magicman: heh
11:22:18 <jophish_> Cale: thanks
11:22:20 <Oobaew83> Cale: http://www.fileformat.info/info/unicode/char/26c0/index.htm
11:22:26 <Oobaew83> > putChar '\x26c0'
11:22:27 <lambdabot>  <IO ()>
11:22:48 <Cale> > text "\x26c0"
11:22:49 <lambdabot>  ⛀
11:22:56 <Cale> Looks right on my end :)
11:22:59 <Oobaew83> aww
11:23:34 <Oobaew83> mine looks like a empty star with a line on the bottom (I can't seem to copy paste it) and then \x26c1 looks like a star with a line on top of it.
11:25:10 <m1dnight_> quick question guys
11:25:13 <m1dnight_> in the monad book
11:25:16 <m1dnight_> there is this question
11:25:18 <m1dnight_> http://lpaste.net/96978
11:25:21 <m1dnight_> well, more example
11:25:25 <m1dnight_> where they put a Nothing in the do
11:25:42 <m1dnight_> yet, the line 'second <- landRight 2 first' uses the first value
11:25:47 <Fuuzetsu> m1dnight_: What's the monad book?
11:25:52 <Iceland_jack> Probably LYAH
11:25:57 <Iceland_jack> m1dnight_: What is the problem?
11:25:59 <m1dnight_> oh wasnt thinking when typing that
11:26:03 <m1dnight_> yeah, LYAH
11:26:05 <m1dnight_> well
11:26:29 <m1dnight_> is it true, that the 'second' in the line 'second <- landRight 2 first' is a different 'second'
11:26:41 <m1dnight_> than the one in 'landLeft 1 second' ?
11:26:42 <m1dnight_> i mean
11:26:49 <Iceland_jack> m1dnight_: It's the same
11:26:58 <nlogax> Had to zoom in a bit to see what it was supposed to be :) http://i.imgur.com/7K6sKT3.png
11:27:15 <Iceland_jack> You're “binding” the value in ‘landRight 2 first’ to the identifier second
11:27:29 <m1dnight_> hrm
11:27:35 <m1dnight_> yes
11:27:50 <Iceland_jack> > do a <- Just 'a'; b <- Just  'b'; c <- Just 'c'; return [a, b, c] -- Does this make sense m1dnight_ ?
11:27:51 <m1dnight_> but, I also bind the 'landLeft 2 start' to the identifier 'first'
11:27:52 <lambdabot>  Just "abc"
11:28:04 <m1dnight_> euhm
11:28:20 <jophish_> and we're back at: unknown symbol `__objc_empty_vtable'
11:28:24 <m1dnight_> that would give you a Just ['a', 'b', 'c'] right?
11:28:33 <Iceland_jack> Check the output of lambdabot ;)
11:28:38 <m1dnight_> oh yes exactly
11:28:38 <m1dnight_> yes
11:28:44 <m1dnight_> but i'm a bit confused with the nothing in the example
11:28:49 <m1dnight_> I mean,
11:28:49 <Iceland_jack> Sure, let's go to that
11:28:53 <Iceland_jack> Now let's flip one of those Just's into a Nothing
11:29:01 <Iceland_jack> > do a <- Just 'a'; Nothing; c <- Just 'c'; return [a, b, c] -- Does this make sense m1dnight_ ?
11:29:03 <lambdabot>  Couldn't match expected type `GHC.Types.Char'
11:29:03 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
11:29:05 <Iceland_jack> (oops)
11:29:17 <m1dnight_> no exactly
11:29:17 <m1dnight_> but
11:29:21 <Iceland_jack> > do a <- Just 'a'; b <- Nothing; c <- Just 'c'; return [a, b, c]
11:29:22 <lambdabot>  Nothing
11:29:41 <monochrom> m1dnight_: Nothing is specific to the Maybe monad.
11:29:48 <m1dnight_> in the example the line 'landRight 2 first', which comes after the nothing,
11:29:57 <Iceland_jack> m1dnight_: Yes?
11:30:04 <Iceland_jack> That's normal
11:30:05 <m1dnight_> doesnt it say 'landright 2 (2,0)?
11:30:15 <m1dnight_> beacuse it uses the 'first' identiefier
11:30:18 <m1dnight_> sorry for typos
11:30:37 <Iceland_jack> Yes first would have value (2, 0)
11:30:41 <m1dnight_> oh
11:30:49 <Iceland_jack> start should have value (0, 0)
11:31:00 <m1dnight_> I SEE NOW
11:31:05 <Iceland_jack> :)
11:31:13 <m1dnight_> because of the nothing
11:31:21 <m1dnight_> Nothing >>= .. it's just nothing
11:31:24 <monochrom> nothing kills everything
11:31:25 <Iceland_jack> yes exactly
11:31:29 <m1dnight_> i see now
11:31:34 <m1dnight_> yes yes yes :)
11:31:38 <Iceland_jack> so Nothing gets propagated
11:32:02 <m1dnight_> I get it!
11:32:03 <m1dnight_> thanks guys
11:32:10 <m1dnight_> just needed some collaborative thinking I suppose :p
11:32:10 <m1dnight_> thanks :)
11:32:17 <Iceland_jack> Great :) we're guys and gals here
11:32:32 <Iceland_jack> > sequence [Just 't', Just 'e', Just 's', Just 't']
11:32:33 <lambdabot>  Just "test"
11:32:36 <Iceland_jack> > sequence [Just 't', Nothing, Just 'e', Just 's', Just 't']
11:32:37 <lambdabot>  Nothing
11:32:59 <m1dnight_> yes :) it's pretty clear now
11:33:15 <m1dnight_> I forgot that the nothing kills the result
11:33:17 <m1dnight_> now I get it :)
11:33:18 <m1dnight_> thanks man
11:33:20 <Iceland_jack> m1dnight_: You may want to check out the definition of sequence and see if it makes sense knowing how Maybe works
11:33:25 <m1dnight_>  or /woman
11:33:28 <Iceland_jack> ;)
11:33:29 <Iceland_jack> You're welcome
11:33:42 <Iceland_jack> @src sequence
11:33:42 <lambdabot> sequence []     = return []
11:33:42 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:33:42 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
11:34:06 <Iceland_jack> m1dnight_: Also note that ‘return []’ = Just [] (in the case of the Maybe monad)
11:34:12 <Iceland_jack> > return [] :: Maybe [a]
11:34:13 <lambdabot>  Just []
11:34:19 <Iceland_jack> > return 'a' :: Maybe Char
11:34:20 <lambdabot>  Just 'a'
11:37:39 <kinslayer> Hey all I am a bit green in haskell, but I really want to get better, and I got this problem
11:38:29 <Iceland_jack> kinslayer: What's the problem?
11:38:37 <kinslayer> I took a Network.HTTP.Conduit to download a json file, but it returns a ByteString (well the Lazy version) and I need to do some operations over it to take out some data. How can I either get a string or operate on the ByteString ?
11:39:01 <Iceland_jack> Have you looked into the ByteString library?
11:39:28 <kinslayer> well I tried to import ByteString and unpack, but it just gives me a list of numbers (Word8)
11:39:44 <kinslayer> so I am getting a little frustrated with this
11:39:58 <monochrom> no, don't go through String first, that's an XY problem. directly give it to a json parser such as aeson
11:40:42 <Iceland_jack> kinslayer: for future reference use ‘Data.ByteString.Char8’
11:40:42 <kinslayer> okay now for the stupid noob question, what would a good json parser be, there is a lot on hackage
11:40:48 <Iceland_jack> aeson
11:41:13 <kinslayer> okay thanks, I am trying to download bitcoin price info and do well something with them
11:41:15 <Ankhers> I am attempting to create a synonym for (Num, Num). How would I create this type?
11:41:20 <hpc> imo the fact that it returns ByteString is quite problematic
11:41:37 <Iceland_jack> Ankhers: type NumNum = (Num, Num) if you really do mean Num
11:41:43 <hpc> because if you really did want a stringy piece of data out of it you have to guess the encoding
11:42:23 <monochrom> aaannnddd... aeson wants a ByteString from you. I hope your next question is not "I have converted ByteString to String, how do I convert it back for aeson?"
11:42:31 <Ankhers> Iceland_jack: I keep getting the error, "expecting one more argument to 'Num'"
11:42:31 <Iceland_jack> lol
11:42:32 <geekosaur> Ankhers, do you actually mean a type you created named Num there?
11:42:40 <Iceland_jack> Ankhers: Num is a type class
11:42:46 <Iceland_jack> Not a type, you probably want Int
11:42:48 <Ankhers> No, I actually want a number that could be positive or negative.
11:42:51 <Iceland_jack> or Integer or what ever
11:42:56 * monochrom hates programmers thinking up so many XY problems
11:43:06 <Iceland_jack> Ankhers: Yes, that's Int and Integer
11:43:07 <hpc> YZ problems are much more fun!
11:43:20 <Iceland_jack> > map succ "XY"
11:43:21 <lambdabot>  "YZ"
11:43:27 <monochrom> well, make it XYZ problems then. in fact we almost had one
11:43:49 <Iceland_jack> > ['X'..] ++ " problems"
11:43:51 <lambdabot>  "XYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\13...
11:44:22 <geekosaur> so you're claiming XY problems succ?
11:44:30 <Iceland_jack> I suppose I am ;)
11:44:52 <Iceland_jack> or that "YZ" problems are a succ-ier version of "XY" problems
11:44:58 <hpc> i like how "{}" are not consecutive characters
11:45:38 <triliyn> What is an XY problem?
11:45:55 <hpc> triliyn: it's where you need to get from X to Z, but ask how to get from X to Y instead
11:46:11 <triliyn> ah, okay
11:46:12 <hpc> on the assumption that a Y to Z operation is necessary, when it really isn't
11:46:19 <ion> triliyn: http://mywiki.wooledge.org/XyProblem
11:46:20 <Eduard_Munteanu> Or when you need Y but wrongly ask for X instead.
11:46:29 <hpc> or that
11:46:33 <hpc> something along the same pattern
11:46:40 <Hodapp> In many ways, it's a side effect of a lot of programmer channels berating people who ask for X when X is not very specific.
11:46:48 <triliyn> Yeah, I've heard of these things
11:46:56 <triliyn> I just wasn't familiar with the term
11:47:05 <hpc> in this case, the question was going BS -> String (assuming String -> JSON as the next step) when BS -> JSON is what's needed
11:48:00 <Eduard_Munteanu> Like people asking for a function IO String -> String when they just need to understand how to use monads.
11:48:16 <hpc> Eduard_Munteanu: to be fair, that question is a symptom of them not understanding monads
11:48:24 <Eduard_Munteanu> Yeah. :)
11:48:30 <Iceland_jack> Eduard_Munteanu: But unsafePerformIO is to IO what runIdentity is to Identity right!
11:48:50 <hpc> Iceland_jack: i prefer unsafeCoerce - it's more generic ;)
11:48:51 <triliyn> We should rename runIdentity to unsafeRunIdentity
11:49:03 <triliyn> For symmetry
11:49:03 <Iceland_jack> heh
11:49:10 <Iceland_jack> fromJust should be unsafeFromJust
11:49:15 <Eduard_Munteanu> Up there in the ivory tower, I just pretend type IO = Identity. :P
11:49:25 <Iceland_jack> head and tail and any [a] → a function should be ("unsafe" ++)
11:49:25 <boom583> Is it a good idea to develop web apps in Haskell?
11:49:35 <dwcook> I want to get my list of files by reading the ls executable, wat do?
11:49:41 <hpc> boom583: it can be a good idea, yes
11:49:45 <dwcook> (Playing on that one quote :P)
11:49:52 <hpc> it depends on what you need, obviously
11:49:53 <Eduard_Munteanu> strings /bin/ls :P
11:49:53 <Iceland_jack> It's a great quote
11:49:56 <triliyn> :t fromJust
11:49:58 <lambdabot> Maybe a -> a
11:49:59 <boom583> I guess I should use some ready-made framework?
11:50:03 <boom583> I've seen Snap. Any others?
11:50:11 <Eduard_Munteanu> @quote shachaf.*bin
11:50:11 <lambdabot> No quotes match. My pet ferret can type better than you!
11:50:12 <hpc> the big three are snap, yesod, happstack
11:50:14 <Eduard_Munteanu> Aw.
11:50:21 <Eduard_Munteanu> @quote bin.*ls
11:50:21 <lambdabot> JonHarrop says: The following traditional implementation of the y-combinator is correct code: fix f = (\x -> f (x x)) (\x -> f (x x)) Yet the type system of standard Haskell fails on it.
11:50:23 <Eduard_Munteanu> @quote bin.*ls
11:50:23 <dwcook> @quite /bin/ls
11:50:23 <lambdabot> JonHarrop says: The following traditional implementation of the y-combinator is correct code: fix f = (\x -> f (x x)) (\x -> f (x x)) Yet the type system of standard Haskell fails on it.
11:50:23 <lambdabot> Maybe you meant: quote quit
11:50:23 <hpc> plus quite a few less-used ones
11:50:27 <Eduard_Munteanu> :(
11:50:54 <dwcook> It's okay, I didn't even manage to spell "quote" correctly
11:50:55 <boom583> hpc, thanks
11:50:56 <monochrom> @quote shachaf IO.*ls
11:50:57 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
11:51:04 <Iceland_jack> JonHarrop!!
11:51:20 <tac> monochrom: hah, that's good.
11:51:37 <monochrom> http://www.vex.net/~trebla/photo/unorganized/IO-String.png
11:51:43 <hpc> boom583: happstack is fairly heavy and really great for web apps, more so than websites
11:52:01 <hpc> snap i understand doesn't really need that much coding experience to use? i never used it
11:52:04 <dwcook> monochrom, I'm confused by that o_0
11:52:07 <Iceland_jack> monochrom: hah!
11:52:18 <Iceland_jack> not quite a pullback~
11:52:20 <Eduard_Munteanu> monochrom: is that a pullback? I think it's a setback. :P
11:52:21 <hpc> and yesod i think is a somewhat lighter version of happstack with different ideas of how to do the same things
11:52:21 <dwcook> Do people actually ask for a function IO String -> IO?
11:52:21 <monochrom> @quote monochrom IO.String
11:52:21 <lambdabot> monochrom says: How do I extract the IO out of IO String?
11:52:29 <dwcook> … Welp.
11:52:40 <monochrom> no, people don't, but I made that joke.
11:52:48 <dwcook> Oh, ha. I was worried for a moment.
11:53:03 <boom583> What do you guys think of Node.js selling point of "same lang on server&client"? Is that really important?
11:53:05 <hpc> you see a whole lot of people asking why (Maybe 5) doesn't work though
11:53:13 <hpc> boom583: it's fairly pointless
11:53:15 <monochrom> no, actually, it worries me that people don't ask that question. it is a cognitive dissonance.
11:53:23 <hpc> for one, server js isn't the same as browser js
11:53:45 <dwcook> monochrom, true, I was operating under the assumption that since they don't ask it, they're not confused about it. But then I realized that's not necessarily true.
11:54:01 <monochrom> the very same logic for "IO String -> String", though faulty, should be just as good for "IO String -> IO".
11:54:02 <hpc> the DOM isn't there, a lot of events are different, different behaviors of the interpreter that inevitably leak into how you write code
11:54:06 <boom583> yeah
11:54:27 <monochrom> but humans, they don't apply their own logics consistently.
11:54:32 <Eduard_Munteanu> boom583: IMO, client-side JS is more of a machine code. A few things already target JS like that.
11:54:35 <hpc> you wouldn't think twice at writing a long running computation in node, but the same thing in a browser gets you into huge usability issues
11:54:57 <dwcook> monochrom, I disagree, you need to take another step of faulty logic for that one, namely, believing that values can have type IO.
11:55:04 <simpson> boom583: Homogenous stacks are easier to deal with, yes, but JS is never pleasant.
11:55:20 <dwcook> monochrom, … never mind, I'm making assumptions again
11:55:23 <hpc> but yeah, "same language server/client" is at best irrelevant, at worst actively unhelpful to people trying to make an informed decision
11:55:25 <Eduard_Munteanu> boom583: I suspect DOM is more interesting in that context than JS itself.
11:55:30 <nlogax_> boom583: I guess it depends on your opinion of JS. If you enjoy it, then great, now you can enjoy it everywhere. If you hate it, then of course you don't want *more* of it
11:55:37 <dwcook> +faulty
11:55:41 <boom583> ok
11:55:55 <Eduard_Munteanu> Since DOM is the interface, JS just happens to be a particular "machine code".
11:57:38 <boom583> Interesting
11:57:40 <boom583> http://stackoverflow.com/questions/3847108/what-is-the-haskell-response-to-node-js
11:57:56 <nlogax_> None, I hope
11:57:57 <boom583> The answers indicate that the event handling of Node.js isn't that good of idea
11:58:03 <jmcarthur> monochrom: i don't think that's true. i think a lot of beginner's developer a really bad mental model of IO due to the way monad tutorials just present monads as containers:    newtype IO a = IO a
11:58:13 <boom583> they indicate that it should rather be one thread per client conenction
11:58:28 <jmcarthur> monochrom: from that model it would make sense to be able to go from IO String to String, but not from IO String to IO
11:58:36 <Iceland_jack> boom583: Have you tried both styles?
11:58:48 <boom583> Iceland_jack: nope, only node.js
11:58:54 <boom583> my sites run on node
11:58:57 <Iceland_jack> Maybe you should try to write using threads
11:59:25 <jmcarthur> *beginners develop
11:59:34 <monochrom> I guess I have the bad fortune of not having read any of the bad tutorials
11:59:55 <Hafydd> Well, look at that: Simon Marlow commented on that question.
12:00:26 <jmcarthur> monochrom: e.g. "the IO monad is like a box. bind takes the value out of the box and applies a function to it."
12:00:30 <nlogax> nodejs' eventness makes you write all your code differently, GHC threads makes you write most code in normal direct style
12:00:37 <nlogax> I prefer the latter
12:01:11 <boom583> nlogax: do snap, yesod and happstack all do it that way?
12:01:11 <Hodapp> nlogax: but is it webscale?
12:01:15 <jmcarthur> boom583: threads are *so* much nicer than callback style
12:01:23 <Eduard_Munteanu> "Moreover, communication between callbacks isn't possible (it would deadlock)."  -- it would be interesting to do that by preempting and passing continuations to your callee
12:01:24 <monochrom> I don't know what is Haskell's response to Node.js, but I know my response. it is "XY problem".
12:01:28 <simpson> boom583: I'm obligated to point out that, by that SO question's own admission, Node is just an inferior Twisted.
12:01:52 <boom583> heh
12:02:11 <boom583> Who is Simon Marlow?
12:02:15 <stepcut> the new GHC 7.8 parallel IO manager has extra webscale now
12:02:16 <nlogax> boom583: I think so
12:02:18 <boom583> ok
12:02:35 <hpc> jmcarthur: "the IO monad is like a box. bind takes a function and stuffs it into the box, where it gets applied to the value" -- much better explanation ;)
12:02:50 <Eduard_Munteanu> boom583: one of the two prominent developers of Haskell at MS
12:02:50 <hpc> (at least, less misleading)
12:02:56 <boom583> ok
12:02:58 <jmcarthur> hpc: "and then combines the boxes into one..."
12:03:05 <fryguybob> boom583: Now at facebook
12:03:12 <boom583> cool
12:03:12 <hpc> yeah
12:03:21 <nlogax> boom583: Here's an example, I had an IRC bot with some commands that could take a long time, and they were blocking other commands. So I made it handle each message in a new thread. Here is the patch https://github.com/nlogax/norby/commit/40a737c88be6b92ac7f46d36158c663b9f874b0b
12:03:28 <hpc> jmcarthur: which conveniently maps exactly to (>>=) = join .: fmap
12:03:32 <Eduard_Munteanu> boom583: the other being Simon Peyton Jones, I mean.
12:03:45 <hpc> er, (=<<)
12:03:48 <jmcarthur> hpc: but yes, slightly less misleading, but it still easily leads to the totally wrong mental model of   newtype IO a = IO a
12:04:27 <Eduard_Munteanu> unique newtype IO a = IO a   :P
12:04:29 <jmcarthur> hpc: further leading to "IO is just a tag saying your function is impure"
12:04:58 <hpc> yeah
12:05:08 <benmachine> so IO (IO a) is a tag saying your function is really really impure?
12:05:34 <hpc> obviously it joins the tags automatically
12:05:39 <hpc> so IO (IO a) is the same as IO a
12:05:45 <Eduard_Munteanu> Once you go IO you can never go back.
12:05:50 <Iceland_jack> benmachine: Obviously double IO means pure
12:05:54 <Hafydd> Hahah.
12:06:02 <scott_> let purify = join
12:06:13 <hpc> join :: m (m a) -> a
12:06:20 <hpc> join = lem
12:06:21 <Iceland_jack> scott_: that would be IMpurify right?
12:06:22 <nlogax> boom583: In node, everything everywhere would have to change to use callbacks (and stuff still blocks if it is CPU bound)
12:06:28 <hpc> what could possibly go wrong?!
12:06:36 <Eduard_Munteanu> Obviously you just need to lift all functions to IO. Then you solve Haskell's *problem*. :P
12:06:44 <Iceland_jack> IO (IO a) = pure, join (undefined ∷ IO (IO a)) ∷ IO a = impure
12:07:12 <monochrom> the best structure for concurrent programs is to have a bunch a threads, each thread an event loop for related events
12:07:15 <boom583> i still haven't grasped the difference between callbacks and threads for web dev :S
12:07:19 <boom583> fully
12:07:24 <hpc> "haskell would be so great if it was strict and allowed IO everywhere"
12:07:28 <hpc> "have you tried ML?"
12:07:32 <hpc> "no, what's it like?"
12:07:34 <Iceland_jack> Do you know what both of those concepts are boom583?
12:07:35 <hpc> "not so great"
12:07:40 <scott_> add x y = do return (x + y)
12:08:01 <jmcarthur> scott_: noooooo
12:08:10 <boom583> Iceland_jack: sure I use callbacks on node.js to respond to requests. threads are threads.
12:08:13 <boom583> :D
12:08:21 <Iceland_jack> …I see
12:08:30 <monoidal> add x y = do { return (x+y) } - see, curly braces!
12:08:33 <boom583> the question is, how are the threads used
12:08:36 <boom583> threads are everywhere
12:08:37 <hpc> #define "do return" id
12:08:41 <jmcarthur> boom583: i would write a loop that waits for the next request and then forks a thread to handle it
12:08:44 <Eduard_Munteanu> add :: (Num a, Monad m) => a -> a -> m a   of course, because you want to "fix" the other monads too!
12:08:46 <FreeFull> add = liftM (+)
12:09:12 <boom583> jmcarthur: so you'd write it manually in pure haskell, without using the frameworks?
12:09:14 <Iceland_jack> boom583: If I have a server I might create one thread per client
12:09:35 <jmcarthur> boom583: i didn't mean that. i just mean that what i would be using is a loop that uses blocking calls, not a scheduler that calls me
12:09:50 <monochrom> the extremist view of "events only, no thread" implies the ridiculous structure of one single event loop for several unrelated classes of events. this is clearly, like, did they ever read that section on cohesion in any typical software engineering textbook?
12:09:53 <dwcook> Eduard_Munteanu, so, to take that to an extreme, every type would be IO (IO (IO (IO (IO …))))?
12:09:54 <scott_> FreeFull: liftM2
12:10:02 <boom583> ok
12:10:08 <Eduard_Munteanu> boom583: callbacks handle things synchronously unless you have some sort of top/bottom-handlers separation.
12:10:12 <jmcarthur> monochrom: that's not even considered extremist. that is par for the course.
12:10:18 <jmcarthur> monochrom: ever seen the windows event loop?
12:10:41 <monochrom> it is extremist in my view. if it means that the majority is extremist, so be it.
12:10:47 <jmcarthur> fair enough
12:10:50 <hpc> the extremist view is implementing threads in terms of an event loop
12:10:58 <Eduard_Munteanu> boom583: in that sense, callbacks should finish quickly to avoid blocking other events from being handled
12:10:59 <hpc> (i think windows 98 did that?)
12:11:04 <boom583> Eduard_Munteanu: that's why you have to be careful in Node.js not to block the event loop. So with Haskell (one thread per request), that worry goes away you mean?
12:11:16 <jmcarthur> hpc: (i've done that with ocaml's async library)
12:11:32 <FreeFull> scott_: Ah, yeah
12:11:32 <hpc> that sounds like fun
12:11:33 <Eduard_Munteanu> boom583: that is one way to avoid that issue, yeah.
12:11:47 <boom583> interesting
12:11:48 <monochrom> I wrote my share of windows 3.0 event loop back in 1992, when it was windows 3.0.
12:11:55 <hpc> someone here implemented a "concurrency" library in terms of unsafeInterleaveIO
12:11:55 <jmcarthur> hpc: it's pretty simple to do, really, and i think is sane if you otherwise just don't have decent threads
12:11:59 <hpc> which i thought was hilarious
12:12:01 <dwcook> boom583, nothing in Haskell itself says you have to have a thread per request, but Haskell does give you the tools to do it right
12:12:08 <Eduard_Munteanu> boom583: especially if said event does not need to be handled before continuing
12:12:22 <boom583> man... a month ago i thought I had finally found the SHIT for web dev (node.js). looks like i was wrong :S
12:12:28 <kinslayer> I think I got a bit further, but now GHC is complaining about <*> not being in scope
12:12:36 <jophish_> Would it be possible to build a single package with ghc 7.7 in a system otherwise built with 7.6?
12:12:45 <triliyn> kinslayer: import Control.Applicative
12:12:47 <xplat> only problem was the word 'the' (? :) )
12:12:47 <monochrom> kinslayer: <*> is from Control.Applicative
12:12:52 <hpc> boom583: eventually you'll find haskell to be insufficient, and you'll move on to agda or something nuts like that ;)
12:12:56 <kinslayer> Thanks
12:13:02 <boom583> lol
12:13:12 <triliyn> hpc: I just jumped to idris and I am slowly ceasing to be confused! :D
12:13:19 <dwcook> What's next in the chain? JavaScript → Haskell → Agda → ?
12:13:31 <Iceland_jack> boom583: Of course this is #haskell, keep that in mind
12:13:35 <hpc> dwcook: giving up on types entirely and using perl
12:13:43 <Iceland_jack> You'll get a completely different answer on a channel dedicated to node.js
12:13:43 <xplat> dwcook: writing your own language.  or someone else might do it before you get to that point
12:13:53 <boom583> :)
12:13:56 <Eduard_Munteanu> boom583: the Linux kernel for example handles interrupts from devices in a callback-like fashion, but those run very quickly and postpone doing expensive work to the so-called bottom handlers, basically a job queue that runs asynchronously after the IRQ handler finished.
12:13:58 <hpc> and then from there, jquery/tux because "perl is slow"
12:14:00 <xplat> dwcook: beluga looks like it might turn into a possibility
12:14:06 <dwcook> hpc, seems kind of like a backward step to me :P
12:14:13 <hpc> dwcook: exactly
12:14:22 <dwcook> xplat, good point. Though, so far most of the languages I write I acknowledge are terrible :P
12:14:55 <boom583> ok
12:14:55 <hpc> (i understand nginx is getting pretty close to tux speeds through some really wonky tricks)
12:15:16 <Eduard_Munteanu> boom583: but in that case, the tradeoffs are well known and micromanaging it is part of the point. Which is less of a good idea for general app development.
12:16:15 <boom583> With Node.js it is a bad idea to use Apache supposedly. Nginx should be used. What about Haskell?
12:16:33 <boom583> Since Apache uses threads... hmmm.
12:16:34 <hpc> node.js is its own server, i thought
12:16:45 <boom583> hpc: yes but nobody uses it as its own server afaik
12:16:46 <nlogax> boom583: If you use e.g Warp, you have a server baked into your program
12:16:51 <jmcarthur> boom583: for the most part, we use compile native web servers written in haskell directly into the web app
12:17:02 <Eduard_Munteanu> I don't think that's a reasonable generalization.
12:17:15 <Hodapp> Eduard_Munteanu: What is(n't)?
12:17:15 <xplat> you can use haskell as fastcgi too though
12:17:28 <Eduard_Munteanu> The "uses threads too" analogy.
12:17:39 <xplat> and i don't think there are any servers it works especially badly with
12:17:40 <jmcarthur> boom583: and if you want you can use some off the shelf servers to distribute among multiple such haskell servers
12:17:49 <hpc> "X uses threads, therefore bad" => "never use software again"
12:18:02 <Iceland_jack> lol
12:18:03 <jmcarthur> right, you can do it the other way too. i just mean this is kind of an unofficial convention we've established already
12:18:15 <kinslayer> I really don't understand haskell's type stuff, any good reads or videos explaining it ?
12:18:25 <hpc> kinslayer: read lyah
12:18:37 <Hodapp> Haskell's "type stuff" is... most of Haskell.
12:18:40 <xplat> @where lyah
12:18:41 <lambdabot> http://www.learnyouahaskell.com/
12:18:41 <kinslayer> I got Real World Haskell
12:18:41 <monochrom> "never use software again" is always a good conclusion.
12:18:49 <Eduard_Munteanu> kinslayer: perhaps there are specific things you can ask about?
12:18:52 <hpc> it's like reading a children's book, but at the end of it you miraculously understand more than when you started
12:18:55 <kinslayer> hodapp: I know
12:19:22 <monochrom> therefore, according to both classical and intuitionistic logics, X => "never use software again" is also always a good conclusion.
12:19:23 <xplat> lyah is kind of a gentler introduction than rwh
12:19:24 <Eduard_Munteanu> Yes, never and always sounds like something coming from a #haskell dweller named monochrom. :P
12:19:26 <boom583> jmcarthur: isn't it always a good idea to have a respectable secure web server (nginx, whatever) in front of a haskell web server in any case? indeed, i currently use nginx to distribute among my multiple sites - each a node.js app running its own local http server
12:19:28 <hpc> RWH is also good to have, but it doesn't teach the underlying concepts as well
12:19:34 <kinslayer> I do like lyah (also played with erlang a bit, and that version is also great)
12:19:34 <hpc> it's better as an "intro to libraries"
12:19:50 <hpc> where lyah is a proper intro to the language itself
12:19:59 <jmcarthur> boom583: i don't think anybody would argue against using mature software when it makes sense to do so
12:20:06 <dwcook> The impression I get is that the fear of threads comes from how awful they are to work with in C and Java.
12:20:18 <jmcarthur> boom583: haskell code has a tendency to be pretty safe and performant already though, to be honest
12:20:20 <hpc> dwcook: your impression is correct
12:20:21 <monochrom> yes dwcook
12:20:26 <hpc> dwcook: also C++ and python
12:20:26 <boom583> ok
12:20:29 <simpson> There's a difference between OS threads and runtime userland threads.
12:20:32 <Cale> dwcook: Concurrency *is* hard though.
12:20:32 <hpc> /especially/ python
12:20:33 <kinslayer> Maybe what I don't get is stuff more of the stuff about typeclasses
12:20:34 <Eduard_Munteanu> C is probably awful in itself for a lot of things these days.
12:20:36 <hpc> GIL FTL
12:20:38 <simpson> People dislike the former, not the latter.
12:20:52 <Cale> It's not *just* about how awful it is to work with in most languages
12:21:06 <hpc> Cale: concurrency with bad primitives is hard; concurrency with good primitives is muuuch easier
12:21:08 <xplat> hpc: i'm pretty sure the GIL is *much* slower than light :)
12:21:10 <boom583> Why do people say the Apache threading is bad? I guess it's not because of threads per se but how they make use of the threads... it sounds like Apache spawns new threads inefficiently, or something
12:21:18 <hpc> i consider concurrency on the level of "programming is hard", really
12:21:20 <Cale> hpc: Much easier, but still hard!
12:21:23 <Eduard_Munteanu> C and C++ are rather overused these days, I think.
12:21:47 <monochrom> "programming is hard" => "never use software" is a good inference :)
12:21:51 <hpc> boom583: apache is a huge piece of software and you really need to specify which part is meant when you say "how they make use of threads"
12:21:54 <Iceland_jack> boom583: Do people say that or do node.js say that?
12:21:56 <Iceland_jack> *does
12:22:02 <Eduard_Munteanu> I blame it on the "projects have to use a single language" assumption, I think.
12:22:02 <kinslayer> I really wouldn't want to write anything concurrent in C or C++ I mean isn't that for masochists ?
12:22:04 <Cale> There are significant classes of difficulties you open yourself up to with concurrency which are simply fundamental to the definition of concurrency.
12:22:06 <hpc> or rather, jode.js people need to specify
12:22:08 <aristid> Eduard_Munteanu: dunno, as a percentage both are now dwarfed by java and c# by far i think
12:22:08 <magicman> The concept of thread-local storage is still kinda baffling in my mind. (mind you, I learned things the other way around, starting with concurrency in Haskell, then looking at what other languages do)
12:22:12 <Iceland_jack> I saw some node.js slide which had graph basically saying that thread ⇒ slow
12:22:21 <jmcarthur> kinslayer: i've done it, and it sucks
12:22:29 <xplat> hpc: concurrency is harder than nonconcurrent programming in the same way that designing a plant to produce TV dinners is harder than cooking dinner
12:22:33 <hpc> magicman: thread-local storage makes more sense from the C/OS perspective
12:22:37 <Eduard_Munteanu> aristid: possibly, I'm referring to FOSS stuff
12:22:41 <kinslayer> jmcarthur: I haven't done it I am very grateful for that :D
12:22:42 <hpc> where the heap is shared and the stack is local to each thread
12:22:45 <aristid> Eduard_Munteanu: oh there, definitely
12:22:53 <xplat> or,, er, writing a recipe for dinner
12:22:54 <hpc> so someone goes "ooh, let's store some shit at a fixed point on the stack"
12:23:03 <hpc> and a whole species of bug is born
12:23:04 <aristid> Eduard_Munteanu: i feel like in the open source world, the language choice of successful projects is often very conservative
12:23:14 <Hafydd> Concurrent dining.
12:23:17 <magicman> Ahh, I see.
12:23:21 <aristid> Eduard_Munteanu: perhaps because that's the lowest common denominator in the pool of contributors
12:24:18 <kinslayer> Concurrent dinner -> that sounds like a messy plate :D
12:24:19 <Eduard_Munteanu> aristid: yeah, but I think that's also an issue of trying to pick *one* language. It's easy to get carried away by reasons "oh, I might need to micromanage this little bit, therefore I'll write all of it in C".
12:24:49 <boom583> jmcarthur: what about static files? with node.js, nginx serves the static files and node does the rest, because static files in node are SLOW
12:24:53 <boom583> not true for haskell?
12:25:00 <Eduard_Munteanu> kinslayer: I think the forks are disputed too, not just the plates :P
12:25:03 <xplat> honestly if i were a manager i would fire people for writing some of the things people write in C in C
12:25:07 <Hodapp> Eduard_Munteanu: And that is, in my opinion, one of the most idiotic forms of premature optimization that is still in rampant use.
12:25:09 <hpc> kinslayer: my solution to the dining philosophers problem is "i don't want to use someone else's utensils"
12:25:24 <hpc> xplat: you would fire people in C?
12:25:26 * monochrom goes "oh, I might need high-level programming for this little bit, therefore all of it will be in Haskell"
12:25:31 <kinslayer> well I come to think of french service
12:25:32 <jmcarthur> boom583: this isn't even a language or framework specific issue. it's just a matter of using reasonable system calls.
12:25:38 <simpson> boom583: This is only a problem in Node.js.
12:25:47 <jmcarthur> boom583: so if node sucks at it, it's really the node developers' faults
12:25:54 <boom583> ok
12:26:04 <Hodapp> Eduard_Munteanu: I have a silly pejorative view that the number of parts of an application that need to be fast are almost never so large that they justify writing the entire thing in a lower-level language.
12:26:05 <Cale> Writing parallel programs *without* concurrency can be "easy", so long as you're sufficiently lax about what success means (Is it okay to have n/2 speedup on n cores? Is it okay to have the 1 core case be significantly slower?)
12:26:08 <hpc> monochrom: the way i picked haskell to write a game in was "what's the worst technology i could pick for this task"
12:26:24 <hpc> monochrom: i also ended up using happstack and imagemagick ;)
12:26:31 <jmcarthur> haha
12:26:43 <xplat> hpc: no way would i fire people in C, i'd write past one of the ends of the blanks on the pink slip and my refrigerator would catch fire
12:26:45 <monochrom> wait, happstack and imagemagick for a game?!
12:27:03 <Hodapp> xplat: *groan*
12:27:16 <hpc> monochrom: the best part is using imagemagick for terrain generation
12:27:27 <monochrom> you are a genius!
12:27:31 <Cale> If you've resigned yourself to writing actually-concurrent programs, then you're opening yourself up to fairly large classes of bugs, even if you use the best tools we have for controlling the combinatorial explosion of possible behaviours which come from interleaved changes to state.
12:27:39 <Eduard_Munteanu> Look at gcc, they had a hard time transitioning to a *subset* of C++, for some reason.
12:27:49 <hpc> i make mountain ranges by drawing some black beziers on a white canvas, then applying UV noise
12:27:56 <Eduard_Munteanu> The bad sort of subset. :)
12:27:57 <kinslayer> I probably should read some haskell code, like XMonad or Pandoc and try to understand them (probably very bit by bit)
12:28:21 <hpc> kinslayer: not xmonad, maybe pandoc
12:28:23 <Cale> It's still easy to write bugs with STM. It's much easier to get things right than without STM, but many things can still go wrong.
12:28:34 <Hodapp> Eduard_Munteanu: they had a hard time there?
12:28:40 <scott_> hpc: Why not XMonad?
12:28:43 <kinslayer> okay xmonad is to complex ?
12:28:51 <hpc> xmonad has to deal with x11
12:28:53 <scott_> (I haven't gone through xmonad, but I'm interested in it, too.)
12:29:11 <hpc> definitely read it, but don't consider it reading haskell code
12:29:16 <kinslayer> yeah x11 would be a bit messy, I would probably try to read some of it, but that is some ffi right ?
12:29:19 <Cale> scott_: XMonad has a beautiful core
12:29:30 <scott_> Cale: That's what I've heard
12:29:30 <hpc> yeah, the core is still interesting
12:29:32 <nicoo> Cale: It is easy to write bugs in pure code :]
12:29:33 <Cale> Or, I should have addressedf that to kinslayer
12:29:57 <kinslayer> well I would like to look into that...
12:29:59 <hpc> pandoc is much more fun because is has an interesting core, with lots of parsing code around it
12:30:09 <Eduard_Munteanu> Hodapp: they're trying very hard to stick as close as possible to plain C.
12:30:09 <hpc> a good way to get into writing some very practical code
12:30:17 <kinslayer> are there other good programs to read ?
12:30:23 <hpc> hoogle, maybe
12:30:30 <Eduard_Munteanu> Hodapp: which is rather odd considering gcc is a rather slow compiler.
12:30:34 <hpc> djinn if you want to learn some theory
12:30:40 <hpc> lambdabot if you hate yourself ;)
12:30:45 <kinslayer> hpc: I would obviously like to know where to look :D
12:30:52 <boom583> unfortunately nothing as beautiful as Jade seems to exist (HTML templating)
12:30:54 <nlogax> boom583: Here's a simple web thingie https://github.com/scotty-web/scotty#readme , though stuff like Yesod try harder to make things type-safe that usualy aren't, so that things like XSS become a compile-time error
12:31:06 <Cale> nicoo: Well, in some sense, but in this case, I'm considering pure code "easy", and effectful single-threaded code "normal", and saying that by comparison, concurrent stuff is "hard".
12:31:10 <Eduard_Munteanu> And considering their issue was an expressivity / abstraction / high-levelness issue.
12:31:31 <hpc> also reading some of the big libraries, like parsec and friends, or a web framework
12:31:37 <hpc> or blaze-html, or something
12:31:53 <boom583> well scrape that. I can still use Jade, independently of course
12:31:55 <hpc> if you are a bad enough dude, you can also read into how GHC does things
12:32:13 <Cale> Don't get me wrong, there are fairly significant classes of program where obtaining the concurrency involved doesn't involve much in the way of additional painkillers.
12:32:15 <hpc> which is low-level and FFI-y in a way that's much more fun than xmonad
12:32:39 <Eduard_Munteanu> Production FOSS code is often nice to look at and try to get pointers from, e.g. wrt coding style.
12:32:47 <kinslayer> hpc: yeah lets just read ghc and understand nothing (I think that will be for a long time)
12:33:08 <hpc> kinslayer: yeah, it's not something for everyone to read ;)
12:33:33 <hpc> but it's still neat to see how far down a lot of base logic goes before you get to primitives
12:33:39 <kinslayer> hpc: No that would probably be a bit crazy to expect that ?
12:33:55 <boom583> nlogax: thanks
12:33:58 <Cale> But the primitives there fundamentally allow you to get into headache-inducing situations. Concurrency is all about the nondeterminism of state which comes from all the possible interleavings of threaded operations. (Without that, I wouldn't say that your program is truly concurrent, even if it does take advantage of parallelism.)
12:34:04 <monochrom> GHC is large. so, it depends on which small part you happen to read.
12:34:12 <hpc> that too
12:34:40 <Eduard_Munteanu> And yes, I think gcc is still sort of stuck in the one true language dilemma.
12:35:37 <hpc> i feel like C would be much more pleasant to use if every compiler stuck to the standard with {-# LANGUAGE #-} type options declared in specific files
12:35:58 <hpc> good luck making that happen though ;)
12:36:16 <scott_> I like the way Haskell does language extensions
12:36:22 <xplat> hah, yes, tough enough getting one compiler to do it right
12:36:35 <simpson> edwardk: I find myself pulling out hair over tricky parses. Are there tokenizers that I could be using to make life easier and still use parsers?
12:36:50 <scott_> Haskell does have the advantage of only having one major compiler
12:36:54 <Eduard_Munteanu> hpc: there isn't much non-standardiness wrt C, it's just the C standard itself is rather hairy :)
12:36:56 <jophish_> I've just built ghc, where is the executable?
12:37:00 <edwardk> you can write the tokenizer in parsers of course
12:37:14 <Eduard_Munteanu> hpc: it's not at all like GHC, to compare :)
12:37:27 <Iceland_jack> hpc: If only it were viable to properly retrofit features to C (modules come to mind)
12:37:48 <rtpg> speaking of language extensions, doesn't undecidableInstances include flexibleInstances a prior?
12:37:52 <Iceland_jack> Haskell deals with extensions in a very nice way
12:37:52 <rtpg> priori
12:38:00 <simpson> edwardk: But I'll have to walk away from trifecta's glorious glorious error reporting?
12:38:21 <edwardk> trifecta is a parsers instanc
12:38:21 <xplat> Eduard_Munteanu: there are lots of non-standard C features of varying usefulness.  there's the old 8086 near/far pointers, there's the big lump of stuff called 'GNU extensions', etc
12:38:32 <edwardk> danharaj: around?
12:38:41 <danharaj> I exist.
12:38:59 <edwardk> danharaj: you mentioned you found yourself in the area?
12:39:08 <danharaj> yup
12:39:10 <dwcook> xplat, I got excited when I learned about the GNU extension for declaring functions within functions, but less so once I figured out it doesn't include closures.
12:39:13 <danharaj> I'm currently @ 253 commonwealth ave.
12:39:15 <Eduard_Munteanu> simpson: you generally have two options: separate passes (chars to tokens, then tokens to parsers), or wrapping token parsers into a higher-level applicative parser more transparently.
12:39:56 <Eduard_Munteanu> xplat: I guess so... now that I look back, they seem rather minor compared to GHC extensions. :)
12:40:24 <Eduard_Munteanu> I guess C *is* about minor details. :)
12:40:47 * Eduard_Munteanu hands dwcook an __attribute__((pure)) :P
12:40:53 <Lindrian> How should I think in order to figure out the type of (($) $ ($)) ?
12:41:00 <dwcook> Eduard_Munteanu, I don't even know what that is :P
12:41:27 <xplat> Lindrian: think like '$ is another name for id'
12:41:27 <Eduard_Munteanu> Lindrian: start with the outermost application, namely the middle $
12:41:35 <dwcook> Ah, but I got lucky searching for it
12:42:26 <Lindrian> alright Eduard_Munteanu, i got that far. but thats where it stopped
12:42:30 <Eduard_Munteanu> dwcook: it declares a function pure (has no side effects), but it's not really checked, it only allows the compiler to optimize better.
12:42:39 <Eduard_Munteanu> :t ($)
12:42:40 <lambdabot> (a -> b) -> a -> b
12:42:42 <Iceland_jack> Lindrian: Apply the definition of ($)
12:42:44 <Iceland_jack> @src ($)
12:42:44 <lambdabot> f $ x = f x
12:42:56 <Eduard_Munteanu> (a -> b) -> a -> b
12:44:27 <Eduard_Munteanu> Lindrian: now, you apply ($) to one argument and another ($) to the other. So you replace (a -> b) by ($)'s type, and 'a' by ($)'s type again, making sure to name variables appropriately.
12:44:29 <Lindrian> okay so (($) $ ($)) = ($) ($) ?
12:44:36 <Iceland_jack> yes
12:44:58 <Iceland_jack> You can ‘kinda’ verify it by doing:
12:44:58 <Iceland_jack> @ty (($) $ ($))
12:44:59 <lambdabot> (a -> b) -> a -> b
12:45:03 <Iceland_jack> @ty (($) ($))
12:45:03 <Iceland_jack>  
12:45:04 <lambdabot> (a -> b) -> a -> b
12:45:18 <Iceland_jack> They have the same type so it's possibly correct
12:45:46 <Iceland_jack> Lindrian: Now try expanding the first ($) into its definition
12:45:52 <jophish_> Yo yo yo
12:46:02 <jophish_> I'd like to compile one package with a different version of ghc
12:46:06 <jophish_> hoiw can I go about doing this?
12:46:15 <jophish_> --with-ghc=/path/to/ghc7.7
12:46:23 <mekeor> Iceland_jack: actually you already said the solution by typing "@ty (($) $ ($))" ... -.-"
12:46:25 <Eduard_Munteanu> Lindrian: only the variables in the outer type get fixed, so ($) :: (c -> d) -> c -> d = (a -> b)   and  ($) :: (c' -> d') -> c' -> d' = a  to a first approximation.
12:46:28 <jophish_> this doesn't seem to do it, packages can't be found, etc...
12:46:38 <Iceland_jack> mekeor: Not really
12:47:30 <mekeor> Iceland_jack: well, he wanted to find out the type of that expression... ;P
12:47:44 <Eduard_Munteanu> Lindrian: from that, you can deduce (c -> d) -> c -> d = (a -> b) = ((c' -> d') -> c' -> d') -> b
12:47:50 <Iceland_jack> Oh I thought they were asking how to reduce it
12:47:56 <mekeor> :)
12:48:11 <Iceland_jack> in any case they are attempting to reduce it now hopefully and the answer > the journey
12:48:51 <Lindrian> woah
12:48:51 <mekeor> uhm, er. did you mean "the answer < the journey" maybe? O.o
12:49:07 <Iceland_jack> mekeor: No, I'm not a fan of Journey
12:49:12 <hpc> > "the answer" < "the journey"
12:49:13 <lambdabot>  True
12:51:36 * hackagebot simple-sql-parser 0.1.0.0 - A parser for SQL queries  http://hackage.haskell.org/package/simple-sql-parser-0.1.0.0 (JakeWheat)
12:51:36 * hackagebot hledger-irr 0.1.1.3 - computes the internal rate of return of an investment  http://hackage.haskell.org/package/hledger-irr-0.1.1.3 (JoachimBreitner)
12:52:17 <Eduard_Munteanu> Lindrian: also, the latter has only one identifiable argument, so (c -> d) = (c' -> d') -> c' -> d', b = c -> d
12:53:46 <Lindrian> alright
12:54:08 <Lindrian> how about (.)(.)? I tried applying three arguments and simplified. Ended up with (a b) . c
12:54:10 <Lindrian> is this correct?
12:54:17 <Eduard_Munteanu> So a -> b = ((c' -> d') -> c' -> d') -> (c' -> d') -> c' -> d'
12:54:22 <Lindrian> the entire thing: (.)(.) = (.)(.) a b c = (((.)(.) a) b) c = (((.) . a) b) c = ((.) (a b)) c = (a b) . c
12:54:31 <bennofs> @unpl (.)(.)
12:54:31 <lambdabot> (\ b c e f -> b c (e f))
12:54:43 <bennofs> so a b . c seems correct
12:54:55 <Lindrian> waah
12:55:04 <Eduard_Munteanu> :t (.)(.)
12:55:04 <Iceland_jack> @unpl a b . c
12:55:04 <lambdabot> (\ f -> a b (c f))
12:55:05 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
12:55:16 <Lindrian> what is @unpl?
12:55:34 <Iceland_jack> makes your code pointy
12:55:40 <Eduard_Munteanu> Lindrian: the thing is, it's often enough to look at the type :)
12:55:51 <Eduard_Munteanu> @unpl f
12:55:51 <lambdabot> f
12:55:53 <Lindrian> but that confuses me so much.
12:55:56 <Eduard_Munteanu> Er.
12:55:59 <Eduard_Munteanu> @unpl g . f
12:55:59 <lambdabot> (\ c -> g (f c))
12:56:28 <Iceland_jack> @pl ($) $ ($)
12:56:28 <lambdabot> id
12:57:50 <Eduard_Munteanu> :t ((.)(.)) ?a ?b ?c
12:57:51 <lambdabot> (?a::a -> b -> c, ?b::a, ?c::a1 -> b) => a1 -> c
12:57:52 <Yarou> idiot bird :D
12:58:27 <Iceland_jack> > let idiotBird = id in idiotBird "what?"
12:58:28 <lambdabot>  "what?"
13:01:20 <haasn> lyrebird
13:02:25 <kinslayer> Okay I have written something http://bitbin.it/WHVBJ3Ft however it isn't working, would any of you take a look at it ?
13:02:51 <jmcarthur> "isn't working"?
13:02:51 <haasn> kinslayer: what isn't working?
13:03:04 <Iceland_jack> kinslayer: return $ A.decode json::(Maybe BitcoinData) ← this immediately looks wrong
13:03:07 <Iceland_jack> You're in the IO monad
13:03:15 <kinslayer> It is some type mismatch
13:03:26 <bennofs> kinslayer: can you paste the error message too?
13:03:28 <haasn> oh, yes; Maybe BitcoinData is not BitcoinData
13:03:45 <Iceland_jack> and yes you should include the error messages
13:03:45 <jmcarthur> the type checker give you an error message for purposes of diagnosing the problem. without the error message it's really hard to tell
13:03:55 <bennofs> you also need to write return $ (A.decode json :: Maybe BitcoinData), because of precendence
13:04:40 <haasn> (if you fix the type error the signature will most likely be superfluous as well, due to inference)
13:06:12 <kinslayer> http://bitbin.it/Nhc2sa3G That is my error msg inside Emacs
13:06:32 <Iceland_jack> kinslayer: Did you address the problems that were pointed out?
13:07:01 <Iceland_jack> Expected type: Maybe BitcoinData
13:07:01 <Iceland_jack>   Actual type: Maybe (Maybe a0)
13:07:09 <Iceland_jack> Now read what was said above :)
13:07:10 <kinslayer> That is a bit tricky since I am not entirely sure I understand the problems that are pointed out...
13:07:46 <Iceland_jack> How about you try with a smaller example?
13:07:50 <kinslayer> Somehow I am really confused right now
13:08:02 <kinslayer> That seems to be a good idea...
13:08:46 <kinslayer> However I really wanted to write something like this... Last night I spent a lot of time trying to write something, then I gave up and rewrote it in another way and it just worked, I thought that was weird
13:09:41 <kinslayer> I tried to write a very big main function which just refused to work, then I split out a lot of IO into a seperate "function" (actually it was just a big do block) and then it pretty much just worked
13:10:15 <simon> kinslayer, sounds like A.decode returns a Maybe of something in itself...
13:11:09 <kinslayer> Okay I see that the thing is m0 (Maybe a0)
13:11:24 <kinslayer> a0 would be my data ? and m0 would be some Monad ?
13:11:30 <simon> yes
13:11:43 <simon> try and see what type A.decode has
13:11:50 <kinslayer> Ghc is really good at error MSG :D
13:13:03 <ion> MSG is a good condiment.
13:14:47 <kinslayer> Okay so Data.Aeson.decode returns a "Maybe a"
13:18:08 <KiriKari> is darcs distributed or centralized?
13:18:20 <xplat> distributed
13:18:51 <kinslayer> Hmm there seems to be a lot of errors in my code...
13:18:52 <xplat> i'd go so far as to say 'extremely distributed', since you only have one branch per repo
13:20:45 <KiriKari> what is the advantage of centralized? i just hate the fact that you cant make a bigger commit in smaller steps without commiting so someone else can take it out.
13:21:48 <xplat> KiriKari: the main advantage of centralized is that there's a central point where you can rewrite history, and from where you can see all history
13:23:01 <xplat> of course, as soon as someone writes something like svk or git-svn, suddenly you have a distributed VCS again, only more fragile and less semantically well-defined
13:26:40 <abitlost> Is there a document or tutorial I should read on current recommendations for using hackage, setting up an environment, etc?
13:26:46 <Philonous> Blimey, why is it that whenever I look for a feature in GHC it will be in the next release
13:27:03 <quchen> Philonous: Overloaded records.
13:27:06 <quchen> You're welcome
13:27:34 <Philonous> quchen, Ah, I don't care about those too much. ATM I want to reify modules in TH
13:33:06 <kinslayer> Hey now I got the JSON into a plain haskell string... Couldn't make it with the json converter, but I will have another go at some point
13:37:31 <simon> ion, http://health.howstuffworks.com/wellness/food-nutrition/facts/the-dangers-of-monosodium-glutamate.htm
13:40:03 <Philonous> simon, So many words to say "we have no idea"
13:40:41 <ion> I like how the category and the title say something completely different than the article.
13:42:18 <Philonous> ion, Well, "The harmlessness of MSG" or "What is not understood about MSG" or even "Wild speculations and sensationalist headlines about MSG" wouldn't make for good titles
13:44:48 <shiona> Well, that's one of the best articles on the stuff online I've seen. It actually cites actual papers (I'm not going to take a look how trustworthy they are) for both sides of the argument (!)
13:45:13 <ion> The article comments seem to have some points about the trustworthiness of the papers.
13:46:15 <lispy> MSG is very off topic for #haskell. But it would be a fine topic in #haskell-blah
13:46:47 <shiona> :D
14:00:48 <nlogax> With FRP.Sodium and Graphics.UI.GLUT you could put together a MonadSodium GLUTamate
14:01:02 <nlogax> Sorry
14:01:11 <jmcarthur> wow
14:01:16 <jmcarthur> so much groan
14:01:54 <ahill-89> If only any of my friends who enjoy puns understood Haskell.
14:02:12 <monochrom> as far as url-does-not-match-content is concerned, I am still most fond of for example http://www.amazon.com/Advance-PHP/dp/1593272839/ :)
14:02:33 <monochrom> and nlogax: hahaha, you win :)
14:02:47 * monochrom loves puns
14:02:58 <intrados> Is there a way to do a two-layer bind? Like `m (n a) -> (a -> m (n b)) -> m (n b)`?
14:03:01 <siwica> What would be a good project for a beginner to learn haskell? (experiences in various non functional languages exist)
14:03:03 <ion> nlogax++
14:03:04 <monochrom> did you know: monochrom is the author of:
14:03:10 <monochrom> @quote monochrom faster.than
14:03:10 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
14:03:37 <monochrom> @remember nlogax With FRP.Sodium and Graphics.UI.GLUT you could put together a MonadSodium GLUTamate
14:03:37 <lambdabot> Done.
14:03:38 <shachaf> intrados: If m and n are monads, (m . n) is not necessarily a monad.
14:03:40 <monochrom> hehe
14:03:42 <Philonous> intrados, not in general, no
14:03:57 <abitlost> siwica: that depends on what you mean by 'learn', your previous experience, and your interests, I think; what do you currently know/what have you currently done?
14:04:01 <xplat> but in plenty of cases it is
14:04:19 <shachaf> Sure. But you can't write a general >>= function like that.
14:04:31 <shachaf> (And note that (m . n) *is* Applicative if they're both Applicative.)
14:05:21 <ion> fmap (f x) :: m (n (m (n b)), that perhaps adds some insight. You’d need a join for that.
14:05:22 <xplat> shachaf: quit making trouble, the pun is groanworthy enough without changing it to ApplicativeSodium GLUTamate
14:05:24 <abitlost> siwica: if you just want a staring point, perhaps work through "Learn you a Haskell for Great Good" - it's free online
14:05:37 <ion> fmap f x even.
14:05:45 <siwica> abitlost: My knowledge of haskell consists basically of about 8-10 lectures in my programming paradigm course in college. But I did never write a full program but rather some single functions
14:05:52 <monochrom> haha applicative sodium, that is new chemistry!
14:06:15 * monochrom is of the opinion that no project is a good project for a beginner
14:06:24 <abitlost> siwica: I'd say take a look at that book, then start to do a project similar to what you'd do in any other language to pick it up
14:06:42 <quchen> monochrom: Sounds like Zeno's paradox.
14:06:58 <xplat> yeah, i guess if there were a good project for you you wouldn't be a beginner
14:07:27 <xplat> but still, surely there are better and worse projects
14:07:27 <siwica> abitlost: I would be curious what people use haskell mostly. Depending on the availability of good libraries I could do different things.
14:07:40 <abitlost> xplat: not necessarily, but haskell does have a rough initial learning curve
14:07:49 <siwica> abitlost: use haskell *for mostly
14:07:50 <monochrom> in fact, look at programming courses at schools. they may assign a very small project near the end, but definitely not near the beginning or even the middle.
14:08:29 <siwica> xplat:
14:08:40 <monochrom> there are really quite some toy programs too toy to be called "project" you have to go through before you are ready for the smallest project
14:09:29 <abitlost> siwica: http://www.haskell.org/haskellwiki/Libraries_and_tools#Haskell_applications_and_libraries ; it's a general-purpose language. That said, things which fundamentally use mutable state heavily are a bit annoying, and I've heard bad things about XML library support (but my info is dated)
14:09:33 <Philonous> Conway's Comonadic Life
14:09:48 <monochrom> so, how about this: write a number guessing game for text console. simply getLine and putStrLn your way through. it's like 10 lines. write it first.
14:09:55 <xplat> main = do { putStrLn "hello world."; putStr "2 + 2 = "; printLn (2 + 2) }
14:10:02 <abitlost> monochrom: my university had people do graphical fractal apps in scheme in the first semester; that's not a huge project, but I'd call it a project
14:10:19 <intrados> abitlost: I used xml-conduit recently and it wasn't horrible for my fairly basic needs
14:10:24 <monochrom> yes, and at which point in the course did they do it?
14:10:28 <scott_> I saw this recently, it seems like it might be a nice way to get started with most languages: http://adriann.github.io/programming_problems.html
14:10:40 <abitlost> monochrom: in any language but haskell, maybe. I found getting my head around random numbers in Haskell to be fairly painful as a novice
14:10:49 <abitlost> intrados: good to hear
14:11:00 <monochrom> the random number part is just one randomRIO
14:11:00 <abitlost> monochrom: a few weeks in, iirc
14:11:19 <monochrom> and how many lines?
14:11:20 <xplat> intrados: i hate every xml library for haskell, but i can't think of an XML library i don't hate at least a little
14:11:28 <xplat> intrados: for any language
14:11:50 <siwica> abitlost: I did write a Fractal app in Java that might be fun again. I just dont have any clue on how easy it is to build a gui with haskell
14:12:02 <abitlost> monochrom: it's not *fundamentally* hard, but I found it super-confusing to have a bunch of APIs for it, some of which passed state around and some of which were destructive, etc
14:12:07 <monochrom> if it's 10 lines it's a toy to me. if it's 100 lines I'll agree it's a course project for a 1st-year course
14:12:28 <xplat> abitlost: random numbers in haskell aren't hard if you just do them in IO and think of them as reading a number from /dev/urandom
14:12:57 <abitlost> xplat: sure. But without a tutorial or other source of that guidance, they're not something I'd recommend to someone as their first toy after they can reverse a list
14:13:16 <monochrom> I am deliberately not caring what greatness the program accomplishes, oh graphics and fractals that sounds fancy. well it is trivial once you realize that, for example, Racket gives you a simple library and trivalizes that to 2 lines.
14:13:42 <abitlost> I don't find them hard *now*; I did find them hard when I didn't grok how to do much of anything in main in Haskell
14:13:59 <monochrom> so, my question has not been answered. I take it that the answer proves my point.
14:14:02 <abitlost> monochrom: it was a few hundred lines, and well before Racket was racket
14:14:17 <monochrom> ok, a few hundred lines is a project.
14:14:30 <Ralith> xplat: they aren't hard if you just do them in State and think of them as PRNG output, either...
14:14:34 <xplat> i remember doing mandelbrot and julia sets in turbo pascal
14:14:36 <monochrom> what school is that? perhaps it's an elite school and can afford to do it
14:15:13 <abitlost> monochrom: it was a regional school in a place with a minority language in a small country, where we didn't use sicp because it was thought we "wouldn't be able to handle it"
14:15:36 <xplat> Ralith: sure, but then you have to understand there are more things that 'do' can do than just IO, and people often cringe at the word used to describe that
14:15:48 <Ralith> :p
14:15:50 <monochrom> how well did the students do?
14:16:05 <abitlost> siwica: http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries
14:16:24 <siwica> abitlost: great, thanks!
14:16:42 <abitlost> monochrom: varied from student to student, but all the projects worked at the end (they were in groups of ~3, and the groups helped each other too)
14:17:14 <monochrom> ok, now see that's really different from one person on solo learning haskell, no?
14:17:21 <abitlost> as in any group of actual students, previous experience level varied, and that helped a lot; if it had all been total newbs, that would've been hard
14:17:31 <abitlost> monochrom: what the heck is your *point*?
14:18:05 <monochrom> before asking about my point, perhaps you should ask about my context?
14:18:42 <siwica> so although haskell is technically a multi purpose language: what is it used for mostly in praxis and why is that?
14:18:46 <monochrom> the context is one person on solo beginning with haskell. would you assign a 300-line project a few weeks into haskell?
14:18:57 <xplat> wow, that escalated quickly.  the context is that a person asked what they could do as a project to learn haskell solo as a beginner
14:19:43 <abitlost> siwica: there's no answer to that. It has a large community, and really is used for more or less everything.
14:20:09 <xplat> siwica: it's hard to tell what haskell is actually used for because by far the bulk of the loc-wise use is bespoke projects with low outside publicity
14:20:58 <abitlost> monochrom: I don't assign projects, and no. I was arguing *against* starting with a 'guess the random number game', because that has a way larger amount of stuff to have your head around at least a bit in Haskell than in most languages
14:21:12 <siwica> It just occured to me that I never used a program that I knew was written in Haskell
14:21:35 <jle`> siwica: well. haskell has no specific niche like ruby has in web dev (but it does do blazingly fast web servers). it's powerful in many places, useful in many places, and there is no 'niche' that it is particularly known for.
14:21:41 <jle`> siwica: have you ever used pandoc?
14:21:45 <xplat> things people tend to publicly praise it for include compilers, server-side web programming, advanced report generation, and financial modelling
14:22:02 <siwica> jle`: No, I have not
14:22:03 <abitlost> siwica: I use xmonad, and used to use darcs; they're both in Haskell
14:22:04 <jle`> to convert between markdown, latex
14:22:08 <jle`> html
14:22:13 <jle`> ah
14:22:22 <xplat> abitlost: maybe a better project would be 'animal'?
14:22:47 <abitlost> xplat: I don't know that particular project. :-)
14:23:21 <monochrom> guessing an animal and guessing a number suffer the same problem and enjoy the same solution to that problem.
14:23:59 <monochrom> namely, if randomly generating a secret is too hard, you can always fall back to asking another person for the secret.
14:24:24 <lispy> siwica: have you ever played rainycat?
14:24:49 <xplat> monochrom: the difference with ANIMAL is the computer guesses the animal
14:24:55 <siwica> Ok, so I guess I will start with writing some easy up to 100 lines programs I did write in some other languages (Java, C++, Ruby, Pascal...) before. Like simple Fractals or maybe some project euler math programs.
14:25:02 <siwica> lispy: no, what is that?
14:25:11 <lispy> siwica: it's a game written in Haskell
14:25:12 <monochrom> well, yes, that is another solution you can apply to number guessing too.
14:25:20 <lispy> siwica: There is also nikki and the robots: http://buy.joyridelabs.de/
14:25:41 <monochrom> I think we are on to proving that animal and number are isomorphic
14:26:22 <siwica> lispy: ok, cool!
14:26:38 <xplat> monochrom: actually they're not
14:26:38 <lispy> siwica: and the backend of this webservice is written in Haskell http://detexify.kirelabs.org/classify.html
14:26:44 <siwica> lispy: Writing simple games like tetris or so might be a good project too
14:26:55 <xplat> i wish animal were easier to google for ...
14:27:01 <monochrom> haha
14:27:31 <xplat> there's a version in LOGO but even 'animal game terrapin logo source code' doesn't seem to nab it
14:27:38 <monochrom> I played with Apple II at the the of IIe, it was the only way I knew of the animal game
14:27:46 <monochrom> s/the the/the time/
14:28:06 <ij> If I had a foo :: a -> IO (), and mapM foo [IO Char], but foo no longer returns an instance of IO, then I want an applicative? <*>
14:28:29 <lispy> siwica: ah, I was just trying to think of programs you might have used that are written in Haskell
14:28:33 <siwica> Is there also some Emacs like editor written in haskell?
14:28:34 <ion> ij: fmap
14:28:40 <lispy> siwica: yi
14:28:45 <ion> ij: Also, [IO Char] is not a value.
14:28:45 <lispy> and leksah
14:28:55 <ion> ij: And IO is not a class.
14:29:08 <ij> Those were IO [Char], sorry.
14:29:13 <siwica> lispy: I have used neither of them but I recognize there are some non serverside ones ;-)
14:29:18 <xplat> darcs and xmonad probably have the widest use among people who don't develop haskell code, which isn't saying much really
14:29:32 <ij> :t fmap
14:29:33 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:29:56 <ij> ion, But wouldn't that mean that my foo function should deal with a list(which is not true in this case).
14:30:21 <ion> (=<<) :: … => (a -> f b) -> f a -> f b
14:30:26 <Cale> ij: Perhaps you should just describe what your program does
14:30:28 <ion> fmap  :: … => (a ->   b) -> f a -> f b
14:30:48 <lispy> siwica: I use lots of Haskell programs but often I've just recently written them for some specific task :)
14:31:01 <lispy> Haskell > shell
14:31:45 <xplat> probably if we were still using the command line interface haskell would be all over the place, but haskellers tend toward perfectionism and haven't made a gui library that the community is really happy with yet
14:31:54 <monochrom> https://github.com/chrisdone/hell :)
14:31:59 <siwica> lispy: propably true ;)
14:32:40 <Philonous> xplat, I'd settle for "installs and runs"
14:32:47 <siwica> lispy: So do you still use languages with other paradigms when speed is not a critical issue?
14:32:52 <xplat> most of them either don't have enough functionality, have poor performance, give unusual-looking interfaces, or are thin wrappers over C libs which force you to write some haskell that's uncomfortably like C yourself
14:33:59 <lispy> siwica: are you asking if I use other languages when I want to write a slow program?
14:34:14 <lispy> Haskell programs can be quite fast
14:34:23 <xplat> (another common complaint is 'uses Arrows', although to some people that's not a complaint)
14:34:39 <siwica> lispy: not neccesarily slow but speed is not always an issue
14:34:52 <quchen> Or better, slow speed is very rarely an issue.
14:35:30 <xplat> lispy: what library do you use with haskell that gets you out of writing sh so well?
14:35:52 <siwica> lispy: I study physics and most of the experimental guys seem to do their data analysis with C++ so I thought C++ was somehow more suitable for this time critical domain...
14:36:17 <lispy> xplat: I've used shelly but I'm not all that happy with it. I guess it depends on what the shell was doing right? Shell tends to be good with pipes.
14:36:20 <monochrom> fortran is the most suitable. still is.
14:36:37 <quchen> monochrom: Naah. There are plenty of alternatives.
14:36:49 <xplat> lispy: i'm sort of an expert bash scripter, so it would need to be a pretty darn tiny tradeoff in the usual case for me to not write shell because i know my way around a lot of the more unpleasant limitations
14:36:53 <Cale> monochrom: Kind of sad, given that you can FFI to Fortran easily enough.
14:37:01 <quchen> Python is highly popular as glue these days, for example. The bulk of many programs is implemented with it.
14:37:04 <Cale> (I've tried it, just to make sure that it works)
14:37:10 <monochrom> I am merely referring to practical fortran compilers doing crazy optimizations.
14:37:15 <lispy> siwica: well, hmatrix is a binding to BLAS. computational physics tends to be at an extreme end for performance.
14:37:42 <lispy> xplat: over about 20-50 lines of shell, I find Haskell to be a win in terms of maintenance.
14:37:56 <monochrom> and facts like, for example, fortran semantics allows those crazy optimizations where C semantics doesn't.
14:38:09 <xplat> lispy: i'm seriously attempting to move from make to shake, though, because becoming an expert in make is all about learning exactly why none of its limitations can be worked around
14:38:24 <jeltsch> Hi, I want to check a Cabal package with cabal upload -c ⟨package name⟩.
14:38:49 <jeltsch> However Cabal gives me the following error message:
14:39:08 <jeltsch>     Error: ⟨path to package⟩: 404 Not Found
14:39:12 <monochrom> some Haskell people are, in fact, getting close to bringing similar optimizations to Haskell when it comes to crunching arrays. that will make Haskell on par with Fortran.
14:39:14 <jeltsch>     Error: Page not found
14:39:20 <monochrom> and completely above C etc
14:39:24 <jeltsch>     Sorry, it's just not here.
14:39:27 <quchen> monochrom: Are you referring to HRC?
14:39:34 <siwica> lispy: yes it obviously it. But I wonder what other reasons Haskell people use other paradigms when not forced by their company.
14:39:35 <lispy> siwica: There are different types of performance too. There's programmer time, raw number crunching time, and then the kind of performance you get by being able to change your algorithm or allowing the compiler to do interesting transformations.
14:39:37 <monochrom> I don't know HRC. but maybe yes.
14:39:45 <quchen> Intel's Haskell Research Compiler
14:39:47 <xplat> lispy: heh, i have a 433-line (though that counts blanks) shell script that implements a simplistic database query language with joins
14:39:53 <jeltsch> Can anyone tell me why Cabal doesnt just access the local file, but tries to establish an HTTP connection?
14:40:09 <monochrom> then probably not. I'm referring to cool optimizations when your program is array-intensive
14:40:31 <monochrom> so, think of vector, REPA, data-parallel haskell
14:40:31 <xplat> lispy: (for tag searches, though, not reporting, so it doesn't have user-defined schemas or advanced output options)
14:41:06 <lispy> siwica: Haskell has properties that allow the compiler to do some interesting optimizations like deforestation/fusion. C++ can do some of those too with template meta programming, but it's painful.
14:41:30 <nlogax> jeltsch: Maybe it checks for example if there's a package with the same version already?
14:41:46 <johnw> lispy: in C++ you end up writing your own optimizer using template meta-language!
14:42:10 <nlogax> jeltsch: There's `cabal check` too if you just want to check for mistakes
14:42:18 <quchen> monochrom: HRC is described in this paper if you're interested: http://www.leafpetersen.com/leaf/publications/hs2013/hrc-paper.pdf
14:42:24 <lispy> siwica: but where Haskell won't be as fast as C/C++ (without expert help) is the raw number crunching due to the book keeping of laziness. An expert can get the factor between Haskell and C to be pretty small (or non-existent) though.
14:42:41 <xplat> lispy: if you mean dons just say dons
14:42:45 <lispy> heh
14:43:02 <jeltsch> nlogax: If it checks for a package with the same ID, then I cannot see why I should get an HTTP error.
14:43:04 <siwica> lispy: ok, I see
14:43:08 <lispy> siwica: So, the reason I use Haskell is a) I like it.
14:43:11 <lispy> siwica: there is no (b)
14:43:12 <jeltsch> nlogax: What is the difference between cabal check and cabal upload -c?
14:43:14 <monochrom> C or C++ asks, "mirror mirror, who is the fastest?" mirror answers, "you are the fastest, except there is fortran outside, she is even faster"
14:43:19 <siwica> lispy: :P
14:43:21 <jeltsch> cabal check seems to be new.
14:43:45 <xplat> monochrom: that doesn't make sense.  apple killed flash, not fortran.
14:43:53 <monochrom> haha
14:43:54 <siwica> lispy: So how comes functional languages are not nearly as wide spread as C++/Java/...?
14:44:02 <jmcarthur> cabal check has been around a while. think of it as a simple lint for your cabal projects
14:44:05 <nlogax> jeltsch: I didn't know upload -c existed, so I don't know :) The help text is quite minimal
14:44:06 <monochrom> no one said the fairy tale world makes sense :)
14:44:17 <simpson> siwica: Inertia.
14:44:18 <nlogax> jeltsch: But upload-related checks would make sense
14:44:22 <jophish_> Yo yo yo
14:44:25 <jmcarthur> cabal check has no effect on anything. it just validates
14:45:00 <lispy> siwica: I'm not really sure, but that goes for a lot of my preferences. Dvorak vs. qwerty. Left-handed vs. right-handed. etc
14:45:16 <jophish_> I have a function a -> IO (Maybe b), what's a nice way of printing an error and quitting if this returns Nothing, and otherwise getting the Just value?
14:45:21 <jeltsch> jmcarthur: I though that cabal upload -c is the simple lint for Cabal packages.
14:45:29 <xplat> siwica: it's all canada's fault
14:45:32 <jeltsch> though → thought.
14:45:33 <lispy> siwica: Perhaps those people enjoy template meta programming and objects in the way that I prefer functions.
14:45:53 <quchen> *Nobody* enjoys template metaprogramming.
14:46:08 <monochrom> don't be so sure
14:46:28 <jeltsch> nlogax, jmcarthur: Hmm, cabal help check does not tell me anything useful. It does not even mention a synopsis.
14:46:31 <bennofs> it's fun. It's a puzzle, like solving a rubics cube
14:46:42 <siwica> lispy: A big reason is probably the structure of programming college courses too
14:46:46 <jeltsch> jmcarthur: This is strange, given that is has been around for some time.
14:46:56 <lispy> siwica: possibly, but those had to come from somewhere
14:47:09 <xplat> like solving a rubik's cube that doubles in size whenever you make a wrong move
14:47:31 <bennofs> haha
14:47:51 <monochrom> whenever you see a task or problem that is a circlejerk, you can be sure that some humans enjoy it.
14:48:05 <siwica> lispy: Although I had several years computer science at school and visited some physics programming courses nobody ever told me about functional programming. I just discovered it when beginning to use emacs.
14:48:16 <jeltsch> nlogax, jmcarthur: cabal check is also not described in the Cabal User Guide. :-/
14:48:25 <lispy> siwica: I think a lot of programming language use/preference/choice is purely psychological. If you trust something you're much more likely to use it for things that matter to you like work or research.
14:48:54 <xplat> heh, and people often trust those who will always let them down
14:48:59 <jmcarthur> jeltsch: i usually use it when i first make a project and then never touch it
14:49:01 <quchen> siwica: Well there's your explanation why so few people use functional programming.
14:49:20 <quchen> I remember getting weird looks for returning a lambda in Python. I looked like a martian.
14:49:40 <jeltsch> nlogax, jmcarthur: cabal check seem to check the contents of your cabal package directory. cabal upload -c however is supposed to check a tarball generated by cabal sdist. This is what Im looking for.
14:50:04 <jmcarthur> that difference sounds about right to me
14:50:12 <nlogax> jeltsch: There's an open issue about it here https://github.com/haskell/hackage-server/issues/128
14:50:15 <xplat> quchen: you should instead define a nested function and return it :)
14:50:38 <bennofs> I think I had a def ignore_params(f, *args, **kwargs): return lambda *ignored, **kwignored: f(*args, **kwargs)
14:50:46 <siwica> quchen: It might also be that it helps to have some advance mathematical understanding
14:51:13 <quchen> siwica: Mathematical understanding helps you in Haskell the same way it helps you in imperative languages.
14:51:49 <lispy> siwica: I follow /r/gamedev casually reading articles. A trend I've noticed there is that people frequently come by and ask "what is the best language for game of type X?" and they get answers across the board and suggestions I wouldn't even think of. And yet, people make games in just about everything.
14:52:04 <lispy> siwica: Generalizing that a bit. I don't think the technical details matter nearly as much as we pretend.
14:52:10 <quchen> I for one have yet to put my knowledge about path integrals in field theory to good use in functional programming.
14:52:13 <xplat> quchen: nah, i would say it helps you more, not because haskell is harder without mathematical understanding, but that imperative languages don't get as much easier with mathematical understanding as you might hope
14:52:15 <FreeFull> Obviously the best language is always some Prolog derivative
14:52:21 <siwica> quchen: Ever since I learned how to get familiar with vector spaces of functions in analysis and higher order functions functional programming looked pretty natural to me. Before I might have ran away I guess :)
14:52:22 <lispy> siwica: It's really more about what you're comfortable with and how you use it.
14:54:06 <quchen> That's like saying writing poems in Chinese is harder because the language is more alien.
14:54:07 <jle`> does haskell really require mathematical understanding?
14:54:08 <xplat> quchen: (of course understanding some subfields of math helps more than others, path integrals are kind of on the low end)
14:54:13 <quchen> Painting the symbols is not the problem.
14:54:33 <benmachine> jle`: most people say no
14:54:36 <jeltsch> nlogax: So given that we have this bug, and given that the new HackageDB website has no check functionality, and given that the new package candidate feature is not yet functional, there is just no way to check a package beforehand. :-(
14:54:40 <lispy> siwica: http://pottery.about.com/od/apottersconceptualspace/a/apocrytale.htm
14:54:41 <benmachine> I don't know because I already had the maths before I started :P
14:54:54 <jeltsch> nlogax: I will just upload.
14:54:59 <xplat> jle`: i just made a point of saying it isn't required even while it helps :-/
14:55:04 <hnsz> I can't find any tutorial or book on haskell.org that wants to teacht _programming_, specifically something suitable for students that reached the level of say being able to do derivations, in mathematics (17 year olds)
14:55:15 <siwica> lispy: that is probably true. I think a big step is to take a function as a normal object like an integer and to deal with basically the same way. With highschool math this seems rather nonintuitive it seems
14:56:07 <merijn> hnsz: What's wrong with Learn You a Haskell?
14:56:19 <quchen> merijn: Too basic, written for 5-year-olds
14:56:26 <monochrom> writing poems in Chinese is harder because the language doesn't let you permute words to fit any scheme of rhyming
14:56:29 <xplat> quchen: it's kind of like saying riding horses is more difficult than riding cars because horses are moody
14:56:30 <Cale> I think hnsz is looking for SICP translated into Haskell?
14:56:40 <hnsz> quchen: or cats :p
14:56:44 <merijn> quchen: I enjoyed LYAH as a 25 year old :<
14:56:50 <jle`> :<
14:56:53 <abitlost> siwica: Hmm.. if anything, it's easier in a way (to be able to pass functions around, etc) - they're less 'special'. You don't need to think of it mathematically
14:56:57 <hnsz> Cale:  *self whoosh*
14:57:03 <quchen> merijn: At least that's what your passport says ;-)
14:57:31 <merijn> quchen: My passports only mentions my birthdate, not my age. Also I'm no longer the age I was when I read it :p
14:58:07 <monochrom> someone should make an uncoloured version of LYAH. the goal is to allow the reader to colour it.
14:58:13 <Cale> hnsz: Structure and Interpretation of Computer Programs is a great classic introductory book, but it uses Scheme.
14:58:15 <merijn> monochrom: oooh!
14:58:24 <xplat> hnsz: it's a pet peeve of mine that people think things are 'too childish' for them because of surface characteristics
14:58:26 <hnsz> merijn: I don't think that is aimed at complete newbies to cs and programming
14:58:31 <quchen> SICP is not about Scheme, though.
14:58:33 <monochrom> see? it is more lovely, isn't it? :)
14:58:39 <Cale> quchen: Well, sure :)
14:58:43 <xplat> hnsz: if it's easy enough for children it should be even easier for you
14:58:46 <scott_> monochrom: Crayon syntax highlighting :)
14:58:50 <merijn> hnsz: True, but in my experience most books that are are terrible
14:59:20 <merijn> I don't think LYAH would be that bad to teach with
14:59:24 <Cale> quchen: But it might lose something in translation if a lot of care weren't taken :)
14:59:30 <merijn> It'd require more handholding to do something useful, though
14:59:52 <quchen> Cale: Oh sure, translating SICP to some other language (say Javascript) would be an awful idea.
14:59:57 <merijn> hnsz: Then again, I've avocated Coq and Agda as first languages, so what do I know?
15:00:13 <hnsz> xplat: Seems to me it is just trying a marketing ploy copied from Why's (Poignant) Guide to Ruby
15:00:14 <abitlost> merijn: wow, why? (serious question)
15:00:17 <xplat> agda i could see, but coq?
15:00:34 <KiriKari> does darcs have gui tools like displaying 2 commits side by side to see differences?
15:00:57 <merijn> xplat: Coq as the original proposal by a colleague that didn't know agda
15:01:19 <hnsz> xplat: But that is not the reason why I think it is not suitable for complete beginners
15:01:32 <xplat> hnsz: if people didn't copy successful ideas, we would still all be camping out without tents on rocky pieces of ground in africa
15:01:39 <siwica> abitlost: sure, but you learn this kind of thinking either in mathematics or functional programming. In highschool you could always have a pretty good picture of a mathematical objects. But once you attend an analysis course and try to imagine spheres around functions or so, you learn to stop looking for an everyday equivalent from the normal world and start to think of things in a purely abstract way. Guess thats how it was with me at least.
15:01:45 <scott_> I don't see LYAH as similar to the Poignant Guide
15:01:47 * hackagebot 3d-graphics-examples 0.0.0.0 - Examples of 3D graphics programming with OpenGL  http://hackage.haskell.org/package/3d-graphics-examples-0.0.0.0 (WolfgangJeltsch)
15:01:51 <hnsz> xplat: ok
15:01:53 * yogurt_truck advocates starting by learning as little language-specific things as possible
15:02:11 <merijn> abitlost: Well, we had a discussion and everyone agreed that most "typical" languages hide too much, leading to people with magical believes. So the agreement was that either asm or Agda should be taught first. The idea was that having an interpreter/interactive mode Agda would probably be better than asm :p
15:02:32 <yogurt_truck> s/little/few/
15:02:37 <bennofs> oh, 0.0.0.0, what a nice version number
15:02:38 <merijn> abitlost: The curriculum we settled on was: Agda -> asm -> haskell -> C -> prolog + lisp + something objecty
15:02:50 <abitlost> merijn: I wish I'd gone there. :-)
15:03:07 <merijn> abitlost: That doesn't exist, it's wishful thinking from us phds :p
15:03:15 * abitlost tends to think "something objecty" should definitely be smalltalk
15:03:25 <abitlost> merijn: ahh.... :)
15:03:31 <hnsz> Cale:  WHen I first got into haskell I felt that it did exactly what my intutions wanted when I started programming, which was in a imperative language.
15:03:33 <monochrom> Agda hides even more than other high-level languages, no?
15:03:48 <merijn> monochrom: The idea was to just ignore implementation with Agda
15:04:35 <quchen> A first language should motivate to go on, not teach truest way of programming. Let's add 3+5, but first we need to know about Peano arithmetic, kids.
15:04:43 <merijn> monochrom: Focus on types and declarative meaning, then asm to understand how computers work. Haskell and C for learning how to implement things :p
15:04:56 <monochrom> on the other hand, I guess either cold hard logic or cold hard hardware is a good solution to magic
15:05:17 <hnsz> quchen: No need for peano or lambda's at the start
15:05:23 <xplat> which is why logic should be renamed to 'coldware'
15:05:40 <merijn> monochrom: That was our logic, first cold hard logic, then cold hard hardware, then move to the middle of the spectrum :)
15:06:20 <quchen> I remember how I learned to ride a bicycle. My parents first taught me how to operate a racing motorcycle, and from then on everything was so easy.
15:06:34 <lispy> merijn: I like what you're getting at, but I don't think I would start with Agda unless the crowd is pretty sophisticated mathematically.
15:06:36 <xplat> i think 'magical thinking' is a more general problem than in programming students
15:06:41 <merijn> quchen: No, first language should focus on weeding out the weaklings :)
15:06:58 <quchen> merijn: I'm sure that would turn out well. Sparta programming!
15:07:06 <Urchin[emacs]> merijn: assembler has a lot of the nice mathematical properties that make lisp interesting, so teaching lisp may be redundant
15:07:34 <merijn> Urchin[emacs]: To be fair, after Agda and asm everything else should be a cakewalk :p
15:07:41 <bz> :t runMaybeT
15:07:42 <lambdabot> Not in scope: `runMaybeT'
15:07:46 <xplat> just lock students in a room, and let them program a robot to get them out before they die of thirst
15:08:04 <lispy> merijn: or maybe due to second system syndrom you'll be creating a bunch of asm programmers :)
15:08:12 <hnsz> But seriously, there is no tutorial or book out there aimed at high school students? Doesn't that bug you?
15:08:16 <quchen> xplat: You could at least learn a thing or two about human nature with that.
15:08:16 <abitlost> merijn: Hm, I'm not convinced by the weeder approach; how strongly does it even correlate with later skill? (And you do a lot of damage to the ones that fail, but plenty of them can make life less annoying by doing webdev so we don't have to, eh? ;P)
15:08:21 <xplat> lispy: that's not what second system syndrome means
15:08:35 <lispy> heh, yeah I just realized that :)
15:09:00 <merijn> abitlost: We were talking of creating proper systems people, not puny JS monkeys :p
15:09:02 <xplat> hnsz: i seriously think high school students are the only people too self-conscious to use lyah :P
15:09:09 <hnsz> I've seen your talk Cale, you were heavily implying dsl potential :p
15:09:31 <quchen> merijn: Who does the monkey parts when there are no monkeys?
15:09:33 <abitlost> merijn: sure, hence my first question: to what extent would this *do* that?
15:09:36 <hnsz> xplat: indeed :P
15:09:41 <lispy> xplat: I'm thinking of the one where people learn one thing and like it okay but then they go on to learn a new thing that's a bit different (like a second programming language) and then think it's amazing and don't know how anyone uses anything else.
15:09:47 <hnsz> xplat: They like rap music!
15:10:02 <merijn> quchen: I'm having trouble getting one university that teaches proper systems things, so all the others are still churning out monkeys
15:10:15 <bennofs> What happens when I use dynCompileExpr (GHC API) on an expression evaluating to one version of a type, and then use fromDyn for a different version of the same type on the result?
15:10:25 <xplat> hnsz: there's nothing wrong with rap music
15:10:29 <quchen> merijn: My intro to compsci was in Java :'(
15:10:34 <merijn> quchen: So was mine
15:10:56 <MattY> is there a way to automatically write all the exceptions and their error messages to a log file?
15:11:06 <xplat> hnsz: i can't believe you tricked me into saying 'rap music' when i meant 'rap' :(
15:11:16 <lispy> first PL isn't that important IMO. Djikstra would have you think that I'd be broken forever as my first language was BASIC.
15:11:17 <abitlost> mine was... html, at some community class that I begged to go to because I wanted to learn more about computers, before I was a teenager. Systems stuff would've been way more awesome
15:11:21 <Urchin[emacs]> merijn: assembler should really acompany an exploration of processor achitectures themselves
15:11:26 <arkeet> the intro CS course I took was with pascal, but they switched to python the very next year
15:11:30 <hnsz> xplat: It's just orthogonal to cutesy, programming books
15:11:36 <MattY> something like a global handle function, that is called every time an exception is thrown (even when it is caught)
15:11:55 <arkeet> (I am trying to be careful not to call that my introduction to CS)
15:12:06 <quchen> lispy: My first language was (Visual) Basic. I could easily create windows and clicky buttons and enjoy my programs and give them to my friends and get compliments for them. Try doing that with ASM.
15:12:18 <xplat> lispy: my first language was LOGO, although my second was BASIC
15:12:19 <quchen> I was maybe 13.
15:12:38 <hnsz> quchen: My first language was, moving a turtle in basic :p
15:12:54 <bennofs> my first language was Visual Basic for Applications, in Excel
15:13:04 <Urchin[emacs]> my path was LOGO, QBASIC, C, FORTRAN
15:13:10 <merijn> bennofs: Same here :p
15:13:14 <ImYourBreda> I have a dattype which is kinda similar to a JSON type, is there a way to let users convert between that type and their custom (nested) record types without requiring them to write boilerplate?
15:13:26 <ImYourBreda> is it what GHC.Generics was invented for?
15:13:37 <lispy> ImYourBreda: correct
15:14:08 <ImYourBreda> that library seems so complex
15:14:12 <bennofs> Then Visual Basic -> Java (only a little bit) -> C++ + Python -> Haskell
15:14:23 <xplat> LOGO, Commodore BASIC 2.0, Commodore BASIC 7.0, WordPerfect macros, Turbo Pascal, Turbo Prolog, C, Perl, ... i lose track after that
15:14:42 <lispy> ImYourBreda: Yeah, it's pretty advanced.
15:14:46 <Kron> quchen: I learned to program in QBASIC.
15:14:47 <xplat> i don't really count .BAT files, they're less expressive than WP macros
15:14:48 <arkeet> I used VB when I was really little. except I worked on a greyscale display so I thought #FF00FF was the grey for a window background.
15:15:03 <arkeet> and then when I lated ran my programs on a colour monitor they were all pink.
15:15:06 <Kron> Those were the days... back before newfangled inventions like 'functions' and 'scope'
15:15:13 <Kron> Everyone had nothing but global variables
15:15:15 <xplat> i guess i learned some ASM in there sometime too
15:15:16 <Kron> and we had GOTO
15:15:23 <Kron> and we liked it! Kids these days
15:15:48 <Kron> also no comment syntax so we had to use REM statements everywhere, if we could be arsed
15:15:52 <bennofs> ImYourBreda: You might want to read the paper about generics. I found it pretty readable
15:16:01 <Urchin[emacs]> I had some old Motorola assembler somewhere, but I remember none of it
15:16:04 <xplat> Kron: REM statements are syntax
15:16:21 <k00mi> merijn: so it's settled that you will teach Agda as first language? That could lead to quite a bit of insight regarding the claim that functional programming is only hard for imperative programmers
15:16:27 <bennofs> ImYourBreda: There is also a little introduction on the wiki: http://www.haskell.org/haskellwiki/GHC.Generics
15:16:31 <ImYourBreda> bennofs: could you give me a link?
15:16:35 <ImYourBreda> to the paper
15:16:36 <lispy> ImYourBreda: the idea is that you map your data constructors to the GHC.Generic types and then to finish the conversion you make a map from those types to the other data constructors. The mappings are expressed using type classes.
15:16:51 <bennofs> ImYourBreda: http://dreixel.net/research/pdf/gdmh.pdf
15:16:57 <ImYourBreda> bennofs: cheers
15:17:42 <lispy> ImYourBreda: Here is some example code for whatever that is worth: https://github.com/GaloisInc/aterm-utils/blob/master/src/ATerm/Generics.hs
15:18:18 <xplat> although it's a fun idea, the only way i would seriously recommend Agda as a first language is if you have a class of 50-year-old mathematical logicians who want to learn to program
15:18:53 <ImYourBreda> so there is no easy to use reflection package like in Go? http://golang.org/pkg/reflect/
15:19:03 <ImYourBreda> (totally unsafe though)
15:19:10 <merijn> k00mi: I'm not sure I'd really use Agda, but it's pretty clear functional programming is only hard for imperative programmers that refuse to let go
15:19:20 <lispy> ImYourBreda: There are other ways to do it. We have lots of generic programming libraries
15:19:33 <merijn> k00mi: We see plenty of complete newbies or experiences imperative programmers with an open mind and come here without too much trouble
15:19:58 <merijn> k00mi: It's the vocal minority that looks at haskell and goes "this is different, therefore bad and hard" that whines that functional programming is hard
15:20:13 <Kron> hmmm, merijn, how about ocaml?
15:20:21 <merijn> I would say there's lots of truth in
15:20:26 <merijn> @quote everything.is.hard.in.haskell
15:20:26 <lambdabot> roconnor says: writing incorrect programs in Haskell is hard. but writing correct programs is hard in every langauge. therefore, writing code in Haskell is hard. <EvanR> everything is hard in haskell ;) <kmc> that's a pretty good summary
15:20:27 <Kron> that has most of the functional goodness without the slightly confusing lazy evaluation cost semantics behind it
15:20:39 <Kron> I think a kind of strict haskell would be the easiest way to start out
15:20:56 <merijn> Kron: ocaml just has the confusing syntax, the tempting escape hatch of impure code and a crappy standard library
15:21:02 <Kron> (and I do think strict evaluation is strictly more easy to reason about than lazy evaluation, i.e. it's not a question of familiarity)
15:21:02 <lispy> ImYourBreda: See for example: http://www.haskell.org/haskellwiki/Research_papers/Generics
15:21:05 <ImYourBreda> for example: is there any way to return fields of a record, set field like  setRecordField :: String -> a -> b -> b  (where a is field value ,b is record)
15:21:11 <ImYourBreda> etcetc
15:21:21 <merijn> Kron: I think haskell would be significantly easier as first language, tbh.
15:21:33 <merijn> Kron: (I say this having TA'ed an ocaml course two years in a row)
15:21:33 <Kron> merijn: yeah I too dislike the impure escape hatch
15:21:43 <Kron> if you really watn to you can do a lot of impure stuff in ocaml
15:21:58 <Kron> then again you can do that in haskell to to a lesser or greater extent with unsafePerformIO and the like
15:22:03 <Kron> and the ST monad
15:22:55 <merijn> Kron: unsafePerformIO will break *really* quickly
15:23:00 <Kron> merijn: ooooh that's fascinating, I'd love to hear your stories
15:23:02 <merijn> Kron: Thus traumatising users into not using it
15:23:15 <ImYourBreda> lispy: since my jsonlike type only contains basic types (float, int etc) and Data.Map + list
15:23:19 <merijn> Kron: As for ST, the ST monad is fine. That's still perfectly pure
15:23:21 <k00mi> merijn: ok that's right, a remaining question would be whether a functional language is easier to learn as a first language than an imperative one
15:23:30 <k00mi> I don't think we have much data on that, do we?
15:23:35 <ImYourBreda> maybe Map implements that generic thingie as well and i can just derive it?
15:23:36 <Kron> merijn: true about the monad
15:23:41 <merijn> k00mi: I would say language is the simplest part of learning to program
15:23:50 <merijn> k00mi: It's the learning to think bit that's hard
15:23:55 <lispy> ImYourBreda: Maybe you should look at aeson and how it does conversions to other types. I bet you could reuse their machinery with just a bit of adaptation.
15:23:58 <haasn> I'd like to take this moment to mention that mutation is not necessarily a side effect
15:24:05 <merijn> k00mi: And I think purity helps by reducing the number of variables to think about
15:24:14 <ImYourBreda> lispy: they are using TH
15:24:22 <ImYourBreda> im not going down that route
15:24:41 <hnsz> haasn: I'm fetching my pitchfork
15:24:55 <k00mi> merijn: yeah I agree, it would still be interesting to have some data
15:25:12 <merijn> k00mi: Sure, but this stuff is notoriously hard to have experiments with :p
15:25:27 <haasn> look at some monads; state, writer, cont; combine them with lens. You get an interface that will leave people unfamiliar with haskell thinking it's imperative after looking at examples
15:25:41 <lispy> ImYourBreda: I need to get going. I hope you find a soltion that works.
15:25:47 <Kron> I find that things like 'map' are fundamentally really really easy to think about
15:25:54 <ImYourBreda> lispy: thanks for your help mate
15:25:57 <Kron> I have some experience moving imperative programmers into functional langauges
15:26:00 * Cale read that as "soliton that works"
15:26:15 <Kron> and the toolkit that comes in functional languages to replace stuff like for loops is just powerful and easy to reason about
15:26:34 <ImYourBreda> for loops - they are so nineteen sixties
15:27:52 <merijn> haasn: Don't you mean "thinking it's perl"?
15:30:28 <pyon> Is it possible to write a function in C that is aware of Haskell type classes (e.g., by taking dictionary instances as explicit parameters) and can be consumed from Haskell via the FFI?
15:33:49 <SLi> Is it a universal convention that qualified imports are imported as a one-letter alias? I often find myself confused in even my own code of all the short aliases... though maybe I should use selective import more instead of qualified.
15:33:49 <Cale> pyon: I'm pretty sure the answer is no
15:34:37 <Kron> pyon: it's simple. Step 1: Write Haskell in C. Step 2: ??? Step 3: Profit!
15:34:43 <zomg> SLi: often yes but not always I think. For example, lazy bytestrings or such are sometimes BSL or LBS and such
15:34:59 <SLi> Yeah. Especially if you also have strict ones in the same module :P
15:35:04 <Cale> SLi: Well, a lot of people (myself included) find explicit module qualifiers to be a bit of a painful necessity, and want them to be visually small as a result :)
15:35:24 <SLi> Cale: I understand! They are painful.
15:35:26 <Cale> M for Data.Map and S for Data.Set are the two common one-letter imports that I'm aware of
15:35:56 <Cale> Apart from those, I don't see things being imported with a single letter too often.
15:36:19 <xplat> a lot of people do B for whichever ByteString they need, or T for Text
15:36:19 <Cale> Maybe B for whichever sort of ByteString you're using, or T for Data.Text
15:36:23 <Cale> yeah
15:37:30 <merijn> BS for byteString
15:37:44 <merijn> F and T are for Foldable and Traversable
15:38:07 <SLi> Then maybe one of my problems is that I somehow dislike importing Prelude hiding something, but I don't have a very good reason for that attitude. Perhaps because it makes the meaning of code too dependent on what imports there are...
15:38:15 <Cale> merijn: hehe
15:38:52 <pyon> Kron: When I consult the documentation, it seems to me that the FFI is designed to make Haskell accomodate for the fact it is calling C libraries - you have all these weird "Ptr a"s and Storable instances. I want it to be the other way around: I want a C library that accomodates for the fact it will be called from Haskell. :-|
15:38:59 <Cale> SLi: There was a time when people actually tried to avoid using the Prelude's names. Crazy idea, I know.
15:39:05 <Taneb> What do you call Template Haskell ''Foo-izing?
15:39:31 <merijn> pyon: How so?
15:39:39 <merijn> pyon: What would you want it to do, then?
15:39:57 <Kron> pyon: I'm not sure that's possible, becuase C fundamentally doesn't have the concept of a pure function, right?
15:40:20 <merijn> Kron: Not a compiler checked concept, no
15:40:36 <SLi> pyon: Or.... why would you want to do that? Seems to me that handling the glue code is anyway easier in Haskell. (Some people apparently even prefer testing their C code using Haskell and FFI.)
15:40:36 <jle`> i usually don't mind one letter qualifiers for imports.  i too do not like hiding prelude...i like to know exactly which version i'm using without having to look at the imports
15:40:41 <Cale> I sometimes miss the days when you could just import FiniteMap and import Set without having to worry about the name overlap
15:41:00 <Kron> gah, got to go: exam. pyon, good luck with your code
15:41:06 <pyon> ok ty
15:41:12 <pyon> and gl with your exam
15:41:26 <xplat> pyon: either way you are going to be writing some glue code; seems to me i'd want to write glue code in haskell, not in C.
15:41:43 <xplat> pyon: although i'm aware there are people who think differently about that
15:42:30 <pyon> merijn: xplat: I want C to be aware of Haskell's concepts (to the greatest extent possible), not the other way around. I like thinking in Haskell, not in C.
15:42:30 <Cale> Also I don't understand why the introduction of hierarchical modules meant that we had to immediately shovel everything into the two big "miscellaneous" drawers that are Data.* and Control.*
15:42:41 <xplat> (one of them said haskell had the worst FFI of any language they'd ever done FFI for, because the FFI involved writing glue in haskell rather than C)
15:43:03 <merijn> pyon: That's just not going to work, because C has no concepts like polymorphism or typeclasses
15:43:16 <xplat> pyon: if C could be aware of haskell's concepts, you would probably want to think in C rather than haskell :)
15:43:19 <merijn> pyon: What did you plan to write in C that requires that?
15:43:33 <SLi> Python has (at least) two ways to do FFI; either write complete Python modules in C, or the "ctypes" approach where you write the glue code in Python. I've never understood why anyone would like to do the former, because it's so much harder. I think it would be the same with Haskell :)
15:43:50 <Cale> You can of course write the glue in C, but you'll likely end up with a stupid binding.
15:43:58 <Cale> (or write no glue at all)
15:44:50 <Cale> The only reason Haskell's FFI requires lots of glue on the Haskell side is because C libraries are necessarily terrible. :P
15:44:53 <ParahSailin> you can do it in cmm too
15:45:08 <arkeet> what's the problem with writing glue in haskell?
15:45:17 <xplat> and i guess the haskell ffi is 'bad' that way from the point of view of 'i am bundling these 50 language bindings with my C library though i don't know any of these languages'--but why would you want to do that?
15:45:29 <pyon> merijn: I want to make something like a "mutable bytestring that can mmap()ed from a file".
15:46:21 <Cale> arkeet: Well, I don't know, apparently someone doesn't like it
15:46:26 <xplat> you can already mmap a byte array from a file with just a little glue
15:46:55 <pyon> Oh, never mind. Seems like Hackage already had the answer for what I want: vector-mmap :-)
15:47:51 <xplat> i really don't like the semantics of mmap for a bytestring, but i guess for a vector they make more sense, you can just pretend another thread is messing with your vector
15:48:38 <xplat> doesn't make sense for a STArray or the like though
15:50:10 <xplat> i would kind of like my OS to have a truly immutable mmap() i could use to read in bytestrings from files instantly ...
15:51:14 <Cale> I'd settle for my OS not having draconian limits on open filehandles.
15:51:22 <xplat> heh, that too
15:51:37 <Cale> I have 16 GB of memory, I should be able to fill that with filehandles if I want to
15:51:43 <xplat> it should just be folded into memory limits, yeah
15:54:09 <xplat> threads, too
15:55:34 <Saizan> if that OS could also avoid grinding to an halt when a single process wants all the memory in the world it'd be nice too
15:56:00 <pyon> I want mmap() to be two different functions: one for read-only memory mappings and one for writeable memory mappings. They would not even have the same return type.
15:56:29 <xplat> i actually sketched out a plan for an OS that didn't even have OS threads, just all asynchronous system calls and the ability to set a process-local entry point for when the process gets CPU time
15:56:47 <jophish_> Yo yo yo
15:56:54 <jophish_> Are there any nice opengl wrappers for Haskell
15:57:04 <jophish_> GLUtil is a little nasty
15:57:30 <xplat> pyon: i would want that on the library level most likely, but i'm pretty agnostic about how the syscall interface handles it
15:59:12 <SLi> "The function `lift'ghc: panic! (the 'impossible' happened)"
15:59:27 <SLi> Something tells me I'm not using monad transformers right if I hit compiler bugs :D
16:00:22 <xplat> there's definitely more here than meets the eye
16:00:47 <RoryHughes> Is haskell even a real thing?
16:02:06 <xplat> no, it's a mythical creature like a unicorn.  the wild haskell has four wings, all of which are covered with lambda signs, the face of a CS professor, and the feet of a yeti
16:02:16 <copumpkin> I saw a haskell once, I swear
16:02:19 <dawik> i belive haskell was made to me feel stupid
16:02:35 <dawik> j/k
16:02:40 <dawik> but i am a noob
16:02:47 <donri> :t lift lift lift
16:02:48 <lambdabot>     Couldn't match kind `* -> *' with `*'
16:02:48 <lambdabot>     Expected type: (m1 a1 -> t1 m1 a1) -> t0 m0 a0
16:02:48 <lambdabot>       Actual type: (m1 a1 -> t1 m1 a1) -> t0 m0 a0
16:02:50 <abitlost> dawik: it's a perpetual publications engine ;-)
16:03:02 <johnw> :t lift . lift . lift
16:03:03 <lambdabot> (Monad (t1 (t2 m)), Monad (t2 m), Monad m, MonadTrans t, MonadTrans t1, MonadTrans t2) => m a -> t (t1 (t2 m)) a
16:03:12 <donri> that panics for me, what ghc is lambdabot running?
16:03:13 <dawik> abitlost: hmm :D
16:03:14 <Bor0> @src lift
16:03:14 <lambdabot> Source not found. I am sorry.
16:03:23 <Philonous> RoryHughes, It's an April fool's joke from comp.lang.scheme that spun out of control
16:03:44 <dawik> what do the . arguments do?
16:03:51 <Iceland_jack> (.) is function composition
16:03:57 <Iceland_jack> (f . g) x = f (g x)
16:04:14 <xplat> Philonous: some argue that comp.lang.scheme is still in control, others say there is no haskell cabal
16:04:35 <xplat> i'm with both
16:05:17 <dawik> what does lift do?
16:05:42 <Iceland_jack> @hoogle lift
16:05:42 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
16:05:42 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
16:05:42 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
16:05:50 <Iceland_jack> You can check out Control.Monad.Trans.Class ;)
16:05:51 <arkeet> the second one
16:06:59 <Philonous> xplat, They tried to shift to control but forgot to unwind-protect, or something like that
16:07:11 <dawik> so it recursively runs the monads? is that right?
16:07:20 <xplat> Philonous: ooh, nasty
16:07:23 <arkeet> it's not even wrong
16:07:43 <dawik> takes two arguments and runs the first one with both as arguments?
16:07:56 <dawik> s/runs/returns/
16:08:06 <xplat> dawik: if you have a monad stack, lift lets you run computations designed for a less featureful monad stack by letting its argument completely ignore the feature at the top of the stack
16:08:07 <Iceland_jack> @hackage Control.Monad.Trans.Class
16:08:07 <lambdabot> http://hackage.haskell.org/package/Control.Monad.Trans.Class
16:08:27 <Iceland_jack> Have you looked at the Hackage site dawik?
16:08:36 <dawik> tbh i only have a vague idea of what a monad is
16:08:45 <SLi> Though I think I'd still recommend trying to understand (.) first.
16:08:50 <Iceland_jack> Yes absolutely
16:08:54 <xplat> ...yes.
16:09:01 <dawik> well, i know of monadic properties, that if you return an instance of yourself with every function
16:09:03 <Iceland_jack> Save monad transformers for when you have a very clear idea about monads
16:09:04 <dawik> so you can chain stuff
16:09:19 <Iceland_jack> dawik: That's not really monads
16:09:25 <Luke> Anyone know how to get Shake importing correctly in emacs + ghc-mod?
16:09:26 <xplat> dawik: you read 'monads in jquery', didn't you?
16:09:30 <arkeet> =(
16:09:32 <dawik> xplat: possibly
16:09:34 <Luke> for some reason ghc-mod can't seem to find Development.Shake
16:09:38 <arkeet> please unread that.
16:09:41 <ReinH> dawik: jquery is not a monad.
16:09:41 <SLi> :)
16:09:42 <dawik> well no ididnt
16:09:42 <Iceland_jack> jQuery is not a monad
16:09:50 <dawik> that is what i heard yes
16:10:10 <dawik> it has a monadic structure
16:10:11 <Iceland_jack> dawik: Just being able to do:
16:10:11 <Iceland_jack>     foo().a().b().…
16:10:11 <Iceland_jack> has nothing to do with being a monad or not
16:10:13 <dawik> is that not even close?
16:10:18 <SLi> unreading sounds like IO, but read is not monadic.
16:10:26 <dawik> Iceland_jack: hmm, that is what i thought
16:10:35 <arkeet> a monad is just an instance of the Monad typeclass.
16:10:45 <ReinH> dawik: no, it doesn't.
16:10:59 <Philonous> arkeet, With some special properties
16:11:01 <Iceland_jack> There is no such thing as a monadic structure, at least not for things who aren't monads
16:11:02 <ReinH> This is a great summary of jquery vs monads https://dl.dropboxusercontent.com/u/632742/Tracks/Haskell%20Cast%20Episode%201%20Outtake%201.wav
16:11:03 <Iceland_jack> *that
16:11:03 <arkeet> well sure.
16:11:16 <xplat> dawik: that's like reading a sex advice column written by that smart aleck 3rd grader whose dad left the playboy channel unlocked on some of the weekends he had custody
16:11:25 <dawik> so, what constitutes a monad? i hear it is atomic..
16:11:27 <mgsloan> JQuery does feel a lot like the list monad smashed into the io monad tho.  Not that it /is/ in all cases, because it's difficult to have nice properties in javascript
16:11:36 <dawik> xplat: im sure lol
16:11:43 <ReinH> dawik: a monad is defined by >>=, return and join.
16:11:52 <arkeet> join is redundant
16:11:56 <arkeet> (and not in the class)
16:12:06 <ReinH> dawik: There are lots of analogies for what a monad is kind of like, but none of those are what a monad is.
16:12:07 <abitlost> dawik: indeed, not even close. a monad is when you have blueberries, can put them in a box, and have a function that turns blueberries into raspberries in a box (return and >>=, respectively, for a bizarre fruit monad)
16:12:07 <Iceland_jack> dawik: What do you mean by atomic?
16:12:07 <ParahSailin> @src join
16:12:07 <lambdabot> join x =  x >>= id
16:12:15 <arkeet> figure out what a Functor is first.
16:12:22 <Iceland_jack> Yes, what arkeet said
16:12:23 <arkeet> before thinking about Monad at all.
16:12:34 <triliyn> I've heard that defining monads in terms of fmap, return, and join is theoretically pleasing
16:12:34 <SLi> And anything that can be defined by those in some meaningful sense and that obeys the so called monad laws can be thought of as a monad.
16:12:39 <abitlost> and specifically a haskell Functor; category theory functors and ocaml functors and c++ functors aren't the same idea :/
16:12:40 <Ralith> abitlost: and then you send them into space and make a fruit burrito?
16:12:41 <xplat> oh let's not do the monad analogies joke thing again, all the people who get it are sick of it
16:12:43 <Iceland_jack> and absolutely before thinking about monad transformers (and lift)
16:12:45 * dawik googles functor
16:12:48 <mgsloan> One case of jquery wtf is that $.map when applied to arrays is actually concatMap
16:12:53 <abitlost> Ralith: yes, in a toxic waste factory, how did you know? :D
16:13:06 <Ralith> ^^
16:13:09 <dawik> mapping of two sets?
16:13:17 <arkeet> ... no
16:13:26 <arkeet> and also I mean specifically for haskell
16:13:32 * mgsloan thinks that the jquery metaphor of monads could be very helpful for some class of people, just the statement that it /is/ one shouldn't be made
16:13:36 <abitlost> dawik: http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html - search for functor
16:13:36 <Iceland_jack> dawik: Please read through a Haskell tutorial/book (LYAH) without learning things without context
16:13:38 <arkeet> (...a mapping of two sets is a function)
16:13:39 <Iceland_jack> @where lyah
16:13:39 <lambdabot> http://www.learnyouahaskell.com/
16:13:44 <arkeet> yes please read LYAH
16:13:46 <roboguy_> dawik: you should google haskell functors, specifically
16:13:53 <roboguy_> actually yeah read that
16:13:55 <SLi> A monad is quite an abstract thing, which can be used to describe many kind of real-world things which look quite different to the plain eye.
16:14:01 <dawik> good tips. thanks :)
16:14:07 <Iceland_jack> You're welcome dawik
16:14:14 <dawik> i tried it once, and gave up
16:14:22 <dawik> LYAH
16:14:24 <Zetaeta> Might be helpful http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
16:14:25 <jle`> i feel like it isn't even useful to think of monads as a thing on their own; they are just a useful design pattern
16:14:26 <Iceland_jack> Functors mean a lot of different things in a lot of different contexts so simply Googling and reading what they are out of context will do more harm than good
16:14:35 <dawik> but i've since then learned erlang
16:14:50 <SLi> Kind of similar to the algebraic concepts of a group or ring or some such; it's hard to understand what they are, because basically they only exist as a set of laws, but once you get a grasp on what can be treated as a group, it's very useful.
16:14:51 <Iceland_jack> Also if you don't know what (.) is the you should *definitely* familiarize yourself with that before learning about functors and monads
16:14:53 <dawik> which was a lot easier :) and fun too. but i miss compiling
16:14:57 <arkeet> well erlang is quite a different thing.
16:14:59 <aristid> carter: at work i managed to somehow have mathjax so broken that only a reinstall of chrome fixed it :)
16:15:00 <dawik> to machine code.
16:15:12 <carter> aristid: woaaaaah
16:15:21 <carter> you corrupted the fonts?
16:15:22 <arkeet> you should rather miss a type system.
16:15:26 <aristid> carter: no idea
16:15:30 <carter> CDN or local mathjax?
16:15:36 <dawik> Zetaeta: nice!
16:15:50 <carter> aristid: btw, i may spend a bit of tomrorow trying to add kinesis support to your aws packge
16:15:51 <dawik> i like pictures
16:15:52 <aristid> carter: uh i don't know off hand:)
16:16:05 <aristid> carter: what's kinesis?:D
16:16:18 <carter> some sort of streaming datta blog api amazon has
16:16:23 <Iceland_jack> Some people hear about monads/functors and want to learn ‘just those’ to see what all the hubub is about without any foundation in Haskell, those people are going to have a bad time
16:16:25 <carter> also a keyboard i want
16:16:44 <aristid> carter: oh isn't that the thing that's not an actual amazon api but just a java library?
16:16:55 <xplat> arkeet: don't tell people what they should miss, it's rude.  just make zen statements like 'when you understand why you should miss a type system, you will miss a type system more than compiling, grasshopper.'
16:17:00 <carter> aristid: theres a REST api
16:17:05 <aristid> carter: ah good
16:17:09 <arkeet> =(
16:17:10 <Bor0> when I decided to start with haskell I spent some time on lambda calculus theory, this helped me a lot, especially when coming from imperative languages and when it is hard to see how everything can be made of functions
16:17:17 <dawik> Iceland_jack: tell me about it. the compiler can be very confusing
16:17:19 <aristid> carter: well REST apis should fit pretty well within the existing aws package:)
16:17:32 <Iceland_jack> dawik: The compiler is there to help you :) you just need to start small
16:17:38 <dawik> i did some math excercies in haskell, itw orked nice. but when i ran into too much trouble i rewrote them, lol.
16:17:40 <xplat> the 'grasshopper' is essential, it's how people know it's zen
16:17:42 <Iceland_jack> > [1,2,3] -- simple enough!
16:17:43 <lambdabot>  [1,2,3]
16:17:48 <Iceland_jack> > [1,2,3] :: [Int] -- simple still!
16:17:49 <lambdabot>  [1,2,3]
16:17:59 <Iceland_jack> > map show [1,2,3] :: [String] -- ?!
16:18:00 <lambdabot>  ["1","2","3"]
16:18:10 <Iceland_jack> > concatMap show [1,2,3] :: String -- ⁈
16:18:11 <lambdabot>  "123"
16:18:38 <jle`> are we doing haskell koans
16:18:51 <aristid> carter: do you plan to make a new package or would you like to get it into the main package?
16:19:03 <xplat> > [1,2,3] >>= show -- now you're thinking with monads!
16:19:03 <carter> not sure
16:19:04 <lambdabot>  "123"
16:19:10 <carter> its kinda a self contained thing
16:19:12 <Iceland_jack> xplat: ;)
16:19:13 <arkeet> > concat (map Show [1,2,3])
16:19:14 <lambdabot>  Not in scope: data constructor `Show'
16:19:17 <arkeet> doh
16:19:21 <Iceland_jack> d'oh
16:19:32 <aristid> carter: some other packages do that, use the aws main package just to get the core functionality
16:19:38 <Bor0> > foldr ((++).show) "" [1,2,3]
16:19:39 <lambdabot>  "123"
16:19:54 <carter> for the consulting work i have, i actually need node + python bindings
16:20:02 <aristid> carter: maybe at some point i'll split up the package, not sure. recently i've been fairly lazy as a maintainer though
16:20:06 <carter> but i figure I should first write haskell ones so i can focus on understanding hthe api
16:20:13 <Iceland_jack> > fold $ map show [1, 2, 3]
16:20:14 <lambdabot>  "123"
16:20:26 <carter> aristid: i'd be happy to PR it for you
16:20:30 <carter> if that winds up being easy
16:20:42 <Bor0> > foldr (+) 0 [1,2,3]
16:20:43 <lambdabot>  6
16:20:48 <carter> i've enough other larger code bases i'm going to be maintainer of sooon
16:20:49 <carter> sooo
16:20:49 <arkeet> > 6
16:20:51 <lambdabot>  6
16:20:55 <FireFly> Iceland_jack: I see what you did there :p (concatted ?!)
16:21:14 <Iceland_jack> ;)
16:21:32 <aristid> carter: well there's no technical need to split it up, if you just use it as a core you just also get useless modules for s3 and simpledb and such with it ;)
16:21:38 <jle`> > join $ show <$> [1,2,3]
16:21:39 <lambdabot>  "123"
16:21:45 <carter> i like swiss army knives
16:22:23 <dwcook> Can withSocketsDo fail?
16:22:29 <Bor0> > [1,2,3] >>= \x -> show x
16:22:30 <lambdabot>  "123"
16:22:46 <aristid> carter: yes but it can make sense that for example that the guy who maintains the elastic transcoder package actually cares about the api
16:22:57 <xplat> dwcook: your computer may be hit by a toilet seat falling from orbit
16:23:00 <scott_> > do x <- [1,2,3]; show x
16:23:01 <lambdabot>  "123"
16:23:12 <carter> i understand
16:23:19 <carter> let me contextualize: thats fine
16:23:31 <aristid> carter: i'm undecided what the future is though. so just do whatever floats your boat ;)
16:23:31 <carter> i've crazier problems
16:23:35 <dwcook> xplat, as long as I can catch an exception when that happens
16:23:42 <carter> like, touching node.js
16:23:43 <johnw> > show <$> [1,2,3]
16:23:44 <lambdabot>  ["1","2","3"]
16:23:50 <arkeet> dwcook: you'll probably want to catch something a bit larger
16:23:53 <xplat> dwcook: not on the same computer you can't
16:23:54 <jle`> so close
16:24:08 <Iceland_jack> How to keep #haskell preoccupied: Post trivial code and get 200 variations of it
16:24:15 <Bor0> > filter (/= ',') $ filter (/= ']') $ filter (/= '[') $ show [1,2,3]
16:24:16 <lambdabot>  "123"
16:24:18 <rdevilla> Would Haskell be a good language to prototype a simple go-like board game?
16:24:21 <dawik> > [ a | a <- [1..3] ]
16:24:22 <lambdabot>  [1,2,3]
16:24:24 <aristid> carter: there are worse things to do for money than node.js :P
16:24:32 <arkeet> > filter (`notElem` "[,]) $ show [1,2,3]
16:24:33 <lambdabot>  <hint>:1:39:
16:24:33 <lambdabot>      lexical error in string/character literal at end of input
16:24:34 <arkeet> > filter (`notElem` "[,]") $ show [1,2,3]
16:24:35 <carter> true
16:24:35 <lambdabot>  "123"
16:24:41 <Bor0> notElem! neat
16:24:50 <nocturne777> node is a callback hell
16:24:58 <jle`> > map (head . show) [1,2,3]
16:25:00 <lambdabot>  "123"
16:25:07 <SLi> Ok, a question about monad transformers: Say I have a foo :: WriterT [String] Get () (where Get is the Get monad from Data.Binary.Get). How do I runGet it? (runGet :: Get a -> ByteString -> a.) lift runGet foo?
16:25:18 <carter> aristid: what can I say, i don't like having an eventful life
16:25:22 <arkeet> > const "123" [1,2,3]
16:25:23 <lambdabot>  "123"
16:25:36 <Ralith> heh
16:25:40 <jle`> lol
16:25:44 <Bor0> > filter (\x -> x /= ',' && x /= '[' && x /= ']') $ show [1,2,3] -- even better than previous
16:25:45 <lambdabot>  "123"
16:25:49 <SLi> ("bar = lift runGet foo" in fact causes the impossible to happen for me.)
16:25:53 <dawik> > "123"
16:25:54 <lambdabot>  "123"
16:25:55 <xplat> rdevilla: haskell would be good for the game logic, you might end up spending excessive effort on the interface compared to some languages that have more specialized toolkits for that kind of thing though
16:25:58 <Iceland_jack> dawik wins
16:26:05 <Bor0> > seq [1,2,3] "123"
16:26:06 <lambdabot>  "123"
16:26:12 <arkeet> > filter (\x -> all (/= x) ",[]") $ show [1,2,3]
16:26:13 <lambdabot>  "123"
16:26:25 <xplat> > ['1'..'3']
16:26:26 <lambdabot>  "123"
16:26:53 <SLi> I like some of the errors I got when playing with pipes
16:26:58 * hackagebot haskoin-crypto 0.0.1 - Implementation of Bitcoin cryptographic primitives.  http://hackage.haskell.org/package/haskoin-crypto-0.0.1 (PhilippeLaprade)
16:27:01 <Bor0> > [ x | x <- take 3 ['1'..] ]
16:27:02 <lambdabot>  "123"
16:27:28 <Bor0> > take 3 ['1'..]
16:27:29 <lambdabot>  "123"
16:27:36 <SLi> Like: Couldn't match type `Proxy () B.ByteString () String IO ()' with `a0 -> Proxy x'0 x0 b'0 b0 m0 a'0'
16:27:38 <arkeet> > show . foldl' (\a -> (10*a+)) 0 $ [1,2,3]
16:27:39 <lambdabot>  "123"
16:27:42 <jle`> > filter (\x -> x >= '1' && x < '4') [minBound..maxBound]
16:27:43 <lambdabot>  "123"
16:28:21 <arkeet> > show . foldl1 (\a -> (10*a+)) $ [1,2,3]
16:28:22 <lambdabot>  "123"
16:28:35 * Iceland_jack sighs
16:28:39 <arkeet> =(
16:28:49 <Bor0> > reverse $ reverse "123"
16:28:50 <lambdabot>  "123"
16:28:53 <xplat> > [1,2,3] & each %~ show
16:28:55 <lambdabot>  ["1","2","3"]
16:28:59 <pavonia> > map intToDigit [1,2,3]
16:29:01 <lambdabot>  "123"
16:29:08 <xplat> > [1,2,3] & each %~ intToDigit
16:29:09 <lambdabot>  "123"
16:29:26 <arkeet> > [1,2,3] ^.. each . to intToDigit
16:29:27 <lambdabot>  "123"
16:29:55 <Bor0> > (\(x,y,z) -> show x ++ show y ++ show z) (1,2,3)
16:29:56 <lambdabot>  "123"
16:30:00 <jle`> > map (chr . (+) (ord '0')) [1,2,3]
16:30:02 <lambdabot>  "123"
16:30:11 <arkeet> > map (chr.(+48)) [1,2,3]
16:30:12 <lambdabot>  "123"
16:30:14 <xplat> > [1,2,3] ^.. each . to show . each
16:30:16 <lambdabot>  "123"
16:30:22 <arkeet> xplat: :)
16:30:28 <jle`> darn lenses
16:30:45 <rdevilla> all this haskell hackery
16:31:03 <dawik> diverse language
16:31:16 <dawik> or should i say syntax
16:31:19 <jle`> if only haskell implicitly casted chars to bytes like C huh.
16:31:20 <xplat> timtowtdi
16:31:26 <arkeet> it's far more than just syntax.
16:31:27 <arkeet> :p
16:31:47 <jle`> dawik: most of it is functions, there is very little syntax going on :)
16:31:59 <jle`> :t (%~)
16:32:00 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
16:32:11 <haasn> xplat: re _Show
16:32:26 <haasn> come to think of it, “to show” is simpler and more general than that
16:32:38 <arkeet> but can you read with to show?
16:32:54 <haasn> if it's a prism used for reading, why is it called _Show and not _Read? ;)
16:33:05 <arkeet> because it can show.
16:33:12 <haasn> :t let _Read = _Show; un = re in un _Read
16:33:13 <lambdabot> Not in scope: `_Show'
16:33:48 <jle`> i wonder what does ghci automatically import
16:34:37 <xplat> > show $ 41 * 3
16:34:38 <lambdabot>  "123"
16:34:46 <arkeet> no no
16:34:48 <arkeet> > show $ 41 * length [1,2,3]
16:34:49 <lambdabot>  "123"
16:34:58 <carter> aristid: good idea about pdfs and latex
16:35:01 <xplat> ah, you're right of course
16:35:20 <jle`> > map (head . show . length) $ inits [1,2,3]
16:35:21 <lambdabot>  "0123"
16:35:23 <jle`> darn
16:35:24 <aristid> carter: well pdfs do create a bit of a barrier to light web reading
16:35:28 <carter> jah
16:35:30 <carter> hence pandoc?
16:35:36 <arkeet> jle`: you ruined the combo =(
16:35:37 <SLi> Hmm, if I have a monad (transformer) stack, does the order of the transformers matter? Do I always have to "run" the outmost first (for monads which support running them)?
16:35:42 <aristid> carter: in many browsers they download, or the browsers' integrated viewers can be crummy
16:35:46 <arkeet> SLi: yes!
16:35:48 <carter> yah
16:35:59 <SLi> arkeet: Ah. Now I'm starting to figure this out :)
16:36:11 <Bor0> > show $ 41 * length (read $ show ['l', 'o', 'l'] :: [Int])
16:36:12 <lambdabot>  "*Exception: Prelude.read: no parse
16:36:18 <Bor0> > show $ 41 * length (read $ show ['l', 'o', 'l'] :: [Char])
16:36:19 <lambdabot>  "123"
16:36:30 <arkeet> StateT s (ReaderT r m) and ReaderT r (StateT s m) are very different.
16:36:34 <xplat> SLi: you can run some stacks in any order if you use mmorph, but only very special ones
16:36:39 <arkeet> for example.
16:36:44 <SLi> Unfortunately I think that also means I'm out of luck since there's no Data.Binary.GetT...
16:37:10 <arkeet> hm?
16:37:13 <SLi> As I'd like to do binary parsing (in Get monad) with logging (using Writer monad).
16:37:19 <arkeet> you can do that.
16:37:31 <xplat> you can run the Writer first
16:37:41 <SLi> Hmm, true.
16:37:42 <rdevilla> Bor0: hahahah
16:38:29 <jle`> > map (head . show . head) $ init . tails $ [1,2,3]
16:38:30 <lambdabot>  "123"
16:38:38 <SLi> Though I'm still not sure how to do that :) If I have a foo :: WriterT [String] Get (), how do I run it? Simply runWriter foo doesn't do the trick. Something with lift?
16:38:47 <arkeet> runWriterT
16:38:49 <arkeet> :t runWriterT
16:38:50 <lambdabot> WriterT w m a -> m (a, w)
16:38:51 <SLi> Ah!
16:38:55 <SLi> Excellent :) Thank you.
16:39:13 <SLi> Didn't realize the transformers have different run functions (of course they do, now that I think).
16:39:15 <Iceland_jack> > execWriter (mapM (tell . show) [1,2,3])
16:39:16 <lambdabot>  "123"
16:39:25 <xplat> Tea makes everyone get along better
16:39:40 <arkeet> thanks Iceland_jack :)
16:39:51 <Iceland_jack> Writers!
16:39:53 <SLi> Also didn't help that "lift runWriter foo" hit a compiler bug :)
16:40:50 <SLi> So, *inside* the transformer stack I can just lift things automagically to the right MonadTrans, but outside of it I still need to unwrap the thing in the correct order.
16:41:47 <xplat> > mconcat . map show $ [1,2,3]
16:41:48 <lambdabot>  "123"
16:42:15 <xplat> SLi: yeah
16:42:46 <jle`> flip execState "" $ mapM_ (modify . flip (++) . show) [1,2,3]
16:42:50 <jle`> > flip execState "" $ mapM_ (modify . flip (++) . show) [1,2,3]
16:42:51 <lambdabot>  "123"
16:42:58 <rdevilla> wat
16:43:05 <rdevilla> O.o
16:43:16 <jle`> > flip execState mempty $ mapM_ (modify . flip (++) . show) [1,2,3]
16:43:18 <lambdabot>  "123"
16:43:23 <jle`> just a little cleaner
16:43:44 <nooodl> > fromJust $ find ((>=3) . length) $ map show $ fix (scanl (+) 2 . (-1:))
16:43:45 <lambdabot>  "123"
16:46:04 <Bor0> > show $ (*) ([1,3..] !! 20) $ length $ filter (=='e') "huehuehue"
16:46:05 <lambdabot>  "123"
16:47:37 <jle`> > do { a <- [minBound..maxBound]; b <- [minBound..maxBound]; c <- [minBound..maxBound]; guard ([a,b,c] == "123"); return [a,b,c] }
16:47:41 <lambdabot>  mueval-core: Time limit exceeded
16:47:43 <jle`> :(
16:48:41 <xplat> remember Char is unicode ...
16:52:02 <Peaker_> > fromEnum (maxBound :: Char) - fromEnum (minBound :: Char)
16:52:03 <lambdabot>  1114111
16:52:08 <dmwit> > filter (==('1','2','3')) U.universe
16:52:09 <lambdabot>  Not in scope: `U.universe'
16:52:13 <dmwit> aww
16:52:43 <volko> Anyone here use accelerate?
16:52:46 <Peaker> Is the size of Char a palindrome of any significance? :)
16:52:51 <volko> What happened to PairArrays?
16:53:11 <dmwit> Peaker: Nah, it's a palindrome of coincidence.
16:53:18 <dmwit> > 0x10ffffff
16:53:19 <lambdabot>  285212671
16:53:25 <dmwit> > 0x10ffff
16:53:26 <lambdabot>  1114111
16:53:50 <shachaf> Nothing in base 10 is significant.
16:54:18 <xplat> > show $ liftA2 (+) (intFromDigits . reverse . tail) (head . show) [1,2,3]
16:54:19 <lambdabot>  Not in scope: `intFromDigits'
16:54:30 <xplat> > show $ liftA2 (+) (digitsToInt . reverse . tail) (head . show) [1,2,3]
16:54:31 <lambdabot>  Not in scope: `digitsToInt'
16:54:31 <lambdabot>  Perhaps you meant `digitToInt' (imported from Data.Char)
16:54:50 <dmwit> It takes my computer 7.3 seconds to reach ('1','2','3').
16:55:08 <dmwit> So probably going to be hard to fit in \bot's... 1-second? timeout.
16:55:22 <xplat> > show $ liftA2 (+) (read . map intToDigit . reverse . tail) (head . show) [1,2,3]
16:55:24 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
16:55:24 <lambdabot>    arising from a use of `GHC.Num.+'
16:55:24 <lambdabot>  Possible fix:
16:55:24 <lambdabot>    add an instance declaration for (GHC.Num.Num GHC.Types.Char)
16:55:44 <xplat> > show $ liftA2 (+) (read . map intToDigit . reverse . tail) (ord . head . show) [1,2,3]
16:55:46 <lambdabot>  "123"
16:55:50 <xplat> ...whew
16:55:59 <jle`> let r = ['0'..'9'] in do { a <- r; b <- r; c <- r; guard ([a,b,c] == "123"); return [a,b,c] }
16:56:01 <jle`> > let r = ['0'..'9'] in do { a <- r; b <- r; c <- r; guard ([a,b,c] == "123"); return [a,b,c] }
16:56:02 <lambdabot>  ["123"]
16:56:13 <dmwit> > ord '['
16:56:14 <lambdabot>  91
16:56:36 <dmwit> xplat: neat!
16:57:15 <simpson> > let qf a b c = let disc = b * b - 4 * a * c in ((b - sqrt disc) / (2 * a), ((b + sqrt disc) / (2 * a))); prod (a, b) = a * b; in show . prod $ over both floor $ qf 1 44 123 -- I need to get out more
16:57:18 <lambdabot>  "123"
16:58:11 <xplat> simpson: lol
16:58:29 <xplat> simpson: yours is much easier to adjust for other outputs
16:58:48 <simpson> Also it has a simple and easy-to-understand construction.
16:59:15 <xplat> heh, actually, if you know enough algebra ... :)
16:59:17 <simpson> > let qf a b c = let disc = b * b - 4 * a * c in ((b - sqrt disc) / (2 * a), ((b + sqrt disc) / (2 * a))); prod (a, b) = a * b; in show . prod $ over both floor $ qf 1 45 124 -- I need to get out more
16:59:19 <lambdabot>  "84"
17:00:00 <xplat> simpson: floor bites you there
17:00:08 <simpson> Yep.
17:00:25 <simpson> > let qf a b c = let disc = b * b - 4 * a * c in ((b - sqrt disc) / (2 * a), ((b + sqrt disc) / (2 * a))); prod (a, b) = a * b; in show . prod $ over both floor $ qf 1 35 124 -- Fat-fingering
17:00:27 <lambdabot>  "124"
17:01:10 <Luke> Anyone know how to get Shake importing correctly in emacs + ghc-mod? for some reason ghc-mod can't seem to find Development.Shake
17:01:20 <jle`> > do { x <- [1..3]; y <- ['1'..'3']; guard (digitToInt y == x); return y }
17:01:21 <lambdabot>  "123"
17:01:45 <dmwit> Luke: Huh. But e.g. ghci can find Development.Shake?
17:01:51 <Luke> dmwit: yes
17:01:55 <dmwit> Are you in a sandbox?
17:02:03 <Luke> let me check - i can't remember ;-)
17:02:35 <Luke> no i'm not sanboxed
17:02:43 <xplat> do you feel sand on the back of your legs?  and maybe the occasional cat poop?
17:03:11 <dmwit> Okay. I don't know anything about emacs or ghc-mod, really.
17:03:17 <dmwit> But what does ghc-pkg list shake say?
17:03:37 <dmwit> The other debugging thing I throw at every package problem is "ghc-pkg check".
17:04:25 <Luke> lots of stuff - parsing the output
17:05:17 <Luke> some problems w/ snap stuff but not w/ shake
17:05:25 <scott_> I come back after making supper, #haskell is still doing "123"
17:06:48 <Iceland_jack> scott_: Real-world applications!
17:07:48 <Luke> dmwit: shake-0.10.10 looks like it's installed just fine
17:08:10 <Luke> dmwit: something weird is going on though as ghc-mod + emacs can find and flymake every other package I have installed
17:08:25 <roboguy_> > (fmap (:[]) (over reversed ((3-) <$>) [2,1,0])) ^.. folding (mconcat . map show . mconcat)
17:08:27 <lambdabot>  "123"
17:08:31 <roboguy_> (since I didn't see any lens stuff yet)
17:09:12 <xplat> roboguy_: you weren't paying attention, there were at least 4 or 5 with lenses including the quadratic formula one
17:09:15 <joelteon> ['1'..'3']
17:09:18 <joelteon> > ['1'..'3']
17:09:20 <lambdabot>  "123"
17:09:23 <joelteon> mine is the best one
17:09:24 <roboguy_> xplat: oh, missed those
17:09:27 <xplat> roboguy_: but yours is still neat
17:09:32 <SLi> Is there a way to silence a warning for one use of a deprecated function? Data.Binary.Get.remaining (get num of remaining bytes) warns 'Deprecated: "This will force all remaining input, don't use it."', but I actually need the number of bytes in the input to decide how to parse it...
17:09:35 <scott_> > "123"
17:09:36 <lambdabot>  "123"
17:09:49 <SLi> (And thus I don't care about it being forced)
17:09:50 <scott_> Qed
17:09:52 <roboguy_> xplat: thanks. I think "123" wins though
17:09:56 <rdevilla> > reverse "321"
17:09:57 <lambdabot>  "123"
17:09:58 <rdevilla> woo
17:10:28 <ahill-89> Has anyone Church-encoded it yet? I've only been glancing occasionally.
17:10:46 <xplat> ahill-89: nope, that would be all yours
17:11:48 <jle`> looks like he couldn't handle it
17:11:48 <joelteon> > foldl (flip (:)) "321"
17:11:49 <lambdabot>  <[Char] -> [Char]>
17:11:54 <xplat> SLi: do you actually need the *number* of bytes, or do you just need to know if it's greater than a small number?
17:11:59 <joelteon> > foldl (flip (:)) [] "321"
17:12:00 <lambdabot>  "123"
17:12:47 <jle`> intToDigit looks very useful
17:12:54 <jle`> > map intToDigit [1,2,3]
17:12:55 <lambdabot>  "123"
17:13:10 <SLi> xplat: Well, actually I'd prefer to have the number of bytes, if only to output it to stdout. I don't think I definitely *need* it to parse the binary, but it helps though (and laziness is not going to help too much because the format inherently requires some seeking, as in the header tells there's some data in offset 0x1452...)
17:13:54 <xplat> SLi: ah, so it's kind of TIFF-esque?  i don't think that's the kind of binary format binary was designed for
17:14:01 <SLi> Yeah, might be.
17:14:26 <Bor0> > filter (/= '"') $ dropWhile (/= '"') "<lambdabot>  \"123\""
17:14:27 <lambdabot>  "123"
17:14:45 <Bor0> > filter (/= '"') $ dropWhile (/= '"') "<lambdabot>  \"I love Haskell\""
17:14:46 <lambdabot>  "I love Haskell"
17:15:16 <external-reality> Why does this return `Nothing` in aeson `decodeStrict' "[1,2]" :: Maybe [Integer]` when `decode` returns `Just [1,2]`
17:16:09 <SLi> xplat: Maybe I'll opt for a hybrid approach, as in only work in the Get monad once I'm deep enough into the input that I don't need to seek anymore.
17:17:08 <Bor0> > let sayIt x = filter (/= '"') $ dropWhile (/= '"') x in sayIt "<lambdabot> \"I say whatever you tell me to\""
17:17:09 <lambdabot>  "I say whatever you tell me to"
17:17:16 <external-reality> The documentation doesn't seem to offer an explanation or if it does I'm missing it.
17:17:44 <jophish_> I think I'm going to have to write a new OpenGL wrapper, because none of the current ones really cut it
17:19:15 <pavonia> external-reality: Where does decodeStrict come from?
17:19:59 <external-reality> pavonia: It comes from Data.Aeson
17:20:43 <pavonia> Ah, I was looking at an outdated version
17:21:13 <darthdeus> hey guys, i'm having trouble with the 2. exercise here http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing about supporting R5RS compliant strings (for example "hello\"world")
17:21:34 <darthdeus> i've got this http://lpaste.net/5861675828328267776 but it only matches on "hello\""
17:23:01 <meretrix> If I have a type "data Data = X | Y | Z deriving (Read)" and I am parsing millions of bytestrings with "d <- getIO >>= read :: IO Data", is Haskell smart enough to cache values? Or do I need to manually write "fastRead :: ByteString -> Data; fastRead "X" = X ..."?
17:23:28 <jmcarthur> jophish_: yeah guess what i'm doing right now
17:23:53 <jle`> darthdeus: you are going to parse either the string \" or many non- "\ 's
17:24:09 <jophish_> jmcarthur: What plans do you have?
17:24:09 <jle`> hello\"world is neither of those
17:24:30 <darthdeus> jle`: i thoguht it would kinda keep eating the input until it doesn't match anymore
17:24:41 <jophish_> I  think I'd like something like llvm-general
17:24:57 <jophish_> or even just opengl-raw with a little more type safety
17:25:03 <jle`> darthdeus: you should think of monadic parsers like grammar specifications
17:25:10 <jle`> if...that makes sense
17:25:28 <darthdeus> not really, i'm new to the whole parser thingy
17:25:35 <jmcarthur> jophish_: well, i'm working on a stack of libraries, actually. i've gradually been going to lower and lower levels, as i got more frustrated with the opengl api. right now i'm at a pretty low level of abstraction.
17:25:43 <jle`> there really is nothing being "done", you are specifying what a String should "look like"
17:25:47 <jle`> right now you are saying
17:26:20 <jle`> a string should look like: (a char '"') followed by (either the string \" or many non- \"'s) followed by (a char '"')
17:26:38 <jle`> it's not really quite imperative
17:26:38 <darthdeus> oh okay i see the problem now
17:26:54 <jophish_> jmcarthur: I've done it a couple of times for C++, I've always found that a solution which exposes every feature of GL will be horrible
17:27:08 <darthdeus> i thought it reads "either string \" or many non \" until neither of those holds"
17:27:13 <jmcarthur> jophish_: the goal for this particular one is to allow you to retain quite a bit of control over memory layout and data transfers without actually having to micromanage so much. i'm shooting for a pretty type safe library, but there are escape holes. i'm trying not to interfere with other opengl code. there might be a shader DSL.
17:27:22 <darthdeus> so i need to write it with the `many` in front of the whole <|>
17:27:33 <jmcarthur> jophish_: yeah, i have also done this a few times
17:27:42 <jophish_> jmcarthur: I'm writing a haskell syntax language which will compile to glsl
17:27:43 <jmcarthur> jophish_: and come to the same conclusion
17:27:45 <jophish_> via llvm
17:27:49 <jmcarthur> ah nice
17:28:03 <jle`> that's one way to do it i think; i don't know exactly which parser library you are using
17:28:07 <darthdeus> the problem is that i can't do this ... many (string "\\\"" <|> noneOf "\"") .... since `string` has different type
17:28:08 <darthdeus> Parsec
17:28:11 <jophish_> haskell to llvm IR, and then a llvm backend to glsl
17:28:51 <jle`> darthdeus: try starting from the beginning
17:29:02 <jle`> and thinking about what counts as a valid character in 'String'
17:29:19 <jle`> instead of trying to think about teh parser acting imperatively
17:29:20 <bernalex> hm. anyone in here interested in programming language characteristics nomenclature? I have a paper due tomorrow, so if anyone wants to have a look to give feedback, that would be cool.
17:29:40 <jle`> actually
17:29:48 <jle`> i take that back
17:30:07 <jle`> forgot that \" was two chars
17:30:13 <darthdeus> i dont think it's imperative, the problem is that i have a parser that works for String and another that works on Char
17:30:17 <darthdeus> yeah
17:30:22 <bernalex> it's basically on why some characteristics have no real formal definitions (and if they do they suck). the definitions it talks about are that of higher-order functions, functions as first class citizens and purely functional languages. due to the latter it naturally becomes a bit haskell-centric.
17:30:26 <jmcarthur> jophish_: i'm going for something that one might describe as a slightly more low level and much more efficient gpipe, at the moment.
17:30:30 <jle`> can you coerce a char parser into a string parser
17:30:35 <bernalex> also I recently had spj read one of my papers, so I don't want to bug him again so soon. ;-)
17:30:43 <jmcarthur> jophish_: low level enough that it still looks like opengl, i guess
17:31:14 <jophish_> jmcarthur: I'd really like to see that. I couldn't quite get behind gpipe and lambdacube, they seem to hide some functionality
17:31:20 <darthdeus> jle`: if i do something like liftM (:[]) on the char parser i'll end up with [String], because ie need to repeat those with `many` ... which means i also need to liftM concat :\
17:31:31 <jmcarthur> jophish_: well, i'm going to hide *some* functionality, but less than they do
17:31:37 <jophish_> i.e. there are things one can do writing glsl directly which would be impossible with them
17:31:54 <darthdeus>                  x <- liftM concat $ many (string "\\\"" <|> liftM (:[]) (noneOf "\""))
17:31:55 <jmcarthur> jophish_: and, again, should not interfere with other opengl code
17:31:56 <darthdeus> this really does owrk, hmm
17:32:30 <jle`> you can use sepBy1
17:32:37 <jophish_> I suppose all these things target different people. My language is not going to require Haskell as a host language, and just be a drop in replacement for glsl.
17:32:52 <jophish_> I imagine lots of people find gpipe really useful
17:33:02 <jmcarthur> eh, gpipe has too many flaws to be really useful, i think
17:33:33 <jle`> or you can use (count 1) to turn a char parser into a string parser
17:34:19 <darthdeus> hmm that would be probably smarter than what i have
17:34:49 <jophish_> jmcarthur: do you think something like this would work. A pure interface to OpenGL, and a function: executeCommands :: [GLCommand] -> IO ()
17:35:05 <jophish_> Along the lines of llvm-general
17:35:09 <jle`> i could have sworn there was a convenient alias for count 1
17:35:25 <jle`> well
17:35:33 <jophish_> which has a pure way of building Modules, and a few functions in the IO monad to send the pure representations to the c++ llvm library
17:35:39 <jle`> you could always do show <$>
17:36:38 <jle`> but also remember noneOf doesn't do what you think it does
17:36:39 <jmcarthur> jophish_: i think it would work, but i think that approach actually says very little about the API except that it produces inspectable syntax trees, for better or for worse
17:36:57 <jle`> er, unless i misunderstand
17:37:05 <jle`> actually yeah nvm
17:37:12 <jle`> that makes sense
17:37:18 <jle`> sorry
17:38:00 <jle`> but yeah show <$> will turn any char parser into a string parser for that one char, although it is slightly inelegant
17:38:24 <dawik> > concat (map (\x -> show x) (take 3 [1..]))
17:38:25 <lambdabot>  "123"
17:38:43 <johnw> > concatMap show $ take 3 [1..]
17:38:45 <lambdabot>  "123"
17:38:48 <quchen> > take 3 [1..] >>= show
17:38:49 <lambdabot>  "123"
17:38:59 <jle`> dawik: remember that (\x -> show x) is just show
17:39:05 <johnw> quchen: good show
17:39:08 <jle`> :t (\x -> show x)
17:39:09 <lambdabot> Show a => a -> String
17:39:11 <jle`> :t show
17:39:12 <lambdabot> Show a => a -> String
17:39:20 <jophish_> jmcarthur: On further thought, that interface is exactly OpenGLRaw, with executeCommands == sequence_!
17:39:26 <jmcarthur> yup
17:39:44 <jmcarthur> jophish_: a bit more limited actually, since it doesn't provide a way to get any values from a command'
17:40:19 <jophish_> It's not /too/ often that one does that
17:40:23 <jophish_> or that one needs to do that
17:40:43 <jophish_> for example, filling a buffer with data requires one to get a pointer after mapping the buffer
17:40:51 <jophish_> but that could all be hidden
17:40:53 <jle`> @pl (\x -> show x)
17:40:53 <lambdabot> show
17:40:58 <quchen> jle`: No, `show <$> parser` will not create a parser of that one char in String form: show 'c' evaluates to "'c'". So the parser will parse the one char and return that char in single quotes.
17:41:02 <quchen> > show 'c'
17:41:03 <lambdabot>  "'c'"
17:41:12 <jle`> really?
17:41:15 <jle`> darn
17:41:18 <jle`> > show '4'
17:41:19 <lambdabot>  "'4'"
17:41:21 <jmcarthur> jophish_: creating objects requires that, although the C api hides that fact by having you pass mutable parameters instead
17:41:30 <jle`> sorry, my bad
17:41:36 <quchen> jle`: Use "(:[]) <$>" instead
17:41:37 <jle`> try return
17:41:38 <jophish_> I guess that all the OpenGL constants would be collected at the start and exposed in a pure way
17:41:41 <quchen> ROBOT MONKEY OPERATOR!
17:41:47 <jle`> haha
17:41:50 <jophish_> or since the C functions are pure they could be unsafePerformIO
17:41:56 <Iceland_jack> quchen: That's redundant, all monkeys are robotic
17:42:12 <jle`> > return '4' :: String
17:42:13 <lambdabot>  "4"
17:42:15 <quchen> Iceland_jack: But neither all monkeys nor all robots are operators.
17:42:17 <jle`> okay all order is restored.
17:42:38 <Iceland_jack> {{citation needed}}
17:42:44 <jophish_> jmcarthur: good point, what's a nice way of creating objects then
17:42:45 <jmcarthur> jophish_: if you care about performance, the order than you allocate resources like that can be important, since it affects the memory layout in VRAM
17:42:57 <jmcarthur> jophish_: some i would discourage unsafePerformIO for that
17:43:00 <jmcarthur> *so i
17:43:08 <jle`> do people actually use (:[])
17:43:11 <quchen> No.
17:43:14 <jle`> it looks kind of cool admittedly
17:43:21 <arkeet> @quote (:[
17:43:21 <lambdabot> Plugin `quote' failed with: user error (parseRegex for Text.Regex.TDFA.String failed:"(:[" (line 1, column 4):
17:43:21 <lambdabot> unexpected end of input
17:43:21 <lambdabot> expecting "^", "]", "-" or Failed to parse bracketed string)
17:43:22 <quchen> It's List's `return`.
17:43:23 <arkeet> hm
17:43:24 <Iceland_jack> \x -> [x] is perfectly clear
17:43:29 <arkeet> @quote \(:\[
17:43:29 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
17:43:31 <jmcarthur> jophish_: it really depends on how low level your API will be
17:43:41 <jle`> on my ocaml final i was tempted to litter all my code with (*_*)
17:43:44 <jophish_> oh sure, unsafePerformIO for creating resources isn't great
17:44:00 <jophish_> but for gl get max uniform buffers or something it should be fine
17:44:05 <quchen> {-:> Merry Christmas <:-}
17:44:35 <jmcarthur> jophish_: for a high level enough API you shouldn't even have to care about stuff like that. if it's low level, you will probably want at least an Applicative style API, so you can get results, instead of a Monoid style API like the one you suggestion (the list making it a free monoid, that is)
17:44:40 <jmcarthur> *suggested
17:44:42 <jle`> people should be using (:mempty "how are you today?")
17:44:45 <jle`> to be polite.
17:44:52 <jle`> > (:mempty "how are you today?") 4
17:44:53 <lambdabot>  [4]
17:44:54 <arkeet> haha
17:45:03 <jmcarthur> jophish_: and really, you'll end up wanting it monadic, so it will basically look like IO
17:45:21 <Iceland_jack> :t (:mempty "how are you today?")
17:45:22 <lambdabot> a -> [a]
17:45:22 <jmcarthur> jophish_: this is the problem with trying to retain as much generality as possible
17:45:40 <Peaker> hmm.. when using GLFW-b, setting a window callback that raises an IO exception via "fail" seems to cause a shutdown of all things (GHC RTS) from some non-main thread. Such that a "bracket" on the main thread doesn't get its cleanup called
17:45:43 <jophish_> jmcarthur: why wouldn't applicative work?
17:45:56 <arkeet> Iceland_jack: (r -> [a]) is a monoid, with mempty = const mempty = const []
17:46:04 <Iceland_jack> I'm aware :)
17:46:07 <arkeet> ok
17:46:09 <jmcarthur> jophish_: create some object, bind it later, ah crap, now i need a monad
17:46:12 <Iceland_jack> seems like Clojure
17:46:31 <jmcarthur> jophish_: because the action depends on the value result of a previous action
17:46:33 <jophish_> hmm, could it be done in phases perhaps, create; use-pure
17:47:08 <Peaker> which is weird, because I can't find anything like that in the GLFW-b or bindings-GLFW packages
17:47:11 <jophish_> I guess that's quite a lot of generality lost there
17:48:16 <jophish_> I wonder if it's possible to write a really performant engine in Haskell
17:48:24 <jmcarthur> Peaker: come to think of it, i don't know what is supposed to happen when a haskell callback called from C land raises an exception
17:48:42 <jmcarthur> jophish_: i'm trying to do that :)
17:48:56 <Peaker> jmcarthur: I'm not entirely sure threads are actually involved (just a guess), will try to verify it now
17:49:14 <jmcarthur> jophish_: i've written fairly performance sprite engines in haskell before. not that i can remember any numbers right now...
17:49:21 <jmcarthur> ket's se
17:49:23 <jmcarthur> oops
17:49:31 <jmcarthur> let's see if it still builds and i'll measure it
17:49:58 <Peaker> yeah, main thread id 40, cb thread id 41
17:50:47 <jophish_> I maintain an engine for XB1 and PS4 for a living in C++, it's great fun shaving off a few hundred microseconds here and there. I've only been using Haskell regularly for a few months, but I can't really imagine getting that kind of experience in Haskell
17:53:01 <external-reality> Why does this return `Nothing` in aeson `decodeStrict' "[1,2]" :: Maybe [Integer]` when `decode` returns `Just [1,2]`
17:53:05 <SLi> I wonder if there's a function doing what I just wrote a function for. type LoggingT m a = WriterT [Text] m a; runGetBase :: Monad m => LoggingT Get a -> ByteString -> LoggingT m a.
17:53:12 <external-reality> thought i'd ask one more time :-)
17:53:24 <jophish_> If that's not possible in this language, I suppose that a nice clean interface would the the priority
17:54:01 <Peaker> jophish_: I'm also working on high-performance code (in C), and I don't see GC as a good trade-off in that arena at all, ruling out Haskell and many other languages
17:54:01 <SLi> Basically it is a Writer-monadic action that runs a Get monad inside a Writer monad, telling the output of its parameter and returning what the Get monad returned.
17:54:36 <SLi> runGetBase f bs = let (val, w) = runGet (runWriterT f) bs in tell w >> return val
17:55:21 <Twey> Using glfw-b, how do I handle scroll events?  I can't check whether the mouse button 4 is down in my event loop because it's only down for a moment.
17:55:40 <jmcarthur> jophish_: my last sprite engine in haskell pushed around 700k sprites/second, each with individual affine transformations in each frame and alpha channels. but it wasn't written very intelligently, so i think i could do a lot better.
17:55:52 <dwcook> external-reality, what type are you giving the one you're using decode for?
17:56:02 <Peaker> Twey: isn't there a callback?
17:56:24 <Peaker> Twey: http://hackage.haskell.org/package/GLFW-b-1.4.3/docs/Graphics-UI-GLFW.html#v:setMouseButtonCallback ?
17:56:26 <jmcarthur> jophish_: that number is in a benchmark that was fairly minimal, but not totally trivial, as there were unique transformations for each sprite calculated in each frame, and they were stacked on each other so that the alpha would hurt as much as possible
17:56:30 <jophish_> I think I'd like a language like c++ with no side effects and type inference
17:56:44 <Twey> Peaker: I have a rendering loop
17:56:46 <jophish_> jmcarthur: was it cpu bound?
17:56:57 <Peaker> jophish_: I am not sure whether purity works well within a manual-mm language
17:57:15 <jophish_> Peaker: yeah, I don't think that such a language can really exist
17:57:16 <Twey> Peaker: Is there some way to get information out of a callback without sticking IORefs everywhere?
17:57:25 <jmcarthur> jophish_: 95% cpu bound
17:57:31 <jmcarthur> or, well
17:57:33 <jmcarthur> not bound
17:57:37 <carter> careful ghc code is pretty darn good
17:57:38 <jmcarthur> used 95% of cpu
17:57:48 <jmcarthur> that may or may not be the bound
17:57:50 <Peaker> Twey: I don't think so, but what everybody does is a small IORef framework to pass the callbacks to the main loop once -- and then everything is cleaner afterwards
17:58:06 <jle`> if anyone has time to spare on a lazy saturday, does anyone mind tearing apart my MonadPlus tutorial: http://blog.jle.im/id/11 --- i'm probably not going to post to reddit again, i was a little embarrassed that it got attention last time and cluttered up the front page ><
17:58:10 <jmcarthur> let me build with llvm backend and see if it's faster
17:58:17 <jle`> (part 2)
17:58:26 <Twey> Peaker: Mh.  =(
17:58:31 <jophish_> jle`: 404
17:58:32 <Peaker> Twey: I have an IORef with a list of events (mailbox) that I prepend to in callbacks, and the mainloop empties the mailbox (reversing it) and then it has a pure list of events
17:58:40 <Peaker> Twey: which means I define an ADT of possible callbacks I care about
17:58:46 <jle`> http://blog.jle.im/entry/id/11
17:58:52 <Peaker> Twey: it's low-level code you write once for your main loop, it's not that bad
17:58:53 <jle`> that's what i get for hand typing url's
17:58:54 <Twey> It's frustrating because this structure already exists inside GLFW
17:59:08 <Peaker> Twey: the C version, you mean?
17:59:21 <Twey> Aye
17:59:25 <Peaker> Twey: does it use poling of events, and not CBs?
17:59:26 <jmcarthur> no gain from llvm whatsoever
17:59:41 <Twey> Peaker: No, it exposes callbacks, but there's a queue inside
17:59:59 <Twey> So putting callbacks on that and then reconstructing the queue seems unpleasant :þ
18:00:15 <carter> jmcarthur: for what?
18:00:29 <jmcarthur> carter: oh the old haskell-game graphics benchmark i had made
18:00:55 <carter> the only ah
18:01:02 <jmcarthur> jophish_: 20% of the CPU time is on GC. i really could make that a lot better
18:01:04 <carter> thread or no?
18:01:08 <carter> yeah
18:01:15 <carter> generations help i fyou're careful
18:01:25 <carter> i am a wee bit intrigued by rust
18:01:30 <jophish_> jmcarthur: how about this for radical ideas: OpenGL monad, which can be compiled at runtime by llvm to something superfast
18:01:41 <jophish_> that was poorly explained
18:01:41 <jmcarthur> carter: in this case, most of the GC time is on gen1, so more gens wouldn't help here
18:02:02 <Peaker> Twey: a queue inside, what for? Scheduling callbacks?
18:02:02 <carter> make sure more data is dead
18:02:07 <carter> jmcarthur: which llvm?
18:02:09 <carter> llvm-general?
18:02:13 <jmcarthur> jophish_: while it is possible to make a compilable monad, it is a little awkward
18:02:21 <carter> you could totally do a DSL for something
18:02:22 <jmcarthur> carter: you mean jophish_?
18:02:27 <Peaker> Twey: I guess in C, it makes sense to use callbacks here simply as the only type-safe way to encode a closed-sum-type (sort of a Visitor)
18:02:27 <carter> yes
18:02:47 <jmcarthur> carter: in my rewrite i'm going to have very few allocations in the first place
18:02:49 <jophish_> carter: one could use llvm-general for this
18:02:55 <carter> yeah
18:03:03 <carter> but ti'd be just calling open gl ffi
18:03:09 <carter> right?
18:03:12 <jophish_> I wonder if it would be possible to restrict a dsl for opengl enough to make it applicable for this
18:03:26 <carter> yup
18:03:35 <jmcarthur> it is quite doable
18:03:37 <jophish_> carter: it may be doing some memory shuffling and other things
18:03:49 <Twey> Peaker: The docs imply that events from multiple event sources are fed into a queue for GLFW processing
18:03:53 <carter> jmcarthur: likes
18:03:56 <carter> jophish_: likely
18:04:09 <carter> jophish: super easy to design restricted dsls
18:04:16 <carter> make them restricted by definiton
18:04:39 <carter> jophish: have you seen gpipe?
18:05:07 <Peaker> Twey: ah. In any case, it's only a mild annoyance, IMO (though I remember being very annoyed before implementing the small work around :)
18:05:16 <jophish_> I suppose that every frame Haskell would marshal some data, and write a bunch of opengl commands to execute on this data. The wrapper takes the marshaled data and the list of commands, optimizes and executes
18:05:34 <Peaker> anyway, FFI cb's that throw exceptions seem to wreck havoc on the RTS?
18:05:34 <jophish_> carter: yeah, I can't say I really liked the look of gpipe
18:05:35 <carter> jophish: why marshal?
18:05:42 <carter> theres no need to marshal
18:05:53 <jmcarthur> jophish_: you are describing something akin to a "submission engine" i think
18:05:56 <carter> you could have some ring of off heap frame buffers
18:05:59 <carter> and read and right to them
18:06:12 <jophish_> marshal may not have been quite the right word
18:06:19 <jophish_> write to some memory location
18:06:41 <carter> yes
18:06:43 <carter> so read / write
18:06:44 <Twey> Peaker: It's pretty annoying, to be sure
18:06:47 <carter> yeah, ghc is pretty good at that
18:07:11 <jophish_> This is probably exactly what the drivers are going to be doing anyway, whether the overhead of this system would be a win is another matter
18:07:31 <jmcarthur> jophish_: with some restrictions you can make optimizations the drivers can't
18:07:51 <jophish_> I get the feeling that this would enable a few more low level optmization opportunities.
18:07:58 <darthdeus> what's the difference if i do    (try $ string "ab") <|> string "ad"  vs ommitting the try there? using parsec
18:08:18 <Twey> Maybe I can rework it into FRP somehow
18:08:35 <jophish_> instead of hacking away at c++ getting these little wins, one could focus on submitting the optimal sequence of commands to the submission engine
18:09:25 <Twey> darthdeus: Without the ‘try’, "ac" fails
18:09:41 <Cale> darthdeus: If a Parsec parser succeeds in consuming any input (even if it later fails), any parser it's been <|>'ed with will be discarded
18:09:42 <ion> darthdeus: With string "ab" <|> string "ad", upon encountering 'a' Parsec will choose the first branch and throw away the second one.
18:09:47 <darthdeus> Twey: but it would fail either way no?
18:09:57 <Twey> Er, "ad" also fails.  :þ
18:10:05 <Cale> The try will make it look like it consumed no input when failing.
18:10:05 <darthdeus> ah
18:10:18 <darthdeus> i thought it always goes back when it doesn't match the whole thing
18:10:44 <Cale> This fact about Parsec is responsible for a lot of its efficiency, but it's also the thing I like least about Parsec.
18:10:49 <ion> Btw, ‘try (string "ab")’ is prettier than ‘(try $ string "ab")’
18:11:11 <intrados> Is there a way to lift a `Reader` into a `ReaderT IO`?
18:11:41 <ion> @type reader . runReader
18:11:42 <lambdabot> MonadReader r m => Reader r a -> m a
18:11:45 <johnw> intrados: I'm pretty sure "hoist liftIO" will do that
18:11:51 <johnw> from mmorph
18:11:59 <darthdeus> Cale: so any time i want to use <|> on things that might have the first character the same i should use try
18:12:06 <johnw> since Reader is really ReaderT Identity
18:12:09 <darthdeus> and in any other case that two things might match on a smae character
18:12:17 <Cale> darthdeus: right
18:12:29 <intrados> johnw: Thanks
18:12:55 <johnw> intrados: i may not be exactly right with that, though
18:13:04 <johnw> but i've done something similar in the past
18:13:12 <darthdeus> Cale: and the only downside of doing that all the time is slowness?
18:13:17 <Cale> darthdeus: yeah
18:13:24 <darthdeus> cool
18:13:24 <intrados> johnw: It seemed to work
18:13:29 <johnw> nice
18:13:50 <Peaker> I wonder how many parsers actually need to be monadic, and how many could just as well be applicative -- the latter would be much more performant without the need for "try"
18:13:52 <Twey> Slowness?  I'd say the memory usage is more immediate
18:14:04 <jophish_> jmcarthur: perhaps a submission engine would work best at a higher level, where the submission engine could sort objects by shader etc...
18:14:12 <Peaker> monadic parsing throws away a lot of the interesting theory behind parsing
18:14:14 <Cale> darthdeus: There are other parser combinator libraries out there which have a more symmetric notion of choice, and get space efficiency out of processing the options in parallel
18:14:21 <jmcarthur> jophish_: that is the usual way a submission engine works, yes
18:14:25 <Cale> yeah, it's actually space which is the main concern rather than time
18:14:42 <jophish_> if it's at the level of opengl commands I'm not sure what benefits it would hold over the IO monad, which is essentially the same thing
18:14:43 <Cale> because you can't discard the initial part of the input if you're going to backtract
18:14:45 <Cale> k*
18:14:53 <darthdeus> Cale: erm :P i've just finished reading LYAH and now doing the scheme in 48 hours book, so not sure if i could understand any differences between the libraries :D
18:17:18 <maybefbi> I need help using Database.LevelDB inside a Pipes.Consumer
18:17:52 <maybefbi> All levelDB manipulations can only be done from inside a monad that implements MonadResource m
18:17:57 <jophish_> Perhaps one on the command level could avoid resubmitting the commands individually every frame,
18:20:15 <jophish_> modify the memory, and execute the previous frames commands
18:21:10 <jophish_> carter: jmcarthur, how much overhead is there calling a C function from haskell, if it's a non-negligible amount, then it may be worth compiling the command list every time it changes
18:21:16 <carter> 3ns
18:21:24 <jophish_> ah
18:21:24 <carter> if you do the unsafe ffi
18:21:26 <carter> mabye 6ns
18:21:31 <jmcarthur> jophish_: it depends on if it's a safe or unsafe binding
18:21:36 <carter> yah
18:21:44 <jophish_> what's the difference?
18:21:56 <carter> for things that take more than 500µs, you probably wanna use the safe ffi
18:21:56 <jmcarthur> carter: i think safe bindings are much more expensive than that
18:21:57 <carter> yes
18:21:59 <carter> yes
18:22:45 <Cale> Isn't the difference just whether they're allowed to call back into Haskell code?
18:23:01 <carter> not quite
18:23:05 <jmcarthur> jophish_: for opengl functions, it's like to be pretty expensive. they are dynamic bindings. the opengl api provides most functions by offering an interface to query them by name. the haskell bindings do that statically, but it's still not as optimized as if the function pointer was inlined into the generated code
18:23:07 <carter> whther they're SAFE to call back into ahskell cod
18:23:11 <jmcarthur> *likely
18:23:32 <jmcarthur> jophish_: however, you don't really do that many opengl calls per frame in most applications anyway, so it's not a big deal
18:23:52 <jophish_> jmcarthur: is there something to be said from using LLVM to inline a block of opengl calls then, perhaps?
18:24:10 <jmcarthur> Cale: another difference is that unsafe bindings block the current capability until they return
18:24:23 <carter> also yes
18:24:36 <jophish_> It's probably unlikely that opengl calls would have to be safe, unless one's using DEBUG_OUTPUT
18:24:40 <jmcarthur> jophish_: maybe, if llvm has access to the function pointers directly
18:24:52 <jophish_> jmcarthur: there's no reason it couldn't
18:25:00 <jmcarthur> agreed
18:25:07 <jmcarthur> jophish_: i don't know how much win there would be though
18:25:23 <jophish_> jmcarthur: if the commands don't ever change it may be worth it
18:25:23 <jmcarthur> jophish_: i still stand by my claim that you usually just don't make that many calls per frame
18:25:38 <jophish_> having to compile a llvm module every frame on the other hand
18:25:46 <carter> eeek
18:25:47 <jmcarthur> oh no, you should not do that
18:26:03 <jophish_> :)
18:27:01 <carter> you'd be many sads
18:27:02 <Guest65896> hi, I see a base64-bytestring and base64-string, but no base64-text?
18:27:05 <jmcarthur> jophish_: i made a mistake. i said the haskell bindings look up the functions statically, but i meant they do it one time at initialization, but it's still at runtime
18:27:11 <jophish_> jmcarthur: I think you're right, I've never seen any engine inline the calls like that
18:27:18 <carter> would be cool to do
18:27:24 <carter> might not be worth it though
18:27:30 <Peaker> jmcarthur: damn, following GHC code for FFI import "wrapper" is a maze
18:27:44 <Peaker> jmcarthur: Can't quite figure out how IO exceptions are supposed to be handled
18:28:07 <Cale> "A safe call is less efficient, but guarantees to leave the Haskell system in a state that allows callbacks from the external code. In contrast, an unsafe call, while carrying less overhead, must not trigger a callback into the Haskell system. If it does, the system behaviour is undefined." -- that sounds like "not allowed" to my ears ;)
18:28:14 <jmcarthur> Peaker: darn. i was hoping to benefit from your hard work :)
18:28:20 <Guest65896> anyone know of a base64 encoding for text?
18:28:59 <Peaker> jmcarthur: using some -dump-stub options, I can see GHC generates code like: http://lpaste.net/96986
18:29:17 <jophish_> I think that there's something to be said for a Haskell based submission engine, where the submission engine 'compiles' to writing to a memory block and executing a stream of opengl commands one after the other
18:29:24 <Cale> Anyway, if you're just FFI importing a bunch of stuff, you probably want to mark most things unsafe, unless they actually have some way to call back into the Haskell code.
18:29:34 <Peaker> jmcarthur: what this means for IO exception handling, I am not sure, but it took many minutes just getting to this point :)
18:30:08 <jmcarthur> Cale: i disagree. safe is a good default because it won't block your capability
18:30:39 <Cale> Oh, I suppose that is a good point.
18:30:44 <jophish_> out of interest, in glfw-b is everything unsafe except for glfwPollEvents?
18:31:10 <jmcarthur> jophish_: probably a few more are safe, at least. swapBuffers, for example
18:31:18 <jmcarthur> waitEvents
18:31:20 <jmcarthur> etc.
18:31:30 <jophish_> can swapbuffers execute the callbacks>
18:31:31 <jophish_> ?*
18:31:31 <lambdabot> Maybe you meant: v @ ? .
18:31:46 <jmcarthur> jophish_: there is something you can set to make it autopoll, yes
18:32:18 * hackagebot ihaskell 0.2.0.0 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.2.0.0 (gibiansky)
18:32:51 <Peaker> jophish_: swapBuffers is supposed to block waiting for vblank
18:32:54 <johnw> Cale: nice, I need to use unsafe calls through most of hlibgit2
18:33:17 <Cale> johnw: Well, see jmcarthur's remark too though :)
18:33:36 <Cale> If you care about other threads being able to run on that capability
18:34:16 <johnw> it will block them?
18:34:20 <Cale> yeah
18:34:24 <johnw> hmm
18:34:35 <johnw> so, serial performance gain, possible concurrent performance loss
18:34:41 <Cale> yeah
18:34:55 <johnw> ok, i'll just stick with safe then
18:35:11 <johnw> I just saw that bindings-DSL added #ccall_unsafe
18:35:15 <jmcarthur> i basically only use unsafe for "nonblocking" bindings
18:35:21 <Cale> The capability will sit and wait for the unsafe call to complete, so maybe the ideal thing is to use it when you expect the call to be fast
18:35:43 <jmcarthur> yes, what Cale said
18:36:03 <jmcarthur> and in particular, when you expect the call to *always* be fast
18:36:23 <jmcarthur> it sucks when some random unusual case hangs up your whole program
18:36:44 <johnw> how much faster are we talking about here?
18:36:48 <lykos_> I'm trying to set the upper contents of a dialog in gtk3 in haskell. I think I may have found a bug in the library. In the older versions in haskell, there was a function dialogGetUpper that returned a VBox, now there's a function dialogGetContentArea that returns a Widget (that is, the actual type "Widget"), even though the documentation still says the upper area is a vbox.
18:36:56 <jmcarthur> johnw: you mean the difference between safe and unsafe?
18:37:01 <johnw> yeah
18:37:10 <lykos_> Is this a bug, or am I looking at it wrong? Is there a way to work around this? My simple goal is to pack a table into the upper area.
18:37:16 <Cale> There's also apparently 'interruptible' in GHC which is like 'unsafe' but if that thread is thrown an exception, it will do OS-specific things to try to terminate the FFI call.
18:37:30 <jmcarthur> johnw: it's about the difference between 3ns and 100ns i think
18:37:38 <johnw> omg
18:37:49 <Cale> sorry, like 'safe' rather
18:38:08 <jophish_> I think I need to try and write a speedy engine in Haskell and see where all the time is going
18:38:37 <jophish_> it may be the case that interfacing with OpenGL isn't much of an overhead at all
18:39:20 <jmcarthur> jophish_: usually if a new opengl project is going slow it's due to bad pipelining
18:39:35 <jophish_> jmcarthur: how do you mean?
18:39:51 <jmcarthur> jophish_: you want to be transfering data in big chunks, and you want the GPU to be drawing the previous batch at the same time that you are transferring the next batch
18:40:07 <lykos_> Does anyone have any ideas how I could do that?
18:40:26 <jophish_> that's a fairly high level issue. I imagine that Haskell would tackle that quite nicely
18:40:36 <jmcarthur> jophish_: it's quite low level
18:40:50 <jmcarthur> jophish_: you have to be aware of (or guess) what the graphics driver is doing a lot
18:41:26 <Cale> lykos_: let me refresh myself on how that binding works
18:41:32 <jmcarthur> jophish_: you want to shoot for something like 30-50 draw calls per frame, and for each one you want to be streaming in the data for the next draw call
18:41:32 <Peaker> hmm.. for some reason the GHC RTS goes into "Interrupted" state when the FFI "wrapper" throws an exception
18:41:47 <jmcarthur> jophish_: that way the GPU and CPU are being utilized at the same time
18:41:47 <Cale> (I haven't used it in years, from before GTK3 existed)
18:42:00 <lykos_> Cale: Thanks. I'll be here for a little while. I appreciate the help.
18:42:24 <Cale> lykos_: I think there's a way to cast Widget to other things explicitly
18:43:14 <jmcarthur> jophish_: or at least, that's a fairly ideal situation to be in, when you need to stream a lot of data to the GPU
18:43:22 <Cale> castToVBox :: GObjectClass obj => obj -> VBox
18:43:23 <lykos_> Cale: I looked for that, but couldn't find it. The built in casts cast from a GObject, and I tried doing castToVBox for the widget returned by dialogGetContentArea
18:43:27 <jmcarthur> jophish_: if you can get away with sending less data to it, all the better
18:43:45 <lykos_> Cale: But it didn't work, gave me a runtime error
18:44:01 <Cale> oh, well, Widget is an instance of GObjectClass
18:44:08 <jmcarthur> jophish_: most gl commands aren't that expensive. the draw calls are the worst, so you want to minimize them (within reason... still use enough that you can pipeline well)
18:44:12 <Cale> So it's supposed to *possibly* work sometimes.
18:44:20 <lykos_> That's what I thought, but it didn't work in this case.
18:44:21 <carter> johnw: bascially if any op is FS / network bound, use the Safe ffi
18:44:21 <jophish_> jmcarthur: It's about 0230 here, I don't think that I can quite articulate what I mean very effectively any more
18:44:33 <jophish_> I agree with all you're saying though
18:44:36 <Cale> Of course, the thing which is in the upper part of the dialog might not really be a VBox for some reason
18:44:47 <Cale> (the perils of downward casts)
18:44:47 <jmcarthur> jophish_: the thing is, it's tough to benchmark since it's usually asynchronous. gl only blocks if the command queue fills up
18:45:04 <Cale> I wonder if there's a way to query it to make sure
18:45:20 <jmcarthur> jophish_: or if you do a query, of course, but... don't do that
18:45:55 <jmcarthur> carter: sadly, a lot of common operations that don't appear to depend on the fs actually do
18:46:10 <carter> exampeles?
18:46:20 <jmcarthur> carter: my most recent discovery along these lines is strftime
18:46:26 <carter> whats that?
18:46:57 <jmcarthur> generates a string from a time/date
18:46:59 <lykos_> Cale: I don't know. What do you think I should try to do?
18:47:03 <Cale> lykos_: What runtime error are you getting?
18:47:07 <jophish_> What your saying requires low level knowledge of how a typical OpenGL implementation works, but I think that when to submit draw calls and when/where to stream data are fairly high level engine design considerations (certainly draw call timing)
18:47:31 <lykos_> One sec, let me check again.
18:47:53 <jmcarthur> jophish_: well, my libraries have mostly abstracted over that and provided stream interfaces instead, so i can optimize for it myself instead of making the user do it
18:48:17 * asdaraujo slaps dantasara around a bit with a large trout
18:48:46 <lykos_> Cale: A nice, simply, uninformative one. "Cannot cast object to VBox"
18:49:19 <jophish_> jmcarthur: but there's little you can do if a user send you data to stream the instance before it needs to be used
18:49:32 <jophish_> although most driver don't render and transfer data to the card at the same time anyway
18:49:35 <jophish_> drivers*
18:49:37 <jmcarthur> carter: surprising no? it makes sense once you learn why, but most people wouldn't think about it immediately
18:49:45 <lykos_> Cale: I tried just casting it to a box, and it worked!
18:49:51 <jophish_> some of the higher end workstation cards can do that thoguh
18:49:51 <Cale> lykos_: aha
18:49:57 <jmcarthur> jophish_: most drivers do, actually
18:50:01 <Cale> lykos_: I was about to suggest trying widgetClassPath
18:50:12 <jmcarthur> jophish_: at least if you use them correctly
18:50:14 <lykos_> Cale: oh, that could prove useful later, thanks
18:50:26 <jmcarthur> jophish_: anyway, my libraries are mostly kind of declarative, so the user can't really thwart me
18:50:29 <carter> yeah, if your'e wanting perf, you need to understand how it works
18:50:32 <carter> wmahaha
18:51:18 <jmcarthur> jophish_: not the one i'm working on right now, but the one i told you benchmarks for works that way at least
18:51:32 <jophish_> jmcarthur: I'm not so sure about that, Fermi and Northern islands can't transfer and render at the same time
18:52:13 <jmcarthur> jophish_: i am surprised. got any references for that?
18:52:40 <jophish_> OpenGL insights, 28.2.1
18:52:42 <jophish_> http://www.seas.upenn.edu/~pcozzi/OpenGLInsights/OpenGLInsights-AsynchronousBufferTransfers.pdf
18:52:56 <jophish_> Apparently CUDA can do it though
18:53:33 <lykos_> Cale: Still, box is an abstract widget class, and the documentation states it should be a Vbox class, so I still think it's an error.
18:53:42 <lykos_> bug*
18:54:46 <Cale> Maybe a bug in the documentation even.
18:54:54 <Cale> It's probably some other kind of box
18:55:19 <Cale> (Hopefully widgetClassPath should be able to tell you which)
18:56:19 <jmcarthur> jophish_: i see. interesting
18:56:54 <jmcarthur> jophish_: well, at least you still gain from the technique for streaming buffers, since the destination is pinned CPU memory anyway in that case
18:58:05 <jophish_> yeah, In the engine I'm working on at the moment nearly all data is streamed into mapped pointers from separate threads and uploaded on the render thread when it's ready
18:58:16 <jophish_> how on earth could one do this in Haskell!
18:58:32 <SLi> I've thunk that Haskell is not really a good language for perfectionists or near-perfectionists like me. Because there's always a better and more beautiful way to do $whatever, more so than in other languages. Even now I've been writing a fairly simple binary parsing program for a few days and learned about pipes, conduits and monad transformers.
18:58:57 <SLi> Writing in C(++) I'd already be done :)
18:59:17 <SLi> Or writing not-optimized-for-beauty Haskell.
18:59:41 <jophish_> I suppose that multiple threads could all write into the memory block sent to the submission engine, and uploading the data would be one of the commands submitted
18:59:49 <Twey> SLi: That's the fun of it.  :þ
18:59:52 <Peaker> SLi: Perfectionism-creep is a real problem in Haskell, indeed :)
18:59:59 <Peaker> perfection seems so attainable!
19:00:03 <jophish_> although that sounds like the submission engine would have to wait on all these threads
19:00:27 <SLi> Or maybe that means it is a good language for perfectionists, as there's always a better way to do it? :)
19:00:49 <jophish_> jmcarthur: how about if the submission engine operated on a tree of commands rather than a list. and one of the commands was wait for semaphore from thread
19:01:08 <jophish_> a tree where each branch can be executed independently from other branches
19:01:16 <jmcarthur> sounds tricky
19:01:47 <carter> the whole point of a goodl DSL is you shouldn't have to thinka bout that stuff
19:01:59 <carter> or perhaps even be able to write stuff that needs that sort of coord
19:02:09 <carter> the best concurrency is that which needs no coord
19:02:10 <carter> :)
19:02:18 <jophish_> carter: this would all be in the background :)
19:03:49 <jophish_> perhaps a tree is a little over the top
19:03:54 <jmcarthur> jophish_: my streaming library just maps a buffer and writes data into it, relying on fusion to make that loop also be doing the interesting CPU work that generates the data that's being written into the buffer. the problem with it is that it was a rough prototype and lacks any real fusion. it's all just lists! therefore, high allocation rate, bad GC, too many thunks, only 700k textured quads/second
19:04:22 <jmcarthur> jophish_: but i think in principle the idea is sound. just have the writing loop also do the rest of the CPU burning as it goes :)
19:05:51 <lykos_> Cale: the widget path is: (16,"GtkDialog.GtkBox","xoBktG.golaiDktG")
19:06:23 <jophish_> jmcarthur: I'd be really interested to take a look at what you have
19:06:29 <jophish_> but for now, I'm going home and to sleep
19:06:50 <jophish_> goodnight all!
19:07:39 <lykos_> Cale: Hmm, I think I know what's up. Vbox's might be depreciated. They still work in gtk3 haskell, but in glade3 they're just boxes, where you choose either vertical or horizontal alignment for them.
19:07:50 <Cale> ah
19:07:50 <jmcarthur> jophish_: sure. it's not a low level library, as i said, so doesn't really apply directly to your goals, but here:   https://github.com/haskell-game/graphics
19:08:16 <lykos_> Cale: So I guess it's just an abstract type in gtk2, not 3. gtk3 in haskell still doesn't seem fully implemented: it still only has tables, not grids
19:08:17 <Cale> lykos_: That would explain why the class hierarchy shown in the documentation for Box shows it as a sibling of VBox and HBox
19:08:18 <jmcarthur> jophish_: the included example is the one i ran
19:08:48 <jophish_> jmcarthur: awesome, thanks
19:08:50 <jmcarthur> jophish_: you will see a lot of low hanging fruit in there, so don't cringe too much :)
19:09:01 <Cale> Even though the documentation still refers to it as abstract (probably because it was mostly copied from the GTK2 binding's doc)
19:09:30 <Cale> Yeah, the GTK3 binding is very new
19:09:30 <lykos_> Cale: Yeah, makes sense.
19:09:46 <Cale> (Like a few weeks maybe?)
19:10:11 <Cale> Yeah, uploaded Nov 30 :)
19:10:21 <lykos_> Cale: I've been wanting to get more involved with the haskell community, this might be a good time to contribute. I'm still a fairly new programmer. The project I was having issues with is actually my first github project
19:11:19 <lykos_> Cale: I'm about to implement something, then I'm going to commit it to github, if you'd be interested in seeing it? It's just a project I had for class, that I decided to go overboard with and make a full gui. It's looking kinda cool, although of course I'm biased.
19:11:31 <Cale> Sure, I'll take a look
19:15:14 <lykos_> Cale: Okay. I'm going to add a quick handler, then upload it and give you the link.
19:36:14 <boogie> Hi. Anyone familiar with http://hackage.haskell.org/package/github ?
19:38:20 <zacts> I'm trying to decide eventually learning haskell, or erlang first.
19:38:34 <zacts> I'm interested in highly reliable concurrent systems with live-update
19:38:52 <carter> live update is fiddly in every language
19:38:55 <carter> even erlang
19:39:02 <carter> i've had some chats with folks at basho
19:39:11 <carter> they don't really advocate  doing hot code swapping
19:39:22 <zacts> oh interesting..
19:39:28 <carter> zacts: ask reiddraper  :)
19:39:38 <zacts> ok.
19:39:46 <carter> (he's a basho)
19:39:48 <zacts> reiddraper: ^ you may private /msg me if you would like
19:40:27 <carter> zacts: have you built any distributed systems before?
19:40:27 <zacts> how about the other two options, highly reliable and concurrent?
19:40:45 <carter> well, erlangs not so good at concurrency
19:40:48 <carter> its better at distributed computation
19:41:05 <zacts> carter: I've worked a bit on a project that is like python's twisted.
19:41:05 <carter> why don't you start with reliable concurrent on a single machine code?
19:41:19 <zacts> and I'm a newbie getting through SICP and scheme right now.
19:41:21 <carter> zacts: have you seen simon marlows book?
19:41:22 <carter> ok
19:41:28 <carter> soooo, no distributed systems for you yet
19:41:30 <zacts> I'm just brainstorming for future projects..
19:41:40 <carter> read simon marlows book :)
19:41:44 <zacts> ok, cool!
19:41:48 <carter> it gives a nice vocab for many concurrency ideas
19:42:01 <carter> that carry across many languages, buthave working code in haskell
19:42:08 <zacts> the oreilly book?
19:42:15 <carter> http://chimera.labs.oreilly.com/books/1230000000929
19:42:16 <carter> yeah
19:42:19 <carter> also
19:42:40 <zacts> ok thanks! I'm thinking I'll start with learn you a haskell for a great good?
19:42:51 <zacts> then that book, whenever I get around to haskellish stuff?
19:43:09 <carter> ummyeah
19:43:11 <carter> sure
19:43:39 <carter> http://www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf is a good theoretical lecture notes on concurrent and distributed systems
19:43:44 <zacts> so you can apply those concepts from your link to other programming languages?
19:43:50 <carter> sure
19:43:51 <carter> math is math
19:44:15 <carter> nb: distributed systems are harder than concurrent systems, and both can be tricky
19:45:10 <zacts> carter: ok thanks I'll check it out.
19:47:49 <lykos_> Cale: If you're still on, here it is: https://github.com/PainterAndHacker/LambdaCrypt
19:50:51 <lykos_> (or if anyone wants to check it out, it's a gtk3 for haskell project I've been doing, it implements RSA key generation, encryption, and decryption)
19:51:02 <carter> cool
19:51:10 <Cale> lykos_: cool
19:51:52 <zacts> carter: I'm also interested in exploring things like: http://www.minix3.org/soc-2013/ - the section with "haskell"
19:52:28 <lykos_> Feel free to build it if you'd like, it should build cleanly. It has a pretty smooth user interface I think, but it'd be nice to get some other takes on it.
19:52:50 <lykos_> Or I could send you a binary if you're on a linux machine, should hopefully run with preinstalled libs.
19:53:06 <carter> i'm on  mac
19:53:16 <carter> soo i'll pass for now :)
19:53:38 <Cale> lykos_: Looking at RSA.hs, I think you could perhaps factor the block handling part of the encryption/decryption out of the IO code a little more (i.e. have pure functions which take a key and an input string, and produce the resulting string)
19:53:56 <Cale> (You've essentially written them in the let blocks there)
19:54:50 <Cale> Or Cipher, rather
19:55:18 <lykos_> Cale: Good idea, I'll definitely do that. And thanks for looking at the code, I appreciate it.
19:58:22 <Cale> lykos_: also, it's really okay to ignore the warning you get from -Wall when you don't use the result of an IO action :)
19:59:05 <lykos_> Cale: Heh. Yeah, I figured, but it did seem more complete to do. Do you think I should just ignore them usually?
19:59:09 <Cale> (This is one of the spurious sorts of things which contributes to my usually not turning on -Wall)
19:59:38 <jle`> you could just use void
19:59:49 <Cale> Unfortunately, there are a bunch of actually-useful warnings which -Wall is a convenient way turn on at once
20:00:15 <jle`> you can also use a pragma
20:00:31 <Cale> and if you don't use that, you have to turn them on one-by-one, like -fwarn-incomplete-patterns
20:01:26 <jle`> {-# OPTIONS_GHC -fno-warn-wrong-do-bind #-}
20:01:48 <Cale> yeah, you can explicitly turn off the ones which are silly, I suppose
20:01:53 <jle`> or you can specify it in the cabal file too
20:02:12 <Cale> I think it's -fno-warn-unused-do-bind
20:02:57 <Cale> oh, -wrong- also exists
20:03:08 <Cale> The documentation is a little unclear about what the difference is
20:03:24 <lykos_> hmm, interesting
20:03:38 <lykos_> I turned off wall because of the pointless ones
20:03:46 <jake23> is there a way to make GHC give partial function warnings? for example data Foo = Bar | Baz; func Bar = 10.  I want GHC to warn me that func isn't handling Baz case.
20:04:13 <Cale> jake23: -fwarn-incomplete-patterns
20:04:26 <lykos_> is that part of Wall?
20:04:31 <Cale> yes
20:04:52 <Cale> I think that one should probably be default on, without -Wall
20:04:56 <jake23> thanks
20:04:59 <twiceler> So I'm trying to make some arrays that can be either mutable (in the ST monad) or immutable. But I want to have a function of type f :: Either Array (MutableArray s) -> MutableArray s -> ST s (). (Where obviously that array is only read but not mutated). Is there any less clunky way than Either to do it? I could do a typeclass too, but that also seems... imperfect
20:05:26 <Cale> Though it hasn't always been perfect about detecting whether things really are complete, in complicated cases
20:05:56 <jake23> Cale do you have an example of such a complex case off hand?
20:06:14 <Cale> Not off hand
20:06:42 <Cale> and it might be I'm remembering a bug that's since been fixed
20:07:40 <Cale> twiceler: Probably figuring out which operations on arrays you care about would be a good way to begin
20:08:00 <lykos_> this is the first project I've used git with, I just got an account on it.
20:08:02 <lykos_> It's amazing.
20:08:44 <twiceler> Cale: Sorry, don't really understand what you mean.
20:09:07 <Cale> twiceler: Well, are you familiar with IArray and MArray?
20:09:09 <jle`> it probably should be default, it's default in ocaml
20:09:17 <jle`> i have heard a lot of ocaml people complain about it
20:09:20 <twiceler> Cale: yeah
20:10:11 <carter> zacts: you've got A LOT on your plate?
20:10:28 <Cale> twiceler: So, from these two interfaces, what sorts of pairs of corresponding operations do you want to do with your thing which is either a mutable or immutable array?
20:11:47 <twiceler> Cale: I want to do readArray (MArray) / (!) (IArray) basically
20:12:06 <twiceler> Here's the situation: I'm dealing with arrays on the GPU and I'm trying to make some Cublas bindings
20:12:15 <carter> twiceler: oooo
20:12:27 <carter> have you looked at accelerate?
20:12:29 <Cale> twiceler: Okay, so such a thing has type (Ix i) => i -> m e for some i, m, and e
20:12:37 <Cale> (assuming you already know what the array is)
20:12:38 <twiceler> and there are some functions which look like "read this array and that array, and update that array"
20:13:02 <twiceler> Cale: Yep
20:13:17 <Cale> twiceler: So you could make a type like:
20:13:56 <twiceler> carter: I have! I was using the Accelerate FFI to make the bindings until just recently... I kind of got fed up with the complexity :(
20:14:03 <carter> i've some stuff i'm working on that may be relevant,
20:14:13 <carter> but i wont' have gpu friendly tooling for a few months
20:14:21 <carter> aiming to get the cpu tooling out soon
20:14:35 <carter> what was the complexity? that you could only write code their way?
20:15:08 <twiceler> carter: Yes, and a few other things.
20:15:15 <carter> please rant on
20:15:37 <Cale> data GenArray m i e = GA { readGA :: i -> m e }
20:15:38 <twiceler> carter: I was getting fed up with the type families. For example, For some reason, the device pointer for an array with CFloat values had a type of Float
20:15:41 <carter> mine was "i want to write recursive algs in direct style, with nested parallelism, and fancy array layouts"
20:15:54 <carter> Cfloat and Float are kinda the same
20:15:57 <carter> well
20:16:08 <carter> Ptr CFloat ==== Ptr Float
20:16:21 <carter> afaict
20:16:27 <carter> well
20:16:28 <twiceler> twiceler: Well, I made my bindings with CFloat, because that makes more sense to me, and I didn't want to change, so I did an unsafeCoerce
20:16:35 <carter> yeah
20:16:38 <carter> that happens :)
20:16:40 <Cale> and then you can write functions for each type of array which make one of these by applying readArray or (!)
20:16:48 <lykos_> On a question unrelated to haskell, how small of an update is too small for a git commit? Cale: I updated the encrypt/decrypt functions to be more pure, would that be too minor to commit you think?
20:16:52 <twiceler> carter: Yes, with Haskell 2010, Floats and CFloats are supposed to be essentially auto-marshalled or something
20:17:06 <Cale> lykos_: Arbitrarily small?
20:17:09 <carter> well, they have the same storable / unboxed array model
20:17:23 <carter> lykos_: do it
20:17:26 <carter> no harm
20:17:55 <lykos_> okay
20:18:13 <Cale> lykos_: Smaller commits are usually better than larger ones, if you can manage things. But you also probably don't want to commit a change which stops the code from compiling.
20:18:58 <carter> unless you're doing lots of experimentation
20:19:02 <Cale> (unless it's on a branch so that other people can get it for you to discuss what to do)
20:19:07 <carter> and note the breakage
20:19:09 <Cale> yeah
20:19:39 <lykos_> Okay, thanks. What if I have two rather minor, unrelated things? Is it fine to commit them both in 1 commit, or should I separate it into 2?
20:19:45 <lykos_> I'm thinking 1.
20:19:57 <Fuuzetsu> @pl f cd fp = cd >>= (return . (</> fp))
20:19:58 <lambdabot> f = flip (fmap . flip (</>))
20:20:13 <twiceler> carter: I didn't have a good feeling for how the FFI worked. It was weird because the arrays all had to come at a tuple at the end. And I didn't know whether my scalars should have been put in that tuple or not (I guess it would make a difference if I implemented the non-CUDA "backup" function)
20:20:15 <jake23> -fwarn-incomplete-patterns worked nicely. are there any other warnings i should be turning on?
20:20:31 <Fuuzetsu> :t liftM
20:20:32 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
20:20:43 <Cale> lykos_: I usually don't stress out too much about that sort of thing. It's nicer if you can commit patches where each change has a single purpose, but doing that consistently is often tedious.
20:21:17 <carter> twiceler: so i take it you're meh on repa too?
20:21:33 <carter> have you looked at vector?
20:21:42 <twiceler> Cale: I'm not sure I understand what you mean with that GenArray
20:21:48 <jle`> lykos_: it depends on the context of course
20:21:59 <jle`> lykos_: but one thing you can do for personal development
20:22:00 <Cale> jake23: Well, https://www.haskell.org/ghc/docs/7.6.3/html/users_guide/options-sanity.html has a list you can look through for stuff that you'd worry about yourself.
20:22:02 <jle`> is maintain different branches
20:22:10 <jle`> branch early, branch often
20:22:20 <jle`> when you wnat to implement a new feature, check out a feature branch
20:22:30 <Cale> twiceler: I'm saying that rather than providing a choice between two different types, you provide a record of all the things you want to be able to do regardless.
20:22:33 <jle`> and make commits every small change
20:22:33 <twiceler> carter: I haven't used repa. I actually LOVE accelerate. It's literally my favorite library. But I think it was just too much for me to handle with making this linear algebra stuff
20:22:43 <carter> well
20:22:47 <carter> i've love your feedback
20:22:52 <jle`> and then when it's done merge back into your develop branch
20:22:54 <carter> once i get my preview release out
20:23:15 <Cale> If the only thing you're going to do with the array is to read it, then you might as well just provide a function to do that, rather than the array.
20:23:20 <twiceler> Cale: Well, both of my arrays are actually the same thing (ptrs to chunks of data). But one is tagged as mutable and one not
20:24:08 <twiceler> So I could just ask for the mutable array, and then make people do an "unsafeThaw" on their immutable arrays, knowing that their array won't actually end up changed
20:25:12 <Cale> twiceler: If all you're going to do is read, why not just have them supply a function (i -> m e) though?
20:26:51 <Cale> If you're worried that they might supply you with a sneaky function that doesn't really read from an array, then you can pull this GenArray trick, and hide the constructor with a module boundary, only allowing them to use specific constructors that make GenArrays from specific types of mutable and immutable array
20:27:04 <Cale> (and a GenArray is again, just internally a function of that type)
20:27:32 <Cale> But if you're not worried so much about that, you can just ask for a function argument
20:28:14 <twiceler> Cale: Yes, supplying that function is basically either a Left or a Right
20:28:30 <twiceler> Cale: Maybe I was just being a little picky in hoping for something really neat
20:28:41 <Cale> uhhhh
20:28:49 <Cale> I think you're missing the point of what I'm saying
20:28:57 <Cale> I'm saying, *don't* use Either
20:29:00 <Cale> Use a function type
20:29:06 <twiceler> Cale: Oh I see. That way there's no way you can mess with their mutable array
20:29:20 <twiceler> Whereas with the Either they still have to trust me.
20:29:28 <Cale> They supply you with a way to read their array, and you use that
20:30:07 <Cale> (and you can do some things to make that argument easier to supply, but for mutable arrays, you'd just apply readArray to them)
20:30:18 <twiceler> I like that idea! Let me try to grok how I could implement it.
20:36:15 <lykos_> Cale: Do you think I should just remove the "_ <-" from the unused IO results?
20:36:36 <lykos_> It would look much cleaner, but I feel it might be bad form?
20:36:36 <Cale> lykos_: I would :)
20:36:49 <lykos_> Okay.
20:38:14 <johnw> lykos_: unless you use -Wall
20:39:46 <Zxcvbnm> :arc guard
20:40:08 <Zxcvbnm> :arc guard
20:40:24 <jle`> lykos_: you could use void
20:40:26 <jle`> :t void
20:40:27 <lambdabot> Functor f => f a -> f ()
20:40:42 <lykos_> hmm
20:40:58 <lykos_> That would look kinda clunky doing it every time.
20:41:03 <lykos_> Would it be good to, you think?
20:41:20 <johnw> I use void quite a bit
20:41:24 <johnw> because I use -Wall
20:41:50 <lykos_> Okay. I currently set it so I'm using -Wall, but with -fno-warn-unused-do-bind
20:41:51 <quchen> johnw: What do you do with the defaulting warnings?
20:41:55 <quchen> Explicit types?
20:42:03 <johnw> yep
20:42:07 <quchen> Oh.
20:42:14 <johnw> i tried to avoid turning off warnings
20:42:24 <johnw> i do turn off orphaned instances when I need to use them
20:42:45 <quchen> I do that on a module pragma basis.
20:42:55 <quchen> I mostly use -W because -Wall seems a bit pedantic usually.
20:43:00 <johnw> same
20:44:08 <Zxcvbnm> :src guard
20:44:33 <lykos_> It's nice having a clean compile, but I'm just going to let myself ignore some do results.
20:44:39 <lykos_> It's just a lot cleaner code.
20:44:41 <Zxcvbnm> @src guard
20:44:41 <lambdabot> guard True  =  return ()
20:44:41 <lambdabot> guard False =  mzero
20:44:42 <lykos_> *sigh
20:46:38 <quchen> lykos_: The cleanliness comes at a price though. Side effects of "thrown away" code are real, and not obvious when you're debugging something.
20:46:54 <quchen> Using void or "_ <- ..." makes your intention explicit.
20:47:44 <johnw> i've been told that _ <- is better, but there are times when void is more convenient
20:47:55 <quchen> Why would that be better?
20:48:01 <lykos_> quchen, yeah, I realize. In a pinch, I could just auto-add _ <- for all the warnings, for debugging. Do you really think I should _ <- or void?
20:48:20 <johnw> quchen: void needs a Functor constraint, for one
20:48:22 <quchen> No, I think you should void for void
20:48:33 <quchen> johnw: LALALA I live in 7.10 dream world already :-þ
20:48:41 <jle`> :P
20:48:47 <johnw> edwardk had some reasons why void's performance can be bad too
20:49:10 <quchen> Oh really? Was it in this channel, are there logs?
20:49:24 <johnw> for what people use it for, I think it should have been defined as "void m = m >> return ()"
20:49:28 <johnw> quchen: yeah, and probably
20:49:32 <jle`> _ <- feels hackier than void for me
20:49:47 <johnw> then don't use it :)
20:49:50 <jle`> :)
20:51:28 <haasn> this is why we need linear monads!
20:51:46 <quchen> I agree!
20:51:50 <quchen> What are linear monads?
20:52:08 <haasn> Hmm. functors?
20:52:31 <haasn> maybe uh, functors with liftA2
20:52:42 <quchen> You mean `Apply`?
20:52:53 <quchen> Functor+<*>
20:53:05 <haasn> looks like it
20:53:18 <haasn> a strong lax semi-monoidal endofunctor, apparently
20:53:22 <shachaf> That would be relevant, not linear, wouldn't it?
20:53:42 <haasn> shachaf: if only I managed to remember what “relevant” means
20:54:05 <shachaf> "relevant" means at least one, "affine" means at most one, "linear" means exactly one.
20:54:10 <quchen> johnw: I think some of Edwardk's objections to the current `void` were that it is implemented in terms of fmap, and not (<$). That was on the mailing lists though.
20:54:17 <shachaf> At least, that's what I take them to mean.
20:54:33 <jle`> @src void
20:54:33 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:54:50 <quchen> Can't find the void discussion on IRCBrowse, all the talk is about Void there.
20:54:59 <shachaf> ("relevant" ~ "exists" ~ "+" ~ ..., "affine" ~ "unique" ~ "?" ~ ..., and so on. These things have many names.)
20:55:00 <haasn> I guess it depends on what exactly one is counting when one says “linear monad”
20:55:14 <quchen> jle`: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Monad.html#void
20:55:35 <shachaf> Where did the term come from?
20:55:45 <shachaf> I'd expect a monad to have something like join.
20:57:36 * hackagebot UISF 0.1.0.0 - Library for Arrowized Graphical User Interfaces.  http://hackage.haskell.org/package/UISF-0.1.0.0 (dwincort)
20:58:49 <haasn> I guess it's a relevant monad I was going after originally; the idea was to have a type of monad in which the results of actions have to be used in the do block following it (to avoid the _ <- ... scenario where information just gets destroyed); another way to formulate it I guess would be to enforce the right hand sides of >>= use its parameter at least/exactly once
20:59:50 <johnw> a... semigroupad?
21:01:25 <haasn> johnw: is that a semigroup in the semigroupoid of endosemifunctors?
21:02:18 <shachaf> Hmm, I wonder whether you could use lensy things to encode linear types.
21:02:24 <johnw> couldn't it just be endofunctors?
21:02:31 <Twey> If I have a Behavior in reactive-banana and I want to do something every <time delta>, how should I model that?  Is there a ‘fromPoll’ equivalent for Behaviors?
21:02:35 <haasn> johnw: I don't know. ‘functor’ to me implies category
21:02:36 <johnw> shachaf: that's an interesting idea
21:02:55 <haasn> ddg doesn't have a !bang for ncatlab yet :(
21:04:43 <haasn> johnw: http://ncatlab.org/nlab/show/semicategory terms it “semi-functor”
21:05:07 <shachaf> Just call it a "homomorphism" and let people guess what you mean.
21:05:32 <johnw> a homomorphoid
21:05:43 <haasn> semihomomorphism
21:05:47 <abitlost> functoidism
21:07:16 <haasn> shachaf: Lin f g ~ forall r. (g r -> r) -> f r -> r  (from cmccann's linear logic stuff)
21:07:37 <shachaf> Maybe I should look at that.
21:07:42 <haasn> http://lpaste.net/75222
21:07:53 <shachaf> Hmm, that's a funny type.
21:09:36 <shachaf> Hmm, Haskell sure is awkward.
21:09:45 <shachaf> You can't even write the type for a free group.
21:09:47 <shachaf> Or a set.
21:10:16 <shachaf> thanks, curry
21:11:00 <haasn> undneg :: Not (Not x) ⊢ x
21:11:02 <haasn> undneg = Lin (\x -> Not $ \(Not kx) -> kx x)
21:15:10 <zacts> carter: eh, yeah. I tend to often think I can do more than I can handle. similar to going to a buffet and thinking you can eat everything, but you really can't
21:15:34 <zacts> but, I'm also trying to decide which projects to work on, so I'm looking at my possibilities.
22:01:14 <jle`> come on #haskell be more active, how am i supposed to procrastinate on my grad school apps when you're in this state
22:02:55 <johnw> you just need to ask something
22:03:46 <ion> “What examples of monads are there other than jQuery?”
22:04:19 <johnw> a tortilla-wearing spaceman, of course
22:04:40 <haasn> What examples of Linq are there other than IEnumerable? :(
22:06:30 <jle`> if monads are like burritos, what are tacos?
22:06:43 <shachaf> I recommend contributing signal rather than noise if you can.
22:06:59 <jle`> fair enough
22:13:40 <hiptobecubic> I've been out of the loop for a few months. Are there any libraries left that haven't been replaced by lens somehow?
22:14:59 <Ralith> jle`: grad school apps procrastination team \o/
22:18:15 <jle`> o/
22:18:21 <hiptobecubic> I guess not.
22:19:03 <jle`> hiptobecubic: if it's a serious question, http://ocharles.org.uk/blog/posts/2013-12-01-24-days-of-hackage-intro.html has a nice summary
22:19:39 <hiptobecubic> Oh right. A friend mentioned it, but I forgot that was going again. Nice :) thanks.
22:27:17 <joelteon> for cabal's bootstrap.sh, can I specify a build directory that's not ~/.cabal or the global dir?
22:41:25 <triliyn> Where is the Not type from http://lpaste.net/75222 defined?
22:41:53 <triliyn> oh wait, never mind
22:42:00 <triliyn> It's in the paste, I just missed it somehow
22:44:04 <shachaf> It is Not defined on line 50.
22:50:21 <shachaf> preflex: seen cmccann
22:50:22 <preflex>  cmccann was last seen on #haskell-lens 74 days, 8 hours, 29 minutes and 58 seconds ago, saying: sounds legit.
23:02:00 <shaladdle> Quick question: I can do ':t Crypto.Hash.SHA1.init', and it works, but if I do ':m Crypto.Hash' followed by ':t SHA1.init', it doesn't work.. I must just not know the right syntax for this..
23:06:15 <lispy> shaladdle: you can also say, 'import Crypto.Hash'
23:06:30 <lispy> shaladdle: and the imports variety is probably easier as you already know the syntax
23:06:34 <johnw> I think you need to import Crypto.Hash.SHA1, then :t init
23:06:45 <arkeet> yes
23:06:55 <lispy> shaladdle: if you really want to use :m it's :m + Crypto.Hash IIRC
23:07:08 <lispy> I know the + matters, just can't recall where the spacing codes
23:07:11 <lispy> goes*
23:07:54 <shaladdle> lispy: thanks, that put me on the right track, 'import Crypto.Hash.SHA1 as SHA1' is what I wanted. Didn't know you could use import in ghci
23:07:58 <lispy> johnw: oh, good catch. I glossed over that.
23:08:07 <lispy> shaladdle: that's a relatively new feature
23:08:11 <Kron> wow, GHC is fast. Like, really fast.
23:08:13 <shaladdle> johnw: I tried that, but there's an 'init' in Prelude too, so they were colliding.
23:08:19 <Kron> I've only just looked it up on the language shootout
23:08:34 <johnw> in your code, do import qualified Crypto.Hash.SHA1 as SHA1
23:08:37 <johnw> then you can use SHA1.init
23:08:37 <lispy> Kron: yup :)
23:08:45 <Kron> I don't remember it being this fast
23:08:58 <Kron> I vaguely remember it being slow and outrun by ocaml, but that was like 5 years ago I think
23:09:13 <lispy> Kron: Writing code that fast in Haskell requires a fair bit of experimentation beyond generic performance expertise
23:09:20 <shaladdle> johnw: does it work without 'qualified', ie 'import Crypto.Hash.SHA1 as SHA1'? That's all I had to do in ghci. I know ghci isn't the same as in a .hs file, is this one of those cases?
23:09:31 <lispy> Kron: But...it's still nice to have that existence proof
23:09:44 <arkeet> shaladdle: yes
23:10:03 <shaladdle> arkeet: gotcha. Thanks guys
23:10:22 <arkeet> that just lets you access things in SHA1 by both saying SHA1.blah or just blah
23:10:53 <shaladdle> ohh hmm
23:11:52 <arkeet> so,s ay
23:12:08 <arkeet> if you say import Data.Map as M
23:12:22 <arkeet> then you can refer to M.singleton also as just singleton
23:12:33 <arkeet> but, if you say map
23:12:43 <arkeet> then it'll be ambiguous (because that could be from Data.Map or Prelude)
23:12:56 <arkeet> qualified just makes it force you to write M.
23:13:20 <arkeet> to not conflict with the main namespace.
23:13:28 <shaladdle> arkeet: Ah I see. I get it. What's the convention? Seems like qualified makes it a little more obvious what's going on
23:13:35 <arkeet> I agree
23:14:29 <arkeet> incidentally, you can import multiple modules into the same namespace
23:14:46 <arkeet> e.g. import qualified Data.Text as T; import qualified Data.Text.IO as T
23:15:00 <arkeet> useful sometimes
23:15:43 <zRecursive> then which T is used when T.*** ?
23:15:57 <arkeet> whichever one works.
23:16:11 <zRecursive> oh
23:16:11 <arkeet> T.map will come from Data.Text; T.printLn will come from Data.Text.IO
23:16:37 <arkeet> it works as long as there isn't a conflict
23:16:48 <arkeet> er T.putStrLn
23:17:12 <zRecursive> ok
23:17:27 <joelteon> I'm trying to bootstrap cabal but it keeps exiting with status 2. is that a memory thing?
23:18:55 <lispy> joelteon: 2 is usually something else. I think memore is 11 or 9.
23:18:59 <lispy> memory*
23:19:25 <lispy> joelteon: http://tldp.org/LDP/abs/html/exitcodes.html
23:19:43 <lispy> that's for shell not arbitrary programs
23:19:55 <lispy> joelteon: are you running a bootstrap script?
23:21:23 <jeetu>  /quit
23:21:28 <joelteon> i'm running bootstrap.sh
23:22:14 <lispy> joelteon: So according to that table I linked, you should look for a misuse of shell builtins
23:22:26 <arkeet> which OS?
23:24:32 * lispy would be tempted to use a binary search over the text of bootstrap.sh (commenting out the second half of the script. if the error goes away, uncomment half of that. If the error is still there, comment another half of what remains. Repeat.)
23:24:34 <joelteon> centos 6.4
23:24:53 <joelteon> i've built cabal about 50 times on centos without issue until now
23:24:59 <joelteon> so I'll binary search
23:26:02 <lispy> joelteon: another think to check. What actual shell does centos 6.4 use for !/bin/sh (or whatever the shell specifies)
23:26:15 <lispy> Maybe they use dash and the script has bash-isms? Who knows.
23:26:52 <arkeet> also, you could always just install the dependencies manually.
23:30:23 <lispy> arkeet: if the script is non-portable then it would be good to report a bug
23:30:37 <arkeet> well linux should work fine??
23:30:49 <lispy> arkeet: but joelteon is using linux
23:30:53 <arkeet> exactly
23:31:12 <lispy> I bet the authors tested on something else like debian
23:31:28 <johnw> i've built cabal many times on ubuntu and centos 6
23:31:59 <johnw> lispy: we call that binary searching thing bisecting :)
23:33:55 <MitchW_> am I crazy, or is main in ' main = show "blah" ' a pattern, and not a function binding (funlhs in the haskell 2010 syntax reference requires a pattern inbetween the var and the rhs, which 'main = ' does not have) *confused (and surely missing something trivial)*
23:33:59 <lispy> johnw: tomato tomato
23:34:46 <lispy> johnw: my usage derives from this: http://en.wikipedia.org/wiki/Binary_search_algorithm
23:35:04 <lispy> johnw: Although I concede that bisecting is more accurate
23:35:26 <johnw> i remember "inventing" that same strategy when I was working at a company long ago
23:37:20 <lispy> johnw: I had the good fortune of being taught that trick as a teenager. I was also taught the trick in college in at least one class.
23:38:01 <lispy> johnw: It's my go-to for brute force searches
23:38:15 <johnw> yeah, me too; it's a rather effective method of print debugging
23:38:35 <johnw> i must admit I rather miss my interactive debugger in Haskelland
23:38:42 <johnw> i used to practically live in gdb
23:38:47 <scott_> MitchW_: I think that's right, main is not a function, it has type IO ()
23:38:58 <lispy> johnw: yeah, gdb can be a godsend for C/C++
23:39:07 <johnw> main is an IO action executed by the Haskell runtime
23:39:17 <lispy> main is a supercombinator in the lambda calculus sense
23:39:26 <scott_> MitchW_: btw, show "blah" isn't IO () so that example is not well typed if main :: IO ()
23:39:47 <lispy> http://en.wikipedia.org/wiki/Supercombinator
23:40:02 <shachaf> It isn't well-typed for any valid type for main.
23:40:14 <MitchW_> scott_: cool, so I'm not nuts then - just made a wrong assumption :)
23:40:18 <johnw> lispy: cool
23:40:31 <johnw> nice that the only reference is to an SPJ work :)
23:40:59 <shachaf> alan_: alan_?
23:41:15 <lispy> Oddly enough, that's the source I learned the term from. That article could use other citations though as SPJ didn't make it up AFAICT
23:41:19 <shachaf> Hmm, I guess you're not that ac.
23:42:18 <lispy> johnw: related, combinator (a word we throw around) has a precise mathematical definition
23:42:28 <lispy> But not a lot of Haskellers realize that
23:42:30 <johnw> right
23:42:37 <johnw> a function that only uses its own arguments, right?
23:43:02 <shachaf> It has several possible meanings and usually people ignore all of them and just use it to mean "thing" or "value".
23:43:04 <lispy> "An expression that contains no free variables is said to be closed. Closed lambda expressions are also known as combinators and are equivalent to terms in combinatory logic." -- http://en.wikipedia.org/wiki/Lambda_calculus
23:43:41 <johnw> does that make (+) an integer combinator?
23:44:32 <lispy> As a lambda expression, wouldn't it be \x.\y.x+y ?
23:44:45 <johnw> yeah
23:44:46 <lispy> But yeah, I think so
23:45:02 <lispy> But not a supercombinator
23:45:16 <johnw> but maybe a megacombinator
23:45:55 <johnw> I like shachaf's definition: Combinator has a precise mathematical definition, which most people use to mean "thing" or "value".
23:46:14 <bz> hm
23:46:22 <bz> doesn't lambdabot have MaybeT?
23:46:53 <arkeet> @let import Control.Monad.Trans.Maybe
23:46:54 <lambdabot>  Defined.
23:46:56 <arkeet> it does now!
23:47:17 <lispy> :t MaybeT
23:47:18 <lambdabot> m (Maybe a) -> MaybeT m a
23:47:52 <johnw> is there a convenient way to turn a Just value into a MaybeT action, besides "MaybeT $ return m"?
23:48:24 <bz> lift getLine >>= \s -> guard (isDigit $ head s) >> return s
23:48:42 <bz> (>>) means that the result of that guard is ignored, right?
23:48:55 <johnw> :t guard
23:48:55 <lambdabot> MonadPlus m => Bool -> m ()
23:49:07 <lispy> the result of guard is totally ignorable
23:49:08 <johnw> not that you could do much with it, but yeah
23:49:23 <bz> what the hell
23:49:41 <joelteon> Yep, I fixed it
23:49:50 <joelteon> swappiness was configured to 0 rather than 60
23:50:00 <lispy> joelteon: what is swappiness?
23:50:11 <shachaf> "combinator" isn't a thing that a value is.
23:50:12 <johnw> how eagerly pages get swapped out
23:50:20 <bz> http://en.wikibooks.org/wiki/Haskell/Monad_transformers#Application_to_the_password_example
23:51:20 <lispy> shachaf: I'm not following your objection
23:51:42 <lispy> shachaf: functions in Haskell are values, and so you're saying that Haskell functions are not combinators?
23:51:51 <bz> @src guard
23:51:51 <lambdabot> guard True  =  return ()
23:51:51 <lambdabot> guard False =  mzero
23:52:03 <bz> :t mzero
23:52:03 <arkeet> :t maybe mzero return
23:52:04 <lambdabot> MonadPlus m => m a
23:52:04 <lambdabot> MonadPlus m => Maybe a -> m a
23:52:17 <arkeet> :t msum
23:52:18 <lambdabot> MonadPlus m => [m a] -> m a
23:52:24 <arkeet> :t F.msum
23:52:25 <lambdabot> (MonadPlus m, Foldable t) => t (m a) -> m a
23:52:28 <arkeet> hm not quite.
23:52:34 <shachaf> lispy: Well, to contrast with "combinator", what's a thing that isn't a combinator?
23:52:46 <arkeet> :t F.asum . fmap pure
23:52:47 <lambdabot> (Functor t, Foldable t, Alternative f) => t a -> f a
23:53:16 <lispy> shachaf: an expression with a free variable
23:54:07 <shachaf> OK, so expressions are the things that are combinators/not combinators?
23:54:35 <lispy> shachaf: More to the point, I think we tend to throw the term around in a way that gives it a vague sense in Haskell. Like a connotation, but many of us are ignorant to the fact that it already has a precise definition.
23:54:59 <lispy> and yeah, the precise definition is very general
23:55:02 <shachaf> So saying that a value is a combinator is an error of some sort, because expressions exist in a different universe from values.
23:55:07 <lispy> (which is what I think you're getting at)
23:55:09 <shachaf> OK, now I don't care again.
23:56:30 <lispy> You're making a distinction between lambda expression and lambda value, correct?
