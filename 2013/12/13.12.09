00:00:13 <joejev> I mean what is the application going to do
00:00:25 <augur> quite literally that. :)
00:00:31 <augur> its a fancy command line
00:01:12 <joejev> ph
00:01:14 <joejev> oh, cool
00:15:18 * hackagebot linear 1.3.1.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.3.1.1 (EdwardKmett)
00:15:18 * hackagebot monad-logger 0.3.3.1 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.3.1 (MichaelSnoyman)
00:20:26 <dp_wiz> Is it my installation or current yesod generates broken scaffold wrt new wai-2 packages?
00:21:09 <nisstyre> dp_wiz: if it assumes a particular version of ghc and uses some feature that was removed or changed then that could be the cause
00:21:13 <dp_wiz> hackagebot: nice tachyon uplink, dude. looks like you answered my question before i asked for it.
00:21:28 <nisstyre> I don't use Yesod though so don't ask me why
00:24:49 <jle`> anyone have any practical uses for reverse state monad/tardis?
00:28:32 <dp_wiz> jle`: it's fun and allows for trivial solutions for some tasks (like that twitter water quiz) but actual performance is meh...
00:32:42 <jle`> dp_wiz: hm, do you have a link to that solution for the twitter water problem?
00:36:33 <dp_wiz> jle`: http://chrisdone.com/posts/twitter-problem-loeb
00:38:32 <jle`> dp_wiz: thanks :)
00:39:29 <dp_wiz> I like how "second fastest algorithm" is expressed nicely in common HOFs...
00:41:30 <begriffs> jle`: finished the article. Thanks for teaching me about MonadPlus. I've certainly seen mzero and return but I didn't realize mzero comes from an additional typeclass. So that was cool. Although I had to look it up on Hoogle. Might be nice if your article mentions that Monad gives us return and MonadPlus adds mzero.
00:42:23 <johnw> "MonadPlus turns monadic actions into monoids."
00:43:02 <begriffs> Also, the version of 'halve' function that uses guard confused me because of the "x <- n" thing. I was puzzled why that was there. I wrote a version without that step and tried it out and it was fine...then I read the note that says "Some of this might seem a little convoluted..."
00:44:09 <begriffs> So in general when the example functions have extra steps I got confused and worried there was something I was missing because it seemed like it should have been simpler. But then you mention that you wrote things in that style because it will make sense in future articles.
00:46:10 <begriffs> jle`: that's my take on the article. I learned stuff, but got unnecessarily confused by some of the examples not being written as concisely as they could have been.
00:51:02 <johnw> begriffs: which article is this btw?
00:52:17 <begriffs> johnw: jle' wrote "anyone interested in tearing apart my MonadPlus series targeted at intermediate haskellers http://blog.jle.im/entry/id/12"
00:53:06 <jle`> begriffs: thanks, i think the extra convoluted parts mgith not be necessary at all
00:53:18 <jle`> they might confuse more than they help
00:53:44 <jle`> if i intend on promoting good haskell especially
00:59:49 <Matthijsh> Hello. Could someone tell me/redirect me to an explaination of the difference between deep and shallow semantics?
01:08:49 <johnw> Matthijsh: I don't know what you mean, can you give more context?
01:24:24 <jle`> begriffs: i got rid of any extra unecessary convolution, thanks for offering the input.  and yeah, i always found it a little un-obvious what things like Alternative/MonadPlus are really "for".  Also, i added a clarification on return.  But really though, return is a conceptually/semantically "meaningless" construct on general monads; it could conceptually "mean" whatever you want.  In the context of
01:24:26 <jle`> MonadPlus, it has a specific (enforced) conceptual meaning, so that's why I treated it like something that belonged to monadplus.
01:42:59 <Guest9491> Hi,
01:43:14 <Guest9491> I'm struggling writing a function that traverses an n-ary tree
01:43:26 <Guest9491> here is some code:
01:43:26 <Guest9491> http://lpaste.net/361979525879300096
01:43:57 <Guest9491> An additional problem is that I have to keep track of the current path, to print how to get from the root to a paticular node
01:50:16 <bezirg> how would somebody go and source-to-source compile a simple imperative and strict language down to Haskell code?
01:50:53 <bezirg> besides putting strict annotations here and there, what the variable assignment & update would be translated into?
01:51:34 <lieven_> bezirg: why would you want to do that? it seems like a bad match.
01:51:56 <bezirg> lieven_: mostly just for fun
01:52:35 <merijn> I disagree with lieven_ on it being a bad match
01:52:47 <merijn> I also don't think you need strict annotations at all
01:53:09 <bezirg> merijn: but how the variable assignment&update would be implemented?
01:53:12 <xkb> depends on how far you want to go to mimic the semantics of the source language
01:53:13 <bezirg> merijn: sth int ST monad?
01:53:17 <merijn> The fact that your compiling code with strict semantics doesn't require the underlying to support that
01:53:29 <bezirg> merijn: i think u r right
01:53:46 <merijn> bezirg: You could use ST, you could do something eve simpler and use an IntMap and translate variable names to entries in that
01:54:11 <xkb> something like a symbol table
01:54:13 <bezirg> aha
01:54:23 <bezirg> but symbol tables r expensive, right?
01:54:43 <merijn> bezirg: Getting good performance out of haskell as a target language would probably require reasonably advanced haskell knowledge. But getting some good enough to work, won't be that hard
01:54:49 <merijn> bezirg: For some value of expensive
01:55:05 <xkb> again that depends on specific semantics that you want/need
01:55:10 <merijn> bezirg: python effectively does a dictionary/map lookup for every variable access, function call, etc.
01:55:20 <bezirg> merijn: didn't know that abt python
01:56:31 <allsystemsarego> it would be tricky to decide if a Python function is pure or not
01:56:43 <merijn> bezirg: The IntMap approach is obviously not optimal, but unless you plan to do high performance stuff other than "look! I made a simple language and it actually works!", I don't think it's a big issue
01:57:38 <allsystemsarego> you could implement the transpiler for a subset of the language, Fay did that
01:58:20 <allsystemsarego> but Fay went from a powerful language to a lesser one
01:58:43 <bezirg> one other question: the source language has sth like interface inheritance (OO-style). I thought to map it down to Haskell typeclasses. Is there any performance consideration? I remember that typeclasses have to do a lookup to the method unless it is specialized
01:59:01 <issam> Hi folks
01:59:02 <issam> :)
02:01:03 <Cale> bezirg: So you're compiling some OO language to Haskell?
02:01:26 <bezirg> Cale: not OO in the classice sense, it lacks class code inheritance
02:01:49 <bezirg> Cale: i.e. you can only implement Interfaces, not extend classes
02:02:07 <bezirg> Cale: and the objects are typed by interfaces, not by classes
02:02:19 <Yuu-chan> Won't it be too bad to use unsafePerformIO for loading a constant bitmap?
02:02:25 <Cale> bezirg: I think for something like that, I'd prefer to just manage the dictionaries myself, rather than relying on Haskell's instance resolution, but it depends on how closely the source language matches.
02:02:48 <bezirg> Cale: i understand
02:03:44 <Cale> Yuu-chan: If it was a one-off hack, you could get away with it. If it's a real program that someone's going to have to maintain, I'd avoid abusing unsafePerformIO frivolously like that. In any case, it's easy enough to avoid doing.
02:06:15 <k00mi> Yuu-chan: file IO can always go wrong, I wouldn't hide it when it happens
02:06:55 <Yuu-chan> Cale: thank you. Yes, this is mostly a toy program at the moment.
02:07:45 <merijn> Yuu-chan: Probably should avoid unsafe* in any toy program, unless it's sole purpose is to play with unsafe*
02:08:04 <merijn> Yuu-chan: While learning unsafe* usually only results in horrible confusion when things break in weird ways
02:08:18 <Yuu-chan> Okay...
02:08:48 <Cale> Yeah, if you're learning the language, you should probably try to do things the right way anyhow. It's not usually very hard to load the resources you need in main, and pass them along to where they're needed.
02:09:11 <Cale> (Sometimes it can be good to make a data type for collecting them up into a single parameter though)
02:09:35 <jle`> i wonder if there is a TH solution
02:09:50 <jle`> loading the bitmap into a bytestream or something
02:11:18 <mgsloan> Yeah, some of the yesod shakespearean templates stuff does that - the template is loaded at compile time
02:11:32 <mgsloan> Not sure if the same thing is done for serving static files, but I think it might be
02:11:39 <Yuu-chan> Cale: seems I'll end up with a solution like that.
02:12:14 <mgsloan> It wouldn't be too hard to use TH for this, but yeah, it'd be a little bit ugly.  Better to stick with prettier haskell :)
02:12:37 <rtpg> how much time does GHC take to build when it's in "quick"m ode?
02:12:40 <rtpg> mode?
02:13:01 <Yuu-chan> mgsloan: huh, how to use IO inside a Q?
02:13:03 <merijn> rtpg: Depends on the machine
02:13:07 <Cale> You mean compiling GHC itself?
02:13:18 <Cale> Yeah, it depends
02:13:19 <mgsloan> Yuu-chan: runIO
02:13:41 <merijn> rtpg: I think last time it took me somewhere around 40 minutes to an hour to compile 7.8, but I don't think I used any "quick" or whatever mode
02:13:45 <Yuu-chan> @hoogle runIO
02:13:46 <lambdabot> Language.Haskell.TH.Syntax runIO :: IO a -> Q a
02:13:47 <lambdabot> Language.Haskell.TH runIO :: IO a -> Q a
02:13:47 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
02:13:54 <Yuu-chan> Cool.
02:14:20 <mgsloan> Yuu-chan: Also, if you're loading in a file at compile time, it's best to also use "addDependentFile", so that ghc will know when it needs to recompile things
02:15:14 <rtpg> ok I was just wondering, I've heard that it takes "so long" that I was supprised it was over in an hour
02:16:05 <merijn> rtpg: I guess it depends on what you think is long :)
02:16:06 <Yuu-chan> mgsloan: thanks :)
02:16:16 <mgsloan> welcome!
02:16:39 <merijn> rtpg: I don't think I ever heard of a GHC compilation on a reasonably modern machine taking more than 2 hours. But some people think anything over 15 minutes is ages for compilation
02:17:06 <Cale> It's a waste of time if you're not actually working on GHC though
02:17:21 <Cale> (or you don't have some kind of special patch which needs applying)
02:17:38 <rtpg> is ghci built in the default build? I can't find it anywhere
02:17:54 <Cale> yes?
02:18:41 <merijn> rtpg: Did you remember to "make install" afterwards?
02:18:57 <merijn> (and did you configure your --prefix correctly?)
02:19:14 <merijn> Cale: I would say it's a waste of time *if* you're working on GHC
02:19:31 <rtpg> oh right, I could just --prefix it. I didn't want to override my install
02:19:34 <merijn> Cale: Compiling once every so often to update to HEAD is not as annoying as waiting 2 hours to see what your minor change did
02:20:00 <merijn> rtpg: The beauty is that you can simply --prefix install it and update your path and it'll Just Work (TM)
02:20:19 <rtpg> the prefix is on the configure step though right?
02:20:26 <merijn> rtpg: Yeah
02:20:27 <Cale> merijn: Well, if you're working on GHC, I don't think a small change will force a complete rebuild
02:21:30 <merijn> rtpg: Incidentally, there should be binary builds of every GHC release if you're just wanting to update GHC from the Platform. The only real reason to compile from source is if you want to patch the compiler
02:22:14 <merijn> And I believe johnw has frequent builds of HEAD lying around somewhere
02:22:52 <merijn> rtpg: Although, I think rerunning configure and rebuilding should finish almost instantly since everything is already compiled?
02:23:13 <rtpg> I'm actually thinking of trying to patch something into ghc, and looking into the internals interests me
02:23:29 <rtpg> I'm not such a masochist that I want to manually compile every program I run by hand
02:46:57 <haasn> GHC makes me feel like I have a stutter: -fforce-recomp -ddump-simpl
02:59:35 <rtpg> Is there much difference between purely functional data structures the paper and PFDS the book?
03:01:11 <gienah> rtpg: the book is like an updated version of the thesis
03:05:03 <k00mi> the book also contains haskell versions of the code
03:07:26 <rtpg> I saw that the book contains haskell version of the code . The book is on sale on amazon.com (only $9!) but I'm in france, and it's 40 euro here...
03:07:49 <gienah> in an appendix, while thoughout the book the examples are in a mythical lazy ML language
03:07:58 <rtpg> I'm really interested in the haskell examples though, the lazy ML stuff is hard to read imo
03:17:48 <hjulle> How does the Acme.RealWorld module work?
03:18:58 <merijn> hjulle: It doesn't :p
03:19:10 <merijn> hjulle: acme-anything is the category of practical jokes and terrible ideas
03:19:37 <merijn> hjulle: Hence the "ACME" name, as reference to the fictional company Wile E. Coyote uses in the Roadrunner cartoons
03:20:23 <hjulle> I was having some trouble wrapping my head around how it would store the whole universe in a variable. :/
03:21:14 <merijn> :)
03:21:25 <Yuu-chan> hjulle: is it the same one where `don't' notation is defined?
03:22:01 <arkeet> that is also an acme library yes :-)
03:22:16 <merijn> See also: acme-php :)
03:22:52 <merijn> Probably one of the better examples of the terrible ideas Haskell lets you implement :p
03:25:53 <merijn> Do we have a FuckIt.hs based on quickcheck and TH yet? :p
03:27:16 <hjulle> data Bool = TRUE | FALSE | FILE_NOT_FOUND :)
03:28:56 <t7> also   true = TRUE   but   false = False
03:29:57 <rtpg> In a world without side effects, evaluation order doesn't matter right?
03:30:05 <haasn> rtpg: correct
03:30:11 <haasn> rtpg: but be wary of strictness
03:30:31 <arkeet> and of memory usage
03:30:35 <bearclaw> in a world without side effect...what is that "evaluate" concept you are talking about?
03:30:45 <jle`> ^^
03:31:04 <haasn> I mean, I think sometimes if you change the evaluation order so that you evaluate some recursive parameter before some function application, you'll end up with an infinite loop (ie. bottom)
03:32:51 <rtpg> so the semantics can change then ...
03:32:57 <arkeet> haha, foldl' f z xs = xs `seq` foldl f z xs
03:33:27 <arkeet> notElem x ys = elem (not x) ys
03:33:59 <arkeet> reading this makes me smile.
03:34:01 <arkeet> always.
03:34:07 <arkeet> however, I should be sleeping, not smiling.
03:35:25 <magicman> @hoogle Monad m => (a -> b -> m c) -> m a -> m b -> m c
03:35:26 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
03:35:27 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
03:35:27 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
03:35:49 <haasn> rtpg: evaluation order truly doesn't matter in total (pure) languages like Agda and Idris though
03:36:05 <haasn> in fact, those are strict by default because they don't have haskell's distinction between strictness and nonstrictness
03:37:38 <hjulle> arkeet: The instances of String is lovely too.
03:37:46 <arkeet> :)
03:37:54 <donri> "not" is partial :P
03:38:17 <jle`> haha
03:39:03 <hjulle> The "prolog" functions are interesting too
03:39:34 <hjulle> "In prolog, we only need to specify the true cases, and the unifier will backtrack on false cases"
03:40:29 <donri> :D
03:41:04 <hjulle> Hmm.. what would be the logical value of "not FILE_NOT_FOUND"?
03:41:20 <donri> bottom
03:41:26 <donri> see, acme-php is sensible
03:41:59 <jle`> now :: UTCTime
03:42:01 <jle`> now = unsafePerformIO getCurrentTime
03:42:10 <asdf1234> ^ except that probably isn't now
03:42:19 <hjulle> Time is an illusion!
03:42:21 <donri> asdf1234: acme-now, joke package
03:42:24 <asdf1234> ohhh
03:42:31 <jle`> now never changes
03:42:35 <jle`> it is pure
03:42:37 <jle`> :)
03:42:47 <arkeet> it's not NOINLINE
03:42:48 <arkeet> =(
03:43:07 <donri> @hackage acme-year
03:43:08 <lambdabot> http://hackage.haskell.org/package/acme-year
03:43:08 <arkeet> maybe that doesn't matter.
03:43:23 <asdf1234> I'm a fan of acme-realworld
03:43:38 <hjulle> arkeet: Well, Einstein learnt us that time is relative, so that shouldn't be a problem.
03:44:20 <asdf1234> What's the status of GHC 7.8?
03:44:43 <donri> blocked on apple being evil
03:45:23 <asdf1234> Heh, really?
03:46:20 <jle`> Acme.LookOfDisapproval seems genuinely useful
03:46:25 <donri> yes, refusing gpl3 and breaking the c preprocessor
03:46:48 <merijn> I'm not sure refusing the gpl3 can be classed as evil
03:47:03 <asdf1234> what merijn said
03:47:07 <merijn> Have you *read* the GPL3? I would flip out if I was a corporate lawyer
03:47:44 <asdf1234> also, "breaking" the c preprocessor is a stretch.. clang's preprocessor isn't as zany as gcc's
03:47:45 <donri> not using it is one thing, refusing it all together is another
03:48:02 <merijn> donri: You don't just promise to not sue users of your code for patents covering the code, it requires you to promise not to sue users of your code for any patent violation *ever*
03:48:21 <merijn> donri: I fail to understand what you mean by refusing?
03:48:22 <donri> good, they should
03:48:34 <donri> patents are evil :)
03:48:48 <merijn> donri: What you believe is completely irrelevant for the day to day business
03:49:02 <donri> yes. day to day business tends towards evil. :)
03:49:10 <merijn> donri: MS would only have to buy a single OSX distribution to never be sued by Apple again while still being able to sue Apple
03:49:28 <merijn> donri: Provide one reason you would distribute such a license as a big company
03:49:30 <flux> gpl3 didn't think if that?
03:49:34 <donri> but i don't think gpl3 says that
03:49:36 <flux> they should have made that clause bound both parties
03:49:38 <asdf1234> I'd be surprised if gpl3 was so encompassing
03:49:53 <merijn> asdf1234: Well, no one is sure if it *can* do that
03:50:01 <merijn> asdf1234: But no one wants to try and find out it can
03:50:07 <dp_wiz> is there a cabal command to "freeze" installed packges?
03:50:14 <asdf1234> even challenging it grants gpl legitimacy, eh?
03:50:25 <merijn> asdf1234: GPL is already legit
03:50:31 <asdf1234> I mean in a legal sense
03:50:35 <merijn> asdf1234: It's been held up in courts plenty of times
03:50:39 <asdf1234> ah
03:51:15 <asdf1234> dp_wiz: you can either use cabal-dev or set up a new package repository and install your fun things over there
03:51:16 <merijn> asdf1234: There have been a couple of tens of successful GPL suits around the world, a lot in Germany but I believe there have been 3 or 4 succesful in the US
03:51:43 <dp_wiz> asdf1234: i did. but i need to extract currently-installed versions to pin them in a new sandbox.
03:51:44 <merijn> asdf1234: So no one really doubts the basic enforcability of the GPL anymore
03:51:52 <merijn> At least, not anyone who knows what they're doing :)
03:52:16 <asdf1234> All the more reason to be scared of it, I suppose! :)
03:53:01 <asdf1234> regardless, that's a shame; I'm looking forward to 7.8
03:53:24 <merijn> asdf1234: Well, it's pretty trivial to install
03:53:48 <t7> @pl f x = g x + h x
03:53:48 <lambdabot> f = liftM2 (+) g h
03:53:55 <merijn> asdf1234: You can just download the binary release of 7.8 and install it on your system. It's just platform that is stalled on the 10.9 drop of gcc
03:54:46 <asdf1234> merijn: I'll probably do that. I've actually been using llvm with ghc on OSX for the past 6 months.
03:55:09 <donri> merijn: 7.8 isn't released
03:55:30 <asdf1234> donri: while that may be true, it's fairly stable and easily accessible
03:56:46 <k00mi> is there a solution to the CPP problem?
03:57:41 <asdf1234> k00mi: use gcc's CPP
03:57:44 <donri> all that said, i think it's a good thing if ghc isn't dependent on gcc
03:57:59 <asdf1234> k00mi: or tell everyone to not use the stuff in gcc's CPP that breaks llvm's
03:58:08 <asdf1234> sorry, clang's
03:58:59 <k00mi> asdf1234: so there is no way without user intervention?
03:59:27 <asdf1234> k00mi: you can automate the use of gcc's CPP
03:59:57 <asdf1234> but essentially
04:00:11 <donri> merijn: i don't think you understand patents. patent grants only cover the licensed work, it's not a universal grant of any patents used in that work
04:00:52 <k00mi> hrm, so why is that stopping 7.8 from being released?
04:02:01 <donri> k00mi: technically it would be perfectly fine to release it and require osx users to install gcc. i guess they want to avoid that.
04:02:50 <merijn> asdf1234: I have 7.8 running on OSX 10.8 just fine, FYI
04:03:01 <k00mi> donri: but is there any hope to finding a solution that doesn't require that?
04:03:10 <asdf1234> merijn: Thanks. I'll give it a shot later today.
04:03:42 <asdf1234> donri: kinda funny considering they ship the windows platform with mingw
04:04:47 <asdf1234> k00mi: find a way to make clang's CPP compatible with gcc's without changing anything
04:05:00 <donri> ^_^
04:05:12 <k00mi> asdf1234: good luck
04:05:53 <asdf1234> k00mi: they could bundle the platform with a copy of gcc/gcc CPP I guess
04:05:54 <t7> is there unsafe map lookup
04:05:58 <merijn> Just specify a --prefix to install too in ./configure and prefix your PATH with that directory and it works
04:06:06 <rtpg> haasn, is total basically that all functions can be found as terminating statically?
04:06:11 <t7> @hoogle Map A B -> A -> B
04:06:11 <lambdabot> Data.Map.Lazy (!) :: Ord k => Map k a -> k -> a
04:06:12 <lambdabot> Data.Map.Strict (!) :: Ord k => Map k a -> k -> a
04:06:12 <lambdabot> Data.Map.Lazy findWithDefault :: Ord k => a -> k -> Map k a -> a
04:06:21 <issamou> hi guys, im having a bit of troubles in implementing simply typed lambda calculus
04:06:24 <asdf1234> t7: what does unsafe mean in this context?
04:06:40 <t7> throws when the key does not exist
04:06:54 <asdf1234> t7: why do you need to do that?
04:07:15 <t7> prototyping and cant be bothered to propogate errors at the moment
04:07:29 <asdf1234> t7: you could convert the maybe to an exception / error
04:07:45 <t7> im hoping thats what (!) does
04:08:05 <haasn> rtpg: total means has a normal form, I guess
04:08:26 <haasn> but that's pretty much the same thing, yeah
04:09:26 <rtpg> I should really study lambda calculus or something one day, I have no idea about a lot of asides made in some papers about termination or whatnot
04:10:34 <asdf1234> As someone not quite in the know, guaranteed termination would seem undesirable from a practical perspective
04:11:57 <merijn> asdf1234: Not as much as you'd think
04:11:59 <k00mi> asdf1234: requires non-turing completeness, but note you can have something like a server loop via coinduction
04:12:08 <merijn> asdf1234: Turing completeness is overrated
04:12:27 <merijn> asdf1234: And languages have a "non-termination monad" in the same way haskell has an IO monad
04:12:49 <merijn> asdf1234: So you could write "infinitely loop this terminating request" using the non-termination monad
04:13:01 <asdf1234> that's handy
04:13:03 <merijn> Also co-induction/co-data
04:13:14 <asdf1234> which languages are we talking about?
04:13:31 <merijn> Agda, Coq and Epigram are total, iirc
04:13:44 <raichoo> Idris has a "total" annotation.
04:14:19 <tdammers> I just read that as "annihilation"
04:14:21 <tdammers> :P
04:14:26 <raichoo> :D
04:15:01 <asdf1234> How does Agda compare with Coq?
04:15:14 <haasn> merijn: so are ATS, Guru, Matita, NuPRL and Twelf, to name a few more
04:15:18 <haasn> https://en.wikipedia.org/wiki/Dependent_typing#Comparison_of_languages_with_dependent_types :)
04:15:25 <merijn> haasn: Never heard of any of them :p
04:15:32 <haasn> merijn: me neither :D
04:15:39 <merijn> asdf1234: Agda compares to Coq like haskell to ocaml :p
04:15:41 <haasn> well, I've heard of ATS
04:15:57 <merijn> asdf1234: i.e. lots of the same underlying theory, but Coq/ocaml have ugly French syntax :)
04:16:12 <asdf1234> Oh, now I remember why I didn't bother with Agda. Those strange unicode symbols.. And emacs. Blegh.
04:16:35 <t7> asdf1234: you get used to it quick
04:16:58 <t7> especially when agda starts writing code for you and stuff :)
04:17:04 <gienah> there is a coq plugin for dependently typed programming with a nicer syntax: mattam.org/research/coq/equations.en.html?
04:17:50 <haasn> merijn: I thought Ocaml was quite distinct from haskell?
04:18:01 <asdf1234> t7: have any cool learning resources popped up in the past couple of years?
04:18:01 <merijn> haasn: Depends on how much you squint
04:18:21 <asdf1234> t7: wrt agda
04:18:47 <merijn> asdf1234: I think a good approach is to do advanced type hackery in Haskell until you think "if only I could write X in the type system" and then realise Agda makes writing X in the type system really easy ;)
04:18:48 <haasn> haskell is pure, nonstrict and functional; ocaml is impure, strict and object oriented - no?
04:19:24 <merijn> asdf1234: i.e. understanding higher kindedness, DataKinds, GADTs and TypeFamilies is a good road to understanding dependent types (assuming you're moderately comfortable in haskell)
04:19:29 <t7> asdf1234: most people recommend this: http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
04:19:37 <merijn> haasn: Calling ocaml OO is rather a stretch
04:19:50 <merijn> haasn: ocaml is functional
04:19:59 <merijn> haasn: It has structural subtyping, though
04:20:00 <asdf1234> merijn: heh, I've already hit that; I figure out how to build vectors at runtime.
04:20:06 <t7> merijn: i found it easier to learn the other way
04:20:06 <asdf1234> I couldn't figure out*
04:20:18 <merijn> haasn: Structural subtyping is neat, but not really OO
04:20:34 <Twey> I'm with t7: the extensions add a lot of weird syntax and special cases for things that are simple and obvious in Agda
04:20:42 <merijn> haasn: It's basically, if code works on a record with fields A and B, then it works with any record that has a superset of those fields
04:20:51 <merijn> haasn: Think of it as statically checked duck-typing
04:21:18 <k00mi> isn't that what the new record system does?
04:21:29 <Twey> Vinyl also does it
04:21:34 <merijn> k00mi: No, the new record stuff is far less ambitious
04:21:34 <Twey> (though you need an explicit cast)
04:21:36 <fjdddd> I'm trying to write some bindings for a header file that declares functions using macros, like so: FUNC_WRAPPER(foo, func_name, bar, baz);. After running gcc -E on that header I see foo func_name(bar, baz);. How can I write a binding?  Is it possible to bind to a preprocessed file? Or should I create a copy with the needed wrappers as suggested for CPP:
04:21:36 <fjdddd> http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Importing_C_functions_that_turn_out_to_be_CPP_macros
04:22:09 <haasn> merijn: sounds like OverloadedRecords :)
04:22:13 <merijn> fjdddd: Good news!
04:22:17 <asdf1234> fjdddd: you might be interested in hsc2hs
04:22:29 <merijn> fjdddd: GHC 7.6 has a new FFI calling convention that can import CPP macros!
04:22:49 <fjdddd> merijn: Yay!
04:22:49 <merijn> fjdddd: Check the manual for the "capi" calling convention, instead of the usual "ccall" calling convention
04:22:57 <fjdddd> Thanks, will do shortly.
04:23:59 <asdf1234> merijn: I could have used that a couple weeks ago.. can I import #define constants too?
04:24:14 <asdf1234> t7: thank you for the pdf link
04:24:15 <AshyIsMe> lambdabot: let foo = [("foo","bar"),("lol","bang")];  map snd foo
04:24:38 <merijn> asdf1234: Yup
04:24:49 <AshyIsMe> is lambdabot ignoring me?
04:25:12 <mr-> > let foo = [("foo","bar"),("lol","bang")] in map snd foo
04:25:13 <haasn> AshyIsMe: lambdabot doesn't accept commands like that; it also isn't GHCi
04:25:14 <lambdabot>  ["bar","bang"]
04:25:16 <merijn> asdf1234: See this example stuff: https://github.com/merijn/posix-pty/blob/master/System/Posix/Pty.hs#L224-L235
04:25:17 <fjdddd> asdf1234: I'd rather avoid using any "external tools."  I checked hsc2hs some time ago but couldn't write anything with it. Maybe I wasn't trying hard enough.
04:25:26 <AshyIsMe> ah cheers
04:25:29 <haasn> there's a @let command but that just adds definitions to a static .hs file
04:25:58 <merijn> fjdddd: hsc2hs is for writing new Storable instance for structs, which I'll admit is the most painful bit of the FFI
04:26:12 <merijn> If you can avoid custom structs you won't need to define Storable instances, though
04:26:22 <AshyIsMe> so i want to fold ++ across the snd elements of the foo list but i cant quite get it right
04:26:54 <asdf1234> foldr (++ . snd)?
04:26:59 <AshyIsMe> > let foo = [("foo","bar"),("lol","bang")] in foldl (++ . snd) "" foo
04:27:00 <lambdabot>  <hint>:1:55: parse error on input `.'
04:27:07 <merijn> > foldr (++) [] . map snd $ [("foo","bar"), ("lol","bang")]
04:27:07 <asdf1234> with an extra bit of parans
04:27:08 <lambdabot>  "barbang"
04:27:30 <fjdddd> merijn: Can I avoid writing any Storable instances if foo in the above example is actually a struct?
04:27:58 <merijn> fjdddd: You only need Storable if haskell needs to do something with the struct
04:28:13 <AshyIsMe> oh i was trying to do the compose in the foldr argument
04:28:28 <merijn> fjdddd: If you just need a pointer to the struct, then you have no problems
04:28:30 <asdf1234> merijn: not even, only if you want haskell to be able to peek and poke out of the struct
04:28:42 <asdf1234> yeah, pointers are pointers
04:28:49 <asdf1234> ashyIsMe: you can combine them
04:28:53 <merijn> asdf1234: Structs are not always pointers though :)
04:29:09 <merijn> asdf1234: Haskell can use struct pointers fine, it can't use structs without a Storable instance, though
04:29:30 <asdf1234> merijn: does haskell ever see an actual struct, though?
04:29:47 <merijn> asdf1234: If you pass it as a struct instead of a pointer, yes.
04:30:02 <AshyIsMe> oh wow, the $ just grokked for me
04:30:16 <merijn> "void foo(struct blah x);" <- this passes a struct by value, not by pointer
04:30:22 <asdf1234> ashyisMe: foldr ((++) . snd)
04:30:26 <merijn> AshyIsMe: That's what getting smarter feels like :)
04:30:55 <asdf1234> merijn: yeah, but I thought haskell would interpret that as a pointer to a spot a bit up the stack
04:31:58 <fjdddd> merijn: indeed, both functions return a pointer to a struct, and one of them gets a pointer as an argument. how should I define Ptr Foo where Foo is a struct? Will it be enough to use data Foo?  This is the first time I use the FFI...
04:32:01 <AshyIsMe> merijn: haha yeah
04:32:11 <merijn> asdf1234: Something would have to magically translate that, and there is no mogic :)
04:32:31 <AshyIsMe> haskell is starting to hint at me that it has little delicious bits
04:32:35 <merijn> fjdddd: You can just use "Ptr ()" or "Ptr Void" for void*
04:32:41 <AshyIsMe> like when you find a new little commandline trick or something
04:33:18 <merijn> fjdddd: As long as you don't use the peek/poke functions to inspect the "Ptr a" you can use whichever type you like
04:33:27 <asdf1234> merijn: I dunno. GHC seems fairly magical at times. ;P. But that's true. I guess it's partially in how C handles structs.
04:34:03 <fjdddd> merijn: Thanks again. Will give it a try soonish.
04:34:16 <fjdddd> I wouldn't be able to get anything done without your help.
04:34:25 <asdf1234> fjdddd: you could even create empty types for your pointers if you don't want to confuse them
04:34:27 <merijn> fjdddd: Basically, you can access the 'a' in "Ptr a" by using it's Storable class, but if you don't need to access 'a' you don't need a Storable class either :)
04:34:50 <asdf1234> yeah, the a in "Ptr a" doesn't do anything other than give the typechecker a hint
04:36:39 <AshyIsMe> ah and hlint let me know that concat exists too
04:36:59 <AshyIsMe> > let foo = [("a","b"),("c","d")] in concat $ map snd foo
04:37:00 <asdf1234> AshyIsMe: concat is like foldr1 (++)
04:37:00 <lambdabot>  "bd"
04:37:14 <darthdeus> if i'm getting non-exhaustive pattern error, can i somehow inspect it?
04:37:27 <asdf1234> darthdeus: look for case expressions
04:37:37 <merijn> darthdeus: No, but if you compile with warnings GHC will produce a warning with line number for non-exhaustive pattern match
04:37:53 * merijn thinks that warning should be on by default
04:37:53 <fjdddd> merijn: Also, am I right that Word8 is a Haskell version of uint8_t?
04:37:57 <darthdeus> i'm probably blind, i have a really simple match though
04:37:59 <merijn> fjdddd: Yes
04:38:02 <fjdddd> Good
04:38:12 <merijn> fjdddd: And Int8 is int8_t
04:38:18 <darthdeus> https://gist.github.com/7871575
04:38:28 <darthdeus> where Option is defined as data Option a = Some a | None deriving (Show)
04:38:31 <asdf1234> merijn: try to use Foreign.C.Types if you can
04:38:58 <merijn> asdf1234: Foreign.C.Types is for C types of unspecified length
04:39:13 <Iceland_jack> darthdeus: remove the d
04:39:15 <Iceland_jack> no sorry
04:39:22 <merijn> i.e. "int", "long", etc. for uint8_t it makes no sense
04:39:22 <asdf1234> darthdeus: you might like the maybe function from Data.Maybe
04:39:38 <merijn> darthdeus: Compile with -Wall ?
04:39:45 <arkeet> and also fromMaybe
04:39:46 <darthdeus> asdf1234: yeah i know about maybe :P i'm following a book that has an excercise to re-implement the scala's Option
04:39:46 <arkeet> :t maybe
04:39:47 <lambdabot> b -> (a -> b) -> Maybe a -> b
04:39:48 <arkeet> :t fromMaybe
04:39:49 <lambdabot> a -> Maybe a -> a
04:39:57 <fjdddd> merijn, asdf1234: There was a thread on the haskell-cafe list about adding uint8_t to Foreign.C.Types.
04:40:04 <merijn> darthdeus: Also, include the definition for the Option type?
04:40:05 <Iceland_jack> darthdeus: it should work, it does here
04:40:19 <Iceland_jack> @let data Option a = Some a | None
04:40:21 <lambdabot>  Defined.
04:40:24 <merijn> darthdeus: Are you sure this is where the match failure is?
04:40:35 <quchen> It's a very awkward pattern match warning.
04:40:44 <darthdeus> merijn: well i load it into repl and type getOrElse None 5
04:40:48 <darthdeus> and get pattern match error
04:40:48 <Iceland_jack> > let { getOrElse (Some x) _ = x; getOrElse None d = d } in getOrelse (Some 5) 10
04:40:50 <lambdabot>  Not in scope: `getOrelse'
04:40:50 <lambdabot>  Perhaps you meant `getOrElse' (line 1)
04:40:59 <Iceland_jack> > let { getOrElse (Some x) _ = x; getOrElse None d = d } in getOrElse (Some 5) 10
04:40:59 <quchen> Pattern match(es) are non-exhaustive    In an equation for `getOrElse': Patterns not matched: None _
04:41:00 <lambdabot>  5
04:41:10 <arkeet> it's a typo
04:41:12 <arkeet> gerOrElse
04:41:27 <quchen> Haha :-D
04:41:42 <darthdeus> i dont see a typo :O
04:41:43 <darthdeus> wat
04:41:51 <asdf1234> "gerOrElse None d = d"
04:41:57 <AshyIsMe> oh wow hlint is good
04:41:58 <quchen> geRRRRorelse
04:42:02 <AshyIsMe> "why not concatMap?"
04:42:18 <Iceland_jack> > "ge" ++ repeat 'R' ++ "OrElse"
04:42:20 <lambdabot>  "geRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR...
04:42:31 <darthdeus> oh lol
04:42:32 <darthdeus> :D
04:42:40 <asdf1234> clam down, lambdabot
04:42:48 <arkeet> I like clams
04:42:58 <merijn> AshyIsMe: There's an offline binary for hlint too, btw
04:43:04 <issamou> hi :), I'm confused about the 'Eval' in lambda calculus
04:43:06 <darthdeus> i need to turn on hlint in emacs somehow
04:43:09 <AshyIsMe> merijn: yeah ive got it hooked up in vim
04:43:16 <asdf1234> merijn: I can never get hlint to compile :(
04:43:40 <issamou> http://pastebin.com/Sj3L2nKN
04:43:41 <AshyIsMe> every time i save the file in runs
04:43:42 <mauke> The paste Sj3L2nKN has been copied to http://lpaste.net/96782
04:43:44 <issamou> this is my implementation
04:44:03 <issamou> and im trying to implement the rules for eval: "https://dl.dropboxusercontent.com/u/30688032/lambda.png"
04:44:44 <issamou> but for example, "let t2_prime = evaluate t2 in App v t2_prime" what if t2 is (Var "x") then how would this continue?
04:45:02 <arkeet> it doesn't.
04:45:14 <asdf1234> slightly off-topic: what does the sideways T mean in type notation?
04:45:20 <merijn> asdf1234: "entails"
04:45:27 <issamou> entails
04:45:29 <merijn> asdf1234: It's somewhat like implication in logic
04:45:33 <issamou> but the typing im done with it
04:45:43 <issamou> my problem is on the Eval :) :)
04:45:45 <merijn> asdf1234: Or "it follows from"
04:45:56 <asdf1234> merijn: so like, this is a rule and here's why: ... ?
04:46:06 <Iceland_jack> issamou: The typing? is it the untyped lambda calculus or a typed one?
04:46:13 <issamou> simply typed
04:46:16 <issamou> lambda calculus
04:46:20 <issamou> can you see the image?
04:46:36 <merijn> asdf1234: The first one reads as follows: "if x:T is in the set Gamma, then x:T follows from Gamma"
04:46:45 <issamou> ah cool
04:46:56 <issamou> yah, im sorry i put the red box in the wrong place
04:47:03 <issamou> im referring to E-app1
04:47:05 <issamou> E-app2
04:47:07 <merijn> asdf1234: Above the line are the preconditions, below the conclusions
04:47:19 <issamou> and E-appAbs
04:47:22 <issamou> the beta reduction
04:47:23 <merijn> asdf1234: So from the top line we can conclude the bottom line
04:47:27 <issamou> yes
04:47:32 <issamou> premise to conclusion
04:47:45 <issamou> this is how i implemented it for evaluation
04:47:46 <issamou> http://pastebin.com/Sj3L2nKN
04:47:46 <mauke> The paste Sj3L2nKN has been copied to http://lpaste.net/96782
04:48:03 <asdf1234> merijn: thank you ;P I could use a crash-course in reading the notation
04:48:26 <issamou> but the problem is
04:48:31 <issamou> what if I have this test case
04:48:41 <issamou> print (evaluate (App (Constant 3) (Var "y"))
04:48:49 <issamou> Where (Constant 3) is a value 'v'
04:48:59 <issamou> and (Var "y") is a term 't2'
04:49:15 <Iceland_jack> issamou: There is no “constant” there
04:49:24 <Iceland_jack> a value is *only* a lambda abstraction
04:49:36 <merijn> Iceland_jack: Wrong, it's STLC, not UTLC
04:49:53 <issamou> its confusing i know, sometimes its put with a constant c
04:49:53 <merijn> Simply Typed Lambda Calculus has values
04:49:58 <issamou> ah cool
04:50:03 <issamou> thanks for the confirmation
04:50:04 <issamou>  :)
04:50:12 <Iceland_jack> merijn: Not on the picture he sent from TACP
04:50:29 <Iceland_jack>     v ::= λx:T.t
04:50:35 <merijn> Oh, I didn't read that :p
04:50:54 <asdf1234> what is TACP, out of curiosity?
04:50:54 <Iceland_jack> s/he/they/
04:50:56 <quchen> He even gives an exercise about this later ("there are no values, why?")
04:50:57 <merijn> issamou: "App (Constant 3) (Var "y")" <- isn't this a type error
04:51:06 <issamou> why?
04:51:12 <tovarish> there is no type error in lambda calculus
04:51:19 <merijn> tovarish: There is in STLC
04:51:26 <merijn> tovarish: That's why it's called that...
04:51:35 <tovarish> merijn, :)
04:51:52 <quchen> It's TAPL (Types and Programming Languages), not TACP (The Art ??? Computer Programming) by the way.
04:51:55 <merijn> issamou: Well, aren't you applying the "Constant 3" to "Var 'y'"?
04:51:57 <Iceland_jack> quchen: oops, yes
04:52:00 <Iceland_jack> meant TAPL
04:52:08 <Iceland_jack> by Pierce
04:52:19 <merijn> issamou: You can only apply functions
04:52:22 <issamou> http://pastebin.com/Fj3w4L8T
04:52:27 <mauke> The paste Fj3w4L8T has been copied to http://lpaste.net/96783
04:52:28 <issamou> here is the complete code
04:52:33 <asdf1234> quchen, Iceland_jack: thank you!
04:52:35 <issamou> with the terms and types i defined
04:52:58 <issamou> well
04:53:01 <issamou> its in the picture
04:53:06 <issamou> or the table
04:53:12 <issamou> v t2 -> v t2'
04:53:14 <merijn> issamou: The picture doesn't have "Constant", though
04:53:16 <issamou> thats application right?
04:53:41 <merijn> issamou: So it's right in the picture, because in the picture only functions are values
04:53:43 <issamou> yah its similar to what im trying to implement
04:53:47 <issamou> its only missing the constants :)
04:53:52 <fjdddd> merijn: I tried to bind #define max(A, B) ((A) > (B) ? (A) : (B)) like so: foreign import capi "test.h max" c_max :: a -> a -> a but got the Unacceptable {argument,result} type in foreign declaration errors. What's wrong?
04:54:06 <merijn> issamou: The addition of constants means you have to properly type check
04:54:19 <issamou> even in evaluation?
04:54:37 <merijn> issamou: improperly typed functions can't be evaluated
04:55:05 <asdf1234> fjdddd: is that a c function? it just looks like an expression
04:55:19 <merijn> fjdddd: Only some types are allowed in FFI functions (the GHC manual specifies which), 'a' is not one of them
04:55:38 <fjdddd> Ah, ok.
04:55:44 <merijn> fjdddd: The problem is that you can't really import a polymorphic compare like that
04:55:45 <asdf1234> That makes sense, then
04:56:12 <issamou> so how would I check?
04:56:13 <merijn> fjdddd: You could use a specific numeric type or pointers (but pointers wouldn't make sense to compare like that)
04:56:17 <issamou> :)
04:56:35 <merijn> asdf1234: capi lets you import macros in addition to functions
04:56:46 <fjdddd> merijn: Trying with CInt...
04:56:48 <merijn> issamou: That's what the entire TaPL book is about :)
04:57:10 <darthdeus> can i somehow run ghci so that when i :l a file it will have the warnings enabled?
04:57:28 <merijn> darthdeus: Yes, you can pass warning flags to ghci on startup, iirc
04:57:32 <issamou> okay
04:57:35 <issamou> assume i have this test case
04:57:40 <issamou> print (evaluate (App (Var "x") (Var "y")))
04:57:51 <issamou> this should invoke the third case in the code right?
04:58:18 <merijn> issamou: Yes
04:58:33 <issamou> but in "let t1_prime = evaluate t1 in App t1_prime t2"
04:58:33 <asdf1234> darthdeus: :set -Wall
04:58:43 <darthdeus> perfect :) thanks guys
04:58:46 <issamou>  evaluate t1 becomes evaluate (Var "x")
04:58:58 <issamou> for which there is no case :(
04:59:01 <quchen> I'm halfway through TAPL and I still don't understand the Var rule [ x : T ∈ Γ  |  Γ ⊢ x : Γ ]  :-(
04:59:18 <merijn> quchen: That doesn't look right
04:59:24 <merijn> Is the last Gamma supposed to be T?
04:59:30 <quchen> Yes, woops.
04:59:44 <merijn> quchen: What is there not to understand? It's almost trivial
04:59:47 <quchen> Got carried away LaTeχing in XChat :-)
05:00:01 <issamou> <quchen> it simply means, if the type of x belongs to Gamma (or Context)
05:00:07 <issamou> then return the type of x as T
05:00:08 <quchen> merijn: Exactly. It looks like a tautology to me: if x is in the context then the context contains x
05:00:10 <merijn> quchen: If there is a variable "x : T" in Gamma, then we're allowed to conclude that
05:00:32 <merijn> quchen: Yes
05:00:52 <asdf1234> now prove it ;)
05:00:53 <fjdddd> merijn: CInt works, but it would be much better to convert it to Int, which is not safe according to http://www.haskell.org/haskellwiki/FFI_Introduction. Is there a workaround?
05:00:58 <quchen> merijn: Yes??
05:01:01 <issamou> so what about  "let t1_prime = evaluate t1 in App t1_prime t2" when t1 is a terminal?
05:01:13 <issamou> like (Var "x")
05:01:24 <merijn> fjdddd: You mean you want Int to use in the Haskell code?
05:01:28 <asdf1234> fjdddd: CInt and Int may not be the same length
05:01:31 <quchen> merijn: Is it like the entry way to the "⊢" domain?
05:01:40 <fjdddd> merijn: Yep.
05:01:47 <merijn> quchen: Yeah
05:01:55 <quchen> Well that's anticlimatic
05:01:57 <merijn> fjdddd: The problem is that Int may be shorter than CInt
05:01:59 <quchen> But thank you :-)
05:02:13 <merijn> fjdddd: In fact, I had to fix a bug in the GHC runtime related to a conversion that did this wrong >.>
05:02:25 <merijn> fjdddd: You *could* convert it to Integer safely, though
05:02:45 <fjdddd> Ok.
05:02:47 <mr-> quchen: math and CS.. a constant source of disappointment (via demystification)
05:02:54 <asdf1234> fjdddd: or the largest int your platform supports, I guess
05:02:58 <merijn> fjdddd: Just use fromIntegral to convert CInt into Integer
05:08:25 <asdf1234> merijn: is there a tool to automagically generate haskell bindings to C functions?
05:09:27 <fjdddd> asdf1234: I failed to find one last week.
05:10:37 <asdf1234> fjdddd: seems like it should be doable..
05:10:43 <gienah> c2hs can parse C headers and help with the bindings
05:11:05 <merijn> asdf1234: Define "generate bindings"?
05:11:33 <merijn> asdf1234: If they just use pointers and standard C datatypes you only need to do an FFI import for them to work?
05:11:37 <asdf1234> merijn: create the ffi declarations for me instead of having me go through and import each function
05:12:04 <asdf1234> merijn: I'm a lazy man.
05:12:33 <asdf1234> I suppose side effects are problematic
05:12:41 <asdf1234> and knowing whether the function is reentrant
05:13:19 <asdf1234> Maybe there's some sort of analysis that can determine that..?
05:17:27 <asdf1234> merijn: mostly wondering because I want to try to use cocoa from haskell, and creating c wrappers for objc methods and then importing all of those would be tedious
05:18:08 <piezoid> hi everyone !
05:18:13 <asdf1234> hello
05:18:14 <asdf1234> !
05:18:24 <piezoid> is there a equivalent to MVar for ST ?
05:18:36 <asdf1234> STRef
05:18:49 <asdf1234> try Data.STRef
05:18:55 <seanparsons> I get the feeling that I don't quite understand the () type in Haskell: https://gist.github.com/seanparsons/8af5b2dee6c50e7a7d50
05:18:55 <seanparsons> Anyone got any clues as to what I'm doing wrong?
05:18:56 <piezoid> STRef is not blocking
05:19:22 <asdf1234> piezoid, why are you blocking on a STRef? >.<
05:19:27 <asdf1234> or trying to, rather
05:19:37 <benj_> seanparsons, s/=>/->/ :)
05:19:48 <Iceland_jack> seanparsons: Nothing to do with (), just what benj_ said
05:20:06 <seanparsons> Gah.
05:20:22 <asdf1234> piezoid: mvars are there for blocking
05:20:30 <asdf1234> (sorta)
05:20:31 <piezoid> asdf1234: I'm trying to get atomic modifications on MVector entries
05:20:43 <seanparsons> Wait, what is the different between => and -> in this context?
05:20:57 <asdf1234> piezoid: that sounds very IO-ish to me
05:21:00 <watermind> the convention is that  ΑxB -> CxD means  (ΑxB) -> (CxD), right? or am I getting confused? on the one hand that's how I think it is, on the other it'd be sensible for exponential to have  a higher precedence, so I'm getting confused
05:21:02 <benj_> typeclass constraints go on the left hand side of =>
05:21:12 <Iceland_jack> watermind: It is
05:21:23 <Iceland_jack> A×B → C×D is (a, b) → (c, d) in Haskell
05:21:27 <seanparsons> Ah of course, I'm an idiot.
05:21:48 <watermind> Iceland_jack: yes I know, but in haskell there's no precedence issues because of the sintax
05:21:48 <asdf1234> piezoid: you can convert an ST operation to an IO operation if you need
05:21:49 <piezoid> asdf1234: oh yes, because threads can't share a ST world ?
05:21:54 <seanparsons> Interesting how some other functions have not cause me any issues with that!
05:22:12 <Iceland_jack> I didn't say where wasn't
05:22:22 <asdf1234> piezoid: the s part of ST s can escape with an mvar
05:22:27 <asdf1234> piezoid: which defeats the purpose of ST
05:22:39 <asdf1234> piezoid: anything across threads is going to be inherently IO, I think
05:22:44 <watermind> Iceland_jack: right
05:22:54 <Iceland_jack> *there
05:23:02 <piezoid> asdf1234: ok thanks
05:23:09 <benj_> seanparsons, I vaguely remember there was a bug once, where people found they could sometimes substitute => for ->
05:23:43 <watermind> Iceland_jack: on the one hand it is rather convenient to have exponential with lower precedence, on the other it is kind of weird to have x and + with higher precedence than exponentials... :L
05:23:55 <seanparsons> Yeah, I had _lots_ of functions where I'd gotten the two mixed up and it was working fine.
05:24:11 <fjdddd> merijn: OK, I know how to bind to #defines, but is it possible to bind to a postprocessed function? E.g., instead of binding to FUNC_WRAPPER(foo, func_name, bar, baz);, can I bind to foo func_name(bar, baz);?  (The latter is the postprocessed version.)
05:24:41 <Iceland_jack> watermind: Try writing some type signatures with a reverse precedence ;P
05:25:32 <watermind> Iceland_jack: I know :/
05:25:43 <watermind> parenthesis everywhere
05:25:53 * hackagebot parsec 3.1.4 - Monadic parser combinators  http://hackage.haskell.org/package/parsec-3.1.4 (AntoineLatter)
05:26:34 <asdf1234> fjdddd: how does the C program handle that? does it return a function pointer?
05:27:11 <fjdddd> asdf1234: I don't understand the question. How does it handle what specifically?
05:27:24 <asdf1234> what does the #define return?
05:27:42 <asdf1234> are you assigning the return value to something?
05:28:50 <fjdddd> asdf1234: In the above example, the return type is determined by the first argument of FUNC_WRAPPER.
05:29:00 <fjdddd> Does it answer your question?
05:29:41 <asdf1234> fjdddd: not really, but I'm not sure what I was asking at this point
05:29:47 <fjdddd> haha
05:29:53 <asdf1234> fjdddd: heh, have you tried it?
05:30:08 <merijn_> fjdddd: The fact that a function is defined using macro's is irrelevant to haskell
05:30:20 <merijn_> fjdddd: In the compiled binary there is just a function symbol and GHC uses that
05:30:43 <merijn_> fjdddd: Haskell doesn't parse the C source (well, it checks the function type for you if you provide a header file)
05:30:55 <merijn_> fjdddd: The actual textual definition of the function is irrelevant to GHC
05:31:12 <fjdddd> merijn_: Hm, then I'm simply incorrectly building the resulting binary.
05:31:18 <quicksilver> well that's not true
05:31:27 <quicksilver> there is also the new ffi binding method
05:31:30 <tdammers> a #define doesn't really return anything... it's just a text-based search-and-replace, really
05:31:30 <tdammers> it literally just replaces source code at the text level
05:31:37 <quicksilver> for which the C compiler approach does matter
05:32:03 <merijn_> quicksilver: Sure, but not in sense that macro definition matters for a real function
05:32:15 <asdf1234> merijn_: so I could import any call and as long as it follows whatever calling convention, ghc will just use the symbol?
05:32:17 <merijn_> As long as the code the macro produces for that function matches your type on the haskell side
05:32:24 <merijn_> asdf1234: Yes
05:32:29 <quicksilver> you have two approaches
05:32:32 <merijn_> asdf1234: GHC just links with the C binary
05:32:40 <quicksilver> you can use old-style FFI to link direct to the exported symbol
05:32:53 <merijn_> asdf1234: Unless you use the capi, in which it compiles a wrapper function (thus allowing access to macros, etc.)
05:32:54 <quicksilver> and ignore the #defines which don't matter -a ll that matters is what actually gets linked
05:32:58 <asdf1234> merijn_: interesting... is there a way to specify the calling convention?
05:33:08 <quicksilver> or you can use the capi-style FFI which actually compiles a smalls tub
05:33:11 <quicksilver> ...small stub...
05:33:12 <merijn_> asdf1234: Yes, the calling convention is part of the foreign import syntax
05:33:22 <quicksilver> which then means you can use macros if that is more convenient.
05:33:24 <asdf1234> merijn_: can I create my own calling convention?
05:33:48 <merijn_> asdf1234: Yes, if you patch ghc
05:33:52 <asdf1234> merijn_: bummer
05:34:23 <merijn_> asdf1234: Hence why most FFI interaction goes through C, every language just implements a C FFI and everyone uses that
05:34:36 <merijn_> asdf1234: You could implement a custom python FFI or whatever if you felt like it
05:34:44 <asdf1234> merijn: true enough
05:35:19 <asdf1234> merijn: if I wrote assembly that used the c calling convention, could I import it as a ccall?
05:35:47 <merijn> asdf1234: Sure
05:35:55 <jmcarthur_mobile> asdf1234: if you are trying to interface with python, there is a library for loading the python runtime and calling python functions through it. I forget the name
05:36:07 <chrisdone> missingpy
05:36:28 <asdf1234> merijn: cool, I've been wondering if there was a way to do that
05:36:29 <merijn> asdf1234: You can import anything as ccall as long as the actual binary does indeed behave like C calling convention :)
05:36:38 <chrisdone> http://hackage.haskell.org/package/MissingPy
05:36:44 <jmcarthur_mobile> Maybe I read too much from what Merion said though
05:36:57 <jmcarthur_mobile> merijn*
05:37:04 <asdf1234> merijn: that's really cool; is there documentation on the ccall convention ghc uses?
05:37:09 <chrisdone> jmcarthur: Merion Baggins?
05:37:19 <merijn> asdf1234: The same one as gcc/clang use for C
05:37:30 <jmcarthur_mobile> chrisdone: Yay SwiftKey...
05:37:56 <merijn> asdf1234: GHC uses a different one for haskell code, but once you do a foreign import it will rework the stuff to call the foreign imports using the standard C calling convention
05:38:13 <asdf1234> merijn: right
05:38:33 <asdf1234> merijn: if only there were a standard c calling convention :P
05:39:11 <merijn> Well there's only like 3 anyone cares about, no?
05:39:40 <merijn> Windows, i386 and x86_64? I'm not even sure windows still has it's own calling convention
05:40:00 <fjdddd> merijn: Hm, so I have foreign import ccall "test.h foo" foo :: ... in Test.hs, which I'm trying to build like so: ghc -I/usr/local/include --make -main-is Test Test.hs, but I'm hitting the undefined reference errors. Any ideas?
05:40:26 <merijn> Paste the error on lpaste?
05:40:51 <merijn> fjdddd: Actually
05:41:02 <merijn> fjdddd: You need to actually compile and link the relevant C code :p
05:41:49 <merijn> fjdddd: If you use cabal you can get cabal to compile your C code for you
05:42:40 <asdf1234> merijn: it seems Windows has its own x86_64 calling convention :( .. so that's 4 if we ignore non-intel/amd chips
05:43:49 <merijn> asdf1234: GHC is still working on ARM, so there's not that many other things to worry about in haskell anyway :p
05:44:22 <fjdddd> merijn: I'm not sure what "compile and link the relevant C code" means in this context. I'm trying to write bindings to a C library, which is installed system-wide, so I have the relevant bits in /usr/local/include and /usr/local/lib. Do I need anything else?
05:44:28 <asdf1234> merijn: true enough :P
05:45:02 <asdf1234> fjdddd: you need to include the libraries in the ghc compile prompt
05:45:05 <merijn> fjdddd: You need to pass GHC "-lname" to link the library
05:45:27 <merijn> fjdddd: i.e. if you wanna link with libevent you'd pass -levent to GHC
05:45:51 <fjdddd> merijn: Wow!
05:46:25 <merijn> (and maybe -L/usr/local/lib to specify the library location)
05:46:50 <asdf1234> I'm surprised that isn't passed by default.
05:47:00 <merijn> asdf1234: It might be
05:47:09 <merijn> asdf1234: cabal passes locations by default, for example
05:47:54 <fjdddd> merijn: Yeah, I tried to use -L/usr/local/lib, but it failed to build. I'm puzzled, why does -ltest work?
05:48:08 <asdf1234> which libtest?
05:48:28 <asdf1234> (by which I mean is libtest in /usr/local/lib)
05:49:08 <merijn> fjdddd: -L specifies the location to use, -ltest basically says "link with the libtest library"
05:49:33 <merijn> fjdddd: Well, GHC is not telepathic, how is it supposed to know foo is defined in libtest if you don't tell it that? :)
05:49:50 <asdf1234> merijn: by search every symbol in every library!
05:49:53 <asdf1234> searching*
05:49:55 <merijn> fjdddd: The -l flags tell it "search these libraries for symbols"
05:50:45 <fjdddd> asdf1234: there are libtest.a and libtest.so in /usr/local/lib, but when I pass -L /usr/local/lib it fails.
05:51:07 <merijn> fjdddd: -L doesn't tell it to actually look inside the libraries
05:51:17 <merijn> fjdddd: -L says "libraries can be found here"
05:51:25 <merijn> fjdddd: -L says "look inside this library"
05:51:27 <merijn> eh
05:51:28 <merijn> -l
05:51:29 <fjdddd> Ah, so -L and -l are not interchangeable?
05:51:30 <asdf1234> I think it means then that when you pass -lfoo, you don't need to use the full path for it
05:51:33 <merijn> fjdddd: No
05:51:40 <fjdddd> OK, got it.
05:53:52 <t7> @pl (\c _ -> f a c)
05:53:53 <lambdabot> const . f a
05:54:26 <tomejaguar> I write 'concat' so much that I can't spell "contact" any more.
05:54:55 <fjdddd> Oh, the haskell wiki doesn't allow to automatically create an account. Is it a way to protect from spam?
05:55:16 <chrisdone> yeah
05:55:57 * hackagebot unique-logic-tf 0.4.1 - Solve simple simultaneous equations  http://hackage.haskell.org/package/unique-logic-tf-0.4.1 (HenningThielemann)
05:56:09 <exicer> Which of the emacs modes for haskell is considered to be the best ?
05:56:19 <asdf1234> exicer: vim ;p
05:56:55 <exicer> asdf1234: I usually use vim, want to try evil mode!
05:56:56 <Joshy> Guys, my names Josh. I  released a MMORPG on the 5th called Helbreath. I would love your feedback on the website and the game its self >> http://hbserver.org
06:00:49 <chrisdone> exicer: of what set of choices?
06:00:58 * hackagebot Bookshelf 0.4 - A simple document organizer with some wiki functionality  http://hackage.haskell.org/package/Bookshelf-0.4 (EmilAxelsson)
06:02:02 <quicksilver> exicer: there is only one haskell mode.
06:02:17 <quicksilver> exicer: however there are a variety of modules which work with it to make it more awesome
06:02:28 <exicer> chrisdone: quicksilver: I see there is ghc-mod and haskell-mode, but I'm not quite clear on the differences
06:02:33 <quicksilver> the way to tell how awesome the extra modules are is to ask if they were written by chrisdone, or if he helped.
06:02:49 <donri> \o/
06:03:06 <donri> not sure ghc-mod is a "mode"
06:03:11 <donri> or is it?
06:03:22 <exicer> donri: I'm possibly messing up emacs terminolgoy ;p
06:03:40 <exicer> It seems like you have to enable ghc-mod somehow though
06:03:44 <exicer> the frontend, that is
06:03:51 <exicer> and it is an extension of haskell-mode
06:03:58 <donri> i guess it's part a (minor?) mode
06:04:34 <chrisdone> quicksilver: haha, too kind =p
06:04:40 <asdf1234> well if it's an extension, use both?
06:05:35 <chrisdone> exicer: yeah, ghc-mod is intended as an enhancement to haskell-mode
06:05:39 <exicer> asdf1234: True. Also there is scion, which I forgot to mention :P
06:05:52 <chrisdone> exicer: hdevtools is similar
06:06:09 <exicer> Amongst these, would you reccommend any in particular ?
06:06:25 <donri> what does ghc-mod add in emacs given the existing repl integration?
06:06:56 <chrisdone> ghc-mod, hdevtools and scion all add the one interesting feature that ghci doesn't do -- type of sub-expressions
06:07:09 <donri> ah right
06:07:45 <bartavelle> (and this is incredibly handy)
06:08:05 <donri> do you have to write the buffer for that in emacs?
06:08:10 <chrisdone> exicer: scion i think is dead, largely its functionality supplanted by ghc-mod and hdevtools. it's my understanding that hdevtools is faster and from what i read of the code, more comprehensive, than ghc-mod. johnw likes that one a lot
06:08:34 <chrisdone> donri: hm?
06:08:38 <donri> hdevtools doesn't seem maintained though :(
06:09:09 <donri> chrisdone: in vim you have to write the buffer before you can inspect types etc with ghc-mod or hdevtools
06:09:35 <donri> which is annoying. though not sure how to reliably make it work without that. if you write a tempfile then you mess up the load path etc, i guess
06:09:35 <chrisdone> oh you mean save it to a file
06:09:38 <donri> yeah
06:10:15 <chrisdone> don't know. flycheck, for example, writes to a temporary file and checks that instead. haven't used hdevtools, though i might play around with it
06:11:04 <exicer> chrisdone: It looks like hdevtools is used through flycheck - is that correct ?
06:11:14 <chrisdone> last time i tried to use it, i couldn't specify the package conf i wanted, which was annoying
06:11:21 <chrisdone> exicer: indeed
06:11:47 <donri> ghc-mod supposedly handles cabal sandboxes automatically, and hdevtools requires some custom setup for it
06:12:18 <alpounet> chrisdone: the clone in IDE feature on lpaste is pretty cool :-)
06:12:35 <chrisdone> alpounet: :3
06:13:34 <chrisdone> it seems to be a nice idea would be to patch hvr's ghci-ng to also support type of sub-expression
06:13:48 <chrisdone> and then get it merged into head
06:14:06 <donri> that sounds nice yeah
06:14:17 <chrisdone> e.g. :type LINE COL [LINE-TO] [COL-TO]
06:14:22 <chrisdone> or something
06:14:35 <chrisdone> :span-type
06:16:00 <exicer> Is there some nice way of using eg yesod with angular ?
06:16:12 <exicer> As in, generating js
06:16:59 <donri> hm wasn't there a fay-angular project
06:17:15 <liter> Good morning
06:18:29 <exicer> donri: Doesn't look like it is that active :s
06:18:31 <liter> About GHC: when is the ByteCodeGen phase used? Only for GHCI, or also for other cases (like hi file generation..)?
06:19:02 <donri> liter: also try #ghc if you don't get an answer in here
06:19:41 <liter> donri: Thanks, will see
06:22:13 <asdf1234> grumble grumble.. hlint installation places binaries in hard-coded paths
06:22:58 <asdf1234> oh, nevermind
06:27:29 <quchen> Namely ~/.cabal/bin
06:27:55 <asdf1234> I think it's set in ~/.cabal/config
06:28:04 <asdf1234> I forgot that I had it linked to another directly
06:28:15 <asdf1234> cabal whined to me about the link not being in the system path when it actually is
06:28:36 <asdf1234> to another directory*
06:31:02 * hackagebot unix-process-conduit 0.2.2.1 - Run processes on Unix systems, with a conduit interface  http://hackage.haskell.org/package/unix-process-conduit-0.2.2.1 (MichaelSnoyman)
06:35:12 <asdf1234> does pipes safe release resources promptly now?
06:36:01 <quchen> asdf1234: Tekmo is the right person to ask this
06:36:07 <quchen> (Not online at the moment though)
06:36:37 <asdf1234> quchen: thanks
07:07:44 <mikeplus64> @type f
07:07:46 <lambdabot> FromExpr a => a
07:10:29 <joejev> is there a way to make an optional dependecy for a library?
07:10:53 <Clint> with cabal flags?
07:11:07 <joejev> like, if you wrote a function, make it able to take a Text, String, or ByteString without making Text and Bytestrings dependancies
07:11:45 <joejev> Clint: and yes, if it was a package that was installed with cabal
07:14:55 <viran> mm, off topic. I need to show that a 1-tape turing machien can simulate a 2-tape turing machine, any idea how? :/
07:15:31 <joejev> viran: do you need to implement this? or just prove it somehow?
07:15:49 <viran> joejev: just to prove it
07:16:12 <merijn> viran: create 2 tapes by treating all "even" spaces as tape 1 and all odd spaces as tape 2?
07:16:26 <fjdddd> merijn: turns out I have to look inside ptr.
07:16:56 <merijn> fjdddd: Ah, then you're stuck having to implement a Storable instance. If you're lucky you can autogenerate one using c2hsc
07:18:16 <fjdddd> merijn: has anything changed recently in this regard? will this work: http://www.haskell.org/haskellwiki/FFICookBook#Working_with_structs?
07:18:30 <viran> merijn: thanks
07:21:08 * hackagebot hPDB-examples 1.1.1 - Examples for hPDB library  http://hackage.haskell.org/package/hPDB-examples-1.1.1 (MichalGajda)
07:21:10 * hackagebot Octree 0.5.2 - Simple unbalanced Octree for storing data about 3D points  http://hackage.haskell.org/package/Octree-0.5.2 (MichalGajda)
07:21:12 * hackagebot FenwickTree 0.1.1 - Data structure for fast query and update of cumulative sums  http://hackage.haskell.org/package/FenwickTree-0.1.1 (MichalGajda)
07:23:12 <merijn> fjdddd: That should work, but my own first couple of attempts took quite a bit of messing around and fiddling before I got it too work
07:23:27 <Clint> joejev: then you can use cabal flags, but i think that violates some policy somewhere
07:24:32 <dcoutts> joejev: you're allowed to have optional dependencies, however libraries are not allowed to change their external API based on flags.
07:24:35 <merijn> joejev: You shouldn't use cabal flags, a more common approach is to make it work with String and then have "mylib-extras" as a separate package providing ByteString/Text versions
07:25:00 <dcoutts> in the case of text & bytestring however, they're core libs and there's no problem with just depending on them
07:25:01 <merijn> OTOH, almost any application will already use ByteString/Text so one might as well depend on those
07:25:20 <fjdddd> merijn: Meh, I can't even run c2hsc... What should I specify as a prefix if test.h is in the current directory?
07:25:39 <merijn> fjdddd: c2hsc is a separate program it doesn't install with GHC :)
07:25:42 <merijn> @hackage c2hsc
07:25:42 <lambdabot> http://hackage.haskell.org/package/c2hsc
07:25:57 <viran> merijn: any idea how a regular TM could simulate a 2D TM? 2D TM can go up/down/left/right on it's single tape...
07:26:09 * hackagebot haskell-names 0.3.2.2 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.3.2.2 (RomanCheplyaka)
07:26:24 <fjdddd> merijn: I know. I installed it, but it requires the --prefix argument. What should I specify?
07:26:49 <merijn> viran: Build those some instructions inside TM i.e. have "left/right" go two spaces to stay on odd/even and have up/down go 1 space to switch between odd and even
07:27:01 <merijn> fjdddd: Just . should work, I think?
07:27:01 <fjdddd> merijn: E.g., c2hsc test.h returns c2hsc: Please specify a module prefix to use with --prefix
07:27:17 <fjdddd> merijn: Nope, doesn't work.
07:27:22 <byorgey> merijn: I think viran is talking about a fully 2D TM now, not just a 2-tape TM
07:27:30 <byorgey> i.e. a cartesian grid instead of a tape
07:27:32 <merijn> oh
07:27:44 <merijn> You'd have to invent an indexing scheme, then
07:27:44 <byorgey> viran: is this homework?
07:27:58 <merijn> fjdddd: I used this in the past: https://github.com/merijn/SNet2.0/blob/master/Setup.hs
07:28:11 <fjdddd> merijn: I'm getting "gcc: error: : No such file or directory", then "c2hsc: Failed to run cpp: ExitFailure 1"
07:28:13 <viran> byorgey: no, midterm prep
07:28:18 <byorgey> viran: OK
07:28:20 * fjdddd looks
07:28:50 <byorgey> viran: do you know the standard proof that the integers and the rational numbers have the same cardinality?
07:29:13 <t7> @hoogle [a] -> Int -> Maybe a
07:29:14 <lambdabot> Prelude (!!) :: [a] -> Int -> a
07:29:14 <lambdabot> Data.List (!!) :: [a] -> Int -> a
07:29:14 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
07:29:26 <viran> byorgey: yes
07:29:33 <byorgey> viran: OK, well, that's a hint =)
07:29:54 <FliPPeh> Say I have a "type MessageHandler m = Message -> m()", how can I constrain this to mean "for all m part of typeclass Connection"? The usual "(Connection m) =>" does not work here :(
07:30:16 <byorgey> you just need a computable correspondence between a 1D tape and a 2D space
07:30:23 <merijn> FliPPeh: You can't without RankNTypes
07:30:46 <viran> byorgey: i see, thanks
07:30:50 <FliPPeh> merijn: Hmm, alright, I guess it'll still be constricted when passed as an arguments into the dispatcher function which does have the constriction
07:30:55 <FliPPeh> merijn: Thanks :)
07:30:55 <merijn> FliPPeh: Might be easier to just use "type MessageHandler m = Message -> m (); foo :: Connection m => Int -> MessageHandler m"
07:31:07 <FliPPeh> Ohh, that is an idea
07:31:23 <merijn> FliPPeh: Since m is in the foo signature you can just constrain it there
07:34:51 <FliPPeh> Well, the function currently is "foo :: Connection m => ... -> MessageHandler m -> m ()", so in a way if you put a MessageHandler into that it'll be constricted automatically anyways, I just thought it'd be cleaner to explicitely contrain it :)
07:35:23 <lilred> hey guys, I want to expose HTTP and possibly WebSocket services from my Haskell application, what's the most straightforward webserver?
07:35:49 <merijn> FliPPeh: Yeah, that works
07:36:10 <merijn> FliPPeh: Constraining the type synonym almost certainly doesn't do what you naively expect, so this is better :)
07:36:24 <t7> does ghci 7.6 have goals?
07:36:36 <FliPPeh> t7: To be newer than 7.6
07:36:51 <merijn> lilred: I think almost everything uses warp? You could also try and use something like http-conduit? Not sure if that can be used as a server, though
07:37:16 <merijn> t7: Nope, sadly
07:37:16 <FliPPeh> Damn, 7.5
07:37:25 * FliPPeh shuffles back into the background
07:37:26 <merijn> t7: At least, assuming you meant type holes by that
07:37:53 <FliPPeh> How far has the AMP gone by now? Any news?
07:38:14 <merijn> FliPPeh: Work in progress, I believe you shouldn't count on it before 7.10
07:38:19 <FliPPeh> Aw
07:41:11 * hackagebot http-client 0.2.0.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.2.0.2 (MichaelSnoyman)
07:43:15 <fjdddd> merijn: Are there any other tools that I could use? I can't make c2hsc work.
07:43:41 <byorgey> FliPPeh: 7.8 will include warnings for Monad instances without corresponding Applicative instances.  7.10 will add  Applicative => Monad.
07:43:45 <merijn> The stuff described in the wiki you linked should work, just requires more handcoding for the wrappers
07:43:55 <fjdddd> What about c2hs?
07:44:34 <merijn> I haven't used it
07:44:52 <fjdddd> OK, I'll try to follow the wiki.
07:45:44 <merijn> ugh, why is naming things so hard? :(
07:46:00 <cariveri> hey. Can I "map perform [IO ()]" somehow?
07:46:30 <hpc> cariveri: sequence or sequence_
07:46:43 <hpc> (for IO (), likely sequence_)
07:46:48 <hpc> :t sequence
07:46:49 <lambdabot> Monad m => [m a] -> m [a]
07:46:50 <hpc> :t sequence_
07:46:51 <lambdabot> Monad m => [m a] -> m ()
07:47:39 <stelleg> @src sequence_
07:47:40 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
07:48:07 <cariveri> yes thank you. thats it.
07:48:12 <merijn> See also mapM and mapM_
07:48:25 <chrisdone> merijn: in soviet lamdu, editor names you!
07:48:54 <merijn> chrisdone: I know, that'd be great. Because then renaming once I settle on a name would be more convenient too!
07:49:11 <chrisdone> ≖‿≖
07:50:09 <identity> okay, so cmdargs doesn't work with Text?
07:50:11 <identity> god..
07:50:28 <merijn> I can't come up with a sensible name for "Get a -> Proxy () ByteString y' y (StateT ByteString m) a", I guess something like "parsePipe" or "pipeGet", I guess...
07:50:43 <identity> knowing that could have saved me a functorload of time. -_-
07:51:07 <chrisdone> merijn: i tend to think parsers have expected failure
07:51:26 <merijn> chrisdone: The expected failure here is "throw exception that aborts the entire pipeline"
07:51:42 <chrisdone> exceptions aren't expected, they're exceptional =p
07:51:57 <chrisdone> by expected i mean Either or Maybe or so
07:52:38 <merijn> chrisdone: I'm parsing low level protocol headers, failure to conform means 1) corrupted data or 2) malicious client, in which case I disconnect
07:53:25 <merijn> Either and Maybe are only useful if you have any intention to handle failure
07:53:41 <merijn> My only intention on failure is to immediately kill the executing thread and close the socket
07:53:50 <merijn> So why bother with the boilerplate?
07:55:55 <chrisdone> i'm not saying you should change your types, just that parsers normally expect failure
07:56:12 * hackagebot persistent-template 1.2.0.5 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.2.0.5 (MichaelSnoyman)
07:56:56 <chrisdone> easier to trust and test, that way. if that's inconvenient and it's easier to barf up, you go girl
07:58:46 <chrisdone> are you parsing streaming stuff incrementally?
07:58:56 <fjdddd> merijn: Do you have a correctly-written example of a Storable instance?  Since the wiki example uses c2hsc, I can't follow it.
07:59:26 <chrisdone> fjdddd: you can look in the haddocks of Storable for instances of base types
07:59:33 <merijn> chrisdone: Well, if you have a better name, I'm open to suggestion :p
07:59:40 <fjdddd> chrisdone: Good idea, thanks.
08:00:16 <chrisdone> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Foreign-Storable.html#line-181
08:01:13 * hackagebot unique-logic-tf 0.4.1.1 - Solve simple simultaneous equations  http://hackage.haskell.org/package/unique-logic-tf-0.4.1.1 (HenningThielemann)
08:01:14 <exicer> Is it possible to get tab completion in the ghci you get with haskell mode in emacs ?
08:02:01 <merijn> I'm doing byte level twiddling on the input stream to parse some headers before the proper connection starts, so I wanted a quick convenience thing that lets me interleave the parsing and output, so that function parses one "Get a" and stores the remaining BS for future Get's
08:03:11 <fjdddd> chrisdone: Looks complicated. And I have to write an instance for a struct, which would be even harder, I guess.
08:03:50 <chrisdone> hm, i wonder if Storable is derivable. you'd kinda think it would be
08:04:13 <merijn> chrisdone: No
08:04:19 <merijn> chrisdone: Why would it be derivable?
08:04:27 <chrisdone> why wouldn't it be?
08:04:28 <merijn> chrisdone: The instance depends on the C compiler used
08:04:33 <fjdddd> merijn: If it's not, how does c2hsc work, then?
08:04:49 <merijn> fjdddd: c2hsc parses C code and generates one from the C code
08:04:56 <chrisdone> hm, that seems odd
08:04:58 <fjdddd> Ah.
08:05:05 <merijn> chrisdone: How so?
08:05:18 <merijn> chrisdone: Offsets and packing are compiler dependent
08:05:28 <chrisdone> merijn: well the implementation of Storable there that i just linked is in pure haskell
08:05:39 <chrisdone> merijn: if those exist, why can't it be derived for other types?
08:05:42 <merijn> chrisdone: But that's for pure haskell data, no?
08:05:52 <chrisdone> oh, i thought that's what we wanted
08:06:21 <merijn> chrisdone: He wants access to a C struct from haskell
08:06:24 <chrisdone> ahhhh
08:06:35 <fjdddd> yep
08:07:14 <chrisdone> then c2hs seems more reliable. although another option is to write a bit of c code to access/wrap the struct and use that from haskell. i did that
08:07:54 <chrisdone> e.g. https://github.com/chrisdone/freenect/blob/master/cbits/freenect-helpers.c
08:08:06 <Jeanne-Kamikaze> we have freenect bindings ?
08:08:53 <chrisdone> we do!
08:09:19 <Jeanne-Kamikaze> that's pretty cool
08:09:20 <chrisdone> i wrote some 2 years ago for depth data, and mentored kevin to add video support
08:09:51 <Jeanne-Kamikaze> was he mentored 2 years ago also ?
08:10:45 <chrisdone> yup
08:11:01 <chrisdone> damn. so long ago
08:12:44 <Jeanne-Kamikaze> I once read about the story of freenect, and apparently it was born out of some spanish dude deciding to reverse the data protocol used by the kinect
08:12:55 <Jeanne-Kamikaze> iirc, the funny part was that microsoft then paid him a reward of sorts
08:13:13 <Jeanne-Kamikaze> not for the reversing per se, but for making the stuff cross-platform, or something like that
08:13:48 <Jeanne-Kamikaze> or maybe it was the other way around; someone put a reward price, and then this dude decided to take the challenge
08:14:43 <chrisdone> nice
08:15:15 <Jeanne-Kamikaze> seems like a cool way to fund oss projects; explain what you want to get done, put a bounty on it, wait for the lurking eye
08:15:52 <zomg> I wouldn't say it's a way to *fund* them, but rather find someone to do the work
08:15:56 <chrisdone> i've thought about doing that for haskell
08:16:05 <zomg> I mean in order to have a bounty you actually need to have the money in the first place =)
08:16:16 <chrisdone> there're some things i'd pay $1k for
08:16:26 <zomg> You have too much money then
08:16:27 <zomg> :D
08:16:42 <chrisdone> lol
08:16:47 <zomg> Well, I paid a lot for a nice chair
08:16:56 <zomg> So if it's something of that level of making-your-life-better
08:16:59 <zomg> =)
08:17:35 <Jeanne-Kamikaze> true, thanks for the correction
08:19:08 <fjdddd> chrisdone: Examples?
08:21:00 <zol> I'm having a really hard time comprehending functors, monads and monoids -- anyone got any nice explanation on the web I could digest? My Google Fu has failed so far.
08:21:46 <fjdddd> zol: Have you read the monad tutorials on the wiki?
08:22:00 <scriptor> zol: this is a nice start http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
08:22:16 <zomg> ^ that's what I was going to link as well but naturally had misplaced it =)
08:22:35 <zol> scriptor: Thank you!
08:22:46 <fjdddd> zol: Basically, read a couple of them to get the idea, then try to implement the basic ones (List, Maybe, Either, State, Reader, Writer) from scratch.
08:22:49 <zol> fjdddd: Thought I had, but apparently I found a better site now.
08:22:58 <Jeanne-Kamikaze> there's this video by brian beckman, don't fear the monad
08:23:14 <merijn> Jeanne-Kamikaze: Cale was ranting earlier that he hated that one :p
08:23:15 <Jeanne-Kamikaze> which I found particularly nice to follow
08:23:18 <Jeanne-Kamikaze> oh ?
08:23:31 <Jeanne-Kamikaze> why ?
08:23:33 <fjdddd> tastes differ
08:23:49 <merijn> 16:38 < Cale> It's like an hour long and if I recall correctly he fails to actually say what a monad is the entire time.
08:23:52 <merijn> 16:39 < Cale> He does say some things which are true, so it's not entirely bad, and does talk about Kleisli composition without calling it that.
08:24:02 <scriptor> Jeanne-Kamikaze: did you have an idea what monads were before you watched it?
08:24:41 <merijn> zol: Monoids are probably the simplest of those three, on account of every programmer already knowing three examples
08:25:09 <fjdddd> zol: Have you read LYAH?
08:25:30 <Jeanne-Kamikaze> scriptor, yeah, more or less, but that video seemed to make it more clarifying for some reason
08:25:31 <merijn> zol: Monoids are just any value that has 1) a "blessed" empty value (called mempty in haskell) and 2) an operator combining two values together (mappend in haskell)
08:25:40 <zol> Oh, so a functor just unboxes the boxes value, performs the function supplied, and then returns the new value boxed?
08:25:49 <zol> unboxes the boxed*
08:25:55 <merijn> zol: Which should follow the following laws: "mappend mempty x == x == mappend x mempty"
08:25:57 <Jeanne-Kamikaze> like the way he explains monoids, ways to build complex objects from simple ones, seemed very intuitive
08:26:01 <chrisdone> fjdddd: i'd like the ability to update any IO-ish monadic function running in ghci, i'd like reloading modules not to clear the running context. i'd like a structured diff for haskell. i'd like ghc's parser to be extracted from ghc and put into a library like hse without all the type info mess. i'd like a reliable way to compile haskell code safely. i'd like ghci to be a separate package from ghc that you can install from hackage and
08:26:02 <chrisdone> fork and patch easily. just stuff i'd like but can't be bothered doing myself
08:26:02 <zol> fjdddd: I'm on chapter 10 I think
08:26:21 <merijn> zol: Also, mappend should be associative, so "mappend x (mappend y z) == mappend (mappend x y) z"
08:27:09 <Jeanne-Kamikaze> so if you tell me, a monoid is some triplet consisting of a set, an associative binary operation and an identity, my next question is "and why in the world do you want that?" However, brian goes the other way around: he talks about the intuition first and then formalises the thing
08:27:09 <fjdddd> chrisdone: Thanks for elaborating.
08:27:27 <Jeanne-Kamikaze> which is why I found the video helpful
08:27:34 <merijn> zol: That's all there is to know about monoids. The three simple examples are: 1) natural numbers, with 0 as mempty and addition as operation, 2) natural numbers, with 1 as mempty and multiplication as operation and 3) lists with [] as mempty and ++ (concatenation) as operation
08:28:02 <k00mi> chrisdone: what do you mean by "a reliable way to compile haskell code safely"? in what way is it unsafe now?
08:28:49 <chrisdone> k00mi: apart from the obvious template haskell, there are lots of sneaky ways haskell code can do bad things when being compiled
08:28:50 <merijn> zol: There's also comically trivial monoids (such as (), with () as empty element and "\() () -> ()" as combination function)
08:29:05 <zol> merijn: What are monoids used for?
08:29:08 <benmachine> associativity is weird until you realise that it just means, if you have a list it doesn't matter how you reduce it
08:29:29 <chrisdone> k00mi: it's not quite as bad as lisp, but you really need to call ghc inside a VM to get any kind of security
08:30:32 <merijn> zol: One example is "generic sum" function, i.e. sum adds all numbers in a list. One can define "msum" which mappends every value in a list
08:30:33 <k00mi> chrisdone: TH is an extension, what other ways are there, preferably without extensions?
08:30:35 <merijn> :t msum
08:30:36 <lambdabot> MonadPlus m => [m a] -> m a
08:30:39 <merijn> aww
08:30:43 <merijn> That's now that I meant :p
08:30:51 <byorgey> you want mconcat
08:30:57 <merijn> :t mconcat
08:30:58 <lambdabot> Monoid a => [a] -> a
08:31:02 <merijn> There we go
08:31:26 <Peaker> chrisdone, k00mi: You can make GHC hang forever
08:31:31 <merijn> zol: The laws let you write generic code while still being able to predict what it will do in some specific case
08:31:33 <Peaker> (though that's easy to alleviate with a timeout)
08:31:56 <merijn> zol: Monoid is really just an interface for "values that can be combined"
08:32:02 <byorgey> zol: you might be interested in my paper "Monoids: Theme and Variations" (or watching the video of the talk) here: http://www.cis.upenn.edu/~byorgey/publications.html
08:32:46 <haasn> I heard byorgey has a thing or two to say about monoids
08:32:49 <haasn> also shachaf
08:32:54 <FreeFull> List concatenation is a perfect example of a monoid
08:33:07 <haasn> FreeFull: gee, I wonder why :P
08:33:13 <merijn> zol: In general many of the abstract things used in haskell like monoid, monad, functor, etc. are simply to allow the writing of generic code
08:33:22 <FreeFull> haasn: Because it isn't commutative =P
08:34:00 <merijn> zol: For example, there is monad-loops is a library which has a ton of generic loops that will work on any monad implementation. So rather than reinventing them every time you need one we can just collect a huge library of generic code like that
08:34:10 <byorgey> haasn: the condescending tone is unnecessary.
08:34:22 <zol> merijn: Aha, thank you!
08:34:47 <byorgey> FreeFull: in fact, lists are "free monoids", which means that in a technical sense lists are actually the "most fundamental" monoid
08:34:51 <merijn> zol: If you implement some datatype a year from know and figure out how to implement a Monad instance for it, all those functions will be available to you for free
08:34:54 <haasn> byorgey: oops, unintentional
08:35:19 <byorgey> FreeFull: which does indeed make them a perfect example =)
08:35:37 <FreeFull> byorgey: Another good reason
08:35:39 <merijn> zol: Similarly, functors generalise the idea of "map"
08:36:08 <merijn> zol: "map :: (a -> b) -> [a] -> [b]" compare "fmap :: Functor f => (a -> b) -> f a -> f b"
08:36:14 <zol> "A Functor is any data type that defines how fmap applies to it."
08:36:14 <haasn> “Monoid a” is isomorphic to “[a] -> a”
08:36:27 <merijn> zol: Incidentally, the fmap implementation for lists *is* map :)
08:36:38 <chrisdone> k00mi: i can't remember the other ways. i looked into it a while back and was given lists of ways things can go wrong. the fact i don't remember them now is perhaps testament to the fact it's easy to miss something. not that there are probably any malicious haskellers out there
08:36:48 <benmachine> you can actually write the monoid axioms in terms of mconcat
08:36:52 <zol> merijn: Hah, no wonder I have been feeling confused. :)
08:37:10 <byorgey> haasn: I don't think that's true, is it?
08:37:18 <merijn> zol: But fmap also works on: Maybe ("(a -> b) -> Maybe a -> Maybe b"), Either e ("(a -> b) -> Either e a -> Either e b"), etc.
08:37:28 <FreeFull> Are lists free functors?
08:37:29 <benmachine> I wrote this down somewhere
08:37:34 <merijn> zol: Hopefully you're starting to see a pattern there ;)
08:37:37 <byorgey> FreeFull: no
08:37:55 <FreeFull> What about Maybe?
08:38:04 <benmachine> something like if you have an [[m]], you can concat the lists and then mconcat the results, or mconcat the lists and then mconcat the results, and you get the same thing
08:38:12 <haasn> byorgey: you're right; I think it's only true if we assume the laws hold
08:38:16 <zol> merijn: Yeah, thanks. :)
08:38:34 <byorgey> haasn: yeah, you need some extra constraints on what the  [a] -> a  function is allowed to do
08:38:37 <haasn> that is, the [a] -> a is a monoid homomorphism
08:38:43 <byorgey> right
08:38:45 <chrisdone> benmachine: reminds me; i noticed listToMaybe/eitherToMaybe are all Data.Foldable.foldr (const . Just) Nothing
08:38:45 <merijn> zol: Now suppose someone writes some library code that works on any Functor. If I define "data Point a = Point a a a; instance Functor Point where fmap f (Point x y z) = Point (f x) (f y) (f z)"
08:39:10 <merijn> zol: Now I can use my Point datatype with that library, simply because they both use the same common interface
08:39:15 <haasn> chrisdone: preview folded
08:39:43 <benmachine> you also need mconcat [x] = x
08:39:49 <chrisdone> haasn: was that supposed to be english?
08:40:05 <merijn> zol: Applicative and Monad are slightly more powerful versions of Functor. As a result you can write more code using Monad, but less things can be Monads (because not every datatype that can implement fmap can implement the Monad functions)
08:40:19 <benmachine> chrisdone: was that a serious question?
08:40:20 <haasn> :t preview folded -- sorry chrisdone, my head is a mess today
08:40:21 <lambdabot> (Foldable f, MonadReader (f a) m) => m (Maybe a)
08:40:40 <haasn> there goes lens ultra-generalization again
08:40:42 <haasn> :t (^?folded)
08:40:44 <lambdabot> Foldable f => f a -> Maybe a
08:40:45 <edwardk> ?
08:40:56 <edwardk> oh preview
08:41:03 <zol> merijn: Why can less things be monads?
08:41:17 <benmachine> chrisdone: I retract my question
08:41:21 <benmachine> about your question
08:41:21 <edwardk> the MonadReader there comes about because folks use these in monad transformer stacks and it avoids taking a second name for view/preview
08:41:32 <edwardk> folks complained when i had separate query/prequery combinators
08:41:38 <haasn> zol: because every Monad is trivially an Applicative (pure = return; (<*>) = ap); but some Applicatives can't be Monoids (eg. Const [a])
08:41:46 <haasn> s/Monoids/Monads/
08:42:01 <benmachine> all applicatives give rise to monoids
08:42:16 <merijn> zol: Functor requires "fmap :: Functor f => (a -> b) -> f a -> f b", Monad requires two things: "return :: Monad m => a -> m a" and "(>>=) :: Monad m => m a -> (a -> m b) -> m b"
08:42:30 <fjdddd> merijn: Finally, I've been able to run c2hsc. This works for me: c2hsc --prefix=. /location/of/file.h
08:42:57 <merijn> zol: The (>>=) type cannot be implemented for all values. I'm trying to think of a simple enough example that illustrates that
08:43:51 <merijn> zol: The second argument is "a -> m b", right? So the function is allowed to decide *which* "m b" to return depending on the value of 'a'
08:44:17 <merijn> zol: Suppose 'a' is an Int we could for example return different "m b" depending on whether the Int is even or odd
08:44:42 <merijn> With Functor the decision of what value is returned is made by "fmap", not by the the function being mapped
08:44:54 <byorgey> benmachine: how's that?
08:45:00 <haasn> merijn: data Zero a = Zero
08:45:11 <zol> merijn: Couldn't you implement the monad in the fmap then?
08:45:11 <haasn> wait, that can be a Monad
08:45:24 <haasn> but Const can't
08:45:27 <merijn> zol: You can implement fmap using (>>=), but not the other way around
08:45:34 <benmachine> byorgey: Monoid a => f a, particularly f ()
08:45:52 <byorgey> oh, to monoids, of course, I read "monads" =P
08:46:06 <merijn> zol: In fact: fmap f == \x -> x >>= return . f
08:46:22 <haasn> byorgey: Codensity f
08:46:43 <haasn> this gives you a Monad for any f, including applicatives. not sure if that counts :P
08:46:51 <merijn> zol: One example (albeit a bit silly one from the perspective of newcomers) is Const
08:47:06 <merijn> zol: "data Const a b = Const a" <- does this type make sense to you?
08:47:54 <merijn> By sense, I mean: do you understand what it is :p
08:48:00 <merijn> If you think it's silly, that's fine
08:48:10 <zol> merijn: Yes, it's a constant function, always returning the first argument? :)
08:48:19 <merijn> zol: Constant datatype, but yes
08:48:31 <zol> merijn: Ah, yeah, sorry, missed the data!
08:48:32 <merijn> zol: "Const a" can be made a functor quite easily
08:48:50 <merijn> "fmap :: (a -> b) -> Const x a -> Const x b", right?
08:49:01 <merijn> "fmap f (Const x) = Const x" <- done
08:49:21 <shachaf> haasn: Monoids?
08:49:21 * haasn .oO( fmap = const unsafeCoerce )
08:49:47 <merijn> zol: i.e. since there's no second argument inside the Const constructor, we can just change the type without doing anything
08:50:01 <tomejaguar> haasn: just 'fmap = unsafeCoerce' would work, no?
08:50:10 <merijn> zol: We can even make "Const x a" an Applicative, as long as x is a Monoid (whoo! usecase for monoids!)
08:50:12 <haasn> tomejaguar: that would unsafeCoerce the parameter ‘f’
08:50:17 <haasn> tomejaguar: I don't think that would work
08:50:24 <tomejaguar> haasn: Oh yeah, I misread :)
08:50:36 <tomejaguar> fmap _ = unsafeCoerce
08:50:41 <zol> merijn: *grins*
08:50:45 <merijn> zol: Applicative has these functions: "pure :: Applicative f => a -> f a" and "(<*>) :: Applicative f => f (a -> b) -> f a -> f b"
08:50:55 <tomejaguar> s/misread/mistyped/
08:51:03 <chrisdone> haasn: i'm glad someone already abstracted that
08:51:08 <shachaf> benmachine: The monoid axioms are that mconcat is a monoid monad algebra!
08:51:12 <merijn> zol: So to implement pure we need "pure :: a -> Const x a"
08:51:24 <merijn> zol: Which requires us to pluck an 'x' out of thin air
08:51:40 <shachaf> benmachine: Er, a free monoid monad algebra.
08:51:46 <merijn> zol: Fortunately, Monoid has mempty, so we can use that
08:52:10 <merijn> zol: So "instance Monoid x => Applicative (Const x) where pure x = Const mempty"
08:52:15 <benmachine> shachaf: wooo
08:52:20 <merijn> zol: (Stop me if anything confuses you)
08:52:32 <benmachine> shachaf: oh right, list-monad, hence mconcat . return = id
08:52:35 <shachaf> benmachine: Er, a free monoid monad monad algebra.
08:52:48 <shachaf> Yes.
08:53:04 <merijn> zol: (<*>) essentially lets you apply a function "inside" a functor to something in the same functor
08:53:09 <zol> merijn: Not entirely sure what an Applicative is yet, but I guess it's something that allows function application?
08:53:19 <shachaf> Same goes for class Monad m where retract :: Free m a -> m a
08:53:48 <merijn> zol: Yes, it allows you to apply a function that is "inside" a functor (the functor class doesn't let you get things out of it again!)
08:53:54 <merijn> zol: One example
08:54:01 <haasn> I still prefer to think of Applicative in terms of liftA2 (,), for pedagogical reasons. Is that just me?
08:54:03 <haasn> :t liftA2 (,)
08:54:05 <lambdabot> Applicative f => f a -> f b -> f (a, b)
08:54:10 <merijn> > Just (+1) <*> Just 2
08:54:11 <lambdabot>  Just 3
08:54:16 <merijn> Or\
08:54:22 <shachaf> haasn: It is not just you, it's also the Applicative paper.
08:54:25 <merijn> :t fmap (+) 1
08:54:26 <lambdabot> (Functor f, Num a, Num (f a)) => f (a -> a)
08:54:33 <merijn> > fmap (+) 1 <*> Just 2
08:54:34 <lambdabot>  No instance for (GHC.Show.Show b0)
08:54:35 <lambdabot>    arising from a use of `M240623140909126208912843.show_M2406231409091262089...
08:54:35 <lambdabot>  The type variable `b0' is ambiguous
08:54:35 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
08:54:35 <lambdabot>  Note: there are several potential instances:
08:54:36 <shachaf> I also like lift0 and lift2
08:54:47 <merijn> whoops
08:54:52 <shachaf> Where Functor gives you lift1.
08:54:53 <merijn> > fmap (+) (Just 1) <*> Just 2
08:54:54 <lambdabot>  Just 3
08:55:04 <haasn> shachaf: lift0 :: f ()  ?
08:55:17 <shachaf> lift0 :: a -> f a; lift2 :: (a -> b -> c) -> f a -> f b -> f c
08:55:18 <merijn> zol: So basically fmap lets you map a function of 1 argument inside the functor, Applicative lets you apply the result to more values
08:55:18 <haasn> oh, no
08:55:20 <zol> :t (<*>)
08:55:20 <haasn> yes
08:55:21 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:55:53 <chrisdone> applicatives strike me as a way to generalize function application
08:56:01 <merijn> zol: Anyway, with Const x the type of "(<*>) :: Monoid x => Const x (a -> b) -> Const x a -> Const x b"
08:56:13 <zol> merijn: When you say functor, should I think about a data type that implements fmap then?
08:56:15 <chrisdone> the particular instance decides how application works and what is constructed
08:56:18 <merijn> zol: Yes
08:56:41 <merijn> :t fmap (+) (Just 1)
08:56:42 <lambdabot> Num a => Maybe (a -> a)
08:56:56 <merijn> How do you do something useful with that function inside the Maybe?
08:57:02 <chrisdone> in that sense it would be nice to have better syntax for it
08:57:03 <merijn> Using the Applicative instance of Maybe
08:57:03 <zol> merijn: So Applicative is somehow like a map?
08:57:17 <haasn> chrisdone: idiom brackets!
08:57:31 <chrisdone> nod
08:57:39 <zol> merijn: Hm.. fromJust? :D
08:57:51 <merijn> zol: Well, fmap is like map and Applicative is a generalisation of Functor
08:57:56 <magicman> @instances IsString
08:57:57 <lambdabot> Couldn't find class `IsString'. Try @instances-importing
08:57:58 <merijn> zol: Ah, but Applicative is neater
08:58:09 <merijn> > fmap (+) (Just 1) <*> Nothing
08:58:11 <lambdabot>  Nothing
08:58:15 <merijn> > fmap (+) (Just 1) <*> Just 2
08:58:16 <lambdabot>  Just 3
08:58:22 <magicman> @instances-importing IsString Data.String
08:58:23 <lambdabot> Couldn't find class `Data.String'. Try @instances-importing
08:58:28 <merijn> > Nothing <*> Just 2
08:58:30 <lambdabot>  Nothing
08:58:38 <magicman> @instances-importing Data.String IsString
08:58:39 <lambdabot> [Char]
08:59:00 <merijn> zol: So in case of Maybe <*> lets you apply the function with proper error handling if either the function or argument are Nothing
08:59:12 <merijn> zol: Whereas fromJust would just crash
08:59:34 <merijn> zol: To get back to the story
08:59:38 <joelteon> > liftA2 (+) (Just 1) (Just 2)
08:59:39 <lambdabot>  Just 3
08:59:46 <merijn> zol: with Const x the type of "(<*>) :: Monoid x => Const x (a -> b) -> Const x a -> Const x b"
08:59:47 <zol> merijn: *nodnods*
09:00:39 <merijn> zol: We don't have a function to apply, but that's fine we don't have a value to apply it to either. That is easy enough to implement too: "(Const x) <*> (Const y) = Const (mappend x y)"
09:01:09 <lingxiao> hey all i have a question about a very particular topic in lambda calculus, could some one spare a moment?
09:01:11 <merijn> zol: Note that we use mappend to combine the x and y together, otherwise our code would no behave properly with the Applicative laws (which I'm gonna skip)
09:01:37 <merijn> zol: Right, so now that we have an Applicative for "Const x" we wonder if we can make a monad instance
09:01:43 <merijn> zol: But now we're boned
09:01:48 <chrisdone> it would be fun to try a sublanguage where runIdentity was implicit and $ = <$> and . = <*>
09:02:19 <merijn> zol: "(>>=) :: Monad m => m a -> (a -> m b) -> m b" which becomes "(>>=) :: Monoid x => Const x a -> (a -> Const x b) -> Const x b"
09:02:43 <merijn> zol: Now we're screwed, because "Const x a" doesn't actually have an 'a' inside
09:02:56 <merijn> zol: But "a -> Const x b" requires an 'a' value to return something
09:03:16 <merijn> zol: In other words, it's not possible to make Const an instance of Monad, because we cannot implement >>=
09:03:28 <zol> merijn: Aha!
09:03:39 <haasn> shachaf: I think half of the applicative laws (apart from associativity) basically mean that combining lift2 with lift0 gives you lift1
09:03:47 <haasn> does that make sense?
09:03:59 <merijn> zol: Similarly there are types which can be functors, but not applicatives
09:04:00 <chrisdone> > let ($) = (<$>); (.) = (<*>) in runIdentity ((+) $ pure 4 . pure 6) -- e.g. but with Num instances for Num a => Identity a so you could write (+) $ 4 . 6
09:04:02 <lambdabot>  10
09:04:48 <haasn> lift2 f (lift0 a) = lift1 (f a)
09:05:03 <haasn> lift2 f x (lift0 y) = lift1 (`f` y) x
09:05:38 * zol nodnods at merijn
09:06:21 <issam> hi guys
09:06:29 <issam> for the evaluation rule for lambda calculus
09:06:32 <issam> rules*
09:06:41 <issam> do we need a function that returns a constant value?
09:06:50 <issam> for example, evalauate (Constant c) = Constant c
09:07:01 <merijn> zol: The nice thing is that you can then write generic things like "liftM2" and others that work on every monad, including IO, lists, Maybe, etc.
09:07:05 <merijn> :t liftM2
09:07:06 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:07:35 <tomejaguar> merijn: Can't you define '_ >>= _ = Const mempty'?
09:07:42 <chrisdone> issam: yeah, k → k, (\k.k) k → k
09:07:55 <merijn> tomejaguar: No, that doesn't obey the monad laws
09:07:56 <haasn> oh, but I don't think my laws give us lift1 f (lift0 a) = lift0 (f a)
09:08:12 <merijn> "x >>= return . id == x"
09:08:16 <chrisdone> issam: you don't necessarily need constants, you could just return lambda abstractions. but commonly constants are supported
09:08:24 <tomejaguar> merijn: Ah indeed.
09:08:27 <issam> https://dl.dropboxusercontent.com/u/30688032/lambda.png
09:08:30 <merijn> tomejaguar: Your definition will fail that because the value gets replaced by mempty
09:08:32 <issam> its not part of the rules?
09:08:48 <shachaf> haasn: The Applicative laws expressed for these primitives do give you the Functor laws (I think).
09:08:49 <issam> chrisdone, i see, its implicitly implied if we support constants :)
09:10:34 <scriptor> what does: Tau |- x : T mean again?
09:12:17 <merijn> zol: btw, trying to define your own functor/applicative/monad instances for existing types can be good practice. Especially if you then try and figure out whether they obey the relevant laws
09:13:40 <zol> merijn: Yeah, I intend to practice! Thanks a lot for the thorough explanation :)
09:14:05 <Cale> scriptor: It means that from the statements in Tau, it follows that x : T
09:14:29 <Cale> Though usually that's a Gamma, not a Tau (capital tau just looks like a T)
09:14:40 <scriptor> Cale: ah, thanks
09:15:04 <benmachine> Γ ← gamma
09:15:19 <scriptor> doh, should've checked my greek alphabet
09:21:36 <fizbin> So, if I have some types defined in module A.B.C and a few instance declarations defined in A.B.C.Instances, is that bad form?
09:22:25 <zomg> I think I've seen packages on Hackage use that pattern so might be ok =)
09:23:41 <fizbin> Thing is, I'm serializing to/from XML with HXT, and I really don't want to junk my types up with HXT stuff, so I put all that in a subpackage, and the main way to serialize with HXT involves defining an instance of XmlPickler
09:24:10 <fizbin> But then I get warnings unless I {-# OPTIONS_GHC -fno-warn-orphans #-}
09:24:30 <maurer> fizbin: Basic rules to follow is that you should ensure that in terms of _exported_ modules, the instances should get exported in a module with one of them
09:24:54 <maurer> err, by one of them, I mean one of the typeclass declaration or the type declaration they're over
09:25:16 <fizbin> maurer: Really? So anyone using my types should also have to add a dependency on HXT?
09:25:20 <fizbin> That seems wrong.
09:25:22 <mrwonko> Map keys have to be Ord for the map to be useful, but I'd like to use an Enum. I suppose there's a different type I should use?
09:25:43 <merijn> mrwonko: A type can be both Ord and Enum
09:26:03 <merijn> mrwonko: Or do you just want an array indexed by enum values?
09:26:06 <maurer> fizbin: That's a reasonable concern, and I don't have an answer for you, but that's the practice that is trying to be enforced
09:26:16 <merijn> mrwonko: In case of the latter take a look at Array?
09:26:28 * hackagebot th-lift 0.6 - Derive Template Haskell's Lift class for datatypes.  http://hackage.haskell.org/package/th-lift-0.6 (MathieuBoespflug)
09:26:30 * hackagebot virthualenv 0.2.2 - Virtual Haskell Environment builder  http://hackage.haskell.org/package/virthualenv-0.2.2 (BartoszCwiklowski)
09:26:33 <maurer> It's a side effect of the anti-modularity of typeclasses and trying to make sure that packages aren't confusingly inconsistent
09:26:34 <fizbin> What I'd like is a way to say "for the orphan instances check, consider anything in packages A.B.C and P.Q.R to be in this package"
09:27:03 <mrwonko> I want to define names using data MyEnum = A | B | C and then associate up to one value with each of them, i.e. a Map MyEnum Whatever
09:27:10 <fizbin> Sort of a limited -fno-warn-orphans.
09:27:14 <asdf1234> you could use an intmap
09:27:19 <asdf1234> or a hashmap
09:27:39 <merijn> mrwonko: "Array MyEnum (Maybe Whatever)"?
09:27:54 <merijn> mrwonko: Alternatively, why not just make MyEnum an Ord instance? :)
09:28:12 <merijn> mrwonko: "data MyEnum = A | B | C deriving (Enum, Ord)" <- done
09:28:54 <mrwonko> oh, I just tried deriving Ord, which did not work since there's presumably no way to determine the order automatically without defining it to be an enumeration (I left out the deriving Enum part)
09:29:12 <asdf1234> merijn: to be fair, you need an Eq instance in there too :)
09:29:25 <merijn> oh, maybe, yeah
09:29:48 <fizbin> maurer: What do you mean by "the anti-modularity of typeclasses"?
09:30:01 <merijn> fizbin: The fact that you can't selectively import them
09:31:13 <lingxiao> if S x y z = (x z)(y z) and K x y = x
09:31:18 <lingxiao> what is SK ?
09:31:21 <maurer> fizbin: You can't import one typeclass instance in some parts of your program and another part in others
09:31:29 <maurer> fizbin: Even if you weren't epxorting it
09:31:31 <asdf1234> lingxiao: is this homework?
09:31:32 <fizbin> Oh, that. Sure.
09:32:02 <maurer> fizbin: The rule about putting them in either the same place as the type or the class definition is a little overrestrictive, but it removes tne confusion that can result when you try to combine these otherwise
09:32:07 <lingxiao> no, I no longer have the luxry of homework in life
09:32:10 <jjauhien> Hey, folks. Maybe you could help with the following problem (some workaround is pretty fine). I need automatic loading BibTex record (or some other record with full authors list and journal/book/etc. name) from Google Scholar. As for now I could form a request URL and download search results page (e.g. like this one: http://bit.ly/1ddg1re). On this page to get a BibTex record the one should click on Cite link (which is JavaScript, as
09:32:10 <jjauhien>  I understand) and then click on the link Import to BibTex (which is just a usual GET link to a text, containing BibText record). So I could load pages from usual GET URLs, but my problem is to do this "click on JavaScript link and get the resulting page" in Haskell. Any suggestions, please?
09:32:12 <lingxiao> :( or should I say :)
09:32:18 <cyrix> what do you think about this tutorial? it seemed helped me understand functors, applicatives and monads, but the I saw that the author repeatedly calls getLine as a function that takes zero arguments so I am wondering if there are any other mistakes
09:32:29 <cyrix> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
09:32:33 <maurer> fizbin: In the case where one is your foo package, and one is your foo-serialization package, you are probably fine
09:32:39 <maurer> fizbin: I was just trying to explain what the warning is for
09:32:45 <asdf1234> lingxiao: S K would make the compiler complain, I think .. it'd try to apply S to K which doesn't make sense
09:32:48 <lingxiao> asdf1234: I know what the types is, I could just type it in ghci anyways
09:33:01 <mm_bureau> lingxiao: S K g x = K x (g x) = x
09:33:02 <merijn> cyrix: It's not terrible, but not that good either
09:33:07 <fizbin> Right. I just wish I had a way to turn the warning off only a tiny bit.
09:33:24 <lingxiao> sorry.. K x y = y
09:33:35 <haasn> :t let s x y z = (x z)(y z); k x y = x in s k
09:33:36 <lambdabot> (t -> t1) -> t -> t
09:33:37 <mm_bureau> lingxiao: that's not K
09:33:38 <merijn> cyrix: I tend to recommend only two monad "tutorials": 1) You Could Have Invented Monads (And Maybe Already Have) and 2) the original Wadler paper
09:33:42 <mm_bureau> lingxiao: K x y = x
09:33:44 <fizbin> Currently I just have to be very careful of all instance declarations in any file where I start with {-# OPTIONS_GHC -fno-warn-orphans irc://irc.freenode.net:6667/#-}
09:33:45 <tomejaguar> lingxiao: S K y z is K z (y z)
09:33:55 <merijn> cyrix: If you're reasonably comfortable with haskell syntax the Wadler paper is really not that intimidating
09:33:57 <fizbin> Stupid adium copy/paste
09:34:07 <haasn> > let s x y z = (x z)(y z); k x y = x in s k x y
09:34:08 <lambdabot>  Couldn't match expected type `Debug.SimpleReflect.Expr.Expr -> t0'
09:34:09 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
09:34:09 <lingxiao> mm_bureau: sorry I corrected it to K x y = y
09:34:16 <haasn> > let s x y z = (x z)(y z); k x y = x in s k f y
09:34:17 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr t0)
09:34:18 <lambdabot>    arising from a use of `Debug.SimpleReflect.Vars.f'
09:34:18 <lambdabot>  The type variable `t0' is ambiguous
09:34:18 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
09:34:18 <lambdabot>  Note: there are several potential instances:
09:34:23 <mm_bureau> lingxiao: let's call that one L then =)
09:34:29 <asdf1234> you broke lambdabot
09:34:30 <lingxiao> haha flip K
09:34:31 <haasn> > let s x y z = (x z)(y z); k x y = x in s k (f :: Expr -> Expr) y :: Expr
09:34:31 <tomejaguar> lingxiao: K x y is typically x.
09:34:32 <lambdabot>  y
09:34:35 <haasn> there we go :P
09:34:40 <cyrix> merijn: what about a tutorial for applicatives? I think I get monads more than them
09:34:55 <lingxiao> wait no I I was right, K x y = x
09:34:57 <lingxiao> ahhh..
09:35:08 <BlankVerse> is code.haskell.org down?
09:35:12 <lingxiao> tomejaguar: yeah you're right
09:35:31 <BlankVerse> I wanted to get the source for lamdabot @ http://code.haskell.org/lambdabot
09:35:31 <fjdddd> cyrix: Have you read the original paper?
09:35:32 <fjdddd>  
09:35:32 <asdf1234> cyrix: you have to be able to understand applicatives to understand monads :o
09:35:36 <merijn> cyrix: Applicatives are "just" an in-between Functor and Monad
09:35:44 <cyrix> the idea to apply a function in a context to a value in a context seems just weird to me, and apart from applying a list of functions to a list of values I cant see where it could be useful
09:35:50 <mm_bureau> lingxiao: given L x y = y, you get:  S L g x = L x (g x) = g x
09:35:56 <merijn> There was a decent Applicative paper too, I think
09:36:03 <merijn> cyrix: Simple
09:36:10 <mm_bureau> lingxiao: the secret to figuring these things out is:  if you can't reduce, add another argument =)
09:36:21 <mm_bureau> lingxiao: S L = ?, no idea
09:36:23 <merijn> > (+) <$> Just 1 <*> Just 2 -- <$> is just fmap
09:36:24 <lambdabot>  Just 3
09:36:27 <mm_bureau> S L x = ?, no idea
09:36:32 <merijn> > (+) <$> Just 1 <*> Nothing
09:36:33 <lambdabot>  Nothing
09:36:37 <mm_bureau> S L x y = L y (x y) = x y
09:36:41 <merijn> cyrix: Seems pretty handy to me ;)
09:36:49 <merijn> Also, how about:
09:36:54 <mm_bureau> lingxiao: does that make sense?
09:37:03 <merijn> :t liftA2 (,) getLine getLine
09:37:03 <lambdabot> IO (String, String)
09:37:51 <cyrix> what does (+) <$> Just 1 do?
09:37:52 <merijn> cyrix: "the idea to apply a function in a context to a value in a context seems just weird to me" <- think of fmap'ing a function of multiple arguments
09:38:00 <lingxiao> mm_bureau: not entirely yet haha, could you expand on your earlier statement: "S K y z is K z (y z)"
09:38:08 <merijn> cyrix: "(+) <$> Just 1 == fmap (+) (Just 1)"
09:38:15 <merijn> :t fmap (+) (Just 1)
09:38:16 <lambdabot> Num a => Maybe (a -> a)
09:38:16 <mm_bureau> lingxiao: that's how S is defined
09:38:23 <merijn> :t (+) <$> (Just 1)
09:38:24 <lambdabot> Num a => Maybe (a -> a)
09:38:25 <mm_bureau> lingxiao: S f g x = f x (g x)
09:38:34 <lingxiao> oh you're putting in K for x in S x y z
09:38:38 <mm_bureau> lingxiao: so S K g x = K x (g x) = x
09:38:39 <lingxiao> and just expanding on the def
09:38:43 <mm_bureau> yeah
09:38:44 <lingxiao> ahh.. got it thanks
09:38:48 <merijn> cyrix: The problem is that after fmap you still require one extra argument, but since it's inside the Maybe no, you can't use fmap for that
09:39:10 <mm_bureau> lingxiao: note that SK calculus mixes very well with lambda calculus…  so let's say you have trouble figuring out what S L is
09:39:21 <mm_bureau> S L = \g -> S L g
09:39:30 <cyrix> (+) <$> Just 1 is (Just (+1)) and (+) <$> Nothing is?
09:39:39 <mm_bureau> = \g x -> S L g x
09:39:40 <asdf1234> :t zygoHistoPrepro
09:39:41 <lambdabot> Not in scope: `zygoHistoPrepro'
09:39:43 <merijn> > fmap (+) Nothing
09:39:44 <lambdabot>  Nothing
09:39:50 <asdf1234> alas
09:39:51 <mm_bureau> = \g x -> x
09:39:53 <mm_bureau> uhm
09:39:55 <mm_bureau> = \g x -> g x
09:39:57 <merijn> cyrix: <$> is just infix notation for fmap :)
09:39:57 <mm_bureau> so S L = id
09:40:06 <mm_bureau> but a constrained id
09:40:13 <merijn> cyrix: Which happens to look nice together with the <*> Applicative function
09:40:30 <cyrix> oh. so it is just a function or Nothing (of type Maybe function)
09:41:05 <lingxiao> oh that's what you mean by adding one more arg and reduce .
09:41:07 <asdf1234> Maybe (a -> b) might be a function or nothing
09:41:14 <mm_bureau> lingxiao: exactly
09:41:27 <mm_bureau> lingxiao: you can also go the other way around…  how do you represent 'flip' in SK calculus?
09:42:24 <cyrix> is that the whole purpose of applicatives? to apply a function with more than one argument to applicative values
09:43:00 <merijn> cyrix: Yup
09:43:07 <cyrix> ok :)
09:43:17 <fizbin> Quick style question: (take col [' ',' '..]) versus (replicate col ' ')
09:43:28 <fizbin> Which do you prefer?
09:43:39 <tomejaguar> cyrix: You could think of it that way, or you could think of it as combining two "applicative values" into one, which amounts to much the same thing.
09:43:44 <merijn> fizbin: The latter
09:43:56 <merijn> fizbin: or "take col (repeat ' ')"
09:44:01 <merijn> I find the first one really confusing
09:44:03 <tomejaguar> fizbin: The latter
09:44:35 <tomejaguar> @src replicate
09:44:36 <lambdabot> replicate n x = take n (repeat x)
09:44:49 <fizbin> Yeah, I'm thinking [' ', ' '..] is a rather cryptic way of saying repeat ' '
09:45:15 <asdf1234> would [' ', ' ', ..] require an enum instance?
09:45:29 <asdf1234> (not that it matters in this case)
09:45:35 <zol> How should I parse this/read this out loud? "instance Functor ((->) r) where ..."
09:45:36 <asdf1234> or like [a, a, ..]
09:45:58 <zol> :t (->)
09:45:59 <lambdabot> parse error on input `->'
09:46:08 <asdf1234> :t ((-> r)
09:46:09 <lambdabot> parse error on input `->'
09:46:12 <asdf1234> :t ((->) r)
09:46:13 <lambdabot> parse error on input `->'
09:46:20 <asdf1234> :i ((->) r)
09:46:23 <cyrix> > (+) <*> Nothing == Nothing
09:46:25 <lambdabot>  Precedence parsing error
09:46:25 <lambdabot>      cannot mix `Control.Applicative.<*>' [infixl 4] and `GHC.Classes.==' [in...
09:46:48 <zol> asdf1234: See my problem?
09:46:55 <asdf1234> the instance one should work
09:46:59 <asdf1234> it's a function from any type to r
09:47:01 <cyrix> > ((+) <*> Nothing) == Nothing
09:47:02 <lambdabot>  Couldn't match expected type `Data.Maybe.Maybe (a0 -> b0)'
09:47:02 <lambdabot>              with actual type `a1 -> a1 -> a1'
09:47:09 <tomejaguar> > ((+) <$> Nothing) == Nothing
09:47:11 <lambdabot>  No instance for (GHC.Num.Num a0) arising from a use of `GHC.Num.+'
09:47:11 <lambdabot>  The type variable `a0' is ambiguous
09:47:11 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
09:47:11 <lambdabot>  Note: there are several potential instances:
09:47:11 <lambdabot>    instance [safe] GHC.Num.Num b => GHC.Num.Num (b -> b)
09:47:22 <cyrix> hmm yes I wanted <$>
09:47:24 <asdf1234> :i ((->) r)
09:47:32 <asdf1234> :info ((->) r)
09:47:38 <asdf1234> huh
09:48:06 <zol> asdf1234: I guess
09:48:10 <zol> :t Functor (->)
09:48:12 <lambdabot> parse error on input `->'
09:48:15 <zol> :i Functor (->)
09:48:22 <cyrix> > isNothing ((+) <$> Nothing)
09:48:23 <lambdabot>  True
09:48:24 <asdf1234> try that one in ghci
09:48:26 <cyrix> :)
09:48:44 <asdf1234> zol: oh, it doesn't like it
09:48:54 <cyrix> (I love hoogle)
09:49:18 <asdf1234> zol: think of -> as an infix operator
09:49:25 <lingxiao> well I guess you coudl just write \fxy.fyx
09:49:32 <asdf1234> zol: you can write 1 + 2 as (+) 1 2
09:49:38 <lingxiao> but that's not in the spiriti of things... I should define it using SKI
09:49:43 <asdf1234> zol: you can write a -> b as (->) a b
09:49:59 <zol> asdf1234: I thought that was just type information?
09:50:19 <asdf1234> zol: it is type information
09:50:35 <asdf1234> zol: it's one of those special things like how [a] means a list of a
09:51:31 <cyrix> > (+) <$> Nothing <*> undefined
09:51:33 <lambdabot>  Nothing
09:51:38 <asdf1234> zol: ghc doesn't handle partially applied infix operators in most circumstances, so you wind up with stuff like (->) r
09:52:46 <c_wraith> ghc doesn't handle sections at the type level at all, last time I checked
09:53:05 <nominolo> preflex: seen Heffalump
09:53:06 <preflex>  Heffalump was last seen on #haskell 4 days, 22 hours, 19 minutes and 17 seconds ago, saying: that flags the possibility of the value not being there explicitly in the type system
09:53:13 <cyrix> I seemingly I got applicatives more or less. but I cant see how they could be used for saying parsing. IIRC parsec could be done using applicatives instead of monads?
09:53:26 <asdf1234> cyrix: pieces of parsec can be applicative
09:53:28 <zol> asdf1234: Aha, but now I am really confused. If a functor is a data type that implements fmap, then "instance Functor ((->) r)" is what?
09:53:35 <asdf1234> cyrix: anything requiring context is monadic
09:53:49 <fizbin> Is there somewhere a good explanation of the problem for which type families are the solution?
09:53:54 <asdf1234> cyrix: or at least more than applicative
09:54:01 <cyrix> I see
09:54:25 <zol> asdf1234: If ((->) r) is all functions that return r, then it isn't a data type?
09:54:45 <asdf1234> zol: a function from r to some type for which there exists a function fmap from some type a to some type b
09:55:18 <asdf1234> I believe, but I could be wrong
09:58:00 <asdf1234> zol: a function from r to some type for which there exists a function fmap from some type to type r
09:58:22 <asdf1234> zol: fmap is (.) for ((->) r)
09:59:13 <mm_bureau> flip = S (S (K S) (S (K K) S)) (K K)
09:59:25 <mm_bureau> wow, i forgot how tiring it is to perform abstraction elimination by hand =)
09:59:53 <zomg> looks like Lisp ;)
10:00:47 <asdf1234> What's the y-combinator look like in S K calculus?
10:03:03 <zol> asdf1234: Aha, thanks
10:03:23 <asdf1234> zol: sorry; I think I had wires crossed at first
10:05:17 <asdf1234> well this is patently absurd: https://gist.github.com/sdiehl/5275402
10:05:46 <exicer> How the hell do you turn off the popup telling you about haskell-mode-hook with haskell-mode in emacs ?
10:06:01 <rtpg> exicer, by turning on one of the indent modes
10:06:07 <asdf1234> <insert-vim-joke-here>
10:06:34 <rtpg> exicer, http://www.haskell.org/haskellwiki/Emacs/Installing_haskell-mode
10:06:48 <rtpg> at the bottom of that page, a thing about haskell-mode-hook
10:06:50 <rtpg> put it in your .emacs
10:06:52 <rtpg>    (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
10:07:24 <exicer> rtpg: Yeah, I had that, but then added something trying to use autocomplete
10:07:35 <exicer> And now it won't shut up about the fact that it is no longer nil
10:07:39 <rtpg> oh if people are talking about S and K, does anyone know of papers about hardware implementation of an S K machine?
10:07:51 <exicer> rtpg: Thanks though, will have another look later :)
10:08:07 <Heffalump> fast and slow reverse have equivalent strictness, right?
10:08:09 <rtpg> in coders at work, SPJ mentions it and other hardware implementations of functional paradigms, but I have yet to be able to find a paper about it
10:08:28 <rtpg> like... processors whose base instructions are S and K
10:09:57 <fjdddd> merijn: Did you use hsc2hs after c2hsc? hsc2hs test.hsc fails to compile the file: fatal error: bindings.dsl.h: No such file or directory Any ideas?
10:11:21 <c_wraith> fjdddd: did you install bindings-dsl?
10:11:57 <fjdddd> c_wraith: Meh, nope. Thank you.
10:12:02 <c_wraith> err, bindings-DSL is the package
10:12:13 <fjdddd> yep, got it.
10:12:41 <fjdddd> hm... still fails.
10:12:52 <c_wraith> it's traditional to depend on it in the .cabal file, even though it contains no real haskell code.  It still has a dummy library, just so that it's possible
10:12:52 <asdf1234> what does it say? :o
10:13:35 <c_wraith> If it's still failing, I'd be suspicious that ghc isn't including the cabal header directory when it should be..
10:13:43 <c_wraith> which is probably some sort of path issue
10:14:02 <fjdddd> The same thing: bindings.dsl.h no such file or directory. I use hsc2hs test.hsc. should I specify anything else?
10:14:17 <c_wraith> wait..  you're running hsc2hs manually?
10:14:23 <c_wraith> did you try letting cabal handle it?
10:14:36 <fjdddd> yep, manually. never used it before. what's the right way?
10:14:40 <c_wraith> that might be necessary for setting all the paths correctly
10:14:45 <asdf1234> (either that or include the header yourself)
10:14:56 <fjdddd> is there a guide I could follow?
10:14:58 <cyrix> :t liftA2 (+) (read <$> getLine) (read <$> getLine) -- is there a nicer way of writing this?
10:14:59 <lambdabot> (Num c, Read c) => IO c
10:15:29 <asdf1234> there's this on hsc2hs: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/hsc2hs.html
10:15:41 <c_wraith> fjdddd: have you used cabal for your own code before?  If so, there's nothing special about using hsc2hs with it - just include the module it generates in the exposed-modules or other-modules section
10:15:56 <fjdddd> c_wraith: yes, I have.
10:16:02 <c_wraith> fjdddd: it figures out on its own that it's an hsc file and it needs to run hsc2hs
10:16:26 <asdf1234> does hsc2hs autoinclude bindings-dsl.h?
10:16:40 <fjdddd> So, if I have test.hsc I should specify test.hs in the cabal file, right?
10:16:52 <c_wraith> you should just specify the module name in the cabal file
10:17:02 <fjdddd> ah, even better.
10:17:11 <fjdddd> OK, will try that. Thank you!
10:17:14 <c_wraith> also, the cabal file needs to depend on bindings-DSL
10:17:14 <dcoutts> fjdddd: exposed-modules/other-modules are module names, main-is is a filename
10:17:29 <c_wraith> so that it includes the header files
10:17:35 <fjdddd> Thanks, dcoutts.
10:17:44 <johnw> merijn: hi
10:17:47 <johnw> merijn: my GHC builds are on hiatus since rebuilding my server
10:17:57 <c_wraith> so throw bindings-DSL into the build-depends section
10:21:10 <fjdddd> johnw: fyi, c2hsc from hackage didn't work for me, so I had to install the one from github.
10:21:17 <johnw> oh?
10:21:35 <johnw> trying now
10:25:37 <jle`> cyrix: (+) <$> readLn <*> readLn
10:25:50 <jle`> :t (+) <$> readLn <*> readLn
10:25:51 <lambdabot> (Num b, Read b) => IO b
10:26:11 <johnw> fjdddd: just worked here; what error did you get?
10:26:44 <benmachine> :t liftA2 ((+) `on` read) getLine getLine
10:26:45 <lambdabot> (Num c, Read c) => IO c
10:27:08 <cyrix> nice :)
10:28:35 <cyrix> I was tried something like this, but I tripped and fell
10:29:08 <cyrix> :t [fmap read] <*> [getLine,getLine]
10:29:10 <lambdabot> Read b => [IO b]
10:30:11 <cyrix> how would you apply sum to that?
10:30:18 <jle`> return x <*> y is the same as x <$> y
10:31:37 * hackagebot http-conduit 2.0.0.2 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.0.0.2 (MichaelSnoyman)
10:31:41 <johnw> mapM (fmap read) [getLine, getLine]
10:32:02 <fjdddd> johnw: I tried c2hsc --prefix=. /location/ot/the/file.h It returned gcc: error: : No such file or directory and c2hsc: Failed to run cpp: ExitFailure 1 However, the same command works fine with HEAD.
10:32:24 <johnw> ah
10:32:31 <johnw> i thought you meant it wouldn't install from Hackage
10:32:39 <cyrix> jle`: not sure how would that help me simplify or resolve that
10:32:43 <Luke> johnw: who'd you say i need to talk to last night for the Shake problems I had?
10:32:48 <fjdddd> Nope, it installs just fine.
10:32:53 <johnw> Neil Mitchell
10:32:56 <johnw> the shake mailing list
10:33:27 <jle`> cyrix: oh i was saying that it was redundant, you could have just written fmap read <$> [getLine, getLine]
10:33:35 <jle`> to get the same thing
10:33:42 <cyrix> ah
10:33:52 <johnw> you'll still need to sequence if you do that though
10:33:54 <jle`> return $ fmap read => [fmap read]
10:34:44 <cyrix> how would we apply sum to [IO Int] though?
10:35:23 <Iceland_jack> :t fmap sum . sequence
10:35:24 <lambdabot> (Monad f, Functor f, Num b) => [f b] -> f b
10:35:49 <Iceland_jack> :t fmap sum . sequence :: [IO Int] -> IO IO Int
10:35:50 <lambdabot>     `IO' is applied to too many type arguments
10:35:50 <lambdabot>     In an expression type signature: [IO Int] -> IO IO Int
10:35:51 <lambdabot>     In the expression: fmap sum . sequence :: [IO Int] -> IO IO Int
10:35:53 <jle`> :t sequence
10:35:55 <lambdabot> Monad m => [m a] -> m [a]
10:35:55 <Iceland_jack> :t fmap sum . sequence :: [IO Int] -> IO Int -- oops
10:35:56 <lambdabot> [IO Int] -> IO Int
10:36:38 * hackagebot c2hsc 0.6.3 - Convert C API header files to .hsc and .hsc.helper.c files  http://hackage.haskell.org/package/c2hsc-0.6.3 (JohnWiegley)
10:36:52 <fjdddd> johnw: thank you.
10:37:33 <osa1> do we have a parameter for GHC like --typecheck-only that just runs type checker and does not compile the file?
10:38:15 <merijn> osa1: Yes, but I forgot what it was
10:38:16 <johnw> -fno-code
10:38:35 <johnw> it has some limitations
10:38:48 <johnw> no TH, and some warnings won't be caught
10:39:05 <osa1> johnw: is there an equivalent parameter for cabal?
10:39:16 <johnw> --ghc-options "-fno-code"?
10:39:25 <osa1> hm
10:39:29 <osa1> I'll try that, thanks
10:39:51 <osa1> my problem is I compile my project too many times in a day just to typecheck it and I don't want to lose time for actually compiling the project
10:40:31 <johnw> well, in that case
10:40:40 <johnw> use "hdevtools check [OPTIONS] File.hs"
10:40:44 <johnw> that's blindingly fast
10:40:49 <johnw> and does a full typecheck
10:41:12 <jle`> johnw: is hdevtools check preferred over ghc-mod check?
10:41:22 <cyrix> :t fmap sum . sequence . fmap (fmap read) . replicate 10 $ getLine   -- can someone make it more beautiful?
10:41:23 <johnw> i much prefer it
10:41:24 <lambdabot> (Num b, Read b) => IO b
10:41:38 <Iceland_jack> cyrix: replicateM
10:41:41 <Iceland_jack> @ty replicateM
10:41:42 <lambdabot> Monad m => Int -> m a -> m [a]
10:41:49 <osa1> johnw: last time I tried hdevtools was not good with some cabal files, I think
10:41:50 <Iceland_jack> and readIO
10:41:53 <osa1> but I'll give it another chance
10:41:59 <cyrix> ah
10:42:48 <osa1> johnw: also, apparently hdevtools vim plugin doesn't support checking
10:44:19 <Iceland_jack> ignore the readIO remark
10:44:22 <merijn> osa1: Works fine here
10:44:34 <osa1> merijn: what's the command your running?
10:44:57 <Iceland_jack> I meant readLn
10:45:01 <osa1> you're*
10:45:12 <merijn> osa1: I use syntastic and have that take care of calling hdevtools
10:45:26 <merijn> osa1: I just specify a bunch of extra files in my .vimrc
10:45:43 <Iceland_jack> @ty replicateM 10 readLn :: IO [Int] -- cyrix
10:45:44 <lambdabot> IO [Int]
10:45:48 <Iceland_jack> @ty sum <$> replicateM 10 readLn :: IO [Int] -- cyrix
10:45:49 <lambdabot>     No instance for (Num [Int]) arising from a use of `sum'
10:45:49 <lambdabot>     Possible fix: add an instance declaration for (Num [Int])
10:45:50 <lambdabot>     In the first argument of `(<$>)', namely `sum'
10:45:54 <Iceland_jack> @ty sum <$> replicateM 10 readLn :: IO Int -- cyrix *
10:45:55 <lambdabot> IO Int
10:45:56 <cyrix> yeah got it
10:46:06 <osa1> merijn: can you share your syntastic settings? I never used that but I might give it a try
10:46:08 <Iceland_jack> sorry for the spam
10:46:15 <cyrix> :t fmap sum . replicateM 10 $ readLn
10:46:16 <lambdabot> (Num b, Read b) => IO b
10:46:39 * hackagebot resource-effect 0.1.0 - A port of the package 'resourcet' for extensible effects.  http://hackage.haskell.org/package/resource-effect-0.1.0 (ClarkGaebel)
10:47:26 <cyrix> :t sum <$> replicateM 10 readLn
10:47:28 <lambdabot> (Num b, Read b) => IO b
10:47:29 <merijn> osa1: https://github.com/merijn/dotfiles/blob/master/vimrc#L186-L222
10:47:45 <cyrix> sweet
10:47:52 <osa1> thanks!
10:50:08 <rtpg> https://github.com/nominolo/HTTP/commit/b9bd0a08fa09c6403f91422e3b23f08d339612eb
10:51:27 <cyrix> I am not sure I understand the difference between read vs readIO. typing either of them in ghci gives me exception.
10:51:32 <cyrix> "The readIO function is similar to read except that it signals parse failure to the IO monad instead of terminating the program."
10:51:57 <merijn> :t readIO
10:51:58 <lambdabot> Read a => String -> IO a
10:52:15 <merijn> cyrix: I think readIO throws a catchable exception
10:52:15 <enthropy> you can catch the exception that readIO makes
10:52:23 <merijn> cyrix: In any case, you shouldn't use either
10:52:34 <merijn> cyrix: You want Text.Read.readMaybe (ghc 7.6 and later)
10:52:41 <enthropy> you can catch the one read makes too, but that's tricky
10:52:43 <cyrix> why cant one catch exception thrown by read?
10:52:44 <merijn> Or reads (any GHC version)
10:53:08 <merijn> cyrix: read doesn't throw a "real" exception, so it can escape and be thrown by pure code outside the handler
10:53:46 <merijn> cyrix: Basically, since it's not in IO you don't control where "read" is evaluated, and thus can't guarantee it's evaluated inside a "catch"
10:54:02 <merijn> cyrix: With IO you control where it's evaluated, so you know where to catch the exception
10:54:50 <cyrix> we would have to force evaluation with seq to catch it?
10:55:02 <merijn> cyrix: Even then it's tricky
10:55:05 <merijn> :t catch
10:55:06 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
10:55:13 <merijn> That's the easiest way
10:56:12 <sritchie> posco: what the hell are you doing here, son
10:56:18 <cyrix> does this apply to any pure function that throws exceptions? should we avoid that?
10:57:04 <razieliyo> hi
10:57:09 <jle`> hi razieliyo
10:57:25 <razieliyo> when trying to install gloss, I have this error:
10:57:26 <razieliyo> cabal: Missing dependency on a foreign library:
10:57:27 <razieliyo> * Missing C library: GL
10:57:51 <razieliyo> I know it's a very basic issue but I've searched for my opengl packages and have setted --extra-lib-dirs and --extra-include-dirs without success
10:58:23 <razieliyo> and get the same with "cabal install opengl"
10:58:35 <razieliyo> is there any know issue around this?
10:58:39 <razieliyo> known*
10:59:08 <merijn> cyrix: Yes, in general exceptions can only be properly handles in IO
10:59:53 <monochrom> razieliyo: if ubuntu or debian, apt-get install freeglut3-dev
11:00:16 <razieliyo> monochrom, it's installed :S
11:00:30 <geekosaur> that's not freeglut3-dev
11:00:41 <geekosaur> it may be mesa-dev
11:00:43 <jle`> :t mconcat <$> (fmap $ fmap Sum) <$> replicateM 10 (readMaybe <$> getLine)
11:00:44 <lambdabot> Not in scope: `readMaybe'
11:00:45 * geekosaur pokes
11:00:53 <razieliyo> also libgl1-mesa-dev
11:00:54 <jle`> heh.
11:01:05 <merijn> :t readMaybe
11:01:06 <lambdabot> Not in scope: `readMaybe'
11:01:11 <merijn> :t Text.Read.readMaybe
11:01:12 <lambdabot> Read a => String -> Maybe a
11:01:18 <merijn> jle`: Not in scope :)
11:01:27 <razieliyo> so, freeglut3-dev and libgl-mesa-dev are installed, don't know what's going wrong
11:01:40 <jle`> i meant heh as in messy; don't know how to do the same thing with readMaybe
11:01:45 <jle`> :t mconcat <$> (fmap $ fmap Sum) <$> replicateM 10 (Text.Rad.readMaybe <$> getLine)
11:01:46 <lambdabot> Couldn't find qualified module.
11:01:49 <jle`> :t mconcat <$> (fmap $ fmap Sum) <$> replicateM 10 (Text.Read.readMaybe <$> getLine)
11:01:50 <lambdabot> (Num a, Read a) => IO (Maybe (Sum a))
11:02:04 <merijn> jle`: What are you trying to do?
11:02:13 <monochrom> geekosaur, freeglu3-dev will bring in libgl1-mesa-dev, it's a dependency. it's a huge dependency tree there
11:02:40 <razieliyo> /usr/lib/i386-linux-gnu/libGL.so, /usr/lib/i386-linux-gnu/libglut.so
11:02:43 <jle`> a readMaybe version of sum <$> replicateM 10 readLn
11:02:49 <merijn> :t sum . catMaybes <$> replicateM 10 (Text.Read.readMaybe <$> getLine)
11:02:50 <lambdabot> (Num b, Read b) => IO b
11:03:01 <merijn> jle`: catMaybes \o/
11:03:04 <merijn> :t catMaybes
11:03:05 <lambdabot> [Maybe a] -> [a]
11:03:10 <jle`> but i guess that's not the same, it should all fail if one of the things is not read
11:03:15 <merijn> True
11:03:52 <jle`> oh i could sum <$> sequence
11:03:55 <augur> is it possible to use parameterized grammars with parsec?
11:04:08 <rtpg> :t <$>
11:04:10 <lambdabot> parse error on input `<$>'
11:04:18 <jle`> :t (<$>)
11:04:20 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:04:24 <jle`> it's just fmap
11:04:29 <rtpg> oh right
11:04:34 <rtpg> I keep on forgetting
11:04:43 <jle`> rtpg: i like to think of it as $ "inside"
11:04:50 <jle`> > (*2) $ 3
11:04:51 <lambdabot>  6
11:04:54 <jle`> > (*2) <$> Just 3
11:04:56 <lambdabot>  Just 6
11:05:07 <rtpg> oh, never thought of that
11:05:15 <augur> like, i want to have a production rule that has a parameter that's used to constrain subnodes. eg agreement parameters like  NP[sg] -> D[sg] N[sg]
11:05:20 <jle`> > (*2) <$> [3]
11:05:22 <lambdabot>  [6]
11:05:32 <joejev> How hard would it be to write a function to parse coefficients from a string without parsec or happy or something like them
11:06:10 <rtpg> what sort of coefficients joejev ?
11:06:22 <joejev> rtpg: for a quadratic eq, sorry
11:06:51 <skypers> tonight I switch from git to darcs!
11:06:56 <skypers> sounds exciting!
11:06:57 <rtpg> if the form is always ax^2 + bx + c then not too hard
11:07:11 <rtpg> well even if they're moved around
11:07:46 <razieliyo> I found this on my issue http://www.haskell.org/pipermail/beginners/2009-August/002085.html
11:07:57 <razieliyo> but it's from 2009, so I guess it's been fixed
11:08:18 <jle`> > ((sum <$>) . sequence) <$> replicateM 4 (readMaybe <$> getLine)
11:08:19 <lambdabot>  Not in scope: `readMaybe'
11:08:26 <joejev> rtpg: would it be a good idea to write a DFA for that? or no, and the form is ax^2 + bxy + cy^2 + dx + ey + f = 0
11:08:36 <jle`> > ((sum <$>) . sequence) <$> replicateM 4 (Text.Read.readMaybe <$> getLine)
11:08:38 <lambdabot>  Not in scope: `Text.Read.readMaybe'
11:08:50 <rtpg> joejev, is there a reason you need it like this?
11:08:54 <rtpg> like, is this a previous data set
11:09:04 <rtpg> also is it parentheses, are there -'s , etc
11:09:27 <joejev> rtpg: yes, but I would like the order of the terms to not matter, negatives allowed, and maybe even move things over the equality sign, but that would be a lot
11:09:48 <monochrom> MacOS is not ubuntu or debain
11:10:00 <razieliyo> monochrom, but the issue is very similar
11:10:17 <rtpg> if you're not using parentheses, you could probably do this easily
11:10:25 <rtpg> but you'd basically be writing a parser a la parsec anyways
11:10:35 <monochrom> I agree to disagree
11:11:21 <joejev> rtpg: is parsec part of the haskell platform?
11:11:22 <rtpg> anyways, if you want to do it that way, what you could do is : try to "parse" a list of coefficients, when you get to the =, then you just make the values "negative"
11:11:41 <rtpg> ummm.... I think so? It's pretty important so I'd imagine
11:12:07 <joejev> rtpg: yeah, I don't remember dling it, so I guess it wouldn't really add a dependency to use it, but then I would have to learn it
11:12:16 <rtpg> but if you want to do it by hand... take your string, find the first instance of x/y, take everything before that, parse the number
11:12:37 <rtpg> parse the x/y bits (count the x and ys, look for the '^' character)
11:12:40 <rtpg> then repeat
11:13:15 <rtpg> joejev, have you ever written parser grammars before?
11:13:19 <skypers> hey, do you know a way to register a remote target for darcs push / darcs send?
11:13:22 <skypers> like git remote add
11:13:25 <monochrom> the frameworks field is ignored when cabal is on ubuntu. "On Darwin/MacOS X, a list of frameworks to link to. [...] This entry is ignored on all other platforms." straight from the cabal user guide.
11:13:59 <joejev> rtpg: no, this is my first attempt, the only thing I did was write an interpreter for brainf*ck but that was easy and idk if it even counts
11:14:25 <jle`> > sequence [[1,2],[3,4],[5,6]]
11:14:25 <razieliyo> monochrom, so any idea on how to go over this?
11:14:27 <lambdabot>  [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
11:14:28 <jle`> how cool
11:14:41 <monochrom> no, because I cannot reproduce it, it builds fine here.
11:14:46 <rtpg> that language is pretty easy to parse yeah...
11:15:02 <razieliyo> monochrom, alright, thanks for trying!
11:15:09 <ksira> Can anyone tell me why Unboxed vectors are not instances of functor, but boxed vectors are? I don't really get it..
11:15:10 <rtpg> basically your first task would be : write something that takes a String and tries to parse one "value"
11:15:16 <razieliyo> idk what's my issue....
11:15:28 <merijn> ksira: unboxed means the value is stored directly in the vector
11:15:33 <rtpg> so a function of type String -> (Value, String), where the return is the value you found, plus the rest of the string
11:15:46 <rtpg> then you can just apply this function a lot until you get to the equals
11:15:48 <merijn> ksira: The type you're fmapping to may be bigger than than will fit in the new unboxed vector
11:16:05 <rtpg> and on the other side of the equals you can just do the same thing except in negatives
11:16:11 <joejev> rtpg: My idea was to use a DFA for each term, and run all of them over, where they return a Maybe Integer, and then make the Equation data using fromMaybe 0 myResult or whatever
11:16:45 <joejev> rtpg: So Value is like, Integer, and then what is the other string, the original \\ the match?
11:16:54 <skypers> no one?
11:17:00 <skypers> except the --set-default flag
11:17:04 <ksira> merljn: Okay, that makes sense to my internal type checker, thanks.
11:17:10 <skypers> which is not really what I’m looking for
11:17:12 <rtpg> the other is what's left of the string after you parse the first value
11:17:37 <skypers> git remote outputs all the available remote repositories to push into; what’s the same for darcs?
11:17:45 <rtpg> for example, if the entry is "3x^2+2x", the return is (Value("3x^2"), "+2x")
11:18:10 <trolling> I've seen some suggestions of bibtex entries for citing hackage packages, any idea where I might find them?
11:19:11 <joejev> so like, takeWhile (`notElem` "xy") and then peek to see if the next char is ^, if so, take 2 more, if not, return it?
11:20:18 <Kinnison> Unless you *need* to write it yourself for some reason, I strongly recommend using a parsing library like Parsec to help you with this kind of thing.
11:20:42 <merijn> Since System has already claimed the name ExitCode, does anyone have any suggestions for the "return value" of a connection/session?
11:20:55 <Kinnison> SessionResult
11:21:01 <joejev> ConnectionExitCode
11:21:10 <joejev> SessionExitCode
11:21:56 <merijn> joejev: See, those are too long, I already have to linewrap half my types >.>
11:22:08 <monochrom> QuitCode
11:22:18 <monochrom> DisconnectCode
11:23:20 <merijn> QuitCode is the most pleasing in length, I guess.
11:24:02 <joejev> merijn: Do you limit line length? also, is that common for haskell, I like 80 chars, but idk if that is frowned upon or something
11:24:02 <johnw> ECode
11:24:28 <Kinnison> J
11:24:45 <monochrom> I allow myself 90 columns. and a bit more in exceptional cases.
11:24:57 <johnw> i limit to 80
11:24:58 <merijn> I usually stick to 80 columns
11:25:05 <haasn> I hard cap at 80
11:25:13 <merijn> I guess ExitStatus would work
11:25:29 <trolling> I tend to cap at 78 so that I can view diffs in 80x24
11:25:29 <haasn> jesus
11:25:34 <haasn> Oh, wrong chat
11:25:36 <osfameron> cap?
11:25:57 <joejev> okay, so 80 chars is common? what does XMonad use?
11:25:59 <trolling> osfameron: set my upper bound on line length*
11:26:28 <osfameron> ah ok
11:27:02 <monochrom> 20 years ago, I would agree with people who say "use the printer's limit". it's a good choice.
11:27:19 <cyrix> :t fmap sum . mapM readMaybe <$> replicateM 2 getLine   -- how to rewrite this so that it stops reading after first unparsable input?
11:27:21 <lambdabot> Not in scope: `readMaybe'
11:27:22 <trolling> I have a friend who has been known to right-align code
11:27:29 <osfameron> cute
11:27:32 <Hodapp> arabic?
11:27:32 <monochrom> the printer's limit is 132 columns for wide printers at school, and 132 columns again for home printers when put in condensed mode
11:27:38 <osfameron> I think I've done it for some very specific reason
11:27:38 <SrPx> What is a good name for a function that receives a function F and a number N and returns a function that applies F N times to its argumetn?
11:27:50 <trolling> SrPx: paul
11:27:51 <merijn> :t iterate
11:27:53 <lambdabot> (a -> a) -> a -> [a]
11:27:54 <liter> Good morning
11:28:00 <SrPx> trolling: thanks
11:28:07 <trolling> you're welcome
11:28:13 <SrPx> trolling: wait you're not trolling me are oyou
11:28:14 <monochrom> and for the screen, 25 years ago, the Hercules display card could also display 132 columns
11:28:22 * trolling ? me?
11:28:24 <augur> hmm
11:28:32 <augur> my naive dyck language parser doesnt work :(
11:28:34 <Hodapp> trolling: do you use that name just so that when someone says "You're trolling" you can jump in and say, "No, I am!"?
11:28:39 <monochrom> it is delighting to see that as technology progresses, we have fewer columns to use!
11:28:42 <trolling> Hodapp: pretty much
11:28:51 <trolling> I have a huge grin on my face every single time, too
11:28:58 <joejev> monochrom: that made me chuckle
11:29:04 <liter> I seem to have a problem compiling objects when there is both FFI and TH involved - TH seems to start generating bytecode, which tries to resolve FFI symbols, which fails (note that I don't want to link, just generate objects).
11:29:05 <merijn> monochrom: My screen can't fit two terminals at 132 char width, though!
11:29:18 <Hodapp> TH generates bytecode?
11:29:19 <liter> Did anyone stumble on similar issue? If so is there a workaround (apart from not using TH)
11:29:33 <liter> Hodapp: well, shares the same mechanism as GHCI (as I was told)
11:29:42 <joejev> merijn: that is one of my reasons for using 80, I can get 3 pages on a screen
11:29:49 <liter> guess to execute the TH itself? don't know
11:29:52 <silasm> merijn: exactly, I use 80 characters mostly because that means two terminals side-by-side.
11:29:53 <osa1> what type to use when declaring FFI binding for a C function that takes a struct as parameter? (not a pointer to struct, just struct)
11:29:58 <liter> (but surely it enters the BytecodeGenPhase or what)
11:30:28 <geekosaur> osa1: I don't think FFI can do that very easily, if at all
11:30:34 <haasn> SrPx: times!
11:30:37 <haasn> SrPx: 3 `times` f
11:31:02 <SrPx> haasn: isn't times used for, for example, "times 4 -> [4 4 4 4]" ?
11:31:09 <haasn> SrPx: that's replicate
11:31:10 <SrPx> times 4 4 *
11:31:11 <int-e> monochrom: I don't believe that the HGC could do that. In any case the clone I was using for a while couldn't.
11:31:13 <SrPx> haasn: oh.
11:31:17 <osa1> geekosaur: that struct have 4 uint8 members, does Word32 work for this?
11:31:34 <geekosaur> osa1: it might; depends on the C compiler
11:31:40 <SrPx> haasn: thanks!
11:31:45 <haasn> SrPx: actually, write a Num instance for it and just use “4”
11:31:45 <osa1> hm
11:31:50 <haasn> or fromInteger, technically ;)
11:33:02 <monochrom> ok, int-e, then some older display card did it.
11:33:10 <haasn> SrPx: if you can afford the overhead, you can also use foldr (.) id . replicate n
11:34:11 <monochrom> by the 50th anniversary of Apple II, we will be doing 40 columns. "because I'm coding on iPhone"
11:34:42 <haasn> :t ala Endo . foldMapOf . replicated
11:34:43 <lambdabot> Int -> (a -> a) -> a -> a
11:34:46 <haasn> SrPx: ^
11:36:05 <scott_> :t (\n f x -> iterate f x !! n)
11:36:06 <lambdabot> Int -> (a -> a) -> a -> a
11:36:33 <SrPx> haasn: ah interesting thank you! c:
11:36:45 <scott_> > iterate (*2) 1 !! 10
11:36:46 <lambdabot>  1024
11:37:04 <haasn> > ala Endo (foldMapOf $ replicated 10) (*2) 1
11:37:07 <lambdabot>  1024
11:37:12 <haasn> longer :(
11:37:19 <haasn> but more lensy, so you get extra style points
11:39:24 <nisstyre> gotta love generated code, http://ideone.com/lT6YCn
11:40:14 <nisstyre> hmm, I see a bug with that -1 should be (-1)
11:40:56 <nisstyre> or rather it should be a function call :/
11:41:10 <triliyn> No, it's supposed to be fib (n - 1)
11:41:15 <triliyn> Isn't it?
11:41:29 <triliyn> So it's correct
11:41:32 <triliyn> Just confusingly spaced
11:42:08 <nisstyre> triliyn: yes, it's correct, but just by mistake
11:42:14 <monochrom> haha, who generated that scheme code? :)
11:42:28 <nisstyre> monochrom: I'm testing a compiler I'm working on
11:42:36 <monochrom> fun
11:43:21 <cyrix> this is pretty ugly.. any suggestions on making it nicer?  http://lpaste.net/96790
11:44:19 <Ralith> cyrix: use do notation in Maybe
11:44:33 <Eduard_Munteanu> Let T a  ~~  a | F (T a) where Functor F | T a -> T a. Is there a lens-like thing that can transform T a into T b, given 'a -> b' and 'b -> a'?
11:45:24 <cyrix> Ralith: I am not sure how when I am already using do notation for IO
11:45:38 <Ralith> do { x <- readMaybe line; xs <- readManyLn (n - 1); return (x:xs); }
11:45:49 <Ralith> cyrix: a 'do' block is just like any other expression
11:46:04 <cyrix> wow that easy?
11:46:18 <Eduard_Munteanu> > do (1 + 1)  -- :P
11:46:20 <lambdabot>  2
11:46:46 <nisstyre> monochrom: if you're curious, this is the code that got generated from https://gist.github.com/nisstyre56/7879427
11:46:54 <Eduard_Munteanu> Don't mind me though.
11:47:09 <shachaf> Eduard_Munteanu: I don't understand your notation.
11:47:12 <nisstyre> yes it looks kinda like scheme had a baby with python
11:48:00 <monochrom> even better: scheme had a baby and the other parent may be python or ruby, we don't know which :)
11:48:16 <joelteon> > do ()
11:48:17 <lambdabot>  ()
11:48:53 <cyrix> Ralith: I have to return the maybe do block too though, to make it IO (Maybe) and I cant figure out the syntax. return
11:49:05 <Ralith> cyrix: return is just a function
11:49:25 <cyrix> i have tried return (do ... )
11:49:25 <joelteon> > 3 + do 4 :: Int
11:49:26 <lambdabot>  7
11:49:31 <joelteon> one nice way to avoid parentheses
11:49:54 <zol> A monad is any type that defines how >>= applies to it?
11:50:01 <Sorella> nisstyre: Looks like SRFI 49, but with parenthesis.
11:50:05 <Ralith> cyrix: that should work, but note that if you want a one-line do you need to use brackets and semicolons as in my example; alternatively, newline and indent
11:50:06 <johnw> zol: and "return"
11:50:10 <tac> > (do (+)) <$> (do 1) <*> (do 2)
11:50:11 <lambdabot>  No instance for (Control.Applicative.Applicative f0)
11:50:12 <lambdabot>    arising from a use of `e_112'
11:50:12 <lambdabot>  The type variable `f0' is ambiguous
11:50:12 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
11:50:13 <zol> johnw: right, thanks!
11:50:13 <lambdabot>  Note: there are several potential instances:
11:50:17 <Eduard_Munteanu> shachaf: hm, let me simplify a bit: say I have   type T a = a -> ... -> Foo a,  basically the type of functions taking 'a' as input and returning another 'a', possibly in a functor.
11:50:24 <merijn> zol: Well, >>= and return
11:50:27 <Ralith> cyrix: you could also do 'return $ do', then newline and indent
11:50:39 <merijn> zol: Additionally there are some laws that all "sane" monad instances should follow
11:50:49 <Eduard_Munteanu> shachaf: I want to transform such functions T a into T b, if I have a function (a -> b) and another one (b -> a).
11:51:00 <cyrix> Raith oh there is one issue
11:51:01 <merijn> zol: For example "x >>= return . id" should have the same result as "x"
11:51:10 <computio1ist> good morning!
11:51:26 <cyrix> readManyLn returns IO, so I cant use it in a do block :/
11:51:27 <shachaf> Eduard_Munteanu: Maybe see http://hackage.haskell.org/package/invariant ?
11:51:27 <zol> merijn: Aha, I knew it wasn't as simple as I thought. Thanks. :)
11:51:41 <shachaf> Of course, it won't work with a type syonym.
11:51:44 <cyrix> (in a maybe do block)
11:51:51 * hackagebot extensible-effects 1.2.1 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-1.2.1 (BenFoppa)
11:52:02 <computionist> I'm having trouble building cabal-1.18.1.2 on windows.
11:52:19 <Eduard_Munteanu> shachaf: ah... I was wondering if there's a lens for that though.
11:52:30 <activeaspect> is anyone familiar with the problems building gtk2hs while running xcode 5? i've followed the advice to build ghc head and still see problems.
11:52:57 <cyrix> how can I handle this?
11:54:06 <shachaf> Eduard_Munteanu: A lensy equivalent of over for invariant functors?
11:54:18 <Eduard_Munteanu> shachaf: nevermind, I'm lying... I don't have those two functions generally. I can transform a to b and back in the *same* context instead.
11:54:40 <computionist> Here's a paste of the error I get: http://lpaste.net/96791
11:55:07 <computionist> It looks like it builds but then can't find setup.exe in the dist it built.
11:55:39 <Eduard_Munteanu> shachaf: no, a 'Something (T a) (T b) a b' of sorts, that's a lens-like thingy.
11:59:00 <Eduard_Munteanu> shachaf: for instance  Something (T a) (T b) a b  ~   (b -> (a, c)) -> ((a, c) -> b) -> (T a -> T b).  (T a and T b, and 'a' and 'b' respectively aren't isomorphic.)
12:00:55 <Eduard_Munteanu> Maybe I should use the Iso encoding for lenses, i.e. a Lens is an Iso between a and (b, c) (some context).
12:03:06 <ocharles> Woohoo, got the go-ahead on publishing a guest post for 24 Days of Hackage today
12:03:14 <johnw> which package?
12:03:19 <ocharles> that'd be telling now, wouldn't it?
12:03:42 <computionist> Alright I have 1.18.0.2 at least, so I guess that'll work.
12:03:42 <ocharles> I just need to craft a new page template so I don't claim ownership and I can throw it on the internets
12:03:57 <merijn> What's the best type for ascii C strings? String or ByteString?
12:04:03 <haasn> merijn: CString ?
12:04:16 <merijn> haasn: No, that's a char* for the FFI
12:04:18 <johnw> merijn: a CString is directly convertible to/from a ByteString
12:04:37 <ocharles> merijn: What do you want to do with these strings?
12:04:51 <merijn> ocharles: print and pass along unchanged
12:05:07 <merijn> I'm getting identifiers from the network which are defined as ascii C strings
12:05:11 <johnw> i'd using CString and withCString then
12:05:21 <merijn> johnw: There is no actual char* anywhere
12:05:25 <johnw> then peek them into a ByteString
12:05:29 <merijn> So CString and withCString is pointless
12:05:40 <merijn> I'm parsing them directly in Haskell
12:05:47 <merijn> The question is just what I should parse them into
12:06:00 <haasn> ByteString doesn't sound too wrong if you're just using them as static identifiers
12:06:04 <johnw> ah
12:06:05 <merijn> I guess the third option is Text
12:06:09 <ocharles> merijn: I would parse into Text
12:06:14 <johnw> with Text you need to worry about encoding
12:06:19 <johnw> do you have a guaranteed encoding?
12:06:29 <haasn> which also means you need to worry about invalid values
12:06:30 <merijn> johnw: printable C string
12:06:40 <johnw> what does that mean?
12:06:51 <merijn> johnw: You decide :p
12:06:53 <haasn> by keeping them opaque unless you need them otherwise, you could mitigate/defer that risk
12:06:55 <johnw> then bytestring
12:07:17 <Eduard_Munteanu> shachaf: am I making no sense again? :)  Just let me know, I'm a bit confused myself.
12:07:48 <johnw> if you don't want to know and just want to pass it along for the terminal to decode however it would be default, bytestring is really the only sane choice
12:08:12 <johnw> otherwise, with String or Text you're forced to interpret the data
12:09:24 <merijn> johnw: It's basically ascii, because that's the only encoding that exists for systems level code
12:09:27 <johnw> i made this mistake with git, btw
12:09:42 <johnw> i was using Text because it seemed right, but realized that I have to take a "hands off" approach to what the strings mean
12:10:22 <johnw> merijn: even still, bytestring is closer to the truth
12:11:25 <merijn> hmm
12:11:34 <merijn> Is there a datatype for IP adresses somewhere?
12:12:43 <johnw> network-address?
12:15:28 <merijn> hmm, that just seems to be Word32 and (Word64, Word64), might just provide my own type for that
12:16:02 <Eduard_Munteanu> merijn: perhaps it might be useful to use String / Text and remember hostnames?
12:16:36 <Ralith> merijn: what's wrong with those types?
12:16:49 <merijn> oh
12:17:00 <merijn> Ralith: Nothing, but not work adding a bunch of dependencies for
12:17:08 <Ralith> ah
12:17:12 <merijn> But network has SockAddr, that's better
12:17:59 <joelteon> network-address has ridiculous constraints on Cabal's version
12:21:59 * hackagebot HTTP 4000.2.10 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.10 (GaneshSittampalam)
12:23:04 <Heffalump> (the HTTP release is courtesy of a nice performance fix by nominolo - it reportedly shaves 10s of seconds off cabal update)
12:23:54 <joelteon> nice one nominolo
12:24:33 <johnw> i did often wonder what cabal update was doing
12:24:53 <byorgey> Heffalump: =D
12:25:01 <jle`> yeah i never could understand why it took so long
12:25:01 <byorgey> nominolo++
12:25:07 <jle`> to just...download a plaintext file
12:25:18 <johnw> well, it downloads a .tar.gz
12:25:21 <johnw> but it's not that big
12:25:27 <johnw> 6M right now I think
12:27:21 <Heffalump> johnw: me too, but I always assumed my internet connection was at fault :-)
12:27:50 <johnw> in fact, unless I'm missing something, this is all that cabal update does:
12:27:51 <johnw> curl -s -o - http://hackage.haskell.org/packages/index.tar.gz | gzip -dc > ~/.cabal/packages/hackage.haskell.org/00-index.tar
12:28:13 <Heffalump> I think so, except it runs on platforms without curl installed
12:28:24 <shachaf> Should use https, now that haskell.org supports it.
12:28:42 <shachaf> Hmm, HTTP the library doesn't, though, does it.
12:28:45 <johnw> so, on my machine that's a 6s operation
12:28:51 <Heffalump> which would require getting a stack that supports SSL into the platform
12:29:00 <Heffalump> someone was looking at adding https to HTTP
12:29:02 <johnw> right, that's been discussed on cafe a bit
12:29:22 <shachaf> Hopefully not one of the packages that implements everything on its own in pure Haskell.
12:29:28 <Heffalump> https://github.com/haskell/HTTP/issues/17
12:30:01 <fjdddd> Hm, I've created the cabal file as c_wraith suggested, but I can't find MyFile.hs after running cabal configure && cabal build. Where should I look for the generated .hs file?
12:30:07 <fjdddd> dcoutts ^
12:30:18 <Heffalump> shachaf: that's an interesting argument, for one thing if it's not in pure Haskell, how do you manage the platform?
12:30:30 <shachaf> Heffalump: Lots of things in the platform have C bindings.
12:30:31 <Heffalump> but there are obvious risks too
12:31:13 <Heffalump> shachaf: what C libraries does it bundle?
12:31:46 <shachaf> I don't remember what's in the platform because I've mostly stopped caring about it.
12:32:02 <shachaf> Doesn't OpenGL use C bindings?
12:33:13 <byorgey> =D it works!  http://lpaste.net/96798   cabal update went from 17.5s to 6s
12:33:26 <byorgey> nominolo++
12:33:30 <byorgey> deserves another ++
12:33:38 <sm> ooh I'll take that.. nominolo++
12:33:51 <Feuerbach_> I cannot reproduce it somehow... still at 60s
12:33:59 <monochrom> yes, OpenGL uses a ton of C bindings, it is a hurdle when building Haskell Platform from source
12:34:31 <Eduard_Munteanu> That's part of HP? :O
12:34:48 <shachaf> Everything is, these days.
12:35:52 <Heffalump> Feuerbach_: if you were being hit by the performance bug, it would be using CPU for most of that time
12:36:27 <byorgey> Heffalump: interesting, for me it went from 17% CPU (before updating HTTP) to 47%
12:36:38 <monochrom> OpenGL had been in Haskell Platform since many years ago
12:36:58 <monochrom> in fact probably since the very first version
12:37:24 <monochrom> indeed, once upon a time, GHC itself came with both OpenGL and OpenAL. fancy that.
12:37:48 <monochrom> Haskell Platform started its life as taking up libs that GHC no longer wanted.
12:38:39 <Feuerbach_> Heffalump: CPU usage was and stayed at about 10%
12:38:55 <Peaker> merijn: why did you write >>= return . id      above there? What's the composition with id for?
12:39:11 <merijn> Peaker: brainfart
12:39:27 <merijn> Peaker: I was thinking of "fmap id" and then translated to monad
12:39:35 <monochrom> hehe
12:39:46 <monochrom> but wait a second!
12:40:02 <monochrom> isn't it a law "fmap id x = x"?!
12:40:03 <startling> monochrom: woah, weird
12:40:13 <startling> I guess it'd be easier to build that way
12:40:19 <Peaker> merijn: heh, I never saw that equivalence before :)
12:40:35 <Eduard_Munteanu> I think bindings belong upstream in some ways.
12:40:53 <startling> there definitely should be a better way to do them.
12:41:37 <Eduard_Munteanu> It's a bit sad interfaces are blessed and tied with the implementation.
12:44:31 <Heffalump> byorgey/Feuerbach_: ok, so I have no idea about anything then :-) Given that the performance bug was a quadratic reverse operation, I can't really explain CPU usage going up, albeit that I guess in byorgey's case if you multiply time by percentage you still get a lower number.
12:44:46 <merijn> Yay! Time to play the "solve the circular import"-game!
12:45:42 <johnw> what should I reinstall after install the new HTTP?  just Cabal/cabal-install?  I did that, but it's still 12s
12:45:54 <monochrom> is that like Wheel of Fortune? can I buy a vowel?
12:46:06 <adimit> is there something similar to the Reader monad but "lighter?" I don't need, say sequential operation and binds in my case (and I think maybe ReaderMonads rarely do…) so I'd maybe like to have just a functor, or something.
12:46:21 <merijn> monochrom: Yes, except instead of buying a vowel you shuffle data definitions and import statements around at random
12:46:45 <monochrom> ooohhhh!
12:47:13 <fjdddd> How can I write a Storable instance for a struct that has a pointer to some other type as one of the fields?  Can I define that type as ()?  Could anyone show an example?
12:47:14 <monochrom> adimit: consider the Reader applicative :)
12:47:56 <Feuerbach_> johnw: just cabal-install
12:48:44 <byorgey> johnw, Feuerbach_: well, you have to make sure it compiles against the new HTTP and not the old one
12:48:45 <Feuerbach_> johnw: cabal install --constraint 'HTTP ==4000.2.10' cabal-install
12:48:50 <Feuerbach_> yep
12:48:57 <johnw> aha
12:50:01 <Heffalump> johnw: you might also want to uninstall old ones from your package database
12:50:02 <adimit> monochrom: well, for example. Though even (*>) seems almost overkill. (I want to annotate a (Tree a) to a (Tree (Type a)), where Type carries information about the position of `a` in the Tree. This then allows comparing values of (Type a) in subsumption relations, etc, but that only makes sense against *a specific tree.*)
12:50:24 <Feuerbach_> Heffalump: for me curl+gz takes 37s (compared to cabal's 60s), fwiw
12:50:58 <aphury> If one would write a parser in Haskell, which parses expressions based on some runtime information (like "contexts", e.g. where variable names are stored), would one simply add a context parameter to every function definition?
12:50:59 <Heffalump> also, I don't know that everyone was being hit significantly by this performance bug, I think it was quadratic in the number of chunks pulled off the network at some critical point, but I don't really have a good understand of what would influence that chunking
12:51:16 <adimit> also I've never heard of the reader applicative, so I guess I'll just code it up myself… I'm thinking maybe I can even just have a Reader Functor?
12:51:46 <Heffalump> adimit: Reader is a monad, applicative and functor all-in-one
12:51:49 <byorgey> adimit: Reader already is an instance of Applicative.
12:51:51 <mr-> adimit: then don't use >>= and return ;-P
12:52:15 <shachaf> There isn't much of a reason to use the type Reader. Just use ((->) r).
12:52:27 <byorgey> good point
12:52:46 <startling> adimit, ReaderT is already a functor transformer :)
12:52:58 <c_wraith> Yeah, ReaderT is a lost more useful than Reader
12:53:06 <byorgey> adimit: if all you had to work with Reader (or ((->) r) ) was fmap, it wouldn't get you all that far.
12:53:28 <byorgey> Applicative lets you run two computations which both depend on some read-only environment, and combine their results
12:53:53 <adimit> byorgey: then that seems to be pretty much what I want.
12:53:59 <c_wraith> iirc, the Reader Monad instance doesn't add any additional functionality to the Applicative instance
12:54:25 <merijn> Does Data.Binary not provide a way to get a specific constant?
12:54:34 <adimit> I'll need to think about it a bit more then. Really, what I want to do is avoid having to say "Monad" where the full power of Monad is not really needed. It seems inelegant to do that.
12:54:48 <startling> merijn, empty if it's not the constant you expect
12:54:50 <adimit> (as in, just not use >>=, fail)
12:54:53 <byorgey> adimit: sounds good
12:55:05 <c_wraith> adimit: yeah, I think Applicative will do
12:55:45 <adimit> Well. There was an article in the Monad.Reader (ha!) about abstractions with Applicatives, I'll go read that.
12:56:08 <adimit> wait, it's the Comonad.Reader.
12:56:09 <merijn> startling: Yeah, but "val <- get :: ExpectedType; if val == x then return () else empty" seems a bit ugly, I'm surprised there's no build in function for that
12:56:24 <edwardk> by sclv
12:56:27 <startling> merijn: fair enough
12:56:41 <merijn> I was hoping binary had something nicer hidden somewhere
12:56:49 <merijn> It seems like a rather common usecase
13:00:15 <c_wraith> merijn: just name it expect and send a patch
13:03:45 <lykos_> Hello. I'm looking for a way to capture the microphone with Haskell, any ideas? Preferably in a flac format.
13:04:36 <Feuerbach_> lykos_: try gstreamer
13:05:37 <passiveobserver> lykos_: also maybe you should use other i/o oriented better suited language for that and then use submodule from haskel
13:06:23 <Eduard_Munteanu> lykos_: might be possible to just read from some /dev entry
13:07:11 <Eduard_Munteanu> lykos_: e.g. /dev/snd/pcmC0D0c
13:07:21 <Eduard_Munteanu> On Linux, that is.
13:08:01 <lykos_> Thanks everyone
13:08:33 <lykos_> Eduard_Munteanu: I'd prefer it to be cross platform, although that would be fun to do.
13:17:13 <fjdddd> c_wraith: I tried to invoke hsc2hs via cabal as you suggested.  But it failed to compile.  The .hsc code was generated by c2hsc.  Is it a known issue, or does it indicate some problem on my side?
13:17:29 <johnw> failed how?
13:17:38 <johnw> Feuerbach_: hmm... still 12s
13:17:52 <c_wraith> fjdddd: oh.  Hmm.  I don't know about using c2hsc, I'm only used to using hsc directly
13:18:06 <fizbin> Wow. Now that I know I'll only have one more slow
13:18:21 <fizbin> 'cabal update', it seems hard to wait for it to finish...
13:19:00 <sm> it is *really* slow right now
13:19:35 <fizbin> I know. And knowing that there's a fix out there (see reddit) makes it feel slower...
13:19:35 <Feuerbach_> johnw: yeah, I didn't feel the difference either. Still, isn't nearly as bad as 60s (which is what I experience) — maybe that will cheer you up ;)
13:19:52 <Feuerbach_> fizbin: don't set your expectations too high
13:20:42 <adimit> does the new version of cabal-install trap Ctrl-C in sandbox'd cabal repl?
13:21:14 <adimit> I really hate that it doesn't do that.
13:21:37 <merijn> How do I construct strict ByteString with binary?
13:21:39 <monochrom> perhaps hackage is being slashdotted :)
13:21:45 <adimit> nope, doesn't seem to be doing it…
13:21:48 <merijn> Put only seems to create lazy BS?
13:22:18 <fjdddd> johnw: Well, I'm getting lots of warnings/errors (undeclared things, wrong types, etc.).  Then it simply says compiling dist/build/Foo_hsc_make.c failed (exit code 1).  I guess I should try to write hsc by hand as suggested here http://www.haskell.org/haskellwiki/FFICookBook#Working_with_structs if I find an example of binding a struct, which has a pointer to a non-scalar type.
13:23:23 <johnw> can you show me the resulting .hsc file?
13:25:57 <marx2> @src liftA2
13:25:58 <lambdabot> liftA2 f a b = f <$> a <*> b
13:26:20 <marx2> @type liftA2
13:26:22 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:26:53 <marx2> why is convention to use `f' instead of `a' as a type variable for applicatives?
13:27:02 <shachaf> f for functor
13:27:08 <simpson> And that's good enough for me.
13:27:09 <shachaf> Or maybe type function.
13:27:27 <merijn> Someone rescue me from confusion
13:27:29 <marx2> but f is used for Functor too
13:27:32 <shachaf> 'a' is usually only used for type of kind *
13:27:46 <shachaf> Right, and every Applicative instance is a Functor instance.
13:27:53 <merijn> First I get told I should use binary instead of cereal, because binary is faster, but now I discover binary can't do strict bytestrings
13:27:57 <merijn> So which should I use?
13:28:09 <marx2> shachaf and every Monad instance is a (or should be) a Functor instance too, yet we use `m' for monads not `f'
13:28:18 <shachaf> OK.
13:30:13 <merijn> Anyone?
13:30:31 <simpson> merijn: Honestly, cereal's always been fast enough for me.
13:31:01 <merijn> simpson: That doesn't tell me much without knowing what was "fast enough" for you :)
13:31:45 <simpson> merijn: I used it to decode Minecraft protocol frames in a networking application. It was fast enough that it was not the bottleneck in the application. I don't know what you're building.
13:32:15 <Eduard_Munteanu> marx2: how else would you abbreviate "applicative"? Plain 'a' would be confusing.
13:33:02 <marx2> Eduard does it have to be single letter?
13:33:11 <Eduard_Munteanu> No.
13:33:15 <marx2> then ap
13:33:39 <merijn> simpson: ZMQ implementation, so it's not so much "how fast do I need to be" and more "be as fast a possible for potential users"
13:33:52 <fizbin> :t ap
13:33:53 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:34:13 <Eduard_Munteanu> marx2: mind Monad isn't a functor
13:34:24 <Eduard_Munteanu> Doesn't imply, that is.
13:34:30 <johnw> but will!
13:35:03 <mauke> the full name is "applicative functor"
13:35:35 <marx2> then af is an even better name. and it won't bother fizbin :)
13:36:02 <johnw> how about lax, for strong lax monoidal functor
13:36:38 <adimit> too much like laxative.
13:36:46 <Eduard_Munteanu> Lax consensus. :P
13:37:04 <shachaf> "lax functor" means something else.
13:37:20 <shachaf> Also, "strong lax monoidal functor" sounds deliberately confusing.
13:37:26 <shachaf> Since it's not a strong monoidal functor.
13:37:31 <johnw> and free monoid monad monad algebra doesn't, certainly
13:37:37 <mauke> inb4 clopen
13:37:53 <Eduard_Munteanu> shachaf: strong here means strength
13:38:02 <shachaf> Right.
13:38:15 <shachaf> I'm not saying it's wrong, just that it sounds deliberately confusing.
13:38:22 <shachaf> Maybe "lax monoidal strong functor"?
13:38:33 <johnw> that does sound better
13:38:38 <Eduard_Munteanu> "strict" is more correct for monoidal functors than "strong".
13:39:01 <merijn> bah
13:39:37 <merijn> So I replaced my cereal code with binary for nothing and now I have to go put it back >.>
13:39:43 <Hodapp> cereal code?
13:40:01 * Eduard_Munteanu imagines "tight comonoidal weak functor"
13:40:09 <donri> merijn: try the bytes package? ;)
13:40:17 <simpson> merijn: You can always promote strict ByteStrings to lazy ones.
13:40:51 <shachaf> or is it "demote"???
13:41:19 <quchen> Bimote maybe.
13:41:48 <simpson> How about "lift"? A lazy BS is just a list of strict BSs, IIUC.
13:42:10 <ocharles> johnw: there you go!
13:42:18 <Eduard_Munteanu> I think it's more involved than that.
13:42:36 <merijn> donri: oh, that might work
13:42:56 <merijn> donri: Not sure how much overhead that has
13:43:12 <tomejaguar> I think it's invarmote.
13:43:55 <jeltsch> Hi, how should you install GLUT on Windows if you want to use the Haskell GLUT package. I found http://www.transmissionzero.co.uk/software/freeglut-devel/. Is this recommended? Do you need the MSVC or the MinGW version?
13:43:57 <levi> Eduard_Munteanu: Dude, that comonoidal weak functor is *tight*! Where'd you find it?
13:44:30 <merijn> simpson: My problem is that I want strict but binary produces lazy
13:45:03 <shachaf> Pratt declared that "comonoid" without qualifier should imply chu spaces.
13:45:11 <shachaf> http://boole.stanford.edu/pub/comonoids.pdf
13:45:20 <shachaf> Since a Set comonoid is boring.
13:45:28 <simpson> merijn: Can you suffice with a list of strict?
13:45:53 <merijn> simpson: No, I could concat and toChunks it, but that isn't free
13:46:16 <merijn> I don't really understand why they don't just add a strict Put monad to Binary
13:48:44 <shachaf> zomg chu space comonoids are related to linear logic comonoids
13:48:45 <tomejaguar> merijn: Are you writing a pure Haskell implementation of ZMQ?
13:48:48 <merijn> donri: No good, bytes doesn't do incremental Get
13:48:49 <shachaf> not very surprising
13:48:57 <merijn> tomejaguar: ZMTP, but yes
13:48:58 <joejev> how frequently should libraries be updated on hackage? should I wait until I have a lot of changes to release a new version, or should I release all the small changes as _._._.+1 changes?
13:49:27 <dolio> Eduard_Munteanu:  Strong monoidal functors and strict monoidal functors aren't the same thing.
13:49:35 <merijn> argh, this nonsense makes me just want to give up programming altogether...
13:49:46 <shachaf> dolio: Applicative is neither, is it?
13:49:55 <dolio> Right. They're lax monoidal functors.
13:50:02 <Eduard_Munteanu> Yeah, I thought he meant the other one.
13:50:27 <shachaf> Yes. Hence what I said.
13:50:29 <dolio> Or closed functors.
13:50:31 <Eduard_Munteanu> dolio: or closed functor, I hear
13:50:33 <Eduard_Munteanu> hEH.
13:50:43 <merijn> preflex: seen edwardk
13:50:44 <preflex>  edwardk was last seen on #haskell 54 minutes and 18 seconds ago, saying: by sclv
13:50:45 <bergmark> joejev: i don't think anyone minds a lot of minor bumps, i usually release stuff like that immediately if it improves the library for users. i try to hold off on the major bumps for a bit
13:51:21 <dolio> Lax closed functors, I guess.
13:51:57 <Eduard_Munteanu> dolio: I'm unsure why they aren't just exponential-preserving functors, though.
13:52:01 <bergmark> joejev: it can also be nice to put minor things in minor releases so the major bumps seem less intimidating when they see the changelog :)
13:52:15 <Eduard_Munteanu> Pointed exp-preserving functors.
13:52:35 <dolio> That's what a closed functor is.
13:52:48 <dolio> You need monoidal structure to define exponentials.
13:53:02 <shachaf> i love monoids
13:53:12 <tomejaguar> dolio: Thanks for your reply re Oleg's effects paper.
13:53:15 <Eduard_Munteanu> I thought closed functors preserved some notion of "everything" in a category.
13:53:26 <tomejaguar> dolio: I'll write something for fpcomplete.com
13:53:37 <dolio> Closed functors are functors between closed monoidal categories that preserve the exponential.
13:54:03 <dolio> tomejaguar: Sounds good.
13:54:21 <Eduard_Munteanu> dolio: how so? Don't you just need products? And even with products, I guess you don't need all exponentials to preserve exponentials.
13:54:44 <zol> Are there any exercises anywhere available to train on turning functions into point-free style? Also on curry/uncurry?
13:54:46 <joejev> bergmark: thanks, I think I will push my changes after tesing thourougly then.
13:54:51 <dolio> Categories with products are way less general than monoidal categories.
13:55:24 * zol doesn't find it intuitive at all to write functions in point-free style.
13:55:33 <joelteon> you will
13:55:57 <Eduard_Munteanu> dolio: hm, interesting... how about closed monoidal functors, namely a left adjoint to A ^ _.
13:56:05 <mangaba_leitosa> zol: learning the J language might help :-)
13:56:06 <Eduard_Munteanu> s/\./?/
13:56:12 <shachaf> Right adjoint?
13:56:12 <johnw> zol: thinking of it as a data flow helps
13:56:13 <joejev> zol: I agree, sometimes it is good, I really only use it if I am writing a function like, f = g . h
13:56:16 <shachaf> Er, no.
13:56:28 <shachaf> Isn't the definition of A^- that it's a right adjoint?
13:56:45 <shachaf> So that seems like a backwards way of defining it.
13:57:16 <zol> johnw: and each parameter/argument as its own flow? Oh, yeah, good analogy, the data flows can combine into a single flow, or diverge into several others.
13:57:22 <Eduard_Munteanu> Oh, duh, closed monoidal categories are exactly that.
13:57:29 <shachaf> Or maybe of -^A, rather.
13:58:08 <dolio> Yeah, closed monoidal categories are categories with a tensor product (x) and an exponential [,] such that A (x) - -| [A, -]
13:58:09 <Eduard_Munteanu> Er, yeah.
13:58:11 <dolio> Or something like that.
13:59:48 <dolio> And then closed functors preserve the [,] in addition to the tensor and unit.
14:00:12 <dolio> Although nlab notes that every monoidal functor between two closed monoidal categories is a closed functor, I think.
14:00:22 <dolio> So it's not really a distinct thing.
14:01:07 <shachaf> dolio: Really?
14:01:08 <Eduard_Munteanu> dolio: so closed functors merely preserve exponentials? IIRC, Wikipedia made it sound like they preserve more than that (something like "any structure").
14:01:24 <dolio> Saying it's a closed functor I guess says something about the categories it's over.
14:01:26 <dolio> shachaf: I think so.
14:01:29 <raek> zol: try to implement some basic functions from math, for example "factorial", "is perfect number" or "is prime number", by composing functions like "map", "foldr", "filter", "iterate" and "take"
14:01:54 <shachaf> dolio: I remember that a Heyting algebra homomorphism isn't the same thing as a frame morphism, even though the two were the same structure.
14:02:19 <shachaf> Complete Heyting algebra, rather.
14:03:11 <shachaf> That sounds like a similar deal.
14:03:14 <zol> raek: good, idea, thank you
14:03:50 <shachaf> https://en.wikipedia.org/wiki/Complete_heyting_algebra
14:03:56 <dolio> shachaf: Reading, I guess it only works in general for lax closed functors.
14:05:38 <dolio> shachaf: F([X,Y]) (x) F(X) -> F([X,Y] (x) X) -> F(Y), so F([X,Y]) -> [F(X), F(Y)]
14:06:43 <dolio> It's lax because you use the evaluation morphism [X,Y] (x) X -> Y.
14:06:48 <dolio> I think.
14:06:56 <dolio> But Applicative is lax anyway.
14:07:59 <dolio> So strong and strict closed functors are more distinctive, I guess.
14:08:07 <Eduard_Munteanu> dolio: isn't lax wrt to the tensor product not being equal on the nose?
14:08:17 <tomejaguar> Eduard_Munteanu: That's weak.
14:08:39 <Eduard_Munteanu> Oh, right, as opposed to strict.
14:08:51 <dolio> Eduard_Munteanu: Lax means that there is just a transformation F([X,Y]) -> [F(X), F(Y)], rather than an isomorphism or identity.
14:09:00 <dolio> And same for the tensor and unit.
14:10:23 <shachaf> dolio: Hmm, so what's the Heyting algebra thing I'm thinking of?
14:10:57 <dolio> shachaf: Dunno.
14:11:14 <tomejaguar> Actually I take it back.  It seems that "weak monoidal" has a strange etymology.
14:11:21 <shachaf> A frame homomorphism preserves finite products, which are the monoidal structure used to define exponentials, but it doesn't preserve exponentials.
14:11:47 <Eduard_Munteanu> I take mine back too, weak seems to go with strong.
14:11:55 <dolio> What does preserve mean?
14:12:14 <shachaf> Ah, I guess it is equality.
14:12:29 * hackagebot blaze-builder 0.3.3.1 - Efficient buffered output.  http://hackage.haskell.org/package/blaze-builder-0.3.3.1 (SimonMeier)
14:12:40 <shachaf> OK.
14:12:53 <Eduard_Munteanu> liftA2 ($) = ($)?
14:13:23 <Eduard_Munteanu> Where by ($) I actually mean 'eval'.
14:13:30 <jeltsch> liftA2 ($) = (<*>)
14:14:06 <Eduard_Munteanu> I was working in the lifted category. :)
14:17:30 * hackagebot blaze-builder 0.3.3.2 - Efficient buffered output.  http://hackage.haskell.org/package/blaze-builder-0.3.3.2 (SimonMeier)
14:25:56 <ifesdjeen> is there any way to pattern match [1,2,3,4,5] based on the value of some element, for example, split it to [1,2] and [4,5] saying that 3 is the middle element
14:26:06 <johnw> you could using a view pattern
14:26:13 <ifesdjeen> oh
14:26:22 <ifesdjeen> checking
14:27:28 <ion> > let f (break (== 3) -> (ls, _:rs)) = ls ++ rs in f [1..5]
14:27:30 <lambdabot>  [1,2,4,5]
14:27:38 <Bor0> won't something like this do? let f [_,_,x,_,_] = if x == 3 then True else False
14:27:52 <johnw> i'm assuming he doesn't actually know the length of the list
14:27:58 <ifesdjeen> right
14:28:00 <ifesdjeen> i don't
14:28:09 <ion> Also, that “if…” isn’t in the pattern. You could use a guard, though.
14:28:20 <ifesdjeen> ok
14:28:28 <ion> Also, if x then True else False = x
14:28:31 <ifesdjeen> ion: is it possible to use same thing in a function signature?
14:28:39 <Bor0> hehe, right
14:28:43 <ion> ifesdjeen: What do you mean?
14:28:52 <johnw> foo xs | uncurry ((==) `on` length) (break (==3) xs) = ...
14:29:12 <ifesdjeen> ion: i mean - pattern match right where i specify arguments for the function
14:29:23 <ifesdjeen> not sure i can formulate it any better :/
14:29:27 <ion> ifesdjeen: Doesn’t my example pretty much do that?
14:29:32 <ifesdjeen> ah
14:29:33 <ifesdjeen> true
14:29:57 <razieliyo> when trying to install gloss package with cabal, it seems that I need a higher version of "base" package, does this mean that I have to update my ghc? trying to "cabal install base" doesn't do anything
14:30:07 <ifesdjeen> thank you a lot!
14:30:23 <quchen> razieliyo: bsae is pretty tighly coupled with GHC.
14:30:39 <frx> how to define an instance for a pair that requires * -> * kind? instance Foo (a,) where gives me parse error
14:30:48 <quchen> You could also install an older version of Gloss of course.
14:30:49 <razieliyo> quchen: so, should I update ghc?
14:31:08 <adimit> razieliyo: might be a good idea anyway.
14:31:15 <ion> frx: ((,) a)
14:31:23 <razieliyo> 7.4.1 this is my current
14:31:36 <quchen> razieliyo: 7.6.3 is the current version
14:31:37 <ion> frx: The section syntax isn’t available for types.
14:31:46 <frx> ion thanks
14:31:58 <razieliyo> quchen: yes, well, that's what I had, but when I try to compile some examples made for the last gloss version, it obviously crash because the need of some moduels
14:32:00 <adimit> any news on when 7.8 is coming out?
14:32:09 <Clint> "december"
14:32:15 <razieliyo> and because of the poor doc on gloss, I would like to have the examples working at least
14:32:17 <adimit> ah. christmas present.
14:33:23 <ion> razieliyo: In case your distro packages are old: this is what i always do. https://gist.github.com/ion1/2815423
14:33:27 <razieliyo> if I want to uninstall my current ghc, should I do something with cabal so that I don't have problems when I update the version?
14:33:36 <razieliyo> ion: lets see
14:33:57 <Eduard_Munteanu> razieliyo: if you update GHC you might need to rebuild some stuff.
14:34:23 <razieliyo> Eduard_Munteanu: but, is that rebuilding work done for me?
14:34:38 <razieliyo> when I try to install a new package or something, of course
14:34:45 <Eduard_Munteanu> Mm, I'm not sure.
14:34:52 <razieliyo> I don't want to mess things up
14:35:41 <quchen> razieliyo: GHC works with multiple versions installed. You'll have to rebuild everything though.
14:35:57 <quchen> So you don't have to uninstall your old version, but the new version will be *new*.
14:36:15 <adimit> razieliyo: are you trying to write a haskell program/package or are you trying to compile something for userspace? In the former case, I'd just use cabal's new sandbox feature, which makes development *much* less painful.
14:36:16 <razieliyo> fine, so I should setup cabal somehow so that it knows I'm using the new version, isn't it?
14:36:42 <razieliyo> adimit: former
14:38:10 <adimit> razieliyo: once you have the new cabal, cabal-install, and ghc: cabal sandbox init && cabal install --only-dependencies && cabal configure && cabal build. Incredibly handy. It'll compile all the package's deps into a local sandbox.
14:38:27 <adimit> You can get a ghci with `cabal repl`
14:38:44 <razieliyo> adimit: fine, I'll get that into account, currently I'll install the new ghc version from github
14:39:14 <adimit> razieliyo: why not just download a binary release from hackage? Compiling ghc can take a while…
14:39:29 <adimit> s/hackage/haskell.org/
14:40:00 <razieliyo> oh, fine, I'll do that way
14:40:48 <adimit> http://www.haskell.org/ghc/download_ghc_7_6_3#x86_64linux
14:40:55 <adimit> that's the 64 bit linux version.
14:41:03 <quchen> adimit: Not too long though, takes like 45 minutes on my 3 year old laptop
14:41:31 <adimit> quchen: nothing beats "no compile time at all."
14:41:47 <toly> Hi all -- I seem to be running into what seems to be a GHC RTS bug (a sporadic segmentation fault in copy_tag in the GC code), but want to make sure I do enough diligence before submitting.  (In particular, my simplest example depends on attoparsec, which contains unsafe code.)   Does anyone have suggestions for steps to take to verify that it really is an RTS bug?
14:43:22 <heath> which is more conducive for abstraction? APIs which expose (1) separate get/set methods or (2) a single function which either gets or sets depending on whether you pass a value
14:43:45 <tomejaguar> heath: Give us an example?
14:47:39 * hackagebot cmdargs 0.10.7 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.10.7 (NeilMitchell)
14:48:45 <lingxiao> could someone explain to me what Bohm Trees are used for?
14:48:58 <Peaker> heath: a lens that can get/set?
14:49:23 <lingxiao> I'm reading through some slides that just kind jump right into what they are, without saying why they're needed
14:50:46 <pmurias> are there any tools for debugging parsec?
14:52:20 <merijn> Peaker: Isn't that a redundant statement?
14:52:35 <razieliyo> adimit: what's the advantage of using that cabal sandbox you told me?
14:52:43 <Peaker> merijn: only for someone who already knows what a lens is :)
14:54:34 <nominolo> byorgey: thanks :)  The best part is: this function processes the input in lines
14:54:47 <heath> filterTwoListsByProp :: [a] -> [a] -> prop -> eqOp -> [a]  {-  e.g.: filterTwoListsByProp [{id: 1}, {id: 2}, {id: 3}], [{id: 3}, {id: 4}, {id: 5}], "id", "!="  -} versus intersectionWithKey :: [a] -> [a] -> prop -> [a] {- e.g.: intersectionWithKey [{id: 1}, {id: 2}, {id: 3}], [{id: 3}, {id: 4}, {id: 5}], "id" -}
14:55:37 <heath> these are json objects, not tuples
14:55:45 <nominolo> byorgey: that means the number of chunks is proportional to the number of newlines which may vary a lot based on the contents of the gzipped tarball.  Due to the quadratic runtime it usually wouldn't be an issue most of the time, but occasionally become a huge issue
14:55:55 <monochrom> pmurias: consider http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#IO as a way to print some intermediate messages for debugging
14:56:13 <nominolo> I think Greg Collins or tibbe recently had it running for ~5min
14:56:17 <heath> filterTwoListsByProp can either either be difference or intersection, depending on if you pass in the eqOp "==" or "!="
14:56:44 <lingxiao> is bohm tree some some AST representation of some lambda expression?
14:56:52 <lingxiao> am I speaking to the wind?
14:56:59 <quchen> heath: What does it do for (\_ _ -> False)?
14:57:41 <heath> it isn't handled, this is a rought translation of something I was contemplating in a js project
14:57:41 * hackagebot hoogle 4.2.25 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.25 (NeilMitchell)
14:57:46 <heath> s/rought/rough
14:58:15 <ParahSailin> im having a hard time allocating ByteArrays on the heap in Cmm
14:58:20 <nominolo> lingxiao: no clue.  Google has some links to papers
14:58:57 <lingxiao> I am, they all assume prior knowledge
14:59:26 <pmurias> and is there a less greedy version of sepBy1? so that if I have (string "x" `sepBy1` ";") and the input is x;x;y it will only match (x;x) and not fail?
14:59:44 <Peaker> pmurias: there's my TraceUtils hacky package with http://hackage.haskell.org/package/TraceUtils-0.1.0.2/docs/Debug-TraceUtils.html#v:tracePutStrLn
15:00:09 <Peaker> pmurias: hackishly allowing Debug.Trace-based putStrLn/prints in any monad -- with caveats about laziness/etc
15:01:02 <monochrom> no, pmurias, there is no greedy version of sepBy1. re-design your grammar and your whole approach
15:01:04 <Peaker> I find it very useful to stick a tracePrint in any "do" block, even if every once in a while the print disappears due to laziness :)
15:01:15 <monochrom> err, s/no greedy/no non-greedy/
15:01:57 <Peaker> pmurias: how much do you want it to match? just one?
15:02:16 <pmurias> as much as possible
15:02:19 <Peaker> pmurias: or do you want it to backtrack for each option?
15:02:49 <Peaker> pmurias: you'd need a proper parser FSA for that, not a backtracking parser like parsec, or you get terrible asymptotics
15:03:03 <Peaker> Someone ought to implement an Applicative parser that can do this properly
15:03:30 <ocharles> mm_freak: having a read of conal's push-pull paper atm. have you got any thoughts on how netwire relates to this?
15:03:31 <pmurias> what I'm trying to match is foo: 1; bar: 2;3; baz: 5 as (foo: 1) ; (bar: (2;3)); (baz: 5)
15:03:50 <ocharles> the idea of having values that aren't constantly recomputed is very desirable, and i'm not sure i can see how to do that in netwire
15:04:09 <pmurias> if there is no less greedy sepBy1 I can achieve it in different ways
15:04:15 <ocharles> (but then again, i don't have a concrete example either - switching to 'const' for example means the wire has almost no cost)
15:04:29 <monochrom> that completely doesn't look like you need non-greedy anything, ever
15:04:41 <augur> any parsec pros wanna give me advice?
15:05:13 <AshyIsMe> is there a way to load a haskell file into ghci without it needing to be a module?
15:05:21 <Clint> :l
15:05:38 <AshyIsMe> ah cheers Clint
15:05:47 <augur> http://lpaste.net/96802 this just gets stuck, it seems
15:06:25 <monochrom> ok, I see that "bar: 2;3;" is a problem. then I blame it on the grammar, it's maliciously ambiguous.
15:06:29 <augur> i assume its because of the third rule, but
15:09:06 <byorgey> nominolo: hahaha, that's hilarious
15:09:18 <monochrom> augur, perhaps you can also benefit from my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#IO as a way to print intermediate messages for debugging
15:09:27 <augur> monochrom: ?
15:10:03 <adimit> razieliyo: less dependency problems, tighter control over what exact package you depend on.
15:10:14 <monochrom> am I making myself unclear?
15:10:31 <adimit> razieliyo: basically, alleviate cabal hell.
15:10:58 <monochrom> nominolo: wait a second, are you saying it was previously doing hGetLine on a tar.gz file?
15:10:59 <pavonia> augur: the problem here is left recursion, which makes parsec loop
15:11:10 <razieliyo> adimit: fine
15:11:23 <razieliyo> currently I just wanna learn how to use gloss
15:11:34 <razieliyo> I'm wanderign through the examples
15:12:40 <adimit> razieliyo: well, good luck!
15:13:03 <razieliyo> adimit: I'll need it, thanks!
15:13:24 <augur> pavonia: i figured. is there any way to get parsec to work?
15:13:32 <razieliyo> there's a pretty nice example drawing a tree, very funny, just have to get how things stick together
15:14:18 <monochrom> ok, no one ever understands what I say. I must be in a Chinese room.
15:14:20 <adimit> there are general ways of eliminating left-recursion from grammars, but I haven't  seen a way to do it automatically for parsec applicative parsec grammars (it can't be done for monadic ones.)
15:14:36 <zol> I am sorry for asking about this again.. But foldr and foldl, they will always produce the same results, right? The documentation says: "foldr, applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left" -- that doesn't mean it consumes the list from right to left, right?
15:14:54 <hpc> > foldr (-) 0 [1..10]
15:14:56 <lambdabot>  -5
15:15:06 <hpc> > foldl (-) 0 [1..10]
15:15:08 <lambdabot>  -55
15:15:18 <Eduard_Munteanu> zol: foldl and foldr are only equivalent result-wise for associative operations
15:15:21 <merijn> zol: They only produce the same results for commutative operations
15:15:22 <hpc> > foldr (-) z [1..10] -- a bit more obviously
15:15:23 <lambdabot>  1 - (2 - (3 - (4 - (5 - (6 - (7 - (8 - (9 - (10 - z)))))))))
15:15:25 <hpc> > foldl (-) z [1..10]
15:15:27 <lambdabot>  z - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10
15:15:31 <merijn> oh, wait
15:15:35 <merijn> I guess I mean associatve
15:15:46 <frontendloader> zol: think of it like addition vs division
15:15:51 <hpc> associative, yeah
15:15:56 <monochrom> zol, the list is consumed from left to right always.
15:16:01 <frontendloader> if it doens't matter which side of the operand the terms are on
15:16:04 <frontendloader> foldr = foldl
15:16:06 <Eduard_Munteanu> > foldr (flip (-)) 0 [1..10]
15:16:08 <lambdabot>  -55
15:16:15 <Eduard_Munteanu> > foldl (flip (-)) 0 [1..10]
15:16:17 <lambdabot>  5
15:16:18 <roboguy_> > take 10 (foldr (:) [] [1..])
15:16:20 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
15:16:20 <hpc> commutative in addition lets you permute the list
15:16:26 <roboguy_> > take 10 (foldl (flip (:)) [] [1..])
15:16:30 <lambdabot>  mueval-core: Time limit exceeded
15:16:47 <roboguy_> They also have different behavior on infinite lists
15:17:02 <Eduard_Munteanu> However, mind they work differently evaluation-wise.
15:17:57 <hpc> lyah has a section on folds iirc, if you really want to get to the _|_ of it
15:18:02 <zol> Ok, but when the operations aren't associative, it will appear as foldr => goes from left -> right, and reverse for foldr?
15:18:17 <zol> hpc: orthogonal?
15:18:22 <hpc> bottom ;)
15:18:46 <zol> hpc: Thought so, wasn't sure if it was a mathematical joke or not. :)
15:18:55 <lykos_> has anyone here used gstreamer with haskell before?
15:19:29 <pavonia> augur: Not sure what's the best way here, I usually use chainl/chainr for that if there's a delimiting token in between
15:19:32 <Eduard_Munteanu> lykos_: I am working on something like that
15:19:50 <Eduard_Munteanu> lykos_: better ask a direct question
15:19:52 <augur> monochrom: i understand the meaning, but not the context, of what you said
15:20:12 <frx> zol, also, foldr can work with infinite lists, foldl can't
15:20:17 <frx> > take 5 $ foldr ((:) . (2^)) [] [1..]
15:20:19 <lambdabot>  [2,4,8,16,32]
15:20:19 <monochrom> zol: it is totally possible to operate on items in any direction while the list is always consumed left to right
15:20:22 <pavonia> augur: but ther are general rules how to remove left recursion from a grammar
15:20:22 <lykos_> Eduard_Munteanu: I've been trying to use the gstreamer haskell bindings, but it seems like major parts of it are not implemented, maybe?
15:20:46 <augur> pavonia: so the answer is basically to normalize the grammar, not poke parsec with a stick
15:20:47 <augur> :\
15:20:48 <lykos_> For example, pulsesrc
15:20:55 <lykos_> which I can use fine in python on my system
15:20:58 <lykos_> does not work here.
15:21:29 <monochrom> augur, the context is your question. you say you guess, but not sure, that the third rule causes an infinite loop. and I answer, there is a way to print messages so you can see.
15:21:30 <Eduard_Munteanu> lykos_: that is possible... that's why I'm coding some snippets in Vala and writing bindings for those.
15:21:47 <zol> monochrom: Aha, looking at the source for foldr and foldl I see that both are consumed from left -> right, but the operations are applied in different order.
15:21:48 <augur> monochrom: aha i see. that makes sense.
15:22:02 <Eduard_Munteanu> lykos_: also it doesn't support GStreamer 1.x AFAICT
15:22:19 <monochrom> but why didn't you tell me when I said "am I making myself unclear?"
15:22:20 <lykos_> My only goal right now is to get a voice recording from the microphone, and save it as a flac file
15:22:26 <lykos_> do you know how I could do that?
15:22:51 <monochrom> do you, like, value my answer? if not, tell me you don't value my answer, so I won't answer in the future.
15:23:00 <joelteon> > foldr f a [b,c,d,e]
15:23:01 <lambdabot>  Ambiguous occurrence `a'
15:23:02 <lambdabot>  It could refer to either `L.a', defined at L.hs:155:1
15:23:02 <lambdabot>                        or `Debug.SimpleReflect.Vars.a',
15:23:02 <lambdabot>                           imported from `Debug.SimpleReflect' at L.hs:110:1-26
15:23:02 <lambdabot>                           (and originally defined in `simple-reflect-0.3.1:De...
15:23:08 <Eduard_Munteanu> lykos_: for that it might work to just spawn a process running gst-launch, which you can pass a pipeline description on the command line
15:23:10 <joelteon> > foldr f Debug.SimpleReflect.Vars.a [b,c,d,e]
15:23:11 <lambdabot>  Not in scope: `Debug.SimpleReflect.Vars.a'
15:23:12 <lambdabot>  Perhaps you meant one of these:
15:23:12 <lambdabot>    `Debug.SimpleReflect.var' (imported from Debug.SimpleReflect),
15:23:12 <lambdabot>    `Debug.SimpleReflect.a' (imported from Debug.SimpleReflect),
15:23:12 <lambdabot>    `Debug.SimpleReflect.r' (imported from Debug.SimpleReflect)
15:23:18 <joelteon> ok
15:23:21 <nominolo> monochrom: it still is
15:23:22 <joelteon> > foldr f Debug.SimpleReflect.a [b,c,d,e]
15:23:23 <lambdabot>  f b (f c (f d (f e a)))
15:23:58 <lykos_> Eduard_Menteanu: Ah, good point. I'm a newbie in gstreamer though, how would I go about doing that?
15:23:58 <nominolo> monochrom: I have to take a closer look at the code to do that properly
15:24:20 <AshyIsMe> so if i have an either value, how do i get at it's right value?
15:24:42 <Eduard_Munteanu> lykos_: see the manpage for gst-launch. Do you need to stream that data into your Haskell application, or would writing to a file suffice?
15:24:48 <monochrom> I guess traditionally HTTP assumes that the data is just HTML
15:25:16 <lykos_> writing a file should suffice.
15:25:34 <AshyIsMe> do you use pattern matching to see if it's a Right or Left?
15:25:35 <haasn> getTomorrow'sTime = threadDelay (24*3600*1000) >> getCurrentTime
15:25:43 <nominolo> monochrom: yes.  The code is quite old, too
15:25:45 <geekosaur> heh
15:25:54 <jxv> Is there an extension that does this: Say type-class Foo exists, and Bar is a type-class which derives Foo. Now Quux is an instance of Bar which implements Foo's and Bar's functions under Bar.
15:26:02 <geekosaur> .oO ( followed by sleepsort? )
15:26:44 <Eduard_Munteanu> lykos_: should be easy to do that with a textual pipeline
15:27:01 <lykos_> I want to make it so that a haskell function will determine when the recording starts and stops
15:27:02 <haasn> oh, microseconds, not milliseconds
15:27:27 <johnw> who needs microseconds?
15:27:34 <johnw> i've got some around here somewhere
15:27:41 <lykos_> are you sure there's no way to just do it within haskell? I'd like to get the gstreamer librarary working if possible
15:27:53 <monochrom> jxv: no
15:28:06 <jxv> monochrom, thanks.
15:29:04 <Eduard_Munteanu> lykos_: that might work
15:29:28 <haasn> AshyIsMe: case x of Left l -> ... ; Right r -> ...
15:29:43 <Eduard_Munteanu> lykos_: might be possible even if some plugin you need isn't part of the bindings, as long as you can use ElementFactory to create it.
15:30:24 <lykos_> Can you give me some example code to work with?
15:30:59 <lykos_> I'm just trying for now to get a simple example working in gstreamer for haskell, and then work from there
15:31:02 <AshyIsMe> haasn: ah cheers
15:31:50 <Eduard_Munteanu> lykos_: I think you should look at C / Vala examples first: http://valadoc.org/#!api=gstreamer-1.0/Gst.ElementFactory
15:32:05 <Eduard_Munteanu> Er, that's for 1.0 but I guess it doesn't change much.
15:32:24 <lykos_> That's what I've been doing, but the things it recomends aren't working
15:32:30 <lykos_> for instance:
15:32:46 <lykos_> gst-launch autoaudiosrc ! audioconvert ! faac ! mp4mux ! filesink location=aac_audio.mp4
15:33:02 <lykos_> I saw that as a basic example
15:33:08 <lykos_> but, it doesn't even remotely work.
15:33:12 <lykos_> Any ideas?
15:34:04 <Eduard_Munteanu> lykos_: what do you mean "it doesn't work"?
15:35:47 <lykos_> I keep getting an error about NULL pointers
15:36:10 <lykos_> Except when I used a few strings, like "video-source"
15:36:19 <johnw> AshyIsMe: also, the function "either"
15:36:26 <lykos_> so "video-source" seemed to work, whereas "autoaudiosrc" did not
15:37:57 <Eduard_Munteanu> lykos_: try pulsesrc directly
15:38:23 <aalevy> in the network package, why does `listenOn` return a Socket, while `connectTo` returns a Handle?
15:38:55 <johnw> doesn't listen afterward need an accept call?
15:38:58 <johnw> and the accept returns a Handle?
15:39:13 <aalevy> ah... yes that is correct
15:39:20 <lykos_> How?
15:39:23 <johnw> the reason being that you can establish many sessions over the lifetime of one listening session
15:39:32 <razieliyo> what kind of magic is done in this gloss example? http://ideone.com/af3Wyw AFAIK, picture takes 2 args and the last is the time, but it's not expressed when specifying (picture 6), so I can only think that animate (Float -> Picture) arg is somehow interacting with that unbounded var (time on picture)
15:39:52 <mkay_> hi there
15:39:54 <Eduard_Munteanu> Also a fd implies you can send / receive data.
15:40:02 <Eduard_Munteanu> Which you can't before you accept.
15:40:08 <johnw> right, after you call listen, you aren't actually talking to anyone yet
15:40:09 <Eduard_Munteanu> mkay_: hi
15:40:13 <johnw> accept will block until the remote side connects
15:40:25 <mkay_> I've got another weird problem...
15:40:28 <razieliyo> mkay_: hi
15:40:57 <mkay_> I have a set of objects that I index into using a Map
15:41:18 <mkay_> these objects contain a mutable array each
15:41:20 <aalevy> Interestingly though, `accept` in Network.Socket returns a Socket
15:42:19 <monochrom> Network.Socket exposes the low-level unix interface
15:42:35 <mkay_> but the changes I make to those arrays somehow don't persist
15:42:41 <monochrom> well, maybe not expose, but models around
15:42:51 <mkay_> as in, the next time I get that same object from the Map, the array is empty again
15:43:21 <AfC> What's a good example of a library with an FFI binding that I could use for reference?
15:43:57 <monochrom> mkay_, you should show actual code. see the topic for a paste bin
15:45:15 <mkay_> monochrom: the code isn't exactly user friendly right now :D
15:47:28 <mkay_> I think it basically boils down to this: can a STArray be understood as a kind of "pointer" to an array instance, meaning if you change the object somewhere, all previously stored references to it also change, or do I need to encapsulate it somehow for that to happen?
15:47:46 <scott_> Is there a nicer way to write fmap for State s? I have:
15:47:47 <scott_> fmap f (State g) = State $ \s -> let (x, s') = g s in (f x, s')
15:47:52 <Yep> hi, I'm looking for a version of prelude "lookup" that returns a list of results (i.e. Maybe [b])
15:48:10 <quchen> Yep: filter?
15:49:10 <monochrom> I don't understand your question. I don't understand "references change". how about this: I create the array and give it to you, then I change a cell in the array, then you can see the change.
15:49:38 <Yep> quchen: thanks, filter will do the trick
15:50:42 <mkay_> monochrom: yep, that's what I would expect
15:51:58 <mkay_> I create the array, store it in an object in a map, then I change something in the array and expect to see the same changes the next time I retrieve the object from the map
15:52:27 <monochrom> yes
15:52:55 <mkay_> but that's not what happens
15:52:55 <mkay_> the next time I retrieve the object, the array is empty again
15:53:00 <mkay_> and I have absolutely no idea why
15:53:26 <monochrom> do you want to know how a scientist would approach this?
15:53:52 <mkay_> I'm curious :P
15:54:10 <adimit> monochrom: he would cage a couple of monkeys and let them hack on a keyboard until the unit tests pass?
15:54:34 <quchen> adimit: The technical term is "grad student"
15:54:40 <monochrom> he/she would put aside your current code, then write new, simple code for exactly "I create the array, store it in an object in a map, then I change something in the array and expect to see the same changes the next time I retrieve the object from the map", test it.
15:55:16 <monochrom> if the test says "that's right", now you know your current code has a different problem and a different cause.
15:55:26 <adimit> quchen: details.
15:57:28 <monochrom> oh, and if the test says "no", now you have simple code ready to show other people
15:58:10 <monochrom> simple, yet self-contained, and reproducible by other people, so they can analyze and say what is the cause
15:59:48 <lykos_> I got it working :)
16:00:12 <lykos_> I found some hidden Japanese source-code and reverse engineered it.
16:04:10 <NoahTheDuke> i'm having trouble updating my cabal installation
16:04:25 <NoahTheDuke> i run win 7 64 bit, with powershell, and i keep getting this error: http://lpaste.net/96810
16:05:27 <NoahTheDuke> I've googled around a bit, but can't find anything related to setup.exe not existing, or what to do to install it manually
16:06:53 <slack1256> I usually tend to put a lot of monads transformers, make a newtype and then pass that monolitic monad around (a la XMonad but bigger)
16:07:00 <slack1256> what is the alternative to that design?
16:08:11 <adimit> slack1256: ezyang mentioned some talk at ICFP on alternatives to that, but nothing concrete. AFAIK it's a research topic. See http://blog.ezyang.com/2013/09/if-youre-using-lift-youre-doing-it-wrong-probably/
16:09:31 <mkay_> monochrom: well, I was hoping there was some scientist here that already ran those experiments ^^
16:10:14 <Iceland_jack> Writing Haskell code is one big research topic :)
16:12:02 <jmcarthur_mobile> slack1256: I tend to just use whatever functionality I need exactly where I need it and plumb accordingly
16:12:27 <jmcarthur_mobile> Sometimes there's a transformer stack involved, sometimes there's not
16:12:34 <jmcarthur_mobile> Usually not
16:13:11 <jmcarthur_mobile> I don't know about intentionally avoiding transformer stacks though
16:16:49 <jmcarthur_mobile> People say in advance transformers are not composable, but actually they are.
16:17:14 <jmcarthur_mobile> If you put two monad transformers together you get a monad transformer
16:17:25 <jmcarthur_mobile> They even form a category
16:17:43 <jmcarthur_mobile> Well, a Monoid I guess
16:17:52 <jmcarthur_mobile> Err, lowercase monoid
16:18:47 <quchen> jmcarthur_mobile: I think "Monads are not composable" is what people say.
16:19:07 <quchen> Transformers solve that problem on a per-case basis.
16:19:08 <Peaker> Also, transformers can represent stack that effect systems can't
16:19:25 <Peaker> however, code using transformers has a problem with variance
16:19:33 <jmcarthur_mobile> Monads are indeed not composable in general
16:19:36 <Peaker> e.g: "bracket" for IO is unusable with transformed-IO
16:19:57 <jmcarthur_mobile> Yeah, that's an unfortunate problem. Never thought to associate it with variance though
16:20:32 <Peaker> lift can only be used on the covariant sides, there's no "unlift"
16:21:16 <jmcarthur_mobile> Yeah
16:27:53 * hackagebot hPushover 0.1 - Pushover.net API functions  http://hackage.haskell.org/package/hPushover-0.1 (WJWH)
16:28:26 <pavonia> What could cause my program to hang if I download a file via calling curl by runInteractiveCommand? It works fine if I run it from GHCi but the compiled version hangs.
16:31:27 <pavonia> it seems some lines are even downloaded before it hangs
16:46:34 <pavonia> Okay, it works if I compile with the -threaded option
16:49:57 <ryantrinkle> is there any news on when 7.8 might come out?
16:51:58 <quchen> ryantrinkle: "December"
16:52:19 <srhb> Christmas Eve, just to alienate Haskellers further from anyone in real life.
16:52:22 <srhb> Clearly.
16:52:31 <ryantrinkle> srhb: lol
16:52:41 <quchen> Thank god for atheism
16:54:48 <srhb> try $ option 0 $ try (choice [oneC, twoToNine]) <* string "og" -- I am now so alienated from real life that I don't understand why my own code works. :<
16:55:03 <monochrom> wow some many $s, like bitcoin
16:55:12 <srhb> Such dollars.
16:55:23 <quchen> Very application.
16:55:55 <monochrom> perhaps read "try (choice [oneC, twoToNine]) <* string "og"" first?
16:55:58 <srhb> I was challenged to write a "nice" parser for Danish numbers -- I am now tempted to hardcode everything from 1-100
16:56:11 <quchen> Slightly more on-topic: are there differences between mtl and monads-tf apart from the obvious? Better performance, for example?
16:56:23 <srhb> monochrom: That bit is.. Understandable
16:56:31 <shachaf> One difference is that you should use mtl and not monads-tf.
16:56:48 <srhb> It's the double try that kills me. Won't option 0 always succeed?
16:56:57 <monochrom> then, I suppose the result is a Maybe? therefore there is an "option 0" outer
16:57:15 <quchen> Are there differences between mtl and monads-tf apart from the obvious? Could you give a constructive answer if you do?
16:59:02 <monochrom> there is not just succeed vs unsucceed, but also consumes input or unconsumes input
17:00:37 <ij> :t getWord16
17:00:38 <lambdabot> Not in scope: `getWord16'
17:01:00 <ij> ByteString package had something like this, but I can't hoogle it. Where could it be?
17:02:19 <srhb> monochrom: Ahhh, it clicked. Thank you.
17:03:18 <shachaf> @google getWord16
17:03:19 <lambdabot> http://www.haskell.org/hoogle/?hoogle=getWord16+%2Bbinary+%2Bcereal
17:03:19 <lambdabot> Title: getWord16 +binary +cereal - Hoogle
17:05:12 <ij> shachaf, hmm, what did I do wrong?
17:06:15 <marx2> ...
17:10:50 <k00mi> ij: hoogle only searches through a small number of packages, you can tell it to search a specific package with +package
17:11:37 <ij> May I make it search through all packages?
17:11:57 <k00mi> ij: hoogle can't do that (I think), but hayoo can
17:12:01 <k00mi> http://holumbus.fh-wedel.de/hayoo/hayoo.html
17:18:48 <enthropy> ij: there's one with a more complete database in https://www.fpcomplete.com/hoogle
17:18:56 <chrisdone> i was having trouble sleeping so i hacked on ircbrowse a bit, made it more navigable and split up the stats per chan, check this: http://ircbrowse.net/haskell
17:18:56 <chrisdone> what happened to lisp's userbase? =( http://ircbrowse.net/lisp
17:19:01 <enthropy> you can also run your own locally
17:19:34 <srhb> Crud, I think parsing the Danish numbers might be better suited for a DFA..
17:20:00 <slack1256> Is my idea, or in the ListT monad you can only maintain or decrease de list but no increase it (in number of elements)?
17:21:03 <slack1256> on the [a] monad you can do both, you have all Data.List at your serve and there is a concat in the definition
17:21:06 <enthropy> @unmtl ListT Maybe a
17:21:06 <lambdabot> Maybe ([] a)
17:21:15 <ij> enthropy, why isn't it merged with haskell.org's one?
17:21:34 <chrisdone> fpcomplete's is using stackage
17:21:44 <chrisdone> i think haskell.org is just base or something
17:21:50 <chrisdone> and some standard packages
17:22:36 <enthropy> > runListT $ do x <- ListT (Just [1,2,3]); y <- ListT (Just [1,2,3]); return (x+y)
17:22:37 <lambdabot>  Not in scope: `runListT'Not in scope: data constructor `ListT'Not in scope: ...
17:23:00 <ij> Can I find out what the infixr/ls of functions are without compiling?
17:23:39 <enthropy> > let runListT = Control.Monad.List.runListT; listT = Control.Monad.List.ListT in runListT $ do x <- listT (Just [1,2,3]); y <- listT (Just [1,2,3]); return (x+y)
17:23:40 <lambdabot>  Not in scope: `Control.Monad.List.runListT'
17:23:41 <lambdabot>  Perhaps you meant one of these:
17:23:41 <lambdabot>    `Control.Monad.Cont.runContT' (imported from Control.Monad.Cont),
17:23:41 <lambdabot>    `Control.Monad.Cont.runCont' (imported from Control.Monad.Cont)Not in scop...
17:23:41 <lambdabot>  Perhaps you meant one of these:
17:23:53 <chrisdone> ij: not without some difficulty
17:24:40 <enthropy> oh well, slack1256 you can do something like the above to get a  Maybe [Int], which has 9 numbers in it
17:24:42 <slack1256> I will run that on my ghci
17:28:17 * hackagebot hPushover 0.1 - Pushover.net API functions  http://hackage.haskell.org/package/hPushover-0.1 (WJWH)
17:28:17 * hackagebot nbt 0.5 - A parser/serializer for Minecraft's Named Binary Tag (NBT)  data format.  http://hackage.haskell.org/package/nbt-0.5 (AdamFoltzer)
17:28:19 <slack1256> enthropy: neat, that works
17:28:27 <slack1256> I don't why I wasn't seeing now.
17:30:23 <slack1256> thanks
17:35:07 <ij> Hmm, but how do I use getWord16le(:: Get Word16)? It's got no arguments.
17:35:33 <monochrom> use it in the Get monad
17:35:33 <chrisdone> runGet, probably
17:35:58 <ij> How does it receive data?
17:36:08 <ij> oh, it is data itself?
17:36:24 <monochrom> it picks out data from whatever you feed to runGet or something
17:38:03 <shachaf> How does get :: State s s receive data?
17:40:24 <adimit> dear god, I finally figured out how applicative readers work. That took me WAY too long. I'll just say it's late…
17:43:14 * hackagebot elm-repl 0.1 - a REPL for Elm  http://hackage.haskell.org/package/elm-repl-0.1 (EvanCzaplicki)
17:43:16 * hackagebot nbt 0.5.1 - A parser/serializer for Minecraft's Named Binary Tag (NBT)  data format.  http://hackage.haskell.org/package/nbt-0.5.1 (AdamFoltzer)
18:17:11 <evincar> Perhaps a silly question. I'm writing a transformer, and I want to be able to run IO actions within the transformed monad.
18:17:17 <evincar> So rather like the dual of MonadIO.
18:17:21 <evincar> How do?
18:18:46 <evincar> For example, 'MyT' should be able to use 'try' and so on inside MyT m where m = ReaderT Crap IO without knowing anything about m.
18:19:13 <evincar> I don't know if this is possible or if I'm just being thick.
18:21:15 <spaceships> make it an instance of MonadIO..or provide an equivalent liftIO function for your transformer
18:24:03 <evincar> spaceships: Mm, the real problem for me is that 'catch' takes an 'IO a' and not a 'MonadIO m => m a'.
18:24:23 <evincar> I'll try some other approach I guess...
18:27:49 <enthropy> evincar: I think this is the most common approach to the catch problem: http://hackage.haskell.org/package/monad-control
18:33:12 <evincar> enthropy: Thanks, I'll keep it in mind for the future, but I don't think it's ideal for the library I'm working on.
18:59:09 <dainanaki> I'm experimenting with using a Ragel parser with GHC primops along the lines of this blog post: http://breaks.for.alienz.org/blog/2012/02/09/parsing-market-data-feeds-with-ragel/
18:59:32 <dainanaki> Does anyone know how to supply a callback to a foreign prim import?
19:12:40 <ParahSailin> is OverloadedLists a thing?
19:13:09 <geekosaur> in 7.8 I think?
19:13:12 <TallerGhostWalt> I am seeing more and more llvm backend use from ppl, what are the reasons to do that? can it be faster than gcc?
19:14:16 <geekosaur> ghc doesn't use gcc any more, hasn't for a while
19:14:33 <triliyn> It still CAN I think, it's just not the default
19:14:40 <geekosaur> llvm backend produces better numeric code currently, and is the only working backend for ARM last I checked (possibly also for some other platforms)
19:14:43 <triliyn> (It does its own native code generation now)
19:15:13 <TallerGhostWalt> oh okay
19:15:46 <TallerGhostWalt> I got confused probably because I was building it for ARM and it required me picking
19:15:59 <TallerGhostWalt> at one point
19:16:47 <TallerGhostWalt> will 7.8 compile natively to ARM or through llvm?
19:17:17 <swineflu> I've been trying to google this but what is import Prelude hiding (lookup)
19:18:03 <byorgey> swineflu: that means to import the usual Prelude module, except not to import the 'lookup' function
19:18:04 <geekosaur> `lookup` is a function in Prelude. normally Prelude is imported by default, but if the very first import in your file is for Prelude then you can specify functions to hide, or import it qualified, etc.
19:18:33 <geekosaur> you might want to hide lookup because you intend to use the one from Data.Map a lot, for example
19:19:03 <swineflu> I see
19:19:04 <geekosaur> otherwise you'd have to import and use the Data.Map one qualified
19:19:20 <geekosaur> (the one in Prelude operates on lists)
19:20:12 <swineflu> Thanks
19:20:17 <triliyn> It would be nice if GHC could resolve ambiguous names by type
19:21:15 <AshyIsMe> swineflu: there's some good info on modules here: http://learnyouahaskell.com/modules#loading-modules
19:22:07 <swineflu> Once I saved the file and the syntex highlighting kicked in it actually seemed pretty obvious lol
19:22:26 <adimit> is there a "join" for applicative (I think there can't be, right?)
19:23:58 <jmcarthur> adimit: join is the difference between applicative and monad
19:24:11 <jmcarthur> adimit: or one presentation of the difference at least
19:24:24 <jmcarthur> adimit: what i mean is, if you add join to applicative, you have all the same power as monad
19:25:25 <adimit> jmcarthur: yes, I thought as much. Now I'm in a pickle! My nice applicative code starts getting very complicated.
19:26:05 <adimit> in particular, I have to write myself stuff like filterA. And using it on values that are themselves within the Applicative seems tricky.
19:26:36 <TallerGhostWalt> the foldl' bug with Data.Vector and a list output type, seems pretty severe but it hardly mentioned.  Is there some better way of doing accumulation with a vector and a fold?
19:26:54 <TallerGhostWalt> I don't see where I can "push" onto a Vector?
19:27:10 <copumpkin> vector doesn't support efficient append
19:27:18 <copumpkin> so the answer is "don't use it that way"
19:28:18 <TallerGhostWalt> gotcha
19:28:25 <TallerGhostWalt> sigh... that is always the answer!
19:28:28 <adimit> I think I'm just so used to "thinking in monads" that rethinking my workflow to applicatives is really proving difficult.
19:29:02 <Hodapp> I've still yet to have a good sense of where one should use a monad...
19:29:03 <copumpkin> TallerGhostWalt: that's not to say you can't do the overlal operation efficiently on vectors, but don't do it in that particular way
19:29:14 <Hodapp> I'll start trying to grok functors, applicatives, and arrows after that perhaps.
19:31:59 <TallerGhostWalt> I think I ended up using Map and List
19:32:23 <TallerGhostWalt> it was just weird to have my compiler freeze
19:32:25 <augur> observation:   r { x :: a, y :: b }   <:   r { x :: a }      but      R { x = a0 }   `sub`   R { x = a0, y = b0 }
19:32:41 <TallerGhostWalt> I wish there had been a note about it in the Docs
19:32:48 <TallerGhostWalt> perhaps there was and I missed it
19:33:07 <adimit> TallerGhostWalt: appending to lists is done with Difference Lists (or just plain old "id . ('a' :) . ('b' :) . [])
19:34:12 <augur> has anyone seen this before?
19:34:52 <TallerGhostWalt> adimit: you mean inside of a vector fold?
19:35:29 <adimit> well, any fold.
19:35:31 <jrw> augur: what's sub?
19:35:31 <byorgey> augur: I don't understand what you mean
19:35:54 <augur> jrw, byorgey: `sub` ordering by definedness
19:36:21 <augur> i suppose i shouldnt really be using record subtypes, really
19:36:41 <byorgey> augur: OK. What do you mean "seen this before"?
19:36:45 <augur> what i should be using is intersection types    X&Y <: X   but   R x undefined `sub` R x y
19:36:59 <augur> byorgey: just, is this at all familiar
19:37:25 <jrw> augur: this is what always trips people up about subtyping: "smaller" in subtyping means "more constrained" means "has more fields"
19:37:39 <augur> jrw: right
19:37:41 <jrw> and thus "looks bigger on paper"
19:37:54 <augur> jrw: but it also means "more general" in that it can be used in more places
19:37:54 <byorgey> augur: sure.
19:38:09 <augur> if you have   m :: X&Y then you can use it in more places than you can use m' :: X
19:38:18 <byorgey> right.
19:38:22 <augur> on the other hand
19:38:41 <augur> if you're using some sort of unification widget on _structure_, then R x undefined is "more general" because it can unify with more things that R x y
19:39:07 <augur> R x undefined  `unify`  R x 5   succeeds happily
19:39:26 <jrw> sure
19:39:40 <byorgey> augur: right, this corresponds to whether the records are being used co- or contravariantly
19:39:47 <augur> so theres this kind of funky duality of "general" -- general types are more constraint, general values are less constraint
19:40:44 <augur> byorgey: lemme give a more concrete example, using an actual problem domain and two ideas that have been used in the literature
19:41:02 <byorgey> no thanks, I should be working on my cover letter
19:41:06 <augur> :p
19:41:16 <augur> thats ok, you dont have to respond, its just to whoever is listening
19:41:23 <byorgey> in any case, this phenomenon is very familiar to me
19:41:24 <jrw> augur: I feel like the first part is more an issue with precision. if you give an imprecise type to an expression, that's "less general".
19:42:19 <augur> so verbs require their arguments to have specific cases: subjects must be nominative, objects, accusative. names can be either nominative or accusative (john saw frank, frank saw john) but pronouns are one or the other (he saw frank, but not frank saw he)
19:42:30 <kvda> If a function returns the type of "SqlPersistT m (Maybe UserInfo)", how can i get to that UserInfo data type?
19:42:38 <augur> so in some sense, john :: Nom & Acc   but he :: Nom
19:42:53 <augur> so john has a more general type than he
19:42:54 <jmcarthur> adimit: it could be that your algorithm is not expressible with only the applicative combinators
19:43:04 <augur> thats one approach: intersection types
19:43:18 <kvda> it's always a little too difficult to inspect data in haskell compared to other languages
19:43:29 <augur> another approach people have used is to say  john = R { case = undefined }   he = R { case = Nom }
19:44:23 <augur> and then to be a subject, the word john has to unify with R { case = Nom }
19:44:32 <augur> and to be an object it has to unify with R { case = Acc }
19:44:42 <augur> it can do either, but obviously he can only be a subject
19:44:54 <adimit> jmcarthur: I'm thinking that right now, but that would be sad. I have l :: f [a], and a predicate p :: (a -> f Bool). Now I want to filter l by p, so I want filterA' :: (a -> f Bool) -> f [a] -> f [a]. But that doesn't seem to work, I'd need join. Or sleep. one of the two anyways.
19:45:30 <jmcarthur> adimit: yeah i think you need join/bind for that
19:45:52 <augur> so there's this kind of funny dual approach -- at the level of types, more complex types are more general, and can be further specified, whereas at the level of values, more complex values are less general, and can't be specified as much
19:47:06 <jrw> augur: yeah, that all makes sense. I'm not sure it's funny, though. and I'm hesitant to use "type" and "value" the way you do. it seems too specific to unification patterns and intersection types
19:47:09 <adimit> and I was wondering why filterA wasn't in Control.Applicative, and we only have filterM. Though filterA would be (a -> f Bool) -> [a] -> f [a]. But that's less useful.
19:47:25 <augur> jrw: fair enough
19:48:55 <jrw> I guess I would say it thus: patterns that specify less are clearly and intuitively match more values, but they guarantee less about what was matched. intersection types with more constraints let you do more things to them, but they are harder to produce.
19:49:29 <jrw> modulo typos.
19:56:15 <iFire> I'm having problems with linking on windows.
19:56:18 <iFire> http://pastebin.com/8qYk2mBX
19:56:22 <iFire> https://github.com/fire/sdlexample/tree/master
19:56:23 <mauke> The paste 8qYk2mBX has been copied to http://lpaste.net/96811
19:57:17 <lispy> I have a notation question
19:57:39 <lispy> if someone writes, e[x/y], for a substitution, does that mean replace y with x?
19:58:17 <lispy> So, would you write (y + 1)[2/y] and rewrite that to 2 + 1 ?
19:58:28 <lispy> I always forget
20:01:33 <jmcarthur> adimit: i think filterA is doable
20:02:10 <jmcarthur> adimit: the problem is the extra f wrapped around your second argument
20:02:28 <adimit> jmcarthur: oh, I have filterA. I just have the variant that filters a list [a], not the list f [a]. I think the latter can't be done in general (the result would have to be f [ f a ] or so.)
20:02:50 <jmcarthur> adimit: right. you need monad for that, since you end up with nested fs
20:03:13 <adimit> jmcarthur: yes. I just had a shower and found out that I could demote the predicate to a -> Bool, safely. If I do that, I can use plain old filter.
20:03:17 <jrw> lispy: yes. mnemonic: the '/' falls over and crushes the y, leaving only x.
20:03:18 <adimit> and fmap that.
20:03:30 <AshyIsMe> hmm, evilmode is not very close to vim
20:03:39 <AshyIsMe> C-u doesnt even do pgup
20:03:44 <adimit> jmcarthur: thanks for helping me keep sane.
20:04:45 <adimit> ah, no. It won't help me. I have another f I forgot about… so it goes.
20:05:08 <lispy> jrw: ah. I was thinking it was that you factor out the y and multiply by x
20:05:20 <jrw> lispy: I like that one too :)
20:05:39 <lispy> jrw: I still much prefer e[y := x]
20:05:49 <lispy> or even using the \mapsto arrow in place of :=
20:06:02 <jrw> lispy: yeah, nobody ever said it was *good* notation. but it is used frequently.
20:06:17 <lispy> Yup :( I just ran into it :)
20:15:07 <Yep> hi, I seem to be misunderstanding nested do blocks and have stayed away but I feel I should use thim in this case. Any suggestions?  http://lpaste.net/96812
20:18:43 <jrw> Yep: you probably need an extra set of parens around the argument to assert in the second function?
20:20:42 <jrw> Yep: also the nested do is equivalent to "fmap (run . runResourceT . responseBody) res" (I think)
20:25:02 <Yep> jrw: Opps on the parens, nowonder the errors we're making sense....
20:25:35 <Yep> jrw:  I get the following error, so I seem to be off...   Expected type: Maybe (Maybe Response)       Actual type: ResourceT IO (Maybe Response)     In a stmt of a 'do' block: resp <- res
20:27:05 <jrw> Yep: can you post new code with parnes fixed?
20:29:38 <roboguy_>  Yep: I think the first statement of the nested do uses the ResourceT monad but you try to compare that to a "Just expected" (a Maybe value)
20:30:04 <roboguy_> since res :: ResourceT IO (Maybe Response)
20:32:48 <TallerGhostWalt> AshyIsMe: Have you tried Viper?
20:34:05 <roboguy_> Yep: also, there should probably be parens around the argument given to assert. I think assert takes two arguments as well
20:34:55 <Yep> roboguy_: jrw: Thanks guy, your right roboguy about the ResourceT IO (Maybe Response) when I want Maybe Response... but that was giving me very weird errors before
20:35:02 <TallerGhostWalt> Is there a way to derive a Text Equivalent of Read ?
20:35:17 <Yep> after fixing a couple of parens i'm much closer and should be able to find my way
20:36:18 <Yep> i always get nested do's wrong and give up after my first attempt, lol... but makes sense as long as u don't make silly errors
20:36:36 <AshyIsMe> TallerGhostWalt: nope
20:37:46 <TallerGhostWalt> AshyIsMe: I guess it is vi key bindings how diff is that (I have never used VI/VIM except in a panic trying to get out)
20:38:30 <AshyIsMe> oh you are a different walt, heh
20:38:52 <AshyIsMe> yeah i would want vim features too
20:39:36 <Elision_> is it more common to interleave multiple vertex attributes or block them out?
20:39:55 <Elision_> because I've seen people do both
20:40:32 <TallerGhostWalt> AshyIsMe: There is also God mode pretty darn cool
20:40:37 <Elision_> wait
20:40:43 <Elision_> this isn't ##OpenGL at all
20:43:23 <AshyIsMe> TallerGhostWalt: yeah i dont know emacs well enough to use that though. i'll have to do some deeper investigations for vim haskell mode improvements later in the week
20:43:28 <Hodapp> Elision_: this is a dimension not of vertices and facets, but of type systems and monads... a wondrous land whose boundaries are that of some mathematical concept that I really don't know much about. It is an area we'll call... #haskell.
20:48:15 <iFire> anyone on windows?
20:51:12 <vamega2> Hi can someone explain to me why this doesn't work?
20:51:20 <vamega2> (2 :: Double) - (2 :: Int)
20:51:31 <scott_> :t (-)
20:51:32 <lambdabot> Num a => a -> a -> a
20:51:39 <scott_> The arguments to (-) have to be the same type
20:51:45 <vamega2> since both Double and Int are of Type Num
20:51:49 <vamega2> shouldn't this work?
20:52:02 <vamega2> rather have the typeclass Num.
20:52:06 <scott_> Nope, Double and Int are two different types. Num is a typeclass they both have instances for
20:52:17 <vamega2> Oh alright
20:52:18 <vamega2> Thanks
20:52:45 <vamega2> How do I convert an Int to a Double
20:53:03 <scott_> :t fromIntegral
20:53:04 <lambdabot> (Integral a, Num b) => a -> b
20:53:19 <vamega2> Thanks
20:53:26 <vamega2> I had search Hayoo for Int -> Double
20:53:31 <vamega2> But that didn't quite work
20:53:53 <scott_> Yeah, sometimes what you want is defined too generally for a search like that
20:56:05 <bobajett> if I define the function "+" for my data type and within the rest of my file I also have to use the + for Ints, ghc complains about ambiguity. Does this mean that I have to preface all the "+"s in my file with (Prelude.+) ?
20:56:47 <jerry669> http://hotgirlsinyogapantss.blogspot.com/2013/12/pulling-them-up.html
20:56:59 <scott_> What is your data type? You might want to just use a different operator name, or you could make a Num instance for your type if it makes sense
20:57:39 <bobajett> scott_: to learn about data types, Im playing with creating a Vector data type. So it would be nice to do: v1 + v2
20:58:45 <scott_> The easiest solution would be to use a different operator name, e.g. v1 +. v2 or whatever you want
21:01:36 <bobajett> scott_: got it, will do. But shouldn't ghc be able to figure this out based on the data types being given to the operator? In other words if it sees a Vector + Vector it should know to use Vector.+ and if it sees zipWith (+) [list of Ints] [another list of Ints] -- be able to use the Prelude.+ ?
21:02:09 <scott_> bobajett: It's probably possible, but GHC doesn't do that
21:02:50 <scott_> Haskell doesn't have any overloading of names except with type classes
21:03:05 <bobajett> scott_: ok cool. thanks!
21:11:40 <nstdloop> Googling has yielded no helpful information on the release date of ghc 7.8
21:11:54 <nstdloop> I found one post from a few months ago saying late Nov. 2013, but that looks to be incorrect
21:15:43 <Cale> https://ghc.haskell.org/trac/ghc/query?status=!closed&milestone=7.8.1&order=priority
21:22:13 <iFire> I'm having problems linking a library on windows. Can anyone help?
21:23:13 <Cale> iFire: Sometime might :)
21:23:24 <Cale> What error are you getting?
21:23:33 <iFire> http://pastebin.com/8qYk2mBX
21:23:33 <iFire> https://github.com/fire/sdlexample/tree/master
21:23:33 <mauke> The paste 8qYk2mBX has been copied to http://lpaste.net/96811
21:25:53 <iFire> Cale: hm?
21:26:03 <Cale> I'm not a windows user myself, so I don't know what special steps you need to take to install it there.
21:26:09 <Cale> SDL, that is
21:26:18 <iFire> well sdl2 installs
21:26:24 <iFire> it compiles and stuff
21:26:24 <ThatOtherPerson> Does Haskell have SDL2 support?
21:26:40 <iFire> using https://github.com/Lemmih/hsSDL2
21:26:49 <ThatOtherPerson> ah
21:26:56 <iFire> anyways the problem is it works on ubuntu 13.10
21:27:08 <iFire> but not windows
21:27:49 <Cale> That repository must be new. I don't think it corresponds to the SDL package on Hackage.
21:28:05 <iFire> SDL2
21:28:13 <Cale> yeah
21:28:33 <Cale> (and the one on Hackage is for SDL 1.x)
21:29:49 <mzero> Can anyone thing of an Applicative that isn't a Monad... ?   (,) a   and ZipList are about the only two I can find
21:31:27 <Cale> mzero: There are more Applicatives whose computational behaviour is different from what any Monad instance would allow in cases where there's also a Monad instance.
21:31:54 <mzero> But in practice we don't have any in the library, except say, ZipList, right?
21:31:58 <Cale> mzero: For instance, where you do something to execute all the parts of the Applicative computation in parallel
21:32:37 <Cale> Well, in the library, you can sort of tell what's there...
21:32:48 <Cale> WrappedArrow is apparently an example
21:32:56 <mzero> hmmm.. okay
21:33:02 <quchen> async defines the Concurrently Applicative, to name a widely available type
21:33:52 <mzero> Just noticed, BTW, that    Monoid a => (,) a   is Applicative, and it is sort of a lovely poor-man's logging compuation
21:34:05 <Cale> Well, it's also a Monad
21:34:16 <Cale> and usually referred to as the writer monad, so yeah :)
21:34:17 <mzero> see, there ya go
21:34:29 <mzero> Well, right, but I mean without the tagging
21:34:49 <Cale> Yeah, it's the unwrapped version
21:34:52 <mzero> like I could just causally tuple up some stuff, and Applicative a few functions and pattern match out my bits
21:35:03 <mzero> without needing to wrap/unwrap etc...
21:35:15 <Cale> I'm not sure why there isn't an instance of Monad for that
21:35:33 <quchen> Because the mailing list deadlocks when you propose it.
21:35:37 <Cale> hah
21:35:47 <bos> @pl f (g x) x
21:35:47 <lambdabot> f (g x) x
21:35:54 <bos> @pl \x -> f (g x) x
21:35:54 <lambdabot> f =<< g
21:36:03 <quchen> "It's stupid nobody should use (,) a over Writer" vs "but it's a valid instance for a basic type"
21:36:15 <bos> ah, Reader monad
21:37:52 <Cale> Lemmih_: Are you around? iFire is having trouble with your binding to SDL2
21:38:31 <shachaf> Henning Thielemann vs. the World
21:38:43 <Cale> shachaf: What now?
21:39:07 <shachaf> The (,)w thing.
21:39:19 <Cale> Oh, is he opposed to it?
21:39:58 <shachaf> Wasn't he the only person really strongly against it?
21:40:06 <Cale> I don't know
21:40:11 <shachaf> Also against Monad (r ->).
21:40:22 <Cale> I haven't followed the mailing lists ever since the volume got high enough that I couldn't read everything
21:40:37 <shachaf> Not to mention the people.
21:40:56 <shachaf> Also Either, I think.
21:41:10 <scott_> Is there an extension that makes (r ->) valid syntax?
21:41:25 <Cale> Nobody should be taking advice about Haskell libraries from a guy who names all his types T
21:41:36 <lispy> Cale: :)
21:41:41 <lispy> Cale: and classes C
21:41:45 <shachaf> scott_: Not in GHC.
21:42:01 <shachaf> http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/20045
21:42:16 <quchen> I think that discussion was before the libraries committee's formation though.
21:42:21 <iFire> Cale: 64bit ghc doesn't work?
21:42:25 <iFire> on windows
21:42:35 <iFire> With 32bit ghc and sdl libraries it works
21:42:38 <lispy> iFire: it works (on windows) until you need to link something.
21:42:40 <enthropy> scott_: I think as sugar that wouldn't be very helpful, since you need a type-level lambda to do the other section (-> r)
21:42:42 <Cale> iFire: Oh, cool.
21:42:55 <Cale> iFire: I honestly don't know what's required here :)
21:43:03 <lispy> iFire: the problem is that ghc has a builtin linker that doesn't understand the large code size model that windows uses.
21:43:07 <enthropy> well it would be nice to have that syntax, but it doesn't generalize
21:43:10 <Cale> iFire: Maybe a 64 bit version of SDL 2 would help?
21:43:11 <scott_> enthropy: Hmm, true enough
21:43:31 <scott_> Would something like (-> r) be useful?
21:43:44 <Cale> Oh, seems lispy knows more :)
21:43:45 <shachaf> Yes, but not valid Haskell without a newtype.
21:43:51 <shachaf> @src Op
21:43:52 <lambdabot> Source not found. That's something I cannot allow to happen.
21:44:07 <iFire> lispy: is there any prebuild 7.8 packages?
21:44:31 <Cale> scott_: Well, informally, most people use that syntax already when discussing that functor
21:44:41 <Cale> Because it's easier to read than (->) e
21:45:03 <quchen> Weird how nobody uses (a,) when talking about Writer though.
21:45:06 <Cale> oh, (-> r) would be useful
21:45:14 <Cale> But introducing things like that has issues
21:45:37 <Cale> (with respect to type inference especially)
21:45:51 <enthropy>  type State s = s -> (s,)
21:46:00 <shachaf> (s ->) . (s,)
21:46:10 <lispy> iFire: I doubt it. You'd probably have to use a 7.6 install to build 7.8.
21:46:17 <triliyn> 10 :: (,)
21:46:25 <shachaf> help
21:47:43 <quchen> iFire: There's no 7.8 yet.
21:48:35 <lispy> quchen: HEAD of the git repo :)
21:48:50 <lispy> It's still stabilizing, but it's morally 7.8
21:49:15 <iFire> lispy: any idea when it'll be out
21:49:17 <quchen> It's 7.7.something.
21:50:20 <gienah> emerge -av =dev-lang/ghc-9999 from the gentoo haskell overlay :]
21:50:22 <Cale> iFire: Real Soon Now
21:50:40 <quchen> GHC development has switched to Valve time.
21:51:07 <lispy> HL3: GHC
21:52:38 <Cale> https://ghc.haskell.org/trac/ghc/query?status=!closed&milestone=7.8.1&order=priority -- I don't know which bugs they're actually waiting on before release
21:52:55 <lispy> iFire: It was originally scheduled to come out in September, but I guess they got slowed down by last minute stuff.
21:54:01 <Cale> Oh really, September?
21:54:08 <Cale> I read November 25 somewhere
21:54:43 <quchen> I think ICFP was the deadline for patches at some point.
21:54:54 <lispy> oh maybe it was just a patch deadline and I read too much into it.
21:55:04 <lispy> I only casually watch ghc-devs
21:57:17 <iFire> lispy: does ghc have a continous integration system?
21:59:22 <quchen> iFire: This looks related. https://travis-ci.org/nomeata/ghc-complete
22:04:41 <bobajett> if I have a module Vector and a module Matrix and they both export a function "scale", i.e. scale aVector bySomeInt, scale aMatrix bySomeInt, can I not import them together? I get Ambiguous reference scale, could refer to Vector.scale or Matrix.scale :(
22:05:44 <bobajett> I would think Haskell's strong type checking would make it realize when it's being passed a Vector or a Matrix in a call to the "scale" function?
22:06:41 <mauke> but which scale function?
22:07:57 <bobajett> my little test file reads: someNewVector = scale 2 aPreviouslyDefinedVector -- wouldn't that allow Haskell to infer which scale function
22:09:25 <quchen> What if you have more than one ambiguous function? Trying out all combinations grows exponentially with the number of ambiguous words.
22:09:45 <mauke> bobajett: no
22:09:50 <quchen> What if there are two functions that have the same names and types?
22:10:07 <mauke> you're concentrating too much on "function"
22:10:14 <mzero> bobajett: and what about       scaleBy2 x = scale 2 x
22:10:15 <mauke> scale is an arbitrary identifier
22:10:31 <mzero> what type is that?
22:10:34 <mauke> the problem is that haskell needs to assign a type to each expression
22:10:42 <mauke> a single type, that is
22:11:20 <mauke> now imagine scale = 1.23; scale x = scale x aVector; scale = Left "Hello"
22:11:26 <mzero> also - grouping together functions just because they happen to be named similarly in different modules is a poor idea from a software engineering perspective
22:11:27 <bobajett> but what's the difference between (+) (2::Int) (2::Int) and (+) (2::Double) (2::Double) versus (scale 2::Int aVector) and (scale 2::Int aMatrix)?
22:11:37 <mauke> bobajett: + is a method
22:11:42 <mauke> excellent question, btw
22:11:55 <mauke> (+) has a single type, namely: (Num a) => a -> a -> a
22:11:57 <mzero> sure, scale from Vector and scale from Matrix seems like something that aught to be grouped into some sort of family.... but what about scale from Grocery   ?
22:12:04 <mzero> or scale from Fish
22:13:03 <mzero> which is it to, that Int and Double both "bought into" the same (+) when they choose to create instances of Num
22:13:18 <mauke> "standard" perl example: package Spot { extends qw(Dog Tree); ... } my $spot = Spot->new; $spot->bark; :-)
22:13:27 <mzero> where as your scale from Vector and scale from Matrix both just happened to be named similar
22:14:00 <mzero> if you really want scale to apply to either ---- do what (+) did:   Define      class Scalable a where scale :: Int -> a -> a
22:14:07 <mzero> and have instances for both Vector and Matrix
22:14:07 <mauke> if all uses of scale can be resolved statically, you can just use different names
22:14:18 <mauke> because that's what overloading boils down to
22:14:22 <mzero> and now you can        someNewVector = scale 2 aPreviouslyDefinedVector
22:14:45 <mzero> but you can also now       scaleBy2 x = scale 2 x
22:15:29 <mzero> because it would have the type      Scalable a => a -> a
22:16:48 <mzero> And if, perhaps you realize a better class might be....     Affine.... say.... then you get more power because now you can write generic code that works on Affine instances ---- and know it works for types that opt into Affine
22:17:04 <bobajett> awesome thanks guys! (it took me a little bit of time to unwind the helix of mauke's and mzero's answers interspersed together, but I finally got it).
22:17:32 <mzero> which is somewhat better than, say in C++, where you write generic templated code, but are mearly hoping the types it gets used with decided to follow the same lexographic convetions the tempalte assumes
22:18:58 <bobajett> mzero: your C++ comment meaning that in C++ these types of checks would only end up happening at runtime?
22:19:27 <mauke> no, C++ does no checks (but it happens at compile time)
22:19:39 <bobajett> ah ok.
22:19:44 <mauke> template<typename T> void foo(T x) { x.bark(); }
22:19:57 <mauke> foo(something);  // compiles if something has a .bark() method
22:20:02 <mzero> no - at compile time - buy by dint of the type "conforming to the syntax of usage"
22:20:17 <bobajett> cool, makes sense.
22:21:18 <mzero> tempalte<typename T> void foo(T x) { return x.bark() > x.bite() ? (int)x : x.size / 2 }
22:21:34 <mauke> yeah, that is fun
22:21:42 <mauke> (spot the 2 typos)
22:21:53 <mzero> here, T just has to be a type that will /syntatically/ parse in expressions   x.bark()  x.bite()   (int)x    x.size
22:22:15 <mauke> x.bark() > x.bite() is especially open
22:22:33 <mauke> bark could return an object of type A, bite of type B
22:22:34 <mzero> there really isn't any way to declare or require that T has opt'd into some Dog protocol
22:22:41 <mauke> and maybe A defines a > method
22:22:50 <mauke> or there's a global > function for (A, B)
22:22:57 <mzero> yes - mauke, exactly - that could be satisified, syntatitcally, by a huge range of things
22:22:59 <mauke> or maybe there's an implicit conversion from A to B. or B to A
22:23:09 <scott_> Have you heard of the concepts proposal(s) for C++?
22:23:34 <mzero> scott_: no.... because I already have Haskell!
22:23:39 <scott_> :)
22:24:14 <newsham> c++ proposes you switch
22:24:29 <scott_> Basically concepts would allow you to make constraints like a + b is defined and has type foo and then enforce that constraint on the type used in a template
22:24:59 <scott_> And then you could get errors at the template insantiation instead of inside the mess after it's expanded...
22:25:09 <mauke> wow, that sounds almost like a type system
22:25:12 <mzero> 'cause, ya know, the syntax of templated code in C++ hasn't quite yet reached the length of Java... and they need to keep up?
22:25:38 <mauke> but seriously, one of my major annoyances with C++ templates is that they're completely untyped
22:25:39 <bobajett> lol - I like that description "instead of inside the mess after it's expanded"
22:26:00 <mauke> sure, it all happens at compile time but it's still running untyped code
22:26:10 <scott_> mauke: Yeah, it seems like concepts could make a huge difference (less insane error messages)
22:26:12 <mzero> mauke: yes - I think it is a huge problem with C++
22:26:12 <newsham> bobajett: you've never written a program to de-templatize c++ errors?
22:26:40 <bobajett> newsham: by the tone of your question, Im thankful I haven't ;-)
22:27:11 <mzero> most shops deal with it by avoiding templated code, or leaving it only for a few 'wizards' --- but I want to levarge abstraction and genericitiy !!! just want to keep all the engineers sane at the same time!
22:28:08 <quchen> "John, you've been with us for 10 years now. Here is your written permission to use templates in future code."
22:29:03 <newsham> you know in sushi restaurants in japan the trainees get to make rice for 5 years before they're even allwoed to cut the fish :)
22:31:03 <bobajett> "John, I be-knight thee to wield the terribly powerful weapon of Templates in our code base! Let all lesser coders tremble and quiver at the power you now wield!"
22:31:35 <newsham> but you're still not allowed to use pointer arithmetic
22:31:46 <ReinH> Yep, template users are definitely benighted.
22:31:52 <ReinH> Oh that's not quite what you said.
22:43:14 <iFire> data Event
22:43:14 <iFire> Constructors
22:43:14 <iFire> Event	
22:43:14 <iFire> eventTimestamp :: Word32eventData :: EventData
22:43:33 <iFire> how do I access Eventdata in a case
22:43:41 <iFire> given a Event
22:46:12 <mzero> ?
22:46:16 <mzero> is that from some library?
22:46:34 <mzero> did you mean     eventTimestamp :: Word32eventData -> EventData
22:47:13 <mzero> ? even so, there is no Event data in there
22:51:01 <iFire> eventTimestamp :: Word32
22:51:02 <iFire> eventData -> EventData
22:52:27 <mzero> I'm sorry? Is that a fragment of a GADT? Where is this definition? Is it in a library?
22:53:31 <iFire> yeah
22:53:34 <mzero> ah - this is in SDL?
22:53:39 <iFire> yes
22:53:56 <iFire> none of the sdl2 examples work
22:54:13 <mzero> oh o ho oh        data Event = Event { eventTimestamp :: Word32, eventData :: EventData }
22:54:15 <mzero> AH
22:54:34 <mzero> so, you have a value of type Event, and you want the EventData?
22:54:45 <iFire> yes
22:54:47 <Cale> Just apply the eventData function
22:55:00 * iFire is confused 
22:55:01 <mzero>        eventData ev
22:55:12 <Cale> That data declaration automatically defines a field extractor:  eventData :: Event -> EventData
22:55:39 <Cale> Or you could pattern match of course.
22:55:51 <iFire> I'm not sure how to pattern match
22:56:04 <iFire> loop :: IO () -> IO ()
22:56:04 <iFire> loop
22:56:04 <iFire>     = do ev <- pollEvent
22:56:04 <iFire>          case eventData of
22:56:05 <iFire>            Quit -> exitWith ExitSuccess
22:56:06 <Cale> foo (Event ts ed) = ... do something with ed here ...
22:56:07 <iFire>            Keyboard keyMovement _ KeyDown (Keysym 'q' _ _) -> exitWith ExitSuccess
22:56:09 <iFire>            _ -> return ()
22:56:11 <iFire>          loop
22:56:13 <mzero> so, say we've got some function       nextEvent :: IO Event       (I'm guessin' there is something linke that
22:56:17 <mzero> ah, no need
22:56:28 <iFire> hm?
22:56:31 <scott_> iFire: Please use a pastebin for code samples (see the topic)
22:56:38 <mzero>     loop =  do  (Event t d) <- pollEvent;    .....
22:56:41 <mzero> then just use d and t
22:56:42 <mzero> !
22:56:48 <mzero> Or, if you prefer
22:57:05 <mzero> loop = do ev <- pollEvent;   .....  eventData ev ......
22:57:11 <mzero> wherever you need the data
22:57:13 <Cale> iFire: that should be  case eventData ev of ...
22:57:22 <Cale> (in what you pasted)
22:58:12 * mzero wonders if the SDL examples have -XRecordPuns turned on
22:58:34 <Cale> Even if they did, you'd have to write
22:58:41 <mzero> I know....
22:58:45 <mzero> just wondering
22:58:54 <Cale> well, yeah, you know :)
22:58:56 <iFire>   Couldn't match type `IO b0' with `IO () -> IO ()'
22:58:56 <iFire>   Expected type: IO (Maybe Event)
22:58:56 <iFire>                  -> (Maybe Event -> IO b0) -> IO () -> IO ()
22:58:56 <iFire>     Actual type: IO (Maybe Event) -> (Maybe Event -> IO b0) -> IO b0
22:59:11 <iFire> well it is 4 lines of code
22:59:11 <Cale> iFire: in which expression!
22:59:20 <mzero> please , paste bin it
22:59:24 <mzero> @where lpaste
22:59:24 <lambdabot> http://lpaste.net/new/haskell
22:59:27 <Cale> iFire: You left out the most important part, and yeah, use lpaste :)
22:59:55 <iFire> http://lpaste.net/2795718118477922304
22:59:57 <Cale> That looks like maybe you forgot to give a parameter to a function though.
23:00:22 <iFire> http://lpaste.net/9038914414241120256
23:00:58 <Cale> iFire: Okay, so what's the type of withInit?
23:01:14 <iFire> withInit :: [InitFlag] -> IO a -> IO a
23:01:42 <Cale> oh
23:01:48 <Cale> loop :: IO () -> IO ()
23:01:51 <Cale> that's incorrect
23:01:58 <Cale> delete that type signature
23:02:08 <Cale> Or replace it with  loop :: IO ()
23:02:18 <mzero> or  loop :: IO a    even
23:02:37 <mzero> loop doesn't take any arguments
23:02:39 <Cale> right
23:05:04 <iFire> hm
23:05:25 <Cale> iFire: To explain the error you were seeing, because loop :: IO () -> IO () which is  ((->) (IO ())) (IO ()), it means that the whole do-block in which loop is used must then be in the (->) (IO ()) monad, and that makes things confusing.
23:05:52 <iFire> yes. but there's still problems :/
23:05:57 <Cale> okay, what's left
23:06:11 <iFire> http://lpaste.net/3512293558813982720
23:06:34 <iFire> http://lpaste.net/1195760930051325952
23:06:46 <c_wraith> chrisdone: how the heck do you type >>= with your emacs config? If I try, it inserts spaces around the =
23:06:47 <Cale> oh, right
23:07:15 <Cale> In those patterns, you're pattern matching against Maybe EventData values
23:07:28 <Cale> e.g. Just Quit -- the Just is a constructor of Maybe
23:07:46 <Cale> Maybe try deleting the occurrences of Just there
23:08:01 <Cale> Also,  Just keyMovement _ KeyDown (Keysym 'q' _ _)
23:08:09 <Cale> that's horribly not-well-typed
23:08:15 <Cale> Just only takes one argument
23:08:21 <Cale> and here, it has 4
23:08:31 <iFire> http://lpaste.net/1040899849764995072
23:09:03 <Cale> Oh, pollEvent :: IO (Maybe Event)?
23:09:20 <iFire> yeah
23:09:33 <Cale> In that case, re-wrap the constructors in Just and use  fmap eventData ev
23:09:56 <Cale> eventData :: Event -> EventData
23:10:05 <Cale> so using the Maybe instance for Functor, we have
23:10:15 <Cale> fmap eventData :: Maybe Event -> Maybe EventData
23:11:06 <iFire> in my code?
23:11:07 <Cale> fmap f Nothing = Nothing
23:11:09 <iFire> or sdl's code
23:11:13 <Cale> In loop
23:11:23 <Cale> fmap f (Just x) = Just (f x)
23:11:30 <Cale> ^^ this is the standard fmap for Maybe
23:11:36 <Cale> (It's in the Prelude)
23:12:02 <Cale> Oh, the only change I'm recommending is something like
23:12:11 <Cale> case fmap eventData ev of
23:12:18 <Cale>   Just Quit -> ....
23:13:00 <Cale>   Just (OtherStuff ...) -> ...
23:13:15 <Cale> (I don't know what the correct other patterns are, the code you pasted last has some issues...)
23:13:29 <Cale> oh, is Keyboard right?
23:13:30 <iFire> the checking for q code is wrong
23:13:37 <iFire> yeah
23:13:44 <iFire> it's wrong
23:14:01 <Cale> Where is the haddock for this SDL 2 library?
23:14:04 * hackagebot wai-app-static 1.3.3.1 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.3.3.1 (MichaelSnoyman)
23:14:06 * hackagebot wai-app-static 2.0.0.1 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-2.0.0.1 (MichaelSnoyman)
23:14:28 <Cale> (I wish people would put stuff on Hackage and not just github)
23:14:30 <iFire> I generated it locally
23:14:34 <Cale> ah, okay
23:17:06 <lispy> Cale: The SDL2 binding isn't released yet
23:17:14 <lispy> Cale: That's why it's not on hackage yet
23:17:31 <lispy> and perhaps also why iFire is struggling with it
23:17:44 <Cale> lispy: Put it on Hackage anyway! :D
23:18:09 <lispy> I'm not actually involved :)
23:18:39 <moop> hi folks, i want to learn haskell, but i need your help
23:18:54 <moop> there are so many guides out there that i don't know which one to choose
23:18:56 <moop> D:
23:18:58 <Cale> moop: Feel free to hang around and ask lots of questions
23:19:00 <lispy> Cale: I more invested in GLFW-b at the moment. SDL + cabal tends to mean hand-holding. :/
23:19:06 <Cale> moop: Perhaps Learn You A Haskell
23:19:17 <Cale> http://learnyouahaskell.com/chapters
23:19:23 <moop> oh, ty Cale
23:19:51 <lispy> moop: the most important thing though, is to try stuff and ask questions. Don't be shy :)
23:20:17 <moop> i tried tryhaskell but quickly understood that it doesn't even touch on all the features of the language
23:20:22 <moop> just the very basic ones
23:20:28 * lispy nods
23:20:29 <Cale> yeah, it's like a 10 minute intro
23:20:33 <Cale> from what I recall
23:20:38 <moop> yes
23:20:48 <moop> anyway
23:21:01 <moop> time to grok the learn you a haskell
23:22:17 <drbean> How do you pattern match on the first character of a string elegantly? ('#':_) is best?
23:22:44 <Skola> Can this be written more generally? nacci q xs = let p = sum (genericTake q xs) in p : nacci q (p:xs)
23:22:50 <lispy> drbean: yeah, that or use a guard and isPrefixOf
23:23:09 <iFire> http://lpaste.net/1040899849764995072
23:23:12 <iFire> this is what compiles
23:23:18 <iFire> Cale, moop
23:23:27 <iFire> it flashes for 1 second but that's a logic error
23:23:35 <Skola> doing (p :) twice annoys me
23:25:04 <Cale> iFire: cool
23:26:30 <Cale> > let nacci q xs = let p = sum (genericTake q xs) in p : nacci q (p:xs) in nacci 2 [0,1]
23:26:32 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
23:26:36 <Cale> okay
23:26:42 <Cale> hmm
23:33:31 <Skola> fg
