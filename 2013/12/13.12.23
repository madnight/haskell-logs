00:00:03 <jle`> > return () >> return 5
00:00:04 <lambdabot>  No instance for (GHC.Show.Show (m0 b0))
00:00:04 <lambdabot>    arising from a use of `M56163011012635492504758.show_M56163011012635492504...
00:00:04 <lambdabot>  The type variables `m0', `b0' are ambiguous
00:00:04 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
00:00:04 <lambdabot>  Note: there are several potential instances:
00:00:12 <jle`> > return () >> return 5 :: [Int]
00:00:13 <lambdabot>  [5]
00:00:18 <jle`> > mzero >> return 5 :: [Int]
00:00:19 <lambdabot>  []
00:00:26 <zRecursive> why ?
00:00:31 <johnw> why what?
00:00:39 <jle`> it might be easier to see using Maybe
00:00:49 <jle`> > return () >> return 5 :: Maybe Int
00:00:50 <lambdabot>  Just 5
00:00:51 <zRecursive> why mzero >> return  :: [Int] ?
00:00:52 <johnw> @src List mzero
00:00:53 <lambdabot> Source not found. My brain just exploded
00:00:57 <jle`> > Nothing >> return 5 :: Maybe Int
00:00:58 <johnw> @src [] mzero
00:00:58 <lambdabot> mzero = []
00:00:58 <lambdabot>  Nothing
00:01:10 <johnw> @src Maybe mzero
00:01:11 <lambdabot> mzero = Nothing
00:01:14 <jle`> >> anything to a Nothing results in a nothing
00:01:15 <eitan> because of the MonadPlus laws
00:01:29 <zRecursive> :t mzero
00:01:30 <eitan> mzero kinda acts like "multiplying by zero"
00:01:30 <lambdabot> MonadPlus m => m a
00:01:51 <zRecursive> i see now
00:01:55 <jle`> > return 5 >> return 6 >> Nothing >> return 7 :: Maybe Int
00:01:56 <lambdabot>  Nothing
00:02:03 <jle`> > return 5 >> return 6 >> mzero >> return 7 :: Maybe Int -- sorry
00:02:04 <lambdabot>  Nothing
00:02:04 <eitan> with respect to bind
00:02:12 <jle`> > return 5 >> return 6 >> mzero >> return 7 :: [Int]
00:02:13 <lambdabot>  []
00:02:13 <johnw> > Just 4 `mplus` mzero
00:02:14 <lambdabot>  Just 4
00:13:04 <jle`> > Just 4 <|> empty
00:13:06 <lambdabot>  Just 4
00:14:02 * hackagebot free-game 0.9.4.3 - Cross-platform GUI library based on free monads  http://hackage.haskell.org/package/free-game-0.9.4.3 (FumiakiKinoshita)
00:14:02 * hackagebot rmonad 0.8.0.2 - Restricted monad library  http://hackage.haskell.org/package/rmonad-0.8.0.2 (GaneshSittampalam)
00:18:38 <jle`> @src mfilter
00:18:38 <lambdabot> Source not found. My mind is going. I can feel it.
00:19:13 <eitan> cool...make him sing Daisy
00:20:38 <bitemyapp> How could this be improved? - http://lpaste.net/97409
00:21:32 <simpson> Argfl. Cannot figure out how to use the Unspaced and Unlined newtypes in parsers.
00:24:06 <simpson> Aha, success. That's... tricky.
00:28:58 * hackagebot cabal-dir 0.1.0.0 - show dist dir of 'cabal copy/install'  http://hackage.haskell.org/package/cabal-dir-0.1.0.0 (YoshikuniJujo)
00:38:58 * hackagebot cabal-dir 0.1.0.1 - show dist dir of 'cabal copy/install'  http://hackage.haskell.org/package/cabal-dir-0.1.0.1 (YoshikuniJujo)
00:43:23 <jle`> anyone know who manages lpaste?
00:43:42 <jle`> or can figure out why my lpastes never get posted here even though lpaste feels like it expects them to
00:43:48 <jle`> maybe it's the ` in my name
00:44:42 <jle_> hm that's not it.
00:45:22 <jle`> i don't know how much longer i can survive like this
00:48:59 * hackagebot json-rpc-server 0.1.0.0 - JSON RPC 2.0 on the server side.  http://hackage.haskell.org/package/json-rpc-server-0.1.0.0 (grayjay)
00:49:35 <simpson> jle`: Are you setting the channel?
00:49:52 <jle`> simpson: yes i am
00:50:08 <kbotnen> doesnt work for me either.
00:50:10 <jle`> later on when i click "expand", it even posts a link to the #haskell archives searching for the lpaste number
00:50:16 <jle`> as if it expects it to be there
00:50:44 <kbotnen> probably a bacground job that hangs or need to be started on the server.
00:50:51 <simpson> Yep, guess it's broken.
00:51:22 <jle`> hm. my fallable human memory suggests that i ahve tried it before while seeing it working for other people, with still no luck
00:51:27 <jle`> but i shall try again later.
00:53:41 <triliyn> jle`: why do you use a suffix for your name?
00:54:12 <jle`> triliyn: because jle is already registered
00:54:23 <triliyn> ah, okay
00:54:42 <jle`> :)
00:58:04 <simpson> @src (<*)
00:58:04 <lambdabot> (<*) = liftA2 const
00:58:18 <simpson> @src (*>)
00:58:19 <lambdabot> (*>) = liftA2 (const id)
01:20:42 <joejev> I am wondering if map f . filter will only iterate through a list once because of laziness, or twice
01:23:06 <quchen> joejev: That will only go over the list once due to laziness by default.
01:23:15 <quchen> By non-default GHC will most likely fuse the two together.
01:23:16 <dmj`> joejev: once, evaluation will be driven outside by map, from outside in
01:23:17 <shachaf> What does that mean?
01:24:02 <jle`> hm. map asks for one element at a time
01:24:08 <jle`> and filter can return one element at a time?
01:24:10 <jle`> is that what you mean?
01:24:11 <quchen> shachaf: I think what he meant was whether the "filter" part traverses the entire list (forcing the spine etc) or not.
01:24:28 <quchen> Before the mapping starts happening, that is.
01:25:04 <BoR0> I think he wants to know what would be the execution order. will map return a new list, and filter work on that list? so the execution time would be O(n+m) (n is old list, m is filtered), or just O(n)
01:25:58 <shachaf> I think in this case the most important part is probably to make sure the question is understood.
01:26:44 <jle`> i think he is asking if the composition has to go through every element of teh list twice, or only once
01:26:44 <shachaf> Because what the question is isn't obvious and actually pinning it down probably requires a reasonable understand of how Haskell code is evaluated.
01:27:39 <shachaf> But you can narrow down parts of it, like asking "if I do X to an infinite list/list with Y element at the end/whatever, will Z happen"
01:28:00 <jle`> you can also ask what happens if you only want the head
01:28:19 <BoR0> map f . filter is equal to map f (filter p list). so will map work at the same time with filtering, or will it wait filter to finish and then re-evaluate the new list
01:28:51 <shachaf> That would be useful to ask/answer.
01:29:25 <BoR0> so we have either O(n+m) or O(n), depending on the evaluation strategy
01:29:50 <dv-> > take 1 $ filter (== 2) $ map (+1) [1, undefined, undefined, undefined]
01:29:52 <lambdabot>  [2]
01:30:11 <shachaf> I feel kind of bad about answering a question that has a wrong premise, because it feels like misleading people further into a rabbit hole. So I like to clarify what question was actually meant.
01:30:16 <jle`> @src map
01:30:16 <lambdabot> map _ []     = []
01:30:16 <lambdabot> map f (x:xs) = f x : map f xs
01:30:19 <jle`> @src filter
01:30:19 <lambdabot> filter _ []     = []
01:30:20 <lambdabot> filter p (x:xs)
01:30:20 <lambdabot>     | p x       = x : filter p xs
01:30:20 <lambdabot>     | otherwise = filter p xs
01:30:21 <jle`> @src fold
01:30:21 <lambdabot> Source not found. There are some things that I just don't know.
01:30:40 <jle`> oh i guess filter isn't implemented in terms of fold
01:30:55 <jle`> so much for my uni fp course
01:32:20 <shachaf> This way lies mauke-ism.
01:32:43 <BoR0> > map (+1) (filter (>3) [1,2,3,4,5])
01:32:44 <lambdabot>  [5,6]
01:32:49 <BoR0> > foldr (\x y -> if x > 3 then ([x + 1]++y) else y) [] [1,2,3,4,5]
01:32:50 <lambdabot>  [5,6]
01:35:00 <BoR0> > foldr (\x y -> if x > 3 then (x+1):y else y) [] [1,2,3,4,5] -- even better
01:35:01 <lambdabot>  [5,6]
01:37:06 <BoR0> and the generalization of that is mapfilter p f l = foldr (\x y -> if (p x) then (f x):y else y) [] l. now is mapfilter faster than map.filter, or are they equal? :)
01:37:42 <jle`> think about what happens when you want the first element.
01:37:55 <jle`> for map
01:37:58 <jle`> you require x, to do f x
01:38:51 <BoR0> ok, what does that tell me?
01:38:56 <jle`> what do you need to do to get x, then?
01:39:28 <BoR0> I don't know, head?
01:39:41 <jle`> what does filter need to do
01:39:44 <jle`> to be able to return its head
01:40:34 <BoR0> I am confused, the predicate to hold?
01:41:00 <jle`> try to 'step through' the recursive steps of filter
01:41:05 <jle`> tto see the first time it returns an element
01:41:29 <BoR0> that'd be the first time the predicate is true, isn't it
01:41:47 <TheMK> cd
01:44:04 * hackagebot yesod-auth 1.2.5.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.2.5.1 (MichaelSnoyman)
01:44:37 <jle`> i guess i was just trying to show that it doesn't filter the list, then map it
01:44:45 <jle`> it maps and filters each element
01:44:47 <jle`> at once
01:44:50 <FliPPeh> I wonder, how does the minimal typeclass implementation work? For example, for Ord you need at least "compare" or "<=", but how is that realized in the code?
01:44:50 <jle`> in one swoop
01:45:32 <BoR0> it'd be great if that was the case, but I don't see how that shows that it filters and maps each element at once
01:47:13 <vlitomsk> hello men
01:47:49 <vlitomsk> data Einfo = Einfo { sym::Char, cnt::Int } deriving (Eq, Show) -- GHC says that cnt is defined but not used.
01:48:09 <shachaf> This channel is not only men.
01:48:11 <vlitomsk> is there any way to write something like: data Einfo = Einfo {sym::Char, _:: Int}
01:48:27 <FliPPeh> Or maybe the easier example, Eq. I can either define == or /=, how does that work? If I define ==, it uses that to generate the /= function, but if I define /= it'll use that to define ==
01:48:34 <FliPPeh> This looks pretty darn recursive to me
01:48:49 <vlitomsk> shachaf, oh, sorry for mistake. my English leaves much to be desired
01:49:01 <Saizan> FliPPeh: the default implementations there are indeed mutually recursive
01:49:17 <Saizan> FliPPeh: you providing an explicit one breaks the loop
01:49:32 <FliPPeh> So is that some kind of magic or can I do that in my own code?
01:49:48 <shachaf> vlitomsk: OK. :-) Words like "people" are more friendly in general.
01:50:03 <shachaf> vlitomsk: You can use { ..., _cnt :: Int }
01:50:12 <shachaf> It's not magic. Just ordinary recursion.
01:50:16 <Saizan> FliPPeh: just provide definitions for the methods in your typeclass definition
01:50:19 <shachaf> Well. It's not even recursion in practice.
01:50:26 <shachaf> It's just ordinary calling functions.
01:50:32 <shachaf> In the next version of GHC, it'll warn you when you forget to define one!
01:52:12 <FliPPeh> I think what's confusing me here is the overriding part
01:52:20 <dmj`> vlitomsk: do you have more code to show?
01:52:34 <FliPPeh> Because usually you'd get an error but in type classes you just override the default
01:52:45 <FliPPeh> You don't even see it
01:53:02 <Saizan> it's not even overriding
01:53:26 <Saizan> think of the default as "if the method is not implemented fill this in" rather than a starting point
01:53:30 <vlitomsk> shachaf, I want 'sym' to be present. if i would use '...', how Haskell would know its type?
01:54:22 <vlitomsk> dmj`, i never use 'cnt', but sometimes i use 'sym'
01:54:32 <Saizan> vlitomsk: ... was a placeholder for what you might want there
01:54:45 <Saizan> vlitomsk: the important part is to prefix cnt with a _
01:55:33 <vlitomsk> Saizan, shachaf: Thanks! Warning disappeared! :)
01:56:10 <bennofs> preflex: xseen Feuerbach
01:56:10 <preflex>  Feuerbach was last seen on freenode/#haskell 3 days and 9 seconds ago, saying: xintron: yes, http-conduit is good
01:58:36 <dmj`> any ideas as to why a remote acid state can be connected to via ghci on windows, but not when compiled?
01:59:05 * hackagebot cabal2ebuild 0.0.15.3 - make gentoo's .ebuild file from .cabal file  http://hackage.haskell.org/package/cabal2ebuild-0.0.15.3 (YoshikuniJujo)
02:03:32 <donri> dmj`: not really but, is it a UnixSocket?
02:04:10 <donri> also, is ghci in the same environment like mingw or no mingw, as compiled?
02:04:22 <donri> and are you getting any error messages?
02:08:28 <dmj`> donri: the connection is made, but then it simply hangs on queries/updates. I've turned on the debugger. All done through cygwin terminal. I think the issue is with my code since the remote examples work ootb.
02:09:02 <dmj`> donri: The state is served via linux (so yes unix sockets) and accessed w/ windows
02:09:24 <donri> dmj`: but is it served via UnixSocket? or PortID?
02:09:54 <donri> UnixSocket is a type of file
02:10:56 <dmj`> donri: http://lpaste.net/97414
02:12:48 <donri> dmj`: yeah that doesn't look quite right
02:13:00 <donri> dmj`: you're running the acidServer in the finalizer for the state handle?
02:13:11 <dmj`> donri: I assumed cygwin tried to emulate unix sockets, maybe I'm confused
02:13:22 <dmj`> donri: yes, the code was taken from the acid-state remote example
02:13:29 <donri> dmj`: you're not using UnixSocket, forget about that :)
02:13:46 <dmj`> https://github.com/acid-state/acid-state/blob/master/examples/RemoteServer.hs
02:13:50 <dmj`> donri: ok :)
02:14:39 <donri> ah no i misread the bracket
02:16:49 <donri> dmj`: and how are you connecting?
02:17:12 <donri> also did you mean it fails when the server is compiled or when the client is?
02:17:35 <donri> anyway i don't really know anything about windows, you might like to file a bug
02:18:28 <dmj`> when the client is compiled
02:19:23 * hackagebot cabal2ebuild 0.0.15.3 - make gentoo's .ebuild file from .cabal file  http://hackage.haskell.org/package/cabal2ebuild-0.0.15.3 (YoshikuniJujo)
02:19:23 * hackagebot soap 0.2.1.2 - SOAP client tools  http://hackage.haskell.org/package/soap-0.2.1.2 (AlexanderBondarenko)
02:22:05 <dmj`> donri: I'm connecting w/ a call to openRemoteState here http://hackage.haskell.org/package/acid-state-0.11.4/docs/src/Data-Acid-Remote.html#openRemoteState
02:22:12 <dmj`> donri: http://lpaste.net/97415
02:23:10 <dmj`> donri: I appreciate the help, I apologize it's highly ambiguous
02:24:18 * hackagebot cabal2ebuild 0.0.15.4 - make gentoo's .ebuild file from .cabal file  http://hackage.haskell.org/package/cabal2ebuild-0.0.15.4 (YoshikuniJujo)
02:26:09 <donri> dmj`: have you tried the program with runghc and with -O0 ?
02:26:23 <donri> the client
02:27:22 <d3lxa> if I want to sort desc with sortBy, I need to reverse 'compare' right? is there such function, it's inefficient to reverse afterward right?
02:29:29 <jle`> BoR0: if you wanted the first three items, for example, you'd ask filter for the first item, apply f to it, return the first; then ask filter for the second item, apply f to it, return the second, etc.
02:29:49 <jle`> you wouldn't filter the entire list, stop, then run through the filtered list and map it
02:29:59 <supki_> d3lxa: flip compare
02:30:20 <jle`> in that sense it is o(n) in time complexity
02:30:29 <supki_> > sortBy (flip compare) [1,7,4,2,8]
02:30:30 <lambdabot>  [8,7,4,2,1]
02:30:42 <dmj`> donri: tried runghc, runhaskell same thing.
02:30:57 <Zepheus> there's a 'Down a' type afaik
02:30:58 <d3lxa> supki_: duh, so easy! thx
02:31:18 <dmj`> donri: Unsure about -O0
02:31:25 <jle`> BoR0: it basically *is* a 'find first then map' function, with the laziness
02:31:41 <jle`> er, filter and map as you filter
02:32:15 <dmj`> donri: oh, optimizations? Yes, but the remote acid-state ex, works w/o any additional compilation options
02:34:10 <FliPPeh> Oh god, implementing a read instance is much harder than I thought
02:37:41 <donri> FliPPeh: have you looked at ReadP?
02:39:23 <FliPPeh> Nope
02:39:31 <FliPPeh> I don't need something that sophisticated
02:39:39 <jle`> hm
02:39:43 <jle`> ReadP is supposed to make it easier
02:39:45 <boothead> Hi Folks, is there a way to change ghc-options from cabal repl? :unset -Werror would be helpful about now :-)
02:39:52 <FliPPeh> What I have is a fancy string that I want to show and read as a normal string
02:40:26 <FliPPeh> show (Name "foo") == "\"foo\"", (read "\"foo\"" :: Name) == Name "foo"
02:42:34 <merijn> "instance Read Name where read s = Name (read s)" should work, no?
02:42:45 <FliPPeh> I thought so too
02:42:48 <merijn> FliPPeh: Assuming Name == "newtype Name = Name String"
02:42:52 <FliPPeh> but "read" is not a method of "Read"
02:43:21 <FliPPeh> You have readsPrec, readsList and all that nonsense
02:43:29 <merijn> oh, right
02:44:20 * hackagebot soap 0.2.1.3 - SOAP client tools  http://hackage.haskell.org/package/soap-0.2.1.3 (AlexanderBondarenko)
02:45:23 <FliPPeh> It's okay
02:45:27 <jle`> FliPPeh: your ReadS is going to be ReadS $ \s -> [(Name s, "")]
02:45:28 <merijn> I always get rather annoyed when I have to implement my own Read instance
02:45:48 <FliPPeh> I think hiding the type constructor is much more disgusting than anything else
02:45:51 <jle`> so your readsPrec should be readsPrec _ = ReadS $ \s -> [(Name s, "")]
02:48:45 <jle`> hm
02:48:51 <jle`> oh you want to read the s
02:49:22 <dleedev> Cale: hi
02:57:12 <danilo2> enthropy: do you remember our yesterdays talk about "instance (y ~ (t1 -> t2 -> (t1,t2))) => Member1 Vector y" instead of fundeps? Unfortunatelly I'm not able to generate "Exotic predicate type" in Template Haskell (it is not supported YET). Can we express it different way?
02:58:20 <bennofs> danilo2: Is it because TH doesn't support ~ (type equality)?
02:58:34 <danilo2> bennofs: exactly
02:58:52 <danilo2> bennofs: brb, I'll paste a code showing TH error
03:00:07 <danilo2> bennofs: http://lpaste.net/97417
03:00:10 <bennofs> danilo2: IIRC oleg had a TypeEq type class that you could use as a constraint.
03:01:28 <danilo2> bennofs: Could you tell a little mroe about it?
03:02:07 <danilo2> By the way, does anybody know when the "exotic predicate types" will be implemented in TH? Should we expect it working in GHC 7.8? (http://lpaste.net/97417)
03:02:44 <dleedev> Cale: I guess you're not here right now, I'll come back later
03:02:52 <bennofs> danilo2: http://hackage.haskell.org/package/HList-0.3.0.1/docs/src/Data-HList-FakePrelude.html#HEq and http://hackage.haskell.org/package/HList-0.3.0.1/docs/src/Data-HList-TypeEqO.html#TupleType
03:06:09 <danilo2> bennofs: If I understand correctly - this type class checks equality of arguments - and in GHC 7.7 we can implement it better as closed type family, am I right?
03:06:45 <bennofs> danilo2: yes, I think so
03:08:07 <boothead> is there a way to compose a Lens with a Traversal? (i.e. to apply the lens to a data structure and then the traversal to the part that the lens points to)
03:08:28 <bennofs> boothead: yes, just compose it
03:08:32 <bennofs> boothead: using (.)
03:08:54 <jle`> it's magic, man
03:08:57 <boothead> bennofs, I thought that, but it's giving me an error that I can't understand
03:09:05 <bennofs> > [(1,2,3), (2,3,4)] ^.. traverse._2   -- Here I composed a lens (_2) with a traversal (traverse)
03:09:07 <lambdabot>  [2,3]
03:09:24 <bennofs> boothead: Could you paste the relevant code + error message?
03:09:28 <boothead> When using functional dependencies to combine... am I using the wrong lookup perhaps?
03:09:51 <bennofs> @where lpaste
03:09:51 <lambdabot> http://lpaste.net/new/haskell
03:09:56 <bennofs> boothead: put your code there
03:10:40 <boothead> actually, let me deconstruct this a bit better, I've got several things screwed up at once :-)
03:14:22 * hackagebot circle-packing 0.1.0.3 - Simple heuristic for packing discs of varying radii in a circle  http://hackage.haskell.org/package/circle-packing-0.1.0.3 (JoachimBreitner)
03:17:05 <dmj`> donri: figured it out
03:19:39 <dmj`> donri: I had a forever $ do { threadDelay (sec 2) >> putStrLn "rvcd" }, on unix it prints "rcvd", windows it wasn't. Thread delay might act differently, unsure.
03:20:50 <bennofs> danilo2: It's even easier than what I propesed
03:21:22 <bennofs> danilo2: http://lpaste.net/97418
03:21:41 <bennofs> danilo2: I just made a super class, so we can refer to that class by name
03:26:34 <danilo2> bennofs: hmm, that is very interesting! thank you! By the way is there ANY difference between this and "~" ? Any in type checking / inference or something else?
03:27:56 <bennofs> dnewby: I don't think so. Btw, I just tested it: you can even use type HEq = (~) with -XConstraintKinds
03:28:51 <bennofs> danilo2: hmm, oops, I don't even get the error you were getting, even when using ~ :|
03:28:59 <ClaudiusMaximus> > over _2 reverse (123, "abc") -- boothead, maybe you want  over  but I'm quite new to lens so I'm not sure...
03:29:01 <lambdabot>  (123,"cba")
03:29:54 <Eduard_Munteanu> Hm... Looks like you can abuse classes to give meaningful error messages too. :)
03:30:22 <danilo2> bennofs: seriously? What is your output of runQ [d| instance ( y ~ (t->t) ) => Member Vector y where member v = test  |] and ghc version?
03:30:27 <donri> i just wish we had closed type classes :D
03:30:59 <danilo2> donri: +1
03:31:37 <mikeplus64> why is mtl used over monads-tf?
03:32:00 <mikeplus64> historical/hysterical reasons or is there a 'real' reason?
03:32:04 <ClaudiusMaximus> Eduard_Munteanu: i seem to recall something along the lines of   instance Chewbacca t => This t Does Not Make Sense
03:32:15 <bennofs> danilo2: turns out it doesn't work in GHCi :O
03:32:35 <bennofs> danilo2: but if I use main = print =<< print =<< runQ [d| instance y ~ (t -> t) => Member Vector y where member _ = test  |] it works fine
03:32:48 <danilo2> bennofs: coudl you post the output ?
03:32:59 <bennofs> [InstanceD [EqualP (VarT y_0) (AppT (AppT ArrowT (VarT t_1)) (VarT t_1))] (AppT (AppT (ConT Main.Member) (ConT Main.Vector)) (VarT y_0)) [FunD Main.member [Clause [WildP] (NormalB (VarE Main.test)) []]]]
03:33:33 <bennofs> danilo2: ^^
03:33:40 <danilo2> bennofs: you are right! wow.
03:34:50 <danilo2> bennofs: I do not understand why GHCi does not allow for what we can write in normal hhs files, but this information made my day!
03:34:55 <danilo2> bennofs: Thank you! :)))))
03:35:01 <donri> mikeplus64: can you newtype derive with associated types? (don't know)
03:35:22 <Eduard_Munteanu> ClaudiusMaximus: I'm thinking of   class ErrorMessage (msg :: Symbol)    instance OtherClass ...   instance (ErrorMessage "failed") => OtherClass ...   assuming OverlappingInstances
03:37:00 <ClaudiusMaximus> Eduard_Munteanu: yeah that's what i recall but with the details that i didn't - and i think if you can list all the failure modes of otherclass then you might not need overlap?
03:37:58 <mikeplus64> donri: i don't think so. do you mean like "deriving instance Foo (SomeAssocTypeHere Bar)"?
03:38:43 <Eduard_Munteanu> It should be possible to derive, you can derive GADTs that way too.
03:38:43 <mikeplus64> donri: yeah you can't
03:38:45 <danilo2> bennofs: I filled a bug about it. If you want to see it, its here: https://ghc.haskell.org/trac/ghc/ticket/8625#ticket
03:39:06 <donri> mikeplus64: newtype Handler a = Handler (ReaderT Request (WriterT (Endo Response)) a) deriving (MonadReader Request, MonadWriter (Endo Response))  -- using GeneralizedNewtypeDeriving
03:39:15 <donri> not sure you can do anything like that with monads-tf
03:39:34 <mikeplus64> ah, hm
03:39:40 <donri> it's trivial to write by hand but boring
03:39:49 <bennofs> danilo2: Check this out: http://lpaste.net/3425592552953217024 It even works at GHCi!
03:40:22 <Eduard_Munteanu> ClaudiusMaximus: if the failure mode isn't a constraint failing to match
03:40:23 <donri> Eduard_Munteanu: type families? how
03:40:33 <danilo2> bennofs: hmm, so monadic binding in IO allows this code to work. Very interesting
03:41:07 <bennofs> danilo2: and you can also omit the print
03:41:15 <Eduard_Munteanu> donri: you can just do standalone deriving on GADTs as long as the resulting code typechecks
03:41:27 <donri> Eduard_Munteanu: we're talking about monads-tf though
03:41:30 <danilo2> bennofs: When I ommit the print, I'm getting the error, I showed before
03:41:36 <donri> Eduard_Munteanu: how do you derive a class with associated types
03:41:48 <donri> stand alone type instance maybe?
03:41:49 <bennofs> danilo2: I don't get the error when I omit the print, but when I use your sequence, I get the error
03:41:53 <bennofs> danilo2: weird
03:41:54 <donri> does that work?
03:42:22 <Eduard_Munteanu> donri: what's the error message? I'm thinking you might be able to do it if GHC at least attempts to generate code.
03:42:40 <mikeplus64>       (even with cunning newtype deriving):
03:42:43 <mikeplus64>       cannot eta-reduce the representation type enough
03:42:45 <mikeplus64>       the class has associated types
03:42:52 <mikeplus64> that would be the error
03:42:53 <Eduard_Munteanu> Ah, hm.
03:42:53 <danilo2> bennofs: You are right - when I started clean GHCi session, it works even without print
03:42:53 <donri> Eduard_Munteanu: no error message, i was just suggesting one reason mtl might have "won" over monads-tf, in response to mikeplus64's question
03:43:26 <obk> My work env is broken since MissingH 1.2.0.2 doesn't work with unix-2.7.0.0 (both latest versions), seems a 2nd argument was added to the Terminated constructor?
03:43:34 <donri> mikeplus64: although i think the main reason might be that mtl predates it and monads-tf uses the same module names, and because people don't want to deal with PackageImports one of the two has to "win"
03:43:52 <obk> What do I do now to restore a working environment?
03:44:25 <Eduard_Munteanu> At the very least you'd need to fix the type parameters to stay within the same instance, to derive.
03:44:38 <mikeplus64> donri: yeah i guess so. it wouldn't be so bad with monads-tf if the associated types were outside of the classes, that way you can at least derive the instances after defining the type family instances
03:44:48 <mikeplus64> more effort than just deriving (MonadReader) or whatever but still
03:45:33 <donri> i really like type families but they're lacking in some departments
03:45:42 <donri> haddock is bad at documenting them for example
03:45:57 <Eduard_Munteanu> Yeah, they're rather useless for type system tricks, it occured to me.
03:46:01 <donri> MPTCs sorta just work there by accident :P
03:46:42 <aristid> i think for the mtl/monads-fd/monad-tf, fd just won pretty much :P
03:46:54 <Eduard_Munteanu> I still end up using classes with a fundep-implied result parameter, since type families don't take contexts and they're too opaque at times. :(
03:47:05 <donri> aristid: mike's question was, why? :)
03:53:31 <boothead> bennofs, ClaudiusMaximus: it was indeed simple composition. My problem was type inference further down in the file. Thanks for your help!
04:04:26 * hackagebot wl-pprint-text 1.1.0.1 - A Wadler/Leijen Pretty Printer for Text values  http://hackage.haskell.org/package/wl-pprint-text-1.1.0.1 (IvanMiljenovic)
04:12:08 <exicer> So I can do ['a'..'z'], and ['A'..'Z'] - but is there an easy way to get ['a'..'Z'] ?
04:13:40 <k00mi> exicer: upper case letters come before lower case and between them there are other symbols
04:13:51 <k00mi> > ['A'..'z']
04:13:52 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
04:14:00 <exicer> Ah, thanks
04:14:03 <exicer> Good to know!
04:14:35 <bennofs> > (++) <*> map toUpper $ ['a'..'z']
04:14:36 <lambdabot>  "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
04:14:54 <bennofs> toUpper <> id $ ['a'..'z']
04:14:57 <bennofs> > toUpper <> id $ ['a'..'z']
04:14:58 <lambdabot>  Couldn't match expected type `GHC.Types.Char'
04:14:58 <lambdabot>              with actual type `[GHC.Types.Char]'
04:15:02 <bennofs> > map toUpper <> id $ ['a'..'z']
04:15:03 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
04:15:50 <dv-> or just ['a'..'z'] ++ ['A'..'Z']
04:18:30 <aristid> > filter isAlpha ['\0'..'\127']
04:18:31 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
04:24:05 <m1dnight> could anyone help me for a second with cabal?
04:24:21 <m1dnight> i'm trying to get the snap tutorials up and running but i'm guessing im having issues with cabal
04:25:24 <haasn> > ['a'..'z'] ^.. folded.(to toUpper <> id)
04:25:25 <lambdabot>  No instance for (Data.Monoid.Monoid
04:25:26 <lambdabot>                     (Control.Lens.Internal.Getter.Accessor
04:25:26 <lambdabot>                        (Data.Monoid.Endo [GHC.Types.Char]) GHC.Types.Char))
04:25:26 <lambdabot>    arising from a use of `Data.Monoid.<>'
04:25:26 <lambdabot>  Possible fix:
04:25:37 <haasn> heh, that would be AaBbCc either wayt
04:33:15 <m1dnight> I keep getting the following errors in cabal : "the following packages are likely to be broken by the reinstalls:"
04:33:22 <m1dnight> 'snap...' and 'heist..'
04:33:25 <m1dnight> how do I fix this?
04:33:32 <aristid> m1dnight: what are you trying to reinstall?
04:33:35 <m1dnight> nothing
04:33:41 <m1dnight> I installed cabal for the snap framework
04:33:51 <m1dnight> and I just tried "snap init tutorial"
04:33:54 <m1dnight> and then it throws that in my face :p
04:34:06 <aristid> so snap init tries to reinstall stuff? oO
04:34:18 <m1dnight> I tried cabal update (which doenst give me any output), and then I did "cabal install cabal-install"
04:34:50 <m1dnight> oh aristid i'm sorry: I did the 'cabal install' in my project folder to build it
04:35:00 <m1dnight> cabal init tutorial works, but cabal install for the project doesnt
04:35:04 <m1dnight> let me show you the output
04:35:46 <m1dnight> http://pastebin.com/Ba22Gpy0
04:35:47 <mauke> The paste Ba22Gpy0 has been copied to http://lpaste.net/97426
04:35:48 <m1dnight> this is what I get
04:37:46 * m1dnight tries 'cabal install snap' again :p
04:37:47 <silver> m1dnight, there should be a mechanism alowing to install your project (and it's dependencies) not in the system folders but in custom path/folder
04:38:55 <m1dnight> but, will that fix the package issue?
04:39:01 <m1dnight> reinstalling snap fucked it over once more :p
04:40:13 <silver> no it will not sadly
04:40:27 <m1dnight> damnit
04:41:02 <m1dnight> is there a way to completely remove every cabal thing?
04:41:05 <m1dnight> So i can start fresh?
04:41:07 <silver> you can make clean re-install of the platform though, if you don't have a lot of packages installed
04:41:26 * m1dnight is a linuxnoob AND a haskellnoob :)
04:42:25 <silver> did you use tour distro's package manager?
04:42:30 <silver> your*
04:43:03 <silver> I think all the packages might be in ~/.cabal or something, not sure though
04:43:37 <bennofs> silver: no, it's not ~/.cabal. You need to delete ~/.ghc if you want to reinstall all packages
04:43:52 <silver> oh yeah, right
04:45:43 <m1dnight> allright, .cabal and .ghc are gone
04:45:53 <danilo2> Hello! I'm trying to write something, which I've got working using (~) (by the way - how it is called in Haskell?), using type families. ( http://lpaste.net/97427 ) The (~) line is 22 and the type family is declared in 26. Is it even possible to get such behavior with type families?
04:46:00 <m1dnight> so first, I'll install the Haskell platform again?
04:47:12 <silver> basic system should be there (if platform/ghc was installed by package manager)
04:47:17 <m1dnight> ffs, apt-get says ghc is already installed
04:47:22 <bennofs> danilo2: I think you need a forall t1 t2. there
04:47:35 <silver> try ghc in command prompt
04:47:41 <silver> yeah that' right
04:47:45 <bennofs> danilo2: so it's type FuncType = forall t1 t2. t1 -> t2 -> (t1,t2)
04:47:58 <bennofs> danilo2: you might need to enable -XRankNTypes
04:47:59 <danilo2> bennofs: I've tried it: Illegal polymorphic or qualified type
04:48:15 <danilo2> bennofs: I think foralls are denied for type families, arent they?
04:48:23 <bennofs> seems so :|
04:48:24 <seanparsons> Is there a way of making ghc treat this as a compile error:
04:48:24 <seanparsons> True <- GLFW.init
04:48:24 <seanparsons> (GLFW.init returns IO Bool, so I want it to fail compilation if the value is False)
04:48:44 <seanparsons> "-W" seems to let this pass by without a care.
04:48:45 <danilo2> bennofs: rankNTypes does not help
04:49:18 <mcstar> GLFW.init is a run time action, how could you know what it 'returns' at compile time?
04:50:01 <danilo2> bennofs: I've updated the example, now it is simplier: http://lpaste.net/97427
04:50:02 <seanparsons> Well it's doing a pattern match on the left side (this is in a do expression), so I would've thought it would be able to check for that.
04:50:05 <mcstar> makes as much sense as static_assert(clock() == 5432142)
04:50:16 <silver> m1dnight, so you have removed all user packages and it might be fine now, try ghc-pkg check for example
04:51:09 <seanparsons> mcstar: If I were to do a pattern match in other situations this would be caught by GHC surely?
04:51:33 <mcstar> pattern matching can fail in any case
04:52:06 <seanparsons> mcstar: What does that even mean?
04:52:26 <mcstar> that you can write pure code that fails pattern matching
04:53:04 <mcstar> but what you want is semantically impossible...
04:53:16 <mcstar> see my c++ snippet up there
04:53:31 <seanparsons> Checking for exhaustiveness of ADTs is impossible?
04:53:47 <danilo2> Maybe I'll ask it once again: Is it possible to create polymorphic types using type families, like I'm trying to do in the line 30? (http://lpaste.net/97427)
04:54:34 <bennofs> danilo2: I don't think so. You'd have to use data families
04:54:34 <mcstar> i didnt say it was impossible, but in this case that is irrelevant
04:55:09 <danilo2> bennofs: data families? I didnt hear about them
04:55:10 <seanparsons> mcstar: It's not irrelevant to me.
04:56:12 <danilo2> bennofs: ahh data families!
04:56:33 <danilo2> bennofs: brb
04:57:38 <mcstar> seanparsons: are you aware that that pattern match cannot happen at compile time?
04:57:58 <seanparsons> mcstar: What do you mean?
04:58:06 <mcstar> i mean exactly that
04:58:35 <seanparsons> mcstar: Well thanks for not being any help whatsoever.
04:58:54 <mcstar> np, but i tried
04:59:19 <mauke> seanparsons: what do you mean?
04:59:30 <seanparsons> mauke: In relation to what?
04:59:53 <merijn> seanparsons: How could compilation fail when the value of GLFW.init is False?
04:59:57 <mauke> seanparsons: thanks for being no help
05:00:07 <merijn> seanparsons: How would the compiler know that value of GFLW.init?
05:00:22 <merijn> s/that/the
05:00:40 <seanparsons> I'm not saying that, I'm saying it's an incomplete pattern match on the left hand side of the arrow that I want to prevent.
05:01:11 <mcstar> that is not at all what you wrote perviously
05:01:19 <seanparsons> Ah, now that's my fault for not being very clear and I apologise.
05:01:34 <merijn> Oh, you mean "True <- GLFW.init"?
05:01:43 <merijn> -Wall doesn't catch that?
05:01:46 <seanparsons> merijn: Yup.
05:01:52 <seanparsons> Nope, lets it fly on through.
05:02:06 <mauke> it's not partial code
05:02:08 <bennofs> danilo2: But I think data families won't make it nice to use. You'd have to write something like member $ \(SomeConstructorHere x) -> now you can use x as the function
05:02:14 <seanparsons> Similarly there's "Just win <- GLFW.createWindow ...."
05:02:51 <mauke> @undo do { True -> GLFW.init; doStuff }
05:02:51 <lambdabot> <unknown>.hs: 1: 11:Parse error: ->
05:02:55 <mauke> @undo do { True <- GLFW.init; doStuff }
05:02:56 <lambdabot> GLFW.init >>= \ a -> case a of { True -> doStuff; _ -> fail ""}
05:04:09 <seanparsons> mauke: I understand that it's adding in the additional case to "handle" the remaining cases, I'd just like it to not do that! :)
05:04:18 <merijn> seanparsons: It's a rather common discussion whether "fail" should be removed from the Monad class or whether desugaring pattern matches should use fail or not
05:05:03 <danilo2> bennofs: it does not bother me much. It will be used in generated code only. I'm looking for the best way of expressing it :)
05:05:05 <merijn> seanparsons: The main solution to that is to not use pattern matches in "<-" do notation, I don't expect it to change anytime soon, due to the amount of bikeshedding
05:05:13 <mcstar> seanparsons: out of curiousity, what would you do, when GLFW.init fails?
05:05:18 <seanparsons> merijn: If this is just something I have to avoid writing myself then that's cool.
05:05:34 <m1dnight> silver: I removed ghc and cabal and just did a fresh install from apt-get (ghc, and then cabal-install)
05:05:38 <m1dnight> then I did a cabal-update
05:05:43 <m1dnight> now I'm doing cabal install snap again
05:05:47 <merijn> seanparsons: If you use GHC 7.6+ you could use LambdaCase
05:05:49 <seanparsons> mcstar: Well in that case it's something I'm expecting to happen because it's an IO instance.
05:06:05 <bennofs> Can I use .. as an operator?
05:06:14 <bennofs> > let (..) = id in id .. 3
05:06:15 <lambdabot>  <hint>:1:6: parse error on input `..'
05:06:22 <mcstar> i mean, what logical action would you take? try again? terminate the program?
05:06:23 <merijn> seanparsons: i.e. "GLFW.init >>= \case True -> something" <- this would be a warning "non-exhaustive pattern"
05:06:31 <merijn> bennofs: .. is syntax
05:06:48 <bennofs> Oh right
05:06:54 <bennofs> > let (...) = id in id ... 3
05:06:55 <lambdabot>  3
05:07:10 <seanparsons> mcstar: Well it would likely be terminating.
05:07:52 <mcstar> i think 'fail' will do that for you, though the reason might not be clear
05:08:01 <seanparsons> mcstar: But I suppose there's a difference between it returning False and an exception being thrown, in the False case there's likely to be something I can interrogate to figure out why that's the case.
05:08:26 <seanparsons> mcstar: Like I said later as well, there's a similar issue with createWindow too,
05:08:57 <danilo2> Can somebody outline me what is the difference between associated type families and associated data families? (the first one is declared like "class ... where data ..." and the second like "class ... where type ...")
05:09:36 <mauke> type is crazier
05:09:54 <bennofs> danilo2: associated data families have different constructors each time
05:09:57 <mauke> data forces you to define a new type
05:10:13 <hpk> i am trying to play with https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/tagsoup -- but it's not clear to me which packages i need to install in order to do that tutorial.  Any hints?
05:10:15 <seanparsons> mcstar: In that case there's likely to be options that can be tweaked so that it succeeds, it's nice for the compiler to stop me doing something that can obviously fail.
05:11:34 <bennofs> hpk: I guess http-conduit and xml-conduit?
05:11:59 <hpk> bennofs: tried that but still get "cannot find module `Text.HTML.DOM`"
05:12:20 <hpk> i feel like i am missing something -- a tutorial should say which modules to install, no?
05:12:30 <danilo2> bennofs, mauke: Ok, thanks. I'm testing this stuff, brb :)
05:12:32 <bennofs> hpk: that module is in http-conduit
05:12:45 <bennofs> hpk: http://hackage.haskell.org/package/html-conduit-1.1.0.1/docs/Text-HTML-DOM.html
05:13:03 <mauke> danilo2: generally, type families is the one that causes ambiguity errors you don't understand
05:13:56 <danilo2> mauke, but type families are better than functional dependencies + UndecidableInstances ?
05:14:03 <hpk> bennofs: thanks.  I re-installed http-conduit, and now get "could not find module `Text.XML.Cursor`.
05:14:24 <bennofs> hpk: that module is in xml-conduit
05:14:52 <lingxiao> Morning All!
05:15:12 <hpk> bennofs: is there a page/easy way to find out what comes from where?
05:15:22 <lingxiao> Has anyone went through "TypingHaskellInHaskell" and could explain to me what section "11.4 Alternatives" is all about?
05:15:36 <bennofs> hpk: try hayoo or hoogle
05:15:37 <m1dnight> silver: I still get the errors...
05:15:39 <bennofs> @where hayoo
05:15:39 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html – See also Hoogle: http://haskell.org/hoogle
05:15:41 <lingxiao> as in, what syntax construct in haskell does "Alternatives" refer to?
05:15:41 <bennofs> @where hoogle
05:15:41 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
05:15:47 <m1dnight> ffs why can't it just work
05:16:30 <hpk> bennofs: so now i am doing "cabal install xml-conduit http-conduit" -- hope that allows to run things in the end. (Installing one by one tells me to reinstall things).
05:16:59 <hpk> is there a difference between "cabal install X" and "cabal install Y" as opposed to "cabal install X Y"?
05:17:42 <bennofs> hpk: Yes, the 3rd form allows cabal to know what you want to install ahead of time and might improve dependency resolution
05:18:03 <hpk> but effectively it should end in the target state?
05:18:05 <bennofs> hpk: What version of cabal are you using, btw? (cabal --version to check)
05:18:23 <hpk> 0.14.0 (using version 1.14.0 of the cabal lib)
05:18:34 <hpk> coming from Ubuntu 12.04 LTS
05:19:18 <danilo2> mauke, bennofs: Maybe I'll ask you about what I'm trying to solve? I've got a code: http://lpaste.net/97430 (which mimics an OO behaviour - I can call functions "by name" based on types - it is for my DSL lang). I'm wondering if I can replace anything with f.e. type families to make the type checker check more things
05:19:51 <danilo2> mauke, bennofs: I have heard that type families are a lot better than fundeps and a lot of effort was put to make them better, so I was thinking it would be better to use them isntead?
05:20:08 <bennofs> hpk: Then you should probably upgrade cabal. afaik newer versions (0.16 or 0.18) have better dependency resolution solutions. Also, you get cabal sandboxes if you use 0.18 (a new feature that is useful when you start using more than a few packages)
05:20:41 <hpk> bennofs: thanks, will see to upgrade and maybe find another tutorial.  I'd really like to get something running and play around to get a feel/hands on with the language.
05:21:24 <bennofs> hpk: well, the brute force method is to delete ~/.ghc (are you on linux?) and try cabal install xml-conduit http-conduit again.
05:21:29 <hpk> sidenote: i often saw examples on the web so far that gave no indication what the perequisites are -- which seems like a must for someone new to the ecosystem
05:21:53 <hpk> bennofs: ok, will try that as well.  sandboxing (like python's virtualenv i guess) also sounds good.
05:23:18 <m1dnight> hmm haskell platform fails to install as well
05:23:28 <m1dnight> i might just format my ubuntu for this one :p
05:23:59 <mcstar> you would learn nothing from that
05:24:08 <m1dnight> that is correct
05:24:11 <bennofs> m1dnight: what did you do / what problem do you have?
05:24:13 <m1dnight> but I would be able to get started :p
05:24:29 <m1dnight> well I'm taking a haskell course. I have to work in the snap framework.
05:24:41 <m1dnight> My haskell stuff keeps throwing errors in my face
05:24:44 <m1dnight> So from that point
05:24:46 <bennofs> Btw, there is ppa providing GHC 7.6 (current stable) and cabal 1.18 on https://launchpad.net/~hvr/+archive/ghc
05:24:56 <m1dnight> sudp apt-get remove cabal-install ghc
05:25:04 <m1dnight> removed .cabal and .ghc
05:25:18 <m1dnight> so that's clean, I guess?
05:25:29 <m1dnight> then I tried apt-get install ghc, apt-get install cabal-install
05:25:40 <bennofs> and what do you want to install with cabal install?
05:25:42 <m1dnight> thanI tried the haskell platform (for all the packages?) using the build from source method
05:25:50 <m1dnight> nothing, just installed cabal from my package manager?
05:26:02 <m1dnight> and now that is giving me errors as well (build from source)
05:26:16 <bennofs> m1dnight: what are those errors?
05:26:42 <merijn> I think this is one of those "Ubuntu shipping ridiculously old things" problems
05:26:56 <m1dnight> Error:
05:26:57 <m1dnight> Building the HUnit-1.2.5.2 package failed
05:26:57 <m1dnight> make: *** [build.stamp] Error 2
05:27:01 <m1dnight> that's the haskell package problem
05:27:06 <mcstar> (is haskell-platform necessary, when you already have cabal installed?)
05:27:08 <Tekmo> merijn: Do you still need help with the pipes parser?
05:27:26 <bennofs> m1dnight: You could try to add the PPA https://launchpad.net/~hvr/+archive/ghc and install ghc-7.6.3 and cabal-install-1.18
05:27:57 <m1dnight> okay so first i do apt-get remove everything, and the directories in ÃÂ·~/, right?
05:28:03 <m1dnight> or do I have to delete more stuff?
05:28:22 <merijn> Tekmo: Hey! I redid the entire thing without the double pipe, but that requires some annoying hoisting and/or RankNTypes, so if you have a sec to take a look and see if you have any recommendations I'd be grateful
05:28:38 <Tekmo> merijn: Show me what you have
05:28:45 <bennofs> m1dnight: yes, rm -r ~/.cabal and rm -r ~/.ghc and apt-get remove everything should be enough
05:28:47 <hpk> bennofs: removed .ghc/ and "cabal install xml-conduit http-conduit" produces a "could not find module `Text.HTML.DOM`".  Am going to upgrade now to the PPA you mentioned and see how that goes.
05:28:58 <merijn> Tekmo: http://lpaste.net/2323380747957698560
05:29:10 <hpk> bennofs: ("ghc parse.hs" produces the could not find module to be precise)
05:29:31 <bennofs> hpk: could you paste the output of ghc-pkg list ?
05:29:34 <bennofs> @where lpaste
05:29:35 <lambdabot> http://lpaste.net/new/haskell
05:30:16 <merijn> Tekmo: Since my Producers/Consumers are implemented in a way that's independent of the underlying monads I can avoid most of the hoists, but that requires annotating every single Pipe argument as "forall m r . Consumer Foo m r", which makes the types rather intimidating
05:30:37 <merijn> Tekmo: OTOH, I'm not sure whether the hoisting has a performance price compared to RankN Consumer/Producer
05:31:57 <Tekmo> merijn: So I have a question.  For your protocol, is your handshake always going to be outputting `ByteString`s before authentication is complete and only `Frame`s after authentication completes?
05:32:53 <merijn> Tekmo: Yes. The only reason I have ByteString at first is because the authentication/handshake decide which Frame decoder I have to use
05:33:33 <hpk> bennofs: installing from that PPA gives me ghc-7.4 -- i guess it's the best fit for my ubuntu system or so, hoped for 7.6 though)
05:33:35 <merijn> Tekmo: And the handshake itself interleaves writing/reading, but afterwards sends and receives are completely independent
05:33:59 <merijn> Tekmo: I just noticed I'm missing some types for the authenticate/zmtpVersion, I'll add those too
05:34:24 <bennofs> hpk: you need to install the package "ghc-7.6.3"
05:34:54 <hpk> bennofs: ah! thanks again.  that works now.
05:35:06 <bennofs> hpk: then your ghc executable will be in /opt/ghc/7.6.3/bin/ghc
05:35:20 <FreeFull> :t dimap words unwords
05:35:21 <lambdabot> Profunctor p => p [String] [String] -> p String String
05:35:32 <hpk> bennofs: is it enough to add it to PATH?
05:35:36 <bennofs> hpk: yes
05:35:43 <merijn> Tekmo: Added the missing types at the bottom: http://lpaste.net/2323380747957698560
05:36:03 <FreeFull> :t dimap words unwords (intercalate '!')
05:36:04 <lambdabot>     Couldn't match type `Char' with `String'
05:36:04 <lambdabot>     Expected type: [String] -> [String]
05:36:04 <lambdabot>       Actual type: [[Char]] -> [Char]
05:36:16 <bennofs> hpk: you need to add /opt/ghc/7.6.3/bin to the PATH (I told you the path of the executable :p)
05:36:24 <hpk> bennofs: of course.
05:36:51 <FreeFull> :t dimap words unwords (intersperse "!")
05:36:52 <lambdabot> String -> String
05:36:53 <m1dnight> bennofs: I've added the repo. Do i have to say it has to install ghc and cabal from that repo? or how do I do it?
05:36:54 <hpk> bennofs: i kind of now my way around linux and other programming langs, but want to play with haskell and see if i can get productive with it.
05:36:57 <merijn> Tekmo: So essentially ZmtpVersion is interleaved reads/writes to figure out the version (and thus decoder/encoder), then there's an authentication interleaves reads/writes (using Frame), after that I have two independent read and write streams reading from and writing to the socket
05:37:02 <FreeFull> > dimap words unwords (intersperse "!") "Hello world yay"
05:37:05 <lambdabot>  "Hello ! world ! yay"
05:37:13 <m1dnight> make: *** [build.stamp] Error 2W: Failed to fetch https://launchpad.net/~hvr/+archive/ghc/dists/saucy/main/binary-amd64/Packages
05:37:16 <m1dnight> make: *** [build.stamp] Error 2W: Failed to fetch https://launchpad.net/~hvr/+archive/ghc/dists/saucy/main/binary-amd64/Packages
05:37:19 <m1dnight> hmmm, not working as well
05:37:58 <m1dnight> oh nvm, was my bad
05:39:05 * hpk feels for the first in a long time like wanting to have more CPU power (for compiling/installing haskell modules)
05:39:18 <Tekmo> merijn: So I take it you are using the `StateT Bytestring` layer for leftovers?
05:39:50 <m1dnight> pfff fialed to fetch some stuff AGAIN
05:39:53 <m1dnight> im dying here :p
05:40:01 <bennofs> m1dnight: I think it's only for Ubuntu precise
05:40:08 <m1dnight> Which OS should I take then, bennofs ?
05:41:05 <merijn> Tekmo: Yeah, I have a simple "Get a -> Effect (StateT ByteString m) a" parser and use the ByteString for leftovers. Then in session I "runStateP empty" the handshake and use the leftovers as initial input to the reading thread (i.e. "yield rest >> cat")
05:41:14 <implementation> when trying that: http://paste.lisp.org/display/140654, ghc complains about a functional dependencies conflict between the second and the third instance. i can't figure out the reason. To me m() and a->t look definitely distinguishable. Anyone got an idea?
05:41:40 <Tekmo> merijn: Have you followed my recent work on `pipes-parse` (it's okay if the answer is "no")?
05:41:44 <bennofs> m1dnight: sorry, I just noticed that saucy has already a pretty new GHC / cabal-install version.
05:41:51 <merijn> implementation: It helps to pastebin the error
05:42:06 <bennofs> m1dnight: I don't understand why the haskell platform doesn't compile through.
05:42:58 <m1dnight> Me neither :)
05:43:04 <m1dnight> maybe try a virtual machine
05:43:10 <Clint> Tekmo: so if lifted-base is the wrong way, how should i get a finally/bracketOnError that work with EitherT?
05:43:11 <mauke> implementation: let m = (->) a, t = ()
05:43:13 <bennofs> m1dnight: You could also just install the packages you need from hackage
05:43:23 <mauke> implementation: now m () = a -> t
05:43:30 <bennofs> mauke: That's what I've been doing, and it worked pretty well for me (I didn't use haskell platform)
05:43:40 <merijn> Tekmo: I looked at pipes-parse, yeah. But I had difficulty actually using the "StateT (Producer a m) m r" (or whatever it was exactly, I'm transcribing from memory :) approach and I figured that given the simplicity of my parsing needs it was simpler to just write one myself
05:43:57 <hpk> bennofs: success.  i also needed to install html-conduit (and i guess it depends on xml-conduit).
05:44:36 <hpk> bennofs: thanks again.  Still don't get why the simple "perequisites: cabal install ..." is missing from the tutorial.  it's not obvious at all to me.
05:44:52 <implementation> mauke: ((->) a) may be a monad, but it's not an instance of MonadPrinter, thus it's an impossible case
05:44:59 <Tekmo> merijn: The reason I ask is because what you are doing is very similar to the `StateT (Producer am) m r` approach
05:45:12 <Tekmo> merijn: ... except that you are doing the state passing explicitly
05:45:19 <mauke> implementation: I haven't looked at your code but generally that doesn't matter
05:45:35 <zett_zelett> Isn’t there a function which takes two functions f :: a -> b, g :: c -> d and builds their product f×g :: (a,c) -> (b,d)?
05:46:05 <Tekmo> Clint: So when you say "work with EitherT" do you mean that exception handling is still done in `IO` but you are just lifting it over `EitherT`?
05:46:22 <m1dnight> i'm going to try in a VM
05:46:25 <m1dnight> then I can reset it with snapshots
05:46:30 <m1dnight> i just want to start asap on that fucking project :p
05:46:38 <merijn> Tekmo: Yeah, that was mostly the inspiration :) I just didn't really see how to fit it in the rest of the code with the Producer inside the StateT
05:47:07 <Tekmo> merijn: There's one major difference from previous versions of `pipes-parse` in my latest work
05:47:26 <Tekmo> merijn: You no longer hav something of type: `Pipe ... (StateT (Producer ByteString) m) r`
05:47:43 <Tekmo> merijn: The latest stuff is done so that you always have `StateT` on the outside with no `Pipe` layer at most
05:47:55 <merijn> Yeah, that's the one I looked at
05:49:58 <Tekmo> merijn: Side note, I think you can use `bracketOnError` instead of having a `catch` clause inside of your `bracket`
05:50:52 <Tekmo> merijn: Also, you can use the `async` package to simplify your threaded code
05:51:34 <Tekmo> merijn: So where is the part where you have the most problems right now?
05:51:47 <merijn> Tekmo: But I ran into problems given the polymorphic use of my Producers/Consumers. But I guess that's less of a problem now that I rewrote the code. I actually think it looks decent now. The two main "problems" I have with this implementation is 1) the hoisting in handshake and 2) the explicit passing of rest in 'session'.
05:52:32 <merijn> Tekmo: I initially wanted to "preload" the remainder into the decoder pipe returned by handShake, but I couldn't figure out a good way to do that
05:53:25 <merijn> Tekmo: Yeah, I know about async, but I'm doing quite a bit of low-level thread management myself already. I think async would get in the way with the amount of control I want over the threads
05:53:51 <Tekmo> merijn: Can't you just use `get` to retrieve the current leftovers, use `put` to empty the leftover buffer, and then add the leftovers to the returned decoder?
05:53:55 <Tekmo> merijn: In other words:
05:54:15 <implementation> mauke: Do you have an alternative idea to extend printf such that it supports more return types without modifying the original code? The main problem is that the method required for implementing Printfype is not exported...
05:54:21 <ocharles> Always good to see 'cabal: Prelude.last: empty list' when I do 'cabal upload' :(
05:54:37 <merijn> Tekmo: Yeah, but then it looks like "rest <- get; return ((yield rest >> cat) >-> decoder, encoder)", I thought the explicit passing was less horrific then that
05:54:39 <Tekmo> merijn: bs <- get; put empty; return (yield bs >> decoder, encoder)
05:54:54 <Tekmo> Oh yeah, it's a pipe, not a producer
05:55:30 <Clint> Tekmo: i'm doing `finally` and bracketOnError in a newtyped EitherT e (StateT s m) a, with orphaned monad-control instances
05:55:51 <merijn> Tekmo: But if you don't see any massive flaws in this version, I think I'm actually kinda happy with it
05:56:12 <Tekmo> merijn: I can recommend a way to remove the hoists
05:56:28 <Tekmo> merijn: Just put the `ReaderT` and `StateT` layers on the outside and then just run the immediately before composing your pipe
05:58:22 <Tekmo> merijn: Other than the custom leftovers solution I don't see any flaws.  You did the right thing by returning the encoder and decoder from the pipe
05:58:34 <Tekmo> merijn: I can recommend another way to simplify the handShake type
05:58:44 <merijn> Tekmo: hmm, lemme see if I can figure it out with the StateT on the outside
05:58:46 <Tekmo> merijn: Usually when I have a large return type like that I bundle it into a record
05:59:36 * hackagebot snap-cors 1.1.0 - Add CORS headers to Snap applications  http://hackage.haskell.org/package/snap-cors-1.1.0 (OliverCharles)
05:59:42 <merijn> Tekmo: Yeah, normally I do that too, but since the type won't be publically exposed or used outside of this module that didn't seem worth the effort :)
05:59:49 <Tekmo> merijn: Alright
05:59:57 <d3lxa> has anyone tested lenses with persistent, there is a fieldLens function (not sure how it works?)
06:03:23 <Tekmo> Clint: So what happens if you call `finally` using `lifted-base` and the `EitherT` aborts with a `Left`.  Does it still finalize the resource properly?
06:04:10 <mm_bureau> Tekmo: btw, is there a reason you wrote SafeIO instead of using ResourceT?  what are the differences?
06:04:18 <klrr_> anyone written a instance of ToJSON/FromJSON for IntMap?
06:04:42 <mm_bureau> klrr_: if there is one for Map, you can probably copy it almost verbatim
06:04:51 <klrr_> true
06:04:58 <klrr_> gonna read the code then
06:04:58 <Tekmo> mm_bureau: When I initially wrote `pipes-safe` it had some different features from `resourcet`.  Over time it evolved to something very similar.
06:05:09 <m1dnight> hrm, I cleaned it once more, did ghc install and now I want to install haskell platform. This now tells me that it needs zlib. So I try cabal install zlib but that fialed "in the configure step"
06:05:13 <merijn> Tekmo: If having transformers are going to be commonly used on the "outside" of a stack using Proxy, would it be an idea to have an mtl style "MonadProxy" class that has auto lifted versions of things like yield/await?
06:05:13 <m1dnight> any clues
06:05:16 <m1dnight> ?
06:05:24 <Tekmo> mm_bureau: Right now, though, I'm working on a slightly different tack in order to improve promptness of resource release
06:06:03 <Tekmo> merijn: That's basically what the `Proxy` type class from `pipes-3.*` was.  However, it was more trouble than it was worth
06:06:47 <klrr_> http://hackage.haskell.org/package/aeson-0.2.0.0/docs/src/Data-Aeson-Types.html#FromJSONhttp://hackage.haskell.org/package/aeson-0.2.0.0/docs/src/Data-Aeson-Types.html#FromJSON anyone know what transformMap comes from? cant find docs on hoogle or google
06:06:49 <Tekmo> merijn: Right now the recommended way is that if you don't want to run the non-pipe layers, then just put them on the inside and use `Pipes.Lift` operations to run them
06:07:00 * conceptualHygene is compiling the haskell platform
06:07:02 <klrr_> use ctrl+f to search for "transformMap" to see where its used
06:07:58 <Tekmo> conceptualHygene: I think it's an internal `aeson` function
06:08:04 <mm_bureau> may i use / to search?
06:08:25 <merijn> Tekmo: Actually, if I change handShake to have "StateT ByteString" on the outside, I have a problem implementing line 68 and 70 in session, don't I?
06:08:36 <conceptualHygene> Tekmo: What?
06:08:38 <m1dnight> okay, 'apt-get zlib1g-dev' works.. lets hope that fixes it
06:09:10 <Tekmo> conceptualHygene: I couldn't find `transformMap` on either Hoogle or Hayoo, so I think it's a function imported from another internal `aeson` module
06:09:15 <mm_bureau> Tekmo: klrr_
06:09:44 <klrr_> mm_bureau: what u mean?
06:10:00 <mm_bureau> klrr_: i'm sure Tekmo's message was for you instead of conceptualHygene =)
06:10:12 <klrr_> aaa thanks for highlighting then!
06:10:22 <klrr_> Tekmo: okey thanks, will dig more into its source then
06:10:41 <Tekmo> merijn: Wouldn't you just do: handshake = fromNetwork >-> flip runStateT empty (flip runReaderT cfg handShake) >-> toNetwork ?
06:10:42 <conceptualHygene> Tekmo: I don't know what that is :C
06:10:59 <mm_bureau> conceptualHygene: i'm sure Tekmo's message was for klrr_ instead of you =)
06:11:04 <Tekmo> conceptualHygene: Ooops
06:11:10 <Tekmo> conceptualHygene: I meant to reply to klrr_
06:11:37 <merijn> Tekmo: Yeah, I just realised after typing that :)
06:12:16 <merijn> I just ran the State and Reader in the wrong order >.>
06:12:51 <mm_bureau> that's the advantage of MonadReader and MonadState over Reader and State…  you can't really run in the wrong order =)
06:13:24 <merijn> On the upside, my pipes rewrite is paying off. I just changed the parsing implementation to have StateT on the outside and only had to touch a minimal amount of code to accomodate the new implementation. The pre-pipes version would have to be mostly rewritten
06:13:34 <merijn> mm_bureau: Eh, yes you can
06:14:09 <merijn> mm_bureau: MonadReader and MonadState don't provide generalised running functions
06:14:34 <mm_bureau> merijn: (MonadReader X m, MonadState Y m) => m Integer
06:14:37 * hackagebot data-size 0.1.1.4 - Profiling of data structures  http://hackage.haskell.org/package/data-size-0.1.1.4 (UweSchmidt)
06:15:11 <mm_bureau> merijn: both 'flip evalState y . flip runReader x' and 'flip runReader x . flip evalState y' work
06:15:51 <Taneb> I've kind of wrote myself in a hole, because Haskell's the language I know best, so now I'm trying to translate some of my Haskell code into Python
06:15:58 <mm_bureau> uhm, +T
06:16:13 <Taneb> Except I'm using StateT (WriterT []) and I don't know if it is possible
06:16:40 <Tekmo> Taneb: It is possible.  What is the problem?
06:17:04 <Tekmo> Taneb: The type should be something more like `StateT s (WriterT [a] m) r`
06:17:09 <Taneb> Well, yeah
06:18:05 <conceptualHygene> I'm following http://learnyouahaskell.com/introduction#so-whats-haskell :D
06:18:29 <Taneb> Tekmo, it's just not-obvious how to do the backtracking with state efficiently in Python
06:18:46 <matpat> is there any specific reason why GHCI does not use defaulting for partially applied MultiParam type classes? http://lpaste.net/97432
06:18:55 <Clint> Tekmo: yes, it does
06:18:58 <Tekmo> Taneb: Are you sure you don't actually want the `StateT s []` monad?
06:19:28 <Tekmo> Taneb: I know you're trying to write it in Python, but I just want to make sure I understand what your Haskell version is doing
06:20:12 <merijn> mm_bureau: That's because in that version you never specify the monad stack
06:20:34 <Taneb> Tekmo, http://lpaste.net/97433
06:20:36 <merijn> mm_bureau: I *have* to specify the reader/state order at some point, because some parts of my code aren't both
06:20:45 <merijn> mm_bureau: So if they're in the wrong order that won't work
06:20:53 <Taneb> Tekmo, it's for an AI for a battleships-like game
06:21:03 <augur> Taneb: you could probably use continuations to do your pythonian backtracking
06:22:02 <Taneb> augur, that sounds... does Python have continuations?
06:22:16 <augur> it has lambdas doesnt it?
06:22:32 <Taneb> Yes, but...
06:22:38 <augur> well then!
06:22:42 <Taneb> I don't really understand continuations :(
06:22:47 <augur> ahhh well then. :)
06:23:00 <klrr_> is there any read and show functions for Int -> Text and vice versa?
06:23:15 <geekosaur> er? you want to show a function?
06:23:30 <bennofs> geekosaur: I think he wants read and show for Text
06:23:35 <ion> Text.pack . show
06:23:36 <Hafydd> Python "has" continuations, but I'm not sure how much you can rely on last call elimination.
06:23:44 <mcstar> python has push and pull style coroutines
06:23:54 <geekosaur> bennofs, probably, but that's not what they asked for...
06:24:12 <zett_zelett> How is `[1..]' implemented in Haskell?
06:24:17 <m1dnight> anybody here used the snap init tutorial website yet?
06:24:23 <augur> i dont mean native continuations, but you might be able to do it with them
06:24:28 <ion> zett_zelett: That’s syntactic sugar for enumFrom 1
06:24:34 <m1dnight> i think ive got evrything  setup, but the website doesnt do anything.. (it should do some stuff afaik)
06:24:44 <augur> i just mean thunks as continuations
06:24:53 <geekosaur> zett_zelett, [x..] is enumFrom, [x..y] is enumFromTo, [x, y..] is enumFromThen, [x, y .. z] is enumFromThenTo
06:25:31 <geekosaur> all defined as part of the Enum typeclass http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.1.1.0/Prelude.html#t:Enum
06:25:33 <ion> zett_zelett: You can find implementations of enumFrom with a hoogle search.
06:26:05 <augur> Taneb: ill give you a hint in the right direction: haskell can do this stuff nicely because of laziness, but one way to code up laziness is with thunked values, e.g. you might define an infinite list type in an eager language as   data List a = Nil | Cons a (() -> List a)
06:26:41 <augur> defining head as usual, and tail as  tail (_ : xs) = xs ()
06:26:45 <Taneb> augur, thank you, and I think Python does have lazy lists?
06:26:48 <zett_zelett> Thanks.
06:26:58 <mcstar> but why not use generators?
06:27:03 <Taneb> Actually, I'm using Python 2, I don't know if it does
06:27:03 <mcstar> they are powerful
06:27:10 <Tekmo> mcstar: Generators are not sufficient, though
06:27:20 <Tekmo> mcstar: He needs to simulate a backtracking list monad
06:27:31 <augur> Taneb: you need to have lazy appends and such. the key point tho is to understand what the thunk is affording you in that presentation
06:27:32 <Tekmo> mcstar: Generators only buy you the laziness, but not the backtracking
06:27:41 <mcstar> but they work both ways wrt. information flow
06:28:18 <Tekmo> So my understanding is that the idiomatic way to do a backtracking search in a language without monads is to just keep a stack of states
06:28:25 <augur> Taneb: anyway, good backtracking should be done using some kind of nice little EDSL that uses thunks/continuations
06:28:33 <geekosaur> klrr_, in any case Data.Text has both Read and Show instances which should do the right thing
06:28:45 <Taneb> augur, unfortunately, I want my Python to be readable to someone whose first language is C++
06:28:51 <augur> Tekmo: yes, thats one way to reify the control flow into a data structure
06:29:02 <merijn> Taneb: "first language is C++" <- so anything goes?
06:29:27 <ion> geekosaur: He meant Show a => a -> Text
06:29:30 <mcstar> python is executable pseudocode, or so they say
06:29:39 <augur> Taneb: my suggestion is to write a little library
06:29:43 <merijn> FWIW, I've been preemptively banned of ever writing C++ by my colleagues for fear of Lovecraftian horrors of code
06:30:03 <Taneb> augur, I'm not in a position to do that. It's for a competition with somewhat restrictive rules.
06:30:05 <geekosaur> that sounds like C++ template code, what's the problem? :p
06:30:20 <augur> Taneb: what makes that prohibited?
06:30:29 <Tekmo> So the issue with doing the continuation approach is that it just becomes one giant function, which is very ugly in a language without something like `do` notation
06:30:47 <augur> Tekmo: eh, it depends on the task.
06:31:10 <Taneb> augur, I have to stick to a single file
06:31:24 <klrr_> anyone know why i get this type error? https://gist.github.com/klrr/8097890
06:31:28 <augur> Taneb: thats fine, you can write the "library" in a handful of functions
06:31:41 <Taneb> Also, I think I can do something with itertools
06:31:44 <klrr_> im trying to convert a IntMap into a Aeson Object
06:31:46 <Taneb> Thanks, everyone :)
06:32:20 <augur> Taneb: the big one being something like    lazychoice mx f = case x of { Just x -> x ; Nothing -> f () }
06:32:49 <Tekmo> klrr_: I was able to compile it just by adding an `import qualified Data.Text as T` line
06:33:05 <klrr_> Tekmo: strange
06:33:10 <augur> Taneb: and every time you have multiple options, you lazychoice over the first one, and a recursive call to the function generating the options
06:33:18 <klrr_> (enabled it here too just forgot to put in paste)
06:33:48 <Tekmo> klrr_: My guess is that your program is importing two packages, each of which depends on a separate version of `unordered-containers`
06:33:57 <augur> Taneb: something like    go [] = Nothing ; go (c:cs) = lazychoice (doSomethingWith c) (\() -> go cs)
06:34:02 <Tekmo> klrr_: The easiest way to diagnose this problem is to type `ghc-pkg list | grep unordered-containers`
06:34:14 <geekosaur> that, or there's a difference between lazy and strict hashmaps
06:34:34 <augur> thats a fairly standard way to do this sort of thing that should be in every eager programmer's toolkit
06:34:39 <klrr_> Tekmo: i got two version installed
06:35:19 <Tekmo> klrr_: Did you install the Haskell Platform before installing other packages?
06:35:52 <klrr_> Tekmo: i install ghc and such from my distributions repos (ubuntu 13.04
06:36:01 <mcstar> Taneb: maybe this can help http://rosettacode.org/wiki/N-queens_problem#Python
06:36:15 <Tekmo> klrr_: So Ubuntu has a package called `haskell-platform` which you can install
06:36:26 <Tekmo> klrr_: It's a good idea to install that before installing any other packages
06:36:42 <mcstar> (the diff. between the last 2 solutions is the parens)
06:36:59 <Tekmo> klrr_: Are you using `cabal` to get package or your repo?
06:37:08 <klrr_> Tekmo: cant actually remember if i installed ghc indicudually or the HP-package but i certainly installed haskell the first thing i did after upgradeing from 12.04
06:37:21 <klrr_> cabal
06:37:33 <klrr_> (but i use apt-get for some packages like sdl)
06:37:45 <augur> oh btw, Taneb, the thing i described is listed on mcstar's page in the standard ML implementation as failure continuations
06:38:06 <Tekmo> klrr_: What works best for me is to use the repo to install everything up to the haskel platform, but then only use `cabal` for everything past that point
06:38:12 <klrr_> Tekmo: isnt there a way to blacklist vesrions of librarys with some commandline option to ghc?
06:38:28 <augur> specifically, the try function with has the form   fun try j = ... addqueen(..., ..., fn() => try (j + 1))
06:38:59 <Tekmo> klrr_: So the next thing you should check is to see which versions of `unordered-containers` come from your global package database or from your local package database
06:39:11 <Tekmo> klrr_: If you type `ghc-pkg list` it will show two groups of packages
06:39:28 <augur> addqueen itself is defined to do the kind of conditional stuff that lazychoice did in my example
06:39:29 <Tekmo> klrr_: The first group of packages is your global package database and the second group is your local package database
06:39:41 <augur> i think factoring out that sort of behavior is preferable tho
06:39:42 <Tekmo> klrr_: Check to see which database each version belongs to
06:41:53 <augur> i think your best bet is to try to factor out all of the backtracking junk into a handful of combinators so you can keep the code simple. backtracking is an implementational issue that shouldnt get in the way of expressing the idea
06:42:12 <geekosaur> klrr_, you can't blacklist one but you can specify one to use (-package unordered-containers-x.y.z)
06:42:41 <geekosaur> but in general you're asking for trouble when you have multiple versions of something installed (sadly)
06:42:50 <geekosaur> ghc doesn't handle this very well
06:43:23 <klrr_> Tekmo: okey thanks! geekosaur: that was what i looked for
06:43:30 <LuxuryMode> I don't get this: if S and T are sets, the cartesian product S x T has two projection functions proj1: S x T ->  S and proj2: S x T -> T. The functions are surjective is S and T are both nonempty. How do we know they're surjective?
06:43:58 <quchen> Not Haskell.
06:44:56 <LuxuryMode> Eh?
06:45:17 <lingxiao> Tekmo: if you have a moment, can I ask if you've implemented some simply-typed lambda calculus in haskell, and have some lessons/resources to share?
06:45:19 <augur> LuxuryMode: where is this coming from?
06:45:27 <Tekmo> lingxiao: I have not, unfortunately
06:45:32 <LuxuryMode> This is a point that is preliminary to category theory so I figured this would be a good place to ask.
06:45:35 <lingxiao> Tekmo: ok all good, thank you!
06:45:41 <Tekmo> lingxiao: You're welcome!
06:45:47 <augur> LuxuryMode: you could also try ##categorytheory :)
06:45:52 <LuxuryMode> augur coming from Barr and Wells book on category theory
06:46:01 <LuxuryMode> augur did not know there was such a channel!
06:46:03 <LuxuryMode> thanks
06:46:03 <augur> :)
06:46:09 <Tekmo> lingxiao: However, I may be able to dig up some resources.  One second
06:46:16 <LuxuryMode> uh
06:46:51 <LuxuryMode> augur hehe you would know about that, since you started that channel :)
06:47:06 <augur> it was a community effort
06:47:38 <LuxuryMode> all that matters in the end is who set the topic
06:47:45 <LuxuryMode> everyone else's efforts matter not
06:47:52 <LuxuryMode> jk
06:48:59 <klrr_> how would i write a instance of ToJSON for a type that is "ToJSON a => Foo a"?
06:49:19 <klrr_> (i know how to write the instance itself but not the "instance blabalb where ..."
06:49:23 <Tekmo> lingxiao: So you might want to read this: http://www.andres-loeh.de/LambdaPi/LambdaPi.pdf
06:49:35 <Taneb> On a completely different note, are there any libraries for distributed computing in Haskell/
06:50:36 <Taneb> Oooh, Cloud Haskell is a thing
06:50:39 <klrr_> nvm figured out :)
06:51:54 <merijn> The dependency of network on Parsec seems a bit overkill
06:52:04 <mcstar> there is an mpi binding i think
06:52:48 <lingxiao> Tekmo: ok awesome, exactly the kind of papers I'm looking for
06:52:49 <lingxiao> thanks!
06:52:55 <Tekmo> You're welcome!
06:54:01 <merijn> Does windows still need withSocketsDo?
06:58:15 <geekosaur> it is known to fail without it, yes
06:58:40 <geekosaur> or if you do things like wrap each use of a socket in withSocketsDo and expecting the socket to remain valid between them
06:59:04 <klrr_> is the instance ToJSON a >= ToJSON (Maybe a) not total? i get a error when i do "toJSON Nothing"
07:00:03 <geekosaur> what error? sure it's not just unable to figure out what type you intended?
07:00:18 <Tekmo> merijn: Yes
07:00:46 <merijn> Unfortunate, oh well, I'll just reexport it then
07:01:17 <klrr_> geekosaur: okey i needed type annotations :) thanks
07:01:26 <bennofs> m1dnight: did you solve your snap problem?
07:06:21 <fredmorcos> I've written a monad Parser a = Parser (String -> Either String (a, String)).. now i'd like to add line and column tracking...
07:06:30 <fredmorcos> is it better to have (String, Int, Int) -> (Either (String, Int, Int) (a, String, Int, Int)
07:06:51 <fredmorcos> or String -> Int -> Int -> Either (String, Int, Int) (a, String, Int, Int)?
07:07:18 <fredmorcos> or is it a matter of preference... and why?
07:07:21 <bennofs> fredmorcos: you can easily convert between the two with uncurry3 / curry3
07:07:25 <bennofs> @ty uncurry3
07:07:26 <lambdabot>     Not in scope: `uncurry3'
07:07:26 <lambdabot>     Perhaps you meant `uncurry' (imported from Data.Tuple)
07:07:32 <bennofs> @hoogle uncurry3
07:07:34 <lambdabot> No results found
07:07:43 <bennofs> hmm, I thouh
07:08:11 <fredmorcos> so it's basically a matter of preference?
07:08:14 <bennofs> yes
07:08:18 <fredmorcos> in case I implement uncurry3
07:08:27 <fredmorcos> Alright.. thanks!
07:08:29 <bennofs> @ty \(x,y,z) f -> f x y z
07:08:29 <lambdabot> (t1, t2, t3) -> (t1 -> t2 -> t3 -> t) -> t
07:09:10 <bennofs> @ty \f (x,y,z) -> f x y z
07:09:11 <lambdabot> (t1 -> t2 -> t3 -> t) -> (t1, t2, t3) -> t
07:10:25 <fredmorcos> am I at least going in the right direction?
07:13:20 <fredmorcos> and in that case, my item function should update the line and column, correct?
07:13:25 <fredmorcos> item :: Parser Char
07:13:25 <Taneb> How big is the difference between binary and cereal?
07:16:44 <Tekmo> Taneb: Not very different
07:17:22 <Tekmo> Taneb: The main difference is that `cereal` was built from the ground up not to use asynchronous exceptions to signal parse failures
07:17:47 <m1dnight> bennofs: Yes. Yes I have.
07:17:55 <m1dnight> I might even say I don't dare say what my problem was
07:18:08 <m1dnight> mind the "my"
07:19:20 <ocharles> What should I use to split a Char8 ByteString into a list, splitting on "," surrounded by zero or more spaces?
07:19:28 <ocharles> I could use attoparsec, but that feels a bit heavyweight
07:19:47 * hackagebot haskell-updater 1.2.1 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.1 (SergeiTrofimovich)
07:21:07 <merijn> Tekmo: Don't forget cereal has better support for strict ByteString
07:21:14 <Tekmo> merijn: That's right
07:21:21 <merijn> Taneb: I recently saw a report proposing merging cereal into binary
07:22:07 <bartavelle> ocharles, a dirty approach is to split with "," then trim spaces
07:22:30 <Tekmo> ocharles: There is nothing heavyweight about `attoparsec
07:22:50 <bartavelle> Tekmo, I suppose he means including the package, then writing the parser, then running the parser
07:22:53 <Taneb> merijn, I hope that happens, they are both ridiculously similar (almost interchangeable) and both quite popular
07:23:04 <merijn> Taneb: No kidding
07:32:59 <quchen> Taneb, merijn: What are the differences between them? Strict/lazy BS, but apart from that?
07:33:39 <quchen> Binary seems to use quite verbose encodings, how does Cereal compare?
07:33:40 <Wardje> So iterate f x = [x, f(x), f(f(x)), ...]. Can I assume Haskell to be smart enough not to start from the very beginning for every item of the resulting list ?
07:34:01 <quchen> Wardje: It's not Haskell but iterate's definition that is smart enough
07:34:04 <quchen> @src iterate
07:34:04 <lambdabot> iterate f x =  x : iterate f (f x)
07:34:26 <Wardje> as long as something's smart enough :) thanks
07:34:41 <quchen> You see that the "x" is shared between the prepended x and the recustive iterate call
07:36:36 <Wardje> hmm, but haskell is lazy so dont you end up with a [x, f(x), f(f(x)), ...] until you want to take out some results, passing the problem back to haskell?
07:37:05 <Taneb> Wardje, you end up with x : iterate f (f x)
07:37:20 <Taneb> It doesn't even think about the rest of the list until it needs to
07:37:38 <mauke> Wardje: x is different in the recursive call
07:37:52 <mauke> turns out variables do
07:38:17 <Wardje> ok, bad wording, Taneb, my bad
07:39:47 <Wardje> I was under the impression though that the (f x) wouldnt be evaluated yet either, so you end up with `f x : iterate f (f (f x))' and so on
07:39:49 * hackagebot hake 1.3.8.1 - make tool. ruby : rake = haskell : hake  http://hackage.haskell.org/package/hake-1.3.8.1 (YoshikuniJujo)
07:40:16 <Wardje> as in, the f x is still just there, not it's evaluated result
07:40:31 <mauke> Wardje: true but irrelevant to the question you asked
07:41:14 <mauke> Wardje: let square x = x * x in square (1 + 2)
07:41:25 <mauke> this will only compute 1 + 2 once because the result is shared
07:41:31 <Tekmo> Wardje: I believe `ghc` will share the `f x` with the recursive call
07:41:43 <mauke> Tekmo: huh?
07:41:52 <Tekmo> mauke: In the example he typed out
07:41:58 <mauke> go on
07:42:06 <Wardje> ok mauke, the sharing part is what I was wondering about in my original question, sorry if that didnt make sense
07:42:08 <Tekmo> mauke: Maybe it's simpler if I start from beginning of the list
07:42:15 <Tekmo> x : iterate f (f x)
07:42:20 <Tekmo> That then expands to
07:42:36 <Tekmo> x : f x : iterate f (f (f x))
07:42:47 <mauke> Tekmo: except that notation loses sharing
07:43:01 <Tekmo> Oh, it does?
07:43:07 <mauke> it's more like x : (let x' = f x in x' : iterate f (f x'))
07:43:17 <Tekmo> Are you sure?
07:43:19 <mauke> yes
07:44:05 <Tekmo> I still think it is shared
07:44:09 <jmcarthur> Wardje: yes, you had the idea of lazy evaluation of iterate right. it's actually quite unfortunate that we don't have an iterate' where the accumulator is strict
07:44:17 <Tekmo> Because the `f x` in the recursive call is bound to `x`
07:44:37 <Tekmo> And that `x` is shared because of how `iterate` is defined
07:44:40 <mauke> Tekmo: yes
07:45:08 <mauke> huh
07:45:08 <Tekmo> mauke: So are you just disagreeing with the notation I was using?
07:45:20 <Wardje> hmm that is quite unfortunate, jmcarthur
07:45:22 <Tekmo> So the definition we are using is:
07:45:28 <Tekmo> iterate f x = x : iterate f (f x)
07:45:29 <quchen> jmcarthur: takeWhile (`seq` True) (iterate f x)
07:45:50 <Tekmo> mauke: I assume that the `x` in that definition will not be recomputed twice
07:46:16 <Tekmo> mauke: When we do the recursive call to `iterate`, it should bind `f x` as the new "x" and then share that for the next recursive call
07:46:45 <mauke> I think I just disproved referential transparency
07:46:46 <quchen> Tekmo: I think what Mauke meant that in the notation "x : f x : iterate f (f (f x))" precisely that binding gets lost.
07:46:52 <quchen> i.e. "f x" is not shared.
07:46:56 <Tekmo> quchen: Right
07:47:11 <Tekmo> quchen: What I was trying to say was that it effectively ends up being
07:47:21 <Tekmo> x : (let y = f x in y: iterate f y)
07:49:49 <bennofs> haskell-src-exts produces a lot of warnings when compiled with -Wall :(
07:52:22 <bernalex> is there any project to duplicate GNU coreutils in haskell?
07:52:30 <bernalex> if not, I propose to start one. :-) just for learning.
07:52:36 <bennofs> bernalex: I'm in
07:53:31 <bernalex> bennofs: I started reading RWH some months ago, and somewhere right at the beginning they gave an example of how haskell code might look like, with a function that counted words or something, so I got type-happy and basically implemented all of wc. :-P
07:54:19 <Tekmo> bernalex: Have you seen this? http://www.haskell.org/haskellwiki/Simple_Unix_tools
07:54:21 <mcstar> next step is du
07:54:57 <bernalex> Tekmo: no. thanks. :-)
07:55:07 <Tekmo> You're welcome!
07:55:10 <mcstar> also, you could make your life easier and write a c->haskell compiler
07:55:19 <mcstar> that way you could resue the codebase
07:55:23 <mcstar> reuse*
07:55:31 <bernalex> I'll start it sometime during Christmas and push to github once I have a few programs started, I guess
07:55:46 <bernalex> I just have to decide if I wanna encourage reuse etc, or if I want self-contained examples
08:06:07 <Elision> are there builtins for \x->\y->x and \x->\y->y in Prelude?
08:06:26 <osfameron> the former is const, isn't it?
08:06:27 <bennofs> Elision: const and flipe const
08:06:28 <mauke> const, const id
08:06:39 <Elision> ah, right
08:06:42 <ion> flipe doge
08:06:46 <bennofs> :p
08:06:50 <Elision> thanks :p
08:16:54 <Eelis> if i have a network protocol consisting of trivially framed protobuf messages, and i want to run a little connection forwarder/proxy program that uses a  Message->[Message]  to replace incoming and outgoing messages (for debugging purposes), would it make sense to do this with pipes and Haskell protobuf bindings?
08:20:34 <klrr_> how do i write a FromJSON instance for a type like this "data Foo = Bar | Quuz" ?
08:22:45 <donri> any way you like :P
08:24:28 <klrr_> yeah but how? is there a way to check all strings and if they match a case then they parse as Foo?
08:25:15 <donri> klrr_: Parser is ah Alternative
08:25:30 <klrr_> hmmm
08:29:32 <Eelis> what's the Haskell equivalent of C++'s Boost.Asio?
08:29:47 <bennofs> Eelis: what does asio do?
08:29:53 * hackagebot haskell-generate 0.2 - haskell-generate  http://hackage.haskell.org/package/haskell-generate-0.2 (BennoFuenfstueck)
08:30:13 <Eelis> bennofs: it provides a nicer interface than raw sockets
08:30:17 <cschneid> klrr_: `parseJSON (Object v) = if textValueOf v then Bar else Quuz` or so. I have no idea what the right way to get text out of that object is though :)
08:31:30 <klrr_> cschneid: thanks for the hint!
08:31:58 <cschneid> klrr_: yeah, presumably that works, but heck if I know :)  Go write a blog post or something when you figure it out, so I can google it up when I need it.
08:32:20 <bartavelle> I am looking for a configurable (Rational -> String) (decimal notation, choose number of digits displayed after the dot), suggestion anyone ?
08:32:36 <Eelis> bennofs: i guess another way to put it is that i want a library that does select() for me
08:32:41 <Eelis> or epoll(), whatever
08:33:04 <donri> klrr_: although I think maybe you want to pattern match on String there
08:33:45 <cschneid> bartavelle: does Text.Printf do what you need? (http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Printf.html)
08:34:03 <donri> klrr_: parseJSON (String "bar") = Bar; parseJSON (String "quuz") = Quuz; parseJSON _ = empty
08:34:06 <bartavelle> cschneid, it most probably does, but I was wondering if there was a more specialized way
08:34:26 <cschneid> bartavelle: I imagine there is. The question is: "Have you written it yet?" :)
08:34:31 <bartavelle> hehe
08:34:45 <donri> klrr_: uh you'll want pure Bar and pure Quuz there
08:35:21 <Eelis> bennofs: or maybe the Haskell Way when i want to listen for data on two sockets is to just create two threads, each blocking on a socket, and hope that GHC's I/O manager does the right thing? :)
08:35:40 <cschneid> that does seem useful though, a function like:   displayNumber :: DisplayOptions -> Num -> String.  That way you can partially apply some options like: reportNumber = displayNumber {MyOptions}, and have a nice pretty printer without having to think about it everywhere
08:36:00 <cschneid> donri: hey, pattern matching. That's way better than my solution of using `if` :)
08:36:14 <bennofs> Eelis: I haven't tried that out myself, but if it works, yes
08:36:34 <klrr_> donri: oh that's what i want, thanks!
08:36:35 <donri> cschneid: it was your idea, you matched on Object!
08:36:39 <Eelis> bennofs: ok, i'll give it a shot. thanks :)
08:47:35 <bennofs> What was the macro for the GHC version again?
08:47:42 <m1dnight> I'm working with the Snap framework. I would like to see the implementation of the Snap monad.
08:47:46 <m1dnight> How could I do this?
08:48:17 <bennofs> m1dnight: Look here: http://hackage.haskell.org/package/snap-core-0.9.5.0/docs/src/Snap-Internal-Types.html#Snap
08:48:42 <bennofs> m1dnight: but why do you need the implementation of the snap monad?
08:49:58 <m1dnight> well, because I have no clue what I'm doing atm
08:50:09 <m1dnight> and it might've made me a bit wiser
08:50:11 <m1dnight> but.. no.
08:50:26 <m1dnight> why on earth did the professor give us this as a project
08:50:29 <m1dnight> documentation 0.0.
08:51:04 <bennofs> m1dnight: Have you looked at the snap tutorial?
08:51:24 <m1dnight> yeah , it's a crappy one if you don't mind me saying :p
08:51:27 <aristid> snap still uses iteratees? how unfashionable
08:51:41 <m1dnight> ill just tinker a bit with everything
08:51:42 <bennofs> m1dnight: what do you want to do?
08:51:50 <m1dnight> Just build a calendar application
08:52:04 <m1dnight> but I've just (as in really really just) learned the basics of haskell
08:52:14 <m1dnight> And now this :p
08:52:32 <mcstar> snap judgement
08:52:39 <shiona> aristid: damn that highlight
08:52:55 <bennofs> haha
08:57:54 <aristid> shiona: ?
08:58:21 <aristid> oh
08:58:23 <bennofs> aristid: you said unfa*shiona*ble :P
08:58:26 <aristid> shiona: yes, fix your client
08:59:55 * hackagebot picosat 0.1.0.0 - Bindings to the PicoSAT solver  http://hackage.haskell.org/package/picosat-0.1.0.0 (sdiehl)
09:04:51 <shiona> aristid: no way to fix really. And that's not really a problem
09:05:42 <aristid> shiona: i guess you'll just notified whenever something is fashionable or not
09:06:08 <shiona> yeah, which happens about once every two years or so normally
09:08:39 <shiona> but I assume you would recommend me to use -fullword or something, but unfortunately I'm a native speaker of a language where words inflect
09:09:25 <aristid> shiona: where even names are inflected?
09:09:56 <aristid> shiona: does the inflection happen at both ends of the word?
09:10:28 <aristid> shiona: if it's just a suffixed inflection, something like \bshiona might work
09:11:00 <flazz> is it common for hdevtools to just sit and no nothing? (os x) i can't seem to get it to do anything else
09:11:03 <shiona> aristid: in Finnish, inflection is just for suffixes, but we also have compound word system that rivals that of German
09:11:24 <bennofs> flazz: from where did you install hdevtools?
09:11:31 <flazz> bennofs: cabal install
09:11:54 <bennofs> flazz: so you're running hdevtools check someSourceFile.hs and it does nothing?
09:11:54 <aristid> shiona: german has compound nouns, yes, but names are never embedded in compound nouns at all. also, names are not inflected in german :)
09:13:09 <shiona> aristid: yea, I know. In Finnish "to shiona" would be "shionalle"
09:13:21 <ion> nalle means a bear
09:13:33 <shiona> true
09:13:47 <aristid> ion: your name is an infix of shiona's!
09:13:47 <shiona> Names do not get compounded in written language, but in spoken it's possible
09:13:55 <ion> aristid: !
09:13:58 <flazz> bennofs: it just hangs on the command line
09:14:48 <bennofs> flazz: Hmm, that's not normal
09:15:19 <bennofs> flazz: are you sure the file you want to check exists?
09:15:58 <flazz> bennofs: hdevtools check -g -isrc Main.hs; src/Main.hs exists
09:16:13 <Hafydd> It appears to me that System.Environment.getProgName only gives the basename of the original executable, not its full path relative to the CWD; and System.Environment.getExecutablePath gives the path of the current executable file, even if it's renamed; and neither of these allow me to get the original absolute path of the executable as invoked.
09:16:18 <Hafydd> Am I correct?
09:16:44 <bennofs> flazz: try specifing src/Main.hs directly. But make sure that hdevtools isn't running anymore before.
09:16:49 <geekosaur> Hfydd: yes, and there's a reason for that
09:16:57 <Hafydd> What is the reason?
09:17:02 <geekosaur> that it is not available
09:17:23 <m1dnight> hmm
09:17:28 <m1dnight> in Snap i have the following line
09:17:29 <geekosaur> getProgName returns whatever argv[0] it was invoked with. getExeutablePath tries to find the corresponding executable
09:17:30 <Hafydd> I'm pretty sure that the original name (relative to the CWD) is available to C programs.
09:17:33 <m1dnight> writeBS "a string"
09:17:36 <flazz> bennofs: same behavior
09:17:46 <m1dnight> why does my compiler complain when I try "writeBS (map toUpper "a string") ?
09:18:02 <bennofs> m1dnight: writeBS writes a ByteString.
09:18:04 <geekosaur> actually I think getProgName explicitly removes any path components; if you are insistent on getting the original, you probably need to figure out how to FFI it
09:18:14 <bennofs> m1dnight: map toUpper "a string" is a String
09:18:18 <m1dnight> oh
09:18:26 <m1dnight> but Ã"a string" is a string as well, right?
09:20:11 <mgsloan> You probably have OverloadedStrings turned on, which means that string literals have the type (IsString a => a)
09:20:19 <bennofs> m1dnight: you should use 'writeText $ T.pack $ map toUpper "a string"', after import qualified Data.Text as T
09:20:41 <mgsloan> However, map forces it to figure out an instance of IsString that's a list, in other words, String
09:21:01 <m1dnight> ugh :p
09:21:07 <m1dnight> okay thnx bennofs
09:21:47 <mgsloan> Sounds like you might want to use Text, by the way
09:21:55 <mgsloan> Oh, yeah, that's what bennofs is saying, nvm
09:23:08 <c_wraith> If you're importing Text, you should uppercase correctly, rather than by mapping toUpper
09:23:41 <c_wraith> since Text has helpful functions for *correct* uppercasing, instead of what map toUpper does
09:23:58 <flazz> bennofs: any idea on how i could diagnose hdevtools?
09:26:39 <Hafydd> geekosaur: consider the following: http://lpaste.net/97436
09:26:42 <bennofs> flazz: 1. Make sure hdevtools isn't running anymore (Check: .hdevtools.sock doesn't exist). 2. In one terminal, start hdevtools using hdevtools admin --start-server --nodaemon 3. In another terminal, do hdevtools check -g -isrc -g -v3 src/Main.hs
09:27:05 <geekosaur> [23 17:11] <geekosaur> actually I think getProgName explicitly removes any path components; if you are insistent on getting the original, you probably need to figure out how to FFI it
09:27:15 <Hafydd> I see.
09:27:32 <geekosaur> and the maintainers have already heard and rejected complaints about it so don't bother
09:27:33 <Hafydd> Why? Has this really not become an issue before?
09:27:37 <donri> mgsloan: actually map toUpper, not only map, as the IsString instance looks currently
09:27:46 <donri> edwardk: did your proposal go through?
09:27:55 <geekosaur> you can search the -cafe archives for getProgName to see past discussions about it
09:27:55 <mgsloan> donri: Right, makes sense
09:28:02 <flazz> bennofs: .hdevtools.sock never existed on the fs (as far as i could see), but lsof reports it as an open file
09:28:27 <geekosaur> hm, actually, lemme see if there is a POSIX version now
09:28:28 <bennofs> flazz: really? .hdevtools.sock should exist on the fs in the directory you ran hdevtools
09:28:38 <donri> mgsloan: edwardk proposed (a ~ Char) => IsString [a] which would make map alone sufficient
09:28:57 <geekosaur> getProgName is the portable version, which is the argument for having it strip path components so it returns the same kind of thing everywhere
09:29:27 <mgsloan> donri: I'm certainly in favour of that change
09:29:52 <geekosaur> nope, no POSIX specific one
09:30:01 <mgsloan> Heck, I kinda thought it was already that way (as that's what I somewhat accidentally implied above)
09:30:24 <dv-> does anyone know of an easy http client lib for haskell? i need things like cookie handling and following redirections
09:30:43 <Hafydd> Well, I suppose I could just getExcecutableName right at the beginning, and hope for no race conditions.
09:31:07 <geekosaur> on linux it will use /proc/self/exe
09:31:45 <bennofs> dv-: Not sure how simple it is, but there's http://hackage.haskell.org/package/http-conduit-browser
09:33:03 <donri> mgsloan: agreed, it's what one expects
09:33:27 <flazz> bennofs: nope,
09:34:15 <dv-> bennofs: looks okay. thanks
09:34:30 * geekosaur makes note that hdevtools will not work right on a network-mounted home dir
09:34:47 <bennofs> geekosaur: oh, do you know why that is?
09:35:09 <flazz> geekosaur: its standard mac fs, on ssd
09:35:11 <geekosaur> because socket nodes might or might not work in nfs, and will nto work in cifs or afs
09:35:37 <geekosaur> flazz, that wasn't really directed at you, more a side observation
09:35:55 <bennofs> flazz: so hdevtools admin --start-server; ls -a doesn't show .hdevtools.sock?
09:37:13 <geekosaur> this somewhat matters to me. if I use it I'll need to modify it to create its socket in /var/run
09:37:18 <flazz> bennofs: nope, could it be cabal or sandbox related?
09:38:16 <m1dnight> okay, another question: when I import the Data.Text lib it complains that I have to add it to my .cabal file.
09:38:26 <m1dnight> so i added text >= 0 && < 5
09:38:42 <m1dnight> i suppose those are version numbers so I just picked a big interval
09:38:45 <m1dnight> yet this doesn't really work
09:39:09 <m1dnight> It is a member of the hidden package `text-0.11.3.1'. Perhaps you need to add `text' to the build-depends in your .cabal file.
09:39:14 <mgsloan> m1dnight: If you don't want to restrict the versions, just use "text"
09:39:15 <dcoutts> if you want to use useless constraints, it'd be clearer to just use no constraint at all
09:39:38 <bennofs> m1dnight: maybe you added it to the wrong build-depends? Is there more than one build-depends in you cabal file?
09:39:59 * hackagebot fclabels 2.0.1 - First class accessor labels implemented as lenses.  http://hackage.haskell.org/package/fclabels-2.0.1 (SebastiaanVisser)
09:40:11 <m1dnight> no I only see one. But adding "text" only, gives a parse error as well
09:40:29 <bennofs> m1dnight: did you add a comma to the previous line?
09:41:15 <m1dnight> hah, exactly, just noticed it
09:41:19 <m1dnight> another error! amazing!
09:41:55 <m1dnight> yeah that was it thanks benf
09:41:55 <m1dnight> bennofs:
09:44:35 <xintron> newtype ObjectPath = dbus-0.10.5:DBus.Types.ObjectPath String; shouldn't I be able to use a string anywhere an ObjectPath is required?
09:45:16 <geekosaur> no, you need the constructor
09:45:27 <geekosaur> type makes it an exact synonym
09:45:40 <xintron> ah, ok
09:46:15 <xintron> and OverloadedStrings wouldn't do anything related to this I take it?
09:46:37 <xintron> (found an example where they use a normal string directly, that's why I'm asking)
09:47:03 <bennofs> xintron: you need an instance IsString ObjectPath to use OverloadedStrings
09:48:38 <xintron> which there isn't (according to :info ObjectPath). Mabye the API has changed since the example or I'm missing something
09:49:16 <bennofs> xintron: :info is sometimes liying
09:49:19 <bennofs> lying*
09:49:24 <xintron> ah
09:49:31 <bennofs> xintron: http://hackage.haskell.org/package/dbus-core-0.9.3/docs/DBus-Types.html#t:ObjectPath shows an IsString instance
09:49:48 <xintron> yeah, I also just found that
09:49:58 <xintron> thanks, now it all makes sense why it doesn't work :)
09:50:06 <geekosaur> more precisely :info will only show it if it's in scope in ghci
09:50:18 <Hafydd> Right, I suppose what I was trying to achieve was impossible, anyway; the initial getExecutablePath is the best I can do, anyway.
09:50:21 <xintron> Is it possible to enable overloadedstrings in ghci?
09:50:34 <bennofs> xintron: :set -XOverloadedStrings
09:51:05 <xintron> I guess it's best practice to not use overloadedstrings though?
09:52:34 <geekosaur> Hafydd, if you just want argv[0], you may be able to do it via the FFI (but only with some pain, since I doubt the original argv is accessible except by trawling the stack and knowing how it gets laid out)
09:56:58 <Hafydd> Apparently there is this package: http://hackage.haskell.org/package/system-argv0-0.1
10:05:01 * hackagebot dynamic-cabal 0.1 - dynamic-cabal  http://hackage.haskell.org/package/dynamic-cabal-0.1 (BennoFuenfstueck)
10:30:30 <zuserm> Anyone know what's going on with GHC 7.8?
10:30:36 <dv-> urlFilename urlString = reverse (takeWhile (/='/') (reverse urlString)) -- any better ideas?
10:34:29 <zuserm> dv-: why not use takeFileName from System.FilePath?
10:37:27 <dv-> hm that works
10:39:59 <augur> fun thought: imagine if haskell had expression substitution for strings
10:40:24 <td123> zuserm: http://www.haskell.org/pipermail/ghc-devs/2013-December/003491.html
10:40:25 <augur> eg   let x = 5 in "x = #{x}"   ==   "x = 5"
10:40:41 <dv-> ugh
10:40:46 <td123> zuserm: short answer, looks like no one knows :P
10:40:53 <augur> dv-: dont like expression substitution? :D
10:40:58 <Cale> let xs = "Hello #{xs}" in xs
10:41:15 <augur> Cale: :)
10:41:19 <augur> actually thats boring
10:41:23 <ion> I wouldn’t mind Show interpolation.
10:41:35 <augur> that just gets you fix ("Hello " ++)
10:41:39 <Cale> It does
10:41:46 <Cale> Well...
10:41:46 <augur> Cale: fixes are way too easy
10:42:00 <Cale> Actually, it probably gets you fix (("Hello " ++) . show)
10:42:01 <augur> a more interesting one is this:
10:42:02 <ion> "Hello #{xs}" is more interesting with OverloadedStrings. :-P IsString would probably need to depend on Monoid.
10:42:07 <Cale> given your previous example
10:42:10 <augur> first, imagine toWords :: Int -> String
10:42:13 <Cale> > fix (("Hello " ++) . show)
10:42:14 <lambdabot>  "Hello \"Hello \\\"Hello \\\\\\\"Hello \\\\\\\\\\\\\\\"Hello \\\\\\\\\\\\\\\...
10:42:18 <augur> Cale: ok sure, that
10:42:20 <augur> thats fine
10:42:24 <augur> close enough!
10:42:31 <augur> imagine instead   toWords :: Int -> String
10:42:40 <augur> where like   toWords 35 = "thirty five"
10:43:04 <augur> what is   let x = "#{toWords (length x)}" in x
10:43:21 <augur> i mean, there are certainly some solutions, but
10:43:41 <augur> one would hope at least one solution is   "four"
10:43:52 <Cale> Uh, you'd get a fixed point
10:43:55 <augur> would it be found? who knows! i dont know how it would compute
10:44:16 <augur> Cale: sure ofcourse you would, but how would it actually compute? would it halt with an actual solution? which one? i dont know
10:44:16 <Cale> I'm pretty sure it would be _|_
10:44:29 <augur> there certainly are non-bottom solutions tho
10:44:31 <Cale> Because _|_ is a fixed point of that equation
10:44:38 <augur> "four" being one of them
10:44:39 <Cale> and fix finds least fixed points
10:44:42 <ion> augur: You can try it right now by desugaring the hypothetical "#{}" notation manually.
10:45:17 <augur> ion: i suppose! but defining "toWords" is the tricky part
10:45:28 <Cale> Unless toWords _|_ is not _|_
10:46:05 <augur> Cale: right but would toWords necessarily act like that? i mean, i could imagine that you'd get one of these loopy knotted programs
10:46:42 <Cale> But if toWords _|_ is y where y isn't _|_, that means y <= toWords x for any other number x
10:46:48 <Cale> (in the definedness ordering)
10:47:53 <Cale> i.e. you could obtain toWords x by replacing occurrences of _|_ in y with other values, regardless of x
10:48:41 <Cale> (Haskell-definable or computable functions are monotone increasing in the definedness ordering)
10:49:33 <Cale> That's not to say you couldn't try to use some other solver to find fixed points for string functions specifically, but that might be considered a little odd
10:50:15 <Cale> (i.e. a solver which wouldn't be satisfied with finding a least-defined fixed point, and would enumerate strings somehow to try to find a different one)
10:50:51 <Cale> Though I suppose in general if you're defining this syntax, you wouldn't only have to deal with fixed points involving only strings along the way
10:51:19 <Cale> You'd end up with funny mutual recursion and stuff in general, so it would be tricky to do something more sophisticated than fix at the same time
10:52:08 <augur> Cale: im just tickled by the funny properties that quasiquotation and laziness have together :)
10:56:17 <augur> this is part of a reply to Tekmo from reddit, mind you
10:56:35 <augur> i mean, regarding referential opacity and such
10:57:11 <augur> what the hell is the denotation of such strings? i dont know, man. referential opacity is mind warping
10:58:00 <Clint> edwardk: this is your monday-celebrational adjunctions and representative-things harassment, beep beep beep
11:00:05 * hackagebot implicit-params 0.2.1 - Named and unnamed implicit parameters with defaults.  http://hackage.haskell.org/package/implicit-params-0.2.1 (ShaneOBrien)
11:02:09 <ion> Is would be kind of cool if "http://foo/#{bar :: String}" :: URI used a method of interpolation specific to URI and String and URI-encoded the string in UTF-8; "foo #{bar}" :: String could have an interpolation instance for all Show a => a.
11:04:02 <davidfetter_disq> is there an info bot?
11:05:35 <yogert> Hey I have a design question. I am making an API wrapper for a web service. When using this API you are dealing with a number of different "classes" of datatypes, each with it's own set of fields. My question is that, since many of these classes have some overlap in their fields (for instance, many have a timestamp, and timestampUTC field) would it be wise to make a number of typeclasses to create a single interface across them all? To do this I would be
11:06:02 <augur> Cale: i used http://www.haskell.org/haskellwiki/99_questions/Solutions/95
11:06:16 <augur> let s = fullWords (toInteger $ length s) in s   just spins
11:07:28 <Guest23559> How can I check that my cabal file contains all the dependencies?
11:07:52 <nadirs> davidfetter_disq: hi, what are you looking for? there's lambdabot here, does it fit?
11:08:25 <davidfetter_disq> nadirs, unsure. i'm trying to find references for random silly topics, not yet trying out code
11:09:46 <nadirs> davidfetter_disq: not Haskell-related? Anyway, here's a wiki about lambdabot → http://www.haskell.org/haskellwiki/Lambdabot
11:10:20 <davidfetter_disq> nadirs, well, they're probably haskell-related. will read that 1st.
11:10:35 <pmade> Guest23559: build your project with cabal.  It will complain if you don't have all the dependencies listed.
11:11:01 <ParahSailin> ive got a basic TH question http://lpaste.net/97442
11:11:42 <davidfetter_disq> nadirs, looks perfect. diving in... :)
11:12:08 <nadirs> davidfetter_disq: have a nice swim :)
11:13:08 <ParahSailin> what goes in the th_magic slot?
11:16:34 <kqr> yogert, i would be careful with type classes, but i'm not an authority on this
11:16:51 <kqr> yogert, i just know people tend to use type classes a bit too eagerly
11:17:26 <Cale> yogert: your question was cut off at "To do this I would b"
11:17:49 <mgsloan> yogert: Maybe instead you can create wrapper objects that contain the common fields?
11:18:11 <Cale> Yeah, I would structure things to try to collect common bunches of fields into their own types
11:24:43 <edwardk> Clint: i almost perversely don't want to make this stop, but perhaps  should. ;)
11:25:38 <Clint> edwardk: i was afraid of that
11:26:56 <flebron> Hi. Purely for stylistic purposes, is there a way to define (in unicode) the TeX symbol \in to be <-?
11:27:09 <flebron> UnicodeSymbols, by default, doesn't seem to do this.
11:27:13 <shachaf> Clint: What's this adjunctions and representative-things business?
11:31:46 <lightquake> so, here's a design issue I'm having some problems with. I'm trying to write a dead-simple IRC bot, and I'm having problems with the whole 'connecting to the server' thing.
11:31:54 <Clint> shachaf: there's no version of adjunctions compatible with comonad 4.0, and edward is going to fix that problem
11:32:14 <lightquake> the reason is that some ircds send you a PING after you send the NICK and USER messages, and don't accept commands until after you send a PONG... but some don't.
11:32:34 <edwardk> i've got a half-finished rewrite that merges in representable-functors and may merge in representable-tries through the memo stuff i posted the other day
11:33:01 <edwardk> shachaf: clint is subtly reminding me to get off my ass, stop playing in quora and work on it ;)
11:33:26 <lightquake> so, right now the thing I've settled on is not sending JOIN commands until after I see the final line of the MOTD
11:33:34 <lightquake> but I still have to respond to pings before then
11:33:48 <shachaf> Do you have a type class for "behaves like (e,)"?
11:34:01 <shachaf> Seems like the other side of Adjunction could benefit from it.
11:34:33 <shachaf> On the other hand given that this class has only one instance, I'm not sure how much point there really is to it anymore.
11:35:19 <lightquake> the one approach I was considering was forking off a separate ping thread, but... I dunno.
11:36:33 <Elision> lpaste has suggestions about style things I am unaware of, such as list notation in patterns and lets in do notation. is there a tool that provides such suggestions on local code?
11:37:00 <shachaf> hpaste uses hlint
11:37:01 <geekosaur> hlint
11:37:01 <geekosaur> which is what lpaste is running
11:37:25 <Elision> thanks
11:41:49 <Guest23559> Is it OK to use the default package version (as suggested by cabal init) for a new project?
11:42:17 <merijn> Guest23559: cabal init just picks whatever you have installed +are using atm
11:43:26 <xintron> So, as a beginner should one avoid OverloadedStrings?
11:43:36 <sofaer> Hello everyone, I'm trying to get started with Yesod, and I'm having a problem with the cabal sandbox.  I'm not sure whether it's cabal-dev or Yesod.  When I try to do 'cabal-dev ghci' in my project folder so I can play around with the created types in ghci, I get the error "cabal-dev: user error (cabal: Can't parse --info output of GHC)", which seems to come from cabal-dev trying to run ghc, but actually running some sort of stub ghc
11:43:36 <sofaer> instead.  Any advice?
11:43:38 <Guest23559> merijn: sorry, I don't understand your reply. could you expand a bit? note that I was referring to 'Package version? [default: 0.1.0.0]'.
11:44:00 <benzrf> hi
11:44:02 <pmade> Guest23559: If you're referring to the version number cabal uses for the package *you* are writing, then yes, 0.1.0.0 is good.
11:44:41 <dcoutts> sofaer: cabal-dev has not been updated for the latest version of Cabal or ghc, but fortunately cabal itself has sandbox support now, so you can retire cabal-dev (indeed this is why it has not been updated)
11:44:46 <pmade> Guest23559: You should also read the cabal user guide to understand what the version number represents so when you make a new release you know what to change.
11:45:12 <merijn> Guest23559: Oh, that matters even less
11:45:29 <Guest23559> pmade: I've read the relevant wiki page.
11:45:38 <merijn> Guest23559: There is a Package Versioning Policy, but in the end it's sorta up to you
11:45:45 <Guest23559> pmade: which covers A.B.C.rest
11:46:05 <erisco> @src sort :: (Ord a) => [Maybe a]
11:46:05 <lambdabot> Source not found. That's something I cannot allow to happen.
11:46:21 <Guest23559> merijn: My questions is: what should the first version be if the package is not ready yet. I guess 0.1.0.0 is fine.
11:46:21 <shachaf> help
11:46:22 <erisco> @src sort :: (Ord a) => Maybe a
11:46:22 <lambdabot> Source not found.
11:46:26 <Guest23559> question*
11:46:32 <simpson> :t sort -- erisco
11:46:33 <lambdabot> Ord a => [a] -> [a]
11:46:39 <erisco> yeah whoops
11:47:18 <erisco> :t compare
11:47:18 <lambdabot> Ord a => a -> a -> Ordering
11:47:36 <erisco> @src compare :: (Ord a) => Maybe a -> Maybe a -> Ordering
11:47:36 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
11:47:43 <erisco> :(
11:47:45 <shachaf> erisco: What are you doing?
11:47:55 <simpson> erisco: src doesn't generate source; it looks stuff up in a pre-existing table.
11:47:56 <lightquake> ... I wonder if maybe I want to use netwire for the internal logic of this IRC bot.
11:48:00 <geekosaur> that's not how @src works. what do you think you are doing?
11:48:01 <shachaf> You should have to have a license to use @src.
11:48:11 <erisco> > (sort [Just 0, Nothing], sort [Nothing, Just 0])
11:48:12 <lambdabot>  ([Nothing,Just 0],[Nothing,Just 0])
11:48:21 <shachaf> Mostly because @src is pretty broken.
11:48:54 <erisco> weird my ghc does not give that result
11:49:06 <Guest23559> pmade: Also, is there a guide that covers project categories? Some of them are very specific while ther others are too vague. It's hard to pick.
11:49:15 <erisco> oh lol
11:49:17 <erisco> stupid me
11:49:29 <pmade> Guest23559: not that I know of.  Use the categories on hackage to decide.
11:49:40 <erisco> I handily forgot to actually sort the list in my tests :P
11:49:55 <merijn> Guest23559: I just picked a random semi-accurate one :p
11:51:11 <benzrf> what's the justification for left catch for monadplus?
11:51:12 <jle`> don't let the hackage police catch you though
11:51:20 <benzrf> I do not understand why it makes sense
11:51:57 <jle`> benzrf: i think it makes it behave kinda like alternative
11:52:12 <jle`> but then again alternative's list instance doesn't follow it so
11:52:30 <benzrf> well i dont really know alternative >_>
11:52:30 <benzrf> what
11:52:35 <benzrf> *what's the justification /there/
11:53:24 <jle`> benzrf: Alternative/MonadPlus embody the concept of monad instances defined by modeling chaining of failure/succcess processes
11:53:27 <jle`> ie, Maybe
11:53:53 <jle`> alternative supplies a way to laterally/in parallel pick from many choices of these processes
11:54:02 <jle`> in Maybe, it picks the 'first'
11:54:18 <jle`> same as in parser combinators typically, although parsec's is a little weird
11:54:24 <benzrf> hmmm, ok
11:54:32 <jle`> MonadPlus supploes >>=
11:54:39 <benzrf> aah, that makes sense
11:54:43 <jle`> which defines the idea of chaining fail/success proccesess one after another
11:54:47 <jle`> in series
11:54:56 <benzrf> left catch only works for first-style >>= chains though
11:55:02 <benzrf> and not all monads are like that...
11:55:10 <jle`> not all MonadPlus, you mean?
11:55:33 <benzrf> wait hmmm
11:55:47 <benzrf> i guess you could just say that it doesnt make sense for a monad not like that to be an m+
11:56:18 <jle`> the concept of fail/success doesn't have any meaningful interpretation for most monads
11:56:24 <benzrf> right
11:56:41 <benzrf> but not even all monoids are necessarily first
11:57:10 <benzrf> or is monadplus supposed to be for possible failures only?
11:57:29 <Cale> benzrf: It's ambiguous
11:57:33 <benzrf> :\
11:57:35 <Cale> Really there should be two classes
11:57:41 <benzrf> certainly sounds like it
11:57:50 <Cale> This has been known about for years
11:58:04 <Cale> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
11:58:18 <jle`> well, non left catch is useful for the list monad's monadplus instance
11:58:32 <jle`> because it makes sense in the spirit of what the list monad tries to model
11:58:44 <Cale> That page is from 2006, and I think it might actually be a carryover from the old wiki
11:58:45 <jle`> by the list monad i mean the default haskell instance of monad for the list
11:59:25 <jle`> which is inherently an 'or'
11:59:44 <jle`> er
11:59:57 <Cale> All you can really say for now is that MonadPlus is for monads which create monoids
11:59:58 <jle`> sorry, not an 'or' as used by the article
12:00:39 <benzrf> Cale: with left zero...
12:00:50 <Cale> Yeah, I suppose you could throw that in
12:01:11 <jle`> yeah, that's the thing
12:01:14 <benzrf> so how is mplus different from join\
12:01:25 <jle`> it makes it more than just a trivial monoid instnace/any monoid instance
12:01:27 <Cale> The type is completely different
12:01:29 <benzrf> wait buh
12:01:32 <benzrf> that was a brain fart
12:02:41 <jle`> mplus is <|> and i'm pretty sure that mplus shouldn't even exist, if it weren't for that whole hierarchy mess
12:04:24 <benzrf> @src mplus :: Maybe a -> Maybe a -> Maybe a
12:04:24 <lambdabot> Source not found. My pet ferret can type better than you!
12:04:36 <quchen> @src Maybe mplus
12:04:37 <lambdabot> Nothing `mplus` ys = ys
12:04:37 <lambdabot> xs      `mplus` ys = xs
12:04:41 <benzrf> ah
12:05:05 <benzrf> wait, so is that basically just <<?
12:05:10 <zipper> I probably shouldn't have taken that beer before starting to learn Haskell
12:05:36 <jle`> benzrf: no
12:05:44 <benzrf> @src Maybe (>>)
12:05:45 <lambdabot> (Just _) >>  k      = k
12:05:45 <lambdabot> Nothing  >>  _      = Nothing
12:05:45 <jle`> > Nothing << Just 5
12:05:46 <lambdabot>  Not in scope: `<<'
12:05:46 <lambdabot>  Perhaps you meant one of these:
12:05:46 <lambdabot>    `=<<' (imported from Control.Monad.Writer),
12:05:47 <lambdabot>    `<' (imported from Data.Ord), `<=' (imported from Data.Ord)
12:06:02 <benzrf> oh wait
12:06:09 <benzrf> ah
12:06:14 <benzrf> p:
12:06:15 <jle`> wait what do you mean by <<, do you mean <*
12:06:22 <benzrf> i mean flip >>
12:06:22 <ion> or <>
12:06:32 <quchen> <* isn't flip (<<) though
12:06:47 <benzrf> well I meant flip >>
12:06:48 <benzrf> :P
12:08:58 <benzrf> wait so
12:09:11 <benzrf> mplus is supposed to preserve success when >>= propagates failure?
12:10:11 <jle`> more like it tries to 'select' success between choices
12:10:37 <benzrf> mostly what i meant :p
12:10:44 <benzrf> that isn't really plus, it's more like max
12:10:46 <jle`> you can think of mplus like a short circuit OR, for left catch ones
12:10:56 <benzrf> while >>= is anders^^
12:10:57 <benzrf> *and
12:11:08 <benzrf> or rather >> is and
12:12:23 <benzrf> *> is >> for applicatives, right?
12:12:30 <benzrf> wait hm
12:12:56 <benzrf> > Just 1 *> Nothing
12:12:57 <lambdabot>  Nothing
12:13:01 <benzrf> > Just 1 *> Just 8
12:13:02 <lambdabot>  Just 8
12:13:30 <benzrf> > Right 1 *> Right 2 *> Right 3
12:13:32 <lambdabot>  Right 3
12:13:35 <benzrf> cool
12:14:04 <benzrf> why are $ and * associated with functors and applicatives anyway
12:16:00 <jle`> <$> is a wrapped $
12:16:03 <kqr> $ is associated with function application
12:16:06 <jle`> $ 'inside'
12:16:11 <kqr> <$> is by analogy applying a function within a functor
12:16:12 <jle`> > (*2) $ 3
12:16:14 <lambdabot>  6
12:16:18 <jle`> > (*2) <$> Just 3
12:16:19 <lambdabot>  Just 6
12:16:37 <jle`> etc.
12:16:40 <jle`> it's kinda cute
12:17:41 <benzrf> @src $>
12:17:41 <lambdabot> Source not found. Wrong!  You cheating scum!
12:17:43 <jibcage> What exactly needs to happen for a SafeCopy to be derived from a data structure?
12:17:46 <benzrf> @src (<$)
12:17:46 <lambdabot> (<$) = (<$>) . const
12:17:58 <benzrf> why use (<$>) instead of fmap
12:18:06 <quchen> It's an infix synonym.
12:18:10 <jibcage> I'm trying to derive a safecopy for an implementation of red-black trees but the compiler won't let me.
12:18:11 <benzrf> i know, that's my point
12:18:14 <benzrf> fmap is much easier to type o:
12:18:30 <quchen> <$> has fixity to combine well with Applicative functions like <*>.
12:18:37 <jle`> <$> is cleaner in a lot of cases
12:18:39 <jibcage> I literally spent 30 minutes trying to google <$>
12:18:39 <jle`> and that too
12:18:45 <jle`> jibcage: hoogle :P
12:18:47 <jibcage> did not work
12:19:02 <jle`> @hoogle <$>
12:19:02 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
12:19:03 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
12:19:21 * jibcage bookmarks hoogle
12:19:32 <merijn> jibcage: I think you just need to derive Generic so you can use Safecopies Generic instance?
12:20:13 <jle`> i feel like <$> has a lot to offer conceptually, with its parallels to $, compared to fmap
12:20:28 <jibcage> so in my data declaration I should write deriving Generic?
12:20:33 <merijn> jibcage: Yeah
12:20:46 <simpson> Agh. Damn you parsers. Damn you to hell!
12:21:20 <benzrf> what does | do outside of data defs?
12:21:26 <merijn> jibcage: Oh actually, maybe I'm wrong
12:21:40 <quchen> jle`: You can view fmap from two different angles. One is "mapping over something", the other one is "lifting a function". The lifting part is what explains how <$> really is $ one level higher.
12:21:42 <merijn> jibcage: I see safecopy has template haskell functions for deriving instances
12:21:44 <aristid> benzrf: it's for guards, which are boolean conditions to a pattern
12:21:50 <merijn> benzrf: ENOTENOUGHCONTEXT
12:21:52 <jibcage> merijn: yep
12:21:53 <geekosaur> functional dependencies in typeclass declarations; guards
12:22:04 <aristid> merijn: don't you like the guessing game?
12:22:31 <aleksejs_> Hi, I've already asked this here: is there any working "Haskell Koans" project? Google only gives me HaskellKoans project on github which doesn't work
12:22:32 <benzrf> derp
12:22:52 <benzrf> bbl thx
12:23:12 <merijn> jibcage: The code has some (admittedly underdocumented) examples of using them
12:23:22 <jle`> quchen: yeah i guess they both have their own situations where one makes more sense conceptually over the other.  i should have needlessly added the 'compared to fmap' clause.
12:23:27 <merijn> jibcage: i.e. "deriveSafeCopy 1 'base ''T0" <- this calls the template haskell function at compile time
12:23:31 <jibcage> merijn: Which is exactyl my problem...
12:23:47 <Guest23559> I have the following in my .cabal file: includes: foo.h and extra-libraries foo.  even though ghci -lfoo Foo.hs works, cabal build fails to find foo. what's wrong?
12:23:57 <jibcage> merijn: Right, but the compiler is complaining that it can't derive a safecopy instance for my tree
12:24:10 <jibcage> merijn: And I can't for the life of me figure out why
12:24:19 <Guest23559> it particular, it complains about a missing header file.
12:24:29 <Guest23559> in*
12:24:46 <aleksejs_> Koans is like piece of code but with some part of it replaced with "fixMe" or replaceMe" or something else. The goal is to replace it with something to make code work
12:24:59 <lispy> jibcage: fail $ "Can't derive SafeCopy instance for: " ++ show tyName ++  ?
12:25:21 <merijn> aleksejs_: Maybe you're looking for something like
12:25:24 <merijn> @where exercises
12:25:24 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
12:25:45 <aleksejs_> merijn, not exactly
12:25:52 <lispy> jibcage: phrased differently, I guess you could look at all the places their template haskell has errors like your error and see if you can figure out how it gets there
12:26:21 <lispy> jibcage: do you use GADTs, existentials, or anything fancy like that?
12:26:44 <aleksejs_> 99 problems ask you to write a code, but Koans ask you to replace some word with working piece of code
12:26:47 <jibcage> lispy: nope
12:26:48 <aleksejs_> like
12:28:00 <jibcage> sigh. I guess I'll just use Data.Map
12:28:19 <aleksejs_> pow2 n = fixMe >> to be replaced with pow2 n = n*n
12:51:40 <jle`> (^2)
12:52:07 <lispy> :t \n -> (^2)
12:52:08 <lambdabot> Num a => t -> a -> a
12:52:18 <lispy> jle`: clearly you're think of someting else ;)
12:52:43 <Guest23559> There are libfoo.a and libfoo.so in /usr/local/lib as well as foo.h in /usr/local/include/foo. I specified includes: foo.h and extra-libraries: foo in the cabal file. However, cabal configure fails unless I export C_INCLUDE_PATH=/usr/local/include/foo  If my package ends up on Hackage, I'm worried that people may have troubles with it. Should I specify anything else in the cabal file?  Or I shouldn't care since it's user's
12:52:43 <Guest23559> responsibility to know where their libraries are located, should I?
12:53:01 <jle`> lispy: const (^2) :P
12:53:27 <jle`> nvm >.>
12:53:42 <lispy> jle`: I was just teasing that you'd have to eta contract the original to make it simply (^2)
12:53:57 <lispy> eg., pow2 = (^2)
12:54:02 <jle`> yeah i saw
12:54:08 <jle`> was trying to get around it somehow
12:54:19 <lispy> n^2 :)
12:54:31 <jle`> still by using (^2) :P
12:54:36 <jle`> (^2) n
12:54:53 <lispy> (^2) $ n
12:55:09 <lispy> $ for clarity, or something
12:55:31 <lispy> Guest23559: extra-include-dirs?
12:57:12 <Guest23559> lispy: Yeah, I'm aware of this field. But is it a good idea to specify it? I can't be sure that a user would install a C library to the same directory.
12:58:17 <roboguy_> Guest23559: wouldn't it be likely that they would install it into something that is in their include path? How could they use it otherwise?
12:59:26 <Guest23559> roboguy_: Yeah, I feel the same way. Just trying to avoid false assumptions.
12:59:41 <Guest23559> OK, I'll stick to includes and extra-libraries, then. Thanks!
13:02:45 <lispy> Guest23559: you can also specify --extra-include-dirs and --extra-library-dirs on the command line
13:03:09 <xintron> How can I invert the match like: dropWhile (< 10) [1,2,10,11]; using not? (bad example maybe but it should still be valid)
13:03:10 <lispy> Guest23559: That's usually what I do when a package fails due to pathing difference
13:03:38 <Guest23559> lispy: OK, thanks for explaining.
13:03:42 <lispy> do you want > or "not less than" (which is >=)
13:04:03 <bernalex> gawd. how do I rewrite "concatMap output <$> mapM readFile files" to also send files to output?
13:04:14 <bernalex> well, really, I don't want files, but the file being read.
13:04:18 <bernalex> (filename)
13:04:25 <xintron> lispy, the actuall example is dropWhile (isTagOpenName "foo") and I want to drop as long as the name is NOT foo
13:05:06 <lispy> So you want (\f -> not (isTagOpenName "foo" f)), right?
13:05:15 <lispy> ?pl (\f -> not (isTagOpenName "foo" f))
13:05:15 <lambdabot> not . isTagOpenName "foo"
13:05:23 <Guest23559> lispy: Finally, is it fine to specify base using == in build-depends, or should I use >=?
13:05:24 <lispy> lambdabot: to the rescue!
13:05:49 <lispy> Guest23559: use a range unless it only works on a specific ghc release
13:05:53 * lispy has to go
13:06:25 <xintron> lispy, exactly. Thanks!
13:06:58 <Guest23559> So can I safely use base >=4.6.*?
13:07:00 <roboguy_> bernalex: I'm not sure I follow
13:07:36 <bernalex> roboguy_: let me paste some context
13:08:03 <bernalex> roboguy_: http://lpaste.net/8786754384621993984 -- I now want output to take the FilePath of the file I send it as a String
13:08:40 <bernalex> so I want to turn output into output ::  FilePath -> String -> String. right now it is just output ::  String -> String. my question is how do I rewrite the "concatMap output <$> mapM readFile files" to accomplish this.
13:09:50 <bernalex> (I'm going to use something else for interact, so don't worry about interact output.)
13:14:23 <ParahSailin_> how do you use haddock on projects containing happy and alex parsers?
13:16:24 <merijn> Is there a version of "connectTo" that returns a Socket instead of a Handle?
13:16:51 <ParahSailin_> ah, cabal haddock does the magic
13:16:52 <merijn> Or is there another convenient way to figure out the IP of the host you connected to?
13:17:24 <bernalex> hm. actually. how do I just get the [FilePath] and file contents [String] to a function?
13:18:48 <bernalex> I do input <- getArgs to get a list of files. how do I send the filepaths and contents to a function that takes [FilePath] and [String]?
13:18:51 <ParahSailin_> merijn: i think you might have to create socket and then connect http://hackage.haskell.org/package/network-2.4.2.1/docs/Network-Socket.html
13:19:25 <tac> bernalex: if getArgs has type IO [String], then input will have type [String]
13:20:00 <merijn> ParahSailin_: Blah
13:20:02 <bernalex> tac: I'm not sure I see your relevance"
13:20:09 <ParahSailin_> merijn: some wrappers for convenience here http://hackage.haskell.org/package/network-simple-0.3.0/docs/Network-Simple-TCP.html
13:20:14 <roboguy_> bernalex: how about something like: outputFiles files = concat <$> mapM (\x -> output x <$> (readFile x)) files
13:20:54 <bernalex> roboguy_: it's a bit too terse than I'd like given my current skill (not to talk about my skill in two days, rereading this stuff)
13:21:13 <tac> bernalex: I'm not sure I understand your question then
13:21:17 <bernalex> roboguy_: also, right now I'd like [FilePath] [String], or [(Filepath, String)].
13:21:35 <roboguy_> bernalex: what do you mean?
13:21:53 <bernalex> tac: well, how do I get the file contents to a function that takes [String]?
13:21:59 <tac> You have a list of strings. You need a list of FilePaths (which are strings) and Strings (which are also strings)
13:22:06 <merijn> ParahSailin_: That's less useful, all the convenience wrappers get in the way of the stuff I actually wanna do
13:22:32 <ParahSailin_> merijn: thats how it always is
13:22:32 <bernalex> roboguy_: I want my function to take either [FilePath] and [String], or [[FilePath, String)]. I guess the latter is the best.
13:22:45 <bernalex> roboguy_: so [(the path to the file, the contents of the file)]
13:22:52 <roboguy_> bernalex: oh I thought you wanted FilePath -> String -> String
13:22:54 <bernalex> roboguy_: and I use input <- getArgs to get the file paths.
13:23:01 <bernalex> roboguy_: sorry for the confusion
13:23:03 <tac> bernalex: So you read in the list of... files in your args? Is that how you want it to work?
13:23:31 <bernalex> tac: the program would be invoked like "program file1 file2 file3"
13:23:50 <bernalex> tac: then I want a function to get [(file path, file contents)]. so the path and content of each file.
13:23:53 <tac> If you want to do a [(FilePath, String)], you probably want to use zip
13:23:54 <tac> @type zip
13:23:54 <tac> (lambdabot?)
13:23:54 <lambdabot> [a] -> [b] -> [(a, b)]
13:24:03 <tac> ty lambdabot
13:24:17 <tac> So using zip, you have your list of files as the [a]
13:24:32 <tac> And you need to somehow come up with your list of contents for each file
13:24:35 <tac> that becomes your [b]
13:24:53 <tac> and zip gives you the list of (filepath, filedata) pairs
13:25:00 <bernalex> well, you are telling me all the things I actually know how to do, not how to do the things I'm struggling with. :-)
13:25:16 <tac> Well, what is the issue then?
13:25:31 <bernalex> I could zip input and mapM readFile input, but the latter is [IO String] not [String] -- for one.
13:26:03 <roboguy_> bernalex: you can use sequence to turn [IO String] into IO [String]
13:26:22 <roboguy_> then fmap to lift a function from a -> b to IO a -> IO b
13:26:23 <tac> @type mapM readFile
13:26:24 <lambdabot> [FilePath] -> IO [String]
13:26:43 <tac> that looks like what you want, right?
13:26:52 <bernalex> tac: minus the IO.
13:26:54 <Wardje> Is there a way to check line per line (sorta) what type what variable is?
13:27:01 <bernalex> it's the lifting I am having trouble with.
13:27:10 <tac> so you do fileDatas <- mapM readFile input
13:27:11 <tac> then fileDatas is a [String]
13:27:11 <tac> bernalex: that's what the <- does for you
13:27:12 <roboguy_> bernalex: you probably want fmap for this
13:27:25 <bernalex> roboguy_: I assume so, yes. I'm not however entirely sure "where to put it"
13:27:31 <bernalex> so if I do e.g. handleFiles $ zip files (mapM readFile files)
13:27:46 <roboguy_> bernalex: well, where is the function that needs to work with IO that doesn't already?
13:27:47 <bernalex> then that last part will be IO [String]. how do I lift that with fmap?
13:28:08 <bernalex> what?
13:28:24 <bernalex> do you mean handleFiles? it's handleFiles ::  [(FilePath, String)] -> String
13:28:26 <Luke> how to I tell ghc-mod that I'm using cabal sandbox? it can't seem to find what I install from there
13:29:00 <roboguy_> :t \files -> zip files (mapM readFile files)
13:29:01 <lambdabot>     Couldn't match type `IO' with `[]'
13:29:01 <lambdabot>     Expected type: FilePath -> [String]
13:29:01 <lambdabot>       Actual type: FilePath -> IO String
13:29:07 <roboguy_> :t \files -> fmap (zip files) (mapM readFile files)
13:29:08 <lambdabot> [FilePath] -> IO [(FilePath, String)]
13:29:46 <roboguy_> now we have IO [(FilePath, String)] and a function that is [(FilePath, String)] -> String
13:30:50 <bernalex> roboguy_: I have http://lpaste.net/7379741352063401984
13:30:54 <tac> bernalex: I'm like 90% sure your problem is a matter of: you need to use another <- in your do notation to turn an IO thing into just a thing.
13:31:32 <bernalex> roboguy_: the problem here is Couldn't match type `[(FilePath, String)]' with `(FilePath, String)', so... I'm only getting one (path, contents)
13:31:35 <roboguy_> bernalex: that is close but we need a IO [(FilePath, String)] -> IO String, not [(FilePath, String)] -> String
13:31:49 <bernalex> roboguy_: what, why?
13:33:06 <bernalex> roboguy_: and, where?
13:33:22 <roboguy_> bernalex: wait, I may have misread that sorry. hold on...
13:33:29 <bernalex> roboguy_: NP
13:36:42 <bernalex> I don't understand why it's (FilePath, String) and not [(FilePath, String)]. if I do it in ghci it is right... I think.
13:37:33 <roboguy_> bernalex: well, let's start by giving outputFiles a type signature. that helps sometimes
13:37:34 <bernalex> I do let a = ["1","2"] :: [FilePath], and then :t fmap (zip a) (mapM readFile a) is IO [(FilePath, String)].
13:37:49 <bernalex> roboguy_: OK
13:38:28 <roboguy_> we know that it takes FilePaths and it needs to use the IO monad in the result
13:39:10 <bernalex> it does? why does it have to use IO in the result?
13:39:22 <bernalex> putStr takes a String
13:40:20 <roboguy_> but you are using >>=
13:40:28 <roboguy_> and also reading from a file is an IO action
13:40:42 <roboguy_> :t (>>=)
13:40:43 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:41:09 <roboguy_> so >>= takes a "monadic value", a function from a regular value to a monadic value and gives you a monadic value
13:41:22 <bernalex> right, so outputFiles :: [FilePath] -> IO String?
13:41:26 <roboguy_> yep!
13:42:02 <roboguy_> so, if we just look at "fmap (zip files) (mapM readFile files)" for a second and ignore handleFiles for the moment...
13:42:12 <roboguy_> :t \files -> fmap (zip files) (mapM readFile files)
13:42:13 <lambdabot> [FilePath] -> IO [(FilePath, String)]
13:42:54 <roboguy_> we see that we have a IO [(FilePath, String)] and we need an IO String. We also have handleFiles :: [(FilePath, String)] -> String
13:43:25 <bernalex> so we need to lift it from IO when passing it to handleFiles, and erm put it back (IDK the terminology here, sorry) when we're done?
13:43:27 <roboguy_> so, essentially we have a function [(FilePath, String)] -> String and we need a function IO [(FilePath, String)] -> IO String
13:43:46 <bernalex> right.
13:43:49 <roboguy_> :t fmap
13:43:49 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:43:56 <roboguy_> IO is also a Functor
13:44:33 <roboguy_> so, in the specific context of IO, fmap :: (a -> b) -> IO a -> IO b
13:45:41 <bernalex> I wanna say "fmap handleFiles (fmap (zip files) (mapM readFile files))", but something tells me that's naïve...
13:45:59 <bernalex> I know you shouldn't nest maps like that, but I'm just interested in making it type check at all right now, hehe.
13:46:13 <roboguy_> bernalex: nope, that should be right!
13:46:20 <sm> XB*TERM
13:46:25 <roboguy_> as far as I know, nesting maps is ok
13:47:02 <roboguy_> well, I guess you could combine them, but that shouldn't really matter too much
13:47:19 <bernalex> roboguy_: roboguy_ I tend to do that, but that's not a big problem/focus right now so that's fine.
13:47:41 <bernalex> OK, so I have a bunch of errors. are you aware of them? :-P or should I paste my updated code and the errors
13:48:00 <roboguy_> bernalex: you should probably post them, because it looks ok on my end
13:48:17 <roboguy_> *paste them
13:48:24 <danilo2> Hello! Could somebody help me with TemplateHaskell issue? Its very strange - when I'm generating a TH code (and preview it using --ddump-splices) it looks exactly like it should - even If I copy paste it (from splice) instead of generating it works, but when it is generated there is compilation error about missmatched kinds
13:48:39 <bennofs> danilo2: can you show the code?
13:48:45 <roboguy_> bernalex: one thing I notice is handleFiles takes one argument but you have two
13:48:54 <danilo2> bennofs: of course, brb
13:48:58 <bernalex> roboguy_: some million errors here http://lpaste.net/4968262496923156480
13:49:04 <roboguy_> bernalex: also, you can just say "handleFiles = undefined". undefined is a nice placeholder
13:49:21 <bernalex> I know about undefined, but thanks
13:49:37 <bernalex> stub actually prints something if I want to test the program :-)
13:49:40 <danilo2> bennofs: Ok, give me 3 minutes to clean it up
13:50:14 <bernalex> roboguy_: why do you say I have two arguments? I thought (fmap (zip files) (mapM readFile files)) was one argument
13:50:33 <roboguy_> bernalex: in: handleFiles _ _ = "stub"
13:50:42 <bernalex> oh, right, sorry
13:50:53 <bernalex> top errors still apply though
13:51:25 <roboguy_> bernalex: also, outputFiles should give a IO String
13:51:31 <bernalex> can't I just do     _ -> putStrLn $ outputFiles input
13:51:33 <roboguy_> remember, you can't escape IO
13:51:33 <bernalex> ?
13:51:46 <bernalex> oh, my mistake
13:52:05 <bernalex> that fixes... everything
13:52:29 <bernalex> wow... thanks so much!
13:52:37 <roboguy_> bernalex: sure! no problem
13:53:00 <bernalex> roboguy_: I rewrote outputFiles to do, handleFiles . zip files <$> mapM readFile files
13:53:44 <roboguy_> bernalex: cool, that looks a lot nicer
13:54:13 <danilo2> bennofs: Here it is: http://lpaste.net/97452 . It should compile and work
13:55:54 <danilo2> bennofs: If you "runHaskell -ddump-splices Main.hs" you'll get error "The third argument of ‛Member’ should have kind ‛*' (...)". Andif you replace the TH call with ddumped splice, it works ...
13:57:52 <bennofs> danilo2: hmm, wait, I need to install pretty-show ...
13:58:14 <danilo2> bennofs: of course :) Thank you, you are looking at it :)
14:00:36 <bernalex> roboguy_: uhm another question, in handleFiles, shouldn't "map (foo . snd) xs"... work, when foo is a String -> String function?
14:01:48 <bernalex> (foo . snd) should be "(a, String) -> String", to my understanding
14:01:59 <roboguy_> bernalex: yeah, it would be
14:02:10 <roboguy_> so map (foo . snd) xs :: [String]
14:02:15 <bernalex> I get "Couldn't match type `[Char]' with `Char'"
14:02:27 <bernalex> Expected type: String -> Char, Actual type: String -> String
14:02:33 <roboguy_> bernalex: the return type is String and "map (foo . snd) xs" is [String]
14:02:37 <bernalex> In the first argument of `(.)', namely 'foo'.
14:02:39 <roboguy_> so you might want concatMap
14:02:45 <bernalex> oh!
14:02:56 <bernalex> of course. thanks.
14:03:37 <bernalex> roboguy_: unlines $ map (foo . snd) xs -- does the job
14:04:14 <roboguy_> ah, yeah
14:04:36 <bernalex> roboguy_: oh, actually, not. because foo already does "\n". so concatMap it is. :-)
14:05:28 <bennofs> danilo2: you forget one ' in front of Vector_testid
14:05:37 <bennofs> danilo2: you want to refer to the type, not to the constructor :)
14:07:06 <danilo2> bennofs: No way ... I was searching what is happening here for over an hour ... heh
14:07:47 <danilo2> bennofs: Could you reveal how you found it? You just saw the lack? Because the errors are not informative at all
14:09:10 <bennofs> danilo2: I looked at the source code, saw a ConT and somehow thought "How does it know if it refers to the type or value constructor?". Then I remembered that there was only one '. I also noticed before that it was probably using the value constructor, because the error looked like a promoted kind
14:12:05 <danilo2> bennofs: I'm very thankfull for your help! Thank you for spending your time on this problem and helping me! :) I will be vey careful with this in the future :)
14:13:15 <danilo2> bennofs: I see now, that this happened, because I need to pass both ''Vector_testid and 'Vector_testid - if I want to implement the type class function in TH. I remember I was using double apostrophe before in this place, heh :)
14:15:34 <teneen> Does having functions as first-class citizens in a pure language have any advantage of the same in non-pure languages?
14:15:46 <teneen> advantage over**
14:16:26 <roboguy_> teneen: you know that the functions are referentially transparent in a pure language which can be nice
14:16:59 <teneen> besides purity
14:17:36 <teneen> can side-effects ruin higher-order functions? degrade their usage?
14:17:41 <merijn> teneen: Not more so than purity in general has
14:17:59 <bernalex> roboguy_: thanks for your help. I now have a fully functional wc program. albeit a bit... spaghetti atm. :-)
14:18:02 <merijn> teneen: Potentially it could, but haskell has first-class side effects too :)
14:18:07 <bernalex> also performance is terrible :-D
14:18:10 <roboguy_> teneen: well, it's really just like the other advantages of purity
14:18:40 <roboguy_> bernalex: no problem!
14:18:50 <merijn> teneen: You can even parameterise your side-effects over other side-effects :)
14:18:50 <Hodapp> I always try to make sure to be as smug as possible when saying 'purity'.
14:19:02 <Hodapp> merijn: QUIT HURTING MY HEAD.
14:19:27 <aristid> Hodapp: sounding properly smug is very important for being a proper fp afficionado indeed
14:19:29 <merijn> Yo dawg!
14:19:35 <Hodapp> doge?
14:19:54 <merijn> We heard you like side-effects, so we put side-effects in your side-effects, so you can side-effect while you side-effect!
14:20:03 <Hodapp> aristid: It's 'aficionado'.
14:20:09 <ParahSailin_> seems like haddock doesnt like hyperlinking to type synonyms in other packages
14:20:14 <teneen> merijn: what's an example of this?
14:20:36 <aristid> Hodapp: thanks for the correction
14:20:56 <merijn> teneen: Suppose I have a program that repeatedly gets a line of input. I want to be able to get input from a socket, a file or stdin
14:21:06 <Hodapp> aristid: Of course. Being an FP aficionado, I put *such* a focus on correctness.
14:21:17 <Hodapp> aristid: I really feel that it makes the world a better place.
14:22:02 <merijn> teneen: I can just write my code as "myLoop :: IO String -> IO ()" where the "IO String" reads a line. Now myLoop can run that action multiple times (infinitely, even) without needing to know whether that "IO String" is implemented using sockets, stdin or files
14:22:58 <merijn> teneen: The key insight is that the "IO String" is a fully first-class value that you can pass around throughout your program and use wherever you like
14:22:59 <yogert> Is it possible to automatically derive instances of Aeson.FromJSON for data types with fields of type "Either a b
14:23:00 <yogert> "
14:23:01 <yogert> ?
14:23:14 <teneen> merijn: yeah I see
14:23:18 <merijn> teneen: See for example this code in ghci: "map print [1..] !! 3"
14:23:30 <merijn> :t map print [1..]
14:23:31 <lambdabot> [IO ()]
14:24:39 <merijn> teneen: The neat thing is that you can construct side-effects without running them. Which means you can do things like implementing proper short-circuiting too (i.e. only execute an action if another action was false, or whatever)
14:25:28 <bernalex> is there a neat way to get right-adjusted output?
14:26:02 <merijn> I thought there was a pretty printer for Text somewhere
14:26:07 <Hodapp> merijn: for Text?
14:26:36 <merijn> @hackage pretty
14:26:36 <lambdabot> http://hackage.haskell.org/package/pretty
14:26:42 <bernalex> I have a data type with three Ints. I need to print all of these and align them nicely, like wc does.
14:27:05 <merijn> hmm, I guess that uses Strings
14:27:06 <roboguy_> bernalex: printf could do that
14:27:29 <roboguy_> it is functionally more or less like C's printf if you're familiar with that
14:27:40 <bernalex> roboguy_: I'll look into it
14:28:36 <bernalex> my... not very elegant function right now does format (counter:cs) = "  " ++ show (lin counter) ++ " " ++ show (wor counter) ++ " " ++ show (cha counter) ++ format cs
14:28:50 <bernalex> it was just something I wrote to make it display stuff, heh
14:29:06 <bernalex> counter is the data type with three ints.
14:29:35 <yogert> For example, given a datatype "data Foo = Foo { bar::Either Int Bool }", and automatically constructing my FromJSON instance with "$(deriveJSON defaultOptions ''Foo)". I can't seem to code JSON looking like "{ bar: 1}". Is there any way to do this?
14:33:32 <mmmm> Say I was writing a monadic evaluator for an assembly like language, what's the best approach to deal with jump statements
14:33:33 <roboguy_> bernalex: hmm, yeah but that won't adjust with the number sizes. it would be easiest to use printf for that
14:35:02 <bernalex> roboguy_: I'm not sure how to do that. GNU wc seems to output each file as it finds it (not print everything to a buffer, format it, print it to stdout). how does wc know how long the longest number will be?
14:35:48 <roboguy_> bernalex: I think they just picked a certain max length. Looks like it might be 8 characters
14:36:27 <bernalex> roboguy_: no.
14:36:42 <bernalex> roboguy_: oh, wait
14:37:05 <bernalex> roboguy_: I got confused by how wc has different format for STDIN than files. maybe you are right. though it seems to be 10 here, not 8.
14:38:01 <bernalex> roboguy_: so I could maybe build a [String], and recurse with a pattern match for (lin:wor:cha:path:xs) = printf stuff neatly formatted ++ "\n" ++ recurse, or somethnig
14:39:10 <roboguy_> bernalex: I would store those different fields as either a tuple or fields in a data constructor, but otherwise yeah something like that
14:39:51 <roboguy_> if you store them as part of the list and the list isn't a multiple of 4 (if there's a bug, for instance) it will have a non-exhaustive pattern match
14:39:55 <bernalex> roboguy_: they are in a data constructor
14:40:09 <bernalex> right
14:40:17 <roboguy_> ah, ok
14:40:39 <roboguy_> bernalex: the newline can go inside the printf as well, but that general format looks right
14:40:44 <bernalex> yep
14:43:00 <roboguy_> bernalex: another possibility is you could just print it directly, instead of building up a String first
14:43:15 <bernalex> roboguy_: I'm leaning towards that
14:43:22 <bernalex> it's simpler, and it's what GNU wc does
14:43:32 <kinslayer> hmm are there any koans for haskell ?
14:47:12 <bernalex> roboguy_: evidently IDR how to do this in C. I thought it was %.8d, but uhm, that prints out a bunch of zeros instead of just aligning
14:47:51 <bernalex> oh just %8d
14:48:28 <bernalex> roboguy_: wc does indeed do some clever form of adapting though.
14:48:49 <bernalex> wc on /var/log/messages has a lot more space than for my test files (which have very small numbers).
14:51:04 <kinslayer> are there anything for haskell like the koans in ruby or clojure ?
14:52:28 <roboguy_> bernalex: get rid of the .
14:52:31 <Cale> > fix error
14:52:32 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
14:52:38 <bernalex> roboguy_: I fixed that, but thanks.
14:53:19 <bernalex> I now have a... fully-ish working wc implementation in <40 lines. but without GNU wc's clever alignment.
14:54:50 <yogert> kinslayer: I haven't seen anything quite like it.
14:56:08 <yogert> kinslayer: A quick google search brought up a few results though. Including: https://github.com/HaskVan/HaskellKoans
14:56:33 <Aetherspawn> Hi, how do I get a list from a list of each value and the remaining values excluding
14:56:42 <Aetherspawn> ie, the first order permutations or something like that
14:56:55 <kinslayer> how is it that I didn't find that in my search ?
14:57:00 <Aetherspawn> [1..3] -> (1, [2,3]), (2, [1,3]), (3, [1,2])
14:57:11 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in select [1..3]
14:57:13 <lambdabot>  [(1,[2,3]),(2,[1,3]),(3,[1,2])]
14:57:21 <jle`> her'es  aprelude function that does this actually
14:57:23 <jle`> i think
14:57:26 <Cale> no
14:57:28 <Aetherspawn> thanks, is there something in prelude that does this better?
14:57:30 <Aetherspawn> oh
14:57:30 <Cale> There isn't.
14:57:42 <bennofs> > liftA2 zip inits tails $ init $ tail [1,2,3]
14:57:43 <yogert> kinslayer: heh, no clue. : P It was the second result for "Haskell Koans" for me
14:57:44 <lambdabot>  [([],[2]),([2],[])]
14:57:52 <Cale> I've asked for this to be in Data.List before
14:57:54 <bennofs> > init $ tail $ liftA2 zip inits tails $ [1,2,3]
14:57:55 <lambdabot>  [([1],[2,3]),([1,2],[3])]
14:58:02 <kinslayer> okay, your bubble is different from mine...
14:58:03 <kinslayer> :D
14:58:03 <bennofs> hmm
14:58:10 <Cale> There are a few other useful variations on it as well
14:58:13 <Aetherspawn> yeah it'd be useful
14:58:34 <Cale> (and of course, you can generalise it using differentiation of data structures if you add a class for that)
14:59:02 <yogert> Yeah perhaps, also, I find the Wiki to be a pretty good place to look for stuff
14:59:09 <Cale> But I think this version on lists is somewhat important enough on its own to be in Data.List
14:59:09 <kinslayer> or what did I search for, when I thought I searched for "haskell koans" nobody knows (except google)...
14:59:14 <yogert> that is, the wiki on haskell.org
14:59:29 <mightybyte> Why is Control.Monad.when fixed to unit instead of being m a -> m a?
14:59:34 <kinslayer> since I just researched again, and this time a very extensive lists of resources popped out...
14:59:42 <bennofs> mightybyte: what happens if the condition is False?
14:59:48 <mightybyte> Grrr
14:59:55 <mightybyte> bennofs: Yeah, I guess so.
15:00:01 <Peaker> bernalex: though it is more a topic for this channel than #-blah :)
15:00:10 <kinslayer> yogert: the koans on the wiki is mostly poems ?
15:00:12 <Cale> It could produce a Maybe value instead
15:00:19 <bernalex> Peaker: ?
15:00:22 <Peaker> bernalex: if you paste your code maybe I can give some feedback
15:00:34 <Peaker> bernalex: I thought you were talking about wc in Haskell?
15:00:36 <bernalex> Peaker: oh, right. no I think I want to figure it out by myself. or at least try to, first.
15:00:44 <Peaker> bernalex: ah, ok, cool :)
15:01:01 <bernalex> Peaker: thanks though!
15:02:10 <Cale> kinslayer: What do you mean by koans, if not something dealing with Zen?
15:02:42 <kinslayer> look at the ruby koans (small snippets of code with small errors designed to help the student learn)
15:04:03 <kinslayer> cale: but ultimately it probably still helps the novice obtain zen, so in that respect it is still dealing with zen :D
15:04:32 <fwappy> What's the advantage of "ap"? In RWH, they show an example of "ap" in infix style alongside "liftM" in a way that reminds me of applicative style. Can't one just use applicative style, where "(<$>)" corresponds to "liftM" and "(<*>)" corresponds to "ap"?
15:05:05 <yogert> kinslayer: Oh, well I don't know about the koan entry on the haskell wiki, but I do find that it is a good resource for finding things relating the the haskell ecosystem
15:05:06 <bennofs> fwappy: unfortunately, Applicative is not a super class of monad yet
15:05:26 <kinslayer> yogert: I would agree with that...
15:05:54 <fwappy> So it comes down to a question of class restraints?
15:06:02 <bennofs> fwappy: so if you write generic functions that already use the Monad interface, using liftM and ap requires no additional constraints, but using (<*>) and (<$>) requires an Applicative constraint
15:06:51 <bennofs> instead of writing `function :: Monad f => f a -> f a` I have to write `function :: (Monad f, Applicative f) => f a -> f a` when using (<*>) and (<$>)
15:07:01 <tovarish> liftM is <*> ?
15:07:12 <fwappy> bennofs: yeah, ok. Kinda silly but I get it.
15:07:13 <bennofs> no, liftM = fmap = (<$>) = liftA
15:07:28 <tovarish> :t liftM
15:07:29 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
15:07:37 <Peaker> bennofs: or you can use this hack: https://github.com/Peaker/lamdu/blob/master/bottlelib/Control/MonadA.hs#L6-L7  and then: (MonadA f) => ...
15:07:37 <bennofs> fwappy: Note that this will finally be fixed in GHC 7.10, where we will get Applicative as a supper class of Monad! :)
15:07:44 <tovarish> how many fmap is there in Haskell?
15:07:48 <mauke> :t [liftM, fmap, (<$>), liftA]
15:07:48 <lambdabot> (Monad m, Applicative m) => [(a1 -> r) -> m a1 -> m r]
15:07:55 <jmbto> http://lpaste.net/97457 >> hi, is there such a thing as a "WordString" in Haskell?
15:08:08 <jmbto> if possible, I wouldn't like to tamper with the FFI
15:08:15 <fwappy> If i can see how liftM + ap looks like applicative style, maybe i'm on the right track. :)
15:08:32 <Peaker> :t [liftM, fmap, (<$>), liftA, flip (<&>)]
15:08:33 <lambdabot> (Monad m, Applicative m) => [(a1 -> r) -> m a1 -> m r]
15:08:47 <aristid> Peaker: what's wrong with type MonadA m = (Monad m, Applicative m)?
15:09:04 <Peaker> aristid: it requires adding {-# LANGUAGE ConstraintKinds #-} to *every* module that uses it
15:09:18 <bennofs> jmbto: what's a WordString?
15:09:19 <Peaker> aristid: whereas this only requires explicit extension enabling in the MonadA.hs itself
15:09:20 <fwappy> tovarish: in fact fmap is preferred over liftA and liftM when you can get away with it.
15:09:27 <aristid> Peaker: meh
15:09:39 <Peaker> aristid: and compatibility with older GHC's
15:09:58 <aristid> Peaker: my LANGUAGE list is usually a grab bag of things that ghc asked me to enable at some point, with no regard to whether it's still needed :D
15:10:00 <Peaker> aristid: but I like to keep track of which extensions my modules actually rely on
15:10:14 <Peaker> aristid: (So I don't put them in my .cabal file but in each module)
15:10:32 <aristid> Peaker: putting them in the module makes using ghci easier too
15:10:37 <mmmm> Say I was writing a monadic evaluator for an assembly like language, what's the best approach to deal with jump statements
15:10:38 <aristid> unless you use cabal ghci always
15:10:58 <aristid> Peaker: -XEverything
15:10:59 <jmbto> bennofs: like a array of integers I guess
15:10:59 <fwappy> On an unrelated note, I've decided to learn vim. Is vim as a Haskell development environment hard to set up?
15:11:02 <identity> mmmm: how are you representing your memory, etc?
15:11:06 <identity> is it a list?
15:11:13 <jmbto> *an
15:11:13 <bennofs> jmbto: so maybe ByteString?
15:11:32 <identity> fwappy: no, it isn't, but it's awesome to work with IMO
15:11:37 <jmbto> bennofs: I tried that, but the result is modulo 255
15:12:03 <jmbto> since they are bytes
15:12:07 <mmmm> yes as a list
15:12:28 <identity> mmmm: well, I implemented a brainfuck interpreter in haskell a long time ago
15:12:31 <identity> I used a zipper
15:12:51 <fwappy> identity: nice, i was googling around and found a Haskell mode, which looked like it boils down to a long config file last touched in 2010; is that what I want?
15:13:18 <identity> fwappy: You want ghcmod, probably
15:13:39 <identity> fwappy: that lets you typecheck and hlint your code on each save(or when you want)
15:13:45 <fwappy> Ah interesting, I'll look for that, thanks.
15:13:55 <identity> I use YouCompleteMe for completion
15:14:04 <fwappy> I definitely want hlint onceach save, hlint is my best friend
15:14:27 <identity> fwappy: and vim2hs
15:14:37 <identity> which is.. not perfect, but the maintainer is working on a rewrite if I'm not mistaken
15:14:54 <mmmm> ok thanks
15:14:58 <mmmm> I'll look into it
15:15:01 <fwappy> identity: I'll check them out, awesome.
15:15:01 <identity> Then I use an assortment of other mods which are not specific to haskell
15:15:27 <identity> fwappy: oh, and syntastic, that gives you syntax checking with errors pointed out in code and so on
15:15:42 <fwappy> identity: any others you would strongly recommend?
15:16:00 <mmmm> :q
15:16:42 <identity> fwappy: well, tabularize is nice as well, and having stylish-haskell is nice as well, if you like the way it lays out your imports and so on.
15:17:00 <identity> otherwise.. I don't think so
15:17:16 <jle`> i like tabularize, syntastic, vim0haskellmode, vim2hs
15:17:18 <jle`> hm
15:17:22 <jle`> and i have a lot of general purpose ones
15:17:28 <jle`> of course
15:17:34 <jle`> but tnose are the ones especialyl useful for hs
15:18:00 <identity> jle`: you don't use ghcmod-vim?
15:18:00 <jle`> wow what is wrong with my fingers
15:18:24 <jle`> i think i might have plopped it down at some point
15:18:31 <fwappy> jle`: is it vimhaskellmode?
15:18:38 <jle`> maybe
15:18:59 <identity> i don't believe I use haskellmode because it's ancient and bitrotted iirc
15:19:11 <identity> or maybe vim2hs incorporates haskellmode, I'm not sure
15:19:15 <jle`> hm. yeah none of it never really worked for me
15:19:19 <jle`> haskellmode
15:19:21 <fwappy> haskellmode is what I found I think
15:20:21 <jle`> but yeah i couldn't live without syntastic
15:21:06 <fwappy> Do Mac users typically prefer the gui Macvim?
15:21:18 <jle`> there's a tags extension that shows you what function you are currently in irrc
15:21:23 <jle`> with powerline or airline
15:21:43 <bennofs> jle`: O.O do you have functions so big that you don't see the header?
15:22:47 <yogert> I've found ghc-mod + syntastic to be a bit sluggish. Is it a problem for you guys?
15:22:56 <jle`> haha no. just listing off plugins that integrate
15:22:57 <seanparsons> identity: How do you use YouCompleteMe with Haskell?
15:27:12 <jle`> oh yeah i use NeoComplCache
15:27:15 <jle`> i use the heck out of that
15:27:20 <identity> seanparsons: I will admit not having done very much configuring of ycm, but it basically just does completion depending on what I've already typed
15:27:29 <identity> i never really got neocomplcache to work
15:27:32 <identity> properly, anyway
15:27:40 <jle`> works flawlessly for me
15:27:41 <jle`> hm
15:27:45 <seanparsons> Yeah, I had grief with ncc.
15:27:46 <jle`> yeah it has proven indepsnesible
15:27:57 <jle`> oh :/
15:28:15 <seanparsons> I'm gonna have another look at it now.
15:28:35 <identity> ncc?
15:28:47 <identity> iirc, ycm toted itself as a replacement for that very addon
15:28:54 <jle`> yeah that might be the case
15:28:57 <roboguy_> fwappy: I don't know about vim, but I usuall use the graphical Emacs for OS X
15:29:25 <fwappy> I used to be an Emacs guy, but no more
15:29:53 <identity> youcompleteme does some cool automatic tag parsing ish stuff for python when I write that, and java iirc
15:30:17 <roboguy_> I kind of like Sublime these days, but SublimeHaskell keeps crashing on me. hopefully they'll fix that soon
15:30:54 <fwappy> roboguy_: I've been using sublime for monthsnow, but I'm making the switch to vim
15:31:27 <fwappy> You can get a lot of mileage out of sublime
15:31:34 <xmodem> Hi there.  I'm trying to remember the name for the category of functions where when the output of that function is passed back to the function as its input then the output is guaranteed to be the same as the input
15:31:39 <roboguy_> fwappy: you wouldn't happen to have any tips about stabilizing SublimeHaskell would you?
15:32:03 <aristid> identity: i find ycm a bit unstable in combination with clang completion :/
15:32:04 <roboguy_> xmodem: a fixed point?
15:32:18 <fwappy> roboguy_: I've never had issues on my Mac. What are your issues?
15:32:51 <identity> aristid: I haven't used it for c or c++, but I've run into it doing some silly redrawing stuff sometimes, so that the entire buffer blinks every time I type something
15:32:52 <roboguy_> fwappy: sometimes it's pretty slow and other times it says the plugin crashed
15:32:59 <identity> aristid: but that usually goes away on its own
15:33:11 <roboguy_> xmodem: or idempotent maybe?
15:33:40 <identity> roboguy_: iirc, idempotence is basically sort(list) = sort(sort(list))
15:33:41 <aristid> identity: i've had it crash completely and fill the screen with red lines. i've had it slow down vim so much that i need to wait seconds for a keypress to show up (in insert mode)
15:34:04 <identity> aristid: ah, too bad. I haven't run into any such things. but it does depend on compiled components -- maybe those are the cause?
15:34:20 <roboguy_> identity: that's pretty much what he's saying isn't it? or am I misunderstanding?
15:34:20 <fwappy> roboguy_: hmmm... I'm not sure what to tell you. I've seen that subl is slow to start up at times, otherwise I've never had issues. Are you using the latest version of the plugins and GHC?
15:34:36 <aristid> identity: maybe, i don't know. veteran users claim it got worse when ycm switched to client-server
15:34:40 <identity> roboguy_: I'm thinking he's basically looking for a function that is also its inverse
15:34:54 <identity> x = f . f $ x
15:35:04 <roboguy_> fwappy: I think so. Actually, how can I check to see if plugins are up-to-date/update them if they're not?
15:35:05 <identity> aristid: ah, don't know really
15:35:10 <aristid> negation!
15:35:32 <xmodem> roboguy_ & identity - fixed point combinator sounds like what what i'm after i think
15:35:55 <fwappy> roboguy_: not exactly sure; are you Mac or Windows or Linux or what?
15:36:01 <roboguy_> fwappy: Mac
15:36:11 <xmodem> this wikipedia page will solve my problem - thanks guys!
15:37:02 <identity> though the identity function also fulfills his requirements :P
15:37:33 <fwappy> ok, well, type Cmd+P for command pallete, then try typing things to indicate what cmd you might be looking for, such as update or plugin or what have you. Sorry, i'm hardly an expert :(
15:38:32 <roboguy_> fwappy: that's okay! good luck learning vim! I've never gotten used to the two typing mode thing that it has
15:38:46 <roboguy_> *two typing modes
15:39:16 <fwappy> Thnks
15:39:24 <jle`> welcome to the club fwappy :)
15:39:40 <fwappy> Haha, awesome!
15:39:48 <fwappy> I appreciate it.
15:39:57 <identity> vim is the only way
15:40:02 <jle`> one of us
15:40:06 <jle`> one of us
15:40:13 <ion> What’s “club fwappy”? ;-)
15:41:06 <jle`> it's pretty chic...i wouldn't be surprised if you haven't heard of it, it's kinda underground.
15:41:33 <msavoury> i've been lurking in this channel for days and this is the first time i can contribute to the topic: Vim
15:41:43 <msavoury> i'm still haskell newb
15:41:44 <fwappy> Fwappy is the name of one of my guinea pigs. I'm on my android tablet at the moment, when i'm not, I go by the handle "stolaruk", which is my last name.
15:42:36 <identity> jason stolaruk
15:42:36 <fwappy> msavoury: whats up
15:42:46 <fwappy> Uh yeah
15:42:50 <ion> fwappy: reverse "stolaruk" sounds like Finnish.
15:42:54 <fwappy> Did you google me?
15:42:57 <identity> yep
15:43:00 <identity> just for fun
15:43:08 <ion> just for stalk
15:43:12 <identity> "stolaruk haskell" -> twitter
15:43:13 <identity> yep.
15:43:23 <fwappy> Well you found me :)
15:43:29 <jle`> the name rings a bell, you've been here a a few times haven't you?
15:43:51 <identity> i almost got thrown out of class once when I googled my teacher who wouldn't tell us her age and I discovered it from some .. marathon stuff she'd partaken in
15:43:57 <fwappy> Yes i've been on here with my (newbie) questions.
15:45:07 <fwappy> I'm working on a MUD in Haskell :)
15:45:14 <jle`> oh
15:45:19 <jle`> i told you to use vim
15:45:22 <jle`> for haskell
15:45:24 <jle`> on december 4th
15:45:26 <jle`> haha
15:45:34 <fwappy> Haha! Did you?
15:46:57 <fwappy> Well I got me the O'Rielly Vim book and I'm on my way
15:48:11 <fwappy> My goal over this holiday break is to make it thru all of RWH.
15:48:17 <jle`> good luck.  the folkds on #vim and stack overflow are always pretty helpful.  just take it one step at a time.  and learn to do as much as you can using text objects/movements :)
15:48:17 <msavoury> fwappy: how is it?
15:48:21 <msavoury> i have vi improved
15:48:41 <jle`> fwappy: how is RWH?
15:48:49 <jle`> is it as dated as people say
15:48:49 <msavoury> no the O'reilly vim book
15:48:53 <msavoury> i have RWH
15:48:57 <msavoury> it's awesome
15:49:01 <fwappy> jle`: i have a lot of fun with text editors, it's gonna be a good time. :)
15:50:07 <augur> koninkje_away: you know, im getting buzzed quite a lot, and i thought it was my highly flammable commentary on the turing pardon, but no, its you and your type theory nonsense. if only you'd get back from away on irc so we could REALLY talk about this! and if only kristopher would get on irc at all!
15:51:26 <fwappy> jle`: after reading LYAH, i must say RWH comes across as an unnecessarily difficult book that was clearly written by 3 different ppl. But it's taught me a handful of very important points. Just seems that they gloss over the most difficult areas. Reading the reader comments in the online version helps a lot.
15:52:17 <fwappy> As most ppl do, I'd very strongly recommend reading LYAH first.
15:52:18 <Rembane> fwappy: What important points has it taught you?
15:52:26 <jle`> yeah i started reading it but got a little bored, i still use the chapters every once in a while as a reference though
15:53:32 <jle`> i do recommend simon marlow's Parallelism/Concurrency text though, if for nothing else than a nice look at practical haskell idioms and idiomatic code
15:53:37 <fwappy> Rembane: well for example I just went thru the profiling chapter, i was able to reduce the execution time of my program to about 1/4th of what it used to be by following the hints and tips in RWH.
15:53:41 <jle`> and how to approach things
15:54:27 <jle`> and plus it is relatively new, so the style is up to date
15:55:07 <koninkje> augur: oh alright. Though I really should be working on my last qual
15:55:32 <koninkje> augur: we should prolly get a room or something lest we flood this channel though
15:55:46 <augur> koninkje: yes cause tweeting a million things is "working on my last qual" :P
15:56:01 * koninkje :P
15:56:15 <augur> koninkje: #typetheory
15:56:24 <augur> its just ezyang in there right now, and me
15:56:58 <Rembane> fwappy: Nice! I really like the profiling chapter, it lets me solve more Project Euler problems. :)
15:58:49 <Eduard_Munteanu> Is 'a -> b c' different from 'a -> b, a -> c' as fundeps?
15:59:04 <fwappy> Rembane: another example, RWH pointed out, somewhat in passing, how =<< can be used alongside a "pipe" of composed functions for readability; I don't think that was ever mentioned in LYAH.
15:59:06 <augur> xplat: #typetheory is probably a good place to go, bee tee dubs
15:59:08 <Saizan> Eduard_Munteanu: nope
15:59:27 <Eduard_Munteanu> Interesting, thanks. I expected them to be, though.
15:59:31 <fwappy> Rembane: there are a handful of such benefits I've gleaned from RWH
15:59:57 <Saizan> Eduard_Munteanu: a b -> c and a -> c, b -> c differ
16:00:18 <Eduard_Munteanu> Yeah.
16:02:48 <Rembane> fwappy: Ah, that's very handy.
16:03:03 <fwappy> Yes indeed.
16:05:40 <Rembane> I think it's fun that Haskell usually is read from right to left, until you start using Monads which are read from left to right, or up to down depending on style.
16:06:10 <fwappy> Well it's about dinner time here, gonna take off; thanks for chatting !
16:06:18 <benmachine> Rembane: you can read Haskell left-to-right, in a manner of speaking
16:06:18 <kinslayer> Okay I did something really stupid
16:06:23 <benmachine> it's all a matter of perspective
16:06:42 <kinslayer> Somehow I broke a lot of packages in hackage, so now I need a way to fix it
16:07:23 <kinslayer> basically everything depending on crypto-api-0.12.2.1
16:07:54 <benmachine> kinslayer: what did you do
16:08:20 <kinslayer> as I said something stupid, basically I had a trouble with the package above so I removed it
16:08:32 <kinslayer> it was saying it had possibly created dublets...
16:08:55 <benmachine> ok so when you say you broke a lot of packages in hackaage
16:08:58 <benmachine> you don't mean you broke Hackage
16:09:01 <benmachine> you broke your own stuff :P
16:09:05 <kinslayer> nono locally
16:09:07 <kinslayer> yeah
16:09:12 <jle`> thank you for clarifying benmachine
16:09:22 <Rembane> benmachine: I think this is a quite good example of right to left: let znum = zip [1..] in (unlines . znum . sort . lines)
16:09:25 <quchen> Locally that's not Hackage, that's your package database.
16:09:25 <jle`> i was about to pull out my local backup of hackage
16:09:34 <Rembane> benmachine: How do I read this from left to right?
16:09:40 <kinslayer> jle` yeah good idea :D
16:09:57 <quchen> m >>= return . f  --  Both ways!
16:10:04 <benmachine> Rembane: I dunno, I think what I read first is "unlines . [...] . lines" so I go "ok, this function does something to the lines"
16:10:14 <kinslayer> possibly this is a good reason to upgrade to newer version of the haskell platform
16:10:16 <benmachine> "what does it do to the lines? it numbers the sorted lines"
16:10:37 <quchen> First of all it's a type error.
16:10:38 <jle`> benmachine: you can also think of it as 'it merges together the thing to the thing to the lines of the text'
16:10:46 <benmachine> jle`: right
16:10:49 <Rembane> benmachine: Ah, that's a good way.
16:11:05 <kinslayer> How would I go about installing a newer version of Haskell-Platform ?
16:11:19 <kinslayer> I need to get a newer compiler, and I am not entirely clear on how I do that
16:11:21 <quchen> kinslayer: Depends. How is your current version installed?
16:11:39 <kinslayer> from the OS package manager
16:11:50 <kinslayer> (fyi I use Mint)
16:11:56 <quchen> And there's no new version in the repos?
16:12:13 <quchen> What version are you using anyway?
16:12:21 <kinslayer> I don't think the one that is works with my current compiler
16:12:26 <kinslayer> 2012.8 I think
16:12:31 <kinslayer> some 2012
16:12:39 <quchen> And GHC?
16:12:39 <kinslayer> ghc-7.4.2
16:12:51 <quchen> That sounds compatible then.
16:13:14 <quchen> (In fact I'd be surprised if the package manager let you install incompatible GHC+Platform.)
16:13:15 <kinslayer> well the platform things says I need 7.6 to compile the most modern platform
16:13:29 <kinslayer> quchen: yeah that would be suspicious
16:13:31 <quchen> The Platform is tailored to a specific GHC release, yes.
16:13:42 <quchen> In particular the binary releases are ;-)
16:13:54 <jle`> i would just build ghc and haskel platform from scratch
16:13:58 <kinslayer> can I just download the binary and install the platform ?
16:14:14 <quchen> Sure
16:14:35 <quchen> You'll need GHC (binary release is available) and the Platform tarball
16:14:36 <kinslayer> hmm that should be simple then, well I will ask if I need help :D
16:14:50 <kinslayer> yeah I was just gonna get the binary GHC
16:14:57 <quchen> Then do the usual configure, make, make install process
16:15:16 <kinslayer> then I should put the ghc bin in the path :D
16:16:06 <jle`> is there some equivalent for checkinstall
16:16:08 <jle`> for mint?
16:16:17 <jle`> just to make sure you have a clean/easy way to clean up/uninstall
16:16:27 <quchen> kinslayer: See also this http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
16:16:41 <quchen> And this https://github.com/quchen/articles/blob/master/install_haskell_platform_manually.md
16:17:32 <kinslayer> and I just happened to have the current compiler laying around :D
16:19:28 <kinslayer> oh yeah that was the reason I didn't install it already
16:19:35 <kinslayer> I need the gmp library]
16:19:57 <quchen> So install libgmp
16:19:59 <quchen> -dev
16:20:08 <danilo2> Hello :) I want to ask you, what is the procedure to update a package on hackage if I'm npot its author? Should I contact the autor even if package is not touch for 5 years? I'm talking about OneTuple (http://hackage.haskell.org/package/OneTuple-0.2.1) which is very trival thing, but it is implemented as Data type, not newtype, which not optimal
16:20:09 <kinslayer> I think I tried that
16:20:54 <kinslayer> hmm libgmp is set to manually install ?
16:21:09 <quchen> danilo2: newtype would have different strictness properties.
16:21:51 <quchen> The docs state that "OneTuple has the expected laziness properties", which presumably means "like 2-tuples but with only 1 element".
16:22:11 <quchen> That said, the usual 1-tuple is Identity.
16:23:12 <jle`> danilo2: you should probably ocntact the author, or if it's on github, submit a pull request
16:24:16 <danilo2> quchen: hmm, I did not think that way before. Could you tell me more about these properties? Are you talking about the fact, that newtype keeps the underlying type without packing it "in additional layer" and when we evaluate it, we evaluate only this layer until we need something deeper? (I know this is not the best description, but hope it is understable)
16:25:08 <danilo2> jle`: Thank you. Maybe this would not be needed, because quchen noted something I was missing :)
16:26:35 <quchen> danilo2: It's a bottom thing.  Identity ⊥  = ⊥, but OneTuple ⊥ /= ⊥.
16:28:03 <danilo2> quchen: Ok, and in practical point of view? What gives us this solution over newtype when using it?
16:28:53 <benmachine> there's almost no circumstance when you /can/ use newtype but /shouldn't/
16:29:09 <RichyB> benmachine, I've seen one. :)
16:29:15 <quchen> Hence "almost".
16:29:23 <benmachine> RichyB: still interested, what was it?
16:29:27 <RichyB> benmachine, data Box a = Box { unBox :: a }
16:29:33 <benmachine> danilo2: to your case I'd say, just don't use that package?
16:29:50 <johnw> benmachine: if you want to make your type lazy, you shouldn't use newtype
16:29:50 <johnw> lazier
16:29:50 <benmachine> johnw: uh, explain
16:29:58 <benmachine> johnw: precisely what kind of laziness are you talking about, and why is the situation better with data
16:29:59 <johnw> well, with newtype Box a = Box a, a is evaluated whenever Box a is
16:30:03 <RichyB> That was to get around a library that was `seq`ing a value that it shouldn't have
16:30:10 <johnw> but with data Box a = Box a, a is not evaluated when Box a is
16:30:14 <benmachine> johnw: when do you ever want to evaluate the box without evaluating the contents?
16:30:21 <johnw> pattern matching
16:30:26 <RichyB> I wanted to knot-tie, but the early seq call made it loop instead.
16:30:38 <benmachine> RichyB: ah, that does make sense, but I hope you'd agree that's rather a niche use
16:30:46 <johnw> it's a subtle distinction, I'm just saying that it exists and is a real distinction
16:30:50 <benmachine> well, I won't be very upset if you disagree :P
16:30:55 <sinclair|work> vagrant up
16:30:59 <benmachine> johnw: explain what you mean by "pattern matching"
16:30:59 <sinclair|work> ops
16:31:02 <RichyB> sinclair|work, good idea, wrong window :D
16:31:16 <johnw> benmachine: if I have a Box a, and pass it to a function like this: foo (Box a) = a
16:31:18 <benmachine> johnw: why would you want to pattern match on such a value, if you didn't intend to evaluate it?
16:31:25 <RichyB> benmachine, oh and maybe GADTs are another example.
16:31:26 <johnw> whether a is evaluated or not will depend on whether Box is a newtype or a data
16:31:41 <benmachine> RichyB: you can have, er, GANTs, I think
16:31:59 <benmachine> johnw: sure, I know what the distinction *is*, but why would you *want* it
16:32:07 <johnw> benmachine: http://stackoverflow.com/questions/13566673/laziness-strictness-between-data-and-newtype
16:32:12 <RichyB> A GADT can, when a pattern-match succeeds, add new information to the type checker's view of the world, but pattern-matching on newtypes succeeds unconditionally.
16:32:18 <benmachine> johnw: I wrote this article http://www.haskell.org/haskellwiki/Newtype
16:32:23 <johnw> http://stackoverflow.com/questions/9293882/yet-another-newtype-vs-data-stylistic-issue
16:33:04 <johnw> benmachine: mind you, I agree with your main point
16:33:07 <RichyB> I really don't want pattern-matching to succeed unconditionally if I'm passing around a value that's meant to be used as a type equality witness, for example. :)
16:33:10 <johnw> i always try to use newtype if I can
16:33:25 <benmachine> RichyB: ah, that's interesting
16:33:45 <benmachine> but of course you can't implement type equality as a newtype because it is nullary
16:33:48 * benmachine hmms
16:34:19 <RichyB> I didn't think GANTs were a feature?
16:34:38 <benmachine> RichyB: yeah, that's kinda my mistake
16:34:52 <benmachine> RichyB: you can define newtypes with GADT syntax but they're basically massively restricted compared to data
16:35:10 <RichyB> Ah, so it's just for syntactic uniformity. That makes sense.
16:35:29 <benmachine> I'm not certain on that point, but it sounds about right
16:35:33 <RichyB> Aside, I quite like the GADT syntax even though I don't use the GADT feature very much.
16:35:37 <benmachine> yeah
16:35:42 <Eduard_Munteanu> RichyB: it basically has to be isomorphic to the wrapped type, no more or less
16:35:45 <benmachine> did you know you can enable it separately from GADTs?
16:35:46 <rose> I'm trying to increment a count in a db and then return IO () when I'm done. Why does this code show this error? http://lpaste.net/97461
16:35:58 <kinslayer> somehow my system wont install libgmp :(
16:36:02 <Eduard_Munteanu> RichyB: and moreover have the same representation at runtime
16:36:33 <benmachine> "A newtype constructor must have a return type of form T a1 ... an" ← so I guess they're basically not generalised
16:37:07 <quchen> Wait, now I'm confused. Why does this not crash? http://lpaste.net/97462
16:37:27 <jle`> i don't know, is it really the best question to ask why you want want something to be lazy when you are in a language that is lazy by default?
16:37:42 <jle`> you could just refer to the motivation of laziness in general
16:37:47 <Peaker> quchen: pattern-matching a newtype constructor is a no-op
16:37:57 <benmachine> quchen: replace the case scrutinees with just "undefined" to see a difference
16:38:14 <Peaker> case undefined of Newtype _ -> .. won't crash, iiuc
16:38:16 <Eduard_Munteanu> rose: I think the Nothing and Just count cases types don't match
16:38:25 <quchen> Peaker: Is that a semantic subtlety or a GHC optimization?
16:38:26 <benmachine> jle`: who's asking that question?
16:38:36 <Eduard_Munteanu> rose: namely that 'run pipe...'
16:38:38 <benmachine> quchen: it's the semantics of newtype
16:38:41 <rose> Eduard_Munteaunu: thanks
16:38:57 <Peaker> quchen: newtype cons/decons being a no-op is the explicit semantics of newtypes
16:39:04 <johnw> rose: which line in that paste is line 168?
16:39:08 <quchen> Good to know, time to read the report again
16:39:12 <benmachine> quchen: note that the restriction that newtypes can only have a single unary constructor is exactly what you need to make it make sense to do nothing on pattern-match
16:39:23 <rose> johnw: I commented it in the code
16:39:29 <benmachine> quchen: read this instead http://www.haskell.org/haskellwiki/Newtype :>
16:39:33 <johnw> ah, just saw it :)
16:39:45 <quchen> benmachine: That's a mess.
16:39:58 <benmachine> quchen: which
16:40:47 <quchen> I think the report is often very clear compared to other sources.
16:40:52 <Peaker> quchen: I've never read the report.. :P I let my brain accumulate tidbits that eventually color the whole canvas (I hope) :)
16:41:13 <benmachine> the report is pretty nice, to be fair
16:42:30 <quchen> It's also much more normative than the Wiki
16:43:23 <benmachine> yeah I mostly only recommend that article because I want people to like it because then I'll feel better about having written it :P
16:43:29 <benmachine> it's not even that good >_>
16:43:40 <benmachine> I really think the wiki should be developed as a resource, though
16:43:52 <benmachine> obviously it can go into much more detail than the report et al
16:45:25 <quchen> It's also much easier to learn unrelated stuff by accident when reading the report ;-)
16:48:58 <lightquake> so, I've been messing around with pipes, and one thing I haven't really found a use for is the return value from a pipe
16:49:24 <johnw> lightquake: imagine a consumer which is a fold
16:49:29 <johnw> you'd want the final result of th efold
16:49:47 <lightquake> ah
16:50:30 <johnw> otherwise, how can that value escape the pipeline?
16:51:06 * kinslayer is getting a new haskell-platform :D
16:51:07 <lightquake> use the State monad and execStateP it? :D
16:51:16 <johnw> haha, fair enough ;)
16:51:19 <johnw> IORefs!
16:51:32 <quchen> johnw: With unsafePerformIO!
16:51:37 <johnw> or serialize it to a file and read it back after
16:51:41 <lightquake> i actually have a 200LOC IRC bot that uses pipes both for the networking and for the 'modules'
16:52:40 <lightquake> data Module = Module String (Pipe IRC.Message IRC.Command IO ())
16:52:51 <lightquake> where the String is the module name, used for debugging
16:54:17 <hatds> I accidentally typed a 'cabal install foo' command that I shouldn't have done.  Now I need to undo the installation and everything it fetched.  Do I have to manually create a list of installed stuff and unregister them?
16:54:26 <seanparsons> jle`: Have you had any issues with neocomplete just not talking to neco-ghc?
16:55:12 <quchen> hatds: Cabal doesn't have an uninstallation feature.
16:56:05 <benmachine> hatds: I have a script for this somewhere
16:56:29 <johnw> cabal-delete does a very nice job
16:56:38 <hatds> Thanks, but it's a manageable size list.  It makes me fear what would happen if it wasn't though.
16:56:41 <johnw> https://github.com/iquiw/cabal-delete
16:56:51 <johnw> i like that it recursively deletes too
16:56:55 <johnw> and removes documentation
16:57:53 <lightquake> each module operates in its own thread and receives every message, yielding however many responses it wants
16:59:01 <lightquake> and then there's one thread that distributes incoming messages and one that pulls messages off the outgoing queue and replies to the server. so there's n+2 threads, where n is the number of loaded modules
16:59:58 <johnw> sounds like there should be a pipes-based actors library
17:00:15 <johnw> I wonder if Cloud Haskell has looked at pipes
17:00:30 <johnw> i know it uses channels that you can pass to the actor to receive back-propagated results
17:01:16 * lightquake should probably write up a blog post about how it works
17:02:07 <johnw> uses pipes to write it
17:02:43 <lightquake> haha
17:03:10 <lightquake> lightquake :: Producer BlogPost IO ()
17:03:22 <quchen> ()?
17:03:37 <quchen> Better make that "r", you're never done learning after all ;-)
17:03:57 <jle`> seanparsons: afraid i can't help you too much, it seemed to work fine with it just out of the box
17:04:00 <jle`> have you installed ghc-mod?
17:04:04 <jle`> on cabal
17:04:38 <seanparsons> Yeah, nothing is complaining, it is only completing based on the contents of the file however.
17:04:54 <seanparsons> So imports are only populated with the existing imports and so on.
17:05:01 <jle`> hm
17:05:32 <jle`> are they even haskell tokens?
17:05:50 <jle`> or are they just like lexemes used in the file
17:05:58 <jle`> language-agnostically
17:06:01 <lightquake> quchen: haha
17:06:22 <jle`> does it complete language pragmas for you?
17:06:31 <Eduard_Munteanu> Can Symbol (type-level string literals) be concatenated?
17:08:29 <seanparsons> jle`: Ah, interesting, language pragmas work, but everything else looks a little like it's been picked up like a ctag, with some context like imports are separate to functions and the like.
17:08:34 <Eduard_Munteanu> Hm...
17:08:36 <Eduard_Munteanu> newtype instance Sing (n :: Symbol) = SSym String
17:08:45 <Eduard_Munteanu> But... data Symbol
17:09:14 <Eduard_Munteanu> Oh, it is indeed that.
17:11:01 <jle`> seanparsons: try import Data. ... etc
17:11:08 <jle`> does it load the module names?
17:11:26 <seanparsons> Nope, just sees Data.Bits and Data.Time.Clock in there.
17:11:34 <seanparsons> Which is what I already have.
17:11:45 <jle`> hm.
17:11:51 <seanparsons> Yeah... :/
17:11:53 <jle`> is your haskell platform up to date? ghc-mod up to date?
17:12:04 <jle`> just shooting in the dark here, i really don't know what's going on too much.
17:12:39 <jle`> try :NeoCompl<Tab> and seeing if anything that pops up might be relevant to you :)
17:15:04 <seanparsons> I've tried a couple of things, nothing seemed to have any effect.
17:16:44 <seanparsons> Oddly I thought I had this working in Emacs too, but now that doesn't seem to be working...
17:17:15 <johnw> are you using sandboxes or anything like that?
17:17:47 <seanparsons> I'm using the cabal sandbox.
17:18:07 <johnw> did you build your ghc-mod insid that sandbox?
17:18:24 <seanparsons> Oooh, now that's a good point.
17:18:29 <johnw> yeah, bites me all the time
17:18:30 <seanparsons> No I didn't IIRC.
17:19:56 <seanparsons> Quite how I'm going to get vim to look at that ghc-mod however is an entirely different issue.
17:20:22 <johnw> it doesn't use your PATH?
17:20:33 <johnw> oh, that's right, sandboxes are tied to cabal
17:20:45 <johnw> I'm still used to the way that hsenv takes over a lot of the environment
17:21:28 <seanparsons> This feels...suboptimal would be my political response. :)
17:21:45 <johnw> ghc-mod could use better sandboxing support, yes
17:21:57 <johnw> but I've found that all the utilities I use which are based on GHC API suffer from a similar problem
17:22:18 <johnw> there seem to be certain package-related details which get "baked in" to the executable depending on the environment its compiled in
17:22:57 <Eduard_Munteanu> Why is there no GHC.Prim documented on hackage.haskell.org for GHC 7.6.x ?
17:22:57 <johnw> i'll often see problem with "Text" not matching "Text", because the version that was in the environment where I compiled ghc-mod is different from the versions in my sandbox, that sort of thing
17:23:06 <johnw> all of which is solved by just building the utility within the sandbox
17:28:35 <benmachine> Eduard_Munteanu: it moved out of base to a package that isn't on Hackage
17:29:01 <benmachine> arguably the docs for ghc-prim could be uploaded to hackage manually like those of base
17:29:05 <benmachine> but I guess no-one did that
17:31:02 <Eduard_Munteanu> Ah, thanks.
17:35:03 <AshyIsMe> wow Fay looks really cool
17:35:10 <AshyIsMe> 24 days of hackage is such a good series
17:35:13 <AshyIsMe> ocharles: you rock!
17:35:50 <johnw> yes, 24 days is a great series; it's introduced be to a few cool things I would have never found otherwise, like SBV
17:36:37 <jle`> ocharles++
17:39:23 <dmj`> if I have a function foo = flip map [1..10], and I say bar = show . bar, why is the type inferred as (Integer -> ()) -> String, and not Show b => (Integer -> b) -> String. When I add the type signature explicity it works fine, but by default why does ghc infer (Integer -> ())?
17:39:47 <dmj`> bar = show . foo
17:39:48 <shachaf> @google monomorphism restriction
17:39:48 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
17:39:48 <lambdabot> Title: Monomorphism restriction - HaskellWiki
17:39:54 <Eduard_Munteanu> @where dmr
17:39:54 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
17:41:27 <dmj`> thanks
17:42:54 <jle`> why don't more things have contravariant instances
17:44:08 <johnw> jle`: what do you think should have it but doesn't?
17:47:48 <lispy> what is a contravariant instance? (laws, intuition, typical examples, etc)
17:48:27 <Eduard_Munteanu> Contravariant functors on *.
17:48:32 <johnw> ilspy: newtype Op a b = Op (a -> b) is the classic
17:48:38 <johnw> sorry, Op b a
17:48:56 <johnw> i.e., you can map over the input type, rather than the output type
17:49:07 <Iceland_jack> lispy: . o O (every math/CS text book should have large paragraphs on how to gain intution for a given concept)
17:49:14 <lispy> johnw: ah
17:49:32 <augur> johnw: mmm i smell a lemma lurking :3
17:49:49 <lispy> Iceland_jack: and what would those paragraphs say?
17:50:14 <johnw> laws: contramap id = id; contramap f . contramap g = contramap (g . f)
17:50:25 <Eduard_Munteanu> Basically Hask^op -> Hask as functors on categories.
17:50:57 <augur> monoid in the category of endofunctors
17:50:58 <RichyB> lispy, examples, pictures and slightly-leaky analogies.
17:51:05 <lispy> Eduard_Munteanu: I'm not (yet) competent enough with CT to make sense of your remarks :)
17:51:06 <RichyB> I like that idea.
17:51:25 <augur> haha, called it :)
17:51:29 <augur> lispy: catsters
17:51:47 <johnw> lispy: it's a Functor with the arrows flipped, so contramap :: (a -> b) -> f b -> f a
17:52:10 <lispy> johnw: cool. I think I groked it once you said "i.e., you can map over the input type, rather than the output type"
17:52:25 <johnw> yeah, for the function instance that intuition works nicely
17:52:51 <Eduard_Munteanu> lispy: do you know functors? Covariant functors are what you normally call functors C -> D. If a functor flips arrows, you can call it a contravariant functor and it can be written as C^op -> D, if C^op is the opposite category of C (same as C with arrows flipped).
17:53:14 <jle`> lispy: there is a recent 24 days of hackage entry on it
17:53:19 <augur> lispy: contravariance is more general than just that tho. the contramap type is most important.
17:53:51 <augur> lispy: just think of contravariant functors as functors that reverse arrows, sorta kinda. thats really what they do.
17:53:58 <lispy> k
17:54:01 <Eduard_Munteanu> (->) is contravariant in the input type and covariant in the output type
17:54:04 <lispy> Thanks everyone
17:54:09 <augur> with pictures between categories:
17:54:25 <johnw> lispy: clearly we want to talk about them more :)
17:54:29 <Eduard_Munteanu> (In CT you call that Hom(-, -))
17:54:41 <johnw> we need somebody to take lispy's place and just ask us about contravariance
17:55:21 <augur> X ---f---> Y
17:55:21 <augur> |          |
17:55:21 <augur> F          F
17:55:23 <augur> |          |
17:55:25 <augur> v          v
17:55:27 <augur> FX --Ff--> FY
17:55:29 <augur> lispy: ^
17:55:33 <augur> thats F being covariant
17:55:41 <augur> contravariant has Ff going in the other direction
17:56:04 <augur> bee tee dubs, this really belongs in ##categorytheory
17:56:22 <jmcarthur> but i like category theory in #haskell :(
17:56:56 <lispy> augur: and is Ff the only arrow that changes direction in that picture?
17:57:26 <nooodl> yup
17:57:28 <augur> lispy: in that picture, yes, but its not fixing X and Y and f, its just a schema
17:57:39 <kholdstare_> lispy: Don't know how the conversation was started, but I found the explanation here to be pretty intuitive: http://ocharles.org.uk/blog/guest-posts/2013-12-21-24-days-of-hackage-contravariant.html
17:58:14 <augur> X ---f---> Y
17:58:14 <augur> |          |
17:58:15 <augur> F          F
17:58:16 <augur> |          |
17:58:18 <augur> v          v
17:58:20 <augur> FX <--Ff-- FY
17:58:22 <augur> lispy: ^
17:58:24 <augur> for contravariant F
17:59:21 <Eduard_Munteanu> Though typically the source category is ^op, so 'f' would be "backwards" wrt your choice of orientation.
18:00:12 <augur> or is ^op the result of the contravariant ID functor? :O
18:01:26 <Eduard_Munteanu> I guess you could say that... I've seen -^op.
18:01:39 <augur> theres that as well!
18:01:55 <lispy> kholdstare_: thanks
18:02:03 <lispy> kholdstare_: yeah does have good exmaples
18:02:24 <kholdstare_> lispy: no prob :)
18:05:49 <lispy> if Funtor has instance Functor [] where fmap = map, is there a corresponding instance Contravariant [] where = ??
18:06:00 <shachaf> No.
18:06:20 <shachaf> If f has both a Functor instance and a Contravariant instance, then the "a" in "f a" is phantom.
18:07:06 <augur> yes.
18:07:32 <augur> well, not in haskell
18:07:41 <augur> but in category theory that's certainly true
18:07:48 <Eduard_Munteanu> Maybe you mean only in Haskell?
18:07:57 <cdk> Eduard_Munteanu: I've seen the notation Hom(-,-) or similar before, but I don't know what it means. Care to explain it for me?
18:08:11 <augur> cdk: Hom(-,-) is easy
18:08:15 <nooodl> aiui f(-,-) is like \x y -> f(x,y)
18:08:16 <augur> the -'s are where objects go
18:08:16 <shachaf> cdk: It means \x y -> Hom(x,y), roughly
18:08:36 <shachaf> Eduard_Munteanu: Oh, I didn't see that there was any context to lispy's question.
18:08:54 <cdk> so its a function or its more like forall x y. Hom(x,y)
18:09:00 <augur> cdk: not quite a function
18:09:02 <Eduard_Munteanu> cdk: Hom(-,-) :: C^op -> C -> Set
18:09:03 <augur> but kind of like a function
18:09:46 <cdk> so Hom(Set, -) is just fixed in one of its arguments?
18:09:53 <Eduard_Munteanu> cdk: where Hom(A, B) means the set of arrows between A and B
18:10:05 <Eduard_Munteanu> In that particular category C.
18:10:15 <augur> cdk: right, yes
18:10:28 <shachaf> Eduard_Munteanu: Well. It usually means a Functor to Set.
18:10:36 <cdk> okay, I think that clears it up for me :)
18:10:45 <shachaf> s/F/f/
18:10:48 <shachaf> Where the more important attribute of a functor is where it maps the arrows, not the objects.
18:11:15 <Eduard_Munteanu> Yes, sure, I was defining Hom for some context.
18:11:43 <shachaf> I didn't read the context so maybe I'm just being unhelpful right now.
18:11:46 <Eduard_Munteanu> (assuming locally-small C)
18:12:14 <shachaf> Aha, <lispy> what is a contravariant instance? (laws, intuition, typical examples, etc) </lispy> is the original context.
18:12:30 <shachaf> lispy: I can probably help with that if it hasn't been clarified yet.
18:12:37 * lispy likes lispy tags </lispy
18:12:46 <lispy> shachaf: it has
18:13:01 <lispy> shachaf: It's clearly a tortilla
18:13:13 <shachaf> OK, then I won't give my examples and intuitions.
18:13:21 <lispy> shachaf: from which you can build a monad^H^H^H^H^Hburrito if you're incline
18:13:23 <lispy> +d
18:13:38 <lispy> gah, my scarcasm lock was on
18:13:56 <lispy> I hate it when my keyboard gets stuck in that mode :/
18:13:59 <Iceland_jack> @hackage burrito
18:13:59 <lambdabot> http://hackage.haskell.org/package/burrito
18:14:18 <shachaf> Burrito jokes make me want to leave this channel forever.
18:14:23 <simpson> bunzen: Eduard_Munteanu
18:14:28 <simpson> Wow, thanks keyboard.
18:14:40 <lispy> shachaf: my intent was to make fun of the burrito jokes. So does that still count?
18:14:56 <shachaf> Yes.
18:15:03 <lispy> :/
18:15:30 <danil`> join :: Joke (Joke Burrito) -> Joke Burrito
18:15:49 <Iceland_jack> Ah, the joke monad
18:16:10 <Eduard_Munteanu> I fear jokes only duplicate themselves.
18:16:11 * lispy waits for someone say it's cofunny
18:17:17 <Eduard_Munteanu> Aw, he left.
18:17:49 <lispy> I should do that too. I have lectures to watch: http://scs.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx#folderID="07756bb0-b872-4a4a-95b1-b77ad206dab3"
18:17:58 <lispy> That's Bob Harper's HoTT Lectures
18:19:19 * Eduard_Munteanu bookmarks
18:20:01 <lispy> Eduard_Munteanu: you can also get to that page by googling bob harper and then scrolling down to his list of courses
18:21:10 <kholdstare_> Hi everyone, I have a question about subclassing instances. I have a situation where ghc suggests adding "UndecidableInstances" which i want to avoid, but I don't know how to get around it. The problem is in the Monoid instance: http://lpaste.net/97465
18:22:07 <kholdstare_> it could also be that I'm doing it all wrong :) thanks for the help.
18:22:20 <lispy> kholdstare_: I have to admit, when I hear "subclassing instances" I red flag goes up.
18:23:26 <lispy> hmm
18:23:49 <Eduard_Munteanu> kholdstare_: what is Container?
18:24:01 <kholdstare_> good question
18:24:10 <kholdstare_> eveything's fro mthe hmatrix library
18:24:54 <kholdstare_> argh, it doesn't seem to expose the doc on hackage: http://hackage.haskell.org/package/hmatrix
18:25:10 <Eduard_Munteanu> It does for the next to latest version.
18:25:39 <kholdstare_> Eduard_Munteanu: What Container gives me is the "add" for vectors
18:27:14 <kholdstare_> Eduard_Munteanu: The gist of it is: I'm using hmatrix, and am describing Affine Transformations using a Matrix and a Vector. I'd like to compose these transformations. afMul does that, and requires some instances, (in particular Container which is giving me trouble). I would like to make a Monoid instance for these transformations, where mappend = afMul
18:28:16 <Jimx-> how do you indicate "no return value" in a function?
18:29:08 <Eduard_Munteanu> kholdstare_: try making a 'Container Vector e => Container AffineTransform3D e' instance first
18:29:20 <jle`> Jimx-: () ?
18:29:32 <simpson> Jimx-: What's your function do if it has no return value?
18:29:34 <kholdstare_> Eduard_Munteanu: I see, interesting
18:29:36 <Eduard_Munteanu> Jimx-: you can't, unless your function returns a Maybe or similar
18:30:08 <Eduard_Munteanu> Jimx-: or unless you really want to leave it undefined
18:30:19 <jle`> unless he means 'no `return`' value, as in the haskell monad definition of return hur hur
18:30:29 <Jimx-> I'm a total newbie, so my apologies for the rather strange question, I suppose I am just trying to "define" a function via function :: parameter -> return value syntax
18:30:41 <Jimx-> parameter type*
18:30:45 <jle`> Jimx-: what would your funcion 'do' if it doesn't return anything?
18:30:51 <jle`> remember that Haskell functions have no side-effects
18:30:57 <jle`> all they are is a map from one value to another
18:31:17 <jle`> can you define a mathematical function f(x) with no return value?
18:31:21 <Eduard_Munteanu> Jimx-: a function always has an input and an output type
18:31:39 <Eduard_Munteanu> Otherwise it would just be a value.
18:32:15 <Jimx-> ah okay, you are correct, that clears up that.  I'm still thinking in imperitive mindset I suppose
18:32:43 <Jimx-> imperative*
18:33:17 <Jimx-> thank you
18:35:24 <Eduard_Munteanu> kholdstare_: also, you can make a  class (Container t e) => IsAffineTransform3D t e   or something like that, and as a bonus it can be even more polymorphic.
18:36:13 <kholdstare_> Eduard_Munteanu: so t would take the place of Vector in that case?
18:36:30 <Eduard_Munteanu> Er, hold on.
18:37:22 <Eduard_Munteanu> kholdstare_: ah, yeah
18:38:51 <danil`> kholdstare_: I think you really do need UndecidableInstances for this. FlexibleInstances only goes as far as letting you write `instance (C1, ..., Cn) => C if all the Ci are strictly smaller than C (in total type variables / constructors), and if no type variable appears more often in a given Ci than in C
18:39:59 <Eduard_Munteanu> kholdstare_: actually, you can try   class IsAffineTransform3D e te | te -> e   instance (Container t e) => IsAffineTransform3D e (t e)   instance (IsAffineTransform3D e (t e)) => Monoid (t e)
18:40:08 <AshyIsMe> well, fay looks great on the site, good ol' cabal isnt having a bar of it though :/
18:40:11 <Eduard_Munteanu> That should fix types good enough.
18:40:35 <kholdstare_> danil`: hmm. I'm still shaky on when each is needed (Flexible vs Undecidable). Any good reference? Or should I just read up on the official docs?
18:41:10 <Eduard_Munteanu> kholdstare_: the docs are fine... FlexibleInstances is less controversial.
18:42:54 <flazz> is there a way to get a snapshot of a stacktrace of a running haskell app?
18:42:58 <Eduard_Munteanu> I think the fundep above should make it decidable though.
18:43:10 <shachaf> @where rts-xc
18:43:10 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
18:43:26 <shachaf> Not exactly what you asked for but perhaps something.
18:44:33 <flazz> shachaf: i think so thanks
18:44:58 <kholdstare_> Eduard_Munteanu: thanks for your help. I'm looking over your last suggestion. The class IsAffineTransform3D would then contain the "afMul" function? The te in that case would make the transform polymorphic in the Vector type
18:45:12 <Eduard_Munteanu> kholdstare_: doh, the above can just be rewritten as  instance (IsAffineTransform3D e te) => Monoid te
18:46:06 <Eduard_Munteanu> kholdstare_: yes... te is the fully-applied thing, e.g. AffineTransform3D e
18:46:54 <kholdstare_> Eduard_Munteanu: I see... so in a way I have to wrap my AffineTransform3D in a class. I'll try that, thanks!
18:49:52 <Eduard_Munteanu> kholdstare_: more like generalizing it to a typeclass
18:50:21 * Eduard_Munteanu has to go, though
18:52:10 <kholdstare_> Eduard_Munteanu: alright, thanks for your help. Unfortunately "instance (IsAffineTransform3D e te) => Monoid te" also gives UndecidableInstances, because of the e type variable :(
18:52:43 <shachaf> That instance is not a good instance.
18:53:05 <shachaf> Instances are resolved without contexts.
18:54:31 <kholdstare_> shachaf: is there a good place to read up on the nitty-gritty details of instance resolution? I feel like im poking in the dark
19:22:06 <bmuk> hey everyone what is the best way to call a shell command on a list of words and then write a file with the original word, a tab, and the result of the shell command?
19:22:21 <bmuk> I have been looking at readProcess
19:22:50 <jfischoff> system is probably the simplest way
19:22:54 <jfischoff> @hoogle system
19:22:56 <lambdabot> System.Process system :: String -> IO ExitCode
19:22:56 <lambdabot> System.Cmd system :: String -> IO ExitCode
19:22:56 <lambdabot> package system-argv0
19:24:48 <bmuk> if you don't mind, could you look at my code, it's very short. I have a format function at the end and this is where I would like this to happen but I'm not sure how to deal with the IO monad
19:25:06 <bmuk> https://github.com/bmuk/Book2Words/blob/master/book2words.hs
19:26:21 <Iceland_jack> bmuk: you can import Text properly btw with
19:26:21 <Iceland_jack>     import Data.Text (Text)
19:26:29 <Iceland_jack> instead of the type synonym
19:26:31 <bmuk> I might have to refactor the whole thing or add a function near the top where the other IO functions are
19:26:39 <bmuk> Oh okay I didn't realize
19:27:00 <Iceland_jack> also there is a function for appending an extension to
19:27:05 <jfischoff> yeah I would just break up line 17
19:27:05 <Iceland_jack> @hoogle (<.>)
19:27:06 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
19:27:06 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
19:27:11 <jfischoff> no need to refactor everything
19:27:52 <jfischoff> get the output of parseBook and the call the function
19:27:54 <Iceland_jack> also bmuk, is getFrequency and orderWords needed?
19:27:55 <jfischoff> read the output file
19:27:57 <jfischoff> etc
19:29:16 <bmuk> Iceland_jack: this project is supposed to take a book in a foreign language and eventually output an anki deck of the words you must learn to read it
19:30:33 <bmuk> Iceland_jack: getFrequency gets all the unique words and how many times they are used and order words puts those in order most frequent -> least frequent
19:31:00 <bmuk> Iceland_jack: unless you mean I should combine them with parseBook or is there an easier way
19:40:36 <jle`> bmuk: foldl' (M.insertWith (+1) 1) M.empty
19:45:16 <bmuk> jle`: that's for getFrequency, right? Will that perform better than what I already have or is it simply clearer
19:46:42 <etrepum> jle`: that's not quite the signature of insertWith, and you'd want to make sure you're using the strict version of Data.Map for that use case
20:06:44 <qfjp> Hi guys, I have a quick question on types
20:06:50 <qfjp> why can I do this:
20:06:54 <qfjp> data TwoVector = TwoVector { components :: (Double, Double) } deriving Show
20:06:58 <qfjp> but not this
20:07:10 <qfjp> data TwoVector = TwoVector { components :: Num a => (a,a) } deriving Show
20:08:10 <mikeplus64> qfjp: you can, if you enable Rank2Types or RankNTypes
20:08:52 <qfjp> what is rank2types?
20:09:06 <mikeplus64> a language extension
20:09:25 <qfjp> I see, just to give full type clasess...everywhere?
20:09:57 <mikeplus64> http://www.haskell.org/haskellwiki/Rank-N_types
20:10:17 <qfjp> awesome, thanks
20:10:20 <mikeplus64> http://www.haskell.org/haskellwiki/Existential_type also this
20:10:48 <mikeplus64> the latter is the most relevant actually
20:11:01 <qfjp> alright, i'll check it out first
20:16:29 <slack1256> What is good reason to use HaTeX instead of LaTeX
20:16:43 <slack1256> Maybe I don't see a benefit I should be seeing
20:16:58 <srh_> what if you despise humanity
20:17:09 <srh_> it's better to hate than be late
20:17:20 <byorgey> qfjp: it is quite likely that    TwoVector { components : Num a => (a,a) }  doesn't mean what you think, or isn't what you want
20:17:32 <shachaf> hi srh_
20:17:51 <byorgey> qfjp: for example, if you have two such TwoVector values, there is no way to tell whether they are storing values of the same type
20:17:58 <byorgey> so you can never do arithmetic on them
20:18:11 <shachaf> Maybe I picked up all my bitterness from srh_.
20:18:30 <qfjp> hm...I didn't consider that
20:18:41 <byorgey> qfjp: you can, however, do this:   data TwoVector a = TwoVector { components :: (a,a) }
20:18:45 <qfjp> im still new to haskell, so I guess i forgot it wouldnt autocast
20:19:09 <qfjp> wouldnt that allow for a twovector with strings? or other data?
20:19:51 <byorgey> qfjp: yes, but for various technical reasons you don't want to restrict it to only Num in the definition of TwoVector.  Instead, use Num constraints on TwoVector operations
20:20:03 <byorgey> e.g.  addVectors :: Num a => TwoVector a -> TwoVector a -> TwoVector a
20:20:19 <qfjp> Ah, that makes sense
20:20:31 <qfjp> my next question was going to be how to fix the function type defs
20:20:37 <qfjp> thanks!
20:20:43 <byorgey> qfjp: put another way, there's nothing wrong with a TwoVector containing Strings.  You just can't e.g. add them.
20:21:24 <qfjp> hah I guess so, that still seems a little weird though
20:22:30 <byorgey> you get used to it.
20:22:37 <qfjp> fair enough
20:23:22 <shachaf> There are several things you could have meant but it's likely that none of them is as nice as what byorgey says.
20:24:06 <qfjp> I gotcha, I'm just still not used to functional programming
20:24:13 <qfjp> working my way through real world haskell
20:24:33 <byorgey> cool, have fun
20:24:47 <qfjp> thanks!
20:24:55 <qfjp> ill probably be back here often
20:30:16 <bmuk> I have attempted to write the definitions function I asked about earlier and I can't seem to get it to work
20:30:29 <bmuk> here's my progress
20:30:33 <bmuk> https://github.com/bmuk/Book2Words/blob/master/book2words.hs
20:31:15 <bmuk> I can't figure out how to combine the result of the shell call with my pure list of strings
20:31:57 <jfischoff> I thought the shell call wrote a file, do you want the stdout of the shell call?
20:32:21 <bmuk> yes, I'm trying to call a command line dictionary
20:32:34 <bmuk> readProcess should give me the stdout right?
20:33:18 <jfischoff> yes
20:33:51 <jfischoff> mapM_ is not what you want, you want mapM
20:34:42 <bmuk> @hoogle mapM
20:34:44 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:34:44 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:34:44 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
20:35:26 <jfischoff> @type mapM_
20:35:27 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
20:35:38 <jfischoff> mapM_ throws away the result
20:36:11 <bmuk> oh I see. That's why it's useful for just applying a function to arguments
20:37:10 <bmuk> I'm getting a couldn't match [] with IO on zipWith. I'm guessing that wordDefs is [IO String] instead of [String] and zipWith cant work on that?
20:39:13 <pavonia> bmuk: No, you're trying to apply liftM on something that isn't IO
20:39:49 <bmuk> I actually removed liftM since I commited
20:40:20 <bmuk> now the line reads: finish <- zipWith (++)  wordList wordDefs
20:40:23 <pavonia> but the <- still tries to access the result of an IO action
20:40:36 <bmuk> and flymake is telling me zipWith is the issue
20:41:12 <bmuk> oh, sorry, stupid mistake
20:42:14 <bmuk> I'm still new to the IO stuff and I'm trying to learn by doing. Thank you for helping me
20:43:09 <jfischoff> bmuk: we've all been there ;)
20:43:22 <bmuk> thank you :)
20:43:52 <jfischoff> the good thing is your in the right place asking the right questions
20:44:34 <bmuk> I am definitely glad this IRC channel exists!
20:45:30 <bmuk> Now the only error I have is that writeFile expects a String and Im giving it an IO String. any suggestions
20:46:11 <RichyB> bmuk, pull the string out of the IO action that it's in, using either "value <- action" or "action >>= ..."
20:46:16 <tromp> :t writeFile
20:46:17 <lambdabot> FilePath -> String -> IO ()
20:46:37 <shachaf> RichyB: "pull the string out of the IO action that it's in" :-(
20:46:45 <RichyB> bah
20:46:53 <jfischoff> also: writeFile "blah" =<< ioString
20:47:06 <shachaf> I don't think reïnforcing the idea that a string is "in" an IO action helps people much with figuring this out.
20:47:20 <RichyB> Sorry.
20:47:55 <bmuk> so bind allows IO tainted values to be 'bound' to functions which accept normal values? Am I getting this?
20:48:11 <shachaf> bmuk: "IO tainted values" is a very misleading way of thinking about IO in Haskell.
20:48:14 <RichyB> I've horribly mis-explained this
20:48:33 <bmuk> no I'm just naive lol
20:48:38 <shachaf> There are no tainted values. There are Strings, which are ordinary plain old strings of characters. And there's "IO String", which is a different thing altogether.
20:48:47 <shachaf> @quote /bin/ls
20:48:47 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
20:49:29 <johnw> that funny that shachaf writes reïnforcing and then bmuk writes naive, since naïve is pretty much the only word I ever see in print using diaresis
20:49:45 <RichyB> Say I want to read the contents of a file called "a" and write that into a file called "b".
20:49:55 <bmuk> oh... so an IO String is a thing that gives me a String.
20:50:01 <RichyB> I could write that like: do { data <- readFile "a"; writeFile "b" data; }
20:50:10 <bmuk> okay
20:50:13 <shachaf> bmuk: It's like a program that can be run to produce a String.
20:50:25 <RichyB> An IO String is a thing that will (do some IO, and) give you a String if you run it.
20:50:53 <RichyB> bmuk, I oculd also write that like: readFile "a" >>= \data -> writeFile "b" data
20:51:07 <RichyB> which is just the same as: readFile "a" >>= writeFile "b"
20:51:16 * shachaf thinks this explanation is trying to explain too many things at once.
20:51:20 <shachaf> But maybe not. We'll see.
20:51:48 <RichyB> The way that I prefer to think about this is that >>= glues subroutines together by giving the output of one as an input to the next.
20:52:21 <RichyB> do notation is shorthand for using the >>= operator.
20:52:38 <bmuk> I get that do notation is syntactic sugar for bind. Is bind sort of like coposition of IO subroutines?
20:52:54 <bmuk> composition*
20:53:03 <johnw> bmuk: in terms of the IO monad, bind is a bit like (but not exactly like) piping
20:53:10 <RichyB> Yes.
20:53:22 <jfischoff> @type (&)
20:53:23 <lambdabot> a -> (a -> b) -> b
20:53:23 <johnw> it's not exactly like it because it's not really a pipeline
20:53:29 <johnw> each step finishes before the next executes
20:53:31 <jfischoff> @type (>>=)
20:53:31 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:53:43 <jfischoff> @type flip ($)
20:53:44 <lambdabot> b -> (b -> c) -> c
20:53:54 <jfischoff> @type ($)
20:53:54 <lambdabot> (a -> b) -> a -> b
20:54:00 <jfischoff> @type (=<<)
20:54:01 <lambdabot> Monad m => (a -> m b) -> m a -> m b
20:55:05 <bmuk> The type is saying that bind takes a function that takes a non Monadic value and returns a monadic value right?
20:55:30 <bmuk> Didn't we bind something earlier to a completely pure function or am I misremembering?
20:56:42 * slack1256 GhcMod.vim completes me
21:01:22 <bmuk> What options do I have to diagnose run time errors? I'm getting a hClose resource vanished error
21:01:33 <bmuk> Sorry I'm so full of errors today lol
21:03:54 <johnw> bmuk: is this with your readFile/writeFile example?
21:04:23 <johnw> oh, that was RichyB
21:04:37 <johnw> anyway, hClose resource vanished indicates a pretty typical lazy I/O bug
21:04:40 <johnw> can you show us some code?
21:04:42 <RichyB> erk
21:04:54 <bmuk> https://github.com/bmuk/Book2Words/blob/master/book2words.hs
21:05:25 <bmuk> I think it has to do with readProcess
21:05:28 <jfischoff> yes
21:05:45 <bmuk> I think I am confusing arguments and stdin
21:05:55 <jfischoff> no I don't think so
21:06:01 <bmuk> @type readProcess
21:06:02 <lambdabot> Not in scope: `readProcess'
21:06:13 <jfischoff> how big is wordList?
21:06:13 <johnw> try this after the readFile: evaluate (length content)
21:06:18 <johnw> you'll need to import Control.Exception
21:06:21 <bmuk> @hoogle readProcess
21:06:22 <lambdabot> System.Process readProcess :: FilePath -> [String] -> String -> IO String
21:06:22 <lambdabot> System.Process readProcessWithExitCode :: FilePath -> [String] -> String -> IO (ExitCode, String, String)
21:06:38 <lightquake> is there a way to use pandoc as a syntax highlighter? i.e., pandoc file --highlight-as=haskell -o output.html
21:06:55 <bmuk> wordList is fairly large - it's all the unique words in a book (in my test case it
21:07:01 <bmuk> is harry potter)
21:07:44 <jfischoff> I think it has to make a file handle for each readProcess to connect to the stdout
21:07:52 <jfischoff> someone correct me if I am wrong
21:08:06 <bmuk> :johnw what does exception do here?
21:08:17 <johnw> it's just to bring in the "evaluate" function
21:08:46 <bmuk> :johnw excuse me I meant to ask what evaluate did
21:08:54 <johnw> it forces the evaluation of the expressoin
21:09:08 <johnw> it means "read the whole contents here into memory before continuing"
21:09:16 <johnw> that's what I'm using it to mean there
21:09:30 <bmuk> so it's a way around laziness?
21:09:42 <johnw> it's a way to find out if my guess is right about your problem
21:09:53 <johnw> what happens is that readFile doesn't actually read everything into memory
21:10:08 <johnw> but the handle is being closed before you use the rest of the value
21:10:15 <johnw> so it tries to read from a closed handle
21:10:20 <johnw> this happens often when using lazy I/O
21:10:53 <testirc> ;
21:11:05 <bmuk> ah okay. Is there any reason not to use strict IO? maybe when handling significantly large files?
21:11:24 <johnw> bmuk: I would use conduits, they solve all of these lazy I/O issues and give you constant memory usage
21:12:46 <RichyB> Sometimes lazy I/O gives you shorter programs than strict I/O because it saves you the bother of breaking stuff up into chunks yourself, but it is considered to be a bit of a mistake these days because lazy I/O tends to break in confusing ways in bigger programs.
21:12:53 <bmuk> conduits? I'll check them out. This is already performing orders of magnitude better than yesterday when I started the project. I switched to Text from String
21:13:00 <AlainODea> how do I see where a running Haskell process is in terms of stack? I'm trying to diagnose infinite loop or deadlock.
21:13:12 <johnw> bmuk: I never use lazy I/O anymore, it's just not worth the headache
21:13:24 <johnw> it's make toy programs cute, but it loses in production code
21:13:29 <RichyB> If you aren't handling much data, just use strict I/O and read/write entire files, save yourself the headaches.
21:13:31 <jfischoff> I really don't that this is an issue that is related to the reading of the file, but we will see
21:14:10 <jfischoff> for what it is worth lazy io can also read files in constant memory
21:14:15 <johnw> it could be the readProcess, in which case you could "evaluate (map length wordDefs)" to force reading them all
21:15:00 <johnw> AlainODea: I'm not sure, but maybe threadscope could help?
21:16:40 <johnw> actually, I strongly believe now that it's the readProcess
21:17:02 <bmuk> I think it is too
21:17:07 <johnw> writeDefinitions is returning thunks that refer to as-yet-unread data from the readProcess call, but the process handles are being closed by the garbage collector after writeDefinitions returns
21:17:34 <bmuk> oh. So I need to wait on the process
21:17:43 <johnw> or just force its results into memory
21:18:07 <AlainODea> johnw: thanks, I'll give ThreadScope a try :)
21:18:21 <bmuk> where should I put evaluate (map length wordDefs)?
21:18:36 <johnw> mapM (\w -> xs <- readProcess "dict -d spa-neg" []; evaluate (length xs); return xs) wordList
21:19:17 <johnw> need a "do" in there
21:19:34 <johnw> mapM (\w -> do { xs <- readProcess "dict -d spa-neg" []; evaluate (length xs); return xs }) wordList
21:19:39 <c_wraith> bmuk: in more general terms...  what you *really should be doing is is not mixing lazy IO with explicitly closing file handles.  They just don't work together.
21:20:28 <bmuk> so I should focus on conduits first and that would solve the issue and the myriad of issues I will have in the future with lazy IO
21:20:39 <c_wraith> conduits replace lazy IO
21:21:23 <johnw> bmuk: yes
21:21:27 <jfischoff> bmuk: conduits are not easy for beginners. I would not recommend it
21:21:47 <johnw> conduits have a learning curve, but are worth the investment; however, if you are just beginning with Haskell, don't attempt it yet
21:21:58 <jfischoff> which bmuk is
21:22:00 <johnw> the type errors and monad transformer machinery is a huge burden if you are unfamiliar with them
21:22:07 <jfischoff> exactly
21:23:08 <johnw> so, put in on your list of things to learn in the future :)
21:23:14 <johnw> for now, just force stuff into memory
21:23:38 <bmuk> Is there a list of good white papers to read regarding haskell so I can understand more of the types/monads/etc.? I really liked reading the paper on fold that real world haskell linked to
21:23:49 <johnw> @hoogle Typeclassopedia
21:23:51 <lambdabot> No results found
21:23:51 <bmuk> They're on the list lol
21:23:59 <johnw> @where Typeclassopedia
21:23:59 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
21:24:20 <bmuk> oh wow. haskell wiki has everything doesn't it? lol
21:24:34 <johnw> Haskell has an _amazing_ amount of high-quality online material for free
21:25:34 <bmuk> Do many of you work on haskell for a living? Is that feasible currently?
21:25:44 <johnw> I do, a few others do also
21:25:57 <johnw> and yes, I saw 6 new Haskell jobs offered in Singapore last night
21:26:27 <carter> johnw: btw for your ghc ticket, have you tried -f-no-omit-yiedls?
21:26:33 <carter> johnw: wait, 6?
21:26:37 <johnw> let me try
21:26:43 <johnw> 6 positions
21:26:45 <johnw> all at the same place
21:26:54 <carter> lazada or another palce?
21:27:00 <JuanDaugherty> boy I wish hackage had ratings or reviews
21:27:01 <bmuk> Interesting. I am really falling in love with Haskell and functional programing in general. I would really like to make it career (obviously when I'm much better at it lol).
21:27:03 <jfischoff> bmuk: more and more jobs are showing up
21:27:23 <carter> jfischoff: yup!
21:27:47 <johnw> carter: trying neow
21:27:52 <carter> jfischoff: woot
21:27:59 <carter> jfischoff: bmuk : and more every day
21:28:01 <johnw> bmuk: that's what happened to me too
21:28:09 <ParahSailin> carter: i think the 6 were at some samwers outfit but not lazada
21:28:15 <carter> wheres this ?
21:28:20 <carter> i've not seen those annoucnes
21:28:20 <zq> can anyone eli5 the ast typing problem? from what i've read, it seems to be a design pattern intended to solve a class of problems exemplified by needing to incrementally add new information to an existing and potentially large ast
21:28:27 <ParahSailin> /r/haskell
21:28:41 <carter> i've on a fam tirp
21:28:42 <carter> trip
21:28:45 <johnw> carter: I saw them on twitter
21:28:54 <johnw> can't find them now; I can never find anything on twitter once it's gone
21:29:49 <JuanDaugherty> twitter is ephemeral?
21:30:00 <johnw> my use of it is :)
21:30:10 <JuanDaugherty> I thought you could go back
21:30:18 <Nafai> This is the job johnw is probably thinking of: https://github.com/projectdeltasea/projectdelta/blob/master/README.md
21:30:44 <johnw> hey Nafai!!!
21:30:48 <Nafai> Hey johnw
21:30:50 <johnw> I haven't seen you in like a year!
21:31:02 <carter> jfischoff johnw  is that php rewrtite the thing likely that dude from ICFP?
21:31:15 <johnw> carter: I just don't remember anymore; I thought it was a financial company
21:31:27 <carter> johnw:, jfischoff  met the dude i'm talking about
21:31:28 <johnw> I mean, this was from last night for goodness sake, that's ancient history
21:31:44 <carter> php + ecommerce startup
21:31:52 <Nafai> johnw: brb, gotta get hooked up to my dialysis
21:32:02 <carter> dude was working on getting buyin to get a shift from php
21:32:27 <maxs__> if you believe in the JVM, there are lots of scala jobs in the world
21:32:42 <carter> i don't believe in the jvm
21:32:54 <maxs__> I thought so
21:32:54 <carter> its a captive island
21:33:12 <bmuk> haha. Do you believe in llvm?
21:33:17 <carter> bmuk: hehe
21:33:18 <johnw> he most certainly does
21:33:24 <johnw> see #haskell-llvm on any average day
21:33:35 <carter> johnw: i kinda created that channel :)
21:33:47 <bmuk> haha what are the odds?
21:33:52 <carter> its a cute wee community of folks who are cooler than me
21:34:17 <carter> johnw: bmuk : if i'm not careful, simon marlow may talk me into making the NCG a mini haskell based llvm like thingy
21:34:31 <carter> though i don't wanna
21:34:50 <carter> i just wanna spend some time in 2014 cleaning up the ncg so its a teeny bit more extensible
21:34:58 <carter> johnw: results of benching?
21:35:07 <maxs__> is this on top of cmm?
21:35:12 <johnw> carter: still working on it
21:35:16 <carter> ok
21:35:19 <carter> nah
21:35:24 <carter> maxs__: its a backend for cmm
21:35:28 <carter> just like the llvm one
21:35:33 <maxs__> ah ok cool
21:35:36 <carter> cmm is the IR before the backends
21:35:39 <carter> maxs__: good question
21:36:01 <maxs__> good
21:36:03 <maxs__> you can fix aliasing then
21:36:06 <carter> oh
21:36:11 <carter> fix which bit?
21:36:29 <maxs__> having it
21:36:35 <carter> maxs__: the issue currently is i don't think any aliasing info is passed to CMM
21:36:38 <maxs__> yea
21:36:48 <carter> that *is*  a real issue, i agree
21:36:56 <carter> but thats a problem BEFORE the cmm phase
21:37:07 <carter> that info should be there before cmm
21:37:11 <carter> and then elaborated there
21:37:41 <carter> my near term goal is the "given final opimtized CMM, make the code gen there after nicer"
21:37:57 <carter> maxs__: actually thats not quite true
21:38:08 <carter> my near term goal this evening is to stare at the soure for https://code.google.com/p/blis/ to steal some tricks
21:38:14 <johnw> carter: no effect
21:38:17 <carter> ok
21:38:27 <carter> i gave you the correct flag right?
21:38:33 <carter> johnw: oooo
21:38:37 <johnw> i don't know
21:38:42 <carter> johnw: what about -threaded -N1
21:38:45 <carter> + that flag
21:38:51 <johnw> -threaded -N2 solves it
21:38:53 <johnw> -N1 does not
21:39:10 <carter> ok
21:39:13 <johnw> you mean, +RTS -N1, right?
21:39:13 <carter> with the flag?
21:39:13 <carter> ok
21:39:16 <carter> yes
21:39:25 <carter> wait
21:39:36 <carter> johnw: on 7.6 and HEAD, you need to compile with -rtsops
21:39:38 <carter> *opts
21:39:42 <carter> for +RTS blah
21:39:42 <johnw> i did
21:39:44 <carter> to do anything
21:39:44 <carter> ok
21:39:54 <johnw> carter: https://gist.github.com/8109173
21:40:57 <carter> huh
21:40:59 <carter> ok
21:41:08 <carter> i just tweeted that ticket to ezyang
21:41:27 <carter> this really closely touches on a bunch of the ghc rts stuff he's been working on
21:41:34 <maxs__> carter: yes that is quite interesting...
21:41:41 <carter> maxs__: what is?
21:41:48 <maxs__> blis
21:41:52 <carter> oh yeah
21:41:58 <carter> i've some related ideas
21:42:04 <carter> that are more general
21:42:29 <carter> but for the near term, if i can (ab)use their primops to give the initial release decent perf without locally depending on having a blas installed, i'll be really really happy
21:42:41 <carter> esp since every OS i'm wiliing to support will have a c compiler
21:42:46 <carter> (else they'd have no haskell)
21:42:57 <carter> but most casual first time users won't have a gfortran
21:43:28 <carter> johnw: maybe theres a busywait / spinlock issue?
21:43:54 <johnw> that's what hvr was thinking too
21:44:06 <carter> and its across all the ghc versions right?
21:44:08 <maxs__> carter: yeah for sure
21:44:18 <maxs__> I'm off, aeroplane time
21:44:20 <carter> enjoy
21:44:59 <johnw> carter: yes
21:45:04 <johnw> all the ones I have built
21:49:37 <malaclyps> so, i'm just getting the hang of haskell, and having fun composing functions; it may be my OOP upbringing, but I've found myself creating a data type to pass around two related values
21:50:27 <johnw> making data types can add to the expressiveness of your code, especially if it expresses a connection between the values
21:50:43 <malaclyps> eg, I have a Pandoc type, and it has embedded in it a number -- I've ended up pulling out that number once, and then creating a separate type, which has both the number and the Pandoc
21:51:26 <malaclyps> the number can be derived from the Pandoc, and I feel like maybe I'm not doing it right -- that maybe I should be calculating it every time I need it, rather than storing it in a (temporary) type
21:52:08 <malaclyps> so there *is* a connection between the values, but it's a fixed connection
21:52:18 <johnw> if you can hash the Pandoc, then you could memoize the function that calculates the number
21:52:33 <johnw> but then it would need to hash each time, maybe just as expensive...
21:52:35 <carter> pass around how?
21:52:42 <carter> could you gist or lpaste the example?
21:52:51 <malaclyps> from one function to another --- sure, hold on
21:54:19 <malaclyps> here we go: https://gist.github.com/dannyob/83cf0dc75f0c8defe11f
21:54:52 <malaclyps> the program grabs a bunch of downloaded HaskellWiki pages, finds the ones with 99 problems on them (which are identified by the phrase "_to_" in the filename)
21:55:28 <malaclyps> splits the texts of the pages into individual problems, then outputs them as comments in a set of 99 haskell source files
21:55:47 <malaclyps> (i was getting bored of doing this manually while doing the 99 problems, and figured it would be a good way of doing an actual Haskell problem)
21:56:49 <malaclyps> anyway, the key thing this needs to work is a pile of Pandoc fragments (which are the text of the problems) and the problem number (which you can pull out of the text of the headings)
21:57:13 <johnw> in this case, i wouldn't bother storing the number, since I doubt that will impact the performance of your algorithm
21:57:25 <malaclyps> i ended up with a "problem" type that has an int for the problem 'number' (actually it can have A or B at the end of the number), and the Pandoc blob itself
21:57:54 <malaclyps> so you think i should just move the problem number calculation closer to when it's actually needed?
21:58:10 <johnw> this is a time vs. memory/complexity tradeoff
21:58:17 <johnw> if you don't need to make that tradeoff, go for simplicity
21:58:30 <malaclyps> and an extra type is probably added complexity?
21:58:33 <johnw> yep
21:59:05 <malaclyps> is there anything else that leaps out as ... unhaskelly?
21:59:48 <malaclyps> (i'm pretty pleased with lines 68-73 -- the rest of it is pretty imperative, but that was the first time that I felt like I was thinking in Haskell
21:59:54 <johnw> safequery q xs |[Str x] <- query q xs
22:00:08 <johnw> just call safequery with (query q xs), and pattern match on its result in safeQuery
22:00:15 <carter> honestly if something seems complex, ask "does it have to be?"
22:00:25 <carter> johnw: heh, blis is kinda a neat piece of c
22:00:31 <johnw> what is blis?
22:03:07 <malaclyps> i'm just getting a feel for how short functions should be, and how much you can inline without losing the meaning
22:03:24 <pavonia> also "isMod3 x = x `mod` 6 == 0" is quite confusing
22:03:32 <igpeer> hi Haskellers!!
22:03:46 <malaclyps> haha, i think that was originally `mod` 3 -- it's just a quickcheck
22:04:10 <carter> johnw: https://code.google.com/p/blis/ a more modern BLAS that i'm debating borrowoign some low level code form
22:05:52 <igpeer> anyone can help to me explain the difference between package and library? I just now installed haskell. I saw the list of libraries under lib folder. But when I run the comment 'ghc-pkg list'. I see some of the packages. When I cross check the lib folder and the list of pkg, I found difference
22:07:07 <igpeer> say for example, if prelude is library. why it is under package catagory in hackage site.
22:09:39 <benzrf> hi
22:09:52 <benzrf> how is my attempt at a mergesort impl -> http://bpaste.net/show/161405
22:12:18 <johnw> benzrf: you could be cute and delete the first two definitions of merge', and create a second definition: merge' l l' acc = reverse l ++ reverse l' ++ acc
22:12:46 <johnw> because that definition will only happen if l or l' or both is []
22:13:43 <benzrf> bah
22:13:50 <carter> gah, weird weird compilation bugs
22:14:16 <pavonia> benzrf: Why do you merge the lists backwards?
22:14:27 <benzrf> pavonia: because prepending is faster than appending
22:14:31 <benzrf> am I missing something important here
22:14:50 <benzrf> i thought one reverse then a bunch of prepends > no reverse and a lot of appends
22:15:20 <johnw> benzrf: or use DLists
22:15:43 <carter> grr, looks like blis is a pain to build
22:15:44 <pavonia> Well, couldn't you merge them without reversing?
22:16:05 <pavonia> only using (:) that is
22:16:10 <benzrf> pavonia: don't think so?
22:16:14 <benzrf> I mean i could be wrong
22:16:32 <pavonia> Hhm, maybe I have another merge function in mind
22:16:41 <benzrf> but i cant figure out how you could do that myself
22:17:35 <pavonia> You just go through both lists and add the smaller of either elements to the resulting list, then proceed with the rest, no?
22:18:10 <benzrf> wouldnt you end up with a backwards result?
22:18:31 <benzrf> oh wait you'd still only have to flip that instead of both the inputs
22:18:38 <benzrf> welp thats definitely quicker
22:19:22 <pavonia> No, there's no flipping needed, you get the result element in exactly the order of the input elements
22:19:27 <zRecursive> igpeer: http://stackoverflow.com/questions/16997950/whats-the-difference-between-module-package-and-library-in-haskell
22:19:36 <benzrf> ?
22:19:45 <benzrf> pavonia: can you write a quick impl
22:20:24 <igpeer> Thanks @zRecursive
22:20:57 <pavonia> benzrf: The basic idea is merge (x:xs) (y:ys) | x < y = x : merge xs (y:ys) | ...
22:21:20 <benzrf> ohhh
22:21:25 <benzrf> I was thinking entirely tail recursively
22:21:26 <benzrf> -.-
22:21:33 <benzrf> yeah that would probably workq
22:22:20 <lispy> tail recusion can get you into trouble in Haskell
22:23:07 <johnw> Soroboruo, the tail that eats its own head
22:24:07 <benzrf> lispy: really??
22:24:11 <benzrf> i always thought it was better
22:24:22 <lispy> In eager languages like lisp it is better
22:24:40 <jle`> is there any sort of javascript interpreter for haskell's javascript libraries?  or are they compiled only
22:24:46 <lispy> benzrf: So imagine you take a non-tail recursive function and make it tail recursive. Typically you introduce some sort of accumulator.
22:25:02 <benzrf> right
22:25:11 <lispy> benzrf: Because Haskell is lazy by default, that accumulator will be built lazily. Thunks of thunks.
22:25:15 <benzrf> ooohhh
22:25:18 <benzrf> space leaks :P
22:25:38 <lispy> now, when you evaluate that value, you can run out of room to do the evaluation (ghc uses the stack so you can get a stack overflow)
22:25:51 <lispy> That's why we have foldl'
22:26:05 <lispy> It tries to not build up a crazy amount of thunks
22:27:13 <lispy> benzrf: it's not always bad though. Sometimes it's still the right thing. It's just that it's no longer the obvious win that it was in eager languages.
22:34:09 <gamegoblin> I have a line like " map (\(tr,te) -> (newValues m tr, newValues m te)) cvs "
22:34:17 <gamegoblin> hlint tells me I should use Control.Arrow
22:34:27 <gamegoblin> does Arrow offer any advantages in terms of performance?
22:34:33 <gamegoblin> or is it just sexier?
22:34:35 <lispy> :t &&&
22:34:36 <lambdabot> parse error on input `&&&'
22:34:39 <lispy> :t (&&&)
22:34:40 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
22:34:45 <gamegoblin> It says to use ***
22:34:48 <lispy> gamegoblin: I think just cuter
22:34:48 <lispy> ah
22:35:00 <gamegoblin> :t (***)
22:35:01 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
22:35:07 <lightquake> are `forall a. f a` and `f (forall a. a)` the same type when f is a functor?
22:35:08 <lispy> I can never keep *** and &&& separate in my brain
22:35:44 <mauke> *** is tuplier
22:35:46 <benzrf> >> ((+1) &&& (+2)) 3
22:36:04 <benzrf> no wait
22:36:07 <benzrf> > ((+1) &&& (+2)) 3
22:36:09 <lambdabot>  (4,5)
22:36:12 <benzrf> o:
22:36:36 <benzrf> > ((+1) *** (+2)) (1, 2)
22:36:37 <lambdabot>  (2,4)
22:36:46 <lispy> gamegoblin: FWIW, I wouldn't follow that advice
22:36:49 <benzrf> that's like zipwith ($) but for tuples?
22:37:06 <gamegoblin> lispy: any reason?
22:37:07 <lightquake> you can write in :: forall a. f a -> f (forall a. a), certainly, but I'm not sure about the other direction
22:37:26 <lispy> gamegoblin: to me it seems silly and obsfuscated to use ***
22:38:13 <lispy> gamegoblin: would it be the same to write zipWith (newValues m) cvs?
22:38:20 <lispy> :t zipWith
22:38:21 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
22:38:41 <lispy> ah right cvs would have to be split already
22:38:47 <gamegoblin> indeed
22:39:33 <mauke> :t (,) `on` ?f
22:39:34 <lambdabot> (?f::a -> b) => a -> a -> (b, b)
22:39:46 <mauke> :t uncurry ((,) `on` ?f)
22:39:47 <lambdabot> (?f::b -> b1) => (b, b) -> (b1, b1)
22:40:10 <mauke> :t join (***)
22:40:10 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
22:40:49 <lightquake> ... hm, yeah, I can't figure out how to write a function of type (f (forall a. a)) -> (forall a. f a)
22:40:55 <dsrx> what is (?f::a -> b)
22:41:42 <Aetherspawn> I have something like this: packRects w h []    = (Nothing, []); packRects w h r@((rw, rh):rs)
22:42:05 <Aetherspawn> If I add ~ before (rw,rh) to make it a lazy match, can I delete the first one and make a guard statement | null r instead?
22:44:05 <benzrf> dsrx: ??
22:44:07 <benzrf> ?
22:44:29 <dsrx> oh...
22:44:37 <lightquake> dsrx: http://www.haskell.org/haskellwiki/Implicit_parameters
22:44:37 <dsrx> I should have looked more closely
22:44:43 <lightquake> oh, that page isn't helpful
22:45:09 <dsrx> that gives me some good things to google, thanks :)
22:45:22 <lightquake> it's not something I've ever seen used in code
22:45:34 <benzrf> lightquake: its an extension
22:45:39 <lightquake> right
22:45:53 <lightquake> but there are lots of extensions I see used, and that's not one of them
23:01:56 <roboguy_> I've never understood implicit parameters. when would it be better to use that over reader? it always seemed kind of over complicated
23:04:24 <Cale> roboguy_: What kind of program are you writing? The main thing I'd actually use reader for over *explicit* parameters is something like a lambda calculus evaluator where there would be lots of uses of local.
23:05:13 <roboguy_> Cale: I mean the ExplicitParameters extension vs. reader. I'm not working on anything involving that, I'm just curious
23:05:22 <roboguy_> *ImplicitParameters extension
23:05:25 <enthropy> roboguy_: reader pollutes your types more than -XImplicitParams
23:05:52 <enthropy> well in the sense that you need to be more explicit about adding stuff like `return'
23:06:13 <enthropy> and it's only good for 1 parameter (which could be a tuple or record or whatever)
23:06:38 <Cale> Implicit parameters is not so complicated, but it can result in some confusion about what's going on
23:07:01 <Cale> It's a bit harder to miss the fact that Reader is in use
23:08:28 <Cale> But personally, unless I was going to write an entire library of stuff around it and hide my usage of it via a newtype, I would almost never use, say, ReaderT instead of just adding explicit function parameters.
23:09:54 <Cale> (It has a syntactic cost in terms of lifts which typically doesn't make up for the parameter passing that it saves you, so unless you can capture all the cases where you'd be lifting into some finite set of definitions, it's usually not worth it.)
23:10:03 <bitemyapp> is there a way to get Cabal to install all dependencies mentioned in a cabalfile? It doesn't seem to understand my build-depends for my test block.
23:10:16 <bitemyapp> all meaning across all build-depends
23:10:24 <Cale> (This is just my personal opinion about style though, other people like Reader/ReaderT more than I do)
23:11:03 <bitemyapp> wat: cabal: can't find source for test :(
23:12:43 <Cale> Where is test.hs located relative to the .cabal file? Maybe you need to add an hs-source-dirs?
23:13:13 <bitemyapp> Cale: the test.hs is in the same tier as cabal file, it mentions src in hs-source-dirs because that's where the application namespaces are.
23:13:22 <bitemyapp>   hs-source-dirs: src
23:13:23 <bitemyapp>   main-is:    test.hs
23:13:38 <bitemyapp> Test-Suite test-frak
23:14:50 <pavonia> Shouldn't it be in src then?
23:15:38 <bitemyapp> I guess. I didn't know declaring an hs-source-dirs made it ignore the current directory.
23:16:02 <bitemyapp> pavonia: that worked, thanks.
23:16:09 <bitemyapp> no coloration though. hum.
23:19:18 <bitemyapp> cabal clean doesn't seem to be doing its job. In ghci the tests work, but they still break with a stale error if I try to cabal clean && cabal test
23:44:54 <dv-> is there a strict readFile? I've tried force `fmap` readFile but it's not working
23:46:22 <Cale> dv-: If you use the readFile for strict ByteString or Text, it'll read the whole file at once
23:46:59 <dv-> i'm using String
23:47:46 <killerswan> hmm, ISC is not a recognized Haskell license?
23:48:03 <killerswan> what kinds of license compliance auditing tools are there on Hackage?
23:48:21 <Cale> killerswan: hm?
23:48:25 <killerswan> do I break any of them by just going with "OtherLicense" and ignoring it otherwise?
23:49:10 <killerswan> Cale: http://en.wikipedia.org/wiki/ISC_license
23:50:18 <Cale> You can use UnknownLicense "ISC", I suppose.
23:50:31 <killerswan> I imagine there might exist compliance tools which, given a package, could walk the dependency tree and confirm that we're bound by GPL, or NOT, for example
23:50:47 <Cale> Oh, I don't know of any such tools
23:51:05 * killerswan nods
23:52:36 <Cale> http://www.haskell.org/cabal/release/cabal-latest/doc/API/Cabal/Distribution-License.html gives the list of constructors for that datatype
23:52:46 <Cale> I'm not really sure what it's actually for
23:53:47 <Cale> But I guess you could try to analyse the package graph for dependencies that aren't supposed to be allowed
23:54:29 <roboguy_> Cale: earlier I was mostly talking about the ((->) r) instances rather than the Reader type. that might cut down on the type complexity some
23:54:51 <tpsinnem> hello -- is there a special meaning to the '{-| Foo ... @ Bar ::= Quux ... ; @ -}' stuff, as found in here for example: https://github.com/idris-lang/Idris-dev/blob/master/src/Idris/ParseExpr.hs ?
23:55:01 <Cale> roboguy_: Oh, well then. :)
23:55:36 <Cale> Haddock syntax, I bet
23:56:03 <Cale> http://lambda.haskell.org/platform/doc/current/ghc-doc/haddock/ch03s08.html#idp37236912
23:56:20 <Cale> Code blocks go between @ signs
23:57:52 <tpsinnem> Cale: ok, thanks
