00:00:00 <Iceland_jack> Sadly Haskell uses two colons but that's another story
00:00:34 <Sgeo> (/) $:: sum ~> fromIntegral.length
00:01:36 <Sgeo> Hmm, what is the difference between that and using the r-> applicative?
00:02:00 <Sgeo> Well, composition of result too, hmm
00:03:45 <nurupo> is there a shorthand for map y (dothings . (map x list)) ?
00:04:22 <Iceland_jack> It's a type error so No
00:04:28 <nurupo> like
00:04:28 <nurupo> > map read (reverse (map show [123, 456, 789]))
00:04:29 <lambdabot>   [*Exception: Prelude.read: no parse
00:04:36 <Iceland_jack> That's not what you posted
00:04:44 <nurupo> > map read (reverse (map show [123, 456, 789])) :: [Int]
00:04:45 <lambdabot>   [789,456,123]
00:04:59 <nurupo> Iceland_jack: ignore the dot :)
00:05:09 <Iceland_jack> @pl map y (x (map z xs))
00:05:09 <lambdabot> map y (x (map z xs))
00:05:14 <Iceland_jack> Not that I'm aware of
00:05:25 <codygman> Iceland_jack: I made my program do what I wanted, perhaps what I was trying to do is more clear now? This works, but am I doing things wrong? How would you write something to read fields in a json file, update them, then write them back to the file? http://lpaste.net/96726
00:05:26 <nurupo> what is "pl"?
00:05:42 <Iceland_jack> but you could write:
00:05:42 <Iceland_jack>     > reverse (map (read . show) [123,456,789])
00:05:51 <Iceland_jack> since map f . map g = map (f . g)
00:06:12 <Iceland_jack> and reverse is a natural tra… no I've said too much
00:06:12 <arkeet> @free reverse :: [a] -> [a]
00:06:12 <lambdabot> $map f . reverse = reverse . $map f
00:06:40 <arkeet> ;)
00:06:55 <nurupo> > reverse (map (read . show) [123,456,789])
00:06:56 <lambdabot>   [*Exception: Prelude.read: no parse
00:07:03 <Iceland_jack> > reverse (map (read . show) [123,456,789]) :: [Int]
00:07:04 <lambdabot>   [789,456,123]
00:07:30 <arkeet> > reverse [123,456,789]
00:07:31 <lambdabot>   [789,456,123]
00:07:41 <Iceland_jack> > [789,456,123] -- Is this cheating?
00:07:43 <lambdabot>   [789,456,123]
00:08:33 <mirpa> Is there a function like (liftM2 (<|>)) which evaluates second IO only if the first IO evaluates to Nothing?
00:08:36 <nurupo> oh
00:08:58 <mirpa> IO (Maybe a)
00:09:38 <nurupo> > map (read . reverse . show) [123, 456, 789]) :: [Int]
00:09:39 <lambdabot>   <hint>:1:44: parse error on input `)'
00:09:45 <nurupo> > map (read . reverse . show) [123, 456, 789] :: [Int]
00:09:46 <lambdabot>   [321,654,987]
00:09:50 <arkeet> mirpa: you may be interested in MaybeT
00:09:53 <arkeet> it has Alternative/MonadPlus instances
00:10:03 <arkeet> that do that
00:10:23 <arkeet> MaybeT IO a = IO (Maybe a)
00:10:25 <mirpa> arkeet: its not part of standard library, is it?
00:10:31 <arkeet> it's in transformers which is pretty standard
00:10:38 <djahandarie> Does anyone know how to do regex-based substitution in Haskell using anything aside from subRegex (seems to have issues with unicode)?
00:10:38 <arkeet> (part of the platform)
00:10:47 <Iceland_jack> codygman: you're using ‘return’ again
00:10:47 <mirpa> ok, thanks for the tip
00:10:55 <djahandarie> All the other regex libraries don't seem to handle substitution...
00:11:10 <Iceland_jack> codygman: Not *everything* you work with in the IO monad needs to have type IO
00:12:52 <Iceland_jack> so you can write something like:
00:12:52 <Iceland_jack>     main = do
00:12:52 <Iceland_jack>       Just d ← decode <$> getJSON ∷ IO (Maybe [Product])  -- here d ∷ [Product]
00:12:52 <Iceland_jack>       let x = updateModels d
00:12:55 <Iceland_jack>       print (encode x)
00:12:58 <Iceland_jack>  
00:13:52 <Iceland_jack> in line 29 you're really needlessly wrapping your values in the IO monad
00:15:40 <Iceland_jack> In actual code you wouldn't actually pattern match on the value drawn from ‘decode <$> getJSON’ so you'd have something like:
00:15:40 <Iceland_jack>     main = do d ← …
00:15:40 <Iceland_jack>               let updated = updateModels <$> d  -- recall: (<$>) = fmap
00:15:40 <Iceland_jack> 	      print (encode <$> updated)
00:17:10 <Iceland_jack> I hope I haven't obscured the point :)
00:18:47 <augur> with Parsex, why does p <|> q try q only if p doesnt consumes no input?
00:18:58 <augur> can p fail but consume input, thereby not trying q?
00:19:16 <arkeet> yes
00:19:24 <augur> parsex lol. parsec*
00:19:27 <augur> arkeet: example?
00:19:28 <arkeet> that's why try exists.
00:19:34 <augur> Parsec is Parsexy
00:19:37 <arkeet> uh, anything that reads more than one character and fails.
00:20:00 <augur> arkeet: ok, so then what is a usecase for when that's desirable?
00:20:15 <arkeet> parsec does that for efficiency.
00:20:29 <augur> ?
00:20:39 <codygman> Iceland_jack: Thank you, I get what you mean. I knew before that everything in main doesn't have to be IO... honestly now that you've pointed this out I'm terribly confused as to why I did that originally lol
00:20:41 <arkeet> "why does p <|> q ..."
00:21:01 <augur> arkeet: no, what are situations where its more efficient
00:21:20 <arkeet> well, memory efficiency.
00:21:22 <Iceland_jack> codygman: Happens to the best of us!
00:21:28 <arkeet> by not having to keep backtracking state all the time.
00:21:43 <arkeet> :t parse
00:21:44 <lambdabot> Not in scope: `parse'
00:21:45 <arkeet> oh.
00:21:49 <arkeet> @let import Text.Parsec
00:21:51 <lambdabot>  Defined.
00:21:52 <arkeet> @let import Text.Parsec.Char
00:21:53 <lambdabot>  Defined.
00:22:05 <arkeet> > parse (string "ab" <|> string "ac") "" "ac"
00:22:06 <lambdabot>   Ambiguous occurrence `<|>'
00:22:06 <lambdabot>  It could refer to either `Control.Applicative.<...
00:22:09 <arkeet> ....
00:22:17 <arkeet> > parse (string "ab" `mplus` string "ac") "" "ac"
00:22:18 <lambdabot>   Left (line 1, column 1):
00:22:18 <lambdabot>  unexpected "c"
00:22:18 <lambdabot>  expecting "ab"
00:22:27 <arkeet> > parse (try (string "ab") `mplus` string "ac") "" "ac"
00:22:28 <lambdabot>   Ambiguous occurrence `try'
00:22:28 <lambdabot>  It could refer to either `Control.Exception.Bas...
00:22:30 <arkeet> ...
00:22:57 <arkeet> > parse (Text.Parsec.try (string "ab") `mplus` string "ac") "" "ac"
00:22:58 <lambdabot>   Right "ac"
00:23:38 <arkeet> oh I guess I didn't need to separately import .Char
00:23:43 <arkeet> I never use parsec :c
00:23:57 <augur> but what is a case where thats the desired behavior
00:24:35 <dirk103> so i;  let breaker = 2   ;  let fullLoadStart = [2.5, 3, 2.5]    ;  and now i want to access the third element via   fullLoadStart !! breaker
00:24:48 <dirk103> but it Couldn't match expected type `Int' with actual type `Integer'
00:25:18 <Iceland_jack> You can do: let breaker = 2 :: Int
00:25:28 <Iceland_jack> or turn off the monomorphism restriction
00:26:40 <arkeet> augur: it usually isn't.
00:26:55 <dirk103> oh ok
00:27:22 <codygman> Iceland_jack: I just hear a drunk person walking outside (live in a college town) and he said "Happens to the best of us!"... isn't that a weird coincidence :D
00:27:24 <arkeet> or fullLoadStart !! (fromIntegral breaker)
00:27:25 <codygman> heard*
00:27:32 <arkeet> hmm, no parentheses needed there.
00:29:25 <Iceland_jack> codygman: yeah weird coincidence… or is it?
00:31:25 <codygman> codygman: I admit it freaked me out.. I tend to get paranoid when it's late
00:31:32 <codygman> err.. Iceland_jack
00:31:40 <codygman> Great now I'm talking to myself
00:32:12 <udevd> codygman: [spoiler]don't look behind yourself[/spoiler]
00:32:30 <codygman> udevd: haha
00:32:40 <codygman> alright I think this means it's time for bed... see you guys
00:33:12 <udevd> have you checked if there are monsters under your bed xD?
00:34:00 <udevd> but bye :3
00:42:51 <dirk103> when does  'do' know when to stop doing
00:42:58 <dirk103> :P
00:43:16 <augur> dirk103: what do you mean
00:43:42 <dirk103> well i'm reading a hello world app, and it has main = do  then it looks like it stops when the indentation resets to zero
00:44:03 <augur> you mean how does the parser know where the do block ends?
00:44:38 <dirk103> yes!
00:45:03 <klugez> dirk103: http://en.wikibooks.org/wiki/Haskell/Indentation - Indentation is how the blocks are delimited.
00:45:16 <augur> i think that's basically just this: the first line of the do block following the do sets the indentation level of the block, and subsequent lines are at least that deep
00:45:20 <arkeet> > nubBy (((== 0) .) . mod) [2..]
00:45:21 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
00:45:22 <augur> like python
00:45:26 <dirk103> thank you
00:47:41 <arkeet> the do block ends when it sees a line that's indented less than the first one inside.
00:47:48 <arkeet> yeah.
00:48:08 <augur> i think thats the typical "semantic" whitespace scheme
00:48:11 <arkeet> and all statements have to have the same indentation level.
00:48:15 <augur> tho calling it semantic is something i've come to hate
00:48:25 <arkeet> (lines indented further are treated as continuations of the previous line)
00:59:39 <dirk103> http://pastebin.com/J59wtSXk
00:59:40 <mauke> The paste J59wtSXk has been copied to http://lpaste.net/96737
00:59:58 <dirk103> am i not doing that list comprehension at the bottom right?
01:00:17 <dirk103> it says 'not in scope, motorName'
01:00:34 <arkeet> motorName <- fst motorName !! x
01:00:58 <arkeet> you can't have the same thing on both sides of <-
01:01:11 <dirk103> opps!
01:01:40 <arkeet> anyway, please don't use legnth/!! like that. =)
01:01:54 <dirk103> should be motorName <- motors'
01:01:57 <dirk103> no?
01:02:14 <arkeet> well, there are other problems too.
01:02:25 <dirk103> :P it's my first program
01:02:27 <arkeet> when you write x <- blah
01:02:27 <dirk103> need to read more
01:02:28 <arkeet> blah is a list
01:02:30 <arkeet> x is an element of blah
01:03:03 <arkeet> oh hmm.
01:03:17 <arkeet> what are you trying to do, actually? I can't tell anymore.
01:03:31 <dirk103> lol
01:03:42 <dirk103> \i just want to print the list of strings there
01:03:46 <dirk103> defined at the top
01:03:57 <arkeet> so you want ["Single-phase, all types", "SCIM, FVS, Resistor and Reactor, ...]
01:04:00 <dirk103> yes
01:04:04 <arkeet> ok
01:04:17 <arkeet> well first of all, don't even think about using length or !!
01:04:25 <dirk103> :P okay
01:04:28 <arkeet> most of the time we don't use those.
01:04:36 <dirk103> okay
01:04:50 <arkeet> anyway, so you have that list
01:04:59 <arkeet> motors' :: [ (String, [Integer]) ]
01:05:13 <dirk103> i get that part right?
01:05:19 <arkeet> so here's how you could use a list comprehension to do it:
01:05:35 <arkeet> you can grab each element of thie list: x <- motors'
01:06:02 <arkeet> so x is a tuple, of type (String,[Integer])
01:06:11 <arkeet> and fst x is the thing you want, so:
01:06:23 <arkeet> you want a list of all the fst x things.
01:06:30 <arkeet> [ fst x | x <- motors' ]
01:06:53 <dirk103> ohhh
01:06:53 <dv-> or map fst motors'
01:07:03 <arkeet> dv-: I was going to mention that later. :p
01:07:30 <dirk103> wow i was really doing a terrible ugly thing there wasnt i
01:07:31 <dirk103> lol
01:07:31 <arkeet> but yeah, it's more idiomatic to just use  map fst  instead of a list comprehension.
01:07:42 <arkeet> yeah and it wasn't going to work either ;)
01:08:13 <dirk103> i can see how this language is going to be awesome
01:08:13 <arkeet> you could do something awful like [ motorName | i <- [0 .. length motors' - 1], let motorName = fst (motors' !! i) ]
01:08:14 <arkeet> but please don't.
01:08:26 <dirk103> :) eheh ok
01:08:31 <arkeet> :)
01:08:43 <arkeet> it's a much slower and uglier way of doing the same thing.
01:08:44 <shachaf> arkeet: =(
01:08:50 <dirk103> is the let statement soley for the ghci program?
01:09:07 <arkeet> in that list comprehension? no
01:09:29 <arkeet> let has a few uses in a normal .hs file
01:09:34 <arkeet> ghci's input is a little different
01:09:39 <dirk103> okay i'll read up on that
01:10:17 <arkeet> if you know about IO and do syntax, you can kind of pretend that a ghci session happens inside a gigantic do block. (in IO.)
01:10:38 <arkeet> and then the "let" stuff in ghci just comes from how let works inside a do block.
01:10:46 <dirk103> are, loops the same? if i wanted to putStrLn for each element would i have a comprehension iterate over listMotorName?
01:11:08 <dirk103> ohhhh cool
01:11:13 <arkeet> unfortunately it doesn't work that way :(
01:11:26 <arkeet> if you try something like [ print x | x <- motors' ] or whatever
01:11:32 <arkeet> that won't work because
01:11:41 <arkeet> that's a list of IO actions; it's type is [IO ()]
01:11:54 <dirk103> do i have to completely cast away my normal programming thinking and think about this as more of a mathematical process
01:11:54 <arkeet> you need a way of composing them all together into one big IO action.
01:12:16 <dirk103> i think i understand
01:12:26 <arkeet> I don't know how mathematical it is, but your thinking is likely going to be pretty different from other programming languages ;)
01:12:51 <dv-> there are for-like loops in haskell
01:12:59 <dv-> forM_ motors' \m -> print m
01:13:07 <arkeet> forM_ motors' $ \m -> print m
01:13:13 <dv-> oops yeah
01:13:15 <arkeet> or better: mapM_ print motors'
01:13:25 <arkeet> (note how it looks sort of like how you'd use map)
01:13:25 <dirk103> is that a proper way to do that?
01:13:50 <arkeet> which?
01:14:02 <dirk103> anyone
01:14:10 <xkb> mapM_ is quite normal ;)
01:14:16 <dirk103> i need to read mroe that looks like you're just putting random symbols and stuff together to me haha
01:14:20 <arkeet> haha
01:14:30 <arkeet> well:
01:14:32 <arkeet> :t map
01:14:32 <lambdabot> (a -> b) -> [a] -> [b]
01:14:41 <arkeet> map applies a function to each element of a list, collection the results into another list.
01:14:42 <dirk103> %%mapMAP_!! : (a 3---- b)
01:14:58 <dirk103> ohhhh
01:15:01 <arkeet> :t mapM_ :: (a -> IO ()) -> [IO a] -> IO ()
01:15:02 <lambdabot>     Couldn't match type `a' with `IO a'
01:15:02 <lambdabot>       `a' is a rigid type variable bound by
01:15:02 <lambdabot>           an expression type signature: (a -> IO ()) -> [IO a] -> IO ()
01:15:08 <arkeet> er
01:15:13 <arkeet> :t mapM_ :: (a -> IO ()) -> [a] -> IO ()
01:15:13 <lambdabot> (a -> IO ()) -> [a] -> IO ()
01:15:21 <dirk103> cool :T
01:15:23 <xkb> mind the IO there..
01:15:35 <arkeet> xkb: don't want to confuse too much with typeclass business)
01:15:49 <arkeet> dirk103: mapM_ applies a function to each element in a list, but the function has to result in an IO action.
01:15:57 <arkeet> and then it runs all those IO actions together.
01:16:18 <arkeet> (well, it works with other monads too, not IO, but maybe don't worry too much about that.)
01:16:29 <arkeet> :t mapM_ -- the fully general type.
01:16:29 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
01:16:44 <shachaf> :t traverse_
01:16:45 <lambdabot>     Not in scope: `traverse_'
01:16:45 <lambdabot>     Perhaps you meant one of these:
01:16:45 <lambdabot>       `F.traverse_' (imported from Data.Foldable),
01:16:48 <dv-> if you have a larger function to run then forM_ can be clearer
01:16:50 <shachaf> :t F.traverse_
01:16:50 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
01:16:57 <dv-> i.e. forM_ list $ do ...
01:16:58 <arkeet> yes, forM_ is just mapM_ with the arguments flipped.
01:17:15 <arkeet> forM_ list $ \x -> do { some big long thing involving x }
01:17:43 <dirk103> i'm starting to get frightened, gonna go read thanks a lot guys
01:17:44 <dv-> it also nests nicer
01:17:45 <xkb> dirk103: $ is used quite a lot in haskell code
01:17:55 <arkeet> oh yeah, the $ is just
01:17:56 <arkeet> f $ x = f x
01:17:59 <dv-> forM_ $ \x -> forM_ $ \y -> ...
01:18:04 <dirk103> haven't read about $ yet
01:18:09 <arkeet> it saves you from having to write parentheses a lot of the time.
01:18:10 <shachaf> When I first saw mapM_, I thought: There are so many mapping functions that they went all the way up to M, and even then they had to add an _?
01:18:15 <xkb> dirk103: I can recommend the regular books.. LYAH and Real World
01:18:24 <arkeet> shachaf: they had mapA, mapB, mapC, ... first
01:18:54 <dirk103> oh one quick spoiler if you dont mind
01:18:54 <shachaf> Is there a map map?
01:18:58 <dirk103> programming with sockets
01:19:00 <arkeet> :t Map.map
01:19:01 <lambdabot> Couldn't find qualified module.
01:19:04 <arkeet> :t Data.Map.map
01:19:05 <lambdabot> (a -> b) -> M.Map k a -> M.Map k b
01:19:05 <dirk103> and specifying type sizes
01:19:17 <xkb> type sizes?
01:19:38 <dirk103> as in i want to communicate with a C++ application and transmit a unsigned integeter 16 bits long. is that weird to do in haskell?
01:20:04 <arkeet> not really
01:20:05 <dirk103> can you deal with fundamental types like that?
01:20:15 <arkeet> there's a Word16 type for unsigned 16-bit integers
01:20:48 <dirk103> are these types fundamental to the GHC or is it a kind of library defined thing?
01:21:00 <arkeet> it's part of ghc I think
01:21:07 <arkeet> yeah
01:21:20 <xkb> theres Network.Socket for socket programming
01:21:32 <xkb> (have not used it myself, there might be better solutions)
01:21:46 <arkeet> well, that's for the standard low-level socket stuff
01:21:56 <arkeet> there are plenty of things built on top of it
01:22:30 <arkeet> there are also libraries for serializing things like Word16s so you can send them as a stream of bytes, and so on
01:22:52 <arkeet> (well, a lot more things than that)
01:22:59 * hackagebot aws-sdk-xml-unordered 0.1.1 - The xml parser for aws-sdk  http://hackage.haskell.org/package/aws-sdk-xml-unordered-0.1.1 (ShoheiYasutake)
01:23:12 <dirk103> cool
01:23:14 <dirk103> thanks
01:47:55 <Iceland_jack> > Since Haskell people claim to be the only enablers of "true monads", they would of course nitpick about patterns implemented in other languages.
01:47:56 <lambdabot>   <hint>:1:52: parse error on input `of'
01:49:45 <dv-> where's that from?
01:50:19 <Iceland_jack> https://news.ycombinator.com/item?id=6868599
01:51:10 <liftM> not this again...
01:51:14 <Iceland_jack> Indeed
01:51:36 <rdevilla> hasn't this whole jquery monad nonsense been debunked a while ago
01:52:40 <Iceland_jack> rdevilla: Well you can have your definition of monad and I can have mine where jQuery is a monad and we'll agree to disagree ;)
01:52:48 <mauke> hah, I was about to say that sounds like yet another javascript/php/whatever programmer who has "implemented monads"
01:53:20 <Iceland_jack> In fact, personal monad definitions for all!
01:53:36 <simpson> Can we short-circuit the discussion by removing JS from existence?
01:53:43 <Taneb> simpson, that's the plan
01:53:58 <mauke> no, because I actually like parts of JS
01:54:13 <simpson> Why not like Self instead and ignore JS?
01:54:24 <simpson> Or how about Python? I hear that the kids like it.
01:54:27 <mauke> I've never heard of Self
01:54:32 <mauke> and Python is worse than JS
01:54:48 <simpson> Self is the language that inspired JS.
01:54:58 <mauke> does it run in browsers?
01:55:08 <rdevilla> zomg, c++ templates are monads
01:55:09 <mauke> then throw it into the fire
01:55:29 <simpson> Meh. If that's all that's interesting, then Fx nightly runs Python. They don't ship it in releases for political and security reasons.
01:55:44 <mauke> yes, but python is worse than js so that doesn't help me
01:55:45 <simpson> Self's slow and no work ever went into making it faster.
01:56:10 <simpson> Could you explain exactly how? From my vantage point, Python's so much better than JS that it's kind of hard to even consider a fair comparison.
01:56:19 <mauke> python fails at scoping
01:56:34 <mauke> scoping is the most important part of a language
01:56:52 <simpson> Hm. Does `this` have reasonable scoping rules in JS?
01:57:04 <mauke> yes in that it's a function parameter
01:57:19 <simpson> Can't it also be implicit?
01:57:33 <mauke> abstractly speaking, every function in JS has exactly two arguments, 'this' and 'arguments'
01:57:48 <mauke> parameter lists are syntactic sugar for destructuring 'arguments'
01:58:19 <simpson> Hm. So where does `document` come from?
01:58:28 <mauke> global variable
01:58:50 <mauke> or rather, property of The Global Object because unfortunately that's how globals work in JS
01:59:26 <simpson> I would, BTW, posit that types are more important than scoping rules, in that `[] + []` does different things in JS and Python and one of those is surely less unintuitive than the other. :3
01:59:29 <mauke> (only in browsers, of course)
01:59:57 <mauke> simpson: not in my system
02:00:07 <mauke> and by "system" I mean "gut feeling"
02:01:07 <mauke> simpson: + isn't commutative in python. ew
02:01:21 <mauke> (it also isn't commutative in JS, I know)
02:01:52 <shachaf> + ought to be commutative.
02:01:57 <Iceland_jack> >>> 'a' + 'b' == 'b' + 'a'
02:01:57 <Iceland_jack> False
02:02:00 <Iceland_jack> *gasp*
02:02:04 <simpson> I like strong types. Types with conviction.
02:02:14 <shachaf> I like bugs.
02:02:31 <mauke> + is commutative in perl. perl is also the only "dynamic" language to get scoping 100% right.
02:02:40 <pharaun> how did python fail scope?
02:02:53 <simpson> pharaun: Not all statements introduce new scopes.
02:02:54 <mauke> pharaun: it has no explicit variable declarations
02:03:03 <mauke> and python "scopes" are bound to functions
02:03:04 * hackagebot network-dns 1.0 - Domain Name System data structures  http://hackage.haskell.org/package/network-dns-1.0 (MikhailVorozhtsov)
02:03:19 <mauke> and "use of unbound variable" is a runtime exception
02:03:54 <mauke> and the only way to give something a name locally (without polluting the surrounding environment) is string eval
02:04:26 <Iceland_jack> mauke: A friend of mine insisted that ("use of unbound variable" is a runtime exception) is a feature :)
02:04:29 <mauke> the latter is trivial in Haskell: let x = whatever in ...
02:04:41 <pharaun> good ol' string eval
02:04:47 <simpson> mauke: So, you could make your point without comparing apples to basketballs.
02:04:52 <mauke> Iceland_jack: right, because who wants the compiler to detect typos in identifiers anyway!
02:04:55 <simpson> if-statements don't create new scopes. Done.
02:05:01 <mauke> simpson: that's not my point at all
02:05:12 <Iceland_jack> mauke: I don't like admitting I can make mistakes so I don't!
02:05:20 <mauke> Iceland_jack: fair enough
02:05:23 <simpson> mauke: Well, we were comparing JS and Python, not Haskell and Python.
02:05:37 <mauke> simpson: but that's off-topic in #haskell!
02:05:44 <mauke> I will now compare JS and Haskell
02:06:03 <Iceland_jack> I personally prefer Python to JS but I believe X vs Y has been done to death ;)
02:06:08 <simpson> mauke: Y'know what, fine. Whatever. You win. I don't know what you're winning, but great.
02:06:09 <jle`> python better than js? what is this world coming to
02:06:10 <Iceland_jack> for all values of X and Y
02:06:22 <mauke> (function (x) { ... })(whatever);  // is how you get a local 'x' in standard JS
02:06:40 <shachaf> Listening to mauke is often a good idea because he's often right.
02:07:03 <mauke> to translate that into Haskell syntax: (\x -> ...) whatever
02:07:15 <shachaf> Sometimes he's a whole different level of right where his worldview doesn't allow him to see how anyone could be wrong.
02:07:43 <mauke> it's not perfect because JS has return/break/continue but it gets you something usable 99% of the time
02:08:07 <mauke> if you use extensions to push JS closer to Perl, you get something really usable
02:08:20 <mauke> 'use strict'; { let x = whatever; ... }
02:08:21 <shachaf> Which extensions?
02:08:25 <shachaf> Oh.
02:08:39 <mauke> 'use strict' makes the compiler complain about undeclared variables
02:08:41 <jle`> i feel like anyone who uses haskell can appreciate JS
02:08:45 <mauke> 'let' gives you lexically scoped variables
02:08:46 <shachaf> (Maybe #-blah would be better, though.)
02:09:10 <mauke> basically, what Haskell always does
02:09:50 <shachaf> Maybe I should learn Perl.
02:09:55 <liftM> mauke: you said Perl was the only dynamic language to get scoping right. Does Clojure or Racket not do exactly what you want here?
02:10:11 <jle`> i wonder how perl scoping compares to ruby scoping
02:10:28 <jle`> considering how much of the language ruby borrowed from
02:10:34 <jle`> was it just syntactic or was it deeper?
02:10:34 <mauke> liftM: I said "dynamic" because I don't really think it's a useful description
02:10:43 <liftM> ok
02:11:00 <mauke> liftM: I meant the usual suspects perl/ruby/python/php/javascript because the rest aren't as well known
02:11:12 <mauke> e.g. I don't know clojure at all
02:11:29 <mauke> I expect racket to get things right because it's a scheme and scheme invented lexicals (in the lisp world)
02:11:34 <shachaf> Ruby's scoping probably fails multiple mauke tests.
02:11:52 <liftM> yes I believe Clojure and Racket get this right
02:12:30 <jle`> doesn't ruby have two different anonymous function constructs with two different scoping rules?
02:12:57 <shachaf> They aren't scoping rules exactly. But I think this is definitely a #-blah topic.
02:13:05 * hackagebot threepenny-gui 0.4.0.1 - GUI framework that uses the web browser as a display.  http://hackage.haskell.org/package/threepenny-gui-0.4.0.1 (HeinrichApfelmus)
02:13:07 * hackagebot network-dns 1.0.0.1 - Domain Name System data structures  http://hackage.haskell.org/package/network-dns-1.0.0.1 (MikhailVorozhtsov)
02:13:10 <mauke> yeah, I'm going over to #haskell-blah
02:13:10 <jle`> indeed
02:39:18 <pdxleif> Great, I've got an amiguous Control.Monad.Trans from having both monads-tf and mtl installed. :(
02:39:41 <arkeet> hide one of them.
02:39:42 <shachaf> Solution: Uninstall monads-tf
02:39:45 <arkeet> or uninstall
02:39:58 <arkeet> or use package imports
02:41:38 <pdxleif> hakyll depends on snap which depends on MonadCatchIO-transformers which depends on monads-tf
02:42:17 <arkeet> hide monads-tf then
02:42:36 <pdxleif> perfect, thanks
02:42:45 <arkeet> and then bug the snap devs to switch from MonadCatchIO-transformers to exceptions
02:45:45 <allsystemsarego> what's the benefit of using snap over scotty for little toy projects?
02:53:40 <cinimod> Anyone done anything on bigquery?
03:07:15 <Palmik> Hi guys. Did anyone experience "403 Forbidden" when issuing 'cabal upload'?
03:07:46 <mauke> when was the last time you uploaded before that?
03:08:02 <Palmik> Before the migration to Hackage 2.
03:08:18 <mauke> wasn't there an account confirmation thing you had to do?
03:09:18 <Palmik> Hmm, that might be the case.
03:10:58 <Palmik> mauke: Thanks, it's working now. :)
03:13:12 * hackagebot suspend 0.2.0.0 - Simple package that allows for long thread suspensions.  http://hackage.haskell.org/package/suspend-0.2.0.0 (PetrPilar)
03:13:14 * hackagebot timers 0.2.0.2 - Simple package that implements timers.  http://hackage.haskell.org/package/timers-0.2.0.2 (PetrPilar)
03:13:47 <Hugh> Can I ask a question about Yesod here?
03:14:07 <Iceland_jack> Hugh: Sure
03:14:34 <bernalex> Hugh: there's #yesod though.
03:15:55 <Hugh> thanks, is it possible to 'hot load' changes in Yesod?
03:16:19 <Iceland_jack> oh interesting question
03:16:43 <Hugh> In Play, the development cycle is beautiful - change, save, refresh. So far I get the impression Yesod is more 'clunky' and not such a nice development cycle
03:17:01 <Iceland_jack> Hugh: https://groups.google.com/forum/#!msg/yesodweb/YzFGZMdbBHU/niXZ6R8VilMJ is this relevant to your question?
03:19:06 <Hugh> thanks, not really what I am after.. it looks to me that every line of code is re-compiled even if you have only changed the templates.
03:19:30 <Hugh> It just doesn't make for a very nice work flow, and time is money etc
03:24:11 <marx2> why don't Nums have a Monoid instance?  is having no instance better than picking between Product or Sum?
03:25:16 <Iceland_jack> marx2: That's basically it, yes
03:25:50 <Iceland_jack> well you probably mean specific types and not Num in particular
03:26:16 <marx2> yes
03:26:57 <Iceland_jack> The general response is “should it be (*), 1 or (+), 0? either one you pick is going to be non-obvious”
03:33:52 <marx2> I think (+) 0 would be the obvious one
03:34:18 <Iceland_jack> If I had to pick one that's the one I'd choose, but others don't quite agree
03:38:20 <nlogax> Isn't there both Sum and Product somewhere?
03:38:56 <Iceland_jack> nlogax: They're both defined in Data.Monoid if that's what you're asking
03:39:25 <nlogax> Iceland_jack: Ah, yes
04:02:59 <Philonous> marx2, Is it? Juxtaposing two numbers (2a) usually means multiplication, not addition
04:03:18 * hackagebot laborantin-hs 0.1.3.0 - an experiment management framework  http://hackage.haskell.org/package/laborantin-hs-0.1.3.0 (LucasDiCioccio)
04:07:24 <arkeet> @instance Num b => Num (a -> b) where fromInteger = (*) . fromInteger; (+) = liftA2 (+); (*) = liftA2 (*); (-) = liftA2 (-); negate = fmap negate; abs = fmap abs; signum = fmap signum
04:07:24 <lambdabot> Maybe you meant: instances instances-importing
04:07:28 <arkeet> @let instance Num b => Num (a -> b) where fromInteger = (*) . fromInteger; (+) = liftA2 (+); (*) = liftA2 (*); (-) = liftA2 (-); negate = fmap negate; abs = fmap abs; signum = fmap signum
04:07:28 <lambdabot>  .L.hs:164:10:
04:07:29 <lambdabot>      Duplicate instance declarations:
04:07:29 <lambdabot>        instance [safe] N...
04:07:31 <arkeet> @undefine
04:07:32 <lambdabot> Undefined.
04:07:34 <arkeet> @let instance Num b => Num (a -> b) where fromInteger = (*) . fromInteger; (+) = liftA2 (+); (*) = liftA2 (*); (-) = liftA2 (-); negate = fmap negate; abs = fmap abs; signum = fmap signum
04:07:34 <lambdabot>  .L.hs:144:23:
04:07:34 <lambdabot>      Could not deduce (a ~ b)
04:07:34 <lambdabot>      from the context (Num b)
04:07:35 <lambdabot>   ...
04:07:39 <arkeet> hmm.
04:07:45 <arkeet> doh.
04:08:13 <marx2> Philonous I don't find that relevant
04:08:57 <arkeet> @let instance Num b => Num (b -> b) where fromInteger = (*) . fromInteger; (+) = liftA2 (+); (*) = liftA2 (*); (-) = liftA2 (-); negate = fmap negate; abs = fmap abs; signum = fmap signum
04:08:58 <lambdabot>  Defined.
04:09:00 <arkeet> this will have to do.
04:09:01 <arkeet> > 2 3
04:09:02 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
04:09:02 <lambdabot>    arising f...
04:09:08 <arkeet> oh geez.
04:09:39 <arkeet> do we have TypeFamilies? I don't think we do
04:09:46 <arkeet> @let instance (a ~ b, Num b) => Num (a -> b) where fromInteger = (*) . fromInteger; (+) = liftA2 (+); (*) = liftA2 (*); (-) = liftA2 (-); negate = fmap negate; abs = fmap abs; signum = fmap signum
04:09:47 <lambdabot>  Parse failed: TypeFamilies is not enabled
04:09:49 <arkeet> yep
04:09:58 <mauke> > 2 (3 :: Int)
04:10:00 <lambdabot>   No instance for (GHC.Show.Show a0)
04:10:00 <lambdabot>    arising from a use of `M2902436382370...
04:10:06 <arkeet> > 2 3 :: Int
04:10:07 <lambdabot>   No instance for (GHC.Num.Num a0) arising from the literal `3'
04:10:07 <lambdabot>  The type var...
04:10:12 <arkeet> > 2 (3 :: Int) :: Int
04:10:14 <lambdabot>   6
04:10:35 <dv-> :O
04:10:35 <arkeet> yeah, the ~ version would have better inference
04:10:55 <arkeet> oh but it doesn't work when you string multiple ones together
04:12:09 <arkeet> (a * b) c = a (b c)  makes it work better.
04:12:17 <arkeet> >>> 1 2 3 4
04:12:18 <arkeet> 24
04:12:53 <arkeet> > 2 x :: Expr
04:12:54 <lambdabot>   2 * x
04:13:02 <arkeet> at least that much works.
04:18:20 * hackagebot hspec-expectations 0.5.0 - Catchy combinators for HUnit  http://hackage.haskell.org/package/hspec-expectations-0.5.0 (SimonHengel)
04:19:45 <marx2> why is this affecting all the types and not just types that implement Num ?
04:19:51 <marx2> instance Num a => Monoid a where mappend x y = x + y; mempty = 0
04:21:26 <edwardk> startling: note WriterT e m a = m (e, a)  -- EnvT e w a = (e, w a) -- the comonad is in the opposite order. there is no distributive law available for you to make that a monad in general
04:21:35 <edwardk> you'd need representability of m.
04:22:48 <marx2> what's up with this?  why does instance for Num a affect String?  http://lpaste.net/96743
04:23:39 <henk> What import line do I have to use to be able to use the data constructor 'ZipList'? I tried 'import Control.Applicative( (<$>), (<*>), ZipList )' but get back "Not in scope: data constructor `ZipList'".
04:24:00 <dv-> ZipList(..)
04:24:09 <edwardk> marx2: you should read instances as a rule for pattern matching whatever is on the right instance Num a => Monoid a -- says that no matter what 'a' you have you should make the Monoid by using Num for addition. period. there is no backtracking involved in selecting between multiple alternatives
04:24:12 <sipa> marx2: does Char implement Num? if so, then your rule will make Char and [Char] a monoid
04:24:27 <edwardk> because if there was, ten addng an instance elsewhere in your program could change the meaning of code that was already written!
04:24:42 <marx2> I see
04:25:07 <edwardk> so you need to make the instance more specific. you could write instance Monoid Int where mappend = (+); mempty = 0
04:25:13 <henk> dv-: thanks
04:25:18 <edwardk> but you'd need to enumerate the instances you wanted to handle this way
04:25:25 <edwardk> alternately you can use a newtype, like Sum
04:25:36 <edwardk> > mappend (Sum 1) (Sum 2)
04:25:37 <lambdabot>   Sum {getSum = 3}
04:25:41 <edwardk> > getSum $ mappend (Sum 1) (Sum 2)
04:25:42 <lambdabot>   3
04:26:11 <marx2> yeah I realize it exists. I was just wondering if I can implement it generically for all of the Num instances
04:26:12 <arkeet> > getProduct $ mappend (Product 2) (Product 5)
04:26:13 <lambdabot>   10
04:26:17 <edwardk> you can't
04:26:28 <sipa> > getSum $ 1 `liftA2 Sum` 2
04:26:29 <lambdabot>   <hint>:1:20: parse error on input `Sum'
04:26:57 <edwardk> Don't let someone sell you OverlappingInstances as a solution, either. OverlappingInstances in general never do what you expect.
04:27:05 <marx2> edwardk by the way what do you think about having no default Monoid instance for Int, etc?
04:27:52 <edwardk> marx2: the reason is there are may possible monoids for it, max/minBound, min/maxBound, (+)/0, (*)/1 -- which do you choose?
04:28:14 <edwardk> marx2: when there isn't a 'universal' choice, we typically don't choose and delegate that to a newtype
04:28:21 * hackagebot hspec-meta 1.8.1 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.8.1 (SimonHengel)
04:28:23 * hackagebot hspec 1.8.1 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.8.1 (SimonHengel)
04:28:43 * arkeet is tempted to get edwardk started on the Monoid instance for Maybe
04:28:49 <edwardk> arkeet: =P
04:31:42 <mangaba_leitosa> I find myself often doing something like 'max_elements = let max_weight = snd $ maximumBy (\(element1, weight1) (element2, weight2) -> compare weight1 weight2) list in filter ((== max_weight) . snd) list', is there is an idiom for doing it in a concise way?
04:32:12 <marx2> are there any other issues with OverlappingInstances besides the one you mentioned?  ("adding an instance later could change the meaning of code that was already written")
04:32:29 <marx2> because that appears to do what I want
04:32:59 <arkeet> > head . group . sort $ [1,3,1,5,2,1,4]
04:33:00 <lambdabot>   [1,1,1]
04:33:21 <arkeet> > head . group . sort $ [1,3,1,5,2,1,4] ++ replicate 1000000 2
04:33:22 <lambdabot>   [1,1,1]
04:33:22 * hackagebot hspec-expectations-lifted 0.5.0 - A version of hspec-expectations generalized to MonadIO  http://hackage.haskell.org/package/hspec-expectations-lifted-0.5.0 (SimonHengel)
04:33:24 * hackagebot xdot 0.2.4.1 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  http://hackage.haskell.org/package/xdot-0.2.4.1 (DennisFelsing)
04:33:24 <arkeet> > head . group . sort $ [1,3,1,5,2,1,4] ++ replicate 10000000 2
04:33:26 * hackagebot ghc-vis 0.7.2 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.7.2 (DennisFelsing)
04:33:29 <marx2> I can see why that would be a problem by the way, just wondering if there's some other issue I am not aware of
04:33:29 <lambdabot>   mueval-core: Time limit exceeded
04:34:13 <arkeet> > map fst . head . groupBy snd . sortBy (comparing snd) $ [(a,1),(b,2),(c,1)] ++ replicate 1000000 2
04:34:14 <lambdabot>   Occurs check: cannot construct the infinite type:
04:34:15 <lambdabot>    a0 = (Debug.SimpleRefl...
04:34:18 <arkeet> > map fst . head . groupBy snd . sortBy (comparing snd) $ [(a,1),(b,2),(c,1)]
04:34:19 <lambdabot>   Occurs check: cannot construct the infinite type:
04:34:19 <lambdabot>    a0 = (Debug.SimpleRefl...
04:34:29 <mangaba_leitosa> arkeet: I would like to avoid sorting the list
04:34:31 <arkeet> > map fst . head . groupBy ((==) `on` snd) . sortBy (comparing snd) $ [(a,1),(b,2),(c,1)]
04:34:32 <lambdabot>   [a,c]
04:34:33 <marx2> (and out of curiosity, which Monoid instance would be choosen for string if one was to implement a weird Num instance for String?)
04:34:45 <arkeet> hm, I guess I'm counting on sort being sufficiently lazy.
04:34:53 <arkeet> which it probably isn't.
04:35:03 <arkeet> an insertion sort could be, though.
04:35:30 <arkeet> marx2: things get hard to predict with Overlapping/IncoherentInstances
04:37:49 <marx2> I guess TemplateHaskell could be used to avoid code duplication like this.
04:39:58 <stewe> could IO be implemented without monads?
04:40:03 <arkeet> yes!
04:40:04 <Iceland_jack> It was once
04:40:19 <Iceland_jack> also it is in other languages :) depending on what you mean by your question anyway
04:40:26 <stewe> really? how was it implemented?
04:40:40 <arkeet> it wasn't very nice in haskell before.
04:40:51 <arkeet> http://r6.ca/blog/20110520T220201Z.html
04:41:06 <Iceland_jack> There were several ways, stream of requests and responses
04:41:16 <mauke> you could implement IO without monads exactly as it is now
04:41:25 <mauke> (>>=) :: IO a -> (a -> IO b) -> IO b
04:41:34 <mauke> return :: a -> IO a
04:41:57 <arkeet> also http://stackoverflow.com/questions/13536761/what-other-ways-can-state-be-handled-in-a-pure-functional-language-besides-with/13538351#13538351
04:42:29 <arkeet> this answer is a very good read.
04:43:23 * hackagebot hspec-expectations 0.5.0.1 - Catchy combinators for HUnit  http://hackage.haskell.org/package/hspec-expectations-0.5.0.1 (SimonHengel)
04:48:24 * hackagebot hspec 1.8.1.1 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.8.1.1 (SimonHengel)
04:55:34 <stewe> are there any other pure languages in use today that implement IO differently than haskell?
04:55:45 <Iceland_jack> Clean is one
04:59:21 <stewe> I know it is subjective, but is it less or more convenient to use IO like that?
05:11:56 <merijn> stewe: "It depends"
05:12:39 <merijn> There's other languages using uniqueness types (Clean's solution to IO), but I'm not sure either approach is more convenient/easier
05:12:47 <merijn> They seem to mostly just be different
05:15:31 <merijn> stewe: Incidentally, not mentioned in the SO answer is that haskell hasn't always used monads for IO, they were added after the language's invention when some people realised "hey, this is really useful"
05:16:31 <stewe> ah interesting
05:16:41 <merijn> stewe: So it's not like they're some abstract idea forced upon haskellers and us all suffering from Stockholm syndrome. They were embraced because it proved such a useful and generic tool
05:17:04 <zelvosaur> Hello. I am space profiling my program and when running with the -hc option, the graph contains lots of memory marked as PINNED. What does it mean? Can I find what pinned the memory and how to get rid of it?
05:18:38 <henk> I have two lists of functors (Maybe DateTime) and need to zip them into one list using the diffSeconds function (lines 42-45 in http://lpaste.net/96744). I’m just learning about applicative functors, but I’m not quite sure how to use them here. Any advice please?
05:21:12 <Philonous> @type \f -> zipWith (liftA2 f)
05:21:12 <lambdabot> Applicative f => (a -> b -> c) -> [f a] -> [f b] -> [f c]
05:24:07 <Philonous> henk, It's almost always easier to just use zipWith than to go the ZipList/Applicative route.
05:26:02 <Philonous> henk, but if you want to you have to take care of both Applicatives
05:26:12 <henk> Philonous: yay, perfect, thank you.
05:26:32 <Philonous> @type liftA2 . liftA2 :: (a -> b -> c) -> [Maybe a] -> [Maybe b] -> [Maybe c]
05:26:32 <lambdabot> (a -> b -> c) -> [Maybe a] -> [Maybe b] -> [Maybe c]
05:27:05 <Philonous> Oh, well, that was the wrong Applicative instance, but you get the point.
05:29:07 <henk> Philonous: I’m afraid I don’t ):
05:31:35 <henk> I tested a few things using liftA2 and sequenceA (to have 'Maybe [a]' instead of '[Maybe a]') but couldn’t quite figure out how to apply them correctly
05:33:00 <Philonous> henk, Nested applicatives aren't automatically handled. That is, liftA f will lift f only one level, for example from (a -> b) to [a] -> [b], but not to [Maybe a] -> [Maybe b]. You have to use liftA twice for that to work.
05:35:14 <henk> Philonous: ah, yes, that makes sense (: Could you repeat that @type-line with the correct instances please? I’m not sure what you meant is wrong about that …
05:36:15 <Philonous> henk, I used [] instead of Ziplist
05:36:38 <Philonous> @type liftA2 . liftA2 :: (a -> b -> c) -> ZipList (Maybe a) -> ZipList (Maybe b) -> ZipList (Maybe c)
05:36:39 <lambdabot> (a -> b -> c) -> ZipList (Maybe a) -> ZipList (Maybe b) -> ZipList (Maybe c)
05:41:08 <henk> oh, right, thank you very much (:
05:45:50 <albertid> Hi, how can I filter a  "Gen a"? I'd like to use sth like mfilter (a -> Bool) -> M a -> M a but it is only defined on MonadPlus which Gen is not an instance of.
05:48:35 <albertid> ah, "suchThat"
06:13:35 * hackagebot errorcall-eq-instance 0.1.0 - An orphan Eq instance for ErrorCall  http://hackage.haskell.org/package/errorcall-eq-instance-0.1.0 (SimonHengel)
06:32:25 <_Vi> How to use "plugins"? In my system   H.eval_ "1 + 6 :: Int" [] [] [] [] :: IO (Either [String] (Maybe Int))   leads to   Left ["","on the commandline:","    Warning: -fglasgow-exts is deprecated: Use individual extensions instead"]
06:33:58 <_Vi> BTW can I use Safe Haskell with this "plugins"?
06:35:42 <donri> _Vi: should work with any ghc extension i imagine. but note that safe haskell doesn't give you safe *compilation*
06:35:50 <donri> stepcut: ^
06:36:38 <_Vi> Haskell compilation can execute arbitrary code?
06:37:04 <donri> _Vi: there's a number of unsafe things http://hackage.haskell.org/trac/ghc/wiki/SafeHaskell/SafeCompilation
06:37:13 <_Vi> BTW will "plugins" work in embedded way? I.e. single binary transparently compiles and loads modules from source code without requiring many files in distribution?
06:37:28 <donri> plugins requires ghc at runtime
06:38:04 <donri> although not sure it uses the binary or the library
06:38:08 <_Vi> Is it easy to distribute ghc with the program? Is it few files that can be placed anywhere or something big required to be present?
06:38:35 <_Vi> strace -fe execve ./plugins_test shows "ghc" and "as" being executed.
06:38:48 <donri> _Vi: btw try eval_ with ["-fno-glasgow-exts"]
06:38:51 <Twey> _Vi: GHC is a compiler.  It's large.
06:39:44 <donri> _Vi: if all you want is eval, you might prefer the hint package though
06:39:48 <donri> it embeds ghci, basically
06:40:07 <donri> (the interpreter, not the repl)
06:41:16 <_Vi> Left ["","on the commandline:","    Warning: -fglasgow-exts is deprecated: Use individual extensions instead","","on the commandline:","    Warning: -fno-glasgow-exts is deprecated: Use individual extensions instead"]
06:41:28 <donri> hah ok
06:41:58 <donri> _Vi: -fno-warn-deprecated-flags then?
06:42:25 <donri> i'd say it's a bug or limitation that it fails on warnings, but just trying to work around the issue...
06:43:53 <asdf1234> Why does FRP seem so bound to the idea of time deltas?
06:44:06 <haasn> asdf1234: not all schools of FRP are
06:44:30 <_Vi> Right (Just 7)
06:44:33 <haasn> not fundamentally, at least
06:44:44 <asdf1234> hmm.. all of the packages I see recommended use it
06:44:49 <_Vi> (However before that it was "Segmentation fault")
06:45:03 <donri> fun
06:45:14 <asdf1234> haasn: I don't understand why they would be, though.
06:45:55 <CodeB> 1
06:45:56 <CodeB> 2
06:46:03 <CodeB> ups..
06:46:40 <haasn> asdf1234: well, I guess FRP aims to simulate/represent values that are continuous over time; but since computers and algorithms are discrete in nature that means compensating for the time delta between iterations somehow
06:47:10 <haasn> though some are purely event/signal-driven
06:47:19 <haasn> like early versions of netwire (if you ignore the built-in time delta)
06:47:25 <haasn> you can use it as a purely event-driven network
06:47:38 <haasn> with iterations being as fast or as slow as you want
06:48:39 * hackagebot base-compat 0.3.0 - A compatibility layer for base  http://hackage.haskell.org/package/base-compat-0.3.0 (SimonHengel)
06:48:48 <Eduard_Munteanu> :t from
06:48:49 <lambdabot> (Functor f, Profunctor p) => AnIso s t a b -> p t (f s) -> p b (f a)
06:49:04 <maybefbi> How do I find a suitable `magic` for this: Pipes.Csv.encode `magic` Pipes.Csv.decodeMany
06:49:16 <Eduard_Munteanu> Why does that take AnIso?
06:50:10 <erisco> Data.Graph appears designed such that if you want to store data on vertices and edges you have to maintain two other maps
06:50:17 <erisco> is this the intended design?
06:51:03 <asdf1234> erisco: probably.. graphs without mutability are hard
06:56:47 <erisco> that is true. I suppose to represent an NFA I would be better using [(Int, Maybe a, Int)]
06:57:21 <erisco> indirect tying of the knot
07:03:05 <erisco> is there a name given to functions of type "a -> a -> a" ?
07:03:13 <erisco> are they all monoids?
07:03:23 <Iceland_jack> erisco: No
07:03:30 <Iceland_jack> that's just a binary function
07:04:03 <erisco> what if I have an mempty?
07:04:05 <Eduard_Munteanu> :t (curry fst, curry snd)
07:04:06 <lambdabot> (c -> b -> c, a -> c1 -> c1)
07:04:07 <donri> a function to an endomorphism :)
07:04:27 <Iceland_jack> erisco: A monoid is an mempty + mappend + type + laws
07:05:04 <erisco> of course then the burden is wrapping and unwrapping types
07:05:06 <Iceland_jack> it's not a function, not an element or type but an agebraic structure
07:05:08 <Iceland_jack> *algebraic
07:05:32 <donri> a -> a is an endomorphism, which is a monoid with mempty = id; mappend = (.)
07:05:54 <donri> :t Endo
07:05:54 <lambdabot> (a -> a) -> Endo a
07:06:20 <Iceland_jack> I question the usefulness of explaining things in terms of endomorphisms to erisco :)
07:07:17 <Iceland_jack> erisco: Monoids have binary operators (mappend :: a -> a -> a), but not all binary operations are parts of a monoid
07:07:22 <Iceland_jack> *are part
07:07:28 <Iceland_jack> *operations
07:07:30 <erisco> Iceland_jack, yes, thank-you
07:08:23 <donri> if you mean functions like a -> b -> c, we call those binary and/or curried
07:08:26 <stewe> what is minBound? it is not a function it seems.. so what is it?
07:08:37 <Iceland_jack> stewe: Polymorphic constant
07:08:45 <donri> stewe: it's a constant
07:08:54 <Twey> It's a function on a type.  ;)
07:09:10 <Twey> :t minBound
07:09:11 <lambdabot> Bounded a => a
07:09:12 <Iceland_jack> Twey: Not in Haskell it's not :)
07:09:24 <Twey> Iceland_jack: With implicit application!
07:09:27 <Iceland_jack> heh
07:09:41 <Iceland_jack> It's a function on a record of methods in Core!
07:09:48 <Twey> Mathematically speaking, it is (that is, its value depends on a type)
07:09:48 <stewe> and we have one distinct constant per type?
07:09:56 <Iceland_jack> stewe: That's right
07:09:58 <Twey> stewe: Yes (for every type that implements Bounded)
07:10:03 <Iceland_jack> they don't have to be distinct though
07:10:20 <donri> stewe: yes, just as functions in a type class are "constant values" bound to functions / with a function type
07:10:29 <donri> (ie. it's not a special case of non-functions)
07:10:53 <donri> ehh "value bound to" is not right
07:11:22 <erisco> is a unary operator named by symbols possible in Haskell without requiring surrounding parentheses?
07:11:36 <Iceland_jack> > let ε = 0 in ε
07:11:37 <lambdabot>   0
07:11:44 <Iceland_jack> oh sorry, no
07:12:02 <Iceland_jack> you can use a postfix operator but you always require parentheses
07:12:21 <Twey> Is PostfixOperators standard now?
07:12:27 <Iceland_jack> No
07:12:30 <skypers> > let (a>!<) = a * 2 in (4>!<)
07:12:31 <lambdabot>   <hint>:1:6: Parse error in pattern: a >!<
07:12:44 <Iceland_jack> Twey: Speaking of which, I found a pretty nifty use-case for post-fix operators
07:12:59 <donri> is there any good reason it's not standard? i guess it affects inlining
07:13:03 <erisco> what is a single tilde reserved for?
07:13:07 <erisco> :t (~)
07:13:08 <lambdabot> parse error on input `)'
07:13:09 <donri> type equality
07:13:13 <Iceland_jack> Why would it affect inlining?
07:13:18 <Iceland_jack> It's purely syntactic
07:13:24 <donri> Iceland_jack: so is inlining
07:13:47 <Iceland_jack> You can convert from a post-fix operator into a regular unary function
07:13:55 <Iceland_jack> so I'm not sure what you mean
07:13:58 <skypers> :k (~)
07:13:59 <lambdabot> * -> * -> Constraint
07:14:31 <Twey> Iceland_jack: Oh?
07:15:05 <Iceland_jack> I was talking to a friend of mine about modelling music in Haskell and she wanted to model notes
07:15:25 <Iceland_jack> and I suggested: (:♯) ∷ Note → Annote, (:♭) ∷ Note → Annote, …
07:15:28 <donri> Iceland_jack: well i'm not sure it does affect inlining, but it wouldn't surprise me
07:15:32 <donri> "Moreover, GHC will only inline the function if it is fully applied, where "fully applied" means applied to as many arguments as appear (syntactically) on the LHS of the function definition."
07:15:35 <Iceland_jack> (Annote = Annotated + Note)
07:16:03 <Iceland_jack> you can then define (note ♯) = (note :♯)
07:16:22 <Iceland_jack> I find that a far better motivating example than the usual... (6!) = product [1..6]
07:16:33 <donri> postfix translates (e!) to ((!) e) as opposed to (\y -> (!) e y) so that might affect inlining of (!) here
07:16:35 <Twey> Nice
07:17:07 <erisco> oh, damn... Data.Map union time is O(n+m) ?
07:17:11 <Iceland_jack> donri: But if you'd use fact = (!) in the first place it would be the same situation?
07:17:19 <Iceland_jack> You'd end up with (fact e)
07:17:32 <donri> Iceland_jack: oh i'm talking about other operators in the same module being affected
07:17:40 <donri> sections for binary operators
07:17:41 <Iceland_jack> Ah I see
07:18:10 <erisco> that seems to mean that constructing a map recursively would be O(n^2)
07:19:39 <donri> :t M.unions
07:19:40 <lambdabot> Ord k => [M.Map k a] -> M.Map k a
07:20:44 <watermind> Twey: donri: weird, I was trying that extension, but even explicitely specifying the extension doesn't seem to work  http://lpaste.net/96745
07:20:48 <watermind> am I missing something here?
07:21:21 <donri> watermind: you need to enable it at the usage site, not the definition site
07:21:32 <donri> (although it might be needed there too, not sure)
07:21:34 <Twey> MasseR_: You probably loaded it into a GHCi that didn't have it enabled
07:21:41 <Twey> Er, watermind
07:21:55 <donri> nice mistab
07:21:56 <Twey> watermind: Try :set -XPostfixOperators
07:22:10 <Twey> donri: I'm far from my screen and I read it as ‘mastermind’ :þ
07:23:01 <donri> nice reado (what's the dual of typo?)
07:23:21 <Twey> donri: Cotypo
07:23:30 <watermind> Twey: donri: Ah thank you
07:23:42 <donri> co-medy
07:23:55 <Iceland_jack> donri: *groan*
07:24:05 <Iceland_jack> What do category theorists drink on a cold winder night?
07:24:07 <Iceland_jack> *winter
07:24:11 <Iceland_jack> Hot a.
07:24:52 <watermind> is there a way to list all the set options?
07:25:01 <Iceland_jack> All the set options?
07:25:09 <watermind> nevermind
07:25:13 <watermind> just found it
07:25:14 <Iceland_jack> You can do:
07:25:14 <Iceland_jack>     :info Data.Set
07:25:14 <Iceland_jack> to get a list of functions + data types
07:25:18 <donri> :set TAB
07:25:26 <watermind> Iceland_jack: I meant :set options
07:25:30 <watermind> donri: thanks!
07:25:33 <Iceland_jack> ah, hah
07:26:01 <donri> watermind: also man ghc. :set just sets the ghc arguments
07:26:08 <watermind> fortunatelly there's only 644 of them
07:27:33 <donri> well they're structured :) :set -XTAB (list of extensions) :set -fTAB (list of flags) :set -dTAB (list of debug options) etc
07:27:56 <donri> but better read the manual ;)
07:28:05 <watermind> ah
07:29:27 <donri> also the user guide https://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
07:29:35 <donri> or for that matter https://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html
07:29:56 <watermind> donri: yes I'm on it, thanks donri
07:34:55 <darthdeus> is there a way that i can check if a partial function is defined for a specific value?
07:35:09 <Iceland_jack> It's strictly possible but you shouldn't
07:35:11 <darthdeus> (i've been learning some scala lately and trying to understand why they would want partial funcitons as a separate type)
07:35:27 <Kron> hmm, i'm not sure I even understand that question
07:35:31 <Kron> defined for a specific value?
07:35:45 <Iceland_jack> It depends how it's partial
07:35:49 <Eduard_Munteanu> darthdeus: you have nicer partial functions in Haskell too, without those downsides: a -> Maybe b
07:35:56 <darthdeus> Kron: foo 1 = 3    ... how do i define if it's defined for 2?
07:36:02 <darthdeus> s/define/check
07:36:11 <Kron> ahh
07:36:11 <Iceland_jack> darthdeus: What if it loops?
07:36:20 <Kron> no I don't think so, but there's a deeper question here:
07:36:25 <Kron> can code like that even be well formed in haskell?
07:36:29 <Kron> haskell isn't object oriented
07:36:31 <Eduard_Munteanu> That's some other form of partiality than the one he's looking at.
07:36:35 <Kron> you can't have heterogenous lists of mystery functions
07:36:49 <Kron> everything you work with is, on some level, very clearly defined in what it can or cannot do
07:36:56 <rdevilla> > let foo 1 = 3
07:36:57 <lambdabot>   not an expression: `let foo 1 = 3'
07:36:57 <darthdeus> well from what i understand the reason they have this is that they can kinda chain partial functions until one of them matches
07:37:03 <rdevilla> hm I cannot lambdabot
07:37:05 <Kron> that's why the compiler can speed things up so much, by taking scandalous liberties
07:37:14 <Kron> interesting
07:37:22 <geekosaur> rdevilla, `let foo 1 = 3` is not a self-contained expression
07:37:22 <Hodapp> Haskell's not object-oriented?
07:37:28 <Iceland_jack> > let foo 1 = 3 in foo 1
07:37:29 <lambdabot>   3
07:37:30 <ij> Kron, Isn't that pattern matching?
07:37:30 <Iceland_jack> there you go
07:37:31 <Philonous> darthdeus, Checking for partiality is a side effect.
07:37:34 <rdevilla> @let foo 1 = 3
07:37:35 <lambdabot>  .L.hs:154:1: Warning:
07:37:35 <lambdabot>      Pattern match(es) are overlapped
07:37:35 <lambdabot>      In an equat...
07:37:41 <rdevilla> @let foo 3 = 4
07:37:41 <lambdabot>  .L.hs:154:1: Warning:
07:37:41 <lambdabot>      Pattern match(es) are overlapped
07:37:41 <lambdabot>      In an equat...
07:37:44 <rdevilla> ._.
07:37:48 <darthdeus> for example you can have one function that matches on 42, another for 43, etc.
07:37:55 <Kron> I see what you're doing here
07:38:00 <geekosaur> rdevilla, you need to do them in a single expression
07:38:01 <darthdeus> Philonous: how so? i thought matching happens on the constructors somehow?
07:38:06 <Kron> it doesn't have first class functionality for that no, but you can accomplish it yourself I think
07:38:12 <geekosaur> .@let foo 1 = 3; foo 3 = 4; ...
07:38:18 <Kron> Using an Either monad or some similar structure
07:38:21 <rdevilla> @let foo 1 = 3; foo 3 = 4
07:38:21 <lambdabot>  .L.hs:154:1: Warning:
07:38:21 <lambdabot>      Pattern match(es) are overlapped
07:38:21 <lambdabot>      In an equat...
07:38:24 <geekosaur> (note leading dot, it appears `foo` is already in use)
07:38:26 <Kron> I've seen similar structures in emacs hooks
07:38:28 <geekosaur> use a different na,e
07:38:31 <geekosaur> *name
07:38:36 <rdevilla> @let foo' 1 = 3; foo' 3 = 4
07:38:37 <lambdabot>  Defined.
07:38:38 <rdevilla> > foo' 2
07:38:39 <lambdabot>   *Exception: L.hs:(156,1)-(157,10): Non-exhaustive patterns in function foo'
07:38:56 <Kron> ij: you can't stack different patterns in different parts of your code
07:38:56 <Hodapp> darthdeus: if I get what Philonous is saying, it relates to the fact that when you've found a partial function that fails to terminate, there is no way for the code to be aware of it.
07:39:09 <Kron> it's not reasonable to assume that each separate function pattern is its own 'function shard' independent of the others
07:39:17 <darthdeus> Hodapp: so i can't check if it will match beefore i call it?
07:39:20 <magnap> @let fib 0 = 1; fib 1 = 1
07:39:21 <lambdabot>  Defined.
07:39:22 <Kron> that's a bit of a confusing mistake that the notation kind of implies
07:39:37 <darthdeus> i mean obviously i can have a funciton that returns Nothing in the default match to kinda simulate this behavior
07:39:59 <Kron> darthdeus: all functions are fundamentally black boxes, you'll have to build your own self aware functions using your own types
07:40:06 <Philonous> darthdeus, More specifically, observing _|_ is a side-effect. You can model partial functions for example with (a -> Maybe b). In that case you can just match Nothing.
07:40:08 <darthdeus> i'm asking if it's possible to have     let foo 2 = 3;   let bar = if foo `matchesOn` 2 then foo 2 else 3
07:40:13 <Kron> though I can definitely see this being useful
07:40:19 <geekosaur> and the answer is "not really"
07:40:41 <geekosaur> there are some ugly tricks that will work for simple cases but they're ugly for a reason; you're Doing It Wromhg
07:40:43 <geekosaur> *Wrong
07:40:47 <darthdeus> Philonous: yeah i understand the Maybe case, but i dont understand why matching is a side-effect?
07:40:53 * geekosaur is Ty[ping It Wrong...
07:41:05 <darthdeus> geekosaur: i'm not doing it this way :P scala is
07:41:15 <darthdeus> i'm just trying to understand the herp derpiness in it
07:41:20 <Kron> I don't think it's matching itself
07:41:20 <Eduard_Munteanu> darthdeus: yes... matchesOn f x = isJust (f x)
07:41:27 <Kron> it's observing _|_
07:41:31 <Kron> _|_ is the abyss
07:41:37 * darthdeus is confused
07:41:38 <Kron> to stare into it is to accept that it will stare back into you
07:41:49 <Philonous> darthdeus, Mathing is not, but catching exceptions is. And failing pattern matches produce exceptions
07:41:53 <Philonous> matching*
07:42:16 <mcstar> they can avoid wrapping in the Maybe type but still can write correct code, probably thats the reason
07:42:18 <darthdeus> Philonous: ah, so what you meant is that the only way i can figure this out is to catch the exception that gets thrown
07:42:18 <magnap> @let fibList = map memoFib [0..]; fib = fibList !!; memoFib 0 = 1; memoFib 1 = 1; memoFib n = fib (n - 1) + fib (n - 2)
07:42:18 <lambdabot>  Parse failed: Parse error in expression: fibList !!
07:42:27 <Philonous> darthdeus, Yes
07:42:32 <darthdeus> Philonous: thanks, that makes sense :)
07:42:37 <geekosaur> darthdeus: java has a privileged value that any object variable can point to. this is because it's not actually strongly typed; a "type" in java or scala or etc. is a value that can respond to some message (the type "exists" at runtime)
07:43:00 <magnap> @let fibList = map memoFib [0..]; fib = (!!) fibList; memoFib 0 = 1; memoFib 1 = 1; memoFib n = fib (n - 1) + fib (n - 2)
07:43:01 <lambdabot>  .L.hs:156:1:
07:43:01 <lambdabot>      Multiple declarations of `fib'
07:43:01 <lambdabot>      Declared at: .L.hs:152...
07:43:03 <Kron> that is actually a fascinating way to phrase it
07:43:08 <geekosaur> in haskell, types exist at compile time and must be resolved at compile time. and you can't represent "not defined for this value" without using something like Maybe
07:43:10 <Kron> I'm personally used to CLOS from common lisp
07:43:17 <Philonous> darthdeus, I've actually played around with this. It's gets really ugly, For example, what happens when the function itself matches but it has a failing pattern match inside it?
07:43:17 <Kron> but yes, types fundamentally do not exist at run time
07:43:19 <darthdeus> hmm interesting
07:43:19 <Eduard_Munteanu> > let matchesOn f x = case f x of { Just _ ->  True; Nothing -> False }; test 2 = Just 5; test _ = Nothing in (test `matchesOn` 2, test `matchesOn` 3)
07:43:20 <lambdabot>   (True,False)
07:43:23 <Kron> it's just code the compiler knows Just Works
07:43:24 <mcstar> also, this `matchesOn` looks similar to  == NULL is conventional languages
07:43:29 <Kron> which is why heterogenous lists don't work
07:43:30 <geekosaur> yes
07:43:32 <Eduard_Munteanu> darthdeus: ^^
07:43:47 <magnap> @let fibList = map memoFib [0..]; memoizedFib = (!!) fibList; memoFib 0 = 1; memoFib 1 = 1; memoFib n = memoizedFib (n - 1) + memoizedFib (n - 2)
07:43:48 <lambdabot>  Defined.
07:44:02 <magnap> > memoizedFib 40
07:44:03 <lambdabot>   165580141
07:44:06 <geekosaur> I think they even use `null` to represent that. in haskell terms, all types are Maybe
07:44:12 <magnap> > memoFib 40
07:44:14 <lambdabot>   165580141
07:44:28 <geekosaur> (except the unboxed ones, but autoboxing obscures that)
07:44:32 <magnap> @let fib n = fib (n-1) + fib (n-2)
07:44:33 <lambdabot>  Defined.
07:44:38 <magnap> > fib 40
07:44:41 <lambdabot>   mueval-core: Time limit exceeded
07:44:46 <magnap> > memoizedFib 40
07:44:47 <lambdabot>   165580141
07:45:09 <magnap> > memoizedFib 1000
07:45:10 <lambdabot>   703303677114228158218352548771835497701812698363587327426049050871545371181...
07:45:12 <darthdeus> damn, now i wanna do haskell :( Maybe seems much more safe than partial functions throwing match errors :P
07:45:36 <magnap> darth: Just wait 'till you hear about Either
07:46:12 <Kron> darthdeus: I was talking about the Either system earlier. Either can be one of two values
07:46:14 <Eduard_Munteanu> darthdeus: you can simulate pattern-matching exceptions if you use Maybe as a monad
07:46:15 <haasn> magnap: now use a trie instead of a list!
07:46:19 <Kron> so you can have a function return Either Int String
07:46:23 <Kron> and it gives you one or the other
07:46:37 <magnap> haasn: trie?
07:46:38 <Kron> and any other function using the output of the first function must prove it adequately accounts for both cases
07:46:40 <Kron> before it compiles
07:46:49 <darthdeus> Kron: yeah, i can see that being useful in this case :)
07:46:50 <Twey> geekosaur: ‘Java is not is not strongly typed’
07:46:55 <haasn> magnap: http://hackage.haskell.org/package/MemoTrie and friends
07:46:57 <Kron> indeed
07:47:01 <Kron> you can have something like
07:47:06 <Twey> geekosaur: That's only partially true
07:47:07 <Kron> Either Inputtype Outputtype
07:47:17 <Kron> and each new function can check if the inputtype has been 'processed' yet
07:47:20 <Kron> and once it has, it ignores it
07:47:22 <ion> magnap: memoFib is still inefficient.
07:47:25 <Kron> and if not, it tries to match it
07:47:34 <Eduard_Munteanu> > let foo = Just 3 in do { a <- foo; return a }
07:47:36 <lambdabot>   Just 3
07:47:41 <Eduard_Munteanu> > let foo = Nothing in do { a <- foo; return a }
07:47:42 <lambdabot>   Nothing
07:47:50 <magnap> ion; it uses the list?
07:48:02 <Eduard_Munteanu> Because Monad has 'fail'.
07:48:15 <ion> magnap: memoFib traverses the list twice.
07:48:33 <magnap> ion: how might i change that?
07:48:37 <Philonous> Eduard_Munteanu, Unfortunately, it does.
07:48:46 * hackagebot SFML-control 0.2.0.0 - Higher level library on top of SFML  http://hackage.haskell.org/package/SFML-control-0.2.0.0 (AlfredoDiNapoli)
07:48:55 <Eduard_Munteanu> You can even distinguish pattern-match failures from other errors, if you use Either.
07:48:56 <Twey> geekosaur: It's strongly typed, but there are some holes in the type-system (like arrays).  They're mostly deprecated, though.  Generics are type-erased, but the base type functions aren't.
07:49:16 <ion> > let fibs = -55 : 34 : zipWith (+) fibs (tail fibs) in fibs
07:49:17 <lambdabot>   [-55,34,-21,13,-8,5,-3,2,-1,1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,...
07:49:30 <ion> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs); fib = (fibs !!) in fib 1000
07:49:31 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
07:50:08 <Kron> does anyone know how I can try out structured-haskell-mode?
07:50:33 <Philonous> Eduard_Munteanu, How so?
07:50:57 <Twey> I'm really surprised lambdabot didn't just time-out
07:51:15 <Kron> lambdabot is life
07:51:17 <Kron> lambdabot is love
07:51:22 <Kron> embrace lambdabot
07:51:23 <Feuerbach> Kron: there are instructions in the README
07:51:36 <Kron> where exactly do I even download it? '^^
07:51:42 <Kron> I've heard of it, don't see it in M-x list-packages
07:51:44 <Eduard_Munteanu> Philonous: let fail _ = Left PatternMatchError and 'throw' other exceptions
07:51:46 <Twey> Kron: https://github.com/chrisdone/structured-haskell-mode/
07:51:55 <Kron> ah! thank you!
07:52:02 <Twey> I don't think it's in ELPA yet; you'll have to install it yourself
07:52:09 <Kron> understood
07:52:12 <Eduard_Munteanu> :t throwError
07:52:13 <lambdabot> MonadError e m => e -> m a
07:52:38 <Eduard_Munteanu> @src MonadError
07:52:38 <lambdabot> class (Monad m) => MonadError e m | m -> e where
07:52:38 <lambdabot>     throwError :: e -> m a
07:52:38 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
07:52:47 <Kron> "deletes your Emacs configuration (worse!)" oooorrrrr maybe I'll wait a bit. Yes.
07:53:08 <Philonous> Eduard_Munteanu, Oh, you in ErrorT, not in straight Either.
07:53:11 <Philonous> mean*
07:53:20 <Twey> Kron: You could just back it up :þ
07:53:58 <Philonous> Twey, For a second I thought you where citing a certain mall cop
07:53:59 <Eduard_Munteanu> Philonous: you can do it with Either too, if you refrain from calling fail manually and perhaps define a throw helper
07:53:59 <Feuerbach> Kron: it's a feature, actually. Forces you to think of backups
07:54:07 <Kron> back ups are for casuals. I do everything using one copy, all loaded into RAM, on a laptop that screams like a jet engine from overheating and age
07:54:12 <Kron> Get on my level D:
07:54:34 * Kron puts Danger Zone on repeat
07:54:48 <Feuerbach> Kron: then you must be programming in ed
07:54:50 <mcstar> ssd's make backups easier
07:54:57 <Twey> Kron: You joke, but I actually do that
07:55:05 <Kron> Twey: that is actually kinda hilarious then
07:55:19 <Twey> (sometimes I save copies elsewhere though :þ)
07:55:26 <Kron> I DO use a laptop, it doesn't quite scream unless I'm playing Dota 2 though
07:55:41 <Feuerbach> mcstar: how exactly?
07:55:48 <Twey> I've got two fans blasting the underside to try desperately to keep it from overheating
07:55:51 <mcstar> they are small in capacity
07:56:12 <Kron> Twey: I feel your pain. My laptop is right now propped on a general relativity textbook
07:56:18 <Kron> who knew physics could be so useful?
07:56:39 <Twey> Fuuzetsu used TAPL to put his monitor on the other day.  You guys are bad people.
07:57:13 * mcstar needs to set up a NAS badly
07:57:46 <magnap> ion: sorry, lost my connection. How could i as an example make memoFib even more efficient?
07:59:26 <Kron> magnap: you're traversing the list twice I think
07:59:37 <Kron> "fib n = fib (n-1) + fib (n-2)"
07:59:45 <magnap> Kron: yes, but how can I avoid doing so?
07:59:45 <Kron> if each fib call is a (!!) in a memoized list
08:00:03 <Kron> then fib (n-1) and fib (n-2) each start from the beginning of the list and go to n-1 and n-2
08:00:16 <Kron> you want to build a helper function that traverses just once and pulls out two adjacent values
08:00:50 <Kron> fib n = a + b where (a,b) = pairAt (n-2) fiblist
08:00:52 <Kron> something like that
08:01:04 <Kron> mind you, pairAt isn't an actual thing (I think) I just made it up
08:02:26 <magnap> @let pairAt _ [] = []; pairAt 1 [x:y:rest] = (x,y); pairAt n [x:xs] = pairAt (n-1) xs
08:02:27 <lambdabot>  .L.hs:167:29:
08:02:27 <lambdabot>      Couldn't match expected type `[a0]' with actual type `(t0...
08:03:18 <magnap> @let pairAt _ [] = (,); pairAt 1 [x:y:rest] = (x,y); pairAt n [x:xs] = pairAt (n-1) xs
08:03:19 <lambdabot>  .L.hs:167:29:
08:03:19 <lambdabot>      Couldn't match expected type `a0 -> b0 -> (a0, b0)'
08:03:19 <lambdabot>      ...
08:03:48 <Kron> magnap, just skip the first match case entirely I think
08:03:53 <Kron> or you'll have to do
08:04:02 <Kron> pairAt _ [] = error "This should never have happened."
08:04:24 <Kron> rather than using null values or failure defaults, just throw errors; they will always typecheck
08:04:46 <mcstar> the only better message is:
08:04:49 <Kron> (mind you, throwing errors is generally bad style so try to avoid making code that even needs any I think)
08:04:50 <mcstar> > error "error"
08:04:51 <lambdabot>   *Exception: error
08:05:06 <Kron> > error "::noitpecxE"
08:05:07 <lambdabot>   *Exception: ::noitpecxE
08:05:28 <Kron> palindromic errors is best errors
08:06:13 <mcstar> > error ":noitpecxE*"
08:06:14 <lambdabot>   *Exception: :noitpecxE*
08:06:19 <mcstar> sry, i had to fix it
08:06:25 <Kron> thank you
08:06:32 <Kron> I wanted to myself but it felt too channel spammy
08:09:17 <Tekmo> Yeah, you should never use `error`.  It's better to use `Maybe` or `Either`
08:09:43 <Kron> I use errors in programs similar to the one magnap was making
08:09:45 <jjauhien> Hi, folks. Maybe you could find with the following problem (some workaround is pretty fine). I need automatic loading BibTex record from Google Scholar. As for now I could download search results page (e.g. like this one: http://bit.ly/1ddg1re). On the page to get a BibTex record the one should click on "Cite" link (which is JavaScript, as I understand) and then click on the link "Import to BibTex. So my problem is to do this "click o
08:09:45 <jjauhien> n JavaScript link" in Haskell. Any suggestion, please?
08:09:55 <Kron> pattern match cases which should literally never ever happen
08:10:04 <Kron> I want it to error because I want it to fail in an extremely visible and violent fashion
08:10:20 <Tekmo> Kron: You can do that with `Either`, too
08:10:24 <mcstar> 'error' doesnt provide source line number, i think, but pattern match failure does
08:10:53 <mcstar> maybe with the CPP extension, error "__LINE__: blah" could work?
08:10:54 <Tekmo> The reason I like to advocate `Either` over `error` is that learning to use `Either` teaches you a lot more about the langugae
08:10:56 <Kron> Agreed, but I find my own error messages easier to understand since I generally add context data
08:11:07 <Kron> "Error: trying to read too shallowly into the quadtree" etc.
08:11:17 <klrr_> i dont understand, sdl1.2 simply does no work at all as intended
08:11:29 <Kron> Tekmo: that is a really good point
08:11:39 <magnap> @let pairAt _ [] = error "Can't take something from an empty list"; pairAt 1 [x:y:rest] = (x,y); pairAt n [x:xs] = if n > 0 then pairAt (n-1) xs else error "I refuse to believe in the existence of negative indexes"
08:11:39 <lambdabot>  .L.hs:169:34:
08:11:40 <lambdabot>      Occurs check: cannot construct the infinite type: t0 = [t...
08:11:41 <Kron> I'm extremely unused to using Either, I only have experience with Maybe
08:11:56 <mauke> mcstar: http://hackage.haskell.org/package/pseudomacros-0.0.1/docs/PseudoMacros.html
08:12:12 <Tekmo> There is one good use of error, which is high-performance code where you want to skip error checks
08:12:13 <mcstar> magnap: you can converse with lambdabot privately, if you wish
08:12:24 <Tekmo> i.e. something like `(!)` from the `vector` package
08:12:39 <magnap> mcstar: I am extremely unused to IRC, how would I do so?
08:12:40 <mcstar> mauke: ty
08:12:46 <mcstar>  /query lambdabot
08:12:47 <Kron> ah, "/query lambdabot"
08:12:51 <bennofs> Tekmo: how does error allow you to skip error checks?
08:12:53 <Kron> it will put you in a private conversation with the person
08:12:57 <Tekmo> Sorry, I misspoke
08:13:04 <Tekmo> I mean, skip `Left` checks
08:13:09 <magnap> Got it, thanks!
08:13:32 <Kron> magnap: do you not have a haskell interpreter at all?
08:14:11 <magnap> I do, but I was just constructing pairAt for the sake of demonstrating fibMemo
08:14:45 <Tekmo> Oops
08:14:51 <Tekmo> I have no idea how IRC works sometimes
08:14:58 <ion> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs); fib = (fibs !!) in fib 1000  -- magnap
08:14:59 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
08:15:46 <henk> I need a bit of advice on how to write clean and sensible code. In http://lpaste.net/96749 I have a list of 'Maybe DateTime' values (line 34) and I’m not sure how to handle them properly in the following code. Is using 'fromJust' as I do ok? Should I do that at some other point in my code? Or is there a more elegant way? (I’m open for other (style) advice as well, if anyone wants to comment (: )
08:15:53 <klrr_> how do i choose which version of a library to use when i run runhaskell?
08:16:15 <Tekmo> klrr_: Usually it selects based on your currently installed package database
08:16:23 <Kron> henk, you could always pattern match
08:16:35 <Kron> it's something I do a lot to make readable Maybe code
08:16:57 <{[^-^]}> henk: fromMaybe
08:17:03 <Tekmo> klrr_: However, I think you can use `cabal sandbox` to temporarily install a local database with the desired package and then use it to run things with that local database
08:17:16 <Tekmo> Kron: I agree.  I prefer pattern matching over `maybe`
08:17:22 <Kron> I generally do this:
08:17:46 <Kron> case thingy of Just x -> ......... | Nothing -> ........
08:17:47 <yitz> @type mapMaybe --henk
08:17:49 <lambdabot> (a -> Maybe b) -> [a] -> [b]
08:17:50 <Kron> it's just... more instantly readable
08:17:56 <Kron> you look at it and it jumps out at you
08:18:14 * mauke jumps out at Kron
08:18:15 <Kron> the "maybe" function reads to me like it constructs maybes, not destructures them. Though that may just be me.
08:18:25 <Tekmo> henk: I like to do this for simple scripts
08:18:36 <klrr_> Tekmo: heard about sandboxes, i manage to choose specific library version in cabal file for the project, unfourtunaly current SDL does no work as documented, which is sad :/ it was not the version that was wrong
08:18:37 <Tekmo> I'll use your logfile_lines_split as an example
08:18:58 <mcstar> does not work in what way?
08:19:15 <Tekmo> henk: case logfile_lines_split of [line0, line1] -> {- core program logic -}; _ -> return ()
08:19:41 <Tekmo> henk: That basically says "If there were two lines, then do everything as normal, otherwise abort with a simple `return ()`
08:19:45 <magnap> ion: I get that now, infinite recursive zip!
08:19:53 <Tekmo> henk: It even binds the line names to `line0` and `line1` for free
08:20:12 <Kron> I need to learn lenses
08:20:22 <Tekmo> I can help you
08:20:25 <Tekmo> What do you need to know?
08:20:37 <Tekmo> Also, I know `bennofs` knows a ton about lenses ,too
08:20:41 <yitz> Kron: i use maybe *all* the time. or fromMaybe, or mapMaybe, or maybeToList. using pattern matching just isn't necessary for Maybe. in my opinion, it makes code much choppier and harder to read.
08:20:43 <Kron> well, at the moment, basically everything. I'm currently planning on reading this: http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
08:20:51 <yitz> Kron: just a matter of personal style i guess.
08:20:54 <Kron> yitz, it is ultimately a stylistic choice
08:21:05 <Kron> I'll never fault someone for using it, especially in a function composition
08:21:13 <Kron> where it can be very clean in comparison to alternatives
08:21:16 <Tekmo> Well, I'm currently writing up another lens article which shows how to use them in a pure situation
08:21:22 <Tekmo> Kron: Here's a very simple example
08:21:45 <Kron> Tekmo: I guess something that is making things difficult for me is that there seems so MUCH of it, I have no idea what minimal subset I should start with and focus on
08:22:02 <henk> {[^-^]}, Kron, yitz, Tekmo: Wow, thanks for your answers (: I’ll try to follow the discussion I caused now and look at your suggestions, but will probably be back with followup questions soon (;
08:22:10 <Tekmo> Kron: You should begin by studying the `lens-family-core` package
08:22:22 <Tekmo> Kron: It's a smaller subset of lens with simpler types and less generality
08:22:31 <Kron> gotcha
08:22:39 <Kron> I want to make a quadtree library for my gf
08:22:42 <Kron> and I do want to make it lensable
08:22:50 <Kron> is there a sort of minimum subset of operations I should define
08:22:51 <Tekmo> However, there is one article you should read which was the predecessor to all of this which I find really helpful
08:22:55 <Tekmo> Let me find it
08:22:57 <Kron> that let the rest of the lens framework fractally expand out of?
08:23:05 <Kron> thanks tekmo
08:23:08 <Kron> good luck henk
08:23:40 <mcstar> gf: thats the most romantic thing anyone has ever done for me!
08:24:01 <Tekmo> Kron: Read this: http://twanvl.nl/blog/haskell/cps-functional-references
08:24:53 <yitz> Kron: if i made a quadree library for my wife she would probably never speak to me again
08:25:21 <Kron> my gf probably WOULD find it romantic
08:25:27 <mcstar> yitz: forgot, lensable!
08:25:33 <Kron> once she wrote me a fractal heart graphic in sdl using common lisp
08:25:36 <Kron> for valentine's day
08:25:47 <mcstar> now im envious...
08:25:58 <yitz> mcstar: lensable. indeed.
08:25:58 <Kron> in return I hastily sketched out a mathematical function for generating a pretty heart on a graph
08:26:03 <Kron> but mostly I stick to buying her video games :P
08:26:23 <Kron> so yeah I want a library christmas gift cause I know she wants to make a roguelike in haskell
08:26:29 <Kron> and I want to help her start
08:29:38 <Kron> hmmm
08:29:47 <Kron> question, is there any default operator that does this:
08:29:54 <Kron> (.:) f g x y = f (g x y)
08:30:00 <henk> hm, AFAICT I’m actually best off with something very similar to what I’m doing now … mapMaybe is not good, because the result needs to be of the same length as the input list. fromMaybe sounds good but ATM I have no idea what value to provide as a sensible default. Best is if the program fails, as fromJust does, should there be a 'Nothing' in the list. It can’t do anything sensible in that case
08:30:02 <henk> anyway …
08:30:02 <Kron> so you can do stuff like pairAt = take 2 .: drop
08:30:25 <Tekmo> Kron: No such default operator
08:30:29 <Kron> gotcha
08:30:36 <Kron> time to start making my own toolbox library I guess
08:30:46 <Kron> is there any way to register your own files with GHC or something?
08:30:46 <Eduard_Munteanu> Kron: sometimes it's written as (f .) . g
08:30:50 <Kron> yeah, I know
08:30:53 <Tekmo> henk: The function you want is `mapM`
08:30:56 <Kron> but that strikes me as unbelievably unreadable
08:30:57 <Tekmo> henk: Or sequence
08:31:01 <Kron> my mind contorts every time I see that
08:31:05 <Tekmo> henk: sequence :: [Maybe a] -> Maybe [a]
08:31:16 <Tekmo> henk: If all the elements are `Just` then the result will be a `Just`
08:31:29 <Tekmo> henk: If at least one element is a `Nothing`, then the result will be `Nothing`
08:31:37 <danilo2> Hello! I've got a strange memory problem. I've got 2 equivalent functions - one works in constant memory and one takes whole RAM. Could somebody help me and tell me why such thing is happening?: http://lpaste.net/548519683645505536
08:32:03 <brrrrian> I am trying to write a parser with attoparsec, and I would like to know if there is any way to do "take n" with a parser e.g. "take n parser" so it would return a list of the parser run n times...  Kind of like "listOfParsedElems <- take n (repeat elemParser)" ??? But I don't fully understand why that doesn't work..
08:32:40 <Tekmo> brrrrian: `replicateM` from `Control.Monad`
08:32:59 <Tekmo> :t replicateM
08:33:00 <lambdabot> Monad m => Int -> m a -> m [a]
08:33:08 <Tekmo> Replace `m` with `Parser` and you get:
08:33:16 <Tekmo> replicateM :: Int -> Parser a -> Parser [a]
08:33:41 <brrrrian> Tekmo: perfect, I think that's what I need
08:33:41 <mcstar> > let pairAt n = take 2 . drop n -- whats wrong with this?
08:33:42 <lambdabot>   not an expression: `let pairAt n = take 2 . drop n -- whats wrong with this?'
08:34:16 <Twey> It's not an expression
08:34:22 <Twey> And doesn't return a pair
08:34:35 <mcstar> what?
08:34:39 <mcstar> irrelevant
08:34:54 <{[^-^]}> henk:
08:34:55 <mcstar> Kron: ^ i dont think you need .: for that
08:35:03 <{[^-^]}> > fromMaybe (error "Don't know what to do with data!") Nothing
08:35:04 <lambdabot>   *Exception: Don't know what to do with data!
08:35:07 <Twey> mcstar: Which issue were you talking about, then?
08:35:19 <Kron> yeah that works just fine
08:35:25 <mcstar> ok then :)
08:35:27 <Kron> but I was considering a complete pointfree style
08:35:29 <mcstar> Twey: solved
08:35:31 <Twey> > let pairAt n = (head &&& head . head) . drop n in pairAt 2 [1, 2, 3, 4]
08:35:32 <lambdabot>   No instance for (GHC.Show.Show c0)
08:35:33 <lambdabot>    arising from a use of `M2574773203494...
08:35:40 <Kron> in retrospect, probably a bad thing to even try
08:35:43 <Twey> Oops
08:35:48 <Twey> > let pairAt n = (head &&& head . tail) . drop n in pairAt 2 [1, 2, 3, 4]
08:35:49 <lambdabot>   (3,4)
08:35:58 <Kron> Haskell has this... amazingly terrible nature... where it makes you want to write 'clever' code
08:36:04 <Twey> > let pairAt = fmap (head &&& head . tail) . drop in pairAt 2 [1, 2, 3, 4]
08:36:05 <lambdabot>   (3,4)
08:36:09 <Kron> you need to beat back the impulse to right combinatorial code golf
08:36:13 <Kron> whenever you write anything
08:36:29 <mauke> Kron: hah. that's not unique to haskell
08:36:36 <Twey> Kron: There's code that's both ‘clever’ and clean
08:36:41 <Kron> I generally compromise with my own well defined combinators like (.:) and stuff for when I get the urge for brevity
08:36:44 <Kron> agreed
08:36:51 <HectorAE> You can write unclear code in any language
08:36:57 <Twey> You just get a well-honed sense of where to stop :þ
08:37:04 <Kron> true
08:37:08 <Kron> but I remember writing
08:37:14 <Kron> (.:) f g = (f .) . g
08:37:15 <HectorAE> I wonder if there's an Obfuscated Haskell contest
08:37:24 <Kron> and I had to physically force myself to write (.:) fg x y = f (g x y)
08:37:26 <mauke> HectorAE: there is (or was)
08:37:29 <Kron> my future self will like me more ;_;
08:37:32 <mcstar> sometimes #haskell is eaxactly that
08:37:36 <Twey> Kron: The former is fine
08:37:38 <mauke> Kron: do you even lift, bro
08:37:44 <Twey> Heh
08:37:46 <mauke> Kron: (.:) = (.) (.) (.)
08:37:49 <Kron> lol
08:37:52 <Kron> yeah i've seen that
08:37:53 <Tekmo> Psssh
08:37:54 <Kron> the tits operator
08:37:56 <Tekmo> fmap fmap fmap
08:37:58 <Kron> orwhatever it's called
08:38:01 <Twey> I'd write (.:) = (.) . (.) or (.:) = fmap fmap fmap
08:38:03 <Kron> (.:) = (.).(.)
08:38:15 <Kron> let fap = fmap
08:38:18 <Kron> (.:) = fap fap fap
08:38:20 <mcstar> not my size, (. ) ( .) is better
08:38:24 <Kron> lol
08:38:41 <Tekmo> danilo2: I assume that `srcPkgMap` is large?
08:38:44 <HectorAE> Then there's the dick operator
08:38:52 <HectorAE> =>
08:38:59 <mauke> my dick doesn't look like that
08:39:01 <Kron> that is hardly a penis
08:39:08 <mauke> => looks more like an arrow
08:39:12 <Kron> agreed
08:39:23 <Kron> c==$
08:39:24 <Twey> Kron: The definition of overly ‘clever’ code is stuff that other people (including yourself) won't get.  There's a higher tolerance for that in the Haskell community :þ
08:39:37 * Kron nods
08:39:39 <merijn> Tekmo: Thanks for your answer on bidirectional pipes, I think that that solves me issue. If I understand it right once the Client stops requesting the entire pipeline will produce it's Producer end value which I can then use for the remainder, right?
08:39:43 <Kron> it comes down to who I want to read my code I guess
08:39:49 <danilo2> Tekmo: yes
08:40:00 <danilo2> Tekmo: about 30 000 records
08:40:03 <FireFly> Twey: "see e.g. lens"?
08:40:03 <Kron> but minimal  necessary clarity: I need to be able to read my code when I dump my mental RAM and look at it a month later
08:40:04 <Twey> Kron: If you stick to abstractions that are common (Applicative, Monad, Lens) you'll probably be fine
08:40:06 <Tekmo> danilo2: So the first function streams over the map just once
08:40:09 <Twey> Hehe
08:40:11 <Kron> right
08:40:23 <Tekmo> danilo2: The second one uses it in two different places ,so it can't stream over the map in constant space
08:40:32 <henk> Tekmo: Thanks, but a (list of) Nothing is not usable for the program, so erroring out is probably the best …
08:40:34 <Tekmo> danilo2: It has to save a copy of the entire map for both uses
08:40:51 <Tekmo> henk: No, it odesn't produce a list of nothing
08:40:56 <henk> {[^-^]}: Thanks, did not know, that was possible (:
08:40:57 <Tekmo> henk: It produces a single `Nothing`
08:41:03 <Tekmo> henk: No list at all
08:41:13 <Tekmo> henk: So what you do is something like:
08:41:29 <danilo2> Tekmo: Ok, I was aware of this, but the first funciton takes about 100mb memory and the last about 4 Gb - this is huge difference
08:41:32 <Tekmo> henk: case sequence myList of Just elems -> {- use the elems -}; Nothing -> return ()
08:42:06 <Tekmo> merijn: Not quite.  The way I wrote it the `Server` decides when the handshake is done
08:42:32 <Tekmo> merijn: If you want to do it the other way around then the `Client` has to return the `Producer ByteString`, not the `Server`
08:42:57 <Tekmo> danilo2: Then it might be because there is a space leak
08:43:16 <Tekmo> danilo2: Are you using Data.Map or Data.Map.Lazy?
08:43:24 <danilo2> Tekmo: Data.Map.Lazy
08:43:39 <Tekmo> danilo2: Try `Data.Map.Strict` and see what happens
08:43:54 <danilo2> Tekmo: ok, brb
08:44:01 <Kron> hmmmm, if I'm trying to convert a square gridspace that isn't 2^n x 2^n in dimensions
08:44:08 <Kron> like a rectangle or something
08:44:17 <Kron> I'm going to have to deal with non-space in my quadtree
08:44:27 <Kron> I guess I'll have to define some sort of empty value?
08:44:37 <Tekmo> Kron: Just use `Maybe`
08:45:07 <Tekmo> Kron: Or use a quadtree that has up to four children per node instead of exactly three children per node
08:45:15 <Tekmo> *exactly four
08:45:41 <HectorAE> Okay I guess this is as good a time to bring this up as any. Upper bound dependencies. I think I know how to fix them.
08:45:45 <Kron> hmmmm
08:45:48 <merijn> Tekmo: Ah, I wanted the Client to decide when it's done, but it should just forward ByteString from the Server (i.e. in my case the Server needs to do two way communication on a socket and I don't want to leak that into the authentication code, leading to two orthogonal bits needing to know about socket)
08:46:35 <merijn> Tekmo: i.e. the Server just forwards stuff from the Client to the wire until the Client decides it's done, at which point the Server only need to read stuff from the network
08:46:40 <Tekmo> HectorAE: How?
08:46:58 <danilo2> Tekmo: Stragne, Data.Map.Strikt takesall behaves the same way ...
08:47:35 <HectorAE> Mark certain packages semantic versioning compliant so other packages aren't allowed to use an upper bound of them more specific than a MAJOR version.
08:47:59 <merijn> Tekmo: Having the Client return the Producer seems to mean I once again need to tell it about the socket? (Currently only the Server knows how to produce ByteString by reading from the socket, so returning the Producer from there is simple)
08:48:45 <henk> Tekmo: I need to error out anyway in case the input timestrings are not parseable …
08:48:59 <Tekmo> henk: You can do that using `Maybe`, too
08:49:19 <Tekmo> henk: There is a whole world of utilities for `Maybe` and `Either` that do exactly what you want
08:52:00 <danilo2> Tekmo: I've created annotation (http://lpaste.net/548519683645505536) with a working function, which does not take all the memory, but I still does not know where it comes from ...
08:53:12 <Tekmo> merijn: What makes this tricky is that both the `Server` and `Client` have to change their type after the handshake finishes
08:53:55 * hackagebot ADPfusion 0.2.0.4 - Efficient, high-level dynamic programming.  http://hackage.haskell.org/package/ADPfusion-0.2.0.4 (ChristianHoener)
08:54:35 <Kron> can you get lenses with "cabal install lens"?
08:54:36 <Tekmo> merijn: So I think there is a solution that is well-typed, but it's a bit more complex than just pipes
08:54:57 <Tekmo> merijn: I'll give an example
08:55:17 <Tekmo> merijn: The first example will be simple and not use pipes at all just to illustrate the idea
08:55:41 <henk> Tekmo: Yes, I’m using fromMaybe as {[^-^]} suggested now, thank you.
08:55:41 <Tekmo> merijn: Let's say that the handshake involves the transfer of exactly two bytestrings back and forth
08:55:49 <Tekmo> henk: You're welcome!
08:56:10 <Tekmo> merijn: In the case where you statically know the number of back-and-forth exchanges you don't need pipes at all
08:56:29 <Tekmo> merijn: So if there are two exchanges the type of the "server" would be
08:56:53 <Tekmo> theServer :: ByteString -> m (ByteString, ByteString -> m (ByteString, Producer ByteString m r))
08:57:05 <nadirs> hello
08:57:10 <Tekmo> merijn: That will do two exchanges and then begin producing bytes
08:57:18 <Tekmo> merijn: The complementary "client" would be
08:57:28 <HectorAE> Hola nadirs.
08:57:34 <nadirs> a question about GHC preprocessor headers:
08:57:58 <Tekmo> merijn: theClient :: m (ByteString, ByteString -> m (ByteString, ByteString -> m ()))
08:58:12 <Tekmo> merijn: You'd need a custom function to connect the two
08:58:24 <Tekmo> merijn: That would just forward their relative `ByteString`s back and forth
08:58:30 <Eduard_Munteanu> How do you compose Iso'-s?
08:58:47 <nadirs> the flags that I pass to "OPTIONS_GHC" are explained in ghc's manpages or belong to runghc or something else?
08:58:48 <Tekmo> and then after forwarding the last `ByteString` it would take the `Producer` stored at the end of `theServer` and begin using that
08:59:02 <Eduard_Munteanu> :t (Control.Category..) :: AnIso' c b -> AnIso' b a -> AnIso' c a
08:59:03 <lambdabot>     Couldn't match type `b1' with `a1'
08:59:03 <lambdabot>       `b1' is a rigid type variable bound by
08:59:03 <lambdabot>            an expression type signature:
08:59:45 <Eduard_Munteanu> :t (Control.Category..) :: AnIso' b c -> AnIso' a b -> AnIso' a c
08:59:46 <lambdabot>     Couldn't match type `c1' with `b1'
08:59:46 <lambdabot>       `c1' is a rigid type variable bound by
08:59:46 <lambdabot>            an expression type signature:
09:00:25 <geekosaur> nadirs, http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
09:00:41 <merijn> Tekmo: Right
09:00:49 <Kron> score = lens _score (\game v -> game { _score = v })
09:00:53 <nadirs> geekosaur: perfect, thanks!
09:00:54 <Kron> I am having great difficulty parsing this
09:00:58 <Eduard_Munteanu> :t (Control.Category..) :: AnIso b c b c -> AnIso a b a b -> AnIso a c a c
09:00:58 <Kron> what on earth is going on here?
09:00:59 <lambdabot>     Couldn't match type `c1' with `a1'
09:00:59 <lambdabot>       `c1' is a rigid type variable bound by
09:00:59 <lambdabot>            an expression type signature:
09:01:10 <mauke> Kron: it's defining 'score'
09:01:11 <merijn> Kron: Are you familiar with record update syntax?
09:01:14 <Tekmo> merijn: The reason that pipes require that the client and server share the same return value is that pipes lack the static information necessary to know which one will finish first
09:01:15 <Kron> no I am not
09:01:32 <Tekmo> merijn: But if you can encode that static information into the type the way I showed then you can specify which one will finish
09:01:44 <mauke> Kron: 'score' is defined as the result of applying lens to _score and (\game v -> game { _score = v })
09:01:52 <henk> Can I shorten something in lines 30-32 or 37-38 in http://lpaste.net/96749?
09:01:55 <mauke> lens is presumably an imported function
09:01:58 <merijn> Kron: Ah, basicall "foo { x = y }" says "make a copy of the record foo with field x set to y"
09:02:00 <mauke> _score is presumably a record field
09:02:10 <Tekmo> merijn: The only loss is that you can't use pipe operations for the initial handshake part
09:02:29 <Kron> ohhh I see
09:02:38 <merijn> Tekmo: Right, but if the number of exchanges is not static, I'm boned unless I do a more tricky encoding, I guess?
09:02:48 <Kron> wait
09:02:51 <mauke> _score by itself is a getter
09:02:51 <Kron> isn't foo the object itself?
09:03:00 <Tekmo> merijn: What is the exact protocol?
09:03:01 <henk> seems a little too verbose to me …
09:03:02 <mauke> (\game v -> game { _score = v }) is the corresponding setter
09:03:03 <Kron> what exactly IS a record, I thought records were fields
09:03:22 <Kron> ohhh
09:03:22 <mauke> Kron: a record is a tuple where the elements can be accessed by name instead of position
09:03:29 <Kron> score = lens getter setter
09:03:39 <Kron> that makes so much sense now
09:03:51 <merijn> Tekmo: I had a pipes-3 implementation of ZMTP (the ZMQ protocol), but it's really messy, with all sorts of implementation details throughout the entire pipeline
09:03:55 <Kron> mauke: gotcha
09:03:56 * hackagebot jsc 0.1.1.0 - High level interface for webkit-javascriptcore  http://hackage.haskell.org/package/jsc-0.1.1.0 (HamishMackenzie)
09:04:40 <merijn> Tekmo: So I was working on a cleaner version using pipes-4, the problem is that I first have to parse a header (this requires some back and forth over the socket as I parse), then do an authentication handshake, after which it just streams frames
09:05:55 <Tekmo> merijn: Okay, so I think the issue here is actually using a `Server` instead of a nested pipe
09:06:03 <Tekmo> merijn: Another solution that might work is something like htis:
09:06:10 <merijn> Tekmo: I was hoping to avoid having knowledge of the sockets all throughout that initial header/authentication. But the number of messages depends on the authentication mode set by the header, so I don't know in advance how many messages it lasts
09:06:29 <ParahSailin> why is there no shift and rotate machop?
09:06:45 <Tekmo> merijn: yourClient :: Producer ByteString (Pipe ByteString ByteString m) r
09:06:51 <Tekmo> merijn: I'll explain the type
09:07:06 <Tekmo> merijn: The outer `Producer` are the messages you send to the zeroMQ socket
09:07:27 <Tekmo> merijn: The inner `Pipe` reads from the socket and writes to whatever goes downstream
09:07:43 <Tekmo> merijn: So lets say you split the zeroMQ socket as a `Producer` and `Consumer`
09:07:47 <Rarrikins> ParahSailin: For which machine?
09:07:54 <Tekmo> merijn: readSocket :: Producer ByteString m ()
09:08:05 <Tekmo> merijn: writeSocket :: Consumer ByteString m r
09:08:16 <Tekmo> Then you would hook things up like this:
09:08:31 <Tekmo> I'll do it a step at a time like in the e-mail
09:08:58 <Tekmo> yourClient >-> writeSocket :: Effect (Pipe ByteString ByteString m) r
09:09:17 <ParahSailin> Rarrikins: https://github.com/ghc/ghc/blob/master/compiler/cmm/CmmMachOp.hs
09:09:21 <Tekmo> merijn: runEffect (yourClient >-> writeSocket) :: Pipe ByteString ByteString m r
09:09:41 <Tekmo> merijn: readSocket >-> runEffect (yourClient >-> writeSocket) :: Producer ByteString m r
09:10:05 <Tekmo> merijn: That final `Producer` is then what downstream interacts with
09:10:36 <Tekmo> merijn: When writing `yourClient`, basically `yield` is how you would send messages to the socket, `lift await` is how you would read from the socket, and `lift yield` would be how you send things further downstream
09:10:57 <Tekmo> merijn: Actually, maybe a more elegant way, would be the following type:
09:11:01 <Rarrikins> ParahSailin: It has shifts with the Shl and Shr. Not sure about rotate, but I imagine optimizing it later is easy.
09:11:07 <Tekmo> merijn: Pipe ByteString ByteString (Producer ByteString m) r
09:11:15 <ParahSailin> Rarrikins: im at later
09:11:16 <Tekmo> merijn: yourClient :: Pipe ByteString ByteString (Producer ByteString m) r
09:11:26 <Tekmo> merijn: Then all the socket interactions are confined to the outer `Pipe` layer
09:11:33 <Tekmo> merijn: And the run function would basically be
09:11:57 <Tekmo> merijn: runEffect (readSocket >-> yourClient >-> writeSocket) :: Producer ByteString m r
09:12:10 <Tekmo> merijn: Of course, the name `yourClient` is now misleading since it's not a client, but you get the idea
09:12:12 <merijn> Tekmo: Right, so in that example the lifted await receives from readSocket and because of writeSocket produces stuff going to the socket. And once yourClient is done the "lift yield" just forwards its input, right?
09:12:18 <Tekmo> merijn: Right
09:12:43 <Tekmo> merijn: In the latter example I gave, you would use `await` to read from the socket, `yield` to write to the socket, and `lift yield` to forward input
09:13:02 <marx2> is .: defined in some utility library?  what about equivalent for f (g x y z) or (((f.).) . g), is there one?
09:13:13 <yitz> mauke: that's a great definition
09:13:37 <merijn> Right, in which case I could write it as "yourClient >> forever (await >>= lift . yield)", right?
09:13:54 <merijn> Tekmo: Wait, "yourClient" there is a bad name
09:14:12 <Tekmo> merijn: Yeah
09:14:18 <marx2> it would be cool if we had syntactic sugar for this that is more concise than a lambda, something like: (f (g _ _ _))
09:14:20 <merijn> Tekmo: I meant, I can implement the client like that, with 'yourClient' doing it's thing as a Pipe
09:14:23 <Tekmo> merijn: It should really be called "handshake" or something like that
09:14:26 <merijn> yeah
09:14:34 <mauke> marx2: that's syntactically ambiguous
09:14:49 <yitz> @remember mauke a record is a tuple where the elements can be accessed by name instead of position
09:14:49 <lambdabot> It is stored.
09:14:57 <Tekmo> merijn: And yes to your last question: it would be "handshake = authenticate >> forever (await >>= lift . yield)"
09:15:14 <mauke> @quote mauke trees.are
09:15:14 <lambdabot> mauke says: trees are hierarchical
09:15:22 <Tekmo> merijn: You can also simplify that last part to `for cat (lift . yield)`
09:15:37 <merijn> Tekmo: I'm still finding it hard to think about nested pipes, but I think this should get me a bit further
09:15:54 <Tekmo> merijn: Basically, nested pipes let you create branched topologies
09:16:05 <Tekmo> merijn: i.e. reading or writing from more than one thing
09:16:07 <yitz> mauke: trees are things that have a hierarchy of trees under them
09:16:23 <mauke> @quote mauke trees
09:16:23 <lambdabot> mauke says: trees are hierarchical
09:16:24 <mauke> @quote mauke trees
09:16:25 <lambdabot> mauke says: no, haskell doesn't support trees
09:16:25 <nadirs> reizuki: I've sort of done homework 1 of byorgey's course. Couldn't manage to solve exercise 6 though (I wonder if there's a trick in that one)
09:16:44 <Tekmo> merijn: For example, `Consumer a (Consumer b m) r` is something that can `await` a's or b's
09:16:51 <marx2> mauke what makes it syntactically ambiguous?
09:17:02 <mauke> marx2: where would the lambda be inserted?
09:17:11 <merijn> Tekmo: Anyhoo, thanks for the help, I'm going back to the draw^H^H^H^Hcoding board :)
09:17:20 <Tekmo> merijn: You're welcome!  Good luck
09:17:23 <marx2> mauke good point.
09:17:39 <mauke> marx2: that is, is (f (g _ _)) equivalent to (f (g (\x -> x) (\x -> x))) or (f (\x -> g x x)) or \x -> f (g x x)?
09:17:47 <marx2> yeah I got it
09:17:58 <mauke> except that's wrong
09:18:07 <marx2> I did not bother parsing it :)
09:18:10 <mauke> should be (f (\x y -> g x y)) and \x y -> f (g x y)
09:18:30 <yitz> that was starting to look like the y combinator
09:18:35 <marx2> was it F# or some other language that had syntactic sugar like this?
09:18:39 <marx2> scala?
09:18:55 <Tekmo> danilo2: Sorry for the delay.  I'm just trying to wrap my head around the second function's code to make sure that it's doing the same thing as the first function
09:18:58 * hackagebot ghcjs-dom 0.0.1 - DOM library that supports both GHCJS and WebKitGTK  http://hackage.haskell.org/package/ghcjs-dom-0.0.1 (HamishMackenzie)
09:19:22 <danilo2> Tekmo: No problem. Thank you very much, you are thinking about it
09:20:19 <danilo2> Tekmo: Look, the first functions has got srcPkg map and finds all pckages in instPkgMap, that has the same names (keys) as in the first map
09:20:31 <Tekmo> danilo2: Wait, I hvae a question
09:20:49 <Tekmo> danilo2: Why do you combine `keysSet` and `Set.toList` instead of just using the `keys` function from `Data.Map`?
09:21:43 <danilo2> Tekmo: Oh, of course - this is the same - I'm combining them, because exaple 2 is modified example 4 (and there it makes sense)
09:23:15 <danilo2> Tekmo: (Set.toList . Map.keysSet) is equal to (Map.keys). And such operation makes sense If I want to union sets on the beginning (example 4)
09:23:27 <Tekmo> danilo2: Got it
09:23:36 <Tekmo> danilo2: Give me a second more to study the second function
09:23:45 <danilo2> Tekmo: of course :)
09:25:21 <danilo2> Tekmo: by the way, join (***) is just mapping function over both tuple elements
09:25:28 <Tekmo> danilo2: Yeah, I figured that out
09:25:59 <mangaba_leitosa> nadirs: what course is it?
09:26:39 <nadirs> mangaba_leitosa: hello, here's the link → http://www.cis.upenn.edu/~cis194/lectures.html
09:27:12 <Tekmo> danilo2: Okay, so your second function isn't quite doing exactly the same thing
09:27:25 <mangaba_leitosa> nadirs: thanks. is it on-site course or online? :-)
09:27:32 <Tekmo> danilo2: Your first function reuses the value in the original `srcPkgMap` and your second function does a new lookup to get it back again
09:28:19 <danilo2> Tekmo: yes, you are right (but the output of course is the same). I still do not know, why the first takes 100mb and the second 3 Gb of RAM
09:28:20 <Tekmo> danilo2: Basically, where your first function has `x`, the second function has `Map.findWithDefault [] key srcPkgMap`
09:28:36 <stewe> is killThread a safe way to stop some long task?
09:28:36 <Tekmo> Tekmo: So try this out and see if you still get a memory leak
09:28:47 <Tekmo> Tekmo: Give me a second to paste another example to try
09:28:51 <mangaba_leitosa> nadirs: it says Mondays 1:30-3. not online then :_(
09:28:57 <danilo2> Tekmo: ok, thank you
09:29:07 <nadirs> mangaba_leitosa: I think it's on site course. I'm not attending that uni, by the way, the author just made it public, so we're doing those exercises :)
09:29:29 <donri> donri: why are you talking to yourself?
09:29:29 <mangaba_leitosa> nadirs: I see :-)
09:30:25 <danilo2> danilo2: Yeah, I'm also courious about that :D
09:33:39 <Tekmo> danilo2: Try this version: http://lpaste.net/96752
09:33:53 <Tekmo> danilo2: All that does is convert the map to an assoc list, do the map on that, then convert back
09:34:00 * hackagebot ghcjs-codemirror 0.0.0.1 - Installs CodeMirror JavaScript files  http://hackage.haskell.org/package/ghcjs-codemirror-0.0.0.1 (HamishMackenzie)
09:34:11 <Tekmo> danilo2: That will help me figure out if the problem is conversion to lists or if the problem is from doing that second lookup
09:34:18 <danilo2> ok
09:34:22 <danilo2> Tekmo: ok, brb
09:34:32 <stewe> say I have a thread that downloads and scraps web pages. would it be safe to cancel this operation by calling killThread?
09:35:06 <rtpg> as safe as it would be to have only a half downloaded page I guess?
09:35:31 <Tekmo> stewe: Probably
09:35:55 <Tekmo> stewe: If your page scraping operation has exception handling built in to close the socket when killed, then yes
09:37:56 <danilo2> Tekmo: there was missmathced bracked in your code and after I fixed it, the types does not match:  Couldn't match type `t0 -> (t0, [Package])'  with `(String, ([Package], [Package]))'
09:38:25 <stewe> Hopefully it does, i will check. I am using Network.HTTP.Conduit btw
09:39:05 <danilo2> Tekmo: ah, in the lambaa there is tuple, brb I'll fix it
09:39:13 <Tekmo> danilo2: Yeah, that was my mistake
09:39:31 <Tekmo> danilo2: It should have been \(k, x) -> ...
09:39:40 <merijn> stewe: Normally you'd use something like bracket which ensures cleanup code is called
09:39:58 <merijn> stewe: Although I believe conduit has their ResourceT stuff to ensure cleanup
09:40:18 <Tekmo> stewe: Yeah, conduit will clean it up
09:40:33 <danilo2> Tekmo: there was another ereror too, the fixed line looks like this: map (\(k, x) -> (k,(x, Map.findWithDefault [] k instPkgMap)))
09:40:44 <Tekmo> danilo2: Right.  Thanks for cleaning that up
09:40:46 <stewe> cool thanks
09:40:53 <Tekmo> stewe: You're welcome
09:41:24 <danilo2> Tekmo: No problem - I want to thank you, you're helping me :) So youtr code works in constant memory (not eating everything)
09:41:56 <Tekmo> danilo2: Okay, let me test another variation
09:42:31 <danilo2> Tenmo: I do not know if you have seen my adnotation (http://lpaste.net/548519683645505536) - there is working verison of what I'm trying to do, which does not eats whole memory (thi still does not answers question why there is this memory leak though)
09:43:51 <Tekmo> danilo2: Yeah, I saw it, but it wasn't sufficiently different from the original for me to figure out the cause of the problem
09:44:45 <stewe> Tekmo out of curiosity where does it say that? I am reading this and I cant find it. I also cant find any finally or catch keywords in the source. http://hackage.haskell.org/package/http-conduit-1.2.4/docs/Network-HTTP-Conduit.html
09:45:11 <Tekmo> danilo2: Try this: http://lpaste.net/96752
09:45:26 <Tekmo> danilo2: This is to test if the leak is due to splitting the keys and values
09:45:37 <danilo2> Tekmo: ok, brb
09:45:37 <henk> Is there an easy and obvious way for making my own datatype work with printf? Everything I can find seems so convoluted and blown … I know I need an instance like "instance Text.Printf.PrintfArg HMSTime where", is that correct?
09:45:47 <Tekmo> stewe: It's from `resourcet`
09:45:54 <Tekmo> stewe: That's what does all the resource management
09:46:04 <Tekmo> stewe: It will show in the types as `ResourceT` or `MonadResource`
09:46:22 <stewe> ah ok, thanks again :)
09:46:28 <Tekmo> stewe: You're welcome! :)
09:47:40 <danilo2> Tekmo: works ok
09:48:09 <Tekmo> danilo2: Then the problem seems to be due to the fact that you are doing that extra lookup
09:49:04 <Tekmo> danilo2: Let me try another example
09:49:28 <danilo2> Tekmo: hmm, very interesting. I have to investigate it further (because Im cutious what makes it so memory hngry then). Thank you very much for your help and examples!
09:49:31 <danilo2> Tekmo: ok :)
09:50:01 <Tekmo> danilo2: Also, just so you know there is a way to profile heap usage that can sometimes be more direct
09:50:33 <danilo2> Tekmo: I've heard about it but never used it. I think this would be the best way to see whats happening there
09:50:33 <Tekmo> danilo2: If you compile your program with `-rtsopts` then you can profile heap usage and see what is taking up all the space
09:51:00 <Tekmo> danilo2: Then once you compile it with that option, you run your program with `./myProg +RTS -h`
09:51:33 <Tekmo> danilo2: That generates a `myProg.hp` file (or some other extension, maybe, I forget which)
09:51:40 <maikklein> stupid question but cabal allows only one version of a library to be installed right? Is there some way that I can say "install haskell-src-exts1.11 and install haskell-src-exts1.14"? And then let the cabal file decide which version it should take?
09:51:54 <Tekmo> danilo2: Then you can convert that to a colo image using `hp2ps -c myProg.hp`
09:52:17 <danilo2> Tekmo: thanks! I'll do it (not now, because I've got some urgent tasks and I thin such investigation would take long time) but I'll test it and I'll write you back what are the results :)
09:52:23 <Tekmo> maikklein: Actually, you can install multiple versions of a library
09:52:33 <Tekmo> maikklein: But it will only select one for any given compiled program
09:52:44 <Tekmo> danilo2: Alright.  Good luck
09:53:00 <danilo2> Tekmo: Cool infomrations! Hmm seems it would be straightforward to test it. Anyway I have to do it :) Thank you once again! :)
09:53:12 <Tekmo> danilo2: You're welcome! :)
09:53:51 <fizruk> maikklein, cabal install haskell-src-exts-1.11 should install version 1.11 of haskell-src-exts
09:54:03 * hackagebot swish 0.9.0.9 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.0.9 (DouglasBurke)
09:54:06 <maikklein> Tekmo, fizruk oh, thank you guys
09:54:46 <Tekmo> maikklein: You're welcome
10:00:51 <dirk103> heyo
10:01:24 <dirk103> what is the type [t0] ?
10:01:32 <dirk103> " Couldn't match expected type `Float' with actual type `[t0]' "
10:01:35 <Iceland_jack> dirk103: A list of any type
10:01:49 <Iceland_jack> > [] :: [t0]
10:01:50 <lambdabot>   []
10:01:51 <Iceland_jack> > [] :: [a]
10:01:52 <lambdabot>   []
10:02:19 <Iceland_jack> > (pi :: Float) == ([] :: [t0])
10:02:20 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
10:02:20 <lambdabot>              with actual typ...
10:04:00 <ion> Huh, show ([] :: [a]) works, even though a is not an instance of Show? What’s going on here?
10:04:42 <scott_> Perhaps it defaults to [()] for that?
10:04:50 <Cale> [a] is the inferred type of [] anyway
10:04:51 <ion> > show (undefined :: a)
10:04:52 <lambdabot>   "*Exception: Prelude.undefined
10:04:59 <Cale> So writing that type signature has no effect
10:05:06 <Cale> Defaulting happens
10:05:10 <ion> > fmap id (undefined :: a)
10:05:11 <lambdabot>   No instance for (GHC.Show.Show (f0 b0))
10:05:11 <lambdabot>    arising from a use of `M57485789...
10:05:35 <Cale> Defaulting in GHCi (or with ExtendedDefaultRules turned on) is more aggressive, and will default some things to ()
10:05:40 <dirk103> http://pastebin.com/D4a0BDVS
10:05:41 <mauke> The paste D4a0BDVS has been copied to http://lpaste.net/96754
10:05:47 <dirk103> i suppose i'm doing this completely wrong then?
10:06:10 <ion> Oh, i didn’t realize defaulting will apply with “:: a”.
10:06:24 <Kron> I wish functions had a default print value, like in ocaml
10:06:37 <Kron> I'd love to just do soem random combinator stuff on the ghci terminal and not have it explode
10:06:51 <monochrom> writing "[] :: [a]" does not force polymorphism. it is still subject to default and to monomorphism restriction
10:07:12 <Cale> dirk103: The type you've specified for listMotorFeederSize has it resulting in a Float, but your code clearly produces a list.
10:07:17 <FreeFull> I wish monomorphism restriction was disabled by default
10:07:20 <henk> "zipWith (\y x -> foofunc (barfunc y x)) list1 list2" Is there a sane way for shortening this function?
10:07:20 <monochrom> for example "b = 5 :: Num a => a" still gives you a monomorphic b
10:07:42 <ion> aye
10:08:10 <dirk103> ohh
10:08:35 <geekosaur> @pl \y x -> foofunc (barfunc y x)
10:08:35 <lambdabot> (foofunc .) . barfunc
10:08:41 <Cale> henk: Well, you could write (foofunc .) . barfunc instead of the lambda, and that's shorter, but I'm not sure it's as sane :)
10:09:31 <Kron> dirk103: I see your bug
10:09:33 <ion> Anyone who uses “(foo .) . bar” should be excommunicated from the community.
10:09:36 <Kron> listMotorFeederSize :: Int -> Float -> Int -> Float
10:09:40 <Kron> it's trying to output a Float
10:09:45 <Kron> but you're outputting a list
10:09:50 <dirk103> i want a float though :(
10:09:53 <Kron> [ ... | ....... ] generates a list via list comprehension
10:09:56 <Cale> If you're defining a function like  f list1 list2 = someExpression list1 list2, you can cancel the lists from both sides of the equation
10:09:57 <Kron> what do you want to do with the list?
10:09:59 <donri> i like fmap f . g
10:10:02 <Kron> multiply the elements together?
10:10:04 <Kron> add them together?
10:10:42 <Kron> hold up
10:10:53 <Kron> "snd (motors !! motorType) !! ocType" isn't this just a single element?
10:10:59 <Kron> this is just a single number isn't it?
10:11:12 <Cale> yes
10:11:22 <dirk103> i want it to return    motors[motortype][octype] * fullLoadCurrent
10:11:26 <Cale> So, he's going to have another type error once that's done
10:11:28 <Kron> dirk103: you're using a list comprehension when you shouldn't
10:11:46 <Kron> you want to do this:
10:11:46 <Cale> (motors !! motorType !! ocType) * fullLoadCurrent
10:11:54 <dirk103> cool
10:12:01 <Kron> yup, that
10:12:20 <dirk103> this is teaching my self to program over again
10:12:32 <Kron> gotcha
10:12:33 <dirk103> i like how i'm trying to force C++ thinking on it
10:12:46 <Kron> I was going to mention that :P
10:12:51 <dirk103> not that i'd want to, but could i get what i was trying to work?
10:12:52 <Kron> you're trying to create a sort of fake arra
10:12:54 <Kron> *array
10:12:55 <Cale> Well, yeah. You should usually do everything in your power to avoid !!
10:13:00 <Kron> right
10:13:26 <Cale> If you're using !! then you probably want a Map or an IntMap or something.
10:13:42 <Kron> but association lists are a nice place for a new programmer to start I think
10:14:07 <Kron> dirk103: do you know of function composition?
10:14:14 <dirk103> i like how i'm trying to force C++ thinking on it
10:14:18 <Cale> But also, new programmers will use !! in places where they want a list sometimes, but the !! is avoidable (it isn't here though)
10:14:24 <dirk103> no. but i'll read about it
10:14:28 <henk> ion: lol, why?
10:14:40 <henk> geekosaur: thanks
10:14:40 <Kron> basically, you can chain functions together
10:14:42 <Kron> if you want to go
10:14:49 <Cale> For example, if you're computing xs !! n for each n from 0 to k or something, then you're doing it wrong! :)
10:14:57 <Kron> x = (foo (bar (baz y)))
10:15:13 <Kron> you can say x = (foo . bar . baz) y
10:15:23 <Kron> you can build new functions out of other ones
10:15:26 <henk> Cale: Well, at the moment not really, as I don’t understand it, but yeah, it’s short (:
10:15:41 <klrr_> is there any good 2d drawing libraries for haskell besides threepenny-gui and gloss?
10:15:53 <Cale> klrr_: diagrams
10:15:54 <ion> henk: It only makes the code less readable for pointlessness’ sake.
10:16:05 <klrr_> Cale: thanks, will look it up
10:16:07 <Cale> dirk103: xs !! n takes O(n) time to compute
10:16:16 <henk> ion: ok thanks (:
10:16:27 <Cale> dirk103: (and it can error out if your index is out of bounds)
10:17:36 <dirk103> Cale: ohhh
10:17:47 <Cale> It is somewhat analogous to taking a loop and putting an if expression inside it which makes the loop body only happen if the counter is a specific value (and then break out), so it's pretty unnatural.
10:18:02 <Kron> dirk103: a "Map" in haskell (note the capitalization becauset he lowercase variant is very different) is a kind of hash table, ish. You can treat it as one.
10:18:14 <dirk103> I was reading that putting items on the begining of a list is instant whereas putting it on the end is O(n) is that correct?
10:18:14 <Cale> Only it doesn't use hashing
10:18:16 <Kron> that's why Cale mentioned it earlier; you can put things in a Map with keys and access them via keys
10:18:20 <Cale> So it's better than a hashtable ;)
10:18:24 <Kron> yeah it's not really a hash table
10:18:35 <Cale> dirk103: yes, that's correct
10:18:37 <Kron> but it's mentally model-able as a hash table
10:18:40 <ion> If you’re applying (!!) to a non-infinite list, you’re certainly doing the wrong thing.
10:18:41 <Kron> it's how I learned to use maps
10:18:44 <geekosaur> dirk103, yes, a haskell list is a simple linked list
10:19:02 <Kron> dirk103: if you have experience with C programming, think of it as a big chain of pointers
10:19:03 <Cale> fsvo of "simple" which includes "may be infinite"
10:19:11 <dirk103> yeah a linked list
10:19:11 <Kron> a list is a whole bunch of elements that point to the next item in the list
10:19:16 <Kron> yes, a linked list!
10:19:28 <mauke> a list is a node that points to another list
10:19:38 <dirk103> for my source code there i need !! though to access my custom list motors at the top eh?
10:19:52 <Kron> however: haskell lists are not actually linked lists when compiled and implemented and everything (I think), or at least not necessarily. They're not quite meant to be treated as literal lists like lisp so keep that in mind.
10:19:53 <dirk103> is there a different way i could format my data that would be better?
10:20:05 <chrisdone> Kron: “deletes your emacs configuration” was a joke. hahaha
10:20:09 <mauke> Kron: haskell lists are actually linked lists
10:20:11 <Kron> chrisdone: oh, lol
10:20:19 <dirk103> i kind of want to look at the GHC source, is it written in haskell or C?
10:20:23 <Kron> mauke: gotcha
10:20:26 <mauke> dirk103: haskell
10:20:26 <Cale> Why don't we be precise? A list of type [a] is either the empty list [] or it is an expression of the form (x:xs) where x is an element of type a and xs is another list.
10:20:29 <Kron> it's actually written in haskell
10:20:47 <Cale> There's a little bit of C in the runtime system
10:20:48 <dirk103> that would be a very large undertaking in C
10:20:51 <Kron> it's written in itself, since recursion is its own reward
10:21:08 <Cale> It really is, in the case of a compiler
10:21:17 <chrisdone> a little bit? c'mon, it's loads =p
10:21:23 <monochrom> people don't like precise. people like analogies. analogies are like drugs.
10:21:25 <Cale> Because improvements to your compiler result in improvements to the compiler's performance.
10:21:38 <darthdeus> how can i easily convert [Just a] -> Just [a] ?
10:21:42 <Kron> something something the singularity!
10:21:50 <simpson> :t catMaybes -- darthdeus
10:21:51 <mauke> darthdeus: why the Just in the result?
10:21:52 <Kron> darthdeus: sequence
10:21:52 <lambdabot> [Maybe a] -> [a]
10:21:56 <ion> darthdeus: [Maybe a] -> Maybe [a]? traverse
10:22:09 <Cale> > sequence [Just 5]
10:22:09 <darthdeus> yeah maybe :) but i thought more in general
10:22:10 <lambdabot>   Just [5]
10:22:12 <ion> Oh, wait. What Korn said.
10:22:18 <ion> Oh, wait. Kron. :-P
10:22:20 <Kron> sequence is probably your best bet
10:22:24 <Kron> and yes, it's Kron :P
10:22:28 <Cale> > sequence [Just 5, Nothing]
10:22:29 <lambdabot>   Nothing
10:22:35 <Kron> god there was this horrible time in like the 2005s
10:22:35 <Cale> > sequence [Just 5, Just 7]
10:22:36 <darthdeus> if i have Monad1 and Monad2, is there a generic way of doing Monad1 (Monad2 a) -> Monad2 (Monad1 a) ?
10:22:36 <lambdabot>   Just [5,7]
10:22:40 <simpson> > catMaybes [Just 2, Nothing, Just 3, Nothing, Just 4]
10:22:41 <lambdabot>   [2,3,4]
10:22:47 <Kron> where everyone assumed that I was a Korn fan and I'd misspelled my name
10:22:49 <simpson> darthdeus: Nope.
10:22:50 <Cale> darthdeus: no
10:22:59 <Cale> darthdeus: (Not even in theory)
10:23:00 <ion> kron: (I actually didn’t misread, i only mistyped.)
10:23:09 <Kron> indeed, I figured as much
10:23:17 <darthdeus> hmm
10:23:38 <Kron> cayMaybes and sequence do different things
10:23:48 <darthdeus> and [Monad a] -> Monad [a] ?
10:23:55 <Kron> one fails your whole list if you see a single Nothing, the other just only returns Justs
10:23:59 <Cale> However, if for some specific pair of monads S and T, you have a function S (T a) -> T (S a) satisfying a couple of additional laws, you can turn the composite T . S into a monad.
10:24:04 <mauke> :t sequence
10:24:04 <Kron> darthdeus: sequence exists for all monads
10:24:05 <lambdabot> Monad m => [m a] -> m [a]
10:24:43 <darthdeus> hmm
10:24:46 <dirk103> ahrg this haskell is super cool and i want to make things in it but i dont know what i'm doing
10:24:50 <darthdeus> i must be oding this worng
10:24:55 <Kron> dirk103: start small!
10:25:01 <Kron> are you reading Learn You A Haskell?
10:25:04 <dirk103> yes
10:25:10 <Kron> http://learnyouahaskell.com/functionally-solving-problems
10:25:15 <Cale> Also, ask more questions :)
10:25:17 <Kron> there's a chapter called Functionally Solving Problems
10:25:23 <Kron> which is purely about just putting stuff into practice
10:25:31 <Kron> and carefully going over the mentality of writing functional code
10:25:37 <Kron> and functionally doing things
10:25:59 <brrrrian> If I have a list of data types [ elem1, elem2 ...] and inside each elem is a bytestring... how do I create a bytestring that is the concatenation of all the elem bytestrings..?
10:26:02 <Kron> I also found this: http://www.joelonsoftware.com/items/2006/08/01.html really informative
10:26:19 <Cale> brrrrian: Do you really mean a list of *types*?
10:26:25 <Kron> it's what gave me the important idea of separating concerns and separating your control flow and structure searches and stuff from the things you want to do on them
10:26:34 <Iceland_jack> @hoogle [ByteString] -> ByteString
10:26:34 <lambdabot> Data.ByteString concat :: [ByteString] -> ByteString
10:26:34 <lambdabot> Data.ByteString.Char8 concat :: [ByteString] -> ByteString
10:26:34 <lambdabot> Data.ByteString.Lazy concat :: [ByteString] -> ByteString
10:26:40 <Iceland_jack> brrrrian: ↑
10:26:54 <Cale> brrrrian: Or do you mean a list of values of some specific type?
10:27:01 <brrrrian> Cale: I mean a data record
10:27:15 <Kron> first you'll have to extract the data from the record
10:27:17 <Iceland_jack> brrrrian: First run a function which extracts the ByteString
10:27:23 <Kron> map fieldname listofthings
10:27:33 <brrrrian> data Record = Record { field 1, field 2 :: ByteString }  ... how to concat list of Record field 2?
10:27:34 <Kron> that will give you a (lazy) list of all the bytestrings
10:27:43 <Cale> brrrrian: BS.concat . map field2
10:27:47 <Kron> concat (map field2 list)
10:28:01 <Kron> so yes
10:28:11 <Kron> concatenatedBytestring list = concat (map field2 list)
10:28:23 <Kron> concatenatedBytestring list = (concat . map field2) list
10:28:29 <Kron> concatenatedBytestring = concat . map field2
10:28:29 <brrrrian> I see
10:28:46 <brrrrian> you just apply 'field2' to all of the elements to get the bytestring.. and then concat them all together?
10:28:50 <joneshf-laptop> is there a bit more indepth description of the hierarchy structure than this: http://www.haskell.org/haskellwiki/Hierarchical_module_names
10:28:51 <mauke> concatenatedBytestring = (fmap concat) (fmap field2)
10:28:52 <joneshf-laptop> ?
10:28:53 <Kron> yes, kind of
10:28:53 <Iceland_jack> brrrrian: Yes
10:29:08 <Kron> the subtle difference is that it's not actually generating a full list of bytestrings before concatenating them
10:29:10 <Cale> Well, you're probably going to want to explicitly give a module path for concat
10:29:15 <Cale> concat is also the name of a Prelude function
10:29:25 <Kron> it is actually traversing the list, and for each element it finds the bytestring and then concatenates it
10:29:26 <Cale> So unless you imported the Prelude hiding a bunch of stuff
10:29:29 <Kron> like (map fieldname) is a generator
10:29:34 <Kron> so it's quite efficient
10:29:35 <Cale> You probably imported ByteString qualified
10:29:38 <Kron> only one O(n) traversal
10:30:35 <Cale> If f and g are both O(n) then f + g is O(n)
10:32:06 <ion> With Lens, listOfRecords ^. folded . field2
10:32:15 <Cale> There is fusion going on all over the place. I would expect there to be a rule somewhere that fuses ByteString's concat with build or map
10:32:22 <brrrrian> "f (map g x)" executes like [ g(x1) `f` g(x2) `f` ... g(xn) ]  ?? because of the crazyness that is laziness?
10:32:34 <Cale> err
10:32:37 <sipa> clazyness
10:32:54 <ion> > f (map g [a,b,c])
10:32:56 <lambdabot>   Could not deduce (Debug.SimpleReflect.Expr.FromExpr b0)
10:32:56 <lambdabot>    arising from the...
10:32:57 <Cale> brrrrian: Lazy evaluation isn't going to magically change the type of things
10:33:00 <joneshf-laptop> mauke, looks almost arrowish
10:33:17 <Kron> brrrrian: not quite
10:33:20 <Kron> you sorta get...
10:33:23 <Cale> brrrrian: It just means that expressions are evaluated outermost first, and that any bound variable is evaluated at most once
10:33:36 <Kron> it's hard to explain actually
10:33:53 <Kron> > map (*2) [1,2,3,undefined,4,5]
10:33:54 <lambdabot>   [2,4,6,*Exception: Prelude.undefined
10:33:54 <Cale> But what Kron is referring to here isn't lazy evaluation
10:34:11 <Kron> take a look at that: it multiplies each element and prints it before evaluating the full list
10:34:20 <Cale> Let's actually check that there're rules for BS.concat here :P
10:34:26 <Kron> it generates the output as it goes along, it does not actually construct the whole input list in memory
10:35:23 <Cale> Well, okay, there is *that*, yes
10:35:46 <Cale> Lazy evaluation will mean that the list is computed as concat demands each part of it, regardless.
10:36:05 <Kron> when people are worrying about bytestrings it's generally due to memory constraints, and it's nice to remind people how lazy evaluation works when they're new to haskell here especially '^^
10:36:14 <Kron> I remember for the longest time I just totally didn't get it
10:36:28 <Kron> I used to avoid foldr especially since it seemed like a non-tail-recursive nightmare
10:36:37 <Cale> But you only save *space* that way, you don't actually save any *time* over doing two traversals like that, unless there's a rule to eliminate the construction of the intermediate list.
10:36:42 <joejev> hey, I thought that hackage added the docs after about 8:00, however, the docs for my package candidate aren't showing up
10:36:54 <Kron> indeed, I was focusing on space; I should have been more clear
10:36:55 <Cale> (except maybe GC time!)
10:37:02 <brrrrian> "it generates output as it goes along"  okay makes sense for "map field2 list" but still don't understand why the list doesn't have to be fully evaluated before it is passed to concat in "concat (map field2 list)"
10:37:28 <Kron> because there is no true function stack; return values are not entirely calculated values.
10:37:29 <Cale> brrrrian: Okay, so lazy evaluation crash course:
10:37:34 <Kron> what it returns are things called 'thunks'
10:37:43 <Kron> they are sort of abstracted notions of computation to be performed in the future
10:37:45 <Cale> Let's not go down to the level of thunks
10:37:48 <Kron> sure
10:37:54 <Cale> Let's suppose we have the definition  double x = x + x
10:38:08 <Cale> and we'll use a few different methods to evaluate  double (double 5)
10:38:34 <Cale> First there's strict evaluation, which is innermost first, and is probably what you're familiar with if you've used any other programming languages
10:38:41 <Cale> double (double 5)
10:38:45 <Cale> -> double (5 + 5)
10:38:45 <brrrrian> ya
10:38:47 <Cale> -> double 10
10:38:50 <Cale> -> 10 + 10
10:38:51 <Cale> -> 20
10:39:05 <Cale> But that's not the only order we could have chosen to evaluate in
10:39:11 * hackagebot DAV 0.5 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-0.5 (ClintAdams)
10:39:34 <Cale> In particular, we might have chosen to always reduce the outermost leftmost reducible subexpression first:
10:39:36 <kristof> Is there a theoretical framework for metaprogramming?
10:39:39 <Cale> double (double 5)
10:39:44 <Cale> -> (double 5) + (double 5)
10:39:50 <kristof> Are GADTs what I'm looking for?
10:39:51 <Cale> -> (5 + 5) + (double 5)
10:39:55 <Cale> -> 10 + (double 5)
10:40:00 <Cale> -> 10 + (5 + 5)
10:40:02 <Cale> -> 10 + 10
10:40:05 <Cale> -> 20
10:40:07 <Iceland_jack> kristof: GADTs are unrelated to metaprogramming
10:40:49 <Cale> But here we obviously wasted effort duplicating the work of computing double 5, because x occurred twice in the body of double x = x + x
10:41:21 <Cale> So lazy evaluation adjusts that a bit, and says that we should share the computation of a bound variable between all of its occurrences
10:41:40 <kristof> Iceland_jack: Well, I had supposed that they would be useful for statically typed metaprogramming.
10:41:42 <Cale> If you'll permit me to use let ... in ... to represent that sharing, here's how it looks with lazy evaluation:
10:41:45 <Cale> double (double 5)
10:41:58 <Cale> -> let x = double 5 in x + x -- note that this is still outermost-first!
10:42:05 <Cale> -> let x = 5 + 5 in x + x
10:42:10 <Cale> -> let x = 10 in x + x
10:42:12 <Cale> -> 10 + 10
10:42:14 <Cale> -> 20
10:42:40 <brrrrian> So basically lazy evaluation is outer-most evaluation (on-demand evaluation) with optimizations... and makes it extremely hard to reason about any sort of step-by-step execution of the program...
10:42:52 <Cale> Strict evaluation evaluates every argument to a function exactly once.
10:42:56 <monochrom> it is pretty easy to me
10:43:09 <kristof> brrrrian: Only hard if you don't know the rules! And I believe that it's not *always* outer-most evaluation.
10:43:10 <Kron> brrrrian: it's non intuitive reasoning
10:43:14 <Kron> peopel aren't used to it
10:43:14 <Cale> Normal order evaluation (outermost-first) evaluates every argument to a function zero or more times.
10:43:18 <Kron> but you can get used to it over time
10:43:27 <Cale> Lazy evaluation evaluates every argument to a function zero or one times.
10:43:32 <kristof> brrrrian: There are specific rules outlined on the haskell wiki
10:43:38 <Kron> have you ever seen an infinite list in haskell?
10:43:47 <Cale> So in that sense, it's the "best of both worlds" between innermost and outermost first evaluation.
10:43:55 <kristof> brrrrian: Only hard if you don't know the rules! And I believe that it's not *always* outer-most evaluation.6
10:44:07 <Kron> > take 10 (map (* 2) [1..])
10:44:08 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
10:44:09 <monochrom> I wouldn't call it "intuitive" or "not intuitive". "only the nipple is intuitive"
10:44:22 <Cale> The step-by-step evaluation order is completely determined if you're using lazy evaluation, and is easy to reason about.
10:44:31 <monochrom> anyway, read my http://www.vex.net/~trebla/haskell/lazy.xhtml
10:44:34 <Kron> infinite lists are possible because of stuff like this
10:44:42 <Cale> However, Haskell is not specified as using lazy evaluation!
10:45:03 <Kron> are there ANY other languages that use lazy evaluation though?
10:45:08 <Cale> Clean
10:45:19 <mauke> make
10:45:27 <Kron> Also I feel that lazy evaluation is too fundamental to Haskell programming to really say stuff like "haskell is not specified as using it" without a lot of footnotes
10:45:36 <Kron> ooh I didn't think of make. Never heard of Clean.
10:45:50 <brrrrian> monochrom: thanks
10:45:52 <Cale> Haskell is only specified to have non-strict semantics, i.e. programs should terminate when lazy or outermost-first evaluation would terminate, and they should have the same result.
10:45:55 <xkb> Clean is nice
10:46:13 <Cale> But compilers are free to reorder the evaluation whenever it would be more efficient to use innermost-first evaluation for a while.
10:46:15 <xkb> Esp. Uniqueness typing
10:46:20 <Cale> (or any other evaluation order)
10:46:37 <Kron> Cale: ahh I see
10:46:43 <Cale> and of course, Haskell is designed so that it doesn't actually matter which order the expression is evaluated in
10:46:50 <brrrrian> > map (* 2) [1..10]
10:46:51 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
10:46:54 <Kron> I don't fully understand or appreciate the difference between non-strictness and laziness
10:46:56 <Cale> You get the same result, so long as you don't maliciously choose an order which doesn't terminate
10:47:13 <Cale> (and if any order terminates, then outermost-first does)
10:47:20 <mauke> Kron: sharing results
10:47:38 <Cale> laziness implies outermost-first only, with sharing
10:47:52 <monochrom> "non-strict" doesn't say which order, only whether you get an answer eventually
10:48:01 <Kron> > take 10 . map (\ n -> product [1..n]) $ [1..]
10:48:02 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800]
10:48:09 <monochrom> "non-strict" is at an entirely different level
10:48:10 <Kron> a list of all factorials, etc.
10:48:10 <Cale> non-strictness says roughly "do whatever you want, so long as the result of the program is the same as with outermost-first evaluation"
10:48:30 <Kron> ok
10:48:30 <monochrom> strict : lazy :: tree : apple
10:48:39 <Cale> So if the compiler can prove that it's okay to be strict, it can be.
10:48:47 <monochrom> consider "comparing apples with trees"
10:48:54 <Cale> and in practice, GHC is pretty good at finding opportunities to be stricter
10:49:10 <mangaba_leitosa> sometimes it's funny to see how 'let value = f args' in REPL works correctly, then trying to print value results in an exception :-)
10:49:15 <Cale> (so long as you're using -O or -O2)
10:49:32 <Kron> mangaba_leitosa: many things are perfectly valid evaluations, they just aren't printable
10:49:36 <Cale> mangaba_leitosa: Well, the let will only be typechecked
10:49:44 <Kron> the only printable things are objects that are a part of the show typeclass
10:49:47 <Cale> let doesn't cause any evaluation of the defined things to happen
10:49:52 <Kron> right
10:49:56 <Cale> (unless you're using bang patterns, weirdly)
10:50:09 <Kron> from my interpreter:
10:50:10 <Kron> ghci> let x = [1..]
10:50:10 <Kron> ghci>
10:50:17 <Cale> Bang patterns can transform let into case
10:50:21 <Kron> stuff like this is normal, it doesn't evaluate, it just defines
10:50:23 <monochrom> read my http://www.vex.net/~trebla/lazy.xhtml . it begins by discussing non-strict vs lazy.
10:50:35 <Kron> monochrom: will do
10:51:02 <mangaba_leitosa> Kron: no, I mean the case when actually evaluating 'value = f args' will cause an exception when 'value' is finally accessed
10:51:07 <Cale> (I actually kind of wish they'd stuck with the original translation of bang patterns, maybe it was less useful in some corner cases, but it was easier to understand)
10:51:23 <Kron> mangaba_leitosa: that's also reasonably normal... but less normal, yeah
10:51:32 <Kron> > take 2 [1,2,3,undefined,4,5]
10:51:32 <mangaba_leitosa> Kron: :-)
10:51:33 <lambdabot>   [1,2]
10:51:45 <Kron> you can layer landmines in your structures
10:52:07 <Iceland_jack> Kron: I do that in my code in for testing ;)
10:52:14 <Kron> same actually
10:52:22 <Kron> it's my favorite way to make sure my code is lazy
10:52:29 <Kron> also how I prototype functions
10:52:36 <Kron> foo = undefined
10:52:38 <Kron> I fill it in later
10:52:51 <Iceland_jack> indeed, working out the types is a great way to get started
10:53:15 <scott_> Sometimes I write part of an expression and put 'undefined' in one part, then ask vim/hdevtools what type that part of the expression needs to be
10:53:16 <Cale> That's also what I do when people don't paste their entire code (which is annoying!)
10:53:16 <Feuerbach> monochrom: 404
10:53:35 <Cale> Just define all the things which they left out as undefined
10:53:54 <Cale> and hope that I can reproduce whatever type error they're struggling with anyway ;)
10:54:02 <Kron> oooh you have a vim plugin that lets you scan types of parts of your code?
10:54:05 <Kron> can you do that in emacs?
10:54:50 <scott_> It's super useful because it actually tells you the specialized type of things in expressions, not just the type they are defined with
10:54:56 <scott_> I'm sure you can do in emacs too
10:55:45 <Kron> indeed
10:56:03 <brrrrian> If I have a function like:  fun = do a <- getA ; b <- getB ; ... return $ SomeData a b ...   how can I write that in a better style?  I think this is where applicative comes in, but I am not yet there in understanding
10:56:17 <Philonous> Kron, ghc-mod
10:56:20 <Iceland_jack> brrrrian: liftM2 SomeData getA getB
10:56:29 <Kron> thanks Philonous
10:56:31 <Cale> brrrrian: Well, you can use liftM2 or you can use the Applicative combinators
10:56:37 <brrrrian> but i see control.applicative and control.monad operators everywhere so i need some basic level of understanding of what's going on
10:56:38 <Iceland_jack> If it's applicative then you can use liftA2
10:56:38 <simon> brrrrian, liftM4 SomeData getA getB getC getD
10:56:42 <Cale> SomeData <$> getA <*> getB
10:56:45 <mirpa> SomeData <$> getA <*> getB
10:56:46 <Iceland_jack> or: someData <$> .... damn
10:56:57 <Cale> good ol' stereo
10:57:06 <dirk1033> Anyone know anything about generated code on x86 for GHC? I'm just wondering about reverse engineering software written in haskell. seems like it might generate some weird funky machine code?
10:57:24 <Cale> dirk1033: It would
10:57:32 <Cale> dirk1033: You should start with the STG machine paper
10:57:43 <Cale> It's not entirely accurate anymore, but it's a solid starting point
10:57:52 <simon> brrrrian, else: http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#v:ap
10:57:59 <Cale> http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
10:58:42 <Cale> dirk1033: Basically, all variables become pointers to code.
10:59:24 <dirk1033> hehehe cool
10:59:24 <ion> implementing peytonjones
11:00:02 <mauke_> peyt `on` jones
11:00:05 <stewe> Gtk or Qt for haskell GUI lib?
11:00:08 <dirk1033> there's a haskell compiler for sparc i assume? I bet taht would be a really good platform for it
11:00:18 <Cale> dirk1033: The first time a variable is evaluated, that code for computing its value is entered, and it rewrites the pointer temporarily to point at a "black hole" which will kill the program with an exception if entered (detected infinite loop), before computing the value, and then rewriting the pointer to point at a short piece of code which returns the already computed value immediately.
11:00:45 <rdevilla> that's insane
11:02:03 <dirk1033> Cale: Have you worked on GHC?
11:02:06 <Cale> no
11:02:16 <simpson> Should I feel bad about TupleSections?
11:02:25 <chrisdone> no, tuplesections are awesome
11:02:29 <Cale> simpson: I wouldn't
11:02:46 <Cale> dirk1033: I have been programming in Haskell since around 2001 or so
11:03:08 <stewe> in what cases would "black hole" be entered?
11:03:22 <Cale> stewe: Things like x = x + 1
11:03:31 <stewe> ah
11:03:31 <Cale> where in order to evaluate x, you need the value of x
11:03:59 <Cale> (specifically, you need to *pattern match* on the value of x)
11:04:10 <stewe> but wouldnt parallel access to x also trigger it?
11:04:14 <Cale> Pattern matching is ultimately what drives evaluation forward
11:04:23 <Cale> Well, parallelism complicates things
11:04:25 <dirk1033> eeeeeeee
11:04:26 <dirk1033> split
11:04:39 <dirk1033> Cale: What kind of projects have you worked on?
11:04:41 <Cale> With the threaded runtime, blackholes can't quite work like that
11:05:02 <stewe> yeah
11:05:37 <Cale> dirk1033: Well, my first major project was a pipeline scheduler and register allocator for PPC/Altivec assembly as part of a compiler for a special purpose language for signal processing applications.
11:05:49 <dirk1033> wow Math.FFT
11:07:07 <stewe> what about things like "let xs = 1 : 2 : xs". what is stopping that from entering it
11:07:21 <dirk1033> Cale: That sounds hard. :P
11:07:32 <Cale> (It was a summer job at McMaster University, my scheduler managed to schedule a program which was about 42 instructions long for computing sine/cosine pairs into a 15 cycle loop, and we had a practical performance of about 2.5 clocks/float :)
11:07:35 <mauke> stewe: that's already in WHNF
11:07:53 <Cale> (for unfair comparison GNU libm takes around 200 cycles/float)
11:08:05 <mauke> stewe: xs = (:) 1 ((:) 2 xs)
11:08:19 <mauke> i.e. xs points to a (:) node containing 1 and another list
11:08:25 <stewe> but we need to keep evaluating xs to (keep) write to xs, no?
11:08:31 <stewe> writing*
11:08:35 <mauke> write to xs? huh?
11:09:11 <mauke> Cale mentioned above that pattern matching drives evaluation
11:09:17 <dirk1033> Cale: Is that thanks to haskell or ability or both? :P
11:09:24 <mauke> and you can match on _ : _ without touching xs
11:09:28 <brrrrian> okay, I've got a fun one...  how to transform [ a1 b1 a2 b2 ... an bn ] into [ b1 a1 b2 a2 ... bn an ] ?
11:09:28 <Cale> Another big one was that I worked for a startup called iPwn Studios on an action RPG in Haskell called Blood Knight. That's unreleased, the company is on hiatus until the owner gets some more funds, but I learned a good deal about using and implementing FRP systems that way.
11:09:57 <reizuki> nadirs: great, me too! I just finished mine :)
11:09:58 <brrrrian> is there a way to split the list and then zip it back up to do that?
11:10:12 <Iceland_jack> brrrrian: foo (a:b:rest) = b:a:foo rest
11:10:12 <Philonous> Cale, Oh, you're not working on that game any more? Bummer :(
11:10:12 <Cale> dirk1033: Well, Haskell made this reasonable to do in ~1200 lines, about 50% of which was comments, and reasonable to write in 2 months
11:10:14 <mauke> whenever I see FRP I think of making farting noises with my hands
11:10:17 <Iceland_jack> with an appropriate empty case
11:10:22 <reizuki> nadirs: I feel that my solution to exercise 2 is somewhat clunky, though
11:10:28 <Iceland_jack> You can also use chunksOf
11:10:43 <Cale> dirk1033: In C, it would have been something like 50 or 60 thousand lines, and I wouldn't have been able to do it
11:10:52 <Iceland_jack> > concatMap reverse (chunksOf 2 "testing")
11:10:53 <lambdabot>   "ettsnig"
11:10:53 <stewe> mauke: we talked about runtime writing to unevaluated variable, and setting up a "black hole" that, if variable is evaluated again, crashes program
11:11:01 <Iceland_jack> brrrrian: ↑ does that answer your question?
11:11:07 <reizuki> reizuki: I'll take a look at your repo since I'm curious how you did it!
11:11:11 <mauke> stewe: no, we're not writing to variables
11:11:20 <brrrrian> Iceland_jack: yes, thanks.  that's elegant
11:11:27 <dirk1033> Cale: Can you explain more in laymans terms what it did? :P
11:11:30 <Cale> dirk1033: (I leaned heavily on what was essentially the list monad)
11:11:30 <reizuki> nadirs: ^ lol, I addressed a message to myself, I'm the best!
11:11:35 <stewe> we are not but runtime is
11:11:39 <mauke> stewe: timeout, I need to think
11:12:35 <dirk1033> So why isn't functional programming more popular? Tradition / ignorance?
11:12:37 <mauke> stewe: ok, so what's going on is that we only evaluate one level deep
11:12:53 <mauke> stewe: which is a no-op because _ : _ is already evaluated
11:12:53 <mangaba_leitosa> stewe: what is it for? uniqueness types?
11:12:56 <Cale> dirk1033: Well, the main bit was taking a loop consisting of a bunch of PPC/Altivec instructions, working out their data dependencies, and then reordering them. If you're willing to move a bunch of iterations to the beginning and end of the loop, you can essentially put the ones in the body of the loop anywhere you like.
11:13:35 <Cale> dirk1033: My program kept track of the activity of the various units on the CPU and tried to schedule the instructions in such a way that they could be executing in parallel
11:13:39 <mauke> that reminds me, I wanted to ask Cale something about lazy lambda calculus
11:13:42 <stewe> mauke: I see
11:13:51 <Cale> (on top of the parallelism that SIMD instructions were already giving us)
11:14:16 <dirk1033> Cale: Ah so it was kind of a optimization routine for the compiler?
11:14:18 <Cale> dirk1033: and basically, the goal was to fit the loop body into as few cycles as possible
11:14:20 <Cale> yeah
11:14:25 <dirk1033> Wow
11:14:41 <Cale> for optimising the computation of a loop which was mapping some function over an array
11:15:05 <dirk1033> You must have learnt a ton about PPC/Altivec processor/system architecture. At what point did you learn all that?
11:15:13 <Cale> I also did the register allocator, which is basically just a graph colouring algorithm
11:15:25 <Cale> I learned it as I went
11:15:39 <Cale> I didn't know anything about PPC/Altivec before I started the project
11:16:06 <dirk1033> did you plan this all out before you started coding?
11:16:41 <Cale> Pretty much, yeah. I spent most of the time thinking, and then wrote the whole thing in a week
11:16:42 <stewe> mangaba_leitosa: no completely unrelated to that. topic was how ghc runtime implements lazy evaluation
11:16:47 <stewe> anyway gtg
11:17:03 <Cale> (Not quite, but mostly :)
11:17:38 <mauke> Cale: in lazy lambda calculus, a value is either reduced (i.e. a lambda) or a thunk (i.e. an application). is this correct?
11:17:41 <reizuki> byorgey: I wrote down a few fresh emotions during and after doing your homework/lesson, do you want to read them now or you'd prefer to get them in bulk after I'm done? :)
11:18:14 <dirk1033> Cale: That's really cool. Were the PPC instructions just stored in a normal haskell list?
11:18:17 <reizuki> s/emotions/thoughts/
11:19:01 <dirk1033> I find it very interesting you were able to do such a low level thing so effectively.
11:19:19 * hackagebot hPDB 1.1 - Protein Databank file format library  http://hackage.haskell.org/package/hPDB-1.1 (MichalGajda)
11:19:21 * hackagebot hPDB-examples 1.1 - Examples for hPDB library  http://hackage.haskell.org/package/hPDB-examples-1.1 (MichalGajda)
11:19:25 <Cale> dirk1033: Well, it's actually all quite high level. My program was *emitting* a low-level thing.
11:20:18 <Cale> The Haskell program didn't even have to necessarily be very fast. It just had to produce a fast resulting piece of code as its output :)
11:20:26 <dirk1033> yes
11:20:57 <dirk1033> what it emit. was it just a list of bytes i guess
11:21:02 <Cale> There were lots of lists involved, but I think the mapping from cycle to instructions was in a Data.Map
11:21:05 <dirk1033> machine language
11:21:13 <Cale> Ultimately, a chunk of assembly code.
11:21:13 <dirk1033> or was it assembler you were emitting? it some kind of IR code
11:22:11 <dirk1033> okay well i gtg nice talking to you
11:22:17 <Cale> see you around!
11:22:33 <Cale> mauke: Um
11:23:42 <Cale> mauke: Okay, so I guess it depends on the details of the lambda calculus which sorts of expression terms there are, but usually, you say that something is in weak head-normal form (WHNF) if it is either a lambda, or it is an application of a data construtor to any arguments.
11:23:56 <mauke> let's say we don't have any data
11:24:01 <Cale> That's usually the most meaningful sense of something being "evaluated"
11:24:22 <Cale> Then yeah, if something is a lambda, it's done.
11:24:38 <Cale> If it's an application, then you can beta reduce it.
11:25:05 <Cale> (because it'll have to be an application of a lambda if there're no data constructors)
11:25:17 <mauke> not necessarily
11:25:21 <mauke> the evaluator basically goes like this: is it a lambda? ok, done. otherwise it's an application and I must reduce the first bit first
11:26:05 <mauke> after reduction it must be a lambda and I can substitute stuff in
11:26:32 <mauke> and then I guess it has to check the result again
11:26:46 <Cale> oh, yeah of course the thing on the left could be something else, yes
11:27:15 <simpson> Huh. I have reached yet another point where incomprehensible walls of symbols seem like the best way to do things.
11:27:18 <simpson> lookupMethod i (VTable (t, p)) = IM.lookup i t <|> (p >>= lookupMethod i)
11:27:48 <Cale> Maybe  lookupMethod i =<< p  would be better?
11:27:48 <chrisdone> so the syntax is this? data Expr = Var Int | Lam Int Expr | App Expr Expr
11:27:55 <mauke> ((((a b) c) d) e) would then cause recursion in the evaluator
11:28:06 <Cale> mauke: yeah, that's right
11:28:20 <mauke> and that's where the stack goes
11:28:45 <simpson> Yeah. I'm just kind of surprised that "Either look it up on the current table, or on the parent of the current table, and return everything in Maybe" actually works notationally.
11:28:55 <Cale> If you're not doing something special to expressions like that, yes
11:29:07 <mauke> function calls are simply "substitute parameter, switch over to body"
11:29:14 <mauke> no need for a stack
11:29:17 <Cale> right
11:29:42 <mauke> chrisdone: pretty much, except Int is bad
11:30:02 <chrisdone> Integer better?
11:30:03 <mauke> and Var doesn't appear in values
11:30:10 <chrisdone> ah, huh
11:30:17 <quchen> Is there any way I can specify which package to import a module from without a .cabal file (for small hacky projects for example)? MTL and Monads-TF keep clashing
11:30:38 <mauke> except it does
11:30:40 <mauke> dammit
11:30:47 <chrisdone> mauke: so the parameters of the lambdas are not used inside the abstraction? e.g. (\x.x) is not possible?
11:30:57 <mauke> it can't appear at the top level, but it has to exist under lambda
11:31:04 <chrisdone> gotcha
11:31:05 <mauke> chrisdone: why not String?
11:31:10 <Cale> Yeah, you do need Var
11:31:41 <chrisdone> mauke: sure, String. just didn't know what encoding was being used
11:31:57 <Cale> In a dependently typed setting, you could more easily make sure that the variables are always something bound in the environment :)
11:33:24 <mauke> now that that's cleared up, I can consider constructors
11:33:25 <chrisdone> cale: yeah, that seems tricky to express in haskell
11:33:42 <mauke> and I may need to do this again in the future because it doesn't come intuitively to me
11:34:19 <matheus23> Hello, I've got an endless loop in Yampa using 'loop' from ArrowLoop, I've tried to implement 'integral' myself. What could be the cause of that?
11:34:53 <Cale> matheus23: Basically, you have to be super-careful about strictness when using loop
11:34:53 <matheus23> code incoming: http://pastebin.com/YqmXJbKw
11:34:58 <mauke> The paste YqmXJbKw has been copied to http://lpaste.net/96756
11:35:30 <Cale> yes, that won't work, because loop doesn't have any built-in delay
11:36:10 <matheus23> erm. Okay... I wondered how it would get 'lastPosition' the first time it was called anyways....
11:36:14 <matheus23> so how do I get it to work? :)
11:36:21 <Cale> So you're defining lastPosition = newPos here, essentially
11:36:50 <Cale> I forget what Yampa called its infinitesimal delay...
11:37:49 <Cale> ah, right, pre / iPre
11:37:59 <Cale> You're probably going to want to use iPre
11:38:02 <matheus23> *googleing*
11:38:51 <Cale> iPre :: a -> SF a a
11:39:25 <matheus23> I see, but what does it do?
11:39:35 <matheus23> or better: How does it help me?
11:42:18 <Cale> It makes sure that you're not setting the second component of the tuple to the solution to x = x + velocity
11:42:47 <Cale> actually, I'm not sure that this approach is actually going to work...
11:43:06 <Cale> But it should at least break the cycle so you don't get <<loop>>
11:43:40 <Cale> You could also use loopPre
11:44:09 <Cale> which is similar to loop, but you give an initial value, and it delays the cycling so that you don't have infinite loops
11:44:15 <matheus23> ah okay
11:44:22 <matheus23> yeah I got that from the signature this time :9
11:44:36 <Cale> loopPre c_init sf = loop (second (iPre c_init) >>> sf)
11:45:31 <matheus23> but that's not what they originally used when implementing 'integral' right?
11:45:43 <Cale> Well, you're not making use of the time step here
11:45:47 <Cale> which varies
11:45:59 <Cale> so your integral will probably be very incorrect
11:46:02 <matheus23> yeah, I'm not multiplying by delta value
11:46:06 <matheus23> (yet)
11:46:14 <matheus23> delta time*
11:46:39 <Cale> http://hackage.haskell.org/package/Yampa-0.9.3/docs/src/FRP-Yampa.html#integral
11:47:08 <matheus23> what is 'zeroVector'?
11:47:24 <Cale> It's polymorphic
11:47:41 <Cale> zeroVector is the zero vector of the vector space that you're integrating in
11:47:47 <matheus23> so there is an instance of VectorSpace for Int, where zeroVectoris 0 for Int's?
11:47:54 <Cale> Well, not for Int, surely
11:47:59 <Cale> But for Double
11:48:07 <matheus23> oh yeah. right
11:48:23 <matheus23> perfect, that helps! :)
11:48:44 <matheus23> (btw, those nested 'where's are crazy...)
11:48:47 <greg`> yo!
11:49:22 <Cale> The Yampa code is pretty obnoxious to read for some reason, but you kind of have to read some bits of it to know what's going on :)
11:49:45 <matheus23> okay :)
11:49:54 <matheus23> Big thanks for your help!
11:50:13 <greg`> hlint-1.8.55 depends on haskell-src-exts-1.14.0 which failed to install
11:50:14 <Cale> (and some of the comments are helpful)
11:50:21 <greg`> does anyone know what i should do ?
11:50:27 <greg`> ive tried cabal update
11:50:48 <Cale> (especially the one before 'reactimate')
11:51:04 <merijn> Pipes question: Is there a simpler way to turn "a -> m ()" into a "Consumer a m r" then "for cat (lift . f)"? It seems a little cumbersome that way
11:51:08 <Cale> greg`: figure out why haskell-src-exts failed to install
11:51:35 <Cale> greg`: Hopefully there will be an error message of some sort
11:52:01 <greg`> Configuring haskell-src-exts-1.14.0...
11:52:02 <greg`> setup: The program happy version >=1.17 is required but it could not be found.
11:52:02 <greg`> Failed to install haskell-src-exts-1.14.0
11:52:02 <greg`> cabal: Error: some packages failed to install:
11:52:05 <greg`> haskell-src-exts-1.14.0 failed during the configure step. The exception was:
11:52:08 <greg`> ExitFailure 1
11:52:08 <merijn> Wait, I guess that's not even right...
11:52:11 <greg`> hlint-1.8.55 depends on haskell-src-exts-1.14.0 which failed to install.
11:52:18 <greg`> so it looks like happy wasnt found
11:52:24 <greg`> but i cant imagine why
11:52:51 <tomejaguar> greg`: Is happy on your PATH?
11:53:00 <Cale> 'which happy'
11:53:35 <greg`> no i deleted my .cabal directory
11:53:41 <Cale> cabal install happy
11:54:49 <greg`> Building happy-1.19.2...
11:54:49 <greg`> Preprocessing executable 'happy' for happy-1.19.2...
11:54:49 <greg`>  
11:54:49 <greg`> src/Grammar.lhs:33:10:
11:54:52 <greg`>     Could not find module `Control.Monad.Writer'
11:54:55 <greg`>     There are files missing in the `mtl-2.1.2' package,
11:54:56 <applicative> merijn: you mean like \f -> forever $ await >>= lift . f
11:54:57 <matheus23> just a quick follow up question: Why can 'integral' work without requireing 'Num' but also using '+'? That doesn't work for me...
11:54:59 <greg`>     try running 'ghc-pkg check'.
11:55:02 <greg`>     Use -v to see a list of the files searched for.
11:55:05 <greg`> Failed to install happy-1.19.2
11:55:14 <greg`> ok i'll try and find the root cause,
11:55:24 <greg`> just it shouldnt be this hard should it?
11:55:49 <merijn> applicative: Yeah, that's identical, I think
11:56:19 <merijn> matheus23: Does integral have any other constraints?
11:56:29 <matheus23> VectorSpace, no more
11:56:32 <merijn> matheus23: Might be Num is a superclass for one of the constraints on integral
11:56:46 <merijn> matheus23: Yeah, pretty sure VectorSpace is a subclass of Num
11:56:55 <matheus23> yeah, I used VectorSpace as a constraint, too, but idt doesn't work :(...:
11:56:56 <applicative> merijn: yeah, 'for ..' like you wrote is supposed to be the standard way, if I understand. I came looking for Tekmo but he seems to have vanished.
11:57:05 <matheus23> "Could not deduce (Num a) arising from a use of `+'"
11:59:05 <merijn> matheus23: Paste the code and errors on lpaste?
11:59:09 <greg`> this is insane , should i just delete my .cabal directory and start again?
11:59:28 <greg`> ghc --version
11:59:36 <greg`> oops wrong window
11:59:37 <matheus23> http://lpaste.net/96757
12:00:43 <geekosaur> greg`: removing ~/.cabal does nothing useful, and mtl should be in the global registry (if it's in the local one then [a] that's most of your problem [b] and removing ~/.cabal would almost certainly have *caused* what you're seeing)
12:00:54 <merijn> matheus23: And which code led you to believe the Num constraint is optional?
12:01:07 <matheus23> http://hackage.haskell.org/package/Yampa-0.9.3/docs/src/FRP-Yampa.html#integral
12:01:22 <merijn> matheus23: Couldn't you just solve this by writing "(Num a, VectorSpace a s) =>"?
12:01:29 <greg`> thanks geekosaur , i guess i just want a fresh repository
12:01:40 <geekosaur> then you are looking for ~/.ghc
12:01:40 <merijn> matheus23: That's not using +, though
12:01:41 <matheus23> yeah... I think so ^^
12:01:51 <greg`> thanks
12:01:51 <matheus23> well, it's "+^"
12:01:56 <merijn> matheus23: It's using ^*^ which is a class function of VectorSpace
12:02:01 <merijn> eh
12:02:03 <merijn> ^+^
12:02:07 <matheus23> yeah, typo
12:02:10 <matheus23> okay, thanks! :)
12:02:20 <matheus23> wait, but how does that work?
12:02:36 <merijn> matheus23: http://hackage.haskell.org/package/vector-space-0.8.6/docs/Data-AdditiveGroup.html
12:02:40 <geekosaur> in particular, removing ~/.cabal without also removing ~/.ghc will break things, while removing ~/.ghc without removing ~/.cabal is mostly harmless
12:02:53 <merijn> matheus23: AdditiveGroup is a superclass of VectorSpace
12:02:54 <pdxleif> Anyone know how to write a request body to a file under WAI 2.0.0?
12:03:29 <matheus23> so could I simply use "^+^" instead of +?
12:03:34 <merijn> matheus23: As you can see it comes with a ton of predefined instances
12:03:36 <pdxleif> Under 1.4.1 I had 'requestBody req $$ sinkFile "foo"', but now it needs runResourceT or a hoist or something somewhere?
12:03:39 <greg`> ok i'll blat them both , thanks
12:03:51 <merijn> matheus23: Depends on what you want, ^+^ is vector addition
12:03:56 <matheus23> NICE! :)
12:03:59 <matheus23> works :9
12:09:07 <mirpa> Can I open file regardless of case-sensitivity? (Windows->Linux)
12:09:07 <matheus23> So in the end I've finally implemented 'fixedCappedIntegral', thanks merijn and Cale! :)
12:09:49 <mirpa> eg. openFile "img.BMP" ... saved as Img.BMP
12:11:02 <merijn> mirpa: By opening the folder and looking for any file matching a case insensitive version of your filename?
12:11:18 <merijn> mirpa: linux doesn't provide a way to case-insensitively open a file, afaik
12:11:50 <mirpa> merijn: I am just wondering if there is some system independent library for that
12:12:45 <nadirs> and what if there are two files with the same (case-insensitively) name?
12:13:17 <mirpa> I am porting some windows ap to linux
12:13:25 <mauke> case sensitivity isn't a well defined concept
12:13:31 <mauke> er. insensitivity
12:14:16 <mirpa> I mean that two such names are impossible because it would cause a problem on Windows...
12:14:51 <merijn> mirpa: You can't
12:15:12 <merijn> mirpa: Only one solution: stab users who create files with same name but different case
12:15:29 <merijn> and/or name & shame them
12:15:33 <quchen> merijn: That requires hardware support though
12:15:39 <merijn> quchen: True :)
12:15:55 <joneshf-laptop> quchen, the name & shame could easily dish it off to twitter or some such
12:16:00 <mirpa> I guess that I will have to loouk whole directory then...
12:16:14 <mirpa> *lookup
12:16:33 <wojtekM_> The docs say that Data.Time.Clock.UTCTime has Show instance, but ghci says otherwise. What am I doing wrong?
12:17:29 <merijn> wojtekM_: Looking at the wrong version of the docs? :)
12:17:47 <quchen> The docs are wrong
12:17:52 <quchen> Can confirm
12:18:01 <quchen> Oh. Hold on a second.
12:18:48 <quchen> Well I've got time-1.4.0.1, docs mention Show, :i doesn't.
12:19:11 <wojtekM_> For 1.4.1 it is the same
12:19:49 <greg`> does anyone know what the latest is regarding ghci and arm
12:20:07 <quchen> greg`: I think GHCi started working with 7.6
12:20:23 <quchen> In 7.8 I think ARM is an officially supported target platform
12:20:52 <wojtekM_> quchen: Do you think it is okay for me to report this as an issue?
12:21:19 <quchen> wojtekM_: One thing I could imagine is that it's an orphan instance that Haddock automatically resolves
12:22:00 <greg`> cool
12:22:15 <greg`> thanks quchen
12:23:02 <greg`> there isnt a haskell platform for arm , i would have to assemble the various components myself right?
12:23:11 <ehtesh> are there additional lessons to http://tryhaskell.org/ ? I like the style a lot
12:23:37 <wojtekM_> quchen: But I guess it would be nice to have a Show instance?
12:23:45 <quchen> wojtekM_: Yeah it's an orphan instance, defined in Time/LocalTime/LocalTime.hs
12:23:59 <quchen> Not sure why. The source even calls it an orphan explicitly.
12:24:25 <quchen> It doesn't mention why having an orphan here makes sense. Worth a ticket if you ask me.
12:24:52 <quchen> (On a related note, it would be really nice if Haddock provided source links for instances.)
12:25:47 <wojtekM_> quchen: You don't mind I quote you when reporting it, do you?
12:26:09 <ehtesh> but I'd like to learn more about functors, applicative functors, monads, arrows, etc via this style
12:26:44 <quchen> wojtekM_: Depends. "Quchen confirmed" isn't very useful, you should provide the source location at least :-)
12:27:42 <wojtekM_> quchen: I'll do my best
12:28:03 <quchen> wojtekM_: I just downloaded the source and grepped it to find the instance by the way
12:28:24 <quchen> ehtesh: I don't think there's more to tryhaskell.
12:29:03 <ehtesh> heck http://www.haskell.org/haskellwiki/Typeclassopedia via tryhaskell would be wow! also figured I'd ask chrisdone
12:29:47 <ehtesh> quchen: yeah, just wondering if more stuff is a WIP or if it's meant to cover only that stuff
12:29:53 <ehtesh> quchen: yeah, I was hoping for more
12:30:26 <quchen> tryhaskell isn't actively maintained anyway I think.
12:30:47 <ehtesh> drat!
12:32:05 <merijn> ehtesh: Learn You a Haskell and Real World Haskell are also good resources
12:33:00 <ehtesh> merijn, I mean I know there are other resources, but i don't like 'em as much, I guess.
12:38:25 <rtpg> how far does seq force a thunk?
12:38:46 <rtpg> just until we can figure out its datatype or if it a lambda?
12:39:30 <geekosaur> first constructor
12:40:23 <rtpg> ok, what I thought, just wanted to make sure
12:41:52 <rtpg> so in the end is forcing strictness really even that interesting for non-numeric datatypes? It seems like if we're working with recursive datatypes that the thunk cost will be linearly correlated to the strict memory cost anyways
12:43:34 <quchen> rtpg: Data.Set is essentially "data Set a = Tip | Set a !(Set a) !(Set a)".
12:43:55 <quchen> The strictness annotation ensures that the structure of the Set is always evaluated.
12:44:08 <quchen> So that's an example of where strictness of non-numeric things is handy.
12:45:04 <greg`> where can i find arm binaries 7.6?
12:45:09 <wojtekM_> quchen: Okay, I see instance Show UTCTime in LocalTime. If I load LocalTime, everything works as expected. So is this the matter of moving the instance to Data.Time.Clock?
12:45:49 <quchen> wojtekM_: Yes. An orphan instance is when an instance is defined in a module other than where the data type is defined. Orphans are generally undesirable (and issue a compilation warning).
12:46:26 <wojtekM_> quchen: Thank you.
12:46:43 <quchen> greg`: Not sure. My Raspi runs 7.4 from the repos. :-\
12:47:20 <quchen> Self-compiling GHC on the Raspi is not very enjoyable from what I've heard (compilation error after 2 days)
12:47:46 <greg`> lol i bet that sucks
12:48:01 <greg`> im on samsung chromebook
12:48:31 <greg`> can one install ghci via cabal?
12:48:38 <quchen> Maybe ask in #ghc about the new build servers. Maybe there will be an ARM one.
12:48:49 <quchen> No, GHCi is part of your compiler, you can't install it separately.
12:48:58 <greg`> cool ill hop over there
12:48:59 <greg`> thanks
12:50:10 <spaceships> is there a standard library for saving/restoring state to file?
12:50:42 <quchen> spaceships: acid-state
12:51:05 <spaceships> quchen: thanks
12:55:29 <byorgey> reizuki: I'd prefer to get them later, I'm snowed under with job applications and a paper deadline at the moment
12:55:34 <byorgey> also some actual snow
12:56:08 <jjauhien> Hey, folks. Maybe you could help with the following problem (some workaround is pretty fine). I need automatic loading BibTex record (or some other record with full authors list and journal/book/etc. name) from Google Scholar. As for now I could form a request URL and download search results page (e.g. like this one: http://bit.ly/1ddg1re). On this page to get a BibTex record the one should click on Cite link (which is JavaScript, as
12:56:08 <jjauhien>  I understand) and then click on the link Import to BibTex (which is just a usual GET link to a text, containing BibText record). So I could load pages from usual GET URLs, but my problem is to do this "click on JavaScript link and get the resulting page" in Haskell. Any suggestions, please?
13:01:03 <wojtekM_> Instance "declaration" or "definition"?
13:01:49 <ozgura> hello. I quite like `cabal install --list`, because it tells me the installed version and latest available version of packages. But it doesn't seem to work with sandboxes. Does anyone know how to get it to work?
13:02:02 <ozgura> I only tried `cabal sandbox list --installed`, but no chance.
13:02:29 <ozgura> `cabal sandbox hc-pkg list` works, but doesn't contain latest available version info
13:05:02 <wojtekM_> quchen: I think the instance is there because it needs the functionality of this module to work.
13:07:59 <wojtekM_> Hmm, is mutual module dependence (import) in haskell possible?
13:08:03 <mauke> yes
13:08:19 <johnw> wojtekM_: to a limited extent, yes
13:08:38 <johnw> you can have mutually referential functions, but not mutually referential types
13:08:58 <mauke> I bet I can
13:09:14 <johnw> data Foo = Foo Bar in one module, and data Bar = Bar Foo in another?
13:09:20 <johnw> if you can, I'd love to know the trick!
13:09:27 <johnw> i've tried and failed achieve it
13:09:56 <johnw> in general I find that .hs-boot files must form a DAG, thus freeing their corresponding source modules to be cyclic
13:10:41 <wojtekM_> In the case of Data.Time.Clock and Data.Time.LocalTime functions should be enough
13:10:48 <johnw> (or put another way, .hs-boot files turn the whole thing into a DAG, with the illusion of cyclic references)
13:12:48 <mietek> Now that we have Heroku deployment, does anyone have NewRelic integration?
13:14:22 <mauke> johnw: done
13:14:26 <johnw> show me!
13:14:32 <mauke> Foo.hs: module Foo where import Bar; data Foo = Foo Bar
13:14:44 <mauke> Bar.hs: module Bar where import {-# SOURCE #-} Foo; data Bar = Bar Foo
13:14:56 <mauke> Foo.hs-boot: module Foo where data Foo
13:15:15 <johnw> mauke: I stand happily corrected
13:15:27 <johnw> I wonder what it is that I ran into now
13:16:13 <quchen> Bad luck, johnw. :-)
13:16:27 <johnw> i had a type that needed a type from another module that needed a type from the first module
13:16:41 <johnw> and every combination I was trying did not work out; but *maybe* I never tried it in the reverse direction...
13:16:57 <johnw> because clearly mauke has a way
13:17:03 <wojtekM_> Module imports form a cycle:
13:17:04 <wojtekM_>          module `Data.Time.Clock.POSIX' (./Data/Time/Clock/POSIX.hs)
13:17:04 <wojtekM_>         imports `Data.Time.Clock.UTC' (./Data/Time/Clock/UTC.hs)
13:17:04 <wojtekM_>   which imports `Data.Time.LocalTime' (./Data/Time/LocalTime.hs)
13:17:07 <wojtekM_>   which imports `Data.Time.LocalTime.TimeZone' (./Data/Time/LocalTime/TimeZone.hs)
13:17:10 <wojtekM_>   which imports `Data.Time.Clock.POSIX' (./Data/Time/Clock/POSIX.hs)
13:17:13 <wojtekM_>  
13:17:24 <mauke> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
13:17:26 * johnw bows to mauke
13:17:39 <mauke> johnw++  # your happiness has increased
13:17:52 <johnw> next time I shall not fear the circularity
13:18:38 <wojtekM_> I need this {-# SOURCE #-} pragma?
13:18:48 <mauke> see the documentation I linked
13:19:35 <wojtekM_> I just wanted to print a timestamp a few hours ago...
13:19:39 * hackagebot hoogle 4.2.24 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.24 (NeilMitchell)
13:19:43 <mauke> that's trivial
13:20:47 <wojtekM_> mauke: Not if the timestamp is Data.Time.Clock.UTCTime
13:20:59 <mauke> we'll see about that
13:21:04 <johnw> addUTCTime
13:21:26 <wojtekM_> mauke: I learned about orphan instances
13:21:37 <johnw> addUTCTime (-(3 * 3600)) <$> getCurrentTime
13:21:40 <johnw> the time, 3 hours ago
13:23:25 <mauke> wojtekM_: c <- getCurrentTime; print c  -- works
13:24:20 <wojtekM_> it doesn't work, because the Show instance of UTCTime is in LocalTime.
13:24:29 <mauke> irrelevant
13:24:38 <wojtekM_> Well, it does if I load LocalTime, too.
13:24:48 <mauke> all I did was 'import Data.Time' and 'getCurrentTime >>= print'
13:25:05 <wojtekM_> mauke: really?
13:25:07 <mauke> yes
13:25:36 <wojtekM_> mauke: ah, because Data.Time imports a whole lot of stuff
13:25:42 <rtpg> (\xs -> head xs + last xs) [1..n]　　and  (\xs -> last xs + head xs) [1..n]
13:26:03 <rtpg> on wikibooks it says that the first takes O(1) space, and the second O(n), but I don't really see why that should be true
13:26:05 <wojtekM_> mauke: I was importing selectively
13:26:12 <intrados> Is possible to place a constraint on a type family instance? Like `type instance (Show a, Show b) => Foo (a, b) = String`
13:26:34 <johnw> intrados: what does that mean?
13:26:49 <mauke> import Data.Time (getCurrentTime)  -- selectively :-)
13:27:09 <wojtekM_> mauke: I was importing Data.Time.Clock
13:27:17 <mauke> that just leads to tears
13:27:46 <intrados> johnw: That Foo of (a, b) is String as long as a and b are showable
13:28:00 <mauke> rtpg: which part?
13:28:01 <johnw> oh, that and a and b are both String?
13:28:23 <wojtekM_> mauke: well, maybe not tears, but definitely some intimate acquaintance with the theory and practice of orphan instances
13:28:26 <johnw> String is itself Showable, so I still don't understand
13:28:47 <intrados> johnw: Not necessarily. a and b could be anything showable
13:28:49 <nomeata> johnw: this is a question about type families...
13:28:52 <cyrix> `catch` \error -> putStrLn "bye"  <- how to specify type of the exception?
13:28:53 <johnw> if you know that Show a and Show b, you can easily convert a and b to String
13:28:59 <wojtekM_> mauke: ...and cyclic dependencies
13:29:21 <johnw> ok, I just don't get it then, i'll stop guessing
13:29:22 <mauke> cyrix: what types of errors do you want to catch?
13:29:52 <nomeata> intrados: I don’t believe you can, and the problem is that type classes are open, so when would you know that this question is _not_ going to be applied?
13:29:55 <cyrix> ThreadKilled
13:30:45 <nomeata> intrados: but I’m not an expert with these parts of the type system
13:30:58 <mauke> cyrix: that sounds dangerous
13:31:02 <byorgey> intrados: no, that is not possible
13:31:06 <mauke> cyrix: why do you want to catch that?
13:31:27 <intrados> nomeata, byorgey: Ok, that's what I suspected. I just wanted to check. Thanks
13:31:49 <lightquake> programming in an ml-derivative language has really made me appreciate haskell's syntax more
13:31:56 <lightquake> i miss (.) and ($)
13:32:27 <frx> (.) and ($) are just functions
13:32:29 <cyrix> tell me first how to catch it :)
13:33:19 <mauke> cyrix: ... `catch` \e -> case e of ThreadKilled -> putStrLn "lol no"; _ -> throwIO e
13:33:22 <mauke> or something like that
13:33:52 <reizuki> byorgey: sure! I'll keep the comments piling up and send them later then :) by the way, I was wondering about a more elegant solution to one of the exercises and ended up posting the question on stack overflow ;-)
13:34:04 <lightquake> frx: right, but the fact that you can define functions with names like that is part of syntax
13:34:04 <reizuki> http://stackoverflow.com/questions/20459241/haskell-how-to-iterate-list-elements-in-reverse-order-in-an-elegant-way
13:34:23 <pavonia> intrados: It might work if you'd include that type family in a type class. But still not sure if that is a good idea anyway
13:34:26 <frx> lightquake true
13:35:16 <cyrix> mauke you need to specify type of the argument in lambda.. and I cant see how I would do that without making a named function
13:35:27 <monochrom> Q: how to iterate through a list in reverse order. A: don't use a list in the first place.
13:35:32 <mauke> cyrix: no, I don't
13:35:37 <cyrix> @sec catch
13:35:37 <lambdabot> catch m k = catchException m handler where handler (IOException err) = k err
13:35:50 <djahanda1ie> Does anyone know how to do regex-based substitution in Haskell using anything aside from subRegex (seems to have issues with unicode)?
13:35:53 <mauke> sec?
13:35:59 <cyrix> @hoogle catch
13:35:59 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
13:35:59 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
13:35:59 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
13:36:04 <djahanda1ie> All the other regex libraries don't seem to handle substitution.
13:36:07 <monochrom> sec is auto-corrected to src :)
13:36:09 <mauke> cyrix: did you even try my code?
13:36:50 <monochrom> cyrix: the pattern matching against ThreadKilled already nails the type
13:37:05 <monochrom> but yes, have you even tried before opinionating?
13:37:19 <cyrix> I did now.. did not expect it to work, but it did
13:37:34 <monochrom> expect nothing. observe. only observe.
13:37:53 <monochrom> use the scientific method, not the opinionative method.
13:38:28 <pavonia> djahanda1ie: Have you tried regex-compat-tdfa?
13:38:38 <cyrix> so throwIO part is useless?
13:38:42 <cyrix> or?
13:38:58 <djahanda1ie> pavonia, wow. How did I not find this myself.
13:39:04 <djahanda1ie> Will give it shot, looks very promising, thanks!!
13:39:06 <cyrix> if the type is ThreadKilled then it cant be anything else?
13:39:12 <mauke> cyrix: ThreadKilled is not a type
13:39:16 <johnw> text-icu has some regex code too, based on the ICU library
13:39:45 <cyrix> ah right
13:39:51 <mauke> cyrix: look at it this way: \e -> case e of True -> "A"; _ -> "B"
13:39:55 <mauke> what is the type of e?
13:40:05 <cyrix> got it
13:40:11 <Luke> I want to script some stuff around cabal from haskell: is there an API I should be using or should I just use System.Process?
13:40:42 <dcoutts_> Luke: depending on what you're doing, there's the Cabal library
13:41:03 <Luke> dcoutts_: clean; configure; build;
13:41:04 <johnw> Luke: I use Shake in those situations
13:41:13 <cyrix> I am still curious how to specify type in the lambda argument
13:41:25 <jle`> i think you need an extension for that
13:41:29 <Luke> johnw: oh I'm not familiar with Shake- I'll take a look. Thank
13:41:52 <mauke> cyrix: you don't necessarily have to do it in the argument
13:41:55 <jle`> Luke: Shake is good for managing tasks and dependencies
13:41:57 <mauke> well, parameter
13:42:07 <jle`> if you want stronger scripting commands/tools then you can itnegrate it with Shelly
13:42:33 <jle`> which has tools for the scripts themselves
13:42:39 <jle`> but usually it is overkill
13:42:40 <mauke> \e -> flip const (e :: Whatever) ...
13:42:47 <jle`> shelly is mostly for type-safe scripts
13:42:57 <johnw> also, Shake doesn't use system-filepath, which Shelly depends on
13:43:03 <johnw> so using the two together is... onerous sometimes
13:43:07 <jle`> johnw: oh i wans't aware
13:43:14 <jle`> that's a shame
13:43:24 <joejev> I was told that hackage would add the module docs for a package candidate after about 8 hours; however, my package still has no module docs after almost 20, when I generated haddock docs locally things worked fine. Is there something special I need to do that I am missing?
13:43:25 <johnw> and Shelly is fully Text-based, while Shake uses String mostly
13:43:31 <johnw> yeah, it's a bit impedance mismatch
13:43:33 <jle`> i mostly just use Shake but i always thought i could just toss on Shelly
13:43:38 <johnw> me too
13:43:45 <johnw> actually, I suggested it on the shake mailing list
13:43:51 <johnw> and I know Greg has mentioned it to Neil before too
13:44:13 <jle`> i feel like scripting languages aren't really a case where String's performance is a big concern
13:44:15 <jle`> er
13:44:15 <johnw> neither objects, somebody just need to step up and write what would likely be a Shake module for Shelly
13:44:16 <jle`> scripting
13:44:33 <jle`> scripting contexts
13:44:37 <johnw> jle`: true, except for processing pipelines maybe?
13:44:49 <jle`> perhaps
13:44:49 <johnw> but in that case, one can use conduit and bytestrings
13:44:53 <Luke> I don't know if I need a build system just to do a clean call to build with cabal do I?
13:45:01 <dcoutts_> joejev: building docs for candidates is not working at the moment, sorry.
13:45:05 <johnw> Luke: I'd use Shelly then
13:45:09 <johnw> run "cabal" ["clean"]
13:45:12 <Luke> thanks
13:45:14 <Luke> yeah
13:45:24 <Luke> I want to do release scripting and stuff to
13:45:27 <jle`> yeah Shake is basically like a Haskell Make
13:45:28 <Luke> packaging w/ gzip etc
13:45:31 <jle`> or Rake
13:45:32 <joejev> dcoutts_: is there a way to provide the docs ahead of time?
13:45:35 <jle`> if you have ever used Make or Rake
13:45:41 <jle`> its power is in its dependency/task management
13:45:43 <Luke> I've used make,not rake
13:45:52 <joejev> dcoutts_: otherwise, is it safe to just upload it and then assume they will be built later?
13:45:56 <Luke> doesn't cabal handle my reps though?
13:45:58 <Luke> deps*
13:46:03 <jle`> Luke: yes it does
13:46:09 <jle`> Shake would be for custom builds
13:46:16 <jle`> maybe even in non-haskell contexts
13:46:17 <Luke> custome?
13:46:23 <Luke> custom*
13:46:25 <jle`> i used shake to render my papers
13:46:36 <Luke> oh like a build system to build anything, not just haskell
13:46:37 <Luke> i see
13:46:38 <benzrf> hi, when i try to `import Control.Monad.Writer' I get:
13:46:38 <benzrf>     Ambiguous module name `Control.Monad.Writer':
13:46:38 <benzrf>       it was found in multiple packages: monads-tf-0.1.0.1 mtl-2.1.2
13:46:39 <jle`> yeah
13:46:47 <Luke> so maybe I do want a task manager
13:46:52 <benzrf> Luke: nice nick
13:46:54 <dcoutts_> joejev: I'm not absolutely sure that docs get carried over properly yet. The candidates feature is nearly but not totally complete tbh.
13:46:58 <Luke> i basically want targets: build, package, ssh-release etc
13:47:06 <Luke> benzrf: ? it's my name
13:47:16 <benzrf> Luke: well im impressed it wasnt taken
13:47:24 <Luke> well it wasn't 10 years ago =)
13:47:26 <jle`> yes you probably would want to use a task manager/dependency manager of some sort then.  by dependency i mean file modification dependencies, not cabal deps of course
13:47:29 <joejev> dcoutts_: but if I upload it as a normal package, will it be okay?
13:47:30 <benzrf> Luke: my pont
13:47:30 <benzrf> :p
13:47:33 <Luke> ha gotcha
13:47:40 <benzrf> *point
13:47:41 <dcoutts_> joejev: yes, or publish the candidate.
13:47:45 <jle`> file modification and task dependencies
13:47:48 <jle`> same as Make
13:47:51 <jle`> just...you use Haskell
13:48:01 <jle`> Rake is the same philosophy, it's just Make but it's an embedded DSL in ruby.
13:48:14 <Luke> so I probably do want Shake
13:48:17 <jle`> Hake is an embedded dsl for task deps and stuff in Haskell
13:48:30 <Luke> how does shake compare to hake?
13:48:38 <jle`> i don't believe hake is maintained at the moment
13:48:55 <jle`> also shake is by neil mitchell of hoogle fame
13:48:55 <joejev> dcoutts_: I have a couple changes since I published that, just docs, so can I edit the candidate, and then publish, or should I just delete it and publish a new one?
13:49:32 <johnw> Luke: once you get used to Shake, you'll find it's pretty dead simple
13:49:39 <johnw> and what's nice is that it's FAST
13:49:53 <dcoutts_> joejev: I believe you can just upload a new tarball for the same version with a candidate, indeed that is kind of the point.
13:50:01 <jle`> also i am a small contributor so i feel special when i use shake
13:50:13 <jle`> (my only contribution is an infix alias, but it makes me happy)
13:50:17 <joejev> dcoutts_: thanks
13:50:17 <johnw> Luke: here's the Shake script I'm using with Cabal: https://gist.github.com/7864189
13:50:23 <cyrix> .
13:50:55 <johnw> all my script does is move things into place for Cabal
13:50:59 <johnw> and run a header file generator
13:52:33 <Luke> johnw: thanks
13:52:36 <Luke> jle`: thanks a lot
13:53:01 <cyrix> I have seen finally used like this but it doesnt work unless I put parenthesis around forever. why? http://lpaste.net/96760
13:53:21 <johnw> cyrix: because the binding for $ is so low
13:53:57 <johnw> it's associating finally with your do block
13:54:07 <cyrix> yeah I see
13:54:16 <Luke> johnw: so basically using shake to run cabal, then run tar, then ssh would be an OK set of tasks for it?
13:54:25 <johnw> Luke: sure!
13:54:26 <cyrix> so how to write this idiomatically? just use parens?
13:54:30 <Luke> cool - thanks
13:54:47 <jle`> Luke: i wrote a small exposition on basic shake as well as my sample typical build-a-paper script
13:54:49 <jle`> http://blog.jle.im/entry/id/2#completed-file
13:54:57 <johnw> forever (print id >> threadDelay 1000000) `finally` putStrLn "lol bye"
13:55:01 <Luke> jle`: wow thanks a lot
13:55:08 <johnw> or move the do block into a "where" definition
13:55:09 <jle`> it's admittedly very basic
13:55:22 <jle`> but it basically explains how to re-implement almost everything in Make
13:55:29 <Luke> wow this is extensive
13:55:38 <Luke> more than enough for what I need
13:56:35 <cyrix> heh, adding do before forever makes it work too
13:56:40 <jle`> no problem
13:56:43 <jle`> :)
13:57:00 <cyrix> quite easy to miss it, or remove it later, so I am not sure it is a good style
14:02:59 <Luke> johnw: jle`: good call w/ shake. this is exactly what i was looking for!
14:03:21 <Luke> people always compare it with rake which I'm not familiar with so I never knew what it really was
14:03:24 <johnw> Luke: nice!
14:03:51 <Luke> johnw: btw regarding your chicago presentation, I'm just waiting for the holidays to wind down then I'll put something together
14:04:19 <johnw> k, just let me know
14:04:23 <Luke> will do
14:05:08 <Luke> johnw: were you at the hackathon?
14:05:23 <johnw> I sure was
14:05:25 <seeg> hello
14:05:34 <Luke> johnw: oh did we talk?
14:05:36 <johnw> mostly played with Agda with Isaac
14:05:41 <seeg> I have a problem with Happstack & AcidState: http://lpaste.net/1864639740658057216
14:05:46 <johnw> I don't know! haha
14:05:49 <Luke> ah dang I don't know if we met then =)
14:05:55 <Luke> sorry about that!
14:05:59 <johnw> it's hard to think I didn't even say hello, but it could have happened
14:06:11 <seeg> The query function works correctly, but 'update' requires a different type for acid parameter, I have no clue why :)
14:08:17 <benzrf> <no location info>:
14:08:17 <benzrf>     Ambiguous module name `Control.Monad.Writer.Class':
14:08:17 <benzrf>       it was found in multiple packages: monads-tf-0.1.0.1 mtl-2.1.2
14:08:20 <benzrf> what do
14:09:03 <jle`> are you sandboxing?
14:09:41 <jle`> when something like this happens i just nuke my entire .cabal heh.
14:09:55 <jle`> ~/.cabal
14:10:01 <jle`> because trying to fix it always leads to more trouble for me..
14:10:09 <benzrf> idk
14:10:12 <joneshf-laptop> seeg, is your type right?
14:10:27 <seeg> It's supposed to be the same for both query and update
14:10:30 <jle`> if you are building a package you should be using cabal sandbox
14:10:36 <dcoutts_> benzrf: you can ghc-pkg hide monads-tf-0.1.0.1
14:10:41 <seeg> at least this says so: http://happstack.com/docs/crashcourse/index.html#acid-state
14:10:59 <benzrf> thanks man
14:11:12 <seeg> And it's not right, since I'm getting the error, but have no clue why it's different for query than update :)
14:11:13 <dcoutts_> benzrf: or use cabal to build, e.g. make a .cabal file using cabal init
14:11:23 <benzrf> it worked =D
14:11:26 <benzrf> ttyl
14:12:17 <ReinH> ocharles: I think you've got an extra comma in your first main code example in http://ocharles.org.uk/blog/posts/2013-12-06-24-days-of-hackage-persistent-esqueleto.html
14:13:54 <seeg> i've no clue where this EventState came from :)
14:14:29 <cyrix> what is the best way of making sure that output isnt mixed up when doing parallel calls to print?
14:14:45 * hackagebot cabal-constraints 0.0.0.1 - Repeatable builds for cabalized Haskell projects.  http://hackage.haskell.org/package/cabal-constraints-0.0.0.1 (BenArmston)
14:15:15 <johnw> it is possible to losslessly convert a Data.Time.UTCTime to a Data.Thyme.UTCTime?
14:16:00 <benmachine> johnw: pedantically, I don't think so – thyme is not as expressive as time
14:16:04 <benmachine> practically, probably?
14:16:16 * benmachine has a look at thyme
14:16:26 <johnw> alternatively, can I convert a Data.Time.UTCTime into an Integer number of micro, nano or picoseconds?
14:16:36 <benmachine> the lack of expressiveness only comes into play millenia from now, I think
14:16:42 <benmachine> oh, the answer to that is almost certainly yes
14:16:48 <joneshf-laptop> seeg, it's in the type http://hackage.haskell.org/package/acid-state-0.12.1/docs/Data-Acid-Advanced.html
14:16:50 <johnw> or do I need to format "%q" and then read :: String -> Integer?
14:16:59 <benmachine> (although if you care about seconds precisely then expect pain)
14:17:15 <dcoutts_> johnw: you can convert to picosec
14:17:18 <johnw> how?
14:17:26 <benmachine> johnw: possibly realToFrac?
14:17:53 <seeg> joneshf-laptop, but it's in the type of query and works correctly
14:17:54 <dcoutts_> johnw: one of the types it uses is an alias for Fixed Pico
14:17:57 <benmachine> yeah, toRational works on DiffTime
14:18:11 <seeg> and the examples say it works the same for query as for update, i.e. type of the 'acid' parameter is the same
14:19:46 <benmachine> seeg: EventState is possibly a type function?
14:20:03 <johnw> what I need is effectively: read (Data.Time.formatTime defaultTimeLocale "%s%q" now) :: Integer
14:20:07 <joneshf-laptop> seeg, I dunno, my strategy is usually to remove the annotation and see what it figures out for itself
14:20:11 <johnw> so, I have a UTCTime, not a DiffTime
14:20:18 <johnw> and I need the day component to be part of the final value
14:20:24 <seeg> ah, shit, found it :)
14:20:37 <seeg> it's not TA.insertPerson but TA.InsertPerson :)
14:20:38 <benmachine> johnw: well, multiply it by whatever and add it :P
14:20:48 <johnw> ok
14:20:50 <seeg> the InsertPerson is template haskell's magic type infered from insertPerson function
14:21:08 <seeg> joneshf-laptop, thanks :)
14:21:44 <joneshf-laptop> seeg, glad you got it
14:22:35 <benmachine> johnw: alternatively, get a NominalDiffTime to some fixed endpoint
14:22:47 <jemendja> hi
14:22:52 <jle`> hi jemendja
14:24:39 <skypers> hi
14:25:00 <skypers> how do you make something deprecated in haddock doc?
14:25:10 <johnw>     toPicoSeconds t = let x = toRational (toModifiedJulianDay (utctDay t))
14:25:11 <johnw>                             + toRational (utctDayTime t) in x * (10^12)
14:25:31 <johnw> oh, and slap a numerator on that
14:26:43 <skypers> woooh
14:26:49 <skypers> I’m compiling darcs through cabal-install
14:26:55 <skypers> it’s full of warnings!
14:28:10 <lispy> skypers: every version of ghc changes the warnings
14:28:33 <lispy> skypers: so even if they get rid of all the warnings before a release, if you use a newer ghc later you may still see a bunch
14:29:22 <skypers> that makes sense because they have 6-months sprints
14:29:34 <joejev> is there a standard library function that is like (fromIntegral a) / (fromIntegral b)
14:29:49 <skypers> huh, mod?
14:29:53 <skypers> div*
14:29:56 <skypers> :t div
14:29:57 <lambdabot> Integral a => a -> a -> a
14:30:09 <merijn> > 4 `div` 2
14:30:10 <lambdabot>   2
14:30:15 <merijn> > 6 `div` 2
14:30:16 <lambdabot>   3
14:30:42 <skypers> oh, you want something fractional?
14:30:47 <joejev> yes
14:30:56 <benmachine> there is not a standard library function for that
14:31:02 <joejev> okay, thanks
14:31:09 <skypers> well it would be actually weird
14:31:33 <skypers> either you want an euclidian div
14:31:35 <skypers> then you use div
14:31:45 <skypers> otherwise you want a fractionnal one, then you use (/)
14:32:00 <joejev> well, / takes fractional a, so neither of those really do what I want
14:32:02 <skypers> want you want is a cast-then-(/)
14:32:20 <skypers> just write that function then :)
14:32:29 <joejev> I did, I just wanted to know
14:32:39 <Kron> gah
14:32:49 <joejev> because if it existed, people would wonder why I rewrote it, no?
14:32:49 <Kron> I'm reading so many tutorials on lensing and I still don't have a clue as to how to use them
14:32:52 <Kron> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/basic-lensing
14:33:04 <Kron> in this entire tutorial, there wasn't a single example of how to actually get or set any data with a lens
14:33:19 <Kron> I'm still trying to tease out an integer from a simple data type via a lens in GHCi and totally failing
14:33:49 <Kron> if I have a type with a "_value" record field, how do I read the data using the 'value' lens?
14:33:58 <Iceland_jack> > view _1 (1, 2) -- Kron :)
14:33:59 <skypers> > (2,4) & _1 .~ 5
14:34:00 <lambdabot>   1
14:34:01 <lambdabot>   (5,4)
14:34:08 <edwardk> > ("hello","world")^._2
14:34:08 <edwardk> > ("hello","world") & _2 .~ 4
14:34:08 <edwardk> foo^.value
14:34:09 <lambdabot>   can't find file: L.hs
14:34:10 <lambdabot>   "world"
14:34:23 <Kron> neither work
14:34:25 <Kron> I get type errors
14:34:34 <skypers> 23:25 < Kron> if I have a type with a "_value" record field, how do I read the data using the 'value' lens?
14:34:41 <edwardk> show me the type
14:34:43 <skypers> you have to make the lenses first
14:34:48 <skypers> with TH function
14:34:56 <Kron> data QuadTree a = Leaf { _value :: a }
14:34:58 <Kron> and yes, I did
14:35:01 <edwardk> and did you use makeLenses?
14:35:11 <Kron> ghci> :t value
14:35:11 <Kron> value
14:35:11 <Kron>   :: Control.Applicative.Applicative f =>
14:35:11 <Kron>      (a0 -> f a0) -> QuadTree a0 -> f (QuadTree a0)
14:35:13 <ReinH> Kron: what error do you get?
14:35:17 <Kron> I used makeLenses, yes
14:35:19 <benmachine> aha
14:35:19 <edwardk> Kron: are there any other constructors that lack value?
14:35:26 <Kron> yes
14:35:28 <edwardk> Kron: you only have a traversal then
14:35:35 <Kron> there's a Node constructor
14:35:37 <edwardk> so you can use foo^?value
14:35:37 <Kron> ah
14:35:41 <benmachine> you can't have a valid lens if there might not be a value
14:35:43 <edwardk> but it'll give you Maybe
14:35:49 <Kron> ooooh
14:35:50 <Kron> ghci> x^?value
14:35:51 <Kron> Just 1
14:35:52 <benmachine> because if you set a lens and then get it, you're supposed to get the thing you set
14:35:53 <Kron> that's... fascinating
14:35:54 <Kron> okay
14:36:01 <benmachine> but you can't if there isn't one
14:36:01 <Kron> so now I need to learn about traversals
14:36:14 <skypers> there’re some functions I think they’re weird, like _folded
14:36:16 <skypers> _traversed
14:36:16 <edwardk> if you want to assert that it really must be a Leaf then you can use foo^?!value
14:36:41 <Kron> okay the operators are getting sillier and sillier :P
14:36:48 <skypers> ahah
14:37:04 <Kron> > foo (>^.^)> value
14:37:05 <lambdabot>   Not in scope: `>^.^'Not in scope: `value'
14:37:14 <skypers> edwardk: what is <~?
14:37:17 <skypers> :t (<~)
14:37:18 <lambdabot> MonadState s m => ASetter s s a b -> m b -> m ()
14:37:24 <edwardk> ^? asks a question. its punctuation similar to ^?   -- ^?! is you asserting something that should make you uncomfortable. it is designed to make you ask ^?!
14:37:26 <skypers> oh
14:37:28 <skypers> it’s a put?
14:37:53 <edwardk> er similar to ^.
14:38:52 <Kron> where can I learn about traversals, and what are prisms?
14:39:06 <Philonous> edwardk, I wonder, how do you arrive at the definitions of your structures? For example, how did you determine how to define prisms? Did you derive them somehow or did you just stare at them until you saw the solution?
14:39:20 <edwardk>  traversal is just a lens with 0 or more targets instead of exactly one
14:39:20 <Peaker> Kron: there are edwardk's talks about lens, and the lens docs/wiki, or I could explain here if you want
14:39:37 <Peaker> (or edwardk could explain, apparently :-) )
14:39:57 <edwardk> Philonous: i came up with a hack, rwbarton came up with a set of laws dual to those of a lens, we gradually converged to the same thing
14:40:20 <edwardk> Peaker: not going to be around long today, so perhaps its best if i don't get dragged too far in =)
14:40:27 <Kron> hmmm
14:40:31 <Kron> then I'd love some more links
14:40:33 <Philonous> edwardk, Ah ok, thanks
14:40:34 <Kron> to more docs, I guess
14:40:37 <edwardk> > [1,2,3,4] & traversed +~ 1
14:40:38 <lambdabot>   [2,3,4,5]
14:40:46 <Kron> a lot of these tutorials don't quite tell me how to use stuff in a codeable manner
14:40:55 <Kron> they just tell me "lenses exist and they're cool and here's their basic nature"
14:41:02 <edwardk> Kron: did you see tekmo's tutorial?
14:41:04 <skypers> god
14:41:07 <skypers> that sounds so weird
14:41:11 <Kron> not... sure
14:41:16 <Kron> is that the one that used filtered
14:41:17 <skypers> :t traversed
14:41:18 <lambdabot> (Applicative f1, Traversable f, Indexable Int p) => p a (f1 b) -> f a -> f1 (f b)
14:41:20 <Peaker> Kron: you can follow http://lens.github.io/  and Tekmo's tutorial is at http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
14:41:20 <Kron> and everyone freaked out?
14:41:32 <Kron> okay
14:41:35 <Peaker> Kron: yeah, it used filtered. didn't see much freaking out :)
14:42:03 <edwardk> i need to update lens.github.io with about 8 months of lens news =)
14:42:05 <Kron> someone said PHP in the reddit thread!
14:42:09 <Kron> mentioning the P-word = freaking out to me
14:42:15 <edwardk> Kron: yeah it did
14:42:25 <skypers> edwardk: what is traversed for?
14:42:26 <skypers> I mean
14:42:31 <Peaker> Kron: in short,  the "Functor f" from lens's "Functor f => (a -> f b) -> (s -> f t)"   becomes an "Applicative f", and you've got a traversal instead of a lens
14:42:37 <edwardk> skypers: it gives you the index as you go.
14:42:40 <skypers> > fmap (+1) [1..4]
14:42:41 <lambdabot>   [2,3,4,5]
14:42:52 <Kron> I'll be frank, applicative functors stretch the boundaries of my mindspace already
14:42:52 <edwardk> > ["hello","world"]^..traverse.traversed
14:42:54 <lambdabot>   "helloworld"
14:43:00 <edwardk> > ["hello","world"]^..traversed<.>traversed
14:43:01 <skypers> ^.. ?
14:43:01 <lambdabot>   "helloworld"
14:43:06 <Peaker> ^@.. ?
14:43:07 <skypers> omg
14:43:08 <edwardk> > ["hello","world"]^@..traversed<.>traversed
14:43:09 <lambdabot>   [((0,0),'h'),((0,1),'e'),((0,2),'l'),((0,3),'l'),((0,4),'o'),((1,0),'w'),((...
14:43:19 <skypers> sometimes
14:43:21 <skypers> I just
14:43:22 <skypers> huh
14:43:24 <Kron> a snail operator?
14:43:28 <Kron> there's a snail operator?
14:43:28 <Peaker> > ["hello", "world"] ^@.. traversed <. traversed
14:43:30 <lambdabot>   [(0,'h'),(0,'e'),(0,'l'),(0,'l'),(0,'o'),(1,'w'),(1,'o'),(1,'r'),(1,'l'),(1...
14:43:31 <Kron> I thought my gf was joking
14:43:36 <edwardk> > ["hello","world"]^@..traversed.traversed
14:43:36 <edwardk> > ["hello","world"]^@..traversed.traversed
14:43:37 <lambdabot>   can't find file: L.hs
14:43:38 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(0,'w'),(1,'o'),(2,'r'),(3,'l'),(4...
14:43:56 <edwardk> @ 'attaches the index to the answers given' by ^. ^.. ^? etc.
14:44:04 <Kron> man
14:44:07 <Kron> this is like... format
14:44:09 <Peaker> Kron: The lens operators use a memorable composition of characters so you only need to remember what some characters/compositions mean and you know almost all operators
14:44:09 <Kron> format strings
14:44:15 <skypers> no
14:44:19 <skypers> it’s like hebrew
14:44:19 <Kron> interesting
14:44:21 <Peaker> Kron: "@" in the middle of an operator makes it be the "indexed" version
14:44:31 <skypers> or egyptian glyphs to me
14:44:37 <Peaker> Kron: The operators starting with "^" are the accessor ones to read from a lens/traversal/etc
14:44:51 <skypers> zip [0..] (concat ["Hello","World"])
14:44:52 <edwardk> folks have started naming some of them though, yes. ^@.. for snail   <<>~ for rat, etc.
14:44:57 <skypers> > zip [0..] (concat ["Hello","World"])
14:44:57 <Peaker> Kron: The operators ending with = are State actions, like:  someLens += 3    or someLens *= 4
14:44:58 <lambdabot>   [(0,'H'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,'W'),(6,'o'),(7,'r'),(8,'l'),(9...
14:45:02 <Kron> what is the difference between a traversal and a prism, and should I know what an iso is or just leave that to deep magics?
14:45:09 <edwardk> skypers: now write back to that
14:45:12 <merijn> Pipes is really neat, but requires as much brain bending for me as lens does >.>
14:45:38 <skypers> back to what?
14:45:42 <edwardk> skypers: also notice the simple . composed one restarted the count
14:45:49 <edwardk> back to the zipped version
14:45:59 <skypers> I actually understand the zipped version
14:46:10 <Peaker> Kron: a Prism is like a data constructor in a type sum. You can use it to try to extract 0 or 1 contained fields (0-or-1 traversal) and you can use it to construct a value
14:46:17 <edwardk> > ["hello","world"] & traverse.traverse .~ 1
14:46:18 <lambdabot>   [[1,1,1,1,1],[1,1,1,1,1]]
14:46:19 <skypers> yours is so… well, it’s like BD characters saying bad words
14:46:20 <Peaker> > Right 5 ^? _Right
14:46:21 <lambdabot>   Just 5
14:46:24 <Peaker> > Left 5 ^? _Right
14:46:26 <lambdabot>   Nothing
14:46:31 <Peaker> > _Right # 5
14:46:33 <lambdabot>   Right 5
14:46:33 <skypers> [1..4] & ^!?@#^$
14:46:36 <skypers> :D
14:46:44 <Peaker> Kron: So _Right represents the "Right" data constructor of Either
14:46:47 <skypers> edwardk:
14:46:53 <Peaker> Kron: you can use it to extract the value from a right or to construct a right
14:46:57 <Kron> ok
14:47:00 <Peaker> Kron: and like all lenses it composes properly with everything else
14:47:10 <ij> :t iterateM_
14:47:11 <lambdabot>     Not in scope: `iterateM_'
14:47:11 <lambdabot>     Perhaps you meant one of these:
14:47:11 <lambdabot>       `iterate' (imported from Data.List),
14:47:21 <skypers> > fmap (fmap (<$) 1) ["Hello","world"]
14:47:22 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable1 f0)
14:47:22 <lambdabot>    arising from a use...
14:47:25 <Peaker> > (1, Right (Just (3, 2))) & _2 . _Right . _Just . _2 +~ 1
14:47:26 <lambdabot>   (1,Right (Just (3,3)))
14:47:30 <skypers> > fmap (fmap ((<$) 1)) ["Hello","world"]
14:47:31 <lambdabot>   Couldn't match type `GHC.Types.Char' with `f0 b0'
14:47:32 <lambdabot>  Expected type: [f0 b0]
14:47:32 <lambdabot>  ...
14:47:34 <skypers> damn
14:47:38 <edwardk> there are prefix versions of all of these that matter
14:48:13 <bx> \msg lambdabot Hi
14:48:14 <Kron> hmmmm
14:48:14 <Peaker> I actually like TIOOWTDI, so prefer to use the operators/sections for everything and not remember the extra prefix names
14:48:20 <skypers> > fmap ((<$) 1) ["Hello","world"]
14:48:21 <lambdabot>   [[1,1,1,1,1],[1,1,1,1,1]]
14:48:37 <edwardk> skypers: the main thing i was getting at is that it is easy to turn this sort of traversal around. you 'do the construction once'
14:48:55 <skypers> yeah, but it’s so obscure to me
14:49:16 <skypers> I think your lens package is one of the hardest to understand
14:49:18 <Peaker> Kron: the nice thing about the lens-lib representation of lenses is that the type-class constraints unify correctly to form the most permissive composition still possible. so when you compose a lens and a prism, for example, you get a traversal
14:49:36 <edwardk> > ["hello","world"] & traversed<.>traversed %@~ \(i,j) v -> (i,j,v)
14:49:37 <lambdabot>   [[(0,0,'h'),(0,1,'e'),(0,2,'l'),(0,3,'l'),(0,4,'o')],[(1,0,'w'),(1,1,'o'),(...
14:49:40 <Peaker> skypers: the trick is *not* to start by reading the types, like you would read other libraries :)
14:49:46 <Kron> I don't understand what all that meant, so I'm going to not slowly now.
14:49:48 * Kron nods sagely
14:49:52 <skypers> Peaker: I read operators
14:49:54 <Kron> *nod
14:49:55 <Peaker> Kron: in the last sentence, or before?
14:49:59 <skypers> I understand the logic
14:50:00 <Kron> your last sentence
14:50:01 <skypers> but hm
14:50:12 <skypers> the shit with traversed, folded, and all of that…
14:50:19 <Peaker> Kron: ah, did you read about/understand the bit about encoding a lens like:   Functor f => (a -> f b) -> (s -> f t) ?
14:50:33 <edwardk> ignore the indices until you need them, when you do you'll be happy they are there
14:50:34 <Peaker> Kron: that's a tricky thing, which has some incredibly useful consequences
14:50:43 <Kron> yes, but while my brain vaguely understands what a functor is I can't quite wrap my mind around all that simultaneously
14:50:48 <Kron> I can still barely process (f .) . g as is
14:50:59 <Peaker> Kron: the SPJ talk about lenses is pretty nice
14:51:00 <skypers> edwardk: exactly
14:51:03 <Peaker> Kron: I think it takes it rather slow
14:51:09 <skypers> and the thing is
14:51:12 <Kron> then I'll listen to this talk
14:51:14 <skypers> I rarely need lens
14:51:14 <bitemyapp> Peaker: better than edwardk's?
14:51:25 <skypers> sometimes I use the .~, or %~
14:51:27 <Peaker> bitemyapp: I think it's more beginner-friendly, and has a much narrower scope
14:51:28 <skypers> but that’s all
14:51:31 <bitemyapp> edwardk's talk seemed a bit dense to me.
14:51:36 <bitemyapp> Peaker: so that makes sense, thanks.
14:51:45 <Kron> skypers: I kinda want to learn. I want to learn to do write the best haskell possible in the most expressive way
14:51:48 <edwardk> SPJ is more concerned with getting the basics across. my talk is more concerned with getting to something interesting
14:51:56 <Peaker> bitemyapp: he only describes Lens with that tricky representation.. he doesn't explain the advanced stuff you get to on top of that
14:51:59 <skypers> I think lens is not mandatory for that
14:52:02 <edwardk> mine is really a 3 hour talk smashed in a 2 hour timeslot
14:52:07 <Kron> I'd like the basics of traversals then
14:52:16 <edwardk> :t traverse
14:52:17 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
14:52:21 <edwardk> :t traverse.traverse
14:52:21 <skypers> what is mandatory is all the Base stuff
14:52:22 <lambdabot> (Applicative f, Traversable t, Traversable t1) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
14:52:23 <skypers> mtl one
14:52:26 <skypers> containers
14:52:28 <skypers> and so on
14:52:46 <edwardk> traverse is the 'prototypical' traversal.
14:52:55 <Peaker> (which predates the lens library, of course)
14:52:55 <skypers> I think you can still write great code without using any lens
14:52:55 <edwardk> once you understand that you have a pretty good feel for them
14:53:14 <Peaker> skypers: of course, but some of the tedious unpacking/packing bits in lots of Haskell code disappear nicely with lens
14:53:25 <skypers> nicely?
14:53:32 <skypers> sure lens is a nice library
14:53:33 <skypers> but hm
14:53:39 <edwardk> i could, but i've decided i no longer want to ;)
14:53:45 <Peaker> skypers: Yes.  5 lines of code replaced by (foo ^@.. traversed <. traverse)  <-- I like this :)
14:53:49 <Kron> units.traversed.health is pretty expressive
14:53:50 <skypers> all that bunch of operators always makes me sick
14:54:02 <simpson> Not to mention that you can craft new lenses.
14:54:05 <Kron> I don't quite like all the operators myself
14:54:09 <Peaker> skypers: well, they're not just random noise, they're composed from characters which have consistent meanings across almost all of them
14:54:13 <edwardk> skypers: then don't use them. in lens 4 you'll be able to import it sans operators.
14:54:22 <Kron> but being able to say "bossHP = boss . health" seems like a great thing to learn
14:54:37 <skypers> Kron: and the trick is
14:54:40 <skypers> you can already do that
14:54:43 <skypers> without lens.
14:54:49 <simpson> units.npcs.animation.time.modded += seconds
14:54:55 <edwardk> skypers: whch works right until you want to edit it
14:55:04 <skypers> well
14:55:14 <skypers> I have to use let in and the record {} syntax
14:55:15 <skypers> yes
14:55:19 <skypers> it’s pretty annoying
14:55:27 <simpson> Also, filtered is awesome.
14:55:34 <Peaker> skypers: you can write traversals/etc without the lens library, but will you instantiate them with Const to use them as getters? Will you rewrite everything tediously when you need the index?
14:55:34 <skypers> my gosh.
14:55:36 <Kron> is it okay to use filtered?
14:55:43 <Kron> something something filtered is not a true theoretic traversal?
14:55:45 <edwardk> which requires you to write O(n^2) names to edit n levels deep
14:55:45 <simpson> Use at your own risk, but yes.
14:55:50 <mangaba_leitosa> '^@..' and '<.' make me think of the J language :-)
14:55:53 <bitemyapp> haskell tutorials should probably mention {: :} for use in GHCi upfront, it just confused the crap out of my friend who is learning Haskell next to me.
14:56:03 <ij> Should I ever use 'x >>= return . puref' instead of 'fmap puref x'?
14:56:24 <Kron> bitemyapp: tell him to bite your app
14:56:34 <edwardk> Kron: filtered is nominally only going to give you a fold per the laws, it gives you a traversal that breaks the laws if you aren't careful to make sure to replace the thing that matched the predicate with something _else_ that matches the predicate
14:56:42 <merijn> bitemyapp: Personally I tend to recommend newcomers to code in an editor instead and use :l/:r
14:57:05 <Kron> emacs + C-x C-l is how I do it
14:57:07 <edwardk> this is not _really_ a problem in practice, but it means that you need to view any traversal that includes filtered with suspicion, and reason about 'fusion' around them very carefully
14:57:08 <nooodl> ij: i think the former sometimes looks better in do-notation, but i don't know why you'd write it with the >>= instead of just using fmap (or <$>)
14:57:09 <skypers> :t filtered
14:57:10 <lambdabot> (Applicative f, Choice p) => (a -> Bool) -> Overloaded' p f a a
14:57:12 <Kron> that's literally the only haskell mode command I know
14:57:13 <skypers> oh god :(
14:57:34 <Peaker> skypers: the same argument against lens is usable against Haskell itself.  All that learning curve for a benefit that's hard to appreciate before the learning curve? why?
14:57:35 <edwardk> > [1..10]^.traverse.filtered even
14:57:36 <lambdabot>   No instance for (Data.Monoid.Monoid a0)
14:57:36 <lambdabot>    arising from a use of `e_1110'
14:57:36 <lambdabot>  ...
14:57:38 <bitemyapp> merijn: I would tend to agree, but he was following "learnxinyminutes" to catch up before we do a coding session and just wanted to use ghci.
14:57:41 <edwardk> > [1..10]^..traverse.filtered even
14:57:42 <lambdabot>   [2,4,6,8,10]
14:57:56 <edwardk> > [[1..5],[6..10]]^..traverse.traverse.filtered even
14:57:58 <lambdabot>   [2,4,6,8,10]
14:57:58 <skypers> Peaker: I think we reach the limit of expressivness here
14:58:08 <Peaker> skypers: What do you mean by "limit of expressiveness"?
14:58:10 <edwardk> funny, its just getting started for me =)
14:58:25 <ij> Should I fmap or <$>?
14:58:30 <edwardk> i want to encode delta lenses next
14:58:31 <bitemyapp> can I override a binding (mutate) in Hint in a running Haskell process?
14:58:35 <skypers> ij: <$> for Applicative stuff
14:58:37 <skypers> Peaker: well
14:58:39 <bitemyapp> I basically want to patch code at runtime.
14:58:46 <Peaker> skypers: lens gives you a set of tools applicable in a very very wide set of situations (A medium-sized Haskell project of mine uses lens everywhere to cut down on tedious code)
14:58:56 <edwardk> ij: depends on the surrounding context. if i can do it without sectioning i tend to use (<$>)
14:59:01 <skypers> if the way you express things is too expressive, you have to many tools
14:59:04 <skypers> too many ways
14:59:09 <Peaker> skypers: It takes a bit of an effort to learn, but anyone who could go through Haskell's learning difficulties can learn lens in reasonable time
14:59:17 <skypers> C is a good language because you have a few tools
14:59:20 <bitemyapp> skypers: anytime you have multi-field or nested data and need to express steps of queries/changes to that data and don't want to repeat yourself, lenses will often be applicable.
14:59:21 <ij> edwardk, Sectioning?
14:59:28 <Kron> y'know
14:59:32 <skypers> Haskell is a good language because it’s really simple by design
14:59:35 <Kron> I used to feel that 'fold' was a too many tools thing
14:59:36 <Kron> a long time ago
14:59:43 <Kron> who needs folding and mapping and filtering?
14:59:44 <skypers> and I think lens makes it really hard to understand
14:59:48 <Kron> just write the recursive function
14:59:54 <skypers> it turns the IT code into a Math code
14:59:58 <bitemyapp> nevermind, I guess you use hotswap for that.
15:00:04 <Peaker> skypers: Haskell has already a bazillion ways to do anything. I agree TIOOWTDI is nice, and orthogonality is a good guiding principle.  But dumping lens because we already had tedious ways of doing the same things is not a good idea
15:00:07 <simpson> skypers: You do realize that lens doesn't extend the language, right?
15:00:11 <Kron> skypers: I dont' feel haskell is simple by design
15:00:15 <edwardk> skypers: funny the reason i like lens is because the tools i get with it are more reusable. i have ultimately fewer names to remember for how to put things together when i use the lens vocabulary. they just compose very flexibly, so its hard to search for the tool you need, but once yu find it you can use it in _many_ contexts.
15:00:18 <Kron> Haskell is the most complex language I've ever learned
15:00:25 <skypers> Kron: sure it is, functions, types
15:00:26 <ij> What's lens?
15:00:26 <Kron> far dwarfing lisp and even prolog
15:00:28 <bitemyapp> Kron: the fundamentals are simple, the implications are deep.
15:00:30 <skypers> all is a value
15:00:31 <Peaker> skypers: ordinary Haskell code is hard for people.  (>>=) is hard for newbies.  Haskell is hard.
15:00:32 <skypers> that is
15:00:40 <bitemyapp> Kron: expressions, values, functions, types.
15:00:44 <nooodl> for some reason i prefer <$> when fmapping over IO actions specifically. am i crazy
15:00:50 <jle`> Kron: i always like to believe that the only reason Haskell is hard is because of our ingrained habits fighitng it
15:00:52 <Kron> I think it's a mistake to try to separate out a language's pure specification from its libraries, tools, community and ethos
15:01:05 <bitemyapp> I don't think so.
15:01:08 <jle`> i like to say that someone who has never programmed before
15:01:11 <edwardk> ij: it is a library for dealing with accessing parts of structures. think 'jquery for haskell data types'
15:01:14 <jle`> would find haskell no harder than anything else
15:01:15 <jle`> maybe even easier
15:01:19 <Kron> what's important isn't "Haskell 98", it's "Programming in Haskell"
15:01:23 <Peaker> skypers: Haskellers know that simple, powerful tools are worth the difficulty of learning how to apply them.  Lens is a set of pretty simple tools.  Mathematically simple, which means hard more than easy
15:01:24 <bitemyapp> understanding the fundamentals leads to better grokking of how things actually work, instead of understanding from a distance via innuendo and supposition.
15:01:41 <skypers> 23:52 < Kron> Haskell is the most complex language I've ever learned
15:01:44 <skypers> no it’s not
15:01:48 <Kron> I feel like that's a mathematical community mistake
15:01:49 <Kron> like
15:01:50 <skypers> it’s VERY simple _by design_
15:01:55 <Peaker> jle`: I don't know, I believe Scheme would be far easier to learn than Haskell. Much less syntax to learn. Fewer rules, etc.
15:01:55 <bitemyapp> complexity is not difficulty.
15:01:56 <Kron> I remember coming on here yesterday, really frustrated
15:02:00 <skypers> C++ is a very complexe one
15:02:04 <bitemyapp> recursion is simple, but sometimes difficult for people to learn.
15:02:04 <skypers> C# and Java too
15:02:07 <Kron> trying to prove the law of material implication without using demorgan's laws in natural deduction
15:02:11 <bitemyapp> difficulty and complexity are not the same thing.
15:02:24 <ij> skypers, I would like to agree with you.
15:02:24 <jle`> bitemyapp: i don't think you even need to know recursion to program haskell practically
15:02:29 <jle`> when was the last time you used explicit recursion?
15:02:31 <Kron> I knew it was true, I knew it worked, but some people like restricting themselevs to the tiniest number of axioms and then buildign everything out of them
15:02:34 <Kron> which is a mistake
15:02:39 <bitemyapp> jle`: well, Clojure either, but my point was about difficulty vs. complexity.
15:02:41 <merijn> Kron: I would argue haskell is rather simple, but the ecosystem is rather big and intimidating
15:02:42 <Kron> main = putStrLn "Hello World"
15:02:44 <bitemyapp> they're two independent variables.
15:02:50 <Kron> should I learn monads? Before I print Hello World?
15:02:55 <ion> no
15:02:55 <skypers> no
15:03:01 <ij> I did that.
15:03:04 <jle`> there is no such thing as 'learning monads'
15:03:06 <ij> I was happy about it.
15:03:07 <merijn> Kron: I don't think one should *learn* monads at all
15:03:11 <skypers> Peaker: edwardk I know lens is something I just should learn
15:03:15 <skypers> but it makes me really sick
15:03:26 <Peaker> skypers: The types are terrible-looking..
15:03:29 <Kron> the IO Monad is vastly complex and it's a part of that library of code built on top of the specification that's a part of haskell
15:03:30 <merijn> Kron: One should learn types and typeclasses, after that it's fairly simple to understand the whole monad business
15:03:34 <jle`> IO a is a monad but so are a lot of other things, and it's also a lot of different things.  the monadicness of IO doesn't help you understand it at all
15:03:50 <merijn> Kron: Why do you feel the IO monad is complex?
15:03:52 <ion> “IO” is, “IO a” isn’t
15:03:54 <edwardk> skypers: it is definitely unsettling. i felt that the whole time i was writing it, but it composes too well for me not to use =)
15:03:58 <skypers> Peaker: the types and somehow the concepts as well
15:03:59 <Peaker> skypers: @type <function from lens> --> WTF   is the terribleness of lens.   But it has an upside -- lens operators Just Work, in every context you would expect them to
15:03:59 <jle`> monads are just a convenient way to compose objects and functions
15:04:02 <Kron> i've been learning haskell for four months and I still don't know when something actually happens
15:04:11 <Peaker> skypers: The concepts are amazing :-)
15:04:13 <Kron> like I don't understand when an IO evaluation is performed
15:04:16 <merijn> Kron: Right, fortunately I recently saw a good article on this
15:04:21 <merijn> Kron: lemme grab you the link
15:04:27 <skypers> I should use them
15:04:29 <skypers> I know it
15:04:33 <skypers> but I don’t know
15:04:34 <Kron> it's even more difficult to mentally model than prolog sometimes
15:04:37 <merijn> Kron: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
15:04:39 <skypers> I like my program to be simple to read
15:04:43 <edwardk> Peaker: i'm in the process of writing up ow they work from a real category theory perspective
15:04:45 <mauke> Kron: that's not "evaluation"
15:04:46 <ion> peaker: I wish GHC were intelligent enough to turn types (such as [Char] or Functor f => (a -> f b) -> s -> f t) back into appropriate type aliases.
15:04:48 <skypers> and I prefer using modify and some let in
15:04:57 <skypers> that I MonadState weird operator
15:04:59 <skypers> than*
15:05:00 <edwardk> spans, profunctors, double categories and pullbacks, oh my!
15:05:00 <merijn> Kron: That should thoroughly unconfuse about the seperation between evaluation and execution
15:05:12 <Peaker> edwardk: cool -- though I never quite dove into CT. Planning to, some day :)
15:05:21 <edwardk> the nice thing is once you have a good intuition for lenses it gives you an intuition for a lot of harder category theory
15:05:39 <jle`> Kron: saying haskell is more difficult to mentally model than prolog is a bit of a stretch
15:05:50 <merijn> Kron: IO would work even if it wasn't a monad, it just happens that IO is a convenient interface for combining IO actions. But it's not a prerequisite
15:05:50 <ij> Not for him.
15:05:57 <Kron> it's not for me
15:06:02 <Kron> I'm modelling it in my head, I'd know
15:06:05 <jle`> Kron: you can think of an IO a as an object that describes a computer action.  In fact you can maybe even think of it as a little chunk of C code, abstracted away
15:06:05 <Peaker> ion: it's a problem since type aliases aren't always just short-cuts, sometimes they have semantics. like: type FilePath = String,  you would want to preserve FilePath as such, but not turn some Strings into FilePath arbitrarily
15:06:05 <edwardk> many of those things that arise in describing lenses categorically are famously difficult to convey normally
15:06:06 <Kron> (her)
15:06:14 <edwardk> gotta run
15:06:19 <jle`> Kron: when yous ay main = putStrLn "hello world", you are saying that main = this io action
15:06:29 <jle`> so when the compiler looks at it
15:06:35 <jle`> it sees what IO object is named "main"
15:06:43 <lingxiao> hey all I have a question about lambda calculus, so Im reading through this document:
15:06:43 <jle`> and translates it into assembly
15:06:45 <merijn> Kron: I also attempted a similar (unfinished) essay here: https://gist.github.com/merijn/6478573
15:06:45 <Kron> so IO blocks outside main simply never do anything?
15:06:46 <mangaba_leitosa> Kron: but prolog is based on logic. It's rather trivial to mentally model logic for someone who use logic when thinking :-)
15:06:50 <Peaker> Kron: IO happens sequentially from main, according to the (>>=) ordering. That's the simplest thing in Haskell evaluation order. Everything else is forced from there
15:07:06 <mauke> Kron: do you know C?
15:07:07 <lingxiao> Lambda Calculi with Types by Henk Barendregt
15:07:08 <merijn> Kron: Read the two links I just send you, they are pretty clear in explaining IO in haskell
15:07:09 <Philonous> Kron, Just like in C. If you don't call it from main it's not executed at all.
15:07:10 <Kron> mangaba_leitosa: you'll find that prolog is secretly a very imperative language masquerading as logical and pure
15:07:12 <skypers> another part of lens is that if you start using them, you end up with lenses everywhere
15:07:16 <Kron> "is" syntax gives me headaches
15:07:17 <skypers> even when you don’t need them
15:07:22 <ion> peaker: The functionality would need to track what type aliases the values were using originally and try to bring that back to the final :t output. Arbitrary [Char]-to-String or String-to-FilePath changes would be bad of course.
15:07:31 * merijn will stop talking now because 5 people saying the same thing probably doesn't help
15:07:37 <mangaba_leitosa> Kron: "is" for arithmetics?
15:07:42 <Kron> yeah
15:08:03 <Philonous> merijn, Better than 5 people contradicting each other
15:08:07 <Peaker> ion: yeah, though in lens's case, you would need the "arbitrary" conversion to get from prism . lens -> Traversal
15:08:14 <jle`> Kron: so if you have something like putStrLn "hello", it's not very useful becuase most computer programs are most useful when you can do more than one thing in a row.  so we have a function (>>) that takes two IO objects and combines them into one big one, that consists of the two sequenced.  Then when you set that to Main, the compiler sees that big io object and compiles *that*
15:08:19 <Peaker> ion: (since the class constraints unify into a unique new constraint that also has a type synonym)
15:08:36 <lingxiao> and the it introduces the Church system is that with a set of Types T = V | T -> T
15:08:47 <jle`> i wrote a short article on the subject too...it seems like everyone has to have their own interpretation on this >.> http://blog.jle.im/entry/id/6
15:08:50 <ion> peaker: I haven’t really given this any further thought, but perhaps e.g. lens could have a method of giving GHC hints wrt that.
15:08:51 <lingxiao> pseudoterms: Lam = V | Lam Lam | Lam V T Lam
15:08:55 <merijn> Philonous: Sure, but I'm not entirely agreeing with the explanation approach by some, I think the first blog post is much clearer than following 4 people on IRC :)
15:08:58 <lingxiao> and then basis..
15:09:06 <Kron> jle`: I find it fascinating that haskell sort of has 'interpretations', it's kind of cool
15:09:10 <lingxiao> what are basis and what function do they serve?
15:09:11 <Kron> like the burrito tutorials or whatnot
15:09:22 <jle`> oh merijn posted the same link as me
15:09:22 <Kron> so many different ways people mentally model the GHC
15:09:23 <Peaker> Kron: if you want an IO explanation in Haskell, I wrote one in a big Reddit comment, which I think is good (got 13/0 so far..)  http://www.reddit.com/r/programming/comments/1s65r6/dont_fear_the_monad_the_video_that_helped_me_to/cdv9bir
15:09:29 <skypers> :t folded
15:09:30 <lambdabot> (Applicative f1, Foldable f, Contravariant f1) => (a -> f1 a) -> f a -> f1 (f a)
15:09:34 <skypers> I wonder how you wrote that…
15:09:36 <Kron> thanks Peaker
15:09:39 <skypers> I mean the implementation
15:09:40 <merijn> Kron: No, the burrito tutorials are universally considered terrible and bad by people
15:09:48 <ion> This may or may not be helpful: “What is inside Haskell IO?” https://gist.github.com/ion1/7154691
15:10:00 <skypers> being able to see a use for a Contravariant
15:10:03 <skypers> for a Profunctor
15:10:11 <Peaker> ion: Sometimes like:  type {-# NonSemanticSynonym #-} Traversal f s t a b = ...
15:10:11 <skypers> yeah, I actually just suck at all of that
15:10:11 <lingxiao> bases*
15:10:24 <skypers> it’s awfull and makes me sad ahah
15:10:33 <skypers> I just should ragequit :D
15:10:47 <wojtekM_> How many bytes would you think UTCTime should occupy?
15:11:14 <ion> Probably less than a megabyte.
15:11:30 <benmachine> skypers: it's not like you sit there with a Contravariant searching for a use for it
15:11:42 <benmachine> skypers: you start with a use-case and work backwards to decide what abstractions should sit behind it
15:12:25 <jle`> Kron: basically, Haskell doesn't "execute" anything; Haskell generates a sequence of instructs for a computer, inside an object. What GHC does is it takes that sequence of instructions and compiles it into Machine code, and then later, a computer can run it.  In Haskell, you don't deal with actual executions or actions; you basically spend the entire program composing up one giant object that contains your
15:12:27 <jle`> instructions list.  This composition is facilitated by (>>), which is simply "glue these together", and (>>=), which is "glue these together but let the second thing know about what the first thing did".  So if i wanted to both print "hello" and print "world", i have putStrLn "Hello" and putStrLn "World" --- two instruction objects --- I can combine them into one big insturctino object by doing putStrLn
15:12:29 <jle`> "Hello" >> putStrLn "World".
15:12:41 <ion> (kron: highlight so you don’t miss my link above)
15:12:50 <henk> I get a parse error for http://lpaste.net/96762 after trying to rewrite my code to use optparse-applicative and have no idea what’s wrong about it. Could anyone help me please?
15:13:13 <wojtekM_> time <- getCurrentTime; (recursiveSize $!! time) >>= print -- says 144
15:13:22 <wojtekM_> Haskell will never be fast.
15:13:37 <Kron> ion: thanks. jle` : I get the basic theoretical idea but modelling it in my head is still something that I'm only slowly coming to terms with
15:13:38 <mauke> wojtekM_: 144 looks pretty fast to me
15:14:07 <Peaker> wojtekM_: what's recursiveSize?
15:14:08 <wojtekM_> mauke: you really need 16 and you get that in C
15:14:23 <wojtekM_> GHC.DataSize.recursiveSize
15:14:27 <mauke> wojtekM_: why do I need 16?
15:14:28 <jle`> knowing "IO is a monad" doesn't really help you work with IO.  That's like saying that knowing "You write C++ in a text editor" helps you write C++.  "Monadness" really isn't a helpful thing to "know", if that makes sense
15:14:45 <mauke> wojtekM_: and how fast is 16?
15:14:59 <wojtekM_> mauke: man clock_gettime
15:15:17 <mauke> wojtekM_: ok, what now?
15:16:03 <ion> henk: Are you sure that’s the same code? I don’t see “map” on line 43, column 3.
15:16:31 <wojtekM_> mauke: About 10 times faster, when memory is the bottleneck. Or about a milion times faster when the machine starts to swap to disk.
15:16:34 <solrize> is this is 100x faster with optimization than without
15:16:39 <solrize> http://lpaste.net/96764
15:16:56 <mauke> wojtekM_: ok, so we've established that 16 is "about 10 times faster"
15:16:59 <Peaker> what units does "recursiveSize" use?
15:17:01 <mauke> that's good to know. /s
15:17:13 <wojtekM_> Peaker: bytes
15:17:38 <quchen> henk: There is no "in" for the "let" starting in line 34.
15:17:59 <mangaba_leitosa> 16 bytes is about 10 times faster 144? :-)
15:18:06 <mangaba_leitosa> than 144
15:18:13 <mauke> mangaba_leitosa: no, 16 bytes is about 10 times faster, period
15:18:18 <mauke> this is absolute
15:18:20 <mangaba_leitosa> mauke: ah, ok
15:18:21 <jle`> Kron: you'll find that just using IO practically is of more benifit than thinking about the theoretical implications
15:18:29 <mauke> mangaba_leitosa: actually, 16 is about 10 times faster
15:18:32 <ion> quchen: Oh, huh. GHC gives an interesting error message for that.
15:18:33 <mauke> mangaba_leitosa: no one said anything about "bytes"
15:18:42 <jle`> Kron: i'm sure if you have read LYAH that you can work with something like do { x <- getLn; putStrLn x }
15:18:48 <jle`> (on multiple lines of/c)
15:18:59 <quchen> ion: Inspired by Latex' ability to pin down where you missed a "}" :-þ
15:19:00 <ion> quchen: One would think it could say “expected ‘in’”.
15:19:03 <henk> ion: m( no, you are right, my mistake. I was desperate and tested map, mapM and mapM_ and copied the wrong error output. It’s only the map|mapM|mapM_ part that’s changed though. Should I still create a matching paste?
15:19:27 <ion> henk: No need, quchen already figured the problem out.
15:20:15 <dcoutts_> ion, quchen: ghc has bad parse errors because happy has almost no error reporting capability
15:20:26 <dcoutts_> erm error messages
15:20:47 <quchen> dcoutts_: What happened with the plans to include Parsec in Base?
15:20:53 <henk> quchen: oh right, thank you
15:20:54 <ion> When someone implements a better replacement, *please* call it “unhappy”.
15:21:15 <mauke> deeply disturbed & deeply unhappy
15:21:34 <dcoutts_> ion: Ralf did, he called it frown
15:21:41 <haasn> cohappy
15:21:46 <ion> dcoutts: Heh, nice.
15:21:50 <quchen> "cabal install crappy"
15:21:51 <geekosaur> quchen, what? they're shrinking base, not adding big packages to it?
15:22:20 <quchen> geekosaur: I just remembered an email on the lists a couple of months ago that asked for Parsec in Base. I think.
15:22:48 <geekosaur> it was requested and shot down, is my recollection
15:22:51 <dcoutts_> quchen: I don't think that's ever been a plan, though there has been some discussion of having parsec in the set of libs distributed with ghc, allowing Cabal to depend on it
15:23:37 <quchen> dcoutts_: Ah, that rings a bell. I think that's what I meant.
15:23:51 <wojtekM_> I ran into performance problems today. I was parsing a 25MB file and I needed 8GB of RAM to do that. I thought something was very wrong with my code, but no. Haskell, without any optimization, was expanding every line (53 bytes) to over 1600 bytes. Adding great many ! and -funbox-strict-fields alleviated the problem.
15:23:56 <haasn> Wasn't there some proposal or extension to allow NeM-style literals for integral types in the case that M ≥ the number of digits in N ?
15:24:09 <Peaker> wojtekM_: seems a POSIX time interval is 64 bytes, maybe too much precision
15:24:23 <ij> (.) is needed only to avoid parentheses?
15:24:24 <quchen> dcoutts_: Out of curiosity, why can't Happy generate nicer error messages? Is it a technical problem, or is it just that nobobdy bothered?
15:24:35 <Peaker> wojtekM_: unoptimized Haskell is notoriously slow
15:24:37 <dcoutts_> quchen: mostly not bothered. frown can do it.
15:24:48 <wojtekM_> Peaker: The real data is just Int (64 bits), the rest is various overhead.
15:24:51 <quchen> And we're not using Frown because ..?
15:24:52 <Peaker> wojtekM_: instead of -funbox-strict-fields I'd use {-# UNPACK #-}
15:24:59 <dcoutts_> quchen: it's not maintained
15:25:08 <quchen> There's always a catch. :-(
15:25:46 <wojtekM_> But it got me interested in how much space different values take. And it is terrible.
15:25:59 <dcoutts_> quchen: but the concept could be imported into happy. frown provided the error production with the expected tokens, and (I think) which production it was in
15:26:09 <wojtekM_> Especially on 64 bit machines
15:26:22 <dcoutts_> quchen: and this is more or less all the info that parsec uses as the basis for its error messages
15:27:01 <wojtekM_> Peaker: In fact I used UNPACK, too.
15:27:09 <Peaker> wojtekM_: so no need for the -f
15:27:09 <quchen> dcoutts_: Hm, sounds like this would be easier than porting GHC to Parsec (politics aside)
15:27:31 <Peaker> wojtekM_: ooh, I see Data.Fixed uses an Integer behind the scenes for its E12 thing for NominalDiffTime for PosixTime, which may be a bit wasteful
15:27:51 <Peaker> wojtekM_: I would love to have a more-aggressively-unboxing compiler for Haskell
15:27:53 <benmachine> Peaker: this was why thyme was invented, right?
15:27:59 <dcoutts_> quchen: yes, and it'd still be as fast as happy
15:28:03 <Peaker> benmachine: haven't heard of thyme
15:28:15 <benmachine> Peaker: it's a time library based on Int64
15:28:19 <benmachine> focus on performance
15:28:28 <Peaker> benmachine: oh, cool, wojtekM_, check it out: http://hackage.haskell.org/package/thyme
15:29:33 <quchen> dcoutts_: I can't find Frown though. The website seems to be dead. :-(   (← hahahaha)
15:29:44 * benmachine high fives quchen 
15:30:11 <wojtekM_> benmachine, Peaker: Fabulous, thanks a lot!
15:30:12 <benmachine> dcoutts_: is happy maintained? it seemed pretty static last I looked
15:30:12 <quchen> It'll be some web archive digging and package unpackaging to get the whole source I guess.
15:30:17 <dcoutts_> quchen: I said it wasn't maintained :-)
15:30:26 <dcoutts_> benmachine: well it doesn't change much
15:31:35 <Peaker> many Haskellers believe thunks/laziness require extra boxing/indirection, and I'm not sure I agree.  I think the C++ approach of unboxing everything would work great, except for compile times (maybe a "release mode" for this would be useful).  Of course, with RankNTypes or existentials or other situations, you'd need boxing after all
15:31:37 <merijn> wojtekM_: Sounds like you were using String for the file?
15:32:03 <wojtekM_> merijn: Lazy ByteString
15:32:39 <merijn> Curious how that exploded that much then
15:32:46 <wojtekM_> merijn: using lines and then parsing every line with attoparsec
15:33:45 <merijn> wojtekM_: Have you looked into using something like pipes/conduits? Lazy IO is a rather awful mess where it's easy to leak resources
15:34:20 <quchen> dcoutts_: My garden shed is unmaintained. It's still there though.
15:34:34 <benmachine> merijn: it's possible for lazy IO to be fine
15:34:40 <benmachine> there are circumstances in which it's fine
15:34:45 <quchen> But apparently someone uploaded Frown to Github.
15:35:02 <quchen> For the logs: https://github.com/strake/frown/blob/master/Haskell.lhs
15:35:04 <tomejaguar> Peaker: do you think you could do this in GHC, or would it have to be a different approach altogether?
15:35:08 <merijn> benmachine: Sure, I said it's a mess. Messes can be ok sometimes, you need to be aware of the fact you're causing them, though :p
15:35:15 <Peaker> tomejaguar: I think so, but I'm not that well versed in GHC internals
15:35:31 <Kron> guys
15:35:34 <Kron> we need a Burrito typeclass
15:35:40 <Kron> for types that are complex and have lots of tutorials
15:35:47 <wojtekM_> merijn: the datatype was initially: data OHLC = OHLC (Int16, Int8, Int8) (Int8,  Int8, Int8) Decimal Decimal Decimal Decimal Int
15:35:51 <Kron> Burrito a => [Tutorial a]
15:35:58 <Peaker> tomejaguar: when I suggested it in #ghc, someone said "go for it, we'd love to see patches for that in ghc", seems like a huge project, though and I have too many already :)
15:36:35 <tomejaguar> Peaker: Interesting.  Do you have an idea of what it would take to fix?
15:36:47 <wojtekM_> merijn: It really does take over a kilobyte
15:37:16 <tomejaguar> Peaker: AIUI the reason that unboxing can only be done monomorphically is that otherwise the garbage collector gets confused
15:37:42 <wojtekM_> merijn: I need it all in memory at once, because I'm doing some map/reduce on it
15:38:00 <wojtekM_> merijn: besides, it's only 25MB!
15:39:30 <wojtekM_> merijn: Small correction, the file has 233MB. But I have 8GB of RAM.
15:39:42 <benmachine> wojtekM_: well, if you're going to put it all in memory anyway, might as well use a strict bytestring, no?
15:40:14 <Peaker> tomejaguar: each type could get a GC traversal automatically exported for it that is called/inlined by the traversal of its containers
15:41:17 <Peaker> tomejaguar: (auto-generated to traverse just the references)  this might get hairy with sharing of contained structures.. these already exist, I guess (if you have an unpacked value inside a constructor, and someone refers to it)
15:41:20 <wojtekM_> benmachine: Yes, I think so. But I started form Lazy. Do you think the memory usage would be less with Strict ByteString?
15:41:52 <benmachine> wojtekM_: I don't expect much of a difference, but I'm not much of an expert
15:41:55 <Peaker> wojtekM_: can't map/reduce be done in a streaming fashion?
15:41:56 <wojtekM_> benmachine: I think the real deal is the size of the parsed data.
15:42:04 <tomejaguar> Peaker: Well that goes over my compiler-ability head.  But the idea fits in well with my plan for strict Haskell :)
15:42:27 <benmachine> tomejaguar: someone's already working on LANGUAGE Strict, right?
15:42:46 <wojtekM_> Peaker: Yes. Maybe I should have said 'sort'.
15:42:52 <Peaker> tomejaguar: strict Haskell can do it more easily, I think that's what Mu does
15:42:58 <copumpkin> moo
15:43:04 <copumpkin> fish goes blub
15:43:17 <Peaker> copumpkin: everything alright in there? :)
15:43:30 <tomejaguar> Peaker: I don't see why it's more easy.  GHC is already strict if you look it it from the right direction :)
15:43:34 <wojtekM_> Peaker: I really need it all in memory at once.
15:44:04 <piezoid> Peaker: do you think that whole program compilation would help ? (for unboxing)
15:44:19 <Peaker> tomejaguar: because thunks are harder than simple values
15:44:34 <Peaker> tomejaguar: (though laziness ought to always be an option, even if strictness is a default)
15:45:04 <tomejaguar> Peaker: Indeed.  I don't really consider them separable, since they're both needed for a decent language (as far as I can tell)
15:45:18 <Peaker> piezoid: I think it's almost a necessity, because without boxing, types no longer have a uniform representation to work with, so you need to compile many variants of functions for various types
15:45:36 <brrrrian> how do you pattern match with record syntax and lists?  e.g. fixupN a (SomeData n):xs = (SomeData a):(fixupN (a+1) xs)   ???
15:46:00 <Peaker> tomejaguar: I want typed/polymorphic laziness  (maybe after using it I won't want it anymore, heh)
15:46:16 <wojtekM_> thyme rocks! Just 8 bytes for time, hurray.
15:46:19 <tomejaguar> Peaker: Yeah me too.  That's what one of my side-projects is about.
15:46:20 <piezoid> Peaker: having all definitions INLINEABLE by default could be a good start
15:46:22 <merijn> brrrrian: "f SomeData { field1 = x, field2 = y } = x + y"
15:46:22 <Tekmo> brrrrian: I think you want: fixupN a ((SomeData n):xs) = ...
15:46:35 <tomejaguar> Peaker: Although I think we've half-discussed this before on various different fora :)
15:46:38 <Peaker> tomejaguar: strict list is ListT Identity a,  lazy-spine list is ListT Lazy a.  Lazy-spine lazy-value list is: ListT Lazy (Lazy a)
15:46:56 <tomejaguar> Peaker: Yup yup :)
15:47:33 <merijn> Tekmo: I send a sketch of my current design to the mailing list, if you have some time to sanity check it I'd be grateful :)
15:47:45 <Tekmo> merijn: Got it.  Will do
15:48:35 <brrrrian> Tekmo: yeah, that did it...  do you always need the paren if you're pattern matching a list like that?
15:49:25 <merijn> brrrrian: Yes, because "function application" bind tighter than infix operators
15:49:31 <ij> How do I pack four bytes into an Int?
15:49:32 <tomejaguar> Peaker: I did a sort-of proof-of-concept implementation of this a few weeks ago to convince myself that it's feasible and useful.  It's not *too hard* to prototype it in normal GHC, though it's not /quite/ right.  What we really need is a slightly adjusted type system.
15:50:04 <merijn> brrrrian: So "fixupN a (SomeData n):xs" parses as "(fixupN a (SomeData n)):xs"
15:50:16 <merijn> ij: That's not guaranteed to be possible
15:50:29 <merijn> ij: I believe the report only guarantees 27bit size for Int
15:50:39 <brrrrian> merijn: can you explain your solution above? I don't follow how it is equivalent
15:50:42 <ij> What about float?
15:50:45 <scott_> Why 27bit?
15:51:03 <geekosaur> because some historical compilers used the rest of the bits as tags
15:51:13 <ij> And do they still?
15:51:18 <merijn> brrrrian: It isn't, you were asking for pattern maatching with record syntax, but I don't see any record syntax there
15:51:26 <merijn> scott_: To leave room to use a few bits for tagging
15:51:28 <Peaker> tomejaguar: Once you go strict-by-default, I wonder how augustuss's approach of compiling to C++ compares with ghc
15:51:32 <danharaj> ocaml uses tagged ints
15:51:32 <Tekmo> brrrrian: Yes, you need parentheses around pattern matching unless it is a record using field syntax (for some bizarre reason)
15:51:45 <merijn> ij: GHC uses 32bit/64bit Int depending on platform, but you can't rely on that if you wanna be portable
15:51:51 <Peaker> the reason is not that bizarre, {} binds tighter than function application
15:51:52 <wojtekM_> Looks like Data.Thyme and Data.Fixed will allow me to do create a sparing data type. Thanks everybody.
15:51:55 <tomejaguar> Peaker: Mu compiles to C++?
15:52:17 <Peaker> tomejaguar: If I understood augustuss correctly
15:52:40 <tomejaguar> Peaker: Details are few and far between.  The only public info I know is that video.
15:53:08 <Peaker> tomejaguar: met him in the IFL2013 conference, and he described some tidbits here and there
15:53:36 <tomejaguar> Peaker: We should chat about this more.  It seems we have both come to the same conclusions.
15:54:06 <ij> merijn, Suppose I want to pack a Float. Do I have to write my own routine?
15:54:19 <merijn> ij: btw, why do you want to encode into Int? i.e. what are you trying to do?
15:54:48 <maxs_> wojtekM_: I'm not sure I followed your problem completely, but are you parsing a large CSV?
15:54:52 <Peaker> tomejaguar: I am not fully convinced the idea works. It sounds like it should work in theory, and promoted also by Conor Mcbride, so it's probably good :)  But maybe it would be difficult in practice or require more machinery elsewhere due to interactions with other features
15:54:57 * hackagebot diophantine 0.1.0.0 - A quadratic diophantine equation solving library.  http://hackage.haskell.org/package/diophantine-0.1.0.0 (joejev)
15:54:58 <ij> merijn, I want to manipulate with audio data.
15:55:14 <ij> Which comes in the form of [Char] stream from sox.
15:55:14 <merijn> ij: Right, don't you just want to get Int32/Word32 then?
15:55:23 <merijn> ij: [Char]? Ouch...
15:55:24 <Tekmo> ij: Not if Float has a Storable instance
15:55:40 <ion> ij: ಠ_ಠ
15:55:42 <merijn> ij: No way to get a ByteString?
15:55:42 <geekosaur> probably best done with ByteString instead of String
15:56:16 <merijn> ij: Then you can just use binary to decode Word32/Int32 from the ByteString
15:56:18 <tomejaguar> Peaker: I would like to know what the know potential difficulties are.  From where I stand it seems like it would just be an adjusted type system for GHC which basically indicates when something is known to be in WHNF.
15:56:49 <Tekmo> tomejaguar: I think I would prefer a language that used codata and data declarations
15:56:51 <tomejaguar> That's not to say I think *programming* for such a language will be easy :) but I do think such a language should be possible.
15:56:56 <wojtekM_> maxs_: Yes.
15:56:58 <Tekmo> tomejaguar: codata is lazy and data is strict
15:57:09 <Peaker> Tekmo: even then an explicit Thunk type would be nice
15:57:09 <Jesin> I am a little bit disappointed in the interface for Data.Set
15:57:11 <tomejaguar> Tekmo: How would you reflect that in the type system?
15:57:24 <Tekmo> tomejaguar: I'm not sure.  It's just a vague and inarticulate idea of mine :)
15:57:44 <Peaker> Tekmo, tomejaguar: Does Agda use laziness for codata? I suppose it must?
15:57:55 <Zap_> Hi!
15:57:56 <Tekmo> Peaker: I have no clue
15:58:01 <Zap_> I'm stuck with an exercise
15:58:04 <ij> merijn, 'Binary' some package?
15:58:11 <ij> s/'
15:58:11 <merijn> @hackage binary
15:58:11 <lambdabot> http://hackage.haskell.org/package/binary
15:58:23 <Zap_> the task is to model a file system as data (not a real file system, just a toy example)
15:58:26 <ij> Okay then, thanks.
15:58:29 <tomejaguar> :)  I thought about all sorts of possible combinations, spurred on by ezyang's article about the difference between lazy function application and lazy datatypes.  But an explicit thunk datatype is the only approach I could get to make any sense.  And I think it makes a lot of sense.
15:58:41 <Zap_> Instruction: "A file either contains data or is a directory"
15:58:50 <Zap_> code: data File = Data | Directory
15:58:53 <merijn> ij: It provides easy ways to decode stuff from ByteString's (hence why you really want that instead of [Char] as input)
15:58:54 <Zap_> ok, next part:
15:59:06 <Zap_> "A directory contains other files (which may themselves be directories) along with a name for each one."
15:59:25 <Zap_> code (?): data Directory = File String
15:59:38 <Zap_> now, this would mean that a Directory can only contain one file an a description
15:59:54 <merijn> Zap_: Your initial line specifies a type "File" which has two constructors (Data and Directory)
16:00:07 <Zap_> I would like to write something like "data Directory = [File String]", which doens't work
16:00:17 <merijn> Zap_: You probably want to add some extra information to the Directory constructor
16:00:30 <Tekmo> Zap_: You would put the contents of the Directory within the Directory constructor of the file type
16:00:36 <merijn> Zap_: i.e. "data File = Data | Directory [(String, File)]"
16:00:42 <Tekmo> Zap_: i.e. data File = Data | Directory [File]
16:00:56 <Jesin> http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.5.0.0/Data-Set.html
16:01:02 <Tekmo> Zap_: Note that `Directory` in that declaration is a constructor, not a type
16:01:05 <merijn> Zap_: i.e. that says the Directory constructor has 1 argument, a list of tuples of String and File
16:01:07 <maxs_> wojtekM_: so I can parse a 700mb csv in about 35 seconds, but it has a space leak somewhere, and is blowing up to use about 2gb of RAM
16:01:24 <henk> This seems like a stupid question: I have an IO String where a String is expected, what do I do? http://lpaste.net/96767 I’m sure I should know how to do something like that by now, but I can’t figure it out for some reason o_O
16:01:48 <Zap_> Thanks for the help!
16:02:12 <merijn> henk: transpose has type "String -> String"
16:02:22 <Tekmo> henk: If you have a function of type `f :: String -> SomethingElse` and an `IO` action of type `action :: String`, you can use `fmap` to apply the function to the `String`
16:02:30 <merijn> henk: But "logfile_lines_split" has type IO String
16:02:31 <maxs_> wojtekM_: http://lpaste.net/96768
16:02:33 <Tekmo> henk: fmap f action :: IO SomethingElse
16:02:36 <merijn> henk: Because of the fmap
16:02:59 <merijn> henk: You want to use the "<-" syntactic sugar to work with it
16:03:08 <Tekmo> henk: fmap is basically equivalent to the following code: fmap f action = do { str <- action; return (f str) }
16:03:25 <wojtekM_`> maxs_: In my case there was no leak, the data type to hold the parsed lines was very large.
16:03:54 <merijn> henk: Or move the transpose inside the fmap
16:04:22 <maxs_> hmm thats interesting
16:04:25 <wojtekM_`> maxs_: Maybe in your case the 2GB is simply legit memory usage.
16:04:40 <Peaker> Tekmo: action :: *IO* String   seems missing there?
16:04:55 <Jesin> I would like to see a function semantically equivalent to: insertAndMember x s = (Data.Set.insert x s, Data.Set.member s x)
16:04:56 <wojtekM_`> maxs_: 700MB -> 2GB is not that much expansion.
16:05:06 <Jesin> ....
16:05:11 <Jesin> I would like to see a function semantically equivalent to: insertAndMember x s = (Data.Set.insert x s, Data.Set.member x s)
16:05:18 <Jesin> sorry I got the arguments mixed up the first time.
16:05:19 <maxs_> wojtekM_`: yeah but it should be streaming, not all in RAM
16:05:22 <Tekmo> Peaker: Oops ,yeah
16:05:28 <Jesin> But yeah... that'd be really nice for performance
16:05:30 <Tekmo> henk: That should have been `action :: IO String`
16:05:36 <henk> merijn, Tekmo: oh, so the problem is not the argument given to readFile?
16:05:52 <merijn> henk: No
16:06:09 <Tekmo> henk: Can you give us the exact function types?
16:06:09 <wojtekM_`> maxs_: Well, in that case things are not okay...
16:06:13 <Peaker> Jesin: if you use lens, you have:   "contains x"    which can be used to read whether it was a member and change it too
16:06:14 <maxs_> lol yea
16:06:16 <merijn> henk: The problem is that the result of fmap over readFile is still an "IO String", which you then give to transpose
16:06:30 <merijn> henk: But tranpose doesn't accept IO values
16:06:33 <merijn> :t transpose
16:06:33 <lambdabot> [[a]] -> [[a]]
16:06:50 <Peaker> Jesin: s & contains x %~ f    where f False = True ; f True = error "x already in the list!"
16:06:58 <wojtekM_`> I have not quit, dear freenode.
16:07:21 <henk> Tekmo: hmm, I don’t know. I’m not sure what you mean … All the code I have is in the pastebin.
16:07:41 <henk> merijn: hm, confusing error message then, is it not?
16:08:09 <Jesin> Peaker: I am unfamiliar with lens...  in which module would I find those functions?
16:08:18 <Tekmo> henk: The issue is precedence
16:08:22 <Peaker> Jesin: you have to "cabal install lens"
16:08:30 <Peaker> Jesin: then it's in Control.Lens
16:08:36 <Tekmo> henk: There are two separate issues
16:08:53 <Tekmo> henk: First, you have precedence wrong for the definition of logfile_lines_split
16:09:12 <Tekmo> henk: It should be: logfile_lines_split = map (splitOn ";") . lines <$> readFile (inFile opts)
16:09:33 <Tekmo> henk: Sorry, it should be further modified to:
16:09:34 <maxs_> if anyone likes debugging space leaks, my conduit doesn't work. :P http://lpaste.net/96768
16:09:43 <Tekmo> henk: It should be: logfile_lines_split = (map (splitOn ";") . lines) <$> readFile (inFile opts)
16:10:07 <cmears> Is there a standard function for doing tie-breaking sorting: sort by comparing this function, and if they're equal, use this, and if that's also equal, use that ...
16:10:10 <Tekmo> henk: Second, you should probably change it to something like
16:10:18 <cmears> > sortBy ((\fs -> (\a b -> mconcat (map (\f -> f a b) fs))) [comparing length, comparing last]) ["apple", "cat", "cod", "dog", "fish"]
16:10:19 <lambdabot>   ["cod","dog","cat","fish","apple"]
16:10:22 <cmears> (like that)
16:10:25 <merijn> Tekmo: It doesn't need the parens before <$>
16:10:36 <merijn> Tekmo: (.) is infix 9, <$> is like 4 or 5
16:10:37 <henk> Tekmo: Yes, that fixes the error message, thank you.
16:10:56 <Tekmo> henk: [timestrings_finish, entries] <- (transpose . map (splitOn ";") . lines) <$> readFile (inFile opts)
16:11:16 <Tekmo> henk: In other words, include `transpose` in the set of functions to fmap over the `readFile`, and then bind the result
16:11:32 <merijn> cmears: There was a neat monoid trick to do that, but I forgot how
16:11:46 <Tekmo> merijn: Thanks, I didn't know that
16:12:06 <cmears> merijn, my implementation does use the monoid via mconcat, but I was hoping for something in some library that has a good name (:
16:12:23 <merijn> cmears: Yeah, I just noticed that. I'm not aware of any
16:12:31 <Peaker> maxs_: your ExpectLineOrTrailer has a lazy Int in it
16:12:36 <Peaker> maxs_: that seems very suspicious
16:12:36 <Tekmo> cmears: I think you can simplify it further.  HOld on a second
16:12:47 <Peaker> maxs_: I'd use a strict Int there (and {-# UNPACK #-} for good measure)
16:13:00 <maxs_> Peaker: ah good point!
16:13:08 <issam> how to return an element association from a tuple in a list only if it exists, for example, if 3 `lookup` x == Just e  then e else 'Error'
16:13:28 <Peaker> maxs_: the first thing I learned to look for in leaks is lazy constructor fields
16:14:09 <Tekmo> cmears: sortBy (mconcat [comparing length, comparing last]) ["apple", ...]
16:14:39 <henk> Tekmo: Thank you, but now I get a "parse error on input `<-'" … What does <- do and when do I use it, when do I use =?
16:14:52 <Tekmo> henk: You need to use `<-` within a `do` block
16:14:59 <Tekmo> henk: I recommend you first learn how Haskell `IO` works
16:15:12 <Peaker> maxs_: http://neilmitchell.blogspot.co.il/2013/02/chasing-space-leak-in-shake.html <-- this is why I learned this, but also http://blog.ezyang.com/2012/11/why-cant-i-just-be-a-little-lazy/
16:15:13 <Tekmo> henk: Have you read "Learn you a Haskell" yet?
16:15:30 <cmears> Tekmo, oh, there's a monoid instance on functions, very nice, thanks!
16:15:35 <Tekmo> cmears: You're welcome!
16:15:46 <henk> Tekmo: Not completely, I always get back and read sections again, but I keep forgetting things when I don’t use them …
16:15:59 <Peaker> the monoid instance for functions makes it possible to do nice things like:  mconcat [a, b, c, d] x y
16:16:08 <skypers> night folks
16:16:22 <Tekmo> henk: You can try reading this post I wrote on `IO`: http://www.haskellforall.com/2013/01/introduction-to-haskell-io.html
16:16:23 <maxs_> Peaker: cool thanks, I will have a look at them
16:16:34 <Peaker> (instead of mconcat . map ($y) . map ($x) $ [a, b, c, d] )
16:16:40 <maxs_> Peaker: cool thanks, I will have a look at them
16:16:54 <Peaker> or   mconcat [a x y, b x y, c x y, d x y]
16:17:22 <henk> Tekmo: thanks, will do that tomorrow
16:17:43 <cmears> Peaker, that is cute
16:18:27 <Peaker> Tekmo: why not <> instead of mconcat for just 2 values?
16:18:48 <Tekmo> Peaker: Mindless modification of his example.  I wasn't really thinking
16:18:50 <henk> So do I add a do block to that function now?
16:19:10 <Tekmo> cmears: Like Peaker said, you can use `<>` and write `sortBy (comparing length <> comparing last) ["apple", ...]
16:19:36 <cmears> Tekmo, I just did that to my application and it looks very nice now
16:21:40 <Tekmo> henk: It's hard to explain `do` syntax on IRC without using semicolons and braces
16:23:07 <Tekmo> henk: However, using that it would be: do { [timestrings_finish, entries] <- tranpose . map (splitOn ";") . lines <$> readFile (inFile opts); ... }
16:23:33 <mietek> "Thankfully, you don’t have to worry about that - because Edward Kmett has already done it for you."
16:23:45 <mietek> ocharles: :)
16:24:06 <tomejaguar> > let ords = sort [LT, GT, EQ] in (<>) <$> ords <*> ords
16:24:15 <lambdabot>  [LT,LT,LT,LT,EQ,GT,GT,GT,GT]
16:24:18 <tomejaguar> What is this magic?
16:24:26 <int-e> > preview (strippingPrefix "abc") "abchello"
16:24:34 <lambdabot>  Just "hello"
16:24:59 <henk> Tekmo: ah ok, I think I got it, only the second error left, which I’ll take a closer look at now. Thank you very much (:
16:25:01 <triliyn> > let ords = sort [LT..] in (,) <$> ords <*> ords
16:25:07 <Tekmo> henk: You're welcome!
16:25:08 <int-e> shachaf: I silenced the deprecation warning. ^^
16:25:08 <lambdabot>  <hint>:1:22: parse error on input `]'
16:25:15 <quchen> tomejaguar: The magic of obfuscation
16:25:17 <triliyn> > let ords = sort [LT..GT] in (,) <$> ords <*> ords
16:25:26 <lambdabot>  A section must be enclosed in parentheses thus: (LT.. GT)Not in scope: `LT..'
16:25:41 <triliyn> I don't know why I tried to use ..
16:25:47 <triliyn> > let ords = sort [LT,EQ,GT] in (,) <$> ords <*> ords
16:25:56 <lambdabot>  [(LT,LT),(LT,EQ),(LT,GT),(EQ,LT),(EQ,EQ),(EQ,GT),(GT,LT),(GT,EQ),(GT,GT)]
16:26:06 <int-e> @version
16:26:10 <lambdabot> lambdabot 5.0-int-e
16:26:16 <lambdabot> git clone git://github.com/int-e/lambdabot.git
16:26:23 <tomejaguar> quchen: Is there some sensible interpretation of this instance?
16:26:36 <quchen> tomejaguar: It's the List Applicative you've been using
16:27:03 <tomejaguar> I mean the Monoid instance for Ordering
16:27:12 <cmears> tomejaguar, it's "use the first non-EQ"
16:27:34 <cmears> (but return EQ if they're both EQ)
16:27:45 <tomejaguar> cmears: OK that makes sense with respect to what Tekmo's using it for there ...
16:27:50 <tomejaguar> Still seems like a lot of magic ...
16:28:01 <quchen> EQ <> x = x; y <> _ = y
16:28:03 <quchen> That's it
16:28:09 <cmears> it's similar to the instance for Maybe
16:28:20 <quchen> If the first comparison is inconclusive, try the next
16:28:28 <tomejaguar> Yup that's nice.
16:28:37 <tomejaguar> A bit cunning for me though.
16:28:42 <quchen> It's how you compare words for lexical ordering.
16:28:48 <quchen> Check first letter. Equal? Check second.
16:29:16 <cmears> rather, it's like the monoid for "First", not "Maybe"
16:29:55 <quchen> It's First Bool to be precise ;-)
16:30:26 <issam> why doesnt this work ? "x <- 3"
16:30:29 <issam> x<-3
16:30:31 <issam> x <- 3
16:30:37 <issam> :)
16:30:40 <mauke> x<- 3
16:30:44 <mauke> x <-3
16:30:54 <mauke> x< -3
16:30:58 <merijn> issam: Define "doesn't work"?
16:31:08 <merijn> @undo do { x <- 3; foo x }
16:31:08 <lambdabot> 3 >>= \ x -> foo x
16:31:12 <quchen> mauke: Going full antisocratic again? :-þ
16:31:23 <merijn> ^ doesn't make sense unless 3 is an instance of Monad
16:31:23 <issam> in prelude
16:31:24 <quchen> s/anti/co/
16:31:26 <issam> i get this
16:31:28 <issam> <interactive>:87:6:
16:31:28 <issam>     No instance for (Num (IO t0)) arising from the literal `3'
16:31:28 <issam>     Possible fix: add an instance declaration for (Num (IO t0))
16:31:28 <issam>     In the first argument of `GHC.GHCi.ghciStepIO ::
16:31:28 <issam>                                 IO a_a1fp -> IO a_a1fp', namely
16:31:29 <issam>       `3'
16:31:31 <issam>     In a stmt of an interactive GHCi command:
16:31:33 <issam>       c <- GHC.GHCi.ghciStepIO :: IO a_a1fp -> IO a_a1fp 3
16:31:41 <Tekmo> issam: Why are you trying to write `x <- 3`?
16:31:49 <Tekmo> issam: Do you mean `let x = 3`?
16:31:53 <issam> yah
16:31:55 <mauke> issam: what are you trying to achieve?
16:31:56 <issam> but i saw some code
16:31:57 <issam> online
16:31:59 <geekosaur> also please do not paste directly into the channel, use the pastebin
16:32:12 <issam> writing something like  rhs <- 'werew'
16:32:17 <issam> sorry!
16:32:23 <Tekmo> issam: That's because it was using the list monad
16:32:25 <mauke> that's a lexical error
16:32:25 <Luke> my emacs + flymake isn't recognizing 'import Development.Shake' - is there something special I need to do?
16:32:32 <Tekmo> issam: "werew" is a list of characters
16:32:38 <geekosaur> I assume that was "werew"; 'werew' is not a thing
16:32:40 <Tekmo> issam: So it was binding each individual character that way
16:32:44 <simpson> edwardk: Out of curiosity, is there currently a way to use highlighting in parsers (or trifecta) to output a highlighted parse, or does this require one to write a pile of code?
16:33:34 <issam> I see, thank you :)
16:34:53 <Luke> my emacs + flymake isn't recognizing 'import Development.Shake' - is there something special I need to do?
16:36:40 <danilo2> Hello :) How can I print a ByteString containing quotations without backslashes before each quotation? I'm Using Aeson to encode structure in JSON format and when I print the encoded ByteString to terminal I see: \"tags\":[\"\"]
16:37:07 <mauke> are you using 'print'?
16:37:19 <danilo2> mauke: yes
16:37:28 <mauke> well, stop
16:37:44 <danilo2> mauke: I was trying to use ByteString.hPut stdout
16:37:54 <mauke> go on
16:38:03 <danilo2> mauke: but I've got strange error: Couldn't match expected type `ByteString.ByteString' with actual type `Data.ByteString.Lazy.Internal.ByteString'.
16:38:15 <Tekmo> danilo2: Use `Data.ByteString.putStrLn` to show it without escaping characters
16:38:37 <Tekmo> danilo2: Then use `Data.ByteString.Lazy.putStrLn`
16:39:00 <Tekmo> danilo2: Actually, you will need a `Char8` in there somewhere
16:39:21 <Tekmo> danilo2: Data.ByteString.Lazy.Char8.putStrLn
16:39:45 <danilo2> Tekmo: hmm, I was searching this function. I do not know why I havent found it. Thanks! :)  (Data.ByteString.Lazy.Char8.putStrLn)
16:40:03 <quchen> danilo2: Printf? http://lpaste.net/96775
16:40:09 <danilo2> Tekmo, mauke: btw, could you tell me why the hPut does not work?
16:40:14 <quchen> Not the most efficient of algorithms though.
16:40:16 <mauke> or just putStr followed by putChar '\n'
16:40:38 <mauke> danilo2: because you imported the wrong module
16:40:39 <geekosaur> danilo2: Couldn't match expected type `ByteString.ByteString' with actual type `Data.ByteString.Lazy.Internal.ByteString'
16:40:48 <simpson> edwardk: Okay, never mind, I think that I see ho to make things all come together, more or less.
16:40:53 <geekosaur> means one is strict and the other is lazy
16:41:22 <epta> Is there a function to build a/b directory path that will work on windows to?
16:41:57 <Peaker> Luke: is shake installed?
16:42:06 <Luke> Peaker: yeah
16:42:21 <danilo2> geekosaur: ah, ok - when I import the lazy version it works. Hmmm I was accustomed to libraries exporting lazy api by default
16:42:33 <Peaker> Luke: might be something like HOME not being in your emacs's env
16:42:41 <Tekmo> danilo2: I would expect `hPut` to also work
16:42:57 <epta> epta: System.FilePath.Posix.</>
16:43:03 <Peaker> Luke: in any emacs buffer, type (getenv "HOME")  C-x C-e   and see what it says in the minibuffer
16:43:05 <Luke> ooh I know what it is! I have my src did set and the shakefile is above my src dir. Thanks Peaker
16:43:08 <danilo2> Tekmo: It indeed works, when imported from good module :) Tekmo, mauke: thank you :)
16:43:17 <Tekmo> danilo2: You're welcome
16:43:19 <mauke> quchen: showHex = printf "%*v02X" " "
16:43:29 <mauke> quchen: with Text.Printf.Mauke
16:43:34 <Luke> Peaker: sometimes you need to just talk it out w/ someone. Thanks a lot
16:43:42 <Peaker> Luke: heh, rubber duckie method :)
16:43:49 <Luke> exactly =)
16:43:58 <Luke> it needs to be a person for me though
16:44:22 <Peaker> Yeah, I don't think I could ever get it to work with a rubber duck
16:44:34 <Peaker> hard to get yourself to actually explain it :)
16:44:34 <Tekmo> Luke: My trick is to type my thoughts into an empty vi buffer
16:44:49 <quchen> mauke: I don't even.
16:44:52 <Peaker> Tekmo: but we only have emacs buffers :P
16:44:52 <Luke> sometimes I just need someone to ask me the obvious stuff =)
16:44:58 <Luke> haha yes
16:45:07 <Tekmo> Peaker: Yeah, it has to be vi :)
16:45:08 <mauke> quchen: vector flag, yo
16:45:11 <Luke> haha
16:45:24 <quchen> mauke: And asterisk flag
16:45:28 <quchen> Or is that prinf-*
16:45:39 <mauke> I bet you can run vi in an emacs buffer
16:45:51 <mauke> quchen: that's not a flag
16:46:16 <mauke> it's just that the separator string defaults to "."
16:48:01 <gamegoblin> Hello all. I'm about to start using regex in Haskell, and from the descriptions of the many libs, it seems like TDFA is the best? However, I haven't really found much in the way of tutorials or examples. Any ideas?
16:48:22 <quchen> So it's `printf "% v02X`?
16:48:51 <mauke> quchen: yes, except that's not valid syntax
16:48:59 <quchen> gamegoblin: Regex is fairly unpopular in Haskell. What do you want to do?
16:49:33 <mauke> printf format strings weren't made for embedding arbitrary strings
16:49:37 <gamegoblin> I'm making some machine learning functions, and in machine learning there is a popular file format called ARFF (attribute relation file format)
16:49:41 <gamegoblin> so I am making an arff parser
16:50:06 <gamegoblin> It's a relatively simple format, 5 or so regexs could do all I need
16:50:21 <quchen> Use a parser library, like Parsec!
16:50:33 <gamegoblin> I figured that might be a bit too heavy weight
16:50:46 <gamegoblin> Seeing as using regex would be < 20 lines of python T_T
16:50:52 <quchen> I use Parsec to parse Brainfuck, so I don't agree ;-)
16:51:01 <simpson> gamegoblin: In Python, we would also tell you to use a parser library, like Parsley.
16:51:11 <simpson> gamegoblin: What does "heavy weight" mean?
16:51:22 <gamegoblin> lots of set up for a relatively simple task
16:51:37 <nicoo> gamegoblin: Regexp are for lexing, not parsing
16:51:46 <mauke> gamegoblin: regexes are harder to set up in haskell
16:51:56 <gamegoblin> nicoo: but since I know the precise format of the data, regex's suffice perfectly
16:52:05 <benmachine> parsec is a bit wordier than regex but it's way simpler
16:52:20 <quchen> It's also typesafe and readable and maintainable.
16:52:25 <alpounet> gamegoblin: what ML algorithms are you implementing?
16:52:40 <simpson> gamegoblin: Doesn't follow; many context-free languages are simple but beyond the powers of regexes.
16:53:18 <gamegoblin> simpson: It isn't a context free language. It's a very specific file format that can be parsed by regex. I have made a parser for it in C++, Python, and Java all using regex.
16:53:22 <ion> Regexps are overused in programming, perhaps due to the lack of good parsing libraries.
16:53:44 <Tekmo> gamegoblin: Just trust us on this: parsers are a dream to use in Haskell
16:53:53 <Tekmo> gamegoblin: They are like the regex of Haskell, in terms of ease of use
16:53:59 <ion> I don’t think i have used regexps even once in Haskell.
16:54:09 <gamegoblin> I don't doubt you guys, and I will use parsec, I was just saying regex are totally just fine for this task (in general, maybe not haskell)
16:54:37 <simpson> gamegoblin: Nothing stops you from using regexes in Haskell.
16:54:43 <Tekmo> gamegoblin: The issue is that Haskell regex libraries are so poorly designed and maintained because nobody uses them
16:54:46 <monochrom> regex is fine. parsec isn't more work either
16:55:06 <Tekmo> gamegoblin: They are also more weakly typed because the format string is a string
16:55:20 <sharky> more weakly typed than what?
16:55:26 <ion> Parsec
16:55:27 <gamegoblin> simpson: The lack of examples and tutorials is what stops me, which was my first question about them 5 minutes ago (for regex-TDFA specifically)
16:55:39 <Tekmo> sharky: The equivalent parser combinators
16:55:51 <gamegoblin> Fortunately the file format specifies the types of all of the data
16:55:55 <sharky> Tekmo odd comparison
16:56:20 <Tekmo> sharky: Not odd at all
16:56:28 <gamegoblin> alpounet: Not too relevant to parsing ARFF files, but I am implementing: knn (with ball trees), belief networks (naive bayes, and arbitrary belief networks), MLPs, SVMs, RBMs, RFs, and... I might have forgotten a few
16:56:28 <ion> Huh. I for one get what Tekmo means.
16:56:36 <Tekmo> sharky: `many` behaves like the regex `*`, `(<|>)` behaves like the regex `|`, etc.
16:56:37 <gamegoblin> I am just porting a python ML library I wrote to haskell
16:57:06 <simpson> gamegoblin: "haskell regex-tdfa example" brings many relevant hits on Google.
16:57:36 <sharky> odd as a follow up to "Haskell regex libraries are poorly designed and maintained". i figured you were comparing it to regex libraries in other languages
16:57:53 <Tekmo> sharky: Yeah, I meant that, too
16:58:10 <gamegoblin> simpson: I have looked on google. Please link me to a tutorial that specifically uses regex tdfa if you do find one. A few of them mention it, but I haven't found one that uses it with examples.
16:58:42 <Tekmo> sharky: regex-tdfa is not a good library in my opinion
16:58:48 <sharky> Tekmo you meant that haskell regex libraries are more weakly typed than regex libraries in other languages?
16:58:55 <Tekmo> sharky: Oh, no not that
16:58:58 <simpson> gamegoblin: bos has several pages, from his examples in RWH to his G+ posts, that have examples.
16:59:06 <Tekmo> sharky: I mean that they are just poorly designed and maintained than other languages
16:59:12 <Tekmo> sharky: They are more weakly typed compared to parser combinators
16:59:58 <gamegoblin> simpson: RWH doesn't use regex-tdfa
17:00:10 <copumpkin> is there a TLS-over-pipes library somewhere?
17:00:39 <copumpkin> pipes-network-tls looks promising
17:00:54 <Tekmo> copumpkin: http://hackage.haskell.org/package/pipes-network-tls
17:01:00 <copumpkin> thanks :)
17:01:03 <Tekmo> You're welcome! :)
17:01:07 <copumpkin> have much experience with it?
17:01:10 <copumpkin> does it work reliably?
17:01:46 <Tekmo> I haven't had a chance to test drive it since it was upgraded to 4.0, but probably
17:02:07 <Tekmo> copumpkin: The main issue is use of `pipes-safe` combinators, the same issues that Michael Snoyman mentioned in his series of posts on pipes vs. conduit finalization
17:02:15 <gamegoblin> Would you guys say the best parsec tutorial is the RWH one or should I start elsewhere?
17:02:24 <Tekmo> copumpkin: If you don't use the `.Safe` module then you should have 0 issues
17:02:40 <cyrix> I want to call a C function that returns 32 bit unsigned integer. what is haskell equivalent?
17:02:49 <copumpkin> hmm, haven't been following the -safe issues
17:02:55 <Tekmo> gamegoblin: My favorite parser combinators tutorial is the functional pearl but Hutton and Meijer
17:03:33 <alpounet> gamegoblin: is it on github? i'm interested, i'm myself working on some ML techniques in Haskell, and have been for a while now
17:03:34 <Tekmo> gamegoblin: http://www.cs.nott.ac.uk/~gmh/pearl.pdf
17:03:52 <gamegoblin> Tekmo: reading now
17:04:33 <copumpkin> Tekmo: is there also an HTTP pipes lib that I can layer on top of the TLS one?
17:04:41 <Tekmo> copumpkin: No, not yet
17:04:46 <copumpkin> ah okay
17:04:47 <Tekmo> copumpkin: Jeremy Shaw is working on it right now
17:04:52 <gamegoblin> alpounet: yes, but the only thing there right now is a data container that I am going to be putting ARFF data into (it also takes care of things like generating cross validation sets, shuffling of data, and bootstrap aggregation)
17:04:53 <copumpkin> luckily my http stuff is trivial
17:05:10 <Tekmo> copumpkin: If you have an attoparsec parser for the HTTP header, you can use that in conjunction with `pipes-attoparsec`
17:05:23 <alpounet> gamegoblin: i'm writing code for RBMs at the moment actually heh
17:05:24 <Tekmo> copumpkin: There will be a few changes to `pipes-parse` coming up soon that will make all that stuff much more slick to use
17:05:28 <copumpkin> cool
17:05:29 <darthdeus> how come people are always talking in this room more than in the other 10 rooms i'm in combined? :P
17:05:37 <copumpkin> mostly don't care about the HTTP stuff, it's just there for annoying reasons
17:05:51 <alpounet> darthdeus: friendliness?
17:05:52 <alpounet> :
17:05:53 <alpounet> :)
17:06:06 <alpounet> i think that's a factor
17:06:16 <darthdeus> alpounet: haha yeah, every time i get a question i get about 5 answers within a minute
17:06:29 <darthdeus> but last time i asked a question in #android-dev i got told to !@#$ off for being a noob :D
17:06:37 <merijn> darthdeus: Well, #haskell is one of the largest channels on freenode
17:06:45 <merijn> darthdeus: And also one of the most newbie friendly ones
17:06:50 <alpounet> wow, 1205 users right now
17:06:53 <copumpkin> we actively enforce friendliness
17:06:59 * copumpkin cracks the whip
17:07:02 <copumpkin> (the friendly whip)
17:07:03 <alpounet> these IRC channels grow so fast
17:07:16 <merijn> darthdeus: At the other hand, there's also a significant number of very advanced people to talk with too
17:07:20 <darthdeus> which i why i made a cookie just for you guys :P
17:07:22 <darthdeus> https://twitter.com/darthdeus/status/409766188118310912/photo/1/large
17:07:39 <merijn> i.e. fp researchers showing up in here too
17:07:43 <monochrom> darthdeus: create 10 rooms, make them all mirror this room. that solves the problem. :)
17:07:45 <darthdeus> oh shit, i made the lambda the other way around :D
17:07:54 <darthdeus> or didn't i?
17:07:58 <darthdeus> yeah i did
17:07:59 <ion> photoshop
17:08:10 <Tekmo> darthdeus: It's the anti-lambda!
17:08:37 <ion> colambda
17:08:45 <darthdeus> i guess it's kinda like with the \ lambda syntax ... if you squint hard enough you can see it there :P
17:08:53 <alpounet> it's a coabstraction
17:10:07 <darthdeus> case cookie of (lambda: tail) -> (reverse lambda) : tail ... trololol
17:10:39 <benmachine> λλλλ
17:11:43 <darthdeus> while we're at the unicode characters ... the scala dudes are using ⇒ in their sources https://github.com/akka/akka/blob/master/akka-persistence/src/main/scala/akka/persistence/Eventsourced.scala#L34 ... or am i blind?
17:11:47 <ion> ʎ
17:11:51 <darthdeus> O.o
17:12:23 <benmachine> darthdeus: have you heard of the UnicodeSyntax extension?
17:12:37 <quchen> Eww.
17:12:48 <darthdeus> benmachine: i'm not sure if such thing should be allowed to exist
17:13:29 <alpounet> also, the haskell-mode for emacs can display a unicode lambda and pretty (double) arrows while still actually using \, -> and =>
17:13:32 <benmachine> darthdeus: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#unicode-syntax
17:13:40 <AshyIsMe> yeah it seems a bit silly if it's not on anyone's keyboard
17:14:09 <ion> alpounet: Does it handle code alignment correctly?
17:14:32 <benmachine> AshyIsMe: eh, keyboards are programmable
17:14:33 <darthdeus> alpounet: yeah i actually used that for a while until i figured out how to turn it off
17:14:37 <benmachine> or, input methods are at least
17:14:56 <alpounet> ion: no idea, I just remember I tried it out back when I started using Haskell, but didn't find it to be really an improvement over the good old usual chars
17:14:57 <darthdeus> AshyIsMe: 
17:15:01 <AshyIsMe> i know but that doesnt make the syntax more accessible in general
17:15:07 * benmachine has a compose key setup for ⇒ and → and ≡
17:15:12 <cyrix> I want to call a C function that returns 32 bit unsigned integer. what is haskell equivalent?
17:15:22 <alpounet> Word32
17:15:25 <benmachine> I don't use UnicodeSyntax for Haskell but I'm not against it
17:15:27 <darthdeus> cyrix: String :P
17:15:30 <alpounet> I guess
17:16:08 <alpounet> cyrix: from Data.Word: http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Word.html#g:1
17:16:16 <cyrix> thanks
17:19:17 <merijn> cyrix: CUInt
17:19:46 <merijn> cyrix: Well, actually are you using uint32_t or "unsigned int"?
17:20:14 <cyrix> I already have C data type, which I wanted to hide. it appears though it was just an alias for Word32
17:20:15 <merijn> cyrix: Word32 is uint32_t, CUInt matches whatever "unsigned int" is in C
17:20:30 <alpounet> oh right, for FFI CUInt may be better suited
17:20:51 <alpounet> for portability
17:20:53 <nstdloop> Hey everyone. What's the easiest way to reinstall cabal packages after changing some .cabal/config flags?
17:21:06 <nstdloop> cabal install world --reinstall says it's going to break things
17:21:10 <nstdloop> which I would rather avoid
17:21:14 <merijn> nstdloop: Nuke .cabal/.ghc and reinstall from scratch
17:21:20 <benmachine> nstdloop: what did you change?
17:21:32 <monochrom> nstdloop, read my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config
17:21:34 <nstdloop> documentation, optimization, and library profiling
17:22:02 <benmachine> monochrom: I read that the other day, I think you are overcautious
17:22:19 <nstdloop> monochrom: I was actually just there. Cool to get help from the author.
17:22:22 <benmachine> monochrom: following your instructions will never lead someone astray, but I'm not as careful as you and I get by
17:22:30 <cyrix> yeah I realize that unsigned int may not be 32 bit in C, I am not using that type though
17:22:47 <nstdloop> Where can I go to get the list of non haskell-platform packages?
17:23:02 <nstdloop> because when I try and list installed cabal packages I get tons of them
17:23:58 <monochrom> no, nstdloop, the idea is not to find out what you already have and completely restore them. the idea is to decide now what you really need and just install those.
17:24:12 <nstdloop> ah
17:24:12 <nstdloop> ok
17:24:43 <nstdloop> how do I know I won't be forgetting something critical? Is there a place I can look to find necessary packages?
17:25:03 <quchen> If something is missing you install it.
17:25:39 <monochrom> is it important to, immediately, without delay, be comprehensive and not forget something?
17:25:46 <darthdeus> if i have a [Double] (which is probably a wrong type), and i do length on it, i'll get an Int ... but hoogle can't find anything that's Int -> Double >:o
17:25:56 <darthdeus> i kinda wanna do   sum xs / length xs
17:26:02 <benmachine> darthdeus: fromIntegral
17:26:03 <arkeet> fromIntegral
17:26:06 * benmachine > hoogle
17:26:16 <arkeet> or you could use genericLength
17:26:24 <darthdeus> thanks :)
17:26:26 <arkeet> also, beware memory leaks when you do that
17:26:37 <darthdeus> memory leaks?
17:26:40 <frx> memory leaks when you do what?
17:26:47 <darthdeus> what's a memory leak?
17:26:47 <arkeet> sum xs / length xs
17:26:48 <benmachine> it's not really memory leaks
17:26:48 <darthdeus> :D
17:26:51 <arkeet> ok not really
17:26:58 <benmachine> it's not-quite-as-good-as-it-could-be
17:27:17 <arkeet> but it will have to hold the entire list in memory
17:27:24 <benmachine> it's possible to calculate the average of a list in a single traversal, if you generate the list element-by-element that means you can do it in constant space
17:27:38 <benmachine> often it is fine not doing this, but it's cool if you can
17:28:07 <quchen> The RWH chapter on profiling and optimization is precisely about sum xs / length xs.
17:28:14 <darthdeus> hmm interesting
17:28:35 <alpounet> Don also covered this example on his blog
17:28:46 <alpounet> "haskell as fast as C" or something like that
17:29:14 <Tekmo> See also "beautiful folds"
17:29:33 <monochrom> dear benmachine, it's a free country, you are free to do the opposite of what I say
17:29:34 <haasn> Use a fold combinator library
17:30:05 <darthdeus> alpounet: this one? http://donsbot.wordpress.com/2008/06/04/haskell-as-fast-as-c-working-at-a-high-altitude-for-low-level-performance/
17:30:07 <haasn> monochrom: is it also a cofree untry?
17:30:14 <benmachine> haasn: :D
17:30:27 <nstdloop> monochrom: Not really. I just want to make everything work cleanly and forget about it.
17:31:14 <benmachine> monochrom: it isn't that free :P but after all I do appreciate your articles, despite my comments
17:31:26 <alpounet> darthdeus: I think so, but there was one before that started with: mean xs = sum xs / length xs
17:31:30 <darthdeus> why every time i open a blog post about FP i have to edit the css to be able to read the text :P
17:32:15 <monochrom> ok, suppose you are actively working on 3 projects, project 1 requires lens and aeson, project 2 requires aeson and fay, project 3 requires fay and lens.
17:32:35 <monochrom> don't tell me you don't know what your 3 projects require. the requirements are right in your *.cabal files.
17:33:03 <monochrom> then, it's "cabal install --haddock-hyperlink-source lens aseon fay" at the end
17:33:24 <sharky> calling it a memory leak is wrong.. it will just store entire list into the memory (as it would in any non-lazy language), which shouldn't matter in vast majority of the cases
17:34:58 <alpounet> Tekmo: is it possible to have some kind of equivalent of `cycle` as a Producer on which I could fold that wouldn't hold onto too many elements in memory at a time?
17:35:38 <Tekmo> alpounet: What's the type signature you have in mind?  Is the input a list or another `Producer` to cycle?
17:35:54 <nstdloop> monochrom: I'm not doing anything busy enough to even need that. I just write little standalone scripts. I'm reading all your stuff and figuring it out. Thanks.
17:36:38 <alpounet> Tekmo: I'll rather give my use case. I'm doing some machine learning, and I want to go over the learning set over and over again until some conditions are met
17:37:06 <Tekmo> Tekmo: In other words, something similar to the `until` function?
17:37:09 <alpounet> but I don't want to pretend the learning set is just going to be small
17:37:26 <cyrix> are there any reliable tools for autogenerating C bindings from header files?
17:37:38 <alpounet> so ideally even if we're encountering the same samples, I'd like not to hold onto them all in memory at the same time
17:37:47 <nstdloop> monochrom: so in step 4 I just delete the folder you have there? Do I need to do anything else to delete all the packages?
17:38:08 <alpounet> and I have an update function that takes *one* sample and updates my model accordingly
17:38:31 <alpounet> I just want to fold with that function, until the error goes below some threshold or something
17:39:00 <alpounet> is it possible to generate a suitable Producer I could consume?
17:39:01 <twiceler> cyrix: funny you ask that
17:39:20 <twiceler> I have actually been doing exactly that for CUBLAS
17:39:22 <alpounet> from, say, a list of samples yes (but really it can be anything else if needed)
17:39:34 <twiceler> using template-haskell and language-c
17:39:36 <monochrom> you can find files under ~/.cabal to delete. which files? read my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove , which is the link right in step 1.
17:40:00 <Tekmo> alpounet: Are you ever going to reuse any of the samples or can you discard each sample immediately after folding it in?
17:40:16 <nstdloop> monochrom: should I do that first? Before deleting the folder?
17:40:26 <cyrix> twiceler: you rolled your own library that does it?
17:40:36 <monochrom> yes
17:40:40 <alpounet> Tekmo: i'll most likely use the samples several times
17:40:53 <alpounet> thus my idea of having a 'cycle'-like function for producers
17:40:54 <twiceler> cyrix: I'm in progress, so "library" might be a little over-selling it :)
17:41:14 <monochrom> so are you saying, you do step 4 before doing step 1?
17:41:25 <alpounet> you generally go over your training set until your model does good enough on some other set of samples
17:41:25 <cyrix> twiceler: :). do you plan on making it public when it is more mature?
17:41:36 <twiceler> It's about 200-ish lines of code, and imports the functions with correct types, and has some marshalling
17:41:41 <Tekmo> alpounet: I guess my question is how can you stream the values if you have to remember them?
17:41:55 <Tekmo> alpounet: It sounds like no matter what you do you have to store the whole data set in memory
17:41:59 <nstdloop> monochrom: my ~/.cabal has nothing in it except config and config.platform
17:42:04 <twiceler> cyrix: I'm not sure it will ever get mature. I've learned that C is much more flexible with regards to declarations than I'd expect.
17:42:06 <nstdloop> which seems wrong...
17:42:11 <monochrom> maybe I should, you know, make the article show step 1 only, and detect whether you have done it. if you haven't done it, the article won't show you other steps
17:42:25 <twiceler> So my thing works well for CUBLAS, but I have no idea how it will do with header files that are structured differently
17:42:52 <alpounet> Tekmo: yeah, I thinks sharing kind of comes in the way
17:42:54 <monochrom> well then, there is no other file to delete
17:42:59 <cyrix> twiceler: I see. did you try using SWIG too?
17:43:00 <alpounet> I think* sorry
17:43:08 <nstdloop> monochrom: haha I'm reading it now. carefully. But the files you refer to don't exist on my machine. There's no ~/.cabal/lib
17:43:14 <twiceler> But I could send you the code if you want to see how I've been doing it
17:43:24 <twiceler> cyrix: Never heard of SWIG...
17:44:21 <Tekmo> alpounet: The only way you can stream is if you re-read the values every time you need them instead of saving them
17:45:02 <Tekmo> alpounet: If you did that, then the cycle definition would basically be `cycle = forever`
17:45:15 <Luke> jle`: you around?
17:45:18 <cyrix> twiceler: it does just that, generates C bindings for many languages, and it seems to have haskell support. no idea how well it works though
17:46:14 <haasn> given eg. data Foo = Foo { foo, bar :: T }; how well does “let Foo _ x = example in ... x ...” compare to “... (bar x) ...” ?
17:46:21 <haasn> err, (bar example)
17:46:32 <alpounet> Tekmo: right. this is conceptually a bit annoying but most likely won't matter much in practice. having training sets of a gigabyte or more isn't that common right now for me, thanks for sharing your thoughts
17:46:44 <alpounet> have you handed over your thesis yet, by the way?
17:46:49 <haasn> That is; is it more efficient to define something directly in terms of pattern matching than to use an auto-generated field accessor?
17:47:03 <quchen> haasn: As far as I know pattern matching is always rewritten to case
17:47:21 <quchen> Oh wait nevermind, misread
17:47:25 <Tekmo> alpounet: No problem ta all :)
17:47:43 <Tekmo> alpounet: Yeah, I have.  I'm totally done with my PhD
17:48:29 <twiceler> cyrix: Okay. Well the advantage of rolling your own is you can add some auto-marshalling stuff
17:48:34 <quchen> Tekmo: Time to worry about counting Buffers :-D
17:48:47 <bitemyapp> Tekmo: whoa, you did a PhD? Your blog has helped me tons. What was your thesis on?
17:48:50 <Tekmo> quchen: Yeah, one thing at a time!
17:48:56 <Tekmo> quchen: I'm also sick right now and recovering
17:49:00 <Tekmo> quchen: That's why I'm on IRC
17:49:05 <bitemyapp> Tekmo: hope you get better soon!
17:49:09 <Tekmo> bitemyapp: Thanks! :)
17:49:15 <bitemyapp> did somebody mention your phd thesis and I didn't see it?
17:49:18 <alpounet> Tekmo: nice, congrats! Heading to industry or continuing research?
17:49:27 <Tekmo> bitemyapp: My thesis was on bioinformatics, not computer science
17:49:31 <Tekmo> alpounet: I'm joining Twitter
17:49:40 <alpounet> wow
17:49:50 <alpounet> scala?
17:49:52 <alpounet> :p
17:49:58 <Tekmo> Yeah, it will be Scala
17:50:04 <twiceler> cyrix: You're aware of c2hs, right?
17:50:10 <cyrix> twiceler: I dont know enough haskell to toll my own, unfortunately. are you parsing header files yourself, or?
17:50:13 <Tekmo> Don't worry, I'll still be working on Haskell in my free time as I always do
17:50:31 <Tekmo> My long term goal is to build a polished game in Haskell.  Everything I'm doing is a really slow build-up to that
17:50:45 <cyrix> twiceler: yes
17:51:14 <twiceler> cyrix: the language-c package parses the C to an AST, and then I "parse" the AST
17:51:20 <heatsink> So... the game will be related to genetics?
17:51:22 <alpounet> Tekmo: well my experience with scala was, well, let's say mixed. hope you'll have tons of fun, the problems at hand there probably will help
17:52:06 <Tekmo> alpounet: Yeah, I'm well aware of the problems with Scala
17:52:38 <Tekmo> alpounet: My long term goal is to get Haskell going within Twitter
17:52:44 <twiceler> cyrix: I didn't know template-haskell before this project; it is fun to learn
17:52:49 <Tekmo> alpounet: That's one of the reasons that I was recruited
17:52:58 <Ralith> Tekmo: really? they're taking an active interest?
17:52:59 <Ralith> nice
17:53:05 <Tekmo> Ralith: It's a minor interest right now
17:53:13 <bitemyapp> Tekmo: oh you're going to be working at twitter?
17:53:14 <cyrix> twiceler: it is on my to learn list
17:53:17 <Tekmo> bitemyapp: Yeah
17:53:19 <bitemyapp> Tekmo: how long ago did you start?
17:53:20 <Ralith> major enough to hire someone for
17:53:23 <alpounet> Tekmo: that would be quite awesome :-) I think Haskell is reallly starting to catch the interest of the biggies
17:53:24 <Tekmo> bitemyapp: I start in Feburary
17:53:30 <bitemyapp> Tekmo: I actually know sritchie a little bit from his Clojure and Scala stuff, before he left Twitter.
17:53:39 <bitemyapp> I talked to him about cascalog and summingbird/algebird a fair bit.
17:53:57 <bitemyapp> Tekmo: Facebook's haskell stuff seems to have been most successful anywhere parsing, type inference, or compilers were involved.
17:54:08 <Tekmo> Yeah, I got an offer from Facebook, too
17:54:12 <bitemyapp> which was oddly enough, critical because PHP has nothing for that.
17:54:17 <Tekmo> It was a really tought choice
17:54:24 <bitemyapp> is bos still at FB or did he move on to start another company?
17:54:29 <Tekmo> He's still at FB
17:54:45 <alpounet> Tekmo: i suppose you received offers from banks too?
17:54:47 <bitemyapp> Tekmo: it's a trade-off. Twitter has a better established FP culture, but it's less hardcore than the haskellers that already exist in FB.
17:54:48 <haasn> Oh, this is interesting. The following code: http://bpaste.net/show/156816/ compiles to the following Core: http://bpaste.net/show/156817/
17:55:01 <Tekmo> alpounet: No.  I never applied or got an internal referral
17:55:22 <haasn> both compile down to a pattern match on Foo; but in the case of cmp2, it actually inlines the pattern match on I# as well
17:55:26 <haasn> I wonder why cmp2 does that but cmp1 does not
17:55:28 <haasn> (this is with -O2)
17:55:31 <Tekmo> bitemyapp: That's exactly the impression I got
17:55:40 <alpounet> Tekmo: well, I have been contacted by a few this year, that's why I was asking :-) haskell's already established though
17:55:46 <Tekmo> bitemyapp: Twitter's FP base is broader
17:55:52 <posco> bitemyapp: say hi sometime. When do you start?
17:55:57 <issam> hello :), why am I getting this error http://pastebin.com/sgrt8DAu
17:55:58 <mauke> The paste sgrt8DAu has been copied to http://lpaste.net/96776
17:55:59 <Tekmo> bitemyapp: But it doesn't have Simon Marlow or bos
17:56:01 <bitemyapp> posco: that's Tekmo, not me.
17:56:06 <bitemyapp> posco: he's starting in Feb.
17:56:16 <issam> and how would I fix it
17:56:25 <Tekmo> posco: Are you at Twitter?
17:56:27 <posco> Ah. Misread that. Well, you should say hi too. :)
17:56:29 <bitemyapp> Tekmo: I wasn't talking to Twitter, but I knew people that worked there. I was talking to FB about possibly working there. ultimately chose to go to a medium-sized startup instead. I'm happy with my choice.
17:56:34 <posco> Yes.
17:56:38 <Tekmo> posco: What's your name?
17:56:39 <bitemyapp> I work in SOMA.
17:56:44 <posco> bite
17:57:06 <bitemyapp> I'm converting a bunch of (bio-focused) Python coders to Clojure and Haskell.
17:57:15 <bitemyapp> I'm happy to carry the flag in foreign territory :)
17:57:17 <posco> Tekmo: I worked with Sam on a lot of stuff including algebird and summingbird thus my app pinged the mention
17:57:25 <Tekmo> bitemyapp: Yeah, that is lots of fun
17:57:34 <Tekmo> bitemyapp: I got to do a lot of that as part of my graduate study and it made me really happy
17:57:44 <bitemyapp> Tekmo: I don't mind writing Python that much anyway. That old saying about FORTRAN applies to Haskell and clojure too.
17:57:56 <alpounet> haasn: interesting
17:57:59 <bitemyapp> "good FORTRAN programmers can write FORTRAN in any language"
17:58:01 <Tekmo> posco: Neat!  I'll make sure to say hi when I start :)
17:58:14 <Tekmo> bitemyapp: Yeah, I know
17:58:18 <posco> Tekmo: Oscar boy
17:58:24 <Tekmo> bitemyapp: I would have fun implementing church-encoded maybes in Python
17:58:30 <bitemyapp> Tekmo: I've done that.
17:58:32 <posco> Boykin. Damn I am having trouble with this iOS app
17:58:34 <Tekmo> bitemyapp: :)
17:58:43 <posco> @posco
17:58:43 <lambdabot> Unknown command, try @list
17:58:50 <alpounet> haasn: you should use some core-output simplifying flags :p
17:58:52 <bitemyapp> posco: I'm nearby 4th and Brannan, so if you're around SOMA we could grab lunch sometime if you like.
17:59:10 <bitemyapp> followed you on Twitter.
17:59:24 <haasn> alpounet: like? :)
17:59:26 <posco> bitemyapp: sure. I used to live over there. We should have a haskell meetup at twitter sometime.
17:59:29 <bitemyapp> I should put a picture of myself on Twitter to be polite, but I really like that beer.
17:59:31 <Tekmo> I'm in San Francisco, too
17:59:34 <haasn> (I'm new to this core business, got any articles?) also time to sleep
17:59:35 <alpounet> gah, I should really keep my GHC Core by Example series going
17:59:40 <twiceler> I'm trying to get people at my workplace to use Haskell! It usually starts like this: "Yeah, I used Haskell to do this." "Oh Pascal, I think I've heard of that"
17:59:43 <monochrom> please don't scorn at fortran. its most important contribution is being trashed by many programmers these days. the contribution of letting you write "a*(b+c)" so you don't have to write "tmp1 = b+c; tmp2 = a*tmp1"
17:59:46 <alpounet> haasn: well, I have two for now
17:59:50 <Tekmo> twiceler: Oh god, I get that so much
17:59:54 <bitemyapp> posco: I'd really like that, there aren't any Haskell meetups lately, only type theory. Which is cool too, but it overlaps with my Clojure stuff and I am very active in that.
17:59:58 <bitemyapp> I know more Clojure than Haskell atm.
18:00:05 <alpounet> haasn: http://alpmestan.com/2013/06/27/ghc-core-by-example-episode-1/ and http://alpmestan.com/2013/10/01/ghc-core-by-example-episode-2-evaluation/
18:00:10 <Tekmo> The best Haskell meetup is bayhac
18:00:11 <alpounet> still really the basics
18:00:13 <posco> bitemyapp: are you at prismatic?
18:00:13 <bitemyapp> Somebody starting up Haskell meetups would be very valuable to me.
18:00:16 <haasn> alpounet: I really know almost absolutely nothing about core. Thanks, I'll have a read in the morning
18:00:18 <posco> Just guessing
18:00:18 <heatsink> haasn, compareInt isn't defined with an {-# INLINE #-} annotation, while the related function gtInt is
18:00:18 <alpounet> but I'll keep more coming
18:00:26 <heatsink> That's probably the cause
18:00:26 <posco> They are over there
18:00:26 <bitemyapp> posco: no, I'm nearby them. I wouldn't need to sell Clojure/Haskell if I was at Prismatic.
18:00:33 <posco> :)
18:00:35 <bitemyapp> posco: I presented a project at their clojure community night.
18:00:41 <bitemyapp> I'm at a genetics company.
18:00:45 <alpounet> heatsink: right on spot! that's right
18:00:45 <haasn> @src comparing
18:00:45 <posco> Ahh
18:00:46 <lambdabot> Source not found. You type like i drive.
18:00:49 <Tekmo> bitemyapp: What's the name?
18:00:52 <bitemyapp> InVitae
18:00:52 <monochrom> edwardk revealed in Toronto that he has a secret backburner project called Turbo Haskell
18:00:59 <bitemyapp> monochrom: wat
18:01:03 <Tekmo> bitemyapp: Aw, I was hoping it was the genetics company that my friend joined
18:01:11 <bitemyapp> Tekmo: Counsyl?
18:01:12 <Tekmo> bitemyapp: He joined some place named DNA Nexus
18:01:14 <bitemyapp> oh.
18:01:19 <haasn> heatsink: is comparing defined as something other than comparing f x y = compare (f x) (f y) -- ?
18:01:23 <bitemyapp> Tekmo: I haven't even heard of them, I have a guess as to what they're up to though.
18:01:35 <bitemyapp> Tekmo: we're not a pure software company, we sequence DNA and apply it to medical outcomes.
18:01:37 <Tekmo> bitemyapp: I forgot what he said they were doing
18:01:37 <haasn> Maybe I should add cmp3 x y = compare (foo x) (foo y) -- to the list
18:01:40 <haasn> but I really have to sleep now
18:01:53 <bitemyapp> not being a pure software company has been a plus for me, it means I actually have more free rein to do as I like.
18:02:12 <heatsink> That's exactly how it's defined, haasn
18:02:24 <alpounet> haasn: the change is in the int implementation
18:02:25 <Tekmo> bitemyapp: For me it has been the opposite.  After working in a mixed experimental/computing lab I yearn for a pure software environment
18:02:33 <monochrom> therefore, when you tell your coworkers "I'm using Haskell, the compiler is called Turbo Haskell", they can then say, "yeah, Turbo Pascal, I've heard of that"
18:02:46 <alpounet> one function has an INLINE pragma, the other doesn't
18:02:49 <bitemyapp> Tekmo: my situation is a bit uncommon, it's one of those semi-anarchic companies.
18:03:02 <bitemyapp> Tekmo: where individuals are generally trusted to not have a boss and just do their thing.
18:03:14 <Tekmo> bitemyapp: So was my lab
18:03:24 <Tekmo> bitemyapp: My professor gave an extraordinary amount of freedom to graduate students
18:03:39 <Tekmo> bitemyapp: However, that also meant a lot of responsibilities, too
18:03:49 <bitemyapp> Tekmo: it might matter that I am relatively isolated from the bio/lab parts and that my personal *experience* of the job has been pure software.
18:03:55 <Tekmo> bitemyapp: i.e. writing our own grants and stuff like that
18:03:59 <bitemyapp> Tekmo: I consult with bio/medical/pathologist/lab people on a case by case basis.
18:04:07 <bitemyapp> Tekmo: hrm, no, we have more division of labor than that.
18:04:16 <bitemyapp> *I* do pure software, the company does not.
18:04:22 <Tekmo> Ah, that's nice
18:05:02 <bitemyapp> not being the only thing on the company's collective mind is nice though because the engineers are pretty free to organize individually and collectively as to how they want to solve problems.
18:05:26 <Tekmo> bitemyapp: Yeah, that is a nice way to work
18:10:16 <Ralith> bitemyapp: on the flipside, if it's the only thing in the company's mind, you might have engineers in charge, in which case the same goes
18:11:34 <bitemyapp> Ralith: there's no hierarchy at my company
18:11:47 <bitemyapp> Ralith: so "in charge" is a dubious concept
18:12:06 <Ralith> you get the point :p
18:12:18 <bitemyapp> Ralith: I guess, but it really doesn't matter in my case.
18:12:34 <bitemyapp> There are executives, but there's a division of labor applied, they only define high level strategy, they don't mess with the bio/lab/software people.
18:13:01 <bitemyapp> software people decide how they want to do things themselves.
18:17:38 <Ralith> bitemyapp: sounds nice
18:18:25 <jle`> Luke: what's up?
18:18:54 <Luke> jle`: how do you set up your Shakefile so it can be compiled etc?
18:19:35 <Luke> jle`: do you put it in your src folder?
18:19:48 <jle`> Luke: you don't compile it
18:19:53 <jle`> typically
18:20:00 <jle`> you would just runghc Shakefile.hs
18:20:06 <Luke> how do I ensure it type checks then?
18:20:22 <jle`> you can test runghc it
18:20:27 <jle`> or you can use hlint or ghc-mod
18:20:53 <Luke> no i mean how do you usually set it up with your projects?
18:20:57 <Luke> what do *you* do?
18:21:07 <jle`> how do i execute it?
18:21:17 <jle`> runghc Shakefile.hs
18:21:21 <Luke> yeah. where do you keep it in your project layout?
18:21:27 <jle`> oh in the project root
18:21:34 <jle`> the same place i would put my Makefile
18:21:44 <jle`> that's just me though
18:21:48 <Luke> how do you make ghc-mod know about it when it's in the project root?
18:21:51 <Luke> yeah that's what I was thining
18:21:54 <Luke> thinking*
18:22:16 <jle`> does ghc-mod check Shakefile.hs not work?
18:22:33 <jle`> i can't really integrate it with my project though heh.
18:22:47 <jle`> like i never got it to load modules from my project
18:23:04 <jle`> i think i tried at one point but didn't put too much effort into it
18:23:59 <flebron> What does f ~x = ... mean?
18:24:06 <Tekmo> flebron: That's a lazy pattern match
18:24:08 <Kron> it's a lazy pattern match
18:24:24 <jle`> Luke: are you trying to load modules from your project and script it using Shake?
18:24:31 <flebron> Isn't the standard pattern match lazy? (As opposed to !)
18:24:32 <Kron> it means that the argument is not evaluated before being bound to x to be used in the function
18:24:40 <issam> what does " !! " mean?
18:24:40 <Luke> jle`: no i'm just trying to be able to open in it emacs w/ ghc-mod and have it flymake check
18:24:47 <Kron> well you can only pattern match by evaluating something
18:24:47 <jle`> oh
18:24:48 <arkeet> :t (!!)
18:24:49 <lambdabot> [a] -> Int -> a
18:24:49 <Kron> think about this:
18:24:53 <Kron> foo [] =
18:24:56 <Kron> foo (x:xs) =
18:25:08 <Kron> for these to work, haskell has to check if the input is a [] or a cons
18:25:09 <jle`> Luke: I don't think i have ever had any problem with ghc-mod integration with my editor
18:25:13 <flebron> Right.
18:25:14 <Kron> lazy pattern matching avoids that
18:25:17 <Kron> so when you do
18:25:19 <jle`> i'm sorry but i can't help you too much there
18:25:20 <bitemyapp> jle`: Luke http://hackage.haskell.org/package/ghc-mod-3.1.4/docs/Language-Haskell-GhcMod.html
18:25:21 <Kron> foo ~(x:xs)
18:25:28 <Kron> it will actually pattern match [] as well
18:25:34 <Kron> it will assume that any input is x:xs
18:25:37 <Kron> this can be... useful
18:25:38 <Luke> jle`: np thanks
18:25:39 <Kron> but also dangerous
18:25:46 <Kron> you want to avoid it if you're not specifically looking for it
18:25:56 <flebron> Ah, OK :)
18:25:58 <flebron> Thanks!
18:26:07 <benmachine> flebron: re: your comment regarding !, ! only really makes sense on variable or wildcard patterns
18:26:08 <Kron> you're welcome!
18:26:18 <benmachine> flebron: f !x = something involving x
18:26:22 <jle`> i mostly use it to make my code look like ascii art
18:26:23 <Tekmo> flebron: The reason it is dangerous is because it desugars to partial functions
18:26:28 <jle`> f ~o = ... so cute!
18:26:32 <Kron> lol
18:26:40 <benmachine> is just as strict as if you'd pattern-matched on x
18:26:51 <Tekmo> flebron: `f ~(x:xs) = g x xs` is basically the same thing as `f ys = g (head ys) (tail ys)`
18:26:53 <Kron> best part about the ocaml (* comment syntax *) is putting (*_*) everywhere
18:26:54 <arkeet> lazy pattern match is useful for matching on tuples and such
18:26:57 <arkeet> in some recursoin
18:26:57 <Kron> let x = 1 (*_*)
18:27:02 <issam> arkeet can you plz show an example :)
18:27:09 <jle`> haha
18:27:10 <issam> im a noob at haskell
18:27:24 <arkeet> issam: list !! n gets the nth element of a list
18:27:24 <jle`> can't believe i never did that in my ocaml course
18:27:29 <arkeet> ['a','b','c'] !! 1
18:27:31 <jle`> i have a chance to put it on the final though.
18:27:34 <arkeet> > ['a','b','c'] !! 1
18:27:35 <lambdabot>  'b'
18:27:47 <issam> thanks arkeet!
18:27:53 <arkeet> issam: you know about hoogle?
18:27:55 <arkeet> @where hoogle
18:27:56 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
18:28:02 <arkeet> you can look it up on there for documentation
18:28:13 <jle`> @hoogle [a] -> Int -> a
18:28:14 <lambdabot> Prelude (!!) :: [a] -> Int -> a
18:28:15 <lambdabot> Data.List (!!) :: [a] -> Int -> a
18:28:15 <lambdabot> Prelude drop :: Int -> [a] -> [a]
18:28:16 <issam> sure thats good stuff
18:28:27 <issam> waw
18:28:55 <jle`> neat thing about haskell is that once you figure out the type signature you want, you can usually narrow it down pretty quickly
18:29:20 <Tekmo> The types become a language that you can use to converse with other Haskell programmers, too
18:29:31 <bitemyapp> jle`: showed how to find the function you want via type signature search in Hoogle to a buddy of mine I'm teaching Haskell. Showed him today.
18:29:40 <bitemyapp> type signatures are such nice documentation.
18:30:00 <jle`> i don't know what it is about haskell that makes it more useful in hs than in other languages though
18:30:14 <jle`> does someone with more insight care to elaborate
18:30:31 <jle`> is it because all functions are strongly typed and often polymorphic?
18:30:39 <Tekmo> jle`: My experience is that there are two big practical advantages to programming in Haskell
18:30:51 <twiceler> referential transparency!
18:30:54 <Tekmo> jle`: One is the type system, which greatly improves development speed and maintainability
18:31:09 <jle`> Tekmo: I mean specifically the reaosn why hoogle is more useful in Haskell than in other languages
18:31:16 <Tekmo> jle`: The second is the system of "design patterns" inspired by category theory
18:31:17 <twiceler> oh
18:31:27 <jle`> why type signatures are such a powerful information-conveyance tool
18:31:27 <Tekmo> jle`: Well, that's easy to answer
18:31:39 <benmachine> jle`: purity is one aspect
18:31:40 <Tekmo> jle`: If you ask Pyton what the type of a function is it will just say `<function>`
18:32:04 <jle`> it doesn't even say its arity? for shame.
18:32:12 <jle`> i guess it must be haskell's strong typong on functions
18:32:34 <twiceler> Since most other languages are not pure, I guess something like Bool -> Bool could launch missiles in other languages, right?
18:32:36 <Tekmo> jle`: This is not my area of expertise, but maybe it's because Python can't determine more until runtime
18:32:50 <twiceler> If we're not evil in Haskell, Bool -> Bool should be one of 4 possible things
18:32:54 <jle`> i think i read somewhere a long time ago that type signatures sometimes can even uniquely specify the exact implementation/behavior
18:32:55 <benmachine> jle`: purity means that what a Haskell function does is more often a part of its type
18:33:03 <benmachine> twiceler: right
18:33:04 <Tekmo> jle`: That's correct
18:33:15 <jle`> something like const :: a -> b -> a
18:33:20 <Tekmo> jle`: For example, ignoring cheating things there is only one function of type: `f :: (a, b) -> (b, a)`
18:33:23 <jle`> ther eis only one possible function that can have that type signature
18:33:31 <twiceler> Right
18:33:51 <alpounet> twiceler: it could read the resulting Bool from a JSON service
18:33:58 <jle`> is this somewhat related to that curry-howard correspondance
18:34:03 <jle`> (is it howard)
18:34:08 <benmachine> jle`: it is howard
18:34:22 <benmachine> but honestly I think CH is only loosely if ever related to Haskell programming
18:34:32 <jle`> how sometimes proving that the types check out is as powerful as proving a computation
18:34:44 <benmachine> under the correspondence, Haskell's type system corresponds to a pretty boring logic
18:34:53 <benmachine> though not quite so boring as that of mainstream programming languages
18:35:04 <Tekmo> benmachine: lol
18:35:17 * hackagebot Paillier 0.1.0.1 - a simple Paillier cryptosystem  http://hackage.haskell.org/package/Paillier-0.1.0.1 (onemouth)
18:35:44 <jle`> anyways haskell is cool.
18:36:22 <twiceler> jle`: I'm not sure. I know like NO category theory at all, but I think it might be related to all the "free" things - like the most general things
18:36:40 <Tekmo> twiceler: I think there is a category theory way to prove it
18:36:50 <twiceler> jle`: Like a function of type Show a => a -> String is f . show where f :: String -> String
18:37:00 <Tekmo> twiceler: I think it involves proving that it is isomorphic to `()`
18:37:16 <Tekmo> twiceler: However, that might be overkill
18:37:41 <benmachine> the free theorem for a -> b -> a pretty much gives you that it is const
18:39:28 <eyebloom> Is there a way to specify where a file is in an import statement?
18:40:03 <benmachine> eyebloom: no, GHC expects a particular directory structure based on the name
18:40:17 <ParahSailin> eyebloom: no, your options are to copy shit to cwd or use cabal
18:40:40 <benmachine> well actually it depends what you mean
18:40:56 <benmachine> you can tell GHC which directories to look in for source files
18:41:40 <heatsink> Often, a large part of an imperative library's interface is in the rules about how to encode what you want to do as a sequence of commands
18:41:48 <heatsink> So the types aren't that informative
18:41:55 <arkeet> @free const :: a -> b -> a
18:41:56 <lambdabot> f . const x = const (f x) . g
18:41:57 <eyebloom> benmachine: how does that directory structure work
18:42:17 <benmachine> eyebloom: My.Favourite.Module is expected to be in My/Favourite/Module.hs
18:42:23 <ParahSailin> eyebloom: java style
18:42:40 <jle`> how about something like const' :: Monoid a => a -> b -> a ?
18:42:53 <twiceler> arkeet: what is @free?
18:42:53 <jle`> that no longer is required to be const right?
18:43:07 <arkeet> twiceler: derives a free theorem given a type. see wadler's paper "theorems for free!"
18:43:27 <eyebloom> I'm getting a failed to load interface message for 'InteractiveUI' when I'm trying to compile GHC on a mac and the file is in the same directory as Main.
18:43:32 <jle`> because your function can return mempty
18:43:37 <jle`> instead of a
18:44:03 <jle`> does the monoid constraint make it outside of the domain of free theorem stuff
18:44:42 <ion> That’s const' :: a -> (a -> a -> a) -> a -> b -> a.
18:44:49 <heatsink> Is the file named InteractiveUI.hs and is it in the current directory when you run ghc?
18:45:24 <heatsink> or InteractiveUI.lhs
18:45:44 <eyebloom> no I'm a level up from that directory.
18:46:18 <heatsink> You can use -i src on the command line to tell ghc to search in the 'src' directory
18:46:18 <jle`> ion: come again? are you saying that it is the same as const but passing in mempty and mconcat?
18:46:51 <triliyn> jle`: a monoid function can also return a <> a and things like that too
18:46:59 <eyebloom> But I think commenting out the individual imports seemed to solve the problem
18:47:13 <ion> jle: Monoid a => foo is like a -> (a -> a -> a) -> foo
18:47:44 <jle`> ion: are you saying that you implicitly pass in mempty and mconcat as parameters?
18:47:51 <shachaf> ion: Except easier.
18:48:05 <jle`> that makes sense
18:48:13 <ion> mempty and mappend (i was ignoring mconcat).
18:48:19 <jle`> oh yes i mean mappend
18:48:27 <jle`> i mix up all of these things way too often
18:48:32 <ion> shachaf: And more loveable
18:48:34 <heatsink> I don't see how commenting out the import could solve anything, unless you don't actually need the imported module
18:48:47 <jle`> yesteday i called mzero empty
18:49:34 <jle`> can we just start over with the library some day
18:49:35 <heatsink> mzero and mplus do make a monoid
18:49:53 <Aune> jle`, It still has free theorems, the monoid constraint gives us more alternatives though. Such as    f :: (Monoid a) => a -> b -> a  cant do anything with b cause we dont have any information about what b could be. But f a b = a or f a b = mempty or f a b = a <> a or f a b = a <> a <> a ...
18:50:14 <jle`> Aune: ah that makes sense
18:50:19 * hackagebot Paillier 0.1.0.2 - a simple Paillier cryptosystem  http://hackage.haskell.org/package/Paillier-0.1.0.2 (onemouth)
18:50:23 <jle`> it might not be exactly const, but it can't possibly depend on b
18:50:36 <jle`> perhaps what i really meant to say was
18:50:48 <jle`> const'' :: Monoid b => a -> b -> a
18:50:49 <jle`> ?
18:51:05 <twiceler> jle`:  That's still const
18:51:12 <triliyn> hmmm, Monoid a => a -> b -> a is isomorphic to the type of natural numbers I think
18:51:36 <triliyn> twiceler: it can return mempty or b or b <> b or b <> b <> b or ...
18:51:36 <startling> triliyn: how's that?
18:51:37 <Aune> jle`, it still cant depend on b. So the monoid constraint adds no new information
18:51:39 <arkeet> assuming all monoid instances are lawful, yes.
18:51:41 <jle`> triliyn: you aren't incorrect; the natural numbers form a monoid under two popular binary operations
18:51:44 <arkeet> startling: same as Monoid a => a -> a
18:51:49 <twiceler> triliyn:  it returns a type a
18:51:54 <startling> arkeet: oh.
18:52:06 <jle`> Aune: how about making them both be Monoids?
18:52:10 <triliyn> twiceler: oh right, never mind
18:52:13 <startling> I wouldn't call that ismomorphic I guess?
18:52:22 <jle`> then maybe we can return mempty :: a if b == mempty :: b
18:52:26 <startling> jle`, making them both monoids doesn't let you combine them
18:52:29 <jle`> or b otherwise
18:52:32 <arkeet> startling: sure it's isomorphic.
18:52:38 <jle`> er, or a otherwise
18:53:18 <startling> jle`, that needs Eq, too
18:53:28 <jle`> so throw in Eq then.
18:53:31 <startling> arkeet: I guess you're right.
18:53:36 <jle`> then is it no longe const?
18:53:38 <twiceler> We can certainly have
18:53:44 <triliyn> startling: for the isomorphism thing, functions of that type have to return either mempty or foldr (<>) mempty (replicate n a) for some n
18:53:51 <jle`> const a mempty = mempty; const a _ = a
18:54:03 <twiceler> f :: Monoid a => Nat -> (a -> a)
18:54:04 <triliyn> (And mempty fits that pattern with n = 0)
18:54:05 <jle`> const :: (Monoid a, Monoid b, Eq b) -> a -> b -> a
18:54:30 <twiceler> but you might not be able to make
18:54:38 <twiceler> g :: Monoid a => (a -> a) -> Nat
18:54:40 <jle`> does adding those three constraints suffice to make an a -> b -> a not be const?
18:54:42 <arkeet> triliyn: well, not quite, since you might have some non-lawful monoid instances lying around. ;)
18:55:01 <triliyn> arkeet: of course, we're assuming they conform to the laws
18:55:33 <twiceler> never mind about what I just said
18:55:34 <triliyn> I was looking at the idris prelude source yesterday and I was disappointed that classes don't contain proofs of the class laws
18:55:39 <Aune> jle`, if you throw in Eq AND Monoid for b and Monoid for a then you can do f a b = if b == mempty then a else mempty
18:56:14 <triliyn> Some of the Prelude.Algebra types have proofs, but they're sequestered in classes like VerifiedMonoid
18:56:42 <triliyn> VerifiedJoinBoundedSemilattice
18:57:30 <startling> triliyn: yeah, I don't like it either
18:57:44 <startling> edwinb is pretty set on that, though
18:57:51 <triliyn> oh?
18:57:53 <jle`> i guess i'm asking for a general "what does it take" to kill const
18:57:54 <triliyn> I wonder why that is
18:58:10 <startling> triliyn: you can ask him in #idris
19:00:13 <rabipelais> Hello people, I am having trouble installing Threadscope. When compiling the version from hackage I get a lot of "ambiguous occurence `height'" referring to either `GUI.Types.height' or `Graphics.Rendering.Cairo.height'. I am somewhat new to haskell, and am trying the book "Parallel and concurrent Haskell"
19:00:56 <twiceler> rabipelais: It means that it there is a "height" variable imported from both GUI.Types and Graphics.Rendering", and it doesn't know which one you mean
19:01:06 <jle`> how unfortunate
19:01:12 <Tekmo> rabipelais: Sounds like one of those two packages started exporting `height` in a recent version
19:01:26 <twiceler> rabipelais: So you probably want to hide the height in the import from the one you don't want
19:01:28 <Tekmo> rabipelais: You'd have to lock in `Threadscope` to depend on an older version of whichever package that was
19:01:43 <twiceler> oh, I see; it's not your own code
19:01:49 <Tekmo> rabipelais: I'm not exactly sure how to do that, but maybe somebody else here knows how
19:02:10 <rabipelais> oh, yeah, it's not my code, it's from the threadscope package
19:02:51 <Tekmo> rabipelais: I mean, in the worst case scenario you could just download the threadscope package and modify it and then compile that
19:02:56 <rabipelais> Tekmo: thanks, may I will try downgrading the Cairo package, and see if it didn't export that variable then
19:10:48 <ReinH> rabipelais: what OS/platform?
19:15:34 <maxs_> rabipelais: I recommend downloading the binary for Threadscope, if possible.
19:15:49 <rabipelais> ReinH: Linux (Arch)
19:17:23 <maxs_> rabipelais: unfortunately there is no linux binary :(
19:22:39 <Clint> cmdargs-0.10.6/System/Console/CmdArgs/Explicit/Complete.hs: time stamp 2051-01-26 08:39:10 is 1171794296.421239608 s in the future
19:22:42 <Clint> impressive
19:29:27 <rabipelais> Tekmo: I downloaded the code for Threadscope, and hid some imports from the Cairo Libraries. It now compiles and works (not thoroughly tested). Is this something I should report to someone?
19:30:19 <Tekmo> rabipelais: Yes.  The Hackage page says that the official bug tracker for ThreadScope is: http://trac.haskell.org/ThreadScope/
19:35:20 <mcjohnalds> I want to develop 3d games in Haskell, what's the best 3d game engine? (full game engine, not just rendering or something)
19:35:24 * hackagebot pandoc 1.12.2.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.12.2.1 (JohnMacFarlane)
19:35:39 <rabipelais> Tekmo: Thanks for the help and the patience. I sent the ticket.
19:35:46 <Tekmo> rabipelais: You're welcome
19:36:19 <rabipelais> (by the way: awesome and very helpful community you've got here ;) )
19:38:43 <twiceler> mcjohnalds: I think non-existent :(
19:39:24 <twiceler> mcjohnalds: The only one I've heard of is is HGamer3D, which I think is based on Ogre
19:40:03 <mcjohnalds> That one looked great, but it's windows only :(
20:04:06 <Luke> hmm I still can't seem to get Shake to compile correctly: http://lpaste.net/96778
20:04:35 <johnw> can I see Shakefile.hs?
20:07:05 <Luke> http://blog.jle.im/entry/shake-task-automation-and-shell-scripting-in-haskell#completed-file
20:07:11 <Luke> this exact file
20:07:31 <Luke> it seems it can't even find the Development.Shake import
20:09:59 <johnw> all you should need to do is "cabal install shake"
20:10:10 <johnw> that's the extent of what I do
20:10:20 <johnw> do you have a command "shake" on your PATH?
20:10:30 <johnw> in this case, you make need to run "shake", instead of runhaskell?
20:10:33 <johnw> i'm not sure though
20:12:10 <Luke> shake is on my path and yeah, i installed it
20:12:20 <johnw> GHC 7.6.3?
20:12:22 <Luke> let me try running shake
20:12:24 <Luke> yeah
20:12:51 <Luke> running shake as a binary ran but just said it couldn't find my Makefile
20:13:06 <johnw> we need to Neil on tap :)
20:14:04 <Luke> johnw: dang =(
20:14:18 <johnw> don't suppose I could have an anonymous ssh into your system to debug? :)
20:17:48 <enthropy> Luke: I think you should look into why you have -XOverloadedStrings enabled
20:18:30 <enthropy> it's not suggested by that file, or the command line you have
20:19:27 <enthropy> doesn't seem runhaskell looks at a .ghci file
20:24:44 <Luke> enthropy: you saying i have it enabled or shouldn't?
20:24:55 <enthropy> enabled and it shouldn't be enabled
20:25:35 <enthropy> and since there's no reason it should be enabled, something is inconsistent in the information you've provided
20:27:17 <startling> can you tell me anything interesting about "(f a -> f b) -> e f a -> e f b"?
20:27:44 <johnw> isn't that just fmap over e?
20:27:51 <startling> johnw, no
20:27:55 <arkeet> not quite
20:27:58 <johnw> i guess that would be e (f a) -> e (f b)
20:28:00 <arkeet> yes
20:28:05 <arkeet> it's an HFunctor.
20:28:06 <startling> johnw: you can map Nothing to Just something
20:28:10 <startling> arkeet: HFunctor?
20:28:19 <arkeet> I gave you a fish to look up.
20:28:19 <startling> what's H?
20:28:26 <arkeet> probably "higher" or something.
20:28:27 <johnw> it's not "hoist" either, which is one level up
20:28:37 <startling> johnw: yeah, I've been playing with mmorph
20:28:39 <Luke> enthropy: an yeah it's enabled by by ghci config or something
20:28:42 <Luke> you think that's the problem?
20:28:43 * startling goes fishing
20:28:46 <arkeet> oh maybe it's not that.
20:29:11 <arkeet> but maybe it is.
20:29:46 <arkeet> hmm.
20:29:56 <startling> hmap looks a lot like MFunctor
20:30:01 <startling> I mean
20:30:03 <arkeet> http://hackage.haskell.org/package/category-extras-0.53.5/docs/Control-Functor-HigherOrder.html
20:30:07 <startling> HFunctor looks a lot like MFunctor
20:30:16 <arkeet> I don't know what MFunctor is.
20:30:31 <johnw> it's like a generalization of what functions like transResourceT do
20:30:36 <johnw> where e in that case is ResourceT
20:30:46 <johnw> oh, not quite
20:30:47 <johnw> that changes f
20:31:05 <startling> it's in mmorph; it provides hoist :: (forall a. f a -> g a) -> e f a -> e g a
20:31:14 <startling> there's a Monad _ => somewhere in there
20:31:36 <startling> my thing's an MFunctor too but that doesn't let me do anything interesting :(
20:31:57 <johnw> startling: what do you know about 'e'?
20:33:40 <johnw> because "fmap lift" will give the right return type, but you'd need some kind of "lmap runE" to make the input work, or a transET that maintains f -- but that requires knowledge of each specific E
20:33:56 <Tekmo> startling: So I suspect that your `e` might be a monad of some sort
20:34:08 <Tekmo> startling: In other words, I would also expect a function of type
20:34:40 <Tekmo> startling: otherFunction :: (forall a . e (e f) a -> e (e g) a) -> e f b -> e g b
20:34:55 <startling> this is the structure i'm looking at in general: https://gist.github.com/startling/613e660f26cd4b4dcf56
20:35:46 <startling> I think it's Applicative e => Applicative (Abstract e) and Monad e => Monad (Abstract e), but I can't see a nice way to do it and it takes forever to enumerate the possibilities
20:35:53 <Tekmo> startling: So why do you separate out the `e` and the `a`
20:36:01 <Tekmo> startling: Couldn't you combine them into a single type variable?
20:36:09 <startling> Tekmo, Scope is sort of like "Bind e (Maybe a)"
20:36:15 <Tekmo> startling: Oh wait, yeah
20:36:21 <Tekmo> startling: I just saw that Scope requires them separate
20:36:25 <startling> yeah.
20:36:33 <startling> (it's a lambda term thing)
20:36:50 <startling> then newtype Term a = Term (Abstract Term a)
20:39:32 <startling> e is probably a functor at least
20:39:47 <startling> I can write "(e a -> e b) -> Abstract e a -> Abstract e b" if e is a Functor
20:41:41 <startling> if I have that, 5 of the 9 cases are trivial
20:42:02 <startling> I'm not sure about Monad e => Monad (Abstract e) though
20:44:27 * startling is just overarchitecting ASTs
20:45:11 <startling> the nice thing about the "open" version of this is that I can overload a lot of things for tagged-with-source-information versions
21:01:36 <swineflu> http://www.haskell.org/haskellwiki/Euler_problems/61_to_70 <- Can someone tell me what going on in problem 67 here?
21:03:52 <arkeet> swineflu: what part?
21:04:23 <edwardk> @tell dibblego i don't have an argument in defense of the name 'pure', I use it because it is used in Applicative, thats it.
21:04:24 <lambdabot> Consider it noted.
21:04:26 <arkeet> might help to write out the types of things
21:05:35 * hackagebot semigroups 0.12.0.1 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.12.0.1 (EdwardKmett)
21:06:07 <swineflu> arkeet: the step function
21:06:15 <swineflu> I know its recursive but i just dont follow
21:06:20 <djahandarie> There's nothing like an unadulterated function. Only 24 carat functions can be instances of applicative.
21:07:09 <startling> highPriestLOL, can you please change your nick less often?
21:07:58 <djahandarie> No wonder Haskell Jewelers always has the purest stuff.
21:08:49 <osa1> is there a parameter in GHC/Cabal for just typechecking?
21:08:58 <johnw> -fno-code
21:09:11 <johnw> but mind, it won't handle Template Haskell, and some warnings will not appear
21:10:34 <arkeet> swineflu: maybe see what it does on some smaller examples
21:11:38 <arkeet> swineflu: also note + has higher precedence than :
21:11:40 <arkeet> ( x + max y z) : step xs (z:zs)
21:15:41 * hackagebot reducers 3.10.1.1 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-3.10.1.1 (EdwardKmett)
21:15:43 * hackagebot bytes 0.13.0.1 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.13.0.1 (EdwardKmett)
21:20:02 <dirk103> heyo
21:20:23 <dirk103> so when i   3 `elem` [1, 2, 3, 4]
21:20:41 <dirk103> the ` only use in haskell is to allow me to put a function between its inputs
21:20:42 <dirk103> ?
21:20:50 <johnw> yep
21:20:57 <johnw> it makes a function into an infix operator of sorts
21:21:16 <johnw> foo 1 2 or 1 `foo` 2.  1 == 2 or (==) 1 2
21:21:38 <raphie> thinking of re-writing this with haskell: http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/ as a little learning project
21:21:49 <raphie> read it, thought about the barbarism of manually managing a linked-list
21:22:50 <dirk103> infix thats it
21:23:19 <dirk103> how come == doesnt need ` around it?
21:23:33 <johnw> because it's an opertaor
21:23:35 <johnw> operator
21:23:45 <johnw> it's name is composed of "operator characters"
21:24:04 <dirk103> ok
21:27:16 <startling> dirk103, elem 3 [1, 2, 3, 4] -- this is the same thing
21:28:17 <dirk103> ya
21:30:10 <startling> raphie, heh
21:30:25 <startling> it's definitely doable in Haskell!
21:30:43 * hackagebot wl-pprint-extras 3.5 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-3.5 (EdwardKmett)
21:35:43 * hackagebot wl-pprint-terminfo 3.7 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-3.7 (EdwardKmett)
21:38:28 <startling> I guess a class Pointerful a where pointers :: Simple Traversal a (forall e. Ptr e) would be the way to do it
21:40:05 <startling> a Fold, rather
21:40:44 * hackagebot parsers 0.10.1.2 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.10.1.2 (EdwardKmett)
21:40:46 * hackagebot intern 0.9.1.2 - Efficient hash-consing for arbitrary data types  http://hackage.haskell.org/package/intern-0.9.1.2 (EdwardKmett)
21:46:59 <edwardk> you can't write a fold that takes an impredicatively qualified argument like that
21:47:24 <edwardk> best you can get is Simple Traversal a (Ptr Void) but i haven't tuned into why you want it, just that the solution wasn't going to work =)
21:47:34 <startling> edwardk: aw, really? darn.
21:48:05 <startling> raphie was talking about writing a mark-and-sweep garbage collector in haskell.
21:48:28 <startling> I guess pointers :: a -> [forall e. Ptr e] works just as well, but isn't as fancy
21:48:36 <edwardk> you mean like the er one we already have?
21:48:42 <raphie> wait what's forall? haven't seen that before
21:48:59 <edwardk> raphie: google 'rank-n types in haskell'
21:49:18 <startling> edwardk, exactly :)
21:49:36 <startling> I think you'd need ExistentialQuantification too
21:51:29 <edwardk> well, its worse than that, you just can't write them
21:51:43 <edwardk> bcause there is an impredicative use of it
21:52:32 <johnw> what does "impredicative" mean in this context?
21:53:24 <johnw> is it the fact that he can't just manufacture an abstract type?
21:53:42 <edwardk> [forall a. a]
21:53:49 <edwardk> is different than forall a. [a]
21:53:53 <johnw> right
21:54:00 <edwardk> the former is impredicative
21:54:13 <johnw> so even if he fixes "a" at some type, he can't use it to make a forall e. Ptr e
21:54:14 <edwardk> http://www.haskell.org/haskellwiki/Impredicative_types
21:54:28 <johnw> thanks, will read
21:55:20 <joejev> can anyone explain this error? failed to parse haddock prologue from file: dist/doc/html/diophantine/haddock-prolog1553.txt
21:55:46 * hackagebot semigroups 0.12.1 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.12.1 (EdwardKmett)
21:57:59 <nurupo> :t forall
21:58:00 <lambdabot>     Not in scope: `forall'
21:58:00 <lambdabot>     Perhaps you meant `forAll' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
21:58:10 <johnw> forall is syntax
21:58:38 <shachaf> > let forall = 2; 2 + 2 = 5 in forall + forall
21:58:39 <lambdabot>  5
21:58:49 <johnw> touché
21:59:09 <newsham> > let 2 + 2 = 5 in 4 + 4
21:59:11 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
22:00:06 <newsham> > let 2 + 2 = 5; 4 = 2 + 2 in 4 + 4
22:00:08 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
22:00:23 <newsham> stupid bot
22:00:24 <dmj`> > let a@b:c = 1:2:3:[]
22:00:26 <lambdabot>  not an expression: `let a@b:c = 1:2:3:[]'
22:00:43 <dmj`> @def a@b@c = 1:2:3:[]
22:00:43 <lambdabot>  .L.hs:160:1:
22:00:44 <lambdabot>      Multiple declarations of `a'
22:00:44 <lambdabot>      Declared at: .L.hs:155:1
22:00:44 <lambdabot>                   .L.hs:160:1
22:00:46 * hackagebot lens 3.10.0.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.10.0.1 (EdwardKmett)
22:00:54 <johnw> > let 2 + 2 = 5 in 2 + 2
22:00:56 <lambdabot>  5
22:01:27 <nurupo> > let 2 = 1.999999999999999999999999999999; in 2 + 2
22:01:29 <lambdabot>  4
22:02:09 <newsham> > let let = let in let
22:02:10 <lambdabot>  <hint>:1:9: parse error on input `='
22:02:40 <nurupo> > let let = let in let 2 = 1.999999999999999999999999999999; in 2 + 2
22:02:42 <lambdabot>  <hint>:1:9: parse error on input `='
22:03:11 <newsham> > let haskell = id in haskell $ nubBy (\a b -> a `mod` b == 0) [2..]
22:03:12 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:03:30 <newsham> haskell++
22:04:33 <arkeet> > let 2 = 1 in 2 + 2
22:04:34 <lambdabot>  4
22:05:40 <enthropy> > let 2 + 2 = 5 in 2 + 2
22:05:41 <lambdabot>  5
22:05:55 <nurupo> > let + = +- in 2 + 2
22:05:56 <lambdabot>  <hint>:1:5: parse error on input `+'
22:05:59 <nurupo> > let + = - in 2 + 2
22:06:01 <lambdabot>  <hint>:1:5: parse error on input `+'
22:06:07 <pavonia> What is "2 = 1" defining?
22:06:08 <newsham> > let (+) = (-) in 2 + 2
22:06:08 <enthropy> you need parentheses
22:06:09 <lambdabot>  0
22:06:32 <nurupo> #define false true
22:07:46 <Redz> getChanContents never finish, right?
22:08:34 <joejev> what would cause this error on
22:08:47 <joejev> cabal haddock failed to parse haddock prologue from file: dist/doc/html/diophantine/haddock-prolog1553.txt
22:16:41 <dmj`> joejev: I'm not entirely sure, but it seems someone else has had this
22:16:42 <dmj`> same issue here: http://trac.haskell.org/haddock/ticket/183
22:17:59 <johnw> Redz: pretty easy to test
22:19:44 <Redz> i saw the code of getChanContents. it seems so.
22:20:49 * hackagebot linear 1.3.1.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.3.1.1 (EdwardKmett)
22:30:20 <lispy> > let !2 = 1 in 2 + 2
22:30:22 <lambdabot>  *Exception: <interactive>:3:5-10: Non-exhaustive patterns in pattern binding
22:30:51 <lispy> arkeet: let 2 = 1 is a pattern match not a definition
22:30:57 <arkeet> I know.
22:31:37 <lispy> arkeet: ah okay. I guess it was pavonia that asked about it
22:31:38 <arkeet> :)
22:32:02 <gamegoblin> simpson: parsec has been a pleasure to use (though I still think simple regex support would be nice too...)
22:32:48 <johnw> gamegoblin: try http://hackage.haskell.org/package/regex-applicative
22:33:03 <pavonia> lispy: Oh, I see
22:33:16 <lispy> gamegoblin: I still prefer the non-monadic parsers. like happy.
22:33:41 <lispy> gamegoblin: with parsec probably the most common bugs revolve around try
22:33:51 <gamegoblin> why?
22:34:07 <lispy> gamegoblin: and with happy it can tell you where the equivalent problems are (warnings about shift/reduce and reduce/reduce conflicts)
22:34:16 <Cale> I actually kind of like ReadP if I'm just writing a small simple parser.
22:34:19 <lispy> gamegoblin: parsec doesn't backtrack unless you tell it to
22:34:28 <Cale> Because it doesn't need try
22:34:55 <lispy> gamegoblin: So if one combinator consumes input and then fails the next combinator picks up at that point in the input, not at the input when the other combinator started...unless you put a try there.
22:35:31 <johnw> yeah, you do have to think about failure a lot when writing parsec parsers
22:35:49 <lispy> gamegoblin: where you need trys is not terribly local either. You frequently need to understand a fair bit of the grammar at once.
22:36:00 <zomg> I was working with parsec and it actually felt sort of logical in that you need to "try parser1 or parser2 or parser3"
22:37:37 <lispy> gamegoblin: On the other hand, I do think parsec is one of those things every haskell programmer should learn.
22:37:55 <johnw> they are great for quick and dirty parsing
22:38:08 <johnw> and sometimes, regex-applicative is enough, with a very similar interface
22:39:39 <Cale> zomg: Probably you actually need to try parser2 as well
22:40:02 <Cale> (because if it consumes input before failing, then parser3 won't be tried)
22:40:26 <joejev> dmj`: hmm, the thing is I dont have any code blocks in the docs
22:41:32 <simpson> lispy: Funny that you should say that; I wrote a parser earlier with parsers and trifecta and the *only* thing biting me was `try`.
22:42:21 <edwardk> try should, in general only ever be used around some kind of lexical recognizer or places with known ambiguity in your grammar
22:44:16 <dmj`> joejev: None in the cabal file?
22:45:09 <simpson> edwardk: The problem that bit me hardest was that something like `double <|> natural` (with the appropriate type-adjustments of course) fails to parse integers, at least on trifecta.
22:45:13 <joejev> dmj`: http://lpaste.net/96779
22:45:36 <edwardk> simpson: there is literally a naturalOrDouble parser in there for that reason =)
22:45:40 <simpson> Because `double` consumes the integral part and then expects an exponent or radix mark or something else float-like...
22:46:02 <edwardk> http://hackage.haskell.org/package/parsers-0.10.1.2/docs/Text-Parser-Token.html#v:naturalOrDouble
22:46:10 <simpson> edwardk: Yeah, I know, but I haven't done this in Haskell in a while. I'm still used to PEGs.
22:46:30 <lispy> simpson: there is a peg generator library on hackage, IIRC
22:46:30 <simpson> And I want my parser to *always* be okay with backtracking. I'm just not used to this partial-commit thing.
22:46:43 <simpson> lispy: But edwardk's parsers library is so helpful!
22:46:44 <lispy> simpson: http://tanakh.github.io/Peggy/
22:46:50 <simpson> Haskell-world problems. :c
22:47:08 <sopvop> heh, I needed to parse language which allows floats to omit 0 before dot. like: .1 == 0.1, .05 == 0.05
22:47:11 <edwardk> if it always backtracks then you always have to deal with all the result continuations, you can never prune them away, your parser leaks memory all over.
22:47:41 <edwardk> spaceships: you can write a different parser for them, the ones that are supplied are pretty simplistic and mostly haskell-like
22:48:14 <edwardk> the main thought that went into them went into making them work well with code folks already had in parsec and just cleaning them up a bit
22:50:45 <dmj`> joejev: remove line #20 in your cabal file and run it again
22:50:52 * hackagebot monad-logger 0.3.3.1 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.3.1 (MichaelSnoyman)
22:52:11 <joejev> dmj`: same error
22:52:24 <dmj`> joejev: not for me
22:53:12 <dmj`> joejev: oh wait
22:53:42 <dmj`> joejev: remove the entire description
22:55:05 <joejev> dmj`: that worked, hmm, the only thing I changed in the project was I added another module, do I need to do something special to do that?
22:58:34 <dmj`> joejev: I think the description field you have is malformed.
23:00:09 <joejev> dmj`: This is why I am confused though: http://hackage.haskell.org/package/diophantine-0.1.0.0
23:00:24 <joejev> look at the package descr, nothing changed yet now it doesn't work
23:02:38 <dmj`> joejev: I think you need to give it time, and it will generate on
23:02:38 <dmj`> hackage. Your project generates nice haddock output for me locally.
23:03:59 <joejev> dmj`: what I meant was that I just made a change, and added another module, it made nice local docs before with what I had, but now, after the changes, it will not make docs
23:04:11 <joejev> if I have a description field
23:06:25 <Sgeo> :t foldr
23:06:26 <lambdabot> (a -> b -> b) -> b -> [a] -> b
23:06:35 <Sgeo> :t foldr (>>=)
23:06:36 <lambdabot>     Occurs check: cannot construct the infinite type: b0 = a0 -> b0
23:06:37 <lambdabot>     Expected type: (a0 -> a0) -> (a0 -> a0 -> b0) -> a0 -> a0 -> b0
23:06:37 <lambdabot>       Actual type: (a0 -> a0) -> (a0 -> a0 -> b0) -> a0 -> b0
23:06:52 <Sgeo> :t foldr (>=>)
23:06:54 <lambdabot> Monad m => (b -> m c) -> [b -> m b] -> b -> m c
23:07:58 <lightquake> what's up with hackage generating haddock with file:// urls?
23:08:49 <dmj`> joejev: It's because you haven't exposed that module in the cabal file
23:09:09 <dmj`> joejev: exposed-modules:     Math.Diophantine, Math.OtherModule
23:09:32 <joejev> the other module is Math.Diophantine.Internal
23:09:37 <joejev> or is that not how it works?
23:10:50 <dmj`> joejev: I believe only exposed modules get documentation
23:11:15 <joejev> dmj`: Can I not expose Math.Diophantine.Internal ?
23:11:33 <dmj`> joejev: well, it's internal, you could, but are you sure you want to?
23:12:05 <joejev> dmj`: Maybe I should rename it to Unsafe, and then prefix the functions with unsafe
23:13:25 <joejev> dmj`: Basically, it is all the functions solve will call AFTER it has converted the GeneralEquatuon into a particular type, so they can throw errors if the equations are not correct, so I didn't want them exposed by default, but I also thought that I should offer them incase people wanted to call them directly
23:16:55 <dmj`> joejev: Then yes, they would need to be exposed to be used.
23:18:07 <joejev> dmj`: so, did I not expose them properly in the .cabal file?
23:18:15 <joejev> if so, then why is it not parsing?
23:19:40 <dmj`> In the cabal file you need to specify your exposed modules, you currently are only exposing Math.Diophantine, to generate documentation for all modules you'll need to specify Math.Diophantine.Unsafe as well
23:21:40 <joejev> dmj`: is this the proper syntax for that? exposed-modules:     Math.Diophantine, Math.Diophantine.Internal
23:21:49 <joejev> where those are the two I want to expose
23:22:03 <dmj`> joejev: yes
23:22:56 <joejev> hmm, well that is what I have
23:30:24 <dmj`> joejev: You need to make a folder for Internal
23:31:54 <joejev> A folder, the structure is I have a folder Math, inside that there is a file Diophantine.hs, and a directory Diophantine, in the Diophantine directory, there is a file, Internal.hs
23:32:16 <joejev> do I need to mark the sources directory or something, right now it is just '.'
23:32:24 <arkeet> you need a Math/Diophantine.hs and Math/Diophantine/Internal.hs
23:33:18 <joejev> arkeet: that is what I have, the project builds fine, it is just that the cabal haddock fails
23:33:31 <arkeet> ah.
23:33:50 <arkeet> with what error?
23:34:02 <joejev> arkeet: and it only failed after I added a new module, the old one was fine, and the error is: haddock: failed to parse haddock prologue from file: dist/doc/html/diophantine/haddock-prolog2537.txt
23:34:15 <joejev> sort of cryptic
23:34:25 <arkeet> hm, what if you remove dist/doc and start fresh?
23:34:33 <joejev> I tried
23:34:36 <arkeet> hmm
23:34:57 <arkeet> I'm out of ideas.
23:35:25 <joejev> it worked when I got rid of the description field, even though it is the exact same as before i added the other module
23:35:30 <joejev> that is very confusing to me
23:35:54 <arkeet> weird.
23:36:15 <augur> is there a way to use parsec to specify CFGs with parameterized rules?
23:36:23 <dmj`> joejev: https://dl.dropboxusercontent.com/u/10021156/dio.png
23:36:46 <dmj`> joejev: exposed-modules:     Math.Diophantine, Math.Diophantine.Internal
23:37:04 <joejev> isn't that what I have
23:37:20 <arkeet> mind sharing the .cabal file?
23:37:58 <joejev> http://lpaste.net/96779
23:38:22 <joejev> so, it works if you make the description feild blank
23:39:56 <joejev> also, that is how I have it structured dmj` http://i.imgur.com/jRjOz8M.jpg
23:40:47 <dmj`> joejev: In the Internal.hs file is your module name specified correctly? Math.Diophantine.Internal
23:41:00 <arkeet> ok, I get the same error here
23:41:33 <joejev> dmj`: yes, I dont think it would build in ghci without that
23:42:28 <arkeet> joejev: it's not liking the @ in your email address
23:42:36 <arkeet> haddock, that is
23:42:39 <joejev> should I escape?
23:42:42 <arkeet> in the description
23:42:46 <arkeet> yes
23:43:19 <joejev> even with an escaped @ it failed
23:43:36 <arkeet> using \@ ?
23:43:38 <arkeet> that fixed it for me...
23:44:00 <joejev> yes
23:44:17 <dmj`> fixed it for me too
23:45:24 <joejev> arkeet: I am dumb, I was only changing it in the maintainer field, that fixed it for me
23:45:31 <arkeet> yes, don't change the maintainer field.
23:45:54 <arkeet> only change the description
23:46:06 <arkeet> I should have been more clear, sorry. :P
23:46:16 <joejev> no no, thank you all so much for that
23:47:04 <joejev> however, should I name the module Math.Diophantine.Internal, or Math.Diophantine.Unsafe, where the idea is that the function that it exports might call error if used imporperly
23:48:53 <startling> joejev, do you have safe versions?
23:49:25 <arkeet> I think Internal is fine.
23:49:31 <arkeet> Unsafe is more for stuff that's actually unsafe
23:49:38 <arkeet> like lets you potentially do unsafePerformIO/unsafeCoerce
23:49:45 <arkeet> to me, anyway
23:50:30 <joejev> startling: basically, I have the Diophantine module export only one Equation constructor, the GeneralEquatuon, and then the function 'solve' determines the type and calls the proper solve function for it and converts the type, and also, I agree that it really isn't unsafe in the way something with an FFI is unsafe
23:51:11 <joejev> I think that a warning in the docs, and the fact that it is called Internal should be enough warnign that these might not be the best to use if you are not sure.
23:51:11 <jle`> anyone interested in tearing apart my MonadPlus series targeted at intermediate haskellers http://blog.jle.im/entry/id/12
23:51:34 <jle`> it's not posted yet
23:51:37 <startling> joejev: yeah, .Internal seems fine to me too
23:53:10 <begriffs> jle`: reading it now. That's a lot of writing!
23:53:57 <jle`> begriffs: yeah...i tend to write too much.  what was the three-part series was intended to be all one article
23:54:10 <jle`> but the reason i ended up spending an entire article explaining Maybe was becuase my personal friends do'nt know any Haskell
23:54:20 <jle`> so i wanted my eventual fun-list-monad article to be accessible to them
23:54:28 <augur> also, is there a convenient library for doing REPL-like things?
23:54:54 <joejev> augur: what do you mean?
23:54:56 <jle`> in other news, Purely Functional Data Structures is now $10 for some reason
23:55:24 <joejev> jle`: is that a book?
23:55:26 <jle`> http://www.amazon.com/dp/0521663504/ref=pe_385040_30332200_pe_309540_26725410_item
23:55:33 <augur> joejev: er.. a REPL. some kind of interaction library so that your program can do interaction with the user via a command line interface
23:55:44 <augur> i could code it by hand but im curious if there's a lib for it
23:56:05 <jle`> begriffs: i appreciate it :)  i follow your writing pretty closely myself
23:56:25 <joejev> augur: I meant, what would this library do other than call getLine, and then parse the input and call the aproptiate functions?
23:56:34 <augur> i dont know!
23:56:45 <augur> im pretty sure ive heard of such a lib before is all
23:57:23 <joejev> http://hackage.haskell.org/package/repl-0.95/docs/Language-Haskell-Repl.html ?
23:58:19 <augur> i want to keep some state going too, which i would hope a lib could do nicel
23:59:02 <joejev> augur: does that library do what you want?
23:59:05 <augur> hmm. i think ill just handcode it
23:59:12 <augur> joejev: dunno. its hard to grok just from that :(
23:59:41 <joejev> augur: what's the repl going to be for?
23:59:58 <augur> a command-line sort of thing
