00:02:26 <larss> how can I have two different function definitions depending on the used OS? for example one definition for windows and other for non-windows
00:06:48 <tippenein> hmmm, still having problems with postgresql-libpq while trying to install postgresql-simple
00:07:53 <tippenein> maybe I need libpq5?
00:08:49 <tippenein> nope.. already have that
00:09:51 <tippenein> libpq-dev was needed
00:17:44 * hackagebot fpco-api 1.0.5 - Simple interface to the FP Complete IDE API.  http://hackage.haskell.org/package/fpco-api-1.0.5 (ChrisDone)
00:24:27 <FliPPeh> @pl cmp a b = (map toLower a) == (map toLower b)
00:24:27 <lambdabot> cmp = (. map toLower) . (==) . map toLower
00:26:54 <ion> flippeh: (==) `on` map toLower. You should not use map Data.Char.toLower, though. It won’t do the right thing. Use Data.Text.toLower or Data.Text.toCaseFold.
00:27:46 <shachaf> Comparing on toLower and case-insensitive comparison are not the same thing.
00:28:23 <FliPPeh> Well, the things I'll be stuffing into that comparison are guaranteed to be ASCII
00:28:26 <FliPPeh> Or latin1 at least
00:28:34 <shachaf> latin1 :-(
00:31:09 <ion> flippeh: Great, Data.Text.toLower or toCaseFold (depending on which you really want) will do the right thing for them, too. :-P (Assuming you mean the set of characters that matches Latin-1, not the encoding.)
00:32:15 <FliPPeh> But I already wrote the whole thing with String!
00:32:26 <FliPPeh> And I'm way to lazy to do the correct thing
00:32:45 * hackagebot persistent-postgresql 1.2.1.2 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.2.1.2 (MichaelSnoyman)
00:50:45 <f-a> I have got a state monad computation which starts with a "put state". Now I find myself in need of using runState, which is "s -> (a, s)". Is it possible to "extract" the state without providing one? I tried placing "undefined" after runState and it works, but maybe there is a better option.
00:52:25 <ion> Can’t you pass the initial state to the runState call?
00:53:11 <f-a> ion: the state is build with a function. Like setUpState :: Int -> Foo -> State Bar ()
00:53:34 <simpson> f-a: The typical trick is, indeed, to `undefined` it, but that's iffy. Is there no possible initial empty state?
00:53:58 <johnw> maybe call runState with (error "State not initialized")
00:54:34 <jle`> yeah, it makes it explicit that you are leaving yourself open to a runtime error
00:54:40 <f-a> those are both reasonable suggestions
00:54:57 <simpson> f-a: BTW, if this is some game loop or something like that, where the state's a big structure, my previous strategy has been to shrug and then provide a default state that is set to empty stuff, 0, "", etc.
00:55:41 <simpson> Also, consider Data.Default; it could help.
00:55:55 <f-a> State = BigState | TinyState ? <-- like this?
00:56:05 <nisstyre> if your thing is a monoid then mempty works
00:56:12 <nisstyre> or def as simpson said
00:56:22 <f-a> not a monoid unfortunately
00:56:34 <dv-> what's wrong with undefined
00:56:49 <nisstyre> nothing I guess, if it's never going to be evaluated
00:59:23 <f-a> thanks everyone, really useful suggestions. I will probably go with emty state.
01:00:31 <dv-> then you need to make sure that the empty state won't just crash the program, or it's just wasted effort
01:04:01 <Cale> int-e: are you around?
01:04:05 <Cale> lambdabot is failing
01:25:31 <johnw> does anyone have an idea as to what might cause FFI callbacks (Haskell -> C -> Haskell) to suddenly became a very slow operation within a thread?
01:27:48 <johnw> my callback jumps from taking ~40 microseconds, to taking ~20 milliseconds
01:28:34 <johnw> the callback itself uses IO, and does get a bit slow, from ~7 microseconds to to 20-200 microseconds
01:29:17 <johnw> one odd thing I've noticed is that if I put a (putStrLn "...") in the right place in the parent thread, all the slowness goes away
01:32:24 <adelbertc_> anyone have recommendations for learning about cabal (new to haskell here)
01:39:30 <AshyIsMe> adelbertc_: there's a good page here: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
01:39:56 <adelbertc_> AshyIsMe - awesome, thanks!
01:40:39 <AshyIsMe> no worries
02:14:38 <FliPPeh> Since empty record updates are illegal, what's the best way to replace my "if cond then updatedRecord { foo = bar } else updatedRecord"?
02:17:56 * hackagebot persistent 1.2.3.2 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.2.3.2 (MichaelSnoyman)
02:49:33 <bennofs> What is the meaning of the buildable field in cabal?
03:01:30 <johnw> preflex: seen JaffaCake
03:01:30 <preflex>  JaffaCake was last seen on #ghc 18 days, 20 hours, 16 minutes and 38 seconds ago, saying: inline functions
03:08:54 <jle`> FliPPeh: do you have the greater context?
03:35:00 <raek> What does "extensionally observable behaviour" mean? Context: http://lpaste.net/97372
03:35:52 <merijn> raek: "extensionally observable" strikes me as rather redundant
03:37:27 <merijn> raek: extensionally equal means "two black boxes are the same if their external behaviour is identical", compare intensional equality which means "two black boxes are the same iff their internal behaviour (and by extension their external behaviour too) are identical"
03:39:25 <raek> right, like the type of a functional piece of code tells you exactly what that piece of code can possibly do? (modulo termination)
03:40:06 <merijn> raek: Well, in context he's saying that "functional programs" only specify the end result, not how to get there
03:40:10 <raek> I remember that Erik Meijer talked about languages being "honest" in some talk. this feels related
03:40:23 <raek> hmm
03:40:31 <merijn> raek: Although one would usually speak of "declarative" vs "imperative" languages in this context
03:40:51 <merijn> raek: A declarative language specifies which results you want, an imperative language specifies how to get results
03:40:52 <Saizan> btw, that snippet of text is quite an hyperbole for current functional languages
03:41:11 <merijn> raek: oh, ha!
03:41:22 <merijn> raek: I only just noticed this is about SAC :)
03:41:46 <raek> yes :)
03:43:14 <merijn> I still think treating all functional languages as declarative is rather hyperbole to sell the language (obviously), but I think SAC is indeed a lot more declarative than many other languages, given the amount of whole program optimisation they do
03:46:52 <merijn> raek: Out of curiosity, how'd you end up with that paper?
03:47:54 <raek> merijn: hacker news
03:48:12 <merijn> wait, SAC was on hacker news?
03:48:18 <pantsman>  
03:48:22 <raek> it is #9 now
03:48:36 <raek> i spotted it 5 minutes ago
03:50:37 <merijn> Kinda sucks that they haven't managed to migrate their webpage to a place where they can update it, though
03:53:32 <augur> merijn: whats sac?
03:53:39 <aristid> single assignment c
03:53:42 <augur> oh ok
03:54:01 <augur> "SAC" to me means Stand Alone Complex, the Ghost in the Shell TV show. lol
03:54:16 <merijn> augur: Single Assignment C, purely functional array-based language with a syntax that looks so much like C they had trouble convincing FP people that it was purely functional
03:54:27 <augur> merijn: haha
03:54:40 <augur> because functional programming is about syntax, donchano
03:55:03 <dv-> if haskell looked like c, nobody would use it
03:55:21 <aristid> merijn: would you consider c++ templates purely functional?:D
03:55:23 <augur> i still think someone should make an extension for C that adds ADTs
03:55:32 <augur> and parametric polymorphism
03:55:47 <merijn> aristid: No opinion, dunno C++ templates enough
03:55:55 <raek> yes! I would love sum types in C.
03:55:56 <tiffany> augur: you should check out rust
03:56:08 <aristid> raek: i would love sum types in sql databases
03:56:10 <Taneb> raek, I think C has sum types
03:56:10 <merijn> aristid: They're purely functional in the traditional sense, though. They use uniqueness types for IO, etc.
03:56:14 <Taneb> Just no-one uses them
03:56:34 <aristid> merijn: well i suppose that still counts
03:56:41 <aristid> Taneb: huh? unions _are_ used
03:56:46 <aristid> they're just horrible
03:57:00 <aristid> because they're untagged and as unsafe as can be
03:57:15 <Taneb> raek, there you go, C has sum types, just they're horrible
03:57:24 <Taneb> aristid, sorry, I've never used C for more than half an hour
03:57:35 <merijn> aristid: The entire language is actually rather neat and interesting, provided you care more about numeric speed and multidimensional arrays then ADTs
03:57:47 <augur> tiffany: no i mean actual C. the idea being that C makes a lot of people comfortable because of its bare-metal-ness, and ADTs and parametric polymorphism would be relatively trivial additions -- just a thing layer of sugar
03:57:56 <aristid> merijn: i like speed. speed is good.
03:58:08 <aristid> but haskell isn't so bad for array stuff if you use vector
03:58:32 <raek> well, if you use unions you still have to add a "tag" field your self to tell te variants apart (and you need to write the case analysis code by hand)
03:58:55 <aristid> raek: indeed. it's horrible.
03:58:57 <tiffany> yeah but rust adds a lot of features such as ADTs, parametric polymorphism, ... without sacrificing being a system's language, losing control over memory, or introducing a mandatory garbage collector; so I thought it was relavent
03:58:57 <merijn> aristid: Isn't so bad compared to what?
03:59:20 <aristid> merijn: i make absolute statements all day if i want to :P
03:59:23 <merijn> aristid: They're trying to compete with hand optimised Fortran/C, vector is nice, but not even close to the same league
03:59:35 <tiffany> raek: plus anonymous unions embeded in a struct with a tag aren't possible until C11
03:59:54 <aristid> merijn: well, vector you can get decent but not completely outstanding performance with extremely straightforward code
04:00:01 <aristid> just beware points that break the fusion
04:00:09 <raek> tiffany: yeah. so you can have sum types, but oh the boilerplate!
04:00:31 <augur> really, you could write a thing wrapper on top of C to make it much nicer, i feel. like, you could compile ML (or something) to C with almost no effort
04:00:32 <raek> (in C <11)
04:00:35 <merijn> aristid: The difference is that tey do whole program optimisation for fusion and they do have cool things like multi-dimensional array comprehensions :)
04:00:36 <jerv> say I've got a function that takes 4 Int's and say I've got a list that has 4 Int's, is there a clean way to pass them in order to the function?
04:00:51 <aristid> merijn: does SAC code also "look high-level"?
04:01:07 <benmachine> raek: and oh the lack of static checking :(
04:01:08 <merijn> aristid: Depends on what you think of as high level
04:01:28 <aristid> merijn: how short the code can be
04:01:31 <merijn> aristid: It looks mostly like C without malloc and with proper arrays
04:01:44 <aristid> merijn: C code is extremely verbose usually
04:01:49 <merijn> aristid: Well, they're array polymorphism stuff is rather neat and flexible
04:01:54 <merijn> s/they're/their
04:02:17 <augur> http://pic.twitter.com/88jVyz9J56
04:02:20 <merijn> So maybe I should say it looks like C had a weird lovechild with APL
04:03:00 <dv-> jerv: let [a,b,c,d] = list in f a b c d
04:03:11 <bennofs> Is there a way to tell cabal install to reconfigure and enable tests/benchmarks without overriding previous options?
04:03:12 <raek> C-like language wish list: sum types (with statically checked tags), parametric polymorphism, pure, closures, well specified ABI or good FFI features
04:03:24 <raek> I feel I should check out Rust...
04:03:41 <aristid> raek: most of those haskell has :)
04:03:46 <aristid> well specified ABI not
04:03:58 <augur> raek: the first two are very easily implemented as sugar and compiler options, i swear
04:04:08 <augur> someone really just needs to do it, someone familiar with C :\
04:04:21 <aristid> hmm did my verb inversion sound weird there?
04:04:31 <raek> aristid: yes, but add "suitable for embedded systems" and "higly predictable runtime performance" :)
04:04:47 <aristid> raek: complete requirements are a virtue :P
04:04:55 <tiffany> raek: rust is quite nice if you need a system's language but like memory safety
04:05:10 <merijn> raek: You should check out SAC, even if only because else my colleagues will yell at me for not telling you that :p
04:05:15 <raek> augur: yes, I and some day I will write a C preprocessor do that :)
04:05:57 <tiffany> rust has everything but the well specified ABI
04:06:06 <benmachine> I'm not sure that parametric polymorphism is easy unless you're thinking templates, in which case ew :P
04:06:10 <tiffany> assuming you can call it "C-like", and I suppose there are those who wouldn't
04:06:17 <benmachine> but statically-checked sum types does sound easy
04:06:23 <merijn> aristid: Their basic marketing strategy is "we give you the ability to translate math to code with about the same ease as matlab, but with the performance close to handwritten Fortran"
04:06:25 <raek> tiffany: does it have good FFI features=
04:06:27 <raek> ?
04:06:31 <tiffany> define "good"
04:06:33 <augur> you just make your adt's into a fancy struct, or something like that; make case into a test or a switch or something, and make polymorphism into pointers + casts or whatever
04:06:54 <tiffany> it's not like some languages I've used, where you can directly import C header files and the type system matches 1:1
04:07:32 <tiffany> the main pains with rust's ffi are when you have to deal with pointers
04:08:21 <raek> tiffany: I found Haskell's FFI fairly pleasant to use. I was thinking of whether it had something better than, say, Javas FFI support
04:08:25 <aristid> merijn: i wonder if something like SAC would make a good replacement for opencl/cuda
04:08:34 <tiffany> I've never used either
04:08:36 <merijn> aristid: They can compile to opencl/cuda
04:08:40 <aristid> merijn: wow!
04:08:48 <merijn> aristid: Well, only cuda atm, I believe
04:08:54 <aristid> merijn: ok, shifting goalposts: BUT CAN THEY ALSO COMPILE TO FPGA?!
04:09:04 <raek> it is neat that I can have a Word32 in Haskell and a uint32_t in C, and it will fit
04:09:05 <merijn> aristid: Current research project
04:09:10 <aristid> merijn: haha awesome
04:09:19 <tiffany> well, rust has explicitly sized types
04:09:30 <tiffany> i32, u8, etc.
04:09:31 <aristid> merijn: i expect that the very c-like syntax might make it easier to sell to crazy hardware people
04:09:42 <tiffany> structs also use the same padding rules as C
04:09:50 <raek> interesting
04:10:02 <merijn> aristid: That's the main reason it was chosen, yeah. To sell to hardware or longtime C/Fortran devs
04:10:21 <aristid> tiffany: does rust also have a "give me a type at least as big as N bits but preferrably machine word size"?
04:10:34 <tiffany> I don't think so
04:10:45 <aristid> tiffany: well, rust is young they can still fix that
04:12:19 <jerv> dv-: great, and if the list is larger but I want to pass only the first 4?
04:12:59 <tiffany> rust maintains flexibility over memory control by having multiple, lifetime-checked pointer types, like & to 'borrow' data (comparable to const * parameters to C functions) and ~ for heap-allocated data; the problem with the FFI arises from passing these pointers to C functions
04:13:36 <dv-> jerv: let [a,b,c,d] = take 4 list in f a b c d :)
04:19:10 <raek> tiffany: but if you have knowledge over how the function will use the pointer (eg. only read from it and forget about it after the call) then it is simpler?
04:19:34 <tiffany> raek: the ABI for & and * are identical, so you can simply define the FFI function as taking an & pointer
04:20:16 <tiffany> there's an as_ptr() or something for ~ pointers to make a *, and you have to worry about whether the pointer will still be valid when used (I tried to make a helper function to turn program args into a char** for me, and got burned)
04:22:54 <aristid> merijn: SAC code looks a bit like R to me (well or MATLAB i guess) :)
04:24:36 <eggspurt> aristid: Matlab is fine, but R is terrible to look at.
04:26:10 <aristid> eggspurt: dunno i don't think matlab is nice, but this was not meant as a positive or negative statement anyways, just that i see some similarity
04:27:03 <merijn> Well, without silly nonsense like R's dynamic scope, etc. :p
04:28:26 <eggspurt> aristid: I find the linear algebra syntax in Matlab quite exemplary - it's compact, expressive, efficient. I'm not qualified to judge the programming language design.
04:29:36 <eggspurt> merijn: R harks back to the S from 1976... Advanced for the time, but tiresome for today.
04:34:24 <rtpg> is there a place that explains how to think about mfix? I have a hard time seeing how we can execute the action only once
04:34:38 <bennofs> @ty mfix
04:34:43 <lambdabot> MonadFix m => (a -> m a) -> m a
04:36:02 <sfvisser> hi, does anyone know if there is a safe way to assign a finalizer to a TVar? I suspect 'addFinalizer' isn't safe, for the same reason there exists a specialized version for IORefs (mkWeakIORef). But I'm not entirely sure.
04:38:07 * hackagebot formatting 3.1.0 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-3.1.0 (ChrisDone)
04:40:09 <merijn> sfvisser: Define "safe"
04:40:53 <sfvisser> to be sure the finalizer isn't called before before the actual reference is collected
04:41:55 <sfvisser> the docs say: "Finalizers can be used reliably for types that are created explicitly and have identity, such as IORef and MVar. However, to place a finalizer on one of these types, you should use the specific operation provided for that type, e.g. mkWeakIORef and addMVarFinalizer respectively (the non-uniformity is accidental)."
04:42:46 <merijn> sfvisser: I would expect the same holds for TVars, but no one thought to implement that
04:43:17 <sfvisser> that's my fear as well
04:43:52 <merijn> sfvisser: Drop an email to libraries@ to suggest it's addition
04:44:12 <merijn> As for your current problem, what exactly are you trying to accomplish?
04:48:33 <stavrosm> Hi! What's the behavior of Data.List.nubBy when given a predicate like (>)? The docs say: nubBy eq (x:xs) =  x : nubBy eq (filter (\y -> not (eq x y)) xs), but I think it's the other way around.
04:48:53 <stavrosm> That is, fitler (\y -> not (eq y x)) xs
04:48:57 <stavrosm> filter *
04:49:37 <augur> Geach is dead. :(
04:50:12 <sfvisser> merijn: I have some Tvars which have I know of other variables refer to, when they get out of scope I'm want them to deregister themselves so they don't take any memory and won't needlessly be involved in transactions. because there involvment won't be visible anymore to the outside world. so manual garbage collection basically
04:50:38 <benmachine> stavrosm: I think nubBy demands that you give it an equivalence relation, so it doesn't matter
04:50:52 <benmachine> stavrosm: at least one sensible person thinks this is a silly restriction that should be removed
04:53:32 <stavrosm> benmachine: Yea, i've read about the equivalence relation part, but I found "take 10 $ Data.List.nubBy (\x y -> x `mod` y == 0) [2..]" really neat
04:54:17 <bennofs> > take 10 $ Data.List.nubBy (\x y -> x `mod` y == 0) [2..]
04:54:21 <lambdabot>  mueval-core: Time limit exceeded
04:54:30 <bennofs> aw :(
04:54:40 <benmachine> > take 10 $ nubBy (\y x -> x `mod` y == 0) [2..]
04:54:43 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
04:54:46 <benmachine> ...oh
04:55:15 <stavrosm> what's going on? i just took this result: [2,3,5,7,11,13,17,19,23,29]
04:55:22 <benmachine> yeah taht's what I was expecting
04:55:39 <benmachine> and yeah, that's what I get in ghci
04:56:00 <benmachine> what's your GHC version?
04:56:20 <stavrosm> The Glorious Glasgow Haskell Compilation System, version 7.6.3
04:56:25 <benmachine> ah, ok
04:56:34 <bennofs> I get [2,3,4,5,6,7,8,9,10,11]
04:56:44 <bennofs> for benmachine's expression
04:57:11 <bennofs> and [2,3,5,7,11,13,17,19,23,29] if I'm using the one where lambdabot timed out
04:57:34 <benmachine> bennofs: sounds right
04:58:12 <stavrosm> what's the definition of nubBy, really? http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-List.html#nubBy
04:59:26 <stavrosm> i'm not familiar with the preprocessor parts
05:00:13 <bennofs> stavrosm: the implementation ghc probably uses is between the #else and the #endif
05:02:49 <stavrosm> ok, thanks :)
05:08:09 * hackagebot coordinate 0.0.1 - A representation of latitude and longitude  http://hackage.haskell.org/package/coordinate-0.0.1 (TonyMorris)
05:08:20 <ClaudiusMaximus> stavrosm: https://ghc.haskell.org/trac/ghc/ticket/2528 has some discussion
05:13:09 * hackagebot persistent-postgresql 1.2.1.3 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.2.1.3 (MichaelSnoyman)
05:15:48 <stavrosm> ClaudiusMaximus: I just don't get why the actual implementation doesn't corresponds to USE_REPORT_VERSION. Thanks for the link
05:16:06 <stavrosm> correspond *
05:19:49 <klrr_> anyone know a good way to represent a X wide and Y tall gaming board where each element is of a certain type?
05:20:57 <donri> klrr_: different types?
05:21:04 <sdfsww> Is it possible to sequence char 'a' and token "foo" in parsec?
05:21:45 <sdfsww> So for "afoobar", I'd get "afoo".
05:22:02 <klrr_> donri: well, i thought of something like [[X]] but i want each element to be easily "replaceable" (with the player) and each needs to contain a easily fethced possition
05:22:12 <rtpg> anyone have an "interesting" example of fixIO? I'm trying to figure out an interesting usecase for it
05:22:18 <klrr_> it's a turn based game
05:22:25 <donri> klrr_: but the cells are all the same type? try Map
05:22:29 <ClaudiusMaximus> klrr_: Array (Int,Int) e  perhaps - there's also a grid package that seems designed for games
05:22:48 <donri> Map X (Map Y Cell)
05:22:50 <merijn> stavrosm: USE_REPORT_VERSION means GHC uses the implementation specified in the haskell report, but for many functions the one in the report isn't the most efficient/best implementation
05:22:59 <ClaudiusMaximus> @hackage grid -- klrr_
05:22:59 <lambdabot> http://hackage.haskell.org/package/grid -- klrr_
05:23:02 <klrr_> map seems like a nice option, will check out grid too
05:23:05 <klrr_> thanks!
05:23:10 <merijn> stavrosm: So by default GHC uses the most efficient one, rather than what the haskell report says
05:24:40 <stavrosm> merijn: ok, I see now :)
05:24:41 <boom583> Someone here has the paper LYAH?
05:24:52 <bennofs> @where lyah
05:24:52 <lambdabot> http://www.learnyouahaskell.com/
05:25:25 <boom583> yes but do you have the paper edition, the online edition is different so i can't reference that
05:25:47 <boom583> whatever
05:25:51 <boom583> on page 40 in the paper LYAH
05:26:11 <boom583> the pargraph "Yikes! Not cool!"
05:26:19 <boom583> Why would the compiled program crash?
05:26:25 <boom583> Why wouldn't it find the error on compile time?
05:27:22 <merijn> boom583: Which chapter is that?
05:27:33 <boom583> chapter 3
05:27:42 <merijn> boom583: Alternatively, just lpaste the code in question?
05:28:11 * hackagebot haskell-generate 0.1 - haskell-generate  http://hackage.haskell.org/package/haskell-generate-0.1 (BennoFuenfstueck)
05:28:14 <boom583> ok 1sec
05:28:22 <Iceland_jack> boom583: badAdd?
05:28:26 <boom583> Iceland_jack: yeah
05:28:27 <stavrosm> boom583: badAdd :: (Num a) => [a] -> a   ?
05:28:29 <boom583> yeah
05:28:40 <Iceland_jack> badAdd (x:y:z:[]) = x + y + z
05:29:11 <merijn> oh
05:29:16 <Iceland_jack> boom583: The compiled program crashed because the patterns are non-exhaustive
05:29:35 <merijn> boom583: If you compile with -Wall GHC will in fact warn you about that at compile time
05:29:38 <boom583> so it doesn't look at the patterns on compile time?
05:29:39 <boom583> oh
05:29:48 <merijn> boom583: With -Wall GHC will return a warning about non-exhaustive pattern match
05:29:51 <donri> boom583: with -Wall it does
05:29:53 <boom583> great
05:29:58 <donri> but only warn, unless -Werror
05:29:58 <boom583> do you always use -Wall?
05:30:02 <donri> yes
05:30:04 <merijn> boom583: I do
05:30:06 <boom583> cool
05:30:11 <boom583> thanks
05:30:35 <boom583> also -Werror?
05:30:51 <augur> hey boom583
05:30:58 <boom583> hi augur!
05:31:05 <pranz1> boom583: depends on what you wirte
05:31:08 <pranz1> write*
05:31:14 <merijn> boom583: Usually not -Werror as there's quite a number of warnings which are not that critical
05:31:17 <pranz1> but some Prelude functions would fail with -Werror
05:31:20 <augur> boom583: what knowledge can i upload to your brains cloudserver today? :)
05:31:22 <pranz1> head, for example
05:31:26 <pranz1> since head is defined as
05:31:34 <Iceland_jack> @src head
05:31:35 <lambdabot> head (x:_) = x
05:31:35 <lambdabot> head []    = undefined
05:32:04 <pranz1> since head [] is undefined the pattern is not exhaustive
05:32:14 <merijn> pranz1: Head is not non-exhaustive
05:32:24 <merijn> pranz1: "head []" is defined, it just crashes
05:32:32 <shiona> I'm having problem with a golf. This runs,but  never prints a thing: http://lpaste.net/97374
05:32:38 <pranz1> but it's defined as undefined? :P
05:32:39 <merijn> i.e. "head [] = error "You dun goofed!""
05:33:09 <pranz1> merijn: ^ the source says it doesn't throw an error in that way
05:33:10 <donri> bottom is synonymous with "not totally defined"
05:33:11 * hackagebot data-size 0.1.1.1 - Profiling of data structures  http://hackage.haskell.org/package/data-size-0.1.1.1 (UweSchmidt)
05:33:31 <merijn> shiona: (¤) is not defined anywhere in that paste
05:33:43 <augur> pranz1: `undefined` is the same as `error "You dun goofed!"`
05:33:43 <boom583> ok
05:33:45 <Iceland_jack> pranz1: The identifier ‘undefined’ *is* defined
05:34:56 <merijn> pranz1: The source uses "errorEmptyList "head"" which in turn calls 'errorEmptyList fun = error (prel_list_str ++ fun ++ ": empty list")'
05:35:13 <merijn> In other words, in the end it just calls 'error'
05:35:34 * merijn remarks once again that 'head' should be called 'unsafeHead'
05:35:55 <merijn> Not gonna change due to backwards compatibility, though.
05:36:23 <dv-> it's not unsafe if you know that the list is not empty
05:36:50 <quchen> :t listToMaybe -- merijn
05:36:53 <lambdabot> [a] -> Maybe a
05:37:32 <donri> unsafeCoerce is not unsafe if you know the types have the same runtime representation
05:37:34 <quchen> dv-: unsafePerformIO is not unsafe if you know your function is referentially transparent
05:37:37 <quchen> Eh.
05:37:41 <donri> unsafePerformIO is not unsafe if you now the IO is pure
05:38:39 <nooodl> rtpg: fixIO $ \cs -> do { c <- getChar; return (c:cs) }
05:38:43 <merijn> dv-: Unsafety has nothing to do with whether something is safe in actuality, it has to with whether the type system will stop you from doing unsafe things accidentally
05:38:57 <benmachine> unsafeHead is not unsafe
05:39:08 <benmachine> it's just non-total
05:39:23 <quchen> Depends on what "unsafe" means.
05:39:24 <nooodl> that's like the fixIO equivalent of `fix ('a':)`, except instead of 'a' you read a char. or something.
05:39:26 <donri> but yeah unsafe is the wrong name (the safe package is the wrong name)
05:39:36 <merijn> benmachine: You seem to have a rather arbitrary definition of safety that I disagree with :p
05:39:36 <dv-> it's trivial to reason about list length
05:39:37 <quchen> "Use only iff you are sure your usage is safe" is a common interpretation of "unsafe".
05:39:38 <donri> totalHead? :P
05:39:51 <benmachine> merijn: "type safety" isn't that arbitrary
05:40:07 <merijn> benmachine: And why is the prefix unsafe restricted to type safety?
05:40:20 <rtpg> nooodl, I saw that example, but I guess I just don't reallly get why you would do that, is it really just a sort of "lifting" of fix?
05:40:25 <merijn> I tend more to quchen's definition
05:40:26 <benmachine> merijn: okay, let me revise my previous comment
05:40:50 <benmachine> "I think it's better to use the word unsafe only to refer to things that violate Haskell semantics"
05:41:03 <benmachine> non-totality is an acceptable part of Haskell
05:41:05 <benmachine> this isn't Agda
05:41:07 <rtpg> I can't see the point of the function existing, since you could just as easily do  "do c<- getChar; return $ repeat c " or something
05:41:10 <shiona> merijn: r and (¤) are just pure functions
05:41:12 <benmachine> (maybe it should be, but that's a separate debate :P)
05:41:29 <benmachine> the behaviour of head is fully-specified on the empty list
05:41:36 <nooodl> i think it is; i guess usually you'd explicitly write the recursion yourself. `fix` is the same way, really
05:41:57 <merijn> benmachine: Idisagree, there's lots of things which don't violate haskell semantics which still violate community expectations
05:41:59 <shiona> sorry for my huge answer latency, the connection is dropping me out all the time in this train
05:42:11 <quchen> rtpg: What's the point of the "forever" function when you can just use "loop = foo >> loop"?
05:42:36 <merijn> rtpg: That's because the getChar doesn't require a Char as input
05:42:43 <nooodl> hmm... the implementation of fixIO kinda confuses me, even though i can vaguely guess what it's doing
05:42:55 <quchen> rtpg: By the way, "repeat c" does not do what you think it does there.
05:43:11 <quchen> :t repeat getChar -- Long list of getChar actions.
05:43:14 <merijn> rtpg: fixIO is for when your IO action can return some partial results but needs it's own results to finish running
05:43:16 <lambdabot> [IO Char]
05:43:36 <nooodl> quchen: isn't (c :: Char) in his example though
05:43:47 <quchen> Oh. Yes.
05:43:53 <quchen> Pardon.
05:44:20 <quchen> nooodl: Good thing my reasoning would have been a type error! :-)
05:44:41 <nooodl> hmm... you can usually write "x = fix f" as "x = f x", right?
05:44:44 <rtpg> quchen, sorry, I don't mean repeat as in the actual function, I just meant some thing that would build an infinite list of chars
05:44:45 <quchen> merijn: moebIO? :-D
05:45:23 <merijn> rtpg: The problem is that nooodl's initial example is a completely useless use of fixIO
05:45:36 <merijn> As it can be trivially accomplished by your example
05:45:55 <nooodl> what would the equivalent be for "x = fixIO f"? something like "x = f =<< x"?
05:46:14 <donri> @src fixIO
05:46:14 <lambdabot> Source not found. You untyped fool!
05:46:25 <donri> i think it uses lazy IO and IORefs
05:46:32 <nooodl> the @src is some low level IO black magic
05:46:39 <rtpg> donri, http://hackage.haskell.org/package/base-4.6.0.1/docs/src/System-IO.html#fixIO
05:46:49 <rtpg> it's an MVar now
05:47:00 <rtpg> I mean I get what it does, I just don't really get the potential use cases
05:47:04 <shiona> I'll have to go, sorry. I'll be back asking this same stull later tonight
05:47:23 <donri> rtpg: DoRec
05:48:06 <nooodl> i wonder if you can write fixM :: Monad m => (a -> m a) -> m a
05:48:23 <merijn> nooodl: No, it require MonadFix
05:48:25 <merijn> :t mfix
05:48:28 <lambdabot> MonadFix m => (a -> m a) -> m a
05:49:03 <donri> isn't it lovely how some monad functions are m*, some *M, and sometimes m* is for monoids
05:49:04 <moofy> o/
05:49:59 <quchen> donri: Could be worse. We still have types and Haddock so it's not too bad.
05:50:03 <nooodl> argh. fix is hard to think about
05:50:13 <FreeFull> :t join . liftM fix
05:50:15 <lambdabot> Monad m => m (m a -> m a) -> m a
05:50:29 <quchen> Haha
05:50:33 <quchen> Called it
05:50:34 <donri> nice try, no cigar
05:50:51 <FreeFull> I knew it wouldn't be right
05:50:56 <donri> ;)
05:51:01 <FreeFull> :t liftM fix
05:51:04 <lambdabot> Monad m => m (r -> r) -> m r
05:51:16 <quchen> Almost!
05:51:18 <donri> :t join fix
05:51:21 <lambdabot>     Occurs check: cannot construct the infinite type:
05:51:22 <FreeFull> Not at all
05:51:22 <lambdabot>       a1 = (a1 -> a1) -> a0
05:51:22 <lambdabot>     Expected type: (a1 -> a1) -> (a1 -> a1) -> a0
05:51:25 <donri> mwahah
05:51:33 <FreeFull> :t (>>=)
05:51:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:51:50 <FreeFull> :t (=<<) fix
05:51:51 <lambdabot> Monad m => m (m b -> m b) -> m b
05:52:04 <FreeFull> Nope, that's the same as the join . liftM fix
05:52:12 <donri> :t liftM (liftM fix)
05:52:12 <FreeFull> I do know it's impossible
05:52:15 <lambdabot> (Monad m, Monad m1) => m (m1 (r -> r)) -> m (m1 r)
05:52:28 <FreeFull> :t contramap
05:52:29 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
05:52:37 <FreeFull> > contramap (fmap liftM) fix
05:52:41 <lambdabot>  mueval-core: Time limit exceeded
05:52:42 <FreeFull> :t contramap (fmap liftM) fix
05:52:44 <lambdabot> (Monad m, Functor f, Contravariant ((->) (f (m a1 -> m r) -> f (m a1 -> m r)))) => (f (m a1 -> m r) -> f (m a1 -> m r)) -> f (a1 -> r)
05:52:49 <quchen> Private session maybe?
05:52:55 <FreeFull> I think I'll just stop
05:57:10 <benmachine> merijn: perhaps "impoliteHead"
05:57:40 <merijn> benmachine: There's a sex joke in there somewhere
05:58:34 <donri> giveHeadOrBeAGoodBottom
06:03:13 * hackagebot nm 1.0.0 - Network Manager, binding to libnm-glib.  http://hackage.haskell.org/package/nm-1.0.0 (ChrisDone)
06:08:48 <epta> Another great package from chrisdone?
06:22:56 <moofy> I have a possibly silly question but: is there any reasonably simple graphics library/tool to get to know haskell with?
06:23:32 <moofy> I'd like to get more into haskell but I'm interested in visual stuff and most of what i've found seems to be deeply back-end computational
06:24:15 <dv-> gloss?
06:24:42 <moofy> is that aimed at me?
06:24:45 <dv-> moofy: http://hackage.haskell.org/package/gloss
06:25:04 <moofy> ooh that sound interesting
06:25:15 <dv-> there's also SDL, etc
06:29:00 <moofy> hmm, assuming i can get cabal to install it
06:29:13 <Clint> is it just me or does http://hackage.haskell.org/package/esqueleto hang indefinitely
06:34:23 <JuanDaugherty> apparently just you
06:35:43 <JuanDaugherty> (and response time to load it was about a second)
06:36:33 <moofy> hmm
06:36:52 <moofy> getting 'binary-0.6.4.0 failed during the building phase.' trying to install gloss
06:45:32 <Saizan> moofy: if you look at the backlog you should find more details, or you could rerun the command so that it will stop just after the failure
06:48:05 <moofy> oh bollocks
06:48:10 <moofy> it's a gcc/clang thing
06:48:17 * hackagebot yesod-auth 1.2.5.0 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.2.5.0 (MichaelSnoyman)
06:55:57 <bernalex> what's the sanest way of doing fromIntegral on something that might be an int? so you have a polymorphic function that takes a Num, and you want to do fromIntegral if it's an int
06:56:24 <Clint> :t fromIntegral
06:56:25 <lambdabot> (Integral a, Num b) => a -> b
06:56:41 <skypers> http://kormacode.blogspot.fr/2011/11/c-style-haskell_10.html
06:56:43 <skypers> I threw up
06:56:54 <bernalex> Clint: I know about fromIntegral -- but the point is that the Num *might* be an integral
06:57:09 <bernalex> > fromIntegral 5.0
06:57:11 <lambdabot>  Could not deduce (GHC.Real.Integral a0)
06:57:12 <lambdabot>    arising from a use of `GHC.Real.fromIntegral'
06:57:12 <lambdabot>  from the context (GHC.Num.Num b)
06:57:12 <lambdabot>    bound by the inferred type of it :: GHC.Num.Num b => b at Top level
06:57:12 <lambdabot>  The type variable `a0' is ambiguous
06:58:14 <Clint> bernalex: you want a function that behaves differently on Integral Nums than it does on other Nums?
06:58:39 <bernalex> Clint: I want to tersely check if the number is an int, and if it is, do fromIntegral.
06:58:49 <p0nce> hi, is there an haskell generic software renderer?
06:59:36 <bernalex> Clint: again, the function takes Num. so the number might not be an int. fromIntegral a will throw up, like I just showed you, if it is e.g. a double.
07:00:21 <skypers> hi p0nce :)
07:00:45 <p0nce> hi skypers
07:00:53 <skypers> you can look into lambdacube, but I don’t know whether it’s still maintained
07:02:00 <skypers> it’s funny how haskellers use BSD3 a lot
07:02:02 <skypers> I wonder why
07:02:06 <skypers> why not GPL3?
07:03:01 <bernalex> skypers: I think it is related to the strong ties to academia. academia tends to favour non-copyleft licences. I only use GPLv3 for my Haskell code though.
07:03:18 * hackagebot nm 1.0.1 - Network Manager, binding to libnm-glib.  http://hackage.haskell.org/package/nm-1.0.1 (ChrisDone)
07:03:33 <chrisdone> donri: ^ that package exists soley for this function: https://github.com/chrisdone/wifi-keepalive/blob/master/src/Main.hs#L55
07:03:35 <chrisdone> =p
07:03:38 <skypers> bernalex: I only use GLPv3 as well
07:03:50 <skypers> but it’s quite curious seeing all those BSD3 softs :)
07:03:54 <alpounet> skypers: I use BSD3 pretty much all the time
07:04:20 <alpounet> it exactly gives the freedom of use I want
07:04:28 <p0nce> skypers is about accelerated rendering, not software
07:04:39 <p0nce> s/skypers/lambdacube
07:05:05 <skypers> p0nce: well, I don’t know soft renderers in Haskell
07:05:29 <skypers> it could be a nice project to work on actually
07:05:36 <chrisdone> donri: next i need to make a ping/icmp library so that the ping code isn't so atrocious
07:05:55 <donri> chrisdone: \o/
07:05:58 <skypers> alpounet: what’s the main difference between BSD3 and GPLv3 then?
07:08:45 <alpounet> skypers: IIRC, gplv3 forces a GPL compatible license for libraries
07:09:04 <alpounet> i know for sure that BSD3 lets open-source users as well as companies use my work
07:09:08 <alpounet> that's what I want
07:09:26 <alpounet> so I stopped browsing the various licenses at that point
07:09:39 <dv-> companies can use GPL3 too :)
07:10:25 <chrisdone> a great number of companies
07:10:35 <chrisdone> seeing as few companies distribute as much as they used to
07:10:55 <skypers> that’s a solid point you came up with, alpounet
07:11:14 <skypers> but aren’t you afraid some companies use your work for – actually – money?
07:11:24 <alpounet> dv-: well it does take some freedom away compared to bsd3, doesn't it?
07:11:41 <skypers> alpounet: GPL3 is compatible with BSD3
07:12:07 <skypers> I don’t actually want companies to use my work to make money
07:12:14 <skypers> I don’t want that to happen
07:12:24 <jellybee> hey, a little off topic, about type checking, this expression http://postimg.org/image/93ox0o0y9/ - T0, T1 are not exactly defined but why is it important that T0 >= T1 || T1 >= T0 ? any idea?
07:12:25 <skypers> for now it’s unlikely
07:12:27 <skypers> but still.
07:12:32 <tovarish> skypers, you can sell GPL3 softsware it's not prohibited
07:12:41 <dv-> alpounet: in the same sense that police takes away people's freedom to kill yes
07:12:44 <skypers> tovarish: I know
07:13:12 <skypers> that’s why I’d love to release my stuff with a double license
07:13:15 <alpounet> skypers: well with the libraries I release, they would have a hard time just selling these, they would most likely build a great deal of things on top of these, so at that point they deserve their money :)
07:13:28 <skypers> free for anyone who wants to keep use it, modify or release it as free
07:13:44 <skypers> and copyrighted for the ones who’d like to sell my stuff
07:14:06 <chrisdone> not wanting people to use your stuff to make money, how evil is that?
07:14:30 <skypers> chrisdone: I want to spread charge-less software
07:14:36 <chrisdone> why?
07:14:40 <p0nce> skypers: if they make money with it, they will poke at you at one point
07:14:42 <skypers> because I don’t want users to pay
07:14:48 <alpounet> anytime I can help a haskell shop do its thing, that's great
07:14:48 <chrisdone> why?
07:14:52 <skypers> p0nce: nope
07:14:59 <skypers> p0nce: are you the D p0nce ? :)
07:15:03 <p0nce> yes
07:15:09 <skypers> if so, you might already know what happenned to XT95
07:15:23 <p0nce> what happened?
07:15:26 <skypers> demoscene is very discrete, but when some idiots try to steal code
07:15:47 <p0nce> code steal?
07:15:48 <skypers> well, XT95 wrote an algorithm for basic lightning (a fragment shader for local illum iirc)
07:15:56 <skypers> and some dudes stole the code
07:16:03 <chrisdone> NO WAI
07:16:06 <p0nce> did they respect the license?
07:16:12 <skypers> and added it to a sold software
07:16:14 <skypers> no p0nce
07:16:25 <skypers> XT95 told the FSF
07:16:32 <p0nce> good thing, he can go to them and sell them more shaders
07:16:40 <skypers> and they’re contacted to unuse the code or credit XT95
07:17:28 <moofy> oh my that was painful
07:17:36 <skypers> moofy: ?
07:17:46 <alpounet> skypers: imagine you've written a library that interacts with some web service or some mathy library. would you mind that a company actually uses it for their products?
07:18:02 <skypers> alpounet: no, because it tiny
07:18:13 <skypers> but I don’t companies to make profits over a larger soft
07:18:13 <jellybee> I need a little help with my "Programming languages course" anyone up for a quick question ?
07:18:18 <skypers> like my 3D engine for instance
07:18:38 <skypers> my engine is public
07:18:41 <skypers> it’s GPLv3
07:18:47 <skypers> if a company wants to use it
07:18:55 <skypers> and sell their softs
07:18:57 <skypers> they just can
07:19:06 <shiona> jellybee: you're better off just asking
07:19:09 <skypers> but it’s something I’m not really fond of you see
07:19:18 <alpounet> skypers: so you want your engine to be used only for open-source games?
07:19:19 <shiona> not asking if you can ask
07:19:21 <moofy> trying to re-sym link gcc over clang in os x
07:19:31 <moofy> so cabal could actually compile things
07:19:34 <skypers> alpounet: yes and no
07:19:37 <jellybee> shiona: i did, none replyed :/ i think the question needs a little context
07:19:45 <skypers> well yes
07:19:59 <skypers> companies have to respect the copyleft
07:20:16 <skypers> and it explicitely states that the source code has to remain open
07:20:18 <skypers> BUT
07:20:35 <shiona> ah. that happens a lot. i guess the channel is so busy people dont read everything
07:20:41 <skypers> I don’t preclude the fact some companies sell my engines through their products
07:20:47 <skypers> I just want to know, and give my permission
07:20:51 <skypers> because as I said
07:21:06 <skypers> I prefer users that don’t sell their products
07:21:10 <shiona> sorry, writing with a damn touchscreen keyboard in a moving car is hard
07:21:14 <skypers> and release the game as free
07:21:21 <p0nce> create your own license, more restrictive than GPL then :)
07:21:31 <sipa> shiona: hope you're not driving at the same time :)
07:21:38 <skypers> it would be full of flaws, p0nce
07:21:47 <skypers> I’m not the right guy to write such a license
07:22:16 <moofy> don't text and drive :/
07:22:33 <skypers> alpounet: I’m sure you can understand that
07:22:39 <skypers> imagine you write a massive library
07:22:43 <skypers> and at some day
07:22:43 <alpounet> i see your point
07:22:52 <shiona> jellybee: i usually repeat my question every 15 to 45 minutes until someone notices the question
07:23:15 <skypers> you get aware of a company that has used your stuff for months actually sells it
07:23:18 <skypers> how would you react?
07:23:20 <shiona> at times it takes a day or two
07:23:34 <skypers> “Oh that’s quite okay, they made money for what I do, and I get nothing”
07:23:40 <skypers> it’s quite frustrating
07:23:54 <shiona> sipa: fortunately not
07:24:05 <alpounet> skypers: well if they use a massive library of mine, I may get hired there
07:24:16 <skypers> ahah :D
07:24:18 <alpounet> because i know better than anyone else how it works and how to use it
07:24:22 <skypers> I’m not that sure
07:24:32 <moofy> :/
07:24:32 <skypers> without lack of respect
07:24:36 <alpounet> that almost happened once
07:24:41 <moofy> I wish cabal had less confusing names
07:24:44 <alpounet> but I was studying my master
07:24:52 <ski> jellybee : you need to convert either of the operands to the type of the other operand, to be able to compare for equality or disequality
07:25:04 <alpounet> people were using 2 of my machine learning libraries
07:25:19 <skypers> alpounet: that situation sounds great
07:25:20 <skypers> but imagine
07:25:23 <skypers> you actually get hired
07:25:25 <skypers> that’s great
07:25:28 <alpounet> wanted support for more stuffs, but I was short on time, so they were offering some money for me to do that work
07:25:32 <skypers> you teach them how to use your stuff
07:25:34 <ski> jellybee : actually, another option would be to convert both of them to a common supertype (such as the least common supertype, the lub)
07:25:34 <jellybee> ski: how do you get that from that expression?
07:25:36 <skypers> that’s even greater
07:25:47 <skypers> they suddendly make you redundant
07:25:50 <skypers> you lose your job
07:25:55 <skypers> and your own property
07:26:15 <skypers> that’s why I don’t want my personal projects to get into companies
07:26:18 <jellybee> ski: i know that in order to use equality both must be from the same type, but does that expression enforces that somehow?
07:26:38 <jellybee> ski: or will the interperter fail to notice that
07:26:44 <p0nce> repeating my question: anyone aware of a generic software renderer in haskell?
07:26:51 <skypers> profit ≠ user-oriented devs
07:26:59 <ski> jellybee : let's say the type of `(op)' "really" is `T -> T -> bool'
07:27:03 <skypers> companies only wanna make profit
07:27:27 <skypers> open-source and libre users don’t give a ****
07:27:32 <skypers> they just want to release good software
07:27:47 <alpounet> skypers: if i have a project I don't want people to use when money is involved, I would do something like Trolltech did back in the time Qt was the next big thing, it was under a dual-license, but that means I would actually build a company around my stuff because it's really worth selling (or selling services around it)
07:28:00 <ski> jellybee : then it seems natural that the reason they added that condition is because they wanted to convert one or the other operand to the type of the remaining one, to be able to apply this "real" version of `(op)'
07:28:05 <skypers> alpounet:
07:28:37 <ski> jellybee : so, i was mostly attempting to reverseengineer why they would want to add that condition, rather than trying to say why this is the condition we want
07:28:40 <skypers> I just need something like a double license!
07:29:00 <alpounet> yep
07:29:24 <ski> jellybee : however, if we don't have (guaranteed) lubs (or directednesS), then this "convert one to the type of the other" sounds like a next best thing to try (and is a bit simpler)
07:29:56 <ski> jellybee : "does that expression enforces that somehow?" "will the interperter fail to notice that" -- "that" being ?
07:30:22 <skypers> I just don’t care about companies, I do care about user experience
07:30:25 <jellybee> can i PM you ski?
07:30:38 <skypers> I think that for that purpose, a double license’s worth it
07:32:04 <shiona> ah, finally on a reasonable connection
07:33:26 <skypers> btw p0nce, are you considering using Haskell?
07:33:29 <skypers> what about D?
07:33:33 <p0nce> skypers: no
07:34:08 <p0nce> was searching for some existing generic renderer like antigrain geometry to steal the design and sell it for loads of money
07:34:13 <skypers> I’d love seeing an unlimited D demo of yours at TUM fall of the month!
07:34:23 <skypers> oh
07:34:32 <skypers> you can then use my engine, p0nce ;)
07:35:30 <p0nce> has haskell some sort of sub-typing?
07:35:49 <Peaker> p0nce: Type-classes sort-of give that
07:35:54 <skypers> what do you mean?
07:36:13 <p0nce> Type B that can be used as a A
07:36:14 <Peaker> p0nce: (Subclass a => Type involving a) is a sub-type of (Superclass a => Type involving a)
07:36:31 <Peaker> p0nce: the lens library is all about such type-class-based subtyping
07:36:39 <Peaker> well, "all" about may be too much :)
07:36:43 <skypers> Peaker: well, we can even do that without typeclasses I guess
07:36:47 <skypers> with simple functions
07:37:05 <skypers> typeclasses are just used as constraints over types or over constraints, aren’t they?
07:37:26 <Peaker> skypers: Right,  you could say   (Int -> Int)  is (sort of) a sub-type of (a -> a)?
07:37:33 <skypers> yep
07:37:39 <skypers> or
07:37:55 <skypers> data Foo = Foo { foo :: Int -> Int }
07:38:11 <skypers> you can them implement Foo1, Foo2 that defines a function like foo1ToFoo
07:38:11 <Peaker> that's not a sub-type though
07:38:31 <skypers> yeah I think I didn’t get the concept of sub-type
07:38:38 <skypers> it only makes me think to inheritance
07:38:39 <mornfall> skypers: is-a
07:38:49 <skypers> and we don’t need inheritance in Haskell nor FPL
07:38:57 <skypers> yeah so that’s what I thought
07:39:01 <Peaker> IIUC, it means you can use it in any context the super-type is expected without explicit "up-casting"
07:39:16 <Peaker> once explicit upcasts are used, I don't think it classifies as subtyping anymore, at least afaik
07:39:45 <mornfall> Peaker: which makes (a -> a) a sub-type of (Int -> Int) but not vice-versa
07:40:06 <skypers> hm
07:40:24 <skypers> I actually see typeclasses like constraints that lets you overload functions and operators
07:40:35 <skypers> it might be quite the same thing I guess
07:41:05 <mornfall> Peaker: the problem with that is that you rarely have a value of type a -> a
07:41:19 <shiona> now, simplifying the situation from my question from before: What am I doing wrong, and why is it wrong: http://lpaste.net/97377
07:41:23 <skypers> mornfall: Monoid Endo
07:41:45 <mornfall> skypers: what about it?
07:42:05 <skypers> mornfall: well it’s full a -> a
07:42:28 <skypers> it’s funny to use Endo
07:43:12 <mornfall> skypers: so what does the value look like?
07:43:24 <skypers> which value?
07:43:29 <mornfall> of type a -> a
07:43:38 <skypers> I don’t understand your question
07:43:50 <skypers> I mean Endo it’s just a wrapper over the endomorphisms
07:44:03 <skypers> > appEndo (Endo (+1)) 3
07:44:04 <mornfall> skypers: and what does that have to do with values with the type a -> a?
07:44:05 <lambdabot>  4
07:44:50 <mornfall> skypers: if you have f :: (Int -> Int) -> Int, you can pass something of type (a -> a) to it
07:44:52 <skypers> mornfall: well, an Endo is a Monoid, and a Monoid shows some functions for such values
07:44:54 <mornfall> skypers: but what would that something be?
07:45:03 <skypers> the (<>) operator for instance
07:45:18 <skypers> 16:37 < mornfall> skypers: if you have f :: (Int -> Int) -> Int, you can pass something of type (a -> a) to it
07:45:20 <mornfall> skypers: I literally mean a -> a, not something in that shape :)
07:45:21 <skypers> what?
07:45:29 <skypers> you can’t do that
07:45:59 <skypers> it wouldn’t typecheck I guess
07:46:00 <skypers> would it?
07:46:48 <mornfall> skypers: why not?
07:46:48 <p0nce> (haskell noob here) does haskell do without any inheritance polymorphism?
07:47:23 <p0nce> ie. no runtime dispatch except pattern-matching?
07:47:23 <skypers> p0nce: wee have higher functions, pattern matching
07:47:25 <skypers> typeclasses
07:47:35 <skypers> higher functions are quite useful
07:47:37 <skypers> mornfall: well
07:47:45 <skypers> it expects Int -> Int
07:47:53 <skypers> a -> a is not Int -> Int
07:48:05 <skypers> you could pass Int -> Int as a -> a though
07:48:09 <mornfall> skypers: it can be specialised into Int -> Int
07:48:21 <skypers> I don’t get your point mornfall
07:48:34 <mornfall> skypers: well, try it :-)
07:48:43 <mornfall> pass id to something that wants Int -> Int
07:49:05 <skypers> oh
07:49:06 <skypers> you mean that
07:49:07 <skypers> sure
07:49:31 <mornfall> @djinn a -> a
07:49:31 <lambdabot> f a = a
07:49:47 <mornfall> well, f a = undefined would work too
07:50:42 <skypers> yeah yeah
07:51:00 <skypers> you can pass a -> a because it’s a polymorphic function
07:51:09 <skypers> I got to go
07:51:12 <skypers> see you later folks
07:51:15 <mornfall> bye
07:51:37 <mornfall> my point being that you can't really treat parametric polymorphism as a form of subtyping
07:52:10 <mornfall> p0nce: typeclasses give you runtime dispatch of sorts
07:52:45 <mornfall> p0nce: although that's an implementation detail until you make an existential around the typeclass
07:52:53 <p0nce> mornfall: that answers my question
07:52:58 <p0nce> thx
08:00:03 <mcstar> shiona: im not sure what you want but these work http://sprunge.us/KYcL?haskell
08:01:14 <ibotty> hi
08:01:42 <shiona> mcstar: I wanted to try keep the parameter inside the IO monad at all times, lifting the functions that handle it if necessary
08:01:43 <ibotty> maybe someone can help me with a type inference problem (using extensible-effects, so pretty hard i guess)
08:02:03 <shiona> it is for a golf where I believe this could be helpful if possible
08:02:16 <shiona> but I'm starting to suspect it isn't
08:04:05 <ibotty> see the following lpaste... http://lpaste.net/97378
08:04:49 <ibotty> the problem is, that if i use the generic runLog, it cannot infer the Log's type
08:06:45 <ibotty> i get the following lpaste output: http://lpaste.net/97379
08:06:46 <meh23970> good ol' typeable.. isn't it about to be overhauled in the next ghc release?
08:07:29 <Peaker> mornfall: we can often use more-polymorphic values in place of monomorphic ones, though
08:07:30 <ibotty> well. oleg should know, huh. i mean, he says, it's safe and great to use, so i trust him. but somehow it feels fragile.
08:07:34 <Peaker> is that considered actual subtyping?
08:07:58 <Peaker> ibotty: prone to type errors aren't considered fragility :)  that would be prone to runtime errors
08:08:12 <ibotty> you are of course, right
08:08:14 <ibotty> :D
08:08:58 <meh23970> it's only a type error if you get caught :)
08:09:03 <ibotty> Peaker: honestly i guess there is some misunderstanding on my side...
08:09:14 <ibotty> meh23970: the problem is: i get caught!
08:09:36 <meh23970> :t unsafeCoerce
08:09:38 <lambdabot> Not in scope: `unsafeCoerce'
08:09:42 <meh23970> darn
08:09:45 <ibotty> aww
08:09:56 <ibotty> meh23970: that's not what i'd like to do
08:11:07 <meh23970> runLog has quite the interesting type signature
08:12:17 <meh23970> hmm.. I'll put Control.Eff on the list to of things to explore. Still, having to use typeable makes me a bit leery.
08:12:56 <mornfall> Peaker: but that's the exact opposite of your original Int -> Int is a subtype of a -> a idea
08:13:18 <meh23970> is it supposed to comonadic?
08:14:16 <Peaker> mornfall: yeah, you're right, of course, I had that reversed. I'm wondering about whether it's actually considered subtyping?
08:18:42 <boom583> A "let" inside a list comprehension and a "let...in" expression. These are two totally different beasts aren't they?
08:18:50 <boom583> even though they are both "let"
08:19:09 <meh23970> let inside of a list comprehension is a bit like let in a do block, I think
08:19:25 <meh23970> and by a bit, I mean exactly >.<
08:20:04 <boom583> ok i'm not at do blocks yet
08:20:11 <meh23970> ah
08:20:17 <meh23970> list comprehensions are a strange beast
08:20:35 <meh23970> they're a sort of syntactic sugar for monadic operations on lists
08:20:45 <boom583> haven't gotten to monads either lol
08:20:54 <meh23970> oh
08:21:04 <boom583> whatever
08:21:07 <boom583> i'll keep reading
08:21:08 <boom583> thanks
08:21:19 <meh23970> well, you probably have used them for a long time and haven't noticed really
08:21:35 <meh23970> boom583: but yeah, in the context of a do block or list comprehension, let doesn't need an in
08:21:46 <boom583> ok
08:21:49 <meh23970> boom583: it's kinda like assigning to a variable
08:22:56 <bernalex> how can I neatly write a function [a] -> a, where a has to be either an Integral or a Fractional, and do different things based on whether it is one or the other?
08:24:41 <meh23970> bernalex: use two separate functions or build yourself a typeclass
08:24:49 <nadirs> bernalex: you could make a typeclass with a function f :: [a] -> a, and than declare instances for Integral and Fractional, providing different implementation for that function f
08:24:58 <bernalex> I guess
08:25:09 <bernalex> thanks for the idea
08:25:38 <meh23970> or if it's just two, you could use a sum type
08:26:29 <meh23970> bernalex: Integral a, Fractional b => Either a b -> ....
08:27:23 <meh23970> I guess that's a product type
08:27:24 <meh23970> w/e
08:27:59 <meh23970> or both!
08:28:27 <elfette> Hey, I'm currently reading LYAh but I was wondering how I should be reading it. I've preread some of the chapters so going through the examples is quite boring, should I just skip around?
08:28:32 <elfette> LYAH*
08:29:04 <boom583> elfette: i'm reading the whole thing from start to finish
08:29:07 <boom583> at page 48
08:29:21 <boom583> not boring at all!
08:29:48 <elfette> I'm on 55 but I've read up to 90
08:30:00 <elfette> getting through 55 -> 90 is boring if you already read it lol
08:30:10 <elfette> I was in calculus reading it actually
08:30:22 <meh23970> elfette: well if you've already read it, what's the problem?
08:30:36 <elfette> typing in the examples is tedious for some reason
08:30:52 <meh23970> what section is p55?
08:30:57 <elfette> I get the concept, but of course I need to familiarize myself with the syntax by typing it and using ghci and such
08:31:10 <elfette> currently recursion but next is higher-order functions
08:31:54 <meh23970> well, the recursion part is basic and something you can learn from other languages
08:32:15 <meh23970> the only novel bit there is pattern matching in function declarations
08:32:21 <elfette> yeah
08:32:39 <elfette> I feel like if I go through the book start to finish I'll forget a lot
08:32:48 <elfette> it's very dense
08:33:05 <meh23970> wait until the functor section :P
08:33:15 <boom583> elfette: that's the way it is
08:33:27 <boom583> gotta revise forgotten things constantly
08:33:35 <quchen> Write some code.
08:33:36 <elfette> of course
08:33:41 <boom583> but reading it once it will stick in the subconscious
08:33:54 <allCAPS> Hey. I've got a question.
08:34:02 <elfette> that's what I was thinking, wasn't too sure of what to code without knowing the later things
08:34:09 <quchen> Solve the first 10 Project Euler problems. (Then stay away from the site because it's about number theory fiddling and not programming.)
08:34:19 <allCAPS> I have a list defined in my .hs file. Can I add to that list in ghci when I compile it?
08:34:55 <meh23970> allCaps: what do you mean?
08:35:09 <elfette> not really too much of a fan of project euler to be honest x)
08:35:23 <meh23970> allCaps: I think the list has to be constructed at runtime anyway?
08:35:30 <allCAPS> meh23970: So, say I have a list, and I have a function to display the list in a certain way. I would like to display the list, then add a value to the list, and then display it again. Possible?
08:35:37 <m1dnight> is there a difference between literate haskell and regular haskell? Or are it just the '>' before every line?
08:35:48 <quchen> m1dnight: It's just that.
08:35:49 <pranz1> allCAPS: you can't mutate the list
08:35:56 <allCAPS> pranz1: That's cool, thanks.
08:36:07 <allCAPS> Better just to have a second list in the .hs file, then?
08:36:08 <meh23970> allCAPS: except appending to the list isn't mutating it
08:36:11 <pranz1> but yeah, you can create a new list with the added list
08:36:15 <pranz1> and then print it out
08:36:21 <m1dnight> oh ok quchen
08:36:22 <allCAPS> Ah, that would work. Thank you
08:36:25 <meh23970> allCAPS: sorry, appending to the front
08:37:27 <allCAPS> Excellent, I've figured it out. Thanks all!
08:37:38 <meh23970> elfette: it doesn't have to be something complicated
08:38:01 <elfette> yeah I'll probably mess around a bit
08:38:20 <quchen> You can implement parts of Prelude.
08:38:23 <elfette> I really like elm's FPL so I'll probably mess with that too even though that's not haskell
08:38:25 <quchen> Write cycle, take, takeWhile, …
08:38:33 <elfette> that's why LYAH shows ^^
08:38:39 <meh23970> heh
08:39:22 <meh23970> I guess go through it and do that, then
08:39:39 <meh23970> anything with more IO than printing will require at least dabbling in monads, I think
08:39:56 <elfette> though I read it was possible without monads
08:39:56 <meh23970> (in terms of understanding)
08:40:19 <elfette> is IO practical without monads?
08:40:25 <meh23970> it's dangerous
08:40:28 <meh23970> the IO monad is special
08:40:32 <quchen> No.
08:40:48 <meh23970> ok, the state token in the IO monad is special
08:40:50 <quchen> You can implement IO yourself.
08:40:55 <tvynr> Does anyone have any idea how Happy might be installed and yet not installed?  If I run "cabal install --only-dependencies && cabal build" I get "At least the following dependencies are missing: happy -any"
08:41:06 <tvynr> I'm about as certain as one can be that my PATH is set correctly.
08:41:23 <quchen> IO without monads is pretty awkward from what I've learned a couple of weeks ago, but it's not impossible.
08:41:30 <elfette> hm
08:41:32 <meh23970> quchen: hypothetically, but then we're in the land of implementation-specific black magic
08:41:58 <quchen> Well, you don't need the "monad" abstraction for "monadic IO". IO is a Monad instance, and if you had "returnIO" and "bindIO" it would not be "monadic IO" but still handle the same way.
08:42:04 <pranz1> You don't need to understand monads very well to do IO in haskell IMO
08:42:08 <quchen> Monad is really the abstraction over all things that behave like monads.
08:42:09 <td123> tvynr: try --with-happy=PATH
08:42:17 <pranz1> just remember that an IO value can only be used inside another IO action
08:42:21 <tvynr> td123: Will do, thanks.
08:42:27 <meh23970> pranz1: that was my point about printing stuff to stdout
08:43:12 <elfette> currently processing, wrapping my head around it ha
08:43:19 <quchen> meh23970: IO is basically an abstraction to build up a chain of I/O operations. The runtime system then takes that chain of actions and executes them.
08:43:40 <meh23970> quchen: yup
08:43:50 <tvynr> td123: Same result.  Thanks for the suggestion, tho.  :)  It's weird; every time I run that command, it recompiles and reinstalls Happy with exit code 0.  But then it doesn't seem to remember that Happy was installed.
08:44:11 <tvynr> I've already tried deleting ~/.cabal and ~/.ghc and starting again from scratch; no luck.
08:44:32 <meh23970> tvynr: where's ghc installed?
08:44:52 <meh23970> tvynr: happy may be living in the bin dir of your ghc installation
08:45:21 <elfette> alright, thanks for the help everybody, I'll be back probably
08:45:39 <tvynr> meh23970: I have "/usr/bin/ghc" on PATH, if that's what you mean.  But "which happy" gives me "$HOME/.cabal/bin/happy".
08:46:01 <meh23970> tvynr: linux system?
08:46:13 <tvynr> meh23970: Debian Squeeze, updated nightly.
08:46:24 <epta> Suppose there is  a :: IO [x] and f :: x -> IO y. How to get IO [y]? Is there some function like :: m n x -> (x -> m y) -> m n y ?
08:46:30 <meh23970> tvynr: try looking in usr/share/ghc/bin (I think?)
08:46:50 <meh23970> tvynr: then again, if which happy points to .cabal/bin .. idk
08:47:09 <epta> @djiin m n x -> (x -> m y) -> m n y
08:47:10 <lambdabot> Error: kind error: (KVar 6,KStar)
08:47:13 <epta> :[
08:47:28 <quchen> epta: fmap!
08:47:42 <meh23970> tvynr: do other packages that require happy build?
08:47:44 <tvynr> meh23970: Yeah.  The most confusing part about this is that it installs but then claims that it's not installed.  "cabal list happy" shows "Installed versions: [ Unknown ]".
08:48:06 <tvynr> meh23970: I don't know; I don't think I have any.  Let me go find one that requires happy.
08:48:06 <quchen> :t fmap (undefined :: [x] -> [y]) (undefined :: IO [x])  -- epta
08:48:07 <lambdabot> IO [y]
08:48:07 <meh23970> tvynr: does it show up in ghc-pkg list?
08:48:22 <tvynr> meh23970: Nope.
08:48:34 <quchen> epta: Oh sorry, I missed the IO part in f. In that case, >>= is what you're looking for.
08:48:39 <meh23970> tvynr: then it isn't registered with ghc ... odd
08:49:16 <meh23970> tvnyr is there a happy conf file in ~/.ghc/$SYSTEM/package.conf.d/ ?
08:49:26 <tvynr> meh23970: Yeah, I'd think that "cabal install happy" would take care of that step.  :-P  Can you recommend a package which requires happy?
08:50:11 <tvynr> meh23970: There are two files in ~/.ghc/$SYSTEM/package.conf.d/ which are named package.cache and Cabal-1.18.1.2-becfdafcfdc4657b09fc7e48961db788.conf
08:50:58 <epta> quchen: how do you mean?
08:51:05 <meh23970> tvynr: then again, it's an application so maybe it shouldn't show up there?
08:51:50 <supki_> :t ?xs >>= traverse ?f
08:51:51 <lambdabot> (Monad m, Applicative m, Traversable t, ?xs::m (t a), ?f::a -> m b) => m (t b)
08:51:51 <meh23970> tvynr: yeah, I don't have one in my ghc-pkg .. oh well.. um, as for dependent packages.. language-objc is the only one I can think of off the top of my head
08:52:05 <khs> Hi, I'm having some trouble with a function I need to write. The type is:   [Action] -> [WorldObject] -> [WorldObject]   I need to process the actions one by one in a function like this  Action -> [WorldObject] -> [WorldObject] ofcourse i can't use 'map' as that would return [Actions]... What should I do?
08:52:48 <meh23970> khs: try (>>=)
08:53:22 <piezoid> :t \ma f -> ma >>= mapM f
08:53:22 <lambdabot> Monad m => m [a] -> (a -> m b) -> m [b]
08:54:22 <tvynr> meh23970: Version 0.4.2.8 of language-objc doesn't seem to require happy.
08:54:26 <tvynr> meh23970: But thanks much for your help.
08:54:32 <tvynr> meh23970: I'll keep poking at it.
08:54:47 <meh23970> tvynr: oh dear; it definitely should.. its parser is built in happy
08:56:14 <meh23970> tvynr: what package are you trying to install?
08:56:41 <khs> meh23970: thanks
08:56:44 <raek> khs: you could chain the functions together using foldl and (.)
08:57:23 <raek> khs: sorry, I misread the types, I tihnk
08:57:23 <quchen> foldr, you mean
08:57:39 <meh23970> :t (=<<)
08:57:40 <lambdabot> Monad m => (a -> m b) -> m a -> m b
08:58:18 <tovarish> what is missing with haskell is an infix flip fmap
08:58:36 <supki_> :t (<&>)
08:58:38 <lambdabot> Functor f => f a -> (a -> b) -> f b
08:58:40 <Taneb> tovarish, there's one in lens, <&>
08:58:58 <meh23970> :t `flip (.)`
08:59:00 <lambdabot> parse error on input ``'
08:59:17 <meh23970> :t `(flip (.))`
08:59:17 <lambdabot> parse error on input ``'
08:59:20 <tovarish> Taneb, it's not in the standard haskell ?
08:59:28 <Taneb> No
08:59:29 <Taneb> :(
08:59:34 <meh23970> :t (#)
08:59:34 <tovarish> that's the pb
08:59:35 <quchen> You can't use `foo` on arbitrary expressions, only wordy identifiers.
08:59:35 <lambdabot> parse error on input `)'
08:59:47 <meh23970> quchen: so I see :P
09:00:10 <meh23970> quchen: a fair number of packages define (#) as flip (.) yeah?
09:00:12 <quchen> meh23970: This also prevents operations like  `(`mod`)` etc :-)
09:00:21 <tvynr> meh23970: I have a package I'm developing; it's an interpreter for our research language.  My package builds just fine at the moment.  But when I add "happy" to the build dependencies, it starts failing by claiming that Happy is missing.  Even when I install it myself.
09:00:29 <meh23970> quchen: probably for the best, I think, heh
09:00:31 <khs> Anyone know a tutorial or something explaining how to use >>= ?
09:00:32 <quchen> meh23970: I think (#) is often flip ($). flip (.) I haven't seen often.
09:00:43 <quchen> (&) is Lens' version of flip ($).
09:00:56 <meh23970> tvynr: I don't think happy shows up in the ghc-pkg list even when installed
09:01:11 <meh23970> tvynr: there's nothing to find when searching for dependencies
09:01:49 <tvynr> meh23970: I see.  So how does one write a cabal file for a project that needs a Happy executable or a specific version of Happy?
09:02:17 <tvynr> meh23970: It seems you're saying that putting "happy" there will always fail, yes?
09:02:39 <meh23970> tvynr: I can't say for sure, but I think so
09:02:42 <quchen> There is (<<<), which is flip (.)
09:02:46 <bernalex> I really wish names in haskell supported any utf-8 character
09:02:54 <quchen> It's in Control.Category
09:03:02 <quchen> Eh, (>>>) I mean
09:03:17 <tvynr> meh23970: Interesting.  I'll look into that.  It's a bit of a strange behavior, I think.
09:03:19 <benmachine> bernalex: have you tried?
09:03:28 <tvynr> meh23970: You might've just cracked this problem for me, though.  Thanks muchly!
09:03:36 <benmachine> there's quite a few you can use
09:03:49 <benmachine> > let λ = 5 in λ
09:03:51 <lambdabot>  5
09:03:56 <bernalex> benmachine: "a few" isn't any. you can't even use ?
09:04:04 <meh23970> tvynr: put happy until Build-Tools
09:04:09 <bernalex> > let just? = isJust
09:04:11 <lambdabot>  <hint>:1:11: parse error on input `='
09:04:22 <benmachine> bernalex: oh, well, Agda gets closer :P
09:04:43 <meh23970> "tvynr: Build-Tools:" happy in your cabal file
09:04:59 <meh23970> bernalex: ghc has an extension for that
09:05:06 <bernalex> meh23970: hah, what is it?
09:05:15 <meh23970> bernalex:  {-# LANGUAGE UnicodeSyntax #-}
09:05:26 <tvynr> meh23970: That seems to have done it.  :-D  Thanks!
09:05:27 <meh23970> bernalex: have fun >.<
09:05:36 <meh23970> tvynr: good luck!
09:05:37 <quchen> Nonononono don't have fun with that
09:05:54 <bernalex> meh23970: awesome
09:05:56 <tvynr> meh23970: I was stuck on this for a while now.  You have my gratitude.  :)
09:07:38 <bernalex> meh23970: hm. still get parse error. what ghc version do I need?
09:08:13 <meh23970> bernalex: dunno; should work?
09:08:18 <meh23970> bernalex: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#unicode-syntax
09:08:40 <meh23970> bernalex: thought it would let you use it for identifiers too
09:09:42 <bernalex> meh23970: right so it doesn't actually let you write "blah? :: [a] -> Bool"
09:10:01 <meh23970> bernalex: maybe try reading here? http://www.haskell.org/haskellwiki/Unicode-symbols
09:10:13 <meh23970> bernalex: '?' may be illegal in identifiers
09:12:01 <bernalex> meh23970: aww.
09:14:25 <meh23970> bernalex: looks that way; in the syntax docs, types and variables can only have ascii / unicode letters
09:14:56 <greg`> im getting Not in scope: `A.min' when my haskell code says import
09:14:57 <greg`> 	Data.Array.Accelerate as A
09:15:04 <greg`> can anyone guess why?
09:16:00 <meh23970> greg`: probably min isn't exported by Data.Array.Accelerate
09:16:06 <meh23970> greg`: perhaps try minimum :)
09:16:18 <greg`> thanks will do
09:21:01 <greg`> i think i need to redefine the signature, it says so in the document, i'll figure out how to do that , thanks to all for your help
09:21:11 <meh23970> greg`: good luck
09:23:30 * hackagebot force-layout 0.2.0.1 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.2.0.1 (BrentYorgey)
09:23:53 <greg`> so it wont be easy, im trying to compile the sources for concurrent and parallel programming in haskell
09:24:03 <greg`> v. annoying :-\
09:25:52 <zett_zelett> http://zyklon.be/dl/computer-autism.jpg
09:30:51 <epta> How to convert String to Data.ByteString.Internal.ByteString?
09:32:25 <quchen> epta: Have a look at the Encoding modules in Data.ByteString
09:36:46 <rose__> How can I pattern match on a suffix? Something like   case string of (x ++ ", ")
09:38:36 <geekosaur> you can't pattern match directly; use a guard
09:38:48 <epta> rose__: case (Data.List.stripPrefix ", " string) of Just x -> ; _ -> ;
09:40:08 <rose__> epta: There are many ", " intercalated in the string
09:42:18 <meh23970> rose__: you might like the words function?
09:42:59 <meh23970> :t unwords . map init . words
09:43:01 <lambdabot> String -> String
09:46:23 <darthdeus> hey guys, i've finished LYAH and "scheme in 48 hours" ... and now i'd like to start building some stuff, where do you recommend i go next ... real world haskell?
09:46:37 <meh23970> darthdeus: or just start building stuff
09:46:58 <darthdeus> I'd love to try some game development, but not sure what's a good library to start :P if there is one
09:47:03 <yitz> yeah that's interesting. it's kind of a hole in the OverloadedStrings extension. pattern matching on the end of a String doesn't make sense, so the syntax doesn't support it. but OverloadedStrings allows pattern matching on Text, where it *does* make sense, but there's still no syntax for it.
09:47:04 <darthdeus> i found a few bindings, but ... i'd rather ask here first
09:47:27 <meh23970> darthdeus: depends on how deep down the rabbit hole you're willing to go
09:47:42 <yitz> darthdeus: pick an existing project that interests you and start contributing
09:47:58 <meh23970> darthdeus: there are bindings to packages like glfw which is like using c with a veneer of haskell
09:48:00 <darthdeus> meh23970: as deep as it gets, haskell actually made me start a computer science university again :p
09:48:19 <numberten> darthdeus: you might want to read the typeclassopedia
09:48:22 <meh23970> darthdeus: or you can find yourself playing around with frp packages like netwire, elerea or reactive-banana
09:48:32 * hackagebot stompl 0.1.1 - Stomp Parser and Utilities  http://hackage.haskell.org/package/stompl-0.1.1 (TobiasSchoofs)
09:48:38 <darthdeus> hmm, cool
09:48:54 <numberten> i usually recommend this to people after LYAH: http://www.haskell.org/haskellwiki/Typeclassopedia
09:49:14 <lingxiao> hey all, so I'm going through TypingHaskellInHaskell
09:49:19 <darthdeus> thanks guys, i'll check it out :P
09:49:45 <meh23970> darthdeus: check out function reaction programming, then
09:49:59 <lingxiao> and could someone who has gone through it comment on how complex the program is, relative to some other haskell programs you've seen?
09:50:09 <meh23970> darthdeus: netwire, sodium, elerea and reactive banana are all libraries with slightly different twists
09:50:39 <lingxiao> because there's two kinds of complexity here, complexity of underlying idea of type inference, and the complexity of implemenation. and they're both somewhat challenging to me
09:51:28 <meh23970> lingxiao: I haven't looked at typing haskell in haskell, but maybe you'd be interested in starting with something a bit less ambitious?
09:51:34 <darthdeus> meh23970: i've done a bit of FRP in c# with RX.NET, but i guess this will be a completely different appraoch to the problem :)
09:51:50 <lingxiao> darthdeus: http://stackoverflow.com/questions/3247280/whats-the-next-step-to-learning-haskell-after-monads
09:51:54 <meh23970> lingxiao: try building a simply-typed lambda calculus implementation?
09:52:25 <meh23970> darthdeus: heh, I'm not sure to be honest; good luck
09:52:48 <lingxiao> this SO question provides a good roadmap on what to do after LYAH. Also brent yorgey authored Typeclassopedia, and writes many other good blogs about haskell, and learning haskell. They're a good read
09:53:18 <meh23970> darthdeus: you'll want to look at learning arrows with some of those frp libraries, by the way
09:53:32 * hackagebot stomp-queue 0.1.1 - Stompl Client Library  http://hackage.haskell.org/package/stomp-queue-0.1.1 (TobiasSchoofs)
09:54:16 <lingxiao> meh23970: yeah typeclasses definitely add a lot more complexity to the typechecker ..
09:54:16 <tristan_1> if I want to restrict record creation in other modules to using a default function to do so, but I want to be able to then do: defaultR{field1 = 1}, is there a way to say export all fields for R besides R(..)
09:54:29 <tristan_1> since R(..) would mean you can also construct a record R without calling defaultR
09:55:11 <exicer> If I have a hex string, that is just String, what is the easiest way to decode it to Integer ?
09:55:13 <meh23970> tristan_1: accessor functions or factor your default fields out into a another data type that you don't export the constructor to
09:55:18 <ParahSailin> is alex wrapper "monad" broken or poorly documented?
09:55:57 <meh23970> tristan_1: map char?
09:56:02 <meh23970> :t chr
09:56:03 <lambdabot> Int -> Char
09:56:09 <meh23970> tristan_1: sorry, chr
09:56:16 <meh23970> tristan_1: is it a string of ints?
09:56:24 <meh23970> tristan_1: or a list of ints?
09:56:27 <tristan_1> hm?
09:56:33 <tristan_1> oh you mean exicer I think
09:56:34 <meh23970> oh dear
09:56:37 <meh23970> I mixed up names
09:56:38 <meh23970> sorry!
09:56:45 <meh23970> exicer: map chr
09:56:59 <meh23970> exicer: although, can you say more about the structure of your hex string?
09:57:06 <darthdeus> now i dont know what to read first :D
09:57:53 <exicer> meh23970: Well it is just a string, so it has :t String, but it is of the form 0xblahblah
09:58:11 <lingxiao> darthdeus: can you state your original question again, I think I'm but a little bit ahead of you in learning haskell
09:58:31 <lingxiao> i just logged on so I didn't see your original question
09:58:39 <darthdeus> lingxiao: i've just finished the "scheme in 48 hours" thing, and i read LYAH and i'm reading real world haskell (just started)
09:58:41 <meh23970> exicer: so the 0xblahblah is encoded as ascii/unicode characters?
09:58:48 <darthdeus> my question was "whatdoaidonextzz" :P
09:59:45 <lingxiao> so what I found was LYAH is good at softball-introduction of basic haskell concepts,but not great at teaching you how to use *all of them together in a cohesive program
09:59:52 <darthdeus> yes
09:59:59 <tristan_1> meh23970: doesn't seem like either of those are anymore elegant than just exporting field1 and defaultR manually
10:00:06 <darthdeus> that's my feeling too, i'm not really sure how to do stuff
10:00:10 <nadirs> darthdeus: hello, what aside from reading? Did you write something?
10:00:34 <darthdeus> nadirs: not really, i've done all the excercises in the scheme tutorial, that's probably 90% of haskell i've written
10:00:53 <darthdeus> but i dont feel that i understand things enough to contribute to opensource
10:00:53 <lingxiao> as for real world haskell on the other hand, it's really focused on use cases, and serve its purpose  I suppose
10:00:56 <lingxiao> http://www.seas.upenn.edu/~cis552/
10:01:33 <lingxiao> I found that after I went through all the lectures and homework in that class, I felt a lot more confidant with haskell, and the concepts begin to click in my head
10:01:39 <meh23970> sorta .. real world haskell is starting to feel dated imo
10:02:33 <lingxiao> in the sense that they feel more intuitive. Going out on a limb, don't learn arrow for now, it's just another way to model computation, and I would know the basic conepts cold before doing that
10:02:38 <nadirs> lingxiao: I'm working on Yorgey's cis194 at the moment, do you know it? Does cis552 come as a natural succession to that?
10:03:14 <darthdeus> lingxiao: too late, i've already started learning arrows while trying to understand the HXT xml parser :D
10:03:28 <darthdeus> but yeah it's still too abstract for me
10:03:57 <darthdeus> the problem is that i understand the code when i see it, sort of ... but i can't ever imagine myself writing that sort of thing
10:03:57 <bennofs> HXT is abusing arrows. All it's arrows are really also monads iirc
10:04:20 <aristid> bennofs: abusing is the wrong word i think :)
10:04:28 <nadirs> darthdeus: I can relate :P
10:04:52 <lingxiao> nadirs: oh yeah I did some of the homework in that as well. It's a bit of step to do cis552 but I wouldnt say it's unatural
10:05:02 <meh23970> aristid: why add the mental load of having to think in arrows when you could use monads? :/
10:05:22 <aristid> meh23970: there are alternatives to hxt:)
10:05:36 * bennofs would like to see hxt-monad on hackage
10:05:37 <nadirs> lingxiao: nice, I've bookmarked it anyway, once I'm done with cis194 I'll definitely give it a try :)
10:05:38 <lingxiao> darthdeus: arrows is like another way to decompose all computations down to just three, second order functions
10:06:32 <lingxiao> like of like how lamda calclus breaks all functions down to just three combinators, K,S,and I
10:06:56 <darthdeus> looking at typeclassopedia, this is how it makes me feel about the types https://pbs.twimg.com/media/Bb0xl4yIEAAUC-Q.jpg:large
10:07:04 <lingxiao> kind of like how a phonetic system breaks all words in a language down to primitive sounds, each one mapping to an alphbet, A,B,C...
10:07:23 <meh23970> darthdeus: http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
10:07:42 <darthdeus> lingxiao: i'm thinking of arrows as "even lazier function applications which can be composed"
10:08:04 <lingxiao> darthdeus: see that's the problem, you've got too many facts, not enough context. which is why i think it's good to limit yourself now, and beat the three facts that you know to death, but doing lots of projects
10:09:05 <lingxiao> darthdeus: what do you mean by lazy?
10:09:05 <darthdeus> lingxiao: yeah i guess you're right
10:09:17 <darthdeus> well i mean that i create the arrow and it doesn't do anything until i run it
10:09:25 <darthdeus> (i only know about runX)
10:09:51 <darthdeus> and before that i can kinda compose them kinda like monads but not really ... yeah i dont really understand them :D
10:10:01 <lingxiao> darthdeus: yeah i didnt realize this until a few months in, but the idea of creating inert computations that need to be run is one of the most basic concepts in haskell
10:10:08 <lingxiao> along with function is value
10:10:32 <meh23970> runX doesn't actually run anything
10:10:50 <meh23970> it builds a new thunk out of its arguments
10:11:32 <lingxiao> nadirs: yeah that class is a bit more beastly, but very rewarding. it'll teach you the idiomatic way to decompose programs into atomic computations, and composing them in different ways
10:12:09 <nadirs> lingxiao: sounds exactly like what I'm looking for!
10:12:09 <darthdeus> so it's kinda like IO in a way that it evaluates when you start eating it
10:12:20 <lingxiao> darthdeus: I totally understand what you mean, I was exactly at that place a few months ago. it just comes with time.
10:13:07 <lingxiao> also "the monad reader" has lots of good articles, and they'll enrich your understanding of things. and I found it was a lot easier to learn coroutines first before learning functional reactive programming
10:13:24 <meh23970> oh boy.. continuations
10:13:28 <lingxiao> there's a nice article on coroutine in "the monad reader"
10:13:59 <lingxiao> nadirs: yup hope you find all that and more in there :D
10:14:02 <darthdeus> this is again where my brain melts :D because up until recently i thought i know what FRP is because i've been playing with libraries that have "reactive" in their name
10:14:09 <darthdeus> but listening to you guys i feel that i dont understand anything :D
10:14:44 <meh23970> darthdeus: re-entrant functions .. think python generators
10:14:45 <lingxiao> darthdeus: maybe we're all putting on fronts. how could you understand if we don't even understand ourselves lol :D
10:15:37 <meh23970> darthdeus: or setjmp / longjmp if you're into that
10:15:38 <darthdeus> async collection sort-of-monad thingies + bunch of combinators = frp?
10:16:25 <darthdeus> and not really async i guess
10:16:26 <meh23970> an frp is analogous to a circuit .. you propagate a signal through your program and change it based on events
10:16:43 <meh23970> an frp program*
10:16:46 <darthdeus> yeah that part i understand
10:18:02 <lingxiao> darthdeus: if you really are interestd in FRP and know javascript, there's a library, bacon.js that you can play with
10:18:27 <nadirs> a question about minus (-): can you eta-reduce `f x = x - 1`?
10:18:51 <Clint> @pl \x -> x - 1
10:18:51 <lambdabot> subtract 1
10:19:36 <nadirs> Clint: thanks a lot!
10:20:14 <nadirs> @help pl
10:20:14 <lambdabot> pointless <expr>. Play with pointfree code.
10:21:06 <meh23970> > let x = x + 1 in x
10:21:10 <lambdabot>  mueval-core: Time limit exceeded
10:21:30 <lingxiao> Clint: is `subtract x y` = y - x?
10:21:35 <darthdeus> let f = flip (-) 1
10:21:39 <lingxiao> according to that gove?
10:21:41 <lingxiao> above*
10:21:49 <lingxiao> :t subtract
10:21:51 <lambdabot> Num a => a -> a -> a
10:21:56 <dario`> @src subtract
10:21:56 <lambdabot> subtract x y = y - x
10:22:05 <lingxiao> oh well there you go
10:22:31 <darthdeus> lingxiao: yeah bacon is kinda popular in the js world i must say
10:22:52 <darthdeus> i remember first time someone told me about it i was like "wtf is this good for?"
10:23:12 <lingxiao> darthdeus: i wish more so, the only person who answers my question about it on SO is the creator.
10:23:16 <lingxiao> answer: elegance
10:23:22 <darthdeus> well people know it exists, but they dont understand it :D
10:23:47 <darthdeus> at least in the ember.js community i think everyone has heard of bacon
10:25:01 <lingxiao> that's funny I was playing with ember a lot back when it was like version .98, three consecutive api changes later I'm like "peace!"
10:26:11 <darthdeus> yeah i remember that time :D
10:26:26 <darthdeus> i was writing two apps with ember during that time, so much pain in those weeks
10:28:45 <lingxiao> yeah and then there's ember data
10:29:24 <darthdeus> dont even get me started on that :P
10:30:27 <lingxiao> meh23970: do you know of any simply-typed lambda calculus impl I could reference?
10:30:33 <lingxiao> or a really good one I should say
10:31:02 <meh23970> lingxiao: take a look at Types and Programming Languages by Benjamin Pierce
10:31:11 <meh23970> lingxiao: I'm not sure if you can find it online
10:31:24 <lingxiao> darthdeus: haha yeah, that's when I decided on learning Haskell.
10:31:53 <lingxiao> meh23970: yeah you, edward kmett, and everyone else I know recommends the book. I guess I have no choice but to pick it up
10:32:02 <lingxiao> and no I've tried..
10:33:18 <lingxiao> meh23970: also if I could ask, I feel like making good haskell programs is alot about finding the right way to reprsent your data and common computations in the program
10:33:45 <lingxiao> for you, how many iterations do you have to go through before finding a good set of those? one that doesn't hang you with incidental complexity later on
10:35:08 <meh23970> lingxiao: dunno; trying to keep everything modular
10:35:13 <darthdeus> lingxiao: do you write haskell for living now?
10:35:29 <meh23970> lingxiao: imo, object-oriented principles are valuable even in haskell
10:35:53 <lingxiao> darthdeus: ha no, it would be interesting though :D
10:36:46 <lingxiao> meh23970 : could you expand on that? I though haskell was about minimizing moving parts? I don't have much experience with large haskell programs though so my opinions are very loosely hel
10:36:48 <lingxiao> held*
10:37:10 <ParahSailin> are the posn and monad wrappers in alex supposed to work?
10:38:49 <meh23970> that was interesting.. irc client bit the dust
10:38:56 <meh23970> anyway
10:39:26 <meh23970> I meant more in the sense that you shouldn't introduce unnecessary dependencies in your program
10:39:49 <meh23970> try to keep everything isolated unless it really needs to interact
10:40:16 <meh23970> there's more to object-oriented design than storing state and having behaviors attached
10:41:30 <lingxiao> meh23970: ah gotcha. thank you!
10:44:00 <vektor> hey guys. haskell newbie here. I need someone to help me out a bit. I want to compile haskell functions from source at runtime. And I don't trust whatever is in those source files, so I want to ensure that those functions in there have a specific type signature.
10:45:27 <vektor> (those type signatures being doFun :: [String] -> Memory -> (Memory, [String]) and evFunc :: [String] -> Memory -> (Memory, String)
10:45:29 <vektor> )
10:45:31 <benmachine> vektor: eep. this sounds like a dangerous thing for a newbit to be doing :P
10:45:35 <benmachine> *newbie
10:45:41 <vektor> hehe.
10:46:06 <benmachine> well, it's a dangerous thing for anyone to be doing, but it's not impossible to get right, cf. lambdabot
10:46:12 <bennofs> @hackage mueval -- vektor
10:46:12 <lambdabot> http://hackage.haskell.org/package/mueval -- vektor
10:46:25 <vektor> What's the worst that could happen? I guess I could crash my system
10:46:34 <vektor> at worst, I would have to do a reinstall of the OS
10:46:37 <vektor> :D
10:46:41 <vektor> willing to take risks, I am
10:46:51 <benmachine> someone could install code on your computer that
10:46:52 <benmachine> hmm
10:46:59 <benmachine> read all your credit card details?
10:47:10 <benmachine> turned your computer into a spambot?
10:47:29 <vektor> well, the code in there is not made by an intelligent being
10:47:31 <benmachine> contacted the local police force saying HELLO I BROKE THE LAW PLEASE ARREST ME BECAUSE OF CRIMES
10:47:31 <vektor> it's random
10:47:44 <benmachine> ah, okay
10:47:55 <vektor> Well, I wanna run a genetic algorithm, so sooner or later (rather later) it might become evil
10:48:01 <benmachine> :)
10:48:06 <benmachine> what will it be built from?
10:48:14 <vektor> huh? come again?
10:48:20 <benmachine> the code, lambdas? functions from a library?
10:48:24 <bennofs> vektor: You want a genetic algorithm that builds random haskell programs?
10:48:33 <benmachine> is it allowed to import whatever modules you have?
10:48:35 <vektor> bennofs: uhh. yeah. Why not?
10:48:54 <vektor> benmachine: the only limitation I want to impose is the above type signature. so no IO stuff.
10:49:04 <bennofs> GHC is pretty slow at compiling. So it's not gonna be too fast
10:49:11 <vektor> In essence you could consider it a function in the mathematical sense, I guess.
10:49:13 <benmachine> bennofs: eh, GHCi is pretty fast
10:49:31 <benmachine> vektor: yeah but if you have access to GHC-internal libraries you can "cheat"
10:49:44 <vektor> I'm not sure whether I'll want to use GHC or GHCI. I guess it mostly depends on the complexity of agent's AIs and their lifespan
10:49:53 <bennofs> vektor: maybe try hint?
10:49:56 <bennofs> @hackage hint
10:49:56 <lambdabot> http://hackage.haskell.org/package/hint
10:49:57 <vektor> benmachine: how so?
10:50:06 <benmachine> vektor: have you heard of the FFI?
10:50:23 <benmachine> the FFI is the "foreign function interface", it allows interfacing with C libraries
10:50:33 <benmachine> of course, a priori, that might be impure, so you import things as IO functions
10:50:43 <vektor> I thought so.
10:50:43 <benmachine> but in reality many C operations are pure and we want to be able to expose such things
10:50:54 <vektor> without IO there's nothing much you can do I hope
10:51:06 <benmachine> but the type system can't prove that they are pure, so basically there are special functions to say "this is pure, promise"
10:51:19 <vektor> ouch
10:51:23 <vektor> that's mean
10:51:35 <benmachine> so you can implement APIs that /you/ know are pure even though they are implemented impurely underneath
10:51:40 <bennofs> you can avoid these escape hatches though by using SafeHaskell
10:52:07 <vektor> I bet safehaskell is gonna save my ass here :D
10:52:27 <geekosaur> safe haskell isn't necessarily safe in the way you want
10:52:41 <vektor> wut?
10:52:49 <bennofs> geekosaur: I thought safeHaskell disallowed unsafePerformIO and the like?
10:53:37 * hackagebot haskell-updater 1.2.0.12 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.0.12 (SergeiTrofimovich)
10:54:38 <geekosaur> yes and no. (you can use them as long as you promise that the result is pure. but this means someone can, accidentally or maliciously, tag a module as Trustworthy even though it turns out to use them in an unsafe way)
10:54:57 <vektor> any volunteers? join me, we can rule the galaxy!
10:55:33 <vektor> FOSS of course.
10:59:33 <benmachine> geekosaur: Trustworthy doesn't work unless you ghc-pkg trust the relevant packages
11:03:06 <tac> If I cabal install a package, and there's an examples/ directory in the source, where would I typically find those files on a Windows machine?
11:03:11 <tac> after I install*
11:14:22 <AlainODea> tac: AFAICT they are not included normally.
11:14:32 <tac> I found it, so nvm
11:14:46 <tac> you get a zipped copy in your local appdata directory
11:18:20 <td123> vektor: what are you building?
11:19:33 <meh23970> tac: you can also pass along a cabal flag to have it built
11:21:14 <tac> thanks
11:25:28 <vektor> td123: uhh... haskell-powered genetic algorithms in an artificial life kinda scenario
11:26:09 <vektor> I'd be thankful if someone with a bit more haskell experience than me could take care of the safety-critical GHC(i) part
11:27:19 <Baughn> Any recommendations for a lightweight, standalone Haskell webserver framework?
11:27:31 <meh23970> Baughn: scotty
11:28:06 <implementation> Is there any way to declare that all types of class A also belong to class B?
11:28:37 <c_wraith> implementation: not the way you hope
11:28:44 <vektor> implementatin: that sounds lik OOP
11:28:44 <meh23970> implementation: class A a => B a where ....
11:29:10 <quchen> meh23970: The other way round. :-)
11:29:18 <c_wraith> meh23970: that's not the same thing.  That's "it is required to be an instance of class A to be an instance of class B"
11:29:33 <meh23970> the letters got me all confuzzled!
11:29:38 <Baughn> meh23970: Thanks, this looks reasonable
11:30:08 <meh23970> and I guess he's right.. it's not the same
11:30:19 <meh23970> you could have a general instance for all elements of the class
11:30:31 <c_wraith> implementation: you can't do it in the way you really want to, because ghc doesn't consider contexts when resolving class instances.
11:30:56 <c_wraith> implementation: so if you tried to say instance A a => B a where ...
11:31:13 <c_wraith> implementation: ghc won't consider the context, so it will assume you're saying "all types are an instance of B"
11:31:30 <implementation> "instance A a => B a where" is not even allowed ^^
11:31:47 <c_wraith> well, it is if you allow undecidable instances
11:31:59 <implementation> that's why i'm looking for an alternative way without providing the instance for every type manually
11:32:09 <c_wraith> The standard approach is a newtype wrapper
11:32:49 <c_wraith> instance A a => B (AWrapper a) where ...
11:33:21 <c_wraith> Sometimes that does the job you need, sometimes it just isn't convenient
11:33:40 * hackagebot xdot 0.2.4.2 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  http://hackage.haskell.org/package/xdot-0.2.4.2 (DennisFelsing)
11:33:42 * hackagebot ghc-vis 0.7.2.1 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.7.2.1 (DennisFelsing)
11:33:44 <meh23970> c_wraith: does that somehow pass the context around?
11:34:29 <c_wraith> meh23970: no.  It just adds the A a requirement to the context it's being typechecked in
11:35:06 <meh23970> c_wraith: why does that different from instance A a => B a where ...
11:35:12 <meh23970> why does that differ*
11:35:21 <meh23970> ?
11:35:40 <c_wraith> meh23970: it only matches when there's an AWrapper involved, rather than matching on all types
11:36:11 <c_wraith> meh23970: that means the instance is decideable, and doesn't overlap everything ever
11:36:50 <meh23970> c_wraith: oh, I get what you're saying
11:37:23 <meh23970> c_wraith: what if typeclasses could be sealed?
11:37:56 <c_wraith> it'd change everything.  It's a pervasive assumption in the way the type checker is implemented that type classes are open
11:38:10 <zebr> hi all. is there, in type theory, an idea of the 'size' of a simple type, being how many type atoms it contains?
11:38:30 <c_wraith> zebr: absolutely.  It's where the "algebraic" in "algebraic data type" comes from
11:38:41 <meh23970> c_wraith: ah; thanks!
11:40:08 <zebr> c_wraith: are we talking about the same thing? i.e. (a->b)->c->d would be of size 4?
11:40:20 <c_wraith> zebr: oh.  we're not
11:40:30 <c_wraith> zebr: I see what you're asking now
11:40:43 <c_wraith> I have no idea if there's a term for that
11:40:56 <zebr> ah :) thanks, though
11:43:44 <c_wraith> What's the name of the extension that enables a kind for contexts?
11:43:50 <klrr_> if i use RecordWildCards can i refer to a variable within the record without giving it the record itself as usual?
11:44:08 <c_wraith> oh, ConstraintKinds
11:45:09 <c_wraith> klrr_: yes, RecordWildCards implicitly shadows the name of the accessor with a binding to the value it'd access
11:45:54 <c_wraith> klrr_: when you pattern match with Foo{..}, anyway
11:48:17 <meh23970> klrr_: also makes it hard for other people to figure out your code
11:48:58 <klrr_> c_wraith: ok thanks meh23970: i think it will make it more readable honestly
11:52:46 <c_wraith> agh..  What's the import for the Constraint kind?
11:52:50 <c_wraith> And why isn't that listed in the documentation for the extension?
11:53:06 <meh23970> -XConstraintKinds I think
11:53:14 <c_wraith> not the extension, the import
11:54:19 <c_wraith> ah.  GHC.Prim or GHC.Exts both export it
11:54:23 <Sgeo_> Is composing multiple Data.Text.replace's as efficient as hand-writing an algorithm to do so would be (perhaps because of laziness), or is it as inefficient as it would be in a string language (perhaps Texts are non-lazy?)
11:54:35 <ClaudiusMaximus> c_wraith: GHC.Prim ?
11:54:44 <ClaudiusMaximus> ah, too late
11:55:19 <c_wraith> Sgeo_: they *should* fuse together if compiled with optimizations, because of how the Text library is designed.
11:55:56 <meh23970> Sgeo_: should being the operative rule; the package has rewrite rules that should eliminate intermediate test representations, but you'll need to check the core output to be sure
11:56:02 <meh23970> operative word, rather*
11:56:17 <Sgeo_> :/
11:56:24 <meh23970> s/test/text/
11:57:49 <meh23970> Sgeo_: the text type itself is unboxed & strict, though
11:58:07 <dario`> @pl (\x -> (x, length x))
11:58:07 <lambdabot> ap (,) length
12:00:37 <meh23970> hmm.. some place lost & regained internet access
12:00:48 <meh23970> quite the pattern
12:00:57 <tristan_1> hah, everyone using irccloud
12:01:19 <meh23970> heh
12:01:20 <tristan_1> odd that so many in here use irccloud compared to the erlang channels :)
12:01:56 <meh23970> interesting
12:01:56 <meh23970> I'd never heard of irccloud
12:01:56 <tristan_1> well nm, just realized this is happening in erlounge and erlang as well
12:02:50 <tristan_1> I use it for irc on my phone
12:03:03 <tristan_1> got tired of using irssi on it, hehe
12:03:36 <meh23970> doesn't irssi run in a terminal? O.o
12:03:49 <tristan_1> yea
12:04:05 <meh23970> you're a brave fellow
12:04:40 <tristan_1> hah, it wasn't too bad
12:04:59 <tristan_1> just ssh to the server I have it running on under tmux from my phone
12:05:23 <meh23970> huh; interesting idea
12:05:59 <meh23970> does android come with a ssh client
12:06:19 <tristan_1> no
12:06:23 <tristan_1> just install connectbot
12:06:38 <tristan_1> and the hacker keyboard, so you have all the keys you need
12:07:12 <meh23970> ah, thanks for pointing me in the right direction
12:11:57 <bernalex> sortByLength = sortBy (\a b -> if (length a > length b) then a else b) -- what am I doing wrong?
12:12:38 <jonasw> :t sortBy
12:12:40 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
12:12:46 <bernalex> (I know I can just do sortBy compare)
12:13:06 <bernalex> jonasw: yes, so if I give my sortByLength a list of lists, this should be right, no?
12:13:19 <bernalex> :t (\a b -> if length a > length b then a else b)
12:13:20 <lambdabot> [a] -> [a] -> [a]
12:13:52 <jonasw> bernalex: Your function doesn't return an Ordering
12:14:08 <jonasw> @src Ordering
12:14:08 <lambdabot> data Ordering = LT | EQ | GT
12:14:31 <bernalex> right, of course. it's not the Ord typeclass, it's an Ordering. sorry!
12:14:36 <croyd> sortBy (comparing . length)
12:14:44 <croyd> ?
12:14:45 <Cubesoup> :t comparing
12:14:46 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
12:14:52 <bernalex> Cubesoup: even sortBy compare would work
12:14:58 <bernalex> erm croyd ^
12:15:06 <bernalex> but I was just playing around with ghci
12:15:17 <Cubesoup> I learned a new trick :D
12:21:13 <bernalex> :t sortBy (\x y -> if length x > length y then GT else LT)
12:21:15 <lambdabot> [[a]] -> [[a]]
12:21:19 <bernalex> right
12:21:30 <bernalex> wurks
12:21:38 <mauke> :t sortBy (comparing length)
12:21:39 <lambdabot> [[a]] -> [[a]]
12:21:48 <bernalex> mauke: yes, again, I know
12:21:49 <osa1> can I use ptr == nullPtr (in Foreign.Ptr) for null pointer checking?
12:21:53 <mauke> osa1: yes
12:22:11 <bernalex> mauke: even sortBy compare would work for this.
12:22:22 <mauke> :t sortBy (comparing length <> compare)
12:22:23 <lambdabot> Ord a => [[a]] -> [[a]]
12:22:47 <bernalex> > sortBy compare [[1,2,3],[1],[1,2,3,4,5],[1,2]]
12:22:48 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4,5]]
12:23:02 <bernalex> I was just playing around in ghci and wanted to do it myself :-)
12:23:28 <dv-> > sort [[1,2,3],[1],[1,2,3,4,5],[1,2]]
12:23:29 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4,5]]
12:23:56 <aristid> dv-: amazing, isn't it ;)
12:23:57 <bernalex> dv-: true
12:24:08 <mauke> > sortBy (comparing last) [[1,2,3],[1],[1,2,3,4,5],[1,2]]
12:24:09 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4,5]]
12:24:38 <bernalex> sortByLength = sort
12:24:40 <bernalex> lol
12:26:21 <mauke> > (\x -> map (\n -> [1 .. n]) [1 .. maximum (concat x)]) [[1,2,3],[1],[1,2,3,4,5],[1,2]]
12:26:23 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
12:28:45 * hackagebot scotty 0.6.2 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.6.2 (AndrewFarmer)
12:28:47 * hackagebot wai-middleware-static 0.4.0.2 - WAI middleware that intercepts requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.4.0.2 (AndrewFarmer)
12:36:41 <yitz> > sortBy (comparing product) [[1,2,3],[1],[1,2,3,4,5],[1,2]]
12:36:43 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4,5]]
12:38:07 <yitz> > sortBy (comparing permutations) [[1,2,3],[1],[1,2,3,4,5],[1,2]]
12:38:08 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4,5]]
12:46:43 <darthdeus> scotty doing 26k req/s on my machine, not bad considering i dont know how to use compiler optimizations and other stuff :D
12:47:44 <haasn> > sortBy (comparing sort) [[1,2,3],[1],[1,2,3,4,5],[1,2]]
12:47:46 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4,5]]
12:50:06 <chrisbuchholz> I feel like I have been "reading" haskell for long enough, going from LYAH and other tutorials I've digged up. What are a good tutorial/guide/howto/book where I'll learn actually to practically apply haskell to create a program instead of just learning the theory and small bits isolated from each other?
12:50:21 <chrisbuchholz> going through LYAH and... *
12:50:51 <ClaudiusMaximus> @where rwh
12:50:51 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:50:58 <Cale> chrisbuchholz: Well, you could try RWH... yes.
12:51:09 <darthdeus> chrisbuchholz: write yourself a scheme in 48 hours
12:51:17 <darthdeus> i just finished yesterday and it's kinda enlightening
12:51:30 <greg`> its funny there isnt really one place that will do it
12:51:41 <Cale> Well, what is there really to say about it?
12:51:49 <greg`> lyah makes what could be a very heavy dross subject light and entertaining
12:51:53 <Cale> Other than providing examples of applications of various sorts
12:52:12 <croyd> member:darthdeus: how much scheme should you know going in?
12:52:20 <Cale> Or talking more about particulars of libraries which might be relevant or might not
12:52:22 <speckle> darthdeus, by scheme you mean the lisp variant?
12:52:29 <darthdeus> speckle: yes
12:52:30 <chrisbuchholz> darthdeus: but... scheme
12:52:37 <darthdeus> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
12:52:38 <speckle> thanks!
12:52:38 <chrisbuchholz> Cale: thanks, ill take a look!
12:52:51 <darthdeus> http://book.realworldhaskell.org/read/ i'd recommend too, i'm reading it atm
12:53:00 <greg`> i watched the sicp videos those where very enlightening
12:53:19 <chrisbuchholz> darthdeus: cool!
12:53:25 <chrisbuchholz> greg`: sicp?
12:53:45 <greg`> structured interpretation of computer programming
12:53:46 <Cale> You can really only get a sense for how to solve problems by solving them. I really doubt the usefulness of anything which claims to be a general methodology for solving the problem of how to structure programs.
12:53:48 <chrisbuchholz> ah
12:54:32 <roconnor> synthetic domain theory seems kinda neat
12:54:34 <greg`> its more about lisp, the idea of finding a fixed point and then the meta circular evaluator was a moment i'll always remember
12:54:53 <Cale> (Apart from the kind of things we're already doing with type systems, if that counts at all -- you still have the burden of figuring out what the types of things need to be, and that's fundamentally not something you can paper over)
12:54:53 <greg`> big aha moment "lisp is just an approximation of lisp!!"
12:57:24 <greg`> all: which version of haskell are you running?
12:58:00 <joelteon> Can you put class constraints on associated types? (have I asked this before?)
12:58:24 <Cale> joelteon: yes
12:58:31 <Cale> joelteon: You put them in the class head
12:58:56 <joelteon> Oh man, no way
12:58:57 <Cale> class (Ord (Foo a)) => C a where type Foo a ...
12:59:01 <joelteon> awesome, thanks Cale
13:00:42 <greg`> perhaps you should just define a derivative of Ord with extra constraints
13:04:56 <notobo> hello
13:05:24 <notobo> how can i define a binary data type - i'm thinking of data bin = 0 | 1
13:06:19 <roconnor> data Bin = Zero | One
13:06:43 <aristid> alternatively, type MyType = Bool
13:07:06 <Cale> data Bool = False | True  is in the Prelude already
13:07:32 <darthdeus> is there a json serialization library that takes a simple data thingy and makes a json thingy?
13:08:03 <rtpg> darthdeus, you would need some introspection for that, maybe theres some stuff that uses Template Haskell?
13:08:27 <darthdeus> rtpg: sorry i've never even touched template haskell ... i'm looking for a really simple use case though, i have just one data thingy
13:08:40 <darthdeus> and what i've got atm is       where toJSON (Article name body) = "{\"name\": \"" ++ name ++ ", \"body\": \"" ++ body ++ "\"}"
13:08:56 <notobo> yes, but i want to generate some lists with this data type and do calculations (summing) on them, so Zero | One is not good for my purpose
13:09:42 <notobo> and Bool neither
13:11:52 <Cale> notobo: If you intend to add 1 and 1, what should the result be?
13:12:02 <roconnor> notobo: what do you mean by summing lists of binary data?
13:12:50 <rtpg> darthdeus, check this out : http://hackage.haskell.org/package/json2-0.8.3/docs/Data-JSON2.html#t:ToJson
13:13:12 <rtpg> there's a function that lets you build a thing from a Map String String to a JSON expression
13:13:40 <rtpg> and vice-versa
13:14:09 <notobo> ok, i'll need to be more precise. i want something like [ [a] | a <- [0 or 1], sum [a] == 4, length [a] == 8], so all 8-element lists which have 4 Zeros and 4 Ones. No other elements except 0,1 are allowed
13:14:10 <rtpg> so you can do something like toJSON (Article name body) = toJson (fromList [("name",name),("body",body)])
13:14:22 <rtpg> it's still a little wordy, but you'll be more sure of it
13:14:46 <rtpg> you can also define instances of ToJSON and FromJSON typeclasses
13:16:14 <roconnor> > filter (\l -> foldmap (\x -> if x then Sum 1 else Sum 0) l == Sum 4) (replicateM 8 [False,True])
13:16:16 <lambdabot>  Not in scope: `foldmap'
13:16:16 <lambdabot>  Perhaps you meant one of these:
13:16:16 <lambdabot>    `foldMap' (imported from Data.Foldable),
13:16:16 <lambdabot>    `ifoldMap' (imported from Control.Lens)
13:16:23 <roconnor> > filter (\l -> foldMap (\x -> if x then Sum 1 else Sum 0) l == Sum 4) (replicateM 8 [False,True])
13:16:24 <lambdabot>  [[False,False,False,False,True,True,True,True],[False,False,False,True,False...
13:16:30 <darthdeus> rtpg: thanks, that's exactly what i need :)
13:16:36 <roconnor> notobo: ^^
13:16:40 <slack1256> What option should I pass to ghc to use another .cabal directory apart from the one in $(HOME)
13:17:19 <joelteon> Can subclasses of typeclasses provide default implementations for methods of their parents?
13:18:03 <roconnor> > filter ((Sum 4 ==) . (foldMap (\x -> if x then Sum 1 else Sum 0)) (replicateM 8 [False,True])
13:18:05 <lambdabot>  <hint>:1:94:
13:18:05 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:18:13 <roconnor> > filter ((Sum 4 ==) . (foldMap (\x -> if x then Sum 1 else Sum 0))) (replicateM 8 [False,True])
13:18:14 <lambdabot>  [[False,False,False,False,True,True,True,True],[False,False,False,True,False...
13:18:17 <edwardk> joelteon: not exactly, but there are "DefaultSignatures" which can play that role to some lesser extent
13:18:49 * hackagebot direct-sqlite 2.3.9 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.3.9 (IreneKnapp)
13:18:58 <joelteon> yeah, I sort of know how DefaultSignatures work
13:19:14 <joelteon> but what I'm doing now is writing a typeclass for a bot that can connect to the network, and I have a method openConnection :: b -> Env b Handle
13:19:27 <roconnor> edwardk: Is there a simpler type isomorphic Reducer a b that I can think of to understand it?
13:19:28 <joelteon> and I'd like to subclass it, Bot b => TCPBot b where openConnection = etc. etc.
13:19:34 <joelteon> but I don't think that's possible, is it?
13:19:52 <edwardk> roconnor: Reducer a b is a Monoid on b, and an embedding a -> b
13:19:56 <notobo> roconnor: thanks indeed, but wouldn't it be simpler to construct a data type as said in the beginning?
13:20:40 <notobo> like data bin = 0 | 1 and [[a] | length [a]==8, sum [a]==4, a<- bin]
13:21:01 <edwardk> but since it is an embedding, snoc :: b -> a -> b  and cons :: a -> b -> b may be able to be implemented more efficiently, as there are fewer cases to consider when b was constructed from a, since the embedding is rarely surjective
13:21:15 <edwardk> hnce why they are included in the reducer
13:21:21 <ClaudiusMaximus> :t (Sum . fromEnum) `asAppliedTo` False -- more golf..
13:21:22 <lambdabot> Bool -> Sum Int
13:22:56 <Clint> edwardk: this is your irregularly unscheduled adjunctions harassment
13:23:01 <roconnor> edwardk: okay, I understand the efficency issue.  But all I want is an equivalent type that doesn't use quantifiation so that it may help me understand what it is supposed to denote.
13:23:04 <edwardk> ack!
13:23:46 <edwardk> roconnor: class Monoid m => Reducer a m where unit :: a -> m
13:24:10 <roconnor> notobo: you don't need a datatype to do that
13:24:28 <roconnor> >  [[a] | a <- [0,1], length [a]==8, sum [a]==4]
13:24:30 <lambdabot>  []
13:24:33 <roconnor> er
13:24:40 <edwardk> roconnor: its just a monoid plus embedding
13:24:59 <roconnor> er
13:25:45 <roconnor> > filter (\x -> sum x == 4) (replicateM 8 [0,1])
13:25:47 <lambdabot>  [[0,0,0,0,1,1,1,1],[0,0,0,1,0,1,1,1],[0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,1],[0,...
13:26:09 <notobo> ah thats nice
13:26:14 <notobo> :)
13:26:17 <roconnor> well, I guess the type of that doesn't enforce that the values are 0/1.
13:26:32 <notobo> does what i'm looking for.
13:26:35 <roconnor> So, I think what I wrote above was better.
13:27:17 <flebron> Say I note f^t as f f f ... f, t times. Why is fmap^{6+4k} = fmap^6?
13:27:24 <notobo> thanks for the moment, maybe i'll annoy you with the data type question another time ;)
13:27:54 <roconnor> notobo: you can't easily use length x == 8 in a list comprehension because it is a filter, so it will go through every list and pick out all the ones of length 8, but since there are an infintie number of lists, that process never terminates.
13:28:28 <roconnor> notobo: hence replicateM 8 is the appropriate function to use in this case because it will choose every combination of 8 elements.
13:29:22 <notobo> thanks for that comment. indeed i've to check out the functionality of replicateM which i didn't know until now
13:29:44 <c_wraith> So why don't we have the ability to specify partial type signatures yet?
13:31:22 <joelteon> is there a stdlib function that converts a PortID to a PortNumber?
13:31:55 <roconnor> data PortID
13:31:56 <roconnor> = Service String
13:31:58 <roconnor> | PortNumber PortNumber
13:31:59 <roconnor> | UnixSocket String
13:32:05 <joelteon> oh wait never mind
13:32:41 <joneshf-laptop> edwardk, hmm, there's no bimonad in your bifunctors package, any reason?
13:32:49 <joneshf-laptop> wait, bimonad...
13:32:59 <joneshf-laptop> dyad it'd be no?
13:33:29 <c_wraith> What's the opposite of a rigid type variable?  wobbly?
13:33:30 <roconnor> monoid:monad::dioid:dyad?
13:34:09 <roconnor> c_wraith: flacid.
13:34:29 <yitz> darthdeus: that doesn't look like a very typical toJSON instance. why are you writing explicit curly braces and such?
13:34:39 <yitz> darthdeus: are you using aeson?
13:34:50 <darthdeus> yitz: i'm not using anything, which is why i asked what library should i use :)
13:34:56 <yitz> ah
13:35:30 <c_wraith> ah, wobbly is the opposite
13:35:54 <c_wraith> Is there any reason that it's hard to make _ be wobbly fresh type variable?
13:36:47 <c_wraith> ..  That might be a better question for /r/haskell than here
13:37:55 <slack1256> I got a cabal-dev directory, how can i launch ghci on there?
13:38:26 <Baughn> cabal-dev ghc
13:38:28 <Baughn> +i
13:38:51 * hackagebot coordinate 0.0.2 - A representation of latitude and longitude  http://hackage.haskell.org/package/coordinate-0.0.2 (TonyMorris)
13:41:52 <yitz> darthdeus: we use aeson, and we're pretty happy with it. it's Text oriented, though, not so much String oriented.
13:43:55 <yitz> darthdeus: so you'd write instance ToJSON Article where toJSON (Article name body) = object [ "name" .= name, "body" .= body]
13:44:12 * Baughn needs a different web framework.
13:44:22 <yitz> darthdeus: assuming that data Article = Article Text Text
13:44:39 <Baughn> ("Bypass security if security handler throws error" is not a good idea)
13:45:44 <yitz> darthdeus: oh wait actually i think it would work for String too. it's just the labels that are Text, so you just need to make sure OverloadedStrings is in effect.
13:46:06 <yitz> Baughn: which web framework?
13:46:10 <Baughn> Scotty
13:46:14 <yitz> Baughn: whichever one it is, it sounds like you
13:46:21 <yitz> re using it wrong
13:46:31 <Baughn> Perhaps I shouldn't have used a "notFound" handler for checking login data, but I don't see a better option
13:48:17 <Baughn> ..basic problem is it passes to the next handler if there's a parse error.
13:48:42 <darthdeus> yitz: sweet :) i'll give it a shot, it seems pretty reasonable
13:50:59 <slack1256> Baughn: that isn't working, I had to use "GHC_PACKAGE_PATH=./cabal-dev/packages-7.6.3: ghci" as a workaround
13:51:06 <slack1256> Later I will check why is failing
13:51:12 <slack1256> thanks anyways
13:51:31 <yitz> Baughn: in yesod, you typically start a handler with do { requireAuth; ...} or do { uid <- requireAuthId; ..} and it just does what you expect.
13:52:08 <Baughn> yitz: Well, I'm installing Yesod right now. Let's see how that goes.
13:52:14 <Baughn> May take some time. :X
13:52:37 <yitz> Baughn: yeah "installing yesod" sounds easy, but...
13:53:36 <Baughn> (Scotty is missing a few other things that make me call it incomplete. I was hoping it was just complete /enough/, but..)
13:54:44 <Baughn> Does transferring (hash(hash(password) + salt), salt) as an auth key sound reasonable?
13:55:12 <Baughn> ..I know, I know, no inventing your own crypto. Hm~
13:55:13 <shachaf> No.
13:55:22 <simpson> Baughn: HMAC.
13:55:27 <shachaf> simpson: No.
13:55:40 <shachaf> What you want is probably a key-derivation function.
13:55:46 <simpson> shachaf: Are we going to take the "don't roll your own, ever" approach?
13:56:01 <Baughn> PBKDF2, I presume.
13:56:04 <shachaf> Well, it's not really a key.
13:56:11 <shachaf> simpson: I wish. :-(
13:56:26 <shachaf> If you say that people will just ignore you. Of course.
13:56:28 <simpson> Also this is a good question. Are you making a key, or an authentication proof?
13:56:39 <Baughn> Authentication proof
13:57:00 <Baughn> shachaf: I totally won't. Having trouble finding a JS/Haskell auth library, is all.
13:57:11 <shachaf> Why are you doing it in JS?
13:57:19 <Baughn> Because that's all I can run in the browser?
13:57:25 <Baughn> Also I can't do HTTPS
13:57:37 <shachaf> Then it's more or less useless.
13:57:42 <simpson> Then an HMAC wouldn't be bad, but you wouldn't want to include any of the password information in it. So you'd probably derive a key from the password with a KDF, and then associate that with a secret session; you'd use an HMAC to prove the session.
13:57:54 <simpson> Also I'm going to stop playing cryptograher, 'cause I'm bad at it.
13:57:54 <shachaf> Someone intercepting the traffic can just change the JS code that's being run.
13:57:59 <Baughn> Honestly, just transferring the password in plaintext would be sufficient for my puropses
13:58:06 <shachaf> Use https.
13:58:09 <Baughn> I'm not concerned with eavesdropping
13:58:35 <shachaf> OK then. Don't use a password.
13:58:54 <shachaf> Well, maybe use a password. I don't know.
13:58:55 <shachaf> Anyway this is kind of off-topic here.
14:00:06 * Baughn is protecting a "restart the minecraft server" verb, not anything particularly important.
14:01:13 <Baughn> ...my god, yesod, that's a lot of build errors
14:03:36 <yitz> Baughn: if pw /= "njvd7bvIb" then authenticationError else ...
14:03:48 <Baughn> Heh. Don't think I'm not tempted. :P
14:03:53 <slack1256> Anybody has used Hatex and Diagrams together?
14:04:36 <Baughn> But I'll go with hash(pbkdf(password) + nonce), just because it makes me somewhat better.
14:05:03 <shachaf> It already has a salt.
14:05:15 <Baughn> The none is to prevent replay attacks
14:05:17 <Baughn> *nonce
14:05:26 <Baughn> ..is there a channel where this kind of thing is on-topic?
14:05:29 <sdsdfc> Is there a way to preserve order while using <+> from Control.Arrow? I have the following code: runX $ foo >>> (bar <+> baz <+> qux) >>> quux.  baz's result comes first in the output.
14:05:31 <shachaf> But whatever. I won't argue about it in here.
14:05:35 <shachaf> Yes, ##crypto, for instance.
14:10:42 <ChongLi> how do I get flycheck to work with a cabal sandbox?
14:10:55 <ChongLi> it invokes ghc to do its syntax checking
14:12:48 <slack1256> ChongLi: I am with the same doubt on the vi world
14:14:32 <yitz> sdsdfc: doesn't it depend on the particular ArrowPlus instance you are using?
14:15:09 <sdsdfc> yitz: I haven't used arrows much, so I'm not sure.
14:15:12 <yitz> sdsdfc: well, in any case, <+> is right associative; that's certainly part of the story.
14:16:13 <sdsdfc> yitz: I could change the order of things between <+>, would produce the same order for all inputs?
14:16:51 <sdsdfc> yitz: That's a poorly-worded question.
14:17:33 <sdsdfc> yitz: I just want to make sure that <+> doesn't randomly change the order.
14:19:13 <sdsdfc> yitz: Hmm, I swapped bar and baz from my example. That produces the same result as before.
14:21:21 <yitz> sdsdfc: what are the types?
14:22:12 <ChongLi> slack1256: well, there is some good news
14:22:22 <ChongLi> ghc-mod is aware of cabal sandboxes
14:22:22 <sdsdfc> yitz: bar, baz, qux :: ArrowXml a => a XmlTree XmlTree
14:23:16 <sdsdfc> yitz: I've just tried to swap qux and baz. The result is the same.
14:23:52 <yitz> sdsdfc: ah, HXT?
14:24:13 <sdsdfc> yitz: yeppers.
14:25:07 <sdsdfc> yitz: bar, baz, qux are hasAttrValue, actually.
14:25:58 <sdsdfc> yitz: The idea is to check multiple attributes and get their children, but I care about the order since I want to pipe it to the other function.
14:30:33 <sdsdfc> yitz: I think I got it.
14:30:57 <sdsdfc> yitz: The order depends on the order of attributes on the webpage.
14:32:52 <sdsdfc> yitz: So foo <+> bar <+> baz, baz <+> foo <+> bar, etc. all produce the same result.  Can I be sure that it's always the case?
14:32:53 <yitz> sdsdfc: ok, that might make sense
14:33:00 <sdsdfc> yitz: See above.
14:33:13 <aristid> :t (<+>)
14:33:14 <lambdabot>     Ambiguous occurrence `<+>'
14:33:14 <lambdabot>     It could refer to either `Control.Arrow.<+>',
14:33:14 <lambdabot>                              imported from `Control.Arrow' at /home/lambda/.lambdabot/State/L.hs:35:1-20
14:33:22 <aristid> :t (Control.Arrow.<+>)
14:33:22 <lambdabot> ArrowPlus a => a b c -> a b c -> a b c
14:34:10 <thinkpad20> hey guys, quick question, is there a type class for containers which can be instantiated with a singleton element, like `Data.Map`, `Data.Set`, `[]`, etc?
14:35:01 <klrr_> is it possible to make threads talk with eachother?
14:35:18 <klrr_> thinkpad20: monoid?
14:35:24 <aristid> klrr_: yes. for example: MVar
14:35:32 <thinkpad20> monoid doesn't provide a singleton element, only a zero
14:35:35 <roboguy_> thinkpad20: like Applicative's pure?
14:35:40 <thinkpad20> yeah like that
14:35:51 <tromp> :t pure
14:35:52 <lambdabot> Applicative f => a -> f a
14:35:54 <roboguy_> thinkpad20: What about just using Applicative then?
14:35:55 <aristid> except Map/Set aren't Applicative
14:35:58 <klrr_> aristid: so, you could have two threads modifying a MVar?
14:36:06 <thinkpad20> basically I'm thinking monoid plus a `singleton` function
14:36:19 <aristid> klrr_: it depends
14:36:33 <klrr_> thinkpad20: like a structure that only have a [a] and a [] ? (just uses list as example)
14:36:33 <yitz> @type \x -> x <> mempty
14:36:34 <lambdabot> Monoid m => m -> m
14:36:54 <thinkpad20> not necessarily only that, but that at the minimum, plus an append operation
14:36:54 <rs0> so i'm messing around with varargs functions in haskell, and i came up with the following: http://lpaste.net/97384 this compiles, but when you run it it doesn't actually print anything
14:37:13 <thinkpad20> so `empty`, `singleton`, and `append` as methods
14:37:35 <thinkpad20> I think basically any container type that implements monoid would have it, but idk if it has a name
14:38:09 <yitz> lambdabot is responding v e r y  s l o w l y. that's usually a sign that it is about to crash.
14:38:40 <sdsdfc> yitz: Why does it crash?
14:38:50 <klrr_> thinkpad20: how can you append if its only a signlaton or zero
14:38:51 <klrr_> ?
14:38:58 <thinkpad20> not ONLY singleton or zery
14:39:00 <thinkpad20> zero
14:39:04 <yitz> sdsdfc: i don't know.
14:39:14 <thinkpad20> singleton, zero and append
14:39:24 <sdsdfc> rs0: Have you read Oleg's vararg article?
14:39:24 <klrr_> thinkpad20: well then what you looking for is something that is deriving functor and monoid
14:39:33 <klrr_> or am i missing something? oO
14:39:50 <thinkpad20> well idk if it would have to be functor
14:39:57 <thinkpad20> it just needs to be able to contain things
14:40:01 <rs0> sdsdfc: i may have
14:40:08 <thinkpad20> for example set would satisfy this, even though it doesn't satisfy functor
14:40:12 <roboguy_> klrr_: I think he wants a class with a method like point :: a -> f a
14:40:19 <thinkpad20> yeah exactly
14:40:25 <klrr_> aa okey
14:40:35 <sdsdfc> rs0: http://okmij.org/ftp/Haskell/vararg-fn.lhs
14:40:35 <quchen> Pointed is non-standard
14:40:59 <quchen> @hackage pointed
14:40:59 <lambdabot> http://hackage.haskell.org/package/pointed
14:41:07 <thinkpad20> but pointed implies functor which i wouldn't need
14:41:08 <Clint> is there a pretty way to make \x -> foo x <|> bar x <|> baz x point-free?
14:41:42 <quchen> Clint: You can make everything pointfree, but it's usually not pretty.
14:41:50 <roboguy_> thinkpad20: Does it?
14:41:53 <joneshf-laptop> thinkpad20, do you really need functor?
14:42:02 <thinkpad20> no I don't and that's what I'm saying :P
14:42:02 <aristid> @pl \x -> foo x <|> bar x <|> baz x
14:42:02 <lambdabot> ap ((<|>) . liftM2 (<|>) foo bar) baz
14:42:06 <aristid> hehehe
14:42:10 <quchen> No, pointed does not imply Functor.
14:42:19 <Clint> not pretty
14:42:19 <quchen> They're orthogonal.
14:42:19 <roboguy_> thinkpad20: I don't think pointed implies Functor, since Set is Pointed (for example)
14:42:23 <joneshf-laptop> thinkpad20, i meant, do you need it for pointed
14:42:24 <thinkpad20> according to this it does http://hackage.haskell.org/package/category-extras-0.53.1/docs/Control-Functor-Pointed.html
14:42:30 <thinkpad20> but maybe I'm looking at the wrong one
14:42:40 <joneshf-laptop> isn't that deprecated?
14:42:41 <quchen> @hackage pointed
14:42:41 <lambdabot> http://hackage.haskell.org/package/pointed
14:42:42 <quchen> ^ That one.
14:42:45 <aristid> thinkpad20: category-extras is not used anymore
14:42:54 <aristid> but i think edwardk doesn't like Pointed at all anymore
14:42:59 <thinkpad20> ah, ok thx
14:43:07 <edwardk> Pointed has moved into the 'pointed' package
14:43:08 <merijn> aristid: I thought most people didn't like Pointed anymore
14:43:18 <quchen> The problem with Pointed is that it doesn't have any laws and isn't tied to anything really.
14:43:33 <edwardk> merijn: well, i started the rally in favor of it, and then eventually realized what i wrought, and started the rally aganst it ;)
14:43:41 <thinkpad20> hmm so looks like I'm basically looking at a combo of monoid and pointed
14:43:48 <aristid> merijn: maybe?
14:44:12 <quchen> edwardk: Now do that for Pro-/Bifunctor and omit the second part :-D
14:44:23 <rs0> sdsdfc: what I'm trying to write is basically a variant of http://www.haskell.org/haskellwiki/Varargs , which approaches this problem by accumulating a [String], but mentions in passing that you could also do it by accumulating the IO monad and printing the elements directly
14:44:33 <edwardk> thinkpad20: the original Pointed carried with it the assumption of Functor, but it led to the problem that flks couldn't make Set into an instance
14:44:33 <thinkpad20> well thanks guys :)
14:44:41 <thinkpad20> right yeah I see
14:44:49 <thinkpad20> that was my thought as well
14:45:07 <simpson> I still don't see what Pointed is for.
14:45:19 <edwardk> f you want "functor and monoid" you may just be looking for Applicative
14:45:28 <simpson> Although I guess it's like Default; maybe it only has rare uses.
14:45:32 <thinkpad20> speaking of which is there a fmap-LIKE function on sets, which has the ord restriction?
14:45:52 <roboguy_> edwardk: he some stuff that aren't functors, like Set
14:45:54 <merijn> thinkpad20: Set.map?
14:45:57 <edwardk> simpson: it at first seems like something you'd want, until you realize it comes with no laws so things like 'foldMap point' have t be reasoned about pointwise at each instance with no laws
14:45:58 <merijn> :t Data.Set.map
14:46:00 <lambdabot> (Ord a, Ord b) => (a -> b) -> S.Set a -> S.Set b
14:46:05 <thinkpad20> sweet, that's the ticket
14:46:22 <roboguy_> *he wants some stuff.
14:46:35 <edwardk> roboguy_: i missed the problem statement, just saw pointed =)
14:46:58 <simpson> edwardk: Yeah, and if you add in fmap to make some laws then you're halfway to Applicative, right?
14:47:15 <quchen> But then Set won't be Pointed anymore.
14:47:22 <thinkpad20> Yeah applicative is certainly more generally useful
14:47:33 <ParahSailin> how do you use startcodes with alex, the documentation seems to be out of date
14:47:34 <joneshf-laptop> quchen, why stop at bi?
14:47:36 <thinkpad20> I was just thinking for example about generalizations of intercalate
14:47:43 <thinkpad20> and the like
14:47:52 <joneshf-laptop> quchen, n-functor, n-foldable, n-applicative, etc
14:47:53 <edwardk> simpson: exactly. there are 2-3 real usecases, but my experience is every time someone says they want Pointed, they can shuffle around things and its more useful to talk about something _else_ having an associativity law
14:48:08 <edwardk> this is why i champion the use of semigroupoids rather than pointed
14:48:09 <quchen> joneshf-laptop: I don't see as many applications for n>2.
14:48:25 <quchen> joneshf-laptop: Not having "first" is a common annoyance.
14:48:45 <joneshf-laptop> quchen, does it need applications right now?
14:48:46 <quchen> joneshf-laptop: There's Arrow's version, but that one abstracts over the function, which is usually not what you want.
14:48:49 <edwardk> joneshf-laptop: once you have bi you can typically build the higher order ones out of that, its needing 'more than one' that is the critical step
14:48:54 <roboguy_> speaking of semigroups, why isn't IO an instance of Semigroup?
14:48:56 <joneshf-laptop> quchen, surelyy somone will think of a reason for it eventually
14:49:18 <quchen> joneshf-laptop: That someone is edwardk, and unless he needs it nobody does. Not even Oleg! :-þ
14:49:19 <edwardk> roboguy_: which instance? liftA2 (<>) ?
14:49:42 <joneshf-laptop> edwardk, i'm strating to see that :)
14:50:13 <quchen> joneshf-laptop: Also note that the number of n-Functors grows exponentially with n, because you need co-/contravariant versions for all positions
14:50:36 <edwardk> joneshf-laptop: i have had some code that used trifunctors and 'Triversable' mostly so i can use the latter name, but i eventually refactored it down to use two variables at most
14:50:44 <joneshf-laptop> edwardk, also, while you're here, what's the state of bifunctors? are more things being added to it, or is it kind of stagnated?
14:50:48 <lightquake> i need a dead simple config file format
14:50:59 <edwardk> joneshf-laptop: if folks want more in there, talk to me.
14:51:01 <lightquake> basically a serialized Map String String
14:51:06 <lightquake> (that's human-editable)
14:51:11 <joneshf-laptop> edwardk, dyad
14:51:11 <edwardk> i'd say its pretty stable, not stagnated ;)
14:51:18 <quchen> Oh, I was about to suggest serializing Map String String :-þ
14:51:24 <joneshf-laptop> edwardk, good to hear
14:51:27 <roboguy_> edwardk: I was just thinking instance Semigroup (IO a) where (<>) = (>>)
14:51:29 <roboguy_> would that work/
14:51:48 <ParahSailin> the docs claim that you can "begin startcode" but ghc tells me "begin" is out of scope
14:51:55 <edwardk> roboguy_: but you can see that that is only one of two perfectly viable options.
14:52:06 <edwardk> roboguy_: and the one i gave extends to a monoid, while yours doesn't
14:52:11 <roboguy_> edwardk: ahh, right
14:52:15 <edwardk> in that setting i tend to make no choice rather than the wrong one
14:52:26 <quchen> lightquake: How about JSON?
14:52:36 <quchen> Plenty of library support, intuitive to use
14:52:43 <edwardk> joneshf-laptop: what do you mean by dyad?
14:52:44 <lightquake> quchen: that works, but the deserialization is a bit more cumbersome than I'd like
14:52:57 <roboguy_> edwardk: doesn't Maybe have the same kind of problem?
14:53:16 <joneshf-laptop> edwardk, bimonad, but  bi-mon sounds odd
14:53:19 <edwardk> roboguy_: the Maybe instance is horrible. it should lift a semigroup t a monoid, but they didn't have semigroup
14:53:33 <lightquake> oh wait no it's not, never mind
14:53:37 <quchen> :-)
14:53:38 <ParahSailin> does anyone have experience with alex?
14:54:31 <edwardk> joneshf-laptop: find me some. ;)    also dyad is a bad name. there is a concept from martin fokkinga called a dyad http://wwwhome.ewi.utwente.nl/~fokkinga/mmf94c.pdf -- that i later showed has no interesting inhabitants that aren't monads/comonads.
14:54:52 <edwardk> joneshf-laptop: in general though you wind up with issues where sums and products handle very differently in the bifunctor setting
14:55:00 <edwardk> so the number of 'monad-like' notions you want to think about explodes
14:55:07 <shachaf> quchen: 2-functor means something different from bifunctor.
14:55:14 <joneshf-laptop> edwardk, i was playing around with something and came up with: `bireturn :: a -> b -> d a b`, `>>== :: d a b -> (a -> b -> d e f) -> d e f`
14:55:18 <quchen> shachaf: Oh?
14:55:42 <quchen> I smell 2-categories
14:55:43 <edwardk> joneshf-laptop: not consider Either as  bifunctor. you get a different notion of bireturn, different notion of (>>==), etc.
14:55:48 <tristan_1> hm, I was planning to have an encode and decode field in a record so the user can set the json encode/decode functions they want to use with the lib but a default one is set for them
14:55:48 <edwardk> er now
14:55:57 <joneshf-laptop> edwardk, oh, didn't know. I was going the J route :)
14:56:17 <tristan_1> but can I even do that if the type needs to be parameterized? like: encode :: (a -> ByteString)
14:56:18 <edwardk> quchen: bifunctor is a functor from a product category. a 2-functor is a functor between 2-categories
14:56:22 <joneshf-laptop> edwardk, hmm, let me think on that
14:56:42 <klrr_> what is the purpose of async library?
14:56:51 <edwardk> joneshf-laptop: basically the class you described only has a couple of inhabitants
14:56:53 <shachaf> It would be too easy if a bifunctor was between bicategories.
14:57:19 <simpson> klrr_: It's a simple way to handle STM+IO actions which happen asynchronously.
14:57:38 <klrr_> simpson: what does out-of-sync mean in this context?
14:57:39 <edwardk> klrr_: running code in a manner that is more explicit about dependencies so you can shove stuff nto the background and demand it when you need it.
14:57:56 <klrr_> okey
14:58:11 <klrr_> what do i want to look into if i want two threads that can talk to eachtoher?
14:58:11 <edwardk> klrr_: consider when you have 4 things you need to compute, when they are all done then you'll do something else. start them all going, then gather their answers.
14:58:13 <edwardk> async does that
14:58:20 <joneshf-laptop> edwardk, off the top of my head, data.map should be one right?
14:58:35 <merijn> klrr_: Control.Concurrent.Chan and Control.Concurrent.STM.TChan
14:58:42 <klrr_> edwardk: okey, thanks for the explaination
14:58:43 <edwardk> joneshf-laptop: you can't write your (>>==) you need the Ord constraint
14:58:43 <joneshf-laptop> edwardk, i'm working on a query string library so it has quite a bitin common with it
14:58:44 <merijn> klrr_: And/or MVar/TVar
14:58:47 <klrr_> merijn: will look into that
14:59:05 <merijn> klrr_: In fact, just look at every module below Control.Concurrent :p
14:59:46 <joneshf-laptop> edwardk, now why's that? we were discussing this the other day with data.map and applicatives
15:00:02 <joneshf-laptop> edwardk, is it just because it's implemented in an ordered fashion?
15:00:11 <edwardk> :t singleton
15:00:12 <lambdabot>     Not in scope: `singleton'
15:00:12 <lambdabot>     Perhaps you meant one of these:
15:00:12 <lambdabot>       `BS.singleton' (imported from Data.ByteString),
15:00:15 <edwardk> :t M.singleton
15:00:16 <lambdabot> k -> a -> M.Map k a
15:00:36 <edwardk> that makes a map, but to do anything with a map you need t be able to compare keys
15:00:48 <edwardk> :t M.fromList
15:00:49 <lambdabot> Ord k => [(k, a)] -> M.Map k a
15:00:59 <joneshf-laptop> hmm
15:01:19 <joneshf-laptop> so what about a Map where the keys don't need to be sorted?
15:01:19 <edwardk> even with an assoc-list you wind up with an Eq constraint
15:01:23 <joneshf-laptop> hmm
15:01:48 <edwardk> at that point you have a list monad. why require the elements to be pairs? just adopt that as convention
15:02:15 <edwardk> you get no benefit from the extra structure you've imparted to the elements, you've just given up the ability to say useful thngs
15:03:05 <joneshf-laptop> hmm
15:03:06 <joneshf-laptop> okay
15:03:16 <joneshf-laptop> are trees the same way?
15:03:20 <joneshf-laptop> full of compromises
15:04:20 <joneshf-laptop> though
15:04:30 <joneshf-laptop> that's not rally what i'm thinking about
15:04:49 <joneshf-laptop> nevermind
15:05:01 <joneshf-laptop> edwardk, well thsi has been enlightening
15:09:02 <thinkpad20> how do you pattern match on Data.Set? Looking at hackage the type comes with constructors Tip and Bin, but trying to use those in pattern matching gives me "not in scope"
15:09:33 <merijn> thinkpad20: They're not exported
15:09:42 <merijn> thinkpad20: You're not allowed/supposed to pattern match on Set
15:10:04 <simpson> thinkpad20: Why do you want to pattern match on Sets?
15:10:06 <thinkpad20> hmm why is that?
15:10:34 <thinkpad20> looking at the source it exports Set(..) so I would think that the constructors would be there
15:10:42 <thinkpad20> but I guess not
15:10:46 <simpson> Because one could build a Set that doesn't preserve the invariants.
15:10:58 <merijn> thinkpad20: Separation of concerns, the implementation of Set is supposed to be opaque, also this way the invariants on the ordering are preserved
15:11:14 <thinkpad20> I guess that makes sense
15:11:32 <merijn> thinkpad20: The export of "Set(..)" is inside an ifdef
15:11:47 <merijn> thinkpad20: It only exports "Set(..)" when the TESTING macro is defined
15:12:00 <merijn> Else it only exports the abstract type Set
15:12:17 <thinkpad20> ok thanks
15:12:33 <thinkpad20> I can get around pattern matching, and yeah it would probably just screw it up anyway
15:12:45 <simpson> thinkpad20: What did you want to do?
15:13:58 * hackagebot FormalGrammars 0.0.0.2 - (Context-free) grammars in formal language theory  http://hackage.haskell.org/package/FormalGrammars-0.0.0.2 (ChristianHoener)
15:14:00 * hackagebot GrammarProducts 0.0.0.4 - Grammar products and higher-dimensional grammars  http://hackage.haskell.org/package/GrammarProducts-0.0.0.4 (ChristianHoener)
15:14:35 <thinkpad20> I'm writing a type checker with type classes; I have a map from the class names to sets of types that implement those classes. But the types contain type variables, which could make it so that two equivalent types appear different because of their different variables. So I wanted to write a function where I could iterate through the set and check for that
15:14:45 <thinkpad20> buuut thinking more about it there are better ways to do this
15:15:11 <edwardk> thinkpad20: a Set has invariants that the leaves are stored in ascending order and that the tree is balanced. If we gve you the constructors those invariants are at best suggestions
15:15:45 <edwardk> you can use the Foldable instance for Set to foldr, foldl, foldMap, etc.
15:15:55 <quchen> There's still fromAscList if you want to violate the Set invariants though.
15:16:16 <edwardk> quchen: sadly
15:16:24 <quchen> unsafeFromAscList!
15:16:45 <edwardk> note: fromList and fromAscList have almost the same performance now
15:16:53 <edwardk> so there is very little reason to use the latter
15:17:11 <thinkpad20> I think it should be reasonably simple to do, but I don't think there's any way to do it faster than O(n). Oh wellz
15:17:18 <quchen> At least you can use an assertion to check the integrity of ascendingly created Sets
15:17:44 <edwardk> quchen: by the time you add the assertion you add as much overhead as fromList does in constructing it properly for that case
15:18:03 <edwardk> and you just fail awkwardly, moreover, if you do that as two passes it performs worse than fromList
15:18:15 <quchen> edwardk: Sure, but assertions aren't used when you compile with -O
15:18:21 <quchen> … iirc
15:18:26 <edwardk> fromList builds the set like fromAscList so long as the list remans in order
15:18:45 <edwardk> and then hedge merges those ascending runs
15:18:52 <edwardk> given one run? it just works
15:18:53 <quchen> edwardk: So the only overhead is checking whether the current element is larger than the last one?
15:18:58 <edwardk> yes
15:19:03 <edwardk> far less than two passes
15:19:23 <edwardk> the difference between the two was something like 2-3%
15:19:36 <edwardk> the two pass version was 100% if you turn on debugging =P
15:19:52 <edwardk> and a greater difference between test and production
15:20:03 <edwardk> i'll take the 'correct and not really slower' option please ;)
15:20:41 <quchen> Sounds reasonable
15:23:11 <quchen> edwardk: So why isn't fromAscList deprecated?
15:23:24 <quchen> … plus made a synonym for fromList
15:24:36 <zomg> Whoever runs this 24 hours of Hackage thing needs to put some back buttons into the article pages
15:24:36 <int-e> > 1
15:24:38 <lambdabot>  1
15:25:05 <zomg> Sure I could edit the URL to figure out where the index of the posts is but I'm lazy.
15:25:06 <edwardk> quchen: because it is 2% faster ;)
15:25:08 <quchen> zomg: it's ocharles
15:25:08 <zomg> =)
15:25:24 <edwardk> quchen: where? =)
15:25:31 <quchen> ..?
15:25:43 <int-e> > cata (+) [1..5] 0
15:25:45 <lambdabot>  Couldn't match expected type `Lambdabot.Plugin.Haskell.Eval.Trusted.Mu
15:25:46 <lambdabot>                                  f0'
15:25:46 <lambdabot>              with actual type `[t1]'
15:25:51 <edwardk> "zomg, its ocharles" -- never mind, if you have to explain the joke...
15:26:13 <zomg> ocharles: you should put some back buttons on the 24 days of hackage articles, would be much easier to find the rest of the things
15:26:16 <quchen> edwardk: Oh I was just answering zomg. OCharles is the author of 24-days.
15:26:25 <edwardk> quchen: yes
15:26:34 <edwardk> quchen: was a bad joke
15:26:40 <quchen> There was no joke
15:26:42 <zomg> lol
15:26:44 <quchen> I'm confused
15:26:51 <edwardk> quchen: my comment was
15:26:54 <quchen> Oh.
15:26:55 <edwardk> a dead dead joke
15:27:09 <quchen> edwardk: My statement still stands, there was no joke ;-P
15:27:12 <edwardk> beaten, trampled, pounded into the dirt
15:27:23 <shachaf> edwardk's poor joke :'(
15:27:28 <int-e> Cale: "failing", hmm?
15:27:29 <shachaf> how could you be so heartless, quchen
15:27:32 <zomg> I think the aftermath of the joke provided to be more amusing than the joke itself
15:27:57 <edwardk> its like one of those monty python skits that is so unfunny it wraps around and becomes funny again
15:28:09 <zomg> haha =)
15:28:32 <quchen> edwardk: Are you trying to sell a dead joke to me?
15:28:50 <edwardk> This, sir, is an ex-joke!
15:29:16 <quchen> I think this is drifting a little offtopic eggs bacon and spam spam.
15:29:34 <Cale> int-e: At one point, it seemed like the machine it was running on had no time to operate at all, I couldn't get things like sequence [[1,2,3],[4,5],[6,7,8]] to evaluate
15:29:47 <edwardk> clearly we need #haskell-joke
15:30:27 <quchen> It already exists! And it's empty.
15:30:47 <AshyIsMe> are you sure it's empty?
15:31:14 <AshyIsMe> or is freenode just taking a while to sync?
15:31:17 <edwardk> that's the joke ;)
15:31:26 <shachaf> It exists but I preëmptively banned *!*@* from it since I'm such a grouch.
15:31:36 <johnw> lol
15:31:41 <AshyIsMe> haha
15:31:41 <quchen> Nice diacritics!
15:42:41 <int-e> Cale: hmm. I probably can't do much about that.
15:44:00 * hackagebot shapely-data 0.1 - Generics using @(,)@ and @Either@, with algebraic operations and typed conversions  http://hackage.haskell.org/package/shapely-data-0.1 (BrandonSimmons)
15:44:08 <int-e> Cale: lambdabot is running on a virtual server (managed by ramnode); it has ensured RAM, but if another customer is hogging CPU then I have to rely on them for killing those processes. At least that's what I suspect happened.
15:45:08 <int-e> Cale: it's also possible that they migrate their virtual machines which would also explain the occasional hickup.
15:50:12 <Geek98> Hi everyone !
15:52:16 <byorgey> hi Geek98
15:54:59 <danilo2> Hello :) I'm learning about type famielies and I've got a question. Lets consider following code: http://lpaste.net/97390 . I could imagine using "associated families" (in type classes) to replace the functional dependencies, but can I use somehow closed type families for this purpose?
15:56:39 <int-e> Cale: actually there is a second possibility; lambdabot might be choking on the rate limiting code for sending messages to the IRC server. I'll have to investigate that.
15:56:55 <merijn> I don't suppose there's an "whatever is needed to match" version of 'hoist' so I don't have to do silly things like "hoist (hoist lift)"?
15:57:04 <Cale> int-e: I was getting "mueval: time limit exceeded"
15:58:35 <qtsyb> Is there a problem with Hackage at the moment? I'm getting a Forbidden: No Access for this resource. for a new upload.
15:58:42 <int-e> Cale: ok. that rules out that possibility, thanks.
15:58:52 <rasfar> I enjoyed reading your code danilo2, but I can't answer your question, not having used that stuff
15:59:02 * hackagebot SDL2-ttf 0.1.0 - Binding to libSDL-ttf  http://hackage.haskell.org/package/SDL2-ttf-0.1.0 (OmerAgacan)
16:00:42 <enthropy> danilo2: can you translate that class into one that uses type families
16:00:52 <Cale> int-e: You might want to check in your mueval's Watchdog.hs (iirc), I recall there being a really stupid small limit there which was applied separately from the commandline flag to mueval.
16:00:54 <danilo2> rasfar: Maybe this code lacks explanation - if you use this bind "as monadic binding" - instead of do notion - it automatically results in pure function if you are using no IO code inside, or results in IO function otherwise. I'm curious if is it possible to use **closed** type families there
16:01:29 <danilo2> enthropy: yes, but then I've got not **closed** type family, but a standard associated family. Is it possbile to use closed family instead?
16:01:51 <danilo2> enthropy: If I'm not wrong, we are not allowed to use closed type families as associated families?
16:02:47 <byorgey> danilo2: correct, closed type families cannot be used as associated families, because they can't be open
16:02:59 <int-e> Cale: hmm. threadDelay (7*700000) ... 4.9s *should* be enough.
16:03:08 <byorgey> and type classes are open.
16:03:50 <danilo2> byorgey: ok, so is it possible - just asking - to use closed type families in my example to throw away functional dependencies? Or have I use the associated families instead?
16:03:56 <Cale> int-e: ah, yeah, well, note that this includes the time for the compiler to run, and it's wall clock time, rather than actual cycles.
16:04:33 <vektor> soo.. It's me again. Can someone here help me use GHC to compile 2 functions from a source file?
16:04:43 <vektor> GHCi would work as well, I guess.
16:06:24 <vektor> http://pastebin.com/FxSEPCtq this is the type signature of the function. Does that sound doable?
16:06:25 <merijn> vektor: Well, it might help to say what you're having trouble with
16:06:26 <mauke> The paste FxSEPCtq has been copied to http://lpaste.net/97391
16:06:32 <int-e> and why is the factor set to 700k anyway?
16:07:01 <enthropy> danilo2: you know that you can write `type family Foo a' as a non-associated type?
16:07:03 <vektor> merijn: I don't even know where to start.
16:07:46 <enthropy> so you can use (Foo t) in the signature you give for a method
16:07:46 <vektor> so I have a source file with those 2 functions in it, evFunc and doFunc. Type signatures are in the paste.#
16:07:49 <byorgey> danilo2: sure, I think so.  define a closed type family  Result  and then have  class Bind m1 m2 where  bind :: m1 a -> (Pure a -> m2 b) -> Result m1 m2 b
16:07:58 <johnw> vektor:  [String] -> Memory -> (Memory, [String]) is pretty much the exact same thing as [String] -> State Memory [String]
16:07:59 <danilo2> enthropy: I know and I know that if I put te "where" keyword then I've got closed type family (I'm usijng ghc 7.7, so it supports it)
16:08:27 <enthropy> yes so follow byorgey's example
16:08:35 <danilo2> enthropy, byorgey: Hmm - I think I was a little confused by the theory. I think I missed a very simple use of them, brb :)
16:08:36 <byorgey> danilo2: why would you need a *closed* type family in this case?
16:08:48 <vektor> johnw: thanks for the hint. Is "State"somewhere on hackage? I'll get there when the time is right. Right now it's about making GHC my bitch :D
16:09:33 <danilo2> byorgey: Because this stuff is used in generated haskell code. I'm pretty sure, closed type families would allow the type checker to check some recursive functions, using this "Bind" class
16:09:35 <johnw> vektor: it's in either transformers (Control.Monad.Trans.State) or the mtl (Control.Monad.State)
16:09:38 <vektor> johnw: found some stuff on hackage. Guess I'll have to check that out.
16:09:54 <byorgey> vektor: (please refrain from language like that, thanks)
16:10:20 <johnw> plus, by using State you get access to a whole bunch of helper functions written around state, most notably Lens if you come to using that at any point
16:11:31 <osa1> "Lazy Haskell composes much nicer than strict Haskell" <-- can anyone explain how does this work? I'm having trouble how laziness help composability
16:11:33 <Earnestly> byorgey: (to be fair, language like that has far transcended its original meaning.  A lot of the older generation still sees it as offensive though.)
16:11:34 <vektor> alright, I'll see about that. But as I said, I'm right now focusing on GHC. I want to implement that function in the paste, so that I give it the path to a source file, and GHC returns to me the 2 functions in question.
16:12:09 <johnw> I don't know what you mean "and GHC returns to me"
16:12:14 <vektor> byorgey: ^that
16:12:39 <Iceland_jack> osa1:
16:12:39 <Iceland_jack> @src all
16:12:39 <lambdabot> all p =  and . map p
16:12:40 <vektor> nevertheless, I'll keep my mouth shut next time such words come to mind.
16:12:50 <Earnestly> For the best *nod*
16:12:51 <byorgey> Earnestly: I'm aware of that; I still don't think that particular word (b****) is appropriate for #haskell
16:13:09 <vektor> alright.
16:13:14 <johnw> vektor: we like to keep the tone somewhat professional, with occasional light humor
16:13:15 <blackdog> osa1: it means you can define something without regard to the way it's going to be used
16:13:17 <Iceland_jack> That could not be written as 'and . map p' in a strict language
16:13:32 <Iceland_jack> without doing useless computations
16:14:14 <vektor> (not even allowed to use bad language at 1 AM on the internet. ohh well. ;-) )
16:14:44 <geekosaur> it's not 1 AM for everyone...
16:14:49 <byorgey> It's 7pm for me! =)
16:14:54 <johnw> 6pm here!
16:14:54 <Iceland_jack> vektor: (also you should be in bed by now :) Haskell takes care of you)
16:14:56 <vektor> hehe. I know :D
16:15:05 <geekosaur> it's 11AM Monday in Sydney
16:15:19 * johnw wishes byorgey wasn't a whole timezone away
16:15:27 <pxqr> what is the right way to spawn some process before cabal test and kill it after tests have done? Distribution.Simple.UserHooks.UserHooks(preTest, postTest)?
16:15:38 * geekosaur not there, but has enough contacts all over the world that he keeps a world clock on his desktop to make sure he's not trying to ping someone at 0330 their time :)
16:16:32 <vektor> johnw: well, the idea is to use the GHC package. I have a path to a file.hs That file contains (or rather, should contain) 2 functions, which meet the function definitions of evFunc and doFunc.
16:17:06 <vektor> What I want is to compile the source file and return "pointers" to those functions. All at runtime.
16:17:14 <johnw> so you mean using the GHC API to parse the file?
16:17:32 <johnw> like what "hint" does?
16:17:39 <vektor> yep, kinda.
16:17:42 <johnw> k
16:18:02 <vektor> geekosaur: I know that feel got 4 different clocks on my phone.
16:18:20 * johnw has 5 clocks on his desktop, since his co-workers are all over the world
16:19:07 <vektor> so hint appears to be interpreted-only?
16:19:07 <geekosaur> (and this past week I was doing support between US east coast, US west coast, and Bangalore)
16:19:56 <johnw> vektor: I don't know of an interface that will actually return you the compiled versions of those functions; but maybe the GHC API can do that, I'm unfamiliar
16:20:14 <johnw> then again, this would be an XY problem
16:20:18 <johnw> s/would/could
16:20:23 <vektor> XY problem?
16:20:34 <johnw> http://meta.stackoverflow.com/questions/66377/what-is-the-xy-problem
16:21:30 <johnw> i.e., maybe this isn't the right way to solve what you're really trying to solve
16:21:56 <vektor> johnw: so what you're saying is "that guy doesn't *want* to use GHC to runtime-compile a function, he thinks he needs to in order to solve some other problem"
16:22:03 <johnw> exactly
16:22:15 <danilo2> byorgey, enthropy: than you, I've managed to create the closed type family for this (asn byorgey suggested) - sorry for such easy question - if you are learning something, sometimes it looks harder than it really is :)
16:22:20 <johnw> so, why do you want to runtime-compile functions? :)
16:22:42 <johnw> since I've never heard of anyone needing that except for the Accelerate project, and that's for a very special case
16:23:08 <vektor> Artificial Life: genetic algorithms on coke.
16:23:43 <vektor> So an AI Agent's implementation consists of those 2 functions: do and ev. "do" tries to solve a specific problem at hand - play TicTacToe, play chess, do whatever.
16:23:55 <vektor> that's the conventional part
16:24:26 <johnw> and ev evolves the code into a newer version
16:24:33 <danilo2> byorgey, enthropy: I've got a connected question if I could (my code now looks like this - the annotation: http://lpaste.net/97390). Is it possible to tell Haskell, that if I'm using the "bind" function, it should only consider IO or Pure types as possible types for m1 and m2? That there would never be other types allowed?
16:24:42 <johnw> and you would want to replace the previous do with the new version created by ev, plus a new ev for the next iteration?
16:25:15 <vektor> "ev" is meant to take the agent's own .hs source file (and maybe other .hs files) as parameter and rewrite it
16:25:40 <enthropy> that BindResult type family doesn't use any overlap
16:25:49 <vektor> basically, that's where the coke is: it doesn't just randomly permute, but instead actively guides it's genetic code.
16:26:04 <vektor> exactly
16:26:19 <danilo2> enthropy: is it wrong ?
16:26:23 <enthropy> you could have written it with an open type family, and probably there's a trick to prevent people from writing new instances
16:26:33 <enthropy> such as not exporting that type family
16:27:14 <enthropy> danilo2: no it's not wrong, it's just that you're requesting features you aren't using
16:28:04 <danilo2> enthropy: I do not want to prevent people - I want to force tpye checker to try these 2 types when infering types. Right now If im using this stuff in a recursive function - I get an error about types, that are ambigous. If I misstype it (tell GHC the wrong type, like, testrecfunc :: Pure ...), It complains it sohuld be IO. So If GHC would now
16:28:05 <johnw> vektor: http://hackage.haskell.org/package/plugins-1.5.4.0/docs/System-Eval-Haskell.html
16:28:05 <enthropy> maybe you just want   data M a = Pure a | IOtag (IO a)
16:28:10 <johnw> vektor: maybe that is more what you want?
16:28:17 <danilo2> enthropy: that only these 2 types are allowed, it would infer it without problems
16:28:19 <heatsink> I think you could promote an ADT to the type level
16:28:29 <vektor> johnw: how would you go about solving that problem? in essence, doFunc and evFunc should be pure functions, which makes me think that I a) need additional security features to prevent an "outbreak" and b) probably won't need most of the stuff GHC provides. Just plain lambda, for the most part.
16:28:35 <heatsink> I don't know if the type checker will do case analysis though
16:28:46 <enthropy> danilo2: we discussed this yesterday I think
16:29:04 <enthropy> didn't the option of making your instances more overlapping help?
16:29:30 <danilo2> enthropy: We were talking yesterday about very simmilar stuff. I am just wondering if type families would help me to solve this in other way
16:29:43 <johnw> vektor: hmm.. maybe read the user's code in as a string, and maintain the string as your 'State', with the product of the evaluation being the compiled version of the string (the code).  Then you would just mutate the string as you go along, which is essentially what you were originally asking about.  So I'd have to agree that you want what you want
16:30:05 <danilo2> enthropy: ahhh, I remember now what you are tlaking about! It helped for a moment, but it caused errors in some cases
16:30:15 <heatsink> danilo2, is it just that you want an easy way to statically select a type?
16:30:30 <enthropy> danilo2: hearsay is that functional dependencies are just sugar for type families in current ghcs
16:30:35 <danilo2> enthropy: When I was using your solution, the type inferencer was picking the one you proposed **even if there existed** more specific one
16:30:36 <vektor> good to hear your Y matches mine :D
16:31:00 <johnw> vektor: from this discussion, it becomes pretty clear why Lisp's homoiconicity is such a big win for AI
16:31:02 <enthropy> ok I thought something like that
16:31:21 <danilo2> enthropy: brb, I'll paste yesterdays code and the error I was getting with your solution
16:33:15 <danilo2> enthropy: This is the proposed solution: http://lpaste.net/97393 . If you look at line 22, it was selected by type inferencer **even if** instance from line 8 matched - causing an error, which didnt appear before
16:33:57 <danilo2> enthropy: Because of that I was looking for type families based solution - and I was thinking, that maybe with closed type families I'm able to solve this question in more "informative for GHC" way
16:35:09 <danilo2> enthropy: Do you have any idea - if / how can it be fixed? Your yesterdays solution fixed the recursive problem, but caused the one, i described 2 lines above
16:36:19 <south> I have a quick question for you guys.
16:36:29 <south> I have a class defined like so:
16:36:34 <south> class Id a = identity :: a
16:36:42 <south> er
16:36:48 <south> class Id a where identity :: a
16:37:04 <south> I want to make every Monoid an Id, like so:
16:37:14 <south> instance (Monoid a) => Id a where identity = mempty
16:37:27 <haasn> south: that doesn't do what you probably think it does
16:37:28 <south> but it doesn't quite work
16:37:36 <vektor> so if I wanted to go with System.Eval.Haskell, I would pass the function's actual implementation as the String, while supplying any wanted/allowed/required imports as the second argument?
16:37:37 <haasn> that makes every ‘a’ an instance of Id, but requires it have a Monoid constraint as well
16:38:17 <south> Oh, okay
16:38:28 <south> Is there a simple way to say "If a is a Monoid, a is an Id?"
16:38:41 <haasn> south: make Monoid a subclass of Id
16:38:50 <haasn> (this is not possible without modifying Monoid)
16:38:56 <south> Hmm.
16:39:03 <south> Seems weird
16:39:04 <vektor> johnw: ^
16:39:05 <haasn> you could also provide a newtype wrapper, eg. instance Monoid a => Id (WrappedMonoid a)
16:39:08 <enthropy> danilo2: maybe an alternative is to convert everything to IO, so you can just use the IO version?
16:39:17 <johnw> vektor: I believe so; I haven't used that library before
16:39:19 <haasn> you could also of course use OverlappingInstances but that's ugly
16:39:25 <johnw> vektor: at this point, people in #ghc may have better answers
16:39:33 <vektor> haha
16:39:40 <vektor> doing it right then :D
16:39:44 <south> haasn: Yeah, I don't really want to do anything ugly, but it seems like this type of behavior should be allowable
16:39:54 <haasn> you could provide a default signature for identity; eg. default identity :: Monoid a => a; identity = mempty -- this would let you write just eg. “instance Identity [a]” without repeating the line
16:40:04 <johnw> well, this channel is more about Haskell-the-language, while #ghc is about a particular compilation environment, which your question seems more directed to
16:40:09 <tristan_1> hm, is the way to convert a lazy bytestring to a strict bytestring just toChunks?
16:40:21 <enthropy> class Promote a b | a -> b where promote :: a -> b; instance (a ~ b) => Promote (IO a) (IO b) where promote = id; instance (a ~ b) => Promote a (IO b); ...
16:40:24 <haasn> fromChunks, you mean?
16:40:31 <south> haasn: I'll give that a shot
16:40:44 <johnw> south: but there is no way to "auto-generate" Id instances for every type that is also a Monoid
16:40:51 <tristan_1> lazy toChunks returns a list of strict bytestrings
16:40:57 <johnw> you'll have to do it on a type-by-type basis
16:41:14 <haasn> south: there are language proposals to allow this kind of thing but nothing concrete in place yet
16:41:25 <haasn> eg. an ability to add a superclass of an existing class (+ a default implementation)
16:41:27 <south> haasn: Haha, funny that I stumbled upon it then
16:42:07 <south> haasn: It almost seems like this type of thing should exist though, there have been several occasions where I want to make a type have an identity element without mconcat
16:42:55 <south> thanks for your help, in any case haasn :)
16:43:01 <haasn> south: an identity to *what*?
16:43:30 <haasn> “x is an identity” means “x · y = y” for some ·
16:43:40 <south> Hm
16:43:48 <south> haasn: I guess I mean like
16:43:51 <haasn> so a class with just the “identity” singled out doesn't make a lot of sense
16:44:12 <c_wraith> yes, that's why monoid names that it's an identity element *with* an operation
16:44:14 <danilo2> enthropy: I'm sorry - I forgot to plug my laptop to electricity and it went down
16:44:23 <south> Suppose I have a player for a game that I want to start out with the same stats at the beginning of every game
16:44:30 <haasn> south: class Default, maybe?
16:44:39 <haasn> (this exists)
16:44:42 <south> I guess I'd like there to be a class that wraps this behavior
16:44:45 <haasn> eg. for configurations
16:44:52 <haasn> default { SomeField = someChangedConfig }
16:44:58 <south> Yeah, that sounds about perfect
16:45:02 <south> Where's that implemented?
16:45:06 <johnw> data-default
16:45:12 <south> Thanks!
16:45:35 <haasn> oh; def, not default
16:45:36 <danilo2> enthropy: I do not want to use IO :( I've got the IO version working right now and it scales ugly when you are using for example array of 10 000 Ints from function with (IO Int) signature
16:46:19 <danilo2> enthropy: It is slow, eats a lot of heap etc
16:47:00 <AshyIsMe> does haskell have something like the f# type providers?
16:47:13 <AshyIsMe> a work colleague was showing them to me recently and they look pretty nice
16:47:15 <zRecursive> danilo2: haskell indeed needs more RAM
16:47:32 <danilo2> zRecursive: what do you mean ?
16:48:14 <zRecursive> i mean more RAM will make haskell happy
16:48:40 <danilo2> zRecursive: In the GHC 7.7 the heap was inccreased to the 80% of available RAM, but this is not a solution for my problem - where I want to stick with pure functions because they are not eating ANY ram, but it is a bit long story :)
16:49:23 <mietek> Anyone using Snap with React.js?
16:49:33 <south> johnw: haasn:  Default works great; Thank you!
16:49:55 <south> It just irked me that I couldn't generalize easily
16:49:59 <johnw> south: just realize that "def" can mean anything the implementor of the instance wants
16:50:00 <zRecursive> danilo2: then who eats a lot of heap as you said ?
16:50:02 <south> But with Defaul that works
16:50:04 <johnw> it's lawless, in other words
16:50:14 <south> johnw: Yeah, that makes sense
16:50:17 <johnw> there's no guarantee whatsoever that it will always mean what you expect it to mean for a given type
16:50:40 <south> johnw: Understandable, it would be hard to define without any other constraints
16:50:47 <danilo2> zRecursive: something like sequence over an array of 10000 [IO Int]
16:50:49 * haasn .oO( instance Default Double where def = 0/0 )
16:50:59 <south> johnw: But it definitely works for this case, so thank you!
16:51:24 <south> I'm basically just making a text-based game
16:54:08 <chritchens> hi, is there anyone parteciping to the fp competition?
16:54:29 <chritchens> parteciping => who has joined...
16:55:47 <zRecursive> danilo2: Maybe you can try: Data.Vector/Data.Vector.Unboxed, Data.Array.Vector ...
16:55:55 <danilo2> I'm just messing up with type  families :) I would be very thankful if someone would tell me, why the following code is not working (including error message): http://lpaste.net/97394
16:56:23 <johnw> it's just "type family GetTheType a"
16:56:32 <johnw> you don't define instance methods like you do for type classes
16:56:45 <johnw> then you define what "GetTheType a" is for particular instances of a
16:57:12 <johnw> type instance GetTheType Int = (Int, Int), for example
16:57:44 <danilo2> zRecursive: Thank you :) I know it could help. I told you this is a little longer story - I'm generating haskell code out of some kind of DSL. Because of that I'm a little limited of what I can do, but I wanted to create a system, hich would automatically check if we are in IO or not. And now I've got no problem with 10000 [IO Ints] as before, but some other one
16:58:25 <danilo2> zRecursive: I've only answered your question - what I was exactly talking about, when I was talking about RAM issue :)
16:59:10 <zRecursive> heh
16:59:50 <danilo2> johnw: hmm, but I think I did it correclty. I defined GetTheType (closed type family), which (it can sound stupid, but I'm checking something) tells, that GetTheType X is of Type X. then I'm using it in function signature - whats wrong here?
17:00:38 <danilo2> johnw: If you comment out the line 15 it compiles
17:00:49 <kersplodey> hey guys, has anyone got any experience with printing out binary trees in a vertical fashion?
17:01:07 <kersplodey> I've managed to get it going sideways, but vertical is so much nicer
17:03:54 <danilo2> Oh I see the problem in (http://lpaste.net/97394)! Haskell cannot infer "a" even if it has only one possibility (because of the usage of closed type family) - is it a bug? Or Haskell is not supposed to make such obvious conclusions in this case?
17:04:07 * hackagebot free-game 0.9.4.2 - Cross-platform GUI library based on free monads  http://hackage.haskell.org/package/free-game-0.9.4.2 (FumiakiKinoshita)
17:04:41 <jle`> kersplodey: one way commonly to do it is to populate a grid
17:04:45 <jle`> and then print the grid
17:05:54 <johnw> what does "where" mean on a type family?  that syntax is new to me then
17:05:57 <jle`> actually i wonder if it can be done recursively without the interpediate grid step
17:06:09 <copumpkin> johnw: probably closed?
17:06:49 <johnw> ah, yes
17:06:54 <mikeplus64> johnw: yeah, it's a closed type family, meaning there are only the instances that are within the "where" block, and they match top-down
17:07:00 <johnw> it gives the scope of all possible type family instances
17:07:08 <kersplodey> jle`: I hadnt actually seen that grid approach mentioned in all of my googling. People keep making a reference to a Data.Tree.Pretty package. I have no idea how to use it though...
17:07:08 <johnw> ok, cool
17:07:17 <johnw> I just learned how to use closed type families :)
17:07:25 <mikeplus64> they're pretty nifty
17:07:30 <jle`> kersplodey: oh i was talking about the language-agnostic approach
17:07:34 <lightquake> pipes are pretty neat
17:07:54 <jle`> if there is a pretty package already for it then that might be better haha
17:07:55 <danilo2> mikeplus64, johnw: Ok, they are cool, but why Haskell does not use them to infer types in my example? ( http://lpaste.net/97394 ) ?
17:08:29 <TravisD> if PC part picker tells me that the estimated wattage of my computer is 374W, is a 400W power supply a safe enough choice?
17:08:48 <kersplodey> jle`: I'm doing this for a college assignment, and our lecturer has specified he wants it done recursively
17:08:48 <merijn> johnw: Within a where clause type families are matched in lexical order, allowing you to write closed type families
17:09:04 <merijn> johnw: Normally, type families are matched in undefined order, like class instances
17:09:28 <merijn> johnw: To pimp my own neat example: https://gist.github.com/merijn/6130082 :)
17:09:37 <kersplodey> I've managed all of the insertion and balancing (AVL tree) recursively, so it would be a shame to break it here :P
17:10:05 <johnw> danilo2: I don't know
17:10:18 <johnw> merijn: I was mentioning this example to a co-worker not 4 days ago
17:10:30 <merijn> \o/
17:10:32 <danilo2> johnw: Ok, thank you :)
17:10:34 <TravisD> Oh sorry, wrong channel
17:10:50 <jle`> kersplodey: how pretty does this have to be?
17:11:27 <kersplodey> jle`: the way I have it now would be fine, but I'd prefer to make it nicer to maximise the marks I get. At this point its a personal preference
17:11:34 <merijn> I wanted to give a talk on stuff like this at the local FP group (Amsterdam), but the low number of haskellers makes me afraid I'd waste my time
17:12:05 <dilinger>  /win 29
17:12:16 <Hodapp> dilinger: you, sir, have too many IRC windows open.
17:12:28 <dilinger> yeah, i know :/
17:12:31 <danilo2> merijn: It seems, you know closed type families - do you think, they could help me with this code (annotation to: http://lpaste.net/97390 ) - I want to inform the Haskell's type inferencer, that when I'm using "bind", the "m1" and "m2" coudl be only of types IO or Pure ?
17:12:40 <rdevilla> and I thought 19 was bad ._.
17:13:05 <merijn> danilo2: I looked at the example, but I didn't quite understand what you were doing and couldn't be arsed to figure it out at 2AM, sorry :)
17:13:12 <Hodapp> I've been trying to drag the Pythonista at $day_jerb over to the world of static typing and functional languages... he groks the functional stuff a bit, but not static typing.
17:13:39 <danilo2> merijn: heh, ok :) Should I try to tell you, what is it doing, or should I try tommorow? :)
17:13:51 <danilo2> merijn: If you dont mind of course :)
17:14:12 <enthropy> merijn: that example works? With a my ghc77_20131004 it doesn't
17:14:15 <merijn> danilo2: Tomorrow would be a better bet, I was about to head to bed :)
17:14:29 <speckle> Hodapp, how would you drag a Java programmer? :)
17:14:39 <danilo2> merijn: Ok, thank you :) I'll write you tommorow
17:14:44 <enthropy> which does things like   type family F a where F a = ...
17:15:02 <merijn> enthropy: I have 7.7.20130615
17:15:11 <merijn> enthropy: I know the syntax was changed slightly after I wrote it
17:15:25 <merijn> enthropy: But I couldn't be arsed to recompile GHC yet, so I haven't fixed it
17:15:44 <benbangert> is there a preferred lib for a strict b-tree?
17:16:06 <danilo2> enthropy, merijn: I belive this is the new syntax: http://lpaste.net/97395
17:16:11 <Hodapp> speckle: I dunno.
17:16:51 <merijn> enthropy: I think it should work if you try it like: https://gist.github.com/merijn/6130082 ?
17:16:56 <Hodapp> speckle: Folks who acknowledge the benefits of a high-level language and GC aren't totally gone, but sometimes they're very set in their OOP ways.
17:17:24 <benbangert> Hodapp: the bit that is most daunting is how much there is, even though soooo much isn't actually required to Get Things Done
17:17:55 <speckle> how much of what there is?
17:18:00 <enthropy> merijn: yeah that should work. Do you find the (a ~ "oops!") error doesn't show up early enough?
17:18:00 <Hodapp> STUFF!
17:18:12 <danilo2> merijn: I've pasted this fixed code 2 lines about yours :) What is it suppsoed to do ?
17:18:20 <benbangert> speckle: how much to haskell there is, with abstractions on abstractions, etc. it seems like an endless list of abstractions to learn
17:18:32 <merijn> enthropy: It's a bit brittle, if you write "foo 1" it breaks unless you annotate the type
17:18:45 <merijn> enthropy: Because it can't prove you didn't mean a Num instance for ()
17:19:11 <merijn> danilo2: You can restrict type variables to be "anything but X"
17:19:29 <merijn> danilo2: The example foo accepts any type as argument, as long as it's not type () or type Int
17:19:49 <merijn> "foo 'c'" returns 'c', "foo (1 :: Int)" is a type error
17:20:00 <danilo2> merijn: hmmm, interesting, because, when I'm writing "print $ foo (1::Int)" it works
17:20:31 <danilo2> merijn: on ghc-7.7.20131217
17:20:37 <merijn> Really?
17:20:45 <danilo2> merijn: really
17:20:47 <merijn> Odd, maybe this is not the right fix, then
17:20:58 <merijn> I will have to update GHC to check
17:21:07 <speckle> Hmm, not sure what it means to be set in OOP ways - I'd think people would be happy to use whatever's available to them in terms of abstractions
17:21:15 <merijn> Or someone broke the type equality thing I use
17:21:27 <speckle> After all, they had to start using OOP instead of procedural code at some point, in the first place
17:22:20 <blackdog> speckle: OO as it's typically practiced is a structuring mechanism for holding procedural code :)
17:22:54 <Hodapp> speckle: It means to try to apply OOP to everything and to see all problems as in a domain that OOP best models.
17:22:58 <chritchens> blackdog: so continuations are bad?
17:23:41 <chritchens> blackdog: if used to imitate procedural code, I mean
17:24:05 <speckle> I believe OOP is about being able to properly abstract things away.  Languages can make it easier or harder, but they can't force you to do it
17:24:34 <jle`> OOP is procedural
17:24:36 <Hodapp> speckle: Some languages can force you to use certain abstractions.
17:24:47 <speckle> Of course, OOP has some limitations in terms of abstractions compared to functional programming, but I think proper OOP code would at least take advantage of those abstractions
17:24:49 <Hodapp> speckle: if you want there to be abstraction at all.
17:24:54 <jle`> it's just a way of structuring and abstracting procedural programs
17:25:12 <enthropy> merijn: might be that ghc ignores the first case which is trying to make an equality between something with kind k and Symbol
17:25:25 <enthropy> which can never be satisfied... maybe that's too much
17:25:27 <blackdog> chritchens: yeah, i'd call that an abuse. same as doing all your haskell hacking in the IO monad
17:25:42 <enthropy> in any case I get  foo :: a -> a
17:25:44 <blackdog> you can write Fortran in any language, after all
17:25:58 <chritchens> blackdog: yes, I think it too. Very ugly.
17:26:28 <chritchens> blackdog: on Fortran: +1
17:27:13 <rasfar> i'm trying to get haddock+hscolour working for the first time
17:27:27 <merijn> enthropy: No, that's not a problem, I added that line specifically to force a type error
17:27:45 <rasfar> can anyone tell me, do the definitions need to be in the first column to get anchors?
17:28:05 <merijn> enthropy: Without that the type error is unparseable, by forcing it to fail on equality between type and Symbol it prints that entire Symbol string, which is a more useful error :)
17:28:21 <rasfar> i know they need to be top-level, but I have a habit of indenting 2 spaces...
17:28:38 <merijn> enthropy: I'm worried the equality check of a's in "Restrict a (a ': as)" may have broken
17:30:17 <rasfar> it seems like HsColour is always producing anchors with names like "line-55"
17:31:00 <rasfar> whereas Haddock is producing hrefs like "srcs/Tree.html#addChild"
17:31:19 <merijn> enthropy: Anyhoo, I'll fix it later
17:31:51 <rasfar> i'm using the script example near bottom of http://www.cs.york.ac.uk/fp/darcs/hscolour/
17:32:17 <enthropy> merijn: this is my fix for it http://lpaste.net/97396
17:33:25 <rasfar> i've done a number of experiments but there seems to always be this fundamental disparity in the anchor name conventions
17:33:29 <rasfar> anyone?
17:37:44 <rasfar> nobody uses HsColour then? or just nobody cares?
17:38:49 <enthropy> hscolour is pretty popular (hackage uses it)
17:39:04 <rasfar> i suppose using cabal is the usual way, but only two modules are ready (quite a few changes are needed to make them acceptable to Haddock, as I've got...
17:39:30 <enthropy> I think you just   cabal haddock --hyperlink-source, and get those anchors sorted out
17:39:55 <rasfar> yeah i imagine you're right ... I was hoping to go one module at a time, that's all.
17:40:00 <enthropy> in my experience, the "source" links haddock makes point to the right place
17:40:21 <enthropy> well you can look at how cabal calls haddock/HsColour
17:40:27 <kersplodey> Any chance anyone could provide some guidance on how to print a binary tree in a vertical fashion?
17:40:33 <rasfar> because there are lots of issues in my code, for example if you comment out a guard, that is interpreted as a doc comment by Haddock...
17:40:38 <rasfar> -- |
17:41:03 <rasfar> so I wanted to go manually, take it slow one module at a time, rather than commit to rash pervasive edits
17:41:36 <rasfar> it's going well, just that HsColour run standalone with -anchor, for me, always produces "line-34" etc. anchor names
17:41:48 <rasfar> thanks enthropy for saying something
17:42:22 <rasfar> i'll let the source links be a final treat, when whole project is ready for cabal haddock --hyperlink-source, then
17:42:51 <rasfar> (or look at how cabal calls the tools, right)
17:43:47 <rasfar> kersplodey: how about printing it horizontally to a buffer and transposing it? (with some symbol substitutions)
17:45:26 <kersplodey> rasfar: I have it printing horizontally already, how would I go about doing the transposition? I'm quite new to haskell...
17:46:01 <rasfar> i know you have it horizontally already, that's why i thought this might help
17:46:27 <rasfar> you could "render" to a [[Char]], then Data.List module has function "transpose"
17:46:59 <kersplodey> rasfar: i'll look into that. thanks :)
17:47:31 <rasfar> or if you already render to a single String, you can do "lines" function to get it in [[Char]]
17:47:39 <rasfar> as transpose needs list-of-list
17:48:11 <rasfar> then "unlines" ... so something like (unlines . transpose. lines . showTreeHorizontal ) myTree
17:48:52 <rasfar> you're welcome, it's nice to help (and even nicer to get it, when that happens...)
17:53:08 <kersplodey> rasfar: I've just become very confused with my lists and strings haha. So by using "lines" it turns a single string into a list of strings?
17:53:16 <kersplodey> from which I can then transpose it?
17:55:52 <johnw> > lines "foo\nbar\nbaz\n"
17:55:53 <lambdabot>  ["foo","bar","baz"]
17:58:29 <johnw> > under (iso unlines lines) transpose "Hello"
17:58:30 <lambdabot>  "H\ne\nl\nl\no\n"
17:59:51 <FreeFull> > unlines . transpose . lines $ "Hello"
17:59:52 <lambdabot>  "H\ne\nl\nl\no\n"
18:03:20 <kersplodey> Stupid question maybe...but to use transpose I just have to import Data.List.Transpose right?
18:03:46 <geekosaur> @index transpose
18:03:46 <lambdabot> Data.List
18:05:02 <rasfar> kersplodey: sorry had to disconnect there
18:05:07 <kersplodey> Can I not just import the transpose function? I (perhaps unwisely) named one of my own functions insert and its complaining
18:05:29 <rasfar> right, lines breaks a String into a [String] at the line breaks
18:05:39 <rasfar> import Data.List ( transpose )
18:05:40 <geekosaur> import Data.List (transpose)
18:05:54 <tippenein> @index liftIO
18:05:54 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
18:05:55 <larss> how can I have two definitions of a function, for windows and for non-windows OSes?
18:06:10 <nooodl> :t iso
18:06:11 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
18:06:23 <johnw> larss: using the C preprocessor
18:06:32 <johnw> {-# LANGUAGE CPP #-}
18:06:42 <kersplodey> rasfar: Would you mind taking a look at what I've got?
18:06:52 <rasfar> kersplodey: you can also hide specific names in an import:
18:06:57 <kersplodey> I'm feeling kind of lost at the minute...
18:07:03 <johnw> #if mingw32_HOST_OS
18:07:07 <rasfar> import Data.List hiding ( insert )
18:07:16 <johnw> or whatever your host identifier ends up being
18:07:20 <larss> johnw: ah ok, thanks
18:07:35 <rasfar> suer kersplodey, @lpaste
18:07:48 <rasfar> @lpaste even
18:07:49 <lambdabot> Haskell pastebin: http://lpaste.net/
18:08:38 <kersplodey> http://lpaste.net/97397
18:09:13 * hackagebot purescript 0.2.0 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.0 (PhilFreeman)
18:09:27 * rasfar is in a fine mood, solving one of my favourite problems ... for the 3rd or 4th time pfft
18:09:42 <kersplodey> If you see any other issues with the code please point them out. I actually really enjoy haskell.
18:09:53 <rasfar> (which is actually related to presenting trees, come to think of it)
18:11:14 <rasfar> first thing I notice, you aren't putting spaces around . when using as function composition. it's a good idea to have whitespace there in Haskell.
18:11:15 <roboguy_> kersplodey: there's some style stuff, you should use guards instead of a bunch of ifs and you should get rid of all the 'do's
18:11:58 <rasfar> you should only have to transpose once, towards the end...
18:13:05 <rasfar> the idea is, if this was an image you were rendering, you'd just rotate it 90 degrees to get what you want
18:13:44 <rasfar> this will actually flip it through a diagonal line, so it's not quite the same, but you can do some trick with "reverse" maybe
18:13:56 <kersplodey> rasfar: yeah I get the idea of it, I'm just struggling with the implementation. Obviously its not as simple as just slapping a transpose in there.
18:14:06 <roboguy_> kersplodey: also, you want $ not . after transpose. You are applying the function there, not composing it
18:14:07 <rasfar> heh. well, it almost is.
18:14:35 <rasfar> it would be better if you could paste the code as it was before we met :D
18:14:48 <rasfar> from there, it will be very small change
18:14:54 <kersplodey> roboguy_: Ah! Thanks
18:16:15 <rasfar> you just added one "unlines", and two "transpose", right?
18:17:53 <larss> what CPP define should I use to ensure I am on windows? I wouldnt expect mingw32_HOST_OS if haskell was compiled with other windows compiler
18:17:56 <kersplodey> rasfar: Going to be completely honest. Got the printing section off a website, and didnt even notice it was using transpose as it was
18:18:11 <kersplodey> So that's quite a large fault on my part >_<
18:18:18 <rasfar> oh, then never mind my annotation!
18:18:30 <rasfar> it's probably pretty broken
18:18:54 <kersplodey> This is a college project due tomorrow. Been working like crazy on it for most of the day
18:19:19 <kersplodey> Like I mentioned, the horizontal printing is fine, but I want to try get some "style" makrs
18:19:21 <kersplodey> marks*
18:19:44 <rasfar> we both got some stuff to work on then! :)
18:20:19 <roboguy_> kersplodey: you'll definitely change the ifs to guards and remove the 'dos' in that case
18:20:26 <roboguy_> *definitely want to
18:21:32 <kersplodey> roboguy_: Is that just general better Haskell practice?
18:21:43 <kersplodey> or is there a functional reason? I thought they achieved the same goal
18:22:14 <roboguy_> kersplodey: yeah, the 'do's don't do anything in this instance. The guards just look nicer
18:22:16 <roboguy_> (I think)
18:22:34 <roboguy_> do is needed when you want to use the syntactic sugar for working with monads
18:23:28 <roboguy_> and you aren't using any kind of monadic operations, so they are entirely unnecessary here
18:25:42 <roboguy_> also guards are usually preferred over ifs
18:25:48 <kersplodey> roboguy_: to use a guard is it simply      |balance == 2 && leftbalance == (-1) = rebalanceRight (Root a left (rebalanceLeft right))  ?
18:26:35 <kersplodey> Heh. obviously not
18:30:14 <benbangert> so uh, b-tree... better off making my own type, or is there a nice lib for strict b-trees that ppl use?
18:30:17 <roboguy_> kersplodey: the search function uses guards so it would be like that. Also, you will need to change that 'let' into a 'where'
18:30:57 <roboguy_> 'let's don't really work with guards, but 'where's do
18:32:04 <larss> I see haskell libraries use #ifdef mingw32_HOST_OS to detect windows, but isn't this unportable? what if ghc was compiled with some other compiler, like cygwin's gcc?
18:32:32 <larss> and what about defines for other OSes?
18:32:35 <benbangert> larss: if its like any other lang, my experience has been that only windows needs special-cases for the most part
18:33:01 <larss> benbangert: but cygwin runs on windows too
18:33:19 <roboguy_> kersplodey: actually, the problem you are running into is probably because of the "let" thing. if you move those into a "where" it should work
18:33:24 <benbangert> maybe cygwin installs libs that make windows act more POSIX-like? I dunno
18:34:13 <lingxiao> has anyone gone through "typing haskell in haskell", and comment on how complex of a program you think the typechecker the authro implemented is?
18:34:28 <kersplodey> roboguy_: I changed it into a where and it's still throwing up an error.
18:34:39 <lingxiao> this includes both complexity of the underlying idea, and complexity of implementing the idea
18:35:03 <roboguy_> kersplodey: hmm, put what you have for that function on the paste site
18:35:14 <rasfar> larss: there's also #ifdef CABAL_OS_WINDOWS if you're expecting builds via cabal
18:36:07 <larss> rasfar: i do, but when developing I am using ghci
18:36:24 <lightquake> something that I see sometimes in Haskell libraries is that a function f is presented as having some simpler type when it really has a more complicated, general one
18:36:31 <lightquake> but of course when you do :type f you get the most general one
18:36:37 <rasfar> that shouldn't hurt (you know what platform you're on I guess)
18:36:40 <larss> so are there no standard defines for host OSes? are we suppose to use something other than CPP for this?
18:36:43 <lightquake> i wish there was some way to tell ghci or whatever 'oh, also print these types'
18:36:45 <kersplodey> roboguy_: http://lpaste.net/97399
18:38:04 <enthropy> larss: you can get cabal's CPP defines in ghci if you start ghci with  `cabal repl`
18:38:10 <roboguy_> kersplodey: turn all the tabs into spaces and make sure everything lines up. Tabs are usually a bad idea in haskell
18:38:26 <rasfar> larss: alternatively, you maybe can use the Distribution.System API
18:38:27 <enthropy> and have a .cabal file of course
18:38:42 <mirpa> Is this convenient to collect successful MaybeT values? (fmap catMaybes . mapM (runMaybeT . (f :: Int -> MaybeT IO Int)) $ [1..4]) :: IO [Int]
18:38:49 <roboguy_> there's probably an option in your editor to automatically put spaces instead of tabs
18:39:09 <tippenein> if there isn't you should change editors
18:40:06 <kersplodey> roboguy_: aha. That got it. I wish I had known about the tab thing before...
18:42:09 <roboguy_> kersplodey: there's a program that automatically checks some style things called "hlint". It's pretty handy
18:42:38 <kersplodey> roboguy_: I'll keep that in mind. Thank you for the advice!
18:43:01 <roboguy_> it wouldn't tell you about the ifs -> guards thing, but it will tell you about some other stuff like redundant dos and parentheses
18:43:07 <roboguy_> keelo: sure!
18:43:21 <larss> Distribution.System looks nice, but I am not sure how (or if) I can use it at compile time to pick a function definition based on OS
18:43:23 <kersplodey> I noticed that the paste site does that as well. Very handy
18:43:49 <roboguy_> kersplodey: yep. I think it uses hlint for that
18:44:15 * hackagebot treeviz 0.0.3 - Visualization of computation decomposition trees.  http://hackage.haskell.org/package/treeviz-0.0.3 (DavidBanas)
18:44:18 * hackagebot stripe 0.3.0.2 - A Haskell implementation of the Stripe API.  http://hackage.haskell.org/package/stripe-0.3.0.2 (MichaelSchade)
18:44:18 <AshyIsMe> kersplodey: you should look into using vim or emacs probably
18:44:38 <AshyIsMe> they both have good support for haskell with automatically pulling in hlint suggestions every time you save etc.
18:44:52 <kersplodey> AshyIsMe: One of my friends keeps telling me to. Should probably do it at some point.
18:45:01 <jle`> kersplodey: what are you using now?
18:45:12 <rasfar> larss: oh right, compile-time. i'm interested to find out if there's a better answer...
18:45:20 <kersplodey> jle`: hehe... notepad++
18:47:34 <AshyIsMe> you're about to go down the rabbit hole with editors :)
18:47:49 * AshyIsMe whispers "pick vim"
18:48:14 <jle`> haha
18:49:14 <mirpa> Emacs is more "functional" than Vim :-)
18:49:28 <mirpa> Anyone using Yi?
18:50:24 <AshyIsMe> i used emacs for about 6 months when i was messing around with cl and scheme and had to switch back to vim because my hands started dying
18:50:47 <AshyIsMe> though evil mode and god mode are supposedly much better these days
18:50:49 <danilo2> Hello! Does -XUndecidableInstances changed the way they are working in GHC 7.7? If I'm enabling -XUndecidableInstances on code, (compilable under ghc 7.6) I'm getting an error "The liberal coverage condition fails in class ..."
18:51:06 <roboguy_> AshyIsMe: did you swap your caps lock and control keys?
18:51:19 <mirpa> I started with Vim but I decided for Emacs because of Dvorak layout which isn't very good with Vim
18:52:12 <mirpa> You can also use Alt instead of Ctrl
18:53:14 <roboguy_> at least for me personally, alt would probably be in a worse place than ctrl and caps lock is way more convenient
18:54:04 <mirpa> unless you have smaller space - then it is pretty easy and palm is much stronger finger than pinky
18:54:06 <AshyIsMe> roboguy_: yeah i did, still didnt help
18:54:42 <AshyIsMe> i bought a kinesis keyboard and that was a lot better but i couldnt afford one for work aswell so i ended up getting rid of it
18:54:55 <mirpa> but it is more about stupid keyboard layout than editors
18:55:12 <AshyIsMe> ah, i use dvorak too
18:55:19 <AshyIsMe> but i learned vim on dvorak so it feels natural
18:55:49 <mirpa> ortogonal keyboards would be much easier to learn/use
18:56:06 <AshyIsMe> i would love to try this out with cherry browns: http://www.humblehacker.com/keyboard/
18:56:25 <AshyIsMe> with a little bit of layout tweaking it could fit vim really well
18:57:22 <AshyIsMe> although i cant see the brackets anywhere on it, so yeah it'd need some layout tweaking
18:57:39 <mirpa> there some examples of good keyboards if you search for ErgoEmacs blog/articles
18:58:02 <enthropy> danilo2: does -XAllowAmbiguousTypes help?
18:58:20 <kersplodey> rasfar: for the transposition, would I want to call lines first, transpose it and then unlines?
18:58:25 <mirpa> ...but once you get back to common qerty keyboards - outch
18:58:46 <danilo2> enthropy: no :(
18:58:54 <rasfar> kersplodey, you'd have to, because of the type of the transpose function
18:59:41 <larss> btw: <rasfar> that shouldn't hurt (you know what platform you're on I guess) <- it does hurt. it means I can't load the file in ghci. someone suggested cabal repl but i cant get to work either
19:00:05 <rasfar> it's really as simple as this (FWIW this kludge)
19:00:06 <enthropy> danilo2: there is kind of a good reason for why those definitions get rejected now. You can re-write them in a way that does work I'm sure
19:00:18 <rasfar> if you have a working showTreeHorizontal
19:00:28 <AshyIsMe> mirpa: yeah i have 3 das keyboards for that very reason
19:00:37 <AshyIsMe> have to have one at work and on the spare machine
19:00:43 <rasfar> showTreeVertical = unlines . transpose . lines . showTreeHorizontal
19:01:18 <enthropy> lets say instead of   class C a b c | a b -> c; instance C a b T, you have   class C' a b t; instance (t~T) => C' a b t
19:01:19 <rasfar> or maybe showTreeVertical = unlines . transpose . lines . showTreeHorizontal . changeSomeSymbols
19:01:27 <AshyIsMe> anyway, chatter for #keyboardscouldbesomuchbetter i guess
19:01:36 <kersplodey> rasfar: thank you. I'll start working on that now
19:01:37 <larss> oh, it is 1.18
19:01:37 <rasfar> sorry, that would be
19:01:51 <rasfar> showTreeVertical = unlines . transpose . lines . changeSomeSymbols . showTreeHorizontal
19:03:13 <rasfar> larss, yeah, sorry that remark was not the most helpful
19:03:16 <danilo2> enthropy: Here is **very** simplified example code: http://lpaste.net/97400 . In the reality I'm simulating OO behaviour - getting function bound to an "object type"
19:04:06 <rasfar> i keep hearing about / coming across cabal repl, but I have no idea what it is -- going to find out!
19:04:12 <Rylee> @src transpose
19:04:12 <lambdabot> transpose []             = []
19:04:12 <lambdabot> transpose ([]   : xss)   = transpose xss
19:04:12 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
19:04:17 * hackagebot free-game 0.9.4.3 - Cross-platform GUI library based on free monads  http://hackage.haskell.org/package/free-game-0.9.4.3 (FumiakiKinoshita)
19:05:14 <Rylee> @pl unlines . transpose . lines . showTreeHorizontal . changeSomeSymbols
19:05:14 <lambdabot> unlines . transpose . lines . showTreeHorizontal . changeSomeSymbols
19:07:26 <danilo2> enthropy: Here is an annotation with "real" code, simulating such behaviour: http://lpaste.net/97400 . Can I get this result in GHC 7.7 and later?
19:13:08 <osa1> where can I learn more about GHC's inliner? does that inline things automatically when compiled with -O?
19:13:35 <dmj`> osa1: maybe here: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/pragmas.html#inline-noinline-pragma
19:14:11 <osa1> thanks for the pointer
19:14:24 <enthropy> danilo2: yeah re-write it without the fundeps
19:15:04 <danilo2> enthropy: but then it will not work as expected, will it?
19:15:07 <enthropy> probably you see how the translation C to C' above works?
19:16:14 <rasfar> larss: in case you decide runtime detection can be workable, I guess System.Info (in base) would be preferable to Distribution.System
19:16:20 <rasfar> Rylee: that's the one that won't type :-p
19:16:32 <enthropy> no, an   instance (y ~ (t1 -> t2 -> (t1,t2))) => Member1 Vector y  -- with Member1 having no fundeps
19:16:49 <enthropy> will match in the same situations as the original
19:17:11 <danilo2> enthropy: I have misslooked ytour code above! Thank you! I'm checking it out! :)
19:18:39 <danilo2> enthropy: There is still the same error
19:19:09 <rasfar> larss: maybe http://blogs.operationaldynamics.com/andrew/software/haskell/config-dot-h-and-ifdef can help if you haven't seen it
19:19:25 <rasfar> but maybe this is just the same problem over again, when from GHCi
19:19:27 <enthropy> danilo2: you got rid of the fundeps on the class?
19:19:51 <danilo2> enthropy: ouch ...
19:20:16 <danilo2> enthropy: thank you ... it works! You saved my day :)
19:20:27 <kersplodey> right well I have to go. It's as done as it'll get.
19:20:32 <kersplodey> Thanks everyone
19:20:38 <kersplodey> rasfar: roboguy_ you two especially
19:20:54 <kersplodey> o/
19:21:05 <enthropy> you will need that -XAllowAmbiguousTypes and possibly need more type signatures then
19:22:00 <danilo2> enthropy: but it works without -XAllowAmbiguousTypes :)
19:22:20 <danilo2> enthropy: Thank you once again! :)
19:22:30 <enthropy> good. But I think you run into problems trying to compose those instances then
19:22:50 <danilo2> enthropy: hmm, could you tell me a little more why?
19:23:12 <enthropy> http://hackage.haskell.org/package/HList-0.3.0.1/docs/Data-HList-FakePrelude.html#t:HComp
19:23:35 <enthropy> I think instances like that one get rejected without that extension
19:24:01 <enthropy> hmm, or maybe it was the Comp right below
19:24:12 <danilo2> enthropy: But I undertand, that enabling this extension would fix this rejection ?
19:24:53 <enthropy> of hand-written type signatures
19:25:15 <danilo2> enthropy: All type signatures I'm generating with TH
19:25:20 <enthropy> it doesn't help with inferring types (that have what are classified as "ambiguous type variables")
19:25:36 <enthropy> well maybe you're lucky and don't run into that problem
19:26:19 <danilo2> enthropy: I hope so. On GHC 7.6 everything works. I hope in 7.7 will work also. I'll test it tommorow :)
19:39:57 <dario`> @pl (\x -> map (ord . subtract x))
19:39:57 <lambdabot> map . (ord .) . subtract
19:40:38 <djahandarie> Has anyone made an actual code golfer?
19:41:06 <djahandarie> Something which takes a Haskell file and does all sorts of ridiculous shortenings on it.
19:41:58 <dario`> sounds like there should be :)
19:42:21 <Iceland_jack> :t (\x -> map (ord . subtract x))
19:42:22 <lambdabot>     No instance for (Num Char) arising from a use of `subtract'
19:42:22 <lambdabot>     Possible fix: add an instance declaration for (Num Char)
19:42:22 <lambdabot>     In the second argument of `(.)', namely `subtract x'
19:42:26 <Iceland_jack> Doesn't type check
19:42:34 <roboguy_> djahandarie: that's an interesting idea
19:42:55 <roboguy_> I was actually just doing some code golf earlier
19:42:59 <johnw> djahandarie: isn't that basically what the optimizer does to Core?
19:43:12 <djahandarie> roboguy_, probably would only take a couple nights with coffee and haskell-src-exts :)
19:43:19 <djahandarie> johnw, no, I don't think so.
19:43:34 <dario`> @pl (\x -> map (subtract x . ord))
19:43:34 <lambdabot> map . (. ord) . subtract
19:43:43 <dario`> that's what i actually meant to write
19:45:19 <roboguy_> johnw: doesn't the optimizer optimize for speed and memory usage rather than code size?
19:45:30 <johnw> that's very true
19:46:20 <roboguy_> what's it like to use haskell-src-exts anyway? I've always wondered
19:56:31 <lispy> I used it once, briefly, circa 2006 (maybe it was just haskell-src back then?). It was fine and easy to use, but my use was also easy.
19:57:14 <julianb> Hi!. I'm trying to implement a black key sieve using ST and Data.Bits. I need to create a C-like array to use it as a bitmask, any ideas on how I might do this?
19:57:23 <roboguy_> I've been curious about transformations on Haskell code, so maybe I'll give it a shot
19:57:26 <lispy> julianb: hi
19:57:43 <lispy> julianb: Data.Vector is probably your best bet
19:57:45 <johnw> roboguy_: give HaRe a look too: http://www.haskell.org/haskellwiki/HaRe
19:58:09 <lispy> julianb: we also have Data.Array. If neither of those work you could malloc a chunk of memory and go nuts.
19:58:15 <roboguy_> johnw: thanks
19:58:40 <lispy> julianb: another approach is to use a wrapper around Integer
19:58:43 <julianb> lispy, actually, how do I malloc?
19:58:46 <lispy> julianb: and I think someone made a library for that
19:58:54 <lispy> ?hoogle malloc
19:58:54 <lambdabot> Foreign.Marshal.Alloc malloc :: Storable a => IO (Ptr a)
19:58:54 <lambdabot> Foreign.Marshal.Array mallocArray :: Storable a => Int -> IO (Ptr a)
19:58:54 <lambdabot> Foreign.Marshal.Array mallocArray0 :: Storable a => Int -> IO (Ptr a)
19:59:19 <julianb> oh. Thats cool. Isn't there any ST malloc?
19:59:32 <johnw> julianb: if you need to malloc, it's a good idea to put it into a ForeignPtr, so it can be free'd when garbage collected
19:59:43 <jfischoff> @hoogle mallocForeignPtr
19:59:44 <lambdabot> Foreign.ForeignPtr mallocForeignPtr :: Storable a => IO (ForeignPtr a)
19:59:44 <lambdabot> Foreign.ForeignPtr mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)
19:59:44 <lambdabot> Foreign.ForeignPtr mallocForeignPtrArray0 :: Storable a => Int -> IO (ForeignPtr a)
19:59:53 <johnw> @hoogle new
19:59:53 <lambdabot> System.Event new :: IO EventManager
19:59:53 <lambdabot> Data.HashTable new :: (key -> key -> Bool) -> (key -> Int32) -> IO (HashTable key val)
19:59:53 <lambdabot> Foreign.Marshal.Utils new :: Storable a => a -> IO (Ptr a)
20:00:00 <johnw> that 3rd one
20:00:08 <lispy> ForeignPtrs are all the rage. So exotic!
20:00:10 <johnw> or mallocForeignPtrArray0
20:00:12 <johnw> or mallocForeignPtr
20:00:21 <jfischoff> I bet Vector will do the trick like lispy said
20:00:34 <julianb> but that's actually IO monad, I'm trying to avoid IO. I'll check vector
20:00:48 <lispy> and if it's really a arbitrarily large bitmask, there is a library that could do it even better with Integer...
20:01:17 <lispy> and this: http://hackage.haskell.org/package/bit-vector
20:01:35 <lispy> ah, this is the first one I was tihnking of: http://hackage.haskell.org/package/bv
20:01:42 <lispy> using Integer is pretty smart.
20:01:59 <jfischoff> that's crazy :)
20:02:59 <lispy> julianb: So, yeah, I would give bv a shot first. It looks pretty complete and the author is pretty solid.
20:05:48 <lispy> and all the bv stuff is pure...
20:05:54 <lispy> not even ST
20:06:10 <lispy> It's pretty much perfect for this
20:06:21 * lispy puts the soap box away
20:06:22 <julianb> lispy, thanks!
20:06:50 <lispy> yw!
20:07:15 * jfischoff thanks lispy for showing him bv
20:19:47 <jle`> is it wrong to say that `type` is only a lexical alias?
20:20:39 <jle`> something equivalent to a limited #define
20:22:36 <razieliyo> incredible
20:22:49 <razieliyo> haskell is making me write shorter code in C++, I've just noticed
20:23:03 <razieliyo> simulating data constructions
20:32:13 <joelteon> Can I use an existing datatype for an associated datatype?
20:33:42 <enthropy> no
20:33:59 <joelteon> oh
20:34:11 <enthropy> unless you're ok with a newtype wrapper around the old one
20:34:38 <ij> What does the '|' mean in "class Monad m => MonadState s m | m -> s where"?
20:35:20 <carter> bitemyapp: respectfully, twitter is a pretty incomprehensible reading format, my reading comprehension is quite good, so don't say stuff like that
20:36:09 <geekosaur> ij: it's a functional dependency
20:36:33 <geekosaur> "if you know the type of m, you also know the type of s"
20:37:35 <sellout-> ij: IE, for a given m, there can be only one s.
20:38:00 <ChongLi> hmmm
20:39:40 <joelteon> ok, newtype it is, I guess
20:45:34 <ij> sellout-, geekosaur, Where is this functionality covered? It's not here http://www.haskell.org/tutorial/classes.html nor in LYAH.
20:45:59 <ij> Also, I couldn't find what two variables like "MonadState s m" mean too.
20:46:00 <carter> lispy: happy holidays!
20:46:34 <carter> jfischoff: yo!
20:46:54 <sellout-> ij: http://www.haskell.org/haskellwiki/Functional_dependencies
20:47:25 <sellout-> ij: Note that it’s not part of the standard.
20:47:40 <jfischoff> carter: yo yo!
20:50:24 <bitemyapp> carter: fair, but what you were saying made no bloody sense.
20:50:54 <carter> bitemyapp: whatever, been a busy week, so i misread what you said when exahusted, doesn't matter
20:53:31 <roboguy_> ij: when there are two parameters like that, that is a multi-parameter type class which is also not part of the standard. it uses the MultiParamTypeClasses extension
20:59:37 <bitemyapp> carter: S'okay. It's holiday vacay for most people now, so hopefully you can get some rest!
20:59:57 <carter> thankee
21:00:27 <bitemyapp> carter: what is with the misconceptions around how Haskell users work? There seems to be this impression among some that we're still bashing rocks together.
21:01:01 <carter> could you restate that sentence with different words?  i dont' remember what your'e referrring to
21:01:37 <bitemyapp> carter: I got into a snit with Sean McDirmid of MSR and he appears to know nothing about Haskell but seems to assume we're editing Haskell code with `ed` and doing everything in a terminal.
21:01:46 <carter> wat
21:01:51 <carter> thats sillly
21:01:52 <bitemyapp> carter: anyway, hope you're feeling better soon!
21:01:55 <carter> thankee
21:01:55 <bitemyapp> yeah, of course it is.
21:02:15 <carter> is he the dude who writes the really crazy cthuluian CS OPEds?
21:02:22 <bitemyapp> Hum. Good question.
21:02:42 <bitemyapp> I mentioned Yi and EclipseFP in the context of Haskell community doing a good job of "tool sharing" and he didn't believe me, haha.
21:02:51 <bitemyapp> of the*
21:03:12 <carter> well, honestly i don't believe in IDEs :)
21:03:28 <bitemyapp> I don't use IDEs as they typically manifest
21:03:46 <bitemyapp> but I'm capable of recognizing how similar'ish workflows can be useful via automation in my preferred environ (Emacs)
21:04:04 <bitemyapp> automated refactoring tools, for example, can be friggin' magical for large codebases.
21:04:12 <bitemyapp> I just don't need a dropdown menu for said tool.
21:05:07 <carter> true
21:05:18 <ij> geekosaur, sellout-, so I can either supply an instance for "Int Monad" or just "Schmonad" from which, it will figure out the s or e.g. "Int"?
21:05:20 <carter> actually ghc 7.8 will make it even nicer
21:05:33 <bitemyapp> I would also prefer such tools be reusable as libraries, services, or command-line applications across all editors and IDEs
21:05:44 <bitemyapp> so that people don't have to reimplement analysis/refactoring/etc tools over and over.
21:05:52 <simpson> edwardk: Out of curiosity, is there a way to get a parse trace out of trifecta (or any other parsers-compatible library)? I'm having trouble with some gnarly syntax, and it would help immensely to see the decisions that the parser is making.
21:06:05 <bitemyapp> and that was really the original point I was making in the thread, that Haskell was doing a much better job of this than most languages.
21:06:21 <carter> oh yeah agreeed
21:06:24 <carter> somehow i missed that :)
21:06:34 <carter> theres this whole ghc hooks api  thing landing in 7.8 that should make it super awsome
21:07:19 <bitemyapp> carter: is that what Fay is waiting for to get typeclasses?
21:07:30 <carter> ghcjs ftw :)
21:07:31 <bitemyapp> Fay's lack of typeclasses is making my spleen rupture.
21:07:43 <bitemyapp> carter: Need clean compiler output in the work I do.
21:07:49 <carter> ahh
21:07:50 <bitemyapp> ghcjs spews garbage comparatively.
21:07:51 <carter> hrmm
21:08:01 <bitemyapp> but it want my damn typeclasses :(
21:08:01 <carter> could you use more neutral metaphors?
21:08:06 <bitemyapp> also I like Fay's FFI better.
21:08:20 <bitemyapp> I can do that, sure.
21:08:38 <bitemyapp> That's the most tasteful and pleasant request of that nature I've ever received on IRC.
21:09:01 <ij> "... forms a monad" = "a data type that's a Monad instance"?
21:09:18 <carter> bitemyapp: yay
21:09:41 <carter> bitemyapp: you may find the timber of your irc chats may become more fun!
21:10:36 <bitemyapp> noprompt: oh cap'n my cap'n
21:11:13 <carter> >
21:11:15 <carter> ?
21:11:43 <noprompt> bitemyapp: msged you. i fell asleep for a little bit. :)
21:12:00 <noprompt> bitemyapp: started working on insert before that.
21:12:24 <bitemyapp> noprompt: cool!
21:12:44 <noprompt> bitemyapp: give me a second here to get my brain back online.
21:12:53 <echo-area> bitemyapp: Hey you're here too, nice to meet you
21:12:57 <echo-area> :)
21:13:01 <bitemyapp> echo-area: hi!
21:18:46 <jfischoff> what is the equivalent of mapMaybe for MaybeT?
21:19:58 <johnw> :t mapMaybeT
21:19:59 <lambdabot> (m (Maybe a) -> n (Maybe b)) -> MaybeT m a -> MaybeT n b
21:20:41 * jfischoff nods 
21:20:55 <johnw> :t mapMaybe
21:20:56 <lambdabot> (a -> Maybe b) -> [a] -> [b]
21:21:01 <johnw> ok, not the same thing
21:21:29 <johnw> you want (a -> MaybeT m b) -> m [a] -> m [b]?
21:21:40 <johnw> or do you want the input to be [a]?
21:23:08 <jfischoff> I was just wondering if there was some interesting generalization at work
21:23:15 <jfischoff> but there doesn't appear to be
21:23:58 <jfischoff> @hoogle mapMaybeM
21:23:59 <lambdabot> No results found
21:24:03 <jfischoff> ha
21:24:13 <jfischoff> http://www.haskell.org/platform/doc/2013.2.0.0/ghc-api/MonadUtils.html
21:26:45 <johnw> :t \f xs -> foldM (\acc x -> do { x' <- runMaybeT (f x); maybe (return acc) (fmap (:acc)) x' }) [] xs
21:26:46 <lambdabot> (Monad m, Functor m) => (b -> MaybeT m (m a)) -> [b] -> m [a]
21:26:52 <johnw> :t \f xs -> foldM (\acc x -> do { x' <- runMaybeT (f x); maybe (return acc) (liftM (:acc)) x' }) [] xs
21:26:53 <lambdabot> Monad m => (b -> MaybeT m (m a1)) -> [b] -> m [a1]
21:27:03 <johnw> almost, not quite
21:27:39 <johnw> :t \f xs -> foldM (\acc x -> do { x' <- runMaybeT (f x); return $ maybe acc (:acc) x' }) [] xs
21:27:40 <lambdabot> Monad m => (b -> MaybeT m a) -> [b] -> m [a]
21:29:14 <johnw> :t \f -> foldM (\acc x -> runMaybeT (f x) >>= maybe (return acc) (liftM (:acc))) []
21:29:15 <lambdabot> Monad m => (b -> MaybeT m (m a1)) -> [b] -> m [a1]
21:29:26 <johnw> :t \f -> foldM (\acc x -> runMaybeT (f x) >>= return . maybe acc (:acc)) []
21:29:27 <lambdabot> Monad m => (b -> MaybeT m a) -> [b] -> m [a]
21:29:30 <johnw> ok, enough
21:34:53 <jle`> is there such thing as a trivial monad instance?
21:35:07 <jle`> i guess for monoids it >>= can always return mzero
21:35:13 <jle`> would that satisfy the monad laws?
21:35:37 <johnw> i'm pretty sure Identity's instance would qualify as trivial
21:35:42 <jle`> sorry
21:35:44 <jle`> mempty
21:35:50 <johnw> ah
21:36:07 <jle`> i mean, a trivial monad instnace for an arbitrary data type
21:36:24 <jle`> is there such thing as a trivial instance for any data type in general?
21:36:34 <eitan> no...what should return give?
21:37:18 <eitan> or maybe return and bind both just give bottoms...that's pretty trivial :-)
21:37:39 <jle`> haha
21:38:17 <jle`> would (>>=) _ _ = mempty follow the monad laws for monoids?
21:38:30 <jle`> and return _ = mempty
21:38:40 <johnw> mempty has the wrong kind
21:38:46 <johnw> (its type does, I mean)
21:39:13 <johnw> (>>=) returns an "m b", mempty would have type "b"
21:39:30 <trolling> mzero works though
21:39:34 <jle`> :t mempty
21:39:35 <lambdabot> Monoid a => a
21:39:39 <eitan> monads are in the first place type constructors with kind *->*
21:39:40 <trolling> you can have data Unit a = Unit
21:39:42 <shachaf> Probably y'all're looking for Proxy.
21:39:48 <shachaf> The thing trolling just said.
21:39:51 <jle`> what do ya know
21:40:04 <jle`> hm.
21:40:14 <jle`> is there any way to define a general monad instance for monoids then?
21:40:46 <djahandarie> trolling, I would hope you can always construct a Monad if you have a MonadPlus.
21:41:15 <eitan> a Monoid has kind *, a Monad has kind *->*, so no?
21:41:29 <trolling> jle`: well, there's the writer monad...
21:41:36 <jle`> eitan: ah that makes sense
21:41:47 <jle`> my type logic isn't too sharp
21:41:51 <johnw> you could lift the Monoid a to Free ((,) a) ()
21:42:18 <trolling> nothing about Free ((,) a) () uses the monoid constraint though
21:42:40 <johnw> hmm, good point
21:43:11 <eitan> yeah, the Writer Monad is the best example of a Monad derived from a Monoid
21:44:22 <trolling> if you'll forgive lay category theory for a moment, a monad is a monoid in the category of endofunctors on hask, no? So being able to turn monoids into monads would necessarily involve a functor from hask to endofunctors on hask which sounds like a bit of an ask
21:45:08 <Hafydd> A bit of an 'ask.
21:45:45 <eitan> Yup...Writer is a functor from the category of Monoid objects in Hask to the category of monoid objects in End(Hask)
21:46:06 <trolling> hooray for mathematics
21:46:37 <shachaf> Writer (also known as (,)) is pretty good.
21:46:50 <shachaf> For example the Monad laws on (m,) correspond directly to the monoid laws on m.
21:46:52 <johnw> i just tried to write something simpler than Writer to exhibit this property... and ended up writing Writer
21:47:07 <shachaf> You can break them in one place and see them breaking in the other.
21:47:58 <shachaf> And if you use Codensity (m,) it ends up behaving just like "DList" ("DMonoid", you know what I mean).
21:48:26 <djahandarie> Really?
21:48:51 <jle`> this is interesting
21:48:57 <shachaf> It'll right-reässociate your mappends.
21:49:17 <trolling> neat
21:49:36 <shachaf> (tell a >> tell b) >> tell c becomes (a <> (b <> c)) and so on.
21:49:46 <eitan> cool
22:00:01 <AfC> If I have to serialize a largish list of Maps, am I better off using Vector or is the Prelude (Data.List) list going to be same same?
22:00:44 <johnw> I would think either would serialize in O(n)
22:02:36 <AfC> johnw: fair enough
22:02:49 <quchen> Binary serializes Map by calling toList on it anyway
22:02:54 <AfC> johnw: I guess I'll have to see what form I need them in when I read them back.
22:04:39 <AfC> quchen: I'm going to guess cereal uses one of http://hackage.haskell.org/package/cereal-0.4.0.1/docs/Data-Serialize-Put.html#g:7 , perhaps putListOf. There is a "cereal-vector" package out there...
22:05:24 <eitan> which is preferred, binary or cereal?
22:06:00 <startling> eitan: it depends.
22:06:23 <eitan> which is preferred in which sort of scenario then?
22:06:46 <startling> cereal is nicer in some ways but uses strict bytestrings.
22:06:48 <FliPPeh> What's the point of this idiom: case () of _ | cond -> ... ?
22:06:59 <dmwit> FliPPeh: It's like a multi-way if.
22:07:06 <dmwit> Kind of nice if you have lots of conditions to check.
22:07:30 <dmwit> Of course, now we have MultiWayIf if you don't mind being tied to GHC.
22:07:36 <startling> eitan: you might look at http://hackage.haskell.org/package/bytes
22:07:37 <FliPPeh> Hmm
22:08:17 <eitan> startling: thanks. why do you say cereal is nicer in some ways?
22:09:38 <roboguy_> dmwit: huh, I never heard of MultiWayIf
22:09:57 <ashwins1> hi everyone. I've got a quick question about Functor. For purely didactic purposes, I was trying to make an instance Functor (Map Int) but it said I needed FlexibleInstances. Any idea why?
22:10:33 <quchen> ashwins1: All type variables must be *variable*. In your case, you have an explicit Int in Map's argument.
22:10:33 <ashwins1> (also if I don't parenthesize (Map Int), it complains that Functor is being applied to too many type arguments)
22:10:39 <eitan> elm has multiway if
22:10:40 <ashwins1> ohhh, got it, thanks!
22:11:14 <quchen> ashwins1: If you write "Functor Map Int" that's more like "(Functor Map) Int".
22:11:50 <mirpa> eitan: cereal has Either for error, binary has exceptions
22:12:29 <eitan> mirpa: I see. Thanks
22:28:42 <startling> what's the difference between "forall a. [a]" and "[forall a. a]"?
22:29:37 <shachaf> Well, they both have only one inhabitant, []
22:29:50 <shachaf> I think kmc wrote a post about those two, actually.
22:30:01 <shachaf> @google mainisusuallyafunction forall a
22:30:03 <lambdabot> http://mainisusuallyafunction.blogspot.com/2010/10/quantification-in-haskell.html
22:30:03 <lambdabot> Title: main is usually a function: Quantification in Haskell
22:31:27 <johnw> would one by "the type of every list" and the other "a list of every type"?
22:31:40 <startling> ok. I had a "[forall m. MonadError String m => m a]" and I was getting type errors until I switched to "forall m. MonadError String m => [m a]".
22:31:53 <shachaf> No, they are both types. Neither is a list.
22:31:59 <startling> :<
22:32:19 <shachaf> startling: Yes, it's impredicative, you can't actually talk about a type like [forall a. ...] in Haskell.
22:32:39 <shachaf> You can wrap it in a newtype if you want, as in newtype Foo = Foo (forall a. ...) and then use [Foo]
22:32:45 <johnw> well, I mean "the type of every list type" and "the type of a list of every type"
22:32:53 <shachaf> But you should understand what the types mean, because they're pretty different.
22:33:03 <startling> shachaf: that's why I'm asking.
22:33:20 <shachaf> Right. Well, the post above was pretty clear if I remember correctly.
22:33:27 <startling> ok! I'll look at it.
22:33:44 <startling> johnw, well, consider the MonadError thing.
22:34:00 <shachaf> Also you can read the first few pages of an Agda introduction. Then you'll understand everything better.
22:34:10 <shachaf> (But you have to understand, not just read.)
22:34:25 <shachaf> startling: I suggest forgetting about type classes for a while, because they're vaguely magic and make things harder.
22:34:50 <startling> shachaf, I don't know. it seems import that a forall + a typeclass says "this is defined only in terms of the typeclass members".
22:34:55 <startling> *it seems important.
22:35:02 <shachaf> Right, but you can always use plain old types instead.
22:35:08 <startling> oh, fair enough.
22:35:31 <shachaf> E.g. instead of "forall a. Read a => a", you can say "forall a. (String -> a) -> a"
22:35:34 <startling> [forall a. [a]] <- this is a list of [] (ignoring bottom), right?
22:35:47 <shachaf> (That's not exactly what Read is but you can pretend.)
22:36:03 <shachaf> The only inhabitants of that (impredicative) type would be lists of empty lists, yes.
22:36:25 <startling> then what are the inhabitants of forall a. [[a]]?
22:36:37 <startling> oh, I think I see.
22:36:54 <johnw> startling: in order to have an inhabitant of [forall a. a], you'd need a value which was at once every type, iiuc
22:37:02 <startling> johnw, [].
22:37:11 <startling> > [] :: [forall a. a]
22:37:13 <lambdabot>  Illegal polymorphic or qualified type: forall a. a
22:37:13 <lambdabot>  Perhaps you intended to use -XImpredicativeTypes
22:37:21 <johnw> well, [] is just saying you can't ever fill it because nothing will
22:37:29 <eitan> maybe it'd be easier to think about some examples which aren't empty (except for bottom)
22:37:45 <shachaf> GHC doesn't really support impredicative types.
22:37:52 <eitan> forall a. a->a
22:37:52 <startling> johnw, um, ok. that's why i started talking about typeclasses and types.
22:37:57 <shachaf> Anyway, I'll be glad to explain this further but you should read the post I linked to above first.
22:37:57 <eitan> has id
22:38:05 <startling> I'm reading!
22:38:07 <shachaf> Because I don't want to duplicate effort.
22:38:24 <startling> fair enough.
22:38:35 <eitan> forall a. f a -> g a
22:38:49 <eitan> if f and g are functors then this is all natural transformations
22:38:59 <shachaf> The trouble with IRC is that even if you link someone to a post, people will keep talking because they think their explanation is better, so they never get a chance to read the post.
22:38:59 <johnw> startling: ok, take [forall m. Monad m => m a]; there is no value which is at once an inhabitant of every monad type.  As shachaf said, type classes do not change the fundamental issue
22:39:10 <shachaf> Sigh.
22:39:24 <startling> johnw, return someA
22:40:06 <johnw> what is someA?
22:40:22 <startling> johnw, some value of type a (which you'll note is not forall'd)
22:40:46 <eitan> forall a. Maybe a
22:40:47 <johnw> which type are you proposing that's an inhabitant of?  we've mentioned a few
22:40:49 <eitan> has Nothing
22:41:04 <startling> eitan: right, that's why I started talking about lists-of-lists.
22:41:38 <johnw> startling: I'll side with shachaf at this point and recommend some reading off channel
22:41:52 <startling> johnw, ok, [forall a. Monoid a => a] is a better example so we don't get confused about free and bound variables.
22:42:00 <startling> johnw, will that help you understand what I'm saying?
22:42:19 <johnw> sure
22:48:38 <johnw> startling: I think you're thinking that's a list of anything which is a Monoid, where each member of the list has _a_ type which is an instance of Monoid; instead it's a list of values, each of which is an inhabitant of *every* Monoid type.  Such values cannot exist, because every value must have a specific type
22:55:02 <shachaf> johnw: startling is not here. And that's not right (I'm not sure if it's even wrong).
22:55:12 <johnw> haha, what's that mean?
22:55:13 <shachaf> Exercise to the reader: Why not?
22:55:18 <johnw> hmm
22:55:50 <shachaf> OK, let's go with just wrong.
22:56:04 <eitan> because [] is an element?
22:56:30 <johnw> I was talking about the values inside the list not existing (a list of ...)
22:56:34 <johnw> maybe my wording was off
22:56:41 <johnw> shachaf: care you explain just a bit more?
22:57:02 <shachaf> :t mempty
22:57:03 <lambdabot> Monoid a => a
22:57:32 <johnw> it would be a list of polymorphic mempty's
22:57:42 <johnw> s/could
22:57:42 <eitan> ah
22:57:56 <eitan> i was wondering about that...since the mempties are different for different Monoids
22:58:02 <shachaf> I'm not entirely sure what "every value must have a specific type" means.
22:58:05 <eitan> whether they count...but polymorphicity...gotcha
22:58:07 <shachaf> What's the type of []?
22:58:12 <johnw> shachaf: let's go with wrong then
22:58:45 <johnw> [] is forall a. [a]?
22:58:56 <shachaf> The type of [] is forall a. [a], yes.
22:59:07 <shachaf> Is that a specific type? Actually I don't know what specific type means.
22:59:08 <eitan> :t []
22:59:09 <lambdabot> [a]
22:59:28 <johnw> let me just retract what I said then; I need to go read those resources you cited again myself
22:59:43 <Sibi_> Any recommendations for introductory book on category theory ?
22:59:55 <johnw> Sibi_: I like Lawvere's "Intro to Conceptual Mathematics"
23:00:11 <johnw> but if you already know lots of math, it may be too light
23:00:36 <Sibi_> johnw: No, I'm weak in maths.
23:00:39 <eitan> watch the catsters videos on youtube
23:00:56 <shachaf> What is the goal of learning category theory?
23:02:08 <Sibi_> shachaf: Have no intention, But i think it will help me understand the type system better.
23:02:30 <Sibi_> eitan: thanks.
23:02:51 <shachaf> OK.
23:11:40 <randomclown> A someone who have seen catster's videos, they are good, but digesting them is ahrd
23:11:44 <randomclown> hard*
23:11:53 <johnw> agreed
23:11:59 <johnw> i couldn't follow them at all at first
23:12:18 <jle`> how come my lpastes never get posted here :/
23:12:27 <eitan> i'm a bad example because i'm a mathematician :-)
23:12:37 <johnw> eitan: professionally?
23:12:45 <eitan> well, not really any more
23:12:53 <eitan> but got my phd a year ago
23:12:55 <Aetherspawn> Can someone help me refractor this (to hopefully a 1-liner?) https://gist.github.com/kvanberendonck/8092783
23:12:58 <johnw> someday I hope to meet a professional mathematician
23:13:07 <Aetherspawn> the part on line 6 is giving me headaches
23:13:13 <eitan> lol, ever been to a university?
23:13:27 <Aetherspawn> I know that I would usually do Data <$> whatever <*> foo <*> bar, but certain parts are pure and others are not and I'm getting a little confused.
23:14:09 <johnw> well, and you need to use 'a' twice
23:14:30 <johnw> not sure what the last "do" means
23:14:40 <Aetherspawn> thats just something I haven't written yet, sorry
23:14:47 <johnw> or why you assign z and don't use it
23:14:58 <Aetherspawn> z is nothing, just so the let makes sense.
23:15:08 <johnw> it's hard to refactor unfinished code
23:15:16 <johnw> my first refactoring would be: remove the let :)
23:15:19 <Aetherspawn> well, to finish this code I have to copy lines 6-9 about 20 times.
23:15:30 <Aetherspawn> I want to put a generic version of a binary operator inside the let
23:15:32 <johnw> sure, do that
23:15:35 <Aetherspawn> and then use 1 line per thing in the choice
23:15:37 <Aetherspawn> :|
23:16:05 <dmj`> Aetherspawn: you have an unsused at line 11
23:16:07 <dmj`> do
23:16:46 <Aetherspawn> Mhm, sorry for bothering you folks.
23:17:01 <jle`> no bother :)
23:17:02 <eitan> convert it out of do notation first
23:17:42 <Aetherspawn> thats really really hard
23:17:42 <eitan> then see if you can break it down a step at a time
23:17:52 <eitan> no it's easy to undo ;-)
23:18:06 <jle`> hm. is it really?
23:18:10 <jle`> he uses `a` twice
23:18:27 <eitan> yeah, that prolly means no one-liner
23:18:29 <eitan> true
23:18:30 <Aetherspawn> actually, the second a is the same as the first I reckon.
23:18:39 <Aetherspawn> annot is a source position annotation
23:18:46 <Aetherspawn> line number/column
23:20:01 <dmj`> Aetherspawn: I posted on your gist
23:21:06 <Aetherspawn> cheers, that's one way to do it I guess.
23:23:23 <dmj`> johnw: what's up
23:25:27 <johnw> hey dmj`!
23:28:29 <dmj`> johnw: wonder when that pipes meetup is gonna happen :)
23:29:04 <johnw> me too!  ask stepcut
23:29:28 <dmj`> yea, I need to pick his brain more on acid-state too
23:32:40 <johnw> I'd love to have another hackathon in Jan or Feb
23:32:51 <johnw> we can discuss on GGroups
23:33:25 <Aetherspawn> updated gist to express what I was going for a little more. https://gist.github.com/kvanberendonck/8092783
23:34:55 <dmj`> yes, sounds good. We grow in number each time
23:35:52 <WraithM> johnw, dmj` :)
23:36:41 <johnw> WraithM!!!
23:38:17 <WraithM> I need to sleep, but I'm liking what I'm seeing!
23:38:19 <WraithM> lol
23:39:21 <Aetherspawn> .....
23:40:12 <dmj`> WraithM: want to hear of your progress on that happstack project soon
23:40:21 <Aetherspawn> woops, sorry
23:40:25 <Aetherspawn> leaning on the keyboard.
23:40:30 <WraithM> dmj`: lol, I switched to Snap :D
23:40:53 <eitan> where's your hackathon?
23:40:57 <WraithM> dmj`: But yes, we'll catch up
23:41:06 <dmj`> WraithM: oh did you, much to discuss
23:41:16 <WraithM> eitan: We're talking about Chicago
23:41:23 <eitan> ah
23:41:35 <eitan> not close :-)
23:42:27 <dmj`> eitan: how far? we'll fly you in, we have a huge budget ;)
23:42:48 <eitan> haha, San Fran area
23:43:12 <shachaf> I hear that's the place to be.
23:43:28 <eitan> it's nice
23:44:00 <dmj`> eitan: You don't like -2 degree weather?
23:44:30 <jle`> dmj`: and you're comparison is chicago? :P
23:44:34 <jle`> *youre
23:44:36 <eitan> lol
23:44:36 <jle`> your
23:44:38 <jle`> dangit
23:44:56 <jle`> my mind switched from 'you are comparing' to 'your comparison' halfway through typing
23:45:08 <dmj`> jle`: if you wanna talk rent prices I'll go there ;)
23:45:35 <dmj`> ok maybe I'm jealous, there I said it
23:47:08 <jle`> wrote a short program to demonstrate the list monad. anyone care to review for idiomaticness to make sure i'm not teaching any bad habits? http://lpaste.net/97408
23:47:42 <jle`> some things are trivially filters but i wanted to push list monadness where i coudl
23:48:11 <jle`> it's um...that wolf goat cabbage puzzle. http://en.wikipedia.org/wiki/Fox,_goose_and_bag_of_beans_puzzle
23:49:14 <johnw> jle`: mfilter isSolution makeNMoves
23:49:41 <johnw> or just filter even
23:49:48 <johnw> unless the intent is to demonstrate guard
23:50:44 <jle`> there is some intent in demonstrating guard
23:50:55 <jle`> but i do the guard p x >> return x a lot
23:50:55 <johnw> you also have it elsewhere
23:50:59 <johnw> so maybe the contrast is helpful?
23:51:08 <jle`> yeah, probably useful
23:51:14 <jle`> it's a common enough idiom
23:51:49 <zRecursive> Is guard same as "assert" in C ?
23:51:59 <johnw> no
23:52:05 <johnw> assert is similar though :)
23:52:31 <zRecursive> then guard code can be removed by compiler ?
23:52:35 <johnw> assert in C raises SIGABRT by calling abort(); assert in Haskell raises an exception; the behavior of guard depends on the MonadPlus instance
23:52:44 <eitan> guard is like the guards in list comprehensions
23:52:59 <prophile> like in that in a sense it is the guard in list comprehensions
23:53:30 <johnw> for the list MonadPlus, failing a guard yields []
23:53:43 <jle`> the way i am writing it is that you can think of the list monad as outputting the end result of all succesful forks; a failed guard indicates that that particular fork will not show up in teh list of successes
23:54:11 <zRecursive> i see now
23:54:12 <jle`> > do { x <- [1..10]; guard (even x); return x }
23:54:14 <lambdabot>  [2,4,6,8,10]
23:54:31 <jle`> > do { x <- [1..10]; return x }
23:54:32 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
23:54:50 <zRecursive> @src guard
23:54:51 <lambdabot> guard True  =  return ()
23:54:51 <lambdabot> guard False =  mzero
23:55:26 <jle`> relies on the MonadPlus law that mzero >> a = mzero
23:55:43 <zRecursive> @undo do { x <- [1..10]; guard (even x); return x }
23:55:43 <lambdabot> [1 .. 10] >>= \ x -> guard (even x) >> return x
23:55:43 <zRecursive>  
23:56:32 <johnw> > [1 .. 10] >>= guard . even >=> return
23:56:34 <lambdabot>  Precedence parsing error
23:56:34 <lambdabot>      cannot mix `GHC.Base.>>=' [infixl 1] and `Control.Monad.>=>' [infixr 1] ...
23:56:37 <johnw> > [1 .. 10] >>= (guard . even >=> return)
23:56:38 <lambdabot>  [(),(),(),(),()]
23:56:49 <johnw> ah
23:57:51 <zRecursive> i still cannot see the source of guard ?!
23:58:18 <johnw> it was pasted above
23:58:20 <johnw> @src guard
23:58:20 <lambdabot> guard True  =  return ()
23:58:20 <lambdabot> guard False =  mzero
23:58:58 <jle`> well
23:59:06 <zRecursive> why does `guard True >> return x` different from `guard False >> return x` ?
23:59:06 <jle`> > [1..10] >>= guard even
23:59:08 <lambdabot>  Couldn't match type `()' with `[b0]'
23:59:08 <lambdabot>  Expected type: a0 -> [b0]
23:59:08 <lambdabot>    Actual type: a0 -> ()Couldn't match expected type `GHC.Types.Bool'
23:59:08 <lambdabot>              with actual type `a1 -> GHC.Types.Bool'
23:59:32 <jle`> > [1..10] >>= guard . even
23:59:33 <lambdabot>  [(),(),(),(),()]
23:59:46 <johnw> because guard True returns ())
