00:00:00 <erisco> particularly I am trying to extract the "have seen this vertex already" part of graph functions
00:00:07 <erisco> some adaption is still needed
00:00:40 <erisco> but this is closer given that 'fib' can be implemented now :)
00:01:33 * ski wonders whether one could knit any knots profitably here
00:02:02 <erisco> yes you can use the memo table to tie the knot
00:15:32 * hackagebot RSA 2.0 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  http://hackage.haskell.org/package/RSA-2.0 (AdamWick)
00:15:32 * hackagebot github 0.7.3 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.7.3 (JohnWiegley)
00:21:11 <johnw> huh, I uploaded that several hours ago
00:21:46 <blaenk> does that let you post gists?
00:24:05 <johnw> i don't think so
00:24:30 <blaenk> o
00:43:34 <FliPPeh> Can I somehow get the current writer value from my writer monad before it exits through runWriter?
00:43:41 <FliPPeh> Or is that already state monad territory
00:55:42 <johnw> :t listens
00:55:43 <lambdabot> MonadWriter w m => (w -> b) -> m a -> m (a, b)
00:58:41 <maybefbi> how to plot inside a conduit?
01:03:34 <zebr> hi all. a package with the constraints 'GLUT (>=2.2 && <2.5)' led to it installing GLUT 2.2.2.1, despite 2.4 being available. installing 2.4 fixes the problem (2.2.2.1 wasn't compiling). isn't this a bug of sorts?
01:05:18 <maybefbi> may be cabal-install goes for the lowest version that satisfies the constraints
01:05:44 <maybefbi> perhaps there is some occam's razor style math theorem that says lowest version that works is the best
01:06:36 <maybefbi> zebr: assuming of course, that all versions compile
01:07:02 <maybefbi> zebr: which in your case doesnt
01:07:09 <maybefbi> zebr: but that is only incidental
01:07:27 <johnw> maybefbi: you can liftIO within a conduit, is that what you mean?
01:07:41 <zebr> maybefbi: i have serious doubts about such a theorem :p regardless, there was also a GLUT 2.2.0 available.
01:08:47 <maybefbi> johnw: yes but the conduit executes often, and i don't want to lose the previous image of the plot
01:09:05 <maybefbi> johnw: it has to be like an animation
01:09:43 <maybefbi> zebr: :D hmm if 2.2.0 is available, then it is possible that you are using sandboxes
01:10:07 <johnw> maybefbi: then just "lift" and run your conduit in something that has State
01:10:27 <maybefbi> johnw: ok
01:10:35 <johnw> you can always access the "surrounding" monad within which you are running your conduit
01:11:03 <maybefbi> johnw: yes I use IO
01:11:43 <maybefbi> zebr: if you are inside a sandbox, the compilation of a package might use a GLUT from outside the sandbox if it finds it there
01:12:15 <maybefbi> zebr: issue a cabal sandbox hc-pkg list, and see what repositories are being used, and what versions of GLUT already exist
01:30:48 <issamou> hi, what's the benefit of Expr fold: http://faculty.cse.tamu.edu/hlee/csce314/expr.hs
01:31:10 <issamou> it returns the same answer as without fold
01:32:17 <johnw> i don't quite follow; those two functions are essentially the same thing
01:36:40 <issam> johnw, fold doesnt serve a purpose in that code right?
01:37:25 <johnw> no, it's just another name for "eval" there
01:37:44 <issam> i see
01:45:33 * hackagebot repa-sndfile 3.2.3.3 - Reading and writing sound files with repa arrays  http://hackage.haskell.org/package/repa-sndfile-3.2.3.3 (AtsuroHoshino)
01:45:35 * hackagebot repa-fftw 3.2.3.2 - Perform fft with repa via FFTW  http://hackage.haskell.org/package/repa-fftw-3.2.3.2 (AtsuroHoshino)
01:57:53 <lightquake> what's the point of this idiom: f x = go x where go x = {- some stuff involving reursive calls to go -}
01:58:19 <johnw> well, in that case usually it's just "go" and not "go x"
01:58:25 <johnw> which also means you get sharing of x
01:58:51 <johnw> but typically I only do that if go needs a starting value
01:59:13 <johnw> as in, f x = go n where go n = {- stuff using n and x and recursing into go -}
01:59:32 <lightquake> right
02:00:25 <skypers> http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html
02:00:31 <skypers> Haskell at the 50th place
02:00:32 <skypers> ahah
02:01:18 <skypers> 10:51 < johnw> as in, f x = go n where go n = {- stuff using n and x and recursing into go -}
02:01:25 <skypers> sounds like wrapper&worker :)
02:03:22 <Taneb> How big does a set have to be for Set to be more time-efficient than []?
02:03:33 <Taneb> Actually, never mind
02:03:55 <Taneb> My program uses a very small set and depends heavily on []
02:13:24 <dibblego> data Free2 a b = Done a b | More (f (Free2 a b)) -- does this exist anywhere?
02:13:36 <dibblego> data Free2 f a b = Done a b | More (f (Free2 a b)) -- does this exist anywhere?
02:18:06 <ClaudiusMaximus> dibblego: type Free2 f a b = Free f (a, b) -- or am i missing something
02:18:30 <dibblego> I am silly, thanks
02:19:09 <dibblego> I guess it's that it is a monad on each side, like bifunctor all over again
02:34:25 <anonymous_> hello hackers
02:34:47 <anonymous_> i mean haskers
02:37:38 <anonymous_> ChanServ, Hello
02:40:30 <jle`> hello anonymous_
02:42:59 <anonymous_> Hello jle
02:43:53 <JuanDaugherty> *haskellers I presume though I dunno if anybody uses that
02:44:37 <jle`> i've heard haskellers more often than haskers tbh
02:45:01 <JuanDaugherty> and you've in fact heard "haskers"?
02:45:04 <anonymous_> jle`, What is the meaning of haskellers
02:45:22 <jle`> i actually do not recall ever hearing haskers.
02:45:39 <JuanDaugherty> right because it was created above as a result of a slip
02:46:04 <jle`> did i just witness the birth of something amazing
02:46:15 <jle`> (most likely not, but i can dream)
02:46:43 <jle`> i never knew that edwardk was so passionate about haskell
02:46:48 <jle`> and emotional
02:46:52 <jle`> i just always thought he was really good
02:47:19 <FliPPeh> Is there some way to handle exceptions within a monad stack with liftIO?
02:47:28 * JuanDaugherty notes that the great apes are not known to be especially placid creatures.
02:47:34 <FliPPeh> Without dropping down to IO and losing everything the monad stack gives you?
02:48:16 <JuanDaugherty> with the possible exception of Pango
02:53:31 <Pacy> Is there any one who uses anonymous os?
02:53:46 <jfs> what's taht?
02:54:09 <Pacy> jfs, iT'S on Operating system
02:57:08 <JuanDaugherty> why would anyone use it Pacy, it's apparently a goof rip of ubuntu which is a production level rip of debian
02:57:25 <JuanDaugherty> or rather it apparently was
02:57:57 * JuanDaugherty slaps himself back on topic
02:59:51 <Pacy> JuanDaugherty, I wanted some help concerning it's tools
03:00:18 <JuanDaugherty> Pacy, in #haskell ?
03:00:25 <xpika> what is the easiest way to parse a haskell source file to and ADT of the AST?
03:01:34 <xpika> something that outputs something that looks like this Function "Main" (Call "print" [1])
03:03:21 <Pacy> JuanDaugherty, Why not?
03:04:18 * JuanDaugherty is enlightened about the doubling of the population of this channel over the last 6-7 years
03:09:22 <Saizan> xpika: haskell-src-exts
03:16:38 <dv-> there's no BS.pack . show?
03:18:53 <khyperia> I'm looking to build an irc bot. I'm not looking for a prebuilt bot like lambdabot, just a framework. Any good libraries out there?
03:19:02 <Taneb> dv-, no, and ByteStrings aren't Strings, so watch out
03:19:40 <FreeFull> khyperia: There seem to be several on hackage
03:19:54 <khyperia> the only one I can find is simpleirc
03:20:13 <khyperia> which might do, I dunno
03:20:34 <FreeFull> How about ircbot?
03:20:44 <FreeFull> Actually, maybe not
03:20:50 <khyperia> why is that not under the irc category?
03:20:57 <FreeFull> You could always just use the irc library and implement everything else
03:21:01 <FreeFull> I used the search rather than categories
03:21:52 <khyperia> I'm pretty much doing this as a learning exercise, so implementing everything else is probably the way to go.
03:22:41 <khyperia> any suggestions on how I should structure it, then? I'm thinking some type of FRP, but I've never learned about FRP before and I dunno if it'd be appropriate (but the point is for me to learn)
03:25:36 <Redz> is there a short way to filter a polymorph type for a specific constructor, instead of using pattern matching?
03:26:26 <Fuuzetsu> [ x | x@(SomeConstructor _) <- yourList ]
03:26:52 <Fuuzetsu> > [x | x@(Just _) <- [Nothing, Just 1, Nothing, Just 2]]
03:26:56 <lambdabot>  mueval-core: Time limit exceeded
03:27:00 <Fuuzetsu> > [x | x@(Just _) <- [Nothing, Just 1, Nothing, Just 2]]
03:27:01 <Redz> and with regular filter function?
03:27:01 <lambdabot>  [Just 1,Just 2]
03:27:21 <Redz> i was thinking about
03:27:22 <Redz> data = Foo Int | Bar String
03:27:22 <Redz> > filter (\(Foo i) -> True)
03:27:23 <lambdabot>  Not in scope: data constructor `Foo'
03:27:40 <Fuuzetsu> because that fails with incomplete match when you see Bar
03:28:28 <Fuuzetsu> you could use LambdaCase and have a catch-all returning False
03:28:44 <Redz> so, list comprehension is the only alternative to pattern matching?
03:28:46 <simon> Fuuzetsu, doesn't your case particularly work because Maybe has the right typeclasses?
03:28:53 <Redz> uh what is lambdacase?
03:29:02 <Fuuzetsu> simon: Like what?
03:29:03 <Redz> oh and case.
03:29:08 <simon> Redz, anonymous functions with multiple patterns
03:29:10 <Fuuzetsu> Redz: A language extension
03:29:19 <simon> Redz, you could also just have a case-of inside your lambda.
03:29:19 <FreeFull> Redz: You could use ViewPatterns
03:29:34 <FreeFull> Which is another extension
03:29:55 <FreeFull> Actually, no, that wouldn't work
03:30:09 <FreeFull> lambdacase would be the right thiing
03:30:25 <simon> Redz, if you make your own predicate, you could just use that... e.g.
03:30:35 <simon> > filter isJust [Just 1, Nothing, Just 2, Nothing]
03:30:39 <lambdabot>  mueval-core: Time limit exceeded
03:31:19 <Fuuzetsu> I still think that a list comprehension is the easiest way if you want to avoid helpers &c and only have one constructor that you want, especially because you can unpack it at the same time
03:31:23 <Redz> if i could generate the predicates with template haskell, it would be great.
03:31:59 <simon> I agree.
03:32:50 <ski> > catMaybes [Just 1, Nothing, Just 2, Nothing]
03:32:54 <lambdabot>  mueval-core: Time limit exceeded
03:33:00 <Redz> yep. list comprehensions, seems to be a easy, well known solution. i'll try it.
03:33:12 <ski> hm
03:33:14 <ski> > catMaybes [Just 1, Nothing, Just 2, Nothing]
03:33:18 <lambdabot>  mueval-core: Time limit exceeded
03:33:38 <ski> <lambdabot>  [1,2]
03:34:13 <simon> ski, sure, but for arbitrary constructors.
03:37:44 <skypers> ok I need some help with OpenGLRawgen
03:38:12 <skypers> I built the OpenGLRawgen exec, I ran it on a gl.xml file, now, I want to cabalize the whole thing
03:38:15 <skypers> any idea?
03:40:42 * hackagebot SVGPath 1.1.1 - Parsing the path command of SVG  http://hackage.haskell.org/package/SVGPath-1.1.1 (TillmannVogt)
03:55:43 * hackagebot mongoDB 1.4.3 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  http://hackage.haskell.org/package/mongoDB-1.4.3 (FedorGogolev)
04:07:50 <Fuuzetsu> skypers: ‘cabal init’ is a good start
04:09:01 <skypers> holy crap
04:09:09 <skypers> I didn’t even think of that
04:09:10 <skypers> :D
04:09:32 <merijn> skypers: cabal init + quick gloss over the cabal user guide is usually a good start
04:11:41 <FliPPeh> So I wonder
04:12:14 <nickela> Hello ALL! How to embed function like (d -> a b c) into arrow chain, that produced 'd'?
04:12:15 <FliPPeh> Does it make sense to write my own IO functions like "fancyIo :: (MonadIO m) => ... -> m a" and have them call liftIO?
04:12:19 <FliPPeh> Since IO itself is MonadIO
04:12:31 <FliPPeh> And you wouldn't need liftIO in transformer stacks on top of IO
04:12:35 <FliPPeh> Or is that ew?
04:14:02 <Taneb> FliPPeh, I think that's a style point that really depends who you ask
04:14:14 <Taneb> Are you going to be using the function a lot in transformer stacks?
04:14:16 <FliPPeh> So if I ask lazy people they'd be all for that
04:14:23 <FliPPeh> Taneb: In my case I will be :>
04:14:28 <Taneb> Then go for it
04:14:32 <FliPPeh> It's not a library I'm writing, just for myself
04:14:41 <nickela> for example I have "print :: String -> a String String" and I want embed 'print' into arrow chain that print their argument and return them
04:14:42 <FliPPeh> But I still like to stick with what people think is right
04:14:49 <FliPPeh> Because that's mostly a good thing to do
04:15:15 <merijn> FliPPeh: I alternate between liftIO everything and not
04:15:17 <nickela> f1 >>> embed print  >>> f2, how to write 'embed' ?
04:15:23 <merijn> FliPPeh: Still unsure which I prefer
04:15:38 <merijn> FliPPeh: I think there's no strong consensus either way, so just use what you prefer
04:15:53 <FliPPeh> Okeydokey
04:17:24 <Taneb> nickela, where do you want print to take its argument from?
04:19:20 <nickela> actually, I wrtting code for netwite now, and I have function ' f :: String -> Wire .... ' and I need embed this function into wires pipeline
04:20:17 <nickela> I found solution now via netwire  ( switch (arr f) empty
04:21:02 <nickela> but I think is exist more general way for arrows ?
04:21:13 <nickela> like join for monads
04:21:19 <nickela> but for arrows
04:21:57 <Taneb> Maybe something with app
04:22:46 <nickela> I will try
04:25:58 <zett_zelett> http://www.xkcd.com/1270/
04:26:00 <nickela> Taneb: cool, it works: app (arr f &&& id)
04:26:16 <nickela> Taneb: thanks :)
04:26:24 <zett_zelett> “Functional programming combines the power and flexibility of abstract mathematics with the intuitive clarity of abstract mathematics.” – love it.
04:30:46 * hackagebot rex 0.4.3 - A quasi-quoter for typeful results of regex captures.  http://hackage.haskell.org/package/rex-0.4.3 (MichaelSloan)
04:31:11 <nickela> Taneb: hm, but netwire not have ArrowApply instance for Wire... so return to solution via switch
04:40:25 <Taneb> Is there a way to do a template haskell ''Foo thing on a name that has multiple tokens?
04:51:24 <benmachine> Taneb: names have multiple tokens?
04:52:24 <Taneb> benmachine, like "Maybe Bool"
04:55:35 <benmachine> Taneb: that's not a name as such
04:55:40 <benmachine> it's a type but it's made of two names
04:56:44 <andreaseggenschw> nick Res
04:56:45 <Taneb> benmachine, okay, but you know what I mean
05:00:15 <Philonous> Taneb, type MaybeBool = Maybe Bool and then you can just pass ''MaybeBool ?
05:06:19 <andreaseggenschw> lambdabot
05:14:12 <haasn> Philonous: I'm quite sure type synonyms don't get lifted to kinds
05:15:12 <Philonous> haasn, This is name quoting, not type lifting
05:15:17 <haasn> oh!
05:15:30 <haasn> too much DataKinds form e
05:15:40 <Philonous> :>
05:16:02 <Philonous> I wonder how those features interact
05:20:50 * hackagebot structured-haskell-mode 1.0.0 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.0 (ChrisDone)
05:21:15 <greg`> can someone tell me what i need to do about -> fwaccel.hs:44:14: Not in scope: `A.min'
05:24:44 <andreaseggenschw> @help
05:24:45 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:25:35 <andreaseggenschw> @version
05:25:35 <lambdabot> lambdabot 5.0-int-e
05:25:35 <lambdabot> git clone git://github.com/int-e/lambdabot.git
05:26:08 <andreaseggenschw> :t +
05:26:11 <lambdabot> parse error on input `+'
05:26:18 <klrr_> :t (+)
05:26:20 <lambdabot> Num a => a -> a -> a
05:38:46 <lelf> Can use somehow access parsec user state on ParseError?
05:40:52 * hackagebot mongoDB 1.4.4 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  http://hackage.haskell.org/package/mongoDB-1.4.4 (FedorGogolev)
05:45:39 <kinslayer> I have a html document in bytestring which I passed through html-conduit and now I have a parsed document, however I am still a bit confused as to how I could search it for some <div>'s or other tags with all the children...
05:48:50 <zinfandel> :q
06:34:10 <implementation> hey guys, in the line "instance (MonadTrans t,MonadFBA m) => MonadFBA (t m) where" ghc complains that it cannot derive (t m) to be a monad, but doesn't a Monad applied to a Monad Transformer always give a new monad? how do I tell haskell that this is valid?
06:38:18 <rawtass> beginner question: http://lpaste.net/97332, how do I convert this Int (from the length) to a [Char] so I can ++ it with the other [Char] ?
06:41:22 <lieven_> rawtass: show
06:41:23 <pavonia> rawtass: show
06:41:28 <Perseid> rawtass: I'm rather new to haskell myself, but I have successfully used "show" for these usecases: "show (length xs)"
06:42:12 <sdrodge> Watch out guys, this was posted on reddit today: https://gist.github.com/quchen/5280339 - There might be some trolls coming in here to test whether or not #haskell is truly untrollable.
06:43:56 <rawtass> why do I have to say show (length xs)
06:44:08 <rawtass> thought I could do show $ length xs
06:44:13 <rawtass> or show length xs
06:45:07 <geekosaur> `show length xs` passes two parameters to show and none to length
06:45:24 <geekosaur> `show $ length xs` is valid... sometimes. depends on where you're using it
06:45:40 <geekosaur> but if you're treating ($) as magical, it will never make sense
06:46:05 <geekosaur> because it will stubbornly refuse to actually *be* magical
06:46:08 <Perseid> thats my cue: how is "$" not magical ;)
06:46:26 <Perseid> or, why does it not work in some cases?
06:46:28 <rawtass> geekosaur: ok, thanks.. Yes, $ did not use in this case
06:46:40 <rawtass> this examples was "foo bar length: " ++ show $ length xs
06:46:41 <geekosaur> Perseid, it's just application at low precedence
06:46:54 <aristid> Perseid: x $ y = x y, it's just a little operator function that allows you to effectively reduce the precedence of function application
06:46:58 <geekosaur> `x $ y` is exactly `(x) (y)`
06:47:04 <geekosaur> for x and y both as long as they can possibly be
06:47:43 <geekosaur> so, for rawtass's example, the reuslt is `("foo bar length: " ++ show) (length xs)` which should be pretty obviously nonsense
06:47:45 <Perseid> ah ok, it is an infix operator
06:47:59 <aristid> when you do (x) (y), the function application still has high precedence, so if it's embedded in a bigger expression, $ will behave a bit differently
06:48:35 <geekosaur> rawtass, in particular you are expecting ($) to read your mind and know where to stop
06:48:43 <geekosaur> it doesn't; it just keeps going
06:49:09 <aristid> generally i would recommend stickhing with just using parens mostly, it's far harder to make a mistake that way
06:49:11 <rawtass> I thought it would stop at the end of the line :)
06:49:18 <geekosaur> it did
06:49:32 <geekosaur> what part of `("foo bar length: " ++ show) (length xs)` makes sense to you?
06:49:32 <Perseid> I got the part about the right side being processed completely, but somehow missed the implication on the left side when reading the documentation. Thanks
06:49:50 <geekosaur> it stopped at *both* ends
06:49:57 <aristid> geekosaur: instance IsString (a -> String) :D
06:50:52 <Perseid> so the problem with the above is that a function cannot be concatenated to a string
06:50:58 <Perseid> with the ++ operator
06:51:11 <aristid> :t (++)
06:51:13 <lambdabot> [a] -> [a] -> [a]
06:51:37 <geekosaur> actually, the problem is pretty much what you said earlier: people assume the stuff on the left is "already parsed" and $ will only extend rightward
06:51:48 <geekosaur> but that's not how precedence works...
06:51:51 <Hodapp> Dear #haskell folks: C++ feels even worse now. Thanks for nothing.
06:51:52 <Perseid> yeah, I'm figuring out why currying does not work, and that feels like the reason for me ^^
06:51:52 * Hodapp stalks off
06:52:53 <geekosaur> Hodapp: dude, I'm a Perl programmer. tell e about it. :p
06:52:53 <Fuuzetsu> Hodapp: Even worse? That's pretty bad.
06:53:26 <Perseid> :t (\x -> "abc"++ (show x))
06:53:27 <geekosaur> at least C++ has types, however loosely
06:53:28 <lambdabot> Show a => a -> [Char]
06:53:38 <aristid> Perseid: the () is not necessary in there
06:53:51 <aristid> Perseid: because function application always binds higher than any operator
06:54:06 <Perseid> :t \x -> "abc"++ (show x
06:54:08 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
06:54:16 <Perseid> :t \x -> "abc"++ show x
06:54:17 <lambdabot> Show a => a -> [Char]
06:54:26 <Perseid> good to know
06:55:29 <Perseid> > \x -> "abc"++ show x $ 5
06:55:33 <lambdabot>  Couldn't match expected type `a1 -> t0'
06:55:33 <lambdabot>              with actual type `[GHC.Types.Char]'
06:55:57 <Perseid> > (\x -> "abc"++ show x) $ 5
06:56:00 <lambdabot>  "abc5"
06:57:09 <aristid> Perseid: the $ there is unnecessary
06:57:20 <aristid> > (\x -> "abc"++ show x) 5
06:57:24 <lambdabot>  "abc5"
06:57:27 <Perseid> aristid: so function application binds higher if there is an actual argument, but not for currying
06:57:33 <aristid> Perseid: ?
06:57:39 <aristid> it ALWAYS binds higher.
06:57:55 <aristid> currying does not exist to the syntax.
06:58:03 <sdddfff> Is there a way to tell HXT to skip <b>s, <i>s and similar tags when getText is used?
06:59:52 <Perseid> aristid: that is a good point :)
07:00:19 <Perseid> haskell still gets me confused
07:00:28 <bennofs> Is there a negated pattern in haskell?
07:00:37 <Perseid> about low level stuff even
07:01:03 <bennofs> Because haskell-src-exts has a PNeg :: Pat -> Pat constructor
07:01:14 <dwcook> bennofs, no, but you can match everything else in a previous case then use _
07:01:26 <dwcook> (barring extensions, but I'm unaware of an extension for that)
07:01:49 <kersplodey> Uh, hi! I've got a question. I'm trying to implement a few functions for AVL Trees in haskell, does anyone have any resources or anything that might help? Kind of stuck as to where I should start.
07:02:33 <sdddfff> For example, hasAttrValue "class" (== "foo") /> getText returns "This should be " for <span class=foo>This should be <b>bold</b>, right?</span>, but I'd like to get the whole sentence.
07:02:44 <klrr_> in attoparsec how do i write this "s <- many (noneOf "\"")" (this one in parsec)?
07:03:07 <dario`> kersplodey: how far have you gotten before you got stuck?
07:03:12 <Feuerbach_> bennofs: yes, f (-1) = 42
07:03:27 <kersplodey> dario`: Well, I'm not really sure where I should begin with it, to be honest.
07:03:53 <Feuerbach_> bennofs: the field is of type Pat to incorporate both integer and floating literals
07:04:17 <Feuerbach_> bennofs: see section 3.17.1 of Haskell 2010
07:04:40 <mgsloan> bennofs: Humorously, HSE actually implements pattern parsing by parsing it as an expression and then generating errors while converting to the pattern AST
07:05:25 <mgsloan> Roughly speaking, actually, rather, I think they both share a "core" expression parser
07:05:34 <dwcook> Oops, I suppose I misunderstood the question
07:05:37 <dario`> kersplodey: well, what could your avl data declaration look like?
07:05:43 <bennofs> kersplodey: I don't really know how AVL trees work, but maybe you should start by defining a data type for your tree
07:06:57 <mgsloan> (I bet GHC still does this too, since HSE was forked from GHC's parser)
07:08:35 <kersplodey> dario`: Something like this? data AVLTree t = Empty | Root Int (AVLTree t)(AVLTree t)
07:09:25 <bennofs> kersplodey: And where do you want to store the values in this data type? I see no 't' field
07:10:57 <kersplodey> bennofs: Hm?
07:11:16 <kersplodey> How do you mean?
07:11:39 <bennofs> kersplodey: How would a tree with the element '3' of type AVLTree Int look with your data type?
07:11:54 <bennofs> There is no place where you could put the data
07:13:06 <kersplodey> That is a really good question.
07:13:12 <kersplodey> I'm not really that good at Haskell.
07:15:16 <bennofs> kersplodey: I think AVL trees contain values in the nodes. So you have to extend the 'Root' constructor of your AVLTree data type
07:17:31 <Fuuzetsu> somewhat related, but are there rose trees with ‘terminal’ leaves that can't have more children?
07:17:40 <Fuuzetsu> I don't really want to roll one myself
07:18:37 <bennofs> Fuuzetsu: you mean something like data Tree a = Empty | Rose [Tree a] | Leaf a ?
07:19:18 <Fuuzetsu> Yeah. I'd love to leverage existing tree though, including the instances and whatnot
07:19:29 <kersplodey> bennofs: I thought it would work as it's a recursive definition and the value of the node would be stored at Root Int?
07:19:30 <Fuuzetsu> I don't think there's a clean way to do it though
07:19:57 <aristid> bennofs: sounds like Tree (Maybe a) to me
07:20:40 <bennofs> kersplodey: but your 'Root' constructor has no t field
07:21:16 <bennofs> kersplodey: So far, you can only construct AVLTrees that look like this: Root 3 (Root 4 Empty) (Root 5 Empty)
07:21:19 <aristid> bennofs: ah nevermind, Tree can have labels on inner nodes too
07:21:48 <pavonia> I have many patterns like "case m of { Just x -> return x; Nothing -> case n of { Just y -> return y; Nothing -> ... } }" where m and n are Maybes. It's like the opposite of the Monad instance, i.e. trying all subsequent Maybe values and failing only if the last action fails. Is there a way to make that less verbose?
07:21:55 <bennofs> kersplodey: woops, I meant Root 3 (Root 4 Empty Empty) (Root 5 Empty Empty)
07:22:16 <bennofs> kersplodey: you need to extend the 'Root' constructor to include a value of type t.
07:23:13 <bennofs> kersplodey: so that you can for example have a AVLTree String: Root 3 "Foo" (Root 4 "Bar" Empty Empty) (Root 5 "Baz" Empty Empty)
07:23:37 <kersplodey> So, would it look more like: data AVLTree t = Empty | Root t (AVLTree t) (AVLTree t)
07:23:45 <aristid> :t foldMap Last
07:23:47 <lambdabot> Foldable t => t (Maybe a) -> Last a
07:24:15 <aristid> > foldMap Last [Just 1, Nothing, Just 2]
07:24:19 <lambdabot>  Last {getLast = Just 2}
07:24:39 <pavonia> :t Last
07:24:41 <lambdabot> Maybe a -> Last a
07:24:45 <FreeFull> > Just 3 <|> Nothing <|> Just 4
07:24:48 <lambdabot>  Just 3
07:24:54 <FreeFull> > Nothing <|> Just 3 <|> Nothing <|> Just 4
07:24:55 <lambdabot>  Just 3
07:25:22 <pavonia> > foldMap First [Nothing, Just 1, Nothing, Just 2]
07:25:23 <lambdabot>  First {getFirst = Just 1}
07:25:25 <bennofs> kersplodey: yeah, but now you also need the Int field for the balance. So it's actually: data AVLTree t = Empty | Root Int t (AVLTree t) (AVLTree t)
07:25:29 <Fuuzetsu> :t First
07:25:31 <lambdabot> Maybe a -> First a
07:25:39 <Fuuzetsu> @src First
07:25:39 <lambdabot> Source not found. My mind is going. I can feel it.
07:25:41 <pavonia> Nice, I want one of these
07:25:44 <FreeFull> pavonia: Would this be useful? (<|>) is from Control.Applicative
07:25:48 <aristid> First and Last are in Data.Monoid
07:25:58 <aristid> foldMap is in Data.Foldable
07:26:01 <FreeFull> > foldMap (<|>) [Nothing, Just 3, Just 5, Nothing]
07:26:03 <lambdabot>  No instance for (Data.Monoid.Monoid a0)
07:26:04 <lambdabot>    arising from a use of `e_135'
07:26:04 <lambdabot>  The type variable `a0' is ambiguous
07:26:04 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
07:26:04 <lambdabot>  Note: there are several potential instances:
07:26:19 <pavonia> FreeFull: Yep, though some kind of list notaion would be even better
07:26:55 <bennofs> pavonia: there is msum
07:26:59 <Fuuzetsu> that might be useful
07:27:04 <bennofs> > msum [Just 3, Just 4, Just 5]
07:27:05 <lambdabot>  Just 3
07:27:09 <Fuuzetsu> :t msum
07:27:11 <lambdabot> MonadPlus m => [m a] -> m a
07:27:19 <bennofs> > msum [a,b,c]
07:27:20 <lambdabot>  Couldn't match expected type `m0 a0'
07:27:20 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'Couldn't match e...
07:27:20 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'Couldn't match e...
07:27:20 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
07:27:24 <pavonia> > msum [Nothing, Just 3, Just 4, Just 5]
07:27:25 <lambdabot>  Just 3
07:27:26 <FreeFull> > msum [Nothing, Just 3, Nothing, Just 5]
07:27:28 <lambdabot>  Just 3
07:27:33 <FreeFull> msum it is
07:27:51 <pavonia> okay
07:27:54 <liquidmog> kersplodey: So with the data definition what have you got to actually do with it?
07:28:32 <kersplodey> liquidmog: Uh, implement functions for searching, inserting and displaying, I think
07:28:38 <kersplodey> Hold on...
07:28:45 <kersplodey> Yeah, that's right.
07:28:54 <pavonia> thanks, I have to look more into all that MonaPlus, Monoid, etc. stuff
07:29:02 <bennofs> kersplodey: The easiest thing is probably first to write isEmpty :: AVLTree t -> Bool
07:36:01 * hackagebot postgresql-simple 0.4.0.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.4.0.0 (LeonSmith)
08:17:26 <RoryHughes> Sorry, but who is 'haskell'?
08:17:54 <Zetaeta> RoryHughes: http://en.wikipedia.org/wiki/Haskell_Curry
08:18:09 <RoryHughes> Sorry, but who is 'Zetaeta'?
08:18:25 <Zetaeta> begone, troll
08:19:14 <RoryHughes> Sorry, but.... troll?
08:36:06 * hackagebot git-annex 5.20131221 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20131221 (JoeyHess)
08:43:18 <danilo2> Hello :) I want to download the newest ghc 7.7 and on the official GHC page there is lnk to: http://darcs.haskell.org/ghcBuilder/uploads/ there we can find a lot of builds (from almost every day between 21 Jul and 28 Aug 2013). What has happened on 28 Aug? Are there no newer builds?
08:47:39 <Taneb> danilo2, I think that was when they changed the number to 7.8
08:47:56 <Taneb> Also, you should really use 7.6, I believe 7.7 is the development version
08:48:42 <danilo2> Taneb: I thought, that even "dot version" numbers are official releases. I do not think 7.8 is out, is it?
08:49:35 <epta> Where is 7.8 btw?
08:50:27 <kqr> 7.8 is not out yet
08:50:44 <kqr> even numbers usually signify public releases and odd numbers development versions
08:50:59 <danilo2> kqr: exactly! so where can I download the newest 7.7?
08:51:20 <danilo2> kqr: http://darcs.haskell.org/ghcBuilder/uploads/ - here we can find versions up to 28 Aug 2013
08:51:23 <td123> danilo2: github?
08:52:13 <pavonia> Is there already a flipped version of fmap somewhere, preferably as an infix operator?
08:52:26 <Taneb> There is in lens
08:52:30 <Taneb> (<&>)
08:52:39 <kqr> danilo2, have you looked at https://ghc.haskell.org/trac/ghc/wiki/Building/GettingTheSources
08:53:05 <roconnor> yougthos: "Moral of the story is that pure functions are only practical when your language is backed by persistent data structures.
08:53:16 <roconnor> That is a fine fine observation
08:53:57 <danilo2> kqr: yes ... "Source distributions for all versions of GHC are available from the download page" -> dead link
08:54:09 <kqr> danilo2, and the git?
08:54:24 <td123> danilo2: http://www.haskell.org/pipermail/ghc-devs/2013-December/003491.html
08:54:33 <pavonia> Taneb: Installing lens for that is too much overhead, but I guess I will adopt the operator
08:54:39 <td123> in case you're wondering about 7.8 status, you can follow the thread there
08:55:08 <roconnor> pavonia: that seems like a wise decision
08:55:28 <danilo2> td123: ok thank you. I will foollow it
08:55:50 <rasfar> what's a good way to find out all the actual dependencies of my cabalised, sandboxed project? i tried commenting out the buiild-depends in .cabal file, but cabal configure doesn't mind...
08:55:53 <roconnor> Of course, I the type of person who will define specialized versions of (***) and (&&&) when I find importing Control.Arrow too much overhead. :D
08:55:57 <danilo2> kqr: I'll do it with git. I understand that all commits on master branch are buildable and are working good ?
08:56:00 <rasfar> i imagine a cabal init at this point might be the wrong thing?
08:56:29 <rasfar> or is it safe to move the .sandbox temporarily aside and try cabal configure again?
08:56:35 <pavonia> :t (<&>)
08:56:38 <lambdabot> Functor f => f a -> (a -> b) -> f b
08:57:33 <rasfar> b/c all the advice I see about this suggests running cabal init, but it's much water under the bridge since then in my case...
08:58:08 <rasfar> my problem is, i've been adding sub-deps to the .cabal and just realised this isn't necessary, now trying to pare it down
08:59:13 <rasfar> alright, i will make a copy of the whole project, clean out the .sandbox, and try re-initting...
09:01:02 <epta> Question for vim users. hasktags or fast-tags or hothasktags?
09:01:04 <ParahSailin> why is the TH Q monad applicative instance not defined?
09:12:27 <rasfar> yeah that was helpful. anyone who may read this, beware that your existing .cabal file will be overwritten (that is, if you cabal init later in order to test project dependancies)
09:12:39 <rasfar> any advice on best practise for this would be appreciated
09:13:08 <aristid> polymorphic all the things for the benefit of type safety and expressiveness!
09:16:52 <rasfar> correction: it will backup your old .cabal file (to *.cabal.save0 and Setup.hs.save0) -- didn't notice as the copied dir had a different name, which became the default project name on cabal init
09:17:11 <rasfar> but it's still a heck of a messy way to find out the build-depends
09:32:19 <rasfar> one thing to bear in mind, in case you use #if 0 ... #endif to temporarily comment out imports: cabal init will still see them as dependancies...
09:43:32 <schell> what's the default value for --package-db in cabal/ghc-pkg/ghc?
09:43:47 <dcoutts_> schell: global + user
09:44:56 <schell> dcoutts_: thanks, is there a way, like a flag I can pass to cabal/ghc-pkg to find out exactly where that points?
09:45:09 <dcoutts_> schell: ghc-pkg list says
09:45:27 <schell> oh! is that it then, awesome - thanks
09:46:08 <schell> dcoutts_: so it's usually something like /path/to/package.conf.d
09:47:48 <dcoutts_> schell: right. OOI, why do you care where they are exactly?
09:49:09 <schell> dcoutts_: i've got 4 different ghc's (7.6.3 from platform, HEAD and ghc-ios and ghc-ios-simulator) and i'm trying to configure their respective cabals correctly
09:49:58 <dcoutts_> schell: you just need to get cabal to use the right ghc-pkg. You don't need to tell it where the package db is.
09:50:15 <dcoutts_> the right ghc+ghc-pkg
09:51:04 <schell> huh - and i thought that for the iOS compilers that was already taken care of
09:51:48 <dcoutts_> schell: if it's already using the right ghc + ghc-pkg then that's fine. You never need to tell cabal where the global or user package dbs are.
09:52:06 <schell> then i'm probably making some other mistake
09:52:46 <dcoutts_> schell: ah, the user package db would be shared between different instances of the same compiler version for the same arch
09:53:01 <schell> weird
09:53:34 <dcoutts_> schell: since it's ~/.ghc/${arch}-${compiler}/
09:53:46 <schell> if i do arm-apple-darwin10-ghc-pkg list it lists a different db
09:54:05 <schell> it doesn't look like the iOS ghc package dbs are set?
09:54:09 <dcoutts_> so if you had two instances of ghc installed for the same arch and the same ghc version then the user dbs would alias
09:54:43 <dcoutts_> you can check of course, using ghc-pkg list for each ghc-pkg
09:55:28 <schell> http://lpaste.net/97337
09:56:02 <schell> and looking at my ~/.ghc it seems there are three databases but each corresponds to an older HEAD build
09:56:35 <dcoutts_> schell: so there are no user packages for those yet.
09:56:47 <schell> huh
09:57:16 <schell> ah - okay, i think i see what's happening
09:57:23 <dcoutts_> schell: I mean for arm-apple-darwin10-ghc-pkg for example, there are no user packages, otherwise it'd list them.
09:57:33 <dcoutts_> that's ok of course
09:57:37 <schell> right
09:57:50 <dcoutts_> and you may prefer to keep it that way
09:58:32 <schell> if i use my custom arm.config file for `arm-apple-darwin10-cabal --config-file=config.arm install vector`, it says vector has already been installed
09:59:07 <schell> but if i just do `arm-apple-darwin10-cabal install vector` i get a build error, so that must be why nothing has ever been installed, it can't build correctly
09:59:19 <schell> i think my arm compiler is still borked then
10:00:56 <schell> thanks!
10:07:36 <spitfiredd> hi
10:10:07 <Pupnik> can you pattern match on number of arguments in haskell?
10:10:46 <mauke> all functions take exactly 1 argument
10:11:47 <simpson> Pupnik: What's your goal?
10:12:59 <Pupnik> no goal, just curious.  I'm just starting out and couldn't figure out a way to do it without packaging arguments into a list
10:17:19 <geekosaur> there are ways to do varargs. they're pretty hairy
10:20:29 <valrus_> So, I'm traveling for the holidays and would like to mess with Haskell but all I'll have is an iPad. What are my options?
10:21:41 <kqr> Pupnik, generally you know from the type how many arguments a function takes
10:21:48 <kqr> Pupnik, so a function will always take the same number of arguments
10:22:01 <kqr> Pupnik, you can get around it, but you need good reason to
10:29:46 <td123> valrus_: you can try the fpcomplete ide which is hosted on the cloud, I've never used it though
10:31:42 <valrus_> Just found that through tryhaskell. Money tho :/
10:32:16 <td123> they have a free version
10:32:50 <kqr> valrus_, there's a free community version
10:32:59 <td123> valrus_: https://www.fpcomplete.com/business/fp-haskell-center-pricing/
10:32:59 <valrus_> Oh, nice
10:33:02 <Clint> edwardk: adjunctions
10:33:03 <valrus_> Thx
10:33:23 <edwardk> oh yeah i left adjunctions. i should right that
10:34:13 <benmachine> iswydt
10:35:59 <lispy> Why are Haskell courses graded by exam only? Because we lack assignments.
10:36:03 <valrus_> Maybe they have GHC installed at work and I can ssh in
10:36:16 <pranz1> hah
10:48:52 <erisco> you around ski ?
10:49:50 <erisco> given a cyclic graph I want to collect all vertices in a finite list. this is my approach thus far, adapting my memoisation techniques from yesterday
10:50:00 <erisco> http://lpaste.net/97340
10:50:21 <erisco> however, it is not functioning correctly so I have missed something :( no list returns
10:50:41 <erisco> test case is "vertices test"
10:51:19 <erisco> a simple graph such as  a = Vertex 0 [Edge a 'a'] True   works
10:58:39 <Eduard_Munteanu> Hm, disappointing... it seems you can't pull constraints out of GADT indices the same as when you put them in.
10:59:48 <donri> Eduard_Munteanu: are the tricks used here relevant? https://typesandkinds.wordpress.com/2013/12/17/singletons-v0-9-released/
11:01:14 <pranz1> a setter is essentially fmap for (Product a) isn't it?
11:01:35 <pranz1> and getter is coreturn for (Product a)
11:04:19 <Eduard_Munteanu> donri: mm, I don't think so... I'm poking at    data Foo :: ... -> Constraint -> ... where Con :: ... -> Foo ... SomeClass ...
11:05:06 <donri> Eduard_Munteanu: is that Dict from constraints?
11:05:35 <robstewartuk> I'd like to use list comprehension, involving a list and a function in the IO monad. See http://lpaste.net/97341 . How similar to `h` can I make the implementation of `g` look?
11:06:01 <Eduard_Munteanu> Er, no, maybe I should paste things.
11:06:07 <Eduard_Munteanu> Hold on.
11:06:23 <donri> :t sequence -- robstewartuk
11:06:26 <lambdabot> Monad m => [m a] -> m [a]
11:06:58 <robstewartuk> donri: ok...
11:07:10 * robstewartuk tries to see where it could fit in `g`
11:08:30 <donri> robstewartuk: you write a list comprehension producing IO actions, and then apply sequence to it
11:08:42 <robstewartuk> thanks. /me tries.
11:11:57 <rtpg> >When using a type declaration, the type synonym and its base type are interchangeble almost everywhere (There are some restrictions when dealing with instance declarations)
11:12:22 <rtpg> this is on haskellwiki concerning type and newtype, I was wondering: what are the restrictions on instance declartions?
11:13:01 <benmachine> rtpg: optional, that's what they are :P
11:13:03 <Eduard_Munteanu> rtpg: regarding newtype? No restriction at all
11:14:03 <rtpg> sorry, in that statement, type is the keyword type
11:14:08 <benmachine> rtpg: by default, something like type X = Y; instance Show X would be forbidden
11:15:11 <benmachine> rtpg: however, there's not a very good reason why this is the case, so there's this extension TypeSynonymInstances that removes that restriction
11:15:21 <benmachine> TypeSynonymInstances is pretty uncontroversial
11:15:47 <rtpg> so it's just a "at one point we were too lazy to implement something" sort of thing?
11:16:40 <donri> at least in recent GHC where you can't use it to mask FlexibleInstances which used to be the case, or do i misremember
11:16:52 <Eduard_Munteanu> rtpg: no, the controversial bit is you end up defining an instance for a bunch of logically distinct types
11:17:36 <donri> i think rtpg is asking why TypeSynonymInstances isn't standard
11:18:21 <Eduard_Munteanu> E.g. is  type Name = Text  and you're unaware of it, declaring an instance for Name gets you one for Text really. Also, if type Surname = Text, Surname also has it.
11:18:41 <Eduard_Munteanu> *E.g. if
11:20:42 <rtpg> oh, I see
11:20:49 <rtpg> I can see how that can be an issue, yeah
11:21:23 <rtpg> though in that case you have newtype, I suppose
11:22:04 <erisco> I annotated my paste with the trace I expect for "vertices test" http://lpaste.net/97340
11:22:11 <erisco> I am still not sure why the program hangs
11:22:20 <Eduard_Munteanu> rtpg: yes, definitely, in case Name should be an instance of somthing, but Text shouldn't, or if they should be different instances.
11:22:49 <Eduard_Munteanu> rtpg: also, you can't partially apply type synonyms in e.g. instance heads.
11:23:50 <Eduard_Munteanu> e.g. this would fail:  type Reader r a = r -> a   instance Monad (Reader r)
11:23:57 <Eduard_Munteanu> At least without LiberalTypeSynonyms.
11:32:15 <prasadi> This question is about Haskell and Sqlite3. Suppose I have the following SELECT statement. quickQuery' conn_1 "SELECT * FROM company WHERE code = ? " [toSql code] I want to get the number of rows returned by that query. I know that there's a method called sqlite_num_rows () in sqlite3 , but don't know how to wrap it in Haskell.pls help
11:32:57 <Eduard_Munteanu> prasadi: you should link to the documentation of the DB bindings you're using
11:33:32 <prasadi> I  read it so many time. but couldn't find such
11:33:58 <geekosaur> that's not the point, so much as there are many bindings and we have no idea which one you are using
11:35:56 <prasadi> I'm using  HDBC
11:37:23 <erisco> here is a different formulation of seenFold. http://lpaste.net/97344
11:37:36 <erisco> that feeling when you're asking a futile question :(
11:40:12 <prasadi> Is there a way to convert IO Integer to Integer
11:40:20 <eyebloom> erisco: what's the question exactly? Why does the program hang?
11:40:27 <erisco> eyebloom, yes that is my question
11:40:34 <Eduard_Munteanu> prasadi: http://www.haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
11:40:43 <geekosaur> prasadi, asking that question indicates you need to learn Haskell
11:40:45 <geekosaur> @where lyah
11:40:45 <lambdabot> http://www.learnyouahaskell.com/
11:40:54 <erisco> I've been messaging here for a while now but I can't get any biters with 51 loc
11:40:56 <mauke> prasadi: is there a way to convert (Integer -> String) to Integer?
11:41:23 <eyebloom> What methods have you tried to trace the execution?
11:41:25 <rtpg> what about unsafePerformIO :P
11:41:28 <Cale> prasadi: A value of type IO Integer is like a program which you can run to produce an Integer
11:41:31 <erisco> eyebloom, manual
11:41:40 <Cale> prasadi: You can only run it inside of another IO action though
11:41:55 <eyebloom> Using Debug.Trace?
11:42:01 <erisco> eyebloom, no doing it by hand
11:42:16 <erisco> I am missing a step somewhere :(
11:42:17 <Cale> For example, if you have foo :: IO Integer  then you can write  main = do n <- foo; print n
11:42:22 <Cale> n will be an Integer there
11:42:37 <Cale> and main itself will also be an IO action
11:42:39 <eyebloom> One method that has worked for me in a pinch is to define a temporary function:
11:44:06 <eyebloom> tr m x = trace (m++"start") $ trace (m++"end") x
11:44:24 <eyebloom> tr being a short name for a temporary trace
11:44:45 <eyebloom> m is usually the name of the function being entered or the case alternative
11:45:20 <eyebloom> x is whatever term you suspect might be looping
11:46:08 <eyebloom> so the first trace shows that you got to the evaluation and the second shows that the function terminates
11:46:35 <eyebloom> x would need to have an instance of Show or Outputable etc
11:46:44 <eyebloom> Is that helpful?
11:47:36 <Cale> prasadi: Here's my quick introduction to how IO works: http://www.haskell.org/haskellwiki/Introduction_to_IO
11:48:41 <Igloo> eyebloom: Both traces happen before x is evaluated
11:49:13 <erisco> eyebloom, usually the time the trace is evaluated is hard to predict especially when there is infinite recursion happening somewhere
11:49:18 <erisco> eyebloom, but I will give it a go
11:49:30 <erisco> so far the sites I've tried have not been helpful :(
11:49:45 <eyebloom> Right, laziness can allow the term to pass through this.
11:50:17 <eyebloom> But it also shows that computation you are looking for is deeper in the term.
11:50:30 <Cale> eyebloom: Uh, I think both those traces would print *before* the evaluation of x
11:50:35 <rtpg> what's the term for when we do something like instance Show a => Show [a]?
11:50:58 <Cale> rtpg: An instance with class constraints?
11:51:07 <Cale> Maybe lifting instance, if you want
11:51:38 <implementation> Outputable is a strange thing. What's the sense of Outputable?
11:51:50 <Cale> implementation: Defined where?
11:51:51 <rtpg> I guess I meant, more specifically, with generic sort of instances, how we automatically generate new instances
11:52:08 <Cale> implementation: In the GHC API?
11:52:18 <eyebloom> Sure you can add a case x of y -> y if you want to fully evaluate
11:53:27 <eyebloom> tr m x = trace (m++"start") $ trace (m++"end") (case x of y -> y)
11:53:27 <implementation> Cale: That's the only location where I found it. eyebloom mentioned it a few minutes before.
11:53:30 <Cale> implementation: In the GHC API, it's just a class for the types which have a canonical prettyprinter
11:53:54 <Cale> eyebloom: Expressions are evaluated outermost first
11:53:55 <implementation> But why do we need another class for prettyprinting, if we have Show?
11:54:18 <Cale> eyebloom: So again, the end trace will be evaluated and print its message before the case expression is even looked at
11:54:27 <erisco> eyebloom, I think I discovered that when attempting to pass around the memo table I have a infinite dependency
11:54:50 <Cale> implementation: Because Show is not really for prettyprinting.
11:55:07 <geekosaur> implementation, because Show is not for prettyprinting. it's for *debug* printing
11:55:07 <erisco> but it is hard to tell
11:55:07 <eyebloom> Cale: Sorry, I'm not thinking straight.
11:55:12 <Cale> (Or at least, it's not very pretty)
11:55:16 <eyebloom> This is what I'm actually using:
11:55:48 <eyebloom> tr m x = pprTrace m (text "-->") $ pprTrace m (ppr x) x
11:55:55 <implementation> thanks. then i have to find out how to build an SDoc value O.O
11:56:10 <eyebloom> which using trace would be.
11:56:48 <eyebloom> tr m x = trace m $ trace (m ++ show  x) x
11:57:44 <eyebloom> Helpfulness fail :(
11:58:55 <implementation> great, the i have used Show for the wrong purpose all the time xD
12:00:08 <eyebloom> Implementation: I think Outputable is a ghc thing
12:01:23 <eyebloom> But the function "ppr" will build an SDoc for you.
12:03:05 <Cale> Yeah, it's a GHC internal thing, but there are other prettyprinting libraries which are less specific to GHC's setup which do similar things
12:04:19 <Cale> implementation: One of the more important things that this SDoc type (and corresponding types in other prettyprinting libraries) is able to do is to line-wrap code and get the indentation right, so as to, e.g. line up parameters to a function vertically when they don't all fit on a line.
12:06:01 <rtpg> is there a term for the actual execution of an IO action? as opposed to the simple construction of it?
12:06:39 <Cale> The other thing it does in GHC's case is that values of type SDoc internally depend on things like the dynamic GHC flags, which allow the way that things are pretty printed to be informed by which of GHC's flags are turned on.
12:06:57 <Cale> rtpg: I use the word 'execution' for that pretty consistently.
12:07:16 <Cale> rtpg: I wouldn't use "execution" when I meant "evaluation".
12:07:54 <implementation> thank you, guys ^^
12:09:17 <rtpg> and another small question: did the operational semantics of Haskell have to change when the IO monad was introduced? I really have the impression that they didn't, but a person I'm talking with strongly disagrees (in a more general "you can't have side effects without semantics to go with" sense)
12:10:12 <erisco> rtpg, there is specific compiler support for IO, but referential transparency is preserved, if that is what you mean
12:10:26 <rtpg> I guess I meant in the more language theory sense
12:10:34 <erisco> it preserves it essentially by introducing an anti-pattern
12:11:24 <erisco> that anti-pattern being "the arguments will always be different" and so, in a trivial sense, it is still pure
12:11:27 <rtpg> when looking at the IO inside page on haskell wiki, I got the impression that the whole "world chaining" trick allows us to cheat the system
12:11:53 <erisco> rtpg, yes, it does. that is the anti-pattern I am referring to
12:12:13 <Chousuke> I thought that was just to ensure the proper ordering of executed side-effects
12:12:27 <Chousuke> by introducing a dependency on "world state"
12:12:55 <erisco> Chousuke, that is another benefit of the design, yes
12:13:10 <moop> #1 of mastering haskell -> learning all the built-in functions
12:13:12 <rtpg> from SPJ's "Interactive Functional Programming" paper, I got the impression that it allows us to have effects without actually introducing effects into the language itself (so long as you have an FFI)
12:13:16 <moop> there are so many of them
12:13:47 <Chousuke> and IO being a monad just means you can hide that invisible state token passing behind a nice interface
12:14:22 <geekosaur> rtpg, what you're not seeing is how I/O worked before the IO monad
12:14:39 <geekosaur> which was, roughly, main :: [Response] -> [Request]
12:14:51 <erisco> lazy streams?
12:14:52 <rtpg> yeah, I saw that stuff, nice and dirty
12:15:12 <Chousuke> geekosaur: wait, response to request? not the other way around? :/
12:15:22 <geekosaur> yes
12:15:26 <rtpg> you make requests and recieve responses
12:15:33 <rtpg> so responses are input
12:15:37 <geekosaur> but it starts with receiving a response
12:15:42 <geekosaur> unsolicited
12:15:52 <Chousuke> ah, that makes sense.
12:16:00 <erisco> if it was not such an insult to the type system, I think it is a neat idea
12:17:39 <rtpg> I'm actually writing a report for a class on various ways to do IO in Haskell, and I want to write something along the lines of "Haskell's IO monad can be introduced without actually changing the operational semantics of the language, giving us an effect system in a functionally pure language"
12:17:52 <Chousuke> rtpg: anyway, the pretty part about IO actions as monadic values is that they compose without any side-effects because execution is not evaluation, so you maintain purity and laziness and other nice things.
12:18:01 <eyebloom> geekosaur: Is there a good paper that talks about this non-monadic description of main?
12:18:07 <rtpg> I'm trying to make extra sure this is true though, I got into an argument about it with my professor (not a Haskell person)
12:18:50 <nexx> "execution is not evaluation" I have to remember that
12:18:58 <rtpg> eyebloom, http://cse.iitk.ac.in/users/karkare/courses/2010/cs653/Papers/imperative.pdf
12:19:11 <erisco> eyebloom, the techinque is called "lazy streams" iirc so that might find you something
12:19:14 <rtpg> in "comparison with other I/O styles" they, go into the old version
12:19:32 <geekosaur> http://stackoverflow.com/questions/17002119/haskell-pre-monadic-i-o
12:19:39 <geekosaur> several references
12:20:07 <erisco> rtpg, I think it depends on the nuance of your argument. Haskell is not doing any effects
12:20:37 <erisco> rtpg, in a way... well, it is nuanced. the compiler has to specially support the IO operations
12:21:04 <erisco> but the IO monad allows you to express a sequence of side effects the runtime should do
12:21:12 <rtpg> Basically I'm trying to say that we can consider all expressions to be pure, because in the end , we only evaluate our program to get an IO action "main" that we give to the runtime
12:21:18 <Chousuke> rtpg: of course, Lazy IO wouldn't be a problem at all if we only ever needed to evaluate haskell programs. but some people like to execute the effects as well.
12:21:43 <erisco> it is kind of like an HTML file describes how a page should be rendered, but it does not do any of the rendering
12:22:50 <erisco> but that is sort of splitting hairs
12:23:57 <erisco> rtpg, yes, all the expressions are pure, as long as you ignore all the impure parts of Haskell :)
12:25:21 <Chousuke> is Safe Haskell completely pure?
12:26:29 <ktosiek> as long as you consider IO monad pure
12:26:37 <rtpg> erisco, but is an expression of type IO a impure? I mean in theory it's just a function World -> (a , World), right?
12:27:20 <erisco> rtpg, there are unsafe functions, for instance unsafePerformIO, is what I am referring to
12:27:23 <nisstyre> rtpg: unexecuted IO actions are pure as can be
12:27:34 <rtpg> ok , so if we're not using those we're good
12:27:48 <erisco> rtpg, the reason I bring up the HTML analogy is because depending on your argument with the prof it may be relevant
12:28:04 <erisco> rtpg, because as far as Haskell semantics are concerned, there is no single World that is being mutated
12:28:30 <rtpg> the prof was basically saying that because we have side effects, haskell's semantics needs some sort of thing like linear types to represent effects
12:28:31 <erisco> rather there are many immutable instances of World
12:28:59 <erisco> rtpg, yes, the IO monad does use a linear type behind the scenes, I think, but someone may correct me on that
12:29:00 <rtpg> whereas my impression is that the way the IO monad is designed, the operational semantics of Haskell are still pure, and the linearity is enforced by fake data dependencies
12:29:15 <rtpg> at least it's possible in theory
12:29:22 <Chousuke> a function Something -> IO SomethingElse will always give you the same IO SomethingElse for any one Something, but its effects can vary when executed.
12:30:11 <shachaf> rtpg: "IO a" is not in theory "World -> (a, World)"
12:30:17 <magicman> And suddenly there was concurrency.
12:30:21 <shachaf> It isn't even that in practice, though it's something that looks vaguely similar.
12:30:28 <shachaf> But it's definitely nothing like it in theory.
12:30:41 <bmnxc> could anyone explain why mkAbsURI from hxt prepends the current directory to the link, not the url?
12:31:07 <rtpg> shachaf, really? pre-concurrency, I thought it was like that
12:31:26 <erisco> rtpg, if you look at the source the type used is called RealWorld
12:31:27 <rtpg> I have the impression that extra semantics were needed for Concurrent and Paralllel Haskell
12:31:59 <erisco> I do not think Haskell has any support for linear types, but I think it is fair to say the manor in which RealWorld is used is as though it was a linear type (ie, if it was a linear type, there would be no compile error)
12:32:28 <shachaf> Well. There's no advantage and no real sense to thinking about it that way as far as I can tell.
12:32:38 <shachaf> RealWorld is used in a manor? Maybe that's what I've been getting wrong.
12:32:59 <erisco> erm
12:33:00 <erisco> manner
12:33:31 <rtpg> Right, the point I want to make is that we don't have to consider things like linear types because we can implement IO in a simple type setting
12:33:34 <shachaf> Anyway, I don't recommend thinking about the internal GHC type "RealWorld" unless you're messing with internals for some reason.
12:33:53 <rtpg> shachaf, this is more of a discussion on the theory of the language itself than implementation
12:34:00 <shachaf> From a user's perspective, IO is an abstract type.
12:34:08 <erisco> shachaf, well, evidently in rtpg's discussion, whether or not RealWorld could be considered a linear type is of concern
12:34:35 <shachaf> There is no RealWorld.
12:34:52 <erisco> what do you mean?
12:35:10 <Eduard_Munteanu> erisco: it's only a phantom type
12:35:22 <shachaf> Maybe I'm missing some context here.
12:35:36 <erisco> phantom meaning the compiler eventually discards it? yes I know
12:35:38 <shachaf> I see what rtpg's goal is now.
12:35:49 <erisco> but it does satisfy part of the compilation process
12:35:52 <rasfar> bmnxc: maybe your base is a file:// not a http:// ?
12:35:52 <erisco> else it would not be there
12:35:56 <shachaf> rtpg: Did you see the answer I wrote at http://stackoverflow.com/a/13538351/712548 ?
12:37:32 <rtpg> I want to basically be able to say "you can build an IO monad in functionally pure semantics, so adding an IO monad doesn't require changing how you think about the semantics (unsafe* nonwithstanding) of the language"
12:37:56 <shachaf> I don't know what "building something in functionally pure semantics" really means.
12:38:25 <shachaf> And you could do I/O in Haskell without monads, certainly.
12:38:25 <erisco> rtpg, you could make MyIO in Haskell right now, but you could not make it have any side effects
12:38:41 <shachaf> Anyway, did you read the post I linked to above?
12:38:51 <rtpg> well, in a language like C, there's an operational semantics regarding expression evaluation order, notably
12:38:58 <rtpg> *are
12:39:06 <shachaf> erisco: Why not?
12:39:24 <erisco> shachaf, presuming you do not break purity and you do not use the IO monad
12:39:29 <erisco> shachaf, is there any way then?
12:39:33 <rtpg> erisco, what about if you have the FFI
12:39:44 <Eduard_Munteanu> FFI is IO too.
12:40:15 <shachaf> OK, that sounds like not a useful argument.
12:40:26 <rtpg> but you can declare pure functions via the FFI too, right?
12:40:32 <erisco> when rtpg says "you can build an IO monad in functionally pure semantics" what I am trying to illuminate is that if you wanted to make your own IO monad, you could not
12:40:38 <shachaf> You need to have some mechanism of having side effects in order to have side effects, in Haskell as in C.
12:40:49 <Eduard_Munteanu> rtpg: you can declare them "pure, trust me".
12:41:02 <rtpg> so you just say, in the haskell world, that you have a pure function of type "World -> Int, World",  and from there build your own IO monad
12:41:07 <shachaf> rtpg: Did you read my post above?
12:41:22 <shachaf> I can say more things once you've read it.
12:42:45 <mcstar> can you post the link again? im interested but joined after that
12:42:51 <shachaf> Anyway, certainly you can make your own type to represent I/O. And just like the normal "IO" type, you'll need to run your actions somehow.
12:43:22 <nisstyre> mcstar: http://stackoverflow.com/a/13538351/903589
12:43:25 <shachaf> It's a sad property that programs don't run without being run.
12:44:01 <rtpg> shachaf, thanks , I think the question confirmed what I was thinking
12:44:11 <shachaf> Uh oh.
12:44:21 <shachaf> If what you were thinking was World -> (a, World) then I have failed.
12:44:24 <rtpg> I'm not very clear on what I'm trying to say, I think
12:44:31 <rtpg> no I don't think it's like that
12:44:52 <erisco> how about
12:45:05 <greg`> Data.Array.Accelerate doesnt have a min function
12:45:07 <erisco> "you can build an IO monad that has a functionally pure interface"
12:45:42 <erisco> that claim allows you to then have side effects under the hood
12:46:20 <erisco> which is exactly what side effects in Haskell are. IO is the interface and the compiler does the under-the-hood side effects
12:46:22 <rtpg> I think my prof thinks that monads somehow get special treatment in the language
12:46:34 <erisco> monads do not. IO does
12:46:50 <Eduard_Munteanu> Only as far as do syntax et al. are concerned.
12:46:50 <nisstyre> monads get special treatment in the parser though
12:47:02 <nisstyre> however they do not in the core language
12:47:13 <rtpg> right, it's mainly about the core language
12:47:19 <nisstyre> i.e. they get desugared into something that is no more special than other things
12:47:46 <startling> nisstyre, I don't think that's "monads get special treatment
12:47:55 <startling> I think that's "do notation gets special treatment".
12:48:05 <startling> the parser presumably has no idea what types things are.
12:48:14 <greg`> can anyone help me diagnose why my cabal compiler is saying there is no min function in Data.Array.Accelerate
12:48:30 <Eduard_Munteanu> Yeah, it only cares about (>>=) and (>>) being in scope.
12:48:45 <startling> does it?
12:48:45 <Eduard_Munteanu> Not their types.
12:49:00 <startling> I think it just desugars to Prelude.(>>=).
12:49:20 <nisstyre> startling: you can sort of think of an extremely simplified "type system" for parsing though, like "this is a number", "this is a list", etc... for the sake of conceptual symmetry
12:49:24 <greg`> well ive downloaded the source code from simon marlows parllel haskell book
12:49:34 <dolio> Depends on whether you have RebindableSyntax enabled.
12:49:36 <greg`> and its complaining about the data array
12:49:36 <Eduard_Munteanu> Not with RebindableSyntax at least.
12:49:40 <Eduard_Munteanu> Ah.
12:50:18 <dolio> GHC also used to (at least) type check do notation without desugaring it.
12:50:22 <Eduard_Munteanu> The nice thing is you can redefine do notation for stuff like indexed monads, I think.
12:50:34 <nisstyre> dolio: I'm guessing that was to give nicer error messages
12:50:38 <dolio> Not sure if it can still do that with arbitrary rebinding.
12:51:04 <nisstyre> but I guess they found a way to do it after desugaring?
12:51:07 <Eduard_Munteanu> Also MonadComprehensions, btw.
12:51:26 <dolio> At one point, it had some amusing effects.
12:51:44 <dolio> For instance, if you wrote "do 5" you'd get that the type was 'Num (m a) => m a'
12:51:55 <dolio> Even though 'do 5' desugars to 5.
12:52:40 <mcstar> :t do 1
12:52:42 <lambdabot> Num a => a
12:53:36 <mcstar> i would have thought that anything after a do would result in the expression being an 'm a', if well formed
12:53:52 <dolio> Nope.
12:54:27 <rtpg> what's the point of that though?
12:54:33 <dolio> There is no point.
12:54:37 <mcstar> consistenc?
12:54:40 <mcstar> y
12:54:42 <nisstyre> the point is to have fun
12:54:44 <dolio> It's just a corner case that used to be wrong.
12:54:45 <Eduard_Munteanu> rtpg: a single statement desugars to itself
12:54:51 <rtpg> ah, ok
12:54:58 <dolio> At least, according to the specification.
12:55:33 <Eduard_Munteanu> @undo do { b <- f a; return (g b) }
12:55:33 <lambdabot> f a >>= \ b -> return (g b)
12:55:38 <mcstar> > :t do return 1 -- you heard me, haskell!
12:55:41 <lambdabot>  <hint>:1:1: parse error on input `:'
12:55:46 <Eduard_Munteanu> @undo do { b }
12:55:46 <lambdabot> b
12:55:49 <mcstar> :t do return 1 -- you heard me, haskell!
12:55:50 <lambdabot> (Monad m, Num a) => m a
12:56:25 <prasadi> Is there a way to convert SqlValue to Integer ? again, this is about Haskell and Sqlite3. I'm sorry if my question is not clear to you all. I'm very new to haskell
12:57:22 <triliyn> :t let don't _ = return () in don't (return 1)
12:57:24 <lambdabot>     Could not deduce (Monad m0) arising from a use of `return'
12:57:24 <lambdabot>     from the context (Monad m)
12:57:24 <lambdabot>       bound by the inferred type of it :: Monad m => m () at Top level
12:57:49 <geekosaur> prasadi, there's a whole explanation of how to work with SqlValue in http://hackage.haskell.org/package/HDBC-2.3.1.2/docs/Database-HDBC-SqlValue.html
12:59:54 <ibotty> @pl \l -> (lift . g) l >> go (f l)
12:59:54 <lambdabot> ap ((>>) . lift . g) (go . f)
13:00:21 <Eduard_Munteanu> prasadi: see safeConvert
13:00:38 <Eduard_Munteanu> Or 'convert'
13:00:42 <erisco> mkay I might be getting somewhere
13:00:54 <Eduard_Munteanu> http://hackage.haskell.org/package/convertible-1.0.11.1/docs/Data-Convertible-Base.html#v:convert
13:01:09 <mcstar> safeFromSql
13:01:41 <erisco> I have determined with ghci :step that my program gets stuck infinitely calculating == for Vertex (line 13), right after "saw" is called on line 31 http://lpaste.net/97347
13:01:53 <erisco> "saw" is equivalent to Set.insert, so this is confusing to me
13:02:17 <ibotty> hi all,
13:02:30 <Eduard_Munteanu> Er, I missed that, I went straight to the instances.
13:02:43 <ibotty> what's a nice name for a logging function besides log, which already is in prelude?
13:02:45 <Cale> erisco: Oh, you're putting values into a Set using an Ord instance which isn't a total ordering?
13:03:00 <Eduard_Munteanu> :t log
13:03:02 <lambdabot> Floating a => a -> a
13:03:04 <Eduard_Munteanu> Oh.
13:03:04 <erisco> Cale, Int is totally ordered no?
13:03:05 <Eduard_Munteanu> Heh.
13:03:10 <bmnxc> rasfar: I guess that happens because of 'readString'.
13:03:12 <Cale> Int is, yes
13:03:26 <erisco> then it should be okay I would presume
13:03:34 <Cale> But if you're putting Vertex a values in, the Ord instance you provided isn't a total ordering on Vertex a
13:03:51 <erisco> Cale, yes but I ensure that all ids are unique
13:03:59 <bmnxc> rasfar: Can't post an example, though.  Is there a version of mkAbsURI which could be used with runLA and hread?
13:04:02 <Cale> hmm
13:04:08 <Eduard_Munteanu> ibotty: you can hide Prelude's log though
13:04:23 <erisco> and even if they were not, then Set.insert would just bump the old value out, or keep the old one
13:04:28 <enthropy> > S.fromList [0/0, 0/0]
13:04:31 <lambdabot>  fromList [NaN,NaN]
13:04:36 <ibotty> i know. it's for a library... i don't feel like exporting conflicts.
13:04:46 <Cale> erisco: This program doesn't have a main, what do I do to make it loop?
13:04:50 <Eduard_Munteanu> Ah.
13:05:27 <erisco> :step (fmap vertexId $ vertices test)
13:05:31 <ibotty> hslogger uses the severity... but i want to be agnostic to a severity...
13:05:37 <Eduard_Munteanu> ibotty: perhaps doLog? Or logTo if it takes an argument?
13:05:38 <erisco> I annotated with the call stack
13:05:53 <ibotty> logTo looks about right
13:05:54 <Eduard_Munteanu> (a destination argument)
13:06:03 <ibotty> thanks
13:06:18 <ibotty> one of the two hard problems of cs solved again... in #haskell :D
13:06:48 <erisco> Cale, ah I discovered one logical error in my program
13:06:56 <erisco> I do not know if it is the cause of this, but I will correct that first
13:07:05 <Eduard_Munteanu> ibotty: I think naming projects before starting them is the more intractable problem. :P
13:07:36 <ibotty> oh. i plan to contribute to an existing project. i won't tackle that hornet nest just yet!
13:07:40 <Cale> erisco: I replaced your instances of Eq and Ord for Vertex with the derived ones and your program works.
13:07:44 <Eduard_Munteanu> :D
13:07:59 <Cale> ghci> vertices test
13:07:59 <Cale> [Vertex {vertexId = 0, vertexOut = [Edge {edgeTo = Vertex {vertexId = 1, vertexOut = [], vertexAccept = False}, edgeTransition = 'c'}], vertexAccept = True},Vertex {vertexId = 1, vertexOut = [], vertexAccept = False}]
13:07:59 <Cale> ghci> (fmap vertexId $ vertices test)
13:07:59 <Cale> [0,1]
13:08:02 <erisco> Cale, hm I do not understand
13:08:32 <Cale> Set relies on the Ord instance being a total ordering. If it's not, then anything can happen :P
13:08:53 <erisco> well how have I violated the total order as far as Set is concerned?
13:09:06 <rasfar> bmnxc: thanks for responding; I don't really know, it's been a while since I touched HXT (only 6 months but feels like 5 years have passed in the last 6 months!)
13:09:39 <mcstar> :i Ord
13:10:03 <mcstar> you should define compare i think
13:10:32 <mcstar> (but thats just from memory)
13:11:01 <Cale> Ah, compare test (Vertex 1 [] False) takes forever with your instance
13:11:35 <erisco> what have I done?
13:11:44 <epta> http://lpaste.net/97349 how to help hdevtools here?
13:11:56 <Cale> The default implementation of compare is
13:12:09 <Cale> compare x y = if x == y then EQ else if x <= y then LT else GT
13:12:19 <Cale> and the default implementation of <= is
13:12:25 <erisco> I changed my instance to define compare instead of < and it works
13:12:30 <mcstar> great
13:12:33 <Cale> x <= y = case compare x y of { GT -> False ; _ -> True }
13:12:44 <Cale> So, there was a loop between <= and compare
13:12:51 <erisco> d'oh
13:12:58 <mcstar> it happens :)
13:13:02 <Cale> You should generally always define compare
13:13:05 <mcstar> how did you not catch that with :step?
13:13:07 <erisco> good thing I did the stepping
13:13:13 <erisco> because I was looking in my program logic this whole time
13:13:20 <Cale> But I would just use the derived instances
13:13:38 <Cale> They're as efficient as your instance if you're ensuring that the vertices are unique
13:13:42 <Cale> (the ids)
13:13:49 <Cale> But they fail more gracefully
13:13:50 <mcstar> Cale: is it smart enough to start comparison on the fields in order?
13:14:18 <mcstar> hm, thats not really smart, but is it the way it happens?
13:14:30 <Cale> Yeah, the derived instance is lexicographic -- it compares the constructors (in the order you provided them) then each of the fields in turn if the last comparison was equal
13:14:51 <rasfar> bmnxc: there is setBaseURI and changeBaseURI in the same module as mkAbsURI, maybe that helps?
13:15:14 <erisco> Cale, mcstar yay thanks :D
13:15:19 <mcstar> :)
13:15:43 <erisco> I'm not really sure that seenFold is a practical abstraction
13:17:02 <Cale> For cyclic graphs, this representation will be weird
13:17:07 <bmnxc> rasfar: Haven't tried these. I'm currently trying to call readDocument properly. I'll let you know if I make the code work.
13:17:34 <erisco> Cale, you mean my Vertex and Edge definitions? I do not think it is weird. why do you think so?
13:18:07 <erisco> it is specifically for automatons
13:18:31 <Cale> Well, you'll be tying the knot to construct the cyclic graphs. Such graphs can be pretty awkward to manipulate (say, if you want to add a new vertex)
13:18:54 <erisco> Cale, yes, for that I can leverage the work I did yesterday with memoisation, hopefully
13:19:12 <Cale> You'll have to produce a new version of at least every other vertex, and the fact that you need to pay attention to the vertexIds to not loop infinitely can be inconvenient.
13:19:13 <erisco> for creating the list of vertices I do not need a Map though, just a Set, so I had to write different operations
13:19:32 <erisco> Cale, I have these algorithms taken care of. it is a matter of refactoring them nicely
13:20:06 <bmnxc> rasfar: Aha! Still fails. Will post the code soonish.
13:20:17 <Cale> Well, it's just that you end up paying linear costs in the size of the graph for more operations than you might otherwise like to
13:21:00 <mcstar> well, he assigns ids for the vertices by hand, so he doesnt plan on creating large graphs
13:21:04 <erisco> Cale, yes any changes to the graph will likely require total reconstruction, but there is no operation I do that would not likely result in that anyways
13:21:12 <Cale> okay
13:21:19 <erisco> mcstar, no I do it algorithmically. that was just a test case
13:21:26 <mcstar> and mine a joke
13:21:37 <erisco> oh :)
13:22:04 <Cale> http://cale.yi.org/share/Regular.hs -- you might take a look at what I did for NFAs here. This code isn't particularly intended to be efficient, but it's not terrible :)
13:22:12 <erisco> Cale, for tying the knot I found that the technique looks a lot like memoisation, using an approach where you thread the memo table through the computation
13:22:25 <erisco> Cale, this is my work on that yesterday where I implement fib http://lpaste.net/97351
13:23:03 <erisco> complete with an applicative-like interface :D
13:23:06 <Cale> (I end up doing some silly numerical tricks to ensure that vertex ids are disjoint though, which is kind of awkward)
13:25:54 <Cale> (I wrote that code when someone was bothering me for help with understanding some papers about differentiation of regular expressions and comparing regular languages for inequality.)
13:26:10 <erisco> @pl \x y z -> x + y + z
13:26:10 <lambdabot> ((+) .) . (+)
13:26:12 <Cale> The r and s examples at the end are actually from one of the papers :)
13:26:35 <mcstar> calculus of regular expressions?
13:26:41 <bmnxc> rasfar: http://dpaste.com/1517131/plain/ do is redundant, of course.
13:26:55 <mcstar> (you mentioned differentiation)
13:27:07 <erisco> Cale, that is interesting. I have not actually done any work on the construction bit yet
13:27:21 <erisco> I am primarily concerned with union, intersection, and concatentation
13:27:35 <roconnor> mcstar: regular expressions are the initial kleene algebra, ie an idempotent semiring with an asteration operation.
13:27:43 <roconnor> mcstar: you can do calculus on semirings
13:27:46 <Cale> mcstar: The derivative of a language L with respect to a symbol x is D_x L = {w : xw in L}
13:27:50 <erisco> (construction from a regex that is)
13:27:50 <rose> How can I convert a type from [IO (Either Failure ()] to IO [Either Failure ()] ?
13:28:30 <ibotty> :t sequence
13:28:33 <lambdabot> Monad m => [m a] -> m [a]
13:28:41 <roconnor> mcstar: essentially a derivitive is define to be a linear function with the following product law D(f * g) = Df * g + f * Dg
13:28:45 <Cale> mcstar: In the DFA/NFA representation this corresponds to replacing the start state(s) with their image under the transition function.
13:29:11 <mcstar> slowly guys, i will need my brain tomorrow, too
13:29:17 <Cale> In terms of regular expressions, you get something which looks quite a bit like the ordinary rules for differentiation, with some tweaks
13:29:23 <roconnor> Cale: tweeks?
13:29:28 <roconnor> tweaks?
13:29:39 <Cale> Yeah, you *don't* want the product rule that you just gave really :)
13:29:46 <roconnor> O_o
13:30:15 <Cale> Because the intention isn't to represent the language of words in L with one x deleted from them
13:30:18 <ibotty> rose: but there is certainly something nicer than using sequence if you restructure your code a bit
13:30:33 <Cale> You want the x to be deleted from the beginning
13:30:46 <Cale> (in order that this correspond to something useful in terms of the automata)
13:30:49 <roconnor> Cale: such abuse could only come from computer scientists
13:30:49 <rose> ibotty: I'm modifying documents in a db
13:31:26 <ibotty> rose: you might be using map when you could use mapM.
13:31:29 <ibotty> that's my guess
13:31:50 <ibotty> :t map
13:31:51 <ibotty> :t mapM
13:31:52 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
13:31:53 <lambdabot> (a -> b) -> [a] -> [b]
13:31:54 <Cale> (you can see my definition of d there)
13:32:16 <mcstar> i decided there is too great an impedance mismatch between me and those sentences for me to comprehend them
13:32:34 <Cale> The extra little bit is the 'map delta ps1'
13:32:57 <mcstar> but it is always weird to see differentiation in a discrete world of things
13:33:09 <Cale> If we just did ps1, that's a meaningful notion of derivative too, but it wouldn't correspond to what we wanted here :)
13:33:33 <Cale> mcstar: Okay, so let's take a combinatorial approach to understanding the derivative of x^3
13:33:55 <Cale> The idea of differentiating with respect to x is to delete an x in all possible ways
13:34:01 <rose> ibotty: that works. Thanks!
13:34:08 <ibotty> :)
13:34:09 <mcstar> Cale: what is x^3?
13:34:10 <Cale> If we start with xxx = x^3
13:34:16 <mcstar> ok
13:34:22 <rasfar> nice work bmnxc; HXT can be tough in my experience
13:34:25 <Cale> Well, let's not go with regular expressions yet
13:34:33 <mcstar> (i have no background in these 'grammars')
13:34:54 <bmnxc> Could anyone familiar with HXT explain why this code http://dpaste.com/1517131/plain/ doesn't output ["http://www.haskell.org/haskellwiki/HaskellWiki:Copyrights"]?
13:35:18 <Cale> Then deleting one of the three x's (i.e. replacing it with a 1) in all possible ways and summing the results gives:
13:35:27 <Cale> 1*x*x + x*1*x + x*x*1
13:35:32 <bmnxc> rasfar: Take a closer look, the code doesn't work properly.
13:35:35 <Cale> = 3 * x^2
13:35:48 * erisco mind asplodes
13:35:54 <mcstar> ok, so this is a purely symbolic analogy
13:35:59 <Cale> yeah
13:36:07 <mcstar> thats fine
13:36:40 <Cale> If you delete an x from f * g, then either you delete one from f and leave the g part alone
13:36:50 <Cale> or you delete one from g and leave the f part alone
13:36:59 <mcstar> yeah
13:37:07 <Cale> So D_x[f * g] = D_x[f] * g + f * D_x[g]
13:37:11 <Cale> which is the usual product rule
13:37:14 <adelbertc_> Hey, just installed the haskellmode vim plugin (http://projects.haskell.org/haskellmode-vim/) - when I do a simple main = putStrLn "Hello" and put my cursor under putStrLn and hit _t
13:37:16 <mcstar> thats basically what he wrote
13:37:19 <rasfar> bmnxc: well, should it print anything? I don't see an output stage (or whatever)...
13:37:20 <adelbertc_> i get "type not known"
13:37:20 <Cale> yes
13:37:21 <adelbertc_> any ideas?
13:37:32 <Cale> I just wrote it again for emphasis
13:37:33 <erisco> Cale, you should have taught me calc
13:37:41 <mcstar> i guess the order in which f and g appear doesnt matter
13:37:56 <roconnor> mcstar: it does matter
13:37:57 <mcstar> erisco: that is still not calculus
13:37:58 <Cale> mcstar: Well, if you're in a noncommutative ring, then maybe it does
13:37:59 <erisco> all I got were trig identities I have long forgotten
13:38:11 <Cale> In a commutative ring, it doesn't matter
13:38:45 <mcstar> so, where is the punch line? why do we not want the product rule?
13:38:49 <ski> roconnor : hm, if multiplication isn't commutative, couldn't you have both `d y / d x' and `d x \ d y' ?
13:38:49 <Cale> When discussing automata and languages, there's another sort of deletion which is more important
13:39:15 <bmnxc> rasfar: Yes, it should print the commented part. (Run it in ghci and type main.) But I want it to print a different thing (see above).
13:39:25 <Cale> Given a language L, we tend not to care so much about the language of words from L which have had an x deleted from them somewhere.
13:39:44 <roconnor> ski: the (+) is still commutative in a non-commuattive (semi)ring,
13:39:54 <ski> yes ?
13:40:00 <Cale> However, we *do* care very much about the language of words which are the tails of words in L that start with x
13:40:06 <roconnor> so Df * g + f * Dg = f * Dg + Df * g
13:40:12 <d3lxa> i've got a type that is Real, Fractional, etc and I need a Double, how do you convert? the aforementionned type is NominalDiffTime btw
13:40:24 <Cale> i.e. the thing which our DFA is going to match once we change its state according to a transition
13:40:26 * ski isn't sure what roconnor's point is
13:40:56 <roconnor> ski: so when we take a D(f * g) the relative order of f and g remain the same in the two terms being summed
13:41:02 <roconnor> ski: there is no second choice.
13:41:27 <roconnor> d3lxa: realToFrac
13:41:28 <rasfar> bmnxc: strange, for me it prints nothing
13:42:05 <Cale> So, to capture deletion from the beginning, we can define a function delta on regular expressions such that delta r = 1 if r is nullable (matches an empty string), and delta r = 0 otherwise
13:42:06 <rasfar> it prints nothing when compiled; but it does print with GHCi
13:42:15 <Cale> and then revise our product rule
13:42:32 <bmnxc> rasfar: Meh...
13:42:45 <ski> roconnor : well, if you're going to be removing `x's from strings in a language, you could remove from the start or the end
13:43:16 <d3lxa> roconnor: hey, great! thank you!
13:43:28 <Cale> D_x(f * g) = D_x[f] * g + delta(f) * D_x[g]
13:43:58 <roconnor> ski: Well, IMHO Cale's notion of removing a letter from the beginning of a language does not deserve the name dervitative, though I do not doubt that it is standard.
13:44:02 <rasfar> bmnxc: could you try setBaseURI? I am trying but can't yet figure out where/how to put it in...
13:44:15 <rasfar> granted it seems like that shouldn't be necessary
13:44:15 <Cale> So, this still looks somewhat like a product rule, but in order to delete an initial x from the g part, we need to know that f matched the empty string.
13:44:17 <mcstar> yeah he didnt really use dervitative though
13:44:22 <bmnxc> rasfar: Yeah, I've just had the same idea.
13:44:23 <mcstar> XD
13:44:32 <ski> roconnor : i think you can generalize it to take the derivative wrt a regular expression / language, and not just a symbol or a word
13:44:42 <Cale> ski: Indeed, you can :)
13:45:02 <bmnxc> rasfar: I thought it could be derived automagically. Perhaps I was wrong.
13:45:10 <mcstar> whats the difference between this derivative and the transition function?
13:45:13 * ski str gio123 was talking about derivatives of regular expressions a lot, implementing it in Prolog
13:45:13 <Cale> I was just sticking with a single symbol to begin with because that's a little easier to think about initially perhaps
13:45:16 <roconnor> ski: for Cale's notion, sure; but not for the standard notion of a dervative in a semiring.
13:45:24 <Cale> ski: Yeah, that's the guy ;)
13:45:34 <ski> Cale ?
13:46:03 <Cale> ski: He's the guy who bugged me to help him read papers about differentiating regular expressions for some reason :)
13:46:14 <Cale> and I wrote this code to try to explain things to him
13:46:34 <mcstar> Cale: f matched the empty string means, f didnt match?
13:46:51 <Cale> mcstar: no, it means it *succeeded* in matching the empty string
13:47:09 <mcstar> hm
13:47:14 <Cale> i.e. if we're talking about a DFA, the start state is also a terminal state
13:47:15 <ski> Cale : yeah, bugged me about such papers as well (and some others)
13:47:18 <rasfar> i think i had the right idea on my first advice, b/c
13:47:33 <rasfar> bmnxc: getBaseURI returns the current directory for me
13:47:54 <Cale> mcstar: For example, (abc)* will match the empty string, but abc will not.
13:47:58 <rasfar> now how to set it, in the context of your arrow? *headsmack*
13:48:35 <Cale> mcstar: If you look at my definition of nullable and delta in http://cale.yi.org/share/Regular.hs you should get the idea :)
13:49:14 <mcstar> i wouldnt, maybe in another lifetime
13:49:20 <Cale> mcstar: Zero is the regular expression which never matches (i.e. it's the identity for Sum/disjunction), One is the regular expression which only matches an empty input.
13:49:51 <ski> roconnor : hm, i'm not sure about the standard notion of a dervative in a semiring
13:49:58 <Cale> Sym x is the regular expression which matches exactly the single symbol x
13:50:01 <ski> (not sure about how it's defined)
13:50:01 <roconnor> ski: what are you not sure about?
13:50:19 <Cale> Sum rs will match whenever any of the regular expressions rs does
13:50:28 <ski> (and how it relates to derivatives in analysis, and perhaps differential forms)
13:50:37 <mcstar> Cale: first i should need to get comfortable with regular expressions, and language grammars (if thats what they are called) but i havent had the need to parse anything :(
13:50:47 <Cale> Prod rs will match whenever the input is the concatenation of strings matched by each of rs
13:50:51 <Cale> ah, okay
13:51:03 <Cale> If you've never seen regular expressions before, this would be weird :)
13:51:07 <bmnxc> rasfar: Now I have to figure out how to pass a string to it.
13:51:29 <mcstar> i didnt say, i've never seen them, but only used them in for grepping
13:51:37 <mcstar> -in
13:51:47 <Cale> ah, okay, I'm sort of assuming a context of having done the CS 101 stuff about regular languages and finite automata
13:52:02 <mcstar> nah, but sure, it is interesting stuff
13:52:26 <mcstar> maybe ill try a coursera course in the future
13:52:29 <Cale> mcstar: Basically, a regular expression is a notation for a particular set of strings.
13:52:36 <roconnor> ski: D is takes a function and returns a function such that D(f + g) = Df + Dg and D(c*f) = c*D(f) and D(f * g) = Df * g + f * Dg and I think that is it.
13:53:01 <roconnor> ski: maybe you need to add D(id) = const 1;  I don't remember if that can be derived.
13:53:05 <Cale> mcstar: A regular expression is nullable if that set of strings contains the empty string.
13:53:34 <Cale> Zero in my code is the notation for the empty set of strings, while One is the notation for the set containing just the empty string.
13:53:48 <mcstar> Cale: i was a little disappointed to find that regexes are really cumbersome when you need to parse real programming languages for example, and they would need non standard extensions to properly do that, like recursion.., and matching parens
13:53:58 <Cale> Yes
13:54:25 <roconnor> mcstar: regular expressions should not be used for language parsing.
13:54:34 <mcstar> thanks, i know that
13:54:36 <mcstar> now
13:54:46 <Cale> They're remarkably limited, but their saving grace is that they have a very efficient implementation mechanism. However, perl foregoes that and implements them in a way which involves an exponential worst case.
13:55:08 <rasfar> bmnxc:  runX $ constA "http://haskell.org" >>> setBaseURI >>> ...
13:55:15 <mcstar> but i guess perl has the most powerful implementation
13:55:17 <rasfar> :D
13:55:28 <Cale> (because it's tricky to integrate any sort of extensions with the efficient implementation mechanism that actual regular expressions give you)
13:56:22 <mcstar> roconnor: also i wonder, how many implemetations of prog. lang. sytanx hilighters use regexes
13:56:38 <Cale> mcstar: Essentially all of them
13:56:42 <roconnor> mcstar: all of them, and they are all wrong.
13:56:47 <mcstar> yeah i would have guessed so
13:56:56 <Cale> (Except e.g. when you're talking about Agda)
13:56:57 <mcstar> wrong and incorrect :)
13:57:14 <roconnor> yes
13:57:18 <Cale> Or Mathematica for that matter
13:57:23 <mcstar> Cale: emacs' agda-mode ?
13:57:26 <Cale> yeah
13:57:37 <mcstar> how is it different?
13:57:48 <Cale> Agda's syntax highlighting conveys information about semantics, and requires the file to compile.
13:59:24 <rasfar> bmnxc: i'd love to stay to hear the sweet sound of your undying gratitude, but sadly i gotta split
13:59:29 <bmnxc> rasfar: Haha, if I prepend it, the types don't match. But if I add it to the end of the >>> sequence, the whole thing throws away the needed part and prints ["http://haskell.org"].
14:00:08 <rasfar> oh ... um, with my suggestion?
14:00:13 <rasfar> b/c for me it outputs:  ["http://haskell.org/haskellwiki/HaskellWiki:Copyrights"]
14:00:27 <bmnxc> rasfar: Hm... Gotta check again.
14:00:33 <bmnxc> rasfar: Anyway, thanks for your help!
14:00:40 <rasfar>  runX $ constA "http://haskell.org" >>> setBaseURI >>> ... in case you missed
14:00:43 <rasfar> bye
14:01:34 <mcstar> wolfram is up to something again
14:01:49 <mcstar> he has released the wolfram language or whatnot
14:02:55 <mcstar> untyped knowledge based programming is very dangerous, i hear
14:02:56 <Cale> mcstar: e.g. if you have it set to Conor's colouring scheme, then it'll colour type constructors blue, data constructors brown/red, defined functions/values green, and locally bound variables purple
14:03:50 <mcstar> Cale: i think this is the first instance i hear that a source is colored by meaning and not by keywords
14:04:10 <Cale> oh, and keywords are black and underlined :)
14:04:32 <Cale> and most other bits of the syntax are just black
14:04:41 <Cale> (which isn't much, after all that!)
14:05:10 <mcstar> also, i wonder, in practice how big a difference does it make?
14:05:42 <Cale> Well, one little thing that Conor says is to beware the green slime in your types. :)
14:05:43 <mcstar> cause, the regular coloring technique is not that useless after all
14:06:41 <mcstar> Cale: thats basically your own functions!
14:06:57 <Cale> Well the ones which are defined by cases especially
14:07:38 <Cale> While sometimes it's unavoidable, you have to be a bit careful when you put those things in types, because the ability of the typechecker to see that types really match can then depend on precisely *how* you defined that function
14:07:54 <Cale> i.e. which case analysis you did, if there was a choice between more than one, as is the case for say addition
14:09:14 <Cale> This is the one feature of dependently typed programming which makes me a little bit sad, is that more than traditional functional programming, it breaks the abstraction of functions a bit.
14:09:42 <mcstar> more than?
14:09:57 <mcstar> ah, by traditional you mean with side effects?
14:10:05 <Cale> nah, I mean like Haskell :)
14:10:06 <mcstar> lisp,ocaml?
14:10:30 <enthropy> Cale: we need "partial type signatures" I guess
14:10:32 <mcstar> how does haskell break abstraction?
14:10:44 <mcstar> (of functions)
14:10:55 <Cale> Haskell is pretty good about the functional abstraction -- when you define a function, you tend not to care all that much how it's been defined apart from what results it gives. Though you will start to care if your program's performance sucks.
14:11:37 <Cale> But with dependent types, you have to look inside the definitions of functions a little more often than that, because in your types, you'll have the function applied to some expressions which involve variables
14:12:00 <enthropy> so long as you don't have to write any type signatures that isn't a problem though
14:12:09 <mcstar> it sounds like agda functions can operate on unevaluated expressions
14:12:20 <Cale> and the ability to evaluate the function by a step or two despite the presence of those variables will determine the ability of the typechecker to check that types actually match sometimes
14:12:32 <Cale> yes, in types they can be required to
14:12:56 <mcstar> are there type level functions?
14:12:57 <Cale> Not just unevaluated expressions, but expressions that can't be evaluated because they have unbound variables in them
14:13:00 <Cale> yes
14:13:05 <mcstar> are they isomorphic to regular functions?
14:13:13 <Cale> You can just use any function you've defined at the type level
14:13:13 <mcstar> maybe not the right word
14:13:26 <mcstar> are types values too?
14:13:27 <Cale> and types can be parameterised by values
14:13:31 <Cale> yes
14:13:45 <Cale> Types are values of type Set l for some level l.
14:14:26 <mcstar> is l analogous to *, * -> * ... ?
14:14:30 <Cale> Set l : Set (suc l)
14:14:40 <Cale> (that's a typing annotation)
14:14:55 <Cale> So, ordinary types are Set 0
14:15:55 <Cale> and then if they have a parameter which has type Set 0, they have to be at least Set 1, and so on
14:16:20 <ski> so `Set 0' is more or less `*'
14:16:23 <Cale> yeah
14:17:42 <Cale> If a : Set l and b : Set l' then a -> b : Set (max l l')  iirc.
14:18:00 <Cale> So things parameterised by types have to be of higher Set level
14:18:09 <Cale> This is to prevent infinite loops :)
14:19:10 <Cale> If you turn on a certain flag, it'll let you have Set : Set, and with that, you get inconsistency, you can prove anything and write programs which don't terminate
14:19:36 <Cale> http://www.cs.nott.ac.uk/~txa/g53cfr/l20.html/l20.html
14:20:28 <Cale> contr : ⊥  -- once you have this, you can prove anything at all using ⊥-elim.
14:20:32 <mcstar> Cale: i regularly do that in c++ without Set : Set
14:20:56 <Cale> Heh, you probably regularly do it in Haskell too :)
14:21:01 <Cale> :t fix id
14:21:04 <lambdabot> a
14:21:19 <epta> a?
14:21:27 <Cale> epta: any type at all :)
14:21:28 <triliyn> epta: it can be any type
14:21:34 <mcstar> Cale: i wish... i dont get to use haskell for real things
14:21:36 <triliyn> > 5 + (fix id)
14:21:41 <lambdabot>  mueval-core: Time limit exceeded
14:21:59 <Cale> It's an infinite loop, so what it produces can be of any type :)
14:22:05 <triliyn> id (id (id (id (id (id (id ...)))))))
14:22:12 <triliyn> (I didn't count the parentheses there)
14:22:24 <Cale> fix id = x where x = id x
14:22:26 <mcstar> 13
14:22:55 <mcstar> triliyn: you should enable show-paren-mode at least
14:23:00 <mcstar> or use paredit
14:23:41 <triliyn> mcstar: I'd love to use an emacs-based irc client so I could use all my lovely emacs thingies, but all the emacs IRCs I know of use hard newlines instead of line wrapping :(
14:25:50 <rtpg> has anyone ever tried writing some sort of DSL to generate typeclass instances for nicer type-level programming?
14:26:24 <rtpg> though I guess the population of people heavily invested into type-level stuff must not be that high
14:26:39 <triliyn> Someone linked something like that earlier today actually
14:26:42 <triliyn> Just a template haskell thing
14:26:53 <danilo2> Hello! If I remember correctly, there was a extension in Haskell, which allow me to declare aliases for type Constrains, am I right? I want to declare alias: "type LiftErr2' f a b c = (LiftErr f a sx, LiftErr sx b c)" and use it like "f :: LiftErr2 f a b c => ..."
14:26:54 <triliyn> https://typesandkinds.wordpress.com/2013/12/17/singletons-v0-9-released/
14:27:07 <rtpg> I keep on forgetting template haskell exists
14:27:58 <mcstar> triliyn: are you sure? i think it is a question of settings
14:28:25 <rtpg> triliyn, oh my
14:28:28 <triliyn> mcstar: I guess I could try again, but I think I looked at some of the settings and couldn't find a way to make it do something acceptable
14:28:31 <rtpg> this is amazing
14:28:34 <mcstar> triliyn: im not a fan of emacs based irc clients... im a hipster now, but i think when i tried erc it wrapped
14:28:39 <mcstar> or i could make it wrap
14:28:49 <triliyn> hmm
14:29:06 <triliyn> Well, part of the issue is that I want to maintain the separation between nicks and messages
14:29:17 <triliyn> I could get it to wrap, but not while keeping those things in separate columns
14:29:22 <triliyn> Also, I think this is kind of off topic
14:29:29 <triliyn> Perhaps I should join -blah
14:29:38 <mcstar> triliyn: maybe use different windows for nicks and messages?
14:29:57 <asdf1234> taking the gimp approach ...
14:30:22 <mcstar> as in, the gimp's sleeping?
14:30:45 <asdf1234> more like the gnu photoshop clone, but close enough xD
14:39:11 <danilo2> Hello! I've got a problem with -XConstraintKinds. When declaring such constrain: "type LiftErr2 f a b c = (LiftErr f a sx, LiftErr sx b c)", ghc complains: "Not in scope: type variable ‛sx’". Is it possible to decalre such constrains somehow? (sx is not used on the right of the constrain)
14:39:37 <enthropy> not really
14:39:59 <enthropy> type LiftErr2 f a b c = forall sx. (LiftErr f a sx, LiftErr sx b c) -- can work in a couple situations I think
14:41:10 <enthropy> you can also make a class: class (LiftErr f a sx, LiftErr sx b c) => LiftErr2 f a b c -- and a corresponding instance (which is undecidable I think)
14:41:26 <enthropy> or maybe that doesn't work: try it out
14:42:00 <danilo2> enthropy: It compiles, but when I'm trying to use it, it does not work, brb
14:45:04 <Eduard_Munteanu> Can you get decidable equality on types somehow?
14:45:30 <danilo2> enthropy: I know the naming in this example is terrible (sorry for that, temporary code): http://lpaste.net/97353
14:45:36 <Eduard_Munteanu> I can't seem to write a simple SplitOn at the type-level.
14:46:10 <enthropy> Eduard_Munteanu: splitting a promoted list?
14:46:22 <enthropy> it should be doable
14:46:24 <Eduard_Munteanu> enthropy: yes
14:46:31 <ski> perhaps danilo2 wanted `exists' ?
14:47:34 <enthropy> danilo2: so use the one that works?
14:48:18 <danilo2> enthropy: I can use the one that works, but I want to create a type alias for this ... if is it possible
14:48:29 <danilo2> eki: 'exists'?
14:48:35 <danilo2> ski: 'exists'?
14:48:48 <ski> instead of `forall' as suggested by enthropy
14:48:57 <enthropy> probably you can hide that type variable in a class / instance
14:49:06 <enthropy> but constraint kinds don't work that way
14:49:09 <ski> (just saying it's not obvious how you want to quantify/bind the tyvar)
14:49:17 <danilo2> ski: I just want to create alias for "(LiftErr Safe s1 sx, LiftErr sx s2 s3)"
14:49:28 <Eduard_Munteanu> enthropy: it seems recursing and checking for equality result in overlapping instances, e.g.  class SplitOn (a :: k) (ls :: [k]) (rs :: [k])   instance SplitOn a (x ': ls) rs => SplitOn a ls (x ': rs)   instance SplitOn a ls (a ': rs)
14:49:48 <ski> danilo2 : and `type LiftErr2 sx f a b c = (LiftErr f a sx, LiftErr sx b c)' (possibly with different parameter ordering) isn't what you want ?
14:50:08 <Eduard_Munteanu> I've tried a bunch of variation, I can't seem to get it done.
14:50:22 <Eduard_Munteanu> An even simpler thing neither: checking for an element.
14:50:31 <ski> danilo2 : if we saw the situation that you want to abbreviate with this, it could be easier to figure out how you want `sx' to be bound
14:50:33 <danilo2> ski: some kind yes, but "sx" should not be on the "input list", because it does not appear later
14:50:50 <enthropy> you need overlap to check equality
14:51:20 <enthropy>  instance Eq a b False; instance Eq a a True
14:51:26 <enthropy> those overlap
14:51:28 <Eduard_Munteanu> I'm not sure OverlappingInstances gets it working, I should try again.
14:51:35 <ski> danilo2 : are you attempting to abbreviate a type signature ? an instance declaration head, a class declaration head ? a method signature in a class declaration ? something else ?
14:52:03 <Eduard_Munteanu> enthropy: arguably this is an usecase for closed type families, but I'm merely using GHC 7.6.3.
14:52:13 <ski> Eduard_Munteanu : hm, maybe you can oleg it
14:52:29 <enthropy> Eduard_Munteanu: also you might need to add fundeps to class SplitOn
14:52:58 <enthropy> or otherwise make it so that the instance can be selected without having to know the result
14:53:13 <Eduard_Munteanu> Yeah.
14:53:23 <danilo2> ski: hm, ok, I'll try to explain it better :) Here is the code: http://lpaste.net/97353 . Look at the line 5. Its constrain is "(LiftErr Safe s1 sx, LiftErr sx s2 s3)" and the sx does not appear later. I'm just looking for a way (if it is possible), to declare alias for this constrain, but if "sx" does not apper in the signature, I was thinking about
14:53:32 <Eduard_Munteanu> I should try and see if OverlappingInstances allows some of those constructions.
14:53:59 <enthropy> instance (SplitOn a (x ': ls) rs, xrs ~ (x':rs)) => SplitOn a ls xrs
14:54:07 <danilo2> ski: something like "type LiftErr2 f a b c = (LiftErr f a sx, LiftErr sx b c)"
14:54:23 <FreeFull> enthropy: Can't you use ~ rather than a family and avoid inequality?
14:54:57 <enthropy> FreeFull: I dunno what you mean by "avoid inequality". There's no family here as far as I can tell
14:55:04 <Eduard_Munteanu> enthropy: in that case x doesn't occur in the instance head
14:56:41 <Eduard_Munteanu> Also, why don't type families take contexts?
14:56:52 <Eduard_Munteanu> Type family instances at least.
14:56:58 <enthropy> sure. That's -XUndecidableInstances territory, which isn't so bad (see Oleg's november monad reader article)
14:57:09 <danilo2> ski: So we can say, I'm trying to shorten the type signature
14:57:19 <enthropy> but it does overlap
14:57:42 <Eduard_Munteanu> It's a bit weird because I end up abusing classes + fundeps to essentially emulate type families.
14:58:38 <ski> danilo2 : ok, method type signature in a type class
14:59:22 <ski> danilo2 : ok, so you have
14:59:27 <ski>   liftf2 :: (LiftErr Safe s1 sx, LiftErr sx s2 s3) => (a -> b -> c) -> m1 (s1 a) -> m2 (s2 b) -> m3 (s3 c)
14:59:41 <ski> if this were a free-standing type signature, this would *really* mean
15:00:04 <ski>   liftf2 :: forall sx s1 s2 s3 a b c m1 m2 m3. (LiftErr Safe s1 sx, LiftErr sx s2 s3) => (a -> b -> c) -> m1 (s1 a) -> m2 (s2 b) -> m3 (s3 c)
15:00:42 <ski> however, since we're in a class declaration, some type variables are bound by the class head (namely the parameters of the class, `m1',`m2',`m3')
15:00:54 <ski> so, in this case, the signature really means
15:01:03 <ski>   liftf2 :: forall sx s1 s2 s3 a b c. (LiftErr Safe s1 sx, LiftErr sx s2 s3) => (a -> b -> c) -> m1 (s1 a) -> m2 (s2 b) -> m3 (s3 c)
15:01:08 <ski> danilo2 : ok, so far ?
15:01:20 <danilo2> ski: interesting, I didnt though about it like this. Yes, so far it is clear
15:02:11 <ski> `forall' expresses polymorphism, that `liftf2' promises to work for whatever actual types are selected by the caller for the tyvars `sx',`s1',`s2',`s3',`a',`b',`c'
15:02:38 <ski> now, you wanted to abbreviate the `(LiftErr Safe s1 sx, LiftErr sx s2 s3)' part (the context in the type signature)
15:03:10 <Eduard_Munteanu> enthropy: interesting, it works iff I enable OverlappingInstances. I guess there's no suggestion for it being rather controversial.
15:03:21 <Eduard_Munteanu> Thanks.
15:03:33 <ski> however, if you want to abbreviate that, you have to parameterize the abbreviation by *all* free type variables in the type (or constraint/context, as in this case)
15:03:36 <Eduard_Munteanu> *due to
15:03:38 <ski> this gives us
15:03:52 <ski>   type LiftErr2 sx f a b c = (LiftErr f a sx, LiftErr sx b c)
15:04:00 <ski> (possibly with a different ordering of the parameters)
15:04:04 <ski> this is similar to having to say
15:04:18 <ski>   f x y = x + y^x
15:04:21 <ski> and not just
15:04:25 <ski>   f y = x + y^x
15:04:37 <ski> if we want to "abbreviate" `x + y^x'
15:05:15 <nahiluhmot> ;w
15:05:28 <danilo2> ski: Ok, I see it, but could you tell a little more, why in such case cannot we write " LiftErr2' f a b c = forall sx. (LiftErr f a sx, LiftErr sx b c)" This would not mean the same ?
15:05:32 <ski> however, in this case, it would be possible that `x' is a globally defined variable in our module (or another module), or that `f y = x + y^x' is a local declaration (say inside a function definition), where `x' is in scope (perhaps it's a parameter of the outer function definition)
15:05:48 <ski> but generally, you can't have "outer bound" type variables
15:06:06 <ski> *except* in the case of method type signatures in a type class declaration
15:06:44 <ski> but in your case, the abbriviation declaration will not occur inside any code (like a class) where `sx' is already bound
15:06:52 <ski> which leaves you with two (main) options
15:07:02 <ski> (a) either bind `sx' yourself as a parameter, as in
15:07:06 <ski>   type LiftErr2 sx f a b c = (LiftErr f a sx, LiftErr sx b c)
15:07:26 <ski> (b) *or* *locally* bind `sx' in the type/context being abbreviated
15:07:32 <ski> let's go back to
15:07:36 <ski>   liftf2 :: forall sx s1 s2 s3 a b c. (LiftErr Safe s1 sx, LiftErr sx s2 s3) => (a -> b -> c) -> m1 (s1 a) -> m2 (s2 b) -> m3 (s3 c)
15:07:40 <ski> for a moment
15:07:46 <ski> i'll abbreviate it as
15:07:50 <danilo2> ski: I'm following you
15:08:07 <ski>   liftf2 :: forall sx s1 s2 s3 a b c. (LiftErr Safe s1 sx, LiftErr sx s2 s3) => ..a..b..c..s1..s2..s3..m1..m2..m3..
15:08:15 <asdf1234> that's a fun type signature
15:08:58 <ski> where `..a..b..c..s1..s2..s3..m1..m2..m3..' represents some code expression (here a type expression) that may depend on tyvars `a',`b',`c',`s1',`s2',`s3',`m1',`m2',`m3'
15:09:18 <danilo2> ski: yes, thats the standard form of writing such code
15:09:27 <ski> now, you can think of `forall a b. ..a..b..' as an abbreviation of `forall a. forall b. ..a..b..'
15:10:25 <ski> also, a logical laws says that `forall b. ..a.. -> ..a..b..', where `..a..' doesn't mention `b', is equivalent to `..a.. -> forall b. ..a..b..'
15:11:02 <ski> and another laws says that `forall b. ..a..b.. -> ..a..' is logically equivalent to `(exists b. ..a..b..) -> ..a..'
15:11:37 <ski> note that `forall b. ..a..b.. -> ..a..' really means `forall b. (..a..b.. -> ..a..)', btw
15:11:40 <ski> danilo2 : ok ?
15:11:52 <ski> should i explain more what i mean by `exists' here ?
15:11:58 <danilo2> ski: I'm thinking about one of the lines
15:12:19 <danilo2> ski: give me a second
15:12:58 <danilo2> ski: why "`forall b. ..a..b.. -> ..a..' is logically equivalent to `(exists b. ..a..b..) -> ..a..'" ?
15:13:03 <ski> consider
15:13:05 <ski> @type length
15:13:07 <lambdabot> [a] -> Int
15:13:15 <ski>   length :: [a] -> Int
15:13:30 <ski> or, with an explicit `forall' quantifier, explicitly binding the type variable `a'
15:13:34 <ski>   length :: forall a. [a] -> Int
15:14:08 <ski> intuitively, this says that for all/every actual type you replace `a' with, `length' has type `[a] -> Int'
15:14:14 <ski> e.g., from knowing that
15:14:15 <ski>   length :: forall a. [a] -> Int
15:14:17 <ski> is true
15:14:21 <ski> we can deduce that
15:14:27 <ski>   length :: [Int] -> Int
15:14:29 <ski> is also true
15:14:29 <danilo2> ski: so far everything clear
15:14:30 <ski> and also
15:14:43 <ski>   length :: [(b,String)] -> Int
15:14:58 <ski> where `b' is some type variable we haven't yet said what type it should stand for
15:15:06 <danilo2> ski: I've got a question
15:15:15 <ski> maybe we'll replace `b' by yet another type
15:15:31 <ski> or maybe we'll *generalize* on `b', getting to
15:15:34 <danilo2> ski: you have written "`forall b. ..a..b.. -> ..a..' is logically equivalent to `(exists b. ..a..b..) -> ..a..'" did you mean "`forall b. ..a..b.. -> ..a..' is logically implies that `(exists b. ..a..b..) -> ..a..'" ?
15:15:37 <ski>   length :: forall b. [(b,String)] -> Int
15:16:05 <ski> @type length :: forall b. [(b,String)] -> Int  -- showing that this signature is actually accepted
15:16:07 <lambdabot> [(b, String)] -> Int
15:16:37 * hackagebot postgresql-libpq 0.8.2.6 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.8.2.6 (LeonSmith)
15:16:41 <ski> danilo2 : no, it should be "logically equivalent"
15:16:59 <danilo2> ski: ok, I'm following you :)
15:17:40 <ski> generally, when removing a `forall a.' from `blah :: forall a. ..a..', one has to replace all occurances of `a' in `..a..' by the *same* type, say `A', getting `blah :: ..A..'
15:18:14 <ski> @type take
15:18:16 <lambdabot> Int -> [a] -> [a]
15:18:26 <ski>   take :: forall a. Int -> [a] -> [a]
15:18:29 <ski> so also
15:18:36 <ski>   take :: Int -> [Int] -> [Int]
15:18:38 <ski> and also
15:18:56 <ski>   take :: Int -> [(String,IO Double)] -> [(String,IO Double)]
15:18:58 <danilo2> ski: yes, this is clear
15:18:59 <ski> but not
15:19:04 <ski>   take :: Int -> [(String,IO Double)] -> [Int]
15:19:12 <ski> now, intuitively
15:19:15 <ski>   take :: forall a. Int -> [a] -> [a]
15:19:18 <ski> means the same as
15:19:26 <ski>   take :: Int -> forall a. [a] -> [a]
15:19:29 <ski> do you agree ?
15:19:54 <danilo2> ski: if this is take :: Int -> forall a. ([a] -> [a]) then yes
15:20:02 <ski> it doesn't matter if we pick a particular type to replace `a' with *before* or *after* applying `take' to its first argument (of type `Int')
15:20:12 <danilo2> ski: yes
15:20:27 <ski> *because* the type of that first argument doesn't mention `a', so we can "defer" the choice
15:20:38 <ski> `take :: Int -> forall a. ([a] -> [a])', yes
15:20:51 <ski> so, this is what i meant by
15:21:02 <ski> <ski> also, a logical laws says that `forall b. ..a.. -> ..a..b..', where `..a..' doesn't mention `b', is equivalent to `..a.. -> forall b. ..a..b..'
15:21:37 <ski> (and the point of `a' there was just to hint that the type expressions are allowed to mention other type variables than `b')
15:21:49 <ski> anyway, GHC prefers to rewrite from the
15:21:59 <ski>   take :: Int -> (forall a. ([a] -> [a]))
15:22:00 <ski> form to the
15:22:13 <ski>   take :: forall a. (Int -> ([a] -> [a]))
15:22:14 <ski> form
15:22:24 <ski> now, the other law
15:22:31 <ski> consider again
15:22:49 <ski>   length :: forall a. ([a] -> Int)
15:22:55 <erisco> that feeling when you have no idea why your code works
15:23:38 <ski> reading this : we first pick a concrete type to use for `a' (say `A'), then we apply the resulting function to a value of type `[A]', at which point the result has type `Int'
15:23:53 <ski> however, one can equally well accept
15:24:05 <ski>   length :: (exists a. [a]) -> Int
15:24:31 <ski> iow, we apply `length' to an argument expression where we have already *forgotten* the actual element type in the list
15:24:34 <ski> so, if we know
15:24:40 <ski>   "foobar" :: String
15:24:43 <ski> which is short for
15:24:44 <danilo2> ski: which means, that this signature is valid for some types, but not all (If Im reading it correectly)
15:24:47 <ski>   "foobar" :: [Char]
15:24:49 <ktosiek> can I put a pattern matching expression inline?
15:24:54 <ski> then, it's also true that
15:25:04 <ski>   "foobar" :: exists a. [a]
15:25:07 <ktosiek> I have a list of some type, and I want to only take elements matching a given pattern
15:25:12 <ski> by "forgetting" the element type
15:26:15 <ski> something having type `forall a. ..a..' means that it is polymorphic, it has type `..a..' for *all* types `a' -- we can decide which type to pick for `a', say `A', and then the value will have type `..A..' (each `a' occurance replaced by `A')
15:26:17 <geekosaur> ktosiek, perhaps you want filter?
15:26:52 <ski> something having type `exists a. ..a..' means that someone (the one constructing the value) has *already* selected a concrete type for `a', but won't tell us what it is !
15:26:53 <ktosiek> yes, but I don't know how to make a function that checks if value was created with given constructor
15:27:07 <ski> danilo2 : which signature ?
15:27:14 <ktosiek> I mean, I don't know how to create it in one line, as an argument for filter
15:27:26 <danilo2> ski: Ok, its clear now
15:27:36 <ski> consider the following derivation
15:27:44 <danilo2> ski: I did not know, that "`exists a. ..a..' means that someone (the one constructing the value) has *already* selected a concrete type for `a', but won't tell us what it is !"
15:27:59 <geekosaur> ktosiek, lambdas? filter (
15:28:00 <ski>   ("foo",id) :: (String,String -> String)
15:28:01 <geekosaur> er
15:28:15 <ski>   (12 :: Integer,show) :: (Integer,Integer -> String)
15:28:26 <geekosaur> > filter (\x -> x > 0) [(-2)..5]
15:28:30 <lambdabot>  mueval-core: Time limit exceeded
15:28:32 <ski> now, trying to put those two into a list is a type error
15:28:44 <geekosaur> probably did that wrong, damn negative numbers
15:28:44 <ski>   [("foo",id),(12 :: Integer,show)] :: ???
15:28:47 <ski> doesn't work
15:28:52 <ski> however, from
15:28:55 <ski>   ("foo",id) :: (String,String -> String)
15:28:57 <ski> we can derive
15:29:00 <geekosaur> the only issue is you get exactly one pattern from a lambda
15:29:03 <ktosiek> geekosaur: well, i have a type AorB = SomeA A | SomeB B
15:29:05 <ski>   ("foo",id) :: exists a. (a,a -> String)
15:29:08 <ski> and from
15:29:11 <ski>   (12 :: Integer,show) :: (Integer,Integer -> String)
15:29:13 <ski> we can derive
15:29:15 <L8D> src sequence
15:29:20 <L8D> @src sequence
15:29:20 <lambdabot> sequence []     = return []
15:29:20 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:29:20 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
15:29:23 <ktosiek> and a [AorB]
15:29:23 <ktosiek> and now I want to get only the As
15:29:27 <ski>   (12 :: Integer,show) :: exists a. (a,a -> String)
15:29:31 <ski> so now we get
15:29:35 <theOtherCat> hello there. I need a *little* help concering http://lpaste.net/97354. I don't quite get why compiling (with ghc) fails, i.e. why is main not capable of printing "Nothing" if erg fails?
15:29:51 <ski>   [("foo",id),(12 :: Integer,show)] :: [exists a. (a,a -> String)]
15:30:20 <ski> danilo2 : in this case, it's *crucial* that `exists a.' is *inside* the `[...]', rather than outside
15:30:48 <merijn> theOtherCat: That doesn't look write, is that really the entire code?
15:30:53 <merijn> theOtherCat: Because that should work...
15:31:00 <ski> `[exists a. ..a..]' means the type of lists where for each element there is some (hidden/unknown) type `a', such that that element has type `..a..'
15:31:16 <ski> the actual type that is hidden by `a' may be different for each element of the list
15:31:28 <danilo2> ski: ok, I see it. Hmm, I have no words to tell you how I'm thankful for such great and in depth explaination ...
15:31:46 <geekosaur> ktosiek, that's not really a pattern match type of thing, although a list comprehension might work
15:31:46 <ski> otoh, `exists a. [..a..]' means that there's a *single* (hidden/unknown) type `a', such that *all* the elements of the list has type `..a..'
15:31:56 <danilo2> ski: I have to tell you, that now I started to understand why existential datatypes work
15:32:02 <ski> so, going back to
15:32:12 <ski>   length :: (exists a. [a]) -> Int
15:32:26 <geekosaur> > [x | Just x <- y, y <- [Nothing, Just 3, Just 5, Nothing, Just (-2)]]
15:32:30 <lambdabot>  mueval-core: Time limit exceeded
15:32:34 <ski> this says that we can pass a list where we've forgotten the element type, to `length', and get back an `Int' result
15:33:04 <theOtherCat> complete listing at http://lpaste.net/97355
15:33:06 <geekosaur> no, I got those backwards
15:33:31 <ski> danilo2 : btw, note that if we know `blah :: (Integer,Integer -> String)', then we can go to `blah :: exists a. (a,a -> String)' (we could also go to `blah :: exists a. (a,Integer -> String)', though that may be less useful)
15:33:57 <ski> danilo2 : however, if we only know `blah :: exists a. (a,a -> String)', then we can't go to `blah :: (Integer,Integer -> String)'
15:34:32 <ski> danilo2 : compare this with how if we know `length :: forall a. ([a] -> Int)', then we can go to `length :: [String] -> Int'
15:34:34 <danilo2> ski: I understand it. But of course `blah :: exists a. (a,Integer -> String)' is not EQUIVALENT to `blah :: exists a. (a,a -> String)' ? It is some kind of "superset" ?
15:34:44 <merijn> theOtherCat: That doesn't have a line number for the error, though. According to the types "erg [1..10^6]" has type "Maybe Int" and "print" accepts any show, which should include Maybe Int
15:34:48 <merijn> :t print
15:34:51 <lambdabot> Show a => a -> IO ()
15:34:54 <ski> danilo2 : but if we only know `length :: [String] -> Int', then we can't get to ` we can't go to `blah :: (Integer,Integer -> String)'
15:35:00 <ski> from that
15:35:30 <ski> we can "remove/eliminate `forall's", and "introduce `exists's"
15:35:41 <haasn> geekosaur: [x | Just x <- [Nothing, Just 3, ...]]
15:35:47 <geekosaur> yeh
15:35:50 <theOtherCat> error is in 19:1 which is main = ...
15:35:50 <haasn> also, I'm wondering what exactly happened in your version
15:35:58 <haasn> y :: Expr so how did that end up type checking
15:36:02 <geekosaur> I'm lousy at list comprehensions, have generally ignored them
15:36:05 <merijn> theOtherCat: If I copy that code into my editor it compiles just fine...
15:36:09 <danilo2> ski: I understand it. I was thinking "exists" means something completely other than it really means
15:36:18 <ski> danilo2 : you could probably say that `blah :: exists a. (a,Integer -> String)' is more specific than `blah :: exists a. (a,Integer -> String)'
15:36:22 <haasn> :t y
15:36:24 <lambdabot> Expr
15:36:24 <merijn> theOtherCat: Are you sure you're compiling the right file?
15:36:26 <haasn> :t [x | x <- y]
15:36:27 <lambdabot>     Couldn't match expected type `[t0]' with actual type `Expr'
15:36:27 <lambdabot>     In the expression: y
15:36:27 <lambdabot>     In a stmt of a list comprehension: x <- y
15:36:37 <danilo2> ski: exactly - I was missing the word "specific"
15:36:38 <haasn> :t [x | Just x <- y, y <- [Just 3, Nothing]]
15:36:39 <ski> danilo2 : just like we can say that `length :: forall a. ([a] -> Int)' is a more *general* type signature for
15:36:39 <lambdabot>     Couldn't match expected type `[Maybe t0]' with actual type `Expr'
15:36:39 <lambdabot>     In the expression: y
15:36:39 <lambdabot>     In a stmt of a list comprehension: Just x <- y
15:36:42 <ski> @sec length
15:36:42 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:36:44 <haasn> weird
15:36:46 <ski> @src length
15:36:47 <lambdabot> Source not found. Where did you learn to type?
15:36:49 <ski> bah
15:36:53 <ski>   length [    ] = 0
15:37:02 <ski>   length (a:as) = 1 + length as
15:37:15 <ski> than `length :: [String] -> Int' is
15:37:38 <ski> (even those that latter would still be a *valid* signature for that definition of `length', it's not as general as the former one)
15:38:11 <danilo2> ski: thank you! I understand it :)
15:38:13 <erisco> I just realized why my program works :D
15:38:14 <theOtherCat> ohoh. no i wasn't. i'll now stand in the corner until i don't produce super-embarrassing problems ;)
15:38:20 <theOtherCat> thanks anyway
15:38:24 <ski> for `forall's, you can go from general to not as general -- and so you want to infer the most general, so that you can specialize it in as many non-general situations as possible
15:38:36 <merijn> theOtherCat: Don't worry, it happens :)
15:38:38 <danilo2> ski: I'll copy our talk and I'll show some people working with me, because I know, they will learn from this about "exists" a lot
15:38:42 <erisco> Cale, I just realized I do not have to worry about tying the knot in any of my algorithms
15:38:54 <erisco> Cale, thanks to an accident :D
15:38:55 <ski> for `exists', you can go from specific to not as specific ("abstract", maybe ?)
15:39:14 <ski> i'm not that sure about the story for attempting to infer `exists', though
15:39:21 <augur> ski: you've been gone for a while. :|
15:39:24 <merijn> theOtherCat: FYI, you can edit and load files into ghci in parallel (":l file.hs" to load, ":r" to reload the file to account for any newly saved changes)
15:40:11 <ParahSailin> im not sure how the use case for something like happy compares to the use case for monadic parsers
15:40:24 <ski> danilo2 : anyway, `forall a. (..a.. -> ...)' is logically *equivalent* to `(exists a. ..a..) -> ...' (where both `..a..' and `...' may contain other (free) tyvars than `a', but only the former may contain `a')
15:40:32 <Cale> erisco: Interesting :)
15:40:32 <erisco> ParahSailin, I am pretty sure Happy has a monadic interface
15:40:40 <erisco> Cale, lies you don't know why yet :P
15:40:57 <Cale> erisco: Well, maybe it's just because you never produce any graphs :P
15:40:58 <ParahSailin> erisco: so im not really clear at all what happy is
15:41:04 <danilo2> ski: I know I see it now. Anyway how can I repay you for this great explaination and time, you spend here explaining this to me ? I'm very thankful for that.
15:41:14 <merijn> ParahSailin: shift-reduce parser like lex/yacc produces
15:41:20 <merijn> AFAIK
15:41:24 <ParahSailin> shift-reduce?
15:41:31 <erisco> ParahSailin, it is a parser generator. ie, it takes a non-Haskell source file and dumps out a Haskell module containing the corresponding parser
15:41:35 <Cale> erisco: But I still like the Map V (Set V) sort of graph adjacency better in most cases ;)
15:41:37 <ski> danilo2 : in a sense, `forall a. Foo a b -> Bar b' being equivalent to `(exists a. Foo a b) -> Bar b' is similar to how `curried_foo :: A -> B -> C' is *almost* the same as `uncurried_foo :: (A,B) -> C'
15:41:41 <erisco> ParahSailin, the non-Haskell file is some configuration stuff + your grammar
15:41:52 <merijn> ParahSailin: See: https://en.wikipedia.org/wiki/Shift-reduce_parser
15:41:57 <ParahSailin> so it could generate something like Parsec parser from ebnf?
15:41:59 <ski> danilo2 : a few more things
15:42:02 <ski> consider
15:42:19 <erisco> Cale, complement, union, intersect, and concat were the operations I want to do on automatons
15:42:25 <erisco> Cale, which I am sure you are familiar with
15:42:26 <merijn> ParahSailin: Well, the thing is that it's trivial to produce fast and efficient parsers for shift+reduce parsing
15:42:29 <Cale> yeah
15:42:38 <merijn> ParahSailin: The downside is that they cannot parse all possible grammars
15:42:47 <erisco> Cale, and because they can be cyclic I was thinking that each one would have to keep track of already-visited vertices
15:42:54 <ParahSailin> merijn: ah i see, is shift-reduce LR grammar?
15:42:57 <erisco> Cale, but accidentally I just coded something which works and does not do that
15:43:06 <Cale> hm!
15:43:16 <Cale> Do you have a Set of states?
15:43:22 <merijn> ParahSailin: I forget which one, but yeah they can only handle some forms of recursion in the grammar
15:43:32 <ski>   data Blah = forall a. MkBlah a (a -> String)
15:43:39 <erisco> Cale, say in 'complement a' I do not keep track of visited states, and 'a' is cyclic
15:43:45 <erisco> Cale, then I will get an infinite graph
15:43:45 <ski> danilo2 : this is a so-called "existential data type"
15:43:51 <merijn> ParahSailin: Unlike parsec, but the downside of parsec is that in general top-down parsers tend to be less efficient than shift-reduce
15:43:52 <danilo2> ski: exactly
15:43:54 <ski> note that in this case
15:44:04 <ski>   MkBlah :: a -> (a -> String) -> Blah
15:44:06 <Cale> erisco: Well, yeah.
15:44:06 <merijn> ParahSailin: So the trade-off is parser speed vs grammar flexibility
15:44:06 <erisco> Cale, however, I can make the graph finite again with a separate function
15:44:09 <Cale> hm
15:44:19 <ski> is supposed to hold for *all* types `a'
15:44:20 <ski> iow
15:44:21 <erisco> Cale, which crawls the infinite graph and keeps track of the vertex ids it has already seen
15:44:22 <Cale> Oh, I suppose you can separate that part out, yes.
15:44:27 <ski>   MkBlah :: forall a. a -> (a -> String) -> Blah
15:44:37 <ski> now, we can't rewrite this into using `exists', directly
15:44:44 <ski> but if we change the definition slightly to
15:44:49 <erisco> Cale, yeah :D that greatly simplifies my code
15:44:50 <ski>   data Blah = forall a. MkBlah (a,a -> String)
15:44:52 <ski> we get
15:44:57 <ski>   MkBlah :: forall a. (a,a -> String) -> Blah
15:45:14 <ski> which now *can* (by the above logical equivalence law) be rewritten to
15:45:26 <ski>   MkBlah :: (exists a. a,a -> String)) -> Blah
15:45:31 <erisco> Cale, it is certainly better than the memo table hoop-la I was working on
15:45:37 <ski> and there's the existential in the "existential data type"
15:45:41 <Cale> cool
15:45:59 <ski> note that the data *constructor* `MkBlah' is *polymorphic* though, using `forall', not `exists'
15:46:06 <ski> which explains why there's a `forall' in
15:46:11 <ski>   data Blah = forall a. MkBlah (a,a -> String)
15:46:19 <ski> to introduce an "existential data type"
15:46:36 <danilo2> ski: Is it valid to write in Haskell "data Blah = forall a. MkBlah (a,a -> String)" ?
15:46:44 <ski> an alternative way of defining this type, which might look not as surprising to some would be using GADT syntax to define it :
15:46:47 <ski>   data Blah
15:46:48 <merijn> danilo2: With some extensions, yes
15:46:48 <ski>     where
15:46:57 <ski>     MkBlah :: forall a. (a,a -> String) -> Blah
15:47:08 <ski> or, indeed we can in this case omit the `forall', leaving it implicit
15:47:10 <ski>   data Blah
15:47:11 <ski>     where
15:47:13 <danilo2> ski, merin: ahh, ok sorry
15:47:16 <ski>     MkBlah :: (a,a -> String) -> Blah
15:47:23 <merijn> danilo2: Specifically ExistentialQuantification extension (GADTs lets you write syntactically different, but semantically identical things)
15:48:22 <ski> danilo2 : you need `{-# LANGUAGE ExistentialQuantification #-}' to define `data Blah = forall a. MkBlah a (a -> String)'
15:48:36 <ski> for the other version with `where', replace `ExistentialQuantification' by `GADTs'
15:49:22 <ski> danilo2 : so, `MkBlah' is polymorphic because it can hide *any* type `a' in the argument(s) we pass to it (`a' not occuring in the result type `Blah')
15:49:47 <danilo2> ski: yes, yes, I got it :)
15:50:03 <ski> danilo2 : however, when you *unpack* such a value, by pattern-matching, *then* you have no idea what `a' was used in this value you unpack, it's unknown/hidden
15:50:34 <ski> you only know there *exists* some type `a', so that all the components (constructor arguments) fit together by using the same `a'
15:50:35 <danilo2> ski: unless you specify it is instance of a class when declaring the existentil datatype
15:50:43 <ski> btw, here's another example of an existential data type
15:50:44 <danilo2> ski: and you can only use methods from this class on these values
15:51:18 <ski>   data QueueOps a = forall q. Q {empty :: q,enqueue :: a -> q -> q,dequeue :: q -> Maybe (q,a)}
15:51:30 <erisco> Cale, did you see any value in the memoisation technique I pastied earlier?
15:51:40 * hackagebot graph-serialize 0.2 - Serialization of data structures with references.  http://hackage.haskell.org/package/graph-serialize-0.2 (ThomasSchilling)
15:51:42 <erisco> there is some work to be done on it still but the rough idea was there
15:51:47 <erisco> in the fib example
15:51:50 <ski> note that this is *not* OO-style -- you use this by opening it once, then in thatr scope constructing all the queues you want yo use
15:51:55 <ski> an OO-variant would be
15:52:18 <ski>   data Queue a = forall q. Q {this :: q,empty :: q,enqueue :: a -> q -> q,dequeue :: q -> Maybe (q,a)}
15:52:31 <Cale> erisco: I might've missed the details, are you talking about something similar to data-memocombinators?
15:53:02 <Cale> http://hackage.haskell.org/package/data-memocombinators-0.5.1/docs/Data-MemoCombinators.html
15:53:16 <ski> danilo2 : anyway, imho, `ExistentialQuantification' is a bit of a misnomer, since it doesn't enable the `exists' syntax. it enables the "existential data type" syntax above (written with `forall')
15:53:48 <erisco> Cale, is that module based on tries?
15:53:49 <BMeph> ski: Why wouldn't is be: 'dequeue :: q -> Maybe (Queue a, a)'? :)
15:54:04 <Cale> erisco: sort of
15:54:09 <ski> `ExistentialComponents' might be a better name for it, cf. `PolymorphicComponents' which allow `data Blah = B (forall a. [a] -> [a] -> [a])' e.g.
15:54:11 <Cale> erisco: they're implicit though :)
15:54:30 <erisco> Cale, the approach I was interested in was passing a memo table through the computation
15:54:31 <Cale> (Implicit in the structure of the programs in memory)
15:55:04 <erisco> which gives something like this http://lpaste.net/97351
15:55:15 <ski> (whether the `forall' is "inside" or "outside" the data constructor in the `data' declaration is a *huge* difference -- in the "outside" case, it corresponds to an `exists'-wrapped argument type, in the "inside" case, it corresponds to a `forall'-wrapped argument type)
15:55:17 <erisco> the exact operators are not complete or quite right yet
15:55:19 <erisco> but the idea is there
15:55:19 <ski> danilo2 : ok ?
15:55:41 <Cale> erisco: oh, I see
15:55:51 <erisco> Cale, this gives explicit control of the memo table
15:55:55 <danilo2> ski: you are right. "ExistentialComponents" sounds a lot better for what you were tlaking about. The apperance of "dorall" - inside / outside - is clear to me
15:56:26 <Cale> erisco: Yeah, data-memocombinators is kind of more implicit than this. It abuses the fact that we have a lazy evaluator which isn't going to evaluate a bound variable more than once in order to store the tables
15:56:33 <ski> danilo2 : do you know about higher-ranked types ?
15:56:48 <ski> danilo2 : also, GHC doesn't support the `exists' syntax (though istr LHC does, for some restricted cases at least) -- however, i still think it's useful to *think* at the level of `exists' rather than "existential data type"
15:56:59 <erisco> Cale, yes I am aware of that approach if it is anything like untrie . trie as described by conal
15:57:15 <ski>   data Blah = B (forall a. [a] -> [a] -> [a])
15:57:17 <ski> means that
15:57:24 <ski>   B :: (forall a. [a] -> [a] -> [a]) -> Blah
15:57:45 <ski> means that `B' is *not* polymorphic. it takes a polymorphic function as an argument, which is very different
15:57:47 <erisco> Cale, I was wondering if you saw any value in this type of approach, though
15:58:01 <ski> one can also have functions that take polymorphicm stuff as arguments
15:58:12 <ski> these are called rank-2 types
15:58:14 <danilo2> ski: I know rankNTypes extension, I have used it once or twice and I know something about higher-ranked types - but I cannot tell you I know everything about them
15:58:39 <ski> you could also have a function which takes a function which takes a polymorphic thing as argument, that would be rank-3, &c.
15:58:51 <ski> `(forall a. ..a..) -> ...' is rank-2
15:58:58 <ski> `((forall a. ..a..) -> ...) -> ...' is rank-3
15:59:04 <erisco> Cale, I put so much work into designing it and eta-reducing the memo table that it has to be worth something right? :P
16:00:14 <danilo2> ski: heh, I remember I was thinking about this "forall" when I was reading about rankNTypes. Now Its super clear :)
16:00:45 <danilo2> ski: I only wish GHC could infer types, which would be rankN (n>1) in some cases
16:00:59 <ski> danilo2 : my <http://lpaste.net/10060> has an example of rank-2, where it's used to hide an implementation detail of the function `traceFix' (namely that it uses the `Writer w' monad), hiding that from the type of the function, so that the caller can't make use of that information when passing a callback function as argument to it
16:01:24 <ski> danilo2 : anyway, back to
16:01:27 <ski>   liftf2 :: forall sx s1 s2 s3 a b c. (LiftErr Safe s1 sx, LiftErr sx s2 s3) => ..a..b..c..s1..s2..s3..m1..m2..m3..
16:01:31 <danilo2> ski: your lpaste is empty :(
16:01:58 <ski> danilo2 : hm, works here (perhaps you copied the `<' or the `>' chars into the URL field ?)
16:02:14 <danilo2> ski: Oh, heh, ofc :)
16:02:29 <ski> because you don't want `sx' to appear in the abbreviation of `(LiftErr Safe s1 sx, LiftErr sx s2 s3)' (while `s1',`s2',`s3' may appear in that abbreviation)
16:02:40 <danilo2> ski: I've clicked it - but the ">" was interpreted as part of the address :)
16:02:47 <ski> we must *rewrite* the signature so that `sx' is *locally* *bound* in the abbreviated part
16:02:52 <ski> from
16:02:54 <ski>   liftf2 :: forall sx s1 s2 s3 a b c. (LiftErr Safe s1 sx, LiftErr sx s2 s3) => ..a..b..c..s1..s2..s3..m1..m2..m3..
16:02:57 <ski> we get
16:03:06 <ski>   liftf2 :: forall s1 s2 s3 a b c. forall sx. (LiftErr Safe s1 sx, LiftErr sx s2 s3) => ..a..b..c..s1..s2..s3..m1..m2..m3..
16:03:10 <ski> and from there we get
16:03:21 <ski>   liftf2 :: forall s1 s2 s3 a b c. (exists sx. (LiftErr Safe s1 sx, LiftErr sx s2 s3)) => ..a..b..c..s1..s2..s3..m1..m2..m3..
16:03:32 <ski> and so we see that you really wanted the abbreviation
16:04:05 <ski>   type LiftErr2 f a b c = exists sx. (LiftErr f a sx, LiftErr sx b c)
16:04:19 <danilo2> ski: makes perfect sense
16:04:39 <ski> with `exists' instead of `forall' (which is what enthropy suggested, which would type-check, but wouldn't be what you wanted)
16:05:13 <ski> danilo2 : now, since there is no `exists' keyword in GHC, there's a different question about how to attempt to *implement* this in GHC (if possible)
16:05:36 <ski> but i think it helps to determine *what* you want, before trying to do it -- at least if it's not immediately obvious how to do it
16:07:43 <danilo2> ski: thank you very much for all the info. I see why the "exists" would not work here and I need something other. I think I can solve this problem a lot simplier that I was trying to do - instead of simplifying the constrain, introduce another type class and then the "sx" would not appear even on constrain list
16:08:30 <ski> (if `exists' occurs to the left of a `->', you can rewrite it to a `forall'. otherwise (e.g. if it's in a "result type", or say inside `IO' or `[]' or something, you have to wrap in an auxilary "existential data type" -- or maybe write in CPS)
16:09:02 <ski>   class (LiftErr f a sx, LiftErr sx b c) => LiftErr2 f a b c
16:09:03 <ski> ?
16:09:10 * ski can't recall atm whether that works
16:09:19 <ski> in any way, that would logically mean
16:09:23 <danilo2> ski: anyway, going back to what you have talked about : I really do not know how to thank you for your time. It clarified to me a lot of things - this is one of those "Haskell ++" days for me :)
16:09:30 <danilo2> ski: I was thinking about something else
16:09:36 <ski>   class forall f a b c sx. (LiftErr f a sx, LiftErr sx b c) => LiftErr2 f a b c
16:09:36 <ski> iow
16:09:40 <ski>   class forall f a b c sx. ((LiftErr f a sx, LiftErr sx b c) => LiftErr2 f a b c)
16:09:43 <ski> iow
16:09:56 <ski>   class forall f a b c. (exists sx. (LiftErr f a sx, LiftErr sx b c)) => LiftErr2 f a b c
16:10:08 <ski> which seems close to what you wanted
16:10:14 <danilo2> ski: exactly
16:10:29 <ski> hmm ..
16:10:38 <ski> actually possibly a better attempt is
16:10:42 <danilo2> ski, but I'm able to do it. look
16:10:46 <ski>   class LiftErr2 f a b c
16:10:56 <ski>   instance (LiftErr f a sx, LiftErr sx b c) => LiftErr2 f a b c
16:11:17 <ski> (since otherwise you'd have to declare instances of `LiftErr2', it doesn't happen automatically)
16:11:42 * hackagebot postgresql-simple 0.4.0.1 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.4.0.1 (LeonSmith)
16:12:16 <danilo2> ski: it should work I think, but I've got other idea to solve it. But it is connected with restructuring the type classes in other parts of the code and I have to try it.
16:12:42 <danilo2> Anyway if I get thius idea working, I'll write it back to you - if not, I will not bother you with it :)
16:12:54 <lightquake> anybody know how to turn a TyThing into a Type using the GHC API?
16:13:03 <lightquake> er, a TyCon
16:13:25 <ski> danilo2 : btw, in case you've used stuff like `int foo(void *env,char (*callback)(void *env,int n,char *s),int k);' or `struct {void *env; char (*callback)(void *env,int n,char *s); }' in C, then that's *really* attempting to simulate `exists' by unsafe casts
16:13:37 <lightquake> oh, apparently it's flip TyConApp [], or so
16:14:13 <ski> (well, it's attempting to simulate closures, by means of attempting to simulate `exists')
16:15:30 <ski> danilo2 : anyway, have fun
16:15:59 <danilo2> ski: I hate (void*) :) I think everybody here hate (void*) too ;) I understand why existential datatypes exist and they have perfect sense - everytime I think about them I think about interfaces in golang
16:16:23 <danilo2> ski: Again, thank you for all the help! I think I'll start spending more time on IRC and try to answer some questions I would know answers to. I do not know if there is another way to "repay" for the help I'm getting on irc :)
16:17:22 <ski> one'd want something like `struct {exists T; T *env; char (*callback)(T *env,int n,char *s); };' or `template<T> int foo(T *env,char (*callback)(T *env,int n,char *s),int k);' (where `template' is roughly code for `forall', here) in those cases
16:18:10 <ski> danilo2 : sounds like a good idea :)
16:20:00 <danilo2> ski: heh :) By the way - if you havent seen this - take a look at the "interfaces" in google's go language - they are **exactly** existential datatypes but in "java" or "c++" world (without some of the dangers of void* 's) :)
16:20:23 <ski> "Existential Types for Imperative Languages" by Dan Grossman in 2002-04 at <http://www.cs.washington.edu/homes/djg/papers/exists_imp.pdf>
16:20:27 <ski> "Quantified Types in an Imperative Language" by Dan Grossman in 2006-05 at <http://www.cs.washington.edu/homes/djg/papers/qtil.pdf>
16:20:41 <ski> those papers might be interesting, if you're curious about `void *' and quantification
16:21:02 <pranz1> ski: slightly OT, but why is there different uses for "forall" depending on what language extension you use? Some of them don't seem correlated in any way
16:21:08 <ski> (they are in the context of the language Cyclone. iiuc, BitC and Rust have some similar stuff)
16:21:35 <ski> pranz1 : `forall' means "for all" in all the uses
16:21:46 <ski> but different placements of it give different effects
16:22:00 <danilo2> ski: thank you! I love such papers! :) I would read them for sure If I get a little free time
16:22:03 <ski> different extensions allow using `forall' in different places
16:22:14 <danilo2> ski: and now we get some holidays so I will read them! :)
16:22:19 <ski> in the
16:24:07 <ski>   data SetOps a = forall s. S {empty :: q,singleton :: a -> s,elem :: a -> s -> Bool,union,intersect,difference :: s -> s -> s}
16:24:11 <ski> which i'll desugar to
16:24:22 <qfjp> I have a fairly stupid question
16:24:34 <qfjp> is there a way to get ghci to recognize keybindings for multiple keys
16:24:41 <ski>   data SetOps a = forall s. S (a,a -> s,a -> s -> Bool,s -> s -> s,s -> s -> s,s -> s -> s)
16:24:49 <qfjp> like, bind ab escape
16:24:56 <ski> the data *constructor* `S' *is* polymorphic
16:25:12 <ski> for every type `s', `S' has the following signature
16:25:26 <ski>   S :: (a,a -> s,a -> s -> Bool,s -> s -> s,s -> s -> s,s -> s -> s) -> SetOps a
16:25:29 <ski> iow
16:25:35 <ski>   S :: forall s. (a,a -> s,a -> s -> Bool,s -> s -> s,s -> s -> s,s -> s -> s) -> SetOps a
16:25:38 <ski> is true
16:25:39 <ski> or
16:25:42 <ski>   S :: forall a s. (a,a -> s,a -> s -> Bool,s -> s -> s,s -> s -> s,s -> s -> s) -> SetOps a
16:25:50 <ski> if you want to be explicit about the `a' as well
16:26:21 <danilo2> ski: I discovered it before, that If I do not write "a" explicit in such case it is automatically "there"
16:26:51 <danilo2> ski: I'll read the code you've pasted in lpaste - thank you once again :)
16:26:53 <ski> pranz1 : so `S' being polymorphic in what *representation* type `s' for the set (of `a's) that it accepts, *while* not mentioning `s' in the result type `SetOps a', means that calling `S' *forgets* the actual type used for `s'
16:27:20 <ski> pranz1 : and as i attempted to explain to danilo2 (amongst other things) above (for maybe an hour ?)
16:27:24 <ski>   S :: forall a s. (a,a -> s,a -> s -> Bool,s -> s -> s,s -> s -> s,s -> s -> s) -> SetOps a
16:27:27 <ski> is logically equivalent to
16:27:37 <ski>   S :: forall a. (exists s. (a,a -> s,a -> s -> Bool,s -> s -> s,s -> s -> s,s -> s -> s)) -> SetOps a
16:27:45 <ski> and there is your existential quantification hiding
16:27:52 <pranz1> ah
16:27:56 <ski> in general, if you have a constructor of type
16:28:03 <pranz1> Maybe I should scroll and read up a bit then
16:28:05 <pranz1> seems interesting
16:28:22 <ski>   MkBlah :: forall a s. ..a..s.. -> ..a.. -> Blah a
16:28:37 <ski> then this really means
16:28:40 <ski>   MkBlah :: forall a s. (..a..s.. -> ..a.. -> Blah a)
16:28:45 <ski> and this is equivalent to
16:29:01 <ski>   MkBlah :: forall a. (exists s. ..a..s..) -> ..a.. -> Blah a
16:29:26 <ski> the `forall a' just means that `MkBlah' is polymorphic in `a'
16:29:30 <danilo2> ski, pranz1: for over an hour - this was incredible talk :)
16:30:01 <ski> byt if you call `MkBlah' on an argument where `a' is actually `MyA', you'll get `Blah MyA', so the value (well, type :) isn't "forgotten"
16:30:11 <ski> otoh, `s' is not in the result type, so `s' is forgotten
16:30:28 <ski> so, the *argument* of the constructor (aka component) has an existential type
16:30:43 <ski> pranz1 : otoh, imagine the following
16:31:24 <ski>   data MonadDict m = MD {unit :: forall a. a -> m a,bind :: forall a b. m a -> (a -> m b) -> m b}
16:31:29 <ski> which i'll desugar to
16:31:41 <ski>   data MonadDict m = MD (forall a. a -> m a) (forall a b. m a -> (a -> m b) -> m b)
16:31:51 <ski> the type signature of `MD' is
16:32:04 <ski>   MD :: (forall a. a -> m a) -> (forall a b. m a -> (a -> m b) -> m b) -> MonadDict m
16:32:17 <ski> or, if you want to be explicit about `m'
16:32:24 <ski>   MD :: forall m. (forall a. a -> m a) -> (forall a b. m a -> (a -> m b) -> m b) -> MonadDict m
16:32:45 <ski> in this case, the *arguments* of the constructs (aka components) have *universal* (`forall') type
16:33:46 <ski> meaning they store a polymorphic value (function in this case) -- as opposed to storing a specific type with a specific (undisclosed) choice for the quantified type variable `s' in `exists s.' above
16:34:53 <chrisblake> is there a more succicent way to represent: ['0'..'9'] ++ ['A'..'Z'] ++ ['a'..'z'] (a list with all alphanum characters)?
16:35:10 <ski> (a value of a `MonadDict m' is akin to an `instance Monad m where ...', except that it's first class, you can pass ity around, and select amongst several ones which one you want to use -- you can use another class instead of `Monad', but `Monad' was the first one i thought of which had polymorphic methods)
16:35:35 <erisco> chrisblake, no: http://www.asciitable.com/
16:35:53 <ski> > filter isAlphaNum ['0' ..]  -- hmm
16:35:56 <lambdabot>  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\178\179\...
16:36:09 <joneshf-laptop> hey, can someone explain this to me?
16:36:18 <joneshf-laptop> :t pure "something"
16:36:19 <lambdabot> Applicative f => f [Char]
16:36:21 <chrisblake> erisco: the problem is that there are other things in the middle
16:36:22 <ski> (actually i meant to start at  '\0'  )
16:36:32 <erisco> chrisblake, that is why I said "no" :)
16:36:35 <joneshf-laptop> what does that even mean?
16:36:38 <chrisblake> erisco: oh okay :)
16:36:43 <bennofs> joneshf-laptop: Do you understand Functors?
16:36:53 <joneshf-laptop> i'd like to think so
16:37:04 <ski> @type pure "something" :: Maybe String
16:37:06 <lambdabot> Maybe String
16:37:08 <chrisblake> > filter isAlphaNum ['0'..'z']
16:37:09 <ski> @type pure "something" :: [String]
16:37:10 <lambdabot>  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
16:37:10 <lambdabot> [String]
16:37:18 <chrisblake> so there *is* a way
16:37:21 <chrisblake> thanks, ski :)
16:37:22 <ski> @type pure "something" :: Either (Double -> Bool) String
16:37:23 <lambdabot> Either (Double -> Bool) String
16:37:24 <joneshf-laptop> whati mean though, is who's pure is it using?
16:37:25 <ski> > pure "something" :: Maybe String
16:37:28 <lambdabot>  Just "something"
16:37:30 <ski> > pure "something" :: [String]
16:37:31 <lambdabot>  ["something"]
16:37:33 <ski> > pure "something" :: Either (Double -> Bool) String
16:37:34 <lambdabot>  Right "something"
16:37:35 <bennofs> joneshf-laptop: that depends on where you use it
16:37:40 <erisco> @src isAlphaNum
16:37:40 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:37:46 <erisco> sorry lambdabot
16:37:49 <joneshf-laptop> > pure "something"
16:37:51 <lambdabot>  No instance for (Control.Applicative.Applicative f0)
16:37:51 <lambdabot>    arising from a use of `e_1'
16:37:51 <lambdabot>  The type variable `f0' is ambiguous
16:37:51 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
16:37:51 <lambdabot>  Note: there are several potential instances:
16:37:59 <ski> chrisblake : not sure it'd work in EBCDIC, though ;)
16:38:03 <joneshf-laptop> oh, so ghci is just sending me down the wrong path
16:38:06 <bennofs> joneshf-laptop: This error tells you that GHC doesn't know which pure to use
16:38:06 <erisco> chrisblake, yeah but isAlphaNum is uses the same ranges under the hood
16:38:23 <danilo2> joneshf-laptop: pure is only a method cal. It is defined as function in Applicative
16:38:26 <danilo2> joneshf-laptop: look
16:38:35 <joneshf-laptop> what contextis ghci in? IO or something?
16:38:45 <danilo2> joneshf-laptop: http://en.wikibooks.org/wiki/Haskell/Applicative_Functors
16:38:48 <chrisblake> what's EBCDIC?
16:38:49 <bennofs> joneshf-laptop: the GHCi prompt will force all expressions to be of type IO a when they can. So pure "something" at the ghci prompt will evaluate as pure "something" :: IO ()
16:38:56 <ski> joneshf-laptop : it didn't know which particular `f' you want to use when entering it in GHCi like that
16:38:59 <danilo2> joneshf-laptop: it is valid for ALL Applicative Functors
16:39:03 <joneshf-laptop> bennofs, gotcha, thanks
16:39:05 <bennofs> Ehm, pure "something" :: IO a I mean
16:39:27 <danilo2> joneshf-laptop: IO is instance of Applicatibve, so "pure" is valid for it. If you look at the pure type
16:39:31 <roboguy_> bennofs: wouldn't it be IO String?
16:39:33 <ski> joneshf-laptop : in most actual cases you write stuff "interfacing" (e.g. being a subexpression of) other pieces of code, and then this ambiguity wouldn't arise
16:39:53 <danilo2> joneshf-laptop:  Applicative f => pure :: a -> f a
16:39:59 <ski> chrisblake : <http://en.wikipedia.org/wiki/EBCDIC>
16:40:07 <bennofs> roboguy_: yes, that's what GHC uses then
16:40:10 <danilo2> joneshf-laptop: you see, that pure "packs" a value inside an Applicative "thing"
16:40:12 <andyland> Hi! I just found this on reddit: https://gist.github.com/quchen/5280339 Seems like you guys are rather awesome :)
16:40:14 <danilo2> for example
16:40:18 <ski> chrisblake : an (old) character encoding system, alternate to ASCII
16:40:18 <roboguy_> bennofs: that's what I mean, yeah
16:40:30 <danilo2> joneshf-laptop: if you write "pure 1 :: [Int]" you get "[1]"
16:40:44 <ski> chrisblake : probably still used on some IBM servers, i suspect
16:40:45 <bennofs> roboguy_: but the GHCi prompt doesn't force the a to be of some type, it only says that it's in IO, not what result type it has (that's what I wanted to show by using IO a instead of IO String)
16:40:46 <joneshf-laptop> i think i asked my question too generally ;)
16:40:48 <danilo2> joneshf-laptop: because list is instance of applicative
16:41:22 <andyland> I've got a bit of lisp knowledge through emacs lisp, so today is the day I'm gonna learn haskell
16:41:34 <roboguy_> bennofs: wait, I would have thought that pure "something" would specifically be IO String in ghci, not forall a. IO a
16:41:36 <joneshf-laptop> bennofs, danilo2, ski thanks!
16:41:49 <quchen> andyland: It would make my day if that chatlog made someone start learning Haskell :-) LYAH is a good start.
16:42:18 <bennofs> roboguy_: it will, because pure :: a -> m a. Being at the GHCi prompt only gives m ~ IO. Then, later, GHC notices that a ~ String (from the argument, not from GHCi)
16:43:55 <roboguy_> bennofs: hmm, yeah
16:44:05 <qfjp> does anyone know if ghci can have multi key keybindings?
16:44:19 <quchen> GHCi has keybindings?
16:44:20 <bennofs> qfjp: what are multi key bindings?
16:44:31 <qfjp> if i want to bind "ab" to escape
16:44:55 <qfjp> something like "bind ab ^[" instead of  "bind a ^["
16:44:58 <bennofs> qfjp: how are you using GHCi? Inside vim/emacs/something else?
16:45:20 <qfjp> inside vim, but i'd like to be able to use it standalone also
16:45:41 <bennofs> qfjp: GHCi doesn't have keybindings in standalone mode afaik
16:45:50 <qfjp> i found this http://trac.haskell.org/haskeline/wiki/CustomKeyBindings
16:46:02 <qfjp> but keyseq seems only for simultaneous keystrokes
16:46:04 <qfjp> C-a and such
16:46:44 * hackagebot timeplot 1.0.23 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.23 (EugeneKirpichov)
16:47:18 <qfjp> thanks anyway, i guess i can run it through vim for the time being
16:48:33 <yogert> Hey, anyone mind taking a look at this? I'm trying to parse some JSON files with Aeson and am running into trouble.
16:48:34 <yogert> http://lpaste.net/97359
16:51:38 <yogert> And the example i posted has a few errors ("DeriveData", conflicting record names etc). I created it on the spot, but it communicates what I've been trying thus far
16:51:45 <AlainODea> yogert: have you tried adding ToJSON and FromJSON to your deriving set? You'll need GeneralizedNewTypeDeriving I think
16:51:45 <pranz1> yogert: what kind of trouble?
16:52:02 <pranz1> oh didn't see comments
16:52:03 <pranz1> nvm
16:52:17 <k00mi> AlainODea: doesn't work, those aren't newtypes
16:52:37 <AlainODea> k00mi: good point
16:52:44 <donri> yogert: try deriving ToJSON the same way and see what JSON it generates for some input
16:52:58 <donri> yogert: you need the input JSON to match that format
16:53:43 <yogert> ok give me abit
16:54:32 <donri> it's possible you're running into https://github.com/bos/aeson/issues/142 though
16:58:31 <roboguy_> Does anyone here use SublimeHaskell and know if there's a way to make it more stable?
17:01:19 <yogert> donri: when you say "derive ToJSON the same way", what do you mean exactly?
17:03:07 <donri> yogert: sorry i missed it, you're already deriving ToJSON. now try using those instances :)
17:03:43 <donri> encode GenTest { ... }
17:03:48 <yogert> o
17:03:49 <yogert> ok
18:12:54 <yogert> donri: hey sorry, i was interrupted. Just to let you know, I got it working
18:13:15 <yogert> I do i have a question, that I think i know the answer to
18:14:12 <yogert> Is it possible to grab only some of the fields? That may have been my problem earlier
18:26:54 <Asminthe> I'm working on my first non-trivial Haskell program, and it'
18:27:13 <Asminthe> It is a bit of a strain to not think of everything in imperative terms
18:28:30 <nisstyre> Asminthe: what is an example of something you are having trouble conceptualizing?
18:29:51 <Asminthe> I'm afraid I might be working myself into a corner in one area in particular.  The program is a game, and the game has several players.  I want each player to have a decision function that it uses to decide which play to make on their turn.
18:30:20 <nisstyre> Asminthe: okay, that sounds fine
18:30:43 <Asminthe> Some of these decision functions might be purely deterministic, but others might, for example, ask a user for input or make use of pseudorandom numbers
18:30:45 <nisstyre> Asminthe: are you having trouble generalizing the decision function?
18:31:08 <nisstyre> Asminthe: your decision function can return something like IO Decision
18:31:15 <nisstyre> that's not bad
18:31:28 <nisstyre> and you could even factor out the pure parts by giving it a function as a parameter
18:31:56 <Asminthe> So it would probably be correct, then, to define a DecisionFunction to be of type Player -> Game -> IO PlayerAction or something
18:32:07 <nisstyre> I guess so yeah
18:32:13 <nisstyre> as long as it isn't one huge function
18:33:48 <Asminthe> Okay, thanks.  I wanted to make sure I wasn't going to end up in someplace weird, and I'm especially trying to be aware of not keeping enough of the system pure.
18:34:03 <pavonia> I would even remove the Player argument and pass each player its own function
18:35:18 <erisco> I annotated with a vertMap that keeps state http://lpaste.net/97360
18:35:39 <erisco> I dunno, I see this pattern coming up over and over again
18:38:17 <pavonia> erisco: Maybe you want Functor instances for Vector k and Edge k?
18:39:29 <erisco> pavonia, I am particularly looking at the act of threading the state through
18:39:57 <erisco> so you have a callback and it needs to save information
18:41:19 <Cale> erisco: Did you just invent the State monad?
18:41:26 <Cale> ;)
18:41:33 <erisco> Cale, it does look like a monad
18:41:46 <Cale> (Are you familiar with how the State monad works?)
18:42:00 <shachaf> There really ought to be a mechanism for adding superclasses in the middle of a class hierarchy after the fact.
18:42:23 <blackdog> is there a way to get parsec (or similar library) to return all possible parses of an input stream?
18:42:24 <erisco> Cale, I have worked with ST but not State so I'll have to take a look
18:42:32 <shachaf> I duppodr prople have probably thought about it.
18:42:35 <shachaf> What are the problems that come up?
18:42:55 <Cale> erisco: Well, I can go through the construction with you if you like, but let's do that in #haskell-overflow or something
18:44:50 <pavonia> blackdog: That should be the result if you use the list monad for ParsecT
18:45:08 <pavonia> I guess
18:46:43 <blackdog> pavonia: thanks, i'll look into it. haven't played with ParsecT before
18:47:13 <dolio> shachaf: Library W has C1 => C3. Library X inserts C1 => C2 => C3. Library Y implements C1 and C3 for T. Now I use W, X and Y. Where does the C2 for T come from?
18:48:09 <shachaf> Default implementation in terms of a subclass?
19:02:18 <zRecursive> Will lazy cause Concurrent/Parallel not practical ?
19:04:30 <Cale> zRecursive: huh?
19:05:06 <geekosaur> @google parallel and concurrent programming with haskell
19:05:07 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
19:05:07 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
19:05:08 <Cale> zRecursive: On the contrary, it's often helpful.
19:05:36 <zRecursive> oh ?
19:05:46 <Cale> The fact that not everything is strict means that we can construct higher order things which evaluate their parameters in parallel, because they're not already evaluated yet.
19:06:08 <Cale> e.g. parMap from Control.Parallel.Strategies
19:06:22 <Cale> and things like that
19:06:36 <Cale> (well, pretty much everything in that module is an example of this)
19:07:13 <zRecursive> ok, need to study it ...
19:08:13 <shachaf> dolio: I'm thinking of cases like e.g. adding Invariant as a superclass of Functor/Contravariant. And then adding Lensy/Prismy (with operations f a -> f (b,a) and f a -> f (Either b a)) as superclasses in between.
19:08:21 <Cale> It also means you can stuff unevaluated expressions through a channel and have the reader evaluate them when it's ready
19:08:41 <zRecursive> geekosaur: good book, thx
19:08:52 <Cale> That can sometimes result in better parallelism through concurrency in the case where you have few writers and many readers
19:09:00 <shachaf> I suspect these instances all end up being uniquely defined, so you don't even have to worry too much about different implementations coming from different places. But maybe that's not true and that sort of thing is an issue in general.
19:10:07 <Cale> zRecursive: as for concurrency itself, laziness doesn't really affect that a whole lot one way or the other, since it's lazy *evaluation*, and concurrency is about nondeterministic order of *execution*
19:11:52 <Cale> Because evaluating a Haskell expression gives the same result no matter when you do it, the evaluation order won't tend to affect the possible outcomes of concurrent Haskell programs.
19:12:09 <zRecursive> sure
19:12:13 <Cale> (unless you're messing with unsafePerformIO or something)
19:13:03 <zRecursive> Do we need to force evaluation sometimes ?
19:13:08 <Cale> yes
19:13:45 <enthropy> @type forkIO
19:13:47 <lambdabot> Not in scope: `forkIO'
19:14:00 <geekosaur> :t Control.Concurrent.forkIO
19:14:01 <lambdabot> IO () -> IO GHC.Conc.Sync.ThreadId
19:14:02 <Cale> It can be a big problem to just let large expressions be accumulated in IORefs/MVars/TVars over time without being evaluated for too long.
19:14:11 <enthropy> no need for unsafePerformIO to do IO in different threads
19:15:04 <Cale> e.g. consider what happens if you modify a shared mutable variable using (+1) millions of times without evaluating it, you end up with a mess which looks like (+1) ((+1) ((+1) ... ))
19:15:31 <Cale> which will use way more memory than the resulting integer would, and will consume lots of GHC's stack when it eventually gets evaluated
19:15:32 <zRecursive> big thunk ?
19:15:34 <Cale> yeah
19:15:55 <Cale> (though I tend to think at the level of expressions rather than worry about the details of their representation as thunks)
19:16:43 <Cale> Thunks are just helping simulate expression graph rewriting efficiently anyway.
19:17:28 <zRecursive> Can thunks be controlled by the programmer ?
19:18:00 <Cale> With the GHC API, you can get hold of them and inspect the real details
19:18:40 <Cale> There's a library on Hackage called vacuum which has useful tools for inspecting them
19:18:51 <zRecursive> At the beginning, i just want to force it to be evaluated ...
19:19:20 <Cale> Well, don't worry about thunks then
19:19:28 <zRecursive> now i am using "!" to force strict
19:19:37 <Cale> Yeah, that sort of thing will help
19:20:07 <Cale> Also, Control.Exception.evaluate may be of use, if you care about the sequencing of evaluation with IO
19:20:07 <zRecursive> ok
19:20:36 <zRecursive> :t Control.Exception.evaluate
19:20:38 <lambdabot> a -> IO a
19:21:17 <Cale> evaluate x, when executed, will force the evaluation of x up to determining what its top level data constructor is, and return the result
19:22:04 <Cale> For pure programs, there's also seq (which is equivalent to the use of bang patterns, if that's what you meant by !)
19:22:50 <zRecursive> :t seq
19:22:52 <lambdabot> a -> b -> b
19:23:18 <Cale> Semantically, seq x y = _|_ if x is _|_, and y otherwise.
19:23:38 <zRecursive> used to guarantee "evaluation sequence" ?
19:23:48 <Cale> Basically, this means that x must be evaluated before the result of y is made available to pattern match on.
19:23:50 <Cale> yeah
19:24:11 <zRecursive> ok
19:24:30 <Cale> @src foldl'
19:24:30 <lambdabot> foldl' f a []     = a
19:24:31 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
19:24:41 <Cale> compare with:
19:24:44 <Cale> @src foldl
19:24:45 <lambdabot> foldl f z []     = z
19:24:45 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:24:47 <AlainODea> The type of seq is uninteresting for the most part.  It's for evaluating to weake head normal form: essentially force one level of evaluation.
19:44:42 <Taslem> Can the first functor law be derived from the second?
19:50:34 <lightquake> Taslem: I don't know how rigorous you can do it, but you can argue something like...
19:50:46 <lightquake> fmap (f . id) = fmap f . fmap id = fmap f, so fmap id is 'probably' id
19:52:05 <Saizan> mapMaybe _ _ = Nothing respects the second law but not the first
19:52:17 <Taslem> Okay, that makes sense.
19:52:21 <lightquake> ah, yeah
19:52:38 <Taslem> Is there an example of a definition which respects the first but not the second?
19:53:05 <Saizan> nope, given the first the second follows by parametricity
19:53:47 <Taslem> I'm not familiar with that. Do you know of a reference that explains it?
19:54:24 <Saizan> ?google wadler theorems for free
19:54:26 <lambdabot> http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
19:54:26 <lambdabot> Title: Theorems for free Philip Wadler University of Glasgow* June 1989 Abstract Fro...
19:54:54 <lightquake> Saizan: what about fakeFmap f x = fmap (f . f) x?
19:55:02 <lightquake> oh wait that doesn't have the right type
19:57:28 <Saizan> Taslem: you'll find a lot of newer papers on parametricity too, but more about extending it than showing its use
20:00:47 <yogert> When using Aeson to parse JSON, is there a way to automatically make my datatype an instance of FromJSON, while still allowing for missing fields? It appears that if I write out the parseJSON code, it can withstand the absence of a field, giving a Nothing back instead. If I use TemplateHaskell or DeriveGeneric instead though, it runs into an error. Any way to work around this?
20:02:34 <ski> Cale : i thought in `seq x y', `x' needs to be evaluated to WHNF, but not necessarily before `y' is
20:03:38 <ski> i wonder whether a compiler could (e.g. perhaps as a consequence of strictness analysis or partial evaluation / program specialization) evaluate `x' after `y' is matched upon (so long as `x' is evaluated eventually)
20:03:51 <johnw> "seq is strict in both its arguments, so the compiler may, for example, rearrange a `seq` b into b `seq` a `seq` b"
20:04:18 <Cale> ski: You can evaluate y first, but you have to evaluate x before you make the result of evaluating y available for pattern matching
20:04:29 <Cale> (welll....)
20:05:05 <ski> it's the latter part which i'm wondering about
20:05:06 <Cale> I suppose all that the report *really* implies is that we *eventually* evaluate x before any visible effects happen.
20:05:27 <Cale> I believe that ghc *does* reorder seqs sometimes
20:05:44 <ski> @where lazy
20:05:44 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
20:06:01 <ski> zRecursive : if you haven't seen that ^ before, it might be interesting
20:06:26 <ski> @type Control.Parallel.pseq
20:06:27 <lambdabot> a -> b -> b
20:10:59 <tvynr> Anyone have any suggestions regarding cabal not realizing that Happy is installed?  I've definitely installed it and the binary is on my PATH, but I can't build my project because it seems to be missing.
20:11:49 <tvynr> A skim of the 'net suggests that this has something to do with happy being a binary package, but I can't figure out for the life of me why cabal can't tell it's there.
20:15:01 <geekosaur> did you just change $PATH? if so, did you `export` it?
20:15:42 <tvynr> Yeah.  But I get the appropriate binary from: `which happy` --version
20:16:28 <geekosaur> "which" isn't always reliable. does "type" see it?
20:17:02 <tvynr> type happy: "happy is /home/zpalmer/.cabal/bin/happy"
20:17:16 <geekosaur> (depending on whose "which" you are using, ti may show you the one you'll see when you next log in)
20:17:34 <tvynr> which happy gives the binary in ~/.cabal/bin and it's definitely version 1.19.2.  But cabal list gives me "Default available version: 1.19.2" and "Installed versions: [Unknown]"
20:17:41 <geekosaur> oh
20:17:52 <geekosaur> did you actualy use ~ when you added to $PATH?
20:18:02 <geekosaur> because in that case, bash and only bash will handle it correctly
20:18:11 <geekosaur> because bash and only bash underdtands ~
20:18:16 <tvynr> The path includes "/home/zpalmer/.cabal/bin"
20:18:21 <tvynr> (thanks for helping out, btw)
20:18:40 <Clint> technically bash and only bash mishandles ~
20:19:44 <geekosaur> enh. it's nice and convenient, but requires access to the environment. which the kernel does not have, so it can't expand ~ in general file names
20:20:38 <geekosaur> it's no more of a mishandling than shells supporting $var is a mishandling of $
20:20:41 <tvynr> So if I run "cabal install --only-dependencies && cabal build" I see Happy install and then I get "At least the following dependencies are missing: happy -any"
20:21:02 <Clint> geekosaur: if your definition of "correctly" is posix, then, no
20:21:46 <haskellcurry> greetings, minions. why does this program (http://pastebin.com/E9fd32TU) not loop forever if given a negative integer along with a non-empty list as input?
20:21:46 <geekosaur> if your definition of "correctly" is posix and nothing whatsoever except posix, you are going to be fairly unhappy anyway
20:21:51 <mauke> The paste E9fd32TU has been copied to http://lpaste.net/97364
20:22:04 <Clint> that's true, but there's no sane reason to violate posix tilde expansion rules in bash's case
20:22:56 <geekosaur> haskellcurry, try giving it an infinite list
20:23:01 <tvynr> haskellcurry: 'cause any negative number is effectively going to be a massive positive number.
20:23:25 <tvynr> haskellcurry: It'll bottom out if given a finite list 'cause it'll chew up the list and hit [] eventually.
20:23:52 <yogert> Sorry to ask again, but does anyone know how to get Aeson's parseJSON method to work despite missing fields in the JSON? I can get it working when I write the function by hand, using the (.:?) operator, but when I use TemplateHaskell or Generics, the resulting code doesn't work.
20:24:03 <haskellcurry> tvynr: wut - how is any negative number effectively a massive positive number?
20:24:14 <tvynr> geekosaur: So thanks again for the help.  Any idea how I could try to figure out what's up with Happy and Cabal?
20:24:31 <geekosaur> haskellcurry, because it will continue forever, just as if you had given it an infinitely large positive number
20:24:44 <geekosaur> except in this case, for a finite list it will hit the [] case which ignores your number
20:24:55 <geekosaur> but if you feed it an infinite list, it will continue forever
20:25:06 <geekosaur> > cycle 1
20:25:08 <lambdabot>  No instance for (GHC.Show.Show a0)
20:25:08 <lambdabot>    arising from a use of `M1695649062287213854687.show_M1695649062287213854687'
20:25:08 <lambdabot>  The type variable `a0' is ambiguous
20:25:08 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
20:25:08 <lambdabot>  Note: there are several potential instances:
20:25:11 <tvynr> haskellcurry: The problem is that you'll (pretty much) never reach zero because you keep decrementing the negative number.  (I think Int will eventually roll over, right?)  But the point is it won't really reach zero.
20:25:12 <geekosaur> beh
20:26:00 <haskellcurry> tvynr, geekosaur aaahhhhh, the light bulb turns on! the integer keeps ticking, but the list keeps getting smaller. thank you, minions.
20:26:03 <geekosaur> eventually it will. but even on  32 bit platforms I think Int is 64 bit in ghc these days
20:27:13 <enthropy> Int = Int64 on 64 bit as long as I've known
20:27:44 <enthropy> geekosaur: or you're saying Int = Int64 on 32 bit now?
20:28:17 <geekosaur> enthropy, last time I checked that seemed to be true. but it might have been an artifact of the platform (Macs are weird about 32 vs. 64)
20:28:47 <haskellcurry> wait, so why doesn't that program return the empty list if i give it a negative number and non-empty list as input?
20:31:08 <geekosaur> tvynr, not offhand. cabal does $PATH search for executable dependencies, so make absolutely certain that `echo $PATH` doesn't include any ~s
20:31:20 <geekosaur> also doesn't include any $s
20:32:39 <haskellcurry> hrmm? geekosaur or tvynr? why does the program not return an empty list if given a negative integer and non-empty list as input?
20:33:24 <pavonia> What does it return instead?
20:33:40 <haskellcurry> the non-empty list that i provided it with....
20:33:48 <geekosaur> haskellcurry, it returns an empty list here
20:33:57 <tvynr> haskellcurry: I just popped it into ghci.  It does return an empty list.
20:34:15 <tvynr> haskellcurry: Perhaps the function you're calling is not the function you think you're calling.
20:34:30 <haskellcurry> yes, i was calling drop, instead of dropx
20:34:37 <haskellcurry> many thanks minions
20:37:45 <tvynr> haskellcurry: (The "minions" thing, while initially amusing, doesn't leave the greatest tone.  ;)  Not angry; just sayin'.)
20:40:17 <arrdem> what's the effective difference between Int and Integer?
20:42:01 <geekosaur> Int is a machine word, Integer is arbitrary sized
20:42:04 <geekosaur> (via gmp)
20:42:24 <geekosaur> > 2^70 :: Int
20:42:26 <lambdabot>  0
20:42:32 <geekosaur> > 2^70 :: Integer
20:42:33 <lambdabot>  1180591620717411303424
20:46:42 <lightquake> geekosaur: I don't think the report guarantees that it's a machine word, only that it's at least 29(?) bits large
20:47:24 <lightquake> however I think in practice it is
20:47:46 <Asminthe> Is there a story behind that 29?
20:48:11 <Asminthe> Seems like the kind of thing that would have a story.
20:48:47 <geekosaur> some older Haskell implementations "stole" bits for use by garbage collection or tagging
20:48:54 <geekosaur> ghc doesn't
20:49:14 <Asminthe> Ah.
20:49:28 <dmwit> Instead, GHC steals entire words.
20:49:52 <Asminthe> lol, naturally
20:49:55 <Cale> :)
20:51:21 <geekosaur> it has been rather a while since we needed to conserve bits to make stuff fit in 64K :p
20:52:26 <lightquake> geekosaur: I think these days the arguments tend more towards CPU caches
21:05:43 <jibcage> Hi, I started trying out Haskell after learning SML, but I'm having trouble getting this to typecheck : http://lpaste.net/8454839350641819648
21:06:00 <jibcage> It claims that the connection is a handle
21:06:05 <jibcage> when it is most definitely a socket (I think)
21:06:43 <jibcage> I'm sort of merging two different examples here, so there could be other things wrong with it as well. But this has had me stuck for a while.
21:07:54 <Cale> jibcage: You pass conn to body as the first parameter
21:08:06 <Cale> jibcage: then body c h passes c to helper
21:08:18 <Cale> and then helper handle host passes handle to hGetContents
21:08:40 <Cale> and so somewhere along the line, you stopped thinking of conn as a socket :)
21:09:13 <jibcage> Cale: Thanks! I guess I was thinking about it from the other way around.
21:09:47 <Cale> By the way, the error messages you'll get from GHC will tend to be much better in cases like this if you annotate the definitions with type signatures
21:10:23 <jibcage> Cale: Can you do that with local functions?
21:10:28 <Cale> yes
21:10:30 <jibcage> I'm assuming you can, just never seen an example.
21:10:45 <jibcage> I'll go look that up then :)
21:11:00 <Cale> Well, it's just as you'd expect
21:12:00 <Cale> body :: Socket -> SockAddr -> IO ByteString -- or something like this :)
21:12:00 <jibcage> Cale: Ah, thanks. I was expecting another curveball. This project is my cold turkey learning experience
21:12:28 <jibcage> My functional programming class taught me SML which hasn't proven to be terribly useful
21:13:17 <Cale> Well, it should be a good start, I would hope!
21:13:27 <jibcage> Cale: Out of curiosity, what would the type signature for loop be, since it doesn't terminate?
21:13:30 <Cale> SML and Haskell share a lot of features
21:13:54 <Cale> loop :: Socket -> IO a
21:14:04 <Cale> Or you could make it  loop :: Socket -> IO ()
21:14:27 <roconnor> Socket -> IO a is better
21:14:39 <Cale> I agree, it tells you in the type that it's not going to terminate
21:16:56 <roconnor> Cale: well, it could call system exit.
21:17:24 <Cale> I'd count that as not terminating ;)
21:17:44 <roconnor> that is a bit of a stretch :D
21:17:59 <Cale> Well, it's similar to how _|_ can mean a call to error
21:18:18 <Cale> (but yeah)
21:19:48 <lightquake> roconnor: what about Socket -> IO Void?
21:22:44 <roconnor> lightquake: equivalent.
21:23:02 <roconnor> would also be acceptable
21:23:18 <lightquake> can you write (forall a. a) -> Void?
21:23:45 <roconnor> Void and (forall a. a) are morally isomorphic
21:23:55 <lightquake> right
21:24:12 <lightquake> neither of them has any inhabitants aside from bottom-y things
21:27:30 * hackagebot persistent 1.2.3.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.2.3.1 (MichaelSnoyman)
21:28:56 <jibcage> Now I'm not entirely sure, but I think the compiler is mad at me because when I use getContents instead of hGetContents on the socket, I get a lazy bytestring.
21:29:33 <jibcage> http://lpaste.net/5926249553522065408
21:29:59 <geekosaur> yes? look at your imports
21:30:02 <jibcage> Couldn't match expected type `ByteString' with actual type `Data.ByteString.Lazy.Internal.ByteString'
21:30:45 <jibcage> sigh
21:34:13 <dleedev> Hello everyone
21:35:22 <Iceland_jack> hey dleedev
21:35:32 <dleedev> I just read Edward-Kmett's quora post saying how great the #haskell channel is
21:35:45 <edwardk> hah
21:35:55 <dleedev> edwardk: is that you?
21:35:59 <edwardk> yep
21:36:25 <edwardk> mind you the example i cited as an extreme case. ;)
21:36:28 <edwardk> er was
21:36:40 <jimmt> http://www.reddit.com/r/programming/comments/1te0m8/a_review_of_haskell/ce70kfr lol
21:37:50 <edwardk> i figured i should take some time to reach out to the folks who use quora as there doesn't seem to be a lot of overlap with the haskell reddit and the channel here.
21:39:09 <Iceland_jack> jimmt: Hey…
21:39:09 <Iceland_jack>  
21:39:09 <Iceland_jack>     13:21 < Iceland_jack> xQuasar: We are cooperating with you, you're just not aware that your goal is learning Haskell
21:39:21 <dleedev> how important is learning category theory when using haskell?
21:39:30 <edwardk> dleedev: its not.
21:39:31 <Iceland_jack> dleedev: It isn't
21:39:58 <rdevilla> does learning category theory offer deep insight into haskell, though?
21:40:01 <dleedev> ok, just saw that as the first thing you did after your conversion
21:40:08 <djahandarie> I would give a different answer
21:40:32 <edwardk> dleedev: I personally find category theory to be useful, because it helps me avoid blind alleys. It tells me a lot about what can't exist, so I can stop looking. It is useful to the kind of software that I _like_ to write.
21:40:47 <djahandarie> "Yes", because learning category theory is a good thing to do when studying pretty much any theoretical field.
21:40:59 <bitemyapp> carter: need to work on your reading comprehension.
21:41:10 <edwardk> but it isn't strictly necessary. many people go their whole programming career without knowing where monads come from, etc. just getting by on examples of them and seat of their pants intuition.
21:41:47 <lightquake> "daddy, where do monads come from?" "well, when a functor and a join operator love each other very much..."
21:42:03 <dleedev> actually, I do have questions about monads
21:42:17 <djahandarie> Ask me about my monads!!
21:42:18 <edwardk> rdevilla: for me it does. i think i'd get a lot less done had I _not_ obsessively binged on category theory when I found Haskell. It made for a slower learning trajectory as I had all this math being shoved in my face, but I think it definitely raised the top end of what I can do.
21:42:24 <bitemyapp> dleedev: http://dev.stephendiehl.com/hask/
21:42:24 <dleedev> is there a good link that conceptual describes monads in haskell?
21:42:31 <bitemyapp> dleedev: read that link.
21:42:37 <bitemyapp> dleedev: monads are just code. they're not special.
21:42:42 <dleedev> bitemyapp: thank you
21:42:47 <dleedev> but monads are treated specially in haskell
21:42:50 <edwardk> dleedev: monads are very simple. 2 methods, 3 laws. thats it.
21:42:53 <bitemyapp> dleedev: Haskell makes use of several catrgory theoretic concepts that have algebraic laws attached to them.
21:42:56 <rdevilla> edwardk: hm, I see. Thanks for your input
21:43:00 <edwardk> dleedev: they are just a class like any other.
21:43:06 <bitemyapp> dleedev: you can think of the relevant typeclasses as "interfaces" with rules attached.
21:43:10 <Iceland_jack> dleedev: If you're referring to do-notation then that's just syntactic sugar
21:43:11 <edwardk> dleedev: they get a bit of syntactic sugar, but that's just convenience
21:43:16 <rdevilla> I would like to learn category theory but I don't think I'm mathematically mature enough for that yet
21:43:21 <bitemyapp> dleedev: that they happen to be composable is just nice.
21:43:40 <bitemyapp> edwardk: showing a before/after of desugaring a do-syntax example helps to make that point.
21:43:51 <dleedev> how are monads com posable?
21:43:54 <bitemyapp> dleedev: monads aren't even that "special", beyond the privileged status IO gets.
21:44:04 <edwardk> dleedev: the problem with trying to deal with monads as a 'concept' rather than just looking at the two methods and 3 laws and staring at a bunch of seemingly unrelated examples and figuring out how they all pass is that all the analogies are wrong in some sense.
21:44:16 <bitemyapp> dleedev: you're going to get further just writing some code.
21:44:17 <edwardk> > do x <- [1,2,3]; y <- [4,5,6]; return (x * y)
21:44:19 <lambdabot>  [4,5,6,8,10,12,12,15,18]
21:44:22 <bitemyapp> dleedev: talking to people about it won't do anything.
21:44:24 <edwardk> @undo do x <- [1,2,3]; y <- [4,5,6]; return (x * y)
21:44:24 <lambdabot> [1, 2, 3] >>= \ x -> [4, 5, 6] >>= \ y -> return (x * y)
21:44:27 <bitemyapp> dleedev: obey the article I sent you.
21:44:35 <bitemyapp> it will not fail you.
21:44:40 <edwardk> > [1, 2, 3] >>= \ x -> [4, 5, 6] >>= \ y -> return (x * y)
21:44:41 <dleedev> bitemyapp: haha, got it
21:44:42 <lambdabot>  [4,5,6,8,10,12,12,15,18]
21:45:02 <bitemyapp> nothing in the slightest bit special about any of it. Just write the code, see how it behaves, boom enlightenment.
21:45:05 <dleedev> whoa, lambdabot
21:45:33 <bitemyapp> dleedev: also note the progression from functor, to applicative, to monad. You can think about how monoids compare as well.
21:45:33 <dleedev> but I feel like writing the code for most monad examples leads me to a false sense about monads
21:45:44 <lightquake> that reminds me
21:45:45 <dleedev> in the beginning, I thought monads were "imperative code" in haskell
21:45:47 <bitemyapp> dleedev: how about you write some code, toss it on lpaste, then we'll talk.
21:45:52 <edwardk> dleedev: there is a notion of a "monad transformer" that lets you glue together bigger and bigger monads out of simpler parts.
21:45:53 <lightquake> is there a nice way to generate documentation for all the libraries i have installed?
21:46:10 <edwardk> dleedev: that is one of the common false analogies
21:46:32 <dleedev> yeah, and that's why I want to avoid simplistic introductions to monads
21:46:33 <bitemyapp> edwardk: yes but lets explain why that false analogy is used.
21:46:47 <bitemyapp> dleedev: entertain my socratic for a moment
21:46:52 <dleedev> I went down the wrong road once, and got burned a little
21:46:59 <edwardk> dleedev: monads aren't about "imperative code", they aren't about spacesuits, burritos, containers, syntax trees, etc. they are a simple pattern that happens to fit all of those things.
21:47:00 <bitemyapp> dleedev: what is imperative programming? what does the paradigm generally mean?
21:47:19 <dleedev> I guess manipulating bits
21:47:19 <rdevilla> bitemyapp: do this, then this.
21:47:26 <bitemyapp> dleedev: no, what rdevilla said.
21:47:48 <bitemyapp> dleedev: now, you boil that down to, "I have a sequence of instructions against implicit or explicit state"
21:47:55 <rdevilla> oh, it was a didactic question.
21:47:57 <rdevilla> ._.
21:48:33 <bitemyapp> dleedev: monads are purely functional. When you make use of functions and data, what's the typical pattern involved?
21:48:51 <dleedev> pattern in which paradigm?
21:48:52 <edwardk> a monad is basically about 'a kind of structure' or a set of expressions, where you can push things around just enough to be able to make functions out of them without changing your meaning.
21:49:05 <bitemyapp> edwardk: let me try this, to spare you the hassle.
21:49:10 <edwardk> those kinds of expressions are useful for talking about lists, containers, IO, syntax trees, etc.
21:49:12 <bitemyapp> edwardk: I've been teaching a lot of Haskell recently.
21:49:16 <bitemyapp> edwardk: to complete FP noobs.
21:49:23 <bitemyapp> edwardk: but I need their full attention.
21:49:27 <edwardk> go for t
21:49:35 <dleedev> bitemyapp: bring it on
21:49:40 <bitemyapp> dleedev: just you know, bare bones functional programming. You have values and functions. What do you do with them?
21:49:58 <dleedev> pass values into functions and get more values
21:50:00 <bitemyapp> nothing subtle here, just state the obvious.
21:50:09 <bitemyapp> dleedev: okay, so you're invoking functions against values right?
21:50:12 <dleedev> yeah
21:50:15 <bitemyapp> dleedev: cool. So now lets think about this.
21:50:21 <bitemyapp> dleedev: the functions have to do everything.
21:50:48 <bitemyapp> dleedev: so if you needed (in some language that wasn't Haskell) to handle things like, "what if this value isn't valid because of a previous computation?"
21:51:05 <bitemyapp> dleedev: what do you do in our simple scenario? you'd put if checks or something in every function intended to receive the data right?
21:51:28 <dleedev> yes, except I didn't understand the part about "previous computation"
21:51:45 <bitemyapp> dleedev: I have functions f and g. They are having some data piped through them.
21:52:15 <bitemyapp> dleedev: if f could possibly return a null/nonsensical value, g has to check for it. So does every function that might receive data f has processed.
21:52:40 <bitemyapp> dleedev: this turns into a combinatorial explosion of conditional checks in your functions if you have functions you're reusing across a variety of data sources.
21:52:50 <dleedev> ok
21:52:54 <bitemyapp> dleedev: again, the problem is the data is "dumb". it can't do anything or dictate how it is processed.
21:53:00 <bitemyapp> dleedev: the functions have to do everything.
21:53:07 <dleedev> got it
21:53:23 <bitemyapp> dleedev: the first, simplest way to try to mitigate this is basically closures or function wrapping. You can see this with decorators in Python.
21:53:28 <bitemyapp> dleedev: but that falls apart eventually.
21:53:42 <dleedev> ok
21:53:44 <bitemyapp> dleedev: but lets go back to the fundamental nature of the problem. The data can't tell how to process itself.
21:54:03 <bitemyapp> dleedev: so we begin with the simplest and most general concept, the functor.
21:54:21 <bitemyapp> dleedev: functors are basically a way to apply functions to data that are inside of some sort of container. The verb is "fmap"
21:54:29 <bitemyapp> dleedev: that link I sent you. Find the functor typeclass section.
21:54:49 <dleedev> I found "Applicative Functors"
21:54:59 <bitemyapp> dleedev: uhh, you want the vanilla functors. should be above that.
21:55:15 <bitemyapp> dleedev: http://www.haskell.org/haskellwiki/Typeclassopedia#Functor just look here.
21:55:24 <dleedev> got it
21:55:33 <bitemyapp> dleedev: okay. so we want to apply functions to data that's inside of a "container" of some kind.
21:55:43 <bitemyapp> dleedev: what is a common "container" type to almost all programming languages?
21:55:55 <dleedev> array/list
21:56:07 <bitemyapp> dleedev: precisely.
21:56:25 <bitemyapp> dleedev: so if you wanted to implement Functor's fmap for lists, what function is precisely what you want in Haskell/python/clojure/etc ?
21:57:00 <dleedev> map?
21:57:04 <bitemyapp> dleedev: precisely!
21:57:09 <shachaf> Maybe you should take it to #haskell-overflow.
21:57:13 <bitemyapp> arrdem: welcome. we were just explaining how it's tedious to put redundant if-checks and the like in functions that need to handle "uncertainty"
21:57:19 <bitemyapp> shachaf: so we will.
21:57:24 <dleedev> bitemyapp: see you there
21:57:25 <bitemyapp> arrdem and dleedev - #haskell-overflow please.
22:01:11 <Platz> any good resources on monad transformers? I watched Tony Morris - Monad Transformers - http://vimeo.com/73648150 , but i think I need some more examples
22:01:32 <dmwit> I liked All About Monads for that part of my journey.
22:01:56 <dmwit> My usual advice is sigfpe's "You Could Have Invented Monads" followed up by "All About Monads".
22:02:14 <dmwit> I think there's a version of it on the wiki.
22:02:41 <kryft> Platz, dmwit: Thanks! I didn't think of asking this question right now, but I've wanted to ask it before, so I liked the question and the answer ;)
22:02:44 <Platz> I've got the basic monad thing donw, I'll do "all about Monads", looks very good
22:04:45 <Platz> so MonadIO is a monad transformer, but doesn't have the T suffix like the other transformers, right?
22:04:52 <shachaf> MonadIO is a type class.
22:06:13 <Platz> ah, yeah that's a little different then
22:06:16 <c_wraith> Things which in no way involve transformers can be instances of the class, too.  Like...  IO
22:06:57 <dmwit> The typical instances of MonadIO is a monad stack with IO at the bottom.
22:07:06 <dmwit> The empty stack is a stack, too.
22:07:36 <c_wraith> liftIO = id is the best liftIO
22:07:52 <Platz> I'm sure it will make more sense after going though "All About Monads" carefully
22:08:23 <dmwit> Sure. But if you have concrete questions, you can sure ask them now and maybe we can answer in an understandable way.
22:08:36 <Platz> sure, thanks
22:09:26 <Cale> a monad transformer* stack
22:09:50 <c_wraith> The thing that makes monads "hard" is that they're *so* abstract. It's not really possible to explain them by analogy.
22:09:53 <kryft> dmwit: A monad stack means a monad with transformers "on top" or "around it"?
22:10:59 <FliPPeh> What would happen if I were to wrap a ReaderT inside a StateT inside a WriterT inside another ReaderT?
22:11:17 <dmwit> kryft: yes
22:11:28 <FliPPeh> RequestContext(ResponseContext(GlobalProgramState(ReadOnlyProgrammConfiguration))) in this case
22:11:45 <zRecursive> FliPPeh: You will be crazy :)
22:11:53 <johnw> FliPPeh: you'd have someone recommending RWST to you
22:12:14 <FliPPeh> :o
22:12:15 <dmwit> FliPPeh: Not much, except that you will have to use "lift ask" instead of "ask" to get to the inner ReaderT's data.
22:12:49 <dmwit> ?unmtl ReaderT r (WriterT w (StateT s (ReaderT r' m))) a
22:12:50 <lambdabot> r -> (WriterT w (StateT s (ReaderT r' m))) a
22:12:53 <dmwit> ...
22:13:03 <dmwit> Who do I have to hire to fix ?unmtl?
22:13:36 <FliPPeh> So RWST is what it says on the tin? A reader/writer/state monad transformer stack?
22:13:41 <dmwit> yes
22:13:53 <shachaf> dmwit: You could fix it yourself.
22:13:53 <FliPPeh> Okay, the neatly combines my current approach
22:14:09 <FliPPeh> Although the writer part comes later and is not part of my core program
22:14:11 <dmwit> shachaf: that sounds awful
22:14:23 <FliPPeh> I have a core around Reader for configuration and state for... state
22:14:30 <FliPPeh> And now I want to build a request context around it
22:14:34 <dmwit> () is a monoid
22:14:46 <dmwit> in fact, () is even a Monoid
22:14:58 <FliPPeh> The writer part has existed for a while now, but now I need a reader part to have an implicit context which has a shorter life than the whole program
22:16:20 <FliPPeh> Maybe I should just make the current context part of my state monad :(
22:16:32 <johnw> FliPPeh: why not use RWST?
22:16:46 <FliPPeh> johnw: because that doesn't work here
22:16:48 <johnw> ah, sorry, didn't see the scrollback
22:16:52 <FliPPeh> :v
22:17:05 <FliPPeh> It *would* work to be precise
22:17:13 <FliPPeh> But it won't improve anything
22:17:25 <c_wraith> well, it's a little more efficient
22:17:29 <c_wraith> So it does improve something
22:17:32 <FliPPeh> and it would waste its "W" part because "W" is bolted on later and only for a while
22:17:45 <johnw> and "lift" takes on a better meaning too
22:17:46 <FliPPeh> I always need reader and state and to handle a request I shortly need a writer
22:17:57 <FliPPeh> *shortly*
22:18:10 <FliPPeh> I can't bolt on a writer for the whole duration of the program, it makes no sense :D
22:18:11 <c_wraith> briefly?
22:18:16 <FliPPeh> Yes
22:18:47 <FliPPeh> I read a request and briefly run a writer which result will be the responses to send back
22:19:05 <FliPPeh> The writer is just a small part that's used *sometimes*
22:19:17 <FliPPeh> While the state and reader are essential all the time
22:20:04 <johnw> so you want the Writer to be "scoped" over certain parts of the runtime, but Reader and State to persist throughout the app?
22:20:15 <FliPPeh> That's why my question was about RWSRT, which would be (RW: request context, SRT: program context)
22:20:43 <FliPPeh> I think that's a pretty good summary of what I'm trying to do
22:20:59 <johnw> you could make an RST monad then, and use WriterT over it in places
22:21:20 <FliPPeh> Incoming request => run writer with access to program state
22:21:28 <lightquake> is there a way to generate a hoogle database for all the packages I have installed?
22:21:29 <FliPPeh> That's what I'm doing right now and that works nicely
22:21:30 <FliPPeh> But!
22:21:36 <johnw> but I'd probably start out by using RWST and not using the writer part, and then use WriterT over that as needed
22:21:39 <johnw> lightquake: yes!
22:21:42 <FliPPeh> Now I want to make the request context implicit
22:21:51 <johnw> lightquake: here's my script: https://gist.github.com/8079027
22:21:55 <FliPPeh> Have it in a reader for the request handler
22:22:29 <lightquake> johnw: what's rehoo?
22:22:32 <FliPPeh> johnw: How would that work? You can only get back what has been written in the writer when the writer has evaluated which will not happen until the end of my program with RWST
22:22:38 <johnw> it effeciently combines many .hoo files
22:23:03 <johnw> FliPPeh: the type would be: WriterT w (RWST ...) a
22:23:24 <johnw> i'm just saying, you could code with that type now, and then later change to RST if the performance matters
22:23:35 <FliPPeh> But I don't need the W of RWST if I wrap it inside WriterT anyways :>
22:23:43 <johnw> yes, I know
22:23:52 <FliPPeh> Or you mean for readability?
22:24:01 <johnw> just for ease of trying out the approach
22:24:05 <johnw> RWST is there, it works
22:24:12 <johnw> writing a proper RST will be pretty trivial, but won't take zero time
22:30:34 <dmwit> FliPPeh: Why are you not just using RWST and listen?
22:30:49 <FliPPeh> :t listen
22:30:50 <lambdabot> MonadWriter w m => m a -> m (a, w)
22:31:56 <FliPPeh> so listen runs a function in the same WriterT "instance" and returns it while staying the that writer?
22:31:58 <johnw> the scope of RWST would be too long
22:32:02 <FliPPeh> where it = the written?
22:32:09 <dmwit> FliPPeh: yep
22:32:30 <FliPPeh> Okay, that solves the unused W part of RWST
22:32:53 <FliPPeh> still doesn't solve the problem I have
22:33:16 <dmwit> O
22:33:19 <FliPPeh> Well "problem" is the wrong word
22:33:31 <FliPPeh> I just want to make the whole thing a bit nicer
22:34:07 <FliPPeh> Separate the request handling and response into a RW monad on top of my program core RST monad
22:34:39 <dmwit> uh
22:34:46 <FliPPeh> Where the request and response RW servers as a context for both the current request and the response to send and the RST of my program serves as static runtime configuration and state on top of IO
22:34:48 <dmwit> Can you make the reequest handling and response polymorphic?
22:35:00 <maurer> Hey, if I'm considering doing a webapp in haskell, do people have opnions on happstack vs yesod vs snap?
22:35:09 <dmwit> e.g. :: (MonadReader r m, MonadWriter w m) => m a instead of :: ReaderT r (WriterT m) a
22:35:11 <FliPPeh> Maybe I can if I knew what that meant :x
22:35:21 <maurer> So far the only real opinion I've formed is that yesod seems to super overuse TH to the point where I'm worried about understanding what's actually going on
22:35:26 <FliPPeh> Hm
22:35:53 <zRecursive> So i like Snap more ...
22:35:54 <FliPPeh> maurer: Don't even try to understand what's going on in Yesod
22:35:57 <dmwit> Later you can pick what monumental monad implements all that junk. Perhaps using lenses to make that monumental monad happen to be your program's monad.
22:36:11 <maurer> FliPPeh: Yeah, that kind of comment is the kind of reason I'm thinking maybe I don't want to use it
22:36:31 <FliPPeh> Although to be fair
22:36:40 <FliPPeh> If I were to write a website in Haskell it would be in Yesod
22:37:50 <zRecursive> I am not used to TH :(
22:43:28 <jle`> TH loses its mystery a little when you realize that it's just replacing boilerplate code you would write yourself
22:43:47 <jle`> and use it a few times
22:45:33 <zRecursive> jle`: same as macro in CL ?
22:46:20 <Platz> what about simple stuff, is just Wai by itself feasible. based on benchmarks it's pretty fast
22:46:30 <nisstyre> zRecursive: I think TH macros are unhygienic yeah, but obviously they do not use s-expressions
22:47:20 <zRecursive> nisstyre: thx
22:55:29 <enthropy> nisstyre: if you're getting names in the TH like 'xyz or [| xyz |], it's hygenic
22:56:19 <enthropy> as in, you don't need an xyz in scope when you run the TH
22:57:10 <enthropy> but of course you could do   dyn "xyz", and get whatever xyz is in scope later on
23:01:14 <nisstyre> enthropy: hygienic means you can't use identifiers in the macro if they aren't already in scope, and you can't create new bindings in the macro and expect them to be usable outside the macro
23:02:46 <enthropy> ok so if you restrict yourself to Exp splices, and ban dyn, mkName, I think you have those properties
23:02:53 <nisstyre> probably yeah
23:03:02 <nisstyre> Racket solves this using something called syntax parameters
23:03:17 <nisstyre> they're sort of like dynamic scope for macros, but you get an exception if you use them before they're "initialized"
23:03:45 <enthropy> what do you mean by "solves" this?
23:04:57 <nisstyre> enthropy: the problem of having hygiene while still being able to write "anaphoric" macros
23:04:59 <enthropy> you still want the option to do dynamic binding no?
23:05:25 <nisstyre> http://www.schemeworkshop.org/2011/papers/Barzilay2011.pdf
23:07:23 <zRecursive> It is almostly enough to use gensym in CL
23:14:12 <FliPPeh> @pl any (`elem` arg) " :"
23:14:13 <lambdabot> any (`elem` arg) " :"
23:14:25 <FliPPeh> @pl foo arg = any (`elem` arg) " :"
23:14:25 <lambdabot> foo = flip any " :" . flip elem
23:14:36 <FliPPeh> Maybe not
23:22:39 * hackagebot unix-process-conduit 0.2.2.2 - Run processes on Unix systems, with a conduit interface  http://hackage.haskell.org/package/unix-process-conduit-0.2.2.2 (MichaelSnoyman)
23:32:40 * hackagebot persistent-postgresql 1.2.1.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.2.1.1 (MichaelSnoyman)
23:32:58 <maurer> Does anyone know a way to make either of cabal-dev or cabal sandbox ignore the system and user packages (other than things like base which can't be reinstalled)
23:33:17 <shachaf> It's not only base.
23:33:33 <maurer> thus things-like
23:33:53 <maurer> but the point being that I was hoping to not use the system version of random things I have installed in this build
23:34:01 <maurer> and would prefer to not have to uninstall them to get this effect
23:34:02 <shachaf> Oh.
23:34:27 <FliPPeh> I keep writing my own supposedly fancy modules and then later I find a function from a standard module that  does it all. I love it. I just replaced every single function in my module with a wrapper around Data.Map.alter.
23:38:11 <maurer> shachaf: Basically I want it to do the equivalent of emerge -e when it builds my package
23:38:15 <maurer> shachaf: Is there a way to achieve htis?
23:38:16 <maurer> *this
23:38:25 <shachaf> I don't know. I've never used cabal-sandbox or cabal-dev.
23:43:32 <Aetherspawn> How do I add constraints to data?
23:43:57 <Aetherspawn> can I do data (Monoid m) => X m = A m | B m ?
23:48:55 <johnw> Aetherspawn: put it on the functions which use X and actually need Monoid
23:49:54 <jle`> there's a ghc extension to allow it i think, but it was very quickly dis-encouraged and generally considered a bad idea
23:50:02 <jle`> dis-encouraged?
23:50:04 <jle`> discouraged?
23:50:20 <jle`> i want a word that means more like un-encouraged than discouraged though. oh well
23:51:22 <johnw> deprecated?
23:52:52 <jle`> ah that is perfect
23:55:43 <Aetherspawn> hmm
