00:06:29 <dmwit> You can f (unOuter -> Inner x y) with suitable extensions and unOuter definition.
00:18:04 * hackagebot easyrender 0.1.0.0 - User-friendly creation of EPS, PostScript, and PDF files  http://hackage.haskell.org/package/easyrender-0.1.0.0 (PeterSelinger)
00:18:04 * hackagebot DAV 0.6 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-0.6 (ClintAdams)
00:22:59 * hackagebot http2 0.0.1 - HTTP/2.0 library including HPACK  http://hackage.haskell.org/package/http2-0.0.1 (KazuYamamoto)
00:26:26 <ion> “Many modules are exported for debugging purpose only. Please don't import them.” I found that somehow funny.
00:39:10 <lama> is there a way to convert text into PersistObjectId
00:39:51 <lama> text is in this format "PersistObjectId "R\171\CAN\190\&8X\246Et\NUL\NUL\EM""
00:42:54 <ion> Apply PersistentObjectId to it.
01:07:41 <lama> ion, you mean PersistObjectId
01:18:29 <jg__> hi all. i defined a newtype DateTimeString = DateTimeString String. Now i'd want to export both this type and the type constructor from a module. Exporting only DateTimeString doesn't seem to do that. What's the right way to go?
01:18:51 <quicksilver> jg__: DateTimeString(DateTimeString)
01:18:57 <quicksilver> or DateTimeString(..)
01:20:05 <jg__> quicksilver: is there a place where i could possibly look up such stuff in the future? a readable Haskell syntax reference?
01:24:21 <quicksilver> jg__: The language report is not too bad, it has examples etc - http://www.haskell.org/onlinereport/modules.html
01:25:01 <jg__> quicksilver: cool, many thanks
01:43:09 * hackagebot aws-sdk-text-converter 0.3 - The text converter for aws-sdk.  http://hackage.haskell.org/package/aws-sdk-text-converter-0.3 (YusukeNomura)
01:58:46 <PTBD> hello. what am I doing wrong here? I try: twice f = f . f     and it works. but twice f x = f . f x     doesn't work.
01:59:48 <tovarish> PTBD, it look slike you need recursive type to do that
01:59:55 <tovarish> but haskell refuse recursiove types
02:00:01 <tovarish> (never find an option to enable it)
02:00:15 <Taneb> PTBD, ignore tovarish, the answer's simpler than that
02:00:20 <Taneb> Try "f . f $ x"
02:00:30 <Taneb> Or "(f . f) x"
02:00:34 <Taneb> tovarish, sorry
02:00:39 <quicksilver> I would say (f . f) x
02:00:44 <quicksilver> that explains the problem more clearly
02:00:48 <PTBD> Taneb, yes that works
02:00:52 <quicksilver> it's just a bracketing (precedence) problem
02:00:56 <tovarish> Taneb, pls I don't say bullshit
02:01:14 <tovarish> bnut yes, you're right, it's what (s?)he is looking for
02:01:22 <quicksilver> tovarish: he didn't. He just said to ignore you, because you were wrong in this case.
02:01:32 <tovarish> sorry I was right
02:01:45 <tovarish> i parse it as f x = f . (f x) which need rec type to be possible
02:01:51 <Taneb> You had misread the question, the assumption was the two definitions of twice would be the same
02:01:52 <PTBD> don't fight just because of my silly questions ;)
02:02:24 <quicksilver> tovarish: the question made it clear that he wanted the thing equivalent to "twice f = f . f"
02:02:38 <tovarish> no for me it wasn't
02:02:45 <quicksilver> if you want recursive types in haskell the simplest way is to use an expicit 'data' to tag the recursion.
02:02:47 <tovarish> I often encounter case where the type system was limited
02:02:58 <tovarish> end rectype remove the limitation
02:03:12 * hackagebot data-size 0.1.0.3 - Profiling of data structures  http://hackage.haskell.org/package/data-size-0.1.0.3 (UweSchmidt)
02:07:17 <maybefbi> how do I write zcat :: Conduit FilePath IO ByteString ? whenever I await a filePath, and then give it to sourceFile I get the no instance of MonadResource/MonadBaseControl error
02:08:57 <maybefbi> cat :: FilePath IO ByteString
02:10:59 <Fuuzetsu> Hey guys, check this out: http://fuuzetsu.co.uk/images/case-split-s.gif , I feel pretty good about this (although it's still very, very hacky!)
02:12:22 <maybefbi> Fuuzetsu: what kind of sorcery is this?
02:12:31 <Fuuzetsu> black magic
02:12:36 <maybefbi> :D
02:12:51 <quicksilver> Fuuzetsu: that is pretty cool yes :)
02:13:42 <maybefbi> Fuuzetsu: emacs/vim?
02:13:53 <donri> looks like sublime
02:14:13 <PTBD> hope I may ask another stupid question for a problem I don't understand. I have the function: twice = (.)      and twice (+1) (+1) 3 does work. but twice (+1) (-1) 2 does not.
02:15:02 <maybefbi> PTBD: is there a typo in what you typed?
02:15:10 <Fuuzetsu> maybefbi: Neither! Yi.
02:15:20 <Fuuzetsu> donri: Perhaps because of
02:15:24 <Fuuzetsu> @hackage yi-monokai
02:15:24 <lambdabot> http://hackage.haskell.org/package/yi-monokai
02:15:30 <donri> Fuuzetsu: i was going by the tabs
02:15:33 <maybefbi> Fuuzetsu: i see
02:15:38 <PTBD> maybefbi, I don't see one
02:15:39 <dv-> > ((+2) . (+(-1))) 3
02:15:40 <lambdabot>  4
02:16:06 <Fuuzetsu> donri: I haven't figured out how to get rid of them yet but considering they seem to preserve buffer layout, I might actually use them in the future.
02:16:22 <Fuuzetsu> maybefbi: I was going to write it for emacs but meh
02:16:38 <Fuuzetsu> It needs a lot of polish first, it's very fragile
02:17:03 <quicksilver> PTBD: because (-1) is not like (+1)
02:17:10 <dv-> PTBD: (-1) is negative 1, not \x -> x - 1
02:17:11 <quicksilver> PTBD: which is annoying
02:17:22 <quicksilver> PTBD: try twice (+1) (subtract 1) 2
02:18:04 <maybefbi> Fuuzetsu: Gotta install yi I guess
02:18:47 <PTBD> I see. but if (-1) is the function to negate. shouldn't "(-1) 3" give me -3?
02:19:02 <quicksilver> (-1) isn't a function at all
02:19:05 <dv-> :t (-1)
02:19:06 <quicksilver> it's just a number
02:19:06 <lambdabot> Num a => a
02:19:07 <dv-> :t negate
02:19:08 <lambdabot> Num a => a -> a
02:19:21 <PTBD> ok. than I misread the type
02:19:31 <quicksilver> <pedant>unless you have a Num instance for functions, but normally you don't</pedant>
02:19:36 <dmj`> > 5 * do 4 + 4
02:19:38 <lambdabot>  40
02:19:41 <dmj`> how is that possible?
02:20:10 <dmj`> > do 4 - 4 * do 3 + 3
02:20:11 <lambdabot>  -20
02:20:34 <PTBD> thanks for all your help
02:20:55 <solarus> a do with only one line desugars to that one line without any bind etc
02:20:57 <quicksilver> dmj`: in general "do <expression>" is just the same as <expression>
02:21:18 <quicksilver> dmj`: for example, (do putStrLn "hi") is the same as (putStrLn "hi")
02:21:33 <dmj`> quicksilver: 4 * 4 is a pure function, not inside any monad
02:21:33 <quicksilver> the report is not completely clear if you should be allowed to use do with types which are not monad instances
02:21:34 <donri> dmj`: no different from bla $ do ...
02:21:42 <quicksilver> but GHC has always allowed it.
02:21:44 <donri> i guess it's the types that trip you up
02:21:50 <dmj`> do implies monadic context
02:21:53 <mr-> dmj`: also, the parentheses are do 4 - (4 * do 3+3), I think
02:22:00 <quicksilver> it implies it but does not require it
02:22:02 <quicksilver> in GHC at least
02:22:27 <quicksilver> it's just a little illogical corner in the syntax
02:23:34 <donri> does the desugarer run before the type checker? could it even type check the expression at that point?
02:23:46 <donri> i guess it could desugar to return () >> expr  :P
02:24:16 <donri> > return () >> 4 + 4
02:24:17 <lambdabot>  No instance for (GHC.Show.Show (m0 b0))
02:24:17 <lambdabot>    arising from a use of `M21546732458513654717219.show_M21546732458513654717...
02:24:17 <lambdabot>  The type variables `m0', `b0' are ambiguous
02:24:17 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
02:24:17 <lambdabot>  Note: there are several potential instances:
03:01:08 <piezo> hi
03:01:13 <piezo> does it make sense to parse an AST with ParsecT s u (Free AstF) ?
03:02:47 <piezo> i'm guessing the syntax should follow a monadic structure
03:03:19 * hackagebot haskell-names 0.3.2.3 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.3.2.3 (RomanCheplyaka)
03:04:23 <piezo> i think it can't parse "a + b" (but maybe "(+ a b)")
03:08:20 * hackagebot ampersand 3.0.0 - Toolsuite for automated design of business processes.  http://hackage.haskell.org/package/ampersand-3.0.0 (hanjoosten)
03:13:21 * hackagebot approx-rand-test 0.2.1 - Approximate randomization test  http://hackage.haskell.org/package/approx-rand-test-0.2.1 (DanielDeKok)
03:18:21 * hackagebot string-conversions 0.3.0.1 - Simplifies dealing with different types for strings  http://hackage.haskell.org/package/string-conversions-0.3.0.1 (SoenkeHahn)
03:28:23 * hackagebot hslogstash 0.3.4 - A library to work with, or as, a logstash server  http://hackage.haskell.org/package/hslogstash-0.3.4 (SimonMarechal)
03:49:53 <augur> hm. i wonder if it'd be possible to extend the HasField stuff in a nice way to allow partiality automatically
03:50:34 <augur> like a type that has the field "foo" but not for every construction should really have some variable of foo thats partial
03:50:39 <augur> but this really should be generically derived
03:50:57 <augur> like try_foo :: r { foo :: a } -> Maybe a
03:51:07 <augur> i dont know how you'd derive it generically, but
03:51:31 <augur> it seems like something that ought to be doable, and indeed, desirable
03:57:27 <bourbaki> Greetings
03:57:47 <bourbaki> Im having a bit of a trouble with updating cabal on Windows / Cygwin.
03:58:10 <quicksilver> augur: well you can't turn "old-fashioned" undefined-based partiality into Maybe, that's non-monotonic
03:58:32 <quicksilver> augur: better just to have a bit more sugar or some combinators around fields of Maybe type?
03:58:42 <bourbaki> Uh?
03:58:48 <bourbaki> Well nm ... it works now...
03:59:05 <bourbaki> It didnt yesterday maybe a reboot was all it needed.
03:59:29 <augur> quicksilver: right, thats why it would need to be built in somehow
03:59:51 <bourbaki> What needs to be built in?
03:59:59 <augur> quicksilver: you can derive the unsafe version from the safe version, obviously
04:00:07 <augur> bourbaki: partiality in row polymorphism
04:05:50 <quicksilver> augur: it woulud be wrong, even built-in.
04:06:01 <quicksilver> augur: monotonicity is not just for show, it matters!
04:06:16 <augur> quicksilver: what?
04:06:34 <augur> quicksilver: no, i said you can do the other way around
04:06:45 <augur> turning Maybe-partiality into undefined-based partiality
04:06:55 <augur> by doing foo = fromJust.try_foo
04:07:44 <quicksilver> augur: right
04:08:11 <quicksilver> augur: you also said "that's why it would need to be built in". Probably I misundersood what you were referring to by 'it'.
04:08:24 <augur> quicksilver: yes, the Maybe thing would have to be built in
04:08:42 <augur> since you cant produce it with a user-defined class
04:09:46 <Taneb> I wrote this and I have no idea how it works: http://lpaste.net/97121
04:10:34 <augur> Taneb: attaboy!
04:10:57 <augur> Taneb: oh, is the loeb thing confusing, or is that sensible and the rest is wonky?
04:11:05 <Taneb> augur, the latter
04:12:28 <augur> Taneb: whats it supposed to do, in principle?
04:12:35 <Taneb> augur, calculate collatz lengths
04:12:42 <augur> collatz, eugh
04:12:46 <augur> dunno it, sounds horrible
04:25:36 <danilo2> Hello! Is it possible to pass flags during configuration step to packages when using cabal sandbox? I'm using cabal "sandbox add-source" to register a library. How can I configure it with some flags?
04:27:23 <Raydiation> hi, whats confluence? if something can be solved with outermost reduction, it can also be solved with innermost? but not the other way round?
04:28:05 <jmcarthur> Taneb: loeb x = let y = V.map ($ y) x in y
04:28:38 <jmcarthur> Taneb: from what i've seen that doesn't make a huge performance difference in practice, but it feels better to me anyway
04:28:53 <jmcarthur> (i'm not entirely sure why the difference isn't huge though)
04:48:20 <Taneb> jmcarthur, that's doubled the speed (on my not very intensive test)
04:48:31 <jmcarthur> ah nice
04:50:53 <Taneb> jmcarthur, on larger tests, it is much faster :)
04:51:13 <jmcarthur> okay, then i stand corrected and am pleased with the results
04:51:27 <Taneb> 6 or 7 times
04:52:12 <jmcarthur> it's just that i had suggested the same improvement for somebody else before and they reported no real speedup at all. that's what i get for trusting others ;)
04:52:28 <Taneb> Maybe it depends on the rest of the code, or even the underlying functor
04:52:47 <jmcarthur> it probably just depends on how much sharing actually helps
04:58:34 * hackagebot OpenAL 1.5.0.0 - A binding to the OpenAL cross-platform 3D audio API  http://hackage.haskell.org/package/OpenAL-1.5.0.0 (SvenPanne)
04:58:36 * hackagebot ALUT 2.3.0.0 - A binding for the OpenAL Utility Toolkit  http://hackage.haskell.org/package/ALUT-2.3.0.0 (SvenPanne)
05:00:21 <aristid> Taneb: i wonder if you could get that to work with unboxed vectors:D
05:01:13 <Taneb> aristid, it'd be difficult
05:01:28 <Taneb> I'd have to manually rejig loeb into the program
05:01:50 <aristid> Taneb: hmm yeah i guess it does rely on laziness
05:03:34 * hackagebot postgresql-simple 0.3.10.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.3.10.0 (LeonSmith)
05:12:12 <nominolo> Fuuzetsu: I'm around now
05:12:37 <nominolo> Fuuzetsu: PM me your email address (and if you want a different username)
05:13:16 <nominolo> @localtime Fuuzetsu
05:13:17 <lambdabot> Local time for Fuuzetsu is Tue Dec 17 13:02:26 2013
05:15:37 <Fuuzetsu> nominolo: fuuzetsu@fuuzetsu.co.uk
05:16:00 <Fuuzetsu> You barely caught me, was just going to sleep.
05:16:36 <BoR0> for a monoid, we have that it has to support 3 properties: close, associativity and identity. e.g. if we look at the monoid ([Int], ++, []): I can see identity as base case ([]), closure as [Int] ++ [Int] should produce an [Int], but what is associativity's role? or should I ask what is associativity's usefulness?
05:16:47 <BoR0> closure*
05:17:29 <nominolo> Fuuzetsu: password in email, I suggest you change it at some point.  Good night!
05:18:05 <nominolo> sorry for the noise
05:18:07 <Fuuzetsu> BoR0: [a] ++ ([a] ++ [a]) ≡ ([a] ++ [a]) ++ [a]… doesn't this look useful? For example, we're free to do the operations in any order which means that we can very easily parallelise it
05:18:11 <Fuuzetsu> nominolo: Thanks!
05:18:32 <BoR0> so associativity allows us to do parallelism?
05:18:34 <BoR0> (in general)
05:18:56 <nominolo> BoR0: yes.  Guy Steele gave a nice talk on this
05:19:13 <BoR0> cool. can you please link to that?
05:19:19 <Fuuzetsu> BoR0: Sure, that's one use. There's a paper somewhere on monoids in use for MapReduce algorithms
05:19:58 <nominolo> BoR0: http://www.infoq.com/presentations/Thinking-Parallel-Programming  I think it gets interesting in the second half
05:20:22 <BoR0> thanks both of you, I will check that, and also the relation with MapReduce algo
05:21:31 <quchen> 24 days used to be informative, this time it's also beautiful!
05:21:35 <quchen> http://ocharles.org.uk/blog/img/2013-12-16-festive-ocharles.png
05:21:56 <quchen> Oh, ocharles isn't online :-(
05:22:45 <bergmark> :-)
05:22:48 <nominolo> BoR0: and Monoids are all about an associative operation.  Here're some ideas for thinking monoidically: http://comonad.com/reader/2009/hac-phi-slides/
05:26:28 <mr-> quchen: it would be awesome if every module contained a 24-days-style-article as part of its documentation!
05:29:51 <Taneb> aristid, I managed to convert to Unboxed vectors, but it just gives <<loop>>
05:29:57 <Taneb> boxed vectors work fine with the same code
05:31:33 <Taneb> Storable gives loop, too
05:34:43 <Yuu-chan> Is it possible to make composable wordy numerals in code? So that "two", "two hundred" and "two hundred thousand" could be converted to corresponding numbers
05:35:24 <tdammers> Yuu-chan: yes. It's a nice little exercise.
05:35:26 <Hodapp> I suppose you could, but that sounds like intentional self-flagellation.
05:35:34 <Fuuzetsu> Yes but it's pretty tedious, especially if you need a really big range. There's almost certainly a lib for this already
05:36:40 <Yuu-chan> I mean not converting from strings, but placing directly in code
05:36:54 <Yuu-chan> E.g. one hundred + fourteen thousand
05:37:18 <tdammers> no, that won't work
05:37:30 <tdammers> or at least, I don't see how
05:37:33 <Fuuzetsu> maybe with Template Haskell or something but WHY
05:37:42 <Yuu-chan> I thought of some extensions
05:38:03 <Yuu-chan> Fuuzetsu: just a nice little exercise ;)
05:38:22 <tdammers> You could probably get to [n|one hundred and sixty-three|] + [n|ten million and one|]
05:38:36 <quicksilver> I think you could probably do that, yes
05:38:40 <donri> @hackage numerals
05:38:40 <lambdabot> http://hackage.haskell.org/package/numerals
05:39:06 <tdammers> but making it such that "one hundred and sixty-three" is valid Haskell syntax and compiles... I don't think that's possible
05:39:18 <quicksilver> tdammers: I think it is :)
05:39:24 <quicksilver> don't have time to prove it, naturally.
05:39:47 <donri> i imagine it could be done, but the type inference for it might suck
05:39:52 <tdammers> quicksilver: then what's the type of 'one'?
05:39:55 <quicksilver> class NumberWord n where one :: n; two :: n; three :: n; .....
05:40:01 <quicksilver> instance NumberWord Int ...
05:40:06 <Yuu-chan> tdammers: I experimented with FlexibleInstances, but my variant required explicit typing
05:40:09 <quicksilver> instance Number (a -> b)
05:40:14 <quicksilver> instance NumberWord (a -> b)
05:40:19 <tdammers> hmm, yes, I thought of that
05:40:27 <Yuu-chan> quicksilver: yes, like that
05:40:29 <tdammers> but I still expect things to be ambiguous at some point
05:40:30 <quicksilver> and probably an instance for some explicit ADT for intermediate calculations
05:40:35 <tdammers> or too generak
05:40:35 <quicksilver> which you can flush to Int at the ned
05:40:41 <tdammers> *general
05:41:02 <tdammers> as in, the compiler should absolutely reject things like "one hundred hundred"
05:41:19 <quicksilver> if you want compile-time errors then yes, possibly that is too hard
05:41:25 <quicksilver> with run-time errors it's fine though
05:41:40 <tdammers> if runtime errors were enough, I'd just do it in python
05:41:46 <quicksilver> :P
05:42:01 <quicksilver> you never write haskell programs with any runtime error conditions?
05:42:05 <quicksilver> you must be chuck norris.
05:42:12 <Yuu-chan> :) I wanted to push it in Haskell extended type system
05:42:21 * Yuu-chan is afk
05:43:01 <donri> tdammers: just throw some type level nats at it :)
05:43:44 <tdammers> quicksilver: meh
05:43:47 * mr- throws Fix Succ
05:43:59 <donri> mr-: type level NaN? :p
05:44:30 <mr-> Who knows :-)
06:03:43 * hackagebot modbus-tcp 0.1 - Communicate with Modbus devices over TCP  http://hackage.haskell.org/package/modbus-tcp-0.1 (RoelVanDijk)
06:08:43 * hackagebot yesod-auth 1.2.4.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.2.4.1 (MichaelSnoyman)
06:17:47 <nomeata> dmwit: hi
06:18:02 <nomeata> dmwit: I received a "request for packaging" for yeganesh for Debian
06:18:23 <nomeata> dmwit: but I’m wondering: Is there a reason why that functionality cannot live in dmenu itself?
06:24:13 <boom583> In imperative programming, I find myself having to think about large portions of my program at the same time. This leads to lack of confidence. I also have to constantly keep re-reading older parts of my program to gain confidence in the again.
06:24:18 <boom583> Does functional programming solve this?
06:24:26 <tdammers> yes.
06:24:33 <boom583> you agree with my problem about imper prog?
06:24:35 <k00mi> nomeata: probably because suckless people don't want all that "bloat" in dmenu
06:24:36 <boom583> it's horrible
06:24:38 <tdammers> no
06:24:42 <boom583> hmok
06:25:01 <tdammers> shared mutable state is bad, but imperative programming can usually avoid most of it
06:25:19 <boom583> ok
06:25:22 <tdammers> you don't need functional programming to keep your scopes small and your interfaces narrow
06:25:26 <geekosaur> nomeata: last time I checked there were several patches to add that functionality to dmenu, none standard and apparently no interest upstream in adding one
06:25:33 <boom583> i c
06:25:37 <tdammers> FP does kind of take it to a new level though, IMO
06:25:52 <nomeata> k00mi: hmm, ok
06:25:55 <Peaker> boom583: I think having to think about too much at same time is more about modularity than about imperative. fp makes modularity much easier, and the common/default style is much more modular
06:26:54 <boom583> ok
06:28:13 <Peaker> there exist modular imperative programs. whenever aliasing is involved, the issue rises though, so non-aliasing (which you get for free in fp but have to work for in imperative) is great for modularity
06:28:47 <boom583> cool
06:28:48 <boom583> thanks
06:30:42 <BoR0> boom583, just go for FP. just learn it, nothing you will lose, only gain
06:30:52 <BoR0> you can still program imperative for your job
06:31:13 <boom583> :)
06:31:19 <boom583> yeah i've ordered LYAH
06:31:39 <BoR0> it is what I am doing. Haskell is great. LYAH is also great, you have a free online version. you will learn a lot
06:35:57 <helmut> is there a way to build a package in parallel? -j to cabal build does not seem to have any effect in the context of a single package.
06:36:57 <L8D> helmut: Builing packages in parallel won’t build them any faster if I’m not mistaken
06:37:11 <tdammers> depends, I guess
06:37:23 <tdammers> if you're I/O bound, going parallel will only make it worse
06:37:31 <k00mi> helmut: not yet, but it's one of the features that will come with ghc 7.8 :)
06:37:32 <donri> helmut: it's coming in the next ghc
06:37:37 <tdammers> CPU-bound, you might win some by using more than one core
06:37:47 <helmut> k00mi: thx. best answer
06:38:07 <L8D> Isn’t GHC already multi-threaded?
06:38:29 <gnuvince> Hi all; I wrote a small Digraph datatype (adjacency list) and a function to test whether a digraph has a cycle.  I tested it on a few hand-crafted examples and it worked, but I was wondering if anyone had any idea how to construct an Arbitrary instance so that I could quickcheck it?
06:38:40 <quicksilver> building has times when it is IO bound so simply multiplexing the IO would be a small win
06:38:54 <quicksilver> building is CPU bound most of the time so multi-coring the CPU is a bigger win.
06:39:12 <quicksilver> parallel build for cabal has been a wishlist feature for years
06:39:17 <donri> gnuvince: one way might be to find a model to compare to, ie. an existing implementation
06:39:19 <quicksilver> I think I read it being worked on recently
06:39:54 <k00mi> quicksilver: cabal can build multiple packages in parallel, yes, but not one package
06:39:59 <L8D> offtopic: Anyone used XMonad here?
06:40:06 <gnuvince> donri: so build random Digraphs, feed it to my algorithm and a known existing algorithm and make sure that they return the same answer?
06:40:14 <tdammers> L8D: yes, and offtopic goes in #haskell-blah
06:40:22 <donri> gnuvince: yeah
06:40:33 <bernalex> L8D: tdammers: there's also #xmonad
06:40:48 <L8D> tdammers: I meant offtopic to the conversation about parallel cabal installs
06:40:52 <tdammers> ah
06:40:53 <tdammers> k
06:42:11 * L8D joins #xmonad
06:49:09 <jophish> Has anyone got OpenGL Profiler working on Mavericks
06:49:16 <Philonous> Why doesn't http://lpaste.net/97130 parse? The xample with the multi-line string literals is even given in the report.
06:49:41 <chrisdone> for all things Emacs and Haskell, come idle in #haskell-emacs =)
06:50:32 <jophish> oops, wrong channel
06:52:13 <rasfar> Philonous: that compiles for me with GHC 7.6.3
06:57:03 <Philonous> rasfar, Strange, thanks
07:07:13 <piezoid> is there a way to use :reload without cleaning the environment if it fails ?
07:08:03 <merijn> piezoid: Yes, but I forgot how. Try the GHC manual chapter on ghci?
07:09:09 <piezoid> my process is: edit, reload, *crap*, comment, reload, types experiments, edit, reload, etc
07:14:20 <haasn> is there a way to use :reload without cleaning the environment if it succeeds?
07:20:24 <merijn> gah, I hate it when my fancy solutions turn out to be broken weeks after I come up with them
07:20:52 <tdammers> that's why it's better to use simple solutions in the first place
07:21:15 <merijn> tdammers: If there was one that didn't suck, I would
07:21:44 <merijn> Any pipes experts willing to weigh in here? https://groups.google.com/forum/?fromgroups#!topic/haskell-pipes/wIsbxcPV3Ok
07:21:59 <aristid> haasn: not losing all the lets would be nice indeed
07:22:05 <lieven_> debugging is harder than programming so you should avoid being too clever when programming :)
07:22:31 <merijn> That design lets me first do a handshake and then return a "Producer Frame m r", but I have no way of obtaining the Consumer I need after the handshake
07:38:54 * hackagebot OpenAL 1.6.0.0 - A binding to the OpenAL cross-platform 3D audio API  http://hackage.haskell.org/package/OpenAL-1.6.0.0 (SvenPanne)
07:38:57 * hackagebot ALUT 2.3.0.1 - A binding for the OpenAL Utility Toolkit  http://hackage.haskell.org/package/ALUT-2.3.0.1 (SvenPanne)
07:48:55 * hackagebot data-size 0.1.0.4 - Profiling of data structures  http://hackage.haskell.org/package/data-size-0.1.0.4 (UweSchmidt)
07:53:30 <d3lxa> has anyone experienced with GHC plugins? I'm wondering if it's possible to add custom type constraints (like in scala macros)
07:55:51 <merijn> d3lxa: What sort of things do you have in mind? You can already write quite fancy restraints in GHC using some extensions
07:56:00 <jaspervd2> So... When I load a file in GHCi 7.6.3, I only get access to the exposed functions in that module.
07:56:21 <jaspervd2> IIRC, you used to also have access to the internal functions defined in that module
07:56:43 <merijn> jaspervd2: Are you using import or :l?
07:56:47 <jaspervd2> Does anybody know whether this changed? Or did I mess up my environment?
07:57:02 <merijn> jaspervd2: import only imports exposed functions, obviously
07:57:02 <Feuerbach> jaspervdj: :l *module.hs perhaps?
07:57:08 <merijn> :l should still do everything
07:57:24 <jaspervdj> merijn: I tried ghci <filename>, :l <filename> and :l *<filename>, same result :-(
07:57:40 <d3lxa> merijn: it seems you cannot enforce types with TH (true?) thus I was looking at GHC plugins (i need to find a concret example then)
07:57:41 <merijn> jaspervdj: Maybe a regression from implementing the import support
07:57:52 <merijn> d3lxa: 7.8 will have typed TH :D
07:58:00 <d3lxa> merijn: oh really?
07:58:14 <merijn> d3lxa: You should already be able to play with it in HEAD
07:58:47 <merijn> d3lxa: http://gmainland.blogspot.nl/2013/05/type-safe-runtime-code-generation-with.html
07:59:19 <Feuerbach> jaspervdj: I'm pretty sure in 7.6.3 it works as always, and gives you access to everything
07:59:30 <Feuerbach> so something wrong with the way you're using it
07:59:37 <jaspervdj> Hmm, cabal repl seems to work. I think I must've messed up my environment.
08:00:15 <d3lxa> merijn: (out of subject: blogspot has localized website? so you are in netherlands? hum)
08:02:02 <d3lxa> wow great, TH now has less problem with stage restriction? seems cool
08:05:10 <merijn> d3lxa: I just went with whatever came up first in my search engine, but yeah I'm in NL
08:09:04 <rasfar> d3lxa: i see you really mean business, heh! i hope you succeed :)
08:15:51 <merijn> Man, is there a proposal for type level holes yet?
08:19:19 <levi> Isn't there something like that already implemented?
08:19:23 <Yuu-chan> Why does my Gloss program fail with "out of memory" when the main window is closed?
08:19:56 <Luke> Yuu-chan: there's a way to increase your heap size
08:20:01 <Luke> ghc or ghci?
08:20:19 <levi> http://www.haskell.org/haskellwiki/GHC/TypeHoles
08:20:30 <Yuu-chan> Luke: both
08:20:48 <Luke> Yuu-chan: perhaps you're just leaking memory
08:21:21 <Luke> I'm not sure what the best tool for analyzing memory usage is. maybe threadscope?
08:21:43 <Yuu-chan> Luke: the game works flawlessly, but prints this when the window is closed (and it should stop anyway)
08:22:28 <Yuu-chan> Luke: by pressing Esc, it stops without problems
08:23:58 <Yuu-chan> Also, mouse wheel actions don't work for me :( Middle button does.
08:25:17 <int-e> Luke: one option is to use +RTS -h  to write a heap profile, which one may look at with hp2ps. Does threadscope have support for heap profiles?
08:25:40 <Luke> int-e: I think it does
08:28:17 <int-e> Luke: at the glance it only supports summary information (as output by +RTS -s)
08:28:29 <Luke> yeah you're right - i was mistaken
08:30:32 <kinslayer> if I want to make a lift of results from a http download with lets say 5 seconds delay between requests, how would I make the delays ?
08:30:40 <kinslayer> make a list*
08:31:25 <Yuu-chan> @hoogle threadDelay
08:31:26 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
08:31:26 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
08:31:26 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
08:31:49 <Rarrikins> @hoogle threadSleep
08:31:50 <lambdabot> No results found
08:31:52 <Yuu-chan> kinslayer: I used this.
08:32:06 <kinslayer> okay is that measured in milliseconds ?
08:32:20 <Yuu-chan> In microseconds
08:32:26 <c_wraith> you chould read the docs...
08:32:30 <c_wraith> *could
08:32:31 <kinslayer> a 1000 = 1 sec ?
08:32:37 <c_wraith> no, microseconds
08:32:42 <kinslayer> so less...
08:32:50 <c_wraith> 1000000 = 1 sec
08:33:03 <kinslayer> okay that is a small unit...
08:33:22 <Rarrikins> http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Concurrent.html#v:threadDelay
08:34:54 <Rarrikins> It would be nice if @hoogle had links to the documentation.
08:35:48 <kinslayer> also I am working in a single treaded env... This doesn't cost me troubles in that setting right ?
08:35:55 <Yuu-chan> @google Control.Concurrent threadDelay
08:35:56 <lambdabot> http://www.haskell.org/ghc/docs/7.6.2/html/libraries/base/Control-Concurrent.html
08:35:56 <lambdabot> Title: Control.Concurrent
08:36:11 <c_wraith> threadDelay works fine in a single-threaded env
08:36:23 <c_wraith> heck, forkIO works fine in a single-threaded env
08:36:30 <Rarrikins> Blah, that lacks the anchor.
08:36:34 <Yuu-chan> kinslayer: a single threaded app is a multithreaded with n=1 ;)
08:36:48 <kinslayer> well sure.. Gotta go to dinner....
08:39:02 <Yuu-chan> kinslayer: anyway, GHC threads /= system threads
09:07:09 <merijn> I have a transformer stack "t m a" that I want to turn into "t (t' m) a", any helpful libraries/ways to do that?
09:09:03 * hackagebot http-client-conduit 0.2.0.1 - Frontend support for using http-client with conduit  http://hackage.haskell.org/package/http-client-conduit-0.2.0.1 (MichaelSnoyman)
09:09:04 <Cale> merijn: This kind of thing is why I recommend pretty much always newtyping any application of a monad transformer
09:09:05 * hackagebot http-client-tls 0.2.0.1 - http-client backend using the connection package and tls library  http://hackage.haskell.org/package/http-client-tls-0.2.0.1 (MichaelSnoyman)
09:09:07 * hackagebot http-conduit 2.0.0.3 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.0.0.3 (MichaelSnoyman)
09:09:35 <merijn> Cale: How would that help this situation?
09:09:37 <Cale> merijn: (So that the number of places where you have to adjust the lifts is limited when you change the implementation of your monad)
09:10:15 <merijn> Actually, I mind be able to RankNTypes my problem away
09:10:19 <danilo2> Hello! I want to ask you why something like this (http://lpaste.net/97134) is not available in any library (even here: http://hackage.haskell.org/package/tuple-0.2.0.1). Nobody ever wanted to map functions over homegous tuples? I know we can use arrows etc,  but they are much less readible
09:10:26 <Cale> If you have a bunch of lifts mixed into the client code for your monad, then it can become a big mess
09:10:39 <skypers_> I’ve been wondering
09:10:44 <merijn> Essentially I have a transformer polymorphic in the base monad that I'm trying to use with two different base monads
09:10:47 <skypers_> in standard GUI, we have “callbacks”
09:11:10 <skypers_> in FRP GUI, there’re event streams, but when an event “changes”, is there a callback that change the event stream?
09:11:15 <merijn> I figured I'd lift it by hand, but maybe I can get away with "forall m . Monad m => MyT m a" as argument to my function
09:11:23 <skypers_> changes*
09:11:32 <merijn> skypers_: There's no such thing as an event that changes
09:11:38 <Cale> danilo2: It's pretty rare to work with anything larger than pairs, and it's rarer still to work with tuples whose components all have the same type
09:11:51 <skypers_> merijn: well
09:11:59 <Cale> merijn: You can have a Behaviour of an Event
09:12:15 <skypers_> imagine that can create an event
09:12:17 <merijn> Cale: Sure, but that's not a changing event. That's an event that varies over time
09:12:26 <skypers_> it has to be repercuted somewhere
09:12:38 <skypers_> merijn: that’s quite the definition
09:12:39 <Cale> heh, I'm not sure what's meant by changing event if not that
09:12:42 <merijn> I suspect this question comes from conflating the FRP model with implementation
09:12:44 <danilo2> Cale: unless you are working with Accelerate, where you can for example decompose colors into arrays of homogenous tuples
09:13:02 <skypers_> merijn: I have my very own
09:13:05 <skypers_> FRP.Reactant
09:13:12 <Cale> danilo2: There's probably some way to do this with lens
09:13:20 <skypers_> I’m trying to figure it out how to make it work in concurrent threads
09:13:24 <merijn> skypers_: You're working on your own FRP implementation you mean?
09:13:29 <skypers_> and I just don’t get it
09:13:30 <skypers_> merijn: yeah
09:13:38 <skypers_> https://github.com/skypers/reactant
09:13:38 <merijn> skypers_: Have you read the Push-Pull Reactive Programming paper?
09:13:43 <Cale> In fact, there is, I remember it now :)
09:13:48 <skypers_> heard of that
09:13:51 <merijn> skypers_: http://conal.net/papers/push-pull-frp/
09:13:55 <Cale> > over each (*10) (1,2,3)
09:13:57 <lambdabot>  (10,20,30)
09:14:04 <skypers_> yeah, jmcarthur_mobile told me about that
09:14:06 <Cale> > over each (*10) (1,2,3,4,5)
09:14:08 <lambdabot>  (10,20,30,40,50)
09:14:25 <rasfar> nice
09:14:27 <merijn> skypers_: Very worth the read, it discusses the formal model and possible implementations
09:14:27 <stephenmac7> Is there any language that compiles to javascript that's a little more like haskell?
09:14:31 <danilo2> Cale: hmm, I would love to see this using lenses. Btw. could you tell me if I'm wrong or not - If I'm using such solution (with UndecidableInstances) - it is completely safe (if user will not declare custom instances) AND it does not affect in any way the performance of resulted binary?
09:14:38 <Cale> danilo2: ^^ see above
09:14:40 <merijn> stephenmac7: Haskell can compile to javascript :)
09:14:43 <danilo2> Cale: wow
09:14:50 <stephenmac7> merijn: I meant a mature project
09:14:52 <merijn> stephenmac7: With 7.8 we will have production ready support of ghcjs
09:15:04 <danilo2> Cale: thank you! I was searching for this the whole life! :D
09:15:30 <merijn> stephenmac7: Well, UHC can already compile to haskell. Other than that we have some other haskell inspired languages that compile to JS, but those can't run all haskell code
09:15:30 <rasfar> stephenmac7: have you checked out Elm?
09:15:38 <Cale> over (each . each) toUpper ("hello", "world")
09:15:40 <Cale> > over (each . each) toUpper ("hello", "world")
09:15:41 <lambdabot>  ("HELLO","WORLD")
09:15:47 <stephenmac7> rasfar: Yes
09:15:53 <Cale> > over each (*10) [1,2,3,4,5]
09:15:55 <lambdabot>  [10,20,30,40,50]
09:16:14 <rasfar> what did you think? i'm considering trying to reimplement my "portackage" using Elm...
09:16:32 <stephenmac7> rasfar: It feels incomplete
09:16:34 <Cale> > over each toUpper (Data.Text.pack "hello")
09:16:35 <lambdabot>  Not in scope: `Data.Text.pack'
09:16:44 <donri> > over template (*10) (1,2,3)
09:16:45 <lambdabot>  (10,20,30)
09:16:50 <skypers_> merijn: I just try to understand how I could transpose it into concurrent threads
09:17:01 <skypers_> where the Event would come from?
09:17:06 <stephenmac7> rasfar: Also seems to be targeted to FRP
09:17:06 <donri> > over template succ (1,2,3'4','5','6')
09:17:07 <lambdabot>  Could not deduce (Data.Typeable.Internal.Typeable a0)
09:17:07 <lambdabot>    arising from a use of `Data.Data.Lens.template'
09:17:07 <lambdabot>  from the context (Data.Data.Data t,
09:17:07 <lambdabot>                    Data.Data.Data t1,
09:17:07 <lambdabot>                    Data.Data.Data t2,
09:17:10 <donri> :P
09:17:20 <Cale> 3'4'
09:17:21 <rasfar> yeah, that makes sense
09:17:30 <Cale> > over template succ (1,2,3,'4','5','6')
09:17:32 <lambdabot>  Could not deduce (Data.Typeable.Internal.Typeable a0)
09:17:32 <lambdabot>    arising from a use of `Data.Data.Lens.template'
09:17:32 <lambdabot>  from the context (Data.Data.Data t,
09:17:32 <lambdabot>                    Data.Data.Data t1,
09:17:32 <lambdabot>                    Data.Data.Data t2,
09:17:39 <Cale> okay
09:17:41 <Cale> heh
09:17:42 <rasfar> looking into FRP was how I came across Elm
09:17:45 <danilo2> Cale: Thank you for this lens solution. It is super cool :)
09:17:49 <stephenmac7> merijn: rasfar: Thanks
09:17:55 <skypers_> in my lib, I can build reactive value from Event (I called them… Reactive, not Behavior, but I think it’s quite the same thing)
09:17:59 <skypers_> then, I have a function called at
09:18:01 <monochrom> "mature" is subjective. you can keep raising the bar until nothing satisfies you so as to get stuck. great way to be productive, yeah?
09:18:04 <skypers_> that takes a Reactive
09:18:06 <skypers_> a time
09:18:10 <donri> Cale: would need existential i imagine?
09:18:11 <skypers_> and returns the value at that time
09:18:16 <skypers_> it’s quite okay to me
09:18:18 <supki> > (1,2,3,'4','5','6') & template %~ (succ :: Integer -> Integer)
09:18:19 <lambdabot>  (2,3,4,'4','5','6')
09:18:25 <skypers_> but I don’t see where I could get the events from
09:18:29 <stephenmac7> monochrom: I mean something for production use
09:18:30 <Cale> Right, it's just the type
09:18:33 <donri> > succ '4'
09:18:34 <lambdabot>  '5'
09:18:38 <Cale> GHC won't infer a polytype
09:18:42 <skypers_> because in order to build te reactive, I need to fetch the events from something
09:18:43 <stephenmac7> That's not going to die out in a year
09:18:44 <monochrom> I for one, when I learned Haskell, Haskell itself was not even "mature". but I stayed. now it's mature.
09:18:58 <skypers_> any one?
09:19:03 <Cale> I think there might've been some way using the generics stuff...
09:19:30 <stephenmac7> monochrom: True, but there were probably many other languages at the time that people learned and became defunct
09:19:42 <stephenmac7> You were just lucky to pick the right one to learn :)
09:19:45 <rasfar> so many good things are coming with GHC 6.8, is there any plans for a JVM target?
09:19:59 <osa1> are there any differences between data constructors and functions?
09:20:08 <skypers_> yes
09:20:08 <donri> you can pattern match on data constructors
09:20:13 <skypers_> what donri said
09:20:39 <osa1> well yeah
09:20:58 <rasfar> *GHC 7.8 i mean
09:21:20 <alpounet> rasfar: not in GHC
09:21:31 <alpounet> and ther Haskell-on-JVM projects are all abandonned AFAIK
09:21:32 <Cale> skypers_: Do you have some primitive way to get an event whose sole occurrence is at a particular time?
09:21:41 <rasfar> is UHC here to stay do you think? maybe that's not a nice question, but it is pertinent...
09:21:53 <alpounet> rasfar: there's Frege however that you may want to check out
09:21:58 <Cale> skypers_: You presumably have some way to take an event and a behaviour and capture the value of the behaviour at each occurrence of the event?
09:22:16 <skypers_> hm, no, but I can implement it easily
09:22:20 <skypers_> actually
09:22:25 <skypers_> I have a function that takes a value
09:22:29 <rasfar> alpounet, thanks (i am mainly asking for stephenmac7)
09:22:34 <skypers_> and collect the events applied
09:22:36 <skypers_> (accumE)
09:22:45 <Cale> skypers_: (You might find my way of thinking about things a bit weird, because I've spent a lot of time with a very particular FRP system that only a handful of people had access to)
09:23:00 <skypers_> Cale: which one?
09:23:12 <Cale> skypers_: Our internal arrowy FRP system at iPwn.
09:23:16 <merijn> Cale: I was right that I could avoid having to lift the inner monad (on account of my input being polymorphic in the base monad), but this RankN solution seems a bit overkill: http://lpaste.net/97135
09:23:19 <skypers_> I actually started from reactive-banana
09:23:21 <stephenmac7> alpounet: Interesting... Frege
09:23:27 <skypers_> but mine is quite different
09:23:35 <skypers_> I don’t have to fetch the time from IO
09:23:52 <skypers_> the thing is, I still don’t know how I could fetch events
09:24:01 <Cale> skypers_: sodium has very similar *concepts* but looks very different on the surface to the system we used
09:24:14 <skypers_> Cale: ok then imagine
09:24:20 <skypers_> you have a reactive value in a thread
09:24:26 <skypers_> and a second thread generates events
09:24:32 <skypers_> how do you apply those events to the reactive value?
09:24:37 <merijn> skypers_: That doesn't really make sense, though
09:24:49 <Cale> I'm not sure what a thread means here
09:25:00 <merijn> skypers_: FRP is completely unrelated to threads
09:25:02 <skypers_> a thread, like in multithreading
09:25:04 <Cale> Are you talking about outside the FRP system?
09:25:08 <skypers_> yes
09:25:10 <skypers_> well merijn
09:25:14 <skypers_> it’s not the point here
09:25:19 <piezoid> do you have a clue about why Parsec.Expr can't parse multiple postfix operators ?
09:25:29 <skypers_> I just want how to know I can use FRP in multithreaded environments
09:25:30 <FreeFull> Send the events over a channel and sequence them in or something similar?
09:25:31 <piezoid> a minimal example : http://lpaste.net/97136
09:25:33 <Cale> Well, it's not *completely* unrelated, but none of the existing FRP libraries is any good at multithreading as far as I'm aware.
09:25:42 <skypers_> yeah
09:25:49 <skypers_> that’s what I thought
09:25:54 <merijn> skypers_: That depends on the design of the FRP system
09:25:55 <Cale> FRP *can* make the potential for free parallelism more apparent.
09:26:36 <skypers_> then hm
09:26:37 <Cale> (though I doubt you'd ever want to completely automate that, because you'd have granularity issues, just as you do when trying to auto-parallelise pure computations)
09:26:49 <skypers_> a GUI, in FRP, with no threads sounds quite hard
09:26:56 <rasfar> piezoid: i'm presuming the double-' lexes to a single operator? (like in Haskell, where you need a space)
09:27:27 <Cale> skypers_: btw, have you seen Stephen Blackheath's talk about FRP?
09:27:34 <merijn> skypers_: I strongly recommend reading the push-pull paper, the FRP implementation Conal describes uses threads internally, but they're not externally visible in the API
09:27:53 <piezoid> rasfar: char '\'' should consume only one char in the stream
09:28:35 <skypers_> ok
09:28:38 <skypers_> thank you guys :)
09:29:38 <rasfar> piezoid: unfortunately I can't compile your example... it's been a long while since I used Parsec. hopefully someone else can weigh in...
09:30:54 <rasfar> several of: Couldn't match expected type `T.Text' with actual type `[Char]' from your main
09:30:56 <piezoid> rasfar: i test "(a' ')" with a withspace aware "lexeme parser", same problem
09:31:09 <rasfar> i see. that's what i wanted to try.
09:31:50 <rasfar> piezoid: how to I make those String literals be T.Text's?
09:31:58 <piezoid> oh it need {-# LANGUAGE OverloadedStrings -#} and import Text.Parsec.Text ()
09:32:03 <rasfar> thanks
09:34:08 <Cale> skypers_: Well, in practical terms, doing a GUI *with* threading tends to be quite hard right now because GUI libraries are retarded, or more precisely, it's because they use something like the Observer pattern for registering event handlers.
09:34:38 <skypers_> yes Cale
09:34:39 <skypers_> but hm
09:34:52 <skypers_> each widgets uses a thread right?
09:35:13 <Cale> In some kind of magical GUI library which doesn't exist, that might be a good idea.
09:35:30 <skypers_> ahah :)
09:35:31 <skypers_> ok
09:35:40 <Hodapp> Cale: Didn't BeOS sort of function that way?
09:35:55 <Cale> Well, yeah, I seem to recall that it might've had something like that
09:36:06 <Hodapp> 'pervasive multithreading' or whatever
09:36:19 <Hodapp> and they'd nailed it, compared with contemporary Windows of the time
09:37:40 <rasfar> piezoid: could it be your grammar doesn't allow consecutive postfix ops, without parentheses intervening?
09:37:55 <Cale> Yeah, I ran BeOS a bit, and it was lovely compared to everything else which existed at the time. It's really too bad that they didn't get their story straight from the beginning about wanting a chunk of the desktop OS market instead of trying to sell people custom computers to run their OS on.
09:38:15 <Cale> (Well, who knows, that might've been a failure too...)
09:38:44 <piezoid> rasfar: i didn't decide of the grammar :(
09:38:50 <mangaba_leitosa> piezoid: just checked what OverloadedStrings is... cool! I was so annoyed by having to write T.pack "foo" instead of "foo"
09:39:58 <piezoid> mangaba_leitosa: yes, it's useful. You can define your own overloaded strings with IsString instances.
09:41:00 <rasfar> i'm pretty sure that is the case, although I can't read Parsec code really, only ponder and speculate :)
09:41:55 <Rarrikins> Parsec is way too far away.
09:43:02 <piezoid> rasfar: ok, thanks anyway. I'll try to put the ' parsing in the term parser, or somewhere else...
09:45:04 <rasfar> "Silently, one by one, in the infinite meadows of heaven,
09:45:04 <rasfar> Blossomed the lovely stars, the forget-me-nots of the angels."
09:46:26 <sm> rasfar++
09:46:40 <rose> How can I find a String -> Collection function for mongodb? Here's the documentation: http://hackage.haskell.org/package/mongoDB-1.4.1.1/docs/Database-MongoDB-Query.html#t:Collection
09:49:06 * hackagebot cabal-debian 4.0.3 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-4.0.3 (DavidFox)
09:49:08 * hackagebot resourcet 0.4.10 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.4.10 (MichaelSnoyman)
09:49:22 <Cale> rose: Well, Data.Text.pack :: String -> Text
09:49:27 <Cale> rose: So that ought to work
09:50:24 <FreeFull> Not ought to, that will work
09:51:10 <rose> Cale: thanks
10:14:08 * hackagebot dirfiles 0.1.0.1 -   http://hackage.haskell.org/package/dirfiles-0.1.0.1 (HugoGomes)
10:38:36 <FreeFull> How useful is Data.Vault?
10:39:31 <Rarrikins> How long does it take to drill through it?
10:42:00 <Rarrikins> FreeFull: It looks nice for something where you'd use a HashMap but where the keys would be arbitrary.
10:42:12 <c_wraith> approximately one unsafeCoerce
10:42:50 <sm> c_wraith: but then there's the lasers
10:47:25 <rose> How can I convert a Value to an ObjectId? Here's the documentation: http://hackage.haskell.org/package/bson-0.1.3/docs/Data-Bson.html
10:48:55 <shachaf> It looks like a Value is either an ObjId or various other sorts of values.
10:49:22 <shachaf> So if it's an ObjId, just get the ObjectId. If it's something else, I guess you can't.
10:51:29 <rose> how can I get the ObjectId? I don't have access to the ObjectId constructor
10:51:37 <rose> shachaf:
10:51:42 <shachaf> Pattern-match on Value.
10:51:56 <rose> how does that give me an ObjectId?
10:52:04 <shachaf> data Value = ObjId ObjectId | ...
10:52:51 <alanz> Fuuzetsu: doing cabal install yi
10:54:57 <Fuuzetsu> alanz: Great!
10:55:30 <Fuuzetsu> Please do not expect too much!
10:56:03 <alanz> I may want to see about integrating HaRe to it too.
10:56:20 <alanz> Or twisting your arm to do it :)
11:00:57 <amalloy> is f . g . h $ x preferred over f $ g $ h $ x?
11:01:47 <FreeFull> amalloy: Yes
11:01:49 <ion> Yes. Or alternatively (f . g . h) x
11:02:05 <Rarrikins> amalloy: Yes, definitely.
11:02:08 <Feuerbach> amalloy: No. (to ensure some diversity)
11:02:12 <rasfar> amalloy, personally I would prefer the latter if f, g etc. were anything but small expressions
11:02:19 <Rarrikins> Feuerbach: Evil heretic!
11:02:20 <FreeFull> Especially when you can get rid of the $ x  part
11:02:51 <amalloy> is there any particular reason for that preference? the former doesn't feel natural to me yet
11:03:05 <Feuerbach> Rarrikins: can't help it, the whole argument is stupid
11:03:25 <Feuerbach> amalloy: write the way it feels natural
11:03:41 <ion> amalloy: “g $ h” can’t be refactored out verbatim and be given a new name, “g . h” can. “$ x” can be eta-reduced away from the former, not the latter.
11:03:47 <Feuerbach> no point in polling an irc channel on how to write your code
11:04:52 <Rarrikins> amalloy: It's nice because it shows more information about the structure of it to readers and the compiler and because the precedence is a bit more aesthetically pleasing.
11:05:27 <scriptor> Rarrikins: the compiler treats it differently?
11:06:39 <Rarrikins> scriptor: I'm not sure exactly, but rewrite rules can be picky like that.
11:07:03 <Rarrikins> scriptor: Two obviously equivalent expressions won't both be optimized.
11:07:25 <scriptor> interesting
11:09:12 <noprompt> does anyone here use Emacs + evil-mode haskell-mode?
11:09:16 <benmachine> I would imagine that all the . and $ would disappear p quickly
11:09:24 <benmachine> they're very inlinable
11:09:39 <benmachine> noprompt: I don't, but I've considered it
11:10:48 <noprompt> benmachine: eh, maybe i'll just use vim.
11:11:10 <benmachine> mm
11:12:30 <klugez> noprompt: I do, though I haven't coded much Haskell lately. :(
11:12:45 <klugez> And I'm very new to Emacs.
11:12:53 <klugez> But at least evil-mode is great.
11:13:09 <scriptor> how vimmy is it?
11:13:11 <noprompt> klugez: ah, ok. i was hoping maybe someone could help me fix the behavior of `=`.
11:13:16 <noprompt> scriptor: it's very vimmmy.
11:13:32 <scriptor> I should probably give it a try, some time
11:13:33 <noprompt> scriptor: hands down the best vim emulation of any editor.
11:13:43 <scriptor> how comprehensive is the support?
11:13:50 <scriptor> can I do split-screens with vim keybindings?
11:13:57 <klugez> scriptor: Some things are delegated to Emacs, obviously not everything is implemented.
11:14:18 * hackagebot singletons 0.9.0 - A framework for generating singleton types  http://hackage.haskell.org/package/singletons-0.9.0 (RichardEisenberg)
11:14:19 <rose> scriptor: use tmux. It splits screens outside vim, so you can have bash open in one window, and vim open in another
11:14:20 <klugez> But I don't miss anything. Yes, you can do ^w s, ^w v and so on.
11:14:29 <donri> i found ex mode the most lacking in evil-mode
11:14:37 <scriptor> rose: I, uh, I use gvim
11:14:39 <scriptor> on windows
11:14:42 <noprompt> scriptor: yes. complex vim style keybindings can be configured with additional packages but overall it's a very faithful emulation.
11:14:58 <rose> How can I build a Bson Document field-by-field?
11:15:19 <noprompt> scriptor: don't use tmux. that's a hack. also there is VimShell and VimProc these days if you're looking for that sort of thing.
11:15:26 <frx> poor ex mode support is the only major objection i had when i used evil
11:15:33 <scriptor> hmm
11:15:51 <scriptor> yeah, I honestly prefer leaving the whole window for vim
11:16:07 <scriptor> having a dedicated part of my screen for bash seems wasteful, since I'm not in it all that often
11:16:39 <noprompt> the whole reason i left Vim for Emacs was so that i could have shells, repls, etc in the editor w/o having to resort to silly hacks.
11:16:53 <rasfar> how programming style is less relevant than choice of editor simulator in a programming channel, i'm not sure
11:17:38 <noprompt> rasfar: what's your point?
11:17:54 <ReinH> "don't use tmux. that's a hack" o_O
11:18:11 <rasfar> that was my point (in the context of the last two discussions)
11:18:17 <scriptor> noprompt: one more thing, can evil-mode read my .vimrc?
11:18:21 <noprompt> ReinH: let me preface that by saying i think it's a hack.
11:18:24 <klugez> noprompt: `=' in evil just calls indent-region. From HaskellWiki "Do not use indent-region
11:18:27 <klugez> Using indent-region is generally a bad idea on Haskell code, because it would need to know which of the tab-cycle stops you wish to choose for each line. The innermost one is chosen in each case, which often results in unusable code. Moral: just don't use indent-region with haskell-mode. "
11:18:32 <klugez> So it's not evil-mode related.
11:19:07 <noprompt> ReinH: setting up the whole vim + tmux experience is a hassle and, from what i remember, buggy.
11:19:42 <ReinH> what "vim + tmux experience" do you mean?
11:19:48 <noprompt> scriptor: no, it can use your vimrc, but that wasn't a deal breaker for me.
11:20:12 <noprompt> ReinH: running tmux/vim in seperate splits and sending code from vim to a tmux session.
11:20:20 <ReinH> Oh. Who does that?
11:20:29 <noprompt> ReinH: apparently programmers.
11:20:36 <klugez> scriptor: The configuration is very much emacsy with elisp.
11:20:49 <ReinH> noprompt: weird
11:21:07 <noprompt> ReinH: sorry i didn't mean that tmux itself was a hack.
11:21:48 <kuznero> Hi All!
11:22:02 <noprompt> klugez: so i guess then i'll disable that. but what then could i use for auto indentation?
11:22:25 <noprompt> klugez: or rather, formatting the code?
11:22:25 <rasfar> hi kuznero, what's happnin?
11:23:22 <kuznero> rasfar: trying to find a reason why scaffolded yesod project gives headache on Windows :)
11:23:37 <rasfar> what means "scaffolded"?
11:24:23 <kuznero> rasfar: yesod can create a template of a project by asking you series of questions - this process is called scaffolding a project
11:25:06 <rasfar> oh yeah? i see, thanks
11:25:41 <klugez> noprompt: I don't know of anything to do that, since indentation is meaningful. stylish-haskell is closest, but it only aligns import statements, if I remember correctly.
11:25:50 <rasfar> taken to the logical limit, that sounds incredibly useful
11:26:17 <rasfar> i guess it's a constraints-based approach, then you use constructive approach to finish it off
11:26:25 <noprompt> klugez: gotcha.
11:26:36 <klugez> Or using chrisdone's structured-haskell-mode, which means you'll edit the structure, not the text. But that is in an early state right now.
11:27:12 <klugez> noprompt: Anyway, there's haskell-mode-stylish-buffer, which will run stylish-haskell on the buffer.
11:30:38 <noprompt> klugez: structured-haskell-mode sounds like something i'd want. i'm trying to pick up haskell again after spending the last year w/ clojure and finding the syntax very annoying.
11:30:49 <Fuuzetsu> alanz: I can't say it's in my top priorities list! It shouldn't be too hard to integrate however!
11:31:05 <noprompt> i want s-exprs ;_;
11:32:00 <klugez> noprompt: https://github.com/chrisdone/structured-haskell-mode
11:32:45 <klugez> I haven't programmed in any lisps, but I've had a look at paredit and smartparens. I can see why you'd not want to give such things up and formatting by hand after getting used to them.
11:32:52 <acowley> chrisdone needs to run a kickstarter to add case splitting to shm
11:33:02 <acowley> Or just put out a bucket, whatever
12:03:00 <alanz> Fuuzetsu:it is specifically presented as a library, with high level commands to operate on files on the disk, which can then be reloaded. Should be straightforward to bring in.
12:14:45 <kuznero> Can anyone help with this type of error when compiling simple Yesod project on Windows: http://lpaste.net/97141
12:15:34 <Cale> First of all, does the file mentioned exist, and is it nonempty?
12:15:53 <Rarrikins> kuznero: Report it as a GHC bug.
12:16:14 <Fuuzetsu> Or rather, check the issue tracker first.
12:16:15 <duairc> Are there haddocks online anywhere for template haskell 2.9?
12:16:59 <Cale> Well, yeah, it's probably at least a bug in terms of GHC's ability to report what's wrong
12:17:07 <kuznero> Cale: yep, file exists
12:17:10 <Fuuzetsu> duairc: --enable-documentation when building is probably the best way
12:17:11 <Cale> But I'm pretty sure Yesod is meant to be possible to use on Windows
12:17:41 <Cale> https://ghc.haskell.org/trac/ghc/ticket/7056
12:18:07 <kuznero> Cale: yes, it should work on Windows.
12:18:27 <piezoid> alanz: How did you install SQLite ?
12:18:42 <Cale> Apparently that error happens if somehow GHC is using the gcc which comes with mingw rather than the one which comes with GHC
12:18:47 <piezoid> sory, kuznero
12:19:35 <kuznero> piezoid: I installed it by just copying precompiled binaries from sqlite website and making it available through exposing its path in the PATH environment variable.
12:19:42 <Rarrikins> kuznero: https://ghc.haskell.org/trac/ghc/ticket/7056
12:19:50 <Cale> yeah, I linked that :)
12:20:02 <kuznero> Rarrikins: yes, that sounds like that
12:20:15 <Rarrikins> Oh, sorry
12:20:15 <kuznero> Cale: yep, should I post there as well?
12:20:35 <Cale> Perhaps add yourself to the CC list.
12:20:48 <alanz> I am running on Debian, it is just there. or in via apt-get
12:21:02 <Cale> alanz: Is what?
12:21:03 <piezoid> kuznero: maybe you should try other binaries, or compile it with ghc's mingw32
12:21:12 <Cale> oh
12:21:20 <Cale> (that wasn't a question)
12:21:28 <alanz> sorry, that was aimed at piezoid
12:21:30 <kuznero> Cale: actually, someone has already mentioned this particular issue with the ticket you sent
12:21:37 <Cale> kuznero: yeah
12:22:09 <piezoid> kuznero: that's maybe the only one external library linked, so it's suspect
12:22:37 <kuznero> alanz: piezoid: so, should I try installing sqlite through mingw facilities?
12:22:38 <piezoid> alanz: sorry, same mistake, my question was for kuznero :p
12:22:47 <kuznero> :))
12:23:45 <kuznero> Is there any way to upvote the ticket on Trac?
12:24:05 <piezoid> kuznero: maybe, that's just a clue...
12:24:24 <Fuuzetsu> kuznero: No.
12:24:56 <kuznero> Fuuzetsu: ok, then I hope someone will look at it soon :) It seems to be there for 18 months already
12:25:10 <kuznero> Anyway, trying it with mingw now. Thanks for suggestions!
12:25:52 <Fuuzetsu> kuznero: You could try to provide new information or poke your head into #ghc and ask around or ask around on ghc-devs mailing list
12:26:29 <kuznero> ok, thanks for the tip
12:26:47 <`cbp> hello, I'm trying to install uniplate with cabal install uniplate but it fails becuse it says it can't find libiconv.dylib however the library is in /usr/lib, how do i tell it that?
12:28:05 <acowley> `cbp: It's surprising that it's not looking there, but there are flags like --extra-lib-dirs
12:28:35 <rasfar> `cbp: did you install the -dev version of libiconv? you'd need that.
12:28:53 <acowley> That sounds more likely
12:29:01 <rasfar> :)
12:29:12 <rasfar> hey i have a question related to one not too far above:
12:29:17 <`cbp> I'll try that
12:29:34 <rasfar> if you for some reason didn't have --enable-documentation set in your cabal config
12:29:51 <rasfar> i've read on SO http://stackoverflow.com/questions/1587635/haddock-for-cabal-installed-modules that you can do
12:30:08 <rasfar> cabal install graphs --enable-documentation (having already installed it without the docs)
12:30:25 <rasfar> but when I try that I get the warning that must use --reinstall, and of course that is bad to do
12:30:56 <rasfar> i'm more concerned with --enable-profiling equivalent of this question -- whether there's any safe way to do it?
12:31:17 <acowley> I don't think there is
12:31:21 <rasfar> my best solution so far is to "just use sandboxes"
12:31:24 <acowley> Yes
12:31:44 <rasfar> i see, okay thanks acowley
12:31:58 <acowley> In general, you might have B built with C, then A built with B. If you reinstall B, it might pick up C'
12:32:51 <acowley> It would be really nice if some part of cabal could figure out how to deal with multiple builds of the same package with multiple dependency sets
12:32:53 <rasfar> yes, someone kindly led me through that argument here a few weeks back. it seems like for the haddock it should be okay...
12:33:00 <bergmark> in general i just reinstall, worst case you wipe ~/.ghc and do it again
12:33:19 <sm> rasfar: --reinstall is perfectly approriate there, unless it says will break these other packages, in which case you might reinstall those too
12:33:22 <acowley> I think the problem is that if you do --enable-documentation, it will still reinstall the package library itself, which might pull in an updated dependency
12:33:58 <rasfar> could you introduce ... / i see thanks sm / acowley okay
12:34:04 <acowley> sm is right, but I admit I'm pretty draconian with that kind of thing these days. Nuke first, worry about other options later :/
12:34:59 <rasfar> so appropriate for haddock, but when it comes to profiling libraries, best not to --reinstall I guess?
12:35:10 <rasfar> never mind, cancel that
12:39:40 <sm> lol, first hit for how to cabal install: http://www.cabalonline.com/guide/install.asp
12:40:29 <acowley> How many new Haskellers do you think tried to follow those instructions?
12:41:11 <Rarrikins> sm: Heheh
12:41:34 <sm> the flaming sword looks like exactly what we need
12:41:53 <acowley> The flaming sword of reinstallation
12:41:56 <sm> WE SHALL BE YOUR GUIDES THROUGH CABAL HELL
12:42:04 <scriptor> first hit for me is on haskell.org
12:42:17 <Rarrikins> You can buy Cabal Cash to make installs go more smoothly.
12:42:25 <scriptor> same when I google it in incognito
12:42:54 <acowley> Google knows sm
12:43:12 <`cbp> hmm how do you solve cabal not finding libiconv.dylib in os x?
12:43:45 <sm> acowley: ha, not my machine
12:43:56 <evancz> does anyone know of good resources for turning Haskell projects into "distributables"? (like a .dmg and the equivalents for other platforms)
12:44:06 <evancz> I'm have trouble finding a comprehensive resource on this
12:44:19 <acowley> sm: Then google has taught you something about the person you borrowed it from: they need more Haskell in their life
12:44:30 <acowley> `cpb: Same answer as before!
12:44:53 <sm> evancz: I'd look at git-annex
12:45:14 <sm> there might also be a tip or two in hledger's Makefile
12:46:05 <`cbp> hmm :(
12:46:28 <acowley> evancz: Did you look at http://hackage.haskell.org/package/mkbndl
12:47:29 <sm> and maybe http://hackage.haskell.org/package/bamse and http://hackage.haskell.org/package/nsis for windows
12:48:33 <evancz> sm, what does git-annex do related to this stuff?
12:48:42 <evancz> quick glance shows lots of other features
12:48:52 <evancz> looking at others now :)
12:49:12 <acowley> I think sm was referring to the fact that git-annex makes releases downloadable on the web
12:49:28 <acowley> so joeyh probably has a build script for packaging things
12:49:48 <sm> evancz: I think it's pushing the state of the art in cross-platform-just-works-ness
12:50:03 <`cbp> aughh
12:50:05 <`cbp> I give up
12:50:21 <evancz> Do these tools let you install without installing haskell though?
12:50:21 <Clint> what with yesod on android
12:50:38 <Hodapp> When I dabbled with git-annex, I don't recall it doing anything of the sort.
12:50:48 <gOqRg]MVF> Can I use foldr in such a way that it doesn't fold over just one list but over two lists, where one is consumed in every step and the other maybe gets consumed depending on whatever is at the head of the former list, or do I have to stick with my manual recursion?
12:50:50 <Hodapp> it was basically, um, an annex onto git.
12:51:03 <Clint> you misunderstood the claims
12:51:14 <sm> Hodapp: I might mean git annex assistant. Not sure
12:51:43 <FliPPeh> Stupid nickser
12:51:44 <FliPPeh> v
12:52:10 <sm> evancz: sure. hledger's old binaries are a simple example, it's just static linking with some extra platform-specific tweaks to try and minimise the remining library dependencies
12:52:33 <sm> http://hledger.org/DOWNLOAD.html
12:53:25 <triliyn> FliPPeh: you can zip the two lists and write a function that manipulates the tuple
12:53:52 <evancz> sm, cool
12:53:57 <triliyn> Or wait, that might not do what you want
12:54:11 <FliPPeh> Not unless I write a custom zipper, I think not
12:54:13 <evancz> sm, it looks like he is disributing gzipped things though?
12:54:33 <FliPPeh> Because the second list may be shorter than the first list
12:54:44 <joejev> I realze usafeThaw is probably not the best, but after profiling my project I was spending a good 66% on array updates. I have to updatte values one element at a time based on the nature of the program,so I was trying to use unsafe thaw; however, I get the error: Expected type: IOUArray Int Word8,Actual type: IOUArray Int (b1 Int Word8)
12:54:52 <sm> evancz: I'm not totally familiar with how joeyh does it, I just follow the blog
12:54:52 <FliPPeh> ['a', 'm', 'k'] and ['foo'] for example
12:54:58 <triliyn> Well also, do you want to keep the elements of the second list that you don't consume (to perhaps consume them later)?
12:55:03 <FliPPeh> "*
12:55:31 <evancz> I feel like doing something like this (http://nodejs.org/download/) or this (http://www.haskell.org/platform/) is more professional
12:55:36 <FliPPeh> If I don't consume all the elements of the second list than whatever the server sent me is invalid
12:55:39 <evancz> maybe not professional, but easy to use
12:55:43 <FliPPeh> So at that point I just drop the operation
12:55:51 <FliPPeh> then*
12:56:36 <sm> evancz: ie you want to add an installer ? the hackage things we linked are for that
12:56:59 <sm> the windows ones are, at least
12:57:28 <sm> haskell platform's installers might be a good thing to look at
12:58:00 <acowley> Does http://hackage.haskell.org/package/mkbndl not work anymore?
12:58:30 <evancz> what is an .app bundle?
12:58:42 <acowley> It's a directory with all the bits and pieces an executable needs
12:58:44 <joelteon> it's an osx thing
12:58:45 <sm> acowley: no idea, but it looks pretty old
12:58:54 <acowley> sm: Yeah, my question wasn't rhetorical
12:59:14 <acowley> I thought the original question was for OS X
12:59:19 <acowley> I may have misunderstood
12:59:51 <sm> multi platforms, I thought. http://hackage.haskell.org/package/cabal-macosx looks better
12:59:54 <evancz> acowley: yeah, I mentioned .dmg and couldn't remember what .msi was called :)
13:00:22 <evancz> acowley: it's from 2008 so I'm not too excited to dig into it further
13:00:25 <acowley> sm: Ah, that does look good
13:00:39 <acowley> evancz: I don't think .app directory structures have changed much
13:00:55 <acowley> It's just a matter of copying things into the right place
13:01:27 <acowley> I hope dynamic linking doesn't make this all more complicated
13:01:41 <sm> some mac apps come with an installer that you run, but I guess that's unnecessary for most
13:01:59 <evancz> oh, so you can just give an .app bundle?
13:02:35 <acowley> evancz: Yes, the usual thing is to make a .dmg for distribution, but all that contains is the .app
13:02:52 <acowley> And you can make a .dmg with Disk Utility or from the command line
13:02:59 <sm> yes, many mac apps you just open the .dmg and get a folder more-or-less carefully arranged for you to drag the app into your Applications folder
13:03:51 <evancz> okay, I'll see what I can do :)
13:03:55 <evancz> thanks!
13:04:43 <evancz> as Haskell gets more industry use, I think more folks will begin to ask about this kind of thing. So a comprehensive resource could be really helpful in making the "ready for industry" argument.
13:04:57 <sm> +1 evancz
13:04:58 <evancz> I don't mean to be critical at all, I know there's lots of stuff to do :)
13:05:15 <acowley> evancz: There are wikis for this, update them when you work things out
13:05:46 <acowley> e.g. http://www.haskell.org/haskellwiki/Mac_OS_X
13:05:53 <evancz> Do you know any FP Complete folks?
13:06:02 <evancz> they'd be good to talk to about this
13:06:16 <evancz> are there wikis?
13:06:48 <levi> evancz: I think their focus is on cloud deployment rather than desktop deployment.
13:06:58 <evancz> we didn't talk about any
13:07:28 <epta> How to list all files from specific directory recursively and unix/windows compatible?
13:07:31 <levi> I think Haskell has a number of other challenges to face for desktop deployment before making distribution simple is a major problem.
13:08:18 <evancz> It's unlucky that making .dmg and .msi is so unglamorous :)
13:08:29 <evancz> in any case, thanks for the links!
13:08:41 <levi> Well, it's also unlucky that GUI bindings are unglamorous.
13:08:43 <joejev> epta: there is a function called getDirectoryContents, it is in System.Directory I think
13:09:00 <FreeFull> GUI frameworks are big
13:09:07 <FreeFull> It's tough to make comprehensive bindings
13:09:11 <evancz> we'll see how it goes
13:09:11 <evancz> I may try to find the haskell-platform folks and see how they do it
13:09:31 <FreeFull> Also, there are some problems interfacing with C++ code, which makes something like QT hard to wrap
13:10:24 <epta> joejev: _recursively_
13:10:26 <acowley> evancz: I just linked to the wiki
13:10:44 <evancz> yeah, I guess there are pretty much only command line things that would be distributed
13:10:44 <evancz> like pandoc
13:11:01 <sm> I think evancz meant wiki pages. I see no relevant page on the wiki, eg at http://www.haskell.org/haskellwiki/Category:Tools
13:11:09 <sm> (how to get an alphabetic list of all pages ?)
13:12:34 <acowley> I don't understand
13:12:37 <Rarrikins> sm: It's MediaWiki (http://www.haskell.org/haskellwiki/Special:Version), so it has http://www.haskell.org/haskellwiki/Special:SpecialPages.
13:12:38 <acowley> What I linked is a wiki ipage
13:12:38 <sm> evancz: web apps and apps with web-based GUIs, too
13:12:51 <acowley> It has a section on OS X build tools
13:13:07 <sm> Rarrikins: oh, nice
13:13:26 <sm> really nice
13:13:43 <sm> aside from being written in you know what
13:13:46 <sm> say nothing
13:17:40 <joeyh> I'd be using cabal-osx, except IIRC I did not find it until after I wrote the eqivilant, and IIRC there is something horrible to do with RPATH size limits that I had to work around by renaming libraries in my .dmg to 1 letter long
13:18:43 <joeyh> I can recommend http://hackage.haskell.org/package/nsis for the windows side, if you're so unlucky as to need it
13:18:52 <joeyh> and for the android side.. erm, it's complicated
13:18:59 <joelteon> @hoogle (</>)
13:19:01 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
13:19:01 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
13:20:15 <simpson> FilePath being String is annoying.
13:20:17 <joejev> Can someone explain how to use that here? I get type error everywhere
13:20:20 <joejev> http://lpaste.net/97142
13:20:27 <sm> Rarrikins: still no easy way to see a simple list of all pages alas
13:24:33 * hackagebot simple-sql-parser 0.2.0 - A parser for SQL queries  http://hackage.haskell.org/package/simple-sql-parser-0.2.0 (JakeWheat)
13:32:58 <quchen> joejev: "Doesn't work" is not an error message.
13:33:43 <Rarrikins> If I ever make a compiler, "doesn't work" will totally be an error message.
13:34:07 <henk> Hi everyone. I use the DateTime type in a script to handle dates+times. I’m looking for a way to get a DateTime representing the start of the day (i.e. 00:00:00) of another DateTime. Any hints how to do that?
13:34:12 <quchen> Don't make a compiler.
13:34:35 * hackagebot Dust-tools 1.3 - Network filtering exploration tools  http://hackage.haskell.org/package/Dust-tools-1.3 (BrandonWiley)
13:34:37 * hackagebot Dust-tools-pcap 1.1 - Network filtering exploration tools that rely on pcap  http://hackage.haskell.org/package/Dust-tools-pcap-1.1 (BrandonWiley)
13:34:38 <Rarrikins> :(
13:34:39 * hackagebot Dust 2.3.0 - Polymorphic protocol engine  http://hackage.haskell.org/package/Dust-2.3.0 (BrandonWiley)
13:34:41 * hackagebot Dust-crypto 0.1 - Cryptographic operations  http://hackage.haskell.org/package/Dust-crypto-0.1 (BrandonWiley)
13:35:24 <fizbin> Hey, I have a question: how do I tweak my cabal file so that I can then run "cabal repl" with the proper options to get a stacktrace when an exception is hit?
13:35:43 * fizbin has an exception and no useful information about why.
13:36:31 <fizbin> Adding -prof -fprof-auto to my ghc-options line produces scary warnings.
13:36:38 <acowley> fizbin: Add +RTS -xs to the flags in the cabal file
13:37:09 <acowley> sorry, -xc
13:37:10 <fizbin> Do you mean the ghc-options line?
13:37:38 <fizbin> My cabal file has no line "flags"
13:38:18 <acowley> sorry, yes, ghc-options: "-with-rts-opts=--xc"
13:38:40 <acowley> My fingers are cold. That should be "-xc" just a single hyphen
13:39:08 <acowley> So, the full line is: ghc-options: "-with-rts-opts=-xc"
13:39:24 <acowley> I use the quotes because I've had trouble passing multiple parameters there in the past
13:40:32 <fizbin> ghc: unrecognised flags: -with-rts-opts=-xc
13:41:02 <fizbin> Ah, no second dash
13:41:45 <acowley> I've not actually tried -xc before, but what I showed is how you can bake RTS flags into the build
13:44:21 <volko> I don't quite understand the :: in the following line
13:44:22 <volko> force arr = toArr $ go (arrays (undefined::a)) arr
13:44:38 <johnw> volko: that's what we call a "proxy argument"
13:44:40 <volko> I've seen it a few other places
13:44:42 <volko> ah, thank yo
13:44:44 <volko> *you
13:44:49 <johnw> it's passing a value that will never be evaluated, but which provides a type to the compiler
13:45:21 <johnw> some libraries tend to use Data.Proxy to do this sort of thing, as it's a bit clearer what's going on
13:45:26 <acowley> The (::) specifically is the same :: you see in type signatures
13:45:39 <johnw> example:
13:45:44 <johnw> > sizeOf (undefined :: Int)
13:45:46 <acowley> You can use that notation to clarify things like numeric literals
13:45:46 <lambdabot>  Not in scope: `sizeOf'
13:45:46 <lambdabot>  Perhaps you meant one of these:
13:45:46 <lambdabot>    `IM.size' (imported from Data.IntMap),
13:45:46 <lambdabot>    `M.size' (imported from Data.Map),
13:45:46 <lambdabot>    `S.size' (imported from Data.Set)
13:45:59 <acowley> :t (1::Double)
13:46:00 <lambdabot> Double
13:46:01 <johnw> @let import Foreign.StablePtr
13:46:03 <lambdabot>  Defined.
13:46:03 <acowley> :t (1::Int)
13:46:03 <lambdabot> Int
13:46:04 <johnw> > sizeOf (undefined :: Int)
13:46:06 <lambdabot>  Not in scope: `sizeOf'
13:46:06 <lambdabot>  Perhaps you meant one of these:
13:46:06 <lambdabot>    `IM.size' (imported from Data.IntMap),
13:46:06 <lambdabot>    `M.size' (imported from Data.Map),
13:46:07 <lambdabot>    `S.size' (imported from Data.Set)
13:46:09 <volko> Ah, cool
13:46:11 <Rarrikins> :t undefined :: Double
13:46:12 <lambdabot> Double
13:46:14 <acowley> johnw is fancy
13:46:22 <johnw> @let import Foreign.Storable
13:46:23 <lambdabot>  Defined.
13:46:25 <johnw> > sizeOf (undefined :: Int)
13:46:26 <lambdabot>  8
13:46:29 <volko> so I just bound them with the (), if I want to put them within another statement?
13:46:48 <Rarrikins> > sizeOf ()
13:46:50 <lambdabot>  No instance for (Foreign.Storable.Storable ())
13:46:50 <lambdabot>    arising from a use of `Foreign.Storable.sizeOf'
13:46:50 <lambdabot>  Possible fix:
13:46:50 <lambdabot>    add an instance declaration for (Foreign.Storable.Storable ())
13:46:55 <acowley> Yes, my parentheses were excessive. They're (nearly?) always needed in practice
13:46:57 <Rarrikins> You can't store that!
13:47:26 <acowley> It should be zero
13:47:59 <Rarrikins> Yees
13:48:25 <Rarrikins> It should also be very efficiently storable.
13:49:36 * hackagebot Dust 2.3.1 - Polymorphic protocol engine  http://hackage.haskell.org/package/Dust-2.3.1 (BrandonWiley)
13:49:38 * hackagebot Dust-tools 1.3.2 - Network filtering exploration tools  http://hackage.haskell.org/package/Dust-tools-1.3.2 (BrandonWiley)
13:49:40 * hackagebot Dust-tools-pcap 1.3.1 - Network filtering exploration tools that rely on pcap  http://hackage.haskell.org/package/Dust-tools-pcap-1.3.1 (BrandonWiley)
13:50:00 <Rarrikins> Must be a bugfix release.
13:57:05 <henk> Now that seems a bit stupid: http://lpaste.net/97143 Is there any less roundabout way for getting "start of day" as DateTime type? Or any less strange way of writing this function?
13:57:22 <Rarrikins> @hoogle ClockTime
13:57:22 <lambdabot> System.Time data ClockTime
13:57:22 <lambdabot> System.Time addToClockTime :: TimeDiff -> ClockTime -> ClockTime
13:57:23 <lambdabot> System.Time diffClockTimes :: ClockTime -> ClockTime -> TimeDiff
13:57:25 <quchen> Can someone recommand a generic trie library? There's the "TrieMap" package, but I don't see documentation on Hackage and the Github readme is empty; it doesn't look trustworthy at all.
13:58:04 <Rarrikins> henk: I'm not sure how DateTime is represented. You might be able to do something with that.
13:58:56 <Rarrikins> henk: It looks like toSeconds and fromSeconds might work.
13:59:13 <ocharles> Erm, I'm using Hashable and generic deriving and I get a stack overflow if I try and call `hash $ Foo "Bar" "Baz"` where `data Foo = Foo String String`
13:59:20 <johnw> henk: do you just want the date, without the time?
13:59:22 <Rarrikins> henk: With subtracting a remainder. Not sure if leap seconds are included, though.
13:59:26 <ocharles> looks like hashable 1.1.2.5
13:59:53 <johnw> if so, I'd use UTCTime and call utctDay, that will give you a day you can manipulate with the Gregorian functions
14:00:18 <ocharles> I'm using deriving (Generic) on Foo, and then 'instance Hashable Foo'
14:01:07 <henk> Rarrikins: Yes, I saw those types, but was not able to figure out how to use them for my cause …
14:02:20 <kinslayer> If I want to run some function forever (err well a IO action) isn't there some nifty thing that lets me do this ? However would it just start over running a specified action or would it continue from the state it would be in when its starting again ?
14:02:22 <ocharles> Ah balls, I'm not on hashable 1.2
14:02:43 <Rarrikins> @hoogle forever
14:02:44 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
14:02:48 <Rarrikins> @src forever
14:02:48 <lambdabot> Source not found. My mind is going. I can feel it.
14:03:03 <johnw> forever x = x >> forever x
14:03:21 <kinslayer> thanks but would it start x over ?
14:03:41 <Rarrikins> kinslayer: It would execute x again, if you're doing IO.
14:03:43 <johnw> i'm not sure what you mean
14:03:55 <kinslayer> so if it was done with x it would start over ?
14:04:05 <johnw> it would do the same thing over and over again
14:04:17 <kinslayer> okay kind of like while 1: do x
14:04:21 <johnw> exactly
14:04:36 <kinslayer> super... Then I should combine that with threadDelay
14:04:43 <kinslayer> to make it wait for some seconds...
14:05:16 <henk> johnw: Well, actually what I have is a string containing a time representation in a certain timezone. ATM I’m converting that to DateTime, which AFAIU is just a "pimped" UTCTime, i.e. it’s missing the original timezone information and it seems I need to rethink my program ): In the end, I want to calculate the time between two such time strings, but that’s irrelevant for now, my main issue has become
14:05:18 <henk> preserving the timezone …
14:05:32 <henk> Rarrikins, johnw: Thanks for your input
14:05:38 <Rarrikins> kinslayer: Perhaps everySoOften :: Int -> IO a -> IO a; everySoOften n x = x >> threadDelay n >> everySoOften n x
14:05:42 <johnw> henk: LocalTime?
14:05:44 <Rarrikins> henk: No problem.
14:06:02 <kinslayer> everySoOften sounds like something I really would like :D
14:06:13 <kinslayer> @hoogle everSoOften
14:06:14 <lambdabot> No results found
14:06:16 <Rarrikins> kinslayer: Or foreverWithDelay
14:06:22 <johnw> everySoOften n x = forever (x >> threadDelay n)
14:06:24 <quchen> I think forever is "forever x = go where go = x >> go" for better sharing
14:06:26 <Rarrikins> kinslayer: You'd just put that definition in your code.
14:06:31 <kinslayer> there is a lot of solutions to this problem
14:06:41 <kinslayer> @hoogle everySoOften
14:06:42 <lambdabot> No results found
14:06:45 <johnw> quchen: good point
14:06:53 <Rarrikins> kinslayer: It's not in the libraries.
14:06:56 <kinslayer> @hoogle foreverWithDelay
14:06:56 <Rarrikins> kinslayer: I made it up.
14:06:57 <lambdabot> No results found
14:07:03 <johnw> delayedEternity
14:07:10 <Rarrikins> kinslayer: Just copy that to your source code.
14:07:12 <rose> how can I place guards inside a case statement?
14:07:19 <Rarrikins> kinslayer: Might be better to name it foreverWithDelay, though.
14:07:23 <henk> johnw: Yes, probably.
14:07:31 <johnw> case foo of x | yourPredicate -> ...
14:07:38 <rose> johnw: thanks
14:07:51 <kinslayer> I assume the ';' is not supposed to be there ?
14:07:54 <Rarrikins> case zomg of { whatsit -> ...; kthx -> ... }
14:08:09 <Rarrikins> kinslayer: Well, replace that with a newline.
14:08:21 <kinslayer> yup I thought so
14:08:22 <kinslayer> :D
14:08:43 <Rarrikins> Oh, guards.
14:11:06 <kinslayer> can I use return inside an IO action to continously get data out ?
14:11:19 <Rarrikins> kinslayer: Return doesn't get data out.
14:11:24 <Rarrikins> kinslayer: Use output.
14:11:28 <Rarrikins> kinslayer: Like print or something.
14:11:41 <kinslayer> oh but I wanted to construct a list of values
14:12:03 <Rarrikins> kinslayer: Then create a list and add to it on successive iterations.
14:12:19 <Rarrikins> kinslayer: Or use IOVars or something.
14:12:38 <kinslayer> some docs on IOVars ?
14:12:51 <Rarrikins> kinslayer: It's better to start off with successive iterations.
14:12:54 <kinslayer> since I would like to inspect the list while the action is running
14:13:16 <kinslayer> rarrikins: and perhaps also after would it stay around ?
14:13:28 <Rarrikins> kinslayer: You'll have zomg xs = do { ...; ...; threadDelay 50000; zomg (x:xs) }
14:13:41 <Rarrikins> kinslayer: I have to go to dinner soon, unfortunately.
14:13:51 <Rarrikins> kinslayer: With that, xs changes each iteration.
14:14:05 <Rarrikins> kinslayer: It's a bit like recursion.
14:14:05 <kinslayer> okay... So the variable created will be around when the IO action stop ?
14:14:20 <jrmithdobbs> it *is* recursion
14:14:24 <Rarrikins> kinslayer: The IO action won't stop with an infinite loop.
14:14:27 <kinslayer> that is really all I need
14:14:28 <Rarrikins> jrmithdobbs: Yeah :D
14:14:52 <c_wraith> No one's mentioned lazy IO?
14:15:01 <c_wraith> I mean, it's often a bad idea, but sometimes it works..
14:15:07 <Rarrikins> kinslayer: You can stop it with zomg xs = do { ...; ...; if kthx then do { threadDelay 50000; zomg (x:xs) } else return xs }
14:15:14 <Rarrikins> kinslayer: Something like that.
14:15:32 <Rarrikins> kinslayer: You recurse until you're done and you return something.
14:15:45 <Rarrikins> kinslayer: You can then use that zomg action to get a list.
14:16:02 <kinslayer> so if I call zomg it would stop ?
14:16:05 <kinslayer> or ?
14:16:12 <Rarrikins> kinslayer: It'll be like main = do { zomgList <- zomg; ... }
14:16:35 <Rarrikins> kinslayer: As long as the if condition was eventually false.
14:16:40 <kinslayer> so it will create a progressively larger list...
14:16:50 <Rarrikins> kinslayer: Yeah, until it terminates.
14:17:02 <kinslayer> yeah I can just say till it gets of size n
14:17:18 <Rarrikins> kinslayer: You can do that, though it would be good to add the length as a parameter to zomg.
14:17:28 <Rarrikins> kinslayer: So that you don't need to compute the length repeatedly.
14:17:37 <kinslayer> yeah.
14:18:00 <Rarrikins> kinslayer: However you do it, it's just normal recursion.
14:18:05 <Rarrikins> kinslayer: Have to go.
14:18:08 <kinslayer> okay
14:18:11 <kinslayer> thanks for the help
14:18:14 <Rarrikins> No problem.
14:18:18 <kinslayer> :D
14:19:38 * hackagebot haskoin-protocol 0.0.1 - Implementation of the Bitcoin network protocol messages  http://hackage.haskell.org/package/haskoin-protocol-0.0.1 (PhilippeLaprade)
14:19:40 * hackagebot singletons 0.9.1 - A framework for generating singleton types  http://hackage.haskell.org/package/singletons-0.9.1 (RichardEisenberg)
14:20:58 <acowley> kinslayer: You may also want to look at http://hackage.haskell.org/package/monad-loops-0.4.2/docs/Control-Monad-Loops.html
14:21:21 <kinslayer> here I thought haskell didn't have loops...
14:21:22 <jrmithdobbs> also /package/conduit and/or /package/streams
14:21:38 <jrmithdobbs> because those are probably what you're really after, you just don't know it yet
14:21:46 <kinslayer> well streams might be a useful thing... Are they like streams in other languages
14:21:52 <kinslayer> scala for instance ?
14:22:16 <jrmithdobbs> kinslayer: yes both conduit and streams are for processing streams of data in constant memory
14:22:17 <heatsink> They're kind of like scala iterators
14:22:35 <jrmithdobbs> kinslayer: but no they aren't like io streams in c++ (thank god)
14:22:52 <kinslayer> that is nice that it is not linked to c++
14:23:18 <kinslayer> I think god wrote the world in c++ and got something wrong (how else would you explain this mess we live in ?)
14:23:42 <heatsink> Are classes theories whose instances are their models?
14:23:54 * heatsink is reading about model theory
14:27:42 <DigitalKiwi> kinslayer: http://xkcd.com/224/
14:27:42 <hopf_> A model is an interpretation of a language in some set, right?
14:28:03 <hopf_> so if you can find a path from one definition to the other, you win
14:28:41 <kinslayer> digitalkiwi: Yeah that is a great one... However my theory might explain some of the messes better ?
14:28:54 <heatsink> What does language mean in this case?  A string of symbols?
14:29:13 <DigitalKiwi> i think being hacked together with perl explains it about as well as being hacked togthe with broken C++ :P
14:29:14 <hopf_> A set of function symbols, relation symbols, and constant symbols
14:29:36 <hopf_> that must be interpreted as functions, relations, and constants (respectively)
14:30:12 <heatsink> That sounds like a signature to me
14:30:20 <hopf_> hmm, oh yeah!
14:30:20 <kinslayer> digitalkiwi: I almost like perl, it was my first language
14:31:20 <wting> Is there a term for applying n functions to one list to get n lists back?
14:32:11 <heatsink> Do all the result lists have the same type?
14:32:18 <eacameron> how do you import your cabal package version into your code?
14:32:53 <acowley> :t \xs -> map (flip map xs)
14:32:54 <lambdabot> [a] -> [a -> b] -> [[b]]
14:33:22 <heatsink> eacameron, you get it from the paths module http://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-the-package-version
14:33:41 <heatsink> The module is autogenerated by cabal
14:33:48 <eacameron> heatsink: haha...I was just reading that page; it's what led me to ask the question
14:34:05 <hopf_> okay, so the signature is the set of symbols, and then maybe the language is all first order statements with those symbols?
14:34:09 <eacameron> heatsink, so "import Path_myproj (version)" ?
14:34:34 <heatsink> yes.  I think there's something in the cabal file that declares the name of the module
14:34:43 <henk> Can anyone recommend a way for doing "time arithmetic" using 'LocalTime's? There are several good ways for calculating seconds or minutes between two given 'UTCTime's but they don’t seem to work for LocalTime …
14:34:57 <henk> AFAICT that is (:
14:35:26 <heatsink> I think that's right hopf_
14:35:52 <heatsink> Usually there are axioms declaring equivalences between statements
14:36:28 <acowley> henk: Have you looked at thyme?
14:36:45 <piezoid> wting: f <*> a
14:36:49 <Feuerbach> henk: why not just convert them to UTCTime?
14:36:51 <piezoid> :t \(a :: [a]) f -> f <*> a
14:36:52 <lambdabot> [a] -> [a -> b] -> [b]
14:37:05 <henk> acowley: no, will do, thank you
14:38:12 <henk> Feuerbach: I’m considering that too, thanks (:
14:41:20 <hopf_> heatsink: I think it's more accurate to say that a set of axioms is a subset of the set of all statements, and certain models may satisfy a set of axioms (according to Tarski's definition of satisfaction)
14:44:47 <heatsink> Then an interpretation associates statements to objects, and the axioms only pertain to the objects
14:44:50 <quchen> I'm looking for a data structure to cache the last N pieces of data received in. Using `Set Foo` makes lookup for previously encountered ones easy, but deleting the oldest entry when a new one comes in is O(n). On the other hand `Seq` makes the queue behaviour natural, but lookup takes more time. Is there a data structure that is more suitable for my needs?
14:45:14 <geekosaur> priority search queue?
14:45:19 <acowley> yea,
14:45:25 <acowley> @hackage PSQueue
14:45:25 <lambdabot> http://hackage.haskell.org/package/PSQueue
14:45:27 <quchen> That sounds good.
14:45:50 <quchen> Hmm, from 2008
14:46:07 <Feuerbach> that was a good year
14:46:17 <heatsink> Deleting from a Set is O(log n)
14:46:20 <acowley> http://hackage.haskell.org/package/fingertree-psqueue
14:46:22 <acowley> that's vintage 2011
14:47:00 <mm_bureau> quchen: if you don't mind mutability you can use a ring buffer…  otherwise it would be useful to know how you index
14:47:21 <mm_bureau> Seq is pretty fast if you index by date
14:47:48 <quchen> Oh right, a ring buffer will do as well.  (The data I want to store is list-y.)
14:48:25 <quchen> But a ring buffer has O(n) lookup as well, so what's the advantage over Seq?
14:48:37 <mm_bureau> quchen: a ring buffer has O(1) lookup by index
14:48:38 <quchen> Well, I'd be making a ring buffer with Seq I guess
14:48:49 <mm_bureau> quchen: no, a ring buffer is a mutable structure
14:48:52 <quchen> Oh, array-based ring buffer. That's why you mentioned the mutability
14:49:03 <mm_bureau> yes…  you write in a sliding-window manner
14:49:18 <mm_bureau> i think Seq is the next best solution
14:49:32 <mm_bureau> it's logarithmic in worst case, but almost constant at the two ends
14:49:50 <quchen> I would need lookup by element value though
14:49:59 <quchen> i.e. "has X been observed before"
14:50:00 <mm_bureau> then Seq sucks =)
14:50:05 <acowley> You're rejecting PSQueue for not being updated recently?
14:50:18 <FreeFull> What's the best choice for something where you're constantly adding data on one end and taking it off the other?
14:50:25 <mm_bureau> FreeFull: Seq
14:50:28 <quchen> acowley: No, I'm looking through it. I meant that "2008" in the sense of "I hope it compiles" :-)
14:50:47 <mm_bureau> FreeFull: well, "best immutable"
14:51:22 <AVM> jle': you here?
14:51:33 <AVM> jle`: you here?
14:54:41 * hackagebot singletons 0.9.2 - A framework for generating singleton types  http://hackage.haskell.org/package/singletons-0.9.2 (RichardEisenberg)
14:55:17 <AVM> jle`: I figured how to do the stuff with ST andRand
14:55:20 <epta> Here I've found another FilePath http://hackage.haskell.org/package/system-filepath-0.4.8/docs/Filesystem-Path.html#t:FilePath
14:55:36 <epta> is it somehow convertable to GHC.IO.FilePath from Prelude
14:55:43 <epta> ?
14:56:06 <epta> Ans what is the point of having own FilePath definition
15:02:51 <epta> Well, GHC.IO.FilePath is just a String type-synonym, ok
15:15:28 <sm> epta: to clarify the intent of your code and reduce errors
15:18:49 <epta> Btw, is there some method to drop FilePath from another? Like "a/b/c" `drop` "a/b" == "c"
15:20:12 <epta> stripPrefix doesn't work with dirnames
15:20:28 <johnw> epta: yes, it's in System.FilePath
15:21:05 <johnw> takeFileName
15:21:09 <johnw> @let import System.FilePath
15:21:11 <lambdabot>  Defined.
15:21:14 <johnw> > takeFileName "a/b/c"
15:21:15 <lambdabot>  "c"
15:21:23 <ocharles> mm_bureau: so what is the sane way of doing pull-ing in netwire 5?
15:21:34 <ocharles> poll everytime i step the wire, and shove the results in as input?
15:21:52 <mm_bureau> ocharles: you don't /do/ pulling
15:21:57 <mm_bureau> it's internal and not implemented right now
15:22:03 <epta> johnw: that was a bad example :). "a/b/c/d" `drop` "a/b" == "c/d"
15:22:24 <johnw> you'll have to split the filepath into components
15:22:30 <johnw> and then drop 2 on that list
15:22:45 <mm_bureau> ocharles: closing the bureau…  i'll be back in about 30 mins as mm_freak =)
15:22:49 <ocharles> hehe, ok
15:22:54 <ocharles> maybe we'll pick this up tomorrow. I should sleep
15:23:54 <sm> what about stripPrefix in system-filepath
15:24:04 <quchen> :t let drop' (_:xs) (_:ys) = drop' xs ys; drop' _ ys = ys in drop' -- johnw, epta?
15:24:05 <lambdabot> [t] -> [t1] -> [t1]
15:24:25 <quchen> let drop' (_:xs) (_:ys) = drop' xs ys; drop' _ ys = ys in drop' "a/b/c/d" "a/b"
15:24:27 <quchen> > let drop' (_:xs) (_:ys) = drop' xs ys; drop' _ ys = ys in drop' "a/b/c/d" "a/b"
15:24:28 <lambdabot>  ""
15:24:37 <quchen> Eh, flipped.
15:25:15 <quchen> Anyway, evil exploiting of stringly typed paths ;-)
15:25:48 <scriptor> in something like µP.Rec{pos : int; move : int → P}, how do you read the "µP.Rec" part?
15:26:28 <heatsink> It's a fixed point operator
15:26:30 <quchen> That doesn't look like Haskell. Is µ TAPL's recursive-type-lambda?
15:26:36 <scriptor> right
15:26:45 <heatsink> It's defining Rec in terms of itself
15:26:48 <scriptor> but literally, how do you read it, as in how do you say it out loud?
15:27:02 <scriptor> "micro P Rec"?
15:27:10 <pavonia> *mu
15:27:11 <quchen> μ is "mu".
15:27:14 <quchen> As in "mew".
15:27:16 <scriptor> right
15:27:17 <quchen> … ish
15:27:22 <scriptor> so "mu P rec"?
15:27:30 <quchen> Sure, why not.
15:27:44 <quchen> How do you pronounce "λ x.f"?
15:27:52 <quchen> Chances are you'll say "lambda" at some point.
15:28:00 <scriptor> cool, just wondering
15:28:25 <scriptor> just making sure there's no longer way to say it, kind of like a :: Int is "a has type int"
15:28:33 <AshyIsMe> is there a pronunciation guide for common haskell operators somewhere?
15:28:44 <quchen> Yes, I think there is one in the Wiki
15:28:59 <scriptor> http://www.haskell.org/haskellwiki/Pronunciation
15:29:04 <quchen> http://stackoverflow.com/a/7747115/1106679
15:29:21 <AshyIsMe> ah cool, it doesnt go too far though
15:29:36 <AshyIsMe> i got up to the applicative functors chapter in lyah last night
15:29:40 <AshyIsMe> was wondering how to say <$>
15:29:47 <FreeFull> fmap
15:29:51 <AshyIsMe> ah yeap
15:30:08 <quchen> scriptor: The leading whitespace in that table is awful! ;-)
15:30:27 <nooodl> so is there a book on how to pronounce lens operators
15:30:37 <heatsink> haha
15:32:37 <quchen> nooodl: I think there is a formal proof around that they're unpronouncable
15:33:22 <johnw> nooodl: that's easy; just invent a new and unpronouncable alphabet
15:33:31 <johnw> "the symbol formerly known as view"
15:33:40 <quchen> <<>~ is the rat operator
15:33:49 <FreeFull> (:[]) is the robot monkey
15:34:03 <heatsink> ! is pronounced as a dental click
15:34:05 <hpc> all operators are now named "edwardk"
15:34:18 <Feuerbach> AshyIsMe: <$> is pronounced Swierstra florin
15:34:21 <quchen> hpc: Like "smurf" back in the days?
15:34:26 <Feuerbach> http://www.staff.science.uu.nl/~hage0101/liberdoaitseswierstra.pdf
15:34:30 <quchen> >=> is fish composition
15:34:47 <heatsink> >>= is "much greater than or equal to"
15:34:56 <quchen> heatsink: Or right-shift-mutate
15:35:17 <merijn> <>~ <- sperm operator
15:35:19 <hpc> . o O ((<=>) :: (a -> m b) -> (b -> m a) -> m (a, b))
15:35:40 <FreeFull> hpc: How would that be implemented?
15:35:44 <hpc> carefully
15:35:52 <merijn> Probably needs MonadFix
15:35:54 <merijn> :t mfix
15:35:55 <lambdabot> MonadFix m => (a -> m a) -> m a
15:36:00 <quchen> MonadZip?
15:36:09 <hpc> it'd be mfix plus an enforcement on ordering of argument actions
15:36:12 <quchen> MonadFixZip.
15:36:57 <rdevilla> so after seeing this http://cokmett.github.io/cokmett/
15:37:03 <heatsink> :t \ to from -> mfix (\ ~(x, y) -> (,) <$> to x <*> from y)
15:37:03 <rdevilla> is %%.%=-+ actually a thing
15:37:03 <lambdabot> (MonadFix m, Applicative m) => (t -> m t) -> (t1 -> m t1) -> m (t, t1)
15:37:09 <hpc> f <=> g = mfix $ \(a, b) -> (,) <$> f b <*> g a
15:37:19 <hpc> :t let f <=> g = mfix $ \(a, b) -> (,) <$> f b <*> g a in (<=>)
15:37:20 <lambdabot> (MonadFix m, Applicative m) => (t1 -> m t) -> (t -> m t1) -> m (t, t1)
15:37:24 <merijn> rdevilla: No, neither is a Semirepresentableoid :p
15:37:30 <merijn> rdevilla: It's a joke/parody
15:37:31 <rdevilla> :<
15:37:39 <hpc> quick, someone find a use for it!
15:37:58 <hpc> i bet FRP could use it, actually
15:38:07 <heatsink> I think you need a lazy pattern binding hpc
15:38:10 <rdevilla> and I was excited for my coproendosemidetached
15:38:17 <hpc> heatsink: doh, yes
15:38:24 <hpc> but it typechecks so who cares ;)
15:38:50 <quchen> At least one of me and ocharles have a problem counting one day per day. There seems to be a new 24 days article every 7 hours.
15:46:37 <AshyIsMe> Feuerbach: i think i'll stick with fmap
16:19:45 <slack1256> It's my idea, or for ghcmod-vim to work on a project, I need to have all the dependencies listed on the .cabal file?
16:19:48 * hackagebot FormalGrammars 0.0.0.1 - (Context-free) grammars in formal language theory  http://hackage.haskell.org/package/FormalGrammars-0.0.0.1 (ChristianHoener)
16:28:28 <dagano> > let x :: Int = maxBound
16:28:29 <lambdabot>  not an expression: `let x :: Int = maxBound'
16:28:49 <dagano> heaalp?
16:29:00 <ParahSailin> > maxBound :: Int
16:29:01 <lambdabot>  9223372036854775807
16:29:26 <Rarrikins> > let x :: Int; x = maxBound in x
16:29:27 <lambdabot>  9223372036854775807
16:29:36 <dagano> aah thx
16:29:36 <c_wraith> > let x = maxBound :: Int in x
16:29:37 <lambdabot>  9223372036854775807
16:30:01 <c_wraith> dagano: two things.  in an expression context, let must always be followed by in
16:30:14 <c_wraith> dagano: that's what lambdabot was complaining about
16:30:27 <c_wraith> dagano: but you also can't put the type on a value with that syntax
16:30:32 <dagano> let x = 5 in x + 3
16:30:36 <dagano> > let x = 5 in x + 3
16:30:37 <lambdabot>  8
16:30:51 <Rarrikins> > let 3 = 4 in 3 + 2
16:30:52 <lambdabot>  5
16:31:18 <dagano> so in <stuff here> is the expression... let is bindings
16:31:32 <slack1256> naughty lambdabot, naughty
16:31:35 <slack1256> 3 /= 4
16:31:44 <Rarrikins> It does in some types.
16:31:50 <slack1256> you will get coal for xmas!
16:31:55 <Rarrikins> :(
16:31:59 <dagano> i like that
16:32:59 <dagano> in Rarrikins' example .. 3 = 4 means what in terms of variables and values?
16:33:00 <mm_freak> Rarrikins: '3 = 4' is a failed pattern-match
16:33:23 <Rarrikins> Ahh
16:33:27 <mm_freak> > let x@3 = 4 in x
16:33:28 <lambdabot>  *Exception: <interactive>:3:5-11: Irrefutable pattern failed for pattern x@3
16:33:28 <c_wraith> It's an edge case in the syntax that it's allowed - because it doesn't actually define a name, so it doesn't do anything.
16:33:47 <mm_freak> > let x@3 = 3 in 2*x
16:33:48 <lambdabot>  6
16:34:01 <c_wraith> > let 2 + 2 = 5 in 2 + 2
16:34:02 <lambdabot>  5
16:34:06 <coolbeans> hi, this book i am reading talks about using this function called "ord", but when i try to use it in ghci it tells me the function is not defined?
16:34:15 <c_wraith> coolbeans: import Data.Char
16:34:17 <coolbeans> now i found out its in the module Char?
16:34:22 <coolbeans> ah.
16:34:23 <coolbeans> thanks
16:34:30 <slack1256> on ghci i would be
16:34:31 <Rarrikins> > let 2 + 2 = 5 in 2 + 3
16:34:32 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
16:34:32 <mm_freak> coolbeans: Char is haskell 98 and obsolete now
16:34:37 <slack1256> :m +Data.Char
16:34:39 <Rarrikins> As expected!
16:34:49 * hackagebot GrammarProducts 0.0.0.2 - Grammar products and higher-dimensional grammars  http://hackage.haskell.org/package/GrammarProducts-0.0.0.2 (ChristianHoener)
16:34:50 <c_wraith> slack1256: recent versions of ghci support import statements, too
16:34:51 * hackagebot GrammarProducts 0.0.0.3 - Grammar products and higher-dimensional grammars  http://hackage.haskell.org/package/GrammarProducts-0.0.0.3 (ChristianHoener)
16:34:54 <slack1256> neat
16:35:05 <coolbeans> why is Char obsolete now?
16:35:16 <slack1256> the namespace is obsolete
16:35:18 <jrmithdobbs> coolbeans: because it's slow and [Char] sucks
16:35:19 <mm_freak> coolbeans: because the flat module namespace of h98 is obsolete
16:35:25 <slack1256> now is called Data.Char
16:35:27 <jrmithdobbs> ;p
16:35:54 <mm_freak> (it's still flat in a sense)
16:36:08 <donri> are hierarchical modules actually in haskell2010 though
16:36:21 <mm_freak> donri: if that's a question, then yes =)
16:36:25 <coolbeans> how would ord be defined now?
16:36:59 <mm_freak> coolbeans: ord 'A' = 65; ord 'B' = 66; …
16:37:04 <mm_freak> conceptually
16:37:23 <coolbeans> mm_freak: so would it be okay if i wrote my own ord function?
16:37:28 * Hodapp writes "comonads" on a 2x4 and bangs his head into it repeatedly.
16:37:29 <c_wraith> Fortunately, it's more efficient than that internally. :)
16:37:29 <slack1256> I believe the module Data.Char has the same code as Char, they only changed the name of the file
16:37:31 <coolbeans> mm_freak: or is that re-inventing the wheel?
16:37:38 <mm_freak> coolbeans: probably not, because it would be a huge waste of time =)
16:37:47 <mm_freak> coolbeans: and really huge, because unicode is huge
16:37:53 <c_wraith> coolbeans: note that Char represents a unicode codepoint.
16:37:59 <slack1256> Hodapp: Comonads are just the dual of a monoid of on the category of endofuctors
16:38:02 <slack1256> what is the problem?
16:38:24 <Hodapp> >_<
16:38:41 <edwardk> A comonad is just a functor with 2 extra operations and laws that look like the monad laws in a funhouse mirror
16:38:54 <k00mi> coolbeans: just import Data.Char instead of Char
16:38:55 <slack1256> (That is some joke I saw on a T-shirt, I struggle with them too)
16:39:33 <mm_freak> coolbeans: as an additional motivation to import Data.Char, ord is O(1)
16:39:48 <mm_freak> [citation needed]
16:39:49 * hackagebot DnaProteinAlignment 0.0.0.1 - Frameshift-aware alignment of protein sequences with DNA sequences  http://hackage.haskell.org/package/DnaProteinAlignment-0.0.0.1 (ChristianHoener)
16:39:56 <coolbeans> k00mi: slack1256 mm_freak c_wraith well, when i type in m: +Data.Char in GHCi, it gives me a syntax error of some sort
16:40:06 <mm_freak> coolbeans: ":m"
16:40:09 <jrmithdobbs> coolbeans: :m
16:40:10 <slack1256> it's :m not m:
16:40:11 <mm_freak> not "m:"
16:40:26 <mm_freak> coolbeans: also ghci supports import syntax:  import Data.Char
16:40:27 <coolbeans> sorry, i did type in :m in GHCi, just made a typo error in IRC
16:40:35 <Rarrikins> In ghci, use: import Data.Char
16:40:44 <coolbeans> sweet, that worked
16:40:48 <Rarrikins> For the nice recent versions of ghci.
16:41:04 <mm_freak> nowadays i don't think it's necessary to call those "recent" anymore =)
16:41:08 <Rarrikins> :m is the work of Satan.
16:41:12 <dagano> i am having trouble building instances of graph and tree data types...can anyone point me to a good functional data structure resource?  populating a graph, given either my own type or some library, is blowing my mind
16:41:20 <FreeFull> mm_freak: What about fromEnum?
16:41:22 <kvda> Rarrikins, wait, why?
16:41:27 <haasn> Rarrikins: but how else do you unimport modules?
16:41:28 <edwardk> Hodapp: do you understand monads?
16:41:31 <Rarrikins> kvda: It's harder to type.
16:41:31 <mm_freak> FreeFull: what about it?
16:41:32 <Hodapp> edwardk: sorta
16:41:35 <zRecursive> Can ":m +" add my own module ?
16:41:40 <FreeFull> It's in Prelude by default
16:41:42 <FreeFull> And works on Char
16:41:44 <Rarrikins> haasn: Some Satanic things have uses :)
16:41:48 <edwardk> hodapp: if you had to write a function extract :: (e, a) -> a   could you do it?
16:41:48 <mm_freak> zRecursive: sure, when it's in the search path
16:41:49 <kvda> zRecursive, that's what :a and :l are for
16:42:06 <Rarrikins> :r is also very nice.
16:42:16 <zRecursive> how can i set its search path ?
16:42:41 <mm_freak> zRecursive: normally you don't…  what kvda said
16:43:02 <zRecursive> use absolute path ?
16:43:07 <mm_freak> no
16:43:22 <mm_freak> zRecursive: the usual approach is to invoke ghci with the right module:  ghci Blah.hs
16:43:29 <Hodapp> edwardk: extract = snd?
16:43:35 <mm_freak> when Blah.hs imports other modules, they will be available in the REPL
16:43:51 <edwardk> Hodapp: one down. now try extend :: ((e, a) -> b) -> (e,a) -> (e,b)
16:43:54 <zRecursive> ok
16:44:17 <kvda> you can also use relative paths, from the dir you launched ghci in
16:45:18 <kvda> and you can also looking into making a .ghci file that sets up ghci for that project
16:46:59 <zRecursive> now i have ":set -i/my_proj_dir" in ~/.ghci, then i can use ":load Util" in ghci now.
16:47:19 <edwardk> Hodapp: i kind of expect this one to take a bit longer than extract, so just work through it steadily and let me know when you have it
16:47:43 <edwardk> there is only really one answer that typechecks
16:47:59 <c_wraith> edwardk: undefined? :P
16:48:04 <slack1256> lol
16:48:33 <kvda> zRecursive, i would move that to the /my_proj_dir/, if you intend on working  on other haskell projects :)
16:48:45 <edwardk> c_wraith: one that isn't obviously borked like that =P
16:49:09 <zRecursive> kvda: then i must `cd <my_proj_dir>` first ?
16:49:55 <coolbeans> is leksah.org down?
16:50:12 <coolbeans> nvm, just worked!
16:51:58 <edwardk> Hodapp: if you get stuck let me know
16:53:20 <kvda> zRecursive, no i think ":set -i." should do
16:53:54 <kvda> the dot being the important part
16:56:08 <iron_houzi> Is it possible to use Haskell to create a webapp where I can capture keycodes from the keyboard and write out complex unicode text on the DOM? I also need to be able to adjust the text layout and fonts.. I tried using the contenteditable feature in js, but I had problems with overriding the default keyboard input. I'm really hoping Haskell and the web frameworks might come to the rescue here..
16:56:19 <apples> edwardk: is there a quick overview of indexed functors available somewhere? the only thing i can find is by löh, and it's not very accessible to me (i also don't know any agda)
16:56:47 <L8D> iron_houzi: What you’re trying to do seems like a job for JavaScript
16:57:05 <iron_houzi> Oh, I was afraid that would be the case..
16:57:05 <L8D> unless you want to move everything to the server side and have a really slow webapp
16:57:10 <c_wraith> iron_houzi: A lot of that is stuff that needs to be done in the browser.  There are several ways to compile haskell to js, but the code needs to be JS at some point.
16:57:24 <edwardk> apples: kleisli arrows of outrageous fortune perhaps? https://personal.cis.strath.ac.uk/conor.mcbride/Kleisli.pdf
16:57:54 <Hodapp> edwardk: I've done... extend f t = (fst t, f t), was just trying to write it point-free
16:57:56 <iron_houzi> c_wraith: Yes. I just hoped I could write it all in Haskell and that some Haskell framework had made some abstraction layers to simplify this.
16:58:27 <apples> edwardk: i'll give it a shot, thanks
16:58:32 <edwardk> hodapp: what you have is fine, you could do extend f = fst &&& f
16:58:39 <L8D> iron_houzi: Checkout https://github.com/faylang/fay for one of the best js-transpilers
16:58:46 <mm_freak> iron_houzi: it's possible in principle, but i don't think any framework does it
16:58:48 <edwardk> hodapp: congratulations, you've written your first comonad.
16:58:50 <c_wraith> iron_houzi: nothing yet..  all the methods of compiling haskell to js aren't quite good enough yet.  fay and sunroof are limited in what they can do, ghcjs requires a custom GHC build at the moment..
16:58:57 <Hodapp> edwardk: I'm not familiar with &&&...
16:59:03 <c_wraith> iron_houzi: Check back in a year. :)
16:59:06 <mm_freak> L8D: except that fay is not a haskell compiler
16:59:07 <edwardk> :t (Control.Arrow.&&&)
16:59:08 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
16:59:15 <edwardk> let a = (->) in that
16:59:27 <L8D> mm_freak: Yes, but it allows you to still write haskell
16:59:28 <edwardk> > (head &&& tail) [1,2,3]
16:59:29 <lambdabot>  (1,[2,3])
16:59:30 <iron_houzi> The software is intended to be run locally anyways. I just thought JS in the browser would give good cross-platform features..
16:59:42 <edwardk> > (even &&& odd) 4
16:59:43 <lambdabot>  (True,False)
16:59:54 <c_wraith> iron_houzi: check out threepenny-gui maybe?  It's designed for local UIs via http
17:00:07 <iron_houzi> c_wraith: Wow. THanks.
17:00:25 <c_wraith> iron_houzi: I'm not sure it can do what you need, but it's cool
17:00:28 <edwardk> > (fst &&& id) (1,2)
17:00:29 <lambdabot>  (1,(1,2))
17:00:33 <iron_houzi> BTW. How is cross-platform development in Haskell anyways? Linux, OSX, Windows..
17:00:33 <Hodapp> edwardk: I believe you, but I'm still not sure what the essence of its... comonadditude is.
17:00:46 <mm_freak> iron_houzi: if you could explain the application on a higher level, we could probably provide better answers
17:01:02 <c_wraith> iron_houzi: there's little windows support in libraries.  There's just no particular windows culture
17:01:05 <mm_freak> iron_houzi: cross-platform development, while not trivial, is much easier in haskell than in most other languages
17:01:25 <edwardk> Hodapp: here we're working with the "environment" comonad, or 'coreader'. you can read the environment from it as a comonadic action. fst :: (e,a) -> e      just like you can ask in a monad.
17:01:26 <c_wraith> iron_houzi: some things do make the effort to work on windows, many don't.  I'm guilty of releasing a linux-only library, for instance
17:01:56 <edwardk> Hodapp: a monad is easy to get into and hard to get out of, right? a comonad is easy to get out of and 'hard to get into'
17:02:06 <mm_freak> c_wraith: even when library developers don't make the effort, my experience is that most of them still work out of the box on windows
17:02:19 <Hodapp> edwardk: huh...
17:02:29 <mm_freak> that's because a lot of the system details are abstracted away, even file paths
17:02:51 <FreeFull> c_wraith: Compensates for all the windows-only binaries you usually get
17:02:57 <simpson> I *really* like the comonad for signal processing that the codo-notation paper demonstrates. I wish that it were more obvious when comonads were the answer.
17:03:00 <edwardk> Hodapp: another way to think about it is a monad lets you look around at a tiny piece and decide how to build a 'big new thing' (a -> m b)    then applies that to all the data it has `m a` and stitches them together to get a new big structure made out of all of those parts. but you can only look at one part when deciding what to do
17:03:39 <mm_freak> simpson: whenever you want to lift an "f a -> b" to an "f a -> f b" you most likely want a comonad =)
17:03:58 <coolbeans> functional programming and imperative programming can accomplish exactly the same things; they are both the same, they just use different notation
17:04:10 <mm_freak> coolbeans: different paradigm
17:04:11 <iron_houzi> OK. The rough strokes are: Super simple WYSIWYG Tibetan text editor (mainly layout for printing), so must have a GUI and must be able to capture keyboard keycodes and translate them into complex unicode glyph stacks.. Must be possible to do a one-click install for the OSX/Win users.
17:04:12 <edwardk> Hodapp: on the other hand a comonad gives you access to all of the context in (w a -> b) but only lets you build one tiny part of the result, then we can take the whole `w a` and make a new 'mosaic' out of all those little tiles we're given back, `w b`
17:04:29 <coolbeans> mm_freak: no
17:04:30 <iron_houzi> mm_freak: Do you think it's doable in Haskell?
17:04:44 <edwardk> simpson: this is why i've been writing the articles i have on fpcomplete, trying to show comonads aren't magic or scary and have some practical uses.
17:05:06 <Hodapp> edwardk: feel free to link!
17:06:09 <mm_freak> iron_houzi: certainly, but as said the JS-targetting compilers are currently mostly alpha
17:06:21 <edwardk> hodapp: https://www.fpcomplete.com/user/edwardk   cellular automata part 1 uses a store comonad, part 2 introduces a comonad for folds as part of writing a png writer, snippets: mandelbrot gives more use of that style
17:06:39 <mm_freak> iron_houzi: for the time being you can check out haxe
17:06:42 <edwardk> conquering folds shows another comonad for parallel reductions over large tree structures
17:06:44 <simpson> edwardk++
17:06:49 <kvda> iron_houzi, that is entirely javascript's domain
17:07:17 <mm_freak> iron_houzi: also you can employ some of the abstractions you would typically use in haskell
17:07:21 <edwardk> one thing to note is you probably _won't_ structure your entire app around one comonad like you do with a monad.
17:07:21 <simpson> edwardk: Also I realized that I may have met you in person without realizing it. Were you a GSoC mentor about half a decade ago?
17:07:23 <mm_freak> for example you can use FRP with bacon.js
17:07:30 <edwardk> if you use them at all you'll often have lots of little comonads
17:08:07 <edwardk> simpson: i've been mentoring/admining for haskell for at least 5 years now, yeah
17:08:15 <Hodapp> edwardk: thanks!
17:08:50 <edwardk> simpson: if you went to the gsoc mentor summit, we've probably met =)
17:08:59 <simpson> edwardk: I went to the mentor summit once either five or six years ago; I had mentored for Xorg and didn't grok higher-level languages. I had a conversation with somebody about Haskell and ropes.
17:09:16 <c_wraith> ropes was a library edwardk worked on a while ago
17:09:36 <edwardk> simpson: that'd be me
17:09:49 <coolbeans> what is a mentor summit?
17:09:52 <simpson> Once, I was the student. Now, uh. I guess I'm still the student?
17:10:09 <edwardk> and about 5 years ago they were on folks minds because of the icfp 2007 contest
17:10:39 <barkappara> can i get support for cabal in here? there's nobody in #cabal
17:11:22 <edwardk> coolbeans: after the google summer of code, google invites a couple of mentors from each organization down to headquarters for a bit of an 'unconference'. it has been pretty good at bringing the open source community together.
17:11:44 <edwardk> barkappara: dcoutts is usually around, try asking your question, and if nobody else answers he'll eventually see it ;)
17:12:26 <coolbeans> edwardk: ah, i see.
17:13:22 <johnw> I didn't even know about #cabal; I've always asked cabal questions in #hackage
17:13:40 <mm_freak> coolbeans: whether you write "foreach(x in xs) { putStrLn(x); }" or "mapM_ putStrLn xs" is not just syntactic difference =)
17:14:05 <edwardk> coolbeans: for instance i have started talking to the guys who do rtems about what it'd take to put all my succinct data structure stuff to work in their filesystem, and have generally been able to help folks in a lot of different areas find haskell and apply it, and point out algorithms or data structures folks didn't know were there. in the receiving side, talking to the gcc folks was quite useful for improving a jit of mine, etc.
17:14:27 <mm_freak> similarly:  "var s = 0; foreach(x in xs) { s += x; }" is a lot different from "foldl' (+) 0 xs"
17:14:52 * hackagebot webdriver-angular 0.1.0 - Webdriver actions to assist with testing a webpage which uses Angular.Js  http://hackage.haskell.org/package/webdriver-angular-0.1.0 (JohnLenz)
17:14:55 <edwardk> hodapp: https://www.fpcomplete.com/user/edwardk/parallel-crc also uses a comonad to compute CRCs in parallel
17:15:00 <coolbeans> mm_freak: it is mm_freak, i promise. if looked at from a formal theoretical perspective, both the functional and imperative paradigms aren't paradigms, as much as the same thing with different notation
17:15:36 <mm_freak> coolbeans: they have to be equivalent in expressive power, but they do not use the same theoretical foundation
17:15:55 <mm_freak> functional is generally based on lambda calculus, while imperative is based on turing machines
17:15:57 <coolbeans> mm_freak: they do, would you like me to link you to a source, or should i not bother?
17:16:17 <mm_freak> coolbeans: alright then, you're right
17:17:02 <coolbeans> mm_freak: no, i don't want you to just say i am right. i don't care about being right. i mean, if you want to learn, i can show you. if you don't want to, i won't trouble you anymore. there is no need to insult me by simply saying "okay you're right" though...
17:18:09 <mm_freak> coolbeans: it was not an insult, it was my acknowledgement that this discussion, if we continue it, will be tiring and inconclusive =)
17:18:35 <coolbeans> at the heart of imperative programming we have assignment, at the heart of functional programming we have the function application axiom. both are exactly the same thing, except with different notation.
17:18:54 <coolbeans> mm_freak: i don't think it will be tiring and inconclusive, because it can be shown formally, with mathematics.
17:19:07 <mm_freak> coolbeans: of course it can
17:19:20 <coolbeans> okay, i'll leave you alone now, sorry.
17:19:37 <simpson> coolbeans: And at the heart of object-based languages we have Heart, right? :3
17:19:45 <mm_freak> coolbeans: i wasn't making fun of you, i'm serious
17:19:48 <jj2baile> coolbeans: can you link to a source anyway? just for my future reading
17:19:52 <mm_freak> they have to be equivalent at some level
17:20:03 <mm_freak> otherwise there would be programs you could write only in one of the two =)
17:20:11 <mm_freak> s/at/on/
17:20:17 <coolbeans> jj2baile: http://www.cs.utoronto.ca/~hehner/FMSD/
17:20:25 <jj2baile> Oh hey that guy
17:20:28 <coolbeans> simpson: lol
17:20:28 <mm_freak> coolbeans: but you're missing an important point
17:20:38 <jj2baile> coolbeans: thanks
17:20:43 <coolbeans> mm_freak: what might that be?
17:20:59 <coolbeans> jj2baile: no problem
17:21:16 <mm_freak> coolbeans: a hammer is equivalent to a baseball bat in the sense that you can hit a ball with a hammer and run a nail into a wall with a baseball bat
17:21:49 <mm_freak> saying that they are equivalent is correct, but saying that they are the same thing is wrong
17:22:26 <Twey> If you'll permit me an analogy: they're the same in the same sense English and Japanese are the same.  They're both languages; they're both used for the same purposes; they can both express the same things.  But that doesn't mean that the respective *ways* they express those things are anything alike.
17:22:55 <mm_freak> coolbeans: first of all "functional programming" is not a well-defined term…  there are multiple contradictory definitions, depending on who you ask
17:23:08 <coolbeans> mm_freak: urm, no. i am not talking about similarities at *that* base a level. i am saying that if we are reasoning about imperative programs and functional programs, we can use a theory that is essentially the same, except the notation is different. in imperative programming we have assignment, sequential composition,...in functional programming we have function application and function composition. they are fundamentally the same
17:23:47 <coolbeans> mm_freak: honestly, this isn't my idea. someone who is super smart at CS and has a long history of contributions stated this.
17:23:59 <coolbeans> and i loved it, lots of light bulbs turned on, for me at least.
17:24:18 <mm_freak> coolbeans: again, they have to be equivalent…  this is not a surprising result
17:24:30 <mm_freak> but the paradigm is still different
17:25:03 <coolbeans> we can reason about them in much the same way too! so the paradigm really isn't different if you are approaching it formally
17:25:28 <coolbeans> maybe if you are approaching it in the way E.W.Dijkstra would have hated, it would be different
17:25:29 <mm_freak> we can reason about them in the same way, if we bother to translate one of them to the other
17:25:45 <coolbeans> no, we don't even have to bother to translate one to the other
17:25:55 <mm_freak> similarly you can do everything you do in haskell in C as well, if you essentially write a haskell interpreter in C =)
17:25:59 <mm_freak> do you understand what i mean?
17:26:00 <coolbeans> imperative specifications and functional specifications are *basically* the same darn thing with different notation
17:26:10 <mm_freak> ok
17:26:21 <coolbeans> *shrugs*
17:26:43 <mm_freak> it already starts to get tiring, and i have functional code to write now =P
17:26:54 <coolbeans> go ahead
17:26:58 <coolbeans> have fun
17:27:04 <coolbeans> i have more formal methods to enjoy
17:27:17 <coolbeans> i have more formal methods stuff* to enjoy
17:27:25 <chrisw_> exit
17:27:30 <Twey> coolbeans: Would you mind pointing me to this research you mention?
17:27:32 <coolbeans> i'll sharpen my axe with dijkstra's kool aid
17:27:45 <coolbeans> Twey: http://www.cs.utoronto.ca/~hehner/FMSD/
17:28:01 <Twey> That's not research, that's an entire semester's worth of lectures, most of which don't look to be terribly related
17:28:34 <coolbeans> Twey: you can just look at the textbook, honestly.
17:28:41 <coolbeans> Twey: and there's a link to that there.
17:28:55 <mm_freak> i can't wrap my head around how anyone could say that folds and loops are the same thing with different notation =)
17:29:25 <coolbeans> mm_freak: good thing the world doesn't revolve around what you can and can't wrap your head around!
17:29:27 <Hodapp> Twey: If the functional specification is *total* functional, and the imperative specification is still Turing-complete, how equivalent can they be and how amenable to formal analysis?
17:29:31 <Hodapp> errr...
17:29:35 <Hodapp> direct that to coolbeans
17:29:40 <mm_freak> coolbeans: now you're getting insulting
17:29:53 <coolbeans> Hodapp: http://www.cs.utoronto.ca/~hehner/aPToP/
17:30:03 <mm_freak> coolbeans: notational difference means:  you can translate one to the other on a purely syntactic level
17:30:07 <coolbeans> mm_freak: i am sorry, its just hte truth. the same thing applies to me. i am just a little nothing playing in a puddle
17:30:18 <Hodapp> coolbeans: How about you answer instead of name-dropping?
17:30:22 <coolbeans> mm_freak: yes, that is exactly what i am saying.
17:30:33 <Twey> coolbeans: I just wanted an outline of the proof :þ
17:30:35 <coolbeans> Hodapp: i am not name dropping. i linked you to a textbook that covers it this time.
17:30:44 <mm_freak> coolbeans: but you can't translate a C for loop to a haskell list fold
17:31:01 <Hodapp> coolbeans: Linking me to a textbook that supposedly covers it *is* basically just name-dropping.
17:31:04 <coolbeans> oh, if you want the outline of the proof, look at lecture 21 alone, or section....5.8 in the "a practical theory of programming" textbookj that i linked you to
17:31:25 <coolbeans> but, you almost have to read chapters 2 and 3 and 4 before reading 5.8...so...
17:31:31 <coolbeans> sure, maybe that's "name dropping"
17:31:57 <coolbeans> i can't give it to you on a silver spoon, just a copper spoon
17:32:09 <Hodapp> coolbeans: I'm asking you for a practical summary of this. How could a total functional specification, one that cannot express something Turing-complete, be equivalent to something expressed in an imperative language that *is* Turing complete?
17:32:35 <coolbeans> Hodapp: i don't care about turing complete.
17:32:38 <coolbeans> lol
17:32:43 <mm_freak> coolbeans: you should
17:32:47 <coolbeans> there's a reason why lambda calculus exists.
17:32:54 <Twey> coolbeans: Thank you
17:33:04 <coolbeans> sure *shrug*
17:33:21 <Hodapp> coolbeans: You should, because Turing completeness rather throws a wrench into the ability of a formal procedure to determine much about that spec, including whether or not it is equivalent.
17:33:41 <coolbeans> Hodapp: it doesn't at all, really. i don't think you are too familiar with formal methods.
17:33:58 <coolbeans> Hodapp: i am sorry, i linked you to a very complete source of information. we can't argue it superficially.
17:34:07 <thebnq> typed lambda calc isn't turing complete, thats a big wrench
17:34:48 <mm_freak> coolbeans: my feeling is that you're just repeating some ten-liner you've read somewhere without actually understanding what's going on…  Hodapp's objection is very well-founded
17:34:51 <Hodapp> coolbeans: Really. Show me this procedure which can determine whether two things expressed in a Turing-complete language are equivalent.
17:34:56 <coolbeans> thebnq: you are going to way to base a level. we don't need to compare EXTREMELY minimal computational systems.
17:34:59 <speckle> Hodapp, regarding Turing completeness, there's been some minor effort to make Turing Incomplete languages
17:35:12 <Hodapp> speckle: What do you suppose I'm speaking of with 'total functional'?
17:35:29 <coolbeans> mm_freak: yes, if you'd like to, you can believe that.
17:35:33 <coolbeans> i am totally cool with it.
17:36:11 <mm_freak> coolbeans: you can save your reputation by answering Hodapp's question
17:36:14 <speckle> Oh! I see your point, Hodapp.  I'm just interested in Turing-incomplete languages, is all.  Sorry.
17:36:21 <simpson> You don't even need to go that far. Context-free languages are undecidable in equivalence./
17:36:28 <Hodapp> speckle :)
17:36:29 <simpson> And those are far weaker than Turing machines.
17:36:36 <Hodapp> simpson: Interesting...
17:36:50 <Hodapp> speckle: What languages?
17:36:56 <simpson> Hodapp: Turns out computational linguistics is kind of ridiculous that way.
17:37:30 <Hodapp> simpson: I have dealt with context-free languages a little, but I'd never known that proving equivalence is undecidable. I'd have thought it's just a shitty problem.
17:37:49 <speckle> Hodapp, I don't really know them, unfortunately. My interest in Turing-incomplete languages has been limited to reading about them, because they most seem to have abandoned implementations.
17:37:51 <mm_freak> anyway, this is about translation from one framework to another, which doesn't need decidable equivalence
17:38:03 <mm_freak> after all you can translate turing machines to lambda expressions in finite time
17:38:12 <mm_freak> and vice versa
17:38:23 <speckle> Also, if you can interpret language X in language Y, you can surely do the same thing in language Y as language X, but that's not the same as having a loop be equivalent to an arbitrary language construct.
17:38:25 <edwardk> Hodapp: "total" functional programming isn't turing complete, but it is still a surprisingly productive place to work
17:39:02 <mm_freak> edwardk: i'm sure Hodapp understands that
17:39:04 <Hodapp> edwardk: If it's total, where does the Turing incompleteness manifest itself?
17:39:09 <Hodapp> er, completeness
17:39:09 <mm_freak> but coolbeans apparently doesn't =)
17:39:51 <mm_freak> Hodapp: total and complete kinda contradict each other
17:40:01 <mm_freak> in a total language the halting problem doesn't exist
17:40:12 <Hodapp> edwardk: er, wait. I misread!
17:40:22 <Hodapp> edwardk: I thought you were saying that total functional languages could be Turing-complete.
17:40:55 <edwardk> Hodapp: "total" means that it every program terminates. http://www.jucs.org/jucs_10_7/total_functional_programming/jucs_10_07_0751_0768_turner.pdf this gets in the way of writing things where you are worried about termination, if every program terminates the halting problem is trivial, but you can't write the hard problems ;)
17:41:09 <Hodapp> edwardk: yes, yes, we read the same paper :P
17:41:18 <Hodapp> edwardk: I just mis-read
17:41:33 <mm_freak> well, a total program doesn't need to terminate
17:41:44 <edwardk> most of the problems people want to solve in practice though can be handled via well-founded recursion or productive corecursion
17:41:51 <mm_freak> it just needs to produce an answer in finite time, even if the answer is:  "ok, continue there"
17:41:57 <Hodapp> speckle: I believe that Idris requires that functions be total unless you declare them partial. It's likely not the only language.
17:42:26 <mm_freak> Hodapp: for idris it's the other way around
17:42:29 <edwardk> Hodapp: well, my experience here is mostly driven from dealing with a lot of agda programmers ;)
17:42:35 <benmachine> Agda requires functions be total but has datatypes that correspond to "here is some computation I did, I didn't get anything, do you want me to do some more"
17:42:54 <benmachine> (that's roughly my interpretation of the partiality monad, anyway)
17:42:56 <Twey> speckle: Total programming languages are a big topic of research.  You might be interested in Agda and its ilk.
17:43:05 <speckle> thanks!
17:43:11 <edwardk> idris isn't trying to be a theorem prover, it just wants dependent types because they are nice to hack around with
17:43:11 <mm_freak> benmachine: agda does it differently, it has guarded corecursion
17:43:19 <Hodapp> mm_freak: damn, you are right again.
17:44:30 <benmachine> mm_freak: isn't that roughly what I said :P
17:44:52 <mm_freak> benmachine: yes, but it's not the partiality monad =)
17:44:52 <Hodapp> did our pal c**lbeans run away?
17:45:04 <Hodapp> I was finding him rather amusing actually
17:45:14 <coolbeans> mm_freak, Hodapp, edwardk: i can't understand this paper http://www.cs.toronto.edu/~hehner/PHP.pdf, maybe you can!
17:45:24 <coolbeans> i am glad you found me amusing.
17:45:51 <benmachine> coolbeans: oh, that is not what I was expecting PHP to stand for
17:46:04 <coolbeans> benmachine: hehe
17:46:19 <general-general> Wasn't Darth Monad the first Sith Lord?
17:46:34 <coolbeans> mm_freak, Hodapp, edwardk: i don't think it has much to do with what we were talking about before, but i wouldn't know since i am a bona fide simpleton.
17:46:46 <hpc> that abstract seems to think the halting problem is a program that can be fed to itself
17:46:50 * hpc confuzzles
17:46:51 <Hafydd> Darth Monad built the first Sith Academy on Io.
17:46:59 <general-general> Ah.
17:47:07 <Hodapp> hpc: I thought that was how the proof worked in the first place >_>
17:47:21 <edwardk> coolbeans, Hodapp: please lay off
17:47:26 <Hodapp> edwardk: what?
17:47:27 <hpc> Hodapp: i mean, the halting problem itself is a program
17:48:28 <edwardk> Hodapp: "I was finding him rather amusing actually" was rather inflammatory
17:48:34 <hpc> i should probably read the whole thing ;)
17:48:51 <Hodapp> hpc: what program is that? The hypothetical one which examines an arbitrary program?
17:49:05 <mm_freak> solveHaltingProblem :: IO a -> IO ()
17:49:13 <mm_freak> solveHaltingProblem = forkIO >=> killThread
17:49:19 <cognominal> how do I test which ghc platform is installed on a given host?
17:49:29 <coolbeans> anyway, i don't care about turing machines. thank god.
17:49:51 <hpc> Hodapp: i mean, the abstract is worded to imply "the halting problem" is a program
17:50:02 <Hodapp> edwardk: Hrm? I don't see it that way, but telling me to 'lay off' is quite possibly more inflammatory.
17:50:08 <heatsink>  cognominal, do you mean haskell platform?
17:50:25 <cognominal> yes
17:50:25 <Hodapp> coolbeans: Doesn't the notion of Turing completeness still matter a bit here though?
17:50:34 <hpc> basically, it's poorly worded
17:50:40 <coolbeans> Hodapp: if it makes you feel better, he told me to lay off too. i don't think he was trying to be inflammatory, he was trying to diffuse what he perceived to be tension
17:50:56 <cognominal> heatsink, yes, I meant haskell platform
17:51:00 <heatsink> Examine the version of the "haskell-platform" package
17:51:04 <Hodapp> coolbeans: perhaps, perhaps.
17:51:17 <heatsink> ghc-pkg list haskell-platform
17:51:24 <heatsink> I don't know if there's a way to do it programmatically
17:51:25 <coolbeans> Hodapp: i don't think there is a "perhaps" there...just like i don't think turing completeness matters to what we were talking about
17:51:43 <edwardk> Hodapp: quite possibly, and yet, i felt the need to say it as i really don't want to deal with this much tension in the room, and we really rather prefer people to be nice in here.
17:52:03 <cognominal> heatsink, thx
17:52:15 <coolbeans> edwardk: don't worry though, i didn't feel bad! and i hope that i haven't made mm_freak or Hodapp feel bad either
17:52:15 <hpc> oh god, it uses _|_ to mean false instead of undefined
17:52:29 <merijn> hpc: I skimmed it, it didn't seem *obvious* bogus (then again, I only skimmed and it's nearly 3 AM), might need to read more thoroughly tomorrow to have an opinion
17:52:32 <edwardk> on that note, i'm going to let someone else deal with this and go do something fun
17:52:34 <Hodapp> edwardk: Replying to tension rarely resolves...
17:52:52 <edwardk> Hodapp: as an op, it comes with the territory
17:52:54 <heatsink> That's \intuitionistic logic, hpc
17:53:00 <hpc> merijn: i don't really have an opinion yet, i just can't even parse the abstract ;)
17:53:10 <coolbeans> hpc: "oh god, i see new notation!"
17:53:29 <merijn> coolbeans: It's not new notation, just naively misused notation
17:53:39 <coolbeans> lol, hahahahaha
17:53:40 <coolbeans> ohh god.
17:53:42 <merijn> coolbeans: I expect better of people arguing seriously about the halting problem
17:53:57 <merijn> hpc: His main argument seems to boil down to something along the lines of "type error"
17:54:31 <benmachine> I think it's pretty bogus
17:54:38 <merijn> As far as I can skim he's not so much arguing that there is no Halting problem, but that the definition of the halting problem is "uninteresting"
17:54:40 <benmachine> this bit I'm reading about oracles is pretty much nonsense
17:55:03 <merijn> benmachine: I'm leaning towards probably nonsense, but too tired to decide
17:55:07 <coolbeans> pretty bogus: COMPUTING2011 Symposium on 75 years of Turing Machine and Lambda-Calculus, Karlsruhe Germany, invited, 2011 October 20-21. Advances in Computer Science and Engineering v.10 n.1 p.31-60, 2013
17:55:13 <hpc> "X is proved to be (T/_|_) ergo boring; QED"
17:55:29 <coolbeans> http://www.cs.toronto.edu/~hehner/RHP.pdf
17:55:37 <coolbeans> http://www.cs.toronto.edu/~hehner/CH.pdf
17:55:53 <coolbeans> hpc: wow. you proved him wrong with sheer wit!
17:55:59 <coolbeans> -_-
17:56:05 <hpc> no, just being silly
17:56:08 <heatsink> oh, he's not using _|_ in the intuititionistic logic sense
17:56:15 <merijn> coolbeans: Being published proves nothing, I got stuff published and it was freaking terrible
17:56:18 <dagano> name one way to go from IO String -> String
17:56:21 <dagano> please
17:56:23 <merijn> (The stuff I wrote, I mean)
17:56:24 <hpc> heatsink: he's literally using it as "false"
17:56:28 <benmachine> dagano: const ""
17:56:30 <Hodapp> merijn: Don't forget scigen :)
17:56:31 <merijn> dagano: "You don't wannt do that"
17:56:40 <dagano> merijn: why no?
17:56:40 <coolbeans> hpc: he is literally using it to mean "not a theorem", not false
17:56:43 <hpc> coolbeans: when i have an opinion on this paper, it will be clearly labeled ;)
17:56:55 <dagano> ls <- readFile 'path.xxx'
17:56:58 <merijn> dagano: You probably want to read this, though: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
17:57:07 <benmachine> _|_ often means "the least element of an ordered domain", this subsumes "false" and "bottom"
17:57:14 <merijn> dagano: Which explains the details pretty well
17:57:19 <dagano> ok thanks merijn
17:57:23 <hpc> coolbeans: look at the box on page two
17:57:27 <coolbeans> benmachine: exactly. new/different notation. the world must be coming to an end for hpc
17:57:32 <hpc> h : P -> B, where P = program, B = boolean
17:57:41 <hpc> he then says h will return either T or _|_
17:57:53 <hpc> conclusion: T : B, _|_ : B
17:57:54 <coolbeans> hpc: do you know what the : stands for?
17:57:57 <merijn> coolbeans: New notation which is counter to that used by all other people in a field is a red flag
17:58:16 <coolbeans> merijn: you should have said that to dijkstra.
17:58:21 <hpc> coolbeans: i assume it means "spaghetti" ;)
17:58:32 <coolbeans> hpc: thanks.
17:58:38 <benmachine> I really don't think the notation is the issue here
17:58:51 <hpc> it's not, but it's a bit weird
17:58:57 <Hodapp> coolbeans: I've read a good deal of Dijkstra's work, and I'm inclined to agree with merijn here.
17:59:03 <hpc> and making it harder for my haskell brain to get to the meat of the paper
17:59:17 <benmachine> the issues to me are primarily that the paper skips all the sophisticated cleverness that argues you /can/ actually build universal turing machines and encode them in themselves
17:59:43 <coolbeans> Hodapp: well Hodapp if you are inclined to agree, i am inclined to agree!
17:59:44 <benmachine> and that it's remarkably blasé about issues like what things are defined in precisely what ways
17:59:59 <merijn> coolbeans: Anyway, arguments from authority aren't worth much. If you take factual issue with statements people make, please either address or ignore them
18:00:09 <Twey> coolbeans: This lecture seems to show obvious equivalence between a small subset of imperative and functional programs (that is, those functional programs that can be expressed with only iterative recursion), then hand-wave away the rest
18:00:13 <coolbeans> merijn: noted, thank you.
18:00:18 <hpc> "if the
18:00:18 <hpc> if
18:00:22 <hpc> doh
18:00:39 <hpc> "if the if-part terminates with result _|_" -- doh, my brain
18:00:42 <coolbeans> Twey: no.
18:00:48 <Twey> (in the last two slides at the end)
18:00:50 <merijn> But I need to drop out of the discussion anyway, sleepy time
18:01:09 <coolbeans> Twey: that's why you need chapter 2, 3, and at least part of 4
18:01:36 <benmachine> coolbeans: incidentally, if your claim is that imperative vs. functional is "just" notation, I wonder why you are so down on notation
18:01:52 <Twey> coolbeans: You mean he handles non-iterative functions in a different place?
18:01:59 <coolbeans> Twey: yes.
18:02:02 <benmachine> IME shitty notation makes it hard to think
18:02:26 <Hodapp> benmachine: 'Notation As a Tool of Thought' from Iverson would tend to agree.
18:02:29 <Twey> coolbeans: Then why did you say ‘no’ to the claim I made about the lecture?
18:02:38 <coolbeans> well, i am sorry for wasting your time everyone!
18:02:39 <hpc> oh god, that oracle section
18:02:50 <coolbeans> i have clearly been outmaneuvered here by people far smarter than me
18:02:50 <hpc> his oracle is equal to h
18:02:56 <coolbeans> i must humbly accept defeat, and pee where i stand
18:02:59 <coolbeans> good luck!
18:03:10 <Hodapp> coolbeans: The sarcasm covering up arrogance is not appreciated.
18:03:22 <coolbeans> Hodapp: i wish it was sarcastic.
18:03:45 <coolbeans> Hodapp: but i really have to drop it now, i have exhausted my very little authority.
18:04:02 <Hodapp> coolbeans: do come back and ask more questions.
18:04:03 <edwardk> coolbeans: hehner is rather well known as being "out on the lunatic fringe". http://recursed.blogspot.com/2013/10/eric-hehners-fringe-computer-science.html http://www.easychair.org/publications/?page=519637442 http://dl.acm.org/citation.cfm?id=1939859 are all deconstructions of his argument
18:04:17 <hpc> "In Turing's time, programs were commands to a computer. Today, they are also mathematical expressions in their own right" -- this is so adorable
18:04:29 <hpc> in turing's time there were no computers to command!
18:04:53 <edwardk> coolbeans: it is an interesting thesis he puts forth, but it falls apart under scrutiny.
18:05:50 <coolbeans> edwardk: uh, i don't really see much scrutiny there.
18:05:54 <edwardk> coolbeans: i'm not saying that he didn't do good work in his career, but he has stepped pretty far away from the thought of the rest of the field, and his work has been torn apart pretty thoroughly since.
18:06:13 <edwardk> "In UTP'06 [4], Hehner claims that the traditional proof of the incomputability of the Halting Function is rather a proof of the inconsistency of its specification. We identify where his argument fails."
18:06:39 <hpc> merijn: dammit, you got my hopes up making me think it was going to be some kind of "typed halting oracle" or something
18:06:45 <edwardk> "With the insights of the present paper, we know that the relevant question is not whether it is well-defined, but whether it is in the specification domain, that is, whether h has a name. Generalized Rice immediately shows that it is not and that this does not say anything about its well-definedness."
18:06:47 <hpc> instead it's just bad math
18:07:02 <merijn> coolbeans: fwiw, I don't think anyone minds specifically discussion of these topics or you questioning the arguments. But more the tone this conversation started (well, when I looked at the screen anyway). A significant number of people here have several years of research knowledge in computational theory, type theory, etc.
18:07:53 <benmachine> merijn: wait, are you pulling rank?
18:08:00 <edwardk> " The uncomputability of the halting problem has a proof, and we teach that proof in most introductory courses in theoretical computer science. The proof doesn't have many steps, the steps are very simple, and it is accessible to any bright junior-high school student. If Prof. Hehner claims that this proof is flawed, then he must point to the exact line of the proof that he disagrees with. Instead, what he does is translate this
18:08:02 <joneshf-work> edwardk, that crc post was interesting. I just finished writing a CRC algo in verilog the other week
18:08:05 <edwardk>  simple proof -- as in this video -- into his own private language in a flawed way, and then raise several objections to his own translation."
18:08:23 <benmachine> merijn: I sympathise with your frustration but #haskell has a reputation for friendliness even in the face of adversity
18:08:27 <merijn> benmachine: Not me, I have like 1 course in computational theory and one in coding and complexity, I know jack
18:08:38 <merijn>                                 
18:08:45 <edwardk> joneshf-work: thanks. turns out i wasn't the first person to note the ease of computing them in parallel, but i hadn't seen it presented in quite that same way
18:09:00 <merijn> benmachine: Well, I was actually gonna follow with:
18:09:01 <merijn>                                 
18:09:06 <merijn> And since most of them can't shutup when they get started on the topic, just asking for clarification rather than attack
18:09:10 <merijn> But I figured that'd line wrap
18:09:21 <merijn> So maybe that cut-off was a bit unfortunate
18:09:42 <benmachine> hmm.
18:09:44 <merijn> I just wanted to emphasize that maybe we'd prefer a more constructive tone of discussion for the topics
18:09:57 <edwardk> coolbeans: each of those quotes takes issue with the structure f hehner's approach and each comes from a different source i linked there
18:10:41 <merijn> eh
18:10:50 <merijn> I mist "might be more constructive" on that line
18:11:00 <merijn> s/mist/missed
18:11:10 <Luke> does shake only allow one cmd per target?
18:11:11 <merijn> I need sleep rather than rambling, good night! :p
18:11:46 <coolbeans> edwardk: http://recursed.blogspot.ca/2013/10/eric-hehner-replies.html
18:15:51 <benmachine> in fairness, this Jeffrey Shallit sounds like a tool from his comments
18:15:57 <edwardk> coolbeans: there isn't a whole lot of substance in Hehner's rebuttal, it mostly dicks around with language used. I do have to admit the basic statement of Shallit that " Instead, what he does is translate this simple proof into his own private language in a flawed way, and then raise several objections to his own translation." has some bite to it, and Hehner doesn't address that issue.
18:16:02 <edwardk> benmachine: yeah he does =)
18:16:34 <coolbeans> edwardk: edwardk please don't feel insulted if from now on i discount everything you say.
18:17:11 <coolbeans> edwardk: honestly gave it my best shot to not judge you too early, but i have given in to my human weakness.
18:17:15 <c_wraith> coolbeans: he won't be insulted, but that's a pretty unwise choice in terms of ignoring someone who generally knows what he's talking about.
18:17:36 <benmachine> c_wraith: I have the same thought in my mind, but it doesn't sound terribly convincing to strangers
18:17:43 <benmachine> let them make their own assessments
18:18:00 <benmachine> or at least, that's what I would do
18:18:03 <edwardk> coolbeans: shallit strikes me as a jerk, but his objection to hehner's translation strikes me as valid, and is echoed by basically every other peer reviewed paper i can find that isn't written by someone named hehner
18:18:06 <coolbeans> c_wraith: i thought edwardk would enjoy that link because of the references hehner makes to actual articles and discussion surrounding his paper, but instead to him its just "dicking around with language"
18:18:29 <coolbeans> edwardk: EVERY? or you mean one? the one that hehner himself refereed and that you first linked to?
18:18:38 <edwardk> coolbeans: i had read the link in question, and it is interesting, but it mostly is two people squabbling
18:19:03 <dagano> > read "4" :: Int
18:19:04 <lambdabot>  4
18:19:13 <coolbeans> edwardk: i am glad that you admit you only skimmed it at least, but please, i am really a nothing. just a 23 year old with an attitude, and i choose to discount you.
18:19:41 <dagano> with the above .. .i'm not 'casting' but rather signaling read :: Read a => String -> a what 'a' is, correct?
18:19:42 <shachaf> Hmm, I agree with edwardk on the whole "lay off" business. It seems that there's way more nastiness in here than is reasonable.
18:19:57 <benmachine> shachaf: go team be-nice-to-everyone!
18:20:01 <shachaf> dagano: Yes.
18:20:37 <twiceler> dagano: Right. By specifying the type, you're choosing the function that will be used to read the string
18:20:51 <dagano> how about this mess i'm about to type?
18:21:04 <dagano> > map (read :: Int) ["2","44"]
18:21:06 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
18:21:06 <lambdabot>              with actual type `GHC.Base.String -> a0'Couldn't match expected ...
18:21:06 <lambdabot>              with actual type `GHC.Types.Int'
18:21:13 <k00mi> I begin to suspect that this is the first time #haskell has been trolled rather successfully (at least in my time here)
18:21:13 <shachaf> dagano: The type of read isn't Int.
18:21:22 <twiceler> > map (read :: String -> Int) ["2","44"]
18:21:23 <shachaf> dagano: Maybe you mean (read :: String -> Int).
18:21:23 <lambdabot>  [2,44]
18:21:27 <benmachine> k00mi: depends on your criteria for success
18:21:30 <dagano> > map read ["2","44"] :: Int
18:21:32 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
18:21:32 <lambdabot>              with actual type `[b0]'
18:21:35 <shachaf> Or maybe you want to specify that the whole thing has type [Int]. Either works.
18:21:36 <edwardk> coolbeans: between your tone on this issue and hehner, for that matter's i really have very little incentive to dig deeper into his theory. i'll wait until someone like terence tao is convinced and re-evaluate then, but i somehow don't see that happening.
18:21:40 <Iceland_jack> > map read ["2","44"] :: [Int]
18:21:40 <lambdabot>  [2,44]
18:22:06 <coolbeans> edwardk: i am glad we are now both happy :)
18:22:15 <coolbeans> i am ecstatic. every day, i learn a lot.
18:22:44 <twiceler> edwardk: Are you Edward Kmett?
18:22:49 <dagano> so if a type is polymorphic and i want to map it over some stuff .. i have to specify the type variables
18:22:54 <edwardk> twiceler: yes
18:23:13 <Twey> dagano: Only if the type isn't known to the compiler (e.g. by how it's used later)
18:23:31 <Twey> > head (map read ["2", "44"]) + 1
18:23:31 <twiceler> edwardk: Okay. You seem to be full of good ideas! (like https://www.fpcomplete.com/school/to-infinity-and-beyond/deamortized-st) And so I've been wondering...
18:23:33 <lambdabot>  3
18:23:35 <benmachine> dagano: frequently, it won't be necessary to specify them
18:23:53 <benmachine> twiceler: edwardk is noted for his ability to produce good ideas at an uncommon rate
18:23:53 <Iceland_jack> > if read "True" then read "12424" else 24
18:23:54 <edwardk> twiceler: that was a fun article to wite
18:23:55 <twiceler> I am making some mutable arrays that reside on the GPU. And I want to make an ST-ish sort of monad for them
18:23:55 <lambdabot>  12424
18:23:55 <edwardk> er write
18:24:23 <twiceler> In particular, I have some functions which are "read-only" in terms of some arrays
18:24:24 <benmachine> dagano: usually the context in which you use your stuff is enough to precisely determine what type it should be
18:24:31 <benmachine> dagano: but indeed sometimes you need to specify it yourself
18:24:38 <edwardk> twiceler: looking to apply my deamortization trick there as well?
18:25:21 <twiceler> And since I'll also have "immutable" arrays as well, I want to make a function that can sort of neatly accept either a mutable array or an immutable one in the neatest way possible
18:25:51 <edwardk> twiceler: my usual experience with generating efficient gpu code is to write an edsl that decribes abstractly what i want to do, take it and use observable sharing to recover more information about usage and then use all sorts of dirty mutable nastiness to implement the publicly immutable API.
18:26:03 <twiceler> edwardk: I don't think so (I haven't taken the time to understand that completely!), but more I'm interested in the semantics of making immutable things from mutable things
18:26:39 <twiceler> edwardk: observable sharing... thanks! Something I'll have to look up
18:27:29 <edwardk> twiceler: look up 'kansas lava' by andy gill, he has a paper on observing sharing, and there is a paper on nikola by morrisett and mainland which does gpu code generation that has a refinement to give you observable application
18:27:50 <twiceler> edwardk: Awesome, you're the best!
18:28:11 <edwardk> twiceler: if you want to see it in action, you can dig through the work i did with ion on ersatz, which uses observable sharing internally, also the 'kahn' and reverse modes of my ad 'automatic differentiation' package use observable sharing as well.
18:28:50 <twiceler> edwardk: Awesome!
18:31:48 <edwardk> twiceler: morrisett and mainland used to have author copies up on their sites but the only copy of the nikola paper i can find these days is behind the acm paywall
18:33:25 <twiceler> agh, yes, Google Scholar has the now broken link to the author's copy
18:33:39 <oio> can i prefer a function from prelude over the same functions in others modules?
18:34:32 <edwardk> twiceler: try https://www.cs.drexel.edu/~mainland/publications/mainland10nikola.pdf
18:34:52 <edwardk> twiceler: mainland seems to have a copy up at drexel
18:34:57 <twiceler> edwardk: cool, thanks!
18:35:22 <edwardk> twiceler: having reimplemented it several times i can answer questions if you get stuck
18:35:56 <twiceler> oio: You can either type Prelude.(whatever) or hide the other function using import Module hiding (function)
18:36:30 <heatsink> Does Accelerate  use that method of recovering sharing too?
18:37:09 <dhrosa> on that note, how does haskell deal with multiple functions of the same name? Does the later imported one shadow the other one, or can it infer the correct one based on type?
18:37:37 <twiceler> dhrosa: It yells at you (error, won't compile) and makes you disambiguate
18:37:37 <heatsink> It will give you a compile-time error if multiple names are in scope
18:37:44 <jmcarthur> dhrosa: it says "nope"
18:37:57 <heatsink> multiple definitions
18:38:04 <jmcarthur> dhrosa: you can use qualified identifiers though
18:38:12 <heatsink> SPJ had a proposal for type-directed name resolution
18:38:26 <edwardk> heatsink: i never noticed it doing so if it has
18:38:48 <dhrosa> what about the lookup functions in both Prelude and Data.Map?
18:39:04 <heatsink> The documentation for Data.Map suggests importing it qualified
18:39:10 <heatsink> so it would be used as Map.lookup
18:39:14 <jmcarthur> dhrosa: you can hide one, or qualify them
18:39:18 <dhrosa> I'm aware, but if I import Data.Map in ghci I don't get an error
18:39:22 <edwardk> dhrosa: if you have two imports that want the same name then it'll complain until you disambiguate with Prelude.foo or M.foo     if you imported Data.Map as M
18:39:23 <Rarrikins> It deletes the source file.
18:39:25 <dhrosa> until I actually try using lookip
18:39:28 <dhrosa> lookup*
18:39:34 <jmcarthur> dhrosa: just importing is fine. it only complains when you try to use something ambiguous
18:39:36 <heatsink> lol Rarrikins
18:39:39 <dhrosa> ah
18:39:49 <edwardk> dhrosa: it isn't an error to import them, it is an error to call witout disambiguating
18:39:58 <dhrosa> I see
18:40:27 <edwardk> heatsink: TDNR is largely being subsumed by gundry's work on records
18:40:54 <heatsink> Oh, I haven't heard of this
18:41:24 <heatsink> I see there's a GSOC page for it
18:44:27 <danharaj> edwardk: just realized that maybe FRP should be formulated at the level of 2-categories, where implementations should be algebras of a 2-monad. This gives tons of room to deal with the coherence problems I keep running into I mentioned.
18:45:27 <edwardk> danharaj: not sure i see how it helps, it just means you have more headaches ;)
18:45:57 <edwardk> danharaj: i'd love to be proven wrong though
18:46:05 <danharaj> I would love to be proven right.
18:46:33 <edwardk> danharaj: hah
18:47:11 <augur> slightly off topic, but are there any good intro to scala videos?
18:47:14 <DigitalKiwi> at least we're in agreanace?
18:47:23 <Vicfred> Hi, does haskell has something to create all permutations/subsets built-in?
18:47:43 <augur> the scala channel is quite small, and said they didnt know of any, and i figure haskellers probably know better anyway :P
18:48:04 <danharaj> augur: The only good introduction to Scala is the emergency exit door.
18:48:08 <augur> x3
18:48:32 <dagano> i am trying to go from a list to a pretty standard Tree datatype and having trouble writing the fcn...anything I should be thinking?
18:48:58 <Rarrikins> dagano: How do you decide where to put the elements?
18:48:59 <shachaf> > permutations "abc"
18:49:00 <lambdabot>  ["abc","bac","cba","bca","cab","acb"]
18:49:02 <shachaf> > subsequences "abc"
18:49:03 <lambdabot>  ["","a","b","ab","c","ac","bc","abc"]
18:49:27 <Rarrikins> > contiguousSubsequences "abc"
18:49:28 <dagano> Rarrikins: for simplicity, I'm just going to dump them in the tree in breadth first style .. and it'll be binary
18:49:28 <lambdabot>  Not in scope: `contiguousSubsequences'
18:49:38 <shachaf> > (compare `on` (length . show)) (permutations "abc") (subsequences "abc") -- coïncidence?
18:49:39 <lambdabot>  EQ
18:50:12 <DigitalKiwi> augur: did you ask in the scala channel?
18:50:20 <augur> DigitalKiwi: yeah, they said they knew of none
18:50:22 <DigitalKiwi> i have no lastlog of you there :/
18:50:31 <edwardk> dagano: i have rarely heard 'breadth first' as 'for simplicity' ;)
18:51:15 <dagano> not exactly synonyms
18:51:25 <dagano> or synaphrases
18:51:47 <augur> DigitalKiwi: odd. well ill try again!
18:52:04 <Vicfred> shachaf, thanks, I guess I can implement the all subsets using bitwise operations anyway
18:52:06 <DigitalKiwi> and 436 doesn't seem "quite small" :P
18:52:21 <Rarrikins> dagano: The easiest way would be to take the head and to send the remaining odds down one side and the remaining evens down the other.
18:52:25 <Rarrikins> dagano: Something like that.
18:52:44 <Rarrikins> No, that's not quite right.
18:52:56 <Iceland_jack> > concatMap inits (tails "testing")
18:52:57 <lambdabot>  ["","t","te","tes","test","testi","testin","testing","","e","es","est","esti...
18:53:03 <augur> DigitalKiwi: yeah, i dont know. i must have been in a different channel hmm. how odd.
18:53:03 <dagano> ooh but i like that idea
18:53:09 <DigitalKiwi> ;)
18:53:46 <external-reality> The singletons package seems to be working quite nice. Cool!
18:53:46 <Rarrikins> Probably that you take the head, then you send the first two down one, the second two down the other, the next four down one, the next four down the other.
18:54:00 <Rarrikins> Etc.
18:54:41 <dagano> hrmmm ok i'll think about it
18:54:45 <Rarrikins> Hmm, it should start with the first remaining element, the second, the next two, the next two, the next four, the next four, etc.
18:56:31 <dagano> well it has to be recursive .. so if i say .. send the next n down the left subtree .. that sounds like it'll get messy
18:58:00 <oio> any idea?
18:58:00 <oio> "No instance for (Crypto.Random.CryptoRandomGen StdGen)   arising from a use of `generateKeyPair'"
18:58:22 <oio>     rnd1 <- newStdGen     let (puk,prk,rnd2) = generateKeyPair rnd1 1024
18:58:33 <edwardk> coolbeans: monochrom did his ph.d under hehner, perhaps he'd be better positioned to reason one way or the other on the matter.
19:04:29 <Rarrikins> > let zomg xs = f 1 1 xs where f _ _ [] = []; f t 0 xs = let t' = t+t in f t' t' (drop t xs); f t n (x:xs) = x:f t (n-1) xs in zomg [1..10]
19:04:30 <lambdabot>  [1,3,4,7,8,9,10]
19:04:42 <Rarrikins> dagano: Something like that.
19:05:30 <Rarrikins> > let kthx xs = f 1 1 (drop 1 xs) where f _ _ [] = []; f t 0 xs = let t' = t+t in f t' t' (drop t' xs); f t n (x:xs) = x:f t (n-1) xs in kthx [1..10]
19:05:31 <lambdabot>  [2,5,6]
19:05:34 <Rarrikins> And that for the other side.
19:06:04 <dagano> woah
19:07:42 <jmcarthur> i have some code which so far refuses to inline the way i want unless i use GHC.Magic.inline. does anybody have any good tips for debugging inlining problems?
19:08:32 <jmcarthur> another related question: the reason i don't want to just use GHC.Magic.inline is because this is library code and i'm afraid of unnecessarily duplicating code. am i just being paranoid?
19:08:46 <jmcarthur> the inline is being applied to a user supplied argument
19:09:02 <Rarrikins> Magic is the best module name.
19:09:16 <jmcarthur> i think i'm mainly just wanting fairly general advice from a magician
19:09:44 <jmcarthur> Rarrikins: that's about what it is, too!
19:11:19 <johnw> Data.Semigroup is my new best friend
19:12:35 <marx2> in gtk2hs could passing a function that always returns True to treeSortableSetDefaultSortFunc have been causing my program to randomly crash?? since removing that line my program no longer crashes
19:12:50 <marx2> it was rather random though, so I am not sure if I fixed the bug or just hid it
19:15:16 <geekosaur> marx2: various C sort functions can in fact be buggy in that case
19:16:32 <geekosaur> for a very long time the default qsort() implementation would walk backwards off the end of the array to be sorted and (usually) segfault if the sort function returned an inconsistent comparison value (e.g. always claimed second value larger than first)
19:16:43 <Hodapp> huh...
19:17:04 <marx2> that's interesting
19:17:08 <geekosaur> supposedly this has been fixed in glibc for a long time, but I don't know if gtk+'s sort implementation might have the same kind of bug
19:19:07 <geekosaur> (more likely something in glib than gtk+ but I haven't looked closely)
19:19:09 <edwardk> coolbeans: Giving it deeper reading Hehner comes off much better, but i'm somewhat disinclined to discard the entire edifice of the halting problem in reaction to a final talk of somone's career, given at his own festschrift, which has received very little scrutiny so far. I'll stick to my 'waiting for Terry Tao' stance.
19:20:13 <lostpoundsrecent> There's a better way, and you know what it is: liftA (liftA (\x -> (0,x))) $ [[1,2],[1,3],[2,3]]
19:20:22 <lostpoundsrecent> please educate
19:20:50 <edwardk> > fmap (0,) <$> [[1,2],[1,3],[2,3]]
19:20:51 <lambdabot>  [[(0,1),(0,2)],[(0,1),(0,3)],[(0,2),(0,3)]]
19:21:10 <edwardk> > over (traverse.traverse) (0,) [[1,2],[1,3],[2,3]]
19:21:11 <lostpoundsrecent> :edwardk roger dodger
19:21:13 <lambdabot>  [[(0,1),(0,2)],[(0,1),(0,3)],[(0,2),(0,3)]]
19:21:33 <edwardk> > [[1,2],[1,3],[2,3]] & traverse.traverse %~ (0,)
19:21:34 <lambdabot>  [[(0,1),(0,2)],[(0,1),(0,3)],[(0,2),(0,3)]]
19:22:51 <lostpoundsrecent> Wait, though...ghci doesn't like "(0,)" in a quick test
19:23:15 <lostpoundsrecent> fmap (0,) [1,2,3] gives: Illegal tuple section: use -XTupleSections
19:23:29 <ion> use -XTupleSections
19:23:32 <Rarrikins> ((,) 0)
19:23:34 <Luke> jle`: you around?
19:23:49 <danharaj> > traverse (\x -> if even x then Nothing else Just x) [1,5,3,9]
19:23:50 <lambdabot>  Just [1,5,3,9]
19:23:50 <Iceland_jack> lostpoundsrecent: You activate it using ‘:set -XTupleSections’
19:23:52 <Rarrikins> > fmap ((,) 0) [1,2,3]
19:23:53 <lambdabot>  [(0,1),(0,2),(0,3)]
19:24:04 <danharaj> > traverse (\x -> if even x then Nothing else Just x) [1,2,3]
19:24:05 <lambdabot>  Nothing
19:24:10 <triliyn> Even without tuple sections you can use (,) 0
19:24:27 <lostpoundsrecent> :Rarrikins Thanks, I like that
19:24:37 <ion> :wq
19:24:48 <marx2> ZZ
19:24:55 <Rarrikins> lostpoundsrecent: No problem.
19:25:02 <Rarrikins> > fmap (flip (,) 0) [1,2,3]
19:25:03 <lambdabot>  [(1,0),(2,0),(3,0)]
19:25:18 <levi> Regarding Hehner's textbook, there's nothing wrong with his use of T and _|_ in his formal system. True and False are the top and bottom elements of the boolean lattice.
19:25:22 <johnw> > [1,2,3] >>= (,0)
19:25:23 <lambdabot>  Couldn't match type `(,) a0' with `[]'
19:25:23 <lambdabot>  Expected type: a0 -> [b0]
19:25:23 <lambdabot>    Actual type: a0 -> (a0, b0)
19:25:28 <edwardk> lostpoundsrecent: you can switch from (0,) to ((,)0) or you can use {-# LANGUAGE TupleSections #-}
19:25:34 <johnw> > (,0) <$> [1,2,3]
19:25:36 <lambdabot>  [(1,0),(2,0),(3,0)]
19:25:53 <lostpoundsrecent> :edwardk right on
19:25:55 <marx2> > [1,2,3] >>= return . (,0)
19:25:57 <lambdabot>  [(1,0),(2,0),(3,0)]
19:26:26 <Rarrikins> > fmap (,0) [1,2,3]
19:26:27 <lambdabot>  [(1,0),(2,0),(3,0)]
19:26:29 <Rarrikins> Neat
19:27:36 <johnw> > zipWith ($) (repeat (,0)) [1,2,3]
19:27:37 <lambdabot>  [(1,0),(2,0),(3,0)]
19:28:57 <jle`> Luke: yeah, what's up>
19:29:18 <Luke> just going through your shake blog post (thanks for writing this btw)
19:29:31 <Luke> is it possible (or sane?) to have multiple cmd calls per Rule?
19:29:43 <jle`> no problem :)
19:29:47 <jle`> hm
19:29:53 <jle`> i don't see why it wouldn't be possible
19:30:07 <Luke> i get compiler errors when I try
19:30:16 <jle`> let me try
19:30:26 <enthropy> do you use 'do' notation?
19:30:43 <enthropy> shake has monads somewhere in there
19:31:13 <Luke> enthropy: yeah I'm using do
19:31:23 <jle`> huh that's weird.
19:31:54 <Luke> oh I get ambiguous type for the return type because I'm throwing it away
19:32:40 <jle`> yeah, looks like it
19:33:10 <Luke> I have to do this: () <- cmd "..."
19:33:23 <Luke> to explicitly throw away the return type and let it throw exceptions instead
19:33:34 <jle`> you can also specify :: Action ()
19:33:40 <jle`> at the end of your command
19:34:16 <Luke> yeah
19:34:24 <Luke> so is that intentionally hard to do for a reason?
19:34:45 <jle`> i think it's just not able to infer the type
19:34:52 <Luke> also I'm k
19:35:00 <Luke> strike that. I mean "ok"
19:35:14 <jle`> let me look something up
19:37:02 <Luke> something else I'm not sure of: how do I use the file-based Rules to represent multiple build flag types?
19:38:07 <jle`> i actually have to go right now; but i think cmd's behavior is unintentional and is just a failing of the type inference
19:38:29 <jle`> i'll try to get back to you in a couple hours if you still have the porlbme
19:38:31 <Luke> np ty
19:42:20 <AfC> I've used unordered-containers a bit, and gotten along well with it. But if I actually need the keys in a sorted order (at least as far as an Eq or Put instance would be concerned) what package should I use?
19:43:28 <geekosaur> ...containers?
19:45:04 * hackagebot singletons 0.9.3 - A framework for generating singleton types  http://hackage.haskell.org/package/singletons-0.9.3 (RichardEisenberg)
19:50:04 * hackagebot fay-dom 0.3 - DOM FFI wrapper library for Fay  http://hackage.haskell.org/package/fay-dom-0.3 (AdamBergmark)
19:54:18 <AfC> geekosaur: really?
19:54:25 <AfC> geekosaur: ok, I feel like an idiot, then
19:55:13 <geekosaur> well, the reality is that you'd have to describe exactly what kind of characteristice you're looking for.. .but in general, unordered-containers was designed as the unordered companion to the basic containers in the containers package
19:55:52 <AfC> Or I suppose I could just sort the keys after retrieving them from unordered-containers. :/
19:55:58 <geekosaur> there are other kinds of "containers" out there as well, with varying definitions of ordered-ness (hash tables, priority queues, priority search queues, etc.)
19:56:06 <AfC> geekosaur: right.
19:56:08 <AfC> geekosaur: [I'
19:56:22 <AfC> geekosaur: [I've heard people describe containers as heavy weight, for some reason]
19:56:34 <geekosaur> it has a lot of stuff in it
19:57:16 <geekosaur> arguably many things in it could be split out into their own package... but at the same time, much of the "heavyweight" is in relation to the fact that it iships as part of the compiler (ghc)
19:57:28 <AfC> heh
19:57:35 <geekosaur> and, for ghc's purposes, it doesn't need to be quite as complete as it is
19:57:36 <enthropy> you can pretty much take for granted that containers is installed
19:57:40 <AfC> geekosaur: looking at it now it doesn't seem that heavy
19:57:45 <AfC> enthropy: yeah
19:58:34 <geekosaur> (the "boot libraries" that have to come with the compiler instead of being separate packages are rzther larger than they need to be for the purpose of bootstrapping the compiler. so gradually things are being slimmed down so less stuff comes with ghc and more comes with the haskell platform)
19:58:38 <AfC> Ah, I knew I'd seen this somewhere before: "The Map type is shared between the lazy and strict modules, meaning that the same Map value can be passed to functions in both modules (although that is rarely needed)." that's
19:58:45 <AfC> wonderful. I wish ByteString had that
19:58:56 <geekosaur> it does, sort of
19:59:10 <simpson> AfC: A lazy ByteString is basically a list of strict ByteStrings.
19:59:13 <geekosaur> a lazy ByteString is a list of strict ByteStrings, internally
19:59:19 <AfC> simpson: yes, I know that
19:59:46 <geekosaur> but there is no good way to make a single über-ByteString that can serve for either purpose
20:00:05 <AfC> but type-wise you have to spend a lot of time mucking about doing S.ByteString or L.ByteString and often the only way to tell in a haddock document is to hover the damn mouse over the link and squint to see if "Lazy" is in the URL
20:00:14 <mikeplus64> data StupidString = forall a. IsString a => SS a
20:00:47 <mikeplus64> actually that's not enough to do anything because IsString only has fromString
20:00:57 <shachaf> Yes, you want a universal there instead.
20:00:58 <shachaf> "want"
20:01:13 <shachaf> (froall a. IsString a => a) ~~ String
20:01:21 <AfC> type Rope = StupidString
20:01:23 <shachaf> Just like (exists a. Show a *> a) ~~ String
20:01:48 <AfC> anyway, Map did it. ByteString could!
20:02:10 * AfC tucks his forlorn optimism back under the rock it came from
20:02:11 <shachaf> Strict vs. lazy map is about value strictness, not spine strictness.
20:02:19 <shachaf> I didn't know mikeplus64 still existed! Incredible.
20:04:08 <mikeplus64> :)
20:04:42 <mikeplus64> school's over, i've been working on a snap website, killing time and looking for jobs
20:05:20 <djahandarie> Who would hire a murder who snaps frequently!
20:05:38 <mikeplus64> wat
20:06:06 <djahandarie> ...apparently that wasn't as funny as I intended it to be.
20:06:37 <shachaf> I heard a rumour all the jobs are in CA.
20:09:51 <ninegrid> djahandari: snap... killing time... I see what you did there :)
20:16:10 <levi> coolbeans: I've skimmed that textbook up to the point where it discusses refinement of specifications to functional programs, and I think I see where the confusion in the earlier discussion came from.
20:26:20 <BeardedCoder> what do the types alpha and beta mean. ie. IO α and IO β
20:26:39 <shachaf> The same as a and b.
20:26:46 <BeardedCoder> ah, k
20:32:32 <rose> I have my test executable in /root/tests/MyTests.hs, and my .cabal file contains a Test-Suite with this entry main-is  MyTests.hs  and hs-source-dirs src, tests    and yet cabal tells me "can't find the source for MyTests"
20:32:37 <rose> what am I missing?
20:35:08 * hackagebot hpuz 1.1.1 - Haskell bindings for libpuz  http://hackage.haskell.org/package/hpuz-1.1.1 (ChrisCasinghino)
20:37:58 <pavonia> rose: Have you specified the "type" field?
20:38:23 <rose> yes
20:38:36 <coolbeans> levi: sweet! could you help expand on it?
20:38:39 <rose> type:              exitcode-stdio-1.0
20:39:21 <jmcarthur> was thinking somebody might like to see my funky fibonacci implementation... http://lpaste.net/97148
20:39:38 <oio> whats left to make finish this?
20:39:39 <oio> http://lpaste.net/97149
20:40:42 <oio> i understand that in public encryption you exchange public keys but what function uses the other public key?
20:40:57 <oio> http://hackage.haskell.org/package/RSA-1.2.2.0/docs/Codec-Crypto-RSA.html
20:41:52 <pavonia> rose: What is the name of your module in MyTests.hs?
20:42:50 <jmcarthur> that lpaste was my attempt to do something like copatterns using type classes. was a... moderate success
20:43:08 <jmcarthur> i can't do deep copattern matching with this method, which uglies it a bit
20:43:27 <jmcarthur> my use of that Some type is also kind of ugly
20:44:58 <rose> pavonia: I found my mistake. Thank you
20:45:26 <pavonia> What was it?
20:48:49 <Sgeo> I forget, which C-Haskell tool makes stuff that looks like this?
20:48:59 <Sgeo> Because if it's c2hs, that makes me a bit reluctant to use it again
20:48:59 <Sgeo> https://bitbucket.org/Sgeo/haskellaw/src/b5d2371f86efdcfee27eb35966dc7d5262c2b371/Bindings/Activeworlds.hs?at=default
20:49:50 <jmcarthur> Sgeo: that looks like output from such a tool, which is not what you're supposed to commit to your repo. it's a build product.
20:50:16 <Sgeo> Yeah :/ but which tool? This was a while ago
20:50:22 <jmcarthur> Sgeo: and i think that was hsc2hs, not c2hs
20:50:25 <levi> coolbeans: Well, the point of the text and class is to specify a computation, and then to refine a specific program from it through valid transformations. Basically, it defines a semantics of programming, which is a mathematical formalism. Functional programming is concerned with just part of that formalism; the part that talks about functions.
20:50:43 <jmcarthur> Sgeo: you can tell from the references to Activeworlds.hsc
20:50:50 <Sgeo> ty
20:51:13 <Sgeo> Is c2hs more likely to make code that can be used more idiomatically?
20:51:15 <jmcarthur> Sgeo: but, again, i wouldn't let this disturb you too much
20:51:22 <jmcarthur> Sgeo: you aren't supposed to see this
20:51:44 <jmcarthur> Sgeo: oh, those identifiers were probably made by bindings-DSL
20:51:45 <Sgeo> I recall still having to deal with allocating strings when using this code
20:51:58 <Sgeo> Is that still a thing with c2hs or other tools?
20:52:15 <geekosaur> it's code for low level c to haskell bindings. those bindings will *never* be idiomatic; you write your own idiomatic interfaces that call the generated bindings
20:52:29 <jmcarthur> Sgeo: there is no magic tool for generating idiomatic bindings. you normally need to make a higher level wrapper of your own somehow
20:52:36 <Sgeo> https://bitbucket.org/Sgeo/haskellaw/src/b5d2371f86efdcfee27eb35966dc7d5262c2b371/Bindings/Marshal.hs?at=default
20:52:41 <Sgeo> This was manually written code
20:52:59 <jmcarthur> and?
20:53:19 <levi> coolbeans: You'll notice in the text that when he talks about refining to a functional program, he refines *differently* that he does when refining to an imperative program. Although both are concerned with substitution, the *meaning* of the things that are being substituted is different for functional vs. imperative programs.
20:53:34 <Sgeo> Am I still going to need to write similar code? And are there better naming conventions? Because sometimes the c' versions were sufficient
20:54:05 <jmcarthur> Sgeo: you can't get away from writing wrapper functions to make a nice interface
20:54:24 <Sgeo> I should probably learn how to use cabal at some point
20:54:26 <jmcarthur> Sgeo: whether the ugliness takes that form or some other just depends on the tool you use
20:54:27 <coolbeans> levi: i disagree levi.
20:54:50 <jmcarthur> Sgeo: those particular bindings seem to use bindings-DSL (which is meant to be used with hsc2hs)
20:55:00 <Sgeo> With a Lisp, I could theoretically get away with writing a macro to minimize how repetitive it can get
20:55:01 <coolbeans> levi: the refinements are very similar
20:55:05 <jmcarthur> Sgeo: i personally like bindings-DSL, but again, the result is not a final product
20:55:41 <geekosaur> Ageo: anything generated to bind to C functions is going to look and behave like C. there is no automated way to make a nice functional binding, in part because what constitutes "nice" depends on what it's supposed to do and how it's supposed to be used.
20:55:43 <levi> coolbeans: The process of refinement is similar, but the operation of the derived programs is not.
20:55:58 <geekosaur> er, Sgeo
20:56:20 <coolbeans> levi: hmm, that's a good point. i am not sure if that is the case, but i am going to ask about that.
20:57:18 <coolbeans> levi: thank you. you have identified something i don't understand yet :)
20:57:40 <levi> coolbeans: The idea is to produce a program that meets the specification. If you derive a functional program via the functional refinement substitution rules, then you get a functional program. If you derive an imperative program via the imperative refinement substitution rules, then you get an imperative program.
20:58:31 <coolbeans> levi:  i see
20:58:59 <Sgeo> jmcarthur: do any of the tools have easy ways to deal with many of the functions being very similar?
20:59:25 <levi> coolbeans: Another thing to keep in mind is that this is not the only formal system that you can use to formalize programming.
20:59:25 <jmcarthur> Sgeo: you could always define whatever abstractions you need in haskell or, at worse, template haskell
20:59:36 <barkappara> dcoutts: i have a problem with the pango bindings available through cabal http://pastebin.com/rNjz2mbH
20:59:38 <mauke> The paste rNjz2mbH has been copied to http://lpaste.net/97150
20:59:40 <coolbeans> levi: obviously :)
20:59:52 <jmcarthur> Sgeo: but i really think you are seeing this weirdly. i don't see how any set of macros is going to make this trivial
20:59:58 <enthropy> Sgeo: there's http://hackage.haskell.org/package/c2hsc to make hsc files (which use the bindings dsl stuff)
21:00:22 <jmcarthur> Sgeo: at least if you are talking about making something high level semi-automatically
21:00:32 <jmcarthur> Sgeo: there are plenty of tools for making low level bindings to C
21:01:08 <enthropy> actually the original link looks like it was made by c2hsc
21:01:39 <enthropy> or rather it's the hsc2hs output of the hsc file generated by c2hsc
21:03:01 <enthropy> jmcarthur: are there really that many? I don't know if any besides c2hs and c2hsc see much use
21:04:10 <jmcarthur> enthropy: c2hs, hsc2hs, (never heard of c2hsc before right now, but there it is...), greencard, bindings-DSL, etc.   i don't mean they are all mutually exclusive, to be clear
21:04:48 <levi> coolbeans: If you *start* from an imperative program and work backwards towards a formal system, the differences between imperative and functional programs become more clear.
21:06:11 <levi> Of course, the approach of refining a formal specification towards a program is a nice way to avoid that problem!
21:06:49 <jmcarthur> for whoever may have silently been interested in the copatterns stuff i pasted earlier, i just annotated it with a copattern style implementation of the state monad. http://lpaste.net/97148
21:07:40 <enthropy> jmcarthur: yeah there are lots of tools, but not that many mutually-exclusive subsets
21:07:51 <jle`> hey, is it really a big deal that our Show's don't correspond to our Read's?
21:08:16 <Sgeo> Are there a lot of monads that are written mostly because of the nice syntax Haskell provides for them, rather than that they should be monads?
21:08:18 * enthropy thought greencard was dead... but apparently not
21:08:32 <jmcarthur> Sgeo: there aren't really that many, but i think it's still too many
21:08:33 <Sgeo> Blaze almost certainly, any others?
21:08:48 <arkeet> jmcarthur: what is this sorcery
21:08:49 <jle`> Sgeo: http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
21:09:04 <Sgeo> And are such monads that terrible if they're at least real monads? (Again, looking at you Blaze for not even having the decency to be Writer)
21:09:07 <jmcarthur> arkeet: awesomeness. awfulness.
21:09:09 <jle`> particularly #Library_design
21:10:07 <MrWoohoo> is there a book on frp and sodium? or tutorial?
21:10:17 <jmcarthur> Sgeo: i wouldn't say terrible so much as pointless. monads carry more mental baggage than, say, monoids, so it seems harmful to expose your api with unnecessary extra "power"
21:10:17 <jle`> Sgeo: it might be worth mentioning that there is talk about a do syntax that applies to Applicatives (and non-monads)
21:10:18 <MrWoohoo> google isn't helping :(
21:10:36 <Sgeo> jle`: doesn't F# have something like that?
21:10:38 <jmcarthur> arkeet: copatterns: http://www2.tcs.ifi.lmu.de/~abel/popl13.pdf
21:10:58 <jmcarthur> arkeet: although this encoding with type classes isn't quite what is described in that paper...
21:11:05 <arkeet> I'll have a look when my brain is working. thanks
21:11:07 <arkeet> :)
21:11:07 <jle`> Sgeo: in that sense you can have Fake-Writer-Like "Monads" (which basically can just use (*>) instead of (>>)) still use do notation
21:11:11 <jmcarthur> arkeet: also, i'm unhappy with various aspects of this encoding
21:11:20 <quchen> jle`: (*>) is (>>).
21:11:33 <dibblego> F# does not abstract on monad
21:11:44 <jle`> quchen: yeah, just showing that "Fake-Writer" monads that have all return values as () are just applicatives
21:11:52 <jle`> replace (>>) with (*>) to make it clear
21:11:56 <quchen> Ah, ok.
21:12:59 <Sgeo> I fully support special notation for applicatives (and possibly monoids?). But... if this was Lisp, someone would have written a library for it, and it would have the potential to be widely used, and not look awkward... or several competing libraries
21:13:42 <Sgeo> Although, I think the macro thing may hinder willingness to look for good abstractions, using macros to paper over problems
21:13:53 <quchen> Blaze is even worse, it has 'error' in its >>= definition.
21:14:19 <Sgeo> Is there any good reason that Blaze is not a Writer?
21:14:43 <Sgeo> Still get monad syntax, if that's what you really want, AND it would be a real monad
21:18:19 <pqmodn> levi: which text are you discussing, if i may ask?
21:19:07 <enthropy> Sgeo: there's an -XRebindableSyntax if you're wanting to separate the >> and the >>= and return and fail
21:20:25 <levi> coolbeans: This is a classic set of lecture notes on semantics: http://itu.dk/courses/BPRD/E2009/fundamental-1967.pdf
21:20:42 <levi> pqmodn: http://www.cs.utoronto.ca/~hehner/aPToP/
21:21:37 <pqmodn> levi: ah, thanks
21:23:57 <Sgeo> Should I try EclipseFP, even if I'm not fond of Eclipse?
21:27:26 <levi> coolbeans: Leslie Lamport's book 'Specifying Systems' is also a nice introduction to formal specification, although it's not quite as concerned with refinement. I found it easier to deal with than aPToP, anyway.
21:28:27 <levi> Sgeo: It's pretty nice, for an Eclipse-based environment. You can always delete it if you don't end up using it.
21:28:38 <Sgeo> Are there any better IDEs for Haskell?
21:28:43 <jle`> vim :)
21:29:00 <Sgeo> Hoping for a Smalltalk-like experience or better is probably out of the question
21:30:11 <levi> Tools like ghc-mod can give pretty nice integration between editor and language tools, but it takes a bit to set them up.
21:30:40 <DigitalKiwi> http://leksah.org ?
21:31:24 <levi> You're not going to get a Smalltalk/Lisp Machine experience, though. The language and runtime just aren't set up that way.
21:32:08 <Sgeo> Never used a Lisp Machine. Have played with Common Lisp a few times
21:32:25 <quchen> Try FPComplete's IDE?
21:32:38 <Sgeo> It... would feel weird, using a non-local IDE
21:32:51 <Sgeo> And probably wouldn't work if I want to try C binding stuff again
21:33:03 <quchen> *Try* FPComplete's IDE?
21:33:18 <dalaing1> I came in part way through this, so not sure if this is relevant - I liked "Semantics with Applications" as an intro to semantics, found it via http://matt.might.net/articles/books-papers-materials-for-graduate-students/#pl - which has links to the pdf of the previous edition
21:33:43 <quchen> I don't like IDEs in general so I can't recommend one though :-þ
21:35:47 <Sgeo> It's not autorecommending language extensions :(
21:36:04 <Sgeo> At least not for this line anyway:
21:36:04 <Sgeo> data Foo = Bar | Baz | Bat deriving (Read, Show, Typeable, Generic)
21:36:43 <enthropy> ghc isn't perfect at that either
21:37:05 <Sgeo> Oh, it recommends typable when I import Data.Typeable
21:37:18 <Sgeo> Still wish GHC's message for that was clearer
21:37:39 <Sgeo> "You need -XDeriveDataTypeable blah blah blah"
21:37:59 <Sgeo> ...but the IDE lets me click that and it automatically adds the proper LANGUAGE pragma :)
21:38:22 <mgsloan> Yup, and we're planning a bunch more similar conveniences :D
21:38:51 <Sgeo> Can we tell the GHC folks to have GHC recommend the pragma instead of the option?
21:39:23 <enthropy> you can open a bug/feature request
21:39:33 <mgsloan> Yeah, that'd be a good idea
21:39:46 <enthropy> also related is that you need to import GHC.Exts to get Constraint in scope
21:40:13 <coolbeans> levi: cool! i'll give it a whirl
21:40:17 <enthropy> maybe you do need the import, but I guess that one could be suggested somehow?
21:41:00 <Sgeo> Also, is there a more recommended way to import Generics stuff than GHC.Generics? importing GHC.whatever feels awkward somehow
21:45:14 * hackagebot syntactic 1.9 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-1.9 (EmilAxelsson)
21:51:31 <quchen> Sgeo: You are the GHC folks. :-)
21:52:32 <quchen> Feel free to do it the Quchen way though: open a ticket, wait 3 months, get confused and annoyed that nobody implements this cool thing, do it yourself ;-)
21:52:38 <levi> dalaing1: Thanks for the link.
21:54:09 <dalaing1> levi: no worries, Principles of Program Analysis by some of the same authors is also pretty nice
21:54:22 <levi> That pdf has the wonky baseline problem that I used to get out of TeX stuff I printed. I wonder what causes that?
21:55:23 <binroot> what's the best way to compose a list of functions together? I want [f,g,h] to look like (f.g.h)
21:55:31 <dalaing1> I got the more recent dead tree version, so I haven't really looked at the pdf much
21:55:35 <shachaf> :t foldr (.) id
21:55:35 <lambdabot> [b -> b] -> b -> b
21:55:36 <binroot> i'm using foldl (.) [f,g,h]
21:55:44 <arkeet> use foldr
21:55:46 <shachaf> That ssounds like a type error.
21:55:49 <shachaf> Also use foldr.
21:55:56 <arkeet> shachaf: why?
21:55:58 <binroot> i mean, foldr (.) id [f,g,h]
21:56:03 <arkeet> oh that.
21:56:19 <binroot> im using foldr (.) id [f,g,h] but is there a better way?
21:56:27 <arkeet> no
21:56:42 <arkeet> also note: you can only compose functions of type of the form a -> a that way
21:56:52 <binroot> yup
21:57:00 <binroot> thanks
21:57:18 <quchen> Maybe have a look at the Endo monoid while you're at it. (It's not better than the above solution, but good to know about anyway.)
21:57:34 <arkeet> :t appEndo . mconcat . map Endo
21:57:35 <lambdabot> [a -> a] -> a -> a
21:57:40 <arkeet> :t appEndo . fold . fmap Endo
21:57:40 <lambdabot> (Functor t, Foldable t) => t (a -> a) -> a -> a
21:57:44 <arkeet> :t ala Endo foldMap
21:57:45 <lambdabot> Foldable t => t (a -> a) -> a -> a
21:57:58 <arkeet> :t appEndo . foldMap Endo
21:57:59 <binroot> interesting
21:57:59 <lambdabot> Foldable t => t (a -> a) -> a -> a
21:58:01 <arkeet> yeah that one.
21:58:25 <quchen> Ask innocent question, get waterfalls of possible solutions!
21:58:38 <binroot> :)
21:58:58 <oio> what is the pragma of xpackgeimports
21:59:02 <DigitalKiwi> better than some channels
21:59:28 <DigitalKiwi> some channels have this added "none of which are the right answer"
21:59:56 <lightquake> oio: PackageImports is a GHC language extension that lets you import a module from a specific package
22:00:10 <lightquake> why do you ask?
22:01:00 <oio> lightquake: Ambiguous module name `Crypto.Random':       it was found in multiple packages:       crypto-random-0.0.7 crypto-api-0.12.2.2
22:01:11 <quchen> Use -hide-package
22:01:47 <quchen> oio: ^
22:02:26 <oio> quchen: so every time i have to hide the package
22:03:10 <quchen> oio: Using Cabal also solves the issue. But if you're probing around in GHC etc. use -hide-package
22:03:28 <oio> quchen: can't i do this import "crypto-random" Crypto.Random
22:03:33 <quchen> Nope
22:03:51 <lightquake> PackageImports lets you do that, but you probably want to just use cabal
22:04:05 <lightquake> unless this is code you're not going to touch after today
22:04:24 <oio> quchen: - tohugh all -Xblablabl could be into {-# LANXX PackagImports #-}
22:05:23 <quchen> oio: Right, when you're editing source files that works as well.
22:05:58 <quchen> (As opposed to using GHCi, where that would be more verbose than -hide-package)
22:07:13 <oio> quchen: what is thingy of package imports GHCOTIONS LANGUAE ow hat?
22:07:23 <oio> wht?
22:07:27 <quchen> ??
22:09:34 <oio> quchen: Overloadedstrings has lANGUAGE what the one of Packge Imports ghc_options or another?
22:13:22 <jle`> is there any way to have "where" bindings apply to all function-level pattern matches?
22:13:38 <quchen> I don't understand what you're saying, oio
22:13:42 <jle`> or do I have to maybe case within the function
22:13:49 <quchen> jle`: Example?
22:14:25 <oio> quchen: {-# LANGUAGE OverloadedStrings #-} {-# XXXXXXX? PackageImports #-}
22:14:29 <jle`> quchen: foo (Just _) = x; foo Nothing = x+2; where x = 1
22:14:40 <jle`> i'd want the x binding to be usable in both pattern match cases
22:14:52 <quchen> jle`: Hm. I guess you have to use \case for that or something.
22:15:13 <jle`> aw. ok
22:15:23 <quchen> oio: XXX = LANGUAGE as well I think
22:15:47 <shachaf> \case is hardly a solution on its own, and also not the only solution.
22:16:39 <Sibi_> Which is a more recommended read for an intermediate: Typeclassopedia or All about monads ?
22:16:41 <oio> quchen: nope
22:16:46 <binroot> how do I invoke lambdabot here to tell me a pointfree translation?
22:16:53 <arkeet> @pl \f g x -> f (g x)
22:16:53 <lambdabot> (.)
22:16:57 <binroot> thanks
22:17:02 <quchen>  /q lambdabot
22:17:05 <quchen> Then @pl
22:17:10 <shachaf> Probably Typeclassopedia.
22:21:40 <Sibi_> shachaf: Is All about monads more advanced ?
22:21:56 <dalaing1> Sibi_: Introduction to FP using Haskell is awesome if you're willing to buy a dead tree book
22:22:19 <shachaf> I don't know, but I think Typeclassopedia is probably better.
22:23:25 <Sibi_> shachaf: thanks.
22:25:38 <quchen> When I didn't know about monads All About Monads confused me, and when I did know about monads I didn't see the point of it anymore.
22:25:48 <quchen> So go with whatever else you can find.
22:29:27 <johnw> quchen: I found that a lot of the tutorials out there only made sense after they were no longer worthwhile
22:29:30 <Sibi_> @quchen I read some parts of typeclassopedia and I felt that it wasn't comprehensive. Although I understand Monads, I'm still not well versed with all the monads.
22:29:30 <lambdabot> Unknown command, try @list
22:30:16 <Sibi_> quchen: Also some parts of typeclassopedia felt too hard for me to understand.
22:38:46 <yogert> Hey, I have a rather basic question. Is it "inappropriate" to try to make a n-tuple a functor? Am I misunderstanding the underlaying concepts? I ask this because I am having a hard time declaring them as instances.
22:39:07 <shachaf> What is an n-tuple here?
22:39:56 <yogert> A "tuple" of arbitrary length. So for example (1,2,3)
22:40:01 <levi> Heh, there's a commutative diagram in aPToP in the 'Data Transformation' section. I think it's essentially describing a natural transformation, though it doesn't use categorical terminology.
22:40:10 <yogert> Is n-tuple incorrect terminology?
22:40:25 <yogert> I wasnt sure what else to call the
22:40:26 <yogert> m
22:40:30 <shachaf> yogert: OK, so you mean the (,,,,,) types in Haskell.
22:40:36 <yogert> yeah
22:40:42 <shachaf> Note that each one of them is a distinct type and would get its own Functor instance.
22:41:01 <shachaf> Anyway, the type (Int,Char,Bool) is really the type (,,) Int Char Bool
22:41:14 <yogert> Yeah, sure. In my case I was looking to define one for a triple
22:41:15 <shachaf> And so a Functor instance would be for "(,,) Int Char"
22:41:27 <shachaf> So it would only map over the last element of the tuple.
22:41:33 <yogert> Ah, maybe I was just getting the syntax wrong
22:41:54 <shachaf> That depends. What was your goal?
22:41:58 <shachaf> (Give an example with fmap, or something.)
22:42:18 <yogert> fmap (+1) (1,2,3)
22:42:22 <shachaf> Should be?
22:42:30 <yogert> (2,3,4) : )
22:42:32 <yogert> No?
22:42:35 <shachaf> Impossible.
22:42:37 <shachaf> See above.
22:42:44 <yogert> Yeah thats what I was thinking
22:43:02 <shachaf> > fmap (+1) (1,2,3) -- this is possible, though
22:43:03 <lambdabot>  No instance for (GHC.Show.Show t1)
22:43:03 <lambdabot>    arising from a use of `M907420186854493574219480.show_M9074201868544935742...
22:43:03 <lambdabot>  The type variable `t1' is ambiguous
22:43:03 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
22:43:03 <lambdabot>  Note: there are several potential instances:
22:43:12 <shachaf> > fmap (+1) (1,2,3) :: (Int,Int,Int) -- this is possible, though
22:43:14 <lambdabot>  No instance for (GHC.Base.Functor
22:43:14 <lambdabot>                     ((,,) GHC.Types.Int GHC.Types.Int))
22:43:14 <lambdabot>    arising from a use of `GHC.Base.fmap'
22:43:14 <lambdabot>  Possible fix:
22:43:14 <lambdabot>    add an instance declaration for
22:43:18 <shachaf> Hmph.
22:43:22 <yogert> hmmm, so how should I capture that behavior? Is there another standard class that acts this way?
22:43:30 <shachaf> > fmap (+1) (1,2)
22:43:31 <lambdabot>  (1,3)
22:43:34 <shachaf> I guess there's no instance for 3-tuples.
22:43:48 <shachaf> That behavior might not be the right one to want.
22:43:57 <yogert> Huh?
22:44:05 <yogert> As a functor you mean?
22:44:15 <shachaf> Well, maybe you want to define data Triple a = Triple a a a
22:44:21 <shachaf> Then Triple is a Functor where fmap does what you want.
22:44:45 <shachaf> But the elements of a tuple are in general entirely independent, so something like (a -> b) -> (a,a,a) -> (b,b,b) suggests that maybe you don't want a tuple.
22:45:57 <yogert> Yeah, thats what I ended up doing, but the fact that I couldn't do it as a 3-tuple irked me a bit. I've been running into situations where I wan't behavior like fmap, but not fmap itself. I want the type (a -> a) -> f a -> f a instead of  (a -> b) -> f a -> f b
22:46:23 <yogert> And it feels strange to redefine something almost exactly like fmap, but not fmap
22:46:36 <shachaf> That sounds like almost certainly not a type you want.
22:46:43 <shachaf> After all, b can always be a.
22:47:04 <yogert> Well for example
22:47:13 <yogert> my problem the other day was something like this
22:48:14 <yogert> data Foo c a = Foo (c a) a
22:48:56 <yogert> and I wanted a way to easily to lift the "container" out of Foo, "modify" it, and put it back in place
22:49:21 <yogert> but since the other field has the type 'a' as well, it wouldn't work with fmap
22:49:39 <shachaf> It's always possible that what you want is lens, which would let you do all of these things and more.
22:49:46 <shachaf> > over each (+1) (1,2,3)
22:49:48 <lambdabot>  (2,3,4)
22:49:59 <rose__> I have src/Main.hs define the Main module and tests/Tests.hs import the Main module. Why does cabal build tell me module `Main' (tests/Tests.hs) imports itself?
22:50:15 <oio> so i want to put a byte string to a chat what i can i transform it to? so it can travel through a chat (ex facebook) them made again into a bytestring
22:50:16 <shachaf> You can define a lens for just the "c a" bit and then over (thatLens . mapped) f to do what you asked.
22:50:37 <yogert> Yeah I considered using Lens, but for such a simple behavior I figured I might be missing something
22:50:48 <quchen> oio: Base64-encode it
22:51:20 <oio> quchen:
22:51:36 <binroot> @pl flip elem " \t"
22:51:36 <lambdabot> flip elem " \t"
22:51:47 <yogert> Would it be bad form then to make a function like "foomap" which has the type (c a -> c a) -> Foo c a -> Foo ca?
22:52:04 <yogert> it feels wrong to me heh
22:52:07 <binroot> @pl \x -> elem x " \t"
22:52:07 <lambdabot> flip elem " \t"
22:52:17 <shachaf> That's what a lens lens does.
22:52:23 <shachaf> If it's what you want then it's OK.
22:52:46 <shachaf> (`elem` " \t")
22:53:01 <oio> quchen: this http://hackage.haskell.org/package/binary-0.7.1.0/docs/Data-Binary-Get.html ? will it wrok
22:55:00 <quchen> oio: Data.Binary encodes Haskell data structures in ByteString format. It's not related to text-representable formats.
22:55:53 <oio> quchen: runGet getWord64le ?
22:55:59 <oio> > :t runGet getWord64le
22:56:00 <lambdabot>  <hint>:1:1: parse error on input `:'
22:56:11 <oio> :runGet getWord64le
22:57:51 <Hexagenic> :t runGet getWord64le
22:57:52 <lambdabot> Not in scope: `runGet'
22:57:52 <lambdabot> Not in scope: `getWord64le'
22:57:57 <Sgeo> :t execState.state
22:57:58 <lambdabot> (s -> (a, s)) -> s -> s
22:58:28 <yogert> Also, would it be possible to overload the Num methods such that (Vector 1 2 3) + 1 == (Vector 1 2 3) + (Vector 1 1 1)? Or is that impossible / ill advised?
22:58:32 <oio> @t runGet getWord64le
22:58:33 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
22:59:04 <rose__> I have src/Main.hs define the Main module and tests/Tests.hs import the Main module. Why does cabal build tell me module `Main' (tests/Tests.hs) imports itself?
22:59:11 <Sgeo> Can mapM_ and forM_ be defined for Applicatives?
22:59:24 <quchen> Sgeo: Yes, that's what Data.Traversable does
22:59:54 <Sgeo> I have an intuition on the distinction between Applicative and Monad, but not for where Arrows fit into that
23:00:05 <piezo> yogert: define fromInteger a = let a' = fromInteger a in Vector a' a' a'
23:00:07 <quchen> yogert: You can't implement some Num functions (e.g. fromInteger) for tuple types
23:00:21 <quchen> Well, you can implement them, but they'll be awkward.
23:01:12 <yogert> piezo: ah, good point
23:01:26 <yogert> quchen: So not a good idea you think?
23:01:57 <quchen> I think you should define your own "+" operation here and decorate the operator with something small.
23:02:05 <quchen> Some people here like ^+^
23:02:09 <quchen> I often use +.
23:02:43 <yogert> yeah. I suppose the alternative would get confusing
23:05:43 <Digit> trying to work out...  how to represent in the shortest way, how to find out how long it would take for everyone to have a "replicator", if it takes 1 person 1 day to make one, and everyone makes one and gives it to another, not counting other complicating factors like geography, population spreads etc.  1 man makes 1, so day two, two men, then 4 on day 3, and so on.  how long until, say, 8 billion, how many days.   and how to punch
23:05:43 <Digit> that in, neatly, to ghci or some piece of haskell code...   i'm gonna have to sleep on it.  thought i might as well ask.
23:06:13 <simpson> Digit: There's a very convenient formula for it, actually.
23:07:46 <shachaf> ~Half the world's population is not men, so maybe try ~4 billion or more gender-neutral language. :-)
23:08:55 <Digit> i was using it in the old all-inclusive sense where it's like "mankind"... not in the way that offends feminists.
23:09:07 <quchen> Ethymologically, "man" comes from "human".
23:09:21 <dreixel> Sgeo: import Generics.Deriving (from generic-deriving)
23:09:51 <Digit> also, i did say "everyone"... that it started from a man in my example shouldnt matter.  anyways, rather getting off topic
23:12:36 <Digit> simpson: i'm sure there is.  my knowledge and skills dont reach it so easily though.  care to share before i go to bed?
23:13:13 <simpson> Digit: Powers of two.
23:14:27 <simpson> On the first day, you have 2**1-1 machines. On the second day, 2**2-1.
23:15:22 <quchen> Calculate the first couple of days manually. Recognize the pattern. Formulate a formula. Reason about the formula to test whether it's correct. Science!
23:15:55 <Digit> i think its syntax more than anything that's hindering me
23:16:20 <Digit> and sleepyness.  definately sleepyness
23:20:21 * hackagebot yesod-routes 1.2.0.4 - Efficient routing for Yesod.  http://hackage.haskell.org/package/yesod-routes-1.2.0.4 (MichaelSnoyman)
23:48:04 <fishythefish> QUIT
23:48:54 <noprompt> i'm trying to filter a list of files by some predicate after using getDirectoryContents, but i'm having a hard time understanding how to go from IO [FilePath] to simply [FilePath]
23:49:09 <noprompt> would anyone mind helping me understand this?
23:49:27 <dwcook> noprompt, well the first thing to understand is that there's no function IO [FilePath] -> [FilePath].
23:49:43 <noprompt> i don't think i'm fully groking I/O in haskell :(
23:49:55 <dwcook> However, you can use (>>=) (also used implicitly by do blocks) to give the next action access to the [FilePath] you get.
23:50:05 <noprompt> dwcook: thanks. hoogle has verified this aswell. :)
23:50:20 <Sgeo> I think of it a bit like layers: You have an IO layer on the outside, which uses functions that might not use IO
23:50:22 <dwcook> do { myFilePaths <- getDirectoryContents; doSomethingWith myFilePaths }
23:50:55 <dwcook> Or, I guess getDirectoryContents is a function.
23:51:01 <Sgeo> You can't have an IO | non-IO | IO sandwich
23:51:53 <dwcook> noprompt, do you understand my example?
23:51:56 <noprompt> dwcook: are the brackets required?
23:52:02 <epta> noprompt: btw, take a look at System.FilePath.Find from filemanip, there are some nice methods for finding and filtering files
23:52:04 <dwcook> noprompt, no, you can use layout instead.
23:52:08 <epta> @hackage filemanip
23:52:08 <lambdabot> http://hackage.haskell.org/package/filemanip
23:52:45 <noprompt> epta: thanks epta, but i'm trying to handroll this myself atm so i can learn.
23:53:27 <mm_freak> :t filterM
23:53:29 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
23:53:38 <Sgeo> :t const () :: IO () -> () -- ignore this if you're learning, I'm just messing around
23:53:39 <lambdabot> IO () -> ()
23:54:12 <noprompt> mm_freak: where does filterM live?
23:54:13 <Sgeo> :t const const
23:54:14 <lambdabot> b -> a -> b1 -> a
23:54:19 <mm_freak> noprompt: Control.Monad
23:54:52 <noprompt> mm_freak: ah ok, i haven't completely wrapped my head around Monads yet either. :S
23:55:05 <mm_freak> :t const 0 :: (Num a) => IO a -> a
23:55:06 <lambdabot> Num a => IO a -> a
23:55:23 <noprompt> dwcook: i partly understand the example but i keep getting the same type error.
23:55:30 <mm_freak> noprompt: filterM :: (a -> IO Bool) -> [a] -> IO [a]
23:55:37 <mm_freak> noprompt: compare to 'filter'
23:55:47 <mm_freak> filter :: (a -> Bool) -> [a] -> [a]
23:56:22 <Sgeo> An IO a is an action that, when executed, gives you a. (a >>= b) is an action that (when executed) will execute a, feed the result into the function b, and execute that result
23:56:32 <dwcook> noprompt, what error would that be?
23:57:00 <noprompt>     Expected type: [FilePath] -> IO FilePath
23:57:01 <noprompt>       Actual type: [FilePath] -> [FilePath]
23:57:15 <mm_freak> noprompt: is your predicate pure?
23:57:21 <dwcook> noprompt, it might help to show code.
23:57:37 <Sgeo> do { aResult <- a; b aResult} is the same thing, with do notation. Note that, if a is, for example, an IO Int, then aResult, for the diuration, is Int
23:57:44 <Sgeo> But the entire do is going to be IO something
23:58:24 <noprompt> mm_freak: you mean for filter? yes
23:58:32 <noprompt> isPrefixOf is pure
23:58:51 <mm_freak> noprompt: if the predicate is pure and based on file names only, then you can simply do this:  fmap (filter p) getDirectoryContents
23:59:38 <noprompt> mm_freak: ah ok. fmap. the functor bit.
