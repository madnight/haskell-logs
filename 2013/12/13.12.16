00:03:34 <codygman> Two things: 1. Is my translation from the verbose method to the shorter one correct? 2. Is this how you would get the number of words from a webpage? Code: http://lpaste.net/97051
00:05:29 <codygman> Bonus: Is there some pre-existing abstraction I'm overlooking that fits my code (it seems pretty short and to the point to me, but I'm new).
00:05:37 * hackagebot async 2.0.1.5 - Run IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/async-2.0.1.5 (SimonMarlow)
00:11:27 <Cale> codygman: If the thing on the right hand side of a >>= is a composition, you might consider flipping it over and using =<< instead
00:12:33 <Cale> (might be easier to read)
00:17:06 <jle`> i myself would have probably done print $ length . words <$> (your request), to sort of mentally separate the printing from the counting
00:17:28 <jle`> acuallyif your function is pageCount
00:17:34 <jle`> you should really only be returning the IO Int
00:17:43 <jle`> so length . words <$> (stuff) would suffice
00:19:07 <Cale> ?
00:19:14 <Cale> Why not print . length . words?
00:19:20 <jle`> and then on main, do print pageCount
00:19:33 <jle`> if your function is pageCount shouldn't you want the IO Int ?
00:19:43 <jle`> it's a case of knowing when to separate logic from IO, right?
00:20:15 <jle`> a structure/style-wise choice
00:20:18 <Cale> Well, yes, that's a good point, in a more realistic example, you might want to factor this program better
00:21:01 <Cale> length . words is short enough that if you don't want to define it as its own thing, I think that's okay too though.
00:21:18 <Cale> My point was just that you can flip this over
00:21:24 <Cale> print . length . words =<< getResponseBody =<< simpleHTTP . getRequest =<< getLine
00:21:36 <Cale> reads a good bit more straightforwardly than the other direction
00:22:01 <jle`> yes definitely, my comment was made to be taken in parallel with yours
00:22:26 <jle`> print . length . words just feels kind of an odd mixing of IO and pure logic
00:22:38 <Cale> I do things like that all the time myself :)
00:22:47 <jle`> ah, then i must concede :)
00:23:12 <Cale> I suppose it's more natural if you've been forcing yourself to use composition in place of application a lot
00:23:16 <jle`> print $ length . words <$> getResponseBody =<< simpleHTTP . getRequest =<< getLine
00:23:32 <Cale> If whenever you see f $ g $ x or the like, you replace it with f . g $ x
00:23:46 <Cale> then you'll gradually find things like that more natural to write
00:24:34 <jle`> yeah, i know what you mean between f $ g $ x and f . g $ x, this is more of a case of separating io 'logic' from pure logic
00:24:38 <Cale> If I can get away with using composition, I always do it, because it's much nicer working with associative operators
00:25:06 <Cale> I can see how you might want to emphasise (length . words) over (print . length) though
00:27:47 <nisstyre> @src (//)
00:27:47 <lambdabot> arr@(Array l u _) // ies = unsafeReplace arr [(index (l,u) i, e) | (i, e) <- ies]
00:34:42 <robert_> this is weird; I'm trying to compile darcs, but it says that I'm missing hashed-storage >=0.5.6 && <0.6, however it's there and I can see it. what gives?
00:35:10 <startling> robert_, paste the whole error message to http://lpaste.net/ , please
00:35:23 <robert_> okay.
00:35:40 <robert_> and even weirder, I can' tfind hashed-storage in 'ghc-pkg list'
00:36:42 <robert_> startling: it's going to have build system "stuff" around it, just so you know.
00:37:37 <robert_> http://lpaste.net/97052
00:38:02 <robert_> (startling)
00:38:43 <startling> should you be using makepkg?
00:39:36 <robert_> it's the way archlinux builds things.
00:40:03 <robert_> I can't find darcs in the community or core repositories.
00:40:29 <startling> oh, I see.
00:40:43 <startling> robert_, ime, installing haskell things on arch is easier with cabal
00:41:00 <scott_> I agree with startling
00:41:04 <startling> it has some downsides (no uninstallation) but it seems to be less weird.
00:41:16 <startling> well, no /clean/ uninstallation.
00:41:36 <robert_> hm
00:44:49 <robert_> oh, snap. so darcs is written in haskell or something?
00:44:55 <robert_> I could just install it through this.
00:44:55 <startling> yeah.
00:45:14 <startling> cabal install darcs # done
00:45:23 <robert_> now if only ocamel were this easy.
00:45:25 <robert_> :p
00:45:29 <robert_> .. ocaml*
00:45:30 <robert_> wow
00:45:32 <robert_> brain fail.
00:45:40 <startling> haha
00:46:11 <robert_> :D
00:46:12 <robert_> woot
00:46:52 <robert_> oh.. no.
00:47:00 <robert_> it's installing for root.
00:47:00 <Maxdamantus> How easy is it for ocaml to pass through the eye of a needle?
00:47:14 <robert_> Maxdamantus: haha.
00:47:23 <startling> robert_, eh?
00:47:34 <startling> robert_, did you "sudo cabal install darcs"
00:48:11 <robert_> Installing library in /root/.cabal/lib/network-2.4.2.1/ghc-7.6.3
00:48:24 <startling> < startling> robert_, did you "sudo cabal install darcs"
00:48:32 <robert_> I'm root.
00:48:36 <robert_> duh.
00:48:41 <startling> uh, why?
00:48:53 <robert_> because I'm trying to install it as a system package?
00:49:32 <scott_> --global
00:49:36 <startling> robert_, cabal works more nicely if you do everything per-user
00:49:53 <startling> I guess you can --global, though
00:50:58 <robert_> agreed, but I have a build user and it won't pick up all of the runtime dependencies if I install it per-user.
00:51:51 <nisstyre> startling: apparently cabal also works more nicely if it doesn't have quadratic algorithms lurking in it
00:52:10 <startling> nisstyre, isn't that darcs
00:52:26 <nisstyre> startling: https://github.com/nominolo/HTTP/commit/b9bd0a08fa09c6403f91422e3b23f08d339612eb
00:52:29 <startling> robert_, ok. so switch to your build user and cabal install --global darcs
00:54:07 <startling> nisstyre: ok
00:54:40 <nisstyre> startling: it always annoys me that cabal update takes a long time, and I wondered why it was doing that even on insanely fast internet connections
00:54:43 <nisstyre> now I have an idea of why
00:55:16 <startling> nisstyre, ok
01:28:53 <piezoid> hi
01:29:16 <jle`> hi piezoid
01:29:26 <piezoid> it's seems like i've to do a typechecker for the language i'm compiling
01:30:11 <piezoid> i've never done that before, do you have poiters to ressource about typechecking in haskell ?
01:30:29 <m3ga> is there some documentation on how to use Criterion somewhere?
01:30:58 <m3ga> piezoid: there paper called something like "typechecking haskell in haskell"
01:31:04 <m3ga> @google "typechecking haskell in haskell"
01:31:05 <lambdabot> No Result Found.
01:31:22 <piezoid> i got vague notions about HM inference, but I need some kind of dependent types
01:32:02 <piezoid> m3ga: thanks, i think i've seen it, a while ago
01:32:10 <mm_freak> m3ga: import Criterion.Main, use defaultMain with bgroup/bench and nf/nfIO/whnf/whnfIO
01:32:17 <m3ga> piezoid: http://web.cecs.pdx.edu/~mpj/thih/TypingHaskellInHaskell.html
01:32:32 <mm_freak> m3ga: the types fit only one way
01:32:39 <m3ga> mm_freak: how do i get the graphs though?
01:32:51 <mm_freak> good question, i've never generated them
01:33:07 <piezoid> it's for Faust, a language with no let binding or abstraction (just a untyped macro system)
01:33:08 <m3ga> i already have the text output. i want graphs!!! :-)
01:33:34 <m3ga> oh, Faust is cool (even if it does compile to c++) :-)
01:33:39 <mm_freak> m3ga: then that's not a criterion question =)
01:34:43 <piezoid> it's based on combinator of dataflow block (arrow from signal tuple to signal tuple) and I need to infere properties about signals (rate, execution time, etc)
01:35:31 <mm_freak> sounds like something i'd do in haskell
01:36:42 <piezoid> surprisingly the paper about its type system doesn't say anything about unification (http://faust.grame.fr/images/faust-doc/papers/faust-elsevier2011.pdf)
01:37:01 <piezoid> so maybe there is cases where it's not needed ?
01:38:02 <mm_freak> faust looks like a native netwireâ€¦  perhaps i should write a netwire-based DSP library
01:38:15 <QF-MichaelK> I really like this set comprehension to haskell list comprehension: http://learnyouahaskell.com/starting-out#im-a-list-comprehension  Is there some sort of dictionary of Math speak with haskell equivalents somewhere?
01:39:11 <mm_freak> QF-MichaelK: usually the same terminology is used in both
01:39:20 <piezoid> mm_freak: that's the point, ii think it's a good project to learn llvm bindings :)
01:39:46 <mm_freak> piezoid: my point was that i wouldn't use faust =P
01:40:22 <mm_freak> because it looks like something you could do in haskell much more easily and with a readily available powerful type system =)
01:41:05 <nisstyre> piezoid: http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/BasicTypechecking.pdf
01:41:05 <piezoid> mm_freak: the good part of faust is the library of signal processors, and a native compiler
01:41:37 <nisstyre> piezoid: if you have no let then it becomes a lot easier than that though
01:42:04 <piezoid> nisstyre: oh, thanks
01:42:16 <mm_freak> type-checking is usually a simple recursive algorithm
01:42:40 <piezoid> nisstyre: yes, i think so. The hary part would be the dependant types...
01:42:44 <mm_freak> you traverse the AST and check that things make sense
01:43:02 <mm_freak> dependent types are actually really easy from a type-checking standpoint
01:43:03 <nisstyre> piezoid: there are other papers by Cardelli on that
01:43:20 <piezoid> mm_freak: you mean, traversing the AST with a writerT Env ?
01:44:10 <mm_freak> piezoid: perhaps a writer for error messagesâ€¦  i'd use a locally nameless AST
01:44:46 <piezoid> i was realy scared with the general approach (let-rec abstractions), etc...
01:47:14 <helmut> is there a separate channel for discussion of shake (build system)? I would like to teach it to only compile a source, if non-comments of the input change.
01:47:56 <frerich> helmut: Interesting idea :)
01:48:12 <piezoid> nisstyre: nice paper, the notions of inference rules/system are explaned from scratch, just what i need :)
01:48:29 <helmut> frerich: when using literate programming, at some point that becomes important, cause recompiling all the stuff takes ages when you just change the explanation
01:49:02 <helmut> frerich: specifically extracting non-comments (by virtue of markers \begin{code}) are trivial to find
01:50:22 <helmut> and shake's support for finding fixed points (stackoverflow.com/questions/14622169) seems like a gross hack at best
01:52:07 <nisstyre> piezoid: written by one of the people who helped invent the concepts no less
01:52:19 <nisstyre> (Luca Cardelli wrote the first ML compiler)
01:52:38 <QF-MichaelK> mm_freak: Ah, yeah, but it'd be nice to see a comprehensive arrangement of math structures and the Haskell analog.  Have you seen anything like that?  I did see someone charts of math here showing how different fields of math were related to each other.  I'd like to see more in that direction too.  Any suggestions/
01:54:27 <mm_freak> QF-MichaelK: well, there is the typeclassopedia, which comes as close as you can sensibly get
01:54:57 <Cale> QF-MichaelK: For the most part, people try to use the same terminology when it's relevant.
01:55:02 <mm_freak> QF-MichaelK: you will find that we like to call monoids monoids, monads monads, categories categories, affine spaces affine spaces, â€¦
01:55:54 <mm_freak> we're not bound by marketing/business idealsâ€¦  that's why instead of "dependency injection" we simply say "function" =)
01:56:22 <Cale> One little difference is that the Haskell Functor class really means "Endofunctor on the category of Haskell types and functions"
01:56:32 <quchen> mm_freak: Functions are called dependency injections somewhere?
01:56:34 <Cale> But at least it's *some* kind of functor :)
01:56:36 <QF-MichaelK> Hm, I mean: it'd be nice to see the math definition for affine space next to haskell's declaration.
01:56:38 <Cale> quchen: yes
01:56:45 <mm_freak> quchen: more precisely reader monads
01:57:09 <quchen> Oh, like having an implicit argument everywhere
01:57:16 <mm_freak> quchen: pretty much
01:57:35 <quchen> Well then functions aren't called functions in Haskell as well
01:57:46 <mm_freak> ?
01:57:59 <quchen> Reader is some form of function with some convention on how and when to use it, that's why it has a separate name.
01:58:25 <quchen> I thought when you mentioned "dependency injection" you were ridiculing some language for not calling its functions functions.
01:58:37 <mm_freak> the point of DI is automatic propagation, which is precisely what readers do in haskell
02:00:23 <Cale> "Delegate" is probably closer
02:00:59 <Cale> as a kind of awkward attempt at functions
02:01:33 <mm_freak> type Delegate a b = [a -> b]
02:01:46 <mm_freak> if you mean .NET delegates
02:03:10 <Cale> Why a list?
02:03:37 <mm_freak> Cale: because you can add more functionsâ€¦  their original purpose was event handling
02:03:38 <Cale> (also, I guess, because of impurity, we should say "procedure" rather than "function")
02:04:00 <frerich> mm_freak: I thought DI was a design decision to reduce coupling between some parts of your program caused by hardcoding types. And you *implement* DI using functions which produce values of some more abstract type. What does 'automatic propagation' mean then?
02:05:16 <mm_freak> frerich: a process that takes a while and produces progress log output
02:05:23 <mm_freak> without DI:  process :: IO ()
02:05:31 <mm_freak> with DI:  process :: (String -> IO ()) -> IO ()
02:05:48 <mm_freak> hardcoded logger vs. abstracted logger
02:06:09 <Cale> Yeah, I've always thought of DI as just another name for "additional function parameters"
02:06:19 <dmj`> dumb question, is there a typeclass or function that is like Show, a -> String, but ShowBS a -> ByteString
02:06:19 <Cale> With an unfortunately awkward implementation
02:06:20 <mm_freak> the fact that you use an /abstract class/ has nothing to do with DI itself
02:06:41 <frerich> mm_freak: That's quite close to what I said, no? Except that in your case you "inject" a value  whereas my understanding is that DI is used to inject a type.
02:06:50 <Cale> dmj`: Well, there's stuff like cereal/binary
02:07:05 <tovarish> a type and a value are the same thing
02:07:07 <Cale> dmj`: But not *quite* like Show
02:07:10 <tovarish> you inject a value of the given type
02:07:11 <mm_freak> frerich: the type injection comes from OO itself, not from DI
02:07:32 <brtaylor92_> is it normal to see lots of warnings when updating cabal?
02:07:46 <mm_freak> frerich: process :: (forall a. (LogLine a) => a -> IO ()) -> IO ()
02:07:47 <Cale> frerich: Injecting a *type* sounds way too fancy for any of the languages in which DI is discussed.
02:07:56 <piezoid> C++11 closures can capture variables, but maybe it's not as implicit
02:08:05 <Cale> (Type level lambda?)
02:08:17 <frerich> mm_freak: Ah, I thought it's a type per definition. If it can be anything else, then I would agree that the term "dependency injection" doesn't pull its own weight. :-}
02:08:35 <mm_freak> frerich: you still inject values
02:08:53 <mm_freak> objects usuallyâ€¦  of class AbstractLogger or whatever OO people would call it
02:09:03 <frerich> Cale: In the languages whree I saw people talk about "DI", it's usually the "injection" of a dependency on a type (not a type itself) as opposed to hardcoding the dependency by using the type directly.
02:09:24 <frerich> ...but I guess it all just boils down to "Don't hard code stuff, pass an argument".
02:09:24 <tovarish> another name for a container providing services to children
02:09:28 <Cale> It might be confusing because the way that you construct genuinely new values of a class is often by defining new subclasses, which have their own types as well as having new implementations of the methods.
02:09:31 <tovarish> the OO world is silly
02:09:41 <mm_freak> frerich: you don't really inject a typeâ€¦  it just comes naturally that you can always use a subclass of the expected class
02:10:03 <mm_freak> frerich: this is implicit in the haskell version
02:10:12 <mm_freak> process :: (String -> IO ()) -> IO ()
02:10:13 <Cale> But really you're constrained to using those subclass objects at their parent class type
02:10:38 <mm_freak> in the OO world people would probably make a subclass StderrLogger, SyslogLogger, RemoteLogger, â€¦
02:10:47 <mm_freak> in haskell that's all String -> IO ()
02:10:57 <tovarish> not necessarily
02:11:04 <tovarish> you have many logging types
02:11:22 <frerich> Cale: True, but in the same way mm_freak's 'process' function would be "constrained" to 'String -> IO ()', i.e. it's the interface visible to the implementation.
02:11:31 <quicksilver> Cale: yes, a subclass is often used when it would be more natural just to have a single fresh value
02:11:34 <Cale> It's really really unfortunate that pretty much all typed OO languages make this compromise of tying method implementations to the types of the objects.
02:11:54 <quicksilver> Cale: because it's not really idiomatic to have 'function variables'
02:11:58 <quicksilver> it's possible, of course
02:12:05 <quicksilver> just not idiomatic and peopple seldom do it
02:12:24 <Cale> (because in the old days, this was a reasonable way to get better performance)
02:13:22 <mm_freak> (in other words:  OO is a giant pile of nostalgia)
02:14:40 <dmj`> Cale: ok good to know, might try a ShowBS class
02:15:04 <Cale> If I were to design an OO language, I would make the object types just specify which methods the objects of that type have and what their types are, and provide a mechanism for introducing new objects of any type by providing implementations of those methods in-place (which could be hidden by a module boundary if desired for the sake of further abstraction)
02:15:39 <piezoid> Cale: i think Go does this
02:15:45 <Cale> Of course, that ends up looking suspiciously like what we already can do reasonably straightforwardly in Haskell.
02:15:58 <lightquake> @pl \x -> f x >> g x
02:15:58 <lambdabot> liftM2 (>>) f g
02:16:32 <arkeet> lightquake: also consider using ReaderT
02:16:59 * frerich learns that '„Inversion of Control is too generic a term, and thus people find it confusing. As a result with a lot of discussion with various [Inversion of Control] advocates we settled on the name Dependency Injection.'
02:17:00 <lightquake> meh, not worth it in this case, it's just three lines of code
02:17:11 <arkeet> ok, at least you considered it. :p
02:17:19 <mm_freak> if i were to design an OO language, i'd write:  "See Haskell's Control.Concurrent."
02:17:33 <lightquake> let r = f x; g r; h r
02:17:44 <lightquake> except with real names, of course
02:18:45 <mm_freak> like sin, sqrt or (<*>)
02:18:53 <quicksilver> the wikipedia page and corresponding talk page on Dependency Injection are good for a laugh. Or an exercise in frustration, depending what mood you're in. Certainly seems to be a subject at which wikipedia fails on consensus of what the term actually means.
02:19:30 <quchen> Every talks page on Wikipedia is an edit war.
02:19:37 <quicksilver> no they aren't.
02:19:51 <quicksilver> there are some perfectly stable and sensible WP pages with clear talk pages.
02:19:59 <quicksilver> but this definitely isn't one such.
02:20:42 <mm_freak> i don't think that DI has ever had a formal definition
02:21:06 <mm_freak> having one could be an epiphany for some people
02:21:36 <Cale> quicksilver: The old page for "Eckmann-Hilton argument" http://en.wikipedia.org/w/index.php?title=Eckmann%E2%80%93Hilton_argument&oldid=107428483
02:22:07 <Cale> I have no idea what's going on there, but it's not the Eckmann-Hilton argument
02:22:25 <quicksilver> something I perceive as annoying in the field of software engineering / programming languages is the inability to distinguish between a technique which is really very specific to a particular language and the tradeoffs of that language; vs a technique which applies more generally
02:23:09 <mm_freak> quicksilver: what would be an example of the former?  type classes?
02:23:32 <Cale> Design patterns are hints at what the weaknesses of a language are
02:24:07 <frerich> Please, I barely grasped what 'Dependency Injection' means exactly, and now you bring up 'Design Pattern'
02:24:13 <mm_freak> Cale: depends on your definition of "design pattern"
02:24:14 <quicksilver> Cale: sometimes they are. I think that argument has been overstressed.
02:24:51 <mm_freak> Cale: mine is "set of laws", so we use design patterns in haskell, and haskell supports them very well
02:24:54 <mm_freak> like Monoid
02:24:58 <Cale> Well, they're patterns in your code which you apparently can't abstract over in your language.
02:25:11 <Cale> Otherwise, they wouldn't be called design patterns, they'd just be definitions.
02:25:35 <quicksilver> mm_freak: a haskell example? A simple kind of haskell example would be "always use newtypes for Binary instances so you don't inadvertently trample on someone else's instance". That is a very specific technique arising from some specific features of haskell.
02:26:38 <mm_freak> Cale: i don't think there is much of a difference between definitions and design patterns, except that we use design patterns for software design
02:27:04 <mm_freak> to me Monoid is both a defined algebraic structure and a software design pattern
02:27:32 <Cale> Okay, well, I suppose you're free to call it that, but I wouldn't ;)
02:28:05 <quchen> Let's see what the Wikipedia page on deisgn pattern says.
02:28:10 <Cale> Well, actually, there is an aspect about calling it one which is tempting, because instances of Monoid aren't *actually* required to be monoids in Haskell.
02:28:41 <mm_freak> Cale: in my view the laws are an important part of the structure/pattern
02:28:45 <Cale> But if we could enforce the laws, I think calling it a "design pattern" would be a weird thing to do.
02:29:15 <frerich> So the only thing everybody more or less agrees on is what a 'function' is (even even then you still have disputes depending on how broad a range of languages you include) and from there is just goes downhill? Pretty amazing how far the state of software development has come with such communication imperfections. :-}
02:29:18 <startling> laws are a pattern, yeah.
02:29:20 <Cale> There is a limitation of Haskell here
02:29:52 <Cale> frerich: Unfortunately, not even function is an agreed upon notion.
02:31:22 <Cale> I see this kind of ambiguity about language as being somewhat okay, so long as we're clear about which sense we mean in context.
02:31:47 <mm_freak> according to the wikipedia page <http://en.wikipedia.org/wiki/Software_design_pattern> overcoming language limitations is not an inherent part of design patterns
02:32:03 <mm_freak> and Monoid is a perfectly fine example for a design pattern
02:32:23 <quicksilver> mm_freak: I think it's pretty clear that the *proponents* of design patterns do not view them as being about language weaknesses.
02:32:25 <mm_freak> OO people would probably call it "Combination pattern" or "ICombinable" or something like that
02:32:39 <quicksilver> so you wouldn't expect that in the wiki page
02:32:51 <quchen> I would call "recognizing monoids" a design pattern, but not monoids themselves.
02:33:04 <quicksilver> what Cale was saying was - not an original argument - that design patterns can in fact be seen that way
02:33:19 <piezoid> mm_freak: that's my problem with Scala, all the fancy names...
02:33:21 <Cale> The first two sentences of that page imply that it is about language weakness.
02:33:27 <quicksilver> many of the gang of four book patterns do in fact highlight abstraction problems in C++/smalltalk family languages
02:33:32 <Cale> "A design pattern is not a finished design that can be transformed directly into source or machine code."
02:33:51 <Cale> In Haskell, we (almost) have Monoid transformed directly into source code.
02:33:55 <Cale> In the form of a type class.
02:34:05 <quicksilver> I mostly agree with Cale but I think it's going a bit far to say they always are
02:34:18 <startling> I think "using Monoid" might be a design pattern.
02:34:33 <quicksilver> startling: I think a design pattern has to identify a class of problems first
02:34:51 <mm_freak> startling: i guess that's right
02:35:02 <quicksilver> "When you're doing X like this, then a good abstraction is to make it polymorphic over all Monoids by doing this..."
02:35:11 <startling> quicksilver, "a lot of things have a binary function and a unit with respect to it"
02:35:22 <quicksilver> that's not a problem.
02:35:27 <quicksilver> that's an observation
02:35:29 <mm_freak> â€¦ associativeâ€¦
02:35:30 <Itkovian> startling I do not agree, being a monoid is a characteristic  of your data type, so it is independent of you using it as such
02:35:32 <nexx> "Design patterns are bug reports against your programming language"
02:35:35 <quchen> Calling design patterns weaknesses is fine as long as you keep in mind that weaknesses are often not bad to have. If it was possible to overcome Haskell's weakness of having to informally add laws to classes via an "Associativity constraint" it sure wouldn't be pretty or practical.
02:35:56 <Cale> quchen: What? :)
02:35:59 <arkeet> what?
02:36:06 <mm_freak> associativity is the defining feature of monoidsâ€¦  it's also their killer feature, so please never forget to mention it ;)
02:36:10 <Cale> quchen: Who says it wouldn't be practical!
02:36:20 <mm_freak> s/the/a/
02:36:33 <Itkovian> hmm, somebody is getting notified a lot, every time we type so
02:36:33 <Cale> I hope we eventually *do* make it both pretty and practical.
02:36:38 <quchen> Cale: Okay, maybe it would be practical. I was thinking about the code required to convince the typechecker.
02:36:39 <startling> yeah, I think it's pretty practical.
02:36:55 <quchen> Strike the "practical" :-s
02:37:00 <Cale> quchen: It's usually not too hard to prove associativity and unit laws for monoids in languages like Coq and Agda.
02:37:14 <mm_freak> Itkovian: a sensible client would only regard "so: " and "so, " as highlight
02:37:16 <startling> it's not hard in idris.
02:37:27 <Cale> Or Idris!
02:37:33 <startling> or idris.
02:37:43 <Itkovian> mm_freak clearly I need to reconfigure som things then :)
02:37:49 <Cale> and if we could force people to reasonably do it in Haskell, I would say go for it
02:37:57 <Cale> But Haskell's bad at that kind of thing
02:38:15 <mm_freak> Itkovian: i don't think it's necessary for your nickname ;)
02:38:28 <Cale> So it's to that extent which I think it's okay to say that "monoid" is still a bit of a design pattern in Haskell, rather than something we can actually define in the language.
02:38:30 <mm_freak> unless it's a common word in your language
02:38:35 <Itkovian> Nope
02:39:44 <startling> or a common word in someone else's language.
02:40:12 <Cale> I highlight all occurrences of my nickname, I haven't been too annoyed by it, and it lets me know when people are talking about me :D
02:40:13 <mm_freak> the problem i have with that definition is:  from one language version to the next suddenly it will become wrong to call it "the monoid pattern"
02:40:33 <Cale> mm_freak: I think that's a good thing
02:40:51 <Cale> Evolution of the language eliminates design patterns and turns them into library definitions.
02:42:10 <piezoid> last time I played with DataTypes à la Carte I needed OverlappingInstances, and it's needed as well by the library examples...
02:42:33 <piezoid> so DTC can be thought as a design pattern in Haskel...
03:17:29 <m3ga> mm_freak: "./my-benchmark -o my-benchmark.html" creates graphs as a html page
03:31:50 <QF-MichaelK> how would I map an infix operator to a function in ghci?  ex: let a = +
03:32:20 <Feuerbach> let a = (+)
03:32:50 <QF-MichaelK> Feuerbach: Thanks.
03:35:49 <mm_freak> m3ga: nice, thanks
03:35:56 <mm_freak> could have thought of reading --help more carefully =)
03:44:36 <danharaj> edwardk: http://www.cs.nott.ac.uk/~nhn/TFP2006/Papers/27-GhaniHamanaUustaluVene-CyclicStructuresAsNestedDatatypes.pdf
03:47:22 <ment> so... what's the slowest haskell interpreter available?
03:52:05 <merijn> QF-MichaelK: Simple rule of thumb, to use an operator as prefix surround in parentheses (like (+), (*), etc.). To use a function as infix, use backticks (like `elem`)
03:52:36 <Yuu-chan> Can Zipper be considered a design pattern? AFAIK, it can't generalized as a module
03:52:37 <merijn> ment: I think there mostly only is ghci and hugs?
03:52:51 <merijn> Yuu-chan: Zippers can actually be generalised quite a bit
03:53:07 <merijn> And automatically derived for many types.
03:53:37 <Yuu-chan> merijn: I only know Zippers can be computed as a derivative of the zipped type
03:53:51 <merijn> Yuu-chan: Right
03:54:15 <merijn> ment: Most of the other interpreters use mueval, which is based on most of the same backend as ghci, afaik
03:58:23 <Yuu-chan> But currently there isn't any generic Zipper, or is it?
03:59:04 <ment> merijn: right. well are there any implementations that are not >40K lines? something akin tiny lisp interpreters
03:59:13 <ment> merijn: speed doesn't really matter
03:59:30 <QF-MichaelK> merijn: Ah, yeah.  fancy, silly but: let ops = [(+),(-),(*),(/)]      let stuff a b = [ op a b | op <- ops]
03:59:41 <mr-> Yuu-chan: I'd guess that derivation can't be done without magic
04:00:02 <Yuu-chan> mr-: that's why I considered it a pattern
04:00:14 <merijn> ment: Not really, I think
04:00:34 <merijn> ment: Lisp is significantly simpler than Haskell
04:00:58 <merijn> ment: Do you have a specific usecase? Or just wanting to see how it could be implemented?
04:01:08 <augur> QF-MichaelK: ops <*> a <*> n
04:01:09 <augur> er
04:01:11 <augur> QF-MichaelK: ops <*> a <*> b
04:01:23 <klugez> Yuu-chan: I don't know what they are exactly, but the lens library has Control.Lens.Zipper
04:01:36 <augur> actually you probably want some pure's in there
04:01:50 <augur> ops <*> pure a <*> pure b
04:02:18 <augur> actually there's probably some combinator in prelude
04:02:36 <augur> @hoogle Applicative f => f (a -> b) -> a -> f b
04:02:37 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
04:02:37 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
04:02:38 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
04:02:56 <augur> guess not
04:03:07 <QF-MichaelK> augur: I don't see what you're getting at...
04:04:06 <ment> merijn: at what point does it get complicated? (considering lisp has to deal with all the stuff like garbage collection etc.)
04:04:32 <augur> QF-MichaelK: nevermind :P
04:04:38 <ment> merijn: or better, what's the next step in the "untyped lambda evaluator" -> SASL -> ... -> Haskell chain?
04:04:48 <QF-MichaelK> augur: alright, I was just playing anyway, reading through lyah
04:04:59 <ment> merijn: no particular use, just some diversion i guess
04:05:45 <Yuu-chan> klugez: interesting, but I'm not sure they are derived automatically, probably you need to write some instances for your custom types
04:06:09 <Yuu-chan> klugez: Edward could clarify it :)
04:06:28 <merijn> ment: I think the chain is "untyped lambda calcululs -> simply typed lambda calculus -> System F -> Haskell"
04:06:55 <merijn> Haskell is mostly based on something like System F_omega
04:07:00 <merijn> iirc
04:07:21 <ment> ok, thanks, i'll try to follow the chain :)
04:09:31 <Yuu-chan> ment: see the Lambda cube :)
04:10:20 <ment> Yuu-chan: Lambda Cube, the movie? :)
04:10:43 <ment> oh, the framework
04:10:51 <merijn> ment: It's a term proposed in a paper by Barendregt, he discusses 3 different axes along which the simply typed lambda calculus can be extended
04:11:02 <merijn> ment: The result is a "cube" of lambda calculus variations
04:11:26 <merijn> The chain continuous on from haskell with Calculus of Constructions and Coq/Agda/Epigram ;)
04:11:51 <merijn> ment: Also, if you're interested in type systems and implementing functional languages TaPL is the "go-to" book
04:11:54 <merijn> @where tapl
04:11:54 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
04:12:36 <merijn> I believe it uses some ML variant, but since that's Hindley-Milner too it should be close enough to the basics of Haskell to get you started
04:12:51 <QF-MichaelK> I find that throwing an error for this is curious: read "5" :: Char
04:13:34 <merijn> > read "'5'"
04:13:35 <lambdabot>  *Exception: Prelude.read: no parse
04:13:35 <merijn> eh
04:13:39 <merijn> > read "'5'" :: Char
04:13:40 <lambdabot>  '5'
04:13:52 <merijn> QF-MichaelK: read expects haskell syntax
04:14:04 <ment> merijn: that's perfect, that's something i was looking for
04:14:05 <merijn> QF-MichaelK: Which includes single quotes for Char, double quotes for String, etc.
04:14:37 <merijn> ment: It should cover stuff like implementing type checking and simple languages
04:14:43 <tdammers> read expects whatever the Read implementation for the type at hand expects
04:15:09 <notdan> Right, but for the buit-in types it expects a form of 'haskell syntax'
04:15:26 <tdammers> and I think the reason why nobody bothered making it more featureful is because writing a real parser with something like Parsec is just too easy
04:16:45 <merijn> QF-MichaelK: Also, if you're using GHC 7.6 you probably want to use Text.Read.readMaybe
04:16:50 <merijn> :t Text.Read.readMaybe
04:16:51 <lambdabot> Read a => String -> Maybe a
04:16:57 <Lindrian> ugh, my haskell exam was hard.
04:17:09 <merijn> > Text.Read.readMaybe "5" :: Maybe Char
04:17:10 <lambdabot>  Not in scope: `Text.Read.readMaybe'
04:17:13 <merijn> awww
04:17:39 <sipa> Lindrian: destructively?
04:17:52 <Philonous> > read "'\65'"
04:17:53 <lambdabot>  *Exception: Prelude.read: no parse
04:17:55 <hpc> it was NP-hard
04:18:00 <Yuu-chan> QF-MichaelK: you can think that the argument of read must be a valid Haskell expression which would be succesfully parsed when placed into a code (and have the same type as a result type of read).
04:18:05 <Philonous> > read "'\65'" :: Char
04:18:07 <lambdabot>  'A'
04:18:11 <sipa> hpc: but did he NP-complete it?
04:18:12 <QF-MichaelK> merijn: Hm, no, only 7.4
04:18:13 <Philonous> Uh, I'm surprised
04:18:16 <hpc> lol
04:18:44 <Lindrian> sipa: what?
04:19:18 <Philonous> Yuu-chan, No, derived read instances don't accept all valid expressions.
04:19:33 <tdammers> > read "4 + 5" :: Int
04:19:34 <lambdabot>  *Exception: Prelude.read: no parse
04:20:07 <tdammers> so no, "valid Haskell expression" is not specific enough
04:20:09 <hpc> Yuu-chan: non-derived read instances only accept all valid expressions if you are a horrible person who loves the GHC API ;)
04:20:14 <QF-MichaelK> It just seems strange to throw the exception.
04:20:27 <Yuu-chan> Philonous: I mean it is necessary, but not sufficient
04:21:00 <merijn> QF-MichaelK: You can implement readMaybe yourself using "reads" but reads it a bit ugly
04:21:00 <tdammers> QF-MichaelK: it's a shortcut - it doesn't parse, and while a bunch of possible responses would make sense, this one is probably the easiest to implement
04:21:03 <Philonous> Yuu-chan, For derived instances that seems to be true
04:21:35 <Yuu-chan> Forgot to specify that, my bad.
04:21:39 <merijn> I believe everyone now agrees that 'read' should return Maybe, but it's just too late to change that
04:21:49 <merijn> Backwards compatibility and all
04:21:55 <tdammers> QF-MichaelK: as I said, Read is great for casual conversion from String to something else, but if you need to parse real input, whipping up a Parsec parser or something like that is usually worth the effort
04:22:21 <notdan> QF-MichaelK: I agree that throwing the exception is not perfect; that's why I use 'readMaybe'
04:22:35 <QF-MichaelK> Parsec?
04:22:42 <Yuu-chan> @hoogle Read a => String -> Either String a
04:22:43 <lambdabot> No results found
04:23:03 <tdammers> QF-MichaelK: http://hackage.haskell.org/package/parsec
04:23:03 <QF-MichaelK> @Parsec
04:23:03 <Yuu-chan> Meh. I really needed it recently.
04:23:03 <lambdabot> Unknown command, try @list
04:23:56 <tdammers> there are a few other libraries with a similar approach
04:24:54 <Yuu-chan> Derived Read instances are great... when all your data is undeniably valid.
04:25:35 <QF-MichaelK> notdan: I don't see readMaybe in ghci (7.4.2)
04:26:00 <tdammers> I think Read is great for quick prototyping and stuff like that
04:26:28 <tdammers> but for production-quality code, I prefer having more control over failure modes and such
04:26:29 <QF-MichaelK> Have you seen a show function which spits out Latex?
04:26:45 <QF-MichaelK> Understandable
04:26:57 <Yuu-chan> I'd take an exception if it was something more informative than "no parse"
04:27:00 <notdan> it's in Text.Read
04:28:12 <merijn> Yuu-chan: That exists in Text.Read for 7.6
04:28:19 <merijn> Yuu-chan: (the either result for read)
04:29:14 <merijn> :t Text.Read.readEither
04:29:15 <lambdabot> Read a => String -> Either String a
04:29:44 <Yuu-chan> merijn: neat, thank you!
04:29:57 <merijn> It was added together with readMaybe
04:30:55 * Yuu-chan hopes that the Left part is not always "no parse"
04:30:59 <Kratos_> Hi!
04:31:09 <Yuu-chan> Hi Kratos_ :)
04:31:17 <Kratos_> I'm stuck with an exam question (old exam, not live ;))
04:31:25 <Kratos_> http://lpaste.net/5162459215578529792
04:31:38 <Kratos_> it's about writing a generator for permutations
04:31:52 <Kratos_> the function " perm' " is clear to me
04:32:06 <Kratos_> but I can't quite wrap my head around "perm"
04:32:21 <Kratos_> please have a look at "as <- permâ€™ [0..length xs - 1]"
04:32:35 <Kratos_> doesn't this send a list of integers to perm' ?
04:32:51 <Kratos_> ...and then the next line is: return (map (xs!!) as )
04:33:12 <merijn> Kratos_: It looks a bit weird, tbh
04:33:19 <Kratos_> yes, it does...
04:33:36 <Kratos_> the perm function is required to get rid of the (Eq a) in the type signature
04:33:48 <Kratos_> it's an exam question, not anything from real life
04:33:54 <Yuu-chan> Kratos_: won't it fail for repeated elements?
04:34:18 <Kratos_> No, it works find for repeated elements
04:34:19 <merijn> Kratos_: Don't you have a definition for "Gen"?
04:34:37 <Kratos_> It;s a generator for quickcheck
04:34:40 <merijn> Kratos_: 'perm' is using the monad instance for "Gen"
04:34:40 <Philonous> merijn, That's from quickcheck
04:35:00 <merijn> Kratos_: It's applying perm' to a list of integers, which returns a "Gen [a]"
04:35:17 <Kratos_> oh
04:35:30 <merijn> Kratos_: It then gets an [a] out of the Gen
04:35:43 <merijn> Kratos_: And maps "(xs!!)" over that list
04:36:11 <merijn> Actually
04:36:21 <merijn> It gets an [Int] out of the Gen
04:36:26 <Philonous> Kratos_, The idea is to get a permutation of the numbers [0.. length xs] and then use this as a list of indices into xs
04:36:39 <merijn> Kratos_: It uses this Int list to select elements out of the [a] list given to perm
04:37:06 <Kratos_> ah, now I get it
04:37:13 <Kratos_> thanks!
04:37:58 <merijn> Kratos_: Although 1) this is a bit obfuscated implementation and 2) a syntax error :p
04:38:01 <Philonous> A pretty silly way of doing it but I guess it works
04:38:11 <Kratos_> how would you do it?
04:38:23 <merijn> Kratos_: The last line need to be indented three more spaces to parse
04:39:21 <Yuu-chan> This implementation generates duplicate lists.
04:39:21 <Kratos_> merijn: sorry, that was a mistake when copying and pasting; I was wondering how you would implement this in a less obfuscated way
04:41:04 <Yuu-chan> Oh, nevermind, I had a wrong notion of what sample does.
04:41:20 <merijn> Kratos_: Probably just adding some better naming would help
04:41:36 <Yuu-chan> @hoogle permutations
04:41:37 <lambdabot> Data.List permutations :: [a] -> [[a]]
04:41:37 <lambdabot> package action-permutations
04:41:51 <merijn> I strongly dislike the "map (xs!!)" stuff, but I can't be arsed to think of a better alternative :)
04:43:34 <Kratos_> ok, thanks again!
04:44:06 <Peaker> Probably using ST internally, with some shuffle algorithm in an array is going to be better
04:44:15 <Philonous> Kratos_, http://hackage.haskell.org/package/random-shuffle-0.0.4/docs/src/System-Random-Shuffle.html
04:44:36 <Philonous> Kratos_, As a simple alternative I would repeatedly select one element from the list
04:48:41 <Kratos_> Philinoous, this was an exam question, and I don't think the examiner would appreciate if I wrote down imports for hackage packages ;)
04:49:01 <Kratos_> I like your other suggestion, though
04:49:21 <rose_> could I have some help finding how I should partially apply a database connection to functions so I can reuse the db connection? THe code, error, and docs are here: http://lpaste.net/97054
04:50:05 <Yuu-chan> Kratos_: you could get rid of Eq by selecting the element position (instead of the element itself) and adding a helper function like extract :: Int -> [a] -> (a, [a])
04:52:04 <Philonous> Kratos: of you don't mind it being biased here's a version:  shuffle (x:y:xs) = oneof [(x:) <$> shuffle (y:xs), (y:) <$> shuffle (x:xs)]; shuffle xs = return xs
04:54:12 <Philonous> Oh wait, never mind, that doesn't work
04:54:14 <Peaker> Kratos_: I pasted an annotation with my attempt
04:54:52 <Peaker> O(N^2) though, whereas an ST-array based can happily be O(N)
04:55:07 <Peaker> Not sure what O() in System.Random.Shuffle
04:56:29 <Yuu-chan> Peaker: according to http://okmij.org/ftp/Haskell/perfect-shuffle.txt, it's O(n*log n)
04:56:43 <Peaker> Yuu-chan: ah, still prefer a cheap O(N) though
04:57:13 <Peaker> Inside a library, ugly fast code is better than pretty slow code, so it should probably use ST or at least offer that alternative
04:57:33 <Kratos_> Peaker: Thanks!
05:01:43 <Peaker> what was the equivalent of runSTArray for mutable vectors?
05:01:55 <Peaker> I keep forgetting and I remember them missing the explanation in the docs
05:02:46 <Peaker> screw it, I'll just use STArray
05:03:16 <Yuu-chan> Peaker: doesn't plain runST work?
05:03:22 <Philonous> Peaker, Implementing Fisher-Yates?
05:03:45 <Peaker> Yuu-chan: well, only if I use "unsafeFreeze" first, which sucks
05:03:50 <Yuu-chan> Peaker: we need System.Random.Shuffle.ST on Hackage!
05:03:54 <Peaker> Philonous: maybe :) Not sure what the name is
05:04:21 <Philonous> Peaker, http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm
05:06:15 * hackagebot ansi-terminal 0.6.1 - Simple ANSI terminal support, with Windows compatibility  http://hackage.haskell.org/package/ansi-terminal-0.6.1 (RomanCheplyaka)
05:13:12 <kaan> hello all! I am a tutor for computer science and my students have to learn Java (in my days we learnt Scheme) in there first semester. I want to show them the beauty of Haskell (functional programming) by some examples. Do you have any suggestions? Or: Do you know some excellent slides for that? I can spend 45min for the "show" :-)
05:13:52 <Peaker> doh, now the problem is ST and Gen both have no transformer version. The latter for no good reason
05:14:28 <benj_> learn Java? my suggestion is pity
05:16:16 * hackagebot language-pig 0.3.0.0 - Pig parser in haskell.  http://hackage.haskell.org/package/language-pig-0.3.0.0 (elisehuard)
05:16:20 <Kratos_> kaan, show them how to return a tuple in Haskell, and then do the same in Java
05:16:22 <kinslayer> Isn't somewhat painful to have to do everything with java ?
05:16:42 <Kratos_> ...but industry demands it :P
05:16:54 <kinslayer> java isn't as easy as python, although it has done strides to be very fast.
05:17:05 <Kratos_> so had Python
05:17:09 <Kratos_> has
05:17:38 <Peaker> Java is extremely painful and terrible.. I even prefer C
05:17:42 <frerich> kaan: Showing 'the beauty of Haskell' doesn't sound like it would create any incentive to learn Java, wouldn't it be more practical to show something where Java shines?
05:17:48 <Peaker> (even when performance isn't an issue)
05:18:28 <Kratos_> where does Java shine? The argument is normally that it's a useful language to learn since there is so much Java code used in production.
05:18:55 <zomg> I think Java is reasonably good for beginners because it's very structured
05:19:16 <Kratos_> Java also forces you to use OOP even when it makes no sense
05:19:27 <zomg> That is definitely the biggest problem in teaching programming ;)
05:19:29 <frerich> Kratos_: It shines because it's popular, i.e. "your friends use it". It's easy to get help.
05:19:32 <kaan> frerich, I only want to show them, that there exists something ELSE than imperative programming...
05:19:39 <Kratos_> as a first language, Python is a lot better than Java, and some universities use in fact a functional language in CS101
05:19:41 <frerich> kaan: Ah, okay.
05:19:46 <Peaker> kaan: Some nice examples:  filterM (\x -> [True, False]) [1..3]         threadIds <- replicateM 10 (forkIO (forever (do ...)) {- Thread pool -}      Some Parallelism Strategies' using code
05:20:28 <Kratos_> frerich: I find it much easier to get help with haskell, just by joining this irc channel; if you need help with Java, you have to sift though dozens of online sources that are normally extremely badly written
05:20:30 <kaan> Peaker, Thank you, they're nice, I doubt, that I can explain those functions in that little time
05:20:36 <Kratos_> JavaRanch is the stuff of nightmares
05:21:08 <kinslayer> isn't there a rule that, The bigger the community the more bad advice there is ?
05:21:28 <Peaker> kaan: that's one of the main problems with Haskell.. to get to the beautiful part you have to go through all the tedious basic notation stuff
05:21:29 <destsk> Cambridge teaches ML in its first CS course.
05:21:30 <zomg> Kratos_: you could also just join the java channel for java help
05:21:41 <Peaker> kaan: and you can easily kill 15 minutes just skimming over the very basics
05:21:45 <destsk> And I think Imperial teaches Haskell.
05:21:45 <zomg> though I kind of agree python is also a reasonably good choice for teaching
05:21:49 <mornfall> Kratos_: we used to have cs101 in Haskell, but they are moving over to python
05:21:49 <Peaker> kaan: probably more
05:21:51 <Kratos_> kinslayer: it's an example of regression to the mean
05:21:56 <frerich> kaan: You could use something like a fibonacci function to show how the definition of the function in a functional language very closely resembles the mathematical definition?
05:22:11 <Peaker> mornfall: what was the experience with Haskell? too difficult to learn?
05:22:15 <Peaker> mornfall: or rather, what's the reason for the move?
05:22:39 <Peaker> kaan: the beautiful stuff that can be shown with little explanation are the stuff that don't involve new concepts -- i.e: the less interesting stuff
05:22:46 <Kratos_> when I had to sit through CS101 in Java I was taught that recursion is generally a really bad idea since it blows up the stack
05:22:48 <frerich> kaan: The Haskell syntax which is somewhat less verbose than Java would make it look fairly elegant, too.
05:22:55 <kinslayer> Kratos_: Okay I understand the words individually but in this combination not so sure that I get it
05:22:56 <mornfall> Peaker: they are trying to make bachelor's self-contained enough to spew employable programmers
05:23:02 <Kratos_> teacher didn't say it's more of a problem in Java
05:23:06 <Peaker> kaan: I think it's OK to hand-wave some examples and say "During the course you will learn to read and understand these examples" or such?
05:23:22 <Peaker> mornfall: so employability ruled out a language that's not used for employment?
05:23:40 <Kratos_> kinslayer: the more people you have, the more likely it is that they are all relatively average
05:24:17 <mornfall> Peaker: presumably ... I think the idea that everyone who ends after bachelor's is going to do imperative coding
05:24:23 <kinslayer> kratos_ Okay but wouldn't it stand to reason that a bigger community could lower the mean ?
05:24:27 <kaan> Peaker, yeah you're right, the "beauty"-stuff comes with more knowledge, but as you said, the fact that it is close to mathematic syntax could be a good example.
05:24:38 <Kratos_> kinslayer: say, you could pick 10 top programmers, chances are you could mention 10 names; but now imagine you were supposed to build a company with 1000 top programmers
05:24:47 <mornfall> Peaker: so they hope to cram in more stuff into the 3 years
05:24:49 <kaan> and thanks frerich, the syntax for its own is nice and verbose
05:25:16 <kaan> map (+1) [1,2,3] is beautiful :-)
05:25:16 <mornfall> Peaker: you could say that there's abrasion of CS in favour of IT
05:25:38 <Philonous> Peaker, Test.QuickCheck.Gen exports Gen's constructors, so you can wrap your function by hand
05:25:47 <kinslayer> kratos_ Yeah that would be an example of diminishing return ?
05:25:49 <kaan> I thought of some list comprehensions, they're nice too
05:25:50 <bernalex> the 3 years model doesn't work.it means that they skip all CS in the name of being "practical". applied computer science is a bachelor in crafts, not CS.
05:25:52 <Kratos_> kinslayer: i.e. it's easier to find 10 top coders than 1000 top coders; now talking about communities: small, early communities are self-selecting, but once you hit mainstream, quality goes down because you get people who just follow trends
05:26:25 <kinslayer> kratos_ which was my point
05:27:13 <mornfall> bernalex: I don't dispute that.
05:27:13 <Kratos_> kinslayer: so,it's regression to the mean. I'd assume that the early Haskell community only consisted of academics
05:27:33 <kinslayer> kratos_ that would make sense
05:27:43 <Peaker> Philonous: I'll just use System.Random interfaces
05:27:52 <kinslayer> kratos_ also this is very easy since I have a cat on my keyboard half the time.. :D
05:28:03 <mornfall> bernalex: but it all comes down to external influences, like how the university is budgeted
05:28:06 <Kratos_> kinslayer: ...and Haskell spread from there; on the other hand, Java was built through marketing
05:28:14 <bernalex> mornfall: it's a bigger problem that all programming bachelors focus on contrived stupid "exercises" where you make things from scratch. instead, students should contribute to free software. nothing teaches the value of code quality like that.
05:28:36 <kinslayer> kratos_ I would think that java would be a lower mean from the start (and then perhaps now they are evening out a little) ?
05:28:41 <mornfall> bernalex: if you need to get over half the students through the study, and you want to take in 600 students every year, you have to make compromises
05:29:01 <bernalex> mornfall: yes, the focus is on money, of course. like everything else.
05:29:09 <Kratos_> mornfall: I'm a CS student myself, BSc. We've got 2nd year students who have a hard time writing for loops
05:29:16 <bernalex> as a result, diplomas are worthless.
05:29:36 <bernalex> Kratos_: I had to explain to a masters level student what directories are and how you move files between them.
05:29:37 <mornfall> Kratos_: news at eleven :-)
05:29:46 <Kratos_> and the university budget depends on how many students graduate, i.e. more people == more money
05:31:10 <mornfall> Kratos_: because obviously, graduation rate is the best indicator of teaching efficiency :)
05:31:44 <bernalex> actually, over here it is also considered prestigious to have high fail rates in hard sciences like maths.
05:32:04 <mornfall> bernalex: it is... but it doesn't pay :-)
05:32:26 <mornfall> and if you develop an appetite for money ... you know
05:32:34 <bernalex> mornfall: it generates hype "omg such school so challenge", and then more people apply.
05:32:47 <Kratos_> bernalex: I think that's rare these days. All I notice is that departments try to increase student intake at all costs. I've witnessed that recently they waived a couple of admission criteria, just to get more bodies in
05:33:08 <jophish> Yo yo yo
05:33:36 <Peaker> Philonous: bah, http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm is buggy
05:33:45 <Peaker> Philonous: implemented it blindly but it doesn't ever touch the last element
05:33:46 <mornfall> bernalex: depends, if you already take in 600 students, making the school harder will probably reduce that
05:33:51 <jophish> Can anyone suggest a nice place to start learning about FRP, preferably with some focus on OpenGL
05:33:59 <mornfall> bernalex: slackers will find a different school to float through
05:34:00 <jophish> Lots of examples I've found seem to be quite old
05:34:06 <Peaker> or maybe I'm confused, checking it out :)
05:34:19 <bernalex> Kratos_: the problem here (and everywhere else) for CS is that there can't be any valuable admission criteria. for a bachelor of physics, at least you can say that you need to have 3 years of maths & physics prior to applying. but you can't do that for cs, since it's not taught in secondary school.
05:34:20 <Philonous> Peaker, do you have the code somewhere?
05:34:23 <Peaker> Oh, it's my silliness, never mind :)
05:34:30 <bernalex> mornfall: yes, it's more applicable to small schools.
05:34:32 <Kratos_> jophish: the other day I heard that there is a MOOC in FRP on Coursera, maybe check it out. It's based on Akka
05:34:36 <Peaker> Philonous: bah @ Array.bounds.  That's what I get for using Array rather than Vector :P
05:34:36 <Philonous> Peaker, :)
05:34:56 <Peaker> Philonous: If Vector had proper support for runSTArray or at least documentation about it...
05:35:00 <jophish> Kratos_: cool, thanks
05:35:21 <Kratos_> bernalex: you can still demand that people have done a bit of mathematics in high school
05:35:27 <mornfall> bernalex: we used to have two study programmes, a small one and big one... but that fell in a reform too
05:35:43 <bernalex> Kratos_: maths skill is not necessarily correlated with programming skill for applied cs.
05:35:46 <Philonous> Peaker, I've never used vectors. Do you mean these: http://hackage.haskell.org/package/vector ?
05:35:48 <mornfall> bernalex: (with the small one being hard and prestigeous, and people enrolling for the challenge)
05:36:02 <bernalex> Kratos_: further, when I was in secondary school, I didn't know that maths was a big deal for programming, so I never bothered.
05:36:04 <Peaker> Philonous: yeah. more modern arrays
05:36:12 <Philonous> mornfall, bernalex, would you mind taking it to #haskell-blah ?
05:36:17 <Kratos_> bernalex: yes, not not necessarily, but I'd assume that if someone can't "hack" mathematics, they will have a very hard time in CS
05:36:23 <Peaker> http://lpaste.net/97060 <-- ST-based fisher-yates
05:36:40 <Peaker> will cabalize it when I have more time...
05:37:12 <Kratos_> but that's more of an issue in the country I'm studying in since here people can make it through highschool with little more than basic algebra
05:37:42 <Kratos_> In many other countries standards for maths in high school are a lot higher
05:37:59 <Philonous> Kratos_, Can you please move it to -blah ?
05:38:12 <Kratos_> sorry, I'll shut up now
05:39:34 <kinslayer> kratos_ I think standards for education have been slipping in a lot of countries...
05:40:39 <Hodapp> oh, we've raised standards like crazy! Just not the ones that matter.
05:46:37 <nh2> is there a type class that enumerates me all alternatives of a simple sum type? e.g. (all :: [a])?
05:46:59 <nh2> or is that reundant with Enum+Bounded and [minBound..maxBound] ?
05:47:17 <Peaker> nh2: Enum+Bounded are type-classes that let you enumerate..?
05:47:30 <quicksilver> the enum+bounded one is the way I'd do it
05:47:40 <Peaker> though there's a "universe" package for less simple sum types
05:47:43 <quicksilver> Enum is a mess of a typeclass but, anyway, it works
05:47:55 <danilo2> Hello! Why a lot of libraries (like accelerate) use IO(Either Error Something), instead of IO ( Something)? Whats wrong with IO errors? Should I avoid them in production code? (f.e: Data.Array.Accelerate.IO.readImageFromBMP)
05:48:02 <frerich> nh2: I often have a helper function 'allValues = [minBound..]' which does just that, i.e. Enum+Bounded
05:48:41 <Philonous> danilo2, There's no way to tell which exceptions an IO action might throw
05:48:59 <Philonous> danilo2, With IO (Either ErroType a) you see it in the type
05:49:27 <Philonous> danilo2, And it's impossible to forget to check these errors because the type checker will complain
05:49:48 <merijn> Is the testing framework stuff in cabal still in development or is it already working?
05:50:12 <danilo2> Philonous: So general rule is to use IO(Eiter Error Something) always? It makes sense, but this indicates that IO errors are a little wrong implemented in my opinion
05:51:20 * hackagebot language-pig 0.3.0.1 - Pig parser in haskell.  http://hackage.haskell.org/package/language-pig-0.3.0.1 (elisehuard)
05:51:47 <Philonous> danilo2, I like to use it wherever I can. But it has downsides. For example with exceptions you can just handle the errors you care about and let the rest fall through
05:52:14 <nh2> frerich: ah, indeed [minBound..] without upper limit is elegant
05:52:31 <danilo2> Philonous: You can do it with hoistEither also (from errors library)
05:52:33 <nh2> merijn: you mean `cabal test`? That is working
05:53:17 <Philonous> > [False ..]
05:53:19 <lambdabot>  [False,True]
05:53:34 <tdammers> wait what?
05:53:37 <Philonous> Didn't know that worked
05:53:50 <tdammers> me neither
05:54:21 <tdammers> I would have expected either [False, True, True, True, True, ... or [False, True, ** Exception **
05:54:36 <Philonous> @type succ
05:54:37 <lambdabot> Enum a => a -> a
05:54:51 <tdammers> > succ True
05:54:52 <lambdabot>  *Exception: Prelude.Enum.Bool.succ: bad argument
05:54:54 <Philonous> I wonder how that works, though, since Enum doesn't require Eq
05:55:07 <danilo2> tdammers: No, if you;ve got numbers, you can count them. They are not cycled if you write [1..]
05:55:31 <tdammers> danilo2: I am aware of that part
05:55:59 <tdammers> I'm just stumped that [False..] doesn't try to produce an infinite list
05:56:06 <nh2> danilo2: enumerated errors will make your code very robust/uncrashy. One reason that IO exceptions etc. exist despite many liking checked ones more is that some errors cannot easily be enumerated (e.g. OS-dependent), and they make async exceptions easier
05:56:42 <danilo2> nh2: ok, I'll write them using this style :)
05:56:45 <merijn> tdammers: I guess it just depends on the implementation of Enum
05:56:53 <danilo2> nh2, Philonous: thank you :)
05:57:20 <merijn> danilo2, nh2: Also, not all types of exceptions are nicely handlable using Either
05:57:30 <tdammers> merijn: hmm, yes, but still...
05:57:40 <danilo2> merijn: Do you have any examples?
05:57:50 <merijn> danilo2, nh2: IO exceptions (I mean IO as in filesystem/socket/read/write/etc. calls, not the haskell type) are notoriously annoying to do checked
05:59:03 <merijn> danilo2, nh2: My goto is client-server protocol that has no error handling. Upon error there's nothing you can do other than disconnect and cleanup, so just having a thread get killed by an exception (using bracket for cleanup) can be much nicer than spreading Either everywhere
05:59:43 <merijn> Libraries should return error codes, not exceptions. But in application code exceptions can be nicer
06:00:38 <nh2> merijn: I agree, that's what I meant with async exceptions above
06:01:38 <lieven_> can you do exceptions with resumption semantics in haskell?
06:02:21 <merijn> What does "resumption semantics" mean?
06:02:50 <quicksilver> the ability to handle the exception and return control to where it was thrown so a normal value is returned from the function
06:02:54 <quicksilver> and it's as if nothing has happened.
06:03:01 <lieven_> the stack doesn't get unwound, the handler gets called, handles the problem and the computation continues
06:03:29 <k00mi> the thing that annoys me the most about exceptions in haskell is that I usually have to add a type signature somewhere in the middle of an expression
06:03:37 <quicksilver> haskell's built-in asynchronous exceptions do not have that capability
06:03:39 <k00mi> when using try etc.
06:04:02 <quicksilver> you can devise your own capability like that using threads, certainly
06:04:08 <lieven_> if you know common lisp, handler-bind versus handler-case
06:04:10 <quicksilver> and you can call it "my exceptions" if you like ;0
06:04:26 <quicksilver> or even not using threads.
06:04:57 <quicksilver> there are some google hits for haskell resumable exception too
06:05:19 <merijn> k00mi: That only happens if you don't use the thrown exception type anywhere. If you do type inference will remove that issue
06:07:06 <jophish> I can't really see what FRP gets me over a regular monadic
06:07:39 <rose_> could I have some help finding how I should partially apply a database connection to functions so I can reuse the db connection? THe code, error, and docs are here: http://lpaste.net/97054
06:07:43 <jophish> regular monadic construction, for a game engine
06:08:34 <danilo2> merijn: Ok, thank you for this clarification :)
06:10:53 <k00mi> merijn: yep, or when using the *Just variants, but usually I just wrap some action and handle the error directly and don't use it any further
06:15:47 <deech> Hi all, I have C header file included in my Haskell source and Haddock fails trying to find it. How do I get it to not chase down foreign header files?
06:17:51 <frerich> merijn, Philonous: "[n..]" is sugar for "enumFrom"; the documentation of the Enum class states that "'enumFrom' and 'enumFromThen' should be defined with an implicit bound, thus: enumFrom x = enumFromTo x maxBound".
06:20:38 <Philonous> > [maxBound, ..] :: Int
06:20:39 <lambdabot>  <hint>:1:12: parse error on input `..'
06:20:44 <Philonous> > [maxBound ..] :: Int
06:20:45 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
06:20:45 <lambdabot>              with actual type `[t0]'
06:20:50 <Philonous> > [maxBound ..] :: [Int ]
06:20:51 <lambdabot>  [9223372036854775807]
06:23:16 <tdammers> > [1..9223372036854775806..]
06:23:18 <lambdabot>  <hint>:1:24: parse error on input `..'
06:23:28 <tdammers> > [1, 9223372036854775806..]
06:23:29 <lambdabot>  [1,9223372036854775806,18446744073709551611,27670116110564327416,36893488147...
06:23:43 <tdammers> > [1, 9223372036854775806..] :: [ Int ]
06:23:44 <lambdabot>  [1,9223372036854775806]
06:23:57 <tdammers> ah
06:24:09 <tdammers> misconception on my part then
06:24:12 <tdammers> apparently
06:29:08 <danilo2> Hello! I've got an color coded as Word32 number. I want to exctract the R, G and B as Word8. I'm using "(rgba `div` 0x100) .&. 0xFF" to exctract G - how can I convert it to Word8 in the best (most beautifull) way?
06:31:00 * frerich read 'beanmachine' and, for a moment, thought that quicksilver is doing a pun on benmachine's nickname... :-}
06:31:45 <nh2> danilo2: shift+mask should be ok I guess
06:32:19 <Philonous> danilo2, fromIntegral
06:32:44 <danilo2> Philonous: Right now I just made a facepalm ... of course! :)
06:33:05 <danilo2> nh2: I forgot about Philonous  function: fromIntegral
06:33:09 <danilo2> Philonous: thank you :)
06:33:29 <danilo2> nh2: I do not think shift + mask would allow me to convert types - it will land in Word32 I think
06:36:26 * hackagebot tasty 0.5.2.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.5.2.1 (RomanCheplyaka)
07:06:30 * hackagebot epanet-haskell 2.0.12.1 - Haskell binding for EPANET  http://hackage.haskell.org/package/epanet-haskell-2.0.12.1 (psibi)
07:09:03 <yogert> Hey whats the fastest way to find the index of the first set bit of an integer? I am aware of the use of de Bruijn sequences, but I'd rather not have to implement it all myself if there is a better alternative
07:09:26 <geekosaur> there should be something in Data.Bits, I think?
07:09:47 <yogert> I didn't seem to find anythingâ€¦ it's possible i missed it though
07:09:51 <tdammers> http://graphics.stanford.edu/~seander/bithacks.html
07:09:53 <yogert> one second...
07:09:56 <tdammers> one of these maybe?
07:10:08 <int-e> which one is the "first" bit anyway?
07:10:39 <geekosaur> oh bleh, that's right, popcount went in but the first-bit-set didn't
07:11:02 <yogert> why not?
07:11:26 <int-e> popcount ((x `xor` -x) - 1)  finds the index of the least significant set bit.
07:11:33 <int-e> uhm
07:11:45 <int-e> popcount ((x .&. (-x)) - 1)
07:12:02 <int-e> (not sure why I had xor there)
07:12:30 <yogert> oh great i'll give that a shot. thanks
07:15:34 <lieven_> Data.Bits.Extra.lowestBitPlus1 ?
07:16:53 <yogert> lieven_: oh I hadn't seen that. Ill give it a look as well thanks
07:17:30 <yogert> oh thats great actually. I was looking for a solution that might use the gcc builtins
07:21:32 * hackagebot epanet-haskell 2.0.12.2 - Haskell binding for EPANET  http://hackage.haskell.org/package/epanet-haskell-2.0.12.2 (psibi)
07:32:26 <dawik> lets try sneaking an almost totally unrelated question in here: how do i get xmobar to display on my secondary monitor?
07:32:49 <k00mi> dawik: try #xmonad
07:33:13 <dawik> k00mi: i was just there and i was'nt unable to send to the channel, which is why i try here
07:33:38 <dawik> figured Someone might know :)
07:34:50 <dawik> oh now i know why that was. feel free to ignore my question (or answer if you know) while i ask there..
07:36:34 * hackagebot bencoding 0.4.2.1 - A library for encoding and decoding of BEncode data.  http://hackage.haskell.org/package/bencoding-0.4.2.1 (SamTruzjan)
07:37:17 <xkb_> there's also an monad for os x right?
07:37:24 <xkb_> oops, got discod
07:40:33 <ion> wat
07:41:34 * hackagebot epanet-haskell 2.0.12.3 - Haskell binding for EPANET  http://hackage.haskell.org/package/epanet-haskell-2.0.12.3 (psibi)
07:41:58 <kstt> hi
07:42:20 <kstt> how would you decode a bytestring into a float ?
07:42:40 <kstt> (the bytestring is the textual representation of the float)
07:42:55 <kstt> with a string, I would 'read'
07:43:13 <geekosaur> xkb, you mean osxmonad? (there's also another one floating around I think) they're both incomplete
07:43:39 <Philonous> kstt, That really depends on the format and how you are using it?
07:44:41 <Philonous> kstt, If it's a Unicode string with a text representation read can handle you can try read . Text.unpack . Text.decodeUtf*
07:45:05 <kstt> hi Philonous. Can you elaborate a bit please ? The format of the BS is just the textual representation of a float, so ABC.XYZ, so everything fits in ASCII.
07:45:48 <frerich> kstt: Just 'read' would work then, no? E.g.
07:45:52 <frerich> > read "123.456" :: Float
07:45:53 <kstt> Obviously, I try to avoid converting the BS to a string
07:45:54 <lambdabot>  123.456
07:45:58 <frerich> Ah...
07:46:03 <kstt> this is a string
07:46:05 <Philonous> kstt, If you know for sure it's ASCII you can just use unpack from Data.ByteString.Char8 and read
07:46:25 <frerich> kstt: Yeah, I only now see that you'd rather not convert into a string.
07:48:06 <Philonous> kstt, attoparsec has a parser for floating point numbers
07:48:14 <kstt> Yeah. I have millions of them, the parser is bytestring-oriented. Converting all the data to string would cost.
07:49:18 <kstt> That's a big hammer :)
07:49:28 <kstt> Thank you for the tip, I'm having a look
07:49:48 <Philonous> kstt, http://hackage.haskell.org/package/attoparsec-0.10.4.0/docs/Data-Attoparsec-ByteString-Char8.html#g:14
07:51:44 <kstt> thx, that should work. However, if someone has something smaller to suggest, I would appreciate :)
07:54:41 <Philonous> kstt, The dependency tree of attoparsec seems rather shallow. Also, it's in the haskell platform
07:55:00 <Philonous> kstt, I wouldn't hesitate to use attoparsec.
07:55:10 <Philonous> kstt, Which parsing library do you use atm?
07:55:50 <kstt> Attoparsec is already is my project dependency tree
07:56:30 <oio> >binatyGCD 3 10
07:56:35 <oio> >binaryGCD 3 10
07:56:46 <Philonous> > binaryGCD 3 10
07:56:47 <lambdabot>  Not in scope: `binaryGCD'
07:56:55 <Philonous> oio, You need a space after the >
07:57:14 <kstt> It's just that it has a very elaborate parsing system (with parsers and partials and ...), that I could avoid for such a tiny job.
07:57:30 <oio> mm hey i am getting ambiguos type with binayGCD
07:57:38 <kstt> I'm so lazy :/
07:59:00 <oio> > import Math.NumberTheory.GCD; binaryGCD 3 10
07:59:01 <lambdabot>  <hint>:1:1: parse error on input `import'
07:59:04 <kstt> So lazy that SPJ should make a thesis on me
08:00:16 <mm_bureau> what's a good way to speed up GHC compilation without turning off optimization?
08:00:31 <rasfar> depending on your HD, you could compile to a ramdisk
08:00:47 <pavonia> oio: Please paste a full example with error
08:00:51 <mm_bureau> rasfar: disk speed is not the problem
08:01:08 <rasfar> you can also use plain old make to make a fast 1st pass for whether a rebuild is needed
08:01:18 <mm_bureau> it would help if i could tell GHC (7.6.3) to use the two cores i have here
08:01:21 <rasfar> as GHC takes a few seconds just for that on my system
08:01:52 <mm_bureau> rasfar: indeed, circumventing cabal could help
08:02:04 <rasfar> oh! if you're using cabal build, it's far worse overhead
08:02:17 <rasfar> i really feel it, as my system is a netbook 2yrs old
08:02:54 <mm_bureau> the problem is that everything is tightly integrated
08:03:15 <rasfar> are you building something on hackage?
08:03:16 <mm_bureau> reproducing "cabal-dev build && cabal-dev test" is already quite difficult
08:03:34 <mm_bureau> no, i'm writing code
08:03:42 <rasfar> i've heard cabal-dev is quite quick, but I'm using sandboxes and never tried it
08:03:57 <danilo2> Hi! Is there a library in Haskell, which will provide a function "toFloat", which will work on any number (Int, Float etc?)
08:04:01 <kstt> most cabal-dev features are now integrated into cabal
08:04:12 <danilo2> toFloat for Floats should be "id"
08:04:18 <ADexter> hey, I'm having trouble fixing a type error using Either, could somebody give me a tip on what it is that I'm doing wrong? http://lpaste.net/97077
08:04:24 <mm_bureau> kstt: including (practical) sandboxing?
08:04:26 <rasfar> danilo2: i sympathise with that...
08:04:40 <kstt> mm_bureau: including very practical sandboxing
08:04:52 <mm_bureau> danilo2: you could find realToFrac useful
08:04:53 <rasfar> the sandboxing works great, but it is slow
08:04:56 <kstt> 'cabal sandbox init'. There you go.
08:05:00 <danilo2> rasfar: If there is no, I think I'm gonna make it, because its very usefull for me all the time
08:05:01 <oio> pavonia: http://lpaste.net/97078
08:05:09 <mm_bureau> :t realToFrac
08:05:10 <lambdabot> (Fractional b, Real a) => a -> b
08:05:21 <mm_bureau> > realToFrac (5 :: Rational) :: Float
08:05:22 <lambdabot>  5.0
08:05:26 <mm_bureau> > realToFrac (5 :: Integer) :: Float
08:05:27 <lambdabot>  5.0
08:05:43 <rasfar> i casually proposed a type constraint last time this came up (well, i brought it up)...
08:06:14 <mm_bureau> danilo2: you could write a type-specialized version realToFloat
08:06:21 <mm_bureau> :t realToFrac :: (Real a) => a -> Float
08:06:21 <pavonia> oio: What does your Haskell code look like?
08:06:22 <lambdabot> Real a => a -> Float
08:06:28 <rasfar> the problem is, there can be other, perhaps not-yet-conceived, types of numbers, so there was some objection on an "open world" basis
08:07:03 <oio> pavonia:     putStrLn $ show $ binaryGCD 3 10
08:07:05 <rasfar> i was mainly concerned with the behaviour of the primary arithmetic operators
08:07:34 <rasfar> and standard numerical functions
08:08:25 <Philonous> oio, Add a type to one of the Arguments, as in "putStrLn $ show $ binaryGCD 3 (10 :: Word16)"
08:08:38 <danilo2> mm_bureau: hmm interesting, but the name "realToFloat" is wrong then
08:09:05 <mm_bureau> kstt: do you mean by using --builddir?
08:09:17 <oio> Philonous: i tried (3::Integral a -> a)
08:09:18 <Philonous> oio, The problem is that the types involved couldn't be fixed by the context. The number literals, binaryGCD and show all are polymorphic
08:09:21 <mm_bureau> and --prefix and â€¦
08:09:31 <oio> Philonous: binaryGCD :: (Integral a, Bits a) => a -> a -> a
08:10:07 <Philonous> oio, That's still polymorphic.
08:10:54 <kstt> mm_bureau: no
08:10:59 <kstt> mm_bureau: this http://www.haskell.org/cabal/users-guide/installing-packages.html#sandboxes-basic-usage
08:10:59 <kstt> needs cabal 1.18+
08:11:34 <mm_bureau> uh, i'm on 1.16 =/
08:12:56 <Philonous> oio, Also, it's wrong
08:12:56 <Philonous> oio, Should be (Integral a => a) with a thick arrow
08:13:12 <pavonia> ADexter: You need to return the whole do-block as argument of Right
08:14:07 <oio> Philonous: i tried (3::Integral a => a yes did not work either)
08:14:33 <pavonia> oio: You need a concrete type for 3 and 10
08:15:13 <Philonous> oio, It cant. You have to specify a concrete type like Int or Word16. show and binaryGCD can do different things depending on the type of the arguments, so at some point they have to be fixed
08:16:07 <ADexter> pavonia: Thanks, I never thought to do it that way. I makes sense, thou.
08:16:19 <oio> oooo
08:16:20 <oio> Thnax
08:24:00 <danilo2> Hi! Maybe I'm blind, but why such simnple code returns error? http://lpaste.net/97080
08:25:42 <Rarrikins> danilo2: :: isn't casting.
08:27:33 <danilo2> Rarrikins: what do you mean ?
08:28:17 <flebron> You can't say 'a' :: Potato and convert 'a' to a Potato.
08:28:21 <danilo2> Rarrikins: Maybe I'm wrong, but I was thinking, that when I've got Fractional a and I write type, I'll get that type (you are probably talking I'm wrong) but how to fix it in this code?
08:28:37 <Rarrikins> danilo2: You also need (Fractional a => a) or instance Fractional a => Convertible a Float
08:29:21 <Rarrikins> danilo2: I'm not sure that instances will work properly with that, though.
08:29:23 <haasn> danilo2: â€œFractional aâ€ is not a type
08:30:41 <flebron> Even if you changed that to Fractional a => ..., it still wouldn't compile. Convert is supposed to take an a, and return a Float (in that instance). You can't just say :: Float and have that be "converted" to Float.
08:31:25 <Rarrikins> danilo2: No, it declares the type of n, it doesn't change the type of n. That means that it can only handle Float. If it can get something else, it will be a type error.
08:31:26 <danilo2> Rarrikins, haasn: Hmm, you're right. How in this case I can make such expression working? " (convert 2.0 :: Float)"
08:32:22 <flebron> You may very well lose precision if you're given a = Double.
08:33:02 <danilo2> flebron: I want to create function "convert", which will allow you to loose precision if you want to
08:33:07 <haasn> danilo2: for starters, get rid of â€œclass Convertable a b where convert :: a -> bâ€. I can't think of a single legitimate use case for such a class
08:33:32 <flebron> There's already a float2Double in GHC.Float.
08:33:40 <flebron> (And double2Float.)
08:34:14 <danilo2> haasn: I'm thinking about creating "convert" function, whcih allows for conversion between any numbers. I would love to write (convert 1 :: Float)
08:34:26 <flebron> You can already say 1 :: Float.
08:34:32 <flebron> Since Float is a Num, and Nums have fromInteger.
08:34:41 <danilo2> haasn: Based on this function I wanted to create functions like "toFloat" or "toInt" working on any numbers
08:35:27 <danilo2> flebron: I know, but I want this to work: "let x = 1 :: Int; y = convert x :: Float"
08:35:28 <Rarrikin1> Time for lunch!
08:35:40 <danharaj> :t fromIntegral (1 :: Int) :: Float
08:35:41 <lambdabot> Float
08:35:41 <haasn> danilo2: fromIntegral
08:35:45 <haasn> or realToFrac
08:36:01 <Rarrikin1> > let convert :: Fractional a => a -> Float; convert = fromRational . toRational in convert (1::Int)
08:36:02 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
08:36:03 <lambdabot>    arising from a use of `convert'
08:36:03 <lambdabot>  Possible fix:
08:36:03 <lambdabot>    add an instance declaration for (GHC.Real.Fractional GHC.Types.Int)Could n...
08:36:03 <lambdabot>    arising from a use of `GHC.Real.toRational'
08:36:04 <haasn> those are your two big functions for generalized numeric conversion
08:36:10 <Rarrikin1> > let convert :: Fractional a => a -> Float; convert = fromRational . toRational in convert (1::Double)
08:36:11 <lambdabot>  Could not deduce (GHC.Real.Real a)
08:36:11 <lambdabot>    arising from a use of `GHC.Real.toRational'
08:36:11 <lambdabot>  from the context (GHC.Real.Fractional a)
08:36:11 <lambdabot>    bound by the type signature for
08:36:12 <lambdabot>               convert :: GHC.Real.Fractional a => a -> GHC.Types.Float
08:36:43 <Rarrikin1> > let convert :: Real a => a -> Float; convert = fromRational . toRational in convert (1::Double)
08:36:45 <lambdabot>  1.0
08:36:54 <Rarrikin1> > let convert :: Real a => a -> Float; convert = fromRational . toRational in convert (1::Int)
08:36:55 <lambdabot>  1.0
08:37:12 <Rarrikin1> @type toRational
08:37:13 <lambdabot> Real a => a -> Rational
08:37:26 <danilo2> haasn: I know it, but I want a function "toFloat", which will work on any number (even on Floats)
08:37:27 <flebron> (Rational is basically (Integer, Integer))
08:37:36 <Rarrikin1> @type numerator
08:37:37 <lambdabot> Integral a => Ratio a -> a
08:37:58 <flebron> danilo2: Is there a specific use case you have in mind?
08:38:02 <Rarrikin1> Hmm, there's probably something in Fractional you can use to do it.
08:38:02 <Rarrikin1> But I must eat.
08:39:17 <danilo2> flebron: yes, I want to have image processing functions and I want to create function "floatRepr", which converts curernt representation to Floats (if current repr is float it owuld work as id)
08:39:56 <phserr> I need to coach a moderately inexperient pc user through a haskell package installation, but I don't have windows with me to test things. So, a quick question - does the haskell platform put cabal on the PATH?
08:40:02 <flebron> What is a "current representation"?
08:40:12 <phserr> so that I can just tell him to invoke cabal from cmd.exe
08:40:22 <mstksg> danilo2: so you want something f :: Num a => a -> Float
08:40:49 <mstksg> but typically if you have the number already somewhere, you'll  know enough about it
08:40:54 <mstksg> to know if it's an integral or not
08:41:46 <mstksg> it's not like you are given a heterogeneous list or something
08:41:58 <ibotty> hi
08:42:24 <ibotty> i am playing around with extensible-effects. can it be that it's not ghc7.4-safe?
08:42:39 <ibotty> (or at least parts of it)
08:42:41 <danilo2> mstksg: yes, exactly. Hmm you are right, but this does not proove, such function is useless. It would be much simplier to use one conversion function in any situaton, than choose between fromIntegral or float2double
08:43:13 <flebron> danilo2: You can do that, but you don't need the generality of what you wrote.
08:43:19 <Kolmogorov> Hi. I'm trying to calculate two sequences of integers, p = [1, 3, 7, 12, 18, 26, 35, 45, 56, ..] and n = [2, 4, 5, 6, 8, 9, 10, 11,..]. The k'th element of p is the sum of the k-1'th element of p plus the k-1'th element of n. n is all positive integers starting from 2, unless that integer is in p. I tried doing it like this: http://pastebin.com/HMLcR9Ca , but the program doesn't terminate. Help?
08:43:21 <mauke> The paste HMLcR9Ca has been copied to http://lpaste.net/97083
08:43:56 <zgredzik> hello, does anyone know how to convert a ByteString into a String without special characters, such as < getting converted into thing like \u003c ?
08:44:05 <danilo2> flebron: I know it - I wanted to created generality and then based on it create specific functions. I wanted to create function convert :: (Num a, Num b) => a -> b
08:44:19 <flebron> danilo2: As a tip, use generality when you need it, not before.
08:45:06 <quicksilver> danilo2: there are only two polymorphic "convert into this type" methods
08:45:18 <quicksilver> danilo2: those methods are fromInteger and fromRational
08:45:43 <byorgey> Kolmogorov: using 'elem' is not going to work, since elem has to look through the whole list before concluding that an element is not there
08:45:44 <quicksilver> because of those two, the most general conversion functions are fromIntegral and realToFrac
08:46:02 <flebron> danilo2: http://lpaste.net/97084
08:46:04 <quicksilver> there is no "from*" type method in Num, so your convert is unimplementable.
08:46:25 <byorgey> Kolmogorov: oh, never mind, I see you're defining prefixes of the lists... I guess it is more subtle than that
08:46:53 <danilo2> flebron: I know I can do it like this and this of course works :) I wanted to allow to use this function like this also: "convert 1 :: Float", which does not work, because 1 is Fractional a in this case
08:46:59 <flebron> (Another way to see it's unimplementable is that it's supposed to work for all Nums, but I can definitely create a new instance of Num, which you do not know how to make into a Float.)
08:47:43 <flebron> danilo2: It definitely works, I just tried it. toFloat 1 :: Float gives me 1.0.
08:47:49 <Kolmogorov> byorgey, is the problem may that in the definition of p, I  use last (n k), but I can't calculate n k unless I have  p k?
08:48:12 <byorgey> Kolmogorov: yes, that sounds plausible
08:48:27 <Kolmogorov> byorgey, any idea how I should proceed instead?
08:48:37 <byorgey> Kolmogorov: I suggest trying to trace through evaluation of p and n for small values of k by hand
08:48:49 <flebron> (Basically, Integer is the default Num.)
08:49:41 <Kolmogorov> byorgey, I've done that, but I still think in terms of iterations, and I can't figure out how to do it recursively.
08:50:17 <Yuu-chan> Could somebody help with Gloss, please?
08:50:50 <haasn> danilo2: how would that function convert (Void -> Int) to Int?
08:51:17 <danilo2> flebron: Interesting. If you are using typeclass with one parameter it works, in this example it does not (even if typechecker should behave the same way): (annotation) http://lpaste.net/97084
08:52:24 <quicksilver> danilo2: does that not work if you have a Convertible Integer Float instance?
08:52:41 <donri> is there any flag to make ghc accept type signatures without accompanying bindings? for sketching out apis, i want an implicit undefined
08:52:48 <danilo2> quicksilver: brb
08:53:50 <flebron> danilo2: Int is not the default Num, Integer is.
08:54:05 <danilo2> quicksilver: no
08:54:10 <byorgey> Kolmogorov: the way I would do it is to generate both lists at once, zipped together, like [(1,2),(3,4),(7,5),(12,6)...].  Write a function that takes one pair (p,n) and generates the next.
08:54:24 <quicksilver> oh, it's because of the way defaults work
08:54:26 <byorgey> Kolmogorov: then you can use 'unzip' to get the two lists separately
08:54:30 <Kolmogorov> byorgey, I just started doing that 3 minutes ago :D
08:54:33 <byorgey> =D
08:54:41 <danilo2> flebron, quicksilver: this still does not work: http://lpaste.net/97087
08:54:52 <Kolmogorov> byorgey, thanks, for the 'unzip' too.
08:54:55 <quicksilver> danilo2: yes, defaulting doesn't kick in if the defaulted type has any class constraints other than the prelude ones
08:55:22 <flebron> danilo2: In general, there's really no need for this class :p
08:56:43 <byorgey> Yuu-chan: try asking a specific question.  If someone knows the answer they will help.  If you just say "can someone help with gloss" no one knows whether they can actually help or not.
08:56:47 <nstdloop_> How do I add colors to ghci?
08:56:47 <nstdloop_> ghci -- color and ghci --colour don't work
08:57:14 <flebron> Are there colors for GHCi? O.o
08:57:51 <byorgey> no.
08:58:11 <byorgey> nstdloop_: see http://www.haskell.org/haskellwiki/GHCi_in_colour for some efforts in that direction.
08:58:23 <flebron> https://github.com/rhysd/ghci-color
08:58:27 <byorgey> you might find something there you can use to hack something together
08:58:45 <byorgey> ah, nice, that too
08:58:45 <quchen> You can at least color the prompt.
08:58:46 <flebron> Oh, it's a regexp in sed haha.
08:58:47 <jg> hi all. I'm still trying to wrap my head around haskell. How should i deal with a situation where i want to maintain a growing list of things? Think todo list and adding new tasks. What's the idiomatic approach here? IORef/IOArray/State Monad?
08:58:49 <flebron> Naaaaasty.
08:58:51 <nstdloop_> fiebron: I'm watching Haskell from scratch and the guy in it has it
08:59:24 <nstdloop_> jg: why not use a regular list?
08:59:27 <flebron> Perhaps this helps: http://unix.stackexchange.com/questions/57872/pretty-output-in-ghci-no-colours-shown
08:59:29 <donri> you can use override the default print function with :set -interactive-print, but beware that it might affect the observable laziness
08:59:37 <nstdloop_> define a task type
08:59:42 <nstdloop_> then make a list of tasks
08:59:47 <quchen> My ghci.conf says [see end], which gives me at least some colour.     set prompt "\ESC[34;47m=== %s ================================\ESC[m\n\ESC[34mÎ».\ESC[m "
08:59:49 <byorgey> jg: just pass the current list around as a function argument.  Once you get annoyed with that, you can figure out how the state monad helps.
09:00:30 <donri> quchen: i had problems with colors in the prompt, IIRC related to wrapping long inputs
09:00:47 <jg> nstdloop_: okay, but i will want to 'mutate' the list ie create new lists. I understand holding a named reference which would point to the current list is not the way to go here....
09:00:48 <jg> ?
09:01:04 <quchen> donri: Hm, I never had problems there.
09:02:38 * flebron just had to run ghci via sudo. Apparently updating Mavericks updated my XCode, and ghci needed something it provides to run, leading to a hilarious: "Agreeing to the Xcode/iOS license requires admin privileges, please re-run as root via sudo"
09:03:07 <pyon> jg: Why do you need to mutate the list? Why would creating a new list not be good enough?
09:03:32 <quchen> Oh, I see what you mean, that issue. Yeah that happens.
09:03:40 <quchen> Still worth the colour though ;-)
09:05:29 <SLi> Hey, how would I do something like this in Haskell without doing everything in the IO monad: In a C program I would have a module, decompress.c, which when initialized loads a (constant) lookup table from a file and then provides a decompress() function. Seems to me that since the decompress function needs to rely on loaded values, it needs to work in the IO monad? Unless it is passed the lookup tables as parameters, but then I call it from fairly deep inside
09:05:29 <SLi> pure code...
09:05:32 <nstdloop_> jg: what do you mean? You just want to be able to add to the list right? If it's not very long, then deletion won't be too slow.
09:05:34 <jg> nstdloop_, pyon, byorgey: okay, i think it might be a problem with how i structured my program. I have a user interaction loop which looks like so http://lpaste.net/97088 . Haven't yet figured out where to put the state monad here.
09:06:31 <FreeFull> SLi: You might be able to use the Reader monad
09:06:32 <jg> nstdloop_: keeping track of the return value is the problem i guess
09:06:40 <jg> of the new list
09:07:10 <SLi> FreeFull: Ah, right, there's such a thing! Thanks for the pointer :)
09:07:34 <FreeFull> There probably is another way to do it
09:07:38 <jle`> jg: state monad isn't necessary for this really
09:07:49 <jle`> just make your list an argument for your loop
09:07:55 <nstdloop_> I guess the way I would do it is once I've confirmed that I have a task to create I'd just push it on the end (head) of the list
09:08:05 <jle`> and then when you go back to the loop, pass in the new list
09:08:10 <jg> ohh
09:08:25 <nstdloop_> and pass the tasklist around to the recursive call of this
09:08:29 <nstdloop_> exactly
09:08:45 <jle`> you need to call the loop initially with []
09:08:53 <jle`> most people handle that by making it a helper function
09:09:10 <jg> alright. That's the way i'll do it. Many thanks!
09:09:14 <nstdloop_> then instead of having repl you would do repl (modify tasklist)
09:09:44 <nstdloop_> Unrelated, but you should fix all the little things that Ipaste found
09:09:59 <nstdloop_> like redundant brackets and dos and stuff, it'll make your code look nicer
09:10:26 <jg> ok, i'll do that too
09:10:55 <jg> thanks for the tip
09:13:02 <akbiggs> Hey, I'm having a bit of trouble resolving how (flip (buf_append bufOps)) works in my head from https://github.com/nominolo/HTTP/commit/b9bd0a08fa09 . As far as I can tell, (buf_append bufOps) returns a function that takes some stuff and puts it at the end of bufOps, so it's unary, but flip expects a binary function. How does that work out?
09:13:05 <zgredzik> does anyone know why, when using Aeson to parse a string as JSON, some characters get encoded - like < changing into \u003c and so on?
09:13:57 <quchen> zgredzik: To make it safe to paste the JSON in HTML maybe?
09:14:25 <byorgey> akbiggs: just a guess, but I think buf_append bufOps  is actually binary
09:14:43 <byorgey> akbiggs: it looks to me like bufOps is not a buffer, but a record of functions which are operations on buffers
09:15:00 <byorgey> so  buf_append bufOps  projects the append operation out of the bufOps record
09:15:12 <zgredzik> quachen: makes sense, but is there any way to prevent that from happening or decode the characters?
09:15:36 <zgredzik> quchen: ^
09:15:54 <notdan> Why does the ST monad need the first parameter ('s')?
09:16:06 <akbiggs> oh, wow. okay, that makes more sense. thanks byorgey!
09:16:07 <quchen> Aren't Unicode escapes identical to their represented characters?
09:16:12 <danharaj> It prevents you from mixing mutable state between different instantiations of ST actions.
09:16:23 <byorgey> akbiggs: see the definition of BufferOp here: https://github.com/nominolo/HTTP/blob/b9bd0a08fa09c6403f91422e3b23f08d339612eb/Network/BufferType.hs
09:16:25 <notdan> I understand the "trick" with runST using existential quantification, but I am not sure why this trick is necessary
09:16:38 <quchen> notdan: It's an implementation detail. The phantom type "s" ensures that you don't leak state.
09:17:14 <notdan> quchen: But why do you need that type at all?
09:17:25 <quicksilver> notdan: the STRefs that you create inside the action don't exist outside it
09:17:31 <quicksilver> the 's' stops you using them
09:18:09 <quicksilver> (is a more concrete way of saying the same things as quchen and danharaj already said)
09:18:12 <zgredzik> quchen: well, I'm trying to generate json vales containing html code to be displayed in a browser and this way instead of getting a pretty output I get it all as a text
09:18:38 <notdan> and how could you leak state if there was no 's' involved?
09:18:45 <quchen> notdan: Consider `do { x <- newSTRef 0; return x }`. The "x" has type `ST s (STRef s Int)` (or something like that), so if you `runST` the do block you would get an `STRef s Int`, which has an "s" in it.
09:18:57 <quicksilver> you couldn't leak state. You could segfault.
09:19:03 <quchen> That's what the forall business prevents.
09:19:05 <Yuu-chan> byorgey: okay, but some time ago I asked them and got no reply...
09:19:12 <quicksilver> the STRef is useless outside, and accessing it would crash or do something absurd
09:19:20 <quicksilver> the 's' stops you even trying
09:19:23 <notdan> quchen: right, but you cannot do anything with that STref
09:19:28 <Yuu-chan> byorgey: I'd want to enable texture interpolation in bitmap scaling
09:19:32 <quicksilver> notdan: without the s you could
09:19:37 <quchen> notdan: Sure, you could load it in another ST block for example.
09:19:42 <quicksilver> notdan: you could 'readSTRef' it in another ST block
09:20:03 <Yuu-chan> And to make the window non-resizeable.
09:20:04 <notdan> Oh, I see
09:20:05 <quchen> If you're allowed to leak the "s" you'll end up with IO, pretty much.
09:20:07 <notdan> yes it's obvious now
09:20:14 <quicksilver> let myref = runST(newSTRef 0); myval = runST(readSTRef myref);
09:20:38 <quchen> Oh, the "ST s" in the "x" type in my comment above is too much. Anyway.
09:21:26 <lykos_> I'm wanting to learn FRP, what is a good, up to date, maintained library to use?
09:21:47 * hackagebot smallcheck 1.1.1 - A property-based testing library  http://hackage.haskell.org/package/smallcheck-1.1.1 (RomanCheplyaka)
09:22:20 <fsf-free> Welcome to ##fsf-free, a channel for discussion of all free software and Internet freedom related things! :-)
09:22:36 <flebron> Go home fsf-free, you're drunk.
09:23:02 <fsf-free> flebron, Obviously your drunk
09:23:17 <Iceland_jack> Whose drunk?
09:23:17 --- mode: ChanServ set +o monochrom
09:23:17 <jle`> don't talk about his drunk like that
09:23:18 <flebron> I prefer to call you "our" drunk.
09:23:18 <quchen> Keep your spam and trolling elsewhere please.
09:23:22 --- mode: monochrom set +b *!*@gateway/tor-sasl/xfce-x64
09:23:22 --- kick: fsf-free was kicked by monochrom (fsf-free)
09:24:48 <quchen> zgredzik: There are prettyprinting libraries avaialble for Aeson I think. Maybe those can help you?
09:24:52 <lykos_> Ah, that was a humorous exchange.
09:24:59 --- mode: monochrom set -b *!*@gateway/tor-sasl/xfce-x64
09:25:44 --- mode: monochrom set +b $a:xfce-x64
09:25:51 --- mode: monochrom set -o monochrom
09:27:48 <lykos_> What's a good way to learn FRP/a good frp library to use?
09:27:59 <zgredzik> quchen: thanks a lot, I'll look into that
09:28:01 <lykos_> I'm looking for something up-to-date.
09:28:34 <byorgey> lykos_: try reactive-banana, sodium, or netwire
09:29:01 <byorgey> I have not used any of them.  I just know those are up-to-date/maintained.
09:30:31 <jle`> some people recommend learning Elm, which is a different language from Haskell but shares a lot of syntax
09:30:38 <jle`> and is centered around FRP apparnetly
09:31:02 <cizra> Hi! I'm trying to install the glib bindings on a Mac. I've got glib installed via homebrew, and I get this error: http://lpaste.net/97049
09:32:12 <tac> If by "some people", jle`, you mean Evan.
09:33:10 <byorgey> tac: by "some people" jle` obviously means "some superset of Evan and jle`".
09:33:14 <jle`> tac: haha.  no i've seen people recommend it unironically on this channel before
09:33:20 <jle`> i haven't used elm admittedly
09:33:22 <byorgey> to suggest that no one else recommends learning Elm is silly and false.
09:33:58 <Feuerbach> cizra: could it be the infamous Mac CPP issue? check out the link in the channel's topic
09:35:46 <cizra> Feuerbach: Will try the suggestions there.
09:36:58 <sm> elm is totally worth a look. I've heard (in here) it isn't truly FRP, but data-flow ?
09:38:55 <Iceland_jack> sm: I would suggest reading the Elm thesis, it's very well written and understandable
09:40:29 <sm> good idea, I will. I have only seen Evan's video
09:41:13 <c_wraith> elm doesn't have continuous-time semantics, so it doesn't fit at least one definition of FRP.
09:41:52 <Kolmogorov> byorgey, it works! Thanks for your help.  Can it be done prettier: http://pastebin.com/PZ7atLSj ?
09:41:57 <mauke> I have copied your paste PZ7atLSj to http://lpaste.net/97089 - pray I don't copy it any further.
09:42:33 <Kron> mauke: you monster
09:42:52 <danilo2> Hello! :) I'm new to Aeson. Could somebody tell me please how can I decode things I'm getting from AESON to get readable form back? For example: (encode "a>b") resutls in ("\"a\\u003eb\""). I want to decode it back to "a>b". How can I do it?
09:43:48 <Kron> Kolmogorov: what is this function trying to do?
09:44:43 <shachaf> That doesn't sound right.
09:44:49 <shachaf> > text "\x3eb"
09:44:50 <lambdabot>  Ï«
09:44:55 <Kolmogorov> Kron, calculate two sequences of integers, p and n. The k'th element of p is the sum of the k-1'th element of p plus the k-1'th element of n. n is all positive integers starting from 2, unless that integer is in p.
09:45:12 <Kron> why not move the pattern matching from the guards into the function itself?
09:45:14 <Kron> ah
09:45:24 <danilo2> shachaf: what do you mean? this is output form aeson
09:45:54 <shachaf> Oh, that's 003e
09:46:16 <Kron> what's the first element of k?
09:46:29 <Kron> I mean, what's the first element of p
09:46:35 <shachaf> I guess I'm too used to maximal munch behavior.
09:47:38 <danilo2> shachaf: Do you know how to convert it back ?
09:48:15 <monochrom> isn't it simply calling decode?
09:48:24 <Kolmogorov> Kron, p0 = 1, n0 = 2
09:48:47 <Feuerbach> danilo2: see this http://hackage.haskell.org/package/aeson-0.6.2.1/docs/Data-Aeson.html#pitfalls
09:54:30 <danilo2> Feuerbach, monochrom: Maybe the question was a little wrong: If I\m encoding a datatype with "description" field (which has got description in HTML) and I want to print it to the screen I would like these characters to look normally when encoded with JavaScript
09:54:30 * Kron pokes Kolmogorov
09:54:34 <Kron> is Kolmogorov gone?
09:54:45 <lightquake> when I'm using the normal cabal package database, I can use ghc -Wall File.hs to check a single file without compiling my entire program. is there a way to do that if I'm using a cabal sandbox
09:54:46 <lightquake> ?
09:55:09 <dcoutts> lightquake: not yet, though you can use cabal repl
09:55:36 <dcoutts> lightquake: and if you're using cabal repl then you can reload the one module quite quickly
09:56:01 <lightquake> right
09:56:10 <lightquake> I'm just trying to figure out how to write a flycheck checker for sandboxed projects
09:57:59 <lightquake> so it looks like I can just grab the package database out of the cabal sandbox config and then do ghc -package-db $DB -Wall File.hs
09:58:59 <joneshf-laptop_> ugh, apparently sandboxing isn't working for me, so i've got two packages that want regex, one uses `regex-pcre` the other `regex-pcre-builtin` when I import `Text.Regex.PCRE` ghci says it's ambiguous.  How can i resolve this?
09:59:32 <dcoutts> lightquake: oh, this is for files that are not part of a .cabal project, just files on their own but within the sandbox env?
10:00:05 <lightquake> dcoutts: no, they are within a sandbox project, but I want to automate the checking so I can hook it into emacs
10:00:36 <dcoutts> lightquake: then using ghci on it's own is not enough in general to get the right environment for the component
10:00:52 <lightquake> right, but it's better than nothing
10:00:54 <dcoutts> lightquake: since components in .cabal files can have various other options
10:01:18 <lightquake> i agree that the Right Thing To Do is to actually look at the .cabal file, and i think i might write something that does that
10:02:58 <lightquake> but for now passing -package-db and -no-user-package-db works since i specify my language extensions in the file rather than the .cabal file
10:04:41 <lightquake> maybe in cabal-1.future you'll be able to just do cabal ghc File.hs
10:05:21 <darthdeus> scheme in 48 days mentions this http://i.imgur.com/SkshJ89.png implementing a partial function, but from everything i've read so far, partial functions are always tohught of as bad, no?
10:05:53 <Iceland_jack> darthdeus: I don't agree with the book in this case
10:06:02 <Iceland_jack> there are other ways of dealing with problems such as these
10:06:37 <darthdeus> from my noob point of view wouldn't just raising an explicit error instead of failing on a pattern match be better?
10:06:37 <monochrom> partial functions are fine in suitable contexts. use your good judgment, not religion.
10:06:59 <Iceland_jack> Nobody made any religious arguments :)
10:07:20 <monochrom> oh, everyone thinks he/she is not being religious. everyone is wrong.
10:07:50 <Guest31455> in GTK I have TreeModel (from treeViewGetModel), but I need TreeModelFilterClass. how can I get one from another?
10:07:59 <Iceland_jack> monochrom: That's a rather meaningless statement
10:08:24 <monochrom> I agree to disagree.
10:08:35 <Iceland_jack> Sometimes you really need a subset of a type and there are ways of dealing with that, sometimes partiality is the nicest way of doing so but then the burden lies with you
10:08:56 <quchen> map head . group . sort  etc
10:09:10 <monochrom> is that what I said i.e. good judgment?
10:09:16 <joelteon> > head [1..]
10:09:17 <lambdabot>  1
10:09:32 <Iceland_jack> monochrom: It's rather similar to what you said yes
10:09:43 <monochrom> well there you go
10:09:58 <Iceland_jack> I didn't say I disagreed on your point
10:10:19 <Iceland_jack> The religious remark just didn't add much
10:10:27 <Kron> is there a find function that doesn't return a just, since you know it will return something?
10:10:31 <Kron> say you're working with an infinite list
10:10:41 <Kron> or maybe I should use find with some way to unpack the just
10:10:41 <Philonous> Jake-, treeModelFilterNew gives you a TypedTreeModelFilter, which is an instance of TreeModelFilterClass
10:10:52 <monochrom> ok, a lot of people make "don't use partial functions" a religion. you aren't one of them. but they exist plentily.
10:10:58 <Philonous> Kron, fromJust from Data.Maybe
10:11:04 <mornfall> Kron: repeat 1 is an infinite list and you won't find 2 in it
10:11:10 <Kron> ah okay!
10:11:24 <Philonous> mornfall, It won't fail with a Nothing either
10:11:35 <johnw> monochrom: perhaps part of the reason is that use of partial functions requires discipline, and discipline always fails
10:11:58 <mornfall> true, but it won't return anything
10:12:16 <Philonous> mornfall, Yes, but you don't have to check whether to result is Nothing in any case
10:12:32 <Philonous> the result*
10:13:35 <mornfall> johnw: Turing-complete programming requires discipline by extension
10:13:43 <mornfall> (and it presumably always fails :-)
10:14:08 <quchen> It would be nice if every language would be as lax and easy as Agda.
10:14:21 <johnw> yeah, but at least using things like headMay instead of head forces the point rather than making it something you have to be constantly aware  of
10:14:44 <monochrom> my favourite is safeFromJust
10:15:13 <mm_bureau> Kron: use a stream type
10:15:26 <mm_bureau> if it's a stream and you want stream search, you want Stream =)
10:15:35 <mm_bureau> @hackage streams
10:15:35 <lambdabot> http://hackage.haskell.org/package/streams
10:17:06 <mm_bureau> using fromJust feels so wrong that i'd rather restructure my program
10:17:22 <Kron> it was to solve Kolmogorov's problem
10:17:28 <johnw> mm_bureau: oh, and it's unholy
10:17:32 <Kron>  <Kolmogorov> Kron, calculate two sequences of integers, p and n. The k'th element of p is the sum of the k-1'th element of p plus the k-1'th element of n. n is all positive integers starting from 2, unless that integer is in p.
10:17:42 <Kron> there's a reasonably elegant two line solution
10:17:53 <Kron> though I haven't properly haskellized it
10:17:58 <Kron> my lisp background betrays me
10:18:15 <mornfall> mm_bureau: yes, irrefutable patterns are so much better! :)
10:18:15 <darthdeus> if i have a function of   a -> a and i need to apply it to a monad, should i rewrite the function to   a -> m a  and use bind, or use liftM without changing the function?
10:18:19 <Kron> n = 2 : map (\x -> fromJust
10:18:19 <Kron>               (find (\y -> (not (y `elem` (take x p))) &&
10:18:19 <Kron>                            (not (y `elem` (take (x-1) n)))) [2..])) [2..]
10:18:19 <Kron> p = 1 : zipWith (+) n p
10:18:34 <Kron> It's just two infinite lists that search each other, it works fine
10:18:37 <johnw> darthdeus: certainly the latter
10:18:40 <mm_bureau> darthdeus: liftM
10:18:48 <quchen> :t notElem -- Kron
10:18:49 <lambdabot> Eq a => a -> [a] -> Bool
10:18:49 <byorgey> I pasted an alternate two-line solution to Kolmogorov's problem here: http://lpaste.net/97089
10:18:52 <Kron> I need to be careful with searching n to prevent infinite looping though, hence all the careful take-ing
10:18:57 <darthdeus> cool, but semantically it should be the same, right?
10:19:02 <mm_bureau> darthdeus: if it's a specific monad, i'd prefer fmap over liftM
10:19:08 <Kron> quchen: oh thank you, I didn't know about that function
10:19:29 <stolaruk> Is there ever a case where you would use liftM over fmap?
10:19:31 <haasn> who is mm_bureau and what did he do to mm_freak? :(
10:19:48 <Kron> byorgey: that's fascinating. Can you tell me what unzip does?
10:19:56 <byorgey> stolaruk: if you already had a Monad constraint and did not want to incur a Functor constraint as well.
10:20:01 <johnw> stolaruk: when I only have a Monad constraint, and don't want to force a Functor constraint
10:20:02 <byorgey> @type unzip
10:20:03 <lambdabot> [(a, b)] -> ([a], [b])
10:20:03 <johnw> haha
10:20:12 <stolaruk> Ah I see, makes sense
10:20:16 <byorgey> Kron: can you figure out what it does from the type? =)
10:20:53 <mornfall> does it, uh, unzip? :-)
10:21:04 <quchen> Return two empty lists? ;-)
10:21:04 <darthdeus> stolaruk: if my type is a specific monad, should i still use fmap?
10:21:13 <Kron> hah, yes I think I can
10:21:15 <mornfall> quchen: my guess exactly!
10:21:21 <Kron> @type iterate
10:21:22 <lambdabot> (a -> a) -> a -> [a]
10:21:28 <Kron> I'm not sure what exactly iterate does
10:21:34 <danharaj> @src iterate
10:21:34 <lambdabot> iterate f x =  x : iterate f (f x)
10:21:39 <byorgey> > iterate f x
10:21:40 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
10:21:46 <Kron> hah, that's elegant
10:22:23 <eyebloom> Searching for an infinite loop while hacking GHC. I'm wondering if there is a good way to do this without GHCi?
10:22:32 <Kron> I'm assuming that the implementation uses some sort of sharing or referential transparency hack to not actually call f O(n^2) times, right?
10:22:34 <byorgey> Kron: your solution is nice in that it more faithfully translates the original description.
10:23:08 <Kron> byorgey: thank you, but I like your solution much more
10:23:17 <Kron> as a general principle I am trying to learn to not scatter lambdas in all my functions
10:23:26 <quchen> Kron: All function applications there are shared.
10:23:28 <Kron> it's an old lisp habit and while it does work it's kind of... hard to read.
10:23:33 <johnw> Scattered Lambdas, sounds like a band name
10:23:37 <Kron> Haskell is the only language where I really appreciate code golf
10:23:41 <quchen> Kron: `iterate f x` will only calculate `f x` once.
10:23:45 <Kron> you can make functions smaller and easier to comprehend
10:23:51 <quchen> Well, it will only create one `f x` thunk at least.
10:23:52 <Kron> quchen: gotcha
10:24:24 <stolaruk> darthdeus: Yeah you can use fmap. fmap works with functors but all monads are functors. As such, the usual style is to prefer fmap over liftM. Kind of like how in general you might prefer applicative style over monadic code when you can use applicative style.
10:25:17 <johnw> stolaruk: in 7.10 that should be true of Monad too
10:26:10 <stolaruk> johnw: Are you talking about the "superclass" correction?
10:27:38 <stolaruk> darthdeus: Also good to keep in mind, you can compose "fmap"s to lift a function inside multiple "layers"
10:27:39 <ReinH> eyebloom: good news: detecting infinite loops is, in the general case, impossible :D
10:27:44 <stolaruk> (fmap . fmap . fmap) (+1) $ Just (Just (Just 5))
10:27:53 <johnw> stolaruk: yes
10:27:59 <darthdeus> wow
10:28:00 <stolaruk> johnw: Yeah ok
10:28:16 <stolaruk> How do I get lambdabot to evaluate an expression again?
10:28:17 <ReinH> stolaruk: which is also, btw, (fmap `fmap` fmap `fmap` fmap) :D
10:28:18 <eyebloom> ReinH: I'm saying at runtime.
10:28:25 <ReinH> eyebloom: so am I :D
10:28:39 <joelteon> :t fmap ((>>=) .)
10:28:40 <lambdabot> (Monad m, Functor f) => f (a -> m a1) -> f (a -> (a1 -> m b) -> m b)
10:29:11 <nadirs> hi
10:29:19 <nadirs> > (fmap . fmap . fmap) (+1) $ Just (Just (Just 5))
10:29:20 <lambdabot>  Just (Just (Just 6))
10:29:25 <stolaruk> ReinH: Someone has pointed that out to me before, maybe even you. ;) That would make my brain hurt
10:29:27 <eyebloom> So what is your process if you have a haskell program that is unexpectedly not terminating.
10:29:30 <stolaruk> nadirs: Thanks
10:29:34 <mornfall> nadirs: that's just evil
10:29:44 <ReinH> stolaruk: (.) is fmap for functions :)
10:29:47 <eyebloom> And you aren't sure why.
10:29:58 <nadirs> mornfall: what do you mean?
10:30:07 <mornfall> nadirs: that expression :-)
10:30:09 <stolaruk> mornfall: It's quite usefull when you need it
10:30:27 <jle`> i think people usually define their own fmap . fmap?
10:30:31 <jle`> (:.) ?
10:30:35 <stolaruk> ReinH: Wow, ok...
10:30:36 <mornfall> stolaruk: lambdabot is ok, but that triple-fmap-of-death...
10:30:39 <volko> What was getL for?
10:30:51 <volko> it seems this function is no longer part of Control.Lens
10:30:58 <nadirs> mornfall: I was just refreshing stolaruk's memory about how to ask lambdabot to evaluate something :)
10:30:59 <quchen> :t (.:) -- jle`
10:31:00 <lambdabot>     Not in scope: `.:'
10:31:00 <lambdabot>     Perhaps you meant one of these:
10:31:00 <lambdabot>       `.' (imported from Data.Function),
10:31:16 <quchen> Hm. Well, that's the usual name. And people encourage others not to use it, usually.
10:31:17 <stolaruk> :t (.)
10:31:18 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:31:20 <stolaruk> :t (fmap)
10:31:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:31:32 <nadirs> :t <$> . <$>
10:31:33 <lambdabot> parse error on input `<$>'
10:31:37 <ReinH> stolaruk: think about [b], a list of 'b', and then think about (a -> b), a function that provides a 'b'
10:31:40 <nadirs> :t (<$>) . (<$>)
10:31:41 <mm_bureau> haasn: mm_bureau is da mm_freak in da bureau =)
10:31:41 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
10:31:47 <ReinH> stolaruk: Now think about what you can do to both of them if you have a function (b -> c)
10:31:53 <volko> :help
10:31:55 <jle`> ah yeah. aren't operators that begin with : usually reserved for infix data constructors anyway
10:33:17 <stolaruk> ReinH: Map the (a -> b) over the [b] to get a list of type [c]?
10:33:24 <stolaruk> uh no
10:33:28 <ReinH> stolaruk: and what can you do to your function a -> b?
10:33:38 <ReinH> stolaruk: well, map b -> c over [b]
10:33:44 <stolaruk> yeah that one
10:34:03 <ReinH> and can't you map your (b -> c) over your (a -> b) too?
10:34:20 <stolaruk> Yeah or compose the two functions
10:34:27 <ReinH> stolaruk: yes, *by* composing them :)
10:34:36 <ReinH> stolaruk: so fmap = (.) for functions
10:34:50 <stolaruk> ReinH: Cool!
10:34:51 <jle`> it's similar to fmap for the State monad, if that helps.  (it probably doesn't)
10:34:58 <supki> volko: getL is from data-lens; I don't think it ever was in lens
10:35:29 <FreeFull> You can also fmap over the argument of the function with some newtypes I think
10:35:30 <supki> volko: it's view in lens
10:35:43 <volko> oh
10:35:58 <volko> I tried view, my types still don't work out
10:36:30 <simpson> volko: What do you currently have?
10:36:50 <volko> instance HasAcid App AcidStore where getAcidStore = view (snapletValue . acid)
10:36:58 <stolaruk> volko: You can also use (^.), like x^.y  where y is a lens into x
10:37:30 <jg> what's the idiomatic way of implementing the toString conversion in haskell? Right now i have a xToString :: X -> String function for every X...., that the right way to go?
10:37:33 <jake--> any Gtk2Hs users around? I have generix TreeModel but I need TreeModelFilter. can I convert former to latter?
10:37:39 <jake--> generic*
10:38:09 <stolaruk> jg: In some cases "show" is suitable
10:38:21 <stolaruk> :t show
10:38:22 <lambdabot> Show a => a -> String
10:38:33 <quchen> jg: There's the IsString class in Base for that: http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:IsString
10:38:51 <quchen> Oh wait, that's the other way round.
10:38:59 <mornfall> :-)
10:39:17 <quchen> In that case have a look at Read.
10:39:23 <monochrom> jg: use the Show class, or invent your own class inspired by Show
10:39:32 <monochrom> err, replace Show by Read
10:39:42 <monochrom> err, nevermind, Show is right
10:39:43 <quchen> Eww, wrong again. Read is also not X -> String.
10:39:54 <mornfall> folks :D
10:39:54 <quchen> I should stop talking.
10:39:55 <stolaruk> Yeah it's show
10:40:15 <stolaruk> You can manually isntantiate "Show" to pretty print as you like
10:40:18 <shachaf> IsString is not what you want.
10:40:21 <mornfall> you left me out of whatever good stuff you are having
10:40:43 <mornfall> right, IsString is for string literal abuse
10:41:20 <monochrom> Num is how 1 2 3 could type-check. IsString is how "1" "2" "3" could type-check
10:41:24 <stolaruk> If you roll your own "Show" you might want to roll your own "Read" as well. Serialize and deserialize
10:41:46 <monochrom> soon, with OverloadedList, [1] [2] [3] will type-check, too
10:42:05 <jg> okay, i see. Many thanks
10:42:11 <mornfall> I think you only want to roll your own Show if your types are decorated with existentials.
10:42:31 <shachaf> monochrom: But ['a', True] will still not type-check
10:42:47 <mornfall> shachaf: which is probably a good thing
10:43:09 <joneshf-laptop_> for anyone paying attention `cabal repl`
10:44:00 <sm> leaving Show as the default has some advantages, eg pretty-show can parse it and give you readable debug output
10:44:32 <FreeFull> shachaf: until IsChar
10:44:37 <jg> but i still don't get what is showPrec all about in the docs. That confused me the first time i looked at it
10:44:45 <FreeFull> Or IsBool
10:45:19 <quchen> Or IsIs for things that have an Is* class
10:45:31 <quchen> â€¦ instance
10:45:33 <mornfall> jg: something to do with precedence :-) you can ignore it for the time being
10:45:48 <monochrom> jg: when you later have infix notation and therefore need more parentheses, you will need showPrec
10:46:21 <monochrom> or rather s/more parentheses/automatic minimal necessary parenthesizing/
10:47:48 <mornfall> monochrom: what happens to comprehensions with OverloadedList?
10:48:35 <JordiGH> What's an interesting mainstreamish Haskell project to contribute to, other than Haskell itself?
10:48:42 <benmachine> mornfall: MonadComprehensions, you mean?
10:48:44 <monochrom> I don't know.
10:49:02 <monochrom> lens
10:49:13 <mornfall> benmachine: I mean how does IsList commute with the desugaring of the comprehension
10:49:15 <JordiGH> I mean, what do you guys consider an example of good and interesting public Haskell code?
10:49:23 <benmachine> oh, I don't know either
10:49:27 <sm> JordiGH: library or application ?
10:49:32 <benmachine> JordiGH: all of mine, ofc
10:49:36 <benmachine> jk, I am terrible
10:49:47 <quchen> Pipes and Lens have many small secondary modules, maybe have a look at one of those.
10:49:56 <quchen> i.e. lens-* and pipes-*
10:50:00 <JordiGH> sm: Either, I suppose. I want to look at a big Haskell project that people who don't use Haskell would consider interesting.
10:50:00 <mornfall> Lens is the new Haskell
10:50:23 <Feuerbach> JordiGH: xmonad, pandoc, hledger
10:50:28 <sm> JordiGH: I want your brains, for hledger. It's not too big, but practical
10:50:33 <sm> for a big project, GHC
10:50:43 <JordiGH> ghc is only interesting for people who like Haskell. :-)
10:50:44 <mornfall> sm: GHC isn't particularly interesting to non-Haskell audiences
10:50:45 <johnw> git-annex
10:50:51 <sm> oh right, my bad
10:50:55 <JordiGH> johnw: Oh, Joey is kind of nuts. :P
10:50:58 <pozori> hello. I noticed Real World Haskell (the book) is printed in 2008. is it still relevant?
10:50:58 <sm> +1 git-annex
10:51:05 <mornfall> Feuerbach: and actually neither is xmonad
10:51:11 <JordiGH> If only I didn't hate git so much... I'll take a look at hledger.
10:51:23 * JordiGH is kind of sad that darcs failed.
10:51:23 <monochrom> I don't think "don't use haskell" matters
10:51:31 <sm> \o/ in your face git
10:51:32 <merijn> pozori: Mostly
10:51:36 <Feuerbach> mornfall: why is that?
10:51:43 <JordiGH> pozori: The part about exceptions is old, other than that, it's fairly relevant.
10:51:53 <mornfall> Feuerbach: what's the point of xmonad other than .xmonad.hs? :)
10:51:55 <sm> JordiGH: darcs didn't fail, it's just er resting
10:51:56 <merijn> pozori: Basically, some of the APIs described in the book have changed, but the overarching explanations still apply
10:52:03 <mornfall> Feuerbach: or is it .xmonad/xmonad.hs
10:52:28 <JordiGH> sm: The theory of patches is something only a wretched physicist would come up with. :-/
10:52:33 <merijn> pozori: For complete beginners Learn You a Haskell is usually recommended, RWH is more of a practical treatment of several important libraries and things like profiling
10:52:46 <JordiGH> Commutatativity of operators? In *my* DVCS?
10:53:02 <Feuerbach> mornfall: back when I was active in xmonad community, we had plenty of users who didn't know almost any Haskell. Don't know what it's like now
10:53:07 <JordiGH> sm: Okay, so I can use hledger for tracking my expenses?
10:53:16 <pozori> merijn JordiGH: okay thanks. I'll stick to LYaH then.
10:53:44 <sm> JordiGH: yup
10:53:55 <mornfall> Feuerbach: I'd expect they'd move to something they can configure. :-)))
10:53:59 <mornfall> Feuerbach: or learn Haskell
10:54:06 <JordiGH> pozori: LYaH is less "in-depth" and more "intro", I would say. Great book, I'm very glad I bought a treeware copy. My unending praise for No Starch Press (and I'm not just saying this because I'm a technical reviewer another book for theirs right now).
10:54:32 <merijn> pozori: RWH is a good follow up to LYAH. The biggest "problems" are things like the parsec chapter describing parsec 2, instead of parsec 3. On the other hand, using 3 after learning how 2 works is trivial as the big picture is the same
10:55:16 <JordiGH> pozori: I agree with merijn. After reading LYAHFGG, RWH was a good follow-up.
10:55:29 <mornfall> Feuerbach: also, I'm a little worried that the future for xmonad is rather dim, now that people are actually starting to move away from X
10:55:53 <monochrom> then xmonad should also move
10:56:01 <volko> Hmm, I cannot get this HasAcid instance to check out
10:56:05 <mornfall> monochrom: and become a compositor?
10:56:09 <mornfall> monochrom: doesn't seem very likely
10:56:39 <volko> getAcidStore wants an Acid AcidStore, but it's getting a Snaplet (Acid AcidStore)
10:56:54 <volko> i'm following the example in http://hackage.haskell.org/package/snaplet-acid-state-0.2.5/docs/Snap-Snaplet-AcidState.html#t:HasAcid
10:57:28 <JordiGH> sm: Are you the one hosting demo.hledger.org?
10:57:36 <JordiGH> Looks like someone decided to make Breaking Bad jokes with it?
10:58:02 <Mortomes> example?
10:58:25 <JordiGH> I don't know, I just "methsales" in it.
10:59:31 <sm> JordiGH: yes.. let me see
10:59:39 <danilo2> Hello! I've got very strange accelerate error. The type checker checks tells everyrthing is ok and the error appears when running the program. I investigated it is caused by following function: http://lpaste.net/97091. Why this happens?
11:00:34 <sm> it's just a sandbox. It used to be have awesome clown transactions
11:00:53 <mornfall> danilo2: well, an instance method is missing, clearly :)
11:01:32 <dhrosa> Hello! I know how to do this with a lambda, but does anyone know a shorter way to map a function onto the first elements of a list of tuples?
11:01:48 <mr-> dhrosa: map fst ?
11:01:54 <Feuerbach> map (first f)
11:02:03 <mr-> ah.. a function. sorry
11:02:05 <mornfall> danilo2: I guess you aren't supposed to call fromIntegral on that
11:02:12 <Feuerbach> first is in Control.Arrow
11:02:19 <danilo2> mornfall: Ok I've got it! I should not use "fromIntegral", but I sahould use "A.fromIntegral" instead - this is accelerate method. The error message is completely not informative - it popints inside the accelerate package
11:02:48 <dhrosa> Feuerbach: oo, thanks
11:03:07 <mornfall> danilo2: yeah, sounds like a bug in accelerate ... they probably need the instance for something though, but can't actually convert to numbers
11:03:33 <mornfall> danilo2: so chances are the best you could hope for is toInteger = error "something informative"
11:04:13 <danilo2> mornfall: heh, yeah the error should be more clear. Im happy it is working with A.fromIntegral :)
11:07:00 * hackagebot epanet-haskell 2.0.12.4 - Haskell binding for EPANET  http://hackage.haskell.org/package/epanet-haskell-2.0.12.4 (psibi)
11:07:31 <JordiGH> sm: Hm, I'd like to get interested in hledger, but I think I would need to start a business first.
11:07:57 <sm> why JordiGH ? no need for personal tracking ?
11:08:09 <JordiGH> I'm just not that organised. :P
11:08:17 <ludamad> Considering I wrote this mostly with imperative programming in mind I'm curious what you lot think: http://adam-dev-blog.blogspot.ca/2013/12/a-parameterized-attack-on-programming.html
11:08:24 <JuanDaugherty> hledger is mostly used for personal purposes
11:08:25 <sm> that's what it helps with :)
11:08:49 <JuanDaugherty> the whole *ledger ecosys ftm, gnu cash, etc
11:09:46 <jle`> pozori: if you have finished LYAH and have some comfort in Haskell you are probably ready to also benefit from Simon Marlow's parallel & concurrent haskell. even though you might not need to do parallel/concurrent computing, you will learn a bit about haskell in general and style and approaches to problems
11:10:00 <ion> Now i want to create a programming language named L.
11:10:28 <mornfall> ion: why L?
11:10:39 <ion> mornfall: See ludamadâ€™s link.
11:10:46 <JuanDaugherty> doubtless already done so you'll need Ln
11:11:24 <JuanDaugherty> prolly every latin character
11:11:38 <mornfall> ion: I see
11:11:44 <quchen> I suggest inserting L via a HTTP GET parameter.
11:11:54 <ludamad> Haha
11:11:59 <quchen> Then post the same link 10 times on Reddit and HN and see how it goes.
11:12:02 <mornfall> ludamad: also, I disagree :-)
11:12:05 <quchen> Well, the "same" :-)
11:12:06 <JuanDaugherty> http://en.wikipedia.org/wiki/L_(programming_language)
11:12:06 <ludamad> Yea
11:12:17 <ludamad> mornfall: Good, thoughts ?
11:12:33 <mornfall> ludamad: many languages failings are actually language failings
11:12:46 <jle`> ^^
11:12:48 <ludamad> mornfall: Oh. Don't get me wrong.
11:13:07 <ludamad> mornfall: This aims to show the absurdity of viewing a language as a something you must formulate everything in.
11:13:15 <ludamad> as something*
11:13:22 <ludamad> because then that implies this monoculture, etc
11:13:29 <ludamad> but really, i mostly think all languages suck.
11:13:55 <mornfall> ludamad: that's because they do, and there's mostly nothing that can be done to fix that
11:14:10 <ludamad> mornfall: Too easy an assumption
11:14:12 <mornfall> ludamad: (and I suppose that's what you are trying to say)
11:14:49 <ludamad> Well the whole idea I was trying to say with early vs modern is that somehow maybe theres a different model. But you can arrive at a contradiction just formulating it for sure.
11:15:34 <ludamad> but the main intuition is that eg SQL and regex are parts of a stable solution if we want common language between industries
11:16:05 <ludamad> (not CORBA, dear god)
11:16:16 <mornfall> ludamad: why would you want a common language between industries?
11:16:20 <simpson> ludamad: SOAP? :3
11:16:37 <mornfall> simpson: nono, REST
11:16:38 <ludamad> mornfall: Why would you want to derive calculus over again ?
11:16:47 <ludamad> same idea, you can reuse results a lot better
11:16:55 <simpson> mornfall: But people appear to hate REST.
11:17:07 <mornfall> ludamad: which industrial product is like calculus?
11:17:14 <simpson> ludamad: Which L are you talking about, BTW?
11:17:20 <ludamad> mornfall: Correct programs
11:17:33 <ludamad> simpson: Its a satire
11:17:49 <ludamad> (but does aim to show you can reasonably argue any language sucks)
11:18:06 <simpson> ludamad: How do you feel about chimaeric languages?
11:18:07 <mornfall> ludamad: now I may live in a different universe, but can you point at one correct program that came out of industry? :)
11:18:32 <simpson> I ask because L is apparently the name of a language that was inspired by E, and E supports directly embedding languages inside itself through extensive quasiquoting.
11:18:40 <benmachine> < ludamad> mornfall: Why would you want to derive calculus over again ? â† in fairness this actually sounds like my idea of a good time
11:18:46 <mornfall> ludamad: I'm sure the industry would love to mass-produce calculus if there was money in it. Doesn't mean they can.
11:18:58 <ludamad> mornfall: Google Mathematics Inc
11:19:04 <ludamad> if you havent seen EWD's analogy
11:19:07 <ludamad> very funny
11:19:16 <ludamad> 'royalties for Riemann hypothesis usage'
11:19:21 <ludamad> 'secret proof'
11:19:36 <ludamad> but thats the thing, it should be equally absurd for provable program components to be patentable
11:19:39 <mornfall> benmachine: eww calculus
11:19:46 <ludamad> and thus industries should go back to not-programming
11:19:57 * JuanDaugherty fingers the topic whistle
11:19:57 <benmachine> mornfall: eww, *your* hobbies
11:19:59 <ludamad> and we'll finally make sense of this curveball
11:20:04 * benmachine folds arms grumpily
11:20:08 <mornfall> benmachine: how can you tell I have any?
11:20:15 <benmachine> mornfall: ewwww.
11:20:22 <simpson> ludamad: Also, how do you feel about ML? It is, after all, the *meta-language*.
11:20:48 <mornfall> right right, #haskell-blah
11:20:59 <mornfall> this is the second time today
11:21:26 <ludamad> simpson: As long as you can formulate something using the least strength I think you have a candidate system
11:21:36 <ludamad> that being said, I think its a compound solution for sure
11:21:49 <ludamad> ok, ill stop deriding, sorry
11:21:52 <simpson> ludamad: Oh, you obviously want Forth. >:3
11:22:01 <ludamad> PMs welcome
11:22:17 <ludamad> simpson: Least strong == most provable :-)
11:22:25 <ludamad> not BF :-)
11:22:46 <simpson> ludamad: I think that Mr. Godel has something to say about that. >:3
11:22:46 <skypers_> hi
11:22:57 <skypers_> Iâ€™m looking for a filterBy function
11:23:08 <skypers_> is it deleteBy . not ?
11:23:10 <simpson> :t filterBy -- isn't this in Data.List
11:23:11 <lambdabot>     Not in scope: `filterBy'
11:23:12 <lambdabot>     Perhaps you meant one of these:
11:23:12 <lambdabot>       `filter' (imported from Data.List),
11:23:15 <skypers_> nope
11:23:28 <johnw> filter already takes a predicate function
11:23:32 <simpson> Oh, wait, wait. What do you want to filter by?
11:23:38 <mr-> what is filterBy supposed to do?
11:23:52 <skypers_> tuples
11:23:53 <skypers_> yeah
11:23:55 <skypers_> Iâ€™m stupid
11:23:57 <skypers_> I can use on
11:23:59 <skypers_> nvm
11:24:51 <pozori> I'm total newbie to Haskell. I managed to convince my professor to allow doing a mandatory free-to-choose programming project in it nevertheless so I get time to learn it. :)
11:25:01 <jle`> pozori: congratulations :)
11:25:44 <pozori> thing is, I'm kinda out of ideas. I honestly have no idea what to do with it. I could whip out some Qt application quite trivially to do thing X, but with Haskell it kinda feels so very restricted
11:26:04 <jle`> is it really open ended
11:26:18 <pozori> yup, but must be interactive with user
11:26:22 <mr-> pozori: it feels like that because you are not used to it/don't know the infrastructure that well
11:26:43 <mornfall> pozori: I had some success writing a compiler project in Haskell.
11:26:50 <mr-> pozori: if interactive animations is something you are interested in, then try gloss
11:27:08 <simpson> pozori: You should really learn a language before building things with it.
11:27:08 * pozori notes down gloss
11:27:12 <mornfall> but that's not interactive, bummer
11:27:17 <BeardedCoder> ^ http://ocharles.org.uk/blog/posts/2013-12-10-24-days-of-hackage-gloss.html
11:27:18 <mornfall> pozori: oh, check out htune ;-)
11:27:47 <mornfall> pozori: is extending existing software an option?
11:27:51 <pozori> no
11:27:58 <mornfall> that's a stupid assignment
11:28:09 <mr-> pozori: also, I have heard good things about "threepenny-gui" for simple guis
11:28:34 <pozori> opinions of Leksah for coding?
11:29:55 * mornfall never got hang of Leksah
11:29:56 <{[^-^]}> I've nevr gotten it to compile
11:30:14 <mornfall> (but then, not of any other IDE ... unless you count emacs as one)
11:31:35 <epta> Could someone please take a look? http://stackoverflow.com/questions/20618076/getting-confused-with-monadbasecontrol-errors-while-learning-conduits-in-haskell
11:31:51 <skypers_> hey, from a Behavior t a
11:32:09 <skypers_> how could I get the more recent value of such a Behavior?
11:33:48 <pozori> mornfall: nah, I'm a vim guy. wanna brawl abut it? ^_^
11:34:32 <mornfall> pozori: stick with vim then :)
11:35:03 <mornfall> I'm not particularly religious. I use vim myself fairly often.
11:35:36 <shachaf> No editor wars in here, please.
11:35:52 <benmachine> I use vim except for agda, where I use emacs
11:37:27 <skypers_> hey
11:37:37 <skypers_> I donâ€™t find any way to create events in reactive-banana!
11:42:44 <johnw> epta: I've responded
11:43:03 <skypers_> seriously
11:43:06 <johnw> also, you may wish to recurse into downloadContent
11:43:07 <skypers_> I donâ€™t get it
11:43:35 <skypers_> how with a single Functor instance can we create a value of type Event t a?
11:43:43 <skypers_> with Applicative I could use pure
11:43:48 <skypers_> but with Functor?!
11:43:53 <johnw> there is no way with functor
11:44:03 <skypers_> thereâ€™s no event function
11:44:07 <skypers_> to lift a a -> Event t a
11:44:13 <skypers_> so weird
11:44:26 <skypers_> thereâ€™s a function to build a Behavior t a
11:44:30 <skypers_> stepper for instance
11:44:38 <skypers_> a -> Event t (a -> a) -> Behavior t a
11:44:40 <skypers_> that makes sense
11:44:43 <johnw> one thing you can do, if you already have a functoral value, is: x <$ f, which will embed x in the same context as f
11:44:55 <skypers_> hm
11:45:02 <johnw> but there is no way to create a "default context", the way that pure does
11:45:14 <skypers_> I donâ€™t get it
11:45:25 <skypers_> if I want to emit the event 4
11:45:32 <skypers_> how could I do that?
11:45:39 <skypers_> emitting the event 4 at time t0
11:45:47 <skypers_> a function should be there for that, right?
11:45:48 <skypers_> like
11:45:53 <skypers_> event :: t -> a -> Event t a
11:46:04 <johnw> i have never used FRP libraries, I do not know
11:46:10 <skypers_> arf
11:46:13 <skypers_> no one knows?
11:46:14 <Feuerbach> skypers_: see the Frameworks module
11:46:28 <Feuerbach> there's no such event function, 'cause what's t0?
11:46:40 <Feuerbach> but you can trigger events through IO callbacks
11:46:41 <skypers_> ok
11:47:15 <skypers_> well, t0 is the time the event occured, right?
11:47:16 <skypers_> oh
11:47:17 <skypers_> you mean
11:47:24 <skypers_> we have to fetch the time from IO?
11:47:26 <jle`> the time from which t is measured
11:47:35 <Feuerbach> what's the type of t0?
11:47:43 <skypers_> in my framework
11:47:47 <skypers_> it could be anything
11:47:52 <skypers_> but letâ€™s state itâ€™s Float
11:47:53 <Feuerbach> reactive-banana doesn't really work with "real" time
11:48:02 <skypers_> yeah me neither
11:48:06 <skypers_> it would be a pain in the a**
11:48:14 <skypers_> letâ€™s say itâ€™s Integer
11:48:16 <Feuerbach> well, you could call the callback at your time t0
11:48:29 <Feuerbach> and trigger an event
11:48:29 <skypers_> so it still works with a callback then!
11:48:43 <Kaidelong> I take it banana is the successor to grapefruit?
11:48:53 <Feuerbach> it's a way to express primitive events
11:49:06 <Feuerbach> you can then combine them without any callbacks
11:49:18 <skypers_> h
11:49:19 <skypers_> m
11:49:28 <skypers_> so reactive-banana wonâ€™t work in pure code
11:49:35 <skypers_> it has to be run from IO
11:49:43 <Feuerbach> yes
11:49:52 <Kaidelong> oh then it is much more limited in scope than grapefruit
11:50:21 <Kaidelong> is reactive banana still a bunch of arrows?
11:50:33 <Kaidelong> that you use by using combinators from the arrow library?
11:50:51 <epta> johnw: where does `lift` come from?
11:51:27 <Hodapp> Too bad Neal Stephenson's predictions on BeOS never came to fruition.
11:51:37 <Hodapp> BeOS was pretty damn awesome.
11:51:41 <johnw> epto: Control.Monad.Trans.Class
11:53:33 <johnw> epta: do you understand why lift is needed?
11:53:37 <skypers_> I see something like I need a temporal generator
11:53:48 <skypers_> and it should be written by the user
11:54:02 <skypers_> but it would be instable thenâ€¦
11:54:04 <Hodapp> ...ignore what I said. I'm in the wrong channel.
11:54:07 * Hodapp derps away
11:55:32 <epta> johnw: actually don't
11:57:07 <epta> johnw: parseUrl :: String -> m (Request m'), and this m is finally happens to become IO
11:57:09 <johnw> epta: so, in your conduit that you've made (in this case, it's a Sink), the only "action" you can perform is await, or you can fuse with other conduits.  If, inside the sink, you want to perform an action that you would have otherwise performed in the monadic context in which you're using this sink, then lift is how you perform those actions "within the sink" so to speak
11:57:28 <johnw> epta: you could probably do liftIO instead of lift actually, but lift is more general
11:57:33 <eacameron> I am writing T.pack a lot because one library uses String and the other Text...any way to mitigate this? (I'm missing C++'s implicit constructors right now)
11:57:50 <mauke> eacameron: overloaded string literals
11:58:00 <eacameron> mauke: they aren't literals
11:58:13 <johnw> eacameron: not really
11:58:35 <johnw> eacameron: you can define a set of functions that imply pack, and then use those functions instead
11:58:47 <monochrom> make both libraries use Text
11:58:56 <jle`> submit a pull request
11:59:01 <johnw> like, if foo takes a String, write fooT = foo . pack
11:59:04 <eacameron> one is optparse-applicative ;)
11:59:09 <eacameron> it uses String
12:00:00 <eacameron> johnw: yeah...a thin wrapper, eh? not too bad
12:00:10 <augur> whats the right way to make sure IO effects happen in the right order?
12:01:02 <eacameron> monochrom: or StringLike
12:01:27 <johnw> augur: how do you mean?
12:01:57 <jle`> augur: context?
12:02:10 <augur> johnw: well, laziness leads to effect order being wonky
12:02:18 <augur> lazy IO is notoriously tricky
12:02:19 <johnw> ah, don't use lazy IO :)
12:02:50 <eacameron> is there a strict IO monad?
12:02:52 <jle`> put all of your normal main in main'
12:02:53 <epta> johnw: Ana (which is not mt btw) doesn't mentioned, but the whole problem is to deduce that m is IO in whole that context http://lpaste.net/97093
12:02:56 <jle`> then use
12:03:01 <jle`> main = main' `seq` main'
12:03:32 <johnw> epta: runResourceT $ responseBody res $$+- sinkFile sym
12:03:52 <johnw> you need to use ReosurceT with resumable sources from http
12:04:02 <augur> johnw: yeah but how!
12:04:04 <johnw> so that it knows when it can release the resources relating to the response
12:04:09 <johnw> augur: conduit!
12:04:11 <augur> jle`: lol. thats a recipe for disaster, surely
12:04:22 <simpson> augur: IIUC IO is strict by default; it's only non-strict when unsafeInterleaveIO is used.
12:04:50 <johnw> actually, I think even non-resumable sources need ResourceT in this case
12:05:22 <augur> simpson: no io is definitely NOT strict by default
12:05:30 <augur> johnw: conduit. blegh. now i have to learn conduit! :(
12:05:48 <monochrom> what's wrong with learning conduit
12:05:49 <johnw> augur: conduit borders on being trivial, ask any questions you have in #haskell-conduit
12:07:11 <augur> monochrom: that i have to do it :P
12:07:54 <epta> johnw: er? http://lpaste.net/97094
12:08:06 <augur> monochrom: haskell libraries aren't well documented, usually. learning things is more of a fight with the library than anything else
12:08:29 <johnw> epta: put the liftIO back
12:08:44 <monochrom> is that true of conduit too?
12:08:59 <johnw> conduit is also documented in the YesodBook, I believe
12:09:06 <johnw> but I've not found it lacking in documentation
12:09:19 <benmachine> IO definitely is not lazy by default
12:09:50 <benmachine> x `seq` x is always pointless
12:10:11 <benmachine> (it says, when you evaluate x, also evaluate x)
12:10:24 <epta> johnw: here you go! http://lpaste.net/97095
12:10:36 <monochrom> it is full of double-talk, even quadruple-talk, when people discuss lazy, strict, and IO together.
12:10:43 <johnw> ah
12:10:45 <joehillen> benmachine: IO isn't lazy? that doesn't sound right at all, or are you talking about some other IO
12:10:46 <johnw> sorry, my mistake
12:10:55 <augur> monochrom: dunno. im reading the page on fpcomplete at any rate
12:11:00 <benmachine> joehillen: well, what I mean is, the vast majority of IO is not driven by evaluation
12:11:12 <johnw> epta: https://gist.github.com/7993337
12:11:24 <johnw> you may need a liftIO yet again in front of parseUrl
12:11:26 <benmachine> well
12:11:30 <benmachine> maybe that's an exaggeration
12:11:40 <benmachine> things like readFile and getContents are very often used
12:11:42 <benmachine> and they are lazy
12:11:47 <benmachine> lazy-IO lazy that is
12:11:54 <skypers_> woh
12:12:00 <skypers_> I feel terribly stupid but hm
12:12:04 <benmachine> but most IO, like getLine, putStrLn, writeFile, etc. are not lazy
12:12:10 <skypers_> how is return implemented for State?
12:12:19 <monochrom> firstly, lazy vs strict is already wrong. but ok, I can take it to mean lazy vs eager. that is not the worst problem.
12:12:20 <jle`> skypers_: const a i think?
12:12:20 <benmachine> skypers_: do you know the definition of State?
12:12:27 <notdan> skypers_: \s -> (a, s_
12:12:35 <skypers_> oh sure
12:12:37 <pavonia> @src return State
12:12:37 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:12:46 <notdan> rudebot
12:12:47 <skypers_> Iâ€™m just having issue with my Monad version of a newtype
12:12:49 <joelteon> @src (->) return
12:12:49 <lambdabot> return = const
12:12:51 <skypers_> I think itâ€™s impossible
12:12:51 <dwcook> Sometimes lambdabot is the rudest one in here.
12:12:57 <joelteon> @src State return
12:12:57 <lambdabot> Source not found. Take a stress pill and think things over.
12:13:03 <skypers_> it would be like make (a,b) a Monad instance
12:13:05 <monochrom> and then, IO effect order is yet different from value evaluation order.
12:13:23 <benmachine> skypers_: if you have the type of return for State, you cannot implement it incorrectly
12:13:28 <joehillen> monochrom: you've got it right, I have no idea what benmachine is talking about
12:13:32 <skypers_> yes benmachine
12:13:34 <benmachine> as long as you avoid stupid things
12:13:52 <benmachine> joehillen: I don't disagree with monochrom, if that helps
12:13:53 <monochrom> oh, they interact, sure. but they are two things that interact, not one single thing
12:15:04 <monochrom> lastly and most confusingly, there is value evaluation of an IO action value too.
12:15:55 <joehillen> that makes perfect sense.. if you already know that
12:16:46 <smith_> If I have a function in IO that returns SomeValue and can generate SomeError, is it better to have it as :: IO (Either SomeError SomeValue), or as :: IO  SomeValue and use throwIO to throw SomeError as an exception?
12:18:56 <monochrom> "IO is strict" could refer to any of: strict in an IO action value, eager in an IO action value, eager in an IO effect, strict in an IO effect.
12:19:05 <evancz> When using aeson, is it possible to get all fields of an object in the order they appear?
12:19:26 <simpson> evancz: I thought that the order was arbitrary?
12:19:39 <johnw> evancz: I bet lens-aeson could do that
12:19:40 <evancz> simpson: like in the spec it doesn't matter?
12:19:50 <simpson> evancz: Yes.
12:19:58 <evancz> johnw: I don't want extra dependencies right now :)
12:20:11 <edwardk> johnw: actually aeson generally screws up order
12:20:16 <johnw> ah, ok
12:20:30 <evancz> simpson: I have a file that humans will read, so it'd be good to keep the order they put in there
12:20:31 <edwardk> johnw: so by the time lens-aeson sees it it is too late
12:20:54 <evancz> okay, perhaps the other json library then?
12:20:58 <evancz> I'll take a look
12:21:18 <augur> also, anyone know if its possible to call compiled haskell from C?
12:21:31 <simpson> I'd be wary of any library that actually encourages this. You should just always sort your keys when writing back out.
12:21:34 <simpson> augur: Yes.
12:21:51 <evancz> looks like it works fine there
12:22:04 <evancz> simpson: I don't think that's true
12:22:09 <augur> simpson: would you might appeasing grice and expanding on that? XP
12:22:11 <epta> johnw: in original gist https://gist.github.com/anonymous/7991727#file-gistfile1-hs-L39 there is another function with similar problem, so yield looks kinda confusing there
12:22:40 <Kaidelong> has anyone worked on haskell libraries that generate metro programs?
12:22:45 <evancz> imagine modifying https://npmjs.org/doc/json.html with a program
12:22:50 <Kaidelong> (html+javascript windows applications)
12:22:51 <simpson> augur: Oh, I meant yes to your implied followup question of "So, *is* it possible?" Lemme find a link.
12:22:53 <evancz> in any case, thanks for the help
12:22:59 <evancz> later folks!
12:23:22 <Kaidelong> how difficult would it be to adapt something like Yesod for windows dev?
12:23:26 <simpson> augur: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
12:24:04 <augur> also also, whats a sensible way to handle state that has to lurk behind some IO stuff?
12:25:02 <augur> that is to say, im building something thats going to have a shell-like interface, and it needs to carry some state along with it that persists between IO interactions
12:25:32 <jle`> between executions?
12:25:41 <jle`> or within the same program execution
12:26:08 * monochrom decides to not update haskellwiki
12:26:23 <augur> i suppose i could try to wedge it into a State-on-top-of-IO thing, but im not sure if thats conventional
12:26:23 <augur> simpson: thank you :)
12:26:27 <smith_> Within the same execution you could use StateT.
12:26:57 <jle`> StateT might be overkill; if you are doing a simple recursive loop you can just pass the state in as a parameter
12:27:02 <augur> jle`: within the same program execution
12:27:42 <jle`> although if you want to be able to modify the state more than once or access it in sub functions then yeah StateT
12:27:55 <jle`> at that point the plumbing gets tedious
12:28:37 <augur> i mean, i probably dont need to do this at all, since in the long run i think im going to have to rewrite this in some C-like language anyway, but its good practice to do this in haskell i feel :x
12:28:37 <augur> jle`: thats my instinct
12:29:12 <smith_> https://hackage.haskell.org/package/mtl-1.1.0.2/docs/Control-Monad-State-Lazy.html#2 has an example for wrapping StateT around IO, if you go that route.
12:30:01 <augur> jle`: indeed
12:30:01 <augur> well, we'll see i guess
12:30:15 <jle`> main benefit of StateT is to compose StateT functions that modify state and return a result; you'd otherwise have to return tuples in all your functions. but if you never compose any funconis, or your functions never return any result other than the modified state, or if your state is not modified, then it won't benefit you too much
12:30:29 <jle`> *modified by sub-functions
12:30:43 <jle`> but i just named off a long list of restrictions, so it is likely that it will be useful to you
12:37:01 <Clint> how do i understand why i can't generalized-newtype-derive MonadTrans?
12:45:31 <monochrom> I understand it as: generalized newtype deriving can only one one straightforward thing, MonadTrans is not straightforward
12:47:08 <Clint> monochrom: hmm, why not?
12:47:22 <lightquake> what's the current standard command line option parsing program?
12:48:26 <lightquake> er, library
12:49:35 <Taneb> lightquake, optparse-applicative is pretty cool
13:08:35 <duairc> Is there any way to reify the type of an expression using template haskell? Basically, is there a function like a -> Q Type, which takes an arbitrary expression of type a?
13:12:20 <Museifu> Hi
13:14:27 <jle`> hi Museifu
13:15:07 <tommd> duairc: Are you looking for a quasiquoter?  [t| Int -> Int |]
13:16:42 <duairc> tommd: I might be. I don't know much about quasiquotation.
13:17:02 <statusfailed> Is it bad to use GeneralizedNewtypeDeriving in library code?
13:17:18 <statusfailed> (for use with Monad Transformers)
13:17:27 <statusfailed> I can't convince myself it'd ever do anything evil
13:18:35 <statusfailed> maybe if the order of the stack matters, and you don't think about it? hm
13:20:21 <tommd> duairc: If you want the type of a named thing (in-scope variable of function) then 'reify' can give you that.  If you want the TH expression for a particular type then quasi-quoting can help.
13:20:44 <tommd> If, however, you want the type of an arbitrary expression (vs just an Id that is in scope) then I think you are out of luck.
13:22:38 <ocharles> Erm, does anyone know how to save stuff to images from repa?
13:22:49 <ocharles> I'm using JuicyPixels-repa to load images, but it doesn't seem to have write routines
13:22:53 <ocharles> should I use repa-devil?
13:23:24 <acowley> I've not used JuicyPixels-repa, but JuicyPixels itself makes saving images from Vector pixel data pretty easy
13:23:44 <acowley> So assuming you can get a Vector from your repa array, I think you'd be set with just JuicyPixels
13:24:03 <ocharles> Can you turn three-dimensional repa arrays into vectors?
13:24:19 <duairc> tommd: I definitely want the type of an arbitrary expression rather than an Id that is in scope. Damn it.
13:24:35 <ocharles> 'toVector' looks like it might do the trick
13:25:02 <Peaker_> JuicyPixels is in pure Haskell for ease of portability within Haskell programs, right?
13:25:26 <Peaker_> Given C's portability and cabal's ability to embed&compile C code within Haskell packages, it sounds like integrating existing C image codecs could work just as well?
13:25:57 <acowley> ?hackage DevIL
13:25:57 <lambdabot> http://hackage.haskell.org/package/DevIL
13:26:04 <acowley> err, that's not right
13:26:09 <acowley> http://hackage.haskell.org/package/Codec-Image-DevIL
13:26:16 <acowley> That's the one that's just bindings
13:26:16 <lispy> Peaker_: Then you have to bundle the C with your cabal package lest getting the C library on your machine become the hard part
13:26:42 <tommd> duairc: Perhaps hint can help some?   http://hackage.haskell.org/package/hint-0.3.3.7/docs/Language-Haskell-Interpreter.html#v:typeOf
13:26:46 <Peaker_> lispy: yeah, that's what I meant by the embed part
13:27:08 <Peaker> lispy: since C codecs already existed, I wonder if it wasn't easier to do that.. Probably more fun for the author to write JuicyPIxels :)
13:27:26 <acowley> I used to use the DevIL bindings but switched to Juicy as it has a better Haskell-side API
13:27:32 <lispy> possibly. The author has done a really good job. Solid support and all that.
13:27:45 <tommd> If anyone wants to add encoding/writing operations for JP-Repa I'd be happy to merge them in.
13:27:51 <lispy> He accepts all my pull requests right away :)
13:27:54 <jrmithdobbs> is there a more convenient operator i'm missing for (<*> const) ?
13:27:55 <tommd> It should just be a lifting of the functionallity already in JP.
13:28:00 <ReinH> acowley: hai
13:28:01 <joelteon> :t (<*> const)
13:28:02 <lambdabot> (a -> (b1 -> a) -> b) -> a -> b
13:28:07 <ReinH> acowley: so you prefer juicy to devil?
13:28:10 <acowley> It's probably worth someone's time to put a Vector-based API with nice types on the DevIL bindings just so it's an option
13:28:18 <duairc> tommd: Yeah, I was thinking I'd have to use something like hint, but that feels like overkill for what I'm doing, so I'll see if I can find another way of doing it.
13:28:23 <acowley> ReinH: It's not something I put a lot of thought in to, tbh
13:28:28 <ReinH> ok :)
13:28:42 <acowley> ReinH: But I've been very happy with JuicyPixels since its release
13:28:54 <acowley> ReinH: also, hai
13:29:22 <acowley> I have had problems where Juicy couldn't load some image files I had, while other things could
13:29:28 <acowley> but I don't remember the details.
13:29:37 <lispy> acowley: that might be fixed now.
13:29:47 <lispy> acowley: I know there have been several fixes for edge cases
13:30:04 <acowley> lispy: that would be great
13:30:21 <acowley> my "fix" was to just use convert until I hit a format that worked :/
13:30:29 <Iceland_jack> @ty fix
13:30:30 <lambdabot> (a -> a) -> a
13:31:01 <tac> @ty fix fix
13:31:02 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> a0
13:31:02 <lambdabot>     Expected type: (a0 -> a0) -> a0 -> a0
13:31:02 <lambdabot>       Actual type: (a0 -> a0) -> a0
13:31:05 <tac> @ty fix . fix
13:31:06 <lambdabot> ((c -> c) -> c -> c) -> c
13:32:18 <tac> > (fix . fix) (\g x -> if x == 0 then 0 else x-1)
13:32:22 <lambdabot>  mueval-core: Time limit exceeded
13:35:25 <ReinH> acowley: heh "fix".
13:35:29 <ReinH> well played
13:36:39 <Cale> > fix error
13:36:41 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
13:37:09 * Hodapp glares at Cale
13:37:11 <tac> That didn't fix much at all.
13:38:03 <Cale> Maybe in the sense of "I'll fix you good!"
13:38:33 <Fylwind> is there a way to search the docs on hackage?  i couldn't get anything from hoogle
13:39:09 <danharaj> hayoo
13:46:04 <ReinH> Cale: yo dawg I heard you like errors and such
13:54:14 <acowley> Is anyone working on a cabal thing that would hash dependencies with installed packages to serve as a sandbox cache?
13:58:17 <jle`> i am surprised that fix error produces output
13:58:32 <jle`> i guess exceptions print their contents lazily...?
13:58:39 <statusfailed> That is awesome
13:59:02 <kylcarte> is there any way in ghci to check whether a type has a valid instance of a class?
13:59:09 <dwcook> jle`, error knows that "*Exception: " must go at the beginning without even knowing what the actual content was
13:59:21 <statusfailed> kylcarte: you can do :i MyType which usually gives a list of instances
13:59:33 <statusfailed> not exactly what you want though
13:59:52 <dwcook> jle`, it's just like if you produced an infinite list and tried to print it (in fact, I'm pretty sure it's the same thing)
14:00:03 <kylcarte> statusfailed: except when you have inferred instances through something like FlexibleInstances, MultiParamTypeClasses, etc.
14:00:19 <statusfailed> ah ok, no help from me then :)
14:00:22 <statusfailed> sorry
14:00:29 <kylcarte> statusfailed: thanks, though :)
14:00:47 <jle`> dwcook: so Haskell's io does not evaluate the exception contents before beginning to print it
14:00:57 <jle`> that makes sense, it does that for lists too
14:02:00 <dwcook> jle`, well you don't need the entire list/string to start printing it. You just need the next character, and the next, â€¦
14:02:13 <dwcook> It does evaluate it though
14:02:13 <kylcarte> such a feature would be a big help, I think.
14:02:44 <dwcook> It just does it alongside printing it
14:04:40 <bitemyapp> this channel is worth it just for the abuses of fix.
14:05:04 <ocharles> "Exception: Prelude.(!!): negative index" FUUUU
14:05:23 <Kron> ocharles: this is why we need naturals D:
14:05:49 <jle`> there is already hardware-implemented naturals anyway
14:05:54 <jle`> why can't we use them T.T
14:06:09 <Kron> because we can't have nice things
14:06:21 <dwcook> Kron, and why can't we have nice things?
14:06:30 <dwcook> I mean, we do have Haskell. That's a pretty nice thing.
14:06:30 <Kron> because we don't have dependent types
14:06:35 <ocharles> this JuicyPixels-repa library doesn't seem to work very well :(
14:06:47 <Kron> there's no way to check at compile time that our functions don't generate negative values
14:06:49 <lightquake> anybody here experienced with Cabal-the-library? i want to write a program that needs to know the package DBs and ghc options for a possibly sandboxed package
14:06:50 <dwcook> I don't think you'd need dependent types to take advantage of naturals more than Haskell already does.
14:07:00 <dwcook> You'd need to redesign some typeclasses and language semantics though.
14:07:01 <ocharles> I can load an image fine, but the moment I ask for the repa extent I get the above error :/
14:07:02 <Kron> and newtype Natural = Int or whatever only lets us runtime check
14:07:16 <jle`> Kron: well you can just separate out the typeclasses and have (-) be a Integral-only function
14:07:16 <Kron> dwcook: well okay, we can't have nicer things
14:07:28 <moop> hi everyone, so i'm slowly progressing through the 'learn you a haskell for great good' and i'm really enjoying everything, but there's one thing i don't understand
14:07:33 <Kron> jle`: that's true I guess
14:07:38 <joelteon> functionally balancing binary trees is quite the task
14:07:40 <jle`> Natural provides (+), Integral provides (-)
14:07:56 <acowley> ocharles: What are you aiming to do?
14:07:57 <jle`> just like in maths :)
14:08:09 <ocharles> acowley: I just want to blend two images together, basically
14:08:19 <ocharles> But I can't even write an identity program
14:08:27 <Hodapp> moop: go on...
14:08:28 <Kron> what about non integrals that can still subtract
14:08:28 <acowley> ocharles: Is this to exercise repa or because you want blend images?
14:08:39 <acowley> err "want to blend"
14:08:46 <moop> '-> is right associative by default. (a -> b -> c) -> (b -> a -> c) is the same as (a -> b -> c) -> (b -> (a -> c)), which is the same as (a -> b -> c) -> b -> a -> c.'
14:08:49 <ocharles> the former
14:08:59 <moop> so all the examles so far had
14:09:16 <jle`> ocharles: have you flipped trhough the marlow chapter on repa
14:09:19 <Kron> moop: are you a lisper? :D
14:09:27 <cwraith> :t flip
14:09:28 <lambdabot> (a -> b -> c) -> b -> a -> c
14:09:48 <Kron> oh wait I see you're using ' as a way to demarcate a string
14:09:59 <Kron> for a moment I thought you were instinctively quoting out a symbol ;_;
14:10:00 <ocharles> yes, but I don't think this is my fault. Just doing "readImage "ocharles.jpg" >>= \(Right img) -> print (extent (imgData img))" is enough to cause an error
14:10:04 <moop> Kron: i'm trying to understand, so all the function calls are done with the curry on the right?
14:10:10 <ocharles> that's JuicyPixels-repa, imo - not me
14:10:14 <Kron> yes
14:10:24 <mauke> moop: this has nothing to do with calling functions or currying per se
14:10:31 <mauke> it's just a notational convention
14:10:40 <Kron> moop: it is the deep dark secret of languages like haskell and ocaml that all functions simply take one argument and return one result
14:10:41 <nisstyre> Kron: your brain ran out of memory to store the entire string and thus forgot that it was enclosed by balanced ' marks
14:10:44 <moop> e.x. (((func a) b) c) is actually (func a (b c))
14:10:50 <ocharles> hmmm, it works with a different image
14:10:50 <Kron> well it kind of does have to do with currying
14:10:50 <ocharles> that's odd
14:10:53 <mauke> moop: no, it's not
14:10:57 <Kron> and I just came back from an exam on C
14:11:03 <ocharles> Doh, I had a type annotation saying ocharles.jpg was RGBA, but it's just RGB
14:11:04 <mauke> moop: and that has nothing to do with how -> works in types
14:11:05 <ocharles> that's nasty :/
14:11:17 <jle`> ocharles: :|
14:11:19 <nisstyre> Kron: did they ask you to look for undefined behaviour?
14:11:20 <Kron> moop that's not quite true
14:11:29 <mauke> moop: (a b c d) is the same as (((a b) c) d) but that's not the same as (a b (c d))
14:11:33 <Kron> (((func a) b) c) is (func a (b c)), we can'ta pply b to c
14:11:38 <Kron> *isn't
14:11:38 <acowley> ocharles: In my HOpenCV fork I try to convert to the desired format based on the type when loading
14:11:50 <moop> so why is (a -> b -> c) -> (b -> a -> c) is the same as (a -> b -> c) -> (b -> (a -> c)) ?
14:11:53 <acowley> ocharles: I think we'll get similar functionality in the new OpenCV stuff
14:11:57 <jle`> -> is right associative but function application is left associative
14:12:12 <moop> in the example of flip
14:12:13 <mauke> moop: because -> is right associative, meaning X -> Y -> Z is parsed as (X -> (Y -> Z))
14:12:41 <mauke> moop: well, (b -> a -> c) ==> (b -> (a -> c)) to use the names from the example
14:12:42 <Kron> (a -> b -> c) -> (b -> a -> c) is in reality (a -> (b -> c)) -> (b -> (a -> c))
14:13:12 <moop> so how does that fit with currying
14:13:12 <jle`> func a b c is really (((func a) b) c), but a -> b -> c, the type signature, is (a -> (b -> c))
14:13:23 <mauke> moop: it doesn't
14:13:29 <Kron> because you can think of a function in various ways
14:13:33 <moop> shit's hard man :X
14:13:36 <Kron> mauke: it's fundamentally about currying
14:13:39 <Kron> I'll give you an example
14:13:42 <mauke> Kron: not really
14:13:46 <Kron> (+) :: Int -> Int -> Int
14:13:47 <mauke> it's all quite simple and pointless
14:13:53 <Kron> in reality it's not Int, it's a Num a, but we'll pretend it's an Int
14:13:54 <jle`> i don't think it has anything to do with currying, it is just syntax convention
14:13:56 <mauke> there's no substance or hidden meaning
14:14:07 <jle`> you could have currying without right-associative or left-associatinve types/function calls
14:14:10 <c_wraith> Eh.  It's to make currying easy syntactically simple.  But it's not a part of currying.
14:14:12 <mauke> jle`: right
14:14:15 <jle`> it's just a little easier to write
14:14:17 <Kron> you can read that as "Takes two int inputs, returns one int output"
14:14:23 <c_wraith> easy *and* syntactically simple
14:14:24 <Kron> or you can read it as Int -> (Int -> Int)
14:14:37 <Kron> which is "Take one int input, returns a function that takes one int input and returns one int output"
14:14:43 <Kron> (+) 3 is a valid function
14:14:49 <mauke> Kron: I can read Int -> (Int -> Int) as "takes two int inputs, returns one int output"
14:14:52 <mauke> Kron: what now?
14:17:00 <moop> Kron: ok i think i understand now with your example
14:17:18 <Kron> moop: it's how I learned about currying in haskell, basically
14:17:28 <jle`> @let plusThree = (+) 3
14:17:29 <lambdabot>  Defined.
14:17:33 <jle`> > plusThee 2
14:17:34 <lambdabot>  Not in scope: `plusThee'
14:17:34 <lambdabot>  Perhaps you meant `plusThree' (line 160)
14:17:38 <Kron> > plustThree 3
14:17:39 <jle`> > plusThree 2
14:17:40 <lambdabot>  Not in scope: `plustThree'
14:17:40 <lambdabot>  Perhaps you meant `plusThree' (line 160)
14:17:40 <lambdabot>  can't find file: L.hs
14:17:41 <Kron> lol
14:17:59 <jle`> where did you go lambdabot
14:18:05 <Kron> > ((+) 3) 2
14:18:06 <lambdabot>  5
14:18:08 <Kron> there
14:18:10 <jle`> > plusThree 2
14:18:12 <lambdabot>  5
14:18:44 <Kron> moop: basically if you read the A -> B -> C -> ... -> Z format as "take inputs A, B, C... return Z"
14:18:57 <Kron> then you can use the right associativity to instantly see every way it can be curried
14:19:05 <mauke> :t flip id
14:19:06 <lambdabot> b -> (b -> c) -> c
14:19:44 <moop> Kron: yep
14:20:02 <moop> so it just shows what function is returned on each call
14:20:06 <moop> yip yip yip
14:20:10 <Kron> yes, basically!
14:20:15 <moop> cool, ty
14:20:21 <Kron> each function basically absorbs the first thing and returns the rest
14:20:26 <Kron> in general, all functions are like this:
14:20:31 <Kron> allFunctions :: a -> b
14:20:40 <Kron> functions with higher arity simply have extra functions in b
14:20:49 <jle`> you can also think of it as it 'partially' applies the function.  when you say (+) 3, it's "waiting" for the second number
14:20:56 <Kron> that's the true difference between a simple value and a function
14:21:04 <Kron> yeah the waiting analogy is a great one
14:21:17 <Kron> I find the waiting analogy starts to fall apart with maps and stuff, but it's brilliant to begin with
14:21:21 <psc_> Isnt this called currying ?
14:21:33 <Kron> it is
14:22:21 <moop> ok, thanks guys
14:22:37 * hackagebot HaRe 0.7.0.8 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.0.8 (AlanZimmerman)
14:22:51 <c_wraith> wait, HaRe is still maintained?
14:22:56 <c_wraith> That's cool
14:23:15 <kinslayer> Hmm I am really not understanding how I can take json and spit out a custom datatype...
14:23:39 <jle`> kinslayer: do you already know how to parse json into an Aeson data structure?
14:23:57 <kinslayer> into a Aeson well not really..
14:24:06 <jle`> what are you using?
14:24:21 <kinslayer> Well trying to use Aeson
14:27:39 <jle`> is the json from an outside source?
14:27:52 <kinslayer> Yes I download it from the what
14:27:59 <kinslayer> from the web*
14:28:05 <jle`> if you are serializing and deserializing your own data structures then there is some TH magic you can do
14:28:08 <jle`> ah
14:28:23 <jle`> > decode "[1,2,3]" :: Maybe Value
14:28:24 <lambdabot>  Not in scope: type constructor or class `Value'Not in scope: `decode'
14:28:31 <jle`> > Data.Aeson.decode "[1,2,3]" :: Maybe Value
14:28:32 <lambdabot>  Not in scope: type constructor or class `Value'Not in scope: `Data.Aeson.dec...
14:28:58 <jle`> anyways the thing you are "supposed" to do is define a FromJSON instance for your datatype
14:29:01 <kinslayer> Okay I might give that a try
14:29:01 <jle`> http://hackage.haskell.org/package/aeson-0.6.1.0/docs/Data-Aeson.html#t:FromJSON
14:29:15 <jle`> but if you are just starting out
14:29:18 <jle`> you can do a naive approach
14:29:27 <kinslayer> I like that
14:29:29 <jle`> and just play around in GHCI with decode "your json" :: Maybe Value
14:29:37 <jle`> and look at the datastructure that it returns
14:29:57 <kinslayer> I am playing in ghci
14:30:44 <jle`> how familiar are you with recursive data types/trees?
14:30:45 <kinslayer> well it complains about being in the IO
14:30:55 <jle`> kinslayer: what are you typing?
14:30:58 <kinslayer> well I know the definition
14:31:19 <kinslayer> getCex >>= (\j -> Data.Aeson.decode j::Maybe Value) (getCex is what downloads a lot of json)
14:31:20 <jle`> remember you can only decode a string
14:31:31 <kinslayer> so I should unpack ?
14:31:51 <jle`> actually you can decode non-strings too
14:31:57 <jle`> what i meant was you can't decode things inside IO
14:32:11 <jle`> okay, do something like
14:32:13 <kinslayer> well it expects a ByteString
14:32:25 <jle`> yeah heh. sorry. you should be using a ByteString
14:32:30 <jle`> i turn on OverloadedStrings so I didn't even notice
14:32:38 <jle`> do something like j <- getCex
14:32:46 <jle`> and type :t j and tell me what you see
14:33:16 <kinslayer> IO ByteString
14:33:33 <kinslayer> well L.ByteString (Lazy ByteString)
14:35:01 <jle`> decode j :: Maybe Value should work then
14:35:12 <kinslayer> import qualified Data.ByteString.Lazy.Char8 as L
14:35:29 <kinslayer> and then it says IO L.ByteString
14:35:46 <jle`> what is :t getCex ?
14:36:30 <kinslayer> Well j was L.ByteString and getCex is IO L.ByteString sorry
14:36:54 <jle`> so does decode j :: Maybe Value work?
14:37:57 <kinslayer> Hey yes :D
14:38:15 <jle`> mk
14:38:38 <kinslayer> hmm however I can't turn into my own data structure...
14:38:41 <jle`> and you know how to get values outside of Just's and Array's and Object's, right?
14:39:01 <alanz> c_wraith: I am busy with a port of HaRe to make use of the GHC API. Making good progress
14:39:10 <kinslayer> Well I know about fromMaybe but not about the other things
14:39:27 <c_wraith> alanz: excellent
14:39:43 <jle`> kinslayer: so what you should do is write a convert function
14:39:49 <jle`> convert :: Value -> YourDataType
14:39:59 <danilo2> Hello :) I've got a design question :) I want to create some operations, which return Either MyError Result. I want to ask you, if MyError should be a datatype or existential datatype? The problem is, that I want to create custom MyError type, but I will use some libraries (like Codec.BMP), which've got custom Error Datatypes.
14:40:13 <kinslayer> I don't know about taking out of Array and Object
14:40:26 <danilo2> So I should pack them in my structure, or should I use existential datatypes (to create something like Exceptions) ?
14:41:39 <jle`> kinslayer: arrays -- http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector.html#t:Vector
14:41:46 <jle`> objects -- http://hackage.haskell.org/packages/archive/unordered-containers/0.2.3.0/doc/html/Data-HashMap-Strict.html#t:HashMap
14:41:50 <kinslayer> Okay
14:41:58 <jle`> so your function convert
14:42:06 <kinslayer> yes..
14:42:06 <jle`> it should have three patterns to match
14:42:37 <jle`> convert (Array v) = ...
14:42:41 <jle`> convert (Object v) = ...
14:43:04 <heatsink> What will you do with errors?
14:43:13 <kinslayer> so I should try to think a bit about the thing I want to write
14:43:45 <jle`> kinslayer: yes, think about what you want to return when you have an array
14:43:50 <jle`> and what you want to return when you have an object
14:44:32 <jle`> and you will probably end up either recursing or having multiple layers of convert-like functions
14:51:46 <kinslayer> well I can't make it work when I am doing it from inside the program it only works inside the ghci
14:52:23 <joelteon> What's the class that provides only the mempty-ish memberc
14:52:25 <joelteon> member
14:52:41 * hackagebot language-c-quote 0.7.6 - C/CUDA/OpenCL/Objective-C quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.7.6 (GeoffreyMainland)
14:52:43 * hackagebot scientific 0.1.0.1 - Arbitrary-precision floating-point numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.1.0.1 (BasVanDijk)
14:52:45 * hackagebot mainland-pretty 0.2.7 - Pretty printing designed for printing source code.  http://hackage.haskell.org/package/mainland-pretty-0.2.7 (GeoffreyMainland)
14:52:49 <heatsink> Pointed?
14:53:02 <joelteon> No, that's pure
14:54:10 <mm_freak> joelteon: what semantics would mempty have without mappend?
14:54:25 <joelteon> oh, you know what
14:54:26 <heatsink> Since mempty is the neutral element of mappend, wouldn't you need to have both defined?
14:54:31 <joelteon> I was thinking of semigroup, which only has mappend
14:54:34 <joelteon> lol
14:54:58 <arkeet> joelteon: Default?
14:55:07 <mm_freak> there is the Default class, but it's not really well-founded
14:55:16 * arkeet still thinks it sucks that that got split up into multiple packages
14:57:33 <danilo2> What error reporting mechanism should I use in a "pure" library? I want to return several custom errors (from my custom datatype) and I want to return some errors from other libraries, like: Codec.BMP.Error? Should I use Either a b with a datatype "packing" these foreign errors or maybe some other mechnisms?
14:57:59 <joejev> I like the whole Either MyError MyResultType
14:58:11 <joejev> it forces people to deal with any error in a safe way
14:58:47 <mm_freak> joejev: well, it doesn't really force
14:59:04 <mm_freak> :t let fromRight ~(Right x) = x in fromRight
14:59:05 <lambdabot> Either t t1 -> t1
14:59:09 <danilo2> joejev: I like it too, but what If I use several libraries and EACH of them declares other "MyError" and I want to pass these errors to user? I have to "incorporate" them inside my datatype - there is not better way ?
14:59:30 <mm_freak> joejev: but yeah, it's still much safer =)
14:59:49 <heatsink> I think you should just use a sum type for all the errors
15:00:21 <joejev> mm_freak: i have stuff like that floating around the internals of libs, but I would hope not to see that when it isn't already checked it is safe to do so
15:01:13 <bitonic> mm_freak: isn't Default simply a pointed set?  that seems pretty well founded
15:01:29 <joejev> is it faster to have charToWord :: Char -> Word32; charToWord = toEnum . fromEnum, or charToWord = unsafeCoerce
15:01:42 <bitonic> maybe the provided instances aren't
15:01:44 <danilo2> heatsink: "a sum type" - that is the sentence I was looking for asking this question. Ok, I'll do it this way. Nobody uses Exceptions in pure code btw? (http://www.haskell.org/haskellwiki/Existential_type#SomeException)
15:01:59 <cizra> Feuerbach: Nope, didn't help.
15:02:05 <jle`> kinslayer: can you lpaste anything
15:02:45 <kinslayer> the whole code block ?
15:02:46 <heatsink> As I understand it, Exception subtyping is done that way because throw/catch can send exceptions across module boundaries
15:02:57 <heatsink> So a piece of code can catch exceptions it doesn't know about
15:03:21 <jle`> kinslayer: er, just like the data type dfinition and where you are trying to convert/your convert function
15:03:23 <jle`> relevant things
15:03:32 <heatsink> In your case, you know what kind of exceptions your library could throw
15:03:35 <heatsink> or return
15:03:51 <heatsink> so existentials aren't necessary
15:04:22 <kinslayer> data BitcoinData =
15:04:22 <kinslayer>     BitcoinData {
15:04:23 <kinslayer>       timestamp :: Int ,
15:04:23 <kinslayer>       low :: Double ,
15:04:24 <kinslayer>       high :: Double ,
15:04:24 <kinslayer>       last :: Double ,
15:04:25 <kinslayer>       volume :: Double ,
15:04:25 <kinslayer>       bid :: Double ,
15:04:26 <kinslayer>       ask :: Double } deriving (Show)
15:04:26 <kinslayer> instance FromJSON BitcoinData where
15:04:27 <kinslayer>     parseJSON (Object v) = BitcoinData <$>
15:04:27 <kinslayer>                            v .: "timestamp" <*>
15:04:28 <kinslayer>                            v .: "low" <*>
15:04:28 <kinslayer>                            v .: "high" <*>
15:04:29 <kinslayer>                            v .: "last" <*>
15:04:29 <kinslayer>                            v .: "volume" <*>
15:04:30 <kinslayer>                            v .: "bid" <*>
15:04:30 <kinslayer>                            v .: "ask"
15:04:35 <jle`> kinslayer: lpaste/pastebin please
15:04:43 <heatsink> @where lpaste
15:04:43 <lambdabot> http://lpaste.net/new/haskell
15:04:48 <kinslayer> Yes better
15:05:05 <danilo2> heatsink: you are completely right. I was just a little confused by many different methods libraries are using. Thank you :)
15:05:39 <jle`> kinslayer: you need to decode with "decode j :: Maybe BitcoinData" of course
15:05:39 <kinslayer> http://lpaste.net/97097
15:05:51 <jle`> i assuem you're already doing so?
15:06:04 <kinslayer> That doesn't seem to work when I am inside of the program, only in GHCI
15:06:38 <jle`> where are you decoding?
15:09:23 <kinslayer> Okay now I just to make the last thing an expression
15:09:35 <kinslayer> it is some json from a commodity exchange...
15:09:51 <jle`> where is your call to `decode`, i mean
15:10:03 <kinslayer> oh inside of a function
15:10:14 <jle`> what is your error?
15:10:22 <jle`> remember that decode will return a Maybe BitcoinDta
15:10:28 <jle`> and not a BitcoinData
15:10:39 <kinslayer> Oh yes so I can't print directly
15:10:45 <jle`> ?
15:11:59 <kinslayer> http://lpaste.net/97098 I was doing it here
15:12:40 <kinslayer> that should however be fine, Now I just need to find a way to do some work with the data
15:13:27 <jle`> hm. what si your problem then?
15:13:40 <kinslayer> well right now I don'
15:13:42 <joejev> so, when should I use unsafe coerce, it looks like it is slower than toEnum for chars, is there a use for it or is it just for lower level stuff
15:14:05 <kinslayer> I don't think there is a problem right now, just more work, however the conversion seems a little tricky..
15:14:50 <jle`> hm okay.
15:15:14 <jle`> in a real program you can probably omit the type annotation
15:15:19 <jle`> becuase it can probably be inferred from somewhere else
15:15:35 <jle`> oh, in your lpaste snippet
15:15:39 <jle`> i don't think it'd work
15:15:49 <kinslayer> why not ?
15:15:55 <jle`> what monad are you in?
15:16:00 <jle`> IO?
15:16:05 <jle`> or Maybe?
15:16:06 <kinslayer> I would think so
15:16:14 <jle`> then you should say let un = decode j
15:16:21 <kinslayer> Well that is a great question...
15:16:29 <jle`> "un <- " means "bind the result of the IO computation"
15:16:42 <kinslayer> yeah but that somehow worked...
15:16:52 <kinslayer> so I should be in IO not Maybe
15:17:00 <skypers_> hey, what does it do to use StateT e IO and forkIO?
15:17:05 <jle`> yes you have to be in one or the other
15:17:14 <kinslayer> well shouldn't = be in a let ?
15:17:45 <kinslayer> well let un = decode j works
15:18:10 <jle`> yeah, that should work
15:18:16 <jle`> it means that you are defining un to be the result of decode j
15:18:27 <jle`> un <- means that you are defining un to be the result of the given IO computation
15:18:28 <kinslayer> well calling djson returns a pretty Nothin
15:18:32 <kinslayer> well calling djson returns a pretty Nothing*
15:19:13 <jle`> test out your decode with some sample data
15:21:00 <jle`> on ghci
15:21:48 <kinslayer> shouldn't  I put it into Value and then write some conversion to my datatype ?
15:22:57 <jle`> what you did was define a way to go straight from a json ByteString to your datatype
15:23:10 <kinslayer> which seems to not work
15:23:24 <kinslayer> I wonder why....
15:23:37 <jle`> did you test it with a sample json string?
15:23:58 <kinslayer> well it is a bit complex since I need to fill out all the fields..
15:25:10 <jle`> "{\"timestamp\": 10, \"low\": 1.0 ....etc.
15:25:26 <jle`> or you could even get a sample one with j <- getCex
15:26:36 <kinslayer> yeah, a lot to type
15:27:08 <kinslayer> well j is not a good sample since it parse to Nothing
15:27:29 <jle`> print out j, is it valid?
15:29:00 <kinslayer> http://lpaste.net/97100
15:29:04 <kinslayer> that is my data
15:29:21 <kinslayer> well at least that is a sample
15:29:47 <skypers_> why TVar is called that way?
15:29:55 <skypers_> I mean, STMVar would make sense :D
15:30:01 <skypers_> or CVar, for concurrent var
15:30:05 <skypers_> why T?
15:30:08 <skypers_> transactional?
15:30:25 <geekosaur> yes
15:30:47 <skypers_> thank you
15:31:17 <jle`> kinslayer: you know i think your datatype might be simple enough for Aeson to automatically generate the conversion
15:31:39 <kinslayer> but is it describing to the sample data ?
15:32:42 <jle`> follow the instructions on the ToJson section http://hackage.haskell.org/package/aeson-0.6.1.0/docs/Data-Aeson.html#t:ToJSON
15:33:00 <jle`> then make a sample data
15:33:08 <jle`> BitcoinData
15:33:18 <jle`> BitcoinData 1 1.0 2.0 3.0 4.0 5.0 6.0 or something
15:33:20 <jle`> and then encode it
15:33:26 <jle`> and compare that result to the real one
15:34:18 <kinslayer> I will try that
15:35:27 <kinslayer> well there is a lot of names in the json
15:35:43 <jle`> lpaste it?
15:35:45 <kinslayer> "{\"timestamp\":1 ...}"
15:36:12 <kinslayer> http://lpaste.net/97100
15:36:38 <jle`> i think you posted the same link
15:36:54 <kinslayer> isn't that the json ?
15:37:06 <kinslayer> yeah that is the json
15:37:18 <jle`> that's the json that is generated by "encode btd" ?
15:37:35 <kinslayer> nope.. That is the json I want to describe
15:37:53 <jle`> paste the one returned by encode btd
15:37:55 <jle`> and see how it compares
15:38:01 <kinslayer> encode ?
15:38:12 <jle`> encode (your test data structure)
15:38:14 <jle`> at ghci or something
15:38:38 <jle`> if it matches the one you want to describe then you don't need to do anything, you can have aeson auto-generate the decoding
15:38:50 <kinslayer> hmm no instance for ToJSON
15:38:55 <kinslayer> for my datatype
15:39:02 <jle`> did you follow the instructions on the ToJSON section?
15:39:04 <jle`> http://hackage.haskell.org/package/aeson-0.6.1.0/docs/Data-Aeson.html#t:ToJSON
15:39:39 <jle`> add "deriving Generic" to your data
15:39:46 <jle`> and then "instance ToJSON BitcoinData"
15:39:49 <kinslayer> http://lpaste.net/97101 that is the encoded data
15:39:51 <kinslayer> :D
15:40:20 <jle`> hm.
15:40:27 <jle`> okay i think the problem with your decode earlier
15:40:37 <jle`> is that cex returned strings for the data fields
15:40:42 <jle`> instead of ints and doubles
15:40:45 <Rarrikins> What is this for?
15:40:49 <kinslayer> it is all strings
15:40:50 <jle`> and when it wanted an int, but got a string, it failed
15:40:56 <kinslayer> this is not used for anything...
15:41:07 <Rarrikins> Oh
15:41:15 <kinslayer> so I should put String in all over the place ?
15:41:47 <jle`> better to convert the strings to ints/doubles in the decode
15:42:04 <kinslayer> however that seems a bit difficult ?
15:42:28 <Rarrikins> You can use fmap, I believe.
15:42:43 <Rarrikins> Or, let's see how I did it.
15:42:44 <jle`> the applicative style is a little tricky to understand, you might have a better time doing it in monadic style
15:42:52 <kinslayer> well the data is just a describtion of the marked...
15:43:20 <kinslayer> well I found a nice tutorial about applicative monadic and functors really good
15:43:59 <Rarrikins> kinslayer: Something like this: http://lpaste.net/97102
15:44:55 <kinslayer> isn't the names important to match up ?
15:45:03 <kinslayer> so vol should be volumen ?
15:45:22 <Rarrikins> kinslayer: It's using the Ticker constructor, each line does one argument of it.
15:45:29 <jle`> kinslayer: here is your decoder rewritten in monadic style
15:45:31 <jle`> http://lpaste.net/97097
15:45:58 <kinslayer> jle': That looks nice
15:46:05 <jle`> this is a case where monadic style might be slightly more readable than applicative style
15:46:11 <kinslayer> almost something I can understand :D
15:46:11 <jle`> of course instad of read, do repairRational
15:46:27 <kinslayer> repairRational ?
15:46:28 <jle`> er
15:46:34 <jle`> hm
15:46:40 <jle`> :t repairRational
15:46:41 <lambdabot> Not in scope: `repairRational'
15:46:44 <Rarrikins> If you're using the newer Aeson, you don't need that.
15:46:48 <kinslayer> is that to give a rational ?
15:46:51 <Rarrikins> The old one always used Doubles.
15:46:56 <jle`> ah okay
15:47:00 <Rarrikins> repairRational would fix it somewhat.
15:47:16 <kinslayer> so read should be repairRational ?
15:47:19 <Rarrikins> You can use <*> v .: "whatever"
15:47:25 <Rarrikins> No need to fmap.
15:47:40 <jle`> what is repairRational?  i just saw Rarrikins use it
15:47:43 <Rarrikins> No, you don't really want read. Aeson has its own parsers that are faster than read.
15:47:57 <Rarrikins> repairRational is for an older Aeson that used Doubles internally.
15:47:58 <kinslayer> so I really don't need to do anything ?
15:48:00 <jle`> how should aeson parse doubles?
15:48:18 <Rarrikins> It parsed doubles fine, but you get artifacts with truncation.
15:48:39 <Rarrikins> (You shouldn't use doubles for financial stuff)
15:49:03 <Rarrikins> They recently switched to something that can handle Rationals nicely.
15:50:05 <kinslayer> so I should remove all the reads ?
15:50:06 <jle`> i'm not sure what is idiomatic aeson in this case
15:50:29 <Rarrikins> Here's for the newer version of Aeson: http://lpaste.net/97102
15:50:31 <jle`> Rarrikins: he can't v .: whatever
15:50:35 <jle`> because his v contains strings
15:50:44 <jle`> which represent both ints and floats
15:50:52 <Rarrikins> Oh, they use JSON strings for that?
15:50:59 <kinslayer> Yes
15:51:06 <jle`> it's rather unfortunate
15:51:29 <Rarrikins> You'd use something like liftM read (v .: "whatsit")
15:51:34 <kinslayer> Well it might be horrible but that is how they made their api
15:51:41 <jle`> yeah, that's what i did, but monadic style
15:51:49 <jle`> does the read version work, kinslayer?
15:51:57 <kinslayer> jle': what was your link ?
15:52:06 <kinslayer> I have not tried...
15:52:09 <jle`> http://lpaste.net/97097
15:52:27 <jle`> actually
15:53:23 <kinslayer> well It wont eat the FromJSON
15:53:34 <jle`> what's the error?
15:54:14 <kinslayer> http://lpaste.net/97106
15:54:55 <hamster007> I have a really basic question... I need to modify a package that normally I just install using cabal.  I need a *clue* as to how to download it, modify it, locally build it, and use it in a program.
15:55:25 <dcoutts_> hamster007: cabal unpack
15:55:37 <hamster007> a clue!
15:55:39 <dcoutts_> or more generally, cabal --help
15:55:57 <jle`> kinslayer: that's weird...does your original progrma work?  you still need the instance FromJSON BitcoinData where parseJSON ... et
15:56:10 <kinslayer> :D
15:57:23 <kinslayer> well now it broke...
15:57:28 <kinslayer> I really need to go to bed soon
15:57:53 <jle`> error?
15:58:06 <wxcafe> hey
15:58:13 <wxcafe> i'm trying to do an infinite loop
15:58:17 <wxcafe> (i know, silly, but hey)
15:58:27 <kinslayer> http://lpaste.net/97107
15:58:32 <wxcafe> so i tried " loop x = \x -> loop x
15:58:38 <Twey> wxcafe: let x = x in x
15:59:00 <jle`> oh i forgot to include the bid
15:59:07 <wxcafe> yeah, but i'd like it with a lambda
15:59:13 <Twey> wxcafe: That's not an infinite loop, it's a function (hint: the two â€˜xâ€™ variables are different)
15:59:15 <wxcafe> that's my constraint
15:59:28 <Twey> wxcafe: \() â†’ let x = x in x
16:00:10 <kinslayer> well not it works at least it compiles
16:00:12 <nicoo> wxcafe: let loop = \x -> loop x
16:00:43 <rasfar> loop x = (\y -> loop y) x
16:00:47 <jle`> kinslayer: did you add the bid? does it compile/work now?
16:00:54 <kinslayer> hey that got it into my structure, so now I need to think about how to go further
16:01:06 <jle`> kinslayer: see if this works
16:01:06 <kinslayer> I added the bid and it works
16:01:08 <rasfar> (or what nicoo said)
16:01:09 <jle`> http://lpaste.net/97097
16:01:15 <jle`> it'll be safer than the version with read
16:01:19 <nicoo> @pf loop x = (\y -> loop y) x
16:01:19 <lambdabot> Maybe you meant: pl bf
16:01:21 <kinslayer> I took the data from the wire and fed it in
16:01:24 <nicoo> @pl loop x = (\y -> loop y) x
16:01:24 <lambdabot> loop = fix id
16:01:29 <nicoo> Ah, yes
16:01:37 <jle`> because with the read, if you get a non-double for a field, it'll throw an error; with this, it should just return Nothing
16:01:52 <wxcafe> ok, i'll go back to reading the doc
16:01:55 <wxcafe> ^^
16:02:05 <wxcafe> i get my error though
16:02:07 <jle`> actually, wait, no sorry, mixed up my types
16:02:09 <jle`> don't do that ^^
16:02:25 <kinslayer> yeah that broke it
16:02:29 <kinslayer> the safer version
16:02:30 <wxcafe> thanks for your help
16:02:45 <jle`> yeah parseJSON was the wrong function
16:02:48 <Twey> wxcafe: (these are all equivalent to â€˜let loop x = loop x in loop xâ€™, which is just a specialization of â€˜let x = x in xâ€™)
16:03:06 <kinslayer> so what should it have been ?
16:04:48 <augur> blurgh. how do i install conduit? :(
16:04:48 <kinslayer> I will go to bed now... So I will see you all tomorrow, and thanks for the help :D
16:05:08 <lightquake> how do languages like agda prevent you from writing fix in them?
16:05:11 <jle`> kinslayer: yeah, sorry, can't think of it right now. but hopefully ir works now
16:05:22 <augur> lightquake: well, agda isnt lazy
16:05:23 <jle`> if you come back antoher day i might have a better answer
16:05:33 <kinslayer> well I will be back tomorrow or the day after, I like hanging out here
16:05:34 <augur> lightquake: so you'll run afowl of agda's termination checker
16:05:36 <jle`> or someone else would.
16:05:41 <lightquake> augur: ah
16:05:52 <jle`> we ar elooking for a function f :: String -> Parser Int
16:05:53 <augur> lightquake: you can write a coinductive fix tho, i think
16:05:59 <jle`> or f :: String -> Parser a
16:06:04 <augur> lightquake: provided you can prove you're productive
16:09:33 <lispy> quchen: re: monad_fail proposal: So adding a data constructor to a type would change the types of things use that type?
16:09:43 <lispy> (by introducing the MonadFail constraint)
16:10:11 <lispy> quchen: if it seems like full pattern matches also shouldn't introduce the constraint
16:10:24 <Twey> lightquake: Agdo performs a termination check: every recursive call to a function has to be â€˜smallerâ€™ (i.e. wrapped in fewer constructors) than it was in the originating call
16:10:58 <lispy> is agdo the spanish edition of agda? :)
16:11:09 <mm_freak> the male edition
16:11:12 <Twey> No, the Dvorak-typo version :Ã¾
16:11:21 <lispy> aoeu away!
16:11:30 <Twey> Hehe
16:11:35 <lispy> (also, Twey++ for dvorak)
16:11:36 <sipa> it's agda
16:11:49 <sipa> it's agda's do notation
16:11:53 <Twey> lispy: I'm thinking of switching to Workman
16:11:56 <Twey> sipa: Hah!
16:11:59 <jle`> haha
16:12:24 <augur> agda's do notation isn't primitive!
16:13:17 <marx2> Gtk2Hs does not export castToListStore, which I need to convert TreeModel to ListStore, but unsafeCoerce *seems* to do the job and everything *appears* to work fine. but I have no idea if this is really safe. anyone?
16:13:54 <dcoutts_> marx2: the trick is not to loose the ListStore in the first place
16:14:04 <dcoutts_> hold on to both the ListStore and the TreeModel
16:14:12 <jle`> are you asking if unsafeCoerce is unsafe?
16:14:43 <marx2> surely it can be used safely, otherwise why would it exist
16:15:12 <Twey> It's totally safe.  It's just called that as a practical joke on newbies.
16:15:17 <geekosaur> heh
16:15:19 <Twey> marx2: It's meant for FFI code, mostly
16:15:39 <marx2> dcoutts I could do it that way too, but it would be more convenient if I could just pass TreeView, and extract all the models (filter model, sort model, and list view) as they are needed
16:15:49 <marx2> and liststore, even
16:16:00 <geekosaur> it would be, but gtk doesn't think so
16:16:03 <shachaf> Twey: Please don't be unhelpful like that. :-(
16:16:29 <dcoutts_> marx2: it's really best to think of TreeModel as a wrapper/view/adaptor and to keep the original
16:16:31 <Twey> marx2: You could just bundle them all up in a datatype; you'll only lose the space of the pointer.
16:16:37 <Twey> (if they really are the same thing)
16:16:59 <Twey> shachaf: Sorry, forgot my sarcasm indicators.
16:17:09 <joejev> are functions members of Eq?
16:17:10 <marx2> here is an example of castToTreeModelSort by the way, it is more complex than straight unsafeCoerce http://hackage.haskell.org/package/gtk-0.12.3.1/docs/src/Graphics-UI-Gtk-Types.html#castToTreeModelSort
16:17:15 <Twey> joejev: No
16:17:26 <joejev> Twey: is there a way to check the equality of functions?
16:17:30 <Twey> joejev: Function equality is undecidable in the general case
16:17:46 <jle`> halting problem et.
16:17:48 <jle`> c
16:18:43 <joejev> hmm, so if I wanted to make a list of functions, and then work with them, like remove duplicates and such, I would be better off making a data placeholder, and then converting, or can I skip that step>?
16:18:43 <Twey> joejev: You can check 1) whether the functions provide the same output for some range of inputs; 2) whether the functions live at the same place in memory (not usually advisable unless you really know what you're doing)
16:19:41 <joejev> Twey: I guess for this, I do not mean mathematic functional equality, but if this was c, are they both pointing to the same function
16:19:42 <Twey> joejev: Eq is for *notional* equality, not identity as in some other languages.  If you want identity, you can get that with makeStableName, but it's often saner to just tag your functions with values indicating whether they're â€˜the sameâ€™ or not.
16:20:36 <Twey> joejev: http://hackage.haskell.org/package/base-4.6.0.1/docs/System-Mem-StableName.html â€” you can do this; maybe it's what you want
16:20:53 <dcoutts_> marx2: you found toTypedTreeModel presumably
16:20:59 <dmwit> joejev: http://stackoverflow.com/q/17045941/791604
16:21:36 <dmwit> joejev: Alternately, work with IORef (a -> b) instead of (a -> b) and get equality for free.
16:21:45 <dmwit> (A semantically very boring equality. But there you have it.)
16:21:48 <quchen> lispy: In its current form: yes and yes.
16:22:27 <quchen> lispy: At least the second case is easy to add. The first one is one of the tougher things.
16:22:42 <dmwit> Perhaps I should add the IORef idea to that answer.
16:22:46 <joejev> Twey: so with these StableNames, you could pass a function to MakeStableName?
16:23:13 <dmwit> joejev: Correct. The type of makeStableName puts no restrictions on its argument.
16:23:52 <dmwit> I wonder how hard it would be for GHC to expose an instance Ord (IORef a).
16:23:57 <joejev> dmwit: I guess that is, in my case, the same as making a data with a constructor for each function I want to represent, and then just working with those
16:24:33 <joejev> unless I am missing something
16:24:34 <dmwit> joejev: Is "that" supposed to indicate "StableName"s in your sentence?
16:24:57 <Twey> joejev: Not really; a StableName refers to a memory location.  Every object has one, and they may change during an object's lifetime.
16:25:17 <dmwit> Anyway, I think the difference is that with the scheme you propose you must think of all the functions you're interested in ahead of time.
16:25:27 <dmwit> StableNames/IORefs  do not have that restriction.
16:25:53 <joejev> dmwit: yes, sorry, and Twey, I see how they differ, and in my case I do know all the functions I will be working with ahead of time.
16:26:14 <marx2> dcoutts I am looking at it now.  I can't seem to figure out how to use it to convert TreeModel to ListStore a
16:26:44 <joejev> I was just trying to cut that corner, where instead of having a list of MyFunctionType, I would have a list of (a -> a) and then work with those, but I do not think that would work.
16:26:53 <joejev> and the other options are more complex for this task
16:26:55 <Twey> joejev: In that case it's probably wisest to tag the functions, then.
16:27:07 <joejev> Twey: thank you
16:27:53 * hackagebot notmuch-web 0.2.0 - A web interface to the notmuch email indexer  http://hackage.haskell.org/package/notmuch-web-0.2.0 (JohnLenz)
16:27:55 <dmwit> joejev: That's the last bullet point in the SO answer I linked to, by the way. =)
16:27:57 <lightquake> is there an option I can pass to ghc that forces recompilation of the file argument even if it has a .hi file?
16:28:31 <lightquake> -fforce-recomp
16:29:20 <haasn> lightquake: I'm confused. did you just answer your own question?
16:29:27 <lightquake> yes
16:29:31 <haasn> okay :)
16:29:41 <lightquake> usually when I ask a question in here I answer it in case anybody else happens to be looking :)
16:30:00 <lightquake> i've gotten fed up with forum threads that have two posts: "How do I do X?" and "Figured it out"
16:30:02 <haasn> or for public logs
16:30:11 <lispy> quchen: I think they're equivalent. For a 1 data constructor type, a full pattern match is matching on the one constructor. And we already have ways to check for complete pattern matches.
16:32:09 <haasn> joejev: in certain specific cases you could encode your function as a different data type eg. (a :-> b) or Map a b or [(a,b)] and check for equality of those
16:32:24 <koala_man> lightquake: god yes.
16:32:29 <joejev> dmwit: thanks also
16:32:33 <haasn> of course, if you know the potential forms of your functions in advance you could just use ADT placeholders for them
16:33:44 <haasn> stablenames and IORefs and whatnot don't â€˜reallyâ€™ solve the problem because two equivalent functions, constructed in different ways at different places, won't be equatable with those techniques
16:33:51 <Twey> haasn: What's :->?  ?
16:33:52 <haasn> you might as well just use (Identifier, a -> a)
16:33:54 <Twey> >.-
16:33:59 <Twey> haasn: What's :-> ?
16:34:07 <haasn> Twey: http://hackage.haskell.org/package/MemoTrie-0.6.1/docs/Data-MemoTrie.html oh it's :->:
16:34:23 <hamster007> so cabal unpack  then cd into the directory    then     cabal configure    cabal build    cabal install    and this will install my local version of the package right?
16:34:41 <dmwit> hamster007: skip cabal configure and cabal build
16:35:03 <dmwit> hamster007: In fact, why not skip it all and just "cabal install <package-name>" directly?
16:35:12 <hamster007> because I want to modify it
16:35:20 <dmwit> Right. =)
16:35:29 <dmwit> Then yes, cabal unpack and cabal install are enough.
16:35:33 <hamster007> so still skip configure and build?
16:35:37 <hamster007> yeah
16:35:38 <hamster007> ok
16:35:44 <hamster007> thanks man
16:35:58 <hamster007> what if I already did configure and build
16:36:02 <Twey> haasn: Ah, right
16:36:03 <hamster007> does it matter
16:36:07 <dmwit> nah
16:36:13 <hamster007> yay
16:36:22 <haasn> Twey: of note is the instance (HasTrie a, Eq b) => Eq (a :-> b)
16:36:36 <larss> is it correct to say that liftM (+10) mx is a monadic operation?  since we can do same with Functors, is it a Functor operation?
16:36:39 <dmwit> If it turns out that cabal install and cabal configure agreed on the right way to satisfy dependencies, cabal install will even reuse the work it did during cabal build. =)
16:37:26 <dmwit> larss: That's sort of okay.
16:37:50 <dmwit> larss: There's not really a standard word for a value whose type happens to have a monad in it. And with functors it's even less standard.
16:38:15 <Twey> Obviously â€˜foteâ€™, to go with â€˜moteâ€™!
16:38:17 <dmwit> "monadic operation" is no worse than the alternatives I've heard, really.
16:38:18 <haasn> Twey: oh, but come to think of it, that trie type will be no better than (Universe a, Eq b) => Eq (a -> b)
16:38:26 <Twey> Or â€˜futeâ€™?
16:38:35 <Twey> haasn: Right; I was just thinking that reading the documentation :Ã¾
16:38:37 <dmwit> But by analogy, the Functor version would surely be "functorial operation", not "Functor operation". =)
16:38:48 <shachaf> I don't know what the word "operation" means.
16:39:22 <shachaf> If you're calling "liftM (+10) mx" a monadic operation, are you talking about the whole value or the idea of liftMing a function or what? Is "mx" a monadic operation in that context?
16:39:45 <dmwit> Twey: "funct"?
16:39:51 <dmwit> functote
16:39:53 <dmwit> yes
16:40:29 <dmwit> We've had enough discussion of what a good term would be. We need a competition to come up with the *worst* possible term for this.
16:40:31 <larss> I am asking because I tried to use do x <- mx; return (x + 10). to show to someone why monads can be useful, and someone commented that you can do the same thing with functors so it is not really a monadic operation
16:40:55 <Twey> I could get behind â€˜functoteâ€™, but we might need to introduce â€˜monoteâ€™ to go with it.
16:41:10 <larss> shachaf: the idea of lifting
16:41:30 <dmwit> larss: Perhaps you should ask yourself whether the terminology is really the thing you want to argue about with this person.
16:41:41 <dmwit> I think their objection is much deeper than a terminological one.
16:41:55 <jle`> larss: something like (+10) <$> mx i feel is not a good demonstration on why monad-ness is useful
16:42:24 <jle`> in fact it is actually a very narrow subset of things where monadicness becomes useful
16:42:26 <Fuuzetsu> Is there no â€˜foo = return ()â€™ where â€˜fooâ€™ is hopefully shorter than â€˜return ()â€™?
16:42:43 <dmwit> :t (()<$)
16:42:44 <lambdabot> Functor f => f b -> f ()
16:42:48 <larss> not a complete demonstration but it seemed like a good starting point
16:42:52 <shachaf> :t void
16:42:53 <lambdabot> Functor f => f a -> f ()
16:42:57 <merijn> Fuuzetsu: Any specific reason you want it?
16:42:59 <Twey> : void()
16:43:02 <Twey> :t void()
16:43:03 <shachaf> Er, but that's not foo = return ()
16:43:03 <lambdabot>     Couldn't match expected type `f0 a0' with actual type `()'
16:43:04 <lambdabot>     In the first argument of `void', namely `()'
16:43:04 <lambdabot>     In the expression: void ()
16:43:06 <jle`> larss: in many applications, you really only need functorness and applicativeness
16:43:07 <Twey> Er
16:43:08 <shachaf> No, return () has no shorter name.
16:43:14 <shachaf> other than pure (), if you're willing to go with that.
16:43:14 <Fuuzetsu> merijn: drop some parens in things like â€˜maybe (return ()) â€¦â€™
16:43:14 <Rarrikins> @let foo = return ()
16:43:15 <lambdabot>  .L.hs:165:1:
16:43:15 <lambdabot>      Multiple declarations of `foo'
16:43:15 <lambdabot>      Declared at: .L.hs:161:1
16:43:15 <lambdabot>                   .L.hs:165:1
16:43:24 <Rarrikins> @let foo2 = return ()
16:43:25 <lambdabot>  .L.hs:161:8:
16:43:25 <lambdabot>      No instance for (Monad m0) arising from a use of `return'
16:43:25 <lambdabot>      The type variable `m0' is ambiguous
16:43:25 <lambdabot>      Possible cause: the monomorphism restriction applied to the following:
16:43:25 <lambdabot>        foo2 :: m0 () (bound at .L.hs:161:1)
16:43:40 <merijn> Fuuzetsu: Ah, yeah. that one annoying. I usually just define "whenJust" for that
16:43:41 <Rarrikins> Monomorphism restrictions!
16:43:50 <merijn> Although I believe forM_ can work with that
16:43:50 <dmwit> :t traverse
16:43:51 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:43:53 <merijn> :t forM_
16:43:54 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
16:44:11 <merijn> I guess I want the Foldable version of that
16:44:12 <dmwit> forM_ is probably better.
16:44:13 <jle`> in fact i would argue that (+10) <$> mx is anti-monad, because something "monadic" involves using the result of the previous operation to determine the next one
16:44:16 <merijn> :t F.forM_
16:44:17 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
16:44:26 <merijn> or something along those lines
16:44:33 <jle`> so if there is no branching, it is not a monad
16:44:35 <jle`> there i said it :)
16:44:47 <dmwit> jle`: I definitely would not go that far.
16:45:04 <merijn> larss: tbh, the term "monadic" is a rather loosely defined casual term
16:45:05 <shachaf> I would say that's a completely useless argument.
16:45:06 <jle`> it is the branchingness of an operation chaining that gives it monadic quality
16:45:17 <merijn> larss: Arguing about it's meaning just means the other guy is trolling you
16:45:17 <Fuuzetsu> jle`: You can't just decide what is and what isn't a monad depending on what you think, it's a well defined thing.
16:45:19 <shachaf> Words are overrated.
16:45:24 <jle`> :'(
16:45:32 <jle`> a monad is a well defined thing
16:45:37 <dmwit> Your opinion is bad, and you should feel bad.
16:45:41 <jle`> but a 'monadic operation' and what is a good demonstration of something using monads is not
16:45:49 <shachaf> dmwit: I do.
16:45:55 <jle`> noooo
16:45:57 <haasn> but is â€œnot a monadâ€ a well defined thing?
16:45:58 <Fuuzetsu> rip
16:45:59 <jle`> what did you do dmwit :/
16:46:06 <dmwit> amazing
16:46:09 <merijn> haasn: monad and not a monad are well defined
16:46:12 <Fuuzetsu> haasn: Yes, something that's not a monad.
16:46:15 <merijn> haasn: in both haskell and math
16:46:17 <jle`> haasn: that was lexical sugar for "not a good example for a monadic action"
16:46:18 <Fuuzetsu> Surprisingly enough.
16:46:20 <haasn> Fuuzetsu:  is a cat a monad?
16:46:20 <merijn> haasn: But "monadic" is not
16:46:34 <jle`> surely your lexical compiler should have desugared it properly
16:46:47 <merijn> haasn: Yes, cats can consume things and use those to produce new cats
16:46:52 <dmwit> Actually, I think shachaf had the right idea.
16:46:58 <Fuuzetsu> hue
16:47:14 <Fuuzetsu> now that shachaf is gone, we can discuss monads in terms of burritos
16:48:04 <jle`> but i will elaborate that unless you are branching, you are not exploiting monadic structure
16:48:29 <haasn> monadsploitation
16:48:38 <jle`> so whatever example of 'why monads are useful' you have, if it dodesn't involve branching, it does not really take advantange of the fact that you are in a monad
16:49:42 <QF-MichaelK> Pattern matching seems a bit like a switch statement but with types rather than values.  Is this kind of right?
16:50:02 <haasn> jle`: what about â€˜concatâ€™?
16:50:12 <merijn> QF-MichaelK: Yes
16:50:15 <Fuuzetsu> nominolo: You around? Any chance that you could bestow a wiki account upon me?
16:50:25 <merijn> QF-MichaelK: Well, you actually switch on constructors, not types
16:50:26 <haasn> QF-MichaelK: no
16:50:26 <jle`> haasn: hm?
16:50:26 <Iceland_jack> merijn: With types?
16:50:32 <Iceland_jack> Value constructors, not types
16:50:35 <haasn> QF-MichaelK: you don't branch on the types. That can't be done in Haskell
16:50:42 <merijn> haasn: Can too!
16:50:51 <merijn> Iceland_jack: Yeah, I was hasty with my answer
16:51:01 <merijn> haasn: learn2typefamilies :p
16:51:09 <haasn> as a matter of fact, switch statements are pretty much exactly like pattern matching;  case x of 1 -> ...; 2 -> ...; 3 -> ...
16:51:17 <haasn> (but pattern matching is more general)
16:51:22 <Iceland_jack> QF-MichaelK: You define a *single* type with one or more value *constructors*
16:51:23 <QF-MichaelK> Hmmm, alright
16:51:29 <merijn> QF-MichaelK: Are you familiar with C?
16:51:32 <Iceland_jack> and then you pattern match on those constructors
16:51:36 <QF-MichaelK> merijn: yes
16:52:00 <larss> to give some context, this was meant as a (beginning of) a basic introduction to a guy who does not know haskell, isnt learning it or any other functional languahe, and was wondering what monads are all about.
16:52:19 <merijn> QF-MichaelK: Right, you know what "tagged union" means? i.e. a struct that has an enum and a union, where the enum indicates which type is used by the union
16:52:31 <QF-MichaelK> merijn: negative
16:52:52 <jle`> larss: you have to give him context of course.  he should understand the usefulness of a functor first, then the usefuless of an appliative, then the usefulness of a monad.  actually he can probably skip applicative.
16:52:53 <QF-MichaelK> merijn: rather, now I do
16:53:10 <larss> adding a number to a null reference seemed like the most natural way to explain it. then following up with applicatives (liftA2), then full blown bind :)
16:53:18 <merijn> QF-MichaelK: Well, I just mostly described them :) Haskell ADT are a lot like that, pattern matching is essentially a switch on the "enum" (i.e. constructor)
16:53:33 <jle`> larss: the typical monad example is the Maybe/null example of course
16:53:41 <jle`> something like halve :: Int -> Maybe Int
16:53:43 <merijn> QF-MichaelK: With the variation that you can pattern match nestedly
16:53:46 <Iceland_jack> QF-MichaelK: When you define something like:
16:53:47 <Iceland_jack>     data Food = Carrot | Potato | Strawberry
16:53:47 <Iceland_jack> then â€˜Foodâ€™ is a type constructor and Carrot/Potato/Strawberry are value constructors
16:53:48 <Twey> larss: And he objected to your example by saying it was too functorial?  :Ã¾
16:53:55 <haasn> merijn: sort of. you still bind variables in a pattern match. That's something unique to pattern matching
16:53:59 <jle`> halve n | even n = Just (n `div` 2); otherwise = Nothing
16:54:02 <maurer> Z/windo w27
16:54:03 <haasn> you don't bind variables in any sort of switch statement known to me
16:54:13 <merijn> QF-MichaelK: i.e. "case foo of (Just x):restOfList -> doSomething"
16:54:16 <QF-MichaelK> Iceland_jack: Ah, thanks
16:54:29 <haasn> Iceland_jack: s/type constructor/type/
16:54:43 <larss> jle`: my question really is, do we have to give names to Functor and Applicatives? is it imprecise to call it all a Monad? since Monad is a functionality wise a superset of Functors and Applicatives
16:55:01 <jle`> larss: we have to give names to them because there are useful things that are Functors and not monads or applicatives
16:55:05 <Iceland_jack> QF-MichaelK: So you can write a function
16:55:05 <Iceland_jack>     yummy :: Food -> Bool
16:55:05 <Iceland_jack>     yummy Strawberry = True
16:55:05 <Iceland_jack>     yummy _          = False
16:55:06 <jle`> and useful things that are Applicatives but not monads
16:55:17 <Twey> larss: That's backwards.  All Monads are Functors (in spirit); not all Functors are Monads
16:55:24 <Iceland_jack> where we pattern match on the value constructor â€˜Strawberryâ€™
16:55:25 <merijn> QF-MichaelK: Basically the pattern (constructors) on the left side are recursively matched against a value, if it determines no match it moves to the next line (kinda like switch)
16:55:43 <haasn> Twey: what he meant (I think) is that a monad interface is a superset of a functor interface
16:55:44 <larss> jle`: sure, but That is probably not interesting to someone who is not a haskell programmer
16:55:52 <Iceland_jack> In a similar way you can think of the numbers (â€¦, -5, 0, 15, 2994349, â€¦) as value constructors
16:56:01 <simpson> Monads require a Functor instance underneath, I thought.
16:56:08 <haasn> smith_: no
16:56:09 <merijn> simpson: not yet
16:56:09 <haasn> simpson: *
16:56:09 <Hari`> hi
16:56:20 <Twey> haasn: Aye, but they were talking about calling Functors Monads because Monads are Functors.
16:56:26 <merijn> simpson: It's an approved feature coming in the next couple of GHC releases
16:56:31 <QF-MichaelK> Iceland_jack: merijn: haasn:  Ah, thanks guys, that clarified things.
16:56:34 <jle`> larss: if you want to skip naming functors and applicatives then you can leave them unnamed.  we actually left applicative unnamed for a long time
16:56:37 <larss> Twey that is why I said functionality wise. Monads can do everything Applicatives and Functors can, but not vice versa
16:56:52 <pyon> larss: I think zipping lists is useful to many programmers, not just Haskell programmers. :-)
16:56:57 <Iceland_jack> QF-MichaelK: And gals! :) you're welcome
16:57:05 <pyon> many programmers using different languages*
16:57:08 <Twey> larss: Yes; so it's defensible to call any Monad a Functor, but not to call any Functor a Monad.
16:57:38 <larss> what about Functors? did we have Monad before Functor in haskell?
16:57:39 <jle`> larss: but it's slightly misleading to say that fmap is what makes a monad a monad.  that's like saying the best part about soda is that it is made out of molecules
16:57:46 <QF-MichaelK> Iceland_jack: Ah, my apologies ^.^
16:57:49 <jle`> i say that because i have a bottle of soda in my hand.
16:57:51 <Iceland_jack> jle`: Well isn't it?
16:57:56 * hackagebot tempodb 0.2.2.0 - A small Haskell wrapper around the TempoDB api.  http://hackage.haskell.org/package/tempodb-0.2.2.0 (ParnellSpringmeyer)
16:58:04 <jle`> mm those molecules.
16:58:09 <Iceland_jack> QF-MichaelK: Any other questions?
16:58:15 <Twey> Photon cola is pretty, but just not as satisfying.
16:58:29 <Iceland_jack> Twey: You mean Photon Cola: Light?
16:58:33 <jle`> haha
16:58:34 * Twey groans.
16:58:45 * Iceland_jack prepares a public apology
16:59:00 <stolaruk> I'm trying to learn when to use strict data types and bang patterns, and when to use lazy evaluation. In The Haskell Cast episode 2 with Don Stewart, Don talks about this guideline: make the spines of your structures lazy, and the leaves of your structures strict. Apparently "leaves" is referring to "atomic" types such as Int, Double, and Bool. What is meant by "spines"?
16:59:04 <Twey> larss: I think you can show off Haskell by explaining the advantages of functors just as well as you can by showing the advantages of monads.
16:59:12 <larss> jle`: I dont think I ever said that, though maybe I was interpreted by that
16:59:13 <jle`> larss: if you want to say "monads are things you can map functions over", then that really is -- although true -- slightly misleading
16:59:26 <larss> like that*
16:59:33 <Rarrikins> stolaruk: It's an evaluated list with unevaluated elements.
16:59:37 <QF-MichaelK> imalsogreg: Not right now, just continuing reading lyah and random questions arise when trying to relate it to how I might tell other people about these concepts when they don't have the familiarity and I don't have the expertise to fully show them yet.
16:59:48 <Rarrikins> stolaruk: The 'spine' of the list is evaluated.
16:59:56 <QF-MichaelK> Iceland_jack: OOps
16:59:56 <haasn> stolaruk: an example;  data List a = Nil | Cons !a (List a) -- has a lazy spine, strict leaves
16:59:58 <jle`> larss: what was your original question? how to explain why monads are useful?
17:00:02 <QF-MichaelK> imalsogreg: oops that was to Iceland_jack
17:00:08 <haasn> stolaruk: data List a = Nil | Cons a !(List a) -- has a strict spine, lazy leaves
17:00:18 <stolaruk> Rarrikins: So it's sorta evaluating a list to weak head normal form?
17:00:18 <Twey> stolaruk: data List a = Nil | Cons a (List a) â€” the â€˜spineâ€™ is the chain of â€˜Consâ€™ constructors; the â€˜leavesâ€™ are the â€˜aâ€™ values attached to it
17:00:50 <Rarrikins> stolaruk: Yeah, you get a bunch of (:)s and a [], but none of the list elements.
17:00:54 <larss> jle`: it was "is it imprecise to call fmapping  a monadic operation"
17:00:55 <Iceland_jack> QF-MichaelK: Another simple data type is
17:00:56 <Iceland_jack>     data Bool = True | False
17:01:02 <jle`> larss: ah
17:01:12 <stolaruk> So does this concept of spines and leaves apply best to recursively defined types?
17:01:19 <merijn> stolaruk: Think of the spine of a data structrue as the "shape" of the structure
17:01:25 <Iceland_jack> So you can define â€˜notâ€™ by pattern matching on the constructors True and False
17:01:26 <Iceland_jack>     not :: Bool -> Bool
17:01:26 <Iceland_jack>     not False = True
17:01:26 <Iceland_jack>     not True  = False
17:01:32 <haasn> stolaruk: as a matter of fact, it only applies to recursively defined types
17:01:33 <Twey> stolaruk: Only, in the usual parlance
17:01:35 <merijn> stolaruk: I would say it *only* applies to recursively defined types
17:01:40 <Rarrikins> stolaruk: I think it can be used for any data structure. The structure itself is the spine. The data is the 'meat'.
17:01:57 <jle`> larss: what is a monadic operation >>
17:02:00 <Rarrikins> Ahh, OK
17:02:08 <jle`> people call things like putStrLn a monadic operation
17:02:19 <merijn> So list has one long spine, a tree has a branching spine, etc.
17:02:25 <jle`> in that context a monadic operation is an object representing an action
17:02:26 <stolaruk> I see. So lets say I have a simply data type like "data Foo = Bar Int Bool Double". In this case it's just a leaf
17:02:28 <haasn> jle`: we tend to call it â€œmonad actionâ€, I think
17:02:36 <QF-MichaelK> Iceland_jack: and then not _ = error "not of type Bool"
17:02:38 <haasn> or simply â€œactionâ€
17:02:39 <jle`> haasn: ah ok
17:02:43 <merijn> stolaruk: I would not use either leaf/spine there
17:02:44 <Iceland_jack> QF-MichaelK: No
17:02:49 <stolaruk> ok
17:02:52 <merijn> stolaruk: As it doesn't really tell you much
17:02:54 <Iceland_jack> QF-MichaelK: True and False are the *only* possible values of type Bool
17:02:57 * hackagebot yesod-auth-account 1.2.3 - An account authentication plugin for Yesod  http://hackage.haskell.org/package/yesod-auth-account-1.2.3 (JohnLenz)
17:03:00 <haasn> QF-MichaelK: that's a redundant pattern
17:03:04 <Twey> QF-MichaelK: not is defined to take a Bool: the only thing that can be in that argument position is a Bool
17:03:05 <ReinH> "an object representing an action"?
17:03:05 <Iceland_jack> There are no other cases
17:03:11 <lightquake> i'm feeling grumbly about ghc-mod/hdevtools
17:03:17 <haasn> QF-MichaelK: the type system already enforces that you get a bool.  â€œnot 0â€ is a type error
17:03:28 <haasn> (well, sort of. I mean, let's just pretend I wrote â€œnot 'a'â€ instead)
17:03:33 <QF-MichaelK> Ah ok
17:03:35 <merijn> stolaruk: If you have a binary tree "data Tree a = Leaf a | Branch (Tree a) (Tree a)" then it's spine is "the bits that give it a shape", i.e. the Branch
17:03:38 <lightquake> ghc-mod doesn't require any hacking to support cabal sandboxes, but it's slow on large projects
17:03:49 <lightquake> hdevtools is faster because it keeps a server around but if you're sandboxing you have to pass a bunch of arguments
17:03:51 <haasn> ((numeric literals are polymorphic in haskell so 0 could technically be a Bool. but that's not the point here))
17:03:53 <merijn> stolaruk: Since Leafs don't actually do much other than hold data
17:04:05 <ReinH> lightquake: :/
17:04:06 <stolaruk> merijn: Yeah, that makes perfect sense.
17:04:12 <jle`> haasn: Bool is a Num?
17:04:22 <haasn> jle`: it would make sense as one. sort of
17:04:29 <jle`> > 0 :: Bool
17:04:30 <haasn> jle`: (it's not. not by any sort of default)
17:04:31 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Bool)
17:04:31 <lambdabot>    arising from the literal `0'
17:04:31 <lambdabot>  Possible fix:
17:04:31 <lambdabot>    add an instance declaration for (GHC.Num.Num GHC.Types.Bool)
17:04:33 <merijn> stolaruk: It's not a very strictly defined term, though so it's usage is mostly inferred from context using that heuristic
17:04:34 <Rarrikins> jle`: If you write an Integral instance for it.
17:04:43 <stolaruk> ok
17:05:04 <haasn> jle`: You could reasonably think of a Bool as a bit, ie. Int1
17:05:08 <haasn> Word1, rather
17:05:15 <jle`> larss: i guess my personal answer would be "technically maybe, but not the best example of one"
17:05:25 <jle`> haasn: i meant in Haskell implementaiton, heh
17:05:35 <haasn> no, Bool is not an instance of Num in Haskell
17:05:46 <lightquake> like... 2.8 seconds in ghc-mod vs 0.18 seconds in a hot hdevtools
17:05:56 <merijn> stolaruk: The reason you want strict leaves is that if you insert some expensive computation, then it's done immediately rather then when someone gets it out
17:06:12 <merijn> stolaruk: The reason you want lazy spines is that those allow you to use infinite structures
17:06:21 <haasn> merijn: assuming you force the spine.
17:06:21 <ReinH> haasn: infinitely sad that Bool is not Num w/ a mod 2 space implementation... Ok not really.
17:06:26 <larss> jle`: i agree it isnt, but it still seems as a good way to start explaining monads to a non-haskell programmers
17:06:29 <merijn> stolaruk: A strict infinite structure obviously won't fit in memory
17:06:36 <haasn> merijn: if you force the spine you might as well force the leaves, too
17:06:40 <jle`> larss: yes most people do start out explaining monads with fmap
17:06:54 <jle`> but they don't call it a monadic action; i guess it is up to you.
17:07:01 <merijn> haasn: Sure, but I'm clarifying why dons mentioned "strict leaves, lazy spine" as heuristic
17:07:09 <larss> how would you call it?
17:07:11 <ReinH> fmap, pure, join is a perfectly reasonable way to explain monads
17:07:13 <haasn> I think for many types a strict spine *and* strict leaves would be best for performance. Especially hand-rolled ones. If you expose it as part of a library and it makes sense for it to be infinite, though, that's obviously a taboo
17:07:14 <ReinH> larss: I would call it fmap
17:07:27 <ReinH> larss: don't make up confusing/misleading names for things that already have good names
17:07:49 <larss> ReinH: that name is meaningless to a non-haskeller though
17:07:51 <haasn> I would explain monads in terms of do sugar, I think. I've never had to explain monads. Not in that sense
17:08:00 <jle`> larss: just as meaningless as monadic though
17:08:02 <ReinH> larss: every name is meaningless to a person that hasn't heard it before.
17:08:05 <ReinH> So give it meaning
17:08:08 <ReinH> tht's what teaching *is*
17:08:14 <stolaruk> I thought expensive computations were best done in lazy terms. And that making fields strict is good when you expect to only have trivial computations, so as to avoid the buildup of many thunks for said computations.
17:08:17 <jle`> i like to call it "apply inside"
17:08:19 <haasn> fmap/pure/join is more or less meaningless to a non-category theorist. And (>>=) is more or less meaningless to a non-Haskell-programmer
17:08:26 <jle`> > (*2) $ 3
17:08:28 <lambdabot>  6
17:08:31 <jle`> > (*2) <$> Just 3
17:08:32 <lambdabot>  Just 6
17:08:39 <ReinH> :t fmap
17:08:40 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:08:45 <haasn> jle`: is a function a container?
17:08:46 <haasn> etc.
17:08:49 <ReinH> that + the laws = explaining fmap
17:08:56 <merijn> stolaruk: Expensive computation are best done lazily, IF there is a chance they're never used
17:08:57 <ReinH> haasn: yes, in a way.
17:09:08 <jle`> haasn: it's a container containing a future value ^.^
17:09:10 <haasn> ReinH: we've had this discussion a billion times in #haskell :P
17:09:12 <ReinH> haasn: a -> b is a container of b's in much the same way that M.Map a b is :p
17:09:15 <merijn> stolaruk: If you're sure you're gonna use them it doesn't matter much when you do them
17:09:16 <ReinH> haasn: I know
17:09:23 <larss> haasn is fmap a term from category theory?
17:09:28 <Rarrikins> Monads are useful only for burrito-related tasks.
17:09:34 <stolaruk> lol
17:09:44 <ReinH> Rarrikins: false.
17:09:45 <haasn> larss: no, not that I know of. They just re-used the functor's name
17:09:45 <ReinH> Rarrikins: I find them useful for spaceship-related tasks as well.
17:09:46 <Twey> larss: No, it's a term from category theory with an â€˜fâ€™ appended by unfortunate historical accident.  >.<
17:09:50 <stolaruk> merijn: ok, I see
17:10:32 <Fuuzetsu> What's a good way to rebuild mtl with profiling without breaking every single package already on my system?
17:10:37 <lispy> Is there a library function for (fmap . fmap . fmap) ?
17:10:46 <Twey> lispy: Not in base
17:10:49 <lispy> I have Map k [[v]] and I want to apply a function at all the v
17:10:52 <jle`> well not necessary an accident
17:10:58 <lispy> Twey: lens would be fine too
17:11:03 <jle`> didn't we have fmap as map once?
17:11:05 <haasn> lispy: over (mapped.mapped.mapped) heh
17:11:13 <lispy> haasn: heh, that seems worse :)
17:11:14 <jle`> the problem was that newbies would see a type error when they mapped over a list
17:11:18 <ReinH> haasn: (actually, the question "if [b] is a container of b's, what would it mean to say that (a -> b) is a container of b's" has been useful to me when properly supported)
17:11:25 <jle`> and instead of seein a type error about lists, they saw a type error about Functors
17:11:56 <jle`> and they would feel sickly or something
17:12:08 <heatsink> heh
17:12:16 <jle`> so then they changed map back to fmap
17:12:19 <Peaker> And then they used some "a" as if it were a "Maybe a", and they got an "Occurs Check: Somewhere in your source file" which was not about anything
17:12:21 <jle`> and made map only for lists
17:12:22 <haasn> > fmap ord 'a'
17:12:24 <lambdabot>  Couldn't match expected type `f0 GHC.Types.Char'
17:12:24 <lambdabot>              with actual type `GHC.Types.Char'
17:12:34 <haasn> oh, that's sane. I half-expected a kind error
17:12:39 <heatsink> Then the newbies would go back to C++ with its 100-line template error messages
17:13:17 <Peaker> GHC errors suck in many circumstances. Making the libraries suck more so that error messages suck slightly less seems like a bad idea
17:13:23 <jle`> now if only forM and mapM would be generalized to all functors in prelude
17:13:30 <jle`> ...
17:13:32 <jle`> who is on that, again?
17:13:43 <Twey> edwardk, I believe :Ã¾
17:13:53 <Peaker> you mean mapM -> traverse?
17:13:58 <larss> ReinH: I was trying to explain Monads to a non-haskell programmer (and one who does not aspire to be a haskell programmer either). so haskell function names and signatures arent too relevant
17:14:04 <Twey> Though I don't think functor is the right abstraction there
17:14:14 <ReinH> larss: sure they are.
17:14:16 <haasn> the most general mapM I know operates on traversables and applicatives
17:14:19 <heatsink> I don't think you can mapM over (->) k
17:14:22 <ReinH> larss: they are quite easy to understand.
17:14:27 <Twey> larss: Link them to one of the many, many â€˜monads are useful in $language too!â€™ posts out there
17:14:36 <ReinH> you can use join : TxT->T if you want
17:14:39 <jle`> you should tell them that jQuery is a monad. (don't)
17:14:45 <ReinH> but I think join :: m (m a) -> m a is quite easy to support
17:14:46 <Twey> Why not?
17:15:05 <zRecursive> :t join
17:15:06 <lambdabot> Monad m => m (m a) -> m a
17:15:25 <haasn> heatsink: correct;  sequenceA :: (Void -> Const Void Void) -> Const Void (Void -> Void) -- impossible
17:15:53 <Twey> I think it's one of the less clumsy implementations of monads despite the poor language support (it's going to lose something in the translation to any untyped language, I suppose)
17:15:58 <haasn> but (Void -> a) is a perfectly fine Functor; and (Const Void) is a perfectly fine applicative
17:16:19 <ReinH> Twey: it's not a monad.
17:16:40 <ReinH> Twey: https://dl.dropboxusercontent.com/u/632742/Tracks/Haskell%20Cast%20Episode%201%20Outtake%201.wav
17:16:41 <haasn> actually, I lied
17:16:44 <haasn> Const Void is not an applicative
17:16:47 <heatsink> Isn't Const Void uninhabited?
17:17:00 <jle`> larss: have you read http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html ?
17:18:15 <Twey> ReinH: That's a lot of people saying jQuery is not a monad.  I believe you now :Ã¾
17:18:23 <ReinH> Twey: mostly Edward Kmett :p
17:18:26 <Twey> Yeah :Ã¾
17:18:35 <Rarrikins> @hoogle fix
17:18:36 <lambdabot> Data.Function fix :: (a -> a) -> a
17:18:36 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
17:18:36 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
17:18:45 <Twey> Categorically speaking, yes, it's not a monad; but the typical use of it looks a lot like a listâ€¦ functor, I guess
17:18:54 <ReinH> Twey: no. :D
17:19:23 <simpson> Deferred is a monad, but nobody ever notices or cares. :c
17:19:29 * Twey scratches his head.
17:19:31 <ReinH> simpson: promises in general are monads.
17:19:48 <ReinH> simpson: fun story: I've been in a Promise/A issue about making some use of the monad properties
17:19:52 <ReinH> there was a fair amount of care
17:19:57 <ReinH> but not from anyone who could do anything about it
17:20:09 <Twey> You can wrap things in it, and call functions (on elements) that multiply or filter them
17:20:21 <ReinH> Twey: does it obey the functor laws?
17:21:10 <Twey> I think it obeys the monad laws (the usual usage, that is; it's hard to make any general statements about a â€˜typeâ€™ that doesn't exist and can be extended by anyone at runtime)
17:21:41 <ReinH> Twey: https://twitter.com/kmett/status/93883284362248192
17:21:46 <ReinH> So... no.
17:22:16 <haasn> Twey: is Linq a monad? :)
17:22:21 <jle`> edwardk is the judge, the jury, and the executioner
17:22:44 <ReinH> well, it's an argument from authority
17:22:47 <ReinH> but... it's edwardk
17:22:53 <ReinH> also his reddit comment goes into more
17:23:08 <haasn> â€œI have a proof, but this tweet is not large enough to contain itâ€
17:23:14 <ReinH> haasn: ha yes exactly
17:23:20 <haasn> famous last words
17:23:22 <ReinH> haasn: I had to pull that one before.
17:24:08 <joneshf-work> @hoogle (a -> b -> b) -> b -> b -> [a] -> b
17:24:09 <lambdabot> Data.IntMap.Strict insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
17:24:10 <lambdabot> Data.IntMap.Lazy insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
17:24:10 <lambdabot> Data.IntMap insertWith' :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
17:24:20 <joneshf-work> hmm
17:24:30 <joneshf-work> is there like a `foldWithDefault`?
17:24:34 <Twey> ReinH: The interesting argument comes down to â€˜jQuery isn't a monad because Javascript is impureâ€™.  Which is true, but you can constrain yourself to only do things that are monad-safe and squint a bit, and then it almost looks like a monadic bind (although admittedly the return isn't anywhere close).
17:24:41 <jle`> unfortunately, in Fermat's days, there was no way to hyperlink to a reddit thread
17:24:50 <Twey> Heh
17:24:58 <ReinH> Twey: I don't think we're going to agree on this
17:25:00 <ReinH> :p
17:25:13 <Twey> haasn: People keep saying so.  I don't really know enough about it to judge.
17:25:18 <joneshf-work> like if you were folding a list of Maybe's and you want to give a default value for the Nothing's
17:25:19 <ReinH> I cleave tightly to the edwardk dogma
17:25:39 <joneshf-work> hmm
17:25:43 <ReinH> joneshf-work: fold xs <|> default
17:26:06 <Twey> ReinH: I think we do agree on it, but have different criteria for â€˜kind of likeâ€™ that turns it into a definitional argument.  :Ã¾
17:26:17 <ReinH> Twey: it's always a definitional argument :p
17:26:29 <haasn> Twey: it's not, there's no â€œreturnâ€
17:26:45 <jle`> what is a monad/applicative without return/pure?
17:26:48 <joneshf-work> ReinH, thanks!
17:26:49 <jle`> surely there is a name
17:26:55 <haasn> Twey: Linq gives you an interface for (>>=) and â€˜fmapâ€™ (which is distinct from (>>=) in the absence of return) but that's it
17:26:56 <ReinH> jle`: bind?
17:27:11 <zRecursive> Whether or not are packages, installed by cabal, gauranteed supported by community all the time ?
17:27:15 <ReinH> jle`: I think one of the proposals has a Bind typeclass?
17:27:37 <pyon> jle`: Like a... semigroup object in the category of endofunctors? (in the case of monad without pure)
17:27:58 <Twey> haasn: Ahuh
17:28:20 <Fuuzetsu> ReinH: Saved for prosperity
17:28:20 <ReinH> pyon: a free semigroup monad monad-algebra? :D
17:28:33 <ReinH> Fuuzetsu: ?
17:28:52 <ReinH> pyon: (no)
17:28:53 <Twey> Chanspeak for â€˜posterityâ€™, I think.
17:28:56 <Fuuzetsu> ReinH: The out-take
17:29:01 <ReinH> Fuuzetsu: oh :)
17:29:07 <ReinH> Fuuzetsu: you could also save the whole episode :)
17:29:10 <ReinH> it's not really an outtake
17:29:31 <Fuuzetsu> I have watched it before.
17:29:43 <ReinH> yay :D
17:29:49 <Fuuzetsu> Twey: hey, prosperity is a word!
17:30:14 <Twey> It is that
17:30:26 <ReinH> Twey: why not both :D
17:31:11 <Twey> Hehe
17:31:27 <jle`> is there a functor + return ?
17:32:41 <pyon> pure/return is like the kind * -> * equivalent of pointed sets/types (kind *), right?
17:32:56 <haasn> jle`: Pointed, but it's not really useful
17:33:11 <Twey> Pointed doesn't have fmap
17:33:28 <haasn> Pointed Functor, then ;)
17:33:52 <Twey> pyon: Pointed is * â†’ * as well: class Pointed f where pure âˆ· a â†’ f a
17:34:26 <pyon> Twey: Yeah, but pointed sets are just a set with a distinguished element.
17:34:48 <pyon> (Not that they are terribly interesting. They are not.)
17:35:06 <Twey> Hrm, I'm not sure whether that's still true in Haskell
17:36:01 <haasn> pyon: I guess you could say it's the equivalent of class Default
17:36:09 <Twey> Yeah
17:36:09 <ReinH> "Categories? Oh are you talking about... a shopping cart, right."
17:36:12 <ReinH> I need better friends.
17:36:23 <pyon> haasn: There is a class Default? :-O
17:36:31 <Twey> pyon: In the â€˜defaultâ€™ package
17:36:48 <haasn> @hackage default
17:36:48 <lambdabot> http://hackage.haskell.org/package/default
17:36:51 <Twey> I don't see the connection between Pointed and a pointed set
17:36:54 <haasn> @hackage data-default
17:36:54 <lambdabot> http://hackage.haskell.org/package/data-default
17:37:04 <Twey> Is there one?
17:37:25 <haasn> Twey: there's one in one direction; point () is an arbitrary element
17:37:36 <ReinH> so Pointed can't be called Coalgebra instead?
17:37:54 <Twey> haasn: But it's an arbitrary element of f (), not of f a
17:37:57 <haasn> ReinH: I don't know. Doesn't an algebra imply some sort of laws?
17:38:01 * hackagebot http2 0.0.0 - HTTP/2.0 library including HPACK  http://hackage.haskell.org/package/http2-0.0.0 (KazuYamamoto)
17:38:08 <ReinH> haasn: Yeah, I guess pointed doesn't have laws
17:38:11 <Twey> (in fact, since Pointed applies to the f, I don't think it even makes sense to talk about elements)
17:38:57 <pyon> haasn: Well, a morphisms of pointed sets (f : X -> Y) maps the default element of X onto the default element of Y. I guess a "pointed algebra" maps pure onto pure.
17:39:37 <ReinH> so a forgetful T-algebra
17:39:44 <ReinH> (where you forget about the join-related laws)
17:52:22 <johnw> epta: still having problems?
17:58:04 * hackagebot GLFW-b 1.4.6 - Bindings to GLFW OpenGL library  http://hackage.haskell.org/package/GLFW-b-1.4.6 (BrianLewis)
17:58:50 <jle`> i wonder why p = (:[]) doesn't suffer from the monomorphism restriction in ghci
17:58:58 <jle`> let p = (:[])
17:59:11 <shachaf> No constraint.
17:59:48 <jle`> ah
18:00:41 <jle`> that makes sense. it cna't just pick an arbitrary type from the constraint, becuase there is no constraint
18:01:54 <shachaf> That's not a criterion for the MR.
18:02:15 <joejev> what exactly does this mean?  Exception: Prelude.chr: bad argument: 4294967295
18:02:15 <joejev>  
18:02:21 <shachaf> (I recommend looking at the Report.)
18:02:32 <Rarrikins> joejev: Probably that that's not a valid index for a character.
18:02:32 <jle`> shachaf: ok, sounds like a good place to start
18:02:34 <shachaf> It means what it says. Prelude.chr got a bad argument.
18:02:41 <ParahSailin_> ?chr 4294967295
18:02:41 <lambdabot> Maybe you meant: thx ghc echo arr
18:02:46 <ParahSailin_> >chr 4294967295
18:02:47 <Rarrikins> @thx
18:02:47 <lambdabot> you are welcome
18:03:13 <Rarrikins> > 2^32
18:03:14 <lambdabot>  4294967296
18:03:17 <geekosaur> joejev, looks like you managed to pass it a -1 which got interpreted at some level as unsigned?
18:03:28 <joejev> hmm, I am not sure why it would do that, thanks though
18:03:29 <Rarrikins> > maxBound :: Word32
18:03:31 <lambdabot>  4294967295
18:03:48 <jle`> > ord maxBound
18:03:49 <lambdabot>  1114111
18:04:44 <Rarrikins> Neat
18:04:58 <Rarrikins> > chr 1114112
18:05:00 <lambdabot>  *Exception: Prelude.chr: bad argument: 1114112
18:05:35 <jle`> > chr 1114111
18:05:36 <lambdabot>  '\1114111'
18:05:40 <jle`> wouldn't ya know
18:05:40 <ParahSailin_> > maxBound :: Char
18:05:41 <lambdabot>  '\1114111'
18:11:28 <pavonia> > text "\1114111"
18:11:29 <lambdabot>  ô¿¿
18:11:34 <jle`> why don't we just use Word as our Nat type
18:12:09 <Iceland_jack> > text "\9731"
18:12:10 <lambdabot>  â˜ƒ
18:12:18 <jle`> > text . return $ maxBound
18:12:19 <lambdabot>  ô¿¿
18:13:06 * hackagebot easyrender 0.1.0.0 - User-friendly creation of EPS, PostScript, and PDF files  http://hackage.haskell.org/package/easyrender-0.1.0.0 (PeterSelinger)
18:13:10 <jle`> just make all functions that can't take negative numbers, like indexes, and make them take a Word instead of an int
18:13:36 <Rarrikins> > 0x10ffff
18:13:37 <lambdabot>  1114111
18:16:24 <zacts> is there a #haskell-offtopic channel?
18:16:33 <jle`> zacts: #haskell-blah
18:16:45 <zacts> thanks
18:21:36 <stolaruk> Do I need only put the "-funbox-strict-fields" pragma inside the module where my types with bang patterns are defined?
18:28:44 <^guapo^> 03:17] ubottu: guapo: Help! Channel emergency! (ONLY use this trigger in emergencies) - elky, Madpilot, tritium, Nalioth, tonyyarusso, PriceChild, Amaranth, jrib, Myrtti, mneptok, Pici, jpds, gnomefreak, bazhang, Flannel, ikonia, maco, h00k, IdleOne, bkerensa, nhandler, Jordan_U, DJones or k1l!
18:29:03 <^guapo^> 03:17] ubottu: guapo: Help! Channel emergency! (ONLY use this trigger in emergencies) - elky, Madpilot, tritium, Nalioth, tonyyarusso, PriceChild, Amaranth, jrib, Myrtti, mneptok, Pici, jpds, gnomefreak, bazhang, Flannel, ikonia, maco, h00k, IdleOne, bkerensa, nhandler, Jordan_U, DJones or k1l!
18:29:04 <^guapo^> 03:17] ubottu: guapo: Help! Channel emergency! (ONLY use this trigger in emergencies) - elky, Madpilot, tritium, Nalioth, tonyyarusso, PriceChild, Amaranth, jrib, Myrtti, mneptok, Pici, jpds, gnomefreak, bazhang, Flannel, ikonia, maco, h00k, IdleOne, bkerensa, nhandler, Jordan_U, DJones or k1l!
18:29:09 <flebron> Err.
18:31:02 <Fuuzetsu> Channel emergency!
18:32:49 <ReinH> > maxBound `asTypeOf` 'c'
18:32:50 <lambdabot>  '\1114111'
18:38:44 <jle`> @src asTypeOf
18:38:44 <lambdabot> asTypeOf = const
18:38:57 <jle`> that's cute
18:43:09 * hackagebot DAV 0.6 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-0.6 (ClintAdams)
18:46:19 <johnw> hmm... const's type is a -> b -> a, but asTypeOf is a -> a -> a
18:46:37 <johnw> if you really used const, the type of the second argument wouldn't matter
18:46:49 <johnw> but you can define it as const with a type signature
18:47:28 <pavonia> Can you even do it without an explicit type signature?
18:47:45 <johnw> with an explicit type signature, it should fix b ~ a
18:48:41 <jle`> johnw: you have to explicitly define the type signature i think
18:49:04 <jle`> @let asTypeOf' = const :: (a -> a -> a)
18:49:06 <lambdabot>  Defined.
18:49:16 <jle`> :t asTypeOf'
18:49:17 <lambdabot> a -> a -> a
18:49:50 <johnw> i meant: asTypeOf :: a -> a -> a; asTypeOf = const
18:50:13 <jle`> yeah, i meant that; hard to do in lambdabot admittedly
18:50:17 <johnw> ah
18:50:19 <jle`> actually can you do that?
18:50:39 <jle`> @let showInt :: Int -> String; showInt = show
18:50:40 <shachaf> Puzzle: Write asTypeOf without an explicit type.
18:50:41 <lambdabot>  Defined.
18:50:45 <shachaf> (Not a difficult puzzle.)
18:50:49 <jle`> :t showInt
18:50:50 <lambdabot>     Ambiguous occurrence `showInt'
18:50:50 <lambdabot>     It could refer to either `L.showInt',
18:50:50 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:164:1
18:50:56 <jle`> oops
18:50:57 <shachaf> There's no need to use @let when you can just use let in >.
18:51:38 <jle`> > let showIntOnly :: Int -> String; showIntOnly = show in (show 5, show 5.0, show True)
18:51:40 <lambdabot>  ("5","5.0","True")
18:51:57 <jle`> > let showIntOnly :: Int -> String; showIntOnly = show in (showIntOnly 5, showIntOnly 5.0, showIntOnly True)
18:51:58 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
18:51:58 <lambdabot>              with actual type `GHC.Types.Bool'
18:52:23 <shachaf> (Also, you can /msg lambdabot for these sorts of things.)
18:52:27 * flebron wonders what an epimorphism restriction would be.
18:59:26 <johnw> > let asTypeOf' x y = head [x,y]
18:59:27 <lambdabot>  not an expression: `let asTypeOf' x y = head [x,y]'
18:59:39 <geekosaur> let ... in
18:59:45 <johnw> right
19:00:34 <oio> is there a way to prefer the functions of a module? over another?
19:00:54 <johnw> oio: no
19:01:04 <johnw> oio: you have to hide the others, or qualify the ones you want
19:01:13 <ion> Donâ€™t import the less-preferred module unqualified.
19:02:06 <pavonia> :t let asTypeOf' x y = const x (asTypeOf' y x) in asTypeOf'
19:02:07 <lambdabot> b -> b -> b
19:02:21 <johnw> ah, cool
19:02:43 <johnw> pavonia: I started thinking about recursively calling into asTypeOf, but then thought the head/list variant was easier to read
19:03:00 <johnw> but I hadn't fully finished my thoughts down that road, so thank you
19:03:30 <pavonia> hehe, took me some minutes too :)
19:07:36 <oio> how can i prefer functions from prelude than any other module?
19:08:55 <Iceland_jack> oio: You can't, you can however hide functions from the Prelude by doing
19:08:55 <Iceland_jack>     import Prelude hiding (lookup)
19:09:03 <Iceland_jack> It's not optimal but that's the way it is
19:09:12 <geekosaur> actually you can just import other modules qualified
19:09:18 <Iceland_jack> or import it qualified
19:09:21 <oio> the can i hide all the prelude functions?
19:09:24 <oio> then*
19:09:26 <Iceland_jack> oio: You wouldn't want to
19:09:49 <Clint> you can hide all but one
19:09:57 <geekosaur> you can explicitly import Prelude qualified as the first import, IIRC, which will override the default import
19:10:01 <Iceland_jack> If you have a few clashes you can hide them, otherwise you can import your module qualified
19:10:01 <Iceland_jack>     import qualified Data.List as L
19:10:18 <geekosaur> if what you're after is to make Prelude functions not be the default
19:10:28 <geekosaur> but then you need to qualify them to use them
19:13:58 <oio> i tough you could do import Prelude hiding AL;
19:14:01 <oio> ALL*
19:28:16 <rose> How can I print a string in ghci without the surrounding "" quotes?
19:28:28 <Iceland_jack> putStrLn "hello"
19:28:46 <Luke> does anyone build a version number into their binaries?
19:29:12 <Luke> I was thinking about using Shake to build an hs file with a version number in it before it builds the binary
19:29:55 <rose> Iceland_jack: when I replace print with putStr, I get this error: Couldn't match type `Value' with `[Char]'. How can I resolve it?
19:30:06 <rose> Where Value is defined in Data.Bson
19:30:10 <Iceland_jack> rose: putStrLn only works on String
19:30:25 <rose> yep, so how can I turn my Value into a String?
19:30:33 <Iceland_jack> @src print
19:30:33 <lambdabot> print x = putStrLn (show x)
19:30:35 <Iceland_jack> You can use show
19:30:40 <Iceland_jack> which is exactly what
19:30:42 <Iceland_jack> â€˜printâ€™ does
19:30:49 <Iceland_jack> > show 10
19:30:50 <lambdabot>  "10"
19:30:50 <rose> that keeps the "", right?
19:30:52 <jle`> i think he doesn't want the "" that show gives
19:30:52 <Iceland_jack> > putStrLn (show 10)
19:30:53 <lambdabot>  <IO ()>
19:31:12 <Iceland_jack> rose: There is not â€˜""â€™, that's not a part of the string
19:31:15 <Iceland_jack> *is no
19:31:33 <jle`> show basically returns a string representation of the item you are showing.  so a string representation of a string is the string literal, with the ""'s.
19:31:36 <rose> putStrLn "hey"
19:31:39 <Iceland_jack> When you run â€˜putStrLn "..."â€™ the quotes don't show
19:31:41 <rose> > putStrLn "hey"
19:31:42 <lambdabot>  <IO ()>
19:31:51 <Iceland_jack> rose: You need to use your own ghci for IO actions
19:32:02 <rose> what do you mean?
19:32:05 <jle`> putStrLn doesn't `show`, it just puts the actual string, not the strong representation of the string
19:32:20 <jle`> rose: lambdabot doesn't execute IO objects
19:32:22 <Iceland_jack> rose: putStrLn "hey" is an IO action, that's why you get <IO ()> back
19:32:26 <rose> alright, so I just need a way to convert a Value to a String without using show
19:32:26 <jle`> it only evaluates them
19:32:36 <Iceland_jack> rose: You're misunderstanding something here
19:33:44 <haasn> luite_: could we get a version of http://hdiff.luite.com/gloss/styrene/ etc. compiled with a to-date ghcjs up and running sometime soon?
19:33:46 <Iceland_jack> > undefined :: IO () -- Seems like it doesn't evaluate them ;)
19:33:47 <lambdabot>  <IO ()>
19:33:58 <jle`> rose: you want to pattern match out the text
19:34:07 <haasn> luite_: the performance on it is a bit abysmal, I hear newer ghcjs has far more optimizations
19:34:10 <rose> cool, how?
19:34:10 <jle`> Iceland_jack: that's interesting :)
19:34:16 <Iceland_jack> It just checks the type
19:34:27 <Iceland_jack> jle`: Pattern match out the text?? What do you mean
19:34:27 <jle`> let (Text myText) = myValue
19:34:35 <Iceland_jack> Ah.
19:34:38 <jle`> Iceland_jack: he has a Data.Bson.Value
19:34:47 <haasn> luite_: also the source link 404s
19:34:54 <jle`> so then you get out the Text
19:34:55 <Iceland_jack> I thought you mean having a "\"...\"" and removing head an tail
19:35:11 <jle`> and...i think you have to unpack it before printing it?
19:35:25 <jle`> can someone help me here
19:35:46 <Iceland_jack> jle`: People have been and are helping you, there's no need to request it
19:36:15 <jle`> my bad; i meant that to say "someone else can take the baton here, i'm not familiar with how to print out Text's"
19:36:39 <Iceland_jack> @hoogle Text -> IO ()
19:36:39 <lambdabot> Data.Text.IO putStr :: Text -> IO ()
19:36:39 <jle`> i would just do putStrLn . T.unpack $ myText i think
19:36:39 <lambdabot> Data.Text.Lazy.IO putStr :: Text -> IO ()
19:36:39 <lambdabot> Data.Text.IO putStrLn :: Text -> IO ()
19:36:45 <Iceland_jack> jle`:  â†‘ there you go
19:36:49 <jle`> cool thanks :)
19:36:54 <Iceland_jack> You can use @hoogle in the future
19:41:51 <rose> How can I pattern match like this: let (Text myText) = myValue   when myValue is List?
19:42:49 <haasn> rose: what's List and Text?
19:42:55 <Iceland_jack> http://hackage.haskell.org/package/bson-0.1.1/docs/Data-Bson.html I suppose
19:43:07 <jle`> haasn: it's a Bson data constructor
19:43:07 <rose> [Text]
19:43:17 <jle`> (actually [Value])
19:43:28 <rose> yes
19:43:35 <jle`> but you want [B.Value] -> [T.Text]
19:43:39 <rose> correct
19:43:57 <haasn> this is where we need prisms
19:44:00 <haasn> s/need/want/
19:44:03 <haasn> s/want/should have/
19:44:30 <Iceland_jack> jle`: I see a String constructor but no â€˜textâ€™ there
19:45:02 <Iceland_jack> jle`: I apologize, I was looking at an old version of the package
19:45:23 <jle`> Iceland_jack: you're still right though
19:45:27 <jle`> the constructor is String
19:45:30 <Iceland_jack> Yes
19:45:36 <Iceland_jack> For a single (val :: Value) you can pattern match on String yes
19:45:41 <jle`> sorry rose
19:45:58 <jle`> without prisms you can define a function getString (String t) = t
19:46:00 <Iceland_jack> rose: You can do [ text | String text â† myVals ]
19:46:11 <haasn> Iceland_jack++
19:46:13 <rose> thanks
19:46:22 <jle`> that's pretty nice
19:46:29 <haasn> that one's really elegant
19:46:32 <jle`> gj
19:46:45 <jle`> :)
19:46:50 <Iceland_jack> ty ty
19:47:24 <jle`> rose: be aware that this is a partial match though, so be careful
19:47:35 <haasn> Iceland_jack's fails gracefully
19:47:40 <rose> jle' what do you mean?
19:47:41 <jle`> oh really?
19:47:44 <jle`> that's sweet
19:47:57 <haasn> > [x | Just x <- [Just 3, Just 4, Nothing, Just 5]]
19:47:59 <lambdabot>  [3,4,5]
19:47:59 <Iceland_jack> > [ x | Left x â† [Left 1, Right 2, Left 3, Right 4] ]
19:48:00 <lambdabot>  [1,3]
19:48:02 <Iceland_jack> Hey!
19:48:11 <jle`> that's awesome
19:48:17 <jle`> hm.
19:48:24 <haasn> > fail "Pattern match failure" :: [Int] -- jle`
19:48:26 <lambdabot>  []
19:48:29 <Iceland_jack> When a pattern match failure occurs, â€˜failâ€™ is invoked
19:48:32 <Iceland_jack> which is []
19:48:35 <jle`> yeah i was suspecting that
19:48:58 <jle`> > do { Left x <- Right 1; return x }
19:48:59 <lambdabot>  Could not deduce (GHC.Num.Num (Data.Either.Either b t0))
19:49:00 <lambdabot>    arising from the ambiguity check for `e_11'
19:49:00 <lambdabot>  from the context (GHC.Num.Num (Data.Either.Either b t))
19:49:00 <lambdabot>    bound by the inferred type for `e_11':
19:49:00 <lambdabot>               GHC.Num.Num (Data.Either.Either b t) => Data.Either.Either a b
19:49:14 <jle`> er...i get the picture.
19:49:40 <dazed_and_amused> > getLine
19:49:41 <lambdabot>  <IO [Char]>
19:50:12 <jle`> Either's fail is an exception anyway
19:50:17 <haasn> > do { Left x <- [Left 1, Left 2, Right 3, Left 4]; return x }
19:50:18 <lambdabot>  [1,2,4]
19:50:23 <Iceland_jack> @src Either fail
19:50:24 <lambdabot> fail msg      = Left (strMsg msg)
19:50:39 <jle`> yeah haasn's makes sense
19:51:25 <Hodapp> University of Illinois computer science department... thumbs up or down?
20:06:08 <robonerd> does anyone know how people can give you a web link to the channel chat log, back to a specific line? and they can search the log, and when they find the line they want to quote, get a link to that precise line
20:06:55 <robonerd> i'm in a community with devs of bitcoin/*coin software and services in #coindev and we have a domain coindev.org and we want to now set up channel logging
20:07:02 <robonerd> iirc this place had a powerful bot
20:07:47 <Hodapp> robonerd: https://github.com/Hive13/jIRCBot is a somewhat home-spun bot for my hackerspace which does this.
20:08:42 <robonerd> thanks
20:08:54 <Hodapp> I'm not sure what this has to do with Haskell though...
20:11:26 <robonerd> sorry
20:32:10 <dazed_and_amused> I'm trying to write a small program to select a random song from my music folder and play it.
20:32:44 <dazed_and_amused> I've searched hoogle a bit, specifically the Directory module, and I'm wondering what the best way to select a random song would be
20:33:29 <Iceland_jack> dazed_and_amused: Do you have trouble with a specific part of the problem? What have you got so far?
20:33:30 <dazed_and_amused> the only thing i can think of so far is find the number of folders in music, generate a random number from it and travel to that directory. then execute a shell command playing that song
20:33:42 <robonerd> does #haskell public log the channel?
20:33:44 <Iceland_jack> That sounds reasonable enough
20:33:53 <ion> robonerd: Please see the topic.
20:33:54 <Iceland_jack> @hoogle getDirectoryContents
20:33:55 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
20:34:16 <Iceland_jack> @hoogle randomRIO
20:34:16 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
20:34:30 <robonerd> sorry
20:34:56 <dazed_and_amused> Thanks, I figured as much. I actually had both of those functions in mind, I was just wondering if there was a better way to do it
20:35:22 <Iceland_jack> I mean I'm sure there is some library on Hackage that selects a random file in a directory
20:35:26 <Iceland_jack> @hackage shuffle
20:35:26 <lambdabot> http://hackage.haskell.org/package/shuffle
20:35:32 <Iceland_jack> That might be it
20:35:45 <Iceland_jack> Hm I suppose not
20:36:03 <Iceland_jack> I don't see how much simpler you're hoping the problem could get though dazed_and_amused
20:36:11 <Iceland_jack> get files â†’ pick file â†’ play file
20:37:01 <dazed_and_amused> Yeah, I just didnt know if there was some haskell kung-fu you guys knew about that would cut down the steps
20:37:02 <Iceland_jack> @hackage randfile -- dazed_and_amused: This seems to be what you want
20:37:02 <lambdabot> http://hackage.haskell.org/package/randfile -- dazed_and_amused: This seems to be what you want
20:37:06 <dmj`> is there a way to tell if my GHC install is 32 or 64 bit? Suppose I didn't know what haskell platform I downloaded
20:37:47 <dazed_and_amused> Iceland_jack: Wow, thats perfect, thanks!
20:37:58 <maxcan> are there any updated estimates for the GHC 7.8 release date?
20:38:03 <Iceland_jack> There is also:
20:38:04 <Iceland_jack> @hoogle system
20:38:05 <lambdabot> System.Process system :: String -> IO ExitCode
20:38:05 <lambdabot> System.Cmd system :: String -> IO ExitCode
20:38:05 <lambdabot> package system-argv0
20:38:06 <geekosaur> on linux, file will tell you whether the ghc executable (which is not the one in your bin directory) is 32 or 64 bit
20:38:13 <maxcan> the track tickets barely seem to be moving
20:38:16 <maxcan> trac
20:38:17 <Iceland_jack> for simply running an executable
20:38:34 <Iceland_jack> but there are more nuanced ways of doing so depending of the level of granularity required
20:38:35 <geekosaur> the thing in your bin directory is a shell script, you can read it to find out where the real executable is and then run file on that
20:39:05 <Iceland_jack> dazed_and_amused: If you need to manipulate stdin/stdout you may want to look at System.Process
20:39:36 <geekosaur> on windows, I suspect the properties would tell you that but I don't know if you need to find the real ghc or if the one in %PATH% is the real one
20:41:00 <dmwit> dazed_and_amused: find /path/to/music -print0 | sort -zR
20:41:01 <dmwit> ;-)
20:41:25 <Iceland_jack>     system "mplayer $(ls ~/music/*.mp3 | shuf -n1)"
20:41:34 <dmj`> geekosaur: big thanks, looks like the haskell platform for windows doesn't have a 32 or 64 bit choice, but the install directory is in Program File (x86), which would make it 32-bit then right?
20:41:41 <Iceland_jack> there you go! Haskell saves the day again
20:41:45 <geekosaur> yes
20:41:48 <dmwit> Iceland_jack: Wow, why does shuf exist.
20:41:53 <Sgeo> Is plugins package the recommended way to write code that takes plugins these days?
20:42:06 <geekosaur> actually I think a 64 bit one for windows is in the works somewhere
20:42:11 <dmj`> geekosaur: so then there would be no 64-bit ghc for windows then?
20:42:13 <dmj`> ah
20:42:39 <geekosaur> where is that haskell industry consortium thing
20:42:41 <dmwit> Iceland_jack: Also, yours is broken in several ways. =)
20:43:01 <Iceland_jack> dmwit: Like how?
20:43:02 <Hodapp> alright, Idris looks interesting
20:43:14 <Hodapp> even me not knowing much about dependent typing, it looks pretty accessible.
20:43:20 <dmwit> Iceland_jack: Like if file names contain newlines.
20:43:26 <dmwit> Iceland_jack: Or like if there are subdirectories.
20:43:33 <geekosaur> hm, supposedly been there since 7.6.1?
20:43:45 <Iceland_jack> Yes well if you have songs with newlines then you deserve that now don't you?
20:43:48 <dmwit> Iceland_jack: Or like if there are more files than will fit in a command line buffer.
20:43:54 <dmwit> Iceland_jack: No. Fix your code.
20:44:02 <Iceland_jack> I won't
20:44:16 <dmwit> Why? It's easy. I already pasted a correct version.
20:44:33 <dmwit> You can even stick with shuf instead of sort if you prefer.
20:44:40 <Iceland_jack> Fix *what* code exactly? I pasted it as a joke
20:44:41 <dmwit> find ~/music -print0 | shuf -zn1
20:44:41 <geekosaur> dmj`, looks like ghc itself is available for x86-64, but there's no platform release for it
20:45:08 <geekosaur> this may reflect unavailability of contributors of platform packages
20:45:47 <dmwit> You can even add -name '*.mp3' if you really want to rule out all my FLACs and OGGs. =(
20:45:59 <Iceland_jack> geez
20:46:01 <dmj`> geekosaur: I see, so the platform has only 32-bit available. There is a link here for a 7.6.3 Win64 GHC. http://www.haskell.org/ghc/dist/7.6.3/ghc-7.6.3-x86_64-unknown-mingw32.tar.bz2
20:46:08 <geekosaur> yes
20:46:18 <dmj`> Might try to overwrite the libs
20:47:02 <dmj`> geekosaur: thanks for the help, trying to get HsOpenSSL installed w/ the 64-bit openssl libs
20:47:08 <geekosaur> better bet is probably to install the x64 ghc, bootstrap cabal-install, and then install the platform yourself via https://github.com/haskell/haskell-platform/blob/master/haskell-platform.cabal
20:48:06 <geekosaur> although I don't know if there's a bootstrap that works on windows; the one I'm aware of is a shell script >.>
20:48:52 <dmj`> geekosaur: might as well try, I'm using cygwin and have emacs running
20:49:28 <geekosaur> well, yes. but it also refers to the unix package, which won't help you too much even with cygwin :)
20:50:40 <lightquake> fast and unmaintained vs slow and correct. a terrible tradeoff
20:50:45 <S11001001> @pl \x a b -> b x
20:50:45 <lambdabot> const . flip id
20:50:47 <dmj`> ah, this is true. Could it substituted for unix-compat?
20:50:55 <dmj`> it be*
20:51:00 <GGMethos> ll
20:51:20 <Clint> edwardk: this is your scheduled adjunctions harassment
20:51:38 * edwardk hits the snooze alarm until wednesday. ;)
20:51:55 <edwardk> but noted =)
20:52:53 <Clint> edwardk: next up, should i be using orphan instances for MonadBase/MonadTransControl/MonadBaseControl EitherT.. or can they go somewhere?
20:53:14 <edwardk> for now i think the have to be orphaned
20:53:22 <Clint> ok, thanks
20:53:23 <geekosaur> dmj`: I don't really know, unfortunately
20:53:35 <edwardk> either has rather '98
20:53:44 <edwardk> er rather '98'ish dependencies for now
20:54:17 <geekosaur> I'm a unix type, not sure I've ever used a compiler under windows (unless you count djgpp on desqview+win3.1)
20:54:49 <edwardk> Clint: if you sent a patch/put in an issue odds of them appearing in the package would dramatically increase though ;)
20:55:36 <Clint> edwardk: a patch which adds a dep on monad-control?
20:56:23 <edwardk> it'd at least let folks have the discussion on the issues list. tekmo'd probably be the voice that made or broke it, as he is the major consumer of either at this point with errors
20:56:37 <Clint> ok, will do
20:56:39 <joejev> how big is Nothing, for example, if I make an array of length 10000 filled with Nothing, will it be very small or no?
20:56:54 <edwardk> joejev: there is only one "Nothing
20:57:17 <edwardk>  you'd have a list of 10000 pointers to the same object in memory
20:57:59 <joejev> edwardk: okay, so that is is not bad
20:58:19 <Clint> edwardk: er, github doesn't have 4.0?
20:59:26 <edwardk> let me push
20:59:38 <dmwit> joejev: (...in GHC)
21:00:16 <edwardk> Clint: done
21:00:31 <Clint> edwardk: thanks
21:11:55 <Clint> edwardk: and there you go
21:11:57 * Clint runs away
21:12:37 <edwardk> clint: thanks!
21:14:13 <apples> edwardk, do you have plans to break out Control.Functor.HigherOrder from category-extras?
21:14:33 <gamegoblin> In cabal, can exposed modules make use of unexposed modules?
21:14:35 <edwardk> apples: github.com/ekmett/indexed will eventually replace the existing indexed and has it
21:14:47 <edwardk> among a bunch of other stuff
21:15:14 <apples> cool, i'll check it out
21:22:44 <enthropy> gamegoblin: if they're in the same package
21:23:43 <gamegoblin> enthropy: I have a module called Lambdalearn.Util.Util and another called Lambdalearn.Containers.Matrix, and when the Util file is not exposed, I get weird unknown symbol parse errors, when it is exposed, it works fine
21:24:10 <enthropy> do you have a   other-modules: Lambdalearn.Util.Util ?
21:24:23 <gamegoblin> Mmmmm that might do it...
21:25:10 <Fuuzetsu> you need to have every single one of your (used) modules in your cabal file, be it under exposed-modules or other-modules
21:25:18 <gamegoblin> enthropy: works now, thanks
21:25:20 <Fuuzetsu> otherwise you get arcane linking errors
21:26:01 <gamegoblin> Yeah I was getting unknown symbol `lambdalearnzm0zi1zi0zi0_LambdalearnziUtilziUtil_shuffle1_closure'
21:26:13 <gamegoblin> Which seems to have inserted a lot of z's and other nonsense into the path...
21:26:39 <Fuuzetsu> Sounds about right.
21:29:28 <enthropy> preflex: zdec lambdalearnzm0zi1zi0zi0_LambdalearnziUtilziUtil_shuffle1_closure
21:29:30 <preflex>  lambdalearn-0.1.0.0_Lambdalearn.Util.Util_shuffle1_closure
21:41:36 <marx2> did anyone get Gtks's TreeView working with both Filter and Sort Models?  after stacking the two models together I am getting "invalid cast from `GtkTreeModelFilter' to `GtkTreeSortable'" every time I click on a column header.
21:54:31 <volko> in this kind of function definition
21:54:31 <volko> useArrayAsync (Array !sh !adata) ms = run doUse
21:54:45 <volko> how does ! change things?
21:55:19 <augur> iinm, it means the arguments sh and adata must be strict
21:55:41 <byorgey> volko: that is a bang pattern, it forces evaluation of sh and adata to weak head normal form when the pattern is matched
21:56:49 <gamegoblin> Is there a way to import all modules in a package?
21:57:31 <byorgey> gamegoblin: nope
21:57:38 <gamegoblin> Sadness
21:57:55 <gamegoblin> Importing a billion things into ghci to do some repl testing is frustrating...
21:59:42 <augur> hey byorgey, any new species stuff worth reading? :D
22:07:18 <byorgey> augur: there will be soon.
22:07:33 <augur> byorgey: dissertationally so?
22:07:39 <augur> or are you done with that?
22:07:42 <byorgey> working on a paper to submit to MSFP at the moment
22:07:42 <augur> i dont remember
22:07:47 <augur> fun
22:07:50 <augur> MSFP?
22:08:02 <byorgey> (and the paper will turn into a chapter of my dissertation or something like that)
22:08:18 <volko> Where does arrays come from here?
22:08:19 <volko> Use arrs                -> use (arrays (undefined::arrs)) arrs >> node (pure $ Use arrs)
22:08:25 <byorgey> http://www.cs.bham.ac.uk/~pbl/msfp2014/
22:09:46 <augur> ahhhh ok
22:48:01 <epta> When 7.8 will be released?
22:48:27 <ion> â€œsoonâ€
23:36:17 <bz> can't use pointed notation in pattern matching, right?
23:38:46 <dmj`> bz: how do you mean?
23:39:26 <dmj`> bz: like case Just 4 of { Just -> print; Nothing -> print "nothin" }
23:39:39 <dmj`> where Just is point free
23:39:43 <bz> dmj`: f (Outer $ Inner x y) = ...
23:40:02 <bz> dmj`: f (Outer (Inner x y)) = ...
23:40:28 <bz> that's a function declaration
23:42:38 <dmj`> bz: I think the second example you pasted is allowed, but not the first
23:42:46 <dmj`> bz: is Outer a record type?
23:47:09 <bz> dmj`: yes
23:58:42 <jle`> you can only use data contructors?
23:59:23 <jle`> similarly you can't use something like $ in your type signatures
