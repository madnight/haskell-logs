00:02:11 <Saizan> mh, sounds like a job for case-split and maybe something that sets up the recursive calls too
00:02:26 <Saizan> i.e. something IDE style rather than in-language
00:16:56 * hackagebot fpco-api 1.0.4 - Simple interface to the FP Complete IDE API.  http://hackage.haskell.org/package/fpco-api-1.0.4 (ChrisDone)
00:16:56 * hackagebot quickcheck-instances 0.3.5 - Common quickcheck instances  http://hackage.haskell.org/package/quickcheck-instances-0.3.5 (AntoineLatter)
00:21:52 * hackagebot tpdb 0.8.2 - Data Type for Rewriting Systems  http://hackage.haskell.org/package/tpdb-0.8.2 (JohannesWaldmann)
00:27:03 <rose__> I have a question about getting [String] out of IO (Maybe [String]) here: http://lpaste.net/97204
00:27:41 <augur> board size = 8 for n-queens is the first interesting board size
00:27:51 <blaenk> agreed
00:27:54 <bz> hm
00:28:04 <ion> Heh, i like how arbitraryBoundedEnum uses asTypeOf to the other direction than usual. http://hackage.haskell.org/package/quickcheck-instances-0.3.5/docs/src/Test-QuickCheck-Instances.html#line-377
00:28:07 <augur> oh maybe its not
00:28:08 <QF-MichaelK> augur: Why?
00:28:16 <bz> i wonder if strong typing would affect the performance of generated code
00:28:17 <blaenk> augur: it is, stand your ground
00:28:17 <QF-MichaelK> I think 4 is the first interesting one
00:28:18 <augur> oh yes, i think it is
00:28:22 <blaenk> :)
00:28:34 <pqmodn> rose__: you cannot unwrap IO, see the Haskell FAQ: http://www.haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
00:28:41 <augur> QF-MichaelK: because for n < 7, the solutions are all regular grids
00:28:50 <augur> and for 8, afaict, all the solutions are irregular
00:28:50 <ion> rose: In do { x <- foo :: IO (Maybe [String]); … }, x :: Maybe [String]. You can then figure out what to do with the two possible cases for Maybe.
00:29:18 <QF-MichaelK> augur: Ah, ok, sufficient reasoning, thanks for elaborating.
00:29:59 <augur> http://www.math.utah.edu/~alfeld/queens/all.gif
00:30:04 <QF-MichaelK> augur: In that case though, most board sizes aren't interesting since you can just trivially stair case larger sizes
00:30:04 <augur> those are all the solutions for N=8
00:30:08 <pqmodn> rose__: you can lift ordinary values into IO using return though
00:30:34 <augur> QF-MichaelK: maybe, i dont know. the same solutions arent necessarily available for larger sizes as for smaller sizes
00:30:54 <augur> http://www.cs.usfca.edu/~galles/visualization/RecQueens.html -- speed it up (bottom slider) and look at N=4..7
00:31:50 <augur> all the solutions found first using the naive brute force algo are also _the_ grid solution
00:32:01 <rose__> I tried using <- to get the Maybe out of IO, but that produced a parse error: http://lpaste.net/97204 What's wrong?
00:33:04 <ion> rose: Please paste the full code and the full error.
00:33:34 <bz> can't use <- in a let block
00:33:47 <bz> or a where block
00:33:59 <QF-MichaelK> augur: http://en.wikipedia.org/wiki/Eight_queens_puzzle#Explicit_solutions
00:34:04 <quchen> First paste the code with correct indentation.
00:34:08 <Ralith> also your alignment is all over the place
00:35:37 <augur> QF-MichaelK: yep
00:35:57 <augur> 9 is again interesting
00:35:58 <augur> 10 is not
00:37:36 <QF-MichaelK> augur: Hmmm seems like the same pattern to me, just stairs... same thing all the way from 4, just look at it toroidally maybe?
00:37:58 <augur> QF-MichaelK: but for 8, the stairs arent regularly spaced on the torus
00:38:18 <augur> 1 over, 2 up, one over, 1 up, one over 2 up, one over 5 up
00:38:25 <augur> there's this big jump
00:38:31 <augur> you cant make a grid out of all the points
00:40:18 <rose__> ion: I updated my question here http://lpaste.net/97204
00:40:40 <ion> rose: You can only use <- like that in a do block.
00:41:53 * hackagebot wai-routes 0.4.0 - Typesafe URLs for Wai applications.  http://hackage.haskell.org/package/wai-routes-0.4.0 (AnupamJain)
00:42:05 <rose__> ion: The whole block is a do block... how do I introduce a do block within the do block?
00:42:48 <ion> rose: It’s in a let block. The let block happens to be in a do block but that isn’t relevant from the parser’s point of view.
00:43:33 <ion> rose: Would indenting the <- line back to the do block’s level of indentation help?
00:43:59 <QF-MichaelK> augur: 8 and 9 are the same solution but 9 has a queen in the top right
00:44:08 <augur> QF-MichaelK: yes?
00:44:28 <ion> rose: Btw, it’s much better to use pattern matching to determine an empty list: case something of { [] -> …; _ -> … }
00:44:31 <augur> its still not a grid
00:44:52 <ion> rose: length will need to traverse the entire list.
00:45:23 <QF-MichaelK> augur: sure, I'm not saying it is, I still don't quite see how to easily step for the 8, the 10 seems so much clearer...
00:45:25 <quchen> rose__: Also http://lpaste.net/97204
00:45:32 <quchen> … see annotations below
00:45:39 <augur> QF-MichaelK: there is no such solution for 8.
00:45:46 <augur> thats the point. thats why 8 is the first interesting case
00:47:01 <dp_wiz> Just looking at #haskell helps me to fix my type errors.
00:54:10 <rose__> quchen: thank you! I have another question about getting a value out of a monad here: http://lpaste.net/97209.
00:55:22 <ion> rose: exec is an IO action. You need to use it in the outer “do” block, not the “let” block. res <- case statement of { [] -> return ""; _ -> exec statement }
00:55:33 <QF-MichaelK> augur: fair enough, you've got a point, it is weird.
00:57:44 <ion> rose__: Oh, wait, you’re doing that in “results <- res”. That’s redundant if you move the “let res …” to “res <- …”. The problem here is that "" doesn’t have the same type as exec statement. Can you think of a value that would have the type IO (Maybe [String])? Hint: a value of type IO (Maybe a) will be appropriate.
00:58:01 <augur> QF-MichaelK: the n-knights problem is much more interesting, imo
00:58:32 <augur> QF-MichaelK: it has an extremely clever solution space
00:58:44 <QF-MichaelK> augur: I never looked at the solution space
00:59:07 <QF-MichaelK> augur: maybe I don't want to, I should probably try it out by hand for fun...
00:59:13 <augur> QF-MichaelK: yeah try it
00:59:32 <augur> for various chess board izes, see how many knights you can get on maximally
00:59:38 <augur> its absolutely clever
01:00:04 <augur> the solution you want to arrive at is very out-of-the-box
01:00:09 <QF-MichaelK> You need at least a board size 4?
01:00:32 <augur> nope, you can do it on any board size.
01:00:58 <QF-MichaelK> hmmm?  wait which n-knights problem are you discussing?
01:01:13 <QF-MichaelK> wait, I was thinking knight's path problem
01:01:25 <QF-MichaelK> http://en.wikipedia.org/wiki/Knight's_tour
01:01:26 <augur> "how many knights can you fit on an N-by-N chessboard without capturing"
01:01:35 <augur> that problem, whatever its called
01:01:59 <QF-MichaelK> ah, yeah, I was mixed up, sorry.
01:04:04 <QF-MichaelK> 1,4,5,.. 8x8 hmm at least 24
01:04:06 <augur> its not quite n-queens, since n-queens isnt asking for max, but rather for equal-to-board-size
01:04:46 <QF-MichaelK> 64 if they're all the same color ^.^
01:04:55 <augur> lol
01:05:08 <augur> above some board size, the answer is N^2/2
01:05:14 <augur> (rounded up)
01:05:29 <augur> a knight can only capture on an opposite color square
01:05:38 <augur> so if all the knights are on the same color, there are no captures
01:06:01 <augur> its extraordinarily clever, because you have to make this insight about capture color
01:06:17 <augur> it relates to the mutilated chessboard in a way
01:06:28 <QF-MichaelK> augur: ah, yeah, fun
01:06:29 <augur> dana scott had a presentation at OPLSS one year, about the question "what is a proof"
01:07:07 <augur> and he observed that the mutilated chessboard is very easy to solve if you add certain structure to the problem
01:07:13 <augur> namely, the colors of the chessboard
01:07:30 <augur> the same is true here -- without the colors, the knight capture problem is harder to answer
01:07:41 <augur> or its harder to make the leap
01:08:50 <QF-MichaelK> I tried a few shapes in my head, only so far I could go without actual pieces to look at
01:08:53 <augur> i bought a couple of books of "logic puzzles" to look through and try to see how these clever solutions work. "clever solutions" seem to be the bread and butter of what we call genius, so if we could somehow figure out techniques or heuristics for finding clever solutions, we could make genius computer
01:08:54 <augur> s
01:09:16 <QF-MichaelK> Yup, pretty much
01:09:50 <QF-MichaelK> Automated proof solvers are vaguely in that direction
01:09:54 <augur> we can make computers that brute force search, or that use certain well-understood clever solutions that people found (e.g. verifications, as found by gerhard gentzen)
01:10:26 <augur> but the proof domain there is pretty weakly structured
01:11:03 <QF-MichaelK> Yeah, I don't see how to systematically traverse "proof space"
01:11:28 <augur> oh its easy: try everything!
01:11:40 <augur> but thats hard, because of infinities in the space
01:12:04 <augur> gentzen's verifications were a convenient way of eliminating a lot of infinities
01:12:07 <companion_cube> you can encode the problem in first order logic, and try some automated prover
01:12:18 <companion_cube> but it's only semi decidable
01:13:01 <augur> companion_cube: yeah but the point is that the insightful solution isn't like that
01:13:22 <companion_cube> oh, if you want "insightful" then you need an AI
01:13:35 <QF-MichaelK> even automating traversals of a few definitions/theorems is tough
01:13:37 <augur> the mutilated chessboard, or the knights problem, these solutions are insightful because they rely on some sort of observed lemma which makes the whole thing vastly simpler
01:14:07 <augur> you're trying to prove P, you "insightfully" observe that Q -> P and that Q is easy
01:14:17 <QF-MichaelK> companion_cube: an AI proof solver, that sounds like a sufficiently hard challenge...
01:14:31 <augur> irritatingly, this is precisely the opposite of gentzen's insights
01:14:49 <augur> companion_cube: and yeah, you sort of "need" an AI, but thats kind of the point
01:15:30 <augur> if we understood what human insight was doing, or at least if we understood some heuristics for finding what we would call "insightful" solutions, we'd have a sort of mini-AI for certain problem domains
01:15:41 <QF-MichaelK> I still don't quite have a feel over the difference between ML and AI... seems like ML is data driven and AI is pattern driven...
01:15:50 <companion_cube> but it's not very interesting to have domain-specific AI, imho
01:15:59 <companion_cube> you end up with chess AIs that can't do anything else
01:15:59 <augur> companion_cube: really? im pretty sure mathematicians wouldnt mind it
01:16:09 <QF-MichaelK> companion_cube: depends on the domain
01:16:10 <companion_cube> well, depends on how narrow the domain is
01:16:19 <QF-MichaelK> hah
01:16:22 <augur> i mean, a math-AI that can have insightful solutions would be highly desirable
01:16:34 <companion_cube> well sure, a math AI would be great
01:16:49 <augur> imagine if you had a really good math-AI, or at least an efficient one. then you could try to solve Fermat's last theorem _elegantly_
01:17:00 <companion_cube> I think I read something about a prover that tries to find human-like proofs for mathematics
01:17:05 <augur> after all, the whole point of the AI is to find elegant solutions, not ugly ones
01:17:29 <QF-MichaelK> That's why I'm learning haskell... I may be going in the wrong direction, but I was told to go learn category theory and I figured I'd start here
01:17:30 <augur> but as dana scott asked, "what is a proof?"
01:17:35 <augur> because it depends on what counts as a proof
01:17:42 <yitz> companion_cube: it's more interesting to have domain-specific AI than non-domain-specific, because the former works and the latter doesn't.
01:17:47 <yitz> so far
01:17:50 <augur> the knights/mutilated chessboard answers werent proofs to Dijkstra
01:17:59 <augur> but they're gestures towards proofs that are convincing enough
01:18:12 <companion_cube> yitz: but the domain specific AI are hardly AI :(
01:18:27 <augur> yitz: good AI doesnt exist yet, even domain-specifically
01:18:36 <augur> i would argue, anyway
01:18:36 <yitz> companion_cube: they're all we have, after 50 years of effort.
01:18:48 <companion_cube> and that's why it's not satisfying
01:18:57 <yitz> augur: i didn't say good. i said works. it's useful at least.
01:19:02 <augur> yes thats true
01:19:09 <augur> most current techniques build in insights
01:19:11 <augur> which is fine
01:19:13 <companion_cube> but we don't have mathematical AIs at all
01:19:21 <augur> but the ideal is to find insights when needed
01:19:23 <QF-MichaelK> wonder if there's something relevant here
01:19:24 <QF-MichaelK> http://aitopics.org/
01:19:40 <augur> we need a sort of meta-insight: we want to build in the insight of "how insights are found"
01:19:59 <augur> obviously, the smart goal is to make it general, so that you could get positive feedback
01:20:34 <QF-MichaelK> I don't know enough about math to have a reasonable conversation in this direction, but I wish I did.
01:21:01 <augur> me neither D:
01:21:25 <companion_cube> http://www.foundalis.com/res/diss_research.html  interesting domain-specific AI, btw
01:21:34 <companion_cube> (on Bongard's problems)
01:21:36 <yitz> augur: perhaps if we had a really good general semantic data store - say, like google's search db, but semantic - then perhaps we could start empirically trying different kinds of pattern search and start seeing what works
01:21:54 <augur> i doubt that would be useful at all
01:25:45 <QF-MichaelK> companion_cube: curious, thanks
01:27:01 <companion_cube> the author did a PhD with Hofstadter on the issue, but never released his source code :(
01:28:48 <QF-MichaelK> companion_cube: probably got hired into some private company
01:29:32 <QF-MichaelK> Too bad more PhDs don't release their code
01:31:24 <QF-MichaelK> His bio is weird
01:36:15 <jle`> is there some kind of standard library function for f p x = guard (p x) >> return x
01:36:17 <jle`> ?
01:36:58 * hackagebot kickchan 0.1.0.3 - Kick Channels: bounded channels with non-blocking writes  http://hackage.haskell.org/package/kickchan-0.1.0.3 (JohnLato)
01:37:04 <jle`> hm mfilter matches the type
01:37:48 <jle`> actaully it doesn't :|
01:38:33 <jle`> hm it seems to work if i pass in mfilter p (return x)
01:39:59 <jle`> but if i'm going to have to write return x anyways i do'nt see the main verbosity advantage, besides making it one line
01:40:54 <supki_> :t \p x -> x <$ guard (p x)
01:40:54 <lambdabot> (Functor f, MonadPlus f) => (a -> Bool) -> a -> f a
01:40:56 <jle`> guard (p x) >> return x just turns into mfilter p (return x) ... I only really save three characters
01:41:52 <jle`> that's nice
01:42:11 <supki_> :t \p -> ap (<$) (guard . p)
01:42:12 <lambdabot> (Functor f, MonadPlus f) => (a -> Bool) -> a -> f a
01:43:12 <jle`> slightly less readable but it does get rid of typing x twice
01:57:00 * hackagebot haskell-names 0.3.2.4 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.3.2.4 (RomanCheplyaka)
02:07:00 * hackagebot yesod-pnotify 0.4.3.0 - Yet another getMessage/setMessage using pnotify jquery plugins  http://hackage.haskell.org/package/yesod-pnotify-0.4.3.0 (KatsutoshiItoh)
03:04:40 <narxus> Hello guys
03:05:44 <narxus> I never knew there would be so many people in this chatroom...
03:06:12 <jle`> welcome :)
03:06:36 <narxus> Is haskell an awesome language?
03:07:05 * hackagebot http-client-tls 0.2.0.2 - http-client backend using the connection package and tls library  http://hackage.haskell.org/package/http-client-tls-0.2.0.2 (MichaelSnoyman)
03:08:36 <AlainODea> narxus: yes.
03:08:56 <jle`> probably
03:09:49 <zett_zelett> I’m convinced it is.
03:10:21 <AlainODea> every language has faults, but my opinion of Haskell five years in is that it has far fewer than the others I've learned.
03:10:49 <MrGwen> Smalltalk is also awesome
03:11:00 <narxus> I am curious about learning functional programming. Which of these 2 are books for beginners: 'Learn you a Haskell' or Great Good! or 'Real world Haskell'?
03:11:07 <zett_zelett> Learn You A Haskell.
03:11:22 <zett_zelett> You can read it almost fluently.
03:11:30 <zett_zelett> And it’s great fun.
03:11:45 <zett_zelett> Okay, I’m not through with it, yet, but about half-way.
03:11:59 <zett_zelett> (I’m also a beginner.)
03:12:18 <narxus> That tutorial is the reason why I am here :)
03:12:43 <zett_zelett> Ah, yeah. It talks about #haskell at the beginning, doesn’t it?
03:13:26 <narxus> Yup. Just started reading it :)
03:14:57 <AlainODea> narxus: I found RWH to be a tough ride especially given the errors and outdated stuff in it.  I found LYAH much more enjoyable. After LYAH I found Haskell from Scratch (jekor's on Youtube) really excellent for embracing Haskell for imperative programming as well
03:15:14 <jle`> i also feel like LYAH has aged better than RWH
03:15:29 <jle`> the years have not been too kind with the latter
03:16:10 <narxus> I had fun with imperative programming. I want to experience better with functional programming.
03:16:23 <narxus> I think it seemed cleaner than OOP
03:16:29 <jle`> you will feel shocked and disoriented at first :)  but you'll get used to it
03:16:40 <AlainODea> if you prefer lecture style the whole Informatics I course from the University of Edinburgh is up online including up to date labs and exercises
03:16:56 <narxus> I did, jle'. My first functional language was scala.
03:17:19 <narxus> I was taking a course called: "Programming Principles with scala" on coursera.
03:17:41 <jle`> that's good :)
03:17:46 <narxus> Never lasted a week. Syntax too weird.
03:18:09 <jle`> ah i thought you implied that you now are no longer disoriented
03:18:13 <narxus> I now regained the will to learn but this time, with haskell
03:18:28 <jle`> how long ago did you start progrmaming imperatively?
03:18:45 <narxus> 2012
03:18:53 <jle`> ah so not too long ago
03:18:57 <narxus> I guess... 2 years
03:19:00 <jle`> my illustration is not as useful
03:19:03 <narxus> I meant a year
03:20:09 <jle`> well then, good luck :)  and welcome to haskell
03:20:21 <zett_zelett> Why is it that people coming from imperative languages know of other programming paradigms but frequently avoid trying them out for many years?
03:20:46 <narxus> Thanks
03:20:49 <merijn> zett_zelett: Because the majority of people don't care about learning or improving themselves
03:21:36 <dv-> that's a bit harsh
03:22:44 <merijn> dv-: It's not, that implies to more than just programming languages/paradigms
03:22:44 <narxus> I can't say that's not true. Most people think learning sucks...
03:22:55 <merijn> The majority of people just don't care about improving in anything
03:23:03 <zett_zelett> Maybe there’s some truth to it: They have to think of declarative programming as unnecessary instead of interesting.
03:23:23 <dilinger> if folks feel that RWH hasn't aged well, what do you prefer instead for covering advanced topics like FFI or monad transformers?  the wikibooks haskell tutorial, perhaps?
03:23:44 <merijn> dilinger: Personally I think RWH isn't that bad
03:24:05 <merijn> dilinger: Some of the examples/code may be broken due to using old libraries, the basic ideas still apply
03:24:28 <merijn> dilinger: For example, RWH uses parsec2, but if you understand parsec2 picking up parsec3 from the haddock should be fairly simple
03:25:14 <merijn> dilinger: I don't think there is really a book for the FFI, but in my personal experience if you know C the FFI is trivial to learn from the docs
03:26:29 <narxus> Guys, I read somewhere that there is another way of repeating tasks other than loops in Haskell. Is that true?
03:26:35 <mm_freak> if you have used a handsaw for many years, you build kind of a relationship to it…  the handsaw becomes a part of you
03:26:51 <mm_freak> switching to a chainsaw requires giving up that relationship, which many people have a problem with
03:26:52 <merijn> narxus: Depends how you define loops
03:26:53 <AlainODea> RWH is definitely valuable and wa extremely useful for pushing me into functional thinking, but I found it very hard the first time I went through it.
03:27:07 <RichyB> There's a PDF of the original standard here:
03:27:10 <RichyB> bleh
03:27:10 <RichyB> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi.pdf
03:27:27 <mm_freak> so you will find people cutting trees with handsaws, even though other tools would work way better
03:27:28 <carminemlt> zett_zelett: In my case I didn't know about functional programming, until a few years ago. And it happened after reading part of one of the first books on Scala. I jumped for a while on Erlang, just the time to toy with it. I quit Erlang, because I didn't like it. Haskell kept popping up much more frequently in my searches and I choose to give it a try. Since then (2 years now) I'm trying (struggling? :) )
03:27:29 <carminemlt> to learn it during my almost non existant spare time.
03:27:37 <narxus> merijn: Well... I use for loops all the time when I solve puzzles like FizzBuzz, min, max, etc...
03:27:57 <merijn> narxus: In haskell we tend to use functions like map, fold or just recursion
03:28:32 <jle`> yes, the concept of looping (in an imperative sense) is much less of a useful idea in functional programming
03:28:34 <mm_freak> this applies to the case when, say, a C/java/PHP programmer knows that haskell would do the job better, but simply doesn't want to abandon their deep knowledge in their language
03:28:55 <narxus> merijn: Imperative programming only taught me recursion. I don't fully know how powerful recursion really is...
03:29:01 <merijn> mm_freak: The deeper my C knowledge, the more I doubt many people have sufficiently deep C knowledge to make that decision :)
03:29:34 <jle`> narxus: remember that a functional program is not best thought of as a list of tasks to do or repeat
03:29:47 <mm_freak> merijn: but that's not the case…  i came from C, and this was my experience…  my feeling is that it applies to many people =)
03:30:39 <merijn> mm_freak: Did you see some of mauke's C programs that try to mess with your mind? :p
03:30:39 <jle`> narxus: rather, they are just lists of functions and compositions of functions.  functions int he mathematical f(x) = y sense, not in a sub-procedure progrmaming sense
03:30:50 <jle`> but if you read LYAH you will see this soon enough
03:30:54 <merijn> mm_freak: e.g. http://mauke.hopto.org/stuff/c/sizeof.c
03:30:55 <jle`> just forget that you ever used loops
03:30:56 <AlainODea> narxus: recursion is incredibly more powerful than any imperative language will successfully demonstrate.  Combinators like map and foldl' and Haskell's fluency in composing functions changes the economics of clean code considerably
03:31:28 <jle`> this is the disorientation i was talking about; concepts you relied on heavily in imperative progrmaming now are mostly unuseful in functional programming
03:32:21 <narxus> Wow... Functional programming is like a living in a whole new world...
03:32:49 <mm_freak> merijn: that one is easy enough =)
03:33:02 <merijn> @quote romm continent
03:33:03 <lambdabot> romm says: i thought i knew programming. this is like discovering a new continent.
03:33:39 <merijn> mm_freak: I only know like 4 people that got it right, and I was extraordinarily proud of myself for getting it right the first time :p
03:33:43 <augur> haha
03:33:47 <augur> thats a good quote :)
03:33:48 <merijn> mm_freak: Maybe you just know smarter C programs
03:33:53 <merijn> mm_freak: eh, programmers
03:34:47 <mm_freak> merijn: it's just applying the rules
03:35:22 <narxus> Learning Haskell is like learning how to program all over again coming from imperative programming.
03:36:15 <jle`> it's actually worse; it's like learning how to program all over with someone shouting over your shoulder bad advice
03:36:22 <jle`> (the person being yourself)
03:36:26 <merijn> augur: It's a very true quote, too :)
03:36:40 <merijn> augur: A lost continent where the monads and ADTs still roam free
03:37:52 <yitz> and where we raise up a great new nation, that soon begins poking into everyone else's business
03:38:00 <augur> merijn: i want ADTs in C
03:38:04 <augur> it would be a simple addition
03:38:40 <BoR0> what does sizeof(0)["abcdefghij"] actually express to?
03:39:09 <narxus> Wait... So, what I mostly learned in C, C++, Java, C#, Python can't be applied in Haskell?
03:39:23 <frerich> boR0: My guess: 1
03:39:32 <BoR0> I know, but how does it express to 1
03:39:32 <merijn> frerich: Ah, but why? :)
03:39:49 <zomg> narxus: some of it can, but for example program flow and such works rather differently
03:40:12 <frerich> merijn: I'd guess that it's the same as 'sizeof 0["abcdefghij"]' which is the same as 'sizeof "abcdefghij"[0]' which is the same as 'sizeof 'a'"
03:40:21 <benj_> whitespace is significant, a bit like in Python. Err, that's about it.
03:40:39 <merijn> BoR0: sizeof is not a function, it's a unary operator (hence why you shouldn't use "sizeof(int)" but "(sizeof int)"), fun fact: sizeof binds less tight than array indexing
03:40:49 <BoR0> excellent. so it was all about order of evaluation
03:40:50 <frerich> merijn: Not sure how the 'sizeof' is parsed. It could also be '(sizeof 0)["abcdefghij"]' in which case it would evaluate to 4["abcdefghij"] (on 32bit), i.e. 'e'
03:40:51 <merijn> BoR0: And for the rest frerich is right
03:40:56 <BoR0> I read as (sizeof 0)
03:41:10 <frerich> Damn I shouldn't have said anything so people would have claimed I actually know it. :)
03:41:13 <frerich> It was just an educated guess.
03:41:19 <narxus> zomg, Well I atleast know that I can define variables like in python
03:41:32 <merijn> BoR0: Yes, that's why I'm guessing mauke wrote the example, as argument not to use "sizeof(0)"
03:41:48 <narxus> But the function definition is really different
03:41:51 <merijn> BoR0: And the 'a' being a char is defined to have sizeof 1
03:41:51 <BoR0> what is the preferred way? sizeof 0 ?
03:42:05 <merijn> BoR0: "(sizeof x)"
03:42:10 <BoR0> I see.
03:42:29 <benj_> I'd say it's not really like Python; defining a variable in Python is basically creating a mutable cell and giving it an initial value
03:43:03 <benj_> even for function parameters, which leads to some fun gotchas
03:43:12 <augur> merijn: data List a = Nil | Cons a (List a)   would become   typedef enum { NIL ; CONS } LISTCON; typedef struct<a> { a head; List<a> *tail } List<a>;   and case would be translated into a switch statement, or something
03:43:33 <narxus> Well... Guys, thanks for the telling me what Haskell will look like. I'll start the second chapter of LYAH tomorrow.
03:43:35 <narxus> Good night :D
03:43:35 <augur> you could do it, im sure.
03:45:31 <augur> you could macro the parametricity away probably.   #define LIST(a) struct { a head; void * tail }
03:46:52 <augur> woops, you need a constructor in there as well
03:52:08 <spion> oh haha. sizeof  (0)["string"]
03:55:43 <mm_freak> the C code is indeed more confusing than i thought
03:55:57 <mm_freak> it boils down to understanding that a[b] is really just a + b
03:56:34 <BoR0> a[b] = b[a], if you prefer that way of reading stuff. "asdf"[0] is more readable to me than 0["asdf"]
03:56:36 <mm_freak> it boils down to understanding that a[b] is really just *(a + b)
03:56:51 <mm_freak> and that sizeof(a)[b] parses as sizeof((a)[b])
03:57:45 <BoR0> lol. http://mauke.hopto.org/stuff/c/kimian.c this is fun.
03:57:57 <mm_freak> sizeof(0)["abcdefghi"] = sizeof(0["abcdefghi"]) = sizeof(*(0 + "abcdefghi")) = sizeof(*("abcdefghi")) = sizeof('a') = 1
03:58:04 <BoR0> it actually dictates the errors that it causes
03:59:15 <mm_freak> lol cool
03:59:56 <merijn> BoR0: Another neat one: http://mauke.hopto.org/stuff/c/hell.c
04:01:24 <timmot> AlainODea: you said that the University of Edinburgh has the course notes for Informatics I online, would you happen to have a link?
04:01:35 <mm_freak> merijn: isn't that just inline opcode
04:01:37 <mm_freak> ?
04:01:56 <AlainODea> timmot: yep, just a sec
04:02:10 * hackagebot minimorph 0.1.5.0 - English spelling functions with an emphasis on simplicity.  http://hackage.haskell.org/package/minimorph-0.1.5.0 (MikolajKonarski)
04:02:20 <frerich> merijn: I like how he mixed hexadecimal, octal and decimal in both positive and negative values. :-)
04:03:26 <merijn> mm_freak: It's not inline asm, it's just bytes that happen to have the same values as the binary that should be produced
04:03:31 <AlainODea> timmot: http://www.inf.ed.ac.uk/teaching/courses/inf1/fp/
04:04:21 <timmot> thanks
04:04:39 <mm_freak> merijn: well, it crashes for me
04:12:11 <AlainODea> timmot: my pleasure
04:14:03 <somu> how to write "a <- getLine; b <- getLine; let a' = (read a :: Int); let b' = (read b :: Int)" in more compact way inside a do notation?
04:14:58 <Feuerbach> let getInt :: IO Int; getInt = read <$> getLine; a' <- getInt; b' <- getInt
04:15:25 <merijn> Or just
04:15:28 <merijn> :t readLn
04:15:32 <lambdabot> Read a => IO a
04:16:26 <Feuerbach> oh wow
04:16:34 <Feuerbach> I didn't know it existed
04:18:16 <christiansen> I'm looking to get a program built with Cabal to put the Git version hash in the version string for non-release copies. Is there a canonical way to do this with Cabal?
04:19:15 <christiansen> (the particular program in question is Idris - I think this will make some bug reports easier to process)
04:19:28 <dcoutts_> christiansen: use custom code in Setup.hs to generate a module containing the info
04:20:20 <christiansen> I figured I might need to do that - I had been hoping there was a standard package for it :)
04:20:22 <christiansen> thanks
04:21:51 <timmot> AlainODea: actually, thank you again. it's fantastic to have such an up to date introductory resource
04:25:31 <noric> Hi, I'm a beginner. I'm trying to figure out if my pure function is running in parallel. Played around with -threaded and +RTS -N2, read about Control.Parallel, but I'm confused as to what I get for 'free' and what I have to parallelize explicitly.
04:26:22 <hpc> the short answer is parallelism doesn't happen unless you tell it to
04:26:35 <hpc> longer answer is "put it on hpaste and we can look at your specific problem"
04:26:39 <hpc> @hpaste
04:26:39 <lambdabot> Haskell pastebin: http://lpaste.net/
04:27:12 <noric> My pure function is basically a 'sequence' without keeping the entire result in memory, it recursively builds the cartesian product of a set of lists. Each element of the cartesian product is scored, and only the highest scoring element is kept.
04:27:19 <noric> Cool, sec.
04:28:19 <noric> http://lpaste.net/6807287585203814400
04:28:28 <shiona> ThreadScope is supposedly a nice profiler for parallel haskell programs. So whenever you find yourself asking "Is this running parallel (enough)", you might wanna take a look at that
04:28:45 <noric> I am brand new to haskell, sorry if the code sucks :>
04:29:21 <hpc> the only style issue i see is that you are using tabs
04:29:36 <hpc> which haskell defines as being 8-stop just to make you miserable ;)
04:29:42 <noric> lol
04:30:01 <noric> I just switched editors and will look into that, thanks.
04:30:09 <hpc> i don't see anything in this code that says to compute things in parallel
04:30:23 <noric> Right. Because I am new, I am wondering at this weird 'haskell functional magic'
04:30:36 <hpc> i think what you want is for maximumBy to be parallel
04:30:42 <noric> for example, I didn't realize that naive fibonacci wasn't memoised
04:31:00 <noric> Yeah, or the list comprehension
04:31:26 <hpc> there's not much magic to haskell
04:31:43 <hpc> pretty much the only place you can reliably say "the compiler will figure it out" is the type system
04:31:45 <tdammers> well, Haskell *does* provide a bunch of compiler magic, so it's kind of surprising to newcomers when you find that some things are still explicit :x
04:32:04 <noric> I was looking into parMap, but I don't understand the strategies, and I gather there's an issue of creating too many sparks
04:32:28 <hpc> i don't think too many sparks is an issue; at worst each spark is a forkIO
04:32:32 <hpc> which you can have millions of
04:32:58 <noric> Oh
04:33:20 <noric> brb going to try parMap rpar..
04:33:40 <hpc> that's likely what you want
04:34:02 <hpc> the fun part will be exactly how much of it you parallelize, and what gives the most gains
04:36:09 <noric> while my test runs, could you explain to me what's going on with !! in this fragment: memoized_fib = (map fib [0 ..] !!)
04:36:11 <donri> sparks are relatively cheap but they can still cost more than sequential evaluation
04:36:23 <donri> thus strategies, or we could just "paralellize all the things"
04:36:51 <donri> noric: that's a section for partially applying the list index operator
04:37:12 <donri> the result is a function from an index of the fibs list to that Nth fib
04:37:13 * hackagebot http-conduit 1.9.6 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.9.6 (MichaelSnoyman)
04:37:34 <noric> hpc said I could have millions of sparks, however I have billions+ of steps, is the spark overhead mainly creation/destruction or the # you can have in parallel?
04:38:42 <donri> you should read marlow's book :)
04:38:56 <noric> title?
04:39:38 <donri> @where parconc
04:39:38 <lambdabot> I know nothing about parconc.
04:39:43 <donri> @where pcph
04:39:43 <lambdabot> I know nothing about pcph.
04:39:53 <donri> guess we never settled on a short name for it :P
04:40:09 <donri> http://chimera.labs.oreilly.com/books/1230000000929
04:40:13 <noric> Cool! SPARKS: 206615129 (9420 converted, 3209598 overflowed, 0 dud, 202088687 GC'd, 1307424 fizzled)
04:40:27 <hpc> http://hackage.haskell.org/package/parconc-examples -- also examples
04:40:37 <saeidw> hey everyone, I wrote a function to "break up" a list into sublists, I did it recursively and with a fold, I just don't think the fold solution was any good: http://lpaste.net/97216
04:40:39 <hpc> hehe, "dud" and "fizzled"
04:42:25 <Saizan> > map (take 2) . takeWhile (not.null) . iterate (drop 2) $ [1,2,3,4,5,6,7]
04:42:29 <lambdabot>  mueval-core: Time limit exceeded
04:43:08 <Saizan> > map (take 2) . takeWhile (not.null) . iterate (drop 2) $ [1,2,3,4,5,6,7]
04:43:12 <lambdabot>  [[1,2],[3,4],[5,6],[7]]
04:44:17 <Saizan> saeidw: you might like that ^^^
04:44:55 <saeidw> hey that's neat, I'm gonna play with it in ghci, I didn't think to use iterate
04:45:18 <noric> Haha OK. 206 million sparks. 1.6% discarded due to pool full, 97.8% discarded because not needed, 0.63% fizzled was already evaluated
04:45:21 <augur> :t iterate
04:45:24 <lambdabot> (a -> a) -> a -> [a]
04:45:27 <noric> But it improved runtime from 40s -> 33s or so
04:46:51 <augur> hm. Saizan: thats an interesting function
04:46:55 <AlainODea> noric: check out Simon Marlow's book. Paralellism in Haskell is not free, but is particularly convenient and elegant. http://chimera.labs.oreilly.com/books/1230000000929
04:48:11 <augur> Saizan: i wish there were some kind of big book that discusses these kinds of solutions, why they make sense, and how to find such solutions
04:51:43 <augur> Saizan: i feel like the techniques for thinking about that kind of solution are the sort of thing that make great functional programmers, and that need to be taught in intro to FP books
04:51:56 <augur> i wish i were a great functional programmer :(
04:55:43 <_justjust> how would i record a data-stream from a com port to a file and then emulate a com port an playback the recorded stream?
04:56:59 <_justjust> i guess recording isn't the hard part with something like serialport
05:02:13 <codygman> Should I use cabal or apt-get with debian? Anyone thought about the tradeoffs there before? Sadly I don't have any specific requirements for my project yet, but has anyone else weighed the pros and cons?
05:02:58 <_justjust> cabal has all the pros :)
05:03:31 <donri> well with apt-get you skip the build times and you get packages that are known to work together
05:03:38 <donri> but you only get a subset of hackage
05:11:40 <jmcarthur_mobile> codygman: apt for executables. Cabal for libraries
05:13:17 <bartavelle> codygman, also http://deb.seereason.com/ubuntu/, to get an up to date ghc
05:27:08 <issam> how can i run fold in haskell?
05:27:17 <issam> it says, the method is not recognized
05:27:34 <simpson> issam: Haskell requires you to specify whether the fold is to the left or to the right.
05:27:37 <simpson> :t foldr
05:27:40 <lambdabot> (a -> b -> b) -> b -> [a] -> b
05:27:56 <issam> so its foldr instead of fold?
05:28:09 <issam> :t foldl for the left
05:28:12 <lambdabot>     Not in scope: `for'
05:28:12 <lambdabot>     Perhaps you meant one of these:
05:28:12 <lambdabot>       `T.for' (imported from Data.Traversable),
05:28:18 <issam> :t foldl
05:28:18 <lambdabot> (a -> b -> a) -> a -> [b] -> a
05:28:42 <simpson> Note that foldl, due to laziness, builds up lots of thunks, so it can be quite a bit slower. Try to foldr when possible.
05:29:27 <issam> thanks simpson, appreciated!
05:34:31 <noric> Is there a better way to a implement a spark cutoff than this example: http://stackoverflow.com/questions/1798996/multicore-programming-in-haskell-control-parallel/1799134#1799134
05:37:02 <jmcarthur_mobile> noric: I don't think there is any one great way of doing it. It's an unfortunate tuning parameter no matter what you do
05:39:13 <jmcarthur_mobile> noric: the bad effects of creating too many sparks could be lessened by making ghc's spark queues growable, which would at least mean the less productive sparks wouldn't prevent more productive sparks from being added to it, although now the cost model for space when using sparks would have to change a bit
05:40:15 <jmcarthur_mobile> noric: it shouldn't even be that hard to make the change, I think. The data structure used in GHC is based on a paper describing lock free, growable queues. It's just that the growing part hasn't been implemented
05:40:33 <noric> jmc: thanks. Is there ever a reason to use rpar with only one core available (or -N1)?
05:40:33 <jmcarthur_mobile> I've been considering trying it out
05:40:36 <noric> I am new..
05:41:00 <noric> Rather, are sparks relevant with only one core?
05:41:17 <jmcarthur_mobile> I don't think there is any point in parallelism if you know you will only have one core
05:41:47 <jmcarthur_mobile> The nice thing about sparks is they scale well to more cores without hurting too much on lower numbers of cores
05:41:52 <noric> I couldn't tell if sparks were only useful with work stealing or if they are used to shovel work onto a single core
05:41:55 <jmcarthur_mobile> When used well
05:42:23 * hackagebot threefish 0.2.6 - The Threefish block cipher and the Skein hash function for Haskell.  http://hackage.haskell.org/package/threefish-0.2.6 (AntonEkblad)
05:42:33 <jmcarthur_mobile> I could imagine some cases where it might still help I guess
05:42:47 <jmcarthur_mobile> But kind of weird ones
05:43:18 <noric> thanks
05:43:43 <jmcarthur_mobile> Like if your main thread makes a safe sys call and you had built with -threaded then you might get an opportunity to pull from the spark queue then
05:44:33 <jmcarthur_mobile> G2g
05:46:55 * hackagebot http-conduit 1.9.6 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.9.6 (MichaelSnoyman)
05:46:55 * hackagebot threefish 0.2.6 - The Threefish block cipher and the Skein hash function for Haskell.  http://hackage.haskell.org/package/threefish-0.2.6 (AntonEkblad)
06:08:36 <Xunie> Hayoo is apparently running out of memory... ( http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=map )
06:09:49 <kinslayer> Is there a good way to download a webpage as HTML directly ?
06:10:29 <merijn> http-conduit?
06:10:47 <kinslayer> merijn: Isn't that giving a bytestring ?
06:11:00 <kinslayer> since I am using that right now.
06:11:13 <kinslayer> But then again what does TagSoup work on ?
06:11:45 <merijn> kinslayer: I prefer using html-conduit together with http-conduit
06:12:15 <kinslayer> okay, but if TagSoup works on ByteString I would not need to convert ?
06:12:38 <timmot> augur: it wouldn't hurt to look into other functional language books to extend your knowledge :)
06:12:57 <augur> timmot: well, i can code well enough
06:13:02 <augur> but not elegantly
06:13:33 <kinslayer> @hoogle TagSoup
06:13:34 <lambdabot> package tagsoup
06:13:35 <lambdabot> package tagsoup-ht
06:13:35 <lambdabot> package tagsoup-parsec
06:13:57 <kinslayer> that helped a lot ?
06:15:53 <kinslayer> great stuff Text.HTML.Download - no page...
06:16:52 * hackagebot snap-cors 1.0.0 - Add CORS headers to Snap applications  http://hackage.haskell.org/package/snap-cors-1.0.0 (OliverCharles)
06:21:52 * hackagebot bencoding 0.4.3.0 - A library for encoding and decoding of BEncode data.  http://hackage.haskell.org/package/bencoding-0.4.3.0 (SamTruzjan)
06:28:51 <zgredzik> does anyone know how can I compare two Exp Float values when workint with accelerate package?
06:31:53 * hackagebot snap-cors 1.0.1 - Add CORS headers to Snap applications  http://hackage.haskell.org/package/snap-cors-1.0.1 (OliverCharles)
06:34:36 <merijn> zgredzik: compare them for what?
06:46:11 <zgredzik> merijn: equality
06:46:55 <zgredzik> I mean check if the Float values are equal
06:49:28 <merijn> zgredzik: Please don't do that :(
06:49:48 <merijn> Every time you compare Float for equality, god murders a metric ton of kittens
06:51:02 <zgredzik> yeah well thought the same but the guy sitting next to me argues that it's ok
06:51:03 <zgredzik> :D
06:52:08 <merijn> zgredzik: Slap him in the face, tell him to read: http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html and never suggest such lunacy again
06:52:48 <merijn> zgredzik: Incidentally, if you're doing numeric stuff you should probably read that too
06:52:51 <quchen> Lobbying against Float equality again, eh?
06:53:43 * quchen thinks (==) on Float is fine, as long as you don't confuse it for "the numbers are equal". It's a structural (bit-wise) comparison, and sometimes that can be convenient to use.
06:54:28 <quchen> Example: sub-second timestamps over multiple architectures. When two timestamps are Double equal, you can be pretty sure the timestamps were ordered by the same operation.
06:54:38 <Feuerbach> I'm with quchen here
06:54:42 <quchen> Using an Int for timestamps may not be the right thing here due to arbitrary clock resolutions.
06:54:53 <zgredzik> merijn: truth to be told the floats are not calculated (I choose a minimum value out of 3 different ones and later on I have to check which one of them was chosen as the smallest) so I guess this might actually work, but thanks for the article, I'll read that asap
06:55:27 <Feuerbach> always find it annoying when people are fighting against something without first learning the background
06:56:03 <merijn> Well, accelerate sounds like GPU sounds like numeric code sounds like need to know about Float anyway
06:56:13 <quchen> Feuerbach: On the other hand float comparison is definitely not an operation I'm using very often. Anyway, I'm going offtopic so I'll stop here.
06:56:36 <zgredzik> that's why I am going to read that article :)
06:57:09 <Feuerbach> quchen: yeah, neither am I
07:03:25 <m1dnight> guys, I just installed ghc and cabal on linux, and now it says it can't locate Control.Monad.Writer
07:03:36 <m1dnight> I tried some commands I found on google but they didn't fix it
07:03:44 <m1dnight> do I have to install a package via cabal or smth?
07:03:58 <m1dnight> http://blog.tmtk.net/2013/01/14/could_not_find_module_control.monad.writer.html # I tried these
07:05:16 <quchen> m1dnight: Transformers don't come with GHC, they're in the "transformers" package.
07:05:49 <quchen> m1dnight: Did you consider installing the Haskell Platform? It's a collection of very common Haskell packages.
07:06:46 <m1dnight> oh, I figured I didn't need that since I'm on linux
07:06:49 <m1dnight> I might try it though
07:06:53 <m1dnight> I think I use it in Windows
07:06:56 <m1dnight> thanks for the tip
07:07:36 <quchen> m1dnight: When you have GHC installed already, you can install the Platform via Cabal though
07:08:09 <quchen> i.e. make a giant cabal install
07:08:19 <quchen> cabal install -j9 --haddock-hyperlink-source async attoparsec case-insensitive cgi fgl GLUT GLURaw hashable haskell-src html HTTP HUnit mtl …
07:08:27 <m1dnight> all that stuff? :p
07:08:32 <quchen> Or you could just install the HP of course ;-
07:08:32 <quchen> )
07:08:33 <m1dnight> damn :D
07:09:11 <quchen> I'm sure there is a Haskell Platform package in your package manager, that should be the fastest solution.
07:09:21 <m1dnight> yeah, i can't immediatly find it
07:09:35 <quchen> I think in Ubuntu it's "haskell-platform".
07:09:47 <quchen> http://www.haskell.org/platform/
07:09:58 <quchen> That should name the package for your distro.
07:12:09 <bernalex> hm. shouldn't there be a haskell weekly today
07:12:58 <m1dnight> hmm seems like it's not really that easy :p
07:12:59 <m1dnight> im working on it
07:13:23 <bernalex> m1dnight: what GNU+Linux distribution are you using?
07:13:38 <quchen> Richard Stallman awards you a gold star.
07:13:48 <quchen> Sorry :-)
07:14:07 <m1dnight> http://packages.ubuntu.com/search?suite=raring&keywords=haskell-platform
07:14:09 <m1dnight> 13.04
07:14:12 <m1dnight> ubuntu that is
07:14:27 <m1dnight> but I've found some SO questions
07:14:30 <m1dnight> so I'm trying those )
07:14:30 <m1dnight> :)
07:14:31 <bernalex> m1dnight: apt-get install haskell-platform # or something like that
07:14:31 <ij> So, I heard prolog can solve a sudoku, if you feed it to prolog correctly without writing an algorithm. Does prolog have some constraint satisfaction algorithm in it? (That you'd have to get to archive the same thing in e.g. haskell?)
07:14:58 <m1dnight> what do you mean ij?
07:15:12 <m1dnight> you just put the constraints a sudoko has
07:15:15 <simpson> ij: Prolog executes via a mechanism that is very much like the List monad.
07:15:32 * m1dnight just finished a prolog project for school \o/
07:15:44 <m1dnight> bernalex: yeah, that doesn' work on 13.04
07:15:55 <ij> But how does it know how to solve it with only the constraint given?
07:16:00 <christiansen> dcoutts: so the result of your tip is at https://github.com/idris-lang/Idris-dev/pull/742
07:16:03 <christiansen> thanks again
07:16:22 <bernalex> m1dnight: OK IDK how to ubuntu. try #ubuntu.
07:16:25 <scooty-puff1> m1dnight: if not already mentioned, may want to use LogicT instead
07:16:36 <simpson> ij: Because Prolog only executes through the logic clauses of the program. Declaring something in Prolog is equivalent to declaring the algorithm that it implies.
07:16:39 <scooty-puff1> err
07:16:40 <quchen> m1dnight: Run  apt-get install haskell-platform -s
07:16:41 <scooty-puff1> ij:
07:16:56 * hackagebot NoTrace 0.1.0.0 - Remove all the functions come from Debug.Trace after debugging  http://hackage.haskell.org/package/NoTrace-0.1.0.0 (CindyLinz)
07:16:59 <quchen> m1dnight: That's the dry run. If it works without errors the package exists and you can delete the -s.
07:17:07 <simpson> ij: I'd recommend going and learning about Prolog on your own; it's a simple and enlightening language.
07:17:14 <m1dnight> still getting "unable to locate package"
07:17:22 <m1dnight> ffs :p
07:17:28 <m1dnight> can't I just install some huge list of packages through cabal?
07:17:36 <ij> simpson, Hmm, okay.
07:17:45 <quchen> Then run  apt-get dist-upgrade  to get 13.10, it exists there :-þ
07:17:45 <bernalex> simpson: I've heard CS guys saying that Göedel is a better first stop
07:17:52 <m1dnight> oh
07:17:55 <m1dnight> i might want to try that then
07:18:11 <quchen> Careful with distro upgrades
07:18:19 <quchen> It's a long-running tradition to break things with it
07:18:31 <simpson> bernalex: There's a logic language called Goedel? :3
07:18:36 <bernalex> I read a paper on what languages to teach at school. haskell and Gödel were the recommended ones.
07:18:58 <quchen> m1dnight: Since you already have GHC and working Cabal I guess you can go with installing everything via cabal though.
07:19:06 <quchen> Probably simpler than a distro upgrade.
07:19:12 <bernalex> simpson: Gödel. it stands for God's öwn declarative language, lol!
07:19:16 <scooty-puff1> when fast inserts and unions are required, instead of lists, dlists, or sequences, are https://github.com/sonyandy/wart/blob/master/src/Data/Bag.hs good to use?  i am trying to sort out the downside, and the best i can find is traversals could be slower, but i think it is bounded slowness (ratio internal nodes to leaf nodes goes to 1)- though i am not comfortable with my reasoning on this
07:19:35 <christiansen> so i've got Cabal generating a module akin to the paths module for a project that contains Git revision information (for bug reports), but cabal sdist can't find it
07:19:41 <quchen> scooty-puff1: What about Set/Map?
07:19:45 <bernalex> simpson: it's like prolog, but "better", according to a lot of people.
07:19:46 <simpson> bernalex: Hm. Looks a little involved. Prolog's not especially practical these days, but it's simple and straightforward, which are useful traits for teaching languages.
07:19:58 <christiansen> is there a good way to mark it as auto-generated so cabal sdist doesn't search for it, but it's still available for import?
07:20:02 <simpson> Yeah, I hear that about Mercury and Oz as well.
07:20:08 <TheBrayn> bernalex: which type of school?
07:20:13 <scooty-puff1> quchen: uniqueness is not a requirement
07:20:27 <bernalex> TheBrayn: CS undergrad
07:20:36 <simpson> bernalex: IMO Prolog and friends are useful as embedded DSLs but not as standalone implementation languages.
07:20:40 <bernalex> simpson: check out https://en.wikipedia.org/wiki/G%C3%B6del_(programming_language)#G.C3.B6del_compared_to_Prolog
07:20:56 <bernalex> simpson: Gödel is strongly typed
07:21:16 <simpson> bernalex: Yeah; that page feels like it was written by a strong proponent of the language who doesn't believe in hello world.
07:21:34 <bernalex> simpson: the write-up is too biased, I agree.
07:21:41 <simpson> bernalex: You mean "statically typed," right? Also I *like* dynamic types.
07:21:48 <bernalex> simpson: no, strongly.
07:21:50 <m1dnight> quchen: I found this script specifically for 13.04:
07:21:57 * hackagebot simplessh 0.2.0.2 - Simple wrapper around libssh2  http://hackage.haskell.org/package/simplessh-0.2.0.2 (thoferon)
07:21:59 <TheBrayn> I'm not so sure if haskell is a good language to start with
07:22:00 <m1dnight> https://raw.github.com/chrisprobst/ubuntu-raring-haskell/master/install.sh
07:22:02 <bernalex> simpson: prolog is weakly typed.
07:22:19 <bernalex> TheBrayn: I think scheme, sql and haskell are contenders.
07:22:22 <simpson> Oh. Well, so's Prolog; once you're unified, you can't really un-unify the type, and there's not much coercion.
07:22:30 <TheBrayn> bernalex: sql ist not a programming language
07:22:37 <bernalex> TheBrayn: yes it is, what are you talking about
07:22:52 <bernalex> unless you mean it's "a family of languages" or whatever blah
07:22:54 <simpson> TheBrayn: Sure it is. Might not be Turing-complete, but that's okay.
07:23:06 <TheBrayn> oh it is
07:23:08 <simpson> There's ANSI SQL.
07:23:12 <TheBrayn> I did not know that
07:23:15 <bennofs> christiansen: does it work if you just omit the module from other-modules field?
07:23:22 <m1dnight> prolog is very good language to start. But (imo) it's not relateable to any other widely used programming language
07:23:27 <quchen> Everything is a programming language. The expressiveness may vary though.
07:23:39 <m1dnight> it's just nice to know that a language like that exists :)
07:23:40 <bernalex> simpson: it can be Turing complete, actually
07:23:44 <christiansen> bennofs: it might actually - presently recompiling
07:23:44 <Peaker> Skydiving is a programming language
07:23:55 <quchen> Peaker: It even has jump instructions!
07:24:03 <bernalex> simpson: maybe not ANSI SQL though (not sure)
07:24:06 <Peaker> heh
07:24:19 <quchen> m1dnight: I don't know that script. (And I installed the Platform via Cabal, so I don't know about the package situation.)
07:24:33 <bernalex> simpson: hell, CSS3 and HTML5 is Turing complete now, lol!
07:25:09 <bernalex> (also Pokèmon Yellow on GameBoy Color, the Magic the Gathering card game, and others)
07:25:16 <quchen> Turing completeness is overrated. It's a mathematical concept and doesn't say much about the practical usability of a language.
07:25:33 <m1dnight> http://www.pyret.org/
07:25:37 <m1dnight> that language! :p
07:26:02 <bernalex> quchen: actually, it kind of does for us plt geeks. but I'll try to not venture further off-topic now. :-)
07:26:19 <simpson> bernalex: I didn't know that HTML5 was Turing-complete without any other languages embedded inside of it.
07:26:31 <quchen> bernalex: You can make a case that a very practical subset of C isn't Turing-complete.
07:26:47 <bernalex> simpson: (CSS3 + HTML5 need to be combined to be Turing complete)
07:26:51 <quchen> bernalex: You can make the case that HTML is a useful programming language (with one statement, implicit print).
07:26:55 <m1dnight> is there a programming language NOT turing complete then?
07:26:57 * hackagebot NoTrace 0.2.0.0 - Remove all the functions come from Debug.Trace after debugging  http://hackage.haskell.org/package/NoTrace-0.2.0.0 (CindyLinz)
07:27:07 <companion_cube> coq isn't turing complete
07:27:11 <bernalex> m1dnight: yes, plenty. but that's a discussion for #haskell-blah
07:27:18 <m1dnight> oh okay sorry
07:27:20 <m1dnight> didnt know that
07:27:22 <bernalex> quchen: yes, but that wasn't my point. also, #haskell-blah. :-)
07:27:27 <bernalex> m1dnight: NP. :_)
07:28:19 <m1dnight> there is no such thing as haskell-blah! :p
07:28:20 <m1dnight> or am I wrong?
07:28:29 <quchen> You are.
07:28:57 <m1dnight> hmm, something with screen irssi and utf encoding
07:29:00 <m1dnight> #
07:29:06 <m1dnight> nvm
07:29:08 <m1dnight> ill figure it out later
07:29:10 <m1dnight> i want to haskell
07:29:19 <bernalex> m1dnight: you don't need to use '#', you can just /j haskell-blah
07:32:29 <yitz> bernalex: how do you get loops/recursion in html5 without javascript?
07:33:03 <bernalex> yitz: IDK the details of it.
07:33:08 <rasfar> just got sound with OpenAL -- it worked for me loading a .wav file, guess the bluishcoder buffers were either too quiet or wrong sample rate maybe, or ... but, yay!
07:33:36 <m1dnight> guys, sorry to ask again but..
07:33:42 <m1dnight> now I have the Writer monad, and I an import it
07:33:42 <m1dnight> but
07:33:49 <m1dnight>     Not in scope: data constructor `Writer'
07:33:50 <m1dnight>     Perhaps you meant `WriterT' (imported from Control.Monad.Writer)
07:33:52 <christiansen> bennofs: seems to have worked... thanks
07:33:58 <m1dnight> Is this right?
07:34:37 <scooty-puff> Writer is a type synonym - WriterT is the one with a data constructor
07:34:50 <m1dnight> oh
07:34:51 <scooty-puff> type Writer w = WriterT w Identity
07:35:12 <scooty-puff> so, instead of trying to match on Writer, do runWriter, and match on the results
07:35:17 <bartavelle> I believe transformers and mtl both export WriterT and Writer for the strict or lazy versions ... this is a strange error
07:35:25 <bartavelle> ah
07:35:28 <bartavelle> data constructor
07:35:29 <bartavelle> nvm
07:35:37 <m1dnight> I just copy-pasted it from the book though
07:35:38 <m1dnight> (lyah)
07:35:39 <m1dnight> damnit
07:35:52 <scooty-puff> it may be a little out of date - mtl has changed a bit
07:36:25 <scooty-puff> compare http://hackage.haskell.org/package/mtl-2.1.2/docs/Control-Monad-Writer-Strict.html and http://hackage.haskell.org/package/mtl-1.0/docs/Control-Monad-Writer.html
07:36:33 <scooty-puff> Writer used to have a data constructor
07:36:49 <bernalex> yes, this part of lyah confuses some people. me included.
07:37:15 <scooty-puff> to match it perfectly, you could cabal instal 'mtl <2.0', however, this is not recommended
07:40:27 <nahiluhmot> Anybody in the mood to help me optimize a function?
07:41:37 <Peaker> Now that I had to add an import for "join", I suddenly realized soon I won't need to import join manually, due to the Applicative proposal, yay :)
07:44:35 <rasfar> nahiluhmot, i'm in the mood to try, you got a paste?
07:44:39 <rasfar> @hpaste
07:44:39 <lambdabot> Haskell pastebin: http://lpaste.net/
07:47:08 <nahiluhmot> rasfar: lpaste.net/97223
07:47:53 <nahiluhmot> The function (removes) takes a list, and outputs a list of tuples. The first element in each tuple is the element at the index in the list, and the second element is the list without that element.
07:48:39 <nahiluhmot> Currently, it takes O(n^2) time and a shitload of memory (scientific terms), but I'd like to speed it up a bit.
07:50:04 <rasfar> are you compiling with -O2? it can make a big difference (GHC)
07:50:54 <rasfar> (and improve memory use as well)
07:51:27 <nahiluhmot> rasfar: Yes, I am. I'm just wondering if theres a better algorithm for what I'm trying to do (don't want to reinvent the wheel -- and poorly at that).
07:51:31 <rasfar> :t (\\)
07:51:33 <lambdabot> Eq a => [a] -> [a] -> [a]
07:51:39 <merijn> nahiluhmot: Are elements unique?
07:52:11 <rasfar> (merijn, btw, semi-solved my OpenAL issues without FFI)
07:52:12 <nahiluhmot> merijn: No, and in my situation they aren't equatable (they're parsers).
07:52:44 <merijn> should still be able to do this in linear complexity, I think
07:52:57 <nahiluhmot> merijn: That's what I was hoping :)
07:53:12 <nahiluhmot> I just can't think of a different way to do it.
07:53:48 <moto9> hi all, what's the best R surrogate implemented in Haskell?
07:53:48 <augur> does anyone understand ludics?
07:54:06 <escalz> [1] is a sugar syntax for 1:[] so what about (1)?
07:54:20 <bennofs> > (1)
07:54:22 <lambdabot>  1
07:54:27 <merijn> nahiluhmot: Does order matter?
07:54:30 <rasfar> > ((1))
07:54:32 <lambdabot>  1
07:54:48 <merijn> nahiluhmot: i.e. does the list bit of (a, [a]) need to have a specific order?
07:54:48 <nahiluhmot> merijn: nope
07:54:57 <merijn> ok, good :)
07:55:53 <bennofs> > map (\(before, (_:rest)) -> (before ++ rest)) . init . uncurry (zipWith (,)) . liftA2 (,) inits tails $ [a,b,c,d,e,f]
07:55:54 <lambdabot>  [[b,c,d,e,f],[a,c,d,e,f],[a,b,d,e,f],[a,b,c,e,f],[a,b,c,d,f],[a,b,c,d,e]]
07:56:01 <bennofs> Maybe this is faster?
07:56:42 <merijn> nahiluhmot: This should be O(n), I think: http://lpaste.net/97223
07:56:52 <moto9> which would be: define lots of operations on vectors and sees single numbers as vectors of size 1 and provides lot's of visualisation shortcuts
07:57:33 <escalz> so (1) is "primitive" while [1] is a sugar syntax?
07:58:00 <merijn> nahiluhmot: The ++ should fuse away when you use the lists (becoming O(1)), the only problem is the order of the list is not preserved, but if that doesn't matter this should work
07:58:07 <jonasw> escalz: Parentheses are just for grouping
07:58:09 <merijn> escalz: Define primitive and define sugar?
07:58:19 <merijn> escalz: parenthesis don't do anything but grouping
07:58:29 <bennofs> You could say () is sugar for id
07:58:35 <rasfar> (and tupling, but i guess there's no singleton tuple)
07:58:37 <nahiluhmot> merijn: Would that not spill be n^2? (++) takes (n + m) time and it must be done for each element in the list
07:59:01 <escalz> sorry, I meant in case of tuples
07:59:01 <merijn> nahiluhmot: ++ is not n+m, because of laziness
07:59:04 <jonasw> rasfar: That's (,) though
07:59:18 <rasfar> yeah, or (,,) ... but no singleton
07:59:20 <nahiluhmot> merijn: Right, but once it's evaluated wouldn't that be the amortized cost?
07:59:20 <jonasw> Yeah
07:59:33 <scriptor> :t ,
07:59:36 <lambdabot> parse error on input `,'
07:59:40 <jonasw> > (,,) 1 2 3
07:59:42 <lambdabot>  (1,2,3)
07:59:43 <merijn> nahiluhmot: It depends on how you use the result list
07:59:51 <rasfar> > (1,,3) 2
07:59:53 <lambdabot>  (1,2,3)
08:00:03 <merijn> nahiluhmot: "map f (n++m)" <- here ++ is free, as laziness fuses the ++ traversal with the map
08:00:08 * rasfar likes sections
08:00:27 <merijn> nahiluhmot: Keep in mind that ++ does not need to walk the list to return a value
08:00:28 <scriptor> rasfar: woah, I didn't know you could do that
08:00:40 <rasfar> it's a language extension actually, scriptor
08:00:47 <bennofs> scriptor: it's the -XTupleSections extension, iirc
08:00:53 <scriptor> ah, interesting
08:01:01 <merijn> "[] ++ xs =  xs; (y:ys) ++ xs = y : ys ++ xs"
08:01:05 <scriptor> > (1,,3,,5) 2 4
08:01:07 <lambdabot>  (1,2,3,4,5)
08:01:13 <nahiluhmot> merijn: I see, that makes sense. I think that's pretty close to my situation. I have a list of "Parser a"s, and I want to try to parse them in any order, so I use this "removes" function and then iterate.
08:01:15 <rasfar> if you like this sort of thing, you might check out freesect as well
08:01:31 <escalz> wow nice. so we can say that (,,) 1 2 3 == (1,2,3) and 1:2:3:[] == [1,2,3] ?
08:01:44 <bennofs> nahiluhmot: maybe just use permutations then?
08:01:44 <augur> rasfar, scriptor: i think these require that you use the tuple sections extension
08:01:49 <bennofs> > permutations [a,b,c,d]
08:01:51 <scriptor> I see
08:01:51 <lambdabot>  [[a,b,c,d],[b,a,c,d],[c,b,a,d],[b,c,a,d],[c,a,b,d],[a,c,b,d],[d,c,b,a],[c,d,...
08:01:52 <merijn> :t permutations
08:01:54 <lambdabot> [a] -> [[a]]
08:02:00 * hackagebot ZipperAG 0.4 - An implementationg of Attribute Grammars using Functional Zippers  http://hackage.haskell.org/package/ZipperAG-0.4 (prmartins)
08:02:05 <scriptor> do you have to compile ghc with those flags?
08:02:18 <merijn> scriptor: No, just use them when compiling your code
08:02:26 <rasfar> har har
08:02:28 <merijn> scriptor: Or (better!) use pragma's
08:02:31 * Yuu-chan still tries to invent in-code literal numerals
08:02:32 <haasn> nahiluhmot: maybe use a list comonad
08:02:40 <nahiluhmot> bennofs: I was thinking about that, but that definitely takes n^2 time.
08:02:42 <rasfar> {-# LANGUAGE TupleSections #-}
08:02:47 <bennofs> scriptor: or put a {-# LANGUAGE TupleSections #-} at the top of your source file
08:02:49 <merijn> scriptor: You can write "{-# LANGUAGE TupleSections #-}" in your code and GHC will add the extension
08:02:59 <haasn> zipper comonad that is
08:03:02 <quchen> Maybe someone should mention {-# LANGUAGE TupleSections #-}
08:03:10 <bennofs> xD
08:03:43 <nahiluhmot> haasn: To be honest, comonads are one of the areas of Haskell that I have yet to explore. How would they help in my situation?
08:04:34 <haasn> nahiluhmot: duplicate on a list zipper gives you a list of lists, each with one element “singled out” and the others provided as context
08:04:43 <haasn> so you can easily extract the context (without the singled out element)
08:04:50 <haasn> for each iteration
08:05:00 <nahiluhmot> haasn: That's a good-ass idea.
08:05:19 <haasn> of course you might as well hand-roll ‘duplicate’ instead of using the Comonad and Zipper types :)
08:06:13 <nahiluhmot> haasn: At that point, would it be much different from using the "removes" function we arrived at earlier?
08:06:18 <haasn> for a moment I just thought that would make this boil down to some higher level comonadic function but on second thought it doesn't seem like it to me
08:06:25 <haasn> not sure, I only just saw your last few lines
08:06:40 <nahiluhmot> lpaste.net/97223
08:07:11 <merijn> nahiluhmot: I think mine should at least be faster than the original removes, though if you can tolerate the reordering
08:07:32 <nahiluhmot> merijn: It should, thank you :). Fortunately, I don't think ordering will be an issue.
08:09:55 <yitz> > let removes xs = init $ zipWith (\ ys (z:zs) -> (z, ys ++ zs)) (inits xs) (tails xs) in removes [1..5] -- yitz's de-optimized version
08:09:56 <lambdabot>  [(1,[2,3,4,5]),(2,[1,3,4,5]),(3,[1,2,4,5]),(4,[1,2,3,5]),(5,[1,2,3,4])]
08:12:06 <rasfar> nahiluhmot: a difference list might give you better zipping (excuse if haasn has covered that)
08:12:17 <mgsloan> Hey!  Anyone know why adding "qualified" (without "as") to an import causes it not to be re-exportable?  E.g. https://gist.github.com/mgsloan/d28270f7778b94390e66
08:12:34 <rasfar> Data.DList / package dlist
08:12:41 <mgsloan> I'm looking at the haskell 98 report, and it doesn't really seem to specify this point
08:13:23 <stolaruk> Why won't ghc automatically link and make an executable if I have a "module Foo.Main" declaration in my Main.hs? I'm running "ghc Foo/Main.hs"
08:13:56 <Peaker> stolaruk: an executable is "module Main", not "Foo.Main"
08:14:20 <stolaruk> ah
08:14:32 <stolaruk> Peaker: Should Main.hs then be one folder above Foo?
08:14:47 <Peaker> stolaruk: I think it should work even if not, but I'm not sure
08:14:57 <stolaruk> Peaker: Will try, thanks!
08:15:03 <Peaker> (Main is special, found from command-line argument rather than module-path)
08:15:29 <yitz> mgsloan: import qualified Data.List as A
08:16:08 <mgsloan> yitz: Thanks, I'm aware of that pattern, it's a nice one.  What I'm after is the exact semantics of re-export
08:17:48 <yitz> mgsloan: with or without an export list, your module only exports symbols that are in its own namespace. without the re-export, it only exports symbols that are also lexically defined in the module.
08:18:26 <fizbin> Anyone know of any MOOC/online course covering category theory?
08:19:04 <fizbin> Going through the blog posts on "unapologetic mathematician" is useful, but I'd really benefit from something more structured.
08:19:44 <nahiluhmot> merijn: It should, thank you :). Fortunately, I don't think ordering will be an issue.
08:20:14 <mgsloan> yitz: I guess the issue I'm having is that it seems like the qualification without the "as" part of the import acts differently than qualification that lacks an "as", when it comes to re-export.  However, they're pretty much the same in the code when it comes to qualified identifiers
08:20:47 <mgsloan> errr, I meant qualification *with* an "as", vs one that lacks
08:22:55 <mgsloan> yitz: Ahhh, nevermind, I think I get it.  qualified imports can't be re-exported, simple!
08:23:02 <mgsloan> yitz: Thanks!
08:23:13 <Peaker> mgsloan: but they can?
08:23:28 <bennofs> import qualified Data.Text as T -- can I now re-export module T ?
08:23:53 <mgsloan> Peaker: bennofs: Not according to my tests.  "import Data.Text as T" works but "import qualified Data.Text as T" doesn't
08:23:58 <Peaker> I think exporting "module T" would export the whole of it, I'm not sure. But I regularly re-export stuff like:  module Foo (T.a, R.bar)
08:24:01 <quchen> bennofs: "module X" in the export list
08:24:15 <mgsloan> So you can *rename* your import, and group them all together, but they don't re-export if they're imported with qualified
08:24:34 <t7> @pl \s -> s { clients = M.insert c cl (clients s) }
08:24:34 <lambdabot> (line 1, column 9):
08:24:34 <lambdabot> unexpected '{'
08:24:35 <lambdabot> expecting variable, "(", operator or end of input
08:24:36 <Peaker> mgsloan: well, you can re-export  Foo.bar,  not sure if re-export of qualified M as a whole module works
08:24:50 <quchen> Oh, no "module ". http://lpaste.net/97225
08:24:55 <mgsloan> Peaker: Ah, right, explicitly exporting qualified identifiers works
08:25:42 <Peaker> mgsloan: does exporting a qualified module with the "module" keyword not work?
08:26:07 <mgsloan> Peaker: Nope, which was a surprise to me
08:27:21 <mgsloan> I can imagine that this could easily confuse someone, because it's not an error to use a "module Blah" re-export even when no symbols from Blah will get re-exported!
08:27:26 <mgsloan> that should probably be a warning
08:29:22 <mgsloan> Turns out that having a module renaming refactoring is not so easy as it would seem on the surface!
08:31:26 <rasfar> mgsloan: http://lpaste.net/97226 works for me...
08:31:28 <m1dnight> omg this haskell is hurting my head so bad :p
08:31:51 <rasfar> i have probably missed something particular to your test...
08:32:24 <mgsloan> rasfar: Yeah, the particular thing about my test is that it uses "import qualified X" and then tries to re-export it with "module X"
08:32:25 <rasfar> nm, i have caught up with the discussion
08:32:33 <mgsloan> thanks for looking into it :D
08:32:41 <rasfar> oops / yeah, that didn't work for me either :D
08:33:47 <mgsloan> m1dnight: Well, don't let the current conversation confuse you - I've gotten plenty far in Haskelling without fully grokking these specifics - they aren't very important
08:34:07 <m1dnight> yeah but i'm following lyah and i'm trying to implement the tell function for Writer monad
08:34:10 <m1dnight> can't get it to work
08:34:22 <m1dnight> and its because i dont understand monads enough
08:34:24 <m1dnight> but i'm trying :p
08:34:45 <quchen> Doing what you are doing is exactly the way to understand monads.
08:34:54 <quchen> Use them.
08:35:40 <zomg> Hug the monad
08:35:43 <zomg> Make love to the monad
08:36:05 <zomg> paraphrasing the immortal words of Shatner
08:36:06 <zomg> lol
08:36:08 <mgsloan> Yup, using different monads in code is definitely the best way to understand what they are and why they're useful
08:36:36 <ocharles> I'm being dumb here I think. If I cabal repl Foo/Bar.hs, I can only see Foo.Bar's public exports
08:36:41 <ocharles> Is there a way to see private functions?
08:38:25 <mgsloan> ocharles: I think ":load Foo.Bar" might do the trick
08:39:00 <ocharles> It seems if I 'cabal clean', then it works
08:39:04 <ocharles> and I get the magic * at the start of my prompt
08:39:14 <ocharles> but if I cabal build, then I don't. presumably because it uses the object file
08:39:37 <m1dnight> is it normal the type inferencer whines that [String] and [[Char]] are not the same?
08:39:40 <ocharles> mgsloan: nope, if i 'cabal build', :load just acts like an import
08:39:47 <m1dnight> (fixed it by changing everything t[[Char]]
08:39:47 <merijn> m1dnight: No, those should be the same
08:39:59 <Peaker> I wonder if allowing any order of declarations whatsoever, rather than the old C restriction (bottom up declarations) is an improvement or not.  There's something nice about having a guarantee that stuff is defined in a certain order, when reading code, or handling error messages (now got an error that was due to a used symbol having wrong type below my definition)
08:40:04 <merijn> m1dnight: String is literally identical to [Char]
08:40:10 <m1dnight> oh not it does compile
08:40:13 <merijn> m1dnight: pastebin small code sample plus error?
08:40:26 * m1dnight facepalm
08:40:30 <m1dnight> forgot to type a b
08:40:33 <m1dnight> nvm it works :D
08:40:36 <mgsloan> Peaker: It'd also force forward declaration of mutual recursion
08:40:38 <m1dnight> hurrah, my tell is going to work \o/
08:40:44 <Peaker> mgsloan: yes, another good thing!
08:40:54 <mgsloan> Potentially good, potentially annoying :)
08:40:56 <ocharles> aha, :load *Foo.Bar seems to do the job
08:41:46 <Peaker> mgsloan: Well, the other side of the coin is that it's more annoying to read stuff in arbitrary/random order
08:42:00 <Peaker> and not having a "warning" that recursion is coming up, like I have (and like) in C
08:42:20 <Peaker> though I like Mu's requirement for a language pragma to have recursion support at all :)
08:42:30 <Peaker> (which only 10% of the modules use!)
08:43:16 <mgsloan> Peaker: I guess it's similar to much of Haskell's sugar.  Instead of forcing you to use just "case", you can use guards, if-then-else, etc.  While it might be more homogenous and predictable, this way the writer is given the freedom to make their code as clear or unclear as they like.  Of course, opinions differ there as to what's clear or not
08:44:10 <Peaker> mgsloan: ah, I much prefer TIOOWTDI, though I think case/guards are quite orthogonal, "if" might be redundant (could be nice to have easy way to have guards anywhere, instead)
08:44:29 <rasfar> nice find ocharles
08:44:31 <bennofs> what is TIOOWTDI?
08:44:46 <zerokarmaleft> there is only one way to do it
08:44:46 <Peaker> bennofs: from Python's philosophy: There is one obvious way to do it
08:44:58 <Peaker> zerokarmaleft: there can never be "only one way", so it's "one obvious way"
08:45:06 <Peaker> (and an infinite variety of less obvious ways)
08:45:28 <merijn> Peaker: Guards anywhere, you mean MultiWayIf? :p
08:45:41 <Peaker> merijn: yeah, as a replacement for "if", though, not as an addition
08:47:30 <m1dnight> IT WORKS \o/
08:47:36 <mgsloan> Peaker: Yeah, I think that can work better in a visual language, actually.  E.g. I can imagine having just one multi-arity case statement, and leaving it at that. Have you seen Jonathan Edwards' schematic tables?
08:47:47 <m1dnight> my god that was (as we say in dutch) a tough labour (as in having a baby)
08:48:29 <Peaker> mgsloan: yeah, it seems really great
08:48:48 <Peaker> mgsloan: and IMO quite in line with Haskell's case/guards - much moreso than any contemporary textual language
08:49:07 <mgsloan> Indeed, I've always wanted to do a Haskell-backed implementation of them
08:49:13 <mgsloan> When're they coming to lamdu? ;)
08:50:17 <Peaker> mgsloan: a while yet :)  We're struggling with the implementation of a good type system and inference -- while also looking around to see if we could re-use existing work. The closest seems like ermine, but we don't want the Type/Kind/etc clutter from Haskell, and we want explicit type variables/instantiation (hidden in UI)
08:50:53 <Peaker> so none of the existing type systems seem appropriate for Lamdu. Another close one is Idris -- but we really want row types/polymorphic variants :(
08:51:40 <Hodapp> I'll learn Idris once I learn Haskell and Coq...
08:52:54 <Peaker> (Idris also does the type variable stuff)
08:53:12 <Peaker> in Lamdu, the low-level language we use is more like SystemF, and "type variables" are a Sugar/UI thing
08:53:21 <mgsloan> Ah, that's interesting.  Sounds like a good way to avoid type errors travelling far from their source
08:53:29 <merijn> m1dnight: That's the point where you start cackling maniacalically
08:53:52 <Peaker> mgsloan: usually you'd let it infer the type var instantiations, which still allows that.. (brb)
08:54:43 <mgsloan> Peaker: Sure, but then once they're instantiated, when things break, the errors will be nicer
08:55:23 <mgsloan> Peaker: One thing I've been thinking would be really cool for this would be to use a structural diff that also diffed the types
08:55:53 <m1dnight> http://lpaste.net/97227 # How come the runtime tells me that my tell signature is like that?
08:56:01 <m1dnight> the two types are obviously swapped in position
08:56:10 <mgsloan> Peaker: This could either inform type inference to prefer the way types were when compilation worked, or, it could just be used to inform the user of all the types that changed since compilation worked
08:56:11 <m1dnight> yet still it says w -> a -> Writer w a
08:56:21 <m1dnight> I dont get it :p
08:56:56 <m1dnight> oh! it's the data type, not the type constructur, and those are swapped in the definition
08:56:59 <m1dnight> I think
08:59:13 <Yuu-chan> m1dnight: yes
08:59:27 <m1dnight> they should fix that :p
08:59:40 <Yuu-chan> m1dnight: what exactly?
08:59:57 <m1dnight> the two parameters that get swapped in the Writer monad
09:00:11 <Yuu-chan> Monoid comes first for partial type application
09:05:12 <bennofs> How do I check for the operating system using cabal with CPP?
09:07:05 * hackagebot cubical 0.1.0 - Implementation of Univalence in Cubical Sets  http://hackage.haskell.org/package/cubical-0.1.0 (AndersMortberg)
09:13:46 <m1dnight> http://lpaste.net/97228 # Could somebody help me out here
09:13:52 <m1dnight> I thought my tell was done, but it's not :p
09:13:55 <rasfar> bennof: I see #ifdef CABAL_OS_WINDOWS in enumerator-0.4.18, maybe that can help?
09:14:24 <rasfar> ^bennofs
09:15:07 <Peaker> m1dnight: I don't understand what you're asking
09:15:21 <m1dnight> well I want to implement the tell function of the writer monad
09:15:26 <m1dnight> but it's nt working as expected
09:15:28 <Peaker> m1dnight: your implementation looks fine
09:15:30 <m1dnight> and I dont know how to make it do that
09:15:41 <m1dnight> isn't it supposed to work like I wrote in the do?
09:15:41 <Peaker> or rather, it's not quite the right type
09:15:52 <m1dnight> but that gives me errors
09:15:56 <bennofs> rasfar: that seems to work, thanks
09:15:58 <Peaker> m1dnight: tell *only* tells, it doesn't actually return a value too
09:16:10 <rasfar> great, yw!
09:16:13 <Peaker> m1dnight: tell :: Monoid w => w -> a -> Writer w a   <-- this is the wrong type
09:16:20 <Peaker> m1dnight: tell :: Monoid w => w -> Writer w ()
09:16:54 <mortberg> does anyone know how to make cabal run a program (bnfc) only when a specific file has changed (the grammar)?
09:17:05 <m1dnight> so it returns an empty value with a context (the log file) ?
09:20:39 <m1dnight> tell :: Monoid w => w  -> Writer w ()
09:20:40 <m1dnight> tell addthis = Writer (return (), addthis)
09:20:43 <m1dnight> is it like that then?
09:20:51 <m1dnight> I can't seem to brain properly today
09:21:27 <Peaker> m1dnight: What type is within the tuple of the Writer?
09:21:43 <Peaker> m1dnight: you're almost there -- your first-in-tuple is of the wrong type
09:22:07 <m1dnight> well it's type Int,  [String]
09:22:17 <m1dnight> but the empty alue is not zero
09:22:23 <m1dnight> oh, () ?
09:22:51 <Peaker> m1dnight: what's the definition of the Writer type itself?
09:24:01 <m1dnight> Write wa = Writer {runWriter :: (a, w)}
09:24:19 <nstdloop_> How are list comprehensions actually implemented in Haskell? Is it just a language feature? What's the easiest way to fake a list comprehension with pure Haskell
09:24:30 <m1dnight> monads :(
09:24:37 <Peaker> m1dnight: monads :-D
09:24:43 <m1dnight> list comprehensions are syntactic sugar for do
09:24:47 <m1dnight> comprehensions*
09:25:04 <Peaker> m1dnight: so:  Writer w ()    means you have a "()" in the tuple, not "return ()"
09:25:38 <m1dnight> because "return ()" would put it in a minimal context, and that would be a writer, which I don't want?
09:25:41 <m1dnight> right?
09:25:41 <Peaker> nstdloop_: [(x, y) | x<-[1..3], y<-[10,20,30]]   --->    do { x <- [1..3] ; y <- [10,20,30] ; return (x, y) }
09:25:58 <Cale> Perhaps show a guard as well
09:26:00 <Peaker> m1dnight: "return ()" has type:  "Monad m => m ()",  And "m ()" contradicts the type (), which you need
09:26:06 <m1dnight> indeed
09:26:11 <Cale> The Report actually defines list comprehensions without monads
09:26:12 <m1dnight> it works \o/
09:26:15 <m1dnight> hurrah, i'm so happy :)
09:26:19 <m1dnight> thanks guys for the patience!
09:26:19 <joelteon> yes
09:26:31 <Cale> http://www.haskell.org/onlinereport/exps.html#list-comprehensions
09:26:37 <Cale> shows the translation rules
09:26:42 <Peaker> nstdloop_: [(x, y, z) | x<-[1..3], even x, let z=x`div`2, y<-[10,20,30]]   --->    do { x <- [1..3] ; guard (even x) ; let z = x `div` 2 ; y <- [10,20,30] ; return (x, y) }
09:26:59 <nstdloop_> so return (x, y) pairs all the elements together automatically?
09:27:11 <Cale> But yeah, translating to do-notation and using the list monad is more straightforward
09:27:14 <Peaker> nstdloop_: in this context, return just wraps it in a single-item-list
09:27:24 <Peaker> nstdloop_: it could be:  .... ; [(x, y)] }
09:27:28 <Cale> > return 5 :: [Integer]
09:27:31 <lambdabot>  [5]
09:27:38 <Cale> > return (3,4) :: [Integer]
09:27:39 <lambdabot>  Couldn't match expected type `GHC.Integer.Type.Integer'
09:27:39 <lambdabot>              with actual type `(t0, t1)'
09:27:45 <Cale> > return (3,4) :: [(Integer, Integer)]
09:27:46 <lambdabot>  [(3,4)]
09:27:51 <Cale> Hit enter too soon :)
09:28:02 <nstdloop_> Wouldn't you get [([1..3], [1..5])] from x <- [1..3] and y <- [1..5]
09:28:12 <Peaker> nstdloop_: every use of "<-" is syntactic sugar for application of the (>>=) function and a "lambda" that covers the rest of the comprehension/do-block.   The >>= actually loops over all the items and executes the "rest" for each item
09:28:23 <Cale> nstdloop_: You can read it as a sort of nested loop, if you like
09:28:32 <nstdloop_> so how would this look if we used >>=?
09:28:36 <Cale> x <- [1..3] means x is chosen (in all possible ways) from the list [1..3]
09:28:43 <dwcook> nstdloop_, x <- [1..3] does not mean the same thing as let x = [1..3]
09:29:01 <joelteon> and the MonadComprehensions extension will actually translate list comprehension syntax into what Peaker said
09:29:06 <joelteon> I think that's what it's called
09:29:08 <Peaker> nstdloop_: [1..3] >>= \x -> guard (even x) >> let z = x `div` 2 in [10,20,30] >>= \y -> [(x, y)]
09:29:16 <rasfar> > x <- [1..3] :: Expr
09:29:17 <lambdabot>  not an expression: `x <- [1..3] :: Expr'
09:29:21 <Cale> > [1..3] >>= \x -> guard (even x) >> let z = x `div` 2 in [10,20,30] >>= \y -> [(x,y,z)]
09:29:23 <lambdabot>  [(2,10,1),(2,20,1),(2,30,1)]
09:29:24 <Peaker> nstdloop_: every (>>=) in this case is a loop
09:29:31 <rasfar> > do x <- [1..3] :: Expr
09:29:32 <lambdabot>  The last statement in a 'do' block must be an expression
09:29:32 <lambdabot>    x <- [1 .. 3] :: Expr
09:29:41 <binroot> I have a list of data types that look like `Item { key :: Int, a :: Maybe Int, b :: Maybe Int }` how can I combine the keys to remove duplicates?
09:29:46 <rasfar> > do { x <- [1..3] ; return x } :: Expr
09:29:47 <lambdabot>  Couldn't match type `[b0]' with `Debug.SimpleReflect.Expr.Expr'
09:29:47 <lambdabot>  Expected type: [b0]
09:29:47 <lambdabot>                 -> (b0 -> [b0]) -> Debug.SimpleReflect.Expr.Expr
09:29:47 <lambdabot>    Actual type: [b0] -> (b0 -> [b0]) -> [b0]
09:30:01 <Peaker> rasfar: it doesn't seem Monad comprehensions are enabled in lambdabot
09:30:10 <Peaker> I'd prefer list comprehensions to be gone, replaced by ordinary do blocks
09:30:11 <rasfar> kay
09:30:27 <Cale> I really like list comprehensions sometimes
09:30:28 <Peaker> TIOOWTDI :)
09:30:41 <joelteon> yeah, they can be nice
09:30:48 <Peaker> Cale: moving the eventual result up-front is so weird. Everything is defined bottom-up style except the final result
09:30:49 <Cale> They place a focus on the element rather than the way that element is chosen
09:31:10 <Cale> You of all people I think would like the option to switch the direction of things ;)
09:31:23 <dwcook> binroot, Map and fromListWith
09:31:24 <Cale> Weren't you arguing that you liked & the other day? :)
09:31:36 <Peaker> Cale: I only like & because it has the right fixity along <&> and >>= :)
09:31:46 <nstdloop_> Peaker: Interesting. Thanks.
09:31:50 <Peaker> Cale: I'd love to have a single direction everything uses (ideally right-to-left)
09:31:52 <binroot> @pl \n o -> (++)
09:31:52 <lambdabot> const (const (++))
09:32:08 <dwcook> @hoogle fromListWith -- binroot
09:32:09 <lambdabot> Parse error:
09:32:10 <lambdabot>   fromListWith -- binroot
09:32:10 <lambdabot>                  ^
09:32:12 <dwcook> @hoogle fromListWith
09:32:13 <lambdabot> Data.IntMap.Strict fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
09:32:13 <lambdabot> Data.IntMap.Lazy fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
09:32:13 <lambdabot> Data.Map.Lazy fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
09:32:14 <Cale> I suppose I'm also *very* used to set comprehensions
09:32:15 <bennofs> \ y e s :)
09:32:20 <binroot> @pl \n o -> (++) n o
09:32:20 <lambdabot> (++)
09:32:34 <dwcook> I suppose you'd also need to throw a map in there
09:32:45 <Peaker> Cale: I think comprehensions appeal to you as a mathematician similarly to the way +=, *=, etc appeal to me as a former imperative programmer :)
09:32:49 <Cale> Peaker: There are also cases where I've found occasion to use list comprehension syntax with no binds and only a single guard
09:33:07 <Cale> like ["foo" | cond]
09:33:13 <Peaker> Cale: I've used [x | foo] too, now that I think of it.  though now I tend to use  x <$ guard foo
09:33:18 <binroot> @pl \n o -> zip n o
09:33:18 <lambdabot> zip
09:33:21 <Cale> especially concatenated with similar list comprehensions
09:34:12 <Peaker> here is me abusing [ .. | .. ]  notation: https://github.com/Peaker/lamdu/blob/master/bottlelib/Graphics/UI/Bottle/Widgets/TextEdit.hs#L214
09:34:13 <rasfar> > [x | x <- [1..3]] :: Expr   -- had to do it, the previous was so far off the mark
09:34:15 <lambdabot>  Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
09:34:15 <lambdabot>              with actual type `[t0]'
09:34:21 <Peaker> Cale: and concat'ing it with many like it
09:34:22 <rasfar> sigh
09:34:33 <Cale> Yep!
09:34:45 <Cale> I think list comprehensions have their place
09:35:04 <Cale> (and monad comprehensions generally)
09:35:28 <Cale> They're a little quieter, and a little better when you have many guards and few generators
09:36:05 <Cale> and when you're more concerned with the generic element of the list than the generators and conditions
09:36:13 <Peaker> [ x | y ]  vs.  (x <$ guard y)
09:36:20 <Peaker> they require less imports, that's for sure :)
09:36:20 <Cale> yeah
09:37:08 * hackagebot uuagc 0.9.50.1 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.50.1 (JeroenBransen)
09:37:08 <bennofs> Peaker: Compare x <$ do guard $ longExpression vs [x | longExpression]
09:37:21 <Cale> and they don't steal any syntax which isn't already stolen, which is good
09:38:04 <bennofs> Or even x <$ guard (longExpression) >> guard (longExpression2) vs [x | longExpression, longExpression 2]
09:38:31 <Peaker> x <$ guard (looong expression)     vs.    [ x | looong expression ]   ?  Only slightly more noise
09:38:51 <bennofs> I still don't like those parens :P
09:38:59 <Peaker> bennofs: same amount of parens?
09:39:07 <Cale> Well, you have brackets in the list comprehension case ;)
09:39:15 <Peaker> x<$ guard (foooooooo) && (baaaaar)  <- for more than 1 need more parens.
09:39:22 <Peaker> oops
09:39:35 <Peaker> x<$ guard ((foooooooo) && (baaaaar))  <- for more than 1 need many parens  :(
09:40:22 <Peaker> though && is likely low precedence enough to avoid need for the inner parens
09:40:32 <Peaker> (even if it's not as low-precedence as a comma)
09:41:39 <Peaker> refactoring Lamdu's basic Expr types to have a paremterized type for the lambda/get-var names is taking so long. With a good IDE it'd be a piece of cake!
09:42:03 <Peaker> (compile loop is a few seconds of wait for each fix :( )
09:44:52 <startling> Peaker, x <$ guard foooo <$ guard baaaar
09:45:20 <Peaker> not quite the right type?
09:45:25 <startling> er
09:45:33 <startling> x <$ guard fooooo <* guard baaar
09:45:48 <Peaker> you can use >>/<*/*> but then might as well use && ?
09:46:05 <startling> I thought you wanted to avoid /nested/ parens
09:46:19 <Peaker> hmm.. <* and *> have precedence 4. && has 3, and >> has 1
09:46:44 <Peaker> so >> is probably best?
09:47:11 <startling> I guess so.
09:47:19 <startling> weird that >> and *> have different fixities.
09:48:45 <rmorgan> Hi, I have a question about list comprehensions. I am trying to write a function to caculate a covariance: http://pastebin.com/4Z1ALTg0. Instead of iterating through each list of values, it calculates all possible combinations.  How can I make it only calculate the cross products for the corresponding values?
09:48:46 <mauke> The paste 4Z1ALTg0 has been copied to http://lpaste.net/97229
09:48:58 <Cale> zip?
09:49:08 <Cale> (xv,yv) <- zip x y
09:49:38 <Cale> You could use what's called a parallel list comprehension, though those aren't terribly popular
09:49:51 <Cale> [ ... | xv <- x | yv <- y]
09:50:06 <rmorgan> okies, i'll give it a whirl. Seemed like getting the values into a tuple would be helpful
09:50:10 <Cale> (you'll have to turn on that extension though)
09:50:32 <rmorgan> interesting -- i haven't seen that before. i've only been learning haskell for 2 weeks
09:51:24 <Cale> Yeah, to use that, you would put {-# LANGUAGE ParallelListComp #-} at the top of your file
09:51:39 <Cale> But most people would just use zip
09:51:50 <startling> haha
09:53:31 <rmorgan> nice!  I think it's working
09:53:47 <rmorgan> I knew it was something simple like that
09:53:56 <edwardk_> playing around with generic memo combinators: http://lpaste.net/97230 basically updating the idea from data-memocombinators to with with GHC.Generics automagically
09:54:43 <edwardk_> so in the end you just get
09:54:45 <edwardk_> class Memo a where memo :: (a -> b) -> a -> b  -- where you can write instance Memo a => Memo [a]   and it just derives the right memo-combinator
09:55:05 <ReinH> edwardk_: nice!
09:55:06 <Peaker> edwardk_: cool :)
09:55:25 <edwardk_> i went er.. a bit nuts making it derive the right thing for Tree, which required me to build Memo1, and GMemo1
09:55:43 <edwardk_> that should work for anything you can make Generic or Generic1
09:56:10 <edwardk_> and the (~>) trie type works like a memoized reader
09:56:45 <Peaker> I think this kind of memo is really nice & elegant. But that maybe the ugliness of ugly-memo + ephemeral data structure + some sort of LRU   might be worth the extra performance?
09:57:09 <edwardk_> thinking about packaging it up with for hackage
09:57:31 <edwardk_> the question is how much extra performance you get in practice out of ugly-memo over the generic memo-combinator approach
09:57:55 <Peaker> I think ugly-memo was already much faster -- and it uses a naive Data.Map (which pays an unnecessary cost for unneeded persistence)
09:58:05 <Peaker> and it also doesn't do LRU, which it could do given it has free IO power there
09:58:10 <edwardk_> *nods*
09:59:28 <edwardk_> just found lennart's old uglymemo article
09:59:44 <bennofs> Can I use (,) qualified, as in Prelude.(,) ?
10:00:49 <edwardk_> bennofs: (,) is syntax not an operator
10:01:02 <bennofs> :|
10:01:41 <edwardk_> :| is an operator, not syntax. =)
10:05:46 <quchen> :)
10:06:01 <quchen> is an operator, but also a syntax error ;-)
10:07:45 <binroot> @pl (\x -> ((True &&) (not x), not x))
10:07:46 <lambdabot> ap ((,) . (True &&) . not) not
10:08:54 <bennofs> binroot: Is this a test of @pl?
10:09:00 <Peaker> join (,) . not ?
10:11:08 <startling> quchen, not always. ( :)
10:11:48 <quchen> inb4 robot monkey operator once again
10:12:47 <joelteon> god, my network package is broken again
10:13:09 <joelteon> I installed it from git HEAD and it's still getting the duplicate symbol errors
10:15:47 <Peaker> isn't the network package distributed as binary inside the haskell platform?
10:16:15 <edwardk_> Peaker: one reason why i'm exploring this option is that with some work i can memoize full function spaces. e.g. (Memo a, Memo b) => ((a -> b) -> r) -> (a -> b) -> r
10:16:32 <edwardk_> that requires me to "double-down" on this sort of structure
10:16:35 <startling> edwardk_: woah, cool
10:19:01 <Peaker> edwardk_: hmm.. so if you take the "static-table" view of functions, you mean you can memoize function keys?  Not sure how you could compare the memo-tables representing the functions with reasonable performance?
10:19:30 <edwardk_> well, its pointwise evaluation of the entire function
10:19:38 <edwardk_> not saying it'd be great just that i could do it =)
10:19:42 <startling> oh heh
10:20:00 <edwardk_> if 'r' is sufficiently complicated it could pay out
10:21:09 <edwardk_> now the real question is if you can play 'modulus of continuity' games somehow, wth an ugly memoizer
10:22:24 <edwardk_> e.g. the function from ((a -> b) -> r) inspects (a -> b) at only so many places, so remember the probes it makes and update a memo-table
10:41:12 <zeiris_> Has anyone played around with Atom, to the point of figuring out how to define new data types? (For doing <== and value on Enum types, or defining bitfields in the state struct, or creating custom bitmasked types for flags...)
10:42:02 <zeiris_> The various ASTs used seem to be limited to the standard Word/Int 8/32/16 and that's it, but I'm probably not getting their design.
10:44:49 <joelteon> has anyone used pipes-attoparsec here?
10:54:50 <johannesbodannes> is there some function somewhere that does this?:
10:55:05 <johannesbodannes> \s -> return (someArbitraryFunction s)
10:55:32 <Kinnison> return . someArbitraryFunction ?
10:55:37 <simpson> @pl \s -> return (f s)
10:55:37 <lambdabot> return . f
10:55:48 <johannesbodannes> oh bugger, that's so obvious UGH
10:55:48 <johannesbodannes> thank you
11:02:09 <FreeFull> johannesbodannes: That's also the same as  fmap/liftA/liftM
11:02:10 <narxus> How do I register a new account?
11:02:21 <FreeFull> :t \f -> return . f
11:02:23 <lambdabot> Monad m => (a -> b) -> a -> m b
11:02:24 <FreeFull> :t liftM
11:02:25 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
11:02:30 <FreeFull> Actually, no, it isn't
11:02:32 <FreeFull> Nevermind
11:03:01 <FreeFull> If there would be a bind in there it'd be
11:07:19 * hackagebot cabal-install-bundle 1.18.0.2.1 - The (bundled) command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-bundle-1.18.0.2.1 (BartoszCwiklowski)
11:07:21 <narxus> Is there a command to register a new account here?
11:09:54 <geekosaur> "here"?
11:10:37 <narxus> I don't know how to register in this site. There isn't any "register" page.
11:10:47 <startling> narxus, you mean freenode?
11:10:55 <narxus> yes
11:11:33 <shachaf> Try asking in #freenode. Or use /msg nickserv help
11:12:07 <startling> I guess narxus is probably using webchat, so "this site" makes sense in their context.
11:12:38 <narxus> Yes.
11:12:55 <shachaf> OK. See http://freenode.net/ for more information on what Freenode is and how it works.
11:13:29 <startling> narxus, if you begin to use irc often you should probably be aware that most people connect to freenode with a standalone client, and that webchat kind of sucks.
11:13:39 <startling> narxus: but you don't really need to register to ask questions here.
11:13:49 <narxus> I'll keep that in mind.
11:14:02 <narxus> How do you guys connect here then?
11:14:04 <shachaf> You can ask Haskell questions registered or not.
11:14:13 <shachaf> IRC questions are usually off-topic either way. :-)
11:16:31 <narxus> startling, Are you chatting via freenode?
11:16:55 <geekosaur> they are here, they are chatting via freenode
11:17:01 <geekosaur> "freenode" is an IRC network.
11:17:02 <startling> narxus: I'm chatting on freenode with the client irssi (in the same way you can be on google.com with the client firefox).
11:17:12 <geekosaur> freenode.net also provides a web-IRC gateway
11:18:05 <kylcarte> Is there an extension akin to PatternGuards that allows for pattern matching in comprehensions that is not over a list? eg. trivially: [ a | x <- [0..9], Just a <- lookup x someAList ]
11:18:07 <kylcarte> ?
11:18:39 <startling> > [a | x <- [0..9], Just a <- Just 2]
11:18:41 <lambdabot>  Couldn't match expected type `[Data.Maybe.Maybe t0]'
11:18:41 <lambdabot>              with actual type `Data.Maybe.Maybe a0'
11:18:46 <narxus> Ok I understand now. Thanks
11:18:48 <kylcarte> and-- doesn't resort to isJust/fromJust? I'm looking for a general mechanism
11:18:49 <startling> > [a | x <- [0..9], Just a <- [Just 2]]
11:18:50 <lambdabot>  [2,2,2,2,2,2,2,2,2,2]
11:18:52 <shachaf> and++
11:19:02 <startling> > [a | x <- [0..9], Just a <- [Nothing]]
11:19:03 <lambdabot>  []
11:19:23 <startling> kylcarte, ^ failing a pattern-match is safe in [].
11:19:49 <kylcarte> startling: I have that much, but it's hackish. It's unnecessarily constructing and deconstructing a list
11:20:05 <startling> kylcarte, we do that all the time in Haskell.
11:20:16 <startling> you could use "return" if you want.
11:20:18 <ReinH> But it has the essential quality of being possible.
11:20:32 <kylcarte> startling: it's not necessarily something to aspire to, or resign to, if unnecessary :)
11:21:20 <startling> kylcarte, you can use "let ... = ... in ..." but then you lose the safety that [] gives you.
11:21:49 <kylcarte> startling: "let ... = " gives a hard failure, not a pattern match failure.
11:21:57 <kylcarte> which I think is what you were saying.
11:22:01 <startling> > let Nothing = Just 12 in []
11:22:03 <lambdabot>  []
11:22:12 <startling> heh
11:22:19 <startling> > let Just a = Nothing in [a]
11:22:21 <lambdabot>  [*Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Da...
11:22:29 <triliyn> Lazinessss
11:22:40 <startling> it's still a pattern-match failure.
11:22:57 <kylcarte> > [ a | x <- [0..9], let Just a = lookup x [(i,a) | i <- [0,2..9], let a = i + 2 ] ]
11:22:59 <lambdabot>  [2,*Exception: <interactive>:3:24-80: Irrefutable pattern failed for pattern...
11:23:00 <startling> kylcarte: you could also use maybe/fromMaybe
11:23:12 <startling> :t fromMaybe
11:23:14 <lambdabot> a -> Maybe a -> a
11:23:15 <startling> :t maybe
11:23:16 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:23:54 <kylcarte> startling: I know of plenty of things I *can* use. I'm asking if you know if the general mechanism exists. Thanks, though.
11:24:38 <startling> I showed you the general mechanism. You didn't like it.
11:24:49 <narxus> Why did 5 * -3 result to an error?
11:25:03 <startling> > 5 * -3
11:25:05 <lambdabot>  Precedence parsing error
11:25:05 <lambdabot>      cannot mix `GHC.Num.*' [infixl 7] and prefix `-' [infixl 6] in the same ...
11:25:10 <startling> > 5 * (-3)
11:25:11 <lambdabot>  -15
11:25:29 <kylcarte> startling: no offense intended. what you showed had already occurred to me, and yes, I'm unsatisfied with it.
11:25:47 <startling> kylcarte: no offense taken!
11:25:54 <startling> but like
11:25:55 <kylcarte> great :)
11:26:13 <narxus> starting: I know that. But why did  5 * -3 resulted to a precedence parsing error?
11:26:28 <startling> @src liftM -- this also "unnecessarily" constructs a list
11:26:28 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
11:26:32 <startling> well
11:26:56 <ReinH> narxus: That is parsed as 5 * - 3.
11:27:03 <kylcarte> It's a feature that I feel *should* be provided by the PatternGuard extension, but it isn't there.
11:27:28 <narxus> So it thought that it will 5 also subtract 3?
11:27:45 <startling> :t maybeToList
11:27:46 <rasfar> narxus: it's a nuisance, but unary negation in Haskell must be parenthesised (almost always)
11:27:47 <lambdabot> Maybe a -> [a]
11:27:56 <startling> kylcarte: maybe something like that ^ ?
11:27:59 <ReinH> narxus: What should 5 * + 3 do?
11:28:16 <kylcarte> I would love to be able to write the comprehension: [ a | x <- [0..9], Just a <- lookup x someAList ]. Of course, that's not the best syntax, since those two '<-'s mean different things.
11:28:21 <narxus> Also a precedence error
11:28:38 <ReinH> narxus: right, it's no different. If you want negative 3 you need to use parens (-3)
11:28:50 <kylcarte> people have already made the argument that the PatternGuard syntax is confusing, since it reuses the binding arrow from do syntax
11:28:52 <startling> > [a | x <- [0..9], Just a <- maybeToList (lookup x [])]
11:28:53 <rasfar> > -3
11:28:54 <lambdabot>  can't find file: L.hs
11:28:54 <lambdabot>  -3
11:29:25 <startling> there might be an Alternative f => Maybe a -> f a somewhere.
11:29:36 <kylcarte> so perhaps the better alternative would be to use a different syntax for what PatternGuards already provides, and use it as well in comprehensions.
11:29:40 <kylcarte> for pattern matching
11:29:44 <kinslayer> however > -3 * 5
11:29:51 <kinslayer> > -3 * 5
11:29:51 <ion> @type maybe empty pure
11:29:53 <lambdabot>  -15
11:29:53 <lambdabot> Alternative f => Maybe a -> f a
11:30:02 <triliyn> kylcarte: do you know of catMaybes?
11:30:20 <kylcarte> triliyn: yes
11:30:40 <kylcarte> not what I'm looking for
11:30:49 <ReinH> the way Haskell negates numbers is one of the few annoying (but necessary) inconsistencies in the language
11:30:55 <tromp> sounds like a heisenberg operator
11:30:55 <triliyn> kylcarte: to what problem are you looking for the general solution then? I'm not sure I understand
11:31:24 <tromp> sorry schroedinger operation
11:31:42 <kinslayer> ReinH: Well you can't get everything :D
11:31:43 <kylcarte> triliyn: pattern matching in list comprehensions that operates on non-list input, as per my examples above.
11:31:59 <ReinH> kinslayer: I know
11:32:14 <startling> kylcarte, <- means a specific thing. you're asking for a way to overload it to mean something else.
11:32:21 <triliyn> kylcarte: oh, so it's a list comprehension thing in particular, not a Maybe thing?
11:32:26 <startling> the way you do that is "return" it first.
11:32:29 <kinslayer> ReinH: And all the other good things in haskell, this is an acceptable "fault" :D
11:33:19 <kylcarte> startling: we're already reusing it with PatternGuards, it just so happens that the two don't uses don't happen in the same context, so you can infer which is meant without knowing anything about types of expressions involved
11:33:20 <nooodl> i propose doing things the APL way. 5 + ¯3 <-- see, fixed
11:33:44 <kylcarte> s/don't u/u/
11:34:06 <AlainODea> ReinH: the handling of negation is actually a compromise favoring consistency over intuitive behavior.  Handling unary operators specially would be problematic.
11:34:17 <abstract-alf_> howdy
11:34:31 <kylcarte> does anyone know who words on PatternGuards?
11:34:44 <startling> > do { Just a <- []; return a; } -- kylcarte: in do notation it has the same meaning.
11:34:45 <kylcarte> works*
11:34:46 <lambdabot>  []
11:35:18 <Cale> kylcarte: They're a complete feature in GHC. I think they were SPJ's idea.
11:35:21 <ReinH> AlainODea: (+1) vs (-1) is the inconsistency I am referring to.
11:35:24 <shachaf> PatternGuards are a completely different deal from the thing you get in list comprehensions or do-notation.
11:35:35 <shachaf> They happen to use the <- syntax but there is no monad involved.
11:35:43 <kylcarte> startling: that's a hidden call to 'fail'
11:35:54 <narxus> Are string concatenations allowed in haskell?
11:35:55 <kylcarte> which in the [] Monad, happens to be (const [])
11:36:03 <Cale> narxus: sure
11:36:09 <triliyn> narxus: strings are lists of characters, so you just use (++)
11:36:18 <abstract-alf_> IO Monad Question: Say I have a list of Person records.  What's the most concise way to print each Person on its own line in GHCi?  Here's what I've tried: map (show . (++ "\n")) persons; map print persons
11:36:21 <Cale> > "hello" ++ "world"
11:36:23 <lambdabot>  "helloworld"
11:36:31 <Cale> mapM print persons
11:36:35 <ReinH> abstract-alf_: mapM_ print persons
11:36:38 <Cale> or mapM_ print persons
11:36:39 <Cale> yeah
11:36:40 <abstract-alf_> that was quick
11:36:53 <narxus> So... There's no operator overloading?
11:36:56 <AlainODea> ReinH: good point.  I hadn't thought of that
11:36:57 <abstract-alf_> wow
11:36:59 <kylcarte> shachaf: I get that, which is why I think I support the notion of changing the PatternGuard syntax so that it can be used and disambiguated in other places, where other pattern matching is used.
11:37:02 <startling> it strikes me that strings-as-lists-of-characters isn't quite right for unicode strings.
11:37:03 <abstract-alf_> ReinH: thanks
11:37:07 <geekosaur> narxus, not in the sense you mean
11:37:07 <abstract-alf_> Cale: thanks
11:37:11 <startling> e.g. "length" is wrong.
11:37:16 <startling> so is (==)
11:37:24 <joelteon> help, I don't know how to resolve this http://lpaste.net/97231
11:37:28 <Cale> narxus: There's everything-overloading of a sort via typeclasses, but you have to know up front that you're going to require the polymorphism
11:37:34 <Cale> There's no ad-hoc overloading of things
11:37:36 <ReinH> startling: It isn't, but Data.Text
11:37:53 <startling> ReinH: yeah.
11:37:54 <Cale> :t (<)
11:37:56 <narxus> I see... Thanks, Cale
11:37:56 <lambdabot> Ord a => a -> a -> Bool
11:38:09 <Cale> You can define (<) for new datatypes by making a new instance of the Ord typeclass
11:38:14 <Cale> for instance
11:38:23 <ReinH> startling: Data.Text is a pretty well-behaved unicode string library, including correct case mappings, etc.
11:38:30 <geekosaur> (+) is already "overloaded". what we don't do is *arbitrary* overloads... you cannot borrow a math operator on numbers for use as string concatenation
11:38:35 <Cale> Or you can define new types of numbers by writing instances of Num and related classes
11:39:16 <ReinH> geekosaur: sure you can, instance Num String where...
11:39:17 * ReinH ducks
11:39:31 <nooodl> does lambdabot import Data.Text?
11:39:35 <AlainODea> ReinH: winning :)
11:39:38 <Cale> Yeah, you could define an instance of Num for String, but it wouldn't likely make so much sense
11:39:45 <geekosaur> ^
11:39:46 <joelteon> oh, I have to use many1 and satisfy, not takeWhile
11:39:54 <ReinH> Cale: I was being tongue-in-cheek :)
11:40:05 <mgsloan> Prelude.PHP exports some pretty excellent Num instances for String
11:40:08 <mgsloan> http://hackage.haskell.org/package/acme-php-0.0.3/docs/src/Prelude-PHP.html
11:40:12 <ReinH> mgsloan: o_O
11:40:23 <Cale> In particular, you'd want  fromInteger m + fromInteger n to be equal to fromInteger (n + m), and it's unlikely that what you'll come up with will satisfy that, if (+) means concatenation.
11:40:25 <nooodl> i love Prelude.PHP
11:40:26 <ReinH> mgsloan: hahahaha
11:40:27 <mgsloan> My favorite part is the trig functions
11:40:44 <nooodl> TRUE | FALSE | FILE_NOT_FOUND
11:40:45 <Cale> I suppose it might! :)
11:41:00 <abstract-alf_> Data question: For a record data type, why do you need "deriving(Show)" to enable toString() support?  Why can't Haskell just know that my record of strings and ints can be displayed as a string?
11:41:20 <triliyn> nooodl: also, true :: Prelude.PHP.Bool and false :: Prelude.Bool
11:41:22 <Cale> abstract-alf_: Because maybe you want to write your own Show instance.
11:41:33 <shachaf> Or maybe you don't want a Show instance at all.
11:41:45 <ReinH> Cale: well that's already not true if you're mapping to a floating point representation ;)
11:41:49 <shachaf> toString() isn't a thing, anyway.
11:41:49 <abstract-alf_> schachaf: why wouldn't you?
11:41:58 <Cale> Yeah, it's just called show here :)
11:42:00 <shachaf> Maybe you have an abstract data type.
11:42:09 <abstract-alf_> shachaf: it's a thing I'm used to from other languages :)
11:42:12 <Cale> You *usually* want a Show instance of *some* sort
11:42:24 <Cale> But maybe it's not the default one.
11:42:29 <shachaf> Maybe you're representing a computer program!
11:42:40 <abstract-alf_> ah
11:42:42 <Cale> But yeah, for things like functions and such, you can't derive instances
11:42:51 <Cale> and you also can't write very good ones
11:43:04 <Cale> (It can still be useful to have crappy ones)
11:43:14 <shachaf> At any rate, it's nice to be explicit about this sort of thing.
11:43:16 <Cale> (but there's more than one way to do it)
11:43:18 <ReinH> Cale: just like crappy instances of Num! :D Ok I'll stop.
11:43:31 <abstract-alf_> please show me a custom Show instance for the following record type: Data Person = Person{lastname :: String, firstname :: String}
11:43:41 <Cale> instance Show Person where
11:43:55 <abstract-alf_> Cale: that's the whole thing?
11:44:00 <Cale> no
11:44:12 <shachaf> It's possible that if you feel the need to end your line with "Ok I'll stop." you shouldn't have typed it in the first place.
11:44:27 <ReinH> shachaf: thanks
11:44:29 <Cale>   show (Person ln fn) = concat ["(Person: ", ln, ", ", fn, ")"]
11:44:41 <triliyn> instance Show Person where show Person{ lastname=l, firstname=f } = "Hi, my name is " ++ f ++ " " ++ l
11:45:14 <ReinH> one thing I don't miss any more is record syntax.
11:45:26 <Cale> hm?
11:45:26 <abstract-alf_> ReinH: why don't you miss it?
11:45:30 <abstract-alf_> Cale: thanks
11:45:31 <ReinH> Mostly because of lens
11:45:39 <abstract-alf_> triliyn: thanks
11:45:43 <ReinH> And because it isn't very easy to use
11:45:53 <abstract-alf_> lens...
11:45:54 <triliyn> I really dislike the weird = pattern matching
11:45:57 <Cale> Yeah, I suppose we could also write it like:  show p = lastname p ++ ", " ++ firstname p
11:46:10 <triliyn> Because it kind of has flipped semantics compared to the = in function definitions
11:46:17 <triliyn> The name being defined is on the right
11:46:18 <ReinH> triliyn: yep
11:46:24 <ReinH> triliyn: I used to mess that up all the time
11:46:31 <abstract-alf_> ah, I see
11:46:34 <rasfar> instance Show Person where show Person l f = map Char.toUpper l ++ ", " ++ f
11:46:46 <Cale> rasfar: You need moar parens
11:46:49 <rasfar> instance Show Person where show (Person l f) = map Char.toUpper l ++ ", " ++ f
11:46:53 <rasfar> :)
11:46:56 <triliyn> I don't think I've messed it up in a pretty long time, but it's confusing to read
11:47:22 <ReinH> triliyn: you'd be surprised how many times I beat my head against that wall. Or maybe you wouldn't.
11:47:26 <Cale> This is getting away from the original question, but you could use RecordWildCards:
11:47:32 <abstract-alf_> is there something instead of Record that I should use?
11:47:45 <ReinH> abstract-alf_: nope :)
11:47:51 <abstract-alf_> oh, ok :)
11:47:53 <Cale> instance Show Person where show (Person {..}) = unwords [firstname, lastname]
11:47:55 <abstract-alf_> I rather like them
11:48:07 <ReinH> abstract-alf_: They're nice, but having to do too much with record syntax is a pain
11:48:11 <ReinH> especially nested records
11:48:14 <ReinH> thus lens
11:48:27 <Cale> Records aren't really records, they're just syntax sugar for algebraic datatypes.
11:48:41 <Cale> If you just keep that in mind, they do what they do okay.
11:48:46 <m1dnight> guys, difference list appending (e.g: \x -> f (g x)) is faster. Is it because you 'inject' your value in the end of your list instead of walking down your entire list? Or why is it exactly?
11:48:50 <m1dnight> Can't seem to figure it out
11:48:50 <ReinH> Right, they're just product types with an easy way to define field accessors
11:48:59 <ReinH> It's when you start using the weird syntax that it gets out of hand...
11:49:07 <Cale> It would be nicer if the field names were automatically lenses, but lenses didn't exist until quite recently.
11:49:09 <abstract-alf_> ReinH: from what I've seen, Haskell records are so much better than full-on classes in C#.  no getter/setter boilerplate!
11:49:24 <edwardk_> cale: wait for 7.10 =)
11:49:34 <ReinH> abstract-alf_: Oh they're better than a lot of stuff ;) But they're still a bit of a pain.
11:49:43 <triliyn> m1dnight: it's about associativity, I think
11:50:00 <Cale> edwardk_: That's going to be interesting. :)
11:50:10 <Cale> edwardk_: any details on how that's going to work?
11:50:25 <triliyn> It's not always faster, but if you're constructing a list recursively, you might do it in such a way that you associate to the left
11:50:26 <m1dnight> Well, in LYAH I can understand that if you append your newest value to the end, it's not efficient. And if you append them in the beginning it is . I can see that.  But it's harder to see for difference lists..
11:50:45 <edwardk_> cale: its in the writeup gundry did on records. basically they won't _quite_ be lenses, but you'll be able to use a combinator to turn one into a lens-style type changing lens
11:50:52 <Cale> hmm
11:51:04 <edwardk_> and you'll be able to use them directly as a data-lens style lens
11:51:07 <m1dnight> I think you keep your right associativiy, but you have a pointer to your last position or something
11:51:17 <m1dnight> because it's a function instead of a list.
11:51:19 <edwardk_> the composition is backwards to use them directly as lens-style lenses
11:51:25 <triliyn> m1dnight: with regular lists, you can write (((l1 ++ l2) ++ l3) ++ l4
11:51:35 <Cale> I'd think it's a little unfortunate to not take advantage of the fact that 'lens'-style lenses don't actually require anything special
11:51:49 <geekosaur> hm? it's just a chain of calls. when you "append" ot it, you wrap a new function call on the outside, which is fast. you pay for it when constructing the result string (remember, lazy)
11:51:53 <edwardk_> foo.bar means the wrong thing, but 'whatever foo . whatever bar' will be able to convert to lens whenever we name 'whatever'
11:51:56 <triliyn> Which traverses l1 many times, l2 slightly fewer, and l3 twice
11:52:04 <Cale> wait, what?
11:52:11 <m1dnight> geekosaur: so printing out the entire string would still be slow?
11:52:13 <Cale> You're not writing spaces there, and it's confusing me
11:52:25 <Cale> ;)
11:52:28 <ReinH> m1dnight: evaluating the list is slow at any point
11:52:28 <shachaf> Cale: (foo.bar) means (foo . bar), hth
11:52:37 <Cale> shachaf: okay :)
11:52:41 <edwardk_> foo.bar for existing field accessors compose backwards from lens style field accessors, so 'foo . bar' would have very different semantics whether it was a lens or an accessor
11:52:58 <ReinH> m1dnight: the difference is that with regular lists you pay for it each time when you construct a new list via concatenation
11:53:02 <Cale> hrm
11:53:04 <dmead> hi Cale
11:53:08 <ReinH> m1dnight: while with diff lists you pay it only once you evaluate the constructed list
11:53:26 <m1dnight> oh okay, like with appending in the beginning of the list
11:53:27 <edwardk_> and in general you get inference woes that are terrible, so we can't just make the field accessor name _be_ the lens, in the lens-library sense, but it can generate a data type that we can unwrap to get a lens
11:53:32 <geekosaur> right, you only scan through the final list once instead of once per append
11:53:45 <Cale> sigh, this sounds like a weird compromise
11:53:52 <edwardk_> and you can make instances of the accessor types for things like data-lens, etc. directly
11:53:52 <dmead> edwardk_, just saw your talk on  lenses. good job
11:53:52 <ReinH> m1dnight: no, it doesn't change the cost of (++)
11:53:53 <m1dnight> Yeah, so in essence, it's because you wrap it in a function call (ie nothing gets evaluated), and when you append it, it constructs an entire list
11:53:55 <Cale> I haven't seen the writeup though
11:54:10 <edwardk_> cale: it makes sense when you work through the ramifications of type inference
11:54:14 <ReinH> m1dnight: it changes when and how you pay that cost
11:54:17 <Cale> Why not just define the field names as lens-style lenses?
11:54:17 <rasfar> m2dnight: you might like to check out the source (if you're using Data.DList), it's not long: http://hackage.haskell.org/package/dlist-0.5/docs/src/Data-DList.html#DList
11:54:24 <rasfar> ^m1dnight, sorry
11:54:34 <edwardk_> cale: because you'd lose existing code that uses them as functions
11:54:46 <triliyn> A simplified version of the source is already in LYAH I think
11:54:47 <ReinH> m1dnight: consider some typically unperformant use of string concatenation like html template evaluation
11:54:48 <Cale> Well, yeah...
11:54:49 <edwardk_> and compatibility was deemed more important than a nicer lens story
11:55:03 <Cale> Though, you could just turn this on per-module where you wanted it?
11:55:14 <ReinH> m1dnight: with a typical string, you are concatenating repeatedly onto the end of some already-evaluated structure, so you are paying your O(n) tax repeatedly.
11:55:18 <triliyn> (It's basically the same but it doesn't make difference lists abstract)
11:55:29 <m1dnight> oh okay
11:55:31 <edwardk_> the story of how to turn it on and what it means when the field isn't in use in multiple records, etc. is a whole other can of worms ;)
11:55:33 <m1dnight> i understand that
11:55:43 <m1dnight> and appending in the beginning is just O(<length of appended part>)
11:55:44 <ReinH> m1dnight: with a diff list you are adding a single new term of the form (++xs)
11:55:44 <Cale> So if you define the datatype in a module where the extension was turned on, then you don't get field accessors
11:55:49 <Cale> You just get lenses
11:55:51 <m1dnight> so in total also O(n), which is the same with difference lists
11:55:55 <ReinH> m1dnight: when you finally evaluate all those (++xs) terms, you pay the O(n) cost once.
11:56:00 <m1dnight> I get it now :)
11:56:16 <m1dnight> thanks ReinH for your time and patience! :)
11:56:19 <ReinH> m1dnight: np :)
11:56:44 <Cale> Alternately, we could do something like make 'lenses' a keyword iff it occurs after 'deriving'
11:57:02 <Cale> i.e.  data Foo = ... deriving lenses
11:57:05 <edwardk_> the main thing bringing lenses in to the equation did was defuse any nonsense about overloading (.) in weird ways
11:57:45 <Cale> I *really* don't want to see (.) get used for anything more than composition and the abuses which already exist for module selection.
11:58:05 <Cale> Or, well, if we generalise it, let's *generalise* it
11:58:17 <Cale> Not use it for more selector-type things
11:58:25 <ReinH> > foldr ($) "" [(++" World"), (++"Hello")] -- m1dnight
11:58:26 <lambdabot>  "Hello World"
11:58:36 <startling> Cale: isn't Control.Category that?
11:58:46 <Cale> startling: Yeah, I'm okay with Control.Category
11:58:47 <fizbin> Cale: Doesn't Cont.... what startling said.
11:58:57 <ReinH> m1dnight: that is basically all a diff list does. You build intermediate values of the form [(++ys), (++xs)] because consing is fast.
11:59:01 <Cale> I'd also be okay with (.) = fmap
11:59:06 <Cale> because that's also a generalisation
11:59:09 <m1dnight> oh that's a new way to put it
11:59:11 <fizbin> Whoa. What?
11:59:17 <m1dnight> let me wrap my brain around it for a sec :D
11:59:20 <Cale> But I'm not okay with x.foo sort of record selectors
11:59:27 <pranz1> Cale, isn't that how (.) is defined in Control.Category?
11:59:29 * pranz1 looks it up
11:59:51 <fizbin> Cale: How do you feel about Lens's ^. ?
12:00:13 <Cale> I'm pretty unhappy with practically all of the infix names that lens defines.
12:00:32 <Cale> I think they should all get put in a separate package, or at least a separate module.
12:00:37 <m1dnight> oh okay ReinH good fun that haskell! :) I get the point now
12:00:39 <m1dnight> thanks again man!!
12:00:43 <ReinH> m1dnight: :) np
12:01:10 <fizbin> See, I think that if we aren't going to use . for records, we really shouldn't use . for module separation either.
12:01:11 <pranz1> hmm apperently not
12:01:25 <Cale> fizbin: I would love to stop using . for module separation
12:01:29 <Cale> But it's too late
12:01:34 <fizbin> Yeah.
12:02:00 <Cale> But I don't want to see the number of additional uses for . proliferate in a way which isn't consistent with function composition somehow.
12:02:16 <fizbin> And what would you use instead? There is a slight precedence in other languages for ` , but I'm not sure that would be nicely parseable.
12:02:30 <fizbin> "precedent", not "precedence"
12:03:21 <kuznero> Hi All!
12:03:23 <klugez> \, like in Windows paths.
12:03:25 <Cale> hmm...
12:03:37 <Cale> Well, at one point I was thinking | would be pretty nice
12:03:44 <Cale> (with no spaces)
12:03:50 <fizbin> klugez: It's just ugly enough to maybe work.
12:04:14 <Cale> \ is lambda though
12:04:21 <klugez> Though not sure how it often it would be confused with lambdas.
12:04:33 <narxus> Is there a way to access a folder in haskell?
12:04:37 <klugez> There's no good ascii symbols left and unicode is not an option.
12:04:43 <Cale> narxus: sure
12:04:53 <ReinH> I swear if Haskell starts using \ as some sort of namespace separator I will stop using Haskell o_O
12:04:54 <Cale> System.Directory has lots of stuff for working with files
12:04:54 <narxus> How, cale?
12:05:23 <Cale> | is a little visually noisy though.
12:05:26 <pranz1> narxus: check hackage maybe?
12:05:27 <fizbin> Actually, it'd be unambiguous with lambda, wouldn't it? You can't start a lambda with the preceding symbol being a letter, can you?
12:05:39 <zomg_> ReinH: \ is the best namespace separator ever! Especially if it's relative!
12:05:39 <narxus> Do I use CMD like "cd d:/haskell" first?
12:05:40 <zomg_> ;>
12:05:52 <Cale> If we had explicit syntax for module qualification, perhaps we could leave the module path separator as "."
12:05:56 <ReinH> zomg_: I don't want my Haskell looking like PHP or windows paths :p
12:05:58 <Cale> or make it space or something
12:06:06 <Taneb> Would it be considered nasty if I used StateT Dynamic
12:06:26 <Taneb> I feel guilty about it but no-one is ever gonna see this code
12:06:48 <zomg_> ReinH: yeah you wouldn't believe how many times I've talked with people trying to understand why \ was picked, and why on earth was *relative* namespaces picked...
12:06:59 <zomg_> just sounded like a ton of excuses and laziness
12:07:02 <pranz1> narxus: you use functions to modify or get stuff in the directory
12:07:11 <ReinH> zomg_: you just described most of PHP...
12:07:12 <narxus> What function is it?
12:07:15 <pranz1> so all such functions will return a type of IO a
12:07:29 <narxus> I don't know file i/o in haskell though...
12:07:33 <pranz1> narxus: again, hackage: http://hackage.haskell.org/package/directory-1.0.0.0/docs/System-Directory.html
12:08:16 <FireFly> drop / as a valid operator, use / as module separator
12:08:21 <Cale> lol
12:08:38 <brom> narxus: what do you want to do?
12:09:01 <Cale> Steal 'from' as a keyword, and use that for module qualification.
12:09:04 <narxus> Just compile a haskell program. But I need to set the current directory
12:09:13 <narxus> I am looking at system-directory
12:10:37 <Cale> Then allow it as a declaration in let to have scoped module qualifiers
12:11:18 <Cale> ... where concat from Data ByteString
12:11:26 <Philonous> What's best practice regarding QuickCheck? Is it preferable to avoid the additional dependency or to provide Arbitrary instances for custom data types?
12:11:45 <narxus> I don't know how to use system.directory
12:11:59 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/directory/System-Directory.html
12:12:09 <Cale> narxus: What are you trying to do?
12:12:16 <allsystemsarego> what would be the best way in Haskell to traverse an XML document and generate a list of all the fully-qualified CSS selectors that were encountered?
12:12:19 <darthdeus> hey guys, anyone using vim2hs?
12:12:20 <Cale> You import System.Directory near the top of your module
12:12:36 <Cale> "import System.Directory" without the quotes, just to be clear
12:12:38 <mangaba_leitosa> darthdeus: I am
12:12:50 <darthdeus> mangaba_leitosa: how can i disable the automatic folding? it's not in the readme
12:12:57 <Cale> narxus: and then you can use the things defined in that module, which show up in the docs I linked
12:13:04 <narxus> Omg... that actually worked
12:13:10 <mangaba_leitosa> darthdeus: I use 'set foldlevelstart=200'
12:13:16 <narxus> But I tried to import and it resulted to an error
12:13:26 <Cale> er, what error?
12:13:51 <Cale> narxus: What are you trying to make your program do?
12:13:54 <darthdeus> mangaba_leitosa: perfect, thanks :)
12:13:55 <narxus> I tried to import system.directory
12:14:01 <mangaba_leitosa> darthdeus: np :-)
12:14:02 <Cale> import System.Directory
12:14:04 <kqr> System.Directory
12:14:07 <Cale> not system.directory
12:14:08 <kqr> big letters
12:14:11 <narxus> Create a function that doubles the input
12:14:18 <Cale> errrr
12:14:27 <Cale> What does that have to do with files on disk?
12:14:33 <narxus> Nope
12:14:35 <Cale> You mean copy a file?
12:14:49 <narxus> I am just doing what the tutorial is doing
12:14:54 <narxus> http://learnyouahaskell.com/starting-out
12:14:55 <Cale> hmm
12:14:58 <narxus> Baby;s first functions
12:15:04 <Cale> oh
12:15:15 <Cale> Yeah, then you don't need System.Directory
12:15:33 <Cale> You said you wanted to access a folder, which made me think that you were writing a program which needed to manipulate files somehow
12:15:35 <darthdeus> mangaba_leitosa: does the :HPaste work for you? it points me to http://lpaste.net/new without creating anything :(
12:15:48 <narxus> I would do that somehow.
12:16:03 <Cale> If you have a file in your current directory called baby.hs you can load ghci with:  ghci baby.hs
12:16:05 <narxus> Well, Thanks guys for helping me. Especially pranz1.
12:16:18 <Cale> Or if ghci is already running, you can  :l baby  like they show in the black box there
12:16:34 <Cale> If baby.hs is already loaded, you can :r to reload it
12:17:00 <Cale> (which is useful if you have your text editor open in another window, you can save some changes and then just tap :r to reload)
12:18:04 <Cale> I believe if you're running ghci and you want to change the directory where it's looking for your module, you can  :cd path/to/wherever
12:18:22 <ReinH> (you can also :e to open the file in your $EDITOR, which is rather nice)
12:18:25 <Cale> I don't tend to use that though, I'll just quit ghci and browse to the directory with my shell
12:18:43 <mangaba_leitosa> darthdeus: I didn't try :HPaste, will try now
12:18:52 <ReinH> It will be reloaded when you save and exit
12:19:04 <narxus> I'll get used to haskell one day...
12:19:24 <Cale> This isn't really Haskell I'm talking about, it's just commands for controlling ghci
12:19:54 <bernalex> Cale: ghci should have that python addon thing which lets you open vim inside of the interpreter
12:20:25 <Cale> Well, I don't know what that is in Python, but there is :e
12:20:45 <bernalex> oh right. I forgot.
12:21:16 <Cale> However, that's kind of a bad way to go about things unless you're using a VT or something.
12:21:34 <Cale> If you're in a graphical environment, it's much better to have your editor open in another window
12:21:58 <Cale> (perhaps even if not, you could work something out with screen :)
12:22:02 <bernalex> Cale: ya typically you'd just do that. with a tiling manager you'd have 5 source files and then an interpreter.
12:22:04 <mangaba_leitosa> darthdeus: I get 'Not an editor command: HPaste'. Probably something is not setup properly
12:22:21 <darthdeus> mangaba_leitosa: that's weird https://github.com/dag/vim2hs#hpaste
12:22:23 <bernalex> :HPaste is from ghc-mod, right?
12:22:26 <ocharles> Argh, why is there no stripPrefix view for bytestrings :(
12:22:39 <darthdeus> bernalex: nope from vim2hs
12:22:42 <bernalex> oh, no, I have it from haskellmode.
12:22:45 <bernalex> darthdeus: yeh.
12:23:08 <bernalex> mangaba_leitosa: what does :h haskellmode do?
12:23:11 <mangaba_leitosa> darthdeus: yes, I can see HPaste mentioned in $HOME/.vim/bundle/vim2hs/README.md as well
12:24:01 <mangaba_leitosa> bernalex: 'no help for haskellmode'. I don't really now what haskelmode is. I only use vim2hs for syntax hightlighting and didn't learn other features
12:24:08 <narxus> I need help again. Why does ghci say that baby.hs does not exist?
12:24:17 <bernalex> narxus: because it does not exist.
12:25:11 <darthdeus> uhm why do i see so many of these errors when doing cabla install? http://i.imgur.com/zLxyxhr.png it seems like it's not properly detecing '
12:25:43 <narxus> bernalex: It does
12:26:10 <bernalex> narxus: I'm inclined to believe you are wrong and ghci is right. you'll have to provide more info.
12:26:18 <narxus> I am
12:26:19 <narxus> Wait
12:26:57 <geekosaur> darthdeus, see the end of the /topic
12:26:57 <mangaba_leitosa> darthdeus: I think donri (present on the channel) is the author of vim2hs. He helped me set up vim2hs
12:27:26 <narxus> First. I typed setCurrentDirectory: "D:\LYAH\"
12:27:38 <darthdeus> geekosaur: not sure what you mean :o
12:27:43 <narxus> then, I typed getCurrentDirectory
12:27:45 <bernalex> what is there to do with vim2hs besides git clone?
12:27:49 <mangaba_leitosa> darthdeus: but I only needed syntax highlighting so far and didn't try advanced feaures
12:27:56 <narxus> "D:\\LYAH"
12:28:09 <darthdeus> mangaba_leitosa: i don't really use lpaste, i was kinda in exploration mode, trying to see what's there :)
12:28:16 <narxus> then I typed doesFileExist "baby.hs". It resulted to true.
12:28:24 <geekosaur> darthdeus, that is haskell code using cpp, on a machine whose cpp comes from clang instead of gcc (which means a Mac with Xcode 5)
12:28:38 <geekosaur> the channel /topic (you do know about IRC channel /topics?)
12:28:44 <geekosaur> has a link to a workaround
12:29:12 <darthdeus> geekosaur: i saw the link, i just wasn't sure what was the problem :) thanks
12:30:04 <geekosaur> the problem is that gcc's cpp can be run in degenerate mode which is almost usable with non-C code. clang's cpp obeys the ANSI standard and only works on C/C++ code as a result (without some tweaking)
12:30:36 <geekosaur> the correct fix is that we should not be using a C preprocessor on Haskell code, but that turns out to not be a practical fix :(
12:31:17 <mangaba_leitosa> bernalex: I had 'pathogen' setup, so I only needed git clone to .vim/bundle/vim2hs/ (read by pathogen on vim startup)
12:31:34 <bernalex> mangaba_leitosa: that sounds correct. that's what I did as well.
12:31:41 <darthdeus> geekosaur: so basically the problem is that haskell is depending on gcc features which aren't in the standard?
12:31:48 <kqr> narxus, try :cd D:\LYAH\
12:31:51 <darthdeus> to put it in a pesimistic way
12:31:53 <kqr> narxus, instead of setCurrentDirectory
12:31:58 <kqr> narxus, i'm not sure if it matters but it might
12:32:17 <geekosaur> darthdeus, more or less
12:32:26 <mangaba_leitosa> bernalex: I also had to do 'let g:haskell_conceal = 0' and 'let g:jmacro_conceal = 0' for a non-UTF8 terminal
12:32:27 * hackagebot haskoin-wallet 0.0.1 - Implementation of a Bitcoin hierarchical deterministric wallet (BIP32).  http://hackage.haskell.org/package/haskoin-wallet-0.0.1 (PhilippeLaprade)
12:32:35 <trolling> is a better fix not to write a CPP for haskell in haskell?
12:32:44 <mangaba_leitosa> bernalex: for UTF-8 terminals, no other actions are needed
12:32:45 <bernalex> mangaba_leitosa: I haven't seen those in a while :-P
12:32:58 <geekosaur> gcc has a -traditional mode which behaves like the old pcc (AT&T Portable C Compiler, pre-ANSI C) cpp which didn't check for C syntax and could be used as a general preprocessor
12:33:14 <narxus> Omg... I typed Double Me instead of DoubleMe as my function...
12:33:39 <mangaba_leitosa> bernalex: and finally 'set foldlevelstart=200' to prevent functions from being folded by default
12:33:44 <geekosaur> ANSI compatible preprocessors must actually lex, if not parse, C code. gcc's cpp (except in -traditional mode) and clang's cpp both do this
12:34:01 <narxus> But your method works, kqr
12:34:31 <bernalex> mangaba_leitosa: I love folds. :-)
12:35:03 <binroot> @pl \x->(head x, length x)
12:35:04 <lambdabot> liftM2 (,) head length
12:35:12 <bernalex> I wish there was a way vim could tell that if there are comments several lines in a row (not multi-line comments like {- -}, but just several lines of -- comments) and fold them.
12:35:17 <darthdeus> hmm
12:35:23 <bernalex> I mean, there probably is, but I never got around to learning vimscript.
12:35:27 <darthdeus> every time i ask a question here i feel stupider :D
12:35:35 <joelteon> what logging framework should I use?
12:35:45 <binroot> \y -> map (\x->(head x, length x)) . group . sort $ y
12:35:52 <binroot> @pl \y -> map (\x->(head x, length x)) . group . sort $ y
12:35:52 <lambdabot> map (liftM2 (,) head length) . group . sort
12:35:58 <bernalex> darthdeus: why not smarter? now you've learned something new. :-)
12:36:19 <darthdeus> bernalex: i've learned that i need to learn way more than i thought before :P
12:36:26 <kqr> bernalex, the more you know the more you realise you don't know
12:36:48 <bernalex> kqr: exactly that's called intelligence. :-)
12:36:49 <geekosaur> darthdeus, the specific problem is that in ANSI C a ' always introduces a character constant, which should be exactly one (char) (although for backward compatibility reasons it may be up to 4). but in Haskell, it can also appear in the middle of an identifier, or a '' may indicate a Template Haskell splice
12:37:01 <implementation> @pl \(a,b,c) -> (a,c)
12:37:01 <lambdabot> (line 1, column 7):
12:37:01 <lambdabot> unexpected "c"
12:37:01 <lambdabot> ambiguous use of a non associative operator
12:37:02 <geekosaur> both of which will cause an ANSI compliant C preprocessor to raise a parse error
12:37:10 <kqr> bernalex, but it makes you *feel* stupid!
12:37:11 <geekosaur> (well, lexical error)
12:37:18 <bernalex> kqr: not me. :-)
12:37:19 <darthdeus> geekosaur: hmm, i understand that part
12:37:20 <geekosaur> which is exactly what you got
12:37:32 <darthdeus> i donrt understand why haskell is using a C preprocessor?
12:37:36 <mangaba_leitosa> bernalex: btw, I'm on utf-8 xterm now and tried enabling 'conceal' chars again... it seems to slow: when I enable it, opening a 400-line file takes about 3 seconds on my box
12:37:52 <geekosaur> because sometimes you need to conditionalize code based on the version of some other library
12:37:58 <bernalex> mangaba_leitosa: I only use urxvt and am not planning on changing. but duly noted FFR, at least.
12:39:12 <geekosaur> and Haskell itself does not have a good way to do this, so we use an extension that sends Haskell source through cpp, and the Cabal library arranges for version information from libraries to be made available to cpp
12:39:25 <mangaba_leitosa> bernalex: it seems that when 'conceal' is on (default), vim2hs parses the entire file to replace \ with λ and it takes some time
12:39:28 <geekosaur> (as preprocessor #define-s)
12:39:34 <darthdeus> geekosaur: now it all makes sense :)
12:39:55 <bernalex> mangaba_leitosa: it also changes . to something like · (can't be bothered looking up the correct char)
12:40:01 <mangaba_leitosa> bernalex: right
12:40:03 <benmachine> it's pretty crappy that we use CPP to be honest
12:40:09 <benmachine> but, well, everyone already had it installed
12:40:13 <DanielOertwig> Hi, I'm still relative new to haskell. I'm doing a robot (arm) controller simulation, and am unsure whether I should pack values for distance / angle / time in datatypes or if I should just use Doubles?
12:40:16 <darthdeus> but why isn't there a preprocessor written just for haskell?
12:40:26 <geekosaur> there is. sadly it has license issues
12:40:30 <bernalex> benmachine: except os x and windows and others
12:40:31 <benmachine> darthdeus: well volunteered :D
12:40:32 <startling> there's TH.
12:40:38 <geekosaur> (cpphs)
12:40:39 <startling> geekosaur, what is it?
12:40:40 <benmachine> TH isn't the right thing
12:40:41 <startling> oh
12:40:48 <c_wraith> TH has some baffling limitations.  Like, it can't generate imports.
12:40:52 <benmachine> right
12:40:59 <benmachine> that's not so baffling, because you can import TH code
12:41:00 <startling> c_wraith: weird.
12:41:02 <c_wraith> (not really baffling, if you tried to work through the semantics)
12:41:08 <ReinH> DanielOertwig: you could use type synonyms: type Angle = Double and so on
12:41:11 <c_wraith> (There's no sane way it could work)
12:41:34 <benmachine> c_wraith: arguably TH isn't sane anyway :P
12:41:36 <c_wraith> But changing imports is one major reason CPP is used.
12:42:13 <startling> yeah.
12:42:16 <DanielOertwig> ReinH: Will that lead to static compile time type checking? (Ie I cannot pass an Angle to a function expecting a Time?)
12:43:30 <Philonous> DanielOertwig, No
12:43:41 <Philonous> DanielOertwig, For that you need newtypes
12:46:08 <DanielOertwig> Philonous: Like in: newtype Angle = Double ?
12:46:21 <jle`> newType Angle = Angle Double
12:46:22 <Philonous> DanielOertwig, newtype Angle = Angle Double
12:46:31 <benmachine> newtype Angle = MkAngle Double
12:46:41 * benmachine disapproves of types and values sharing names
12:46:45 <Philonous> DanielOertwig, Or (more convenient) newtaype Angle = Angle {fromAngle :: Double}
12:46:57 <jle`> it works like a data constructor but with only one constructor and one field
12:47:23 <jle`> so after it's compiled it behaves almost exactly like a Double, but it'll be able to play in typechecking games
12:47:37 <jle`> like all of the other reindeer
12:47:43 <DanielOertwig> Ok, but I need to pattern match on it to properly use the value, right?
12:47:54 <Philonous> DanielOertwig, That's the downside
12:48:03 <jle`> you can also use fromAngle
12:48:21 <jle`> (or whatever your record is named)
12:49:02 <DanielOertwig> Ok, thank you all :)
12:49:27 <jle`> there is a nice dimensional analysis library i think
12:49:27 <Philonous> DanielOertwig, But you're not paying any performance cost. Wrapping/unwrapping newtypes is free.
12:49:39 <jle`> that can typecheck the dimensions of your quantities
12:49:43 <Philonous> DanielOertwig, That's why you would use it rather than a data declaration
12:49:44 <jle`> it would surely catch something like this
12:49:48 <jle`> might be overkill though
12:50:51 <implementation> jle`: do you remember the name?
12:51:07 <bennofs> Does anyone here know if it is possible to load a CoreModule to the GHCi with the GHC API?
12:51:07 <jle`> hm. no, i found it one late night googling.
12:51:27 <jle`> i was thinking about building my own and wanted to check if someone else already had
12:51:30 <DanielOertwig> Yes, a complete dimensional analysis looks like overkill for me, at least in my (small) scenario.
12:51:30 <jle`> alas.
12:51:32 <jle`> it's on hackage though
12:52:28 <implementation> was it this one? http://hackage.haskell.org/package/units-1.0.0
12:53:08 <jle`> yes i believe that was the one i saw
12:53:14 <jle`> 1.1 is out now though i believe
12:53:24 <jle`> just uploaded yesterday
12:57:24 <kakos> With guards, am I guaranteed that the previous conditions are not true?
12:58:21 <shachaf> Please rephrase or give an example.
12:59:38 <f-a> SDL bindings related question. How do I get the height/width of a surface? I 'followed' the type but it ends in http://hackage.haskell.org/package/SDL-0.6.5/docs/Graphics-UI-SDL-Types.html#t:Surface
12:59:46 <kakos> foo x y z | x < y = "Foo"
12:59:46 <kakos>   | y < z = "Bar"
12:59:47 <kakos>   | otherwise = "Baz"
12:59:47 <kakos> If I get "Bar", am I guaranteed that x >= y?
12:59:53 <c_wraith> kakos: guards are tried in the order they're written
13:00:04 <c_wraith> kakos: as are pattern matches
13:00:10 <benmachine> kakos: as long as the Ord instance is well-behaved, yes
13:00:19 <kakos> c_wraith: I knew about pattern matches, just wasn't positive about guards. THanks. :)
13:00:20 <c_wraith> kakos: top-to-bottom, left-to-right within a line
13:00:25 <kinslayer> so if (<-) only for IO Action not other Monadic actions ?
13:00:28 <benmachine> kakos: with NaN you might find that both are false
13:00:31 <kinslayer> so is*
13:01:22 <benmachine> kinslayer: IO is not syntactically special
13:01:35 <benmachine> you can use do-notation (with <-) for any monad
13:01:38 <kakos> kinslayer: <- is for all Monads. It essentially the equivalent of the 'bind' operation inside of a do block
13:01:55 <kinslayer> Okay I was just wondering...
13:02:10 <kinslayer> Always good to get the correct info down :D
13:02:26 <jle`> remember there is nothing special about IO, syntax-wise
13:03:14 <c_wraith> kakos: the fact that pattern matches are tried left-to-right within a line is actually kind of important.  It's what makes zip xs (tail xs) not crash. :)
13:03:40 <kinslayer> jle`: Well I got that :D so <- is kind of like "store the result of this action" ?
13:03:43 <c_wraith> > let xs = [2,5] in zip xs (tails xs)
13:03:45 <lambdabot>  [(2,[2,5]),(5,[5])]
13:03:55 <c_wraith> err, whoops.  hah
13:03:58 <kakos> c_wraith: Are pattern guards well-behaved with regards to that?
13:03:58 <c_wraith> > let xs = [2,5] in zip xs (tail xs)
13:03:59 <lambdabot>  [(2,5)]
13:04:10 <benmachine> kinslayer: hmmmm not so much "store"
13:04:11 <c_wraith> kakos: They should be.  I haven't tested them
13:04:18 <benmachine> also "result" and "action" are not always appropriate either :P
13:04:41 <kinslayer> benmachine: well in a variable ? (>>=) sends the result to a lambda or something right ?
13:04:45 <jle`> kinslayer: 'x <- ...' is 'let x represent the result of this action', for IO.  different monads interpret bind differently though
13:05:06 <jle`> for example in Maybe, 'x <- Just 5' says 'let x represent the number inside the Just'
13:05:08 <kinslayer> jle`: no reason to make  stuff simple :D
13:05:10 <benmachine> in lists, x <- ... is "let x be each element of this list in turn"
13:05:37 <kakos> I've always found it best to view Monads as boxes and the bind operation just let's you take a look inside the box
13:05:45 <darthdeus> i'm trying to understand forall ... does it mean that i can have different types in a list as long as they have the same typeclass?
13:05:56 <kinslayer> benmachine: so it is interpreting it in diff... ways to make only a single value comes out ?
13:06:02 <jle`> kakos: box analogy kinda becomes weird in a lot of contexts
13:06:09 <shachaf> kakos: That isn't a very good analogy at all and I recommend that you stop if you can.
13:06:21 <shachaf> @quote kmc container
13:06:21 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
13:06:31 <kakos> jle`: What contexts?
13:07:07 <benmachine> kinslayer: it's interpreting it according to the type class instance for Monad
13:07:14 <kinslayer> so right a box is like a monad as long as the box behaves as a monad ?:D
13:07:31 <jle`> kinslayer: I like to think of it as 'x <- list' represents **one** item in that list
13:07:46 <jle`> and at the "end" of the do block, it returns the result of all possible choices you could have made
13:07:51 <darthdeus> shouldn't this work then? foo :: forall a. Eq a => [a]
13:08:35 <kinslayer> I was looking at the TagSoup today and was wondering about StringLike until I realized it was a datatype :D
13:08:45 <kinslayer> err.. Typeclass
13:08:50 <benmachine> darthdeus: that is exactly the same as foo :: Eq a => [a]
13:09:20 <benmachine> darthdeus: you're thinking of [forall a. Eq a => a], but that's an impredicative type so quite scary
13:09:37 <benmachine> darthdeus: it's more usual to use existential types for that
13:09:44 <shachaf> forall a. Eq a => [a] and [forall a. Eq a => a] have the same inhabitants.
13:09:49 <shachaf> (Namely, [] and nothing else.)
13:09:50 <benmachine> darthdeus: except actually it's more usual to not do that at all because usually you don't want to
13:09:51 <jle`> kakos: well, IO, Parsers, State, Reader, etc.?  Technically you can think of it as the value "inside", but that really isn't what it is and it holds you back from actaully understanding what is happening
13:10:01 <darthdeus> benmachine: so theoretically this should work? foo :: [forall a. Eq a => a]; foo = [1, "foo"]
13:10:03 <benmachine> shachaf: oh, fair point
13:10:10 <jle`> by technically i mean "you might be able to get away with for a short while"
13:10:10 <darthdeus> not that i want to do this, i'm just trying to understand
13:10:24 <benmachine> darthdeus: actually as shachaf points out, I was wrong
13:10:37 <darthdeus> yeah it doesn't compile :(
13:10:48 <darthdeus> ah it's not ExistentialQuantification
13:10:53 <benmachine> darthdeus: [forall a. Eq a => a] is a list of things that can be any Eq type
13:11:21 <shachaf> I understood forall (and exists) properly when I started thinking about it as a dependent function (and a dependent tuple).
13:11:22 <mornfall> shachaf: bottom!
13:11:41 <benmachine> shachaf: yes, that's the best way
13:11:49 <darthdeus> shachaf: that doesn't make sense to me
13:11:55 <johannesbodannes> ARGH! I'm having massive trouble getting the Haskell curl library to work. Probably due to some weird interaction between 32 and 64 bit architectures. Are there alternatives to the curl-based libraries for fetching HTTP responses?
13:12:06 <shachaf> darthdeus: Right, because I didn't explain it, I just said it. :-)
13:12:50 <darthdeus> what i understand now is that it somehow allows me to constrain lists by a typeclass and not by a type, is that correct?
13:12:51 <kqr> johannesbodannes, network.http? i haven't done it myself but it's the first hit on google
13:12:53 <mornfall> darthdeus: you don't have any actual values that live in 'a'
13:12:56 <johannesbodannes> if i could avoid having to use curl at all i'd be thrilled
13:12:56 <johannesbodannes> libcurl rather
13:13:02 <shachaf> I think additional good intuition is thinking of things as a two-player game. You're trying to write your function and your opponent is trying to make your life hard.
13:13:05 <shachaf> (Or vice versa.)
13:13:07 <johannesbodannes> i'll have a look, thanks kqr
13:13:17 <kinslayer> johannesbodannes: http-conduit ?
13:13:26 <shachaf> You and your opponent correspond to covariant and contravariant position.
13:14:41 <johannesbodannes> kinslayer: oh even better, thanks!
13:14:46 <johannesbodannes> this looks easy
13:14:58 <darthdeus> okaaaaay .... still not making sense :X
13:15:04 <kinslayer> johannesbodannes: That is what I am using :D
13:15:25 <darthdeus> how can i have covariance/contravariance when there's no subtyping?
13:15:31 <darthdeus> (sorry for being dumb)
13:15:45 <fruitFly> hi, anyone here interested in free markets?
13:15:47 <shachaf> The meaning in Haskell is different but related from the meaning with subtyping.
13:15:59 <simpson> fruitFly: Free markets!? I'll take one!
13:16:14 <kqr> flea markets!
13:16:16 <fruitFly> simpson: can I pm you?
13:16:32 <benmachine> free markets suck
13:16:40 <benmachine> just saying.
13:16:52 <simpson> fruitFly: Just deliver it to my capital city. It should provide +2 coin, +33% coin. "Markets greatly increase the amount of gold produced by a city," right?
13:16:56 <darthdeus> shachaf: kinda like Maybe Float is convertible to Maybe Int but not the other way around?
13:17:03 <Cale> Are we talking about positive and negative positions in types?
13:17:06 <mornfall> fruitFly: are you a bot?
13:17:29 <shachaf> darthdeus: No, a different deal.
13:17:30 * hackagebot happstack-server-tls 7.1.0 - extend happstack-server with https:// support (TLS/SSL)  http://hackage.haskell.org/package/happstack-server-tls-7.1.0 (JeremyShaw)
13:17:31 <shachaf> Cale: Yes, that.
13:17:32 * hackagebot clckwrks 0.20.2 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.20.2 (JeremyShaw)
13:17:45 <fruitFly> mornfall: no
13:17:49 <shachaf> benmachine: If you agree on the function intuition for forall, do you happen to know any link to something that explains it that way?
13:18:23 <benmachine> shachaf: ...Agda? :P
13:18:28 <benmachine> (no)
13:18:40 <benmachine> write a haskellwiki page, and then link to it
13:19:05 <fruitFly> simpson: i'm trying to deliver you a free market, can I pm you?
13:19:46 <shachaf> fruitFly: This is off-topic. Please stop.
13:19:52 <mornfall> simpson: tell us what it was about afterwards, will you? :-)
13:19:56 <simpson> fruitFly: Sure.
13:19:59 <simpson> mornfall: Sure. :3
13:20:07 <Cale> Okay, so in a -> b, the a is in negative position and the b is in positive position. This terminology comes from classical logic, where we would think of this as "a implies b", and that would be equivalent to "b or not a" -- the negation on a is what we're talking about when we're saying that it's in negative position.
13:20:19 <ij> fruitFly, What do you mean by free market? What are you takling about?
13:21:05 <Cale> When we start nesting things, negative and positive get inverted inside a negative context, and stay the same in a positive context
13:21:13 <mangaba_leitosa> If I would like to look at either idris or agda, which one should I pick? :-)
13:21:26 <startling> fruitFly has done this here before.
13:21:28 <shergill> Cale: that makes it so much clearer. i'd always been somewhat mystified by it. thanks
13:21:33 <darthdeus> hmm that makes sense
13:22:13 <Cale> So in (a -> b) -> (c -> d), the a and d are positive, and the b and c are negative.
13:22:56 <Cale> If we're writing a function of this type, b and c are things that will be given to us from outside, and a and d are the obligations we're going to have to provide.
13:23:37 <Cale> (we only have to provide a if we want to get the b of course)
13:23:52 <Cale> Does that make sense?
13:24:39 <shachaf> I like to think of "the outside" as our opponent. They'll give us the worst possible choices of values/types/etc. that they can.
13:24:41 <Cale> If we're using a function of this type, the roles are reversed. We need to provide b (if given an a), and c, and the function will provide us with the a and d.
13:25:44 <Cale> Note that this way of thinking is the idea behind continuation passing style: instead of using positive things of type a, we instead use "doubly negated" things of type (a -> r) -> r
13:26:19 <shachaf> You've probably heard this before in contexts like "I give you an epsilon, which can be as small as I'd like, and you have to give me back a delta such that ...".
13:26:30 <shachaf> This is the same deal.
13:29:26 <Cale> (That double negation transformation turns out to make the world more classical, and that's why we get something analogous to ((a -> b) -> a) -> a, which is untrue in intuitionist logic, but *is* true in classical logic, and that's our callCC
13:29:29 <Cale> :t callCC
13:29:31 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
13:29:52 --- mode: ChanServ set +o shachaf
13:31:22 --- mode: shachaf set +b *!*richard@*.dyn.embarqhsd.net
13:31:22 --- kick: fruitFly was kicked by shachaf (repeated infractions)
13:31:26 --- mode: shachaf set -o shachaf
13:37:52 <simpson> mornfall: Uninteresting rambling. Log available on request.
13:42:01 <mornfall> simpson: The Raving lunatic drools on you.
13:42:12 <raphie> so, question about how lists are stored. if a function returns a list with a value prepended, it doesn't copy the list -- it just adds another node to the beginning and references the original
13:42:42 <raphie> but say I returned a new list with only one item, the nth, modified. does that mean the function returns n "new" elements and then a reference to the old list at the point of modification?
13:42:50 <mornfall> simpson: (a reference to angband in case you never played it...)
13:43:09 <simpson> Let's just drop it.
13:44:05 <Flonk> Has anyone experimented with compiling haskell to js?
13:44:25 <mornfall> Flonk: I vaguely recall something. Google should turn it up.
13:44:28 <bearclaw_> I tried haste once on a simple hello world
13:45:09 <nisstyre> @src foldr
13:45:09 <lambdabot> foldr f z []     = z
13:45:09 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:45:16 <Flonk> bearclaw_: haste, huh? I'll check that out, thanks!
13:46:14 <mgsloan> I'd say the most well known ones are fay, ghcjs, haste, and uhc
13:46:59 <mgsloan> At FP Complete we're using fay for most of our javascript, it's working quite nicely.  In particular, it has a very convenient FFI and the generated code is pretty much a direct translation
13:47:14 <bearclaw_> Kind of fun that there are not 1, but at least 4 attempts to bridge those two languages wich are at the opposite ends of the spectrum
13:47:35 <scriptor> let's just wait until someone does haskell -> php
13:47:41 <mgsloan> bearclaw_: Well, there are many -> javascript transpilers, as the web is an excellent platform
13:48:12 <mgsloan> bearclaw_: Check out the left column here http://langlangmatrix.com/
13:49:16 <mgsloan> The downside of fay is that it's a subset of haskell - no typeclasses :/
13:52:46 <ion> Do other JavaScript-out-of-Haskell things than ghcjs support FFI that transforms do { a <- foo 42; … } into foo(42, function (a) { … });?
13:53:16 <darthdeus> shachaf: Cale: is there a place i can read more about this? i feel like i'm lacking some basic knowledge
13:53:57 <ion> ghcjs has something like foreign import javascript safe "foo($1, $c)" foo :: Integer -> IO Bar where $c stands for the continuation.
13:55:10 <zomg> ion: there is a Cont sample for Fay at least, not sure if that's what you're looking for though
13:55:39 <mgsloan> Hmm, that's pretty neat! fay doesn't have that
13:56:06 <zomg> It took me a while to understand how the Fay Cont thing worked :p
13:56:27 <ion> zomg: Hmm, this isn’t quite as nice as the ghcjs solution. https://github.com/faylang/fay/blob/master/examples/Cont.hs
13:56:30 <ion> Thanks anyway.
13:56:41 <zomg> Yeah, I think it's just working within the limitations of Fay as it is now
13:57:04 <zomg> If you're building heavily async code I think it might be a reasonably good way to go about it vs. building the async in some other way
13:58:45 <mgsloan> We'd like to be using something like ghcjs or haste, but a year ago they weren't really very practical to use.  I'm not sure if that's changed since.  Maybe so!
13:59:04 <shachaf> ion: It seems like you could do something like that yourself, if not with that exact translation.
13:59:53 <shachaf> ion: E.g. like http://slbkbs.org/toys/callfront.txt
14:03:58 <binroot> @pl \x y -> abs (x-y)
14:03:58 <lambdabot> (abs .) . (-)
14:05:11 <kqr> raphie, possibly, yes
14:05:24 <kqr> raphie, thats the obvious solution, anyway
14:05:38 <raphie> kqr: are there any cool optimizations that could fix it?
14:05:58 <kqr> i have no idea
14:11:19 <pranz1> raphie: clarification: if a function returns a list with a value prepended, it returns a reference to the new node, which in turn references the original
14:11:24 <pranz1> and not the other way around
14:11:45 <raphie> yeah, that's what I meant, heh
14:14:11 <f-a> I have an Int and an Integer. I want to multiply them, with the result being an Int. What to do? I tried (fromIntegral a) * b but it seems the result is an Integer?
14:14:38 <kqr> f-a, is there any particular reason you want the result to be an Int?
14:14:49 <shachaf> What is a?
14:15:04 <shachaf> (*)'s type is either Int -> Int -> Int or Integer -> Integer -> Integer
14:15:19 <f-a> kqr: the function I am feeding to the number takes an int
14:15:37 <f-a> a is the integer , shachaf
14:15:41 <startling> :t fromIntegral
14:15:43 <lambdabot> (Integral a, Num b) => a -> b
14:15:56 <startling> :t fromInteger
14:15:57 <lambdabot> Num a => Integer -> a
14:16:00 <shachaf> f-a: Then double-check everything you said.
14:16:02 <startling> f-a, I suspect you're wrong.
14:16:12 <f-a> xD
14:16:14 <f-a> I suspect that too
14:16:22 <startling> using fromInteger might give a better error.
14:16:31 <f-a> (sorry, without ghci some silly errors are unavoidably)
14:16:36 <f-a> *unavoidable
14:17:04 <shachaf> You should ask your question in a way that (a) lets people reproduce your problem and (b) doesn't force them to.
14:17:34 <f-a> aaand of course they are both Integer and I should have used fromIntegral $
14:17:35 * hackagebot tasty 0.6 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.6 (RomanCheplyaka)
14:17:37 * hackagebot HSlippyMap 0.1.0.0 - OpenStreetMap Slippy Map  http://hackage.haskell.org/package/HSlippyMap-0.1.0.0 (j4pe)
14:18:10 <shachaf> Or better yet, fromIntegral ( )
14:18:36 <f-a> shachaf: thanks for the tip. I usually use lpaste before even asking. This one seemed trivial enough (and I suppose it was).
14:19:04 <f-a> why parens?
14:19:25 <shachaf> Because I'm prejudiced. You can probably ignore that, I haven't seen your code.
14:19:44 <donri> darthdeus, mangaba_leitosa: :HPaste probably doesn't work anymore (because lpaste) but in any case it requires +python and isn't set up otherwise
14:21:23 <darthdeus> i have python but it doesn't work as you mentioned :X
14:21:32 <tawm> doge's gonna cream worldcoin this night, isn't it
14:21:58 <tawm> wait, wat
14:22:01 <tawm> wrong channel
14:22:53 <donri> darthdeus: it *might* simply be a matter of changing the host, feel free to try it and pullreq :) (maybe should rename the command etc to go with it though, but not critical)
14:24:14 <ij> If I write "type Discard a = Show b => a -> b -> (a, String)" is the "forall b." implied?
14:24:45 <shachaf> I think it is.
14:24:48 <shachaf> This may be a bug.
14:24:53 <shachaf> I recommend writing it.
14:25:16 <shachaf> @let type Foo = a -> a
14:25:17 <lambdabot>  .L.hs:160:12: Not in scope: type variable `a'
14:25:18 <lambdabot>  
14:25:18 <lambdabot>  .L.hs:160:17: Not in scope: type variable `a'
14:25:21 <shachaf> @let type Foo = Show a => a -> a
14:25:23 <lambdabot>  Defined.
14:25:29 <shachaf> disgusting :'(
14:26:42 <south> Hey everyone
14:27:07 <south> Has anyone here had issues getting Hakyll 4 and Pipes 4 installed together?
14:27:26 <south> There seems to be some dependency issues that cause them to not work together...
14:27:26 <Bor0> if lists are homogeneous, how are we allowed to combine [Left 3, Right "Test"] ? one is Either Int b, other is Either a [Char]
14:27:36 * hackagebot HSlippyMap 1.0 - OpenStreetMap Slippy Map  http://hackage.haskell.org/package/HSlippyMap-1.0 (j4pe)
14:28:06 <jle`> Bor0: they are both Either Int String's
14:28:20 <jle`> or well, they must be
14:28:28 <jle`> htat's how type inference works
14:28:28 <Bor0> oh, I see
14:28:39 <jle`> if you use them elsewhere as something other than an Either Int String, it won't typecheck
14:28:53 <Bor0> so in the list they get converted to Either Int [Char], but if I type check them manually they are not actually Either Int [Char]
14:29:13 <Bor0> s/manually/independant/
14:29:15 <jle`> if you type check them in a vacuum then haskell doesn't know for sure what they are
14:29:27 <jle`> so it will leave it as a type variable a
14:29:44 <shachaf> That depends on what you mean by "are"
14:29:56 <shachaf> I say that "Either Int b" is "Either Int [Char]"
14:30:14 <Bor0> okay
14:30:35 <shachaf> (When b is [Char], of course.)
14:30:51 <shachaf> Anyway the idea is that the types unify.
14:31:08 <Bor0> what does it mean for the types to unify?
14:31:33 <jle`> you find a b and an a such that the two types are equal
14:31:35 <hpc> Bor0: unification is a sort of "solving an equation in both directions"
14:31:54 <jle`> so if we know that Either Int b == Either a String
14:32:02 <jle`> then we see that if we set b = String and a = Int, they are unified
14:32:04 <Bor0> Either Int String is the unified version?
14:32:20 <Bor0> ok, so they kind of match what they need to match :)
14:32:22 <jle`> unification is the process of finding b's and a's that make the equation fit
14:32:28 <Bor0> got it
14:32:33 <hpc> Bor0: to convert jle`'s example to ghc's notation, Either Int b ~ Either a String
14:32:36 * hackagebot HSlippyMap 1.2 - OpenStreetMap Slippy Map  http://hackage.haskell.org/package/HSlippyMap-1.2 (j4pe)
14:32:54 <hpc> when unified, that constraint produces two more constraints b ~ String and a ~ Int
14:33:02 <shachaf> There is quite a lot written on unification.
14:33:12 <shachaf> I bet monochrom has written something on it.
14:33:22 <jle`> yes apparently it is a p.b.d.
14:33:27 <shachaf> http://www.vex.net/~trebla/haskell/prerequisite.xhtml
14:33:31 <Bor0> what does p.b.d. mean now? :D
14:33:39 <jle`> pretty big deal :P
14:34:00 <lightquake> which ghc version added -fdefer-type-errors?
14:34:55 <Feuerbach> 7.6, I think
14:35:30 <shachaf> What?
14:36:06 <Bor0> so, what if I want an Either with 3 different instances?
14:36:18 <lightquake> or maybe i should just run `ghc -fdefer-type-errors` and see if it gives me a 'no input files' error or 'unrecognized flags'
14:36:18 <Bor0> is there a good way to do this with n different instances?
14:36:53 <startling> Bor0: I don't think you mean "instances"
14:37:11 <Bor0> Either Int b is an instance of Either a b, no?
14:37:37 <startling> Either a b has more than three instances, according to that definition.
14:37:41 <lightquake> the word 'instance' is used for something else
14:37:49 <startling> but that's not how it's used in Haskell, no.
14:37:57 <startling> Bor0, do you maybe mean "type variables"?
14:37:59 <lightquake> I guess you could call it an instantiation?
14:38:07 <Bor0> type variables then yes :)
14:39:04 <startling> Bor0, you can write data Three a b c = One a | Two b | Three c
14:39:08 <donri> http://pragprog.com/magazines/2013-06/unification may also be worth a read
14:39:16 <startling> or you can use something weird like Either a (Either b c)
14:39:49 <startling> Bor0: or, if you don't need them to be type variables you can do data Bor0 = One Int | Two Char | Three String
14:41:50 <Bor0> okay, got it. thanks
14:44:16 <ocharles> yo mm_bureau, when does the bureau close today?
14:47:18 <lightquake> hdevtools gets kind of confused if you pass -fdefer-type-errors: it thinks that + in `2 + Bool` has type Bool -> Bool -> Bool
14:47:38 * hackagebot websockets-snap 0.8.2.1 - Snap integration for the websockets library  http://hackage.haskell.org/package/websockets-snap-0.8.2.1 (JasperVanDerJeugt)
14:48:16 <shachaf> 2 + Bool?
14:48:21 <shachaf> Does it even defer scope errors?
14:48:45 <lightquake> er, I meant 2 + True
14:49:01 <Bor0> is there a special reason that >>= and fmap have the same behaviour for Either?
14:49:23 <lightquake> Bor0: what do you mean?
14:49:29 <startling> Bor0, they don't have the same behavior.
14:49:37 <Bor0> hm, they don't?
14:49:41 <startling> :t (>>=)
14:49:43 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:49:45 <startling> :t fmap
14:49:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:49:54 <lightquake> > Right 2 >>= (\x -> Right 8)
14:49:55 <lambdabot>  Right 8
14:50:01 <lightquake> > fmap (\x -> Right 8) (Right 2)
14:50:02 <lambdabot>  Right (Right 8)
14:50:04 <startling> > fmap Left (Right 2)
14:50:05 <lambdabot>  Right (Left 2)
14:50:11 <startling> > Right 2 >>= Left
14:50:12 <lambdabot>  Left 2
14:50:46 <Bor0> oh, I see where my mistake was.
14:50:54 <Bor0> > fmap (\x -> Right 8) Right 2
14:50:55 <lambdabot>  Right 8
14:51:03 <Bor0> what does that evaluate to? :D
14:51:26 <startling> huh?
14:51:30 <lightquake> oh, that's using a different fmap instance
14:51:36 <startling> oh haha
14:51:38 <Bor0> ah, it is? but which one?
14:51:44 <shachaf> It evaluates to Right 8
14:51:46 <lightquake> that's getting parsed as (fmap (\x -> Right 8) Right) 2
14:51:54 <startling> > fmap (\x -> Right 8) (Right 2)
14:51:55 <lambdabot>  Right (Right 8)
14:52:07 <startling> :t fmap (\x -> Right 8) Right
14:52:08 <lightquake> and fmap on functions is function composition
14:52:08 <lambdabot> Num b => b1 -> Either a b
14:52:26 <lightquake> so it's just ((\x -> Right 8) . Right) 2, which is Right 8
14:52:35 <Bor0> :t fmap (\x -> Right 8) Right
14:52:35 <lambdabot> Num b => b1 -> Either a b
14:52:45 <Bor0> ah, I see. wow. it totally got me. thanks again!
14:56:14 <darthdeus> how come this is valid?    liftM or $ mapM (unpackEquals arg1 arg2)   ... shouldn't it be `or` ?
14:56:24 <darthdeus> oh never min, i misread it
14:56:30 <darthdeus> it's lifting the (or)
15:00:45 <Tehnix> has anyone had any luck with installing gtk on OS X 10.9 ?
15:01:36 <Tehnix> or, prolly more glib and cairo. Failing with `gtk2hsC2hs: Error in C header file.`
15:02:54 <cardi> testing
15:03:29 <bernalex> cardi: try #randomprobablyemptychannelfortestingthings
15:03:45 <cardi> lol
15:03:48 <Tehnix> i thought he was referring to me
15:03:51 <Tehnix> :3
15:04:14 <bernalex> oh lol
15:04:24 * bernalex quietly steps away
15:06:11 <Tehnix> mainly I'm trying to get Helm working on OS X 10.9, but, it fails at that particular step :/ haven't been able to find much on it
15:06:55 <geekosaur> have seen that mentioned before, likely gtk2hsC2hs will need some tweaking for 10.9 system include files / macros
15:07:50 <joelteon> Isn't there a library with a monad for user interaction on hackage somewhere?
15:07:53 <joelteon> I completely forgot what it's called
15:09:54 <Tehnix> If anyones interested in the error it gives, https://gist.github.com/Tehnix/8047691
15:10:11 <_justjust> joelteon: maybe haskeline?
15:10:32 <joelteon> it was haskeline
15:20:37 <pavonia> Tehnix: People ask about this quite often here lately and are pointed to the last link in the topic. I don't know about the details though
15:26:24 <Tehnix> pavonia: I already have the wrapper in place though
15:26:33 <cardi> hello guys, noob here. im making my first hobbyist website. ive finished the homepage using html and css in notepad. is there a guide that can help me onto the next stage? the main thing im worried about; if i have a bunch of pages and decide to change something, i will have to manually alter all the pages
15:27:04 <shachaf> cardi: Does this have to do with Haskell?
15:27:47 <pavonia> Tehnix: It could also be a gtk/cairo bug, maybe you want to ask on the gtk2hs mailing list
15:28:15 <Tehnix> pavonia: hmm, will look into that. Wanted to hear if anyone might have had a fix here first though
15:31:07 <frisbee> Hello all! Could somebody help me with such simple code http://lpaste.net/97234 ? If I'm getting rts error, what should I do if I want to print array, which I get from many IO calls (or sum of such array) ?
15:32:05 <RoryHughes> Who is this 'haskell'?
15:32:36 <sipa> RoryHughes: http://en.wikipedia.org/wiki/Haskell_Curry ?
15:32:48 <cardi> ah sorry, im offtopic
15:33:06 <RoryHughes> sipa: Is that actually where 'currying' came from?
15:33:18 <ij> RoryHughes, Yes.
15:33:28 <RoryHughes> ij: cool
15:33:40 <ij> I will double-check this fact, but I think I'm right.
15:33:48 <sipa> i wouldn't say it's where currying comes from, but i'm sure it's named after him
15:33:53 <ij> ^
15:35:04 <RoryHughes> Quote wikipedia "There are three programming languages named after him, Haskell, Brooks and Curry, as well as the concept of currying, a technique used for transforming functions in mathematics and computer science."
15:35:35 <Taneb> How awesome do you have to be to have not one, not two, but THREE programming languages names after you
15:36:28 <RoryHughes> Taneb: 1 Whole Awesome
15:37:12 <sipa> i'd say a bit more, like 3.14 awesome
15:37:27 <startling> cardi, this is usually why people use templates or a CMS or static site generator
15:37:50 <Taneb> At least fix (\r n -> if n == 0 then 1 else n * r (n - 1)) 10 awesome
15:39:00 <cardi> time to buy a new computer, install linux, and get snap framework! ha
15:42:05 <frisbee> Hello! I'm not totally new to Haskell, but currently I'm facing a problem I could not solve :( Would somebody help me with it? I posted the code and error here: http://lpaste.net/97234
15:43:33 <johnw> frisbee: why are you using a monad here?
15:44:00 <frisbee> johnw: It should be IO. I was just testing with (Monad m).
15:45:01 <johnw> you reduce memory use a bit using: a !x = return $! x + 1
15:45:08 <frisbee> johnw: I fixed the code (now it is IO). In real code - this Int is getting from "outer world" or this function has some other side effects
15:45:08 <johnw> and turning on BangPatterns
15:45:23 <johnw> and you can use mapM instead of sequence $ map
15:45:50 <frisbee> johnw: MapM does not help. Im wondering why equivalent pure code does not have such problems
15:46:01 <johnw> no, using mapM won't change antyhing
15:46:04 <johnw> how about my other suggestion?
15:46:19 <frisbee> johnw: I just tried BangPatterns - no change
15:46:27 <johnw> a !x = return $! x + 1?
15:46:38 <maxs__> frisbee: ghc --version ?
15:48:06 <frisbee> maxs__: 7.6.3
15:50:05 <frisbee> maxs__, johnw: I've created annotation, to show you the code with BangPatterns - still getting the same rsult: http://lpaste.net/97234
15:51:19 <danp_> could somebody please take a look at this http://lpaste.net/97236 ... why doesn't the prompt function catch the exception while the test function does ?
15:52:39 <shachaf> Because it throws no exception.
15:53:08 <johnw> frisbee: I will try it here
15:53:31 <danp_> read will call error if it can't parse the input
15:53:42 <frisbee> johnw: thank you! I'm waiting for any info :)
15:54:35 <shachaf> Yes, but the value is never actually evaluated.
15:55:01 <shachaf> What if you try readLn?
15:55:05 <shachaf> It exists for this reason.
15:55:18 <shachaf> (If it works, you should still figure out why the other one didn't work.)
15:56:10 <ij> What's the point of ListT?
15:56:59 <Taneb> ij, logict has the same purpose and both does it better and explains it better.
15:57:09 <Taneb> http://hackage.haskell.org/package/logict
15:57:27 <Taneb> Actually, logict may overcomplicate it
15:57:41 <Taneb> It's for returning multiple results
15:58:08 <ij> Hmm, I didn't know they had a relation, I am actually trying to get into logict for sudoku.
15:59:18 <haasn> ListT → pipes?
16:00:12 <johnw> frisbee: there must be a trick that I'm missing, but I need to increase stack size to 16m to get your program to run
16:00:19 <danp_> shachaf: oh my, i completely forgot about this function
16:00:39 <piezo> ListT Identity is like []'s Monad instance
16:02:02 <levi> One of its uses is modeling nondeterministic choice.
16:03:12 <frisbee> johnw: hmm, that is not a beautifull solution - I do not how much data I'll have - and I think there would be much more than in this example. Why pure code (see the second annotation here: http://lpaste.net/97234) works without errors for much bigger value?
16:03:38 <johnw> frisbee: how about using conduits to produce your list then, rather than having to accumulate the entire list strictly before returning it?
16:05:12 <johnw> frisbee: here's what I mean: https://gist.github.com/8048340
16:05:25 <johnw> that will accommodate an iternum of basically any size
16:06:19 <frisbee> johnw: I've never heard about them before. how I can sum this array?
16:06:56 <johnw> you'd use CL.fold
16:07:45 <johnw> $= CL.fold (+) 0 $$ CL.mapM_ print
16:08:27 <piezo> frisbee: is it mandatory to load all the data at once ?
16:08:47 <cardi> can anyone point me to a noob friendly web dev channel please?
16:08:48 <piezo> frisbee: this work for me : mapM (print <=< a . (iternum -)) [1..iternum]
16:10:02 <frisbee> piezo: I want simply to sum elements in this array. I know (<=<) is arrow, but I do not know them deep enough to know how to sum the elemends instead of print them in your example
16:10:20 <johnw> frisbee: you'd use foldM in that case
16:10:39 <shachaf> (<=<) doesn't have that much to do with Arrow.
16:10:50 <johnw> foldM (\acc x -> print x >> return (acc + x)) 0 [1..iternum]
16:10:55 <johnw> that will both print and sum
16:11:08 <johnw> anyway, without knowing more about the real problem, it's hard to provide an adequate solution
16:11:26 <johnw> likely you have more requirements than just the few that you've mentioned so far
16:12:48 <frisbee> johnw, piezo: Than you. I'll test it right now. Do you know, by the way, why such problems occure when using IO? GHC does not "see", that these functions simply "return" a value? Why it does not optimize it just like the pure code?
16:13:18 <piezo> frisbee: no arrows, my oneliner is equivalent to mapM (\i -> a (iternum - i) >>= print) [1..iternum]
16:13:38 <johnw> if all your function truly does is return, then it should be pure; if it doesn't just return, then it will have effects that can't be optimized away
16:13:42 <levi> GHC can't always optimize pure code, either.
16:14:10 <johnw> and by "should be pure", I mean that you should write it without using Monad
16:14:31 <ion> shachaf: Yeah, you can do “it” yourself, the Fay Cont example also does it themselves. What i wanted was is that thing conveniently built into the language like it is in ghcjs.
16:14:40 <jmcarthur> frisbee: i don't understand really what you are trying to do, to be honest
16:14:56 <frisbee> johnw, levi: But why GHC does not optimize functions with such signature like f :: (Monad m) -> Int -> m Int, and body: f = return 2 ?
16:15:02 <shachaf> ion: I think overly-magic FFI like that isn't very nice.
16:15:10 <jmcarthur> frisbee: you clearly don't *only* want to sum elements of a list, because if you did then you wouldn't be doing anything with monads
16:15:17 <shachaf> I'd be OK with foreign import ... :: ... that passes an extra argument
16:15:23 <johnw> frisbee: for one reason, such a function in reality would be so rare as to not exist
16:15:40 <johnw> people generally don't write functions in a monad which do nothing but return
16:15:41 <levi> frisbee: What optimization are you expecting it to do?
16:15:56 <frisbee> jmcarthur: This example is a very simplified version from a code, which reads ints from several locations in IO monad. Then I started to dig around to understand why everything is behaving so and now I'm asking out of courius - why GHC is not optimizing the code.
16:16:08 <jmcarthur> frisbee: the code you pasted?
16:16:41 <haasn> (<=<) is like (<<<) for WrappedMonad
16:16:50 <haasn> Or uh, Kleisli
16:16:52 <haasn> Not WrappedMonad
16:17:08 <jmcarthur> frisbee: it's not even a matter of optimization. your code overflows the stack for perfectly good reasons. sequence has to push every element on to the stack because it is not tail recursive (because for some monads that makes more sense, although for IO it doesn't work out so well)
16:17:21 <piezo> frisbee: to stream data from IO you could use conduits or pipes
16:17:23 <jmcarthur> @src sequence
16:17:23 <lambdabot> sequence []     = return []
16:17:23 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:17:23 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
16:17:42 <frisbee> jmcarthur: I've pasted a simplified version of a code. In the real code, there is no "return 2", but the number is read from a disk location. But I was just very suprised, when I've made such simple example (the pasted one) and its pure equivalent - and the "monadish" one was getting error during runtime
16:17:59 <jmcarthur> frisbee: oh, not the lpaste from earlier?
16:19:30 <johnw> frisbee: I'm not saying GHC _couldn't_ be taught to make such an optimization, but I don't think it would be worth the effort in the optimizer
16:19:48 <frisbee> jmcarthur: I didnt pasted "the real code". Only the simple example made for myself. (this was the original "simple example": http://lpaste.net/97239). I was just suprised it gets RTS error, because GHC perfectly sees whats happening there (if I'm not wrong)
16:20:10 <jmcarthur> frisbee: that is exactly the code i was just talking about
16:20:15 <jmcarthur> frisbee: this is not even an optimization problem
16:20:29 <frisbee> johnw, piezo: I'm thinking aobut the sequence - and about the "pushing every element on to the stack" - is there a way to have sequence without this behaviour?
16:21:22 <johnw> frisbee: sounds like a great exercise :)
16:21:40 <jmcarthur> frisbee: yes. i agree with johnw that it's a good exercise
16:22:19 <frisbee> johnw, jmcarthur: I was trying to replace foldr with foldl in the sources of sequence, but no luck so far :(
16:24:04 <johnw> i have a vague memory of this having been done here in the channel before
16:26:26 <johnw> yep
16:26:38 <johnw> i was able to write sequence' purely without much trouble
16:26:49 <johnw> frisbee: so I suggest even more strongly this as an exercise :)
16:27:55 <frisbee> johnw: would you be so nice and show your code, please? :)
16:27:59 <piezo> johnw: purely ? bind is needed somewhere ?
16:28:04 <jmcarthur> frisbee: as you can see, the main loop generated by ghc is about as good as one can reasonably expect.  http://lpaste.net/97239
16:28:16 <johnw> oh, I meant without using nasty tricks like IORef
16:28:26 <jmcarthur> frisbee: the bottom has a simplified version of the generated core
16:28:37 <johnw> frisbee: you sure you don't want to try to solve it yourself?  it would be very helpful toward mastering this subject
16:29:11 <shachaf> I recommend solving it yourself.
16:29:30 <dibblego> frisbee: https://github.com/NICTA/course/blob/master/src/Course/Applicative.hs#L84 this might help
16:30:09 <frisbee> johnw: I know and I see the purpose of this exercise. But I would love to simply see it this time, because right now I've got so many urgent tasks it would be impossible for me to think only about it and I'm afraid it would not be solved because of the lack of time. But I promise, the next time I'll do the exercise! :)
16:30:09 <jmcarthur> dibblego: given the goals, i think using Applicative might be counterproductive ;)
16:30:17 <johnw> frisbee: sequence' = go [] where go acc [] = return acc; go acc (x:xs) = x >>= \v -> go (v:acc) xs
16:30:28 <dibblego> jmcarthur: what is the goal? I thought it was just understanding sequence
16:30:37 <johnw> the trick is to use an accumulator in order to make sequence' tail-call optimized
16:30:40 <jmcarthur> dibblego: no, it's to write a tail recursive sequence
16:30:46 <dibblego> jmcarthur: ok
16:30:57 <frisbee> jmcarthur: this is very interesting! How can I get such output out of ghc ?
16:31:15 <dibblego> I assume the effects must also be run in the correct order
16:31:15 <jmcarthur> frisbee: i used ghc-core (it's on hackage), but you can also get it using -ddump-simpl
16:31:21 <jmcarthur> dibblego: correct
16:31:58 <frisbee> johnw: thank you!
16:32:30 <frisbee> jmcarthur: thank you for the example and informations. I think I'll play with ghc-core :)
16:33:23 <Eduard_Munteanu> Are there reasonable ways to have overlapping (overloaded?) field names for records? 'lens' deals with most of it, except for initialization. Is there some way to get designated typesafe record initializers?
16:33:32 <jmcarthur> dibblego: i was saddened the day i realized you can't write tail recursive functions like this with Applicative
16:33:43 <jmcarthur> although it makes sense
16:33:58 <dibblego> jmcarthur: you think other universes might have it better than us?
16:34:16 <jmcarthur> it's possible
16:34:26 <Eduard_Munteanu> By typesafe I mean ensuring all fields are initialized, while "designated" refers to being able to name fields when assigning stuff.
16:34:59 <cardi> if john carmack is thinking that haskell might be 'the best' programming language, am i wise to learn it even though its a very small niche language compared to java etc?
16:35:25 <dibblego> cardi: why does it matter that john carmack figured it out? Figure it out yourself
16:35:27 <shachaf> No. Learning Haskell because John Carmack said some things about it is not wise.
16:35:53 <shachaf> (Even though he said lots of reasonable things about it.)
16:36:10 <dibblego> (which is not a common thing for a beginner)
16:36:48 <johnw> cardi: learn Haskell because it is a joyful thing to do, and may well lead to productive results; you can learn Java anytime
16:36:52 <jmcarthur> cardi: Beware. If your question implies anything remotely illogical, the fallacy will become the focus of the channel, not the answer you were hoping for.
16:37:03 <mgsloan> Well, checking out haskell because John Carmack said some things about it is wise.  However, learning it should be because you see that it is awesome :)
16:37:08 <shachaf> But also learning Haskell because you can't find a web design channel isn't wise.
16:37:14 <shachaf> But there are many wise reasons to learn Haskell.
16:37:47 <blaenk> how does one rebuild the cabal index? I ran into an internal error and I saw on the relevant github issue that "rebuilding the index outside of any sandbox" fixed it, but I'm not sure how that's done
16:38:04 <johnw> blaenk: cabal update?
16:38:18 <jmcarthur> (Appeal to authority is not *always* a fallacy, by the way...)
16:38:22 <blaenk> yeah that was my first guess but it didn't have any effect :/
16:38:35 <johnw> blaenk: can you show us the error?
16:38:53 <blaenk> cabal: internal error when reading package index: could not read tar file
16:38:53 <blaenk> entryThe package index or index cache is probably corrupt. Running cabal
16:38:53 <blaenk> update might fix it.
16:39:06 <blaenk> is there a way to clear the index cache and index?
16:39:10 <blaenk> to have it start from scratch
16:39:21 <shachaf> No fallacies.
16:39:22 <zRecursive> `cabal update`
16:39:35 <blaenk> yeah if that's the command to do that, then I guess it's not helping me :(
16:40:09 <jmcarthur> cardi: I do think learning Haskell is wise, though. It will teach you many things and, hopefully, become your favorite language, and then you can forever be a part of our wonderful community of sarcastic pedants!
16:40:53 <shachaf> #haskell is not wonderful. It is full of h8rs like me.
16:41:16 <jmcarthur> what an exit...
16:41:32 <zRecursive> what is h8rs ?
16:41:39 <jmcarthur> censorship
16:41:52 <lingxiao> haters
16:41:55 <jmcarthur> heh, i just mean haters
16:41:57 <jmcarthur> yeah that
16:42:28 <cardi> My dream goal (unrealistic but aim high right!) is to make a computer game that runs in the browser. I am a bit of a perfectionist so i am researching different avenues atm and have been working my throught the learn haskell for great good guide. aha i am definately a sarcastic pedant too haha
16:42:49 <zRecursive> Anyway #haskell is a good place to learn FP and English for me :-)
16:43:18 <lingxiao> then monadReader and urbandictionary are must-have companions
16:43:30 <piezo> cardi: http://elm-lang.org/
16:44:08 <lingxiao> hey all, so I need some advice on what to learn next that'll take me to the next level in terms of understanding of Haskell the langauge, the type theory it's based on, and just writing beautiful programs in general
16:44:52 <zRecursive> In fact i only know one haskell app: xmonad
16:44:53 <lingxiao> I feel like I have a pretty good grasp of most of typeclasses in Typeclasspedia
16:45:17 <lingxiao> I went through all the lectures and homework in this course: http://www.seas.upenn.edu/~cis552/13fa/schedule.html
16:46:00 <lingxiao> and bult a coroutine library by reading many existing ones out there, and the apporpriate articles/reports around it.
16:46:35 <lingxiao> I'm currently going through TypingHaskellInHaskell, and and reading Mark Jones's thesis that it draws from
16:46:56 <johnw> lingxiao: how about writing a compiler for the typed lambda calculus?
16:47:09 <lingxiao> so what next? aside from do what interests me, which in the realm of this language is pretty broad..
16:47:29 <lingxiao> ahh so like replicate the Core basically?
16:47:55 <Eduard_Munteanu> lingxiao: no
16:48:09 <lingxiao> Eduard_Munteanu: oh how so?
16:49:37 <lingxiao> johnw: what, in your mind, is gained by writing a compiler for system F? Like as a serious open-minded question, not a sarcastic rhetorical question
16:49:56 <Eduard_Munteanu> lingxiao: Core and STLC are altogether different things, especially in this context
16:50:17 <cardi> piezo interesting link thanks. i see 'if then else' in there which surprises me. Is that strange or no? http://elm-lang.org/edit/examples/Intermediate/Walk.elm
16:50:55 <johnw> lingxiao: just becoming more familiar with type theory, compilers, different techniques for representing syntax trees, etc.
16:50:56 <Eduard_Munteanu> lingxiao: System F is quite a bit above STLC
16:51:16 <johnw> lingxiao: but my background is in compilers, so I'm biased in finding it an interesting thing to do next
16:52:00 <piezo> cardi: why could it be strange ?
16:52:21 <cardi> i thought functional language dont use if then else
16:52:43 * davidfetter_disq hoping for a pure dysfunctional language
16:52:43 <johnw> you can program without if-then-else, but it's a convenient way of writing case x of True -> ...; False -> ...
16:53:10 <johnw> davidfetter_disq: even better would be it's IRC channel
16:53:11 <piezo> cardi: in functional languages if act on values like "pred ? t : e" in C
16:53:39 <Eduard_Munteanu> cardi: if-then-else applies to plain expressions too, not just a bunch of actions.
16:54:18 <augur> i feel like the world would be a much better place with a handful of simple additions/changes to C
16:54:30 <augur> none of which would be anything but sugar
16:54:48 <augur> but which would add a lot of type safety
16:54:51 <merijn> augur: If you think C would be better with only a handful of changes, you don't know C well enough :)
16:54:53 <davidfetter_disq> they've tried that a few times. C++, Java, C#, ...
16:55:21 <augur> merijn: well, i mean, it wouldnt make it perfect, but
16:55:29 * davidfetter_disq wonders what the sanest version of a byte-oriented language like C would look like
16:55:39 <Eduard_Munteanu> augur: customers who bought that also bought: ATS
16:55:40 <merijn> augur: There's so many ridiculously subtle things in C that get in the way
16:55:45 <lingxiao> Eduard_Munteanu: ah thanks for pointing it out
16:56:01 <augur> davidfetter_disq: i just mean, add parametric polymorphism, add ast's. thats it.
16:56:04 <Eduard_Munteanu> @where nameless
16:56:04 <lambdabot> I know nothing about nameless.
16:56:08 <augur> merijn: probably
16:56:11 <merijn> augur: Like, void* can't contain function pointers, char's signedness is implementation defined, etc.
16:56:11 <lingxiao> johnw: ok those sound like good things to learn, I also don't have a comp-sci background, so I should prob learn those things anyways
16:56:13 <Eduard_Munteanu> @google nameless painless
16:56:14 <lambdabot> http://nicolaspouillard.fr/publis/nameless-painless.pdf
16:56:14 <lambdabot> Title: Nameless, Painless
16:56:28 <Eduard_Munteanu> lingxiao: ^ might be of interest to you, at least at some point
16:56:37 <augur> merijn: weirdness. are any of these essential/important to C?
16:56:51 <merijn> augur: If you hope to write portable/non-buggy code, yes
16:57:18 <johnw> lingxiao: oh indeed; my background is not comp sci either, and I find them fascinating.  Have you read Pierce's "Types and Programming Languages"?
16:57:19 <merijn> ADTs without sane behaviour for the basic types doesn't seem like it'd get you much
16:57:31 <Eduard_Munteanu> Well, it's rather Agda-oriented but with GADTs you can get some of that effect.
16:58:12 <lingxiao> Eduard_Munteanu: are you refering to nameless-painless? how come it will be of interest?
16:58:12 <Eduard_Munteanu> Anyway, even if it's of no direct use to you, it's still nice if you're looking for ideas of topics to research.
16:58:13 <merijn> But I should go sleep instead of debate C design :)
16:59:18 <Eduard_Munteanu> lingxiao: yes, if you're looking into implementing lambda calculi in something like Haskell, it might give you some ideas.
17:01:17 <lingxiao> johnw: wow very nice, good to know i'm not alone in this channel. I havn't gotten around to it yet. I have read a lot about simply and typed lambda calculi of differnt kinds, but this would put my knowlge on more solid grounding?
17:01:42 <lingxiao> because I feel like a "sophomore" in the sense that I know enough to write code, but still feel like a fraud haha
17:01:56 <johnw> lingxiao: yes, that book will definitely help
17:02:02 <johnw> and once you get past chapter 5, it becomes very engaging
17:02:10 <lingxiao> Eduard_Munteanu: ok thank you for pointing it out, I will give it a thorough read
17:02:12 <johnw> don't let the dryness of the first two chapters put you off
17:02:23 <johnw> gotta run, good luck lingxiao!
17:02:57 <Eduard_Munteanu> lingxiao: in that case I suggest you try using what you have so far... e.g. write Haskell code for some of your everyday stuff, perhaps to replace some of your scripts if any.
17:02:58 <lingxiao> johnw: thanks! have a good night!
17:03:35 <Eduard_Munteanu> lingxiao: nah, don't give it a thorough read, it was meant as a paper to gather ideas and things to study from.
17:03:53 <[swift]> is there a way i can share a right-hand side between different case branches? (sort of like fall-through in C)
17:03:57 <zRecursive> Haskell is not good at scripting though
17:04:06 <cardi> piezo and others, one last thing before i go sleep. is it possible to make something like this but using haskell rather than elm http://elm-lang.org/edit/examples/Intermediate/Walk.elm
17:04:11 <lingxiao> oh haha, i play fast a loose with the concept of thorough
17:04:50 <lingxiao> but when you say "in that case," are you refering to me being sophomoric? so you think I have more to gain by moving my current knowlege over a range of projects?
17:04:57 <Eduard_Munteanu> zRecursive: depends what you mean by scripting, how so?
17:04:58 <lingxiao> than go down some hole somwhere?
17:05:53 <lingxiao> btw as a general question, I noticed that a lot of papers I read comes from either MS Research, or Penn
17:06:01 <lingxiao> so is Penn like pretty big on language design?
17:06:47 <Cale> [swift]: Not quite. If there's only one like that, you can leave it to the end and match on _
17:07:04 <Eduard_Munteanu> lingxiao: well, yeah, writing useful code opens up interesting avenues and makes things more solid.
17:07:11 <Cale> Or of course, you can make a definition which captures what the cases have in common
17:07:21 <zRecursive> Eduard_Munteanu: it starts slowly
17:07:39 <Cale> But in general, two different patterns will end up binding a different set of variables, so it's not entirely trivial to let you unify them.
17:08:07 <Eduard_Munteanu> zRecursive: ah yes, I thought you were aiming for something else.
17:08:13 <[swift]> Cale: yeah, in general it's nontrivial. it'd be enum if it was supported for patterns that don't bind anything, though...
17:08:18 <augur> holy shit
17:08:23 <Cale> (though something like that could be checked -- it might be nice to have a way to do 'or'-patterns which would be required to bind the same variables in each branch)
17:08:24 <[swift]> sorry, *nice*. not enum, not sure where that came from
17:08:28 <augur> i found a really quick way to raise the temperature of my CPU by 40 degrees
17:08:35 <augur> mine dogecoins
17:08:37 <augur> 0_0
17:08:49 <[swift]> Cale: that'd be even better =)
17:08:52 <Eduard_Munteanu> zRecursive: it's more useful as the "top-level" part of your scripts, assuming you don't write all of it in Haskell.
17:09:15 <Cale> dogecoin wow such heat many computation so temperatures
17:09:19 <augur> :D
17:09:27 <Eduard_Munteanu> TBH, it's easier to just do the latter.
17:09:29 <zRecursive> Eduard_Munteanu: sure
17:09:57 <lingxiao> Eduard_Munteanu: ok cools thanks. With this language there's always a constant temptation to just never write code and read
17:10:29 <augur> Cale: 220ºF
17:10:37 <lingxiao> so on a scale of 1 - advanced, where would you think I am? (advanced = 10)
17:10:49 <Cale> 104 C is pretty insane
17:10:55 <lingxiao> If it's a sensible question based on what I said so far
17:11:04 <augur> Cale: i have a dodgy fan tho
17:11:10 <Cale> Probably should check that your fan and heatsink are clean, yeah
17:11:13 <augur> dodgy as in, doesnt work. so im down to one fan
17:11:29 <Eduard_Munteanu> lingxiao: that's hard to tell even with all the information, generally. :)
17:12:00 <Cale> I think my machine doesn't even start if the fan isn't operating correctly
17:12:12 <lingxiao> oh haha, yeah sighs
17:12:13 <Eduard_Munteanu> lingxiao: it depends on your purposes, sure, you can keep it all academic-y.
17:12:13 <Cale> (probably a safety feature)
17:12:27 <augur> copumpkin: so, computational interpretation of HoTT?
17:12:40 <augur>  /univalence
17:13:39 <Cale> augur: It seems reasonable that something involving contextual information about isomorphisms which is carried around should work
17:13:51 <augur> ?
17:14:17 <Cale> Well, univalence lets you turn isomorphisms of types into equalities, more or less.
17:14:21 <augur> yes
17:14:28 <lingxiao> augur: oohh have you read the HoTT book?
17:14:32 <augur> lingxiao: no
17:14:41 <Eduard_Munteanu> Is there a book?
17:14:43 <augur> yes
17:14:52 <Eduard_Munteanu> link link link link link
17:14:54 <Eduard_Munteanu> :)
17:15:04 <lingxiao> http://homotopytypetheory.org/book/
17:15:08 <Cale> So, when evaluating, you'd need to carry those isomorphisms through the computation and apply them when you reach a place where the types don't physically match up.
17:15:18 <Eduard_Munteanu> lingxiao: thanks
17:15:20 <augur> Cale: sure
17:15:24 <augur> maybe
17:15:35 <augur> i had a similar idea about extensionality a while back
17:15:43 <lingxiao> yup np :)
17:16:06 <Eduard_Munteanu> @where hott
17:16:06 <lambdabot> I know nothing about hott.
17:16:17 <Eduard_Munteanu> @where+ hott http://homotopytypetheory.org/book/
17:16:17 <lambdabot> Done.
17:16:40 <Eduard_Munteanu> @where HoTT
17:16:40 <lambdabot> http://homotopytypetheory.org/book/
17:16:41 <augur> i dont remember what the details were, but it was something about like..   you have a constructor   ext : (forall x. f x = g x) -> f = g
17:16:57 <augur> and there was some sort of computational principle that let you preserve canonical forms
17:17:29 <augur> man what was it
17:17:39 <Cale> Anyway, it seems perfectly reasonable that at least one computational interpretation should exist, but I think one of the issues is that it's sort of inherently ambiguous.
17:18:04 <Cale> You might end up with many potential isomorphisms from one type to another in context.
17:18:30 <Cale> and you need to be careful about which one you apply
17:19:25 <augur> it seems like you could do something with haskell type classes for this
17:19:49 <augur> avoid ambiguity by using newtypes to distinguish how we're viewing a type
17:19:58 <lingxiao> does anyone done type-level programming? like the kind found in "Type-Level Instant Insanity" in MonadReader-issue8?
17:20:09 <augur> and use silent coercions inserted by the type checker
17:20:43 <augur> lingxiao: i only do type-level programming in agda
17:20:49 <augur> i would never risk it in haskell :p
17:21:09 <lingxiao> right see that's my question, what are the cons for doing in Haskell?
17:21:10 <Eduard_Munteanu> lingxiao: with some of the recent-ish GHC extensions it's getting more and more palatable
17:21:20 <augur> lingxiao: that haskell sucks at it
17:21:23 <Cale> lingxiao: I don't think I've ever done anything quite that abusive myself, but I've read programs like that
17:21:24 <lingxiao> what made it unpalatable before?
17:21:26 <lingxiao> haha
17:22:00 <Cale> lingxiao: Well, first of all, the type level in Haskell has more or less been untyped
17:22:14 <lingxiao> yeah it seems really cool, and useful the in the use cases they give... but I really don't know about it enough so that's I'm asking, you guys seem to be against it
17:22:15 <augur> haskell does expose some interesting stuff tho
17:22:22 <Eduard_Munteanu> lingxiao: you should take a look at DataKinds and type-level literals.
17:22:32 <Cale> We had one basic kind * (where all the types with values would live), and then k1 -> k2 for any kinds k1 and k2
17:22:34 <Cale> and that's all
17:22:43 <haasn> this just in: “Haskell basically untyped”
17:23:07 <Cale> So writing programs at the type level was kind of like programming in an untyped language
17:23:12 <augur> hey cale, whats a good book to read for learning how to solve problems in FP?
17:23:12 <Eduard_Munteanu> "The unkind Haskell"
17:23:17 <augur> i dont mean how to program in FP
17:23:33 <lingxiao> Eduard_Munteanu : LOL dum-dum
17:23:36 <augur> but rather, how to really tackle a problem, how to picture, it, etc.
17:24:12 <Cale> lingxiao: Secondly, it wasn't really a functional language, but something more like Prolog, since you were largely using the type class resolution mechanism to do computation.
17:24:18 <lingxiao> Cale: ah so you're saying the kind system is not expressive enough... so briefly if you could, what's different in Agda that makes it palatable?
17:24:25 <Cale> and it's a constraint solver, rather than something more like a functional programming language
17:24:35 <lingxiao> Cale: oh sorry go on. .
17:24:41 <Cale> Agda unifies types and values
17:24:57 <Cale> They're the same thing :)
17:25:05 <augur> well
17:25:07 <augur> more accurately
17:25:13 <augur> Types \subset Values
17:25:21 <Eduard_Munteanu> It makes one want more of it... For instance, existential kinds and type functions would be nice in DataKinds.
17:25:30 <Cale> Well, okay
17:25:52 <lingxiao> Cale: woa, ok I guess I can read up on that, but very cool
17:25:57 <Cale> I suppose you don't have values whose type is 5 :)
17:26:09 <augur> Cale: i hear that a lot
17:26:13 <augur> and its true
17:26:18 <augur> but for a more fundamental reason
17:26:23 <Eduard_Munteanu> It's pretty easy to write length-indexed lists these days.
17:26:27 <augur> you dont have a value who's type is \bot either
17:26:44 <augur> Cale: the difference tho is that x : \bot is a perfectly good statement in agda
17:26:46 <Cale> sure, well, hopefully!
17:27:00 <augur> \x -> x : \bot -> \bot
17:27:13 <augur> but   \x -> x : 5 -> 5   is just ungrammatical
17:27:27 <Eduard_Munteanu> augur: mmm, that's just a binder to be fair
17:27:33 <Cale> Hm, is it?
17:27:37 <augur> yes
17:27:39 <Cale> Okay
17:27:51 <augur> its a parse error or something like that
17:27:53 <augur> i mean, even if it werent
17:28:01 <augur> in the type theory, it would be a judgment failure
17:28:03 <pyon> augur: So the judgement checking is embedded in the grammar? :-O
17:28:14 <Eduard_Munteanu> The ':' thing in values is a 'syntax'-defined thing.
17:28:15 <augur> because to prove 5 -> 5 : Set   you have to prove 5 : Set
17:28:17 <augur> which its not
17:28:21 <Cale> The simplest dependently typed systems have *no* real distinction between types and values
17:29:06 <Cale> well, yeah, 5 is not a Set l for any l
17:29:14 <augur> yes
17:29:19 <Eduard_Munteanu> Cale: it's pretty hard not to run into uninhabited vs inhabited types though
17:29:22 <augur> also you dont have to have a Set type
17:29:27 <augur> you could just have a type judgment
17:29:49 <augur> so instead of   G !- T : Set
17:29:53 <augur> you just have   G !- T type
17:30:15 <augur> which seems like its the same but it has huge consequences
17:30:26 <augur> impredicative system f relies on that, for instance.
17:31:13 <Eduard_Munteanu> I think the inhabited-ness is rather crucial to a type theory, if you go adhoc about it and let one define it in the language I suppose you end up with something like Metamath.
17:31:21 <augur> G ; D, a type !- T type   ===>   G ; D !- forall a. T type
17:31:22 <Cale> Right, yeah, that looks like it could get you impredicativity without necessarily breaking everything
17:31:33 <augur> indeed
17:32:05 <piezo> i'm using tying the knot method to feed back the list of parsed bindings into the parser, for in place name resolution, is it silly as it looks ?
17:32:06 <augur> judgmental typeness is actually typically still present in many systems, even if you have a Set k type
17:32:20 <Eduard_Munteanu> Coq has both though.
17:32:24 <augur> Set omega is not a member of anything --   Set omega : Set ???   has no solution
17:32:33 * piezo having fun with laziness, and abusing it...
17:32:40 <augur> but Set omega type is a judgment
17:32:41 <Cale> piezo: Seems reasonable. Doing things like that can require some amount of care though.
17:32:44 <augur> one we ought to believe!
17:32:47 <augur>  /make
17:32:58 <Eduard_Munteanu> augur: I think there are some TTs with transfinite levels
17:33:01 <Cale> piezo: But things like that are exactly what tying-the-knot is good for
17:33:06 <jmcarthur> piezo: a lot of knot tying tricks are great for constrained problems but not so great when you might need to add features later
17:33:07 <augur> Eduard_Munteanu: sure, its not too hard to do
17:33:28 <augur> Eduard_Munteanu: but you can never quantify over all levels
17:33:31 <Cale> Yeah, it can end up being a little inflexible, and you have to be really careful not to create loops.
17:33:37 <jmcarthur> piezo: but i, too, have done the exact same trick, and did not, in the end, regret it at all
17:34:20 <Cale> In the end, it's just recursion. If we didn't believe in recursion to some extent, we wouldn't likely be here :)
17:34:21 <lingxiao> Eduard_Munteanu: didn't get a chance to reply from earlier but I will look at DataKinds and type-level literals, thanks!
17:34:24 <piezo> ok thanks, i'll go with it so
17:34:34 <augur> anyway, the point i was making, Cale, is that you can have dependent types with a `type` judgment, without conflating types and values
17:34:45 <Cale> augur: Well, that's a good point
17:35:12 <augur> you just define new proofs of the `type` judgement for each data type. eg   data Even : Int -> Set wher e...
17:35:13 <augur> would become
17:35:25 <augur> G !- n : Int ===> G !- Even n type
17:35:52 <piezo> maybe i'll restrain myself of doing pattern matching in the parser with the same trick :p
17:39:01 <benzrf> funny story
17:39:14 <benzrf> I implemented the kleene star for monoids
17:39:17 * Eduard_Munteanu really wants first-class modules now :(
17:39:34 <benzrf> then without thinking I did
17:39:37 <augur> so Cale, FP algo invention books?
17:39:48 <benzrf> kleene $ Set.fromList ["foo", "bar", "baz"]
17:39:56 <benzrf> and then I forgot to press ctrl+c
17:40:03 <benzrf> ~_~
17:40:08 <Cale> augur: I dunno, have you read Okasaki?
17:40:24 <augur> Cale: no, does he discuss problem solving heuristics?
17:40:31 <augur> i knw he discusses particular solutions
17:40:36 <augur> im more interested in the meta-solutions
17:40:40 <Cale> Not as much as he talks about the construction of data structures
17:41:02 <Eduard_Munteanu> benzrf: good thing the monoids weren't monads and monads weren't IO and the IO action wasn't forkIO :P
17:41:03 <augur> i think we need more research into how we solve problems
17:41:05 <Cale> I'm not sure it really makes sense to talk about meta-solutions *too* much.
17:41:37 <augur> techniques for how-to-design rather than how-to-write
17:42:03 <augur> i think Saizan, or maybe it was you, Cale, wrote this beautiful little function, something like
17:42:14 <Cale> I tend to think of how-to-design as being the same question as how-to-decide-what-types-things-have
17:42:39 <Cale> But maybe that's a little glib :)
17:42:49 <augur> groupInto n = map (take n) . takeWhile (not . null) . iterate (drop n)
17:42:51 <augur> or something like that
17:42:53 <Cale> yeah
17:42:59 <Cale> might've been me
17:43:14 <Cale> That's just familiarity with what's in Data.List
17:43:28 <Cale> I think...
17:43:43 <Cale> I suppose there's a little bit of "I'm used to lazy programming" in there
17:43:57 <augur> Cale: yeah but knowing how to set that up as the solution to that particular problem
17:44:01 <augur> you really have to "see" it
17:44:45 <Cale> Have you read the paper called "Why Functional Programming Matters"?
17:45:13 <Luke_> is there a way to get cabal to rename my resulting binary depending on the config flags?
17:45:23 <Cale> (It's a bit funny that "Lazy" or "Non-Strict" isn't in that title, because that's what it's *actually* about)
17:46:04 <Cale> Luke: hmm, I dunno
17:47:15 <jmcarthur> Eduard_Munteanu: what do you want first class modules for?
17:48:46 <Eduard_Munteanu> jmcarthur: I'm moving some type definitions into separate modules to allow overlapping field names in records... it would be nicer if I didn't have to shuffle things among a bunch of files
17:49:45 <c_wraith> Luke: worst case, you could have multiple binary sections, and the flags control which are buildable
17:49:54 <Luke> yeah good point
17:50:24 <Luke> i'm basically trying to use shake for my build process and since I really have 2 different binaries (dev and prod) i need them to be named as such so shake knows if it needs to rebuild things
17:51:22 <Luke> the downside is my executable section is... bit
17:51:23 <Luke> big
17:51:43 <c_wraith> Yeah, I did say "worst case" for a reason.  There's lots not to like about that approach
17:52:23 <Luke> right ;-)
17:52:34 <Luke> just trying to give full context just in case anyone has any alternatives
17:53:33 <Luke> any way to move my deps out of the executable section?
17:53:45 <c_wraith> can shake do the thing make often does, where the makefile alters itself based on the environment?
17:55:00 <Luke> c_wraith: not sure what you mean
17:55:07 <Luke> i'm only familiar with the basics of both
17:55:52 <Eduard_Munteanu> Where can I find a reference on .cabal fields?
17:56:12 <c_wraith> Luke: makefiles can include files that they also contain instructions for generating.
17:56:49 <Luke> hmm not sure
17:57:15 <c_wraith> Eduard_Munteanu: I just do cabal init and look at the comments in the generated file.  Not exhaustive, but it works for me.
17:58:04 <Eduard_Munteanu> I was wondering about the 'other-extensions' field, but then I found https://github.com/haskell/cabal/issues/1517
18:00:30 <Luke> Eduard_Munteanu: http://www.haskell.org/cabal/users-guide/developing-packages.html
18:01:55 <binroot> Is it possible to triangulate a point in the manhattan distance? How about the Levenshtein distance? In other words, can I always uniquely find a string equidistanct to 2 or 3 other stings?
18:03:57 <Cale> Not in just any metric space, surely. The discrete metric, where the distance is 1 whenever two points are distinct, and 0 when they're the same will maximise the number of other points you need to know the distances from.
18:04:30 <Cale> For the Manhattan distance, I think you can though.
18:04:35 <augur> Cale: i have yeah
18:04:51 <augur> Cale: i think i should read the schemer books probably
18:05:11 <augur> and/or htdp or something, look for some nice nuggets of design
18:05:42 <augur> this is an enduring problem i have tho, all over the place -- very little of the written material is devoted to methodology
18:06:02 <augur> even at the research level
18:06:50 <augur> blegh. im out
18:06:51 <augur> see ya
18:07:38 <Cale> Well, augur left, but I think his problem is that there is no methodology which usefully applies to arbitrary problem solving.
18:08:46 <jmcarthur> Eduard_Munteanu: so really you just mean disassociating modules from files
18:09:41 <Eduard_Munteanu> jmcarthur: in this case, I suppose so... but I still want first-class modules in the Agda sense too :)
18:10:07 <jmcarthur> Eduard_Munteanu: i'm not aware of support for first class modules in agda
18:10:19 <jmcarthur> Eduard_Munteanu: you mean parameterized modules?
18:10:53 <Luke> c_wraith: damn it seems cabal won't let me have a conditional around the executable block
18:10:54 <Eduard_Munteanu> jmcarthur: yes... how much more first-class can you get, would they be actual values (records?)?
18:10:57 <jmcarthur> Eduard_Munteanu: ("functors" as the ml world would call them)
18:11:03 <jmcarthur> Eduard_Munteanu: yes, values
18:11:19 <jmcarthur> Eduard_Munteanu: ocaml has first class modules. they are modules you can generate and pass around at runtime
18:11:27 <Eduard_Munteanu> That would be nice I suppose.
18:11:42 <jmcarthur> Eduard_Munteanu: and you can write functions that take modules as arguments, etc. all the nice things
18:11:59 <pyon> Eduard_Munteanu: Doesn't -XExistentialQuantification achieve something similar?
18:12:13 <zRecursive> IIRC, OCaml is VERY VERY fast ?!
18:12:17 <jmcarthur> Eduard_Munteanu: but i think type classes and existential types are an okay substitute for first class modules
18:12:25 <jmcarthur> zRecursive: well... not exactly
18:12:32 <Eduard_Munteanu> I'm not sure how existential types fit here.
18:12:38 <jmcarthur> zRecursive: if you write very low level code, it can be quite fast
18:12:44 <c_wraith> Luke: oh, yeah.  But there's a "buildable" field you can put inside the executable that can have conditionals around it.  The default is true, set it to false to make it not build.
18:13:08 <Luke> yeah but how do I use that to change the executable name then?
18:13:25 <c_wraith> Have two different executables, only set one to buildable at a time.
18:13:33 <jmcarthur> Eduard_Munteanu:    the module interface roughly corresponds to a type class, and the instance roughly corresponds to a module, and with existential types you can get something like first class modules:    data FirstClassFoo = forall a. Foo a => FirstClassFoo a
18:13:33 <c_wraith> this involves lots of copying and pasting.  ick
18:13:35 <zRecursive> jmcarthur: do you mean assembly ?
18:13:46 <jmcarthur> zRecursive: no, i just mean not in a high level style
18:13:58 <jmcarthur> zRecursive: you basically have to write C-like code to get C-like performance, in ocaml
18:14:07 <jmcarthur> zRecursive: which is kind of unfortunate
18:14:27 <Luke> c_wraith: who do I toggle buildable for each though?
18:14:34 <zRecursive> jmcarthur: thinking ...
18:14:41 <jmcarthur> zRecursive: on the other hand, ocaml has a very simple cost model, for a functional language, so it isn't really that hard to write fast code
18:14:48 <jmcarthur> zRecursive: it's just not very high level
18:14:58 <pyon> Eduard_Munteanu: I don't see what the difference is between a module and a record that can have types as members. The type of a module is its pincipal signature. Then, explicit signature ascription would just be structural subtyping on such records. Perhaps I'm missing something.
18:15:14 <c_wraith> Luke: you can put the buildable field inside a conditional. Just use opposite conditionals in the two executables
18:15:31 <Luke> oh i think i understand
18:15:32 <Luke> thanks
18:15:35 <Cale> binroot: In the Levenshtein distance on binary strings... I think if you get to choose the points to triangulate from, you need log(n) distances before you'll know you can pin the string down.
18:15:44 <jmcarthur> pyon: you can, in fact, achieve the types-as-members thing using the trick i just described for Eduard_Munteanu combined with associated types (as in from the type families extension)
18:16:10 <pyon> jmcarthur: Nice. :-)
18:16:14 <Eduard_Munteanu> I suppose that does for plain values/functions, yeah.
18:16:52 <jmcarthur> Eduard_Munteanu: as i just explained to pyon, it works for types as well. the only thing you can't really do is define type classes inside other type classes, but haskell kind of lacks the same feature for modules too...
18:17:06 <Eduard_Munteanu> I guess you can call asstypes the equivalent of existentials for classes.
18:17:07 <Cale> oh, he left
18:18:45 <joelteon> For associated datatypes, do you have to define the datatype inside the instance declaration?
18:19:07 <Cale> yes
18:19:23 <Eduard_Munteanu> joelteon: you can define 0 or more *constructors* for it, IIRC
18:19:33 <Cale> yeah
18:19:39 <Luke> c_wraith: awesome idea. works. I was able to pull out the redundant build-depends into a Library section as well
18:20:11 <Eduard_Munteanu> joelteon: the datatype "contains" the sum of all such constructors, from all instances
18:20:35 <joelteon> I see
18:20:41 <ktt3ja> is the naming convention for Haskell camelCase for everything?
18:20:53 <joelteon> Okay, I'm pretty sure a typeclass is the wrong tool for this
18:20:53 <joelteon> ktt3ja: everything except FFI
18:21:09 <ktt3ja> joelteon: k, thanks
18:21:13 <Eduard_Munteanu> I'm still unsure if assdatatypes are distinct from data families + asstypes, save for type synonym instance issues.
18:23:06 <joelteon> edwardk I am not ):
18:23:14 <edwardk> ?
18:23:32 <Eduard_Munteanu> Possibly the wrong ed.
18:24:17 <joelteon> s/(\w+) (.+) \):/$2 $1 ):/
18:24:23 * edwardk reparsed
18:24:29 <edwardk> hah
18:24:53 * Eduard_Munteanu throws an arse error
18:24:58 <Eduard_Munteanu> (pun intended)
18:25:11 <jle`> maybe he was saying "edwardk, i am not."
18:25:24 <jle`> a true statement for the vast majority of haskell programmers
18:25:29 <joelteon> yeah, that's what I was saying
18:25:30 <haasn> I think he was saying “I am not :(”, as in “I am not sad”
18:25:46 <joelteon> see, if we could speak in haskell, these things wouldn't happen
18:25:51 <haasn> jle`: what about if you adjust for lines of code written?
18:26:01 <Eduard_Munteanu> "edwardk, i am not, therefore i am!"? :)
18:26:40 <edwardk> joelteon: nah, because then someone would throw an & in there and cale would regale them for a half hour about how $ could have been used instead ;)
18:26:59 <Cale> haha
18:27:09 <haasn> $ fixes everything
18:27:14 <edwardk> joelteon: edwardk & I am not       cale: I am not $ edwardk would have been clearer.
18:27:45 <joelteon> haskell.users.filtered (/= edwardk)
18:27:50 <Saizan> tbf the first one is pretty yoda-esque
18:28:04 <joelteon> well, that's a thing people do
18:28:06 <joelteon> "{x}, I am not"
18:28:11 <joelteon> clever, I am not
18:28:13 <joelteon> unambiguous, I am not
18:28:27 <jle`> so lens style is really yoda style.
18:28:32 <jle`> everything makes sense now
18:28:51 <haasn> do you need the force to understand lens operators?
18:29:24 <edwardk> lens or lens not, there is no trie
18:29:44 <joelteon> how do you resolve haddock not finding link destinations
18:30:00 <edwardk> joelteon: usually by crying
18:30:09 <joelteon> i've been doing that, no luck
18:30:15 <edwardk> then i ask solirc and he tells me how to fix it
18:30:34 <haasn> You mean for documentation you're generating? Or if you find documentation online that doesn't link to some (internal) type?
18:30:56 <joelteon> No, when I'm generating it
18:31:04 <Eduard_Munteanu> Since we're on this topic... any chance lens has typesafe designated initializers, in the sense that given a bunch of lenti (?) you can enforce construction of a fully-defined value by some other means than record syntax?
18:31:23 <startling> Eduard_Munteanu, prisms
18:31:25 <edwardk> Eduard_Munteanu: sadly nada. it is a rather disgustingly hard problem
18:31:36 <startling> oh, I see what you mean.
18:32:02 <edwardk> Eduard_Munteanu: basically we have the notion you'd need to solve it worked out, but its too ugly to use and requires O(n!) instances for a constructor with n fields, etc.
18:32:22 <haasn> it seems simple to do in theory with TH and a handful of type families
18:32:28 <edwardk> so we dropped it
18:33:38 <ktt3ja> joelteon: if it's an abbreviation or acronym, say blpx, should it be blpx, bLpx, or bLPX?
18:34:33 <Eduard_Munteanu> edwardk: hm... isn't it possible to get that effect with DataKinds? Basically each record would be a HList, perhaps a type family can verify all of them are present.
18:35:51 <haasn> Eduard_Munteanu: that's what I was thinking, each operation adds a constructor to some empty token type and a TF checks that each constructor appears at least once
18:35:59 <joelteon> ktt3ja: if it's a normal function, probably blpx
18:36:16 <haasn> _BLPX
18:36:19 * haasn throws up a little
18:37:09 <haasn> I guess that's not really what I was thinking, since my approach doesn't really involve a HList
18:37:18 <Eduard_Munteanu> I should try it, perhaps submit a patch (along with a nice FieldRules maybe) too.
18:39:04 <haasn> My idea was to start with the usual Foo { _a = undefined, _b = undefined, _c = undefined } but have the lenses for a/b/c change the type of Foo when modifying. Come to think of it, that can't be legal
18:39:49 <Eduard_Munteanu> haasn: I think edwardk meant solutions involving classes each partial construction explodes rather quickly.
18:39:49 <haasn> eg. a :: (a -> f b) -> Foo a -> Modified "a" (Foo b)  with Modified :: Symbol -> * -> *
18:40:04 <Eduard_Munteanu> *classes for each
18:40:56 <Eduard_Munteanu> Actually I don't even need partial constructions.
18:41:21 <edwardk> in the end you just need the total construction given all the right named fields
18:41:27 <Eduard_Munteanu> I just want to be able to reuse field names, which you can with lens names.
18:41:35 <haasn> and then some Has :: Symbol -> * -> Constraint with instances Has a (Modified a x) and Has a b => Has a (s x)
18:41:38 <edwardk> but you need to build up from some kind of hlist-assembled record, then convert
18:41:45 <haasn> no idea if this works out or not but it's my first idea
18:42:14 <haasn> at any rate, it would work if you drop the lens machinery and just use your own “setA :: b -> Foo a -> Modified "a" (Foo b)”
18:42:42 <edwardk> if someone sits down and writes an hlist that uses the new field accessor names you could have something that 'blesses' an hlist and converts it to a traditional haskell record type when its done
18:42:52 <haasn> Oh, except not really, because “setA x . setA x” would be a type error
18:42:53 <haasn> Hmm.
18:43:06 <Eduard_Munteanu> edwardk: I have a bunch of records I want to be able to construct without ugly designators like _fooField, where "Field" appears in multiple such records
18:43:36 <haasn> Eduard_Munteanu: you can do that already with makeClassy
18:43:41 <haasn> even before the overloaded records stuff
18:43:56 <haasn> oh, you mean; you want the actual field names to be pretty too?
18:44:18 <edwardk> Eduard_Munteanu: yeah. what i'm suggesting is if you ave a form of hlist which can be built up off of valid accessors, by making appriate instances of Has, Set, Accessor, etc. then you could take the resulting hlist and convert it to a record in the end. if you did it right you could get field name punning, etc.
18:44:25 <Eduard_Munteanu> haasn: yes. If not, I want to be able to construct records with lenses, which in turn have pretty names.
18:44:48 <haasn> Eduard_Munteanu: and in that case, you want them checked. Anyway, adding this to lens seems like an XY with the new records machinery
18:45:03 <edwardk> Eduard_Munteanu: as a straw man you might use _Foo # (pass it something like a vinyl record here)
18:45:05 <Eduard_Munteanu> haasn: the new records machinery? :O   linky link?
18:45:20 <haasn> Eduard_Munteanu: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Plan
18:45:37 <edwardk> http://www.well-typed.com/blog/84
18:45:46 <Eduard_Munteanu> Hm, cool.
18:45:55 <haasn> oh, this is not going into 7.8? :(
18:46:05 <Eduard_Munteanu> haasn: did that make it into any release or at least into HEAD?
18:46:43 <haasn> Eduard_Munteanu: edwardk's link quotes “GHC HEAD will soon support [...]”, as of 29 Nov
18:46:55 <edwardk> its going in 7.10
18:46:55 <Eduard_Munteanu> Ah.
18:47:44 <edwardk> didn' figure out quite what the proposal should look like til near the end of the summer of code, by then it was rather late for 7.8 and there are still some open design questions the community should provide feedback upon once it works in the real compiler
18:48:15 <Eduard_Munteanu> edwardk: I could submit a very simple FieldRules that didn't require '_' or a prefix, in the meanwhile, I suppose :)
18:48:47 <Eduard_Munteanu> That way you can get the lenses in *other* modules.
18:49:19 <edwardk> Eduard_Munteanu: patch away =P
18:49:37 <startling> I'd like a "makeLenses ["a", "b", "c"] ''Whatever" that just filled in the names in order.
18:49:42 <haasn> edwardk: what's the release status on 7.8 anyhow? I'm still stuck on 7.6.2 because I'm skipping 7.6.3 “due to 7.8 being just around the corner”, and being this far from HEAD for so long has been making me quite nervous :(
18:49:51 <startling> i.e. in a datatype without field accessors at all
18:49:56 <edwardk> startling: there is something _kinda_ like that that takes an assoc-list
18:50:19 <startling> edwardk: right. I'd rather avoid having accessors at all
18:50:25 <edwardk> haasn: you'd have to ask thoughtpolice. i've been kind of tuned out on the happenings in GHC-land
18:50:49 <Eduard_Munteanu> You could always twist and feed appropriate input into camelCaseRules. :)
18:51:07 <edwardk> startling: sure. it just gets awfully ad hoc pretty quick when you have a mixture of field names that are used in different records getting nubbed out, etc.
18:51:11 <thoughtpolice> haasn: i have been far busier than i expected, including some minor friend/family crises these past few weeks, and also Christmas sucks.
18:51:30 <thoughtpolice> i plan on fixing up the last few bugs before christmas and kicking the RC out the door, but i'm about to be flying out again soon for family
18:51:32 <haasn> thoughtpolice: I understand, I hope you're doing okay
18:51:52 <haasn> your family is more important than GHC :)
18:52:19 <edwardk> thoughtpolice: i hope all is well or at least ends well, and take care. i can live without 7.8 for a few more months, but after that i'll start giving you crap about it ;)
18:53:21 <thoughtpolice> haasn: edwardk - in this case, it was more my friends. two of my friends had their fathers pass away within the same week, so i was out for a lot longer than i expected (literally they happened almost one day after another.) they are OK however, and my family is fine
18:53:30 <thoughtpolice> i've just had my attention extremely divided recently amongst many things
18:53:38 <thoughtpolice> (hence why i've been mostly dormant it seems)
18:54:45 <haasn> thoughtpolice: I'm sorry to hear that. Actually, a friend's friend's father passed away recently too. I wonder if by some coincidence we're linked to the same person without realizing it
18:55:01 <thoughtpolice> oh, and also i'm in the middle of segfaulting Windows builds seemingly for no reason, and did i mention Windows also sucks?
18:55:19 <thoughtpolice> haasn: :( much <3 and piece to your friend
18:55:36 <haasn> thoughtpolice: thanks, to yours too
18:55:50 <thoughtpolice> also *peace
18:55:58 <thoughtpolice> i don't even know how i fucked that one up that badly.
18:57:17 <Eduard_Munteanu> Argh, haskell-mode ignores .cabal?
18:57:40 <Eduard_Munteanu> It doesn't seem to account for default-extensions
18:57:46 <haasn> thoughtpolice: I wonder how old your friends are, if I may ask
18:58:28 <Eduard_Munteanu> * cabal files
18:59:22 <haasn> (perhaps privately, if this is a bit too public)
19:00:47 <jmcarthur> Eduard_Munteanu: have you looked at vinyl?
19:01:04 <Eduard_Munteanu> Hm, no, lemme google a bit...
19:01:36 <Eduard_Munteanu> Interesting, thanks.
19:14:04 <joelteon> does haskell platform come with documentation or not?
19:17:43 <pfurla> hello guy. in emacs is there a haskell type-check key bind?
19:18:55 <Eduard_Munteanu> pfurla: you normally C-c C-l to do that
19:19:26 <pfurla> Eduard_Munteanu: yeah, I wanted something a little less than that
19:19:45 <pfurla> but C-c C-i does works
19:25:52 <pfurla> Eduard_Munteanu: yeah, just a matter of positioning the frames properly and it works the way I want, thanks :)
19:26:53 <raphie> is there a way to use && with function composition? something to replace: foo a = bar a && baz a
19:27:00 <jmcarthur> pfurla: check out ghc-mod. there's also a competitor which is a bit newer, but i can't remember the name
19:27:22 <jmcarthur> raphie: foo = liftA2 (&&) bar baz
19:27:26 <Eduard_Munteanu> raphie: liftA2 (&&) bar baz  but it's not really better
19:27:38 <pfurla> jmcarthur: thanks I will keep that in mind
19:27:45 <Eduard_Munteanu> Or  (&&) <$> bar <*> baz
19:27:56 <jmcarthur> i like the liftA2 version, personally
19:28:03 <jle`> wish there was a better liftA2/liftA2...an operator or something
19:28:14 <jle`> is there some lens solution?
19:28:20 <jmcarthur> jle`: there's always SHE
19:28:40 <edwardk> jle`: what is it you want to do?
19:28:43 <jmcarthur> jle`: (preprocessor that among other things add idiom brackets, which is an applicative syntax sugar)
19:28:56 <jmcarthur> proof that edwardk has lens on highlight
19:29:09 <Eduard_Munteanu> @pl \a -> bar a && baz a
19:29:09 <lambdabot> liftM2 (&&) bar baz
19:29:12 <scott_> Is there a proposal for idiom brackets in GHC or does no one care?
19:29:16 <edwardk> jmcarthur: i rotate my highlights, lest i become too predictable ;)
19:29:20 <jmcarthur> heh
19:29:22 <jle`> edwardk: an perator version of liftM2/liftA2
19:29:25 <jle`> operator
19:29:42 <edwardk> > (&&) <$> [True,False] <*> [True, False]
19:29:44 <lambdabot>  [True,False,False,False]
19:29:44 <zRecursive> :t liftA2
19:29:45 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
19:29:47 <ktt3ja> what did I do wrong? http://pastebin.com/1Hbhxaj5
19:29:49 <lamefun> are cabal packages signed yet?
19:29:51 <mauke> The paste 1Hbhxaj5 has been copied to http://lpaste.net/97243
19:29:52 <edwardk> its magic!
19:30:02 <edwardk> > (,,) <$> [True,False] <*> [True, False] <*> [True, False]
19:30:03 <lambdabot>  [(True,True,True),(True,True,False),(True,False,True),(True,False,False),(Fa...
19:30:18 <jmcarthur> ktt3ja: your sorting function should be curried
19:30:37 <Eduard_Munteanu> lamefun: not AFAIK, but there's https support in place, not cabal though.
19:30:38 <jmcarthur> ktt3ja: it takes two arguments, not one tuple
19:30:56 <joelteon> join (liftM2 (&&)) [True, False]
19:31:12 <Eduard_Munteanu> lamefun: do you mean owners signing packages, or Hackage signing downloads?
19:31:17 <jmcarthur> (join.liftM2) (&&) [True, False]
19:31:38 <jmcarthur> :t join.liftM2
19:31:39 <lambdabot> Monad m => (a1 -> a1 -> r) -> m a1 -> m r
19:31:45 <ktt3ja> jmcarthur: how do I make lambda take two argument?
19:31:56 <jmcarthur> ktt3ja: \ a b -> ...
19:32:04 <lamefun> hackage signing downloads
19:32:38 <ktt3ja> jmcarthur: thanks
19:32:41 <jmcarthur> np
19:32:47 <jmcarthur> bedtime
19:34:07 <Eduard_Munteanu> lamefun: I haven't seen any hashes on Hackage, but you can download the whole package over https manually if you want to.
19:34:15 <Eduard_Munteanu> lamefun: #hackage might know more
19:34:45 <zRecursive> :t liftM2
19:34:46 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:35:11 <Eduard_Munteanu> lamefun: last time I asked (about a week or two ago) the main issue is there's no easy way to do SSL client stuff cross-platform from Haskell.
19:36:25 <Eduard_Munteanu> It should be easy on Linux though, and I guess even partial support is welcome.
19:36:41 <Eduard_Munteanu> Er, s/welcome/warranted/ :)
19:37:33 <jle`> something maybe like (&&) <<.>> bar baz
19:38:18 <Eduard_Munteanu> jle`: that sort of stuff will always parse as ... (bar baz)
19:38:46 <jle`> hm you can't make operators bind tighter than function application?
19:38:50 <scott_> With idiom brackets it's just [| bar && baz |]
19:39:04 <jle`> scott_: that looks nice; is that TH?
19:39:10 <Eduard_Munteanu> jle`: nope... the only thing that binds tighter is record syntax
19:39:20 <scott_> I saw a TH implmentation of it once, I believe
19:39:33 <scott_> It was something like [idiom| .. |] in that case
19:39:58 <jle`> how about something like (&&) <~> bar <<.>> baz
19:40:09 <jle`> probably the same verbosity as liftM2/liftA2 then huh
19:40:26 <Eduard_Munteanu> jle`: sure, let (<~>) = (<$>) and (<<.>>) = (<*>)   :)
19:40:56 <Eduard_Munteanu> :t (&&) <$> ?bar <*> ?baz
19:40:57 <lambdabot> (Applicative f, ?bar::f Bool, ?baz::f Bool) => f Bool
19:41:08 <scott_> What is that ?bar syntax?
19:41:10 <Eduard_Munteanu> Where f = (->) a
19:41:14 <jle`> bar and baz are suppose dto be :: a -> Bool
19:41:28 <Eduard_Munteanu> scott_: implicit arguments
19:41:41 <scott_> jle`: ((->) a) has an Applicative instance
19:41:43 <jle`> oh hey i think it works
19:41:44 <Eduard_Munteanu> Abused to write stuff like the above in lambdabot.
19:41:51 <jle`> oh my goodness my life is changed forever.
19:42:14 <Eduard_Munteanu> jle`: as you can see it easily extends to 3-ary functions and so forth
19:42:44 <Eduard_Munteanu> :t (,,) <$> ?a <*> ?b <*> ?c
19:42:46 <lambdabot> (Applicative f, ?a::f a2, ?b::f a1, ?c::f a) => f (a2, a1, a)
19:42:54 <jle`> had never used (->)'s applicative instance before
19:42:55 <startling> :t (,) <$> snd <*> fst
19:42:56 <lambdabot> (a, b) -> (b, a)
19:43:23 <pavonia> Is there any way to "start" a new monad in GHCi and run all subsequent actions in that monad?
19:43:30 <scshunt> pavonia: huh?
19:43:35 <startling> ^
19:43:36 <jle`> pavonia: you mean instead of just doing do ...
19:43:38 <jle`> ?
19:43:47 <scott_> I don't think so, pavonia
19:43:49 <pavonia> I mean interactively
19:43:57 <startling> pavonia, it's not clear what you mean.
19:44:39 <pavonia> Well, as I understanc GHCi is just like a huge IO-do-block, I just want to change that IO to another, custom monad
19:45:05 <startling> pavonia, ummmmmm
19:45:19 <Eduard_Munteanu> That is true, AFAIK.
19:45:19 <startling> pavonia, if you want to run a State action, you runState it.
19:45:35 <startling> pavonia, if you want to run a Writer action, you runWriter it.
19:45:51 <startling> pavonia: if you want to run a Maybe action, you think about whether what you want makes sense.
19:46:08 <jle`> the interactive Maybe do actually makes the most sense
19:46:13 <scott_> Eduard_Munteanu: Not entirely, since you can write import/data/type/newtype/etc
19:46:32 <raphie> is there a function which determines whether all elements in a list are unique?
19:46:49 <Eduard_Munteanu> raphie: not really
19:46:51 <raphie> I suppose I could roll my own with Data.Set but why bother if it exists
19:47:08 <pavonia> startling: I don't want to specify the complete action in the first place but add other actions interactively
19:47:09 <Eduard_Munteanu> raphie: no, there isn't even a Set/Map-based nub
19:47:14 <jle`> you could compare the length to the nub'd length
19:48:01 <Eduard_Munteanu> nub is a horrifying O(n^2) sadly.
19:48:10 <jle`> yeah not quite a good idea
19:49:04 <Eduard_Munteanu> :t (==) <$> S.size . S.fromList <*> length
19:49:06 <lambdabot> Ord a => [a] -> Bool
19:49:23 <Eduard_Munteanu> Fits well with the previous discussion. :)
19:49:31 <jle`> :)
19:49:40 <scott_> How expensive is S.fromList (big-O)?
19:50:03 <raphie> how's this? https://gist.github.com/RaphiePS/97892b284dba195b660b
19:50:07 <Eduard_Munteanu> scott_: O(n log n) I think, it's pretty much equivalent to sorting the list.
19:50:31 <Eduard_Munteanu> s/I think/it better be   :)
19:51:16 <raphie> is there a way to feed multi-line inputs to lambdabot?
19:51:31 <ktt3ja> is there a way for me to match two cases in one arm of a case expression?
19:51:42 <jle`> raphie: not quite but you can split up your let's with @let
19:51:48 <jle`> just use semicolons
19:52:31 <Eduard_Munteanu> ktt3ja: if said two cases are the only remaining cases, or if you can write it as a guard
19:52:31 <scott_> Eduard_Munteanu: You're right, the documentation specifies O(n log n)
19:53:03 <raphie> jle`: and how should I import stuff?
19:53:07 <raphie> Data.Set in this case
19:53:11 <ktt3ja> Eduard_Munteanu: so I can't do something like an alternation?
19:53:38 <jle`> raphie: i don't think you can import them; if lambdabot has those modules loaded then you can use the functions qualified
19:53:50 <Eduard_Munteanu> ktt3ja: no
19:54:46 <raphie> > @let insert x (u, s) = (u && (not $ Data.Set.member x s), Data.Set.insert x s);
19:54:48 <lambdabot>  <hint>:1:1: parse error on input `@'
19:55:04 <scott_> raphie: Without the >
19:55:13 <raphie> @let insert x (u, s) = (u && (not $ Data.Set.member x s), Data.Set.insert x s);
19:55:14 <lambdabot>  .L.hs:165:18: Not in scope: `Data.Set.member'
19:55:14 <lambdabot>  
19:55:14 <lambdabot>  .L.hs:165:40:
19:55:14 <lambdabot>      Not in scope: `Data.Set.insert'
19:55:14 <lambdabot>      Perhaps you meant `Data.List.insert' (imported from Data.List)
19:55:17 <Eduard_Munteanu> S.insert is enough.
19:55:28 <Eduard_Munteanu> :t S.member
19:55:29 <lambdabot> Ord a => a -> S.Set a -> Bool
19:55:47 <Eduard_Munteanu> @index S.member
19:55:47 <raphie> @let insert x (u, s) = (u && (not $ S.member x s), Set.insert x s);
19:55:47 <lambdabot> bzzt
19:55:48 <lambdabot>  .L.hs:164:47:
19:55:48 <lambdabot>      Not in scope: `Set.insert'
19:55:48 <lambdabot>      Perhaps you meant one of these:
19:55:48 <lambdabot>        `S.insert' (imported from Data.Set), `L.insert' (line 164),
19:55:49 <lambdabot>        `IM.insert' (imported from Data.IntMap)
19:55:52 <raphie> er
19:56:02 <raphie> sorry for taking up the main chat, can I PM lamdabot?
19:56:06 <jle`> yes
19:56:07 <Eduard_Munteanu> raphie: sure
19:56:12 <jle`> i'll allow it
19:56:58 <Sgeo> :t \a b c -> a <* b *> c
19:56:59 <lambdabot> Applicative f => f a -> f b1 -> f b -> f b
19:57:05 <Eduard_Munteanu> Just don't give it money if it asks for it. :P
19:57:23 <Sgeo> :t \a b c -> a <* (b *> c)
19:57:24 <lambdabot> Applicative f => f a -> f a1 -> f b -> f a
19:57:52 <jle`> also don't tell it your password
19:57:53 <Sgeo> I guess anyone actually using a <* b *> c would be shot, unlike someone using a *> b <* c?
19:58:14 <Sgeo> (not literally shot)
19:58:33 <startling> a <* b *> c is pretty funny.
19:58:34 <Eduard_Munteanu> Sgeo: applicative stuff always associates to the left
19:58:39 <edwardk> Sgeo : if you stick t <$>, <*>, <$, and <* you can reason about the parenthesization pretty easily
19:58:48 <Eduard_Munteanu> Sgeo: if you remember that it's easy to work things out
19:58:50 <startling> Eduard_Munteanu: good to know.
19:59:04 <edwardk> when you mix in *> is when things go silly
19:59:39 <Sgeo> Seems odd, especially because *> seems simpler than <* (although I love the thought of <* )
19:59:50 <Eduard_Munteanu> > x *> y *> z
19:59:51 <lambdabot>  Couldn't match expected type `f0 a1'
19:59:51 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'Couldn't match e...
19:59:51 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'Couldn't match e...
19:59:51 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
19:59:52 <edwardk> Sgeo: its because of the associativity needed
20:00:04 <raphie> here we go:
20:00:06 <raphie>  > let unique = fst . foldr (\x (u, s) -> (u && (not $ S.member x s), S.insert x s)) (True, S.empty) in (unique [1,2,3], unique [1,2,1])
20:00:16 <erisco> I am confused on the memoisation approaches here http://www.haskell.org/haskellwiki/Memoization
20:00:27 <raphie> > let unique = fst . foldr (\x (u, s) -> (u && (not $ S.member x s), S.insert x s)) (True, S.empty) in (unique [1,2,3], unique [1,2,1])
20:00:31 <lambdabot>  (True,False)
20:00:37 <erisco> how do you achieve (a -> b) -> a -> b without an unsafePerformIO? or is that the intent?
20:00:50 <Luke> I'm trying to follow this: http://stackoverflow.com/questions/10163604/how-to-reduce-duplication-in-the-build-depends-fields-of-a-cabal-file?answertab=votes#tab-top but for some reason, my executable keeps complaining it doesn't have all the stuff that my library is indeed building
20:00:56 <Sgeo> prog1 and <* just... seems nicer than store in variable, do action, return variable
20:01:06 <Luke> it seems like it wants me to export every dependency of my library as well
20:01:18 <Sgeo> Or maybe I suck at imperative
20:01:50 <raphie> jle`: I think my solution is a bit faster than comparing the lengths of the list and the nub'd list because you don't have to fully evaluate the list (to find its length), you only have to go as far as the first recurring element
20:01:57 <raphie> (I think)
20:02:17 <jle`> most solutions are better than nub-ing :)
20:02:18 <scott_> erisco: The memoization there is per-call, not global. When you do fib 10 it builds up a map to get the result in O(n) time but it doesn't keep the map around. The next fib 10 call builds the same map.
20:02:31 <Eduard_Munteanu> raphie: yeah
20:02:57 <edwardk> erisco: nteresting timing. i just wrote http://lpaste.net/97230 today
20:03:19 <Eduard_Munteanu> raphie: I don't think you want a foldr though
20:03:31 <edwardk> class Memo a where  memo :: (a -> b) -> a -> b
20:03:43 <raphie> Eduard_Munteanu: why?
20:03:45 <scott_> erisco: Actually it doesn't look like it's using an actual Map, but that's the idea
20:04:53 <raphie> > let unique = fst . foldr (\x (u, s) -> (u && (not $ S.member x s), S.insert x s)) (True, S.empty) in unique $ repeat 1
20:04:54 <lambdabot>  *Exception: stack overflow
20:05:02 <raphie> ooh, that's a problem
20:05:51 <raphie> Eduard_Munteanu: how should I solve it then?
20:06:06 <edwardk> erisco: consider how you  would memoize (Bool -> a)
20:06:50 <edwardk> erisco: you could make a data structure data Foo a = Foo a a -- then store Foo (f False) (f True)
20:07:04 <edwardk> erisco: then index into that structure
20:07:25 <edwardk> you have 'two places' to hold onto values, so each will be computed exactly once no matter how many tims you ask
20:07:38 <Eduard_Munteanu> raphie: Set/Map are strict in the keys, so a foldl' would go better but that's inconvenient for shortcut evaluation of (&&).
20:07:44 <erisco> edwardk, I see, so it abuses lazy evaluation
20:08:29 <raphie> Eduard_Munteanu: what's the difference between foldl' and foldl?
20:08:35 <jle`> is it weird that Float/Doubles are Enum
20:08:40 <edwardk> erisco: yeah basically you just built a lazy tree structure that holds all the possible values you could ask
20:08:41 <ion> raphie: You’ll want to use foldl'
20:09:00 <ion> raphie: /msg lambdabot @src foldl, /msg lambdabot @src foldl'
20:09:04 <Eduard_Munteanu> raphie: foldl' has a strict accumulator
20:09:13 <raphie> how could I get the shortcut && to work?
20:09:22 <jle`> foldl' f a xs = xs `seq` foldl f a xs
20:10:16 <raphie> > let unique = fst . foldl' (\(u, s) x -> (True, S.empty) (u && (not $ S.member x s), S.insert x s)) in unique $ repeat 1
20:10:17 <lambdabot>  Couldn't match type `[a1]
20:10:17 <lambdabot>                       -> (GHC.Types.Bool, Data.Set.Base.Set a1)'
20:10:17 <lambdabot>                with `(c0, b0)'
20:10:17 <lambdabot>  Expected type: (GHC.Types.Bool, Data.Set.Base.Set a1) -> (c0, b0)
20:10:17 <lambdabot>    Actual type: (GHC.Types.Bool, Data.Set.Base.Set a1)
20:10:19 <scott_> jle`: That's not right
20:10:38 <raphie> er, whoops, lemme fix that in a PM :)
20:10:55 <Eduard_Munteanu> raphie: not sure how easy that is... maybe if you write it as a scanl
20:11:01 <jle`> scott_: http://hackage.haskell.org/package/acme-php-0.0.3/docs/src/Prelude-PHP.html#foldl%27 :P
20:11:19 <roboguy_> raphie: shortcut &&? You mean short-circuiting?
20:11:30 <raphie> roboguy_: yeah I think so
20:11:39 <scott_> jle`: Best alternative Prelude :)
20:11:57 <roboguy_> raphie: it already is shortcircuiting
20:12:00 <roboguy_> > False && undefined
20:12:02 <lambdabot>  False
20:12:07 <Eduard_Munteanu> raphie: actually, you can foldl' with flip (&&) really
20:12:09 <startling> laziness. :)
20:13:20 <jle`> @src (&&)
20:13:20 <lambdabot> True  && x = x
20:13:20 <lambdabot> False && _ = False
20:13:53 <jle`> isn't it cool that the short circuiting isn't syntax but actually built on top of the language
20:14:46 <raphie> Eduard_Munteanu: a little confused, example?
20:16:09 <raphie> how can I get this to short-circuit properly:
20:16:13 <raphie> > let unique = fst . foldr (\x (u, s) -> (u && (not $ S.member x s), S.insert x s)) (True, S.empty) in unique $ repeat 1
20:16:15 <lambdabot>  *Exception: stack overflow
20:17:50 <roboguy_> raphie: && shortcircuits when it's first argument is False. It can't when it is True
20:19:01 <raphie> roboguy_: but the "next round" of the fold, if the previous one was (False, _) should catch that, yes?
20:19:10 <Sgeo> It's possible with some trickery to make a && that short-circuits when either argument is false
20:19:57 <raphie> oooooh it'll keep inserting into the set regardless of the fst in the tuple
20:20:40 <roboguy_> Sgeo: good point, that's true
20:21:33 <Eduard_Munteanu> > scanl (\(b, v) e -> (b && (v < 3), v + e)) (True, 0) [1,2,3,4,5]
20:21:34 <lambdabot>  [(True,0),(True,1),(True,3),(False,6),(False,10),(False,15)]
20:21:55 <maxs__> has anyone worked on abstracting lambdabot away from just IRC?
20:22:02 <raphie> how do I get the fold to "quit" then? using the example I gave, if u is ever false, it should stop and return
20:22:19 <jle`> i think i asked this earlier
20:22:26 <jle`> but i don't think you can have a short-circuiting fold
20:22:31 <jle`> actually wait someone gave an answer that i didn't understnad
20:22:51 <Eduard_Munteanu> > fst $ scanl (\(b, v) e -> (b && (v < 3), v + e)) (True, 0) [1,2,3,undefined]
20:22:52 <lambdabot>  Couldn't match expected type `(a0, b0)'
20:22:52 <lambdabot>              with actual type `[(GHC.Types.Bool, a1)]'
20:23:00 <roboguy_> raphie: how about an if or a pattern match?
20:23:01 <Eduard_Munteanu> Er.
20:23:05 <Eduard_Munteanu> > map fst $ scanl (\(b, v) e -> (b && (v < 3), v + e)) (True, 0) [1,2,3,undefined]
20:23:06 <lambdabot>  [True,True,True,False,False]
20:23:14 <Sgeo> foldr 'short-circuits' by ignoring the accumulator, right?
20:23:19 <jle`> i asked about an implentation of (!!) using foldl that is as efficient as the explicit recursion
20:23:21 <Eduard_Munteanu> > map fst $ scanl (\(b, v) e -> ((v < 3) && b, v + e)) (True, 0) [1,2,3,undefined]
20:23:23 <lambdabot>  [True,True,True,False,False]
20:23:30 <raphie> roboguy_:
20:23:33 <raphie> > let unique = fst . foldr (\x (u, s) -> if u then ((not $ S.member x s), S.insert x s) else (False, s)) (True, S.empty) in unique $ repeat 1
20:23:34 <lambdabot>  *Exception: stack overflow
20:23:34 <Eduard_Munteanu> Uh.
20:23:50 <Sgeo> Oh, a fold that both doesn't stack overflow and is short-circuitable?
20:24:11 <Sgeo> *doesn't stack-overflow when building up ... ok, wow, phrasing this wrong
20:24:17 <Luke> http://lpaste.net/97245 anyone know what's going on with this error here? I need help interpreting it's meanning
20:24:19 <Luke> meaning*
20:24:28 <raphie> Sgeo: well the point in that example is that it should recognize after the second 1 that there's a repeat element, and should stop
20:24:58 <Eduard_Munteanu> > map fst $ scanl (\(b, v) e -> ((v < 3) && b, v + e)) (True, 0) [1,2,3,undefined,undefined]
20:24:59 <lambdabot>  [True,True,True,False,False,*Exception: Prelude.undefined
20:25:15 <Eduard_Munteanu> > map fst $ scanl (\(b, v) e -> (b && (v < 3), v + e)) (True, 0) [1,2,3,undefined,undefined]
20:25:16 <lambdabot>  [True,True,True,False,False,False]
20:25:42 <Eduard_Munteanu> > fst $  foldl' (\(b, v) e -> (b && (v < 3), v + e)) (True, 0) [1,2,3,undefined,undefined]
20:25:43 <lambdabot>  False
20:26:22 <Eduard_Munteanu> raphie: since (&&) is commutative you can just flip it around for the desired semantics
20:28:00 <Eduard_Munteanu> If it wasn't, well, I suppose you could have worked with the scanl.
20:28:15 <alex20032> What does guy here would recommend for inter process communication using haskell?
20:28:30 <raphie> > fst $  foldl' (\(b, v) e -> (b && (v < 3), v + e)) (True, 0) $ repeat 1
20:28:35 <lambdabot>  mueval: ExitFailure 1
20:28:36 <lambdabot>  mueval: Prelude.undefined
20:29:02 <raphie> Eduard_Munteanu: shouldn't that return False?
20:29:32 <raphie> > fst $  foldl' (\(b, v) e -> (b && (v < 3), v + e)) (True, 0) $ iterate (+1) 1
20:29:38 <lambdabot>  mueval: ExitFailure 1
20:29:38 <lambdabot>  mueval: Prelude.undefined
20:29:48 <Eduard_Munteanu> raphie: it can't, it's strict
20:29:52 <alex20032> Its my first time i will make IPC, need that for a home automation project where a haskell webserver will allow people to remote control thing from a web browser. Then haskell will communicate with a program written in C++. That program written in C++ will control some mcu in the house to do various thing.
20:30:05 <raphie> Eduard_Munteanu: is there a way to make it return False like that? sorry, I'm new :)
20:30:49 <Eduard_Munteanu> Er, I think I confused you.
20:32:15 <Luke> http://lpaste.net/97245 anyone help interpreting this cabal build error meaning?
20:33:32 * lispy likes the HWN joke this week
20:33:45 <lispy> ?quote glutamate
20:33:45 <lambdabot> nlogax says: With FRP.Sodium and Graphics.UI.GLUT you could put together a MonadSodium GLUTamate
20:33:48 <lispy> ^^
20:34:17 <Eduard_Munteanu> raphie: oh, I see what happens...
20:34:39 <Eduard_Munteanu> raphie: the spine of the list is evaluated entirely, but not the elements themselves
20:35:06 <raphie> Eduard_Munteanu: is the spine the reference chain thing?
20:35:23 <Eduard_Munteanu> raphie: yeah, I mean the cons cells
20:36:00 <raphie> Eduard_Munteanu: could it be solved by doing something like: type FoldResult = Bool | Int
20:36:38 <Eduard_Munteanu> raphie: nah, you just can't do it as a simple nice fold I think
20:36:56 <raphie> so I'd just roll my own recursive function?
20:38:10 <tinyghost> so, why do people name things like Text.Blaze.Html5 instead of Text.Blaze.HTML5
20:38:11 <Eduard_Munteanu> raphie: hm, wait, the question your function answers isn't decidable for possibly-infinite streams anyway
20:38:18 <tinyghost> it shouldn't bother me but it does
20:38:37 <tinyghost> if you have to capitalize the first letter why not go all the way and write the acronym correctly
20:38:46 <raphie> Eduard_Munteanu: ooh I didn't consider that, you're right!
20:38:47 <Eduard_Munteanu> raphie: you can't really tell [1..] has no duplicates, for example
20:38:49 <carter> tinyghost: 'cause the author wrote blaze while a student :)
20:38:50 <carter> i think
20:38:59 <tinyghost> haha
20:39:06 <tinyghost> I thought it was some kind of Haskell convention
20:39:07 <carter> jasper is the blaze author right?
20:39:10 <carter> doing which?
20:39:27 <carter> spelling things like they're words/
20:39:28 <carter> ?
20:39:33 <tinyghost> yeah
20:39:58 <tinyghost> like camel case but doing ABC like Abc if it's an acronym
20:40:38 <Sgeo> A fake monad that could easily be a real monad :/
20:41:00 <Sgeo> WHY was blaze a (indirect) dependency for warp-static?
20:41:52 <raphie> is there any easy way to test to see if something will be evaluated? like a function that returns something and logs a message when it is evaluate
20:41:54 <raphie> d
20:42:07 <Sgeo> Debug.Trace.trace?
20:42:15 <Sgeo> For debugging use only
20:42:25 <Sgeo> unsafePerformIO inside
20:42:45 <raphie> Sgeo: trace is perfect
20:42:46 <Sgeo> (Well, there are uses of unsafePerformIO that make sense in practical context)
20:43:07 * hackagebot webdriver-angular 0.1.1 - Webdriver actions to assist with testing a webpage which uses Angular.Js  http://hackage.haskell.org/package/webdriver-angular-0.1.1 (JohnLenz)
20:43:51 <raphie> Sgeo: Debug.Trace.trace isn't in scope according to lambdabot
20:49:47 <Eduard_Munteanu> > foldr1 f $ scanl (+) z [a,b,c]
20:49:48 <lambdabot>  f z (f (z + a) (f (z + a + b) (z + a + b + c)))
20:50:08 <jle`> raphie: lambdabot doesn't do any IO, so you are going to have to do it on ghci
20:58:08 * hackagebot JuicyPixels-repa 0.7 - Convenience functions to obtain array representations of images.  http://hackage.haskell.org/package/JuicyPixels-repa-0.7 (ThomasDuBuisson)
21:19:00 <meoblast001> relrod: no
21:20:33 <blaenk> if I have a let sometext = somesource, followed by a forkIO $ something with sometext, will I get bitten by lazy io? if so, is there a way to avoid that in that scenario?
21:20:55 <shachaf> I don't see any I/O going on there.
21:21:15 <blaenk> forkIO $ atomically $ writeTChan ch sometext
21:21:20 <blaenk> is what follows after let sometext
21:21:59 <shachaf> I still don't see any input or output.
21:22:12 <blaenk> so I shouldn't have any problems in that regard then, cool
21:22:31 <shachaf> I don't know.
21:22:59 <shachaf> getChanContents does lazy IO too, I guess. But of course there's no STM version.
21:24:57 <blaenk> seems like there's no problem, but I don't know if it's something that can sometimes present itself like a race condition
21:25:16 <shachaf> Yes, you'll have to think about how laziness will behave.
21:25:39 <epta> @pl \a -> if a == "" then Nothing else Just a
21:25:40 <lambdabot> ap (flip if' Nothing . ([] ==)) Just
21:25:44 <shachaf> The expression "somesource" will only be evaluated when you use it, which will probably happen in the thread that reads from the TChan
21:34:07 <zRecursive> @wn craft
21:34:10 <lambdabot> *** "craft" wn "WordNet (r) 3.0 (2006)"
21:34:10 <lambdabot> craft
21:34:10 <lambdabot>     n 1: the skilled practice of a practical occupation; "he learned
21:34:10 <lambdabot>          his trade as an apprentice" [syn: {trade}, {craft}]
21:34:10 <lambdabot>     2: a vehicle designed for navigation in or on water or air or
21:34:12 <lambdabot> [11 @more lines]
21:34:33 <joejev> is that a new lambda bot thing?
21:35:06 <shachaf> No. It's very old, but it's not used much since it spams the channel.
21:35:38 <shachaf> zRecursive: You can use @wn in /msg lambdabot. You do it in this channel quite a lot -- could you move it to /msg instead, unless you're specifically trying to show someone else a definition?
21:35:43 <zRecursive> ok
21:36:23 <startling> zRecursive: you could even browse http://wordnet.princeton.edu/ !
21:36:57 <zRecursive> just saw: <<Haskell: The Craft of Functional Programming>>
21:37:27 <joejev> ahh, it's kind of cool. If I am going for raw speed, how slow is unsafeFreeze when compiled with -O and converting using one of the O(c) methods. I have a UArray, and I call unsafeThaw to modify one of the elements by converting to a IOUArray. I know that after the end of the function, it will not be modified, so I am currently just relying on the fact that the IOUArray points to the same array as the immutable one; however, is
21:37:27 <joejev> very bad?
21:38:11 <Cale> "however, i" --> "very bad?"  -- I feel like there might be some missing words here
21:38:33 <joejev> oh, weird, "is this very bad?"
21:39:02 <startling> joejev, irc limits the size of messages and some clients pretend not to know about it.
21:39:08 <Cale> (It's impossible for IRC clients to tell what the appropriate line limit is, so they just guess, and sometimes they're wrong, because IRC is like that)
21:39:35 <joejev> Cale: kk, I will try to break them up myself from now on
21:41:35 <Cale> joejev: Well, it *can* produce confusing results if e.g. you think that the mutable array won't be changed any more, but then some future change to the code results in that happening, and you'll end up with potentially weird results.
21:42:26 <Cale> But if you can somehow encapsulate the entire construction of the mutable array so that nothing else would have access to it and can be careful like that, then it's probably fine.
21:42:58 <lightquake> Cale: rfc2812 says that the maximum command length is 510 characters. then again it says that the maximum name length is 9
21:44:02 <joejev> Cale: the array is an element of a record that is being accessed only in specific functions, also it is an executable not a library so I do not have to worry too much about people using it unsafly. I was only wondering if it would be worth the clarity to add the unsafeFreeze, or if it would be a noticable hinderance to raw speed
21:44:10 <Cale> lightquake: When the server sends the message to other clients, it puts the sender's hostname as it sees it into the message, and that counts against the limit
21:44:22 <lightquake> ah
21:44:27 <Cale> lightquake: and it's not always easy or possible for the client to tell what that name is
21:44:40 <lightquake> right, because you don't get your own messages
21:44:44 <Cale> yeah
21:45:21 <Cale> joejev: The best way to tell if it would is to try it
21:46:39 <joejev> Cale: sounds good.
22:02:04 <L8D> How can I get cryptographically secure random numbers in Haskell?
22:03:16 <c_wraith> http://hackage.haskell.org/package/crypto-random is one common way
22:03:26 <L8D> c_wraith: Thanks
22:04:14 <ion> l8d: http://hackage.haskell.org/packages/ for more
22:04:52 <L8D> ion: don't you mean: http://hackage.haskell.org/packages/#cat:Crypto
22:05:17 <joejev> In the GHC perforamance section on the wiki, it says to view the core output to see how it is being compilied. How does one do this?
22:05:36 <ion> l8d: I linked what i meant to link.
22:08:50 <piezo> gcd with type Nats, worth the pain ?
22:09:34 <piezo> i need to encode rationals, either with my own type system, or with GADTs
22:10:35 <joejev> piezo: can you not use the Ratio typclass?
22:11:26 <piezo> i don't think it can be easily lifted to types
22:12:08 <pqmodn> joejev: ghc -ddump-simpl
22:12:27 <joejev> piezo: what do you mean, it accepts any member of Integral
22:12:32 <joejev> pqmodn: Thank you very much
22:12:55 <pqmodn> joejev: there are several -ddump-XXX and -dsupress-XXX flags which might be worth knowing
22:12:56 <piezo> i need type Rational, like thoses are for Nats : http://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-TypeLits.html
22:13:01 <lightquake> i think piezo means encoding rationals at the *type* level
22:13:45 <piezo> lightquake: yes
22:13:52 <joejev> piezo: ahh, sorry
22:16:14 <piezo> after reflexion, i need to typecheck ASTs from the parser, so runtime type checking
22:17:10 <piezo> or maybe with some Template Haskell tricks it can happen at compile time ?
22:18:15 * hackagebot distributed-process-p2p 0.1.1.2 - Peer-to-peer node discovery for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-p2p-0.1.1.2 (AlexanderBondarenko)
22:20:02 <piezo> never mind, too complicated. my rubber duck already got headaches
22:20:17 <joejev> does (!) do bounds checking for immutable arrays, and if so, is there a function that does not?
22:20:39 <johnw> do you mean Data.Array.!?
22:21:01 <joejev> johnw: yes
22:21:15 <c_wraith> joejev: yes and yes
22:21:39 <c_wraith> joejev: however, the function that doesn't do bounds checking doesn't use the Ix interface - it takes a raw 0-based index
22:22:11 <joejev> c_wraith: that is okay, what function is that? is it in the Data.Array.Unsafe module?
22:23:02 <echo-area> Hello.  I want to learn Haskell, which book do you recommend?  I have background of C, Emacs Lisp, Scheme, and Clojure programming
22:23:11 <ion> @where lyah
22:23:11 <lambdabot> http://www.learnyouahaskell.com/
22:23:20 <shachaf> I recommend _Programming in Haskell_, by Graham Hutton.
22:23:35 <Sgeo> LYAH is popular, but... Scheme and Clojure, you're probably curious about metaprogramming to some extent
22:23:40 <c_wraith> joejev: it's in the mysteriously undocumented Data.Array.Base
22:24:02 <c_wraith> Like, seriously, why does the page that links to 404?
22:25:10 <c_wraith> I think the name of the function is unsafeAt, but it's really hard to check without starting up ghci
22:25:12 <echo-area> Sgeo: Yes that's my concern.  I don't think I know all aspects of FP, but I do know some of them.
22:25:30 <joejev> c_wraith: thank you
22:25:33 <lispy> types enhance FP is wonderous ways
22:25:35 <Sgeo> LYAH is still good
22:25:40 <joejev> c_wraith: this will help a lot
22:25:54 <lispy> echo-area: so, if you're used to Scheme and Clojure, I welcome you to the world of typeful fp!
22:26:19 <echo-area> lispy: Thanks :)
22:26:23 <narxus> Why does "4 `elem` [3,4,5,6] " result to an error?
22:26:34 <Sgeo> :t elem
22:26:36 <lambdabot> Eq a => a -> [a] -> Bool
22:26:37 <piezo> metaprogramming isn't really the strenght of Haskell...
22:26:39 <ion> > 4 `elem` [3,4,5,6]
22:26:41 <lambdabot>  True
22:26:42 <lispy> > 4 `elem` [3,4,5,6]
22:26:42 * piezo wait for typed Template Haskell =)
22:26:43 <lambdabot>  True
22:26:43 <ion> It doesn’t.
22:26:53 <joejev> is there patternmatching in scheme?
22:26:59 <startling> there can be.
22:27:23 <Sgeo> narxus: what's the error? It may be possible that the compiler doesn't have enough information to determine the exact type
22:27:26 <lispy> narxus: the best guesses I have are: a) you have a syntax error near that expression b) the context where you have that can't take a Bool
22:27:43 <narxus> It keeps telling me about -XTemplateHaskell
22:27:58 <c_wraith> are you using ' instead of ` ?
22:27:59 <pqmodn> do you have an extraneous '?
22:28:22 <shachaf> Another reason to always show actual code, and actual error.
22:28:33 <lispy> shachaf: keeping a list now?
22:28:34 <narxus> Do you mean I am suppose to use tilde not a single quote?
22:28:42 <c_wraith> backtick.  tilde is ~
22:28:57 * lispy notes that c_wraith is a faster typist
22:28:59 <narxus> Thanks for correcting me
22:29:24 <c_wraith> anyway, yeah.  infix notation requires backticks, not single-quotes
22:29:32 <narxus> Never knew backticks were possible...
22:29:37 <narxus> Thanks, c_wraith
22:30:02 <jle`> mhm it's right there under the [ESC] key
22:30:10 <jle`> easy to miss, admittedly
22:31:10 <narxus> Indeed, jle'. Me coming from imperative programming was never introduced to backticks in syntax.
22:31:13 <shachaf> narxus: The best lesson is to go to hpaste.org and copy your actual full code and actual full error message so people can look.
22:31:49 <narxus> I'll keep that in mind, shachaf.
22:32:32 <echo-area> My choices were actually Programming in Haskell, Real World Haskell, and Learn You a Haskell.  I think I'd go with the first one.
22:33:19 <narxus> Functional Programming is really challenging.
22:33:41 <narxus> I am starting to have fun learning more of this.
22:33:41 <lispy> s/Functional // :)
22:34:06 <joejev> c_wraith: about that Data.Array.Base module, do you know what the difference between writeArray in the MArray interface and unsafeWrite are?
22:34:25 <echo-area> lispy: It's a little funny to see "lispy" in a Haskell channel :-P
22:34:30 <jle`> narxus: i'm not sure that functional programming is any more challenging than imperative/whatever progrmaming.  it mmight be even less so.  the challenge you feel is probably your deeply ingrained imperative intuition/habits pushing you into trouble
22:34:43 <lispy> echo-area: I moved here from #lisp :)
22:34:58 <piezo> echo-area: LYAH is more about the basics, RWH about pratical applications in the wild
22:35:01 <c_wraith> joejev: same thing.  unsafeWrite uses 0-based indexing, instead of the Ix stuff, and doesn't bounds-check.  You can use it to corrupt memory, so it's actually quite unsafe.
22:35:32 <narxus> jle', I meant learning functional programming is challenging.
22:35:36 <Sgeo> Can the labels concept of Idris's effects package be ported to extensible-effects?
22:36:12 <jle`> narxus: yeah, my same point :) learning fp might be as easy as learning imperative, maybe even easier.
22:36:14 <lispy> Sgeo: that's an interesting question. You might also ask in #idris if youhaven't already
22:36:16 <jle`> learning fp coming from imperative programming, that's hard
22:36:18 <joejev> c_wraith: so is it more directly equatable to something like arr[n] = x?
22:36:25 <c_wraith> joejev: exactly
22:37:00 <joejev> c_wraith: cool
22:37:10 <narxus> Many people from StackOverflow said that FP is beneficial to learn.
22:37:31 <piezo> jle`: right, i've taught basics of FP to CS novices, it was far less a disaster than my Java classes...
22:37:52 <lispy> narxus: Well, I wouldn't be at my current post without having studied FP, so I'm forced to agree :)
22:38:13 <c_wraith> narxus: Haskell goes further than just functional..  It's also pure with type inference and type classes.  Those add many more layers of things to learn.
22:39:04 <narxus> I agree, c_wraith. Learning Haskell is really different than learning Python after C++.
22:39:26 <c_wraith> narxus: it's really rewarding to learn them, but it's a lot to handle at once.
22:39:33 <lispy> What's really amazing about the level of abstraction in Haskell is when you start to think about other languages (like C++) and how their abstractions map into Haskell. And then start to write better code in those languages as a result.
22:39:36 <joejev> I think it is easier to explain FP to people who like math. Higher order functions exist in calculus and other math feilds, people just don't really think of them as such
22:40:14 <narxus> Well... I am not learning them all at once. I only learn them one at a time.
22:41:15 <narxus> But each programming language I learned (Except Java and C#) gave me one each lessons to become used to programming.
22:42:09 <gamegoblin> Package architecture question. I have a module called Matrix which represents some values and some meta data about them. This data is typically stored in a file format called ARFF. Consequently, I have another module that is an ARFF parser. The ARFF parser takes a string in the ARFF format, parses it, and returns a Matrix. So here is the question. I want to make instance Matrix with Read. I want the read function to use the 
22:42:11 <piezo> there all somewhat related, but haskell is a good general start
22:42:20 <narxus> But I think FP will beat imperative since, FP is shorter, faster and easier to read.
22:42:32 <piezo> the biggest step is imperative -> functional
22:43:03 <pqmodn> gamegoblin: your question was truncated at "read functio to use the ..."
22:43:16 <gamegoblin> ahhhhh one second. Stupid IRC.
22:43:17 * hackagebot crypto-pubkey-openssh 0.2.3 - OpenSSH keys decoder/encoder  http://hackage.haskell.org/package/crypto-pubkey-openssh-0.2.3 (FedorGogolev)
22:43:33 <gamegoblin> Package architecture question. I have a module called Matrix which represents some values and some meta data about them. This data is typically stored in a file format called ARFF. Consequently, I have another module that is an ARFF parser. The ARFF parser takes a string in the ARFF format, parses it, and returns a Matrix.
22:43:43 <gamegoblin> So here is the question. I want to make instance Matrix with Read. I want the read function to use the ARFF parser. Is there a better way to do this than make the parser and the matrix modules recursively inherit or...?
22:44:26 <joejev> c_wraith: switching writeArray to unsafeWrite moved me from .43 to .42 seconds consistently, thanks for the input, now I will try unsafeAt
22:45:50 <pavonia> gamegoblin: You could define an extra module for the orphan Read instance
22:46:06 <gamegoblin> pavonia: Can you elaborate on that?
22:46:40 <pavonia> you create a third module that imports both other modules and only defines the Read instance
22:47:34 <c_wraith> joejev: look into using the Criterion library for accurate benchmarking, by the way.
22:48:28 <piezo> joejev: if you do random writes you may want MArray
22:49:39 <c_wraith> piezo: he's using MArray anyway.
22:49:42 <pavonia> gamegoblin: An instance that isn't defined in the module the data type or the class is defined is called an orphan instance. This is generally not a good thing, but if it is in an extra module and well documented, it's not that bad, I guess
22:49:49 <joejev> piezo: I use thaw to convert before writing, unsafeWrite takes an MArray anyways
22:50:09 <piezo> oh right, sorry
22:50:20 <joejev> c_wraith: are the GHC profiling tools not good?
22:50:21 <gamegoblin> pavonia: Is there a better way of doing what I want?
22:50:52 <c_wraith> joejev: they're accurate, they just don't do statistical analysis across multiple trials...  which criterion does
22:51:27 <joejev> also, the changes with unsafeAt and unsafeWrite cut down on the allocations, probably due to the typechecking which is already accounted for elsewhere by me
22:52:15 <pavonia> gamegoblin: perhaps, but that's the best I can think of
22:52:48 <pavonia> gamegoblin: if you don't whant to have only a single module, that is
22:53:17 <joejev> c_wraith: so how does one use this, would I write another benchmarking program that uses this package, or does it come with some binary?
22:54:15 <c_wraith> joejev: you write a small program that uses it, usually via Criterion.Main
22:54:43 <c_wraith> joejev: main = defaultMain benchmarks, etc
22:55:35 <c_wraith> joejev: it's actually pretty straightforward, just follow the types of the combinators exposed in Criterion.Main
22:56:57 <joejev> c_wraith: thanks, so I assume that defaultMain will just print to stdout and I can redirect this into a file to go over?
22:57:05 <c_wraith> joejev: yep
22:57:51 <joejev> c_wraith: does this use the same GHC benchmarking tools and expand on them, or is it completely different?
22:58:10 <c_wraith> joejev: it's completely different.
22:58:18 * hackagebot mongoDB 1.4.2 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  http://hackage.haskell.org/package/mongoDB-1.4.2 (FedorGogolev)
22:58:45 <joejev> c_wraith: would it be worthwhile to use both, or in your oppinion, does this do a better job?
22:59:58 <c_wraith> joejev: they have different uses. the GHC tools are good for profiling when looking for hot spots. criterion is better for comparing alternate implementations
23:01:23 <joejev> c_wraith: ahh. looking at the docs, it shows this running only one function to be benchmarked. Is it okay to use main as that function? I know it accepts IO a, but is this really the intended purpose?
23:01:55 <c_wraith> joejev: it's usually intended more for microbenchmarks, but you could do something like that.
23:02:20 <joejev> c_wraith: thank you for the help, this looks like a great tool.
23:03:43 <pqmodn> joejev: i found this overview helpful http://lambda.jstolarek.com/2012/10/code-benchmarking-in-haskell/
23:09:15 <joejev> pqmodn: very interesting, reading up on this now.
23:14:05 <narxus> Are variables in imperative called bindings in functional programming?
23:14:54 <shachaf> Variables in Haskell are called variables.
23:15:01 <pqmodn> they're usually still refered to as "variables", even if the identifiers cannot be rebound later
23:15:30 <narxus> I see... Then what are bindings?
23:15:47 <joejev> when you attach a name to something
23:16:17 <narxus> Can you give me an example, joejev?
23:16:49 <joejev> myString = "This is a string bound to the name myString"
23:17:10 <narxus> So... "myString" is a binding?
23:17:25 <joejev> yes
23:17:57 <pqmodn> i'm not sure i agree with that, myString is *bound*, but the binding probably includes both the name and the value that's bound to it
23:18:29 <hamid> joejev, i always thought of those as functions without arguments
23:18:34 <joejev> pqmodn: yes, I guess I meant the act of attaching that string to that name is the binding, that name is bound to that string
23:18:38 <shachaf> joejev: No.
23:18:51 <narxus> I thought it was a process of naming a variable
23:19:01 <pqmodn> it can be used as a verb or noun
23:19:21 <narxus> like: let myString = "String bound to myString"
23:19:39 <joejev> c_wraith: about the criterion thing, is there a way to pass command line args to the functions, or will getArgs grab them anyways?
23:20:13 <joejev> c_wraith: because it appears that the criteron default main has its own set of args
23:21:21 <pqmodn> joejev: you might see if you can use -- to indicate the remaining command-line args should be ignored by defaultMain. just a guess, but it's common with command line tools (eg ls -- -my-hyphenated-file-name.txt)
23:21:50 <c_wraith> This is the microbenchmark-oriented design showing up
23:22:55 <joejev> TT, I will just change the functions to manually take the args I would pass as a string list and assume that because I am changing them both, it will be the same, and that there is no way to optimize the aquiring of the args
23:23:27 <pqmodn> joejev: not a suggestion, but you could wrap defaultMain with your own function and then call defaultMain using withArgs
23:24:30 <narxus> Is it possible to create a haskell program with GUI?
23:24:37 <joejev> pqmodn: thanks
23:25:23 <zRecursive> narxus: why not ?
23:25:25 <pqmodn> narxus: there are several packages that provide bindings to GUI toolkits
23:25:49 <narxus> Are those packages built in haskell, pqmodn?
23:26:23 <joejev> you can aquire packages with the tool cabal that comes with the haskell platform
23:27:01 <pqmodn> narxus: i'm not sure i understand the question, but most would be written with a combination of Haskell and C
23:27:27 <pqmodn> narxus: they provide bindings so *you* can write Haskell code to construct the GUI
23:27:44 <jle`> do you want to write haskell code with a GUI? kind of like labview?
23:27:55 <jle`> i think Peaker has a project on that
23:27:56 <narxus> Someday
23:28:19 <narxus> Like building a calculator with GUI
23:28:31 <jle`> oh, building an application with a GUI on Haskell
23:28:40 <jle`> yes it's very possible, there are a lot of Haskell GUI apps
23:28:48 <jle`> and games as well
23:29:00 <jle`> what was that book ... Haskell School of Expression
23:29:06 <jle`> that had a lot of good stuff on this subject
23:29:17 <zRecursive> There should be haskell wrappers for Gtk and Qt
23:29:20 <jle`> it's a little dated but most of the principles it teaches are still relevant
23:29:45 <jle`> also ocharles's hackage series has two gui libraries so far?
23:29:48 <narxus> That's good to know.
23:30:16 <jle`> http://ocharles.org.uk/blog/posts/2013-12-07-24-days-of-hackage-threepenny-gui.html
23:30:35 <jle`> http://ocharles.org.uk/blog/posts/2013-12-10-24-days-of-hackage-gloss.html
23:30:56 <jle`> Haskell is pretty good for GUI's, you just need to approach them differently than in imperative progrmaming
23:31:14 <narxus> Maybe I'll tackle that once I have sufficient Haskell knowledge.
23:31:17 <mzero> @pl \c -> '0'
23:31:17 <lambdabot> const '0'
23:31:38 <mzero> hmmm... on my installed pointfree, I get    const 0
23:31:44 <mzero> !
23:31:49 <narxus> Haskell really meant what they said about shorter code.
23:32:08 <zRecursive> :t const
23:32:10 <lambdabot> a -> b -> a
23:32:16 <pqmodn> mzero: not '0', but 0?
23:32:23 <mzero> exactly!!!!
23:32:24 <dv-> it's good for toy programs
23:32:25 <narxus> I was able to create a single function in a single line
23:32:44 <pqmodn> mzero: i've heard many people complain pointfree is horribly broken, and that lambdabot isn't using the same version that's on Hackage
23:33:02 <mzero> I think it is a pretty printing bug in @pl:   I also get    :pl \c -> 'r'      gives   const r
23:33:10 <pqmodn> heh
23:33:14 <shachaf> mzero: Which version is your installed pointfree?
23:33:26 <mzero> no idea!
23:33:42 <shachaf> Oh, I guess it doesn't have a --version flag.
23:34:00 <mzero> I know, right!
23:34:01 <pqmodn> can you tell from looking in ~/.ghc/ ?
23:34:01 <shachaf> Anyway, it works for me. Maybe try upgrading?
23:34:27 <mzero> pointfree-1.0.4.5
23:34:47 <shachaf> Checked the cabal package cache?
23:34:49 <joejev> c_wraith: wow, those reports are pretty good looking, also, I I am suprised that it ran much faster while profiling, is getArgs really that slow?
23:34:58 <shachaf> shachaf@carbon:~$ ls .cabal/packages/hackage.haskell.org/pointfree/
23:34:58 <shachaf> 1.0.3  1.0.4.3  1.0.4.5
23:35:23 <zRecursive> There is ghci, why do you use lambdabot locally ?
23:35:54 <rose> Can I use nested guards? I get a type error on this http://lpaste.net/97246
23:36:10 <c_wraith> joejev: actually, anything related to String processing can be pretty slow.  Not surpring that getArgs and processing them is slow
23:36:28 <narxus> Does Haskell have docstrings?
23:36:39 <quchen> rose: That's a syntax error.
23:36:56 <rose> quchen: what's an alternative?
23:36:57 <shachaf> rose: No.
23:36:58 <joejev> rose: idk if that works, but can't you do case () of _ | func1 | func2 .. | funcN
23:36:59 <quchen> And no, there are no nested guards. You can use && and friends though.
23:37:03 <mzero> narxus: Haskell has Haddock comments
23:37:18 <rose> thanks
23:37:33 <triliyn> rose: most of your guards seem like they could be easily converted to pattern matches too
23:37:42 <shachaf> You can even use "if | ... = ... | ... = ..." in GHC 7.6.
23:38:06 <joejev> shachaf: dont you need to use the MultiWayif pragma?
23:38:21 <narxus> Thanks mzero
23:38:22 <shachaf> Yes.
23:38:40 <quchen> rose: Also I see you're using head/tail a lot in your code. Try refactoring it to use pattern matching instead; head/tail crash when applied to empty lists. In fact there are only very few places in which head/tail are a good idea.
23:38:50 <joejev> c_wraith: I might use the getArgs as bytestring function to avoid the unicode processing.
23:39:01 <rose> quchen: thank you!
23:39:21 <shachaf> It's true.
23:39:37 <shachaf> In fact booleans are quite often a sign of something wrong.
23:39:47 <shachaf> ...OK, not that often. But avoiding booleans whenever you can is a good idea.
23:40:10 * shachaf imagines uncons :: [a] -> (Bool,a,[a])
23:40:17 <jle`> rose: you shouldn't ever need to use == [] as a guard
23:40:21 <zRecursive> :t getArgs
23:40:21 <jle`> you can pattern match on it
23:40:22 <lambdabot> Not in scope: `getArgs'
23:40:31 <shachaf> I guess that's just (&&&&) null head tail
23:40:43 <quchen> Oh my.
23:41:41 <mzero> narxus: you can look at https://bitbucket.org/mtnviewmark/haskell-playground/src/789e66e13736f5f5ad6ca09cceef7d20d4c7beca/Acme/Acme/Inator.hs?at=default for an example
23:41:46 <joelteon> Is there a version of happy you can install without having happy?
23:41:50 <jle`> rose: instead of foo n | n == [] = blah, you can just do foo [] = blah
23:42:17 <mzero> narxus: it generates http://hackage.haskell.org/package/acme-inator-0.1.0.0/docs/Acme-Inator.html
23:42:27 <lispy> joelteon: hmm? I don't think happy requires happy.
23:42:33 <mzero> oh, better link for the source: http://hackage.haskell.org/package/acme-inator-0.1.0.0/docs/src/Acme-Inator.html
23:42:57 <lispy> joelteon: https://github.com/simonmar/happy/blob/master/happy.cabal
23:43:05 <mzero> joelteon: are you running into the happy/alex cyclic depedence?
23:43:24 <joelteon> is that what this is?
23:43:34 <joelteon> if I try to configure happy, it says it needs the program happy but it could not be found
23:43:49 <pqmodn> trying not to laugh
23:44:21 <joejev> is pattern matching slow?
23:44:23 <DigitalKiwi> computer is sad :<
23:44:31 <quchen> joejev: No.
23:44:41 <joelteon> wow, that's ridiculous
23:44:43 <narxus> mzero: LOL Dr. Heinz Doofenschmirtz
23:44:45 <joelteon> happy complains about happy, but what it wants is alex
23:44:50 <mzero> :-)
23:45:10 <joelteon> someone should maybe clarify that
23:46:25 <mzero> joelteon: now- the source balls for happy and alex come, if I recall, bootstrap files, so you can get one going without the other
23:47:31 <joelteon> yeah, I got it resolved now
23:47:50 <joelteon> I installed alex, and now happy doesn't need happy anymore
23:47:50 <joelteon> what a strange error message
23:53:34 <mzero> joelteon: I suspect the problem was that happy needed alex, and to build alex, alex needed happy... hence the error was needing happy
23:54:36 <joelteon> well, ok
23:58:23 * hackagebot HSlippyMap 1.4 - OpenStreetMap Slippy Map  http://hackage.haskell.org/package/HSlippyMap-1.4 (j4pe)
23:59:35 <gamegoblin> pavonia: with the whole orphan module thing, does the module need to be exposed, I assume?
