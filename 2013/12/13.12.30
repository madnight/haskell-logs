00:00:19 <SrPx> http://o7.no/1kUPDrA this is a picture of the editor as it was in the last version if you guys are curious, this was a small copy of the sprite lamp that figured on kickstarter those days
00:00:28 <haasn> mm_freak: as much as the program structure is lost when going from Haskell to assembly (LC to SK)
00:00:46 <mm_freak> haasn: and this is not just a theoretical view…  SK is an actual way to compile functional programs…  you compile from the FP language to its core language, then to SK, then to a machine code graph-reducer
00:01:01 <SrPx> below is the compiled code which I killed myself to produce like that. now I changed the language specs and have to do it all again, I'm really tired. all I wanted was a target language that could do the hard lifting for me :(
00:01:12 <mm_freak> haasn: going from assembly to haskell can preserve the program structure
00:01:18 <roboguy_> SrPx: is there much of a practical difference between this and something like Scheme?
00:01:29 <haasn> mm_freak: oh, I'm interested in that; how feasible is GHC decompilation?
00:02:01 <mm_freak> haasn: it's probably quite feasible to get close to the original core
00:02:14 <SrPx> roboguy_: no, it is just scheme. In the beginning I was just looking for a Scheme->JS compiler. But there is no satisfactory compiler for it. Ends up Scheme has too many things, as surprising as it is, so the compilation isn't straighforward.
00:02:15 <mm_freak> but going back to full haskell i don't see as very feasible
00:02:49 <xintron> any static site generator to recommend (know of hakyll)? Thought I might as well switch my current setup while learning more haskell :)
00:02:52 <mm_freak> haasn: also optimization makes decompilation a lot more difficult
00:02:55 <roboguy_> SrPx: ok, this is making more sense. Scheme isn't *just* untyped lambda calculus
00:03:07 <haasn> mm_freak: makes sense, I imagine much more so if you go through LLVM instead of the NCG
00:03:08 <mm_freak> xintron: hakyll is quite great
00:03:09 <SrPx> But Scheme is just LC with some things, isn't it? So I thought, I can still have the same productivity of Scheme with LC + arrays + numbers. But there is no such a language. You know? That is why I had to do it kinda by myself, but iI'm not a language designer. I don't know those stuff
00:03:55 <xintron> mm_freak, yeah, and with pandoc it should cover all needs :)
00:04:07 <Cale> SrPx: Scheme is a hell of a lot more than untyped lambda calculus
00:04:09 <haasn> How much does GHC reorder instructions and swap loops and other low level optimizations that completely mangle the logical aspects of it in exchange for hardware speed?
00:04:13 <SrPx> roboguy_: yes, exactly. But most of its productivity come from ULC. Some things such as Macro do *not* need to be part of the language, I've realized the editor can cover that, for example. And many other things that are part of R5RS aren't **really** needed.
00:04:18 <mm_freak> xintron: which is builtin =)
00:04:44 <xintron> mm_freak, Do you happen to know what syntax highlighting system their using (haven't found anything about this)? Or is that pandoc as well?
00:04:56 <mm_freak> xintron: it's pandoc
00:04:58 <SrPx> Also I'm kind of upset with how Scheme treats lists. There is a list type and a vector type, but semantically they work the same. I don't think that is necessary, really. We could have just a vector type that is a Dynamic array, like Python, and kill lists entirely.
00:05:03 <mm_freak> xintron: so highlighting-kate
00:05:08 <SrPx> That is part of why Scheme isn't so fast, too.
00:05:09 <xintron> mm_freak, Mainly wondering if css highlighting for pygments would work without any additions
00:05:25 <SrPx> Cale: exactly, that is the problem!
00:05:36 <roboguy_> SrPx: lists generally mesh better with functional style programming which is why they are used pretty often
00:05:38 <mm_freak> xintron: it only generates the markup…  you then choose your colors in your stylesheet
00:05:44 <Cale> SrPx: Scheme programs actually do things when you run them.
00:06:19 <SrPx> roboguy_: I know, but most of the times you could just use dynamic arrays and consider it an implementation detail. It has been show that they almost aways are superior, even when you're constantly appending etc
00:07:14 <mm_freak> SrPx: you're in the wrong channel to discuss this…  #haskell likes type-driven algebraic stuff
00:07:17 <roboguy_> SrPx: I think I would need to see some practical examples to believe that. The ability easily add to a list without changing it and make a new list in constant time is often extremely important in pure programming
00:07:32 <mm_freak> SrPx: also i have a feeling you're just trolling
00:07:45 <SrPx> oh I know, sorry. types are awesome too, and so is haskell
00:07:49 <haasn> mm_freak: that's actually a cute description of Haskell-style programming, type-driven algebraic programming :)
00:08:09 <haasn> let's abort the “functional” label
00:08:34 <zomg> how about just calling it True Programming
00:08:39 <zomg> to annoy everyone else
00:08:46 <haasn> but everybody knows that's lisp
00:08:54 <dv-> true programming, main = True
00:09:07 <SrPx> you are offending me. I'm just kindly answering your questions. if you consider such trolling, I'm positive the problem is on you, not me. said that, if that is the impression I'm causing there is no reason to continue with that
00:09:10 <yogurt_truck> lisp does annoy everyone else but lispers
00:09:14 <SrPx> my apologies, I'll be back to my work now
00:09:17 <haasn> true.hs: main = exitSuccess
00:10:03 <zomg> lol if that was supposed to sound like he wasn't trolling it did nothing but make it sound even more like a troll
00:10:26 <zomg> that was such a standard troll response
00:10:59 <haasn> (maybe because it's so often used by people that aren't actually trolling that you've come to consider it as a classical sign of trolling, too? :P)
00:12:10 <zomg> haasn: not really :P
00:12:24 <zomg> it's always just the same pattern with people who are actually trolling
00:12:37 <mm_freak> SrPx: it's a feeling…  i may be wrong, but i don't understand how you can be productive with pure LC…  no bindings, no predefined types, everything is slow
00:12:41 <zomg> I didn't actually follow the original discussion which lead to the accusation but that certainly sounded like it fit in with the usual patterns
00:13:46 <mm_freak> although for bindings there is a somewhat poor substitute:  (let stuff = x in y) = (\stuff -> y) x
00:14:33 <mm_freak> then no recursion, so you have to use Y all the time, and you actually have to define it:  (\y -> …) …
00:14:45 <SrPx> mm_freak: I don't agree but I won't be talking about this anymore. zomg: please read what you said and learn to behave yourself on IRC
00:15:10 <mm_freak> alright
00:15:23 <zomg> SrPx: yeah that comment certainly helps... :D
00:15:52 <Cale> I'm beginning to think that SrPx doesn't actually know what untyped lambda calculus precisely is, and has it confused with some scheme-like language.
00:16:07 <Cale> (and that's being generous)
00:16:13 <zomg> SrPx: if you're trying to sound like you're not trolling you're not doing a very good job =)
00:17:44 <SrPx> zomg: you are offending a stranger (which is not good already) for "looking like a troll" regardless of admitedly not having enough information to judge that.
00:18:29 <zomg> SrPx: I didn't actually say anything but that it sounded like a standard troll response and I even specifically said that I didn't follow the conversation, and that it just fits the typical pattern
00:19:15 <zomg> SrPx: then trying to make it look like I'm the person behaving poorly definitely also fits the usual pattern of misdirection
00:19:23 <yogurt_truck> if offending a stranger is a bad thing, then we're all doomed
00:19:51 <SrPx> Cale: if you guys want to talk about that you're welcome to join #lets_not_spam_haskell , alright ?
00:20:23 <Fylwind> it would've been nice if Seq had a Hashable instance
00:21:09 <haasn> Fylwind: I think you'd need to go through [a] or some other abstraction that doesn't replace the internal structure, or equal (in the Eq sense) Seqs would not hash to the same value
00:21:15 <haasn> So you might as well use hash . toList
00:21:23 <haasn> s/replace/preserve/
00:22:50 <Cale> However, you might be able to do something cute with FingerTree if you had a monoidal hash function.
00:22:53 <Fylwind> yea but it kinda ruins the syntactic elegance :3
00:23:01 <Fylwind> Cale: what?
00:23:15 <Cale> (i.e. build hashing in directly)
00:23:36 <Fylwind> that sounds complicated :p
00:24:09 <haasn> Cale: you mean like a HashSeq type that carries hashes around with segments?
00:24:09 <Cale> I also don't know how to implement a good monoidal hash
00:24:13 <Cale> yes
00:24:53 <Fylwind> associative but not commutative hrmm ...
00:25:40 <haasn> there's nothing that says a monoid can't be commutative
00:26:10 <Fylwind> well for a hash function, you'd want [1,2] to be distinct from [2,1] most of the time
00:26:32 <haasn> oh, of course
00:27:22 <SrPx> you're accusing me of trolling but nobody joined the damn private channel!
00:27:22 <smith_> After wiping out all of my packages and reinstalling, I can use aeson's FromJSON instance for Map now, but not for Data.Text anymore.
00:27:41 <Fylwind> i wrote something like that for HashMap but that was easy since 'xor' worked well for unordered data; i can't think of an equivalent for ordered data like Seq though!
00:27:49 <smith_> The example from the docs page doesn't even work: http://lpaste.net/97731
00:28:20 <dibblego> is there a generalisation of Data.Map?
00:28:35 <haasn> dibblego: generalization in which direction?
00:29:08 <mm_freak> SrPx: in other words, nobody is interested…  feel free to come back with results
00:29:10 <dibblego> class M k v where insert :: k -> v -> M k v -> M k v; get :: k -> M k v -> Maybe v -- how about something like this?
00:29:47 <smith_> For some reason, it can't find the (FromJSON Text) instance defined in Data.Aeson.Types.Class... Is it because of some version mismatch?
00:30:05 <smith_> aeson is at 0.6.2.1 and text is at 1.0.0.0.
00:30:06 <Fylwind> dibblego: you can't get rid of the instance requirement (either Ord or Hashable) for a practical perspective
00:30:08 * SrPx shrugs
00:30:13 <supki_> dibblego: does Control.Lens.At count?
00:30:17 <dibblego> well yeah put that on too
00:30:23 <haasn> dibblego: how about :: k -> Maybe v -> M k v  and :: k -> M k v -> Maybe v ?
00:30:40 <haasn> because if so, my answer is the same as supki_'s :)
00:30:45 <Fylwind> the instance requirement makes things a lot uglier though :(
00:30:56 <dibblego> why I believe that is excellent, thanks
00:31:09 <SrPx> it is interesting because if I don't say why I want something I'm wrong, if I carefully explain the use case I'm a troll because I'm talking too much, and in the end nobody helped me with what I need. :(
00:32:27 <mm_freak> SrPx: at least two people suggested you look at STG compilation
00:32:31 <mm_freak> me included
00:32:56 <haasn> :t (at ?~)
00:32:57 <lambdabot>     Couldn't match type `m0 -> f0 m0' with `Mutator t0'
00:32:57 <lambdabot>     Expected type: ASetter
00:32:57 <lambdabot>                      (p0 (Maybe (IxValue m0)) (f0 (Maybe (IxValue m0))))
00:33:24 <haasn> oh
00:33:33 <haasn> :t \k -> (at k ?~)
00:33:34 <lambdabot> At t => Index t -> IxValue t -> t -> t
00:33:50 <haasn> :t view . at
00:33:51 <lambdabot> (MonadReader s m, At s) => Index s -> m (Maybe (IxValue s))
00:34:05 <haasn> those are your two functions, in terms of ‘at’
00:34:15 <Guest2683> class Foobar z where foobar :: w -> z  ?? class (Foo x, Bar y) => Foobar z where foobar :: (x || y) -> z ???
00:34:46 <Cale> SrPx: Everyone you're attempting to troll here already knows what the untyped lambda calculus is, and so they know in particular that it isn't a practical programming language on its own, seeing as it doesn't specify any kind of semantics for what programs written in it are meant to *do*. All you have are terms consisting of variables, applications and abstractions. You can reduce some term to get another term, and tha
00:34:46 <Cale> t's it.
00:36:51 <Guest2683> is it possible to refine a class method with "or" overloading?
00:37:06 <Guest2683> class Foobar z where foobar :: w -> z
00:37:11 <Guest2683> class (Foo x, Bar y) => Foobar z where foobar :: (x || y) -> z
00:37:25 <Cale> Guest2683: I'm not quite sure what you're after
00:37:40 <Cale> Guest2683: We don't have union types
00:37:46 <Cale> But there is Either
00:38:51 <SrPx> Cale: honestly, I don't agree with that, but I won't argument with you here, nor until you stop the unecessary word-calling.
00:39:12 <SrPx> mm_freak: that is true, and a great suggestion.
00:39:41 <SrPx> mm_freak: thanks, I'll be looking for it further. If anyone knows something similar, except for strict semantics, I'd be pleased to know.
00:39:44 <Cale> SrPx: If you disagree with that, then you must have some definition of "untyped lambda calculus" which the rest of the world doesn't subscribe to.
00:40:01 <Cale> SrPx: In which case, I would recommend a name change, because you're going to make people think you're trolling.
00:40:56 <Cale> SrPx: right?
00:41:15 <Cale> Guest2683: Perhaps if you provided some information about the program that you're trying to write?
00:41:26 <roboguy_> Guest2683: maybe making two instances of the class would work? I'm not totally sure what you mean though
00:41:38 <mm_freak> SrPx: also Cale is right…  you're describing a programming language based on LC, not LC itself
00:41:46 <mm_freak> you can't "program" in LC
00:42:06 <SrPx> No, Cale, you can interact with a side-effecting world with pure functions. You can make perfectly useful programs using lambda calculus alone, for example, by writing a function that receives a world state and updates it.
00:42:23 <mm_freak> SrPx: what Cale is arguing about has nothing to do with purity
00:42:39 <Cale> SrPx: Everyone knows this, but lambda calculus on its own has no notion of such things, and adding those things makes it a different language.
00:42:42 <mm_freak> we know very well that you can interact with the outside world from a pure language
00:42:58 <mm_freak> after all we do that in haskell =)
00:43:02 <SrPx> As you can see, I provided a screenshot of a useful program (that has received a huge funding in kickstarter) programmed in lambda calculus alone. So I seriously don't understand what is your reasoning to attacking me or trying to debate that. It isn't even my question.
00:43:20 <Cale> and there are about a million design choices which you'll make in specifying how that interaction occurs
00:43:28 <SrPx> Cale: can we please not debate this? If you want to think I don't know what lambda calculus is you're welcome to think so without bothering me and the channel.
00:43:53 <Cale> So it's extremely unhelpful to call your language "untyped lambda calculus" if it actually includes a system for I/O and interaction with the rest of the world.
00:44:40 <Cale> If you're going to do that, you might as well rename Javascript to untyped lambda calculus
00:44:58 <zomg> lol
00:45:25 <zomg> this reminds me of the discussion about FRP not a long time ago
00:45:55 <zomg> "x is FRP" "no x is not FRP" "but y makes x FRP" "y + FRP is something different than FRP"
00:46:32 <Cale> zomg: At least in the case of FRP, there is no well defined definition of what FRP is.
00:46:39 <smith_> Ah! Got it... Having text-1.0.0.0 installed was what broke aeson, which loaded 0.11.2.0 while my code loaded 1.0.0.0.
00:46:42 <mm_freak> Cale: actually there is
00:46:46 <Cale> It's simply a loosely bundled direction of research
00:47:06 <mm_freak> Cale: conal's original paper "Functional Reactive Animation" gives a precise definition
00:47:10 <Cale> There are some definitions you could imagine writing down, but there is no single widely-accepted one.
00:47:46 <Cale> When you write down a definition like that, you're committing yourself to design decisions already.
00:48:10 <Cale> and I don't think any one definition will cover all the stuff which people have called FRP cleanly
00:48:44 <mm_freak> Cale: there has been an original formulation…  people just made their own later on
00:48:58 <mm_freak> that's why there are so many things calling themselves "FRP"
00:49:03 <Guest2683> Cale: roboguy: The question is more about union overloading. In the first example, we have a very weak statement: foobar will map anything to type z (there are no constraints on w). In the second example, we allow for any Foo x or Bar y to be mapped to z. Is the seconds example possible? If so, what is the syntax?
00:49:07 <SrPx> mm_freak: OK, suppose you write a function in Lambda Calculus that receive a state: a world, and an inbox of messages, including keyboard outputs received on the last tick. That function takes note of the messages and return an updated world.
00:49:44 <mm_freak> SrPx: how would multithreading work?
00:50:09 <SrPx> mm_freak: on that function, you program a game. Then, in another (impure) language, you just feed that function the proper inputs and refresh a screen accordingly to how it modifies the world. Can't you say you programmed the game on that (pure) language?
00:50:32 <mm_freak> SrPx: sure
00:50:36 <jtcwang> is there a good resource on foldr/foldl with infinite lists?
00:50:53 <Cale> jtcwang: foldr works, foldl doesn't
00:50:56 <mm_freak> jtcwang: for foldl there is one:  don't do it =)
00:50:58 <Cale> @src foldl
00:50:58 <lambdabot> foldl f z []     = z
00:50:58 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
00:51:16 <Cale> foldl does nothing but apply itself to new arguments until it reaches the end of the lsit
00:51:17 <Cale> list*
00:51:20 <Cale> @src foldr
00:51:20 <lambdabot> foldr f z []     = z
00:51:21 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
00:51:41 <SrPx> mm_freak: so how can you not say you programmed that game in Lambda Calculus?
00:51:49 <Cale> foldr passes control to f, applying it to the first element of the list, and a recursive call to foldr. If f examines its second argument, the foldr will continue
00:51:52 <mm_freak> SrPx: because that language isn't lambda calculus
00:51:59 <dibblego> jtcwang: http://blog.tmorris.net/posts/2013-04-24-list-folds-bfpg.html might help
00:52:20 <jtcwang> i know i'm wrong here, but i thought foldr folds from the last element of a list
00:52:32 <jtcwang> then how does that work with infinite lists?
00:52:32 <Cale> SrPx: Which lambda terms are you encoding keystrokes with? Big Church numerals?
00:52:34 <mm_freak> jtcwang: it doesn't
00:52:38 <SrPx> mm_freak: what language exactly? There are two languages involved. Pure lambda calculus, which holds all the logic of the game. And another one, which just calls the function (that you created in LC) repeatedly and updates the screen...
00:52:43 <mm_freak> jtcwang: both folds fold left-to-right
00:52:44 <Cale> jtcwang: They both start at the beginning
00:52:57 <jtcwang> dammit haha
00:53:01 <Cale> (you have no choice but to start processing a list at the beginning)
00:53:03 <mm_freak> or top-to-bottom or outermost-to-innermost…  whatever you want to call it =)
00:53:26 <Cale> The difference is in the association of the expression that's produced
00:53:42 <mm_freak> SrPx: the former is not pure lambda calculus…  it's lambda calculus with additionally defined fixed semantics
00:53:50 <jtcwang> what does z (the seed) do in foldr?
00:53:51 <SrPx> Cale: for the sake of debate, suppose I am?
00:53:55 <Cale> foldr (*) 1 [a,b,c,d,e] will give a * (b * (c * (d * (e * 1))))
00:54:07 <mm_freak> jtcwang: it's the folded value of the empty list
00:54:16 <Cale> foldl (*) 1 [a,b,c,d,e] will give ((((1 * a) * b) * c) * d) * e
00:54:23 <Guest2683> Cale: roboguy: creating two seperate instances would do the trick, but I would prefer some type of union overloading if it exists.
00:54:35 <roboguy_> Guest2683: it does not
00:54:44 <roboguy_> I'm pretty sure
00:55:18 <Cale> jtcwang: You can think of foldr f z as replacing each (:) in the construction of the list with f, and the [] at the end with z
00:55:19 <Fylwind> so apparently Tillich-Zemor hash is nontrivial associative
00:55:29 <SrPx> mm_freak: so it is not lambda calculus anymore because you're coding functions in a way that respect pre-determined encodings? So if you programmed the same thing in Python it would not be Python?
00:56:03 <Fylwind> heavy emphasis on the nontrival part though ... :\
00:56:05 <jtcwang> right
00:56:09 <Cale> Fylwind: interesting!
00:56:27 <mm_freak> SrPx: "lambda calculus" relates to a programming language like "monoid" relates to integers with addition
00:56:36 <Cale> jtcwang: Here are some diagrams to illustrate: http://cale.yi.org/share/Folds.png
00:56:49 <mm_freak> SrPx: right now you say "monoid", but you really mean "integers with addition"
00:56:51 <roboguy_> SrPx: this is more like calling C assembly language because it is sort of assembly language with some extra stuff
00:57:34 <Cale> jtcwang: But to understand them operationally...
00:57:39 <mm_freak> SrPx: one is a model, the other one is a specific instance with defined semantics
00:57:49 <jtcwang> Cale, oh goodie
00:58:11 <SrPx> ...? Seriously? The source code of the game is entirely in binary lambda calculus. If you run it repeatedly from the terminal you will see the game running. But suddenly it is not lambda calculus? I don't get it at all...
00:58:25 <SrPx> but this is just a matter of definitions anyway
00:58:36 <roboguy_> Cale: huh, I've seen the foldl and foldr pictures before but not the others. those are cool diagrams
00:58:38 <jtcwang> ok, for my use case, I have a long list of Results
00:58:40 <Cale> foldr f z [1,2,3,4,5] -> f 1 (foldr f z [2,3,4,5]) -> ... we'd really expand the definition of f here ... -> f 1 (f 2 (foldr f z [3,4,5])) -> ...
00:58:55 <jtcwang> i'm trying to print them out using some sort of IO foldr
00:59:10 <mm_freak> SrPx: if you ignore an issue simply because it's a matter of definitions, you contribute to worldwide misconceptions and communication failures
00:59:11 <jtcwang> or should i use foldl?
00:59:14 <Feuerbach> Cale: what did you use to create those pictures?
00:59:15 <Cale> foldl f z [1,2,3,4,5] -> foldl f (f z 1) [2,3,4,5] -> foldl f (f (f z 1) 2) [3,4,5] -> ...
00:59:17 <roboguy_> SrPx: but it's ultimately in machine language, so that means you're really just programming in machine language right?
00:59:20 <Feuerbach> they look very nice
00:59:22 <Cale> Feuerbach: inkscape
00:59:39 <Cale> (I drew them by hand)
00:59:55 <jtcwang> actually, I think the one i'm looking for is mapIO
01:00:08 <jtcwang> so i define a printing function
01:00:09 <Cale> jtcwang: mapM
01:00:10 <SrPx> roboguy_: hm no, because you're not writing machine language? If you are writing lambda calculus then you're programming in lambda calculus, well!
01:00:13 <Cale> mapM print results
01:00:26 <jtcwang> Cale, right
01:00:59 <jrw> SrPx: what representation of "the world" would you use in your lambda calculus program?
01:01:22 <roboguy_> SrPx: okay, then you aren't writing lambda calculus because, by definition, all lambda calculus is is lambda abstractions together with beta reduction, alpha conversion and eta conversion. you are using things that are not any of those
01:01:31 <Cale> jrw: Well, it would have to be some giant lambda term.
01:01:46 <SrPx> roboguy_: but I am using exactly those...
01:01:54 <Fylwind> Cale: did you intend to allow directory access on your server? :3
01:01:56 <jtcwang> Cale, thanks for helping me out
01:01:58 <roboguy_> SrPx: you are using other things too
01:02:03 <SrPx> roboguy_: for example?
01:02:09 <jrw> Cale: right, but I wasn't convinced that's what they were thinking...
01:02:20 <Cale> Fylwind: to the stuff in that directory
01:02:41 <SrPx> jrw: a church list with church numbers encoding the data
01:03:13 <Cale> Fylwind: (However, let me know if you're going to grab anything large)
01:03:56 <SrPx> roboguy_: it doesn't even have that much as it is BLC, so no variables nor alpha conversion, just bruijn indices thanks to Tromp's awesome work
01:03:58 <roboguy_> SrPx: so sin is not implemented as a primitive then? Let me see the lambda expression for sin
01:04:08 <Fylwind> Cale: ah ok, was just browsing some of the nice figures you have (like the one for monad)
01:04:24 <Cale> http://cale.yi.org/share/monadlaws.png ?
01:04:35 <SrPx> roboguy_: oh that was actually enlightening
01:04:55 <Fylwind> yeah, i'm guessing mu = (>>=) and eta = return or something?
01:04:57 <SrPx> roboguy_: I guess you answered a lot of questions by just saying that
01:05:04 <Cale> mu is join
01:05:06 <Cale> and eta is return
01:05:37 <Fylwind> is this some kind of special graph notation?
01:06:22 <tovarish> associative and unitary law :) that's *
01:06:29 <SrPx> roboguy_: so you'd recommend me to use lambda calculus with some pre-defined primitives such as numbers and operations on them ?
01:06:31 <Cale> Fylwind: These are string diagrams. Categories are represented by 2-dimensional regions, functors are the boundaries between those regions, and natural transformations are represented by 0-dimensional points where those boundaries meet (which I draw with a bubble there so that I can label them)
01:07:07 <Cale> In the case of a monad, M is an endofunctor, so there's only one category to worry about, so no point in labelling the 2D regions
01:07:11 <Fylwind> ah I see, I should read up on that
01:07:43 <roboguy_> SrPx: yes I would. that would no longer be lambda calculus, but that is a good thing
01:08:03 <SrPx> roboguy_: how'd you go about implementing those? I could see tree ways: 1. identifying church numbers etc and translating them to proper ints; 2. having numbers and math operations as actuall primitives; 3. including a type system
01:08:56 <SrPx> but the reason I'm avoiding a type system is that it doesn't work any well with the editor
01:09:13 <Cale> Fylwind: http://analogical-engine.com/wordpress/?p=12
01:10:01 <Cale> http://www.youtube.com/user/TheCatsters -- there are also a bunch of lectures about them here
01:10:36 <roboguy_> SrPx: I'm not sure I see how a type system would help, but I would just have normal numbers and math operations as primitives. why stick strictly to pure lambda calculus? that will only make things more difficult and less efficient
01:10:53 <skypers_> @hoogle insertWith . flip const
01:10:53 <lambdabot> Parse error:
01:10:54 <lambdabot>   insertWith . flip const
01:10:54 <lambdabot>               ^
01:10:58 <skypers_> @hoogle insertWith (flip const)
01:10:58 <lambdabot> Did you mean: :: insertWith (flip (Const insertWith insertWith))
01:10:58 <lambdabot> Data.Functor.Compose getCompose :: Compose f g a -> f (g a)
01:10:58 <lambdabot> Control.Monad.Trans.Maybe runMaybeT :: MaybeT m a -> m (Maybe a)
01:11:07 <skypers_> hm
01:11:19 <Fylwind> i swear one of these days i'll have to dig into category theory
01:11:20 <SrPx> actually this is something that is very confusing for me. for example, in Tromp's paper on BLC he says there is nothing inherently slow with LC and you can always use actual numbers when dealing with church numbers. so why can't you just do it, instead of actually changing the language definition?
01:11:49 <skypers_> is there a function similar to insertWith . flip const in Data.Map?
01:12:14 <skypers_> read here, that doesn’t insert the (key,value) if there’s already something
01:12:19 <skypers_> insert is insertWith const
01:12:52 <skypers_> insertWith (flip const) is just a preservative version
01:12:59 <roboguy_> SrPx: I seriously doubt that church numbers will be as fast. there are circuits in computers dedicated to extremely fast math operations that have been refined over many years. those circuits can compute things without even needing to run anything on the software level
01:13:01 <skypers_> but it might already exist, right?
01:13:58 <mm_freak> SrPx_: with 2 and 3 it's definitely not LC anymore
01:14:11 <mm_freak> SrPx_: and 1 is impossible in general
01:14:13 <SrPx_> mm_freak: uh huh.
01:14:20 <SrPx_> mm_freak: are you sure? Why?
01:15:10 <SrPx_> mm_freak: for example, church numbers will always be (λλ(1 1 1 0)), for example (using bruijn indices). So what stops a compiler from identifying that and replacing by (num 3) ?
01:15:22 <mm_freak> 1 is undecidable, firstly because some church integers look like partially applied church booleans, secondly because the general program to determine whether two LC expressions are alpha-equivalent is undecidable
01:15:34 <Cale> SrPx_: Because they *won't* always be like that
01:15:43 <roboguy_> ^ these are important points
01:15:49 <mm_freak> SrPx_: with 2 you're using an extension of LC (which you're doing anyway, so it's fine)
01:15:55 <SrPx_> mm_freak: oh that is true, I was thinking about that too! you're right
01:16:14 <mm_freak> SrPx_: with 3 you're enforcing your programs to terminate in finite time
01:17:10 <mm_freak> SrPx_: also consider this:  printing a church numeral is an O(n) operation, while printing the usual machine-encoded integers is an O(log n) operation
01:17:48 <mm_freak> where n is the value
01:18:16 <tovarish> mm_freak, for Integer, not Int
01:18:34 <mm_freak> church numerals are isomorphic to Integer, not Int
01:19:26 <SrPx_> mm_freak: so, for example, I'm representing the source code as binary tree or ints, where (1 body) is an abstraction, (0 idx) is a bruijn index and (a b) as function application. So the suggestion would be to add further primitives such as (2 NUM) to encode numbers?
01:19:31 <mm_freak> SrPx_: btw, your code is wrong
01:19:40 <SrPx_> mm_freak: what code?
01:19:49 <mm_freak> a church numeral looks like this:  λλ(1 (1 (1 0)))
01:20:28 <SrPx_> mm_freak: oh ok, my bad
01:22:33 <SrPx_> sooo... is that it?
01:23:17 <mm_freak> SrPx_: let me just accept for a moment that you really want to work in that awkward language…  i.e. you don't want let-abstraction or anything else that would make programming easier
01:23:29 <mm_freak> then for practicality reasons 2 is your only option
01:23:43 <mm_freak> but note that it's already an extension to basic lambda calculus
01:24:43 <SrPx_> mm_freak: eh I do have let abstractions as macros (that are just special flags on the editor telling certain function is actually a macro)... but alright continue
01:24:55 <mm_freak> SrPx_: i'm done
01:25:00 <SrPx_> oh my bad
01:25:03 <SrPx_> so, interesting.
01:26:33 <mm_freak> SrPx_: for the sake of communication (and your reputation, tbh) you should accept that your language uses the model we call lambda calculus, but is not itself lambda calculus
01:26:54 <mm_freak> in the same way addition on integers is not /the/ monoid, but /a/ monoid
01:27:21 <mello_> How can I map a SERIAL from postgresql to Snap's SimplePostgres? If not, what should I use for it to be compatible?
01:27:42 <SrPx_> mm_freak: I was talking about lambda calculus all the time. if it is not going to be lambda calculus in the end, I won't call it so. don't get where you got me wrong
01:28:28 <SrPx_> So, I make the interpreter for that new language that will beta-reduce a term as much as it can, then I write an optimizer that will do fusion and etc, then I compile it to an intermediate imperative language, and then I compile it as flat javascript function. Is that my best bet?
01:29:00 <mm_freak> SrPx_: no, because your compiler might never finish with the beta-reduction
01:29:45 <mm_freak> SrPx_: if you really want this to be actual lambda calculus, then your "function" never "returns"…  your /expression/ evaluates to something by beta-reduction, and that something is your result
01:29:53 <SrPx_> mm_freak: I don't think that will be a problem? If it does not terminate then my program will not too, so it is a bug...
01:30:15 <mm_freak> SrPx_: main = forever (putStrLn "hello!")
01:30:27 <mm_freak> your compiler will not terminate for that program
01:31:01 <SrPx_> mm_freak: but that will not happen on the language, no such thing such as a "forever" function
01:32:08 <mm_freak> SrPx_: you will be surprised how often you will encouter these infinite reductions =)
01:32:09 <SrPx_> anyway that is not the matter, what do I do with the code on my new toy language that is lambda calculus + numbers + arrays and some functions on them? what is the best way to get them into fast executable machine code and javascript without having much compiler writing knowledge?
01:32:39 <mm_freak> your new toy language is not lambda calculus + something
01:32:42 <SrPx_> mm_freak: I think this is unlikely, I've been using the former version for some time already, done some cool programs without any problem :/
01:32:59 <mm_freak> again, lambda calculus has no notion of a "function that returns"
01:33:03 <roboguy_> SrPx_: Haskell has a forever function...
01:33:12 <Cale> SrPx_: Why not just write an interpreter?
01:33:17 <roboguy_> oh I thought you meant at all, never mind
01:33:58 <SrPx_> Cale: that is included in what I said :z the interpreter is the first step
01:34:18 <Cale> SrPx_: Well, if you don't know how to write a compiler...
01:34:38 <SrPx_> hmm
01:34:47 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/ -- you might like this book?
01:34:53 <SrPx_> I really wanted an existing technology I could use :/
01:35:23 <SrPx_> like a simple functional language that is close to LC that I could compile into and it would do all the remaining
01:35:26 <Cale> Compile to Haskell
01:35:38 <Cale> Use haskell-src-exts to generate Haskell code
01:35:44 <Cale> and then use GHC
01:35:52 <mm_freak> SrPx_: a functional language has functions that return something…  LC does not have that, so no functional language will be close to LC
01:36:27 <Cale> and well, yeah, depending on what you really want... you'll probably figure out why everyone's been antagonistic pretty quickly :)
01:37:23 <Cale> Well, something other than lambda terms ;)
01:38:54 <Cale> You can sort of think of beta reduction as applying a function and having it return some substituted version of its body, but its body is again another lambda term or an application or a variable
01:39:57 <SrPx_> Cale: uh huh I see it as the same
01:39:59 <Cale> If it's a lambda term, you're kind of "done", but in a possibly sublimely unhelpful way.
01:40:31 <Cale> Because there's no way in general of checking whether that lambda terms is equivalent to one that you'd hope to see
01:40:36 <Cale> term*
01:41:02 <Cale> (it's essentially the same as the halting problem)
01:41:27 <SrPx_> Cale: on that topic, how it is not possible ? As I said Church Numbers always look like (λ(λ(1 (1 (1 0))))) so it looks like a simple string equality could answer it. But you said they don't. How not?
01:41:32 <mm_freak> s/essentially the same as/equivalent to/
01:41:47 <Cale> SrPx_: As soon as you start doing arithmetic, they stop looking so nice.
01:41:58 <mm_freak> SrPx_: only constant numbers look like that
01:41:59 <SrPx_> They always beta reduce to that...
01:42:05 <Cale> no
01:42:12 <SrPx_> example?
01:42:31 <mm_freak> SrPx_: λ(0 + 15)
01:42:43 <mm_freak> let + be something that adds numbers
01:42:56 <mm_freak> let 15 come from the outside world
01:43:02 <SrPx_> that is a function that returns a church number... which will perfectly look like that: (1 (1 (1 ... 15 times ... 0)))
01:43:09 <mm_freak> 15 is not a number
01:43:16 <mm_freak> it's a free variable
01:43:25 <Cale> mm_freak is using De Bruijn indices still
01:43:32 <merijn> SrPx_: tbh, writing a compiler isn't even that hard
01:43:34 <mm_freak> if you don't understand de bruijn indices, stop using them ;)
01:43:35 <SrPx_> 0 is a number?
01:43:38 <mm_freak> no
01:43:43 <SrPx_> oh OK
01:43:45 <mm_freak> 0 is bound
01:43:57 <SrPx_> so that is just (λa.a+b). hmm
01:44:05 <SrPx_> so, I was thinking about that
01:44:05 <mm_freak> yes, with b free
01:44:25 <merijn> SrPx_: I did a compiler writing course a few years back with 0 experience (and we didn't even compile to something high level like haskell, but a basic ASM for a custom VM) and it was actually surprisingly easier then I expected
01:44:37 <jtcwang> how would i pattern match both a list with one array and more than one array?
01:44:57 <merijn> jcande_: You mean you want a list with 1 or more elements?
01:44:58 <jtcwang> if i do (x:xs) can xs be []?
01:44:59 <SrPx_> what I thought is... + is an operator that is going to be optimized. It is an exception. so we just forbid its application on the language. This way (+ 0 15) would never beta reduce. It would just look like that, and then be compiled to something like "foo a b = a + b" in haskell, preserving itself
01:45:06 <merijn> jcande_: Yes, xs can be []
01:45:12 <SrPx_> that made sense for me, is that wrong?
01:45:15 <jtcwang> cool problem solved
01:45:17 <jtcwang> thank
01:45:18 <jtcwang> s
01:45:19 <xintron> mm_freak, any info about yst (compared to hakyll)?
01:45:35 <mm_freak> xintron: sorry, no experience with it
01:45:43 <merijn> > let (x:xs) = [1] in (x, xs)
01:45:45 <lambdabot>  (1,[])
01:46:25 <jtcwang> is there a place where i can find snippets of programs?
01:46:32 <jtcwang> for tutorial purpose
01:46:39 <mm_freak> xintron: note an important difference:  hakyll is used as a library…  apparently yst is a compiler
01:46:48 <merijn> jtcwang: github and hackage? :p
01:46:48 <jtcwang> but not actual tutorial. I just want to familiarize myself with the syntax
01:46:53 <SrPx_> merijn: mm_freak (tbh I *have* already written a compiler but it was for a language that had strings, objects and variables and I decided to cut them off in favor of bruijn indices and no strings/objects, so here I am having to do it again. i)
01:47:02 <mm_freak> xintron: similarly to how you use xmonad as a library to configure it
01:47:15 <SrPx_> it is not for it being hard, it is more for thinking I'm just wasting my time doing the wrong thing (or something that someone has already done)
01:47:16 <jtcwang> merijn, before being bombarded with Monads and ==>=.>=> operators
01:47:18 <jtcwang> :P
01:47:19 <xintron> mm_freak, yeah, I've noticed that difference. Don't know which one to start out with though
01:47:27 <merijn> jtcwang: Check out: http://blog.codeslower.com/static/CheatSheet.pdf
01:47:35 <SrPx_> in all honesty all I wanted was to do the editor, I just wish I had found a language similar to scheme that compiled to fast machine code and fast javascript
01:47:46 <mm_freak> xintron: in general i always prefer to go with libraries =)
01:48:09 <jtcwang> merijn, looks good thanks
01:52:40 <Cale> jtcwang: Also, have you read Learn You A Haskell?
01:53:02 <jtcwang> Cale, I got the book :) I'm chewing through real world haskell
01:53:14 <jtcwang> got frustrated because it gets quite hard
01:53:22 <jtcwang> so decided to actually solidify my haskell first
01:53:35 <jtcwang> by doing a few small projects and programmes
01:53:39 <jtcwang> so here i am!
01:53:57 <bitemyapp> I didn't like RWH and LYAH except as references.
01:54:04 <Cale> Yeah, writing little programs which just use ghci as an interface is probably the best way to get started initially
01:54:06 <bitemyapp> for an actual tutorial, I favor: http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/
01:54:09 <merijn> jtcwang: IMO the pace of RWH ramps up rather quickly, LYAH is slower paced
01:54:20 <Cale> http://www.haskell.org/tutorial/
01:54:22 <jtcwang> bitemyapp, i'll take a look thanks. I like it hard ;)
01:54:29 <Cale> There's the gentle intro :)
01:54:30 <bitemyapp> the problem is LYAH is too much toast with too little butter especially for anybody that already knows some FP
01:54:36 <bitemyapp> LYAH is fucking boring, honestly.
01:54:51 <merijn> bitemyapp: Sure, but that's is the minority of people that get stuck learning haskell
01:54:52 <bitemyapp> It's well written and *useful* but I don't like it as a "straight shot, read from beginning to end" means of learning Haskell.
01:54:53 <dv-> i like the gentle introduction to haskell
01:55:03 <merijn> @quote gentle.intro
01:55:03 <lambdabot> haskruby says: A Gentle introduction to Haskell is as gentle as Mike Tyson
01:55:06 <jtcwang> LYAH is pretty good for me
01:55:11 <merijn> ah, not the one I wanted
01:55:17 <merijn> @quote wrestling.bears
01:55:17 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
01:55:23 <jtcwang> i haven't actually read the real book, just about 1/2 of the online one
01:55:28 <bitemyapp> jtcwang: take a look at the Esposito tutorial, it's not actually "hard"
01:55:34 <bitemyapp> it's simply brief and to the point.
01:55:39 <Cale> The gentle intro is pretty brisk
01:55:42 <bitemyapp> And gets to the "meat" of the subject it presents quickly.
01:55:58 <merijn> bitemyapp: I agree that LYAH is not a "beginning to end" means of learning haskell
01:56:03 <bitemyapp> merijn: hahahaha @ bears
01:56:19 <bitemyapp> merijn: well that's how I see most people trying to learn Haskell and I tried doing it that way too. Didn't work.
01:56:20 <merijn> bitemyapp: But LYAH introduces very important things like functors/typeclasses/etc. in a slow understandable pace
01:56:34 <bitemyapp> Reading Yann Esposito's tutorial, following along in GHCi, and doing my own projects was 1000x better.
01:56:34 <merijn> bitemyapp: Sure, everyone's different :)
01:56:40 <bitemyapp> merijn: well, I'
01:56:50 <bitemyapp> I have been poking at Haskell for years and I'm an experienced Clojure user.
01:56:54 <bitemyapp> so FP isn't alien to me.
01:56:59 <bitemyapp> Just the bits that are specific to Haskell.
01:57:29 <bitemyapp> I know some OCaml too, not a lot albeit.
01:57:35 <merijn> bitemyapp: Right, but unless someone asks "haskell for FPers" intro, I tend to assume only imperative experience, if even that
01:58:08 <bitemyapp> merijn: I tell people to keep LYAH handy, I just think Esposito's tutorial is better in general
01:58:23 <bitemyapp> merijn: because it quickly confronts what you do and do not understand without being obtuse or slow.
02:00:26 <jtcwang> can guards (|) be used with let notation?
02:00:26 <Cale> The stylesheet on that tutorial is terrible
02:00:48 <Cale> (the tutorial itself looks maybe okay, I haven't read it)
02:00:55 <Cale> jtcwang: yes
02:00:57 <merijn> jtcwang: If you're defining a function in the let, then yes (I think)
02:01:09 <merijn> I guess guards even work for non-functions
02:01:10 <jtcwang> what about a variable?
02:01:18 <jtcwang> let aNumber =
02:01:21 <Cale> You can have guards on a pattern binding
02:01:28 <merijn> Although they'd be rather pointless without any arguments to have guards too :)
02:01:30 <Cale> let aNumber | cond1 = ...
02:01:30 <jtcwang>    | (condition) -> 5
02:01:41 <jtcwang> ok
02:01:42 <Cale>             | cond2 = ...
02:01:44 <merijn> jtcwang: Guards don't use arrows
02:01:55 <Cale> merijn: They do when you use them in case
02:01:58 <bitemyapp> Cale: spreadsheet?
02:02:00 <triliyn> > let five | True = 5 | False = 6 in five
02:02:01 <lambdabot>  5
02:02:15 <jtcwang> uh i keep getting confused
02:02:25 <merijn> Cale: Sure, but we were talking about let, just now
02:02:43 <Cale> bitemyapp: I mean, the choices of colours and fonts on Esposito's tutorial leave much to be desired from my point of view :)
02:03:09 <bitemyapp> Cale: you mean stylesheet?
02:03:10 <jtcwang> I have an ADT called WinLose
02:03:13 <jtcwang> Win | Lose
02:03:15 <Cale> stylesheet
02:03:22 <bitemyapp> and yeah, Esposito chooses some weird styling for his blog and stuff.
02:03:22 <Cale> That's what I wrote
02:03:32 <Cale> <Cale> The stylesheet on that tutorial is terrible
02:03:34 <bitemyapp> but it's HTML. it's your browser, you can fix it with a custom style if you want.
02:03:35 <jtcwang> i'm trying to do let thisBet
02:03:38 <Cale> yeah
02:03:45 <bitemyapp> yeah i see how I misread it now, sorry.
02:03:47 <jtcwang>    | (what do i put here as a condition)
02:03:47 <Cale> The code font renders weird for me too
02:03:57 <bitemyapp> Cale: seems okay, I'm on Linux. You?
02:03:59 <Cale> Brackets end up looking like ceiling brackets about half the time
02:04:03 <merijn> jtcwang: Maybe paste what you have so far on lpaste?
02:04:03 <Cale> Linux
02:04:41 <Cale> (Chrome)
02:05:12 <jtcwang> http://lpaste.net/97733
02:05:44 <jtcwang> so i want to see if r is Win or Lose
02:06:02 <merijn> jtcwang: Why not pattern match directly?
02:06:17 <triliyn> simulate (Win:rs) (x:xs) = ...
02:06:25 <triliyn> simulate (Lose:rs) (x:xs) = ...
02:06:38 <jtcwang> haha i knew it must be easy
02:06:45 <jtcwang> thanks
02:06:46 <merijn> jtcwang: i.e. http://lpaste.net/97733
02:06:55 <Cale> (also don't forget about the case where either list is empty)
02:07:09 <merijn> jtcwang: You can nest as many constructors/pattern matches in one go as you want
02:07:14 <jtcwang> ok Cale :)
02:07:24 <jtcwang> i've been thinkin
02:07:32 <merijn> jtcwang: Also, if you compile your code use "-Wall" it'll produce a warning if you forget to handle the empty list
02:07:37 <jtcwang> can i do multiple matches with the same function definition
02:07:52 <Cale> (If you compile with -Wall it will also complain about lots of harmless things though)
02:08:05 <merijn> Cale: Like?
02:08:16 <jtcwang> say for eg i want both r = Win or Lose to have the same function
02:08:16 <Cale> merijn: You didn't use the result of an IO action
02:08:20 <merijn> The only one I can really think of is unused-do-bind
02:08:37 <merijn> jtcwang: Then you just write what you had initially
02:08:47 <merijn> jtcwang: "simulate (r:rs) (x:xs)"
02:08:56 <merijn> jtcwang: here 'r' can be both Win *or* Lose
02:09:18 <merijn> jtcwang: If you don't use a pattern match you can also use _ (which means "don't care what this is")
02:09:23 <jtcwang> let's say i have  char
02:09:31 <merijn> jtcwang: i.e. "simulate (_:rs) (x:xs)"
02:09:35 <triliyn> Isn't there a flag for just incomplete pattern match warnings too?
02:09:45 <jtcwang> 4 possible case: n s e w
02:09:47 <ion> triliyn: -Wall
02:09:51 <merijn> triliyn: Probably, yes
02:10:00 <jtcwang> i want to have the same function for n s e
02:10:22 <jtcwang> is there a way to 'stack them'?
02:10:25 <jtcwang> let me illustrat
02:10:25 <Cale> jtcwang: Pattern match 'w' first, and then handle the rest together
02:10:33 <merijn> jtcwang: Pattern matches happen in lexical order, so if you write "foo W = something; foo _ = other"
02:10:46 <merijn> jtcwang: Then it'll pick "something" for W, but "other" for the other 3
02:11:05 <jtcwang> what about if its 2, 2 condition?
02:11:10 <ion> foo x | x `elem` [A,B,C,D] = … | otherwise = …
02:11:11 <jtcwang> n w, and s e?
02:11:33 <Cale> Then you could use a guard like ion is showing
02:11:39 <Cale> But pattern matches can't quite do that
02:11:40 <jtcwang> right
02:11:45 <jtcwang> i was wondering
02:11:47 <Cale> (on their own)
02:11:48 <merijn> Althought that'd only work if they are Eq
02:11:53 <Cale> right
02:12:13 <jtcwang> i have some vague impression that you can stack them
02:12:28 <Cale> If I found myself doing that a lot, I would worry that my data type isn't structured enough
02:12:43 <jtcwang> lie this: http://lpaste.net/97733
02:12:55 <jtcwang> but guess i remembered wrong
02:13:21 <merijn> jtcwang: You could do that using case-of, I think. But not in function definition directly
02:13:27 <ion> You may be thinking of C switch statements or sh case statements. :-)
02:13:29 <jtcwang> yeap makes sense
02:13:34 <merijn> Or maybe I'm mixing haskell and ocaml case-of
02:13:47 <jtcwang> i'm asking way for way too much here :P
02:13:50 <Cale> I think some of the MLs have or-patterns
02:14:41 <Cale> (Specifically, OCaml does)
02:18:25 <aristid> what's an or-pattern?
02:19:01 <Cale> (0|1)::xs matches a list whose head is either 0 or 1 and whose tail is xs
02:19:43 <Cale> pat1 | pat2 matches if either pat1 or pat2 does, and they must bind the same variables
02:20:22 <aristid> oh, cool
02:21:52 <bitemyapp> Cale: part of my problem with ML was that they over-relied on certain features that really had nothing to do with FP.
02:22:11 <bitemyapp> Cale: parameterized modules and pimped out pattern matching coming to mind.
02:22:21 <bitemyapp> not that I wouldn't like to have the former, it just isn't as important.
02:22:46 <tovarish> pattern matching is just syntaxic sugar
02:23:16 <bitemyapp> well the advantage of pattern matching is that it's declarative.
02:23:33 <bitemyapp> the way you do conditional dispatch in languages without it really sucks.
02:23:42 <merijn> parameterized modules are a pretty splendid idea
02:23:43 <bitemyapp> you'd hate the let-bodies I wrote in Clojure.
02:23:48 <Cale> My main problem with the MLs is just that they sold out as far as I/O is concerned. Secondarily, I rather like nonstrict semantics.
02:23:50 <tovarish> it's just the proper way to handle or on value
02:23:59 <bitemyapp> merijn: they're nice to have but not really a fundamental building block of FP.
02:24:09 <bitemyapp> Cale: ditto and ditto.
02:24:17 <merijn> Haskell has billions of things which aren't very fundamental building blocks of FP :p
02:25:25 <bitemyapp> merijn: it may not seem that way to you, but I think the stuff developed in Haskell so far represents the present and future of how to do FP, whereas ML functors are basically a contingent toy.
02:25:25 <khs> Hi, what is the best place to ask some more in-depth questions about haskell programming?
02:25:38 <bitemyapp> khs: just ask here or in Stack Overflow.
02:25:54 <merijn> khs: Here, SO or the haskell-beginners/haskell-cafe mailing lists
02:25:57 <bitemyapp> merijn: I point you to Oleg's post here: http://www.haskell.org/pipermail/haskell/2004-August/014463.html
02:26:24 <bitemyapp> merijn: ML functors aren't fundamental, stuff that is in the typeclassopedia is more important. Combine what Oleg is talking about with some TH and it feels like a native feature.
02:26:59 <merijn> bitemyapp: The stuff in haskell represents how I believe programming should be done, but I'm not convinced this is necessarily has much of a relation to "pure FP"
02:27:14 <Cale> bitemyapp: fwiw, I think there are some pretty serious cases where it would be very nice to have a module system like OCaml's or SML's especially surrounding ByteString and Text
02:27:42 <bitemyapp> merijn: the part I care about is being able to build my own abstractions, Haskell has better fundamentals for that.
02:27:56 <bitemyapp> same reason I prefer Lisp to Python, C++ to C.
02:28:14 <jtcwang> what's wrong with this: http://lpaste.net/97733
02:28:19 <bitemyapp> Cale: indubitably, I'm just saying that Haskell has the tools needed to accomplish that, but the inverse isn't true.
02:28:26 <jtcwang> its complaining about rs not being a list
02:28:55 <Cale> jtcwang: simulate rs newRecord:x:xs  means  (simulate rs newRecord):x:xs
02:28:58 <merijn> jtcwang: You are using functions/datatypes that are not in your paste and not including the error
02:29:25 <jtcwang> sry merijn, cuz the error is in the prompt
02:29:26 <Cale> jtcwang: Because function application binds more tightly than any infix operator
02:29:30 <jtcwang> not sure how to pipe it
02:29:37 <jtcwang> i see Cale
02:30:08 <jtcwang> i'm using runhaskell
02:30:10 <jtcwang> from vim
02:30:24 <jtcwang> i'll look into how to pipe that back
02:30:27 <Cale> jtcwang: Open two windows, one with vim and the other with ghci
02:30:32 <jtcwang> i'm seen it done before
02:30:32 <bitemyapp> jtcwang: probably want to get in the habit of using GHCi btw. More interactive.
02:30:36 <merijn> jtcwang: I would recommend just using ":load filename.hs" inside ghci
02:30:39 <bitemyapp> introspection can be done in GHCi as well.
02:30:42 <bitemyapp> merijn: :l
02:30:44 <Cale> jtcwang: when you save your file in vim, type :r in ghci to reload
02:30:47 <khs> Ok, I'll try here first then. I have a bunch of points (ordered by x first, then y, then z) in Data.Map which should work OK for lookup when doing collition detection. But I also need to check for each point if it has neighbors when rendering, which would result in O(n log n) rendering time. Is there a common datastructure that supports fast lookup and constant traversal of closest neighbours?
02:30:56 <merijn> bitemyapp: I know, but I try to avoid cryptic commands for newbies :p
02:31:11 <jtcwang> Cale, bitemyapp, merijn: ok thanks
02:31:13 <merijn> khs: You'll want a metric tree, probably
02:31:16 <bitemyapp> sure, just saying, if he's a vimmer then they'll appreciate the shortcut.
02:31:29 <bitemyapp> merijn: have a puppy: http://i.imgur.com/x0Gf2vl.jpg
02:31:32 <merijn> khs: metric trees support lookups like "give all points within X distance of Y"
02:31:33 <jtcwang> I do have ghci open for type checks
02:31:43 <khs> merijn: is that in the standard haskell libraries?
02:31:52 <Cale> khs: Maybe you're looking for something like an octree? (or some other spatially partitioned tree)
02:31:53 <jtcwang> just find one button run (F5) too tempting
02:31:53 <merijn> khs: I think there's a few libraries on hackage
02:32:24 <Cale> http://hackage.haskell.org/package/KdTree
02:32:29 <bitemyapp> khs: that's an octree.
02:32:46 <bitemyapp> if it was 2d, it'd be a quad-tree.
02:32:56 <bitemyapp> khs: are you doing game development in Haskell?
02:33:12 <khs> bitemyapp: yes
02:33:12 <Cale> This tree type can compute nearest neighbour in log time
02:33:26 <Cale> (on average)
02:34:37 <bitemyapp> khs: you'll have to keep us posted, I am intensely interested in Haskell game development. There is an IRC channel devoted to this as well.
02:34:37 <khs> Cale: I could do that in O(log n) time with my Data.Map usage (which is not that different from an octree from my understanding)
02:34:47 <bitemyapp> khs: #haskell-game btw.
02:34:51 <Cale> khs: Could you?
02:35:06 <Cale> khs: How would you do that?
02:36:15 <khs> Cale: I am only using integers for the points. So any point (x y z) would only have C neighbours: C * O(log n)
02:36:23 <aleksejs_> Hi! Could anyone help me? Why do I get "Ambiguous type variable" error here http://lpaste.net/4735858934613540864?
02:36:33 <Cale> khs: uhhh
02:36:48 <bitemyapp> khs: the problem is the ordering would be uni-dimensional and you're modelling something 3d.
02:36:55 <ion> aleksejs: Where? That is, please paste the full error.
02:36:56 <merijn> aleksejs_: Can you include the error?
02:36:59 <Cale> khs: I mean, the nearest neighbour which is actually in the tree somewhere
02:37:42 <merijn> aleksejs_: Usually "ambiguous type variable" is GHC's way of saying, 'There's multiple different ways to make this type match and I dunno which you want'
02:37:43 <khs> Cale: ahhh, yeah, sure, but currently I only care about actual neighbours
02:37:46 <Saizan> aleksejs_: Fractional t and Integral t aren't compatible, can you use (/) instead of div?
02:38:08 <khs> Cale: anywho, maybe I should just learn how to do an actual octree
02:38:36 <ion> aleksejs: I suggest you comment out the type annotation and ask GHC what it thinks the type is.
02:39:09 <aleksejs_> Saizan, with / same error
02:39:19 <Cale> khs: I wouldn't be too concerned about the difference between log time and constant time. Remember that it's impossible for any function whose range has n elements to be computed in less than O(log n) time, so anything of that sort which claims to be constant time is lying for some reason ;)
02:40:24 <aleksejs_> ion, I did exactly as you said
02:40:25 <khs> Cale: Well I could use a three dimensional array, but then I would be wasting too much space
02:40:33 <aleksejs_> here is an error http://lpaste.net/4735858934613540864
02:41:06 <Cale> khs: I'd just do lookups on the points I was interested in
02:41:22 <Saizan> aleksejs_: you have to remove the type signature too
02:41:24 <ion> aleksejs: How about without the type annotation?
02:41:24 <merijn> aleksejs_: oh, duh
02:41:40 <merijn> ion: No, he's not specifying the result type of "solveA" when passing to print
02:41:49 <khs> Cale: that is probably a good idea. I think my performance issues is due to my naive opengl rendering implementation anyway
02:42:01 <merijn> aleksejs_: GHC can't guess which type you want "solveA" to return, so it doesn't know how to print that type
02:42:21 <Cale> You might be able to save a little time by doing 6 split operations, to cut out the 3 bits of the Map that you're interested in
02:42:28 <ion> Huh, it doesn’t use defaulting here?
02:42:33 <Cale> I'm not sure if it'd really be faster
02:42:34 <merijn> aleksejs_: You have to annotate the type like "print (solveA 1000 :: MyType)", although you probably won't be able too, due to Integral and Fractional being incompatible
02:42:45 <merijn> ion: Default what? There is no Fractional *and* Integral type
02:48:29 <bitemyapp> Cale: that's not true.
02:48:35 <bitemyapp> Cale: you can do better than log n.
02:48:46 <bitemyapp> not constant time, mind, but you can do better than log n.
02:49:13 <bitemyapp> log32n and log log n are possible in specific circumstances with specific problems and data structures.
02:49:18 <Cale> bitemyapp: You can't distinguish between n distinct inputs in less than O(log n) time
02:49:33 <bitemyapp> that's a weird way of phrasing it.
02:49:41 <bitemyapp> surely you've heard of the phonebook problem.
02:49:53 <bitemyapp> it has some parallels with collision detection.
02:50:14 <bitemyapp> you can do interpolated lookups in a phone book in log log n.
02:50:27 <bitemyapp> HAMTs are generally log16n or log32n. Which is delightful.
02:50:35 <bitemyapp> so damn close to constant time as to not matter in most cases.
02:50:46 <bitemyapp> you can use probabilistic data structures for some problems to do better than log n as well.
02:50:57 <Cale> What I'm talking about is a theoretical bound which applies to absolutely every function.
02:51:27 <bitemyapp> I'm talking about the application of data structures and the traversal thereof to specific problems.
02:51:39 <bitemyapp> I don't know what constraint you purport to speak of and I've never heard of it.
02:51:46 <Cale> If the range of the function has n values in it, then the function takes at least O(log n) time to compute, because it needs to look at at least log n / log 2 bits of the input.
02:51:51 <bitemyapp> I think you're boxing something into a particular set of constraints.
02:52:04 <bitemyapp> why would that be the case?
02:52:18 <bitemyapp> I've already mentioned the phonebook problem which is log log n.
02:52:33 <bitemyapp> and it's a function with a domain and range n./
02:52:40 <Cale> Well, that tells us something about the size of the range of that function :)
02:52:46 <bitemyapp> no it doesn't.
02:52:59 <bitemyapp> you can query any value in the domain and get the result.
02:53:12 <bitemyapp> all it requires is a known/predictable distribution.
02:53:13 <Cale> (Either the asymptotic analysis is wrong, or the range is really of size O(log n))
02:53:27 <bitemyapp> You can apply similar techniques to trees to do better than log n.
02:53:46 <aleksejs_> ok, same error now (it doesn't like a 6th line) http://lpaste.net/5577914992713269248
02:54:06 <Cale> bitemyapp: If you don't have enough time to look at log_2 n bits, then your function can't tell between n different values.
02:54:20 <aleksejs_> if i replace solveAB n with just [1,2], everything works
02:54:33 <Cale> So, it *must* map some of those values to the same result
02:54:36 <bitemyapp> Cale: http://en.wikipedia.org/wiki/Interpolation_search
02:54:48 <bitemyapp> Cale: interpolation search is (log log n).
02:55:07 <Cale> O(log(log n)) *comparisons*
02:55:43 <bitemyapp> Cale: http://en.wikipedia.org/wiki/Big_O_notation#Orders_of_common_functions
02:55:57 <bitemyapp> and?
02:56:17 <Cale> What's the time complexity of a single comparison? If the things being compared are numbers whose size is O(n), then the time spent comparing them will be O(log n)
02:56:31 <Cale> (at least)
02:56:37 <bitemyapp> Cale: you'
02:56:45 <bitemyapp> are just bein silly and obstinate now.
02:56:54 <Cale> huh?
02:56:55 <merijn> bitemyapp: He's not
02:56:55 <tovarish> but he is right
02:57:02 <Cale> I'm actually correct
02:57:10 <bitemyapp> Cale: I look forward to your wikipedia edit then.
02:57:23 <Cale> This wikipedia article is fine
02:57:28 * tovarish smells troll odor :)
02:57:29 <Cale> It's just not talking about the time complexity
02:57:29 <merijn> bitemyapp: You are referring to a different complexity type
02:57:41 <bitemyapp> then why not say so at the beginning?
02:57:47 <merijn> He did
02:57:59 <merijn> He said it takes at least "O(log n) *time*"
02:58:02 <Cale> I'm talking about time complexity, not comparison counts
02:58:05 <tovarish> merijn, there is only two complexity, time and space. Do you know a third one ?
02:58:13 <merijn> tovarish: Number of operations
02:58:24 <tovarish> merijn, it's time masqueraded
02:58:33 <merijn> tovarish: Only if operations are constant
02:58:35 <bitemyapp> http://en.wikipedia.org/wiki/Big_O_notation#Orders_of_common_functions is time complexity.
02:58:55 <tovarish> merijn, even non constant, it's just more complex to go fgrom one to the other
02:59:13 <Cale> Yeah, that's incorrect if it's referring to time complexity
02:59:26 <bitemyapp> Cale: thus why I look forward to the wikipedia edit.
02:59:41 <merijn> tovarish: Common example, in distributed algorithms one worries about message complexity of operations (i.e. number of messages send), not because of the time used but because of resource usage
02:59:47 <Cale> However, I wouldn't doubt that it's the correct order for the number of comparisons made by the interpolation search
02:59:59 <merijn> tovarish: i.e. communication is expensive for things like embedded systems and sensor networks
03:00:04 <tovarish> merijn, isn't resource usage a special case of time complexity ?
03:00:15 <mm_freak> tovarish: the number-of-steps complexity to add n numbers is O(n), but the time complexity is O(n*s) for numbers of size s
03:00:33 <merijn> tovarish: No, because there may be no correlation between time and resource consumption
03:00:47 <merijn> tovarish: i.e. some things that are very long are very cheap on power and vice versa
03:00:51 <tovarish> merijn, i really don't agrre with you
03:01:02 <schell> is there a lens infix operator to add an element to a list?
03:01:04 <Cale> I added the words "number of comparisons spent" to the beginning of the description there. I'd do more, but I'm lazy
03:01:10 <merijn> tovarish: resource and time only correlate if all operations require similar resources
03:01:12 <schell> or set?
03:01:16 <tovarish> the computation are distributed to gain time, but no it's not a matter of time
03:01:21 <tovarish> we don't live in the same world
03:01:33 <merijn> tovarish: You are thinking HPC distributed systems
03:01:40 <merijn> tovarish: I just mentioned embedded/sensor networks
03:01:47 <tovarish> merijn, i'm thinking about any computrer science algorithm
03:02:06 <tovarish> you can distribute it if you want, but there is still only two relevant info : time and space
03:02:20 <Chousuke> tovarish: that's only true if you assume all resources are free
03:02:22 <mm_freak> tovarish: the number-of-steps complexity to quicksort the rows of a square matrix is O(n²), but the time complexity is O(n³)
03:02:26 <merijn> ...
03:02:29 <mm_freak> tovarish: clearly there is a major difference
03:02:32 <merijn> Am I accidentally speaking chinese?
03:02:36 <tovarish> mm_freak, thta's exactly what I'm saying
03:02:42 <merijn> tovarish: What's wrong with my previous example?
03:02:51 <bitemyapp> Cale: also with interned string implementations your string comparison can be constant time.
03:03:07 <tovarish> merijn, you just show me a masqueraded time complexity
03:03:11 <bitemyapp> Cale: because it's a single pointer reference compare rather than traversing bytes/runes/characters.
03:03:16 <merijn> tovarish: How so?
03:03:16 <Cale> bitemyapp: Only asymptotic analysis is meaningless
03:03:18 <tovarish> and you refuse to recognize it
03:03:30 <Cale> bitemyapp: because you've restricted yourself to finitely many strings :)
03:03:33 <merijn> tovarish: How is my description a masqueraded form of time complexity?
03:03:35 <mm_freak> tovarish: if you agree about this, then you also agree that there are at least three types of complexity:  time, space and steps
03:03:40 <bitemyapp> Cale: so in some languages a stringly interpolation search is in fact (log log n)
03:03:45 <tovarish> merijn, you were talking abouyt time
03:03:48 <tovarish> time time and time
03:03:53 <merijn> tovarish: I explained how time and resource usage do not correlate and you just said "they do!"
03:03:54 <tovarish> that's elementary
03:03:57 <merijn> tovarish: Without any argument
03:04:00 <bitemyapp> Cale: no more than any other implementation.
03:04:01 <Cale> bitemyapp: As soon as you put a bound on the size of the input, everything is O(1)
03:04:09 <bitemyapp> Er, no.
03:04:12 <tovarish> merijn, i never say that the masquerading was a linear function
03:04:13 <Cale> Er, yes.
03:04:14 <bitemyapp> interning strings doesn't bound the input.
03:04:19 <Cale> Yes it does.
03:04:21 <bitemyapp> no more than non-interned strings.
03:04:25 <Chousuke> bitemyapp: the bound is the number of interned strings
03:04:26 <bitemyapp> if anything it saves memory.
03:04:37 <tovarish> i just say that when you study that problem you're studiying a time complexity problem
03:04:52 <merijn> tovarish: Oh, how is that?
03:04:58 <bitemyapp> Chousuke: are we really assuming streaming interpolation search here? The strings are going to be in memory in any serious example.
03:05:08 <bitemyapp> that's just ridiculous.
03:05:25 <Cale> bitemyapp: Eventually your pointer size has to grow, which makes comparisons take longer because you have to compare more bits to compare the pointers
03:05:40 <Chousuke> bitemyapp: yeah, but the cheap comparisons can be done only on the finite set of already interned strings, not any string
03:05:41 <bitemyapp> that doesn't make it not constant time.
03:05:47 <Cale> Yes it does.
03:05:48 <tovarish> merijn, the study ogf resources is the study of the time of the delay of algorithm
03:06:10 <merijn> tovarish: Did you just discard the entire field of embedded and sensor network research?
03:06:47 <merijn> tovarish: There are loads of algorithms where people don't trade off time but resources-vs-accuracy, because time is fixed
03:06:59 <merijn> But those aren't even what I was referring too
03:07:16 <tovarish> merijn, I didn't discrad them, I just say it's a particular branch of time complexity. Why do you deform my words
03:07:17 <bitemyapp> that also touches on probabilistic data structures. Resources vs. accuracy, fixed time operations.
03:07:32 <merijn> tovarish: Why is that time complexity according to you?
03:07:32 <Cale> As the size of your input grows, if you want to keep interning your n strings, you'll have to increase the number of bits in your pointers so that it's at least log n / log 2.
03:07:53 <tovarish> merijn, anything about time for algoirithm (if it's not time it's space) there is nothing else
03:07:59 <Cale> and comparing those pointers for equality will take log n / log 2 time
03:08:06 <merijn> tovarish: That's not an argument
03:08:20 <merijn> tovarish: Just because "I say there's nothing other than time and space!" doesn't make you right
03:08:22 <tovarish> merijn, since the beginning you're aligning false argument
03:08:27 <merijn> I just provided a counter example
03:08:37 <tovarish> merijn, show me something which is not time and space
03:08:40 <merijn> And you refuse to address why my counter example is supposedly invalid
03:08:46 <merijn> tovarish: Resource consumption
03:08:52 <Chousuke> tovarish: power.
03:08:58 <Cale> actually... hmm
03:08:58 <tovarish> merijn, becaudse they are time problems (you use the word TIME, read yourself)
03:09:13 <merijn> tovarish: Why are they time problems?
03:09:16 <tovarish> resource consumption is still a time specific case
03:09:24 <merijn> tovarish: How so?
03:09:30 <Chousuke> tovarish: or say, disk access.
03:09:30 <tovarish> merijn, why do you use the word time wwith your "counter" exampole ?
03:09:40 <tovarish> Chousuke, disk acces is a time p[roblem
03:09:46 <Chousuke> tovarish: no it's not.
03:09:59 <tovarish> Chousuke, what is it ? magic ?
03:10:20 <Chousuke> tovarish: I mean, it takes time, but the number of times a disk is accessed can vary between algorithms, so it can be analyzed separately
03:10:23 <merijn> tovarish: The only time I used "time" was to point out that longer operations do not always consume more power than shorter once, thus power consumption doesn't correlate with time
03:10:34 <Cale> tovarish: There are even different sorts of time
03:10:49 <tovarish> merijn, power ? we're talking about W ?
03:10:50 <Cale> There's wall clock time, there's CPU instruction count
03:10:54 <jle`> hm. can i have acid-state without persistence?  just having them float in memory, and using their atomic updates
03:11:03 <Cale> there's number of memory accesses
03:11:05 <merijn> tovarish: If I care about power consumption and power consumption doesn't correlate with time, then I care about the power complexity of operations
03:11:08 <Cale> there's number of disk accesses
03:11:12 <merijn> tovarish: Yes, as in electricity
03:11:18 <jle`> instead of manually abstracting away STM and MVars and stuff
03:11:30 <Cale> and yeah, there's other sorts of resource consumption
03:12:06 <Cale> jle`: hmm, I'm not sure I understand your motive
03:12:10 <merijn> tovarish: space complexity is just a special case of generic "resource complexity" where the resource happens to be "memory"
03:12:30 <tovarish> merijn, what is power? it's soimething you can produce according to time? because you need power plant, and it took work time to produce power plant and make them run
03:12:32 <merijn> tovarish: One can even argue that time complexity is a form of "resource complexity" where the resource is "cpu operations"
03:12:49 <merijn> tovarish: Not if you have a battery with a fixed charge you need to maximise
03:12:53 <tovarish> merijn, if it's not time,. it's space? thank you that's what I'm saying since the beginning
03:12:55 <Cale> tovarish: For any given function f in our program, we might be interested in the number of times an application of f to some arguments is evaluated
03:13:04 <merijn> tovarish: Now you're just trolling
03:13:07 <tovarish> Cale, it's still to analyse ttime
03:13:10 <Cale> tovarish: That's something related to time and space complexity, but is clearly neither
03:13:56 <tovarish> merijn, I'm not, I proved my point, showing that your "counter" artgument are not argument. You deform my words and say I'm a troll. That's all I need to know I am right and you're wrong
03:13:58 <merijn> tovarish: Dude, having a problem with admitting you're wrong and doubling down my just pretending everyone says what you're saying is not very constructive
03:14:25 <merijn> Anyhoo, I'm out I have a paper to write before tomorrow
03:16:31 <Cale> btw, that O(log n) bound is actually wrong if you consider physical constraints too, and the fact that the amount of information you can fit into any given part of space is bounded
03:17:00 <Cale> (and that it takes light a fixed amount of time to travel a given distance)
03:17:43 <Cale> It's more like O(n^(1/3)) or even O(n^(1/2)) depending on your physical assumptions about nature
03:18:22 <Cale> (specifically, whether you adopt the holographic principle or not)
03:19:09 <bitemyapp> this is why I prefer data.
03:19:49 <Cale> It's actually reasonable to start thinking like that with sufficiently large NUMA machines :)
03:20:20 <Cale> As you scale the system up, your memory gets farther and farther away from your CPU
03:20:46 <Cale> (or from whatever location at which you're trying to collect the result in the end)
03:20:58 <bitemyapp> This is true but I live in a world where I'm on Linux/x86 deploying to Linux/x86.
03:21:07 <bitemyapp> I just don't care about hypotheticals.
03:21:23 <bitemyapp> and I embrace cheating to make the software faster.
03:22:16 <Cale> The problem with asymptotic analysis is that it almost forces you to entertain things like this in order to remain relevant (at least, if taken on its own).
03:22:35 <jle`> Cale: I like the api of having the data store out there, and accessing it, etc; i just don't need to ever persist my structures across program executions
03:23:02 <Cale> jle`: Do you mean like IxSet?
03:23:18 <Cale> You can certainly use IxSet on its own
03:23:24 <bitemyapp> Cale: for me it's just a blunt instrument for thinking about coarse-grained tradeoffs.
03:23:29 <bitemyapp> In the real world, the constant factor matters.
03:23:36 <jle`> Cale: and do I keept in an MVar or something?
03:23:43 <Cale> jle`: Perhaps!
03:25:20 <jle`> Cale: are there any libraries to streamline this?  or i guess there's not too much possible abstractions
03:25:22 <Cale> jle`: All that acid-state does is persist arbitrary Haskell values in a way that they can be updated and queried
03:25:24 <jle`> many
03:25:40 <Cale> So it doesn't make much sense to ask for acid-state without the persistence part
03:25:47 <Cale> That's just arbitrary Haskell datastructures
03:25:52 <jle`> Cale: yes, but those haskell values stay in-memory and i can access them from any IO
03:26:00 <jle`> which is kind of what I was looking for
03:26:11 <jle`> where i can update a sort of global state, i guess
03:26:13 <merijn> jle`: That's just an IORef
03:26:15 <jle`> global datastore
03:26:31 <Cale> Yeah, an IORef is probably what you're looking for
03:26:43 <jle`> merijn, Cale: ah that makes more sense
03:26:53 <jle`> and this is...'okay'?  idiomatic/is clean haskell?
03:27:08 <merijn> jle`: For some value of ok, some stuff just needs mutable state
03:27:23 <merijn> jle`: I go by the "whatever makes live easiest" principle
03:27:23 <Cale> The thing I like to do with my IORefs is that I will typically create them near the top-level of my program
03:27:39 <Cale> and I will immediately separate them into a read and write end:
03:27:47 <Cale> r <- newIORef 0
03:27:48 <aristid> you certainly don't need to go through huge lengths just to avoid an IORef
03:27:59 <Cale> let readEnd = readIORef r
03:28:06 <Cale>     writeEnd = writeIORef r
03:28:18 <Cale> (usually better-named)
03:28:22 <merijn> jle`: Some of my haskell code is heavily imperative (lots of IO everywhere), mainly because my problem is very IO heavy and I just prefer imperative haskell to doing it in C/Python/whatever
03:28:25 <aristid> Cale: and then you only give the writeEnd to some parts of the code and the readEnd to others?
03:28:29 <Cale> right
03:28:36 <jle`> my provider is limiting my sql queries and connections; i've been using Persistent, but i realized that i only really do any inserts/modifications at the startup of the program
03:28:47 <Cale> and what that does is it lets me change the semantics of reading and writing later
03:28:49 <aristid> Cale: somehow i find myself using atomicModifyIORef' more then writeIORef
03:28:53 <aristid> *than
03:29:37 <jle`> i need to pass my IORef into everything, right?  can't have some kind of global IORef without unsafePerformIO?
03:29:51 <Cale> Yeah, I suppose the downside is that this doesn't give you that. You could replace the write end with that through.
03:30:06 <maurer> jle`: No, because the IORef needs to get allocated somewhere
03:30:07 <Cale> jle`: Yeah, but you'll find it's worth the initial pain to do that anyway
03:30:11 <aristid> jle`: using unsafePerformIO for IORefs is one of the slightly less evil uses of unsafePeformIO, but still should be avoided if possible
03:30:34 <jle`> yeah i don't think i would need to, and there is almost no pain
03:30:41 <jle`> just wondering
03:30:46 <aristid> Cale: a write-only version of atomicModifyIORef that doesn't give you the new value might give that separation
03:30:55 <Cale> Passing the IORef explicitly turns out to be very useful when testing, and helps people understand what your code depends on
03:31:11 <Cale> aristid: yeah
03:31:55 <Cale> But yeah, once you have that, you can just change the code in one place and get a log of all the writes and reads that happened
03:32:32 <jle`> and this is probably a not very answerable question, but is there any general performance difference i should be expecting for writing my own 'selects'/queries on Haskell data objects, compared to, say, offloading it to Persistent?
03:32:46 <jle`> for maybe say 200-ish rows
03:33:13 <aristid> Cale: i think it often also makes sense to build more high-level abstractions on top of IORef
03:33:31 <Cale> jle`: I'd expect using Data.Map for such a small number of things to be much faster than querying an external database
03:33:39 <aristid> Cale: like i have function that converts an IORef (HashMap k v) to a mutable map :D
03:33:55 <jle`> hm. thanks
03:33:58 <jle`> all :)
03:36:10 <merijn> Does anyone know of any references/papers I can cite along the lines of "everyone knows static type systems are awesome"?
03:40:31 <donri> merijn: erlang the movie!
03:42:06 <merijn> donri: That...probably doesn't qualify as a scientifically valid argument :p
03:43:02 <Hafydd> Also a suitable citation for "moustaches are awesome".
03:43:08 <donri> (:
03:47:03 <merijn> oh, this will probably work
03:47:04 <merijn> "Static Typing Where Possible, Dynamic Typing When Needed:"
03:47:05 <merijn> The End of the Cold War Between Programming Languages
03:50:46 <bitemyapp> merijn: Seems fine to be, the bit is getting dynamic lang users to realize uni-types in static langs suffice for what they want from a dynlang.
03:51:04 <bitemyapp> even if it's a terrible, *terrible* way to do the limited polymorphism they actually need.
03:51:31 <merijn> bitemyapp: I don't care about that
03:51:36 <bitemyapp> in Haskell the only real pain I have with static types is where I get confused about a typeclass vs. a concrete type and I have to add an expression to make some monad whosawhatsit do what I want.
03:51:37 <mateioprea> hello, i'm trying to run a site using hakyll and when i run ./site it's saying bind: resource busy (Address already in use)
03:51:52 <mateioprea> because i ran it last night and stoped it with ctrl+c
03:52:00 <bitemyapp> mateioprea: kill the other web server yo.
03:52:01 <merijn> I'm writing an argument about type systems, so I don't want to waste space in my paper arguing that "static types are good" since that a basic assumption of my entire idea
03:52:08 <mateioprea> bitemyapp: how ?
03:52:12 <mateioprea> that's my question
03:52:18 <mateioprea> if i losf | grep 8000
03:52:19 <bitemyapp> mateioprea: maybe you need a unix tutorial?
03:52:28 <bitemyapp> are you sure that's the port ./site is trying to bind?
03:52:30 <mateioprea> doesn't echo any output
03:52:34 <mateioprea> yes
03:52:54 <mateioprea> the site it's working on 0.0.0.0:8000
03:53:10 <bitemyapp> mateioprea: that's not the proper way to use lsof.
03:53:17 <mateioprea> oh
03:53:17 <bitemyapp> mateioprea: you want `lsof -i :8000`
03:53:23 <bitemyapp> mateioprea: so yeah, you need a linux tutorial.
03:53:28 <mateioprea> :))
03:53:30 <mateioprea> thanks !
03:53:35 <bitemyapp> kmateioprea: there's a site
03:53:52 <bitemyapp> damn mis-enter, there's a site that records some useful Linux command-line patterns/tricks
03:54:00 <bitemyapp> using them as a way to grok how things actually work isn't a bad idea.
03:54:13 <mateioprea> well ... can u tell me the site, then ? :)
03:54:21 <mateioprea> please.
03:55:03 <epta> No 7.8 in 2014?
03:55:13 <bitemyapp> mateioprea: you need to get used to googling mate. http://www.commandlinefu.com/commands/tagged/361/lsof
03:55:30 <bitemyapp> mateioprea: I don't mean that to put you down, it's just a really useful skill and more productive than asking questions 99% of the time.
03:55:40 <bitemyapp> epta: oh god please don't say that.
03:56:58 <mateioprea> i am googling things :). but i thought that it will work with grep.
03:56:59 <mateioprea> :)
03:57:04 <mateioprea> that's all
03:57:11 <bitemyapp> lsof does work with grep, you just didn't read the manpage to lsof.
03:57:24 <mateioprea> well, i admit that i didn't do that.
03:57:36 <mateioprea> i thought that lsof | grep something it will work.
03:57:49 <bitemyapp> mateioprea: Linux and Unix are not nice to people that don't read.
03:58:05 <bitemyapp> I suggest printing the manpages and keeping a stack in the bathroom.
03:58:17 <mateioprea> and i thought it's an error from me, or something. or that i have to stop the server in another way
03:58:24 <bitemyapp> you'll learn something new everytime you go the bathroom, it'll be great.
03:58:31 <mateioprea> :))
03:58:35 <mateioprea> thanks for the advice
03:58:36 <mateioprea> haha
03:59:18 <maxs_> simplify (maybe mempty id x) ? :)
03:59:35 <maxs_> x :: Monoid a => Maybe a
04:00:58 <bennofs> @ty fromMaybe mempty
04:00:59 <lambdabot> Monoid a => Maybe a -> a
04:01:11 <bennofs> @ty F.fold
04:01:12 <lambdabot> (Foldable t, Monoid m) => t m -> m
04:01:14 <maxs_> ah thanks
04:01:27 <bennofs> maxs_: Maybe is a Foldable
04:01:41 <bennofs> @ty F.fold `asAppliedTo` Nothing
04:01:42 <lambdabot> Monoid b => Maybe b -> b
04:02:59 <maxs_> clever :P
04:04:49 <epta> @hoogle asAppliedTo
04:04:49 <lambdabot> No results found
04:05:37 <ClaudiusMaximus> :t asAppliedTo
04:05:38 <lambdabot> (a -> b) -> a -> a -> b
04:06:46 <epta> Looks like const
04:06:56 <Axman6> Gorroth: how're you finding it? (yes I know you spoke hours ago :P)
04:07:41 <donri> :t F.fold `const` Nothing
04:07:42 <lambdabot> (Foldable t, Monoid m) => t m -> m
04:07:58 <Axman6> epta: it's purely there for use with :type generally
04:08:02 <donri> (;
04:08:44 <donri> :t F.fold `asTypeOf` maybe mempty id
04:08:45 <lambdabot> Monoid m => Maybe m -> m
04:09:39 <merijn> epta: asAppliedTo *is* const (with a slightly different type signature) :)
04:10:02 <donri> :t const `asTypeOf` asAppliedTo
04:10:03 <lambdabot> (b -> b1) -> b -> b -> b1
04:10:40 <Komier> mornin
04:11:05 <Axman6> :t (+) `asAppliedTo` (7 :: Integer)
04:11:06 <Axman6> wow
04:11:06 <Axman6>    much timeout
04:11:06 <lambdabot> Integer -> Integer -> Integer
04:11:08 <bitemyapp> hrm.
04:11:08 <bitemyapp> wtf is going on.
04:11:18 <Axman6> so netsplit
04:11:20 <bitemyapp> jfc
04:11:28 <bitemyapp> sigh FreeNode.
04:12:30 <donri> :t asAppliedTo `asTypeOf` const
04:12:31 <lambdabot> (a -> b) -> a -> a -> b
04:23:30 <klrr_> if you have multiple version of a package and by that get strange type errors, how do you go to fix them? i dont find any way to unintsall a package using cabal
04:24:08 <merijn> klrr_: Cabal doesn't do uninstallation
04:24:26 <merijn> klrr_: You can use "ghc-pkg unregister" but that will break anything depending on the version you remove
04:24:28 <bennofs> ghc-pkg unregister <some package here> lets GHC forget a package
04:24:53 <dcoutts__> klrr_: you must be using ghc/ghci directly rather than building via cabal. So the trick is to specify the versions of packages you want on the command line, or to hide the ones you don't want via ghc-pkg hide ${pkgid}
04:25:50 <dcoutts__> klrr_: e.g. if you had two versions of bytestring & text, you would specify -package bytestring-0.9.2.1 -package text-0.11.2.3  (or whatever specific ones you want)
04:25:58 <epta> What is asTypeOf for?
04:26:31 <dcoutts__> klrr_: or if you don't want the other version at all for anything, then unregister it using ghc-pkg unregister
04:28:07 <klrr_> merijn, dcoutts__: okey, thanks
04:28:36 <merijn> epta: Mostly just to inspect how types fit together
04:28:55 <merijn> epta: Also for type coercions using Data.Typeable
04:32:12 <klrr_> hmm, i unregistered the version that was complained about using ghc-pkg, but now i get exact same error
04:35:17 <Dementhor> Hello! .. I have a question regarding Haskell Compiler: I am trying to give my program more memory at compile time (rather then commands line args) and It gives me an error: My code -> {-# OPTIONS_GHC -O2 -with-rtsopts="-H128m -K64m" #-}
04:35:35 <Dementhor> Error: unknown flag in  {-# OPTIONS_GHC #-} pragma: -H128m  unknown flag in  {-# OPTIONS_GHC #-} pragma: -K64m
04:39:13 <Dementhor> so anybody knows why it gives me that CompileTime error?
04:43:32 <merijn> Is there a relevant paper on encoding program invariants in haskell types?
04:45:50 <bitemyapp> merijn: what sort of invariants?
04:46:00 <bitemyapp> merijn: you're talking about like every applied type theory paper in existence
04:46:16 <bennofs> Is it a bad idea to have cabal-install-1.18 without Cabal-1.18?
04:46:28 <bitemyapp> bennofs: definitely doesn't make a ton of sense.
04:49:46 <merijn> bitemyapp: I know
04:50:22 <merijn> bitemyapp: I'm thinking of concretely something that's stretching haskell's type system to far
04:50:39 <bitemyapp> merijn: linear types?
04:50:44 <merijn> bitemyapp: i.e. I already have some stuff on encoding websessions in Idriss types
04:51:07 <merijn> bitemyapp: But since Idriss is dependently typed that's rather easy. I'm looking for something similar, but haskell based
04:51:28 <bitemyapp> merijn: still going to need you to get more specific before I can be helpful.
04:51:29 <merijn> I guess maybe the Kleisli Arrows of Outrageous Fortune paper would suffice?
04:51:58 <merijn> Since that encodes similar properties using indexed monads
04:52:26 <klrr_> anyone know how to fix this version clash? https://gist.github.com/klrr/8181747 i did "sudo ghc-pkg hide bytestring-0.10.0.2" and "sudo ghc-pkg unregister bytestring-0.10.0.2" but i get same error
04:53:22 <bennofs> klrr_: you need to rebuilt aeson against a different version of bytestring
04:53:30 * hackagebot libjenkins 0.2.0.0 - Jenkins API interface  http://hackage.haskell.org/package/libjenkins-0.2.0.0 (MatveyAksenov)
04:54:08 <bennofs> klrr_: The problem is that aeson is linked against bytestring-0.10.0.2, while your program uses a different version of ByteString
04:54:26 <klrr_> okey
04:54:37 <klrr_> so i need to get my program to use bytestring-0.10.0.2?
04:54:53 <bennofs> Yeah, that would work too
04:55:47 <bennofs> klrr_: I think the best way to solve the issue is to package your program as a cabal project
04:56:14 <bennofs> klrr_: IIRC, cabal will deal with it better then
04:56:15 <klrr_> bennofs: i already do that
04:56:42 <bennofs> klrr_: hmmm. So maybe try sandboxes? (If you have cabal-install >= 1.18)
04:57:21 <bennofs> klrr_: Did you install haskell packages using your system package manager?
04:57:39 <klrr_> i put this in my cabal file "bytestring == 0.10.0.2", now i get this error: https://gist.github.com/klrr/8181747 (at buttom)
04:57:58 <klrr_> bennofs: yes, iirc i have done that sometimes, but i mostly use cabal for it
04:58:20 <klrr_> https://gist.github.com/klrr/8181747 (updated)
04:58:26 <dcoutts_> klrr_: can you try something: run cabal install --dry-run, (rather than cabal configure).
04:58:37 <dcoutts_> on your package
04:58:58 <dcoutts_> it should say that it'll reinstall some things to get you a consistent environment
04:59:15 <bitemyapp> merijn: Conor's paper that you mentioned also touches on the advantage of Haskell's design to ML functors.
04:59:26 <bennofs> klrr_: You also have to import Data.ByteString.Lazy, not Data.ByteString, because aeson produces / consumes lazy bytestrings
04:59:39 <klrr_> i need to install "duelcode*" which is the package im writing
04:59:45 <klrr_> (it says)
04:59:54 <klrr_> aa okey
04:59:56 <klrr_> thanks!
05:00:07 <dcoutts_> and that's all? nothing else?
05:00:18 <dcoutts_> oh
05:00:20 <klrr_> dcoutts_: yup, well it says i should update cabal too
05:00:30 * dcoutts_ notices what bennofs said
05:01:09 <merijn> bitemyapp: Maybe, but that's irrelevant to the point I'm trying to argue in my writing atm :)
05:01:10 <klrr_> the purpose of bytestring and text is faster string right? but if you always need to convert them to different lazy and strict and from [Char]'s and back forth doesnt it make it just slower?
05:01:36 <bennofs> klrr_: you should not need to convert between them very often
05:01:36 <quchen> Bytestring is not faster string. It's a sequence of bytes.
05:01:40 <bitemyapp> merijn: fine fine, just saying that he touches on it.
05:01:54 <bitemyapp> klrr_: Text is a smarter and faster string. Bytestring is just bytes.
05:01:59 <klrr_> okey
05:02:09 <klrr_> how would i append a newline byte to a bytestring?
05:02:26 <quchen> There is no newline byte.
05:02:37 <bitemyapp> klrr_: you're trying to use a bytestring like a string. Stop that.
05:02:37 <merijn> quchen: Technically, there is
05:02:45 <quchen> There is a byte sequence that, given a certain encoding, can be interpreted as a newline.
05:02:50 <bitemyapp> merijn: only conventionally, it has no semantic meaning.
05:02:53 <klrr_> how does hPutStrLn work then in bytestring package?
05:02:58 * bitemyapp goes to find his bamboo staff for swatting klrr_ 
05:03:11 <maurer> klrr_: It assumes that the "Ln" part is a '\n' ascii character
05:03:17 <aristid> klrr_: it rottenly assumes an ascii-compatible encoding:)
05:03:26 <aristid> so it won't work for utf-16 outputs
05:03:28 <Guest23893> Is there a way to pass "-" to readProcess like so: readProcess "prog" ["opt1", "file", "-"] []?  If I do so, I get *** Exception: fd:9: hGetContents: invalid argument (invalid byte sequence).
05:03:32 <klrr_> yes and how do i append it? basically, JSON produces bytestrings
05:03:34 <klrr_> aeson*
05:03:39 <klrr_> that is why  i am using it
05:03:46 <bitemyapp> klrr_: why are you trying to shove \n into a JSON dump?
05:03:50 <bitemyapp> that sounds terrible.
05:04:08 <maurer> bitemyapp: He's trying to append it, so it may be for compatibility with some other system
05:04:08 <klrr_> well, then the client know when to stop reading the message the server sends
05:04:16 <maurer> klrr_: Oh, you shouldn't need a newline for that
05:04:31 * bennofs always uses a null byte for that
05:04:33 <klrr_> a EOF perhaps is what i want?
05:04:34 <maurer> klrr_: JSON parsing can tell you when you don't need anymore :P
05:04:42 <quchen> merijn: UTF-16 does not have a newline byte, for example.
05:04:55 <merijn> quchen: Now you're talking text
05:05:01 <klrr_> yeah but my server need to talk against non-haskell clients so i want it to be as standarized format as possible
05:05:17 <maurer> klrr_: Yeah, but standardized format will be a hunk of json most likely
05:05:23 <maurer> klrr_: Not a hunk of json plus a '\n'
05:05:24 <quchen> merijn: No, I'm talking bytestring. 0x0A is not always newline.
05:05:26 <bennofs> A newline byte is not very unique
05:05:27 <merijn> If we're talking ByteString we're talking bytes and the only common interpretation of bytes is ascii
05:05:29 <klrr_> okey, so i should just use hPutStr?
05:05:35 <maurer> klrr_: That is what I woul ddo
05:05:39 <bennofs> What happens if your json data contains a newline byte?
05:05:40 <klrr_> okey, thanks!
05:05:53 <aristid> bennofs: it would be encoded as \n, i think
05:05:55 <merijn> quchen: Or binary in which case the notion of newline is nonsensical
05:05:57 <aristid> hmm
05:06:00 <bitemyapp> klrr_: word to the wise, fucking with data whose encoding you don't seem to understand - not the best idea.
05:06:02 <quchen> merijn: Right.
05:06:10 <aristid> doesn't json standardise on utf-8?
05:06:21 <klrr_> bitemyapp: i just want to make a game :s
05:06:30 <bitemyapp> aristid: no
05:06:48 <bitemyapp> aristid: it is desired and expected that a JSON parser will "tolerate" UTF-8 but there is no standard encoding.
05:07:22 <aristid> oh
05:07:49 <aristid> go, shift-jis-json!
05:08:36 <bitemyapp> aristid: for example, UTF-16 and UTF-32 are explicitly mentioned in the JSON RFC, but the notion is that you'd escape them.
05:08:52 <bitemyapp> aristid: which leads to some weird fucking scenarios if you're using a podunk JSON library in Java.
05:09:03 <aristid> escape them?
05:09:17 <bitemyapp> \uD834\uDD1E
05:09:23 <klrr_> okey, how do i figure out how much bytes to read? (im trying to figure out how to use hGet from bytestring)
05:09:50 <merijn> quchen: Many "byte" protocols on the network are "just bytes" but their protocol values tend to be ascii strings (for programmer ease) so talking about them as ascii strings is sensible in that context (which occurs frequently when using ByteString)
05:09:54 <bitemyapp> aristid: this stuff is madness, as was the UCS-2/UTF-16 debacle. I really wish we could just get everybody to use UTF-8 only.
05:10:47 <maurer> klrr_: What kind of a handle are you reading from?
05:10:52 <maurer> klrr_: Is this a network socket? A file?
05:10:59 <maurer> klrr_: Is this json object the only thing in the file?
05:11:59 <quchen> merijn: Sure, I know. But that you have an implicit assumption of ASCII here kind of supports my argument. I agree that for many scenarios ASCII bytes might work, but not for all. That's why you should be very careful with always assuming this correspondence.
05:12:25 <quchen> It's like knowing that == on Double is very often a bad idea, but not always. :-þ
05:12:38 <maurer> klrr_: Basically, as long as you are not reading off a stream, or doing something complex with IO management, the easy way to do it would be to just lazily read the file and then run the parser over that
05:12:47 <maurer> klrr_: Rather than worrying about how many bytes there are
05:18:29 <epta> merijn: could you please show example when `asTypeOf' is useful?
05:24:29 <merijn> > cast 1 `asTypeOf` Just (3 :: Int) -- Imagine that this is inside a polymorphic function and 1 and 3 are values of different types and I don't know at compile time what they are
05:24:30 <lambdabot>  Nothing
05:24:38 <merijn> > cast (1::Int) `asTypeOf` Just (3 :: Int) -- Imagine that this is inside a polymorphic function and 1 and 3 are values of different types and I don't know at compile time what they are
05:24:39 <lambdabot>  Just 1
05:25:32 <bennofs> @hoogle (a -> Maybe a) -> a -> [a]
05:25:32 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
05:25:32 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
05:25:32 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
05:25:41 <bennofs> Is there a function like this?
05:25:58 <bennofs> Implementation would be iterateMaybe f = iterate (fmap (join (,)) . f)
05:26:11 <quchen> bennofs: unfoldr?
05:26:22 <bennofs> eh, I meant unfoldr in my implementation of iterateMaybe
05:26:25 <bennofs> @ty unfoldr
05:26:26 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
05:32:44 <aspidites> hello
05:33:09 <aspidites> do ghc extensions ever get moved into haskell proper?
05:33:28 <mauke> yes
05:33:57 <merijn> aspidites: Just look at the changes in Haskell2010
05:34:08 <merijn> aspidites: Although many people think the haskell report is overly conservative
05:35:05 <merijn> See
05:35:06 <quchen> Let's see what Haskell 2014 brings. I could imagine BangPatterns, LambdaCase and MultiWayIf to become standard. And those are just really small extensions.
05:35:10 <merijn> @quote lexical.syntax
05:35:10 <lambdabot> cmccann says: I still kind of expect that the next standard will be haskell2017 or something, and all it will do is a minor change to lexical syntax of comments that fixes nothing but nevertheless breaks 20% of hackage.
05:36:09 <aspidites> interesting. my biggest thing is that (like a lot of people i presume) despite having studied haskell for a while, i'm only now starting to grok it, and its come to the point where most production code I see has extensions
05:36:17 <merijn> aspidites: Most GHC extensions are thoroughly tested and stable, though. So unless you have a compelling reason to support non-GHC compilers, I wouldn't worry about them
05:36:45 <aspidites> so i was wondering if there was maybe a "core set" that would be smart enough to learn first
05:36:55 <merijn> aspidites: Compare Python where CPython is the "reference" implementation. Not using GHC extensions for production code is similar to not using python features that only exist in CPython
05:37:18 <merijn> aspidites: It makes sense if you care about portability between python platforms, but if you don't, why make your life more difficult
05:37:39 <aspidites> merijn: very apt point
05:38:07 <aspidites> howd you know I was a python guy? i guess python is ubiquitous enouh, huh?
05:38:19 <merijn> aspidites: Some interesting extensions to learn about are: GADTs (has a good wikibook chapter), Rank2Types/RankNTypes, ScopedTypeVariables
05:38:35 <merijn> aspidites: I just assume anyone is at least familiar enough with python to grok the analogy :)
05:39:00 <donri> isn't it sort of weird that the FFI is h2010 though, what about e.g. js backends?
05:39:14 <merijn> aspidites: TypeFamilies and DataKinds are neat, but really a sort of "advanced" topic
05:39:35 <donri> sure you can emscripten those parts but shouldn't the standard be "things not too hard to implement properly"? :P
05:39:39 <aspidites> its funny really. i started with ruby, moved to python because of packaging frustrations with ruby (and performance), chanced upon haskell because of the lyah similarity to why's poignant guide. my head exploded and i went back to python
05:39:39 <merijn> aspidites: If you just wanna learn neat things and don't care about direct "real world" applicability, take a look at those too
05:40:08 <aspidites> erlang's syntax made me depressed, then i found elixir -- all the do/ends made me angry, so i decided to learn haskell again
05:40:10 * DarkFox :: Either Human Program
05:40:16 <merijn> aspidites: (Although, to be fair I do use GADTs and TypeFamilies for lots of "real world" stuff, but it's not always directly obvious how you'd use them)
05:40:55 <aspidites> merijn: will probably start with GADTs, RankNTypes, and ScopedTypeVariables since those do seem pretty popular
05:40:55 * donri :: (Intelligence, Void)
05:41:09 <DarkFox> donri: Your nick doesn't start with capital ::O
05:41:10 <aspidites> especially seems like a lot of talk lately about RankNTypes on reddit
05:41:26 <merijn> aspidites: "Fun with Type Functions" is the paper about TypeFamilies, it should be fairly easy to read at intermediate haskell level (i.e. once you have a decent grasp of the things covered in LYAH)
05:41:39 <bennofs> a value of type donri doesn't exist ? :O
05:41:45 <donri> (:
05:41:53 <DarkFox> bennofs: Seemingly so
05:42:03 <DarkFox> bennofs: Or is infinite of null?
05:42:14 <aspidites> except, can't you type a variable? -> x :: Int
05:42:29 <DarkFox> aspidites: You mean "lower" case?
05:42:34 <aspidites> such that donri :: (Intelligence, Void) would be of type tuple of Intelligence and Void?
05:42:48 <merijn> aspidites: Yes, but Void has no values other than bottom :)
05:42:52 <merijn> aspidites: i.e. "data Void"
05:42:53 <DarkFox> Oh I guess if we go to variable; it doesn't matter.
05:42:54 <DarkFox> Lol
05:42:55 <Komier> merijn: this one : http://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf ??
05:42:57 <aspidites> Ah
05:43:03 <merijn> aspidites: It has no constructors, so you can't make non-crashing values
05:43:10 <donri> technically haskell doesn't have a proper void type so it doesn't quite work
05:43:11 * DarkFox is a data
05:43:19 <merijn> Komier: Yeah
05:43:28 <Komier> merijn: ty will save that for later.
05:43:29 <DarkFox> Undefined but type is set
05:43:38 <aspidites> you know when you've been reading too much haskell when these kinds of conversations make you chuckle
05:43:47 <DarkFox> aspidites: :D
05:43:55 <DarkFox> aspidites :: D
05:44:05 <aspidites> ha
05:44:24 * DarkFox goes back to lurking
05:45:49 <aspidites> my only issue with books is that i'll get so far, get to a point of either non-groking or boredom then stop. then take a break for a week or so and learn that I've forgotten most everything in the chapters leading up to that point
05:46:10 <aspidites> with python (for example), I read the whole tutorial in one sitting. then it was just a matter of reading library documentation for new problem domains
05:47:00 <DarkFox> aspidites: I'm tired enough to have read that as "just a matter of reading a library worth of documentation ..."
05:47:38 <aspidites> which is exactly how I feel when i think about how much reading would be necessary for me to understand haskell
05:48:07 <DarkFox> aspidites: LOL
05:48:13 <DarkFox> It isn't that complicated...
05:48:25 <DarkFox> Just stay on this channel 24/7 and you'll learn a lot
05:49:13 <Komier> This channel helps alot.  I'm a total newbie to programming and Haskell but just being in here the last few days and reading has helped quite a bit.  Also picking up lots of tips and docs for later.
05:49:16 <aspidites> yeah. i hear you guys are pretty patient with newbies -- all 1 million of us
05:49:24 <yyyyy> aspidites: I'm at (I think) leaving beginner to going intermediate and the main issue I face is that when you want to use a library sometimes you have to read some preliminaries - e.g. why is this using a comonad, and what is this thing? why won't it compile without FlexibleInstances?
05:49:38 <maurer> Hey, I'm trying to run cabal install yesod, but am getting dependency issues
05:49:46 <maurer> does anyone have any reccomendations on how to deal with this?
05:49:59 <maurer> (specifically, strategies for revising dependency issues)
05:50:24 <aspidites> maurer: os?
05:50:33 <maurer> aspidites: Linux (gentoo)
05:50:39 <yyyyy> maurer: leave only what you need for most projects installed 'globally' and use `cabal sandbox` to build yesod. you'll get less clashes this way. not an ideal solution but has helped me.
05:50:48 <maurer> yyyyy: I am already using a sandbox
05:51:23 <aspidites> ah. i didn't bother with a sandbox. just made sure that all packagkes were installed local except for ghc and the initial cabal-install version
05:51:39 <merijn> I can say that 1 year of #haskell was more useful than 4 years of university CS :p
05:51:40 <aspidites> usually if i have a dependency error it's always one or two things that cause a cascade of issues.
05:52:24 <aspidites> merijn: i felt similarly about learning a foreign language at DLI - learned 4+ years of college level korean in less than a year
05:52:40 <merijn> yyyyy: The answer to "Why doesn't this compile without FlexibleInstances/FlexibleContexts" is almost always "because the haskell report is stupidly conservative in what it allows for those" :p
05:53:07 <merijn> FlexibleX warnings are one of the only occasions where just blindly following the "add -XFlexibleContexts" instruction by GHC is appropriate
05:53:33 * aspidites reads up on flexiblecontenxts
05:53:37 * hackagebot separated 0.0.1 - A data type with elements separated by values  http://hackage.haskell.org/package/separated-0.0.1 (TonyMorris)
05:53:57 <maurer> Hm, I guess I'll try rebuilding unix, looks like my system unix is very slightly old
05:54:11 <maurer> And cabal is for some reason very against the notion of upgrades or having multiple versions of a library
05:54:19 <merijn> aspidites: By default you're not allowed to have "partially specified" typeclass constraints, i.e. "Foo Int x => Blah x"
05:54:41 <yyyyy> merijn: and this is what i'm doing, though going down the rabbit hole to understand the type checker more throughly is in the todo list :)
05:54:49 <merijn> aspidites: The report says it should by "Foo a x => Blah x", which then of course doesn't work because it can't figure out what "a" is supposed to be
05:55:04 <aspidites> wow
05:55:12 <aspidites> seems like one of those 'should just work' things
05:55:43 <merijn> aspidites: Sure, like I said the report is stupidly conservative there. GHC allows many more things (which is what FlexibleContexts enables)
05:55:47 <aspidites> maurer: do you have a traceback for your latest attempt?
05:56:00 <merijn> aspidites: It's just a "don't be so overly pessimistic/restrictive" extension
05:56:02 <aspidites> seems you should be able to get it installed without resorting to recompiling
05:56:14 <aspidites> then...you're on gentoo, so it might in fact ONLY make sense to recompile
05:57:08 <aspidites> i think my biggest thing is coming up with something to write. with pthon i had a bunch of things i wanted to write which forced me to learn the language. in haskell i'm kina like "well thats cool, now what?"
05:57:17 <donri> merijn: it's sensible to avoid FlexibleInstances though
05:57:20 <maurer> aspidites: http://pastebin.com/x4QAn3L7
05:57:28 <mauke> The paste x4QAn3L7 has been copied to http://lpaste.net/97745
05:57:32 <merijn> donri: Not always
05:57:37 <donri> merijn: it tends to get in the way of type inference
05:57:44 <aspidites> i have an app I want to write, but i'm not a gtk fan (and hs2gtk angers me), and there aren't any current qt bindings (hsqml seems promising, but it's still on 4.8)
05:58:00 <maurer> aspidites: Is there any way to do the equivalent of an "empty" build in a sandbox?
05:58:06 <merijn> donri: With GADTs and phantom types it may not be possible to specify Functor instances, etc. without FlexibleInstances
05:58:07 <Komier> aspidites: wx?
05:58:11 <maurer> aspidites: Where it pretends that your system ghc and user ghc packages are not available?
05:58:15 <aspidites> threepenny...neat idea, but well...i might as well be writing a web app at that point, which isn't my thing
05:58:37 * hackagebot xformat 0.1.2 - Extensible, type-safe formatting with scanf- and printf-like functions  http://hackage.haskell.org/package/xformat-0.1.2 (SeanLeather)
05:58:37 <donri> merijn: sure, i said avoid not "never use" :)
05:58:42 <aspidites> Komier: wx is ugly. and just gtk under the hood on linux
05:59:25 <donri> or maybe avoid means that, i'm not a native speaker...
05:59:49 <maurer> It seems the easiest solution to this, given I'm already using a sandbox, would be some way of informing it to ignore most of my libraries other than e.g. base
05:59:56 <Komier> aspidites: aye fair enough.  I'm a long way off it, but would like to do some GUI programming later on.
06:00:13 <aspidites> maurer: that i'm not sure of. i know theres cabal install world but that doesn't build an independent ghc
06:00:21 <merijn> donri: Avoid implies harmful, but I've never found any harmful problem with FlexibleInstances?
06:00:34 <maurer> aspidites: I don't really want an independent ghc, I was just hoping to drop all the libraries within the sandbox
06:00:40 <merijn> Is Edwin Brady in here sometimes? If so, what nick?
06:00:50 <donri> merijn: depends what you consider harmful. it's mostly that it gets in the way of type inference, leading to ambiguity errors
06:00:52 <haasn> FlexibleContexts is not FlexibleInstances
06:00:58 <Komier> aspidites:  Could write your own library of haskell bindings to Qt?
06:00:59 <maurer> aspidites: For example, I want xmonad installed as a system package, so I have a bunch of dependencies installed for that
06:01:06 <haasn> oh, I see, both were mentioned earlier
06:01:10 <maurer> aspidites: but it would be nice if for development, I could ignore the fact that those are installed
06:01:30 <donri> haasn: i know, but merijn said FlexibleX
06:01:50 <merijn> maurer: That's just the broken behaviour of many linux package managers, they install things globally, which is rather annoying
06:02:06 <donri> merijn: #idris and edwinb
06:02:09 <mm_freak> merijn: edwinb
06:02:31 <maurer> merijn: Sure, but there's no reason I can't have a separate .ghc world just for a directory no?
06:02:37 <yyyyy> merijn: isn't it easier to find him on #idris?
06:02:43 <aspidites> maurer: i agree. just don't know how to do it. now i see why you're asking about dependency tracking. just looking at that traceback i went from a haskell toddler to a haskell fetus
06:02:47 <maurer> merijn: Is there really nowhere I can say "Hey, please ignore the .ghc and the system version of .ghc"
06:03:35 <merijn> yyyyy: I wasn't aware of #idris :p
06:03:37 <aspidites> Komier: Qt is notoriously hard to write bindings for, considering the moc.
06:04:51 <yyyyy> maurer: since you mentioned you're on linux you could use LXC containers for that. on my home box i keep LXC 'vms' ready for many tasks, and one is a blank haskell-platform install that i can revert to if needed for testing.
06:05:01 <aspidites> hsqml i think will be ideal as it doesn't bind to qtwidgets but qml which is declarative. minus the small bit of js i'd have to deal with, i think it'd be a perfect fit for haskell
06:05:18 <maurer> yyyyy: ...so your solution to "I need to have multiple versions of a library installed" is "Use a virtual machine" ?
06:06:05 <tovarish> maurer, today it's the best :D
06:06:09 <yyyyy> maurer: i don't know cabal's internals to fix dependency hell, and whenever i have to put something elsewhere it's on a vm anyway, so... yes :p
06:06:10 <aspidites> i might just have to bite the bullet and write a gtk gui, but years playing with pygobject vs pyqt have me spoiled
06:07:23 <yyyyy> and given the recurrence of comments about this, i think the community as a whole is still figuring out how to fix the dependency issue, so even though i'm a newcomer this seems like a real 'unsolved' issue.
06:08:04 <aspidites> am i right to assume that the dependency hell issue is complicated by type-safety?
06:08:11 <tovarish> yyyyy, my experience, it's a common pb to computer science that will never be solved
06:08:11 <yyyyy> merijn: sorry, i didn't realize it.
06:08:32 <aspidites> i thought i read somethingto that effect in passing
06:08:38 * hackagebot delicious 0.3.4 - Accessing the del.icio.us APIs from Haskell (v2)  http://hackage.haskell.org/package/delicious-0.3.4 (SigbjornFinne)
06:09:06 <deech> Hi all, is there a tool that tests foreign function binding coverage? Writing bindings to a rather large API and want to make sure I haven't missed anything.
06:09:17 <merijn> aspidites: I don't think so
06:09:46 <merijn> aspidites: As someone with a lot of experience using C/C++ code I feel the "dependency hell" in haskell is overblown
06:10:18 <merijn> aspidites: There are some issues, but many people shout "dependency hell" just because they're trying to use libraries with conflicting dependencies
06:10:18 <aspidites> overblown as in its not as big of an issue as it's made out to be, or overblown as in it's way more complicated than it needs to be?
06:10:19 <Komier> aspidites: Again, new to this, but I've seen a few Glade/Gtk2HS  GUI's that didn't look awful.
06:10:46 <merijn> aspidites: Overblown as in, there are issues and they're not hard. But most people *claiming* to suffer these issues actually don't
06:11:19 <yyyyy> tovarish: i wasn't aware of that. my intuition was that somehow we'd either move to a 'capabilities'-based detection based on exported types or to some traversal of dependency graphs, though i imagine that complexity could be a limiting factor.
06:11:27 <merijn> aspidites: cabal is not magic, if your libraries have conflicting dependencies, there isn't much it can do. The JS approach to "dependency handling" is "just copy whatever version works completely into your repo"
06:11:34 <mm_freak> i'm glad that with nixos i don't run into this "dependency hell" anymore…  you can make cabal and nix work together very well =)
06:11:42 <tovarish> yyyyy, the pb is not complexity, the pb is the developpers
06:11:51 <tovarish> the solution is really simple but in40 years they failed
06:11:58 <bennofs> mm_freak: do you use the haskell packages included in nixos?
06:12:00 <tovarish> so i gave up, they will never solve it
06:12:08 <mm_freak> bennofs: yeah
06:12:20 <aspidites> merijn: then why, for example, would it seem that linux distros (and different ones to boot) have solved this problem?
06:12:29 <merijn> aspidites: The earlier problem with linux package managers installing things globally and then not being able to hide them is a problem, though
06:12:47 <aristid> merijn: do you use homebrew?
06:12:50 <aspidites> as for languages (for a more apples to apples comparison, python doens't seem to suffer)
06:12:56 <merijn> aspidites: They "solved" the problem by throwing ridiculous amounts of volunteer hours into manually checking dependencies
06:13:02 <yyyyy> tovarish: if the solution is simple and we're all developers i can't see this not working, unless there's some social factor preventing the change.
06:13:17 <aristid> i think the only package manager that really solves the problem properly is Nix.
06:13:18 <merijn> aspidites: Haskell community is not as large, so there's not enough volunteers to check everything
06:13:29 <merijn> aristid: No, I install the platform binary
06:13:45 <tovarish> yyyyy, don't underestimate the developpers stupidity
06:14:09 <aspidites> then perhaps a notification system is needed? for example, in Arch Linux's AUR, there is a "mark pacakge as out-of-date" button which will send an email to a developer when the versions marked in his package are wrong
06:14:23 <aspidites> or really if the package fails to build for any reason, but i think you see my point
06:14:44 <merijn> aspidites: Sure, but what do you do with small orphaned libraries on hackage?
06:14:51 <merijn> aspidites: i.e. the developer doesn't care anymore?
06:14:59 <aspidites> allow others to adopt them
06:15:11 <merijn> aspidites: That is possible, but that requires volunteers
06:15:24 <merijn> aspidites: For popular packages that's not a problem, but for more obscure ones there is
06:15:44 <aspidites> Arch has TUs (trusted users) whom can be petitioned if a maintainer isn't available to be orphaned for later adoption
06:16:28 <merijn> aspidites: Sure, but arch (presumably, like stuff like macports/homebrew/apt) has maintainers dedicated to just the installation/patching for that specific OS
06:16:36 <aspidites> otherwise, you could at least have some kind of visual notice on the hackage page such that if no one volunteers to orphan a package, a developer would know to either rely on a different package, take ownerhip of the offending package , etc
06:16:49 <yyyyy> merijn: isn't the problem amenable to automatic checking? assume that GHC or cabal throws standardised conflict messages. bring up some build machine(s) and leave them building against possible combinations. sort by downloads or usage in other packages. smaller ones would suffer, but the issue would be mitigated somehow.
06:16:49 <merijn> aspidites: There is no volunteer group doing the same for haskell
06:16:50 <aspidites> merijn: AUR is purely the community. no one dedicated per se
06:17:03 <aspidites> so the cycle might be something like:
06:17:29 <merijn> aspidites: Don't underestimate that the linux community is probably several orders of magnitude bigger than haskell
06:17:53 <timthelion> does anyone know of a blog post where I could read about higher kinded types from an engineering perspective?  I mean, I understand that it's just another lambda calculus. But I want to know what this means to me as a programmer...
06:18:07 <aspidites> voluteer creates package -> if he orphans the package, than someone who depends on his package takes it over (as not to risk his own package becoming obsolet) -> otherwise, he writes an alternative to it such that he no longer depends on that package
06:19:18 <tovarish> yyyyy, do you see it? instead of saying it's not a pb the dev will continue to be dependent of that old package, thne developper is enforced to maintain it
06:19:23 <tovarish> it will never be solved
06:20:29 <merijn> aspidites: Sure, and that happens
06:20:47 <merijn> aspidites: But many people do not like finding out they're the volunteers to maintain a package
06:24:07 <aspidites> power outages are awesome
06:24:51 <Komier> lol
06:25:04 <aspidites> perfect analogy for my journey through haskell -- oh that completely makes --- moment of complete darkness -- sense!
06:25:39 <yyyyy> merijn: i guess if the package is essential to yours then understanding it if it goes stale eases the burden, but i reckon that might be a tough bite. i haven't run into that yet.
06:27:27 <yyyyy> tovarish: how do you think it could be solved?
06:27:35 <aspidites> it's crazy to me that i haven't been able to start a haskell project. i mean, composability seems to logically be motivating enough to think "well, i can make it just work now and make it idiomatic and efficient later without much fuss"
06:28:10 <Komier> aspidites:  Just out of curisoity why is it so much different than when you learned python?
06:28:28 <Komier> aspidites: the finding projcts to work on aspect I mean.
06:29:00 <tovarish> yyyyy, yes but only if we accept to have fully specified dll (with a guid for each compiled version, and the ability to link to as many as we want versions in the same file, in the same line of code)
06:30:31 <aspidites> Komier: probably the difference between imperitive thought process vs a functional one. in python i can say "i need to do a, then b, then c" sequentially. I can't decide on a starting point in haskell
06:31:13 <aspidites> i think a lot of that also has to do with oop -- i keep wanting to model data such that objects take action rather than having objects which are acted upon -- if that even makes sense
06:31:23 <yyyyy> i like aspidites idea to get maintainers notified of stale data.
06:32:08 <aspidites> same reason ive never written a game i think. or anything event based (other than guis which usually lay out those frameworks for you)
06:33:36 <Komier> aspidites:  Might be fun to take one of your old python projects and reimplement it in Haskell.  Try and adjust your thinking one piece at  time for to speak?
06:33:45 <Komier> ^ so to speak
06:34:28 <aspidites> Komier: good point. i have one in mind, but it's too large. ironically it's written in a kind of functional style even -- smaller composable parts
06:35:11 <aspidites> haskell tracebacks frustrate me as well. i'm getting better with them, but for the most part they still look like a wall of hieroglyphs to me
06:35:59 <Komier> aspidites : Bearing in mine my suggestions are coming from a non-programmers point of view.  Previously a "dabbler" (Python, C, messing with micro-controllers kind of deal), attempting to learn Haskell as my first serious language.
06:36:39 <aspidites> eh, i wouldn't really call myself a programmer. most of the code i've written has been contributions to other open-source projects.
06:37:38 <aspidites> now that i think of it, there is at least one project that we've been meaning to rewrite and never got around to. if i was going to help with a rewrite, i might as well do it in haskell for kicks
06:37:47 <Sculptor__> aspidites, people who draw 3d objects in cam/cad softwares and extract G code for CNC call themselves programmers. so, why wouldn't you
06:38:27 <aspidites> Sculptor: lol. because I haven't done so in a professional environment, nor do I have a degree (or certificates) to show for it
06:39:25 <aspidites> hmm...i really like SFML's (python) interface, but helm might be a great excuse to learn FRP at the same time
06:39:45 <aspidites> or i wonder how hard it would be to write the sdl2 parts of helm in sfml?
06:40:05 <merijn> aspidites: hah
06:40:13 <d3lxa> if I have a function like: [ forall a. Field a ] -> … -> FormResult [ forall a. Field a ] then the two lists could have different type element-wise right, moreover I would need a cast from the caller to regain the types, is there a better+safer way?
06:40:30 <merijn> aspidites: I spent 4 years of my time in university thinking I wasn't "good enough" to be a real programmer
06:40:41 <d3lxa> oh sorry the second -> is not Field a but just a, that is: [ forall a. Field a ] -> … -> FormResult [ forall a. a ]
06:40:45 <merijn> aspidites: Then I took a sysadmin job and saw what kind of crap gets deployed on production systems
06:40:58 <merijn> aspidites: Now I no longer worry and think myself overqualified :)\
06:41:13 <aspidites> random: as often as people say category theory (or mathematics in general) isn't needed to learn haskell, I can't help but think that knowing it would help build an intuition for how to think like a haskeller (so to speak)
06:41:42 <aspidites> merijn: in other words, I should just get on http://indeed.com or similar and accept a sysadmin job somewhere? ;-)
06:41:58 <merijn> aspidites: There's people out there running databases with financial information (tracking the money left on digital gift cards, to be precise) and not doing proper backups
06:42:41 <aspidites> or dice.com rather
06:42:44 <merijn> aspidites: During my sysadmin time that database got corrupted and they had to roll back to a backup. The most recent backup was 8 days old, thereby recrediting everyone who had spent money since then and invalidating all gift cards sold in the past 8 days.
06:42:58 <merijn> aspidites: That's the kind of "production quality" you encounter in real life
06:43:33 <zomg> I once worked with a system that dealt with credit cards
06:43:41 <merijn> aspidites: As someone who considers themselves an advanced haskeller: I understand jack all about category theory
06:43:42 <aspidites> merijn: fastforward to today and the target fiasco
06:43:43 * hackagebot zeromq4-haskell 0.1 - Bindings to ZeroMQ 4.x  http://hackage.haskell.org/package/zeromq4-haskell-0.1 (ToralfWittner)
06:43:44 <zomg> It wasn't supposed to, because it was just a quick hack
06:43:54 <zomg> but there you had hundreds of credit card numbers in their database
06:44:01 <zomg> running on amazon somewhere
06:44:06 <zomg> no security whatsoever
06:44:22 <aspidites> zomg: given your story, i think your nick is quite appropriate
06:44:27 <zomg> hah =)
06:44:40 <Komier> true that.  I've seen hobby projects turn out better than some of the proprietary software turned out by their supposed "best in field" programmers.
06:44:44 <dmisback> Question: What's the advantage of Haskell over just using pure functions 99% of the time in a imperative language like C# ?
06:44:49 <Komier> at the company i work fo
06:44:50 <merijn> aspidites: anyway, I wouldn't worry so much about what it takes to be a "real" programmer ;)
06:44:59 <zomg> but yeah, reality is unless you somehow find a team that actually cares about code quality.. the stuff that gets deployed tends to be kind of crap
06:45:00 <merijn> dmisback: The type system of haskell is much nicer
06:45:08 <tovarish> dmisback, there is no equivalent to class in C#
06:45:18 <zomg> those teams do exist but for each of them there's probably at least 10 teams that need to be hit with a cluebat repeatedly
06:45:22 <merijn> dmisback: Also, first class IO is nice, which doesn't really exist in other languages
06:45:39 <bennofs> dmisback: I'd guess that pure functions in C# won't be optimized as good as in Haskell
06:46:03 <dmisback> so would it be fair to say that haskell just forces you into a better programming mindset, but you can effectively get the same result in any imperative language if you're disciplined?
06:46:39 <bennofs> In imperative languages, copying is often more expensive so a pure style doesn't work sometimes.
06:46:40 <zomg> dmisback: sure, but your result in some other lang would probably involve more code to achieve the same result with less guarantees that it actually does what you think =)
06:46:55 <merijn> dmisback: I don't think so. Algebraic DataTypes, proper parameteric polymorphism and first class are IO are something that you can't really retrofit
06:47:32 <zomg> You can certainly try to emulate FP practices in other languages but I think it just works better in Haskell
06:47:40 <aspidites> so haskell is why i understand list comprehensions in python -- but i write better ones in haskell -- but apparently shouldn't be using them in haskell because of pattern matching, guards, etc
06:47:42 <aspidites> ugh
06:47:44 <merijn> dmisback: Unless you mean the silly trivial "everything is Turing complete so I can do everything in any language" kind of "effectively", but that seems a rather silly position to take
06:47:58 <merijn> aspidites: It's not so much that you shouldn't use them
06:48:10 <zomg> I think the best example for haskell is really the fact that I've been coding in a variety of languages and I rarely miss any of their features when working with Haskell
06:48:13 <merijn> aspidites: Personally I just don't really see that many cases where they improve the code :)
06:48:18 <zomg> But when working with some other language, I tend to miss haskell features
06:48:25 <merijn> zomg: Word.
06:48:33 <aspidites> merijn: to your mother
06:48:56 <merijn> aspidites: She doesn't understand haskell :p
06:49:07 <aspidites> even better since Word is a type
06:49:07 <tovarish> zomg, i miss the non recursive behavior of ocaml when coding in haskell :)
06:49:10 <merijn> Nor Vanilla Ice, I think
06:49:37 <aspidites> merijn: shame and blessing -- haskell/ vanilla ice wrt your mother
06:49:43 <zomg> tovarish: I think I might've tried to use ocaml maybe once and that was way before I ever learned haskell and didn't really have the patience to learn at that time :D
06:50:00 <Komier> funny you mentioned pattern matching and guards vs list comps actually.
06:50:03 <aspidites> i read some ocaml stuff. just didn't appeal to me
06:50:10 <Komier> I have been debating that with myself and LYAH this morning lol
06:50:16 <merijn> ocaml syntax is ugly, it's a French thing
06:50:18 <tovarish> zomg, you can write in ocaml let i = i + 1 in and that's one of the rarer language where the second i ts not the first
06:50:21 <tovarish> relly cool feature
06:50:33 <aspidites> can't explain why. like it seems easier to gain traction on, but i'm like "but it's not haskell, and if it's not haskell, i'm going back to python"
06:50:35 <merijn> Same goes for Coq :p
06:50:53 <merijn> aspidites: In my experience ocaml is actually worse
06:51:06 <merijn> aspidites: (I say this having TA'ed ocaml to CS students 2 years in a row)
06:51:18 <merijn> aspidites: The easy escape hatch causes them to write really dumb things in ocaml
06:51:18 <aspidites> btw, i've coded in python once since my last  venture into haskell. my mind is stuck on this "if i don't code in haskell, i'm not coding at all" mindset
06:51:39 <aspidites> which subsequently means i might have retired early from open source development ;-)
06:51:39 <yyyyy> Coq truly looks awful, but most of the code makes an attempt to look readable. Agda code in comparison is proud to use as many Unicode codepoints as possible.
06:52:06 <aspidites> Coq is too freudian for me to bother with
06:52:15 <aspidites> and i'm too juvenile...
06:52:16 <tovarish> too freudian ?
06:52:20 <aspidites> wanna see my coq?
06:52:21 <zomg> VB6 for lyfe
06:52:26 <aspidites> my coq is better than yours?
06:52:31 <Axman6> everyone loves coq
06:52:33 <dmisback> I'm just asking because I've always intuitively known that using functions that don't change state is the "best" way... I'm running through a haskell tutorial know and debating whether it's worth the effort to becoming proficient in a language that just forces me to keep to practices I'm aware of.
06:52:33 <tovarish> aspidites, in France coq means only the chicken
06:52:42 <aspidites> etc
06:52:44 <tovarish> (and it's the name of the author)
06:52:46 <dmisback> *already aware of
06:53:13 <aspidites> tovarish: even worse. as a black guy, i couldn't seriously use a programming language named chicken without too many stereotypical puns being made
06:53:35 <zomg> dmisback: I'd say yes, because the language requires you to think in a quite different way in general vs. working with something like OO languages
06:53:42 <tovarish> aspidites, ...
06:53:45 <yyyyy> aspidites: then think it's called rooster. names are of no consequence.
06:53:58 <bennofs> dmisback: Haskell has other nice things, like IO using monads and laziness
06:54:20 <tovarish> lazy i what I miss the more when not doing Haskell
06:54:29 <zomg> dmisback: plus I think the language also exposes you to a variety of interesting techniques/things that don't necessarily exist (or at least not as visibly) in other languages
06:54:45 <aspidites> pretty neat that it's a cognate
06:54:56 <aspidites> coq = cock (rooster)
06:55:06 <tovarish> exactly
06:55:17 <yyyyy> thank the normans.
06:55:22 <Komier> never as waste of time to learn something new.
06:55:23 <aspidites> to be honest, i thought it was called cog for the longest time -- which seemed cool -- gears on a clock turning
06:55:54 <dmisback> ok thanks. I'll dump about 10 hours into it and see where it takes me.
06:56:04 <yyyyy> aspidites: try this -> http://adam.chlipala.net/cpdt/
06:56:27 <aspidites> as soon as i saw 'proof' i got nervous
06:56:40 <aspidites> not a math guy. i'm good at math, but it's not anything i've really ever focused on
06:56:45 <tovarish> but coq is not turing powerfull
06:57:10 <merijn> dmisback: I would argue the "don't change state" is one of the least interesting thing about Haskell :)
06:57:24 <merijn> dmisback: I think the type system, laziness and ADTs are actually much more interesting
06:57:49 <aspidites> rant -- i miss chrom(ium)s pdf viewer -- too bad they insist on removing features every release
06:58:20 <tovarish> google removed their pdf viewer for chrome... that's good news
06:58:35 <bennofs> aspidites: there is an addon that brings pdf.js back
06:58:35 <aspidites> no.. didn't mean to link those statements
06:58:36 <yyyyy> aspidites: think of a proof as simply a program stating something. there are techniques in the same way as there are design patters for other languages, and they're not that mysterious - though a few take time to sink in, at least for me.
06:59:19 <aspidites> what they removed was system borders, so i was stuck with exactly one program that had a close button and borders -- i'm on a tiling window manager so appreciate consistency, minimalism and screen real estate
06:59:51 <aspidites> pdf.js is firefox i thought -- which is still very much around. one thing it does better than libpdf (google chrome) is allowo you to see the table of contents
07:01:41 <aspidites>  really, i can't wait until mozilla servo is released.
07:02:31 <bennofs> There is an addon for chromium which provides pdf.js :)
07:03:39 <aspidites> anyway, back on topic - is there a good article on types and type classes that maybe discusses designing them. i understand the basics but it seems like whenever i write a type signature, i either forget a type classes (eg Ord, or using Num instead of Integer).
07:04:06 <aspidites> just seems that there's got to be a more effecient way of working than to write the body and calling ":t <foo>" in ghci
07:04:18 <Komier> Newbie question incoming : Is a function type/definition supposed to tell you what the function does, without having to read the subsequent code?  Or is it just a way of stating explicitly the type, to avoid the compiler getting confused.
07:05:05 <bennofs> Komier: both. It helps the compiler to produce better error messages but can also serve a bit as an hint for readers of the code
07:06:27 <tovarish> Komier, sometimes you made a msitake in your function but the error pop up only in another function, because you're former function has just an incorrect type
07:06:39 <tovarish> and it could take time to understand it and localize the problem
07:06:40 <geekosaur> in theory you can specify the type well enough to describe what the function does. in practice, haskell's type system is not quite up to it (see also: Agda) and there are some things that are hard to capture in types
07:06:51 <tovarish> if you ensure the type, when the function compile you're sure of it's type
07:07:06 <geekosaur> but specifying your types keeps the type inference engine from inferring wtfs
07:07:40 <geekosaur> (like "oh, that will work if I assume there's a Num instance for <some random not even remotely number-like thing>")
07:08:05 <aspidites> Komier: sort of related: http://www.youtube.com/watch?v=52VsgyexS8Q&list=PLxj9UAX4Em-JAlFhJzVDK1UlveVh7coZZ
07:08:16 <Komier> haha ok thanks guys.  I was just curious, as it seems to me you would only get a hint as to what it does from the type definition, unless you know the intended purpose of the function or can read the subsequent code.
07:08:47 <Komier> aspidites: Thanks, watching now.
07:09:12 <geekosaur> free theorems, djinn
07:09:49 <bennofs> @djinn (a -> b) -> (b -> c) -> a -> c
07:09:50 <lambdabot> f a b c = b (a c)
07:10:06 <geekosaur> just having a type signature *can* specify pretty well what a function does. example: just given the type of `map` you can pretty much tell what it does
07:10:17 <sipa> :t map
07:10:18 <lambdabot> (a -> b) -> [a] -> [b]
07:10:26 <geekosaur> especially if you phrase it as ((a -> b) -> ([a] -> [b]))
07:10:38 <bennofs> @djinn (a -> b) -> [a] -> [b]
07:10:38 <lambdabot> Error: Undefined type []
07:10:40 <bennofs> :|
07:10:42 <geekosaur> (which is the same thing with one redundant set of parentheses)
07:10:58 <aspidites> :t zip
07:10:59 <lambdabot> [a] -> [b] -> [(a, b)]
07:10:59 <sipa> two
07:11:01 <geekosaur> yes, @djinn in lambdabot is a bit limited
07:11:04 <Komier> yeh that one is easy to read.
07:11:05 <aspidites> well that's spiffy
07:11:18 <aspidites> :t aspidites
07:11:19 <lambdabot> Not in scope: `aspidites'
07:11:21 <geekosaur> sipa, the outer set is only to separate the type from the text
07:11:31 <sipa> semantics!
07:11:35 <geekosaur> roughly the same as my use of `` in `map`
07:11:47 <Komier> what about one like replicate, do you not find that slightly more ambiguous?
07:11:52 <bennofs> @ty aspidites
07:11:53 <lambdabot> IO ()
07:12:05 <Komier> or is it just me being new to the language
07:12:10 <bennofs> @ty replicate
07:12:11 <lambdabot> Int -> a -> [a]
07:12:15 <Komier> replicate :: Int -> a -> [a]
07:12:19 <geekosaur> yes, not all type signatures give rise automatically to a specific interpretation
07:12:45 <geekosaur> in theory you could specify a type which would be unambiguous. in practice haskell can't always do that. agda can do so in more cases
07:12:53 <aspidites> 39 lines of sdl in helm. not bad at all
07:13:09 <mirpa> Would you rather recommend 'data T = A | B | ... | Z' or 'newtype T = T Int32' where Int32 should be some game setting?
07:13:13 <geekosaur> (specifically, you could specify that the [a] has a length set by the first parameter, which *is* pretty obvious)
07:13:51 <geekosaur> (in Agda. not in Haskell without a lot of pain)
07:14:07 <geekosaur> (and hairy ghc extensions)
07:14:31 <geekosaur> mirpa: depends on how (and maybe how often) it's used
07:15:16 <geekosaur> if the Int32 is round-tripping to C a lot, I'll probably prefer that although I may also provide a nicer Haskell wrapper if I can't mostly hide the Int32
07:16:03 <hub2> Hi, Is a typeclass something like Interface in object oriented programming?
07:16:13 <geekosaur> yes and no
07:16:36 <mirpa> geekosaur: Int32 is usually red from binary format used by some C++ code but I don't require to encode it back ... it is used internally
07:17:16 <geekosaur> then I would probably deal with its Int32-ness in the serialization code and use a sensible Haskell type elsewhere
07:17:23 <Guest82322> Is there a command like 'system' which returns a string as well as an exit code?
07:17:26 <mirpa> I am asking whether data constructor will use more memory than Int32
07:17:35 <Komier> hub2: http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101
07:17:54 <geekosaur> mirpa: probably less
07:18:17 <geekosaur> since the Int32 is internally (constructor,value) whereas the T is just (constructor)
07:18:41 <mirpa> ...so it should not hit performance
07:19:12 <aspidites> i love when a ghc-pkg check goes well
07:19:16 <geekosaur> it shoudln't, but space usage and performance can be unrelated...
07:19:27 <geekosaur> or worse,  inversely related
07:19:52 <mirpa> hmmm ... so just measure it then
07:19:56 <mirpa> ok
07:20:00 <mirpa> thanks
07:20:20 <geekosaur> Guest82322, http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/process-1.1.0.2/System-Process.html#v:readProcessWithExitCode
07:28:04 <aspidites> i think documentation is another barrior to entry in me starting to write haskell code. seems like i haven't quite built muscle memory for what returns legit results in hoogle (or how best to interpret those results)
07:28:56 <aspidites> for comparison, in python you'll not only get a function signature, but an example of that function being used in a small code example. seems everything i search for in haskell (hoogle) just gives me a function signature
07:29:12 <aspidites> perhaps that should be good enough, but it's not sparking any fires for me
07:29:29 <tovarish> aspidites, usually hoogle give you a link to the doc of the function wich contains anything you need to use it
07:29:43 <tovarish> (usually)
07:29:50 <tristan_1> if you go to the haddocks for the function you often get examples
07:29:56 <tristan_1> right, what tovarish said
07:30:43 <aspidites> thanks tovarish and tristan_1
07:30:58 <aspidites> seems like the latest cabal broke documentation (auto-generation)
07:31:11 <aspidites> at least for the couple of packages i was looking for.
07:32:15 <aspidites> well looks like the couple i was looking at have been fixed
07:33:03 <hub2> So what's the difference between typeclass and OOP Interface? Can typeclasses have some generic implementation?
07:33:05 <aspidites> still not too helpful -> http://hackage.haskell.org/package/helm-0.5.0/docs/FRP-Helm.html of course, i think thats more to do with batteries being included in python which means more cnsistent documentation for packages. i suppose i'd observe similar disparity between 3rd party packages on python
07:34:41 <merijn> hub2: There are several
07:34:54 <geekosaur> hub2: the biggest difference is less with typeclasses themselves as with the fact that types are in some sense "backwards" between OOP and Haskell
07:35:24 <aspidites> hub2: http://stackoverflow.com/questions/8122109/difference-between-oop-interfaces-and-fp-type-classes
07:35:31 <merijn> hub2: 1) typeclasses can have polymorphic values, interfaces can't, 2) typeclasses can be polymorphic in the result, instead of only in function arguments and 3) typeclasses can express polymorphic relations which interfaces can't
07:35:42 <merijn> :t maxBound
07:35:43 <lambdabot> Bounded a => a
07:35:50 <geekosaur> if you say that something returns (X a => a), in an OOP language that would mean you get to pick the instance, in Haskell it means *the caller* gets to pick it
07:35:54 <merijn> hub2: For example of 1, see maxBound/minBound
07:36:00 <merijn> > maxBound :: Char
07:36:01 <lambdabot>  '\1114111'
07:36:03 <merijn> > maxBound :: Int
07:36:04 <lambdabot>  9223372036854775807
07:36:31 <Guest23552> Anyone used Shelly? How can I convert String into FilePath?
07:36:50 <merijn> hub2: An example of 2: "read :: Read a => String -> a" here the polymorphism is in the value returned, not in the arguments provided
07:36:57 <klrr_> maurer: how would i do that?
07:38:08 <geekosaur> Guest23552: I see it's an instance of IsString, so fromString should work
07:38:09 <merijn> hub2: And 3) "(==) :: Eq a => a -> a -> Bool" this specifies both a's are the exact same type. Compare with having an "Eq" interface and "compare(Eq x, Eq y)", since these accept any subclass of Eq, there's no way to enforce that x and y are the same type
07:39:38 <merijn> hub2: OOP interfaces are not a terrible first approximation of typeclasses, but it's the subtle details that will trip you up if you think they are the same
07:39:50 <merijn> (first approximation in terms of understanding, that is)
07:41:07 <hub2_> I'm sorry. I lost connection, could you sent that one more time?
07:41:31 <Guest23552> geekosaur: Thanks! And how can I extract the text from the output of run or cmd?
07:43:05 <charlie_sanders> ,erijin:  hub2_: And 3) "(==) :: Eq a => a -> a -> Bool" this specifies both a's are the exact same type. Compare with having an "Eq" interface and "compare(Eq x, Eq y)", since these accept any subclass of Eq, there's no way to enforce that x and y are the same type
07:43:05 <ij> hub2_, I sent them to you in a PM.
07:43:32 <merijn> hah, so did I :p
07:43:38 <merijn> And several 100 others :p
07:43:38 <ij> :)
07:43:57 <ij> Well, at least now we're sure he got them.
07:44:00 <Guest23552> What's wrong with Hayoo, by the way?
07:44:06 <geekosaur> uh, that sounds like "how do I get (x) out of (IO x)" and the answer is you don't, you use >>= (or -|- as appropriate)
07:44:26 <Guest23552> geekosaur: Ah, OK.
07:44:26 <geekosaur> the usual :( it's usually down weekends (and immediately after) until someone kicks it
07:45:35 <aspidites> has any progress been made toward offering an objective comparison of frp frameworks?
07:45:49 <aspidites> i see the idea was raised on reddit a month ago, but nothing following -> http://www.reddit.com/r/haskell/comments/1qen2k/elerea_grapefruit_netwire_reactivebanana_sodium_a/
07:46:49 <aspidites> all i've gathered is that reactive-banana is idea for gui applications (threepenny and wx). i know helm uses elerea and that its simple (sparse use of ghc extensions). beyond that i'm lost
07:47:20 <aspidites> i guess netwire uses an internal DSL, which only concerns me because i don't want to learn how to use yet another "language"
07:47:33 <Guest23552> geekosaur: Are you aware of a Haskell library that can extract text from PDF files? I've tried pdf-toolbox, but it doesn't insert spaces or newlines.
07:47:51 <aspidites> sodium i can't really get a feel for. implemented in multiple languages and a couple of example apps, but nothing else
07:48:02 <aspidites> maybe i'll try and dig up each of their 'hello world's again
07:48:03 <donri> aspidites: netwire uses arrow, category and applicative. not that "internal"
07:48:16 <geekosaur> extracting text from a pdf sensibly is damned near impossible regardless of language :
07:48:18 <geekosaur> :(
07:48:31 <aspidites> geekosaur: pdftk?
07:48:32 <Guest23552> geekosaur: Try pdftotext, then.
07:48:46 <aspidites> or that .. which isn't pdftotext part of poppler?
07:48:48 <geekosaur> than you, I have used both
07:49:09 <Guest23552> geekosaur: I guess it depends on the definition of "sensible."
07:49:19 <hub2_> merijn: What was 2) ?
07:49:21 <geekosaur> pdf is write-only (well, render-only)
07:49:52 <aspidites> pdfminer, pdf2htmlex
07:50:03 <donri> aspidites: my understanding is a key difference is netwire is pull-driven and reactive-banana push-driven, and that this means netwire is better suited for FPS stuff and reactive-banana for better for widget graphics. something like that. have used neither. :P
07:50:19 <geekosaur> seriously, you've never seen it mistake kerning for a word break? or run headers/footers into the body text?
07:50:22 <Guest23552> aspidites: Could you expand on your comment regarding poppler?
07:50:36 <aspidites> pdftotext is part of poppler. or so i thought
07:50:38 <Guest23552> geekosaur: Currently, that's not important.
07:51:23 <Guest23552> aspidites: Ah, there are bindings for poppler. I thought you were implying to try that package.
07:51:24 <aspidites> just checked. it is. so installing poppler will give you access to the pdftotext binary, which is all i was saying
07:52:19 <Guest23552> aspidites: That's what I use currently. But I can't find a reliable way to process several files without saving plaintext output.
07:52:49 <Guest23552> aspidites: For instance, system (from System.Process) only returns the exit code.
07:53:24 <Guest23552> aspidites: And readProcess doesn't allow to pass "-" as an argument.
07:53:41 <aspidites> yeah, anything pdf related makes my head hurt. i refuse to have to pay 200 dollars for a license to do something sensible when there are open source alternatives. too bad adobe owns mindshare in htat sapce
07:54:33 <aspidites> is it too efficient (as it's clearly not ideal) to just fork a process for each file?
07:54:59 <Guest23552> aspidites: I don't even care about efficiency at this point. I can't make it work at all.
07:55:09 <Guest23552> aspidites: Wait, I'll show some code.
07:55:36 <aspidites> (warning: i probably won't understand the code, lol). just thinking from a generic problem/solve perspective
07:55:58 <aspidites> Guest23552: if you can get things to work for one file, it seems it should be simple enough to rinse and repeat though
07:59:28 <Guest23552> aspidites: Meh, there's nothing to post.  As I said, the problem is that 'system' returns (IO ExitCode) instead of (IO (ExitCode,String)).
08:00:09 <Guest23552> aspidites: I'll try to use the functions from Shelly.
08:01:43 <aspidites> http://hackage.haskell.org/package/process-1.0.1.1/docs/System-Process.html#1
08:02:28 <tovarish> Guest23552, there are other functions wich return more information
08:02:29 <Guest23552> Ah, thank you.
08:02:42 <Guest23552> tovarish: Which ones?
08:02:57 <geekosaur> Guest23552, did you miss me pointing to http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/process-1.1.0.2/System-Process.html#v:readProcessWithExitCode earlier?
08:03:06 <Guest23552> geekosaur: Yes, I think so.
08:03:54 <tovarish> Guest23552, readProcessWithExitCode
08:04:16 <tovarish> sorry geekosaur already gave the link
08:04:55 <hub2_> Can I make some generic implementation for a method in typeclass?
08:04:56 <Guest23552> tovarish, geekosaur: Oh, it doesn't allow "-", it seems.  readProcessWithExitCode "pdftotext" ["-nopgbrk", "foo.pdf", "-"] []
08:05:13 <Guest23552> *** Exception: fd:9: hGetContents: invalid argument (invalid byte sequence)
08:05:29 <geekosaur> that means you have an encoding issue
08:05:35 <tovarish> Guest23552, it looks like an encoding problem
08:05:54 <tovarish> maybe you should use more obscure version with handle ans set them to binary mode
08:05:54 <merijn> hub2_: 2 is the fact that typeclasses can be polymorphic in the return value, i.e.: An example of 2: "read :: Read a => String -> a" here the polymorphism is in the value returned, not in the arguments provided
08:06:28 <Guest23552> tovarish: You mean runProcess, right?
08:06:42 <shachaf> Saying that type classes are polymorphic "in the return value" is a bit misleading because methods aren't necessarily functions at all.
08:07:09 <merijn> shachaf: Point 1 of 3 was already "typeclasses can have polymorphic values"
08:07:12 <tovarish> Guest23552, createProcess should do the job
08:07:19 <shachaf> OK.
08:20:39 <Guest23552> tovarish: Indeed, it works.
08:20:46 <Guest23552> tovarish, geekosaur: Thanks!
08:21:21 <mada> backa
08:21:23 <mada> wrong window
08:21:41 <merijn> Does the new IO manager in 7.8 still use stop the world collection for the multi-threaded runtime?
08:22:01 <merijn> I would guess so?
08:23:46 <bitemyapp> merijn: there are no plans for soft-real time in GHC AFAIK
08:24:08 <bitemyapp> merijn: the closest thing would be the thread-local heap GC branch of GHC but that was by-and-large abandoned.
08:25:03 <bitemyapp> merijn: soft-real time would push GHC's runtime closer to something like BEAM and I don't think there's a strong pressure to do so because people are already successfully using Haskell in production soft real-time projects just by tweaking the RTS settings.
08:25:08 <merijn> bitemyapp: Yeah, I assumed so. But it would be embarassing to claim GHC does stop-the-world collection when it no longer does. So I figured I'd double check
08:26:00 <merijn> I did some benchmarking with 7.6, if 7.8 didn't eliminate that, my observations still apply (albeit at higher core counts, which is irrelevant to the point I'm making)
08:26:15 <bitemyapp> merijn: what observations?
08:26:38 <bitemyapp> you're not going to completely eliminate GC pauses in GHC without a completely re-architecting of the runtime into something closer to what BEAM does.
08:27:10 <bitemyapp> what people do in practice, ie not futzing around with constraint-less benchmarks, is simply tweak the RTS such that the window of any given pause + average processing time means you achieve your latency SLA.
08:27:22 <bitemyapp> this approach has worked so well that people just don't care.
08:27:57 <bitemyapp> most peoples' "soft real-time" constraints are soft enough that they can tweak the JVM or GHC to whatever works for their particular use-case.
08:29:01 <bitemyapp> merijn: it would probably be more productive to think about ways of pooling, primitives, and avoiding allocations in GHC if you are GC pause averse.
08:29:06 <bitemyapp> ways of using*
08:29:53 <bitemyapp> if you need to make a AAA-quality 3d game engine, GHC as your deployed binary runtime probably isn't the way to go.
08:30:38 <bitemyapp> doesn't mean you couldn't make a Haskell EDSL for OpenGL and game logic in C though ;)
08:32:37 <tautologico> any suggestions for a good plotting library?
08:33:24 <aristid> bitemyapp: how long does a gc pause take after tweaking?
08:33:55 <bitemyapp> aristid: how large is food?
08:34:03 <aristid> bitemyapp: i mean order of magnitude
08:34:30 <bitemyapp> aristid: the order of magnitude seriously depends on how large your generations are - ie, how much garbage are you generating and how much memory footprint your app has.
08:34:48 <aristid> bitemyapp: you clearly had concrete examples in mind :)
08:35:03 <Eelis> i tried to write a 3d game in Haskell once but the GC pauses were killing me so i abandoned it
08:35:10 <bitemyapp> aristid: if you're operating with a time sensitivity in the realm of what most financial applications are subject to, Haskell is fine.
08:35:19 <bitemyapp> 3d games are probably not a good idea, not just because of the GC pauses.
08:35:46 <aristid> Eelis: what kind of gc latency did you see?
08:35:55 <bitemyapp> 3d games have an effective latency sensitivity of 16 ms per frame, which would hypothetically be doable in Haskell but there are a few compounding issues.
08:35:57 <jmcarthur> Eelis: i claim without proof that the gc doesn't have to be a problem even for very demanding games
08:36:15 <jmcarthur> Eelis: you just have to be careful about your allocation rates and how long references linger
08:36:28 <bitemyapp> most people are really bad at pooling their resources in high level languages when writing games, so their experiences with GC generally aren't valid./
08:36:40 <Eelis> this was years ago. back then i tried everything but decided Haskell was just getting in my way too much
08:36:44 <bitemyapp> if you pool your resources properly you can avoid the GC almost completely in Haskell.
08:36:54 <bitemyapp> but you'll just end up writing C++ in Haskell.
08:36:55 <tautologico> it is not an issue if you tune the GC to the point that you're not really using garbage collection anymore :)
08:37:01 <bitemyapp> a slightly safer C++, but all the same.
08:37:07 <bitemyapp> tautologico: that's...not a thing.
08:37:08 <Eelis> jmcarthur: claiming without proof is easy
08:37:26 <bitemyapp> tautologico: there's no such thing. the GC is always there.
08:37:29 <monochrom> I tried to write a game in C. I never finished.
08:37:40 <tristan_1> C++ in Haskell!?
08:37:40 <bitemyapp> The real way to sidestep is to use custom pools and allocators for different kinds of objects.
08:37:42 <jmcarthur> the real trick is to limit promotable allocations. short-lived ones are fine, of course. it's not that difficult to do.
08:37:47 <bitemyapp> to sidestep GC*
08:37:48 <tautologico> people turn off automatic collections and pin a lot of resources, so they're almost not using GC anymore
08:37:58 <bitemyapp> you have to use custom allocators and pools in game engines in C++ anyway.
08:38:10 <bitemyapp> because malloc'ing everything means fragmentation which means you're *fucked*
08:38:22 <tautologico> this is the people I know that are doing games on consoles using managed runtimes are doing... not Haskell though
08:39:26 <bitemyapp> there isn't a substantial difference between using a custom pool + allocator in Java or Haskell vs. C++. In one case, you're avoiding GC, in the other, you're avoiding malloc's default behavior.
08:39:41 <bitemyapp> there are other reasons to avoid writing a game in Haskell, GC is one of them and not even the most serious one.
08:39:48 <bitemyapp> only one*
08:39:51 <Eelis> in my case, deterministic destruction was all i needed. i didn't need any pooling to make it fast in C++
08:39:56 <tautologico> of course, default malloc has issues
08:40:18 <Eelis> so it's not true to say "well in C++ you would have to do the same tricks as in Haskell to make it fast"
08:40:27 <bitemyapp> that's not what I was saying
08:40:31 <Eelis> good
08:40:33 <bitemyapp> I was describing game industry norms in C++
08:40:45 <Eelis> mine was a very simple 3d game, not industry worthy
08:40:51 <bitemyapp> Eelis: that touches on one of the more serious issues I was alluding to. The bindings and libraries for C++ for things like OpenGL are fast enough out of the box to not require optimization for the needs of say, an indie dev.
08:41:03 <bitemyapp> Eelis: in Haskell, the OpenGL bindings and libraries are an atrocity.
08:41:09 <Eelis> right
08:41:10 <monochrom> there are many reasons to avoid writing a game at all. the #1 reason: too many smart people already do it, too competitive
08:41:13 <bitemyapp> that's one of the biggest issues and sources of slowness.
08:41:23 <tautologico> monochrom: indeed :)
08:41:38 <bitemyapp> monochrom: that's one of the main reasons I don't work in games or try to do it independently.
08:41:42 <Eelis> monochrom: that's a very silly thing to say, because there are various reasons to write a game
08:41:44 <tovarish> monochrom, do you have other reasons?
08:41:45 <bitemyapp> not a good way to make money.
08:41:49 <tautologico> lots of competition + lots of people doing it for "passion" means lower salaries
08:41:56 <bitemyapp> tovarish: writing games is intensely frustrating and labor intensive.
08:42:04 <Eelis> for instance, one may write a game for fun and creative expression
08:42:05 <bitemyapp> extremely labor intensive.
08:42:09 <bitemyapp> I became a programmer to avoid labor.
08:42:16 <aristid> tautologico: significantly lower too
08:42:27 <bitemyapp> aristid: by like...50%.
08:42:38 <bitemyapp> and you work 100% harder
08:42:38 <aristid> yeah or even more
08:42:46 <bitemyapp> depending on industry, yeah.
08:42:51 <tovarish> bitemyapp, coding is intensely frust....
08:43:00 <tautologico> that was also my reason to give up trying to get a job in the game industry... horrendous work conditions and lower pay
08:43:01 <tovarish> sso coiding game or software i don't see the differences
08:43:10 <bitemyapp> tovarish: if you say so. I have a relatively serene time of it coding in Haskell :)
08:43:21 <bitemyapp> tautologico: wise.
08:43:25 <tovarish> good for you
08:43:31 <bitemyapp> it's best not to feed a beastly industry like gaming with more labor.
08:43:38 <tovarish> (is it an aggressive expression good for you or it's ok?)
08:43:40 <tautologico> I much prefer what I do now anyways
08:43:41 <bitemyapp> they don't deserve the labor they already get.
08:43:52 <Eelis> who cares about industry. writing little games is fun. except when the language gets in your way
08:44:00 <bitemyapp> tovarish: I didn't understand that last bit?
08:44:15 <bitemyapp> Eelis: well there is a game project I'd like to do, but I'm putting it off until I retire/semi-retire.
08:44:17 <tovarish> you seem to like your developper job, I'm glad for you
08:44:31 <bitemyapp> if I have extra time to work on side projects, I'd rather allocate it to ones that might lead to more money.
08:44:33 <monochrom> tovarish: it depends on context and voice. in this case it is friendly. but any expression can be used sarcastically.
08:44:42 <Eelis> bitemyapp: i'm putting mine off until ghc gets better
08:44:46 <tovarish> monochrom, OK
08:44:48 <bitemyapp> tovarish: I'm generally sincere and serious, especially on IRC.
08:44:58 <aristid> bitemyapp: to get the semi-retirement earlier?
08:45:00 <bitemyapp> Eelis: I don't really have a problem writing C++.
08:45:02 <tautologico> if anyone hasn't read it and want to have an idea about how is it to work in the games industry, google to find the "EA spouse" blog
08:45:03 <bitemyapp> aristid: da.
08:45:16 <bitemyapp> aristid: I've seen you in #startups, I'm not surprised you picked up on that.
08:45:20 <Eelis> bitemyapp: i can write C++. it's just not a lot of fun
08:45:30 <bitemyapp> Eelis: I can write functional C++. I don't really care that much.
08:45:42 <Eelis> i don't think there is such a thing as functional C++
08:45:48 <bitemyapp> I'm not saying it's "nice", it's just hypothetically possible.
08:45:55 <bitemyapp> functional means whatever the speaker wants it to mean.
08:46:00 <tautologico> Rust is looking nice, but it's still not stable enough for production
08:46:08 <bitemyapp> yeah, I like the looks of Rust.
08:46:37 <bitemyapp> I'm a little disappointed by their abandonment of M:N threading, but I understand it from the POV of wanting a zero-runtime language.
08:46:49 <bitemyapp> or at least, a sufficiently flexible runtime such that you can use the lang anywhere/everywhere.
08:47:02 <tristan_1> aren't they making all that pluggable?
08:47:04 <tautologico> yeah, their biggest use right now is on Servo
08:47:06 <tristan_1> same with GC
08:47:14 <bitemyapp> the runtime limitations/assumptions/etc are a lot of why Haskell isn't quite as well suited to some systems programming use-cases as C++ yet.
08:47:20 <bitemyapp> tristan_1: yeah.
08:47:35 <bitemyapp> to be fair, you can't really implement Haskell without GC and the runtime.
08:47:52 <bitemyapp> so I don't really care, but it's worth thinking about if you do a lot of embedded/systems work.
08:49:05 <tautologico> there are already communities for gamedev and OS development using Rust
08:50:27 <bitemyapp> yeah, and there's a Haskell game dev community but I think long-term Rust is better suited.
08:50:40 <bitemyapp> Rust was almost completely designed around avoiding GC, allocations, systems programming, etc
08:50:54 <tovarish> there are games developped in Haskell (big games, not small ones) ?
08:51:04 <bitemyapp> there are games, mostly indie.
08:51:07 <bitemyapp> mostly 2d, as well.
08:51:27 <bitemyapp> they're decent games, well made, pretty enough to look at.
08:51:31 <tovarish> those on hackages ?
08:51:36 <bitemyapp>  But they're decidedly not AAA 3d whizbang graphics games.
08:51:50 <tovarish> those who never built or failed to run :)
08:52:02 <tovarish> s/who/which/
08:52:06 <bitemyapp> the opengl bindings et al aren't up to the task and neither is the runtime. And that's okay. Language implementations shouldn't try to be everything to everybody.
08:58:43 <udevd> hi! am I allowed tu use `inline data types synonyms' like f a = b where Data2=Data a; b=Data2 2 -- data Data = Data a Int
08:58:46 <udevd> ?
09:00:34 <shachaf> GHC won't allow it.
09:02:00 <stephenmac7_> I'm having issues with this piece of code: http://lpaste.net/97747
09:02:34 <stephenmac7_> The error: http://lpaste.net/97750
09:03:00 <shachaf> + is not string concatenation.
09:03:05 <shachaf> It is number addition.
09:03:07 <aspidites> someone have a concise example of Applicative vs Arrow? kind of a hello world example of sorts?
09:03:11 <shachaf> Try (++).
09:03:34 <aspidites> I sort of get Applicative (especially when comparing it to do notation), but don't get arrows at all
09:03:46 <shachaf> That's OK, you don't really need to.
09:04:01 <merijn> bitemyapp: My GC question was related to a "position" paper I'm writing for a workshop on PL design. I recently had an idea about orthogonal and extensible type systems, related to a discussion of how one could implement a typesafe runtime system for something like haskell that doesn't require a global GC stop
09:04:46 <aspidites> shachaf: but i'd rather i did understand. ignorance may be bliss, but knowledge is divine
09:04:46 <stephenmac7> shachaf: Thanks
09:04:47 <merijn> bitemyapp: The idea was to basically have per capability GC with explicit data movement between GC domains and have the typechecker guarantee safety
09:04:50 <stephenmac7> Missed that :P
09:05:03 <bitemyapp> merijn: hum. you're getting into linear types, unique pointers, etc
09:05:06 <bitemyapp> merijn: look at Rust.
09:05:15 <tautologico> there's some work on Typed Intermediate Languages and stuff like that
09:05:17 <bitemyapp> merijn: if a lack of GC is truly critical for making your point.
09:05:34 <tautologico> the Cyclone people (Morissett, etc) worked on TIL and related stuff
09:05:50 <tautologico> Cyclone was an influence for Rust btw
09:06:13 <udevd> @def data A=A Int Int
09:06:15 <lambdabot>  Defined.
09:06:15 <tautologico> rust uses regions that are similar to the cyclone design
09:06:20 <udevd> > A 1 2
09:06:22 <lambdabot>  No instance for (GHC.Show.Show L.A)
09:06:22 <lambdabot>    arising from a use of `M817368677501689481814485.show_M8173686775016894818...
09:06:22 <lambdabot>  Possible fix: add an instance declaration for (GHC.Show.Show L.A)
09:06:28 <udevd> @def data A=A Int Int deriving Show
09:06:28 <lambdabot>  .L.hs:152:6:
09:06:28 <lambdabot>      Multiple declarations of `A'
09:06:28 <lambdabot>      Declared at: .L.hs:150:6
09:06:28 <lambdabot>                   .L.hs:152:6
09:06:28 <lambdabot>  
09:06:31 <udevd> erm
09:06:37 <udevd> @def data B=B Int Int deriving Show
09:06:38 <lambdabot>  Defined.
09:06:40 <shachaf> The command is @let.
09:06:48 <udevd> oh. thanks
09:06:54 <udevd> > B 1 2
09:06:56 <lambdabot>  B 1 2
09:06:57 <shachaf> I suppose this works too. Funny.
09:07:06 <udevd> > map (B 1 ) [1..10]
09:07:07 <merijn> bitemyapp: No, it's not about lack of GC, it's more about using type systems for invariants other than "conventional" types. But if I bring out "this can neatly help with typesafely avoiding global GC" as argument, I look like a prat if it turns out GHC already avoids that :)
09:07:07 <lambdabot>  [B 1 1,B 1 2,B 1 3,B 1 4,B 1 5,B 1 6,B 1 7,B 1 8,B 1 9,B 1 10]
09:07:50 <bitemyapp> merijn: well, yeah.
09:07:54 <cschneid> is there a blog post or guide about setting up emacs for haskell dev? I'm a vimmer, but want to expand out a bit :)
09:08:07 <bitemyapp> merijn: dependent types can encode value invariants. linear types can encode resource lifecycle invariants.
09:08:08 <merijn> bitemyapp: I admit I haven't looked at rust, but afaik they basically still only have a single built-in type system
09:08:41 <zipper> Can I really not use modulus (%) in haskell?
09:08:44 <dmisback> lol, i just reached the "how would you do a sort" section of a haskell tutorial. thought I would try to do it without looking. The recursive solution involves placing the head in the middle and list comprehensions on both sides of it, and recurse.
09:08:53 <merijn> bitemyapp: Sure, I'm making the argument "Why are we trying to stuff all these things into a single type system, rather than having an extensible one using multiple orthogonal type systems
09:09:10 <merijn> zipper: % operator is for ratios, for modulo use the "mod" function
09:09:12 <aspidites> go figure there is haskell.org/arrows not sure how i missed that before
09:09:22 <merijn> > 13 `mod` 3
09:09:23 <lambdabot>  1
09:09:29 <zipper> merijn: Well I found that
09:09:41 <zipper> but % is so much more natural
09:09:46 <merijn> > (2 % 5) + (3 % 5)
09:09:47 <dmisback> I'm not sure what to conclude about a language where solving some basic things feel like riddles.
09:09:47 <lambdabot>  1 % 1
09:09:54 <bitemyapp> merijn: http://www.haskell.org/pipermail/haskell-cafe/2011-February/089458.html
09:10:10 <bitemyapp> merijn: I mean, I agree that an extensible type system is in principle a nice thing to have but using Haskell as an example of this is cheating.
09:10:10 <tautologico> zipper: it's not "more natural", you're just more used to it... use mod for a while and then it will feel natural for you
09:10:31 <bitemyapp> merijn: Haskell has an active and passionate developer and user community that has been pushing the goal post since the 90s.
09:11:01 <`^_^v> dmisback, sounds like a straightforward and intuitive (but probably not the best) implementation of quicksort
09:11:20 <zipper> merijn: (2 % 5) + (3 % 5) threw an error too
09:11:21 <merijn> bitemyapp: Why is "using Haskell as an example" cheating? I'm refering to Idriss and Java papers too
09:11:31 <donri> @hoogle (%)
09:11:31 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
09:11:33 <zipper> <interactive>:13:14: Not in scope: `%'
09:11:41 <Cheeseen> o/
09:11:59 <merijn> bitemyapp: I'm using Haskell as an example because I had the idea during a discussion on how we could get Haskell to scale better on multicores
09:12:11 <bitemyapp> merijn: oh, what's that?
09:12:16 <merijn> zipper: 'import Data.Ratio'
09:12:26 <aspidites> :t (%)
09:12:27 <lambdabot> Integral a => a -> a -> Ratio a
09:13:21 <dmisback> `^_^v: thing is, that's not how any human some objects if they were on their desk. So is being forced to learn the recursive way better for any reason aside from expanding your mind to unusual patterns?
09:13:22 <merijn> bitemyapp: The introduction of per capability GC domains with explicit hand-offs between domains. That could eliminate the need for global GC stop, at the cost of making sharing a slightly more costly operation
09:13:35 <merijn> bitemyapp: Other bonus is that such a design maps nicer to NUMA architectures
09:13:36 <dmisback> *how any human would SORT objects
09:13:47 <tautologico> merijn: how do you intend to define the semantics of the type system if different modules may interact with each other?
09:14:19 <zipper> merijn: Thank you
09:14:26 <merijn> tautologico: The "semantics" of the type system is just "it should unify"
09:14:34 <bitemyapp> merijn: sounds nice in principle but usually when you're tweaking allocation/GC behavior you want custom allocator pools anyway.
09:14:43 <tautologico> dmisback: this is the quicksort algorithm, it's a well-known recursive algorithm for sorting... what's obvious is not necessarily what works best as an algorithm
09:14:58 <bitemyapp> Most programs are fine with generic heap behavior (GC or malloc) or they're not.
09:15:07 <boom583> On page 99 in LYAH paper version, why is the second findKey better? It seems me to me that the second is less efficient. The first one stops when we find the right key. But the second one keeps on evaluating.
09:15:12 <merijn> bitemyapp: "most programs are fine" is not very interesting research
09:15:20 * bitemyapp holds up hands
09:15:27 <bitemyapp> yeah yeah, I know, I'm just saying.
09:15:32 <merijn> bitemyapp: "How can we make this work on NUMA in the future" is much harder and more interesting :)
09:15:38 <tautologico> unification is a type reconstruction issue
09:15:49 <shachaf> boom583: You'll get a broader response if you don't restrict the question to people who have the paper LYAH version handy.
09:15:54 <merijn> tautologico: How do you mean?
09:16:26 <bitemyapp> generalizing types of allocators into assuming that there are multiple allocators at work instead of the current pattern of malloc libraries that assume they own the universe could be interesting research.
09:16:45 <tautologico> merijn: you said "it should unify"... I'm thinking about unification, like in Prolog and type reconstruction for Hindley-Milner... if it's that, then it's not a semantics for the type system
09:16:52 <merijn> bitemyapp: I have already been working
09:16:58 <merijn> bitemyapp: +on that
09:17:12 <merijn> bitemyapp: This is more of a "broaden the scope beyond that" :)
09:17:47 <merijn> tautologico: Can you clarify what you mean by the semantics of the type system?
09:18:10 <boom583> This: https://pastee.org/jtm9j Why does LYAH claim that the second version is better than the first? It seems me to me that the second is less efficient. The first one stops when we find the right key. But the second one keeps on evaluating.
09:18:45 <tautologico> merijn: have you looked at "Types and Programming Languages" by Ben Pierce? I mean that kind of stuff
09:18:46 <merijn> boom583: The second doesn't keep on evaluating
09:19:04 <boom583> merijn: why not? it's a fold through the whole list isn't it?
09:19:43 <tautologico> defining the type system formally by giving typing judgment rules, proving soundness, completeness etc
09:19:54 <shachaf> boom583: No.
09:20:01 <shachaf> boom583: Look at the definition of foldr
09:20:02 <merijn> boom583: No, because haskell is lazy
09:20:03 <shachaf> @src foldr
09:20:03 <lambdabot> foldr f z []     = z
09:20:03 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:20:16 <aspidites> :i foldr
09:20:37 <aspidites> awww..
09:20:39 <geekosaur> no :i
09:20:39 <shachaf> It looks just like findKey. So it'll behave like findKey.
09:20:50 <merijn> tautologico: The problem is that you're thinking of a type system that follows from the values, like conventional HM
09:21:32 <bitemyapp> aristid: http://sebastiansylvan.com/2013/04/18/on-gc-in-games-response-to-jeff-and-casey/ I think the hope the author expresses is possible, especially if you combine GC with specialized object pools.
09:21:46 <merijn> tautologico: I have colleagues that work on a purely functional array language. Obviously the amount of optimisation you can do on arrays depends on their memory layout
09:21:47 <bitemyapp> aristid: that is, that mainstream games could eventually use GC. It'd just be GC in something like C++ or Rust rather than Python.
09:22:01 <bitemyapp> and you'd be avoiding allocation to the generic heap.
09:22:51 <tautologico> avoiding a lot of allocation and working with fixed pools and so on
09:22:53 <bitemyapp> aristid: to answer your question about pause length, this answer matches my experience: http://stackoverflow.com/questions/12404031/how-long-pauses-can-occur-in-a-haskell-program-due-to-garbage-collection
09:22:59 <bitemyapp> tautologico: yeah.
09:23:13 <merijn> tautologico: i.e. row order vs column order, dense vs sparse. They're now working on a type system in the compiler that tracks "optimal layout" and allows for "layout polymorphic" or "layout specific" code. They then use this "layout typing" to detect whether different generated code is compatible
09:23:17 <aristid> bitemyapp: thanks
09:23:33 <aristid> merijn: so SAC is _not_ dead?
09:23:41 <aristid> merijn: carter claimed it was
09:23:44 <bitemyapp> aristid: and while I think his guesstimate is accurate, it's based on a particular generation size in a particular kind of problem.
09:23:48 <merijn> aristid: heh
09:23:56 <merijn> aristid: I talked to carter not so long ago about SAC
09:24:06 <merijn> aristid: SAC mostly looks dead, because university IT sucks
09:24:11 <aristid> lol
09:24:16 <bitemyapp> I could write a contrived program that churned a lot of garbage and caused big pauses.
09:24:31 <boom583> ok i'll have to think about this
09:24:32 <merijn> aristid: They're failing to migrate the webpage to the new uni and after 9 months still haven't managed to resurrect the mailing list
09:24:46 <boom583> maybe my brain isn't suited for haskell :(
09:24:51 <zipper> When we check membership in a set like x <- [1..10] Does the state of x not change?
09:24:51 <boom583> or functional programming in general
09:24:59 <merijn> aristid: I know at least 8 or so people are actively working on SAC atm
09:25:23 <aristid> bitemyapp: i guess games are one of the most hostile environments for programmers, because our visual system (in the brain) is capable of perceiving fairly small pauses, stutters and artifacts
09:25:23 <zipper> How does that happen? I'm very new to this obviously
09:25:49 <merijn> aristid: The problem is that the group isn't allowed to host their own mailing list on their machines (uni policy), so as long as IT doesn't get of their ass their a bit stuck
09:26:07 <merijn> zipper: "x <- [1..10]" is syntactic sugar
09:26:13 <aristid> merijn: can't they at least put some news on the website?
09:26:35 <merijn> zipper: "do { x <- [1..10]; foo x }" unsugars to "[1..10] >>= \x -> foo x"
09:26:56 <aristid> which is the same as [1..10] >>= foo
09:26:58 <bitemyapp> aristid: yes, and one of the problems with non-deterministic pauses is you don't get to decide where/when in the process of preparing a frame for rendering that occurs.
09:27:10 <merijn> aristid: They probably should, but they're a bit swamped. I'll ask at the NL-FP day, because I'll see several of them
09:27:16 <skypers> @index liftIO
09:27:16 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:27:16 <shachaf> Or does it?
09:27:18 <bitemyapp> aristid: with deterministic allocation strategies, you can amortize that cost in places/times that make sense for the rendering pipeline.
09:27:28 <tautologico> merijn: cool, is this related to SAC (I assume it's Single-Assignment C)?
09:27:56 <aristid> bitemyapp: right; i wonder if a reference-counted variant of haskell might be usable
09:28:31 <merijn> tautologico: The stuff I just mentioned is, but the stuff I'm writing now is more a speculation about "how can we generalise this for even more stuff" personally I would have a use for layout typing for graphs and "GC typing" to control memory locality
09:28:31 <aristid> tautologico: he IS talking about SAC
09:29:01 <bitemyapp> aristid: reference counting still isn't tenable due to heap fragmentation.
09:29:02 <tautologico> merijn: but if I understand what you said then the compiler is inferring types for the program "internally", so it seems a typed intermediate language to me... different typing systems at different levels, not a "modular" type system
09:29:08 <zipper> Oh man learning this language will be work!
09:29:18 <bitemyapp> aristid: you have to just give up non-deterministic / application-ignorant allocation strategies completely.
09:29:21 <tautologico> aristid: it was not obvious to me that he was, so I asked
09:29:21 <zipper> Can I create GUIs easily in Haskell?
09:29:23 <merijn> tautologico: But once we expand and add two orthogonal typing layers, why not just allow the ability (built-in in the language) to provide arbitrary orthogonal types
09:29:36 <bitemyapp> zipper: threepenny and GTK bindings are a thing.
09:29:57 <aristid> bitemyapp: i guess you could also go down the route of having the renderer in c++, and keeping the AI/logic in haskell, i assume the delay perception might be lower there
09:30:13 <bitemyapp> aristid: that's what Sweeney was experimenting with.
09:30:18 <merijn> tautologico: That specific example is "internal", however the presence of GC domains is something you'd want to have explicitly visible to the programmer (as it comes with a cost intuition that moving between domains is costly)
09:30:23 <aristid> bitemyapp: of Epic?
09:30:23 <bitemyapp> aristid: I don't know what happened to that experiment.
09:30:27 <bitemyapp> aristid: yeah.
09:30:39 <bitemyapp> it wasn't a serious thing, just his general idea of where game dev might go.
09:30:43 <tautologico> merijn: have you looked at the work on typed intermediate languages? I think it's related
09:31:06 <bitemyapp> seemed okay from a high level point of view. I don't really know how costly FFI is in that context.
09:31:15 <merijn> tautologico: So you'd have compiler primitives that have a specific domain type (think of the 's' argument in "ST s a") and users just write mostly "domain polymorphic code", with some explicit migration
09:31:37 <merijn> tautologico: Not a lot, this is a fairly recent realisation :)
09:31:47 <aristid> bitemyapp: sounds like a pretty cool thing, did he write things up about that?
09:31:57 <bitemyapp> aristid: he gave a pretty well known talk about it.
09:32:09 <danilo2> Hello! I want to write a parser, which will deliver "modern functionality", like "tab completion" or "syntax highliting" while typing. I'm choosing between parsec, trifecta and uu-parsinglib. Could you recommend any of these solutions? (uu is the only one that has got error repaitring as far as I know - its nice feature also)
09:32:23 <merijn> tautologico: Basically, if you're gonna let the compiler have additional layers, why not give programmers those too? Rather than trying to encode all your invariants in a single type that becomes a huge mess
09:32:36 <bitemyapp> aristid: http://lambda-the-ultimate.org/user/97/track http://www.haskell.org/pipermail/haskell-prime/2006-February/000380.html
09:33:07 <aristid> http://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf ?
09:33:19 <tautologico> merijn: sounds to me like typed intermediate languages + multi-stage programming :) could be a cool combination to explore
09:33:24 <merijn> tautologico: I've written GADTs+DataKinds+TypeFamilies "one type takes multiple lines" type code, it's not very desirable :p
09:33:46 <bitemyapp> aristid: yeah
09:33:49 <merijn> tautologico: That's kinda the point I'm trying to sell, yes :)
09:33:59 <bitemyapp> aristid: but the LTU stuff will go into more depth typically.
09:34:08 <bitemyapp> the slides are pretty good.
09:42:09 <tomejaguar> Is there another version of hayoo somewhere?
09:42:38 <schlegel> A lot of people use hoogle
09:42:47 <ocharles> and the fp complete hoogle
09:43:17 <schlegel> https://www.fpcomplete.com/hoogle
09:43:36 <aristid> is the fpcompletehoogle more complete than the realhoogle?
09:43:36 <schlegel> Or http://www.haskell.org/hoogle/ or `cabal install hoogle`
09:43:57 <aspidites> command line hoogle doesn't seem to be as robust as it's online counterpart
09:44:26 <bitemyapp> merijn: are you writing a grant proposal?
09:45:09 <udevd> > Just $ 2
09:45:11 <lambdabot>  Just 2
09:45:11 <danilo2> Have anybody used trifecta and uu-parsinglib and could tell me why one is better then the other? What features does trifecta provide, we can not get from uu-parsinglib?
09:45:23 <danilo2> appart of nice error output?
09:45:56 <shachaf> udevd: By the way, you can also /msg lambdabot.
09:48:01 <kakos> So, I have a file in my project with the .chs ending, but cabal doesn't seem to want to compile it. c2hs is installed. I added "build-tools: c2hs" to my .cabal file. Any idea what might be going on?
09:48:25 <Guest87623> Shouldn't it be called hsc?
09:48:28 <Guest87623> .hsc
09:49:22 <kakos> Guest87623: Documentation says "chs"
09:49:35 <Guest87623> Hm, no idea then, sorry.
09:49:43 <bitemyapp> aristid: there's a pretty funny threading joke in the slides btw.
09:50:38 <aspidites> reactive banana and netwire seem to be the best documented
09:50:39 <aristid> bitemyapp: man, organizing subfolders in the "papers" folder is hard!
09:50:48 <aspidites> goal for the day -- write a lame game
09:52:58 <Guest87623> geekosaur: I'm currently using the following code: do (_,Just o,_,_) <- createProcess . shell $ "pdftotext -nopgbrk foo.pdf -"; t <- hGetContents o; return $ length t  It prints the contents of the file but doesn't print the length. What am I doing wrong?  Is it due to laziness?
09:53:46 <geekosaur> you did not tell it to capture output so it sent it to stdout
09:54:18 <boom583> This: https://pastee.org/79cnk The first one is easy to understand. When it finds the element, it stops. No more recursion. Simple.    It seems to me that the second one continues. It never stops. Even after finding the element, it continues. Why am I wrong? I don't see what laziness has to do with it.
09:54:42 <boom583> I see no "stopping condition" for foldr. It just continues.
09:54:51 <boom583> (even if the result will end up the same)
09:55:03 <geekosaur> you generally need to do something like `(shell "whatever") {std_out = CreatePipe}`
09:55:12 <aristid> bitemyapp: his predictions for CPUs were way off... :/
09:55:25 <aristid> 20+ cores... well i guess they exist, but
09:56:17 <bitemyapp> aristid: we'll be there soon enough.
09:56:26 <bitemyapp> aristid: my gaming desktop has 4 physical, 8 logical cores.
09:56:27 <shachaf> boom583: The "stopping condition" is in the function you pass foldr.
09:56:55 <bitemyapp> aristid: the reason he mentions 20+ is that it subsidizes the cost of his approach so as to be faster in the end.
09:56:56 <boom583> shachaf: how so? that function is just specifying the accumulator for the next step
09:57:00 <Earnestly> bitemyapp: He forgot to factor in the possability that wires can leak
09:57:01 <shachaf> See the if? The "acc" -- which means "the rest of this foldr" -- is only in the "else" branch.
09:57:04 <bitemyapp> trading off efficiency for parallelism.
09:57:12 <shachaf> boom583: Just inline your function into foldr by hand.
09:57:28 <shachaf> You'll end up with something identical to the first elem'.
09:58:01 <aristid> bitemyapp: it's currently possible to build a server with 20 cores, but it's still rather expensive:)
09:58:08 <boom583> shachaf: But why does it stop if the lambda function returns True? I thought this just meant that the accumulator for the next step would be True.
09:58:11 <boom583> I don't get it
09:58:16 <shachaf> There is no accumulator.
09:58:23 <aristid> bitemyapp: not counting AMD crap of course
09:58:33 <shachaf> Did you take my advice and inline your function into foldr by hand yet? :-)
09:58:59 <boom583> I don't know what you mean..
09:59:09 <shachaf> "acc" is a misleading name because foldr doesn't have an accumulator in the ordinary sense.
09:59:23 <shachaf> @src foldr
09:59:23 <lambdabot> foldr f z []     = z
09:59:23 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:59:31 <shachaf> foldr (\x acc -> if x == y then True else acc)
09:59:57 <Guest87623> geekosaur: Thanks again.
09:59:57 <shachaf> Take the definition of foldr, and then get rid of the "f" argument and instead replace each use of "f" with that function.
10:00:16 <shachaf> Then do the same thing with z and False, I guess.
10:00:19 <shachaf> Then simplify.
10:00:29 <boom583> ok i'll do this now
10:00:31 <bitemyapp> aristid: his assumption is still correct though, that we'll have to make efficiency tradeoffs in favor of parallelism over time.
10:00:47 <bitemyapp> stuff where we're okay making something 2x slower because we're using 3 or 4 threads.
10:02:18 <aristid> bitemyapp: right
10:03:15 <boom583> @src foldr
10:03:16 <lambdabot> foldr f z []     = z
10:03:16 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:03:43 <boom583> shachaf: looking at just this definition, it can't be stopped. It will always exhaust the whole list, using f, no matter what f does
10:04:08 <merijn> boom583: Haskell's laziness means code won't actually be executed until you try to look at the result
10:04:21 <merijn> boom583: So if you never try to look at the accumulator, it never runs
10:04:50 <boom583> merijn: yes, but so what? If I run it, it always runs the whole thing doesn't it?
10:04:53 <boom583> I don't get where it stops
10:04:56 <merijn> boom583: No
10:05:04 <merijn> boom583: Let's take a simple example
10:05:19 <merijn> boom583: "map (+1) [1..]"
10:05:30 <shachaf> boom583: Did you do the thing I said?
10:05:48 <merijn> boom583: [1..] is an infinite list, so applying "(+1)" should never terminate, right?
10:06:05 <boom583> shachaf: plugging the lambda function into f didn't give me anything interesting.
10:06:16 <boom583> merijn: yes i get that one
10:06:26 <merijn> boom583: But it does terminate!
10:06:38 <merijn> boom583: As long as you don't look at the entire list, that is
10:06:40 <shachaf> Let me try.
10:06:48 <merijn> > take 10 (map (+1) [1..])
10:06:49 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
10:06:53 <shachaf> foldr f z [] = z; foldr f z (x:xs) = f x (foldr f z xs)
10:07:10 <shachaf> Inline f and z.
10:07:28 <boom583> merijn: yes
10:07:31 <shachaf> foo [] = False; foo (x:xs) = (\x acc -> if x == y then True else acc) (foo xs)
10:08:09 <shachaf> Er, no.
10:08:23 <shachaf> foo [] = False; foo (x:xs) = (\x acc -> if x == y then True else acc) x (foo xs)
10:08:33 <shachaf> foo [] = False; foo (x:xs) = (\acc -> if x == y then True else acc) (foo xs)
10:08:34 <boom583> foo?
10:08:38 <merijn> boom583: The definition of map is "map f (x:xs) = (f x): map f xs". But being lazy, Haskell can't be arsed with all that work and calls it a day whenever it can. "map (+1) [1..]" doesn't result in "apply (+1) to every element". It results in "this is a computation that adds one to every element" and haskell then happily does nothing
10:08:41 <shachaf> foo [] = False; foo (x:xs) = if x == y then True else (foo xs)
10:08:52 <shachaf> boom583: foo is my new name for foldr with those arguments inlined.
10:09:30 <shachaf> Do you follow so far? I can break it up into more steps but maybe not in this channel.
10:10:45 <merijn> boom583: Now, suppose I call "take 10 (map (+1) [1..])", here "take 10" tries to look at the elements returned by "map (+1) [1..]", but we didn't actually produce any elements..."whoops". So haskell goes, well... I apply (+1) to [1..] by first doing "(+1) 1 : map (+1) <tail of the list>". Then it goes "sod this" again and doesn't actually continue mapping.
10:11:30 <merijn> boom583: Unfortunately, 'take 10' then goes "well, I wanted 9 more elements of "map (+1) <rest of list>" so back to work we go, returning "(+1) 2 : map (+1) <rest of rest of list>"
10:12:01 <merijn> boom583: But after this has repeated 10 times, "take 10" is done, and haskell sleeps well, knowing it didn't even have to bother with the rest
10:12:14 <Valters> how can I fix this - http://vpaste.net/lMB32
10:12:15 <boom583> merijn: i get this because take has a clear-cut stopping condition.
10:12:33 <boom583> shachaf: i gotta think on this
10:12:52 <merijn> boom583: Right, do you understand how "if x == y then True else rest" only lets you look at "rest" when x /= y?
10:12:58 <fread2282> boom583: However, take doesn't actually do anything
10:12:59 <merijn> boom583: Because that's what shachaf was getting at
10:13:24 <merijn> Valters: "fix" implies something is wrong
10:13:32 <fread2282> boom583: print/ghci/whatever other output mechanism is what starts the evaluation
10:13:33 <merijn> Valters: But I don't see an error or problem statement
10:13:56 * geekosaur will guess indentation without any other information to go by
10:14:19 <quchen> Good call. Tab indented.
10:14:44 <Valters> merijn, this code doesn't work, there is only idea as it should be
10:15:07 <geekosaur> oh, I see another issue, no way that if can typecheck
10:15:27 <geekosaur> since its type is a in the true leg and [a] in the second
10:15:31 <boom583> merijn: no. all I see is that the if-else returns True, and that True becomes the next input into the next foldr call.
10:16:12 <boom583> (when it finds the element)
10:16:12 <merijn> boom583: There is not next foldr call, though
10:16:22 <geekosaur> but the next call doesn't have to actually be evaluated
10:16:22 <merijn> boom583: The foldr call happens inside the "rest"
10:16:24 <Gorroth> Axman6: it seems pretty legit.  i haven't gotten too far into it though; i keep getting distracted with other things
10:16:42 <merijn> boom583: So if we don't evaluate "rest" the next call isn't evaluated either
10:16:49 <merijn> (being inside the rest and all that)
10:16:59 <tautologico> is there a web/html version of ghci ?
10:17:08 <merijn> tautologico: tryhaskell.org?
10:17:13 <merijn> tautologico: Might be broken and buggy though
10:17:24 <tautologico> merijn: yeah, something like that
10:17:25 <merijn> tautologico: Also, webirc + lambdabot? :P
10:17:45 <boom583> merijn: how does it know to stop?
10:17:51 <boom583> it's just True
10:17:54 <boom583> what's special about that?
10:18:01 <boom583> it's jsut looking for the end boolean
10:18:03 <merijn> eh, lemme get the source back
10:18:06 <boom583> and we haven't reached the end yet
10:18:06 <merijn> @src foldr
10:18:06 <lambdabot> foldr f z []     = z
10:18:07 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:18:10 <tautologico> I'm thinking about a quick hack to get interactive plot working... generating graphics via gnuplot perhaps, plus a web repl
10:18:11 <quchen> boom583: 1. Calculate `elem' 3 [1,2]` by hand.  2. Calculate `elem' 1 [1,2]` by hand.  3. Calculate `elem' 1 [1..]` by hand.
10:18:17 <tautologico> interactive plotting
10:18:39 <geekosaur> boom, it's not looking for the "end boolean", it's looking for True. once it finds it, no need to evaluate further
10:18:53 <geekosaur> er, boom583
10:19:15 <boom583> quchen: ok i'll try this. fuck i'm dense :(
10:19:35 <merijn> boom583: Short-circuiting of foldr is really confusing until you do it by hand and go "oooh"
10:19:42 <aspidites> boom: better than dunce ;-)
10:19:47 <tautologico> someone on the Haskell community should try to make a better version of IPython, using Haskell :)
10:20:05 <merijn> boom583: quchen's suggestion is good. Elem is slightly simpler and you can just do it on paper/whiteboard by repeated substitution
10:20:08 <geekosaur> someone was apparently working on it
10:20:15 <boom583> ok
10:20:18 <aspidites> tautologico: https://github.com/gibiansky/IHaskell
10:20:21 <geekosaur> someone else IIRC actually added haskell support to the existing ipython...
10:20:29 <tautologico> aspidites: cool, thanks
10:20:44 <merijn> @src elem
10:20:44 <lambdabot> elem x    =  any (== x)
10:20:47 <merijn> hmm
10:20:52 <merijn> That's...not helpful :p
10:20:59 <aspidites> granted it lets you use haskell inside of ipython. were you meaning an implementation of ipython in haskell instead?
10:21:15 <tautologico> both are useful
10:21:34 <merijn> boom583: Use "elem x [] = False; elem x (y:ys) = x == y || elem x ys"
10:21:43 <tautologico> the only problem with an interface with IPython is that you end up having to deal with a lot of python :)
10:21:53 <quchen> Use both the recursion-based elem and the foldr-based one.
10:22:13 <aspidites> tautologico: http://hackage.haskell.org/package/berp
10:22:19 <aspidites> python in haskell with interpreter
10:22:25 <quchen> There probably won't be surprises for the recursion-based one. When doing the foldr I'm hoping for a eureka moment. :-)
10:22:36 <geekosaur> https://github.com/ndmitchell/guihaskell ? (very incomplete, apparently)
10:22:53 <benzrf> :t on
10:22:54 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
10:23:00 <benzrf> wat?
10:23:09 <geekosaur> @src on
10:23:10 <lambdabot> (*) `on` f = \x y -> f x * f y
10:23:43 <benzrf> oh
10:23:54 <benzrf> so like composition for 2 arg funcs
10:23:59 <merijn> benzrf: Not quite
10:24:04 <geekosaur> given some function that combines two `b`s to make a `c`, and a function that can make a `b` from an `a`, produce a function that can combine two `a`s to make a `c`
10:24:09 <benzrf> yeah
10:24:10 <merijn> benzrf: More like an "adapter" for a 2 arg function
10:24:11 <benzrf> thats what i meant
10:24:14 <benzrf> ;p
10:24:14 * hackagebot crypto-api 0.13 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.13 (ThomasDuBuisson)
10:24:16 * hackagebot cipher-aes128 0.6 - AES and common modes using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.6 (ThomasDuBuisson)
10:24:18 * hackagebot DRBG 0.5.2 - Deterministic random bit generator (aka RNG, PRNG) based  HMACs, Hashes, and Ciphers.  http://hackage.haskell.org/package/DRBG-0.5.2 (ThomasDuBuisson)
10:24:55 <merijn> benzrf: useful for "compare `on` snd" type stuff (which compares tuples by their second element, or use it fo records, etc.)
10:25:04 <tautologico> IHaskell seems to be in working condition
10:25:38 <quchen> merijn: There's `comparing` for that though. `on` is mostly for code golf these days I guess.
10:25:56 <benzrf> so on could be thought of as a limited kind of lens thing
10:26:00 <Hafydd> Control.Golf
10:26:03 <benzrf> hah
10:26:15 <benzrf> where is on, anyway?
10:26:17 <benzrf> @where on
10:26:17 <lambdabot> I know nothing about on.
10:26:19 <benzrf> lame
10:26:20 <Hafydd> Data.Function
10:26:22 <benzrf> oh
10:26:22 <geekosaur> @index on
10:26:23 <lambdabot> bzzt
10:26:25 <geekosaur> bah
10:26:31 <fread228_> @src on
10:26:32 <lambdabot> (*) `on` f = \x y -> f x * f y
10:26:34 <benzrf> @index ??
10:26:34 <lambdabot> bzzt
10:26:37 <benzrf> what does that doo
10:26:39 <benzrf> *do
10:26:46 <fread228_> @help index
10:26:46 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
10:27:14 <aspidites> > index on
10:27:15 <lambdabot>  Couldn't match expected type `(a0, a0)'
10:27:15 <lambdabot>              with actual type `(b0 -> b0 -> c0) -> (a1 -> b0) -> a1 -> a1 -> c0'
10:27:31 <Hafydd> @index map
10:27:31 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
10:27:34 <boom583> gotta sleep on this
10:27:40 <aspidites> @index on
10:27:40 <lambdabot> bzzt
10:27:47 <quchen> boom583: When you wake up, 1. Calculate `elem' 3 [1,2]` by hand.  2. Calculate `elem' 1 [1,2]` by hand.  3. Calculate `elem' 1 [1..]` by hand.
10:27:48 <quchen> :-þ
10:27:59 <geekosaur> unfortunately @index, like @src, relies on a small static database that is chronically out of date and sometimes wrong
10:28:20 <flazz> what is the typeclass that means something can be serialized?
10:28:21 <benzrf> hooray for normal-order evaluation
10:28:21 <benzrf> :D
10:28:26 <benzrf> flazz: Show?
10:29:20 <Hafydd> Storable?
10:29:58 <flazz> Hafydd: yep, thanks
10:37:20 <merijn> flazz: Ignore both of those
10:37:43 <merijn> flazz: You want the Binary class (for the binary package) or Serializable (for the cereal package)
10:37:46 <merijn> @hackage cereal
10:37:46 <lambdabot> http://hackage.haskell.org/package/cereal
10:37:49 <merijn> @hackage binary
10:37:49 <lambdabot> http://hackage.haskell.org/package/binary
10:38:48 <merijn> Or I guess ToJSON for serialising to JSON via aeson :p
10:39:05 <donri> hey kid, have binary and cereal merged yet? http://ro-che.info/ccc/21.html
10:39:14 <quchen> UnsafeCoerce to ByteString!
10:39:30 <merijn> donri: :)
10:40:02 <benzrf> c++ must have the best serialization since you can directly view objects as sequences of bytes!!
10:40:06 <benzrf> just dump them to file, done!
10:40:21 <donri> you can do that with Storable in haskell
10:40:24 <flazz> merijn: thanks
10:41:12 <donri> in fact that's what makes tekmo's pipes-based serialization thingy so fast (but requires IO)
10:42:03 <quchen> donri: Which serialization thingy are you talking about?
10:42:19 <quchen> Is there some sort of pipes-storable I've been missing? I'm using pipes-binary quite a lot.
10:42:55 <donri> quchen: don't think he packaged it up, it's part of his protein search thing
10:43:59 <Hodapp> my protein search frequently ends with me just getting a bunch of eggs from the store.
10:44:50 <Hodapp> as appetizing as "Carnivor Evisceratrix Beef Protein Isolate with Creatine" sounds.
10:45:08 <donri> quchen: this i think https://github.com/Gabriel439/suns-search/blob/master/src/HSerialize/Core.hs although not pipes-based there
10:46:31 <quchen> Hm, that looks rather simple. Pretty much like inlined Binary, except for the IO part.
10:46:45 <donri> yes. just use Storable to write a Handle directly
10:47:42 <donri> quchen: https://groups.google.com/d/msg/haskell-pipes/Gqa3wF3JLn8/veCE1Jwez5oJ
10:48:08 <benzrf> :t either
10:48:08 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
10:48:53 <quchen> donri: Hah, that sounds like it's about the problem I'm having!
10:49:05 <quchen> pipes-binary is the performance bottleneck right now
10:49:18 <donri> (:
10:49:45 <benzrf> :t (***)
10:49:46 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
10:50:07 <donri> but i also remember vaguely dcoutts hinting at an update to binary that he thought would have comparable performance without IO
10:50:29 <benzrf> :t (***) `asAppliedTo` id
10:50:30 <lambdabot> (a -> a) -> (b' -> c') -> (a, b') -> (a, c')
10:50:32 <quchen> donri: I'll just do optimization by waiting for a newer library version then.
10:51:06 <bennofs> :t (***) `asAppliedTo` const undefined
10:51:07 <lambdabot> (b -> a) -> (b' -> c') -> (b, b') -> (a, c')
10:51:14 <benzrf> -.- of course
10:51:16 <benzrf> :t const undefined
10:51:16 <lambdabot> b -> a
10:51:19 <benzrf> yup
10:51:34 <quchen> Private session, benzrf.
10:51:36 <benzrf> sorry
10:51:41 <benzrf> was not thinking
10:55:31 <benzrf> so (***) is for evalling two functions in paralell, right?
10:56:11 <bennofs> benzrf: (***) f g (a,b) = (f a, g b)
10:56:33 <bennofs> benzrf: This has nothing to do with evaluating them in parallel. It is just applying two functions to each side of the tuple
10:56:41 <benzrf> oh wait
10:57:00 <benzrf> yeah that's what i meant by 'in parallel'
10:57:01 <oleo> parallell would be f g (a, b) = f(a, b) g(a, b)
10:57:20 <oleo> ?
10:57:27 <benzrf> nvm
10:57:39 <oleo> actually you can't apply fg parallelly ?
10:57:49 <oleo> cause fog gof ?
10:57:55 <benzrf> huh?
10:57:59 <bennofs> Ok, because "in parallel" could also refer to the evaluation strategy :)
10:58:04 <oleo> ah ok
10:59:06 <benzrf> i just realized, `uncurry (***)' could be <*> for (a, b) couldnt it?
10:59:18 * hackagebot git-annex 5.20131230 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20131230 (JoeyHess)
11:00:01 <pavonia> Can anyone recommend a purely pixel based library compatible with gtk2hs?
11:00:19 <pavonia> *graphics library
11:01:19 <sjoerd_visscher> Is there a way to declare a newtype in a closed data family?
11:01:38 <benzrf> liftA2 and liftM2 are supposed to be identical right
11:01:45 <quchen> benzrf: No, <*> for (a,b) does not operate on both components. It apples a function to one component and appends the monoid parts.
11:01:53 <quchen> Yes, liftA2 = liftM2.
11:02:00 <benzrf> ok
11:02:16 <benzrf> quchen: yeah, but it would also work as an alternative instance, right?
11:02:27 <benzrf> like the difference between [] and ZipList
11:03:13 <quchen> > (Sum 1, (++ " world!")) <*> (Sum 100, "Hello,")
11:03:17 <lambdabot>  (Sum {getSum = 101},"Hello, world!")
11:04:03 <fread228_> > Sum 2
11:04:04 <lambdabot>  Sum {getSum = 2}
11:05:59 <adnauseam> does anyone here use functional java ?
11:06:33 <benzrf> adnauseam: is that possible?
11:06:48 <benzrf> a lambda in java is like 3 lines
11:07:32 <benzrf> new Function<String, String>() {
11:07:46 <benzrf>   public String apply(String a, String b) {
11:07:51 <benzrf>     return a + b;
11:07:53 <benzrf>   }
11:07:54 <benzrf> }
11:08:12 <benzrf> no wait that's wrong
11:08:13 <benzrf> w/e
11:08:31 <benzrf> make that <String, String, String>
11:08:45 <benzrf> and 2ArgFunction
11:08:45 <geekosaur> java: cobol for a new generation
11:08:50 <benzrf> bahaha
11:13:08 <BMeph> I Protest, geekosaur! :(
11:13:34 <benzrf> @hoogle Int -> [a] -> [a]
11:13:35 <lambdabot> Prelude drop :: Int -> [a] -> [a]
11:13:35 <lambdabot> Data.List drop :: Int -> [a] -> [a]
11:13:35 <lambdabot> Prelude take :: Int -> [a] -> [a]
11:13:36 <Thooms> do you guys have any reference for a book on dependant types (preferably with exercices) ?
11:13:44 <BMeph> I liked and respected COBOL, as a clear advancement in the art and tech of programming.
11:13:53 <maxiepoo> > (||) <$> (print 1 >> return True) <*> (print 2 >> return False)
11:13:54 <lambdabot>  <IO Bool>
11:14:15 <maxiepoo> er
11:14:42 <maxiepoo> well I can't get lambdabot to print, but why does that print 1 and 2 instead of just 1?
11:14:43 <benzrf> maxiepoo: exprs cant have side effects m8
11:14:53 <benzrf> maxiepoo: because to get the result, both things must be evalled
11:15:06 <benzrf> oh wait i see what you're saying
11:15:10 <maxiepoo> yeah
11:15:26 <maxiepoo> I would assume that it's lazy and doesn't run the 2nd one unless the first is False
11:15:39 <maxiepoo> I just had a bug where this was the problem
11:15:52 <maxiepoo> I was assuming it would short-circuit
11:15:55 <benzrf> @src IO <*>
11:15:55 <lambdabot> Source not found. I've seen penguins that can type better than that.
11:15:59 <benzrf> @src IO (<*>)
11:16:00 <lambdabot> (<*>) = ap
11:16:03 <benzrf> >_>
11:16:06 <benzrf> @src IO ap
11:16:07 <lambdabot> Source not found. Wrong!  You cheating scum!
11:16:20 <benzrf> @src ap
11:16:20 <lambdabot> ap = liftM2 id
11:16:26 <geekosaur> if it's in IO it has to run it anyway, specifically because it might have a side effect such as printing
11:16:58 <benzrf> :t id
11:16:59 <lambdabot> a -> a
11:17:06 <benzrf> how can you liftm2 that?!
11:17:08 <benzrf> oh wait i see
11:17:11 <maxiepoo> yeah I guess it would be more confusing if you expected the other behavior
11:17:12 <benzrf> clever
11:17:43 <maxiepoo> I guess I could write a short circuiting (||) for any monad
11:18:15 <maxiepoo> (m1 <||> m2) = do b1 <- m1; if b1 then return b1 else m2
11:18:52 <adnauseam> benzrf: just trying to spice things up :( forced to use java for all sorts of courses.
11:18:58 <benzrf> ouch
11:19:11 <benzrf> could you write scala, then decompile it to java?
11:19:11 <benzrf> :D
11:19:29 <benzrf> i should really learn scala...
11:19:33 <joelteon> is there a haskell library that does downloads that I can get a progress indicator from?
11:19:36 <benbangert> what kind of compile options should I have for OSX? cabal build is giving me an error like this: http://paste.ofcode.org/BPmDMUD3M5qY2DiY8kji3V
11:19:46 <adnauseam> code gets reviewed and must be annotated =[
11:20:04 <benzrf> the type of liftM2/liftA2 when M/A is a function is this:
11:20:05 <benzrf> (a -> b -> c) -> (r -> a) -> (r -> b) -> (r -> c)
11:20:08 <benzrf> right?
11:20:44 <BMeph> Right!
11:20:58 <benzrf> ok
11:23:39 <benzrf> so ignoring the typeclass stuff and thinking of liftA2 and (&&&) as working only on functions... you could say:
11:23:42 <benzrf> liftA2 f g h = uncurry f . (g &&& h)
11:23:42 <benzrf> right?
11:24:10 <maxiepoo> not surprised there's already a library with this: http://hackage.haskell.org/package/shortcircuit-0.1/docs/Control-Shortcircuit.html
11:25:40 <benzrf> maxiepoo: when would that be useful?
11:25:42 <benzrf> performance?
11:25:47 <bennofs> benzrf: seems right
11:26:04 <benzrf> o:
11:26:42 <maxiepoo> benzrf: it's for a build system
11:26:53 <carter> tautologico: oh you're here too
11:26:54 <carter> merijn: sac is alive?
11:26:59 <maxiepoo> the 1st action sees if a file exists and the second assumes it does
11:27:11 <maxiepoo> so it should only be run if the 1st one returns true
11:28:12 <bennofs> maxiepoo: If your writing a build system, have you looked at shake? I liked it a lot
11:28:52 <benzrf> why cant you people just use shell scripts for building like the rest of us peons
11:28:56 <benzrf> >:C
11:29:16 <bennofs> benzrf: shake is actually quite nice, it's a haskell DSL for building
11:29:25 <maxiepoo> bennofs: it's for the build system in a compiler
11:29:31 <bennofs> ah, ok :)
11:32:07 <fread228_> maxiepoo: have you looked at shake?
11:32:30 <fread228_> maxiepoo: it might still work
11:32:30 <maxiepoo> fread228_: I haven't except for the homepage
11:33:02 <maxiepoo> fread228_: It's also an oss project that I don't have that much control over
11:33:19 <fread228_> maxiepoo: oh, ok
11:33:31 <maxiepoo> otherwise I would totally try it!
11:33:39 <carter> @tell merijn  i can't find any recent papers on SAC, please point me to them :)
11:33:39 <lambdabot> Consider it noted.
11:33:59 <maxiepoo> (<||>) : Monad m => m Bool -> m Bool -> m Bool
11:34:04 <maxiepoo> that's probably a bad name
11:34:20 <maxiepoo> because it looks applicative when it's actually monadic?
11:34:22 * hackagebot aws 0.8.4 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.8.4 (AristidBreitkreuz)
11:34:55 <maxiepoo> maybe (||>>) ?
11:34:58 <maxiepoo> or just orM
11:35:01 <carter> ooo found em
11:35:10 <carter> merijn: ignore me, found it
11:35:36 <fread228_> =||= ?
11:35:44 <fread228_> or ust =|| ?
11:35:52 <fread228_> *just
11:36:00 <bennofs> =|= ?
11:37:08 <maxiepoo> I'm thinking >> is the sign for monadic right?
11:37:20 <maxiepoo> why the =?
11:37:25 <quchen> Arguably. >> is monadic, but Applicative is enough to implement it.
11:37:33 <quchen> (>>) = (*>)
11:37:33 <maxiepoo> oh that's true
11:37:48 <quchen> But (>>) has a more restrictive type signature. So it's monadic, but unnecessarily so.
11:38:25 <benzrf> @src (*>)
11:38:25 <maxiepoo> quchen: but I mean as a naming convention
11:38:25 <lambdabot> (*>) = liftA2 (const id)
11:38:31 <benzrf> ahihi:
11:38:32 <benzrf> *ah
11:38:36 <maxiepoo> like (>>=), (=<<), (>>)
11:38:54 <maxiepoo> the two > or <'s signifies monad
11:38:54 <quchen> The standard operators with >> are all monadic I think, yes.
11:39:06 <maxiepoo> (>=>) and (<=<
11:39:07 <maxiepoo> )
11:39:14 <maxiepoo> maybe (>||>)
11:39:20 <quchen> There are other operators from other libraries with >> in them that aren't monadic though.
11:39:21 <maxiepoo> looks like kirby lol
11:39:43 <maxiepoo> quchen: hm
11:39:46 <fread228_> Maybe |<< ?
11:39:50 <benzrf> so *> is like <$ but with <*>
11:40:28 <maxiepoo> fread228_: that looks like something is flowing to the left though?
11:40:45 <benzrf> so ive been doing little bits of haskell for like 6-9 months now
11:40:50 <benzrf> when will my brain stop hurting ;-;
11:41:08 <Thooms> benzrf: never, sorry
11:41:08 <maxiepoo> I think I'm just going to go with `orM` haha
11:41:11 <benzrf> whyyy
11:41:25 <benzrf> the hurting has mostly stopped in imperative languages
11:41:26 <fread228_> maxiepoo: true, some kind of direction indicates short-circut to me though
11:41:27 <benzrf> why not here
11:41:30 <benzrf> T_
11:41:30 <benzrf> T
11:41:43 <shachaf> You can write a short-circuiting or with Monad, which you can't with Applicative.
11:41:46 <Thooms> and if it stops hurting, go learn Agda
11:41:59 <shachaf> Anyway, don't come up with crazy symbols unless you'll use them enough to justify them.
11:42:08 <ktosiek> is there something like Text.Parsec.Token but with support for significant line breaks?
11:42:36 <maxiepoo> shachaf: yeah, agreed
11:44:04 <maxiepoo> > let minus = (-)
11:44:05 <lambdabot>  not an expression: `let minus = (-)'
11:44:13 <maxiepoo> > minus = (-)
11:44:14 <lambdabot>  <hint>:1:7: parse error on input `='
11:44:21 <benzrf> @let minus = (-)
11:44:22 <lambdabot>  Defined.
11:44:33 <fread228_> > minus 1 2
11:44:35 <lambdabot>  -1
11:44:52 <bennofs> @quickCheck \x y -> minus x y == flip subtract x y
11:44:52 <lambdabot> Unknown command, try @list
11:45:05 <maxiepoo> > 10 `minus` 2 `minus` 3
11:45:07 <lambdabot>  5
11:45:47 <maxiepoo> > 10 `minus` (2 `minus` 3)
11:45:49 <lambdabot>  11
11:46:01 <carter> merijn: actually i'm not sure if i'm finding em all, so  links to more would be great
11:46:02 <bennofs> @check \x y -> minus x y == flip subtract x y
11:46:04 <lambdabot>  +++ OK, passed 100 tests.
11:46:37 <maxiepoo> can you make non-operators associate to the right?
11:46:52 <geekosaur> yes, infixr etc. work on `function`
11:47:07 <shachaf> Or perhaps `minus` is an operator.
11:47:15 <geekosaur> ``` infixr 4 `minus` ``` or whatever
11:47:18 <maxiepoo> oh cool
11:47:47 <benzrf> ( ) :: (a -> b) -> a -> b
11:51:38 <carter> @tell merjin nvm, found more
11:51:39 <lambdabot> Consider it noted.
11:55:29 <maxiepoo> hm shake looks really cool actually
11:55:44 <maxiepoo> but probably not worth rewriting the whole thing at this point
11:56:53 <simpson> ktosiek: Look at the parsers package; Text.Parsers.Token has an Unlined newtype which you can use to get newlines to not be whitespace.
11:57:25 <carter> maxiepoo: shake for what?
11:57:29 <boom583> merijn: it seems I finally got it by writing it as functions. lambda(1,lambda(2,lambda(3,0)))
11:57:44 <maxiepoo> the --make option for a compiler
11:58:11 <jle`> llll
11:58:16 <boom583> merijn: and I've created a rule of thumb that makes sense to me: If the lambda returns something other than acc (the first argument for foldl and the second argument for foldr), it will STOP.
11:58:25 <boom583> does this sound good to you?
11:59:11 <boom583> merijn: but if the lambda returns acc, or something that is dependent on acc, it will NOT STOP.
12:01:34 <shachaf> That depends on what you mean by "dependent".
12:01:54 <boom583> shachaf: well if "acc" is somewhere in it
12:01:56 <shachaf> I think you have an inside-out view of how things are evaluated such that rules of thumb like that will only confuse you.
12:02:01 <shachaf> OK, that's not true.
12:03:15 <boom583> shachaf: well, what about: if "acc" is somewhere within it AND is actually needed
12:03:29 <boom583> of course maybe it could be [0,acc]!!0
12:03:31 <boom583> or whatever
12:03:34 <boom583> in that case it wouldn't be needed
12:04:13 <shachaf> If by "needed" you mean "forced".
12:05:05 <boom583> forced?
12:06:57 <quchen> The "acc" parameter is where the next step of the fold will be placed, see the definition of foldr. If you don't use the "acc", there is no next fold step, hence the operation terminates.
12:07:24 <mcstar> remain unevaluated?
12:07:39 <shachaf> The word "acc" is not actually mentioned anywhere in foldr's definition. I recommend not using it.
12:07:48 <shachaf> 09:55 <shachaf> There is no accumulator.
12:07:49 <shachaf> 09:55 <shachaf> "acc" is a misleading name because foldr doesn't have an accumulator in the ordinary sense.
12:08:22 <quchen> shachaf: Right, it's probably better to call it something else, I just got used to the silly convention. "rest" makes a better name I guess.
12:08:42 <boom583> well it's used in LYAH so whatever
12:09:23 <benmachine> you can see a foldr as accumulating a value, but it's not the best way to see it if you want to understand why it doesn't need the whole list
12:09:26 * hackagebot ini 0.0.0 - Quick and easy configuration files in the INI format.  http://hackage.haskell.org/package/ini-0.0.0 (ChrisDone)
12:09:32 <boom583> quchen: ah that makes sense!!!!
12:09:44 <boom583> what's the way to get the defintion of functions again?
12:09:46 <boom583> in ghci
12:09:53 <benmachine> you can't, sadly
12:10:03 <boom583> what the devil
12:10:04 <quchen> LYAH does a terrible job at explaining foldr, sadly.
12:10:04 <boom583> ok
12:10:13 <boom583> quchen: yeah, it's a bit misleading
12:10:19 <quchen> It's flat out wrong.
12:10:22 <boom583> oh
12:10:24 <boom583> lol
12:10:24 <benmachine> boom583: in fairness, GHCi usually only has access to compiled code, so it can't tell you what it used to look like
12:10:30 <boom583> ok
12:10:34 <quchen> "The right fold, foldr works in a similar way to the left fold, only the accumulator eats up the values from the right."
12:10:41 <quchen> No, foldr doesn't do anything from the right.
12:10:49 <benmachine> quchen: I don't think that's wrong as such
12:11:14 <benmachine> > foldr f z [a,b,c] :: Expr
12:11:15 <lambdabot>  f a (f b (f c z))
12:11:16 <boom583> quchen: it's true only if the whole thing actually happens, but even then it doesn't happen in that order
12:11:18 <quchen> Once you walk through the entire list and view how the thunk looks like, you can see that it's associated to the right.
12:11:30 <quchen> But that's not how foldr works, what foldr is good for, or anything else with foldr.
12:11:33 <nstdloop> The only time the distinction between "eating values from the right" and what foldr actually does is when it is applied to infinite lists
12:11:43 <benmachine> nstdloop: not true
12:11:57 <boom583> quchen: is anything else in LYAH that sucks?
12:12:15 <benmachine> it's also relevant when applied to lists containing partial values, and operationally
12:12:30 <nstdloop> benmachine: I think what LYAH means is that foldr evaluates from the right side of the list
12:12:37 <nstdloop> true true
12:12:42 <nstdloop> Didn't think of that.
12:12:44 <quchen> boom583: I think foldr is my #1 pet peeve with the book; if I ever had a #2 I don't remember it :-)
12:12:51 <boom583> quchen: ok cool
12:12:52 <boom583> thanks
12:13:02 <bennofs> How would I implement a function that works over a 2D grid of values and needs access to the values above/below/right/left the current position?
12:13:04 <nstdloop> But it makes conceptual sense because you can see that in:
12:13:13 <nstdloop> > foldr f z [a, b, c] :: Expr
12:13:15 <lambdabot>  f a (f b (f c z))
12:13:21 <nstdloop> f c z is evaluated first
12:13:25 <mauke> wat
12:13:26 <quchen> No.
12:13:27 <nstdloop> then f b (that)
12:13:30 <quchen> No.
12:13:40 <quchen> f a (something)  is evaluated first.
12:13:45 <mauke> f is evaluated first
12:13:47 <bennofs> I implemented it using a comonad Cell a = Cell [([a], a, [a])] ([a],a,[a]) [([a], a, [a])], maybe there is something simpler?
12:13:54 <boom583> so where do I go to get the function defintions like on this IRC channel? This IRC channels has them really simple. On haskell.org they're all full of comments and shit
12:14:27 * hackagebot ini 0.0.1 - Quick and easy configuration files in the INI format.  http://hackage.haskell.org/package/ini-0.0.1 (ChrisDone)
12:14:27 <nstdloop> The first thing to be actually calculated, not simply pushed, is f c z, because you can't do anything with f a (something) before you know the something.
12:14:45 <quchen> boom583: The Haskell Report gives easy-to-read definitions of Prelude functions.
12:14:47 <benmachine> nstdloop: except that frequently you can :P
12:14:51 <shachaf> nstdloop: You're saying wrong things, and several people have corrected you. :-(
12:15:13 <nadirs> where does Expr come from? Can I use it in ghci or is it a lambdabot thing?
12:15:16 <mauke> nstdloop: denied
12:15:22 <quchen> nadirs: simple-reflect
12:15:30 <nstdloop> So... what actually happens?
12:15:40 <boom583> quchen: this? http://www.haskell.org/onlinereport/prelude-index.html
12:15:47 <mauke> nstdloop: f is evaluated first, then f a, then f a (...)
12:15:51 <nadirs> quchen++
12:16:19 <quchen> boom583: No, those are just type signatures. I don't know about the HTML version, but the PDF of the Haskell 2010 report has lots of default implementations.
12:16:28 <boom583> ok
12:16:36 <nstdloop> > foldr f z [1..] :: Expr
12:16:37 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 (f 11 (f 12 (f 13 (f 14 (f...
12:16:40 <quchen> They should be in the online report somewhere as well, I just can't tell you where.
12:16:51 <boom583> quchen: it seems by clicking on the funcs I get their defs
12:17:16 <schlegel> bennofs: Have you looked into repa stencils?
12:17:30 <shachaf> http://www.haskell.org/onlinereport/haskell2010/haskellch9.html
12:18:11 <benmachine> nstdloop: the key is that f if you have f a (something) and f is say, const, then you don't need to know what (something) is
12:18:28 <shachaf> Or even if f is, say, cons.
12:18:28 <benmachine> er, "that if"
12:18:35 <bennofs> :( hayoo down again
12:18:36 <benmachine> sure, that too
12:18:50 <quchen> nstdloop: The result of a foldr is *not* a foldr:  foldr f z (x:xs) = f x (foldr f z xs).  The result of this is whatever "f x (...)" evaluates to.  That *may* lead to a recursive call to foldr, but doesn't have to.
12:18:52 * nstdloop has revelation
12:19:29 <nstdloop> That makes so much sense...
12:19:36 <Philonous> Can someone please confirm that https://gist.github.com/8187461 will crash GHC with memory exhaustion when compiled with -O2 ?
12:19:56 <bennofs> schlegel: I haven't looked at repa at all, thanks!
12:20:01 <schlegel> bennofs: http://www.tapdancinggoats.com/haskell-life-repa.htm
12:20:41 <quchen> Philonous: Could not find module `Data.Singletons.TH'
12:21:08 <nstdloop> Philonous: Same here.
12:21:11 <Philonous> quchen, cabal install singletons
12:23:15 <nstdloop> Ghc currently taking forever after Loading package singletons-0.9.3 ... linking ... done.
12:23:22 <nstdloop> stack overflow
12:23:30 <Philonous> nstdloop, Thanks a bunch!
12:23:34 <nstdloop> Sure.
12:23:39 <quchen> Philonous: It exceeded my available RAM.
12:23:47 <quchen> I then killed it before too much swapping goes on.
12:23:57 <quchen> Also stack overflow.
12:24:01 <boom583> ok i'm feeling happier now. was really pissed off earlier about fold
12:24:07 <boom583> thanks all
12:24:13 <Philonous> quchen, nstdloop Thanks, I will file a bug report.
12:31:36 <kakos> I have a cabal project that is building a library. In this library, I have a source file called System/PAM.chs. When I try to build the library, I get an error "dist/build/System/PAM.hs:1:1:\n   File name does not match module name:\n  Saw: `Main'\n    Expected:  `System.PAM'"  Looking at the generated .hs file, I don't see anything at all relating to Main
12:31:39 <kakos> Any ideas what is going on?
12:32:32 <shachaf> Main is the default module name if you don't specify one.
12:32:45 <shachaf> Try putting "module System.PAM where" or something like that at the top of the file.
12:33:03 <mcstar> can someone give me a @qcheck example?
12:33:39 <mcstar> right now, pls, here
12:33:47 <kakos> shachaf: Already there. In both the chs file and the generated hs file.
12:33:55 <mcstar> just how to call it, and if i need type sigs
12:34:04 <aristid> @check \x -> x == True
12:34:05 <lambdabot>  *** Failed! Falsifiable (after 1 test):
12:34:05 <lambdabot>  False
12:34:14 <mcstar> i tried this:
12:34:22 <mcstar> @check \x y -> x == y
12:34:23 <lambdabot>  +++ OK, passed 100 tests.
12:34:27 <mcstar> which didnt make sense to me
12:34:28 <shachaf> Well. My well of guesses is dry. Try showing the file. :-)
12:34:31 <aristid> obviously passes.
12:34:32 <mauke> mcstar: x :: ()
12:34:33 <mcstar> so, i guess there is defaulting
12:34:44 <mcstar> mauke: how can i avoid that?
12:34:51 <mauke> add a type annotation
12:34:55 <kakos> Wait... I think I may be doing something super dumb...
12:34:59 <mcstar> inline?
12:35:01 <cwraith> @check id
12:35:02 <lambdabot>  No instance for (Test.QuickCheck.Arbitrary.Arbitrary a0)
12:35:02 <lambdabot>  arising from a use of `Lambdabot.Plugin.Haskell.Check.ShowQ.myquickcheck' Th...
12:35:07 <mcstar> @check \(x::Int) y -> x == y
12:35:08 <lambdabot>  <unknown>.hs: 1: 11:ScopedTypeVariables is not enabled
12:35:17 <mauke> @check \x y -> (x :: Int) == y
12:35:18 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 1 shrink):
12:35:18 <lambdabot>  0 1
12:35:22 <mcstar> :set -XScopedTypedVariables
12:35:35 <cwraith> @check \x -> x == reverse x
12:35:36 <lambdabot>  +++ OK, passed 100 tests.
12:35:37 <mcstar> mauke: thanks
12:35:39 <mauke> @check \x y -> (x :: Double) == y
12:35:40 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 2 shrinks):
12:35:41 <lambdabot>  0.0 1.0
12:35:54 <Fuuzetsu> oh, we have QC now?
12:36:00 <aristid> Fuuzetsu: this is not new.
12:36:03 <mauke> @check \x -> x == length [x]
12:36:05 <lambdabot>  *** Failed! Falsifiable (after 1 test):
12:36:05 <lambdabot>  0
12:36:09 <aristid> i guess it might have been broken for a time
12:36:14 <geekosaur> it was broken for a while
12:36:25 <kakos> shachaf: Yup, I was an idiot. I had my imports before the "module System.PAM where" statement
12:36:37 <bennofs> schlegel: Can I also have a repa stencil to take the minimum of all neighbour values?
12:37:27 <Fuuzetsu> @check \f x y -> flip (flip f) x y == f x y
12:37:28 <lambdabot>  +++ OK, passed 100 tests.
12:39:30 <mcstar> @qcheck \l -> foldr (:) [] l == foldl (flip (:)) [] (reverse (l::[Int]))
12:39:31 <lambdabot>  +++ OK, passed 100 tests.
12:39:42 <mcstar> thats not what it said to me in private...
12:40:07 <mcstar> oh
12:40:20 <mcstar> @qcheck \f l -> foldr f [] l == foldl (flip f) [] (reverse (l::[Int]))
12:40:23 <lambdabot>  (0 tests) (1 test) (2 tests) (3 tests) (4 tests) (5 tests) (6 tests) (7 test...
12:40:29 <enthropy> is there a quickcheck which reduces the search space by using parametricity?
12:40:55 <mcstar> weird, that it gots wrong the '0 tests' and '1 test'
12:41:03 <mcstar> and anyway, what does that output mean?
12:41:25 <mauke> got what wrong?
12:41:39 <mcstar> well, 1 test is correct
12:41:45 <mcstar> maybe 0 tests too?
12:41:52 <mcstar> yes, sry
12:41:52 <mauke> yes
12:41:59 <enthropy> @check \(Positive n) -> foldr (:) [] [1 .. n :: Int] == foldl (flip (:)) [] (reverse [1 .. n])
12:42:03 <lambdabot>  (0 tests) (1 test) (2 tests) (3 tests) (4 tests) (5 tests) (6 tests) (7 test...
12:42:03 <mcstar> my mistake, but what does the output mean?
12:42:16 <mcstar> can it quick check if f is a parameter?
12:42:18 <ClaudiusMaximus> enthropy: http://hackage.haskell.org/package/lazysmallcheck perhaps
12:42:46 <enthropy> yes that's the same goal, but lazysmallcheck is a different strategy
12:44:26 <Axman6> > [1..-3]
12:44:27 <lambdabot>  Not in scope: `..-'
12:44:34 <Axman6> > [1.. (-3)]
12:44:35 <lambdabot>  []
12:44:41 <mauke> > [1 .. -3]
12:44:43 <lambdabot>  []
12:45:24 <c_wraith> > let 1..-3 = 27 in [1..-3]
12:45:26 <lambdabot>  [27]
12:45:53 <dv-> > enumFromTo (-1) (3::Int)
12:45:55 <lambdabot>  [-1,0,1,2,3]
12:45:57 <mauke> > let 1 = 2 in 3
12:45:59 <lambdabot>  3
12:46:11 <mcstar> ok, so what is happening up there?
12:46:25 <mcstar> does QC pull a function out of its hat?
12:46:27 <Axman6> > let Just x = Nothing in "hello"
12:46:29 <lambdabot>  "hello"
12:46:39 <Axman6> > let Just x = Nothing in x
12:46:40 <lambdabot>  *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Dat...
12:47:01 <mauke> > case Nothing of ~Just x -> x
12:47:02 <lambdabot>  <hint>:1:17: Parse error in pattern: ~Just
12:47:06 <enthropy> ClaudiusMaximus: http://wiki.portal.chalmers.se/cse/pmwiki.php/FP/TestingPolymorphicProperties is one take on that idea, but there's no code to do such a thing (that I've found, or that the authors replied about)
12:47:10 <mauke> > case Nothing of ~(Just x) -> x
12:47:11 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Irrefutable pattern failed for patte...
12:47:39 <xintron> Is there any list of syntax highlighting support for pandoc (what languages/config syntax that is supported)?
12:48:13 <ClaudiusMaximus> enthropy: oh, ok
12:48:23 <enthropy> mcstar: looks like you get that output when your test takes too long
12:49:21 <mcstar> enthropy: ok, but it means, that QC tries to fill in (a -> b) forms too, not just `a`?
12:49:43 <mauke> QC doesn't try to fill in a
12:49:43 <enthropy> yes it can generate functions for you
12:50:14 <bennofs> How can I write a function to convert a repa array to a Gloss Picture?
12:50:25 <enthropy> @check \f g -> (f :: Int -> Bool) 1 == (g :: Int -> Bool) 2
12:50:27 <lambdabot>  *** Failed! Falsifiable (after 1 test):
12:50:27 <lambdabot>  <Int -> Bool> <Int -> Bool>
12:50:38 <bennofs> I think I'd need to use foldAllP, but Picture is not an instance of Unbox
12:52:37 <Cale> bennofs: Which repa representation are you using?
12:52:56 <Cale> bitmapOfForeignPtr :: Int -> Int -> ForeignPtr Word8 -> Bool -> Picture
12:53:00 <Cale> bitmapOfByteString :: Int -> Int -> ByteString -> Bool -> Picture
12:53:09 <Cale> Probably you'll use one of those two
12:53:16 <mcstar> mauke: if i said, os a first approximation, that QC fills in leaves of the ADT, would i be close?
12:53:22 <mauke> no
12:53:36 <mcstar> then how... :(
12:53:37 <mauke> QC generates values of concrete types
12:53:59 <mauke> Int -> Bool is a concrete type
12:54:05 <mcstar> ah, when no type parameter remains?
12:54:26 <bennofs> Cale: My repa array doesn't contain picture data. It contains numbers, and I'd like to draw them as "tiles" with different color depending on the number
12:54:50 <Cale> oh
12:54:51 <quchen> mcstar: When you have open type parameters QC will typically complain that it doesn't know what Arbitrary instance to use for that parameter.
12:54:59 <Cale> Like, making rectangles from them?
12:55:03 <bennofs> yes
12:55:35 <mcstar> mauke: so, it tries to find a value of any of the expressions with concrete type (that comes as a lambda parameter) that makes the result false?
12:56:22 <mauke> yeah
12:56:28 <mauke> there's shenanigans with typeclasses going on
12:56:44 <mauke> each supported type provides a method to generate random values
12:57:01 <mauke> and it tries a bunch of them to see if any of them result in false
12:57:01 <mcstar> now im trying to wrap my head around, whether expressions with functions as parameters actually make sense to QC
12:57:20 <mcstar> to quickcheck
12:57:33 <Axman6> mcstar: http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf
12:57:38 <enthropy>  instance (Arbitray a, Testable b) => Testable (a -> b) -- or something like that lets you supply any number of arguments
12:58:20 <Axman6> jesus, why on earth doesn'y firefox use OS X's native PDF rendering. I can see the damn file loading line by line! that shit's instant in PDFKit based stuff
12:58:30 <mcstar> downloaded
12:59:02 <mcstar> Axman6: scroll is laggy in preview
12:59:05 <geekosaur> Axman6, "security"
12:59:33 <geekosaur> and using the same thing everywhere (so what they're really trying to avoid is acroread on linux/windows but they just use the same code everywhere)
13:00:11 <Axman6> mcstar: I've never ever noticed that. it's always been surpridingly fast for me. especially when compared with Adobe's crap
13:00:12 <Cale> I would probably do something like  pictures [color (f i j) . translate i j $ rectangleSolid 1 1 | i <- [...], j <- [...]] where f i j = something involving makeColor ... index myArray (i :. j :. Z)
13:00:27 <quchen> Why does "\x -> (x :: a)" not typecheck? It seems I'm misunderstanding how lambdas work.
13:00:29 <Cale> bennofs: ^
13:00:36 <bennofs> Cale: thanks!
13:00:39 <mcstar> Axman6: yeah, acroread is the worst, on every document, and preview is very fast, always
13:00:40 <Kratos_> Hi!
13:00:44 <quchen> Does that look like I'm typecasting x to a to GHC or something?
13:00:44 <mcstar> but somehow, this makes it lag
13:01:02 <Cale> quchen: You're insisting that x is completely polymorphic
13:01:07 <bennofs> Cale: I could also use toUnboxed and then use fold from vector
13:01:30 <enthropy> quchen: it works if you have 'a' in scope from something outside
13:01:37 <merijn> quchen: Probably needs more ScopedTypeVariables
13:01:47 <Cale> quchen: Unless you have ScopedTypeVariables on and you've explicitly forall'ed some type variable a in the surrounding declaration
13:01:50 <quchen> merijn: That would be if I wanted to write \(x :: a) -> a
13:01:52 <enthropy> let f :: forall a. a -> a; f = \x -> (x :: a)
13:02:02 <merijn> carter: There were 3 SAC papers at IFL in August :)
13:02:11 <Cale> quchen: x :: a says "x is of any type whatsoever"
13:02:15 <merijn> carter: And one at ICFP
13:02:17 <quchen> Cale: So I'm asking for "\x -> (x :: forall a. a) there?
13:02:20 <Cale> yes
13:02:20 <carter> i found the icfp one
13:02:32 <carter> theres no upto date project links or repo i can find
13:02:37 <carter> sooo its been hard fo rme to figure out
13:02:58 <quchen> Cale: Ah, and when it tries to unify the two "x" the forall refuses to let the "a" leak
13:03:09 <merijn> carter: Yeah, basically Bodo moved from Hertfordshire to Heriot-Watt, but Heriot-Watt IT is a pain in the ass
13:03:19 <Kratos__> I had an issue with my connection
13:03:28 <Kratos__> http://lpaste.net/9219334737531764736
13:03:33 <merijn> carter: They won't allow the group to run its own servers, but after 9 months haven't gotten the mailing lists back up online, etc.
13:03:37 <mauke> typeOf (x :: a) = a
13:03:38 <Kratos__> Please help me out with the quickCheck property in lines 54-55
13:03:42 <Kratos__> Thanks :)
13:03:49 <carter> merijn: so maybe they should host their own somewhere
13:04:18 <merijn> carter: Yes, that's one of the plans, but you know how life gets in the way when you need to migrate websites, etc. :)
13:04:28 <carter> merijn: oh gods yeah
13:04:32 <carter> i still haven'ted updated mine
13:04:36 <enthropy> @type forAll
13:04:37 <lambdabot> (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
13:04:42 <carter> otoh, i'm a wee bit self employed soooo
13:04:49 <carter> i've excused for being overloaded
13:05:01 <merijn> carter: I'll tell the ones that will be at NL-FP to hurry up and fix things :)
13:05:10 <carter> cool
13:05:39 <carter> merijn: i've seen their layout types stuff. and i'm not super wowed, though its good work
13:05:41 <enthropy> Kratos__: you could use that to write:     forAll (oneof [ ... ]) \ arb e -> length ( vars (diff e arb)) >= 0
13:06:04 <merijn> carter: tbh, I haven't looked into it much yet :)
13:06:18 <carter> merijn: i've been hacking on array data models A LOT this past year
13:06:51 <carter> :)
13:07:44 <Kratos__> enthropy: that gives me a parse error. What is the backslash for? (Please excuse if I'm now being stupid in asking that).
13:07:51 <Thooms> does someone here study(ied) at Chalmers university ?
13:07:59 <enthropy> Kratos__: you could use that to write:     forAll (oneof [ ... ]) $ \ arb e -> length ( vars (diff e arb)) >= 0
13:08:02 <enthropy> sorry
13:08:14 <Kratos__> Thooms: I kind of do; having taken a couple of courses there
13:08:21 <enthropy> and instead of [ ... ] put the stuff you wrote about Var "a" and such
13:08:24 <klrr_> Thooms: do you? im study near it :P
13:09:08 <Thooms> no, I kind of have an opportunity to study there next year, in CS graduate school
13:09:17 <Thooms> I'm looking for some infos/report
13:09:20 <Thooms> :D
13:09:23 <merijn> carter: I believe a lot of work has been going into user specifiable shape constraints. So a semi-dependent typing direction (shapes depending on values, statically checked)
13:09:24 <Kratos__> enthropy: that still doesn't seem to work: Couldn't match expected type `Gen Name' with actual type `Expr'
13:09:34 <carter> merijn: i've been doing the same
13:09:50 <carter> merijn: i'm just not wowed by their examples
13:09:51 <Kratos__> Thooms: try to be a bit more specific.
13:10:03 <carter> merijn: though to be fair,  i need to stare at it more
13:10:06 <Thooms> yes sorry
13:10:14 <carter> merijn: is there a SAC distro / source repo anywhere?
13:10:20 <Thooms> hum, is it a good choice to study there
13:10:42 <Thooms> given that I'm fond of theory
13:10:47 <carter> merijn: ok, no public source repo blah
13:10:49 <carter> i don't care
13:11:03 <Thooms> (aka I'm a maths geek)
13:11:17 <flammi_> does anybody here knows a good example gtk2hs program on github or hackage?
13:11:24 <enthropy> Kratos__: oh oneof isn't the right thing to use
13:11:33 <merijn> carter: Not a public one, but should be possible to just access to the repo
13:11:44 <enthropy> oneof :: [Gen a] -> Gen a, but you need a   [a] -> Gen a
13:11:47 <carter> well, then i have to email someone
13:11:50 <carter> and i don't know who to email
13:12:00 <Kratos__> Thooms: if you're a "math geek" then why not do pure mathematics instead
13:12:15 <Thooms> I plan to do so, but not now
13:12:54 <Thooms> I'm in the middle of engineering studies
13:13:21 <aristid> carter: i've only skimmed the backlog but it appears you're now informed that SAC is not dead?:)
13:13:35 <carter> aristid: its not dead, it just stuck in a box in a locked basement
13:13:53 <aristid> carter: apparently 8 grad students or so are working on it
13:13:53 <Thooms> and when I say "maths geek", it's maths `inter` CS (type theory, computability, that kind of things) Kratos__
13:14:06 <carter> aristid: yes, but no code i can look at / use :)
13:14:09 <Kratos__> enthropy: so hoogle recommends "elements". I'll try that then
13:14:30 <aristid> carter: it seems like academics have more incentive to produce papers than useful code :)
13:14:47 <aristid> hmm maybe that's unfair to say
13:14:54 <carter> aristid: well, if i'm ever rich, i'm more apt to support manuels group than the SAC folks then :)
13:15:11 <aristid> carter: manuel chakravarty, the accelerate guy?
13:15:17 <carter> yeah
13:15:55 <aristid> merijn: any reason why it's not public?
13:16:01 <Fylwind> does anyone have a good technique for reducing all the "boilerplate" instances in the type signature? Like, e.g. (Hashable k, Hashable v) -> ...
13:16:05 <merijn> aristid: Politics :)
13:16:14 <aristid> merijn: that can mean anything and nothing
13:16:18 <enthropy> Fylwind: don't write the signatures at all
13:16:21 <aristid> merijn: any concrete thing you can say?
13:16:24 <Kratos__> enthropy: I'm still stuck here... when I'm using "elements", it still doesn't compile
13:16:43 <Fylwind> but everyone says I should write the signatures! :/
13:16:51 <tautologico> academics ARE better at producing papers than code, but that is the fault of the incentive system
13:17:22 <S11001001> Fylwind: if you like, turn on ConstraintKinds, then you can write type synonyms for collections of constraints.
13:17:37 <enthropy> then listen to them... it's your choice except in the cases where ghc requires you to do them
13:17:49 <S11001001> @k (Ord Int, Ord String)
13:17:50 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind v @ ? .
13:17:54 <S11001001> @kind (Ord Int, Ord String)
13:17:55 <lambdabot> Constraint
13:18:18 <Axman6> Flywind: class (Hashable k, Hashable v) => HashKV k v where; instance (Hashable k, Hashabke v) => HashKV k v where -- now you can use HashKV k v anywhere you used the old thing
13:18:41 <Fylwind> guess that would work, thanks :)
13:18:59 <S11001001> type HashKV k v = (Hashable k, Hashable v)
13:19:04 <enthropy> Axman6: type HashKV k v = (Hashable k, Hashable v) -- is better/newer
13:19:12 <enthropy> yeah
13:19:25 <Axman6> ah, indeed =)
13:19:46 <Axman6> can Constrai9nts be used at all on the left of =>?
13:19:57 <enthropy> but the class version of that is still useful
13:20:10 <S11001001> @ki Ord
13:20:11 <lambdabot> * -> Constraint
13:20:23 <S11001001> Axman6: only constraints can be used on the left of => :)
13:20:57 <enthropy>  class (MonadState s m, Num s) => StateNum m -- can't be done with type
13:22:08 <enthropy> Kratos__: what did you do?
13:23:49 <Kratos__> enthropy: I just added the second try to the lpaste: http://lpaste.net/9219334737531764736
13:23:56 <Kratos__> at the very end
13:24:01 <Axman6> S11001001: urgh, I meant the right =)
13:24:13 <merijn> Axman6: Yes!
13:24:19 <Kratos__> "Couldn't match type `Expr' with `[Char]'"
13:24:32 <merijn> Axman6: You can have constraints in phantom types with the right kind
13:24:35 * hackagebot elm-get 0.1 - Tool for sharing and using Elm libraries  http://hackage.haskell.org/package/elm-get-0.1 (EvanCzaplicki)
13:24:37 <S11001001> Axman6: as long as they go somewhere that fits
13:26:06 <Axman6> foo :: c => Foo c -> a?
13:27:35 <enthropy> Axman6: also you can leave off the "where" when there's no body
13:28:12 <Axman6> hmm, I thought I saw it used that way in Simon Marlow's book when talking about the Serialisable class
13:28:41 <nstdloop> #shameless-plug I'd really appreciate answers on this question http://stackoverflow.com/questions/20847281/what-are-the-cleverest-optimizations-ghc-makes
13:28:44 <enthropy> probably you want   foo :: c a => Foo c -> a
13:29:46 <enthropy> nstdloop: http://donsbot.wordpress.com/2009/03/09/evolving-faster-haskell-programs/
13:30:04 <Axman6> nstdloop: "passing everything off to LLVM for optimisation" is also pretty nice :P
13:32:56 <i_am_neuron> Hi guys newbie here. I'm outputting some text and numeric data on the screen, need to pad them. I do this to compute the padding: http://lpaste.net/97754 Is there a way to merge those two functions in one?
13:35:07 <pavonia> You could rewrite it to have type "Either Int String -> String"
13:36:59 <quchen> i_am_neuron: I don't think it's posssible in a useful way. You could always apply "show" to the function's argument, but showing a String adds aadditional quotation marks.
13:37:02 <enthropy> Kratos__: you can't write: diff (Var "x") (Var "x")
13:37:22 <quchen> > (length "foobar", length (show "foobar"))
13:37:23 <lambdabot>  (6,8)
13:38:01 <i_am_neuron> quchen: Yup, at the very beginning I did it for "Show a" and ran into issue like you describing
13:38:13 <enthropy> i_am_neuron: sn = ss . show
13:39:14 <enthropy> you can write a class with a method that does sn or ss, depending on the type
13:40:02 <enthropy> they aren't "merged" in the file that defines those functions, but they are merged at the site that uses them
13:40:14 <i_am_neuron> Cool, thanks for advices, I guess, I'll rewrite it using Either Int String
13:41:17 <imalsogreg> i_am_neuron: Will you ever want to ss a Double, Integer, etc?
13:42:11 <Fylwind> i find it a bit annoying that I have this data type that is *nearly* Functor but isn't because it requires Hashable x => (y -> x) on the function
13:42:19 <Kratos__> enthropy: the second version is what you recommended...
13:43:06 * enthropy only fixes one error at a time
13:43:17 <imalsogreg> i_am_neuron: If you might, then you may want to nix the sn function, and instead use everywhere a pattern more like:  ss $ show myValue
13:43:48 <enthropy> Kratos__: it works if you change the list to ["x","y","z"]
13:44:37 * hackagebot smtp-mail 0.1.4.4 - Simple email sending via SMTP  http://hackage.haskell.org/package/smtp-mail-0.1.4.4 (JasonHickner)
13:45:31 <Kratos__> enthropy: Thanks! it does work now
13:45:44 <i_am_neuron> imalsogreg: sn and ss are mostly passed to map and zipWith, so it'll require changing them to map (ss . show). Blergh
13:51:58 <S11001001> Fylwind: if the constraint is a function of the `f' you are lifting into, you can define a similar typeclass to Functor with a Constraint parameter using ConstraintKinds and MPTCS+FunDeps/TypeFamilies
13:52:44 <Fylwind> I get nauseous when I have to use that many extensions just to get some syntactic convenience. -.-
13:53:11 <bennofs> Am I allowed to use the StencilStatic constructor manually in repa?
13:53:23 <S11001001> Fylwind: it's not merely syntactic; a tremendous number of free theorems are suddenly lost when you go from *forall* b to *only Hashable* b
13:53:58 <S11001001> Fylwind: and it's 2, so what's your threshold for extensions?
13:54:15 <ocharles> Anyone have any "tricks" for making a data type who's strict in its fields lazy?
13:54:23 <Fylwind> none per se, I just don't know if it's worth the extra mile
13:54:37 <ocharles> linear's V2 type is strict in the x and y components, but I have an operation i'd like to do that could short-circuit (using Data.Foldable.or)
13:54:46 <bennofs> ocharles: put a lazy box in it?
13:54:49 <ocharles> but that's pointless if I fmap Bool's into it, because it's strict
13:54:58 <ocharles> bennofs: fmap into a Lazy type?
13:55:17 <ocharles> would data Lazy a = Lazy { go :: a } work?
13:55:20 <bennofs> I think wrapping your type in Identity work
13:55:25 <ocharles> or Identity :)
13:56:13 <ocharles> Identity is a newtype, so that won't work
13:56:31 <bennofs> hmm, right
13:57:09 <bennofs> Does anyone know if I can make a stencil in repa which takes the minimum of all surrounding cells?
13:58:12 <Fylwind> S11001001: thing is, while Haskell makes it easy to specialize classes (=>) trying to broaden classes (<=) is a lot harder (of course)
13:59:02 <negatratoron> it seems javascript is a much better language once you know Haskell
14:01:34 <Fylwind> negatratoron: why's that?
14:02:09 <hpc> Fylwind: you learn enough discipline to not do the bad parts
14:02:27 <Fylwind> bad parts? such as?
14:02:37 <Fylwind> (not all that familiar with JavaScript)
14:03:22 <yyyyy> Fylwind: i can think of equality implicitly coercing types for you as one
14:03:23 <luite> meh i'm not convinced ;p
14:03:26 <hpc> Fylwind: http://lpaste.net/97757
14:03:40 <hpc> Fylwind: {x: 1, y: 2} is a hash table
14:03:43 <hpc> but it's not returned
14:03:49 <hpc> because there's an implicit semicolon
14:04:07 <Fylwind> oh right, the implicit semicolon
14:04:10 <luite> urk why do people keep calling it a hash table :/
14:04:12 <klrr_> anyone know any haskell project that needs contribution?
14:04:13 <Fylwind> who came up with that crazy idea
14:04:23 <hpc> (yes, trwtf is using K&R brackets)
14:04:30 <Axman6> klrr_: ghc
14:04:37 <hpc> luite: because that's the data structure that it is
14:04:56 <merijn> hpc: Yeah, someone needs to learn to 1TBS
14:05:12 <Fylwind> in JS it's called "object", in Lua it's called "table", in Python it's called "dict[ionary]"
14:05:21 <Fylwind> but they are all just associative arrays
14:05:32 <hpc> eh, close enough
14:05:33 <klrr_> Axman6: do you got any directions or hints were to start? ive contributed a little bit to simple projects which i can understand the code of but bigger project like ghc is exactly what i want to get into so i can get some "real" experience
14:05:45 <luite> hpc: well it's an associative container, the actual implementation often isn't a hash table
14:05:53 <merijn> klrr_: Lamdu!
14:05:58 <Fylwind> JS's version is probably the least flexible though, since it only allows string keys
14:06:11 <gsnedders> Fylwind: FWIW, ES6 is introducing a more generic map type.
14:06:14 <hpc> Fylwind: i actually have a feeling that will also choke on the top line too
14:06:27 <klrr_> merijn: that IDE? trying it out is actually on my todo list :)
14:06:34 <hpc> Fylwind: turning it into "var foo;" because you can define functions that way
14:06:38 <Fylwind> isn't there a way to disable the autosemicolon
14:06:48 <negatratoron> I don't think you can disable auto semicolon
14:06:50 <merijn> klrr_: Not sure how much there is to try, last time I looked they couldn't actually generate code :p
14:06:53 <Fylwind> not even use strict?
14:07:08 <Fylwind> gsnedders: i see!
14:07:10 <hpc> strict isn't supported everywhere
14:07:10 <klrr_> merijn: aa okey
14:07:20 <hpc> some of us sad saps still deal with old IE
14:07:33 <merijn> klrr_: You can certainly try things, you just won't be able to compile anything you write :p
14:08:02 <Fylwind> someone should write a virus that autoupgrades every computer's IE to something less ancient :3
14:08:17 <negatratoron> I have just started to use higher-order functions in JavaScript to better effect after learning Haskell
14:08:46 <merijn> Fylwind: Good news, IE6 is no longer supported on Windows 8 (maybe not even 7) and since XP is going out of support corporate world will have to upgrade :)
14:08:47 <negatratoron> I really like that it's a functional language
14:09:12 <gsnedders> enthropy: IE6 isn't supported on anything after XP
14:09:19 <merijn> negatratoron: That sounds more like "I really like first-class functions" :)
14:09:21 <Fylwind> yea but who uses Windows 8! :P
14:09:28 <hpc> negatratoron: you should try writing functional perl ;)
14:09:28 <negatratoron> merijn, you're right
14:09:33 <gsnedders> That was totally the wrong nick. How on earth did I do that!?
14:09:39 <merijn> negatratoron: There's many more languages that support first-class functions than just functional ones :)
14:09:46 <gsnedders> merijn: IE6 isn't supported on Vista even.
14:09:55 <merijn> negatratoron: Hell, even Go has first class functions
14:10:04 <luite> yeah i woudn't really call js a functional programming language
14:10:06 <merijn> I think only C, Java and VB don't :p
14:10:12 <negatratoron> haha
14:10:24 <hpc> assembly has first-class functions if you set your ELF data right!
14:10:30 <Fylwind> IE6 is still >4%
14:10:42 <Fylwind> and >20% in "certain" countries
14:12:54 <spion> with the es6 arrow function syntax, higher order functions in JS really feel natural: let withThis = (obj, fn) => (...args) => fn.apply(obj, args)
14:12:58 <sclv_> luite: ping
14:13:15 <luite> sclv_: oh hai, yeah i need to send you stuff
14:13:22 <sclv_> haha yes the video is up now http://www.reddit.com/r/haskell/comments/1u1m5x/nyhaskell_video_ghcjs_bringing_haskell_to_the/
14:13:26 <sclv_> so there are requests
14:13:31 <gsnedders> Still doesn't have Haskell's type-system, though. :)
14:13:32 <sclv_> we did the best we could with the sound, honest :-P
14:14:12 <luite> thanks :)
14:14:17 <hpc> good soundwork is hard
14:14:36 <sclv_> nah we just had a crummy setup
14:14:41 * hackagebot hsimport 0.2.1 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.1 (DanielTrstenjak)
14:14:48 <sclv_> i actually had an audio engineer friend of mine take a crack at this and its still p bad
14:16:44 <teneen> In lazy evaluation, is it the case that every time a variable is referenced it is checked for being evaluated or not? does there have to be a branch?
14:17:38 <jle`> is there any difference between cabal configure && cabal build and cabal install?
14:17:50 <Axman6> I think anything that's been heap allocated is checked, but the check is simple because it uses the lowest 3 or so bits of the word to mark its status
14:17:53 <flebron> teneen: I imagine you could JIT-compile that sort of thing, but I don't know if GHC does irt.
14:19:42 <luite> no jit compilation
14:19:43 <ocharles> mm_bureau / mm_freak : wanna chat about how to organise collision detection in netwire again? :)
14:19:57 <ocharles> I'm interested about what you said about having this part be "non-wiry"
14:20:56 <luite> flebron: GHC uses pointer tagging, it uses the least significant bits of the pointer to encode this, so it can check without dereferencing
14:21:00 <flebron> luite: This is weird. I'm watching you give a talk on GHCJS in a background window as you typed that :p
14:23:00 <luite> flebron: (also used for encoding the constructor used for small adt's, so branching on those can be pretty fast too, and for function arity, to speed up calls to unknown functions)
14:23:28 <luite> flebron: i'll add the slides in a moment
14:23:55 <flebron> luite: Is there a good source on GHC internals?
14:25:46 <luite> flebron: these things are described in the stg papers + other papers from spj/marlow etc, and there is some commentary on the ghc wiki
14:26:32 <luite> flebron: and i found that -ddump-cmm is useful to see what's actually going on in the generated code
14:26:49 <flebron> Thanks :)
14:26:54 <skypers> woh
14:27:01 <skypers> I got an error while using catch
14:27:03 <klrr_> anyone know any haskell project that needs contribution?
14:27:06 <skypers> saying it’s deprecated in Prelude
14:27:20 <skypers> then, why is it even in Prelude?
14:27:27 <skypers>     Warning: In the use of `catch'
14:27:28 <skypers>              (imported from Prelude, but defined in System.IO.Error):
14:27:28 <skypers>              Deprecated: "Please use the new exceptions variant, Control.Exception.catch"
14:27:32 <skypers> (sorry for the paste)
14:27:40 <klrr_> backwards compatability perhaps
14:28:34 <quchen> GHC can always use contributors
14:28:40 <geekosaur> I thought it was already gone in 7.6.3?
14:28:56 <skypers> klrr_: arf
14:28:59 <geekosaur> older versions had it marked deprecated so that people using it would get warnings to change their code
14:29:17 <klrr_> skypers: arf, google didnt find it could you provide a link?
14:29:18 <skypers> so I need to import both Control.Exception and hiding Prelude.catch
14:29:20 <geekosaur> which is good practice when removing a function from a place where it used to be defined/exported
14:29:27 <skypers> @index catch
14:29:27 <lambdabot> Control.Exception, System.IO.Error, Prelude
14:29:55 <luite> flebron: ghcjs stays fairly close to ghc in the generated code, so it can't take specific advantage of the jit compiler (and it loses some things like pointer tagging)
14:30:30 <luite> flebron: but if you have ideas how it could be used here i'd be happy to discuss, perhaps try to make some proof of concept :)
14:31:26 <flebron> luite: I'm far too ignorant on implementation issues, a friend and I were going to do a bit of a seminar in uni about type theory and functional programming, and we were planning on discussing some implementation issues with the techniques used currently (starting with spj's talk on type class implementation)
14:31:42 <flebron> So I wanted to learn a bit more :)
14:32:24 <luite> flebron: (the code is still optimized in a way that the js jit compiler can do a decent job, and when js gets proper tailcalls we can possibly get better dynamic inlining for free)
14:35:42 <luite> flebron: ah yeah typeclasses are a good target for this kind of things, dictionary passing adds overhead, specialising everything doesn't scale very far. for best results it seems like you still want higher level code around though, run the usual optimisation rules when you decide to specialise some path
14:38:24 <mcstar> hm, i tried to write `instance Monad W where` , for type W a = (a, String), with XTypeSynonymInstances, but it complains: Type synonym `W' should have 1 argument, but has been given none
14:39:18 <bennofs> mcstar: you cannot write instances for type synonyms that aren't fully applied
14:39:20 <Taneb> mcstar, you are doing a Bad Thing(tm)
14:39:48 <mcstar> but if they are fully applied, i cant write a Monad instance
14:39:50 <Taneb> GHC does not know how to expand W to make a real type
14:39:59 <Taneb> Why not (String, a)?
14:40:09 <Taneb> Then you can, with instance Monad ((,) String) where...
14:40:51 <mcstar> i dont understand, what is that extension good for then?
14:40:59 <eacameron> is there a point-free way to write this? withTransaction_ c f = void $ withTransaction c f
14:41:16 <bennofs> echo-area: fmap void . withTranscation
14:41:20 <bennofs> eacameron: ^
14:41:38 <quchen> Is there a point in making this point-free?
14:41:47 <bennofs> eacameron: or if you prefer, only do one step: withTransaction_ c = void . withTransaction
14:41:48 <mcstar> Taneb: also, it is from koen claessen's paper
14:42:00 <Taneb> :(
14:42:06 <eacameron> quchen: curiosity
14:42:06 <bennofs> oops, I forgot a c there, it's withTransaction_ c = void . withTransaction c
14:42:30 <quchen> eacameron: In that case, query lambdabot and type "@pl \c f -> void (withTransaction c f)".
14:42:34 <Taneb> mcstar, the extension is good for if you have really long but common types, iirc Yesod uses it sometimes
14:42:39 <bennofs> eacameron: you can also write (void .) . withTransaction, though I think that's pretty ugly
14:42:45 <Axman6> @pl withTransaction_ c f = void $ withTransaction c f
14:42:45 <lambdabot> withTransaction_ = (void .) . withTransaction
14:43:04 <jonplussed> I might be reading this wrong, but does this ticket indicate that there should be a :complete function in GHCi? https://ghc.haskell.org/trac/ghc/ticket/5687
14:43:06 <mcstar> Taneb: i would just use `data W a = W a String` here
14:43:08 <quchen> eacameron: Any function can be made pointfree. Most functions don't become easier to read in the process.
14:43:15 <eacameron> bennofs: quchen: I'll have to work through those options in my head
14:43:25 <jonplussed> pardon, command not function
14:43:37 <Taneb> mcstar, you do know that Writer is a thing that exists?
14:43:43 <mcstar> yes
14:43:57 <eacameron> quchen: cool lambdabot feature, where is that documented?
14:44:05 <mcstar> i havent used it though, only saw some code that demonstrated it
14:44:27 <mcstar> irrelevant, the paper is on concurrency
14:44:45 <quchen> eacameron: I only know it from hearsay in this channel. There's probably some package providing the functionality as well, and that's what Lambdabot uses as a plugin.
14:45:36 <Fuuzetsu> jonplussed: I thought there was one already (in HEAD)
14:45:42 <mcstar> @hoogle pointfree
14:45:43 <lambdabot> package pointfree
14:45:45 <edwardk_> danilo2: uu-parsinglib shows off a neat way to do parsing. trifecta focuses on user experience. e.g. syntax highlighting, nicer error messages, etc. uu-parsinglib's notion of error recovery tends to give some pretty _weird_ error messages.
14:46:12 <Fuuzetsu> I just checked and it exists already.
14:46:47 <jonplussed> Fuuzetsu: Huh; I'm using haskell-platform (with GHCi version 7.6.3) and I don't see it; says version 7.2.1 in ticket
14:47:09 <jonplussed> Fuuzetsu: is that different from the GHCi version, though?
14:47:18 <ocharles> I still can't decide how I feel about error recovery
14:47:42 <ocharles> if I type x + + y, I don't want my calculator to go ahead and work out x + 0 + y or something
14:47:52 <skypers> oh
14:48:00 <skypers> very interesting
14:48:08 <ocharles> the last time I used uu-parsinglib, I can't remember if it had an option to even fail
14:48:08 <fryguybob> jonplussed: Head is 7.8 (or 7.7) and isn't released yet.
14:48:10 <skypers> I have a data with only one single ctor
14:48:18 <skypers> I do a pattern matching on it
14:48:23 <skypers> if I put _ in the pattern list
14:48:34 <skypers> I get an overlapping pattern matching warning
14:48:38 <skypers> is it sane?
14:48:53 <skypers> I mean, the _ prevent me for forgetting any later added ctor
14:49:00 <danilo2> edwardk_: Hmm, ok, thank you for this info. I understand, that trifecta does not provide any error recovery? By the way - I have seen a presentation about trifecta and there was a lot of talk about online parsing and using it by "syntax highliting" or "tab completion" - does trifecta provide more functionality than uu in this field?
14:49:03 <skypers> hm I guess it’s actually a bad idea
14:49:13 <skypers> it would discard them
14:49:16 <skypers> nevermind then :)
14:49:18 <quchen> fryguybob: Head is 7.7.xxx, 7.8 is a stable release.
14:49:22 <skypers> quite logical warning
14:49:34 <jonplussed> fryguybob: thanks; I want to add it to hdevtools (and subsequently Vim) but I'll probably wait till 7.8
14:49:45 * hackagebot foldl 1.0.1 - Composable, streaming, and efficient left folds  http://hackage.haskell.org/package/foldl-1.0.1 (GabrielGonzalez)
14:49:46 <thoughtpolice> jonplussed: that 7.2.1 refers to the version the bug was filed against, not what version it was fixed in
14:49:46 <edwardk_> danilo2: the old trifecta talk was about something almost completely unrelated. trifecta itself is basically parsec with nicer error messages and support for monad transfomers
14:49:47 * hackagebot treeviz 0.0.4 - Visualization of computation decomposition trees.  http://hackage.haskell.org/package/treeviz-0.0.4 (DavidBanas)
14:49:54 <Cale> ocharles: Consider the case of providing information about types and syntactic classes of things as you edit a file. It would be nice if even though you had some incomplete definition in the middle of your file, the parser could collect from it a bunch of declarations which *do* still make sense, and typecheck them.
14:50:01 <quchen> Oh, Austin is here! Answer SPJ's email! :-D
14:50:05 <fryguybob> quchen: Yeah, I'm just saying that features in "Head" are ones that will appear in 7.8
14:50:07 <danilo2> ocharles: If you write "x + + y" then it would delete on "+" and would parse "x + y". This is cool, because you can still tell user that there i a bug, but you can further parse text and search for other bugs
14:50:20 <mcstar> so far i imagined lifting as pushing upwards, but in fact, it is closer from pulling up from below
14:50:26 <jonplussed> thoughtpolice: thanks!
14:50:26 <thoughtpolice> quchen: yes, i will, i'm still combing through my email after sickness/christmas/other stuff
14:50:28 <edwardk_> danilo2: re syntax highlighting the default parser captures a semantically tagged interval map of highlights you can do with what you will.
14:50:32 <mcstar> closer to *
14:50:35 <yggr> "warpEnv: no PORT environment variable found" -> any advice?
14:50:41 <edwardk_> danilo2: with some work you can turn that into a syntax highlighter
14:50:42 <danilo2> edwardk_: Oh, nice to know, thank you!
14:50:54 <Cale> quchen: Which email are you talking about? :)
14:51:02 <thoughtpolice> jonplussed: but anyway, yes, :complete will be in 7.8.1. also, you can use ghci-ng, which is a backwards-compatible version of GHCi, with forward-ported features
14:51:06 <thoughtpolice> @hackage ghci-ng
14:51:06 <lambdabot> http://hackage.haskell.org/package/ghci-ng
14:51:07 <edwardk_> completion tagging is something i've had working before with it, but isn't in the man parser type
14:51:16 <edwardk_> it was done with a parser-transformer
14:51:23 <skypers> omg edwardk_
14:51:27 <quchen> Cale: "RE: whats our timeline for 7.8 release?" from today
14:51:29 <mcstar> yggr: maybe the config doesnt provide a port, and tries to read it from a shell var
14:51:32 <skypers> I’ve fallen in luv with bifunctors!
14:51:35 <jonplussed> thoughtpolice: oooo schnap! thanks; installing now
14:51:37 <skypers> I use them everywhere now!
14:51:40 <skypers> especially when parsing
14:51:42 <thoughtpolice> jonplussed: ghci-ng 7.6.3.4 supports :complete (backported) but is otherwise compatible with 7.6.3
14:51:50 <edwardk_> danilo2: working up a verson of it in javascrpt right now, so i may backport it to haskell
14:51:51 <skypers> combining bimap and break is SO great :D
14:51:52 <edwardk_> skypers: heh
14:51:53 <thoughtpolice> hvr maintains it (and i think ghci-ng is a good idea)
14:51:57 <edwardk_> break?
14:51:59 <yggr> mcstar: thank you :D
14:52:02 <danilo2> edwardk_: I do not why, but I'm little in love with uu-parsinglib (probably because of its error recovery) - it has some downsides though - I was fighting with custom state in uu-parsinglib and I loose :( I was able to patch BasicInstances.hs file, add custom field to Str datatype, write "get" but not "put" method
14:52:07 <mm_bureau> there is an example of the ultimate in error recovery…  it's about as good as you can get…  shannon would probably have proved that it's optimal error recovery
14:52:10 <mm_bureau> it's called PHP
14:52:14 <skypers> span, break, partition
14:52:14 <skypers> yes
14:52:19 <edwardk_> skypers: ah
14:52:32 <mm_bureau> ocharles: in ~2h i'm happy to =)
14:52:51 <skypers> thanks to that, I do “parsing for free” :)
14:53:16 <skypers> (I know I should use parsec, but hm, 30 lines to load a quite nice format, I don’t need parsec do I?)
14:53:19 <edwardk_> danilo2: personally i find the corrections it offers are never the right ones, but YMMV.
14:54:15 <bennofs> How can I set a value at a given index in repa?
14:54:46 * hackagebot separated 0.0.2 - A data type with elements separated by values  http://hackage.haskell.org/package/separated-0.0.2 (TonyMorris)
14:56:26 <danilo2> edwardk_: Hmm so from all the libraries available, you prefertrifecta the most?
14:56:37 <simpson> danilo2: Well, he wrote it, so... :3
14:56:44 <danilo2> edwardk_: By the way - there is not a lot of people knowing uu-parsinglib and you seems to know it well (you've send me a paper about it couple months ago and because of you I learned it - thank you! :) ), if you have a sec, please look here: http://stackoverflow.com/questions/20846429/performance-of-uu-parsinglib-comparet-to-try-in-parsec/20848152?noredirect=1#20848152
14:56:46 <edwardk_> i confess to being a bit biased
14:57:24 <boom583> This: https://pastee.org/fqu2v
14:57:24 <boom583> You see how acc is returned there to move on to the next element in the list
14:57:24 <simpson> edwardk_: BTW, if you're in the parsing mood, Text.Parsers.Expression doesn't parse chained postfix expressions, and doesn't document it, although the lack of chained prefixes is documented. Is this intentional or an oversight?
14:57:44 <edwardk_> simpson: patch! =)
14:57:47 <boom583> My question is: Is it common to return some manipulation of "acc"? Or if is usually only "acc" returned?
14:58:42 <monochrom> boom583, it is common to do whatever is appropriate for the task.
14:58:53 <edwardk_> simpson: there was a bit of a kerfuffle over Text.Parsers.Expression in the issues lately. Check to see if it was a consequence of the happenings there. Otherwise I have no real objection to multiple postfix operators
14:59:02 <danilo2> edwardk_: ahh you are ekmett! Ok, now I can connect the facts :) Thats very nice, because I wanted to ask you about Trifecta - is it still under development? I was looking at the commit history and open bugs - some are open for over 7 months and there is not many new commits to it - I was a little afraid of it
14:59:09 <monochrom> it is uncommon to expect one rule of thumb that solves all problems. well, perhaps it is common among some people.
14:59:31 <boom583> yes, but let me rephrase: Have you come across code where you return some manipulation of "acc"? Say "[0,acc] !! 1" or whatever the hell. Something other than pure "acc"
14:59:31 <edwardk_> danilo2: it is stll in development, it has just moved mostly to the back burner. The fixes for it have mostly been in parsers
14:59:45 <boom583> (i can't think of any examples)
14:59:49 <edwardk_> danilo2: because most of the combinators have moved there. (parsers, the package)
14:59:49 <boom583> but i wanna know if it's done
15:00:09 <boom583> in practice
15:00:19 <monochrom> foldr (\x acc -> x + acc) returns some manipulation of acc.
15:00:20 <simpson> edwardk_: 'k, awesome. I know that for some grammars (gee, *thanks* Haskell) it can't be done, but for Python, E, C, etc. it's fine.
15:00:25 <edwardk_> danilo2: we're building a compiler with it here, so it is definitely getting use
15:00:31 <boom583> oh shit
15:00:32 <boom583> lol
15:00:48 <monochrom> in fact, "if x == y then True else acc" can be called a manipulation of acc, too.
15:00:56 <boom583> LOL
15:00:56 <boom583> yeah
15:00:57 <danilo2> edwardk_: "it has just moved mostly to the back burner" - excause me, what is "back burner" in this mean ?
15:00:58 <boom583> my bad!
15:01:01 <edwardk_> simpson: there is little reason why haskell couldn't have true prefix/postfix operators, we do them in ermine with a shunting yard
15:01:39 <ocharles> mm_bureau: it's a date!
15:01:44 <simpson> edwardk_: TBH I am super-comfortable with just doing the Python formalism of nested precedence of parsers; I just thought that T.P.Expression was really really cool.
15:02:02 <edwardk_> danilo2: i mean that we're fixing it as we go, but i haven't been rushing off to rebuiild it
15:02:15 <ocharles> Cale: sure, not saying correction doesn't make sense - but I'm not entirely sure I've wanted it for what I'm doing
15:02:21 <ocharles> which is IO depending on what a user types in
15:02:24 <edwardk_> danilo2: there is a branch that is trying to convert the whole thing to use Text, which is the biggest "new" development arc
15:02:39 <ocharles> I don't want "Don fire the missles" corrected to "Fire the missles" (:
15:02:44 <edwardk_> simpson: i ned to add a shunting yard
15:03:19 <monochrom> "dont fire the missiles" is corrected to "dons fires the missiles" :)
15:03:24 <boom583> monochrom: thanks bro
15:03:39 <danilo2> edwardk_: ah, ok :) I very like how trifecta uses monad transformers - this is one of the nicest thing about it. So If I've got scratch compiler written in Parsec, would it be safe for me to move over trifecta or shoudl I wait for some "big updates" ? :)
15:03:46 <simpson> edwardk_: T.P.Train? :3
15:03:59 <joehillen> How do I get cabal sandbox to ignore both user and global packages?
15:04:20 <bennofs> joehillen: I think GHC cannot currently ignore the global DB
15:04:21 <monochrom> it already ignores user packages.
15:04:21 <simpson> Also is there any likelihood of trifecta ever gaining Parsec's token-at-a-time powers? I had to switch to Parsec once I started using Alex...
15:04:34 <edwardk_> danilo2: it isn't changing very fast, you could build off the current design with minimal pain fr future changes. like i said, i have it deployed in production, so it has fossilized somewhat early  for a project of mine
15:04:45 <monochrom> if you get it to ignore global packages, then even ghc itself ceases to work.
15:05:13 <joehillen> ah
15:05:15 <edwardk_> simpson: throw an issue on parsers about it, i've had a couple of people ask
15:05:45 <edwardk_> i'm not sure i want to change it in such a way that we can do token-at-a-time, because t has a ton of knock-on consequences
15:05:55 <Tekmo> Like what?
15:06:00 <edwardk_> and makes the very approachable parsers library far less approachable, and far less haskell 98
15:06:02 <monochrom> it actually upsets me that all sandboxers on hackage ignore user.
15:06:41 <edwardk_> Tekmo: right now all the classes in parsers are 98. there is a couple of lines using existential quantification, and maybe a rank-2 type in there, and that's it
15:06:55 <danilo2> edwardk_: Ok, than you :) Last question (If I could): If I would use trifecta and I would want to parse a file with errors inside (to provide for example syntax coloring) - in uu it's automatically fixable, how would you handle it in trifecta?
15:07:02 <simpson> At least I can still use parsers' combinators with Parsec.
15:07:46 <edwardk_> Tekmo: adding arbitrary token types means that i need to add a way to signal what the delta is for the token, go through a class dictionary, it'll make the speed worse, and the code harder to read.
15:08:20 <joehillen> monochrom: why is that?
15:09:16 <edwardk_> danilo2: have you ever actually gotten the syntax errored file to give you the right correction with uu-parsinglib?
15:10:19 <edwardk_> danilo2: i know that is what they sell it with, I just have never had it pay out on that promise.
15:10:47 <danilo2> edwardk_: Honestly yes (not always, but sometimes it works). Even if it does not - imagine a "Java like syntax" - user writes class, some functions and maes error writing the last one - even if the last definition would be fixed in the wrong way, the AST I get from it would be good and woudl allow me to color the foirst part of class
15:11:12 <edwardk_> danilo2: color me, honestly, impressed.
15:11:16 <monochrom> because I have useful stuff in user
15:11:17 <hattmammerly> hm. what's the latest in web scraping with haskell? I just wanna swipe the title tag from a page, nothing too fancy
15:11:29 <edwardk_> danilo2: i don't have a compelling story for error recovery in trifecta
15:11:39 <edwardk_> its designed to basicaly be 'parsec but better'
15:11:46 <edwardk_> at least for human scale grammars
15:14:33 <edwardk_> in particular i care about the quality of the error message i can give more than about the auto-recovery i can offer, but i can see the appeal
15:15:03 <danilo2> edwardk_: Sorry If I my words sounded offensive - it was not in my mind :) I was just asking - how can we handle such situation in Trifecta / Parsec / any other monadic parser - when we want to colorize code containing errors :)
15:16:03 <danilo2> edwardk_: I see the sense of showing beautifull errors - it is the most important thing in compiler
15:16:26 <edwardk_> this is one case where LALR tends to shine
15:16:29 <danilo2> edwardk_: Hmm, one of the most important, - working compiler is more important :P
15:17:18 <edwardk_> i have some code started for a GLL parser combinator library in Haskell, which could permit me to borrow yacc-like error recovery tools, but it is _very_ much backburnered.
15:17:40 <simpson> Also being able to show *accurate* errors. "Expecting CloseParen" is alright; "Expecting complete statement, final declaration, or expression" is better.
15:17:42 <edwardk_> carter started playing with a form of it about 6 months ago, but i think he got distracted
15:18:30 <danilo2> edwardk_: hmm, interesting :) I did not realize LARL would be good in this field - I've never tried to use it that way
15:18:59 <danilo2> edwardk_: I asked you above about the custom user state in uu - do you have any expirence with it ?
15:19:10 <edwardk_> danilo2: basically what you need is the ability to 'start recognizing a stack' later on once it is clear you have failed and once the reductions are unambiguous again
15:19:32 <xoip> Quick! I'm code golfing, no time to explain! I don't even know a haskell, why is it that when I punch in Control.Monad.replicateM 2 [1,2] in the interpreter it works, but when I load in a module that says the same thing (the only difference being that it's a function yo = Control.Mon....) it gives me "Not in scope: Control.Monad.replicateM"?
15:19:40 <edwardk_> danilo2: my uu experience is a bit dated, and mostly consisted of rewriting the code so i could read it, and working through their tricks
15:20:06 <edwardk_> xoip: import Control.Monad at the top of your file
15:20:08 <simpson> xoip: Gotta import Control.Monad
15:20:17 <simpson> xoip: And at that point, you can refer to replicateM unqualified.
15:20:21 <geekosaur> xolp: ghci, being a desktop calculator type of thing, auto-imports stuff when named. the actual compiler does not, you must import modules explicitly
15:20:30 <xoip> Ah, gotcha. That makes sense.
15:20:33 <danilo2> edwardk_: Thank you very much for this talk :)
15:20:59 <xoip> I was surprised when it worked at all in the interpreter without importing, but then I assumed that worked everywhere :)
15:21:12 <geekosaur> ghci has a lot of convenience stuff that the compiler does not
15:21:28 <geekosaur> (extended defaulting being another example that can cause confusion/surprises)
15:21:44 <Tekmo> That reminds me.  Why do all imports have to be at the top of a file?
15:21:50 <Tekmo> Is there any technical reason for that?
15:21:50 <edwardk_> danilo2: another option is to tokenize and do some kind of manual Burke-Fisher pass after an error and figure out which recovery parses longest
15:22:01 <edwardk_> http://en.wikipedia.org/wiki/Burke%E2%80%93Fisher_error_repair
15:22:20 <geekosaur> I presume just to make the implementation a little simpler
15:22:32 <edwardk_> Tekmo: i think it is mostly a sanity thing
15:22:55 <geekosaur> the compielr already has to do things like hold onto expressions until it has determined the fixities of all operators involved
15:23:13 <geekosaur> I would not want to write a haskell parser...
15:23:28 <edwardk_> Tekmo: it does come with a benefit though in terms of figuring out module dependencies in a simple interpreter you can parse all your modules only up through the imports
15:23:36 <L8D> geekosaur: Isn't there already a module for parsing haskell code?
15:23:40 <edwardk_> Tekmo: without having to understand the full grammar
15:24:04 <geekosaur> L8D: yes, but it's of limited use if you are, for example, designing your own compiler (not that I would be likely to do so)
15:24:17 <edwardk_> Tekmo: otherwise you'd have to be capable of fully parsing the grammar to start doing anything
15:25:01 <danilo2> edwardk_: Thanks! I recognize I have heard about it. After reading the short article on Wikipedia I have impression, that this algorithm has big time complexity (compared to for exaple LALR or uu error recovery process), am I wrong?
15:25:28 <edwardk_> danilo2: its slow, but it is highly general and easily applied
15:25:38 <edwardk_> danilo2: its also only used once something goes wrong ;)
15:26:35 * fryguybob wants a compiler that keeps working on a better error message after showing me the first best guess.
15:26:48 <edwardk_> amusingly i've had some success integrating the parser and a _type checker_ and getting burke-fisher suggestions for how a typo led to a type error ;)
15:27:20 <edwardk_> this is part of what i've been doing with type error slicing
15:28:03 <edwardk_> parse, slice, now you have a narrowed set of tokens to consider, use burke-fisher on that and see if you can find a way to make the type error go away
15:28:07 <danilo2> edwardk_: If you are using it to syntax highliting, you can assume, every keystroke something goes wrong :P
15:28:14 <edwardk_> danilo2: sure
15:28:24 <edwardk_> danilo2: your use case is very different than mine.
15:28:38 <edwardk_> i tend to just try to pick out keywords, balance parens, and call it good in that case
15:28:45 <edwardk_> ;)
15:30:00 <mm_bureau> ocharles: shoot
15:30:14 <mm_bureau> a bit earlier than expected =)
15:31:00 <danilo2> edwardk_: Thank you very much for all the informations :) It clarified a lot to me. I'm going get some sleep, couse I'm sick and I feel like I've been run over by a train ;) Thank you once again!
15:31:36 <edwardk_> sounds good. i'm going to probably check out for the rest of the day and spend time with my wife
15:32:47 <danilo2> oh, and happy new year to everyone! (I'm writing today, because I'll not be avalable here tommorow) :)
15:34:01 <bennofs> only 23:30 hours to go ...
15:34:50 * hackagebot text 1.0.0.1 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-1.0.0.1 (BryanOSullivan)
15:49:53 * hackagebot elm-server 0.10.1 - The Elm language server.  http://hackage.haskell.org/package/elm-server-0.10.1 (EvanCzaplicki)
15:54:03 <simon> http://www.zdnet.com/microsofts-midori-the-m-connection-7000024664/ -- notice how far up JavaScript is listed in the "Safet & Productivity" scale.
15:58:08 <moop> so, do i need to be math genius to use haskell?
15:59:08 <Polarina> moop, not at all.
15:59:26 <ocharles> Only as much as you need to be a math genius to use JavaScript
15:59:28 <ocharles> Or Python
15:59:35 <tautologico> not really... but haskell makes the connection between math and programming more explicit than in most languages
16:01:21 <merijn> moop: I suck at math and I have no problem with haskell
16:01:41 <moop> so what you're saying is... there's still hope
16:01:43 <moop> ok
16:02:26 <tautologico> if you "suck at math" but are good at programming, I'd say you have all you need to be good at math...
16:02:41 <tautologico> math is unfortunately badly taught
16:03:36 <Guest81397> What sort of Math do you find difficult? Would it have an effect on your understanding of haskell?
16:03:50 <moop> tautologico: ha, "good at programming"
16:04:06 <moop> barely managing to do lambdas is not 'good'
16:04:09 <moop> :i
16:04:10 <arvind> hi learning haskell currently
16:04:37 <tautologico> moop: some things take a while to get used to, it's normal
16:05:13 <tautologico> especially abstractions... we're not naturally good at abstract thought, but it can be trained
16:08:53 <DigitalKiwi> moop: do you know any other programming languages?
16:10:04 <moop> DigitalKiwi: i know c# a bit
16:11:05 <moop> actually decided to try haskell because i fell in love with linq
16:11:25 <augur> moop: lambdas are easy, let me teach you!
16:11:40 <moop> augur: no need, i was a bit joking
16:11:47 <moop> :D
16:12:08 <moop> also it's a bit late
16:16:13 <zRecursive> why late ?
16:18:13 <moop> like, 2am
16:18:26 <zRecursive> haha
16:18:32 <zRecursive> night
16:18:32 <augur> moop: aww darn
16:18:36 <augur> i love teaching people LC
16:18:45 <moop> LC?
16:18:50 <moop> expand pls
16:18:52 <moop> for me
16:18:58 <nstdloop> lambda calculus, right?
16:19:10 <moop> that makes sense
16:19:11 <zRecursive> Late Course ?
16:19:27 <moop> libcaca
16:19:44 <pavonia> Gah, pixel graphics in cairo are a pain. Aren't there libraries for gtk2hs to draw graphics based on pixel coordinates?
16:22:23 <moop> anyways
16:22:25 <moop> good night
16:22:36 <arvind> i need to relearn haskell basically i left since it was very very  scary  to me :/
16:22:41 <moop> we'll talk about learning stuff... in about 8~ish hours
16:22:56 <hpc> that's it everyone, #haskell is closed
16:23:01 <hpc> go home people!
16:23:15 <zRecursive> good morning
16:23:25 <hpc> nope, it's good night now
16:23:40 <hpc> ;)
16:23:41 <zRecursive> East is morning
16:23:44 <moop> exactly
16:23:49 <moop> no talky until i get back
16:36:58 <quchen> Does currying have an effect on whether GHC rules are applied? For example, does `forall f (g x) y = f x y` get applied in `f (g 2)`?
16:37:14 <quchen> s/forall/forall f g x y/
16:37:17 <quchen> .
16:37:28 <shachaf> I imagine the answer to the second question is "no".
16:37:52 <shachaf> And also I'd say it doesn't have much to do with currying, but maybe that's just me.
16:37:56 <L8D> How can you import a module and exclude certains parts?
16:38:08 <hpc> import Foo hiding (bar, baz)
16:38:15 <L8D> hpc: thanks
16:38:16 <Polarina> L8D, import Module hiding (evilfunction, EvilData)
16:38:17 <shachaf> @google haskell import
16:38:18 <lambdabot> http://www.haskell.org/haskellwiki/Import
16:38:18 <lambdabot> Title: Import - HaskellWiki
16:38:21 <benmachine> GHC does have a notion of arity of functions, so to the optimiser there can be a difference in how many arguments you specify
16:38:22 <shachaf> L8D: That has a full list.
16:38:34 <benmachine> but I don't know the details
16:38:47 <hpc> L8D: important to note, for data structures you likely want to do hiding (Bool(..)) or similar
16:38:59 <hpc> if you hide just Bool (the type), you still get True/False
16:39:18 <shachaf> I know some of the details. But I'd guess that they aren't even critically important here.
16:39:20 <L8D> interesting
16:39:25 <hpc> a certain acme package uses this feature to hilarious effect
16:39:33 <quchen> shachaf: The reason I brought up currying in particular was because of its effects on inlining, and thought maybe there is some connection.
16:39:39 <L8D> But I’m only using it to import prelude without putStr and putStrLn
16:40:10 <quchen> The broader question would be "how are rules applied", aiming at a non-"read the GHC source" answer. :-)
16:40:26 <shachaf> But this is just application of a thing to an argument. :-(
16:40:50 <shachaf> Anyway, what happened when you tried it out?
16:41:03 <shachaf> -ddump-rule-rewrites, -ddump-rule-firings, etc. might help.
16:41:34 <L8D> > f (id x) where f (g x) = g
16:41:36 <lambdabot>  <hint>:1:10: parse error on input `where'
16:41:49 <L8D> > let f (g x) = g in f (id x)
16:41:50 <lambdabot>  <hint>:1:8: Parse error in pattern: g
16:41:57 <L8D> :(
16:45:15 <yyyyy> is there some automated way to do wrapping and unwrapping of newtypes so I can have access to the originating type functions?
16:45:48 <quchen> Type functions? That doesn't sound like what newtype is useful for.
16:46:02 <bergmark> yyyyy: check the newtype package
16:46:49 <yyyyy> quchen: sorry, ambiguous precedence :p. it should read as (originating type) functions
16:46:58 <yyyyy> bergmark: thanks, will do so.
16:47:37 <Tekmo> Also, `lens` can do this to a degree, if you treat the wrapping/unwrapping pair as an `Iso`
16:47:46 <Tekmo> w
16:49:25 <yyyyy> Tekmo: i'm still getting my feet wet with lens. while basic usage is ok, i feel like i need to understand the derivations more throughly before using it to a larger extent. maybe that's one such opportunity.
16:50:44 <maxiepoo> so any suggestions for libraries that use lens extensively in their API? I keep hearing how awesome lenses are but I've never really seen them in action
16:51:35 <hpc> maxiepoo: the way type classes work, it's a lot more like lens extending the API of many other data types
16:51:56 <d-snp> hi, if I want to read bytes from a socket, and write them to a hard disk, what's the best intermediate data type I could use?
16:52:10 <hpc> d-snp: bytestring, probably
16:52:20 <d-snp> I want to avoid allocating to memory as much as possible
16:52:30 <Tekmo> d-snp: You can use `pipes` or `conduit` to do this
16:52:36 <Tekmo> d-snp: I can give you the `pipes` example code
16:52:50 <d-snp> pipes sounds like it's what I need
16:52:54 <udevd> @type succ
16:52:55 <lambdabot> Enum a => a -> a
16:52:55 <d-snp> please do :)
16:54:26 <maxiepoo> hpc: so a library doesn't really need to be lensy in order for you to use lens with it?
16:54:47 <d-snp> I found this: http://www.haskell.org/haskellwiki/Library/Streams , is this something that people use generally?
16:54:48 <hpc> nope; lens defines instances for a lot of data types, like tuples and lists
16:55:19 <hpc> stuff that lens misses might have a dependency on lens and provide their own instances
16:55:33 <hpc> or have a side package like "foo-lens" that does
16:56:12 <hpc> you should start by just importing the lens modules and see what works and what doesn't
16:56:43 <hpc> and then take a quick look through the class definitions in docs, which will list instances
16:57:00 <Tekmo> d-snp: http://lpaste.net/97763
16:57:02 <hpc> though as an edwardk package that may or may not be informative ;)
16:57:18 <Tekmo> d-snp: that uses the `pipes-network` library to read from the socket and `pipes-bytestring` to write to disk
16:57:43 <d-snp> thanks! I'll read into it :)
16:57:57 <Tekmo> The key thing to read is the `pipes` tutorial
16:58:02 <hpc> d-snp: in any event, allocation is the least of your worries since you have both network IO and disk IO to worry about ;)
16:58:09 <Tekmo> d-snp: This is best starting point: http://hackage.haskell.org/package/pipes-4.0.1/docs/Pipes-Tutorial.html
16:58:23 <maxiepoo> yeah I feel like I'm at a place where I have an idea of what lens is good for but I just haven't really had to deal with super nested data structures or something
16:58:26 <hpc> just so long as it's constant space :P
16:58:41 <hpc> maxiepoo: that's where i am
16:59:05 <Tekmo> Lens really shines when dealing with file formats
16:59:17 <Tekmo> Those tend to attract really complex data types
16:59:27 <hpc> it's hard to find a way to apply it where it doesn't just get more verbose
17:00:31 <sm> hey all, is there an option to have blaze-html add newlines for easier html reading ?
17:01:43 <hpc> sm: probably using a different renderer
17:01:46 <hpc> http://hackage.haskell.org/package/blaze-html-0.6.1.2/docs/Text-Blaze-Html-Renderer-Pretty.html
17:01:54 <hpc> vs i think the default one of .String?
17:02:06 <maxiepoo> Tekmo: like binary formats?
17:02:10 <hpc> there's also .Text and .Utf8 (unsure how that differs from String)
17:02:34 <Tekmo> maxiepoo: I was thinking more of how the format would be modeled internally within the program, regardless of how it is serialized
17:02:44 <Enigmagic> sm: perhaps http://hackage.haskell.org/package/blaze-markup-0.5.1.6/docs/Text-Blaze-Renderer-Pretty.html ?
17:02:59 <Tekmo> maxiepoo: An example of a file format close to my heart that benefits from lens is something like the Protein Data Bank (PDB) file format
17:03:37 <hpc> theoretically that will add indentation as well
17:03:52 <hpc> Tekmo: ooh, make a PNG lens!
17:03:56 <d-snp> looks nice Tekmo, the pipes example
17:04:01 <hpc> or a jpg lens with exif!
17:04:05 <hpc> that'd be awesome
17:04:05 <Tekmo> d-snp: Thanks!
17:04:34 <maxiepoo> interesting
17:04:37 <hpc> (actually don't, jpg is a somewhat hellish format full of offsets and cosine transforms)
17:04:37 <d-snp> I'll go experiment with it tomorrow, it's quite important that it uses as little memory as possible
17:04:51 <Tekmo> d-snp: The 4096 number is the chunk size
17:04:57 <sm> hpc, Enigmagic ah you're right. Thanks!
17:04:59 <Tekmo> d-snp: Just change it to the amount of memory you want your program to use
17:05:07 <d-snp> my code has two modes, when there's memory available, it reads into memory greedily, so it can directly stream it on
17:05:14 <Tekmo> d-snp: It won't load more than a single chunk into memory
17:05:16 <d-snp> when its out of memory, it needs to stream directly to disk
17:05:38 <d-snp> the whole app is basically a file backed pipe
17:05:41 <hpc> sm: a nice fallback plan is also to use browser consoles; they usually have a way of showing the document as a node tree and you can copy it as formatted html
17:05:51 <hpc> though i haven't tried that out myself
17:06:21 <sm> hpc: I've just been trying firebug's open in editor.. it preserves the original source formatting
17:06:22 <hpc> d-snp: you expect it to OOM often?
17:06:38 <Tekmo> d-snp: Is the purpose of the backing file just to drain the input as rapidly as possible?
17:07:02 <hpc> sm: try it in the native one? i find firebug is rather pointless since firefox 10 or so
17:07:45 <sm> hm, I found the new inspector much too limited in general. But I'll check again
17:08:49 <hpc> (disclosure: i haven't tried firebug since i found out around 3.0 that it had a catastrophic memory leak)
17:10:29 <FireFly> I like the built-in one personally
17:10:53 <Enigmagic> sm: in chrome's inspector you can use the "{}" button in a source view to reformat everything..
17:11:17 <hpc> i like how quickly accessible right-click-q is
17:11:23 <hpc> as a shortcut for "inspect element"
17:11:25 <sm> I really want to get it into emacs so I can experiment with layout
17:11:57 <hpc> i think emacs can auto-format it
17:12:09 <hpc> hell if i know the shortcut though
17:14:27 <sm> hpc: M-x tidy-buffer from the tidy package seems to be the way, but only if the markup is valid
17:14:30 <yyyyy> bergmark: thanks for the newtype package tip again. that saved me many hours of keystrokes and was a fairly easy addition to the codebase.
17:14:39 <hattmammerly> so I've got this function here: http://bpaste.net/show/163247/ which gets the title of a web page. this would be more useful if it returned a string, but I'm not sure how to rework it to do that. any tips on accomplishing that, or otherwise improving what I'm sure is an awful function?
17:15:05 * hackagebot herringbone 0.0.1 - A library for compiling and serving static web assets.  http://hackage.haskell.org/package/herringbone-0.0.1 (hdgarrood)
17:15:10 <hattmammerly> the nested lets are probably a huge no-no aren't they
17:15:20 <sm> I'll figure out how to invoke the right blaze-html renderer from yesod
17:15:32 <sm> thanks
17:17:16 <Tekmo> hattmammerly: Have you heard of parser combinator libraries like `parsec` or `attoparsec`?
17:17:28 <Tekmo> hattmammerly: They make this much easier
17:18:09 <Tekmo> You'd be able to write something much simpler like:
17:18:44 <Tekmo> title = string "TITLE" <|> string "title" <|> string "Title"
17:18:52 <hattmammerly> Tekmo: parsec was mentioned to me earlier today with a note like "people talk about this when they talk about regexps"
17:19:03 <Tekmo> endTitle = char '/' *> title
17:19:22 <Tekmo> withinTitle = title *> takeWhile (/= '<') <* endTitle
17:19:29 <Tekmo> withinTitle :: Parser String
17:19:38 <Tekmo> It's really slick and easy to use
17:19:41 <hattmammerly> hm, that looks very alien to me heh. but I'll go look into that!
17:19:42 <hpc> hattmammerly: you might also try something that parses the entire html into a data structure
17:19:53 <Tekmo> hattmammerly: The best place to begin is a very readable paper:
17:19:55 <Tekmo> hattmammerly: cs.nott.ac.uk/~gmh/pearl.pdf
17:19:56 <hpc> and then get something like (title . head) or whatever
17:20:06 <Tekmo> hattmammerly: Then study either the `parsec` or `attoparsec` libraries
17:20:21 <hattmammerly> hpc I asked if there were good web crawlers earlier today but got no responses so I just stuck with the libcurl bindings
17:20:31 <quchen> Is there an official offline version of the Cabal user guide?
17:20:49 <quchen> i.e. anything better than cloning the HTML source
17:21:48 <hattmammerly> Tekmo: alrighty, thanks! :)
17:21:58 <Tekmo> hattmammerly: You're welcome! :)
17:23:12 <ocharles> hattmammerly: Learn You a Haskell covers Parsec - be sure to check that out
17:23:32 <ocharles> it's what ultimately made me go "woah, I want to learn this language!"
17:23:46 <ocharles> I think Real World Haskell also covers it
17:23:58 <hattmammerly> ocharles: it did? I have the book here, it's never mentioned heh
17:24:05 <ocharles> i was sure it did
17:24:09 <hattmammerly> RWH definitely does, I'll check out that chapter too
17:24:27 <ocharles> must be RWH
17:24:44 <hattmammerly> thank you!
17:24:54 <ocharles> yea, sorry - got my past wrong :)
17:27:26 <zRecursive> I heard of someone created Perl6 impl. using Parsec. IIRC, it is Pugs ?
17:27:43 <ocharles> yea, I think so
17:28:10 <zRecursive> then Parsec should be very practical
17:28:42 <hpc> parsec is webscale
17:28:51 <maxiepoo> nah
17:28:56 <maxiepoo> attoparsec is webscale
17:28:57 <hpc> it has lr1 and bnf
17:29:17 <Tekmo> attoparsec is basically parsec with better performance, automatic backtracking, and terrible error messages
17:29:27 <ocharles> :)
17:29:47 <hpc> attoparsec uses byte strings, which are low level and prone to segfaults
17:30:02 <Tekmo> Why are byte strings prone to segfaults?
17:30:03 <hpc> parsec is reliable with all of unicode
17:30:10 <Tekmo> Also, attoparsec supports `text`
17:30:18 <hpc> Tekmo: ;)
17:30:19 <zRecursive> Tekmo: i first heard of backtracking in Prolog :)
17:30:32 <Enigmagic> Tekmo: parsec supports Text too
17:30:37 <Tekmo> zRecursive: Yes, you can implement backtracking in Haskell
17:30:50 <Tekmo> zRecursive: The list monad is the simplest example of a backtracking monad
17:31:06 <Tekmo> zRecursive: You can think of a parser as a list monad enriched with the state monad transformer, to a first approximation
17:31:13 <hpc> the list monad is a bad example; it's only backtracking if you squint
17:31:14 * slack1256 needs an 'introduction to logic programming in haskell'
17:31:30 <ocharles> slack1256: the LogicT paper is worth a read
17:31:35 <Tekmo> type Parser input result = StateT input [] result
17:31:44 <hpc> (and even then it doesn't do backtracking particularly well)
17:32:03 <ocharles> Backtracking parsing is much better handled with a breadth-first parser
17:32:34 <ocharles> A list only back tracks well with explicit "back track to here" markers, which is icky
17:32:49 <hpc> also, neither attoparsec or parsec does backtracking
17:32:55 <hpc> they keep a set of matches
17:33:11 <Tekmo> hpc: tomato tomato
17:33:20 <ocharles> mm_freak: back yet? ;)
17:33:37 <hpc> Tekmo: /excuse me/, you mean potato potato
17:33:38 <jmcarthur> hpc: i don't see how it's not true backtracking. i agree that it's not especially sophisticated backtracking.
17:33:40 <zRecursive> ...
17:33:41 <arvind> good morning
17:33:43 <Tekmo> hpc: :)
17:33:56 <Tekmo> arvind: Good morning
17:34:56 <hpc> jmcarthur: the difference between keeping every option and doing backtracking is that there exists an "undo whatever i just did" step in the latter
17:35:08 * hackagebot herringbone 0.0.2 - A library for compiling and serving static web assets.  http://hackage.haskell.org/package/herringbone-0.0.2 (hdgarrood)
17:35:18 <hpc> in my book, at least
17:35:25 <jmcarthur> hpc: [] doesn't count?
17:35:30 <ocharles> i agree, that's why I said you really want to be breadth-first
17:35:34 <Tekmo> hpc: List backtracking does have that.  That's what `(<|>)` does
17:35:40 <ocharles> depth-first with a list just space leaks up the wazoo
17:36:00 <hpc> Tekmo: not really
17:36:22 <hpc> (<|>) isn't "backtrack" so much as "orElse"
17:36:58 <hpc> which... actually ignore me on that
17:37:02 <hpc> but still, you have to squint
17:37:21 <jmcarthur> i still don't see why there's any squinting involved. to me it still looks like (inefficient) backtracking
17:37:47 <ParahSailin> @src [] (<|>)
17:37:48 <lambdabot> (<|>) = (++)
17:38:04 <hpc> jmcarthur: because there's no operation undo :: Parser ()
17:38:09 <hpc> or undo :: Parser a -> Parser a
17:38:09 <jmcarthur> hpc: []
17:38:11 <hpc> or whatever
17:38:22 <Tekmo> hpc: And how would you specify how far to backtrack?
17:38:49 <hpc> jmcarthur: wow i am tired...
17:38:59 * hpc goes to sleep in shame
17:39:23 <hpc> yeah, you're right there
17:40:30 <schlegel> I don't see why backtracking needs some sort of undo
17:40:48 <jmcarthur> schlegel: i would call it failure rather than undo
17:40:56 <jmcarthur> schlegel: just something to trigger backtracking at all
17:41:07 <schlegel> When the structures you're working with are immutable your undo would really just be going back and trying another code path
17:41:15 <jmcarthur> that's right
17:41:37 <schlegel> Yeah
17:41:38 <hpc> yeah, that's the part where my sleepiness made me miss obvious facts ;)
17:41:47 <jmcarthur> another related function:
17:41:50 <jmcarthur> :t guard
17:41:51 <lambdabot> MonadPlus m => Bool -> m ()
17:41:52 <schlegel> Just trying to solidify my understanding
17:41:55 <bitemyapp> lightquake: thanks for hamlet mode!
17:41:59 <schlegel> Or
17:42:01 <schlegel> :t mzero
17:42:02 <lambdabot> MonadPlus m => m a
17:42:08 <jmcarthur> > guard True :: [()]
17:42:09 <lambdabot>  [()]
17:42:13 <jmcarthur> > guard False :: [()]
17:42:14 <lambdabot>  []
17:42:21 <schlegel> > mzero :: [()]
17:42:22 <lambdabot>  []
17:42:29 <jmcarthur> > empty :: []
17:42:30 <lambdabot>  Expecting one more argument to `[]'
17:42:31 <jmcarthur> > empty :: [()]
17:42:32 <lambdabot>  []
17:42:35 <Tekmo> > return :: [()]
17:42:36 <lambdabot>  Couldn't match expected type `[()]' with actual type `a0 -> m0 a0'
17:42:39 <Tekmo> > return () :: [()]
17:42:40 <lambdabot>  [()]
17:43:17 <schlegel> Is there a MonadZero?
17:43:21 <Tekmo> Not any longer
17:43:25 <Tekmo> It got merged into `MonadPlus`
17:43:35 <Tekmo> Basically, the `MonadPlus` is identical to the `Monoid` class
17:43:44 <Tekmo> The only difference is that the type class parameter has a different kind
17:43:49 <jmcarthur> well, plus some laws that nobody agrees on
17:43:51 <Tekmo> Yeah
17:43:52 <schlegel> Do you not have to define mplus?
17:44:01 <Tekmo> Those non-Monoid laws are heresy! :)
17:44:03 <hpc> i much prefer Alternative
17:44:20 <hpc> which is only different from MonadPlus in that it constrains on Applicative instead
17:44:24 <jmcarthur> they justify the type class though
17:44:24 <Tekmo> Right
17:44:27 <hpc> same laws nobody agrees on though
17:44:42 <jmcarthur> hpc: pretty sure the Alternative laws hold due to parametricity already
17:44:48 <jmcarthur> hpc: with just the Monoid laws
17:45:11 <hpc> jmcarthur: wouldn't that mean the MonadPlus definitions just need to be Alternative?
17:45:15 <jmcarthur> hpc: there is no (>>=), so the conflicting sets of laws for MonadPlus don't apply
17:45:32 <roconnor> jmcarthur: really?
17:45:39 <jmcarthur> roconnor: not really, as i am not certain
17:45:51 <jmcarthur> roconnor: i said "pretty sure" when i meant "somewhat sure"
17:45:58 <roconnor> interesting
17:46:39 <jmcarthur> it may be that i didn't state that property precisely and you may have a different interpretation of what i said, too
17:46:48 * jmcarthur pulls up the monadplus laws for reference...
17:47:06 <schlegel> So what about monads like Maybe that have an mzero but no mplus
17:47:20 <schlegel> Do you just use MonadPlus and not define mplus?
17:47:40 <roconnor> @src Maybe mplus
17:47:41 <lambdabot> Nothing `mplus` ys = ys
17:47:41 <lambdabot> xs      `mplus` ys = xs
17:48:00 <jmcarthur> empty *> a = empty; a *> empty = empty   -- i think these are the laws i mean
17:48:06 <roconnor> @src First mappend
17:48:06 <lambdabot> Source not found. Take a stress pill and think things over.
17:48:12 <roconnor> boo
17:50:38 <schlegel> Yeah that makes sense
17:51:10 <ocharles> mm_freak / mm_bureau : ok, gotta sleep - we'll try and catch up another time
17:51:30 * ocharles closes the laptop
17:58:20 <zett_zelett> Can someoone give me a hint how to reate category-theory-monads to haskell-monads?
18:00:08 <zett_zelett> Shouldn’t there be some function m (m a) -> m a be involved, representing the natural transformation M² ⇒ M?
18:00:22 <Cale> :t join
18:00:22 <lambdabot> Monad m => m (m a) -> m a
18:01:01 <Cale> zett_zelett: Does that help? :)
18:01:17 <Cale> zett_zelett: Assuming that you have fmap, join and (>>=) are interchangeable
18:01:26 <Cale> x >>= f = join (fmap f x)
18:01:37 <mauke> @src join
18:01:37 <lambdabot> join x =  x >>= id
18:01:49 <schlegel> @hoogle Monad m => m a -> m (a -> b) -> m (m b)
18:01:50 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
18:01:50 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
18:01:50 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
18:02:13 <schlegel> derp
18:02:18 <mauke> :t return .: flip ap
18:02:18 <lambdabot> (Monad m, Monad m1) => m1 a -> m1 (a -> b) -> m (m1 b)
18:02:28 <schlegel> @hoogle Monad m => m a -> (a -> m b) -> m (m b)
18:02:28 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
18:02:28 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
18:02:28 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
18:02:55 <mauke> what's the additional m for?
18:03:07 <schlegel> return could be in a different monad
18:03:47 <shachaf> But m is the same as m.
18:04:36 <schlegel> I was looking to see if there was a monad fmap in prelude for those monads that forgot their functor instance
18:04:44 <schlegel> THought mauke was referring to the m vs m1
18:04:53 <mauke> monad fmap is liftM
18:05:26 <schlegel> Oh wait duh
18:05:57 <schlegel> Monad m => m a -> (a -> m b) -> m (m b) is the same as Monad m => m a -> (a -> c) -> m c where c = m b
18:06:26 <zRecursive> :t join
18:06:27 <lambdabot> Monad m => m (m a) -> m a
18:07:11 <zett_zelett> Yeah, that does help.
18:07:15 <zett_zelett> Thanks!
18:40:29 <angelicous> Hi there
18:40:58 <Cale> Hello
18:41:25 <angelicous> i need help with the function nubBy, can someone here give me a hand?
18:41:51 <Cale> sure!
18:41:57 <Polarina> Why is it that unsafe FFI calls block all threads, even with -threaded?
18:42:13 <angelicous> thanks cale, so here is my problem
18:42:23 <Cale> Polarina: I think they block the capability that they're running on
18:42:41 <Cale> Polarina: but not necessarily *all* threads, the ones running on another capability should still run
18:42:44 <ion> angelicous: On the Internet, it’s best to just ask one’s question.
18:42:56 <Polarina> Cale, ah, ok. That makes a lot more sense.
18:43:02 <augur> https://proofmarket.org/
18:43:31 <augur> just in case anyone wants a justification for learning some dependently typed proof assistants beyond just their awesomeity
18:43:38 <Cale> augur: Now make one for dogecoins
18:43:49 <augur> Cale: i was going to suggest that to peaker for lamdu
18:44:21 <angelicous> i have a list [  (A,(1,1)), (B,(2,2)), (C,(1,1)), (D,(1,1)), (A,(1,1)),  (A,(2,2)),(A,(3,3)),]  i want to filter all the elements that repeat themselvs on the coordinates.
18:44:59 <bitemyapp> don't use Typeable or the puppy gets it: http://i.imgur.com/2LETKG9.jpg
18:45:41 <Cale> > nubBy ((==) `on` snd) [('A',(1,1)), ('B',(2,2)), ('C',(1,1)), ('D',(1,1)), ('A',(1,1)), ('A',(2,2)), ('A',(3,3))]
18:45:42 <lambdabot>  [('A',(1,1)),('B',(2,2)),('A',(3,3))]
18:45:58 <Cale> Or equivalently:
18:46:10 <angelicous> Cale, ok what if there where a char between it?
18:46:18 <Cale> > nubBy (\(_,x) (_,y) -> x == y) [('A',(1,1)), ('B',(2,2)), ('C',(1,1)), ('D',(1,1)), ('A',(1,1)), ('A',(2,2)), ('A',(3,3))]
18:46:19 <lambdabot>  [('A',(1,1)),('B',(2,2)),('A',(3,3))]
18:46:32 <Cale> Sorry?
18:46:47 <Cale> (I don't understand the question)
18:47:03 <angelicous> if they where like (A,B,(1,1)) instead
18:47:34 <Cale> Then you'd use a comparison like (\(_,_,x) (_,_,y) -> x == y)
18:50:37 <angelicous> ok cale thank you very much. I have another question, can you open a pvt window?
18:50:57 <tomberek_> is there a haddock/haskell style guide somewhere? I'd like to create some documentation, but stick to standard Haskell documentation practice
18:51:33 <Cale> angelicous: It's perfectly okay to ask questions here, that's what this channel is for :)
18:52:02 <angelicous> it's kind of complex but ill try to explain here :P
18:52:03 <Cale> tomberek_: http://lambda.haskell.org/platform/doc/current/ghc-doc/haddock/index.html
18:52:21 <tomberek_> Cale: sweet
18:52:38 <Cale> angelicous: If you need to put your code and/or an error message up, you can use lpaste.net
18:53:13 <angelicous> ok ill put it in there and past it here :) just a sec
18:53:50 <tomberek_> Cale: oh, i already had that... i that is more about the syntax of the documentation, not about what sort of information is standard and where.
18:55:07 <Cale> tomberek_: Say what the top level definitions in your module do? :)
18:55:53 <Cale> http://hackage.haskell.org/package/containers-0.5.3.1/docs/Data-Map-Lazy.html is a decent example of documentation
18:57:05 <tomberek_> i'll work it
18:57:49 <Cale> If you can provide some information about the time or space complexity of operations, that's always good, but by no means entirely standard.
18:58:12 <Cale> Examples and/or algebraic laws that your definitions satisfy are also nice to have
18:58:29 <tomberek_> roger
19:09:26 <speckle> hey, how many people here actually understand how this isqrt function works at the bottom of this page? -> http://www.haskell.org/haskellwiki/Generic_number_type#squareRoot
19:10:23 <speckle> I am learning Haskell, and trying to read it is making my head explode, heh
19:11:02 <simon> speckle, it's a fixed-point iteration. you could understand Newton's formula and how it's used independently of Haskell syntax.
19:11:13 <speckle> ah, thanks, I'll look at it from that perspective :)
19:11:40 <simon> http://en.wikipedia.org/wiki/Newton's_method#Square_root_of_a_number
19:12:04 <speckle> yeah, that is simple. it's the program itself that is confusing - being new to Haskell, it looks harder to understand than an IOCCC program
19:12:05 <Cale> That does seem a little more complicated than such a thing usually ought to be.
19:12:29 <Cale> I don't understand the point of defining this (^!)
19:12:40 <Cale> (Just to specialise the type to Int? Why?)
19:13:09 <speckle> it's an integer square root function, as opposed to a floating point square root
19:13:19 <Cale> Well, sure.
19:13:30 <Cale> But look, they defined x ^! n = x ^ n
19:13:45 <speckle> wasn't me! I did not edit that in! I swear!
19:13:57 <Cale> heh
19:14:34 <speckle> looking at the edit history, it looks quite old, actually
19:14:47 <speckle> nobody has touched the article in years, so maybe Haskell has better features now?
19:16:12 <Cale> It's not that Haskell has better features, it's that the person who wrote this was a little bit strange, I think :)
19:16:17 <shachaf> Well, it was added by Henning.
19:16:23 <Cale> Oh, lol
19:16:31 <shachaf> I wouldn't be too surprised that he'd use strange names for things.
19:17:21 <mgsloan> Afterall, you just need to import then qualified
19:17:33 <Cale> Well, in that case, the strangeness of the author in question is unquestionable. This is a guy who names all of his types T.
19:21:14 <simon> sounds like something an ML'er would do.
19:21:58 <Axman6> Cale: what's wrong with that? It accurately reflects that all types are types
19:22:25 <Axman6> just in case you try to use a type where a value (named v) was supposed to be used, it'll be obvious!
19:22:37 <Cale> Axman6: hehe
19:23:40 <Axman6> map :: (t -> t') -> [t] -> [t']; map v v' = case v' of (v'':v''') -> v v'' : map v v'''
19:23:59 <Axman6> miranda had a type system somewhat like that right?
19:24:16 <mm_bureau> ocharles: i guess you still have the highlighting problem =)
19:25:21 * hackagebot mmorph 1.0.1 - Monad morphisms  http://hackage.haskell.org/package/mmorph-1.0.1 (GabrielGonzalez)
19:26:26 <Cale> Axman6: iirc, Miranda used *, **, ***, etc. for type variables
19:27:11 <rik__> http://lpaste.net/97765
19:27:18 <Cale> map :: (* -> **) -> [*] -> [**]
19:27:25 <rik__> Can someone explain that to me? Where does it pattern match the function parameters?
19:27:33 <roconnor> Tuner deserves a Turing award or something
19:27:36 <Cale> foldr :: (* -> ** -> **) -> ** -> [*] -> **
19:27:57 <roconnor> *Turner
19:28:02 <Cale> rik__: hm?
19:28:17 <Cale> rik__: In the definition of fib?
19:28:33 <Cale> rik__: I'm not sure that I understand your question
19:28:46 <rik__> In the code examples I've been looking at, it's usually like fib x = (operate on x)
19:29:20 <Cale> It's perfectly okay to define a function as being equal to some other function, without mentioning the parameters
19:29:40 <Cale> Here, they're defining the function  memoized_fib  to be equal to the function  (map fib [0..] !!)
19:30:30 <rik__> Cale, sort of like how a macro would be defined in another language then?
19:30:47 <bitemyapp> is HList unsound from a type theoretic point of view?
19:31:13 <bitemyapp> if so, is there some sort of code a blue collar like me could contrive that would break at runtime despite type-checking?
19:31:15 <Cale> rik__: Almost but not entirely unlike that.
19:31:29 <mm_bureau> rik__: the "=" sign in haskell means "equals"
19:31:36 <mm_bureau> if you write f = g, you get f = g
19:31:49 <Cale> bitemyapp: no
19:32:01 <bitemyapp> Cale: then what the fuck is Harper's problem?
19:32:10 <Cale> I don't know, I have no context here
19:32:30 <augur> mm_bureau: = in haskell means "reduces to"
19:32:31 <augur> :P
19:32:51 <shachaf> But you could be nicer about it.
19:32:55 <augur> and only very occassionally does that also happen to mean equals
19:32:57 <bitemyapp> mm_bureau: reduction vs. equality in mathematics.
19:33:19 <bitemyapp> mm_bureau: the notion is that via referential transparency you're subscribing to subtitutability.
19:33:23 <augur> bitemyapp: where do you see harper complaining about HList?
19:33:29 <Cale> rik__: I actually don't like this example. It's relying on GHC to do constant lifting to obtain the memoisation.
19:33:32 <augur> oh man dont bring up referential transparency
19:33:36 <bitemyapp> augur: you were there for the conversation, I'm using elision for humor.
19:33:42 <augur> most people dont know what that is D:
19:33:48 <augur> bitemyapp: i wasnt paying attention
19:33:50 <Cale> rik__: It would be safer to bind the list  map fib [0..]  to some variable
19:33:51 <bitemyapp> substitutability.
19:33:58 <bitemyapp> augur: elision and humor, go with it.
19:34:02 <Cale> rik__: and write something like... (I'll lpaste)
19:34:04 <mm_bureau> i'm not going to join that debate, sorry =P
19:34:10 <rik__> Cale, thank you :p
19:34:20 <bitemyapp> mm_bureau: there's no debate, augur is distracting you.
19:34:32 <mm_bureau> bitemyapp: see, that's the "debate" ;)
19:34:42 <augur> which debate?
19:34:56 <bitemyapp> mm_bureau: see? no debate.
19:34:57 <augur> about what = means in haskell?
19:35:12 <mm_bureau> augur: yeah
19:35:13 <bitemyapp> mm_bureau: everybody here is on board with what everybody else is saying, it's a matter of pedagogical technique.
19:35:50 <augur> mm_bureau: we should have a good discussion of it, because i think it's important to be clear and precise about these things lest we confuse people
19:36:10 <Cale> http://lpaste.net/97765
19:37:43 <mm_bureau> augur: you're right of course, but i'm not sure it helped rik__
19:38:03 <augur> im not sure being wrong helped rik__ either :)
19:38:13 <augur> maybe what would help rik__ is something that is both right, and helpful!
19:39:17 <augur> rik__: so
19:39:29 <mm_bureau> augur: but when you write "f = g" and you say "f equals g", is that wrong?
19:39:37 <augur> mm_bureau: yes
19:39:40 <mm_bureau> why?
19:39:44 <Cale> I disagree, it's not wrong.
19:39:51 <Cale> Well, if you want to be really pedantic, there's more than one way in which = is used in Haskell's syntax. It's used to separate the parts of a pattern binding declaration or a function binding declaration.
19:39:56 * bitemyapp laughs in the background
19:40:10 <bitemyapp> nobody agrees, I take back what I said.
19:40:13 <bitemyapp> mm_bureau: but listen to Cale.
19:40:13 <mm_bureau> Cale: i argue that even then equality is right
19:40:22 <mm_bureau> bitemyapp: i always listen to Cale =)
19:40:44 <augur> rik__: so i think it's important to understand what's going on with these computations
19:41:24 <augur> rik__: when you write something like x = y, this haskell instances this to mean "to compute x, replace it with y"
19:41:24 <Cale> In the case of a pattern binding like f = g, it's pretty much guaranteed that an equality is induced between the left and right hand side of the equation.
19:41:32 <ion> Equality is commutative. “=” in Haskell code is not. OTOH you can replace either side of a definition with the other in code and it’ll mean the same thing.
19:41:38 <augur> rik__: at least for top-level definitions of functions
19:42:12 <Cale> Once you write "f = g" in your Haskell code, then it becomes true that f = g as functions, and that g = f.
19:42:37 <Cale> But it's a fair point that you can't typically write "g = f" and have it mean the same thing.
19:42:38 <augur> rik__: when you see this:   memoized_fib = (map fib [0 ..] !!)   you know you should replace any occurrence of 'memoized_fib' with '(map fib [0 ..] !!)'
19:42:38 <mm_bureau> ion: i'm sure you're referring to symmetry, not commutativity
19:42:49 <Cale> Yeah, symmetry
19:43:14 <augur> rik__: so consider what happens when you apply memoized_fib to a number, say, 5:   memoized_fib 5   ~>   (map fib [0 ..] !!) 5   ~>   map fib [0 ..] !! 5
19:43:46 <Cale> This substitution may get you in trouble ;)
19:44:04 <Cale> (as far as time complexity is concerned)
19:44:08 <mm_bureau> Cale: typically you can't write it as code, but you can write it as a valid statement
19:44:13 <augur> yes yes, we dont care about such things, Cale :p
19:44:23 <augur> pedagogy has no need for efficiency
19:44:26 <Cale> Well, the point of this code is demonstrating memoisation
19:44:35 <augur> Cale: yes but the point of the question was not
19:44:38 <Cale> I rewrote it so as to be a safer and better demonstration of that
19:46:34 <Cale> The thing is, ghc likes to detect constant expressions like this, and locally bind them to variables, and then it pushes those bindings upward until it is blocked by a lambda (it tends not to lift definitions through lambdas, because that leads to space leaks, though I think I may be oversimplifying in saying that)
19:46:58 <augur> yeah yeah sure, that doesn't much help things tho, since you're not introducing an application anywhere
19:47:24 <augur> rik__ seemed to not understand what was going on with memoized_fib being a function, but there not being any pattern matching on the left of it's ='s
19:47:29 <Cale> Well, you're introducing a new constant, which will remain computed as long as it's in scope.
19:47:59 <Cale> If you keep recomputing the list  map fib [0..]  then you'll end up with really bad time complexity
19:48:19 <Cale> The whole idea is to compute each element of that list exactly once as they're needed
19:48:26 <augur> Cale: which .. doesnt change the fact that there is still not pattern matching on the left of the ='s for memoizedFib
19:48:28 <schlegel> Cale: rik__ asks why memoizedFib = fib as opposed to memoizedFib n = fib n
19:48:35 <mm_bureau> Cale: you end up with that anyway by using (!!) for memoization =)
19:48:54 <Cale> Well, yes, I realise that, but I think we've beaten that horse into the ground? :)
19:49:07 <Cale> He's presumably also trying to understand why this code memoises.
19:49:16 <augur> Cale: that depends on whether or not rik__ understands why you dont pattern match
19:49:28 <augur> rik__: do you understand? tell us!
19:49:30 <augur> TELL US NOW
19:49:35 <Cale> :)
19:49:47 <speckle> the thing that bothers me about Haskell is all this behind-the-scenes complexity
19:49:58 <augur> speckle: this behind the scenes complexity doesnt exist
19:50:05 <augur> its all in your head, and in Cale's words
19:50:07 <mm_bureau> come on, let him/her enjoy the debate he/she started =)
19:50:50 <augur> haskell is really simple and easy to understand, you just have to avoid letting details complicate things early on
19:51:05 <speckle> particularly "GHC this" and "GHC that", as if you have to work around GHC's quirks to get things done
19:51:08 <Cale> speckle: Well, understanding the time and space complexity isn't *so* bad, you can approximate what GHC will do by pretending that it does graph reduction, or even just pretending that it does lazy evaluation (i.e. outermost-first evaluation + sharing) by manipulating expressions directly.
19:51:11 <speckle> as opposed to the language itself
19:51:19 <augur> Cale: you're not helping
19:51:20 <Cale> speckle: But there are some quirks
19:51:23 <augur> infact you're making it worse
19:51:30 <Cale> augur: How do you mean?
19:51:44 <augur> Cale: i mean you're proving speckle's point
19:51:54 <augur> you're showing off, and noone's learning anything
19:51:56 <Cale> Well, you can ignore time and space complexity altogether.
19:52:01 <augur> yes, you can
19:52:02 <speckle> I'm learning things  :)
19:52:02 <augur> and you should
19:52:08 <Cale> Not always!
19:52:09 <schlegel> Eh
19:52:14 <schlegel> Not if you want to get things done
19:52:18 <Cale> You eventually need to learn this stuff
19:52:23 <augur> schlegel: fortunately we're not talking about getting things done yet
19:52:38 <schlegel> Who's not?
19:52:45 <augur> i think speckle understands that a good understanding of the compiler can be useful to writing efficient code
19:52:56 <augur> this is true of every programming language
19:53:21 <augur> maybe im misinterpreting speckle, i dont know.
19:53:43 <Cale> I think we've kind of got the easier part of the discussion about the raw meaning of Haskell programs better covered in our tutorials and books than the stuff about how an implementation (either a mock one in your head, or a real interpreter or compiler) would carry things out.
19:53:59 <augur> probably
19:54:04 <mm_bureau> augur: i noticed that you seem to know what people understand and what they don't…  and you seem to know what's helpful to them and what isn't
19:54:05 <speckle> you're right, maybe it's true for any language - Haskell just has its own quirks to deal with, as opposed to what other compilers do
19:54:11 <speckle> I guess it's fine :)
19:54:12 <augur> it just feels like this conversation is an example of premature optimization
19:54:33 <Cale> speckle: Right, you probably didn't intuitively understand how to write efficient imperative programs either.
19:54:58 <augur> mm_bureau: ive seen enough trainwreck conversations in this channel to be very wary of "explanations"
19:55:04 <Cale> I'd say the learning curve is probably pretty similar
19:55:17 <augur> especially explanations where the person with the question says "thats not helping" :P
19:55:25 <mm_bureau> augur: to a point where it has the potential to make you blind
19:55:27 <schlegel> augur: I just wouldn't go as far to say that the complexity doesn't exist, more that it exists in the implementations not in the language itself
19:55:28 <speckle> Cale: to be honest, I still don't - I hear it's all about the SIMD now
19:55:50 <Cale> Well, rik__ hasn't said anything in a while, but other people have joined in, so I'm just proceeding with people who are talking :)
19:55:57 <whatisirc> why does this give me an error when i type it in ghci?  flip' f = g where g x y = f y x
19:56:04 <speckle> schlegel: maybe the language is designed in such a way that it pushes complexity onto the implementation?
19:56:09 <schlegel> and that for most people learning Haskell, they should be concerned with the language first and foremost
19:56:11 <Cale> whatisirc: GHCi mostly wants expressions
19:56:21 <augur> mm_bureau: blindness comes when you're unwilling to assume you might not be helping. since i always assume im not helpful, i'd have to say yo're wrong. :P
19:56:24 <Cale> whatisirc: But it will let you make declarations like that if you prefix them with let
19:56:24 <mm_bureau> augur: it was you who said that it's not helping
19:56:31 <augur> schlegel: complexity exists but theres a time and a place
19:56:32 <angelicous> Cale can you give a quick loon in the pvt window? :P sorry for interrupting
19:56:41 <augur> mm_bureau: yes, but i also am the one who said i might have completely misunderstood speckle
19:56:48 <augur> mm_bureau: so stick that in your pope and smoke it! :P
19:56:59 <whatisirc> oh i see
19:57:00 <whatisirc> thanks Cale
19:57:04 <schlegel> speckle: I feel that's a result of not designing a language that is tied to it's machine architecture
19:57:58 <quchen> Maybe I came in too late, but out of context the last page looks pretty obscure.
19:58:16 <Cale> whatisirc: Usually, it's a good idea to open your editor in a separate window alongside ghci, and whenever you save your file, type :r in ghci to reload the definitions and play around with them.
19:58:17 <augur> we still dont know if rik__ understands :(
19:58:27 <speckle> agreed, schlegel, and I don't think it's that bad. A sufficiently complex program will probably have to be like that anyways, to reach a high level of abstraction.
19:58:53 <Cale> augur: I figure he's gotten distracted by something
19:59:03 <augur> Cale: im sure, hence the ping
19:59:13 <speckle> In a way, it's nicer to have the language and compiler take care of it, rather than making your program more complex than it has to be
19:59:33 <whatisirc> Cale, ok i'll do that
20:00:14 <Cale> whatisirc: Much easier than trying to type all your definitions into the GHCi window, since it's easy enough to accidentally quit GHCi and lose them all.
20:01:09 <speckle> the most confusing part of GHCi is how the syntax differs from putting things in a file
20:01:24 <whatisirc> that's true, i'm just playing around right now so no worries
20:01:29 <speckle> functions need let and don't seem to work across multiple lines
20:01:32 <augur> i just use textmate
20:01:41 <augur> i can run code in TM so its way better than ghci
20:01:47 <Cale> It used to be simpler, but it's gotten more and more complicated as people wanted to be able to make declarations.
20:01:51 <speckle> textmate? okay I'll check it out, thanks
20:01:59 <schlegel> speckle: What OS are you on?
20:02:01 <augur> its a mac text editor
20:02:05 <c_wraith> speckle: think of ghci's syntax as "being inside a do block", except for the ability to declare data, instances, and imports
20:02:22 <speckle> okay, that's a lot better than all these weird corner cases, c_wraith
20:02:26 <speckle> I'm on Xubuntu
20:02:27 <Cale> c_wraith: also, it automatically applies print to things which are showable and not IO
20:02:32 <mm_bureau> augur: i'm not even saying you're wrong, but there are many valid approaches to pedagogy, and you should not shoot someone down because it doesn't match your idea of how people should learn
20:02:47 <Cale> and applies (>>= print) to IO actions with printable results
20:03:03 <c_wraith> Cale: except for IO () results. don't forget that special case
20:03:08 <Cale> right, lo
20:03:09 <Cale> l
20:03:24 <augur> mm_bureau: surely if i think it's failing the person, then i definitely ought to shoot it down...
20:03:25 <schlegel> speckle: Sublime Text is fairly similar to textmate if you're interested.
20:03:37 <schlegel> if you're not a fan of emacs/vim of course
20:03:42 <rik__> Cale, augur was eating guys :p
20:04:30 <mm_bureau> augur: that's not because the teaching approach was wrong, but because it doesn't match your "you have to learn fact by fact, and that's the only true way!" approach
20:04:32 <c_wraith> I'm kind of surprised ghci doesn't have a default Show (a -> b) instance thrown in with all the other special cases
20:05:01 <whatisirc> what's a composition timeline
20:05:02 <speckle> I usually use gedit because it's open source, has basic features, and a fairly standard UI
20:05:14 <whatisirc> in the monad article on the wiki
20:05:30 <Cale> whatisirc: Which monad article are you reading?
20:05:34 <speckle> I'm always ready to switch over to an IDE if my project gets complex enough, but gedit is good for small programs
20:05:38 <whatisirc> Cale, http://www.haskell.org/haskellwiki/Monad
20:05:42 <c_wraith> speckle: did you check to see if anyone wrote a haskell mode for it?
20:05:56 <Tekmo_> Best monad article: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
20:05:58 <mm_bureau> augur: another valid way to learn is:  move from loose approximations over close approximation to precise knowledge
20:06:20 <speckle> I think they did, c_wraith, but I just use it as a plain old text editor
20:06:29 <augur> rik__: i was eating guys?!
20:06:35 <augur> my my
20:06:51 <speckle> I would certainly need something better than gedit when looking at existing large codebases, though
20:07:17 <augur> mm_bureau: i think you're confused about what i was saying, and what i just said
20:07:19 <rik__> punctuation is a bitch
20:07:34 <maxiepoo> how do I compile an executable using cabal with profiling enabled?
20:07:39 <maxiepoo> whoops
20:07:57 <maxiepoo> how do I enable profiling using cabal?
20:08:04 <maxiepoo> This isn't working: `cabal build +RTS -prof -xc`
20:08:20 <maxiepoo> I'm trying to get a stack trace
20:08:22 <Tekmo_> It has to be something like "-ghc-opts='+RTS ...`
20:08:37 <Tekmo_> I forgot the exact name. Let me check
20:08:58 <Cale> whatisirc: I think what the article's author meant is that the evaluation of the expression is separate from its execution. But while I haven't read this whole article, I'm not sure I can say I like it :)
20:09:10 <Tekmo_> maxiepoo: cabal install --ghc-options='+RTS ...'
20:10:16 <c_wraith> whatisirc: I'd be cautious about the wiki. It has a lot of stuff that was questionable quality when written, and hasn't been updated since. It's not a resource that's used very much.
20:10:37 <Cale> We really should be more responsible about the wiki
20:10:47 <Tekmo_> The main issue is that people are too afraid to tread on the toes of old articles
20:10:51 <Cale> yes
20:10:57 <maxiepoo> Tekmo_: thanks, but the error isn't that it's not getting the options to ghc,
20:11:03 <maxiepoo> it's: cabal: ghc: the flag -prof requires the program to be built with -prof
20:11:05 <xoip> When using zipWith, is there any way for the function taken as an arg to specify that some elements aren't included in the output?
20:11:05 <c_wraith> Which totally misses the point of being a wiki.  >_>
20:11:14 <Cale> I really dislike mediawiki, it immediately makes people think of wikipedia and all of wikipedia's rules.
20:11:38 <schlegel> maxiepoo: Have you read http://www.haskell.org/haskellwiki/How_to_profile_a_Haskell_program
20:11:47 <Cale> Back when we were using moinmoin, the wiki was a lot more dynamic and people actually used it to communicate
20:12:08 <c_wraith> xoip: no.  However, you could have the function return a Maybe result, then use catMaybes to filter out all the Nothings and remove the Justs
20:12:19 <Tekmo_> xoip: You can pair up `zipWith` with `filter`
20:13:09 <c_wraith> :t \f x y -> catMaybes $ zipWith f x y
20:13:10 <lambdabot> (a1 -> b -> Maybe a) -> [a1] -> [b] -> [a]
20:13:18 <maxiepoo> schlegel: yeah, but that uses Setup.hs for everything which isn't picking up by cabal sandbox
20:13:21 <Cale> whatisirc: That said, here's a link to my approach: http://www.haskell.org/haskellwiki/Monads_as_computation
20:13:32 <Cale> whatisirc: But about where are you in understanding Haskell?
20:13:33 <xoip> Okay that's a lot of help I'll check it out
20:13:41 <Cale> whatisirc: Are you already familiar with type classes?
20:13:53 <Tekmo_> maxiepoo: Did you build profiling versions of all your libraries?
20:14:51 <maxiepoo> Tekmo_: as in rebuild all of the dependencies or just my libraries?
20:15:09 <schlegel> maxiepoo: All the dependencies have to be profiling too iirc
20:15:14 <whatisirc> Cale, i read the chapter on it in learnyouahaskell but i don't think i fully understand it yet
20:15:16 <maxiepoo> oh lord
20:15:29 <maxiepoo> that takes like an hour for this project
20:15:31 <Tekmo_> maxiepoo: This is why I turn on profiling by default before installing anything
20:15:38 <Tekmo_> maxiepoo: Because it's a pain to do retroactively
20:15:46 <maxiepoo> Tekmo_: apparently!
20:15:48 <Tekmo_> :)
20:15:54 <schlegel> I know with cabal-dev you could have an extra config file with executable-profiling: True library-profiling: True in it
20:16:00 <c_wraith> maxiepoo: it won't speed up the actual compilation, but you can use the magical "world" target to at least make it only one command to rebuild everything.
20:16:21 <whatisirc> Cale, thanks for the link
20:16:24 <c_wraith> maxiepoo: like, after enabling library profiling...  cabal install --reinstall world
20:16:27 <schlegel> not sure about new cabal sandboxes
20:16:47 <Cale> whatisirc: Okay, so it might be good to make sure you have a really solid grasp of what type classes are about before you tackle understanding the Monad type class, because it's a somewhat fancy example of one.
20:16:51 <schlegel> c_wraith: When you have a big hammer...
20:16:58 <schlegel> Why not cabal install --dependencies-only
20:17:18 <c_wraith> schlegel: because if you're fixing the problem, you might as well fix it.
20:17:19 <maxiepoo> so I should do `cabal install --enable-library-profiling`?
20:17:50 <c_wraith> maxiepoo: it's probably better to enable library profiling in your ~/.cabal/config file
20:17:52 <whatisirc> Cale, ok
20:18:08 <schlegel> Yeah I guess, just wasn't sure of other implications of enabling profiling
20:18:09 <c_wraith> maxiepoo: that'll make sure if you install new libs that your project uses, they won't break profiling
20:18:44 <schlegel> I'm one to reinstall just the ones I need to profile with instead of all the ones I might use
20:19:11 <Tekmo_> schlegel: Enabling profiling just means that you double all your compile times.  That's pretty much it
20:19:25 <maxiepoo> oh wait my ~/.cabal/config already has "library-profiling: True"
20:19:28 <Tekmo_> schlegel: cabal compiles two separate versions of the library, one with profiling and one without
20:19:37 <Tekmo_> schlegel: It won't slow down programs compiled without profiling
20:19:40 <schlegel> Oh really
20:19:50 <schlegel> Nevermind then makes perfect sense
20:20:46 <maxiepoo> no wonder it takes so long to compile!
20:22:21 <quchen> Cabal question. I have a handful of source files, and want to build them to multiple different executables (i.e. different main files, the rest of the modules are identical). Is there a way to share the build configuration between them, changing only the "main-is" field? Repeating the entire list of dependencies and other-modules for each executable is a lot of noise.
20:22:50 <Tekmo_> Yes
20:23:02 <binroot> when I write "instance Foldable Tree where ...", do I say "I'm implementing the Foldable typeclass"?
20:23:11 <binroot> what's the proper way of saying what I wrote?
20:23:25 <Tekmo_> quchen: So there is a neat trick where you can add a library field that has all the dependencies and then all the executable depend on the library of the same name
20:23:33 <Tekmo_> quchen: Let me find you an example.  One second
20:23:51 <quchen> Tekmo_: A catchword will do, assuming it's in the Cabal user's guide
20:24:05 <mirpa> There should be more namespace shadowing warnings by default.
20:24:10 <Iceland_jack> binroot: “Implenting a Foldable instance for Tree”
20:24:20 <binroot> Iceland_jack: thanks!
20:24:27 <Tekmo_> quchen: Check this out: http://lpaste.net/97768
20:24:27 <tertl3> hello and bsd/yesod users here?
20:24:33 <Tekmo_> quchen: I'm not sure what the name for this trick is
20:24:51 <mirpa> I often fail to see them in my code.
20:25:04 <quchen> Tekmo_: Hmm. Let me find the trick first.
20:25:41 <schlegel> Tekmo_: I've done the same in makefiles
20:25:46 <schlegel> With a depend target
20:27:18 <quchen> Tekmo_: Oh, it's the "add package itself to dependencies"?
20:27:59 <Tekmo_> quchen: Yes
20:29:41 <quchen> How does that work? When I run 'cabal build', it will automatically build the library and the executable. Once the library is built, the executable (ab)uses it to get the dependencies transitively?
20:29:51 <Tekmo_> I think so
20:30:37 <quchen> And the "library" build type will just build all modules, i.e. it's everything the executable part does minus the linking?
20:31:01 <Tekmo_> Well, I think this only works if you can depend on the library itself to retrieve the things the library depended on
20:31:06 <maxiepoo> wait so my libraries are built with profiling enabled
20:31:11 <Tekmo_> i.e. you would have to have the library re-export necessary parts
20:31:21 <Tekmo_> So I think it's not a terribly sexy solution
20:31:35 <schlegel> maxiepoo: Yes but you also need executable-profiling
20:31:38 <maxiepoo> and I ran `cabal configure --enable-library-profiling --enable-executable-profiling`
20:32:24 <maxiepoo> and I ran `cabal build +RTS -prof -xc`
20:32:28 <maxiepoo> and it still says
20:32:56 <maxiepoo> oh wait
20:33:24 <maxiepoo> ok I ran `cabal build --ghc-options='+RTS -prof'`
20:33:28 <maxiepoo> and it still says
20:33:35 <maxiepoo> ghc: the flag -prof requires the program to be built with -prof
20:33:44 <quchen> Tekmo_: Hmm, that doesn't sound like a very good solution then. Back to the combination of makefile+sandbox it is ;-(
20:33:57 <bitemyapp> shit_hn_says: Why the hell should I worry about text encoding before sending a string into a TCP socket...
20:34:12 <dhrosa> how might I write this without do notation? http://lpaste.net/97770
20:34:20 <schlegel> maxiepoo: Did you 'cabal install --reinstall world'
20:35:01 <maxiepoo> schiegel wait my ~/.cabal/config had "library-profiling: True" the whole time
20:35:14 <maxiepoo> so I shouldn't need to do that right?
20:35:24 <mirpa> is there ghc option to warn about name shadowing like: let foo = f bar >>= foo >>= g; Wall nor fwarn-name-shadowing works
20:35:29 * hackagebot time-io-access 0.1.0.0 - IO Access for time  http://hackage.haskell.org/package/time-io-access-0.1.0.0 (bheklilr)
20:35:31 * hackagebot filepath-io-access 0.1.0.0 - IO Access for filepath  http://hackage.haskell.org/package/filepath-io-access-0.1.0.0 (bheklilr)
20:35:47 <schlegel> maxiepoo: Your issue is executable profiling
20:36:50 <maxiepoo> schlegel: but if I do --reinstall world is that going to reinstall all of my dependencies?
20:37:07 <bitemyapp> who's behind PLT Hulk?
20:38:11 <schlegel> maxiepoo: hmm, I see your point
20:39:47 <schlegel> maxiepoo: Ohhh
20:40:16 <schlegel> `cabal build --ghc-options='-prof +RTS -prof'`
20:40:41 <schlegel> Right now you're only sending the profiling flag to the runtime system, so it's not actually compiled with profiling
20:41:55 <schlegel> Also probably want to add -fprof-auto unless you want to manually annotate cost centers
20:43:18 <schlegel> maxiepoo: So try `cabal build --ghc-options='-prof -fprof-auto +RTS -p'`
20:43:38 <maxiepoo> same thing
20:43:43 <maxiepoo> god
20:43:45 <schlegel> Oh wait
20:44:04 <schlegel> I think '+RTS -p' is telling ghc to run with profiling
20:45:16 <schlegel> maxiepoo: `cabal build --ghc-options='-prof -fprof-auto' `
20:45:32 <schlegel> Then: `./main +RTS -p`
20:45:54 <schlegel> or whatever your executable would be
20:46:41 <maxiepoo> schlegel: ok this is building at least!
20:48:53 <schlegel> maxiepoo: I hope it works, I'm not really sure what I'm doing! haha
20:51:21 <maxiepoo> ugh it didn't
20:51:34 <schlegel> what did it say
20:52:35 <maxiepoo> the same thing
20:52:52 <maxiepoo> the flag -p requires the program to be built with -prof
20:54:07 <Axman6> maxiepoo: you may need to use -fforce-recomp to make sure that it actually rebuilds it with profiling
20:55:20 <maxiepoo> Axman6: it did build though
20:55:23 <maxiepoo> twice
20:55:31 <maxiepoo> one with profiling and one without
20:55:44 <maxiepoo> just like it's supposed to right?
20:59:33 <Tekmo_> maxiepoo: I feel like the time it took you to do all of this is longer than it would have taken to recompile all your dependencies :)
20:59:58 <maxiepoo> Tekmo_: My dependencies were all already compiled with profiling enabled
21:00:03 <maxiepoo> I just didn't know it
21:00:19 <Tekmo_> maxiepoo: You lucky dog! :)
21:00:23 <schlegel> maxiepoo: Check to make sure you have executable profiling enabled
21:00:26 <maxiepoo> I do
21:01:19 <schlegel> I'm not sure if running configure with that flag will add it to your cabal config
21:01:24 <schlegel> it's not for me
21:02:54 <maxiepoo> when I build the executable it makes a bunch of things that end in .p_o
21:06:10 <schlegel> maxiepoo: What are you running with +RTS -p
21:06:32 <maxiepoo> the executable
21:07:10 <Axman6> http://www.google.com.au/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&ved=0CC0QtwIwAA&url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DKswWfq2drCM&ei=MFDCUtTpL8mkkgWx8oDAAg&usg=AFQjCNFG1JfAPLVR3OE1f1qCNVOp616yjQ&sig2=nkuQXTyqz48BXn5AD-Xyzw&bvm=bv.58187178,d.dGI
21:07:14 <schlegel> Strange...have you tried force-recomp like Axman suggested?
21:07:15 <Axman6> urgh
21:07:16 <Axman6> you suck google
21:07:22 <Axman6> whoops, wrong channel!
21:11:06 <enthropy> shouldn't a RankN types be acceptable without a type signature if the definition is used in only one place?
21:11:35 <enthropy> since some inlining could be done before type checking
21:11:54 <jrw> enthropy: that might be possible, but it feels against the typical flavor of a type system.
21:12:05 <jrw> what about exporting such a function from a module?
21:12:24 <enthropy> no you wouldn't export it, since that's multiple uses
21:12:56 <enthropy> but for cases like  f = gmapQl (<>) mempty q ty where q = mkQ ...
21:13:13 <enthropy> I can just inline q, at which point I don't need a type signature
21:13:20 <whatisirc> is there a way to do content <- readFile "thing" \ putStrLn content \ in one line?
21:13:22 <jrw> I see, yes, for local use cases like that it is desireable.
21:13:26 <enthropy> this is kind of like what happens with ($)
21:13:33 <Tekmo_> whatisirc: readFile "thing" >>= putStrLn
21:13:54 <Tekmo_> whatisirc: That is what the `do` notation desugars to (basically)
21:14:46 <whatisirc> ok thanks
21:14:58 <schlegel> whatisirc: BTW proper way to one-line a do block is do { content <- readFile "thing"; putStrLn content; }
21:15:26 <schlegel> which you could then use with lambdabot's @undo
21:15:28 <schlegel> @undo do { content <- readFile "thing"; putStrLn content; }
21:15:28 <lambdabot> readFile "thing" >>= \ content -> putStrLn content
21:15:30 <enthropy> you can leave the { } out
21:15:51 <schlegel> @undo do content <- readFile "thing"; putStrLn content;
21:15:51 <lambdabot> readFile "thing" >>= \ content -> putStrLn content
21:15:55 <schlegel> so you can
21:16:04 <schlegel> thanks, enthropy
21:16:07 <maxiepoo> I am giving up
21:16:14 <maxiepoo> and resorting to putStrLn debugging
21:16:24 <YellPika> Never give up, never surrender...
21:16:25 <schlegel> maxiepoo: Try deleting your dist folder
21:16:29 <whatisirc> schlegel, that's helpful too thanks
21:16:53 <schlegel> I just created a new cabal sandbox and got profiling working
21:17:36 <schlegel> I can zip it up if you want to take a look
21:18:43 <Tekmo_> maxiepoo: A nice debugging trick is to split up your program into smaller parts and test their behavior in `ghci`
21:19:14 <maxiepoo> Tekmo_: it's a large program and I'm unfamiliar with most of it
21:19:34 <maxiepoo> there's a stack overflow
21:19:45 <maxiepoo> which is almost certainly because of an infinite loop
21:19:58 <maxiepoo> I just don't know where
21:20:06 <benzrf> hey, can anybody look over my code @ http://lpaste.net/97771 and give constructive criticism?
21:20:20 <maxiepoo> schlegel: I deleted my dist dir
21:20:30 <maxiepoo> what commands did you do specifically
21:21:23 <schlegel> I added library-profiling and executable-profiling to the cabal.config and just ran cabal build
21:21:42 <whatisirc> is putStrLn =<< readFile "thing" same as readFile "thing" >>= putStrLn?
21:21:44 <Tekmo_> benzrf: You can simplify `addition`s in many ways, but a simple one is: additions = [(x, y) | x <- [-1..1], y <- [-1..1], (x, y) /= (0, 0)]
21:22:03 <schlegel> whatisirc: Yeah
21:22:07 <whatisirc> ok
21:22:22 <schlegel> @src =<<
21:22:22 <lambdabot> f =<< x = x >>= f
21:22:28 <schlegel> whatisirc: ^
21:22:33 <whatisirc> @help
21:22:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:22:35 <whatisirc> @list
21:22:35 <lambdabot> What module?  Try @listmodules for some ideas.
21:22:37 <benzrf> arghh
21:22:41 <Tekmo_> benzrf: Also, instead of `zipWith addC (repeat coord) additions`, you can just do `map (addC coord) additions`
21:22:43 <benzrf> Tekmo_: i always forget about list comps
21:22:46 <benzrf> u_u
21:23:33 <schlegel> benzrf: If you want a lot of criticism, you could post it to /r/haskell
21:23:47 <schlegel> Would definitely get more visibility
21:24:19 <schlegel> not to downplay Tekmo_'s advice :P
21:25:48 <Cale> It's interesting that you choose foldl
21:26:07 <Cale> I think I'd probably have gone with foldr here
21:26:29 <benzrf> i always forget that foldr exists
21:26:31 <Cale> Or I guess foldl' would be possible
21:26:32 <benzrf> why would it be better here?
21:26:36 <benzrf> and what is foldl'
21:26:37 <Cale> foldr is the easier one to think about
21:26:39 <Tekmo_> That's exactly why I love /r/haskell.  They give excellent criticism :)
21:26:55 <benzrf> Cale: really?
21:26:59 <benzrf> how so?
21:27:01 <Cale> foldr f z replaces all the (:)'s in a list with f and the [] at the end with z
21:27:14 <benzrf> oh, i never thought of it that way
21:27:47 <benzrf> i normally think of a fold as an abstract machine or creature proceeding along the list, using the folding func to cram each element onto the accumulator
21:28:09 <Tekmo_> benzrf: That's what a left fold is for
21:28:16 <Cale> foldl' is a strictified version of foldl which makes sure that the accumulator has a chance to evaluate in an order which doesn't result in a stack overflow
21:28:45 <zRecursive> @src foldr'
21:28:45 <lambdabot> Source not found. Are you typing with your feet?
21:28:55 <zRecursive> @src foldr
21:28:56 <lambdabot> foldr f z []     = z
21:28:56 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:28:57 <benzrf> so how would foldr work here?
21:29:33 <zRecursive> @src foldl'
21:29:33 <lambdabot> foldl' f a []     = a
21:29:33 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
21:29:51 <Cale> I haven't thought carefully enough about your specific program
21:30:04 <benzrf> :t foldl
21:30:04 <lambdabot> (a -> b -> a) -> a -> [b] -> a
21:30:05 <benzrf> :t foldr
21:30:06 <lambdabot> (a -> b -> b) -> b -> [a] -> b
21:30:08 <Cale> But let's have a look at what this is doing
21:30:17 <zRecursive> why no foldr' source ?
21:30:24 <Cale> zRecursive: becasue there is no foldr'
21:30:29 <benzrf> i think of monadic chaining as being similar to a left fold
21:30:33 <Cale> because*
21:30:43 <benzrf> you keep pushing new functions onto the current monadic value
21:30:44 <benzrf> or something
21:30:49 <zRecursive> Cale: impossible to implement foldr' ?
21:30:51 <benzrf> so a left fold seemed logical
21:30:58 <Cale> zRecursive: Well, what does that mean?
21:31:15 <benzrf> anyway, >>= is an (a -> b -> a), not an (a -> b -> b)
21:31:17 <quchen> benzrf: >>= is associative-ish, so you can also see it as a right fold.
21:31:23 <zRecursive> Cale: there is foldr, why no foldr' ?
21:31:30 <Tekmo_> benzrf: Your code would have been clearer if you pre-wrapped your `updateHeads` to be `World -> Reader World World` instead of at the last moment in the `updaters` function
21:31:30 <quchen> It depends on how you want your things to be evaluated, really.
21:31:39 <Cale> zRecursive: Could you propose a definition of foldr'?
21:31:51 <Cale> zRecursive: I don't know what you mean by it.
21:31:55 <zRecursive> ok
21:32:47 <Cale> benzrf: I'm thinking more of the stuff in fromDrawing than step
21:33:23 <Tekmo_> benzrf: `foldl` is like the worst of both worlds since it's neither elegant nor strict
21:33:49 <benzrf> :[
21:33:52 <benzrf> it feels elegant to me
21:33:54 <benzrf> D;
21:34:10 <benzrf> i dont know how to think about right folds i guess
21:34:35 <Cale> benzrf: The way I think about them is that you're redefining what cons and nil are after the fact.
21:34:58 <codygman-> I am having problems installing tasty: http://lpaste.net/97772 Here is my cabal file: http://lpaste.net/97773
21:35:43 <Cale> benzrf: http://cale.yi.org/share/Folds.png
21:36:27 <schlegel> benzrf: You first should think about lists as [a,b,c] = a:b:c:[] = Cons a (Cons b ( Cons c Nil ))
21:36:38 <benzrf> yeah
21:36:53 <Cale> codygman-: That's an honest type error in Test/Tasty/Options.hs
21:37:01 <benzrf> i just find it easier to think in terms of left folds
21:37:02 * benzrf shrugs
21:38:03 <Cale> So just like (:) takes an element and a list and produces a new list, the function we pass to foldr is going to take an element x and some summary of the list, and produce a summary accounting for x.
21:38:04 <schlegel> now foldr f d [a,b,c] = f a (f b (f c d))
21:38:25 <Cale> (foldr (:) [] is the identity function)
21:38:36 <schlegel> Similarly foldr (:) [] == id
21:38:38 <jle`> yo if there are naming in my unqualified imports, why can't Haskell infer which one i am talking to?
21:38:41 <schlegel> yeah what cale said
21:38:42 <jle`> about
21:38:44 <Cale> > foldr (\x xs -> x : x : xs) [] [1..]
21:38:45 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
21:39:00 <Cale> > foldr (\x xs -> if even x then x : xs else xs) [] [1..]
21:39:01 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
21:40:37 * hackagebot herringbone 0.0.3 - A library for compiling and serving static web assets.  http://hackage.haskell.org/package/herringbone-0.0.3 (hdgarrood)
21:40:45 <zRecursive> foldr cannot/neednot be strict so there is NO foldr' ?
21:41:10 <Cale> zRecursive: well, which subexpression would you strictify?
21:41:25 <Cale> @src foldr
21:41:25 <lambdabot> foldr f z []     = z
21:41:25 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:41:26 <zRecursive> seems no
21:41:31 <Cale> The foldr f z xs?
21:41:33 <Tekmo_> benzrf: An easier way to build your world from the drawing would be to use helper functions from `Data.Map`
21:41:35 <Cale> I suppose you could do that
21:41:40 <jle`> too much knowledge for benzrf
21:41:42 <Cale> But it would rarely be helpful
21:41:50 <jle`> he left :/
21:41:52 <Tekmo_> benzrf: It provides map constructions functions like `fromList` and `fromListWith`
21:41:53 <schlegel> Cale: You would need to strictify the arguments of f
21:42:08 <schlegel> Or at least
21:42:29 <Cale> You could have foldr' f z (x:xs) = let y = foldr f z xs in y `seq` f x y
21:42:32 <nstdloop> Since foldr seems to be so great, what are the best uses of foldl where foldr wouldn't work?
21:42:45 <Tekmo_> nstdloop: Note that you can implement `foldl` in terms of `foldr`
21:42:54 <nstdloop> Ah.
21:42:58 <Cale> But that's never going to improve performance, as far as I can tell.
21:42:59 <nstdloop> How about where it would be much more complicated
21:43:06 <zRecursive> Cale: so foldr will build a big thunk for a large list ?
21:43:11 <Tekmo_> nstdloop: http://hackage.haskell.org/package/base-4.3.1.0/docs/src/Data-Foldable.html#foldl%27
21:43:18 <Cale> nstdloop: reverse is a pretty good example
21:43:30 <Cale> > foldl (flip (:)) [] [1..5]
21:43:31 <lambdabot>  [5,4,3,2,1]
21:43:31 <Tekmo_> Cale: Actually it does improve performance
21:43:37 <Tekmo_> Cale: It triggers build/foldr fusion
21:43:54 <Cale> Tekmo_: my foldr' will?
21:44:02 <Tekmo_> Cale: Oh
21:44:08 <Cale> oh, also, I didn't use foldr' recursively
21:44:09 <nstdloop> Using foldr to implement foldl
21:44:13 <Cale> which is dumb
21:44:13 <Tekmo_> Cale: No, I was referring to `foldl'` implemented in terms of `foldr`
21:44:18 <Cale> yeah, I wasn't ;)
21:44:20 <Tekmo_> :)
21:44:25 <binroot> is the best way to use a binary tree by using Data.Tree? or should I just make my own data type? The Data.Tree is a rose tree...
21:44:26 <Cale> foldr' f z (x:xs) = let y = foldr' f z xs in y `seq` f x y
21:44:38 <nstdloop> There is a foldr'
21:44:42 <Cale> That's something you can do, but I don't think it's ever useful to do it
21:44:47 <nstdloop> In the link Tekmo_ posted
21:44:59 <Tekmo_> Yeah, it pretty much does what Cale wrote
21:45:06 <Cale> Oh, well, Data.Foldable has a right to be more general
21:45:23 <Cale> Because some of its instances can usefully be decomposed from both ends
21:45:29 <nstdloop> Interesting that foldr' is implemented using foldl and foldl' is implemented using foldr
21:45:31 <Tekmo_> I think `Data.Foldable` should just be one method: `toList` and let build/foldr fusion do the rest
21:46:15 <Cale> Tekmo_: Well, that mostly works
21:47:12 <Cale> It seems like you could theoretically do better than conversion to a list for things like Set
21:47:12 <nstdloop> So are there any nice cases where using foldr is significantly more inconvenient?
21:47:26 <Cale> nstdloop: Cases where you end up with a stack overflow
21:47:31 <nstdloop> Sorry
21:47:38 <nstdloop> I meant where foldl is significantly more convenient
21:47:39 <Cale> (you'll also end up with one using foldl)
21:47:41 <nstdloop> the other way around is clear
21:47:52 <Cale> Did you see my example of reverse?
21:47:56 <Tekmo_> nstdloop: Pretty much whenever you don't want to implement `foldl'` as `foldr`
21:47:59 <Cale> > foldl (flip (:)) [] [1..10]
21:48:00 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
21:48:05 <nstdloop> I do now
21:48:10 <Cale> Harder to do that with foldr
21:48:37 <Cale> > foldr (\x xs -> xs . (x:)) id [1..10] []
21:48:38 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
21:49:34 <nstdloop> But still not too hard
21:50:10 <nstdloop> Considering you can make one with the other that makes sense
21:50:45 <schlegel> Or
21:51:02 <schlegel> > foldr (flip (.) . (:)) id [1..10] []
21:51:03 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
21:51:17 <Cale> hah, sure
21:52:57 <Cale> Note you could also write:
21:53:14 <Cale> > foldr (\x xs -> xs ++ [x]) [] [1..10]
21:53:15 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
21:53:24 <Cale> But apply that to a list of 10000 elements
21:53:29 <Cale> and you'll find out why that's bad
21:53:30 <nstdloop> But that's quadratic
21:53:32 <Cale> yeah
21:54:00 <Cale> (maybe 100000 if that's still too fast)
21:54:12 <nstdloop> I trust in the slowness of quadratic functions
21:54:32 <dleedev> Hi, what's an endofunctor?
21:54:40 <dleedev> is any function a -> a an endofunctor?
21:54:46 <Cale> There's something very Commodore 64 about actually watching it print the results like that. I kind of like it.
21:55:12 <quchen> Cale: May I interest you in SlowSort? :-)
21:55:13 <Cale> dleedev: That might be called an endomorphism or an endofunction
21:55:31 <Cale> dleedev: An endofunctor is a functor whose domain and codomain are the same category
21:56:24 <Cale> (Like every instance of the Functor class in Haskell -- they all have the category of Haskell types and functions as their domain and codomain)
21:56:28 <nstdloop> let's say I have a = [1..100] and b = [1..100]. Because of laziness and purity, isn't c = a ++ b actually constant time? The only reason c would be evaluated is if I were to loop through it, which is linear on its own, and then each element would just get tacked on as I went along. Additionally, a and b would never change, so you don't even need a copy of them,, right?
21:57:02 <augur> dleedev: whats inspiring this question?
21:57:03 <Cale> Well, xs ++ ys takes O(length xs) steps to fully evaluate
21:57:05 <dleedev> Cale: you mean Haskell types are domains and functions are codomains?
21:57:13 <Cale> dleedev: no
21:57:30 <dleedev> Cale: sorry, must have misread what you meant
21:57:31 <Cale> dleedev: I mean, there's a category whose objects are Haskell types, and whose arrows are the functions between them
21:57:43 <Cale> (The Haskell definable functions)
21:57:44 <nstdloop> Cale: True, but because you can't ever change a and b, why can't you just say that c is a until I get to the end then look at b
21:57:59 <dleedev> Cale: I'm not at Arrows yet :)
21:57:59 <augur> dleedev: do you know what a functor is? ignoring the endo part?
21:58:12 <Cale> nstdloop: Any computation of a constant can be considered constant time, unless it loops forever
21:58:26 <dleedev> augur: Functor is a data structure you can map a function over to get the same data structure except with the results
21:58:27 <nstdloop> I dunno. I feel like it should be amortized constant time because the only time I need to step is if I am already looping
21:58:30 <Cale> dleedev: I'm not talking about Arrows in the sense of Haskell.
21:58:39 <Cale> dleedev: I'm talking about arrows in the sense of category theory.
21:58:53 <dleedev> Cale: unless you mean arrows that you fling with a bow, I don't know what arrows are =/
21:59:05 <augur> dleedev: why are you asking about endofunctors?
21:59:17 <dleedev> augur: trying to see what this quote means: "a monad in X is just a monoid in the category of endofunctors of X"
21:59:21 <quchen> nstdloop: a ++ b requires a to be re-allocated, because its last element has to point at b.
21:59:28 <Cale> dleedev: Okay, so you need to know what a category is, and then a functor, and then an endofunctor is just a simple specialisation of what a functor is.
21:59:31 <augur> dleedev: oh dear
21:59:34 <Tekmo_> dleedev: Here's a quick and dirty explanation
21:59:35 <augur> dleedev: ignore that quote.
21:59:36 <Cale> dleedev: Don't bother
21:59:38 <quchen> Or more accurately, a's spine has to be re-allocated.
21:59:42 <Tekmo_> dleedev: Look at the type signature of `mappend`
21:59:42 <nstdloop> quchen: and that requires re allocating the whole list?
21:59:45 <Tekmo_> :t mappend
21:59:46 <lambdabot> Monoid a => a -> a -> a
21:59:53 <Cale> dleedev: Well, okay, if you want to understand that, I can spend a few hours giving you the background
21:59:55 <nstdloop> why not just reallocate the last item?
21:59:56 <quchen> nstdloop: All the cons cells, yes.
22:00:05 <Tekmo_> dleedev: It takes two `a`s and combines them together into a single `a`
22:00:07 <nstdloop> because it's trapped in the whole chain of Cons
22:00:10 <augur> dleedev: that quote is intended to make fun of people who dont know how to explain things without getting stuck up their own butts. or at least, that's what it's come to be.
22:00:10 <Tekmo_> dleedev: Now look at the type of `join`
22:00:12 <Tekmo_> :t join
22:00:13 <lambdabot> Monad m => m (m a) -> m a
22:00:19 <Cale> dleedev: It's kind of enlightening in some ways, but it's also extremely unnecessary. :)
22:00:25 <Tekmo_> It takes two monad layers, `m`, and combines them into a single layer, `m`
22:00:35 <Tekmo_> dleedev: Similarly, consider `mempty`
22:00:39 <Tekmo_> :t mempty
22:00:39 <lambdabot> Monoid a => a
22:00:44 <dleedev> Cale: do all programmers who understand monads understand that quote?
22:00:49 <Cale> dleedev: no
22:00:51 <Tekmo_> dleedev: It generates a single `a` out of thin air
22:00:56 <Tekmo_> dleedev: The `Monad` analog is `return`
22:00:58 <Tekmo_> :t return
22:00:59 <lambdabot> Monad m => a -> m a
22:01:03 <augur> Tekmo_: you're almost certainly not helping
22:01:07 <Tekmo_> dleedev: That generates a single `m` layer out of thin air
22:01:28 <Cale> Tekmo_: To do this analogy justice requires talking about monoidal categories...
22:01:32 <Tekmo_> dleedev: If you take that intuition and make it rigorous, it leads to that quote that you read
22:02:06 <Cale> dleedev: You'll need to know a not-insignificant amount of category theory to understand that quote properly
22:02:57 <augur> dleedev: where did you find that quote
22:03:07 <quchen> That quote is completely irrelevant to using monads in Haskell.
22:03:12 <quchen> Don't obsess with it.
22:03:19 <Cale> augur: Probably everywhere
22:03:21 <Cale> :)
22:03:29 <dleedev> Tekmo_: well, I understand what monoids are, they're datatypes that can be aggregated using `mappend`
22:03:34 <schlegel> dleedev: Are you interested in pure mathematics
22:03:37 <dleedev> Tekmo_: how are monads monoids?
22:03:43 <dleedev> schlegel: no, I'm trying to learn haskell
22:03:46 <augur> Cale: yes well, if it was said in jokingly, thats one thing
22:03:51 <schlegel> Then don't worry about the quote
22:03:55 <Tekmo_> dleedev: `join` is the analog of `mappend`
22:03:55 <dleedev> augur: I found it on stack overflow, I think
22:03:57 <augur> dleedev: dont worry about why monads are monoids
22:04:00 <Tekmo_> dleedev: and `return` is the analog of `mempty`
22:04:09 <Cale> dleedev: These are excellent questions, but you're at least a few hours of definitions away from being able to understand the answer.
22:04:27 <dleedev> Tekmo_: so the the point of the quote is that monads are analogous to monoids, not that they ARE monoids?
22:04:27 <Cale> and the answer will only really help you if you're interested in the mathematics behind this
22:04:35 <Tekmo_> dleedev: They are monoids in a rigorous sense
22:04:37 <Cale> and won't in any way be practical for your daily programming
22:04:46 <Tekmo_> But what Cale is trying to tell you is that the rigorous explanation is difficult
22:04:58 <Tekmo_> I'm giving you a very informal explanation
22:04:58 <augur> dleedev: if it was found on stack overflow in a discussion about haskell, then it was written by someone who had discovered category theory and/or monads and wanted to show off their understanding, but without any consideration to the quality or informativity of the answer they were giving
22:05:09 <Cale> You can generalise the definition of a monoid so that instead of just sitting in the category of sets and functions, it works in an arbitrary monoidal category
22:05:32 <Cale> (that is, a category equipped with some additional widgets)
22:05:43 <Tekmo_> dleedev: The idea is that the category theory definition of a monoid is more general than the Haskell `Monoid` type class
22:06:02 <Cale> and then you can transplant that definition of monoid to a certain monoidal category, and it specialises to the definition of a monad
22:06:08 <dleedev> Tekmo_: ah, I see
22:06:33 <dleedev> Cale: is "category" hard to define?
22:06:36 <Tekmo_> If you want to see how how to embed a more general notion of monoid that does cover the monad sense, you should read this post: http://tailcalled.wordpress.com/2012/04/03/translation-of-monads-are-just-monoids-in-the-category-of-endofunctors/
22:06:42 <Cale> Not *that* hard, but it's a bit of a mouthful
22:06:47 <augur> dleedev: the long and short of it is that you really shouldn't worry about this stuff right now, or at all, depending on your purposes
22:06:52 <Cale> So, a category consists of the following things:
22:07:07 <Cale> a category C consists of
22:07:16 <quchen> Cale is ready to fire away, can't stop it now! :-D
22:07:20 <Cale> 1) A collection Ob(C) of "objects" of C
22:07:46 <Cale> these may be anything and category theory doesn't talk about their insides, so they're more or less labels
22:07:58 <Tekmo_> dleedev: A good starting point is Haskell's `Category` type class.  It's not as general as the category theory notion but it's a good launching point
22:08:00 <dleedev> augur: my purpose is to understand AND APPRECIATE haskell
22:08:08 <Tekmo_> dleedev: Control.Category has this type class
22:08:13 <Tekmo_> :info Category
22:08:18 <dleedev> augur: I feel like my appreciation for much of haskell's design would increase with deeper understanding of this stuff
22:08:21 <Tekmo_> Darn, thought that would work
22:08:28 <Tekmo_> How do I pull up a class definition?
22:08:32 <Cale> 2) For each pair of objects X, Y in Ob(C), there is a collection C(X,Y) of "arrows from X to Y". When f is an arrow from X to Y, we write f: X -> Y
22:08:39 <Tekmo_> @src Category
22:08:39 <lambdabot> Source not found. Just what do you think you're doing Dave?
22:08:48 <augur> dleedev: if that includes learning category theory, then you'll need to learn category theory. from the beginning. like cale is trying to teach you right now
22:08:52 <mgsloan> dleedev: I might be wrong, but I feel like much of this stuff was discovered *after* the design of Haskell
22:09:02 <Cale> 3) For each three objects X, Y, Z in C, and each pair of arrows f: Y -> Z and g: X -> Y, there is a composite arrow f . g : X -> Z
22:09:13 <augur> dleedev: you wont get to the point where you can understand this stuff for a long time.
22:09:23 <Tekmo_> See, this is what I don't like
22:09:25 <mgsloan> in other words, Haskell being a nice language for both programs and maths meant that this interesting intersection between the two is ripe for harvesting
22:09:32 <Tekmo_> I don't like people who are snobs about it
22:09:39 <augur> dleedev: and itll be an investment in and of itself, that wont really help you appreciate haskell right away.
22:09:47 <Tekmo_> I feel that if you advertise category theory as unapproachable then it becomes a self-fulfilling prophecy
22:10:00 <Cale> 4) For each four objects X, Y, Z, W and arrows f: Z -> W, g: Y -> Z, h: X -> Y, we have that (f . g) . h = f . (g . h)  (composition is always associative when it makes sense)
22:10:17 <augur> if thats what youre after, then thats fine. but you have to understand that.
22:10:46 <Cale> 5) For each object X, there is an arrow id_X: X -> X so that for any other object Y and arrow f: X -> Y or g: Y -> X, we have f . id_X = f and id_X . g = g
22:11:05 <Cale> Done!
22:11:15 <Tekmo_> Cale: You could have just linked him to the wikipedia article
22:11:17 <Cale> So, if you define what these things all are, you have a category
22:11:20 <mgsloan> Tekmo_: Hmm, that's true.  I think we're just trying to combat the myth that understanding category theory is foundational to truly understanding haskell
22:11:28 <Tekmo_> mgsloan: That I agree with
22:11:39 <Cale> Yeah, but I don't like telling people to RTFM, and I'd rather be ready to be interactive
22:11:41 <augur> Tekmo_: noone's advertising it as unapproachable. i'm just trying to make sure dleedev knows that CT isnt just five seconds of reading, and that he wont understand that quote until he really reads a bunch because it's not a trivial quote
22:11:55 <dleedev> Cale: by arrow, do you mean function? (remember, I don't know what arrows are)
22:12:03 <mgsloan> And I agree that mystifying category theory is giving too much of a rep for being abstract nonsense ;)
22:12:11 <augur> this might be better suited to ##categorytheory
22:12:11 <Tekmo_> dleedev: An arrow doesn't have to be a function
22:12:12 <Cale> dleedev: The arrows are whatever we say they are.
22:12:17 <Tekmo_> dleedev: It can potentially be anything
22:12:27 <Tekmo_> dleedev: What's your background?  I might be able to come up with a bizarre example
22:12:28 <augur> an arrow is a line with a little pointy thing on one end
22:12:33 <zRecursive> function is called morphism too ?
22:12:35 <Cale> dleedev: If you tell me what all these things are, and they satisfy the conditions I've laid out there, then you've defined a category
22:12:45 <Tekmo_> zRecursive: A function is one example of a morphism (for a particular category)
22:13:00 <augur> and a particular notion of function..
22:13:01 <shachaf> I have the feeling that giving the definition of a category without motivation leads mostly to a lot of confusion until you've been familiar with it for a while.
22:13:06 <zRecursive> Tekmo_: thx
22:13:25 <djahandarie> shachaf, I think it leads to confusion even if you've been familiar with it for a while.
22:13:29 <Cale> dleedev: So, you can tell me what objects and arrows are, and how the arrows compose with each other, and so long as your composition is associative, and you have identity arrows, then I will accept that you've given an example of a category.
22:13:30 <augur> i agree with shachaf even tho he cant see me agree
22:13:30 <shachaf> And there's so much easy motivation, things that are "almost a monoid, but not quite" that you can use, that make the laws come up naturally.
22:13:52 <Tekmo_> Here's a simple example
22:13:56 <Tekmo_> Height
22:13:58 <dleedev> Tekmo_: my background: CS in college, worked with C, C++, JAVA, LISP, Ruby, Javascript, and *sh.
22:14:01 <Tekmo_> Objects are altitudes
22:14:07 <Tekmo_> Morphisms are differences between altitudes
22:14:19 <Cale> dleedev: The canonical example is the category whose objects are sets, and whose arrows f: X -> Y are functions with domain X and codomain Y.
22:14:20 <shachaf> ?
22:14:32 <augur> Tekmo_, that's a really weird example
22:15:08 <shachaf> I'd give an example, but people are already talking over each other way too much.
22:15:14 <Cale> i.e. f consists of a triple (X,Y,G) where G is a subset of the Cartesian product X × Y such that for each x in X, there is exactly one y in Y so that (x,y) is in G, and when (x,y) is in G, we say f(x) = y
22:15:22 <dleedev> Tekmo_: and "Height" is the category?
22:15:34 <Cale> (that's a pretty standardish definition of what a function is from set theory)
22:15:43 <Tekmo_> dleedev: "Height" is just an informal name for it
22:15:57 <Tekmo_> dleedev: I just wanted to give a non-programming example
22:16:05 <shachaf> I can
22:16:13 <shachaf> 't tell what category Tekmo_ means.
22:16:21 <augur> dleedev: if you really want to learn CT, i would suggest you start with Awodey's book and/or lectures at oplss2012:
22:16:24 <augur> @where oplss2012
22:16:24 <lambdabot> https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
22:16:26 <Cale> shachaf: I can't quite either
22:16:29 <Tekmo_> Objects are altitudes
22:16:35 <Tekmo_> Morphisms are differences in altitudes
22:16:37 <Cale> Tekmo_: what's the composition?
22:16:41 <augur> also, i suggest you watch catsters once you've gotten your heals dug in a little bit
22:16:42 <shachaf> Is there exactly one arrow between any two objects here?
22:16:42 <Tekmo_> Composition is addition of (differences in altitudes)
22:16:48 <Tekmo_> Identity is the 0 difference
22:16:52 <Cale> okay
22:16:53 <augur> @where catsters
22:16:53 <lambdabot> http://www.youtube.com/user/TheCatsters
22:16:57 <augur> dleedev: ^
22:17:09 <augur> and dont forget to join ##categorytheory
22:17:27 <zRecursive> Can arrow be bidirectional ?
22:17:28 <shachaf> So is it like a preorder where objects are heights and they're all considered equivalent to each other?
22:17:34 <shachaf> Or am I missing some sort of structure?
22:17:37 <Cale> dleedev: Here's another example, recall that a monoid consists of a set M, together with a binary operation *: M x M -> M which is associative and has an identity
22:17:43 <Tekmo_> zRecursive: It's more appropriate to say that bidirectional tihngs can be arrows
22:17:45 * djahandarie wonders if 1k users is a critical mass for an IRC channel
22:17:53 <shachaf> Anyway I suggest that #haskell-overflow is better for this discussion.
22:18:01 <Gracenotes> critical mess?
22:18:01 <epta> #haskell and ##categorytheory are different channels?
22:18:09 <dleedev> augur: wouldn't ##categorytheory be over my head right now?
22:18:12 <Cale> dleedev: Given any monoid, we can turn it into a category having just one object (doesn't matter what the object is, it's just a label, and since there's only one of it here, not an important label)
22:18:13 <augur> dleedev: no
22:18:21 <augur> dleedev: its a quiet channel, for any CT talk
22:18:24 <augur> including this sort of thing
22:18:31 <Cale> and where there are arrows from that one object to itself for each of the elements of M
22:18:39 <augur> we've done introductory convos before
22:18:46 <Cale> and we define the composition of arrows by the multiplication of the monoid
22:19:04 <Cale> and the identity arrow is the identity of the monoid
22:19:06 <augur> im still not sure if you really need to understand this stuff yet -- i think type theory would be more useful and insightful in the long run
22:19:07 <Tekmo_> Cale: It helps to use Haskell/programming terminology for beginners
22:19:15 <Tekmo_> Cale: Make sur eyou mention that "multiplication" is referring to `mappend`
22:19:20 <Cale> yeah
22:19:25 <Tekmo_> I had a big problem with this when I started
22:19:32 <Tekmo_> I knew the programming terms but not he mathematical terms
22:19:37 * djahandarie finds it amusing that someone is giving Cale advice on how to explain things to people
22:19:40 <Cale> actually, it might be good to take this discussion there if you're interested :)
22:19:47 <augur> fwiw dleedev, im always in there and willing to be bugged about stuff
22:20:05 <Tekmo_> Like others have said, category theory is not a prerequisite for programming in Haskell
22:20:07 <augur> i mean, im always in here too, but this is sort of off topic for this channel :X
22:20:12 <Tekmo_> But I consider it a prerequisite for good library design
22:20:19 <shachaf> djahandarie: Why amusing?
22:20:45 <dleedev> alright, I think I bit a little too much to chew for right now
22:21:04 <dleedev> Cale, augur: I'll see you guys in ##categorytheory when I'm a bit more ready
22:21:06 <Cale> dleedev: Here's a book http://cale.yi.org/share/S.%20Awodey%20-%20Category%20Theory.pdf
22:21:17 <Cale> dleedev: It tries quite hard to not have too many prerequisites
22:21:19 <augur> dleedev: CT is quite a bit to chew on. its a whole field of mathematics!
22:21:38 <Cale> But yeah, this is a *huge* distraction if your main goal is to program in Haskell
22:21:39 <dleedev> augur: is it distinct from type theory?
22:21:42 <augur> that book, together with Awodey's oplss2012 lectures, are a reasonable place to start.
22:21:48 <augur> dleedev: sort of
22:21:55 <Cale> But it's a worthwhile distraction which is also a lot of fun :)
22:22:03 <djahandarie> shachaf, because I think he has it down pat. It's amusing to watch people do silly things.
22:22:28 <augur> type theory is the theory of syntactic objects involved in programming (programs, types, etc.), CT is the theory of the semantic objects involved in programming (the meanings of the programs, etc.)
22:22:34 <Cale> dleedev: It's distinct, but they share a relatively undefended border across which lots of trade occurs
22:22:51 <djahandarie> augur, what?
22:23:04 <dleedev> well, back to endofuctors... since I kind of understand what functors are (in haskell, at least)
22:23:09 <Cale> augur: Wow!
22:23:14 <augur> Cale: :)
22:23:22 <augur> well, wait no not :)
22:23:27 <augur> i didnt even say my controversial thing yet!
22:23:46 <djahandarie> That distinction makes absolutely zero sense to me.
22:23:49 <Cale> CT is the theory of the semantic objects involved in programming <-- ignores most examples of categories ever
22:24:02 <shachaf> djahandarie: This particular advice might be, but this explanation seems to me to be so "down pat" and rehearsed that it's completely ignoring its audience.
22:24:10 <dleedev> can you explain what endofunctors are to someone who understands functors, but not category theory?
22:24:14 <shachaf> It's frustrating to watch. I hope I'm just wrong.
22:24:15 <augur> Cale: pish, everyone knows that mathematics is just programming!
22:24:18 <augur>  /bobharper
22:24:33 <Cale> dleedev: You don't understand functors well enough yet :)
22:24:42 <Cale> dleedev: You might know what functors are about in Haskell
22:24:44 <Tekmo_> dleedev: Haskell functors are one example of an endofunctor, but not the only example
22:24:46 <augur> dleedev: its hard to explain because a) its a categorial concept, and b) haskell functors are all endofunctors anyway so we cant give examples
22:25:12 <dleedev> alas, I guess my curiosity won't be fulfilled today
22:25:27 <Cale> But all instances of the Functor typeclass in Haskell are functors from the category whose objects are Haskell types and whose arrows A -> B are Haskell functions A -> B, to itself.
22:25:29 <augur> djahandarie, Cale: obviously i mean the aspects of CT relevant to programming are about the semantics, whereas TT is about the syntactics.
22:25:34 <zRecursive> Then what's not endofunctors ?
22:25:34 <Cale> i.e. they're already endofunctors
22:26:01 <Cale> So, it's hard to compare them with examples of functors which aren't endofunctors, because you don't have the general definition of what a functor is yet :)
22:26:18 <augur> i mean, unless you're a proof-theory-semantics person (which i am), and then i'd say TT is about the semantics too, and CT is just a lie people tell themselves to feel like they're being objective
22:26:28 <Tekmo_> zRecursive: Functors can be morphisms, too, and an endofunctor is a functor that is a morphism that begins and ends on the same object.  A non-endofunctor is something that begins and ends on different objects
22:26:42 <Tekmo_> zRecursive: Haskell functors are endofunctors because they begin on a Haskell type and end on a Haskell type
22:26:47 <Tekmo_> zRecursive: f (a :: *) :: *
22:27:07 <Tekmo_> zRecursive: The functor `f` begins on a `*` and ends on a `*`
22:27:37 <Tekmo_> zRecursive: This requires imagining it as a "function from a Haskell type to another Haskell type"
22:27:39 <dleedev> Cale, augur, Tekmo_, thanks a bunch for all the help. I'll be back with more questions another day.
22:27:44 <Tekmo_> dleedev: You're welcome
22:27:47 <zRecursive> Tekmo_: then are there any non-endofactors in the world ?
22:27:55 <augur> dleedev: im always here, but im also always cynical :X
22:28:00 <Tekmo_> zRecursive: Yes
22:28:30 <Tekmo_> zRecursive: This example is a bit hard for me to explain, but one that comes to my mind is a functor between two different monoids (i.e. a monoid homomorphism)
22:28:47 <Tekmo_> zRecursive: For example, consider the `length` function
22:28:53 <Tekmo_> That's not the functor per se, but it's part of it
22:28:57 <Tekmo_> It bridges two monoids
22:29:05 <shachaf> newtype Fix f = Fix { runFix :: f (Fix f) } is a functor, I bet.
22:29:14 <Tekmo_> There's the monoid of lists, where: `mappend` = (++) and `mempty` = []
22:29:19 <Cale> zRecursive: Do you know much linear algebra at all?
22:29:26 <Tekmo_> ... then there's the monoid of addition, where `mappend` = (+) and `mempty` = 0
22:29:31 <zRecursive> Cale: yeah
22:29:38 <Tekmo_> zRecursive: You can think of `length` as an `fmap` of sorts
22:29:49 <Tekmo_> zRecursive: You know how `fmap id = id` and `fmap (f . g) = fmap f . fmap g`?
22:29:57 <Tekmo_> zRecursive: `length` has a similar property
22:30:15 <zRecursive> yeah
22:30:18 <Tekmo_> zRecursive: `length [] = 0` and `length (xs ++ ys) = length xs + length ys
22:30:34 <Tekmo_> zRecursive: So `length` is one component of a functor that is a morphism between two categories
22:30:43 * hackagebot x509-validation 1.4.8 - X.509 Certificate and CRL validation  http://hackage.haskell.org/package/x509-validation-1.4.8 (VincentHanquez)
22:30:44 <augur> Cale: im glad i got a wow out of you tho. that means i've internalized my harperisms adequately. :)
22:30:45 * hackagebot x509-util 1.4.3 - Utility for X509 certificate and chain  http://hackage.haskell.org/package/x509-util-1.4.3 (VincentHanquez)
22:30:48 <Tekmo_> The source category is the monoid of list concatenation (i.e. morphisms are lists and composition is concatenation)
22:30:58 <Cale> augur: hah
22:31:01 <Tekmo_> The destination category is the monoid of addition (i.e. morphisms are numbers and composition is addition)
22:31:17 <Tekmo_> zRecursive: and the functor between them is not an endofunctor because the source and destination category are different
22:31:22 <djahandarie> augur, I'd love an actual citation of Harper saying that.
22:31:28 <Cale> zRecursive: Okay, so, for each natural number n, there's a functor which sends each field F to the group of n by n invertible matrices over F
22:31:30 <djahandarie> Because it seems like total crap to me.
22:31:42 <Cale> zRecursive: (a.k.a. GL_n(F))
22:31:46 <augur> Cale: also, laziness is stupid, IO shouldnt be forced into monads, and haskell modules suck
22:31:48 <augur> ;D
22:32:11 <augur> djahandarie: he didnt say that, he joked about mathematics being "just programming" in his oplss2012 class
22:32:13 <Tekmo_> Cale: See, when I learned programming I had no clue what a `field` was
22:32:14 <zRecursive> set theory ?
22:32:50 <Cale> zRecursive: So, I asked if you know much linear algebra, but I probably could have asked what you know about fields and groups too :)
22:33:02 <Cale> (you don't need too much beyond the definition)
22:33:09 <augur> djahandarie: just because noone realized they were doing programming doesnt mean its not programming! x3
22:33:16 <zRecursive> In fact i am not veery clear about the difference between CT and ST ?
22:33:22 <djahandarie> augur, that's hardly controversial, if you're talking about constructive mathematics. I do not think that is what Cale was wowing at, and it's certainly not what I was 'what?'ing at.
22:33:23 <Tekmo_> ST = ?
22:33:33 <zRecursive> set theory
22:33:47 <Cale> djahandarie: I was wowing at the remark that CT is about programming language semantics
22:33:52 <augur> djahandarie: i know what cale was wowing at and i think i clarified what i said enough for it to be not absurd
22:33:56 <tautologico> set theory is about sets, CT is about categories :)
22:34:05 <Tekmo_> My limited understanding is that category theory is advertised as an alternative foundation of mathematics to replace set theory
22:34:18 <Cale> Tekmo_: That's a misunderstanding
22:34:21 <Cale> It's not.
22:34:22 <Tekmo_> Darn :(
22:34:23 <augur> but incase it wasnt clear, djahandarie: what i meant was, the CT-for-programming is about semantics, while TT is about syntactics
22:34:30 <augur> roughly speaking
22:34:30 <Tekmo_> Then I was wrong
22:34:42 <Cale> Tekmo_: Well... you can do things like that, *sort of*
22:34:46 <augur> tautologico: :X
22:34:51 <zRecursive> set != category  ?
22:34:58 <tautologico> zRecursive: yes
22:35:15 <augur> Cale: i've heard it described like that tho
22:35:22 <augur> or described with that as a hope
22:35:24 <shachaf> ETCS is advertised as an alternative to ZFC, and happens to be defined with a category.
22:35:35 <augur> what is ETCS?
22:35:44 <Cale> Elementary Theory of the Category of Sets
22:35:51 <augur> ahh ok
22:35:57 <Cale> It's a first order theory of the way that the category of sets works.
22:36:15 <Cale> where you formulate "is a commutative triangle" as one of your primitive relation symbols
22:36:25 <augur> interesting
22:37:19 <augur> "A broccoli B" is true iff "A" is true broccoli "B" is true
22:38:19 <Cale> Whenever these proof theory guys annotate everything with "is true" I get exactly the same feeling as when I see someone writing  if foo then True else False
22:38:31 <augur> why?
22:38:40 <augur> well let me first ask
22:38:42 <augur> in what context?
22:38:52 <Cale> I understand why they write it
22:39:06 <Cale> It just goes in the face of the language I'm used to
22:39:14 <augur> aha
22:39:39 <augur> well in the judgmental context, its absolutely imperative to use it, or keep in mind that youve got it there secretly
22:40:01 <augur> just because the distinction between judgments is important
22:40:17 <Tekmo_> ((A is true) is true) is true
22:40:36 <augur> Tekmo_: in a judgmental framework, that wouldnt even be something you could say. :)
22:40:37 <Gracenotes> something like brackets (a la semantics) might be nice
22:40:46 <augur> Gracenotes: ?
22:41:21 <Gracenotes> like [[x + y]] = [[x]] + [[y]]. punctuation notation is best notation.
22:41:32 <Tekmo_> augur: So it would not "type-check"?
22:41:48 <Cale> [[bracketing intensifies]]
22:41:51 <augur> Tekmo_: i think it'd be more accurate to say it wouldnt even parse
22:41:56 <augur> Gracenotes: scott brackets for what?
22:42:27 <augur> (they're called scott brackets, btw, after their inventor, dana scott, who's totally cool)
22:42:49 <Cale> augur: Well, maybe it would parse and typecheck, in a meta-meta-meta-theory
22:42:53 <guardianx> when people say "if it is true that...., then....", that's wrong! they should say "if....then..."
22:42:58 <Gracenotes> for "is true"ifing an expression. cuz why not. although, I thought oxford brackets preceded that as name.
22:43:09 <augur> Cale: yeah it really depends on how far you want to push things
22:43:35 <augur> Gracenotes: well, why not is its redundant. every proposition would be in quotes all the time!
22:43:45 <augur> Gracenotes: at least in the judgmental framework
22:44:04 <augur> in the model theoretic framework you usually find props in quotes or whatever anyway
22:44:20 <Cale> The idea is that A is some statement inside a language that we're discussing, and "A is true" is a judgment we're making about that statement outside of that language.
22:44:28 <augur> right
22:44:45 <augur> in the same way that "A is a proposition" is another judgment outside of that language
22:44:55 <augur> or "A might be true" or "A is true at time t" or ...
22:45:41 <augur> the idea being that these judgments are epistemic nuggets. they're things we humans care about and are interested in as thinkers
22:46:49 <augur> and we do more than just care about "truth", whatever that is -- we care about lots of things. truth, falsity, wellformedness, validity, possibility, necessity, etc etc etc
22:47:41 <Cale> With my mathematician hat on, I don't even care about this sort of judgmental truth though.
22:47:57 <augur> the judgmental perspective is really useful for doing TT -- a whole slew of wonderful computational things just fall out of reasonably well-understood judgments
22:48:06 <augur> Cale: oh? :D
22:48:21 <Cale> augur: Yeah, because it's a notion of truth outside of the system I'm working in.
22:48:44 <augur> im not sure i follow
22:49:19 <Cale> If A is a statement of ZFC, I might be able to prove it in ZFC, and yet some external judgment about it might still be "A is false"
22:49:34 <Cale> I don't care about that!
22:49:50 <augur> im still not following
22:50:40 <Cale> I only care about which statements are theorems of ZFC when I'm working in ZFC. Not whether they're externally true or false.
22:50:52 <augur> "externally"?
22:51:57 <mauke> [[is true internally]]
22:52:44 <augur> Cale: do you mean "relative to some model" or "in some non-ZFC, purer sense" or whatever? ie, outside of merely "following from the axioms"?
22:53:02 <Cale> Yeah, that's how I'm reading "A is true" here.
22:53:23 <augur> ok. thats not what it means in the judgmental framework, but it's definitely what is meant in model theory
22:53:26 <Cale> Truth in that sense is truth outside of ZFC itself, in some ambient system we're using to study ZFC.
22:53:55 <Tekmo_> So this is out of my league, but I'll go ahead and make an uninformed comment anyway
22:53:57 <Cale> (Otherwise, why even bother with the distinction?)
22:54:03 <Tekmo_> This reminds me a bit about reasoning about side effects
22:54:05 <augur> in the judgmental framework, the judgment "A true" is what you're after
22:54:15 <Tekmo_> I prefer to reason about side effects within the language as values rather than outside of the language
22:54:33 <augur> Tekmo_: fun fact, there's a judgment for that :D
22:54:46 <augur> `A lax` is the judgment for effects!
22:54:57 <augur>  /monads
22:55:09 <jle`> hm. so this monad i am using offers no transformer version.  is there any way i can still use reader-like functionality?  can i make it *return*/contain a Reader and do something from that?
22:55:16 * JuanDaugherty didn't know till fairly recently that there was a mathematical thing called a judgment
22:55:33 <Cale> When I have my mathematician's hat on, I don't really care about any external judgments about the statements of my formal system, apart perhaps from "A is provable in system X"
22:55:43 <Tekmo_> jle`: You mean use something `Reader`-like to cheat and convert a monad to an equivalent monad transformer?
22:55:48 <augur> Cale: thats what `A true` means tho
22:55:59 <Cale> augur: Usually not?
22:56:05 <jle`> Tekmo_: yes
22:56:06 <augur> Cale: in the judgmental framework it is
22:56:13 <augur> Cale: in the model theoretic framework its not
22:56:21 <jle`> i guess i could do my entire reader-logic my final return at the end, return $ do ...
22:56:29 <JuanDaugherty> where does Tarski fit in this?
22:56:38 <jle`> but i'd like to be able to mix reader stuff and the stuff for the rest of the monad
22:56:43 <augur> JuanDaugherty: tarski was the first modern model theorist
22:56:58 <augur> one might even say he invented model theory as we know it today!
22:57:05 <augur> tho one might be wrong about that, i dont know :X
22:57:09 <JuanDaugherty> so McLane was just a johnny come lately
22:57:10 <Cale> augur: In that case, I don't see the point. The system already exists and has its own rules for deriving new statements from old.
22:57:29 <augur> Cale: when your only judgment is true, then it's often pointless, which is why usually the judgment is surpressed
22:57:35 <Tekmo_> jle`: Well, you can cheat in another way
22:57:46 <Tekmo_> jle`: You can indirectly encode it using `FreeT`
22:58:10 <augur> Cale: when your judgments are more diverse, tho, it's relevant
22:58:32 <jle`> Tekmo_: oh that's cool.
22:59:55 <Cale> augur: (Which of course there aren't because we internalise all of those ;)
23:00:12 <jle`> Tekmo_: you mean like this? http://hackage.haskell.org/package/pipes-2.1.0/docs/Control-Monad-Trans-Free.html
23:00:21 <Tekmo_> There's one in the `free` package
23:00:31 <Tekmo_> That's the official one
23:00:37 <augur> Cale: well, it depends. not all judgments are internalized, and often, internalized versions arent sufficient
23:01:13 <augur> Cale: tho you often want to be able to internalize your flavors of truth, that's certainly true
23:02:19 <augur> Cale: the judgmental framework gives a very nice way to deal with this stuff tho, to make sure that your theory is sensible, etc.
23:02:25 <Cale> Yeah
23:02:51 <augur> but it also sort of tends to push deeper than most mathematicians want
23:03:14 <augur> mathematicians want to say not merely "A follows from the axioms"
23:03:16 <JuanDaugherty> *MacLane
23:03:18 <augur> they want to follow that up with
23:03:38 <augur> "and classical reasoning is totally obviously true and i dont need to think about that stuff lalalala"
23:03:40 <jle`> Tekmo_: thanks
23:03:47 <Tekmo_> jle`: You're welcome
23:03:49 <jle`> i guess it's finally time to dive into that rabbit hole
23:03:56 <jle`> of free monads and free monad transformers
23:03:58 <Tekmo_> jle`: Are you familiar with how to encode something using `FreeT`?
23:04:10 <Tekmo_> I have a short article on this that I wrote that you might find useful
23:04:13 <jle`> no, but i have some familiar with normal free monads
23:04:18 <jle`> ah, i would appreciate it :)
23:04:21 <Tekmo_> jle`: http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
23:04:27 <Tekmo_> jle`: That's using ordinary free monads
23:04:30 <Cale> Well, we'll just go ahead and build any of these things in terms of sets. If you can formulate rules in your judgmental framework for describing when some conditions hold, I can build sets whose behaviour models that of the judgments.
23:04:43 <Tekmo_> jle`: I have another post where I first introduced `FreeT`.  One second
23:04:49 <jle`> Tekmo_: are you mr. gonzalez?
23:04:58 <Tekmo_> jle`: http://www.haskellforall.com/2012/07/free-monad-transformers.html
23:04:59 <Tekmo_> jle`: Yeah
23:05:10 <jle`> Tekmo_: i appreciate your work :)
23:05:14 <Tekmo_> Thanks! :)
23:05:25 <Tekmo_> Basically, anything you can do with `Free` you can do with `FreeT`, too
23:05:47 <Tekmo_> jle`: The only difference is that you have to use `runFreeT` to bind the result before pattern matching on `Pure`/`Free`
23:05:57 <augur> Cale: yes you can
23:06:05 <jle`> thanks, i shall have some reading to do
23:06:12 <Cale> But I guess a lot of those the things which arise naturally that way turn out to be weird from a mathematical perspective, or maybe not directly applicable to the sorts of things that algebraists and analysts work on.
23:06:23 <augur> Cale: but the ultimate crux of this is that you still are assuming a logic and a conception of meaning
23:06:30 <augur> you're just not expressing those assumptions
23:07:01 <augur> Cale: i mean, you say for instance that you want `A is true` to mean nothing more than `A follows form ZFC` but how do you know it follows from ZFC?
23:07:08 <augur> well presumably you're doing some inferences
23:07:17 <augur> but whoever said those inferences make sense in the first place?
23:07:23 <augur> what do they even mean?
23:07:28 <augur> what do these axioms mean?
23:07:29 <Cale> I don't care if they make sense if they follow the rules
23:07:36 <Tekmo_> jle`: You're welcome
23:07:36 <augur> what rules tho?
23:07:37 <augur> thats the point
23:07:43 <Cale> The rules we decided on. :)
23:07:45 <Cale> already
23:07:51 <augur> which were those?
23:07:52 <Tekmo_> jle`: Just keep in mind that `transformers-free` from that post is obsolete.  It got merged into `free`
23:08:01 <augur> classical logic, of course.
23:08:20 <Cale> The rules of first order logic with one relation symbol and a handful of axioms and a pair of axiom schemas
23:08:33 <augur> i never decided on FOL!
23:08:35 <augur> :)
23:09:11 <Cale> Classical mathematicians don't care terribly much about whether the rules of FOL make sense, because regardless of whether they make sense, we're used to them.
23:09:22 <augur> i know
23:09:27 <Cale> Similarly for the axioms of set theory. They're defining a game that we're playing :)
23:09:34 <augur> im just playing devils advocate
23:09:45 <nisstyre> Cale: so in your view, 0,1,2... is just any progression that satisfies a bunch of axioms that apply to natural numbers, right?
23:09:51 <nisstyre> or is that a misrepresentation?
23:09:57 <Cale> nisstyre: yeah, more or less
23:10:20 <nisstyre> Cale: interesting, I'm reading Principles of Mathematics by Russell and he attacks that view in the first few pages :P
23:10:24 <augur> Cale: the crux of the whole judgmental framework is the very question of what any of that is supposed to mean in the first place
23:10:31 <nisstyre> because he thinks there should be something about actual numbers in there
23:10:50 <mauke> "actual numbers"
23:10:51 <augur> Cale: because you can invent any number of formal systems, and indeed many have been invented
23:10:52 <nisstyre> I don't know if there should be
23:10:59 <nisstyre> mauke: actual instances of numbers rather
23:11:06 <nisstyre> like "three geese"
23:11:18 <mauke> goose isn't a well defined concept
23:11:22 <augur> FOL as we know it didnt really "emerge" until probably after russell
23:11:40 <augur> or somewhere when they abandoned iotas maybe
23:11:50 <Cale> nisstyre: The notion that there are "actual" Platonic things that mathematics is supposed to "approximate" by careful choice of its axioms is something that has been dying a slow and painful death ever since the work of Gödel and others around the early 1900's
23:12:20 <nisstyre> Cale: yeah, it's more interesting if you want to know about how stuff developed
23:12:46 <Cale> (Interestingly, Gödel originally thought that there should be a complete and consistent theory of arithmetic)
23:13:23 <nisstyre> PoM was written prior to PM was finished, so obviously before it was shown incomplete
23:13:32 <nisstyre> *prior to when
23:13:47 <nisstyre> although the foreward was written long after I think
23:14:45 <Cale> augur: But I do see proof theory as a good framework in which to invent new games to play :)
23:15:00 <augur> Cale: its not about inventing new games per se
23:15:15 <augur> its about shortcircuiting pointless debates
23:15:17 <augur> imo anyway
23:15:29 <augur> i mean, i dont see the point of ZFC, for instance
23:15:46 <augur> you want foundations for arithmetic, i get that
23:15:55 <JuanDaugherty> for what purpose, mathematics or life?
23:16:05 <augur> ok, here's your foundation for arithmetic: data Nat = Zero | Suc Nat
23:16:26 <Cale> augur: Its point is mostly as a common backbone sort of language we can descend to for clarification.
23:16:42 <Tekmo_> So is the purpose of mathematics to be a language for communication or to gamify some practical concern?
23:16:52 <augur> Cale: well, historically thats not why it came about
23:17:12 <JuanDaugherty> gamify. In the wittgenstein sense.
23:17:14 <Cale> It's not ideal for its job, but there's such a large body of work which has been checked with respect to it, that any concerns about adjusting the foundational framework tend to be trumped by the fact that there are so many libraries available ;)
23:17:16 <augur> historically it came about because frege really wanted numbers to be derivable from logic
23:17:29 <augur> and his view of logic was derived somehow from sets
23:17:39 <Cale> Oh, sure
23:17:45 <augur> and that went wrong but people didnt want to give up on sets even tho it became very clear that they were a mess
23:17:56 <Cale> Well, and sets turned out to be pretty nicely usable building blocks.
23:17:59 <JuanDaugherty> because in life truth is just a simple concept exemplified by it's instances/uses
23:18:11 <augur> "nicely"
23:18:15 <Cale> Again, not perfect, but sufficiently usable
23:18:16 <augur> for some notion of nicely
23:18:27 <mauke> "A is nice"
23:18:31 <augur> and for some notion of "sufficiently usable" :p
23:18:37 <augur> mauke knows what's up
23:18:59 <Cale> (obviously I don't mean anything formalisable by that)
23:19:08 <augur> but frege and russell were genuinely interested in the question "what is a number?"
23:19:22 <augur> they werent doing this set stuff for funzies
23:19:25 <Cale> Yep, because they were at the end of that lineage of people who cared
23:19:29 <shachaf> what about foundations in terms of chu spaces?? like, whoa
23:19:39 <augur> they were doing it because they really thought it was important to figure out what the hell a number was
23:19:52 <JuanDaugherty> s/exemplified/abstracted/
23:19:58 <augur> and somehow people latched on to their set-ly ideas and it got stuck
23:20:48 <augur> somehow foundational work drifted away from that question, and took it for granted that the answer was "lets just code it as sets. i dont know. what?"
23:21:03 <Cale> While set theory might not have been the best possible foundation, the fact that it provided *a* foundation meant that questions about what a number "really was" dissolved, because you could define all different sorts of notions of number in terms of sets, and both talk about them independently and relate them to one another.
23:21:10 <augur> when i feel really the answer shouldve been "lets not code it, lets just think about it"
23:21:13 <Cale> It no longer mattered what numbers "really" were
23:21:35 <augur> sure, but people still insisted on coding things
23:21:39 <nisstyre> augur: well Frege and Russell were philosophers first and mathematicians second
23:21:51 <augur> nisstyre: yes, i agree
23:21:55 <Cale> Well, the coding is just to make certain that everything will work together.
23:22:00 <nisstyre> so it's not unreasonably for them to have not come up with anything perfect or usable
23:22:02 <augur> arguably most foundational work is philosophy
23:22:04 <nisstyre> *unreasonable
23:22:04 <JuanDaugherty> not Frege, Russell yeah
23:22:23 <nisstyre> I've seen Frege called an analytic philosopher
23:22:32 <nisstyre> it might depend on who you ask though
23:22:36 <Cale> If these things are all defined as sets, then we can start to talk about various sorts of functions between those sets.
23:22:38 <augur> Cale: yeah but i mean, i think we have a better approach now to that whole business
23:22:47 <Cale> Possibly!
23:22:58 <augur> Cale: i mean, i think we couldve had it then too
23:23:14 <augur> Cale:  i mean, "make certain everything will work together" is a noble goal
23:23:18 <augur> bt its an illusion
23:23:34 <augur> we already have in mind a view of what counts as a right answer
23:23:35 <nisstyre> there's an interesting paper on Russell's math education at Cambridge, and all of the geometry and calculus stuff he had to go through
23:23:41 <Cale> But you'll be fighting an uphill battle, because foundations *are* largely considered a distraction for most mathematicians, and most mathematicians have at least a passing familiarity with ZFC.
23:23:55 <augur> thats why we can stand back and judge whether or not an encoding via sets is a good encoding or not
23:24:01 <maxiepoo> where on earth did this conversation come from
23:24:01 <Cale> But I agree, I think there are some systems showing up now that might have real serious benefits
23:24:17 <augur> if i just say, here's how i define numbers: ~~~~~ and all it does is make up some nonsense that has nothing to do with numbers
23:24:21 <Cale> (Specifically, I have high hopes for HoTT)
23:24:25 <augur> youre going to say those arent numbers
23:24:29 <augur> thats something else but they're not numbers
23:24:41 <Cale> augur: I honestly won't care.
23:24:50 * JuanDaugherty hands a maxiepoo a special magic topic whistle
23:24:51 <Cale> augur: Number isn't even a technical term
23:25:06 <Cale> So you can call whatever you want numbers, and in context, I'll accept it.
23:25:14 <augur> Cale: no? ok, i propose a new foundation for you: no axioms.
23:25:16 <augur> go forth and do math
23:25:38 <augur> the whole point is that you said "in context"
23:25:40 <augur> well yeah, in context
23:25:59 <augur> well if the context is arithmetic or whatever, you dont just want any collection of axioms
23:26:09 <augur> nor just any collection of consistent axioms
23:26:30 * JuanDaugherty is reminded of sitcalc
23:26:33 <augur> you want something that has something to say about arithmetic because youve got a sense of what arithmetic is all about ahead of time
23:26:38 <Cale> augur: So, if you say "here's what real numbers are" and write down a bunch of axioms which don't agree in any way with the ordinary notion of real numbers, I will say "you're making unhelpful choices of terminology"
23:26:47 <augur> Cale: yes!
23:27:01 <Cale> But that's just name shadowing issues
23:27:18 <augur> Cale: so why not avoid that as a possibility, and just __write down the ordinary notion of real numbers__
23:27:25 <Cale> huh?
23:27:33 <Cale> Because there's more than one?
23:27:35 <Cale> :)
23:27:40 <nisstyre> augur: it depends whether you're doing philosophy or math
23:27:40 <augur> ahh well, write them all down :)
23:27:50 <nisstyre> you can do both I guess
23:28:00 <augur> Cale: thats why i said data Nat = Zero | Suc Nat was a foundation tho
23:28:02 <nisstyre> just be clear about which is which
23:28:05 <Cale> Okay, I think I've lost the thread of the point you're trying to make
23:28:34 <Cale> augur: That also isn't on its own a foundation for natural numbers, because you need to pose a bunch of other things
23:28:34 <shachaf> There was a point?
23:28:46 <maxiepoo> shachaf: +1
23:28:47 <nisstyre> we teach kids about both but it's never made really clear that they aren't the same thing, though I don't know if most kids would care :P
23:28:51 <Cale> augur: If you want to make universal statements about naturals
23:28:56 <augur> Cale: the point i was trying to make was that grounding stuff in sets is a roundabout way of doing foundational work. you have to start out with an idea rattling around in your head to begin with, before you can decide if your encoding makes sense
23:29:05 <shachaf> hi maxiepoo
23:29:09 <Cale> augur: for sure
23:29:10 <maxiepoo> hey man
23:29:10 <augur> and it seems more reasonable to just put that idea down on paper, rather than trying to encode it
23:29:14 <shachaf> I remember you from seahug.
23:29:20 <augur> and i think thats more what the proof-y view is about
23:29:21 <maxiepoo> yea!
23:29:36 <maxiepoo> that was a cool meetup
23:29:40 <Cale> augur: Encoding it serves one main purpose: making sure that it will work together in some fashion with all the other work people have done in this system
23:29:44 <shachaf> I had no idea what I was talking about back then!
23:29:53 <maxiepoo> really?
23:29:58 <maxiepoo> it didn't seem that way
23:30:00 <shachaf> I don't think I said anything wrong exactly.
23:30:35 <augur> Cale: yes thats true
23:30:59 <augur> Cale: except, "this system" is ZFC
23:31:03 <Cale> yep!
23:31:24 <augur> and the work done in ZFC came after someone made the decision that encoding was the way to go
23:31:29 <shachaf> But for example the idea of limit and adjunction are very related and I didn't really know anything about that.
23:31:35 <Cale> augur: Largely mathematicians ignore their own encodings once they've got them figured out, and build higher level ways to talk about everything pretty quickly.
23:31:35 <augur> so the mistake was made before that justification existed!
23:31:52 <nisstyre> augur: this reminds me of why surreal numbers are so cool, because you can deduce a whole bunch of stuff about different types of numbers with just a few axioms
23:31:54 <Cale> augur: Maybe it was foresight!
23:32:04 <augur> Cale: yes i know. real mathematicians just bypass foundations
23:32:57 <maxiepoo> shachaf: interesting. I remember being really impressed by how well you explained things
23:33:23 <augur> but this again is why i prefer the judgmental view, because it gives a nice perspective on how to _do_ this stuff without getting bogged down in encoding things
23:33:31 <maxiepoo> usually explaining category theory stuff doesn't go too well
23:33:55 <Cale> augur: I'm not sure I believe in it that much :)
23:34:01 <shachaf> Well then, I'll take credit for that.
23:34:27 <shachaf> maxiepoo: You might enjoy the Catsters videos, since I probably stole a lot from them.
23:34:30 <shachaf> @where catsters
23:34:30 <lambdabot> http://www.youtube.com/user/TheCatsters
23:34:34 <lispy> Cale: re: ignoring their own encodings, programmers do that too
23:34:39 <maxiepoo> yeah I've heard of it
23:34:41 <augur> Cale: why not? :p
23:34:42 <Cale> lispy: For sure!
23:34:55 <maxiepoo> I've started working through "Categories for Computing Science" with a math friend
23:34:55 <augur> maxiepoo: there's also awodey's videos
23:34:58 <augur> @where oplss2012
23:34:58 <lambdabot> https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
23:34:59 <Cale> augur: Well, I don't know, probably just because I've never seen anything nontrivial done with it directly.
23:35:25 <augur> catsters isnt good for basic intro stuff
23:35:36 <augur> but once you know the basics catsters is AMAZING
23:35:59 <augur> Cale: you know all that stuff we call functional programming? :X
23:36:21 <lispy> Cale: someone I know is bothered by CT because it never defines equality, but seems to care a lot about it.
23:36:35 <nisstyre> oh, by the way, is there a good intro to uniqueness type systems? Other than ATTAPL?
23:36:35 <lispy> Cale: he says, CT only makes sense relative to some notion of equality
23:36:47 <augur> lispy: who says that?
23:36:53 <augur> oh someone you know
23:36:56 <shachaf> maxiepoo: That's Barr and Wells?
23:37:00 <augur> i think i agree with that
23:37:10 <maxiepoo> yea
23:37:13 <Cale> lispy: CT is not intended as a foundations of mathematics.
23:37:32 <Cale> lispy: You *do* need a notion of equality, and it's probably the notion that first order logic gives you
23:37:34 <augur> equality in CT is, you know, equality!
23:37:54 <augur> equal, man. on the nose, exactly the same, precisely the very same exact thing man
23:38:00 <augur> except when its not cause that would be evil
23:38:20 <lispy> Cale: to be fair, I'm not sure what equality means in a foundational sense in say high school algebra. I just know same things are the same.
23:38:21 <nisstyre> I guess I could try to find papers on Clean's implementation...
23:38:44 <Cale> But yeah, category theory, and especially higher category theory is *all about* approaching the question of avoiding specific notions of equality on the nose.
23:38:56 <Cale> and instead talking about equivalence up to some higher-dimensional relationships
23:39:00 <augur> lispy: the notion of identity is not a well understood one
23:39:24 <Cale> lispy: But you need to start somewhere.
23:39:25 <augur> you can either choose to pretend like you have omnipotent capacity to know when things are The Same Thing
23:39:32 <augur> or you can become a philosopher
23:39:57 <Cale> lispy: It's pretty tough to say, okay guys, so, infinity categories. Yeah.
23:40:12 <augur> Cale: forget infinity categories
23:40:13 <lispy> augur: I kind of like agda's notion of propositional equality.
23:40:25 <augur> how do i know if an apple is the same man
23:40:31 <augur> what does that even meeeaaan
23:40:46 <augur> lispy: propositional equality in agda depends on syntactic equality
23:41:14 <augur> but not quite syntactic equality, because its equality modulo beta and eta
23:41:20 <augur> and alpha
23:41:30 <lispy> exactly, you can normalize terms
23:41:50 <Cale> augur: well, two apples are the same when there's a pair of 1-apples between them such that the composites in either direction have a 2-apple to the identity, and those 2-apples are equipped with some 3-apples which...
23:41:53 <augur> but then we're talking about symbols in a computer -- or worse, bits in memory! -- not actual numbers and whatever
23:42:08 <augur> and who cares if two bit strings are the same thats boring yawn
23:42:17 <augur> Cale: x3
23:42:19 <augur> broccoli!
23:43:11 <dhrosa> what's the kosher way of describing a cabal project with multiple executables?
23:43:41 <Cale> dhrosa: You can just have multiple executable sections, can't you?
23:43:42 <augur> dhrosa: up to isomorphism
23:43:50 <dhrosa> wait nevermind, I failed at googling
23:44:01 <augur> google is isomorphi
23:44:02 <augur> c
23:44:14 <Cale> Guys, I think augur is broken.
23:44:19 <augur> :)
23:44:51 <scshunt> conjecture: all mathematicians are isomporphic. discuss amongst yourself.
23:44:51 <augur> i would explain my jokes but then they'd stop being funny
23:44:57 <augur> so i shall explain them:
23:45:16 * lispy pulls up a chair
23:45:27 <augur> broccoli, referencing girard's comments on disquotational meaning explanations `"A brocolli B" is true if and only if "A" is true brocolli B" is true.
23:46:06 <augur> what those comments are, i dont know, since they apparently show up in locus solum and i dont have enough drugs yet to understand it
23:46:07 <lispy> I'm having trouble parsing that
23:46:24 <augur> lispy: "broccoli" is supposed to be a logical operator of some sort
23:46:32 <augur> often you find in model theory statements like
23:46:42 <augur> "A and B" is true iff "A" is true and "B" is true
23:47:11 <augur> which explains nothing because you have to already know what "and" means and then you're no closer to understand what the thing means
23:47:18 <nisstyre> augur: can you explain what this article is talking about? https://en.wikipedia.org/wiki/Ludics
23:47:28 <augur> replace "and" with something you dont understand, e.g. "broccoli" and you no longer understand it
23:47:30 <lispy> ah, so you meant "A brocolli B" is true iff "A" is true and "brocolli B" is true?
23:47:37 <augur> lispy: no no
23:47:49 <augur> "A broccoli B" is true iff "A" is true, broccoli "B" is true
23:48:04 <augur> nisstyre: ludics is the subject of locus solum
23:48:14 <augur> i dont understand ludics.
23:48:19 <nisstyre> ok
23:48:25 <augur> i think it has something to do with mustard watches
23:48:50 <Cale> augur: As far as I can tell, Locus Solum is a gigantic, masterfully executed joke. But it's hard to be 100% sure.
23:49:15 <augur> Cale: i said to zeilberger on twitter, i cant tell with girard whats serious or not
23:49:23 <augur> http://iml.univ-mrs.fr/~girard/mustard/article.html
23:49:24 <Cale> It *has* to be a joke though, right?
23:49:30 <augur> Cale: i think i get the point of it
23:49:39 <augur> like, what ludics is kind of supposed to be about
23:49:40 <Cale> (http://iml.univ-mrs.fr/~girard/0.pdf for anyone who wants to have a look)
23:49:54 <augur> ive seen some explanations that make it clearer, for whatever thats worth
23:50:11 <augur> and it looks like its sensible, but my god is that paper just incomprehensible
23:50:29 <augur> its an art piece as much as it is a paper on logic. its very post-modern
23:51:41 <Cale> It's like the formal logic version of "The Age of Wire and String"
23:51:55 <augur> i actually understand the philosophy of that paper more than i understand the logic of it, Cale
23:52:06 <nisstyre> augur: that mustard watches paper is pretty awesome
23:52:32 <Cale> http://webdelsol.com/marcus/acct.htm (an excerpt from the book I just referenced)
23:53:28 <augur> Cale: like, this makes sense to me: "Moreover the logic-we-used-to-know-and-love is still present, but it now gets a specific name, /spiritual logic/: ludics created spiritual logic in the same way Brouwer created classical logic and Luther catholicism."
23:53:43 <augur> its also eminently postmodernist
23:55:51 <Cale> It's like some kind of dream in which things locally are organised in a structurally familiar way, but globally, it just goes from one thing to the next in a way which seems not to have any reason.
23:55:54 * hackagebot hakyll-elm 0.2 - Hakyll wrapper for the Elm compiler.  http://hackage.haskell.org/package/hakyll-elm-0.2 (maxiepoo)
23:56:13 <augur> Cale: yep. hence the need for lots of drugs, i think
23:56:19 <Cale> http://webdelsol.com/marcus/gods.htm
23:56:24 <JuanDaugherty> lol
23:56:27 <augur> i wouldnt be surprised if he was on acid when he wrote it, tbh
23:57:19 <JuanDaugherty> yeah I'm guessin' Girard Ludics are liek ur gamified judgements
23:57:23 <augur> ive know people like that, people who write these things that are just so whacked out, and you're not sure if they're nuts or not
23:57:43 <augur> and they're often serious stoners and trippers
23:57:46 <nisstyre> augur: it's pretty clear he's a genius though
23:57:50 <augur> nisstyre: oh undeniably
23:58:02 <augur> but then, many geniuses were serious stoners and trippers :)
23:58:30 <nisstyre> augur: yeah, because with certain drugs you can more easily see patterns
23:58:30 <Cale> nisstyre: Well, he's done enough other things which make actual sense that he has nothing left to prove
23:58:36 <augur> nisstyre: exactly
23:58:41 <nisstyre> but you run the risk of seeing patterns that aren't there or are crazy
23:58:59 <augur> echochambers are like this too
23:59:25 <JuanDaugherty> an thin Ron Howard makes a movie about ur ass
23:59:26 <Cale> So, if he wants, he can troll everyone with utter nonsense, and people will actually try to make sense of it because he's who he is.
23:59:30 <augur> like, im trying to grok zeilberger's polarity stuff, but the community he's talking to is so small that when he tries to write for outside of it, it's just impossible
