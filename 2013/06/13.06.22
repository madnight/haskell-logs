00:00:00 <Lethalman> no I didn't explain myself probably
00:00:15 <Lethalman> carter, how many gui applications are you using that are written in haskell?
00:00:50 <carter> my brain counts  as 20
00:01:00 <carter> its gooey
00:01:08 <carter> sometimes it applies itself
00:01:20 <carter> well, i played a game lispy wrote earlier
00:01:53 <carter> Lethalman i'm also mentoring a GSOC project that will hopefully yield nice QT bindings + a generic C++ ffi wrapper
00:01:56 <Lethalman> carter, really? where are those 20 applications? can you link?
00:02:07 <carter> my brain is gooey :P
00:02:24 <carter> though if i had a linux tablet, i'd totally use HOODLE
00:02:29 <carter> which is really cool
00:02:37 <carter> http://ianwookim.org/hoodle/
00:02:42 <Lethalman> :(
00:03:00 <carter> Lethalman did you not read the part about having nice QT bindings?
00:03:07 <carter> and HOODLE being cool?
00:03:23 <carter> also really relaly good gui applications take a lot of time
00:03:33 <carter> and we dont' have a good gui toolkit story yet
00:03:41 <carter> hoodle's magic to the contrary
00:04:18 <dmj> carter: a way to make cocoa gui's quickly would be cool, but isn't the HOC project dead?
00:04:35 <dmj> haskell to objective-c
00:04:38 <carter> dmj theres some cool stuff  to make that EASY landing in 7.8
00:04:44 <carter> google "inline objective C"
00:05:12 <carter> should be in nice shape for OS X fall, maybe also in the cross compiler for ios too
00:05:36 * carter looks around how come i'm the only one answering things?! i'm terrible at it 
00:05:47 <carter> https://github.com/mchakravarty/language-c-inline
00:05:53 <carter> its not usable yet
00:05:58 <carter> and most of the work isn't online
00:05:59 <carter> i think
00:06:02 <olalonde> is haskell a silver bullet?
00:06:15 <carter> for null pointer errors? yes
00:06:19 <dmj> :)
00:06:36 <carter> well, if i deliberately use pointers i could totally do that, but yets
00:06:48 <carter> olalonde whats the werewolf of software engineering you wish to kill?
00:07:13 <carter> warning: its 3am here, so i should start wandering off soon
00:07:25 <carter> blackdog hoss things?
00:07:27 <carter> *how's
00:07:49 <olalonde> :D just trolling
00:08:05 <carter> olalonde go back under your bridge
00:08:08 <carter> :p
00:08:09 <olalonde> haha
00:08:24 <carter> its probably a landmark bridge too, with stone and stuff
00:08:31 <Ralith> haskell is an antimatter bullet!
00:08:34 <Ralith> Good for killing small moons.
00:08:55 <carter> YESS
00:08:59 <carter> and your face
00:09:13 <carter> doesn't matter
00:09:23 <carter> gamma on!
00:09:33 <carter> Ralith sorry, that sort of bursted out
00:09:49 <carter> i get good at free associative puns at this hour
00:10:09 <carter> and I shoudln't finish writing that Cabal ticket write now
00:10:12 <carter> *right
00:10:13 <Ralith> no, no, I'm pretty sure an antimatter detonation would take out any faces in the general area quite tidily
00:10:21 <carter> gamma on
00:10:27 <carter> punon game on
00:10:35 <Ralith> oh
00:10:40 <carter> because anitmatter triggers a gamma ray burst
00:10:41 <Ralith> that seemed far too legitimate a pun to apologize for
00:10:52 <carter> but I had to explain it
00:10:58 <Ralith> well yes now it's ruined
00:11:00 <carter> http://en.wikipedia.org/wiki/Antimatter
00:11:02 <Ralith> look what you did!
00:11:03 <Ralith> >:|
00:11:07 <olalonde> can haskell kill the homeless monad sleeping on my porch?
00:11:16 <carter> olalonde thats no cool
00:11:19 <carter> http://en.wikipedia.org/wiki/Electromagnetic_pulse
00:11:22 <carter> is really cool
00:11:50 <carter> the atmosphere acts as a parabolic reflector when you do a high altitude nuke, sort of scary too
00:11:58 <carter> http://en.wikipedia.org/wiki/Nuclear_electromagnetic_pulse
00:12:06 <olalonde> sounds cool
00:12:10 <olalonde> might do a kickstarter
00:13:04 <carter> cool
00:13:09 <b6> i think the iorefs for storing funptrs are because when the callback is unregistered, you need to call freeHaskellFunPtr.
00:13:16 <aoshi> I fucking love programming
00:13:23 <carter> b6 sounds possible
00:13:29 <carter> i've never done callback heavy codes
00:13:38 <carter> so i'm a newb in that area
00:13:47 <carter> aoshi as do we all if we're here probably
00:13:55 <aoshi> been reading "hackers: heroes of the computer revolution"
00:14:02 <aoshi> history of hackers book
00:14:03 <olalonde> you should drink some Node.js kool-aid
00:14:06 <aoshi> and I want to scream as what is possible now
00:14:13 <aoshi> I love it
00:14:13 <olalonde> to get the right amount of callback intake
00:14:19 <aoshi> as to*
00:14:22 <carter> olalonde i gave a talk on CPS
00:14:26 <carter> thats the king of call backs
00:14:30 <roboguy_> aoshi: that's a good book
00:14:48 <olalonde> :)
00:15:40 <olalonde> CPS is not common in haskell?
00:15:56 <carter> its as common as you want it to be
00:16:05 <carter> as rare as you feel like
00:16:21 <olalonde> ok
00:16:29 <carter> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/CPS
00:16:40 <carter> so right before code gen, everythings made CPS
00:16:52 <carter> in a reprsentation called C Minus Minus
00:17:29 <carter> but theres also certain libraries that kinda use CPS related interfaces
00:17:35 <carter> i forget which because its 3am
00:17:54 <carter> i gave a talk where i demo'd code written in haskell and C and C--
00:17:57 <carter> and benchmarked them all
00:18:07 <carter> inlined haskell code was the fastest on the micro benchmarks :P
00:18:20 <olalonde> its 3pm here :)
00:18:22 <olalonde> got it
00:18:36 <carter> olalonde when the other nyc haskell meetup talk goes online
00:18:38 <carter> watch it
00:18:45 <carter> you'll get to listen to me give a talk
00:18:53 <olalonde> alright great
00:19:06 <carter> and i kinda do a sketchy derive cps from making a toy evaluator that has an explicit stack
00:19:12 <carter> with the first half of the talk
00:19:14 <carter> the second half
00:19:26 <carter> i show how some random bits of how the ghc RTS work
00:19:36 <carter> and how you can write c or c-- or haskell
00:19:39 <carter> to do the same thing
00:19:44 <carter> and the code and slides are online
00:19:50 <carter> though i won't link to em till the talk
00:19:52 <carter> is online
00:20:11 <carter> its crazy how little material is possible to cover in a 1 hour talk
00:20:41 <carter> ok
00:20:44 <carter> NIGHT INTERENT
00:20:46 <carter> *INTERNET
00:20:50 <carter> i can't spell when tired
00:21:28 <dmj> lol
00:21:37 <dmj> carter: one sec let me link u to my db project
00:21:43 <carter> cool
00:22:01 <carter> dmj you should ask edwardk or sclv  when they're awake for Feedbacktoo
00:22:05 <dmj> carter: getting images on github readme's is no easy task
00:22:15 <carter> i wanna sleep
00:22:17 <carter> later?
00:22:22 <dmj> yea no prob
00:22:25 <carter> yay
00:22:26 <carter> night
00:22:26 <dmj> I'll ask them as well
00:22:28 <dmj> :) night
00:22:52 <quchen> Am I missing something, or do the docs really not mention any laws for Alternative? http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t:Alternative
00:25:05 <Lethalman> quchen, aren't those equations the laws?
00:25:28 <quchen> Lethalman: The "some/many" ones?
00:25:31 <Lethalman> yes
00:25:48 <quchen> Not sure. For one, they're completely unreadable.
00:25:51 <Lethalman> or maybe that's why I still haven't grasped alternative :P
00:26:08 <quchen> "some and many should be the least solutions of the equations"
00:26:43 <quchen> That doesn't sound like a good law to me. "empty <|> x = x" is something I can work with much better.
00:27:09 <quchen> I'm not sure what the some/many functions are doing in Alternative anyway.
00:27:51 <shachaf> The some/many laws are irrelevant.
00:28:03 <quchen> Oh, "The identity of <|>", I overlooked that.
00:28:48 <Lethalman> are these the laws? http://www.haskell.org/haskellwiki/Typeclassopedia#Alternative_formulation
00:29:08 <quchen> Lethalman: No, that's an alternative formulation for Applicative.
00:29:14 <quchen> Not a formulation for Alternative.
00:29:14 <Lethalman> ah
00:29:20 <Lethalman> lol
00:29:38 <Lethalman> so Alternative is missing in that doc
00:29:56 <quchen> unit/** are to Applicative like return/fmap/join are to Monad if you will.
00:30:40 <roboguy_> so empty and (<|>) form a monoid?
00:30:51 <dmwit> Lethalman: Uh, it's not missing.
00:30:54 <dmwit> http://www.haskell.org/haskellwiki/Typeclassopedia#Other_monoidal_classes:_Alternative.2C_MonadPlus.2C_ArrowPlus
00:31:16 <quchen> roboguy_: yes
00:32:07 <Lethalman> ah
00:32:11 <Lethalman> dmwit, thanks
00:32:58 <Lethalman> dmwit, Of course, instances of Alternative should satisfy the monoid laws. .... ??? ....
00:32:59 <Lethalman> :P
00:33:29 <dmwit> Lethalman: Why ??? ?
00:33:31 <Lethalman> that means, except for the functor, the laws are the same?
00:34:27 <dmwit> I guess there's not even an "except". Just "the laws are the same".
00:34:28 <quchen> empty <|> x = x   x <|> empty = x   (a <|> b) <|> c = a <|> (b <|> c)
00:34:32 <quchen> ^ Monoid laws.
00:34:40 * hackagebot nicify 1.1 - Pretty print the standard output of show for algebraic datatypes  http://hackage.haskell.org/package/nicify-1.1 (JulianFleischer)
00:34:53 <Lethalman> mh ok
00:35:10 <olalonde> what would you do if you won a million monad?
00:35:17 <Lethalman> > Just 5 <|> Just 6 <|> Just 7
00:35:18 <lambdabot>   Just 5
00:35:23 <olalonde> would you donate them to charity?
00:35:23 <Lethalman> > (Just 5 <|> Just 6) <|> Just 7
00:35:24 <lambdabot>   Just 5
00:35:33 <Lethalman> > Just 5 <|> (Just 6 <|> Just 7)
00:35:34 <lambdabot>   Just 5
00:35:49 <quchen> I guess they could be stated more explicitly here, because I always assume that laws are put in blue boxes by Haddock.
00:38:37 <quchen> I wonder whether the MonadPlus laws can be derived from Alternative+Monad.
00:39:11 <adas> in the state monad.. i can do s <- get to get the state. but how do i get the 'a'?
00:40:03 <quchen> adas: a <- statefulComputation. In your example, "get" doesn't "get the state", it's a stateful computation that has the state as both the state and the "a".
00:40:03 <shachaf> What is the 'a'?
00:40:51 <adas> shachaf: 'a' .. result of the computation of the state..i believe
00:41:43 <shachaf> Your question doesn't make sense. Please provide more context about what you're trying to accomplish.
00:42:39 <adas> shachaf: trying to learn the state monad. using the state monad to write an RPN evaluator.. so the type of state is "State Expression Stack"
00:42:41 <akegalj> hi there :) I wrote some haskell that reads bunch of small files (100,000 * 4kb) and does some work with them. Now, while testing code i get running statistics(real,user). When running for the first time, real(20m) is much bigger then user(1m) time. After few runs real == user with (1m), so i suppose there are no more hard disk reading. Why is this so? Is it ghc related or OS related?
00:43:23 <valdyn> akegalj: your os disk cache
00:43:40 <akegalj> valdyn: ok, thnx
00:44:38 <dmj> adas: This helped me, http://brandon.si/code/the-state-monad-a-tutorial-for-the-confused/
00:44:41 * hackagebot karver 0.1.0 - A simple template engine, inspired by jinja2  http://hackage.haskell.org/package/karver-0.1.0 (JeremyHull)
01:04:47 <Moggle_> oh cool monads will now all be applicatives
01:05:08 <Moggle_> i like this change, it irritates me when i hear the phrase "historical reasons" in places like LYAH
01:08:28 <Hafydd> Woo!
01:09:02 <roboguy_> well that's what i get for trying to memoize a huge amount of data haha
01:16:47 <blackdog> carter: can't see any reason to port it just because it's not in haskell.
01:22:52 <Moggle_> @src <|> :: Maybe a -> Maybe a -> Maybe a
01:22:53 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
01:22:58 <Moggle_> alas
01:23:03 <Moggle_> alright time to download the package source
01:27:08 <roboguy_> @src (<|>) :: Maybe a -> Maybe a -> Maybe a
01:27:08 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
01:27:12 <roboguy_> just checking
01:36:10 <Moggle_> @src liftA2
01:36:10 <lambdabot> liftA2 f a b = f <$> a <*> b
01:44:45 <Lethalman> so I'd like to get the Free monad or blaze html or clay in lambdabot
01:44:49 <Lethalman> but those modules are not safe
01:45:05 <Lethalman> anything I can do without modifying the sources?
01:56:16 <akamaus> hi all. All of a sudden I stumbled upon a bug similar to http://hackage.haskell.org/trac/ghc/ticket/5289 while building a program which uses double-conversion library with ghc-7.6.3 on ubuntu vps. Any ideas how to overcome this?
02:12:41 <fruitFly> elliott: merijn ? any of my gangstahs in d houuse
02:13:30 <shachaf> fruitFly: What?
02:16:22 <Lethalman> :t foldMap . foldMap
02:16:23 <lambdabot> (Foldable t, Foldable t1, Monoid m) => (a -> m) -> t (t1 a) -> m
02:16:25 <Lethalman> \o/
02:16:33 * Lethalman shocked
02:17:24 <Lethalman> but I somehow understand, I think
02:17:57 <shachaf> It's simple: foldMap (foldMap f) ...
02:18:04 <Lethalman> shachaf, yes I can reach that
02:18:42 <Lethalman> :t \x -> foldMap x
02:18:42 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
02:19:12 <Lethalman> :t foldMap
02:19:13 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
02:19:44 * hackagebot hoauth2 0.3.5 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.3.5 (HaishengWu)
02:20:28 <Lethalman> shachaf, so to the outer foldMap it's passed something like t a -> m, right?
02:20:46 <Lethalman> (t a -> m) -> t1 (t a ) -> m
02:20:54 <shachaf> Yes.
02:20:59 <shachaf> See also: fmap . fmap
02:21:04 <shachaf> s/f//g
02:21:09 <Lethalman> but why (a -> m) instead of (t a -> m)
02:21:54 <Lethalman> :t fmap f
02:21:54 <lambdabot> (Functor f, Show a, FromExpr b) => f a -> f b
02:22:12 <Lethalman> :t fmap (fmap f)
02:22:13 <lambdabot> (Functor f, Functor f1, Show a, FromExpr b) => f (f1 a) -> f (f1 b)
02:22:31 <Lethalman> :t fmap . fmap
02:22:32 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
02:22:51 <Lethalman> that is, I expect (f a -> f b) instead of (a -> b)
02:22:54 <Lethalman> mhpf
02:23:10 <shachaf> You should work this all out by hand with unification and all that.
02:24:12 <Lethalman> ok
02:24:16 <Lethalman> so
02:24:21 <Lethalman> :t \f -> fmap (fmap f)
02:24:21 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
02:24:52 <Lethalman> since f is passed to the inner fmap it must be (a -> b)
02:25:00 <Lethalman> then I can grok fmap (fmap f)
02:26:51 <Lethalman> yeah it's something I always used with map
02:27:19 <Lethalman> it's just a little hard to get map . map than actually using it as \x xs -> map (map f) xs
02:27:34 <Lethalman> :-)
02:28:41 <Lethalman> :t map . flip map
02:28:42 <lambdabot> [a] -> [a -> b] -> [[b]]
02:28:47 <Lethalman> :t flip map . map
02:28:48 <lambdabot>     Couldn't match type `[a1] -> [b0]' with `[a0]'
02:28:48 <lambdabot>     Expected type: (a1 -> b0) -> [a0]
02:28:48 <lambdabot>       Actual type: (a1 -> b0) -> [a1] -> [b0]
02:29:00 <shachaf> Also, you can test these sorts of things in /msg lambdabot (or ghci).
02:29:08 <Lethalman> :t fmap . flip fmap
02:29:08 <lambdabot> (Functor f, Functor f1) => f1 a -> f (a -> b) -> f (f1 b)
02:29:31 <Lethalman> oh what's that :P
02:31:57 <Lethalman> :t fmap . flip map
02:31:58 <lambdabot> Functor f => [a] -> f (a -> b) -> f [b]
02:32:01 <Lethalman> that's easier...
02:32:21 <Lethalman> :t map . flip fmap
02:32:21 <lambdabot> Functor f => f a -> [a -> b] -> [f b]
02:32:30 <Lethalman> amazing stuff :P ok I stop
02:45:04 <acube> Oh no, hayoo is down :(
02:45:42 <isomorphic> In the context of c2hs, I've seen declarations like newtype structPtr = structPtr (Ptr structPtr) - which look recursive.   Can somebody explain why these work?
02:46:09 <arkeet> that's not syntactically valid. what exactly was it?
02:46:44 <arkeet> (well, types have to begin with uppercase)
02:47:00 <bitonic> isomorphic: that’s something that can’t be inhabited meaningfully, it’s probably being used as a replacement for EmptyDataDecls
02:47:03 <shachaf> Asking people for the actual code rather than a paraphrase is reasonable.
02:47:21 <isomorphic> newtype DtraceProgPtr = DtraceProgPtr (Ptr (DtraceProgPtr))
02:47:47 <shachaf> bitonic: It's not an EmptyDataDecl. Certainly it can be inhabited.
02:48:11 <arkeet> isomorphic: so that's a pointer.
02:48:16 <bitonic> shachaf, isomorphic: right, i didn’t see the Ptr
02:48:21 <arkeet> the thing the pointer points to is supposedly another pointer, of the same type.
02:48:29 <isomorphic> So, I'm using these things as pointers - I'm fairly sure they work
02:48:37 <isomorphic> … I just don't know why
02:48:48 <bitonic> isomorphic: I’d guess it’s a way to talk about foreign structures
02:49:06 <bitonic> you don’t construct them you just get ptrs from structures initialised by C code
02:49:38 <chrisdone> shachaf: http://ircbrowse.net/nick/chrisdone
02:49:44 <isomorphic> bitonic:  Yes, that's what I'm using them for.
02:49:45 <bitonic> the fact that it’s recursive like that is to indicate that you can’t create a ‘DtraceProg’ and then a pointer to it
02:49:50 <chrisdone> shachaf: http://ircbrowse.net/nick/shachaf =)
02:50:42 <bitonic> isomorphic: the more idiomatic way is to create an empty type and then point to it, e.g. ‘data DtraceProg; type DtraceProgPtr = Ptr DtraceProg’
02:50:46 <shachaf> I'm glad that kmc has still far outdone me in a shorter time.
02:51:41 <shachaf> chrisdone: "most active at aroun 6894:00 (UTC)"?
02:51:43 <chrisdone> ah, just noticed i screwed up time
02:51:44 <chrisdone> haha, sec
02:52:25 <shachaf> chrisdone: How are these actually being generated?
02:52:34 <shachaf> (Should move to #-blah -- this is off-topic in here.)
02:52:49 <chrisdone> alright, fixed
02:53:49 <bitonic> chrisdone: that’s neat
02:55:13 <notdan> is it possible to derive Generic instance for datatypes you haven't defined?
02:55:18 <notdan> haven't defined yourself
02:56:07 <bitonic> notdan: StandaloneDeriving
02:56:48 <notdan> thanks bitonic
03:12:08 <acube> Couldn't match type `a0 -> Box'
03:12:09 <acube>                   with `forall a3. Data a3 => a3 -> Box'
03:13:06 <acube> shouldn't I be able to use the first (a0 -> Box) type when a (forall a3. Data a3 => a3 -> Box) is required?
03:14:01 <shachaf> You should give complete examples rather than snippets.
03:14:06 <acube> Ok
03:14:11 <shachaf> But in this case the answer is no.
03:14:29 <notdan> Are there any serialization libraries that serialize to Text?
03:19:48 <merijn> notdan: You mean pretty printing?
03:23:09 <notdan> Not really. I have this big datastructur with fields of type Text, GHC.Severity and others. I want to serialize it to file. I tried using cereal, but I can't seem to derive Generic instance for Text
03:23:28 <notdan> and neither cereal nor binary provide a out-of-the box way to serialize a Text
03:23:32 <notdan> which is kinda strange
03:32:57 <megabeest> @djinn  ((Either a (a -> Void)) -> Void) -> Void
03:32:58 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
03:33:24 <megabeest> what is the function void here?
03:34:03 <elliott> chrisdone: is "most active at around" broken?
03:34:09 <elliott> it has said 23:00 UTC for everyone I've checked!
03:34:24 <elliott> megabeest: void :: Void -> a, also called absurd
03:34:29 <elliott> megabeest: not related to Control.Monad.void
03:34:39 <chrisdone> elliott: ah, good catch
03:34:56 <chrisdone> tip: don't use tuples
03:35:03 <megabeest> ah, couldn't find it on hackage
03:35:51 <chrisdone> elliott: corrected
03:37:25 <elliott> also, recent/all time don't seem to do anything
03:37:34 <chrisdone> i'm working on it presently =)
03:37:57 <chrisdone> i don't normally work in production, but when i do, it's ircbrowse
03:43:58 <acube> What is "most active at around" ?
03:44:38 <acube> Ah nvm, it's at ircbrowse
03:45:14 <byorgey> chrisdone: the "recent"/"all time" tabs don't seem to do anything
03:45:23 <byorgey> when browsing by nick
03:45:25 <fruitFly> Could I please share with someone my idea for a startup; I'm trying to determine where to invest my time. I would greatly appreciate the advice, it's short.
03:45:55 <fruitFly> Could I please share with someone my idea for a startup, it's short*; I'm trying to determine where to invest my time. I would greatly appreciate the advice.
03:48:00 <chrisdone> byorgey: haha elliot just said the same thing a few mins ago above =p
03:48:34 <byorgey> oh, ok sorry =)
03:49:16 <byorgey> haha, the social graph is quite a throwback
03:49:36 <byorgey> I guess it must be using data from 2008 or so
03:51:58 <chrisdone> yeah that social graph is all time
03:52:26 <chrisdone> (tho i might switch it back to last 30 days)
03:52:28 <byorgey> oh, all time, I see
03:52:47 <elliott> I like all the non-names on it
03:52:56 <Peaker> whenever I try to pretty-print a large Doc I get a stack overflow :(  I am guessing it has to do with too much laziness inside the Doc data structure, but I'm not sure...
03:53:53 <Peaker> What does Haxml do nicely that the simple xml-light does not? It's a monster :(
03:55:30 <isomorphic> bitonic:  Am i right to think if I do it that way (using type), I won't be able to make instances?
03:56:10 <bitonic> isomorphic: instances for what?  Storable and company?  yes, since you don’t have a non-pointer type to begin with
03:56:29 <Peaker> wx "setup: failed" without reason, bah
03:57:29 <isomorphic> bitonic:  Actually, I made my own class for Pointers - to deal with wrapping and unwrapping - so I think it's appropriate to try to make instances.
03:57:56 <bitonic> isomorphic: I don’t know what your situation is
03:58:08 <bitonic> but usually you create an empty type which is an instance of Storable
03:58:41 <chrisdone> byorgey: elliott: works now: http://ircbrowse.net/nick/byorgey?recent=true
03:59:07 <isomorphic> bitonic:  Usually - in the case of dealing with foreign pointers you mean?
03:59:50 <bitonic> isomorphic: yes
04:02:14 <byorgey> chrisdone: cool
04:03:11 <hpaste> burp pasted “persistent example not working” at http://hpaste.org/90261
04:03:35 <burp_> does anyone know of working persistent examples? the ones from http://www.yesodweb.com/book/persistent are not working anymore
04:03:42 <robde> hello. I have a fiddly question: how come f t sf s0 = (s0, t (snd (sf s0))) is of type (a -> b) -> (s -> (s,a)) -> (s -> (s,b))? am I right that I can think of s -> (s, _) as some sort of wrapper function? what could be it’s purpose and the purpose of f?
04:04:52 <merijn> robde: Well, it's purpose would be that that function is fmap for State s
04:05:31 <quchen_> merijn: Nice catch.
04:05:38 <quchen_> Although it's FlippedState. ;-)
04:05:42 <shachaf> robde: That function doesn't look right.
04:05:54 <shachaf> I bet it's not doing what you want.
04:06:01 <merijn> quchen_: How is it flipped?
04:06:05 <shachaf> (So first you should figure out what it is that you want.)
04:06:14 <quchen_> merijn: Isn't State s -> (a, s)?
04:06:26 <merijn> oh, right
04:06:27 <merijn> My bad
04:06:57 <shachaf> State should be s -> (s, a). Calling it FlippedState makes it sound like it's not isomorphic.
04:07:38 <dobblego> newtype FlippedState a s = F (s -> (a, s))
04:07:58 <dobblego> newtype BuggeredState s a = B (s -> (s, a))
04:08:02 <quchen_> That's DoublyFlippedState and you can't make it a Monad.
04:08:13 <dobblego> it is State, flipped
04:08:15 <quchen_> The second one is better. :-)
04:08:23 <dobblego> well, it's buggered
04:08:54 <robde> so f takes a function that transforms the second value of that tuple. but why isn’t it only (a -> b) -> (s, a) -> (s, b)?
04:10:00 <shachaf> I think you're walking backwards toward your goal, and stumbling into things a bit.
04:10:02 <byorgey> @type let q = f t sf s0 = (s0, t (snd (sf s0))) in q
04:10:03 <lambdabot> parse error on input `='
04:10:07 <shachaf> What are you actually trying to accomplish here?
04:10:12 <byorgey> @type let f t sf s0 = (s0, t (snd (sf s0))) in f
04:10:13 <lambdabot> (b -> t1) -> (t -> (a, b)) -> t -> (t, t1)
04:14:21 <isomorphic> bitonic:  I'm going down the path of making a storable instance.   I have a very vanilla C struct and a copy of the gtk2hs source code - what's the meaning of the alignment -  alignment _ = alignment (undefined:: #gtk2hs_type gint)  - and particularly #gtk2hs_type ?
04:14:50 <shachaf> isomorphic: I doubt that's Haskell code.
04:15:04 <shachaf> It's probably hsc2hs code, or one of those things.
04:15:30 <shachaf> Figure out which one you're using and look up its documentation.
04:15:35 <shachaf> Oh, c2hs.
04:23:24 <gspr> Is the Foreign.C.* hierarchy intended only for stuff that's a part of the C standard(s), or is it OK also for other things that interact with a C library through FFI?
04:24:07 <acube> Is it possible to write or does there exist a function of type (Typeable1 t, Typeable1 u) => (forall a. ctx a => t a -> x) -> u b -> Maybe x ? I guess not?
04:24:09 <gspr> (Say, for instance, that I'm writing bindings for a C library, and need to mirror some struct foo. Do I place the corresponding data type in Foreign.C.Types.CFoo?
04:24:21 <gspr> )
04:24:28 <robde> shachaf: the task was to find a function that fits this type signature
04:24:47 <shachaf> robde: Ah. Then the task was ill-specified.
04:24:53 <acube> (the function should apply the function it was given only if it's possible to cast the u b into some t a, where a is an instance of ctx)
04:26:52 <byorgey> gspr: there is no standard or agreement on what different parts of the hierarchy are "intended for".  Just do what you think makes the most sense.
04:26:56 <elliott> you can do it without the ctx part
04:26:59 <byorgey> Foreign.C.Types.CFoo sounds fine to me.
04:27:32 <acube> elliott: How would it work without the ctx part?
04:27:33 <byorgey> gspr: you could also find some libraries that do similar things and see how they name things.
04:27:37 <gspr> byorgey: Yeah, I know there isn't… I'm just trying to be as nice as I can :)
04:27:45 <gspr> byorgey: OK, I'll look around
04:27:54 <gspr> Thanks
04:28:41 <gspr> byorgey: Since I highly respect your opinion (based on your writings) - what would *you* do if the struct in question is a part of POSIX but not the C language itself? :)
04:30:52 <robde> shachaf: it’s an assignment to find a function that suits this type signature. it says nothing about the purpose
04:32:15 <shachaf> Yep. I'm suggesting that it's probably a bad assignment, though who knows.
04:32:17 <shachaf> However, 04:08 <robde> so f takes a function that transforms the second value of that tuple. but why isn’t it only (a -> b) -> (s, a) -> (s, b)?
04:32:36 <shachaf> There's no "why". :-)
04:33:14 <robde> how can I think of this function (s -> (s, a)) that B stores?
04:34:22 <merijn> robde: As a function of type "s -> (s, a)"?
04:34:36 <blackdog> oh good god. just spent an hour chasing a bug because i didn't realise copyBytes had the opposite order of cp.
04:36:09 <merijn> blackdog: Those are the best kinds of bugs :)
04:36:12 <bitonic> isomorphic: I don’t know, iirc I used ‘alignment (undefined :: Ptr ())’ for alignment, but that might be wrong
04:36:29 <blackdog> merijn: "Why is everything broken? My types say everything is a-ok!"
04:36:49 <isomorphic> bitonic:  Thanks :)  I've found a couple of different examples, am just running through should know more shortly :)
04:37:12 <robde> oh, that looks very similar to the State monad
04:45:12 <robde> am I right that :: State s a -> State s b is the same as :: (s -> (a, s)) -> (s -> (b, s))?
04:45:23 <dobblego> yes
04:48:02 <hpaste> burp pasted “persistent - does anyone have a working example for it?” at http://hpaste.org/90262
04:52:05 <burp_> persistent: I just want to use it :/ there is so much magic and language extensions used …
04:52:48 <burp_> and I wonder if I should use persistent at all… if after just a few weeks examples stopped working
04:53:06 <burp_> the code I write not with it will probably stop working in a few weeks / months
04:54:32 <burp_> ~now
04:55:44 <robde> shachaf: do you mean the flipped types in the tuple?
04:56:04 <burp_> I have the feeling that using so many language extensions and "magic" makes these libraries very hard to use for casual haskell users
04:56:16 <burp_> the error messages are hard to understand and cryptic
04:58:02 <chrisdone> shachaf: added memorable quotes: http://ircbrowse.net/nick/chrisdone?recent=false from @remember. i don't feel like tracking @forget so that'll do
05:00:30 <typoclass> burp_: it may have to do with ScopedTypeVariables. i googled your error and found a similar question at http://ircbrowse.net/browse/haskell/?id=15717859&timestamp=1368823575#t1368823575 (see saizan's answer on the next few pages)
05:05:42 <burp_> thank's but it seems to be a different issue here, I think I use some other library, because of my concerns of interface stability given
05:07:06 <elliott> chrisdone: “what is one supposed to put in the passwd.rc file for lambdabot? I want to send a PASS command.” — chrisdone
05:07:07 <Aetherspawn> Heys guys I need some help with package management
05:07:09 <elliott> chrisdone: hilarious quote
05:07:19 <Aetherspawn> I'm going to copy my .cabal from another computer to one of the same operating system and architecture
05:07:31 <Aetherspawn> since it doesnt have enough ram to build certain packages
05:07:34 <elliott> chrisdone: oh that's not the quotes section :P
05:07:42 <Aetherspawn> do I have to update my ghc-pkg or anything after I do this?
05:07:49 <Aetherspawn> is there anywhere else I need to acknowledge the new packages
05:08:11 <arnsholt> Are there any useful tricks for debugging code using Arrays? My code errors out with "(Array.!): undefined array element", and I wouldn't mind a bit more detailed information
05:08:19 <Saizan> Aetherspawn: your .ghc is where the metadata is stored
05:08:23 <typoclass> burp_: ok, could be different. i just noticed the similarity in actual type vs expected type being PersistMonadBackend vs. PersistEntityBackend
05:09:18 <Aetherspawn> oh damn, different usernames
05:09:24 <Aetherspawn> will it make a difference?
05:10:32 <chrisdone> elliott: the top one is a completely random quote =)
05:10:44 <chrisdone> elliott: that's why i made it look like an important citation =p
05:11:24 <elliott> “Can't you just use the API?” — shachaf
05:12:46 <chrisdone> so deep
05:13:17 <typoclass> "anyone got a fixed version of the split library for ghc7? some Tolkienesque error messages about skolems escaping"
05:13:34 <elliott> chrisdone: http://ircbrowse.net/nick/lambdabot?recent=false
05:14:28 <typoclass> elliott: heh, lambdabot is "not active" in the hour between 23h and midnight
05:15:25 <chrisdone> typoclass: ah, that's just the graph api, it doesn't connect it into a circle. maybe i can add an extra data point so it would connect up
05:15:32 <Saizan> Aetherspawn: the metadata has absolute paths in it, so i'd think so
05:16:07 <chrisdone> elliott: interesting that it was really hammered in 2007/2008 and has seen less use each year since
05:16:16 <typoclass> chrisdone: thanks for your opinion, but no, i like my explanation better. lambdabot has a mysterious hour off where she flies around the globe hunting ... kittens or something
05:16:40 <elliott> chrisdone: yeah that's odd, maybe it was more floody in 2007
05:17:00 <chrisdone> it did used to show the title of all urls in the past
05:17:01 <elliott> typoclass: it's the hour when all the christmas presents are delivered
05:17:53 <elliott> chrisdone: ah, I bet that's it
05:17:58 <typoclass> elliott: good theory! deliveries are going on every day for one hour. it's just that the whole transaction is committed on 24 december
05:18:50 <IanMc> hi all
05:19:24 <acube> lambdabot memorable quotes: Plugin `quote' failed with: getRandItem: empty list ha
05:19:42 * typoclass purrs in the general direction of IanMc
05:22:23 <acube> typoclass: Well, split builds fine for me using ghc The Glorious Glasgow Haskell Compilation System, version 7.7.20130617
05:23:07 <typoclass> acube: oh sorry, i was looking at the quote page mentioned earlier :-) didn't make that clear. i don't have a compiler error
05:23:27 <acube> typoclass: oh :P
05:25:35 <mm_freak> merijn: my main complaint about reform (as compared to digestive-functors) is that you can't choose the field names =)
05:25:57 <mm_freak> so it's probably not too bad an idea to start with explicit field names and then add field name generation later
05:26:29 <mm_freak> (reform is still better, btw)
05:35:35 <merijn> mm_freak: I mostly looked at digestive-functors so far, I'll study reform a bit more. My main complaint about the way labelling fields in digestive-functors works (as I mentioned) is that there's no guarantee a given field will actually exist
05:37:17 <mm_freak> merijn: what do you mean?  it's applicative
05:38:12 <merijn> mm_freak: Views use Text labels to find the things to render
05:38:19 <merijn> Unless I misunderstood the docs
05:39:13 <merijn> mm_freak: See https://github.com/jaspervdj/digestive-functors/blob/master/examples/tutorial.lhs#views
05:39:34 <merijn> The rendering of a form there uses Text labels to look up which bits to render
05:39:41 <merijn> Which offends my type safety sensibilities
05:40:32 <mm_freak> merijn: conceptually this isn't needed
05:40:38 <mikeplus64> edvardkk: is your name specifically like this to confuse people looking for edwardk? lol
05:41:03 <burp_> typoclass: a pain with haskell libraries and versions, after rm -rf'ing ~/.cabal and ~/.ghc and reinstalling persistent it works now
05:41:19 <burp_> it seems rm -rf ~/.cabal and ~/.ghc is necessary every few weeks
05:41:26 <typoclass> burp_: oh :-/
05:41:27 <mm_freak> merijn: digestive-functors uses a weird semi-separation between forms and their views
05:41:47 <mm_freak> merijn: reform doesn't separate at all
05:42:08 <mm_freak> so what you really need is a mixture…  the underlying idea is the same, though:  an applicative DSL
05:42:44 <merijn> mm_freak: I know it isn't needed conceptuall, but then your code becomes really messy
05:42:57 <mm_freak> merijn: that's the price to pay for separation
05:43:01 <merijn> mm_freak: Yeah, right now I'm playing with an applicative DSL for widgets wrapped in a monad for the naming
05:43:23 <merijn> mm_freak: The fact that I find that price unacceptable is one of the reasons I want to implement something different :p
05:43:35 <mm_freak> you have to address the widgets you want to lay out some way…  either you get the address from the widget itself or you give widgets names
05:43:48 <merijn> mm_freak: Oh, I'm not saying I'm against *names*
05:43:58 <merijn> mm_freak: I'm just against names that aren't type safe :)
05:44:15 <mm_freak> merijn: then you want addresses from the widget
05:44:28 <merijn> Yeah, that's what I'm playing with now
05:45:06 <robde> ah, this one answeres all my questions :) http://brandon.si/code/the-state-monad-a-tutorial-for-the-confused/
05:45:14 <merijn> I'll take another look at what reform is doing, though
05:46:26 <mm_freak> merijn: you could have invented those applicatives…  the underlying idea is that you can extract a view without running and run without viewing
05:47:05 <mm_freak> then if you can extract the views of f and x, you can also extract it from f <*> x
05:48:08 <mm_freak> and pure x's view is "empty" in a sense as enforced by the applicative laws
05:49:48 <elliott> merijn: perhaps you can abuse Typeable for your identifiers.
05:50:22 <mm_freak> i think merijn doesn't need /identifiers/ at all, but addresses
05:50:22 <merijn> elliott: No, when I say typesafe I mean "given an identifier, a widget corresponding to that identifier should actually exist"
05:50:45 <merijn> elliott: Typeable isn't much help in that scenario
05:50:47 <mm_freak> an "address" can be the view itself
05:51:52 <merijn> Right now I have Widgets, which can be combined in a tree forming the UI and you can obtain Handle's from a widget, which (given the UI) lets you get the value out of the corresponding widget
05:52:22 <merijn> The handles being applicatives which you can combine to combine the values inside the widgets
05:52:45 <mm_freak> merijn: how about instance Comonad Handle?
05:53:00 <mm_freak> and rename Handle to View…  a valued view
05:53:36 <merijn> mm_freak: Well, the issue with Comonad Handle is that then I have no access to the overall UI, or rather, I haven't figured out a way to do that via the Handle yet
05:53:50 <merijn> I'd prefer to have Applicative Handle & Comonad Handle, yes
05:53:54 <mm_freak> merijn: extracting the view is an extra function
05:54:10 <mm_freak> view :: View a -> UI
05:54:26 <mm_freak> and UI is a monoid with an extra function for vertical composition, say
05:54:59 <mm_freak> so actually two monoids with the same identity
05:55:01 <merijn> The problem with using monoid directly for the UI is that it makes writing down layouts really mesy
05:55:11 <mm_freak> huh?
05:55:19 <merijn> Or maybe it doesn't
05:55:22 <merijn> I dunno
05:55:28 <mm_freak> (view x <> view y) <-> view z
05:55:38 <mm_freak> gives you x and y in a row and z on the next row
05:55:48 <merijn> I have roughly that now, yes
05:55:58 <mm_freak> i don't think that's messy
05:56:00 <merijn> I figured that I'll first write it without all the fancy typeclasses
05:56:01 <elliott> a little typeclass hackery lets you skip the "view"s
05:56:09 <merijn> elliott: Yes, I had that before
05:56:13 <mm_freak> and yeah, what elliott said
05:56:45 <merijn> mm_freak: I figure I'll try to refactor things into Comonad/Monoid once I have a more crystalised idea of what works
05:57:05 <merijn> Else I have to continuously add/change/delete instances
05:57:11 <tdammers> I'm wondering whether I could have ghci run my input in a custom monad stack instead of IO
05:57:26 <tdammers> e.g. a StateT Foobar IO or some such
05:57:45 <mm_freak> merijn: maybe that's your main mental problem…  you probably /should/ wrap it up in existing type classes
05:58:08 <tdammers> so that I could just say, for example, foobarBaz .= "Hi there!", right at the ghci prompt
05:58:12 <mm_freak> my idea was to write another type class:  class (Monoid a) => Layout a where (<->) :: a -> a -> a
05:58:37 <mm_freak> with the law:  mempty <-> x = x <-> mempty = x
05:58:49 <mm_freak> and (<->) associative
05:59:11 <mm_freak> tdammers: if your monad stack supports suspension you can
05:59:20 <tdammers> what's suspension?
05:59:29 <Aetherspawn> how do I set the @where thing on lambdabot
05:59:32 <tdammers> and how would I do it?
05:59:45 <elliott> I don't think GHCi has any functionality for this
05:59:47 <merijn> mm_freak: I can think of a million ways to implement what I wanted in fancy types, the problem is not implementing it. The problem is implementing it in a way that results in code that I find acceptable :)
06:00:10 <mm_freak> tdammers: the simplest suspensible monads are free monads…  then you have monad-coroutine and free, which give you the same monad transformer:  Coroutine aka FreeT
06:00:34 <mm_freak> tdammers: a completely different approach is ContinueT, which is my own humble invention =)
06:00:37 <mm_freak> see the 'continue' package
06:00:57 <tdammers> I think I'll need to do a bit more reading to understand that
06:01:11 <mm_freak> merijn: i think what we have worked out here is quite acceptable
06:02:02 <mm_freak> tdammers: well, it depends on whether you want to write a computation and then later append the rest to it
06:02:21 <mm_freak> tdammers: or you want to write a complete computation and reenter it at various spots, possibly with changed values
06:02:27 <mm_freak> the former is FreeT, the latter is ContinueT
06:02:31 <b2coutts> given that arguments to a function don't necessarily have consistent names in function definitions, how do you guys refer to arguments of a function when writing a comment to document what it does?
06:02:52 <mm_freak> b2coutts: by giving a small code sample
06:03:01 <mm_freak> -- | @f x@ does blah to @x@.
06:03:39 <tdammers> mm_freak: I pretty much want what ghci does with its implicit do {} in IO, only in StateT Something IO instead of plain IO
06:04:04 <b2coutts> mm_freak: makes sense
06:04:05 <tdammers> so I guess the former
06:04:14 <mm_freak> tdammers: it's possible, but you have to do it manually
06:04:18 <mm_freak> see also monad-control
06:04:34 <tdammers> my gut feeling says it should be possible to hack it into ghci
06:04:49 <mm_freak> tdammers: probably not worth the trouble though…  at that point i'd put my code in a file
06:05:14 <merijn> mm_freak: Oh, I agree with you, what you wrote just now is mostly what I already tried yesterday after I looked into reform and digestive-functors
06:05:18 <tdammers> well, I have this monad stack coded, but I want to play with it interactively to quickly see if it behaves like I want
06:05:22 <merijn> mm_freak: Now I'm just trying to refine things
06:06:07 <merijn> b2coutts: It depends, sometimes I'll refer to the type of the argument, or not at all
06:06:42 <mm_freak> tdammers: do you have explicit laws you want to hold or is your notion of "behaves like i want" more intuitive?
06:06:54 <b2coutts> merijn: yeah, I mean in some cases it's unambiguous when I just say "takes a function and a list; applies the function to all elements of the list"
06:07:05 <b2coutts> but then in a lot of cases it's unclear and/or ambiguous
06:07:25 <mm_freak> b2coutts: it's unclear in cases like this:  f :: Int -> Int -> Int -> Int -> Int
06:07:55 <b2coutts> yeah, sometimes I've tried to resolve that by just referencing the arguments in the comment in the order in which they should be applied
06:07:57 <mm_freak> but that suggests your functions may take too many arguments and you should probably do something about that first
06:08:07 <b2coutts> but tends to be horribly unclear, and it's often awkward to reference them in order
06:09:14 <mm_freak> b2coutts: in many cases what you really want is some abstraction…  say you want a function to double the length of a 3D vector
06:09:35 <mm_freak> f :: (Num a) => a -> a -> a -> (a, a, a)
06:09:37 <mm_freak> vs.
06:09:44 <mm_freak> f :: (Functor f, Num a) => f a -> f a
06:09:48 <elliott> b2coutts: you can say @f m n o p@ divides m by o and then frobulates with p and n
06:09:59 <elliott> b2coutts: or you can document each argument individually -- haddock supports this
06:10:02 <b2coutts> I mean, I don't generally have large functions like that, but for example, if I have a function that checks if a string is a substring of another string
06:10:13 <mm_freak> oh and yes, what elliott said
06:10:21 <elliott> @isSubstring xs ys@ checks if @xs@ is a substring of @ys@
06:10:21 <lambdabot> Unknown command, try @list
06:10:23 <b2coutts> then I have to say "takes a string and sees if it's a substring of another string"
06:10:24 <elliott> or such
06:10:29 <elliott> (btw, isInfixOf already exists :P)
06:10:29 <b2coutts> which is unclear
06:10:30 <zvrba> hm. polymorphism is weird. It seems I can't overload a function like this: f (x,y) = x+y ; f x = x*x
06:10:37 <mm_freak> b2coutts: http://hub.darcs.net/ertes/cascading/browse/Data/CSS/Build.hs
06:10:43 <elliott> b2coutts: or, document the first parameter as "The needle" and the second as "The haystack"
06:10:44 <mm_freak> see the ($=) function
06:10:47 <zvrba> because the first definition constrains f to take pairs.
06:11:02 <zvrba> is overloading possible in Haskell?
06:11:13 <zvrba> (I was just reading LYAH and experimented with case..)
06:11:19 <merijn> zvrba: Maybe, depending on what you mean by overloading
06:11:21 <mm_freak> zvrba: well, there is no Num instance for (a, a)
06:11:44 <mm_freak> zvrba: your misconception may be that polymorphism does /not/ overload
06:11:57 <b2coutts> zvrba: you could use Either I guess
06:11:58 <mm_freak> it just says, "i work for every type there"
06:12:15 <zvrba> wait. what's the preferred pastebin today?
06:12:17 <b2coutts> though I'd wonder why you'd want to overload a function like this
06:12:21 <merijn> zvrba: hpaste
06:12:50 <hpaste> zvrba pasted “overloading” at http://hpaste.org/90264
06:12:51 <merijn> b2coutts: I suspect he doesn't want to overload, but is just coming from a language where polymorphism is done with overloading
06:12:53 <b2coutts> perhaps f x can be seen as a special case of f (x,y) where y == 0 or something similar?
06:13:05 <zvrba> http://hpaste.org/90264
06:13:10 <mm_freak> merijn: anyway, i'm off for now…  i'm looking forward to your solution =)
06:13:22 <zvrba> if I add 4th pattern in case like this: _ -> "not a pair"
06:13:27 <zvrba> it is never matched.
06:13:28 <merijn> mm_freak: Regardless of what happens thanks for letting me waste your time anyway :p
06:13:45 <merijn> zvrba: Correct, because it's a type error to pass a pair to that function
06:13:50 <mm_freak> little summary of what i suggest so far:  a comonadic view, an applicative widget and much later a wiry UI =)
06:13:55 <merijn> zvrba: Also, the preferred haskell style is without braces
06:14:07 <zvrba> merijn: which function? I thought _ matched anything, including non-tuples
06:14:19 <mm_freak> textField :: Widget (View Text)
06:14:31 <mm_freak> View should probably be a Comonad and an Applicative
06:14:31 <merijn> zvrba: _ matches everything yes, but "f3" can only get tuples as arguments
06:14:35 <mm_freak> see you later
06:14:36 <zvrba> merijn: thanks, but I asked earlier about that. got a divided opinion, w/reference to a big part of stdlib being written with braces. so I use braces.
06:14:51 <hashcat> b2coutts: maybe you means 'f x _ = g x'?
06:14:53 <zvrba> indentation is confusing.
06:15:13 <merijn> zvrba: The stdlib is like that for historical reasons, I believe about >80% of hackage uses layout only
06:15:27 <merijn> mm_freak: See ya!
06:15:52 <elliott> zvrba: haha, you got a divided opinion on whether to use layout in #haskell?
06:15:52 <zvrba> merijn: a nonsensical error message from the compiler convinced me not to use layout syntax. (I forgot "=" in an otherwise clause and the compiler complained about indentation. right.)
06:15:57 <zvrba> elliott: yes.
06:16:12 <elliott> that's, um, probably not a representative sample, then
06:16:18 <merijn> :)
06:16:25 <merijn> Was SPJ in here by accident?
06:16:42 <zvrba> merijn: back to the matter at hand. does that case match any tuples, or just 2-tuples?
06:16:56 <elliott> you'll love the other nonsensical error messages you get
06:16:59 <merijn> zvrba: "tup" must be a tuple in that code
06:17:09 <zvrba> sure.
06:17:18 <zvrba> I just tested f3 (1,2,4) and also got an error message.
06:17:23 <merijn> Yes
06:17:29 <merijn> 2 tuples are not 3 tuples
06:17:37 <merijn> :t ('a', 'c')
06:17:38 <lambdabot> (Char, Char)
06:17:41 <merijn> :t ('a', 'c', 'b')
06:17:41 <lambdabot> (Char, Char, Char)
06:17:46 <zvrba> so the first case-clause restricts "pat" to 2-tuples?
06:17:52 <merijn> zvrba: Correct
06:18:08 <b2coutts> zvrba: while lists keep the same type of [a] regardless of length, tuples of different lengths have distinct types
06:18:15 <zvrba> i.e., case is not arbitrary structural pattern matching, but pattern-matching only over compatible types_
06:18:24 <zvrba> that's what I was trying to ask :P
06:18:24 <merijn> zvrba: Yes
06:18:28 <zvrba> bah :S
06:18:36 <elliott> it's not really to do with "case" specifically.
06:18:42 <merijn> zvrba: All patterns are required to have the same type and the compiler will check that
06:18:44 <zvrba> is there arbitrary structural pattern matching in Haskell?
06:18:52 <elliott> no. that would violate parametricity
06:19:00 <zvrba> what do you mean by parametricity?
06:19:07 <merijn> zvrba: You can do it, but you probably shouldn't and it's in any case not really production code or newbie friendly
06:19:16 <merijn> (i.e. Typeable abuse)
06:19:17 <zvrba> ok.
06:19:28 <elliott> well, Typeable doesn't really let you do exactly that, anyway.
06:19:34 <merijn> True
06:19:39 <zvrba> I'm asking from the perspective of C++ "concepts" and working of templates ;)
06:19:51 <zvrba> anyway
06:19:56 <elliott> perhaps you want a typeclass. (however, people think they want typeclasses far more often than they really do)
06:19:57 <zvrba> i got my answer :)
06:20:16 <zvrba> elliott: nono, I want to write a function that can distinguish between 2-, 3-, n-tuples and single functions
06:20:22 <zvrba> s/functions/parameters/
06:20:28 <zvrba> and give a different result for each
06:20:32 <merijn> zvrba: What's the usecase?
06:20:36 <zvrba> like, for example, dot-product
06:20:37 <b2coutts> zvrba: what function do you want to write, specifically?
06:20:55 <zvrba> and I don't want a general library because I'm working in up to 4 dimensions
06:20:58 <merijn> zvrba: There's lots you can do, but which of those is right (if any) depends on the specific problem
06:21:07 <zvrba> hmm
06:21:08 <zvrba> ok
06:21:09 <b2coutts> zvrba: well, one option is to use lists for that
06:21:12 <elliott> zvrba: you can do something like that with a typeclass. but it's generally a bad idea.
06:21:27 <zvrba> I don't have any specific problem at hand. I found it weird that I can't pattern-match structurally
06:21:41 <elliott> well, values only have one type, roughly.
06:21:49 <b2coutts> when I need arbitrary-length tuples, where all things have the same type, I generally think lists
06:21:52 <elliott> if something's a pair, it can't possibly be a triple.
06:22:05 <zvrba> sure, I get that
06:22:58 <b2coutts> actually, dot product using lists seems like a good example for beginners to me
06:22:59 <merijn> zvrba: Well, one way to deal with things like that would be to wrap the types in another type like "data Vector a = TwoTuple (a,a) | TripleTuple (a,a,a) | List [a]"
06:23:00 <zvrba> anyway, back to book. I'm just playing with random stuff while reading.
06:23:01 <b2coutts> I wonder why it isn't used
06:23:18 <zvrba> oh.
06:23:19 <merijn> zvrba: That would let you match all three in one case
06:23:24 <zvrba> another question.
06:23:27 <Hafydd> Please don't use the word "Vector" for that.
06:23:37 <zvrba> how do you write generic floating-point code?
06:23:45 <zvrba> I wrote a function f1 :: Float -> Float
06:23:50 <zvrba> f2 :: Double -> String
06:23:51 <merijn> zvrba: Because the compiler "knows" TripleTuple is followed by (a,a,a)
06:23:59 <zvrba> and couldn't figure out how to compose f1 and f2
06:24:15 <merijn> zvrba: "f :: Floating a => a -> a -> a" or "f :: Fractional a => a -> a -> a"
06:24:21 <Aetherspawn> Aww yeah
06:24:22 <merijn> :t realToFrac
06:24:22 <lambdabot> (Fractional b, Real a) => a -> b
06:24:23 <Aetherspawn> got lambdabot working
06:24:32 <zvrba> ah, I should have used Fractional instead of FLoating
06:24:36 <merijn> :t realToFrac :: Float -> Double
06:24:36 <lambdabot> Float -> Double
06:24:45 <Aetherspawn> The join command is intermittent. Sometimes it doesn't fire right.
06:24:46 <zvrba> I tried to do arithmetic and it broke down
06:25:11 <merijn> zvrba: It takes a bit to get used to the numerical hierarchy
06:25:26 <zvrba> merijn: hmm, the stuff with TripleTuple seems a bit reduntant, but ok.
06:25:49 <merijn> zvrba: In general, if you have Float/Double of the wrong type you want realToFrac, in case of Integrals, fromIntegral
06:25:56 <merijn> zvrba: You did C++, right?
06:26:08 <zvrba> yes
06:26:15 <zvrba> i DO c++ for living
06:26:20 <merijn> zvrba: Think of "Vector a" as a tagged union, the constructor name is the tag that indicates what the rest of the type will be
06:26:39 <merijn> zvrba: So the "TripleTuple" bit is what lets the compiler figure out what's in the union
06:26:45 <zvrba> merijn: thanks, but you don't have to spoon-feed me. I have dabbled in SML/OCaml previously :)
06:27:03 <zvrba> merijn: I was just surprised that I can't pattern-match structurally.
06:27:14 <zvrba> is there any description of the numerical hierarchy?
06:27:37 <merijn> zvrba: Ah, yeah, ocaml does structural subtyping, haskell doesn't
06:27:52 <b2coutts> I think lyah does a quick overview of the different numeric types fairly early on
06:28:06 <zvrba> it does, but it doesn't discuss how to mix them
06:28:18 <b2coutts> zvrba: have you gotten to typeclasses yet?
06:28:35 <merijn> This one seems ok
06:28:36 <merijn> http://academic.udayton.edu/saverioperugini/courses/cps343/lecture_notes/images/typeclass.png
06:28:53 <b2coutts> you can make your functions more generic by doing something like "f :: (Num a, Num b) => a -> b" instead of "f :: Float -> Float"
06:29:00 <zvrba> b2coutts: no. just past the short part on Ord, Eq, but the mechanism isn't described
06:29:31 <zvrba> ok.
06:29:41 <b2coutts> zvrba: typeclasses are a cool way of taking arguments based on some abstract behaviour they can have, rather than their actual structure
06:29:53 <b2coutts> which is more often what a function needs in its arguments anyway
06:30:24 <ion> merijn: Inspired by the image: import Foo ((+, -, *), bar, baz)
06:30:29 <ion> ;-)
06:30:31 <b2coutts> i.e., you don't need an argument of a specific structure/type, you just need an argument a that will make the "a*2" in your function make sense
06:30:44 <zvrba> i know, typeclass ~ interface
06:30:52 <zvrba> (roughly)
06:31:34 <zvrba> but there's a huge number of typeclasses in Haskell :S
06:32:07 <Philonous> @seen snoyberg
06:32:07 <lambdabot> $N0ybERG
06:32:15 <Philonous> What
06:32:20 <Hafydd> Hahah.
06:32:20 <ion> :-D
06:32:25 <ion> @botsmack
06:32:25 <lambdabot> :)
06:32:49 <ion> preflex: seen snoyberg
06:32:49 <preflex>  snoyberg was last seen on #haskell 67 days, 22 hours, 7 minutes and 10 seconds ago, saying: twoolie: https://www.fpcomplete.com/hoogle?q=mkMigrate http://haddocks.fpcomplete.com/fp/7.4.2/20130313-1/persistent-template/Database-Persist-TH.html#v:mkMigrate http://haddocks.fpcomplete.com/fp/7.4.2/20130313-1/persistent-template/src/Database-Persist-TH.html#mkMigrate
06:33:06 <Philonous> preflex:  seen snoyman
06:33:06 <preflex>  Sorry, I haven't seen snoyman
06:33:11 <Philonous> Thanks
06:35:25 <hpaste> tdammers pasted “types types types (lens lens lens)” at http://hpaste.org/90266
06:35:31 <mikeplus64> there should be type records, for type level meta-data
06:35:47 <tdammers> anyone feel like taking a look?
06:36:17 <ion> tdammers: I think the problem is that docClipList is polymorphic, lens isn’t.
06:36:24 <mikeplus64> then we can have type level lenses
06:36:46 <tdammers> ion: I'm wondering how this actually works in the first place
06:37:09 <tdammers> oh wait, yes of course
06:37:40 <tdammers> hmm, so I'd have to pass it in twice, to instantiate it for both types, right?
06:38:52 <hpaste> tdammers annotated “types types types (lens lens lens)” with “types types types (lens lens lens) (annotation)” at http://hpaste.org/90266#a90267
06:39:41 <tdammers> is there a way to boil this down to something of the form \f lens without resorting to TH?
06:41:37 <merijn> Why is there no "foo f = modify f >> get" combinator anywhere? :\
06:41:52 <merijn> Or why does modify return (), that's silly...
06:41:59 <elliott> merijn: you can do that... with lens!
06:45:37 <xplat> id >%= f , i think it was?
06:46:28 <elliott> :t (id <%=)
06:46:28 <lambdabot>     Not in scope: `<%='
06:46:28 <lambdabot>     Perhaps you meant `<=' (imported from Data.Ord)
06:46:33 <elliott> er, right. ugh
06:46:39 <elliott> note to self: finish new @run plugin by tomorrow
06:46:50 <xplat> elliott: ?
06:48:17 <elliott> xplat: lambdabot doesn't have lens right now
06:48:43 <elliott> xplat: but I'll have to recompile the whole thing to get it working because of Safe Haskell issues, so I'm waiting until I finish the half-done much-faster @run replacement I'm working on first.
06:49:38 <bscarlet> Ralith: "cache oblivious" is "oblivious" to the sizes and structures of the various caches - i.e. not tuned with magic numbers.
06:49:42 <tdammers> merijn: https://github.com/ekmett/lens/wiki/Operators
06:50:29 <tdammers> %= is roughly modify, <%= is modify-and-return-result, <<%= is modify-and-return-previous-value
06:50:38 <ion> tdammers: FWIW, this seems to work. Dunno if that helps. let f :: s -> b -> Lens s t a b -> (t, a); f ab c l = (ab & l .~ c, ab ^. l) in f ("foo", "bar") 42 _2
06:51:01 <tdammers> lemme try that
06:51:23 <elliott> xplat: ...assuming that's what the ? was about
06:52:01 <ion> tdammers: I had to give it the type signature for it to work.
06:52:14 <tdammers> hmm, yeah I suspected something like that
06:52:24 <tdammers> but couldn't figure out the correct type
06:52:36 <ion> Probably because type Lens … = forall f. Functor f => …
06:52:45 --- mode: ChanServ set +o elliott
06:52:56 --- mode: elliott set +b *!~IanMc@*
06:52:58 --- mode: elliott set -o elliott
06:53:23 <mm_freak> Int -> Maybe Int is a Maybe-coalgebra, right?
06:54:26 <elliott> mm_freak: a function f :: Int -> Maybe Int is, AIUI
06:54:32 <elliott> but the type Int -> Maybe Int itself isn't
06:55:14 <mm_freak> that's what i meant, thanks
06:55:31 <mm_freak> and f :: a -> Maybe a is a family of coalgebras?
06:55:41 <elliott> sounds right to me
06:55:47 <elliott> IANACT, I just play one on IRC
06:56:12 <mm_freak> thx, mr. abbrev. =P
06:58:15 <ion> I suppose it went toward something like this when inferring the type: Functor f => s -> b -> ((a -> f b) -> s -> f t) -> (t, a) (which doesn’t work because our code needs to give it a Mutator dictionary at one point and an Accessor dictionary at another)
06:58:23 <ion> Fixed by providing it this type: f :: s -> b -> (forall f. Functor f => (a -> f b) -> s -> f t) -> (t, a)
06:58:46 <ion> a.k.a. s -> b -> Lens s t a b -> (t, a)
07:01:31 <merijn> tdammers: I know lens can do it, but I'm not introducing lens into this code quite yet
07:01:46 <merijn> I was just confused by modify's silly type
07:01:51 <tdammers> right
07:01:56 <elliott> merijn: give in. submit to the urge.
07:02:16 <tdammers> in that case, can't you just make a little function that combines modify and get into one state action?
07:02:40 <tdammers> modify' f = modify f >> get
07:03:40 <elliott> 14:41:15 <merijn> Why is there no "foo f = modify f >> get" combinator anywhere? :\
07:03:43 <elliott> :)
07:03:54 <tdammers> hehe
07:03:57 <tdammers> missed that
07:04:24 <tdammers> but yeah, why not just write that one-lines yourself and put it somewhere convenient?
07:12:24 <fruitFly> i installed somehting on my linux machine using cabal, how do i find out where it installed to?
07:12:30 <xplat> cache-tuned can be much better than cache-oblivious, and is also available for algorithms that cache-oblivious is not -- however, cache-oblivious is also way better than *wrongly* cache-tuned, and sometimes it's pretty hard to even tell how many caches you're dealing with in modern architectures, never mind tune for them correctly
07:12:54 <elliott> fruitFly: most likely ~/.cabal and ~/.ghc
07:13:05 <elliott> if it's an executable it'll be in ~/.cabal/bin
07:13:14 <bscarlet> Is there any documentation for what Distribution.Simple.Setup.haddockProgramArgs means? It's a [(String, [String])].
07:13:41 <bscarlet> (I guess I probably mean HaddockFlags(haddockProgramArgs)
07:13:43 <bscarlet> )
07:13:56 <xplat> well, i should say 'can be much better' rather than 'is much better' -- some cache-oblivious algorithms that have been found, of course, have so much overhead as to be useless in practice
07:13:58 <Aetherspawn> @cd /
07:13:58 <lambdabot>  /
07:14:01 <Aetherspawn> @cd /root
07:14:01 <lambdabot>  /root
07:14:09 <Aetherspawn> yeah, some guy is snooping around my vps with that
07:14:10 <Aetherspawn> -___-
07:14:14 <elliott> wat
07:14:20 <elliott> @cd asjdsdkjfsdjf
07:14:20 <lambdabot>  asjdsdkjfsdjf
07:14:21 <xplat> elliott: yeah, that's what the ? was about, thanks.  excited to hear about a faster @run!
07:14:28 <elliott> I don't think that command does what you think :P
07:14:31 <Aetherspawn> Oh lol
07:14:44 <elliott> it's being corrected to, uh, I don't know, @do or something
07:14:47 <elliott> @help cd
07:14:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:14:50 <elliott> meh
07:15:03 <fruitFly> elliott: where is cabal? ~ just fills the fluff and instigates a search, right?
07:15:19 <elliott> ~ stands for your home directory
07:15:29 <elliott> xplat: :)
07:18:47 <xplat> @do /root
07:18:48 <lambdabot> <unknown>.hs: 1: 1:Parse error: /
07:18:57 <xplat> i guess it's not @do ...
07:19:18 <Aetherspawn> gah
07:19:23 <Aetherspawn> hoogle data gives me "Killed"
07:20:08 <xplat> gah, what happened to my existing lambdabot query?
07:20:14 <fruitFly> how do i find where /.cabal is located?how to search in linux?
07:20:22 <Aetherspawn> ~/.cabal/
07:20:28 <elliott> fruitFly: /home/yourname/.cabal, where yourname is your username
07:20:39 <elliott> xplat: probably got turned into Guest followed by a bunch of numbers
07:20:50 <elliott> xplat: we had some issues where both my lambdabot and Cale's lambdabot were running simultaneously and fighting for the nick ;)
07:21:25 <fruitFly> elliott: not there :S
07:24:05 <elliott> are you sure you have it installed at all?
07:30:29 <Aetherspawn> hoogle data all
07:30:33 <Aetherspawn> worse idea..
07:30:38 <Aetherspawn> *worst
07:35:43 <xplat> elliott: ah.  man, it sucks after all the trouble i went to to get a consistent set of window numbers across restarts that it can get messed up by something like that.  even after i killed both the guest and new queries i still had to move the new-new query to the right window by hand ...
07:36:19 <elliott> xplat: yeah, irssi's handling of nick changes is really awful, it should have some way of merging windows or do it automatically...
07:41:49 <hpaste> efie pasted “cabal install llvm fails” at http://hpaste.org/90268
07:42:32 <efie> do you know how this can be solved?
07:42:52 <elliott> efie: that's caused by using a buggy TH version, IIRC
07:43:02 <elliott> you should always use the TH version that comes with the compiler
07:43:18 <elliott> efie: take a look at https://github.com/ekmett/lens/issues/276
07:44:00 <ion> The TNG remix pops into my head every time someone says “take a look at (this)”.
07:45:36 <Philonous> ion:  what TNG remix?
07:46:19 <ion> → #-blah
07:47:26 <hpaste> niteria pasted “hsenv, cabal segfault” at http://hpaste.org/90269
07:48:01 --- mode: ChanServ set +o elliott
07:48:08 --- mode: elliott set +b *!*@*176.24.235.136
07:48:10 --- mode: elliott set -o elliott
07:52:19 <hpaste> niteria pasted “hsenv, cabal install snap segfault” at http://hpaste.org/90271
07:52:34 <niteria> is it hsenv, cabal or ghc segfaulting?
07:53:16 <elliott> looks like not ghc
07:53:32 <efie> elliott: thanks!
07:53:38 <supki> strace?
07:53:57 <elliott> efie: :)
07:54:43 <kqr> i have gathered that Text is basically what other languages call String, and ByteString is only used for serialisation. String is an abomination that shouldn't really be in the language. am i correct?
07:55:01 <ion> kqr: No.
07:55:04 <mm_freak> kqr: actually most other languages call ByteString String
07:55:17 <kqr> mm_freak, so what makes Text different?
07:55:27 <ion> kqr: String has its uses. Text is for text and ByteString is for arrays of bytes indeed.
07:55:29 <mm_freak> kqr: characters instead of bytes
07:55:36 <kqr> ion, what uses does String have?
07:55:48 <kqr> mm_freak, right. doesn't Java and Python do that as well?
07:55:51 <ion> mm_freak: Many languages do have a native Unicode string type nowadays. That’s akin to Text.
07:56:25 <mm_freak> kqr: dunno about java, but python took a few major versions before it recognized that byte strings are bad ;)
07:57:29 <kqr> haha sure, i'm mostly working in py3k
07:57:34 <mm_freak> String is simple and easy to work with…  it's fast enough for most applications
07:57:37 <ion> kqr: Anything you’d find a linked list of characters useful for. Fusion can also make them very fast when used right.
07:57:54 <mm_freak> Text is very fast and reasonably compact to handle huge amounts of text
07:58:07 <Philonous> ion:  But we have fusion on Text too, don't we?
07:58:15 <ion> philonous: Probably.
07:58:24 <niteria> supki: http://students.mimuw.edu.pl/~bn291697/misc/strace
07:58:25 <mm_freak> we do
07:58:31 <niteria> doesn't look interesting
07:59:01 <kqr> is String unicode aware?
07:59:05 <mm_freak> kqr: yes
07:59:06 <ion> kqr: Yes.
07:59:16 <ion> Both String and Text are representations of Unicode.
07:59:16 <mm_freak> kqr: in fact it isn't byte-aware
07:59:19 <kqr> so the big difference between Text and String is performance?
07:59:31 <kqr> (for large amounts of text, i guess)
07:59:35 <mm_freak> and strictness
07:59:43 <mm_freak> > repeat 'a'
07:59:43 <elliott> String and lazy Text represent the same thing, but differently.
07:59:43 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
07:59:50 <elliott> String and strict Text are rather different
08:00:03 <kqr> okay
08:00:39 <kqr> when reading on reddit i got the impression that String is almost always a bad idea and Text is preferable in most cases
08:00:43 <mm_freak> if build strings character by character you should probably use String
08:00:44 <kqr> but it doesn't really seem that way in here
08:00:50 <Aetherspawn> how big is hackage approximately?
08:01:00 <Aetherspawn> is it <1 tb?
08:01:03 <mm_freak> you could also use lazy Text builders (Data.Text.Lazy.Builder), but they are less convenient and probably still slower
08:01:40 <mm_freak> lazy Text is really more [Text] than String
08:02:07 <elliott> Aetherspawn: if you just care about latest versions see http://hackage.haskell.org/packages/hackage.html
08:02:18 <kqr> mm_freak, is lazy Text implemented as chunks of strict Text?
08:02:23 <mm_freak> kqr: yes
08:02:27 <quchen> Aetherspawn: I heard it's about ~10 GiB.
08:02:33 <quchen> Remember it's mostly source code.
08:02:36 <ion> Also, lazy ByteString is implemented as chunks of strict ByteString.
08:02:49 <elliott> type WayTooLazy = [String]
08:03:04 <quchen> Aetherspawn: Those 10 gigs may be when compiled though.
08:03:06 <ion> type LazyString = [String]  -- Chunks of String!
08:03:14 <mm_freak> kqr: see fromChunks and toChunks
08:03:15 <elliott> ion: you stole my joke. :(
08:03:30 <elliott> type BasicallyWastingItsLife = [[String]]
08:03:32 <ion> elliott: Sorry, i wasn’t paying attention.
08:03:44 <kqr> mm_freak, ah, right. i just vaguely remember reading something about erlang handling string building in a similar way so i tried to look it up but can't find it
08:03:53 <elliott> ion: sorry, but I can never forgive you.
08:03:53 <Aetherspawn> blah
08:03:54 <mm_freak> > TL.fromChunks (repeat (T.singleton 'a'))
08:03:55 <lambdabot>   Not in scope: `TL.fromChunks'
08:03:55 <lambdabot>  Perhaps you meant one of these:
08:03:55 <lambdabot>    `BSL.from...
08:04:01 <Aetherspawn> I should have forked hoogle data all
08:04:05 <ion> elliott: I have no choice but to commit hiragana.
08:04:08 <mm_freak> > Data.Text.Lazy.fromChunks (repeat (T.singleton 'a'))
08:04:09 <lambdabot>   Not in scope: `Data.Text.Lazy.fromChunks'Not in scope: `T.singleton'
08:04:09 <lambdabot>  Perha...
08:04:10 <Aetherspawn> Now I have to leave my ssh session open overnight or it'll die
08:04:17 <ion> Perha... indeed.
08:04:48 <mm_freak> Aetherspawn: press ^Z, then type "bg"
08:04:50 <hpaste> niteria pasted “cabal: internal error: evacuate: strange closure type 144” at http://hpaste.org/90272
08:04:53 <ion> > Text.singleton 'a'
08:04:54 <lambdabot>   Not in scope: `Text.singleton'
08:04:54 <lambdabot>  Perhaps you meant one of these:
08:04:54 <lambdabot>    `Seq.sin...
08:05:02 <kqr> ion, committing hiragana sounds awful
08:05:05 <ion> > Data.Text.singleton 'a'
08:05:06 <lambdabot>   Not in scope: `Data.Text.singleton'
08:05:13 <kqr> ion, sure you wouldn't want to try katakana instead?
08:05:17 <mm_freak> Aetherspawn: but closing the shell will probably still kill it
08:05:23 <byorgey> gspr: I'm flattered that you respect my opinion, but you would be very silly indeed to trust my opinion on matters related to C, the FFI, etc. ;-)
08:05:25 <Aetherspawn> :\
08:05:29 <mm_freak> Aetherspawn: you should have opened it in a screen session
08:05:30 <niteria> I don't understand why it reports ghc 7.4.1
08:05:40 <Aetherspawn> Yeah I didn't think there would be sooo many packages
08:05:58 <elliott> you can ^Z, disown
08:06:02 <elliott> at least I think that will work
08:06:14 <mm_freak> elliott: no
08:06:23 <mm_freak> it will receive a SIGHUP once the terminal is closed
08:06:33 * elliott would trust byorgey on everything from the FFI to buying a house to beekeeping.
08:06:48 <elliott> mm_freak: look at "help disown"
08:06:59 <niteria> there was a tool that let you move running process to screen
08:06:59 <chrisdone> byorgbee
08:07:00 <merijn> @quote goat's.blood
08:07:00 <lambdabot> malig says: I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
08:07:01 * mm_freak would trust byorgey on everything except monad tutorials
08:07:40 <mm_freak> elliott: i'm aware of disown and that's my experience
08:07:45 <elliott> hmm.
08:07:45 <ion> Hmm, i might be doing something wrong, but this didn’t write to /tmp/hup. sh -c 'trap "echo HUP >/tmp/hup" HUP; sleep 10' & disown; exit
08:07:50 <elliott> well it works if you do "foo & disown"
08:07:55 <elliott> but maybe foo \n ^Z \n disown doesn't
08:07:59 <mm_freak> elliott: the problem is, the shell and the process share and write to the terminal
08:08:03 <merijn> mm_freak: I think I know how to answer my own question about how to make View comonadic, I can just abuse laziness to already apply the view to the UI that results from the entire thing
08:08:15 <elliott> mm_freak: oh, so it works if you >/dev/null the process or whatever?
08:08:16 <mm_freak> elliott: both get killed by SIGHUP or a write error once the terminal is closed
08:08:20 <mm_freak> elliott: yeah
08:08:23 <merijn> Laziness and tying the knot is evil voodoo >.>
08:08:34 <thakhad-24> Hello, I have a question: is there a build tool for Haskell like Ant or Maven that integrates steps like code quality reporting into a continuous integration server?
08:08:35 <ion> Without ^Z, disown without fg in between?
08:08:41 <ion> s/Without //
08:08:50 <mm_freak> merijn: i'm not sure i understand that
08:08:54 <ion> Ok, i got a HUP.
08:09:14 <ion> err, bg
08:09:55 <mm_freak> ion: "disown" and "hg && disown" are pretty much the same thing, when you have a suspended background process
08:10:17 <merijn> mm_freak: Well, I was going to use the View to look up the state belonging to said Widget (which is somewhere in the tree of Widgets), but "Comonad View" means that I should be able to produce an "a" from "View a", which doesn't let me use the resulting Widget tree to look up said value
08:10:18 <niteria> Aetherspawn: reptyr may help
08:11:32 <Aetherspawn> reptyr..
08:11:44 <Aetherspawn> Oh I see.
08:11:47 <Aetherspawn> Yeah that'd be useful.
08:11:51 <mm_freak> Aetherspawn: i'd just restart it…  chances are it's finished anyway when you wake up =)
08:12:03 <mm_freak> this time start it in a screen session or something
08:12:06 <elliott> I'd just use the default Hoogle data set
08:12:10 <elliott> it takes like five seconds
08:12:10 <Aetherspawn> :P it's up to M
08:12:10 <mm_freak> then you can safely leave your SSH session
08:12:11 <merijn> But I just realised I can change "View a -> UI -> a" into just "View a -> a" if I assume I already have the UI in the Widget, which I can do by just feeding the result of building the UI into the resulting UI
08:12:22 <askalski> hi
08:12:31 <askalski> I have a question on parallel computation
08:12:51 <askalski> anyone here?
08:13:09 <mm_freak> merijn: the view captures only the current value
08:13:11 <elliott> @@ askalski: @where justask
08:13:11 <lambdabot>  askalski: Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
08:13:24 <askalski> right
08:13:30 <niteria> this looks like ghc crashing, might be cabal version mismatch, but I thought hsenv was supposed to take care of that
08:13:34 <elliott> :)
08:13:38 <elliott> and yes, there's about a thousand people here
08:13:41 <askalski> I have a list that can and should be computed in parallel
08:14:42 <elliott> you might want to look into strategies: http://hackage.haskell.org/packages/archive/parallel/3.2.0.3/doc/html/Control-Parallel-Strategies.html
08:15:08 <elliott> e.g., something like (xs `using` parList rseq)
08:15:17 <mm_freak> askalski: if the list can be computed in parallel, it can probably be expressed as 'map f xs'
08:15:23 <elliott> there's also "parMap"
08:15:27 <askalski> I have a recipe for calclulation - three lists of independent calculations, but each of them requires previous to be computed first
08:16:09 <askalski> how to do it?
08:16:10 <mm_freak> askalski: express all three lists as maps of the previous one
08:16:22 <mm_freak> is that possible?
08:16:35 <mm_freak> because then all you need to do is to rewrite "map f" as "parMap rdeepseq f"
08:16:50 <mm_freak> note:  the lists must be finite for that to work, otherwise see parBuffer
08:16:59 <thakhad-24> askalski: That sounds like a concurrent problem.
08:17:10 <askalski> yes, it's a floyd-warshall in parallel
08:17:46 <mm_freak> askalski: the way i understood is:  you have a list xs0, from which you calculate:  xs1 = map f xs0
08:17:54 <mm_freak> then xs2 = map g xs1
08:18:00 <mm_freak> then xs3 = map h xs2
08:18:05 <mm_freak> does it fit that pattern?
08:18:16 <askalski> first I compute pivot (but that's simple), then I compute pivotRow and pivotColumn (these require only pivot to be computed) and then everything else (these require pivot-row and pivot-column to be done first)
08:18:46 <askalski> mm_freak, the final one is tricky, since I need to address these cells via array indices
08:19:38 <askalski> mm_freak, I can still though just generate a list of computed cells, and then assign them to array,
08:19:42 <askalski> so not that bad
08:19:57 <elliott> woo, after only... 4 hours? my GHC build is almost done...
08:19:58 <mm_freak> askalski: maybe you should use vectors and vector strategies instead of lists
08:20:14 <xplat> optparse-applicative seems pretty nifty
08:20:21 <monochrom> elliott: recently it's just 1 or 1.5 hours on my laptop :)
08:20:35 <monochrom> http://www.vex.net/~trebla/haskell/I-built-GHC.xhtml
08:21:09 <elliott> monochrom: Homebrew forces -j1 for GHC for some reason, so it's incredibly slow
08:21:23 <elliott> bah! the one reason I built it was for source links in the documentation, and they're not there
08:21:26 <elliott> time for another four hours
08:21:46 <mm_freak> elliott: just run haddock again?
08:21:48 <monochrom> oh, -j1 would be 2 or 3 hours in my case :)
08:22:14 <monochrom> do you have hscolour? you need that for source links
08:22:28 <mm_freak> you also need to tell haddock to generate them
08:22:31 <elliott> monochrom: yeah, I do
08:22:36 <mm_freak> --hyper or something like that
08:22:40 <elliott> but perhaps it's not getting into the $PATH
08:22:55 <xplat> but i'm not sure that it doesn't have a fundamental problem with multiply-occurring arguments :-/
08:23:10 <mm_freak> xplat: why would it?
08:23:15 <monochrom> did it build docs at all?
08:23:59 <elliott> monochrom: yep
08:25:11 <xplat> mm_freak: because the way that command-line options are composed into a summary is utterly independent of their ordering, and multiply-occurring command-line arguments tend to care what order they occur in, even relative to other arguments
08:25:50 <xplat> er, s/arguments/options
08:27:18 <monochrom> elliott: in the long output of ./configure, somewhere it says whether it finds hscolour or not. hope this saves several hours of waiting and disappointing
08:27:31 <elliott> monochrom: yeah, investigating that now
08:27:46 <elliott> seems like it's using a PATH without /usr/local/bin in it, so no HsColour. my horrible plan: just move it to /usr/bin temporarily
08:29:55 <xplat> hm, maybe there's a way to abuse the 'argument' parser to do it though ...
08:34:59 <askalski> ok, so I tried with rparMap deepseq
08:35:08 <askalski> it works, but when I benchmark it
08:35:16 <askalski> I see that still only one processor core is used
08:35:31 <askalski> so is there something I need to set up ...
08:36:33 <elliott> askalski: try building with -threaded -rtsopts and pass +RTS -N<cores> to the program
08:37:02 <askalski> elliott, ok, is it possible to get this "N" value within the code?
08:37:09 <askalski> elliott, that would help me a lot
08:37:20 <elliott> uh, I think so. getCapabilities or something in some module or another.
08:37:39 <elliott> ideally if you're doing parallel stuff you shouldn't have to think about it
08:38:09 <askalski> elliott, well, this alg vivides a super big matrix to N^2 submatrices
08:38:27 <askalski> elliott, and chosing right N is essential, and it's always bound with number of cores
08:38:43 <elliott> right
08:39:04 <mjo> import Ghc.Conc; n <- getNumProcessors; setNumCapabilities n;
08:39:44 <xplat> oh, hm, maybe it would work by putting several options inside the same 'many'!  that actually makes sense!  :)
08:39:44 <mjo> That's the lazy way to give other people your parallel code without having to teach them to use the command line
08:41:39 <merijn> mjo: You can set cabal to pass implicit flags to your code to, I think
08:42:22 <mjo> that replaces the problem of the user not knowing how to do that with me not knowing how to do that =)
08:43:15 <merijn> mjo: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html 4.17.1.2
08:43:37 <merijn> You can compile with -with-rtsops="blah"
08:43:50 <merijn> And blah will be the default runtime options, unless overwritten
08:44:25 <elliott> you can just +RTS -N and it'll pick a number :P
08:44:34 <elliott> with with-rtsopts
08:45:22 <mjo> Oh, yeah, but I don't see a way to set it to the number of processors on the target machine (which in theory may not even be the build machine)
08:45:48 <mjo> Running with -N might do that, but I don't think it's guaranteed
08:45:51 <merijn> mjo: The -N option should default to num capabilities == num CPUs
08:46:17 <monochrom> I guarantee it
08:46:29 <mjo> problem solved
08:47:13 <elliott> monochrom: does that mean I can complain to you if it doesn't work?
08:47:25 <mjo> I just moved those two lines of IO so far out of my program they run in somebody else's program. The haskell way.
08:47:29 <merijn> elliott: Sure, how is he going to stop you? :p
08:47:44 <monochrom> yes, please complain to me :)
08:47:51 <Aetherspawn> .@hoogle+ isn't doing anything anymore
08:47:55 <Aetherspawn> too many packages I guess...
08:48:34 <elliott> merijn: he could /ignore me!
08:49:08 <chrisdone> then you could ask lambdabot to say mean things to him on your behalf like a school kid
08:49:30 <Aetherspawn> @vixen
08:49:30 <lambdabot> Scrubbing floors and emptying bedpans has as much dignity as the Presidency.
08:49:30 <chrisdone> > "monochrom your hair is funny and you smell of elderberries"
08:49:32 <lambdabot>   "monochrom your hair is funny and you smell of elderberries"
08:49:40 <Aetherspawn> @vixen
08:49:40 <lambdabot> I don't want to see this country to go that way.  You know what happened to the Greeks.  Homosexuality destroyed them. Sure, Aristotle was a homo, we all know that, so was Socrates.
08:49:51 <elliott> that's @nixon
08:49:55 <monochrom> my hair is funny, but I don't know elderberries
08:50:08 <xplat> @wn elderberry
08:50:10 <lambdabot> *** "elderberry" wn "WordNet (r) 3.0 (2006)"
08:50:10 <lambdabot> elderberry
08:50:10 <lambdabot>     n 1: a common shrub with black fruit or a small tree of Europe
08:50:10 <lambdabot>          and Asia; fruit used for wines and jellies [syn:
08:50:10 <lambdabot>          {bourtree}, {black elder}, {common elder}, {elderberry},
08:50:12 <lambdabot>          {European elder}, {Sambucus nigra}]
08:50:14 <lambdabot>     2: berrylike fruit of an elder used for e.g. wines and jellies
08:50:26 <chrisdone> is it a requirement of the vixen plugin that it be mildly offensive to at least some demographic in the channel?
08:50:46 <elliott> it's just an autocorrection, nothing intentional
08:50:50 <xplat> chrisdone: it's a requirement of any plugin that matches when you type @vixen
08:51:25 <Saizan>  @vixen itself was less likely to be offensive, actually
08:51:33 <monochrom> chrisdone: did you see http://www.vex.net/~trebla/vixen.txt ?
08:51:41 <Saizan> though i wonder why we're keeping @nixon atm
08:51:46 <merijn> Aetherspawn: vixen was removed, it's currently autocorrecting to @nixon
08:52:24 <askalski> mm_freak, ok, I wrote it and fired, but it seems like a second thread does nothing (2 core CPU)
08:52:30 <monochrom> (summary: "what have I done"  XD )
08:52:55 <chrisdone> monochrom: yeah =p
08:52:58 <Aetherspawn> bawh
08:53:19 <elliott> Saizan: well, @nixon is quotation, not generation. though I have no attachment to @nixon
08:54:20 <robde> hello. when I have an expression like (f 10) + (f 10), will ghc optimize the program so that f10 is only calculated once?
08:54:45 <chrisdone> robde: it's likely. if you want to be sure, you can look at the core with -fext-core
08:54:47 <Aetherspawn> I believe thats the point of CNS(?)
08:54:53 <byorgey> robde: generally speaking, no.  If you want f 10 only calculated once you must give it a name, like let x = f 10 in x + x
08:55:03 <Saizan> elliott: yeah, i just don't think we do political satire enough to make @nixon useful, it's nice when bots have a bit of colour but it's a tradeoff
08:55:39 <xplat> it's interesting to see how many random different opinions people have about what is offensive and to whom and why
08:56:09 <elliott> Saizan: yes, it's more that nobody has seemingly really called for/cared about the removal of @nixon except rhetorically in support of @vixen, so it stays by default. if anyone would really like it gone then I can get rid of it, but frankly the quote plugin has a lot of dubious commands that should probably go at the same time
08:59:31 <Saizan> xplat: offense is probably not even the right concept, but a lot of it comes down to trust i find
08:59:53 <chrisdone> robde: i checked core, in this case, nope
09:00:38 <augur> i feel like there should be some way to determine what components of an expression are genuinely referentially transparent
09:00:59 <chrisdone> ah wait, i messed up. yeah, ghc does optimize this case
09:01:35 <chrisdone> so main = print (fib 5 + fib 5) →
09:01:36 <chrisdone> main:main2 :: (ZMZN Char) =
09:01:36 <chrisdone>     %case ((ZMZN Char)) (main:zdwfib (5::Intzh))
09:01:36 <chrisdone>     %of (wws1Il::Intzh) {%_ -> base:itos (zpzh wws1Il wws1Il) (ZMZN @ Char)};
09:01:58 <chrisdone> which is nice. like byorgey says it's not generally assumable, but with -fext-core you can check and gain an intuition about it
09:02:40 <prophile> what's a | in a typeclass used for?
09:02:44 <augur> i mean, what's a situation in haskell where that *doesnt* work? probably something with state or IO, but i cant think of anything offhand
09:02:53 <prophile> eg class A b c | b -> c
09:02:58 <quchen> The Reddit thread about the AMP raised an important issue concerning MonadPlus/Alternative. The MonadPlus laws demand "mzero >>= _ = mzero", therefore "mzero `ap` _ = _ `ap` mzero = mzero". However, there is no corresponding law for Alternative, namely "empty <*> _ = _ <*> empty = empty".
09:03:22 <hpaste> chrisdone pasted “fib and core (robde)” at http://hpaste.org/90275
09:03:24 <robde> chrisdone: for the same parameters a pure function should always return the same falue, right. so why isn’t it assumable?
09:03:25 <elliott> prophile: that's a functional dependency
09:03:25 <quchen> Therefore, setting Alternative => MonadPlus with empty = mzero, <|> = mplus might break more code than expected, no?
09:03:34 <elliott> prophile: http://www.haskell.org/haskellwiki/Functional_dependencies
09:03:59 <elliott> quchen: it won't *break* anything given that the instances will still do the same thing. also, nobody can agree on MonadPlus's laws anyway
09:04:06 <merijn> quchen: Actually, not even "might" "will" break
09:04:25 <merijn> quchen: "empty <|> _ = empty" breaks STM *badly*
09:04:50 <chrisdone> robde: i don't think ghc makes any guarantee about it. and in fact it can be a memory leak to have so-called "sharing" where you bind something to a name and then use it a few times, that name can remain in memory for a long time. i don't know much more than that about it
09:05:08 <merijn> quchen: It will make "stm1 <|> stm2" retry as long as stm1 retries, instead of trying to execute stm2
09:05:09 <Taneb> merijn, nobody is saying "empty <|> _ = empty" is a law
09:05:10 <quchen> merijn: Well crap. So MonadPlus is something entirely different than Alternative+Monad then?
09:05:14 <prophile> elliott: lovely, thanks
09:05:24 <elliott> merijn: wat
09:05:31 <chrisdone> aren't monadplus and alternative isomorphic?
09:05:34 <quchen> Oh, Taneb is right.
09:05:53 <Taneb> > empty <|> "hello"
09:05:54 <lambdabot>   "hello"
09:05:56 <merijn> Taneb: No, but he's saying the default instance would differ in confusing ways
09:05:57 <Taneb> :)
09:05:59 <elliott> the whole *point* of mplus/(<|>) is to catch mzero/empty
09:06:09 <elliott> so I have no idea what you mean
09:06:12 <Taneb> > mzero `mplus` "hello"
09:06:13 <lambdabot>   "hello"
09:06:14 <quchen> merijn: "empty <|> _ = empty" is how STM works right now.
09:06:25 <elliott> ??
09:06:27 <elliott> I seriously doubt that
09:06:27 <quchen> merijn: "retry or _ = retry
09:06:31 <quchen> "
09:06:31 <merijn> quchen: No it's not
09:06:36 <quchen> It's not?
09:06:47 <Taneb> > empty <*> "hello" :: String
09:06:48 <lambdabot>   ""
09:06:56 <chrisdone> > (Just () <|> Nothing,Just () `mplus` Nothing)
09:06:57 <Taneb> THAT is what we are discussing
09:06:57 <lambdabot>   (Just (),Just ())
09:06:59 <merijn> oh
09:07:00 <Taneb> With <*>
09:07:00 <merijn> doh
09:07:01 <Taneb> Not <|>
09:07:05 <merijn> I'm confusing <|> and orElse
09:08:07 <quchen> <|> is not orElse?
09:08:11 <quchen> I'm confused.
09:08:14 <merijn> quchen: I'm not sure anymore
09:08:30 <augur> @src (<|>)
09:08:30 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:08:31 <merijn> quchen: If <|> is orElse, then "empty <|> _ /= empty"
09:08:42 <augur> @src orElse
09:08:43 <lambdabot> Source not found. My brain just exploded
09:08:45 <augur> :|
09:08:47 <merijn> orElse tries the second STM action if the first one fails
09:08:54 <augur> lambdabot's @src never works for me
09:09:02 <Taneb> (<|>) for STM is defined as orElse
09:09:06 <quchen> merijn: instance Alternative STM where
09:09:06 <quchen>     empty = retry
09:09:06 <quchen>     (<|>) = orElse
09:09:08 <elliott> merijn: so???
09:09:10 <merijn> augur: @src is just a lookup table of hardcoded things
09:09:14 <elliott> merijn: nobody has said anything about empty <|> _
09:09:17 <elliott> I'm really confused :P
09:09:23 <elliott> I mean, except you
09:09:28 <Taneb> What was on the table was "empty <*> _ = empty"
09:09:35 <Taneb> Note the asterisk
09:10:11 <augur> quchen brought up <|> tho, guys
09:10:20 <augur> elliott, Taneb ^
09:10:22 <merijn> quchen did mention <|>, but now I'm not sure it was relevant
09:10:30 <augur> who knows!
09:10:38 <Taneb> quchen was rather confused, I presume
09:10:39 <elliott> 17:02:36 <quchen> The Reddit thread about the AMP raised an important issue concerning MonadPlus/Alternative. The MonadPlus laws demand "mzero >>= _ =  mzero", therefore "mzero `ap` _ = _ `ap` mzero = mzero". However, there is no corresponding law for Alternative, namely "empty <*> _ = _  <*> empty = empty".
09:10:43 <augur> conversational confusion is an interesting thing!
09:10:44 <elliott> 17:03:03 <quchen> Therefore, setting Alternative => MonadPlus with empty = mzero, <|> = mplus might break more code than expected, no?
09:10:47 <elliott> 17:04:03 <merijn> quchen: "empty <|> _ = empty" breaks STM *badly*
09:11:21 <Taneb> merijn, you misread the proposed rule
09:11:27 <augur> i presume merijn is correct but irrelevant :)
09:11:28 <quchen> empty <|> x = x  --  empty <*> _ = empty
09:11:41 <augur> in that, if you did indeed define empty <|> _ = empty, it would break STM!
09:11:51 <Taneb> It would also break the Monoid laws
09:11:52 <elliott> quchen: anyway, the change would basically make MonadPlus into a law class if anything.
09:11:57 <quchen> The first one is a law, the second one isn't stated anywhere, but would be implied by the AMP.
09:12:02 <elliott> quchen: but really it's a deprecation of MonadPlus.
09:12:09 <augur> Taneb: well, it wouldnt break them
09:12:11 <quchen> elliott: That's true. I was thinking about that in the long run.
09:12:16 <augur> it would just mean you're in the trivial monoid
09:12:17 <elliott> and then it could be discussed whether to bring mempty <*> _ into Alternative
09:12:30 <elliott> quchen: but the thing is, some people want MonadPlus to have more laws anyway etc.
09:12:41 <elliott> so it's not really that relevant
09:12:44 <Taneb> augur, for any Monoid, mempty <> x == x
09:12:49 <augur> Taneb: yes
09:12:56 <augur> and in the trivial monoid, mempty is the only element
09:13:01 <quchen> Well some people can propose that to the mailing lists. I think it's fairly important that we know all the laws, independent of what people want to add.
09:13:01 <Taneb> augur, aaaaah
09:13:03 <NemesisD> does anyone know any language-agnostic tools for project templates? cabal init isn't cutting it anymore
09:13:04 <augur> so its true that mempty <> _ = mempty :)
09:13:12 <Taneb> augur, I'm on your wavelength now :)
09:13:13 <augur> because x == mempty by necessity!
09:13:13 <prophile> why does MonadPlus even exist anyway, rather than writing an (m a) monoid instance?
09:13:31 <augur> Taneb: but are you on my amplitude?
09:13:39 <Taneb> augur, perhaps, perhaps not!
09:13:42 <quchen> elliott: But as it stands, there is no connection between Alternative laws and Applicative laws.
09:13:48 <augur> Taneb: how quantum
09:13:49 <quchen> (At least according to the docs)
09:13:58 <Taneb> prophile, I think it was originally for stuff like guard and filterM
09:14:08 <Taneb> For with Monad comprehensions
09:14:09 <elliott> quchen: so the question is "if MonadPlus is being deprecated, should Alternative inherit an equivalent of its additional law?"
09:14:24 <prophile> Taneb: sure, but either of those can be defined using a monoid instance rather than monadplus right?
09:14:27 <augur> prophile: m a isn't always a monoid!
09:14:32 <elliott> quchen: I would say probably no but it should be discussed separately. taking a law away is fairly safe, it just means stuff that uses Alternative might just have to declare an additional assumption about the instance.
09:14:42 <prophile> augur: ah, what's the gotcha?
09:14:46 <elliott> adding a law to Alternative might make existing instances invalid, so the conservative thing is not to
09:14:47 <Taneb> prophile, also, the Maybe monoid is very different from the Maybe MonadPlus
09:14:50 <augur> prophile: what do you mean whats the gotcha?
09:14:52 <quchen> elliott: That's part of the question, yes. More importantly, why does no corresponding law for Alternative/Applicative exist already?
09:15:20 <quchen> elliott: Basically, Alternative is completely independent of Applicative if you take the constraint away
09:15:23 <Taneb> Something tells me that law is free
09:15:23 <elliott> quchen: well, look at http://www.haskell.org/haskellwiki/MonadPlus
09:15:24 <prophile> augur: probably a misunderstanding on my part, I understood MonadPlus to be essentially a monoid
09:15:30 <elliott> people wonder "why doesn't MonadPlus have $extra_law?" already
09:16:45 <augur> prophile: i think there are extra laws that people expect monad plus to have which dont necessarily come from monoids maybe?
09:17:05 <quchen> elliott: I would argue that the current state is certainly better than the Alternative scenario, where there are no laws at all
09:17:10 <augur> that is, there are expectations of interaction with the monad operations
09:17:49 <elliott> quchen: of course there are laws
09:18:00 <augur> prophile: m a could be a monad in a boring way that has nothing to do with the monad operations. for instance, if m == [], the monoid operation is (++) but the monad operation is concatMap
09:18:05 <elliott> quchen: the laws are empty <|> x = x <|> empty = x and (<|>) is associative
09:18:27 <quchen> elliott: I meant Applicative related laws
09:18:28 <augur> quchen: cant you just say (empty, <|>) is a monoid? gosh!
09:18:34 <elliott> quchen: sure, so?
09:18:38 <augur> er, elliott ^
09:18:38 <dmwit> > [1..5] `mplus` [10,20..50]
09:18:39 <lambdabot>   [1,2,3,4,5,10,20,30,40,50]
09:18:46 <dmwit> augur: um...
09:18:57 <augur> dmwit: um what
09:19:16 <dmwit> prophile: [a] isn't a MonadPlus in a way that uses concatMap
09:19:19 <quchen> elliott: Isn't that similar to taking the "mzero >>= _ = mzero" laws away from MonadPlus?
09:19:39 <augur> dmwit: mplus is using the Monoid instance of [], not the MonadPlus instance
09:19:45 <augur> isnt it?
09:19:48 <dmwit> :t mplus
09:19:49 <lambdabot> MonadPlus m => m a -> m a -> m a
09:19:52 <elliott> quchen: I really don't understand where you're coming from. let's put it this way, the (mzero >>= _ = mzero) aka (mzero <*> _ = mzero) law has basically *nothing* to do with being a monad.
09:20:03 <elliott> quchen: so even if you want a typeclass to encapsulate that law, "MonadPlus" is the wrong name for it.
09:20:14 <elliott> therefore, the only question is whether to include that law in Alternative when deprecating MonadPlus in favour of it or not
09:20:25 <augur> dmwit: hm, well, either way, the expected laws for MonadPlus involve bind, which for [] is concatMap
09:20:30 <elliott> my argument: don't include it because it's a separate issue. it has not much at all to do with Applicative/Monad
09:20:41 <elliott> instances that still satisfy the stronger MonadPlus law will still satisfy it as Alternatives
09:20:44 <augur> dmwit: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t:MonadPlus
09:21:07 <augur> dmwit: mzero >>= f == v >> mzero == mzero
09:21:11 <elliott> quchen: also, note that
09:21:12 <elliott>  v >> mzero   =  mzero
09:21:18 <elliott> is already violated in practice, IIRC
09:21:26 <elliott> though I forget what by
09:21:33 <dolio> IO
09:21:42 <Taneb> dolio, IO does not implement mzero
09:21:44 <Taneb> Guess again
09:21:46 <elliott> IO isn't listed as an instance on that page, but maybe it's declared as one somewhere else
09:21:52 <augur> dmwit: which is not something you get from monoid alone. monadplus is a monoidal monad, with extra stuff due to the monad structure
09:22:16 <quchen> elliott: mzero >>= _ = mzero is a law that connects monadic >>= and MonadPlus-ic mzero. Why does it have "nothing" to do with being a monad?
09:22:28 <dolio> > mzero :: IO ()
09:22:28 <lambdabot>   <IO ()>
09:22:31 <dolio> You guess again.
09:23:01 <elliott> quchen: because you can consider it as (mzero <*> _ = mzero) too
09:23:02 <quchen> elliott: In other words, why does Alternative need Applicative in the first place? The current version is basically a monoid definition for "* -> *" kinded types
09:23:03 <augur> > let f x = x in f
09:23:04 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t0)
09:23:04 <lambdabot>    arising from a use ...
09:23:07 <elliott> in the shiny new Applicative => Monad world
09:23:07 <augur> darn
09:23:14 <elliott> I am fairly sure they are equivalent
09:23:26 <augur> i was hoping lambdabot had a new and improved show gadget for normally non-showable things :(
09:23:27 <elliott> quchen: ok, so what you actually want is to take away the Alternative superclass?
09:23:37 <elliott> I honestly have no idea what you're proposing or what problem you have
09:23:45 <elliott> er, the Applicative superclass from Alternative, that is
09:23:58 <Taneb> dolio, if you tell me where that is implemented, I will track down the person who wrote it and smack them
09:24:16 <quchen> elliott: Hell no. I guess I should write this up nicely to avoid confusion.
09:25:27 <elliott> quchen: to be clear: I want MonadPlus deprecated in favour of Alternative. I don't care much about whether it stays as Monad m => ... or (Monad m, Alternative m) => ...
09:25:42 <elliott> though the latter will probably catch more breakages.
09:25:47 <FreeFull> How would I go about setting all the values in a data structure to the value of their index using the lens library, other than using imap const?
09:25:52 <quchen> elliott: I agree with that.
09:26:29 <quchen> elliott: So you would drop the MonadPlus laws entirely in the process?
09:26:29 <elliott> ok. then I do not know where the disagreement is
09:26:55 <elliott> quchen: I would leave MonadPlus's laws as they are. I would just add a comment to the start of its documentation saying "This class is deprecated in favour of Alternative and may go away some day."
09:27:08 <elliott> and perhaps a fancy GHC warning on mzero/mplus, if it's not considered too annoying.
09:27:15 <dolio> It isn't hard to come up with examples besides IO.
09:27:40 <elliott> quchen: but, I simply don't believe it matters what the documentation and laws of deprecated, historical relics are
09:28:03 <FreeFull> Does having an Alternative instance make sense for all things that MonadPlus instances make sense for?
09:28:04 <elliott> for anyone writing old code, it's same as it ever was. for anyone writing new code, they shouldn't be using it
09:28:12 <xplat> probably @nixon has a very different 'feel' outside of the USA too.  i already find it has a very different feel when it shows up as @vixen than @nixon ...
09:28:57 <dolio> Like MaybeT (State s)
09:29:11 <elliott> dolio: yeah
09:29:31 <xplat> it really makes a difference to know these are the quotes of a person who has become a persistent national laughingstock after falling from 'greatness', the only US president i can think of who was forced out of office midterm by scandal rather than death
09:31:29 <elliott> xplat: well, there's been two impeachments. (but this is a -blah thing.)
09:31:43 <elliott> (/me, N.B., knows almost nothing of US history)
09:31:52 <elliott> (ok, almost nothing is an exaggeration. but anyway, back on topic.)
09:36:08 <xplat> prophile: you get more free theorems when you know you have the same (polymorphic) Monoid instance for (m a) for all a , plus there are laws concerning the interaction of MonadPlus with Monad that don't make sense to assume for any Monoid
09:41:06 <quchen> elliott: Well, I'm pretty sure this doesn't state anything new, but at least md looks nice. https://gist.github.com/quchen/3b10bf8606c39aa9cf83
09:41:42 <quchen> elliott: I guess my problem is that I see the MonadPlus laws as fairly useful and important, and I'm very surprised Alternative doesn't have equivalents.
09:41:45 <elliott> quchen: my response: it isn't about isomorphism. MonadPlus is Alternative with extra laws, therefore (Alternative, Monad) is a perfectly fine superclass for it
09:41:58 <elliott> quchen: additionally: as dolio shows, MonadPlus's laws are ubiquitously violated.
09:42:08 <elliott> and as I showed, people want even more laws for MonadPlus, they consider the current set insufficient!
09:42:22 <elliott> therefore, I view MonadPlus's stated laws as all but irrelevant, so it is no real drawback of Alternative that it has fewer
09:42:56 <elliott> perhaps it would be good to add empty <*> x = empty to Alternative (x <*> empty = empty would be bad IMO because of it being widely false for MonadPlus instances in practice), but that's a separate discussion
09:44:10 <quchen> I'm surprised to hear that so many MonadPlus instances are wrong.
09:44:14 <augur> style question: do you prefer   data Foo = Foo BoolLike ...   or do you prefer   data Foo = FooFalseLike ... | FooTrueLike ...
09:44:16 <dolio> empty <*> x = empty should be a rule.
09:44:28 <augur> dolio: in Agda, it can be!
09:44:33 <augur> :)
09:44:41 <quchen> Great answer.
09:45:03 <quchen> I'll go over to #javascript and tell them about typeclasses when they discuss a JS problem. They're gonna love it.
09:45:16 <xplat> augur: depends how clear it is which one is the 'True' and which is the 'False'.  but for the first one i'd prefer 'newtype' rather than 'data'
09:45:28 <ion> I wonder how long i’ll keep typing :wa<RET> into Emacs?
09:45:35 <elliott> quchen: the problem is that so many MonadPlus instances are useful.
09:45:36 <augur> xplat: well the ... indicates more stuff
09:45:38 <elliott> and the class tries to stop them.
09:45:49 <elliott> anyway adding empty <*> x = empty to Alternative is fine
09:45:54 <quchen> elliott: Any examples?
09:45:57 <elliott> but I don't think it is really related to deprecating MonadPlus
09:46:03 <elliott> quchen: as dolio said, MaybeT (State s)
09:46:09 <quchen> Oh, I missed that.
09:46:22 <elliott> (and IO, but you can argue about how useful that instance is)
09:46:23 <augur> xplat: my specific example is   data Bizipper = Bizipper Position TheType Context   where   data Position = Before | After
09:46:28 <dolio> You guys are rewriting history.
09:46:35 <xplat> augur: oh.  then i'd prefer the first if the ... have basically the same meaning in both branches, the second if they just coincidentally have the same types
09:46:45 <dolio> Rules for MonadPlus are things people tried to extract from the instances.
09:46:54 <elliott> dolio: right. I agree.
09:47:00 <dolio> Except they extracted several that don't fit all the instances.
09:47:10 <dolio> Two sets, even.
09:47:12 <quchen> dolio: We've changed Applicative => Monad (potentially), we can change anything now! ;-)
09:47:28 <quchen> So for the MaybeT-State, x <*> empty = empty does not necessarily hold?
09:47:37 <quchen> (Can't picture it in my head I'm afraid)
09:47:40 <xplat> Bind comes back in 3... 2...
09:47:51 <Taneb> @unmtl MaybeT (State s) a
09:47:51 <lambdabot> (State s) (Maybe a)
09:47:58 <Taneb> lambdabot...
09:47:59 <dolio> put s *> empty /= empty
09:48:11 <Taneb> @unmtl MaybeT (StateT s Identity) a
09:48:11 <lambdabot> (StateT s Identity) (Maybe a)
09:48:28 <Taneb> @unmtl State s (Maybe a)
09:48:29 <lambdabot> s -> ((Maybe a), s)
09:48:46 <augur> xplat: ok. thats the convention im using right now, but i get drawn to using something like   data Bizipper = Context :@>: TheType | TheType :<@: Context   for visual reasons
09:48:46 <xplat> there's basically a bifurcation between two kinds of Alternative/MonadPlus instances, which could be called '[]-like' and 'Maybe-like'
09:48:48 <chrisdotcode> evening, everyone :)
09:49:12 <xplat> or 'backtracking Alternative' and 'committed Alternative'
09:49:25 <dolio> Yes.
09:49:41 <dolio> I don't really think it's worth having two classes to signal the difference, though.
09:49:57 <dolio> And there are further rules that may or may not apply.
09:50:03 <dolio> Like right-zero.
09:50:12 <xplat> theoretically you could have things that fall inbetween, but in practice you almost never do
09:50:18 <elliott> quchen: it's empty <*>x  = empty that fails
09:50:21 <elliott> for MaybeT (State s)
09:50:23 <elliott> er
09:50:27 <elliott> x <*> empty = empty
09:50:34 <elliott> or x >> mzero = mzero as it's stated for MonadPlus
09:51:36 <xplat> ah, right, there's also the uncancellable effect issue
09:52:13 <Taneb> @unmtl MaybeT m (a -> b)
09:52:13 <lambdabot> m (Maybe (a -> b))
09:52:23 <Taneb> @unmtl State s (Maybe (a -> b))
09:52:23 <lambdabot> s -> ((Maybe (a -> b)), s)
09:52:34 <dolio> I gues there's less explosion if you divide zero from plus.
09:52:58 <dolio> Then you get m zero classes and n plus classes, instead of m*n combined classes.
09:53:06 <xplat> @unmtl MaybeT (State s)
09:53:07 <lambdabot> Plugin `unmtl' failed with: `MaybeT (State s)' is not applied to enough arguments, giving `/\A. (State s) (Maybe A)'
09:53:16 <dolio> That are all identical, except for what equational conventions you're respecting.
09:53:20 <xplat> @unmtl MaybeT (State s) a
09:53:20 <lambdabot> (State s) (Maybe a)
09:53:50 <xplat> ... ?!?!
09:54:43 <dolio> @unmtl ContT r (State s) a
09:54:43 <lambdabot> (a -> (State s) r) -> (State s) r
09:54:53 <dolio> Has that always been the way?
09:55:02 <elliott> dolio: I don't think so.
09:55:06 <elliott> "upstream change", my universal excuse.
09:55:30 <xplat> dolio: of course in Idris they'd all have extra methods, because laws are methods if you actually have a proof for them
09:55:30 <dmwit> Shouldn't it be expanding State?
09:55:36 <dmwit> Independent of the crazy parentheses.
09:55:44 <elliott> @unmtl State s a
09:55:44 <lambdabot> s -> (a, s)
09:55:53 <elliott> I guess the parentheses are messing it up.
09:56:08 <xplat> weak
09:56:16 <dolio> @unmtl (State s) a
09:56:16 <lambdabot> (State s) a
09:56:19 <dolio> Oh yeah.
09:57:31 <dolio> xplat: Yeah. I expect it to not be very fun there, either.
10:05:30 <Nik05> Hey guys, does someone know where i can find a Square root function for big integers?
10:05:49 <Taneb> @package arithmoi
10:05:49 <lambdabot> http://hackage.haskell.org/package/arithmoi
10:06:18 <Taneb> Math.NumberTheory.Powers.Squares.integerSquareRoot etc in there
10:06:24 <Nisstyre> Nik05: SICP
10:06:34 <Nisstyre> >.>
10:07:14 <Nik05> ok thanks guys
10:08:41 <NemesisD> there wouldn't happen to be any fp complete folks in here would there
10:08:57 <chrisdotcode> so if I have a data Jobs = Programmer | GraphicDesigner | Singer how do I make the show representation of GraphicDesigner "Graphic Designer", while derivng the rest so I won't have to type them out?
10:08:59 <elliott> if not right now, there are at least sometimes
10:09:07 <elliott> chrisdotcode: yikes, that's not what Show is for!
10:09:13 <chrisdotcode> elliott: it's not?
10:09:25 <elliott> nope. it's for debugging/cheap serialisation, not pretty-printing
10:09:33 <elliott> you can define your own Jobs -> String function as the simplest thing
10:09:33 <Gracenotes> read . show == id, is usually suggested
10:09:38 <elliott> (btw, I would call the data type "Job")
10:09:58 <Gracenotes> kind of like eval . repr == id, in Python, is the ideal
10:10:01 <Nisstyre> chrisdotcode: if you want them to all be different types you could use datakinds, but I don't think you can selectively derive instances for the types there
10:10:29 <elliott> Gracenotes: id is something quite different in Python :P
10:10:34 <elliott> well, as is (.)...
10:10:39 <Gracenotes> yes, I was going to say :)
10:11:53 <Nisstyre> I guess id in python gives you something like an object's "address"
10:12:03 <Nisstyre> depending on the specific implementation
10:12:07 <chrisdotcode> elliott, Nisstyre: well I don't mind them being the same datatype. and I *cant* derive most of them, and then write out the GraphicDesigner case?
10:12:25 <Nisstyre> chrisdotcode: instantiating is something done to TYPES
10:12:27 <elliott> chrisdotcode: no, but even if you wrote the Show instance totally manually you shouldn't be doing this
10:12:31 <Nisstyre> those are all constructors of the same type
10:12:50 <Nisstyre> or rather data constructors for the same type
10:13:07 <chrisdotcode> the show instance looked like:
10:13:15 <chrisdotcode> instance Show Profession where
10:13:15 <chrisdotcode> 	show GraphicDesigner = "Graphic Designer"
10:13:15 <chrisdotcode> 	show _ = ???
10:13:28 <chrisdotcode> er, it was Profession, not Job, but yeah
10:13:42 <Nisstyre> you can't really do what you want, at least not safely
10:14:19 <Nisstyre> either you derive the Show instance or you manually write it
10:14:24 <Nisstyre> you can't have both
10:14:27 <chrisdotcode> no mixing?
10:14:28 <Nisstyre> (safely)
10:14:29 <Gracenotes> yourFunction GraphicDesigner = "Graphic Designer"
10:14:30 <Nisstyre> nope
10:14:32 <Gracenotes> yourFunction x = show x
10:14:35 <elliott> Gracenotes: :(
10:14:41 <elliott> such sin
10:14:54 <Gracenotes> But even that is terrible, because what happens when you add SoftwareEngineer?
10:14:55 <chrisdotcode> sin?
10:14:59 <Nisstyre> chrisdotcode: there are...ways to have multiple instances of the same type overlap
10:15:02 <elliott> yes. yourFunction shouldn't rely on the Show instance at all.
10:15:05 <Nisstyre> but you probably shouldn't be doing that
10:15:14 <elliott> anyway, you should stop trying to do what you're doing and do it the other way instead. trust me.
10:15:18 <chrisdotcode> Gracenotes: then yourFunction SoftwareEngineer = "Software Engineer"?
10:15:35 <chrisdotcode> elliott: and the other way was to make a Profession -> String?
10:15:42 <chrisdotcode> not instantiate Show?
10:15:43 <ksf> HOAS rocks.
10:15:47 <elliott> you can derive Show, that's fine.
10:15:48 <Gracenotes> chrisdotcode: what if you forget? If you're going to be explicit in some cases, be explicit in all cases.
10:15:51 <elliott> just don't abuse it for pretty-printing.
10:15:57 <ksf> ...especiall when unembedded.
10:16:00 <elliott> that's not what it's for.
10:16:15 <ksf> of course that's what HOAS is for.
10:16:25 <ksf> only evaluating is boring.
10:16:41 <Nisstyre> chrisdotcode: if you derive an instance for a type, then if you want to manually instantiate an instance of the same type class for that type (in the same module mind you), then you're going to have overlapping instances
10:16:56 <ksf> oh.
10:16:58 <ksf> nvm.
10:17:07 <chrisdotcode> elliott: yeah, but I'd like to have the space between "Graphic" and "Designer" printed, which is why I was writing it manually.
10:17:25 <Gracenotes> this is also the problem with class Animal, Dog extends Animal, Cat extends Animal, in languages like Java
10:17:30 <ksf> chrisdotcode, then it's a function application...
10:17:54 <ksf> if you want pretty output, use pretty printing, not show.
10:17:55 <elliott> chrisdotcode: well, that's not how Show is meant to work. it's meant to output in Haskell syntax, and ideally be a valid Haskell expression for the original object. it's for debugging and cheap state storage (and even that is questionable)
10:18:03 <Gracenotes> it makes a lot less sense to model real-world things in a programming language, and there's not a good way to do it, because we put more effort into spending time doing more important things
10:18:12 <ksf> Show is for humanely decipherable serialisation, nothing else.
10:18:20 <elliott> ksf: and ghci.
10:18:42 <Gracenotes> In this case, why does it matter that the datatype is pretty-printed?
10:19:00 <ksf> read . show == id
10:19:06 <ksf> that's a law that shouldn't be broken.
10:19:28 <ksf> ...so show should have a predictable syntax.
10:20:38 <Nisstyre> the output doesn't necessarily have to correspond to the Haskell data type exactly though, if there's some intermediate parsing you want to have happen, then that's why you'd manually instantiate Show and Read for a type
10:20:53 <Nisstyre> *parsing and unparsing
10:21:09 <ksf> the general guideline is that it should be valid haskell, though.
10:21:18 <Nisstyre> then you can use it, e.g. as a QuickCheck property
10:21:19 <Nisstyre> or whatever
10:21:33 <ksf> like fgl's show instance, iirc. it prints a let ... in that defines the graph.
10:21:38 <chrisdotcode> elliott: okay, so the answer is still myShow :: Profession -> String, even if it means manually writing out all of the patterns to match against ;_;
10:21:57 <elliott> it's not myShow
10:22:06 <elliott> the function really doesn't have anything to do with show; that's why it's separate
10:22:25 <chrisdotcode> well toString, then.
10:22:45 <ksf> chrisdotcode, for your sanity: http://hackage.haskell.org/packages/archive/wl-pprint/1.1/doc/html/Text-PrettyPrint-Leijen.html
10:22:57 <ksf> just give it any syntax you want.
10:24:30 <chrisdotcode> ksf: I don't think I'll need anything that advanced yet, but thank you :)
10:25:02 <ksf> advanced libraries make simple things trivial...
10:25:10 <ksf> (at least in theory)
10:25:29 <ksf> (modulo boilerplate, that is, but that should be minimal)
10:25:37 <elliott> chrisdotcode: how about "jobName"?
10:25:45 <elliott> toString is quite vague. there are lots of ways to turn things into String
10:26:06 <ksf> like base64-encoding it.
10:35:27 <Aetherspawn> how do I import more modules into lambdabot
10:38:24 <acube> With ConstraintKinds, I can easily have a data type A ctx b = (forall a. ctx a -> b). How can I pass this data type a composed context, like (Data, Plated) ?
10:39:26 <thoughtpolice> you may have to make an alias; with -XConstraintKinds enabled, then 'type Foo = (Data, Plated) :: Constraint', so 'A Foo b' would work
10:39:40 <thoughtpolice> (in other words type aliases also become constraint aliases)
10:40:01 <monochrom> are you sure of "cxt a -> b"?
10:40:14 <thoughtpolice> oh, and that :P
10:40:16 <Lethalman> I'm navigating a matrix [[Int]] from bottom left to top right
10:40:22 <Lethalman> in order to find an element
10:40:31 <acube> Oh I mean forall a. ctx a => a -> b, anyway, just an example to show you what I want :P
10:40:37 <Lethalman> I have not only to return the position of the found element
10:40:49 <Lethalman> but also the backtrack
10:40:59 <Lethalman> so for example if the found index is (3,3) the backtrack is (2,3)
10:41:06 <Lethalman> but there are 2 special cases
10:41:10 <fridim_> monochrom, I can't beleive you wrote some haskell code to merge log files, this should be a small bash script, or a logrotate :/ Or maybe you did it to practice haskell ?
10:41:17 <hpaste> Elias pasted “FunctorInstances” at http://hpaste.org/90277
10:41:40 <Lethalman> for (0,y) I have to return (0,y-1)
10:41:49 <Lethalman> so, uhm
10:42:12 <Lethalman> do you think it's better to have a function returning both the element position and the backtrack as (Point, Point)
10:42:33 <Lethalman> or have a function -> Point and another function to get the backtrack Point -> Point ?
10:42:54 <Lethalman> for this case, the simplest thing is probably having two separate functions
10:43:06 <monochrom> fridim_: if it were a shell script, it would be practice exercise for shell scripting, aka obscure string manipulation kludge
10:43:12 <Lethalman> mh
10:43:23 <hpaste> Elias pasted “EvenOdd” at http://hpaste.org/90278
10:43:47 <fridim_> monochrom, oh, so maybe I didn't get the problem, sorry :)
10:43:53 <elliott> fridim_: writing small haskell scripts can be surprisingly easy!
10:43:56 <elliott> and shell is quite an awful language.
10:44:15 <elliott> there is even e.g. https://github.com/yesodweb/Shelly.hs/blob/master/README.md to make the task easier
10:46:10 <chrisdone> i'm a big fan of well-typifying unix commands
10:46:11 <monochrom> whee-20130620.log is to be appended to whee-201306.log. however, that's not all. whee-20130620.log contains no date inside, its typical line is "[13:45] <monochrom> hi", you don't know it's 20130620 except for the filename, which will soon disappear
10:46:30 <acube> thoughtpolice: type DataPlatedCtx = (Data,Plated) gives: Expecting one more argument to `Data'
10:46:42 <monochrom> so, when appending, I want to prepend "20130620 " to each line
10:47:19 <monochrom> in Haskell, this is just (unlines . map ("20130620 " ++) . lines). in shell, I don't want to know
10:48:44 <monochrom> I also have to map "20130620" to "201306", so that I know the target filename is whee-201306.log. in haskell, this is just (take 4). I don't know how to do in shell, and I likely don't want to know
10:48:45 <fridim_> monochrom, ok
10:48:54 <Lethalman> now
10:49:00 <Lethalman> let's see if I've understood fmap . fmap
10:49:01 <Lethalman> :D
10:49:12 <chrisdone> monochrom: that's probably: sed 's/^/20130620/'
10:49:26 <chrisdone> oh, i missed a space. but ja
10:49:45 <acube> With ConstraintKinds, I can easily have a data type A ctx b = (forall a. ctx a => a -> b). How can I pass this data type a composed context, like (Data, Plated) ? Saying A (Data, Plated) () gives: Expecting one more argument to `Data'
10:49:58 <acube> (Using a type alias also doesn't work)
10:49:58 <Lethalman> :t both
10:49:58 <lambdabot> Not in scope: `both'
10:49:59 <ion> monochrom: ${foo%[0-9][0-9]}
10:49:59 <chrisdone> you could have a sed :: (Text -> Text) -> Text -> Text function =)
10:50:03 <Lethalman> mh
10:50:13 <ion> ${foo%??}
10:50:34 <fridim_> For me the simpler would be to add the 20130620 when logging. I would log to one file and let logrotate do the job
10:50:38 <Lethalman> @hoogle (a -> b -> c) -> (a,a) -> (b,b) -> (c,c)
10:50:38 <lambdabot> Data.Array.IArray accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
10:50:39 <lambdabot> Data.Array.IArray accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
10:50:46 <Lethalman> @djinn (a -> b -> c) -> (a,a) -> (b,b) -> (c,c)
10:50:46 <lambdabot> f a (b, _) (c, _) = (a b c, a b c)
10:50:52 <acube> @hoogle both
10:50:52 <lambdabot> System.Posix.Terminal BothQueues :: QueueSelector
10:50:52 <lambdabot> System.Posix.Terminal.ByteString BothQueues :: QueueSelector
10:50:53 <lambdabot> Network.Socket ShutdownBoth :: ShutdownCmd
10:51:03 <Lethalman> uhm
10:51:15 <monochrom> I did not write the logger. I could not tell it to add dates
10:51:22 <Lethalman> :t _1
10:51:23 <lambdabot> Not in scope: `_1'
10:51:27 <Lethalman> no lens in lambdabot?
10:51:58 <Lethalman> :t \f (x,y) (x',y') -> (f x x', f y y')
10:51:59 <lambdabot> (t -> t1 -> t2) -> (t, t) -> (t1, t1) -> (t2, t2)
10:52:16 <acube> @let both f (a,b) = (,) <$> f a <*> f b
10:52:17 <lambdabot>  Defined.
10:52:17 <elliott> Lethalman: not right now
10:52:21 <elliott> that's not what _1 is though :)
10:52:21 <Lethalman> :t let tupleMap f (x,y) (x',y') = (f x x', f y y') in tupleMap . tupleMap
10:52:22 <lambdabot> (t -> t1 -> t2) -> ((t, t), (t, t)) -> ((t1, t1), (t1, t1)) -> ((t2, t2), (t2, t2))
10:52:37 <Lethalman> awesome :D
10:52:37 <fridim_> elliott, thanks I'll look at shelly.hs :)
10:52:40 <Lethalman> exactly what I wanted
10:52:46 <chrisdone> hmm
10:52:54 <acube> @let x ^.. l  = getConst $ l (Const . (:[])) x
10:52:55 <lambdabot>  Defined.
10:53:00 <acube> > (1,2) ^.. both
10:53:05 <lambdabot>   mueval-core: Time limit exceeded
10:53:06 <acube> > (1,2) ^.. both
10:53:10 <lambdabot>   [1,2]
10:53:12 <chrisdone> mueval-snore!
10:53:38 <acube> @let l %~ f = runIdentity . l (Identity . f)
10:53:39 <lambdabot>  Defined.
10:53:47 <lambdabot> I might be slow at evaluating, but I'm better at it than chrisdone!
10:53:54 <acube> :P
10:54:10 <acube> Can I do @let in private chat with lambdabot?
10:54:23 <krq> |:::::::::::::::::::::::.:.:.:.:.:.:.:.: : :.: : : : : : : : .. .. :. ..   |
10:54:23 <krq> |:::::::dHHHbo._ ::::::::.:.:.:.:.:.: : :.: : :.: : :.: : : :..:..: .. :.  |
10:54:23 <krq> |::::::dHF""HHHHb.::::::.:.:.:.:.:.:.:.:.:.:.: : :.: : : : : . :. .. . ..  |
10:54:23 <krq> |:::::dHH  _ "HHHHb.:::::.:.:.:.:.:.: :.:.: :.:.: : : : : : :.::.: ..: ..  |
10:54:24 <krq> |:::::HHH_'o  "HHHHHb.::.:.:.:.:.:.:.:.: :.:.:.: : :.: : :.: .... .... .:  |
10:54:24 <krq> |:::::HHFo     "HHHHHHbo..:.:.:.:.:.:.: :.: : :.: : : : :.: :. :.::.: ..   |
10:54:24 <krq> |:::::HHH\`,   HHHHHHHHHHho..:.:.:.:.:.: :.:.:.: : :.:.: : : :: ..  ..  .. |
10:54:24 <krq> |:::::HFHH`._,'HHH'   `HHHHHHb_ :.:.:.: : ____:.: : : : : : :. .::.. : ..  |
10:54:25 <krq> |:::::P:"HHHHH\HP       "HHF:. `._ :.,-'""    "-.  :.: : : : .:  .. ..: .. |
10:54:25 <krq> |::::::::"HHFHHF         F"  :::.."""     "-.    `. : : : : :..:.: .. ..   |
10:54:26 <krq> |::::::::::F::PF                ,            \     \__ : : : _,-----._..--'|
10:54:26 <krq> |::::::::::::::F    j\         /              ;     `."----''              |
10:54:27 <krq> |::::::::::::::|    j  `.      `              A       \                    |
10:54:27 <krq> |::::::::::::::|    |    ;_       .           8        \                   |
10:54:32 <chrisdotcode> elliott: jobName works, thanks :D (sorry, late reply)
10:54:34 <Lethalman> anyway tupleMap != both uhm
10:54:38 --- mode: ChanServ set +o elliott
10:54:39 --- mode: elliott set +b *!*krq@117.230.143.*
10:54:39 --- kick: krq was kicked by elliott (krq)
10:54:40 <Nik05> fap fap ascii
10:54:41 <Lethalman> :t both
10:54:42 <lambdabot> Applicative f => (t -> f a) -> (t, t) -> f (a, a)
10:54:51 <acube> > test
10:54:54 <lambdabot>   "Lambdabot is always right!"
10:55:03 * ksf can't discern anything there, the font is too proportional.
10:55:06 <elliott> acube: you can, yes
10:55:09 <acube> :)
10:56:03 <chrisdone> lambdabot: shudap!
10:56:05 <acube> > (1,2) & both .~ 3
10:56:06 <lambdabot>   Couldn't match type `(t2, t2)'
10:56:06 <lambdabot>                with `a10 -> Data.Functor.Ide...
10:56:36 <acube> > (1,2) & (both .~ 3)
10:56:39 <lambdabot>   (3,3)
10:57:00 <Lethalman> now
10:57:11 <Lethalman> @hoogle (a,b) -> (b,a)
10:57:12 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
10:57:12 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
10:57:12 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
10:57:17 <acube> What? No way to undefine one day?
10:57:18 <Lethalman> right, knew there was it
10:57:21 <acube> thing*
10:57:23 <elliott> nope
10:57:28 <Lethalman> acube, there's undefine but will undefine everything afaik
10:57:28 <elliott> acube: btw, @let import Control.Lens.Foo is easier
10:57:32 <elliott> but it'll only work for some Foo
10:57:37 <elliott> and it'll all be wiped away once @undefine happens of course
10:59:13 <acube> Is there TH in lambdabot? :P
10:59:33 <elliott> uh, I hope not.
10:59:36 <elliott> but maybe.
10:59:51 <acube> > $makeLenses ''Maybe
10:59:52 <lambdabot>   <hint>:1:1: parse error on input `$'
11:00:10 <monochrom> > [monochrom| 3 + 4 |]
11:00:11 <lambdabot>   <hint>:1:20: parse error on input `]'
11:00:24 <acube> > (Just 3) & _Just %~ (+3)
11:00:26 <lambdabot>   Not in scope: `%~'
11:00:26 <lambdabot>  Perhaps you meant one of these:
11:00:26 <lambdabot>    `%' (imported from D...
11:00:41 <KSkrzet> how one gets started with writing custom Prelude? I have an idea for one but I don't know how to start implementation
11:00:44 <acube> > (Just 3) & _Just %~ (+3)
11:00:47 <lambdabot>   Just 6
11:00:50 <acube> wow
11:00:53 <Lethalman> :t iterate
11:00:54 <lambdabot> (a -> a) -> a -> [a]
11:01:06 <Lethalman> :t replicate
11:01:07 <lambdabot> Int -> a -> [a]
11:01:16 <acube> Only Control.Lens doesn't work, I think you can import most of Control.Lens.XXX modules fine?
11:01:20 <KSkrzet> > :t (&)
11:01:21 <lambdabot>   <hint>:1:1: parse error on input `:'
11:01:24 <KSkrzet> :t (&)
11:01:25 <lambdabot> a -> (a -> b) -> b
11:01:25 <acube> :t (&)
11:01:26 <lambdabot> a -> (a -> b) -> b
11:01:31 <KSkrzet> :i (&)
11:01:33 <acube> (&) = flip id
11:01:37 <elliott> acube: most yes, but not all
11:01:48 <elliott> KSkrzet: just write the code and use {-# LANGUAGE NoImplicitPrelude #-}.
11:01:49 <KSkrzet> :t  (%~)
11:01:50 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
11:02:17 <acube> > [1,2,3] ^? _head
11:02:18 <lambdabot>   Not in scope: `_head'
11:02:18 <lambdabot>  Perhaps you meant one of these:
11:02:18 <lambdabot>    `head' (imported ...
11:02:58 <acube> > [1,2,3] ^? _head
11:02:59 <lambdabot>   Just 1
11:03:26 <acube> Aw, no Control.Lens.Each :(
11:03:38 <KSkrzet> elliott: ok, I think I told you too little. I want to make a FlatPrelude: a fork of existing GHC prelude with every class hierarchy replaced with default methods when needed
11:04:04 <elliott> I don't understand what you mean by that, but ok.
11:04:04 <roconnor> default methods?
11:04:07 --- mode: elliott set -o elliott
11:04:44 <Lethalman> :t both
11:04:44 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
11:04:54 <Lethalman> mh
11:04:58 <Lethalman> not what I want I think
11:05:00 <KSkrzet> hmm, i mean default signatures: http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/type-class-extensions.html#class-default-signatures
11:05:06 <acube> :t bimap
11:05:07 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
11:05:19 <elliott> "alternate Preludes" are generally not based on the existing Prelude code.
11:05:26 <KSkrzet> when a default implementation requires existing superclass we turn on that extension instead
11:05:35 <acube> :t bimap :: (a -> b) -> (c -> d) -> (a,c) -> (b,d)
11:05:36 <lambdabot> (a -> b) -> (c -> d) -> (a, c) -> (b, d)
11:05:46 <acube> Lethalman: is that what you want?
11:05:58 <Lethalman> :t \f (x,y) = (f x, f y)
11:05:59 <lambdabot> parse error on input `='
11:06:03 <Lethalman> :t \f (x,y) -> (f x, f y)
11:06:04 <lambdabot> (t -> t1) -> (t, t) -> (t1, t1)
11:06:07 <Lethalman> this ^^
11:06:16 <Lethalman> @hoogle (a -> b) -> (a, a) -> (b, b)
11:06:16 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
11:06:16 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
11:06:16 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
11:06:41 <supki> @ty join bimap
11:06:42 <lambdabot> Bifunctor p => (a -> b) -> p a a -> p b b
11:06:47 <Lethalman> \o/
11:06:48 <elliott> :t over both
11:06:49 <lambdabot> (a -> b) -> (a, a) -> (b, b)
11:07:03 <Lethalman> :t over
11:07:04 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
11:07:05 <elliott> > (1,2) & both %~ show
11:07:07 <lambdabot>   ("1","2")
11:09:18 <supki> @ty join dimap
11:09:19 <lambdabot> Profunctor p => (a -> b) -> p b a -> p a b
11:09:28 <acube> :P
11:10:15 <acube> > ("hello ","world") ^. both
11:10:17 <lambdabot>   "hello world"
11:17:17 <ksf> shouldn't every function be movable to a where clause, if given a type signature?
11:17:30 <ksf> oh, wait.
11:17:34 <ksf> scopedtypevariables.
11:18:23 <ksf> yep, mystery solved.
11:18:33 <ksf> #haskell, you're a very useful rubberduck.
11:19:56 * hackagebot hidapi 0.1 - Haskell bindings to HIDAPI  http://hackage.haskell.org/package/hidapi-0.1 (PatrickChilton)
11:20:14 <kryft> ksf: So every function isn't movable?
11:21:40 <geekosaur> kryft, I imagine that if you have a top level with a type signature and you move it to a where clause under a definition which uses ScopedTypeVariables with a colliding type variable, you'd get an "unexpected" effect
11:22:04 <geekosaur> fixed by renaming the affected type variable in the moved function
11:22:42 <ksf> yep.
11:23:09 <ksf> there can be cases where moving a function without sig into a type signature is going to mess things up, too, due to hindley-milner.
11:23:50 <ksf> don't know how that relates to the monomorphism restriction, though, that may be even more restrictive.
11:26:13 <chrisdone> i don't see any reason why the monomorphism restriction would involve restriction
11:27:52 <ksf> it does, when it comes to things compiling without providing a type signature.
11:28:13 <chrisdone> i was joking =p
11:28:21 <ksf> modulo the fact that disabling it is basically the first thing I do.
11:29:11 <ksf> ...I'm letting ghc generate all the top-level type decls, anyway.
11:29:55 <ksf> (unless I'm for some reason fighting myself through the types arrow by arrow)
11:34:11 <NemesisD> hey guys. i was looking for advice on cleaning up an API i'm working on
11:35:11 <NemesisD> the library is for testing API clients. you build a mock HTTP server then run your client and typically you're going to assert on the requests made and assert on the result of your api call
11:35:34 <KSkrzet> people seem to use profunctors a bit, I tried figuring out the library but there are no docs and no wiki page either... any tips where I can find some examples?
11:35:59 <elliott> KSkrzet: pretty much only lens uses profunctors, I think.
11:36:26 <NemesisD> actually, i should ask: what's the right forum for design advice in haskell? irc? a mailing list?
11:36:39 <supki> KSkrzet: sigfpe's post on profunctors is nice intro
11:36:55 <supki> http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html
11:37:22 <KSkrzet> my bad, google returned link to old package version, new one has docs...
11:37:42 <KSkrzet> elliott, supki: thanks for the links
11:44:53 <NemesisD> ?
11:49:34 <Taneb> It occurs to me that I'm not even sure quite what the purpose of eg. conduit and pipes is
11:51:46 <NemesisD> Taneb: from what i understand: efficient lazy streaming with predicable resource handling from my understanding
11:53:24 <aristid> NemesisD: nice symmetric framing there
11:53:54 <aristid> Taneb: i assume you understand the face-value purpose of those packages, so your question must be subtle :D
11:54:15 <chrisdone> aristid: losing faith in irc? =p http://ircbrowse.net/nick/aristid?recent=false
11:54:32 <Taneb> aristid, earlier today I had a thought, "Maybe I can use conduit or pipes for this?" and I realised I had no idea
11:56:05 <aristid> chrisdone: i think my focus just shifts between channels.
11:56:17 <aristid> chrisdone: in 2010 i was actively learning haskell, so this channel was important.
11:56:28 <aristid> i mean learning haskell per se, not just using it for stuff
11:57:48 <aristid> chrisdone: how does it choose the first line?!
11:58:13 <chrisdone> aristid: a random line from the time period =)
11:58:55 <aristid> chrisdone: AHA you also lost faith in irc! http://ircbrowse.net/nick/chrisdone?recent=false
11:59:09 <NemesisD> where do you guys usually go for advice on designing libraries? i'm to the point now where i'm competent at haskell but on larger projects i end up building pretty unweidly beasts
11:59:15 <chrisdone> aristid: =p
11:59:18 <aristid> chrisdone: i think the verbosity diagram is a bit hard to read.
12:02:06 <aristid> chrisdone: http://ircbrowse.net/nick/dons?recent=false :(
12:03:57 <aristid> @quote NDA
12:03:57 <lambdabot> elliott says: I don't think Haskell can ever hope to enter the enterprise if we can't model non-standard colourblind observers with it.
12:04:24 <joelteon> very clever
12:04:34 <Philonous> chrisdone:  what time zone is that in? And where do the memorable quotes come from?
12:04:41 <aristid> @quote edwardk.*ndas
12:04:41 <lambdabot> elliott says: <edwardk> cmccann: i'm NDA'd out of that space for a while ;) <elliott> edwardk just collects NDAs so that he can focus.
12:04:49 <aristid> there.
12:05:55 <FreeFull> @quote FreeFull
12:05:55 <lambdabot> No quotes match. Sorry.
12:06:03 <FreeFull> @quote haswell
12:06:03 <lambdabot> No quotes match. Sorry.
12:06:17 <MitchellSalad> hi all, i noticed a weird behavior with System.Directory (doesFileExist) and symlinks... it looks like it won't follow symlinks outside of the current directory
12:06:40 <MitchellSalad> i.e. doesFileExist "foo.c" == True, if foo.c -> bar.c, folder/bar.c, folder/folder/bar.c, etc
12:06:53 <MitchellSalad> but doesFileExist "foo.c" == False if foo.c -> /somewhere/else/bar.c
12:07:00 <MitchellSalad> does anyone know how to handle symlinks better?
12:07:08 <Philonous> Interesting, it's attributing something to me even though lambdabot doesn't know any quotes of me. And I'm almost certain I didn't say it.
12:07:12 <elliott> well, generally you should not use doesFileExist :)
12:07:18 <ksf> MitchellSalad, is your symlink broken?
12:07:24 <MitchellSalad> i would love to not use doesFileExist haha!
12:07:29 <MitchellSalad> nope the symlink is not broken
12:07:40 <ksf> there's POSIX filesystem functions
12:08:10 <ksf> package "unix".
12:08:23 <ksf> won't work on windows, of course, but then who cares.
12:08:32 <geekosaur> o.O
12:08:35 <geekosaur> reproduced here
12:08:54 <ksf> http://hackage.haskell.org/packages/archive/unix/2.6.0.1/doc/html/System-Posix-Files.html
12:09:08 <aristid> MitchellSalad: which OS?
12:09:58 <aristid> doesFileExist appears to use stat to determine if it's a directory, and if stat succeeds and says "no directory" returns true *scratch head*
12:10:27 <aristid> unless this code lies: http://hackage.haskell.org/packages/archive/directory/1.2.0.1/doc/html/src/System-Directory.html#doesFileExist
12:10:36 <geekosaur> oh, hm, ok, bad test case. doesFileExist actually means *file* :p
12:11:04 <MitchellSalad> aristid: Arch
12:12:02 <aristid> ok i can not reproduce.
12:12:15 <aristid> on linux (nixos)
12:12:48 <MitchellSalad> okay, well thanks anyways, i'll use posix functions :)
12:18:39 * ksf once had a bug like that, while trying to port ghc to Haiku
12:19:09 <ksf> due to header mixup the crossbuilt ghc thought directories were files and vice versa.
12:19:19 <ksf> it didn't get far compiling stuff :)
12:19:38 <Philonous> But directories are files, are they not?
12:19:49 <ksf> in plan9, maybe.
12:19:56 <ksf> not under unix.
12:19:57 * hackagebot java-reflect 0.9.1 - Tools for reflecting on Java classes.  http://hackage.haskell.org/package/java-reflect-0.9.1 (JulianFleischer)
12:19:58 <geekosaur> mutant files, sorta
12:19:59 * hackagebot hx 0.1 - Utility functions that some may feel are missing from Prelude and base.  http://hackage.haskell.org/package/hx-0.1 (JulianFleischer)
12:20:13 <geekosaur> but there's a separate doesDirectoryExist
12:21:15 <ksf> if you want directories to be files you needs some kind of types for files, too.
12:21:34 <ksf> I think the plan9 thing was that everything could be both at the same time.
12:22:15 <ksf> so opening a directory for reading would give you what readdir does in unix
12:23:09 <Nisstyre> I'm getting this error when trying to install the lens package: http://codepad.org/Fu0ZOUtt
12:23:13 <Nisstyre> all of the relevant info is there
12:23:18 <Nisstyre> any ideas what I'm doing wrong?
12:23:54 <ksf> erm.
12:23:54 <Nisstyre> wrong GHC version?
12:24:06 <ksf> that looks fishy, yes.
12:24:13 <Nisstyre> ksf: shouldn't it tell me I have the wrong version?
12:24:17 <Nisstyre> from the .cabal file?
12:24:24 <ksf> there's only tested-with
12:24:30 <Nisstyre> ok
12:24:34 <ksf> that doesn't mean much but that it was tested.
12:24:52 <ksf> and hackage additionaly tells you what version it sucessfully built the package with.
12:25:17 <ksf> 7.6, as it seems.
12:26:13 <Nisstyre> ksf: it says it was tested with 7.4.2
12:26:22 <Nisstyre> does that mean it built successfully?
12:26:48 <ksf> it means edwardk put the line in there sometime.
12:26:52 <Nisstyre> :P
12:27:14 <ksf> 7.6.1 is nice, though, you should update anyway.
12:27:19 <Nisstyre> I suppose yeah
12:27:32 <ksf> er .3
12:28:51 <Nisstyre> ksf: I think ubuntu is lagging behind on that. I'm using 12.10. Of course when I wrote this stuff on Arch it built fine since it's using 7.6
12:29:17 <ksf> @seen edwardk
12:29:17 <lambdabot> EDWARDk
12:29:22 <ksf> wut?
12:29:26 <ksf> preflex, seen edwardk
12:29:27 <preflex>  edwardk was last seen on #haskell 21 hours, 24 minutes and 9 seconds ago, saying: >>> :t pure   ====> Not in scope: `pure'
12:29:50 <ksf> Nisstyre, I've got my current ghc in my $HOME
12:30:14 <ksf> system-wide I'm still at 6.12.3, gentoo stable.
12:30:16 <Nisstyre> ksf: that's probably a better approach yeah
12:30:39 <ksf> oh. apparantly 7.4.2 hit stable by now.
12:31:34 <ksf> wget the archive; cd; ./configure --prefix=$HOME/ghc; make install
12:31:39 <ksf> (and set your path)
12:32:08 * ksf doesn't recommend building from source
12:32:15 <ksf> ...waste of time.
12:32:41 <Nisstyre> ksf: yet you use Gentoo >.>
12:33:06 <pavonia> Is there already a function of type (a -> b) -> (a -> c) -> (b -> c -> d) -> (a -> d)? No results from Hoogle
12:33:13 <ksf> I don't sit in front of my screen when updating my system.
12:36:04 <b2coutts> pavonia: what exactly do you want that function to do?
12:36:42 <pavonia> I guess there's only one meaningfull implementation
12:36:47 <b2coutts> wait, never mind I misread it
12:37:03 <Nisstyre> @djinn (a -> b) -> (a -> c) -> (b -> c -> d) -> (a -> d)
12:37:03 <lambdabot> f a b c d = c (a d) (b d)
12:37:12 <supki> :t liftA2 :: (b -> c -> d) -> (a -> b) -> (a -> c) -> (a -> d)
12:37:13 <lambdabot> (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
12:37:25 <supki> so it's liftA2 modulo flips
12:37:59 <pavonia> supki: Excellent, thanks!
12:38:07 <geekosaur> I was thinking that looked like liftA2/liftM2 on ((->) e)
12:38:58 <pavonia> Oh, there's an Applicative instance for functions :o
12:39:21 <elliott> pavonia: (<*>) is the S combinator on functions :)
12:39:22 <supki> :t ((flip .) . flip) liftA2 :: (a -> b) -> (a -> c) -> (b -> c -> d) -> (a -> d)
12:39:23 <lambdabot> (a -> b) -> (a -> c) -> (b -> c -> d) -> a -> d
12:40:23 <pavonia> S combinator?
12:41:06 <ion> @@ @djinn @type (<*>) `asAppliedTo` (undefined :: a -> b -> c)
12:41:07 <lambdabot>  f a b c = a c (b c)
12:41:17 <Bike> from ski calculus. Sxyz = xz(yz)
12:41:55 <shachaf> hi Bike
12:42:19 <Bike> hi shachaf.
12:42:41 <shachaf> @@ @pl @djinn @type (<*>) `asAppliedTo` (undefined :: a -> b -> c)
12:42:42 <lambdabot>  f = ap
12:42:51 <Gracenotes> exciting
12:52:07 <aristid> chrisdone: gimme ?recent=false for the home pag!
12:56:44 <Taneb> Is there such thing as a false constraint
12:56:51 <Taneb> Like, the opposite of () :: Constraint
12:57:23 <elliott> class () ~ Void => No
12:57:31 <elliott> note: probably a pain to use in practice.
12:58:00 <Taneb> elliott, this whole endeavour is going to be a pain to use in practise
12:58:13 <elliott> you could also use () ~ Void directly, of course
12:58:25 <elliott> and then if you ever find yourself in such a context, theoretically (absurd ()) should work to give you any value.
12:58:32 <shachaf> Note that this works quite badly in GHC.
12:58:58 <shachaf> In particular you can't do what elliott said. And you can't CPSify a GADT.
12:59:18 <shachaf> data Foo a = a ~ Char => A | a ~ Bool => B -- valid1
12:59:25 <shachaf> newtype Bar a = Bar { runBar :: forall r. (a ~ Char => r) -> (a ~ Bool => r) -> r } -- unusable
12:59:36 <shachaf> s/1//
13:00:39 <elliott> unfortunately I don't have ghci so I can't... oh, wait, lambdabot has a ghci.
13:01:28 <Saizan> shachaf: newtype Bar a = Bar { runBar :: forall r. r Char -> r Bool -> r a }
13:02:22 <elliott>     Inaccessible code in the type signature for foo :: () ~ Void => a
13:02:22 <Saizan> but yeah, not the point i guess
13:02:23 <elliott> so silly.
13:02:36 <elliott> you can't even foo = undefined
13:02:37 <shachaf> Saizan: Right.
13:03:26 <Saizan> that r :: * in your version irks me though
13:04:12 <Saizan> but i guess it's fine since 'a' is a parameter
13:05:42 <chrisdone> Philonous: it's in UTC. it's attributing to you a random line that you said at some point in the time period, it'll update daily or whenever the cache is reset
13:08:59 <chrisdone> gwern: http://ircbrowse.net/nick/gwern?recent=false
13:09:16 <chrisdone> gwern: what happened?
13:15:30 <gwern> chrisdone: I became more interested in statistics than functional programming
13:16:07 <chrisdone> gwern: fair enough! =)
13:16:10 <Taneb> Well, I've achieved something
13:16:15 <chrisdone> statistics /are/ fascinating
13:16:36 <chrisdone> Taneb: world domination?
13:16:39 <Taneb> And that is realising I should really learn Agda
13:17:11 <arkeet> chrisdone: you should try to make the hours plots form a closed loop.
13:17:25 <aplavin> hi! anyone had such error:  eventfd: unsupported operation (Function not implemented)?
13:17:41 <aplavin> i'm experiencing it after a quite large system update (debian)
13:17:53 <aplavin> and haven't found any solution in google :(
13:18:54 <supki> @google  eventfd: unsupported operation (Function not implemented)
13:18:56 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/7926
13:18:57 <lambdabot> Title: #7926 (eventfd: unsupported operation when doing anything) – GHC
13:19:45 <aplavin> supki: yes, but no solution there
13:20:27 <chrisdone> arkeet: hmm, i can't figure out how to do it
13:20:50 <supki> that probably means there isn't one
13:21:05 <arkeet> :(
13:21:32 <chrisdone> arkeet: https://developers.google.com/chart/image/docs/gallery/radar_charts
13:21:52 <arkeet> also, what timezone is this in?
13:22:13 <arkeet> also, the most active times on the front should be the same kind of plot :p
13:22:24 <chrisdone> arkeet: it's in UTC
13:22:29 <arkeet> ok.
13:22:56 <aristid> @quote =)
13:22:56 <lambdabot> Plugin `quote' failed with: user error (parseRegex for Text.Regex.TDFA.String failed:"=)" (line 1, column 2):
13:22:56 <lambdabot> unexpected ')'
13:22:56 <lambdabot> expecting "?", "+", "*", "{", empty () or anchor ^ or $, an atom, "|" or end of input)
13:23:01 <chrisdone> hmm maybe i can close the loop
13:23:08 <aristid> @quote \=\)
13:23:08 <lambdabot> beaky says: why did they settle on bitshiftrightassign (>>=) for monadic bind?
13:23:12 <arkeet> chrisdone: I think you just need to add another point for 24
13:23:22 <aristid> @quote \s\=\)
13:23:22 <lambdabot> No quotes match. Are you typing with your feet?
13:23:25 <aristid> hum
13:23:31 <chrisdone> arkeet: nah, that would just leave you with 24 and 0 next to eachother
13:23:47 <arkeet> the first two examples in that page manage to do it.
13:23:55 <chrisdone> i think i need to add an extra data point with no associated label, like this one: https://chart.googleapis.com/chart?cht=r&chs=200x200&chd=t:10,20,30,40,50&chxt=x&chxl=0:|1|2|3|4
13:23:59 <arkeet> yes
13:24:07 <aristid> @quote [^>]=\)
13:24:07 <lambdabot> frustrated says: <byorgey> that frustrated feeling that you are just not getting it is the feeling of your brain expanding =)
13:24:13 <aristid> i give up.
13:24:32 <arkeet> maybe you should fill it too.
13:24:59 <chrisdone> yaay, adding a data point without a label closed the loop ^_^
13:25:04 <arkeet> hooray.
13:25:17 <chrisdone> hmm yeah filling probably looks nicer, lemmie check the api
13:26:48 <Lethalman> given (a -> a, a -> a) how can I apply those functions to (a, a) ?
13:27:14 <arkeet> :t id *** id
13:27:15 <lambdabot> (a, a1) -> (a, a1)
13:27:18 <arkeet> oops.
13:27:21 <arkeet> that's not it.
13:27:21 <tornate> hi, when trying to install pandoc with cabal, i get a confusing error message http://paste.ohai.su/2830/32743137/
13:27:39 <chrisdone> :t curry (***)
13:27:40 <Lethalman> @hoogle (f a, f a) -> (a, a) -> (a, a)
13:27:40 <lambdabot> No results found
13:27:40 <lambdabot>     No instance for (Arrow (,)) arising from a use of `***'
13:27:40 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
13:27:40 <lambdabot>     In the first argument of `curry', namely `(***)'
13:27:41 <arkeet> @djinn (a -> a', b -> b') -> (a,b) -> (a',b')
13:27:41 <lambdabot> f (a, b) (c, d) = (a c, b d)
13:27:50 <arkeet> @@ @pl @djinn (a -> a', b -> b') -> (a,b) -> (a',b')
13:27:50 <lambdabot>  f = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .))
13:27:52 <arkeet> ;P
13:28:17 <chrisdone> :t uncurry (***)
13:28:18 <lambdabot> Arrow a => (a b c, a b' c') -> a (b, b') (c, c')
13:28:23 <arkeet> that's the one.
13:28:27 <chrisdone> i always get uncurry/curry mixed up
13:28:35 <arkeet> :t (***)
13:28:36 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
13:28:36 <Lethalman> oh yeah
13:28:52 <Lethalman> good one thanks
13:29:24 <arkeet> but really we need a better way.
13:29:50 <arkeet> something were we can have stuff like apOf
13:29:51 <Lethalman> :t a b c -> a (b, b) (c, c)
13:29:52 <lambdabot> parse error on input `->'
13:30:02 <Lethalman> @hoogle a b c -> a (b, b) (c, c)
13:30:02 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
13:30:02 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
13:30:02 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
13:30:11 <arkeet> :t join (***)
13:30:12 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
13:30:23 <arkeet> :t over both
13:30:23 <Lethalman> \o/
13:30:24 <lambdabot> (a -> b) -> (a, a) -> (b, b)
13:30:26 <chrisdone> arkeet: filled =)
13:30:29 <arkeet> =)
13:30:38 <Lethalman> :t join
13:30:40 <lambdabot> Monad m => m (m a) -> m a
13:30:49 <Lethalman> _why_ is it like that :P
13:30:52 <chrisdone> yeah i'll switch the times on the home page
13:30:59 <geekosaur> huh?
13:31:05 <aristid> chrisdone: to CET/CEST? great!
13:31:50 <arkeet> now make the word cloud clickable. :P
13:31:53 <chrisdone> aristid: UTC TIME IS BEST TIME PRAISE THE MOTHERLAND
13:31:53 <arkeet> er, nick cloud
13:32:14 <Peaker> two of the projects I've tried to contribute to today have used Windows newlines, which totally destroys my ability to use "git add -p", "git diff", etc..  and running dos2unix on their project's files seems a bit rude :(
13:32:26 <arkeet> Peaker: git has a feature for that
13:32:31 <Peaker> arkeet, what is it?
13:32:34 <arkeet> for translating newlines
13:32:35 <aristid> @quote nilpotent lie
13:32:35 <lambdabot> No quotes for this person. And you call yourself a Rocket Surgeon!
13:32:36 <Lethalman> git should gracefully handle windows newlines
13:32:38 <aristid> @quote nilpotent.lie
13:32:38 <lambdabot> not-gwern says: 'You say you're the world's greatest systems programmer, but all you academics know how to do is prove academic theorems about the module substructure over nilpotent Lie algebras,
13:32:38 <lambdabot> and even then you can't manage to generalize it past the two-step case. Your method fails to scale, because in the real world, nilpotent Lie algebras can take as many as ten steps to get to zero.
13:32:38 <lambdabot> Just like your statistic
13:32:39 <arkeet> I forget what it's called.
13:32:47 <Lethalman> :t join (***)
13:32:47 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
13:32:50 <Lethalman> really :S
13:32:54 <Lethalman> let's talk about it ahah
13:33:05 <arkeet> https://help.github.com/articles/dealing-with-line-endings
13:33:35 <arkeet> hmm
13:33:45 <Lethalman> what is m here?
13:33:46 <arkeet> the stuff in the repo contains crlf?
13:33:55 <arkeet> Lethalman: (->) t
13:33:58 <Lethalman> (->) ?
13:33:59 <Lethalman> ok
13:34:08 <arkeet> join f x = f x x
13:34:52 <Lethalman> oh
13:35:05 <arkeet> :t join `asAppliedTo` (undefined :: a -> b)
13:35:05 <lambdabot> (a1 -> a1 -> a) -> a1 -> a
13:35:06 <Lethalman> :t join f
13:35:06 <lambdabot> (Monad m, FromExpr (m (m a))) => m a
13:35:33 <Lethalman> :t join f x
13:35:34 <lambdabot> FromExpr a => a
13:35:38 <roboguy_> arkeet: where are over and both from?
13:35:43 <arkeet> roboguy_: lens
13:35:58 <arkeet> > join f x
13:36:00 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
13:36:00 <lambdabot>    arising from a us...
13:36:02 <arkeet> > join f x :: Expr
13:36:03 <lambdabot>   f x x
13:36:32 <Lethalman> > join f :: Expr
13:36:33 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
13:36:33 <lambdabot>              w...
13:36:42 <Lethalman> :t join id
13:36:43 <lambdabot>     Occurs check: cannot construct the infinite type: a1 = a1 -> a0
13:36:43 <lambdabot>     Expected type: a1 -> a1 -> a0
13:36:43 <lambdabot>       Actual type: a1 -> a1
13:36:57 <Lethalman> :t join (+)
13:36:58 <lambdabot> Num a => a -> a
13:37:17 <arkeet> > join (+) 5
13:37:22 <lambdabot>   10
13:37:28 <Lethalman> but... m in this case?
13:37:37 <Lethalman> it's something with (->) but still can't get it
13:37:38 <arkeet> m = (t ->)
13:37:44 <arkeet> well, (->) t
13:37:49 <ion> @type join `asTypeIn` \join -> join (+) 5
13:37:50 <roboguy_> arkeet: hmm that's what I thought. I was confused because I couldn't find it on hoogle
13:37:50 <lambdabot> Num a => (a -> a -> a) -> a -> a
13:37:53 <Lethalman> ok in the case of (+) ?
13:37:59 <arkeet> same thing
13:38:06 <arkeet> (+) is a function that takes two arguments.
13:38:07 <nooodl> m (m a) -> m a   becomes   (t -> t -> a) -> t -> a
13:38:10 <arkeet> ^
13:38:24 <arkeet> :t join `asAppliedTo` (+)
13:38:25 <lambdabot> Num a => (a -> a -> a) -> a -> a
13:38:27 <Lethalman> m a is t -> a and it's ok
13:38:40 <Lethalman> but m (m a) uhm
13:38:43 <Lethalman> m (t -> a)
13:38:45 <arkeet> t -> (t -> a)
13:38:45 <aristid> "now they have two problems" jokes are lame.
13:38:55 <nooodl> (t -> (t -> a)) is the same thing as (t -> t -> a)
13:38:59 <nooodl> (see: currying)
13:39:03 <Lethalman> arkeet, ok
13:39:06 <ion> Now you have two lame jokes.
13:39:28 <Lethalman> thanks
13:39:34 <arkeet> roboguy_: right, lens isn't indexed by hoogle.
13:39:42 <Razz|at_work> Guys, my brother Bob is participating in a photography contest, and here I am shamelessly trying to get him some votes :-P: http://canon.nrc.nl/Picture/view/9545 :-)
13:39:55 <Lethalman> :t join (***)
13:39:56 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
13:40:07 <arkeet> Razz|at_work: wrong channel
13:40:44 <Razz|at_work> arkeet: oops, wrong window, thx
13:41:29 <tornate> hi, when trying to install pandoc with cabal, i get a confusing error message http://paste.ohai.su/2830/32743137/
13:42:34 <Lethalman> so... arkeet if I want \f (x,y) (x',y') -> (f x x', f y y')
13:42:40 <Lethalman> what's the magic with arrows :P
13:42:57 <arkeet> :t join (***)
13:42:58 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
13:42:58 <Lethalman> I can think of starting from something like \f (x, y) -> (f x, f y)
13:43:14 <Lethalman> arkeet, well that's different
13:43:27 <chrisdone> in my daily life arrows are only useful for clever tuple tricks
13:43:33 <arkeet> right.
13:43:36 <arkeet> well, not arrows then.
13:43:53 <chrisdone> well, just one arrow
13:43:54 <chrisdone> =)
13:44:13 <arkeet> Lethalman: if you're doing this in actual code, just write it pointfully.
13:44:16 <arkeet> with a lambda or something.
13:44:30 <Lethalman> arkeet, I know but I'd like to try for exercise
13:45:18 <arkeet> if only we had liftA2Of.
13:45:24 <arkeet> shachaf: let's figure it out.
13:45:34 <arkeet> and by let's I mean you.
13:45:39 <Peaker> Lethalman, I think my windows newlines stuff may have been emacs-shell related rather than git related. Still annoying that toolchain breaks because of archaic MS mistakes when I don't have a shred of MS on my machine :(
13:47:26 <Lethalman> Peaker, ah
13:47:51 <arkeet> @let newtype Pair a = Pair { unPair :: (a,a) }
13:47:52 <lambdabot>  Defined.
13:48:01 <NemesisD> hey guys, i was wondering if you guys had some advice on where i should seek out API design help for haskell libraries. not sure if chat is the right format
13:48:10 <Taneb> @type uncurry . ((.) . flip (.) <*> (.) (,))
13:48:11 <lambdabot> (a -> b) -> (a, a) -> (b, b)
13:48:15 <arkeet> @instance Functor Pair where fmap f = f *** f
13:48:16 <lambdabot> Maybe you meant: instances instances-importing
13:48:19 <arkeet> @let instance Functor Pair where fmap f = f *** f
13:48:20 <lambdabot>  .L.hs:140:18:
13:48:20 <lambdabot>      Couldn't match type `(b, b)' with `Pair b'
13:48:20 <lambdabot>      Expected ...
13:48:37 <arkeet> @let instance Functor Pair where fmap f (Pair (x,y)) = Pair (f x,f y)
13:48:38 <lambdabot>  Defined.
13:49:10 <Peaker> NemesisD, maybe cafe?
13:49:25 <arkeet> @let instance Applicative Pair where pure x = Pair (x,x); Pair (f,g) <*> Pair (x,y) = Pair (f x, g y)
13:49:25 <lambdabot>  Defined.
13:49:58 <arkeet> :t \f a b -> unPair (liftA2 f (Pair a) (Pair b))
13:49:59 <lambdabot> (a1 -> b -> a) -> (a1, a1) -> (b, b) -> (a, a)
13:50:01 <arkeet> oh well.
13:50:28 <arkeet> Pair = (Bool ->)
13:50:52 <arkeet> @let pair (x,y) b = if b then y else x
13:50:53 <lambdabot>  Defined.
13:51:02 <arkeet> @let unpair f = (f False, f True)
13:51:02 <lambdabot>  Defined.
13:51:12 <arkeet> :t \f a b -> unpair (liftA2 f (pair a) (pair b))
13:51:13 <lambdabot> (t -> t1 -> c) -> (t, t) -> (t1, t1) -> (c, c)
13:52:24 <Taneb> @type uncurry <$> liftA2 fmap (distribute fmap) (fmap (,)) -- pointless \f (a, b) -> (f a, f b) as neat as I can make it without arrow or lens
13:52:25 <lambdabot>     Not in scope: `distribute'
13:52:25 <lambdabot>     Perhaps you meant `distrib' (imported from Control.Lens.Indexed)
13:52:33 <Taneb> @type uncurry <$> liftA2 fmap (flip fmap) (fmap (,)) -- pointless \f (a, b) -> (f a, f b) as neat as I can make it without arrow or lens
13:52:34 <lambdabot> (b -> a) -> (b, b) -> (a, a)
13:53:14 <elliott> that is not very neat.
13:53:26 <Taneb> No it is not
13:53:41 <Taneb> Maybe I just don't like brackets?
13:53:51 <Taneb> Maybe I have a warped measure of neat?
13:54:11 <Taneb> Maybe I was trying to see if it could be generalized then forgot to ungeneralize it again?
13:54:41 <Taneb> Maybe all three?
13:55:49 <elliott> it's ok Taneb. it's ok
13:56:48 <mapreduce> Perhaps you can invent a language that uses successively larger numbers of spaces instead of brackets.
13:57:01 <mapreduce> 2 + 3*5  /  10
13:57:42 <Lethalman> !!!!
13:57:42 <Lethalman> > uncurry (***) (join (***) (+) (3,4)) (6,7)
13:57:43 <lambdabot>   (9,11)
13:57:47 <shachaf> arkeet: You want to figure it out? Sure!
13:57:53 <arkeet> yes, you do.
13:58:26 <arkeet> :t (uncurry (***) .) . join (***)
13:58:27 <lambdabot> Arrow a => (b1 -> a b c) -> (b1, b1) -> a (b, b) (c, c)
13:58:32 <mauke> '"2 + '3 * 5'" / 10'  -- intercal style
13:58:38 <arkeet> uh
13:58:42 <arkeet> I guess.
13:59:29 <arkeet> shachaf: for starters, it should work on any Iso
13:59:42 <franco00> (probably naive question) javascript : JSON = Haskell : x <--- x?
13:59:56 <arkeet> ????
14:00:17 <franco00> (what's the JSON of haskell, if there is any)
14:00:21 <Taneb> franco00, algebraic data types
14:00:27 <Taneb> That you yourself can define!
14:00:39 <slack1256> also there are packages for json
14:01:03 <mauke> franco00: no such thing
14:01:18 <arkeet> not that you should interpret json as javascript anyway.
14:01:22 <franco00> :) indeed Taneb . I probably cannot read a txt full of algebraic data types to import some data. I know there is a package for json, just wondered if there was something 'standard' in the haskell community
14:01:25 <arkeet> so it's a pretty silly idea.
14:01:45 <Taneb> franco00, for that, sometimes we use JSON!
14:01:55 <Taneb> But I'm not the best person to answer this
14:02:00 <niteria> cereal?
14:02:01 <Taneb> In fact, I'm going to go now
14:02:03 <Taneb> bye!
14:02:10 <franco00> thanks and bye
14:02:18 <arkeet> niteria: have fun getting something human-readable with cereal.
14:02:19 <niteria> Show, Read instances?
14:02:26 <Demos> franco00: Haskell : Haskell
14:02:27 <shachaf> arkeet: I've complained about the absence of this before.
14:02:33 <arkeet> shachaf: me too.
14:02:34 <Demos> just as JSON is valid javascript
14:02:35 <shachaf> arkeet: I'll be glad when you figure it out.
14:02:43 <arkeet> I'll be glad when you figure it out too.
14:03:02 <shachaf> arkeet: (I think it *might* even be possible without rank-2 types. But I'm not sure of the details. That's your job.)
14:03:16 <arkeet> I'm not afraid of rank-2 types to start with.
14:03:26 <franco00> thanks, niteria and Demos
14:03:30 <niteria> I may be wrong but automatically dericed Show and Read instances are inverses of each other
14:03:39 <arkeet> they're supposed to be.
14:03:44 <Lethalman> yes!!!!! got it
14:04:15 <shachaf> arkeet: Yes, but it would be awful if this require rank-2 types.
14:04:20 <Lethalman> :t let apply2 f x y = uncurry (***) ((***) f f x) y in apply2 (apply2 (+))
14:04:21 <lambdabot> Num c => ((c, c), (c, c)) -> ((c, c), (c, c)) -> ((c, c), (c, c))
14:04:26 <elliott> it wouldn't require rank-2 with o/i lenses
14:04:36 <elliott> I assign arkeet to think of a good word for "lenses"
14:04:38 <elliott> meaning any lensy thing
14:04:42 <arkeet> optics
14:04:43 <Lethalman> :t let apply2 f x y = uncurry (***) ((***) f f x) y in apply2 (apply2 (+) (-1,-2))
14:04:44 <lambdabot>     Couldn't match type `(c1, c1)' with `b0 -> c0'
14:04:45 <lambdabot>     Expected type: (c1, c1) -> b0 -> c0
14:04:45 <lambdabot>       Actual type: (c1, c1) -> (c1, c1)
14:04:46 <elliott> the best I've come up with is -- yeah.
14:04:48 <elliott> but it's kind of bad.
14:04:50 <Lethalman> nooo
14:04:57 <arkeet> glass
14:05:11 <elliott> glass.
14:05:14 <elliott> you're terrible
14:05:16 <arkeet> :(
14:05:26 <elliott> it's ok. I still like you.
14:05:41 <shachaf> hey i'm the terrible one around here........
14:06:20 <chrisdone> that ellispsis is the only terrible thing in here
14:06:31 <chrisdone> and my spelling of ellsispsisis
14:07:00 <shachaf> That's not an ellipsis, it's a sequence of dots.
14:07:08 <shachaf> I was very firm with my sentence.
14:07:34 <NemesisD> gah anyone know how to rig ghci to load a cabal project you're working in?
14:07:42 <Peaker> anyone got a chance to toy around with the FPComplete IDE?
14:07:47 <NemesisD> it seems to not be able to traverse the source tree when i try to load anything
14:07:53 <arkeet> NemesisD: have you tried things like cabal-dev or hsenv?
14:08:13 <nobbb> there is cabal-ghci
14:08:25 <NemesisD> arkeet: using hsenv, but i think you still have to pass some special incantations to it im thinking
14:08:33 <monochrom> isn't it simply using ghci's -i properly?
14:08:38 <chrisdone> Peaker: yeah
14:08:49 <arkeet> NemesisD: cabal install inside hsenv works for me.
14:09:15 <arkeet> maybe you don't want to do that.
14:09:39 <NemesisD> arkeet: tried cabal install myproject.cabal; ghci; import MyProject and no dice
14:09:52 <Peaker> chrisdone, cool, how's it like?
14:09:56 <arkeet> "no dice" as in
14:09:56 <Peaker> chrisdone, standard textual stuff?
14:09:57 <arkeet> what happens?
14:10:11 <Peaker> chrisdone, JetBrains-like? Or anything close?
14:10:28 <NemesisD> arkeet: could not find module Network.HTTPMock (toplevel module of my project)
14:10:46 <NemesisD> arkeet: if i do ghci -i src/Network/HTTPMock.hs it can't find one of the other modules in the project
14:10:56 <arkeet> it's in your .cabal file?
14:10:57 <monochrom> it's -i src
14:11:44 <NemesisD> arkeet: under other modules. monochrom when i do that it complains that src is not a module name or a source file
14:11:54 <arkeet> not -I ?
14:11:56 <monochrom> also, ghci gets very confused if Network.HTTPMock is both in a package and has source code found
14:12:01 <arkeet> indeed.
14:12:32 <NemesisD> ok ill uninstall the package then
14:13:27 <chrisdone> Peaker: standard textual stuff, editing-wise, if you were wondering if there was some structured stuff
14:13:32 <monochrom> or -hide-package the_package
14:13:38 <Peaker> chrisdone, any smart completions? type-awareness?
14:13:56 <Peaker> chrisdone, what's your general impression? better than emacs?
14:13:58 <chrisdone> Peaker: did you see the beta announcement? beta release will be on the 29th
14:13:59 <NemesisD> monochrom: unregistering the package didn't seem to help
14:14:20 <Demos> is it better than visual studio?
14:14:28 <Peaker> chrisdone, oh, I must have missed that :) I thought a select few were already toying around
14:14:59 <chrisdone> presently yeah, but the beta opened it up to sign-ups
14:15:45 <monochrom> oh! -isrc, no space
14:15:49 <Peaker> Demos, if it can do Haskell, then at least in one way it is already better than Visual Studio :)
14:16:27 <monochrom> GHC user's guide section 4.7.3
14:16:49 <Demos> Peaker: well yeah :D
14:17:00 <NemesisD> monochrom: i still can't import the module
14:17:20 <NemesisD> "it is not a module in the current program or in any known package"
14:17:31 <nobbb> have you tried cabal-ghci?
14:17:36 <monochrom> it works for me
14:18:06 <NemesisD> nobbb: do you reckon that would work with hsenv?
14:18:27 <nobbb> oh, probably not
14:19:31 <chrisdone> Peaker: there is type info, completion and jump to definition. standard IDE stuff. i'm one of the devs on it, with johnw
14:19:55 <NemesisD> bummer. i've found most of the challenge in writing haskell for me has just been finding a set of tools that will keep me out of cabal hell and allow me to use stuff like ghci properly. Makes me wonder what other people do, or if its a "you don't use an IDE" problem
14:20:00 * hackagebot hx 0.2 - Utility functions that some may feel are missing from Prelude and base.  http://hackage.haskell.org/package/hx-0.2 (JulianFleischer)
14:20:00 <Peaker> chrisdone, oh, cool, then I can expect great things :)
14:20:08 <Peaker> chrisdone, what kind of completion?
14:20:34 <Peaker> chrisdone, VS completions are basically "(" to func-call gives you func-args/docs, and "." gives you member list.. what kind do you give?
14:21:26 <NemesisD> nobbb: yeah it doesn't seem to work. it doesn't seem to use hsenv's packages
14:22:10 <Demos> actually VS completions compile stuff in the brckground (very slowly this is C++) with lots of metadata
14:22:49 <chrisdone> Peaker: name-based, not type-driven, very basic. like auto-complete.el
14:22:56 <NemesisD> monochrom: do you develop with hsenv or are you using just the raw ghci?
14:23:52 <Peaker> chrisdone, ah, so type info is auto-doc or such?
14:24:08 <monochrom> I just use ghci. when sandboxing is really needed, I do my own sandboxing, it's easy, it's just -package-db=blabhlah
14:24:09 <hpaste> “FASE CERO ” pasted “FASE CERO ” at http://hpaste.org/90283
14:24:57 <chrisdone> Peaker: we have type information of any identifier, top-level or local, but not sub-expressions yet. it's easy to do with ghc-mod, but the ghc api poses interesting challenges for scaling in memory restricted amazon servers =)
14:25:02 <monochrom> also, -isrc works, and it works even in a cabalized directory
14:25:39 <chrisdone> Peaker: Well Typed are consulting with us on that
14:25:48 <NemesisD> monochrom: any experience with the sandboxing in the latest cabal i keep hearing about? i'm just really tired of fighting haskell tools. would really just rather code :/
14:25:59 <monochrom> I have not used it or needed it.
14:26:12 <chrisdone> Peaker: what's auto-doc?
14:26:40 <monochrom> I have always just written code without a fight
14:26:45 <Peaker> chrisdone, I meant that type info is just a documentation thing
14:26:55 <Peaker> chrisdone, rather than an editing operation guidance thing
14:26:57 <chrisdone> Peaker: ah, no, it's properly analyzing it live
14:27:04 <chrisdone> ah
14:27:09 <NemesisD> monochrom: i tried the route of non sandboxing in the past, ended up putting my cabal package db in a precarious state on more than one occasion and was told to nuke my cabal db and go learn how cabal works from some paper
14:27:11 <chrisdone> right, in that sense, it's just informational
14:27:46 <NemesisD> basically i'm finding it very hard as a newcomer to know what the "right" thing to do is when so many routes lead to suffering
14:27:54 <SaBer> is there a function that prepends from Just and does nothing with Nothing? (Maybe a -> [a] -> [a])
14:28:00 <monochrom> I can't solve your problem because I can't reproduce it.
14:28:34 <supki> :t maybe id (:)
14:28:35 <lambdabot> Maybe a -> [a] -> [a]
14:28:36 <NemesisD> except i'm not really a newcomer. i've been doing haskell to some extent for over a year I think and still am unsure about the "right" way
14:29:14 <tommd> glguy: Ping
14:29:53 <Saizan> NemesisD: cabal-install seems to have much more conservative defaults now, so it should be considerably harder to mess up already installed packages
14:30:31 <elliott> SaBer: (++) . maybeToList!
14:31:17 <chrisdone> Peaker: it might get my structured editing, but later. the MVP includes things other than fancy editing utils, such as a stable library base that always builds and an easy deployment platform. you can create and run and deploy a yesod application in a few clicks. these are the kinds of things that companies interested in trying haskell care about
14:31:19 <Saizan> NemesisD: what things do you usually install?
14:31:25 <NemesisD> Saizan: we talking about cabal-install HEAD? my cabal-install is at 1.16.0.2. i don't know when or whether I should sandbox, just a feeling that I do from aversion therapy of inexplicably broken packages
14:31:42 <SaBer> elliott: I guess that would be optimized to be just as efficient as using (maybe id (:)) ?
14:32:06 <NemesisD> Saizan: usually falls into 2 categories: packages which provide system binaries I need everywhere, and then lots of libraries i need on my projects
14:32:08 <monochrom> cabal-install is conservative since 0.14 or earlier
14:32:08 <elliott> probably. probably you don't care though
14:32:23 <Saizan> NemesisD: as monochrom said
14:32:26 <elliott> does anyone know why the modular solver isn't default for cabal-install, btw?
14:32:33 <Peaker> chrisdone, yeah, it sounds very cool :)
14:32:40 <SaBer> elliott: I'm working on discrete optimization programming assignments, so I might care :)
14:33:03 <chrisdone> Peaker: mgsloan is especially interested in adding type annotations in the display itself, similar to lamdu but more based on his on work on showing the 'flow' of types
14:33:16 <elliott> SaBer: may you be blessed with more difficult bottlenecks than that
14:33:17 <Peaker> chrisdone, Happy to see Haskell IDE's taking shape.. lamdu will take a couple more years to replace the toolchains I use, so I'd love to have something better to use in the meantime
14:33:21 <NemesisD> monochrom, Saizan so does that mean if i am developing packages against whatever the latest versions of things are (even libraries like bytestring, text, etc), i should not have to use any sort of sandboxing?
14:33:24 <Saizan> NemesisD: yeah, but which libraries, also if you are doing global installs you should use --root-cmd=sudo
14:33:39 <chrisdone> Peaker: but yeah, start-ups have to make something usable before they can be confident to try to innovate in every category, of course =)
14:33:47 <NemesisD> Saizan: i have my user's .cabal/bin directory in the path so not global
14:33:59 <Peaker> chrisdone, we changed the default mode not to show subexpr types, it's too noisy.. great to enable it with a single keystroke when debugging type issues
14:34:12 <chrisdone> yeah a toggle is nice
14:34:37 <Saizan> NemesisD: installing new versions of packages that came with ghc is a common source of problems
14:34:39 <monochrom> you should still sandbox
14:34:46 <NemesisD> Saizan: if i provided you a list it would probably be dozens and dozens of lines long, and some projects at varying version constraints based mostly on how recently the project was started.
14:34:46 <chrisdone> one thing me and mgsloan thought of was showing old versions of types, or showing what the type checker is thinking
14:35:23 <chrisdone> a type error is kind of un-user-friendly, better would be for it to tell you what it was trying to do and what it was unifying
14:35:37 <monochrom> cabal-install is still not conservative enough IMO. not even HEAD. not even the next two years I bet.
14:36:10 <NemesisD> Saizan: i don't necessarily want newer versions of packages. it isn't a conscious decision, for most packages like text and bytestring, i'm not actually depending on some bleeding edge API, whatever cabal can find lying around is probably fine
14:36:20 <monochrom> until the day cabal-install forbid two appearances of the same package name (different versions or same version), I call it not conservative enough
14:36:26 <chrisdone> Peaker: hmm structural diff, too, i think might be something i'll push for
14:36:29 <NemesisD> monochrom: that's pretty depressing
14:37:00 <Peaker> chrisdone, cool.. how would you chose a diff, though? How can you correlate subexprs now with subexprs from before?
14:37:01 <chrisdone> Peaker: in lamdu, it prevents you from 'committing' wrongly typed values right? you can write them, but it won't let you insert it
14:37:27 <NemesisD> it is quite confusing to me because I see a lot of people getting a lot more work done than i am in haskell and yet i keep seeing the same problems and not finding solutions
14:37:28 <Peaker> chrisdone, yeah -- any badly typed thing is wrapped in a "wrapper hole" that says the actual vs. expected type
14:37:52 <Peaker> chrisdone, letting you either: 1) edit the expression till its type is a match, the wrapper hole becomes green and lets you remove it.   2) insert a transformation of the bad expr
14:38:26 <Peaker> so we still have a "type error" but it is always localized to a particular subexpr, and is a UI thing.. under the UI, the types always work out so we never have a problem of not having some types
14:38:27 <chrisdone> right. that's cool. a fun idea would be to 'step through' the type checker like a debugger
14:39:01 <Peaker> chrisdone, well, in the debug-types-mode (showing subexpr types), we intend to add little Icons for each type constraint that flowed into that position, allowing you to know where constraints came from
14:39:02 <chrisdone> (but that's mgsloan's idea, i just like the sound of it)
14:39:15 <chrisdone> that sounds cool =D
14:39:20 <Peaker> so each type rule/constraint will get its own icon, and clicking/pressing it will jump to the source of the constraint
14:39:22 <Saizan> NemesisD: maybe you should log what you do and then look for where the problems come :)
14:39:35 <Saizan> NemesisD: or sandbox preventively
14:39:36 <chrisdone> Peaker: sounds tricky to actually display in a clean way
14:39:38 <NemesisD> monochrom: pretty much just curious how people are working around these deficiencies with cabal without tearing their hair out
14:40:11 <Peaker> chrisdone, well, subexpr types are already tricky/noisy, which is why they're disabled by default.. if you enable them, it'll just add icons next to the displayed types, which is ok because it's noise you explicitly asked for
14:40:46 <NemesisD> Saizan: i sandbox with hsenv now, the whole thing that started this was just that under hsenv i can't get things like cabal-ghci to work, nor can i get ghci to actually load my project even though it builds fine. things like that that grind my development to a halt
14:42:35 <Saizan> NemesisD: even if you "activate" ?
14:42:58 <Saizan> anyhow, maybe try some other sandboxing option then
14:43:17 <Saizan> or ghci option
14:44:04 <NemesisD> Saizan: the only other one I know is cabal-dev, and i stopped using that as it is an incomplete solution: it does not work for stuff like ghci and makes you rewrite all your tooling to use cabal-dev instead of cabal instead
14:44:15 <elliott> git cabal has sandboxing
14:44:17 <elliott> it's great
14:44:44 <Saizan> there's cabal2ghci
14:45:12 <supki> NemesisD: how does cabal-dev not work with ghci?
14:45:42 <Saizan> yeah, i thought it had a ghci command
14:45:55 <NemesisD> elliott: maybe that's next. my hope is that the community converges on one solution that actually solves a problem and then the only person who has to worry about that is the group maintaining the solution
14:46:16 <NemesisD> i don't remember, maybe it didn't when i used it
14:46:22 <chrisdone> Peaker: i'm still thinking about structural diff, it seems to require a structured viewer in order for it to make sense
14:46:50 <NemesisD> sorry to complain so much, this is just roughly a 1 year long depressive battle trying to figure out how to stop worrying about tools and get work done in haskell
14:47:28 <Peaker> chrisdone, that shouldn't be tough to write, if it's just a viewer, not an editor
14:47:31 <Saizan> NemesisD: I think the fastest solution would have been to care more about the tools from the start
14:48:31 <NemesisD> Saizan: i understand if that's the case but you must admit that is a pretty dreadful tact to have to take from a community looking to attract beginners
14:48:46 <Peaker> chrisdone, I think tough parts might be handling annoying things like code that just moved between files, or detecting stuff was just renamed and/or moved, and handling syntax errors in committed changes.. all the textual legacies :(
14:49:42 <NemesisD> Saizan: i'd argue most devs do not need or want to know how their language's packaging system works. thats not why they select the language
14:49:57 <Saizan> NemesisD: it's a community with limited resources too, the tools are improving but it takes time
14:49:58 <chrisdone> Peaker: thoughts i had: use tree labels instead of line numbers. so a diff between [(1,'a'),(2,'b')] and [(1,'c'),(5,'b')] could be described as: 1.1.2 - 'a' + 'b', 1.2.1 - 2 + 5
14:50:16 <NemesisD> elliott: did you literally just compile from HEAD?
14:50:38 <elliott> NemesisD: you install Cabal from HEAD and then cabal-install from HEAD
14:50:39 <chrisdone> Peaker: right. there're levels of the diff. purely textual, name-resolving, and type-resolving
14:50:45 <elliott> NemesisD: I was scared too. but dcoutts told me it was ok.
14:50:48 <Saizan> NemesisD: sure, but there's always some tool that gets in the way, e.g. git is not exactly something you can use mindlessly
14:52:02 <chrisdone> Peaker: with the ghc api i suppose the name renaming resolution is easier
14:52:10 <Peaker> chrisdone, Usually diffs de-emphasize line numbers.. The main problems involve spurious conflicts because of whitespace, refactoring stuff harmlessly, renaming variables -- so the main benefit would be not in the way the position of a diff is displayed, but rather allowing ignoring/resolving textual differences that amount to unimportant semantic diffs
14:52:27 <NemesisD> Saizan: that's true. i just think that if the ideal solution is a ways off, it would be helpful to at least build some guard rails and some road signs so newcomers know how to keep themselves from careening off a cliff, burning out, and cursing the language the rest of their days
14:52:38 <Peaker> I think the most frequent horribleness is code move.. that will conflict with anything at all, despite being completely harmless
14:52:48 <burkaman> Hey, does anyone know if the pointfree package builds on the latest Haskell Platform? I'm getting "Not in scope: data constructor `State'" when I try to cabal install it, which doesn't really make sense to me.
14:52:57 <NemesisD> elliott: the 483 open issues is daunting, lol, but i trust dcoutts
14:53:12 <chrisdone> Peaker: hmm, we're talking about a structural diff though. who cares about whitespace or textual differences?
14:53:17 <Peaker> chrisdone, maybe that's what you meant with the line number thing?  If definitions' order changed, and someone touched a definition, then you can still resolve the "conflict"
14:54:20 <Peaker> chrisdone, well, it's not just that.. maybe someone moved something from "let" into "where" or even from "let" to "<-" because it now has an effect. and someone else changed something inside a subexpr, need to detect which subexpr is which (a heuristic we'll work very hard not to have to implement in lamdu by tracking all modifications)
14:54:58 <Peaker> chrisdone, if you make code moves not conflict with every other thing it would probably already solve 90% of the silly conflicts :)
14:55:01 <Saizan> NemesisD: monochrom has a nice guide on that line, maybe it was the "paper" you got linked before?
14:56:22 <NemesisD> Saizan: it probably was. i think i'll read it this weekend. as much as i'd like to not think about how cabal works, i dont want to end up having to give up on the language because of this
14:56:34 <chrisdone> Peaker: yeah that's more than ast level structure
14:57:17 <Peaker> chrisdone, well code moves within same file is still AST structure, and you can compare it without regard to order
14:58:19 <Peaker> instead of storing [Definition] in AST, you can store   (Map Name Definition, [Name])  and do ordinary textual diff on [Name] to resolve conflicts if there are 2 conflicting order changes.  But manage conflict resolution between definitions by name
14:58:22 <chrisdone> moving a let to a where is beyond AST information
14:58:54 <Peaker> chrisdone, ah... in lamdu every subexpr has a unique ID, so such a move won't conflict with a subexpr change inside the expr that was moved
14:59:58 <chrisdone> yeah, i know, that's my point
15:00:21 <Peaker> oh, sorry for misunderstanding
15:01:05 <Peaker> anyway, awesome that you guys released something :)
15:01:18 <Peaker> emacs isn't too great for doing Haskell :-(
15:01:58 <chrisdone> that information isn't in an ast, that information is in your editor, your editor knows and stores identity and preserves it across moves. maybe you can redefine AST to mean "abstract syntax and identity tree", then i'll go along with that meaning
15:02:24 <NemesisD> monochrom: was that article about cabal the "Storage and Identification of Cabalized Packages" one?
15:02:35 <ment> Peaker: try "sam"
15:03:44 <Peaker> chrisdone, You're right, conventional AST doesn't include it
15:05:18 <chrisdone> Peaker: anyway, i was just trying to be clear what level we're talking about. having identity for each node is definitely cool
15:05:49 <chrisdone> Peaker: i suppose (1,1) -> (1,1) would actually be recognized as a change?
15:06:15 <chrisdone> i guess it could ignore literals that are equal
15:06:25 <Peaker> chrisdone, you mean if you replace the identities?
15:06:27 <chrisdone> maybe (1*2) and (2*1) can be considered the same
15:06:36 <chrisdone> yeah, if you transpose 1 and 2
15:06:39 <chrisdone> er, 1 and 1
15:06:58 <Peaker> chrisdone, yeah, though conflict resolution strategy may ignore such a change, maybe
15:07:36 <chrisdone> it's interesting deciding where to draw the line
15:08:25 <chrisdone> ordering is pretty important as an intention of meaning, i tend to order things according to how i think about them, decls or 1*2 or w/e
15:08:53 <chrisdone> but the editor could re-order them to something normalized like alphabetical or whatever the user chooses
15:09:07 <chrisdone> do you have modules in lamdu?
15:10:18 <chrisdone> when the IDE is that much control over your code, http://erlang.org/pipermail/erlang-questions/2011-May/058768.html springs to mind
15:11:02 <chrisdone> why bother with modules at all and not just functions that can be looked up and inserted by identity?
15:11:42 <chrisdone> Data.Text.map or Prelude.map? who cares, the IDE knows and will tell you
15:11:58 <chrisdone> becomes more compelling in something like lamdu, i think
15:17:11 <Peaker> chrisdone, sorry, was away for a sec
15:17:24 <Peaker> chrisdone, We do intend to treat user orderings as important -- just allow them not to conflict, not revert them
15:17:44 <Peaker> chrisdone, We do intend not to have modules in their traditional code-grouping sense
15:18:10 <Peaker> chrisdone, but OTOH we want to support abstract types, data hiding.. Basically creating and instantiating interfaces
15:18:27 <Peaker> We're still far from that though so we've only superficially discussed it/thought it through
15:19:04 <chrisdone> yeah
15:19:16 <Peaker> If you just write some utility function, you just give it a name, it has a type, and it can then be published and searched by these properties, without having to make up some silly: Data.Foo.Bar.Utils  module name for it, then a silly package name for it ("foo-bar-utils-1.01") and then upload it to publish it
15:19:32 <chrisdone> right, indeed
15:20:42 <chrisdone> i should be able to write: foo = html (do head (title "Hello") (body ! title "x" $ head ["OK"])
15:21:12 <chrisdone> and head and title will just be the right things because i specified it, and i didn't have to think about it because the IDE filtered on type
15:21:22 <Peaker> yeah, that kind of thing we already have :)
15:21:40 <Peaker> if you have a bunch of functions with the same name, it'll already let you use any of them filtered by type
15:21:41 <chrisdone> you should tell Joe about it ;)
15:21:47 <Peaker> who's Joe?
15:21:57 <chrisdone> joe armstrong, erlang guy?
15:22:19 <hseg> Was looking at the fixities of operators.  http://hpaste.org/90287 Is there a reason (.) is defined as infixr?
15:22:40 <Peaker> chrisdone, I think I must be missing some context? :)
15:22:59 <chrisdone> Peaker: i linked you a post by him positing such a system from 2011
15:23:05 <chrisdone> http://erlang.org/pipermail/erlang-questions/2011-May/058768.html
15:23:21 <Peaker> oh, I forgot
15:23:41 <Peaker> now I remember, didn't register the name
15:24:15 <chrisdone> Peaker: actually joe's doesn't take it all the way, he proposes unique names. we're talking about one step further, having identity separate to naming convention which the database knows
15:24:32 <chrisdone> (unique names is pretty stupid imo)
15:24:32 <Peaker> btw: Our functions are Smalltalk-ish in that params have names which are visible when you choose between them.. so we have: "take count" and "take while"  (count/while are displayed underneath, smaller, as param names)
15:25:01 <Peaker> "take [1..100] while <some predicate>"
15:25:16 <Peaker> chrisdone, Agreed
15:28:16 <chrisdone> Peaker: so you could write: take while while
15:28:49 <Peaker> "while" is a parameter for the "take" func, so each "while" is accompanied by a "take" somewhere
15:29:12 <chrisdone> yeah
15:29:19 <chrisdone> and "while" is a predicate function i defined elsewhere =)
15:29:27 <chrisdone> so: take while while
15:30:01 * hackagebot hx 0.2.1 - Utility functions that some may feel are missing from Prelude and base.  http://hackage.haskell.org/package/hx-0.2.1 (JulianFleischer)
15:30:03 * hackagebot java-reflect 0.9.9 - Tools for reflecting on Java classes.  http://hackage.haskell.org/package/java-reflect-0.9.9 (JulianFleischer)
15:30:03 <Peaker> http://i.imgur.com/aQu1Ep0.png
15:30:23 <Peaker> chrisdone, the "while" would be orange and not gray then :)
15:31:26 <hseg> Was looking at the fixities of operators.  http://hpaste.org/90287 Is there a reason (.) is defined as infixr?
15:32:11 <shachaf> Well, it's associative.
15:32:18 <Peaker> hseg, (.) is associative so it's a matter of performance considerations only
15:32:47 <Peaker> hseg, and f . (g . h)  is probably better than (f . g) . h   because sometimes evaluating left of (.) is enough to know whole result
15:32:50 <shachaf> Think of "(f . g) . h" vs. "f . (g . h)", when f = const x, say.
15:32:51 <chrisdone> Peaker: definitely needs a new colour palette =p
15:33:32 <Peaker> chrisdone, I exported our config to a json file https://github.com/Peaker/lamdu/blob/master/config.json  you can even change it while lamdu is running and it will update live :)
15:33:44 <Peaker> color palette is in there too.. could be nice to have an interactive editor for that
15:34:14 <chrisdone> rgb values have to be specified as decmials?
15:34:17 <hseg> OK. So on average, the left hand parameter for (.) is sufficient to decide the value of the expression more often than the right hand parameter?
15:34:42 <chrisdone> now i see why the colours are so crazy =p
15:35:18 <chrisdone> no one can be bothered translating them from a colour palette editor (which work in 255 triples/hex)
15:35:21 <Peaker> chrisdone, heh, we don't have a nice UI for that, but we probably should :)
15:35:39 <Peaker> until recently, modifying any color would be done in Config.hs which would rebuild a substantial part of the project
15:36:05 <Peaker> Got sick of that so spent the better part of a day to make the config come from a dynamic file.. next logical step is to have a nice UI to edit it
15:39:02 <aristid> Peaker: why are the fonts so huge?
15:39:05 <chrisdone> Peaker: i'm building it
15:39:26 <aristid> Peaker: and this does not look like haskell. take does not take a function oO
15:39:29 <chrisdone> aristid: the display is kind of dynamic, things resize as needed
15:39:47 <Peaker> aristid, I like large fonts.. you can zoom in/out with keys though
15:39:59 <aristid> hum
15:40:11 <Peaker> aristid, it's not take, it's "takeWhile", except it's called "take" with param name "while".. indeed, it's not exactly Haskell
15:40:33 <Peaker> aristid, it's very Haskell-like, but there are a few things we dislike about Haskell, and a few things that just don't match well with a good structural IDE
15:40:46 <aristid> Peaker: is it compatible with haskell though?
15:40:55 <Peaker> aristid, we do intend on having a good FFI with Haskell though.. it's too early to even run code though :)
15:41:25 <aristid> Peaker: are the function parameters named, but still curried? or uncurried?
15:42:34 <Peaker> aristid, not curried
15:43:00 <aristid> Peaker: :/
15:43:01 <Peaker> aristid, currying is one of the things that isn't that useful anymore once you have a good structural IDE around the language: the main advantage of currying is easy partial application.  We have that advantage without currying
15:43:40 <Peaker> A disadvantage of currying is that it makes naming parameters difficult -- and we want named parameters. So our functions of more than 1 arg take a single param which is a record, so we get named params
15:44:06 <aristid> can you make a screenshot showing off your alternative to currying?
15:45:04 <Peaker> aristid, we don't have that part of the UI implemented yet, but if you partially apply "take" to the "from" or the "count" arguments, you'll see it displayed with a named argument for whichever argument it did already get -- and some UI indicator for missing args
15:45:53 <aristid> Peaker: do you have the parameter names in the types?
15:45:59 <Peaker> aristid, yeah
15:46:06 <aristid> interesting:)
15:46:50 <Peaker> http://i.imgur.com/LRHoZcd.png
15:47:05 <Peaker> aristid, red {} is a record type, green {} (not shown here) is record value
15:47:16 <Peaker> aristid, so we do use currying currently for the type variables
15:47:20 <aristid> Peaker: so you have a real record type system?
15:47:34 <aristid> Peaker: do you plan on changing that as well?
15:47:34 <chrisdone> i wonder if it matters, in this IDE
15:47:37 <Peaker> aristid, the very basic core of one.. we don't yet do row polymorphism
15:48:19 <Peaker> aristid, note the type of "take" is:  (a:Set) -> { from : List a, while : a -> Bool } -> List a
15:48:32 <aristid> Peaker: do you have ideas for alternative renderings of the code structures?
15:49:22 <aristid> Peaker: the note being the (a:Set)?
15:49:22 <Peaker> aristid, yeah, if the "conventional" record parameter is in a type, we want to show it similarly to the way calls are shown. i.e: sugar it into vertical list of fields with their types where normally the value is in applications
15:49:35 <aristid> Peaker: i'm familiar with that notation from having toyed with agda a year ago
15:49:45 <Peaker> and we have 3 different "presentation modes" for functions:  "OO", "Verbose", and "Infix"
15:49:59 <Peaker> I'll make 3 screenshots to illustrate, sec.
15:50:55 <chrisdone> i suppose this is partly why structured editing hasn't taken off yet
15:51:04 <aristid> chrisdone: huh?
15:51:11 <chrisdone> unless you have the structured editor, you can't really talk about anything inside it =)
15:53:35 <aristid> chrisdone: you could make drawings i guess
15:53:54 <Peaker> Verbose: http://i.imgur.com/GsM8MeF.png   OO: http://i.imgur.com/70sGWkz.png    Infix:  http://i.imgur.com/5cVynaH.png
15:54:06 <Peaker> Unfortunately, iterate only has 2 args, so I couldn't show infix with >2 args :-)
15:54:19 <Peaker> Infix with >2 args gives you a box with additional arguments underneath the infix line
15:55:03 <Peaker> so notice how when I edit the iterate's presentation mode, the application of iterate on the bottom is presented differently
15:55:22 <Peaker> (I made iterate' because we can't currently edit presentation mode of "built-in" functions)
15:55:32 <aristid> so i guess + is just a function in Infix mode
15:56:12 <Peaker> yeah
15:56:24 <Peaker> http://i.imgur.com/hbuq2gJ.png <-- this is what it looks like if I name it "iterate" and "step" and "initial" (name conflicts)
15:56:44 <Peaker> name conflicts get suffixed with red numbers automatically and there's no "shadowing"
15:57:14 <Peaker> though in the context of "fibs" there's no name conflict
15:57:19 <aristid> Peaker: do you think there will be more presentation modes?
15:57:27 <Peaker> aristid, possibly, I'm not sure
15:57:39 <Peaker> aristid, maybe sqrt will be displayed mathy-like
15:57:54 <Peaker> maybe there will be user-defined widgets for stuff, like anti-macros
15:58:13 <Peaker> (code matches this pattern, sugar it into this sugar construct.   this sugar construct gets edited by this user-defined widget)
15:58:27 <Peaker> currently all the sugar patterns/rules are hard-coded, as well as the widgets to edit them
15:58:52 <aristid> Peaker: consider the case that you would decide that types should not be curried. i think the current syntax would make those fairly verbose
15:59:20 <Peaker> aristid, the types are hidden anyway, you have to explicitly press enter on a polymorphic application to expose the hidden type applications
15:59:36 <Peaker> (or to expose the hidden type lambdas)
16:00:02 * hackagebot errors 1.4.2 - Simplified error-handling  http://hackage.haskell.org/package/errors-1.4.2 (GabrielGonzalez)
16:00:15 <Peaker> only in the exported/inferred type of a definition they are shown, and even there, maybe we'll change them to be <A> or <A,B> rather than a:Set -> b:Set -> ...
16:00:34 <aristid> i kind of like the a:Set
16:00:46 <Peaker> We intend to s/Set/Type everywhere
16:00:50 <aristid> i suppose the question whether this will be a dependent language is secondary to your main goals :D
16:01:12 <Peaker> at first, we wanted DTs, but then we saw that it's not easy, and we have enough difficulties to work with as it is :)
16:01:23 <Peaker> we do hope to get to DTs eventually, in some Version 2 or such
16:01:23 <aristid> heh.
16:01:46 <Peaker> but we know and like the Haskell mode of programming, with nice type inference, and we want to get that working first.
16:01:51 <aristid> you could name it Epigram 2
16:01:57 <Peaker> hah
16:02:14 <aristid> who is we, other than you?
16:02:42 <Peaker> yairchu and me are developing this together
16:02:52 <Peaker> ~60% job on our own time
16:03:29 <aristid> what do you mean with "60% job"? *confused*
16:03:39 <Peaker> I mean we work 3 of 5 days a week on Lamdu
16:04:14 <Peaker> and other days for getting food/shelter money :)
16:04:47 <aristid> using freelance work?
16:06:35 <Peaker> (moved to #-blah)
16:08:46 <aristid> Peaker: do you have a UI for case statements already? (i believe that part is on-topic)
16:09:02 <Peaker> aristid, nope, implementing sum types is the next "big" thing to do
16:09:18 <Peaker> after we finish many small improvements on our TODO list.. our last big thing was record types
16:10:43 <Peaker> aristid, part of implementing sum types is implementing case statements
16:11:22 <Peaker> aristid, we want sums to be more like OCaml variants (I'm not sure if the name "structural" fits, but maybe it does.. so we have structural sums/products)
16:11:25 <aristid> Peaker: watching a subtext video, and it starts with a nice case statement UI.
16:11:55 <Peaker> subtext was an inspiration.. I think Jonathan Edwards is a bit of a wacko when it comes to PLT though :)
16:12:18 <aristid> i got there from the lamdu readme ;)
16:12:33 <aristid> and i wanted to sleep dammit :D
16:14:22 <chrisdone> Peaker: my ideal language/environment: strong static and/or dependent types, structured editing, semantic diffs/merge/scm, live update of running program, no modules, distributed, self-describing, extensible
16:14:23 <chrisdone> Peaker: that's: a bit of haskell/idris/ur, a bit of lamdu/interlisp/agda-mode, a bit of lamdu, a bit of smalltalk/lisp, a bit of erlang, a bit more of smalltalk/lisp/lamdu, a bit of lisp/z and my structured editing support
16:14:33 <chrisdone> Peaker: lamdu satisfies a bunch of the criteria which is nice
16:15:14 <aristid> chrisdone: dependent typing is perhaps indeed a bit much to add on for a first attempt as Peaker said
16:15:16 <roconnor> chrisdone: epigram-style type-directed development
16:15:56 <Peaker> chrisdone, which criteria are missing?  DT is only missing because implementing DT is hard (at least for now)
16:15:59 <chrisdone> roconnor: true
16:16:02 <aristid> i kind of think a less ambitious structured editor that allows editing existing languages would also be nice:)
16:16:03 <chrisdone> Peaker: live update?
16:16:12 <chrisdone> haskell *sucks* at live update
16:16:17 <elliott> I don't think DT is something you can just bolt on.
16:16:19 <Peaker> chrisdone, as in, hot upgrades?
16:16:19 <elliott> it changes the game
16:16:42 <Peaker> elliott, I agree, but a lot of the UI/editing framework can be re-used in our case
16:17:00 <chrisdone> Peaker: yeah, the "hot" terminology doesn't exist in lisp. in lisp it's just, update. it's called "hot" in the "woah updating-as-the-program's-running-are-you-series?" communities =p
16:17:33 <chrisdone> or smalltalk
16:17:45 <Peaker> chrisdone, ah, well I agree it's important, but it's not our focus at least for the next year or two
16:17:56 <xplat> has anyone here used hagll?
16:18:00 <Peaker> (funny to talk about it now before we even have any form of code execution)
16:18:04 <chrisdone> Peaker: sure, i'm just reflecting on dreams
16:18:07 <xplat> https://github.com/adept/hagll
16:18:31 <Peaker> chrisdone, in any case, I agree with all your criteria, and it's mostly a matter of implementation time
16:18:35 <chrisdone> Peaker: i don't think you have, but i expect you will, a way to define arbitrary macros
16:18:38 <hpaste> acube pasted “strange error” at http://hpaste.org/90290
16:18:52 <chrisdone> Peaker: like, "here's a parser for SQL, now let me write SQL in this place"
16:18:55 <acube> Could not deduce A from context (A,B) ?
16:19:19 <acube> Was there a work-a-round for that bug in GHC?
16:19:21 <Peaker> chrisdone, We dislike parsers :)  we'll have something like:  Here's the SQL AST, here's a Widget that can edit this data-type nicely
16:19:39 <chrisdone> Peaker: sure
16:20:03 <chrisdone> the literature from the 80's defines editors as interactive parsers, or so
16:20:13 <Peaker> chrisdone, something like "Show/Read" instance, but that generated a 2-directional editing GUI from a data type
16:20:22 <chrisdone> yeah
16:20:50 <Peaker> chrisdone, so if you're implementing a red-black-tree rotation operation, you see an example visualized tree as input and output and it animates the output changes as you edit the code
16:21:23 <Peaker> or in super-crazy-debug mode, you get a visualized output for every sub-expression
16:21:27 <aristid> Peaker: would it generate the input automatically?
16:21:36 <Peaker> aristid, possibly with something like an "Arbitrary" instance
16:21:46 <Peaker> aristid, or maybe it'll force you to manually input examples, we're not sure yet
16:22:04 <acube> Hmm, that error message was caused by wrong parentheses ...
16:22:22 <xplat> if you have a property (without a proof, if applicable) then you could even quickcheck up a counterexample to work on
16:22:46 <Peaker> yeah that would be a nice way to debug property failures
16:24:02 <xplat> oh, and if you have a proof with holes in it you could use the presence of the holes to guide the counterexample search maybe
16:24:15 <aristid> xplat: quickcheck is a nice incentive to keep a pure core to imperative code :D
16:27:40 <Peaker> xplat, we don't have proofs/DTs (at least in version 1)
16:29:26 <Fuuzetsu> I have a function here that's ‘foo :: Applicative f => f a -> f [a] -> f [a]’ and it works all fine. However the second I try to define an operator in terms of it like ‘(:~>) = foo’, I get shouted down by the compiler about an ambiguous type variable…
16:29:27 <Fuuzetsu> What gives?
16:30:05 <ion> Try with a type signature or NoMonomorphismRestriction.
16:30:06 <shachaf> The monomorphism restriction gives.
16:30:17 <shachaf> And the monomorphism takes away.
16:30:57 <Fuuzetsu> Ah, damn, that's right. Curses, the damn thing manages to get me at least once a week or so.
16:31:16 <ion> It never seems to get me.
16:31:24 <shachaf> There's a lesson there somewhere.
16:31:34 <xplat> i'm still upset that NoGoddamnedMonomorphismRestriction is not a valid LANGUAGE flag
16:31:48 <ion> I use NoMonomorphismRestriction in .ghci and type signatures for top-level items in files.
16:33:05 <shachaf> {-# LANGUAGE EpimorphismFreedom #-}
16:33:15 <elliott> monomorphism restriction is good
16:33:21 <elliott> it teaches you to write type sigs
16:33:25 <xplat> sure it's usually a good idea to have a type signature for a top-level definition, but even Agda goes so far as to support simple aliases without signatures, and for Agda it requires special-case support
16:35:36 <Peaker> Looking at the wxHaskell stuff, it looks like a pretty nice API, much better than what I expected
16:35:44 <aristid> Peaker: the subtext case statement is really cool
16:35:46 <Peaker> imperative as hell, but straight-forward and simple
16:35:55 <Peaker> aristid, yeah, subtext 1 also had some cool stuff in it
16:36:14 <aristid> Peaker: this is what i'm watching: http://subtextual.org/subtext2.html
16:36:30 <Peaker> aristid, Yeah, I think there's just one demo of subtext2, and both J.E demos are impressive
16:36:46 <Peaker> I hope the wx author is responsive to pull requests...
16:37:52 <aristid> Peaker: you don't use raw opengl anymore?
16:37:54 <xplat> just in case anyone missed the first time i asked -- anyone used hagll (GLL parser combinators) ?
16:39:02 <lispy> no, but I wish more people used happy :)
16:39:19 <lispy> happy is pretty nice but it seems most folks would rather use combinator libraries.
16:39:20 <startling> ugh, homebrew broke my ghc
16:39:44 <xplat> lispy: i usually would rather use happy, but i need to compose a grammar dynamically at runtime
16:39:52 <Peaker> aristid, I do -- I'm writing a separate little application now just to display GHC profile outputs
16:39:58 <Peaker> aristid, because .prof files are really hard to navigate
16:40:06 <Peaker> aristid, and our GUI isn't comprehensive enough to do it
16:40:08 <Peaker> (yet)
16:40:22 <Peaker> and this should be fine with a simple Wx/Gtk tree-view navigation, I hope
16:40:38 <aristid> Peaker: i've traditionally been quite averse to graphical programming because most of what i've seen in that space is nonsense, but i really really like j.e.'s case expression :D
16:40:53 <xplat> lispy: i usually only use parser combinators when porting homebrew parsers from other languages
16:41:01 <Peaker> aristid, I hate "graphical programming", it's "structural programming"
16:41:25 <Peaker> aristid, our programs are not "graphic", but we have nice graphic visualizations of certain parts of them, and textual renderings too
16:41:33 <aristid> Peaker: :)
16:41:49 <aristid> Peaker: i think there are definitely graphic elements to his case expression
16:41:50 <xplat> lispy: but for this task i actually need parser combinators that can handle real grammars.  or maybe happy as a library somehow ...
16:42:26 <Peaker> aristid, basically a 2d syntax, like in Epigram
16:42:31 <aristid> Peaker: he cleverly uses two dimensions to incorporate both time and case flow
16:42:32 <Peaker> (except dimensions are used differently)
16:42:44 <aristid> Peaker: yes
16:42:52 <Peaker> well, nobody calls "Epigram" graphical programming? (I think)
16:43:47 <aristid> *shrug* in the end what you call things isn't the most important part
16:44:52 <chrisdone> names are what separate us from the animals! well, except border collies and gorillas. those smart buggers
16:44:57 <acube> Peaker: do you know https://github.com/maoe/tkyprof?
16:47:51 <Peaker> acube, nope, wow, thanks, seems great!
16:48:15 <lispy> xplat: ah.
16:48:50 <lispy> xplat: you can do unholy mashups between happy and aribtrary monads (like Cont) so you could jump in and out of the happy parsing. But that's probably still not what you want.
16:49:52 <xplat> lispy: no, i need to change the actual grammar
16:50:10 <Peaker> xplat, Why can't ordinary Attoparsec/etc handle real grammars?  you mean as a BNF spec?
16:50:39 <Peaker> or do you just want the extra performance / early ambiguity detection?
16:51:12 <xplat> Peaker: what i really want is to handle ambiguous grammars smartly instead of falling down in nonintuitive ways
16:51:54 <xplat> i don't expect performance to be an issue in this case
16:53:15 <Peaker> xplat, so a naive parser combinator that backtracks isn't good enough? Or do you mean you want to be able to return both results?
16:53:30 <Peaker> (in case of ambiguity)
16:54:37 <xplat> Peaker: i guess naive backtracking would work, but then performance might become an issue after all ...
16:55:24 <xplat> i'd also like to at least detect the case when there are two parses if possible
16:57:26 <pavonia> In Gtk2hs, how do you trigger a deleteEvent for a window?
16:57:38 <Peaker> Prelude's old "catch" became what?
16:57:50 <shachaf> It's gone.
16:57:52 <monochrom> disappeared
16:58:04 <shachaf> Well, the new catch in Control.Exception is more general.
16:58:06 <Peaker> how do you adjust old code that used it?
16:58:18 <ion> What’s the catch?
16:58:23 <monochrom> haha ion
16:58:29 <Peaker> oh I see all the uses of catch ignore the exception, so I know how to handle it
16:58:38 <geekosaur> Control.Exception.catch, generally
16:58:49 <geekosaur> or bracket etc.
16:59:11 <monochrom> old code "catch m (\e -> ...)" becomes new code "catch m (\e -> ...)" but make sure (\e -> ...) :: IOException -> IO ...
17:00:01 <shachaf> Peaker: By the way, if you're using lens it has a bunch of utilities for working with exceptions.
17:00:27 <Peaker> shachaf, just fixing up wx package to work with modern GHC
17:01:01 <Peaker> monochrom, I just used SomeException because the purpose seems to be swallowing all exceptions
17:01:11 <Peaker> (pretty terrible, but it's just a wx sample program)
17:01:17 <monochrom> that's good too, if you are sure
17:01:36 <Peaker> Actually I see it's only ever done on IO operations, so better swallow just IO stuff
17:02:05 <monochrom> it depends on whether you want to intercept e.g. KillThread
17:03:19 <monochrom> err, ThreadKilled
17:05:33 <pavonia> Or is there a better place to ask for Gtk2hs help?
17:05:54 <monochrom> catchJust (\e -> case e of TheadKilled -> Just e; _ -> Nothing) m (\e -> putStrLn "who! who is trying to kill me! but I will persevere!")
17:19:46 <pavonia> Hm... widgetDestroy kills the window but the destroyEvent handler is not triggered :s
17:26:00 <newsham> https://twitter.com/tqbf/status/348580900533067776 <- haskell req
17:26:30 <Peaker> acube, tkyprof seems to be lacking some files, at least on his github
17:27:02 <Peaker> but it does work from hackage, cool
17:27:07 <ion> Crypto submissions to what?
17:27:48 <Peaker> yay, it works
17:28:08 <newsham> he has a crypto challenge with a series of programming tasks..  its sort of like homework
17:28:28 <newsham> http://blog.pinboard.in/2013/04/the_matasano_crypto_challenges/
17:28:43 <newsham> oops http://www.matasano.com/articles/crypto-challenges/
17:28:49 <Peaker> it doesn't seem to actually help me understand my profile :(
17:29:49 <ion> Ah, that one. It’s interesting but i haven’t got around to do that. My submissions would have been in Haskell as well. :-)
17:34:06 <niteria> nice, I'd love to get some feedback on my solutions
17:34:53 <niteria> I did the first batch so far and got questions for the second one and that doesn't look as easy
17:35:21 <elliott> is anyone using git head cabal? is there a way to get --hyperlink-source for haddock automatically?
17:35:32 <elliott> --hoogle works in the config but it seems to be passing the opts directly to haddock
17:35:35 <elliott> so --hyperlink-source doesn't :(
17:44:06 <elliott> it seems like you still need to pass options to cabal install all the time, sigh
17:53:09 <Demos> what is a good library for pulling text from an HTML document (a string with html stuff), I just want to be able to say like document /> body /> title and get the title
17:53:25 <Demos> also documentation would be nice
17:53:26 <Peaker> yay, wrote a little wx tree to let you "dig" into a .prof tree, and it's already useful!
17:53:36 <Peaker> (ugly as hell, of course :-) )
17:53:38 <Peaker> https://github.com/Peaker/HaskProfileGui
17:54:09 <Peaker> surprisingly, throwing 16K nodes into a wx Tree didn't cause any performance issue
17:57:11 <startling> why does haskell use :: for types?
17:57:17 <ion> startling: Why not?
17:57:45 <startling> ion, don't most mathematicians use : ?
17:58:11 <Peaker> they wanted pattern matching on (:) to be syntactically cheap
17:58:19 <mapreduce> To annoy people coming from Scala and trying to use :: as cons.
17:58:23 <shachaf> startling: Probably because Miranda did or something.
17:58:32 <Peaker> I think Hughes(?) said that when cons was (::), people wrote:  f (x :: xs) = ...
17:58:42 <Peaker> and when it was (:), people wrote:  f (x:xs) = ...
17:58:46 <shachaf> I'd prefer : because types are more important than lists. But it's not going to change so it's not really worth arguing about.
17:58:47 <Peaker> and they wanted it to be cheap
17:58:51 <startling> Peaker: haha
17:59:19 <startling> shachaf, I'm not arguing; someone just asked me why idris uses :, so I was wondering why haskell went with :: rather than :.
17:59:40 <geekosaur> considering the other stuff a haskell parser has to do, that seems like an odd place to implement parser economy :)
17:59:59 <ion> It’s not about parsing.
18:00:39 <Peaker> it's about how people wrote cons matches with :: as cons
18:02:02 <Demos> what is the best way to unwrapt a Either in ghci? I know it is Right I see the Right value but I cant get it on its own
18:02:15 <Demos> *unwrap
18:02:24 <shachaf> case foo of Left ... -> ...; Right ... -> ...
18:02:37 <ion> Pattern matching or «either».
18:03:07 <Peaker> Demos, let Right myVal = theEither
18:04:28 <mapreduce> Peaker: What does that do if it's actually a Left?
18:04:31 <Demos> thanks Peaker
18:04:57 <latro`a> mapreduce, if the value gets used, an exception will be thrown for pattern match failure
18:05:10 <Demos> yup
18:05:20 <mapreduce> Thanks.
18:05:28 <latro`a> if the value doesn't get used, nothing happens
18:05:32 <Peaker> mapreduce, crash with partiality if "myVal" is ever used
18:05:36 <Demos> but it really does not matter when you are poking things in ghci
18:06:08 <Peaker> but Demos explicitly said "in ghci .. I know it is Right I see the RIght value"
18:06:27 <latro`a> then partiality is fine
18:06:39 <ion> > let Right a = Left 42 in a
18:06:40 <lambdabot>   *Exception: <interactive>:3:5-21: Irrefutable pattern failed for pattern Da...
18:07:23 <Peaker> > let Right a = Left 42 in 5
18:07:24 <lambdabot>   5
18:07:45 <Demos> anyone have a good HTML parser, or a link to good documentation on HaXmL
18:11:36 <hpc> haxml is an xml parser
18:11:45 <hpc> which is extraordinarily different from html
18:12:09 <hpc> oh my mistake, it has an html module
18:12:45 <Demos> well XHTML is well formed XML so an xml parser should be able to deal with it
18:12:51 <geekosaur> you hope
18:13:31 <Demos> well I only need the title so as long as it is well formed up to there...
18:13:50 <geekosaur> (there is an awful lot of "XHTML" that is just crappy HTML with s,<br>,<br/>,g)
18:14:15 <timemage> geekosaur, most of which not being served with an xhtml mimetype.  if it was, that problem wouldn't be as common.
18:15:05 <geekosaur> ahahahah
18:15:40 <geekosaur> the major browsers all fall back to not treating it as xhtml because major web sites break if you try to parse their xhtml as xhtml
18:16:43 <[Coke]> I am not a haskell programmer - trying to get a haskell based project setup to smoketest it - It requires stringtable-atom >= 0.0.4, which fails to install, as does stringtable-atom latest. I captured the errors for both here: https://gist.github.com/coke/5843322 - any guidance greatly appreciated.
18:17:58 <elliott> so, cabal's --haddock-hoogle option is more or less totally useless
18:18:12 <elliott> in that, when using it, you sacrifice... the generation of normal HTML documentation.
18:18:45 <shachaf> [Coke]: What version of GHC are you using?
18:20:26 <shachaf> [Coke]: Oh, I recognize this...
18:21:20 <geekosaur> is that an IntMap API change? (guessing from IM.*)
18:22:01 <shachaf> I think there was an API change, yes.
18:22:15 <shachaf> Knowing the GHC version and/or containers version would help.
18:22:20 <geekosaur> yep, those are IntMap functions, the API must have changed
18:22:32 <shachaf> (It builds fine for me with GHC 7.6 and containers 0.5.)
18:23:37 <elliott> does anyone use cabal/haddock's hoogle database generation stuff? wondering how to get this working in a reasonable way
18:25:44 <timemage> geekosaur, xhtml was kind of doomed from the start.  i'd say we'd need to wipe the slate clean and start over.  but we're going to wind up here again.
18:25:51 <Demos> hm I am getting a duplicate definition error when loading HaXml in ghci for _get_current_timezone_seconds
18:25:58 <geekosaur> yep
18:26:18 <ion> elliott: If you figure it out, would you mind pointing out the solution for me, too?
18:26:59 <ion> konundra_: I was about to mention 1000.0 users on #haskell, but you ruined it. ;-)
18:27:23 <Demos> wow! haskell has lots of users
18:27:25 <shachaf> ion: There you go.
18:27:36 <ion> \o/
18:27:42 <ion> D-:
18:27:59 <shachaf> Now we're at 999.5 users!
18:29:16 <ion> Has anyone graphed the number of users over time?
18:31:07 <Cale> Who is the half-user?
18:31:23 <Demos> hm someone should right a full blown package manager in cabal
18:31:29 <Demos> derp in haskell
18:31:50 <shachaf> Cale: None -- we're back at 1000.
18:32:12 <ion> demos: See NixOS.
18:32:25 <elliott> Nix is written in C++.
18:32:53 <ion> Oh, ok. I was misinformed and didn’t check myself.
18:33:24 <Demos> also, I cant resolve their website
18:40:05 <Demos> HERP DE DERP I still have a really old haskell platform
18:40:41 <[Coke]> shachaf: version 7.4.2
18:42:14 <shachaf> [Coke]: OK, I get this failure with 7.4 and not with 7.6.
18:42:43 <shachaf> Upgrading to 7.6 might be the simplest way to fix it...
18:42:46 <[Coke]> let me see if my host can upgrade for me.
18:43:04 <shachaf> `ghc-pkg list containers` says you're using 0.4, right?
18:50:13 <Sonarpulse> how do you import bindings when they are made in hsc form?
18:50:21 <Sonarpulse> ghc does not search for *.hsc files
18:50:30 <Sonarpulse> I see there is an #import, but that doesn't work either
18:50:54 <Sonarpulse> I could get cabal to manually process every hsc first
18:51:10 <Sonarpulse> but it seems cleaner to just let imports sort out dependancies like normal
18:51:21 <[Coke]> shachaf: 0.4.2.1
18:54:15 <Sonarpulse> anybody?
18:55:23 <shachaf> Sonarpulse: If you're using cabal, it should just work.
18:55:34 <shachaf> If you're not using cabal, you'll have to use hsc2hs yourself.
18:56:27 <Sonarpulse> I am using cabal
18:56:51 <Sonarpulse> it searches for Meirarchical/Module/Name.hs
18:56:54 <Sonarpulse> *ghc does
18:56:56 <Sonarpulse> but not
18:57:03 <Sonarpulse> Heirarchical/Module/Name.hsc
18:57:12 <shachaf> I agree.
18:57:20 <Sonarpulse> the module in question is not exported by cabal
18:57:27 <Sonarpulse> it is included in another
18:57:35 <Sonarpulse> which is exported
18:57:36 <Sonarpulse> so cabal does not know about it
18:58:47 <shachaf> Then tell Cabal about it.
18:58:58 <Sonarpulse> in what field in my cabal file?
18:59:02 <Sonarpulse> extra sources?
19:00:11 <shachaf> I don't remember. It's in the documentation somewhere.
19:00:14 <Sonarpulse> ok
19:00:21 <Sonarpulse> thanks, I'll dig through it
19:00:29 <shachaf> Perhaps it is other-modules.
19:00:41 <shachaf> Regardless, if you're compiling it, Cabal should know about it.
19:37:31 <prophile> does Cont have a comonadic dual?
19:39:42 <shachaf> prophile: There is one sense sense in which Store is sort of dual to it...
19:40:04 <Sonarpulse> shachaf: other-modules works perfectly
19:40:07 <Sonarpulse> thank you so much
19:40:23 <Sonarpulse> sorry I diddn't see you answer earlier, i was doing other things for a bit
19:41:34 <shachaf> prophile: Codensity is dual to Density, and Codensity is like a fancy Cont, and Density is like a fancy Store.
19:42:07 <[Coke]> arglebargle. ok, now the cabal configure steps work, but compiling the actual codebase fails. :)
19:42:22 <[Coke]> (starting over with the minimum versions required JIC)
19:42:28 <shachaf> Which codebase?
19:42:59 <[Coke]> https://github.com/perl6/Pugs.hs
19:43:02 <prophile> shachaf: righty
19:43:02 <prophile> thanks
19:43:15 * prophile reads more
19:43:23 <erisco> dmwit, how many characters did the parser actually consume?
19:43:26 <shachaf> [Coke]: Yep, it's an old codebase. :-)
19:44:03 <shachaf> [Coke]: Once I made a branch to fix all the deprecated things... Did that ever get merged?
19:44:21 <shachaf> I think it didn't. Probably master has completely diverged by now.
19:44:37 <[Coke]> I wouldn't guess completely, no. :)
19:44:50 <[Coke]> I'm just keeping it on life support for now.
19:45:01 <[Coke]> but IANAhaskell programmer.
19:45:49 <shachaf> IANABANANA
19:46:21 * shachaf looks
19:46:53 * lispy is pretty sure shachaf is a BANANA
19:47:08 <shachaf> You found me out!
19:47:25 <Clint> how reactive?
19:47:30 <dwcook> Better peel off
19:47:31 <Sonarpulse> wooo! my basically blank enet bindings finally compile
19:47:35 <Sonarpulse> so at least my cabal is good
19:47:50 <lispy> Sonarpulse: congrats
19:47:54 <Sonarpulse> thanks everbody I have bugged the last week
19:47:58 <lispy> Sonarpulse: Step 0. Complete :)
19:48:02 <Sonarpulse> yup
19:48:13 <Sonarpulse> well i might no enough to get johnw's tool to work now
19:48:26 <Sonarpulse> #include vs #import for one
19:48:28 <lispy> cool
19:48:45 <Sonarpulse> then STEP_LAST here i come!
19:49:09 <Sonarpulse> it is more educational hand rolling it first for sure though
19:49:18 <lispy> yup
19:49:35 <lispy> When approaching a new problem, do the simplest thing that solves a small part of the problem :)
19:49:35 <Sonarpulse> and of course, haskell is more pretty than C pre-processor
19:50:02 <Sonarpulse> in the long run, I think hsc2hs should support some of the things in bindings-dsl and johnw's tool
19:50:10 <Sonarpulse> like if there is a #poke struct field
19:50:23 <Sonarpulse> why not the whole struct?
19:51:05 <Sonarpulse> obviously if you need to tweek the original is there, but for the many cases where your pokes and peeks are completely standard it woudld be nice
19:51:23 <lispy> what do you mean by standard?
19:51:46 <lispy> How I've used it before is to define storable instances. If you give those for each type then you can chain them together.
19:53:18 <Sonarpulse> but doesn't that mean you are sort of doing the same
19:53:40 <Sonarpulse> where {fieldA = (#poke struct a) ; ...}
19:53:43 <Sonarpulse> ever time?
19:53:49 <Sonarpulse> or at least most times?
19:54:27 <lispy> https://github.com/dagit/freetype2/blob/cabalization/Graphics/Rendering/FreeType/Internal/BBox.hsc
19:54:28 <shachaf> [Coke]: Yep, it looks like fixing Pugs is the sort of thing that would involve knowing a bit of Haskell.
19:54:31 <lispy> That's an example
19:54:46 <lispy> Sonarpulse: Are you talking about lines 30-33?
19:55:32 <Sonarpulse> yeah
19:55:40 <Sonarpulse> there is absolutely a pattern there
19:55:53 <Sonarpulse> one things that johnw's tool does
19:56:01 <Sonarpulse> is as opposed to #including the cpp
19:56:16 <Sonarpulse> it loades it and parses it by itself
19:56:42 <Sonarpulse> perhaps LANG CPP does to something more advanced to preclude unforseeing parsing errors
19:57:22 <Sonarpulse> but something like parse C, then template haskell seems more proper to me than #including it all together
19:57:22 <palmje> does anyone know what would be causing this problem? comes from the linker step: relocation R_X86_64_32S against `stg_CAF_BLACKHOLE_info' can not be used when making a shared object; recompile with -fPIC
19:57:55 <palmje> this is using ghc 7.6.3 - I can get it to work, but I have to used -dynamic and -fPIC
19:58:32 <Sonarpulse> IMO schemers would think our FFI stuff is pretty crude janky-lisp-like stuff
19:59:23 <Sonarpulse> give em a good laugh, when we are shaking our heads at dynamic types
19:59:57 <Sonarpulse> lines 29-44 look all abstractable to me
20:00:05 <djahandarie> palmje, are you exporting a shared library? Those are the flags one usually uses for that. I'm not sure of that exact linker error means though.
20:00:09 * hackagebot language-ecmascript 0.15 - JavaScript parser and pretty-printer library  http://hackage.haskell.org/package/language-ecmascript-0.15 (AndreyChudnov)
20:01:41 <palmje> djahandarie: nope, the entire code of this file is: module Main where main :: IO () main = putstrln "testing..."
20:03:29 <[Coke]> shachaf: https://gist.github.com/coke/5843604 - was able to cabal install everything, but pugs build failed. Any pointers?
20:04:37 <shachaf> [Coke]: I suspect you'll have to change some code.
20:04:42 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/System-IO-Error.html#v:tryIOError ?
20:05:08 <shachaf> Exception handling has changed in 7.6 (some deprecated code was removed).
20:05:28 <shachaf> But tryIOError will work in that one place, I guess...
20:09:16 <prophile> peirce's law looks quite similar to the type signature for callCC
20:09:20 <prophile> that's quite interesting
20:09:41 <[Coke]> I assume tryIOError replaces IOError?
20:10:07 <shachaf> IOError is a type; tryIOError is a function.
20:10:17 <shachaf> It looks like it has the same behavior as the old "try" exported by System.IO.Error.
20:10:36 <shachaf> I suspect Control.Exception.try will work too, but might require a type annotation or something.
20:10:58 <[Coke]> ah, no, it replaces try. Danke.
20:17:49 <carter> Sonarpulse language CPP just runs the clang or gcc in CPP only mode…
20:18:09 <carter> actually, which is better, c2hs or hsc2hs?
20:18:16 <carter> or what are the diferences?
20:18:48 <Sonarpulse> c2hs is johnw's tool right?
20:19:20 <Sonarpulse> well as far as I can tell, not having looked at program source, the syntrax transfermations happen differently
20:19:22 <shachaf> No. His program just has a confusingly similar name.
20:19:39 <Sonarpulse> oh c2hsc
20:19:42 <Sonarpulse> yeah
20:19:44 <geekosaur> c2hs tries to work from C struct declarations and do all the hard work for you, but sometimes fails because the C struct declarations don't always tell the whole story. hsc2hs requires more work but means you can deal with the screw cases c2hs gets wrong
20:20:10 * hackagebot language-ecmascript-analysis 0.9 - JavaScript analysis library  http://hackage.haskell.org/package/language-ecmascript-analysis-0.9 (AndreyChudnov)
20:20:11 <carter> ok
20:20:41 <Sonarpulse> basically
20:20:42 <carter> all I know is thoughtpolice  is doing god's work, making sure clang HEAD will be ghc friendly
20:20:43 <carter> or more so
20:20:57 <carter> than it current is
20:21:04 <Sonarpulse> I think we should have more a try/over-ride
20:21:23 <Sonarpulse> where you explicitly do what c2hs/c2hsc (they have similar philosphys) fails at
20:21:45 <Sonarpulse> c2hsc explicity says: run this, then fix yourself
20:22:07 <Sonarpulse> but that makes seperating manual and autogenerated bits cumbersome if c2hsc is upgraded
20:22:10 <carter> huh, the gsoc thing i'm mentoring this summer kinda relates to this
20:22:15 <Sonarpulse> interesting
20:22:30 <carter> student writing a c++ api wrapper tool
20:22:31 <Sonarpulse> I've been thinkinb about package mangement and build systems
20:22:34 <Sonarpulse> oooo
20:22:44 <carter> which look slike it can leverlage wavewave's fficxx
20:22:46 <Sonarpulse> if C++ templates -> haskell polymorfism
20:22:55 <carter> fficxx (eff ficx)
20:22:55 <Sonarpulse> *polymorphism
20:22:59 <carter> nope
20:23:02 <carter> thats hard
20:23:07 <carter> i'm tell him him "ignore that for now"
20:23:07 <Sonarpulse> well if it happend, I would cry
20:23:12 <Sonarpulse> tears of joy
20:23:13 <carter> in joy or sads?
20:23:20 <Demos> honestly FFI to almost anything that is not C is really rather hard
20:23:27 <carter> templates have generative rather than parametric semanticcs
20:23:40 <carter> You could do a Type family sort of model of a template
20:23:43 <carter> maybe
20:23:46 <Sonarpulse> I almost feel like we should create our own rust/ATS hybrid that explicitly is designed to interface with ghc
20:23:47 <carter> once 7.8 lands
20:24:00 <carter> Sonarpulse : i may procrastichack on that
20:24:02 <carter> in a few months
20:24:15 <Sonarpulse> procrastichack?
20:24:21 <carter> Sonarpulse procraticode
20:24:27 <Sonarpulse> ahh
20:24:30 <carter> *procrastinate + code + hack
20:24:39 <[Coke]> shachaf: a simple substitution seems to have done it. Danke.
20:24:40 <Sonarpulse> nice portementeou
20:24:49 <carter> i don't know what that word means
20:24:53 <carter> i do those all the time though
20:25:25 <Sonarpulse> well i probably spelled it wrong
20:25:29 <carter> nope
20:25:31 <geekosaur> @wn portmanteau
20:25:33 <lambdabot> *** "portmanteau" wn "WordNet (r) 3.0 (2006)"
20:25:33 <lambdabot> portmanteau
20:25:33 <lambdabot>     n 1: a new word formed by joining two others and combining their
20:25:33 <lambdabot>          meanings; "`smog' is a blend of `smoke' and `fog'";
20:25:33 <lambdabot>          "`motel' is a portmanteau word made by combining `motor'
20:25:35 <carter> i just never remember french words
20:25:35 <lambdabot> [4 @more lines]
20:26:25 <Sonarpulse> well i did spell it wrong, eou vs eau
20:26:36 <Sonarpulse> silly french
20:27:18 <carter> Sonarpulse the main thing : is i think a modern low level language looks very different from what we all consider a "low level systems language"
20:27:49 <Sonarpulse> you mean how C is sloppy in ways that don't help low-levelness?
20:28:09 <carter> that too
20:28:37 <Sonarpulse> I sort of C haskell moving towards a point where if you slap on enough fancy control library you can do almost whatever you want
20:28:41 <geekosaur> (bring back bcpl!)
20:28:49 <Sonarpulse> ^ lol
20:29:04 <Sonarpulse> but it may *almost* get there, just not quite.
20:29:51 <Sonarpulse> Unix has sort of an A) assume everything is unsafe philosophy and sandbox, B) build up safty meconisms
20:30:04 <Sonarpulse> I'd sort like haskell to become something where
20:30:12 <carter> "meconism" is the right way of putting it :P
20:30:26 <Sonarpulse> ....I need to learn to type
20:30:28 <Sonarpulse> :D
20:30:33 <carter> its ok
20:30:39 <Sonarpulse> for ease of correctness you can just use pure values
20:30:42 <carter> i'll stop being able to spell for the night in another 2 hours
20:30:50 <carter> i write my SIMD code functional style :P
20:30:55 <carter> it actually works out pretty well
20:31:09 <carter> modern intel AVX assembly is kinda functional style
20:31:17 <Sonarpulse> and if you want to "be bad", you can proove it works, so no sandboxing is needed
20:31:25 <carter> ie the result register doesn't have to be one of the input registers
20:31:28 <Sonarpulse> or if you are really desperate your can unsafe
20:31:38 <Sonarpulse> AVX assembly?
20:31:41 <carter> yes
20:31:43 <Sonarpulse> never heard of it
20:31:44 <carter> the SIMD fast math stuff
20:31:49 <Sonarpulse> for x86?
20:31:53 <Sonarpulse> intel GPUs?
20:32:05 <carter> Cpu
20:32:08 <Sonarpulse> interesting
20:32:11 <carter> x86_64
20:32:13 <carter> really easy to use
20:32:18 <Sonarpulse> ah, tool
20:32:20 <Sonarpulse> *cool
20:32:28 <erisco> does SSE apply?
20:32:34 <carter> erisco to what?
20:32:40 <Sonarpulse> I read that the next architexture has hardware transactional memory
20:32:45 <carter> HTM
20:32:46 <carter> yeah
20:32:48 <carter> thats for STM
20:32:49 <Sonarpulse> but on r/haskell and elsewhere they said they did it all wrong
20:32:59 <Sonarpulse> so wouldn't be of much use for GHC
20:33:01 <carter> well, its unclear if its useful in terms of perf
20:33:02 <erisco> well you're saying AVX, and I'm just wondering if you're choosing that arbitrarily
20:33:22 <carter> erisco SSE4 and stuff are kinda similar
20:33:28 <carter> but the register scheduling is more fiddly
20:33:33 <erisco> I don't have AVX so I might be missing out :(
20:33:36 <carter> because of the mutate your inputs stuff
20:33:45 <carter> erisco do you ahve sse4?
20:33:54 <erisco> I think so
20:33:58 <carter> cool
20:34:14 <carter> for my haskell numerics libs, the C bits  (which will later be LLVM code gen bits)
20:34:32 <carter> are for near term on intel just going to be either avx2, avx/sse4 , or none
20:34:38 <erisco> it scares me a bit that instruction sets keep building in size like this... must be absolute chaos in the circuitry
20:34:50 <carter> erisco a lot of them overlap in functinality
20:35:04 <Sonarpulse> ^ not too good either....
20:35:07 <carter> like avx is sort of a nicer sse4
20:35:32 <carter> Sonarpulse erisco  the thing you have to remeber: x86_64 is not what the CPU runs
20:35:39 <carter> it gets turned into a sort of "microcode"
20:35:40 <carter> thingy
20:35:49 <Sonarpulse> I like intel for A) good linux support B) at least attempting transactional memory and that larabeee fully programmable larabee thing
20:36:11 <carter> so the only *necessary* complexity is in the intel ASM -> microcode layer
20:36:14 <Sonarpulse> now if LLVM could just programm that "microcode" directly
20:36:20 <carter> never gonna happen
20:36:22 <carter> no reason to
20:36:25 <carter> why would we want that?
20:36:32 <carter> also really proprietary
20:36:37 <Sonarpulse> ah
20:36:43 <erisco> I don't really get what you're saying... just seems to be shifting the burden
20:36:53 <carter> erisco what i'm saying or him?
20:36:57 <Sonarpulse> I just see x86 as this really nasty mess
20:37:00 <erisco> YOU! :P
20:37:05 <Sonarpulse> only around cause people and their ancient windows binaries
20:37:11 <carter> Sonarpulse x86_64 is pretty sanish
20:37:16 <Sonarpulse> yeah i heard it was better
20:37:19 <Sonarpulse> and like you said
20:37:24 <erisco> carter, oh no way man... sane in no way
20:37:25 <Sonarpulse> intel is doing really clean things under the hood
20:37:48 <carter> erisco its much saner than x86
20:38:09 <startling> carter, the boot process is terrible
20:38:16 <Sonarpulse> so I wish they could give is a cleaner interface that desugared to the same proprietary stuff
20:38:16 <erisco> there are so many concepts which only work on certain widths and have special behaviours with which registers they use and all sorts of nonsense
20:38:18 <carter> glad i'm not doing OS kernel stuff :)
20:38:18 <startling> that's my main beef anyway
20:38:26 <startling> carter: yeah. :(
20:38:28 <Sonarpulse> and disregraded x86 legacy altogether
20:38:38 <carter> erisco i'm glad i'm only using the sse4/avx stuff :)
20:38:45 <erisco> mathematically it has to be a great example of *ugly*
20:38:52 <carter> that part is pretty simple
20:39:18 <carter> happily we have compilers and LLVM IR for other bits :P
20:39:26 <erisco> on the other hand, you get to be MacGyver putting together algorithms
20:39:47 <carter> erisco who is?
20:40:06 <erisco> working with x86_64
20:40:23 <carter> erisco thats LLVM's job :P
20:40:33 <erisco> lots of bits and bobs which can be cobbled together to create surprising solutions
20:40:42 <Sonarpulse> if intel resurected their fully programmable GPU, and did transactional memory in a way that worked for GHC (assuming as planned really doesn't), I think haskell could really start killing
20:41:02 <carter> a few friend wanted me to compre my SIMD intrinsics vs Clang autoveoctorizing. I wont
20:41:03 <Sonarpulse> might even gain some traction in mainstream videogame industry or something
20:41:04 <carter> *won
20:41:28 <carter> Sonarpulse easier approach would be gaming EDSL in haskell that uses LLVM
20:41:57 <carter> the GC engineering needs to be different for latency rather than throughput oriented applications
20:41:57 <Sonarpulse> EDSL desugaring to what>
20:41:59 <Sonarpulse> *?
20:42:00 <carter> LLV
20:42:03 <carter> *LLVM code
20:42:06 <carter> that you compile
20:42:08 <carter> with llvm
20:42:16 <Sonarpulse> oh so like atom or whatever?
20:42:17 <carter> we've the start of some nice LLVM layers
20:42:20 <carter> yes
20:42:22 <carter> or something
20:42:26 <Sonarpulse> that would be cool
20:42:30 <Sonarpulse> but that's not really haskell then
20:42:32 <carter> and doable sooner
20:42:42 <Sonarpulse> unless the EDSL happens to resemble it
20:42:58 <Demos> haskell in video games would be interesting
20:43:00 <Sonarpulse> Don't get me wrong, that would be great
20:43:11 <Sonarpulse> but while I am dreaming, I'll dream big
20:43:12 <carter> well, you'd actually want it to be functional
20:43:18 <Sonarpulse> true
20:43:19 <carter> so you can do GPUization easily
20:43:22 <carter> and stuff
20:43:26 <carter> and aggressive scheudling
20:43:29 <carter> *scheduling
20:43:36 <carter> and locality tricks
20:43:46 <carter> has anyone read the new discrete log alg paper?
20:43:50 <carter> http://eprint.iacr.org/2013/400
20:44:10 <carter> seems like a big deal maybe
20:44:17 <Demos> to be fair though most games are really big ugly piles of code
20:44:32 <carter> that too
20:44:40 <carter> so not worth gettng in that verticle
20:44:58 <carter> unless you happen to be dog fooding the tools to make award winning best selling games
20:45:05 <carter> or just making your own games for ufn
20:45:07 <carter> *fun
20:45:22 <carter> some folks on #haskell-game are trying to build a sort of pygame for haskell set of libs
20:45:25 <[Coke]> shachaf: bah. now fails several thousand tests on the new box it didn't fail on the old one. Ah well. might be time to give up.
20:45:42 <Sonarpulse> well my enet bindings are for a game
20:45:49 <carter> cool
20:45:57 <Sonarpulse> I have a really simple plan
20:46:05 <shachaf> [Coke]: Builds successfully and then the same code fails tests that it didn't use to?
20:46:17 <Sonarpulse> make new client for abandoned (sorta) closed source game with open source server
20:46:22 <Demos> holy carp haskell-game is a think?
20:46:22 <Sonarpulse> that is already somewhat popular
20:46:28 <carter> yes
20:46:33 <carter> some cool people hang out there
20:46:37 <Sonarpulse> and the players are itching for new features
20:46:39 <carter> including lispy and alpounet  and jmcarthur
20:46:46 <carter> Sonarpulse DO IT
20:46:50 <carter> maybe they'll even give you money
20:46:53 <Sonarpulse> nah
20:46:55 <[Coke]> shachaf: aye. (presumably my try -> tryIOError patch was too naive) (or something fragiley depends on an old version of a cabal module)
20:47:00 <Sonarpulse> Jagex, maker of runescape
20:47:02 <Sonarpulse> got game
20:47:03 <Demos> there was a post on gamedev and r/haskell a few days agon about game programming in haskell, but it was really c++ in haskell
20:47:07 <Sonarpulse> is developing it
20:47:15 <Sonarpulse> but their version sucks
20:47:22 <Sonarpulse> more people play free beta now
20:47:30 <Sonarpulse> though player counts for both are declining
20:47:52 <carter> what are some good 2d space action games i should check out? i'm out of date
20:47:55 <Sonarpulse> my client will be backwards compatable with existing server to easy transitions
20:48:01 <Demos> I remember jagex's first 3D game slowing to a crawl and crashing on my $300 video card...
20:48:08 <Sonarpulse> no idea regarding 2D
20:48:16 <Demos> but FREESPACE2
20:48:18 <Demos> for 3D
20:48:24 <lispy> carter: space action? I know some good 2d games, but let's take this to #haskell-game?
20:48:30 * tabemann is wondering whether he is better off having an optimized toList routine for his red-black trees rather than simply relying on Data.Foldable.toList, as the typical way of implementing Data.Foldable.foldMap does not seem that efficient for when f is \a -> [a]...
20:48:31 <Sonarpulse> and my client will be cross platform, which will mainly benefit me but whatever
20:48:31 <carter> lis cool
20:48:41 <Sonarpulse> maybe cannonical will pay me :D
20:49:21 <shachaf> tabemann: I recommend looking at the definition of toList first.
20:50:00 <shachaf> (f is not \a -> [a])
20:50:06 <tabemann> okay, it's actually using Data.Foldable.foldr
20:51:31 * tabemann looks at the definition of Data.Foldable.foldr, and can't tell if it has the non-ideal behavior of normal foldr or not
20:52:41 <shachaf> I don't know what an ideal behavior of foldr is.
20:53:15 <Sonarpulse> if I recall the definition was replace every data constructor with the fold function
20:53:36 <Sonarpulse> so I guess for super-foldr
20:53:37 <tabemann> I mean the tendency of foldr to blow up the stack when you feed something too big into it
20:53:49 <tabemann> being non-ideal behavior
20:54:01 <shachaf> Sonarpulse: What you're recalling is not Data.Foldable.foldr.
20:54:19 <shachaf> tabemann: foldr (on lists) does not blow up anything. Nor does Data.Foldable.foldr.
20:54:21 <Sonarpulse> probably not
20:54:31 <Sonarpulse> but it is true for list foldr
20:54:40 <arkeet> ??
20:54:46 <Cale> tabemann: foldl is more poorly behaved than foldr with regard to the stack
20:54:57 <shachaf> foldr is special because it reflects the structure of a list exactly.
20:55:09 <Cale> (though foldl' fixes that)
20:55:10 <shachaf> Data.Foldable.foldr just turns any old thing into a list.
20:55:24 <shachaf> (Sort of.)
20:55:40 <shachaf> So it gives anything listy behavior. But it's not a structural fold for anything except lists.
20:55:41 <arkeet> it turns it into a list, and then uses list foldr.
20:55:42 <arkeet> more sort of.
20:56:01 <shachaf> You might as well sort of listen to arkeet.
20:56:16 <arkeet> usually Data.Foldable.foldr isn't that cool.
20:56:54 <Gracenotes> hm, so GHC actually uses eval/apply nowadays?
20:57:04 <shachaf> Data.Foldable.foldMap is the cool and easy Foldable function
20:57:56 <shachaf> > foldMap f (S.fromList [1,2,3]) :: Expr
20:57:57 <lambdabot>   (((mempty <> f 1) <> mempty) <> f 2) <> (mempty <> f 3) <> mempty
20:57:59 <shachaf> whoa, dude
20:58:04 <shachaf> I did the whole N thing for nothing.
20:58:16 <arkeet> ??
20:58:16 <Gracenotes> > a + b :: Expr
20:58:17 <tabemann> the definition for Data.Foldable.foldr I see is: foldr f z t = appEndo (foldMap (Endo . f) t) z - this is confusing me because I don't know what Endo and appEndo do and I can't find where they're defined
20:58:18 <lambdabot>   a + b
20:58:26 <shachaf> @hoogle Endo
20:58:26 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
20:58:26 <lambdabot> Data.Monoid newtype Endo a
20:58:26 <lambdabot> System.Posix.Terminal EndOfFile :: ControlCharacter
20:58:28 <arkeet> tabemann: Data.Monoid
20:58:29 <shachaf> Now you know.
20:58:39 <shachaf> (And you know how to find out! Which is even more valuable.)
20:58:46 <Gracenotes> :t f
20:58:47 <lambdabot> FromExpr a => a
20:58:52 <arkeet> you can think of it as turning it into a bunch of singleton DLists
20:59:04 <arkeet> and concat'ing them.
20:59:06 <arkeet> sort of.
20:59:12 <startling> is appEndo supposed to be a pun
20:59:22 <shachaf> That is what it is.
20:59:25 <startling> :/
20:59:28 <shachaf> A "singleton DList" is a function like (x :)
20:59:35 <shachaf> "appending them" is composing the functions.
20:59:54 <tabemann> okay, I officially don't like it when people import entire modules without naming each item to import in them (makes it harder to find where to look for something)
21:00:06 <shachaf> The magic of composition is that (x :) . ((y :) . (z :)) = ((x :) . (y :)) . (z :).
21:00:13 <startling> tabemann, :info
21:00:46 <tabemann> but then I probably should have harnessed the power of Hoogle to search for Endo
21:01:06 <shachaf> Probably. Or the power of :i in ghci.
21:02:09 <tabemann> if foldr is effectively using DLists then I probably don't need to implement my own (marginally faster) toList routine
21:02:13 <shachaf> http://www.youtube.com/watch?v=Ek3LMYJOYRc#t=1m07s
21:03:16 <shachaf> s/0//, I guess. Anyway, this isn't the channel for that.
21:03:54 <Gracenotes> Look Around You: Category Theory
21:06:26 <arkeet> indeed, toList = foldr (:) []
21:09:23 <erisco> Gracenotes, is there actually an episode on that? lol
21:09:39 <Gracenotes> would that it were
21:10:03 <erisco> that seems like an incomplete thought
21:10:57 <Gracenotes> surprisingly it is a sentence
21:11:02 <ekipan> that's only because nobody uses the subjunctive mood in English any more
21:11:46 <Clint> sure they do, they just use it incorrectly
21:11:50 <erisco> subjunctive... someone didn't take enough English classes and it isn't you
21:12:12 <ekipan> actually I first learned what it was in high school french
21:12:18 <Gracenotes> 'would that X' is similar in meaning to 'if only X', and 'were' is used as a subjunctive form of 'to be', as in 'to exist'
21:12:42 <ekipan> I've retained very little else of high school french
21:12:45 <Gracenotes> actual linguists could probably explain 'would that' better, though
21:12:57 <erisco> oh, I understood when wikipedia said it expresses unreality
21:13:14 <Gracenotes> it is a weird-looking sentence though
21:14:15 <erisco> it is a little weird to talk about the past from the speculative future from the present :s
21:15:20 <Gracenotes> gotta have more modal logics. there are many possible pasts and futures, just lay em out on a grid :)
21:16:23 <erisco> the examples on wikipedia make much more sense to me than "would that it were" though
21:16:47 <thoughtpolice> shachaf: i followed your lead from a while ago and played with CoYoneda/Yoneda. it's interesting how they're the same yet different. and CoYoneda really is quite a bit more intuitive
21:16:52 <erisco> the verb doesn't have to be in past tense it seems
21:16:54 <thoughtpolice> even when you begin writing it all out
21:17:51 <erisco> "would that it be" makes more sense doesn't it?
21:18:46 <erisco> then again you say "I wish it was"
21:19:18 <ekipan> and the correct subjunctive way to say that is "I wish that it were"
21:19:43 <erisco> "I wish that it would be"
21:19:59 <erisco> I dunno :P
21:20:20 <shachaf> thoughtpolice: CoYoneda is so great.
21:20:29 <erisco> "I wish" might be talking about either the present or the future I suppose
21:20:45 <shachaf> thoughtpolice: The best I can figure out with Yoneda is boring things like "Yoneda Endo ~~ Maybe"
21:20:49 <erisco> it is all quite confusing to me
21:21:22 <shachaf> thoughtpolice: But CoYoneda can do all sorts of things.
21:21:48 <shachaf> thoughtpolice: You can also make things like data CoYoSet a = forall b. Ord b => CoYoSet (b -> a) (S.Set b)
21:22:02 <Gracenotes> perhaps 'would that it were' refers more the act of coming into existence, then perpetually existing
21:22:07 <Gracenotes> *than
21:22:43 <Gracenotes> would that Look Around You: Category Theory came into existence, rather than: would that Look Around You: Category Theory exists
21:23:02 <erisco> yeah but based on the subject you would infer that the thing still exists
21:23:03 <thoughtpolice> shachaf: yes, and I noticed as you said before you can write CoYoRef a = CoYoneda IORef a to get a 'read only' IORef, which is fairly neat
21:23:18 <shachaf> thoughtpolice: And you can say things like Program f = Free (CoYoneda f), as edwardk points out.
21:23:31 <erisco> like "Look Around You: Category Theory was critically acclaimed as the best in the series" doesn't negate the possibility that it still is
21:23:32 <Gracenotes> this is covered not as much by tense as by aspect, which talks about when things start, end, and about goals, causes, and state
21:23:51 <shachaf> This sounds like a discussion for #-blah.
21:24:33 <Gracenotes> about yoneda, or about english grammar? :p
21:24:37 <thoughtpolice> shachaf: https://gist.github.com/thoughtpolice/5843762 <- there's my hand waving around at the bottom
21:24:38 <Gracenotes> j/k
21:24:40 <shachaf> thoughtpolice: And the fmap-fusion gives you Free fusion of some kind, or something like that.
21:25:14 <shachaf> thoughtpolice: Note that you can say "fmap :: Functor f => f a -> Yoneda f a" and "fmap :: CoYoneda f a -> f a"
21:25:17 <erisco> which is also confusing... because people can still get that mixed up and be unsure if one is implicitly saying the thing no longer exists... such as "My uncle was such a strong figure in my childhood" might prompt people to suspect he is now deceased
21:25:26 <shachaf> I.e. Yoneda is the return value of fmap; CoYoneda is the arguments to fmap.
21:25:29 <thoughtpolice> shachaf: the interesting part is you define Free over Functor, but CoYoneda f is always a Functor!
21:25:41 <shachaf> thoughtpolice: Right.
21:25:52 <dolio> So is Yoneda.
21:26:06 <shachaf> Right.
21:26:25 <carter> i need to start understanding this stuff more
21:26:46 <shachaf> CoYoneda . Is ~~ (->)
21:27:09 <carter> what are Is and ~~
21:27:14 <shachaf> Is is type equality.
21:27:20 <shachaf> ~~ is my made-up notation for isomorphism.
21:27:25 <thoughtpolice> dolio: ah, right. i was just thinking of 'liftYoneda'
21:27:43 <shachaf> dolio: But Yoneda seems to give you less interesting Functors in practice. Is there any situation where it gives you something useful where CoYoneda doesn't?
21:29:25 <thoughtpolice> shachaf: ah, that's neat with the fmap unification
21:30:07 <Gracenotes> shachaf: I say, you should give a talk on this, so the internet can know it in perpetuity
21:30:14 <Gracenotes> ...or a blog post :p
21:30:59 <shachaf> Gracenotes: I doubt there's enough material for more than a few minutes of talk.
21:31:09 <Gracenotes> or a library
21:31:20 <erisco> or a tweet
21:31:39 <erisco> with a hash tag
21:31:58 <shachaf> Maybe if enough people followed me on Twitter I would do it.
21:32:31 <erisco> bah, I only have two real people who follow me (rest are bots). one of them I've never met and never will, and the other I may never meet again... but I still post stuff
21:32:39 <erisco> maybe I need help
21:32:41 <thoughtpolice> shachaf: i guess that makes sense when you eyeball the definition of liftYoneda/lowerCoYoneda, since liftYoneda :: f a -> Yoneda f a is defined in terms of fmap, while on the dual, lowerCoYoneda :: CoYoneda f a -> f a is defined in terms of fmap
21:33:49 <shachaf> thoughtpolice: Right.
21:34:22 <shachaf> thoughtpolice: In fmap :: (a -> b) -> f a -> f b, the "a" value can be treated as existential by the function -- i.e. it's the same type as fmap :: (exists a. (a -> b, f a)) -> f b
21:34:36 <shachaf> And similarly flip fmap :: Functor f => f a -> (forall b. (a -> b) -> f b)
21:36:56 <thoughtpolice> shachaf: what's the deal with CoYoSet?
21:37:30 <shachaf> Which deal?
21:37:38 <shachaf> It's like Set, but it's a Functor instance.
21:37:50 <thoughtpolice> yeah, sorry. brainfart :P
21:37:58 <shachaf> (But it does have some disadvantages.)
21:38:25 <shachaf> Namely map fusion can be a bad idea for a Set.
21:38:46 <shachaf> s/it's a/it has a/
21:38:50 <thoughtpolice> can something vaguely similar be done with Monad/Set?
21:38:55 <thoughtpolice> (just curious)
21:39:02 <shachaf> Yes, but the disadvantage is way bigger there.
21:39:14 <shachaf> Since the set will grow and never shrink.
21:39:32 <shachaf> http://www.haskell.org/pipermail/haskell-cafe/2010-June/079498.html
21:41:46 <shachaf> thoughtpolice: Now that you've figured out Yoneda you should figure out Codensity!
21:42:03 <dolio> newtype YoSet a = YoSet (forall r. Ord r => (a -> r) -> Set r) is also a functor.
21:42:29 <shachaf> True.
21:42:39 <dolio> And you could write lift :: Set a -> YoSet a, except Set's map is over constrained.
21:44:16 * ksf just might have stumbled across a solution to the expression problem.
21:44:27 <ksf> not sure, though, would have to implement it.
21:44:53 <carter> ksf implementing it is a good way to find out!
21:45:05 <shachaf> They should stop calling it the expression problem and call it the expression perspective or expression fact or something.
21:45:12 <shachaf> It's not really a thing to be solved.
21:45:16 <shachaf> Maybe the expression decision.
21:45:39 <ksf> the general idea is to have datatypes as interpreters, then unify them using TH and ghc generics.
21:46:49 <erisco> dmwit, around?
21:46:57 <sclv> the expression dichotomy.
21:47:02 <Gracenotes> some people, when confronted with a problem, say "I know, I'll use TH"
21:47:19 <carter> ksf you should look at compdata
21:47:20 <carter> it does that
21:47:22 <ksf> though in the end that's so close to AGs for economically challenged people that it'd be besser to just use TH.
21:47:33 <carter> ksf  http://hackage.haskell.org/package/compdata
21:47:36 <Gracenotes> still, probably easier than making an entire progrmaming language
21:47:39 <ksf> uuagc doesn't use TH, it has its own generator :)
21:47:46 <carter> its a neat way to do things, but hard to learn
21:47:49 <sclv> Gracenotes: where's the punchline?
21:48:09 <sclv> "Now they have code that generates problems"
21:48:15 <carter> the FreeMonad is the punchline
21:48:17 <ksf> I'm not even sure whether I have a problem in the first place, though. As I'm not trying to do anything overwhelmingly general.
21:48:25 <carter> just apply the right thing to generate stuff
21:48:27 <sclv> free monads _should_ be a punchline!
21:48:30 <Gracenotes> of course you have a problem, it's the expression problem!
21:48:44 <carter> i cant express my problems, thats my problem
21:48:45 <Gracenotes> sclv: I'm not looking to punch anyone
21:48:48 <shachaf> sclv: Sometimes you don't need to say the punchline.
21:48:49 <carter> healthy that
21:48:53 <shachaf> <lexande> sometimes i am confronted with a problem and i think "I know, I'll use Banach-Tarski"
21:48:58 <Gracenotes> heh
21:48:58 <sclv> no you always need to say punchlines
21:49:14 <sclv> shachaf: "now they have banach-tarski banach-tarski"
21:49:24 <Gracenotes> sclv: you ruined it!
21:49:38 <carter> because TT=T, HoTT is HoT
21:49:45 <Gracenotes> shachaf: not a fan of AoC, eh
21:49:53 <Gracenotes> as you mentioned :)
21:49:53 <sclv> how did i ruin it
21:50:21 <sclv> anyway you can't use banach-tarski, its nonconstructive :-P
21:50:36 <carter> sclv not constructive… yetttt
21:50:42 <shachaf> sclv: Since when has that stopped me from doing things?
21:50:49 <carter> i'll apply it some gold one day
21:50:51 <carter> just you see
21:51:15 <sclv> my contributions are always constructive
21:51:47 <carter> woo
21:52:13 <dolio> You shouldn't joke like that. The HoTT folks might get embarassed. :)
21:52:42 <dolio> Comparing them to axiom of choice.
21:53:30 <carter> do i have a choice in the matter?
21:53:39 <carter> depends right?
21:53:39 <sclv> @remember AndrejBauer When have you ever heard a category theorist say: I want to prove this diagram commutes—Let's suppose it doesn't.
21:53:40 <lambdabot> Done.
21:53:54 <shachaf> sclv: Was that "" intentional?
21:54:13 <dolio> sclv: They're much too clever for that. :)
21:54:15 <carter> thats a good quote, is it  a real one?
21:54:19 <sclv> yes
21:54:24 <sclv> (it is a real one is the yes)
21:54:33 <shachaf> I guess that's a silly question.
21:54:34 <shachaf> @forget AndrejBauer When have you ever heard a category theorist say: I want to prove this diagram commutes—Let's suppose it doesn't.
21:54:34 <lambdabot> Done.
21:54:37 <shachaf> @remember AndrejBauer When have you ever heard a category theorist say: I want to prove this diagram commutes—Let's suppose it doesn't.
21:54:37 <lambdabot> Done.
21:55:07 <sclv> I can't see the difference between the two, and its killing me.
21:55:18 <shachaf> The first one had control characters in it.
21:55:27 <sclv> ah yeah they don't show up for me!
21:55:27 <carter> which ones?
21:55:42 <shachaf> Whichever one shows up as a \ for me.
21:56:10 <sclv> its from the video of his talk at IAS on five stages of accepting constructive math
21:56:43 <shachaf> 001C   INFORMATION SEPARATOR FOUR     [^\]
21:57:07 <carter> ah neat
21:58:01 <Gracenotes> sclv: hm, link?
21:59:05 <sclv> http://video.ias.edu/members/1213/0318-AndrejBauer
21:59:55 <sclv> wow they have a bunch of interesting type theory talks at the moment
22:00:12 * hackagebot progression 0.5.0.2 - Automates the recording and graphing of criterion benchmarks  http://hackage.haskell.org/package/progression-0.5.0.2 (KidoTakahiro)
22:00:26 <sclv> Zeilberger on substructural type theory, for example
22:01:34 <carter> sclv doroin zeilberger?
22:01:39 <carter> or a diferent one?
22:02:04 <sclv> noam
22:02:21 <sclv> i suppose i should have specified "the less famous one"
22:02:29 <carter> the son?
22:03:25 <sclv> nephew, apparently
22:03:34 <carter> ah
22:15:12 * hackagebot regex-tdfa-text 1.0.0.2 - Text interface for regex-tdfa  http://hackage.haskell.org/package/regex-tdfa-text-1.0.0.2 (KidoTakahiro)
22:43:10 <sclv> oh man just got the banach tarski joke. man am i dense
22:43:18 <dolio> Heh.
22:48:36 <u_>        (x1,y1) = fromJust $ find ((< price - spread) . fst) bids        (x2,y2) = fromJust $ find ((> price + spread) . fst) asks
22:48:41 <u_> i hate it when you have 2 lines
22:49:07 <u_> which are similar but not quite similar enough to abstract it out
22:49:08 <shachaf> Never say x = fromJust y :-(
22:49:13 <shachaf> Instead, say Just x = y
22:49:17 <u_> why?
22:49:19 <shachaf> Still bad, but at least your error message will be useful.
22:49:30 <u_> what's the difference?
22:49:45 <shachaf> The error message in case find fails.
22:50:14 <shachaf> Of course, it's even better to handle the failure. But perhaps you don't want to do that. Who knows. But what I said is a completely local change.
22:50:27 <u_> i mean what's the difference in the error message
22:50:37 <shachaf> Try it out!
22:50:43 <shachaf> > fromJust Nothing
22:50:44 <lambdabot>   *Exception: Maybe.fromJust: Nothing
22:50:50 <u_> oh there's no line number
22:51:24 <Gracenotes> perhaps you need an applicative, or somethin
22:51:42 <lispy> You know what's easier than getting ghc to print out the line number? Not using partial functions when they can fail.
22:51:52 <lispy> and get off my lawn!
22:51:53 <lispy> :)
22:51:58 <shachaf> lispy: No, getting GHC to print out the line number is easier.
22:52:23 <u_> in this case i'm 100% sure it won't fail at least
22:52:40 <zvrba> what are the differences between haskell98 and haskell2010_
22:52:49 <zvrba> i just got this from ghci: Perhaps you need to add `haskell98' to the build-depends in your .cabal file.
22:52:57 <zvrba> (I'm using eclipse's plugin)
22:53:09 <zvrba> [I tried to use Maybe.fromJust]
22:53:15 <sclv> syou shouldn't add haskell98
22:53:22 <shachaf> GHC is being unhelpful again.
22:53:30 <lispy> zvrba: http://www.haskell.org/onlinereport/haskell2010/haskellli2.html#x3-5000
22:53:33 <shachaf> You would add that if you were trying to get old code running as-is.
22:53:44 <shachaf> But you're writing new code, so you want to write it to the new libraries.
22:53:51 <shachaf> In this case the module is called Data.Maybe, not Maybe.
22:53:54 <zvrba> ok
22:53:58 <applikativ> Data.Maybe.fromJust
22:53:59 <shachaf> So import Data.Maybe.
22:54:06 <shachaf> Also, please don't use fromJust. :-( It is a great evil.
22:54:06 <zvrba> ok, that worked :)
22:54:22 <dmwit> I have a cunning plan.
22:54:27 <zvrba> shachaf: why does this channel have philosophical objection to programs that crash?
22:54:31 <dmwit> teaspoon (fromJust foo)
22:54:32 <applikativ> zvrba: old tutorials often import Monad List IO Maybe etc
22:54:35 <zvrba> (as opposed to programs silently giving the wrong result)
22:54:39 <arkeet> fwiw, don't use the haskell2010 package either.
22:54:45 <zvrba> ok
22:54:50 <applikativ> you have tofigure out Control.Monad Data.List System.IO etc
22:54:56 <dmwit> zvrba: silently giving a correct result is the third option, and i'ts the best of all
22:54:57 <shachaf> zvrba: No objection to programs that crash. I prefer for them to crash at compile-time if possible.
22:55:05 <shachaf> zvrba: But if they crash at runtime, it matters *how* they do it.
22:55:09 <zvrba> shachaf: (no, I probably won't use it as it's not much more shorter than pattern-matching)
22:55:11 <shachaf> fromJust leads to bad habits and bad programs.
22:55:34 <shachaf> (And bad error messages in particular.)
22:55:40 <zvrba> shachaf: what's the difference between fromJust having crashed and inexhaustive pattern having crashed?
22:55:57 <shachaf> One difference: The error message is much more useful.
22:56:01 <zvrba> [except that Maybe is so trivial that compiler can check for inexhaustive match]
22:56:07 <zvrba> ok
22:56:09 <lispy> with -Wall you can detect inexhaustive pattern matches at compile time
22:56:27 <shachaf> Compiler exhaustiveness checking is hardly only for "trivial" things.
22:56:28 <zvrba> I got this in ghci: *** Exception: Maybe.fromJust: Nothing
22:56:29 <lispy> (for more than just Maybe)
22:56:33 <applikativ> if you make it a pattern match in general -Wall will tell you about missing cases
22:56:34 <zvrba> i don't consider this "unhelpful".
22:56:42 <zvrba> would I get location in the code in a compiled program?
22:56:56 <shachaf> zvrba: Really? In a 100,000 line program full of fromJusts?
22:57:01 <zvrba> lispy: yeah, eclipse runs "lint"-equivalent while writing code.
22:57:15 <dmwit> zvrba: Not with fromJust; but with a failed pattern match, yes, yo uwould get a code location.
22:57:19 <zvrba> shachaf: hence, my question :)
22:57:20 <applikativ> zvrba: if you wrote let Just x = Nothing ; ...
22:57:23 <zvrba> dmwit: ok.
22:57:29 <shachaf> zvrba: You can find that out easily enough. :-)
22:57:33 <shachaf> > let Just x = Nothing in x
22:57:34 <lambdabot>   *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Da...
22:57:41 <shachaf> So that's one thing.
22:57:47 <dmwit> ...at least, from GHC.
22:57:53 <zvrba> ok
22:57:57 <zvrba> i'm convinced.
22:58:24 <applikativ> pattern matching is usually clearer anyway
22:58:35 <zvrba> is there a style guide somewhere listing patterns and "antipatterns"?
22:58:40 <zvrba> brb..
22:58:52 <lispy> zvrba: there is a style guide.
22:59:17 <lispy> zvrba: there is this, although I don't use a lot of the 'style' in there myself: https://github.com/tibbe/haskell-style-guide
22:59:47 <lispy> we should be better about codifying the folklore into guides for people new to the language.
23:00:12 <lispy> And make sure to point out that #haskell-style pointfree is not meant for "production" code :)
23:00:26 <lispy> (it sure is fun for golf though)
23:01:04 <Gracenotes> model essential complexity, eschew accidental complexity
23:01:25 <Gracenotes> or hide it very well
23:01:40 <roboguy_> is there a haskell package for emacs that has fewer quirks than haskell-mode?
23:02:55 <johnw> roboguy_: what quirks does haskell-mode have?
23:03:46 <roboguy_> johnw: well, I can't set the prompt to lambda without it crashing and sometimes when I hit tab it comes up with an error like "Wrong argument type: arrayp, nil"
23:03:55 <zvrba> ok, thanks people. gotta go now. (read LYAH)
23:04:28 <johnw> roboguy_: you mean, your problems are in interacting with ghci?
23:04:53 <roboguy_> johnw: the first one is with ghci, the second one is when I'm editing a haskell file
23:05:17 <johnw> well, haskell-mode has 2 ghci interaction modes, and 3 indentation modes
23:05:27 <johnw> so I bet the answer to your question is "haskell-mode"
23:05:37 <roboguy_> i forgot about that
23:05:37 <roboguy_> hmm
23:05:51 <roboguy_> how do I switch the ghci interaction mode?
23:06:28 <johnw> there's inf-haskell (which is the default, I believe), and haskell-interaction-mode
23:06:42 <johnw> i'll have to leave you to reading the tops of those files
23:06:51 <roboguy_> alright, thanks
23:07:05 <johnw> i've used both and they've both worked for me.  I changed my prompt to ">>> "
23:07:16 <roboguy_> well i know why that doesn't work for me
23:07:17 <johnw> also, are you use Emacs 24?
23:07:23 <roboguy_> it looks for a prompt that is of a certain format
23:07:26 <roboguy_> yes
23:07:49 <roboguy_> I think ">>> " is formatted right but it doesn't like lambdas
23:08:14 <johnw> i hate to say it, but don't use lambda
23:08:42 <lispy> roboguy_: I switched to vim.
23:08:51 <lispy> roboguy_: (no joke)
23:09:06 <roboguy_> lispy: I thought about that, but I've used emacs for a few years so it might be kind of a hard switch
23:09:29 <lispy> I used emacs for at least 10 years before switching :)
23:09:37 <lispy> Now I can use both
23:10:01 <roboguy_> lispy: haha, well I definitely haven't used it that long. maybe that would work...
23:10:24 <lispy> I also didn't use ghci inside emacs
23:10:40 <johnw> i use ghci while I code
23:10:42 <johnw> very handy
23:10:43 <lispy> I use tmux instead of embedding ghci in my editor
23:14:21 <roboguy_> lispy: I thought about trying tmux, but it seemed easier to just use the builtin ghci interaction mode. I'm used to using lisp in emacs, so I was already used to that kind of thing
23:22:32 <applikativ> the readme for https://github.com/jtobin/dates is pretty amusing.  Data.Time uses newtyped Integer but a shabby use of Int wont overflow til "ModifiedJulianDay (fromIntegral (maxBound :: Int) :: Integer)
23:22:36 <applikativ> -- 25252734927768413-06-12"
23:23:31 <applikativ> well after the heat death of the universe
23:31:58 <wagle> maybe need bigbang count in addition to year
23:32:41 <wagle> man, just wait until that bug hits
23:32:53 <palmje> does anyone know what would be causing this problem? comes from the linker step: relocation R_X86_64_32S against `stg_CAF_BLACKHOLE_info' can not be used when making a shared object; recompile with -fPIC
23:33:10 <palmje> this is using ghc 7.6.3 - I can get it to work, but I have to use -dynamic and -fPIC
23:35:01 <wagle> sounds like the stg lib wasnt compiled with pic, but i dunno
23:36:38 <palmje> it's the generic amd64 build
