00:00:02 <ksf> depends on your filesystem.
00:00:13 <ksf> some are good at such stuff, some aren't.
00:00:23 <ksf> most aren't.
00:00:56 <akegalj> ksf: ok. thnx for that. I thought it was some kind of bug
00:01:07 <ksf> actually, I can't think on top of my head of any single one that'd be famous for dealing well with it.
00:01:24 <ksf> well, it's certainly not a feature :)
00:01:28 <shachaf> ReiserFS, maybe?
00:01:44 <ksf> better than ext2 better than fat, sure.
00:01:57 <ksf> but you still don't want 100k files in reiserfs.
00:02:01 <shachaf> akegalj: You could strace the Haskell program to see what it's doing.
00:02:12 <shachaf> You could try writing a simple program in C or something to see what sort of overhead that has.
00:02:47 <ksf> akegalj, another thing to try is to make the directories smaller.
00:03:07 <ksf> keep them each under at most 1000 entries
00:03:27 <shachaf> Yes, certainly.
00:04:10 <akegalj> i was thinking of... if there was some command to ask OS to cache all data in folder, and after that reading files is cheap
00:06:46 <mjrosenb> is there a function like nubBy that lets me specify how to combine similar elements?
00:08:37 <shachaf> As opposed to just taking the first one?
00:08:41 <shachaf> I don't think so.
00:09:11 <shachaf> Also keep in mind that nubBy behaves slightly strangely with some functions.
00:09:38 <isomorphic> akegalj:  What platform are you on?
00:10:39 <mjrosenb> shachaf: what functions?
00:10:51 <mjrosenb> i'm going to guess ones that aren't commutative?
00:10:55 <akegalj> shachaf: il see about ReiserFS, thnx for info.
00:11:03 <shachaf> akegalj: I'm not recommending ReiserFS.
00:11:12 <shachaf> Nor saying that it's good with the thing you want, for that matter.
00:11:22 <akegalj> ksf: thnx for info about 1000 files in folder, will try that
00:11:26 <shachaf> mjrosenb: Ones that aren't equivalence relations, certainly. And even ones that are...
00:11:32 <shachaf> @src nubBy
00:11:33 <lambdabot> nubBy eq []             =  []
00:11:33 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
00:11:33 <akegalj> isomorphic: arch linux
00:11:43 <shachaf> Well, it's as strange as you might expect from that definition.
00:12:16 <akegalj> shachaf: ok, will do more searching in that area.. im no expert
00:12:36 <mjrosenb> shachaf: it doesn't look that strange to me.
00:13:22 <isomorphic> akegalj:  One thought is to look - as shachaf suggests above - at the pattern of reads your program is ultimately generating.   On arch, you might look at http://sourceware.org/systemtap/
00:15:18 <isomorphic> See particularly the examples - http://sourceware.org/systemtap/examples/
00:15:48 <akegalj> isomorphic: thnx, will read that
00:32:30 <dEPy> mornin'  :]
00:51:18 <mjrosenb> @src intercalate
00:51:18 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
00:51:27 <mjrosenb> @src intersperse
00:51:27 <lambdabot> intersperse _   []     = []
00:51:27 <lambdabot> intersperse _   [x]    = [x]
00:51:27 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
00:59:18 <zvrba> @src concat
00:59:19 <lambdabot> concat = foldr (++) []
01:24:44 <structuralist> is there an accepted notation for the base functor of a recursive type?
01:24:50 <structuralist> like the opposite of mu
01:26:39 <structuralist> data A = A O (I -> A)
01:26:49 <structuralist> data A' x = A O (I -> x)
01:26:55 <structuralist> A' or AF or … ?
01:31:52 <jonkri> GHC 7.0.1 comes with template-haskell built against containers-0.4.0.0. however, when i want to build the same version of template-haskell against a newer version of containers, i get an error saying that the reinstall of template-haskell will break ghc-7.0.1. is there any way that i can get around this? i need to use template-haskell with a project that depends on a newer version of containers
01:31:54 <supki> I thought the opposite of Mu would be  data CoMu f = forall a. CoMu (a -> f a) a
01:31:57 <supki> ?
01:32:42 <supki> I think it's what Nu is in recursion-schemes package
01:36:23 <supki> jonkri: I wouldn't recommend reinstalling containers (and template-haskell especially)
01:37:18 <jonkri> supki: thanks for your answer. does that mean that i can't use containers >= 0.5 and support ghc 7.0 at the same time?
01:37:27 <jonkri> (p
01:37:41 <jonkri> (or being able to depend on template-haskell)
01:37:58 <jonkri> s/or/and
01:40:09 <supki> jonkri: yes, I would say you can't. By reinstalling any package that came with ghc you're entering the world of endless dependency hell
01:40:41 <supki> jonkri: specifically for template-haskell the problem is really weird errors
01:40:56 <jonkri> thank you
01:41:24 <supki> https://github.com/ekmett/lens/issues/276
01:41:25 <supki> like that
01:42:12 <aleator> Quick spelling Q: should I write typeclass or type class?
01:44:07 <arkeet> the report writes "type class"
01:44:31 <arkeet> I often write "typeclass" just out of habit though.
01:44:31 <shachaf> type class
01:44:32 <aleator> arkeet: That's safe then. Thanks.
01:52:01 <mauke> I often type class
01:55:18 <Fuuzetsu> Is there a way to print out GHCi version while in the GHCi session?
01:56:03 <aleator> :!ghci --version ?
01:56:18 <aleator> .. for some version of some ghci.. :/
01:56:29 <Fuuzetsu> that just runs ghci at the command line
01:56:37 <Fuuzetsu> pretty useless if you switch your versions a lot
01:56:48 <aleator> Fuuzetsu: indeed
02:00:13 <aleator> Anyone know in which article introduces `seq`? I'd need to cite the origins of it?
02:00:27 <typoclass> aleator: maybe the Report?
02:01:25 <aleator> typoclass: Ah indeed. That will do if I can't find anything earlier.
02:04:38 <thoughtpolice> shachaf: is there ever any particular reason to prefer Yoneda vs CoYoneda?
02:05:04 <shachaf> thoughtpolice: I've asked that question more than once before...
02:06:00 <shachaf> When f is a Functor there's usually no reason to care.
02:06:37 <shachaf> When it's not a Functor they probably behave differently, and it seems that CoYoneda is generally the one with the more interesting behavior.
02:07:00 <thoughtpolice> hm, I wonder what CoYoneda IORef is vs Yoneda IORef
02:07:14 <shachaf> "read-only" IORef vs. something not useful.
02:07:19 <thoughtpolice> or does it yield the same kind of read-only IORef?
02:07:30 <thoughtpolice> ah, i figure i'd ask before putting it in GHCi :P
02:08:23 <shachaf> Well, look at the type: (forall b. (a -> b) -> IORef b)
02:08:49 <shachaf> The trouble is that you can't really make one.
02:11:10 <mikeplus64> is there some way to see what instances are applicable for some type? other than :i, i want to see what instances might apply to some amalgamation of types
02:12:16 <shachaf> mikeplus64: Nothing in ghci etc., as far as I know.
02:13:55 <jonkri> supki: ouch. yeah, that is ugly :>
02:13:57 <yitz> @help instances
02:13:57 <lambdabot> instances <typeclass>. Fetch the instances of a typeclass.
02:14:17 <yitz> but it's only for types and instances that lambdabot happens to know about
02:14:24 <structuralist> supki: whoah. where can I read more about this CoMu? it looks exactly like something else I'm using
02:16:55 <hpaste> “http://kodokcorner.blogspot.com” pasted “BOLA368.com Agen Judi Bola Terpercaya Promo 10% All Games Sportbook” at http://hpaste.org/90330
02:17:05 <structuralist> why is Mu not Mu f = In (f (Mu f)) ???
02:17:31 <structuralist> instead it's Mu f = Mu (forall a. (f a -> a) -> a)
02:17:41 <hpaste> “http://arbo-media.blogspot.com/” pasted “Anekahosting.com web hosting murah terbaik di indonesia” at http://hpaste.org/90331
02:17:54 <structuralist> (in recursion-schemes)
02:18:23 <shachaf> chrisdone: hpaste spam
02:19:02 <shachaf> structuralist: Because that's what Mu is.
02:19:24 <shachaf> Fix is the thing you said.
02:19:26 <shachaf> It's isomorphic.
02:19:47 <structuralist> shachaf: does that particular form of it have a name?
02:21:19 <shachaf> Yes, it's called Mu.
02:21:33 <structuralist> so Mu and Fix are not synonymous
02:21:43 <structuralist> I thought they were
02:21:49 <shachaf> People use the name Mu for everything.
02:22:11 <shachaf> roconnor once called newtype Rec a = Rec (Rec a -> a) "Mu", too.
02:22:59 <structuralist> how is that isomorphic to the others?
02:23:22 <shachaf> I think that's left as an exercise.
02:23:35 <shachaf> One direction is usually called "cata".
02:25:34 <structuralist> well Rec :: * -> * so I'm not seeing it
02:25:54 <shachaf> Oh, no, not Rec.
02:26:02 <shachaf> Rec is a different type.
02:26:22 <structuralist> oh
02:26:34 <structuralist> well I see that the other two are isomorphic
02:26:45 <shachaf> Nu, too.
02:26:50 <structuralist> one seems more indirect though
02:27:07 <structuralist> and there's no special name for that presentation
02:27:09 <structuralist> ?
02:27:32 <shachaf> I'm not sure what you're getting at.
02:27:39 <structuralist> what do I google
02:28:55 <structuralist> to find more occurences of this, which I've never seen before
02:35:53 <chrisdone> shachaf: temporary measure: don't announce titles or authors that are urls. but i'll do that nickname checking idea now
02:46:26 <b__> Is it possible to get maxBound from a value?
02:46:35 <shachaf> What does that mean?
02:46:40 <b__> Like "Bounded a => a -> a"
02:46:56 <shachaf> A function which just ignores its argument?
02:47:00 <b__> yes
02:47:08 <shachaf> > let foo :: Bounded a => a -> a; foo _ = maxBound in foo (123 :: Int)
02:47:09 <lambdabot>   2147483647
02:47:32 <typoclass> shachaf: hah! not bad
02:47:38 <b__> cheers :p
02:47:48 <supki> > maxBound `asTypeOf` (123 :: Int)
02:47:52 <lambdabot>   mueval-core: Time limit exceeded
02:47:55 <supki> ...
02:47:59 <supki> > maxBound `asTypeOf` (123 :: Int)
02:48:02 <lambdabot>   mueval-core: Time limit exceeded
02:48:17 <supki> ok
02:48:24 <b__> works in ghci
02:48:25 <shachaf> :t (maxBound `asTypeOf`)
02:48:30 <lambdabot> Bounded a => a -> a
02:48:32 <shachaf> Yes, that works too.
03:20:18 <aleator> Anyone know how I can simulate --make with GHC-api? Currently, I can evaluate expressions from a file, but if I import files that are not packaged I get strange errors of names not being in scope (importing packages does work).
03:20:58 <jonkri> how can i export a function only if "#if MIN_VERISON_ghc(7.6.1)" is satisfied?
03:21:06 <Breadmonster> What are applicative functors?
03:21:26 <mauke> module Foo (
03:21:31 <mauke> #if whatever
03:21:34 <mauke>   bar
03:21:36 <mauke> #endif
03:21:38 <mauke> )
03:21:47 <mauke> Breadmonster: instances of Applicative
03:21:50 <aleator> Breadmonster: Not describable by simple sentence. My favourite explanation is that they are generalized zipWith.
03:21:52 <typoclass> Breadmonster: it's basically a little extension to Functors. it's explained quite well in typeclassopedia
03:21:53 <jonkri> mauke: thanks. i tried that
03:21:57 <jonkri> brb
03:21:57 <typoclass> @where typeclassopedia
03:21:58 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
03:22:15 <jonkri> i got "lexical error at character 'i'"
03:22:31 <jonkri> do i need some LANGUAGE pragma in order for that to work?
03:22:41 <typoclass> jonkri: do you have CPP turned on?
03:22:52 <jonkri> typoclass: nope, thanks
03:23:05 <mauke> jonkri: if you don't have CPP turned on, "#if MIN_VERISON_ghc(7.6.1)" is meaningless
03:23:16 <mauke> because that's not valid haskell
03:23:17 <jonkri> mauke: got it, thanks :)
03:26:17 <jonkri> what does this error mean?
03:26:18 <jonkri>      error: missing binary operator before token "("
03:26:18 <jonkri>      #if MIN_VERSION_ghc(7,6,1)
03:26:18 <jonkri>      ^
03:26:20 <ion> @ask lemmih IIRC you implied one can use ErrorT with Update/Query. Can one use makeAcidic with db_create :: String -> ErrorT String (Update Tasks) Task somehow? I’m probably missing something obvious.
03:26:21 <lambdabot> Consider it noted.
03:27:28 <Ke> jonkri: I would guess that macro is not defined for some reason
03:27:48 <mauke> no
03:28:23 <mauke> that is a weird error
03:29:31 <mauke> ok, it does mean an undefined macro but the error is still weird
03:29:54 <jonkri> line 49: http://hpaste.org/90344
03:29:58 <mauke> ah, it expands unknown identifiers to 0
03:30:17 <ion> @tell lemmih Oh, i guess i’m just supposed to use runErrorT within the Update/Query actions. But then they wouldn’t be propagated through update/query, which is something i wanted. I guess i could create wrappers for them that put MonadError back.
03:30:17 <lambdabot> Consider it noted.
03:31:48 <mauke> jonkri: MIN_VERSION_ghc is not predefined by ghc. where did you get it?
03:32:47 <code-karma> hello
03:33:31 <mauke> jonkri: what are you trying to do?
03:33:34 <jonkri> mauke: i saw that MIN_VERSION_<something> was used, and then i googled MIN_VERSION_ghc, i saw that it was used, in for example <http://hackage.haskell.org/packages/archive/leksah-server/0.12.1.2/doc/html/src/IDE-Utils-GHCUtils.html>
03:33:51 <fosskers> hey guys
03:33:56 <code-karma> hey
03:34:00 <jonkri> mauke: i want to say "if the installed ghc version is >=7.6.1, then do this"
03:34:03 <mauke> jonkri: http://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation
03:34:16 <fosskers> is there a function that executes haskell code?
03:34:28 <mauke> jonkri: #if __GLASGOW_HASKELL >= 706
03:34:35 <fosskers> a la eval/exec ?
03:34:36 <mauke> fosskers: as in eval()? no
03:34:46 <jonkri> thanks mauke
03:34:47 <mauke> it would have to include a complete haskell compiler to do that
03:34:51 <fosskers> mauke: i was poking around for one and couldn't find one
03:35:01 <fosskers> mauke: well then how does ghci do it?
03:35:11 <mauke> fosskers: it includes a complete haskell compiler
03:35:17 <mauke> (i.e. ghc)
03:35:21 <fosskers> haha
03:35:23 <fosskers> alright
03:35:38 <fosskers> alright then, let's say I have a string of haskell code
03:35:49 <mauke> fosskers: http://hackage.haskell.org/package/hint
03:35:51 <fosskers> i want to execute it and return the results
03:37:00 <fosskers> mauke: interesting
03:37:19 <typoclass> fosskers: maybe pipe it into runhaskell? e.g., echo "main = print 42"|runhaskell
03:38:23 <Lethalman> fosskers, http://hackage.haskell.org/packages/archive/plugins/1.5.1.4/doc/html/System-Eval-Haskell.html
03:38:24 <fosskers> let me cut to the chase: i'm trying to find cool ways to connect my Lisp dialect with the Haskell it's written in
03:38:41 <fosskers> embedding haskell might be cool, i thought
03:40:18 <jonkri> mauke: where did you get 706 from?
03:40:53 <fosskers> Lethalman: that is also a cool library
03:41:11 <typoclass> jonkri: 706 means 7.6, it's a bit odd
03:41:21 <jonkri> typoclass: thanks
03:41:27 <typoclass> jonkri: (706 does not mean 7.0.6 or something)
03:41:35 <jonkri> ok :)
03:41:57 <chrisdone> shachaf: elliott: typoclass: ok, hpaste now consults WHOIS for every announcement
03:42:29 * typoclass purrs happily at chrisdone
03:43:16 <chrisdone> (∩▂∩)
03:43:17 <ion> neat
03:43:30 <fosskers> Lethalman: System.Eval.Haskell would force my Evaluate Monad into IO
03:43:37 <fosskers> that is, I'd have to add IO to the stack
03:43:49 <mauke> jonkri: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/options-phases.html#c-pre-processor
03:44:00 <fosskers> mauke: it doesn't seem like i'd have to add IO to the stack to add InterpreterT?
03:44:18 <fosskers> id' prefer to keep IO out of Evaluate
03:44:42 <jonkri> mauke: nice, thanks
03:47:56 <merijn> chrisdone: So I can no spam porn URLs like crazy? \o/
03:48:00 <merijn> s/no/now
03:49:31 <chrisdone> merijn: should be! we're now filtering with spamassassin, http:// in the title, and demanding author being an irc nick. should be enough barriers to at least stop the spammy announcements!
03:50:52 <sordina1> Is there an example of using lenses with sum types?
03:54:39 <supki> sordina1: you may look at Control.Lens.Prism haddocks
03:55:17 <supki> if by "lenses with sum types" you meant prisms
03:55:28 <sordina1> supki: Cool I'll check it out.
03:57:43 <shachaf> Prisms are the dual of lenses *for* sum types, but they aren't really lenses. There are also (affine) traversals, which is possibly what sordina1 meant.
04:01:26 <aleator> shachaf: Prisms are even more awesome than lenses ;)
04:02:58 <sordina1> shachaf: Right, I would like to learn the dual, but I'd also like to get some work done :D
04:13:53 <mekeor> can you (still?) use yesod with fastcgi?
04:17:06 <merijn> Can anyone recommend a matrix library? Preferably one with a convenient inversion function built-in
04:18:39 <shachaf> merijn: edwardk's linear was mentioned recently.
04:18:55 <merijn> oh, hmatrix has an invert function too, I overlooked it at first
04:18:59 <shachaf> I don't know much about it.
04:19:33 <merijn> I don't see anything named linear on hackage, so I guess I'll try hmatrix first
04:20:02 <merijn> This is academic quality software anyway, so :p
04:20:08 <shachaf> @hackage linear
04:20:09 <lambdabot> http://hackage.haskell.org/package/linear
04:20:15 <shachaf> That's as named-linear as you can get.
04:20:23 <shachaf> But I don't know whether it does what you want.
04:20:40 <merijn> oh, I blame hackage search for sucking, then
04:20:45 <merijn> It doesn't find lens either
04:20:52 <merijn> Maybe Hackage just hates edwardk
04:23:47 <srhb> I'm looking at http://projects.haskell.org/xmonad-extras/ and when I cabal install xmonad-extras, I get version 0.11, but XMonad.Hooks.PerWindowKbdLayout doesn't exist. What am I missing?
04:24:44 <shachaf> How can you tell that it doesn't exist?
04:24:56 <srhb> Well, I only checked in my .cabal directory
04:25:02 <srhb> And tried loading it in ghci.
04:25:22 <shachaf>     if impl(ghc >= 6.12.1) && flag(with_template_haskell) && flag(with_hlist)
04:25:25 <shachaf>         exposed-modules: XMonad.Hooks.PerWindowKbdLayout
04:25:32 <srhb> Where do you see that?
04:25:34 <shachaf> I guess you need to compile it with some flags.
04:25:38 <shachaf> In http://hackage.haskell.org/packages/archive/xmonad-extras/0.11/xmonad-extras.cabal
04:25:47 <shachaf> ("Package description")
04:25:52 <shachaf> s/P/p/
04:25:56 <srhb> Ah. I didn't think to actually read the cabal file.
04:26:09 <mauke> ah, hlist
04:28:47 <srhb> Myeah, it doesn't build. I guess that explains.
04:36:53 * typoclass . o O ( PurrWindowKbdLayout )
04:37:44 <srhb> typoclass: Make it happen. :P
04:40:19 <fosskers> mauke: played around with `hint`. I'll be going with it for my project after all
04:40:47 <typoclass> srhb: make it hap-pun =)
04:45:46 <Shou> Wasn't there a recent list of recommendations for Haskell projects to contribute to floating around somewhere?
04:46:31 * hackagebot yesod 1.2.1.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.2.1.1 (MichaelSnoyman)
04:46:33 * hackagebot yesod-bin 1.2.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.1 (MichaelSnoyman)
04:51:31 * hackagebot yesod-core 1.2.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.3 (MichaelSnoyman)
04:51:33 * hackagebot yesod-form 1.3.0.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.0.1 (MichaelSnoyman)
04:51:35 * hackagebot warp 1.3.9 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.9 (MichaelSnoyman)
05:06:26 <jtanguy> Hello, I try to implement a list datatype which length is encoded in its type
05:07:12 <jtanguy> I pulled some ideas from mattew becknell's articles on btrees in GADT
05:07:38 <jtanguy> but I am stuck when writing a fromList helper function
05:12:01 <Saizan> you need to wrap it in an existential
05:13:23 <Saizan> unless you want fromList to get the target length as an argument, then you'll need a singleton type to reify it
05:13:52 <Saizan> (and handle the case in which the given list is of the wrong length somehow)
05:14:42 <jtanguy> Here is my current code: http://hpaste.org/90355
05:15:23 <Saizan> data EList a where EList :: L n a -> EList a -- that'd be the existential wrapper
05:15:53 <jtanguy> but then i'd loose the type-length information
05:16:38 <Saizan> it's not really lost because you didn't have it when you start from "[a]"
05:17:27 <Saizan> but then you can match on EList and go on with your life
05:18:04 <jtanguy> hum
05:18:34 <Saizan> another way would be data Natty :: Nat -> * where NZ :: Natty Z; NS :: Natty n -> Natty (S n)
05:18:49 <Saizan> then have fromList :: Natty n -> [a] -> List n a
05:19:02 <Saizan> but that's not really implementable
05:19:13 <jtanguy> i came up with it to type-check the following problem: how to constrain two list arguments f :: [a] -> [a] -> * to have the same length
05:19:18 <Saizan> fromList :: Natty n -> [a] -> Maybe (List n a) is
05:20:39 <jtanguy> but maybe i'm overcomplicating it and could use guards instead
05:20:50 <Saizan> jtanguy: if you start with [a] you'll have to put a runtime check somewhere
05:21:59 <jtanguy> the idea is to transform [a] into a (L n a) and i would have f :: L n a -> L n a -> *
05:23:07 <Saizan> are you using * as a wildcard or as the kind?
05:23:15 <jtanguy> as a wildcard
05:25:04 <Saizan> ok, the type of f makes sense, then the caller is required to ensure the arguments have the same length, either by construction or by checking it
05:25:26 <jtanguy> exactly
05:25:52 <bakibour> Greetings
05:26:32 <bakibour> I just compliled a rather small program but the binary files is about 1,5 mb big, is there any way to reduce the size of the executables, and why are they so big in general?
05:27:10 <mauke> bakibour: http://stackoverflow.com/questions/6115459/small-haskell-program-compiled-with-ghc-into-huge-binary
05:27:41 <Saizan> e.g. it could call fromList :: [a] -> EList a on both, then run a comparison on the L n a, L m a obtained returning Maybe (Is m n), where data Is a b where Refl :: Is a a
05:31:03 <jtanguy> the problem is to produce the L n a in the first place (or maybe i don't have the necessary GHC extensions)
05:31:44 <Saizan> you produce EList a, then pattern match on it to get the L n a inside
05:33:10 <Saizan> Haskell is not dependent enough to let you have a type like "fromList :: (xs :: [a]) -> L (length xs) a" but that's not so bad here
05:35:35 <merijn> Is there a function like "shuffle :: StdGen g => g -> [a] -> [a]"?
05:35:57 <BitPuffin> if I map (*) over a list and * looks like a -> b -> c will the lists become a or b?
05:36:14 <merijn> BitPuffin: "map (*)" returns a list of functions
05:36:19 <merijn> :t map (*)
05:36:20 <lambdabot> Num a => [a] -> [a -> a]
05:36:20 <quchen> BitPuffin: It will become a list of [b -> c].
05:36:31 <merijn> :t map (*) [1..]
05:36:32 <lambdabot> (Enum a, Num a) => [a -> a]
05:36:54 <quchen> map (*) [1,2,3] = [(1*), (2*), (3*)]
05:37:13 <jtanguy> thanks Saizan for your answer
05:37:22 <BitPuffin> ah
05:37:23 <BitPuffin> thanks
05:37:41 <BitPuffin> is there a way to control which parameter it becomes?
05:37:47 <BitPuffin> I know it doesn't matter in this case
05:38:06 <BitPuffin> but what if I wanted it to be [(*1), (*2), (*3)]
05:38:15 <quchen> It's always the first. If you want something else, you'll have to use a lambda for example.
05:38:25 <quchen> Or flip.
05:38:44 <quchen> map (flip (*)) [1,2,3] = [(*1), (*2), (*3)]
05:38:55 <quchen> = map (\x y -> y * x) [1,2,3]
05:38:57 <BitPuffin> but what if it is more than 2 params?
05:39:06 <quchen> Lambda.
05:43:25 <ion> I wonder what the reason is for sqlType taking “Monad m => m a” instead of “a”? http://hackage.haskell.org/packages/archive/persistent/1.2.1/doc/html/Database-Persist-Sql.html#t:PersistFieldSql
05:43:40 <ion> or, say, Proxy a
05:44:30 <deggis> merijn: last time i borrowed shuffle implementation from http://www.haskell.org/haskellwiki/Random_shuffle
05:45:52 <Lethalman> what is Proxy?
05:46:09 <ion> > map snd . sortBy (comparing fst) . zip (randoms (mkStdGen 42) :: [Double]) $ words "foo bar baz quux narf poit hello world"
05:46:10 <lambdabot>   ["foo","narf","bar","baz","quux","world","hello","poit"]
05:46:32 <ion> @hackage tagged -- lethalman
05:46:32 <lambdabot> http://hackage.haskell.org/package/tagged -- lethalman
05:46:44 <Lethalman> ion, yes just looking at it
05:46:47 <Lethalman> but what's the reason?
05:47:43 <ion> It’s what you use when you want a value for only its type, and when you might not even have values to use. You’ll be using Proxy :: Proxy Foo instead of the nasty undefined :: Foo
05:47:53 <Saizan> ion: "m a", even
05:47:58 <Lethalman> mh
05:48:20 <Lethalman> so instead of having Monad m => m a you have Tagged t => t a ?
05:48:57 <ion> lethalman: Instead of “a” (where you might have to use undefined as the value) you have “Proxy a” (where you use Proxy as the value).
05:49:14 * Lethalman probably never encountered this case then
05:49:41 <ion> > floatRadix (undefined :: Double)
05:49:43 <lambdabot>   2
05:49:47 <ion> > floatRadix (undefined :: Float)
05:49:50 <lambdabot>   2
05:49:59 <jmcarthur_mobile> ion: proxy a >= Proxy a
05:50:30 <ion> In a more perfect world you could have floatDigits (Proxy :: Proxy Double)
05:56:06 <nominolo> chrisdone: pong
06:01:32 * hackagebot NetSNMP 0.3.0.4 - Bindings for net-snmp's C API for clients  http://hackage.haskell.org/package/NetSNMP-0.3.0.4 (PavloKerestey)
06:04:11 <chrisdone> nominolo: hey. i got kowey's help, i was trying to figure out the atto-lisp library, but i'm good now =)
06:04:51 <nominolo> chrisdone: yeah, I need to document that.  One of the Parser types is the one from attoparsec
06:06:32 * hackagebot llvm-general 3.3.0.1 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.0.1 (BenjaminScarlet)
06:06:34 * hackagebot llvm-general 3.2.0.3 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.0.3 (BenjaminScarlet)
06:19:59 <chrisdone> nominolo: indeed, that's exactly what had me confused
06:31:33 * hackagebot github-post-receive 0.1.0.0 - github web hooks server  http://hackage.haskell.org/package/github-post-receive-0.1.0.0 (ShoheiYasutake)
06:34:32 <elliott> ion: taking (Proxy a) is bad practice
06:34:38 <elliott> ion: since you can take (proxy a) instead
06:41:08 <startling> so what do profunctors have to do with this PRISM thing?
06:48:38 <saml> prism monad is monad transformer over nsa monads
06:50:49 <hiptobecubic> :)
06:51:15 <startling> (is this why edwardk is missing?)
06:53:14 <hiptobecubic> more like forgetful functor from constitutions
07:07:01 <Sculptor> yo
07:07:59 <yitz> hi Sculptor
07:08:09 <Sculptor> hi
07:16:57 <Nisstyre-laptop> is there a function for Text that does url encoding/decoding ?
07:17:12 <Nisstyre-laptop> I'd prefer not to convert to and from String for efficiency reasons
07:17:30 <Nisstyre> I did search Hoogle
07:19:51 <Desheng2> Are there really that many job opportunities programming Haskell outside of "best of the best" and comp sci professors?
07:20:36 <Nisstyre> Desheng2: at my current job we're using Haskell for the payment system
07:20:44 <Nisstyre> also I'm building an automated email system with it
07:21:25 <banister`sleep> has anyone here tried to implement haskell 'do' syntax in ruby?
07:22:14 <Nisstyre> banister`sleep: why?
07:22:24 <Nisstyre> does ruby have macros?
07:22:49 <banister`sleep> Nisstyre: no, but ruby has co-routines/fibers, i've seen a python implementation based on co-routines
07:23:20 <Nisstyre> banister`sleep: it's not really custom "syntax" is it?
07:23:20 <Nisstyre> neither languages have macros
07:23:32 <banister`sleep> Nisstyre: no, but it looks pretty close :)
07:23:39 <Nisstyre> also what do coroutines have to do with monads?
07:23:50 <banister`sleep> Nisstyre: let me link u the article, holdon
07:23:56 <Nisstyre> except for a specific monad
07:24:03 <Nisstyre> banister`sleep: I'm busy at
07:24:04 <Nisstyre> *atm
07:24:19 <Nisstyre> I'll read it later
07:24:23 <banister`sleep> Nisstyre: if you read this: https://www.fpcomplete.com/user/dpiponi/the-mother-of-all-monads
07:24:30 <acube> ContT is the mother of all monads :P
07:24:35 <banister`sleep> Nisstyre: it says that continuation monad is the mother of all monads
07:24:38 <acube> oops, just Cont
07:25:07 <banister`sleep> Nisstyre: and that it's therefore possible to do this stuff with either callc/fibers, at the end of the article it says you can theoretically get a nicer 'do' syntax with any language that has either of those (co-routines or callcc)
07:25:12 <supki> I'd rather see ruby do syntax in haskell
07:25:15 <Nisstyre> ok
07:25:21 <supki> all those $'s are annoying
07:25:25 <Nisstyre> brb coffee
07:25:59 <banister`sleep> Nisstyre: here, htis paragraph: http://cl.ly/image/031P2V1y1y27
07:27:00 <ksf> anyone know of a pretty printing library for tabular data?
07:27:12 <banister`sleep> if u click on the link at the end of that paragraph (which u can't as that's just a screenshot :P) it takes u to the python implementation of do syntax
07:29:09 <ksf> http://hackage.haskell.org/packages/archive/boxes/0.1.2/doc/html/Text-PrettyPrint-Boxes.html
07:29:46 <bartavelle> is there a kind of key-value store that is efficient under STM ? (two threads can modify values corresponding to distinct keys without blocking everything)
07:29:56 <bartavelle> (well not blocking, retrying)
07:30:12 <opqdonut> Map Key (STRef Value)
07:30:13 <Nisstyre> bartavelle: you mean like some kind of Map type you can share between threads?
07:30:19 <bartavelle> exactly
07:30:21 <opqdonut> if the keys are statically known, that is
07:30:21 <Nisstyre> what opqdonut said
07:30:42 <opqdonut> if not, things turn interesting
07:30:54 <bartavelle> well, things are interesting then
07:31:07 <Ke> so haskell STM is not implemented using global lock?
07:31:31 <Nisstyre> Ke: think of it like a database
07:32:00 <bartavelle> I expect such a map to have "retrying" on concurrent modification of the map structure, but behaving like " Map Key (STRef Value)" otherwise
07:32:03 <Ke> so rcu of some sort
07:34:20 <merijn> Ke:  It's implemented by computing the complete set of all TVar (transactional variables) that are read from and written too. The value at the start of a computation is stored, then at the end if the values didn't change since the start the result is committed
07:34:42 <merijn> Ke: If any of the TVars changed (i.e. some other transaction finished) the transaction is retried
07:35:01 <merijn> Ke: The documentation of Control.Concurrent.STM should have a link to the paper explaining the implementation
07:35:03 <opqdonut> STM with a global lock would kinda defeat the point of STM
07:35:21 <Ke> but you'd still have to lock for the check
07:35:28 <Ke> but nvm.
07:35:38 <merijn> Ke: Only the variables you're checking need to be locked
07:41:01 <HexSquid> Hi! I'm a beginner to Haskell and having a good time. Why do you folks use for testing?
07:41:22 <HexSquid> I mean what
07:41:35 <mauke> joke opportunity missed :-(
07:41:41 <luite> HexSquid: i usually use test-framework with hunit or quickcheck
07:41:50 <FreeFull> HexSquid: As in unit testing? Quickcheck is nice
07:41:54 <mauke> HexSquid: I use prove with a hacked-up haskell implementation of TAP
07:42:03 <HexSquid> Quickcheck? I"ll check it out
07:42:05 <mauke> which I should probably upload to hackage maybe?
07:42:14 <FreeFull> Lambdabot does quickcheck, I forget what the command was though
07:42:28 <HexSquid> Woah what is this, several helpful answers immediately?
07:42:31 <ion> freefull: It has been broken for a while.
07:42:41 <ion> hexsquid: I mostly use test-framework and QuickCheck.
07:42:47 <FreeFull> ion: Huh, I recall seeing it working not that long ago
07:43:00 <supki> HexSquid: I use hspec mostly
07:43:12 <ion> freefull: Perhaps elliott has fixed it recently, or something.
07:43:19 <ion> @check True
07:43:23 <lambdabot>   mueval-core: Time limit exceeded
07:43:25 <ion> @check True
07:43:26 <HexSquid> Amazing thanks folks!
07:43:29 <lambdabot>   mueval-core: Time limit exceeded
07:43:33 <ion> …
07:43:44 <elliott> @check True
07:43:49 <lambdabot>   mueval-core: Time limit exceeded
07:43:51 <ion> > myquickcheck True
07:43:53 <elliott> look, it works if you believe in it, ok.
07:43:54 <lambdabot>   mueval-core: Time limit exceeded
07:44:00 <ion> > myquickcheck (const True)
07:44:03 <lambdabot>   +++ OK, passed 100 tests.
07:44:03 <lambdabot>  "OK, passed 100 tests."
07:44:08 <elliott> what
07:44:16 <elliott> I hope that was just a fluke
07:44:19 <Hafydd> @check False
07:44:22 <lambdabot>   *** Failed! Falsifiable (after 1 test):
07:44:25 <FreeFull> :t myquickcheck
07:44:27 <lambdabot> Testable prop => prop -> String
07:44:47 <FreeFull> > myquickcheck (\x -> x == 2)
07:44:49 <ion> @check \(as :: String) bs -> reverse as ++ reverse bs == reverse (bs ++ as)
07:44:49 <lambdabot>  <unknown>.hs: 1: 17:ScopedTypeVariables is not enabled
07:44:52 <lambdabot>   mueval-core: Time limit exceeded
07:44:59 <ion> @check \as bs -> reverse as ++ reverse bs == reverse (bs ++ as :: String)
07:45:02 <lambdabot>   mueval-core: Time limit exceeded
07:45:07 <ion> D-:
07:45:13 <ion> halp
07:45:45 <FreeFull> HexSquid: That's just lambdabot not working, rather than anything wrong with Haskell
07:46:00 <FreeFull> > myquickcheck (const False)
07:46:04 <lambdabot>   *** Failed! Falsifiable (after 1 test):
07:46:04 <lambdabot>  ()
07:46:04 <lambdabot>  "Falsifiable, after 0 tests:\...
07:46:12 <Hafydd> Haskell has a bug
07:46:22 <FreeFull> Hafydd: Which is?
07:46:25 <ion> @faq Can Haskell be buggy?
07:46:25 <lambdabot> The answer is: Yes! Haskell can do that.
07:46:51 <FreeFull> Well, obviously we can't go full bug-free until we have full dependent typing with all the bells
07:46:58 <Hafydd> FreeFull: http://book.realworldhaskell.org/support/rwh-200.jpg
07:47:06 <mauke> enjoy your type-level bugs
07:47:36 <FreeFull> Hafydd: Yep, that's definitely an insect
07:48:14 <armlesshobo> @faq can Haskell correct itself?
07:48:14 <lambdabot> The answer is: Yes! Haskell can do that.
07:48:34 <FreeFull> Of course, nothing can truly stop a programmer from writing "white" instead of "write" inside a string literal
07:48:40 <FreeFull> @faq
07:48:40 <lambdabot> The answer is: Yes! Haskell can do that.
07:48:53 <YoureTheVest> FreeFull: Bugs are insects with sucking mouth parts.
07:49:58 <FreeFull> YoureTheVest: What's your source?
07:50:42 <FreeFull> Hmm, apparently Hemiptera are True Bugs
07:51:10 <YoureTheVest> FreeFull: QI originally, but from the wiki: "[True Bugs] share a common arrangement of sucking mouthparts"
07:51:47 <FreeFull> This means that house flies aren't true bugs
07:52:00 <FreeFull> Since they are in Diptera
07:55:00 <merijn> hmatrix is returning the extremely unhelpful error "linearSolveR: singular" when I try to show a Vector...
07:55:04 <merijn> Any clues?
07:55:59 <FreeFull> merijn: Does it even say it is an error?
07:56:20 <jeff_s1> Anybody had success using the latest regex-pcre-builtin?
07:56:48 <merijn> FreeFull: Well, my program terminates instead of producing output, so yes
07:57:06 <Ke> well is the matrix singular?
07:57:14 <merijn> If I remove the "show vector" it runs to completion with sane output, which leads me to believe that the Vector should be ok
07:57:15 <Ke> or close to singular?
07:57:49 <bscarlet> merijn: is the vector used elsewhere?
07:58:11 <Ke> laziness could hit you here?
07:58:44 <merijn> It should be a 2 element vector
07:58:48 <merijn> bscarlet: No
07:59:22 <bscarlet> merijn: if it's not used elsewhere, then laziness could mean the computation that produces it isn't being run if you don't show it.
07:59:55 <merijn> Oh, that's what you meant
08:00:00 <merijn> Yeah, it's used elsewhere
08:00:37 <YoureTheVest> merjin: how are you producing this vector? the error suggests you're inverting a matrix somewhere, perhaps to solve a system of equations.
08:00:39 <merijn> In fact, the exact same operation should be run if I don't show it
08:00:52 <bscarlet> merijn: Is the code small enough to share?
08:00:55 <merijn> YoureTheVest: I'm multiplying the vector with an inverted matrix
08:01:55 <merijn> chrisdone: You broke the hpaste announcer for me! :(
08:01:57 <merijn> http://hpaste.org/90360
08:02:14 <merijn> The offending line is line 35, with that removed it runs fine
08:02:58 <mauke> approxCoefficient new isn't used anywhere else
08:03:12 <merijn> mauke: No, but new is
08:03:31 <mauke> irrelevant
08:03:43 <merijn> mauke: the next iteration calls "approxCoefficient new", or should..
08:04:13 <Aetherspawn> :t liftM
08:04:14 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
08:06:01 <mauke> :t liftA
08:06:02 <lambdabot> Applicative f => (a -> b) -> f a -> f b
08:06:27 <merijn> mauke: updateApprox call "approxCoefficient" on the its input. Since updateApproxM is used in a foldM and calls updateApprox the result of updateApproxM should call approxCoefficient on the next call
08:06:41 <merijn> If it works on the next recursion, why does it fail here?
08:09:31 <bscarlet> merijn: can you use trace inside and outside the call to inv in approxCoefficient to see exactly what you're inverting and verify it's the inversion that fails?
08:11:36 <merijn> m is 2x2 and v is 2x1 (or is 1x2? always get that mixed up)
08:12:28 <YoureTheVest> merjin: 2x1 is fine. What's your input?
08:15:21 <merijn> ugh
08:15:24 <merijn> Stupid mistake
08:15:43 <merijn> I should only print the vector if c> order + 1
08:16:11 <merijn> Otherwise the matrix doesn't have enough information to solve the equation anyway
08:16:32 <merijn> And the initial value is singular
08:23:41 <banister`sleep> elliott: are you elliot cable?
08:25:00 <Luke> is there anything in haskell-mode emacs for visual debugging? I'm watching this presentation and this guy has it working for sublime text 2: https://vimeo.com/68669612
08:25:13 <elliott> banister`sleep: no, that would be ELLIOTTCABLE
08:25:15 <johnw> Luke: yes, you can use GUD in conjunction with ghci
08:25:18 <elliott> and conal elliott is conal
08:25:31 <Luke> johnw: oh I use gud with C++. it's the only way! thanks
08:25:32 <banister`sleep> elliott: ah :)
08:26:04 <Luke> johnw: can I just start GHCi via the `C-c l` binding and it'll work?
08:26:14 <johnw> Luke: see inferior-haskell-break, for example
08:26:22 <johnw> ah, no
08:26:23 <Luke> ty
08:26:24 <johnw> you use :break in ghci
08:26:27 <Luke> k
08:26:34 <johnw> i wrote this: https://gist.github.com/5850866
08:26:49 <Luke> is this in haskell-mode?
08:27:06 <johnw> it uses inf-haskell.el
08:27:09 <Aetherspawn> :t fromIntegral
08:27:10 <lambdabot> (Integral a, Num b) => a -> b
08:27:11 <johnw> whichi s part of haskell-mode
08:27:20 <johnw> I don't think GUD is involved, now that I think about it
08:27:24 <Luke> ah
08:27:24 <Aetherspawn> @hoogle Word32 -> Int
08:27:25 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
08:27:25 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
08:27:25 <lambdabot> Data.Generics.Schemes gsize :: Data a => a -> Int
08:28:10 <mauke> > sizeOf (1 :: Word32) :: Int
08:28:11 <lambdabot>   Not in scope: `sizeOf'
08:28:11 <lambdabot>  Perhaps you meant one of these:
08:28:11 <lambdabot>    `IM.size' (impor...
08:28:14 <mauke> aw
08:28:22 <mauke> > fromIntegral (1 :: Word32) :: Int
08:28:23 <lambdabot>   1
08:29:13 <Aetherspawn> +1 mauke
08:29:29 <elliott> johnw: hi
08:30:14 <mauke> Aetherspawn: "mauke++" is both shorter and actually does something :-)
08:30:56 <ion> @karma blah
08:30:57 <lambdabot> blah has a karma of 31337
08:31:22 <flebron> I'm profiling some code ( http://codepad.org/jwji3Sfj ), and GHC shows that a lot of time is being spent on "main". I'm told this is because main is the one forcing computations, so the time is attributed to it, but is being spent elsewhere. How can I know where to place !s or seqs in order to get a better picture of the time usage of my program?
08:35:20 <merijn> flebron: You might want to pastebin the profiling output too
08:35:56 <flebron> http://codepad.org/h09Tu7zh
08:36:24 <flebron> My suspicion is that factor' takes the most time (it factors integers).
08:37:10 <Aetherspawn> :t liftM9
08:37:10 <lambdabot>     Not in scope: `liftM9'
08:37:10 <lambdabot>     Perhaps you meant one of these:
08:37:10 <lambdabot>       `liftM' (imported from Control.Monad.Writer),
08:37:29 <Aetherspawn> bawh, too good to be true.
08:37:31 <mauke> Aetherspawn: at that point you probably want <*> instead
08:48:57 <Aetherspawn> get = NXHeader <$> get <*> get <*> get <*> get <*> get <*> get <*> get <*> get <*> get
08:49:06 <Aetherspawn> is there anything less retarded? There
08:49:13 <Aetherspawn> *There's 9 get's. Maybe there's a better way to write that.
08:52:58 <FreeFull> Aetherspawn: You could probably use template haskell or something
08:53:15 <Aetherspawn> well, thats a little overkill
08:54:06 <elliott> johnw: you use a local hoogle setup, right?
08:58:43 <jtanguy> Aetherspawn: which get do you have ?
08:58:54 <Aetherspawn> Data.Binary
08:59:02 <johnw> elliott: yes
08:59:24 <quicksilver> the simple haskell answer is that you can't abstract that apparently repeating pattern
08:59:35 <quicksilver> because it's not really repetition - they're different "gets"
08:59:44 <quicksilver> (unless all the fields are in fact the same type)
08:59:46 <elliott> johnw: do you have cabal-install set up to generate the database files, with the --haddock-hoogle option and so on?
09:00:01 <johnw> actually, no
09:00:07 <quicksilver> however, you can use a metaprogramming method to derive a 'get' like that
09:00:12 <johnw> i just run: hoogle data -r -l all
09:00:17 <quicksilver> (which might or might not use TH behind the scenes)
09:00:21 <johnw> it downloads all the current databases
09:00:30 <elliott> hmm
09:00:38 <elliott> doesn't that get you results from random packages that you don't have installed?
09:00:46 <johnw> oh yes, all of them
09:00:49 <Aetherspawn> quicksilver, they're all the same type of get
09:00:50 <applikative> Data.Binary is one of the places where suddenly idiom brackets look really good get = (| NXHeader get get get get get get get get get |)
09:00:51 <johnw> around ~4000 packages right now
09:01:43 <quicksilver> Aetherspawn: if they're all the same type then you can get them all at once with replicateM 9 get
09:01:52 <quicksilver> Aetherspawn: (disclaimer - I didn't count your gets)
09:01:59 <elliott> johnw: hrm, okay
09:02:08 <Aetherspawn> oh wow, thats cool
09:02:16 <johnw> elliott: it actually helps me with package discovery
09:02:16 <applikative> quicksilver: but how does he fmap NXHeader over them?
09:02:35 <quicksilver> indeed.
09:02:39 <elliott> johnw: I ask because I was trying to get cabal-install to generate the database files like this for my local use, but it's broken in a way that seemingly makes getting both local HTML documentation and hoogle databases impossible.
09:02:39 <quicksilver> depends which problem you're trying to solve
09:02:49 <quicksilver> the idiom brackets don't actualy get rid of the repetition
09:02:55 <quicksilver> they just make the <*> implicit
09:03:07 <applikative> quicksilver: no, just the <*> yes.
09:03:14 <elliott> johnw: I would prefer it source from my local packages so I could know it's using the right versions of packages and link to my local documentation :/
09:03:14 <johnw> elliott: ah, you need this I think: --haddock-hoogle --haddock-html --haddock-executables --haddock-internal --haddock-hyperlink-source
09:03:17 <johnw> i do use that too
09:03:28 <applikative> i was thinking more of the direct intelligibility or readablility
09:03:41 <Aetherspawn> Yeah replicateM gives me an array
09:03:50 <Aetherspawn> /s/array/list/
09:03:52 <fryguybob> Ke: I missed the STM conversation earlier, but I would add that STM with a global lock is not pointless.  The semantics are nice regardless of performance (especially the blocking and choice operations `retry` and `orElse`).
09:04:18 <elliott> johnw: hmm
09:04:30 <elliott> johnw: I did --haddock-hoogle --haddock-hyperlink-source -- perhaps the key is that you need to specify --haddock-html too
09:04:32 <applikative> fryguybob: hi.  you seem lost in STM -land these days ...
09:04:43 <elliott> johnw: ...do you actually find --haddock-executables useful?
09:04:53 <fryguybob> applikative: Such is the life of a grad student in the TM world.
09:05:15 <johnw> elliott: no, I just threw it on
09:05:20 <johnw> more info the better, I always say
09:05:36 <applikative> i thought i'd seen you;d become a student. are you going to make some massive improvement on ghcs implementation?
09:06:01 <fryguybob> applikative: There is room for improvement :D
09:06:37 * hackagebot snaplet-acid-state 0.2.3.2 - acid-state snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-acid-state-0.2.3.2 (DougBeardsley)
09:06:42 <elliott> johnw: well, you should add --haddock-tests too then, it has support for building those now!
09:07:31 <johnw> sweet!
09:07:47 <elliott> only in HEAD though
09:07:52 <applikative> fryguybob: well that's good. i've only lately really been learning about it properly, fiddling with s marlows concurrency primer
09:08:20 <elliott> johnw: I wonder if executable haddocks are built when GHC builds its documentation...?
09:12:29 <elliott> johnw: anyway, thanks for the info! this has been holding up my Haskell development for a day since bootstrapping cabal-install from HEAD is such a pain that I didn't want to have to do it more than necessary...
09:13:04 <johnw> sure thing, elliott
09:23:08 <mzaouar> If I have 1 function func1 that calls another func2 that does IO, does it need to return an IO Monad?
09:23:35 <mauke> no, but functions don't do IO
09:23:47 <mzaouar> please clarify
09:24:01 <mauke> an IO value is a description of actions to execute
09:24:07 <mauke> a function can build such a value
09:24:22 <mauke> but if that value is not incorporated into main, it will never be executed
09:24:49 <mzaouar> for example, func1 :: [String] -> String func1 = concat
09:25:05 <mauke> huh?
09:25:08 <mzaouar> and func2 :: IO [String]
09:25:11 <mzaouar> I'll paste bin!
09:25:23 <napping> then func1 func2 is simply a type error
09:25:59 <merijn> I'll take "What is fmap?" for 200, Alex.
09:26:34 <mzaouar> mauke http://pastebin.com/29CAnyJV
09:26:37 <mauke> The paste 29CAnyJV has been copied to http://hpaste.org/90361
09:26:46 <mzaouar> how to make func1 compatible with func2 ?
09:27:21 <mauke> missing 'func2 ='
09:27:23 <merijn> mzaouar: I think the type of func1 is wrong
09:27:25 <mauke> also, func2 is not a function
09:27:42 <mzaouar> should I wrap all my functions being called in IO?
09:27:57 <ion> What do you mean by that?
09:28:03 <mauke> main = do { strings <- func2; print (func1 strings) }
09:28:24 <mzaouar> make but func1 and func2 are used deep in my application..
09:28:25 <napping> does cabal-dev ghci work with -s?
09:28:31 <merijn> mzaouar: Well, it depends on what you want to do
09:28:39 <merijn> mzaouar: In your case you probably want fmap
09:28:47 <merijn> :t fmap
09:28:48 <mzaouar> do continue..
09:28:49 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:29:00 <mzaouar> I know fmap, but how do you use it with IO?
09:29:08 <merijn> mzaouar: IO is a Functor, so fmap for IO has type "(a -> b) -> IO a -> IO b"
09:29:14 <merijn> mzaouar: Yes, IO is a Functor too
09:29:19 <mzaouar> ah ok
09:29:25 <applikative> an IO value is a kind of action, an action like 'writing the letter 'a'' , which is something many people can do at different times; there's no reason to call it a description of action, since it would be action in that general sense that is described.
09:29:46 <startling> :t do continue
09:29:47 <lambdabot> Not in scope: `continue'
09:29:49 <startling> aw
09:29:58 <applikative> @hoogle continue
09:29:58 <lambdabot> Network.HTTP.Base Continue :: ResponseNextStep
09:29:58 <lambdabot> package continue
09:29:58 <lambdabot> package continued-fractions
09:30:03 <mzaouar> the number of bots on this channel is appalling
09:30:13 <startling> mzaouar, "1"?
09:30:14 <applikative> mzaouar: you can make another one.
09:30:31 <startling> oh I guess preflex is back
09:30:31 <applikative> mzaouar: actually as startling is pointing out, they are all commands for lambdabot
09:30:37 <mauke> I'm not a bot
09:30:43 <mzaouar> lol
09:30:47 <applikative> you would say that mauke
09:31:05 <ion> mauke: Please tell me more about I'm not a bot.
09:31:07 <applikative> oh yes when you repaste.  you are a bot
09:31:19 <mzaouar> so is there a way, to call IO functions, without having to do a "do" in main
09:31:22 <mzaouar> or anything similar
09:31:27 <applikative> mzaouar: yes,
09:31:32 <merijn> ion: And how does I'm not a bot make you feel?
09:31:34 <mzaouar> in a normal f :: String -> String ?
09:31:36 <applikative> mzaouar: main = interact reverse
09:31:39 <startling> mzaouar: myAction
09:31:45 <mauke> applikative: I'm a cyborg!
09:31:46 <ion> mzaouar: They aren’t functions unless they have -> in the type signature.
09:32:01 <applikative> mzaouar: if you have a String-> String function, you can make it main with interact
09:32:08 <mauke> mzaouar: 'do' doesn't execute IO actions
09:32:13 <mzaouar> mauke I know
09:32:15 <mzaouar> make I know
09:32:22 <mzaouar> sorry for autocorrect*
09:32:26 <ion> Good correction.
09:32:33 <startling> make: *** No rule to make target `I'.  Stop.
09:32:38 <kryft> I could not be made to know
09:32:39 <Aetherspawn> @pl (\x -> return . (runGet decodeHeader x)_
09:32:39 <lambdabot> (line 1, column 40):
09:32:39 <lambdabot> unexpected "_"
09:32:39 <lambdabot> expecting variable, "(", ".", "`", "!!", operator or ")"
09:32:41 <mzaouar> mauke: I understand, I'm going to research interact reverse
09:32:43 <Aetherspawn> @pl (\x -> return . (runGet decodeHeader x))
09:32:43 <lambdabot> (return .) . runGet decodeHeader
09:32:44 <applikative> if you have a Text->Text function youi can make it a main with Text.interact myfunction
09:33:12 <applikative> mzaouar: and in general do notation desugars into \x ->  and >> and >>= so you can write that explicitly, and so on
09:34:40 <socratesxd> guys, i'm sick of "parse error on input `='"
09:35:04 <startling> socratesxd: then stop writing code like that?
09:35:06 <socratesxd> i know it's about identation, but how can i know more about that?
09:35:13 <startling> oh
09:35:23 <elliott> perhaps hpaste some code you're seeing this error with?
09:35:25 <mauke> socratesxd: it could also be a missing )
09:36:13 <socratesxd> uh
09:36:14 <socratesxd> i see
09:36:21 <napping> socratesxd: everything there is to know about layout is here: http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
09:36:25 <socratesxd> http://hpaste.org/90362
09:36:39 <napping> and here http://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17800010.3
09:37:00 <geekosaur> why are the additional lines in your where clauses indented more?
09:37:08 <elliott> johnw: btw, do you have a good way of passing options to cabal install all the time? the best I've been able to come up with is using an alias and trying not to forget to use it :(
09:37:09 <mzaouar> can someone correct this, while keeping func1
09:37:16 <socratesxd> it's on line 16, 17 and 21
09:37:30 <napping> socratesxd: in particular, 10.3 defines very precisely how indentation is translated into explicit grouping with
09:37:34 <socratesxd> geekosaur, it seems that my editor does that
09:37:34 <geekosaur> yes, those are the misindented lines. why did you indent them that way?
09:37:34 <mzaouar> can someone correct this, while keeping func1's Type intact, and perform IO in func2?  http://hpaste.org/90363
09:37:40 <napping> { ; }, and then the rest of haskell syntax is defined in terms of that
09:37:42 <kamatsu> hi all
09:37:50 <kamatsu> i have a perhaps strange sounding question
09:38:23 <applikative> socratesxd: its tabs
09:38:24 <socratesxd> thanks, bye
09:38:27 <geekosaur> mzaouar, you can't. if you're using an IO function from func1 then it must be in IO
09:38:31 <kamatsu> i would like to have a concise way of finding out the second-largest number out of 4 numbers, without using a list (or any loop/recursion)
09:38:34 <xplat> *drum roll*
09:38:38 <socratesxd> applikative, i'm using spaces
09:38:50 <applikative> socratesxd: not when i cut and paste it.
09:38:58 <applikative> does hpaste turn them into tabs?
09:38:58 <merijn> kamatsu: use max?
09:39:01 <socratesxd> ok, i'll see now
09:39:06 <xplat> oh.  you can write a big fat case statement with guards.
09:39:12 <merijn> xplat: WHy bother?
09:39:16 <kamatsu> merijn: how to find the second-largest using max, without a huge blowout of if statements?
09:39:22 <merijn> oh
09:39:29 <merijn> No, you're screwed
09:39:44 <mzaouar> geekosaur: then let's say I have 15 functions chain-calling each other (func1 calls func2 calls func3 ..), and func10 performs IO, and func1 needs to use its result, I should wrap all the return values in IO ?
09:39:45 <merijn> Manually cover all cases using guards
09:39:52 <kamatsu> because Accelerate (haskell DSL for GPUs) doesn't have lists, and i can't think of another efficient way to do this..
09:40:03 <kamatsu> if I use an array, that'll be nested parallelism
09:40:08 <geekosaur> mzaouar, or find a way to rewrite it
09:40:15 <geekosaur> there are usually better ways to do that
09:40:22 <mzaouar> geekosaur that is very limiting no?
09:40:39 <mzaouar> geekosaur: I mean all your data structures will be rewritten to be wrapped in IO ?
09:40:46 <socratesxd> applikative, http://hpaste.org/90362
09:40:46 <elliott> no
09:40:51 <geekosaur> no, it's symptomatic of poor code
09:40:59 <elliott> you'll get used to writing things this way
09:41:01 <merijn> mzaouar: No, you just move the IO out of the data structure
09:41:02 <elliott> it's fundamental to how haskell does IO.
09:41:12 <geekosaur> design your code properly and you don't get that kind of nesting
09:41:18 <kamatsu> i was hoping for some funny numeric trick that would find the second largest using bitwise operators or number fu
09:41:18 <xplat> kamatsu: if you can find a good partial evaluator, you can write the obvious thing with sort and partial-evaluate it until the list disappears
09:41:19 <merijn> mzaouar: i.e. do all the getLine's in main and then just work on String's in func1 and func2
09:42:11 <socratesxd> applikative, now it's working: http://hpaste.org/90362
09:42:12 <socratesxd> thanks
09:42:18 <socratesxd> uh, by the way
09:42:30 <socratesxd> it's recommended to use spaces or tabs?
09:42:33 <mzaouar> merijn kk
09:42:33 <xplat> kamatsu: well, you can find the largest sum-of-two-things and then subtract the largest thing, but i'm not sure that will save work
09:42:34 <merijn> socratesxd: Spaces
09:42:46 <Aetherspawn> is Data.Binary lazy?
09:42:50 <xplat> socratesxd: use only spaces.  only only only.
09:43:04 <Aetherspawn> I know it operates on lazy bytestrings, but I'm not sure if runGet is lazy
09:43:21 <elliott> socratesxd: most people say spaces. if you use tabs you need to use extra caution.
09:43:39 <elliott> it isn't worth flamewarring about. but people will probably tell you to use spaces if you come in with an indentation error caused by tabs :)
09:43:42 <applikative> socratesxd: you shouldn't use tabs at all; later some real masters find a way
09:44:20 <applikative> elliott s attitude is correct but it turns out to be too complicated at the beginning.  Set you editor to make spaces for tabs, whatever that sort of setting is called
09:44:28 <kamatsu> xplat: ah, but then if two of the numbers are the same, both the maximum
09:44:35 <socratesxd> ok, thanks
09:44:39 <kamatsu> then it won't be the second-highest but the highest
09:44:42 <xplat> kamatsu: if it was 3 things, you could find the max and the min and subtract them from the total
09:45:09 <xplat> kamatsu: then the highest is also the second-highest.  what do you plan to do if all 4 are the same?
09:45:35 <kamatsu> xplat: if that has happened, my program will already abort.
09:46:47 <xplat> kamatsu: yeah at this point i think you're down to the case approach.
09:47:46 <kamatsu> ok, well, oh well.
09:55:49 <Fifo__> lambdabot: reverse "lambdabot"
09:56:33 <elliott> > reverse "lambdabot"
09:56:36 <lambdabot>   "tobadbmal"
09:56:48 <Fifo__> > reverse "lambdabot"
09:56:50 <lambdabot>   "tobadbmal"
09:57:03 <tromp_> mal is french for bad:)
09:57:50 <Fifo__> elliott: Thanks for correcting me
09:59:03 <elliott> :)
09:59:42 <Fifo__> > let var = expressíon in body
09:59:43 <lambdabot>   Not in scope: `expressíon'Not in scope: `body'
09:59:49 <applikative> Fifo__: as people point out, you can do /query lambdabot fwiw
10:00:08 <applikative> > let var = 3 in var + var
10:00:09 <lambdabot>   6
10:00:18 <Fifo__> applikative: Thanks for reminding me.
10:00:36 <applikative> Fifo__: a let expression needs to have a correlative 'in' for lambdabot one-liners
10:00:57 <applikative> Fifo__: usually people are objecting to peoples' use of it in here, but i wasn't
10:01:02 <Fifo__> applikative: Ok.
10:02:51 <plhk> i want to export some function from haskell to c, any examples of setting up cabal for that?
10:03:51 <plhk> http://www.haskell.org/haskellwiki/Calling_Haskell_from_C <- i read this, but compilation is done manually here
10:09:21 <johnw> are you saying you want to use Haskell, but create a C library for other C code to link to?
10:09:26 <merijn> plhk: You don't really need to set up anything in cabal, just pass the right linker flags
10:09:45 <plhk> johnw: yes
10:10:25 <merijn> I think just "foreign export" should be enough
10:10:40 <merijn> Lemme check, I have an example lying around I was playing with
10:11:23 <merijn> plhk: As far as I can see you just need to have the foreign exports and that should be it
10:11:24 <plhk> merijn: the page i linked says i need _stub.c _stub.o and stub.h files
10:11:39 <merijn> plhk: Those are generated by ghc when you compile a file with foreign exports
10:12:05 <plhk> yes
10:13:23 <merijn> plhk: There's not much else to do, beyond turning the compiled .o into a static or dynamic library or passing them directly along to the C compiler
10:14:55 <merijn> plhk: I think you just need to add these flags to your ghc-options in .cabal: -dynamic -shared -fPIC
10:15:06 <applikative> hm when you call haskell from C it is typical for ghc then to compile the C as well, I guess calling gcc?
10:15:16 <merijn> applikative: Yes
10:15:41 <merijn> applikative: In fact, the newest cabal supports C files in Main-Is: !
10:15:57 <applikative> oh I see, nice.
10:16:39 <merijn> applikative: There's also the C-Sources and related cabal field for actually building the relevant cbits
10:16:40 * hackagebot hx 0.4 - Haskell extras (missing utility functions).  http://hackage.haskell.org/package/hx-0.4 (JulianFleischer)
10:16:41 <applikative> i'm really tripping on the cabal sandbox in the next version
10:17:04 <merijn> applikative: You can already upgrade to 1.17 without problems
10:17:05 <applikative> I just haven't thought about the other direction of the FFI
10:17:26 <merijn> applikative: I've been using 1.17 for a couple of weeks now
10:17:30 <applikative> yeah i'm using it too
10:18:24 <applikative> somehow now that it's integrated into cabal i am figuring out how to 'sandbox' and then also stuff I should have understood better before.
10:19:22 <plhk> i want C proxy to be a part of my cabal package
10:19:47 <plhk> i put c-sources: /path/to/my/file.c it tries to build it but cannot find stubs
10:20:30 <merijn> Are you trying to manually pass the stubs files to cabal?
10:20:50 <merijn> You don't have to
10:21:07 <applikative> I wonder if there's an example of what plhk wants around.  ...
10:21:43 <plhk> i just have "foreign export ccall ..." in my .hs file and i can see in dist/build/... that stubs are generated
10:21:48 <merijn> applikative: I have something like that, but it's unpublished and I don't feel like publishing it yet and cleaning it up enough is to much work to do now
10:21:56 <merijn> plhk: That's all you should need
10:22:57 <plhk> but when cabal builds c files it can't find them
10:23:07 <merijn> Which C files?
10:23:28 <merijn> You haven't mentioned any C files yet
10:23:52 <merijn> plhk: Do you have any files with C code that you wrote by hand?
10:24:00 <plhk> plhk | i put c-sources: /path/to/my/file.c it tries to build it but cannot find stubs
10:24:04 <plhk> i did ^
10:24:10 <plhk> merijn: yes
10:24:34 <merijn> plhk: Can you pastebin the entire output of cabal and your cabal file on hpaste?
10:24:43 <plhk> ok
10:27:55 <plhk> http://hpaste.org/90366
10:29:37 <Luke> chrisdone: why isn't haskell-mode in elpa?
10:30:19 <merijn> plhk: oh!
10:31:29 <merijn> plhk: And there is an FFI_stub.h in src/Data/Binary/Format/DWG ?
10:32:33 <plhk> no. there's one in dist/build/Data/Binary/Format/DWG
10:32:41 <merijn> hmm
10:32:53 <merijn> Pretty sure cabal should be including that by default...
10:33:07 <merijn> Can you hpaste call.c?
10:33:21 <plhk> sure
10:34:42 <plhk> http://hpaste.org/90367 it's copy-pasted from the example on the wiki
10:35:17 <plhk> i should try with <FFI_stub.h>
10:36:29 <merijn> plhk: oh, not directly related
10:36:39 * hackagebot acid-state 0.11.0 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.11.0 (DavidHimmelstrup)
10:36:43 <merijn> This is wrong: "extern void __stginit_Safe(void);"
10:36:59 <merijn> It expects "extern void __stginit_<modulename>(void);"
10:37:08 <plhk> oops
10:37:13 <merijn> so "__stginit_FFI(void);" for you
10:37:45 <plhk> fixed
10:38:14 <plhk> is there some flag to cabal to show commands it's executing?
10:38:56 <plhk> yeah, --verbose
10:40:04 <plhk> http://hpaste.org/90368
10:40:36 <merijn> Really odd
10:41:11 <merijn> I'm trying to figure out what's different in your code from mine
10:43:11 <merijn> plhk: Try "cabal build -v3"?
10:43:20 <merijn> I'm curious how it's calling your compiler
10:43:51 <merijn> plhk: Oh, btw
10:43:57 <merijn> I just realised something
10:44:06 <merijn> Your C code is mostly unnecessary
10:44:22 <merijn> Or rather
10:44:39 <merijn> Did you want to call C from haskell or have a C program that calls haskell library calls?
10:45:11 <merijn> I have to run now, so can't help further. But it looks odd, seems to me it should work
10:45:19 <plhk> C program that calls haskell library calls
10:45:34 <plhk> http://hpaste.org/90369
10:46:26 <plhk> '-I' 'dist/build'
10:47:34 <plhk> i changed my include to #include "Data/Binary/Format/DWG/FFI_stub.h" and it compiles now
10:48:24 <plhk> merijn: thanks for your help
10:52:35 <jjohnsson> I'm trying to learn how to use the mersenne-random package and have just produced some ugly code, where some random numbers are created at each loop. Can anyone comment on how to improve on this code, and say if I'm on the "right track"? I intend to write some simple Monte Carlo code.
10:53:03 <jjohnsson> http://hpaste.org/90370
10:53:47 <startling> jjohnsson: that's not so ugly
10:54:13 <jjohnsson> there is one too much "loop", I think.
10:54:13 <jjohnsson> maybe?
10:54:32 <startling> nah
10:55:05 <jjohnsson> okay. I figured it might be possible to split it into one initialization function and one loop function, but it seems to be hard due to IO.
10:57:07 <jjohnsson> Also, in ghci I can only run the "run" function once, apparently because the rng can only be initialized once. So I need to quit and restart ghci for each test of the run function, which is kind of annoying.
10:57:08 <startling> jjohnsson, well, you could do "forever $ do ..." but that way often turns out inflexible
10:57:16 <Gracenotes> hm, no way to use the generator purely? tis a shame...
10:57:38 <jjohnsson> There is a pure mersenne package as well, but it seems to work slightly differently.
10:58:10 <jjohnsson> I don't know if it would be possible to easily switch between the two.
10:58:35 <Gracenotes> if you're doing anything Monte Carlo, I expect speed will help improve your algorithm the most, so purity isn't necessarily a virtue here...
10:58:58 <flebron> I'm profiling some code ( http://codepad.org/jwji3Sfj ), and GHC shows that a lot of time is being spent on "main". I'm told this is because main is the one forcing computations, so the time is attributed to it, but is being spent elsewhere. How can I know where to place !s or seqs in order to get a better picture of the time usage of my program? Profiling data: http://codepad.org/h09Tu7zh . I suspect most time is spent in factor'.
10:59:37 <jjohnsson> Yes, I would like to have some decent speed.
10:59:47 <Gracenotes> at least for the numerical bit, C can often do better; for discrete stuff, Haskell does quite well too
11:00:45 <Gracenotes> but fine tuned code in either can usually be untuned in the other. ...yeah
11:00:54 <jjohnsson> I know I can get better speed in other languages (C, Fortran comes to mind), but I'd like to experiment a bit with Haskell. I find it very interesting.
11:01:13 <Gracenotes> 'randoms' might work as well
11:01:48 <Gracenotes> once you execute the IO action, you can access the list as if it were pure. perhaps cheating a little bit.
11:02:11 <jjohnsson> Ah. Is that possible? I need to try.
11:02:51 <Gracenotes> it does use unsafe operations under the cover, but only because it knows they are in fact safe.
11:02:55 <jjohnsson> But... do I need to pattern match on that list, then, to pick out numbers from it?
11:03:46 <bscarlet> jjohnsson - or map over it
11:03:49 <Gracenotes> jjohnsson: well, the list is something you pass around and consume as you go
11:03:57 <carter> bscarlet Hello!
11:04:16 <Gracenotes> cons pattern matching can't fail, as well, because it's an infinite list
11:04:20 <carter> bscarlet btw: theres now a #haskell-llvm channel :)
11:04:34 <bscarlet> carter: really...
11:04:50 <jjohnsson> I am thinking now of picking random numbers from it, as in my hpaste.
11:05:06 <carter> well, i created it yesterday since otherwise I chat with Ralith  on the # idris channel
11:05:13 <Gracenotes> is random the only reason you need IO?
11:05:41 <jjohnsson> I think so, except for writing out the results.
11:05:43 <flebron> Ah nice, the solution was to compile with -threaded!
11:06:34 <Ralith> jjohnsson: I haven't been following, but if you need random numbers without IO, you should use
11:06:37 <Ralith> @hackage random-fu
11:06:38 <lambdabot> http://hackage.haskell.org/package/random-fu
11:06:48 <Gracenotes> as a general principle, try to use as little IO as possible in the logic of whatever you're simulating. to be honest, this is an abstraction problem that Monads can help solve.
11:07:05 <jjohnsson> Ralith: looking into it.
11:07:51 <jjohnsson> Gracenotes: yes, that is already my plan, and it sounds like a good idea.
11:08:03 <Gracenotes> er... but... it depends on your exact performance/abstraction needs, as far as structuring a program that does everything
11:08:52 <Gracenotes> the reason I suggest monads is because you can define your own, and the user of the monad doesn't need to know if the random numbers come from IO or from a pure implementation.
11:09:03 <Gracenotes> sky is the limit, in any case
11:09:30 <Ralith> IO shouldn't be used for random numbers regardless, unless you're relying on an external RNG
11:09:31 <jjohnsson> okay. hm.
11:09:47 <Ralith> if mutation is needed for performance you can use ST
11:09:58 <jjohnsson> Seems like you never get away from the performance vs. abstraction priorities. :(
11:10:19 <Ralith> I'm not sure what gives you that idea
11:10:24 <Gracenotes> well, that's where a massive amount of bugs come from in imperative languages
11:10:48 <jjohnsson> My experience of writing code.
11:11:04 <Gracenotes> once you have mutation, you have many arbitrary state combinations you didn't intend, and all it takes is an assignment operator.
11:11:08 <monochrom> concerning performance and (and!) abstraction, I have a true story, it happened right in this channel
11:11:42 <Gracenotes> Haskell manages to actually be very efficient in most cases, including doing arithmetic, and there's usually not a huge difference between code that performs okay and code that performs great.
11:11:45 <jjohnsson> monochrom: I'm all ears.
11:12:28 <monochrom> someone looped over randomRIO, and found it slow. I suggested (out of mere elegance): just use IO to get the seed once, henceforth use randomRs and loop over that list instead. it was very fast.
11:13:13 <monochrom> this is because randomRIO is a lot of readIORef and writeIORef. that can't be fast.
11:13:33 <jjohnsson> monochrom: sounds good. :) It always makes me happy when you don't need to prioritize.
11:13:46 <Gracenotes> the mersenne-twister library is just a wrapper around a C library, I believe
11:13:52 <jjohnsson> Anyway, I think I will just go on write some code, and then try different approaches.
11:13:55 <notdan> Is there something like 'show' but for Text instead of String?
11:14:18 <jjohnsson> I always tend to think too much and get nothing done.
11:14:41 <jjohnsson> Thank you all for your excellent feedback. :)
11:14:58 <johnw> notdan: pack . show
11:14:59 <monochrom> notdan: I think no. I guess (pack . show)
11:15:20 <johnw> notdan: otherwise, everyone would have to implement a new ShowText type class or some such
11:17:48 <notdan> Well yeah
11:22:11 <elliott> does anyone know if it's possible to get the cabal sandboxing stuff to look at local db as well as global for dependencies?
11:23:17 <monochrom> I think it already does? at least that's how it finds base.
11:24:33 <elliott> monochrom: no, it finds base from the global db
11:24:39 <elliott> i.e. /usr yes, ~/.ghc no
11:24:51 <monochrom> hrm! then I don't know
11:36:04 <chrisdotcode_> so guys, does haskell code scale with the amount of cores you have?
11:36:15 <chrisdotcode_> I know erlang does, but does haskell?
11:36:26 <johnw> chrisdotcode_: not automatically, if that's what you mean
11:36:28 <elliott> if you write it to
11:36:31 <flebron> man dependent types would be so cool for this. i wanted to create the type (Z/nZ)[X]/<x^2-x-1>, which is (Z/nZ)[sqrt(5)], but n is a parameter, so I can't make it a proper type :(
11:36:33 <elliott> same goes for erlang
11:36:40 <johnw> but it is quite easy to write parallel or concurrent code
11:36:41 <elliott> flebron: you can with the reflection package!
11:36:58 <chrisdotcode_> johnw, elliott: what do you guys mean? I've heard fantastic myths of just adding --threaded and it scales.
11:37:09 <flebron> how old is that package? (as in, can ghc 6.10 use it?)
11:37:10 <chrisdotcode_> how do you write code for multi-cores/threads?
11:37:16 <elliott> chrisdotcode_: that is a myth unless the library you use does automatic parallelisation (like repa)
11:37:22 <elliott> I mean, certainly libraries might do parallel stuff under the hood
11:37:30 <elliott> but don't expect your own code to become parallelised unless you actually write it that way
11:37:40 <elliott> take a look at the "parallel" package, the strategies module
11:38:09 <johnw> also, monad-par, orc, async, and a few more
11:38:33 <johnw> chrisdotcode_: but no, it's not just a matter of adding -threaded to the build
11:38:37 <chrisdotcode_> so you can't write code in a single-threaded way and have it scale "automatically"?
11:38:42 <johnw> no
11:38:48 <johnw> parallelism involves making decisions
11:39:06 <johnw> otherwise, you can too easy lose all your gains in overhead
11:39:17 <monochrom> -threaded is necessary. but you also have to be explicit about par
11:39:44 <monochrom> the alternative is to invent a static analysis that tells you where to put those par's
11:40:14 <monochrom> on the bright side, if you succeed in that alternative, you may very well get an ACM Turing Award
11:40:18 <chrisdotcode_> monochrom: I wanted to avoid explicitly coding for parallelism. like node has callback, so parallelism is explictly visible. I was hoping that it would be invisible in haskell...
11:40:21 <johnw> lol
11:40:46 <johnw> chrisdotcode_: parallelism is still pretty darn cheap, code-wise, compared to many other languages
11:41:10 <chrisdotcode_> johnw: what does explict parallelism look like in good ole' haskell?
11:42:33 * hackagebot markdown 0.1.3 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.3 (MichaelSnoyman)
11:42:33 * hackagebot java-bridge 0.99 - Bindings to the JNI and a high level interface generator.  http://hackage.haskell.org/package/java-bridge-0.99 (JulianFleischer)
11:42:48 <johnw> do { x <- async f; y <- g; (+) <$> (wait =<< async f) <*> g }
11:42:56 <johnw> that will compute f and g concurrently
11:43:06 <johnw> drop the "y <- g; " part
11:43:15 <johnw> do { x <- async f; (+) <$> (wait =<< async f) <*> g }
11:43:23 <johnw> (+) <$> (wait =<< async f) <*> g
11:43:24 <johnw> sorry
11:43:48 <johnw> that may not be concurrent at all
11:43:51 <johnw> let me look for a real example
11:44:03 <elliott> eh
11:44:11 <elliott> I think strategies are a better adveritsement of parallelism
11:44:14 <elliott> since you can keep a pure functional style
11:44:15 <johnw> true
11:44:26 <elliott> stuff like parMap is very simple to just drop in
11:44:48 <elliott> monochrom: ...in particular, it seems like cabal's sandboxing interacts badly with your advice to add "constraint: foo installed" to "foo"s that you install -- if "foo" is installed to your local package database, then in the sandbox it'll complain about not being able to install "foo" because it demands the installed version, but it can't find it :/
11:45:14 <elliott> chrisdotcode_: btw, keep in mind that parallelism and concurrency are two different things.
11:45:31 <johnw> map f [1..10000] vs. parMap f [1..10000]
11:45:36 <monochrom> hrm, that will be a problem
11:45:44 <johnw> however, parMap doesn't give you control over granularity
11:45:46 <chrisdotcode_> elliott: yeah, I"m familar with that distinction
11:45:50 <chrisdotcode_> what are strategies?
11:45:54 <johnw> map f [1..10000] vs. map f [1..10000] `using` parListChunk 100
11:45:57 <monochrom> so cabal sandboxing completely ignores --user?
11:46:11 <johnw> chrisdotcode_: strategies what occur to the right of that `using` I just used
11:46:25 <johnw> in this case, the parListChunk strategies computes chunks of N size in parallel
11:46:29 <monochrom> or is it rather re-defining --user?
11:46:35 <johnw> there are also WHNF strategies, deepseq strategies, etc.
11:47:09 <chrisdotcode_> it's a shame, I'd like my code to be clean, and automatically scale...
11:47:28 <chrisdotcode_> monochrom: ...tell me more about what that static analyzer would have to do, again?
11:47:30 <johnw> chrisdotcode_: you can often just hide parallelism behind your interface
11:47:42 <johnw> chrisdotcode_: that way, user code just magically speeds up when built with -threaded
11:47:50 <chrisdotcode_> johnw: how do you mean?
11:48:00 <johnw> no one needs to know you use parMap instead of map in your library
11:48:04 <johnw> that's the whole point of parallelism in Haskell
11:48:10 <elliott> monochrom: not sure
11:48:24 <johnw> referential transparency guarantees that the meaning of a parallel program is unchanged from the meaning of a corresponding sequental program
11:48:35 <elliott> chrisdotcode_: note that there is no silver bullet
11:48:46 <johnw> so, you can "build in" parallelism, which only gets "turned on" when built with -threaded
11:49:00 <johnw> maybe this is what those blogs you were reading were referring to
11:49:05 <Luke> hvr: thanks for the elpa bug
11:49:27 <Luke> oh i guess that was tibbe
11:49:32 <chrisdotcode_> johnw: right, but I was saying that I wish map and friends automatically were turned into parMap when using --threaded
11:49:45 <johnw> chrisdotcode_: that's not even a good idea, actually
11:49:51 <chrisdotcode_> it's not?
11:49:52 <johnw> takes map f [1..1000000] for example
11:49:56 <johnw> what if f is really cheap
11:50:01 <chrisdotcode_> isn't that what monochrom's static analyzer would do?
11:50:15 <johnw> creating 1,000,000 threads, even if they are super-lightweight, would be a lot more expensive than just calling f a million times
11:50:32 <johnw> chrisdotcode_: yeah, but like he said, if you solve that problem there are many people who will bow at your feet
11:50:46 <Gracenotes> we don't exactly have JIT, do we
11:51:17 <Gracenotes> but for optimizing serialization, rather than for optimizing interpretation
11:51:39 <thoughtpolice> you can get certain kinds of automatic parallelism with some libraries, but in general it's a pretty difficult problem. Simon has a paper from a while back about doinog feedback-directed ('profile guided') implicit parallelism
11:51:42 * hackagebot java-bridge-extras 0.99 - Utilities for working with the java-bridge package.  http://hackage.haskell.org/package/java-bridge-extras-0.99 (JulianFleischer)
11:52:19 <thoughtpolice> i think the TL;DR was it worked OK, but not enough to really justify inclusion and long term maintenance
11:52:24 <chrisdotcode_> so eventually I *will* have to replace my maps with parMaps, and I'm going to have to learn optimization techniques, huhu?
11:52:40 <chrisdotcode_> s/huhu/huh/
11:52:47 <johnw> yeah
11:52:56 <johnw> but usually it will just be a few very well-placed parMaps
11:53:02 <johnw> and you have the threadscope utility to help guide you
11:53:11 <elliott> thoughtpolice: it seems like it would be really nice in a JITting scenario
11:53:35 <elliott> that's the only way I could see "automatic parallelisation" taking off
11:54:31 * thoughtpolice wants a JIT
11:55:02 <elliott> yes, a haskell JIT with a lot of effort put into it would be really great.
11:56:32 <xplat> that would probably eventually be better than a simple type-forgetting translation of GHC core to lua
11:56:42 * hackagebot java-reflect 0.99 - Tools for reflecting on Java classes.  http://hackage.haskell.org/package/java-reflect-0.99 (JulianFleischer)
11:56:44 * hackagebot j2hs 0.99 - j2hs  http://hackage.haskell.org/package/j2hs-0.99 (JulianFleischer)
11:57:17 <xplat> what is all this java-bridging activity?
11:57:22 <thoughtpolice> i'd like to see if GHCi could go this route since it can already interact with compiled code, do dynamic loading, etc. i'm not sure anybody has ever really thought about it in that setting
11:57:48 <elliott> xplat: haha, someone should try core -> luajit
11:57:54 <elliott> or maybe stg or cmm -> luajit would be better
11:58:00 <johnw> LLVM has a JIT, does it not?
11:58:07 <johnw> hook up -fllvm to that
11:58:09 <elliott> I bet you could get something going in a weekend
11:58:20 <thoughtpolice> luajit is pretty heavily based on optimizing 'human' code, it has a lot of heuristics to deal with that kinda stuff. but it would probably work
11:58:31 <elliott> johnw: not the kind of tracing JIT we're wishing for, I think
11:58:46 <thoughtpolice> johnw: not really. GHC and LLVM's optimizers are too heavy and slow anyway, probably
11:58:57 <thoughtpolice> ideally you want a JIT to be memory efficient and fast. GHC and LLVM are neither :P
11:59:05 <johnw> i tried hooking up the LLVM JIT to Emacs at one point, to speed up Emacs Lisp
11:59:21 <johnw> I didn't find it particularly slow then
12:00:33 <thoughtpolice> yes, but in the case of GHC you have to go through a substantial amount of work to get to LLVM in the first place, and if you want re-optimization over time that will probably cost you in the current compilation model
12:01:00 <johnw> true
12:01:52 <thoughtpolice> it also seems a bit square-peg-round-hole to just completely take the existing Core -> STG -> CMM -> LLVM backend and just rig that with an ExecutionEngine, instead of writing to a file. it would work probably, i dunno how flexible or long-term it is
12:02:26 <elliott> yeah I don't think GHC's backend would be helpful for this kind of thing
12:02:27 <thoughtpolice> ideally i think i'd like to see GHCi become something like a JIT... it has bytecode, dynamic linking, an interpreter, etc. it has a lot of the characteristics already
12:02:32 <elliott> but the frontend could probably be reused
12:02:43 <nan`> hm, my cabal initted library build is expecting a main method
12:03:08 <johnw> is there a place for discussing how HoTT might affect languages like Haskell in future?
12:04:06 <xplat> johnw: possibly several places
12:04:18 <johnw> #agda?
12:04:46 <xplat> johnw: that could be one, since people there by and large know what HoTT is ...
12:04:47 <johnw> i started to read the book last night, and it seemed like some rather exciting potential to me
12:05:24 <johnw> I tired to imagine a toroid type in Haskell: data Toroid a = Toroid a (a -> a) (a -> a) ((a,a) -> (a,a)), or something like that
12:05:50 <thoughtpolice> i got through most of Chapter 1 last night, but reading PDFs is so painful sometimes
12:05:54 <joelteon> does this error look familiar to anyone http://hpaste.org/90371
12:06:03 <johnw> thoughtpolice: that is the #1 reason why I love the iPad
12:06:07 <johnw> it makes reading PDFs comfortable
12:06:11 <joelteon> "_utf8_table3" doesn't return any google results for me
12:06:29 <xplat> johnw: i think you'd probably want to use GADTSyntax for HITs
12:06:32 <thoughtpolice> i should put it on my ipad, yeah. it substantially helps, i've been reading lots of physical books lately so i haven't thought about it much
12:06:33 <johnw> joelteon: i'd start using nm and ldd if I were you
12:06:57 <johnw> thoughtpolice: GoodReader is an excellent reader
12:07:07 <thoughtpolice> probably haven't read anything on it in a few months now
12:07:10 <johnw> and the HoTT-online version renders best, imho
12:07:13 <shachaf> ExcellentReader, however, is merely good.
12:07:18 <johnw> shachaf: lol
12:07:26 <thoughtpolice> lol
12:07:41 <thoughtpolice> johnw: oh, interesting. i normally just use Dropbox or whatever and keep my PDFs in there
12:07:56 <johnw> the Dropbox app is an uninspiring reader
12:08:03 <hvr> Luke: what are you referring to? :)
12:08:08 <Luke> nm nm
12:08:20 <johnw> for reading Haskell articles, I like that GoodReader lets you set a "crop window", and further restrict scrolling to the vertical axis only.  Once I have that setup, reading is a great experience
12:08:24 <xplat> shachaf: it's good, but there's no way of telling why it's good?
12:08:50 <johnw> thoughtpolice: GoodReader also integrates with Dropbox,b tw
12:08:59 <joelteon> johnw, OSX doesn't have ldd
12:09:05 <johnw> joelteon: otool -L
12:09:08 <shachaf> xplat: I think you have to read past Chapter 1 to follow that!
12:09:21 <johnw> thoughtpolice: if you want further tips on configuring the iPad for best reading bliss, just /msg me
12:09:44 <hvr> Luke: btw, did you see https://github.com/haskell/haskell-mode/commit/517fd7ed912cd263e26c9c12547a898efa252206 ?
12:10:00 <joelteon> johnw: heh, no output
12:10:06 <joelteon> except <filename>:
12:10:08 <joelteon> and then a blank line
12:10:12 <johnw> joelteon: otool -L <path to .dylib or exe>
12:10:39 <johnw> your pastie suggested it was trying to link against a .dylib but wasn't finding a symbol exported
12:11:00 <johnw> as though your headers were mismatched with your binaries
12:11:01 <joelteon> yeah, that .o file doesn't show anything with otool
12:11:07 <johnw> otool is not for .o's
12:11:08 <johnw> use nm
12:11:34 <johnw> (I think you can actually use otool with .o's, but I don't normally)
12:11:36 <joelteon> ok, yeah
12:11:45 <joelteon> I see _utf8_table3 in a section with U in front of it
12:11:51 <johnw> yes, that's the reference
12:11:55 <johnw> you need to track down one with a "T"
12:12:19 <johnw> like this: nm -o /usr/lib/* | grep utf8_table
12:12:57 <joelteon> there are some __pcre_utf8_table* in /usr/lib/libpcre.dylib
12:13:02 <johnw> aha
12:13:03 <joelteon> why would it be looking in /usr/lib though
12:13:11 <johnw> the global pcre looks like it was built with a prefix
12:13:12 <joelteon> oh
12:13:16 <joelteon> because I told it to look in /usr/lib
12:13:26 <johnw> i think that's a configure-time option to the PCRE lib
12:13:35 <joelteon> same for /usr/local though
12:13:47 <joelteon> ok so why is this failing for regex-pcre-builtin?
12:13:49 <joelteon> if it's /built in/
12:15:25 <johnw> so, the question is, why is the .o you're building not using a prefix
12:15:36 <joelteon> yeah that's a good qusetion
12:15:49 <johnw> plus, __pcre_utf8_table3 over here is a "s"
12:15:58 <joelteon> i have both
12:16:00 <joelteon> U and s
12:16:11 <johnw> yeah, U is undefined, an external reference
12:16:26 <johnw> man nm says that "s" means it's in an Objective C section?
12:16:31 <johnw> odd
12:16:56 <johnw> i'll try to install regex-pcre-builtin here
12:17:10 <joelteon> why would it not use a prefix, yeah
12:17:13 <joelteon> that is confusing
12:17:20 <johnw> it worked here
12:17:29 <johnw> can you show me the output from cabal install -v?
12:17:51 <joelteon> yeah hang on
12:19:31 <joelteon> https://gist.github.com/anonymous/893139ba750df540c85e
12:19:33 <aristid> johnw: is it possible that you might have switched to hledger yourself? :D
12:21:13 <johnw> aristid: no, why do you ask?
12:21:27 <johnw> heldger is missing the value expression machinery that I rely on so heavily
12:21:43 <aristid> johnw: because the ledger ML seems to consist only of hledger releases these days.
12:22:02 <johnw> joelteon: and how do you notice the failure?
12:22:30 <johnw> haha
12:23:16 <joelteon> yesod devel
12:23:27 <johnw> i see the unresolved symbol now
12:23:28 <joelteon> or by using pcre in ghci
12:23:40 <joelteon> compile defaultCompOpt defaultExecOpt "a"
12:24:54 <johnw> joelteon: aha
12:25:12 <johnw> regex-pcre-builtin contains a source file pcre/pcre_tables.c
12:25:19 <johnw> that should be defining utf8_table3
12:25:36 <johnw> but it's guarded by: #if (defined SUPPORT_UTF && defined COMPILE_PCRE8) || (defined PCRE_INCLUDED && defined SUPPORT_PCRE16)
12:25:50 <johnw> would seem it's out of data wrt the PCRE on Mac
12:25:58 <joelteon> huh
12:30:00 <pavonia> Is there a constructor function for NaN?
12:31:04 <shachaf> I think you just mean "a constructor". :-)
12:31:11 <shachaf> The best you can do is probably (0/0).
12:31:27 <shachaf> It's not an actual ADT so it doesn't have actual constructors like that.
12:31:42 <xplat> johnw: now i'm also curious as to what the value expression machinery is/does
12:31:53 <pavonia> shachaf: okay, thanks
12:32:30 <johnw> xplat: things like: --limit 'abs(amount) > 100', that sort of thing
12:32:43 <pavonia> actually, I've already tried 1/0 which yields infinity :)
12:32:43 <xplat> pavonia: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3ARealFloat
12:33:01 * Clint glares at hoogle and hayoo.
12:33:18 <pavonia> xplat I've read that but there's no such function
12:34:07 <johnw> C++ledger contains a small, functional language that uses dynamic binding so the same expression can be re-evaluated in the context of each related posting/account.  hledger does not have this sub-language at all yet
12:34:12 <sm> aristid: hledger announcements are a very small fraction of ledger list traffic.. sure you're subscribed to the right place ?
12:34:37 <aristid> sm: hum
12:34:38 <sm> me high-fives johnw
12:34:46 * johnw high-fives sm!
12:34:57 <johnw> sm: got a moment to skype, actually?
12:34:58 <aristid> sm: oh i know what's going on
12:35:13 <aristid> sm: i'm unsubscribed to the ledger list, but you crosspost to haskell
12:35:34 <sm> johnw: ok wait 1
12:35:50 <sm> aristid: nod
12:39:16 <deech> Hi all, I'm giving a talk on using the common monads (Reader, Writer, State) and their transformer. I'm pretty good on the canonical uses, but can anyone point to packages using them creatively?
12:39:24 <pavonia> Is scaleFloat a kind of left/right shift on floats?
12:40:53 <deech> I currently have Parsec as a creative use of the State monad.
12:41:51 <byorgey> deech: check out http://hackage.haskell.org/packages/archive/xmonad/0.11/doc/html/XMonad-ManageHook.html for a creative use of Reader
12:42:11 <byorgey> in particular see the definition of the Query type
12:42:28 <deech> byorgey: Thanks!
12:46:49 <frankbro> Is there a function similar to chunksOf for array?
12:52:11 <deech> BTW, Hayoo appears to be down.
12:53:05 <acube> yeah, missing hayoo everyday
12:54:15 <johnw> Hoogle wins by dint of having no competitor!
12:54:26 <edwardk> flawless victory
12:54:55 <roconnor> is time part of GHC's base?
12:55:05 <edwardk> its used transitively by it as i recall
12:55:15 <acube> Those downtimes of hayoo are really annoying
12:55:26 <edwardk> i may be wrong in that, but i'll do my homework in the next couple of days
12:55:52 <johnw> roconnor: that just changed today, I think
12:56:10 <roconnor> I know!
12:56:17 <roconnor> I submitted a patch :D
12:56:26 <edwardk> hah
12:56:38 <dolio> I'm glad that's not one of the libraries we're responsible for.
12:56:51 <roconnor> dolio: why is that?
12:57:30 <dolio> Because I don't want to have to learn about the giant rats nest of stuff that goes into making a good time library.
12:57:55 <sm> lol
12:58:07 <roconnor> dolio: It's pretty simple compared to Posix :P
12:58:44 <sm> time, money, and text, the three programming swamps
12:59:19 <roconnor> time seems orders of magnitude worse that money.  And text just should be avoided :D
12:59:33 <roconnor> But ya, text encoding is pretty bad.
12:59:40 <roconnor> possibly worse that time.  I'm not sure.
13:00:06 <roconnor> okay, it is probably worse
13:00:25 <byorgey> sm: you forgot colors.
13:00:35 <roconnor> with time, and a lot of effort, you can probably figure out the right thing to do.
13:00:43 <sm> byorgey: really ? how hard can it...
13:00:49 <byorgey> sm: nooooooooo!
13:00:50 <roconnor> when it comes to transcoding text, there is only choices of differently bad ways
13:02:28 <johnw> ah, colors, just thinking about them changes my perception of them!
13:03:46 <osa1> is there a way to install a package to a cabal-dev sandbox with profiling enabled? how can I do that?
13:03:55 <johnw> --disable-library-profiling
13:04:34 <osa1> johnw: do you mean --enable ?
13:04:42 <johnw> oh, I read that as "without"
13:04:45 <johnw> so, yes
13:04:47 <osa1> cabal-dev install --enable-executable-profiling
13:05:03 <johnw> the package has no library?
13:05:12 <osa1> the package is an executable
13:05:15 <osa1> no libraries
13:05:19 <johnw> ok, then that should be good enough
13:05:40 <osa1> does that install dependencies with profiling enabled too?
13:05:44 <johnw> no, it does not
13:05:52 <johnw> you will have to rebuild the world with library-profiling enabled
13:06:05 <johnw> welcome to the wonderful world of questionable cabal defaults
13:06:08 <osa1> johnw: I thought cabal-dev already rebuilds the world for every sandbox
13:06:17 <johnw> ah, then add --enable-library-profiling
13:06:25 <osa1> ok
13:07:48 <johnw> that's a great use of cabal-dev, which until now never occurred to me
13:08:21 <acube> doesn't hsenv do the same?
13:08:26 <johnw> yeah
13:08:38 <johnw> hsenv has the added advantage that you can specify a different compiler altogether
13:10:43 <osa1> the flag -p requires the program to be built with -prof
13:10:56 <osa1> cabal-dev install --enable-executable-profiling --enable-library-profiling is not enough?
13:11:02 <klrr> okey, so String is not good for production work, should i use Text or ByteStrings?
13:11:04 <johnw> it should be
13:11:34 <CaptainK> is there a funtction to load haskel into my brain in one instuction?
13:12:27 <jeff_s1> CaptainK: cat ghc.tar
13:12:48 <klrr> Taneb: hey
13:12:55 <Taneb> Hi, klrr
13:12:56 <CaptainK> lol, its soo fast!
13:13:03 <CaptainK> now I know
13:13:09 <Taneb> Why have you summoned me?
13:13:52 <joelteon> johnw: so regex-pcre-builtin is broken now?
13:14:01 <johnw> joelteon: well, it is for you and me alt east
13:14:08 <johnw> i'd never used it before
13:14:10 <joelteon> well, rats
13:14:15 <joelteon> I can't test my site now
13:14:20 <johnw> dig into the C code, fix it
13:14:23 <joelteon> i'll install an older version because it used to work
13:14:30 <klrr> Taneb: your message, wanted to confirm i did not
13:14:41 <osa1> does anyone know how can I install a package with cabal-dev with profilings enabled?
13:14:47 <osa1> cabal-dev install --enable-executable-profiling --enable-library-profiling doesn't work
13:15:09 <Taneb> klrr, I am not sure what you are talking about :/
13:15:15 <klrr> ok
13:15:17 <klrr> nvm
13:15:17 <Taneb> Have you got the right person?
13:15:27 <klrr> yes
13:15:46 <joelteon> johnw: yeah, the previous version works great
13:16:15 <johnw> try hdiff then
13:16:25 <klrr> okey, if i use "--XOverloadedStrings" will all strings automatically become Text if i want it too?
13:16:32 <Taneb> klrr, yes
13:16:38 <klrr> okey great :D
13:16:59 <Taneb> You can set the extension by writing {-# LANGUAGE OverloadedStrings #-} at the top of the file
13:17:05 <Breadmonster> Can I work with haskell.org for Google Summer of Code 2014?
13:17:07 <Taneb> This is the preferred style
13:17:33 <Breadmonster> Where do I apply?
13:17:43 <joelteon> yeah, that'll do it.
13:17:49 <joelteon> #ifndef SUPPORT_UTF
13:17:52 <joelteon> #define SUPPORT_UTF
13:17:54 <joelteon> #endif
13:20:33 <chrisdone> johnw: http://ircbrowse.net/nick/johnw =)
13:21:08 <johnw> 20k words in 1 month??
13:21:36 <johnw> the active hours are clearly in UTC or the server's time zone, not mine
13:21:53 <Taneb> johnw, do the NaNoWriMo
13:22:05 <joelteon> that's a great experience
13:22:10 <joelteon> if you have the time for it, which I don't
13:22:17 <chrisdone> johnw: yeah, says UTC near the top
13:22:35 <johnw> so, 3am my time
13:22:55 <joelteon> oh, and that only logs #haskell and #lisp, no fair
13:23:09 <joelteon> and whatever other channels I'm not in
13:23:21 <chrisdone> joelteon: #haskell and #lips are the only ones that matter =p
13:23:27 <joelteon> #lips, huh
13:23:27 <johnw> chrisdone: nice work, chrisdone!
13:23:35 <johnw> chrisdone: well, don't forget #haskell-lens
13:23:36 <joelteon> I wonder if they discuss different balm types there
13:23:43 <joelteon> I'm in #haskell-lens, but it doesn't appear to log that
13:24:17 <structuralist> How are "data Nu f = Outi { out :: f (Nu f) }" and "data Nu f where Nu :: (a -> f a) -> a -> Nu f" isomorphic? I'm not quite seeing it.
13:24:22 <chrisdone> it only takes logs that tunes.org deems worthy of loggery
13:24:34 <Breadmonster> joelteon, What's Haskell Lens?
13:24:43 <joelteon> it's the lens discussion channel
13:25:00 <Breadmonster> What's a lens?
13:25:10 <joelteon> uhh...
13:25:22 <structuralist> http://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/
13:26:24 <shachaf> Do people in #haskell play this game where they try to give every question as complicated an answer as they possibly can?
13:26:37 <joelteon> I thought that's what we were supposed to do :(
13:26:39 <Breadmonster> shachaf: I'd think so.
13:26:46 <joelteon> Breadmonster: a lens is a thing that lets you update parts of a datastructure
13:26:51 <johnw> shachaf: I would answer that, but there is a probably of 99.8% milliterons that my answer would be confounded by higher-order implications
13:26:52 <joelteon> or access it
13:26:59 <chrisdone> i think they answer questions that are trivially googleable
13:27:01 <augur> structuralist: cococo
13:27:07 <Breadmonster> I wish Haskellers told n00bs that monads were a typeclass.
13:27:13 <chrisdone> @google haskell lens
13:27:15 <lambdabot> http://hackage.haskell.org/package/lens
13:27:15 <lambdabot> Title: HackageDB: lens-3.9.0.2
13:27:17 <Breadmonster> And that stuff can be SIMULATED with them.
13:27:21 <johnw> n00b: monads are a typeclass
13:27:21 <ion> shachaf: Followed by a monad joke
13:27:28 <chrisdone> diagrams, explanations, papers, code, etc.
13:27:30 <structuralist> augur: huh?
13:27:40 <augur> structuralist: coalgebras for costate comonad
13:27:52 <structuralist> oh
13:28:02 <edwardk> augur: except 'costate' is a terrible name for everything other than alliterative purposes
13:28:12 <augur> edwardk: :)
13:28:17 <shachaf> edwardk: Are there any other purposes?
13:28:18 <augur> what is costate again?
13:28:25 <edwardk> store
13:28:26 <augur> (a, a -> b) ??
13:28:37 <augur> i dont know what story is :(
13:28:40 <chrisdone> one of the older posts i saw about it: http://twanvl.nl/blog/haskell/overloading-functional-references
13:28:41 <edwardk> newtype Store s a = Store (s -> a) s
13:28:47 <edwardk> er data
13:28:58 <augur> edwardk: right, ok. so yeah. (a, a -> b) basically
13:29:05 <edwardk> the issue is 'costate' isn't dual to state
13:29:07 <augur> such a weird thing to have
13:29:15 <Breadmonster> johnw: Nicely put.
13:29:16 <klrr> wait, chrisdone are you real chrisdone (the cool blogger who also made Z)?
13:29:18 <edwardk> so 'co' there is a real misnomer
13:29:30 <johnw> edwardk: so is Store just CoYoneda without the functor?
13:29:32 <structuralist> edwardk: what really?
13:29:34 <edwardk> its derivable from the same adjunction that we commonly use to give state
13:30:00 <edwardk> but its the composition of the adjunction in the opposite order. every adjunction gives rise to a monad and a comonad in this way
13:30:06 <edwardk> but that relationship isn't dual
13:30:16 <edwardk> coreader, cowriter, etc. are terrible names because they aren't dual
13:30:31 <chrisdone> klrr: haha, i made z, yeah =D
13:30:33 <johnw> edwardk: what has happened to comonad.com?
13:30:36 <augur> edwardk: we should start a campaign!
13:30:38 <edwardk> johnw: laziness
13:30:50 <edwardk> augur: i did. i wrote comonad-transformers and didn't use any of the awful names
13:30:58 <augur> edwardk: thats no campaign
13:31:02 <augur> also what do you mean what happened to comonad.com
13:31:05 <augur> is it dead? D:
13:31:05 <johnw> edwardk: want to host on my server?  I have a WordPress there you could use, and I could keep running for you
13:31:18 <edwardk> johnw: server died. we have a new one. i just haven't reinstalled everything.
13:31:23 <augur> edwardk: o ok
13:31:50 <edwardk> i need to get the guys who run the box to tell me some things and i need to get some stuff off the old box, and its just been a low priority for me for the last 2-3 weeks
13:31:56 <augur> edwardk: whats the better name for these "co" things
13:32:00 <augur> "costate" is store
13:32:09 <johnw> edwardk: well, I make PDFs of everything I read on your site, so I can be patient
13:32:19 <edwardk> costate = store, coreader = env, cowriter = traced
13:32:21 <acube> cowriter is traced I think? and coreader Env?
13:32:35 <osa1> does enabling profiling cause slower runtime? I'm looking for reasons to not to enable profiling by default(in cabal config file)
13:32:39 <joelteon> how is coreader env
13:32:39 <klrr> chrisdone: i was away with family in spain and only had a phone and an internet connection so i read your blog and haskell stuff a lot wihle being there ^^ your blog is cool i like your critisism against the RMS interview by Linux action show :D
13:32:41 <joelteon> I thought reader was env
13:32:42 <augur> edwardk: hm. i dont know what any of these would do, and some of them sound like they'd do what the non-co ones would do
13:32:49 <augur> edwardk: any good tutorials on them?
13:33:16 <chrisdone> klrr: wow, thanks!! you're my second reader! (the first being me)
13:33:18 <johnw> osa1: it certainly slows down compile times, since you have to build everything twice
13:33:30 <acube> Why should one use Env instead of Reader? Are there any different things you can do with them?
13:33:34 <edwardk> augur: never wrote one. worked them out, solved their laws, figured out the transformer variants and double checked that they worked right for the attendant recursion schemes and promptly forgot about it =)
13:33:47 <edwardk> acube: Env is a comonad, not a monad
13:33:47 <augur> edwardk: :P
13:33:53 <edwardk> the usecases are rather subtly different
13:34:26 <structuralist> http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html <- this is cool
13:34:34 <edwardk> in general a comonad transformer gives you more context you can forget, rather than let you lift simpler things into a larger context
13:34:45 <osa1> I installed my package with cabal-dev install --enable-executable-profiling --enable-library-profiling --ghc-options="-fprof-auto" but I still can't enable profiling
13:34:49 <edwardk> hence why ComonadTrans has 'lower'
13:34:56 <klrr> chrisdone: haha xD i think a a bit more read your blog, some haskell stuff are really educational there, well at least for a beginner like me :P
13:35:34 <chrisdone> klrr: glad to hear it =D
13:35:43 <edwardk> acube: Env in its guise as ((,) e)  is one of the easiest comonads to get your head around.
13:35:58 <edwardk> its 'just an extra thing in the environment
13:36:25 <edwardk> extract :: (e, a) -> a; extend :: ((e, a) -> b) -> (e, a) -> (e, b)    -- both have obvious definitions
13:36:41 <chrisdone> klrr: i look forward to seeing your first haskell code released ;D
13:36:43 <edwardk> or even easier. duplicate :: (e, a) -> (e, (e, a))
13:36:56 <shachaf> join = fmap extract
13:37:05 <shachaf> duplicate = fmap return
13:37:23 <chrisdone> shachaf: oh, nice name
13:37:39 <shachaf> Er, wait.
13:37:47 <shachaf> I thought you were talking about Store.
13:37:51 <edwardk> shachaf: that works well for Identity
13:37:54 * shachaf didn't actually read the types, never mind.
13:37:58 <chrisdone> twanvl_: ha! i just linked your blog post (i think) http://twanvl.nl/blog/haskell/overloading-functional-references remember those days? =p
13:38:03 <edwardk> duplicate (Store f s) = Store (Store f) s
13:38:16 <edwardk> you may want to check the laws on your definition for Store. you'll find a bug ;)
13:38:35 <edwardk> that cute definition for Store's duplicate is why i use the arg order i do
13:38:49 <twanvl_> chrisdone:  2007, long time ago
13:38:55 <klrr> chrisdone: i had some stuff on github, a lisp intepreter (mostly based on that Write Yourself a Scheme in48 tutorial) and a little IRC bot, but i deleted them :P working on a new lisp now and is playing around with scotty
13:40:09 <shachaf> OK, y'all should just ignore my nonsense.
13:40:11 <chrisdone> klrr: ah, so you're a lisper, huh? :p that's what lispers do to test out new languages, right? they write lisps!
13:40:37 <shachaf> :t let ret :: a -> s -> (s, a); ret x s = (s, x); dup :: (s, s -> a) -> (s, s -> (s, s -> a)); dup = fmap ret in dup -- this is what I meant, anyway
13:40:39 <lambdabot> (s, s -> a) -> (s, s -> (s, s -> a))
13:40:43 <acube> Are there any examples of good usecases for these comonads?
13:41:50 <klrr> chrisdone: nope, haskell is my first language, ive heard that writing a lisp is a good exercise and since there was a tutorial how to do it i started going through it and it was fun
13:42:13 <jeff_s1> Exercise: Use Template Haskell to compile lisp to haskell.
13:42:24 <edwardk> acube: store can be adapted to make a nice image convolution kernel. traced lets you keep track of what was done to a piece of data to generate it in a 'log' specific to the item you've been modifying. env is useful to tag something with an extra fact. i use it for instance to make most of my data Named a = Named String a like data types into a comonad in a well defined way where you can readily discard the wrapper
13:42:30 <orzo>  i need ip6 support in getHostByName
13:42:43 <chrisdone> klrr: aha! actually me too, my first haskell tutorial was Write Yourself a Scheme also =)
13:42:44 <orzo> for an ap that runs on an ip6 vpn
13:42:56 <edwardk> Store (Int, Int) Color -- makes a viable image that extends infinitely in all directions
13:43:28 <augur> edwardk: why do you need store for that tho
13:43:41 <Taneb> edwardk, that only extends to the size of Int
13:43:44 <edwardk> extend :: (Store (Int, Int) a -> b) -> Store (Int, Int) a -> Store (Int, Int) b    -- takes a function that knows how to compute a value for one point in the image from a position in the image and the old 'image' function, and stitches together a new picture
13:43:46 <Taneb> I think you meant Integer?
13:43:53 <augur> i mean, you're storing an (Int,Int) right, but why?
13:44:25 <Taneb> augur, the (Int, Int) is an index
13:44:34 <edwardk> augur: The store is ((Int, Int) -> a, (Int, Int))    it is a function that knows how to get the 'a' for any given location and a location you have 'focused'
13:44:38 <carter> fyi all: my haskell meetup talk is now online http://www.reddit.com/r/haskell/comments/1gzmw1/who_ya_gonna_call_getting_dirty_with_cmm_the_ghc/ :)
13:45:00 <edwardk> up (Store f (x,y)) = f (x, y + 1)
13:45:16 <edwardk> extend up    gives you a new 'image' shifted 1 pixel up
13:45:16 <orzo> i guess i'm going to need to patch my Network.BSD to support ipv6 addresses in its HostEntry abstraction.  maybe i should change the HostAddress to (Either HostAddress HostAddress6) ?
13:45:29 <edwardk> extend up . extend up shifts twice, etc.
13:45:54 <klrr> chrisdone: haskell is really awesome language :D
13:46:03 <orzo> that'd break existing code, i guess i could have a separate field for ip6 addresses
13:46:15 <edwardk> blur (Store f (x, y)) = (f (x, y - 1) + f (x, y + 1) + f (x - 1, y) + f (x + 1, y)) / 4
13:46:33 <edwardk> extend blur will take an image and apply a blur kernel to the entire image
13:46:43 <acube> edwardk: Yeahm, the Store examples seem pretty impressive. If also seen that example with an array and an index
13:46:53 * hackagebot nitro 0.2.2.4 - Haskell bindings for Nitro  http://hackage.haskell.org/package/nitro-0.2.2.4 (ErinDahlgren)
13:46:55 * hackagebot j2hs 0.99.1 - j2hs  http://hackage.haskell.org/package/j2hs-0.99.1 (JulianFleischer)
13:47:05 <edwardk> acube: sure, the array is just a memoized function in that case.
13:47:07 <augur> edwardk: whats the focused position for tho
13:47:11 <osa1> I'm getting this error only when I compile it with --ghc-options=-prof http://hpaste.org/90374 any ideas?
13:47:36 <edwardk> augur: extend effectively applies the function at all positions
13:47:43 <edwardk> to generate the new image
13:48:10 <edwardk> the store comonad comes up a lot but most of the usecases are things like lenses
13:48:15 <augur> edwardk: that seems like a very roundabout way to conceptualize an image
13:48:31 <augur> i mean, up (x,y) = (x,y+1), f . up
13:48:46 <augur> surely that does the same thing
13:48:56 <augur> actually that should be y-1 but
13:49:15 <edwardk> augur: the trick is that you can make many of these image convolutions, blurring, shifting, multiplying by other images, adding in alpha, etc. whatever and it does the right thing
13:49:16 <shachaf> Density is a lot like Store.
13:49:29 <edwardk> you can line up two images and smash them together
13:49:37 <acube> ok I have to go now, thanks for the explanation
13:49:41 <edwardk> f . up doesn't compose as well.
13:49:58 <augur> edwardk: ill take your work for it. it just sounds like an awful lot of trouble to go through
13:49:58 <edwardk> it only lets you make a single change, but for instance 'blur' used 4 different 'queries' to compose the new value
13:50:29 <KSkrzet> I
13:50:32 <augur> im not sure how it doesnt compose well
13:50:50 <edwardk> data Pointer i a = Pointer (Array i a) i   -- is a perfectly cromulent memoized form of this
13:51:02 <KSkrzet> I've just noticed that JuicyPixels is quite slow... about 20x slower than C libraries for jpeg loading. any ideas why it is *that* much slower?
13:51:03 <edwardk> augur: write extend blur . extend blur your way
13:51:39 <augur> i mean.. blur img (x,y) = avg [img (x-1,y), img (x+1,y), img (x,y-1), img (x,y+1)]
13:51:42 <augur> or whatever
13:52:08 <edwardk> augur: that is the definition of the blur i gave.
13:52:17 <augur> edwardk: sure ok
13:52:26 <augur> blur (blur img)
13:52:29 <edwardk> blur and up are interchangeable in my version
13:52:36 <edwardk> your up is radically different than your blur
13:52:57 <augur> well yes, i was writing them differently but obviously thats a trivial difference
13:52:58 <edwardk> you can of course change your up to be: Store (Int, Int) a -> Store (Int, Int) a
13:52:58 <augur> up
13:53:02 <augur> up' f = f . up
13:53:04 <augur> whatever
13:53:04 <edwardk> but that is what extend does!
13:53:07 <augur> same diff
13:53:25 <edwardk> buy that same token you could replace all monadic actions a -> m b    with m a -> m b!
13:53:26 <augur> edwardk: yeah except its in some funny comonad. thats the part i dont understand.
13:53:32 <edwardk> er by
13:53:47 <osa1> I can't compile my package with profiling no matter what .. there should be an easy wa
13:53:50 <osa1> way*
13:53:53 <augur> is there some special syntactic thing that makes it nice?
13:53:54 <augur> that i could see
13:54:03 <edwardk> 'blur' in your case is doing all sorts of work that can be factored out
13:54:16 <augur> is it?
13:54:21 <edwardk> no magic syntax -- well dominic orchard has something
13:54:27 <edwardk> yes, because you didn't finish it
13:54:31 <augur> didnt i
13:55:50 <edwardk> you can write all of this crap without comonads
13:55:58 <edwardk> the comonad factors out a common pattern
13:56:09 <edwardk> like how monads factor out a common pattern
13:56:30 <augur> im not seeing the factoring tho
13:56:32 <edwardk> i can write my programs in CPS and never have to introduce a monad for everything
13:57:14 <augur> ive heard this also, and ive never seen it done.
13:57:30 <edwardk> blur :: Image Color -> Color           extend blur :: Image Color -> Image Color   -- we say how to generate one 'pixel' of the resulting image and extend turns it into an entire new image.
13:57:56 <edwardk> moving to a 1d example, your Image becomes a 1d cellular automaton
13:58:35 <edwardk> transition :: Automaton Color -> Color; extend transition :: Automaton Color -> Automaton Color
13:59:17 <augur> thats such a weird way of doing things
14:00:06 <edwardk> it doesn't have to be represented by a function and position. you can use a zipper as well
14:00:35 <edwardk> data Automaton a = Automaton [a] a [a]
14:04:07 <edwardk> step (Automaton (l:ls) m (r:rs)) = rule110 l m r where rule110 True True True = False; rule110 _ False False = False; rule110 _ _ _ = True
14:04:20 <edwardk> extend step gives you one step of an automaton for wolfram's rule110
14:04:41 <edwardk> assuming the zipper is extended with an infinite set of False's in both direction.
14:04:44 <edwardk> er directions
14:05:54 <edwardk> but that is just the store comonad in a slow disguise
14:06:01 <edwardk> so it is good to know these things are all equivalent =P
14:06:37 <edwardk> (that isn't entirely true, as the zipper variant knows its bounds)
14:06:54 <augur> edwardk: it just seems like a weird way of doing images
14:07:17 <edwardk> i used the image example because it 'resonates' for more people than talking about store more abstractly
14:07:34 <edwardk> feel free to ignore it and continue on wondering why anyone would ever use store =P
14:07:43 <augur> edwardk: i mean i just dont get why you store the pointer
14:07:49 <augur> thats the part i dont get
14:07:57 <edwardk> because you can do both relative and absolute addressing.
14:08:18 <augur> edwardk: hmm
14:08:22 <edwardk> i can vary my behavior at the edge of the image
14:08:36 <augur> how does that achieve relative addressing?
14:08:48 <edwardk> up is relative addressing
14:09:08 <edwardk> flip (Store f (x,y)) = f (-x,-y)   is also a form of position aware addressing
14:09:34 <edwardk> shrink (Store f (x,y)) = f (x * 2, y * 2)   -- likewise
14:10:22 <edwardk> but you can also do things like sample the pixel in the center of the image, and subtract it from every other pixel in the image, etc.
14:11:16 <edwardk> in store terms we have both 'peek' and 'peeks'. peek does absolute addressing so when you extend it the result is quite boring as that one value gets copied everywhere, peeks does relative addressing
14:11:59 <edwardk> there are variations of this that let you navigate around in a traversable container, edit the contents and spit out a new structure
14:14:20 <orzo> I'm looking at Network.BSD and currently, getHostByName will call the c function gethostbyname which may return an ipv6 address which will be reflected in HostEntry's hostFamily feild, but it will ignore that interpret the address list as nonsense ipv4 addresses in the hostAddresses field.
14:14:58 <augur> edwardk: oh, it enables relative addressing in that it exposes the focus for use in addressing
14:15:23 <orzo> I need ipv6 support for my project, should I change hostAddresses to a type that can hold ipv6 addresess, or should i add a new feild to HostEntry for that?
14:15:38 <augur> im still baffled what the focus is doing tho. i mean why do you want that at all
14:16:17 <iteratee> orzo: will getAddrInfo not work for your use case?
14:17:47 <roconnor> augur: it gives you a centre point to know where you are in a function you are going to "extend"
14:17:50 <roconnor> @type extend
14:17:50 <lambdabot> Not in scope: `extend'
14:17:54 <roconnor> :/
14:19:01 <augur> roconnor: this is why i need some good tutorials, because im just not seeing how thats something i'd want when processing an imagine or whatever.
14:19:43 <roconnor> augur: How would you do a blur?
14:19:49 <augur> roconnor: see above!
14:21:23 <roconnor> augur: right, your (x,y) in your blur is playing the role of the focus location.
14:21:45 <augur> er
14:21:56 <augur> if you insist
14:22:48 <roconnor> extend :: (Store Loc Value -> Value) -> ...
14:22:50 <augur> i mean, the (x,y) is just the location to read from, since the idea is Image == (Int,Int) -> Color
14:23:01 <augur> blur is just Image -> Image
14:23:04 <roconnor> so the function f you pass to extend is *taking* the location focus as an input
14:23:24 <augur> you can obviously uncurry it, which is what Store is
14:23:32 <augur> im just not sure the utility in doing that for images
14:24:33 <augur> anyway, afk
14:24:47 <roconnor> :)
14:25:18 <roconnor> It's a bit like arguing why you cannot just thread state manually.  Why use a monad.
14:26:52 <roconnor> augur: when you get back, rewrite your blur so it takes an arbitrary convolution kernel as a parameter instead of a fixed one.
14:28:45 <roconnor> Maybe I can fill in for augur
14:30:34 <roconnor> augur will say it is foo :: ([DeltaLoc] -> Int) -> (Loc -> Int) -> (Loc -> Int)
14:31:24 <roconnor> wait that isn't right
14:32:36 <roconnor> augur will say it is foo :: ((DeltaLoc -> Int) -> Int) -> (Loc -> Int) -> (Loc -> Int)
14:33:30 <roconnor> Which is now almost the same as (Store Loc Int -> Int) -> Store Loc Int -> Store Loc Int.
14:34:31 <roconnor> I guess extend lets you extend functions that operate on both absolute location and relative location
14:36:02 <klrr> night , haskell is awesome! :D
14:37:42 <roconnor> so you can make a blur which becomes more blurry the more you move away from some absolute location.
14:38:41 <roconnor> presumably (extend f) preserves the location of the Store, so that isn't an interesting aspect of the extend function.
14:38:42 <CaptainK> in LYAH, the examples don't work on the intereactive GHCi, they do load from a .hs file, just trying to figure out why that is?
14:39:47 <geekosaur> ghci has different defaults. one notable difference is extended defaulting rules
14:40:10 <CaptainK> or how can I use GHCi "realtime" ?
14:40:36 <byorgey> CaptainK: ghci only allows you to enter expressions, not arbitrary declarations.
14:40:53 <byorgey> you can enter declarations in ghci but using a different syntax.
14:41:13 <byorgey> loading definitions into ghci from an .hs file is the recommended way to do things.
14:41:23 <byorgey> then you can just type :r to reload after making changes to the file.
14:43:56 <orzo> actually getAddrInfo might work, i need to distinguish local an remote addresses though
14:47:10 <RenJuan> is there a Haskell IDE as well developed as Leksah, but actively (needn't be in haskell itself)?
14:48:20 <c_wraith> RenJuan: EclipseFP is about the only thing in active development.
14:48:31 <RenJuan> c_wraith, thx
14:48:55 <joelteon> wow, GHC uses a buttload of memory
14:48:56 <iteratee> orzo: If it's giving junk ipv4's then it needs to be fixed at a minimum to just skip them.
14:50:13 <iteratee> orzo: How are you telling local from remote with getHostByName?
14:50:41 <CaptainK> byorgey: ok, understood.  The different syntax is that I can use the "let" command in ghci
14:51:09 <byorgey> right.
14:51:10 <joelteon> yeah, ghci is like working in the IO monad, but with import support
14:51:27 <c_wraith> joelteon: actually, GHC is pretty restrained in memory use. but the object files it creates cause ld to eat a ton of memory. sometimes you can replace the system linker with gold to work around that
14:51:34 <joelteon> I see
14:51:52 <CaptainK> even though I can use "let", the output is not the same, for example
14:52:15 <byorgey> CaptainK: Can you give an example where the output is not the same?
14:52:36 <orzo> iteratee: i wasn't.  I just realized it was another hurdle to jump after i decided to try the other function
14:52:43 <orzo> the first hurdle was ip6
14:52:50 <orzo> so i didnt see the second
14:52:52 <orzo> heh
14:53:08 <orzo> i'm switching to getAddrInfo now, and i think itll work out
14:53:15 <CaptainK> let lucky 7 = "jackpot", let lucky x = "sorry", lucky 7 will not give the jackpot, just the last function
14:53:28 <orzo> which means, to bad for getHostByName, somebody else cna patch it
14:53:31 <CaptainK> in ghaci anyway
14:53:38 <joelteon> CaptainK: you would need something like let lucky 7 = "jackpot"; lucky x = "sorry"
14:53:47 <joelteon> otherwise you're overwriting the first binding with the second
14:53:55 <CaptainK> ahhhhh
14:53:58 <CaptainK> ok
14:55:06 <CaptainK> is there a writeup besides lyah to explain this, very new here so I really need to understand the difference?
14:55:51 <CaptainK> was trying to follow lyah, but you keep having to modify a .hs file and that is just too slow
14:55:53 <joelteon> explain what exactly
14:56:46 <CaptainK> thought the "interactive" in GHCi was that you work in a similar flow to the book examples, but there is an obvious reason for that which I need to fully understand
14:56:54 * hackagebot hspec 1.6.0 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.6.0 (SimonHengel)
14:57:54 <geekosaur> no interactive as in it's a sort of desk calculator version of haskell
14:58:16 <CaptainK> ya, so far as a calculator it rocks
14:58:31 <geekosaur> at the very least, your way would require that ghci batch up everything typed in and let you edit and reload from that...
14:58:39 <geekosaur> (which I don't think is planned any time soon)
14:59:50 <CaptainK> well at least I have sublime text and programmed ghci to use it as the editor, so it does come up easy enough, but there is no method to entering on the fly?  How do people follow in the book, same way I do it?
15:00:39 <byorgey> CaptainK: just keep the .hs file open in the editor in one window, and ghci in another window.
15:00:54 <byorgey> CaptainK: make changes to the .hs file, then type  :r  at the ghci prompt to reload.
15:01:33 <byorgey> it's pretty fast, I'm not sure what you're doing that makes you think it is slow
15:01:47 <CaptainK> ok will do, guess its no different than codeblocks, you have to compile it all before output
15:03:10 <CaptainK> "interactive" is confusing me with my history for programming in "interpretive"
15:03:40 <CaptainK> two totally different animals
15:06:54 * hackagebot hspec-meta 1.6.0 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.6.0 (SimonHengel)
15:08:05 <martint> CaptainK, if you use emacs and haskell-mode, you can make changes, press C-c C-l, and then it shows up on the ghci window. (I guess it saves you from having to switch window and then typing :r.)
15:08:51 <CaptainK> ok, will have to look at emacs, iir they have win binaries
15:09:09 <CaptainK> sublime text is kick ass as fas ide's go
15:12:50 <Peaker> I think emacs is less terrible than Sublime
15:13:05 <Peaker> (and unfortunately there's no non-terrible IDE yet, at least that I've had a chance to use)
15:13:07 <CaptainK> Emacs latest Windows binarie: http://gnu.c3sl.ufpr.br/ftp/emacs/windows/emacs-24.3-bin-i386.zip.sig
15:13:51 <CaptainK> lol, yes they do tend to fail because they try to be ALL things to all peoples and their syntaxs. :P
15:14:42 <CaptainK> Do I need to load any extension to have it highlight haskell code?
15:14:56 <CaptainK> it :: emacs
15:15:12 <Peaker> CaptainK, you need to have haskell-mode installed
15:16:16 <martint> CaptainK, follow this [https://github.com/haskell/haskell-mode/blob/master/README.md]
15:17:29 <DanBurton> hpaste down -- http://www.downforeveryoneorjustme.com/http://hpaste.org/
15:17:50 <CaptainK> when typeing in emacs M-x, what keystrokes is that exactly?
15:18:09 <CaptainK> Capital M followed by a lowercase x?
15:18:12 <martint> alt-x
15:18:16 <martint> the m stands for meta
15:18:26 <geekosaur> either holding your meta key (what that is depends on how emacs is configured; often the alt key) or pressing escape followed by x
15:18:47 <CaptainK> and C-l ?
15:18:53 <geekosaur> control
15:18:54 <martint> ctrl-l
15:18:54 <CaptainK> Ctrl + l ?
15:19:06 <CaptainK> ah ok, got it...gtk
15:19:56 <martint> i'd actually type alt-x, customize-apropos, enter, package, enter, and then select package archive, and then insert the marmalade or melpa archive, and then install haskell-mode from the packager
15:21:22 <RenJuan> c_wraith, FWIW Eclipse FP doesn't appear to be actually active either aside from the github repo, and the domain eclipsefp.sf.net appears lapsed
15:21:59 <RenJuan> I presumed Leksah was waiting for ghc 7.6 to stabilize
15:22:05 <c_wraith> RenJuan: hm. The authors were interacting with people on r/haskell quite a lot last year.  I guess things may have lapsed since then
15:22:27 <RenJuan> yeah no path to use is pretty lapsed
15:23:06 <RenJuan> (aside from constructing the eclipse pkg from github sources)
15:23:42 <lispy> It's just moved
15:23:43 <lispy> http://eclipsefp.github.io/
15:23:52 <lispy> RenJuan: ^^
15:24:00 <RenJuan> ah
15:24:35 <lispy> If you got directly to http://eclipsefp.sf.net you get a notice, but I guess if you put in the pkg URL you're not as fortunate :(
15:25:10 <RenJuan> well "lapsed" was based on whois
15:25:31 <Peaker> My only attempts to use Leksah and EclipseFP both left me very disappointed :(
15:25:37 <Peaker> but it was a while ago
15:26:04 <c_wraith> I only wanted one thing from EclipseFP, and it didn't do it.  Furthermore, the authors didn't seem to understand when I asked why it didn't do it.  *sigh*
15:26:06 <RenJuan> Leksah's OK, the best I think but trynna eval this other
15:26:21 <lispy> Peaker: I think eclipsefp is one of the better ones available, but yeah I just use vim.
15:26:26 <RenJuan> better than "OK" actually
15:26:36 <c_wraith> All I wanted as an option to say "import haskell project from .cabal file"
15:27:03 <RenJuan> don't say "all I wanna" or "I just ..."
15:27:11 <lispy> Does eclipsefp or leksah support cabal-dev yet?
15:27:30 <Peaker> lispy, Eclipse in general is so buggy I don't see how people use it at all
15:27:47 <lispy> Peaker: And laggy :(
15:27:49 <Peaker> lispy, and the UI is so clunky and sluggish, and the tooltips that hide half the screen whenever mouse lands anywhere
15:27:53 <DanBurton> http://pastebin.com/6bVGh1Wm -- Is there some reason that these are not in Control.Arrow?
15:27:57 <c_wraith> Well, it was 100% "This is how I think about haskell development. I work on packages. Let's import this package to work on...  Huh, there's no option to do so.  Ok, uninstalling!"
15:28:07 <lispy> Peaker: yes, these issues ring a bell :)
15:28:39 <lispy> DanBurton: I think yampa has the first one as ~<<
15:28:47 <Peaker> Leksah I remember trying and pretty much nothing working as intended :(
15:29:04 <Peaker> Try to press "debug build", nothing happens, try to press various other package-related buttons, nothing happens
15:29:16 <lispy> DanBurton: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Arrow.html#v:-94--60--60-
15:29:42 <RenJuan> http://eclipsefp.github.io/ doesn't work either
15:29:46 <lispy> DanBurton: my mistake. I see the diffeerence in types now.
15:30:23 <martint> RenJuan, works for me here. maybe your connection is broken
15:30:39 <RenJuan> works in juno?
15:30:51 <martint> oh, no. i thought you meant the webpage
15:30:55 <DanBurton> lispy: its still true that arrowFmap = (^<<)
15:31:02 <CaptainK> how is the debugging in haskell? seems like it has constraints to make it easier at compile time, but what do guys think compared to other languages?
15:31:11 <lispy> DanBurton: okay. Maybe I was wrong about being wrong :)
15:31:12 <RenJuan> not that worked even at the lapsed domain's redirection
15:31:25 <RenJuan> s/not/no/
15:31:55 * hackagebot monad-supply 0.4 - Stateful supply monad.  http://hackage.haskell.org/package/monad-supply-0.4 (GeoffHulette)
15:31:58 <DanBurton> lispy: I just find it odd that Control.Arrow doesn't provide arrowAp and arrowPure
15:32:18 <Peaker> CaptainK, it's not so good
15:32:39 <RenJuan> so I guess lispy was referring to that redirection
15:32:40 <Peaker> CaptainK, it's a weak spot for Haskell (though IMO purity should make runtime debugging easier, the tools are just not very good currently)
15:32:44 <lispy> CaptainK: How to do really good debugging of Haskell is definitely still a research problem. There are things you can do to avoid needing to use a debugger and there have been several attepmts at debuggers. See for example, the debugger built into ghci.
15:33:03 <Peaker> I generally throw traces all over the place
15:33:15 <Peaker> which annoyingly sometimes requires adding Show constraints to a lot of functions
15:33:24 <hpc> i just write code that is condusive to static reasoning
15:33:32 <Peaker> hpc, and never debug
15:33:35 <hpc> none of this silly runtime analysis
15:33:58 <hpc> (i am entirely serious; it's a lot easier to get away with in haskell than other languages)
15:33:58 <CaptainK> ya, that is the feeling I'm getting, that it would be tough to track my shit code
15:33:58 <Peaker> the static reasoning stuff doesn't work so well at showing you don't build heavily nested thunks
15:34:11 <Peaker> hpc, of course Haskell makes runtime debugging pretty rare
15:34:20 <johnw> I've been trying more to make errors impossible through types as much as I can
15:34:23 <Peaker> hpc, but it still happens and then it's currently a headache
15:35:36 <CaptainK> seems like a good idea to use explicit declarations even though Haskell can make good assumptions from what I read so far.
15:35:44 <lispy> the profiler that ships with ghc is pretty powerful
15:35:55 <lispy> I haven't tried threadscope but it's supposed to be nice too
15:36:11 <CaptainK> lispy: what is the profiler?
15:36:28 <lispy> CaptainK: it helps you understand the performance of your code
15:36:33 <lispy> where the hotspots are, what is allocating
15:36:44 <lispy> overall memory usage. that sort of thing.
15:36:57 <CaptainK> ok, that sounds good
15:37:51 <CaptainK> was hoping the language was human easy readable, but if you need to declare everything and puke tracepoints all over it, could get messy
15:40:16 <sm> chrisdone, ircbrowse is slick!
15:43:23 <Peaker> The runtime profiler is a bit hard to use if your problem isn't a very dense hotspot
15:43:31 <Peaker> Just wrote a utility to work with profiles to help with that
15:43:38 <Peaker> Already found it very useful
15:45:00 <sm> Peaker: oh do tell ?
15:46:13 <Peaker> sm, https://github.com/Peaker/HaskProfileGui -- it parses the profile and: 1) prints the top 1000 SCC's based on cumulative time rather than self-time.  Of course main->mainLoop->... are boring and need to be skipped, but it shows various functions whose cumulative time is huge and can represent a problem due to having too much occuring inside them
15:46:31 <Peaker> sm, also, it opens up a Wx treeview that lets you easily navigate through the profile tree, sorting children by cumulative time
15:47:24 <Peaker> sm, so you can press in the wx GUI: Right->Right->Right... many times and "dig" into the actual time consumers of the program, by cumulative time. I think cumulative time is usually more interesting than "self-time" because it represents a not-that-local profiling problem
15:47:36 <CaptainK> lol, found this while looking at debugging in general terms.
15:47:38 <Peaker> so you get a good general idea how the time is spent
15:47:46 <CaptainK> The most common types of mistakes when programming are:
15:47:47 <CaptainK>  
15:47:47 <CaptainK>     Programming without thinking
15:47:56 <Peaker> rather than a microscope's view of which functions are problematic
15:48:51 <CaptainK> from: http://www.drpaulcarter.com/cs/debug.php
15:49:39 <elliott> CaptainK: please don't paste anything more than two lines or so
15:50:03 <CaptainK> lazy cut and paster :P
15:50:20 <elliott> lazy or not, you're addressing a thousand people :P
15:51:01 <CaptainK> good point! #haskell is one of the most active groups here
15:52:12 <sm> Peaker: I'm very interested in this - thanks. I've experimented with cleanup scripts and emacs outline mode for profile browsing
15:52:50 <Peaker> sm, try to run this on your profile
15:53:21 <sm> I will, if I can get it installed
15:54:57 <sm> even a cabal-dev install looks problematic (ghc 7.6.3 here)
15:57:01 <Peaker> what does it say?
15:58:18 <sm> Peaker: https://gist.github.com/simonmichael/5854488
15:59:13 <Sonarpulse> I am taking a course using matlab where students (thankfully) are allowed to use something else
15:59:26 <Peaker> sm, ok, so the problem is that it's trying to install older containers.. standard trick is, add:    --constraint "containers == 0.5.0.0"
15:59:33 <Sonarpulse> I am thinking repa for matricies
15:59:37 <Sonarpulse> what should I use for plots?
15:59:48 <Peaker> sm, oh, right! I forgot my pull request to wx wasn't accepted yet
16:00:04 <Peaker> sm, you'll have to install wx from my fork at: https://github.com/Peaker/wxHaskell
16:00:13 <Peaker> sm, I fixed wx to build on modern ghc
16:00:51 <sm> aha, cool
16:02:14 <CaptainK> The first listed compiler error is always a true error; however, later errors may not be true errors.
16:03:50 <RichyB> In that the rest might merely be consequences of the first?
16:06:56 <orzo> hm, the docs show SockAddr has a Show instance, and my test program does work, but i can't seem to find the source code to Show SockAddr
16:08:41 <prophile> orzo: it's in the Network.Socket module
16:09:03 <prophile> http://hackage.haskell.org/packages/archive/network/2.2.1.7/doc/html/src/Network-Socket.html
16:09:14 <orzo> thanks
16:09:26 <prophile> no worries
16:13:05 <JoeyA> http://hackage.haskell.org/packages/archive/network/latest/doc/html/src/Network-Socket.html
16:13:16 <JoeyA> (latest; 2.2.1.7 is pretty old)
16:16:22 <orzo> it puts a port number no matter what for an ip6 address, and i didnt want to display the port number, so i have to either strip it off or not use show
16:21:19 <JoeyA> Rendering IPv6 addresses is pretty tricky, especially if you want to support abbreviation (e.g. "::1").
16:21:34 <JoeyA> At least manually
16:21:56 * hackagebot cabal-debian 3.4.2 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-3.4.2 (DavidFox)
16:22:53 <JoeyA> Stripping off the output of Show seems reasonable, but might not be future-proof.
16:26:14 <orzo> i implemented a strip off that searches for ']' and truncates it there, dont see how that can screw up in the future
16:39:00 <Peaker> sm, did you manage to install wx from my fork?
16:48:34 <sm> not yet Peaker.. I couldn't see what to do with your wxHaskell fork so went back to work :-)
16:48:50 <Peaker> sm, you need to run "cabal install" in wxdirect, wxcore, wx
16:49:32 <sm> Peaker: ah right, I guessed that and then paused it as I don't have the ram on my mac just now
16:49:46 <sm> gotta fix this bug and close phpstorm first
16:53:55 <sm> which by the way has changed my whole attitude to IDEs and made me wish jetbrains would add a haskell one to their intellij family
16:57:30 <sm> Peaker: ok, it requires installing some version of wxwidgets too eh
16:57:31 <CaptainK> is there a web framework for haskell?
16:57:49 <ion> No, there are multiple.
16:57:52 <Peaker> sm, 2.9, yeah
16:57:57 <sm> CaptainK: yesod, snap, happstack, scotty, MFlow and others
16:58:09 <Peaker> sm, I added an Ubuntu "deb" line for it
16:58:13 <CaptainK> great list, thx
16:58:29 <sm> roughly in order of popularity
16:58:39 * CaptainK is lost in web framework land
16:58:43 <Peaker> deb http://repos.codelite.org/wx2.9/ubuntu/ quantal universe <-- for my Ubuntu, and also:  sudo apt-key adv --fetch-keys http://repos.codelite.org/CodeLite.asc
17:02:39 <sm> Peaker: looks too much work right now - sorry
17:09:26 <CaptainK> http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/
17:19:51 <orospakr> hey, is there anything analagous to proguard that will remove unused functions in the link phase?  this would make static linking of the static library a great deal less painful.
17:20:51 <hpc> afaik, ghc already does that
17:21:16 <Demos> and you can strip ghc binaries just like regular ones
17:21:26 <hpc> ghc binaries strip disturbingly well
17:21:56 <shachaf> The wiki ( http://www.haskell.org/haskellwiki/GHC_optimisations#Dead_code_elimination ) says that it does not.
17:22:47 <Demos> well I once used Hint, it static linked in all of GHC, like a 100MB binary, only like 50 when stripped
17:22:57 <orospakr> shachaf, thank you. :)
17:23:09 <orospakr> alas, that's not the answer that I was hoping for, but the wiki explains the current state of things well.
17:23:48 <orospakr> I'm thinking of using Haskell for my next project, but I want to use it as a library in projects on Android and possibly Apple's mobile OS.
17:24:05 <Nisstyre-laptop> orospakr: that is going to be a challenge
17:24:08 <orospakr> and thus, considering how laggy Android already is, I worry a bit about executable sizes.
17:24:22 <sm> orospakr: you should check out joeyh's git-annex dev blog
17:24:30 <hpc> executable size does not correlate with runtime speed
17:24:32 <orospakr> I've seen people doing cross compiling. thankfully, my project does not call for using any of the native mobile APIs from my Haskell code.
17:24:37 <Demos> yeah marshaling between java and haskell is really bad
17:24:50 <Demos> also, calling haskell code from other languages can be quite hard
17:25:15 <Demos> the C bindings are ticky and do not give good errors (they tend to just segfault)
17:25:51 <orospakr> hpc, oh, execution speed it won't have much effect, but start time it does. Android is hell of laggy already, and a frequently used service that is stopping and starting Haskell code might feel it badly.
17:25:56 <Demos> hell even go is hard to use on android and that is a) google, and b) super simple
17:26:22 <orospakr> Demos, fair enough. I expect a minimum of marshalling. however, segfaults are unfortunate. :(
17:26:57 * hackagebot robots-txt 0.3.0.0 - Parser for robots.txt  http://hackage.haskell.org/package/robots-txt-0.3.0.0 (MarkWotton)
17:27:13 <Demos> orospakr, yeah well haskell is strange, you get this problem whenever you go from a more abstract language to a less abstract one, happens with calling dynamic langs from static ones as well
17:27:30 <orospakr> ah, that I'm used to.  done ruby bindings before.
17:27:35 <Demos> also wont haskell start way faster than java (well if the JVM is not already running which on android it is)
17:27:55 <Demos> yeah the dyanmic keywork in c# and the :?> operator in F# are nice
17:28:11 <Demos> at least I think it is :?> it may be like ?:> or <:?
17:28:24 <Nisstyre> Demos: I guess native java binaries can start quickly
17:28:32 <Nisstyre> not many people use those though
17:29:08 <Demos> well isnt that just using JNI to call C
17:29:18 <Demos> and I think people do use them, games and such
17:31:40 <Demos> it sucks but haskell does not have good support for programming on platforms that are not x86
17:31:51 <Demos> hell even x86_64 is lacking on 'doze
17:32:11 <Demos> I suppose you could use ghcjs for the new mozilla phone but then you would need to use a mozilla phone
17:32:33 <Demos> you can use F# on winphone, but that is less amazing than haskell
17:33:04 <OxGOOSE_> Demos: does ghcjs compile into javascript?
17:33:31 <Demos> yeah
17:33:37 <Cale> http://hdiff.luite.com/gloss/styrene/
17:33:45 <Demos> not pretty javascript (well javascript is hardly pretty by default)
17:34:01 <Cale> http://hdiff.luite.com/gloss/styrene/out.js :D
17:34:30 <Cale> It's a testament to how well modern browsers run javascript
17:35:53 <Demos> it is laggy as hell in aurora
17:36:13 <Demos> aurora being the firefox more than beta but less then nightly
17:36:38 <Demos> that is an utterly massive source file though
17:36:42 <Demos> and JS needs to be small
17:36:46 <Demos> does closure work on it
17:37:06 <Demos> also it would be swwwweeet if ghcjs could output LLJS or asm.js code
17:37:41 <Demos> ah runs much better in IE
17:37:54 <Demos> that is a 2D canvas I assume then
17:38:56 <Cale> It runs fine in Chrome for me
17:39:32 <martint> i get about 3 fps on chromium 27 on debian unstable :(
17:39:36 <OxGOOSE_> Can Haskell compile to ByteCode?
17:39:38 <Demos> I dun have chrome
17:39:50 <Demos> what kind o byte code
17:39:57 <Demos> haskell can compile to opcodes!
17:39:58 <OxGOOSE_> jre bytecode?
17:40:07 <Demos> I dont think so
17:40:15 <Demos> nobody has bothered since scala is around
17:40:25 <OxGOOSE_> People use scala?
17:40:29 <Demos> same with compiling it to CLR bytecode, because F#
17:40:44 <Demos> yes
17:41:07 <DiegoNolan> didn't brian o'sullivan write software that was using c# and haskell?
17:41:13 <Demos> it seems like people use it to get away from javascript while still being in the javascript area, like if they need to use java but do not want to write java
17:41:15 <martint> OxGOOSE_, there is https://github.com/Frege/frege which is a haskell-like lang for jre
17:41:44 <Demos> maybe, but I dont think he actually wrote a compiler that went haskell -> CLR
17:42:06 <DiegoNolan> oh no, i think he went native
17:42:40 <Demos> well I would love to see that
17:43:23 <Demos> martint, F# is like a mix between haskell and ML, with a tad more ML, but it is acceptable, sad part is that the libraries are .net and thus you end up writing a lot of loops
17:43:37 <sm> I'm trying to get some old code building.. what replaces Control.OldException.throwDyn now ?
17:43:48 <OxGOOSE_> Why doesn't Haskell compile well on other architectures besides x86?  Doesn't C-- take care of that problem
17:44:13 <DiegoNolan> i'm saying i agree i don't think he went to the CLR.  I think we went machine code and then linked to that
17:44:23 <shachaf> sm: Probably Control.Exception.throw?
17:44:28 <DiegoNolan> i saw a talk about it a while ago but I don't remember what he said
17:44:33 <geekosaur> mm? mostly because nobody cares about keeping those other architectures working, aside from recent ARM work
17:44:34 <Demos> oh, can you compile C# to machine code?
17:44:36 <shachaf> sm: But probably not an exact replacement, since the exception mechanism isn't exactly the same.
17:44:44 <geekosaur> there used to be SPARC support but nobody cared
17:44:57 <OxGOOSE_> Demos: I don't believe so, not even with mono
17:45:07 <shachaf> You can compile anything to anything.
17:45:15 <elliott> OxGOOSE_: what makes you think it compiles badly on architectures other than x86?
17:45:19 <sm> shachaf: alright.. thanks for the pointer
17:45:35 <geekosaur> and the problem with C# to machine code is that most of the power of C# is leveraging the .NET libs
17:45:38 <Demos> well yes, but compiling c# to machine code may mean just static linking the CLR
17:45:41 <xplat> to me F# seems like it has some of the worst parts of haskell (module system), the worst parts of ML (impurity, syntax), with some C# mixed in for flavour.  i mean it's an improvement on other CLR stuff, but still, no thanks.
17:45:56 <Demos> yeah
17:45:58 <OxGOOSE_> someone said it above ^^ "it sucks but haskell does not have good support for programming on platforms that are not x86
17:45:58 <OxGOOSE_> hell even x86_64 is lacking on 'doze"
17:46:01 <Demos> and how are haskell modules bad
17:46:17 <Demos> I suppose my other "main" language is C++ so any modules are good modules...
17:46:31 <Demos> that was me 0x
17:46:36 <Clint> OxGOOSE_: it's less the "compiling" and more the lack of TH or threaded runtime
17:46:57 <Demos> really are TH and threading not avalible on windows
17:47:06 <Clint> i have no idea about windows
17:47:10 <geekosaur> there have been attempts at getting haskell hosted on top of the JVM. I think mostly they died due to lack of interest
17:47:33 <geekosaur> TH should be working on ARM these days
17:47:43 <xplat> Demos: haskell modules are decent by comparison to most languages but among the typed functional languages, or among the aspects of overall Haskell design, they look terrible.
17:48:05 <geekosaur> it took a while to get the bytecode to native library interface working, since it uses its own custom linker instead of the system one
17:48:22 <joeyh> re sparc, I was surprised to see the other day I could turn on the TH using parts of my code on that architecture
17:48:29 <Demos> so how are ML ones better? most of my experence with modules has been in haskell and go
17:49:02 <geekosaur> (and TH and threading work fine on Windows, btw)
17:49:12 <OffsetGoose> What's the difference between a module and something like a C header file?  Sorry if noob question o_o
17:49:25 <hpc> Demos: ML modules can take parameters
17:49:33 <c_wraith> Demos: modules in ML can be parameterized, such that how you import them changes what they operate on.
17:49:49 <hpc> Demos: so you can say "for the duration of this particular import of X, t = Int and b = False"
17:50:00 <hpc> and you can then import X multiple times with different parameters
17:50:05 <prophile> quick question: modifyMVar_ is "only safe if there are no other producers for this MVar" - if I'm only modifying it via modifyMVar_ is it safe?
17:50:14 <c_wraith> prophile: yes
17:50:16 <shachaf> prophile: Yes.
17:50:21 <prophile> lovely
17:50:21 <hpc> this is one alternative to type classes for adhoc polymorphism
17:50:22 <prophile> thanks
17:51:01 <Demos> I mean that is great but not really nessassary, I feel like haskell's modules are designed for structureing code and they do that nicely
17:51:37 <prophile> the lack of control over exporting instances is a little frustrating
17:52:02 <mjrosenb> hpc: you can also give each module its own set of 'globals', which I've found very useful for having global unique id conuters on a per-module basis.
17:52:07 <xplat> Demos: haskell's modules are designed for 3 things, separating code into multiple source files so that it can still be found, really basic information hiding, and namespace management
17:52:26 <Demos> well the idea is that if something is an instance of a typeclass then it has some basic properties that you want to let people access
17:52:43 <xplat> and they basically get those things done in a minimalistic and kind of awkward way (the namespace management particularly is awkward)
17:52:46 <Demos> if you have seceret instance it is kinda pointless... right
17:53:14 <Demos> xplat, yeah true, I like how Go does it, have a package structure but then you access stuff through just one namespace level
17:53:14 <xplat> prophile: the way typeclasses work it doesn't really make sense to not export instances
17:53:53 <xplat> Demos: i'm not so familiar with Go
17:54:35 <Demos> think of it as like C but better and in all the ways C++ is not, it is simple, VERY simple
17:55:11 <Demos> it has first class functions, and interfaces that are kinda like objects but you dont say I IMPLEMENT THIS INTERFACE, you just have its methods... walk like a duck
17:55:25 <Demos> it has a syntax that makes it easy to parse
17:55:33 <Demos> and a very short spec
17:56:02 <xplat> Demos: those aspects i know about, because they are the headline bullet points, but the module system really isn't in the elevator pitch
17:57:03 <Demos> reall? well it has one
17:57:18 <Demos> it does not allow circular dpeendencies, and it enforces a package structure
17:57:54 <Demos> you export things but giving them a capitalized name (Foo not foo or _foo or _Foo) and you must import everything you depend on
17:58:07 <OffsetGoose> Is Go worth learning?
17:58:57 <lispy> OffsetGoose: Isn't Go mostly gaining traction where folks are burnt out on the complexity of C++?
17:59:03 <Demos> sure, it is also very easy to learn
17:59:12 <Demos> OffsetGoose, yes
17:59:32 <Demos> go is also very, very fast to compile
18:00:22 <xplat> ... even on golang.org i'm having trouble finding a useful description of the module system
18:00:54 <c_wraith> You mostly just import things directly from github, then get surprised when your code breaks.
18:00:56 <Demos> yeah golang.org is not fantastic, then neither is haskell.org...
18:01:02 <c_wraith> At least, that's what people tell me about go
18:02:20 <Demos> lol well s/github/hackage/ and you have haskell, other people's code sucks
18:02:43 <Demos> and I think you have to go get the code first then it just downloads to a folder called whatever.github.com/bla
18:03:32 <xplat> okay, go modules seem to basically be slightly worse than haskell modules
18:03:33 <Demos> http://talks.golang.org/2012/splash.article for a good discussion of the design goals of Go
18:03:47 <xplat> the one ray of sunshine is they disallow circular deps
18:04:16 <Demos> yeah, nothing in go is new, it is just really simple
18:04:27 <OffsetGoose> xplat: Does Haskell allow circular dep.s and if so, any idea why?
18:05:19 <byorgey> It does.  One should not use them.
18:05:21 <xplat> OffsetGoose: yes, and probably 'it seemed like a good idea at the time'.  but i don't really remember if it's even in the spec or just a ghc-specific (mis)feature.
18:05:22 <Demos> sometimes circular deps are usefull
18:05:46 <Gracenotes> combination of things in a strongly connected component is usually a sign of good software engineering
18:05:48 <xplat> Demos: you'll go on thinking that until you put it in practice, then you'll see
18:06:09 <Gracenotes> and possibly a hint for further factoring
18:06:56 <Demos> well I meant that there are cases where they have a point, but they are rarely worth the pain
18:09:26 <sm> in practice they are never used in haskell, since GHC makes them hard
18:10:34 <Clint> how would one do that?
18:11:15 <xplat> do what?
18:12:11 <dav> lol
18:12:21 <dav> do THAT
18:13:13 <Clint> xplat: have circular deps?
18:13:17 <sm> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
18:13:39 <Clint> ah
18:14:22 <Clint> i wish i had known that before
18:14:56 <sm> didn't not knowing it force you into a better organisation though ?
18:15:13 <Clint> no, it forced me into worse organization, i think
18:15:48 <xplat> ... 'i wish i had known that before' isn't really the reaction i expected from someone perusing that particular section of the GHC manual :)
18:16:52 <sm> well it forces the usual gathering of basic types into a Types.hs. I remember initially wanting to put each type in its own module together with the functions for operating on it...
18:16:56 <tabemann> that section of the GHC manual makes it pretty clear that that is not something one normally wants to do
18:17:02 <joeyh> sm: forced me into too many little modules or too few big modules
18:17:59 <Clint> sm: right, until you need Types.hs to depend on other stuff
18:18:21 <sm> Types.hs has to be at the bottom level
18:18:29 <Gracenotes> it is a good practice to separate a program into a directed graph with small fairly decoupled nodes, though, whenever possible
18:18:31 <sm> it took me a while to figure that out :)
18:19:08 <Clint> i suppose i could have separated my instance declarations from the types
18:19:35 <Gracenotes> well... Instances.hs is possibly best avoided, though
18:19:50 <Gracenotes> it would only be important ambiently, and makes orphans possible
18:20:02 <sm> I'd like to hear a report from someone using this feature extensively
18:20:34 <tabemann> little question I've been wondering about: why is if then else a special form in Haskell, when one can easily define an equivalent ifThenElse :: Bool -> a -> a -> a ; ifThenElse True a _ = a ; ifThenElse False _ b = b (I note that Agda essentially does that, except it uses a mixfix to reach the usual if then else syntax)
18:20:41 <sm> it's handy having an overview of the types in a single file.. except when it isn't
18:21:37 <sm> I mean, keeping types and their functions in the same module still kind of makes sense to me coming from OO-land
18:22:05 <sm> as an initial organising principle
18:22:06 <xplat> sm: my experience with the circular deps feature in a real project (i wasn't the one who put it in, and am now in the process of taking it out) indicates:
18:22:50 * tabemann is used to the idea of putting types together with modules, which he used to do when coding in OCaml, but in his latest project he's split out all the types into a Types.hs because of interdependencies between modules that would have arose otherwise
18:23:08 <Gracenotes> some mixfix is useful for avoiding parens. general mixfix would possibly wreak havoc on the parser.
18:23:31 <Gracenotes> as for why Haskell had it, well, I'm pretty sure Miranda had it
18:23:34 <xplat> sm: that it will take over your project like a cancer, create a huge snarl of interlinked dependencies, cause definitions to be idiosyncratically displaced because they would otherwise cause dependency loops that the feature couldn't resolve ...
18:24:25 <xplat> sm: ... lead to slow builds and make it impossible to extract aspects of a large project as libraries
18:24:35 <dolio> I second that.
18:24:39 <tabemann> of course Haskell did break with Miranda on a number of important points, such as type variables and placement of guards
18:24:54 <sm> xplat: aiee, you confirm my fears
18:25:10 <dolio> Our scala project at work is a ball of spaghetti, because it just lets you create circular deps.
18:25:32 <dolio> And that's after we went through and broke a lot of cycles way back. They've crept back in, I think.
18:25:38 <sm> it sounds like circular deps are only half supported, then
18:25:40 <xplat> tabemann: parameterized modules can help you get the best of both the Types.hs model and the circular deps model without actually using any circular deps
18:25:53 <Gracenotes> though wherever there is dependency, and the avoidance of cycles, there is always refactoring to invert dependencies. and that is never fun.
18:26:21 <tabemann> xplat: parameterized modules are something I miss from OCaml, but it seems like the designers of Haskell felt that type classes were enough
18:26:52 <DiegoNolan> how could you implement a doubly linked list or a graph in haskell?
18:27:05 <dolio> A lot of people would like parameterizd modules, but it's an open problem to make them work well with type classes.
18:27:21 <Gracenotes> late binding has never been a major priority in Haskell
18:27:40 <Demos> what like type Node = {Node, Int, Node)?
18:27:45 <dolio> And I think I'd rather not have parameterized modules than not have type classes.
18:27:56 <dolio> In practice.
18:28:05 <xplat> dolio: it's really a tough choice though :-/
18:28:10 <dolio> Yeah.
18:28:28 * tabemann wouldn't implement a doubly linked list in Haskell, and would probably use maps to implement linking for a graph...
18:28:39 <Gracenotes> DiegoNolan: well, there are zippers for traversing lists symmetrically
18:28:48 <copumpkin> you can do it, but an immutable doubly linked list isn't particularly useful
18:28:58 <byorgey> Demos: data Node = Branch Node Int Node
18:29:02 <tabemann> type classes solve so many problems that are poorly handled in many other languages, e.g. number overloading, that it would suck to get rid of them
18:29:12 <byorgey> Demos: that is a binary tree type, though, not a doubly linked list.
18:29:14 <dolio> I think our solution to the project at work is to break things up into separate projects, so you can't have circular deps across them. :)
18:29:19 <dolio> That's slowly making things better.
18:29:30 <Gracenotes> also, not all doubly linked lists are circular
18:29:37 <Demos> well a double linked list /is/ a binary tree
18:29:38 <sm> and now you have multi-package dependency hell ?
18:30:11 <dolio> Yeah. But at least every change doesn't require a 5-10 minute recompile.
18:31:09 <sm> unless you really need the change to be in that low-level lib.. but hopefully that becomes less frequent with the right packages
18:31:22 <tabemann> type Graph = Data.Map.Map Node [Node] (but this requires Node to be members of Ord...)
18:31:32 <dolio> Sure, there are some changes that will cascade.
18:31:55 <dolio> The problem is that with the old project, there's a ball of like 130 files such that if you change any of them, you have to recompile all of them.
18:32:21 <dolio> Sometimes the build system doesn't notice them all at first, too, so you recompile some twice.
18:32:25 <dolio> Or more.
18:32:26 <tabemann> (well, that's a *directed* graph at least)
18:33:13 * tabemann remembers a project he worked on a while back where he had to recompile an open-ended number of times before ant would build it right...
18:33:39 <xplat> good old fixpoint-by-hand
18:34:26 <dolio> It's a little funny in those cases, because the build system is trying to save work by only recompiling the necessities, but it ends up not figuring out the necessities until the second or third recompile, which wastes work.
18:34:52 <Demos> is there like ipch wierdness as well?
18:34:59 <xplat> (the 'keep hitting it until it stops squirming' build model)
18:35:14 <Demos> it works for autoconf!
18:36:05 * tabemann is thankful that on that project they *eventually* fixed that...
18:36:09 <Demos> echo $(ls -l /bin) " ... OK"
18:36:23 <Demos> ^probably invalid sh
18:37:02 <dolio> Anyhow, I've heard other people having this problem, too.
18:37:10 <dolio> Giving presentations about it.
18:37:18 <sm> dolio: ouch. That sounds a little more flaky than I'd expect from GHC
18:37:25 <dolio> And how they solved it by moving to a build system that rules out mutual recursion, even though it's allowed.
18:37:26 <Clint> Demos: that's valid, but not smart
18:37:31 <tabemann> I think dolio's working in scala there
18:37:33 <dolio> sm: No, this is Scala.
18:37:41 <sm> ah
18:37:54 <dolio> We don't have this problem with GHC, because we're all too lazy to learn how to write hsboot files.
18:38:29 <edvardkk> <-- newb. Any tips on fns in Control.Monad to do what I'm doing with the "spin" fn? http://hpaste.org/90385  I sortof want "reapplyM", or something :p
18:39:28 <Demos> it is really bad in C++, my personal project does not have mutual recursion (well except /one/ extern) but still compiles like a angry ice sheet, it is a bunch of static libs too which does not help
18:39:53 <Demos> for all the arguments for static linking it can be annoying during devel
18:41:06 <Demos> edvardkk, that nick is really funny
18:41:47 <edvardkk> I know... heard it before here
18:42:00 <dolio> By the way, who was making that wiki article or whatever with the list of easy things to add/fix in GHC for someone looking for random work?
18:42:04 <dolio> I just remembered one.
18:44:09 <edvardkk> Demos: actually, my parents considered edward for my first name as well. even worse :)
18:44:27 <Demos> no it is funny because edwardk
18:44:45 <edvardkk> I know!
18:45:05 <Demos> oh, right ... derp
18:46:07 <Demos> so apperently we may actually get Applicative => Monad
18:46:26 <thoughtpolice> dolio: carter was
18:46:34 <thoughtpolice> dolio: http://www.haskell.org/haskellwiki/Modest_GHC_Proposals
18:46:50 * tabemann remembers applicative vehemently arguing that that was a very bad idea...
18:47:32 <xplat> thoughtpolice: does this mean we're finally getting -feat-babies ?
18:49:06 <Demos> tabemann, really? I know it breaks some things but the plan was to say like return = pure
18:49:37 <Demos> I mean it would still break code.... but I think the effort to "tidy up" is worth it
18:49:46 <tabemann> Demos: he had some idea that only certain sorts of things were "real" applicatives... don't ask me
18:49:52 <thoughtpolice> i didn't really understand applicative's argument for it being a bad idea. something to do with ZipList being the only real reason we have Applicative or something? i dunno
18:50:09 <tabemann> thoughtpolice: that's what I got out of that...
18:50:35 <Demos> It may be a distinction between monad as a mathamatical construction and monad as a design pattern
18:51:07 <xplat> tabemann: i may not have understood the argument, but if i did understand it it was clearly wrong.
18:51:45 <Demos> I like that GHC has a _|_ milestone...
18:54:43 <xplat> tabemann: because Monad plus an Applicative (non-newtyped) that is not equivalent to return/ap is strongly against social norms for how these typeclasses should be used, and also much rarer than other sources of potential breakage from the proposal
18:55:26 <xplat> so it's partly pushing a currently-unaccepted idea that is mostly agreed as being bad, and partly raising a technical concern that is at best peripheral
18:56:15 <Demos> in any case I say if it is between mathmatical purity and beauty and practical utility we choose beauty
18:57:56 <tabemann> the main area of breakage I see with this are just forcing everyone to make their instances of Monad instances of Applicative as well if they have not already; and if someone made a type have *incompatible* instances of Monad and Applicative, well, that's their fault
18:58:48 * tabemann notes that under the GHC _|_ milestone they bothered to put in "Provide a Java Backend" as an entry, as if that is something that is ever going to happen
18:59:18 * tabemann shudders at the idea of tail recursion having to be turned into hidden while() loops or trampolining....
19:00:04 <Gracenotes> why, is it too much to ask to allow arbitrary jumps in code in the JVM?
19:01:19 <tabemann> because the people who designed the JVM didn't have the foresight to think of it, and then make excuses about how "code isn't supposed to have access to the structure of the stack" after the fact
19:02:19 <Demos> yeah I hear the JVM is designed in a pretty restrictive way, prolly part of the reason that the new java updats have been such ********s
19:03:19 <Demos> I suppose part of the reason is that you can design a runtime that supports language design concepts that will ever be created, or well you can but it is called a CPU
19:03:31 <mjrosenb> what is allowed, if not arbitrary jumps in code?
19:03:56 <tabemann> not all runtimes are equally restrictive, though; they could have designed something that looks much more like LLVM, which is properly a runtime
19:04:18 <edvardkk> mjrosenb: in-procedure jumps only
19:04:30 <Demos> mjrosenb, objects, lots of objects
19:04:48 <mjrosenb> edvardkk: oh, that makes sense (I guess)
19:05:03 <Demos> and tabemann, does that not forfit the advantages you get form a rumtime in terms of metadata?
19:05:37 <Demos> and what about coroutines, those are not new, does java just not support them at all?
19:06:22 <tabemann> there's a lot of things java doesn't support; they're just adding lambdas in Java 8, which you had to emulate with anonymous classes so far
19:06:56 <edvardkk> yep. probably compiling them to anon. classes still, though ?
19:07:04 <Demos> oh GOD I HATTTED that when I was using java, it was like to have an event listener you had to write all thiw horrable code
19:07:46 <Demos> c# was like ... yeah we got built in multicast deligates (which are a sort of castrated lambda I suppose)
19:07:50 <tabemann> and even then they're being stupid and, for an imperative language, aren't allowing you to set outer scoped variables from within lambdas (just like you aren't allowed to do that with inner classes), even though it's very possible, as many other imperative or semi-functional languages that support lambdas allow that
19:08:06 <Demos> wait what?
19:08:20 <Demos> like they are limiting you to pass-by-val
19:08:53 <Demos> if c++ could do it in a decent if not pretty way they should be able to as well
19:09:11 <tabemann> it probably is a hack to make it so they don't have to put stack frames onto the heap when closures point at them (by making the values simply be copied into the closure once)
19:10:20 <Demos> does c++ do that or does c++ just segfault
19:10:45 <tabemann> I don't know how lambdas work in C++11 myself
19:11:02 <tabemann> I suspect you can't return lambdas from functions in C++11 though
19:11:03 <edvardkk> yeah. who knows.. should not be impossible to wrap values in reference cells behind the scenes. it's been done
19:11:50 <orzo> doc for getAddrInfo flag AI_ADDRCONFIG The list of returned AddrInfo values will only contain IPv4 addresses if the local system has at least one IPv4 interface configured, and likewise for IPv6.
19:11:51 <tabemann> (whereas from reading about Java 8 it seems that you'll be able to return lambdas from functions)
19:11:54 <orzo> oops
19:12:01 <edvardkk> tabemann: you can return lambdas, but you must be careful with the memory (as always)
19:12:04 <orzo> anyway, the doc makes no sense
19:12:10 <Demos> you can return lambdas
19:12:20 <Demos> I think you can even return them as a function pointer type
19:12:31 <Demos> yeah, that is what I thought edvardkk
19:12:50 <orzo> return only IPv4 if theres a configured IPv4 interface and only IPv6 if there's a configure IPv6 interface?  and if there's both? what? explode?
19:13:28 <Gracenotes> functional programming in C++ is less like soaring the skies of abstraction and more like just walking, but with stilts.
19:13:50 <tabemann> lambdas without actual closures aren't very useful
19:14:20 <Demos> c++ has actual closures, but the things they close may get destructed without telling you
19:14:33 <Demos> yeah FP in C++ is much like FP in javascript I have found
19:14:39 <edvardkk> you can have actual closures in c++11, but it hurts the head to get the memory right
19:14:53 <Gracenotes> no, not really, FP in JavaScript can actually be quite flexible, if not a bit verbose at times
19:15:23 <Demos> I found myself writing like such.foo = Bla.bar.bind(window, param, function() {such.foo = Bla.dun.bind(window)});
19:15:28 * tabemann thought that JavaScript had *dynamic* scoping, but when he looked back recently what he read said that it had lexical scoing, apparently...
19:15:32 <Gracenotes> scope capture is a memory problem, however.
19:15:52 <Gracenotes> when you have lots of anonymous closures floating around. similarly in Python.
19:15:53 <edvardkk> I dunno. I would rather choose to do FP in C++, which at least has some kind of type system. IMO FP in js is extremely limited.
19:16:03 <Demos> tabemann, well the with keyword introduces a kind of dynamic scoping, but using that is as bad as goto
19:16:17 <dolio> Gracenotes: The official answer (as I recall) is that the security model rules out proper tail calls on the JVM.
19:16:38 <tabemann> dolio: which is as good as saying "it's not allowed by official policy"
19:16:42 <edvardkk> sounds strange.
19:16:44 <Demos> edvardkk, yeah, I have spent like 4-5 hours debugging spelling errors on a 2KLOC JS project
19:16:48 <dolio> Security managers are supposed to inspect the stack to see if someone they don't trust is on there.
19:17:15 <Gracenotes> dolio: yeah, when you use stack depth as a means of security, RTSes with different kinds of stacks altogether don't go so well.
19:17:37 <tabemann> as if security should rely on "inspecting the stack"
19:17:56 <Gracenotes> and, tbh, it is possible to go function-crazy with C++ or JS, but it's safer and saner usually to just use the idioms in those respective languages
19:18:00 <Demos> once something is on the stack is it not pretty much done pwning you?
19:18:02 <elliott> is it language bashing hour in #haskell again? :)
19:18:20 <tabemann> Demos: same thought here
19:19:26 <Demos> If I can get on the stack once I can get there many times, then all I have to do is call h4x0r.pwn() while the introspection code is distracted by the other thing on the stack downloading the internet
19:19:36 <mjrosenb> elliott: only in hours that are composite
19:19:38 <mjrosenb> elliott: or prime
19:19:41 <tabemann> Gracenotes: typically to do what one would do with functions in, say, Haskell or OCaml, I'm used to implementing abstract classes (in C++) or interfaces (in Java), which is always infinitely more baroque
19:19:48 <dolio> Is it better or worse than JavaScript not having proper tail calls because 'Microsoft said they won't implement it'? :)
19:20:40 <mjrosenb> dolio: implementation detail *handwaves*
19:20:55 <tabemann> since when are tail calls not trivial to implement?
19:20:55 <Demos> the sad thing about JS is usually someone (often MS but sometimes Apple or Google or Mozilla (rarely Moz)) implements some functionality really nicely then when the W3C standardizes it it is totally imcompatible with the existing implementations
19:21:01 <edvardkk> Hmm. Any tips for efficient alternatives to [Bool]. Should I just use Data.ByteString ?
19:21:17 <elliott> this seems like assuming Java's security model makes no sense and then showing that it makes no sense.
19:21:18 <Gracenotes> Data.BitString? :p
19:21:29 <Tekmo> What are you using the [Bool] for?
19:21:34 <edvardkk> haha. thanks :)
19:21:39 <edvardkk> Tekmo: GA genotype
19:21:48 <mjrosenb> tabemann: debugging.
19:21:55 <Gracenotes> although I just made that up... it does seem to exist
19:21:56 <dolio> edvardkk: Some of the array types have bit-packed boolean vectors.
19:22:05 <shachaf> I think there are unboxed arrays and vectors of Bools.
19:22:07 <tabemann> sure they fuck up debuggers, but that's a minor cost in comparison to what is gained with them
19:22:12 <Demos> a ton of languages that use JS for their target trampoline
19:22:17 <Tekmo> I think Vector Bool might do this
19:22:26 <thoughtpolice> i think the bit-vector package is basically a bit-packed wrapper around 'vector'
19:22:29 <thoughtpolice> @hackage bit-vector
19:22:29 <lambdabot> http://hackage.haskell.org/package/bit-vector
19:22:49 <Tekmo> I thought Unboxed Bool Vectors already did this
19:22:51 <Tekmo> Let me check
19:22:55 <edvardkk> Thanks, guys!!
19:22:57 <thoughtpolice> yep, you're right
19:23:04 <thoughtpolice> 'type BitVector = Vector Bool' :)
19:23:40 <Gracenotes> hm, are these constant-sized bitstrings?
19:23:49 <Tekmo> :)
19:24:13 <Tekmo> In either case, use bit-vector
19:24:21 <Tekmo> It has a nice API for this
19:25:33 <edvardkk> Tekmo: looks good! thank you
19:25:39 <dolio> tabemann: There's really no excuse. People have figured out how to get decent debugging info even with proper tail calls.
19:26:26 <dolio> It kind of amazes me how few languages support them.
19:26:35 <dolio> That's why Lua is the best.
19:26:36 <Demos> there is also this thing called the -O switch
19:26:45 <shachaf> dolio: Oh, Lua supports them?
19:26:50 <dolio> That's what I hear.
19:26:53 <Demos> imageine <meta dotailcalls/>
19:26:55 <tabemann> it seems like the implementors of typical imperative languages don't even think of it as something one might want to implement, as if it were some kind of blind spot
19:27:06 <Demos> well there are like a bajillion lua implementations right?
19:27:07 <Tekmo> Like sum types, arg!
19:27:18 <Tekmo> Thank god for Rust
19:27:25 * tabemann liked working in Lua
19:27:28 <shachaf> Hmm, they even use that name.
19:27:44 <prophile> Demos: where a bajillion is 2
19:27:49 <Gracenotes> Lua is quite a fairly flat language. not as in boring, but no massive cathedrals of language features to be found.
19:27:56 <Demos> yeah
19:28:05 <prophile> it seems like the language javascript should have been
19:28:16 <tabemann> prophile: that's exactly my thought about Lua
19:28:17 <Demos> no javascript should have been scheme
19:28:40 <tabemann> but parentheses!
19:28:50 <prophile> javascript IS scheme
19:28:55 <prophile> with c syntax, classes, and horror
19:29:04 <Demos> actually it /is/ pretty much scheme in but it is hanging out with all these OO guys and it feels lonely
19:29:13 <Demos> JS does not have classes
19:29:19 <prophile> no, it has objects
19:29:23 <Demos> it has prototype based inheratance, just like Lua
19:29:26 <tabemann> which are dictionaries
19:29:29 <shachaf> Is it language bashing hour in here?
19:29:32 <Tekmo> Does anybody know how to lock stdout?  The goal is to perform an atomic write to stdout without cooperation from other writers
19:29:42 <elliott> shachaf: <elliott> is it language bashing hour in #haskell again? :)
19:29:52 <shachaf> Language bashing is off-topic.
19:30:07 <shachaf> And even when it's on-topic this isn't the channel for it.
19:30:29 <tabemann> what channel is it on-topic in?
19:30:34 <thoughtpolice> -blah
19:30:38 <Gracenotes> oh man, you're just taking all of the fun out of the bashing
19:30:39 <geekosaur> afaik there is no public interface to handle locking
19:30:43 <shachaf> Tekmo: You can probably take the Handle yourself but it might be a bit fiddly.
19:30:53 <Tekmo> I'm okay with hacks, as long as they work
19:30:54 <shachaf> Not really an exposed API.
19:30:58 <geekosaur> (there's some stuff GHC uses internally but I don't know how documented it is)
19:31:17 <Gracenotes> ...yeah, I don't really see any particularly vitriolic statements being made here...
19:31:23 <Gracenotes> in any case statement.
19:31:49 <Gracenotes> or case expression, if you like
19:31:55 <Tekmo> > let statement = () in any case statement of () -> putStrLn "Hi"
19:31:56 <lambdabot>   <hint>:1:27: parse error on input `case'
19:32:00 <orzo> it looks like getAddrInfo isnt goo dnenough for me
19:32:10 <Tekmo> > let statement = () in any (case statement of () -> [True])
19:32:10 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Bool'
19:32:11 <lambdabot>              with actua...
19:32:31 <orzo> i need ip6 gethHostByName because I want all the names for a given address
19:32:39 <orzo> er, getHostByADdr
19:32:56 <shachaf> Tekmo: You can also put your own lock around it, assuming this is your own program.
19:33:05 <tabemann> that was my thought here
19:33:12 <tabemann> you can use an MVar for that
19:33:18 <Tekmo> shachaf: Normally I would do that, but this is a general purpose library where I can't guarantee all calls to stdout go through some lock
19:33:43 <tabemann> put it in the documentation "don't do that then!"
19:33:46 <Tekmo> Haha
19:33:56 <Tekmo> I may have to, but I was just checking to see if there was an alternative
19:34:09 <shachaf> You probably shouldn't lock stdout in a general-purpose library...
19:34:09 <tabemann> hmm
19:34:25 <shachaf> Anyway, here's hPutStr: https://github.com/ghc/packages-base/blob/master/GHC/IO/Handle/Text.hs
19:34:30 <Tekmo> I can summarize it pretty easily: this is for a console with concurrent input and output
19:34:37 <tabemann> could you use something in Posix per se, if you're on a UNIX platform, to make a write atomically?
19:34:47 <Tekmo> I'd be happy with Posix only if that is possible
19:35:02 <shachaf> There are a bunch of things that you'll have to think about, like buffering.
19:35:25 <Tekmo> How does it interact with buffering?
19:35:26 <Demos> console! haskell! do tell when this is released!
19:35:26 <tabemann> if you're trying to make writes atomic, you probably don't want buffering, but that will OTOH kill your performance
19:35:44 <geekosaur> POSIX write() on a file descriptor is atomic as long as you aren't writing more than a certain amount. all bets are off as soon as you bring in stdio
19:36:04 <Tekmo> No, it's nothing fancy
19:36:07 <Tekmo> Not a brand new console
19:36:08 <shachaf> geekosaur: Yes, but most likely you'll still care about GHC's buffering and such.
19:36:12 <geekosaur> yep
19:36:25 <Tekmo> Just a convenient wrapper around readline and handling concurrent output without clobbering the readline input line
19:36:35 <geekosaur> really as soon as you have any buffering, the concept of atomic IO gets rather difficult
19:36:59 <Tekmo> I'm okay with "almost works all the time"
19:37:22 <tabemann> advising the user "don't do that then" might be a better idea here
19:37:36 <geekosaur> also note that readline does its I/O at the level of C, so you get no control or even really awareness of it at the Haksell level
19:37:48 <Tekmo> In this case it is a console application, so turning buffering off is acceptable
19:37:53 <geekosaur> *Haskell
19:37:57 * geekosaur kan tipe gud
19:38:04 <Tekmo> Right
19:38:09 <Tekmo> readline is a royal pain to work with
19:38:29 <shachaf> It sounds to me like you want stdin/stdout entirely to yourself anyway.
19:38:29 <Tekmo> That's another reason why I can't rely on cooperation from other writers
19:38:37 <Tekmo> Because readline itself may use it to display completions
19:39:22 * geekosaur is thinking this is sounding more and more like "good luck with that, then"
19:39:29 <Tekmo> Haha
19:40:27 <OffsetGoose> I have to `seq` near all of my readline input
19:40:28 <Tekmo> Maybe it will be easier to rewrite readline from scratch
19:40:57 <shachaf> There is haskeline
19:41:07 * geekosaur also notes that this kind of stuff is like the #1 reason to switch to GUI, where you aren't limited to working with a single screen cursor
19:41:20 <Tekmo> I didn't know about haskeline.  Let me check it out
19:41:29 <shachaf> ghci uses haskeline
19:41:42 <Gracenotes> good-quality pure haskell libs++
19:41:42 <thoughtpolice> haskeline is great
19:41:49 <thoughtpolice> except for the part where it annoys shachaf :P
19:41:53 <Tekmo> Then I will try switching to haskeline
19:41:53 <shachaf> thoughtpolice: :-(
19:42:09 <shachaf> thoughtpolice: It's, like, so close and stuff, man.
19:42:21 * thoughtpolice pats shachaf on the back
19:43:00 <OffsetGoose> Sorry if this is off topic, but what is the best GUI framework with Haskell>
19:43:32 <Tekmo> What platform?
19:43:46 <geekosaur> there isn't really a "best" one, barring religious preferences, I think
19:43:50 <OffsetGoose> Windows preferably, but I'm running Debian
19:43:54 <shachaf> When you find out which one is the best, make sure to send emails to all the other ones telling them not to bother anymore.
19:44:15 <Tekmo> It pretty much boils down to "the one that you can successfully compile on Windows"
19:44:36 <OffsetGoose> shachaf: Haha let me rephrase, then: which is preferred, well developed, low bugs?
19:44:46 <tgeeky> the real answer is: the web browser UI, not a native UI
19:45:05 <OffsetGoose> HTML&css?
19:45:09 <Gracenotes> tgeeky: channeling you some Mozilla, eh
19:45:15 <tabemann> but the web browser imposes many restrictions upon you that aren't present with using a real GUI
19:45:17 <Tekmo> Speaking of which, ghcjs is getting pretty good now, from what I hear
19:45:31 <tgeeky> I still think it's the right answer
19:45:47 <tgeeky> otherwise the answer must be, what? GTK? wx? Qt?
19:46:07 <tgeeky> xmobar?
19:46:18 <Tekmo> Probably gtk or wx
19:46:20 * tabemann would use GTK himself, but then, he doesn't typically write code targeting Windows much except at work, and there he uses Swing (not in Haskell that is)
19:46:21 <Demos> the web browser is also a monster, a huge monster
19:46:39 <geekosaur> the Qt bindings haven't been updated in a while; Wx and Gtk+ interfaces are both actively developed
19:46:39 <Demos> is there a FLTK or tk binding?
19:46:43 * tabemann 's web browser likes to eat *all* his RAM, all 8 gigs of it
19:46:56 <Tekmo> I'd stick to something actively maintained
19:46:59 <Demos> yeah mozilla uses 400megs for me.....
19:47:02 <Tekmo> gtk and wx are still maintained
19:47:11 <isomorphic> Perhaps - look at wai-handler-webkit in yesod
19:47:13 <thoughtpolice> Tekmo: i just want it to be easier to build (ghcjs)
19:47:15 <Demos> there is always a windows API binding!
19:47:21 <tgeeky> my point is here, that you have to look at which you can compile on which OSes?
19:47:24 <tabemann> Demos: well I browse by breadth rather than by depth
19:47:24 <thoughtpolice> then again i haven't tried in a while
19:47:35 <tgeeky> at least with browser, you can belay that problem
19:47:36 <Tekmo> thoughtpolice: I haven't tried building ghcjs, yet.  How difficult is it?
19:47:38 <Demos> hm? winapi is huge in both
19:47:47 <Demos> and hard to use in both....
19:47:59 <Demos> the code generated by ghcjs is too large for my taste
19:48:08 <thoughtpolice> Tekmo: at one point even I thought it seemed a little tiresome, and I commit to GHC :P
19:48:16 <thoughtpolice> however, there is a Vagrantfile now, which is awesome
19:48:17 <Tekmo> thoughtpolice: Haha
19:50:30 <thoughtpolice> i've been thinking of adding a Vagrantfile to GHC for a while now, perhaps I can just steal luite's :P
19:50:46 <OffsetGoose> Is ghcjs in cabal repositories?
19:50:48 <OffsetGoose> or apt
19:51:22 <thoughtpolice> no, it's a fork, so it's not widely available (yet.) the plans are for it to become part of GHC however
19:51:55 <OffsetGoose> excellent, thanks
19:52:21 <Gracenotes> so, actually, is ghcjs geared more towards general computation in JS or toward web-browser specific APIs?
19:52:25 <isomorphic> thoughtpolice:   Do you happen to know the current relationship between ghc and llvm?  I recall there was integration a while back, but I didn't hear more
19:52:59 <thoughtpolice> Gracenotes: DOM-ish stuff is mostly what's there. i don't see any reason you couldn't make it work on node.js or something though
19:53:09 <thoughtpolice> (caveat emptor, i might be wrong)
19:53:32 <Demos> it has a pretty trivial FFI to JS
19:53:34 <thoughtpolice> isomorphic: GHC has an LLVM backend which requires some feature support. that is mostly the extent of the relationship :P
19:53:36 <Demos> AFAIK
19:53:46 <thoughtpolice> (feature support in LLVM, that is)
19:53:57 <Demos> GHC is mostally C-- right?
19:53:59 <thoughtpolice> unless you're referring to something else specifically
19:54:03 <watermind> is the commonad corresponding to the list monad (as in, derived from the same adjunction) used at all?
19:54:09 <elliott> ghc is mostly written in haskell...
19:54:47 <thoughtpolice> Demos: GHC is written in Haskell. C-- is one of the very low level IRs, the last one before it outputs 'final' code (which may be LLVM bitcode, or native assembly for your platform)
19:54:51 <shachaf> watermind: No, because it's not a Haskell type.
19:55:04 <Tekmo> watermind: I wasn't aware that you could implement that comonad in Haskell
19:55:11 <Gracenotes> everything being passed to or returned from a DOM-style function is strict, so strictness analysis might be more intensive than normal.
19:55:12 <thoughtpolice> (note: JavaScript does not qualify in the case of ghcjs, because it is generated from the STG representation in GHC, not C--)
19:55:15 <shachaf> watermind: (Well, depending on which adjunction you mean, I suppose. You didn't specify one.)
19:55:16 <watermind> shachaf: oh
19:55:35 <shachaf> Most likely you mean a comonad in the category of monoids or something like that?
19:55:40 <watermind> Tekmo: or maybe I wasn't aware that we couldn't :P
19:55:43 <watermind> shachaf: yes
19:56:39 <Tekmo> watermind: The issue is that I don't know how to split the list monad into the adjunctions
19:57:08 <watermind> I didn't make the whole derivation, to be honest, but skimmed through thought I understood what the result would... be apparently I missed something
19:57:15 <shachaf> Tekmo: ?
19:57:27 <watermind> Tekmo: well it's the forgetful functor and *
19:57:41 <Tekmo> shachaf: What are the two adjunctions I compose to get the list monad?
19:57:55 <shachaf> Tekmo: It's one adjunction.
19:58:00 <shachaf> Two adjoint functors.
19:58:02 <Tekmo> Yeah, sorry
19:58:05 <Tekmo> adjoin functors
19:58:07 <Tekmo> *adjoint
19:58:12 <watermind> it's just forgetful functor
19:58:18 <watermind> which gives you the set
19:58:26 <watermind> and *, which builds a free monoid
19:58:39 <joelteon> how much do monoids usually cost
19:58:47 <shachaf> Like watermind said, the forgetful functor : Mon -> Set and the free list functor : Set -> Mon
19:58:52 <Demos> $10
19:58:53 <Tekmo> The first one is free
19:59:35 <watermind> shachaf: why isn't it an haskell type?
20:00:00 <Tekmo> shachaf: So if I compose those two adjoint functors I get the list monad?
20:00:10 <shachaf> Tekmo: If you compose them in one direction, yes.
20:00:19 <Tekmo> shachaf: How do I implement those two functors in Haskell?
20:00:21 <shachaf> watermind: It's a comonad but not in the category that we're talking about.
20:00:33 <shachaf> Tekmo: Well, they aren't endofunctors.
20:00:43 <Cale> Tekmo: You don't, because Haskell is only one category...
20:00:55 <elliott> you can model other categories in Haskell and implement the list monad adjunction.
20:01:00 <elliott> I did it with shachaf once.
20:01:01 <dolio> Not only one, really.
20:01:16 <elliott> you want TypeFamilies but that's about it
20:01:19 <Tekmo> Cale: I call shenanigans on one category
20:01:29 <dolio> But you can't really slice out a category of monoids and homomorphisms nicely.
20:01:32 <Tekmo> Cale: see: mmorph
20:02:14 <elliott> dolio: yeah, you just wrap up a function and pretend.
20:02:30 <elliott> it's close enough.
20:02:47 <Tekmo> I think the important question is whether you get a useful comonad out of flipping the adjunction
20:02:55 <Tekmo> or whatever the term for it is
20:03:03 <Tekmo> composing the two adjoin functors in the opposite order
20:03:10 <watermind> Tekmo: that was my original question, when I thought you could implement it :/
20:03:31 <shachaf> You get a comonad, but not an instance of the normal Comonad.
20:03:32 <Cale> Tekmo: Well, there are various things inside Haskell which can be understood as categories in other ways, but for the purposes of this adjunction, you'll be thinking of Haskell as Set, and implementing the composite functor GF of the adjoint pair, rather than each one separately.
20:03:32 <watermind> was wondering if it had some known useful applications
20:03:35 <shachaf> (Or even the normal Functor.)
20:03:59 <Cale> The composite in the other direction, FG, is a comonad on monoids, which forms the free monoid on the elements of another monoid.
20:04:28 <Tekmo> So what is the Haskell implementation of that?
20:05:52 <shachaf> The comonad has extract = fold, I guess?
20:06:24 <watermind> shachaf: yeap that's what I'd expect
20:06:42 <Tekmo> > :t fold
20:06:43 <lambdabot>   <hint>:1:1: parse error on input `:'
20:06:45 <Tekmo> :t fold
20:06:46 <lambdabot> (Foldable t, Monoid m) => t m -> m
20:06:53 <shachaf> [m] -> m
20:06:54 <Cale> Well, if you think about a component of the counit, it'll be a map FGM -> M, where M is some monoid, G is the forgetful functor to Set, and F is the free monoid functor
20:07:26 <Cale> So, it will take a list of elements of this monoid M, essentially, and produce an element of M somehow. The natural thing for this to be is evaluation.
20:07:26 <shachaf> And duplicate = map (:[])?
20:07:33 <watermind> shachaf: yeap
20:08:46 <Cale> (that's the counit from the adjunction, even)
20:08:57 <Tekmo> This is neat
20:10:03 <Cale> and then the comultiplication goes FG -> FGFG, so it needs to somehow stick a GF in between the F and G, and the natural way to do that is to use the unit of the adjunction, whiskered as FηG
20:10:27 <Cale> (FηG)_X = F(η_(GX))
20:10:47 <shachaf> I.e. fmap return, for the appropriate values of fmap and return. :-)
20:10:49 <watermind> So, that should result in just what shachaf said no?
20:10:54 <Tekmo> Could we implement this as an instance of Comonad?
20:11:09 <shachaf> No, because it only works for monoids.
20:11:19 <Tekmo> Can't we package up the monoid constraint within the type?
20:11:31 <Cale> It's a comonad on the category of monoids, not on the category of haskell types
20:11:42 <shachaf> Not when you use the Comonad class.
20:11:42 <watermind> right
20:11:43 <Cale> The Comonad class only captures comonads on Hask
20:11:47 <shachaf> Which has to work with any type at all.
20:11:57 <Tekmo> Shucks
20:12:10 <watermind> it would work together with that trick for having optional contexts no?
20:12:24 <shachaf> Maybe.
20:12:25 <watermind> that same that can be used to have a Set monad
20:12:37 <Tekmo> But that requires a modified Comonad class
20:12:38 <shachaf> You also have to promise that your "functions" are monoid morphisms, in this category.
20:13:04 <watermind> oh
20:13:09 <watermind> good point :/
20:13:28 <Tekmo> However, there's nothing stopping you from defining the operations without making an instance of Comonad
20:13:37 <Tekmo> It's not like there are a lot of Comonad-generic operations out there anyway
20:13:43 <dolio> They already are.
20:13:55 <Tekmo> Is duplicate in a library?
20:14:08 <dolio> One is fold.
20:14:33 <dolio> The other is map (:[]), which I guess isn't defined, because it's barely ever used.
20:14:50 <Tekmo> Yeah, but there is a difference between knowing what they are and formalizing that knowledge into a package
20:15:02 <Tekmo> The people who weren't here for this discussion won't know any of this
20:15:12 <Tekmo> Putting it into a package and documenting this kind of thing is educational
20:15:39 <shachaf> Things can be educational without being a package.
20:15:43 <dolio> You're going to make a package with two functions that people almost never use to document this?
20:15:44 <Tekmo> Then write up a post or something
20:15:52 <Tekmo> But don't let it just wither away in an IRC log
20:15:56 <watermind> this would be way nicer with dependent types, where you could define a specific monoid to be parameterized by it's binary operation
20:16:14 <watermind> so that we could 'just fold it'
20:16:34 <Tekmo> Seriously, starting up a blog takes 2 seconds
20:16:42 <Tekmo> Write up a post, submit it to reddit, and you're done
20:19:42 <watermind> by the way... what about the stream comonad... what is the respective monad (and adjunction)?
20:19:49 <Tekmo> If you guys are really serious about teaching people then you should make the effort to write down your lessons.  You will reach a much broader audience that way
20:20:52 <shachaf> watermind: There is no one adjunction that makes a monad or comonad.
20:21:00 <shachaf> There are lots of them.
20:21:31 <Tekmo> shachaf: I think his question is "Which one gives you the most useful monad?"
20:21:34 <watermind> shachaf: true, but I thougt there may be a standard one, as   x and curry  for state and co-state
20:23:36 <watermind> shachaf: I think  unit a = aaaaaaaaaaaaaa...    and counit a:as = a    could work
20:24:04 <shachaf> watermind: What are the functors (/categories) here?
20:24:18 <watermind> categories, Set and Stream
20:24:32 <shachaf> What's Stream?
20:25:36 <watermind> (thinking...)
20:27:26 <watermind> my guess is that it should be Comonoid
20:27:37 <watermind> that should be the category
20:27:51 <watermind> with Stream being a particular kind of Comonoid
20:28:07 <watermind> much like list is a particular kind of monoid
20:28:15 <watermind> but I need to think this through
20:28:47 <shachaf> Comonoids aren't particularly interesting in Haskell.
20:29:19 <Tekmo> Well, even if they aren't interesting, just complete this line of thought
20:29:41 <Tekmo> Even though the Comonoid may not be interesting, the Monad instance that this gives rise to may still be interesting
20:29:48 <watermind> well streams are quite used
20:29:54 <shachaf> I don't know what the line of thought is so I can't complete it.
20:30:06 * byorgey doesn't see what streams have to do with comonoids
20:30:16 <byorgey> though I can't say I have any good intuition about comonoids.
20:30:21 <Tekmo> Well, I think return is obvious
20:30:27 <augur> comonoids huh
20:30:30 <Tekmo> return :: (Comonoid a) => a -> Stream a
20:30:37 <shachaf> Tekmo: ?
20:30:46 <Tekmo> This is the opposite of the fold
20:30:46 <watermind> it's just a repeat
20:30:47 <shachaf> What's Comonoid? What are the categories?
20:30:58 <shachaf> I thought the goal was to figure out an adjunction.
20:31:01 <Tekmo> It's the default comonoid for every value
20:31:06 <copumpkin> comonoids are real things, they're just really boring in sets
20:31:09 <Tekmo> counit a = ()
20:31:14 <Tekmo> comult a = (a, a)
20:31:20 <augur> so .. what, coempty :: a -> ()  coappend :: a -> (a,a)
20:31:24 <Tekmo> The "Comonoid" is just a pseudo-instance
20:31:27 <Tekmo> So it's 'repeat'
20:31:38 <copumpkin> http://ncatlab.org/nlab/show/comonoid
20:31:42 <Tekmo> 'repeat' is playing the dual of 'fold' in this case
20:31:44 <augur> copumpkin: :)
20:32:01 <Tekmo> So now we need to find the dual of 'map (:[])'
20:32:11 <watermind> Tekmo: tail
20:32:15 <watermind> kinda
20:32:21 <augur> i feel like the curry-howard correspondence doesnt really reveal its power until you have dependent types
20:32:22 <watermind> you get a list with all the tails
20:32:24 <augur> i mean
20:32:36 <copumpkin> heh, not really sure I'd say repeat is the dual of a fold though
20:32:36 <watermind> that's actually Data.tails I think
20:32:38 <Tekmo> Wait
20:32:41 <augur> consider Maybe as a propositional operator
20:32:51 <Tekmo> the join has to have type 'Stream (Stream a) -> Stream a'
20:32:56 <Tekmo> But tail has type 'Stream a -> Stream a'
20:33:03 <copumpkin> what are we talking about, anyway?
20:33:10 <shachaf> copumpkin: I have no idea.
20:33:27 <shachaf> I thought the idea was to figure out an interesting adjunction that makes Stream (-the-comonad).
20:33:27 <augur> intros are easy -- Nothing :: Maybe a -- and elims are also easy -- maybe :: b -> (a -> b) -> Maybe a -> b
20:33:30 <Tekmo> Oh
20:33:32 <Tekmo> It's map extract
20:33:37 <Tekmo> Because
20:33:42 <dibblego> init . tails
20:33:46 <Tekmo> 'map (:[])' is just 'map return'
20:33:51 <Tekmo> so the dual of that is 'map extract'
20:33:57 <copumpkin> o.O
20:33:59 <augur> the type doesnt add anything interesting that you didnt alreadt have, propositionally
20:34:11 <copumpkin> "map return" doesn't have a dual, unless you define what you're talking about
20:34:18 <Tekmo> I'm using the term loosely
20:34:21 <copumpkin> I can tell :P
20:34:24 <Tekmo> :)
20:34:31 <Tekmo> So I'll provide context
20:34:33 <augur> but with dependent types, it all comes back i think
20:34:35 <shachaf> Everything here seems to be used loosely.
20:35:03 <Tekmo> Earlier, watermind was asking what comonad you get if you flip the order of some two adjoint functors that give rise to the list monad
20:35:15 <Tekmo> They foudn an interesting pair of adjoint functors that create the following comonad:
20:35:25 <copumpkin> I have an agda file that gets the list monad from a pair of adjunctions
20:35:25 <watermind> Tekmo: the operations for the stream comonoid, if I'm not mistaken are, counit a = repeat a,  and duplicate = tails
20:35:28 <Tekmo> fold :: (Monoid m) => [m] -> m -- i.e. extract
20:35:36 <shachaf> copumpkin: I have a Haskell file that does that!
20:35:37 <Tekmo> map (:[]) :: [m] -> [[m]]
20:35:37 <copumpkin> the functors that lead to the list monad are typically not endofunctors though
20:35:41 <shachaf> copumpkin: (With a whole lot less in the way of laws.)
20:35:44 <copumpkin> so mine goes into a different category
20:36:03 <copumpkin> you have endofunctors that compose to make the list monad?
20:36:14 <Tekmo> Not endofucntors
20:36:18 <Tekmo> according to shachaf
20:36:20 <copumpkin> so the comonad
20:36:22 <copumpkin> is in another category
20:36:25 <Tekmo> Right
20:36:32 <copumpkin> which is fine, but you won't be implementing it in haskell
20:36:42 <Tekmo> I just showed you the two operations in question
20:36:49 <Tekmo> They aren't a useful instance of Comonad, but they are still useful functions
20:37:16 <copumpkin> for reference, https://gist.github.com/copumpkin/2663881
20:37:44 <Tekmo> So then watermind asked the flipped question
20:37:47 <dolio> They aren't an instance of Comonad at all.
20:38:00 <Tekmo> If 'Stream' is the comonad, what useful 'Monad' can we deduce from flipping some pair of adjoint functors that give rise to Stream
20:38:04 <dolio> _And_ they aren't very useful. :)
20:38:06 <elliott> -- Our category is pretty easy.
20:38:07 <elliott> Monoids : ∀ ℓ → Category (suc ℓ) ℓ
20:38:10 <elliott> very subtle, copumpkin.
20:39:10 <Tekmo> Just because you haven't found a use for it doesn't mean that it is useless.  By that reasoning, Haskell would be a useless language to most people
20:39:13 <copumpkin> Tekmo: what pair of adjoint functors did you come up with that gives rise to the stream comonad? or did you do the stream monad? cause I'm more curious about that one
20:39:30 <Tekmo> Well, I have no idea what the functors are
20:39:37 <elliott> copumpkin: nice cheap plastic imitation of univalence at the bottom there
20:39:38 <copumpkin> the stream monad is reader
20:39:39 <Tekmo> But i suspect the operations they give rise to should be 'repeat' and 'map extract'
20:39:47 <elliott> where you arrange for them to just so happen to be definitionally equal
20:39:48 <Demos> seriously, copumpkin, unicode ID?, owait that is agda
20:39:53 <copumpkin> elliott: <insert reference to a plastic watering can>
20:40:05 <watermind> copumpkin: that's a huge cat theory agda library you have there
20:40:25 <watermind> copumpkin: is it intended to become part of the agda libraries?
20:40:28 <copumpkin> watermind: it makes me super happy to have a bunch of enthusiastic people doing awesome things to it now that I don't anymore
20:40:31 <copumpkin> I doubt it :)
20:41:18 <elliott> formalised category theory libraries seem to mostly be exercises in fighting against intensional equality.
20:41:56 <dolio> Isn't that why everything is parameterized by an equivalence relation?
20:41:59 <dolio> Much more convenient.
20:42:05 <copumpkin> dolio: but then xplat went and took that out!
20:42:05 <elliott> right.
20:42:07 <elliott> that's the fighting.
20:42:09 <dolio> Oh.
20:42:14 <elliott> huh. how does it work then?
20:42:20 <copumpkin> >_>
20:42:30 <elliott> ah, I see.
20:42:31 <watermind> copumpkin: the stream comonad if I'm not mistaken is defined with   counit = head     duplicate = tails
20:42:35 <copumpkin> Tekmo: I'm not sure how that comes about. You have F : C -> D and G : D -> C such that their composition is the stream comonad, and you're saying that both of the operations are haskell functions?
20:42:40 * tabemann has been looking over tutorials on agda and has yet to wrap his brain around it so far
20:43:01 <elliott> copumpkin: is that in a branch?
20:43:09 <copumpkin> yeah
20:43:19 <Tekmo> copumpkin: I'm just following my intuition.  There is 0 rigor involved
20:43:21 <copumpkin> he's got two radical branches
20:43:57 <copumpkin> Tekmo: but I'm saying, unless you think stream comes from a composition of endofunctors, the functor morphism maps are not both going to be hask functions
20:44:31 <dolio> If you just dualize the list thing from earlier, the category is stream comonad coalgebras, and homomorphisms thereof.
20:45:02 <elliott> copumpkin: "clearly" the solution is just to go directly to an infinity-category.
20:45:05 <elliott> who needs equality.
20:45:14 * shachaf vanishes in a puff of orange smoke.
20:45:17 <Tekmo> copumpkin: Neither was the list version, but it turned out to be a useful function nonetheless
20:45:26 <copumpkin> I need a cubinder
20:45:41 * watermind needs sleep
20:47:36 <Aetherspawn> :t (:>)
20:47:37 <lambdabot>     Not in scope: data constructor `:>'
20:47:37 <lambdabot>     Perhaps you meant one of these:
20:47:37 <lambdabot>       `Seq.:>' (imported from Data.Sequence),
20:48:03 <Aetherspawn> :t (/.)
20:48:04 <lambdabot>     Not in scope: `/.'
20:48:04 <lambdabot>     Perhaps you meant one of these:
20:48:04 <lambdabot>       `.' (imported from Data.Function),
20:48:20 <Aetherspawn> > let a (/.) b = a + b in 1 /. 3
20:48:20 <lambdabot>   Not in scope: `/.'
20:48:21 <lambdabot>  Perhaps you meant one of these:
20:48:21 <lambdabot>    `.' (imported from D...
20:50:04 <elliott> copumpkin: hmm, is it the quotients branch? does this have something to do with Agda's experimental quotients that I know nothing about?
20:50:15 <copumpkin> agda's exponential quotients failed
20:50:18 <copumpkin> experimental, grr
20:50:22 <copumpkin> they were just a library
20:50:24 <copumpkin> no special support
20:50:58 <elliott> hmm
20:51:09 <elliott> okay. I'll dig further to try and figure out what this is doing then
20:51:23 <copumpkin> anyway, I think he is using that idea, assuming we do have quotients
20:51:30 <copumpkin> I can't remember
20:52:40 <elliott> is the idea just to postulate false equalities on a dummy wrapper data type to keep reduction?
20:53:33 <dolio> So, (Integer, enumFrom) is a stream comonad coalgebra, I think.
20:53:58 <copumpkin> elliott: https://github.com/copumpkin/categories/blob/quotients/Categories/Support/Quotients.agda
20:54:19 <elliott> copumpkin: oh, so they don't compute.
20:54:22 <elliott> yuk
20:54:55 <copumpkin> nothing for free :P
20:56:01 <elliott> well, I think Agda's module system is enough to let you cheat successfully, isn't it?
20:56:51 <copumpkin> I don't think so?
20:57:16 * elliott installs Agda to test his theory.
20:57:26 <copumpkin> :)
20:57:46 <copumpkin> how would you use the modules for it?
20:58:20 <elliott> by hiding the constructor so you can't pattern match on it.
20:58:48 <copumpkin> how would you get the equality?
20:59:01 <elliott> postulate it
20:59:07 <elliott> it's a lie, because you can disprove it by pattern-matching.
20:59:09 <copumpkin> then the equality doesn't compute
20:59:11 <elliott> that's why you don't export the constructor.
20:59:19 <elliott> copumpkin: but the elimination rule does.
20:59:28 <elliott> so it's strictly more computey than what you linked.
20:59:54 <copumpkin> oh sure, I doubt xplat was trying to be particularly computey
21:00:09 <copumpkin> if anything, it saves memory to avoid reduction in that library :P
21:00:21 <elliott> you've got me installing Agda and now you concede!
21:00:32 <copumpkin> oh no, uninstall it quick!
21:00:37 <copumpkin> before you get sucked in
21:01:14 <elliott> copumpkin: don't worry, I'm loyal to Coq.
21:02:40 <Demos> so... is there anything useful you can do in these nice little languages.........
21:03:38 <tabemann> Demos: I'm waiting for a dependently typed language that is actually useful myself
21:03:46 <elliott> Demos: Coq has been used to verify the four colour and Feit-Thompson theorems
21:04:25 <tabemann> (I'm particularly wondering if any of those languages have numbers beyond just natural ones)
21:04:45 <elliott> that's Idris' market.
21:04:51 <elliott> though people have done FRP stuff in Agda.
21:05:04 <copumpkin> tabemann: they have as much as you're willing to contribute
21:05:04 <Demos> but say I wanted to write a text editor or something?
21:05:06 <dolio> elliott: You can't just hide the constructor.
21:05:24 <dolio> Because matching on equality can still do bad things.
21:05:32 <dolio> The constructor leaks out in the type checker.
21:05:46 <elliott> dolio: that sounds like Agda's module system is flawed :/
21:05:47 <dolio> Unless you get really fancy.
21:05:50 <tabemann> copumpkin: IIRC Agda 1 *had* integers, but they took them out in Agda 2 because the theory doesn't work too well
21:05:51 * shachaf reäppears in a puff of orange smoke.
21:05:58 <dolio> No. Dependent types are flawed.
21:06:14 <elliott> hmm, maybe I need to write up what I'm thinking of to see why it's broken
21:06:15 <dolio> Go take Bob Harper's course on abstraction and types. :)
21:06:33 <sclv> i'm not sure wha's going on here
21:06:35 <dolio> He specifically mentions this, I think.
21:11:16 <tabemann> hmm... Idris is strict-evaluating
21:11:24 <dolio> elliott: Basically, I think you have to choose between things computing during type checking, and abstraction.
21:11:49 <dolio> Agda has abstraction, too, but it will prevent things from computing.
21:12:38 <elliott> dolio: does this mean the trick the HoTT people do to get their computey types working is broken too?
21:12:48 <elliott> since I think they do essentially the same thing
21:12:57 <dolio> It was broken at first. I don't know if they found a fix or not.
21:12:57 <elliott> (maybe it's only okay if you disable K??)
21:13:51 <dolio> I think they came up with some tricks to prevent things from computing quite as much.
21:15:17 <dolio> Like, if you define a _data_ type ⊤, then ⊤ -> A is weaker than just A in some ways.
21:15:56 <dolio> Because you do not get certain eta rules, so it is more opaque.
21:16:32 <elliott> http://homotopytypetheory.org/2011/04/23/running-circles-around-in-your-proof-assistant/ was the trick I was thinking of, fwiw
21:18:01 <Aetherspawn> any idea how to Binary.Get a 64-bit little endian signed Integer?
21:18:03 <dolio> Yes, that is the flawed version.
21:18:07 <dolio> I think.
21:19:09 <dolio> Because I can prove zero ≠ one with an absurd match, because zero ≠ one computes to Zero ≠ One, and Agda knows those are distinct constructors.
21:19:16 <dolio> Despite the constructors not being in scope.
21:19:27 <elliott> ah
21:19:41 <elliott> so the problem is essentially that Agda's pattern matching is too clever
21:19:50 <elliott> because it'll automatically fill in absurd cases?
21:20:07 <elliott> even though you couldn't actually write out the proof in longhand.
21:20:34 <dolio> If you delay them by a non-eta-expanding ⊤, though, that proof won't go through, because it requires functional extensionality.
21:20:58 <elliott> interesting
21:21:09 <dolio> But, I'm not sure that is even good enough.
21:21:29 <elliott> I find it hard to view this as anything but a flaw in Agda for supplying a proof of inequality that you couldn't actually write, but I may just be missing something...
21:23:31 <Aetherspawn> will hayoo ever come back up?
21:23:33 <dolio> I guess. But then you have to modify dependent pattern matching to take into account what information is in scope.
21:25:17 <elliott> that seems like a good thing
21:26:57 <dolio> I've actually noticed that flaw before.
21:27:19 <dolio> The old paper on it just takes disjointness and injectivity of constructors as a property of the theory.
21:27:36 <elliott> hmm, I forgot 90% of Agda hacking is writing out explicit universe levels.
21:27:37 <dolio> But that isn't valid with quotients or higher inductive types.
21:28:32 <kvda> What's a clean way of having 'let' in anon functions? ie. I'm doing a certain operation more than once and i want to remember it
21:29:15 <roboguy_> kvda: cleaner than just using let?
21:29:19 <dolio> Or certain parametricity axioms, I think.
21:29:48 <kvda> roboguy_, yeah like using let outside of the anon function itself
21:30:07 <kvda> i'm just asking if there's a better way, if there's not, let inside is ok
21:30:10 <roboguy_> you mean like let f = \x -> x + 1 in f 2?
21:30:29 <roboguy_> in that case, you can write let f x = x + 1 in f 2
21:31:17 <kvda> that looks about right.
21:32:04 <kvda> although not quite what i wanted, but at least it clears things up :) thanks roboguy_
21:32:14 <roboguy_> sure!
21:33:56 <OffsetGoose> kvda: The above ^ is anonymous function in let.  This is a let in an anonymous function -> f = \x -> let g x = 5*x+6 in gx
21:34:31 <kvda> yep, got it OffsetGoose
21:34:33 <kvda> thanks
21:38:04 <OffsetGoose> Hey all, I have a question
21:39:27 <OffsetGoose> A few people have told me that they don't like Haskell because it relies on indentation,
21:39:27 <OffsetGoose> but as far as I'm aware, you can just use { ; } in all of your do-blocks.  But my question is:
21:39:27 <OffsetGoose> are there any parts in Haskell where forced indentation is inescapable?
21:39:40 <shachaf> My answer is: No.
21:39:50 <lispy> What is the state of the art in managing a symbol table (and that sort of thing) in haskell?
21:40:08 <lispy> I feel pretty comfortable with parsing and AST representation in Haskell, but not with symbol tables
21:40:33 <copumpkin> isn't that just a map from names to something you want to store about them?
21:40:55 <lispy> copumpkin: yes, although I guess it helps to have distinct tames
21:40:57 <lispy> names*
21:41:04 <Gracenotes> people use reader monads sometimes depending on things?
21:41:29 <copumpkin> oh, edwardk had some sort of fancy name generator he was using for a while
21:41:32 <copumpkin> not sure what happened with that
21:43:44 <elliott> those few people are silly.
21:44:58 <OffsetGoose> elliott: I agree :-)
21:45:33 <OffsetGoose> Haskell's the best
21:45:43 <OffsetGoose> just sayin'
21:49:16 <tabemann> the main problem with reader monads is that the problem they solve, i.e. passing around data like configurations, is generally a lesser problem than, say, the problem of managing an even bigger monad transformer stack than before
21:56:10 <e19293001> \leave #haskell
21:56:54 <OffsetGoose> chuckles
22:02:05 <u_> i'm using aeson to parse some json into values made of standard types like [(Integer,Integer)] or whatever
22:02:37 <u_> and apparently i can't use typeclasses for that, even with synonyms?
22:06:52 <dmwit> u_: huh?
22:07:01 <dmwit> u_: Maybe put some code up on hpaste?
22:07:05 <kurak0t> /quit
22:12:56 <u_> nvm i just used a newtype instead
22:13:00 <u_> but it's still quite annoying
22:14:49 <u_> huh
22:14:50 <OffsetGoose> What's the difference between newtype and data?
22:15:00 <u_> i just realized that's the same reason there's a Product newtype
22:15:01 <shachaf> @google What's the difference between newtype and data?
22:15:02 <lambdabot> http://stackoverflow.com/questions/5889696/difference-between-data-and-newtype-in-haskell
22:15:02 <lambdabot> Title: types - Difference between `data` and `newtype` in Haskell - Stack Overflow
22:15:10 <shachaf> OffsetGoose: Is that answer unsatisfactory?
22:15:10 <u_> those monoid instances
22:15:32 <OffsetGoose> shachaf: thank you
22:15:48 <kurak0t> /NAMES list
22:24:21 <wereSheep> How do I fix http://hpaste.org/90389 ?
22:32:41 <OffsetGoose> wereSheep: it looks like you don't have a package installed
22:36:47 <wereSheep> OffsetGoose: which one do I need?
22:46:34 <OffsetGoose> Sorry mate, no idea.  Or maybe you need to reinstall a package.  Can anyone else help?
22:47:07 <wereSheep> I'm already installing into a clean env
22:57:47 <Demos> ugh it just took me like 30mins of hoogle fail to find join....
23:04:28 <klrr> hey
23:06:37 <CaptainK> hay is for horses, grass is free
23:07:57 <Demos> nomnomnomzzzzzzz
23:14:21 <arkeet> @hoogle m (m a) -> m a
23:14:22 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
23:14:22 <lambdabot> Test.QuickCheck.Property joinRose :: Rose (Rose a) -> Rose a
23:14:22 <lambdabot> Prelude concat :: [[a]] -> [a]
23:16:16 <elliott> arkeet: did you know the hoogle plugin has its own @more?
23:16:18 <elliott> except worse.
23:16:23 <arkeet> really
23:16:46 <elliott> yes.
23:16:48 <elliott> @hoogle+
23:16:48 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
23:16:48 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
23:16:48 <lambdabot> Prelude and :: [Bool] -> Bool
23:16:56 <elliott> it doesn't even tell you there's more.
23:17:02 <arkeet> there is always more.
23:17:09 <elliott> not really.
23:17:14 <arkeet> always
23:17:29 <elliott> :(
23:19:18 <neurocyte> orospakr, the ghc rts starts in between 150ms and 300ms on most of the Android devices I’ve tested
23:19:40 <orospakr> neurocyte, oh, that's not too bad. :)
23:20:17 <neurocyte> I haven’t done extensive testing though, that’s just from what android reports when starting the activity
23:22:02 <neurocyte> I think that sort of startup time is similar for any native app
23:37:28 <isomorphic> Can somebody explain what the ghc docs mean where they say "UNPACK indicates to the compiler that it should unpack the contents of a constructor field into the constructor itself"  -   what would be an example of the 'contents of a constructor field'
23:37:32 <isomorphic> ?
23:42:35 <opqdonut> isomorphic: it means that the field is "inlined", i.e. one pointer is eliminated
23:43:03 <opqdonut> so if you have, say "data MyData = Foo Int Int"
23:43:30 <opqdonut> a "Foo x y" in memory would be a "Foo" block with two pointers to Ints
23:43:42 <opqdonut> the pointers are necessary, in general, because of laziness
23:44:14 <Aetherspawn> How do I convert a Word64 into an Int64 ?
23:44:16 <zvrba> what is a 'kind' in Haskell?
23:44:22 <arkeet> Aetherspawn: fromIntegral maybe
23:44:30 <opqdonut> if you UNPACK that, it will be one Foo block followed by two Ints in memory, like a C struct
23:44:34 <Aetherspawn> Word64 is unsigned
23:44:36 <arkeet> zvrba: it's a thing that classifies types/type constructors. like how types classify values.
23:44:43 <opqdonut> isomorphic: did you get all of that?
23:45:20 <isomorphic> opqdonut:  I think so.   Does it really need a Foo block if unpacked?
23:45:35 <opqdonut> well it needs some block that contains the two ints :)
23:46:12 <opqdonut> in the case of one constructor I don't think it actually mentions "Foo" at all, but I'm not completely sure
23:47:07 <opqdonut> isomorphic: http://www.haskell.org/haskellwiki/Performance/Data_types might be of interest
23:47:14 <zvrba> arkeet: hm, type classifying values seems backwards. a value has a definite type, but multiple types can say that a value is of 'their' type (e.g.: Fractional? 3 = True ; Integer? 3 = True)
23:47:45 <zvrba> but I think I get the idea.
23:48:31 <opqdonut> zvrba: the type of the literal 3 is "Num a => a"
23:48:43 <arkeet> that's polymorphism.
23:48:54 <opqdonut> zvrba: both Fractional and Integer are members of the class Num
23:48:59 <arkeet> lately, haskell has kind polymorphism too.
23:49:24 <arkeet> so some things can have multiple kinds.
23:49:49 <opqdonut> zvrba: so the two 3's in that snippet get unified to different types
23:49:49 <zvrba> so what's the difference between a kind and a type class?
23:50:18 <opqdonut> they could be unified in some other language, but in Haskell they're quite separate
23:50:24 <ekipan> :k Int
23:50:27 <lambdabot> *
23:50:28 <ekipan> :k []
23:50:29 <lambdabot> * -> *
23:50:32 <ekipan> :k [Int]
23:50:35 <lambdabot> *
23:50:48 <arkeet> zvrba: e.g. Int and Maybe have different kinds.
23:50:51 <arkeet> :k Maybe
23:50:52 <lambdabot> * -> *
23:50:52 <isomorphic> opqdonut:  Understood.    Based on that document, it looks like there's some kind of metadata in the boxed data types that is necessary to support a pattern match
23:51:08 <ekipan> Int is a ground type, [] is a type contructor, [Int] is the Int type applied to [], resulting in a ground type
23:51:08 <arkeet> because it just doesn't make sense to replace Maybe with Int, for instance.
23:51:45 <arkeet> otoh, maybe it makes sense to replace Int with Char in some Num context. because maybe someone writes a Num Char instance.
23:51:58 <arkeet> type classes are like predicates.
23:52:15 <opqdonut> isomorphic: yeah, that's why the single constructor case is (or might be) treated specially
23:52:22 <arkeet> sort of.
23:52:44 <CaptainK> looks like Happstack is a cleaner WAF than Snap and Yesod, comparing only the Hello World output, anyone have a preference?
23:52:49 <zvrba> but predicates classify. kinds classify. so why the distinction?
23:53:22 <opqdonut> kinds are something we get from type theory, they are a natural extension of types
23:53:29 <opqdonut> type classes are something quite ad hoc
23:53:51 <opqdonut> with a rich kind system (subtyping on the kind level?) one could represent type classes using kinds
23:53:55 <opqdonut> but not in Haskell at the moment
23:53:56 <arkeet> :k Int -- this tells you that Int is an ordinary type.
23:53:57 <lambdabot> *
23:54:07 <arkeet> * is the kind of ordinary types.
23:54:10 <jfischoff> I have a question about catching exceptions from other threads: http://hpaste.org/90390
23:54:17 <arkeet> :k Maybe -- this tells you that Maybe takes a type as an argument, and returns a type.
23:54:17 <lambdabot> * -> *
23:54:34 <zvrba> ok
23:54:34 <arkeet> it's like a type for type constructors.
23:54:38 <opqdonut> yes
23:54:45 <jfischoff> specifically how do I go about it?
23:54:47 <opqdonut> kinds are types for types
23:54:53 <ekipan> :k StateT
23:54:54 <lambdabot> * -> (* -> *) -> * -> *
23:55:15 <arkeet> kinds are why stuff like
23:55:15 <opqdonut> (also, IIRC type classes are way older than kinds in Haskell)
23:55:21 <ekipan> :k StateT Int Maybe Char
23:55:21 <lambdabot> *
23:55:23 <arkeet> :k Maybe Maybe -- this doesn't make sense.
23:55:26 <lambdabot>     Expecting one more argument to `Maybe'
23:55:26 <lambdabot>     In a type in a GHCi command: Maybe Maybe
23:55:38 <arkeet> :k Maybe State
23:55:41 <lambdabot>     Expecting two more arguments to `State'
23:55:41 <lambdabot>     In a type in a GHCi command: Maybe State
23:55:48 <arkeet> because Maybe expects a type of kind *, while State has some different type.
23:55:51 <arkeet> er, kind.
23:56:04 <arkeet> it's a kind error.
23:56:22 <zvrba> so, functions over values => types, typeclasses ; functions over types => kinds
23:56:23 <zvrba> ?
23:56:31 <arkeet> nothing to do with functions.
23:56:43 <zvrba> well, 'functions'
23:56:49 <arkeet> "types"
23:57:22 <arkeet> there is a type of integers, and a type of chars. it is a type error to put one where the other is expected.
23:57:25 <zvrba> so type constructors have kinds, values have tyes?
23:57:28 <arkeet> yes
23:57:49 <arkeet> there is a kind of types (namely, *). there is a kind of type constructors that take one type as an argument (* -> *)
23:57:50 <zvrba> but type constructor is a 'function' that assembles a new type from simpler types.
23:57:51 <arkeet> etc.
23:58:05 <zvrba> hmm
23:58:07 <zvrba> wait a bit
23:58:10 <zvrba> confusion ensues :P
23:58:15 <arkeet> :k Monad
23:58:17 <lambdabot> (* -> *) -> Constraint
23:58:28 <arkeet> this tells you that Monad is a thing that takes a type constructor of kind * -> *
23:58:30 <arkeet> but it doesn't return a type.
23:58:44 <arkeet> it returns a constraint, i.e. the kind of thing you can put on the left side of =>
23:58:45 <zvrba> oh
23:58:53 <Aetherspawn> How can I run fromIntegral over a getWord64le?
23:58:56 <prophile> :k ContT
23:58:58 <lambdabot> * -> (* -> *) -> * -> *
23:59:09 <prophile> interesting
23:59:28 <arkeet> ConstraintKinds is also relatively new.
23:59:41 <ekipan> can anyone think of any more complexly kinded types?
