00:00:43 * hackagebot air-extra 2013.6.14 - air-extra  http://hackage.haskell.org/package/air-extra-2013.6.14 (JinjingWang)
00:00:45 * hackagebot yesod-pnotify 0.4.0.0 - Yet another getMessage/setMessage using pnotify jquery plugins  http://hackage.haskell.org/package/yesod-pnotify-0.4.0.0 (KatsutoshiItoh)
00:02:51 <Aetherspawn> Confusing, when I do something like r <- ask; forkIO $ runReaderT handleSocket r -- it works
00:03:06 <Aetherspawn> Bu when I do something like (forkIO $ ask >> runReaderT handleSocket) it throws a type error
00:03:17 <Aetherspawn> err, I meant >>=
00:04:36 <supki> :t forkIO
00:04:37 <lambdabot> Not in scope: `forkIO'
00:04:41 <supki> right
00:05:02 <johnw> as well it should
00:05:04 <Lemmih> Aetherspawn: You're calling 'ask' in two different contexts.
00:05:05 <johnw> forkIO wants an IO action
00:05:43 * hackagebot yesod-pnotify 0.4.0.1 - Yet another getMessage/setMessage using pnotify jquery plugins  http://hackage.haskell.org/package/yesod-pnotify-0.4.0.1 (KatsutoshiItoh)
00:06:24 <Aetherspawn> err, I meant >>=
00:06:26 <Aetherspawn> woops
00:07:00 <Aetherspawn> Windows dialog boxes popping up all the time messing up my tab order is less than perfect.
00:08:18 <shachaf> There is an easy solution.
00:08:53 <johnw> ask >>= forkIO . runReaderT handleSocket
00:09:53 <Lemmih> @seen ion
00:09:54 <lambdabot> I0n
00:11:17 <shachaf> preflex: seen ion
00:11:17 <preflex>  ion was last seen on #haskell 1 day, 6 hours, 55 minutes and 43 seconds ago, saying: http://packdeps.haskellers.com/reverse
00:11:38 <shachaf> ?where+ test preflex: seen ion
00:11:39 <lambdabot> Done.
00:11:40 <shachaf> ?where test
00:11:41 <lambdabot> preflex: seen ion
00:11:41 <preflex>  ion was last seen on #haskell 1 day, 6 hours, 56 minutes and 7 seconds ago, saying: http://packdeps.haskellers.com/reverse
00:11:52 <shachaf> OK, I can think of an easy fix for @seen.
00:14:42 <Aetherspawn> johnw, thanks
00:16:13 <johnw> Aetherspawn: you may want to define a helper: forkReaderT f = ask >>= forkIO . runReaderT f
00:19:26 <Aetherspawn> johnw, nice idea
00:21:46 <shachaf> Another way of writing that: forkReaderT m = do { x <- ask; forkIO (runReaderT m x) }
00:22:45 <dmj> This is a silly question, but, why do we need functor and monad instances for data (->) a b, if it has no data constructors
00:23:39 <shachaf> The instances are for ((->) r) for any r.
00:23:46 <shachaf> What do data constructors have to do with it?
00:26:19 <dmj> For Maybe, we implement (>>=) and return in terms of Nothing and Just. If we don't have data constructors, what do we use to make a complete instance? Two functions?
00:26:53 <johnw> dmj: have you looked at the instances for (->) r?
00:27:14 <shachaf> Better: Make the instance for (r ->) an exercise.
00:27:22 <shachaf> fmap :: Functor f => (a -> b) -> f a -> f b
00:27:26 <shachaf> f x = r -> x
00:27:33 <shachaf> fmap :: (a -> b) -> (r -> a) -> (r -> b)
00:27:45 <shachaf> Can you write that function? Can you prove that it satisfies the functor laws?
00:28:25 <shachaf> (The library implementation actually doesn't.)
00:28:37 <dmj> the functor laws are fmap id == id and fmap (f . g) == fmap f . fmap g
00:28:57 <shachaf> Yes.
00:29:11 <dmj> (.) == (b -> c) -> (a -> b) -> a -> c
00:29:29 <shachaf> (.) :: (b -> c) -> (a -> b) -> a -> c
00:29:30 <dmj> which is the same as what you defined earlier
00:29:49 <dmj> just with an r not a c
00:29:50 <shachaf> (.) is not a type.
00:30:09 <shachaf> OK. So can you show that it satisfies the laws you just mentioned?
00:31:23 <dmj> I don't speak math very well, but (r -> a) would take on id :: a -> a
00:32:11 <dmj> which is composed with (b -> c), which would also become (a -> a) and it would yield a -> a
00:32:42 <shachaf> I don't understand.
00:33:08 <johnw> dmj: are you familiar with equational reasoning?
00:34:20 <dmj> I just google and found this: http://www.haskell.org/haskellwiki/Equational_reasoning_examples
00:34:26 <dmj> "Haskellers of all levels are sometimes frustrated by not being able to understand the clever code produced by more advanced Haskellers"
00:34:29 <johnw> it's rather easy
00:34:39 <johnw> take the equation you want to prove: fmap id = id
00:34:52 <johnw> now, using what you know, transform "fmap id" step by step until it equals id
00:35:06 <dmj> ok so I know fmap :: (a -> b) -> f a -> f b
00:35:10 <dmj> id :: a -> a
00:35:19 <johnw> describe the operation taken at each step, and shows how its result transforms the expression toward your goal
00:35:19 <shachaf> You're going to need to know more things than that.
00:35:34 <shachaf> For example: You need to know what f is.
00:35:45 <shachaf> And: You need to know what fmap is.
00:35:48 <dmj> fmap :: Functor f :: (a -> b) -> f a -> f b
00:35:59 <dmj> => *
00:36:14 <shachaf> OK, what are you trying to accomplish?
00:36:15 <johnw> dmj: you'll need to perform your reasoning in terms of the goal functor, (->) r, not in terms of functors in general
00:37:00 <dmj> shachaf: I'm trying to prove that the identity functor laws hold for ((->) e)
00:37:14 <johnw> "functors in general" simply state the laws; the implementation of a particular functor carries the burden of proving those laws
00:38:12 <dmj> ok, so do I start with data (->) a b, id and fmap ?
00:39:08 <johnw> you gave a definition for fmap up above
00:39:13 <johnw> that's one of the things you can now use in your reasoning
00:39:14 <dmj> yes
00:39:48 <Aetherspawn> Can this be made simple: forall a.
00:39:49 <Aetherspawn>  ReaderT a ((->) a) (IO ()) -> a -> IO ThreadId
00:39:52 <dmj> ok, how do I go about substituting what I know into the type signature for fmap
00:40:23 <johnw> you don't substitute into any type signatures
00:40:31 <johnw> start with the law
00:40:49 <dmj> fmap id == id
00:40:51 <pxqr> Sometimes it's could be convenient to define a few instances for MonadState, e.g. `MonadState Foo Mo' and `MonadState Boo Mo'. Why do we need fundep in the transformers classes? Scary type errors?
00:40:52 <johnw> then start transforming the expression step by step based on your definitions
00:41:03 <johnw> if you can, by doing that, prove the expression is true, you have proven that law
00:41:46 <pxqr> with Reader the same
00:42:06 <dmj> johnw: Do I use type signatures to do the transformation
00:42:39 <johnw> how about I leave that to you to discover
00:42:46 <johnw> what would the first transformation be?
00:43:02 <shachaf> dmj: You are missing a very important ingredient.
00:43:33 <shachaf> Forget about fmap for a moment. Call your function foo. foo :: (a -> b) -> (r -> a) -> (r -> b)
00:43:38 <shachaf> What's the definition of foo?
00:43:53 <shachaf> You can't prove things about what it does without knowing that.
00:44:06 <dmj> shachaf: that looks like (.) to me
00:44:09 <shachaf> (Well, you can. But that's beyond the scope of this lesson.)
00:44:21 <shachaf> OK. Write out the definition.
00:44:43 <dmj> johnw: would I start by evaluating the left hand side of the equation? The fmap id portion
00:45:44 <dmj> (.) g f = f g
00:46:12 <Lethalman> huh?
00:46:16 <johnw> if fmap is (.), then fmap id == id changes into...
00:46:30 <dmj> @src (.)
00:46:30 <lambdabot> (f . g) x = f (g x)
00:46:30 <lambdabot> NB: In lambdabot,  (.) = fmap
00:46:39 <shachaf> Forget (.). Don't use (.). Write out the definition in your own words.
00:46:49 <Lethalman> dmj, that's a little different than f g
00:46:52 <shachaf> Or look up the definition instead, I guess...
00:47:34 <dmj> Lethalman: f g would return a function (a -> c), f g x would return just a c
00:47:56 <Lethalman> dmj, if f expects a you can't pass it a function
00:48:04 <Lethalman> f g is not f (g a)
00:48:36 <dmj> If the type signature ends with (a -> c) f g works, if it ends with c, I need f (g x)
00:49:06 <dmj> (b -> c) -> (a -> b) -> a -> c vs. (b -> c) -> (a -> b) -> (a -> c)
00:49:21 <Lethalman> depends on what f is
00:49:28 <dmj> oh, you're right. I do need x here
00:49:40 <shachaf> Those two types are the same.
00:49:40 <Lethalman> :t (.) id id
00:49:40 <lambdabot> c -> c
00:49:46 <Lethalman> :t id id
00:49:52 <lambdabot> a -> a
00:49:55 <Lethalman> well
00:50:01 <Lethalman> :t (.) map fold
00:50:09 <lambdabot> (Foldable t, Monoid b) => t (a -> b) -> [a] -> [b]
00:50:12 <Lethalman> :t fold map
00:50:12 <lambdabot> Foldable ((->) (a -> b)) => [a] -> [b]
00:50:25 <dmj> shachaf: applier f g x = g (f x), where applier acts like (.)
00:50:54 <shachaf> I think you would be best served by learning some more Haskell syntax and semantics and such before you try this proof.
00:51:03 <shachaf> But you can try it now if you like.
00:51:11 <dmj> I would like to try it now
00:52:18 <dmj> shachaf, what part of haskell semantics do you think I need to know in order to start proving laws?
00:52:55 <shachaf> For example, you should be able to write (.). :-)
00:53:49 <shachaf> Or maybe what you need isn't Haskell knowledge itself but one of those things monochrom talks about about testing hypotheses. I don't know.
00:54:01 <dmj> yes! I agree, this is the point I'm at. Like fmap fmap, and things like that. I need type intuition here.
00:54:29 <dmj> I like your example tho
00:54:30 <shachaf> Anyway, you've given a few definitions, like (.) g f = f g and applier f g x = g (f x), which have the wrong types.
00:54:44 <shachaf> You should get in the habit of asking the type checker questions.
00:56:11 <dmj> let applier f g x = f $ g x
00:57:16 <shachaf> And now without $
00:57:27 <dmj> let applier f g x = f (g x)
00:57:35 <shachaf> OK.
00:57:44 <dmj> let applier f g x = (f . g) x
00:58:09 <shachaf> You're not allowed to use (.) right now.
00:58:16 <shachaf> Now: I give you some value q, which can be anything.
00:58:17 <dmj> ok
00:58:45 <shachaf> Hmm, I give you a value q and a function h
00:59:00 <shachaf> You want to prove that applier id h q = h q
00:59:15 <shachaf> Do you see what to do?
00:59:23 <gspr> I talked to some of you (shachaf?) about this yesterday, but I had some questions I forgot to ask; for one, is there an unboxed STRef s a, so that readSTRef and writeSTRef become ordinary pointer dereferencing performance-wise?
01:00:23 <shachaf> gspr: No.
01:00:32 <shachaf> But perhaps there are other things that behave like what you want.
01:00:45 <shachaf> For example the FFI and Storable and Ptrs.
01:00:49 <gspr> shachaf: Yeah, you mentioned using tools from the FFI. That's definitely a possibility.
01:00:52 <shachaf> Or an unboxed ST array.
01:01:05 <gspr> Hmm yes, I didn't think of Ptrs
01:01:40 <gspr> Is there a technical reason why such performance can't be (or isn't) available in the ST monad?
01:01:52 <dmj> shachaf: Could I start by saying that the composition of any function with id is itself
01:01:57 <shachaf> Well, what primitive are you proposing?
01:02:11 <shachaf> dmj: You can start by saying anything, but you'll probably have to prove it.
01:02:15 <shachaf> I forgot a step.
01:02:18 <shachaf> You need a definition of id.
01:02:36 <gspr> shachaf: I don't know how the ST stuff works internally... but couldn't an STRef s a be unboxed somehow?
01:02:40 <gspr> (if that even makes sense)
01:03:23 <dmj> Do you want me to use proofs like induction, contradiction, contraposition
01:03:29 <shachaf> I'm not quite sure what you have in mind.
01:03:30 <gspr> I guess what I'm asking is - what's not available to the ST monad (technically/potentially) that is in IO?
01:03:49 <shachaf> Unsafe operations.
01:03:52 <gspr> (in terms of pointer-like constructs)
01:03:54 <Aetherspawn> the suggested forkReaderT has a funny type I can't make work
01:04:28 <gspr> but would unboxing STRef s a (if that even makes sense) be inherently unsafe somehow?
01:04:49 <shachaf> Aetherspawn: {-# LANGUAGE NoMonomorphismRestriction #-}, and read about what that means.
01:05:01 <gspr> (I know I'm probably asking stupid questions here… I just have no knowledge of how ST works internally)
01:05:01 <shachaf> gspr: The question isn't about safety but about making sense.
01:05:06 <gspr> shachaf: :)
01:05:17 <shachaf> Forget about ST and think about IO. They're mostly the same thing.
01:05:28 <shachaf> (In terms of implementation.)
01:05:34 <shachaf> What's your proposed primitive for IO?
01:05:46 * hackagebot cabal-rpm 0.8.1 - RPM package creator for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.8.1 (JensPetersen)
01:06:10 <gspr> shachaf: Is   Ptr a  boxed?
01:06:34 <shachaf> gspr: (By the way, note that even if you got whatever unboxed STRef thing you're after, it would still be a pointer to memory rather than e.g. optimized to register operations. But that's not exactly relevant to your questions.)
01:06:48 <gspr> shachaf: Right, I see.
01:06:51 <shachaf> gspr: I'm not sure what you mean by boxed or unboxed.
01:07:01 <Cale> ghci> :m + Foreign.Ptr
01:07:01 <Cale> ghci> :k Ptr Integer
01:07:01 <Cale> Ptr Integer :: *
01:07:07 <m_hyperbolic> How would you run through a list untill some condition is true, and then return the items on the place? Ie I want to first the first element where x / 2 is 4 in the list [1..10], which should return 8
01:07:08 <Cale> It's of kind *, so it's boxed
01:07:24 <gspr> OK
01:07:37 <shachaf> Yes, but I suspect gspr is being imprecise in their question.
01:07:47 <gspr> shachaf: I am. Sorry.
01:07:50 <Nisstyre> m_hyperbolic: takeWhile?
01:07:56 <MasseR> m_hyperbolic: find?
01:07:58 <Nisstyre> or actually you want dropWhile
01:07:58 <shachaf> gspr: This means a learning opportunity!
01:08:03 <gspr> shachaf: :)
01:08:07 <pxqr> if we have a datatype with { field :: !(IORef Int) } will strictness annotation make sense?
01:08:17 <Aetherspawn> > head [x | x <- [1..10], x/2 = 4]
01:08:18 <lambdabot>   <hint>:1:29: parse error on input `='
01:08:22 <Aetherspawn> > head [x | x <- [1..10], x/2 == 4]
01:08:24 <lambdabot>   8.0
01:08:32 <shachaf> gspr: Since you're working at this level: What memory layout are you thinking of for, say, a boxed STRef? An "unboxed STRef"? A Ptr?
01:08:35 <quicksilver> m_hyperbolic: find (\x -> x`div`2 == 4)
01:08:35 <Aetherspawn> m_hyperbolic, ^
01:08:43 <MasseR> > find (\x -> (x `div` 2) == 4) [1..10]
01:08:44 <lambdabot>   Just 8
01:08:47 <shachaf> Perhaps you should answer in #haskell-overflow
01:09:00 <m_hyperbolic> If my list is say [1..] would that run forever ?
01:09:14 <Cale> > find (\x -> (x `div` 2) == 4) [1..]
01:09:15 <lambdabot>   Just 8
01:09:32 <Nisstyre> > find (\x -> (x `div` 2) == 4) $ repeat 1
01:09:35 <Aetherspawn> m_hyperbolic, possibly, if the condition is never met
01:09:36 <lambdabot>   mueval-core: Time limit exceeded
01:09:44 <Aetherspawn> but x/2 == 4 is simple.
01:10:17 <gspr> shachaf: OK, so, if we think in C for a while, my algorithm essentially involves traversing something like a graph encoded by nodes with pointers to neighbors. Now, leaving out the obvious "find a better, functional, data structure" (I don't think there is one), I'm about to do this all with STRefs, but then kept reading that they can be very inefficient
01:10:20 <Nisstyre> find (not . collatz) [1..] may or may not terminate
01:10:48 <Cale> gspr: What if you just used an IntMap instead of the heap, and Ints instead of pointers?
01:10:54 <gspr> shachaf: I thought that was (partly) do to each readSTRef/writeSTRef being not one, but two, derefercings (one for unboxing, one for actually reading the memory address)
01:10:56 <m_hyperbolic> I think I can do what I want with find. Thanks everybody! :)
01:11:18 <gspr> Cale: Yeah, I've been considering that... it is definitely a possibility.
01:11:28 <Cale> gspr: I would try that first
01:11:36 <gspr> s/derefercings/dereferencings
01:11:46 <Cale> gspr: and only if it's too inefficient would I worry about trying to implement something lower-level
01:11:59 <shachaf> Cale: But understanding the memory layout and behavior etc. of STRefs is a useful thing to do regardless.
01:12:10 <gspr> Cale: OK. I'll have to consider my options a bit then. I might also just do this horrible stateful, low-level stuff in C and FFI it back in in the end.
01:12:16 <shachaf> Even if you can rewrite your algorithm in this case it's a good thing to know if you want to write fast Haskell code.
01:12:24 <quicksilver> gspr: I find it hard to believe you 'kept reading' they can be very inefficient.
01:12:32 <quicksilver> I've not seen that widely or often written.
01:12:38 <gspr> quicksilver: I exaggerated. I read one post :)
01:12:48 <quicksilver> In those cases where STRefs are inefficient I'd be surprised if the double dereference was the issue
01:12:54 <gspr> quicksilver: And then shachaf said something like "it looks worse than I expected"
01:12:56 <Cale> IntMap, or even just Map is usually efficient enough.
01:12:58 <shachaf> It's all in the The STRef Haters Handbook.
01:13:14 <gspr> (sorry if I misquoted you, shachaf )
01:13:18 <quicksilver> dereferencing memory is very fast if both intermediate and final location are in cache
01:13:28 <quicksilver> and if they're not in cache, then it doesn't matter if it's single or double deref
01:13:34 <quicksilver> it costs 100s of cycle either way.
01:13:37 <gspr> quicksilver: Hmm, ok, that makes sense
01:14:05 <pxqr> Cale: new dense IntMap's is neat
01:14:10 <fruitFly> I wanna get a list of all permutations of byte values from 2 - 40 bytes? i've been thinking list comprehension but not sure how to recursively increase the length bytes
01:14:17 <pxqr> IntSet's sorry
01:14:33 <johnw> > permutations [2..40]
01:14:34 <lambdabot>   [[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
01:14:49 <johnw> i don't think that's what you meant
01:14:50 <quicksilver> > ([2..40] >>= flip replicateM [0..255]) :: [Word8]
01:14:51 <lambdabot>   Couldn't match type `[a0]' with `GHC.Word.Word8'
01:14:51 <lambdabot>  Expected type: GHC.Types....
01:15:02 <gspr> quicksilver / shachaf / Cale: Thanks for the input, people :)
01:15:02 <quicksilver> something like that
01:15:22 <quicksilver> > ([2..40] >>= flip replicateM [0..255]) :: [[Word8]]
01:15:23 <lambdabot>   [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[0,7],[0,8],[0,9],[0,10],[0,11],...
01:18:07 <arkeet> > ([2..40] >>= flip replicateM [0,1])
01:18:09 <lambdabot>   [[0,0],[0,1],[1,0],[1,1],[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1...
01:18:17 <arkeet> neat
01:19:06 <johnw> nice
01:19:41 <arkeet> > [0..] >>= flip replicateM "01"
01:19:42 <lambdabot>   ["","0","1","00","01","10","11","000","001","010","011","100","101","110","...
01:20:11 <johnw> well, you have a lot of equivalent members in that set
01:21:18 <quicksilver> it wasn't clear to me which equivalence relation we were working under
01:21:46 <quicksilver> that gives you all words in the alphabet, with order significant and repeated letters permitted.
01:22:05 <quicksilver> I've no idea if it's computationally efficient, I've never tried to think about it.
01:22:17 <quicksilver> it's a good lambdabot parlour trick though
01:22:29 <johnw> yeah, the list monad is great for mind-bendy one-liners
01:22:34 <shachaf> If you want an easy way to understand equivalence relations, I recommend equivalence classes.
01:22:41 <shachaf> arkeet: ☝
01:23:21 <arkeet> equivalence relations are just equalizers
01:23:52 * quicksilver understands equivalence relations quite well thank you :)
01:24:15 <shachaf> Wow, this channel is unforgiving of puns.
01:24:25 <shachaf> Or maybe just my puns.
01:24:50 <quicksilver> if a glib comment with a smiley attached counts as unforgiving you have tough standards.
01:25:18 <arkeet> wait, I might have something backwards.
01:25:25 <quicksilver> but I wouldn't be opposed to a general motion that #haskell should not forgive shachaf's puns.
01:25:34 <arkeet> I already do not forgive them.
01:25:43 <shachaf> @quote quicksilver
01:25:44 <lambdabot> quicksilver says: but what about for other values of 2,3,5 and 7 ?
01:25:47 <arkeet> lol
01:25:52 <shachaf> Hmm.
01:26:02 * quicksilver denies saying that.
01:26:03 <mauke> preflex: quote-count quicksilver
01:26:04 <preflex>  quicksilver has 2 quotes
01:26:19 <quicksilver> "I have no recollection of that conversation, your honour"
01:26:39 <mauke> preflex: quote quicksilver
01:26:39 <preflex>  <quicksilver> learning from other people's mistakes is so web 1.0
01:27:14 <arkeet> yeah, not quite an equalizer, but it's still a pullback.
01:28:50 <arkeet> given a function f: X -> Y, the pullback of X -> Y <- X is naturally a subset of X x X given by {(x,x) : f(x) = f(y)}
01:28:52 <arkeet> er
01:28:59 <arkeet> {(x,y) : f(x) = f(y)}
01:29:11 <fruitFly> quicksilver: I looked up replicateM, but why the flip, and I'm not sure what >>= does... could you explain in a little more detail what's going on?
01:29:21 <arkeet> >>= is concatMap
01:29:26 <arkeet> for lists, anyway.
01:29:34 <quicksilver> as arkeet says
01:29:40 <arkeet> replicateM is some other thing.
01:29:59 <quicksilver> it's simpler to understand one case at a time
01:29:59 <arkeet> for lists it's just
01:30:07 <arkeet> > replicateM 5 [a,b]
01:30:08 <lambdabot>   [[a,a,a,a,a],[a,a,a,a,b],[a,a,a,b,a],[a,a,a,b,b],[a,a,b,a,a],[a,a,b,a,b],[a...
01:30:13 <quicksilver> ^^ right.
01:30:16 <arkeet> hmm, should have picked a smaller number
01:30:28 <johnw> replicateM 2 [1,2] ==> do { x <-
01:30:30 <quicksilver> replicateM in the list monad gives you all the words of length N using those letters
01:30:50 <quicksilver> the >>= flip trick was just to feed lots of different values into the first parameter of replicateM
01:30:54 <Nisstyre> > replicateM 5 $ Just "a"
01:30:55 <lambdabot>   Just ["a","a","a","a","a"]
01:31:03 <johnw> thanks, hit my return by mistake
01:31:19 <johnw> @type replicateM
01:31:19 <Nisstyre> > replicateM 5 $ Just 'a'
01:31:20 <lambdabot> Monad m => Int -> m a -> m [a]
01:31:21 <lambdabot>   Just "aaaaa"
01:31:37 <arkeet> replicateM for Maybe isn't very interesting.
01:31:49 <Nisstyre> > replicate 5 <$> Just 'a'
01:31:52 <lambdabot>   Just "aaaaa"
01:31:59 <Nisstyre> yeah
01:32:00 <arkeet> > replicateM 5 ("hi",())
01:32:03 <lambdabot>   No instance for (GHC.Base.Monad ((,) [GHC.Types.Char]))
01:32:03 <lambdabot>    arising from a u...
01:32:09 <arkeet> :(
01:32:17 <arkeet> I thought this lambdabot was on 7.6.3?
01:32:21 <fruitFly> arkeet: thanks
01:32:45 <arkeet> >>= and replicateM work for general monads, of course
01:33:18 <shachaf> arkeet: 7.6.3 doesn't have that instance.
01:33:21 <arkeet> no?
01:33:23 <shachaf> No.
01:33:47 <arkeet> where is that instance?
01:33:51 <shachaf> Nowhere.
01:33:54 <arkeet> why
01:34:07 <arkeet> Monoid m => (,) m is a fine monad.
01:34:25 <shachaf> The Bird is Cruel.
01:34:30 <shachaf> @let instance Monoid m => Monad ((,) m) where return x = (mempty, x); (a, x) >>= f = let (b, y) = f x in (a <> b, y)
01:34:31 <lambdabot>  Defined.
01:34:39 <shachaf> > replicateM 5 ("hi",())
01:34:42 <arkeet> wait, you can do that?
01:34:43 <lambdabot>   mueval-core: Time limit exceeded
01:34:45 <shachaf> > replicateM 5 ("hi",())
01:34:49 <lambdabot>   mueval-core: Time limit exceeded
01:34:51 <shachaf> In theory.
01:34:53 <arkeet> heh
01:34:57 <arkeet> > replicateM 5 ("hi",())
01:34:58 <shachaf> elliott: What's happening there?
01:35:01 <lambdabot>   ("hihihihihi",[(),(),(),(),()])
01:35:03 <shachaf> Oh.
01:35:07 <shachaf> Just the timeout.
01:35:29 <arkeet> @let data Foo x = Foo deriving (Show)
01:35:30 <lambdabot>  Defined.
01:35:32 <arkeet> > Foo
01:35:36 <lambdabot>   Foo
01:35:39 <arkeet> awesome.
01:35:59 <fruitFly> sry guys my client has been laggin, gonna look up >>= real quick
01:36:00 <elliott> shachaf: no idea
01:36:02 <elliott> I patched mueval and all
01:36:16 <shachaf> Patched it not to use the 7 * 700000 thing?
01:36:21 <shachaf> Praise be to mokus, elliott, et al.
01:37:57 <elliott> it seems to be timing out way too early
01:37:58 <elliott> but i don't know why
01:38:04 <elliott> and i'd rather rewrite the eval code than debug it
01:38:25 <shachaf> Sounds like you need a JIT evaluator.
01:47:00 <Nisstyre> > foldr1 (.) ((replicateM 8 (*)) 2) $ 1
01:47:02 <lambdabot>   256
01:47:50 <t7> guys, there was this conference a while ago where they had SPJ, the guy who made scala, the guy who made f# and other people talking about the future of functional programming languages
01:47:55 <t7> anyone remember what it was?
01:57:56 <dmj> shachaf: can we resume?
01:58:09 <alpounet> t7, wasn't it at Yow! ?
01:59:52 <t7> i duno that yow website is awful
02:00:23 <t7> it was an awesome session though, they should do it every year
02:01:38 <shachaf> dmj: ?
02:08:27 <dmj> schachaf!
02:08:37 <dmj> here
02:09:05 <dmj> shachaf: I believe we were at applier f g x, prove identity
02:10:03 <shachaf> You were at that.
02:10:11 <shachaf> Go for it.
02:11:33 <dmj> I don't know the necessary tools. By proof do you mean show that the type signatures align, or by example? fmap id (Just 4) yields itself. How rigorous do we need to be.
02:12:55 <shachaf> Forget about types. This is possible even without types.
02:13:23 <shachaf> But I don't think now is a good time for you to do this.
02:13:32 <dmj> shachaf: Why
02:13:54 <shachaf> I have nothing to add to what I said before.
02:14:47 <johnw> perhaps it would be helpful if dmj saw an example of this process at work
02:15:01 <johnw> and then attempted the second law
02:15:14 <johnw> otherwise, it's hard to know where to start if you've never done it before
02:15:30 <dmj> johnw: agreed
02:17:17 <dmj> shachaf: I can write all classes for Functor, Applicative, Monad, Monoid, and implement most prelude functions, data.list and control.monad functions and make functor, applicative, monad instances for Maybe, [], Either, etc. I view this as a next logical step.
02:17:50 <shachaf> OK.
02:20:39 <johnw> dmj: https://gist.github.com/5780606
02:20:50 * hackagebot nemesis-titan 2013.6.14 - A collection of Nemesis tasks to bootstrap a Haskell project with a focus on continuous integration  http://hackage.haskell.org/package/nemesis-titan-2013.6.14 (JinjingWang)
02:21:44 <johnw> dmj: let me know if any part of that is not crystal clear
02:21:51 <johnw> and then try to do the same for the 2nd law
02:21:53 <shachaf> johnw: It looks very much like you're begging the question when you write id = fmap id = ... = id, by the way.
02:22:23 <johnw> aren't I just required to prove that fmap id reduces to id?
02:22:57 <shachaf> Whatever you're required to prove, it probably isn't id = id
02:23:16 <shachaf> Your very first line is the thing you're trying to prove.
02:23:17 <johnw> i thought that was the end of equational reasoning, maybe I have missed something here
02:24:06 <shachaf> What?
02:24:18 <johnw> can you clarify what you mean by "begging the question"?
02:24:23 <johnw> i've seen that phrase used before
02:24:51 <shachaf> I mean that you're assuming what you're trying to prove. Never mind the phrase.
02:24:57 <Nisstyre> johnw: assuming the conclusion
02:25:01 <typoclass> johnw: i think in line 9 you can just delete the beginning, "id =", and you're ok :-) "fmap id ... stuff stuff ... = id"
02:25:09 <johnw> ah
02:25:12 <shachaf> Yes, that would be fine.
02:25:19 <johnw> thanks for that clarification guys
02:25:35 <shachaf> (Well, except I might complain about other details there, but not now.)
02:25:55 <johnw> my first step also missed an intermediate step
02:26:14 <johnw> what is the opposite of eta-reduction called?
02:26:22 <johnw> expansion?
02:26:34 <shachaf> Yes.
02:27:48 <typoclass> > reverse "eta reduction"
02:27:50 <lambdabot>   "noitcuder ate"
02:27:51 <johnw> ok, updated the gist
02:27:56 <johnw> also avoided implicit currying
02:28:00 <supki> I think it's also "substitute" not "substitude"
02:28:06 <johnw> huh
02:28:18 <supki> also the very first line is kinda odd
02:28:59 <johnw> dmj: as you can see, I'm not well-trained in these matters, and have never done it before an audience before, but you learn by the attempt when a proper instructor is not around
02:29:35 <merijn> I actually thought "id = fmap id" was clear, as in "let's show 'id = fmap id' by reducing fmap id to id"
02:30:12 <johnw> but I can see shachaf point, that this is really just one big equation.  if I start out with id = ... = id, then I'm assuming what I set out to prove
02:30:47 <shachaf> You wrote a justification for every one of your =s except the first one. If it's different it should look different.
02:30:54 <shachaf> Imagine I was proving 2*x = x+x. I couldn't write something like: x+x = 2*x = (1+1)*x = 1*x+1*x = x+1*x = x+x
02:30:54 <johnw> right
02:31:09 <merijn> shachaf: Oh, you read it differently than me
02:31:18 <johnw> so, dmj, does that help?
02:31:21 <dmj> johnw: Thanks a ton, It makes much more sense to me. Anything to help build type intuition. I wasn't expecting a proof to fermat's last theorem ;)
02:31:26 <merijn> I assumed the "id" part was left blank as it was implicitly the same
02:31:35 <johnw> as you can see, I haven't written any types here
02:31:45 <merijn> That's how I used to write down my high school derivations too
02:31:52 <johnw> this is just equational reasoning, proving that two things are equal
02:31:59 <shachaf> It's a shame you use fmap. Without type classes, types aren't necessary.
02:32:14 <shachaf> With type classes, they become necessary.
02:32:16 <merijn> shachaf: You're parsing it as a continuous line, rather than separate lines with the left hand side being left implicit
02:32:37 <merijn> I guess it's a matter of what you're accustomed to from school
02:32:37 <johnw> merijn: i read it your way as well, and I think I've seen that form used before
02:33:03 <johnw> dmj: why do you mention types, if I may ask?
02:33:10 <shachaf> johnw: By the way, your proof is wrong.
02:33:25 <merijn> johnw: Yes, it's the way algebra is generally taught in Dutch (and I imagine others too) high schools
02:33:25 <shachaf> Not just the proof but the thing you're proving. fmap id is not equal to id.
02:33:41 <shachaf> Can you find the mistake?
02:33:44 <johnw> looking
02:33:49 <johnw> don't tell me! :)
02:34:00 <merijn> shachaf: You mean that fmap id has a type constraint and id doesn't?
02:34:19 <shachaf> merijn: No.
02:34:23 <merijn> hmm
02:34:40 <johnw> fmap id is f a -> f b, and id is a -> a?
02:34:57 <merijn> johnw: That just means id is more general
02:35:05 <shachaf> Type classes make everythign complicated.
02:35:09 <shachaf> Forget about type classes.
02:35:13 <merijn> "fmap id" is "f a -> f a" which is a subset of "a -> a"
02:35:21 <shachaf> (.) id x /= x
02:35:30 <elliott> is this about _|_?
02:35:30 <shachaf> Why?
02:35:38 <shachaf> Of course it is.
02:35:51 <elliott> that seems a rather pedantic point
02:35:54 <elliott> morally correct and all that
02:35:57 <johnw> i'm proving (.) id x = id x
02:36:09 <Fubar^>     <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
02:36:09 <Fubar^>     <category enable="true" name="Config">
02:36:09 <Fubar^>         <node xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="Category" enable="true" name="persons">
02:36:12 <Fubar^>             <node xsi:type="PreLoaded" enable="true" name="bots">
02:36:15 <Fubar^>                 <block name="bot1">
02:36:17 --- mode: ChanServ set +o elliott
02:36:17 --- mode: ChanServ set +o johnw
02:36:17 <Fubar^>                     <icon variable="BOT" path="/bot1.png"/>
02:36:19 --- mode: elliott set +q Fubar^!*@*
02:36:19 --- mode: ChanServ set +o shachaf
02:36:20 --- kick: Fubar^ was kicked by johnw (Kicked by johnw)
02:36:24 --- mode: johnw set -o johnw
02:36:27 --- mode: shachaf set -o shachaf
02:36:27 <merijn> johnw: He means that fmap partially forces the value
02:36:27 --- mode: elliott set -q Fubar^!*@*
02:36:40 * elliott suspects that was just a mispaste
02:36:46 <johnw> yeah, so I didn't ban
02:36:49 <johnw> just wanted to stop the flood
02:37:01 <elliott> anyway, shachaf is right that the proof is incorrect if you care about _|_
02:37:04 <merijn> johnw: i.e. "id undefined" doesn't force undefined, but "fmap id undefined" does
02:37:06 <elliott> because eta reduction no longer holds.
02:37:21 <johnw> merijn: ah, subtle point, I tend to forget about _|_
02:37:25 <shachaf> elliott: johnw was trying to be very rigorous and proof-y. Pedantry isn't necessarily bad for exercises and figuring out where the mistake is is good practice.
02:37:26 <typoclass> johnw: thanks
02:37:27 <elliott> but I think this is a silly point to make; we usually prove typeclass laws assuming the absence of _|_.
02:37:33 <shachaf> In practice you don't care.
02:37:38 <merijn> Which seems a rather pedantic point of view for a "Fisher Price: My First Correctness Proof"
02:37:45 <elliott> Fubar^: mispaste? :)
02:38:01 <johnw> yeah, Fubar^ clarified in privmsg
02:38:01 <elliott> shachaf: I think even with full pedantry mode, the *statement* of typeclass laws is implicitly taken to exclude _|_, but fair enough
02:38:06 <Fubar^> elliott: yeah :)
02:38:09 --- mode: elliott set -o elliott
02:38:27 <merijn> Fubar^: Get a better IRC client :p
02:38:42 <merijn> irssi prompts you before pasting more than X lines ;)
02:38:50 <elliott> except it doesn't always
02:38:57 <Fubar^> merijn: Im using irssi, it didnt prompt me for anything
02:39:29 <johnw> elliott: why does \x -> g x not reduce to g if x is undefined?
02:39:46 <merijn> Fubar^: Check your config for "    paste_verify_line_count = "2";"
02:39:47 <shachaf> johnw: That's a good exercise.
02:39:57 <elliott> johnw: I think you're making a mistake in that question
02:40:01 <alpounet> t7, http://events.inf.ed.ac.uk/Milner2012/Monday_Panel-html5-mp4.html ?
02:40:02 <johnw> I thought the x there was "for any value of the type of x"
02:40:04 <elliott> in particular, it has a type error
02:40:05 <johnw> elliott: I bet I am
02:40:11 <elliott> johnw: anyway, consider that seq exists.
02:40:13 <merijn> Fubar^: See https://github.com/merijn/dotfiles/blob/master/irssi/config#L54
02:40:20 <elliott> shachaf's point only holds when you have both _|_ and seq on functions
02:40:24 <johnw> shachaf: these are great exercises!
02:40:33 <elliott> seq on functions is kind of a bug though, breaks extensional equality...
02:40:49 <t7> alpounet: that was it :) i don't think there will be another though...
02:41:02 <shachaf> ⊥ is also kind of a bug
02:41:04 <shachaf> Oh well.
02:41:11 <elliott> it's true.
02:41:20 <elliott> haskell's all bugs.
02:41:58 <alpounet> t7, phew! i think i would have stopped to look for it if that wasn't the video you were looking for
02:44:33 <johnw> shachaf: according to http://www.haskell.org/haskellwiki/Eta_conversion, the opposite of eta reduction is eta abstraction?
02:45:19 <johnw> elliott: the exact point you were making: http://www.haskell.org/pipermail/haskell-cafe/2007-December/036466.html
02:45:35 <shachaf> You can call it eta entrustibkation if you prefer.
02:45:51 * hackagebot yesod-pnotify 0.4.1.0 - Yet another getMessage/setMessage using pnotify jquery plugins  http://hackage.haskell.org/package/yesod-pnotify-0.4.1.0 (KatsutoshiItoh)
02:45:51 <shachaf> It doesn't matter much.
02:45:53 <johnw> oh, yes, that's very nice, eta-entrustibkation
02:46:12 <johnw> I like to know the common terminology
02:46:24 <elliott> I think "eta-expansion" is the common term
02:46:31 <shachaf> I called it eta expansion once.
02:46:46 <johnw> i already probably mispronounce half of the mathematical terms I've learned, since I never here them pronounced by mathematicians; better to not use the wrong word on top of it
02:47:07 <johnw> (or, in this case, type theoreticians)
02:47:24 <johnw> dmj: are you ready to attempt the second law now?
02:47:41 <shachaf> And on the other hand you misspell half the common English words, like "hear", since you only ever hear them spoken, right? :-)
02:47:48 * elliott mumble mumble parametricity.
02:47:54 <johnw> dmj: you should have everything you need, except you'll need to define (.)
02:48:07 <johnw> shachaf: it surprises me how often I think one word and write another
02:48:08 <elliott> the (->) instance seems a bad one to do these laws for.
02:48:17 <johnw> shachaf: the lateness of the hour definitely makes it worse
02:48:25 <elliott> since it runs directly into stupid _|_ problems and the law statement involves the function you write because it mentions (.)
02:48:52 <merijn> shachaf: That's an issue I have, I have learned the hard way that I appear to write English phonetically. So while typing I will substitute arbitrary words that sound the same, even though I know which word I *should* use
02:48:53 <shachaf> > (fmap id (undefined :: IO Int)) `seq` ()
02:48:55 <johnw> elliott: that's why shachaf introduced "applier"
02:48:56 <lambdabot>   ()
02:48:56 <merijn> It's a real pain
02:48:57 <shachaf> > (fmap id (undefined :: State Char Int)) `seq` ()
02:49:00 <lambdabot>   ()
02:49:03 <shachaf> johnw: I would never have introduced that name.
02:49:18 <johnw> oh, dmj did that
02:49:19 <johnw> n/m
02:50:01 <shachaf> johnw: Exercise: Fix the Functor instance to obey the laws.
02:50:25 <johnw> you mean, taking seq and ⊥ into account?
02:51:12 <shachaf> I,I (.) :: (exists x. (x -> c, a -> x)) -> a -> c
02:51:27 <johnw> what does I,I mean at the beginning there?
02:51:32 <elliott> it's an owl
02:51:36 <shachaf> It looks like an owl face to me.
02:52:32 <dmj> johnw: It just clicked, we turn the left side into the right side and assume fmap id == id. Isn't this called proof by substitution?
02:53:36 <merijn> @tell acowley ah, but the library you linked seems to just be for dealing with OpenGL, which is not the part I had problems with. My problem was that GLFW, unlike SDL doesn't provide a "poll event" function
02:53:36 <lambdabot> Consider it noted.
02:53:42 <johnw> dmj: the number of proofs I've done in my life now numbers 2, so I'm a bad person to ask
02:54:18 <dmj> johnw: could've fooled me ;)
02:54:24 <merijn> johnw: Liar! Everyone knows haskell can only be programmed by full blown professors in mathematics!
02:54:33 <johnw> oh, wait, duh
02:54:36 * merijn mumbles something about an ivory tower
02:54:39 <johnw> i'm forgetting about my adventures in Coq
02:54:49 <merijn> hah
02:54:52 <johnw> I was just thinking of "English-style written proofs"
02:54:52 <merijn> I was right, too
02:54:56 <johnw> no, scratch that, I've done plenty of proofs
02:55:22 <johnw> they're just easier when an incorrect step is impossible
02:55:33 <johnw> otherwise, you need shachaf-checking
02:55:55 <shachaf> Clearly we should measure mathematicians by twice their alcohol percentage.
02:56:29 <companion_cube> if you want english-style proofs, you can check mizar
02:56:56 <shachaf> johnw: On the contrary, they are much easier when an incorrect step is possible.
02:57:05 <johnw> fsvo easier
02:57:06 <int-e> isabelle!
02:57:48 <johnw> as long as I assume True = False, I can prove anything!
02:58:12 <int-e> (I've just seen students struggle with Mizar. The proofs may look readable but the proof checker is - that's the impression I got - not very helpful when it doesn't accept a proof.)
02:59:41 <dmj> johnw: Let's do law #2 next time. I need sleep
02:59:52 <johnw> you do law #2 and come back when you're done
03:00:00 <johnw> even if it takes a few days, it's worth smashing your head against it
03:00:17 <dmj> johnw: alright deal :)
03:00:24 <johnw> I think it took me nine days and many hours of thought to prove that the square root of three is irrational, but I'm extremely glad I spent that time
03:00:47 <johnw> in fact, I need to be less lazy in general.  note to self
03:01:16 <Zariel> Why cant i do (read bytestring), according to hadock there is a read instance for ByteStrings?
03:01:47 <shachaf> Zariel: You tell us!
03:01:56 <Zariel> String -> a!
03:02:07 <shachaf> Is that why?
03:02:46 <dmj> johnw: doesn't sound like laziness to me :) maybe the haskell kind tho. buh-dum-chi
03:02:47 <typoclass> Zariel: hello, a Read instance (capital R indicating a type or in this case typeclass) is responsible for converting *to* a type. e.g. instance Read Int makes in possible to convert to Int. (from String, it's always from String)
03:03:08 <dmj> it's late, I shouldn't make jokes
03:03:22 <johnw> wow, it took me until now to get htat
03:03:29 <johnw> even my humour is lazy
03:03:36 <Zariel> typoclass: thanks, forgot that read was String -> a, now I wish there was a "Text" typeclass as well ..
03:03:54 <Zariel> (read . show) :: a -> c
03:03:56 <shachaf> Zariel: Please remember that ByteString does not represent sequences of characters.
03:04:07 <Zariel> a sequence of bytes
03:04:13 <typoclass> Zariel: yes
03:04:29 <shachaf> And characters are not bytes.
03:04:44 <Zariel> depends what characters they are
03:04:51 <Zariel> and encoding
03:05:03 <elliott> they are not semantically the same even if their sizes coincide.
03:05:07 <Zariel> ascii is not bytes but iso8859-1 are bytes
03:05:11 <elliott> ...
03:05:13 <typoclass> Zariel: anyway, it's probably easiest if you convert the ByteString to String, then use 'read' on it
03:05:17 <typoclass> @where utf8
03:05:17 <lambdabot> A ByteString containing UTF8 can be decoded into a String with "Data.Text.unpack $ Data.Text.Encoding.decodeUtf8 theByteString", from the 'text' package. (There's also the 'utf8-string' package, but
03:05:17 <lambdabot> that is old and apparently not recommended.)
03:05:22 <typoclass> Zariel: ^^
03:05:59 <Zariel> typoclass: thank you
03:06:28 * elliott thinks depending on text to convert to String is a really bad idea.
03:06:59 <johnw> elliott: why is that?
03:07:34 <typoclass> elliott: feel free to add any corrections :-) i thought utf8-string was the thing to use, until last week. people (yitz and others) were telling me it's practically deprecated, and package 'text' should be used *shrug*
03:07:37 <elliott> because it's going to do silly things, maybe even memory-leaky things, from an operational point of view, and because it's depending on a package with all this rich unicode infrastructure only to subsequently ignore it by immediately discarding it
03:07:55 <elliott> well, I think the view there is more that String is deprecated? :)
03:08:09 <elliott> utf8-string has some slightly questionable stuff but it seems better than text if you are going to use String.
03:08:12 <merijn> elliott: Depends on how long your text is?
03:08:15 <typoclass> elliott: alright then. patches please :-)
03:08:23 <elliott> but here is the more pertinent issue: where did the ByteString come from in the first place?
03:08:33 <johnw> elliott: is BS -> T the problem, or T -> S?
03:08:52 <merijn> elliott: Sometimes you just read short text commands from a socket or something?
03:08:55 <elliott> johnw: the T -> S is the silly part that might leak (it might not, I don't know)
03:09:11 <elliott> merijn: ok, from a socket, sure (though doesn't GHC support setting an encoding on them directly and just using regular old string IO?)
03:09:13 <johnw> I do T -> S all over the place, so if it has inherent problems, please let me know
03:09:14 <typoclass> elliott: but i think decoding utf8 is an operation that needs some unicode awareness, so i don't think 'text' is quite so implausible
03:09:26 <elliott> for files, of course you don't have to go through ByteString to read a Unicode String from them, you can just use handle IO
03:09:54 <elliott> johnw: my thinking is that it likely retains the entire Text in-memory array, even as you let arbitrarily large portions of the resulting String gets GC'd
03:10:02 <elliott> this seems the most plausible way for it to be implemented
03:10:08 <typoclass> elliott: iirc http-conduit and friends keep giving you ByteString :-/
03:10:17 <johnw> ah, I see what you're getting at now
03:10:37 <elliott> not that this leak will always be a problem, but one good reason to use String is as a control structure, and control structures that leak memory kind of suck.
03:10:56 <johnw> g'night all
03:11:52 <typoclass> i also found it a bit odd that utf8-decoding a BS is supposed to be BS -> T -> S, but at least 2 people insisted that of the available ways, this was the best
03:12:06 * typoclass reverts to his default state of being happy and confused
03:12:28 <elliott> anyway, how about this: "A ByteString containing UTF-8 text can be decoded into a Text with Data.Text.Encoding.decodeUtf8. The utf8-string package provides the same operation with a String result."
03:12:39 <elliott> perhaps some mention that Text can go back to String if you really want.
03:13:46 <typoclass> elliott: sure, sounds good so far. i guess the remaining issue is the utf8-string-haters ... supposedly it's nearly deprecated, hasn't been updated in eleventy years
03:14:43 <elliott> typoclass: well, I really suspect those people just want you to decode to Text and then stick with Text as much as possible.
03:14:51 <supki> I'd rather depend on text than on some unmaintained package honestly
03:14:52 <elliott> which is reasonable; that's why I made the Text part the first sentence
03:15:00 <supki> yes
03:15:15 <typoclass> elliott: heh, a marketing maneuver
03:15:18 <elliott> anyway, 2011 is not really "eleventy years" for such a simple package
03:15:41 <shachaf> It's two thousand and eleventy years. Even worse.
03:15:43 <elliott> there's only so much you can change a simple UTF-8 decoder whose very type ensures it's not really competing on performance
03:16:07 <merijn> elliott: But software magically breaks if not updated every month!
03:16:10 <typoclass> elliott: right. personally i've never had problems with utf8-string, but people seem to be against it
03:17:16 <elliott> let's put it this way, bringing it back to the original question: you should give up on read long before you give up on utf8-string, because read is not something you should really be using almost ever. once you give up on read, you probably no longer need String
03:17:53 <merijn> elliott: readMaybe for life!
03:18:02 <elliott> readMaybe too :P
03:27:31 <typoclass> @where+ utf8 A ByteString containing UTF-8 text can be decoded into a Text with Data.Text.Encoding.decodeUtf8 (see package 'text'), and decoded into a String with Data.ByteString.UTF8.toString (see package 'utf8-string').
03:27:31 <lambdabot> Done.
03:27:51 <shachaf> That is still too long.
03:28:07 <shachaf> Maybe that can be fixed by fixing lambdabot's wrapping code, though (elliott:).
03:28:26 <shachaf> Also, I have the feeling that a lot of people who are asking about this will miss the central point.
03:28:56 <shachaf> And instead say things about ascii and byte-characters and all that nonsense.
03:29:11 <typoclass> shachaf: hm ... the earlier text for me just showed as two messages? nothing seemed to get silently suppressed or something
03:29:27 <supki> how about "A ByteString containing UTF-8 bytes..."
03:30:41 <merijn> shachaf: Blame C ;)
03:32:04 <typoclass> shachaf: true, it's more correct to use the encoding that (e.g.) you got by reading a http header that specifies it, but assuming utf8 is much more 21st-century than assuming ascii
03:32:28 <shachaf> No, that's not my point.
03:32:38 <shachaf> I'm all for using UTF-8.
03:32:52 <typoclass> shachaf: sorry, then i missed your point
03:32:59 <shachaf> I'm suggesting that people's confusion may be deeper than some simple API documentation can fix.
03:33:03 <shachaf> Maybe the answer is @where unicode.
03:33:09 <elliott> supki: "UTF-8-encoded text" is probably best
03:33:24 <elliott> anyway like I said someone should write a HaskellWiki page on ByteStrings and Text and Strings and encodings and stuff
03:33:28 <elliott> and then it can just be a link
03:33:39 <aoshi> is there a way to do the explicit type annotation for read when it's used by map for a list? eg blah = map read $ lines a_string
03:33:44 <typoclass> elliott: absolutely!
03:33:50 <mauke> aoshi: yes
03:33:51 <typoclass> shachaf: ah, right
03:33:55 <elliott> I nominate shachaf to write it.
03:34:00 <shachaf> map (read :: String -> Int), for instaance.
03:34:02 <elliott> he knows about unicode.
03:34:08 <aoshi> thank you :)
03:34:12 <mauke> map read ... :: [Int]
03:34:18 <shachaf> That also works here.
03:34:25 <shachaf> Also, map (\x -> read x :: Int)
03:34:47 <aoshi> ooh I like that
03:34:54 <elliott> (map :: (String -> Int) -> [String] -> [Int]) read ...
03:35:00 <elliott> what, why are you looking at me funny?
03:35:05 <mauke> type Unify a a = a :-(
03:35:35 <elliott> (map :: (a -> Int) -> [a] -> [Int]) read ..., even.
03:35:39 <elliott> so many great options.
03:36:23 <shachaf> mauke: Just use equality proofs instead!
03:37:27 <elliott> map ((id :: Int -> Int) . read) ...
03:37:51 <shachaf> map ((:: Int) . read)
03:37:57 <shachaf> (Not an option.)
03:38:10 <mauke> I want something that can take 'read' and 'a -> Int' and returns 'read :: String -> Int'
03:38:50 <typoclass> map (read :: ?a -> Int) ... does this work?
03:38:56 <typoclass> (genuine question)
03:39:05 <shachaf> I,I type Unify a b = (a ~ b) => a
03:39:23 <shachaf> (The opposite of what you want, of course.)
03:39:43 <elliott> type Unify a b = b <= )b ~ a(
03:39:44 <elliott> perfect.
03:42:33 <typoclass> ... argh, of course it doesn't work. i'm an idiot. value-level, not type-level
03:48:05 <typoclass> > let intify :: (a -> Int) -> (a -> Int) ; intify = id in map (intify read) ["123"] -- fantastic
03:48:08 <lambdabot>   [123]
03:49:25 <mauke> :-/
03:49:51 <elliott> hm, that's a good point
03:50:07 <elliott> mauke: type U a = a -> a; u :: U a = id
03:50:13 <elliott> mauke: (u :: U (a -> Int)) read
03:50:14 <typoclass> mauke: i guess it would only help if Prelude contained 'intify' and a ton of related functions. plus, if ghc somehow auto-derived one for each type you write yourself
03:50:16 <elliott> close enough for you?
03:52:19 <typoclass> elliott: wow, right
03:52:28 <shachaf> @let type V a b = a ~ b => a
03:52:29 <lambdabot>  Parse failed: TypeFamilies is not enabled
03:52:33 <shachaf> ?
03:52:41 <shachaf> elliott: Can you turn on all the goodies?
03:52:50 <shachaf> That isn't even a type family.
03:52:50 <mauke> :t def
03:52:51 <lambdabot>     Not in scope: `def'
03:52:51 <lambdabot>     Perhaps you meant `dff' (imported from Data.Graph)
03:52:56 <elliott> they are on. they don't get applied to @let and > or something.
03:53:04 <elliott> it's messed up, yes.
03:53:12 <shachaf> Can you fix it?
03:53:14 <elliott> I think 90% of the pragmas in L.hs are currently doing nothing
03:53:29 <shachaf> You don't turn them on in L.hs, not for mueval.
03:53:33 <elliott> shachaf: don't know how. might look into it. suspect it involves moving a huge list of pragmas elsewhere and maybe patching the code
03:53:34 <shachaf> You pass them as -X flags directly.
03:53:40 <elliott> tell that to upstream
03:53:48 <elliott> also does @let even use mueval?
03:53:49 <shachaf> You are upstream.
03:56:33 <typoclass> elliott: heh, you don't even need u, just U
03:56:49 <elliott> and use id instead of u or such?
03:56:52 <typoclass> «map ((id :: U (a -> Int)) read) ["123"]» works for me, given type U a = a -> a
03:57:30 <elliott> right
03:57:38 <elliott> I just defined u because it is one letter shorter
03:57:54 <typoclass> i thought U was Data.Monoid.Endo, but it's a newtype
03:58:02 <typoclass> elliott: sure ;-)
04:01:34 <fruitFly> When I run "cat base64String.txt | ./file" I get: "mat: mat.hs:189:71-135: Non-exhaustive patterns in case" I want to add a trace show to see what's going in I think the base64toIndices function (or the createBase64bytes function). Is trace show what's appropriate here? How do you think I should implement it? http://ideone.com/qVYcqw
04:04:20 <ramses_> fruitFly: on compilation, GHC should warn you about the non-exhaustive pattern, doesn't it?
04:05:43 <typoclass> fruitFly: (you may need to use "ghc -Wall", i'm not sure if it warns you without -Wall)
04:06:21 <fruitFly> ramses_: no it didn't
04:06:40 <merijn> fruitFly: Compile with -Wall
04:06:44 <fruitFly> uugh.. sry guys my client is lagging
04:07:02 <fruitFly> ok so like "ghc -wall file file.hs"?
04:07:35 <typoclass> fruitFly: capital W ... "ghc -Wall file.hs"
04:08:38 <typoclass> fruitFly: your error message mentions line 189, which contains "case base64toBytes ... of Just -> ...". the case "Nothing ->" is missing. the cause must be that base64toBytes gives Nothing for some inputs, and the caller doesn't handle that
04:08:40 <ramses_> fruitFly: and maybe an -fforce-recomp to make it actually recompile the binary
04:09:50 <fruitFly> typoclass: I will never give it nothing. Does it still need that?
04:10:03 <fruitFly> typoclass: and how do I add the nothing case inline?
04:10:06 <ramses_> fruitFly: it may give you nothing, I suppose
04:10:26 <ramses_> and I just wouldn't inline everything like that, it's really hard to read
04:10:33 <typoclass> fruitFly: er, well :-) you did give it Nothing. that's what that means ... "mat.hs:189:71-135: Non-exhaustive patterns in case"
04:10:48 <typoclass> fruitFly: yes, your lines are very long
04:11:17 <fruitFly> typoclass: oh lol, I thought my input (which is being passed from there to another function failed there).
04:11:18 <fruitFly> hmmmmmmmmmm
04:11:19 <ramses_> fruitFly: line 60, you do return Nothing
04:11:57 <typoclass> fruitFly: because of line 59, we can assume the cause is that function base64valid gave False on your input
04:12:05 <ramses_> if that case cannot happen (but apparently it can) it should not return a Maybe
04:13:40 <fruitFly> hold one, non ehaustive case on line 189, but it's refrencing an 'Nothing' from base64toBytes?
04:14:00 <fruitFly> typoclass: ramses_ ^
04:14:16 <typoclass> fruitFly: yes, line 189 says "case base64toBytes ... of Just ...". that's a call to function base64toBytes isn't it
04:14:29 <fruitFly> yes
04:14:29 <fruitFly> ok
04:14:42 <ramses_> fruitFly: base64toBytes returns a Nothing there, and then you pattern match and only give a branch for a Just
04:15:24 <fruitFly> so if I returned 'Nothing', how is that non-exhaustive? wouldn't I get some other error message? typoclass ramses_ ?
04:15:41 <fruitFly> oooooooooooooooooh
04:15:41 <merijn> fruitFly: Your *match* is non-exhaustive
04:15:42 <fruitFly> ok
04:15:45 <fruitFly> I get it
04:15:48 <ramses_> fruitFly: the case statement is incomplete
04:15:49 <merijn> fruitFly: It doesn't know what to do when you get Nothing
04:16:02 <fruitFly> so I have to ass the case for Nothing in like 189 to get something else
04:16:10 <merijn> yes
04:16:31 <ramses_> fruitFly: I would start by chopping that way-too-long line into pieces
04:16:40 <fruitFly> ok... urgh... why the hell is it getting nothing? right, because base64valid is failing... I wanna trace that!
04:16:49 <ramses_> it will become a lot more clear then, I think
04:17:25 <fruitFly> ramses_: yes ok, i not very experience with the constructions that do so, lets and where's? I might might just make many little sub functions
04:17:35 <fruitFly> typoclass: merijn ... tips guys?
04:18:24 <typoclass> fruitFly: i think there's at least 2 things you should fix. 1., the program should give a better message on invalid input. you should include something like   Nothing -> error "Input is not the correct base64 format"  2., base64valid should be better organized. it seems quite long and complicated to me. you're right, you should use 'where'
04:19:21 <fruitFly> typoclass: ok, not experienced with wheres and lets, but I'll think about it
04:20:23 <typoclass> fruitFly: the basic form is simple. func arg = a ++ arg where a = "abc"
04:21:13 <fruitFly> typoclass: ok thanks :).. and I'll look back on lyah too
04:21:19 <ramses_> with the where on a new line, mostly
04:21:30 <fruitFly> ramses_: yes
04:26:57 <stdnt> Hi. Why does pi + 1 is correct but "let a = 1 pi + a" is not correct?
04:27:50 <merijn> stdnt: What is "1 pi"?
04:28:13 <stdnt> "let a = 1 (new line) pi + a"
04:28:34 <merijn> You probably meant "let a = 1 in pi + a"
04:28:39 <merijn> > let a = 1 in pi + a
04:28:41 <lambdabot>   4.141592653589793
04:29:06 <srhb> I think he means to say he's writing that in a do block
04:29:30 <srhb> ie. do { let a = 1; pi + a }
04:29:43 <srhb> stdnt: Correct?
04:29:44 <stdnt> http://pastebin.com/m8y3AX4j
04:30:01 <srhb> Oh well
04:30:04 <fruitFly> is there something wrong with my indentation of main at the bottom? http://ideone.com/5821gy
04:30:07 <stdnt> a = 1 sorry
04:30:10 <srhb> stdnt: Because that's not even close to Haskell.
04:30:39 <srhb> Unless that's a ghci session
04:30:47 <stdnt> Yes. Ghci session.
04:30:57 <srhb> Then it's because of the monomorphism restriction.
04:31:25 <srhb> let a = 1 :: Float ; pi + a
04:31:32 <stdnt> Thank you srhb.
04:33:20 <typoclass> fruitFly: try indenting lines 191+192 more
04:34:31 <fruitFly> typoclass: why does that work? I tabbed (standard) --converting to spaces?
04:34:38 <typoclass> fruitFly: by the way, i expect the error messages will get more meaningful if you set the language to haskell (not c++)
04:34:59 <fruitFly> typoclass: oh lol whoops.. no wonder it was so red :P
04:35:40 <fruitFly> typoclass: i have gotten good at interpreting haskell errors with c++ error messages, however :P
04:40:01 <fruitFly> how do I see how much memory is being used to execute my program... because this is taking forever to terminate
04:40:36 <typoclass> fruitFly: if you're on linux, try running 'top'
04:40:37 <fruitFly> i don't see anything that memory intensive in system monitor?
04:42:08 <fruitFly> typoclass: I don't really see anything, and after I execute my program the cursor skips a line and is all the way to the left... it seems like it's executing, but it was taking over a minute, I restarted it. no sign of an intensive process?
04:42:50 <typoclass> fruitFly: maybe a function infinitely is calling itself?
04:44:22 <fruitFly> I don't think so, I'll check. I'm doing (255 ^ 2) xors on a 100s of chars base64 string, I expect it could take some time, but I would think I would see some kinda process, wouldn't I?
04:44:25 <fruitFly> typoclass: ^
04:49:46 <ramses_> fruitFly: I'd say start with testing your building blocks in ghci
04:50:05 <ramses_> see of anything is taking unreasonably long
04:50:09 <ramses_> s/of/if
04:50:16 <fruitFly> ramkrsna: building blocks?
04:50:34 <ramses_> fruitFly: functions you defined
04:51:07 <fruitFly> ramses_: how do I test that?
04:51:28 <ramses_> my usual workflow is: divide problem in parts, solve one part at a time and use ghci to test it quickly
04:51:46 <ramses_> fruitFly: call it with some test values in ghci
04:52:31 <fruitFly> ramses_: everything has been working up until now I've added more data, I think
04:52:56 <fruitFly> all I did was change main and add more data, changed nothing with the previous funcs that have worked before
04:53:22 <ramses_> what do you mean by "added more data"? Longer inputs?
04:54:00 <fruitFly> ramses_: yes
04:54:18 <fruitFly> ramses_: it looks like it's executing in terminal.. just talking a really long time
04:54:33 <fruitFly> I don't see a prcoess though? I'm not sure what to even look for.
04:54:38 <ramses_> if you're program is supposed to go from base64 to ascii (does it?) it should have linear complexity
04:55:37 <ramses_> try testing individual functions with long inputs to see whether one of them takes too long
04:56:01 <ramses_> did you try sorting by memory usage in top?
04:56:28 <ramses_> (to do so press ">" to move the sorting one column to the right, which is mem here)
04:56:41 <typoclass> fruitFly: try the input that worked, then try an input that is (say) 2x as long
04:56:46 <fruitFly> ramses_: yes, but I'm also xoring, and befor it was only against c| c <- [0..255] ... now it's [c,d] | c <- [0..255], d <- [0..255]
04:57:42 <fruitFly> typoclass: i'll try something like that
04:57:54 <fruitFly> but how do I see a haskell process?
04:58:09 <fruitFly> i.e. what should I be looking for?
04:58:09 <typoclass> fruitFly: same way you see any process
04:58:19 <fruitFly> what's the name though?
04:58:30 <merijn> You might want to enable profiling and inspect the memory usage that way
04:59:03 <fruitFly> merijn: wanna share how?
04:59:10 <fruitFly> i only trust the merijn way
05:00:24 <ramses_> finding a badly performing function in a small program is more work with the profiler than with ghci, imho
05:00:29 <merijn> I don't remember the details, RWH has a chapter on profiling, though
05:00:35 <merijn> @where rwh
05:00:35 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:05:51 <fruitFly> in all honesty, I'm doing some security challenges, and it took my implementation over 10s to xor 255 bytes against a couple hundred strings, now we have to xor one largers string against all permutations of bytes length 2, bytes length 3, length 4... all the way to 40
05:06:19 <fruitFly> I think with my implementation this operation would take forever
05:06:54 <fruitFly> how efficient is haskell able to decode cipher texts with key length 2-40 bytes? is it reasonable?
05:07:15 <supki> my implementation took about 3 seconds
05:07:23 <supki> but I didn't care about performance at all
05:09:32 <ramses_> @faq can haskell decode cipher texts with key length 2-40 bytes with reasonable efficiency?
05:09:32 <lambdabot> The answer is: Yes! Haskell can do that.
05:09:56 <fruitFly> supki: ur implementation of which challenge?
05:10:11 <fruitFly> lol
05:10:16 <fruitFly> ramses_:
05:10:23 <fruitFly> i need to remember that
05:12:53 <supki> fruitFly: I assumed you're talking about the 4th one
05:14:54 <natte> fruitFly: done that challenge, a couple of days ago, ruby though...those are really fun :)
05:15:58 * hackagebot finite-field 0.7.0 - Finite Fields  http://hackage.haskell.org/package/finite-field-0.7.0 (MasahiroSakai)
05:18:32 <fruitFly> supki: ok, did you write your converters from scratch or use pre made ones? and how long was your execution in challenge 5?
05:21:03 <chrisdone> so if you're in here the guy who's trying to scrape the whole of hpaste, please stop doing that or i will ban you
05:21:40 <elliott> haha
05:22:06 <elliott> I see the disk is full again...
05:23:00 <supki> fruitFly: you mean 6?
05:23:31 <Cale> chrisdone: Have you considered adding some kind of rate limiting on posts containing links from a given address?
05:23:49 <supki> fruitFly: I wrote everything from scratch I think
05:23:52 <fruitFly> supki: yeah?
05:24:00 <supki> fruitFly: let me see
05:24:10 <chrisdone> Cale: not yet. i might do, though
05:24:14 <fruitFly> supki: yes 6
05:24:16 <supki> fruitFly: time reports 1.55 secs
05:24:27 <fruitFly> whaaaaat?
05:24:43 <chrisdone> hpaste caches page requests, so that explains all the space usage because this genius is scraping it (could just ask me for the actual database…)
05:25:04 <ramses_> fruitFly: you compile with -O2, right?
05:25:23 <mauke> if your cache can cause out-of-disk errors, it's a disk leak, not a cache
05:25:25 <fruitFly> supki: as in 1.55 seconds to xor the base64 string against all permutations of 2 bytes, 3 bytes, 4 bytes ... 40 bytes... and then sort them all?
05:25:50 <fruitFly> ramses_: no, i've been using -o ... is that a problem?
05:26:00 <typoclass> Cale, chrisdone: as far as i could see removing spam from a few days worth of pastes, there is only one guy causing spam these days, and that's "stooorage.com" guy
05:26:13 <supki> fruitFly: huh?
05:26:14 <merijn> fruitFly: Try not to paste too much specifics, I still need to start on those Matasano challenges (which is also why I haven't really looked at your code yet)
05:26:32 <chrisdone> mauke: helpful
05:26:47 <merijn> typoclass: Yesterday the recent pastes had a whole bunch of porn sounding names
05:26:57 <supki> fruitFly: no, I don't think you need to xor against all permutations
05:27:02 <fruitFly> merijn: alright, I'm sure you'd find everything we're talking about trivial but ok, and u probably couldn't read my code anyway XD
05:27:06 <mauke> http://blogs.msdn.com/b/oldnewthing/archive/2006/05/02/588350.aspx
05:27:17 <ramses_> fruitFly: use -O2 then
05:27:24 <typoclass> merijn: yeah, that's it
05:27:49 <fruitFly> supki, isn't the key either 2 bytes long, 3 bytes long, .. or maybe 40 bytes long?
05:28:02 <typoclass> http://hpaste.org/89877 <- example spam. some sort of metadata, a stooorage.com url, several ryushare.com urls
05:28:03 <merijn> chrisdone: I was thinking about what you could do about spam limiting, but I fear most boil down to registration, which might be annoying for a pastebin
05:28:03 <supki> fruitFly: yes
05:28:19 <typoclass> this format accounts for basically all hpaste spam i've seen
05:28:21 <chrisdone> mauke: with normal traffic it's been fine for, uh, 3 years
05:28:33 <fruitFly> supki: ok, I guess u don't have to do all 40 but stil
05:28:44 <merijn> chrisdone: Maybe hook it up to a source detection file and silently drop anything that's not detect as any source code?
05:28:45 <chrisdone> typoclass: yeah i'll try to ban the ip
05:28:52 <supki> fruitFly: yes, you actually need only 1
05:29:05 <chrisdone> merijn: that would annoy people who were false negatives
05:29:07 <merijn> chrisdone: Alternatively, try and match the filled in name with a freenode user?
05:29:12 <typoclass> chrisdone: thanks, excellent
05:29:24 <elliott> just blocking the domain name from being included in pastes seems like the simplest solution until any more spam happens
05:29:51 <merijn> chrisdone: Is the source somewhere? I'd be up for experimenting with filtering
05:30:45 <chrisdone> yeah link's on the site
05:30:56 <supki> fruitFly: you need to find keysize before doing any "cracking"
05:31:58 <chrisdone> merijn: let me know if you need help building it. it should build from hackage nowadays
05:32:28 <chrisdone> merijn: we already discussed filtering the announcer to people on irc
05:32:30 <merijn> chrisdone: I'll take a look when I get bored
05:33:19 <merijn> Bayesian filter where anything from people on IRC/valid source is used as "ok" and anything containings URLs is negative might be an interesting start
05:33:42 <chrisdone> yeah
05:34:03 <merijn> Not sure how many false positives that'd give, though
05:34:13 <merijn> I dunno how much "non-source" gets pased
05:34:17 <chrisdone> as long as joe from haskell-cafe can still paste something that doesn't pass the haskell test
05:34:19 <elliott> anything heuristic worries me unless the problem is dire enough to demand it
05:34:22 <fruitFly> supki: how is it possible to know what the actual key is unless the resulting plaint text is english?
05:34:31 <fruitFly> supki: doesn't sound right?
05:34:47 <fruitFly> supki: i.e. the key length
05:35:09 <chrisdone> another option is to have a ban feature that ops can use
05:36:15 <Cale> hpaste down
05:36:17 <merijn> downvote button for spam?
05:36:24 <elliott> merijn: unworkable
05:36:30 <elliott> the problem is when it gets reported in here
05:36:35 <elliott> after that the damage is done
05:36:37 <chrisdone> cale: just restarted it
05:36:42 <merijn> elliott: Yeah
05:36:44 <Cale> yeah :)
05:36:45 <fruitFly> what's the difference between -02 and -o?
05:36:54 <fruitFly> compileing with those ^
05:36:56 <chrisdone> -o is output, -O is optimization
05:36:59 <merijn> fruitFly: -02 is wrong
05:37:12 <merijn> chrisdone: Looks like you need a better IRC font ;)
05:37:15 <fruitFly> merijn: what should I use to compile?
05:37:18 <merijn> fruitFly: -O2
05:37:22 <chrisdone> and -0 is nothing =P
05:37:27 <fruitFly> 0
05:37:29 <fruitFly> heh
05:37:31 <merijn> fruitFly: That's a zero
05:37:34 <fruitFly> ok
05:37:36 <fruitFly> O2?
05:37:39 <merijn> I'm using capital O
05:37:40 <merijn> Yes
05:37:41 <fruitFly> ooh ok
05:37:48 <fruitFly> is O2 better?
05:38:03 <merijn> -O is optimisation -O2 is more optimisations -o is the name of the output file
05:38:05 <merijn> fruitFly: Yes
05:39:01 <merijn> Adobe Source Code Pro is a decent monospace font that distinguishes O and 0, for the people torturing themselves with fonts that have them the same :p
05:39:05 <fruitFly> so just "ghc -O2 file.hs"?
05:39:09 <fruitFly> merijn: ^
05:39:11 <merijn> fruitFly: yes
05:39:19 <chrisdone> merijn: ubuntu mono ftw
05:39:48 <mauke> DejaVu Sans Mono
05:40:04 <chrisdone> dude, that's so, like, last year, man
05:40:26 <chrisdone> dejavu sans mono is too big, and it scales badly
05:40:28 <merijn> chrisdone: Oh, Ubuntu Mono looks a little like Monaco
05:40:47 <chrisdone> mm monaco is a little more curly but yeah
05:41:01 <mauke> does Ubuntu Mono cover unicode?
05:41:33 <merijn> That's one of the reasons I like monaco, it has amazing unicode support :)
05:41:41 <fruitFly> I'm using 7.4.2 and instead of getting this error: http://ideone.com/CuJmU5 , which I'm guessing is right somehow, my program is just not terminating?
05:41:43 <bitonic> misc-fixed!
05:41:49 <chrisdone> mauke: how much unicode?
05:41:58 <mauke> chrisdone: ALL THE UNICODE
05:42:15 <merijn> But not everyone uses OSX or is willing to pay for monaco, so I tend to recommend Source Code Pro as a decent alternative with good unicode coverge
05:42:21 <chrisdone> it supports latin and extended and the greek stuff
05:42:24 <merijn> Although it has some minor things I dislike
05:42:46 <chrisdone> if you want japanese in ubuntu mono you'll be disappointed
05:42:57 * typoclass is a fan of inconsolata. source code pro is fairly good as well
05:45:41 <chrisdone> merijn: if you're on linux with fontconfig unicode support in fonts is less of an issue
05:48:07 <ramses_> ubuntu mono has very small dots, seems annoying for source code
06:00:15 <t7> >still using a monospace font for programming >2013
06:01:11 <ramses_> using cabal-dev, I get an error msg on build: "<command line>: cannot satisfy -package-id parsec-3.1.3-4ce5c20fb44b227ab443931c2714a6ef", what does that mean?
06:01:35 <typoclass> ramses_: retry with "-v3"?
06:01:56 <supki> ramses_: did you install anything in --global?
06:02:27 <ramses_> supki: yes, doesn't cabal-dev ignore that?
06:02:28 <supki> ramses_: actually, what does  ghc-pkg list parsec  say?
06:02:33 <supki> ramses_: no
06:02:52 <supki> ramses_: cabal-dev ignores --user database
06:02:53 <ramses_> damn, so I can't have another parsec there?
06:03:19 <ramses_> ah wait, I have parsec in my _user_ db
06:03:26 <ramses_> not in the global one
06:04:11 <ramses_> (is there a way to build ghc-mod without having parsec and such in my user db?)
06:05:57 <ramses_> typoclass: http://hpaste.org/89924
06:06:20 <ramses_> typoclass: I don't see a descriptive error msg
06:06:23 <mr-> ramses_: ghc-mod does not depend on parsec, I think
06:07:24 <merijn> t7: Do you know any heretics that *don't* use monospace fonts?
06:07:34 <chrisdone> people with structured editors
06:07:42 <merijn> chrisdone: Monospace in there too!
06:07:59 <chrisdone> why?
06:08:04 <merijn> chrisdone: Why not?
06:08:06 <Walther> I use Ubuntu Mono, not Monospace :P
06:08:13 <ramses_> mr-: cabal installed it nonetheless then :)
06:08:32 <supki> ramses_: If I had to guess I'd say some package depends on that shadowed (or broken?) parsec
06:08:32 <chrisdone> because fonts look better with properly shaped letters and kerning
06:08:50 <merijn> chrisdone: I like my Monaco just fine
06:08:59 <chrisdone> would you read a novel in monaco?
06:09:14 <merijn> Yes!
06:09:32 <typoclass> ramses_: hm ... must be a quirk of cabal-dev. that's not the output i was hoping for. cabal with -v3 will tell you "i'm not using parsec-1.2.3 because constraint XYZ excludes it", and so on
06:09:55 <Botje> that's how I read neuromancer the first time!
06:10:04 <chrisdone> pirate!!
06:10:05 <Botje> after that I got a nice ebook reader
06:10:20 <chrisdone> would you steal a novel? oh, er
06:10:24 <ramses_> supki: I just deleted all subdirs of cabal-dev and did configure/install-deps
06:10:25 <chrisdone> would you steal a car!?
06:10:51 <supki> ramses_: I mean something in --global
06:11:25 <ramses_> supki: huh, something in global that depends on something in my user db? that shouldn't be possible, right?
06:11:33 <merijn> chrisdone: Once I get a decent 3D printer, yes! :p
06:12:27 <supki> ramses_: well, I can't think of a reason you can get that error in empty cabal-dev sandbox otherwise
06:13:01 <typoclass> ramses_: btw, have you checked "ghc-pkg check"?
06:13:04 <ramses_> can I clean out the user db by just deleting .cabal or do I have to unregister them one by one forst>
06:13:09 <typoclass> maybe parsec itself has a problem
06:13:10 <ramses_> first?*
06:13:43 <supki> you clean it by deleting ~/.ghc and ~/.cabal, ramses_
06:13:55 <chrisdone> merijn: yeah i was watching a talk by RMS about the origin of copyright and how "you can't copy a chair, so copyright doesn't apply". i was like “ehem, 3d printiiing! >_>”
06:14:47 <ramses_> grr, of course cabal-dev is also gone then
06:15:36 <chrisdone> ramses_: perhaps for i in `ghc-pkg list --user`; ghc-pkg unregister --force $i; done
06:15:40 <chrisdone> or something like that
06:15:58 <ramses_> chrisdone: .cabal and .ghc are already gone now :)
06:16:05 <chrisdone> D:
06:16:16 <ramses_> cabal-dev is building
06:16:47 <Aetherspawn> I wish I could build ghc on windows
06:16:50 <Aetherspawn> it fails for me every time
06:17:41 <latermuse> is there anyway to force appendFile to be strict?
06:17:54 <ramses_> doesn't cabal-dev now the -j switch?
06:18:08 <simukis_> Is name for pointless style is “pun intended”?
06:18:35 <typoclass> simukis_: yes, i bet :)
06:18:47 <typoclass> Aetherspawn: is there some problem with the binary?
06:19:02 <Aetherspawn> It fails at an error in some haskell file
06:19:14 <Aetherspawn> or randomly freezes and stops building halfway
06:19:20 <Aetherspawn> (alternates between either one)
06:19:33 <Aetherspawn> I've pulled the git and tried with clean mingw, clean path, etc multiple times
06:19:36 <ramses_> okay, I rm -rf'ed ~/.cabal ~/.ghc and all but cabal.config in ./.cabal-dev and I still get that parsec error!
06:19:41 <typoclass> Aetherspawn: i recommend the binary download. building from source is rarely necessary
06:19:55 <Aetherspawn> I want to help develop the C parts of the windows runtime :)
06:20:01 <Aetherspawn> C is the language I actually know
06:20:07 <typoclass> Aetherspawn: oh, i see
06:20:08 <merijn> Aetherspawn: Did you try building under cygwin?
06:20:14 <Aetherspawn> merijn, only msys
06:20:31 <Aetherspawn> I can try cygwin
06:20:49 <ramses_> ghc-pkg check only complains about missing haddock's
06:22:33 <merijn> Aetherspawn: Also, try #ghc?
06:22:43 <merijn> Presumably someone there is more familiar with building for windows
06:23:19 <Aetherspawn> okay I'm going to try with gcc 4.8.1 and ghc 7.4.2 while I go have a shower
06:26:47 <supki> ramses_: could you paste the output of  ghc-pkg list --global ?
06:27:51 <ramses_> supki: http://hpaste.org/89924 (annotation)
06:29:05 <supki> looks ok
06:31:24 <ramses_> supki: yes, I really don't get why this fails all of a sudden
06:31:30 <fruitFly> oh my god, was chilin for like 20 minutes and noticed my non-terminating programs process which was 6 GB + ... I think it built up to that, that's a possibility that the propgrams starts to use more and more memory, right?
06:31:46 <typoclass> fruitFly: sure
06:31:48 <byorgey> yes
06:31:54 <fruitFly> typoclass: ho my gad
06:31:57 <byorgey> sounds like an infinite loop allocating memory
06:32:11 <fruitFly> holy logic error :(
06:32:13 <byorgey> kill it! kill it!
06:32:26 <ramses_> supki: oh my, I just had to rm -rf the dist dir as well, now it compiles
06:32:38 <fruitFly> killed that long time, I noticed because i was changin windows like a tuuuuuuuuuuuurtle lol
06:32:43 <ramses_> I guess the last time I build this project I had an older ghc still
06:32:44 <fruitFly> i was like.. hold on a second
06:33:44 <chrisdone> the funny thing about modern systems is it takes longer to realise you're shafted and by then it's way too late to stop the system from swapping like an octopus climbing an escalator
06:34:21 <ramses_> you can limit the amount of memory a single process can allocate on linux (probably also on other OSs)
06:34:39 <chrisdone> sure, that requires premeditation
06:34:57 <ramses_> others would call that a sane system configuration :)
06:35:39 <supki> ramses_: huh, that's interesting
06:36:20 <ramses_> supki: yeah, it seems ghc tried to reuse some binaries and then found a reference to a long-gone parsec package or something
06:36:59 <ramses_> I would have expected it to fail more dramatically in such a case
06:38:02 <supki> I would expect a warning "this package was configured against this other ghc before: ..."
06:39:32 <ramses_> indeed, that's what I meant
06:39:43 <ramses_> strange that it tries to continue anyway
06:40:57 <Aetherspawn> the wiki instructions for building ghc are annoyingly unix
06:41:27 <fruitFly> when one does lines does each string in the list have a \n at the end that my other function will parse and try to operate on?
06:41:54 <Peaker> > lines "hello\nworld"
06:41:54 <chrisdone> lines removes the \n's
06:41:55 <acube> > lines "123\n456\n789"
06:41:55 <lambdabot>   ["hello","world"]
06:41:55 <Aetherspawn> > lines "herp\nderp/n\nflerp"
06:41:56 <lambdabot>   ["123","456","789"]
06:41:57 <lambdabot>   ["herp","derp/n","flerp"]
06:42:01 <Aetherspawn> hahah
06:42:07 <acube> > lines "123\n456\r\n789"
06:42:08 <isomorphic> Does anybody happen to know why cabal configure --enable-tests complains about missing dependencies, but doesn't download them?
06:42:08 <chrisdone> @quote stereo
06:42:08 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
06:42:09 <lambdabot>   ["123","456\r","789"]
06:42:37 <acube> isomorphic: you need to use cabal install --enable-tests --only-dependencies to do that
06:42:50 <acube> isomorphic: I don't know why configure doesn't do it automatically though
06:43:02 <acube> > lines "123\n456\r789"
06:43:03 <lambdabot>   ["123","456\r789"]
06:43:15 <fruitFly> concat . lines "loveU\nyouGuys"
06:43:22 <isomorphic> acube:  Thanks :)
06:43:40 <fruitFly> > concat . lines "love\nYouGuys"
06:43:41 <lambdabot>   Couldn't match expected type `a0 -> [[a1]]'
06:43:41 <lambdabot>              with actual type `...
06:43:58 <fruitFly> @type concat
06:43:59 <lambdabot> [[a]] -> [a]
06:44:00 <mr-> fruitFly: precedence!
06:44:13 <fruitFly> mr I dnt know anything
06:44:17 <Aetherspawn> > foldl (++) [] $ lines "love\nyou\nguys"
06:44:18 <lambdabot>   "loveyouguys"
06:44:26 <fruitFly> > concat (lines "love\nYouGuys")
06:44:27 <lambdabot>   "loveYouGuys"
06:44:34 <mr-> fruitFly: (concat.lines) "..."
06:44:35 <dario> > concat . lines $ "hi\nthere"
06:44:36 <lambdabot>   "hithere"
06:44:49 <fruitFly> so then what the poopy is wrong with my program, gonna past it for u guys
06:45:03 <Aetherspawn> I'll get my tardis
06:46:10 <acube> Why is there no hpaste bot anymore? :(
06:46:19 <chrisdone> because we can't have nice things
06:46:52 <chrisdone> spammers gonna spam, so we have to add some restrictions before we bring hpaste back
06:47:33 <quchen> chrisdone: Why are pastes listed in public?
06:47:58 <quchen> chrisdone: I don't think many people find that feature very useful, yet its existence is the only reason spam is an issue, no?
06:48:59 <quchen> Or did HPaste get used to spam the IRC as well (haven't noticed that)
06:49:02 <typoclass> quchen: no, i think the spammer wants a place to store those files
06:49:32 <chrisdone> quchen: anyone who's ever googled some haskell topic and found hpaste has found that bit useful, i suppose
06:50:01 <merijn> quchen: It spammed IRC too
06:50:17 <acube> So what are you planning to do against the spam? Do you know yet?
06:50:35 <Aetherspawn> Is anything gonna die if I try and make ghc with -j8
06:50:54 <quchen> Aetherspawn: I don't think so. It doesn't really help though.
06:51:09 <quchen> Aetherspawn: Oh wait, scratch that, mixup in my head. Yes use it it's a huge speedup.
06:51:19 <chrisdone> lol
06:51:20 <quchen> I recently used it to compile 7.6.3 at least
06:51:46 <quchen> Initially it'll only use one core, but after a couple of minutes it'll scale all the way
06:52:10 <Aetherspawn> sweet
06:52:11 <elliott> I like being able to see recent hpastes
06:53:35 <quchen> And pastes should also be permanent? You could delete anything older than X (or with access times older than X)
06:53:46 <quchen> I don't think there's a solution that doesn't break things here.
06:54:01 <chrisdone> that's a premature conclusion, i think
06:54:22 <Aetherspawn> There are lots of links to pastes on the trac, stack overflow, etc
06:54:33 <chrisdone> nod
06:54:37 <Aetherspawn> Making them nonpermanent would cause a couple broken links here and there
06:54:45 <quchen> Hm.
06:55:14 <Clint> or people should not learn to treat pastebins as permanent
06:55:37 <quchen> Ideal world argument.
06:55:46 <elliott> I like permanent pastes.
06:55:58 <elliott> I see no reason to cut hpaste's functionality drastically like this.
06:56:03 * hackagebot toysolver 0.0.6 - Assorted decision procedures for SAT, Max-SAT, PB, MIP, etc  http://hackage.haskell.org/package/toysolver-0.0.6 (MasahiroSakai)
06:56:08 <acube> Maybe something like an irc code, where you can retrieve a code on irc by /msg'ing pastebin would help
06:56:08 <elliott> the spam that exists now is trivial to filter
06:56:15 <chrisdone> we can look at how other pastebins solve the problem. i never see any spam on gist
06:57:04 <typoclass> i think the whole spam issue is overstated. at least for now. it is this one guy with his "stoorage" dvd metadata pastes. it shouldn't be hard to special-case, and we can deal with anything else when (if) it appears
06:57:36 <Aetherspawn> block everything with "rage" and count of 'o's >= 2
06:57:37 <Aetherspawn> :P
06:58:36 <quchen> Github's spam policy is silentbanning ;-(
06:59:14 <Aetherspawn> do libraries get built with -fllvm
06:59:18 <Aetherspawn> if you use that flag in the program
06:59:49 <Peaker> Aetherspawn, there's no flag you can pass to cabal that makes it rebuild any of your dependencies
06:59:59 <Peaker> so whatever they were compiled with, that's how you'll use them
07:00:25 <Peaker> (minor caveat: libs can be compiled with/without profiling and you get to use either)
07:00:26 <Aetherspawn> There's no -flto option or anything like that?
07:01:11 <Aetherspawn> Actually scrap that question, GHC has always done lto
07:01:12 <chrisdone> anyway, i'm looking into this later this evening, once i've moved it to a new server
07:01:44 <fruitFly> When I pass this a .txt I get a never terminating increasing in memory error... how do you think I can trace this error (debug)?
07:02:31 <Peaker> fruitFly, run it in a profiler, see what's taking up memory.. typical mistake is thunk buildup, too much laziness
07:03:31 <fruitFly> Peaker: I have no idea what that is (I'm still on lyah), i think merejin told me that was in realworld haskell?
07:04:29 <acube> @where profiling
07:04:29 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
07:04:39 <acube> hmm. Idk if that helps
07:04:51 <monochrom> it helped me
07:04:59 <acube> yes, rwh has a chapter on profiling
07:05:18 <Peaker> fruitFly, also, you can show the code if you want feedback/help
07:07:22 <fruitFly> Peaker: omg I forgot the code: http://ideone.com/417sK2
07:07:36 <fruitFly> When I pass this a .txt I get a never terminating increasing in memory error... how do you think I can trace this error (debug)? http://ideone.com/417sK2
07:08:02 <Benzi-Junior> ok one question about data list and comparison I have a List of tuples (a, Int) wheras the int denotes the weight of object a and I have written a comparator that only checks the weight what Im wondering is can I be sure that the minimum (and maximum) functions from Data.List will return the same values if applied to a list that has more than one tuple with the same weight ?
07:08:44 <typoclass> fruitFly: if you don't want to deal with profiling, you might start by generally straightening up your program :-) start with those overly long lines, removing inactive code, and so on. #haskell can help you with that. afterwards it'll be much easier to see what's going on (both for yourself and for the others in #haskell)
07:08:56 <bitonic``> what paper should I reference when mentioning GADTs?  something that explains what they are and how they are used in Haskell rather than focusing on inference or System Fc
07:10:07 <acube> > maximum [1,2,3,2,3]
07:10:08 <lambdabot>   3
07:10:12 <monochrom> perhaps the haskell wiki page on GADTs?
07:10:41 <Peaker> fruitFly, your code is confusing ideone.. try hpaste instead?
07:10:46 <bitonic> mhm, I’d prefer a reference, I’m writing up my master’s thesis, but I don’t want to explain what they are myself
07:10:54 <acube> > maximumBy (comparing fst) [(1,2),(2,4),(3,3),(2,1),(3,4)]
07:10:55 <lambdabot>   (3,4)
07:11:03 <merijn> Benzi-Junior: I dunno, what does their documentation say?
07:11:26 <acube> merijn: It doesn't tell anything about that
07:11:26 <monochrom> then the original papers. they must say "what" and "how to use".
07:11:39 <acube> @ty Max
07:11:40 <lambdabot> Not in scope: data constructor `Max'
07:11:42 <acube> @ty Maximum
07:11:43 <lambdabot> Not in scope: data constructor `Maximum'
07:12:08 <augustss> Howdy!
07:12:17 <Benzi-Junior> that is will minimum [(a, 5),(b,5)] alvays return the same value and will it return the same value for every permutation of that list ?
07:12:26 <monochrom> I don't think "what and how to use" is mutually exclusive to "inference or System Fc"
07:12:46 <acube> > map (maximumBy (comparing fst)) $ permutations [(1,2),(2,4),(3,3),(2,1),(3,4)]
07:12:47 <lambdabot>   [(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3...
07:13:07 <fruitFly> Peaker: typoclass ok, I'm gonna run and get some food I'll brb. Ya'll better be here when I get back
07:13:25 <typoclass> fruitFly: heh :)
07:13:31 <acube> > filter (/= (3,4)) $ map (maximumBy (comparing fst)) $ permutations [(1,2),(2,4),(3,3),(2,1),(3,4)]
07:13:32 <lambdabot>   [(3,3),(3,3),(3,3),(3,3),(3,3),(3,3),(3,3),(3,3),(3,3),(3,3),(3,3),(3,3),(3...
07:13:34 <ousado> bitonic: how about http://www.ats-lang.org/PAPER/GRDT-popl03.pdf
07:14:09 <acube> > filter (/= (3,4)) $ map (maximumBy (comparing fst)) $ permutations [(1,2),(2,4),(3,3),(2,1),(3,4)]
07:14:10 <lambdabot>   [(3,3),(3,3),(3,3),(3,3),(3,3),(3,3),(3,3),(3,3),(3,3),(3,3),(3,3),(3,3),(3...
07:14:11 <bitonic> ousado: thanks, but I’m referencing GADTs in Haskell specifically
07:14:55 <typoclass> Benzi-Junior: i would expect maximumBy to give you the list's last element that is the last one
07:15:11 <typoclass> Benzi-Junior: you could sort by two criteria ...
07:15:41 <typoclass> > nub $ map (maximumBy (comparing fst)) $ permutations [(1,2),(2,4),(3,3),(2,1),(3,4)]
07:15:42 <lambdabot>   [(3,4),(3,3)]
07:16:14 <typoclass> > nub $ map (maximumBy (comparing fst <> comparing snd)) $ permutations [(1,2),(2,4),(3,3),(2,1),(3,4)] -- for comparison
07:16:16 <lambdabot>   [(3,4)]
07:17:02 <typoclass> (hm, i wonder if i got that backwards ...)
07:17:10 <mauke> > maximumBy (comparing fst) [(0, "A"), (0, "B"), (0, "C")]
07:17:12 <lambdabot>   (0,"C")
07:17:14 <mauke> > minimumBy (comparing fst) [(0, "A"), (0, "B"), (0, "C")]
07:17:18 <lambdabot>   (0,"A")
07:17:21 <mauke> weird
07:17:34 <mauke> > maximumBy (flip $ comparing fst) [(0, "A"), (0, "B"), (0, "C")]
07:17:36 <lambdabot>   (0,"C")
07:17:49 <acube> @ty comparing first
07:17:50 <lambdabot> (Ord (a (b, d) (c, d)), Arrow a) => a b c -> a b c -> Ordering
07:17:56 <acube> @ty comparing fst
07:17:57 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
07:18:34 <augustss> @src min
07:18:34 <lambdabot> min x y = if x <= y then x else y
07:18:39 <augustss> @src max
07:18:40 <lambdabot> max x y = if x <= y then y else x
07:18:41 <Lethalman> hi
07:18:49 <Lethalman> what is Hask in few words? the set of all data types in haskell?
07:19:08 <typoclass> Benzi-Junior: does that make any sense?
07:19:14 <augustss> The min and max function prefer different arguments when the arguments are equal.
07:19:16 <t7> Lethalman: category
07:19:33 <elliott> Lethalman: the sort-of-category formed by taking the set of Haskell types as the set of objects, and the set of Haskell functions a -> b as the set of morphisms from a to b.
07:19:53 <Lethalman> ah right it must be a category so it has objects and morphism
07:19:55 <t7> elliott whats the identity morphism in hask ?
07:19:56 <elliott> sort-of because _|_ causes the laws to be violated a bit.
07:20:01 <elliott> t7: id
07:20:01 <Benzi-Junior> typoclass : yes but that means deriving a Ord implementation for my homemade type
07:20:07 <elliott> and composition is (.), of course
07:20:18 <Lethalman> ok thanks :-)
07:20:39 <monochrom> typoclass: it seems the GRDT paper is where the idea is invented, which means where you will find the most on "what and how to use". all newer papers can only be brief on that, and then contribute a small variation or yet another type inference algorithm
07:20:41 <Lethalman> just read a bit of category theory because some haskell libraries talk about category stuff, learning some words is good
07:20:52 <typoclass> Peaker: ^^
07:21:19 <elliott> Lethalman: also, the name Hask is a bit misleading. you can encounter other categories when working with a haskell program, and Hask is just a particularly common one.
07:21:25 <augustss> mauke: the rational for the min&max behavior is that (min x y, max x y) should be a pair with both x and y in it.
07:21:45 <Lethalman> elliott, classes for example?
07:21:50 <typoclass> Benzi-Junior: i dunno, i think the "comparing" thing that acube showed will work as long as you can extract *something* from your homemade type that has Ord
07:22:13 <Lethalman> or constraints
07:22:16 <elliott> Lethalman: no (or: I don't know what you mean)
07:22:50 <Peaker> typoclass, ^^ what?
07:22:52 <typoclass> augustss: interesting!
07:23:08 <typoclass> Peaker: monochrom said something to me which i think was meant for you?
07:23:47 <monochrom> darn, it's bitonic
07:24:00 <typoclass> monochrom: oops, sorry then. i misunderstood
07:24:06 <monochrom> bitonic: it seems the GRDT paper is where the idea is invented, which means where you will find the most on "what and how to use". all newer papers can only be brief on that, and then contribute a small variation or yet another type inference algorithm
07:24:06 <typoclass> Peaker: you too, sorry
07:24:36 <bitonic> monochrom: OK, thanks
07:24:53 <bitonic> I’d say that GADTs were invented when inductive families were invented, but ok
07:25:01 <monochrom> the first paper for Haskell is the "wobbly types" one, and it's already after GRDT.  see http://research.microsoft.com/en-us/um/people/simonpj/papers/gadt/index.htm
07:25:05 <bitonic> which is... somewhen around 1991?
07:25:18 <Adeon> wibbly wobbly type stuff
07:25:22 <augustss> GADTs for Haskell were invented long before the GRDT paper.
07:25:32 <sclv_> A good intuition for me is to read Hask as a setlike thing lacking equalizers and coequalizers and a few other limits i guess
07:25:39 <sclv_> its pretty naive
07:25:52 <sclv_> but it lets me go plug in "Hask" for "Set" in certain constructions and come out sort of ok
07:25:59 <monochrom> augustss: then bitonic probably likes to know which paper documents that
07:26:05 * hackagebot twidge 1.1.0 - Unix Command-Line Twitter and Identica Client  http://hackage.haskell.org/package/twidge-1.1.0 (JohnGoerzen)
07:26:16 <augustss> monochrom, wait, which paper are you referring to with GRDT?
07:26:23 <elliott> my intuition for Hask is that it's boring
07:26:29 <elliott> and gross
07:26:58 <tac> Cartesian closed, but not much more
07:27:28 <bitonic> sclv_: if it’s CCC, it must have equalisers no?
07:27:28 <sclv_> right but cartesian closed gives you a bunch
07:27:29 <t7> what is an interesting category ?
07:27:47 <monochrom> Hongwei Xi, Chiyan Chen, and Gang Chen. Guarded recursive datatype constructors. SIGPLAN-SIGACT 2003
07:27:48 <sclv_> you get "hask is enriched in itself" which is handy, e.g.
07:27:52 <bitonic> equalisers pullback and the other thing
07:28:09 <monochrom> wait, POPL 2003 instead
07:28:57 <augustss> monochrom, Right.  Well, the idea of GADTs for Haskell had been around for 10 years by then.  No implementation, though.
07:29:30 <tac> bitonic: I don't think ccc's need equalizers. They need a terminal, a binary product, and an exponential
07:29:30 <sclv_> t7: lots of categories are interesting for different reasons
07:30:04 <monochrom> then it will have to be some of Hinze's old phantom type papers which said "don't you wish you had GADTs"
07:30:16 <bitonic> tac: oh right.  I was confusing that with limits.
07:30:24 * bitonic just read the first two chapters of a little CT book :P
07:30:24 <augustss> http://web.cecs.pdx.edu/~sheard/papers/silly.pdf
07:30:24 <sclv_> a tougher question is "what is a category sufficiently different from hask/set that i don't just get intuitions about set, but sufficiently basic that i actually have some clue about how it works"
07:31:22 <sclv_> so one trick i learned is that if you want to think about limits and stuff in a very obvious way, you can look at the category of reals, equipped with arrows as less than, look at functors from reals to reals
07:31:34 <sclv_> and then look at preserving limits as preserving continuity
07:31:49 <bitonic> well I would say that the idea for GADTs goes back to peter dybjer and inductive families
07:31:52 <elliott> augustss: any link ending in silly.pdf is a link i will click
07:31:54 <sclv_> so that lets you come up with lots of nice counterexamples to silly questions you may have easily
07:32:05 <sclv_> its probably a boring category for doing many other things though :-P
07:32:12 <augustss> bitonic, absolutely, I just meant in the context of Haskell
07:32:50 <sclv_> "more of the usual ranting"!
07:33:05 <bitonic> augustss: oh OK, which is what I asked in the end :)
07:33:19 <bitonic> I was hoping for a ‘this is how GADTs look like in Haskell’ paper, but it looks like there isn’t one
07:33:59 <enigmuriatic1> how do i install Database.HDBC.Sqlite3?
07:34:02 <monochrom> augustss: I think I owe you the original question of bitonic. an MSc thesis needs to reference a paper that says what he's saying just now.
07:34:07 <sclv_> enigmuriatic1: cabal
07:34:08 <augustss> bitonic, You mean more like a tutorial?
07:34:08 <elliott> "Of course, there should be some kind of soundness proof here, but who cares?" brilliant.
07:34:27 <sclv_> assuming you have libsqlite already on your system
07:34:29 <enigmuriatic1> sclv_, what command though? none i've tried work
07:35:07 <bitonic> augustss: that would be even better, yeah.  I’m basically looking for a tutorial that is referenceable in my thesis
07:35:23 <sclv_> enigmuriatic1: first you find the package you need on Hackage: http://hackage.haskell.org/package/HDBC-sqlite3
07:35:35 <sclv_> then you type "cabal install HDBC-sqlite3" and keep your fingers crossed
07:35:42 <bitonic> actually, silly me, I’ll just reference the manual
07:35:52 <sclv_> bitonic: precisely!
07:35:59 <monochrom> haha yikes
07:36:14 <enigmuriatic1> sclv_, that doesn't work for some reason
07:36:25 <sclv_> "that doesn't work" is not useful
07:36:26 <augustss> bitonic, Yes, the manual works. :)
07:36:34 <Soft> I have a module folder, lets call it Foo, and inside it I have Main.hs file that contains the main function. When I try to run ghc -o foo --make Foo.Main in Foos parent directory ghc complaints it cannot find Main module
07:36:37 <sclv_> you should use hpaste.org to paste the error
07:36:38 <Soft> If I however add -main-is Foo.Main flag the compilation succeeds.
07:36:44 <Soft> Is there something wrong with the way I invoke ghc or the way I have structured my project
07:37:08 <Soft> I just have a feeling I shouldn't have to specify -main-is flag
07:37:11 <monochrom> "for more information on GADTs in Haskell, see [3]. for more information on type families in Haskell, see [3]. for more information on mfix in Haskell, see [3]. ... [3] The GHC User's Guide"
07:37:16 <sclv_> it looks for a module "Main" not "Foo.Main"
07:37:39 <sclv_> so if you want your main to be found automatically it should not be in the Foo folder
07:37:44 <sclv_> or you can pass main-is and not care
07:37:51 <Soft> oh okay
07:38:16 <bitonic> monochrom, augustss: thanks anyway, now I know a bit more about the history of GADTs ehe
07:38:37 <enigmuriatic1> sclv_, turns out i just needed to close my ssh window and open a new one
07:38:44 <enigmuriatic1> i hate when that's the problem :P
07:38:55 <sclv_> oh right, path update nonsense
07:54:37 <enigmuriatic1> is there any reason why a program would compile fine on GHC 7.6 and then give me this error on 7.4? No instance for (Data.String.IsString BL.ByteString)
07:54:37 <enigmuriatic1>       arising from the literal `"|"'
07:56:03 <int-e> enigmuriatic1: It's using a different version of the bytestring package, I would expect. (I don't know when bytestring added the IsString instance.)
07:56:41 <sclv_> btw don't update bytestring
07:56:44 <sclv_> it will be a mess
07:56:59 <sclv_> instead add the isstring instance by hand, or just add manual packs and unpacks
07:57:15 <int-e> the latter means changing "|" to  (BL.pack "|")
07:57:21 <elliott> probably you need to import .Char8 to use that instance
07:57:26 <elliott> however, you shouldn't. :(
07:58:00 * int-e hopes that BL = Data.ByteString.Lazy.Char8
07:58:12 <enigmuriatic1> int-e, it's UTF8
07:59:56 <enigmuriatic1> int-e, using pack (or toString in this case) breaks it on my other machine
08:00:30 <eikke> enigmuriatic1: if it's utf-8, you sure you don't want to use Text?
08:03:02 <enigmuriatic1> eikke, that suggestion has been made, but I need to get this script running before i make changes like that
08:10:18 <sclv_> breaks it how
08:12:12 <choi> Hi if I have a "Seq Text" (Data.Sequence), what is the fastest way to extract the Text from it?
08:13:12 <mauke> what do you mean by "extract"?
08:13:24 <mauke> also, what do you mean by "the Text"?
08:13:38 <choi> @mauke unwrap the Data.Text data in wrapped in the Seq
08:13:38 <lambdabot> Unknown command, try @list
08:13:48 <mauke> choi: Seq is not a wrapper
08:14:35 <choi> mauke: I tried Foldable.foldl1 (T.append) x, but this was slow
08:16:07 * hackagebot sys-auth-smbclient 1.0.0.0 - Auth with smbclient command  http://hackage.haskell.org/package/sys-auth-smbclient-1.0.0.0 (KazuoKoga)
08:25:12 <Guest2565> I am trying to compile the code at https://github.com/mrd/geocode-google/blob/master/Geography/Geocoding/Google/Get.hs; it is failing that catch is not in scope at line 46.
08:25:30 <Guest2565> I added Control.Exception then get an error at show
08:25:38 <Guest2565> how can I fix this?
08:27:46 <mauke> import System.IO.Error
08:27:50 <mauke> use catchIOError instead
08:28:19 <elliott> huh, I thought catchIOError was deprecated
08:28:39 <mauke> that would piss me off
08:28:44 <mauke> because I'd have to reimplement it (again)
08:29:10 <Spaceghost> Clint: finally I find you.
08:29:54 <Spaceghost> Clint: What is the suspicious?
08:30:32 <elliott> the suspicious?
08:31:02 <Spaceghost> Yes, the suspicious.
08:31:17 <elliott> i see. the suspicious.
08:31:49 <qfwfq> It's rare the suspicious is discussed in here. It's great to see the Haskell community is really diversifying.
08:40:47 <johanneslippmann> > take 5 [1..] ==> [1,2,3,4,5]
08:40:48 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
08:40:48 <lambdabot>              with actual type...
08:41:00 <johanneslippmann> > take 5 [1..]
08:41:01 <lambdabot>   [1,2,3,4,5]
08:41:32 <mauke> :t (==>)
08:41:33 <lambdabot> Testable prop => Bool -> prop -> Property
08:41:37 <mauke> o helo
08:43:35 <elliott> mauke: @check works now :)
08:44:27 <t7> is there a mathematical name for something unfoldable
08:44:39 <t7> (unfold)
08:44:42 <mauke> :t def
08:44:43 <lambdabot>     Not in scope: `def'
08:44:43 <lambdabot>     Perhaps you meant `dff' (imported from Data.Graph)
08:44:48 <mauke> elliott: but def doesn't!
08:44:57 <elliott> mauke: giveth; taketh away
08:45:21 <mauke> t7: possibly related: anamorphism
08:46:21 <t7> aha
08:50:48 <xplat> what's the best way to populate a directory with some random stuff from another directory?
08:51:24 <xplat> t7: anamorphism is the name of the unfold, something that admits anamorphisms is a final coalgebra
08:52:14 <xplat> (well, anamorphism is the name of the partially-applied unfold)
08:54:17 <ghorn_> do you guys filter out all these "x has joined", "y has left" messages?
08:55:04 <mauke> I don't
08:55:05 <Clint> i don't
08:55:32 <joelteon> i do
08:55:41 <joelteon> if the person talks, it shows their join/part messages
08:55:55 <joelteon> it eliminates a lot of visual noise
08:56:18 * merijn filters all joins and parts
08:56:38 <t7> xplat: i thought a final coalgebra might not, necessarily, have a single unfold... ?
08:56:40 <Clint> joelteon: elaborate on "talks"
08:56:59 <joelteon> Clint: if they send a message within 5 minutes of joining or parting it shows the join/part events
08:57:10 <Clint> retroactively?
08:57:12 <xplat> t7: having a single unfold is pretty much the exact definition of a final coalgebra.
08:57:16 <joelteon> yes
08:57:18 <joelteon> retroactively
08:57:23 <Clint> what do you do that with?
08:57:24 <t7> ah ok :)
08:57:32 <joelteon> weechat
08:57:44 <Clint> built-in or script?
08:57:53 <joelteon> i think it's built in
08:57:57 <Clint> interesting
08:58:01 <joelteon> yeah it's a builtin called irc_smart
08:58:11 <Clint> i looked at weechat once but something about the screen-drawing upset me
08:58:11 <xplat> i have a script a friend wrote with irssi that shows joins retroactively if someone talks, and shows their part if they have talked since joining
08:58:13 <joelteon> join/parts are tagged irc_smart_filter
08:58:36 <xplat> i looked at weechat once but the code upset me :(
08:58:44 <Clint> don't look at irssi's code then
08:58:53 <Clint> xplat: is that script public?
08:59:11 <joelteon> yeah, weechat is a disaster and the plugin docs are un-googlable, but if you slog through it you can get a really nice client
08:59:14 <xplat> irssi looks like typical horrible C code from what i've seen.  weechat is ... somehow worse than that.
08:59:50 <xplat> Clint: don't know if it's up anywhere, but i can send it if you're interested (dcc)
09:00:34 <Clint> xplat: please
09:00:54 <Zariel> What advice do you have for working with responses from servers, so i need to check if the response is a 200 and then send more commands which need to check for 200
09:01:01 <Zariel> sounds like using Maybe monad?
09:01:20 <Clint> xplat: thanks
09:01:26 <Zariel> would it be sensible to create a new datatype add Monad instances to use bind and return to hide the underlying errors?
09:02:01 <Clint> Zariel: maybe you want a transformer
09:02:46 <Clint> Zariel: or http://hackage.haskell.org/package/errors
09:02:55 <xplat> ErrorT : More than meets the eye
09:03:56 <xplat> i was thinking of using directory-tree for my 'populate a build temp directory' problem but apparently there are several libraries on hackage in the same mold
09:12:41 <xplat> directory-layout, filesystem-trees
09:14:38 <xplat> if this was a shell script i'd just use 'cp -a'
09:14:55 <xplat> every other language has to make it complicated ...
09:16:54 <xplat> okay, if nobody has an opinion i guess i'll use directory-tree ...
09:21:41 <geekosaur> have you considered that perhaps it's a more complicated task than you think?
09:22:29 <augustss> Hmm, 'cp -a' must be some new-fangled gnuism.
09:22:56 <augustss> My cp doesn't have that flag.
09:25:57 <geekosaur> it's cp -R on unix, as distinct from fakehurd
09:26:27 <Saizan> -dR --preserve=all according to my man
09:27:19 <CaptainLex> It would be very strange for 'cp -a' to have the normal functionality of -a
09:29:31 <augustss> Lots of strange flags that the real cp doesn't have.
09:32:03 <FreeFull> -a is a normal frag for cp
09:32:16 <FreeFull> -a, --archive    same as -dR --preserve=all
09:32:40 <augustss> calvin% cp -a
09:32:40 <augustss> cp: unknown option -- a
09:32:41 <augustss> usage: cp [-R [-H | -L | -P]] [-f | -i] [-Npv] src target
09:32:41 <augustss>        cp [-R [-H | -L | -P]] [-f | -i] [-Npv] src1 ... srcN directory
09:33:46 <FreeFull> lens is a pretty big library
09:34:03 <FreeFull> augustss: Which sysutils are you using? busybox?
09:34:21 <augustss> It would have even bigger, but the operator quota was exhausted.
09:35:11 <augustss> FreeFull, I'm running NetBSD, and not wanna-be-unix.
09:36:15 <mauke> >implying BSD is a real unix
09:36:16 <augustss> Using NetBSD and Haskell goes hand-in-hand.  You have to like wearing a hair shirt.
09:36:48 <xplat> geekosaur: of course it's a complicated task.  making complicated tasks look simple is what libraries are for, supposedly.
09:37:17 <augustss> xplat, So maybe you need to write a new library?
09:37:51 <xplat> augustss: there's a limit to how many new libraries i can be writing at once if i ever want to finish any of them
09:39:13 <augustss> mauke, the original BSD certainly was.  But NetBSD has code from that time.  Is an OS still the same OS when every single line has been rewritten?  Is a person still the same person when every cell is new?
09:39:24 <xplat> since 1321 seems to be in excess of that limit, i'm trying to cut down rather than add more.
09:39:24 <augustss> s/has/has no/
09:42:28 <merijn> augustss: Incidentally, that's what cp on OSX looks too ;)
09:42:34 <FreeFull> No matter what library you write
09:42:36 <merijn> True UNIX! \m/
09:42:39 <FreeFull> lens actually does everything you need
09:43:05 <geekosaur> well, yes. openbsd and freebsd are from the same 4.4bsd-lite origin, and os x is largely (though not completely) freebsd userspace
09:44:01 <merijn> I miss FreeBSD's -I, though
09:44:09 <geekosaur> apple resynchronizes it against freebsd-current periodically
09:44:12 <ssedov> geekosaur: I always amused by the fact osx still has calendar.freebsd and they keep it up to date:)
09:44:35 <merijn> eh, "rm -I" I mean
09:45:36 <FreeFull> What does -I do?
09:46:16 <augustss> geekosaur, A lot of the OSX userspace is from NetBSD.
09:47:54 <merijn> FreeFull: It's like minimalist "-i"
09:48:03 <merijn> -i prompts for confirmation of *every* file
09:48:05 <geekosaur> hm. a lot of the original next was from netbsd, but os x mostly syncs with freebsd-current
09:48:15 <merijn> -I just prompts once whenever you delete a directory or more than 3 files
09:48:33 <FreeFull> merijn: I see
09:48:49 <chrisdotcode__> hello everyone! :)
09:48:55 <merijn> So you can just "alias rm = rm -rfI" and if you'd delete a directory it'd go "are you sure?" and then you hit y or n
09:49:08 <merijn> Also protects against accidental shell globbing mistakes
09:49:32 <merijn> like "rm * .sh" instead of "rm *.sh" "this would delete X files, are you sure?"
09:50:30 <joelteon> man, osx's standard tools are pretty lame compared to the GNU stuff
09:50:48 <xplat> yes
09:50:51 <augustss> geekosaur, hmmm, maybe so.  I know Apple contributed some NetBSD patches.  They do use NetBSD in the Time Capsule.
09:51:24 * geekosaur mostly finds the gnu stuff frustrating. especially how recent gnuish utilities assume the operator is a blithering idiot
09:51:42 <augustss> I dislike the gnu tools.  They suffer from the idea that every tool should do everything.
09:51:44 <joelteon> hahah
09:51:48 <joelteon> yeah, but like
09:51:52 <joelteon> sed -i, rm -I, etc.
09:51:53 <xplat> the one time osx's command line tools were ahead of GNU in anything was when they preserved xattrs and GNU stuff didn't
09:52:03 <xplat> geekosaur: ?
09:52:39 <xplat> the main thing i dislike in GNU is that the docs are in info instead of man
09:52:51 <augustss> I like simple tools that compose well, which was the original unix philosophy.
09:52:59 <geekosaur> xplat, rm on my centos VMs defaults to -i
09:53:08 <merijn> geekosaur: ugh
09:53:19 <xplat> info sounded like a good idea at the time, but the standard viewers are horrible and there's no good way to get both info and man without scrubbing
09:53:28 <merijn> "alias rm = yes | rm"
09:53:43 <xplat> geekosaur: that's centos's patch, it's not from the FSF sources
09:53:58 <geekosaur> urgh
09:54:50 <geekosaur> (probably not centos's patch either, more likely red hat's. remind me again why I stopped using deadrat... (sadly this is work stuff so not much choice)
09:55:00 <xplat> (also, most info documents have horrible organization, much like most manpages but somehow those at least seem easier to search)
09:55:42 <chrisdotcode__> guys, let's say I had vehicle type, and I wanted to 'subclass' that into "car", "submarine" and "boat". would I use newtype for that?
09:56:06 <joelteon> data Vehicle = Car | Submarine | Boat
09:56:51 <chrisdotcode_> what if I then wanted to 'subclass' the Car type?
09:57:00 <chrisdotcode_> into ford, chevy, honda
09:57:14 <mauke> chrisdotcode_: the answer is no
09:57:16 <xplat> or data Car = Car { carToVehicle :: Vehicle, carTires :: [Tire], ... }
09:57:25 <merijn> chrisdotcode_: Why? I think this is one of the stereotypical terrible OO examples in the OO world
09:57:35 <augustss> chrisdotcode_, you'd have to change something.
09:57:35 <merijn> chrisdotcode_: It's even more terrible in a non-OO language
09:57:42 <chrisdotcode_> merijn: what's a better way to abstract something like this, then?
09:58:02 <chrisdotcode_> (in a sane language like Haskell, of course :) )
09:58:05 <merijn> chrisdotcode_: Can you give a non-ridiculous example of where you'd like to "subclass"?
09:58:43 <xplat> well, unless maybe you're doing software for an auto mechanic, dealer, or parts store you probably don't need a lot of special casing on the make of car :-/
09:59:03 <chrisdotcode_> merijn: is this example really ridiculous, though? I was thinking about how I would make a game using haskell, and something like this was the first my half-OO brain could come up with.
09:59:30 <augustss> chrisdotcode_, You could do data Vehicle = Car Make | Submarine | Boat; data Make = Ford | Honda | ...
09:59:36 <merijn> chrisdotcode_: Yes, it is. The better I become at programming, the more I think inheritance is one of the worst and most insidious inventions ever
09:59:52 <chrisdotcode_> augustss: oh, that's sweet.
09:59:52 <merijn> What was the fancy term for extending instead of inheritance?
10:00:04 <chrisdotcode_> merijn: er, subclassing? extending?
10:00:22 <chrisdotcode_> merijn: and how would you solve a problem like that? would it be augustss' solution?
10:00:25 <merijn> chrisdotcode_: No, there's a common approach for extending things with behaviour from the game programming world
10:00:34 <xplat> merijn: blah blah by composition.  don't remember what blah blah is
10:00:35 <augustss> merijn, open data types?
10:00:43 <merijn> chrisdotcode_: augustss example is one of the sane aproaches, depending on the "real" problem
10:01:02 <Phlogistique> 
10:01:04 <chrisdotcode_> merijn: what if it was a game? is there a saner solution?
10:01:12 * hackagebot language-slice 0.3.0.0 - AST and parser for the ZeroC Slice language (Specification language for ICE)  http://hackage.haskell.org/package/language-slice-0.3.0.0 (PaulKoerbitz)
10:01:14 * hackagebot slice-cpp-gen 0.3.0.0 - Generate C++ skeletons from slice files  http://hackage.haskell.org/package/slice-cpp-gen-0.3.0.0 (PaulKoerbitz)
10:01:29 <hodapp> xplat: You talking about Mr. Hickey's essay on composition over convention?
10:01:40 <merijn> chrisdotcode_: Hold on, I'll look up what I'm talking about
10:01:49 <merijn> hodapp: That, but Valve discussed a similar thing, I think
10:01:50 <xplat> chrisdotcode_: what kind of game?  is it 'auto repairing papa?'  'grand theft vehicle?'  'death derby 2040?'
10:02:03 <xplat> hodapp: no
10:02:07 <hodapp> merijn: oh, you wouldn't have a link in hand, would you?
10:02:10 <chrisdotcode_> xplat: grand theft vehicle, and/or death derby 2040
10:02:17 <merijn> chrisdotcode_: I read about this solution in a Valve presentation on Left 4 Dead AI, so it's certaintly sane for games :p
10:02:19 <xplat> hodapp: merijn might be though
10:02:37 <chrisdotcode_> merijn: you read about the solution you're trying to find, or augustss' solution?
10:03:27 <merijn> chrisdotcode_: The one I'm trying to find
10:03:34 <xplat> chrisdotcode_: you probably want merijn's solution then
10:03:42 <fruitFly> what do you guys think about freelancing with elm?
10:03:44 <xplat> when he finds it
10:03:44 <chrisdotcode_> that would be an awesome read when you find it :)
10:04:02 <merijn> hodapp: I seem to misremember the presentation I talked about, I got it from somewhere else, but it's still interesting http://www.valvesoftware.com/publications/2009/ai_systems_of_l4d_mike_booth.pdf
10:05:15 <hodapp> merijn: thanks!
10:06:27 <merijn> chrisdotcode_: I'm thinking of composition, but I can't find the relevant paper/talk
10:06:40 <merijn> chrisdotcode_: Maybe you can find something good searching for that term
10:06:55 <chrisdotcode_> merijn: sure. thanks :)
10:08:03 <augustss> merijn, Data-types a la carte?
10:08:31 <merijn> augustss: Naah, it was a specific discussion about why inheritance was bad in game engine context
10:08:38 <augustss> Ah
10:08:39 <merijn> Which seems exactly what chrisdotcode_ wants
10:08:54 <merijn> Lack of extensibility was one major reason
10:09:29 <fruitFly> merijn: how good is vim? does it do much other than efficiently edit text? I'm using sublime now and wasn't sure if I should try emacs or what, what
10:09:36 <fruitFly> what's your take?
10:10:09 <merijn> I like vim, because I like modal editing, others hate it. It's a matter of trying
10:10:14 <xplat> vim is basically 'just' a text editor, but it's really good at being a text editor
10:11:15 <xplat> it's not so good at being a window system, irc client, or even an IDE (although for some languages it can skate by as that)
10:12:01 <chrisdotcode_> merijn: I *know* that there's a more extensible system than inheretance somewhere...
10:12:02 <Hermit> there are 3 reasons that drove me away from vim: 1. bizarre cursor logic  2. lame scripting language (at least lamer than elisp)  3. doesn't play nice with processes (at least didn't use to, emacs does this just fine, and allows for really nice integration of repls and language-modes)
10:12:09 * bitonic couldn’t be typing these words in his editor if he was using vim
10:12:39 <bitonic> Hermit: 2. its API has bindings to a lot of stuff 3. now, ‘very nice’ is a big word
10:14:06 <xplat> Hermit: cursor positioning is my #1 actual pet peeve with vim, but those other things are more a matter of 'don't butter your bread with a screwdriver'
10:15:47 <merijn> chrisdotcode_: The basic issue is that many reasons for needing inheritance in other languages stem from lack of 1) proper polymorphism (i.e. you can't define lists for arbitrary values like you can in haskell with [a]) 2) good ad hoc polymorphism (i.e. what typeclasses let you do) 3) just embedding thinks like augustss' example earlier
10:15:47 <Tene> I'm curious about what properties of vim's cursor positioning are undesirable, and what properties cursor positioning has in other editors that are more desirable.
10:16:05 <Hermit> bitonic: yeah, but I don't like to have a plethora of languages for extensions. There should be a powerful, very well supported one. I really don't like having to mess with perl for example if I want to change some behavior in a script
10:16:06 <xplat> #2 is marginal.  probably you shouldn't have a script language at all if it's going to suck that badly, sort of an 'attractive nuisance' principle
10:16:32 <chrisdotcode_> merijn: well what about Generics? are Haskell's ADTs better?
10:16:41 <bitonic> Hermit: yeah but doing it in Python or whatever is better than doing it in VimL.
10:16:53 <Hermit> xplat: well, I've already got used to emacs, and I'm doing pretty good with it. I see no need to move back to vim. It'd be a waste of time and effort at this point
10:16:56 <bitonic> anyway, I haven’t been using vim for three years, so :P
10:17:14 <merijn> chrisdotcode_: Especially with higher order functions, instead of needing a "comparable" instance you could just write "sortBy :: (a -> a -> Ordering) -> [a] -> [a]" no inheritance necessary!
10:17:14 <augustss> chrisdotcode_, Haskell is "generic" by default.
10:17:42 <merijn> :t []
10:17:43 <lambdabot> [a]
10:17:53 <merijn> chrisdotcode_: There you go, generic list for any a
10:18:08 <chrisdotcode_> merijn: don't you need a restriction of "Ordering" in that type signature for a, though?
10:18:29 <merijn> chrisdotcode_: In fact, defining a generic type is as easy as "data Foo a = Foo a", defines a generic type Foo that works for any other type
10:18:31 <chrisdotcode_> @hoogle (a -> a -> Ordering) -> [a] -> [a]
10:18:31 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
10:18:31 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
10:18:31 <lambdabot> Data.List maximumBy :: (a -> a -> Ordering) -> [a] -> a
10:18:38 <Tene> Hermit, xplat: any chance you could discuss the cursor positioning logic complaints further?
10:18:39 <merijn> chrisdotcode_: Why? I already pass it a function that returns an Ordering
10:18:41 <frerich> chrisdotcode_: No, you wouldn't.
10:18:42 <xplat> Tene: well, you can't position your cursor immediately before the newline at the end of a line, and to fit that logic the cursor is always positioned before the last character you inserted after you insert something
10:18:51 <merijn> chrisdotcode_: Just use that function to compare? :p
10:19:03 <merijn> chrisdotcode_: Ordering is just a datatype
10:19:03 <Hermit> Tene: sure, I'll write a long line addressed to you in a bit
10:19:08 <merijn> :t (LT, EQ, GT)
10:19:09 <lambdabot> (Ordering, Ordering, Ordering)
10:19:17 <xplat> Tene: so 'iblah<ESC>' repeated 3 times gives you 'blablablahhh'
10:19:23 <merijn> > compare 1 2
10:19:24 <lambdabot>   LT
10:19:26 <Tene> Hermit: Thanks. :)
10:19:45 <chrisdotcode_> merijn: yeah, I know that much :) but I thought that you'd have to do: (Eq a) => (a -> a -> Ordering) -> [a] -> [a] ?
10:20:15 <frerich> chrisdotcode_: It might be that the a -> a -> Ordering function you pass in has a requirement on 'Ord' or something, but it could also just be '\_ _ -> EQ' or something.
10:20:21 <merijn> chrisdotcode_: No, if you have a function "a -> a -> Ordering" then that compares two a's, right? Regardless of what it does internally
10:20:34 <merijn> :t \x y -> EQ
10:20:34 <lambdabot> t -> t1 -> Ordering
10:20:51 <frerich> chrisdotcode_: sort* by itself doesn't have that dependency, but the comparison function might.
10:20:52 <Tene> xplat: So, using a instead there is insufficient, because keeping track of whether you want to use i or a is part of the problem?
10:20:58 <chrisdotcode_> frerich: oh, okay.
10:20:58 <xplat> Tene: if you just inserted something and you want to add to it you must resume with 'a', but this doesn't work for repeating
10:21:04 <chrisdotcode_> and so you don't *have* to specify that?
10:21:24 <chrisdotcode_> could you do: (Ord a) => (a -> a -> Ordering) -> [b] -> [b] ?
10:21:24 <frerich> You don't have to specify requirements you don't have, that's right. :)
10:21:40 <augustss> chrisdotcode_, There would be no point in that.
10:21:52 <frerich> chrisdotcode_: You could, but that wouldn't be very useful.
10:22:01 <chrisdotcode_> Ah, alright.
10:22:03 <xplat> you could insert something you want to repeat by going one to the left and using 'a', but that doesn't work at the *beginning* of the line, unless the line is empty
10:22:27 <augustss> chrisdotcode_, That function can not do anything that depends on the list elements.
10:23:05 <merijn> chrisdotcode_: You could, but it couldn't use the function on the list
10:23:17 <chrisdotcode_> well why not?
10:23:36 <merijn> Because if "a = Int" and "b = Double" how would that work?
10:23:41 <frerich> chrisdotcode_:  You get a list of 'b' values but your function can only take 'a'.
10:23:49 <Tene> xplat: Thanks.
10:23:50 <augustss> chrisdotcode_, The list has elements of type b in it.  There's nothing you can do to those.
10:24:03 * frerich should just shut up because he has nothing to add between augustss and merijn :-}
10:24:06 <merijn> chrisdotcode_: You don't know what type b will be, inside the function
10:24:26 <augustss> frerich, The more the merrier. :)
10:24:47 <chrisdotcode_> so (Ord a) => (a -> a -> Ordering) -> [a] -> [a] doesn't work either?
10:24:48 <merijn> chrisdotcode_: on the other hand, my type earlier guarantees the list has a type accepted by your function
10:24:55 <merijn> chrisdotcode_: That does work
10:24:55 <chrisdotcode_> * so (Ord a) => (a -> a -> Ordering) -> [a] -> [Ordering] doesn't work either?
10:25:05 <Hermit> Tene: to me, vim cursor logic is just moronic because it stands ON a character instead of BETWEEN them. Also, that it ignores the linebreak character's existence in a line, so you can't put your cursor on it, joining lines just deleting it. The main problem with these design choice are that you end up needing 2 commands for everything (one to append, one to prepend, be it for insert, paste, whatever) and
10:25:08 <Hermit> that you can't go just past the last word in a line, while still staying in it. This last issue is evidenced with this simple operation: http://dpaste.com/1239254 (transposing words). In this example, transposing words where one is at the end of the line requires a different chord of commands than for any other scenario, while in emacs is as consistent and intuitive as it can be. Give it a try yourself ;-)
10:25:09 <chrisdotcode_> er, scrap that second one
10:25:10 <augustss> chrisdotcode_, That would work, but now you have to ways to compare the a.
10:25:11 <merijn> chrisdotcode_: That one works but is extremely odd...
10:25:14 <chrisdotcode_> the first one works, but not the second
10:25:22 <chrisdotcode_> okay
10:25:23 <merijn> chrisdotcode_: Well, the second one works but is silly
10:25:23 <chrisdotcode_> I get it now
10:25:29 <chrisdotcode_> merijn: the second works?
10:25:38 <chrisdotcode_> won't it just return a whole bunch of LT, GTS and EQs?
10:25:41 <merijn> chrisdotcode_: I don't know what it would do, but you could write it :p
10:25:44 <merijn> chrisdotcode_: Yes
10:25:47 <Tene> Hermit: Thanks. :)
10:26:04 <merijn> chrisdotcode_: But, why would you need "Ord a =>" there?
10:26:14 <chrisdotcode_> merijn: I was just curious...
10:26:17 <merijn> chrisdotcode_: "a -> a -> Ordering" already tells you how to order a's
10:26:23 <chrisdotcode_> right.
10:26:53 <merijn> Now, "sort :: Ord a => [a] -> [a]" does require Ord a, since it doesn't know how to sort a's otherwise
10:26:55 <Hermit> Tene: note that both swap examples part from the same original cursor position in the first line (where the cursor is |)
10:27:29 <acowley> merijn: I'm probably misunderstanding something, but the code I linked you polls GLFW for input and in fact sets up a main loop much like the netwire code you had.
10:27:58 <merijn> chrisdotcode_: But almost any scenario like that can be rewritten to pass the relevant function as extra argument! In OO you rely on inheritance to provide functionality on a value. Here you can just pass that functionality as extra argument
10:28:23 <merijn> acowley: Oh, sure, but I already knew how to write that myself, I was just wondering if there was a nicer interaction model :)
10:28:39 <chrisdotcode_> thankfully, javascript taught me about how awesome higher-order functions are.
10:28:49 <xplat> chrisdotcode_: the essential advantage haskell has here is higher order functions (treating code as data)
10:28:56 <augustss> chrisdotcode_, And even if you use, say (Ord a), to pass the functionality to compare implicitely, it's still not attached to the data (like vtable is).
10:29:28 <xplat> chrisdotcode_: you can kind of simulate this in some OO languages (inner classes, etc) but it feels so heavy and awkward that you are tempted to use inheritance (wrongly) instead
10:29:36 <frerich> chrisdotcode_: In my experience, in the vast majority of cases where you think that type classes (like "Ord") are needed, or that you need to create your own type class - you don't. You would be better off just passing a plain ol' function.
10:30:28 <chrisdotcode_> xplat: anonymous classes that implement methods makes me cry in Java.
10:30:43 <augustss> Java makes me cry.
10:30:55 <chrisdotcode_> frerich: and that's good advice to keep in mind, thanks. I was always under the impression that more info in the type signature was never a bad thing
10:31:16 * frerich hopes whoever is doing the Haskell Weekly News noticed that augustss' last message would make a nice quote.
10:31:16 <xplat> chrisdotcode_: as opposed to anonymous classes that don't implement methods?
10:32:04 <chrisdotcode_> xplat: I believe I've needed an empty object to pass to a function and had to instantiate one anonymously
10:32:04 <frerich> chrisdotcode_: You only want to have as much information (i.e. "constraining" information) in your signature as necessary, not as possible - to foster reuse.
10:32:07 * chrisdotcode_ shudders
10:32:07 <xplat> frerich: quoting that out of context is just trolling though
10:32:41 <chrisdotcode_> frerich: yeah, that was my next thought: if it's too specific, it makes it harder to reuse.
10:32:56 <frerich> chrisdotcode_: I.e. the signature should be constraining enough to make it impossible to call the function wrongly, but not more constraining than that.
10:32:58 <augustss> Stating the obvious should not make a quote.
10:33:11 <frerich> Oh, a recursive quote right there!
10:33:16 <chrisdotcode_> right, that makes sense
10:33:29 <xplat> an Ord constraint on sortBy would actually only provide redundant information, and make it harder to figure out what sortBy does
10:34:01 <augustss> chrisdotcode_, As a beginner it's a good idea to see what type the compiler infers for you.  It might be more general that what you're thinking of yourself.
10:34:35 <int-e> @type sortBy (comparing ($ 1))
10:34:36 <lambdabot> (Num a1, Ord a) => [a1 -> a] -> [a1 -> a]
10:34:48 <xplat> interestingly 'just enough to make it impossible to call the function wrongly' generally turns out to be the same as 'just enough to make it possible to write the function'
10:35:03 <int-e> xplat: sometimes the things you want to sort don't even have a proper Ord instance.
10:35:28 <xplat> (this is actually what one hopes for in a strongly-typed language)
10:36:06 <augustss> The more polymorphic the function is, the easier it is to write the right code.
10:36:58 <augustss> As illustrated by djinn :)
10:37:04 <frerich> I think you could generalize that to "The less a function knows about the types it's dealing with, the easier it is to write the right code."
10:37:36 <int-e> @djinn (a -> b) -> (c -> d) -> (b -> c) -> (a -> d)
10:37:36 <lambdabot> f a b c d = b (c (a d))
10:38:37 <xplat> @compose @pl @djinn (a -> b) -> (c -> d) -> (b -> c) -> (a -> d)
10:38:37 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
10:39:05 <xplat> i always forget the syntax for that plugin
10:39:17 <xplat> @compose pl djinn (a -> b) -> (c -> d) -> (b -> c) -> (a -> d)
10:39:20 <lambdabot> f = id (fix (const (flip ((.) . (.)) . flip (.))))
10:39:20 <lambdabot> optimization suspended, use @pl-resume to continue.
10:40:07 <augustss> Haha
10:40:18 <xplat> ... fix?!
10:40:24 <byorgey> it couldn't optimize  f = id (...) ?
10:40:27 <augustss> fix (const ...)
10:40:32 <byorgey> hehehe
10:40:47 <xplat> @pl-resume
10:40:48 <bitonic> fix const.  useful.
10:40:53 <lambdabot> f = id (fix (const (flip ((.) . (.)) . flip (.))))
10:40:53 <lambdabot> optimization suspended, use @pl-resume to continue.
10:41:10 <augustss> Looks like @pl needs some love.
10:41:43 <bitonic> pl has caused enough damage already!  ehe
10:41:53 <xplat> @pl f d = (b (c (a d))) -- at least this should work
10:41:53 <lambdabot> f = b . c . a
10:43:10 <xplat> @pl f c d = (b (c (a d)))
10:43:13 <lambdabot> f = id (fix (const ((b .) . (. a))))
10:43:14 <lambdabot> optimization suspended, use @pl-resume to continue.
10:43:20 <augustss> If @pl used ordinary bracket abstraction it should have found a good expression.
10:43:52 <xplat> i don't know *what* it's using that would cause it to use fix const here ...
10:43:55 <int-e> what is the fix doing there?
10:44:12 <xplat> i guess it's standing in for letrec
10:44:21 <augustss> It probably always abstracts the f and uses fix.  Just in case of recursion.
10:44:28 <int-e> ah.
10:44:35 <int-e> @pl f = a:f
10:44:35 <lambdabot> f = fix (a :)
10:44:42 <int-e> fair enough.
10:44:52 <augustss> And if f isn't used then it turns into fix (const ...)
10:45:08 <xplat> @pl \a b c d -> b (c (a d))
10:45:08 <lambdabot> flip ((.) . (.)) . flip (.)
10:46:45 <augustss> That's better.
10:48:21 <augustss> There must be something better than flip (.)
10:50:12 <xplat> (>>>)?
10:51:15 <augustss> yeah
10:52:08 <prophile> :t (>>>)
10:52:10 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
10:53:13 <xplat> Category cat => cat meow mew -> cat mew purr -> cat meow purr
10:54:55 <xplat> in this case it would be (meow -> mew) -> (mew -> purr) -> (meow -> purr)
10:56:25 <frerich> I should make a habit of using those type variables instead of 'a' and 'b'.
10:56:29 <augustss> I strongly dislike that you can no longer have operator type variables.
10:57:12 <augustss> Category (-:>) => (a -:> b) -> (b -:> c) -> (a -:> c)
10:57:47 <frerich> I think that's a bit confusing because you need to look closely to tell that -:> is a type variable and -> is not.
10:57:52 <bitonic> ah, I remember the discussion bout that
10:58:22 <bitonic> some other people complained too
10:58:24 <augustss> It breaks the lexical conventions of Haskell.
10:59:55 <lpsmith> err, does getAddrInfo work on windows at all?
11:00:19 <lpsmith> I haven't managed to get anything other than a DoesNotExist IOError
11:00:54 <bitonic> augustss: you can try to dig up the discussion in the mailing list, there was a reason I think
11:01:39 <Lethalman> I have a result from a function that is either Polygon | Polyline | Point | Empty
11:02:06 <Lethalman> my only option is to make data Contour = PolygonContour Polygon | PolylineContour Polyline | .... ?
11:02:37 <byorgey> if those are all different types, yes.
11:03:24 <Lethalman> byorgey, yes they are different types
11:03:36 <Lethalman> byorgey, so there's no way to do type Contour = Polygon | Polyline | ... or similar
11:03:38 <Lethalman> ?
11:03:43 <byorgey> Lethalman: no.
11:03:48 <Lethalman> :-(
11:03:51 <Lethalman> any other suggestion? :P
11:03:52 <bitonic> Lethalman: you can nest Eithers...
11:03:53 <byorgey> I suspect there may also be a better way to design your system so it becomes unnecessary.  But coming up with it is probably nontrivial and depends on the specifics of what you are trying to do.
11:04:03 <bitonic> Lethalman: but that doesn’t mean that you should
11:04:17 <Lethalman> byorgey, recognizing a contour from an image
11:04:34 <Lethalman> and that can be one of those things as you my imagine
11:04:47 <byorgey> Why can it be a point?
11:05:15 <Ralith> Lethalman: why are you so opposed to using a sum?
11:05:19 <byorgey> and why is a point something fundamentally different than a degenerate polyline?
11:05:34 <byorgey> for Empty, perhaps the result should be   Maybe (...)
11:06:06 <byorgey> how is a polygon different from a polyline?
11:06:07 <byorgey> etc.
11:06:09 <Lethalman> Ralith, a sum?
11:06:16 * hackagebot yesod-pnotify 0.4.2.0 - Yet another getMessage/setMessage using pnotify jquery plugins  http://hackage.haskell.org/package/yesod-pnotify-0.4.2.0 (KatsutoshiItoh)
11:06:18 <byorgey> these are the sorts of questions you should be asking yourself about the design.
11:06:28 <Lethalman> Ralith, because typing PolygonContour and embed a Polygon is verbose :P
11:06:30 <Lethalman> only that
11:06:32 <lpsmith> oh, n/m, I forgot to call withSocketsDo
11:06:41 <Lethalman> byorgey, because... a point is not a polyline
11:06:54 <Lethalman> byorgey, but I get your point
11:06:59 <Lethalman> byorgey, I can certainly do Maybe Polygon
11:07:19 <Lethalman> byorgey, but I can't decide whether it's a polygon or polyline then
11:07:29 <Lethalman> so either Polygon or Polyline
11:07:35 <Ralith> Lethalman: you've spent more time discussing it on IRC than it'd take to apply it many times over.
11:07:53 <Lethalman> Ralith, my time spent on irc was about knowing alternatives
11:08:07 <arcatan> Lethalman: how does your function return a value whose type is one of the Polygon | Polyline | ... ?
11:08:08 <Lethalman> Ralith, you know any?
11:08:25 <byorgey> arcatan: presumably Lethalman hasn't written it yet.
11:08:35 <Lethalman> byorgey, already written in another language
11:08:39 <arcatan> oh, okay
11:08:40 <byorgey> that too.
11:09:02 <byorgey> I keep getting an error message from emacs haskell-mode, "Symbol's function definition is void: process-live-p".  Anyone seen that before/have a suggestion?
11:09:20 <byorgey> I can send a message to the haskell-mode mailing list but thought I'd ask here first.
11:09:21 <Lethalman> arcatan, because, if I can't get a polygon, I can at least return a polyline or a point
11:09:31 <Lethalman> which is useful information for further computation
11:09:52 <Lethalman> you can have a triangle, or a line, or a point in an image, and I can decide which of those I'm seeing
11:10:14 <Lethalman> arcatan, I'm reading an image and getting the contour that is
11:10:24 <arcatan> right, now i understand
11:11:02 <Lethalman> so I go for data Contour :-) thanks
11:12:18 <byorgey> ah, it looks like process-live-p is something specific to emacs 24, which would explain why I have this problem on my desktop at school but not on my laptop
11:13:31 <frerich> Lethalman: I think 'recognize :: Image -> Maybe Contour' is a pretty nice signature, eys.
11:13:44 <Lethalman> frerich, right, without Empty
11:13:45 <Lethalman> good point
11:14:04 <Lethalman> also, I may do data Contour = Polygon [Point] | Polyline [Point] | Point
11:14:15 <Lethalman> and convert between types... what about this one?
11:14:30 <Lethalman> i.e. if I need interoperability with, e.g., geometric library, I convert the data
11:15:23 <frerich> Sounds like a plan, the only thing I'm not sure about is whether it's a good idea to have a data constructor "Point" which is the same as a totally unrelated type constructor.
11:15:35 <Lethalman> ah right
11:15:38 <frerich> but I guess it's not ambiguous in the context.
11:16:22 <frerich> Well you could have Polygon [Point] | Polyline [Point] | SinglePoint Point if you want to chicken out (which I probably would) :)
11:16:22 <Lethalman> frerich, I have type Point = (Int, Int)
11:16:32 <Lethalman> eheh
11:19:27 <Lethalman> or the last resort: Maybe [Point], then it's a polygon if last point is equal to the first one \o/
11:22:24 <frerich> Lethalman: You could also use that representation for single points(i.e. the list is just one element).
11:22:50 <Lethalman> frerich, what you mean?
11:22:53 <acube> Why do you need to Maybe there, is there a difference between Just [] and Nothing?
11:23:50 <chrisdotcode_> has anyone written a minecraft clone in haskell yet?
11:24:25 <frerich> Lethalman: Assuming you have 'recognize :: Image -> [Point]' you could say that: 1. If the list is empty, nothing was recognized (your "Empty" case). 2. If the given list is of length 1, then a single point was recognized. 2. If the last elemtn of the list is the same as the first, it's a polygon - otherwise it's a polyline.
11:24:59 <Lethalman> frerich, yes, I'm only concerned about the isPolygon :: [Point] -> Bool
11:25:16 <frerich> I think having dedicated types for this is nicer though, it makes the signatures more descriptive and possibly removes the need to verify some assumptions at runtime (i.e. a function which computes the area covered by a polygon wouldn't need to think about what to do if the list is empty or a polyline or what)
11:26:07 * Lethalman undecided
11:26:19 <frerich> Right, with discrete types the need for "isPolygon" would be reduced (you would only need it in a single place actually), which means that isPolygon would not need to bother handling empty lists or whatever.
11:26:48 <frerich> IMHO having a dedicated type fits the "Make the signatures constraining enough to make it hard to use the function wrongly" mindset quite nicely.
11:26:56 <Lethalman> right
11:27:03 <Lethalman> I go for data
11:27:23 <frerich> FWIW, it's still easy to have a 'asPointList :: Contour -> [Point]' function should you need it.
11:28:24 * frerich thinks calling it "discrete type" wasn't very appropriate, I think I meant "dedicated type"
11:38:06 <augustss> bitonic, I know the reason for changing the lexical convention for type operators.  I just think it was a bad one.
11:38:24 <bitonic> augustss: would you mind reminding me?  I was too lazy to dig
11:39:45 <augustss> bitonic, They thought that operators would be more useful for type constructors, since you need more of those than type variables.
11:40:30 <bitonic> augustss: so basically the principle that it breaks is ‘constructors are lexically different from variables’?
11:41:10 <dolio> There just are no type operator variables anymore.
11:41:14 <augustss> Upper case and : for constructors, lower case and non-: for variables.  That used to be the principle.
11:41:25 <augustss> For both values and types.
11:41:32 <dolio> Unless I'm misremembering.
11:41:39 <bitonic> right, so I’m not sure what the problem is with that.
11:42:16 <augustss> Now the rules for types and values are different.
11:42:46 <bitonic> OK.  but I was looking for a specific reason for the change
11:42:49 <bitonic> I think there was a trigger
11:42:53 <augustss> At least they could have given an exception, like operators beginning with ~ are type variables.
11:45:01 <augustss> I'm sure there was a trigger.  Someone was sick of starting types with a :.
11:46:24 <dolio> The type and value level have never been totally consistent, though.
11:46:42 <bitonic> augustss: I vaguely remember something more grounded.  but I might be wrong.
11:47:02 <dolio> Functions at the type level get lumped with constructors, whereas at the value level they're the same as variables.
11:47:13 <augustss> dolio, I know.
11:47:33 <dolio> And that was probably the trigger. People started writing more functions at the type level, and they all had to have constructor-like names.
11:47:35 <augustss> So by making it worse we make it better?
11:48:36 <luminous> i'm trying to wrap my head around something, apologies for the simplicity: When an argument to a function is a result of another function application, you have to use parentheses for that. For instance: a b (c d)  means the function a acting on two arguments, b and (c d), which itself is an application of function c to d.
11:48:37 <augustss> But type synonyms still have to begin with an upper case letter...
11:49:04 <luminous> specifically, i am confused about the " which itself is an application of function c to d" part of this
11:49:05 <augustss> luminous, yes, that's right.
11:49:34 <luminous> i get the first part, but not the second
11:49:44 <augustss> It refers to (c d)
11:49:55 <luminous> yes, i follow that
11:49:57 <luminous> but
11:50:12 <augustss> which is a function c with an argument d.
11:50:33 <luminous> AH
11:50:49 <luminous> yes, that mmakes sense
11:51:31 <luminous> i am having some difficulty with the terseness if the language descrubung haskell - hah
11:51:43 <luminous> *describing
11:53:20 <dolio> I suspect requiring all functions to be capitalized is a lot less annoying to people than requiring all operators to begin with :.
11:54:14 <augustss> And when Haskell gets proper dependent types we'll just relax all the restrictions on case. :)
11:54:15 <dolio> Which puts the vast majority of the names people want to use in a category that has very few uses.
11:55:26 <xplat> imagine if all your operators at the value level other than variables had to begin with :.  what a mess
11:55:48 <xplat> :>>=, :<++=
11:56:02 <xplat> :+
11:56:27 <augustss> > (0 :+ 1)^2
11:56:28 <lambdabot>   (-1.0) :+ 0.0
11:57:18 <augustss> > exp (pi * (0:+1))
11:57:20 <lambdabot>   (-1.0) :+ 1.2246063538223773e-16
11:58:01 <augustss> > exp (pi * (0:+1)) :: Complex CReal
11:58:03 <lambdabot>   (-1.0) :+ 0.0
11:58:42 <dolio> Haskell is already a complete mess for all the toward-dependently-typed stuff.
11:58:46 <dolio> With all the puns.
11:58:56 <augustss> Yeah, it's horrid.
11:59:16 <augustss> Semi-automagic lifting of types to kinds.
11:59:58 <bitonic> I think fitting the dependent peg in the Haskell hole is a mistake
12:00:04 <bitonic> Haskell is pretty good as it is
12:01:24 <augustss> But it's going to be hard to get a dependently typed language sufficiantly popular to really take off.
12:01:57 <Zekka> augustss - Is there a particular reason why?
12:02:58 <Eduard_Munteanu> Well, for one thing getting any new language to take off is rather difficult.
12:03:06 <sclv_> plus a barrier to entry
12:03:17 <Heffalump> surely there's a lot of infrastructure that the right language could share with Haskell
12:03:19 <sclv_> the latter being the sort of thing idris tries to address
12:03:37 <sclv_> by letting you 'opt in' to the fancier features
12:04:13 <dolio> Only took a little over two decades for Haskell to get so popular. :)
12:04:33 <augustss> In another two decades Idris might be popular.
12:04:37 <Eduard_Munteanu> One other way to make it more palatable is making it real easy to call existing (Haskell) code.
12:04:56 <sclv_> trellys is another attempt on the same lines http://www.seas.upenn.edu/~sweirich/papers/modal.pdf
12:05:08 <augustss> But the dependent types guys are not united behind one language, which is part of the reason Haskell succeeded.
12:05:25 <augustss> We were mostly united.
12:06:01 <frerich> Can anybody explain what "dependent types" are, in layman's terms (I don't have a math or Comp. Sci. background) as opposed to Haskell's… what do you call them - independent types? :)
12:06:03 <Heffalump> is the time right for them to get together like the Haskell creators did?
12:06:10 <Zekka> You've got a point - there are plenty of competing languages using dependent types that cover a lot of ground in common.
12:06:36 <augustss> Heffalump, I tried to get them to rally behind one language a couple of years ago.  They didn't want to.
12:06:46 <Eduard_Munteanu> frerich: types which can depend on values, if you look at the name
12:06:50 <Zekka> frerich - Wikipedia explains it handily: types that depend on values.
12:07:00 * djahandarie doesn't like the word 'depend' really
12:07:05 <Zekka> It also provides some examples.
12:07:07 <Eduard_Munteanu> frerich: in Haskell, types can already depend on other types, e.g. functors.
12:07:14 <Heffalump> I guess there seem to be some significant fundamental design choices that might make it difficult
12:07:21 <augustss> frerich, consider this function:  f b = if b then "a" else True
12:07:24 <Heffalump> Conor once explained one of them to me, but I didn't understand it
12:07:35 <frerich> Eduard_Munteanu: I.e. "Maybe" would be a dependent type (anything with a type constructor taking 1 or more arguments would be a type depending on another type)?
12:07:52 <frerich> augustss: Ah, the type of 'f b' would depend on the value 'b'?
12:08:13 <augustss> frerich, It's not well typed in Haskell.  But with dependent types you could imagine giving it a type like:  f :: (b :: Bool) -> if b then String else Bool
12:08:23 <frerich> Ah, I see.
12:08:24 <arkeet> frerich: types cannot depend on values in haskell.
12:08:29 <arkeet> that's called dependent types, yes
12:09:06 <augustss> Heffalump, Yes, there are design choices.  And they will never agree on one thing.
12:09:20 <Eduard_Munteanu> In practice it's more like we don't really distinguish values and types, and we're free to mix them.
12:10:11 <Heffalump> the thing I can't characterise/explain clearly is how GADTs fall short of being dependent types
12:10:24 <frerich> Is there a situation where it would be convenient to have types depending on values instead of depending on other types? It seems like polymorphy to me in a way, except that the types don't need to have any relation at all (e.g. no common type class)?
12:10:47 <augustss> frerich, What's the type of printf?
12:10:49 <Eduard_Munteanu> frerich: think of length-indexed lists
12:11:14 <frerich> augustss: In Haskell? I would need to look it up, but I suspect it's String or ByteString or some such?
12:11:23 <frerich> er
12:11:26 <frerich> That's sprintf
12:11:34 <Zekka> I think he means for you to consider the type of its arguments.
12:11:38 <augustss> frerich, I mean in general.. The type it has in Haskell is wrong.
12:11:41 <frerich> Oh
12:11:44 <Eduard_Munteanu> You'd like the length to be a normal value, rather than some phantom construct at the type level.
12:12:01 <sclv__> augustss: what language was that at the time?
12:12:02 <Zekka> If you look at it in C, the first argument determines what types the rest of the arguments should have.
12:12:06 <augustss> frerich, The type of printf depends on the value of formatting string.
12:12:08 <frerich> augustss: That's a good question actually, I don't know how you could have what C calls "varargs" in Haskell.
12:13:00 <arkeet> typeclass magic.
12:13:02 <frerich> augustss: but how could you possibly cover all possible strings which 'printf' might take?
12:13:03 <augustss> frerich, The printf in C and Haskell are similar.  Things go wrong at runtime if you pass the wrong arguments.
12:13:26 <dolio> Heffalump: GADTs are something that not even all dependently typed languages necessarily have.
12:13:28 <Eduard_Munteanu> Eh, some compilers do check types in varargs.
12:13:28 <arkeet> > printf "%s" 5 :: String
12:13:29 <lambdabot>   "*Exception: Printf.printf: bad argument
12:13:30 <augustss> frerich, By writing a function that computes the type from the string.
12:13:31 <frerich> augustss: I see how you could check for a specific value, say "%d/%d" and then expect printf to be 'Int -> Int -> IO String' or something like that.
12:13:38 <Zekka> You could pass the formatting string to a function that parses it and returns what types it includes.
12:14:04 <frerich> augustss: Oh, so being able to compute types at runtime is part of "dependent types", i.e having a… what is it called… "meta value" which evaluates to a type?
12:14:17 <augustss> frerich, http://en.wikipedia.org/wiki/Cayenne_(programming_language)
12:14:21 <sclv_> or do you mean you tried to get people together to figure out what such a common language would be?
12:14:38 <Eduard_Munteanu> frerich: yes... one side-effect of full dependent types is you can't erase types easily.
12:14:47 <dolio> You do not compute types at runtime.
12:14:57 <dolio> Or, you do not need to.
12:15:04 <augustss> sclv_, I was a DT meeting and told people it was time to unite.  Especially Conor didn't want that.
12:15:53 <shachaf> What, unification isn't good enough for their fancy type systems?
12:16:20 <frerich> augustss: Would it be fair to say that with dependent types, the difference between types and values gets smaller - since something like "PrintfType" in that Cayenne page is a function, i.e. it yield a value - but that value is a type which is part of the signature of another function?
12:16:21 <augustss> sclv_, I didn't suggest a particular language.  Just that they should do something.
12:16:42 <sclv_> haha sure. maybe if one or two designs start to converge more then it will seem more direct.
12:16:49 <augustss> frerich, Yes, types and values sorta merge.
12:16:59 <sclv_> my sense is that at the time of the haskell committee the languages were starting to look _very_ similar already
12:17:01 <frerich> augustss: I.e. with dependent types, a value has a type, but a value can also be a type.
12:17:02 <sclv_> ?
12:17:46 <simon> @pl do {x <- get; return $ f (g x)}
12:17:47 <lambdabot> (line 1, column 4):
12:17:47 <lambdabot> unexpected '{'
12:17:47 <lambdabot> expecting variable, "(", operator or end of input
12:17:49 <frerich> augustss: I think this is my lack of Computer Science showing, but it seems like a pretty fundamental shift in perception to me, with consequences so hard to foresee that it makes me dizzy. %-)
12:17:57 <Eduard_Munteanu> frerich: general DT languages let you use values everywhere, including type sigs
12:17:59 <augustss> sclv_, The languages didn't look that similar, but they had a core which was semantically the same.
12:18:29 <augustss> frerich, Everything has a type, types as well.  Just as they do in Haskell.
12:18:31 <simon> @pl liftM (f . g) get
12:18:31 <lambdabot> fmap (f . g) get
12:18:34 <Eduard_Munteanu> Now sure   foo :: 5    doesn't make much sense, but you can write that.
12:18:34 <frerich> augustss: Hoho, and now I realize the language Cayenne was done by somebody whose real name is remarkable similar to your IRC nick. Probably not a coincidence? :-)
12:19:20 <augustss> sclv_, I also suggested that they didn't really have to have a common semantic underpinning for all languages.  Just a common syntax. :)
12:19:44 <dolio> Well, that's good. Because I don't think they do have a common semantics. :)
12:20:25 <augustss> "I often quote myself. It adds spice to my conversation.
12:20:25 <augustss> " -- George Bernard Shaw
12:20:45 <Ralith> frerich: if you're interested in DT, you should play with idris!
12:20:54 <shachaf> I, too, often quote George Bernard Shaw to add spice to my conversation.
12:20:59 <Zekka> augustss - I thought you were dead.
12:21:09 <augustss> dolio, They don't.  But they share a lot.
12:21:19 <Ralith> Eduard_Munteanu: can't you erase types just by deleting all values which are never inspected?
12:21:28 <dolio> Yeah.
12:21:31 <augustss> Zekka, George Bernard Shaw is dead.
12:21:55 <dolio> I think that was the time to quote Mark Twain.
12:22:08 <augustss> You're right!
12:22:16 <augustss> I'm too slow.
12:22:28 <Eduard_Munteanu> Ralith: I don't think you can tell that easily, unless you have something like Coq's Prop or Agda's irrelevance.
12:22:52 <Eduard_Munteanu> But those restrict the way you write stuff in the first place.
12:23:01 <augustss> "The reports of my death have been greatly exaggerated.
12:23:02 <augustss> " -- Mark Twain
12:23:15 <dolio> Just erase everything with type Type.
12:23:25 <dolio> And similar.
12:23:28 <dolio> That's a good first pass.
12:23:34 <augustss> Eduard_Munteanu, Cayenne does type erasure.
12:23:53 <augustss> It gets rid of some irrelevant terms.
12:24:11 <Ralith> Eduard_Munteanu: you can show it by whole-program analysis fairly trivially, no?
12:25:17 <Eduard_Munteanu> Ralith: not for all cases, I think.
12:25:45 <augustss> Exactly what's unused is undecidable, of course.  But a data flow analysis can get close enough.
12:25:48 <dolio> If you try really hard, you can do better than that. But you can at least erase types in most languages.
12:26:00 <Eduard_Munteanu> Unless I'm wrong, Coq and other systems where you have an erasable universe prevent you from mixing data and proofs in the first place.
12:26:06 <dolio> Unless you have some kind of type case construct.
12:26:33 <Eduard_Munteanu> Agda in contrast encourages one to mix them up in a way it's difficult to untangle by the compiler.
12:26:36 <Ralith> Eduard_Munteanu: can you provide a counterexample?
12:27:50 <augustss> Eduard_Munteanu, I don't believe that.  Now what makes it tricky is that there can be many ways to erase arguments that will still keep enough information.
12:28:09 <bitonic> Eduard_Munteanu: Coq has Prop which is irrelevant by design
12:28:14 <bitonic> well actually it’s a bit subtle, but it is
12:28:21 <bitonic> and you can put irrelevant data types in Prop as well
12:28:22 <augustss> And picking the optimal way to erase is probably a hard problem.
12:28:28 <bitonic> e.g. things with one constructor with irrelevant things in them
12:28:54 <sclv_> i've been trying to google up a really nice article on how you can do erasurish things with dt languages, but i've forgotten everything about it except that it was very educational :-)
12:29:08 <Eduard_Munteanu> augustss: hm... not sure I'm reading that right, are you saying it's possible to fully infer irrelevance? Or that you can do "well enough"?
12:29:15 <sclv_> also it helps a lot in Heffalump's question about how we distinguish haskell + all our new stuff from genuine DT
12:29:19 <Heffalump> augustss: how far (if at all!) have languages advanced since Cayenne?
12:29:27 <sclv_> since the whole way you think about phase seperation changes
12:29:31 <augustss> Eduard_Munteanu, Well enough.
12:29:52 <dolio> sclv_: Was it the one by Tim Sheard and Nathan Mishra-Linger?
12:30:00 <dolio> Erasure Pure Type Systems?
12:30:12 <bitonic> what do we mean by ‘irrelevance’ here exactly?  identify as equal all members of types with 0 or 1 elements?
12:30:39 <dolio> (Mishra-Linger also has a whole thesis on it.)
12:30:42 <augustss> Heffalump, Cayenne didn't have GADTs (by design, but it was a mistake), so I'd say they have advanced.
12:30:42 <Eduard_Munteanu> Ralith: not off the top of my head, but in Agda is common to embed proofs in datatypes
12:31:03 <bitonic> Heffalump: inductive families, coinduction, generic programming
12:31:06 <bitonic> universe polymorphism
12:31:11 <Ralith> Eduard_Munteanu: I don't see how that poses a problem
12:31:17 <bitonic> Heffalump: dependent pattern matching
12:31:18 <sclv_> aha here it is: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.131.7913
12:31:26 <bitonic> Heffalump: dynamic pattern unification
12:31:27 <sclv_> phase distinctions in the compilation of epigram
12:31:36 <Eduard_Munteanu> Ralith: trivially, there is stuff like   foo : (b : Bool) -> if b then N else Z
12:31:47 <simon> :t liftM lookup get
12:31:48 <lambdabot> (Eq a1, MonadState a1 m) => m ([(a1, b)] -> Maybe b)
12:31:49 <augustss> bitonic, A lot of the things you mention are really the same :)
12:31:49 * Heffalump doesn't really know what most of those things are :-(
12:31:55 <bitonic> augustss: like what?
12:32:01 <Heffalump> heh, now I feel a bit better about that :-)
12:32:03 <bitonic> Heffalump: but you can google them :)
12:32:18 <Ralith> Eduard_Munteanu: what type information do you imagine not being erased there?
12:32:34 <augustss> bitonic, OK, only inductive families and dependent pattern matching.  They go together.
12:32:47 <bitonic> augustss: not necessarly, case in point being Coq
12:33:03 <bitonic> in fact they were formulated indipendently
12:33:10 <simon> ::t liftM2 lookup get
12:33:23 <augustss> True
12:33:24 <Eduard_Munteanu> Ralith: you don't erase anything if all your occurences of 'foo' refer to a 'b' that's obtained at runtime
12:33:27 <simon> :t liftM2 lookup get
12:33:28 <lambdabot> (Eq a1, MonadState a1 m) => m [(a1, b)] -> m (Maybe b)
12:33:28 <sclv_> section 2.4 in particular gives a sense of how our traditional notion of phase distinction has to change, even while we can recover other notions that let us get efficiency back
12:33:30 <bitonic> dependent pattern matching was around before inductive families existed
12:33:37 <Heffalump> bitonic: just doing that :-)
12:33:53 <wavewave> hi
12:34:01 <bitonic> Ralith: yeah the problem is with neutral terms.  you can’t have ‘ite : Bool -> Prop -> Prop -> Prop’ in agda
12:34:15 <sclv_> haha i see augustss is thanked in the conclusion of that paper too :-)
12:34:16 <Ralith> Eduard_Munteanu: I don't see any need to retain type information there, presuming everything's boxed
12:34:25 <augustss> sclv, Ed Brady's PhD thesis was on this subject.
12:34:29 <Heffalump> you get generic programming in non-dependent languages, are the two orthogonal or does generic programming + dependent types add up to much more power?
12:34:31 <Ralith> bitonic: sorry, what? My backgrond is with idris, not Coq
12:34:35 <bitonic> Ralith: so if you have a ‘ite : Bool -> Type -> Type -> Type’ it probably won’t be able to prove it irrelevant
12:34:46 <augustss> sclv_, I was the external examiner for Ed's thesis. :)
12:34:58 <Ralith> bitonic: why not?
12:35:10 <bitonic> Ralith: or in general hypothetical things—if you have a ‘x : Type’ in scope it won’t be able to prove it irrelevant
12:35:30 <bitonic> Ralith: the example of abstract variables is probably better, you can’t express ‘x : Prop’ in Agda
12:35:41 <sclv_> huh i should probably read his whole thesis at some point
12:35:48 <dolio> All x : Type are irrelevant.
12:35:57 <bitonic> you can’t say ‘this argument here is Prop’
12:35:57 <dolio> Unless your language is weird.
12:36:01 <bitonic> dolio: not their members
12:36:06 <Ralith> bitonic: I must be missing something here; why can't you prove anything irrelevant just by showing that there's no case splitting or primitive operation on it?
12:36:09 <dolio> What does that have to do with type erasure?
12:36:20 * hackagebot gpah 0.0.1 - Generic Programming Use in Hackage  http://hackage.haskell.org/package/gpah-0.0.1 (JohanJeuring)
12:36:39 <Eduard_Munteanu> Ralith: not sure boxing even matters, unless you're making an argument in the same vein as "typeclasses are erased"
12:36:39 <augustss> dolio, But is y irrelevant if we know y :: x, x :: Type?
12:36:51 <dolio> No, not necessarily.
12:37:19 <augustss> dolio, Exactly.  Which is why Cayenne had a crazy stratification of types.
12:37:30 <dolio> You don't get to erase your values in Haskell, either, unless you do a lot of work.
12:38:13 <Heffalump> isn't it just a dataflow analysis that would be standard in imperative languages?
12:38:14 <Ralith> Eduard_Munteanu: boxing matters because it's what allows you to manipulate values of arbitrary types through a single ABI
12:38:28 <dolio> Well, maybe not 'a lot' of work. I don't know.
12:38:41 <augustss> Heffalump, It's more complex.  There can be multiple ways to erase.
12:38:57 <Heffalump> oh, so one erasure might invalidate another?
12:39:03 <dolio> JHC does it, for instance, I guess.
12:39:06 <augustss> Heffalump, yes.
12:39:26 <Heffalump> is there a simple example of that?
12:39:30 <sclv_> Heffalump: hrm, good question. (wrt generic programming) one way you get 'more power' as i understand it is that you don't need compiler magic to figure out the 'spine' representation of your type or anything, typically.
12:39:33 <augustss> Heffalump, you can have a function f x y = ... where you can erase x or y, but not both.
12:39:40 <sclv_> you can program on it directly.
12:40:18 <sclv_> i'd imagine the other sort of 'more power' you can get is that you can program over notions of types directly without going through actually going to some uniform rep.
12:40:32 <augustss> Heffalump, f (x :: T) (y :: t) (Equal x y) = ...
12:40:39 <sclv_> and of course finally you can ensure your transformations obey all sorts of laws enforced not by only the shapes of the types
12:40:52 <augustss> Heffalump, So you know from the proof object that x and y are equal.
12:41:28 <augustss> Heffalump, Something like that.
12:41:40 <dolio> Heffalump: One place this can come up... People were just talking about Edwin Brady's stuff. It was about (or, one thing was) how inductive families don't need to store their indices. So sized vectors don't need to store their size internally.
12:41:51 <dolio> Because it's always passed in as an argument that the vector type depends on.
12:41:52 <Heffalump> I see - so it's an analysis that also captures equivalent values
12:42:15 <dolio> But, if that natural number only appears in the types, you can view it as erasable, too.
12:42:20 <augustss> Heffalump, as dolio mentions, it can be much more subtle than that.
12:42:26 <dolio> Because it's only around for typing to work out.
12:42:43 <dolio> But, if you write a length function that grabs the length information that's supposed to be there, you can only erase one or the other.
12:43:08 <Heffalump> augustss: that example doesn't sound fundamentally more subtle than yours, just more involved in terms of the flow
12:43:08 <dolio> Or you erase both and recompute it.
12:43:47 <augustss> Heffalump, maybe not fundamentally.
12:43:49 <bitonic> dolio, Ralith: sorry, crap connection
12:43:55 <bitonic> Ralith: what I was saying is that if you have a type in scope—say A : Type—you cannot prove members of that type to be irrelevant
12:45:02 <bitonic> Ralith: even if you are talking about top-level erasure, this is a problem
12:45:05 <acube> Does anyone familar with the GHC api know if ghc's getModuleGraph function ignores the import paths in the dyn flags?
12:45:09 <Ralith> bitonic: values x : A you mean?
12:45:16 <bitonic> Ralith: because you might postulate a top-level type, but you can’t postulate a top-level Prop
12:45:18 <bitonic> Ralith: yes
12:45:19 <augustss> Heffalump, But I think a normal data flow analysis gets you quite far.  But you need to flow through data structures as well.
12:45:26 <acube> It seems to me that that is the case, as setting -g -itests in hdevtools has no effect
12:45:58 <Ralith> bitonic: I don't know anything about Props; I think my point is basically what augustss is saying
12:46:11 <Heffalump> and of course data flow language on higher-order code is hard in the first place
12:46:18 <Ralith> i.e. it's straightforward to determine objectively whether a value is never inspected via whole-program analysis
12:46:19 <bitonic> Ralith: Prop is an irrelevant fragment of Type, in short (well in Coq is more than that)
12:46:23 <Heffalump> s/language/analysis/
12:46:42 <Ralith> it doesn't even matter what that values type is if nothing ever reads it.
12:46:45 <bitonic> Ralith: ah, OK.  I’m not sure I’d call an undecidable problem straightforward, but OK.
12:47:05 <Ralith> bitonic: er, sorry, I'm speaking too generally
12:47:15 <Ralith> what I refer to is a conservative erasure
12:47:22 <bitonic> I was talking about deciding irrelevance of entire types, so you can erase all their members
12:47:31 <Ralith> certainly you hit the halting problem if you take that approach in general.
12:47:54 <Eduard_Munteanu> Ah, fair then.
12:48:07 <bitonic> I think it’s a bit of a waste to do that when you can just isolate Prop
12:48:16 <bitonic> so that the user clearly states ‘these are irrelevant proofs’
12:48:38 <Ralith> erasing provably-unused values isn't a bad optimization to have regardless
12:48:45 <Eduard_Munteanu> But then it's harder to do Agda-fu like embedding proofs in objects.
12:49:04 <dolio> Erasing values of types based on the structure of the type isn't the only strategy, though.
12:49:07 <Ralith> Eduard_Munteanu: is there any reason why that's necessarily the case?
12:49:13 <dolio> For instance, it's not the basis for type erasure.
12:49:31 <dolio> Well, value-structure, at least.
12:49:32 <bitonic> Ralith: sure
12:49:40 <Eduard_Munteanu> Ralith: I mean something like Prop is more restrictive (even if nicer in other aspects)
12:49:49 <applicativ> whoa augustuss is here.
12:50:09 <Ralith> Eduard_Munteanu: it seems like, at the very least, it should be possible to have props inside values so long as you can prove they're never read.
12:50:13 <augustss> applicativ, I am.
12:50:14 <bitonic> dolio: what strategies are you referring too?  I was talking about irrelevance in general, e.g. in relation to deciding equality as well
12:50:32 <applicativ> well, greetings
12:50:52 <Ralith> bitonic: certainly a way to explicitly declare a type as erasable like that seems useful, I agree
12:50:53 <dolio> bitonic: As Ralith said, some things are computationally irrelevant because the function is parametric in it. It doesn't look at the value.
12:51:05 <dolio> Arguments to a function are irrelevant, regardless of their type.
12:51:24 <dolio> That is the basis for type erasure. There is no way to inspect the value, so you can throw it away.
12:51:40 <dolio> But you can also do analysis to try and figure out which functions are parametric in which arguments.
12:52:01 <dolio> Which probably works okay for first-order code, and less well for higher-order code.
12:52:02 <bitonic> dolio: right right.  so I had in mind another irrelevance (or anyway useful for another purpose)
12:52:30 <Eduard_Munteanu> Ralith: mm, not sure you can due to Prop's impredicativity
12:52:40 <Ralith> Eduard_Munteanu: elaborate? I'm a bit fuzzy on the formalisms here
12:52:52 <dolio> (Because for higher-order code your parametricity may depend on parametricity of functions that are passed in.)
12:53:01 <Eduard_Munteanu> Ralith: Prop : Prop, but the same thing doesn't hold for Set
12:53:15 <dolio> No. Prop is not an inhabitant of Prop.
12:53:20 <dolio> That would be inconsistent.
12:53:38 <Eduard_Munteanu> Not at face-value, but it is impredicative no?
12:53:39 <dolio> But, you can quantify over Prop in a Prop.
12:54:17 <dolio> So, ((A : Prop) -> A -> A) : Prop.
12:54:35 <dolio> Coq used to have an impredicative Set, too.
12:54:42 <dolio> You can still switch it on.
12:55:04 <Eduard_Munteanu> dolio: impredicative Set sounds really weird
12:55:16 <dolio> Does it? Because it's what GHC has.
12:55:24 <dolio> And the calculus of constructions. And System F....
12:55:25 <Eduard_Munteanu> Don't you get funny stuff like Russell's paradox?
12:55:40 <Eduard_Munteanu> Yeah, but those aren't proof systems. :)
12:55:41 <dolio> Well, maybe not GHC anymore.
12:55:51 <augustss> applicativ, Salutations
12:56:09 <meditans> Can I define an istance of a Class of a type of kind *? Something like instance SomeClass Int?
12:56:14 <Lethalman> with Maybe monad I have a <- b; c a. How can I do the same with applicatives?
12:56:17 <applicativ> augustss: i was going to say, you might find the readme for this project amusing https://github.com/luqui/Djest
12:56:30 <Lethalman> c <$> b returns nested maybes
12:56:40 <shachaf> meditans: What happened when you tried it?
12:56:41 <applicativ> the djinn idea is used to make 'a language in which you don't have to write the code'
12:56:43 <augustss> Eduard_Munteanu, You don't get a paradox unless you have certain other things as well.
12:56:47 <shachaf> Lethalman: You can't. That is the point.
12:56:54 <arkeet> meditans: what do you mean? of course you can write instance SomeClass Int
12:56:57 <dolio> Impredicativity at the lowest level is fine as far as anyone knows.
12:57:02 <arkeet> if SomeClass is a class that takes a parameter of kind *
12:57:07 <byorgey> Lethalman: you can't.
12:57:19 <byorgey> Lethalman: you can write b >>= c  though.
12:57:26 <dolio> If you have impredicativity at higher levels in a hierarchy, you can write Girard's paradox.
12:57:36 <Lethalman> shachaf, ok I wanted to avoid nested case statements
12:57:43 <Lethalman> byorgey, good point, thanks
12:57:52 <dolio> So Coq had impredicative Set, but Type was predicative at higher levels.
12:57:57 <applicativ> it is a reductio of the idea of a test-suite, "The generated functions are then tested with the test suite until one that passes all the tests is found, at which point that function is taken as its definition. If it uses the wrong function, then clearly your test suite was not comprehensive!"
12:58:00 <Eduard_Munteanu> Is there any connection between impredicativity and irrelevance, as in the former implying the latter if certain conditions are met?
12:58:00 <augustss> applicativ, Cool
12:58:06 <Lethalman> byorgey, better c =<< b :-)
12:58:34 <meditans> arkeet: ok, and if I only want to have something like "class SomeClass" without "where ..."?
12:58:35 <dolio> Impredicativity is crucial to encoding data types and such, though.
12:59:06 <arkeet> meditans: then you just do that.
12:59:11 <meditans> like in "class Someclass; instance SomeClass Int"
12:59:20 <augustss> applicativ, Jeuring&al did something similar.
12:59:20 <Eduard_Munteanu> dolio: I thought Agda did fine with stratified Set :/
12:59:20 <byorgey> Lethalman: sure, that's more application-y
12:59:25 <arkeet> meditans: yes, that works.
12:59:27 <bitonic> dolio: isn’t having a ‘powerset’ function ‘(\A : Set0. A -> Set0) : Set0 -> Set0’ enough to derive bottom?  or do you mean something else with ‘impredicativity at the lowest level’?
12:59:33 <arkeet> but it doesn't sound very useful.
12:59:38 <bitonic> well maybe not just that function.
12:59:40 <meditans> but ghci tells me "no parameters for the class Simple"
13:00:06 <arkeet> well, you nee
13:00:08 <arkeet> class SomeClass a
13:00:33 <applicativ> augustss: ah. the idea is not surprising. this was originally for a competition to design a language with 'special emphasis on testing' ...
13:00:34 <Heffalump> how easy is it to type-check/compile dependently typed programs in a modular fashion?
13:00:59 <meditans> arkeet: omg, I'm a fool. Of course, thanks :)
13:01:02 <augustss> Heffalump, you can't really.
13:01:04 <Ralith> Heffalump: in general, typechecking code from one module may require executing code in another module
13:01:24 <Eduard_Munteanu> BTW, do any theorem provers stratify stuff in small/large classes only? I've always wondered why we use multiple levels and math prefers small/large only.
13:01:27 <qfwfq> @djinn x :: [(a -> b)] -> [a] -> [b]
13:01:27 <lambdabot> Cannot parse command
13:01:30 <Heffalump> that's a pretty big limitation, it's already a problem with Haskell
13:01:35 <Ralith> Heffalump: also whole-program analysis is very useful for optimizations, so you might not want that anyway.
13:01:51 <Ralith> I think the usefulness of separate compilation is overstated
13:01:55 <qfwfq> @djinn [(a -> b)] -> [a] -> [b]
13:01:55 <lambdabot> Error: Undefined type []
13:02:23 <dolio> Eduard_Munteanu: Agda doesn't encode data types into function spaces like you can in System F or the calculus of constructions. It just takes them as primitives.
13:02:27 <Eduard_Munteanu> Also, there's that Groethendieck universes construction in math, but the largeness there is quite different than the one in type theory.
13:02:30 <Heffalump> Ralith: I think it's crucial for large systems and for independent development.
13:02:35 <Eduard_Munteanu> (it's more like large in the cardinal sense)
13:02:37 <augustss> Heffalump, I think it's a problem you can overcome.  You don't really need access to all code from all imported modules.
13:02:48 <Ralith> Heffalump: why?
13:03:03 <chrisdone> okies, hpaste is going down temporarily to be migrated to another server. hold onto yer butts
13:03:04 <Eduard_Munteanu> Hm.
13:03:49 <Eduard_Munteanu> dolio: and by function spaces you mean encoding datatypes by eliminators and such?
13:03:50 <dolio> bitonic: Impredicativity does not allow you to give that function that type.
13:03:54 <applicativ> Eduard_Munteanu: the big/small classification is closely related to the set/proper class distinction, and thus set theoretic foundations. the gruesome hierarchies and so forth of type theory  were characteristic even of russell's type theory
13:03:57 <dolio> Eduard_Munteanu: Yes.
13:04:06 <augustss> Heffalump, In Cayenne you could choose if you wanted a definition to be available in other modules or not.  If you said no, some later type checking might fail, of course.
13:04:42 <Eduard_Munteanu> I tried really hard to find a Coq or Agda-like universe stratification in math, but I couldn't find anything resembling it.
13:04:46 <Ralith> idris has this feature as well, though I've found it hard to use; you often end up finding you want it for typechecking.
13:05:05 <Heffalump> Ralith: compilation performance, and deployment management
13:05:13 <dolio> Eduard_Munteanu: Principia Mathematica, maybe?
13:05:25 <Heffalump> also sane errors
13:05:27 <Eduard_Munteanu> Hm, I'll try that.
13:05:35 <Ralith> Heffalump: separate compilation is not the only way to get compilation performance. Intermediate results can still be stored for whole-program compilation.
13:05:47 <bitonic`> Eduard_Munteanu: ZF set theory?
13:05:51 <dolio> Eduard_Munteanu: Most mathematics is impredicative. And you can get away without a lot of talking about bigger universes when things are impredicative.
13:05:53 <Ralith> Heffalump: I don't know what 'deployment management' is, or why error reporting would be affected either way.
13:05:59 <Eduard_Munteanu> Arguably, specifying universe levels like a \lub b \lub (suc c) would look really odd on paper, I admit. :)
13:06:04 <applicativ> Eduard_Munteanu: it was rejected, historically. In my view for bad reasons, but revived in modern type theory for good reasons...
13:06:11 <dolio> Because things don't get shoved up a level as often.
13:06:21 <Heffalump> Ralith: having lots of different people deploying pieces of a large system at different times
13:06:28 <augustss> Ralith, Modular design is important.  It's terrible if all kinds of implementation details always leak out.
13:06:29 <Eduard_Munteanu> Or maybe because they don't care about datatypes.
13:06:48 <Ralith> augustss: yes, certainly, but modular design and separate compilation are different issues...
13:06:50 <Eduard_Munteanu> bitonic`: ZF only gives you 2 levels, no?
13:06:58 <applicativ> questions like predicativity were posed 1900-1930; then dropped as set theory took over. Now one regrets this destructuring monoculture
13:07:02 <sclv_> we had a very good talk at hac phi on program generation which seems quite similar
13:07:02 <bitonic`> Eduard_Munteanu: afaik it’s a cumulative hierarchy
13:07:09 <dolio> Eduard_Munteanu: Like, for embedding ZF in Coq, some impredicativity is required if you want to do powerset (maybe only impredicative Prop, but...).
13:07:14 <augustss> Ralith, yes, but related.
13:07:23 <dolio> Eduard_Munteanu: So, imagine if mathematicians had to use a bigger universe every time they used powerset.
13:07:24 <sclv_> although there one trick is to substitute a sat solver for brute enumeration :-)
13:07:37 <applicativ> there are only two levels in Eduard_Munteanu
13:07:38 <Eduard_Munteanu> bitonic: it is cumulative, since "classes" means either large or small
13:07:42 <applicativ> s sense
13:07:59 <bitonic> Eduard_Munteanu: oh right.  yeah you might be right.
13:08:04 <Ralith> augustss: if your point is just that I should have an easier time using hidden-implementation stuff, my challenges there have arisen because even when the implementation is well hidden, idris at least has trouble passing hidden values through external modules.
13:08:06 <applicativ> the underlying semantic picture is one of accumulation of ranks, which can even be viewed type theoretically
13:08:21 <sclv_> dolio: arguably, they do, they just don't admit it :-P
13:08:28 <dolio> Well...
13:08:36 <dolio> I'm not going to argue with that. :)
13:09:19 <Eduard_Munteanu> I wonder if there's any way to relate largeness in the cardinal sense vs typing sense. They seem independent notions of "big", to me.
13:09:19 <applicativ> Goedel thought of set theory in terms of types, it just makes progressive sums
13:10:06 <sclv_> in the cardinal sense we have bijections, in the typing sense we have containment, right?
13:10:14 <augustss> Ralith, My point is that sometimes you don't want the body of foo exported from a module.  That means that nothing of interest can be proven about foo outside the module, so any properties you need of foo have to be proven inside the module and their proofs exported.
13:10:15 <sclv_> like largeness in the typing sense doesn't involve quantity at all
13:10:26 <sclv_> (which is also largeness in the categorical sense, as i understand it)
13:10:46 <applicativ> it doesn't in the set theoretic sense either; V has no associated cardinal
13:10:49 <dolio> Eduard_Munteanu: I also don't think mathematicians want to internalize certain things the way we do.
13:10:50 <Eduard_Munteanu> sclv_: well, clearly large cardinality doesn't imply the other
13:10:57 <sclv_> but there are also rules for which axioms you need to get to what size of cardinals
13:11:07 <dolio> Like, you might want lists of types to be things in the language.
13:11:09 <Ralith> augustss: that seems sane.
13:11:19 <Ralith> Heffalump: how is deployment management affected?
13:11:28 <Eduard_Munteanu> But maybe you can say something about the cardinality of proper classes or of level k sets?
13:11:31 <applicativ> dolio the mathematics could have been different. they made a number of decisions in the period 1900-1930
13:12:00 <bitonic> dolio: so wait, in Agda we could have Set0 to be impredicative and things would be fine?
13:12:01 <Eduard_Munteanu> dolio: hm, yeah, I guess they just don't need it and it's a nuisance
13:12:14 <bitonic> (still regarding the ‘you can be impredicative at the lowest level)
13:12:19 <sclv_> so model theory and foundations in some sense lets us relate the two motions.
13:12:34 <augustss> bitonic, I don't think so.
13:12:49 <dolio> Eduard_Munteanu: And also, to do that, they never talk about the collection of all sets, and a list whose elements are characterized thereby.
13:12:51 <augustss> Because Agda has strong existentials.
13:13:14 <dolio> Whereas that's exactly how we'd talk about it.
13:13:30 <dolio> bitonic: They wouldn't be known to not be fine, at least.
13:14:05 <applicativ> sclv_: different axioms determine larger and larger cardinals, but that all cardinals are comparable as 'bigger' and 'smaller' depends on various classical assumptions to begin with.
13:14:09 <augustss> dolio, Are you sure?
13:14:09 <dolio> Oh right. Strong existentials are a problem.
13:14:26 <dolio> So no.
13:14:36 <Saizan> more than the existentials of CiC?
13:14:46 <dolio> You have to have Coq's extended eliminator rules.
13:15:27 <applicativ> sclv_: just in the usual set theory without 'choice' the 'cardinals' are extremely amusing and a mess; adding a 'large' cardinal axiom just adds another incomparable pile of cardinals
13:15:29 <chrisdone> ok, moved hpaste to the new server. i've asked bos to update the domain but until that's done the server will be a little bit slow because the old server is reverse-proxying to the new server
13:15:55 <luite_> chrisdone: have you switched to a hetzner server?
13:15:58 <chrisdone> yep
13:16:04 <Eduard_Munteanu> For some reason I keep thinking you can't have impredicativity without unique inhabitants, not sure why.
13:16:09 <luite_> chrisdone: ex4?
13:16:27 <chrisdone> yep
13:16:34 <luite_> ah what cpu did you get? :)
13:17:05 <chrisdone> Intel(R) Core(TM) i7-2600 CPU @ 3.40GHz (8 cores)
13:17:22 <luite_> aw :(
13:17:32 <luite_> i got a 3770
13:17:39 <chrisdone> what's that?
13:17:43 <sclv_> applicativ: sure, fair enough.
13:17:49 <dolio> Saizan: Coq has special rules when you use impredicative data types that prevent you from projecting out the type members in certain ways. They behave more weakly.
13:18:10 <augustss> chrisdone, 8 core i7?
13:18:24 <luite_> chrisdone: dunno, they often have faster cpus than advertised. my old eq4 server had a core i7 950 instead of the advertised i7 920
13:18:32 <sclv_> i suppose i meant we can (i guess) look at universes via the lens of model theory and embeddings, and we can look at the cardinal hierarchy the same way. so that gives us a way to conceptualize how the two relate
13:18:41 <chrisdone> augustss: that's how many i count in cat /proc/cpuinfo =)
13:18:54 <sclv_> or at least a common language in which to discuss both.
13:19:00 <augustss> chrisdone, Ah, hyperthreading.
13:19:03 <Ralith> Heffalump: I'd like to hear more about your concerns regarding separate compilation, as I'm investing a lot of work into idris based on my understanding of the problem.
13:19:10 <dolio> You can probably only eliminate into Set, for instance.
13:19:21 <Saizan> dolio: ah, i see
13:19:29 <applicativ> sclv_: it seems to me the proper class / mere set distinction doesn't really have to do with cardinality. i remember lectures of kripke where it was shown that Cantor already had the distinction and had used what we think of as russells argument to show that no there is no universal set. 'this many cannot be made a one' etc etc
13:19:41 <chrisdone> luite_: ah, i don't really mind about CPU. disk and memory are the important things for my servers
13:20:18 <dolio> That might be the whole restriction. :)
13:20:23 <luite_> chrisdone: oh the i7-3770 is just a newer generation, same GHz, but faster memory speed and some minor other improvements
13:20:42 <applicativ> sclv_: you show some predicate ('many') does not determine a set by contradiction, basically. that these will all be of the same 'size', the size of the universe is a theorem which require choice interalia
13:20:42 <dolio> Props have the same kind of restriction, plus others.
13:21:19 <dolio> Like, you can have Props that don't appear to have unique inhabitation, but you can't eliminate them usefully into Set.
13:21:32 <dolio> You can only case on the constructors into Prop.
13:22:00 <chrisdone> luite_: i was paying about $50 for linode for 1gb of ram and crappy cpu and godawful 15gb hard disk performance. my hetzner is around the $50 mark and i get 16gb, acceptable cpu and a few terrabytes and for an extra few you can get an SSD
13:22:14 <sclv_> applicativ: ok, makes sense.
13:22:20 <luite_> chrisdone: yeah it's a huge difference :)
13:22:25 <luite_> chrisdone: but both got hacked :(
13:22:51 <luite_> are you going to zurihac this year btw?
13:22:52 <sclv_> i have a computer that nobody can hack.
13:22:54 <chrisdone> luite_: yeah, not much we can do i suppose
13:23:02 <chrisdone> luite_: might do, it's so easy to get there
13:23:17 <Saizan> oh, when is zurihac?
13:23:18 <chrisdone> sclv_: because it doesn't have an on switch?
13:23:21 <chrisdone> august
13:23:30 <luite_> Saizan: late august, last weekend
13:23:59 <sclv_> chrisdone: http://i.imgur.com/fAD8q.jpg
13:24:07 <chrisdone> beautiful
13:24:15 <luite_> chrisdone: cool. i'll try to be there too. some last sprint to get the ghc/cabal patches merged for the first ghcjs release :)
13:24:16 <sclv_> (i wish i had that computer)
13:24:18 <chrisdone> and they say nobody uses screensavers anymore
13:24:45 <fruitFly> so cloud haskell is for leasing server space for back end haskell?
13:24:53 <chrisdone> luite_: cool. =) yeah, not sure what i would hack on there
13:25:09 <fruitFly> like deploying stuff?
13:26:51 <luite_> chrisdone: make lens faster so i don't have to optimize the ghcjs optimizer ;)
13:27:23 <dolio> sclv_:  I saw a machine like that at the MIT swap meet a couple weeks ago. Should I go back and see if I can buy it, so you can do that?
13:28:11 <xplat> Eduard_Munteanu: the 'axiom of Universes' stuff is really quite similar to hierarchies in type theory, except usually you get powersets living below the first universe (because you've got an axiom like that)
13:28:12 <luite_> sclv_: would you accept a patch that adds instanceof support to jmacro?
13:29:59 <luite_> chrisdone: we finally have this by the way! https://travis-ci.org/ghcjs/ghcjs/jobs/8034519  took me long enough :)
13:31:53 <shergill> chrisdone: how's the reliability on the hetzner (compared to linode)? it's unlikely you've had issues, but in case you looked into it before signing up
13:32:33 <luite_> shergill: haskell.org is hosted there
13:32:46 <shergill> oh
13:33:08 <luite_> i have occasional connectivity problems for a few minutes, but nothing really serious so far
13:33:23 <chrisdone> luite_: yay, travis is cool
13:33:33 <luite_> chrisdone: annoying 50 minute time limit though
13:34:15 <luite_> ghcjs takes way longer than that to build, so i have a vagrant script that builds all the dependencies on my (hetzner) server, travis just builds ghcjs itself and runs the ghc testsuite
13:34:37 <luite_> (build includes GHC HEAD and Cabal)
13:35:24 <chrisdone> shergill: i've been hosting ircbrowse and haskellnews on it for a while, no stability issues so far. linode is sluggish and expensive, but it's also never been down for me either. it's just expensive for not a lot of speed or space
13:35:26 <sclv_> luite_: sure, i guess i should.
13:35:32 <sclv_> its sooooo ugly though
13:36:15 <sclv_> would it be worse or better to make instanceof a normal function that jmacro translates away into the stupid operator thing?
13:36:15 <shergill> chrisdone: yeah, basically why i'm thinking of switching. too expensive for too little
13:36:24 <luite_> shergill: ipv6 was a bit flaky recently though. i tried to download the (200MB) binaries from hetzner with wget, ipv6 was really slow sometimes (but the prolbme might've been on travis' end)
13:37:50 <luite_> sclv_: yeah i don't disagree :) hamishmack mentioned he needed instanceof in some foreign import for webkit or something similar
13:39:21 <sclv_> anyway yeah i'd take the patch though, since its in accord with the general jmacro approach, as much as it pains me sometimes :-)
13:41:32 <luite_> cool. i'm not sure if i'm going to have time to write it any time soon though :)
13:54:56 <sclv_> you can always hack around it by construting the infix node in the ast by hand
13:55:08 <sclv_> then bind it to a nice name and use it in quasiquotes :-)
13:55:14 <sclv_> antiquotes rather
13:56:29 * hackagebot shake 0.10.5 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.10.5 (NeilMitchell)
14:04:32 <Ralith> Has anyone experimented with using GHC with MSVC instead of mingw's GCC on windows?
14:29:10 <orzo> hello.  Anyone have an opinion on style for writing an Enum with many possible values?
14:29:24 <orzo> should the vertical bars start the line or go on the end?
14:30:22 <shachaf> The beginning is more common.
14:31:03 <orzo> I use the beginning for the commas in a list
14:31:11 <orzo> so it seems natural to do so with the bars here
14:31:27 <orzo> but then theres awkwardness with the first value which has no bar and wont line up very well
14:31:39 <orzo> how do you handle that?
14:31:47 <shachaf> Line the |s up with the =
14:31:59 <shachaf> Alternatively, don't care about it.
14:32:35 <darenthis> newbie question: I have an IO String (the contents of a file) that I want to pass to a function that takes Strings. Is there a syntax for doing that without using do notation?
14:32:51 <orzo> fmap
14:32:57 <shachaf> orzo: ?
14:33:08 <FreeFull> What orzo said
14:33:09 <orzo> darenthis: fmap fun ioStringThing
14:33:17 <darenthis> thanks!
14:33:30 * shachaf suspects that won't solve darenthis's problem...
14:33:42 <jnerula> shachaf: Have some hope
14:33:44 <darenthis> I'll master monads or one of us will die trying
14:33:59 <Saizan> if fun's return type is IO Something you'll want >>=
14:34:00 <chrisdone> don't fail
14:34:12 <FreeFull> >>= works too
14:34:17 <Vulfe> "Behold, darenthis the monad master!" they cheered in excitement
14:34:30 <Saizan> ioStringThing >>= fun
14:34:36 <darenthis> I'm trying to parse a json file into a record. Simple, right?
14:34:41 <chrisdone> “Can I touch his clothes?” cried another
14:34:55 <FreeFull> For monads,   fmap f x = x >>= return . f
14:35:02 <Saizan> darenthis: yep, assuming you have a lib
14:35:26 <darenthis> I suspect I'll end up buried in IO (Result (MyRecord)) but I'll worry about that later :)
14:35:52 <Saizan> seems quite a fine type for the thing
14:36:17 <darenthis> I'm using Text.JSON
14:36:25 <Saizan> you might want to separate the "reading from disk" part from the rest
14:37:40 <Saizan> so that you have something like Text -> Result MyRecord which you can develop in isolation
14:41:17 <crdueck> is there a higher order recursion primitive that abstracts kleisi composition (>=>) like so: f 0 = return; f n = g >=> f (n-1)
14:42:21 <Peaker> crdueck, iterate (g >=>) return !! n ?
14:42:51 <nooodl> :t \f n -> iterate (f >=>) return !! n
14:42:52 <lambdabot> Monad m => (c -> m c) -> Int -> c -> m c
14:42:59 <shachaf> :t \n g -> foldr (>=>) return (replicate n g)
14:43:00 <lambdabot> Monad m => Int -> (c -> m c) -> c -> m c
14:43:03 <sclv_> ?ty replicateM
14:43:04 <lambdabot> Monad m => Int -> m a -> m [a]
14:43:10 <monoidal> iterate (>>= g) . return
14:43:33 <shachaf> By the way, :t now works in /msg
14:44:05 <Peaker> who runs lambdabot?
14:44:06 <chrisdone> only took 10 years
14:44:25 <sclv_> at the moment elliott runs it i think
14:44:37 <sclv_> it is a mobile crown
14:44:59 <shachaf> elliott runs it and mokus maintains the code.
14:46:32 * hackagebot lgtk 0.5.2 - lens-based API for Gtk  http://hackage.haskell.org/package/lgtk-0.5.2 (PeterDivianszky)
14:46:37 <Hrumph> yo
14:46:56 <chrisdone> sup cobro
14:47:45 <b6> is it possible to make an instance of Storable for an opaque type? i'm just wrapping the Ptr in a newtype, but if it was an instance of Storable it could be done by peek. but i don't know how to implement sizeOf.
14:48:30 <xico> hi
14:48:35 <shachaf> Isn't the point of making a type "opaque" that you can't write a Storable instance?
14:49:33 <b6> shachaf: well, yeah. maybe i'm being tempted to abuse Storable. i don't like it that some of the foreign import prototypes specify haskell types and some don't. :(
14:50:01 <shachaf> I don't understand what you mean.
14:50:02 <b6> maybe i just need to treat the opaque types specially.
14:50:10 <shachaf> But this situation is no different from what you'd have in C.
14:51:08 <xico> i have "x :: m [a]", "f :: a -> m [b]", and would like to apply "f" to each element inside "x", so getting a "m [b]". is there any clever function to do that?
14:51:48 <shachaf> @ty \x f -> x >>= \y -> concat <$> mapM f y
14:51:49 <lambdabot> (Monad m, Functor m) => m [a1] -> (a1 -> m [a]) -> m [a]
14:52:30 <xico> perfect. thanks!
14:53:05 <dmwit_> Just to make sure: you don't want a "m [[b]]" at the end?
14:53:12 <xico> yep
14:56:53 <monoidal> @pl  \x f -> x >>= \y -> concat <$> mapM f y
14:56:53 <lambdabot> (. (((join <$>) .) . mapM)) . (>>=)
14:57:39 <sclv_> ?ty sequence
14:57:40 <lambdabot> Monad m => [m a] -> m [a]
14:57:40 <dmwit> It's also possible you just want (>>=) for the LogicT m monad instead.
14:58:04 <sclv_> ?ty traverse
14:58:04 <lambdabot>     Not in scope: `traverse'
14:58:05 <lambdabot>     Perhaps you meant one of these:
14:58:05 <lambdabot>       `T.traverse' (imported from Data.Traversable),
14:58:10 <sclv_> ?ty T.traverse
14:58:11 <lambdabot> (Applicative f, T.Traversable t) => (a -> f b) -> t a -> f (t b)
14:59:12 <sclv_> the first time i saw ghc's 'spellchecker' my jaw fell off my face
14:59:13 <IanMc> Hi everyone
14:59:42 <IanMc> did ya get your jaw back?
14:59:49 <dmwit> sclv_: Nice, right?
15:00:20 <roboguy_> it's pretty awesome. I'm kind of surprised nothing else (as far as I know) has something like that
15:00:37 <monoidal> :t \x f -> runListT (ListT x >>= ListT . f)
15:00:38 <lambdabot> Not in scope: `runListT'
15:00:39 <lambdabot> Not in scope: data constructor `ListT'
15:00:39 <lambdabot> Not in scope: data constructor `ListT'
15:00:50 <IanMc> any examples of Haskell in the windows environment?
15:01:51 <IanMc> was that a silly question?
15:02:54 <IanMc> just seems to me that if haskell is that good, should be some examples of windows applications is all but I may be missing the point
15:03:04 <roboguy_> you mean a windows program written in Haskell or a development environment for Haskell that runs in windows?
15:03:34 <IanMc> a program that works in windows, written in haskell
15:04:05 <IanMc> any program
15:04:08 <dmwit> GHC?
15:04:10 <roboguy_> well, Leksah is both a Haskell IDE for windows and it was written in Haskell
15:04:40 <IanMc> not an ide for haskell
15:04:42 <dmwit> gtk2hs comes with a handful of demos that are cross-platform. Also, basically any executable package on Hackage that doesn't depend on the "unix" package will probably work.
15:05:02 <IanMc> just something written in haskell that works in windows, and only just wondering,
15:05:03 <dmwit> darcs is another popular one.
15:05:22 <nooodl> yeah, darcs is a good example
15:05:27 <dmwit> I used to bend over backwards to make wyvern work in Windows before the server completely changed its protocol.
15:05:54 <IanMc> I should have formulated my question betterer, like this' would haskell be a good choice of programming language for writing applications for windows?'
15:06:10 <dmwit> ?faq Can I write Windows applications in Haskell?
15:06:11 <lambdabot> The answer is: Yes! Haskell can do that.
15:06:20 <IanMc> cool
15:06:24 <IanMc> any examples?
15:06:33 * dmwit rubs his head a bit
15:06:53 <dmwit> I'm getting less and less motivated to think up further examples the more you ignore me.
15:07:12 <IanMc> I don't ignore anyone
15:07:15 <simukis_> There's no hurdles to do that. Code would look the same as it looks if you write to other platforms. With some exceptions that are documented in libraries.
15:07:27 <roboguy_> well, like I said Leksah is written in Haskell. that doesn't count just because it also happens to be a Haskell IDE?
15:07:29 <simukis_> s/to/for/
15:07:57 <chrisdone> IanMc: it depends on the kind of windows application you're doing
15:08:04 <IanMc> I'ts just that you don't want to write for windows? it's quite popular you know
15:08:10 <chrisdone> if it's a server or SDL, you probably have no worries
15:08:34 <chrisdone> if it's gtk+, i'd expect some friction building it, but once up and running it will look ok
15:08:46 <IanMc> what is mostly written in Haskell then? Unix type stuff?
15:08:47 <chrisdone> if plain win32 api, there are bindings for that, and the win32 api is easy
15:09:08 <chrisdone> i'd estimate that servers are haskell's main use at the moment
15:09:27 <chrisdone> web servers, data servers, data analysis and finance
15:09:34 <xplat> servers, and bespoke applications for financial services companies
15:09:48 <IanMc> mainframe stuff?
15:09:58 <chrisdone> no
15:10:09 <chrisdone> then again, who writes desktop apps anymore?
15:10:24 <IanMc> can I ask a personal question?
15:10:24 <b6> i've thought about it. like for genealogy.
15:10:26 <chrisdone> you make a web site, or you make an app for your phone if you want an audience to make money
15:10:43 * IanMc does anyway
15:10:44 <xplat> i know, right?  if you write a desktop app, you have to try to get your spyware past all those security programs ...
15:10:51 <IanMc> why do you love Haskell?
15:11:01 <xplat> there's no such problem for web or mobile
15:11:12 <simukis_> IanMc: Because it's *different*.
15:11:20 <IanMc> cool
15:11:26 <chrisdone> right, both web and mobile are sandboxed
15:11:39 <Clint> sort of
15:11:42 <chrisdone> they have straight-forward means of running/installation
15:11:43 <IanMc> an honest answer, I thank you
15:12:09 <IanMc> do you all get along with each other?
15:12:14 <applicativ> haskell is so beautiful, i would burst into tears sometimes, the first few weeks i was learning.  how we can have such an awesome compiler as well is a mystery
15:12:19 <roboguy_> I like it because I have fun writing code in it
15:13:18 * IanMc thinks that applicativ is being over-the-top and now doesn't believe him
15:13:26 <jnerula> I genuinely get excited writing Haskell
15:13:37 <jnerula> It's much more thrilling
15:13:41 <xplat> i like haskell because when i encounter problems with haskell, they seem like they're actually fixable
15:13:46 <applicativ> you don't write recipes, you 'define your terms' within a certain discipline, then the compiler can exectute it
15:13:52 <b6> haskell is the stuff for writing strong, reliable programs.
15:13:53 <josephle> IanMc: because there's really no other popular functional language that has so many cool PL features
15:14:00 <IanMc> why then are there no magnificent apps in windoz ?
15:14:09 <applicativ> the terms you define express ordinary concepts really; you can use them in speech if you like.
15:14:24 <IanMc> ah, that explains it
15:14:27 <applicativ> IanMc: you mean gui apps?
15:14:35 <IanMc> any apps
15:14:37 <applicativ> IanMc there have been
15:14:49 <IanMc> android apps
15:14:53 <IanMc> washing machine apps
15:14:54 <applicativ> plenty of command line apps exist that operate on windows.  try pandoc
15:15:14 <chrisdone> so an irc server that i wrote in an evening and then rewrote from scratch and then deployed has been running on my friends' server for 255 days and 11 hours, my friend told me today, and said “pretty stable software :)”. that's haskell
15:15:18 <applicativ> thats one of the more amazing of them.
15:15:26 <josephle> IanMC: the lack of haskell android apps is more of google's fault than haskell's >_>
15:15:31 * IanMc retracts that last
15:15:56 <Ralith> chrisdone: what'd you use for the network IO?
15:15:58 <xplat> washing machine apps ... well, you'd bemore likely to write them in atom than haskell proper
15:16:05 <IanMc> can see that you love haskell though, fantastic
15:16:10 <chrisdone> Ralith: System.IO?
15:16:20 <Ralith> kay
15:16:22 <applicativ> take a look at http://johnmacfarlane.net/pandoc/ https://groups.google.com/forum/?fromgroups#!forum/pandoc-discuss
15:16:23 <IanMc> I retracted that
15:16:26 <roboguy_> I think there is a small FPS written in it if that counts
15:16:36 <Ralith> was curious if you were playing with one of the coroutine libraries
15:16:54 <Clint> git-annex is on android
15:16:56 <b6> Ralith: i haven't had time to look into it yet, but i bet there's conduit stuff now. or pipes. there are a few competitors.
15:17:13 <chrisdone> Ralith: i don't suppose irc is an appropriate use-case for continuation-based io
15:17:40 <Ralith> chrisdone: the server doesn't terribly call for it, I agree
15:17:59 <Ralith> b6: I'm more interested in seeing somebody write a server using edwardk's machines lib
15:18:14 <Ralith> well, any serious network app
15:18:18 <b6> Ralith: is that cool stuff? give me the intuition.
15:18:27 <Peaker> http://hpaste.org/89938  weird RankNTypes behavior!
15:18:30 <b6> i care about ultra rugged and trustworthy.
15:18:32 <xplat> yeah, that seems like one of the things for which machines would be the superior library
15:18:33 <Ralith> b6: the intuition? edwardk wrote it, therefore it must be cool.
15:18:49 <Ralith> :P
15:18:59 <Ralith> (this is a pretty reliable heuristic)
15:19:04 <chrisdone> fanboi
15:19:08 <b6> Ralith: cool how? cool as in you can trust it with your life, or cool because super advanced programming?
15:19:16 <applicativ> not sure what a network app is. another interesting app still being perfected is http://git-annex.branchable.com/
15:19:18 <Peaker> in my instance:  run = foo    type-checks, but run = <body of foo here>  doesn't, even if "foo" has no type signature specified
15:19:50 <Ralith> b6: afaik it hasn't been used in any major applications yet, so I wouldn't trust my life with it, but I'd expect much more of it than your typical untried library
15:19:59 <Peaker> class Monad m => MonadRun m where run :: m (forall a. m a -> a)     except I put a newtype around the forall part, so I wouldn't need more fancy extensions than RankNTypes
15:20:30 <shachaf> Peaker: In particular, non-working extensions.
15:20:46 <Peaker> shachaf, well, even with only FlexibleInstances,RankNTypes, I'm getting very weird behavior
15:20:46 <Ralith> applicativ: what about it?
15:20:58 <IanMc> I reckon that all your math brains don't want Haskell to be known to the great unwashed and that's why you havent made any windows apps yet
15:20:59 <shachaf> Peaker: You would need ImpredicativeTypes for that type.
15:21:03 <applicativ> Ralith: oh that was meant for IanMc
15:21:07 <Ralith> applicativ: ah.
15:21:14 <xplat> Peaker: might be a problem with the $ and .
15:21:18 <Peaker> oh silly me, I used different forms of (.) and ($), yeah
15:21:23 <Ralith> b6: I generally wouldn't trust my life with anything that hasn't been in use on a large scale for a long time, regardless of its pedigree
15:21:26 <Saizan> $ is special, . is not
15:21:37 <chrisdone> IanMc: genuinely, i don't think anyone's making desktop apps these days. in any language, really. it's kind of old school
15:22:00 <applicativ> I think the concept 'windows app' is a little unclear. there are plenty of them. even elaborate games have been written though gui nonsense is a pain
15:22:01 <chrisdone> not if you want to reach an audience and make money
15:22:11 <Peaker> ah, the culprit is (return . RunMonad) which makes it a rank1 type, whereas (return $ RunMonad $ ... is ok
15:22:13 <Ralith> IanMc: I just finished writing up build instructions of idris on windows...
15:22:14 <IanMc> but there are a lot of erm.. computers
15:22:26 <Ralith> chrisdone: depends on your audience.
15:22:40 <IanMc> please explain
15:22:44 <applicativ> there, IanMc, idris is an excellent haskell app; runs on windows
15:22:51 <chrisdone> "depends" is an easy thing to say of just about any topic =)
15:23:00 <Ralith> :P
15:23:02 <xplat> IanMc: installing software is hard like brain surgery, going to a web page is easy like slipping on rollerblades and cracking your skull
15:23:05 <dmwit> applicativ, Ralith: Don't bother. It seems IanMc is impervious to evidence.
15:23:10 <Ralith> noted.
15:23:11 <Zekka> I'm not entirely sure I understand IanMc's argument.
15:23:25 <Zekka> maybe that's because it's incoherent and I haven't realized this yet
15:23:32 * IanMc is that there exist a lot of computers
15:23:37 <applicativ> dmwit: i don't think he's being particularly trollish.  it's true the line of questioning is deadeningly familiar
15:23:45 <roboguy_> IanMc: there are a lots of smartphones nowadays
15:23:56 <Peaker> I hate how RankNTypes breaks refactorings relating to ($) and (.) :(
15:23:57 <Ralith> chrisdone: games still have a strong holding, as do workstation applications--anything with a really heavy processing load.
15:24:01 <applicativ> IanMc: personal computers are machines for holding browsers
15:24:02 <applicativ> alas
15:24:20 <Zekka> I ought to read up more on general purpose Haskell given that for the most part I've used it just for mathematics.
15:24:23 <josephle> applicativ: what ever happened to personal computers being machines that run haskell? :(
15:24:25 <Peaker> I think this is an advantage of having explicit type variable instantiations
15:24:29 <IanMc> t'cha but what you are saying is that haskell is so advanced that you no-longer need audio visual devices
15:24:36 <applicativ> josephle: that's my own secret view.
15:24:37 <xplat> but a lot of things with really heavy processing can be commandline, and if they can they will since commandline is about 100x easier to write
15:24:49 <Zekka> IanMc - You mean your brain doesn't have a serial port?
15:24:56 <IanMc> not yet
15:24:58 <Ralith> josephle: a haskell machine, eh?
15:25:00 <applicativ> Zekka: you've used it for mathematics?
15:25:03 <roboguy_> IanMc: who is saying that?
15:25:13 <IanMc> you, the collective you
15:25:22 <b6> Ralith: cool, i'll read this pdf and keep an eye on it. thanks.
15:25:24 <chrisdone> Ralith: yeah, that's true, but i doubt it changes the fact
15:25:24 <xplat> games on pcs only still exist as a market because of two things: hardcore gamers and steam
15:25:26 <Zekka> applicativ - Yes, although I'll generally favor another language because I'm not strong in it
15:25:27 <josephle> Ralith: one day reduceron will be more than an fpga (right?)
15:25:42 <applicativ> Zekka: what kind of calculation?
15:25:48 <applicativ> or do you mean calculation
15:25:50 <roboguy_> IanMc: I'm looking for somewhere someone said that and I can't find it.
15:26:05 <IanMc> oh, it's just up there, I said it
15:26:07 <Ralith> b6: let me know how it goes! I'm only very casually familiar with it, but IO tools interest me and edwardk stuff is always worth watching.
15:26:10 <Peaker> IanMc, it's not enough for the language to be good, it needs to have a lot of users who write awesome code in it
15:26:13 <Ralith> chrisdone: which fact?
15:26:22 <roboguy_> ianMC: yeah other than that
15:26:22 <IanMc> ah
15:26:25 <applicativ> IanMc: you can control audio visual devices with haskell, i don't get this
15:26:45 <IanMc> I'm just intrugued, don't mind me
15:26:47 <b6> Ralith: i'm way interested in super robust network client/server stuff.
15:26:53 <Ralith> b6: yeah, exactly
15:26:58 <Zekka> The most common case I can think of is problems where I can assemble a list of candidate solutions and isolate incorrect ones based on rules.
15:27:06 <IanMc> and bad at spellin'
15:27:09 <chrisdone> Ralith: that 90% of consumer programs are on phones or in the browser
15:27:21 <Ralith> b6: also, I am obliged to plug idris every time someone mentions reliability, though we don't *yet* have a nice network interface.
15:27:50 <Ralith> chrisdone: oh, yes, it should come as no surprise that '90%' of consumers have vastly diminishing returns on processing power.
15:27:51 <chrisdone> any programming community has a small % of people writing serious games to make money, and of that %, some portion are targeting phones and browsers, some are targeting consoles, and some are targetting the desktop. haskell has a very small % of games programmers to start with
15:28:16 <Ralith> and when processing power doesn't matter, portability and ease of access dominates
15:28:18 <quchen> chrisdone: One, to be precise. ;-)
15:28:20 <chrisdone> so the "desktops have games" is kind of a droplet in the ocean of apps that could be written
15:28:23 <xplat> coq is still way more reliable than idris, but of course idris has much nicer syntax
15:28:46 * IanMc watches as they zoom away from my little ideas
15:28:47 <Ralith> xplat: yes, it's more a matter of "we're doing relevant and cool stuff" than "you should be using this now"
15:29:05 <Ralith> xplat: mindshare ^^
15:29:22 <chrisdone> <xplat> games on pcs only still exist as a market because of two things: hardcore gamers and steam — +1
15:29:51 <dmwit> That's stupid. "Product X only exists because it has a market." No duh?
15:29:52 <applicativ> steam?
15:30:03 <Peaker> fighting rankntypes was difficult today. I finally won :-)
15:30:05 <Ralith> chrisdone: I'm just making the point that one can still productively target the desktop.
15:30:11 <IanMc> steam is a game thing
15:30:13 <Ralith> applicativ: game distribution platform
15:30:17 <Ralith> very successful
15:30:22 <applicativ> bah, forget coq xplat, then maybe we can hope for something better
15:30:25 <chrisdone> dmwit: that's not the claim, the claim is "it's a small market compared to non-desktop-specific apps"
15:30:29 <applicativ> Ralith, ah
15:30:30 <chrisdone> so the question comes back to IanMc: why *should* anyone be making “windows” apps?
15:30:47 <IanMc> yeah ay?
15:31:00 <IanMc> sorry I'll keep quiet
15:31:18 <josephle> chrisdone: because microsoft has a $100 bounty (or has that expired?)
15:31:22 <Ralith> applicativ: its claim to fame is making it more convenient to buy than to pirate.
15:31:38 <xplat> dmwit: 'hardcore gamers' is a pretty distinct market segment
15:31:52 <applicativ> the going haskell way is for apps to be served; thus all the haskell web activity
15:32:25 <chrisdone> Ralith: ah, you were stressing that my generalization wasn't universally applicable: sure
15:32:31 <dmwit> xplat: So? I still think "this exists because people want it" is a pretty content-less statement.
15:32:33 <applicativ> don't games have a kind of c++ with scripting language monopoly
15:32:34 * IanMc didn't mention anything about games, just if Haskell is so awesome why aren't there any windows apps written in Haskell?
15:32:41 <b6> a C function i'm binding returns NULL on error, so my haskell function returns IO (Maybe ...). is there something better i can do? maybe i should use some more general monad than IO and throw an exception or something?
15:33:09 <shachaf> b6: I think returning Maybe is good.
15:33:24 <roboguy_> IanMc: but we've given you examples of windows apps written in haskell...
15:33:26 <applicativ> IanMc: there are.  the standard charted nonsense is all for windows, for example
15:33:35 <luite_> b6: Maybe is good in general, exceptions can be appropriate for really exceptional situations like a memory allocation failure
15:33:44 <dmwit> stop feeding troll pls =(
15:33:47 <Ralith> chrisdone: and indeed, long term, it seems plausible that the web will become the desktop and the browser the OS, making the desktop a first class target again
15:33:57 <applicativ> dmwit maybe youre right
15:34:06 <b6> shachaf: luite_: ok, i'll stick with Maybe. thanks.
15:34:15 <IanMc> roboguy_ nah, you haven't really given any solid examples, sorry
15:34:42 <chrisdone> Ralith: yeah, it's probably not the particular platform that matters much as long as it has a trivial means for a program to go from "hey try this" to "this is running safely on my device"
15:34:57 <xplat> so the point is that (1) we shouldn't measure the games market just by how many people both have pcs and play  games, and that a lot of the reason there is so much activity in the gaming sector outside of this very particular 'hardcore' segment at all is because people have made installing games much easier and less worrying than installing other windows apps
15:35:11 <luite_> bleh the future must be a horrible time if everything runs in the browser ;)
15:35:12 <Ralith> chrisdone: I agree
15:35:20 <shachaf> IanMc: You've asked six times and been answered every time. You're asking "personal questions" and calling people "math brains" who don't want Haskell to "be known to the great unwashed".
15:35:30 <applicativ> IanMc: darcs runs on windows, though i guess it's seen its day; pandoc runs on windows and is integrated with windows editors.
15:35:35 <shachaf> IanMc: These are all troll patterns. Please stop acting like a troll.
15:35:41 <Hrumph> its hard to go back once you code in haskell
15:35:45 <roboguy_> IanMc: there's some video games written in it. there's an IDE written in it. in addition to the other things listed
15:35:48 <applicativ> IanMc: haskell has nothing to do with math or math brains.
15:35:50 <IanMc> ok, just diss me then instead of answering, that'll work
15:35:50 <xplat> luite_: i agree, but i don't think writing windows apps is a good way to change that momentum, surely :7
15:35:57 <Hrumph> for all those who criticise its hard to go beack to the iterative idiom
15:36:05 <Ralith> luite_: my point was rather that the browser may converge towards a lightweight interface the hardware, not terribly different from existing OS APIs.
15:36:08 <roboguy_> haha okay now you're just being ridiculous
15:36:33 <applicativ> IanMc: the only 'mathematical' knowledge that could be of use in learning haskell is some sort of elementary logic
15:36:48 <Ralith> luite_: see google's various examples with delivering native code through the browser, ASMJS, etc
15:37:02 <Ralith> s/examples/experiments/
15:37:15 <Hrumph> its a fairly mathy language...there's a definite crossover i wouldn't downplay it too much
15:37:29 <shachaf> IanMc: I don't care much whether your question gets answered to your satisfaction. I care about this channel being a pleasant place, and you're making it the opposite of that. Please stop.
15:37:42 <darenthis>  hey folks, I've got a request: I've persuaded the type checker that I'm worthy of using a computer (first haskell program, yay!). Would anyone mind giving me some hints on how to make it more idiomatic haskell?
15:37:50 <IanMc> I apologise
15:37:51 <chrisdone> hoodle is pretty cool http://ianwookim.org/hoodle/gallery.html it works on linux and os x. dunno if it works on windows, but it's really a nice program!
15:37:57 <josephle> darenthis: put it up on hpaste!
15:37:58 <luite_> Ralith: both are a lot more low level than existing OS APIs
15:38:00 <dmwit> darenthis: People would love to. Also, there's a StackExchange for that. =)
15:38:03 <applicativ> Hrumph: I think this is an illusion generated by the important typeclasses which would be important even if mathematicians hadn't already named them
15:38:24 <Ralith> luite_: those are targets, not APIs; the APIs they present are, to my knowledge, quite high level.
15:38:27 <darenthis> http://hpaste.org/89939
15:39:03 <dmwit> Looks great to me.
15:39:04 <applicativ> darenthis: well, for one thing, hlint didnt complain, that's a good sign
15:39:15 <chrisdone> darenthis: looks good to me
15:39:21 <Ralith> darenthis: put a space after IO and just write 'print (parseJson jsonText)'
15:39:22 <meditans> hi, let's I have two functions using the state monad, but with different states, eg: f1 :: First -> State S1 Second and f2 :: Second -> State S2 First. Is there a simple way to have the function call each other mantaining two separate states?
15:39:26 <Ralith> darenthis: otherwise you're doing great
15:39:32 <dmwit> main = readFile "..." >>= print . parseJson -- my only suggestion
15:39:32 <darenthis> I got stuck trying to merge lines 19 and 20, and thanks!
15:39:33 <chrisdone> maybe the formatting is a little unconventional, but you'll pick that up
15:39:42 <applicativ> darenthis: it looks fine, the definition of parseJson is even sexy
15:39:47 <IanMc> I do like what you said about 'it's hard to go back once you code in haskell' I intend to check that out, sorry if i was out of order
15:40:07 <shachaf> meditans: I'm not sure what you mean by "call each other" and "mantaining two separate states".
15:40:14 <Ralith> darenthis: you don't have to merge them, but if you wanted to, you could do 'result <- fmap parseJson (readFile ...)'
15:40:24 <josephle> darenthis: I second applicativ, that parseJson is sexy
15:40:28 <chrisdone> darenthis: once you learn about Applicative you'll be able to shorten makePerson without needing to name the parsed components
15:40:40 <dmwit> Pfft. I like my suggestion better.
15:40:44 <shachaf> meditans: Oh, I see. No, those functions won't really be able to work together.
15:40:47 <luite_> Ralith: i guess that depends on how you look at it, you can't really do much with apis from asm.js, but you can manipulate some low level data and use regular js to interact with the browser
15:41:08 <darenthis> I was quite proud of that >=> :)
15:41:10 <shachaf> meditans: Does rewriting those types to: f1 :: (S1,First) -> (S1,Second); f2 :: (S2,Second) -> (S2,First) clarify things?
15:41:19 <chrisdone> darenthis: yeah the fish is nice
15:41:19 <luite_> asm.js as a target makes me a bit sad though...
15:41:26 <monoidal> darenthis: It's very nice. You probably know this, but currently your program need not import Control.Applicative.
15:41:35 <Ralith> luite_: the APIs I'm concerned with are those that provide access to the os/hardware, so yeah
15:41:39 <meditans> shachaf: ok, so my only hope is to mantain a larger state of type (S1,S2)
15:41:40 <luite_> although perhaps not much more than javascript
15:41:41 <darenthis> yeah, I spotted that after I pasted it
15:41:46 <meditans> ?
15:41:54 <Ralith> luite_: and yes asm.js is a bit depressing, but it's just the flipside of the google native client coin.
15:42:02 <shachaf> meditans: There are many possible hopes. It depends on what you're doing.
15:42:05 <Ralith> the convergence will proceed, I expect.
15:42:13 <dmwit> darenthis: Have you looked into aeson? Not that it would make this particular snippet any better, but it's quite nice for larger projects.
15:42:18 <tabemann> what is specified for Foldable? I'm asking because haskell.org isn't working right
15:42:19 <chrisdone> darenthis: actually you don't have to notice stuff like that manually, ghc -Wall will tell you about unnecessary imports
15:42:28 <mathstuf> Clint: hi, are you the developer of DAV?
15:42:45 <chrisdone> @src Foldable
15:42:45 <lambdabot> Source not found. Abort, Retry, Panic?
15:42:47 <shachaf> @google data.foldable
15:42:48 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html
15:42:48 <lambdabot> Title: Data.Foldable
15:42:49 <shachaf> Works for me.
15:42:54 <tomjack> what should `instance Monoid m => Foldable (,) m` be? `foldMap f = f . snd`?
15:42:57 <shachaf> And I don't know what "specified" means, anyway.
15:42:58 <applicativ> darenthis: oh what dmwit says is true, aeson is sort of the going json library, not that it matters here; anyway the api is similar
15:43:03 <josephle> Ralith: somebody, quickly write a haskell browser! (or Rust needs higher kinds)
15:43:13 <meditans> shachaf: I want the most elegant code that sustains the semantic of my example, and (bonus) lets me keep separate the data
15:43:16 <shachaf> tomjack: That instance doesn't look right (even ignoring the syntax error).
15:43:30 <Ralith> josephle: I'd settle for a reasonable standardized bytecode target.
15:43:33 <tomjack> oh yes, I have ((,) m) but miscopied
15:43:43 <shachaf> meditans: I don't think your example makes sense so I can't comment as to its semantics. :-)
15:43:50 <darenthis> I'll take a look at aeson, thanks
15:43:52 <xplat> the whole thing is kind of depressing.  mainstream pc stuff always recapitulates what unix was doing 20 years ago, only even flabbier because of moore's law, and now it's recapitulating X11
15:43:55 <shachaf> tomjack: There's no reason for the Monoid constraint.
15:43:56 <luite_> Ralith: in part it might be because i've been asked at least 100 times why i don't target asm.js in GHCJS.... :)
15:43:58 <applicativ> isn't there an instance? or maybe they keep talking about one tomjack
15:44:01 <josephle> Ralith: my point being someone should take advantage of the convergence
15:44:08 <Ralith> luite_: heh
15:44:14 <peterjoel> hi, can someone help me find a package (I *think* I saw a few months ago) that does record subtyping? Or am I misremembering?
15:44:15 <Ralith> josephle: not sure I follow
15:44:18 <xplat> well, actually, some weird hybrid of X11 and 3270s
15:44:36 <Ralith> luite_: sounds like you need a FAQ
15:44:45 <meditans> shachaf: you're right, I will produce an example and paste it in a few days. Thanks :)
15:45:06 <josephle> Ralith: I was just thinking that if we're going to converge to standard bytecode target, then possibly to browser as lightweight os
15:45:10 <tomjack> shachaf: ah, I didn't think about that
15:45:33 <applicativ> tomjack: here for example, see the quoted material from conor mcb and conal e. at the bottom
15:46:06 <chrisdone> xplat: that's just how software works, sadly! mathematicians discover things that are only used hundreds of years later. in programming, we forget what people did five or ten years ago, and just ignore anything beyond assuming it's irrelevant only to re-invent it =)
15:46:13 <Ralith> josephle: use it as an excuse to build a haskell OS or something?
15:46:14 * IanMc has another question
15:46:32 <josephle> Ralith: yes, exactly
15:46:32 <shachaf> tomjack: instance Foldable ((,) w) where foldMap f (_,y) = y seems right, though.
15:46:43 <shachaf> tomjack: In fact it's the instance lens defines.
15:46:49 <Ralith> josephle: that would be neat
15:46:56 <Ralith> browsers are hard, though.
15:47:13 <luminous> where do freelancer haskellers go to find gigs? or the other way around
15:47:14 <applicativ> peterjoel: can you say more; there are a lot of wild record schemes around
15:47:16 <dmwit> peterjoel: vinyl, maybe?
15:47:23 <dmwit> That's the most recent contender.
15:47:23 * Ralith cowers in the reassuring familiarity of working on the idris implementation
15:47:38 <chrisdone> eich thinks that javascript is the only way to get a successful cross-platform target
15:47:39 <applicativ> like vinyl
15:47:39 <josephle> Ralith, from my understanding, probably just as much work as writing an OS :/
15:47:39 <darenthis> Ralith: there's https://github.com/GaloisInc/HaLVM (haskell on xen)
15:47:40 <xplat> gnome, meanwhile, builds upon the solid foundation of unix to ... come out with things that were being hyped as the next big thing by the mainstream 5 years ago and provide a convincing demonstration of why they never caught on
15:47:41 <tomjack> shachaf: thanks
15:47:44 <chrisdone> like C
15:47:52 <dmwit> luminous: haskellers.com might be a start
15:47:57 <Ralith> josephle: if not more
15:48:05 <applicativ> Ralith: youre really into it, this idris.  I have sent on patch so far...:)
15:48:12 <Ralith> josephle: though at least you don't need to worry about drivers...
15:48:18 <Ralith> applicativ: I am, and you should be too! ^^
15:48:28 <peterjoel> applicativ: It had some strange (to me) types which used strings in the types. I'm not actually sure how that worked
15:48:30 <applicativ> Ralith: I am, off and on
15:48:30 <chrisdone> luminous: look on haskell cafe and google+
15:48:34 <Ralith> \o/
15:48:44 <applicativ> peterjoel: it sounds like vinyl mentioned by dmwit
15:48:54 <Ralith> dependent types are so much fun
15:49:14 <applicativ> peterjoel: https://github.com/jonsterling/Vinyl
15:49:44 <peterjoel> applicativ, dmwit: Yes I think so. I'm looking at it now.
15:49:50 <tomjack> I see lens does not define a Comonad instance
15:49:57 <applicativ> dependent types are okay if they give you totality and productivity. theorem proving in the abstract is silly in my humble opinion, or to my taste
15:50:21 <Ralith> let me rephrase
15:50:24 <tomjack> oh because there already is one :)
15:50:25 <shachaf> tomjack: That's because Control.Comonad does.
15:50:27 <Ralith> *programming* with dependent types is so much fun
15:50:42 <shachaf> tomjack: In GHC 7.8 Data.Foldable will have the instance.
15:50:52 <monoidal> :k "a"
15:50:53 <lambdabot>     Illegal literal in type (use -XDataKinds to enable): "a"
15:50:55 <applicativ> yes they are cool. somehow I think the rage for them will not have the fruits people think
15:50:56 <Ralith> though the theorem proving can be entertaining in its own right as an intellectual challenge
15:51:00 <applicativ> or that it's overdone
15:51:25 <Ralith> I know one way to find out
15:51:31 <peterjoel> applicativ, dmwit: thanks. it's what I was looking for
15:51:46 <josephle> applicativ: theorem proving with dependent types is extremely mentally taxing :/
15:51:48 <xico> is there any difference between realToFrac and fromIntegral for a Int -> Double?
15:52:44 <applicativ> josephle: not if you TA'd symbolic logic for years ;)
15:53:02 <applicativ> then it seems unbelievable silly
15:53:29 <Ralith> silly?
15:53:34 <applicativ> except cool by being intuitionistic
15:53:42 <dmwit> xico: I'd be very surprised if those didn't end up being exactly identical after the rewrite rules gone done with them.
15:53:53 <xico> dmwit: good point, i will check the core
15:53:54 <applicativ> and of course they let you introduce more constants
15:53:57 <b6> :q
15:55:07 <josephle> applicativ: perhaps you'd have a better time writing proofs for equalities of equalities (HoTT-problems)
15:55:25 <applicativ> josephle: i have lots of experience doing that
15:56:11 <josephle> applicativ: no doubt TA'ing symbolic logic helps :)
15:57:42 <monoidal> xico: from GHC.Float: instance  Real Int  where toRational x        =  toInteger x :% 1
16:00:40 <IanMc> got told off in Haskell-Blah
16:01:20 <IanMc> you are all too fragile for me to be talking to you
16:01:39 <b6> nah, i think you're just weird.
16:01:49 <IanMc> fair enough
16:01:51 <shachaf> You're right. Good bye.
16:02:49 <IanMc> harsh
16:03:15 <IanMc> but fair
16:03:18 <IanMc> goodnight
16:03:23 <b6> seeya.
16:03:43 * geekosaur catches the end of this, decides he doesn't want to know
16:03:48 <b6> actually, #haskell's well known for being friendly and supportive.
16:04:15 <b6> #c (not sure on what network) being the other end of the spectrum.
16:04:27 <shachaf> "#haskell friendliest channel on Freenode", reports #haskell
16:04:57 <b6> no, that's not what i'm doing. i saw it in some unrelated context.
16:05:01 <b6> i think i saw people saying that on HN.
16:05:03 <sipa> also, like minds call eachother great
16:05:08 <b6> i've seen it multiple places.
16:05:36 * b6 old irc hand, knows about this
16:05:47 <b6> (argument from authority)
16:08:32 <sclv> we stay friendly because we don't brook trollling, unintentional or otherwise
16:09:16 <shachaf> If only that was true, this would be a much more pleasant channel.
16:09:52 <josephle> shachaf: fwiw, this is already a pretty pleasant channel imo
16:10:24 <b6> i agree, it's one of the best i've seen.
16:11:36 <xico> monoidal: thanks! but where do you find that? my local base doc does not include GHC.Float, and hackage's one is broken.
16:12:17 <monoidal> xico: source of GHC HEAD (it shouldn't have changed)
16:13:03 <xico> my grep doesnt find them :/
16:14:15 <monoidal> xico: https://raw.github.com/ghc/packages-base/master/GHC/Float.lhs
16:14:19 <monoidal> xico: https://github.com/ghc/packages-base/blob/master/GHC/Float.lhs
16:14:39 <xico> monoidal: thanks!
16:15:20 <monoidal> xico: if you don't have it, I recommend grabbing a copy of head in free time. It's a pleasure to play with new features, plus you can peek at the compiler
16:15:30 <xico> nevermind me. i grepped into ghc, instead of packages-base
16:18:58 <luminous> dmwit: thanks!
16:19:51 <skyflash> Strange but true... Haskell is the only computer language for which I've ever developed what might be called 'jonsing'.  After a week or so away from it, I start to get an increasingly strong sense of loss and withdrawal.  :-)
16:20:34 <skyflash> It must do strange things to your brain chemistry.
16:21:50 <Fuuzetsu> > f <$> x <*> y
16:21:54 <lambdabot>   Couldn't match expected type `f0 a1'
16:21:54 <lambdabot>              with actual type `Debug.S...
16:22:10 <Fuuzetsu> > foldr (++) [x, y]
16:22:13 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable
16:22:13 <lambdabot>                     Debug....
16:22:32 <Fuuzetsu> > a + b
16:22:36 <lambdabot>   a + b
16:22:59 <Fuuzetsu> > foldr (+) z [x, y]
16:23:03 <lambdabot>   x + (y + z)
16:25:31 <byorgey> skyflash: =)
16:25:34 <josephle> skyflash: that's probably the stockholm syndrome that you develop when you're at the mercy of the typechecker :P
16:26:04 <byorgey> typechecker good! typechecker friend!
16:26:08 <luminous> anyone seen crypton.io? super interesting project,. but all in nodejs :(
16:26:39 <Fuuzetsu> NON-BLOCKING IO IS THE FUTURE
16:26:44 * Fuuzetsu hails
16:26:56 * luminous is interested in seeing through an implementation in haskell
16:27:26 <luminous> but, I've not got the haskell chops to come close
16:28:04 <Fuuzetsu> I'm guessing it has to do with http://m.phys.org/news/2013-06-cloud-algorithm-major-problem-homomorphic.html
16:29:17 <josephle> homomorphic encryption is just a functor, what's the problem? (I should really stop using this joke)
16:30:03 <napping> Fuuzetsu: it's the future only if you're thoroughly out of date
16:30:53 <napping> http://www.haskell.org/ghc/docs/4.06/ANNOUNCE
16:31:17 <xplat> jokes like this are just a cylinder object in the category of snowclones; what's the problem?
16:33:36 * josephle respectfully bows to xplat
16:38:45 <skyflash> josephle: yeah, the type system adds a very distinct flavour to Haskell programming.   You going along "wheeeee", then bang the brakes are on because your type gland hasn't been sufficiently developed in some regard.  Then it's all puzzle-solving and research, then (usually) "wheeee" again.
16:40:19 <skyflash> Actually, *sometimes* the "wheee" bits are punctuated by some sobbing as you suddenly perceive of the pure beauty of some code you're working with.  Those are nice moments.
16:40:20 <simon> I'm a bit out of sync since Emacs 24. what's the easiest way to get ghc-mode installed?
16:44:27 <parcs_> writing incoherent sentences is an art form
16:48:37 <Chat2740> Heyy watz up
16:48:53 <Chat2740> Hello
16:50:24 <Vulfe> hehe
17:30:51 <romanandreg> dcoutts: is there a way to specify flags that you would use on cabal install of a package (-fopenssl, -fdevelopment) on build-dependencies?
17:30:59 <romanandreg> say snap-server -fopenssl
17:31:00 <romanandreg> ?
17:37:19 <dmwit> romanandreg: no
17:37:37 <dmwit> romanandreg: Hence the official advice that flags should not affect what interface is offered.
18:13:38 <tomjack> "No instance for (Comonad (Cofree [])) arising from a use of `duplicate'" -- huh?
18:14:58 <tomjack> huh, after `cabal install free` it works
18:16:52 <dmwit> :t showIntAtBase
18:17:08 <dmwit> ?botsnack
18:17:08 <lambdabot> :)
18:17:34 <dmwit> > showIntAtBase 2 ("01"!!) "" 7
18:17:35 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
18:17:35 <lambdabot>    arising from the literal ...
18:17:44 <dmwit> > showIntAtBase ()
18:17:45 <lambdabot>   No instance for (GHC.Real.Integral ())
18:17:46 <lambdabot>    arising from a use of `Numeric.sh...
18:17:59 <dmwit> ...maybe I'd better go to PM.
18:18:18 <shachaf> > base 2 # 7
18:18:20 <lambdabot>   Not in scope: `base'Not in scope: `#'
18:18:23 <shachaf> lambdabot.........
18:18:46 <dmwit> > showIntAtBase 2 ("01"!!) 7 ""
18:18:47 <lambdabot>   "111"
18:19:14 <shachaf> kappabot: binary # 7
18:19:18 <dmwit> ?let str n | n < 1 = error "NO" | otherwise = tail (showIntAtBase 2 ("01"!!) n "")
18:19:18 <kappabot>  .L.hs:7:1:
18:19:18 <kappabot>      Failed to load interface for `Control.Arrow.Operations'
18:19:19 <kappabot>     ...
18:19:19 <lambdabot>  Defined.
18:19:26 <dmwit> > str 2
18:19:27 <kappabot>   Not in scope: `str'
18:19:29 <lambdabot>   "0"
18:19:29 <shachaf> OK, never mind.
18:19:35 <shachaf> kappabot: @quit in shame
18:19:59 <dmwit> ?let len = length (showIntAtBase 2 ("01"!!) n "")
18:20:00 <lambdabot>  Defined.
18:20:24 <dmwit> ?let H x y = str (2 * len x + len y - 1) ++ str x ++ str y
18:20:25 <lambdabot>  .L.hs:127:1: Not in scope: data constructor `H'
18:20:25 <lambdabot>  
18:20:25 <lambdabot>  .L.hs:127:22:
18:20:25 <lambdabot>      Ambigu...
18:20:32 <dmwit> ?let h x y = str (2 * len x + len y - 1) ++ str x ++ str y
18:20:33 <lambdabot>  .L.hs:131:18:
18:20:33 <lambdabot>      Couldn't match expected type `a1 -> a0' with actual type ...
18:20:58 <dmwit> > str (32 :: Int)
18:21:01 <lambdabot>   "00000"
18:21:07 <dmwit> > len 32 :: Int
18:21:09 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Int'
18:21:09 <lambdabot>              with actual...
18:21:20 <dmwit> ugh
18:21:25 <dmwit> ?undefine
18:21:26 <lambdabot> Undefined.
18:22:45 <dmwit> > pair 1 1
18:22:48 <lambdabot>   "0"
18:22:58 <simon> :t pair
18:23:09 <dmwit> > [(i, j, pair i j) | i <- [1..5], j <- [1..5]]
18:23:12 <lambdabot>   [(1,1,"0"),(1,2,"10"),(1,3,"11"),(1,4,"0000"),(1,5,"0001"),(2,1,"000"),(2,2...
18:23:50 <byorgey> dmwit: whatcha workin on?
18:24:06 <wavewave> fficxx has a very simple working real world example ; snappy lib and testSnappy.hs
18:24:10 <dmwit> byorgey: Just found a paper with a linear-time integer-pairing bijection.
18:24:26 <byorgey> oooh
18:24:32 <byorgey> linear in the number of bits?
18:24:36 <dmwit> yeah
18:24:40 <dmwit> ...and lazy!
18:24:44 <byorgey> neato!
18:24:46 <byorgey> link pls
18:25:02 <dmwit> http://www.sciencedirect.com/science?_ob=MiamiImageURL&_cid=272574&_user=10&_pii=002200009290027G&_check=y&_origin=article&_zone=toolbar&_coverDate=31-Dec-1992&view=c&originContentFamily=serial&wchp=dGLbVlS-zSkzk&md5=97ac57db663493b35c392f021725270a&pid=1-s2.0-002200009290027G-main.pdf
18:25:14 <byorgey> strangely, I just spent the past two days implementing an integer-pairing bijection in Agda and then porting it to Haskell.
18:25:27 <byorgey> sciencedirect, ugh
18:25:47 <dmwit> This link worked for me from California and for copumpkin. So try it. =P
18:26:01 <byorgey> oh hey, it's not paywalled
18:26:08 <byorgey> what do you know, thanks!
18:26:42 <dmwit> "pair" here is supposed to be the very first H given in the paper (the unlazy one with bad space usage)
18:26:53 <dmwit> ...because I don't understand how it works =P
18:29:58 <napping> If it's NxN -> N, can't you just interleave bits?
18:30:27 <dmwit> napping: You could, if you had a reliable way of de-interleaving them.
18:30:45 <byorgey> napping: the problem is what to do if the bit strings are not the same length.
18:31:07 <byorgey> (since we want to have a *bijection*  NxN <-> N).
18:31:07 <copumpkin> zeropad on left!
18:31:12 <copumpkin> >_>
18:31:28 <napping> if you work from the little end, zero-padding is fine
18:31:32 <dmwit> copumpkin: That's not bad for an injection.
18:31:55 <dmwit> It's probably not gonna be surjective, though.
18:32:09 <dmwit> e.g. this never produces odd-length bitstrings
18:32:23 <copumpkin> yeah :/
18:32:41 <byorgey> sure it does, when the first one gets zero-padded
18:32:48 <copumpkin> oh, hmm
18:32:50 <byorgey> remember, we are outputting natural numbers, not bitstrings
18:33:11 <dmwit> uh
18:33:17 <byorgey> (01, 11) -->  0111 = 7
18:33:20 <dmwit> No, we must be outputting bitstrings.
18:33:39 <dmwit> ...or?
18:33:43 <byorgey> I thought we wanted a function NxN -> N.
18:33:54 <dmwit> I feel somehow that N is basically identical to bitstrings?
18:34:01 <copumpkin> there are more bitstrings
18:34:03 <dmwit> Just chop off the front 1 or put it back on for your bijection there?
18:34:19 <byorgey> oh, chop off the leading 1.  right.
18:35:05 <napping> N ~= bitstrings that eventually repeat zero, and those interleave/deinterleave nicely
18:35:26 <byorgey> oh, this paper takes  N = {1,2,3 ... }
18:35:30 <byorgey> I was thinking it included 0
18:35:42 <copumpkin> oh, the unnaturals
18:35:49 <dmwit> sorry, yes
18:35:53 <byorgey> I guess it doesn't really matter that much
18:36:01 <copumpkin> BUT THERE IS ONE FEWER NUMBER
18:36:41 <dmwit> Why is str(2|x| + |y| - 1) enough information to tell how to split x and y?
18:36:48 <dmwit> I'm so puzzled by this.
18:36:59 <dmwit> And, like... you don't even know where to split w from xy!
18:39:35 <applicativ> if i say, data Nat = Z | S Nat , then Id say it's {1,2,3,4 ..}
18:39:43 <applicativ> how could you tell the difference?
18:39:49 <copumpkin> Z(ero)
18:39:50 <copumpkin> duh
18:39:56 <copumpkin> do you see a Z anywhere in the word for one?
18:39:58 <copumpkin> didn't think so
18:40:06 <applicativ> een my language we say Z for one
18:43:48 <byorgey> dmwit: it is quite mysterious.
18:44:27 <dmwit> Okay, H is not supposed to be a bijection or have an efficiently computable inverse.
18:44:30 <dmwit> Mystery solved.
18:44:55 <dmwit> Solution: read the next paragraph instead of bashing your brain in.
18:45:09 <shachaf> um
18:45:17 <shachaf> that's not how solutions work
18:46:17 <byorgey> dmwit: I don't see anything in the next paragraph about it not being a bijection.
18:46:34 <byorgey> it's referred to as a "pairing function".  And the abstract says "pairing functions are bijections".
18:47:00 <byorgey> it's not supposed to have an *efficient* inverse.  But I think it's supposed to have one.
18:48:19 <dmwit> hum
18:49:15 <byorgey> it sounds like they may explain it in more detail in section 4.  I'm not sure.
18:49:19 <sclv> @remember applicativ een my language we say Z for one
18:49:19 <lambdabot> Nice!
18:49:56 <shachaf> data N = O | S N
18:50:10 <shachaf> I see that all the time!
18:50:27 <copumpkin> zerO and un
18:50:31 <copumpkin> I see no problem
18:51:27 <sclv> data Nat = Succ Nat
18:51:34 <sclv> all haskell types are lifted anyway
18:51:48 <arkeet> type Nat = forall a. (a -> a) -> (a -> a)
18:52:00 <copumpkin> oh arkeet had to get all fancy
18:52:10 <dolio> Nah, that one's no good.
18:52:14 <arkeet> =(
18:52:20 <dolio> forall a. a -> (a -> a) -> a
18:52:22 <dolio> Is better.
18:52:29 <arkeet> mine is prettier.
18:52:45 <dolio> Forces eta-long normal forms.
18:53:00 <arkeet> ??
18:53:23 <dolio> \z s -> s z
18:53:32 <dolio> vs. \s -> s and \s z -> s z
18:54:22 <arkeet> but operations on nats are easier with this one.
18:54:29 <arkeet> multiplication is composition.
18:54:31 <dmwit> I guess w is a bit like a checksum.
18:54:34 <arkeet> etc.
18:55:00 <applicativ> its irritating cabal init doesn't default to a bsd license anymore.
18:55:39 <applicativ> gpl is fine for things written in C.
18:55:51 <copumpkin> what does it default to?
18:56:07 <applicativ> bsd for Language Militant; gpl for Language Triumpant
18:56:18 <applicativ> it doesnt have a default
18:56:24 <copumpkin> {-# LANGUAGE Militant #-}
18:56:46 <Kaidelong> @ty (***)
18:56:46 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
18:56:51 <dmwit> I'm rather partial to three-legged um pants, my own self.
18:57:08 <Kaidelong> is (***) as general as it could be?
18:57:20 <dmwit> No, undefined is more general.
18:57:27 <copumpkin> >_>
18:57:40 <Kaidelong> more specifically, could (***) be defined for category, instead of arrow?
18:57:56 <copumpkin> category has no real building blocks
18:57:57 <applicativ> something less than arrow
18:57:59 <dmwit> No, but you don't need a full arrow to get something like (***), of course.
18:57:59 <dolio> No.
18:58:10 <copumpkin> there is a lot out there that's less than arrow
18:58:17 <copumpkin> it's also rather specific to (,)
18:58:46 <Kaidelong> @ty liftA2 (,)
18:58:46 <lambdabot> Applicative f => f a -> f b -> f (a, b)
18:58:53 <dmwit> Kaidelong: You might like to use the search term "tensor product" if you want to know about all the varieties of products there are out there.
18:58:59 <applicativ> Even people who are into arrows, think arrows should be less than arrows
18:59:00 <dolio> It's also got weird axioms, as I recall.
18:59:30 <dolio> Like, specifically not expecting (,) to be product-like.
18:59:44 <Kaidelong> (***) looks like liftA2 for Reader
18:59:44 <dolio> Even though that's what it looks like.
18:59:53 <Kaidelong> liftA2 (,) *
19:00:35 <Kaidelong> with an extra type parameter though
19:01:07 <Kaidelong> I guess the difference is that the contravariant part can be heterogenous while with reader they must be the same
19:02:58 <Kaidelong> (a bifunctor applicative on its covariant type parameter is sufficient for ***?)
19:04:07 <Kaidelong> IE you can define (***) with the constraint (Bifunctor f, Applicative f)
19:04:15 <Kaidelong> rather than (Arrow f)
19:04:45 <dmwit> I think even that is too strong.
19:04:52 <Kaidelong> also I don't think it'd work either
19:04:58 <copumpkin> dolio: what axioms then?
19:05:12 <dolio> I don't remember.
19:05:19 <dolio> I don't care about arrows enough to remember all the rules.
19:05:19 <Kaidelong> cause I'm not sure how you'd get the (c,d) part of f (a,b) (c,d) with just that constraint
19:05:22 <copumpkin> lol
19:05:25 <copumpkin> fair enough
19:06:05 <dmwit> Applicative is just barking up the wrong tree, I think.
19:06:28 <dolio> You could have a bifunctor over a, probably.
19:06:49 <Kaidelong> bbl
19:07:01 <dmwit> Yes, it seems it's just a bifunctor.
19:07:16 <dolio> (Category c, BifunctorOver f c) => c w x -> c y z -> c (f w y) (f x z)
19:08:05 <dolio> I'm skeptical that something like that is wise, though.
19:17:49 <applicativ> if a 'Strong' profunctor we have first' :: p a b -> p (a, c) (b, c)
19:18:21 <applicativ> second' :: p c d -> p (b, c) (b, d), thus if it is also a Category, we can glue them together, no?
19:18:44 <applicativ> p a b -> p c d -> p (a,c) (b,d) or did we want something else
19:19:05 <shachaf> It's often not a Category.
19:19:22 <applicativ> yeah, of course
19:20:03 <applicativ> I was thinking, how to characterize when you have something *** starting from Category, as above
19:20:25 <applicativ> or I was treating the question as, what more than a Category do you need?
19:20:47 <dmwit> You need a bifunctor. Profunctor is too specific.
19:20:48 <shachaf> Of course, second' = dimap swap swap . first', etc.
19:20:59 <applicativ> hm
19:21:06 <shachaf> Oh, wait, I missed everything before 19:20.
19:21:40 <shachaf> Never mind.
19:21:41 <dmwit> urgh, that claim is dishonest
19:21:46 <applicativ> this does seem unpromising
19:22:00 <dmwit> You need a bifunctor that's compatible with (,) (or whatever other "product" you're working with).
19:22:29 <applicativ> @type (***)
19:22:30 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
19:23:12 <dmwit> But then by the time you get to saying "you need a bifunctor that's compatible with (,)" you're really just stating the laws you expect about (***) in categorical jargon.
19:23:27 <applicativ> well that is to be expected.
19:28:44 <applicativ> this typechecks, not that it's that interesting:
19:28:46 <applicativ> (***) :: (C.Category a, Strong a) => a b c -> a b' c' -> a (b, b') (c, c'); abc *** ab'c'  = second' ab'c' C.. first' abc
19:29:37 * applicativ demands Kaidelong 's palme d'or
19:31:47 <Zekka> Project I'm working on defines a 2D fixed-size grid type and a function called setTile that takes a grid, position, and a function specifying the change to make to the value at that position (then returning the modified grid). If the function receives an invalid position, is it more idiomatic to silently return an unmodified version of the structure or to give the function Maybe Type and return Nothing in a failure?
19:32:05 <Zekka> Maybe type*
19:33:04 <Zekka> I looked around the standard library for an example of a similar case, and the first I noticed was the list type, which raises an exception when !! is given an invalid index.
19:33:57 <Zekka> I wasn't sure if exceptions were generally considered good practice though.
19:34:58 <applicativ> If the Prelude does it, then surely it's good practice. We can't get enough of head and tail for example.
19:36:04 <applicativ> Zekka: is this grid updating going to be happening in IO, or are you making a pure calculation
19:36:05 <Fuuzetsu> I hate using (!!)
19:36:19 <applicativ> not that that will improve my ever doubtful wisdom ...
19:36:20 <Zekka> applicativ - It's pure.
19:36:27 <applicativ> Fuuzetsu: indeed!
19:36:56 <Zekka> I don't use !! most of the time.
19:38:13 <Fuuzetsu> I don't remember the last time I used it… About 2-3 months ago I think…
19:38:23 <Zekka> If it's worth mentioning I'm considering using the State monad to track the updating over time, but I figured I would implement basic operations on the type first, so I haven't written that portion yet.
19:47:06 <sclv> head is great
19:47:24 * copumpkin doesn't want to know what sclv is up to
19:47:27 <sclv> i like seeing it so much that it helpfully gives me messages reminding me of it while i'm executing my binary
19:48:00 <sclv> partial functions are like your best buddies
19:48:14 <sclv> they always want to remind you about themselves
19:52:30 <shachaf> dmwit: Should I read "lightweight monadic programming in ML"?
20:00:36 <dmwit> shachaf: That's a pretty philosophical question. It's a fun paper with a neat idea.
20:01:09 <dmwit> I think the situation in ML is even more dire than the one in Haskell due to the whole "no type classes" thing.
20:01:13 <dmwit> So lifting is even more painful.
20:01:21 <shachaf> My file of things I should maybe read says <dmwit> shachaf: I just finished reading "lightweight monadic programming in ML", which you may also be interested in.
20:01:49 <dmwit> That was likely in response to something you said just before that, then.
20:01:54 <dmwit> log-diving time
20:01:56 <shachaf> Probably.
20:02:29 <shachaf> The logs say I was complaining about monad transformers being terrible.
20:03:03 <dmwit> yep
20:07:12 <applicativ> monad transformers aren't bad. monads arent bad either. neither cures cancer, it must be admitted
20:09:01 <applicativ> i was trying to figure out some of these moderne effects systems, e.g. the one in Frank ; it was a bit like replacing monads with arrows, better behaved ones admittedly
20:10:47 <applicativ> instead of a -> Maybe b you have, you know, a -[YIPE]-> b
20:11:49 <applicativ> instead of a -> IO (Maybe b) you have a -[YIPE,CONSOLE]-> b
20:12:28 <shachaf> Instead of Maybe b you have?
20:12:34 <Ralith> applicativ: you should check out http://www.cs.st-andrews.ac.uk/~eb/drafts/effects.pdf
20:12:51 <applicativ> () -[YIPE]-> b
20:12:55 <applicativ> since maybe is an effect
20:13:08 <applicativ> yes, Ralith the objection is the same.
20:13:22 <Ralith> applicativ: the objection?
20:13:34 <applicativ> perhaps it is just a question of getting accustomed to it
20:13:48 <sclv> interesting
20:13:55 <applicativ> one thing is, they drive things that we handle without thinking as features of values, as effects
20:13:58 <applicativ> thus Maybe
20:14:02 <applicativ> Either
20:14:22 <applicativ> who wants these things, they're obviously 'effects', like IO
20:15:17 <applicativ> I don't feel like an exception system is better than using Maybe, for example
20:15:43 <applicativ> a fortiori, not their effects systems; this is my working hypothesis
20:16:20 <applicativ> McBride in the Frank documentation goes on about what a trial it is using Maybe.
20:16:36 <applicativ> Well, he just seems completely out to lunch.
20:17:18 <geekosaur> they prefer core dumps?
20:17:25 <applicativ> but a 36 layer monad transformer 'stack' might perhaps make  me eat these ill chosen words
20:18:34 <Ralith> I agree, plenty of things make perfect sense as values
20:18:53 <Ralith> but there's more to effects than doing silly things with maybe
20:20:02 <palm_frond> what editor do you guys use for Haskell?
20:20:23 <Ralith> emacs, sublime text, or vi
20:20:28 <Ralith> probably covers most of the channel
20:20:44 <Ralith> also, every other programming channel that isn't focused on monolithic IDEs
20:20:57 <applicativ> Ralith: of course. I was struck that they could not resist the temptation to vanish Maybe's into their effect systems' version of exceptions.
20:21:43 <applicativ> palm_frond: most of them have tons of infrastructure for haskellizing.
20:22:06 <applicativ> palm_frond: there is also a behemoth haskell 'IDE', leksah, about which I know nothing.
20:22:20 <palm_frond> maybe this is a silly question, but could someone that uses emacs help me set up haskell-mode?
20:22:45 <Ralith> palm_frond: https://github.com/haskell/haskell-mode/blob/master/README.md
20:23:00 <palm_frond> i read through that
20:23:15 <palm_frond> i think i have most of it down but I can't seem to get the indentation working
20:23:55 <applicativ> hm, where do we see haskell-mode questions being asked? SO? it happens here of course.
20:25:42 <applicativ> hm if no one answers, maybe try again when more emacs crazed users are awake. they certainly discuss things like adjusting indentation thus and so.
20:25:55 <applicativ> i mean, on here.
20:25:59 <palm_frond> alright.
20:27:26 <palm_frond> if I use cabal install parsec then import Text.ParserCombinators.Parsec should work, right? or did it change and the tutorial I'm reading hasn't been updated?
20:27:50 <shachaf> I think it's Text.Parsec now? I don't know. Look at the documentation.
20:27:52 <shachaf> @hackage parsec
20:27:52 <lambdabot> http://hackage.haskell.org/package/parsec
20:28:52 <palm_frond> ghci can't find either of those modules, though
20:29:23 <shachaf> Well, you used cabal install parsec. Look at what it installed.
20:29:45 <applicativ> the string only modules are called Text.ParserCombinators.Parsec
20:29:47 <shachaf> Alternatively, if something isn't doing what you want, ask about it.
20:30:04 <applicativ> palm_frond: open ghci again?
20:30:08 <applicativ> or somethign like that
20:30:14 <palm_frond> i tried that already
20:30:50 <applicativ> have you installed ghc more than once? so that the one first in path isn't the one cabal isinstalling for?
20:31:30 <palm_frond> I've only installed once, unless it came with it
20:31:51 <applicativ> parsec does come with the haskell platform
20:31:58 <applicativ> what does ghc-pkg list parsec say?
20:32:26 <palm_frond> /var/lib/ghc/package.conf.d
20:32:39 <applicativ> hm, not installed, what does cabal think it is doing
20:32:57 <palm_frond> er
20:33:04 <palm_frond> should i do cabal install parsec again?
20:33:09 <geekosaur> Text.ParserCombinators.Parsec was Parsec v2, Test.Parsec is v3
20:33:20 <geekosaur> er, Text.Parsec
20:34:03 <applicativ> geekosaur: the other module is also present' it's specialized to String
20:34:32 <applicativ> palm_frond: yes, I guess,
20:34:39 <geekosaur> hm, that's kinda silly
20:34:54 <applicativ> maybe with a --verbose=3 flag or whatever it is
20:35:19 <applicativ> we want to know where it is registering the library, it's clearly not visible to ghc-pkg
20:37:05 <applicativ> geekosaur: anyway, he thinks he cabal installed it, but ghc-pkg list parsec just says /var/lib/ghc/package.conf.d
20:37:41 <applicativ> maybe the point is that ghc-pkg doesn't know of a local package registry or whatever you say
20:37:53 <palm_frond> the ghc-pkg thing gives this now
20:37:54 <palm_frond> /var/lib/ghc/package.conf.d
20:37:54 <palm_frond> /home/palmer/.ghc/x86_64-linux-7.4.1/package.conf.d
20:37:54 <palm_frond>    parsec-3.1.3
20:37:58 <applicativ> ah
20:38:20 <applicativ> then its there; what about ghci?  import Text.ParserCombinators.Parsec
20:38:30 <palm_frond> everything works
20:38:31 <palm_frond> i think
20:38:34 <applicativ> hurray
20:38:40 <palm_frond> thanks!
20:38:57 <applicativ> palm_frond: note that some of the tutorial examples give funny errors nevertheless
20:39:25 <applicativ> you might put {-#LANGUAGE NoMonomorphismRestriction#-} at the top of the file while working on it
20:39:35 <applicativ> and :set -XNoMonomorphismRestriction
20:40:00 <palm_frond> are "funny errors" just warnings or are they actually errors?
20:40:22 <applicativ> it won't be able to decide the type of some things that are typeable.
20:40:37 <applicativ> because it is insisting on the 'monomorphism restriction'.
20:40:49 <palm_frond> oh
20:40:56 <applicativ> it's just a familiar point about parsec tutorials from before Parsec 3
20:41:00 <palm_frond> i know some of these words :(
20:41:21 <palm_frond> oh, I'm not doing the parsec tutorials, I'm trying to go through "write you a scheme in 48 hours"
20:41:35 <palm_frond> but I'll keep that in mind, i guess
20:41:35 <applicativ> it isn't a big deal, it just might spare you nonsense especially while noodling in ghci
20:42:07 <applicativ> its somehow an extrememly frequent problem arising on #haskell, so i mention it
20:42:16 <applicativ> i mean with parsec tutorials
20:42:56 <applicativ> they tend to leave off the signatures, I think
20:43:02 <palm_frond> do you think this scheme interpreter writing tutorial is a good way to go about learning haskell?
20:44:01 <applicativ> i never used it, but I think people approve. there are also the familiar tutorials and so on.  going via parsec I suspect is a very good way in.
20:44:30 <applicativ> the current favorite tutorial/book is 'learn you a haskell' i guess you figured.
20:44:39 <palm_frond> yeah, i went through a little bit of that
20:45:21 <palm_frond> i didn't really get to anything hard like IO though
20:45:53 <applicativ> i'm not sure how much io there is in 'write yourself ...'
20:46:05 <applicativ> i guess you end up with an interpreter of some sort
20:46:27 <palm_frond> well, it starts with a hello world kinda thing, so I've gotten at least something
20:47:03 <applicativ> someone should write a haskell tutorial thats basically  all io from beginning to end; everything else is somehow fitted into that.
20:48:24 <monochrom> that is most of Hudak's book
20:48:58 <monochrom> it is half IO and half reactive
20:49:48 <applicativ> oh theres that.  this isn't a tutorial, but the spirit of it is right http://www.haskellforall.com/2013/01/introduction-to-haskell-io.html
20:49:57 <Tekmo> That's me!
20:49:58 <Tekmo> :)
20:50:08 <applicativ> hah
20:50:16 <applicativ> i was going to say 'Tekmo rocks'
20:50:22 <Tekmo> I agree with the sentiment that palm_frond expressed, though
20:50:27 <Tekmo> There aren't useful introductions to practical IO
20:50:40 <Tekmo> Real World Haskell doesn't cut it
20:53:12 <Tekmo> I find that the biggest deficiencies in modern Haskell tutorials are concurrent programming, parsing, and long-running programs
20:53:15 <applicativ> i remember it took looking everywhere to figure out how to compile, finally i hit on an old sequence of tutorials by stepcut
20:55:02 <applicativ> we begin , of course with 'interact'
20:55:33 <applicativ> then make a detour into the different types, String->String, ByteString->Bytestring, Text->Text
20:55:43 <applicativ> to get some modern libraries on the page.  etc
20:56:20 <applicativ> well s marlow is helping with a 'concurrent programming' tutorial
20:56:28 <Tekmo> Yeah, that will help
20:56:48 <applicativ> I was trying to figure out the tutorial for Control.Proxy.Concurrent
20:56:55 <Tekmo> My only problem with Simon's concurrent style is his over-reliance on killThread
20:57:16 <Tekmo> Part of my `pipes-concurrency` stuff was trying to figure out a graceful, no killThread, solution
20:58:02 * applicativ wonders what Simon thinks of over-reliance on `performGC` :0
20:58:12 <Tekmo> Well, that's not strictly mandatory
20:58:21 <Tekmo> It's only mandatory if you want to 100% guarantee immediate cleanup
20:58:31 <Tekmo> If you remove it, the thread just hangs around until it gets "garbage collected"
20:58:43 <applicativ> yes.
20:59:10 <Tekmo> I wish Haskell had a sane way to do reference counting
21:00:00 <luite_> i was happy to hear that someone had already tested pipes-concurrency with ghcjs, and that it worked :)
21:00:07 <Tekmo> Yeah, that was really nice
21:00:09 <applicativ> oh amazing
21:00:12 <Tekmo> Oh, by the way, amazing job on ghcjs
21:00:22 <Tekmo> I was really impressed when Patrick told me that pipes-concurrency worked on it
21:00:47 <Tekmo> My interest in ghcjs went up by about 800% when I heard that
21:01:21 <Tekmo> Whereas I still can't port `pipes` to Fay yet
21:01:44 <Tekmo> However, it should get better soon
21:01:46 <luite_> yeah i knew that the required operations were all implemented (though performGC doesn't yet promptly perform a GC in GHCJS, yet, due to some preconditions on the thread state), but the code is quite new
21:01:47 <applicativ> what is Fay missing?
21:01:59 <Tekmo> The original problem was that `pipes` relies heavily on type classes
21:02:04 <Tekmo> But that will go away in `pipes-4.0.0`
21:02:22 <Tekmo> I've figured out how to simplify things to get rid of the `Proxy` type class and proxy transformers
21:02:30 <Tekmo> So now it only relies on `Monad`, which is much less inconvenient
21:02:50 <applicativ> hm, just when i was getting used to them ...
21:02:54 <Tekmo> They are still there
21:02:58 <Tekmo> They just don't require the type class any more
21:03:22 <Tekmo> Somebody figured out that they were isomorphic to having the monad transformers in the base monad and he showed me how I could correctly lift all the relevant operations from the base monad
21:03:44 <Tekmo> So now you can have `ErrorT` in the base monad but still use `catch` and everything lifted over the `Proxy` monad transformer
21:04:23 <luite_> really, it will work without typeclasses at all? impressive
21:04:27 <Tekmo> Yeah
21:04:31 <Tekmo> Now the Proxy type is concrete
21:04:38 <luite_> i mean, bah all that ghcjs work for nothing, i could've just used Fay ;)
21:04:40 <Tekmo> There are other nice things that will come out in 4.0.0, too
21:04:46 <applicativ> it didn't used to have them
21:04:52 <Tekmo> For example, now you don't have to write utility pipes that reforward things by default
21:05:01 <Tekmo> Nor do things have to build in bidirectional support by default
21:05:16 <Tekmo> You can just write a plain old ordinary consumer and transparently upgrade it to a reforwarding pipe or a bidirectional pipe (or both)
21:05:30 <Tekmo> So now all the sinks in the Prelude are ordinary Consumers
21:05:38 <luite_> anyway i submitted a ghcjs system demo proposal to haskell symposium 2013, since i was too late for a proper paper
21:05:44 <Tekmo> Nice
21:05:47 <luite_> so i hope to see some of you there and at icfp
21:05:53 <Tekmo> I just submitted a functional pearl to the symposium, too
21:06:09 <applicativ> what are you pearlizing?
21:06:15 <Tekmo> It's pipes-related
21:06:42 <Tekmo> It's not so much a pipes tutorial.  Rather, it's just teaching the idea of using categories for stream processing
21:07:32 <applicativ> a familiar theme
21:07:37 <Tekmo> Yeah
21:08:12 <Tekmo> I was just getting a bit frustrated with yet another Oleg paper focusing on centralizing on input streams or output streams as the central abstraction
21:08:26 <Tekmo> So I wrote this as sort of my way of saying "No, it's the transformations that matter"
21:08:32 <applicativ> is there yet another oleg paper
21:08:45 <Tekmo> I'm referring to the Oleg/Sabry/Peyton-Jones paper on pretty printing
21:09:04 <Tekmo> Where he basically switches from saying "Let's use folds for everything" to "Let's use generators for everything"
21:09:04 <applicativ> ah yes, funny, i was thinking of that when you mentioned a pearl
21:09:26 <applicativ> an essay doing the same as theirs without the loathesome types
21:09:33 <Tekmo> Yeah
21:09:41 <Tekmo> It uses the old pipes-1.0 API for teaching purposes
21:10:13 <applicativ> it was almost unbelievably opaque, the oleg/peyton jones et al paper, even though all the type components were familiar
21:10:26 <Tekmo> The problem was the way they formulate transformations
21:10:35 <Tekmo> I was not satisfied with the "functions are good enough" story
21:10:49 <Tekmo> It's still very generator-centric
21:11:18 <Tekmo> It's pretty much the same problem as iteratees, except flipped
21:12:08 <Tekmo> I still need to do a proper `pipes` write-up, though
21:12:54 <applicativ> with this new scheme you mention, will the concrete proxy type be more or less the same?
21:13:03 <Tekmo> Yes
21:13:14 <Tekmo> It will be the `ProxyFast`, just renamed to `Proxy`
21:13:21 <Tekmo> The constructors will be hidden by default
21:13:46 <sclv> i liked the oleg/pj paper
21:13:51 <applicativ> but we wont act via a typeclass
21:13:54 <Tekmo> Right
21:13:57 <Tekmo> It will be a concrete type
21:13:57 <sclv> they have a concrete problem with interesting characteristics
21:14:12 <sclv> and they derive a solution that does what they need in a fairly concise way
21:14:19 <Tekmo> So there will be no `p` type parameter any more
21:14:26 <Tekmo> There was nothing concise about it
21:14:41 <Tekmo> The equivalent code using a monadic DSL is much more elegant and concise
21:14:48 <sclv> if you don't look at it as a library, but as a way of helping people structure how they think about problems, then...
21:14:55 <Tekmo> It's not that either, though
21:15:16 <applicativ> yes but somehow ReaderT where what is 'read' is a ... what was it a -> StateT blah IO () or something
21:15:54 <shachaf> What happened to poor Data.Proxy?
21:15:57 <Tekmo> If you want a truly elegant streaming parser just use `pipes-attoparsec`
21:16:18 <applicativ> well, can't you agree that the concrete parsing problem is a good demo for this sort of issue
21:16:19 <sclv> did prior solutions 'use a monadic dsl'? i don't recall that
21:16:31 <Tekmo> No, they did not
21:16:34 <sclv> right
21:16:37 <Tekmo> There are no published solutions for the monadic DSL
21:16:40 <sclv> so they beat prior solutions in a number of ways
21:16:49 <Tekmo> That's setting a low bar
21:16:52 <sclv> and demonstrate an interesting technique
21:16:55 <applicativ> haha
21:16:57 <sclv> no that's not a low bar
21:17:23 <applicativ> the technique was an impenetrable nightmare sclv, though i grant your mental capacity may outstrip mine...
21:17:26 <sclv> if someone having read their paper + all prior research can make the syntax look cuter
21:17:29 <sclv> then fine
21:17:45 <Tekmo> This pretty much plays into the biggest critique of academia, which is that they are ignorant of existing deployed solutions like `pipes` and `conduit`
21:17:48 <sclv> its a hard probem
21:17:54 <sclv> hahaha
21:17:58 <Tekmo> It's a hard problem if you've never installed the Haskell platform
21:18:15 <sclv> if you want pipes to be recognized you're doing the right thing -- getting something published on it
21:18:22 <Tekmo> I will
21:18:32 <Tekmo> I have to graduate first, though
21:18:40 <sclv> the fact that busy academics haven't had time to understand unformalized aspects of your library in any special detail is not their problem
21:18:40 * applicativ wonders if simon p j has ever installed the haskell platform
21:19:23 <applicativ> atkey seemed to know about pipes in some early version
21:19:25 <sclv> plus historically conduit had crummy semantics although i know its been cleaned up in a not fully documented way
21:19:44 <applicativ> are the semantics of iteratees so lucid
21:19:49 <Tekmo> The issue is that I have to graduate soon and I do not have permission to work on a `pipes` paper because it's not relevant to my degree
21:19:55 <sclv> they're subject to equational reasoning
21:19:57 <Tekmo> I have to delay it until after I graduate
21:20:01 <sclv> that's fine
21:20:11 <sclv> i'm just saying don't lay that problem at anyone else's feet
21:20:17 <sclv> because they haven't read your nonextant paper
21:20:19 <Tekmo> Even this functional pearl I submitted, my professor has no idea that I wrote it
21:20:23 <applicativ> don't graduate, just sign up for an additional simultaneous program ;)
21:20:55 <applicativ> no; graduate.
21:21:05 <Tekmo> Don't worry, I will be out soon
21:21:09 <Tekmo> I will be defending in November
21:21:14 <applicativ> oh nice
21:22:58 <sclv> if the pearl aims to compare techniques, i hope it includes benchmarks
21:23:06 <Tekmo> No, it's not a `pipes` tutorial
21:23:10 <Tekmo> It's much simpler
21:23:26 <Tekmo> It's just about "Don't make your streaming library biased towards generators or folds"
21:23:51 <Tekmo> Here, let me see if I can host it
21:23:57 <Tekmo> So you can guys can read it if you want
21:24:04 <sclv> so does it solve the pretty printing problem with no backtracking?
21:24:21 <Tekmo> I told you, that is not what this pearl is about
21:24:23 <sclv> + linear memory and bounded latency?
21:24:26 <Tekmo> It's not even about `pipes` specifically
21:24:26 <sclv> ok then
21:24:33 <Tekmo> But `pipes-attoparsec` does solve the problem you describe
21:24:40 <sclv> that's about parsing
21:24:43 <sclv> not pretty printing?
21:25:02 <sclv> or am i terribly mistaken about what attoparsec does?
21:25:06 <Tekmo> The pretty printing part is not that difficult to port from their paper
21:25:10 <sclv> hahahaha
21:25:11 <Tekmo> All they do is linearize the data structure
21:25:18 <sclv> so they do all the hard work
21:25:21 <sclv> and you port it
21:25:22 <Tekmo> No
21:25:27 <sclv> and then you complain their paper is hard to read
21:25:29 <Tekmo> That part has nothing to do with the streaming abstraction
21:25:34 <Tekmo> I didn't complain about that
21:25:38 <Tekmo> That was applicativ
21:25:45 <Tekmo> I understood their algorithm
21:26:04 <applicativ> yeah sorry, i wasn't thinking Tekmo had as much trouble as me, sclv
21:26:13 <sclv> ah, sure
21:26:21 <Tekmo> The point is that nothing about linearizing the pretty printing data type has anything to do with the choice of streaming abstraction
21:26:45 <Tekmo> I will admit that linearizing the type is novel, but it does no credit to their streaming abstraction proposal
21:27:22 <sclv> anyway i think the core of what they do is how they construct the pretty printing
21:27:29 <sclv> everything else is just a tool that's handy
21:27:41 <Tekmo> Yes, but I'm not interested in pretty printing
21:27:46 <Tekmo> I'm interested in general-purpose parsing
21:27:50 <sclv> but that's the point of their paper!
21:27:57 <Tekmo> But there paper is not about general-purpose parsing
21:27:59 <Tekmo> *their
21:28:02 <sclv> yes
21:28:06 <sclv> it is about pretty printing
21:28:14 <sclv> so your criticism of it is it is about a problem you're not interested in
21:28:16 <Tekmo> Their algorithm is completely specific to pretty-printing
21:28:20 <sclv> yes!
21:28:25 <sclv> their paper is about pretty printing!
21:28:27 <Tekmo> There is nothing you can extract from it that is useful to other parsing algorithms
21:28:31 <sclv> it is a good paper about pretty printing!
21:28:36 <sclv> it has fuck all to do with parsing
21:28:46 <sclv> it is also a terrible paper about driving cars
21:28:50 <sclv> and a miserable paper about wine tasting
21:28:56 <Tekmo> Ok, then let's agree that it is an excellent paper about pretty printing
21:29:00 <sclv> good
21:29:00 <applicativ> sclv it is about a sort of pretty printing problem as a demo of a generator etc idea
21:29:04 <sclv> :-)
21:29:07 <Tekmo> :)
21:30:33 <JoeyA> Here's a fun little challenge I encountered trying to pretty-print an IPv6 address: replace the longest sequence of 0s with "::"; for tie breaker, pick left-most.
21:31:00 <JoeyA> So a function like this: longestZeros :: [Word16] -> Maybe ([Word16], [Word16])  -- returns the items before and after the sequence of 0s we picked
21:31:13 <Tekmo> Why Maybe?
21:31:21 <applicativ> sclv, in the abstract, they put things the way Tekmo was finding irritating.
21:31:21 <JoeyA> because such as sequence might not exist
21:31:22 <applicativ> We propose a programming style for incremental stream processing based on typed simple generators. It promotes modularity and decoupling of producers and consumers just like lazy evaluation.
21:31:33 <Tekmo> So you don't count a 0-length sequence of zeros as a match?
21:31:35 <JoeyA> In which case, you can't do ::
21:31:40 <applicativ> then they say we'll solve this old pretty printing chestnut with out stream Idea
21:31:47 <JoeyA> Oh, longest sequence has to have at least 2 0s.
21:31:56 <sclv> eyeroll.gif
21:32:18 <sclv> they're clearly introducing this style as useful in some cases, not as a general principle to rule the world of programming
21:32:33 <Tekmo> No, there must be one way to rule them all and in the darkness pipe them
21:33:14 <sclv> here is my final word on the subject http://www.reactiongifs.com/wp-content/uploads/2013/05/nothing-matters.gif
21:33:19 <applicativ> sclv: I think it is introduced as on the way to a general principle to rule the world of something.
21:34:43 <Kaidelong> meow, I tried to derive a (***) for bifunctors on and off during dinner and I didn't manage
21:35:01 <Kaidelong> I'm not sure it's possible
21:35:16 <Tekmo> What do you plan to use it on?
21:35:23 <JoeyA> Who, me?
21:35:33 <Tekmo> Whoever wanted this (***) for bifunctors
21:35:37 <JoeyA> oh
21:35:44 <applicativ> @type (***)
21:35:45 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
21:36:00 <applicativ> the problem was, what, less than an arrow, can give us this?
21:36:03 <Kaidelong> someone mentioned that it might be possible to use a Bifunctor constraint alone, instead of an arrow constraint
21:36:42 <Tekmo> Well, why don't we start with a specific type that is a Bifunctor but not an Arrow?
21:37:07 <applicativ> my dubious candidate was not with the Bifunctor concept
21:37:08 <applicativ> (***) :: (C.Category a, Strong a) => a b c -> a b' c' -> a (b, b') (c, c'); abc *** ab'c'  = second' ab'c' C.. first' abc
21:37:30 <applicativ> but Strong is half the problem
21:38:19 <Tekmo> So are we keeping Category or not?
21:38:39 <applicativ> I think  Kaidelong was presupposing Category, no?
21:39:02 <Kaidelong> not with what I was working with no, but that might well help
21:39:15 <Kaidelong> I'm going to fire up Coq and start working on this
21:40:32 <Clint> mathstuf: something like that
21:41:20 <mathstuf> Clint: i was wondering what the 'small subset' was missing
21:41:48 <mathstuf> (looking at finally replacing abook and sync with my carddav server)
21:41:53 * hackagebot hpygments 0.1.2 - Highlight source code using Pygments  http://hackage.haskell.org/package/hpygments-0.1.2 (DavidLazar)
21:43:29 <Clint> mathstuf: well, it doesn't do very much.. if you want to help out with carddav that'd be great.. and the api is not ideal
21:44:43 <mathstuf> some newtypes might be good
21:44:55 <Clint> joeyh wants the whole thing to be more monadic
21:45:57 <mathstuf> well, im sure joeyh has more experience than i do at that (and maybe already has some ideas?)
21:46:32 <Clint> mathstuf: perhaps, but i need to pass out rather shortly
21:47:12 <[swift]> what's the best way to get the haskell platform 2013.2 on ubuntu 13.04?
21:47:20 <[swift]> it seems more complicated than i expected
21:48:05 <Tekmo> I've been hearing a lot about this problem on 13.04.  What is the issue?
21:48:08 <mathstuf> Clint: ok, ill send an email CC'ing joeyh; maybe a plan can be made
21:48:29 <Clint> mathstuf: sounds good
21:49:37 <Kaidelong> oh, Coq doesn't seem to have the facilities to handle this built in
21:49:48 <Kaidelong> Only stuff I can find on predicates are for first order ones
21:50:12 <Kaidelong> which I don't think allows me to express typeclasses?
21:50:24 <martint> the problem is that there is no haskell-platform package for ubuntu 13.04 using the default repositories
21:50:27 <[swift]> Tekmo: well, it seems like one make a symlink to ensure the correct version of gmp is used, then install ghc 7.6.3 from source, then install the haskell platform from source
21:50:53 <[swift]> Tekmo: i usually work on OS X and it's a simple "brew install haskell-platform" there
21:51:41 <Tekmo> Wow, that's weird.  Why are the repositories missing the package?
21:52:33 <martint> probably because ubuntu sync'd from debian when their package was broken (ghc 7.6 in repo, but platform depended on 7.4)
21:52:49 <martint> debian has long since fixed it, but ubuntu only syncs it once every 6 months
21:53:29 <Tekmo> If you can install ghc then installing the Haskell platform isn't too difficult
21:53:32 <mathstuf> [swift]: theres not even a bug open for this on LP that i see
21:53:37 <mathstuf> https://launchpad.net/ubuntu/+source/haskell-platform/+bugs
21:53:40 <Tekmo> That's what I did for a while because I was using Debian squeeze
21:53:59 <martint> i think instead of installing ghc 7.6 from source and then installing platform from source, you can use the 7.6 binary and then install platform from source
21:54:05 <Tekmo> You begin with the ghc in the repositories, install the ghc that the platform needs, then install the platform
21:54:21 <Tekmo> Then uninstall the repository ghc
21:54:53 <Tekmo> Yeah, use the platform ghc binary
21:54:58 <Tekmo> There is no sense in compiling ghc from source
21:55:14 <[swift]> i don't understand how that's different. i'm missing something i'm sure
21:55:31 <[swift]> are you not building ghc 7.6.3 from source in either case?
21:56:07 <Tekmo> ghc binary is precompiled for your architecture.  That's different than compiling it from source, which takes much longer
21:56:21 <Tekmo> The platform ghc is on this page: http://www.haskell.org/ghc/download_ghc_7_6_3
21:56:41 <Tekmo> You find your architecture (i.e. Linux (x86_64), for example), download and unzip that and install it
21:57:03 <[swift]> ah, ok, i see
21:57:18 <[swift]> thanks! that does sound faster
21:57:24 <Tekmo> Yeah
23:50:32 <Aetherspawn> is there a function f x = x f
23:52:05 <johnw> yes
23:52:23 <sipa> you're asking for a function f, for which holds that f x = x f?
23:52:24 <johnw> see if you can find it
23:53:14 <johnw> hmm.. maybe I'm not seeing it at the right level though
23:53:17 <johnw> @pl \f x -> x f
23:53:17 <lambdabot> flip id
23:53:23 <johnw> i'm not sure if that's the same as what you're asking for now
23:53:53 <Aetherspawn> It's flip id
23:54:06 <johnw> ah, then I ruined the surprise :)
23:54:23 <johnw> in general, @pl is a great tool for seeking out functional patterns like these
23:55:48 <Aetherspawn> im trying to write a function which applies a boolean function to every combination of things in a list
23:56:28 <johnw> can you show me a simple example?
23:56:33 <Aetherspawn> > let fn f r = map (map (flip id) r) (map f r) in fn (,) [1..5]
23:56:35 <lambdabot>   Couldn't match expected type `a0 -> b0'
23:56:35 <lambdabot>              with actual type `[(a1...
23:56:46 <Aetherspawn> Uh, consider [1,2]
23:57:02 <Aetherspawn> f [1,1] f [1,2] f [2,1] f [2,2]
23:57:04 <johnw> the easiest way to do that, I believe, is with a fold
23:58:37 <isomorphic> If I am setting up a library project in cabal, and I want to use cabal to test the library, is there anything special that i need to do to allow ghc to find the library when compiling the tests?  I've done an exposed modules statement - but cabal doesn't find my library
23:59:32 <Aetherspawn> > map (flip id 4) (map (,) [1..5])
23:59:33 <lambdabot>   [(1,4),(2,4),(3,4),(4,4),(5,4)]
23:59:38 <Aetherspawn> almost there, hehe :P
