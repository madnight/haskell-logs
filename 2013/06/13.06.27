00:04:48 * hackagebot cryptohash 0.9.1 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.9.1 (VincentHanquez)
00:19:22 <kurak0t> why did I get a compile error here?
00:19:29 <kurak0t> elementAt :: [a] -> a -> a
00:19:36 <kurak0t> elementAt x b = x !! b
00:19:58 <int-e> because the 'b' is an Int, not any other typoe.
00:20:11 <Hafydd> :t !!
00:20:12 <lambdabot> parse error on input `!!'
00:20:16 <Hafydd> :t (!!)
00:20:17 <lambdabot> [a] -> Int -> a
00:20:42 <int-e> *type (I swear I didn't intend any pun)
00:20:42 <Hafydd> A shorter implementation is: elementAt = (!!)
00:21:25 <kurak0t> thanks. i'll check it again.
00:22:21 <zRecursive> cd -
00:42:19 <osa1> shachaf: ok so I removed newtype, removed functor instance .. now how should I continue?
00:42:52 <shachaf> I don't know. What do you know? What are you trying to do? What is your goal?
00:43:35 <shachaf> Do you understand *how* Fix (ListF a) is isomorphic to [a]?
00:43:48 <shachaf> Or s/how/why/ if you prefer.
00:44:15 <shachaf> And if so, do you understand the type of the function you want to write?
00:44:45 <shachaf> Do you understand the thing I said yesterday: foldr :: (Maybe (a,b) -> b) -> [a] -> b
00:44:58 <osa1> shachaf: I'm not 100% sure what does isomorphic mean but I assume it means if a and b is isomorphic we can have `a -> b` and `b -> a`, and yes I understand how they are isomorphic
00:45:07 <shachaf> The magic thing about Fix is that you can write a single "fold" function that'll work for any type.
00:45:21 <Moggle_> how is ghc compiled with something like "apt-get install ghc"? the ghc is written in haskell it appears, so i would assume there's a sort of C bootstrap minimal haskell compiler somewhere but I can't find it in the ghc source code
00:45:39 <shachaf> osa1: It means we have to :: A -> B and fro :: B -> A, *and* that to (fro x) = x, and fro (to y) = y, for any x and y.
00:45:55 <mauke> Moggle_: apt-get doesn't compile ghc
00:45:57 <shachaf> In other words, A and B contain the same "information", just represented in different ways.
00:46:13 <shachaf> Moggle_: How are C compilers compiled, since they're usually written in C?
00:46:28 <Moggle_> shachaf: assumably written in assembly initially
00:46:35 <AleXoundOS> Moggle_, apt-get doesn't compile anything as I know
00:46:37 <Moggle_> shachaf: you could cross-compile from an already working OS too
00:46:54 <Moggle_> AleXoundOS: ah, so pre-compiled binaries?
00:46:56 <shachaf> Moggle_: When you build gcc, there's no minimal C compiler written in assembly involved.
00:47:05 <shachaf> Moggle_: So it is for GHC. GHC is compiled using GHC.
00:47:12 <AleXoundOS> Moggle_, binaries
00:47:50 <Moggle_> shachaf: so... cross compilation then? makes sense
00:48:12 <Moggle_> i was thinking for some reason that binaries compiled on one distro weren't guaranteed to work on another but I can see why this is ridiculous
00:48:15 <shachaf> Cross compilation is only necessary when you're porting to a new platform.
00:48:41 <Moggle_> because iirc the linux kernel has a nice executable format that's standard
00:49:08 <Moggle_> thanks in any case that solves a niggling issue i had
00:49:12 <johnw> Moggle_: you mean, ELF
00:49:18 <Moggle_> johnw: yep that's it
00:49:45 <roboguy_> Moggle_: assuming you have all the dynamic libraries that the executable needs
00:49:49 <shachaf> Having an ELF executable here and there doesn't mean that it's compatible... ELF is a pretty general format.
00:49:59 <johnw> you can have two ELF files that contain machine code for different architectures, I'm sad to say
00:50:14 <shachaf> Sad?
00:50:25 <johnw> joyfully melancholy?
00:50:28 <Moggle_> that does seem like an advantage...
00:50:56 <shachaf> Sad because you would prefer an alternative world which behaved differently?
00:50:59 <AleXoundOS> I think ELF is compatible among UNIX systems, but not the libraries it is linked with
00:51:02 <johnw> shachaf: here he thought that ELF meant it would run anywhere, and I just stole it away from him :)
00:51:13 <Moggle_> my entire world is crashing down on my ears!
00:51:20 <Gracenotes> If you are trying to break free from the symbol-based programming paradigm, ELF will also sorely disappoint you
00:51:48 <shachaf> I don't think they said that... But whatever.
00:52:25 <Gracenotes> > "elf" > "a.out"
00:52:29 <lambdabot>   Tru
00:52:33 <Gracenotes> ...hm
00:52:42 <shachaf> It's tru.
00:56:06 <kurak0t> i've been answering problems here, http://www.haskell.org/haskellwiki/99_questions/1_to_10. there were problems that marked with (*) or (**). what does (*)/(**) mean?
00:56:31 <johnw> it usually relates to how long it might take you
00:56:39 <johnw> at least, in other texts that use that convention
00:56:42 <bakibour> Greetings
00:57:14 <bakibour> Im trying to write a function that concaternates into two levels of objects http://hpaste.org/90490 can anyone help me to write this?
00:57:15 <shachaf> kurak0t: The link at the top explains.
00:58:03 <johnw> > fmap concat $ Just ["Hello", "World"]
00:58:04 <lambdabot>   Just "HelloWorld"
00:58:05 <bakibour> What im missing is f :: Maybe [[x]] -> Maybe [x]
00:58:33 <bakibour> Hm
00:58:38 <akegalj_> about gtk2hs, i am doing some work when clicked on button (onClicked). How can i later use data which i calculated in onClicked method?
00:58:39 <johnw> > concat <$> Just ["Hello", "World"]
00:58:40 <lambdabot>   Just "HelloWorld"
00:59:06 <kurak0t> shachaf: which link from the top of what?
01:00:47 <akegalj_> the only thing that pops in my mind is using database for holding state, and after colecting that same state
01:00:50 <akegalj_> is that the way to go here?
01:00:50 <shachaf> kurak0t: The link from the top of the page you linked to.
01:01:13 <shachaf> kurak0t: "Ninety-Nine Prolog Problems"
01:01:16 <Moggle_> akegalj_: IORef?
01:01:42 <Moggle_> akegalj_: I mean there are a million ways to handle it
01:01:50 <shachaf> Yes, a mutable variable seems like the obvious solution...
01:01:56 <shachaf> Gtk2hs is a pretty imperative API.
01:02:12 <akegalj_> Moggle: ok, ill read about IORef
01:02:17 <akegalj_> thznx
01:02:25 <Moggle_> you're welcome
01:02:33 <kurak0t> shachaf: oh, I see. thanks for that
01:03:11 <shachaf> kurak0t: Clicking on links and reading should be your natural reaction!
01:04:38 <kurak0t> shachaf: haha, i was not interested on the link at first though
01:05:29 <shachaf> I'm not interested in any of it.
01:12:39 <kurak0t> shachaf: How did you learn haskell anyway?
01:18:03 <shachaf> kurak0t: I have no idea.
01:18:23 <bakibour> johnw: That was not quite what i needed [Maybe [String]] -> Maybe [String]
01:24:50 * hackagebot markdown 0.1.4 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.4 (MichaelSnoyman)
01:29:34 <sp3ctum> is there a way to use the when function in a Writer monad? I tried with when (predicate) tell "foo" but it did not compile.
01:30:08 <typoclass> sp3ctum: maybe try this? when (predicate) (tell "foo")
01:31:30 <sp3ctum> typoclass, yes. that works. thanks!
01:31:33 <Hafydd> The parentheses around predicate aren't needed.
01:31:41 <sp3ctum> now i feel stupid though :)
01:32:02 <typoclass> sp3ctum: no need for that :)
01:32:14 <Hafydd> And this would work too: when predicate $ tell "foo", if it'
01:32:17 <Hafydd> s one statement.
01:32:23 <sp3ctum> yes
02:19:52 * hackagebot aeson-schema 0.2.0.1 - Haskell JSON schema validator and parser generator  http://hackage.haskell.org/package/aeson-schema-0.2.0.1 (TimBaumann)
02:20:53 <Aetherspawn> Hello I have a problem - it feels like I'm going to have to write too much boilerplate
02:21:08 <Aetherspawn> Consider: http://hpaste.org/90494
02:21:31 <Aetherspawn> Originally when my code only had Nand and Input the function for comparing trees of expressions to see if they are equal was trivial
02:21:53 <Aetherspawn> But now I think I'm going to have to do ~36 permutations of the compare function due to the way my data is set up
02:22:00 <Aetherspawn> can somebody give me a suggestion?
02:22:49 <shachaf> It seems like you can have a big comp _ _ = False case?
02:23:03 <typoclass> Aetherspawn: you're right, it's quite boilerplatey. this may be a partial solution http://hpaste.org/90494
02:23:31 <Aetherspawn> Oh, that escaped me. thanks shachaf and typoclass I'll give it a shot :)
02:23:32 <shachaf> Or, for that matter, maybe you can just use deriving (Eq) here...
02:23:35 <typoclass> Aetherspawn: how much that will help depends on what you're doing exactly
02:26:57 <Aetherspawn> shachaf, does deriving Eq work on trees like this?
02:27:33 <shachaf> Maybe. I don't know what you're after.
02:32:52 * slack1256 ponders why monad-control is so complicated for him.
02:33:21 <roboguy__> well that's not what you want. when I closed emacs, something crashed so bad my computer restarted
02:59:52 * hackagebot grid 7.0 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.0 (AmyDeBuitleir)
03:14:38 <ofan> anyone got 'Command.optionToFieldDescr: feature not implemented' error with cabal 1.60.2 and ghc 7.6.3 when 'jobs' option enabled?
03:16:40 <Dobias> Hi, yesterday I discovered a thousand-fold speed improvement when compiling with optimizations ( http://codepad.org/1RxbmNj3 ). I am now interested in learning what happend there without optimizations. Has anybody an Idea how to investigate this? Is there a possibility to look at the resulting C code?
03:17:54 <shachaf> GHC doesn't compile via C.
03:18:01 <Dobias> I guess the optimization makes Integral to Int, because I get the same speed without optimization if I change the type declaration of the list to int or leave it out completely.
03:18:24 <Dobias> shachaf: Oh, I did not know this. Is it directly core to asm?
03:18:44 <shachaf> Core -> STG -> Cmm -> ... -> assembly, anyway.
03:18:47 <shachaf> Dobias: I imagine it's an MRy issue here.
03:19:05 <shachaf> Dobias: I bet if you changed it to fibo :: [Integer] it'll be a much smaller difference.
03:19:39 <typoclass> Dobias: there is various -ddump-something options to ghc. you can use them to display various intermediate forms. here is a small example http://stackoverflow.com/questions/10693638/how-to-dump-ghc-simplifier-output-in-human-readable-form
03:20:02 <shachaf> Dobias: (But I don't bet too much -- it's just a guess.)
03:20:06 <Dobias> shachaf: Yes, with fibo :: [Integer] both versions just take 0.002s.
03:20:10 <typoclass> Dobias: here is an interesting article about what ghc does in general http://blog.ezyang.com/2011/04/tracing-the-compilation-of-hello-factorial/
03:20:24 <shachaf> Dobias: My guess is that fibo is getting inlined and then specialized with -O.
03:21:06 <shachaf> Dobias: fibo :: Integral a => [a] naÃ¯vely gets compiled into a function like fibo :: IntegralDict a -> [a]
03:21:23 <shachaf> Therefore it doesn't get shared, so you get asymptotically worse behavior (exponential instead of linear).
03:21:34 <shachaf> But that's only a guess. :-)
03:22:21 <shachaf> But looking at the Core should be enough to figure out whether it's true.
03:23:51 <Dobias> tyoclass: Thanks for the remark to the dump flags. I now see the core.
03:24:07 <Dobias> shachaf: Ok, http://codepad.org/XveY7x07 , but I have no idea how to read this. :D
03:24:54 <shachaf> Dobias: Compile it with -dsuppress-all and look again.
03:25:16 <merijn> Dobias: Related, I just saw an article giving an intro to looking at GHC Core: http://alpmestan.com/2013/06/27/ghc-core-by-example-episode-1/
03:25:51 <typoclass> Dobias: and here is some more stuff http://www.haskellforall.com/2012/10/hello-core.html -- http://stackoverflow.com/questions/6121146/reading-ghc-core
03:25:57 <shachaf> Yep, that looked like a good article.
03:26:15 <typoclass> merijn: ooh, haven't seen that one, thanks
03:26:32 <Dobias> http://codepad.org/nRncrnRr
03:27:30 * shachaf would recommend the first linked article over the second one, which seems to be a bit misleading.
03:27:30 <Dobias> OK, I will read the two linked articles.
03:28:25 <shachaf> E.g. "IO is a state monad" is just misleading.
03:28:43 <shachaf> Dobias: Is what you pasted with or without -O? I guess without?
03:28:48 <merijn> It also seems the first one is simpler to start with
03:29:04 <shachaf> alpounet++
03:29:09 <merijn> i.e. it starts with the core for "x :: Int; x = 4" :p
03:29:27 <Dobias> yes, without -O
03:29:30 <volitek> I'm having real trouble understanding how to handle state in haskell. I'm trying to build a poker website with Yesod, and I'm going to need to store the gamestate of several tables. I've written functions that can manipulate the gamestate functionally, i.e. you pass it a gamestate and the active players choice of move, and it returns the state ready for the next players turn, but where do I put the gamestate?? How do I do this functionally / with haskell?
03:31:09 <simukis_> volitek: If you want it to be persistent you put it into the file/database. Otherwise State monad will do.
03:31:10 <typoclass> shachaf: oh, gabriel indeed wrote that. yeah that's odd, isn't it
03:31:37 <MasseR> volitek: It's no longer so much about haskell than it is that you are trying to retain state in a stateless environment (http)
03:33:25 <volitek> MasseR: I don't follow, how else should I approach this?
03:33:34 <MasseR> In a really functional solution you could 'retain state' in a continuation but that's really not applicable to yesod :). I would probably keep the state in a MVar Map UserId GameState
03:33:35 <shachaf> Dobias: That code -- the fibo definition -- seems relatively straightforward, so you should understand it more-or-less and then look at the -O code.
03:33:45 <MasseR> If it is a state for user
03:33:54 <MasseR> Otherwise an MVar GameState is ok too
03:33:57 <shachaf> Dobias: It might be a bit easier to read if you suppress a little bit less than suppress-all -- having the types there helps.
03:34:29 <tomboy65> okay
03:34:30 <tomboy65> i officially suck
03:34:32 <alpounet> Dobias, feel free to complain about that article (the one on alpmestan.com) if anything is unclear, i'll do my best to fix it
03:34:43 <tomboy65> in both haskell and python i compute the wrong result
03:34:57 <tomboy65> yet i compute the same result in both languages
03:35:17 <volitek> MasseR: simukis_: okay i will look up what you both said, thanks for the suggestions!
03:35:22 <Dobias> alpounet: OK, but I am just learning Haskell since two weeks, so I guess I am not competent in doing this. ;)
03:35:33 <t7> tomboy65: paste
03:35:50 <Dobias> shachaf: You were right. The runtime becomes exponetial: http://codepad.org/PqGW6cl2
03:36:31 <AndChat|> Shachaf did you used to hang out in #ruby?
03:36:57 <alpounet> Dobias, that's my point. Well, maybe it's a tiny bit early to read some Core and have a deep understanding, but you should get some intuition nonetheless
03:37:07 <alpounet> that first article doesn't cover anything too hairy
03:37:23 <shachaf> Dobias: You can work out what's going on there without reading any Core -- as I did -- but Core is helpful to confirm it.
03:38:06 <shachaf> AndChat|: A while ago, yes.
03:38:09 <Dobias> ok, I will read alpestams article, and then try to continue with LYAH. ;)
03:38:42 <Dobias> Thanks for you help guys. :)
03:38:53 <AndChat|> Dpbias link for article?
03:39:10 <shachaf> Dobias: Also read, uh, about the monomorphism restriction (not directly relevant here, but this is the reason it exists), and about lazy evaluation/graph reduction.
03:39:12 <AndChat|> Dobias*
03:39:14 <shachaf> @where mr
03:39:14 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
03:39:16 <shachaf> @where lazy
03:39:16 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
03:39:22 <Dobias> AndChat: http://stackoverflow.com/questions/6121146/reading-ghc-core
03:39:24 <shachaf> E.g. those two articles.
03:39:26 <Dobias> sorry
03:39:34 <Dobias> http://alpmestan.com/2013/06/27/ghc-core-by-example-episode-1/
03:43:23 <tomboy65> hehehe t7: http://bpaste.net/show/110173/   ---   it's an implementation of this problem: https://projecteuler.net/problem=196 and i fail to compute the test value for S(10000)
03:54:54 * hackagebot minioperational 0.2 - fast and simple operational monad  http://hackage.haskell.org/package/minioperational-0.2 (FumiakiKinoshita)
03:56:48 <gspr> How can I tell cabal to pass an -I/some/path to GCC when compiling the foreign pieces of some package?
03:57:06 <matematikaadit> :t Just Nothing
03:57:07 <lambdabot> Maybe (Maybe a)
03:57:08 <shachaf> gcc-options, maybe?
03:57:17 <shachaf> Or cc-options. Or something else. cabal --help somethingorother tells you.
03:57:46 <gspr> shachaf: Oh, I meant when running cabal, not by changing the .cabal file
03:58:44 <gspr> I found out. It's --extra-include-dirs
03:59:02 <shachaf> gspr: OK, but in that case it would be --foo-options instead.
03:59:10 <shachaf> But --extra-include-dirs is even better!
04:01:08 <blackdog> matematikaadit: sounds like a sulky teenager :)
04:01:34 <matematikaadit> blackdog: Maybe ;)
04:22:31 <akegalj_> is there standard function that will "aaabba" -> [('a',3'),('b',2),('a',1)] ?
04:23:06 <haasn> uh
04:23:25 <haasn> > map (head &&& length) . group $ "aaabba"
04:23:28 <lambdabot>   [('a',3),('b',2),('a',1)]
04:23:45 <akegalj_> haasn: thnx
04:25:03 <akegalj_> haasn: where is &&& defined?
04:25:21 <haasn> Control.Arrow
04:25:27 <akegalj_> tnnx
04:25:37 <bscarlet> http://www.haskell.org/hoogle/?hoogle=%26%26%26
04:25:43 <bscarlet> Hoogle is your friend
04:26:08 <dingding> a,b,c are 3 nos.. we have a, b^c^a can we get b and c from this?
04:26:23 <Aetherspawn_> @pl (\g h i -> g `comp` h || g `comp` i)
04:26:27 <lambdabot> ap (flip . ((.) .) . ((||) .) . comp) comp
04:26:27 <lambdabot> optimization suspended, use @pl-resume to continue.
04:26:34 <Aetherspawn_> oh god.
04:27:09 <shachaf> Not happy with deriving Eq, eh?
04:27:09 <dingding> Im struck, please help..
04:27:24 <shachaf> dingding: Is this related to Haskell?
04:27:27 <dingding> not related to haskell but in general
04:27:35 <dingding> bit operations..
04:28:05 <dingding> we have a and b^c.. its impossible?
04:28:14 <dingding> is it impossible?
04:29:09 <haasn> Aetherspawn_: something like \g -> (||) `on` comp g -- or: on (||) . comp
04:29:33 <shachaf> any (g `comp`) [h, i]
04:30:05 <shachaf> But if I remember correctly there was a suspicion that comp is actually Eq. In which case this is just g `elem` [h,i]
04:30:28 <shachaf> But, eh. Horses etc.
04:32:09 <Taneb> Is there a case for (Applicative f, Monoid a) => Monoid (WrappedApplicative f a) where mempty = pure mempty; mappend = liftA2 mappend
04:32:56 <arcatan> horses.
04:33:17 <Aetherspawn_> horses?
04:33:34 <haasn> Taneb: a case for?
04:33:50 <Taneb> haasn, a number of good reasons why it should exist
04:34:08 <Aetherspawn_> (==) is indeed comp
04:34:24 <Aetherspawn_> I just tried it. I wouldn't have expected (==) to work in tree circumstances
04:35:42 <Taneb> @let data TanebFoo a = TanebFoo Int a a deriving Eq
04:35:43 <lambdabot>  Defined.
04:36:04 <Taneb> No wait
04:36:09 <Taneb> That's not what I want
04:36:13 <Taneb> @help undef
04:36:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:36:23 <Taneb> @undef TanebFoo
04:36:23 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
04:36:43 <Taneb> @let data TanebFoo a = TanebFoo Int a (TanebFoo a) a
04:36:43 <lambdabot>  .L.hs:134:6:
04:36:43 <lambdabot>      Multiple declarations of `TanebFoo'
04:36:43 <lambdabot>      Declared at: .L.h...
04:36:50 <Taneb> @let data TanebFoo' a = TanebFoo' Int a (TanebFoo a) a
04:36:51 <lambdabot>  Defined.
04:37:31 <Taneb> Bah
04:37:33 <Taneb> @undefine
04:37:33 <lambdabot> Undefined.
04:37:37 <Taneb> I should shut up
04:39:57 <Aetherspawn_> lol Taneb
04:40:12 <Taneb> My point was, (==) does work on arbitrary tree-like structures
04:41:01 <Aetherspawn_> Yeah, I just converted my code to use it and it's 10 lines shorter without all the comp stuff :) https://gist.github.com/kvanberendonck/5862432
04:41:10 <Aetherspawn_> although it is a bit harder to read with all the =='s and ='s next to each other
04:41:51 <Taneb> In the And case for expl, I wouldn't bother defining x' and y'
04:42:17 <Aetherspawn_> Oh, you're right.
04:43:11 <Aetherspawn_> thanks for pointing that out
05:14:17 <haasn> that's a free monad!
05:21:22 <haasn> I wonder if that tree optimizer could be made neater using biplate
05:22:05 <Aetherspawn> haasn, ?
05:26:21 <haasn> Aetherspawn: http://hackage.haskell.org/packages/archive/uniplate/1.6.1/doc/html/Data-Generics-Uniplate-Operations.html#g:4
05:27:00 <Aetherspawn> Thats really complex :S
05:27:03 <shachaf> haasn: Why use unplate when you can use lens?
05:29:12 <haasn> shachaf: possibly because one has forgotten what the lens equivalent of those functions are
05:29:41 <shachaf> haasn: http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/Control-Lens-Plated.html -- guess.
05:30:02 <haasn> oh yeah, that's the one
05:30:24 <haasn> http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/Control-Lens-Plated.html#v:transform
05:59:56 * hackagebot llvm-general 3.2.0.5 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.0.5 (BenjaminScarlet)
06:09:56 * hackagebot llvm-general 3.3.0.3 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.0.3 (BenjaminScarlet)
06:33:22 <acube> Is it possible to kill a running threads in GHCI?
06:34:48 <jbracker> If I have a cabal package with several executable, how can I say I want to install just one of them?
06:36:19 <merijn> jbracker: I don't think you can?
06:36:31 <merijn> At least, not without the package exposing flags to do that
06:36:46 <jbracker> But why do you list different dependencies for each exec. in a cabal file then?
06:36:59 <jbracker> that does not make sense
06:37:12 <shachaf> Each one is compiled on its own with its own GHC flags.
06:37:17 <shachaf> Including package flags.
06:37:51 <jbracker> hmmm... I would habe thought that is possible...
06:37:51 <shachaf> I think an option for this may have been added in HEAD recently, though I might be mixing it up with something else.
06:38:28 <jbracker> so for now I would have to add flags for each executable if I want to compile some but not all
06:40:43 <NeufDeuxRit> Hi guys, is the partial order (ie "definedness") used there http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/ more "formally" described somewhere ?
06:44:26 <elliott> NeufDeuxRit: this is what is covered under "denotational semantics"
06:44:44 <elliott> it's a "complete partial order"
06:44:51 <elliott> just some keywords to help you search
06:45:28 <NeufDeuxRit> I know those but I didn't find any precise reference (ie set of rules) defining these one
06:45:57 <NeufDeuxRit> Or is your point that those rules don't exist out of a full denotational semantics course ?
06:46:29 <elliott> well, as far as I know there's no full denotational semantics of Haskell.
06:46:48 <elliott> but the definedness relation is pretty simple; is there something about it you don't understand from the blog post?
06:49:02 <NeufDeuxRit> Oh no, I was just think of using these order to speak of LVars (in general) replacing bottom by "nt defined yet"
06:49:33 <NeufDeuxRit> and something more condensed that thes post (which is yet excellent and introduced me to semantics) would be useful
06:50:51 <elliott> I don't really have any specific links to give you, sorry; maybe someone else can help
06:51:25 <NeufDeuxRit> No problem :)
06:52:52 <chunkstuntman> hello!
06:52:57 <chunkstuntman> I have a quick question
06:53:26 <chunkstuntman> I'm writing a function that takes in a Maybe(Char,Text)
06:54:10 <chunkstuntman> how do I write the pattern for the non Nothing function?
06:54:25 <chunkstuntman> I've already tried (Maybe(x:xs))
06:54:28 <shachaf> (Style note: Generally you'd write a space after the Maybe.)
06:54:36 <chunkstuntman> I've tried that
06:54:44 <shachaf> Function application in Haskell is "f x", not "f(x)"
06:54:45 <chunkstuntman> I was just writing it quickly
06:54:49 <shachaf> Anyway,
06:54:49 <shachaf> @src Maybe
06:54:50 <lambdabot> data Maybe a = Nothing | Just a
06:55:03 <shachaf> The two cases you want to match for are Nothing and Just (...)
06:55:21 <shachaf> (x:xs) doesn't make any sense for (...), though, because : is for lists, and you have a pair.
06:55:22 <chunkstuntman> well what I currently have are: (Just (x:xs))
06:55:25 <chunkstuntman> and Nothing
06:55:35 <shachaf> Why :?
06:55:44 <chunkstuntman> I'm not sure
06:55:50 <chunkstuntman> it's just a pair?
06:56:05 <shachaf> Well, you're the one who wrote "(Char,Text)"
06:56:20 <shachaf> :t ('a', True)
06:56:21 <lambdabot> (Char, Bool)
06:56:43 <shachaf> : is only for lists. You don't have a list in sight here.
06:56:52 <monochrom> f (Just (c, t)) = ... c is your Char and t is your Text
06:57:17 <tomboy65> i want to zip 2 lists together in a special way: list 1: [a1, a2, a3..], list 2: [b0, b1, b2, b3], result: [(a1, [b0, b1, b2]), (a2, [b1, b2, b3]), (a3, [b2, b3, b4]) .. ]
06:57:27 <tomboy65> suggestion how to do that most effectively?
06:57:36 <bscarlet> chunkstuntman: It looks to me like you've got a modified example which used to have String instead of Text. String is [Char]. Text is quite different.
06:57:38 <shachaf> Are these lists infinite?
06:57:44 <tomboy65> shachaf: no
06:57:59 <tomboy65> shachaf: each contains several million members, though
06:58:02 <NeufDeuxRit> tomboy65: wouldn't a map on alist be enough ?
06:58:22 <b2coutts> tomboy65: you could convert list 2 into [[b0,b1,b2],[b1,b2,b3],...]
06:58:28 <tomboy65> NeufDeuxRit: i tried that. it's running for over an hour now so i'm reworking my algorithm.
06:58:28 <b2coutts> and then simply zip them
06:58:37 <tomboy65> hm
06:58:55 <tomboy65> that might work
06:59:09 <chunkstuntman> bscarlet: you are correct
06:59:48 <NeufDeuxRit> is b2coutts version is more efficient, I'll be glad if someone could explain it
06:59:49 <shachaf> tomboy65: The reason I asked about the lists being infinite is that you have to figure out what to do at the end of the list. :-)
06:59:50 <chunkstuntman> http://pastebin.com/fSJR9xy1
06:59:56 <tomboy65> b2coutts: actually it should, though. but i was looking for a more efficient implementation.
06:59:59 <mauke> The paste fSJR9xy1 has been copied to http://hpaste.org/90508
07:00:00 <chunkstuntman> I'm getting an odd type error
07:00:14 <chunkstuntman> oh
07:00:14 <b2coutts> yeah, I'm not sure about how efficient it is; it depends on what kind of magic ghc does
07:00:15 <chunkstuntman> never mind
07:00:19 <tomboy65> shachaf: i could pad them, that's no problem.
07:01:13 <b2coutts> NeufDeuxRit: explain what it does, how to implement it, or why it's more efficient?
07:01:15 <NeufDeuxRit> why it's more efficient
07:01:20 <NeufDeuxRit> internal ghc behavior is quite obscure to me
07:01:20 <tomboy65> b2coutts: i'm afraid it isn't very efficient, since it means i would basically triple the size of the first list in a temporary one.
07:01:21 <zvrba> how does, or does, Haskell distinguish between Nothing :: Int and Nothing :: String ?
07:01:41 <b2coutts> tomboy65: well, you have to create all of those elements anyway
07:01:48 <monochrom> Nothing is neither Int nor String.
07:01:59 <zvrba> but it belongs to Maybe a ...
07:02:23 <monochrom> then you should say, Nothing :: Maybe Int or Nothing :: Maybe String.
07:02:35 <zvrba> ya
07:02:45 <shachaf> I,I Nothing @ Int; Nothing @ String
07:02:48 <monochrom> the rest of the program determines which one it is
07:03:00 <b2coutts> probably the most efficient way is to just have a function that does 'f (x:xs) (a:b:c:ys) = (x,[a,b,c]):f xs b:c:ys'
07:03:07 <shachaf> (I often wonder whether people use :: to mean type application.)
07:03:14 <NeufDeuxRit> b2coutts: this is the map
07:03:37 <shachaf> b2coutts: I would measure it before being sure of that.
07:04:21 <NeufDeuxRit> (\l1 l2 -> (map (\x -> (x,l2)) l1)) ['a'... 'c'] [1...4]
07:04:24 <NeufDeuxRit> >(\l1 l2 -> (map (\x -> (x,l2)) l1)) ['a'... 'c'] [1...4]
07:04:28 <NeufDeuxRit> hm
07:04:45 <NeufDeuxRit> seems like I've forgotten how to use lambdabot
07:04:53 <b2coutts> need a space after '>' I think
07:04:58 <NeufDeuxRit> > (\l1 l2 -> (map (\x -> (x,l2)) l1)) ['a'... 'c'] [1...4]
07:05:00 <lambdabot>   Not in scope: `...'
07:05:00 <lambdabot>  Perhaps you meant one of these:
07:05:00 <lambdabot>    `.&.' (imported fro...
07:05:07 <NeufDeuxRit> > (\l1 l2 -> (map (\x -> (x,l2)) l1)) ['a'.. 'c'] [1..4]
07:05:08 <lambdabot>   [('a',[1,2,3,4]),('b',[1,2,3,4]),('c',[1,2,3,4])]
07:05:42 <NeufDeuxRit> anyway that's something tomboy65 tried already if I've well understood and that wasn't efficient enough
07:06:38 <tomboy65> hm
07:06:54 <NeufDeuxRit> but tomboy65 I don't think you can reach more efficient as this is O(length of l1). Time is due to multiple copy of l2, so maybe changing your code ahead might help
07:06:57 <tomboy65> it's probably not that function that's not efficient
07:07:09 <tomboy65> yes
07:07:26 <tomboy65> i think i have redundant time intensive calls in there
07:07:29 <tomboy65> just looking over it again
07:08:09 <tomboy65> thanks so far
07:13:09 <Athas> Can anyone think of an elegant way of writing a function that moves an element from one place at a list to another?
07:13:49 <Lethalman> Athas, reorder?
07:13:53 <Athas> Eg, 'move :: Int -> Int -> [a] -> [a]', where 'move k n l' returns a list where the old element at index k is now at index k+n.
07:14:08 <Lethalman> ops lol I read "an elegant name of a function" sorry
07:14:28 <Athas> I can do it manually with takes and drops, of course.
07:14:54 <Athas> Or splitAt, rather.
07:15:29 <Lethalman> Athas, maybe zippers, not sure though
07:17:51 <bxc_> does anyone remember a bug in quickcheck2 where it was ignoring the maximum test case size, sometime in the last year?
07:18:55 <bxc_> i vaguely remember encountering it and it looks lke on a new machine i've just installed I'm seeing it again. but grr i don't remember the details...
07:19:13 <bxc_> (or rather, Maybe seeing it again)
07:23:47 <lemao> ola! In the Overloaded Record Fields discussion I don't see an attempt to merge the Has typeclass with a basic notion of Lens. Is there something technically obvious I am missing?
07:25:20 <elliott> we sort of do that in lens
07:28:18 <lemao> I see a proposal to implicitly generate an Has typeclass for x in data F = F { x :: Int }, why not use the get/set notion from Lens? So f.x would be sugar for Lens?
07:28:28 <allsystemsarego> msg e1 e2 e3 = if e2 ++ e3 == "" then show e1 else e2 ++ e3 -- how can this function be made DRY (avoid doing the concatenation twice)?
07:28:59 <supki> f.x, huh?
07:29:04 <edwardk> lemao: i'm currently discussing that with simon
07:29:14 <merijn> allsystemsarego: let/in or where clause?
07:29:19 <edwardk> we'll see how it goes
07:29:30 <allsystemsarego> merijn, I tried and failed
07:30:59 <supki> f.x notation would mean you cannot use (.) without spaces anymore, right?
07:31:32 <lemao> edwardk: that is good to hear! I personally like the idea of a f.x sugar mainly because it add clarity to the sources (imho), but that is somewhat orthogonal to reusing a basic notion of a Lens. Good luck in these discussions.
07:32:13 <merijn> allsystemsarego: Two ways would be http://hpaste.org/90509
07:32:53 <lemao> supki: there is an ongoing discussion to fix a few warts in Haskell records.
07:33:52 <lemao> edwardk: "Good luck in these discussions" didn't mean in a cynical way, but hope that there can be a common ground that everyone would benefit
07:34:25 <allsystemsarego> merijn, nice, thanks, It wouldn't have occured to me to try it this way
07:34:28 <merijn> elliott: I'm just getting to some indent bugfixes
07:34:42 <merijn> elliott: I consider "foo = bar baz quux where\n" not indenting a feature, not a bug :)
07:34:54 <merijn> :p
07:34:59 <bscarlet> I've got a weird error which looks like a subtle GHC bug.
07:35:09 <bscarlet> http://hpaste.org/90510
07:35:47 <merijn> allsystemsarego: Using where like that is very common, as GHC will evaluate names in where only once, even if used multiple times in the associated function body
07:36:29 <elliott> merijn: why on earth would it not indent?
07:36:35 <elliott> nobody wants to write an empty where clause
07:37:04 <lemao> supki: as far as I understand that is the case ((.) without spaces would be reserved - in the same way that it is already used for module names)
07:37:06 <bscarlet> Can anyone comment? A case with some patterns from a quasiquoter generated with dataToPatQ using a standalone-derived instance of Data, and some not from a quasiquoter, is producing what seem to be spurious pattern overlap warnings.
07:37:06 <merijn> elliott: Sure, I'm just opposed to where on the same line :p
07:37:26 <merijn> I can see how hard it would be to make that change
07:37:56 <elliott> merijn: "foo = bar\n  where\n    ..." is ugly :)
07:42:28 <merijn> elliott: pffft
07:42:36 <merijn> Don't write such small functions then!
07:42:44 <elliott> wat
07:44:01 <merijn> Needs more smileys, I see...
07:45:08 <mr-> elliott: that's ugly? I often do that :-(
07:45:10 <elliott> I don't see what it has to do with the length of the function even :P
07:46:19 <KingofFerrets> ...So weird. I'm used to cranking out 200 lines of code being like, a day's work at most. Now I'm working in Haskell, and even though I'm commenting way more than normal, it's like "HAH YES I HIT 500 LINES AFTER TWO WEEKS". <.<
07:46:33 <Lethalman> same here, i often do foo = bar \n where ...
07:46:59 <merijn> Lethalman: That works
07:47:12 <merijn> Lethalman: It's "foo = bar where\n" that's buggy atm :p
07:47:22 <Lethalman> ah
07:47:49 <Lethalman> I was reading something about ghc core
07:48:10 <Lethalman> and the fact that it seems types are passed to the function looks much like dependant types
07:48:24 <Lethalman> with \ (@a) ...
07:48:39 <Lethalman> that resembles a bit of agda
07:48:51 <merijn> Lethalman: That's actually the opposite of dependent types
07:48:59 <merijn> Lethalman: Are you familiar with the lambda cube?
07:49:10 <roconnor> Lethalman: welcome to F_omega
07:49:13 <Lethalman> mh no
07:49:51 <mauke> NATURE'S HARMONIC SIMULTANEOUS 4-TYPE LAMBDA CUBE
07:50:06 <Lethalman> ah
07:50:51 <Lethalman> so in ghc core when types are passed to functions it's because terms depend on that type?
07:50:51 <merijn> Lethalman: There's a paper "Introduction to Generalised Type Systems" by Barendregt, which introduces the lambda cube and discusses how the various (orthogonal) issues of types depending on terms, terms depending on types, types depending on types and terms depending on terms can be combined
07:52:23 <ziman> hm, could there be useful systems where terms cannot depend on terms?
07:53:55 <merijn> ziman: Not a typed lambda calculus, afaik
07:54:33 <byorgey> ziman: not useful, no
07:54:41 <byorgey> because you can't do any computation.
08:01:47 <merijn> elliott: Ok, new version should have all your issues fixed
08:02:46 <merijn> Which means its time for my self-pimping of the day in an attempt to get more testers :p
08:03:09 <merijn> All vim users should try https://github.com/merijn/haskellFoldIndent it's surprisingly non-broken!
08:05:54 <ocharles> ooo, vim user here
08:05:54 * ocharles looks
08:06:16 <ocharles> "Multiline data declarations will automatically line up with the equals sign:"
08:06:18 <ocharles> #nope
08:06:22 <merijn> ocharles: It's optional!
08:06:33 * ocharles reverts that #nope and reads more
08:06:38 <merijn> I pushed the documentation change for that 5s ago
08:06:42 <ocharles> heh
08:06:44 <b2coutts> haha
08:06:51 <ocharles> I'm tempted to start using GADT syntax everywhere
08:06:51 <merijn> Might need to refresh github, elliott was complaining about it too
08:07:06 <ocharles> | just makes any indentation style generally suck
08:07:06 <merijn> (which is mainly why I added it)
08:07:07 <roconnor> merijn: how do I try it?
08:07:47 <S11001001> @info (>>=)
08:07:47 <lambdabot> (>>=)
08:08:11 <merijn> roconnor: If you use pathogen, just clone the repo into your bundle folder, if not just dumping plugin/haskellFoldIndent.vim into ~/.vim/plugin/ should work
08:08:26 <ocharles> merijn: can it indent function signatures like https://github.com/ocharles/pipes-tar/blob/master/src/Pipes/Tar.hs#L333 ?
08:08:34 <ocharles> though that example isn't quite the best...
08:08:58 <ocharles> generally if I can't fit it on one line I have the name on one line, then shiftwidth :: the -> rest
08:09:04 <merijn> roconnor: (assuming you have "filetype plugin indent on" set in .vimrc, which you probably should)
08:09:13 <ocharles> I've just noticed I use about 5 different indenting styles in that file, so I ought to fix that :)
08:09:33 <merijn> ocharles: By default it lines up arrows in multiline type signatures
08:09:51 <jeltsch> Hi, if I install the Haskell Platform 2013.2.0.0 from source, is package documentation automatically built?
08:09:52 <merijn> i.e., like https://github.com/merijn/haskellFoldIndent#type-signatures
08:10:14 <ocharles> merijn: ok, it sounds like that should Just Work for me then
08:10:50 <merijn> ocharles: If you prefer something else, I'm open to suggestions (implementation depends on offensive I find the resulting style vs amount of effort required, i.e. offensive styles will get minimal work investment :p)
08:11:33 <merijn> ocharles: basically, if you type "-> " or "=> " at the start of a line (ignoring whitespace) it will line the line up with the first arrow or :: on the line above it
08:12:19 <jeltsch> Hmm, is there any other channel or such where I can get help about the Haskell Platform?
08:12:36 <merijn> Whoops, documentation bug
08:12:50 <merijn> Or rather, my documentation contains invalid syntax >.>
08:14:35 <NihilistDandy> jeltsch: Yes, it builds documentation
08:14:39 <merijn> ocharles: Basically, there's a bunch of things that would be cool to have, but it's solid enough that I've been using it for my own code and I just fix/add features as I run into them and/or get requests for them
08:14:44 <jeltsch> NihilistDandy: Okay, very good! Thank you.
08:15:38 <ocharles> merijn: understood, it's useful for me as is
08:15:43 <ocharles> so you have successfully improved the state of the world
08:15:44 <ocharles> :)
08:15:47 <merijn> \o/
08:15:55 <jeltsch> NihilistDandy: Do you also know whether the configure script defaults to user install or global install? The output of --help speaks about autodetection, but I don’t know how this can be “detected”.
08:16:24 <monochrom> jeltsch: do you have hscolour? if not, haskell platform build script has a bug, it hardcodes "--hyperlink-source" which makes haddock abort because you don't have hscolour. edit scripts/build.sh, find "--hyperlink-source", modify it
08:16:42 <NihilistDandy> Ah, also that ^
08:16:48 <NihilistDandy> I had forgotten about that.
08:17:09 <monochrom> it autodetects --user vs --global from your --prefix
08:17:34 <jeltsch> monochrom: What do you mean by “having” hscolor. Having it already installed? I have only installed GHC 7.6.3 via binary install for Linux.
08:17:38 <monochrom> e.g., --prefix=/usr/local => global, --prefix=/home/monster => user
08:17:47 <monochrom> then you don't have hscolour
08:17:59 <merijn> ocharles: hmm, the one thing that might be problematic about the file you linked is example code in multiline comments, I haven't figured out how to usefully detect those yet. Vim is limited to line by line indent decisions, and finding haskell multiline comments almost requires parsing the entire file for comment glyphs...
08:18:38 <jeltsch> monochrom: So ./configure checks whether the prefix lies in my home directory or not to decide the user vs. global question?
08:19:04 <roconnor> merijn: ~/.vimrc [New File]
08:19:21 <merijn> roconnor: I have good news for you!
08:19:22 <monochrom> something like that
08:19:53 <merijn> roconnor: I went through the effort to properly document my vim file with sane defaults! https://github.com/merijn/dotfiles/blob/master/vimrc
08:21:03 <NihilistDandy> merijn: My vimrc is so over-engineered compared to yours :D
08:21:13 <merijn> NihilistDandy: Yeah, I try to keep it minimal
08:21:58 <NihilistDandy> I should try to pare mine down. I mainly just keep the actual active part minimal with conditional loading, but the global defaults are still fairly big
08:25:27 <roconnor> Error detected while processing /home/roconnor/.vimrc:
08:25:28 <roconnor> line   91:
08:25:29 <roconnor> E28: No such highlight group name: LineTooLong
08:25:47 <roconnor> P
08:27:18 <roconnor> merijn: anyhow, how do I use this automagic formatter?
08:27:23 <merijn> roconnor: Yeah, you should probably delete line 90-92 line 4 as they refer to my own colorscheme (unless you download that too, it's in the repo)
08:28:23 <acube> > fix error
08:28:25 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
08:28:28 <merijn> roconnor: Open a file with a .hs extension (or set ":set ft=haskell") and start typing. It doesn't work too well as automatic formatter, as deciding whether or not to change the existing indentation of code requires precognition
08:28:47 <merijn> So by default it doesn't change the indent of already indented lines, only new ones
08:29:17 <roconnor> ok
08:29:45 <merijn> (with nested do blocks there's no way to sensibly decide whether a line should belong to one or the other, so deciding how to change the indentation is impossible)
08:31:17 <dolio> I've been working on indenting for vim that isn't dumb off and on.
08:31:21 <dolio> Not ready for prime time yet, though.
08:31:55 <shachaf> Is 2017 the next prime time?
08:32:48 <roconnor> where is shiftwidth defined?
08:32:58 <pxqr> how to fix this http://hpaste.org/90517 ?
08:33:11 <ocharles> roconnor: you set that in your ~/.vimrc
08:33:15 <dolio> I made a demo video here: https://www.youtube.com/watch?v=EIs2YEcM9LY
08:33:21 <ocharles> set shiftwidth=4, for example
08:34:28 <roconnor> this is surprisingly non sucky
08:34:29 <nooodl> or inside vim, :set sw=4
08:35:15 <monochrom> pxqr: you have several versions of directory etc, the ones you need is shadowed by the ones you installed more recently. get rid of the recent ones. see my http://www.vex.net/~trebla/sicp.xhtml for full story
08:35:39 <monochrom> err, http://www.vex.net/~trebla/haskell/sicp.xhtml
08:36:03 <chreekat> Can I try out this 'surprisingly non sucky' automagic indenter?
08:36:15 <chreekat> sorry for jumping in mid-convo
08:36:40 <mgsloan>  dolio: Neat!!
08:37:02 <pxqr> monochrom: yes, something like that. I've just upgrade debian and trying to install lens to sandbox. So I guess that some core lib is dublicated or something like this.
08:37:11 <pxqr> thanks for the link.
08:38:28 <Clint> pxqr: the libghc-lens-dev package in unstable is current
08:39:10 <merijn> chreekat: https://github.com/merijn/haskellFoldIndent
08:40:10 <merijn> chreekat: Any suggestions/bug reports (other than the issues already listed at the bottom of the README) are welcome
08:41:03 <lcfrs> Hi, has anyone worked with distributed-process (a.k.a. Cloud Haskell)? I'm running into an issue where it seems ProcessId does not have a Binary instance. For e.g.: Prelude> :i ProcessId lists instances for Eq, Ord, Show, but not Typeable and Binary even though these are defined in the module. Help?
08:41:30 <haasn> I think :i only lists instances you also have the classes for in scope or something
08:41:34 <haasn> have you imported Data.Typeable?
08:42:04 <lcfrs> Let me try that
08:42:12 <NihilistDandy> merijn: Wow that looks really good. That's been my only real annoyance with writing Haskell in Vim, and your plugin looks really neat
08:42:28 <ocharles> :i shows all instances in scope, but I thought it said where the instance was defined too
08:42:33 <dolio> mgsloan: It's a little less neat if you don't know exactly which cases to type in to make it look like it handles everything.
08:42:47 <merijn> NihilistDandy: Somewhere in the near future I will also try and get nice code folding going (hence the name), but haven't gotten around to it
08:43:03 <lcfrs> haasn: I imported Data.Typeable and I can see the Typeable instance now, but I still don't see the Binary instance even though I've imported Data.Binary.
08:43:15 <NihilistDandy> I sort of like the haskell-mode folds, but yeah, they could stand to be better
08:44:42 <merijn> NihilistDandy: That's the one that folds multiline type signatures to one line, right?
08:45:15 <mgsloan> dolio: ah, gotcha.  Well, it's a problem that's not really as straightforward as it might seem.  Particularly if you take into account the variety of indentation styles people have.
08:45:18 <dolio> mgsloan: It does apparently have precognition, though. :)
08:45:32 <NihilistDandy> I think it might do that, yes. The main think I notice is folding function definitions. I sort of like just being able to scan type before jumping into the thing that I want to work on
08:46:17 <alanz> lcfrs: Ask your question on #haskell-distributed
08:46:31 <lcfrs> alanz: Thanks, I'll try that
08:46:40 <merijn> NihilistDandy: Yeah, same here. But the indentation was a lot of work, so I'm currently procrastinating starting on the folding so I can actually do some haskell programming instead :p
08:47:03 <NihilistDandy> Haha, not a bad idea
08:47:06 <mgsloan> dolio: It'd be really neat to be able to shift where clauses like that while shifting all of the definitions.  I think chrisdone has something that does whole block shifting in emacs, but I don't think it has syntax-directed tabstops quite like your thing
08:47:44 <NihilistDandy> merijn: I'll definitely play around with it, though. It looks very slick. Enough to make emacs jealous :D
08:48:15 <dolio> Well, I'll keep that in mind, but that'd be more on the font-end, I think.
08:51:04 <Sculptor> yo
08:57:56 <applicative> hm 1114 nicks
09:03:34 <Sculptor> applicative, amazing
09:03:56 <merijn> :t traverse
09:03:57 <lambdabot>     Not in scope: `traverse'
09:03:57 <lambdabot>     Perhaps you meant one of these:
09:03:57 <lambdabot>       `T.traverse' (imported from Data.Traversable),
09:04:00 <merijn> :t T.traverse
09:04:01 <lambdabot> (Applicative f, T.Traversable t) => (a -> f b) -> t a -> f (t b)
09:04:29 <merijn> :t T.sequence
09:04:30 <lambdabot> (Monad m, T.Traversable t) => t (m a) -> m (t a)
09:05:54 <merijn> Is the Monad the most general requirement to have a function "t (m a) -> m (t a)" or are the less restrictive typeclasses that let you write that?
09:06:12 <supki> :t T.sequenceA
09:06:13 <lambdabot> (Applicative f, T.Traversable t) => t (f a) -> f (t a)
09:06:36 <CaptainK> why is this statement error in build but accepted at ghci console?
09:06:38 <CaptainK> zip [3,2,1] ["T","E","N"]
09:07:05 <geekosaur> it's not a statement, it's an expression
09:07:30 <geekosaur> if you're just using it by itself in a program, what is it supposed to do? where is the result supposed to go?
09:07:32 <CaptainK> so I need to equate it to some variable?
09:07:39 <geekosaur> otherwise, show actual code and error
09:07:41 <geekosaur> @paste
09:07:41 <lambdabot> Haskell pastebin: http://hpaste.org/
09:08:07 <nooodl> CaptainK: someList = zip [3,2,1] ["T","E","N"] -- should work
09:08:26 <roconnor> @src T.sequenceA
09:08:26 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:08:38 <CaptainK> ok, get it, you can't just have stuff go direct to standard out
09:08:41 <roconnor> :t T.traverse id
09:08:42 <lambdabot> (Applicative f, T.Traversable t) => t (f b) -> f (t b)
09:08:57 <geekosaur> in a program, everything ultimately follows from main
09:08:58 <roconnor> sequenceA = traverse id
09:09:00 <merijn> Yeah, seems like Applicative is the most general case
09:10:55 <naz__> Can someone point me to a function or a way, where I can read line x from file y ?
09:12:17 <mauke> :t \x -> fmap ((!! x) . lines) . readFile y
09:12:18 <lambdabot>     Couldn't match expected type `a0 -> f0 String'
09:12:18 <lambdabot>                 with actual type `IO String'
09:12:18 <lambdabot>     In the return type of a call of `readFile'
09:12:20 <mauke> :t \x -> fmap ((!! x) . lines) . readFile
09:12:20 <lambdabot> Int -> FilePath -> IO String
09:12:45 <b2coutts> naz__: afaik there isn't a way to read the nth line of a file without iterating through all the lines before it, if that's what you're asking
09:13:00 <b2coutts> since the OS/filesystem doesn't know where the newlines are in the file
09:13:22 <bscarlet> b2coutts: how about a memoizing version? Is that possible?
09:14:10 <b2coutts> bscarlet: I mean, regardless of how you do it, if you want to read the 1000th line of a file, you have to read the file until you've read 999 '\n's
09:14:16 <b2coutts> and then read until the next \n
09:14:38 <b2coutts> you could in theory have some sort of data structure representing a particular file, but for a general file this is necessary
09:15:15 <bscarlet> b2coutts: Yes.
09:16:03 <hvr> NihilistDandy: does http://youtu.be/06q-sCoqwEY make vim jealous? :)
09:17:31 <naz__> b2coutts: thanks for your input
09:17:38 <glguy> hvr: doesn't look like it
09:18:14 <NihilistDandy> Hmm, that's pretty neat, actually. Is there a link to that package somewhere? Is it in MELPA, yet?
09:18:28 <Peaker> mapAccumL/mapAccumR are essentially traverse on the State/reverse-State applicative, aren't they?
09:18:48 <joelteon> :t mapAccumR
09:18:49 <hvr> NihilistDandy: it's unpublished work relying on http://hackage.haskell.org/trac/ghc/ticket/5687
09:18:49 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:18:52 <naz__> mauke : also thanks, i was looking at readFile, but was hopping I can do something without iteratting through the file
09:19:00 <mauke> you can't
09:19:16 <merijn> Doh, I accidentally introduced an annoying indent at the start of the module with elliott's last request, fixed in the latest, latest version :p
09:19:40 <NihilistDandy> hvr: Ah. Though I should point out that neco-ghc does that sort of completion for vim with neocomplcache :D
09:20:07 <NihilistDandy> But that has a dependency on ghc-mod, so the new ghci functionality will be neat
09:20:12 <applicative> naz__: !! is unsafe, maybe something like take 1 . drop (n-1) . lines
09:20:55 <hvr> NihilistDandy: the ghci feature allows more, as it allows you to have the same completion as in ghci itself
09:21:41 <Raydiation> why do you return an empty tuple instead of Nothing in functions that dont return something like putChar?
09:22:03 <applicative> what type Nothing?
09:22:08 <Peaker> is there a standard Applicative flipper newtype somewhere?
09:22:14 <Raydiation> yes type Nothing
09:22:19 <applicative> Maybe Int, Maybe Char ?
09:22:22 <mauke> Raydiation: no such thing
09:22:40 <Raydiation> hm, so what is Maybe a?
09:22:43 <applicative> Raydiation: there could be a type data Nothing = Nothing, that would be the same as data () = ()
09:22:45 <Raydiation> isnt it a|Nothing
09:23:13 <applicative> "Maybe a" is the type that extends the type a with a new member Nothing, and wraps the rest in Just
09:23:18 <mauke> Raydiation: Maybe a is a type. Nothing is not a type
09:23:34 <mauke> Raydiation: and no, Maybe a = Just a | Nothing
09:23:45 <quchen> > Nothing :: Nothing -- ;-)
09:23:46 <lambdabot>   Nothing
09:23:47 <applicative> Raydiation: for any type X, Maybe X is like X but with an extra member
09:23:56 <elliott> quchen: misleading...
09:23:58 <geekosaur> and Maybe a = Just a | Nothing implies that something might return a Just a, whereas putStrLn never does
09:24:09 <Peaker> newtype ReverseApplicative f a = ReverseApplicative { runFoo :: f a } ; instance Applicative f => Applicative (ReverseApplicative f a) where pure = ReverseApplicative . pure ; ReverseApplicative f <*> ReverseApplicative x = ReverseApplicative $ flip ($) <$> x <*> f } ?
09:24:11 <quchen> elliott: Right, sorry.
09:24:17 <Peaker> is it in some lib already?
09:24:36 <elliott> Peaker: flip ($) <$> x <*> f is x <**> f, btw
09:24:54 <Peaker> thanks
09:25:08 <Peaker> so I suppose no lib?  I want the time-reversed State applicative
09:25:12 <Raydiation> so then what is Nothing?
09:25:19 <geekosaur> a data constructor
09:25:25 <geekosaur> :t Nothing
09:25:27 <lambdabot> Maybe a
09:26:03 <applicative> Raydiation: its a value that occupies all 'Maybe' types, as [] occupies all list types
09:26:27 <Peaker> data Maybe(type constructor) a(type variable) = Nothing(data constructor) | Just(data constructor) a(type variable)
09:27:07 <bscarlet> Peaker: have you seen the tardis package?
09:27:27 <Peaker> bscarlet, nope
09:27:31 <geekosaur> might be easier to think of it this way: a Maybe is a list which can hold zero or 1 elements. Nothing is [], Just a is [a]
09:27:35 <applicative> Raydiation: the name 'Nothing' is a little strange, maybe. Given how it is used it might have been called Bad, Error, Extra
09:27:57 <Peaker> bscarlet, I don't want the reverse-state monad, that seems wrong to me :P
09:28:02 <Raydiation> so i can think of data constructors like {} for creating an object in js for instance?
09:28:11 <Peaker> too easy to make self-referential loops
09:28:18 <Peaker> where-as reverse state applicative is trivial
09:28:21 <bscarlet> Peaker: you want a reverse state applicative, but not monad?
09:28:36 <Peaker> bscarlet, yep, I don't need Monad instance, so no need for the complexity of reverse state monad
09:28:46 <Raydiation> or typedef in C?
09:29:06 <Peaker> Raydiation, They're certainly not "typedef". "type" is like "typedef"
09:29:25 <Peaker> Raydiation, just think of them as the "options" inside a custom-defined Haskell type
09:29:43 <Peaker> Raydiation, each type gets a set of "options" that sum together to form a single type. each option is labeled with a "data constructor" and has fields inside it
09:29:51 <mauke> Raydiation: if you know C, 'data' is like a combination of struct/union/enum
09:29:54 <bscarlet> Peaker: what difference is there, other than syntactic?
09:30:02 <Raydiation> i see thanks
09:30:20 <geekosaur> Raydiation, the closest thing in C to this is enums.
09:30:35 <geekosaur> (it's not very close, but it will do for now)
09:30:48 <Raydiation> so Nothing as standalone is a data constructor without arguments?
09:30:52 <mauke> yes
09:31:13 <Peaker> bscarlet, the implementation of:  ReverseState s a -> (a -> ReverseState s b) -> ReverseState s b       has no good way of conjuring up the "a"
09:31:19 <applicative> yes, it doesn't need an argument, since the argument would be the 'valid' value of the underlying type
09:31:32 <Peaker> bscarlet, because the "a" there depends on the state effects of the result of the function that needs an "a" as an input
09:31:41 <applicative> Raydiation: if you think of data Maybe a = Nothing | Just a that way
09:31:46 <Raydiation> i see, can you use it as neutral element?
09:31:51 <Peaker> bscarlet, with Applicative, the state effects can never depend on other state effects
09:32:01 <applicative> Raydiation: as like data Value a = Error | Valid a
09:32:15 <Peaker> bscarlet, the type of bind for reverse state doesn't make sense
09:32:19 <Peaker> bscarlet, (IMO)
09:32:42 <applicative> Raydiation: in ML languages it would be Option a = None | Some a
09:32:51 <naz__> applicative: thanks for the addendum
09:33:16 <Raydiation> i see, replacing those things with lists makes it easier imo :) like List a = [] | [a]
09:33:35 <applicative> naz__: it occurred to me it's still beter to pattern match on the result of drop n lns
09:34:00 <applicative> case lns of [] -> whatever; (firstline:rest) -> whatever
09:34:27 <Raydiation> so the empty tuple is also a data constructor without arguments right?
09:34:28 <mauke> Raydiation: Maybe is like a list of at most one element
09:34:45 <applicative> Raydiation: no data [a] = [] | a : [a]
09:35:04 <applicative> oh I see you are following geekosaur 's idea up
09:35:17 <applicative> Raydiation: it has no arguments, ()
09:35:51 <applicative> it could be data TheSingleValuedType = TheSingleValuedTypeValue
09:36:01 <applicative> deriving (Show, Eq, Ord)
09:36:02 <bscarlet> Peaker: I'm not sure I understand you. The "a" comes from the first argument, the state from the second.
09:36:25 <Raydiation> but why is the empty tuple returned for putChar?
09:36:42 <bscarlet> Peaker: You simply find that distasteful? Or you like the stronger constraints of the Applicative?
09:36:45 <applicative> Raydiation: it is used to express 'No Information"
09:36:54 <applicative> data NoInformation = NoInformation
09:36:57 <geekosaur> because *something* has to be returned and () is a built-in type (and built-in value) which conveys zero information
09:36:58 <Raydiation> why no extra type for that?
09:37:06 <mauke> Raydiation: () is an extra type
09:37:07 <geekosaur> why have one?
09:37:35 <applicative> Raydiation: it's older than Haskell, MLs use Unit
09:38:09 <applicative> () is just witty and attractive like most things in Haskell
09:38:48 <Raydiation> or maybe name the type void :)
09:38:54 <ocharles> Void has no inhabitants at all
09:39:01 <tac> () is a very boring type. You use it when your function needs to return something very boring.
09:39:01 <ocharles> that name is already taken, and has a specific meaning
09:39:10 <ocharles> You cannot construct void
09:39:24 <yitz> ocharles: undefined
09:39:30 <mauke> fix V
09:39:31 <tac> :P
09:39:37 <ocharles> yitz: undefined fucks up everything, so I pretend that doesn't exist
09:39:47 <tac> ocharles: I feel you, man
09:39:57 <yitz> ocharles: yes. and it doesn't construct it, anyway.
09:40:10 <applicative> Raydiation: there are also empty data declarations in haskell; Void in a commonly used library is data Void = Void Void
09:40:25 <tac> Raydiation: Returning "Void" is something like saying, "this function never actually returns"
09:40:41 <applicative> so there is a function Void :: Void -> Void , for constructing a Void value, but unfortunately you have to use it to get one, etc
09:40:46 <tac> It's useful only for things like yield statements or "throw" statements for exceptions.
09:40:57 <ocharles> applicative: that's just a refinement of Void -> a, right?
09:41:07 <tac> (forall a. a) -> Void is inhabited too :)
09:41:40 <tac> ocharles: yeah. Void is initial, so there's exactly one function from it to any other haskell type.
09:41:47 <applicative> it's inhabited, but it has no occupants
09:41:54 <ocharles> oh, i never thought of void as being initial. interesting
09:42:01 <tac> and () is final
09:42:02 <yitz> tac: it is inhabited by unsafeCoerce (/me continues to make trouble)
09:42:05 <Raydiation> hm, thats what makes learning haskell so hard: nearly every operator/type has some different weird meaning
09:42:24 <ocharles> Raydiation: only cause all other languages got it so wrong ;)
09:42:30 <ocharles> </sweeping-generalisation>
09:42:32 <tac> yitz: I expect this kind of treatment in Haskell. My total-minded personality is not well-received here :P
09:42:39 <Raydiation> it feels like learning everything from scratch
09:42:53 <mauke> of course every operator has a different meaning
09:42:55 <tac> Raydiation: for sure. Haskell does things backwards if you learned any other language first.
09:42:59 <ocharles> Raydiation: Haskell does take a lot of rewiring, I agree
09:43:00 <mauke> I mean, what if they all meant the same thing?
09:43:06 <ocharles> but I think, now that I've done most of that rewiring, it was so worth itw
09:43:09 <tac> (But once you get Haskell, you can understand other related languages, like ML or Agda)
09:43:24 <applicative> Raydiation: it's really pretty simple, you just have to not think like a programmer
09:43:27 <applicative> at first
09:43:29 <yitz> tac: once you get Haskell, you can understand unrealated languages, too.
09:43:43 <benj_> @djinn Void -> a
09:43:43 <lambdabot> f = void
09:43:43 <Peaker> bscarlet, We have: State1 a -> (a -> State2 b) -> State3 b    When you have: StateN x   the "x" *depends* on the state transformations inside StateN.   "a" depends on the transformations in State2, but State2 depends on "a". this loop is unnecessary
09:43:56 <Raydiation> applicative: like free your mind and spirit
09:44:03 <Peaker> f (v:Void) = case v of {}
09:44:17 <ocharles> Peaker: good luck convincing ghc of that :)
09:44:27 <ocharles> (but yes)
09:44:28 <applicative> Raydiation: it is a bit like that.  Just think of 'defining your terms'
09:45:23 <Peaker> bscarlet, note the use of MonadFix
09:45:27 <applicative> Raydiation: inside the 'do' notation for IO , there you 'think like a programmer'
09:45:33 <Peaker> bscarlet, in the source of Tardis, to implement this loop (which I find ugly)
09:45:34 <applicative> </sweeping generalization ...
09:45:55 <Peaker> bscarlet, if your state effects don't depend on previous state effects, then it is better to use Applicative, where no such loop is necessary
09:46:15 <bscarlet> Peaker: okay. My taste is different, but I understand where you're coming from. Thanks.
09:46:39 <Peaker> bscarlet, Note that any little mistake you make may easily cause a runtime loop error, without any type error :(
09:46:57 <applicative> Raydiation: are you reading something?  Have you installed ghc and figured out how to load and compile modules?
09:49:00 <applicative> Raydiation: I mean, are you using some book or tutorial
09:49:14 <Raydiation> applicative: i got the learn you a haskell and real world haskell books
09:49:17 <bscarlet> Peaker: I can do that w/ let x = x in x, can't I? I wouldn't blame that on MonadFix.
09:49:24 <lispy> yampa defines the SF (signal function arrow) is it intentionally missing an ArrowApply instance?
09:49:26 <Raydiation> im trying to give http://www.haskell.org/haskellwiki/Haskell_Tutorial_for_C_Programmers a shot
09:49:37 <Raydiation> i cant think in haskell yet
09:49:51 <lispy> The documentation for ArrowApply says it is essentially a monad.
09:49:57 <Peaker> bscarlet, there's an explicit recursion there, though... and indeed, I'd really like "let rec" to be required for recursive name bindings
09:50:04 <tac> Raydiation: It takes a while to get used to it. And even then, it's easy to play golf in Haskell.
09:50:07 <Peaker> bscarlet, I was bit too many times by a typo that built and then failed at runtime
09:50:31 <Peaker> bscarlet, ideally we'd eliminate all unchecked sources of recursion we can and reason about the correctness of every recursion we introduce
09:50:50 <Peaker> (using an existing recursion which was already reasoned about is fine)
09:51:02 <Raydiation> its like learning OOP, took me a long time too
09:51:07 <dropdriv1> Are there reasonable/efficient ways to encode the fact that my function f that returns a Double will never return NaN?
09:51:18 <NihilistDandy> Learning Haskell actually made learning OOP a lot easier for me
09:51:30 <dropdriv1> NihilistDandy: Because you stopped?
09:51:44 <jfischoff> Peaker: I wonder if let rec could be added as an extension?
09:51:52 <haasn> dropdriv1: no
09:51:55 <tac> dropdriv1: Avoid floats maybe >__>
09:52:01 <NihilistDandy> dropdriv1: Haha
09:52:03 <haasn> dropdriv1: but you could return something other than Double
09:52:10 <dropdriv1> haasn: Such as?
09:52:20 <haasn> I don't know your requirements, Rational? Fixed?
09:52:28 <Peaker> jfischoff, hopefully
09:52:40 <mauke> Raydiation: what languages do you know?
09:52:58 <dropdriv1> Oh, I see.  I guess I really do want doubles.
09:53:02 <jfischoff> Peaker: I hope so too
09:53:54 <NihilistDandy> I'll be very impressed if there's much nontrivial float code that *never* returns NaN. Floats are icky
09:54:16 <Raydiation> mauke: C, C++, java, ruby, python, javascript, coffeescript, c#, php and some shell scripting
09:54:27 <bscarlet> Peaker: have you tried XQuery? The unpleasantness of XML aside, it's a fascinating example of a pure functional programming language that separates recursion (and with it, Turing completeness) from the rest of the language, yet offers a great deal of practical expressiveness in the no-recursion subset.
09:54:41 <dropdrive> NihilistDandy: I guess I was going for something more like "if you don't pass me a NaN, I won't return one"
09:54:53 <dropdrive> NihilistDandy: E.g. (+), etc.
09:54:58 <dropdrive> Oh wait.
09:55:06 <NihilistDandy> @faq Can Haskell replace C, C++, Java, Ruby, Python, Javascript, Coffeescript, C#, and PHP (and some shell scripting)?
09:55:06 <lambdabot> The answer is: Yes! Haskell can do that.
09:55:45 <dropdrive> NihilistDandy: What modules are typically used for shell scripting?
09:55:57 <mauke> Raydiation: some javascript and c# bits might transfer
09:56:17 <NihilistDandy> dropdrive: I think shelly's popular, though Tekmo's pipes work is starting to get very interesting
09:56:31 <Peaker> bscarlet, kind of like Agda with termination check?
09:56:50 <Raydiation> yeah linq or underscore :)
09:56:53 <dropdrive> NihilistDandy: pipes is applicable to general shell-scripting tasks?  You mean specifically for setting up pipes between stdout/err/in of different processes?
09:57:07 <bscarlet> Peaker: In some ways, I guess, but not really.
09:57:12 <mauke> Raydiation: I was thinking of XMLHttpRequest
09:57:32 <Raydiation> i usually use a wrapper for that, like $http in angular or $.ajax
09:58:05 <NihilistDandy> dropdrive: The new upstream pipes-safe stuff, I think, is what he uses
09:58:18 <NihilistDandy> For instance: https://github.com/Gabriel439/Haskell-DirStream-Library
09:59:13 <Peaker> is there a Control.Applicative equivalent of "guard"?
09:59:25 <NihilistDandy> There's some cool stuff being talked about on the mailing list, so I'd recommend subscribing
09:59:43 <mauke> Raydiation: the point is that all IO in Haskell is "async" in some sense
09:59:48 <Peaker> so much of Control.Monad is really Control.Applicative :(
10:00:03 <mauke> @src guard
10:00:03 <lambdabot> guard True  =  return ()
10:00:03 <lambdabot> guard False =  mzero
10:00:04 <Raydiation> mauke: you mean lazy?
10:00:16 <mauke> Raydiation: no, I mean working with callbacks
10:00:17 <NihilistDandy> I think they just need to finish one other part of the ecosystem to make serious pipes scripting a reality
10:02:48 <Peaker> @type \x -> if x then pure () else empty
10:02:49 <lambdabot> Alternative f => Bool -> f ()
10:04:56 <jlouis> lpsmith: the OTP patterns are quite good to have if your system needs to handle unforseen errors. It is also an interesting way to build concurrent software
10:09:06 <stepkut> is OverloadedStrings + ("foo" :: Text) any more efficient than just writing ((fromString "foo") :: Text) or (Text.pack "foo") ? Or do the same rewrite rules fire in each case? My impression is that they should all be the same
10:12:23 <mm_freak> is a derived Traversable instance always valid?
10:12:34 <bigs> stepkut: it is my understanding that it is purely as a matter of convenience
10:12:41 <bigs> that is, to say, they should be equal
10:12:45 <mm_freak> stepkut: they are equivalent
10:12:55 <bigs> mhm
10:13:27 <mm_freak> stepkut: just like "3 :: Rational" and "fromInteger (3 :: Integer) :: Rational" are equivalent
10:14:47 <stepkut> great. I've actually dug through the code deep enough to figure it out before, but then I couldn't remember if I confirmed on invalidated my theory :)
10:14:49 <haasn> stepkut: I'd be surprised if they don't compile to the exact same
10:14:52 <CaptainK> can't recall, but someone here had a link to where to use "do" properly
10:15:01 <CaptainK> anyone have url?
10:15:04 <haasn> considering fromString would be inlined to Text.pack either way
10:15:11 <stepkut> indeed
10:15:46 <stepkut> I can easily rationalized why they *ought* to all be the same -- but I am about to depend on that in a significant way, so I figured I should double check ;)
10:16:12 <Reite> Look at the IsString clas
10:16:13 <Reite> s
10:16:26 <mm_freak> well, i wish they wouldn't be the same =)
10:16:47 <mm_freak> sometimes i end up writing `where blah = "blubb"` for efficiency
10:17:04 <mm_freak> and then i can't use it in pattern matching
10:17:04 <stepkut> personally I hate OverloadedStrings as it is currently implemented
10:17:19 <haasn> stepkut: of course, you should be using "foo"^.packed
10:17:19 <mm_freak> yeah, i agreeâ€¦  i'm glad it's there, but it could be improved
10:17:20 <astor> when I install a new package with cabal from hackage, update the cabal file, and I'm in emacs w/haskell-mode and ghci.  How do I get ghci to find the new package?
10:17:27 <haasn> or unpacked # "foo" -- these days ;)
10:17:34 <stepkut> >:(
10:17:44 <mm_freak> haasn: how does that helkpp?
10:17:46 <mm_freak> help
10:17:52 <stepkut> I'm against these new fangled operators :p
10:17:54 <haasn> not in the slightest, but it's more hip and modern
10:18:06 <mm_freak> haasn: it's a step back actually
10:18:11 <mm_freak> you can't pattern-match using lenses
10:18:14 <stepkut> back in my day we didn't even have hierarchical modules and we liked it!
10:18:41 <mm_freak> i like lenses as they are currently defined, but i don't like them being overused so much =)
10:19:04 <haasn> you can pattern match with prisms.. sort of :D
10:19:32 <mm_freak> sort of
10:19:53 <mm_freak> it's not real pattern-matching
10:20:05 <mapreduce> How can I map 'head' across a list of possibly empty lists, getting either a list of heads or Maybes as the result?
10:20:06 <mm_freak> slower, no guards, no pattern guards, â€¦
10:20:13 <haasn> yeah true
10:20:24 <mm_freak> mapreduce:
10:20:39 <haasn> either way, in this case, the result is the exact same as using the regular â€˜packâ€™, so it's a pointless change either way
10:20:41 <mm_freak> :t foldr (const . Just) Nothing
10:20:43 <lambdabot> [a] -> Maybe a
10:21:00 <mm_freak> > map (foldr (const . Just) Nothing) ["blah", "blubb", ""]
10:21:01 <lambdabot>   [Just 'b',Just 'b',Nothing]
10:21:14 <mapreduce> foldr (const . Just) Nothing [[1], [], [2]]
10:21:23 <mapreduce> > foldr (const . Just) Nothing [[1], [], [2]]
10:21:24 <lambdabot>   Just [1]
10:21:31 <mm_freak> no, you need to `map` it
10:21:48 <mm_freak> you could call that fold 'safeHead'
10:21:52 <mapreduce> > map (foldr (const . Just) Nothing) [[1], [], [2]]
10:21:53 <lambdabot>   [Just 1,Nothing,Just 2]
10:22:59 <supki> :t toListOf (folded . to (^? _head))
10:23:00 <lambdabot>     Not in scope: `toListOf'
10:23:00 <lambdabot>     Perhaps you meant one of these:
10:23:00 <lambdabot>       `F.toList' (imported from Data.Foldable),
10:23:05 <supki> :(
10:23:13 <haasn> > map (preview _head) ["blah", "blubb", ""]
10:23:14 <lambdabot>   Not in scope: `preview'Not in scope: `_head'
10:23:14 <lambdabot>  Perhaps you meant one of thes...
10:23:18 <haasn> jeez
10:23:30 <mapreduce> > map (foldr (const . Just) Nothing) [[1], [], [2,3]]
10:23:32 <lambdabot>   [Just 1,Nothing,Just 2]
10:23:54 <mm_freak> > "abc" ^? _ix 0
10:23:55 <lambdabot>   Not in scope: `_ix'
10:23:55 <lambdabot>  Perhaps you meant `fix' (imported from Data.Function)N...
10:23:56 <mapreduce> I don't get why that gives the heads.
10:24:00 <mm_freak> > "abc" ^? at 0
10:24:01 <lambdabot>   Not in scope: `at'
10:24:02 <lambdabot>  Perhaps you meant one of these:
10:24:02 <lambdabot>    `a' (imported from D...
10:24:06 <mm_freak> > "abc" ^? _at 0
10:24:07 <lambdabot>   Not in scope: `_at'
10:24:07 <lambdabot>  Perhaps you meant `cat' (imported from Text.PrettyPrin...
10:24:14 <haasn> :t ix
10:24:14 <lambdabot>     Not in scope: `ix'
10:24:15 <lambdabot>     Perhaps you meant one of these:
10:24:15 <lambdabot>       `id' (imported from Data.Function),
10:24:17 <mm_freak> are they imported qualified?
10:24:20 <haasn> no idea
10:24:24 <lpsmith> jlouis, yeah I honestly like most things about the OTP design patterns,  and all in all I think my attempts to mimic them in Haskell has been pretty successful
10:24:28 <mm_freak> :t L.at
10:24:29 <lambdabot> Not in scope: `L.at'
10:24:29 <haasn> :t Control.Lens.At.ix
10:24:32 <lambdabot> (Control.Lens.Internal.Indexed.Indexable (Control.Lens.Each.Index m) p, Control.Lens.At.Ixed f m) => Control.Lens.Each.Index m -> p (Control.Lens.At.IxValue m) (f (Control.Lens.At.IxValue m)) -> m ->
10:24:32 <lambdabot>  f m
10:24:35 <haasn> oh god
10:24:45 <supki> they aren't imported
10:24:54 <lpsmith> jlouis, I really need proper supervision though,  instead of building ad-hoc "supervisors" into the processes themselves
10:25:08 <haasn> > ["foo", "bar", ""] & mapped %~ Control.Lens.Fold.preview Control.Lens.Cons._head
10:25:09 <lambdabot>   Not in scope: `mapped'
10:25:09 <lambdabot>  Perhaps you meant one of these:
10:25:09 <lambdabot>    `mappend' (impor...
10:25:20 <haasn> > ["foo", "bar", ""] & Control.Lens.Setter.mapped %~ Control.Lens.Fold.preview Control.Lens.Cons._head
10:25:21 <lambdabot>   Not in scope: `Control.Lens.Setter.mapped'Not in scope: `&'Not in scope: `C...
10:25:23 * haasn weeps
10:25:39 <mm_freak> mapreduce: foldr (\x y -> Just x) Nothing (x:xs) = (\x y -> Just x) x (foldr (\x y -> Just x) Nothing xs)
10:25:50 <lpsmith> jlouis, which has mostly consisted of a catch-all exception handler that will restart the process.
10:25:56 <mm_freak> mapreduce: (\x y -> Just x) x â€¦ = Just x
10:26:12 <lpsmith> Of course OTP's supervision trees enables more complex restart behaviors more easily
10:26:23 <elliott> you can @let import.
10:26:48 <elliott> mm_freak: you can do guards btw
10:26:53 <jeltsch> Is there something wrong with HackageDB? cabal upload doesn’t seem to work at the moment.
10:26:54 <supki> elliott: you can fix hashable :[
10:26:54 <elliott> just not with the same syntax of course
10:27:15 <mm_freak> elliott: well, sure, but it's really nothing like plain old haskell pattern matching =)
10:27:22 <elliott> supki: ok, ok, tonight.
10:27:30 <jeltsch> Okay, after one minute or so, uploading completed.
10:27:37 <jeltsch> Strange.
10:28:37 <haasn> mm_freak: â€œuncomposableâ€? ;)
10:28:50 <lpsmith> although, there is one small complication,  in that the exception handlers check an MVar for the state of the process,   and compares it's thread id to the ones that are currently running the process.   If they aren't equal,  then the handler does not restart the process.
10:28:51 <astor> how do I write a parsec parser that returns Either x y if I have a parser for x and a parser for y?  Sort of (try x) <|> y
10:29:25 <dolio> (Left <$> try x) <|> (Right <$> y)
10:29:32 <bigs> ya
10:29:43 <mm_freak> haasn: if you make everything composable, you can't work with the language anymore =)
10:30:03 * hackagebot fraction 0.1.0.2 - Fractions  http://hackage.haskell.org/package/fraction-0.1.0.2 (WolfgangJeltsch)
10:30:04 <mm_freak> haskell already excels at composability and i love it for that
10:30:32 <haasn> mm_freak: lens is the new language!
10:30:48 <astor> dolio: thanks!
10:31:21 <mm_freak> haasn: don't get me wrong, i use lenses
10:31:42 <mm_freak> but if all constructors are exposed, i don't see a reason to use prisms
10:32:08 <haasn> yeah I guess prisms are mainly there for when you want to match on something that isn't actually a constructor
10:32:08 <mm_freak> at least in the catch-all pattern matching case
10:32:14 <haasn> like viewing the ends of a Seq
10:32:19 <haasn> sure, we have view patterns for that
10:32:26 <haasn> but prisms do the job just as well (if not better due to composability)
10:32:55 <mm_freak> for traversing, yes
10:33:00 <haasn> but that doesn't mean we should stop providing prisms for constructors, again, for composability (and also the fact that prisms degenerate into traversals and whatnot that are still just as useful)
10:33:49 <dolio> has _Foo
10:33:50 <mm_freak> haasn: example:  maybe "<no number>" show
10:34:03 <mm_freak> would you really prefer prisms over that?
10:34:05 <elliott> the only reason to use pattern matching over prisms is when you're doing something very simple, or need complete coverage.
10:34:11 <elliott> the latter comes up often
10:34:15 <elliott> mm_freak: that's not what prisms are for.
10:34:16 <jlouis> lpsmith: indeed. You need to implement strategies for restarting groups of processes. Most of the stuff can be implemented with some correct async exception stuff
10:34:39 <mm_freak> elliott: i know
10:36:19 <haasn> mm_freak: well, there's no pattern match either there so I'm not sure what you're comparing
10:37:26 <mm_freak> haasn: \x -> case x of Just x -> show x; Nothing -> "<no number>"
10:37:35 <mm_freak> i just wrote it i terms of 'maybe'
10:37:42 <mm_freak> i folded =)
10:39:45 <haasn> viewing with prisms is sort of based on reducing it to a match with Maybe either way so I guess using prisms to match a Maybe in the first place isn't going to achieve an awful lot
10:39:47 <haasn> preview _Just = id
10:39:51 <haasn> :P
10:46:49 <NihilistDandy> I like when someone asks a question on SO that I care about within a couple of days of me starting to care about it
10:47:11 <haasn> are you sure said questions have not been asked all the time and you starting to care about them made you first notice them?
10:47:23 <pxqr> how to remove ghc-pkg db properly?
10:47:26 <NihilistDandy> Nah, this one's only from a few days ago
10:47:47 <haasn> yeah but maybe one gets asked every few days :P
10:47:49 <tylerkahn> hey guys. anyone know if there's a way to get typeclass-like functionality in Objective C?
10:48:03 <haasn> tylerkahn: ask the objective C guys?
10:48:08 <NihilistDandy> haasn: It's about ekmett's machines library. I don't think those questions get asked often :D
10:48:19 <haasn> and if objective C is any decent you could get away with manually passing around dictionaries
10:48:46 <tylerkahn> haasn, i have a feeling some people here have used objective C
10:48:59 <mekeor> pxqr: maybe just remove ~/.ghc ? O.o
10:49:04 <haasn> NihilistDandy: is the question â€œmachines looks cool and makes great theoretical sense but I have no idea how to use it in practiceâ€?
10:49:46 <NihilistDandy> haasn: Well, this particular one is, in brief, "RÃºnar's talkâ€¦ what?"
10:50:01 <NihilistDandy> But yeah, that is the ultimate information I am trying to gather
10:50:43 <NihilistDandy> I've basically switched to pipes wholesale, but I keep stumbling on machines and being really curious but having no idea how to even approach it
10:51:12 <haasn> I can make it work, but I always have to write tons of boilerplate to glue my machines together
10:51:31 <haasn> so that makes me think I keep doing something wrong
10:51:50 <astor> Why is there no parseFromFile for Text in parsec? It is for ByteString, lazy ByteString, and String.
10:53:18 <NihilistDandy> haasn: It seems like one of those libraries where I'll have to go and find out about the Scala implementation to find out anything about the Haskell one :D
10:53:57 <haasn> is that what you did for lens? =)
10:54:08 <acube> lens is documented pretty well
10:54:14 <mm_freak> pxqr: remove ~/.ghc to get rid of the package descriptions (all packages will appear as uninstalled after that)
10:54:20 <NihilistDandy> Lens is very well-documented, but lens also feels huge
10:54:27 <dolio> The haskell one predates the scala one, though.
10:54:34 <mm_freak> pxqr: to remove the packages themselves, do this:  rm -rf ~/.cabal/{bin,lib,setup-exe-cache,share}
10:54:35 <NihilistDandy> I'm quite intimidated by lens, but I've been trying to use it where appropriate
10:54:39 <haasn> yeah, but it's the only other ekmett library I know that has a direct scala equivalent
10:54:39 <dolio> And has fewer hacks.
10:54:48 <haasn> dolio: it's also much larger
10:55:19 <haasn> as far as I'm aware the scala version literally just has like traversals, lenses and getters/setters and only for the built-in collections
10:55:23 <supki> haasn: lens has scala equivalent?
10:55:27 <dolio> I mean machines.
10:55:30 <haasn> no profunctor prisms and stuff
10:55:33 <haasn> oh
10:55:40 <supki> I thought scala lenses were more like data-lens
10:55:50 <haasn> supki: equivalent would be the wrong phrase
10:55:55 <supki> ah
10:56:06 <haasn> â€œprojectionâ€
10:56:12 <supki> I almost become interested :[
10:56:42 <haasn> as far as I'm aware scala doesn't have a very interesting typesystem
10:56:43 <NihilistDandy> dolio: True, it predates it, but it seems like it gets discussed in the context of Scala more often (not that it's discussed often to begin with)
10:56:56 <dropdrive> So I'm trying to grok http://gergo.erdi.hu/blog/2012-12-01-static_analysis_with_applicatives/ but it's way too advanced for me.  What things should I read/learn as stepping stones on the path to enlightenment?  I suppose I understand Applicative functors, but not much more.
10:57:13 <mm_freak> scala's type system is the acme-* version of haskell's
10:57:23 <mm_freak> the whole language is acme-haskell
10:57:53 * haasn prefers acme-php
10:57:56 <mm_freak> it's an improvement over java, but that's it
10:58:03 <NihilistDandy> dropdrive: Do they really use Î± and Âµ in their code?
10:58:14 <dolio> That wasn't an invitation to rag on scala.
10:58:46 <haasn> oh, I just meant in the sense of â€œinteresting enough to support lens-lensesâ€
10:59:09 <haasn> as per supki's interest
10:59:33 <dolio> It doesn't have rank-n types, really.
10:59:41 <dolio> At least, not without encoding them as classes on a per-type basis.
11:00:21 <S11001001> dolio: actually, Miles did a thing to not do that, it's in scalaz
11:00:27 <dolio> Actually, I guess you can write a 'forall' class, because you can construct arbitrary type-level lambdas. But it isn't pleasant.
11:00:57 <mm_freak> sorry for raggingâ€¦  i just don't like how scala is often presented as "the practical haskell"â€¦  the last time i tried it my conclusion was that it's java with saner syntax and a type system, but nevertheless just java
11:00:59 <jfischoff> type-level lambdas? well that is cool
11:01:15 <dolio> jfischoff: Prepare to be surprised.
11:01:19 <jfischoff> haha
11:02:08 <johnw> dropdrive: that is indeed some pretty advanced stuff.  MarketRequest is just CoYoneda specialized on the MarketData type
11:02:11 <haasn> wait, does scala have something like â€œforall f. Functor f => f A -> f Bâ€ ?
11:02:29 <haasn> ie. parametric polymorphism with typeclass constraints
11:02:46 <dwcook> mm_freak, don't you know? Practical programmers use object-oriented design patterns to encapsulate their concerns in a user-friendly way.</facetious>
11:02:53 <dolio> It is possible; but not very nice.
11:03:06 <dropdrive> NihilistDandy: I think it's fancy characters and your browser is not set up right?
11:03:22 <dropdrive> johnw: That doesn't help ;)  What do you think could?
11:04:26 <mm_freak> dwcook: don't call OO patterns "user-friendly"â€¦  you have to get the word "business" inside there somewhere, because otherwise it sounds like what it really is:  bullshit
11:04:40 <dolio> S11001001: Not do what?
11:04:48 <dwcook> mm_freak, yes.
11:04:52 <johnw> dropdrive: Free looks like it's just an Applicative Sum too, unless I'm missing smoething
11:04:55 <NihilistDandy> dropdrive: I don't follow
11:05:07 <NihilistDandy> mm_freak: ENTERPRISE
11:05:11 <johnw> dropdrive: I'm not sure what would help.  there are a lot of things combining in this article
11:05:27 <johnw> dropdrive: what do you want to understand this article in particular?
11:05:53 <S11001001> dolio: write a new class for every value
11:06:00 <dolio> Oh.
11:06:17 <CaptainK> how do you make "TENET" from ["T","E","N","E","T"]
11:06:32 <NihilistDandy> CaptainK: concat
11:06:32 <haasn> concat . reverse
11:06:40 <dwcook> > concat ["T", "E", "N", "E", "T"]
11:06:41 <lambdabot>   "TENET"
11:06:48 <CaptainK> awesomeness
11:06:54 <mm_freak> comonad.com down?
11:06:56 <johnw> dropdrive: I meant, why?
11:06:58 <mekeor> haasn: ahahha â€“ irony?
11:07:00 <johnw> mm_freak: yes
11:07:05 <johnw> mm_freak: I have a mirror up, if it would help
11:07:18 <johnw> mm_freak: http://comonad.newartisans.com
11:07:53 <acube> johnw: awesome
11:07:53 <dropdrive> NihilistDandy: I don't see any ? in the code, or u.  I see mu and alpha
11:07:54 <dolio> comonad.com kept getting pwned.
11:08:06 <dolio> Probably by copumpkin's army of l33t h4x0rs.
11:08:11 <haasn> comonad.com can only be observed in CoIO
11:08:13 <haasn> aka OI
11:08:22 <NihilistDandy> dropdrive: Right, those are the characters I typed
11:08:23 <johnw> edwardk has a new machine for comonad.com, he just needs to find the time to migrate the data and services to it
11:08:32 <dropdrive> NihilistDandy: Oh, how embarrassing
11:08:43 <NihilistDandy> dropdrive: Seems your IRC client is the issue :P
11:08:52 <johnw> haasn: I was just reading an article about OI last night!
11:09:11 <dropdrive> johnw: I am enthralled by this possibility: "The implementation of this type will allow us to determine, without doing any actual computation, the list of dependencies"
11:09:11 <haasn> johnw: the one about free monads?
11:09:13 <jfischoff> huh me too
11:09:34 <johnw> haasn: no, this one was about modeling effects using comonads
11:09:41 <haasn> ah okay
11:09:47 <haasn> sounds interesting
11:10:15 <johnw> dropdrive: well, I'd start out by trying to adapt the code to your needs, and then asking questions here as you get stuck
11:10:51 <mm_freak> i'm looking for the comonad reader article on composing applicative functorsâ€¦  it might be interesting for dropdrive
11:11:00 <johnw> mm_freak: the Algebra of Applicatives?
11:11:05 <johnw> sadly, my mirror is too old for those articles
11:11:06 <johnw> BUT
11:11:07 <mm_freak> yeah, that sounds about right
11:11:08 <johnw> I have them in PDF format
11:11:09 <johnw> one sec
11:11:14 <lpsmith> jlouis, async exceptions are a bit of a bear though,   in that they do put a certain onus on the code that they are raised in
11:11:42 <mm_freak> what happened to comonad.com anyway?
11:11:53 <mm_freak> i notice that there is a (broken) kmett.com now
11:11:54 <haasn>  johnw â”‚ edwardk has a new machine for comonad.com, he just needs to find the time to migrate the data and services to it
11:12:16 <mm_freak> ah, ok
11:12:28 <dolio> It actually got exploited a few times. That wasn't a joke.
11:12:38 <dolio> (Outdated) Wordpress.
11:12:42 <johnw> mm_freak, dropdrive: Part 1: Abstracting with Applicatives (http://dl.dropbox.com/u/137615/Abstracting%20with%20Applicatives.pdf); Part 2: Algebras of Applicatives (http://dl.dropbox.com/u/137615/Algebras%20of%20Applicatives.pdf)
11:12:48 <mm_freak> are johnw and edwardk isomorphic?
11:12:51 <dolio> Presumably.
11:12:56 <johnw> dropdrive: those are excellent articles to read several times, they really helped me
11:12:56 <haasn> the hackers were clearly after edwardk's advanced supply of comonads and prisms
11:13:07 <johnw> mm_freak: I'm edwardk's forgetful functor
11:13:19 <johnw> we're just adjoint, not isomorphic
11:13:20 <haasn> this breach is believed to have set back computer science by about 30 years
11:13:35 <mm_freak> i see
11:13:45 <dropdrive> johnw: Thanks much!
11:14:33 <johnw> I've been glad more than once that I capture a PDF of every Haskell article I encounter
11:15:05 <mm_freak> yeah, i should do that
11:15:36 <dropdrive> johnw: You mean, from browser to PDF?  I find those PDFs to be kind of ugly
11:15:45 <johnw> I use an app called WebSnapper
11:15:51 <johnw> does the best job of anything else I've tried
11:15:53 <mm_freak> johnw: you could pick out those with a free license and publish them somewhere
11:16:03 <johnw> mm_freak: wow, too much work
11:16:19 <johnw> I presently have 1,462 PDFs
11:16:40 <mm_freak> wkhtmltopdf does close of a good job most of the time
11:16:51 <mm_freak> s/of/to/
11:17:55 <mm_freak> i should probably just snapshot every page i visit =)
11:17:59 <mm_freak> automatically that is
11:18:04 <johnw> mm_freak: I've done that before too
11:18:09 <johnw> but the signal/noise ratio drowns out the real data
11:18:25 <mm_freak> yeah, you could filter out most things
11:18:30 <johnw> and I don't want to spend any time curating; as it is I've fallen behind on categorizing the Haskell PDFs
11:19:12 <haasn> seems to me you could just tweak cache to your favor and cache the actual HTML instead of making a snapshot
11:19:14 <johnw> my workflow is: find article on web, capture, copy to iPad and archival database, read on iPad, delete
11:19:27 <johnw> haasn: actual HTML depends on too many resources sometimes
11:19:34 <johnw> like, articles that link to code in gists
11:19:43 <johnw> a PDF is faithfully "what I saw"
11:20:04 * hackagebot grapefruit-frp 0.1.0.4 - Functional Reactive Programming core  http://hackage.haskell.org/package/grapefruit-frp-0.1.0.4 (WolfgangJeltsch)
11:20:18 <haasn> I've been able to recover things more than once with firefox's offline mode and absurd cache size limitations; but it doesn't cache some content (stuff that updates frequently in particular), and also seems to delete whatever cached versions it had if I reload the page (and get a 404 or something), so it's not as useful as it could be =)
11:20:49 <johnw> i've also setup squid in the past and tweaked the settings to make it a permanent cache
11:21:00 <johnw> and there was some other proxy I used to use that collected everything into a browsable database
11:21:11 <johnw> but again, the information overload problem rendered it fairly useless
11:22:21 <haasn> well, firefox's cache does a good job of picking up relevant URLs from terms I enter
11:22:31 <mm_freak> grapefruit is maintained?!
11:22:48 <jeltsch> mm_freak: Yes! Why shouldn’t it? :-D
11:22:49 <ncs> can I have multiple checks in a case for a variable? for example something like if (x==foo || x==bar || x==fubar -> something) else (x==baz || x==biz || x==bizz -> something else) ?
11:22:53 <haasn> I use a URL cache instead of relying on bookmarks/favorites; I don't see a problem with picking out something specific from a large catch-all cache if you know what you're looking for
11:23:03 <haasn> off-topic here either way
11:23:30 <jeltsch> mm_freak: Actually, the story is a bit more complicated.
11:23:31 <mm_freak> jeltsch: i thought netwire and reactive-banana were pretty much the only active haskell FRP packages =)
11:23:32 <haasn> ncs: x `elem` [baz, biz, bizz]
11:23:36 <acube> ncs: Are your checks all boolean?
11:23:41 <haasn> mix that with guards or something
11:23:50 <acube> ncs: then you might use an if statement?
11:24:03 <ncs> no, they are Constructors
11:24:14 <jeltsch> mm_freak: There is Grapefruit 0.1, which just received an update. These updates are only small adaptions to make it work smoothlessly with newer GHCs and libraries.
11:24:34 <ncs> like I have data A = Foo | Bar | Fubar | Baz | Biz | Bizz
11:25:04 * hackagebot grapefruit-records 0.1.0.4 - A record system for Functional Reactive Programming  http://hackage.haskell.org/package/grapefruit-records-0.1.0.4 (WolfgangJeltsch)
11:25:06 * hackagebot grapefruit-ui 0.1.0.4 - Declarative user interface programming  http://hackage.haskell.org/package/grapefruit-ui-0.1.0.4 (WolfgangJeltsch)
11:25:08 * hackagebot grapefruit-ui-gtk 0.1.0.4 - GTK+-based backend for declarative user interface programming  http://hackage.haskell.org/package/grapefruit-ui-gtk-0.1.0.4 (WolfgangJeltsch)
11:25:10 * hackagebot grapefruit-examples 0.1.0.4 - Examples using the Grapefruit library  http://hackage.haskell.org/package/grapefruit-examples-0.1.0.4 (WolfgangJeltsch)
11:25:17 <jeltsch> mm_freak: However, I plan something new and fancy: Grapefruit 0.2. This will be an FRP implementation, which is quite different from Grapefruit 0.1 (and is written from scratch).
11:25:19 <acube> ncs: Then you can do: case x of { Foo -> something; Bar -> somethingElse; Biz -> ... }
11:25:37 <ncs> there is no way of grouping them huh? too much labor.. :(
11:26:03 <bscarlet> ncs: probably best to put the shared body in a function (defined in a where clause) and call it from each case
11:26:14 <jeltsch> mm_freak: Grapefruit 0.2 will be based on my research about categorical semantics of FRP and the connection between FRP and temporal logic. As a result, its interface should be much more reasonable (and will be more powerful).
11:26:34 <ncs> yes, i just wanted to avoid having 4 cases doing the same thing.. thanks anyways!
11:28:12 <bscarlet> ncs: if A is an instance of Eq, you could also do case a of _ | a == Foo || a == Bar -> thing, ...
11:30:38 <johnw> jeltsch: I'm interested to see what you come up with
11:32:25 <applicative> ncs if the four cases that do the same can come after the ones that don't then of course you can just call them all x or _ or whatever
11:37:01 <jeltsch> johnw: Nice to hear that. It will take some months until I have something to present.
11:37:28 <johnw> from what I've been hearing, there seems to be a need for a more capable FRP library for Haskell
11:37:40 <johnw> or maybe the existing ones just need better docs and examples, I'm not sure
11:37:58 <johnw>  but if you can come up with something that knocks our socks off, I'm sure it would be pretty popular
11:39:03 <jeltsch> johnw: Okay, let’s see. :-)
11:39:24 <johnw> interesting, your client seems to be sending iso-latin-1 bytes directly to the server
11:39:33 <johnw> rather than encoding them
11:39:34 <elliott> jeltsch: I like "smoothlessly" :)
11:39:43 <mapreduce> I have a file Diff.hs, with some functions in it, one named mergeDiffs.  If I do :load Diff or :load Diff.hs, there are no errors, my main function is available but mergeDiffs is not.
11:39:49 <mapreduce> What am I missing?
11:39:58 <lispy> import?
11:40:04 <elliott> mapreduce: it defaults to mdoule Main (main) where by default
11:40:06 <elliott> try module Diff where
11:40:08 <elliott> at the top of your file
11:40:50 <jeltsch> elliott: I really don’t know why I came up with this word. Now that I think about it, it looks pretty stupid. :-D
11:41:10 <johnw> I think you mean seamlessly?
11:41:14 <mapreduce> elliott: That's done the trick, thank you.
11:41:45 <jeltsch> johnw, elliott: I think I meant “smoothly”.
11:41:51 <johnw> hi
11:41:58 <elliott> I much prefer "smoothlessly".
11:42:08 <elliott> mapreduce: :)
11:59:43 <wereSomething> why am I getting this error? http://hpaste.org/90528
12:00:18 <NihilistDandy> wereSomething: 4.5.6.8
12:00:23 <wereSomething> no
12:00:31 <arkeet> wereSomething: simple. you asked for a version that doesn't exist on hackage
12:00:33 <NihilistDandy> Does that version exist?
12:00:34 <geekosaur> looks to me like you typoed
12:00:49 <NihilistDandy> It should be 4.6.8
12:00:59 <wereSomething> yep
12:01:03 <geekosaur> requested regex-pcre-builtin-0.94.4.5.6.8.31 but you have one more element in there then all the versions it found on hackage
12:05:05 <applicative> wereSomething: mine is    regex-pcre-builtin-0.94.4.6.8.31
12:05:34 <wereSomething> 0.94.4.6.8.31 is buggy, I need the earlier version
12:06:49 <wereSomething> can I have multiple remote-repo: lines in my cabal config file?
12:17:11 <elliott> that's one long version number
12:18:11 <tomboy65> it's still <v1
12:18:27 <tomboy65> so way superior to chrome's/firefox's versioning scheme
12:18:52 <geekosaur> wereSomething, so fi you need an earlier version, pick one that cabal knows about. the one you specified is not valid
12:19:07 <geekosaur> maybe you meant 0.94.4.5.8.31
12:19:48 <b52> why do have haddock export list header annotations have to start with an alpha character? something like module  ( -- * 1. aba .. results in a parse error, it works once i remove the leading numbers
12:25:05 * hackagebot fb 0.14.7 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.14.7 (FelipeLessa)
12:28:41 <astor> I just saw that old-locale:defaultTimeLocale defines dateFmt = "%m/%d/%y".  What kind of crazy definition is that?
12:29:48 <Pie314> hello. why isnâ€™t (>>=) :: (a -> m a) -> (b -> m b) -> m b?
12:31:06 <astor> Pie314: The first function must return 'm b' in order to have a 'b' to feed into the second parameter.
12:31:29 <Pie314> oh, I meant (a -> m a) -> (a -> m b) -> m b
12:31:40 <Lethalman> :t return
12:31:41 <lambdabot> Monad m => a -> m a
12:31:44 <Cale> Pie314: that would also be impossible
12:32:13 <Lethalman> Cale, mh why
12:32:33 <Pie314> Cale: why isnâ€™t it that way? somebody told me that I can think of bind as the composition of two functions that return a monadic value, so why isnâ€™t it symmetric?
12:32:45 <Lethalman> :t \f g -> do x <- f; y <- g x; return y
12:32:45 <lambdabot> Monad m => m t -> (t -> m b) -> m b
12:32:55 <Cale> (a -> m a) -> (a -> m b) -> m b -- a function of this type cannot apply either of its function parameters
12:33:04 <Lethalman> :t \f g z -> do x <- f z; y <- g x; return y
12:33:04 <acube> Pie314: there is >=> which is symmetric
12:33:05 <lambdabot> Monad m => (t1 -> m t) -> (t -> m b) -> t1 -> m b
12:33:10 <acube> :t (>=>)
12:33:11 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
12:33:15 <Lethalman> acube, right :P
12:33:16 <Cale> because it hasn't been given a value of type a
12:33:28 <Cale> and so it can't produce a result of type m b which is defined
12:33:32 <Lethalman> oh yes, missing -> a ->
12:34:46 <Lethalman> so I have installed llvm, but still get: http://paste.debian.net/13021/
12:34:59 <Lethalman> oh maybe cabal install llvm ?
12:35:06 * hackagebot fb 0.14.7.1 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.14.7.1 (FelipeLessa)
12:38:35 <bscarlet> Lethalman: Dunno how that package does it, but llvm-general finds LLVM by trying to run the llvm-config binary. Is it on your path?
12:38:56 <Lethalman> it is
12:39:53 <bscarlet> Lethalman: Hmph. Dunno, then.
12:39:59 <Lethalman> :'-(
12:40:02 <Cale> Pie314: In general, x >>= f is the action which first runs the action x, obtaining some result v, and then runs the action f v. The meaning of "runs" and "and then" depend on the specific monad :)
12:40:14 <elliott> as does "some" :)
12:40:29 <Cale> and indeed, the meaning of "action"
12:40:31 <Cale> :D
12:40:36 <elliott> also "first"!
12:41:10 <Cale> But it's a reasonable way to think about what's taking place despite these qualifications!
12:41:56 <Cale> For instance, in the list monad, to "run" a list means to pick an element from it in all possible ways.
12:41:59 <Cale> > [1,2,3] >>= (\x -> [x, 10*x])
12:42:00 <lambdabot>   [1,10,2,20,3,30]
12:42:30 <Cale> Here, x is bound to each element of [1,2,3] in turn, and the results collected into a single list
12:42:30 <acube> How does TypeFamilies change if my code compiles or not? (It fails to compile when I enable it)
12:42:54 <Pie314> Cale: why isnâ€™t it [10, 20, 30]?
12:43:09 <haasn> > Just 3 >>= (\x -> Just (x*10)) >>= (\x -> Just (x+5))
12:43:10 <lambdabot>   Just 35
12:43:13 <haasn> > Nothing >>= (\x -> Just (x*10)) >>= (\x -> Just (x+5))
12:43:14 <lambdabot>   Nothing
12:43:16 <Cale> Pie314: Because for each x, we're producing the results x and 10*x
12:43:28 <acube> I get a lot of Ambiguous type errors when enabling type families
12:43:36 <mapreduce> I have a where minimum = some expression that I think should be of type a, but when I do :: a at the end I get an error message I can't understand beginning with 'Could not deducate (a2 ~ (a, b))'
12:43:41 <Cale> acube: It's really hard for anyone to guess what your code is.
12:43:48 <mapreduce> Is there a way I can see what type ghc thinks minimum is?
12:44:17 <mapreduce> s/deducate/deduce/
12:44:54 <acube> Cale: I knew that would come, the code depends on a lot of other things in the project, would have to simplify it first. I thought that maybe there is a general overview over how type families change valid code into invalid code
12:44:56 <Cale> mapreduce: write   data Void   and then give it a type signature Void. The error message will indicate what type GHC actually thinks the expression has.
12:45:11 <Cale> mapreduce: Or just use any other type which it couldn't possibly be
12:45:57 <mapreduce> That seems to have helped, I now see Couldn't match expected type `Void` with actual type `(a, b)`
12:46:02 <mapreduce> now to see why it's that..
12:46:03 <Cale> acube: Maybe at least post the error messages and the code around the lines which they refer to?
12:46:04 <Pie314> Cale: when I write this into GHCI I get an error. do I somehow import the Monad instance for List?
12:47:02 <Cale> Pie314: what exactly are you typing into GHCi and what error are you getting?
12:47:15 <Cale> Pie314: you don't need to import anything to get the list monad
12:47:25 <Lethalman> bscarlet, from a strace cabal install dph-examples I get only the following: read(7, "llvm -any\ndph-examples -any\nshel"..., 32752) = 430
12:48:12 <Pie314> Cale: got it, I wasnâ€™t aware of the fact that the result of this lambda expression is wrapped in a list.
12:49:22 <Pie314> is this the only way a List can be an instance of Monad?
12:49:23 <Cale> Pie314: Right, because in this case, (>>=) :: [a] -> (a -> [b]) -> [b]
12:49:32 <bscarlet> Lethalman: Have you installed the llvm package? That looks like you might need to.
12:49:35 <Pie314> oh I see
12:49:43 <Lethalman> bscarlet, I did
12:49:51 <Lethalman> and it was installed successfully
12:50:24 <Lethalman> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell#Running_DPH_programs doesn't mention llvm
12:51:32 <acube> http://hpaste.org/90529 is a snippet that shows the problem
12:51:53 <acube> try to uncomment the line with the TypeFamilies language pragma, and the code fails to compile with 5 errors
12:51:55 <S_J> is there really no bluetooth lib for haskell?
12:52:00 <Lethalman> ah ok
12:52:32 <Lethalman> I fear it's about versionin
12:52:36 <johnw> S_J: my guess is that anyone who really needed that would FFI bind to a C library
12:52:45 <Lethalman> "Couldn't execute opt-3.0" but opt --version is 3.2 :S
12:53:07 <wereSomething> Is there a way to have cabal print the dependency tree? I want to know which package(s) exactly pull in regex-pcre-builtin
12:53:53 <xico> that would be so nice
12:54:26 <wereSomething> I once wrote a custom Setup.hs to do that...
12:54:35 <acube> Cale: I've posted the errors and the code on
12:54:37 <acube> http://hpaste.org/90529
12:54:38 <Lethalman> which is probably something to do with -fllvm in the ghc options
12:54:50 <Lethalman> ok got it
12:54:55 <Lethalman> ghc -fllvm needs opt-3.0
12:55:09 <Lethalman> I have ghc 7.6.3, is that old perhaps?
12:56:31 <Lethalman> http://hackage.haskell.org/trac/ghc/ticket/7589 :-( let's install llvm 3.0 :-)
12:57:52 <Lethalman> also why would you use -fllvm instead of the ghc codegen?
12:58:17 <Lethalman> some features are implemented with the llvm backend rather than the ghc codegen?
12:58:53 <Cale> acube: very interesting
12:59:59 <bscarlet> System.Environment.lookupEnv appeared in base in 4.6.0.0. Is there a way for me to find out if it existed somewhere else before that?
13:04:34 <tommd> bscarlet: Fromt he release notes, it seems you should just be able to use getEnv and an exception handler.
13:04:38 <NihilistDandy> bscarlet: It didn't exist in 4.5.1.0
13:04:54 <NihilistDandy> Oh, duh, you said that
13:05:43 <NihilistDandy> I think that was the first time. I scanned the last few major version of base and didn't see it
13:08:10 <bscarlet> Thanks.
13:08:37 <acube> Cale: If got it to work by adding a few explicit type annotations to the where bindings (using ScopedTypeVariables)
13:09:02 <danil> acube: the same thing happens if you turn on GADTs instead of TypeFamilies; it looks like the local definitions of f' in gshowQ and slist in tshow aren't being generalized
13:09:35 <Cale> ohhhhhh
13:09:36 <Cale> right
13:10:06 * hackagebot llvm-general 3.2.0.6 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.0.6 (BenjaminScarlet)
13:10:08 * hackagebot llvm-general 3.3.0.4 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.0.4 (BenjaminScarlet)
13:10:11 <Cale> Yeah, it's the (kind of sad) "let isn't generalised" thing being turned on with the new type system extensions.
13:10:27 <Lethalman> so I'm running dph-spectral-quicksort but it seems to use only one CPU
13:10:32 <S_J> can quickcheck be used for other languages with out modification? (im not askin about the concept which obv can be reused, im talking about literally using a quickcheck binary with another language.)
13:10:49 <Cale> If you want let/where bound things to have polymorphic types, you have to write their signatures now.
13:11:05 <neutrino> since when?
13:11:08 <acube> And you can't turn it off with NoMonomorphismRestriction :(
13:11:17 <Cale> S_J: ...
13:11:25 <Cale> S_J: QuickCheck is a Haskell library
13:11:32 <geekosaur> NoMonoLocalBinds?
13:11:32 <Cale> It's not a binary
13:11:46 <danil> neutrino, acube: http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/let-gen.pdf has the reasoning, though I didn't realize it was already in force
13:12:11 <neutrino> danil: since when is it the casE?
13:12:50 <Cale> Yeah, NoMonoLocalBinds fixes it
13:13:01 <acube> Hmm, not for me
13:13:31 <Cale> hmm
13:13:34 <Cale> which GHC?
13:13:42 <Cale> I'm using 7.6.3
13:13:54 <neutrino> oh i see
13:13:55 <neutrino> well
13:13:56 <acube> I'm too
13:13:57 <geekosaur> I don't recall when it became default, one of the 7.6s
13:14:00 <neutrino> i agree with the author.
13:14:04 <neutrino> it's not something i'm missing.
13:14:13 <geekosaur> I think
13:14:16 <neutrino> it's not something i ever used.
13:14:26 <neutrino> do you guys find it was a crucial feature?
13:14:28 <neutrino> and why?
13:15:07 <Cale> neutrino: You're referring to let generalisation?
13:15:30 <acube> Cale: turning on NoMonoLocalBinds does not fix it for me
13:15:40 <acube> GHC 7.6.3
13:15:53 <Cale> acube: I don't know why... Maybe try recopying the thing you pasted and just adding the pragma?
13:16:02 <acube> Cale: I did
13:16:03 <Cale> acube: (Has anything else changed?)
13:16:05 <Cale> hmm
13:16:30 <Cale> http://hpaste.org/90535
13:16:33 <acube> And you're sure that in your version, when you remove the pragma, it fails to compile?
13:16:38 <Cale> yes
13:16:48 <acube> hmm, that is weird
13:16:53 <PrO_OkI_______> i just leave this here:
13:16:55 <PrO_OkI_______> http://www.youtube.com/watch?v=cyyDmQKcHMs
13:17:05 <danil> I'm on 7.4 and I get the same thing as Cale
13:17:30 <PrO_OkI_______> FP Haskell Center Demo: develop & deploy in Haskell
13:17:35 <Moggle_> this is probably the wrong place to ask it, but is learning vim/emacs really worth it?
13:17:53 <PrO_OkI_______> vim better in my opinion with tmux
13:18:57 <Cale> Moggle_: sometimes... tbh, I think with Haskell specifically, none of the editors are really any better than any other, so long as an editor can convert tabs to spaces and maybe do a little syntax highlighting, I'm fine with anything
13:19:08 <Cale> Moggle_: but that said, I tend to use vim
13:19:22 <Cale> and in the past, I've used emacs for significant amounts of time
13:19:39 <PrO_OkI_______> use this http://haskelllive.com/environment.html thank me later
13:19:48 <xplat> Philippa_: if you're still wondering, idris lets you write a function to take the value all apart and reconstruct it again, and then optimizes uses of that function into (basically) unsafeCoerce (only it's not unsafe because you've proved you could do it the hard way)
13:19:52 <Cale> But I haven't put much effort into it, and I don't see that effort as being very worthwhile.
13:20:51 <acube> I like the syntax highlighting and identation in emacs better
13:20:56 <acube> more colerful :P
13:20:56 <Cale> A small fraction of the time you spend programming will typically be spent on actual typing, and so I don't see optimising that process as particularly necessary.
13:21:25 <acube> Also, undo-tree
13:21:30 <Cale> But that's very language-dependent ;)
13:21:42 <Moggle_> Cale: That sounds very sensible
13:21:47 <Cale> To the extent that programming in some languages is practically intolerable without special support.
13:22:06 <Moggle_> automatic syntax error highlighting is nice though
13:22:09 <acube> What languages? Lisp?
13:22:15 <Moggle_> hum perhaps there are plugins for gedit/geanie for that.
13:22:19 <PrO_OkI_______> leksah ide
13:22:30 <acube> hdevtools and custom checkers do fine
13:22:55 <acube> (in emacs)
13:23:24 <luite> it would be nice if hdevtools and similar stuff worked easily on remote systems or virtual machines
13:23:44 <johnw> luite: I'd just be happy if it worked with hsenv
13:24:03 <PrO_OkI_______> u could ssh into the remote box and use it there
13:24:09 <acube> luite: how do you mean that? Why shouldn't they work on virtual machines?
13:24:09 <PrO_OkI_______> via putty
13:24:30 <luite> PrO_OkI_______: then i'd have to run vim on the machine, i like using a local editor, editing remote files
13:24:46 <johnw> actually, if you use ssh to make a local tunnel, using hdevtools remotely shouldn't be too awful; I think it just uses a regular TCP socket, and not a UNIX domain socket
13:24:58 <b52> dic
13:25:00 <johnw> but I could be wrong
13:25:09 <acube> hdevtools uses an unix socket
13:25:11 <luite> johnw: it uses a unix socket
13:25:17 <johnw> ah, n/m then
13:25:19 <levi> Powerful editors are most handy not when you're typing in the code, but when you need to make sweeping changes to the code.
13:25:39 <johnw> luite: can't you use socat to redirect a TCP socket to a unix socket on a remote machine?
13:25:42 <PrO_OkI_______> i use a similar idea like this
13:25:43 <PrO_OkI_______> https://www.fpcomplete.com/page/haskell-eval-vm
13:25:49 <Cale> I like a lot of the stuff that the guys at FPComplete do, but something about the way that they sell Haskell frequently rubs me the wrong way somehow.
13:25:55 <johnw> i guess you'd need socat on both sides: unix -> tcp -> tcp -> unix
13:26:03 <luite> johnw: would probably be easier to patch hdevtools a bit :)
13:26:09 <johnw> Cale: how so?
13:26:40 <luite> they sell it a lot though, i've seen the same case studies a few times now ;)
13:27:08 <Cale> It's not quite buzzwords exactly, but it's that kind of thing? I'm not quite sure exactly what it is.
13:27:24 <johnw> you mean, marketing people are involved rather than technical people? :)
13:27:28 <Cale> yes
13:27:32 <PrO_OkI_______> yep
13:27:32 <jfischoff> I think it is jarring to hear Haskell get mentioned with buzzwords.
13:27:34 <Cale> Marketing speak
13:27:34 <johnw> don't see how to avoid that really
13:27:35 <elliott> I found their introduction video poor.
13:27:42 <elliott> not just for marketingspeak reasons.
13:27:44 <Cale> I dislike marketing speak very much.
13:27:49 <elliott> admittedly I stopped watching half-way through
13:27:51 <luite> but only fpcomplete lets you deploy your haskell in the cloud
13:28:10 <acube> The introduction video was boring
13:28:11 <PrO_OkI_______> i kust post it for the info nothing else
13:28:16 <PrO_OkI_______> *just
13:29:06 <luite> hmm, i hadn't seen the video yet
13:29:20 <luite> what, gravity-fun? the didn't steal my balls, did they?
13:29:42 <luite> ah no it's more boring :p
13:29:52 <Cale> Also, I guess there's a bit of a philosophical difference, in that I don't think Haskell really needs to be *sold*, in that it's good enough to stand on its own technical merit. You shouldn't have to put fluffy words around it to make it sound any better?
13:29:58 <johnw> Cale: we are trying to attract legions of Java-numb managers to allow their engineers to start doing stuff in Haskell, and I think marketing speak may actually reach those people better than what excites the engineers (who may have already been wanting to use Haskell for a long time but could never "sell" it)
13:30:26 <johnw> that's a hugely different audience than what would interest or attract #haskell
13:30:57 <johnw> I mean, no one here needs to be sold on anything, you'd rather just have a raw API to our deployment platform and shut up about the rest ;)
13:31:05 <Cale> Well, and if it really is better as we think, then companies who use it should eventually outdo those who don't?
13:31:32 <Ralith> there are an immense number of confounding factors in software dev
13:31:35 <luite> johnw: are you going to offer certified haskell engineer certifications? the world really needs that
13:31:41 <johnw> Cale: yeah, but look at C++ and its uptake vs. so many other better technologies that have existed for decades
13:31:51 <johnw> luite: don't tempt me! hahaha
13:32:11 <jfischoff> I guess the reality is disappointing. I would wish that FP complete was making tools for haskell exisiting Haskell shops .. but that is too small of a market I guess
13:32:16 <Ralith> johnw: are you associated with fpcomplete?
13:32:18 <Cale> johnw: C++ actually does have certain advantages over Haskell. They aren't technical ones, but sociological.
13:32:21 <johnw> Ralith: yes
13:32:59 <Cale> i.e. lots of people already "know" (at least to some extent, however minor), the language, or something similar to it
13:33:17 <luite> johnw: does the fpcomplete ide have an easy repl?
13:33:31 <johnw> luite: funny you should ask that, chrisdone is looking into that kind of stuff as we speak :)
13:33:39 <S_J> How does quickCheck test edge cases specifically, how nwould it know what an edge case is?
13:33:49 <Cale> (In the case of C++, I don't think anyone actually knows C++ properly, Stroustrup included.)
13:34:04 <luite> johnw: <a href="http://tryhaskell.org">repl</a>
13:34:04 <acube> If there only was a repl for C++
13:34:43 <haasn> isn't there?
13:35:04 <johnw> S_J: quickCheck has no knowledge of "edge cases", as that would imply interpreting the meaning of values; it just generates random values for any given type, although you can use a specific generator to test for a particular range
13:35:06 <Ralith> I know of two or three
13:35:11 <Ralith> geordi's my usual one
13:35:12 <luite> http://weblog.luite.com/wordpress/?p=127  <- I have a new weblog post btw, reactive stuff with GHCJS and sodium :)
13:35:48 <johnw> Cale: having spent many years on the C++ Committee, I can tell you that almost no one on it truly understands the whole language; people just specialize in their area and make friends with everyone who knows the parts they don't
13:35:55 <Cale> S_J: It doesn't exhaustively test edge cases, but it has a notion of "size" (which is type-dependent) and generates tests of increasing size, and then once it finds a counterexample, it does another type-dependent process of "shrinking" to try to find a simpler one.
13:36:21 <jfischoff> luite: ooh you can run the examplesâ€¦ is that new?
13:36:59 <luite> jfischoff: i added some script yeah. unfortunately you cannot edit the code and recompile... yet. but that should work in ~2 months or so
13:37:26 <jfischoff> still very cool.
13:37:51 <Cale> johnw: Yeah, so that's a black mark on it, but on the other hand, you have a *lot* of people who know a little bit of C++, enough perhaps to get work done. I can see why businesses value that. At the same time, I think referentially transparent by default functional programming is inevitable.
13:38:23 <luite> jfischoff: notdan is helping with that this GSoC, i had much of the low level things working already, but got distracted by GHCJS work :)
13:38:27 <Moggle_> Cale: 'inevitable' seems like a rather strong word, why do you feel that way?
13:38:36 <johnw> Cale: I was thinking more about the beginning of C++, and how it beat out something like Common Lisp or Smalltalk which had much better development environments at the time
13:39:25 <lispy> it's funny what does and does not drive language adoption
13:39:27 <johnw> in fact, after I learned Common Lisp, my first reaction was, "How the hell does C++ even exist when there was something like this in the 80s with even dedicated hardware built around it?"  C++ is so much more work
13:39:31 <johnw> lispy: exactly
13:39:45 <lispy> Perception, trust, and familiarity are very important.
13:40:11 <jfischoff> luite: How could one hook up diagrams?
13:40:22 <johnw> I would say that marketers address perception almost exclusively, which may be what makes their message sound strangely hollow to those who prefer substance
13:40:22 <Cale> Moggle_: Largely because of the increasing need to take advantage of parallelism, and the fact that starting out from an imperative language in which things are mutable by default is like firing the starting gun of the race into your foot.
13:40:44 <luite> jfischoff: diagrams render client side with diagrams-ghcjs, on a canvas. for static diagrams, server-side with a png is acceptable
13:40:48 <johnw> Cale: lol
13:41:00 <jfischoff> luite: killer
13:41:04 <luite> for non-static, for example charts with some input, js would work
13:41:04 <Cale> You're starting out from the case where it's unsafe to execute things in parallel by default, and heroism is required to prove that it's actually okay
13:41:22 <elliott> I don't think FP is inevitable.
13:41:39 <elliott> I assume the world will settle on something much worse than Haskell.
13:41:47 <lispy> johnw: I was told by an IBM fellow once (meaning, he was in the industry working during that time), that because people thought AT&T was creating/endorsing C++ it really helped drive adoption. You can see a similar thing with .NET.
13:41:52 <Cale> Whereas in a functional programming language like Haskell, it's safe to evaluate things in parallel by default, and the hard part is figuring out when it's worthwhile, and arranging the algorithm so that it can be done in a balanced fashion.
13:41:59 <jfischoff> elliott: oh?
13:42:06 <luite> jfischoff: it's more or less what i've been planning for a long time, editable code with these things on a wiki. i used to have the code run server side, but wasn't satisfied with the results, you can't really have fun interactive things like the balls examples that way
13:42:07 <johnw> elliott: at the very least, I think the world would be happy to delay its rampant success for 50 more years if we just hope that "betterness wins"
13:42:24 * jfischoff nods
13:42:35 <elliott> jfischoff: has there ever been a time in the past where the world settled on a programming language that wasn't seriously suboptimal compared to other existing languages in some ways?
13:42:43 <Cale> johnw: I'm also very selfish, I guess. I'm happy enough that Haskell exists for my own use ;)
13:42:54 <elliott> johnw: well, also I don't think success would necessarily be beneficial for Haskell.
13:43:00 <Cale> and there are aspects of its popularity which have downsides
13:43:01 <johnw> Cale: I can completely symathize
13:43:11 <elliott> success begats success at all costs, and success at all costs leads to a worse language.
13:43:21 <jfischoff> elliott: sure but that doesn't mean the world won't end up using as bad Haskell ;)
13:43:30 <Cale> In fact, it's already getting to the point where I feel attracted to other less popular languages, but there's nothing quite yet to take its place :)
13:43:50 <johnw> Cale: I also dread the day when legions of Java developers start wanting to add impurities to Haskell in odd places simply because it eases adoption in their environments, and we'll have to keep saying, "No, no and no", strongly enough to stop it from happening.
13:43:57 <elliott> I also sort of feel like starting from now, by the time Haskell could get truly popularised it would already be obsoleted, by Idris or the like.
13:43:59 <Cale> If someone builds a lazy implementation of a practical language whose type system is founded in HoTT, then I'll probably switch :)
13:44:04 <johnw> also, I hope there is never an ANSI Haskell
13:44:10 <johnw> i've seen what committees can do :(
13:44:10 <jfischoff> I guess because I have been working at companies that use Haskell and are open to it I don't think it is far fetched
13:44:19 <tomboy65> okay, what is incorrect here? tier1 (x:xs) (a:b:c:ys) (d:e:f:zs) = if x == 0
13:44:20 <elliott> and I'm perfectly happy to jump ship, Haskell is very much a stepping stone for me, its long-term inadequacy seems clear at this point.
13:44:21 <tomboy65>                                 then (x, [], []):tier1 xs b:c:ys e:f:zs
13:44:23 <tomboy65>                                 else (x, [a,b,c], [d,e,f]):tier1 xs b:c:ys e:f:zs
13:44:30 <elliott> tomboy65: please use hpaste for more than a couple of lines :)
13:44:32 <johnw> Cale: that sounds like such a beautiful thing to dream for!
13:44:37 <jfischoff> elliott: oh I agree with that
13:44:50 <tomboy65> elliott: i found 3 lines acceptable. but i will do that.
13:44:59 <johnw> elliott: true, as soon as Haskell gets too popular, we'll all jump to another language that people have too much trouble understanding to bother with :)
13:45:22 <elliott> tomboy65: well, I didn't know how many lines it would be when I said that :)
13:45:31 <Cale> I want the language that I'm using to be improving
13:45:42 <Cale> and languages that see a lot of use tend to have a hard time improving
13:45:51 <Cale> because everyone starts to complain about compatibility
13:46:11 <carter> johnw I have funny opinions on commercial haskell
13:46:23 <johnw> Cale: although, C++ has made a lot of huge changes recently, which was surprising to me given its tradition of backwards compatibility
13:46:33 <elliott> Cale: don't worry. I promise to ignore everyone else if I ever make a language.
13:46:35 <tomboy65> and it says that the types do not match. expected type: (t0, [a0], [a1]), actual type `[t1] -> [(t0, [a0], [a1])]' ...
13:46:41 <carter> though said opinions wont' have teeth for another month or so
13:46:54 <elliott> tomboy65: you seem to need parens around your recursive list arguments there
13:47:02 <elliott> function application binds tighter than anything else
13:47:11 <tomboy65> heh
13:47:13 <tomboy65> okay
13:47:15 <tomboy65> let's see
13:47:53 <tomboy65> that did it, thanks elliott
13:48:05 <chrisdone> elliott: i reckon you could make that statement about any language really, as a healthy practice. being satisfied is the best way to stagnate, i'm naturally dissatisfied with everything i use because history teaches that there's always something better that you just haven't seen yet
13:48:34 <Ralith> elliott: there was a time when there was only one language, no?
13:48:39 <Ralith> oops, was scrolled up
13:48:47 <b2coutts> surely there are some bleeding-edge languages that aren't so concerned with stability?
13:49:04 <elliott> Ralith: yes, that was the answer I was expecting :)
13:49:06 <carter> b2coutts Rust changes its type system every month
13:49:12 <elliott> chrisdone: agreed
13:49:52 <elliott> chrisdone: but, I'm more interested in being just behind the cutting edge, rather than picking one point and thinking about popularising it.
13:49:59 <Moggle_> I don't think I've ever used a language with a type system as nice as Haskell's, are there any other languages with really nice ones?
13:50:23 <Ralith> elliott: corrolary being that then someone invented an inferior language, and everyone immediately switched. ^^
13:50:25 <chrisdone> elliott: yeah, that's a proper distinction
13:50:27 <johnw> Moggle_: idris is very cool
13:50:38 <Moggle_> johnw: Thanks! I'll look into that
13:50:41 <ion> @ is pretty awesome.
13:50:44 <johnw> Moggle_: and HoTT looks extremely interesting
13:50:47 <NihilistDandy> b2coutts: Rust, I guess
13:50:48 <tromp_> yes Moggie but they all tend to be Haskell derivates
13:50:49 <carter> Hott looks neat
13:50:50 <chrisdone> Moggle_: Ur is also interesting
13:51:17 <ion> Ur Mom
13:51:35 <chrisdone> @slap ion
13:51:35 <lambdabot> stop telling me what to do
13:51:41 <sm> chrisdone: +1
13:51:46 <chrisdone> lambdabot: go to your room
13:51:52 <lambdabot> no
13:51:55 <chrisdone> lol
13:52:16 <Ralith> bots not doing what they're told? the singularity is nigh
13:52:28 <chrisdone> @quote singularity
13:52:28 <lambdabot> No quotes match. And you call yourself a Rocket Surgeon!
13:52:37 <chrisdone> that is singularly surprising
13:52:46 <carter> @quote carter
13:52:46 <lambdabot> No quotes match. :(
13:52:49 <carter> darn
13:52:54 <carter> @quote shachaf
13:52:54 <lambdabot> shachaf says: Hackage going down regularly is part of the rustic charm of Haskell!
13:52:57 <carter> @quote shachaf
13:52:57 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
13:52:58 <ion> ralith: Thatâ€™s a measure of the imminence of singularity?
13:53:02 <levi> chrisdone: You should do some awesome web stuff in Ur, so it doesn't look like something suitable only for 90s-style web work. :P
13:53:04 <b2coutts> @quote b2coutts
13:53:04 <lambdabot> No quotes match. I feel much better now.
13:53:08 <Ralith> ion: well, that or a bug.
13:53:11 <Ralith> 50/50
13:53:12 <NihilistDandy> @quote NihilistDandy
13:53:12 <lambdabot> NihilistDandy says: I feel like a hipster whenever I talk programming with people at my school. I always have to preface discussions with "you've probably never heard of it" :/
13:53:39 <chrisdone> levi: hahaha
13:53:53 <b2coutts> heh, that quote is funny but also actually a really good explanation of IO
13:53:54 <chrisdone> levi: it seems like if they just imported bootstrap on their docs it would look suddenly modern =p
13:54:00 <b2coutts> the shachaf one, that is
13:54:01 <sm> levi: http://bazqux.com is ur, apparently
13:54:02 <johnw> a language hipster generally can't program in a language that other people know about
13:54:17 <chrisdone> or see
13:54:17 * elliott ends up using the /bin/ls quote more or less whenever IO comes up.
13:54:24 <elliott> it's a very useful quip.
13:54:26 <chrisdone> whitespace is a good language for that. â€œyou probably haven't seen itâ€
13:54:40 <b52> What does that mean in a context of a quickcheck prop test? [Arguments exhausted after 20 tests]
13:55:04 <chrisdone> sm: interesting!
13:55:13 <levi> sm: I'd seen that before, but it doesn't exactly advertise the fact, if it is even still based on Ur.
13:55:15 <NihilistDandy> johnw: I'm pretty much incompetent in the language my school actually teaches
13:55:37 <johnw> Monads were such an amazing concept for Haskell: they at once attracted people to Haskell on their own, and kept people out who weren't sufficiently motivated.  Once the mystery goes away, we'll need another language with a similarly befuddling core concept
13:55:53 <levi> There was also a cool sequent calculus tutorial app thingy that was partially implemented in Ur.
13:56:09 <sm> it's mentioned on the ur wiki. Its ur & haskell lineage got me to become a user & customer, in fact
13:56:18 <NihilistDandy> johnw: Agda already exists. Mission accomplished
13:57:00 <johnw> NihilistDandy: what is Agda's main conundrum?
13:57:14 <chrisdone> that nobody runs agda programs?
13:57:15 <levi> sm: The fact that Google Reader existed and bazqux wasn't free kept me from doing so.  And now I just rarely check RSS feeds.
13:57:15 <elliott> levi: https://bazqux.com/faq says it too
13:57:21 <NihilistDandy> johnw: Proofs are hard T_T
13:57:32 <NihilistDandy> Or so I'm told
13:57:38 <johnw> HoTT has the wonderfully frustrating link between types and topology, for eaxmple :)
13:57:56 <dolio> Also you can't use it for anything yet.
13:57:59 <haasn> johnw: lenses
13:58:06 <johnw> dolio: that seems to be a core feature of hipster languages
13:58:21 <dolio> Doesn't stop mathematicians, unfortunately.
13:58:36 <haasn> that's not a limitation
13:58:38 <haasn> that's a challenge
14:01:49 <kmc> johnw: I'm rejoining this channel after months away just to tell you how incredibly wrong you are that monads are the "core concept" of Haskell
14:02:25 <chrisdone> @remember kmc johnw: I'm rejoining this channel after months away just to tell you how incredibly wrong you are that monads are the "core concept" of Haskell
14:02:25 <lambdabot> It is forever etched in my memory.
14:02:35 <chrisdone> =p
14:02:40 <johnw> kmc: haha
14:03:01 <ion> He didnâ€™t say â€œtheâ€.
14:03:13 <ion> fwiw
14:03:13 <quchen> kmc! Nice to meet you in person. Thanks for the rich quote section Lambdabot has of you.
14:03:18 <johnw> kmc: I didn't mean they were the core concept of Haskell per se, maybe I should have said, "The most enigmatic, publically known concept"?
14:03:27 <mauke> the hype
14:03:32 <kmc> but it's only publicly known as such because of bullshit propaganda (by supporters and detractors alike)
14:03:35 <kmc> yes
14:03:37 <kmc> the hype
14:03:40 <NihilistDandy> I dunno, once you get applicatives, monads are pretty simple
14:03:57 <johnw> kmc: welcome back, btw!
14:04:00 <kmc> thanks
14:04:09 <kmc> unfortunately I can't stay around and argue because I've got to catch a plane
14:04:14 <kmc> see you all again... sometime
14:04:16 <johnw> have a good trip
14:04:22 * hpc writes a tutorial entitled "Monads: Haskell's Secret Shame" :P
14:04:23 <kmc> good luck :)
14:04:44 <Peaker> Monoids, Functors, Applicatives, Monads, Traversals, appear very very frequently in my code
14:04:57 <NihilistDandy> hpc: "Monads: Haskell's Secret Burrito Recipe â€“ Astronauts Only"
14:05:09 <levi> Type Classes in general seem like one of Haskell's defining features vs. other functional languages.
14:05:30 <Moggle_> levi: typeclasses are basically java interfaces though, so they aren't that special
14:05:37 <Moggle_> (yeah they aren't quite exactly but close enough)
14:05:39 <johnw> Moggle_: so not true
14:05:47 <Moggle_> johnw: how not?
14:05:50 <ion> moggle: Can you do mempty in them?
14:05:55 <johnw> Moggle_: http://blog.tmorris.net/posts/type-classes-are-nothing-like-interfaces/
14:06:13 <hpc> for me, the killer feature of haskell is the "togetherness" of laziness, purity, and ADTs
14:06:15 <levi> They're what make programming with Monoids, Functors, Monads, et al. convenient.
14:06:34 <Peaker> Most people tend to use the Monad class more than other classes, I think.. so it's "central" in the sense that it's hard to work with Haskell if you don't understand them... simply because so much code depends on them. There are other things like that, but they are mostly easier to understand
14:06:54 <quchen> When did this "typeclasses are like interfaces" thing go big? I hear it almost daily here
14:07:04 <johnw> hpc: I like the way that I types are curried and can be partially applied using almost the same syntax as functions; I don't have to think in two completely different ways, as I did with functions vs. templates in C++
14:08:07 <jfischoff> johnw: That article is not accurate
14:08:16 <Moggle_> johnw: this article is... pretty off.
14:08:30 <hpc> johnw: the answer in C++ is of course, to have everything be templates and execute your program with g++
14:08:31 <Moggle_> johnw: I get the point it's trying to make, but interfaces are _very_ like typeclasses
14:08:39 <Moggle_> johnw: when it says they're "nothing" alike, it's a gross exaggeration
14:09:01 <hpc> Moggle_: "very large values of nothing" ;)
14:09:06 <Moggle_> :P
14:10:57 <levi> They do some of the same things, but there are any number of ways to also do that sort of thing, and the magic is often in the details.
14:12:12 <jfischoff> Moggle_: I scrolled up. Type classes are not  "basically java interfaces", either.
14:12:29 <ParahSailin> @src maybeToList
14:12:29 <lambdabot> maybeToList  Nothing   = []
14:12:29 <lambdabot> maybeToList  (Just x)  = [x]
14:12:45 <Moggle_> jfischoff: that's reasonable, i misspoke when i said 'basically'.
14:12:50 <ParahSailin> @ty maybe [] (:[])
14:12:51 <lambdabot> Maybe a -> [a]
14:13:39 <jfischoff> There is overlap between the problems that interfaces and type classes attempt to solve, but they do it in different ways
14:14:25 <ion> @check \a -> maybeToList (a :: Maybe Integer) == toList a
14:14:26 <lambdabot>   Not in scope: `toList'
14:14:26 <lambdabot>  Perhaps you meant one of these:
14:14:26 <lambdabot>    `F.toList' (impo...
14:14:30 <ion> @check \a -> maybeToList (a :: Maybe Integer) == F.toList a
14:14:33 <lambdabot>   +++ OK, passed 100 tests.
14:14:44 <dmwit> This guy is proposing that type classes are closer to inheritance than to interfaces?
14:14:48 <pxqr> @check True
14:14:48 <pxqr>  
14:14:48 <dmwit> That's crazy talk.
14:14:51 <lambdabot>   +++ OK, passed 1 tests.
14:17:18 <levi> dmwit: It's clearly true in some ways; i.e. java interfaces provide no implementation inheritance, while Haskell type classes do.  He never claims they're *exactly* the same, just that they're more like one thing than the other.
14:18:43 <levi> But his whole point is that you should introduce them as their own thing, not as 'like' some other thing you know.
14:18:49 <dmwit> Type classes don't provide implementation inheritance, except from the base class. It's not transitive.
14:18:59 <dmwit> It's not very similar at all.
14:19:53 <johnw> Moggle_: ok, updating my data bank
14:20:02 <johnw> Moggle_: there is also http://stackoverflow.com/questions/6948166/javas-interface-and-haskells-type-class-differences-and-similarities
14:20:08 <levi> Type classes can provide implementation for anything that can be expressed in terms of some core subset of functionality that must be provided by the instance.
14:20:52 <levi> They're kind of like OOP 'traits' in that sense, as described in the 'Traits - Composable Units of Behavior' paper.
14:21:26 <levi> But again not *entirely* like traits.
14:22:12 <jfischoff> Lets talk about what they are
14:22:18 <johnw> can Java interfaces have associated types?
14:23:07 <levi> A Java interface is essentially a pure-virtual class that you can tack on as another parent class besides the primary base class.
14:24:38 <mm_freak> a java interface is value-bound
14:24:39 <mm_freak> so no
14:24:52 <levi> So a class must declare all the interfaces it implements at once.  And then it's got to provide implementations for all of the methods for the interfaces; the types of those methods are fixed by the interface.
14:26:48 <Moggle_> johnw: this stack overflow question is pretty good, thanks for linking it.
14:27:17 <jfischoff> Type classes allow one to create instances (implementations) that are selected through a means that is very similar to pattern matching but at the type level.
14:28:09 <S_J> hoq expensive is quickcheck, would it be really ahrd to do on an embedded system?
14:28:35 <mm_freak> S_J: it's a thin layer around regular functions
14:28:40 <mm_freak> so it's cheap
14:29:19 <ocharles> Hmm, is there anything else behind this function?
14:29:27 <ocharles> thread fs r = case fs of { [] -> return [] ; (f : fs ) -> f r >>= thread fs }
14:29:48 <ocharles> It looks remotely connected to a state monad...
14:30:10 <hpc> :t let thread fs r = case fs of { [] -> return [] ; (f : fs ) -> f r >>= thread fs } in thread
14:30:11 <lambdabot> Monad m => [a1 -> m a1] -> a1 -> m [a]
14:30:30 <ocharles> I have a list of computations [a -> m a], and I have a starting a and wish to repeatedly apply them
14:30:31 <mm_freak> Moggle_, johnw: i think this one is better: http://stackoverflow.com/questions/8122109/difference-between-oop-interfaces-and-fp-type-classes
14:30:42 <ocharles> mostly a starting RandomGen which gets changed over various computations
14:30:48 <mm_freak> i would place most focus on the fact that interfaces are value-bound, while type classes are type-bound
14:30:49 <S_J> smsds
14:30:56 <S_J> i cant write in color
14:31:00 <johnw> mm_freak: thanks!  and great distinction
14:31:04 <hpc> :t foldr (>=>) return -- something like this?
14:31:06 <lambdabot> Monad m => [c -> m c] -> c -> m c
14:31:06 <S_J>  hello
14:31:08 <S_J> ah!
14:31:17 <ocharles> hpc: ah yes!
14:31:20 <elliott> colour isn't enabled in #haskell
14:31:24 <ocharles> I knew it was a catamorphism, I just coludn't see how
14:31:33 <hpc> color isn't enabled either ;)
14:31:44 <S_J>  Sorry for reasking, i cant find my previous post and thus not the answers either. How does quickCheck test edge cases specifically, how nwould it know what an edge case is?
14:32:02 <Gracenotes> :t \v -> mapM ($v)
14:32:02 <lambdabot> Monad m => a -> [a -> m b] -> m [b]
14:32:08 <tomboy65> is there a simple way to make ghci sputter output like i was entering ":step" again and again?
14:32:27 <S_J> mm_freak: i meant expensive with regards to randomly generating input. seems expensive.
14:32:29 <jfischoff> Type classes can be used as constraints on polymorphic values. This is usual for creating abstract interfaces.
14:32:30 <ocharles> wait hpc, foldl isn't right
14:32:43 <hpc> ocharles: foldr is right
14:32:45 <ocharles> that fixes c to be (), as I need a final m ()
14:32:52 <Gracenotes> oh, folding. I see.
14:32:56 <ocharles> fine, foldr isn't right
14:33:16 <ocharles> s/as/and/
14:33:24 <hpc> why do you need m ()?
14:33:30 <jfischoff> Because type classes can recursively search for an instance, they can do type level computation. So that is different
14:33:41 <hpc> you can always (>>= return ())
14:33:51 <ocharles> hm, true
14:34:06 <ocharles> let me remove my own type signature and see what ghc infers
14:34:28 <ocharles> ok, as I thought, the return type is anything
14:34:33 <hpc> ocharles: also, foldr is right and foldl is left :P
14:34:35 <ocharles> (as I planned)
14:34:40 <ocharles> hpc: oh you joker you
14:34:40 <ocharles> :)
14:35:39 <jfischoff> I suppose you could have type classes without constraints? Not as useful no doubt...
14:35:47 <ocharles> Hmm, this is kinda nice actually. My return type is RandomGen g => Writer [a] g
14:35:55 <ocharles> Which is more useful than Writer [a] ()!
14:36:10 <hpc> jfischoff: a type class is a "constraint function"
14:36:25 <hpc> so you can't really, without changing the nature of type classes
14:37:22 <jfischoff> hpc: I mean changing the nature. Have typeclasses with no contraints. You could still select instances.
14:38:00 <hpc> i can't even imagine how that would work
14:38:49 <jfischoff> class Foo a where foo :: a; instance Foo Int where foo = 0; test :: Int; test = foo;
14:38:59 <jfischoff> no constraints right?
14:39:00 <elliott> :t foo
14:39:00 <lambdabot>     Not in scope: `foo'
14:39:00 <lambdabot>     Perhaps you meant `T.for' (imported from Data.Traversable)
14:39:46 <jfischoff> The instance selection does not use the constraints right?
14:40:08 <jfischoff> I am not saying there is any real value there
14:40:29 <jfischoff> I'm just trying to highlight how instance selection works
14:40:37 <jfischoff> to help make type classes clearer
14:41:12 <elliott> what would foo's type be?
14:41:41 <jfischoff> Any I don't know
14:42:55 <hpc> jfischoff: i mean this in the nicest possible way, but what you have described is writing (putStrLn "abc") and exclaiming "look ma, no strings!"
14:43:12 <jfischoff> heh sure
14:56:36 <CaptainK> How do I get this ["T","e","n"] to this  "ten" ?
14:56:55 <Cale> CaptainK: map toLower . concat ?
14:56:59 <mauke> const "ten"
14:57:33 <hpc> chr . [116,101,110]
14:57:46 <dmwit> S_J: Dunno if you got an answer or not, but quickCheck doesn't really try to generate edge cases in any meaningful way.
14:57:49 <hpc> [116,101,110] `flip` undefined
14:57:57 <hpc> (Cale-flip)
14:58:01 <Peaker> mauke, heh
14:58:11 <dmwit> It "just" generates random values i.i.d. according to a user-specified distribution.
14:58:35 <mm_freak> > concatMap (map toLower) ["T", "e", "n"]
14:58:36 <lambdabot>   "ten"
14:59:15 <mm_freak> but Cale's solution is better =)
15:00:04 <Cale> dmwit: It does however have a notion of size, and a tendency to start with small cases
15:00:21 <Cale> (which will usually end up trying many edge cases, but no guarantees)
15:00:32 <xico> wait io is lazy...
15:00:34 <xico> funny
15:00:36 <xico> an neat :)
15:00:49 <Cale> xico: there are some lazy IO primitives which are magic
15:00:52 <Cale> Not all IO is lazy
15:00:57 <Cale> (and most is strict)
15:01:15 <dmwit> Also, lazy is a bad word for it, because it sounds like "lazy" but it doesn't mean "lazy".
15:01:36 <CaptainK> mm_freak: concat ["T", "e", "n"]
15:01:36 <dmwit> "concurrent" is probably a better word for it
15:01:56 <tomboy65> i get   *** Exception: prob0196.hs:(30,17)-(48,84): Non-exhaustive patterns in function tier2  --- how can i tell the ghci debugger to show me the values it's trying to call that function with? i am using :set -fbreak-on-exception in ghci, along with :trace, :hist and :print
15:02:18 <tomboy65> but it's kinda confusing for me
15:02:35 <hpc> "concurrent" isn't a very good word either
15:02:38 <CaptainK> the lower case was my type, but gtk...althought concatMap (map toLower) ["T", "e", "n"] gave me toLower not in scope, so must have to load some other module
15:02:47 <hpc> in the same way that unsafeInterleaveIO is unsafe while forkIO is safe
15:03:31 <dmwit> ?index toLower
15:03:31 <lambdabot> Data.Char
15:03:34 <dmwit> CaptainK: ^^
15:03:57 <elliott> hpc: well, the defence of unsafeInterleaveIO is based around it being very similar to what you can do with forkIO.
15:04:11 <Peaker> forkIO and some insane mutable shared state that is
15:04:36 <dmwit> tomboy65: How about tier2 catchAll = trace (show catchAll) (error "went through to the non-exhaustive bit")?
15:04:41 <hpc> unsafeInterleaveIO binds execution to evaluation
15:04:52 <hpc> if you ignore the resulting value of a forked computation, it still happens
15:04:58 <hpc> but with an interleaved computation who the hell knows
15:05:04 <elliott> I said close not indentical
15:05:07 <elliott> *identical
15:05:33 <tomboy65> erm
15:05:47 <tomboy65> dmwit: am i supposed to paste that into ghci? :/
15:06:03 <dmwit> No, change your definition of tier2 and add that as a last case.
15:06:15 <dmwit> It has nothing to do with ghci or ghci's debugger. It's just Haskell code.
15:06:17 <mm_freak> CaptainK: if you need toLower, you should use Cale's version anywayâ€¦  mine is the monadic version, while his is just regular composition
15:06:17 <tomboy65> ahh
15:06:19 <tomboy65> okay
15:06:21 <dmwit> ?index trace
15:06:21 <lambdabot> Debug.Trace
15:06:39 <xplat> anyone have a link to subscribe to the pipes list?
15:07:07 <tomboy65> dmwit: thanks, that was what i wanted to ask for now :p
15:12:42 <tomboy65> haha
15:12:44 <tomboy65> that did it
15:12:49 <tomboy65> thanks, dmwit!
15:15:09 * hackagebot GiST 0.0.1 - A Haskell implementation of a Generalized Search Tree (GiST)  http://hackage.haskell.org/package/GiST-0.0.1 (MihailBogojeski)
15:16:30 <FreeFull> I wonder, why would quick sort be any more difficult to implement in Haskell than mergesort, given a tree structure?
15:17:55 <merijn> FreeFull: Because immutability makes frequent moving of data inefficient
15:18:04 <xplat> FreeFull: mostly it kind of isn't; however, quicksort only really has its famous 'quickness' on arrays and it has more bad edge cases than other 'fast' sorts
15:18:19 <xplat> (specifically on mutable arrays)
15:18:26 <hpc> picking a pivot on a tree is a "slow" operation
15:18:49 <FreeFull> Yeah, quicksort has an nÂ² worst case if I remembr correctly
15:19:11 <FreeFull> And mergesort is always n log n
15:19:12 <orzo> is there a simple way to change a read-write handle into a write-only or read-only handle?
15:19:36 <Peaker> orzo, more of an OS question than a Haskell question. I'm guessing the answer is no, need to reopen
15:19:38 <xplat> FreeFull: there are ways to correct the nÂ² worst case, but then your quicksort becomes really complicated
15:20:00 <FreeFull> I guess mergesort would be more complicated than quicksort in most imperative languages
15:20:21 <xplat> your pivot selection basically gets as complex as most basic sorts are altogether
15:21:02 <xplat> of course, there are ways to complicate any sort to squeeze more performance out (look up 'funnel sort' sometime if you want to see how crazy mergesorts can get :)
15:21:06 <orzo> Peaker: it's actually a haskell question since Handle is a haskell abstraction over the os, and there is hIsReadable and friends.  Thre could easily have been implemented setters that would cause the haskell-i/o to throw exceptions regardless of the underlying file handle permisions
15:22:04 <hpc> xplat: not on wikipedia, doesn't exist ;)
15:22:14 <orzo> also, the os does have the ability to reopen a file handle with different permisions, but i dont see any kind of haskell reopenHandle function
15:22:31 <mauke> my OS doesn't
15:22:36 <S_J> Sorry, internet died, that's why I repost. How does quickCheck test edge cases specifically, how would it know what an edge case is?
15:22:53 <orzo> what is your os, mauke ?
15:23:12 <mauke> linux
15:23:27 <xplat> hpc: http://en.wikipedia.org/wiki/User:Gwern/Funnel_sort :)
15:23:58 <CapitanK> what is the opposite of concat? "ten" -> ["t","e","n"]
15:24:08 <hpc> xplat: user pages don't exist either ;)
15:24:17 <jmcarthur_mobile> map pure
15:24:40 <mauke> map (: [])
15:24:48 <FreeFull> CapitanK: ^
15:25:01 <FreeFull> or map(:[]) for short
15:25:32 <FreeFull> > map(:[]) "ten"
15:25:34 <lambdabot>   ["t","e","n"]
15:25:39 <mauke> > map pure"ten"
15:25:40 <lambdabot>   No instance for (Control.Applicative.Applicative f0)
15:25:40 <lambdabot>    arising from a use ...
15:25:45 <mauke> > map pure"ten" :: [String]
15:25:46 <lambdabot>   ["t","e","n"]
15:25:53 <shachaf> map(:[]) for ugly... There's no reason to teach beginners bad Haskell style.
15:26:40 <FreeFull> Do lists have a comonad instance?
15:26:55 <mauke> how would extract work?
15:27:14 <c_wraith> you can have a comonad instance for nonempty list types.
15:27:16 <FreeFull> Ah, right
15:27:20 <FreeFull> Yeah, nevermind
15:27:43 <CapitanK> so what is a more elegant way? :P
15:28:00 <johnw> map (\x-> [x])
15:28:07 <FreeFull> > fmap return "foo" :: [String]
15:28:08 <lambdabot>   ["f","o","o"]
15:28:25 <Cale> I think map (:[]) is fine
15:28:37 <johnw> I use (:[]) myself in a few places
15:28:38 <Cale> (but put the space there)
15:28:39 <FreeFull> (:[]) can be thought of as the listify operator
15:28:53 <orzo> linux has fdopen() which gives will let you change the access mode on the c-level-abstraction on an open file descriptor, so haskell could have done the same thing with Handle as fdopen does with FILE*
15:29:42 <mauke> orzo: does the c level abstraction even have an access mode?
15:29:53 <orzo> yes it does
15:30:04 <orzo> fopen is passed "r" or "rw" or "rw+" and so on
15:30:05 <mauke> is this documented anywhere?
15:30:18 <haasn> I vote â€˜pureâ€™ because it has the most awesome name
15:30:20 <mauke> orzo: that doesn't mean it's checked anywhere
15:30:21 <orzo> http://linux.die.net/man/3/fopen
15:30:27 <orzo> http://linux.die.net/man/3/fdopen
15:31:01 <NihilistDandy> > reverse . map (: []) . concat . reverse $ ["H","E","L","L","O"]
15:31:02 <lambdabot>   ["H","E","L","L","O"]
15:31:11 <mauke> orzo: "The mode of the stream must be compatible with the mode of the file descriptor."
15:31:16 <mauke> that's all it says
15:31:25 <nooodl> > [[c] | c <- "HELLO"]
15:31:27 <lambdabot>   ["H","E","L","L","O"]
15:31:42 <nooodl> this is kinda elegant, maybe
15:31:42 <haasn> > "HELLO" >>= pure
15:31:44 <lambdabot>   "HELLO"
15:31:49 <treblezen> I vote NihilistDandy's, the simplest.
15:32:02 <orzo> mauke: "compatible" as opposed to "same as"
15:32:21 <xplat> > "HELLO" >> pure.pure
15:32:21 <lambdabot>   Couldn't match expected type `[b0]'
15:32:22 <lambdabot>              with actual type `a0 -> f0...
15:32:28 <mauke> orzo: yes
15:32:32 <orzo> if it has to be the same, then why would they use the word "compatible"
15:32:39 <mauke> orzo: and it doesn't say this mode is stored anywhere, let alone checked
15:32:40 <xplat> > "HELLO" >>= pure.pure
15:32:41 <lambdabot>   No instance for (Control.Applicative.Applicative f0)
15:32:41 <lambdabot>    arising from a use ...
15:32:56 <CapitanK> let nooodl: that a nice one cause it calls it without other functions
15:33:18 <nooodl> well technically [c] is just sugar for (:[]) c
15:33:24 <xplat> oh fine
15:33:31 <xplat> > pure <$> "HELLO"
15:33:32 <lambdabot>   No instance for (Control.Applicative.Applicative f0)
15:33:32 <lambdabot>    arising from a use ...
15:34:12 <xplat> i guess it needs a type signature ...
15:34:34 <roboguy_> > pure <$> "HELLO" :: [String]
15:34:35 <lambdabot>   ["H","E","L","L","O"]
15:34:58 <NihilistDandy> That's actually pretty neat
15:35:01 <orzo> the c/c++ standards might require checks on FILE* access
15:35:43 <shachaf> @quote checks
15:35:44 <lambdabot> shapr says: <shapr> Oleg will do something terrifying like implementing type checking in tcp/ip checksums on the router level through someemergent property of BGP and he'll do it all with HSP!
15:35:45 <orzo> its hard to find that out via a web search though
15:35:57 <nooodl> i don't like how little (:[]) tells you, in terms of code readability
15:35:58 <jjj8> hello. is there a http client library with support for cookies and web forms?  I want to programatically log into some page and then extract data from it
15:36:20 <mauke> orzo: fdopen isn't in the standard
15:36:31 <NihilistDandy> nooodl: How so? Does 1:2:3:[] not tell you enough?
15:36:59 <orzo> it returns FILE* which is maniuplated with standard functions that would do the checking
15:37:28 <nooodl> well, as a haskell programmer, sure, i know what it does
15:37:37 <roboguy_> NihilistDandy: I don't think that's what (:[]) tells you, though
15:37:56 <NihilistDandy> It tells you to stick an empty list at the end of the list you give it
15:37:58 <merijn> roboguy_: What else would it be? pure/return tell you even less :p
15:38:21 <hpc> NihilistDandy: you have it backwards; take the empty list and stick things at the beginning of it ;)
15:38:26 <nooodl> that's how i'd describe (++[])
15:38:37 <NihilistDandy> hpc: Yes, that's true :D
15:38:41 <roboguy_> NihilistDandy: All lists have an empty list at the end
15:39:01 <shachaf> Except when they don't.
15:39:15 <shachaf> > repeat 'a'
15:39:15 <merijn> > [1..] -- owned...
15:39:15 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
15:39:16 <lambdabot>   can't find file: L.hs
15:39:24 <merijn> awww
15:39:28 <roboguy_> Right except for infinite lists
15:39:34 <merijn> lambdabot likes shachaf better :(
15:39:36 <nooodl> i guess what bugs me is... (:[]) makes you think about *how* lists work
15:39:51 <shachaf> Lists make you think about how lists work.
15:39:52 <nooodl> sure, it's a simple thing, but... eh
15:41:19 <nooodl> shachaf: not necessarily
15:41:44 <nooodl> you can write `reverse [1,2,3]` and get `[3,2,1]` back without having to worry about stuff like (:)
15:42:34 <Twey> nooodl: â€˜returnâ€™ doesn't
15:42:43 <Twey> > return 3 :: [Int]
15:42:44 <lambdabot>   [3]
15:43:13 <Gracenotes> well, they're just exactly equivalent functions...
15:43:14 <nooodl> return is even worse
15:43:43 <Twey> nooodl: Why?  It's higher-level and doesn't make you think about list structure.
15:44:06 <Twey> Gracenotes: Well, if you use â€˜returnâ€™ you might be able to generalize a bit.
15:44:23 <nooodl> well maybe it's better than (:[]) to be fair
15:44:40 <Gracenotes> the right data structure for the job. and.. control structure, for the job, alternatively.
15:44:51 <Gracenotes> just figure out what the job is.
15:45:07 <NihilistDandy> Jobs? In #haskell? Pshaw
15:46:14 <nooodl> but i dislike the idea of invoking the list monad for, well, non-list-monady stuff, if you know what i mean. especially something as simple as "just wrap this thing in a []"
15:46:33 <Twey> nooodl: Yes, it would be nice if Pointed were a separate class
15:46:37 <Twey> Maybe soon
15:46:41 <johnw> I knew Pointed would make its appearance :)
15:46:50 <merijn> johnw: Some infidels never learn
15:46:50 <nooodl> (list-monady stuff is where you have a bunch of <-s and guards and stuff, you know?)
15:46:53 <elliott> this is such a trivial thing to argue over :)
15:47:07 <merijn> elliott: Yes, let's argue over record syntax instead :)
15:47:14 <Twey> Hehe
15:47:15 <johnw> elliott: the more trivial the detail, the better the argument -- because if it really mattered, we'd be working on a solution instead of arguing
15:47:24 * merijn is subscribed to ghc-haskell-users :p
15:47:31 <Gracenotes> omg, more like Pointless
15:47:38 <Twey> johnw: I think Pointed is the general solution :Ã¾
15:47:50 <nooodl> i love trivial arguments
15:47:56 <Twey> There's not a whole lot of work to be done
15:48:01 <Twey> Some trivial arguments are surprisingly interesting
15:48:16 <Twey> (maybe not this one :Ã¾)
15:49:08 <johnw> Pointed solves what?  Do you really want "return/pure", but without any laws to give it meaning?  Pointed can do almost anything it likes to yield an "f a", and there's no way to know without already knowing enough about the instance to not need Pointed
15:49:43 <johnw> pointed _ =
15:49:44 <johnw> Nothing
15:49:52 <johnw> is a perfectly valid Pointed instance for Maybe
15:50:07 <Peaker> johnw, Pointed makes it possible to know what a function can/cannot do
15:50:14 <johnw> it's not what you expect, but it's not disallow by any law either
15:50:32 <Peaker> johnw, you can consider Pointed to be a part of Applicative, with all the laws that entails, but still separate so that you get more useful information about code
15:50:49 <nooodl> Pointed laws: "1. please make sense. thank you"
15:50:51 <Peaker> useful constraints tell us what code can or cannot do
15:51:39 <Twey> johnw: It would be reasonable, I think, to make a law that says Pointed instances may not discard information
15:51:48 <elliott> that law is meaningless
15:51:55 <elliott> and why would e.g. Const () not have a Pointed instance?
15:51:58 <elliott> it has a Monad instance
15:52:04 <Peaker> Twey, Const a should probably be Pointed
15:52:09 <Twey> Bah
15:52:12 <johnw> Pointed law: "Do what Applicative's pure would do, but without an associative operator to define what that Applicative's pure would do"
15:52:13 <Twey> Okay, maybe not so reasonable
15:52:28 <Peaker> johnw, why without? there may be an Applicative instance too
15:52:29 <Gracenotes> Pointed lets you know whether a type is empty or not. that's always quite useful.
15:52:39 <augur> johnw: pointed is like inhabited
15:52:43 <Peaker> johnw, you can have a law about Pointed being consistent with Applicative
15:52:43 <orzo> mauke: i just tested it, fprintf does in fact do checking, it let me write to a file via a writable FILE* and it failed to let me write using a read-only FILE* even though both used the same underlying file descriptor.  So at least it behaves the way i expected
15:52:44 <augur> hah, Gracenotes :)
15:52:50 <Gracenotes> the law is: it should return a value. how useful, most types don't tell you that!
15:53:00 <augur> also, johnw, pointed lets you specify an element as special in some way
15:53:04 <orzo> mauke: on linux.
15:53:16 <orzo> i can paste code an doutput if you dont believe
15:53:36 <Peaker> johnw, consider that you may have a relaxed instance of Pointed, but a constrained instance of Applicative.. the law gives you behavior because for the constrained case, pointed must match applicative. But Pointed gives you something, because for the unconstrained case, you get Pointed when you'd otherwise not have it!
15:53:48 <johnw> augur: for distinguishing elements in a set, ok, as long as its understood that you can have no knowledge about what that distinguished element might be
15:53:56 <Peaker> johnw, so you get both Laws about its behavior, and an instance where you'd otherwise not have it
15:54:03 <Peaker> yay Pointed :)
15:54:07 <augur> johnw: it might not matter tho
15:54:19 <Twey> elliott: â€˜May not discard any more information than necessary to create an element of the codomainâ€™?
15:54:20 <augur> johnw: i mean, it acts as a kind of default, right
15:54:23 <johnw> Peaker: I read a paper last night that invented a "Premonad" class which was essentially Pointed, for that very reason
15:54:27 <augur> when you dont know what to use, use the point@
15:54:29 <augur> !
15:54:47 <elliott> Twey: I seriously doubt you're going to get a non-vague law out of it
15:54:49 <orzo> mauke: that checking is slitly less useful in C as it just silently fails to write the read-only FILE*, no exception..., so it does the check, but its impossible for code to handle the failure
15:54:50 <Gracenotes> Pointed can probably be derived automatically pretty easily, though, I will say
15:55:07 <johnw> augur: sort of like, give me a default when I give you an a, instead of just "give me a default"
15:55:14 <Peaker> johnw, since instances can have contexts/constraints, you might have Pointed/Applicative coexisting well enough to have useful laws relating them and completely forcing the Pointed behavior to be sane, while still have cases where Pointed is available and Applicative isn't
15:55:21 <augur> johnw: ?
15:55:33 <Gracenotes> operators like >>= or <*> can't be derived automatically that well
15:55:38 <shachaf> instance Default w => Pointed (Const w)
15:55:44 <johnw> right
15:56:12 <merijn> "instance Pointed (Const w) = pointed _ = Const undefined" :>
15:56:23 <Peaker> Classes can have inter-class laws, I think that's fine
15:56:26 <merijn> While I'm at it...
15:56:43 <merijn> "instance Comonad (Const w) where extract _ = undefined"!
15:57:01 <merijn> (You can tell I'm a C programmer at heart)
15:57:06 <Twey> merijn: undefined just doesn't count :Ã¾  That's just a runtime-checked lack of an instance.
15:57:20 <nooodl> @src Const
15:57:20 <lambdabot> Source not found. I am sorry.
15:57:45 <merijn> nooodl: "newtype Const a b = Const { runConst :: a }"
15:57:47 <shachaf> newtype Const a b = Const a
15:57:53 <augur> Gracenotes: derived from what
15:58:32 <Gracenotes> augur: ...well, assuming you only have 'a' in your type
15:59:08 <augur> Gracenotes: what huh
15:59:35 <Gracenotes> the question of deriving Pointed automatically, in the same way functors are derived automatically.
15:59:59 <Gracenotes> it's not possible for some types... er... a lot of types
15:59:59 <Gracenotes> nvm
16:00:33 <johnw> Peaker: anyway, I brought up Pointed on libraries@, only to be convinced of its lack of general utility.  If you say that Pointed is only valid if it fulfills the spirit of pure from a related Applicative instance (even though Pointed could exist without any valid Applicative), maybe under that constraint it could be useful, but I'm not sure it's too compelling.  We have it in a library at any rate, for when you want it
16:01:13 <Twey> johnw: It's more that we have duplication in â€˜pureâ€™ and â€˜returnâ€™
16:01:13 <c_wraith> Tough to say what that spirit *is*, anyway.
16:01:14 <Peaker> johnw, I think having too fine grained classes is a small problem. Too coarse grained, a big problem
16:01:41 <Peaker> johnw, also, I agree its general utility is low, I have only 1 or 2 example of useful uses, and they aren't that convincing.. OTOH, I think its cost is minimal as well
16:01:46 <johnw> Twey: with the AMP proposal, that can go away
16:01:50 <Philippa_> xplat: cheers. Suspected it might
16:02:07 <Peaker> johnw, unless you add readability/information about code -- the utility in that front may be nice, since you learn more about code from a more tightly binding type
16:02:21 <johnw> Twey: we can have "return = pure" as a default
16:02:34 <roboguy_> if you require that it work with a Applicative instance, then why have it? you already have pure for that
16:02:35 <Peaker> so I'm all for having Pointed and if it turns out it's not that useful separately, no harm done
16:02:36 <haasn> merijn: careful with undefined, you can generally count on breaking the law that way
16:02:42 <haasn> it's mainly useful for Void instances
16:02:57 <Peaker> roboguy_, you require it be *consistent* with the Applicative instance, but you might have Pointed without Applicative because of instance class contexts/constraints
16:02:58 <Gracenotes> because Void is not actually Void
16:03:00 <haasn> where the laws are vacuously true
16:03:10 <haasn> well, +- bottom
16:03:20 <kmc> johnw: I think the hype over monads is really damaging to the community, and so praising the hype as a way to keep out undesirables is at best misguided
16:03:28 <Peaker> roboguy_, instance Pointed (Foo f) where ... ; instance SomeConstraint f => Applicative (Foo f) where ..
16:03:40 <merijn> haasn: https://si0.twimg.com/profile_images/1078664648/fry_bigger.jpg "Not sure if missing the joke or ..."
16:03:42 <Peaker> roboguy_, the overlap of these instances gives us laws to work with, constraining Pointed's behavior
16:03:58 <haasn> merijn: too tired to comprehend it, rather
16:03:59 <Peaker> roboguy_, but the overlap isn't full, so it's useful to have Pointed when "SomeConstraint" isn't fulfilled
16:04:02 <johnw> kmc: sorry, I was only trying to be humorous.  I try not to hype monads whenever possible.  I prefer to point people toward mastering functors before they get too excited about monads
16:04:17 <FreeFull> > fix error
16:04:18 <kmc> ok
16:04:18 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
16:04:29 <Peaker> kmc, are you still Haskelling these days?
16:04:30 <kmc> I have said things like what you said in the past, but i've changed my mind
16:04:31 <haasn> Can I get a master's degree in monads?
16:04:32 <FreeFull> I still love that
16:04:33 <roboguy_> hmm
16:05:10 * hackagebot fb 0.14.8 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.14.8 (FelipeLessa)
16:05:59 <kmc> Peaker: I still write Haskell code from time to time.  i don't hang out in #haskell all day which was most of the extent of my previous Haskelling
16:06:14 <Gracenotes> haasn: you need to transform your monads at least a dozen times
16:06:20 <Peaker> kmc, heh
16:06:35 <Peaker> kmc, have you kept up with awesome developments like the lens library?
16:06:36 <kmc> I want *everyone* to learn Haskell; it's a useful multiparadigm language with a lot of cool features that have nothing to do with omgmath
16:06:38 <haasn> (what about a comaster's codegree in comonads?)
16:06:52 <kmc> i don't want it to be a cool kids club hiding behind some manufactured monad mystique
16:07:00 <kmc> Peaker: people tell me about them
16:07:02 <Gracenotes> haasn: à² _à² 
16:07:43 <merijn> kmc: The summary is that edwardk has been obsoleting everyone else's code at worrying pace :p
16:07:45 <Peaker> it transformed so much of the Haskell code I write
16:07:56 <Peaker> merijn, that's a good way to put it :)
16:08:08 <haasn> I don't actually use lens
16:08:11 <haasn> I just hype it up on IRC
16:08:16 <johnw> we should just admit defeat and start on a Kmett compiler
16:08:24 <merijn> @quote merijn edwardk
16:08:24 <lambdabot> merijn says: So apparently there's a footballer named lens, who played some important part in the match against the Netherlands... Which would explain the fact that twitter is telling me "lens" is
16:08:24 <lambdabot> trending, I was starting to think haskell had won the PL revolution with edwardk as our glorious leader ;)
16:08:27 <haasn> I'll work on the preprocessor
16:08:30 <merijn> oh, bah
16:08:32 <merijn> Wrong quote
16:09:08 <johnw> in Kmett, it's an error for the code to be longer than the type, as that indicate a lack of proper abstraction
16:09:26 <haasn> Kmett doesn't have syntax for code
16:09:29 <haasn> it's derived based on the type
16:09:31 <johnw> lol
16:09:49 <johnw> and it has sooo many libraries, even the type syntax is a library
16:12:38 <merijn> conal: I had an epiphany about the push-pull FRP stuff today, but now I have a question. It seems the assumption is that "Event a" is an external or global event source (modulo whatever you fmap over it), I'm a bit confused how to deal with Behaviour's generating new events. The most sensible implementations of "Event a" involve some form of IO, meaning that producing events for such a type would involve using IO inside 
16:13:39 <conal> merijn: "It seems the assumption is â€¦". Whose assumption? In what context(s)?
16:15:23 <merijn> conal: I dunno, maybe it's just my flawed reading of the code samples/text :)
16:16:03 <conal> merijn: you can check that interpretation (Events as external/global mod fmap) by looking at the semantic model.
16:17:19 <merijn> conal: Well, I guess what I meant is that I could actually imagine Events as non-global fairly easily, I just don't know how to implement them that way. Or rather, I don't know how to add new invents to them from within a Behavior without somehow resorting to IO
16:17:50 <merijn> s/invents/events
16:18:46 <merijn> As any Chan/Stream/whatver based Event approach seems like it'd require IO to add new events to it, if you don't want to abuse unsafePerformIO and break all safety...
16:19:08 <Cale> merijn: In practice, I think you can have a reasonable FRP system where the occurrences of events *must* align with some external event, and there's no way to delay occurrences by a precise amount. Careful and explicit use of a clock event is one way to smooth out the amount of work you have to do.
16:19:20 <conal> merijn: i guess there's some mental context to these questions. perhaps some rough idea about how to implement the semantics?
16:21:11 <conal> although the original semantics and implementation has/had purely synthetic events and mixtures of synthetic & external. so no correspondence between event occurrences and externals or clocks.
16:21:31 <merijn> conal: Well, specifically I've been trying for a while to find a way to find a nicely composable approach for writing GUIs that plays well with some of the reactive libraries. I kept getting stuck, but I think I found an approach now
16:22:06 <conal> brb
16:22:10 <merijn> conal: The think I keep wanting is to have Behavior in one part raise an Event somewhere else, but I'm not sure that makes any semantic sense
16:23:15 <merijn> Cale: The problem I have is having a Behavior that, in response to some external event, generates other Events
16:24:47 <Cale> merijn: There are some sneaky edge cases involved in that, yeah, like where you have a behaviour which switches to a new event which has an occurrence at the time that the switch happens.
16:24:48 <conal> merijn: when you ask about "raising" events, you're referring to some operational/implementation notion, right?
16:24:54 <merijn> conal: Yeah
16:25:11 <conal> merijn: ah, okay. now i understand better.
16:25:39 <conal> merijn: it's hard for me to comment, since i don't know your operational model.
16:26:16 <Cale> (I also probably have the wrong operational model in my head, because I've spent most of my time working in an FRP system which is not even publically available :)
16:26:39 <conal> merijn: my main advice is to stay clear about the denotational model as a basis for defining correctness of whatever operational approach you pick.
16:26:47 <Peaker> Were (<*) and (*>) always methods of the Applicative class?
16:26:47 <merijn> i.e. I have some "Event a" somewhere in whatever Behavior, now I'm a bit confused how I could have other FRP parts "add" new Events, most approach seem to involve IO in some way
16:27:12 <Cale> Peaker: I think the paper doesn't describe them
16:27:16 <merijn> And I'm pretty sure mixing IO into the FRP model I've got so far would irrevocably ruin all nice things :p
16:27:22 <Cale> But I could check
16:27:23 <conal> merijn: yeah.
16:27:38 <Peaker> I'm surprised to have them imported by Applicative(..)
16:27:47 <merijn> But unsafePerformIO would probably be even worse
16:27:57 <conal> merijn: the two properties that have mattered to me from the start are denotative and continuous time. mixing in IO would kill denotative.
16:28:06 <Cale> Peaker: oh, right, in 6.10.x, they weren't part of the class proper.
16:28:13 <kmc> Peaker: Parsec had its own version I think
16:28:17 <kmc> bitd
16:28:26 <merijn> My current backup idea is just to have "Behaviour (ThingICareAbout, NewEvent)" and then have the IO that adds the NewEvents in the loop outside of the FRP bit
16:28:44 <Cale> and then in 6.12.1 they got moved into the class declaration
16:29:02 <merijn> Which keeps the denotative semantics, at the cost having less nice surrounding code
16:29:06 <Cale> http://www.haskell.org/ghc/docs/6.10.4/html/libraries/base/Control-Applicative.html
16:29:08 <Peaker> Cale, so it's old news
16:29:11 <Cale> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/Control-Applicative.html
16:30:12 <merijn> conal: Yeah, I was just wondering if you had already thought about "raising"/"producing" Events from an entirely unrelated part of the FRP code, i attempt to not have to reinvent the wheel :)
16:31:00 <conal> merijn: do you mean as an implementation technique? or some aspect/ability of the API? or ??
16:32:17 <tomboy65> when i loaded a source-file in ghci, how do i access functions apart from main?
16:32:19 <merijn> conal: What I have so far is almost entirely based on the push-pull paper, I'm still trying to figure how much change/addition would be required to get from there to where I want
16:32:44 <conal> merijn: and are you wanting something about expressiveness?
16:33:52 <merijn> conal: Well, my confusion stems from one part of my brain telling me that it's (operationally) obvious and simple to "raise" events from within the FRP code, but when I think about that, I don't think that makes sense in terms of denotative semantics...
16:34:15 <conal> merijn: yep.
16:34:32 <martint> tomboy65, do you have module Filename where at the top of the source file?
16:34:47 <merijn> conal: So, since that realisation I've been trying to think "what's the closest I can get without breaking things"
16:35:18 <tomboy65> martint: no. but i found that :l *filename.hs does what i want :-}
16:35:39 <conal> merijn: my hunch is that you are projecting some old imperative operational thinking about events onto FRP. and experiencing the resulting cognitive dissonance.
16:38:55 <jmcarthur_mobile> I have found that it is still very difficult to explain what FRP is to others. The reaction is usually either "that sounds fuzzy and wishful" or "that sounds like what we already have everywhere, what's so new?"
16:39:08 <CapitanK> why is this: let xp = [1..3] ok in GHCi but not in script build?
16:39:46 <elliott> CapitanK: because GHC doesn't use quite the same syntax as .hs files.
16:39:47 <tomboy65> CapitanK: are you trying to apply this in global context?
16:39:52 <elliott> you just do "foo = bar" at the top level in a Haskell file
16:40:07 <CapitanK> in a do loop
16:40:11 * hackagebot module-management 0.9.3 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.9.3 (DavidFox)
16:40:14 <conal> jmcarthur_mobile: i wonder whether those folks are unused to having precise models/meanings of their software systems.
16:40:28 <merijn> conal: Most likely. I've been messing with GUI designs (because that's what everyone does, right? :p), so I Widget's who have time varying values based on input events. Given an input event I might want to have more events based on the Widget state. This is not so hard if you use the applicative interface of Event, but unfortunately that means I can no longer have my Widget data structure orthogonal from where the Events
16:41:01 <merijn> I can't seem to find a nice way to compose layout and behaviour in an orthogonal way, which is a bit disappointing
16:41:15 <jmcarthur_mobile> conal: I feel fairly confident that is the case, but regardless I am less confident that I am any good at explaining things with you choose precision, either
16:41:34 <jmcarthur_mobile> s/you choose/such/
16:41:42 <jmcarthur_mobile> Yay phone keyboard
16:41:46 <CapitanK> elliott: what is the syntax within the script?
16:42:08 <elliott> <CapitanK> in a do loop
16:42:10 <elliott> er
16:42:16 <elliott> oh
16:42:29 <conal> jmcarthur_mobile: if people don't relate to value in precision or assume that it's unreachable, then they may not try very hard to understand.
16:42:36 <elliott> CapitanK: let foo = bar is the same syntax in GHCi and a do block
16:42:43 <elliott> if you're getting a syntax error, can you hpaste your code?
16:43:23 <conal> jmcarthur_mobile: maybe start with why one might want to understand programs in a precise way.
16:44:01 <conal> jmcarthur_mobile: and if they don't get that part, then don't bother with FRP.
16:44:03 <jmcarthur_mobile> conal: a lot of the time it might be that I am not clear that I am trying to be very precise, either. If one assumes that an explanation is imprecise (as most are) then no matter how precise it is, is still might be taken as some sort of analogy
16:44:10 <CapitanK> tomboy65: ya now I see the reason of your question, it is global so changing it at the beginning of code can have implications for compile later on, hence the failure]
16:44:42 <jmcarthur_mobile> conal: that is probably a good direction, yeah
16:44:59 <conal> jmcarthur_mobile: sounds likely (that people assume you're hand-waving / analogizing)
16:46:28 <acowley> jmcarthur_mobile: I think the world needs more compelling FRP examples, actually. The ratio of arguments of its theoretical benefits to code is too high.
16:46:36 <jmcarthur_mobile> conal: on the other hand, it is often than eyes glaze over when I start with "denotational semantics"
16:46:46 <jmcarthur_mobile> *that
16:47:07 <Philippa_> mmm. It's better when you tell people that you can do maths about the system /and it works/
16:47:16 <acowley> Philippa_: exactly
16:47:30 <conal> jmcarthur_mobile: yeah. "denotational semantics" is a means to an end. if we can clearly articulate that end, maybe people will want to know the means.
16:47:55 <acowley> I've certainly read a lot more of people saying they can understand their systems than actually demonstrating interesting systems.
16:48:25 <Philippa_> acowley: *nod*. Not doing FRP myself, it's been too long since I had stuff where it was applicable that I wanted to do and felt like it was of a scale I could tackle at all
16:48:26 <Philippa_> but yeah
16:48:45 <Philippa_> (disclaimer: I'm a burned out wannabe amateur game developer from the 90s :p )
16:48:55 <Philippa_> speaking of which, hey edwardk ;-)
16:48:57 <acowley> Philippa_: several of us are :)
16:48:59 <merijn> Well, the other issue is trying to figure out how to actually map people's preconceived notions of how to do things to FRP :p
16:49:10 <edwardk> =P
16:49:14 <merijn> i.e. see my problem :p
16:49:22 <johnw> hi edwardk!
16:49:47 <merijn> I'm not even sure my desired behaviour actually has a nice mapping to FRP, which makes me a sad panda...
16:49:51 <Philippa_> acowley: yeah. Somehow something didn't quite go right in the way PC games are/aren't moddable, from where I'm standing
16:50:05 <Philippa_> the Unreal series being a spectacular near miss for me
16:50:38 <conal> merijn: if you can understand what you want in a mathy/denotational/non-operational way, then you'll be on your way.
16:50:52 <acowley> Philippa_: Setting aside economic factors, I think content generation for AAA games became too difficult.
16:51:06 <Philippa_> merijn: so I know if I do a fighting game, FRP probably isn't how I'd do it /anyway/, not least because I don't want to have to calculate the edge cases and work out how it fucks up the game design compared to a 30 or 60Hz clock :-)
16:51:38 <Philippa_> but that's an, uh, specialised case and I suggest conal and I don't get into this unless he's willing to fly out to Nottingham and have a tutorial in playing at least one moderately seriously :p
16:52:10 <acowley> Philippa_: So big-budget games need fancier content than amateurs can produce, and low-budget games can sometimes get by with programmer-art. The middle ground turned into a sink hole.
16:52:14 <Philippa_> acowley: Not just AAA. I can't do good /enough/ content for, say, an early-stage indie UT-alike without a lot of people on board
16:52:38 <merijn> conal: Unfortunately, I'm not sure there is a non-operational description of what I want. Or rather, there is if you consider the Applicative instance of Event, but that approach ruins my life in other ways :)
16:52:41 <Philippa_> to the point where unless you're happy ripping existing content and wasting code on other people's specialised formats, you can't even prototype gameplay properly
16:53:40 <Philippa_> now, UT might've been AAA back then, with the toolchains we had then? I should be able to bootstrap to the point of playtesting interesting multiplayer mechanics /as one person/ these days, and I can't
16:53:51 <merijn> Basically, I want conflicting things and the universe is uncooperative...curse the universe!
16:54:14 <Philippa_> by comparison, for electronic music I can do stuff most producers would've given body parts for in the late 90s on a £330 laptop
16:54:21 <jmcarthur> merijn: that claim sounds funny to me. operational semantics is a means to an end.
16:54:39 <jmcarthur> merijn: so it's very likely that you have some non-operational goal in mind...
16:55:01 <merijn> jmcarthur: Probably, but not one I can clearly formulate
16:55:37 <Philippa_> (and yes, producers with studios running on 100x the budget before adjustment for inflation)
16:55:54 <merijn> I want to fire events based on other events, that bit is simple to describe, but how to do that is less so
16:56:06 <Philippa_> granted, the late 90s gave me a big leap in the form of what MMX let a PC do in the way of live mixing :-)
16:56:12 <jmcarthur> merijn: why do you want to do this?
16:56:34 <Philippa_> merijn: you want a 'patchable' rules-based approach?
16:56:52 <Philippa_> in the sense that the causal event shouldn't have to know what it causes?
16:57:02 <merijn> jmcarthur: Input event + widget state triggering update of another Widget (simplest way being to produce an Event that widget can react to)
16:57:19 <merijn> Philippa_: I don't know what that means? >.>
16:57:26 <Philippa_> merijn: *nod*. Presumably doing the equivalent of spamming listeners everywhere is not good
16:57:40 <jmcarthur> merijn: "triggering update of another widget" sounds like that widget has some time-dependent state, which sounds more like a behavior than an event, to me
16:57:45 <Philippa_> merijn: I guess I'm talking in OOish terms
16:57:46 <merijn> Philippa_: Hell, I can't even do that without breaking things
16:58:11 <jmcarthur> merijn: so then that widget's behavior is dependent on the input event and other widget state (which is also some behavior, i assume)
16:58:35 <merijn> jmcarthur: Yes, which leads you down the applicative path way
16:59:10 <jmcarthur> merijn: i'm guessing that's *not* what you want, then?
16:59:21 <Philippa_> merijn: do you know what the form of the breakage is if you spam listeners?
16:59:21 <merijn> jmcarthur: Which lets me nicely describe all the behavior of widgets and how they depend on other widgets, but the problem is that it then becomes really hard to describe the *layout* of widgets nicely
16:59:32 <Philippa_> *Hah*. Yeah, that figures
16:59:37 <Philippa_> cross-cutting concerns are a PITA
16:59:44 <jmcarthur> merijn: why is the layout of widgets affected by this?
16:59:58 <merijn> jmcarthur: Conversely, all my approaches so far that let me describe layout nicely result in the interrelation of behaviour screwing up
17:00:03 <Philippa_> jmcarthur: for one, the size of the data they're attempting to display may be
17:00:16 <jmcarthur> can't the layout also be a behavior?
17:00:50 <Philippa_> jmcarthur: the problem is that you have two kinds of behaviours that you'd /like/ to be orthogonal that aren't quite
17:01:03 <jmcarthur> Philippa_: why are they two different kinds of behaviors?
17:01:19 <jmcarthur> i don't see why they have to be orthogonal at all. one directly depends on the other, no?
17:01:30 <merijn> jmcarthur: My current idea was to consider "Behaviour (Widget a)" and have a Layout type (which describes the nesting of widgets), then I could use the applicative instance of Behaviour to turn multiple "Behaviour (Widget a)" into "Behaviour Layout", but then how do I get Events to go anywhere?
17:01:42 <Philippa_> jmcarthur: why I am I *not* allowed to decompose along that axis?
17:01:49 <merijn> jmcarthur: They have to be orthogonal because you don't want to write both at the same time
17:01:55 <jmcarthur> merijn: where do events "go"?
17:02:00 <Philippa_> merijn: quite
17:02:12 <Philippa_> it's almost like there's an engineering concern or something :p
17:02:16 <merijn> jmcarthur: Specifying layout and behaviour at the same time becomes a horrible interdependent mess
17:02:17 <jmcarthur> Philippa_: you can have a Behavior Layout and a Behavior Widget. those are separate things. that doesn't mean they are independent. they are not independent in a non-frp context, either
17:02:43 <Philippa_> jmcarthur: Right. So the problem becomes, how do you analyse the dependencies usefully?
17:02:44 <merijn> jmcarthur: I wanted to have "Event a -> Behaviour (Widget b)"
17:02:54 <OffsetGoose> Can anyone explain to me what an Applicative is?  To me it seems to be an addition to a functor, but I don't see the explicit goal
17:02:58 <jmcarthur> it's very typical for presentation to be affected by content
17:03:10 <Philippa_> OffsetGoose: it turns the functor into a language that does n-ary function application
17:03:20 <jmcarthur> it's not like i'm arguing that you have to hard code content into your presentation
17:03:27 <Gracenotes> I think people are thrown off by f (a -> b), which does not immediately appear that useful
17:03:29 <Philippa_> instead of just the unary that fmap effectively gives you
17:03:31 <conal> OffsetGoose: it generalizes fmap to a symmetric form of application
17:03:42 <merijn> OffsetGoose: Let me answer with a simple question, if you're only allowed fmap, how do you get "Maybe (a -> b)" or "IO (a -> b)" out to apply it to an a?
17:03:43 <elliott> OffsetGoose: the Typeclassopedia is a great reference for this kind of stuff
17:03:46 <elliott> @wiki Typeclassopedia
17:03:46 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
17:03:55 <kmc> thanks elliott
17:04:23 <conal> elliott: good idea.
17:04:26 <Philippa_> jmcarthur: yeah, but you're not being any help in finding the actual problems resulting
17:04:41 <merijn> jmcarthur: i.e. I wanted specify a Widget in terms of a Behaviour reacting to whatever Event goes in
17:04:48 <kmc> one of the reasons I left this channel before is that I think 3 concurrent in-channel explanations using different terminology etc. is less helpful than linking to a well written document that the whole community agrees on
17:04:49 <OffsetGoose> Philipa_, conal, merijin Thanks.  Elliot, thanks for the reference, I wasn't aware of it
17:04:51 <jmcarthur> Philippa_: i'm confused. there is a data dependency here which is unavoidable, as far as i can tell
17:04:58 <Philippa_> I mean, to be fair I sometimes raise a problem in here, get a lot of WTF? and then eventually someone realises it's an engineering concern for which the current answer is "you're SOL"
17:05:09 <conal> OffsetGoose: that document is a gold mine!
17:05:13 <merijn> jmcarthur: Now, maybe that's the right approach, but if it's not, I'm open to better suggestions
17:05:16 <Philippa_> jmcarthur: so, what are the engineering techniques for managing that dependency?
17:05:37 <kmc> people tend to measure "friendliness" by the number of people who try to answer a question, or something, but at some point friendliness doesn't translate to helpfulness
17:05:58 <jmcarthur> Philippa_: what are you looking for? a design pattern? i can't give advice that is both infinitely general and universally applicable
17:06:04 <Philippa_> kmc: IME, there's a threshold where that's true, but two or three competing explanations is often a good thing
17:06:18 <acowley> kmc: #haskell likes to bludgeon newcomers with friendliness.
17:06:27 <Philippa_> (OTOH, I try to keep mine succinct and let people ask questions these days)
17:06:46 <jmcarthur> merijn: it sounds like the typical accum sort of thing, to me
17:06:49 <merijn> jmcarthur: Well, I on the other have some immediate practical issues I'm trying to solve, so I'm open to highly specific utterly non-general suggestions
17:06:54 <kmc> Philippa_: I think we have failed at teaching if we can't link to a document for such basic things.  if they read it and come back with questions, sure
17:07:01 <Philippa_> OffsetGoose: no problem, hope we've helped
17:07:11 <Gracenotes> I think many responses is preferable to asking a question and not getting an answer other than 3 hours of joins and leaves.
17:07:16 <Gracenotes> which does happen here.
17:07:34 <Philippa_> kmc: sure. I have a decade-long history of failing at teaching on that basis, including Cale writing a famous monad tutorial because I'd never got round to it
17:07:35 <Gracenotes> of course, it is a dichotomy. choose!
17:07:37 <jmcarthur> merijn: i think it's worth trying Behavior Layout. i don't think this is going to couple your content and presentation as much as it sounds
17:07:44 <kmc> Gracenotes: that's not the dichotomy at all
17:07:55 <merijn> jmcarthur: I'm not sure how I'm supposed to do that, though
17:08:19 <Gracenotes> yes yes, of course. but I'd say it is comparable, from the point of view of the asker, and indeed preferable.
17:08:22 <merijn> jmcarthur: i.e. I can't imagine what code using that idea would look like
17:08:29 <jmcarthur> operationally? are you writing your own frp library? or are you just using one?
17:08:39 <Philippa_> so I suspect the tricky thing is: you're going to have some widget behaviours that are "react-to-layout" and some that are "react to external event", and you may need to be able to stratify those in some sense to get time to fit together?
17:08:40 <merijn> jmcarthur: Yes, no, maybe
17:08:55 <merijn> jmcarthur: I was playing with existing ones, but I'm not sure they'll suffice
17:08:57 <Philippa_> conal: does that sound like bullshit to you?
17:09:14 <jmcarthur> Philippa_: oh, i was assumping that layout would depend on widgets, but not the other way around
17:09:18 <jmcarthur> *assuming
17:09:18 <merijn> jmcarthur: I'm trying to solve my design first, decide on whether to implement my own thing or not
17:09:35 <merijn> +later
17:09:40 <johnw> kmc: I don't think friendliness vs. helpfulness is a useful dichotomy; sometimes the right information given in the wrong way can be worse than just leaving a person to themselves.  It's too easy to demoralize people who come looking for encouragement as much as for information
17:10:09 <conal> Philippa_: i'm not paying enough attention to assess.
17:10:12 * hackagebot module-management 0.9.3.1 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.9.3.1 (DavidFox)
17:10:16 <kmc> of course friendliness is necessary, I'm just saying it's not sufficient
17:10:21 <kmc> was that really unclear?
17:10:27 <johnw> ah, ok
17:10:29 <Philippa_> jmcarthur: depends what layout's responsibilities are, but there are certainly circumstances where that can happen/make sense. Like when the entire nature of the presentation wants to change in response to layout changes
17:10:29 <johnw> then I completely agree
17:10:36 <astor> I'm using generic-deepseq, but there is no instance for DeepSeq for Text.  Shouldn't there be one?
17:10:51 <Philippa_> kmc: we have some fairly spiky folks around here (sometimes I'm one of them), so yeah, 'fraid so
17:11:12 <jmcarthur> Philippa_: i would think that if any widgets depend on layout then layout will probably not cyclicly depend on those widgets, although it may still depend on other widgets
17:11:38 <Philippa_> jmcarthur: it's going to have to depend on at least what those widgets have to say about when they'd like more space/how much so!
17:11:48 <jmcarthur> Philippa_: i am beginning to see where you are coming from though
17:11:50 <merijn> jmcarthur: Basically, once I have a vision of how things should fit together I can (hopefully) implement/reuse something from that view. The hard part I'm struggling with is how to view this in an FRP perspective
17:11:59 <Philippa_> (maybe they don't have anything to say about that, sure)
17:12:24 <Philippa_> jmcarthur: cool, I think that's the important thing :-)
17:12:57 <joobus> Hi people.  I'm hoping I can get a little help here.  On both debian and raspbian (raspberry pi) if have just installed haskell --> sudo apt-get install haskell-platform.  Cabal gets installed doing this.  But when I do `cabal update` it just hangs, saying "Downloading from...".  I get no response trying to ping hackage.haskell.org.  I can however get to the address listed in .cabal/config in a web browser, which is http://hackage.ha
17:13:02 <merijn> jmcarthur: i.e. I know how to define a behaviour FRP style *or* layout FRP style, I can't seem to find the missing piece on how to do both at the same time
17:13:03 <joobus> any help is appreciated.
17:13:08 <Philippa_> conal: no worries
17:13:28 <geekosaur> you chopped off at ", which is http://hackage.ha"
17:13:28 <kmc> joobus: you got cut off at "which is http://hackage.ha"
17:13:31 <kmc> lol
17:13:42 <joobus> http://hackage.haskell.org/packages/archive/
17:13:51 <jmcarthur> merijn: maybe this is a practice makes perfect kind of thing. i'm not sure what else i can say without writing some code, which i am neither up for doing nor confident enough in my understanding of the requirements to bother spending the time anyway
17:13:59 <Philippa_> merijn: have you got some minimal examples you can show us, and some way you could sketch what the "missing piece" needs to accomplish?
17:14:20 <merijn> Philippa_: mostly I have sketches and about 20 crumpled up pages
17:14:37 <Philippa_> *nod*. If you upload 'em, I'd be willing to take a peek sometime not tonight
17:14:39 <merijn> Whenever I try to find a concrete implementation of things I quickly get stuck
17:14:48 <joobus> i'm assuming other people can access hackage just fine because i've gotten no search results looking for answers.
17:15:07 <merijn> Philippa_: Sure, it's 1:15 here anyway, so no time to do that tonight anyway
17:15:18 <merijn> I was planning to solidify my current approach more tomorrow
17:15:25 <elliott> kmc: geekosaur: I like how those lined up
17:15:34 <Philippa_> merijn: yeah, we're in equivalent TZs
17:15:37 <merijn> I was hoping to resolve this mental block before trying that, though :p
17:15:48 <merijn> Philippa_: The same one even, I believe :p
17:16:01 <geekosaur> joobus, I would guess that your browser autodiscovers a proxy; cabal-install doesn't
17:16:28 <geekosaur> (since browser proxy autoconfig is javascript, which cabal-install does not speak)
17:16:37 <Philippa_> merijn: whereabouts are you these days then, if you don't mind me asking? Still snotts here
17:16:38 <merijn> And here I had hoped I had solved everything with my epiphany today...oh well
17:16:53 <joobus> geekosaur, is there some other address i should be using?
17:17:02 <merijn> Philippa_: I'm in Edinburgh now
17:17:24 <joobus> that was the prepopulated address in the config, so I had hoped it would just work.
17:17:32 <geekosaur> no, you need to find out the http proxy on your *local* network, the one your browser is autodiscovering, and configure cabal to use it
17:17:42 <geekosaur> we can't untangle your *local* network for you
17:17:50 <Philippa_> merijn: ah, cool. I'll be there for an extended weekend next month
17:18:04 <joobus> i have no local proxies
17:18:14 <chrisdone> Philippa_: hey!! (â—Â´âˆ€ï½€â—)
17:18:20 <Philippa_> hey chrisdone
17:18:20 <geekosaur> then you'll have to use local network tracing to find out why your browser works
17:18:29 <merijn> Time to start planning a Haskell-Edinburgh meetup... :p
17:18:32 <chrisdone> Philippa_: how's life treatin' you?
17:18:37 <merijn> chrisdone: hpaste won't announce my pastes :(
17:18:39 <joobus> k, thanks.
17:18:41 <Philippa_> 'mafraid I'm planning on sodding off to bed shortly, but at least I'm sitting in here a bit more often now
17:18:54 <chrisdone> Philippa_: cool =)
17:19:02 <chrisdone> merijn: oh! uhmm let me check why
17:19:16 <Philippa_> er. Complex in ways I don't necessarily want to put in here? But not too badly
17:19:31 <johnw> why do some thing that Data.Default is a code smell?  is it better to use a custom "defaultFoo" instead of defining an instance for Default?
17:19:32 <chrisdone> merijn: which one didn't it announce?
17:19:46 <merijn> chrisdone: All of the last ones I made, I can try again
17:19:50 <thoughtpolice> chrisdone: i just tried out haskell-interactive-mode for the first time, it's great. thanks for all the work (my haskell-mode config has been the same for like years up to this point, so i never made the switch)
17:19:51 <elliott> johnw: it's a syntactic trick, the class doesn't really have any semantics by itself
17:19:58 <elliott> and a lot of the instances are questionable e.g. Int
17:20:05 <elliott> it's fine for things like option records though
17:20:34 <johnw> ok
17:20:37 <merijn> chrisdone: I just made one a few second ago (http://hpaste.org/90543), no announce
17:21:04 <akegalj> has anyone tryed using gtk2hs on windows? I made some app on linux, compiled and works. Now I'm trying running the same thing on windows but with no success. I installed haskell platform, gtk2hs bundle, cabal install gtk2hs-buildtools gtk , set PATH and compilation went ok. But when trying to run i get bunch of GLib-Gobject-CRITICAL error messages. Tryed on few win platforms with no luck :/
17:23:28 <tabemann> Haddock question: does -- | mark the start of a Haddock comment for the following function?
17:23:40 <acowley> Yes
17:23:48 <structuralist> has any work been done on turning haskell into a visual programming language?
17:23:50 <hpc> -- | documents the code below
17:23:51 <akegalj> stackoverflow
17:23:54 <akegalj> ups
17:23:55 <acowley> tabemann: Or a module
17:23:56 <hpc> -- ^ documents the code above
17:24:03 <tabemann> okay
17:24:08 <acowley> and -- * defines sections
17:24:10 <merijn> chrisdone: Anyway, I need to head to bed now, if you need any more help to debug just @tell me what you need me to do and how to notify you
17:24:23 * tabemann will remember this
17:24:42 <tabemann> and single quotes are for naming identifiers in comments?
17:25:04 <acowley> single quotes create inks, @x@ typesets
17:25:23 <tabemann> inks?
17:25:32 <acowley> So if you're documenting a funciton foo, you might write -- | @foo x y@ computes the bamboozle of @x@ and @y@
17:25:36 <acowley> s/inks/links
17:26:09 * tabemann should Haddockify his comments in what he's working on ATM, as he's planning on actually putting it in Hackage once it's done
17:26:16 <acowley> But you might extend that to say, "See the documentation for 'bar' for more information."
17:26:17 <edwardk> kmc: welcome back =)
17:26:25 <meretrix`> Is there a function that converts a newtype back to its underlying type or does one just use pattern matching?
17:26:25 <kmc> thanks
17:26:55 <tabemann> meretrix`: pattern matching
17:26:56 <tabemann> but
17:27:01 <tabemann> if you make a newtype like:
17:27:21 <tabemann> newtype Foo = Foo { bar :: Bar }
17:27:32 <tabemann> you can turn a Foo into a Bar with bar
17:28:24 <meretrix`> tabemann: Ah ok.  Is there any downside to doing it that way?
17:28:42 <tabemann> acowley: I notice from looking through the comments for GHC.List that they like to refer to the name of functions in their comments a *lot*
17:28:47 <tabemann> meretrix`: no
17:28:50 <meretrix`> Does one still get the performance advantage of newtypes?
17:29:08 <shachaf> meretrix`: The function "bar" gets compiled into "id", more or less.
17:29:16 <shachaf> The representation is the same.
17:29:27 <meretrix`> Great, thanks.
17:30:51 <acowley> I actually rather like haddock. My main gripes are annoyances like multiline emphasis, or how .cabal files douse you in their own bizarro syntax.
17:31:51 <tabemann> okay, maybe I won't "have" to reformat my comments to refer to the names of each function... from looking at Data.Foldable, for instance, they aren't quite so obsessed with naming each function in its comment
17:32:32 <acowley> tabemann: Do you mean like my example of saying "@foo x y@" in the documentation for foo?
17:33:03 <tabemann> acowley: I mean like:
17:33:28 <tabemann> 'foo' returns the bar of @x@
17:33:51 <tabemann> foo :: Foo -> Bar
17:34:14 <acowley> Oh, I don't think I ever link a function's name in the documentation for that function.
17:34:57 <joobus> can someone ping hackage.haskell.org and tell me what ip it resolves to?  I think my problem might be a time warner problem.
17:35:21 <tabemann> PING hackage.haskell.org (66.193.37.204) 56(84) bytes of data.
17:35:27 <joobus> thanks
17:35:41 <chrisdone> thoughtpolice: cool!!
17:35:49 <joobus> tabemann, were you able to successfully ping?
17:36:18 <jmcarthur> i think i'm in the minority. i dislike when people think of newtype as nothing more than an optimization
17:36:19 <tabemann> joobus: no, but I was able to connect with my browser
17:36:41 <joobus> yeah, that's where i am at.  i can't get cabal to update.
17:37:22 <joobus> i guess i might just have to download the package index.tar and use it locally.
17:37:50 <chrisdone> @tell merijn i'll look into it tomorrow morning
17:37:51 <lambdabot> Consider it noted.
17:37:51 <jmcarthur> with newtype, (case foo of Foo n -> ...) will not evaluate n, but (foo `seq` ...) will
17:37:52 <acowley> I think of a newtype as a hanger upon which I may drape all my lovely, tailor-fit instances.
17:38:18 <jmcarthur> that is a quite interesting property
17:39:07 <jmcarthur> at least if you pretend, incorrectly, that newtype is just an optimized data
17:39:18 <tabemann> acowley: same here
17:39:58 <Philippa_> jmcarthur: yeah. It kinda drives the point of having isomorphisms home
17:40:47 <Philippa_> acowley: not to mention /absence/ of instances!
17:41:12 <Philippa_> (fun when you do something of the form "it's isomorphic to Foo except I've hidden...")
17:41:35 <acowley> Philippa_: Indeed, ill-fitting instances have no place in the newtype sartorial wonderland.
17:41:50 <Philippa_> definitely one of those things that makes it more pleasant working with a lot of applicatives and monads
17:43:04 <tabemann> Philippa_: that also allows GeneralizedNewtypeDeriving as well
17:43:16 <CapitanK> night guys , thanks for the help
17:43:42 <CapitanK> not to be discouraged, I'll keep plugging away at it, but found this sobering read:
17:43:51 <CapitanK> http://honza.ca/2012/10/haskell-strings
17:44:06 <Philippa_> tabemann: Yep. I mean, I'd like to have some more general tools than that myself, but I can at least understand why the design space scares people
17:44:20 <Philippa_> (...OK, thinking about it: I *really* want something like static OTT in GHC Core :p)
17:44:21 <honza> CapitanK: i wrote that :)
17:44:23 * CapitanK wonders how many C programers are here?
17:44:35 * tabemann raises his hand
17:44:37 <CapitanK> honza: its good work you put that together.
17:44:47 <CapitanK> for a newbie it helps a lot
17:44:49 <honza> CapitanK: ha, thanks
17:44:58 <Philippa_> I was never silly enough to be a three-star programmer myself, but I've done C on protected mode DOS
17:45:07 <CapitanK> lol
17:45:12 * hackagebot cabal-meta 0.4.1.1 - build multiple packages at once  http://hackage.haskell.org/package/cabal-meta-0.4.1.1 (GregWeber)
17:45:38 * tabemann wants something that is like a ByteString, but stores *Unicode* characters, so he wouldn't have to use String
17:45:53 <Philippa_> also some C++, but it only took me a couple of years to realise I was kinda blowing its abstraction threshold off
17:45:54 <jmcarthur> i haven't done hardcore C in a while, but i used to
17:46:12 <johnw> CapitanK: until recently, C and C++ was most of what I did
17:46:12 <CapitanK> en la mana, buenos sunos
17:46:14 <Philippa_> which made me a pretty cranky compsci undergrad
17:46:59 <CapitanK> ya C suites me better for my love of OS hacking
17:47:32 <CapitanK> beginning in both , haskell is more annoying so far, but I see the elegance
17:47:42 * tabemann has used C and C++ at work a lot, even though what he uses at work right now is Java
17:47:59 <jmcarthur> at the same time i was writing antitamper in C at work i was using haskell at home. i don't think i could stand to go back to imperative languages now
17:48:15 <Philippa_> CapitanK: you might find it helps to think of Haskell as being relatively low-level, but built on top of pen-and-paper maths instead
17:48:38 <jmcarthur> even so-called
17:48:41 <jmcarthur> oops
17:48:49 <tabemann> Haskell can be low-level if you want it to be, when you are working with FFI-type code (supports pointer arithmetic!)
17:48:56 <jmcarthur> even so-called "low level" maths is much higher level than C
17:49:16 <Philippa_> jmcarthur: I disagree. Set theory is disgusting low-level irrelevance :p
17:49:39 <CapitanK> I had crazy dreams last night after a haskell session, I was walking around with "fn(n)"  and trying to put everything inside it. so haskell does cause some rewiring :P
17:49:55 * tabemann likes that Haskell comes with the Integer type built-in, so he doesn't have to mess around with the gmp library by hand
17:49:57 <jmcarthur> Philippa_: i'm working from the assumption that one considers the lambda calculus to be simpler than the x86 architecture
17:50:10 <CapitanK> lol
17:50:17 <ion> tabemann: Too bad Prelude also comes with Int and a lot of Prelude functions use it.
17:50:30 <Philippa_> tabemann: yeah, but it's really not a useful way to start learning the language. I mean, maaaybe learn the ANF-like subset and how that behaves operationally if you're worried
17:50:50 <Philippa_> jmcarthur: *shrug*. I'm not typing on an x86 machine right now
17:51:19 <Philippa_> (and how complex the lambda calculus is depends on whether you're comfortable treating it as foundational or not and how much of a headache you get from substitution...)
17:52:07 <Philippa_> now, if you want to say x86 is /crappy/ and /tedious/, sure :-)
17:52:12 <kmc> C isn't based on x86 or any other ISA either; it has its own abstract machine, and you can get very very nasty bugs if you assume a piece of C code will compile to machine code in a particular way
17:52:29 <kmc> it's not really very "close to the machine" at all
17:52:29 <Philippa_> kmc: quite
17:52:32 <Ralith> does GHC define any values that identify the host OS? Kinda like System.Info.arch is for CPU architecture?
17:52:38 <kmc> it's close in terms of headache but not in terms of semantics :)
17:52:40 <astor> I am trying to parse using attoparsec + text.  I have sprinkled ! and deepseq everywhere, but all memory is occupied with Text, Success, Added, and ARR_WORDS.  Can anyone see the space leak?
17:53:01 <astor> http://hpaste.org/90544
17:53:12 <Philippa_> whereas if you're happy tolerating it, haskell on top of naive set theory isn't too bad
17:53:17 <Ralith> oh, dur
17:53:21 <Ralith> System.Info.os
17:53:25 <Philippa_> if you want well-founded, that's a bit trickier
17:53:36 <jmcarthur> kmc: you are right, but that doesn't stop people from writing architecture/compiler dependent code
17:53:49 <jmcarthur> kmc: the same applies for haskell, really
17:53:55 <kmc> yep
17:54:07 <Philippa_> Yeah. I doubt 0xA0000 is an interesting pointer on this device
17:54:07 <kmc> I have some Haskell code that puts x86 machine code in a ByteString and then executes it
17:54:13 <kmc> (just for laffs)
17:54:14 <tabemann> back
17:54:29 <bscarlet> kmc: I can help you with that. :-)
17:54:32 <jmcarthur> System.Info.os being an example of platform affecting semantics, actually :(
17:54:36 <Philippa_> kmc: hah, I've seen a live demonstration of harpy :-)
17:55:51 <Philippa_> (thing I actually quite like: the idea that IO's return is "insert Haskell evaluator/etc here")
17:55:52 * tabemann is just amused by all the bugs caused by switching from x86 to amd64, due to assumptions about the size of int vis-a-vis the size of a pointer being broken, and likewise with int versus size_t and so on
17:55:59 <elliott> Philippa_: out of curiosity, what non-x86 machine? an ARM mobile device?
17:56:05 <tabemann> in C that is
17:56:05 <Philippa_> elliott: series 3 chromebook
17:56:22 <elliott> cool
17:57:11 <Philippa_> it may get retired if the silvermont atoms turn out to be non-shite and there're some reasonable passively-cooled models around though
17:57:24 * tabemann remembered that at his job at NASA they *refused* to upgrade the software he worked on to support amd64 for that reason
17:57:26 <Philippa_> (GHCi isn't readily available on this)
17:57:56 <Philippa_> tabemann: given the budgetary concerns that's... uh, you can tell I know how to think like a large org, huh?
17:58:07 <Philippa_> (I don't work for one myself, but)
17:58:42 <tabemann> I worked on a very small team, actually, but there was *so* much code in our codebase that would have had to been gone over with a fine-toothed comb for that happen that they never did it
18:01:16 <tabemann> we never did anything that *needed* the memory made available by amd64 anyways
18:02:30 <Philippa_> tabemann: it's never the size of the individual team that matters, though obv. the codebase does
18:03:49 <tabemann> yeah, we'd built up a pretty large codebase from many projects for past customers, many of which we were still providing support for, and we couldn't break *any* of their code
18:04:02 <tabemann> (all in one massive but highly modular application)
18:04:37 <Philippa_> mmm, nothing like a multi-historical clusterfuck
18:05:24 <Philippa_> I have to admit, that sort of thing's one reason I'm critical of the fact we don't have a better explicit module language in Haskell these days
18:05:57 <Ralith> @tell carter nevermind, fixed it--I needed to manually initialize boehm
18:05:57 <lambdabot> Consider it noted.
18:06:16 * tabemann , from being a past OCaml coder, does wish that Haskell would have explicit interface files rather than generating them automatically
18:06:40 <tabemann> (well, Haskell *had* them, but someone thought it was a good idea to get rid of them)
18:07:22 * tabemann does miss OCaml's module system, even though he isn't sure how parameterized modules would work with type classes
18:07:36 <ion> tabemann: Why would it be better? (A sincere question.)
18:08:10 <tabemann> ion: you can separate your interface from your source code, so someone can see the entire interface of a module without having to wade through its source
18:08:44 <tabemann> with Haskell it seems that Haddock takes that role, by converting source code into an implementation-less form
18:09:25 <rgrinberg> what is a good approach to type safe urls that doesn't require template haskell, or too many ghc extensions.
18:09:34 <ion> True, the haddocks seem to mostly fulfill that need for me. I suppose interfaces in separate files might make it easier to notice if youâ€™re accidentally breaking the API.
18:09:40 <rgrinberg> I'm asking because I'd like to maybe port it to OCaml
18:10:35 <zRecursive> rgrinberg: OCaml has safe urls ?
18:11:25 <rgrinberg> zRecursive: no...
18:12:10 <zRecursive> rgrinberg: IIRC. '+,-,*,/' in OCaml are not polymorphic ?
18:12:50 <rgrinberg> zRecursive: no they're not
18:13:09 <Philippa_> tabemann: not just that, a little careful functor work can make it easy to quickly switch which implementation you're using throughout a program
18:13:10 <zRecursive> you need +. -. *. /.  for float , what a annoying thing ?!
18:13:33 <shachaf> zRecursive: #ocaml is probably a better channel for talking about OCaml.
18:13:37 <Philippa_> tabemann: as for interactions with type classes, I think the short answer is "I know I can work it out, but if you want me to do it properly you'd have to pay me" :p
18:13:55 <rgrinberg> zRecursive: no you don't. Float.( 5.0 / 2.0 + 3.0 )
18:14:10 <rgrinberg> anyway shachaf is right I'd rather not talk about OCaml here
18:14:13 <Philippa_> in that we know enough to know it's doable, that there's a non-trivial design space with some interesting options, and that incremental exploration is going to skip some of the interesting points
18:14:21 <zRecursive> shachaf: just BTW, stop talking it at once
18:14:26 <rgrinberg> but type safe urls in haskell
18:15:55 <tabemann> Philippa_, I just wonder *how* one would handle instances being put in modules passed to parameterized modules
18:15:58 <Philippa_> ion: I have this frequent lazy habit wherein I use association lists for contexts in typecheckers. It's a bad habit. Unfortunately, it has a really nasty tendency to stick because I cba to import Data.Map :p
18:16:19 <Philippa_> tabemann: an instance with no "super-instances" is equivalent to a structure
18:16:28 <Philippa_> one with instance dependencies is equivalent to a functor
18:16:46 <zRecursive> rgrinberg: in fact i donot like TH too
18:16:59 <Philippa_> so the most obvious thing is to unify them, then add sugar
18:17:15 <tabemann> the problem I see is does an instance in a module passed to a parameterized module have limited scope within the parameterized module, i.e. one could have *different* instances for the same type in different places?
18:17:16 <Philippa_> (then the existing Haskell-Modules effectively become "compilation unit+namespace")
18:17:31 <dolio> Unfortunately, the people who get paid to think about this haven't seemed to figure it out yet.
18:17:32 <Philippa_> (consider auto-creating classes and instances for them also, I guess)
18:17:56 <rgrinberg> zRecursive: then perhaps you can suggest a url route lib that doesn't use TH
18:18:09 <Philippa_> tabemann: right, the big issue is that /type classes/ need to maintain that 1:1 relationship because they assume you can locally work out which structure is actually being used as evidence for a given constraint
18:18:10 <zRecursive> shure
18:18:12 <zRecursive> shure
18:18:14 <zRecursive> sure
18:19:11 <Philippa_> I figure the nice solution is to retain type classes but also have looser constraints with an appropriate dependency-tracking mechanism that break the 1:1 relationship. Then you can even build your typeclass instances out of the 'loose' instances where appropriate so you have functors for various default implementations of things that don't get automatically used
18:19:38 <tabemann> yeaah, from thinking about it, local instances would be *really* bad, as the instances could then leak out of the parameterized modules themselves, and of course you *can't* have more than one instance of something in the same place, which one could potentially have with this
18:19:39 <Philippa_> what gets messy is when you realise some datatypes have constraint dependencies and suddenly you'd have to think about it again :-(
18:20:00 <Philippa_> right. But there's still a principled and useful alternative to be had somewhere
18:20:14 <tabemann> forbid instances within parameter modules
18:20:20 <Peaker> Philippa_, Are you phillipjf on Reddit?
18:20:32 <Philippa_> which is why I'll keep complaining: we might never fix it in Haskell, but Haskell-like languages should never make that mistake again
18:20:49 <Philippa_> Peaker: ...why on earth would I be? That a isn't an initial
18:21:03 <tabemann> I don't think anyone actually uses datatype constraints in Haskell
18:21:06 <startling> named instances?
18:21:19 <shachaf> phillipa's "a" was an initial.
18:21:27 <startling> I think you need dependent typing for that to work well though.
18:21:28 <tabemann> (everywhere I've read has said that they are a *bad* idea)
18:21:38 <Peaker> Philippa_, people use variants on their names all the time.. ok though - was hoping you are so I could ask for a memory refresh of something he once explained to me
18:21:50 <dolio> You're not thinking of the same thing.
18:21:52 <Philippa_> tabemann: that's because you don't need to. You get to assume them from a datatype's type parms
18:22:00 <Philippa_> shachaf: er?
18:22:25 <dolio> GADTs allow you to pack constraints in a data type in a useful way.
18:22:44 <dolio> In contrast to the old ones that just imposed constraints on the use of the constructor.
18:23:05 <shachaf> Philippa_: Wasn't there someone called PhillipA in here at one point? Maybe I'm mixing things up.
18:23:16 <shachaf> Anyway, doesn't matter. You and phillipjf are distinct.
18:23:20 <Ralith> When was haskell platform 2013.2.0.0 released?
18:24:54 <Philippa_> shachaf: might've been only one l. IRC's generally case-insensitive for nicks though, so there'd be the obvious nickserv issues
18:25:26 <shachaf> Looks like it was someone related to mauke? Anyway, doesn't matter.
18:26:34 <ion> Î¦-lippa
18:28:15 <Philippa_> eh, if you're going to go to that much effort you might as well use "flippa" - not exactly an infrequent username for me, give or take an extra c for my surname where useful
18:30:35 <kurak0t> how to grok pattern matching in haskell?
18:31:09 <tabemann> okay, question I am not sure if I could find it somewhere else but I think I could more easily find here: when you have guards, and you have a where expression between the two guards and their =s, how do you indent the second guard?
18:31:41 <tabemann> s/expression/form
18:31:42 <shachaf> By putting the where expression after the guards.
18:31:49 <shachaf> s/expression/whatever/
18:32:08 <tabemann> okay, I'm going to have to use let then
18:34:52 <tabemann> now we have both edwardk and edvardkk in here
18:35:07 <edwardk> it was bad enough with just Eduard_Munteanu
18:35:55 <Ralith> edwardk and edwardk: line noise edition
18:36:04 <shachaf> aardvardk
18:36:07 <edmardl> What's going on in here, guys?
18:36:19 <edwardk> hah
18:40:55 * u_ wishes haskell center wasn't called "haskell center"
18:41:24 <tommd> u_ are in a poor position to complain about names ;-)
18:44:28 <b2coutts> what are your opinions on learning haskell as a first language?
18:44:53 <u_> i did and i think i turned out fine
18:45:02 <roconnor> b2coutts: type errors can be confusing.
18:45:17 <roconnor> type class errors
18:45:24 <shachaf> The only thing more confusing than getting type errors is not getting type errors.
18:45:27 <b2coutts> how about in a course or something?
18:45:47 <roconnor> Helium is haskell for teaching
18:46:31 <Cale> b2coutts: I think it's fine
18:47:09 <theguruofreason> type errors are incredibly helpful for me
18:47:12 <b2coutts> this is what I think too
18:47:14 <theguruofreason> as a very novice programmer
18:47:34 <theguruofreason> runtime errors are WAY harder to deal with
18:47:38 <b2coutts> the first year CS teacher mentioned offhand that he had considered teaching the course in haskell instead of scheme, but he "wasn't that mean"
18:48:08 <theguruofreason> I read "Learn You A Haskell For Great Good" over the course of about a month in my spare time
18:48:17 <theguruofreason> and Haskell has been a joy to learn, and fairly easy
18:48:19 <b2coutts> but I think it could be valuable to start learning haskell without having preconceptions from other languages
18:48:49 <roconnor> I think Epigram would be better as a first language :)
18:49:51 <dolio> roconnor: So that people don't get unrealistic expectations about how good a language's syntax can be?
18:50:15 <ion> theguruofreason: What you have noticed about compile-time errors (with a good type system) vs. runtime errors applies to everyone, no matter where on the noviceâ€“guru scale.
18:50:50 <theguruofreason> ion: I imagine so
18:50:54 <roconnor> dolio: mostly for the views from the left.
18:50:57 <shachaf> ion: Well, it doesn't really apply to me, since I never make mistakes.
18:51:47 <dolio> shachaf: You too?
18:51:55 <NPCompL337> Ello gents.
18:53:30 <Gracenotes> type errors. or as they call them in Agda, errors.
18:54:02 <theguruofreason> I am having some trouble understanding the State monad...
18:54:46 <Gracenotes> you are in luck, We have some State monad experts in this very channel
18:54:58 <dolio> Gracenotes: Sometimes you have specification errors.
18:55:15 <theguruofreason> I would really appreciate some help
18:55:31 <Gracenotes> theguruofreason: do you know how the Reader monad works?
18:56:00 <theguruofreason> yes
18:57:31 <Gracenotes> rather than just passing around a value, and doing stuff to that value, you're passing around a function from a particular type and composing it with other functions.
18:57:39 <Gracenotes> not sure if that's how LYAH explains it...
18:58:13 <theguruofreason> I don't feel like LYAH explained it very well at all...
18:59:19 <theguruofreason> I think my problem is that I'm trying to pass a function which takes 2 parameters
19:00:15 <Gracenotes> what do you mean?
19:00:51 <theguruofreason> it's a little hard to explain, I can do a code dump on refheap if that will help
19:01:34 <Gracenotes> yeah, sure, or hpaste (see title)
19:01:39 <Gracenotes> s/title/topic
19:02:49 <theguruofreason> https://www.refheap.com/16167
19:03:14 <theguruofreason> Item is a simple data structure with a name, weight, quality, etc
19:03:50 <theguruofreason> I'm trying to make a simple state transformation that takes a player and removes the first 4 lettered items ('a','b','c','d')
19:04:12 <theguruofreason> just so I can get a feel for how state works
19:04:36 <Gracenotes> So, takeStuff (if you mean it to be a transformation of the internal player state) can have type State Player ()
19:05:17 <theguruofreason> okay
19:05:57 <Gracenotes> State itself is represented using 's -> (a, s)', so this would be a function from 'Player -> ((), Player)', or basically from 'Player -> Player'
19:06:01 <Gracenotes> which is what you want, yes?
19:06:10 <theguruofreason> yes
19:06:36 <startling> theguruofreason, you can use "modify someFunction" where someFunction :: Player -> Player
19:07:26 <ion> Let â€œf, g, h, i :: s -> (a, s)â€. â€œlet (a,s0) = f sInit; (b,s1) = g s0; (c,s2) = h s1; (d,s3) = h s2 in (a,b,c,d)â€ is equal to â€œevalState (do a <- state f; b <- state g; c <- state h; d <- state i; return (a,b,c,d)) sInitâ€
19:07:42 <startling> theguruofreason: let's keep it in this channel, please.
19:08:10 <theguruofreason> sry, I'm actually a bit new to IRC and I don't know all the commands.
19:08:57 <startling> theguruofreason: sure. it's just easier this way because if I step out to make coffee or whatever, other people can scroll up and get context and continue to help
19:09:54 <augur> it seems to me like you can make a consistent type theory with polymorphism where polymorphic types can themselves be quantified over, but without using levels
19:09:55 <ion> State s a is just a wrapper for a function of type s -> (a, s), and the behavior of the monad is demonstrated by the equality above.
19:10:09 <augur> but im not sure if this is true.
19:10:11 <augur> is it?
19:10:49 <Gracenotes> you might have other functions, like killMonster, which you might represent using 'Monster -> State Player Score'. Using the same transformation I described, this becomes like 'Monster -> Player -> (Score, Player)'.
19:11:02 <theguruofreason> right
19:11:30 <Gracenotes> in any case, with monads, you have a nice interface for combining all of these functions to abstract over having-player-state
19:12:17 <Gracenotes> if there's a function that doesn't involve Player at all, it won't need to be in the 'State Player' monad
19:12:54 <ion> To make the behavior of return in the example above explicit: let return' x s = (x,s); (a,s0) = f sInit; (b,s1) = g s0; (c,s2) = h s1; (d,s3) = h s2; (result, s4) = return' (a,b,c,d) s3 in result
19:13:22 <theguruofreason> right
19:13:31 <Gracenotes> though they're not always that useful necessarily, since your abstraction needs will possibly differ from program to program
19:15:28 <ion> theguruofreason: This may or may not be useful: http://heh.fi/state-monad
19:15:58 <theguruofreason> so do I need to modify my "removeItem" function?
19:16:03 <Gracenotes> theguruofreason: but mainly, do you see why takeStuff can have type 'State Player ()'? (I'm not sure what this lower-case 'state' function is, though...)
19:16:16 <ion> @type state
19:16:17 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
19:16:38 <ion> Itâ€™s the equivalent to a State constructor.
19:16:44 <Gracenotes> ah.
19:17:17 <theguruofreason> I've been looking at a few different examples of State, and was trying to follow some example code
19:17:46 <Gracenotes> yes, for the most part, you will only need to use the higher-level access functions provided by MonadState: get, put, modify, gets
19:18:11 <ion> Indeed
19:18:16 <Gracenotes> when using plain State monad in day-to-day codings
19:18:56 <Gracenotes> but, if you want to understand them better, think of State in terms of its definition: as a function
19:19:13 <Guest55594> Yeah I'm unsure what I want to do for state also
19:19:17 <Guest55594> in a similar? context
19:19:38 <Guest55594> though I'm not sure i have a definite question at this time
19:19:41 <Gracenotes> you are composing functions together, but it's not just normal function composition; it's monadic composition. which sounds scary.
19:19:58 <Gracenotes> or, in the case of >>=, monadic application
19:20:12 <Guest55594> though I do 100% understand the state monad
19:20:18 <Guest55594> myself
19:21:00 <Gracenotes> all that 'put' does is construct a function such that, when monadically composed with another function, the second function will receive 's' as whatever put's argument is
19:22:32 <Gracenotes> And all 'get' does is compose a function such that, when monadically composed with another function (a -> State s b), the second function will receive 'a' as the current value of 's'.
19:22:43 <Gracenotes> hm, highly handwavey
19:23:04 <Cale> better just to show the code maybe :)
19:23:07 <Gracenotes> If you're interested in just seeing examples of the State monad being used, there are those, too.
19:23:16 <theguruofreason> I think I got it working...
19:23:28 <theguruofreason> I was overcomplicating it
19:24:41 <Gracenotes> for example, summing over a binary tree. data Tree = Leaf | Node Tree Int Tree. sumIt :: Tree -> State Int (); sumIt Leaf = return (); sumIt (Node l v r) = do { sumIt l; modify (+v); sumIt r; }
19:25:24 <Gracenotes> and you might do: execState (sumIt myTree) 0
19:25:55 <Gracenotes> theguruofreason: nice. for the most part, plumbing aside, using it properly is a matter of convention
19:26:20 <theguruofreason> well, I haven't gotten it working...
19:29:07 <Gracenotes> this one is fun, normalizing a binary tree so its sum is 0. setIt :: Int -> Tree -> State Int Tree; setIt _ Leaf = return Leaf; setIt x (Node l v r) = do { l' <- setIt x l; modify (+v); r' <- setIt x r; return Node l' (v - div x 2) r'; }
19:29:25 <Gracenotes> oh, add extra paren between 'return Node'
19:30:52 <Gracenotes> and then.. lemme see if I can get this right... let (tree', total) = runState (setIt total tree) 0 in tree'
19:31:26 <theguruofreason> I should note that I've only been writing code for a few days, maybe a week
19:31:31 <Gracenotes> (this particular example has no purpose other than being confounding)
19:31:34 <theguruofreason> it's kind of a lot to take in
19:33:17 <Gracenotes> theguruofreason: if you need any help related to your code example, feel free to ask :)
19:34:59 <Gracenotes> also, my example doesn't quite work; you'd need to also divide x by the total number of nodes.
19:35:16 <theguruofreason> yeah, I changed it to "takeStuff :: State Player (); takeStuff = do {modify $ removeItem 'a'; modify $ removeItem 'b'; modify $ removeItem 'c'; modify $ removeItem 'd'}
19:35:28 <theguruofreason> but now it just takes no arguments...
19:35:28 <Gracenotes> ooh, nice
19:35:42 <theguruofreason> so how do I give it a player to do that to?
19:36:14 <Gracenotes> well, you can include as a 'statement' within do notation, and it will transform the state.
19:36:52 <Gracenotes> the function itself does not take any arguments, but the state monad does have a Player argument hidden there.
19:37:37 <theguruofreason> hmmm
19:37:40 <Gracenotes> As for what that Player will end up being at runtime, that will be determined by the initial state, and also by all operations in the State monad when it's called.
19:38:21 <theguruofreason> so to set up an initial state within "takeStuff", I can just use "put"?
19:38:53 <Gracenotes> well, setting an initial state totally means running the State monad. using runState, execState, or evalState.
19:40:18 <Gracenotes> the thing is, you usually don't just hop into the State monad for a bit, modify some things, and pop right out again. Rather, the ambient state pervades everything you do. You can use functions in the State monad, and be used by functions in the State monad, and not worry about explicitly passing around a Player.
19:40:37 <theguruofreason> right
19:40:53 <theguruofreason> I just want to get my feet wet to figure out how it works, because the examples have been baffling to me
19:41:42 <Gracenotes> any particular examples to speak of?
19:42:01 <theguruofreason> well, like I said, the LYAH examples outright don't work
19:42:08 <theguruofreason> like, I copypasted the code
19:42:18 <theguruofreason> because they use State as a data constructor
19:43:12 <Guest55594> yeah just change State to state
19:43:13 <ion> Yeah, change that to state. There used to be a State data constructor.
19:43:27 <Guest55594> but it was made a type alias of StateT Identity
19:43:45 <theguruofreason> so then I kept getting all these type errors talking about StateT
19:43:49 <theguruofreason> was really confusing
19:43:53 <Gracenotes> I kind of lost track of the preferred state of Monad libraries a while ago...
19:44:03 <Gracenotes> you can always just make your own State, anyway
19:44:33 <theguruofreason> yeah, one of the things I love about Haskell is how I can just build stuff from scratch easily if I need it
19:44:34 <Gracenotes> you can even make it as a type, rather than a newtype, if you ignore some other Monad instances
19:45:07 <theguruofreason> Thanks for the help, now that this is working State makes a lot more sense
19:45:17 <Gracenotes> and not having the newtype makes the definitions for >>= clearer, etc. At least I thought, when I was starting out.
19:45:30 <Guest55594> wait
19:45:38 <Guest55594> how can you make a monad instance if it's type and not newtype
19:46:04 <Gracenotes> hm... well... if you pretend really hard (and ghc might need to help you there)
19:46:30 <Guest55594> you can't do it even with ghc's help because that would partially apply a type synonym
19:46:56 <Gracenotes> okay, if you pretend really hard by yourself
19:48:54 <Gracenotes> to inject a value into the State monad, define a function return a s = (a, s). Likewise, get s = (s, s), and put s _ = ((), s).
19:50:23 <Guest55594> put s = const ((), s)
19:50:23 <Gracenotes> and, to apply a function, and abuse some notation, (m >>= f) s = let (a, s') = m s in f a s'
19:50:51 <Gracenotes> yes. everything magically becomes a function which takes an extra argument, though, and returns an extra argument.
19:51:29 <Gracenotes> not quite how it is in practice, but I think it's more clear
19:52:26 <zRecursive> using stack is thread safe though
19:52:45 <Gracenotes> ...maybe... ?
19:55:54 <Gracenotes> Reader monad does have the standard example of replacing an explicit environment argument in the lambda calculus, but I'm not sure if there's such a standard example for State. ah well.
20:04:12 <djahandarie> Hmm, if I have IO (Maybe a), is there a really tight way to get [a] out of that (semantics: keep running the action until it produces Nothing and end the list there)? Or do I need to write it out?
20:04:59 <djahandarie> Whatever it is certainly generalizes to (Monad m1, Something m2) => m (m2 a) though I'm not so sure about what Something is
20:05:59 <johnw> djahandarie: do you mean a function IO (Maybe a) -> IO [a]?
20:05:59 <geekosaur> :t maybeToList
20:06:00 <lambdabot> Maybe a -> [a]
20:06:25 <johnw> yeah, I think fmap maybeToList is what you want, but I can't tell
20:06:33 <elliott> no, not maybeToList
20:06:37 <djahandarie> johnw, yes, that type, not those semantics.
20:06:38 <elliott> "keep running the action until it produces Nothing"
20:06:40 <geekosaur> hm, actually this sounds like some varant of unfold
20:06:43 <johnw> ahh
20:06:44 <johnw> whileJust
20:06:48 <johnw> it's in monad-loops
20:06:59 <elliott> foo m = do { x <- m; case x of { Nothing -> return []; Just y -> (y:) <$> foo m } }, in longhand
20:07:32 <johnw> whileJust :: Monad m => m (Maybe a) -> (a -> m b) -> m [b]
20:07:59 <elliott> @pl \y -> (y:) <$> r
20:08:02 <lambdabot> flip ((<$>) . (:)) r
20:08:02 <lambdabot> optimization suspended, use @pl-resume to continue.
20:08:04 <elliott> @pl \y -> fmap (y:) r
20:08:08 <lambdabot> flip (fmap . (:)) r
20:08:08 <lambdabot> optimization suspended, use @pl-resume to continue.
20:08:11 <elliott> psht.
20:08:15 <djahandarie> :t \x -> x ==> sequence . repeat
20:08:15 <geekosaur> Control.Monad.Loops.unfoldM
20:08:15 <lambdabot>     No instance for (Arbitrary (m0 a0)) arising from a use of `==>'
20:08:15 <lambdabot>     The type variables `m0', `a0' are ambiguous
20:08:15 <lambdabot>     Possible fix: add a type signature that fixes these type variable(s)
20:08:19 <djahandarie> :t \x -> x >>= sequence . repeat
20:08:20 <lambdabot> Monad m => m (m a) -> m [a]
20:08:24 <elliott> djahandarie: maybe you can golf fix (\r -> m >>= maybe (return []) (\y -> (y:) <$> r)) if you don't want a dependency.
20:11:31 <geekosaur> :t sequence . unfoldr
20:11:31 <lambdabot>     Couldn't match type `b0 -> [a1]' with `[m0 a0]'
20:11:31 <lambdabot>     Expected type: (b0 -> Maybe (a1, b0)) -> [m0 a0]
20:11:31 <lambdabot>       Actual type: (b0 -> Maybe (a1, b0)) -> b0 -> [a1]
20:11:37 <geekosaur> bah
20:11:43 <geekosaur> :t unfoldr
20:11:44 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
20:12:08 <geekosaur> oh right, the tuple
20:12:38 <djahandarie> The really annoying part here is that [Maybe a] -> [a] with the semantics I want doesn't exist.
20:12:56 <djahandarie> And catMaybe . takeWhile isJust is fugly
20:13:10 <djahandarie> :t fmap (takeWhile (isJust)) . sequence $ repeat x
20:13:11 <lambdabot>     Couldn't match expected type `f0 (Maybe a0)'
20:13:11 <lambdabot>                 with actual type `Expr'
20:13:11 <lambdabot>     In the first argument of `repeat', namely `x'
20:13:24 <djahandarie> :t fmap (takeWhile (isJust)) . sequence . repeat
20:13:26 <lambdabot> (Monad f, Functor f) => f (Maybe a) -> f [Maybe a]
20:13:26 <OffsetGoose> :t fmap
20:13:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:13:50 <geekosaur> http://hackage.haskell.org/packages/archive/monad-loops/latest/doc/html/Control-Monad-Loops.html#v:unfoldM ? (suggested earlier)
20:13:53 <dobblego> djahandarie: mapMaybe id
20:14:18 <djahandarie> Ah, was this recently added?
20:14:30 <dobblego> nope
20:14:34 <djahandarie> Interesting
20:14:43 <djahandarie> :t mapMaybe id . sequence . repeat
20:14:43 <lambdabot>     Couldn't match type `[a0]' with `Maybe b0'
20:14:43 <lambdabot>     Expected type: [[a0]] -> [Maybe b0]
20:14:43 <lambdabot>       Actual type: [[a0]] -> [[a0]]
20:14:53 <djahandarie> :t fmap (mapMaybe id) . sequence . repeat
20:14:54 <lambdabot> (Monad f, Functor f) => f (Maybe b) -> f [b]
20:15:26 <djahandarie> This should generalize beyond Maybe but who cares! Good enough.
20:15:37 <startling> :t mapMaybe
20:15:37 <lambdabot> (a -> Maybe b) -> [a] -> [b]
20:15:45 <elliott> I think Maybe is tight for the purpose
20:16:00 <startling> oh, I see
20:16:27 <startling> > _1 id (Maybe 1, 1)
20:16:29 <lambdabot>   Not in scope: `_1'Not in scope: data constructor `Maybe'
20:16:44 <startling> :t (_1)
20:16:45 <lambdabot> Not in scope: `_1'
20:16:48 <startling> ???
20:17:14 <djahandarie> (FYI, this is actually for pulling everything possible out of a TChan)
20:17:34 <djahandarie> (Using tryReadTChan)
20:20:51 <flebron> So I want to multiply a and b mod m, where a and b are Int64. Multiplying by dividing one by 2 each time is too slow. So I say a = 2^32 * a_1 + a_2, b = 2^32 * b_1 + b_2, and I compute (a_1 * b_1) * 2^64 + (a_1 * b_2 + a_2 * b_1) * 2^32 + a_2 * b_2. Is there any faster way of computing 2^64 than squaring 2 six times, modulo m? (Saving the one before last as 2^32 mod m, of course.)
20:22:08 <flebron> (And I'm thinking even that could overflow during one of the multiplications :p)
20:22:38 <Guest55594> I'm pretty sure there's a law about multiplying under modulus
20:23:15 <mjrosenb> flebron: if you are on a 64 bit machine, you can just compute (2^32)`mod`m
20:23:19 <mjrosenb> flebron: and then square that.
20:23:45 <mjrosenb> flebron: or you can use arbitrary precision math, since my guess is it will be faster than most things that you do to work around using it.
20:24:07 <flebron> That's what I'm trying to avoid - I was already using Integer, I'm trying to speed things up by using Int64.
20:24:52 <flebron> 2^32 `mod` m may still be 2^32, since m is also 64 bits. Thus squaring 2^32 would go out of range.
20:25:02 <dpwright> I'm playing about with switching stuff to a point-free style (for no good reason, just playing about)
20:25:27 <dpwright> I'm new to it, and one thing that often comes up that I'm not sure of the solution for is where a variable is used inside a bracketed statement somewhere
20:25:40 <dpwright> for example \x -> fromList $ map fromList x
20:26:00 <mjrosenb> flebron: well, that is the last step in the method that you outlined as well.
20:26:01 <dpwright> how would you "extract" the x from those brackets and render that in pointfree style?
20:26:08 <mjrosenb> flebron: ok, how about this
20:26:13 <ion> @src (.)
20:26:13 <lambdabot> (f . g) x = f (g x)
20:26:13 <lambdabot> NB: In lambdabot,  (.) = fmap
20:26:14 <flebron> dpwright: That's fromList . map fromList, isn't it?
20:26:24 <ion> f = fromList, g = map fromList
20:26:29 <johnw> dpwright: you can start with adding another $
20:26:36 <mjrosenb> flebron: 0xffffffffffffffffu `mod` m + 1?
20:26:38 <johnw> \x -> fromList $ map fromList $ x
20:26:39 <dpwright> ...is it that simple?
20:26:41 <johnw> this is equivalent to:
20:26:44 <johnw> \x -> fromList . map fromList $ x
20:26:48 <johnw> and now just drop the x from both sides
20:27:11 <mjrosenb> flebron: with a small check afterwards to ensure that it isn't supposed to wrap around to 0.
20:27:24 <dpwright> oh wow, ok
20:27:50 <dpwright> I think I hadn't realised that fromList $ map FromList $ x is equivalent to fromList . map fromList $ x
20:28:07 <flebron> mjrosenb: How does computing that help?
20:28:12 <dpwright> thanks!
20:28:33 <johnw> go forth and be pointless.. err, free! :)
20:28:38 <dpwright> :-D
20:28:52 <ion> @pl \x -> fromList (map fromList x)
20:28:53 <lambdabot> fromList . map fromList
20:29:11 <mjrosenb> flebron: because 0xff...ffu = 2^64 - 1
20:29:24 <mjrosenb> flebron: and it is exactly representable, as an unsigned int64
20:29:38 <mjrosenb> flebron: then you do the modulus, and add the 1 back.
20:29:46 <flebron> Oh you mean ... `mod` m) + 1
20:29:53 <mjrosenb> err, yes
20:29:59 <mjrosenb> parens. i can parens)
20:30:09 <tabemann> for an unsigned int64 wouldn't one want a Word64?
20:30:12 <flebron> Hrm, that's interesting.
20:32:03 <flebron> mjrosenb: Hrmph. Int64 seems to be signed. :(
20:32:44 <mjrosenb> flebron: well, is m ever going to be negative?
20:33:02 <flebron> Nope.
20:33:08 <flebron> (Nor a nor b.)
20:33:24 <mjrosenb> then there shouldn't be any loss of precision in a cast to uint64 (or word64 as tabemann pointed out)
20:33:40 <mjrosenb> I don't really remember how to cast values in haskell though.
20:33:43 <flebron> Is there uint64 in Haskell?
20:33:49 <flebron> I see Data.Int.Int64
20:33:50 <mjrosenb> it is not something i've ever needed to do
20:33:54 <tabemann> fromIntegral for an integer to an integer
20:34:23 <flebron> Huh?
20:34:26 <mjrosenb> tabemann: I assume it doesn't generate an Integer for something like Int64 -> Word64?
20:34:29 <tabemann> Data.Word.Word64
20:34:51 <flebron> I'll see if the compiler I'm using (online programming competition, old compiler - ghc 6.10) has that.
20:35:12 <mjrosenb> >  0xffffffffffffffff :: Word64
20:35:13 <lambdabot>   18446744073709551615
20:35:21 <tabemann> the Data.Word docs specifically say to use fromIntegral
20:36:12 <flebron> Against all odds, Data.Word.Word64 was imported successfully :o
20:36:49 <flebron> (And ironically, it's my machine, with a newer Haskell platform, that doesn't have it :p)
20:37:16 <mjrosenb> flebron: can you just import Data.Word there?
20:37:17 <flebron> OK, so I'll try with Word64 :)
20:37:21 <flebron> Yep.
20:43:58 * flebron is going to roll the dice with unsafeCoerce :: Word64 -> Int64 >:D
20:45:02 <shachaf> Oh, come on. unsafeCoerce? :-(
20:45:32 <flebron> I looked at the source and there doesn't seem to be a specialization for fromIntegral :: Word64 -> Int64 or viceversa... ;(
20:45:54 <flebron> Plus it feels good to live dangerously for once. My teenage years are gone, this is what I have now.
20:47:33 <johnw> flebron: so you don't care the sign bit?
20:47:36 <johnw> care about
20:48:18 <flebron> Nothing I use will be negative :)
20:48:35 <shachaf> Or bigger than maxBound::Int64?
20:48:44 <johnw> but your type says that they could be :)
20:49:00 <shachaf> Even low-level unboxed GHC code uses an explicit function to convert back and forth Word# <-> Int#
20:49:28 <NemesisD> does MonadPrompt have anything to do with free monads? The use cases i've seen for both seem awfully similar
20:49:38 <johnw> NemesisD: I was thinking the exact same thing
20:49:38 <timbod> Any ubuntu users here?
20:49:53 <DigitalKiwi> I've heard rumor there are lots in #ubuntu
20:50:10 <flebron> A true hSith understands that the power comes from using the entire standard library, you hJedis would never understand. *breathes heavily*
20:50:16 <DigitalKiwi> I think half of them are actually arch users that just watch it for the lulz and troll
20:50:20 <DigitalKiwi> ...
20:50:20 <dmwit> timbod:
20:50:22 <dmwit> ?where justask
20:50:22 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
20:50:26 <timbod> :-) I meant any ubuntu haskell users.
20:50:33 <NemesisD> johnw: i remember a while ago trying to write an HTTP client testing library using free monads and got my ass handed to me
20:50:47 <shachaf> elliott: Can we have a version of ?where that lets us address people directly?
20:50:57 <dobblego> NemesisD: yes it is an instance of Free
20:50:59 <shachaf> And also is less verbose than "?where". Say, "?".
20:51:13 <timbod> I just upgraded to ubuntu 13.04 and find that it no longer has the haskell platform packaged :-(
20:51:24 <dmwit> Perhaps ?> to emphasize that it's aimed at someone (think shells).
20:51:28 <monochrom> right, apt-get individual packages
20:51:40 <johnw> the type for Prompt is a bit hairy
20:51:51 <shachaf> Hmm, newtype Prompt p r = Prompt { runP :: forall b . (r -> b) -> (forall a . p a -> (a -> b) -> b) -> b }
20:51:55 <johnw> yeah
20:51:58 <timbod> Anyone know if the latest platform will work ok with 7.6.2?
20:52:05 <timbod> (It specified 7.6.3)
20:52:18 <shachaf> Looks a bit like a CPSed CoYonedaed Free.
20:52:32 <shachaf> In fact that's what it is.
20:52:38 <johnw> yep
20:52:43 <flebron> You know you're in #haskell when co-Yoneda is a verb.
20:52:46 <shachaf> It's nice how you get rid of the existential via CPSing.
20:52:52 <johnw> i saw the CoYoneda bits, but didn't get the CPS part yet
20:52:53 <elliott> dmwit: you can do this, btw:
20:52:57 <elliott> @@ timbod: @where justask
20:52:57 <lambdabot>  timbod: Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
20:52:57 <dobblego> newtype Free f a = Free (forall b. (a -> b) -> (f (Free f a) -> b)
20:53:18 <elliott> timbod: (sorry for the double ping :) )
20:53:18 <timbod> elliott: I've asked - looks like there is no answer...
20:53:23 <shachaf> Er, wait, it's not what I said at all.
20:53:31 <elliott> timbod: I was just demonstrating the lambdabot functionality
20:53:34 <elliott> should have picked a dummy name, sorry
20:53:38 <shachaf> elliott: That puts a space in front of it, which means some clients won't /hilight.
20:53:50 <dmwit> elliott: cute
20:53:53 <elliott> yes the space should go
20:53:55 <shachaf> Prompt isn't even recursive.
20:54:10 <monochrom> timbod: you want to build from source? then add --enable-unsupported-ghc-version. I haven't tried, but bet high probability of success
20:54:15 <mapreduce> dobblego: I'd love suggestions for improvements to this, apart from the giant consolidateTwo function: http://hpaste.org/90545
20:54:23 <NemesisD> johnw: dobblego was hoping i could rescue the API of my http client testing library with something like free monads. it would be cool to have a testing jig that you swapped in that recorded HTTP calls and faked out responses
20:54:34 <johnw> shachaf: if I change x -> b to f x in that type, I get: f r -> f (forall a. f (p a -> f a))
20:54:35 <elliott> dmwit: you can even do things like link to multiple hackage packages and get it expanded out :)
20:54:39 <elliott> or even...
20:54:49 <dobblego> NemesisD: I just looked at the code for Prompt and it's unclear
20:54:54 <elliott> @@ newbie: 2 + 2 = (@run 2 + 2)
20:54:55 <lambdabot>  newbie: 2 + 2 =   4
20:54:57 <timbod> monochrom: Thanks. Rather than risk that, I think I'll download the generic 7.6.3 binary, and then build the platform from source.
20:55:00 <NemesisD> right now i'm doing by spawning an HTTP server in a thread and using iorefs. the API is a nightmare to use
20:55:29 <dobblego> mapreduce: crikey mate
20:55:32 <timbod> It's pretty crummy that an os upgrade removes tools that previously worked...
20:55:45 <shachaf> Oh, no, the "recursion" is there, I guess?
20:55:56 <shachaf> It's just b in a negative position.
20:56:12 <shachaf> Or something... That's not really right.
20:57:37 <Moggle_> Is it a typical standard in Haskell for when you're modifying a data structure to have it appear as the last argument in a function? ie. for Data.Set you have insert <element> <set>. If I were making a Character type, and made a move function for it, should I make the function moveChar <position> <character>?
20:57:48 <Moggle_> Or is it sort of a haphazard thing?
20:58:00 <sclv> it really depends
20:58:07 <shachaf> It's a whichever-way-is-most-convenient-to-use-it thing.
20:58:07 <sclv> we like to partially apply functions
20:58:18 <sclv> so its nice to say insert 'a' . insert 'b' . insert 'c'
20:58:36 <sclv> so keeping the set last lets it chain them them
20:58:37 <NemesisD> Moggle_: yeah i've heard some suggest the most volatile methods go last
20:58:45 <NemesisD> args* not methods
20:58:56 <shachaf> Which means that if f takes two arguments, x and y, and f-applied-to-y is a useful function and f-applied-to-x is less useful, then y should be the first argument.
20:59:01 <Moggle_> sclv: that would suggest that it IS mostly a standard to put your data structure as the last element, thanks :P
20:59:07 <Moggle_> NemesisD: thanks makes sense
20:59:25 <dmwit> I love Endo. It's so easy.
20:59:51 <ion> You should write an Endo tutorial.
20:59:51 <NemesisD> for stuff like HashMaps its nice because the hash comes last and you can do something like foo = insert "wat" 42 . delete "whatever"
20:59:54 <Gracenotes> the less we have the name things, the better
21:00:02 <Gracenotes> *we have to name things
21:00:10 <elliott> I love categories. they're so easyoid.
21:00:12 <NemesisD> *resists urge to make snoop dogg references when Endo comes up*
21:00:28 <dmwit> Endo tutorial: you just return the same kind of thing as you take, dummy!
21:00:55 <Gracenotes> in this tutorial, you will learn how to say 'append' in Spanish
21:00:55 <ion> TIL http://www.rapdict.org/Endo
21:01:08 * dmwit starts imagining Endo generating sets
21:01:29 <johnw> shachaf: here's what it looks like if I just name all the variables the same and line things up a bit: http://hpaste.org/90547
21:01:46 <elliott> nobody? I thought that one was pretty good.
21:01:59 <NemesisD> ion: thank you. i feel like i've finally contributed something of value to this channel
21:02:00 <sclv> it was goodoid
21:02:02 <shachaf> johnw: It's not Free, it's Program from `operational`.
21:02:02 <johnw> is (forall r. f r -> (r -> b) -> b) â‰… f (Free f a)?
21:02:03 * dmwit groans in appreciation
21:02:06 <johnw> ah
21:02:12 <elliott> thank you.
21:02:32 <elliott> ooh, ooh, I gotta nother.
21:02:38 <elliott> I love semigroups. they're almost easy.
21:02:40 <mjrosenb> flebron: let me know how that UINT_MAX trick goes.
21:02:47 <flebron> I will :)
21:03:01 <mapreduce> dobblego: In particular I'd like to arrange it so it doesn't consume O(n) stack but any style things would be good too.
21:03:02 <sclv> i love fields. they're, uh.
21:03:04 <shachaf> johnw: In this case this is an encoding of data Program p a = Pure a | forall x. Free (f x) (x -> Program p a)
21:03:04 <dmwit> semigroups are monoids with an identity crisis
21:03:04 <sclv> uh.
21:03:17 <mjrosenb> flebron: actually, now that I think about it
21:03:21 <shachaf> In other news I'm really bad at CPS, send help.
21:03:32 <Gracenotes> don't use CPS! use lazy evaluation instead!
21:03:32 <johnw> that's what you get for preferring CoYoneda, clearly :)
21:03:33 <sclv> @remember dmwit semigroups are monoids with an identity crisis
21:03:33 <lambdabot> Done.
21:03:35 <mjrosenb> the only time that you'd end up with 0 is when m == 2^n (for some n)
21:03:45 <Gracenotes> *when possible
21:04:03 <mjrosenb> flebron: which should make the check to see if you need to return 0 rather than n very simple (and should not require another modulo)
21:04:17 <shachaf> Is there a simple mechanical way to CPS/unCPS arbitrary types nicely?
21:04:19 <shachaf> Surely there should be.
21:04:27 <shachaf> Someone should make a lambdabot plugin of it.
21:04:29 <johnw> well, Yoneda does it for functions
21:04:39 <johnw> but I don't know how to do it for types
21:04:40 <shachaf> ?
21:04:43 <shachaf> Oh.
21:04:44 <Gracenotes> CPS is a lot uglier when you think of it as just passing callbacks
21:05:00 <Gracenotes> and transforming callbacks of one type to another type, as you often need to do
21:05:13 <elliott> sclv: I think you have to hate fields
21:05:17 <elliott> they're pretty complicated.
21:05:33 <shachaf> I guess I should call it Boehm-Berarducci.
21:05:37 <shachaf> But I probably won't.
21:05:38 <johnw> so, your Program data type up there is a recursive CoYoneda, I hadn't seen that before
21:05:50 <shachaf> No, Program f a = Free (CoYoneda f) a
21:05:51 <johnw> with a "base case"
21:06:02 <johnw> really?  that's the same thing?
21:06:07 <shachaf> It's the same thing.
21:06:09 <johnw> cool!
21:06:22 <johnw> ah, it's just fusing the two...
21:06:32 <johnw> I see it now, thanks shachaf
21:06:52 <johnw> NemesisD: where did negotiations with free monads break down?
21:07:26 <johnw> shachaf: so, how does Free (CoYoneda f) relate to CoDensity f?
21:07:50 <shachaf> Does it?
21:08:01 <johnw> let me write out the types
21:08:23 <johnw> oh, no, Codensity relates to Yoneda
21:08:39 <NemesisD> johnw: negotiations?
21:08:44 <NemesisD> johnw: like when did i ragequit it?
21:08:46 <johnw> NemesisD: why did they not work for you?
21:08:47 <johnw> yeah
21:08:53 <sclv> elliott: i've learned all this math and all of a sudden i have no intuition for division anymore!
21:09:01 <johnw> being from a parsing background, I'm rather fond of Free monads
21:09:20 <sclv> its like now that i'm stuck on typetheory, if you're more complicated than a semiring, then that's a crime against nature
21:09:31 <NemesisD> johnw: i just didn't understand the underpinnings and couldn't get the types to work out. i think the problem i'm trying to solve may not fit with it
21:09:52 <sclv> like it just _can't_ be a natural structure
21:09:56 <flebron> mjrosenb: Question. So the idea is to compute the following: c1 = a1 * b1, c2 = a1 * b2, c3 = a2 * b1, c4 = a2 * b2, h1 = 2^64 - 1, h2 = 2^32, and then place some (`mod` m) around c1 * h1 + c1 + (c2 + c3) * h2 + c4?
21:10:17 <flebron> (When I say "around" I don't mean around the entire expression, but between some operations.)
21:10:22 <NemesisD> johnw: ideally i'd like the end user to be able to use whatever HTTP library they want, maybe if they write an instance or something, but have a testing free monad that gets fake responses and can record and assert on the requests without doing IO
21:10:25 <johnw> the next free monad project on my list is to write a DSL for building HTTP requests, which can be used with either yesod-test, or http-conduit
21:11:06 <flebron> The issue I see is that c1 `mod` m is an Word64, h1 `mod` m is a Word64, how can I multiply them without overflowing?
21:11:46 <NemesisD> johnw: obvioously i can't get any less intrusive than the solution I chose: spin up a real http server. only requires the user to have a configurable destination host/port, but its slower, more error prone and a GD nightmare to use in something like Hspec
21:11:48 <sclv> ideally you can check the overflow bit after multiplication
21:12:08 <sclv> then optimize the fast path and have a slower path for the harder case
21:12:16 <johnw> NemesisD: I assume you've read Tekmo's articles on using Free to build multiple interpretors?
21:12:48 <NemesisD> johnw: yeah i was brute forcing his examples pretty hard to work out how my testing library would work
21:13:23 <mjrosenb> flebron: what are you trying to compute in the end?
21:15:31 <NemesisD> johnw: i think this problem needs some pair programming or something to get solved adequately. i frequently now find myself needing high-bandwidth feedback on stuff i do in haskell
21:16:19 <flebron> mjrosenb: (a*b) `mod` m
21:16:24 <johnw> well, I wouldn't mind helping out with that
21:16:34 <johnw> learn by trying, and all that
21:16:35 <flebron> Most times it'll be part of a powMod m a b.
21:16:50 <Gracenotes> code review in Haskell is just type signature review, though
21:17:01 <zq> what's the difference between "f g h" and "f . g h"?
21:17:17 <johnw> shachaf: so, Density is not Program, but they don't seem to be too distant from each other: http://hpaste.org/90547
21:17:33 <ion> @src (.)
21:17:33 <lambdabot> (f . g) x = f (g x)
21:17:33 <lambdabot> NB: In lambdabot,  (.) = fmap
21:17:37 <flebron> zg: The first one is f applied to g and h
21:17:41 <ion> zq: â†‘
21:17:44 <johnw> if m is a monad, it builds in the notion of a Pure value
21:17:49 <flebron> The second one is a function \x -> f (g h x)
21:17:58 <elliott> sclv: ah, see, I don't have this problem
21:18:03 <elliott> sclv: I've never been able to do arithmetic
21:18:09 <NemesisD> johnw: i may take you up on that when i muster the the energy to work on this testing library again. i have an HTTP API client with a pretty huge surface area i need to test and i can't bear the thought of using my current library to do it :/
21:18:17 <shachaf> johnw: They seem fairly distant from each other.
21:18:40 <NemesisD> johnw: how would i go about collaborating with you on something like this?
21:18:47 <johnw> shachaf: could it be that they are isomorphic under the condition that m is an instance of Monad?
21:18:51 <shachaf> johnw: Probably what you're getting at is that Density and CoYOneda are both left Kan extensions, or something like that.
21:19:02 <shachaf> johnw: Why?
21:19:04 <johnw> NemesisD: just ping me sometimes, and we can get together on Skype or Google Hangout
21:19:43 <zq> okay, so because currying, f g h == ((f g) h)
21:19:56 <zq> whereas f.g h == (f (g h))
21:19:58 <edwardk> johnw: dolio wrote a nice article for comonad.com showing that the quantification you get when you start playing with this stuff isn't quite right.
21:20:10 <Gracenotes> zq: no, not quite
21:20:29 <johnw> shachaf: well, Program seems to provide this notion of "binding" (via a CPS transformation) and "pure", whereas if m is a monad, you can get both of those functionalities from the underlying Monad and just use >=> on the function part of the Density value.  Or maybe I'm way off
21:20:33 <Gracenotes> the first one is correct, though, f g h is the same as (f g) h
21:20:36 <flebron> f.g h is a function that, given an x, returns f (g h x)
21:20:40 <johnw> edwardk: ah, ok
21:20:55 <zq> flebron: in the case that x = h
21:20:59 <Gracenotes> but that's not because of currying, that's just because of associativity of function operation.
21:21:02 <shachaf> edwardk: Hmm, let me just go to comonad.com and...
21:21:04 <flebron> zq?
21:21:13 <Gracenotes> er, application
21:21:16 <edwardk> shachaf: johnw downloaded them all as PDFs or something ;)
21:21:16 <johnw> edwardk: do you remember the title?
21:21:23 <johnw> http://comonad.newartisans.com
21:21:25 <edwardk> johnw: it'd be one of the most recent ones
21:21:26 <flebron> x need not be h, zq.
21:21:33 <johnw> oh, my mirror stops at Sep 2012 :(
21:21:45 <johnw> unless it was that first one on my mirror
21:21:49 <zq> flebron: yes, but i'm leaving out the 'x' altogether since functions are first class objects
21:21:50 <johnw> "Unnatural Transformations and Quantifiers"
21:21:54 <edwardk> unnatural transformations and quantifiers.
21:21:57 <edwardk> yeah
21:22:00 <johnw> yay, I have it!
21:22:04 <johnw> that's the last article I mirrored
21:22:11 <flebron> zq: Right, I am simply using it to tell you the difference between f g h and f . g h.
21:22:26 <Gracenotes> f . g h = \x -> f (g h x). There's no other way of phrasing it, modulo renaming x other things. The dot hides the fact that there's an explicit parameter, but there still is one.
21:22:30 <zq> so what about f $ g h?
21:22:32 <flebron> f g h is a value, not necessarily a function, that is equal to ((f g) h).
21:22:43 <flebron> f . g h is necessarily a function, and when you give it any x, it returns f (g h x).
21:22:50 <Gracenotes> Using ($), or the function application operator, f $ g h == f (g h).
21:23:08 <zq> flebron: f . g h is necessarily a function?
21:23:13 <flebron> Yes.
21:23:15 <zq> flebron: i thought not
21:23:18 <Gracenotes> :t (.)
21:23:19 <lambdabot> (b -> c) -> (a -> b) -> a -> c
21:23:25 <flebron> When in fact, it is.
21:23:33 <Gracenotes> given two function arguments, you get (a -> c), which is a function.
21:23:50 <flebron> (f .  g h) x = f (g h x).
21:24:17 <Gracenotes> in this example, x has the type a, whatever that ends up being
21:25:57 <roboguy_> :t let (f, g, h) = (undefined, undefined, undefined) in f . g h
21:25:58 <lambdabot> a -> c
21:26:41 <zq> no
21:26:54 <zq> lebron: f.g is necessarily the function
21:27:02 <zq> Gracenotes: there is no parens around a->c
21:27:08 <flebron> f . g h is f . (g h).
21:27:17 <flebron> It is not (f . g) h.
21:27:17 <Gracenotes> it's the way things are grouped
21:27:31 <roboguy_> zq: my example with lambdabot showed how f . g h is always a function
21:27:32 <ekipan> function application binds tighter than every operator
21:27:49 <Gracenotes> a -> b -> c is the same as a -> (b -> c).
21:28:06 <zq> (f.g) 4
21:28:09 <Gracenotes> the way Haskell groups things is definitely different than most other languages, but it does make sense in the long run.
21:28:31 <shachaf> I,I foldr1 (->) [a,b,c]
21:28:35 <roboguy_> zq: (f . g) h is not the same as f . g h
21:28:54 <roboguy_> not in haskell, anyway
21:28:55 <Gracenotes> and, yes, (f.g) 4 is the same as f (g 4), :)
21:31:30 <ekipan> @src (.) -- the entire definition of (.), it's an operator that takes 3 arguments, and when it gets them, you can substitute its use with the rhs of its equals sign
21:31:30 <lambdabot> Source not found. Wrong!  You cheating scum!
21:31:35 <ekipan> @src (.)
21:31:35 <lambdabot> (f . g) x = f (g x)
21:31:35 <lambdabot> NB: In lambdabot,  (.) = fmap
21:33:56 <ekipan> an equivalent way to write that definition that maybe shows its relationship to its arguments more clearly: (.) f g x = f (g x)
21:34:34 <zq> ok grokked
21:34:36 <zq> thanks
21:35:00 <zq> :t ($)
21:35:00 <lambdabot> (a -> b) -> a -> b
21:35:27 <ekipan> @src ($)
21:35:27 <lambdabot> f $ x = f x
21:35:29 <ekipan> even simpler
21:35:56 <zq> is that some magical lambdabot-centric thing? @src doesn't work in ghci
21:36:10 <dmwit> Yes, lambdabot does many things that ghci does not.
21:36:12 <ekipan> it's a lambdabot command, yes
21:36:13 <dmwit> ...and vice versa
21:37:52 <Gracenotes> zq: it just looks up stuff here. http://new-hackage.haskell.org/package/lambdabot-4.2.3.3/src/State/source
21:37:56 <elliott> it also lies.
21:38:09 <elliott> for instance @src (.) lies.
21:38:25 <Gracenotes> It is the a priori correct way to implement any of these functions
21:38:42 <Gracenotes> and, if you use certain flags with GHC, it is the ones GHC will use
21:38:51 <Gracenotes> ...in some cases
21:46:07 <zq> you guys rock
21:46:11 <zq> Gracenotes: thanks
21:46:13 <zq> flebron: thanks
21:46:17 <zq> roboguy_: thanks
21:46:19 <zq> ekipan: thanks
21:46:22 <flebron> :)
21:46:55 <roboguy_> sure!
21:46:58 <ekipan> @botsnack
21:46:58 <lambdabot> :)
21:47:05 <ekipan> she needs thanks sometimes too
21:47:09 <Aetherspawn> > let data Expr = Int Int in 1 `Expr` 2
21:47:10 <lambdabot>   <hint>:1:5: parse error on input `data'
21:47:38 <Aetherspawn> is infix data legit? :P
21:47:46 <Aetherspawn> *data constructors
21:48:05 <shachaf> Yes, but your declaration has multiple errors.
21:48:23 <ekipan> data type declarations in let expressions are less legit
21:48:58 <ekipan> you can have operator constructors, they have to start with :
21:49:03 <ekipan> like (:) for instance
21:53:09 <shachaf> What's the CPS-Church-BB-etc. encoding of newtype Fix f = Fix (f (Fix f))?
21:53:21 <shachaf> Is it newtype Fox f = Fox (forall r. f r -> r)?
21:53:38 <shachaf> That seems pretty fishy.
21:53:48 <Moggle_> Is there a nice easy attribute I can add to a .cabal to have my files be sent to bin/ in the local dir?
21:53:50 <fyuckwack> where do i find 2-3 year sold porn mags online
21:53:55 --- mode: ChanServ set +o shachaf
21:54:01 --- mode: shachaf set +b *!*wack@120.142.190.*
21:54:01 --- kick: fyuckwack was kicked by shachaf (fyuckwack)
21:54:04 --- mode: shachaf set -o shachaf
21:56:00 <kfish> Moggle_, http://hackage.haskell.org/trac/hackage/ticket/289
22:00:24 <flebron> > let a = 14708155195 :: Word64; b = 14708155195 :: Word64; m = 50614917089 :: Word64; a' = fromIntegral a; b' = fromIntegral b; m' = fromIntegral m; in (a*b `mod` m, a'*b' `mod` m')
22:00:28 <lambdabot>   mueval-core: Time limit exceeded
22:00:50 <flebron> Pfft. That's not what you said in /query. (3214129763,19585940240).
22:01:41 <flebron> Specifically,
22:01:42 <flebron> > let a = 14708155195 :: Word64; b = 14708155195 :: Word64; a' = fromIntegral a; b' = fromIntegral b; in (a*b, a'*b')
22:01:43 <lambdabot>   (13415644429400420249,216329829240205488025)
22:01:46 <kvda> is 'let x <- f2; f1 x" not the same as 'f1 =<< f2'?
22:01:50 <kvda> minus the let
22:02:20 <Moggle_> kfish: I meant something like setting -outputdir bin/ on ghc
22:02:33 <Aetherspawn> How can I grab a letter starting at A corresponding to a number
22:02:38 <monochrom> "let x <- f2" is a syntax error
22:02:42 <Moggle_> kfish: which almost works but cabal moves my compiled binaries to ~/.cabal/bin
22:02:44 <Aetherspawn> to A, B, C from 1, 2, 3 for example.
22:02:46 <ekipan> given s/let/do/ it is
22:02:55 <Moggle_> kfish: i don't want my compiled binary to go to there.
22:03:03 <Aetherspawn> in C I would use ('A' + n) because of the ascii table.
22:03:12 <flebron> > chr 65
22:03:13 <lambdabot>   'A'
22:03:20 <Aetherspawn> ah, awesome.
22:03:30 <Aetherspawn> :t chr
22:03:30 <lambdabot> Int -> Char
22:03:46 <shachaf> Aetherspawn: Please note that ASCII is not supported.
22:03:49 <shachaf> Char is a Unicode codepoint.
22:03:55 <ekipan> that's the definition of do-notation desugaring: do { x <- y; z } = x >>= \y -> z
22:04:08 <kfish> Moggle_, yes I think that would be good too .. that ticket seemed to start like that (talking about --bindir) but devolved into a discussion of symlinking ~/.cabal/bin insted :/
22:04:15 <ekipan> (modulo "fail" fail)
22:04:35 <ekipan> er, switch the x and y on the rhs
22:04:41 <Moggle_> i suppose i will look into writing my own Setup.hs
22:04:45 <johnw> chrisdone: morning
22:09:35 <Moggle_> why must cabal make this overly difficult
22:09:47 <Moggle_> i just want my compiled application to go into bin/
22:09:53 <Moggle_> not ~/.cabal/bin
22:10:34 <johnw> Moggle_: --bindir=?
22:10:35 <elliott> Moggle_: you can configure that in ~/.cabal/config, I think.
22:10:50 <elliott> it's not something you should change in Setup.hs or such; that's the wrong place for user configuration like this
22:11:10 <elliott> yeah there is a bindir setting in ~/.cabal/config
22:11:15 <monochrom> Moggle_ means the author of a package wants to use project.cabal to override user's --prefix
22:11:26 <Moggle_> johnw: can that be set in the .cabal file for my package?
22:11:42 <dmwit> Moggle_: Oy! You!
22:11:44 <monochrom> as a user I support making that difficult
22:11:44 <johnw> you sure your users want that?
22:11:54 <dmwit> Moggle_: I'm the guy building your package, *I* get to say where your binaries go.
22:12:14 <Moggle_> johnw: no I suspect I am fundamentally confused on the matter at this point and missing something important
22:12:28 <elliott> dmwit++
22:12:31 <johnw> well, you can say cabal install --bindir=/bin for your side
22:12:35 <elliott> this is a setting about how you install packages
22:12:35 <johnw> but for our side, we want ~/.cabal/bin
22:12:38 <elliott> it goes in your local configuration
22:12:43 <elliott> and it is already supported there
22:12:53 <johnw> yes, you can also set bindir in ~/.cabal/config
22:12:53 <Moggle_> dmwit: I am trying to make a game here, and the game depends on a media/ folder, so it should sort of stick everything in the same folder
22:12:58 <Moggle_> perhaps I should not be using cabal for this
22:12:58 <elliott> your packages should not tamper with it any more than they should adjust the user's desktop theme to be more aesthetically appealing :)
22:13:05 <Moggle_> however I don't want to have to do a makefile here
22:13:14 <elliott> Moggle_: cabal supports installing additional files with your program and accessing them programmatically
22:13:35 <elliott> http://neilmitchell.blogspot.co.uk/2008/02/adding-data-files-using-cabal.html has a quick summary
22:13:38 <elliott> might be slightly outdated
22:13:42 <Moggle_> thanks elliott i'll take a look
22:14:20 <monochrom> cabal has a manual. http://www.haskell.org/cabal/users-guide/  read it fully, you need it
22:14:50 <dmwit> Moggle_: Believe me, you are not the first person to write a program that uses some resources that go in external files.
22:16:50 <elliott> dmwit is right, I wrote the first such program last tuesday.
22:17:30 <Moggle_> dmwit: I suspect the problem at this point is that I'm just plain unfamiliar with linux and where files are installed to. My intended use is to 1) download the package with the source files and data from github (or something else), then type "cabal install" and now presto the game can be played in bin/.  Given your objections, I suspect this is not how things are normally done on linux.
22:18:11 <Moggle_> I suppose it has to do with the whole "make && make install sort of thing"
22:18:32 <Moggle_> uh i messed up the quotes on that but yeah I'll just go find some games on hackage and see how they're compiled now :D
22:21:31 <monochrom> you are ignoring what was said about ~/.cabal/config above
22:22:43 <dmwit> Moggle_: "cabal build" will put a binary in dist/binary-name/binary-name
22:23:00 <dmwit> But I object to giving the package author control over where "cabal install" puts things.
22:23:04 <dmwit> This is *my* system, not yours.
22:24:01 <mjrosenb> aaand uniplate built for me!
22:24:39 <Moggle_> monochrom: sorry, didn't mean to make it seem like I was ignoring you, but ideally I'd like my solution to work for people other than me!
22:25:00 <Moggle_> dmwit: yeah I can understand the issue with package authors dictating where the binaries should end up now
22:26:10 <monochrom> ~/.cabal/config is precisely set by people other than you
22:26:11 <Moggle_> dmwit: THAT SAID, I suppose I'm used to being able to actually uninstall things. With a game, if it's a few gigabytes, ideally I'd like to be able to get rid of that with ease later.  putting files in a nice bin/ which is where I downloaded the source seems pretty much ideal.
22:26:49 <Moggle_> dmwit: so I suppose it's the --bin-dir option for me!
22:29:36 <mjrosenb> /usr/lib/gcc/powerpc64-unknown-linux-gnu/4.7.3/../../../../powerpc64-unknown-linux-gnu/bin/ld: cannot find -lHSrts_thr
22:29:41 <mjrosenb> *grumble*
22:30:02 <mjrosenb> so... cabal-install requires threading?
22:30:13 <monochrom> I like to erase easily too. precisely why I use "cabal install --prefix=/sandbox" and the package author must not disobey it
22:31:52 <jamie-> is there a http client library with support for cookies and post request?  I want to programatically log into some web page and then extract some data from it
22:32:25 <Moggle_> monochrom: yeah, that makes sense. as I said, I was dumb earlier and confused on things. too used to windows installers.
22:32:47 <aleator_> jamie-: http-streams should do.
22:33:00 <jamie-> thanks
22:33:16 <monochrom> windows installers precisely let the user have the final say on which directory to put files, too.
22:39:15 <jzelinskie> hh i get it
22:39:18 <jzelinskie> oops
22:40:26 <jzelinskie> wrong channel :s
22:49:28 <NemesisD> using the list monad, is there any way to pull an arbitrary number of values out of the monad?
22:49:58 <NemesisD> i don't know if that actually makes sense
22:50:15 <shachaf> It doesn't. :-)
22:50:18 <monochrom> perhaps logict does what you want
22:50:30 <shachaf> Firstly because "the monad" means the type (constructor) [], not any value.
22:51:01 <NemesisD> monochrom: i'm actually toying with oleg's(?) FBackTrack, which is like logict i think
22:51:20 <shachaf> But also you should clarify what you mean, I think.
22:51:41 <NemesisD> i'm toying around with a cart optimization algorithm. i took a look at the bin packing problem and its not quite what i'm after.
22:52:06 <startling> NemesisD, do you know what return and >>= are for the list monad?
22:52:59 <NemesisD> http://hpaste.org/90551
22:53:22 <NemesisD> startling: not quite
22:54:05 <startling> NemesisD, well, "return" is easy
22:54:48 <startling> (what's the obvious function of type a -> [a]?)
22:55:19 <shachaf> I can think of three obvious functions.
22:55:27 <NemesisD> startling: (:[])
22:55:30 <shachaf> (And an unlimited number of ones that aren't obvious.)
22:55:37 <NemesisD> aka king kong face
22:56:27 <startling> NemesisD: right. and (>>=) :: Monad m => m a -> (a -> m b) -> m b, so what kind of operation is [a] -> (a -> [b]) -> [b]?
22:56:38 <startling> shachaf, looks like NemesisD has a better intuition than you
22:57:04 <NemesisD> aww yiss
22:58:06 <NemesisD> startling: concat . map ?
22:59:19 <startling> NemesisD: almost
22:59:24 <startling> :t concat . map
22:59:26 <lambdabot>     Couldn't match type `[a1] -> [b0]' with `[[a0]]'
22:59:26 <lambdabot>     Expected type: (a1 -> b0) -> [[a0]]
22:59:26 <lambdabot>       Actual type: (a1 -> b0) -> [a1] -> [b0]
22:59:36 <FreeFull> :t concatMap
22:59:36 <lambdabot> (a -> [b]) -> [a] -> [b]
22:59:41 <startling> FreeFull: shhh
22:59:43 <Moggle_> here's another dumb cabal question: i've got a bunch of dlls from the gtk, how can I ensure cabal install gets the dlls into wherever the exe ends up?
23:01:51 <dpwright> t
23:05:19 <dmwit> :t (concat .) . map
23:05:20 <lambdabot> (a1 -> [a]) -> [a1] -> [a]
23:05:34 <elliott> it's ok to say \f -> concat . map f, people.
23:05:44 <shachaf> elliott++
23:05:47 <dmwit> Moggle_: That's trickier, I think.
23:05:47 <startling> :t concat .: map
23:05:48 <lambdabot>     Not in scope: `.:'
23:05:48 <lambdabot>     Perhaps you meant one of these:
23:05:48 <lambdabot>       `.' (imported from Data.Function),
23:06:02 <ekipan> or even \f x -> concat (map f x)
23:06:02 <NemesisD> ahh ok i was trying to think of some wacky point free way to express it
23:06:09 <startling> NemesisD: heh
23:06:22 <ekipan> points are your friends!
23:06:26 <startling> NemesisD: anyway, do you have a little intuition for what someList >>= someFn does?
23:08:09 <NemesisD> startling: yeah. it maps the function over the list and joins the results
23:08:41 <startling> NemesisD: right. can you phrase "pull an arbitrary number of values out" in terms of that?
23:08:54 <NemesisD> [1..5] >>= (return (*2)) will double everything, [1..5] >>= replicate 3 will repeat everything in order
23:09:13 <Moggle_> dmwit: uh, where do I start on something like that?
23:09:34 <FreeFull> > do { x <- [1..5]; []; return x }
23:09:36 <lambdabot>   []
23:10:51 <NemesisD> startling: i was more referring to do notation, if you do f list = do { x <- list; y <- list; return (x,y); } it permutes the list, like [(x,y) | x <- list; y <- list ]
23:11:53 <johnw> NemesisD: I think you meant: return . (*2)
23:11:55 <FreeFull> NemesisD: list comprehensions get desugared to the monad
23:12:28 <elliott> that's not really true.
23:12:41 <elliott> list comprehensions get desugared to concatMap and filter and stuff.
23:13:18 <dmwit> Moggle_: Tell your users to install gtk and then your program. ;-)
23:13:31 <dmwit> Moggle_: Or learn how to make real Windows installers.
23:13:45 <NemesisD> NemesisD: so the thing i'm getting at is that i'm trying to come up with a way to optimize carts given several store inventories, which seems like it requires some manner of traversing the problem space and comparing the results
23:13:52 <dmwit> Moggle_: But I mean, if "cabal" is your deployment plan, you can expect to have to have some prerequisites.
23:15:23 <NemesisD> im not sure why i addressed that to myself. it must be getting late
23:15:53 <neutrino_> typical for being tired
23:15:55 <neutrino_> go to sleep
23:15:55 <dmwit> Moggle_: (I feel that, generally speaking, you are picturing "cabal" as not being a tool that builds things from source. It's just an entirely different experience than your typical Windows binary installation process.)
23:16:05 <FreeFull> NemesisD: maybe guard from MonadPlus?
23:16:10 <FreeFull> :t guard
23:16:11 <lambdabot> MonadPlus m => Bool -> m ()
23:16:48 <FreeFull> > [1..5] >>= \x -> guard (x /= 3)
23:16:49 <lambdabot>   [(),(),(),()]
23:17:01 <FreeFull> > [1..5] >>= \x -> guard (x /= 3) >> return x
23:17:02 <lambdabot>   [1,2,4,5]
23:17:34 <NemesisD> FreeFull: not sure if guard is enough. what i'm really doing is trying to find the relative best cart out of all possible carts
23:17:54 <FreeFull> NemesisD: Something like a maximum?
23:17:58 <Moggle_> dmwit: I'm just trying to get a build system down to one nice command here. I mean, my ideal situation is that I download my source from github/hackage, then type "cabal install" and have everything to be zipped up or turned into a windows installer for end users in bin/
23:18:27 <Moggle_> I've never done anything like this before and just want to figure it out. cabal doesn't seem like the right tool for it I guess!
23:18:32 <NemesisD> FreeFull: yeah if i was sorting, the best cart would be the lowest priced with the least number of shipments, preferring lower price
23:18:47 <NemesisD> FreeFull: i've been reading a bit about  backtracking monads like logict and trying to figure out if they could help
23:19:02 <FreeFull> NemesisD: Then why don't you sort? I don't really thing that's a problem you need monads for
23:19:11 <FreeFull> :t sortBy
23:19:11 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
23:19:19 <neutrino_> are you people doing logistics?
23:19:23 <carter> how does lambda bot get added to a new channel?
23:19:38 <johnw> ask Cale
23:19:50 <johnw> he's in #ledger, and I don't even know how he got there :)
23:19:50 <Cale> ask elliott
23:19:52 <carter> Cale it'd be cool to add lambdabot to #haskell-llvm :)
23:19:55 <dmwit> Moggle_: Yes, cabal is not a tool for building installers. It is a tool for building programs.
23:19:57 <johnw> he must roam
23:20:11 <carter> elliott see about: lambda bot for #haskell-llvm
23:20:22 * hackagebot byteable 0.1.1 - Type class for sequence of bytes  http://hackage.haskell.org/package/byteable-0.1.1 (VincentHanquez)
23:20:22 <NemesisD> FreeFull: the problem is NP-hard and i was looking into some specialized monads for stuff like the knapsack problem and the bin fitting(filling?) problem that may have some heuristics i could take advantage of
23:20:33 <carter> johnw once i have some dev machines, might be fun to have a sandboxed labmdabot with llvm bindings :)
23:20:39 <elliott> johnw: I run lambdabot now, btw
23:20:40 <elliott> @join #haskell-llvm
23:20:47 <carter> YAY
23:20:48 <elliott> carter: want that on the permament join list?
23:20:54 <carter> elliott at least for now
23:21:06 <carter> would be handy to have the tells be on that channel between the folks using it
23:21:27 <elliott> it is done
23:22:24 <carter> woot
23:22:42 <FreeFull> NemesisD: Are you sure it is np-hard?
23:23:14 <startling> :t _1 -- elliott: what happened to lens?
23:23:14 <lambdabot> Not in scope: `_1'
23:23:35 <elliott> startling: it is waiting for me to recompile, will do today or tomorrow
23:23:42 <NemesisD> FreeFull: i have been lead to believe it is, as it resembles a lot of known problems that are/i think i saw a SO post saying it was
23:23:42 <startling> ah, k
23:23:45 <elliott> you can @let import parts of it piece by piece
23:23:50 <elliott> but any time anyone @undefines it goes away :P
23:24:20 <dmwit> Moggle_: Personally, I'd work on making something that people want to install before trying to figure out how to make the installer. =)
23:29:29 <NemesisD> attempting to solve np-hard problems at midnight when i have work tomorrow seems like a pretty good idea
23:29:41 <NemesisD> haskell just has a typeclass for that right?
23:31:27 <startling> np-hard problems aren't *that* hard
23:31:37 <startling> especially from the programming point of view
23:32:05 <NemesisD> startling: i should mention i solved this very problem some time ago when i was much newer to haskell. solved it naively using lists
23:32:13 <NemesisD> as you'd expect, it is dog slow
23:34:24 <dmwit> NP hard? Throw it at a SAT solver.
23:35:06 <startling> dmwit, I guess the SAT must have gotten harder since I was in high school
23:37:14 <NemesisD> dmwit: are there any in haskell? i've done the most cursory research into sat solvers and concluded it was above my pay grade ;)
23:38:49 <neutrino_> well haskell is turing complete isn't it
23:39:33 <startling> > let a = a in a
23:39:36 <lambdabot>   mueval-core: Time limit exceeded
23:40:01 <dmwit> NemesisD: Um. I dunno. I think there's Haskell bindings to ones written in other languages?
23:40:41 <shachaf> People in this channel should deCPS types for me.
23:40:51 <shachaf> Like forall r. ((forall a. a -> r) -> r) -> r
23:42:06 <roboguy_> NemesisD: I made a brute force SAT solver in haskell not too long ago
23:42:20 <dmwit> forall r. ((((forall a. a -> r) -> r) -> r) -> r
23:42:21 <dmwit> go
23:42:36 <dmwit> ...
23:42:37 <dmwit> ) -> r
23:43:32 <neutrino_> (((((((((((forall a. a ...
23:44:16 <roboguy_> NemesisD: it's not as efficient as it could be, but here it is http://pastebin.com/vr7c6Gu3
23:45:06 <shachaf> OK, let's see.
23:45:20 <shachaf> data Foo = Foo becomes forall r. r -> r
23:45:22 * hackagebot securemem 0.1.1 - abstraction to an auto scrubbing and const time eq, memory chunk.  http://hackage.haskell.org/package/securemem-0.1.1 (VincentHanquez)
23:45:32 <shachaf> data Foo = Foo Foo becomes forall r. (r -> r) -> r -- like, whoa, man
23:45:46 <shachaf> An inhabitant of Void is fix.
23:46:23 <shachaf> Something like forall r. Int -> r is uninhabited.
23:46:40 <shachaf> Does that even translate to anything in data declarations? Probably not.
23:49:31 <shachaf> We're talking about data here, by the way, not codata. Or something.
23:49:44 <shachaf> Nat is forall r. (r -> r) -> r -> r
23:50:09 <NemesisD> ok i'm officially too tired to try to figure out how i'd use a sat solver to solve my high-level problem. i think i'm off to bed
23:50:47 <shachaf> Existentials turn into universals, naturally.
23:52:10 <shachaf> data CoYoneda f a = forall x. CoYoneda (f x) (x -> a)
23:52:37 <shachaf> Foo f a = forall r. (forall x. f x -> (x -> a) -> r) -> r
23:52:41 <shachaf> Straightforward enough.
23:52:58 <shachaf> From before:
23:53:02 <shachaf> data Program p a = Pure a | forall x. Free (f x) (x -> Program p a)
23:55:05 <shachaf> newtype Prompt p a = Prompt { runP :: forall r. (a -> r) -> (forall x. p a -> (x -> r) -> r) -> r }
23:55:13 <shachaf> So far so good, I guess.
23:55:28 <shachaf> The mildly confusing part is the r in the positive position, but that's just because we have an actual function.
23:56:13 <shachaf> So forall r. ((forall a. a -> r) -> r) -> r should be... data Foo = Foo (forall a. a -> Foo)?
23:56:49 <shachaf> This seems like a bit of a monologue.
23:57:29 <mauke> I,I dreaded monoloquism restriction
23:57:30 <zRecursive> because it it hard to understand
23:58:10 * zRecursive "forall a" always make code messy 
23:59:01 <shachaf> My mind is the thing that's messy right now.
23:59:12 <zRecursive> heh
23:59:26 <shachaf> data Foo = Foo Int ---> forall r. (Int -> r) -> r
23:59:34 <shachaf> data Foo = Foo (Int -> Foo) ---> forall r. ((Int -> r) -> r) -> r
