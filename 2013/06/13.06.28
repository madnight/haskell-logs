00:00:25 <shachaf> OK, so if you nest foralls one more level, it becomes unexpressible without making a new data type or using first-class existentials, or leaving the foralls as is?
00:01:00 <shachaf> E.g. forall r. (((forall a. a -> r) -> r) -> r) -> r
00:01:06 <shachaf> Someone else should do that one for me.
00:01:23 <mjrosenb> shachaf: i'm not entirely sure what you are doing.
00:01:28 <zRecursive> one head two big
00:01:50 <shachaf> mjrosenb: Hmm, knowing that would make my life a lot easier.
00:01:56 <zRecursive> from the nested forall
00:02:45 <shachaf> mjrosenb: I want to automatically convert data types from/to this CPS/boehm-berarducci encoding.
00:03:06 <shachaf> I was just trying to figure out what happens with odd cases like deeply nested foralls.
00:03:16 <shachaf> But it probably doesn't matter much.
00:03:58 <shachaf> GADTs become "easy", or alternatively impossible.
00:04:01 <shachaf> I'll go with easy.
00:10:22 * hackagebot xml-lens 0.1.2 - Lenses, traversals, prisms for xml-conduit  http://hackage.haskell.org/package/xml-lens-0.1.2 (FumiakiKinoshita)
00:35:09 <shachaf> How do you CPS/BB/whatever-encode non-regular data types?
00:35:25 <shachaf> data Tree a = One a | Two (Tree (a,a))
00:39:28 <elliott> shachaf: something like (forall r. (forall a. a -> r a) -> (forall a. r (a,a) -> r a) -> r a)?
00:39:50 <elliott> just think how you'd write a fold for that Tree.
00:40:04 <elliott> er, alpha rename those inner "a"s.
00:40:38 <shachaf> Hmm.
00:40:55 <shachaf> I'll just say that it's not allowed...
00:41:09 <elliott> why?
00:41:17 <elliott> I think you need to add a parameter to the result to encode types like thi
00:41:17 <elliott> s
00:41:27 <elliott> i.e. when you end up having indices rather than just parameters
00:41:42 <shachaf> Right, I saw that much.
00:41:53 <elliott> also, it mirrors cpsList (:) []
00:41:58 <elliott> because you can do cpsTree One Two
00:42:41 <shachaf> Sure.
00:43:29 <elliott> shachaf: oh, you mean you'll just say that types like that aren't allowed.
00:43:31 <elliott> rather than my translation.
00:43:42 <elliott> you should make it support all types.
00:43:44 <shachaf> elliott: Yes.
00:43:49 <shachaf> Make what support all types?
00:43:54 <elliott> the plugin you're writing.
00:43:58 <shachaf> What plugin?
00:44:01 <elliott> the plugin.
00:44:21 <Aetherspawn> how do I get a random number out of lambdabot
00:44:26 <Aetherspawn> I keep getting an IO type error
00:44:29 <elliott> @dice 1d1000
00:44:29 <lambdabot> elliott: 635
00:44:34 <Aetherspawn> Using eval
00:44:51 <elliott> shachaf: GADTs are pretty easy, I think. data Vec n a where Nil :: Vec Z a; Cons :: a -> Vec n a -> Vec (S n) a ====> forall r. r Z -> (forall m. a -> r m -> r (S m)) -> r n
00:44:54 <elliott> Aetherspawn: you can't
00:45:40 <elliott> shachaf: data Is a b where Refl :: Is a a ===> forall r. r a a -> r a b. that one's very elegant.
00:47:21 <elliott> hmm, or maybe it's forall r. (forall c. r c c) -> r a b.
00:47:26 <elliott> yes, I think it's that.
00:47:40 <elliott> even eleganter since you can't drop a parameter.
00:48:04 <shachaf> I was hoping you could do something like Vec n a = forall r. (Is n Z -> r) -> (Is n (S m) -> a -> r -> r) -> r
00:48:07 <shachaf> But I guess that doesn't work.
00:48:42 <shachaf> Since those two 'r's aren't the same.
00:49:04 <elliott> hey, this way is pretty elegant!
00:49:09 <elliott> r is, like, a relation, man.
00:49:22 <elliott> well, really it's just a motive.
00:49:28 <shachaf> Motive?
00:49:31 <shachaf> If it's so elegant then you write it.
00:49:33 <elliott> as in /Elimination with a motive/.
00:50:01 <elliott> hmm, the CPS form lets you distinguish paulin-mohring and martin-lof equality, unlike GADTs.
00:50:18 <elliott> I think?
00:50:25 <shachaf> What are those?
00:50:33 <elliott> arkeet: what's the type of the eliminator for paulin-mohring equality?
00:50:46 <shachaf> Parameterizing r sounds like a big headache.
00:51:05 <elliott> shachaf: paulin-mohring is like data Eq A (x : A) : A -> Prop where Refl : Eq A x x
00:51:10 <arkeet> elliott: how would I know?
00:51:16 <elliott> martin-lof is like data Eq A : A -> A -> Prop where Refl : Eq A x x.
00:51:32 <elliott> arkeet: you're meant to know everything I need you to know!
00:51:42 <arkeet> I don't know what half those words mean.
00:51:50 <shachaf> arkeet is an expert in graphics drivers.
00:51:52 <elliott> it's ok. shachaf will teach you.
00:51:55 <arkeet> I'm not.
00:52:01 <blackdog> so, what fun things can you do with a haskell program built with ghc that core dumps?
00:52:10 <shachaf> gdb?
00:52:23 <shachaf> Built it with ghc that doesn't core dump?
00:52:28 <shachaf> That's a much better compiler than ghc that core dumps.
00:52:44 <blackdog> yep, tried that. i get two lines - s3GM_info () and 0x0 in ?? ()
00:53:01 <blackdog> i did built it with -fllvm - i'll try again using the standard backend
00:53:01 <mjrosenb> shachaf: dunno, i could probably give you a build of ghc that would compile every program to toilet
00:53:13 <blackdog> shachaf: you know what i mean :)
00:53:14 <mjrosenb> shachaf: but I don' think that is better than one that crashes.
00:53:41 <elliott> ok, I was wrong, you don't get to make the distinction.
00:53:55 <shachaf> blackdog: OK, so look up what s3GM_info is, I guess.
00:54:17 <blackdog> surely that's a ghc-created closure?
00:54:25 <blackdog> where would you look it up?
00:54:37 <shachaf> Can you consistently compile this thing so it crashes?
00:54:46 <shachaf> You can look at the Core and/or Cmm and/or assembly.
00:54:52 <blackdog> sorry, i should be more precise: it doesn't crash in building, it crashes when it runs
00:54:56 <shachaf> mjrosenb: What's better than compiling every program to toilet?
00:55:07 <blackdog> well, it crashed three times in a row just then
00:55:07 <shachaf> blackdog: Sure. But can you build this crashing program reproducibly?
00:55:31 <johnw> finding what s3GM_info is non-trivial, I have tracked down such things often of late
00:55:32 <blackdog> i can, but i can't share this code
00:55:40 <shachaf> OK.
00:55:53 <shachaf> You can build with -debug and try turning on a bunch of debugging options.
00:55:55 <blackdog> ah, doesn't happen without -fllvm
00:55:56 <johnw> blackdog: are you using FFI?
00:56:12 <blackdog> johnw: yes.
00:56:21 <blackdog> zeromq bindings, sqlite, lots of stuff.
00:56:25 <johnw> is this code C++, or does it call back into Haskell?
00:56:55 <blackdog> no callbacks
00:57:03 <johnw> I ask because exceptions do not propagate; they cause an abort at the FFI boundary
00:57:18 <blackdog> whoops, spoke too soon, coredumps without -fllvm too
00:57:56 <johnw> try -debug, as he suggested
00:58:11 <johnw> run under gdb, type "disass", see what the machine code exactly
00:58:22 <thoughtpolice> blackdog: use -debug on linking. there are guides to use GDB for debugging haskell, but it's not really pretty. it's more of a guessing game, boiling down when the thinks will be evaluated
00:58:47 <blackdog> thoughtpolice, johnw: thanks, i'll try that.
00:59:02 <johnw> blackdog: another thing that can cause this problem with FFI code is improper memory management.  You may have things getting garbage collected when they shouldn't be, because you're not using a StablePtr where you should be, for example
00:59:42 <thoughtpolice> blackdog: http://hackage.haskell.org/trac/ghc/wiki/Debugging/CompiledCode?redirectedfrom=DebuggingGhcCrashes
00:59:43 <blackdog> johnw: hm, ok. would have to be a bug in a hackage library, then, i'm doing no direct FFI.
00:59:50 <johnw> blackdog: if you can show me the disassembly, I can make a better guess
01:00:03 <johnw> I spent 4 hours tracking down a bug like this last week
01:00:19 <johnw> ended up being a GHC issue with do-notation of the form "Foo {..} <- expr"
01:00:41 <johnw> (in 7.4.2)
01:01:14 <blackdog> johnw: sure - PM?
01:01:21 <johnw> yes, that will work
01:02:03 <johnw> let's go with hpaste.org
01:02:34 <thoughtpolice> hm, i really need to take the time to look into writing GDB/LLDB plugins for GHC. i think Enigmagic has the beginnings of some scripts for this somewhere, maybe i should steal them.
01:03:04 <thoughtpolice> it's something i've been meaning to do for a while, just dumping info table reps etc and pointing out thunk/closure types makes a pretty big difference in usability
01:03:12 <Enigmagic> thoughtpolice: not sure if it works with modern/recent lldb but: https://github.com/alphaHeavy/ghc-lldb
01:03:24 <thoughtpolice> Enigmagic: yah, that's it
01:04:05 <Enigmagic> lldb has come a long ways since then so it's probably broken but likely easier to get working again
01:04:10 <thoughtpolice> right now i think the best we have is just some GDB macros that only really do anything useful when you're linked -debug
01:04:22 <thoughtpolice> (stuff like pointing out where BaseReg is and whatnot)
01:04:42 <thoughtpolice> Enigmagic: yeah, i haven't kept up with it. it allegedly is getting there on Linux these days and can actually debug things
01:04:52 <Enigmagic> BaseReg moves with -fllvm, so you may need proper debug symbols to track it down
01:06:16 <Enigmagic> but even without it at least printing out closures and various structures in the debugger is much better than using the -debug rts
01:08:58 <Enigmagic> i've gained more gray hair by calling 'call printTSO($rwhatever)' than any other rts function.
01:09:09 <thoughtpolice> lol
01:09:25 <thoughtpolice> yeah that's never a fun one, i found myself there a lot when looking at some LLVM crashes before
01:09:44 <thoughtpolice> David apparently rewrote most of the LLVM backend and pushed it today, i'm hoping it'll be easier to hack on/fix as time goes on
01:10:23 * hackagebot acid-state 0.11.1 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.11.1 (DavidHimmelstrup)
01:10:24 <thoughtpolice> (because invariably it breaks in weird ways during bootstrap or something and the old backend code was getting nasty)
01:11:11 <Enigmagic> gussing that means FB is funding more Haskell :P
01:11:45 <Enigmagic> good to hear though, i'll check it out. hopefully he reduced some of the need for the llvm inliner passes and some other cruft in there too.
01:13:11 <carter> Enigmagic btw hav eyou seen the llvm-general binding?
01:13:31 <thoughtpolice> Enigmagic: it's mostly just a rewrite of the code to clean it up i think, i haven't gone over the diff or anything. i agree it would probably be nice to examine things like what optimizations are needed and whatnot
01:13:36 <carter> thoughtpolice wait it got rewritten tdoay?
01:13:51 <thoughtpolice> i don't think it really fixes any other outstanding problems, other than the code being a bit old and hacky at this point
01:13:52 <Enigmagic> carter: yeah, not useful for me without porting the higher level bindings but it looks like a good effort
01:13:58 <carter> Enigmagic i figured as such
01:14:10 <carter> Enigmagic also i added a #haskell-llvm channel
01:14:15 <thoughtpolice> Enigmagic: also, doesn't David work for some startup now, not FB? :P
01:14:17 <carter> since the mailing list wasn't very safe
01:14:33 <carter> i should crash
01:14:38 <thoughtpolice> 'MemCachier'
01:14:43 <carter> oh yeah
01:14:46 <thoughtpolice> carter: also yes, you can look at the commits. it's a pretty large rewrite
01:15:04 <carter> thoughtpolice also lemme know what else i can do with helping the clang stuff move along...
01:15:21 <thoughtpolice> today i just got really lazy and did not want to read GCC source code after sending that email
01:15:23 * hackagebot ideas-math 1.0 - Interactive domain reasoner for logic and mathematics  http://hackage.haskell.org/package/ideas-math-1.0 (BastiaanHeeren)
01:15:30 <thoughtpolice> which was the only problem :P
01:15:41 <Enigmagic> thoughtpolice: definitely could use some work on selecting a subset of -O2 or -O3 (meant for clang really) to reduce compilation time... and reducing dependencies on mem2reg and the inliner is also pretty easy since the source language is already quite close to correct.
01:16:11 <carter> thoughtpolice k. i'll pester you about it again in a few days, i'm very very nervious about making sure OS X isn't borked :)
01:16:14 <thoughtpolice> Enigmagic: i think with pushes on Cmm we could completely eliminate mem2reg, there are some outstanding ideas about adding Phi nodes to Cmm
01:16:21 <Enigmagic> thoughtpolice: David works for semi-Haskell using startup but they apparently do some other work as well... rumor has it at least.
01:16:35 <thoughtpolice> (or at least there were, i don't think there was any opposition. just nobody did it)
01:16:41 <thoughtpolice> Enigmagic: yeah, 'MemCachier' like i said earlier
01:16:45 <thoughtpolice> neat stuff
01:16:49 <carter> thoughtpolice the Cminusminus spec is no longer online :(
01:17:03 <thoughtpolice> yeah, i have no idea who owns that domain :(
01:17:08 <Enigmagic> right, but (rumor) is that they're doing contract work for fb
01:17:28 <thoughtpolice> Enigmagic: ah, i see
01:17:35 <carter> hehe, cool!
01:18:25 <Enigmagic> also: no fb haskellers come to bayhac or any other bay area haskell things :(
01:18:31 <pharaun> :(
01:18:35 <thoughtpolice> not even bos?
01:18:38 <carter> hrm, i wonder how much overlap there is between the llvm ghc refactor and the llvm-general bindings
01:18:38 <Enigmagic> nope
01:18:41 <carter> sad
01:18:50 <thoughtpolice> he was at bayhac when i was there. FB clearly assimilated him
01:19:05 <thoughtpolice> (this was when he was still doing MailRank, i mean)
01:19:27 <carter> Enigmagic btw I acknwledge the clang llvm  trick being due to you / alpha heavy in my meetup talk last month
01:19:35 <carter> I can't spell anymore
01:19:37 <Enigmagic> carter: :-)
01:19:39 <thoughtpolice> Enigmagic: but yes, i know you guys are big users of the LLVM backend, so if you have any thoughts on stuff like that, always good to hear. the thing with tuning optimizer levels is it just takes forever
01:19:40 <carter> ngiht!
01:19:44 <thoughtpolice> and is a massive amount of boring ass work
01:20:47 <alpounet> thoughtpolice, don did write a couple of scripts or something to try several optimization options and bench which set of options gave the best results, maybe something similar can be useful here
01:20:58 <Enigmagic> thoughtpolice: tuning the optimizer levels is mostly just common sense. don't generate code that requires mem2reg. inline functions when appropriate, etc. the llvm guys recommend the 'easy for C++ library users' apprach that isn't necessarily compatible with fast codegen or functional languages.
01:21:27 <thoughtpolice> Enigmagic: right
01:22:10 <thoughtpolice> alpounet: so, you can do this. it's called ACOVEA (although finding the code is a pain in the ass, the author doesn't even mention it on his homepage anymore.) it basically uses evolutionary algorithms to try and select 'good' compiler options
01:22:34 <pharaun> oh yeah acovea i've used it, i have gotten ok results out of it, but it *can* take a longass time to do its run
01:22:54 <thoughtpolice> Enigmagic: i haven't looked at it too deeply so you're probably much more familiar with the whole setup. but I do know that I spend quite a bit of extra time on my ARM machines in opt doing optimizations, hence why i'd like to see it done
01:23:15 <thoughtpolice> (this is a little extra painful since LLVM is all you get there)
01:24:06 <Enigmagic> thoughtpolice: i haven't tried breaking GHC's passes down much. the first LLVM frontend i wrote for a functional ranking language (~2009) followed a pretty similar pattern to GHC's current llvm backend
01:24:14 <thoughtpolice> pharaun: it took me about 6 hours to get results out of one benchmark with LLVM's options. i decided to do something else rather than spending the next 80 hours doing the rest for all of nofib or something
01:24:27 <thoughtpolice> (80 hours is probably a pretty conservative bet, even)
01:24:48 <gerg> MNB#0000M0&#BN0#0N00M00N0#RM00#0M0#MN0M00M000M0000
01:24:49 <gerg> M0000000#M0M0#MMM0MN#80M~8M0MM0M0M00N00#M0000MNM00
01:24:50 <gerg> 000M0MM00M0N0N000&KRNNL  _###BBN00MMM000N000M00000
01:24:51 <gerg> 0000000000000000#NMM#NM  MMMM0#M00000M000000MM0000
01:24:52 <gerg> 00000M000M000M00M0##M2  -$ K0X0Q#QMM0000000M000000
01:24:53 <Enigmagic> and it spent a huge % of time on optimization passes that made about 0% performance improvement since the emitted bitcode was near optimal
01:24:53 <gerg> 0M00MD&HWN&MN#0N000Q#0_""M&N0#M08&NMM0MM000MMMNM00
01:24:54 <gerg> MMMM00MN0NN00NM#N00MBM#ae#M0NNN#B&D0000M0#000#00MM
01:24:55 <gerg> 0K0##000Q00&B00NNN#N0M61F#00NNRN&0M00=  "MN080#00N
01:24:56 <gerg> M#0&Qg0K00B&@^MMF*W0N&6_E&0MN0RN00NMW#Zc  MNMQBQ8N
01:24:57 <gerg> 0M#00MMQR&H       *8^Q~  - *#0000#f m#B\  0NMDBg#N
01:24:57 --- mode: ChanServ set +o johnw
01:24:58 <gerg> #Q#00NB0&0U        _~`__,_,__#0MM8&2^#p   0#0NRBNM
01:24:59 <gerg> NMM00MMQ0B#0NMgQ&&Q0MNM00@MFMQ&0MN0&trf *u0#QMMM#M
01:25:00 <gerg> 0MN0B&000MpMMBN#&tBM#X#K#    MKX@#7M&' mqM0B#B008N
01:25:00 --- mode: johnw set +b *!~greg@211.37.105.75
01:25:00 --- kick: gerg was kicked by johnw (Kicked)
01:25:03 <alpounet> thoughtpolice, right, acovea, couldn't remember the name, thanks :)
01:25:05 --- mode: johnw set -o johnw
01:25:05 <pharaun> thoughtpolice: some how i am not surprised :)
01:25:06 <alexander__b> no auto kickban on flooding? heh
01:25:07 <thoughtpolice> johnw: thanks
01:25:11 <pharaun> thanks johnw
01:25:21 <gerg> I mean in ancient times the Egyptians used hard muscle-demanding labor to create large pyramids... and stone age people, the neanderthals, needed to burn 5000-6000 calories a day to survive
01:25:23 <gerg> But now people at Amazon use fork lifts, or skyscraper builders use heavy machinery
01:25:25 <gerg> heavy machinery by companies like Hitachi or Kabuto or C.A.T. or whatever requires some object movement by people to make but not that of bodybuilders
01:25:26 <gerg> But now all weight lifting is good for is police, military, or football/sports players
01:25:27 <gerg> Police don't really "contribute" and product to society, but it's always good pay and it's sort of needed
01:25:28 <AleXoundOS_> haha
01:25:29 <gerg> Military is a waste of time and money
01:25:29 --- mode: ChanServ set +o johnw
01:25:30 <gerg> And football players are like playing video games only in real life
01:25:32 <gerg> Throwing a ball around doesn't help other people no matter how much someone is paid
01:25:32 --- mode: johnw set +b *!~stupid@211.37.105.75
01:25:32 --- kick: gerg was kicked by johnw (Kicked)
01:25:51 <alpounet> thoughtpolice, by the way maybe we could write up somewhere a set of options people don't use much but that can help significantly the performances of their code, depending on what kind of code it is
01:25:56 <gerg> 1&QN3A&MMk#MD&WB#p#QM&Q&MNA000000000$  (a$C0#B@$#&Q0&0K
01:25:57 --- mode: johnw set +b *!~asswipe@211.37.105.75
01:25:57 --- kick: gerg was kicked by johnw (Kicked)
01:26:03 <pharaun> *sigh* seriously? :\
01:26:19 --- mode: ChanServ set +o elliott
01:26:21 <gerg>                    ,,_,,,,,,,_
01:26:21 --- mode: johnw set +b *!~johnw@211.37.105.75
01:26:21 --- mode: elliott set +b *!*johnw@211.37.105.*
01:26:21 --- kick: gerg was kicked by johnw (Kicked)
01:26:22 <gspr> Now that's annoyingâ€¦
01:26:22 --- mode: ChanServ set +o shachaf
01:26:23 <alpounet> ban the ip
01:26:28 <alpounet> for now
01:26:30 <johnw> aren't I doing a * ban?
01:26:40 <gerg>                   ```''-,,
01:26:41 <gerg>                           `'.
01:26:41 --- mode: johnw set +b *!~elliott@211.37.105.75
01:26:41 --- kick: gerg was kicked by johnw (Kicked)
01:26:45 <alpounet> he's changing the "username"
01:26:50 <johnw> ah, ok
01:26:50 --- mode: elliott set +b gerg*!*@*
01:26:54 <johnw> one sec
01:26:56 <alpounet> don't remember what it is called in the IRC vocabulary
01:26:59 <Enigmagic> thoughtpolice: the benefit for things like cmm is going to be in register allocation and the like. many structures in the cmm control flow don't line up with that of clang anyways so loop unrolling passes (e.g.) will rarely do anything useful except heat your laptop up :-)
01:27:00 <alpounet> the part before @
01:27:01 --- mode: shachaf set +b *!*@211.37.105.75
01:27:01 --- mode: elliott set +b *!*@211.37.105.*
01:27:06 <elliott> oh dear.
01:27:11 <alpounet> right, now it should be fine
01:27:12 <elliott> we're making a bit of a mess here.
01:27:14 <thoughtpolice> there are a lot of @ out in force, today
01:27:55 <Gracenotes> clever use of idents.
01:28:14 <pharaun> that seems to imply that there's a large subset of compiler opt that can be dismissed
01:28:15 <hkBst> hey over 1K users, when did that happen? :)
01:28:18 --- mode: elliott set -b *!*@211.37.105.*
01:28:22 <thoughtpolice> Enigmagic: yeah, loop unrolling is a pretty rare occurrence i've noticed unless you're doing something that will obviously get fused completely away.
01:28:22 --- mode: shachaf set -bbbb *!~stupid@211.37.105.75 *!~asswipe@211.37.105.75 *!~johnw@211.37.105.75 *!~johnw@211.37.105.75
01:28:24 <elliott> hkBst: quite a while ago
01:28:25 --- mode: shachaf set -bbbb *!*johnw@211.37.105.* *!~elliott@211.37.105.75 *!~greg@211.37.105.75 *!~stupid@211.37.105.75
01:28:28 --- mode: shachaf set -bbbb *!~asswipe@211.37.105.75 *!~johnw@211.37.105.75 *!~elliott@211.37.105.75 *!*@211.37.105.75
01:28:31 <shachaf> help
01:28:35 <elliott> um.
01:28:41 <elliott> you left the IP completely unbanned
01:28:41 <johnw> shachaf: what do you need?
01:28:48 <shachaf> Did I?
01:28:48 <elliott> though they seem to be using the same nick all the time so it probably doesn't matter
01:29:04 <Gracenotes> just ban only the IP, rather than also the ident
01:29:16 <Enigmagic> thoughtpolice: indeed. which is why llvm opt with generic -O2/-O3 passes make little sense for GHC
01:29:21 <Gracenotes> which you did :) anyway, I am not op. I be quiet.
01:29:28 --- mode: shachaf set +b *!*@211.37.105.*
01:29:45 --- mode: johnw set -o johnw
01:29:52 * elliott appreciates op-related advice! I am incompetent.
01:29:58 --- mode: elliott set -o elliott
01:30:04 --- mode: shachaf set -o shachaf
01:30:05 <thoughtpolice> GHC also however doesn't do things like lift tail recursive calls into a direct loop when applicable, so we also may be able to improve some of that. maybe. the optimizers may still have their hands tied in other ways
01:30:10 <johnw> ok, I created a /kickbanip command
01:30:24 * hackagebot hlint 1.8.47 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.47 (NeilMitchell)
01:30:34 <dmwit> All of a sudden I'm glad I'm not an op. If I had been the one laying down bans, I definitely would have banned myself when he used dmwit as an ident.
01:30:40 <dmwit> So... johnw++ for not doing that.
01:30:54 <Aetherspawn> thoughtpolice, use a AWS!
01:30:55 <johnw> haha
01:31:02 <elliott> I think I typed /mode +b johnw for a second
01:31:08 <pharaun> haha
01:32:14 <Aetherspawn> five bucks on a high power machine will get all those optimization evolutions done in a night
01:32:36 <pharaun> probably could get one of those silly large cpu instance on ec2
01:32:41 <dmwit> Do that 100 times and you could buy yourself a high power machine.
01:32:43 <pharaun> and let it run overnight
01:32:51 <thoughtpolice> Enigmagic: on that note, i also haven't really noticed LLVM's vectorizer do very hot on GHC created code either.
01:32:52 <johnw> yes, those large instances are certainly not cheap
01:33:04 <thoughtpolice> but they've significantly improved its tuning over the past few months, too
01:33:07 <Enigmagic> thoughtpolice: just gotta remember that llvm's optimization passes are refined by clang and llvm-gcc use cases and not ghc. just that writing the high level optimization passes in often easier in ghc and the low level passes are already near optimal in llvm.
01:33:08 <Aetherspawn> only needs to be done every 6 months or so, though, right?
01:33:13 <Aetherspawn> every time llvm evolves a little
01:33:15 <johnw> when we forget to spin down a few of mediums after a trial deployment, it's like throwing away a pizza
01:33:15 <thoughtpolice> (and maybe using vector when we get 128bit ops will help that)
01:33:36 <pharaun> johnw: that's painful :)
01:33:36 <thoughtpolice> Enigmagic: oh yeah, we could benefit directly from tail calls -> direct loops in other ways too
01:33:39 --- mode: ChanServ set +o elliott
01:33:43 <thoughtpolice> it may coincidentally help LLVM as well in some cases
01:33:45 <Enigmagic> thoughtpolice: by then intel will have 512 bit registers though ;-)
01:33:52 --- mode: elliott set -b gerg*!*@*
01:34:01 --- mode: elliott set +b gerg*!*@*$#haskell-ops
01:34:02 <thoughtpolice> although really it's the same thing as the loop unroller bit
01:34:03 --- mode: elliott set -o elliott
01:34:06 <roboguy_> does GHC automatically do stream fusion or do you have to use a library to do it?
01:34:09 <elliott> uh
01:34:14 --- mode: ChanServ set +o elliott
01:34:17 <johnw> i want a vector that uses my GPU with pretty much zero (coding) effort from me
01:34:23 <dmwit> elliott: You are making a mess of it. =P
01:34:24 <thoughtpolice> most of the meat is happening pre-CPS in terms of optimization, and post-CPS, LLVM just has nowhere near as much info
01:34:25 <elliott> oh, I guess you can't have overlapping bans.
01:34:37 <thoughtpolice> so direct loopification would probably only pay off in very, very simple cases
01:34:49 <johnw> then it can use 512-bit instructions all it wants
01:34:50 <elliott> dmwit: I was trying to set +b gerg!*@* but +b gerg*!*@*$#haskell-ops, so gerginator2000 would get redirected to -ops but gerg would just be rejected outright
01:34:52 <thoughtpolice> like (Data.Vector.map foo $ sum ...)
01:34:53 <thoughtpolice> or whatever
01:35:05 <elliott> but I'll just leave it like this, doesn't exactly matter much if someone spams -ops
01:35:08 --- mode: elliott set -o elliott
01:35:11 <dmwit> elliott: Oh, wait, no, I just can't read. Whether you are making a mess of it or not is up in the air, but the mess I thought you were making certainly isn't happening.
01:35:22 <thoughtpolice> johnw: just use Accelerate!
01:35:42 <pharaun> hows it thoughtpolice?
01:36:00 <pharaun> oh nice, just pulled up accelerate
01:36:02 <thoughtpolice> it's a pretty nifty little library. unfortunately i no longer have access to an nvidia-equipped machine
01:36:05 <Aetherspawn> thoughtpolice, I thought the benefit from llvm /should/ be much higher
01:36:20 <johnw> thoughtpolice: I do have a GTX 680 here, now I need a problem...
01:36:25 <Aetherspawn> in ghc 7.4.2 I get between 0% for non-numeric stuff and 30% for worst case numeric stuff
01:36:31 <pharaun> sweet, i do have a nvidia card here, i suppose i can give this thing a try
01:36:40 <Aetherspawn> shouldn't it optimize non-numeric code well, or is it told not to or something
01:36:49 <pharaun> i do have *some* problems that could probably benefit from cuda
01:36:54 <Aetherspawn> (or does ncg just do a good job?)
01:37:13 <mjrosenb> wtb: actual compiler for ppc64
01:37:26 <thoughtpolice> Aetherspawn: it's a lot of things, kinda. LLVM definitely is not a major speed boost on 'average' code, but it is a win on code that will obviously fuse directly into a loop, or something similar
01:37:34 <mjrosenb> alt: fs: one developer to write a ppc64 backend
01:37:39 <thoughtpolice> (which is the case when you're doing something numeric and using 'vector' for example)
01:38:03 <thoughtpolice> you normally have a pretty clear hot loop in some of these cases. LLVM will do great there. but it's not going to add 30% on average to your regular haskell code that uses lists or something
01:38:47 <Enigmagic> Aetherspawn: not numeric code tends to be branch heavy and hard to optimize without sufficiently simple workloads and sufficiently advanced compiler tech... like what msvc did for itanium: http://blogs.msdn.com/b/vcblog/archive/2008/11/12/pogo.aspx
01:39:02 <thoughtpolice> Aetherspawn: also, as Enigmagic said, GHC has a substantially different intermediate representation, compilation pipeline, and optimization opportunities at various stages, compared to LLVM and something like C or C++
01:39:30 <thoughtpolice> in practice, the C-- that GHC gives you is pretty damn good, for an IR. it's very close to what you feed into LLVM already
01:39:34 <thoughtpolice> with a lot of optimizations already applied
01:40:49 <thoughtpolice> (one of the big stages in this pipeline is where the C-- IR is essentially CPS converted. post CPS conversion, you lose a lot of high level structure, that LLVM for example can't recover from nowhere)
01:41:59 <Blkt> good day everyone
01:42:16 <thoughtpolice> johnw: oh, actually i lied. i do have a GTX 680 sitting next to me
01:42:23 <thoughtpolice> but my eGPU dock broke recently :(
01:42:47 <thoughtpolice> someday i'll own an actual desktop
01:43:07 <mjrosenb> thoughtpolice: I've been saying that for many years now.
01:43:59 <Enigmagic> alright, i'm out too. night all.
01:46:13 <thoughtpolice> mjrosenb: me too, me too...
01:46:36 <thoughtpolice> (my Steam library cries out to me on a regular basis, in fact)
01:47:03 <Aetherspawn> laptop master race
01:47:04 * Aetherspawn hides.
01:48:48 <shachaf> Aetherspawn: Next time instead of saying it and then hiding, just don't say it.
01:49:30 <Aetherspawn> Oh, you're no fun at all.
01:50:01 <johnw> I don't think he's here to provide the fun :)
01:51:05 <shachaf> I'm like johnw in that respect.
01:51:08 * elliott finds the "master race" thing somewhat inappropriate. (general statement, not specific)
01:52:03 <johnw> shachaf: we are brothers in something, at last
01:52:46 <startling> was that even supposed to be a joke or
01:53:55 <elliott> brothers in having an "h" in your names
01:54:11 <johnw> thank you, elliott
01:54:25 <elliott> an exclusive club.
01:54:45 <startling> elliot and I are joined by ls
01:54:46 <startling> l-iot
01:55:09 <elliott> I refuse to be part of a club that fails to recognise both my ts
01:56:00 <dpwright> Is there a standard function to clamp a value between two values?  My google-fu is failing me
01:56:20 <elliott> afaik no -- btw, try hoogle-fu@
01:56:23 <elliott> *!
01:56:24 <elliott> @hoogle
01:56:25 <lambdabot> No query entered
01:56:25 <lambdabot> Try --help for command line options
01:56:27 <elliott> uh.
01:56:29 <elliott> @where hoogle
01:56:29 <lambdabot> http://haskell.org/hoogle â€“ See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
01:56:39 <startling> elliott, dirty prescriptivist
01:57:14 <mjrosenb> dpwright: clamp min max x = sort [min,max,x] !! 1
01:57:21 <johnw> async exceptions are wearing me down
01:58:19 <mjrosenb> > let clamp mi ma x = sort [mi,ma,x] !! 1 in map (clamp 3 6) [1..10]
01:58:20 <lambdabot>   [3,3,3,4,5,6,6,6,6,6]
01:59:05 <mjrosenb> and actually, you don't have to pass min and max in in any particular order.
01:59:24 <dpwright> mjrosenb: ah! clever, thank you.  I'm still relatively fresh from imperative-land, I would probably have tried to use some sort of conditional :-/
02:00:01 <mjrosenb> dpwright: it is probably not a very good solution.
02:00:25 <johnw> is there a good demo app for accelerate that shows it being extra fast?
02:00:53 <johnw> ah, found them
02:01:02 <johnw> https://github.com/AccelerateHS/accelerate-examples.git
02:02:18 <alpounet> thoughtpolice, if the information was somehow kept after the CPS conversion, could it really make a difference wrt the LLVM IR generated by GHC? could it generate much better IR, as in significantly more performant?
02:03:05 <thoughtpolice> johnw: all the papers by Manuel are really interesting too
02:03:05 <dpwright> mjrosenb: why not?
02:03:11 <dpwright> what's wrong with it?
02:03:15 <thoughtpolice> he references most of them on justtesting.org
02:03:36 <johnw> just discovered that accelerate-cuda requires 7.6, which sort of stops this for me just now
02:04:03 <neutrino> hi, johnw
02:04:07 <pharaun> 7.6 hm i should have that
02:04:10 <johnw> hi neutrino
02:04:13 <thoughtpolice> alpounet: well, it's more like LLVM just isn't designed to handle that kind of IR. in the CPS conversion, you basically begin explicitly managing your own stack
02:04:22 <pharaun> sweet i got 7.6 i can use accelerate :)
02:04:32 <bartavelle> is that possible to turn of "orphan instance" warnings as a language pragma ?
02:04:54 <thoughtpolice> alpounet: so now when you convert that, you lose all kinds of obvious optimization opportunities at the 'naive' level
02:05:08 <Lemmih> bartavelle: {-# GHC_OPTIONS -fno-warn-orphans #-}
02:05:11 <neutrino> what is IR?
02:05:17 <neutrino> intermediate.. something?
02:05:23 <Lemmih> bartavelle: So, no.
02:05:26 <thoughtpolice> neutrino: intermediate representation
02:05:34 <bartavelle> Lemmih, ah I didnt know that GHC_OPTIONS thingie, thanks
02:05:43 --- mode: ChanServ set +o johnw
02:06:05 <thoughtpolice> alpounet: like, consider, uh, 'f() { z = foo; x = bar; r = p(x); y = x + z - r; return y }'
02:06:21 <thoughtpolice> given that C--, the post-CPS rep looks like
02:07:05 <thoughtpolice> 'z = foo; x = bar; (push z on stack); (push f1_split on stack); call p(x);'
02:07:28 <neutrino> thoughtpolice: thank you
02:08:02 <Lemmih> bartavelle: Oops, it may actually be OPTIONS_GHC.
02:08:15 <thoughtpolice> then 'f1_split(x,y) { z = pop from stack; r = x + z - r; }'
02:08:25 <thoughtpolice> er, 'r = x + z - r; return r;'
02:08:27 <thoughtpolice> something like that
02:08:38 <thoughtpolice> alpounet: now consider in the first example
02:08:49 <thoughtpolice> you can trivially sink the store 'z = foo;' past the call to 'p(x)'
02:08:52 --- mode: johnw set -o johnw
02:08:59 <thoughtpolice> but in the CPS converted representation, this is no longer possible
02:09:27 <mjrosenb> dpwright: I feel like it is constructing a list that isn't really necessary.
02:09:31 <thoughtpolice> alpounet: so in general LLVM is not equipped to handle this stuff
02:09:44 <thoughtpolice> there are certain optimizations which are really, really only going to be applicable BEFORE the big CPS conversion
02:10:32 <alpounet> thoughtpolice, and that's the kind of optimizations llvm is good at, but it's not the right moment in the pipeline to hand it some IR?
02:10:42 <thoughtpolice> yes
02:11:10 <thoughtpolice> in general GHC is pretty much the only thing that's going to handle that stuff. there's a pretty large amount of optimization meat there, aside from the other things LLVM can do
02:11:19 <thoughtpolice> (and there are a lot of things we won't ever beat LLVM at, by the same token)
02:11:34 <thoughtpolice> (think things like instruction scheduling/pipelining/ISA cost models)
02:11:38 --- mode: ChanServ set +o johnw
02:12:05 <thoughtpolice> and also LLVM just has tons and tons of random tricks in its sleeve to make other shit fast
02:12:10 <alpounet> thoughtpolice, so really it's not like we can try to keep some annotations along the Cmm functions, so that we can get a better IR?
02:12:11 <thoughtpolice> like the representation/storage of float constants, etc
02:12:23 --- mode: johnw set +b neutrino!*@*$#haskell-ops
02:12:29 <thoughtpolice> alpounet: yeah, you still really lose a lot of information that i don't think can be meaningfully recovered
02:12:34 --- kick: neutrino was kicked by johnw (Banned due to repeated complaints from several channel operators)
02:13:17 <alpounet> thoughtpolice, because that information is really in the code itself right? not the kind of thing you can keep as just an annotation to some function
02:13:27 <dpwright> mjrosenb: I see... I'm relatively new to functional programming (bar the occasional bit of lisp), so I haven't even started thinking about efficiency yet.  Coming from C, nearly everything I come across doing FP feels "inefficient", but seems to be fixed up by the compiler, so I don't really know where I stand :-/
02:13:32 <thoughtpolice> yeah, pretty much. you invert all of the control flow the moment you pass that stage
02:13:42 <thoughtpolice> so recovering it all is not really going to happen without like, magic
02:14:02 <Lamen> is there something like, ummm, can do pattern-matching on Nothing, but can also tell which type of "Nothing" it's matching? just curious...
02:14:07 <thoughtpolice> and LLVM is pretty highly tuned towards the 'average C/C++ like case' where there's no CPS or inverted control flow
02:14:23 <Aetherspawn> Lamen, Haskell is type-safe - why would you need that?
02:14:32 <alpounet> thoughtpolice, hasn't anyone tested to generate the LLVM IR before the CPS conversion?
02:14:43 <haasn> there's only one kind of Nothing
02:14:49 <haasn> the Nothing kind of Nothing
02:14:54 <thoughtpolice> alpounet: there are various reasons why we do the CPS conversion. i don't know what they all are, but Simon tells me it is so.
02:15:08 <haasn> > Nothing == Nothing
02:15:09 <thoughtpolice> so i'll just say "no, because it probably wouldn't work" :P
02:15:09 <lambdabot>   True
02:15:18 <thoughtpolice> (take that with a large amount of salt.)
02:15:29 <Lamen> Aetherspawn: curiosity :D
02:15:49 <haasn> dpwright: most of seems totally inefficient until the moment you realize Haskell operates nonstrictly
02:15:49 <thoughtpolice> alpounet: or it would be a ridiculous amount of work, which largely kind of undermines the whole new Cmm pipeline and everything
02:16:25 <Aetherspawn> Why did GHC move away from llvm in the first place?
02:16:42 <Aetherspawn> It seems like a really backwards thing to do in terms of the amount of people working on making llvm fast and such
02:16:43 <Lamen> haasn: My original attempt was, ah, if there's Nothing :: Maybe Int, Nothing :: Maybe String, can I have something that can do matching on it :)
02:16:45 <bitonic> Aetherspawn: did it?
02:16:48 <thoughtpolice> GHC did not move away from LLVM. LLVM came much later, after the native code generator
02:16:51 <alpounet> thoughtpolice, you bet there are, I was just wondering how hungry LLVM would be for a better IR -- I also bet they have given this a lot of thoughts, and there's a reason David hasn't written the llvm backend this way, really that was just me being curious
02:16:57 <Aetherspawn> Oh, my misunderstanding . Sorry
02:17:22 <thoughtpolice> alpounet: well, it's more the Cmm part, like i said, which is independent of the actual transformation from Cmm -> LLVM IR, or Cmm -> x86 or whatever
02:17:31 <haasn> Lamen: if your function is polymorphic, there's no way to recover what â€˜typeâ€™ the user ends up actually inputting - that's how polymorphic functions work (there's one exception, but it's a bit advanced)
02:17:53 <thoughtpolice> we've really always done the CPS conversion, we probably won't get away from it. the new code generator makes the optimizers significantly more flexible though, so adding optimizations *pre* CPS conversion should be easier than it was before
02:18:04 <haasn> so for example if my function is: isNothing :: Maybe a -> Bool; I can't figure out whether I got passed a Nothing :: Maybe Int or Nothing :: Maybe Char
02:18:13 <bitonic> haasn: whatâ€™s the exception?
02:18:22 <Aetherspawn> is it RankNTypes?
02:18:26 <haasn> bitonic: Typeable
02:18:28 <thoughtpolice> (the TL;DR is that there used to be this gigantic monolithic pass which converted from STG -> Cmm, and did conversion *and* CPS sort of as this gigantic mammoth)
02:18:29 <Aetherspawn> oh foo.
02:18:48 <thoughtpolice> now the new codegen is split, so there is a phase from STG -> C--, then optimization, and then a new CPS (which is smaller and more flexible) does its thing
02:18:55 <bitonic> haasn: well Iâ€™d say that a type variable with a constraint is not fully polymorphic
02:19:03 <thoughtpolice> then you can do some more optimizations on the C-- part resulting from that, and finally you spit out code
02:19:10 <haasn> yeah you're right
02:19:16 <haasn> so it's not really an exception, just a workaround
02:19:20 <Lamen> …Typable, I have to say it's really a bit advanced.
02:19:29 <Lamen> heh.
02:19:35 <alpounet> thoughtpolice, right. it's just annoying to know ghc isn't getting the best out of its llvm backend, somehow, and is kinda stuck there
02:19:43 <haasn> it's not really that advanced, if you want to understand it; but it's a bit advanced in that most of the time if you think you use it you shouldn't be
02:19:48 <thoughtpolice> well, it's a pretty difficult problem given GHC's design :P
02:20:06 <alpounet> yeah
02:20:07 <thoughtpolice> also, the LLVM guys and the GHC guys have wildly different needs and responsibilities. frankly there is a very large impedemence mismatch in a lot of ways, if you ask me
02:20:25 <thoughtpolice> but we also can't beat LLVM at its own game like numerical code
02:20:33 <alpounet> we're already doing incredibly great considering everything GHC does (compiler + runtime)
02:20:37 <thoughtpolice> personally i think we have a relatively flexible tradeoff, where LLVM and non-LLVM compiled code can interop
02:20:44 <thoughtpolice> no buy in is great IMO
02:20:48 <bitonic> Lamen: by the way, thereâ€™s even a name to describe the fact that polymorphic functions cannot do anything â€˜strangeâ€™ with the polymorphic arguments: parametricity
02:21:11 <thoughtpolice> but this flexibility also comes at other costs
02:22:26 <thoughtpolice> someone else who's smarter than me should write a radically different Haskell compiler with a more conducive compilation model to that stuff :)
02:22:39 <thoughtpolice> me and Lemmih had that idea once, at least
02:22:40 <thoughtpolice> :)
02:22:51 <Lamen> bitonic: (looking it up)…seems that /me will do a little bit "research" on polymorphism in the next week or two
02:23:21 <Lamen> Any recommendation (reading materials)?
02:23:33 <bitonic> Lamen: (I think some japanese characters are ending up in your messages for some reason)
02:23:52 <haasn> (parametricity is a nice thing, for example it can be used to automatically derive theorems based on the type of a function ;)
02:23:55 <haasn> bitonic: works fine here
02:24:29 <Lamen> bitonic: you mean (three dots here)? might the auto-correction
02:24:32 <haasn> ?free f :: (a -> b) -> [a] -> [b]
02:24:32 <lambdabot> h . k = p . g => $map h . f k = f p . $map g
02:24:35 <Lamen> might be
02:24:43 <bitonic> using UTF-8, õ€Œ£ is a box
02:25:22 <bitonic> code point: 0x2954
02:25:36 <alpounet> thoughtpolice, i'm curious about the standard chartered compiler
02:25:46 --- mode: johnw set -o johnw
02:26:08 <haasn> bitonic: where in his message did you see that?
02:26:10 <alpounet> in that regard
02:26:27 <bitonic> haasn: <Lamen> bitonic: (looking it up)õ€Œ£eems that ...
02:26:30 <bitonic> anyway, doesnâ€™t matter
02:26:38 <thoughtpolice> alpounet: MuHaskell? yeah, sounds neat. but be warned, if you go to Standard Chartered, you may never ever return!
02:27:02 <alpounet> thoughtpolice, hah, i'd have to be hired first
02:27:16 <alpounet> although i did receive an offer or two for working with Haskell/C++ in finance
02:27:21 <alpounet> wasn't SC though
02:28:21 <alpounet> but I think Mu has a llvm backend, so maybe it gives better IR than GHC, depending on the way he wrote it
02:28:24 <Lamen> bitonic: yes, that's three continuous dots auto-corrected to that box you saw
02:28:56 <bitonic> Lamen: uhm, OK.  weirdly I get â€˜japanese-jisx0208 (JISX0208.1983/1990 Japanese Kanji: ISO-IR-87)â€™ as the preferred charset for that codepoint
02:29:16 <Lamen> and I've already set my charset to UTF-8, errrâ€¦sorry for that
02:29:38 <bitonic> oh donâ€™t worry, I was just pointing it out in case you didnâ€™t realise it
02:30:00 <Lamen> Thanks anyway. :)
02:31:16 <Lamen> haasn: you mean "Theorems for Free!"
02:31:22 <haasn> yeah
02:32:20 <Aetherspawn> > unsafePerformIO $ getStdRandom (randomR (1,6))
02:32:21 <lambdabot>   Not in scope: `unsafePerformIO'
02:33:51 <thoughtpolice> Lemmih: hey! when did you start working at Erudify? aren't they in Switzerland?
02:34:35 <Lamen> time for some serious reading, thanks all.
02:35:42 <bitonic> thoughtpolice: I can confirm theyâ€™re in Switzerland :P
02:36:16 <thoughtpolice> :P
02:37:30 <tdammers> they're in switzerland alright, which is one of the reasons I don't start working there
02:37:49 <tdammers> the other being that I sucked at the interview :P
02:39:22 <Aetherspawn> The straight lines; the metro, the spacing, the font. It all feels so wrong
02:50:44 <merijn> What's up with Hackage not generating docs for some libraries?
02:51:06 <typoclass> merijn: maybe if they fail to compile? see "build log"
02:51:21 <typoclass> merijn: or if they're newer than 24 hours or some such
02:51:42 <merijn> typoclass: Well, none of the reactive-banana-wx versions have docs, for example
02:53:19 <alpounet> merijn, probably because wx isn't installed on the server hackage runs on
02:53:21 <alpounet> ?
02:53:35 <alpounet> so the build fails, so the haddocks aren't generated (that's how it works for now...)
02:53:39 <typoclass> merijn: yeah, says "build failure ghc-7.6 (log)". might be because the build server is missing some c library that's necessary
02:53:57 <merijn> blah
02:54:03 <merijn> That's annoying
02:54:36 <typoclass> merijn: ... though you're right, i'm not sure why haddock is only tried if ghc has completed successfully. seems like the two tools could easily try independently
02:55:11 <thoughtpolice> 'cabal haddock' will require the 'cabal configure' step. 'cabal configure' is where it's going to scan your system for necessary libraries (like using pkg-config or whatever,) and that's where it'll fail first
02:55:29 <thoughtpolice> the reason for this is because you need to do things like run or check for preprocessors before you may be able to run haddock
02:55:30 * typoclass . o O ( somehow i think the "build failure" field should be more prominent visually. it's just easy to overlook )
02:55:34 <typoclass> thoughtpolice: ah, right
02:56:43 <boothead> I suppose this has been discussed already, but what are peoples thoughts on FPComplete's IDE? Anyone got a beta account yet? Looks really slick!
03:10:47 <OffsetGoose> [1..5]
03:11:00 <OffsetGoose> Darn,
03:11:20 <OffsetGoose> What kind of functionality can lambdabot do besides type signatures?
03:12:03 <typoclass> > 1+2 -- OffsetGoose, it can evaluate expressions, as long as they're not IO actions obviously
03:12:04 <lambdabot>   3
03:12:14 <elliott> it can evaluate expressions that are IO actions too
03:12:28 <typoclass> elliott: right, but it can't execute them
03:12:31 <elliott> though it doesn't run the IO :)
03:12:43 <OffsetGoose> let nats = 0 : map (+1) nats
03:12:46 <OffsetGoose> take 5 nats
03:12:47 <alpounet> OffsetGoose, you have to prefix your code with "> ", just like typoclass did, above
03:13:05 <typoclass> OffsetGoose: be sure to put it all in one line (use let ... in ...)
03:13:08 <OffsetGoose> O, ah didn't see that second '>'
03:13:08 <alpounet> > let nats = 0 : map (+1) nats in take 5 bats
03:13:09 <lambdabot>   Not in scope: `bats'
03:13:09 <lambdabot>  Perhaps you meant `nats' (line 1)
03:13:17 <alpounet> > let nats = 0 : map (+1) nats in take 5 nats
03:13:18 <lambdabot>   [0,1,2,3,4]
03:13:27 <alpounet> > "i'm batman"
03:13:31 <lambdabot>   "i'm batman"
03:13:46 <typoclass> "Perhaps you meant: 'natman' (line 1)"
03:14:08 <alpounet> hah, can't wait for the natman tshirts
03:14:14 <OffsetGoose> > unsafePerfromIO $ simpleHTTP $ getRequest "www.test.com"
03:14:14 <lambdabot>   Not in scope: `unsafePerfromIO'Not in scope: `simpleHTTP'Not in scope: `get...
03:14:29 <OffsetGoose> Is it only Prelude?
03:14:32 <alpounet> OffsetGoose, it won't do any IO, for obvious safety reasons
03:14:33 <mauke> no
03:14:44 <mauke> :t liftM
03:14:45 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
03:14:46 <alpounet> it has more than Prelude though
03:14:52 <mauke> :t M.keys
03:14:53 <lambdabot> M.Map k a -> [k]
03:15:02 <mauke> :t S.fromList
03:15:03 <lambdabot> Ord a => [a] -> S.Set a
03:15:16 <OffsetGoose> What server is this running on?
03:16:00 <OffsetGoose> And how does it prevent unreasonable resource consumption?
03:16:26 <OffsetGoose> > [1..100]
03:16:28 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:16:30 <mjrosenb> OffsetGoose: timer.
03:16:50 <OffsetGoose> Brilliant :-D  Thanks again, mates
03:16:54 <mjrosenb> and presumably a counter on the memory allocator
03:17:05 <mjrosenb> > sum [1..10^10]
03:17:09 <lambdabot>   mueval-core: Time limit exceeded
03:17:25 <OffsetGoose> > [10^100..]
03:17:27 <lambdabot>   [10000000000000000000000000000000000000000000000000000000000000000000000000...
03:17:35 <OffsetGoose> Haha
03:17:37 <mauke> > fix error
03:17:38 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
03:18:07 <mjrosenb> > fix fix
03:18:08 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = a0 -> a0
03:18:08 <lambdabot>  Expected t...
03:18:17 <OffsetGoose> > let f = f in f
03:18:21 <lambdabot>   mueval-core: Time limit exceeded
03:24:56 <startling> mauke, that didn't work at all!
03:27:24 <mauke> > fix fail
03:27:27 <lambdabot>   ""
03:27:38 <startling> o.o
03:28:58 <mauke> any questions?
03:29:11 <quchen> Yes.
03:29:20 <quchen> Why.
03:29:36 <quchen> What Monad is that fail from?
03:30:16 <quchen> Answer: m.
03:30:22 <mauke> :t fail
03:30:22 <lambdabot> Monad m => String -> m a
03:30:25 <mauke> :t fix
03:30:28 <lambdabot> (a -> a) -> a
03:30:29 <quchen> :t fail (fix fail)
03:30:32 <lambdabot> Monad m => m a
03:30:40 <mauke> (a -> a) ~ (String -> m a')
03:30:47 <quchen> Huh?
03:30:49 <mauke> => String ~ m a'
03:31:04 <mauke> => m = []; a' = Char
03:31:14 <quchen> How can (a -> a) be (String -> m a')?
03:31:29 <mauke> what's the problem?
03:31:41 <shachaf> What sort of answer are you expecting to that question?
03:31:42 <quchen> Oh, I read your type inference wrong.
03:31:56 <mauke> I mean I'm passing 'fail' to 'fix' so obviously they have to unify or the code wouldn't typecheck
03:31:59 <quchen> Now it makes sense.
03:32:00 <shachaf> fix takes an argument of type (a -> a); you give it an argument of type (String -> m a')
03:33:25 <shachaf> foldr :: (a -> [a] -> [a]) -> [a] -> [a] -> [a]
03:37:10 <startling> mauke: ahhh
03:37:23 <startling> > fail "help" :: [Int]
03:37:25 <lambdabot>   []
03:37:40 <startling> > fail "help" :: String
03:37:41 <lambdabot>   ""
03:37:54 <alpounet> @src [] fail
03:37:54 <lambdabot> fail _      = []
03:38:17 <startling> :t fix fail
03:38:18 <lambdabot> String
03:38:21 <startling> :)
03:38:31 <startling> why does it default to string and not [a] ?
03:38:41 <alpounet> because fail :: String -> m a
03:38:51 <alpounet> the String comes from there
03:38:53 <startling> oh, right
03:57:32 <tomboy65> why is this code expensive? http://bpaste.net/show/110436/
03:59:59 <tomboy65> or rather, why is computing the fibonacci sequence so expensive?
04:00:10 <supki> that code does not look like it even typechecks
04:00:28 * hackagebot shake 0.10.6 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.10.6 (NeilMitchell)
04:02:16 <tomboy65> supki: it doesn't. it's just a first sketch.
04:03:03 <Twey> supki: take 3 [a, b, c] = [a, b, c]
04:04:47 <Lemmih> thoughtpolice: Little more than a year ago. Yes, we're in Switzerland. Wonderful country.
04:05:08 <Twey> supki: It'll be kind of slow because you're calculating a lot of values more than once
04:05:15 <mr-> tomboy65: for one, I think there is no memoization going on
04:05:22 <Twey> (assuming this is what you meant to write: http://bpaste.net/show/CHeb9Hm9QretIM4S9WtL/ )
04:06:25 <Twey> supki: You can store intermediate results by representing the function as a list instead
04:06:34 <mr-> tomboy65: that's why the algorithms google would show you create a list, thereby saving you from having to compute earlier values again
04:07:23 <tomboy65> good :)
04:07:32 <tomboy65> thanks for that hint. will read up on memoization
04:11:31 <Lemmih> thoughtpolice: Are you still hacking on compilers?
04:16:29 <thoughtpolice> Lemmih: i am committing to GHC more and more these days, yes
04:17:11 <thoughtpolice> Lemmih: i'd guess you've maybe moved on at this point, though :)
04:18:10 <shachaf> thoughtpolice: What, you've finally stopped deliberating between Haskell compilers?
04:18:21 <thoughtpolice> Lemmih: ah, I see RE: Erudify. i thought you might have still been in Denmark
04:18:25 <thoughtpolice> wasn't sure if you had moved :)
04:18:39 <thoughtpolice> shachaf: it would seem so i'm afraid
04:25:27 <Twey> > fix (([0, 1, 1, 1] ++) . liftM3 (zipWith3 (\x y z -> x + y + z)) (drop 1) (drop 2) (drop 3)) -- tomboy65
04:25:30 <lambdabot>   [0,1,1,1,3,5,9,17,31,57,105,193,355,653,1201,2209,4063,7473,13745,25281,464...
04:26:03 <tomboy65> Twey: i have no understanding whatsoever of the purpose of liftM
04:26:32 <tomboy65> liftM3
04:27:59 <Twey> For functions, liftM3 f a b c x = f (a x) (b x) (c x)
04:30:39 <tomboy65> okay, that makes sense then
04:31:16 <djcoin> Is there a way to ask lambdabot the location of some function ?
04:31:33 <djcoin> for the *
04:31:48 <tomboy65> @hoogle fix
04:31:48 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
04:31:48 <lambdabot> Data.Fixed module Data.Fixed
04:31:48 <lambdabot> Data.Function fix :: (a -> a) -> a
04:32:02 <tomboy65> like this?
04:32:44 <djcoin> tomboy65: exactly, thanks :)
04:33:04 <typoclass> djcoin: hoogle ^^ will tell you the module where the function(s) of that name are defined. from the hoogle website you can click through to haddock documentation and the source code
04:33:07 <typoclass> @where hoogle
04:33:07 <lambdabot> http://haskell.org/hoogle â€“ See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
04:33:33 <djcoin> Yeah, don't know why I didn't try it on lambdabot, hoogle is awesome :)
04:38:47 <djcoin> "fix f = let x = f x in x" ; I already checked this on SO - but it is still a bit confusing to me, how does the nested call look like ? (f (f (f (f ... ?
04:41:10 <startling> djcoin, yep
04:41:14 <startling> > fix (const 1)
04:41:15 <lambdabot>   1
04:41:26 <mapreduce> @src fix
04:41:27 <lambdabot> fix f = let x = f x in x
04:41:53 <startling> > fix f
04:41:54 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
04:41:54 <lambdabot>    arising from a us...
04:42:00 <startling> aw
04:42:12 <mapreduce> damn, I can't even tell where the x in f x comes from.
04:42:41 <quchen> mapreduce: Maybe this form is clearer:  fix f = f (fix f)
04:42:43 <supki> > fix f :: Expr
04:42:44 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
04:43:04 <startling> supki: aha
04:43:13 <mapreduce> yes, thank you.
04:43:49 <quchen> @quote fmap.fix.return
04:43:49 <lambdabot> mauke says: fmap fix return is the e^(i*pi)+1 of haskell
04:47:41 <ocharles> :t fmap.fix.return
04:47:42 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:48:26 <quchen> No dots
04:48:30 <quchen> :t fmap fix return
04:48:31 <lambdabot> a -> a
04:48:42 <quchen> (The "." were just for the @quote command.)
04:51:25 <djcoin> startling: supki thanks !
04:52:10 <jxm> Hi, sorry for being (probably) the 1 million-th guy to ask about monads, but could anyone tell me the difference between a series of functions calls chained with an error monad and exceptions in an imperative language ?
04:52:38 <jxm> From what I understand, the point of the error monad if to only continue execution flow if each function call does not return an error
04:52:48 <elliott> they serve the same purpose
04:52:50 <jxm> And from what I gather, raising an exception does exactly that
04:52:58 <shachaf> jxm: Right. That monad is a way of implementing exceptions.
04:53:14 <jxm> With in both cases (?) the need to handle at the caller site the raised exception or the resulting error (monad)
04:53:24 <shachaf> But rather than being a primitive they're just something you can implement.
04:53:40 <jxm> ok
04:53:43 <elliott> and they're first-class.
04:53:52 <shachaf> It's kind of nice that this lets you conflate exceptions with returning error values, which is usually a big dichotomy in oether languages.
04:53:54 <elliott> and you declare explicitly what's going on in the type
04:53:54 <jxm> Thanks for a prompts answers, I think I get it
04:54:40 <jxm> exceptions are needed in imperative languages because they can not be implemented with generic languages constructs where with monads you can just implement them woth no further language magic
04:54:46 <jxm> Is that what you guys are telling me ?
04:55:21 <shachaf> Even "monads" aren't language magic (except for a bit of syntax sugar).
04:55:41 <jxm> Sure, from what I understand monads are essentially syntactic sugar
04:56:10 <jxm> would it be wrong to view monads as "just passing around a closure" somehow ?
04:56:27 <merijn> jxm: Well, they're a typeclass with syntactic sugar around applying the typeclasses' functions
04:56:36 <shachaf> "passing around closures" doesn't really have very much to do with monads per se.
04:56:43 <shachaf> You can (and do) pass around closures all you like.
04:56:57 <merijn> jxm: Kinda, you could  view "passing around a closure" as a Monad, though (I think?)
04:57:06 <blackdog> welp, that's frustrating. finally got a coredump after running under valgrind for a few hours - valgrind knows nothing, and the coredump has very little info except that "yes, you're creating a shedload of threads"
04:57:10 <merijn> (The kinda refers to being wrong)
04:57:30 <jxm> merijn, ah, ok, in that direction it makes better sense indeed
04:57:32 <typoclass> jxm: well, do-blocks are a bit of syntax sugar that gets translated into function calls. these functions are defined in a typeclass named Monad, which has a few commonly used instances (list, Maybe, IO) and a number of less commonly used instances
04:57:42 <shachaf> jxm: "Monad" is just an API that exceptions (and a bunch of other things) happen to implement.
04:57:50 <merijn> jxm: There is a continuation monad, for example
04:58:24 <astor> jxm: exceptions are at least two things.  Primarily they are about containing and signaling conditions through multiple layers without the intermediate layers having to care.  Secondary they have particular expected implementations.  Monads can solve the "intermediate layers having to care" issue.  However, monads are more similar to passing errors back in C at the implementation layer.
04:58:54 <KingofFerrets> Curious: is there a way to call a main method with arguments in GHCI, or do I have to just compile with GHC and run the result with the arguments?
04:59:06 <merijn> jxm: My general advice is, don't worry about "what" they are. Study typeclasses and type signatures, take a look at the Monad typeclass and then the basics should be obvious. After that you can study the State monad to see an example interesting use
04:59:10 * jxm is trying to digest all of this
04:59:36 <jxm> merijn, I know what they are - they are monads ;-)
04:59:46 <klrr> should i use HaskellDB or HDBC?
05:00:43 <jxm> astor, right, this is what I had in mind in fact. Exceptions would be an invention needed to plug the lack of heneric way to have errors "cut" the execution flow
05:01:14 <tomboy65> okay, i'm looking at http://www.haskell.org/haskellwiki/Memoization, where this function is defined: memoized_fib = (map fib [0 ..] !!)
05:01:19 <jxm> With monads no need for an extra type behavior in addition to errors, you can just bubble up the error when and _where_ it happens
05:01:29 <tomboy65> i don't understand the usage of !! there
05:01:32 <jxm> s/heneric/generic
05:01:49 <tomboy65> and map errors out in script and ghci
05:03:35 <merijn> jxm: Haskell has "real" exceptions too, btw, they just require IO to use.
05:03:55 <zomg> throw new NullPointerException('lel');
05:03:57 <jxm> typoclass, shachaf, merijn, astor, elliott thanks a lot for jumping in
05:04:23 <jxm> I would have tons of other questions, but I think it is better to jump into some code, use it and be less "intellectual" about it
05:04:34 <jxm> I'll definitely come back here for more :-)
05:04:42 <elliott> KingofFerrets: try uh :main a b c
05:04:53 <astor> jxm: yes.  so since monads control how to combine expressions, they control for example "the semicolon" in imperative languages, so a monad can implement an if-statement before each ';' to short-circuit in case of an error.  that solves the problem basic exceptions were created to solve (but then there are more advanced exception systems like in common lisp which doesn't map 1:1 like this).
05:05:20 <jxm> merijn: ha, ok, interesting - and disturbing to discover after the "haha" moment I just experienced about exceptions vs monads ;-)
05:06:35 <jxm> astor, in the context you talk about, does it mean that the syntactic sugar implicitely replaces all separators with ==< ?
05:06:36 <merijn> jxm: Well, imagine things like out of memory errors, files that are closed, disks that are full, they can be nice there
05:06:49 <typoclass> jxm: er, nearly :-) it's >>=
05:06:58 <jxm> sorry, >>=
05:07:12 <merijn> jxm: They're a bit analogous to Java's unchecked exceptions
05:07:18 <typoclass> jxm: also, you're right -- try writing code, and reading some code. the understanding will come.
05:07:44 <merijn> jxm: Sometimes you just wanna do "f- it, fail catastrophically all the way back up to the main loop"
05:07:48 <jxm> The thing is that I am writing in erlang these days, and we now have a do implementation
05:07:54 <jxm> I am trying to make sense of it
05:08:11 <jxm> I understand some use cases, and it seems interesting in the context of code I have written
05:08:34 <jxm> in the sense that I _did_ feel the need of something missing sometimes, without naming it
05:08:35 <pxqr> what is the modern way to use DB like sqlite?
05:09:16 <merijn> jxm: lambdabot supports @undo
05:09:16 <jxm> merijn, hey, "f- it" + fail catastophically is all about what erlang is about in fact ;-) "let it crash" as we say
05:09:25 <startling> pxqr: sqlite-simple is alright
05:09:37 <merijn> @undo do { x <- foo; blah; bar x; return 5 }
05:09:37 <lambdabot> foo >>= \ x -> blah >> bar x >> return 5
05:11:02 <astor> lambdabot knows many tricks
05:11:13 <jxm> hehe - do-expansion, is that it ?
05:11:34 <jxm> @undo [x*2 | x <- lst]
05:11:34 <lambdabot> concatMap (\ x -> [x * 2]) lst
05:11:38 <jxm> hehehe
05:12:03 <pxqr> startling: thanks
05:12:04 <merijn> jxm: Basically, the simple rules are (I might forget some) "do { x <- foo; bar x; return 5" becomes "foo >>= \x -> do { bar x; return 5 }" (apply recursively)
05:12:10 <KingofFerrets> elliott: Thanks, seems to work. Has a list of empty tuples at the end of the output, but...
05:12:14 <jxm> <nod>
05:12:30 <merijn> jxm: "do { bar; blah; return 5 }" becomes "bar >> do { blah; return 5 }" (apply recursively)
05:12:51 <startling> pxqr: it's not great, though. just alright
05:12:53 <Aetherspawn> do isn't "high-level"
05:12:59 <Aetherspawn> is it?
05:13:06 <startling> I don't know why there's not anything better.
05:13:06 <Aetherspawn> It
05:13:08 <merijn> and "do { let x = blah; bar; return 5 }" becomes "let x = blah in do { bar; return 5 }"
05:13:34 <startling> Aetherspawn: "do" is precisely as high-level as the monad instance for the computation you're doing
05:13:37 <Aetherspawn> *It's dependant on the existance of Monads and the existance of >>, >>=, etc? or am I misinformed
05:13:39 <jxm> @undo do { x <- lst; return (x*2) }
05:13:40 <lambdabot> lst >>= \ x -> return (x * 2)
05:13:55 <typoclass> Aetherspawn: yes it needs all those
05:14:08 <jxm> Sooo... lst >>= \ x -> return (x * 2)  and concatMap (\ x -> [x * 2]) lst  are equivalent, right ?
05:14:13 <pxqr> startling: exactly that, but I don't need something else :)
05:14:17 <shachaf> What are some good complicated types?
05:14:21 <shachaf> (Not GADTs, though.)
05:14:26 <elliott> KingofFerrets: sounds like your main is main :: IO [()]
05:14:36 <quchen> jxm: For Lists, (>>=) = flip concatMap.
05:14:37 <elliott> KingofFerrets: I suggest giving explicit type signatures -- and I bet the problem is using mapM instead of mapM_
05:14:49 <typoclass> shachaf: cale criticizes the pipes library for their overly complicated signatures
05:14:51 <quchen> jxm: And return x = [x]
05:14:56 <jxm> ok, reverse order then ?
05:15:09 <jxm> (guessing what flip does)
05:15:18 <quchen> Yes. flip f a b = f b a
05:15:18 <typoclass> jxm: yes, flip reverses the order of arguments (of a 2-argument function)
05:15:43 <KingofFerrets> ...I'm actually using just Map for the thing I'm mapping.
05:16:05 <KingofFerrets> Have a list of strings I'm printing, so I have sequence $ map putStrLn (filePaths)
05:16:32 <mauke> sequence_
05:16:38 <quchen> mapM_
05:16:41 <merijn> KingofFerrets: You probably want "sequnce_" and/or "mapM_"
05:16:47 <mauke> putStr (unlines filePaths)
05:17:01 <KingofFerrets> Hm. Alright.
05:17:16 <merijn> KingofFerrets: sequence_ throws away the result
05:17:19 <merijn> :t sequence
05:17:20 <lambdabot> Monad m => [m a] -> m [a]
05:17:20 <merijn> :t sequence_
05:17:21 <jxm> Actually, from a newcomer perspective, it feels weird that Haskell has syntax at all - seems to me it would fit more naturally with a lisp-like syntax-less-ness
05:17:21 <lambdabot> Monad m => [m a] -> m ()
05:17:36 <merijn> jxm: We haskellers love our syntax!
05:17:52 <jxm> merijn, you ML-lover ;-)
05:17:53 <danil> not coincidentally, mathematicicians also love syntax
05:17:56 <mauke> lisp has both syntax and a very weird AST
05:17:58 <KingofFerrets> (I'm sad. I was so proud that I had an error because it was a list of strings, and I was just like "oh, I bet sequence $ map will work" and it did. :P)
05:18:01 <Botje> well, there are some bits that aren't very good
05:18:15 <jxm> merijn, we erlanger have to justify our syntax _all_the_time_ :-)
05:18:42 <startling> jxm, the problem with lisp is that it doesn't cleanly delineate things that happen at compile-time and run-time
05:18:47 <merijn> jxm: I hate ML
05:18:54 <merijn> jxm: The syntax of ML is *awful*
05:18:59 <startling> my favorite ML variant is XML
05:20:07 <KingofFerrets> Another thing: is it bad form to use stdout as the default if an output file isn't passed in to something that normally requires it?
05:20:27 <Aetherspawn> ghc does it.
05:20:39 <mauke> no, it doesn't
05:20:56 <mauke> KingofFerrets: why not always use stdout?
05:20:56 <startling> KingofFerrets: how woul you not pass in an argument?
05:21:16 <Aetherspawn> I'm pretty sure that both or one of the asm/llvm dump functions dumps to stdout
05:21:45 <KingofFerrets> 'cuz the professor wanted me to have passing the output file in as an option.
05:22:02 <jxm> Last thing, could anyone tell me about cuts ?
05:22:15 <merijn> jxm: Context?
05:22:20 <Botje> painful. avoid.
05:22:22 <KingofFerrets> startling: Thing accepts an input file and an output file, I want to make the second argument optional.
05:22:34 <startling> KingofFerrets, what's an optional argument
05:22:37 <jxm> merijn: I should probably ask on #scheme though, unsure if haskell has those
05:22:51 <KingofFerrets> startling: command line argument
05:22:58 <KingofFerrets> rather than a normal function
05:23:03 <startling> KingofFerrets: OH
05:23:08 <startling> yeah that sounds normal
05:23:13 <KingofFerrets> Sorry, I completely forgot to mention that. XD
05:23:34 <KingofFerrets> I'm dicking around with the main method for the thing I've been working on and making it work like I want.
05:23:38 <Botje> KingofFerrets: some applications write to a transformed filename.
05:23:41 <typoclass> ... now i wonder what a cut is
05:23:49 * startling cuts typoclass 
05:23:56 <Botje> for example "oggenc foo.wav" automatically writes to oggenc foo.ogg
05:24:00 <typoclass> mrow!
05:24:03 <startling> KingofFerrets: optparse-applicative is nice fwiw
05:24:10 <Botje> although you could argue it doesn't make sense to dump OGG files to stdout :)
05:24:20 <mauke> KingofFerrets: some programs treat "-" as stdin/stdout
05:24:31 <mauke> Botje: only if stdout is a terminal
05:24:47 <Botje> oh, that too. I keep forgetting about that.
05:25:02 <jxm> merijn, startling http://srfi.schemers.org/srfi-26/srfi-26.html (cuts in scheme)
05:25:36 <jxm> "Notation for Specializing Parameters without Currying"
05:25:53 <Botje> don't really need it in haskell
05:26:12 <KingofFerrets> Botje: Hm, that's another option. I'll go with stdout for now, make a note in a comment, and then ask the professor which he prefers later.
05:26:33 <Botje> for textual data stdout is probably the best default choice.
05:30:33 <KingofFerrets> Hm. Since stdout is usually going to be terminal, even though this is technically text, might be better to not have it potentially output to terminal. By default, we're generating something like 100 random objects, and they can each fill half a screen.
05:30:54 <mauke> :-(
05:31:10 <mauke> don't assume stdout will be a terminal
05:31:41 <KingofFerrets> yeah, I know, it can be redirected
05:31:50 <KingofFerrets> but that is the default
05:32:01 <mauke> no, it's not
05:32:12 <KingofFerrets> in most things that I've encountered it is?
05:32:21 <mauke> the default is whatever your parent process gave you
05:32:28 <KingofFerrets> aha
05:33:06 * KingofFerrets is probably going to learn how this actually works /next/ semester, in OS, so is sort of operating on what he can intuit from experience atm
05:33:09 <mauke> @hoogle hIsTerminalDevice
05:33:09 <lambdabot> System.IO hIsTerminalDevice :: Handle -> IO Bool
05:33:09 <lambdabot> GHC.IO.Handle hIsTerminalDevice :: Handle -> IO Bool
05:33:42 <mauke> at the OS level, there are only file descriptors
05:33:50 <KingofFerrets> ...I'm guessing that tells you if a handle goes to the terminal?
05:33:50 <mauke> a child process inherits open file descriptors from its parent
05:33:54 <mauke> yes
05:34:07 <mauke> by convention, file descriptor 1 is called "stdout"
05:34:13 <mauke> (and is expected to be open0
05:34:47 <KingofFerrets> Could put in an if, if stdout isn't terminal then print to stdout, otherwise print to altered file name?
05:35:22 <mauke> sounds brittle
05:35:43 <mauke> if anything, do what gzip does
05:36:00 <mauke> it it's directed to print to stdout and stdout is a terminal, it simply aborts
05:36:24 <mauke> see also: gzip < /dev/null
05:37:04 <mauke> heh, (tandoori)
05:37:44 <KingofFerrets> Huh. Why's that preferable over the version I described?
05:38:34 <mauke> because in your version it's semi-unpredictable whether it will write to a new file
05:38:59 <typoclass> KingofFerrets: some tools do that -- ls uses columns if you do "ls", or no columns if you redirect its stdout, e.g. "ls | cat". i'm not really sure if that's a good thing. it seems it could confuse the user
05:39:02 <jmcarthur_mobile> This is a reason cat is not an identity for Unix pipes.
05:39:10 <mauke> typoclass: that's not quite the same thing
05:39:58 <jmcarthur_mobile> typoclass: it doesn't even behave that way consistently on all systems :(
05:40:01 <mauke> ls still does "the same thing". it doesn't start creating files just because you did (not) redirect stdout
05:40:42 <KingofFerrets> So creating files when it's not expected is the part you think is problematic?
05:40:46 <jmcarthur_mobile> On centos 6, at least, the columns remain even when going through a pipe
05:41:13 <jmcarthur_mobile> It could maybe be some environment thing, but I don't know
05:41:15 <typoclass> mauke: yes right, it doesn't create files. i meant it just as a minimal example for a tool that changes behavior if it's connected to a terminal
05:42:02 <typoclass> jmcarthur_mobile: that sounds weird. i assume quite a few shell scripts do "ls | something", expecting one line per file?
05:42:25 <jmcarthur_mobile> Apparently not. Only my own she'll scripts seem to break.
05:42:31 <jmcarthur_mobile> Shell
05:42:48 * typoclass read that in scotty's voice
05:43:08 <jmcarthur_mobile> Not that I think about it, I have only noticed this when actually using a shell live.
05:43:15 <jmcarthur_mobile> Now. Sorry.
05:52:31 <Kinnison> Hiya, could someone point me towards some documentation for the 'default' keyword?  It's (understandably) quite hard to google for :-(
05:52:44 * Kinnison has seen 'default (Text)' a few times now, and is trying to understand what it does
05:52:48 <shachaf> Try Hoogle.
05:53:04 <shachaf> Or try the Report, or maybe in this case the GHC manual.
05:53:05 <KingofFerrets> http://www.haskell.org/haskellwiki/Keywords#default
05:53:11 <KingofFerrets> ^what I got from Hoogle
05:53:14 <Kinnison> Mmm, that implies Num related stuff
05:53:16 <Kinnison> so why Text?
05:53:30 <shachaf> Ah. Yes, that's an extension.
05:53:55 <Kinnison> Is it essentially saying any "foobar" becomes an instance of Data.Text.Text ?
06:00:56 <quchen> Kinnison: It's a way of resolving ambiguous types. For example, if you `print []`, GHC complains that it can't infer the list's type enough to decide what Show instance to use.
06:01:30 <quchen> On the other hand, try using `print [1]`, which works because the type of "1" defaults to Integer.
06:02:06 <quchen> The default defaults are (Integer, Double) as far as I know.
06:02:20 <mauke> (Integer, Int, Double)
06:02:35 <quchen> Ah, Int for Bounded probably
06:03:12 <shachaf> If you compile your own GHC you can change the default defaults, but those are the default default defaults.
06:03:31 <klrr> jaspervdj: im learning web development, using scotty , warp, pandoc and your blaze-html library, how do i represent <input type="text" name="var"> in blaze?
06:03:42 <mauke> quchen: oh, I'm wrong
06:03:54 <tomejaguar> How do I know what version of packages I'm building against?
06:03:58 <mauke> quchen++  # learned me something
06:04:05 <tomejaguar> Can I get GHC to dump a list of versions that it uses by default?
06:04:25 <typoclass> tomejaguar: how about ghc-pkg list?
06:04:47 <tomejaguar> typoclass: That's helpful, thanks.
06:06:00 <typoclass> tomejaguar: if you have multiple versions of the same package installed, i guess it can become confusing. ghc -v will tell you which ones it's disregarding ("hiding")
06:06:38 <Kinnison> quchen: So default (Text) is making all numbers be of type Text ?
06:07:42 <quchen> Kinnison: No. When an ambiguous constrained type is found, it checks whether Text satisfies that constraint, and if it does, it uses text.
06:08:02 <Kinnison> quchen: I see.
06:08:07 <quchen> Kinnison: default isn't restricted to Num at all.
06:08:14 <Kinnison> quchen: despite the help on haskellwiki :-(
06:08:49 <quchen> Kinnison: Maybe also have a look at the Report, the section is pretty short though.
06:09:34 <Kinnison> Mmm, I guess I'll not worry for now.  Thank you for your explanations.  It has helped a lot
06:13:50 <quchen> Kinnison: default is nothing to worry about really.
06:14:16 <KingofFerrets> Interesting. So, does default (x y z) check first if x works, and if not that then y, and if not that then z?
06:14:23 <quchen> It's not as bad as the DMR and sometimes it's helpful, so wave and smile
06:14:33 <KingofFerrets> And then if none of those works it complains at you?
06:14:45 <quchen> KingofFerrets: Yes, it picks the first one of x,y,z that satisfies all the constraints it can't resolve.
06:14:55 <quchen> Otherwise crash.
06:14:55 <KingofFerrets> That's pretty neat.
06:16:13 <quchen> As long as it's not unexpected, certainly.
06:16:57 <mauke> and of course there's default ()
06:18:16 <quchen> That's the default default command if you don't want the default default.
06:20:44 <quchen> shachaf: That would be the default default default defaults approach to changing defaults.
06:40:59 <KingofFerrets> ...Hm. What would happen if I attempted to hClose stdout? >.>
06:43:27 <typoclass> KingofFerrets: well, you couldn't write to it anymore :-) and the program that is connected to your program's stdout will be told that the end of file has been reached
06:43:58 <KingofFerrets> Hm. Alright.
06:44:48 <KingofFerrets> So, if I do hClose on a handle that might or might not be stdout at the end of main, that's not much of a problem?
06:45:45 <mauke> no
06:46:15 <KingofFerrets> Swoot. Thanks.
06:48:52 <quchen> I think it would be an excellent idea to know whether a Handle is stdout or not at any given point in your program.
06:51:01 <mauke> fh == stdout
06:54:47 <typoclass> quchen: my program is very flexible. stdout may well be the same as stdin. i have no way of knowing
06:54:48 <typoclass> =)
06:55:05 <quchen> hPutStrLn stdin "hello world!"
06:55:32 <typoclass> quchen: exactly! wouldn't want to disallow this perfectly good call
06:57:09 <KingofFerrets> quchen: Eh, apparently things can work the same whether it's stdout or not, so why find out?
06:57:34 <KingofFerrets> "If outh == stdout then foo else foo" is a pretty pointless thing to write. :P
06:58:02 <quchen> KingofFerrets: It's a little like if you want to close a curtain, and you decide to just nail planks in front of the window because it's going to be dark anyway.
06:58:21 <elliott> hClose foo where foo can be stdout is perfectly fine
06:58:33 <quchen> ... okay :-\
06:58:41 <chrisdone> mauke: shachaf: elliott: would you happen to know who to contact in order to get a paste.haskell.org domain?
06:58:43 <KingofFerrets> quchen: What should I do, in your opinion?
06:59:04 <t7> haskell foundation ?
06:59:17 <typoclass> chrisdone: the haskell-infrastructure mailing list?
06:59:18 <shachaf> chrisdone: Hmm, I'd ask sclv_ whom to ask.
06:59:33 <shachaf> Mostly because he was talking about related things recently so presumably he knows.
07:00:22 <chrisdone> thanks
07:00:39 <shachaf> Or, wait, there's a group that's responsible for these things.
07:00:44 <shachaf> http://www.haskell.org/haskellwiki/Haskell.org_committee
07:00:51 <klrr> is there anyway of using blaze-html for getting input from a webpage?
07:01:22 <elliott> blaze-html is for page generation only afaik.
07:01:29 <elliott> the rest is up to you / your framework
07:01:48 <klrr> oh, crap
07:01:56 <klrr> but it got a function for the <input> tag
07:02:11 <klrr> im not just sure how to use it
07:03:19 <quchen> klrr: The docs mention this tutorial: http://jaspervdj.be/blaze/tutorial.html
07:04:09 <klrr> quchen: ive read that , it doesnt explain input
07:05:17 <quchen> All elements are constructed in a similar way,  tag ! attribute1 "foobar" ! attribute2 "barbaz"
07:05:18 <chrisdone> i think klrr wants to receive form inputs
07:05:40 <quchen> Well that's not something HTML can do.
07:05:42 <chrisdone> klrr: do you know how web forms work?
07:06:02 <klrr> no
07:06:20 <klrr> but its that i want
07:06:23 <chrisdone> right
07:06:24 <klrr> i think
07:06:30 <klrr> im trying build a cms :)
07:07:06 <chrisdone> this page explains web forms: http://www.w3schools.com/html/html_forms.asp
07:07:16 <klrr> thanks!
07:07:19 <chrisdone> that's the web browser component
07:07:22 <mauke> w3schools--
07:07:40 <chrisdone> then on your server you need to receive inputs, so that depends on whether you're using scotty, snap, yesod, etc.
07:07:51 <klrr> im using scotty
07:09:10 <chrisdone> klrr: ok, you can write: post "/foo" (do somevalue <- param "first_name"; â€¦)
07:09:22 <chrisdone> klrr: and in your html, you should have a form input whose name is "first_name"
07:10:09 * KingofFerrets prods at quchen
07:10:12 <chrisdone> klrr: e.g. <input name="first_name"> in html
07:10:22 <klrr> okey
07:10:26 <chrisdone> mauke: if you have a better page than w3schools to explain forms, i'll gladly hear it!
07:11:16 <Hafydd> chrisdone: https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms
07:11:47 <chrisdone> Hafydd: not bad!
07:12:17 <quchen> KingofFerrets: I just find it weird to not know where my handles are pointing, but it seems to be fine. I guess I could think of some examples where having a "h" handle that could be lots of different things could be useful.
07:12:25 <klrr> oh there's also an example file using this :D
07:12:37 <Hafydd> chrisdone: also, http://developers.whatwg.org/forms.html#forms
07:13:10 <klrr> YEAH!
07:14:30 <KingofFerrets> quchen: Alright, if you can agree with the others after a bit, then probably shouldn't be concerned about dissent in  you guys on it.
07:14:39 <Hafydd> In fact, almost anything is better than w3schools.
07:14:40 <chrisdone> Hafydd: oddly, despite w3schools being older than the internet, it's the only one that has live editable demos
07:15:24 <Hafydd> Do you find live editable demos useful?
07:15:57 <chrisdone> are you serious?
07:16:01 <Hafydd> Yes.
07:16:35 <typoclass> Hafydd: well sure. you need examples for what you explained. in my opinion it's a bit like telling a joke but leaving off the punchline "because it's obvious" or "everyone can deduce the details themselves"
07:16:42 <Philippa_> Hafydd: yep. It /saves time/
07:17:07 <chrisdone> Hafydd: http://www.youtube.com/watch?v=PUv66718DII&html5=1
07:17:20 <Hafydd> Okay, but its use is limited unless you try the same demo in every browser you intend to target.
07:17:37 <Philippa_> so's the use of anything else you can do to test things
07:17:47 <Philippa_> that's just the usual webdeb shit for you
07:17:48 <Hafydd> And it's not that much harder to have http://jsbin.com/ open in another window.
07:17:48 <typoclass> Hafydd: honestly, in my opinion, the two pages (whatwg and mozilla) are spectacularly bad teaching
07:18:25 <Philippa_> a) that assumes you know of it b) for some people the extra context-switching is a bigger deal than others
07:18:28 <Hafydd> typoclass: what's wrong with the,?
07:18:35 <chrisdone> Hafydd: Error 503 Service Unavailable, heh
07:18:42 <Hafydd> *them
07:18:55 <Hafydd> Philippa_: well, using w3schools assumes you know of w3schools!
07:19:09 <klrr> chrisdone: thanks for the guidelines , found an example using this and i kinda get it now :)
07:19:19 <chrisdone> klrr: cool =)
07:19:29 <Philippa_> Hafydd: yet you're suggesting two dependencies, woo!
07:19:33 <KingofFerrets> Is there a strip-whitespace function that doesn't involve Data.Text?
07:19:38 <typoclass> Hafydd: i think it's terrible to teach forms and textfields without showing a gorram textfield. it's a bit like trying to teach a small child how to count, but failing to mention the words "one", "two" and "three"
07:19:47 <parcs> > 2 `shiftL` 24
07:19:48 <lambdabot>   33554432
07:20:48 <Philippa_> yeah. I mean, I'm often bad about producing code examples when I'm teaching in here? I'm happy to admit this is a failing
07:21:51 <typoclass> Hafydd: i'm not saying they're doing that on purpose, but i think the authors approached it in an awkward and backwards way
07:21:54 <b2coutts> Philippa_: yeah, I often realize that the most effective way to describe a simple algorithm is to just write the implementation
07:22:01 <Hafydd> typoclass: the Mozilla tutorials have actual forms. The whatwg documentation is intended for people who already know what a form is, I think.
07:22:36 <typoclass> as for jsbin.com, yes that helps and is a sensible suggestion. but still, it should be done by the author once for all readers. not by each reader individually. (for efficiency, if for no other reason)
07:22:53 <Philippa_> *nod*. Use longhand variable names, break things up more than usual and name any concepts explicitly ("pivot", "partition" etc for quicksort, for example), but sometimes just write it
07:23:03 <typoclass> Hafydd: sorry, i didn't see any
07:23:44 <Philippa_> relatedly: I like the "use GADT+interpreter" approach to first monad implementations partly because the interpreter structure is often more obvious than the un/boxing
07:23:52 <typoclass> ah, you have to click through to another article. yeah that's much better!
07:24:25 <Philippa_> (but also because "for us, they're a form of embedded language" is a key concept IMO: that style of implementation is about as concrete a proof as you can get)
07:25:08 <edwardk> bartavelle++ # parsers patch!
07:25:32 <Hafydd> Perhaps we have yet to find the ideal web development resource.
07:25:34 <chrisdone> Hafydd: personally i learn by the most direct experience
07:27:02 <typoclass> Hafydd: the mozilla page together with the linked articles is quite good i think (initially i thought the front page was the whole thing, and in my opinion that would have been terrible)
07:27:22 <chrisdone> Hafydd: rather than describing a form in pros (a few levels of indirection), or showing me what code i would write to make a form (less indirection), i'd rather just be shown an actual form that i can interact with directly and change directly (zero indirection)
07:28:18 <typoclass> chrisdone: on the developer.mozilla page, you can click through to articles which have screenshots and live widgets
07:28:25 <Hafydd> chrisdone: which would welcome you to make fallacious assumptions about how forms behave (when the actual behaviour of HTML can be counter-intuitive).
07:28:26 <chrisdone> typoclass: yeah the mozilla one is pretty decent
07:28:52 <Philippa_> Hafydd: and explaining that is the sort of thing that prose /is/ for, yes
07:29:07 <chrisdone> Hafydd: i'm not precluding any helpful explanation, but i would put that secondary rather than primary
07:29:15 * typoclass . o O ( prose and conse )
07:29:22 <Hafydd> Heh.
07:29:34 <Hafydd> . o O ( nil and cons )
07:29:37 <Philippa_> chrisdone: I think they're joint in this case - otherwise you get "IE is the only browser!" syndrome
07:29:45 <mauke> ns and cons
07:29:54 <Hafydd> Hahahaha
07:29:54 <chrisdone> Philippa_: hm?
07:30:04 <Philippa_> give 100 cons?
07:31:07 <Philippa_> chrisdone: It's important to know when you can't assume something is effectively implementation-defined. A lot of people who liked to got very angry about the idea of browsers that aren't IE in the 90s and 00s
07:32:03 <chrisdone> sure. i think forms are pretty fundamental and cross-browser, tho. the latest html5 stuff might not be, but that's what being the latest stuff is all about
07:32:07 <Philippa_> 'swhy Conceptual Mathematics starts you off doing direct manipulation of /arbitrary/ categories, not writing proofs about specific ones :-)
07:32:29 <astor> If I'm in EitherT and I have two computations that I want to 'mappend'.  One of them must succeed, but only if both fail does EitherT fail.  What should I use?
07:32:36 <Philippa_> My bank's web site does screwy things on firefox on my chromebook, but not on windows
07:32:44 <Philippa_> well, did. I think they unfucked it eventually
07:33:04 <Philippa_> There are some 'interesting' differences in interpretation cross-browser, certainly
07:33:07 <Peaker> astor, you could reverse the Either, so that success is Left, and failure is Right, and then reverse it after composition
07:33:28 <Peaker> luite, but what can I do about those overflows?
07:33:35 <astor> Peaker: ah, so that's what the EitherRT thing is for in errors?
07:33:45 <Peaker> astor, probably
07:33:52 <Peaker> (I'm not familiar with errors)
07:33:54 <luite> Peaker: well you can catch them, they're async exceptions but that's not really a solution :)
07:34:06 <astor> Peaker: thanks, I'll look at it.
07:34:28 <Peaker> luite, I'm wondering if the way the stack works in GHC seems right.. Is it conceptually wrong to force very nested thunk buildups?
07:34:48 <Peaker> luite, the stack could have indefinite growth like the heap, couldn't it?
07:34:58 <luite> Peaker: the stack is used for things that are not tail calls. it gets complicated a bit by laziness
07:35:24 <luite> Peaker: yes, it's dynamically allocated
07:35:33 * hackagebot parsers 0.8.3 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.8.3 (EdwardKmett)
07:35:39 <Peaker> luite, but unlike the heap, it has a (low) max size
07:36:06 <shachaf> luite: I would think that it gets completely changed by laziness, to the point that talking about tail calls doesn't even make sense in the same way. :-)
07:36:10 <chrisdone> Peaker: iirc mzscheme dynamically allocates function calls so even non-tail calls will go on forever
07:36:23 <luite> Peaker: right, since using huge stack is often an indication of something not being right
07:38:17 <acube_> Is there a list data type that doesn't pull all the elements into memory when iterated over multiple times?
07:38:23 <Peaker> A haskell package can be uploaded to hackage, tested, seem well enough -- and then fail with stack overflows on large inputs -- which is either because it is: A) inherently needs lots of stack space => max limit is bad  B) tuned for small inputs, code needs to be modified to handle large inputs too => need better early warnings about this
07:39:00 <yesthisisuser> @help
07:39:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:39:08 <yesthisisuser> @help list
07:39:08 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
07:39:29 <edwardk> @tell bartavelle thanks!
07:39:29 <lambdabot> Consider it noted.
07:40:07 <andrea__> i wrote a pentomino solver in haskell, it's slow :(   http://hpaste.org/90567
07:40:09 <Hafydd> Wait, ekmett and edwardk are the same person?
07:40:15 <edwardk> yes
07:40:16 <luite> shachaf: actually i think that's not quite true, you still use more or less the same stack frames, tail calls never use a stack frame, but when they are used is quite different. if you just look at everything that gets forced, ignore new thunks etc, then you gt a good idea of stack use
07:40:20 <Hafydd> :o
07:40:33 * hackagebot prizm 0.3.1.0 - A haskell library for computing with colors  http://hackage.haskell.org/package/prizm-0.3.1.0 (ParnellSpringmeyer)
07:41:10 <typoclass> Hafydd: most of the people in this channel are also edwardk, but he uses 800 nicks in order to not scare people
07:41:19 <Hafydd> Hahah.
07:41:23 <luite> shachaf: but the order does of course make all the difference between non-tailcall things like map using constant or linear stack
07:41:28 <edwardk> yeah, i have a couple of other clones. I mean come on. edvardkk ?
07:41:50 <edwardk> =)
07:42:01 <deggis> :D
07:42:02 <chrisdone> edvardkk is the good one, you are the evil one
07:42:02 <typoclass> edwardk: i thought he was operated by one of your cats? (poor spelling etc.)
07:42:11 <chrisdone> that's why he has to be quiet and eat his fish heads
07:42:13 <edwardk> chrisdone: well, yes.
07:42:22 <edwardk> chrisdone: i never claimed to be the good twin
07:42:35 <edvardkk> edwardk: what am I to do ?! my uni assigned me this username :p ;D
07:42:41 <Peaker> this program "putStrLn $ render $ vcat $ replicate 1000000 $ text "Hello" stack-overflows :-(
07:42:50 <edwardk> my megalomaniac quest for power should have given it away
07:42:52 <edvardkk> or, should I say, what are we to do
07:43:05 <edvardkk> given that I am a clone
07:43:31 <edwardk> edvardkk: mostly I predict that you'll just endure the occasional teasing. =)
07:43:39 <chrisdone> edvardkk: heh, you're a clone but a semi-accurate one. so you'll go and create a `len' library
07:43:50 <Hafydd> Hahah.
07:44:01 <edvardkk> edwardk: haha, that's fact already
07:44:05 <edwardk> i always wanted to compute with lentils
07:44:29 <edwardk> edvardkk: i try not to make predictions until things happen. it improves my accuracy by a lot
07:44:57 <chrisdone> edvardkk: do you look anything like this? http://25.media.tumblr.com/tumblr_lr2qd2GqFP1qg4chbo1_500.jpg
07:45:09 <yesthisisuser> @pl let a = (+); b = (*4) in f x y = a (b x) y
07:45:09 <lambdabot> (line 1, column 33):
07:45:09 <lambdabot> unexpected " "
07:45:09 <lambdabot> expecting operator
07:45:28 <edwardk> hah i'd forgotten about chrisdone's obsession with me looking like aphex twin.
07:45:35 <yesthisisuser> @pl let a = (+); b = (*4); f x y = a (b x) y
07:45:35 <lambdabot> (line 1, column 41):
07:45:35 <lambdabot> unexpected end of input
07:45:35 <lambdabot> expecting ";" or "in"
07:45:40 <chrisdone> edwardk: it still burns strong =p
07:45:52 <edwardk> sadly, chris, i've cut my hair, so the resemblance is much reduced
07:45:53 <edvardkk> edwardk: sound thinking. but I've already been teased for the similarity on occasion :p
07:46:14 <edvardkk> chrisdone: hmmm. yep. I look a lot like aphex
07:47:31 <chrisdone> edwardk: =o you cut your aphex twine!?
07:47:44 <bartavelle> edwardk, np
07:48:18 <typoclass> edvardkk: you could have no end of fun with slightly inattentive irc regulars. talk to them, mention lenses etc., then gradually make weirder, more surreal comments using more complicated words. see where they notice
07:48:21 <edwardk> chrisdone: yeah. i started walking a lot (~7-10 miles a day) and by the time i'd get where i was going it was looking wild and scary with people offering me change and stuff. i decided it was a good time for a change. ;)
07:48:59 <bartavelle> edwardk, it would be nice that "TokenParsing" wouldn't be a default instance of Trifecta, but an optionnal module
07:49:03 <typoclass> edwardk: so *cough* you took the change from them?
07:49:03 <edwardk> typoclass: actually if you want to maximize confusion start with the surreal comments with complicated words, and when it gets too simple, then they'll figure it out
07:49:15 <chrisdone> edwardk: =) you took the change, though, right?
07:49:23 <Philippa_> edwardk: hah! Yeah, that makes sense. Have to admit, I'm enjoying only having my fringe remotely long
07:49:44 <klrr> okey, i got some errors when i try run my a prototype i wrote, https://gist.github.com/klrr/5885217 (code and error in paste), anyone got an idea what the rpoblem might be?
07:50:07 <edwardk> bartavelle: i'm planning on adding a transformer to permit easy selection of how you want comments to parse. the current choice was rather deliberate, as it is necessary for things like the layout transformer to work
07:50:14 <edvardkk> typoclass: I think, whatever I say, mentioning lenses, should prove confusing to inattentive regulars
07:50:36 <bartavelle> edwardk, not sure what the layout transformer is, but I suppose you know what you are talking about
07:50:39 <edwardk> typoclass, chrisdone: of course.
07:50:40 <edvardkk> "wtf is edwardk on"
07:50:58 <bartavelle> anyway, can't wait for that transformer
07:51:00 <haasn> O.o
07:51:02 <edwardk> bartavelle: i have a monad transformer that gives you haskell-style layout parsing for your grammar
07:51:06 <Philippa_> ...y'know, I really ought to actually poke at trifecta properly one of these years
07:51:14 <Philippa_> I mean, I of all people
07:51:26 <bartavelle> yeah the error reporting is much nicer
07:51:32 <haasn> is edvardkk edwardk's evil twin brother?
07:51:40 <Philippa_> edwardk: mmm. On the bright side, you weren't evil enough to get Google to pay for Parsec 3 just so you could do it!
07:51:42 <bartavelle> I am not sure where the highlight stuff is used though
07:51:43 <edwardk> bartavelle: you just say 'layout someParser' and it uses someParser separated by virtal semicolons, etc.
07:51:55 <bartavelle> ah !
07:52:45 <edwardk> bartavelle: i'm not sure how well the highlighting is wired up in the 1.x trifecta. it was more actively used back in 0.53, but you can get the set of intervals that were highlighted out of the parser and there is some code for generating HTML of the highlighted document
07:53:29 <edwardk> bartavelle: i've also been working on another super-secret GLL parsing combinator library off and on for a few years whenever i think about it, but it isn't parsers compatible, and i'm not sure how much i like that ;)
07:53:30 <klrr> okey, i got some errors when i try run my a prototype i wrote, https://gist.github.com/klrr/5885217 (code and error in paste), anyone got an idea what the rpoblem might be?
07:54:00 <edwardk> and there is the new 'semiparsing' machinery that i should release sometime soon
07:54:27 <chrisdone> typoclass: <edwardk> I was working on a library and something occured to me, and now I'm wondering has anyone really been far even as decided to use even go want to do look more like?
07:54:29 <Botje> klrr: I don't see an error
07:54:44 <edwardk> parsing without the memory footprint
07:55:30 <bartavelle> does sound too good to be possible
07:55:37 <klrr> Botje: look at the paste, there's an error at buttom
07:55:44 <klrr> https://gist.github.com/klrr/5885217
07:55:57 <typoclass> chrisdone: =)
07:56:04 <Botje> yes, that's the one I opened. doesn't have an error.
07:56:17 <Botje> stops at line 31 with 'H.input ... "submit"'
07:56:32 <burkaman> klrr: you sure you're posting the right link? That gist just has some imports and three functions
07:56:58 <Hafydd> Enough people have been far even as decided to use even go want to do look more like for it to be extracted into its own library, methinks.
07:57:19 <klrr> Botje: burkaman sry i forgot click the comment button xD https://gist.github.com/klrr/5885217 now there should be an error
07:58:22 <klrr> i fixed the error!
07:58:23 <Botje> klrr: readMarkdown is a pure function, so you don't need to <- it.
07:58:41 <klrr> oh shit forgot that it was only for monads :
07:58:42 <klrr> :x*
07:58:48 <klrr> thanks, now everytthing is solved :D
07:59:42 <bitrust> I have a data type and a function that *might* join them: join :: a -> a -> Maybe a
07:59:56 <bitrust> I want to use this to add an `a` to a list of `a`
08:00:13 <bitrust> So something like: add :: (a -> a -> Maybe a) -> a -> [a] -> [a]
08:00:18 <typoclass> Hafydd: yah. semiparsing.
08:00:19 <typoclass> =)
08:00:43 <Botje> bitrust: and if join returns Nothing for all as?
08:01:04 <bitrust> Botje: append to list
08:01:31 <bitrust> I can construct this function... just wondering if there's something smart I could use already
08:01:35 <elliott> btw, the name join is taken, best to avoid confusion by avoiding it :)
08:02:09 <bitrust> elliott: don't plan to use join ;) just lazy to make up names
08:02:23 <typoclass> bitrust: so in 'add', you walk through the list until you find one element that will accept the new one?
08:02:27 <Botje> bitrust: it doesn't quite fit onto a foldl or foldr. maybe an unfoldr?
08:02:37 <bitrust> typoclass: exactly
08:03:14 <Botje> or mapAccumL. although I'd just go for a nice recursive functino
08:03:24 <bitrust> Botje: I was trying to figure a scanl but not too sure
08:03:50 <acube_> http://hpaste.org/90568 how would I rewrite this to only use a constant amount of memory?
08:04:52 <typoclass> you could do map (join' new) xs, giving a list of [Maybe a]. then you could do listToMaybe . catMaybe on that
08:05:34 <acube_> what's join'?
08:05:59 <acube_> Oh, was that about my example or wasn't it?
08:06:01 <typoclass> acube_: the function that bitrust specified
08:06:05 <acube_> ah ok :P
08:06:06 <Peaker> a foldr that's strict on its second argument will always stack overflow on huge lists, right?
08:06:09 <typoclass> acube_: oops yes sorry :-)
08:06:18 <typoclass> bitrust: ^^ earlier comment was for you
08:06:33 <klrr> now i get a VERY strange error when i run my file using runhaskell https://gist.github.com/klrr/5885357 any ideas?
08:07:17 <bitrust> Thanks Botje, typoclass. Will try mapAccumL otherwise just write a recursive func.
08:09:20 <Peaker> The pretty lib seems buggy here: https://github.com/haskell/pretty/blob/master/src/Text/PrettyPrint/HughesPJ.hs#L388  because above_' is strict on its second argument, I'm wondering what the right fix is
08:09:41 <burkaman> klrr: that looks very similar to an issue someone had a few days ago
08:09:53 <burkaman> klrr: look through this conversation http://ircbrowse.net/browse/haskell?events_page=455622 and see if that helps at all
08:13:13 <haasn> are there any good libraries out there for factorization of integers apart from â€˜primesâ€™?
08:14:38 <Lethalman> haasn, there are several ones
08:15:56 <bitrust> Botje: Bah, finally it's a really simple recursive function. Was looking too far ;)
08:16:01 <Lethalman> haasn, for example http://hackage.haskell.org/packages/archive/arithmoi/0.2.0.1/doc/html/Math-NumberTheory-Primes-Factorisation.html
08:16:07 <klrr> burkaman: thanks!
08:17:35 <klrr> burkaman: hmm no error when i use cabal to build it though strange :/
08:17:36 <haasn> Lethalman: ooh, that's much faster than trial division =D
08:18:31 <Lethalman> haasn, eh yes that library is quite fast :-)
08:20:17 <acube_> Did anyone post an answer to this question "http://hpaste.org/90568 how would I rewrite this to only use a constant amount of memory?" ? I lagged out
08:20:49 <shachaf> acube_: Start by using traverse_ instead of traverse.
08:20:54 <elliott> not that I can tell.
08:21:36 <shachaf> Well, probably that's not the issue.
08:22:01 <acube_> yes, I have to force the whole list to determine the maximum
08:22:02 <shachaf> Oh, were you the person who was asking about how not to share the list?
08:22:41 <acube_> shachaf: yes I think that's what I'm asking about
08:22:46 <deggis> a security related wondering/question: after garbage collecting unused stuff, is there a way to ensure that the memory in question is wiped/scrambled afterwards?
08:23:09 <shachaf> deggis: If you're doing things like that you don't want GHC to be managing your memory.
08:23:43 <shachaf> Allocate the things that you care about via some FFI thing.
08:24:15 <deggis> shachaf: i guess that's reasonable way to look at it
08:26:07 <haasn> wait why does (#) have such a high precedence
08:26:11 <merijn> I'd probably implement some version of bracket to do the allocation and freeing
08:26:17 <haasn> base 2 # (2*5) -- looks so wrong
08:28:53 <Feryll> I'm trying to make a function that will append a value to the innermost lists of a nested structure, but I think I'm running into type errors http://hpaste.org/90580
08:29:09 <deggis> i think this quickly leads to conclusion that i should be more paranoid to have motivation to implement that
08:29:25 <edwardk> haasn: i don't remember honestly
08:29:37 <elliott> probably because you have to say Just (2*5) Too
08:29:38 <elliott> *too
08:29:39 <edwardk> haasn: throw an issue on the lens issue tracker and we can debate it out there
08:30:15 <edwardk> i think the goal was to make it possible to port diagrams to it with some work but i've forgotten now
08:30:21 <edwardk> so it can't have been too important of a reason
08:30:40 <haasn> I guess the issue here for me is just that â€˜#â€™, as a character, feels like it should have a lower precedence - almost like % or $ or & or whatever
08:30:42 <edwardk> gotta run. later
08:30:59 <edwardk> i can see that. hence why i suggested posting it to the issue tracker to get feedback
08:31:01 <edwardk> =)
08:31:06 <acube> shachaf: How can I avoid sharing in this case?
08:31:11 <edwardk> my kneejerk reaction is to agree with you
08:32:41 <tac> @type ap
08:32:42 <lambdabot> Monad m => m (a -> b) -> m a -> m b
08:32:52 <astor> From the ghc download page: "For most users, we recommend installing the Haskell Platform instead of GHC. The current Haskell Platform release includes a recent GHC release as well as some other tools (such as cabal), and a larger set of libraries that are known to work together. "  <- not true
08:33:14 <astor> There is no ghc in the haskell platform.
08:33:32 <elliott> not true
08:33:36 <elliott> there is GHC in the haskell platform
08:33:42 <elliott> just not the source distribution
08:33:42 <burkaman> Feryll: did you mean to post this link? http://hpaste.org/90581
08:33:50 <tac> > [(+), (-)] <*> [1,2,3] <*> [4,5]
08:33:52 <lambdabot>   [5,6,6,7,7,8,-3,-4,-2,-3,-1,-2]
08:34:22 <elliott> it could perhaps be better worded but you can install the Haskell Platform without GHC (and this is what e.g. most Windows/OS X/even Ubuntu or Arch or whatever users will do), and the definition of a Haskell Platform version includes a GHC version
08:34:26 <Feryll> burkaman: yes
08:34:51 <Feryll> Wait, no.
08:35:08 <Feryll> ?? Yes, apparently. I'm blind.
08:35:08 <lambdabot>  Yes, apparently. I'm blind.
08:35:13 <astor> elliott: ah.  but the haskell platform isn't supported on the recent 13.04 ubuntu for example.  so I think the source distro is pretty relevant.
08:35:53 <laku> Is there a way to prevent ghc from loading a particular (not needed) package when compiling TH code?
08:36:22 <elliott> astor: yeah it is perhaps a bit too red and scary :)
08:36:44 <b2coutts> haha what, haskell isn't supported in ubuntu 13.04?
08:36:51 <b2coutts> how did that happen?
08:36:56 <thoughtpolice> laku: unfortunately, no.
08:37:12 <astor> b2coutts: I mean, it isn't pre-packaged.
08:37:20 <merijn> b2coutts: The new platform probably isn't, last I checked Ubuntu used a platform from 2012
08:37:25 <b2coutts> oh, right
08:37:34 <mauke> to compile the platform from source, you need ghc anyway
08:37:54 <b2coutts> is ghc written in haskell?
08:38:04 <Kinnison> Irritatingly, yes :-(
08:38:04 <mauke> b2coutts: yes
08:38:17 <b2coutts> haha
08:38:25 <elliott> it's written in ghc-specific haskell
08:38:26 <b2coutts> I guess the earliest version must have been C or something?
08:38:35 <mauke> your guess is wrong
08:38:37 <elliott> it was bootstrapped from Lazy ML
08:38:39 <thoughtpolice> the earliest version was a Haskell compiler implemented in Lazy ML, i think
08:38:40 <elliott> iirc
08:38:49 <b2coutts> ah
08:38:50 * Kinnison wishes it was bootstrappable without itself
08:39:29 <b2coutts> haha, people should have written it in haskell, then used the language spec and the code they wrote to hand-compile the code itself
08:39:34 <thoughtpolice> which was written by Lennart. and didn't he write Lazy ML too or something?
08:39:43 <dolio> I think he did.
08:40:06 <Dobias> Hi, I am trying to get the IO example from LYAH to run, but I do not understand this error: http://codepad.org/7Re2LYK5
08:40:08 <thoughtpolice> yeah, i was pretty sure. that guy has implemented a lot of lazy functional language compilers
08:41:04 <Peaker> Can anyone who knows a bit about the pretty library look at the commits in https://github.com/Peaker/pretty/commits/master  -- to see if they make sense?
08:41:04 <Kinnison> Dobias: You probably want to unindent line 27 to match the let
08:41:14 <Kinnison> sorry, line 37
08:41:16 <Peaker> I fixed a foldr which was strict on its second argument, but to do this I had to change a whole bunch of things :(
08:42:08 <mauke> https://github.com/ghc/ghc/tree/e7d21ee4f8ac907665a7e170c71d59e13a01da09
08:43:01 <b2coutts> Dobias: try ending the do block with `return ()'
08:43:15 <b2coutts> (indented as far as let is indented)
08:43:43 <burkaman> Feryll: what's the type signature of this function? Or, what structure is it supposed to operate on?
08:43:50 <merijn> b2coutts: No, line 37 is not a let binding and shouldn't be indented to the let
08:43:51 <Peaker> does this kind of fix: https://github.com/Peaker/pretty/commit/c17c764fd3dbc671f75be6151150588ac72707a1  make sense to make pretty non-strict in its second arg in foldr?  It only wants to know if the right-side is empty, so I put the Empty doc outside of the ordinary Doc sumtype
08:44:08 <b2coutts> merijn: oh, right
08:44:39 <laku> Has anyone experience in using the curl package with ghci or in the presence of TH on windows?
08:44:40 <thoughtpolice> wow, Sigbjorn Finne was working on GHC back in 96? nuts.
08:44:41 <Dobias> b2coutts: Do you mean like this? http://codepad.org/cVwVjS2i
08:45:00 <mauke> thoughtpolice: who's that?
08:45:13 <b2coutts> Dobias: I did, but I was wrong; merijn was right, you need to unindent bracketOnError to it's at the same level as the let
08:45:15 <Feryll> burkaman: I'm new, so I'm not sure what the type signature should be, exactly. But for example, digpend 5 [[[3,2,1],[9,0,1]],[[1,0],[99]]] would return [[[5,3,2,1],[5,9,0,1]],[[5,1,0],[5,99]]]
08:45:19 <Dobias> Kinnison: I guess you mean line 37? http://codepad.org/AlrqFZkV
08:45:32 <Kinnison> http://hpaste.org/90582
08:45:39 <mauke> <Kinnison> sorry, line 37
08:45:41 <thoughtpolice> mauke: he used to do a lot of GHC-on-Windows hacking for a long time and even maintained the Cygwin port when it was alive (although it bitrotted in preference to MinGW, i think)
08:46:46 <pxqr> is it possible to include literate haskell module to ordinary cabal package without any system dependencies?
08:46:53 <Feryll> burkaman : Ideally, it would work on any list of lists of ... by induction. Is that allowed?
08:46:53 <thoughtpolice> i might be wrong, that's just from memory. he also worked at Galois for a while and did stuff like .NET interop
08:47:07 <thoughtpolice> apparently he works at Opera now
08:47:10 <Dobias> Kinnison: Thanks, but now i get: todo_list_manager.hs:37:5: Not in scope: `bracketOnError'
08:47:13 <pxqr> maybe it sounds a bit strange though
08:47:33 <Dobias> and "Undefined variable "openTempFile" on codepad.
08:47:48 <Dobias> Did I forget an import?
08:48:06 <Kinnison> Dobias: bracketOnError comes from Control.Exception I think
08:48:07 <Dobias> (I am using GHC.)
08:48:14 <Kinnison> @hoogle bracketOnError
08:48:15 <lambdabot> Control.Exception.Base bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:48:15 <lambdabot> Control.Exception bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:48:15 <lambdabot> Control.OldException bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:48:18 <Kinnison> yep
08:48:33 <burkaman> Feryll: I'm fairly new too haha. If you want it to work on lists nested to an arbitrary level, I don't think that's doable without weird typeclass trickery
08:48:53 <burkaman> Feryll: See this question for example http://stackoverflow.com/questions/6641703/haskell-nested-empty-lists
08:50:00 <Feryll> burkaman: I suppose I'll manually do it to some level of nesting for now. Thanks for the help!
08:50:07 <burkaman> Feryll: It might be possible with language extensions like the accepted answer uses, but that's a little beyond me
08:51:15 <Dobias> Kinnison: Great, now it works and I can add my bump function like in the exercise. Thanks. :)
08:51:42 <Kinnison> Dobias: You're very welcome
08:52:32 <Dobias> :) have a nice day, bye
08:57:58 <acube> Is there a "pure" version of pipes or does that not make sense? I'd like a function runProxyPure = runIdentity . runProxy or something equavilent
08:59:27 <mauke> aren't pipes pure?
08:59:54 <acube> They are, but there is no shortcut for runIdentity . runProxy, and I'm not sure if it's maybe a bit too much for my purpose
09:00:15 <acube> I want a list that is not shared
09:01:00 <acube> I thought that pipes does pretty much what I want, and it also has a nice interface for this sort of thing, with it's Producer's and Pipe's.
09:03:27 <stolaruk> I found this statement on the "Ten Things You Should Know About Haskell Syntax" blog entry on the FP Complete blog: "Anything that starts with a capital letter is either a concrete type or a data constructor." What about "Maybe a"? (Isn't this called a "type constructor"?)
09:03:54 <mauke> yes, and also a concrete type
09:04:22 <mauke> short version: uppercase = constants, lowercase = variables
09:04:25 <stolaruk> "Maybe a" is concrete?
09:04:31 <mauke> no, Maybe is
09:04:55 <b2coutts> ? I thought "Maybe a" was a concrete type, "Maybe" is a type constructor?
09:04:57 <merijn> stolaruk: I have seen the term "concrete type" before and it always results in mass confusion
09:05:45 <stolaruk> I think "Maybe String" is concrete, but "Maybe a" is a type constructor.
09:05:50 <stolaruk> Right?
09:05:59 <merijn> I would just drop the entire idea of "concrete type" and just refer to things as either types or type variables, if you wanna be specific about the number of arguments, use their kind
09:06:16 <Philippa_> Maybe a is a type, but it's got a variable in it: in that sense it's not "concrete" because it's "forall a.Maybe a" or similar
09:06:29 <b2coutts> my understanding was that a concrete type is any type whose kind is *
09:06:33 <b2coutts> :k Maybe a
09:06:35 <lambdabot> Not in scope: type variable `a'
09:06:35 <merijn> I don't see much value in the distinction between concrete and non-concrete
09:06:37 <tac> I don't think concrete type has any meaning :P
09:06:44 <Philippa_> b2coutts: yeah, that's a reasonable definition
09:06:48 <merijn> :k forall a . Maybe a
09:06:49 <lambdabot>     Illegal symbol '.' in type
09:06:49 <lambdabot>     Perhaps you intended -XRankNTypes or similar flag
09:06:49 <lambdabot>     to enable explicit-forall syntax: forall <tvs>. <type>
09:06:53 <merijn> awww
09:06:58 <Philippa_> merijn: "one of these things directly describes a value" is a useful distinction
09:07:13 <tac> For sure, Maybe isn't a type, but a type family (at least in type theory... I think type family might mean something different in Haskell?)
09:07:17 <merijn> Philippa_: Then I would just say "type of kind *"
09:07:31 <b2coutts> tac: Maybe is a type constructor
09:07:39 <Philippa_> but that doesn't say what's /interesting/ about kind *
09:07:51 <Philippa_> and you're in no end of trouble if * stops being the only kind of  concrete types
09:07:51 <b2coutts> if you give it a type, it creates another type
09:07:56 <elliott> "type" and "concrete type" is better terminology than "type constructor" and "type", at least
09:08:03 <shachaf> ski mentioned "uninhabitable" and "inhabitable" for things of kind not-* and * respectively.
09:08:18 <shachaf> (As contrasted with "uninhabited" and "inhabited".)
09:08:28 <tac> I think sometimes "concrete type" is used to distinguish between when there are no free type variables in a type
09:08:31 <elliott> shachaf: "Maybe is an uninhabitable type" doesn't seem like a very useful description...
09:08:34 <Philippa_> elliott: "type constructor" I think should be specifically the simple one-identifier syntactic entities, yeah
09:08:37 <tac> So [a] isn't concrete (by this definition), but [Int] is
09:09:01 <shachaf> TANSTAAFTV
09:09:01 <tac> Maybe isn't a type, and can't be inhabited or not >__>
09:09:10 <elliott> Philippa_: I figure the special thing is being kind *, not being kind k1 -> k2 (and of course those aren't the only options these days), and we don't talk about "value constructors" (functions) and "values" (never allowed to be functions).
09:09:12 <merijn> tac: Sure it is
09:09:17 <shachaf> Anyway, people have different definitions for these words, and they'll never agree on them ever.
09:09:19 <merijn> Maybe is a type of kind * -> *
09:09:24 <shachaf> So just make sure people know what you mean.
09:09:30 <elliott> shachaf++
09:09:35 <Philippa_> elliott: we /do/ talk about data constructors though
09:09:38 <elliott> state your definitions, even the obvious ones
09:09:38 <b2coutts> my understanding has been that a concrete type is a type of kind *, a type constructor is a type with any other kind, and a type is either a concrete type or type constructor
09:09:51 <b2coutts> at least, that's what I gleaned from lyah
09:09:53 <tac> merijn: the notion of "inhabited" only makes sense for types of kind *, though
09:09:55 <merijn> b2coutts: Oh, careful!
09:09:57 <Philippa_> and there's an expectation that if your data is of function type, something 'interesting' is happening
09:09:59 <elliott> Philippa_: right. but people like to say, Int is not a type constructor, it is just a type. Maybe is a type constructor.
09:09:59 <shachaf> What about codata nstructors?
09:10:10 <elliott> Philippa_: it's that usage I dislike
09:10:13 <Philippa_> elliott: yeah, and they're wrong. It's a nullary constructor
09:10:14 <b2coutts> (and I realize my definition there was infinitely recursive :P)
09:10:17 <merijn> b2coutts: Is True a type constructor?
09:10:28 <merijn> b2coutts: It has a kind other than *!
09:10:33 <b2coutts> merijn: no, nor is it a type, though
09:10:36 <mauke> it is now
09:10:41 <magneticduck> lol mauke
09:10:44 <elliott> Philippa_: I find it remarkably hard to convince people they are wrong about their definitions of words :)
09:10:47 <merijn> b2coutts: Sure it is, True is a type of kind Bool
09:10:58 <elliott> merijn: erm...
09:11:01 <b2coutts> merijn: it's a value that has a type of Bool
09:11:11 <merijn> b2coutts: Fire up ghci, type ":set -XDataKinds" and type ":k True"
09:11:11 <chrisdone> â€¦ did haskell get a new extension?
09:11:14 <Chousuke> do you have DataKinds enabled? :P
09:11:22 <elliott> I think DataKinds is a bit silly to bring into this. actually the whole thing is silly.
09:11:26 <stolaruk> Concerning the original statement, "Anything that starts with a capital letter is either a concrete type or a data constructor." - how does "Maybe a" fit in here?
09:11:32 <Philippa_> elliott: that particular one's a case of the "only the most specific notion applies" thing, which... well, at least you can point out to people that they're doing it and we sure as hell have nullary data constructors
09:11:39 <mauke> stolaruk: it doesn't. "Maybe a" isn't a thing
09:11:44 <mauke> stolaruk: (it's two things)
09:11:52 <magneticduck> ..
09:11:56 <magneticduck> well I have an actual problem
09:12:00 <magneticduck> anybody wanna help?
09:12:02 <chrisdone> mauke: Maybe a isn't a thing. it'll never be a thing! stop trying to make it a thing!
09:12:02 <magneticduck> :3
09:12:07 <b2coutts> stolaruk: "Maybe a" doesn't mean anything on its own
09:12:09 <elliott> Philippa_: right
09:12:12 <merijn> elliott: The whole thing was silly, I was just illustrating by sily example
09:12:16 <elliott> Philippa_: people have so little respect for base cases :(
09:12:18 <Philippa_> magneticduck: sure, ask away!
09:12:19 <b2coutts> stolaruk: "Maybe Int", "Maybe String", etc are all concrete types
09:12:32 <stolaruk> "Maybe a" starts with a capital letter tho...
09:12:39 <b2coutts> :t Just
09:12:39 <lambdabot> a -> Maybe a
09:12:51 <magneticduck> alright, so long story short I'm trying to make a game, and the first thing I'm doing is writing a geometry package that does shit with 2d euclidean geometry
09:12:57 <merijn> b2coutts: Anyway, with DataKinds you can have any value as type
09:13:08 <Philippa_> stolaruk: A matter of scope. "Thing" there means lexical entity, not syntactic
09:13:25 <merijn> b2coutts: You can do neat things like have values of type "Foo (Just *)"
09:13:42 <magneticduck> at its uppermost level right now, it can represent Paths made out of lines and arcs and do a bunch of stuff with them (intersecting, projecting, dealing with distances, etc)
09:14:11 <phulin> okay
09:14:14 <magneticduck> now, I have a really annoying bug that involves cutting a path into two subpaths given a distance
09:14:18 <magneticduck> I'm testing it with gloss
09:14:38 <phulin> if i try to do trace s $ return () inside a monadic computation, will haskell memoize the result and only trace the first time i run the computation?
09:14:39 <magneticduck> basically, I just make an arc path based on the mouse cursor point and then try to cut it up
09:14:53 <elliott> phulin: depends
09:14:58 <elliott> is it behind a lambda?
09:15:00 <magneticduck> it works most of the time, but after from 3 to 30 seconds of fiddling around with it, it stalls out
09:15:01 <phulin> nope
09:15:11 <magneticduck> with the error GHC stack-space overflow: current limit is 536870912 bytes.
09:15:15 <elliott> phulin: then maybe, depending on how the monad is defined and where you place it and stuff.
09:15:21 <magneticduck> I can't recreate it in ghci
09:15:24 <phulin> okay, it appears to be doing that
09:15:28 <elliott> you want it to be at the start at least.
09:15:40 <phulin> elliott, is there a better way to debug a monadic thing?
09:15:40 <elliott> have to say, none of this is guaranteed, use it for debugging only, I'm not responsible :)
09:15:47 <magneticduck> I printed the current position to the screen and tried recreating it in ghci so I could try and trace it
09:15:52 <magneticduck> but it worked fine in GHCI
09:16:10 <elliott> phulin: well, I use trace quite a bit. but usually I just try to keep my definitions small and test them directly in ghci. think of it like dynamic unit testing.
09:16:30 <magneticduck> I can post the test module to hpaste and the library's on github, but I don't really expect anybody to read through all of it (it's a terrible mess too)
09:16:46 <phulin> my things consume complicated datatypes and would be extremely annoying to test in GHCI
09:16:56 <Chousuke> merijn: what do types of kind Maybe * express?
09:17:00 <elliott> I find if I'm writing my code idiomatically, it's not a very complex part, and it doesn't have to do with tricksy low-level or evaluation details, just getting the results out can help me debug it pretty well.
09:17:23 <phulin> elliott, I'm writing a symbolic executor for LLVM code, and the instructions are pretty complicated
09:17:24 <elliott> phulin: well, I'd suggest adding some helpers and doing some simplification so that is possible, if it's at all feasible :) you could also try quickcheck to automatically find what's messing up
09:17:32 <phulin> fair enough
09:17:43 <elliott> but yes, sometimes tracing is the easiest way
09:18:10 <phulin> okay, is there a way to force the trace to evaluate every time?
09:18:41 <merijn> Chousuke: That depends on the context you use them in, mostly you'd use it as a phantom type argument
09:19:08 <magneticduck> I did a bunch of fiddling around and mental tracing of stuff, but didn't get a lot done
09:19:24 <magneticduck> I'm not really sure how to proceed with this kind of problem
09:19:30 <elliott> phulin: maybe as simple as turning M () into () -> M ()
09:19:41 <elliott> and passing a () at the use site and maybe marking the defiition NOINLINE
09:19:45 <elliott> and even that might be overkill
09:20:00 <elliott> GHC doesn't like introducing space leaks so it's generally really easy to get it to stop sharing results
09:20:01 <merijn> Chousuke: Imagine a datatype that is *may* contain values of type a or be something very different, you could have "data Foo :: Maybe * -> * where Container :: a -> Foo (Just a); OtherThing :: Foo Nothing" or something
09:20:42 <magneticduck> test module is http://hpaste.org/90583 and my github page (with EuclideanThings and EuclideanGloss are) is https://github.com/MagneticDuck?tab=repositories a
09:20:48 <merijn> Unfortunately, you can't make that a Functor without ugly Compose (un)wrapping
09:21:11 <magneticduck> I guess the one reasonable thing that I could ask for here would be for somebody to look at the code and see if there's any terrible style / design problems
09:22:02 <magneticduck> (the module in question is EuclideanThings)
09:22:11 <magneticduck> thanks in advance
09:23:52 <magneticduck> I'm a newbie here btw, this is my first large serious project
09:26:42 <magneticduck> is anybody checking it out
09:26:44 <magneticduck> :<
09:26:53 <magneticduck> I should probably organise my code while I can't do anything
09:27:19 <phulin> elliott, i turned down the optimization level and now it's behaving
09:27:31 <phulin> should have done that a long time ago, silly me
09:27:39 <elliott> phulin: my kingdom for a maintained declarative debugger
09:27:47 <phulin> i know
09:27:55 <elliott> oh you may be able to make use of ghci's bizarre debugger that i never spent the time to understand
09:29:22 <phulin> well now that my traces are working correctly maybe something will make sense
09:29:43 <phulin> also, i really wish $ and <$> had the same precedence.
09:31:46 <magneticduck> hallo?
09:35:21 <elliott> magneticduck: most people probably don't have time/energy to look at a whole repository -- maybe hpaste some specific parts you think might be in error and someone could help?
09:54:32 <haasn> magneticduck: from a quick scrollthrough all I can say is you have a lot of functions that nest really, really deep
09:55:00 <haasn> in your position I'd be thinking about ways to factor out common things or subfunctions in order to break the code down into smaller, more readable and comprehensible chunks
09:55:28 <haasn> that nest blocks*
09:55:49 <burkaman> Hey, does anyone know if the pointfree package works with the latest Haskell Platform? I'm getting the error "Not in scope: data constructor `State'" when it tries to compile Plugin\Pl\Transform.hs, which doesn't really make sense to me.
09:56:50 <haasn> burkaman: I doubt it, lambdabot's code is already really outdated, save for some fixes made by the guys who run this channel's instance
09:57:13 <sclv_>  burkaman the new transformers lib now has that lowercase
09:57:18 <sclv_> since its a function and not a constructor
09:57:21 <sclv_> should be easy to fix
09:57:33 <haasn> yeah, fix it and upload a new version =)
09:57:39 <mebaran151> I have a Conduit Source and I would like to read it into a bytestring
09:57:42 <mebaran151> how do I do this?
09:58:05 <monochrom> burkaman: right, pointfree is quite old wrt current state. (pun!) for every error of that kind, change "State" to "state". it's an API change in mtl.
09:58:08 <sclv_> actually the maintainer is pretty active -- i'm sure he'd have no problem if you emailed him and pointed out the issue
09:59:31 <burkaman> Ok awesome thanks guys. I'll take a look at the source and see if it's a simple fix.
10:01:40 <acube> mebaran151: I don't use conduit myself, but I heard there is conduit-bytestring
10:01:50 <acube> @hackage conduit-bytestring
10:01:50 <lambdabot> http://hackage.haskell.org/package/conduit-bytestring
10:01:59 <acube> Well, that's not it
10:02:04 <acube> @hackage bytestring-conduit
10:02:04 <lambdabot> http://hackage.haskell.org/package/bytestring-conduit
10:02:11 <acube> hmm
10:02:54 <mebaran151> oh I already have one of those: I'm just wondering how to get the bytestring out of a conduit
10:02:59 <mebaran151> #yesod
10:03:18 <burkaman> Oh nevermind, the latest version of pointfree works fine. There's some issue with the dependencies though, so cabal tries to use an older version that doesn't work anymore.
10:05:03 <acube> @@ Is there an alternative to (@hackage boxes) ? It doesn't seem to be maintained anymore
10:05:04 <lambdabot> Plugin `compose' failed with: Unknown command: ""
10:05:37 <elliott> lambdabot serves mortals no more
10:06:01 <CaptainK> how to get this: [1,2,3] to this: 123 ?
10:06:07 <bscarlet> If I have a typeclass C and type A, how do I say "a function from A to something which has an instance of C but I won't tell you what", and is RankNTypes sufficient to let me do this?
10:06:29 <supki> CaptainK: concatMap show
10:07:06 <bscarlet> I want to put two such functions returning values of different types into the same list.
10:07:26 <supki> CaptainK: oh, you meant number
10:07:26 <byorgey> acube: not that I know of
10:07:27 <acube> zipWith (*) (iterate (*10) 1) $ reverse [1,2,3]
10:07:34 <acube> > zipWith (*) (iterate (*10) 1) $ reverse [1,2,3]
10:07:36 <lambdabot>   [3,20,100]
10:07:41 <acube> > sum $ zipWith (*) (iterate (*10) 1) $ reverse [1,2,3]
10:07:42 <lambdabot>   123
10:07:57 <byorgey> acube: does it not work?
10:08:10 <acube> byorgey: The dependency bounds are outdated
10:08:14 <phetus> Hey guys, so I have a problem that is foiling me, and I thought you all might have some insight. I have a GADT that has an Integer type and a Float type, and I want to perform math functions which will maintain Integer if possible until a float is introduced, even as a *.0 number. I am thinking of something like a Maybe monad which will maintain Float (like Nothing) when >>=....
10:08:20 <byorgey> acube: ah, so they are
10:08:20 <CaptainK> looks good, but what a lot of code
10:08:59 <acube> > read $ concatMap show [1,2,3] :: Int
10:09:00 <lambdabot>   123
10:09:09 <monochrom> bscarlet: that is existential type. define "data Secret = forall t. C t => Ctor t". then your function's type is A -> Secret
10:09:30 <byorgey> acube: oh, it looks like it's updated on github but there hasn't been a new releaese
10:09:41 <CaptainK> how do you strip the quotes in "123" output?
10:09:53 <bscarlet> monochrom: the data wrapper is necessary?
10:09:58 <acube> CaptainK: It's not a string, it's a number
10:09:59 <monochrom> yes
10:10:04 <bscarlet> monochrom: Thanks.
10:10:07 <acube> CaptainK: If you want to get a string, the code is just
10:10:12 <acube> > concatMap show [1,2,3]
10:10:13 <lambdabot>   "123"
10:10:30 <monochrom> GHC insists on making you create a type for existential types
10:10:31 <CaptainK> and to get just 123
10:10:39 <acube> > read $ concatMap show [1,2,3] :: Int
10:10:42 <acube> or
10:10:42 <lambdabot>   123
10:10:45 <acube> > sum $ zipWith (*) (iterate (*10) 1) $ reverse [1,2,3]
10:10:48 <lambdabot>   123
10:10:50 <supki> > foldl' (\a x -> x + 10 * a) 0 [1,2,3]
10:10:53 <lambdabot>   123
10:11:11 <CaptainK> folding, thats a good one
10:11:29 <Hafydd> @pl \a x -> x + 10 * a
10:11:32 <lambdabot> flip (+) . (10 *)
10:11:33 <lambdabot> optimization suspended, use @pl-resume to continue.
10:12:02 <Hafydd> (+) . (*10) will do.
10:12:47 <acube> > foldl' (\a x -> x + 10 * a) 0 [4,2,3]
10:12:48 <lambdabot>   423
10:13:24 <acube> ah, ok I got how that works
10:14:15 <Hafydd> > foldl1 ((+).(*10)) [1,2,3]
10:14:16 <lambdabot>   123
10:14:24 <Hafydd> If you don't care about the case of [].
10:14:49 <CaptainK> that is tight
10:15:53 <Hafydd> (Or readability)
10:16:22 <arkeet> foldl1 is sad =(
10:16:37 <elliott> the worst thing about foldl1 is that it makes me worry about scanl1.
10:16:39 <elliott> even though scanl1 is safe.
10:16:48 <arkeet> lol
10:17:31 <haasn> > [239, 201, 160] >>= review (base 16) -- finally, a quick and simple way to figure out hex code representations of colors, without having to fire up an image editor
10:17:33 <lambdabot>   Not in scope: `review'Not in scope: `base'
10:17:37 <haasn> screw you lambdabot
10:18:16 <ParahSailin> @src foldl1
10:18:17 <lambdabot> foldl1 f (x:xs) = foldl f x xs
10:18:17 <lambdabot> foldl1 _ []     = undefined
10:20:30 <tac> > foldl1 (+1) []
10:20:33 <lambdabot>   mueval-core: Time limit exceeded
10:20:36 <tac> > foldl1 (+1) []
10:20:40 <lambdabot>   mueval-core: Time limit exceeded
10:20:42 <tac> hmm
10:20:58 <stevejb> greetings, I am having some trouble installing hmatrix
10:21:05 <stevejb> in particular,
10:21:09 <stevejb> +++ OK, passed 100 tests.
10:21:10 <stevejb> ------ some unit tests
10:21:10 <stevejb> Cases: 69  Tried: 12  Errors: 0  Failures: 0Segmentation fault
10:21:11 <astor> anyone knows about a function implementing the 'comm' utility in haskell?
10:21:20 <CaptainK> how do you strip the "" from a string "TEN"?
10:21:51 <acube> CaptainK: The "" just comes from GHCi printing the string
10:22:12 <arkeet> haasn: that's not lensy enough
10:22:23 <arkeet> [239,201,160]^.folded.re (base 16)
10:22:26 <acube> CaptainK: if you want to write it to standard output without the ""'s, just use putStrLn (ends the line) or putStr (leaves the line open)
10:22:32 <haasn> arkeet: much better
10:22:41 <arkeet> btw that won't work for values below 0x10
10:22:49 <arkeet> (zero padding)
10:22:59 <CaptainK> ah ok, thanks so much
10:23:01 <haasn> ah, true
10:23:31 <haasn> well I guess a rudimentary â€œmap (base 16 #) [239,201,160]â€ gets the job done
10:24:05 <arkeet> then replace ^. with ^.. in mine.
10:24:34 <arkeet> think lensy :p
10:24:38 <haasn> yeah, still longer to type though; even if you go with â€˜eachâ€™ instead of folded =P
10:24:48 <arkeet> but lensy :P
10:25:15 <haasn> do we have an operator for â€œa ? b = a . re bâ€
10:25:36 <acube> @ty folded
10:25:38 <lambdabot>     Not in scope: `folded'
10:25:38 <lambdabot>     Perhaps you meant one of these:
10:25:38 <lambdabot>       `foldl1' (imported from Data.List),
10:25:40 <acube> :/
10:25:47 <acube> @import Control.Lens.Fold
10:25:48 <lambdabot> Unknown command, try @list
10:25:56 <haasn> acube: Foldable f => Fold (f a) a
10:26:04 <haasn> whoa, they sure have trimmed down
10:26:08 <acube> ah ok :)
10:26:39 <haasn> actually folded was always that simple
10:26:41 <haasn> nvm
10:35:23 <stevejb> hello, I could use a hand thinking through a function defintion
10:35:42 <stevejb> I am trying to do double integration using hmatrix, and I see that
10:35:54 <stevejb> let quad1 f a b = fst $ integrateQAGS 1E-9 100 f a b
10:36:06 <stevejb> this is single integration, integral from a to b of f
10:36:27 <stevejb> I am trying to use quad1 to do a double integral
10:39:37 <acube> Is there a package that provides a list data type that is never memoized/shared ?
10:40:43 <Hafydd> Why would you need that property?
10:41:28 <stevejb> what is let quad2 f a b g1 g2 = quad1 h a b where h x = quad1 (f x) (g1 x) (g2 x) doing?
10:41:54 <c_wraith> stevejb: really hard to know without the definition of quad1
10:42:19 <stevejb> c_wraith: let quad1 f a b = fst $ integrateQAGS 1E-9 100 f a b
10:42:37 <stevejb> the usage is that quad1 f a b provides the integral of f from a to b
10:43:17 <acube> Hafydd: basically, I'm looking for something like data Generator a = Generator { len :: Int, atIndex :: Int -> a }
10:43:31 <c_wraith> acube: but why does lack of sharing matter?
10:43:43 <Banistertab> Which is the best web framework for building restful apis?
10:44:24 <acube> I have a function that takes the list of indices it should operate on. It will probably consume that list multiple times => when the list is consumed the first time AND shared, it doesn't get GC'ed => the whole list is in memory
10:45:11 <byorgey> acube: you probably want repa.
10:45:39 <byorgey> it specifically has a type for such "virtual" arrays which are represented as a function, and will fuse operations on them together to avoid intermediate allocation
10:45:56 <c_wraith> stevejb: you'd be better off asking that in a channel about math. I can see what the operation does, but I have no clue what it means.
10:46:03 <stevejb> c_wraith: I think that what is happening is that g1 is a function providing lower bounds and g2 is a function providing upper bounds for the integration,
10:46:12 <stevejb> c_wraith: okay thanks
10:46:33 <c_wraith> stevejb: yeah, it is doing an integration over integrating.  I'm not sure why
10:46:33 <acube> byorgey: Right, that was what I was looking for. Thanks!
10:47:57 <stevejb> c_wraith: I am trying to replicate https://en.wikipedia.org/wiki/Multiple_integral#Double_integral
10:48:33 <c_wraith> stevejb: ok, thinking over it a bit more..  It's a double integral.  It's a strange representation, but that's all it is.
10:48:41 <c_wraith> oh, heh.  so it is.
10:48:50 <Hafydd> stevejb: what is the type of quad1? What is the type of quad2?
10:49:01 <stevejb> :t quad1
10:49:01 <stevejb> quad1 :: (Double -> Double) -> Double -> Double -> Double
10:49:01 <lambdabot> Not in scope: `quad1'
10:49:06 <c_wraith> It allows the inner bounds of integration to vary with the point being integrated at
10:49:14 <stevejb> :t quad2
10:49:14 <stevejb> quad2
10:49:14 <stevejb>   :: (Double -> Double -> Double)
10:49:14 <stevejb>      -> Double
10:49:14 <lambdabot> Not in scope: `quad2'
10:49:17 <stevejb>      -> Double
10:49:21 <stevejb>      -> (Double -> Double)
10:49:24 <stevejb>      -> (Double -> Double)
10:49:27 <stevejb>      -> Double
10:49:39 <Hafydd> Prepare for trouble! Make it Double!
10:49:51 <stevejb> c_wraith: so, in my case g1 and g2 rather than being functions, would be just numbers
10:50:06 <c_wraith> stevejb: then just use const foo  as the function
10:50:34 <stevejb> I'll give that a try. I may need some guidance with the syntax. This is my first haskell project.
10:50:50 <magneticduck> screw machine real numbers :<
10:50:54 <elliott> stevejb: btw, hpaste.org is available for pastes of more than a few lines :)
10:51:10 <magneticduck> > (sqrt 2) ^ 2
10:51:12 <lambdabot>   2.0000000000000004
10:51:14 <stevejb> elliott: thanks. I wasn't sure that the threshold was. Say, > 2 lines?
10:51:28 <elliott> about that, yeah
10:51:32 <acube> > (sqrt 2 :: Rational) ^ 2
10:51:33 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
10:51:33 <lambdabot>    arising from a us...
10:51:38 <magneticduck> is there any nice arbitrary - precision real number that's fairly fast to evaluate?
10:51:45 <stevejb> elliott: thanks. Good to know.
10:51:47 <magneticduck> that is, a data type with a Num instance
10:51:47 <acube> > (sqrt 2 :: Rational) ** 2
10:51:48 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
10:51:49 <lambdabot>    arising from a us...
10:51:51 <acube> > (sqrt 2 :: Rational) ^^ 2
10:51:52 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
10:51:52 <lambdabot>    arising from a us...
10:51:55 <magneticduck> that could be evaluated to a Double
10:52:04 <magneticduck> but that doesn't have that kind of problem
10:52:06 <byorgey> acube: um, the square root of two is not rational.
10:52:10 <magneticduck> (basic simplification)
10:52:23 <magneticduck> yeah, you need something more involved than Rational
10:52:26 <acube> byorgey: right, is there also Real?
10:52:35 <byorgey> > (sqrt 2 :: CReal) ^ 2
10:52:36 <lambdabot>   2.0
10:52:41 <magneticduck> >:0
10:52:44 <magneticduck> WUT IS THIS MAGIC
10:52:51 <magneticduck> CReal eh
10:52:59 <byorgey> magneticduck: infinite-precision computable real numbers
10:53:04 <magneticduck> awesome
10:53:13 <magneticduck> s/Double/CReal
10:53:17 <magneticduck> in all of my code
10:53:24 <Hafydd> Heh.
10:53:25 <magneticduck> xl
10:53:31 <acube> byorgey: How does that work? :O
10:53:33 <magneticduck> making a geometry library
10:53:42 <hamid> > (10 / 3) :: CReal
10:53:42 <lambdabot>   3.3333333333333333333333333333333333333333
10:53:43 <magneticduck> I could imagine
10:53:54 <hamid> > (10 / 3) :: Double
10:53:54 <lambdabot>   3.3333333333333335
10:53:58 <magneticduck> just some basic simplification
10:54:00 <Hafydd> Did you mean: haskell cereal
10:54:06 <magneticduck> ((1/3) :: CReal) * 3
10:54:16 <magneticduck> > ((1/3) :: CReal) * 3
10:54:17 <lambdabot>   1.0
10:54:19 <magneticduck> hahaha
10:54:27 <magneticduck> that's CeReal
10:54:37 <magneticduck> heh, silent e
10:55:18 <magneticduck> uhh, no CReal on hoogle
10:55:42 <magneticduck> >_>
10:55:48 <hamid> :k CReal
10:55:48 <lambdabot> *
10:55:52 <Hafydd> http://hackage.haskell.org/packages/archive/numbers/3000.1.0.3/doc/html/Data-Number-CReal.html
10:56:29 <magneticduck> lol, that is one tricky definition
10:56:36 <magneticduck> data CReal = CR (Int -> Integer)
10:56:46 <stevejb> given a function f2 :: Num a => a -> a -> a, how do I get a function of just the first argument
10:56:55 <stevejb> f2 3
10:56:59 <stevejb> oops
10:57:08 <magneticduck> uhh
10:57:11 <acube> > let f2 = (+) in join f2 3
10:57:12 <lambdabot>   6
10:57:13 <phulin> flip f2 3
10:57:24 <elliott> stevejb: (\n -> f2 n 123)
10:57:26 <magneticduck> lol join
10:57:29 <elliott> or (\n -> f2 n n) depending on what you meant
10:57:39 <elliott> join should be avoided until you know how it works, flip should be avoided :P
10:57:42 <magneticduck> more interesting functions
10:57:49 <magneticduck> lol elliott
10:57:58 <magneticduck> why? I use it all the time trying to make shit pointfree
10:58:00 <elliott> (well, knowing that join f x = f x x when f is a function is enough to know how it works. but you need that step)
10:58:13 <elliott> magneticduck: it rarely aids readability.
10:58:15 <magneticduck> something to do with lazy evaluation?
10:58:16 * acube uses (??)
10:58:18 <magneticduck> oh
10:58:24 <elliott> I like lens' infix flip (??) for some situations.
10:58:25 <elliott> like runState
10:58:26 <magneticduck> since when did haskell programmers care about readability?
10:58:31 <magneticduck> I mean, like, seriously
10:58:32 <acube> @let f (??) b = ($ b) <$> f
10:58:33 <lambdabot>  .L.hs:124:22:
10:58:33 <lambdabot>      Ambiguous occurrence `f'
10:58:33 <lambdabot>      It could refer to either `L...
10:58:39 <monochrom> I care
10:58:41 <acube> @let f' (??) b = ($ b) <$> f'
10:58:41 <lambdabot>  .L.hs:124:23:
10:58:42 <lambdabot>      Ambiguous occurrence f'
10:58:42 <lambdabot>      It could refer to either L.f...
10:58:48 <acube> @let f ?? b = ($ b) <$> f
10:58:49 <lambdabot>  Defined.
10:59:01 <phulin> do you guys generally consider it acceptable to write flip id?
10:59:04 <acube> > (-) ?? 3 $ 5
10:59:08 <lambdabot>   mueval-core: Time limit exceeded
10:59:09 <phulin> whenever i see that it takes me a second to remember what's going on
10:59:11 <monochrom> I just disagree with "readable = looks like mainstream languages"
10:59:21 <acube> > (-) ?? 3 $ 5
10:59:24 <lambdabot>   2
10:59:27 <magneticduck> that's not my point
10:59:33 * acube likes ?? :P
10:59:42 <monochrom> and I seriously suspect that most people do use "readable = looks like mainstream languages"
10:59:46 <elliott> monochrom++
10:59:58 <elliott> if you think Haskellers don't care about readability, that probably just means you write unreadable code :P
10:59:59 <startling> phulin, sure
11:00:04 <magneticduck> uhh
11:00:10 * magneticduck hides my code
11:00:21 <byorgey> magneticduck, acube: CReal is actually just using (something equivalent to) a lazy infinite-precision decimal expansion.  The Show instance is cheating.
11:00:21 <elliott> or else read very poor code. or just very strange code.
11:00:40 <elliott> uu-parsinglib looks like a complete mess until you realise the structure underlying the madness. then it just looks strange.
11:00:49 <magneticduck> ahah byorgey
11:01:00 <byorgey> e.g. for  (sqrt 2) ^ 2  if it is  2.00000... to 40 decimal places it just shows 2.0
11:01:08 <johnw> phulin: usually I would write flip ($), to be a little clearer
11:01:14 <phulin> johnw, yeah, me too
11:01:23 <byorgey> HOWEVER, it is true that (sqrt 2)^2  will really be exactly 2.000.... no matter how many decimal places you look at
11:01:30 <phulin> i had an argument with someone the other day who was claiming that flip id was more idiomatic
11:01:32 <scmc> intent
11:01:37 <byorgey> you can just never know whether you might get something other than a zero eventually
11:01:37 <phulin> not that it's really a matter of any significance
11:01:38 * acube would define (&) = flip id for once and then use that
11:02:06 <johnw> yes, I also use & if I've brought in lens for anything else
11:02:22 <magneticduck> > let (a = 0 :: CReal) in (((sin a) ^ 2) + ((cos a) ^ 2))
11:02:23 <lambdabot>   <hint>:1:8: parse error on input `='
11:02:31 <magneticduck> lolwut
11:02:32 <magneticduck> oh
11:02:35 <johnw> is Ozgun Ataman here?
11:02:39 <magneticduck> > let a = (0 :: CReal) in (((sin a) ^ 2) + ((cos a) ^ 2))
11:02:40 <monochrom> here is one little piece of evidence. people outside say "f <$> m <*> n is unreadable". after interrogation, it turns out they prefer alphabetical names instead of infix symbols, and they prefer "object.method(object)". that's what they mean by "readable".
11:02:40 <lambdabot>   1.0
11:02:43 <magneticduck> YES
11:02:56 <magneticduck> ....YES
11:03:05 <johnw> magneticduck: um, is that you?
11:03:07 <magneticduck> well, not suprising actually
11:03:11 <magneticduck> sorry
11:03:19 <magneticduck> > let a = (253.54 :: CReal) in (((sin a) ^ 2) + ((cos a) ^ 2))
11:03:20 <lambdabot>   1.0
11:03:46 * magneticduck stops spamming the chat
11:04:01 <monochrom> here is another little piece of evidence. people outside say "f (g (h x))" is unreadable. after interrogations, it turns out they prefer "y := h x; z := g y; t := f z". that's what they mean by "readable".
11:04:36 <byorgey> > showCReal 100 (pi*2)
11:04:37 <lambdabot>   "6.283185307179586476925286766559005768394338798750211641949889184615632812...
11:04:43 <byorgey> happy Tau Day!
11:04:44 <nexx> monochrom o0
11:04:53 <acube> I don't like f (g (h x))), i'd write f $ g $ h x or maybe f . g . h $ x
11:04:56 <magneticduck> today is Tau Day?
11:05:06 <byorgey> well, in the US at least
11:05:06 <magneticduck> acube: f . g . h $ x all the way for me
11:05:09 <monochrom> oh! yeah tau day!
11:05:11 <byorgey> 6/28
11:05:16 <magneticduck> awesome
11:06:51 <magneticduck> no longer will I have to go insane whenever I debug my graphics functions in GHCi
11:07:09 <magneticduck> (Vector 0.9999999999999999 2.453145335612e-16)
11:07:16 <magneticduck> rofl
11:08:17 <magneticduck> btw am I the only one here who likes keeping sub-modules small at around 300 lines?
11:08:27 <magneticduck> it's kind of wasteful of filenames for large projects
11:08:33 <magneticduck> but it helps me organize
11:08:37 <magneticduck> thoughts?
11:08:53 <Hafydd> Be careful - you might run out of filenames.
11:08:59 <magneticduck> ikr
11:09:09 <magneticduck> I make sure to nest my modules well
11:09:17 <magneticduck> so I don't have a lot of modules in the same directory
11:09:36 <magneticduck> > (10^6) / 300
11:09:38 <lambdabot>   3333.3333333333335
11:09:50 <magneticduck> ofc
11:09:53 <monochrom> you organize code as you see fit. why doubt yourself.
11:10:07 <magneticduck> because I'm a goddam newbie
11:10:11 <magneticduck> xl
11:10:18 <magneticduck> and I suck at most things involving programming in haskell
11:10:20 <monochrom> newbie in organizing code?
11:10:28 <magneticduck> probably
11:10:47 <magneticduck> I mean, the way I'm doing it now works
11:11:02 <magneticduck> but there's probably better ways to do it
11:11:10 <monochrom> how many lines per file is really unspecific to haskell. no correlation with new-to-haskell or old-to-haskell
11:11:28 <magneticduck> alright
11:12:21 <magneticduck> man I dominate the chat
11:12:27 * magneticduck goes into hibernation mode
11:12:33 <johnw> magneticduck: thanks :)
11:12:49 <monochrom> you could press the <enter> key fewer times. merge lines.
11:13:37 <byorgey> monochrom: magneticduck likes to keep his IRC lines small, at around 30 characters
11:13:50 <magneticduck> They're tweets.
11:13:55 <magneticduck> oh wait, this is IRC?
11:14:02 <monochrom> 30 is not even enough for some people's names! :)
11:14:25 <elliott> 9 characters is enough for names. as long as you can address monochrom you're ok.
11:15:00 <monochrom> > length "Sripathi Panditaradhyula Balasubrahmanyam"
11:15:00 <lambdabot>   41
11:15:10 <monochrom> that's http://en.wikipedia.org/wiki/S._P._Balasubrahmanyam :)
11:15:25 <magneticduck> that's a cute name
11:17:32 <magneticduck> lol, the irony has just set in; I actually have one of the longest names here
11:18:01 <TheGreatChatDomi> dam
11:18:24 <dario> @pl if True then "a" else "b"
11:18:24 <lambdabot> if' True "a" "b"
11:18:32 <dario> oh, right :)
11:19:00 <magneticduck> > 16 - (length "magneticduck")
11:19:01 <lambdabot>   4
11:19:21 <themagneticduck_> >:D
11:19:32 <johnw> magneticduck: anyway, this channel is for Haskell discussion.  Too much "chatter" tends to drown out legitimate discourse, so a little hibernation is appreciated :)
11:19:41 <themagneticduck_> awlright
11:20:36 <dario> @pl (\x -> if x then "a" else "b")
11:20:36 <lambdabot> flip (flip if' "a") "b"
11:20:39 * hackagebot tau 6.2831 - Tau, the ratio between any circle's circumference  and radius.  http://hackage.haskell.org/package/tau-6.2831 (BrentYorgey)
11:20:53 <monochrom> um, what? hahaha
11:21:23 <thoughtpolice> byorgey++
11:21:24 <dario> :>
11:21:53 <byorgey> that package has been around for a while, but I realized it would really be best if the "uploaded date" on Hackage was Tau Day =)
11:21:53 <monochrom> are you trying to be cute with the version numbers! 6.28, 6.283, 6.2831
11:22:05 <byorgey> I am not trying to be CUTE I am trying to be ACCURATE
11:22:12 <monochrom> haha
11:22:13 <djahandarie> Haha
11:22:30 <geekosaur> Knuth versioning
11:23:30 <byorgey> yes, it's possible I *might* have gotten the idea from someone else.
11:25:11 <themagneticduck_> you should add documentation, byorgey
11:25:39 <monochrom> it has documentation. hackage just likes to show it later.
11:25:48 <luite> byorgey: i like pi better since you can get 5 digits correct in the upload date/time (24h hh:mm:ss), with tau only 3
11:25:56 <monochrom> so, reload the page later, you will get docs
11:26:46 <themagneticduck_> huh
11:27:36 <byorgey> themagneticduck_: you can look at the documentation for version 6.283, it is identical
11:27:50 <byorgey> luite: that is the worst argument for pi I have ever heard.
11:28:51 <luite> hmm that's rather hard to believe
11:29:09 <themagneticduck_> yeah, I could do a worse one
11:29:15 <byorgey> hehe, true, I'm not sure I believe it myself
11:29:15 <Sculptor> byorgey, that's the worst approximation of 2*pi i ever saw
11:29:32 <roconnor> 2*pi :: CReal
11:29:35 <roconnor> > 2*pi :: CReal
11:29:36 <lambdabot>   6.2831853071795864769252867665590057683943
11:30:19 <b2coutts> :t pi
11:30:19 <lambdabot> Floating a => a
11:30:34 <themagneticduck_> problem: who here does NOT use 't' as a single letter variable in day to day code?
11:30:35 <themagneticduck_> :l
11:30:50 <themagneticduck_> (t is exported by Math.Tau)
11:30:52 <byorgey> themagneticduck_: why does that matter?
11:30:55 <byorgey> no it isn't.
11:31:32 <Cale> themagneticduck_: that's a Ï„ not a t
11:31:44 <themagneticduck_> ahah
11:38:17 <themagneticduck_> is there any single predicate for RealFrac to see if they're actually numbers (not infinity or NaN)?
11:38:55 <burp> > 44/7
11:38:57 <lambdabot>   6.285714285714286
11:39:38 <byorgey> look, now Sculptor has seen a worse approximation of 2*pi
11:39:57 <Sculptor> > 2 * 355/ 113
11:39:58 <lambdabot>   6.283185840707965
11:40:05 <themagneticduck_> > (2 * pi) - (44/7)
11:40:07 <lambdabot>   -2.5289785346993554e-3
11:40:49 <burp> it has a worse absolute error than 22/7 for pi, that's another reason for pi
11:41:15 <themagneticduck_> that's not a reason
11:41:19 <themagneticduck_> tau is larger
11:41:53 <themagneticduck_> larger absolute error is understandable; and besides, you're not gaining anything by using the approximation 22/7 for pi instead of 44/7 for tau
11:42:05 <themagneticduck_> ...for the obvious reason
11:42:24 <byorgey> I don't like all the pointy ends on a 3, that's a reason against pi
11:42:36 <themagneticduck_> > pi :: CReal
11:42:38 <lambdabot>   3.1415926535897932384626433832795028841972
11:42:44 <themagneticduck_> it's ugly.
11:42:49 <burp> just as valid as luites date/time argument :P
11:44:02 <burp> why does noone consider pi/2?
11:44:43 <luite> themagneticduck_: but 44/7 is a topologically more complex approximation than 22/7 due to the counters in the 4 (in my font at least)
11:45:07 <themagneticduck_> while we're switch all pies to halftaus, we might as well switch to base 12, and also rewrite the linux kernel in haskell
11:45:11 <themagneticduck_> I'd like that.
11:45:16 <themagneticduck_> ;D
11:47:01 <b2coutts> man, why don't we use base 12 instead of base 10?
11:47:20 <b2coutts> "we have N fingers" is a silly way to choose a base of a numbering system
11:47:31 <themagneticduck_> there are dumber ways
11:47:52 <themagneticduck_> and that aspect of human anatomy is pretty important
11:48:17 <b2coutts> sure, but doesn't really make sense if you think about it
11:48:33 <b2coutts> having the base of the numbering system equal to the number of fingers doesn't make it any easier to count on our hands
11:48:42 <johnw> guys, none of this is about Haskell
11:48:48 <b2coutts> it's the kind of thing that seems like it makes sense if you only think about it for a second
11:49:06 <orzo> i'm using conduits to send xml on a socket, but when i send some chunks of xml, i wnat them to go immediately.  I'm using xml-conduit's renderBytes function to produce the bytestrings for the socket, and it seems to be holding back.  How do i fix this?  Should I scrap renderBytes and construct my bytestrings directly?
11:49:07 <byorgey> yeah, sorry, let's move this to #haskell-blah
11:49:38 <johnw> orzo: what do you mean by "holding back"?
11:50:09 <djahandarie> Hmm, I want a function [a] -> (a -> [a]) -> [[a]] which does something like [[f a !! 0, b, c],   [f a !! 1, b, c],   [a, f b !! 0, c],   [a, f b !! 1, c],   [a, b, f c !! 0],   [a, b, f c !! 1]]
11:50:24 <djahandarie> Does this already exist or do I need to write it?
11:50:40 <orzo> johnw: i mean nothing happens on the othe rend of the socket, no information is comming, until i close the connection, then the "await" finishes and dumps a trace server side, but of coures it can't go down the wire as the connection is closed
11:50:59 <djahandarie> (In that example, the input list is [a,b,c] and f always produces a list of size 2)
11:51:03 <johnw> orzo: can you put in a use of "evaluate" to see if forcing the evaluation helps?
11:51:19 <orzo> are you familiar with conduits?
11:51:52 <johnw> yes
11:52:23 <johnw> I'm not clear whether the sender not finishing, or if it's waiting on something
11:52:26 <orzo> i think renderBytes is buffering up the bytestring until it decides its an "optimal size"
11:52:30 <johnw> ah
11:52:37 <johnw> I see what you're saying now
11:52:43 <johnw> is there any way to "flush"?
11:52:59 <orzo> i don't think so, that was essentially my question i guess
11:53:24 <byorgey> djahandarie: seems like there should be a lens-y way to do it with a list zipper and a traversal
11:53:38 <orzo> conduits has a Flush wrapper adt with "Chunk a | Flush" constructors
11:53:54 <johnw> orzo: there's a builderToByteStringFlush
11:54:06 <johnw> the question is how to get to it...
11:54:32 <johnw> ah
11:54:35 <johnw> try fusing it in
11:54:39 <johnw> =$= builderToByteStringFlush
11:55:03 <orzo> but my socket expects bytestrings
11:55:09 <orzo> not Flush Bytestring
11:55:24 <johnw> hmm.. then I cannot help.  I haven't tried this yet
11:55:47 <orzo> i can make it work by providing the machinery myself
11:56:01 <johnw> sounds like a good bug to file against xml-conduit
11:56:08 <orzo> to change Chunk/Flush into Bytestring
11:56:49 <orzo> but i could probably just as easily use renderBytestring but not pipe it directly to the suckt, only render in chunks and pass the chunks
11:56:57 <orzo> renderBytes i mean
12:00:35 <orzo> i dont know how to use blaze-builder
12:32:57 <chrisdotcode_> so guys, since monads are monoids, is `return' the identity and `bind' the binary operation?
12:33:20 <dolio> Yes.
12:33:32 <chrisdotcode_> sweet!
12:33:34 <dolio> Well, join is the binary operation.
12:33:40 <Lethalman> :t join
12:33:41 <lambdabot> Monad m => m (m a) -> m a
12:33:49 <chrisdotcode_> so that means I fully understand monads.
12:33:50 <Lethalman> huh, why?
12:34:02 <chrisdotcode_> I had gotten them before, but I didn't really think about the fact that they were monoids.
12:34:13 <chrisdotcode_> I thought it was coincidence that the names sounded familar.
12:34:18 <Lethalman> why is join?
12:34:22 <dolio> join goes from two ms to one m.
12:34:30 <ludamad> i prefer gonads
12:34:32 <chrisdotcode_> :t (>>=)
12:34:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:34:40 <chrisdotcode_> oh, yeah, it is join...
12:34:41 <Moggle_> What's that one quote
12:34:50 <Moggle_> Monads are just monoids in the category of endofunctors?
12:35:00 <chrisdotcode_> Moggle_: "a monad is just a monoid in the category of endofunctors"?
12:35:03 <chrisdotcode_> ninja'd
12:35:15 <chrisdotcode_> yeah, that's why I asked.
12:35:22 <chrisdotcode_> because I wasn't thinking of monads as monoids.
12:35:45 <dolio> Monoids in set go from two elements of the set to one element of the set.
12:35:50 <haasn> monad identity laws and join's associativity directly correspond to the monoid laws; once you see that you'll realize there's not much else to understand about monads =)
12:36:04 <djahandarie> Monads are not monoids. Monads are monoid objects in a specific monoidal category (the category of endofunctors).
12:36:15 <dolio> When you generalie that, you have an arbitrary tensor product, and have an operation from M tensored with M to M.
12:36:21 <dolio> Generalize, even.
12:36:25 <djahandarie> I don't know why some people use the word "monoid" to refer both to the abstract algebra term and the category theory one.
12:36:29 <naz__> wereSomething : cabal configure --enable-benchmarks --enable-tests --verbose=2 should cover you
12:36:31 <chrisdotcode_> So "foo" :: IO String `join` "bar" :: IO String == "foobar" :: IO String?
12:36:54 <chrisdotcode_> djahandarie: that confuses me.
12:37:04 <chrisdotcode_> are monads monoids, or not?
12:37:26 <haasn> â€œmonoids in the category of endofunctorsâ€ is just shorthand for â€œmonoid object in the category of endofunctorsâ€
12:37:29 <djahandarie> I would say that quote is unnecessarily confusing because it's using an overloaded term, and the meaning of "monoid" it's using is NOT the one that the Monoid class represents.
12:37:33 <djahandarie> ^ chrisdotcode_
12:37:40 <Lethalman> aaaaah
12:37:43 <Lethalman> "monoid object"
12:37:46 <haasn> oh, yes, it's important to distinguish that usage from Monoid
12:37:47 <Lethalman> that changes things a lot
12:37:56 <startling> Lethalman: :)
12:37:57 <Lethalman> \o/
12:37:59 <haasn> just it's important to distinguish between Monoid and monoid, or Monad and monad
12:38:20 <chrisdotcode_> djahandarie: oh, okay. so "monoid", with respect to this specific context (that context being the category of endofunctors)
12:38:20 <chrisdotcode_> ?
12:38:50 <haasn> how about â€˜monoidyâ€™ for â€˜having monoid-like propertiesâ€™? =)
12:38:56 <djahandarie> haasn, here it's important to distinguish between Monoid, monoid (a monoid object in Set), and monoid object.
12:39:40 <typoclass> chrisdotcode_: be aware that the quote was written as a joke, not as an explanation ("monads are simply monoids in the category of endofunctors, what's the problem?")
12:39:48 <typoclass> @google brief incomplete wrong history
12:39:49 <lambdabot> http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
12:39:49 <lambdabot> Title: One Div Zero: A Brief, Incomplete, and Mostly Wrong History of Programming La...
12:39:59 <chrisdotcode_> typoclass: right, I've read that. thanks =)
12:40:02 <typoclass> chrisdotcode_: it's very well written and funny :-) ^^
12:40:04 <johnw> haasn: a monoidal algebraic structure
12:40:05 <typoclass> ah ok
12:40:19 <chrisdotcode_> typoclass: "alan turing invents all of the languages at once"
12:40:33 <djahandarie> chrisdotcode_, I don't understand your question.
12:40:43 <chrisdotcode_> djahandarie: er, nevermind haha.
12:40:52 <haasn> @quote copumpkin lax
12:40:52 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
12:40:52 <chrisdotcode_> I was able to figure it out :)
12:42:34 <sclv_> the lack of symmetry between bicategories and bifunctors drives me insane
12:43:46 <tac> sclv_: Cat is the standard example of a bicategory right?
12:45:21 <dyn> hi
12:47:06 <johnw> chrisdotcode: if you look at a typical monoid algebra, it's (() -> a, a -> a -> a).  Compare that with the natural transformations you get from a monad: (I -> M, M `o` M -> M) [using `o` for functor composition].  this symmetry extends also to the laws of identity and associativity, thus both have a monoid structure, it's just at different "levels"
12:48:09 <dolio> sclv_: They've both got two of something. And they are both distinctly unlike other things that are not themselves.
12:48:28 <dyn> I'm a haskell newbie looking for editor/IDE recommendations, if anyone can comment on that. Tried to use ideah (for intellij idea) but the plugin doesn't seem to be compatible with the latest idea
12:48:45 <haasn> most people use emacs, most of the rest uses vim
12:48:49 <dyn> also signed up for FPcomplete's upcoming stuff but did received an invite so far
12:49:10 <dyn> haasn, I'm well trained for vim, if it's a good choice that's good..
12:49:12 <johnw> dyn: invites start rolling out next week, and then will come in waves
12:49:18 <haasn> dyn: I use vim personally and it works fine
12:49:46 <Cale> dyn: In that case, just put set expandtab in your .vimrc, and you're good to go. Keep a vim window open alongside ghci and :r in ghci whenever you save.
12:49:58 <haasn> dyn: depends on what kinds of features you want, really; but personally I just use a ghci session + hoogle/haddock pages in my web browser for my debugging and documentation needs
12:50:31 <dyn> err.. less-trained with haskell. Let me lookup hoogle/haddock :)
12:50:42 <haasn> @where hoogle
12:50:43 <lambdabot> http://haskell.org/hoogle â€“ See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
12:50:58 <dyn> ahem
12:50:58 <haasn> search a package, and you get taken to its haddock documentation page =)
12:51:17 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html -- or you can go from here :)
12:51:35 <Cale> (mostly have to use the package search now that there are so many...)
12:52:10 <sclv_> dolio: that's fantastically similar!
12:52:12 <dyn> and even for basic experiencing you recommend a main function and load it via ghci I guess..
12:52:18 <sclv_> can we create a category called bithingamabobs
12:52:22 <sclv_> that they're both objects in?
12:52:30 <Cale> dyn: You don't necessarily have to define main, if you're playing around with stuff in ghci
12:52:42 <Cale> dyn: because you can just type expressions to test things
12:52:53 <dyn> the fact is, I've been through ~75% of LYHFGG and just wanting to dive in to RWH with following all the examples
12:53:08 <sclv_> along with bialgebras, bicycles, and biannual music festivals
12:53:12 <dyn> Cale: yup, I've came around a few euler problems with haskell already with success this way
12:53:13 <haasn> not a fan of RWH personally
12:53:13 <dolio> I wonder what they actually call functors over bicategories.
12:53:18 <haasn> better to just get some real world haskell experience ;)
12:53:21 <dolio> Bifunctor would be the usual answer.
12:53:32 <dyn> that about sums of my current experience
12:53:44 <dyn> haasn: like..?
12:53:53 <sclv_> where arrows are a partial ordering on stupidity of the name
12:54:00 <haasn> well, looking at existing programs and trying to write your own
12:54:22 <haasn> asking on IRC if you get stuck language-wise
12:54:52 <ludamad> I liked RWH a lot
12:55:38 <dyn> the fact is.. I feel a wide wide gap between being familiar with most of Learn You a .. and being able to actually write a real world program :(
12:55:42 <haasn> in my experience the code examples were often outdated (failed to compile) or badly written (not very elegant, full of boilerplate and not using functions that could have cut down on the complexity)
12:55:50 <dolio> bicategory page on nlab appears to have no mention of it.
12:55:54 <haasn> maybe that's changed by now, I don't know
12:56:00 <dyn> (though it's still the most entertaining programming book I ever read)
12:56:14 <haasn> dolio: 2-functor or something? I don't know anything about higher categories
12:56:25 <dolio> Oh, pseudo-functor.
12:56:33 <dolio> How's that for confusing?
12:56:46 <dolio> 2-functor is if you use the numbering scheme, yes.
12:57:04 <dyn> I also thought of moving on with eg. this one: http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell ? It looks both beginner friendly and real-world like :)
12:57:05 <haasn> can't be more confusing than topology terms
12:57:08 <dolio> But that has ambiguity problems with older terminology.
12:58:17 <haasn> dyn: iirc I spent the time after LYAH writing simple programs that didn't require any knowledge not covered in LYAH
12:58:44 <haasn> basic data type definitions, rudimentary I/O
12:58:50 <haasn> just to get a hang of how to write functional algorithms
12:59:15 <typoclass> dyn: just for double-checking, have you written any haskell so far? even small expressions and one-liners will help. (i think learning it purely from reading is a bit like trying to learn to swim purely by reading :-)  )
12:59:30 <dyn> I've done about 10-12 euler problems with haskell
12:59:39 <typoclass> dyn: ah, very good
12:59:55 <dolio> sclv_: So, bifunctors from product categories, and pseudo functors from bicategories. Obviously.
12:59:55 <dyn> but they feel way far from any real world stuff though (no IO, etc)
13:00:06 <haasn> I think PE is more an exercise in math and creative thinking than using a language, the only interesting bit comes in when you already know the algorithm in your head and need to transfer it to paper
13:00:08 <haasn> (or file, whatever)
13:00:12 <dyn> typoclass: and I agree on the swimming analogue ;)
13:00:31 <typoclass> =)
13:00:40 <haasn> dyn: I think it's important to master a functional state of mind first; how to use I/O and write real program will come naturally after that
13:01:07 <burkaman> dyn: If you're looking for something euler-like that feels slightly more "real world", you could try out http://rosalind.info/ or https://www.codeeval.com/
13:01:28 * typoclass . o O ( we really should collect some small programs + solutions for beginners to write. "write a minimal clone of 'cat -v'" kind of stuff )
13:01:33 <Crockeo> haasn: But to do that you kind of need to understand how to practice functional concepts, at least in my method of learning
13:01:34 <haasn> maybe something simple like 99 haskell problems
13:01:38 <haasn> ?where 99 problems
13:01:38 <lambdabot> I know nothing about 99.
13:01:43 <haasn> ?where problems
13:01:43 <lambdabot> I know nothing about problems.
13:01:49 <haasn> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
13:01:53 <Crockeo> haasn: Like, I wouldn't have been able to learn anything about functional programming without being able to tinker around in Haskell itself.
13:01:54 <Hafydd> ?where love
13:01:54 <lambdabot> http://en.wikipedia.org/wiki/Where_Is_Love%3F
13:02:07 <dyn> burkaman: checking out, thanks
13:02:19 * monochrom offers beginner example http://hpaste.org/52480
13:02:21 <juiko> ?where God
13:02:21 <lambdabot> I know nothing about god.
13:02:36 <haasn> Crockeo: LYAH does tend to show you what functions look like. Either way, H-99 gives you a sort of framework (it provides type signatures for you, so you can't stray too far I guess)
13:03:06 <roconnor> 98 problems would be more ammusing
13:03:07 <haasn> oh, it doesn't provide type signatures for you, but shows you what the input/output should look like. close enough!
13:03:08 <typoclass> monochrom: very good, thanks
13:03:34 <haasn> roconnor: problem 99: solve problems 1-99
13:03:40 <dyn> Crockeo: I actually arrived to haskell from scala, wanting to understand functional concepts. I found it a very useful advice to go this way
13:04:11 <Crockeo> dyn: Ah, alright. Well do watchu do. Everyone learns best their own way, so whatever works best... well, works best!
13:04:19 <hvr> haasn: so problem 99 is self-referential?
13:04:29 <haasn> hvr: exactly
13:05:33 <NemesisD> hey guys. i'm playing around with writing a shopping cart optimization algorithm. i was thinking about doing backtracking with LogicM, however my problem is to choose the "best" not just the first that meets all constraints. am i barking up the wrong tree?
13:05:37 <haasn> monochrom: â€œjust add lensesâ€
13:05:46 <dyn> burkaman: bioinformatics..? sounds scary enough on its own ;)
13:05:58 <c_wraith> The nice thing about problem 99 is that once 1-98 are solved, you solve 99 just by declaring it so.
13:06:07 <burkaman> dyn: haha yeah I only did a few of those, I don't know how tough the biology part gets
13:06:26 <burkaman> dyn: If you want a bigger project you could take a look at this: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
13:06:45 <burkaman> dyn: I haven't gone through it myself, but I've heard good things about it
13:07:05 <haasn> c_wraith: ah, the intended effect was to reimplement problems 1-98
13:07:37 <dyn> burkaman: hmm interesting..
13:07:41 <burkaman> dyn: actually I guess that book is more of a long tutorial and less of a project
13:08:07 <ciaranm> NemesisD: "best" is a series of decision problems
13:08:45 <NemesisD> ciaranm: yeah, naively i'm thinking it needs to keep the best its seen so far and only supplants it when it finds one better. is there a better fit than the logic monad?
13:09:00 <c_wraith> Oh, here's a decent small project idea:  write a program to download mp3s from an amazon .amz file.  It's not actually hard - but it involves working with xml and http
13:09:04 <ciaranm> NemesisD: i'd say "constraint programming", but i'm biased
13:10:41 <typoclass> ha, these rosalind problems aren't half bad. "delete a bunch of substrings from a long string" seems like a plausible getting-your-paws-wet problem to solve http://rosalind.info/problems/splc/
13:10:53 <typoclass> sorry, feet. i forgot you people don't have paws
13:11:05 <c_wraith> I might have paws
13:11:13 <c_wraith> You don't know
13:11:32 <NemesisD> ciaranm: are there any libraries out there i should be looking at? i'm finding trouble figuring how stuff like SAT solvers could be used to solve my problem
13:11:40 <ciaranm> i'm pretty sure SPJ has a tail
13:11:49 <typoclass> the rosalind stuff seems phrased in biological terms, but knowing nothing about biology, i still could work out what they want
13:12:01 <typoclass> c_wraith: i was told i was the only cat
13:12:16 <ciaranm> NemesisD: constraint programming is in some ways a massive generalisation of SAT to "not booleans". writing a constraint solver is a good exercise!
13:12:55 <typoclass> burkaman: thanks a lot for the rosalind.info link, i hadn't heard about it and it seems quite good
13:13:39 <haasn> if anybody needs a project idea, I'd be interested in collaborating on a haskell implementation of the WhatsApp protocol (variant of XMPP) :)
13:14:04 <ciaranm> i thought google officially killed XMPP
13:14:07 <dyn> yup
13:14:17 <Peaker> yay, fixed the annoying "pretty" stack overflow bug
13:14:19 <dyn> and hangouts went proprietary, afaik
13:14:25 <jonkri> any idea why the body of the following ("\n...\n") is not included on ghc 7.6.3: #if __GLASGOW_HASKELL >= 706\n...\n#endif
13:14:54 <haasn> ciaranm: wait, how so?
13:15:01 <haasn> as far as I'm aware Google Talk and Facebook still use XMPP
13:15:11 <mauke> jonkri: test case?
13:15:31 <ciaranm> google talk is dead. long live google hangouts, sponsored by the NSA!
13:15:38 <burkaman> typoclass: yeah I think it's a great alternative for people who find project euler too math-y
13:16:00 <ciaranm> project euler is to maths as astrology is to astronomy
13:16:02 <burkaman> typoclass: it's supposed to teach you a bit of biology as you go, but I've found you can skip most of that stuff
13:16:07 <luite> Peaker: what was it?
13:16:19 <jonkri> haasn: Why would you want to speak that protocol?
13:16:32 <stevejb> http://www.reddit.com/r/haskell/comments/1h9ot9/newbie_help_understanding_curried_functions_in/
13:16:33 <burkaman> typoclass: the harder problems just do complicated stuff with sets and trees, you don't need to learn much biology
13:16:40 <supki> jonkri: __GLASGOW_HASKELL__
13:16:44 <Peaker> luite, 3 of the functions that compose Doc's together used foldr with a function that was strict on its second argument
13:16:49 <typoclass> burkaman: right! i did manage to work out what they want algorithmically. even though i don't know the biological terms
13:16:59 <Peaker> luite, it was strict on its second argument because it wanted to replace: "Above x Empty -> x"
13:17:11 <haasn> jonkri: it seems to be the de-facto standard means of textual communication among teenagers in germany right now
13:17:28 <jonkri> supki: thanks!
13:17:41 <haasn> I'm missing a lot of potential contacts and conversations due to not being able to reach them from within IRC, so I figured a bridge between the two would be a good idea for a project :)
13:17:46 <ciaranm> haasn: why would you want to speak to german teenagers?
13:17:53 <haasn> ciaranm: because I am a german teenager
13:17:56 <jonkri> haasn: how sad. i'm one of the authors of pontarius xmpp
13:17:58 <Hafydd> __GLASGOW_HASKELL__ is the de facto standard means of textual communication among teenagers in Germany?
13:17:58 <dyn> must be the pawn thing..
13:18:00 <Peaker> luite, so I changed it to do the same in post-processing with more laziness: https://github.com/Peaker/pretty/commit/cdf1a1c5adcb5458581cc869595f6643e425de74
13:18:10 <jonkri> hahaha
13:18:28 <jonkri> and xmpp is not dead, guys :)
13:18:46 <geekosaur> both of them actually use mutant XMPP, actually. (for good reasons, even; XMPP tried to handle IM and telephony presence the same way, and this doesn't actually work so well in practice.)
13:18:56 <luite> Peaker: ah, tnx :)
13:19:03 <Peaker> luite, are you involved in the development of pretty?
13:19:11 <geekosaur> hm, one too many actually-s in there :p
13:19:11 <luite> no, i was just interested
13:19:50 <ciaranm> haasn: you'll grow out of it
13:20:01 <typoclass> Hafydd: yes, because germans are shouty. you can translate the english term "glasgow haskell" into german by upper-casing: "GLASGOW HASKELL"
13:20:03 <haasn> ciaranm: obviously :)
13:20:16 <Hafydd> Hahah.
13:20:30 <haasn> typoclass: needs the double-underline for extra emphasis
13:20:56 <Peaker> luite, ah, cool. I hope this pull request isn't ignored..  My pull request on wx to make it work with modern GHC has been ignored for a week :(  https://github.com/jodonoghue/wxHaskell/pull/19
13:20:57 <chrisdone> donri: poke
13:22:06 <luite> Peaker: aw :(
13:22:10 <Hafydd> typoclass: http://imgur.com/gallery/OS9VU
13:23:08 <luite> Peaker: did you find it by experimenting, or did you get a stack dump?
13:23:48 <ciaranm> you have to spell it __GLASGOW__ so the natives realise you're talking. it's hard to get through to them otherwise.
13:23:51 <dyn> about normal workflow.. is it worth to set up eg. a bash loop to watch my .hs file and recompile on change, or are there better approaches for that?
13:24:18 <geekosaur> I have to imagine that someone has already written something using inotify or whatever
13:25:05 <dyn> geekosaur: right.. but if it's not that known I guess you are not using it daily either :)
13:25:28 <geekosaur> I'm not, but I'm rather more sysadmin than dev
13:25:43 <Jar9869458293812> I'm new to Haskell
13:25:46 <haasn> Hafydd: â€œschmetterlingâ€ is so aggressive sounding too, since â€˜schmetternâ€™ is a powerful way of hitting something (in order to propel it), and â€˜zerschmetternâ€™ is to hit something so it breaks into lots of pieces
13:26:48 <mauke> (shatter)
13:26:50 <sipa> http://static4.fjcdn.com/comments/comment+161+posted+first+but+for+those+who+view+in+_01ec602f49021971050fbf4160fb4210.jpg
13:26:58 <geekosaur> if you're serious about automatic compiles, you probably want to look at continuous integration servers. (although last I'd heard, not many of them support haskell)
13:27:24 <dyn> nah, I'm fine with up-enter for now
13:27:26 <burkaman> dyn: One of the best vim setups I've ever seen used this stuff: http://haskelllive.com/environment.html
13:27:30 <typoclass> Hafydd: very good :-)
13:27:45 <burkaman> dyn: there's a guard script there to automatically recompile
13:27:58 <dyn> hmn
13:28:34 <burkaman> I assume you could accomplish the same thing with bash or something else though
13:28:39 <typoclass> dyn: i configured my editor to save and run ghc on the current file when i hit a shortcut
13:29:23 <dyn> also feasible
13:30:09 <jonkri> the template-haskell api documentation really leaves a lot to be desired
13:32:15 <johnw> as long as you desire it during compilation
13:36:15 <dyn> what's a .hi file/
13:36:16 <dyn> ?
13:36:45 <Peaker> luite, I got stack overflows when trying to do pretty dumps of a large structure
13:36:52 <haasn> dyn: temp file used during compilation
13:36:56 <Peaker> luite, at first I thought it was the derived instances, then I saw different derivations all had stack overflows
13:36:58 <geekosaur> not exactly
13:37:00 <luite> not temp files, haskel interface files
13:37:06 <haasn> â€˜haskell interfaceâ€™ yeah
13:37:14 <Peaker> luite, so then I just made a little test: vcat'ing a huge list of simple texts - which reproduced a stack overflow
13:37:16 <haasn> it contains information about what every module exports
13:37:17 <luite> they need to be kept because they contain information about the module, and also some code for inlining
13:37:20 <dyn> do I need it? Can I invoke ghc to skip generating them?
13:37:21 <geekosaur> it's an interface file, which specifies things like type information for library modules that can't be stored in an object file
13:37:30 <Peaker> luite, so I reviewed the code of "text" and "vcat" (only combinators I used to make the Doc) and already saw a problem
13:37:35 <luite> ah :)
13:37:36 <geekosaur> you can't skip generating them, no
13:37:59 <dyn> okay, thanks
13:37:59 <haasn> oh indeed, the .hi files are kept for libraries
13:38:04 <haasn> but can be deleted when compiling binaries
13:38:08 <geekosaur> if you're building a program, you could remove them afterward, but then you lose the ability for ghc to skip recompilimng an unchanged file
13:38:16 <Peaker> luite, Stack overflows with barely any diagnostics about what's at fault -- as well as not having *any* diagnostic that there may be a problem from GHC are one of the main "holes" in the GHC ecosystem IMO
13:38:21 <haasn> my bad :)
13:38:24 <dyn> geekosaur: I see
13:39:02 <Twey> dyn: It's like a C header file â€” it's what the compiler reads to figure out the types and names of things inside a binary
13:39:07 <Peaker> GHC could probably issue a warning if "foldr" is used with a strict-on-2nd-arg function somehow, even if it took manual annotation on "foldr" or ideally if there was a general way to generate such warnings about unbound stack use
13:39:26 <luite> Peaker: yeah. I can solve them myself now by compiling the code with ghcjs, then inspecting the stack with the js debugger :p
13:39:37 <Peaker> luite, haha :)
13:41:31 <cschneid> What does the a0@a do here?: sha1Step4Main (ABCDE a0@a b0@b c0@c d0@d e0@e) s len
13:41:36 <cschneid> source: sha1Step4Main (ABCDE a0@a b0@b c0@c d0@d e0@e) s len
13:41:40 <cschneid> https://github.com/asperous/darcs_source_code/blob/master/src/SHA1.hs#L94
13:41:53 <cschneid> specifically the @ sign part going on.
13:42:29 <typoclass> > let f x@(a,b) = "x is " ++ show x ++ "; a is " ++ show a in f (42,37)
13:42:29 <mauke> pattern aliasing
13:42:31 <lambdabot>   "x is (42,37); a is 42"
13:42:45 <typoclass> cschneid: it matches the entire thingy ^^
13:42:56 <mauke> a@b is silly
13:43:00 <cschneid> right, but they're not matching subsets of 'a' to need to hold onto a handle to the whole thing
13:43:11 <typoclass> cschneid: in your case it looks weird, it seems to just assign two different names to the same thing
13:43:22 <mauke> > let a@b@c = 2 in a+b+c
13:43:23 <lambdabot>   6
13:44:17 <cschneid> ahh, it looks like they just want two names tied to the same input - one to heavily modify in the do block, and at the bottom (line 176 of link) it combines em back or something
13:44:42 <typoclass> cschneid: is that some kind of auto-generated code? it can't be hand-written ...
13:44:59 <cschneid> typoclass: hell if I know, just looking at darcs source.
13:46:58 <dyn> how can I properly do something like:     read "42"  ? Do I need to hint on the type inference?
13:47:01 <typoclass> cschneid: right, it seems like a shorthand for "f a b = let a0 = a ; b0 = b in (long expression)"
13:47:18 <typoclass> > read "42" :: Integer
13:47:19 <lambdabot>   42
13:47:24 <typoclass> dyn: this way? ^^
13:47:46 <dyn> typoclass: yup.. I tried something like:  let a :: Num = read "42"
13:48:00 <byorgey> dyn: Num is not a type
13:48:00 <geekosaur> Num isn't a type
13:48:08 <dyn> it's a type class
13:48:10 <dyn> now that you say
13:48:12 <geekosaur> yes
13:48:14 <dyn> pff :)
13:48:16 <dyn> right
13:48:22 <geekosaur> and you can't use a typeclass that way
13:48:47 <byorgey> dyn: also, in terms of syntax, you can't combine a type declaration with a definition like that, you would have to write   let a :: Int; a = read "42"
13:48:49 <geekosaur> you *could* have used Num a => a, but it's often not a great idea
13:48:50 <dyn> still, let a :: Integer = read "42" is syntactically incorrect I guess
13:48:54 <geekosaur> and that
13:48:59 <bigs> let a = read "42" :: Int
13:49:01 <dyn> byorgey: okay
13:49:07 <haasn> it's valid with some extensions
13:49:14 <ciaranm> there's a language pragma that allows that
13:49:16 <haasn> but in this case the usual form would be preferred
13:49:20 <geekosaur> or let (a :: Int) = ... but that I think needs ScopedTypeVariables in current ghcs
13:49:31 <geekosaur> (used to be a different extension but it was merged)
13:49:34 <byorgey> yes, it does
13:49:44 <OffsetGoose> I have a question about Network.HTTP
13:49:46 <haasn> geekosaur: don't need the brackets with ScopedTypeVariables
13:49:59 <typoclass> i wish we had lower-case for values, upper-case for types, very-big-upper-case for typeclasses, and ludicrous-case for ... kinds i guess
13:50:05 <haasn> actually let me hold back that statement, I have shittons of other extensions enabled
13:50:14 <bigs> what's the q, OffsetGoose
13:50:20 <ciaranm> and plaid for higher order kinds?
13:50:33 <typoclass> dyn: try {-# LANGUAGE ScopedTypeVariables #-} and the "let a :: Integer = read" syntax will be allowed
13:50:37 <haasn> blackboard bold for type-classes
13:50:42 <geekosaur> replace case with font size? :p
13:50:53 <OffsetGoose> If I already have a request ByteString (bs), could I: simpleHTTP (Request bs) ?
13:50:59 <byorgey> haha, syntactically meaningful font size, o joy
13:51:07 <ciaranm> there was some language that had syntactically meaningful colour
13:51:26 <haasn> so you could fail your exams if your ink has the wrong color?
13:51:38 <haasn> ciaranm: (also, are you thinking of piet?)
13:51:39 <mzero> I designed / developed a langauge that hand syntatically meaningful bold and italic and strikethrough
13:51:42 <Peaker> Igloo, maybe here is a better channel to harass you :)
13:51:48 <dyn> typoclass: I'd prefer to learn the mainstream ways first :)
13:52:03 <bigs> OffsetGoose: HStream has a ByteString instance
13:52:14 <typoclass> byorgey: well, we would kinda have to change the alphabet to not have two cases for each letter, but four. (at least until ghc comes up with more new stuff, then we might need more)
13:52:18 <Peaker> Igloo,   force $ render $ vcat $ replicate 10000000 $ text "Hello"   <-- stack overflows, made a test and a fix.
13:52:23 <OffsetGoose> bigs: Thanks!
13:52:27 <haasn> dyn: mainstream would be either: let a :: Integer; a = read "42" or more succinctly let a = read "42" :: Integer
13:52:35 <haasn> the former would literally be the same thing
13:52:43 <geekosaur> program in arabic, use the 4 letterforms (actual Arabic readers would hate us though)
13:52:49 <bigs> OffsetGoose: np! let me know how that goes. off hand, it should be fine. http://hackage.haskell.org/packages/archive/HTTP/4000.0.5/doc/html/Network-TCP.html#t:HStream
13:52:52 <bigs> for reference
13:52:53 <dyn> haasn: but I can't really do the first inside a do block, right?
13:52:58 <haasn> the latter still has some type inference going on for â€˜aâ€™, but there's no more ambiguity in â€˜readâ€™
13:53:02 <dyn> haasn: where I can only use let to assign values anyway
13:53:03 <typoclass> mzero: i can actually imagine that working! not just in the sense of esoteric language fun
13:53:06 <haasn> dyn: you can, as long as alignment is correct
13:53:10 <haasn> (I think!)
13:53:14 <dyn> oh
13:53:24 <mzero> typoclass: it was a serious, production langauge, actually -
13:53:29 <haasn> let me test
13:53:45 <mzero> if you know smalltalk, then you know there is a need to identify message names from variables & arguments
13:53:57 <mzero> in Smalltalk it is done by adding colons to the parts of the message name
13:54:03 <haasn> dyn: yeah, works fine
13:54:04 <mzero> in Glyphic Script, it was done with bold
13:54:04 <typoclass> mzero: right
13:54:19 <haasn> dyn: just make sure the â€˜aâ€™s are aligned
13:54:23 <mzero> italic was comments, and strikethrough was disabled code
13:55:16 <mzero> this allowed conditionals to read 'nicely' (substituting capitals for bold here)      IF x > t THEN [ â€¦block of codeâ€¦ ]
13:55:40 <haasn> mzero: how did you save programs? in .doc? =)
13:55:50 <typoclass> mzero: right, instead of :if x > t :then [...]
13:55:59 <typoclass> or whatever the smalltalk way is
13:56:00 <typoclass> :)
13:56:14 <mzero> in smalltalk     (x > 7) ifTrue: [â€¦. ]
13:56:16 <mzero> !
13:56:39 <mzero> we saved them in files that were combinations of objects and source (like Smalltalk's image files, only modular by package)
13:57:06 <mzero> and we wrote a custom code editor in the environment to make entering very easy (no need to use cmd-B or cmd-I)
13:57:11 <typoclass> relatedly, i once tried to name a variable "x bar", i.e. x plus a unicode combining macron, or what it was. ghc yelled at me :-/
13:57:21 <haasn> looks to me like you could design an editor to display names prefixed with â€˜:â€™ in boldfont, and reinsert the : when saving
13:57:35 <haasn> and get basically the same effect
13:59:32 <burkaman> typoclass: I thought haskell source was unicode. It wouldn't let you name a variable with non-ascii characters?
13:59:36 <typoclass> ... wait, i think i'm misremembering stuff again. i think i tried to have âˆˆ for `elem` and âˆˆ with a subscript m for `Map.member`. ghc said do not want about the infix subscript m, if i recall correctly
13:59:49 <mzero> well, we did the same with shift:    you entered things by capitalizing the first letter of words that you wanted bold
13:59:57 <ion> burkaman: It does, as long as itâ€™s in the correct character category.
13:59:58 <mzero> (the langage was purposly case-insensitive)
14:00:07 <typoclass> burkaman: i think it had to do with recognizing infix vs. prefix
14:00:10 <roboguy_> Is there an interactive mode for cabal-install?
14:00:35 <typoclass> roboguy_: hm ... what would it do?
14:00:45 <mauke> > let (âˆˆ) = elem in ()
14:00:49 <lambdabot>   ()
14:00:57 <ion> > generalCategory "Ì„"
14:00:58 <typoclass> mauke: yup, that part works
14:00:59 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:01:00 <lambdabot>              with actual type...
14:01:04 <ion> > generalCategory 'Ì„'
14:01:04 <roboguy_> typoclass: if something fails, it gives me a command prompt so I can actually look at logs and do things to fix it
14:01:05 <mauke> > let (âˆˆáµ) = elem in ()
14:01:05 <lambdabot>   NonSpacingMark
14:01:06 <lambdabot>   <hint>:1:7: lexical error at character '\7504'
14:01:09 <lelf> ghc doesn't allow combining symbols, there's ticket for that iirc
14:01:09 <mzero> language manual for those that want to look at archeological artifacts: http://www.ozonehouse.com/mark/cw/Scripting%20Manual.pdf
14:01:18 <ion> > generalCategory '\x304'
14:01:19 <lambdabot>   NonSpacingMark
14:01:23 <roboguy_> typoclass: the Homebrew package manager for OS X has something like that
14:01:27 <typoclass> lelf: oooh interesting
14:01:34 <roboguy_> typoclass: and I was wondering if cabal-install had an equivalent
14:02:25 <ion> Aww, it seems NonSpacingMarks arenâ€™t allowed in any names, including operators.
14:02:27 <typoclass> roboguy_: you could re-run the failing cabal command with -v3, which will give you tons of output (which usually somewhere deep in the middle will tell you what's wrong)
14:02:35 <eacameron> In an expression like this, is "r" copied to both functions or do they look at a ref of some sort: if isValid r && isJson r then...
14:02:42 <ion> (FSVO aww)
14:04:01 <typoclass> eacameron: both functions will see an identical r. it can't change
14:04:03 <typoclass> (unless you're doing very funky stuff you shouldn't be doing ...)
14:04:34 <roboguy_> typoclass: well, the problem is a configure file is not finding a package that, from my perspective, is very much installed
14:04:35 <typoclass> roboguy_: oh, also try --dry-run, which will not actually install things, just attempt to
14:05:18 <eacameron> typoclass: right, but do they see a copy or the same identical memory loc?
14:05:43 <roboguy_> typoclass: it says readline isn't found but my package manager says it's installed. I tried reinstalling it too. Unfortunately it doesn't tell me how it's checking to see if it's installed
14:05:43 <typoclass> roboguy_: ah. that will probably be discarded because of some constraint (a simple case would be: you have kitty-0.3 installed, the package you're trying has "build-depends kitty > 0.1 && < 0.2"). cabal will tell you in detail with -v3
14:06:47 <roboguy_> hmm
14:07:39 <typoclass> eacameron: well ghc isn't copying things around needlessly. and because the r cannot change ...
14:08:39 <eacameron> typoclass: that's what I figured...I've had my head entangled in C++ too long :)
14:10:08 <phulin> it appears that setCurrentDirectory doesn't interpret, say, ~, for example. is ther another function I should use?
14:10:26 <dyn> how can I change the ghci prompt? There was a quick way..
14:10:46 <geekosaur> phulin, you have to do it the hard way. ~ is only interpreted by shells
14:10:58 <typoclass> dyn: try :help. it is something like ":set prompt=..." or ":set prompt ..."
14:11:06 <roboguy_> it looks like the test that causes it to fail is "rl_begin_undo_group... no"
14:11:34 <phulin> geekosaur, thanks
14:11:40 <roboguy_> I think that means it's looking at the wrong readline installation (I think OS X comes with one, but the Homebrew one should be newer)
14:11:41 <dyn> typoclass: ah it's :set prompt <stuff>
14:11:45 <dyn> thanks!
14:11:51 <geekosaur> OS X comes with a fake readline
14:11:54 <phulin> i was under the impression that unix functions did that for you
14:12:04 <phulin> for example
14:12:08 <geekosaur> that doesn't work with most programs that expect GNU readline. (it's really BSD editline)
14:12:10 <geekosaur> nope
14:12:10 <phulin> (fopen, etc)
14:12:16 <typoclass> phulin: there is a function getHomeDirectory in System.Directory, if you need it
14:12:31 <geekosaur> fopen does not; system calls definitely do not as they cannot access the process environment
14:12:58 <phulin> right okay
14:13:04 <phulin> guess i was wrong
14:13:18 * hackagebot hails 0.11.0.0 - Multi-app web platform framework  http://hackage.haskell.org/package/hails-0.11.0.0 (AmitLevy)
14:13:23 <aristid> Peaker: the subtext2 demo is _much_ more impressive than the subtext1 demo, IMHO
14:13:32 <Banistertab> Which is the best web framework to use if yiu just want to build a restful api?
14:13:56 <Peaker> aristid, I like the "monadic IO" in subtext 1, that's missing subtext 2
14:14:34 <Peaker> aristid, but the demo is nice indeed
14:14:50 <haasn> Banistertab: yesod seems to be tailored towards creating RESTful applications, judging by its package description
14:14:50 <roboguy_> ok cool, I gave it the path of the good readline and it looks like it's working
14:14:54 <haasn> but you could also use its underlying HTTP stack
14:14:56 <Peaker> aristid, we're reaching a point now where our Lamdu demo is possibly more impressive than either :)
14:15:02 <geekosaur> this is a common source of problems when using ~ in a $PATH setting (and to make things worse, bash will *sometimes* expand it internally... and sometimes not. and subprocesses won't at all.)
14:15:15 <Peaker> and we're still very preliminary
14:15:19 <haasn> (which would be warp)
14:15:36 <aristid> Peaker: gotta make a screencast then.
14:15:53 <dyn> haasn: I feel far from it at the moment, but is yesod the #1 web framework in haskell or are there any competitors?
14:16:05 <Banistertab> Haasn thanks, btw does it integrate well with things like coffeescript and sass?
14:16:09 <Cale> dyn: There's happstack and snap
14:16:11 <Peaker> aristid, while we are already impressive, we're still not quite ready... we do show it off to individuals though
14:16:16 <haasn> #1 by number of uses I'd guess probably
14:16:20 <phulin> geekosaur, thanks.
14:16:21 <typoclass> dyn: there's also snap, and happstack. i don't think they're any less popular
14:16:25 <haasn> I don't know an awful lot about web haskell
14:16:25 <aristid> Peaker: ready for a screencast?
14:16:30 <dyn> okay
14:16:34 <phulin> i don't understand when bash does and doesn't expand ~'s
14:16:42 <Peaker> aristid, yeah, screencast is exposure, and we don't want exposure yet, we want to have more meat to it
14:16:49 <haasn> Banistertab: no idea
14:16:56 <Peaker> aristid, namely, sum types, type classes and execution
14:17:02 <Peaker> (and associated features)
14:17:04 <Cale> dyn: My biggest criticism of yesod is that it relies a bit too heavily on Template Haskell
14:17:31 <chrisdone> Cale: you tellin' me!
14:17:42 <Cale> dyn: and some of its uses end up defining things which are never actually named anywhere in the code
14:17:50 <OffsetGoose> Does yesod compare to something like asp.net @cale?
14:17:52 <Cale> You just have to know that it's going to systematically construct those names
14:18:03 <Cale> I don't know anything about asp.net
14:18:06 <chrisdone> OffsetGoose: yesod is like rails
14:18:15 <dyn> Cale: which other do you prefer?
14:18:28 <tunixman> t phulin: http://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html
14:18:36 <OffsetGoose> chrisdone: I heard rails is a pain
14:19:41 <chrisdone> OffsetGoose: ok?
14:20:56 <OffsetGoose> chrisdone: never used it though.  Do you like rails?
14:21:15 <monochrom> what is rails doing in #haskell?
14:21:33 <Clint> oppressing me
14:21:36 <typoclass> monochrom: you're derailing the discussion
14:21:39 <monochrom> oh, nevermind
14:21:58 <Cale> dyn: I think I like Happstack the best. We're using Snap at my work, and it's pretty decent though.
14:22:13 <Cale> dyn: You can also pretty freely mix and match pieces from them.
14:22:24 <Heffalump> me, I like Cobol on Cogs.
14:23:10 <Peaker> I hate that Happstack uses Lazy I/O :(
14:23:11 <dyn> mentioning using at work, I was never sure if there are active positions for haskell coders or it's rather an academic focused language
14:23:38 <Clint> i hate happstack's dependency morass
14:23:59 <typoclass> dyn: i like to say that haskell will make you a better programmer, whether you end up using haskell or another language =)
14:24:10 <dyn> typoclass: my goal exactly at the moment
14:24:13 <Cale> Clint: well, all the web frameworks have dependency morasses
14:25:05 <Clint> different ones
14:25:31 <Heffalump> dyn: I'd guess that there are low 100s of paid haskell programmers these days
14:25:34 <haasn> Heffalump: Haskell on a Horse =)
14:26:14 <chrisdone> Peaker: why?
14:26:39 <typoclass> i remember there was something years ago "___ on horseback", modeled on "ruby on rails". i don't know if it was haskell or something else
14:26:59 <S_J> what would be an area where haskell shines besides parallellism and concurrency?
14:27:03 <haasn> typoclass: ^^^
14:27:08 <johnw> S_J: type checking
14:27:24 <typoclass> S_J: programming, i would say ;-)
14:27:26 <Peaker> chrisdone, because lazy I/O is terrible for production use.. it means that you choose between: A) leaking evaluation order abstractions  B) foregoing any control over when resources are freed anywhere and in which thread IO will happen
14:27:28 <haasn> S_J: safety
14:27:31 <Twey> Heffalump: You're behind the times.  DOS On Dope is what the cool kids are using these days.
14:27:45 <Peaker> chrisdone, In practice, most choose A -- which IMO makes even pure code be effectively impure
14:27:48 <haasn> BASIC on a Brontosaurus
14:27:51 <hpc> Twey: php on pcp
14:28:01 <sm> http://haskell.on-a-horse.org/ ! come on people, yesod and snap are so yesterday
14:28:29 <Hafydd> Visual Basic on a velociraptor.
14:28:30 <Peaker> chrisdone, I see the same people advocate that lazy I/O is fine as long as you just choose B go ahead and tell newbies how to do A :(
14:28:34 <cdk>  /luca
14:28:55 <Peaker> chrisdone, I really really like the benefits of Haskell purity
14:29:04 * haasn thinks runHorse really needs to be renamed gallopHorse
14:29:12 <monochrom> haha
14:29:22 <sm> gallopHorsey
14:30:40 <typoclass> S_J: honestly, i think haskell is a damn fine language. i used to switch back and forth between c, python, javascript, perl, java, shell just for fun, but somehow i lost interest since getting to haskell. i know it sounds cult-ish, but the others just don't compare
14:31:18 <haasn> haskell is so outdated. all the cool kids these days use agda or idris
14:31:36 <Peaker> I can't say Haskell made me lose interest in C... I really like tight resource management in C and miss it in Haskell
14:31:54 <Peaker> but it did make me lose interesting in Python
14:31:55 <johnw> I made me completely lose interest in C++
14:31:59 <johnw> and Python, and Ruby
14:31:59 <Peaker> interest*
14:31:59 <JoeyA> You can still use things like 'bracket'
14:32:02 <johnw> and even Common Lisp
14:32:18 <haasn> it didn't completely make me lose interest in C#, because it's still interesting to port haskell concepts back to C# just for the heck of it
14:32:21 <dyn> I've seen some shell stuff rewritten to haskell some weeks ago. It was damn expressive
14:32:27 <Peaker> johnw, I feel Haskell doesn't come close to filling the need that C and C++ fill, agree about the others
14:32:38 <johnw> Peaker: plus, it gave me an interest in Coq and Idris :)a
14:33:37 <typoclass> Peaker: i agree with shapr -- 95% haskell, 5% c
14:33:48 <zq> what's wrong with c++
14:33:54 <typoclass> haasn: that means the cool kids are lacking type inference? ;-)
14:33:54 <S_J> haasn: safety, how?
14:34:02 <Peaker> typoclass, most of the time, yeah.  some projects really need to squeeze every ounce of performance from the hardware though
14:34:12 <haasn> S_J: type safety, purity, coverage checks
14:34:29 <typoclass> johnw: i know right! the small things are the killer. "wait, i don't have Maybe here. urgh that's terrible"
14:34:38 <johnw> typoclass: I just use C now for interfacing with other C code
14:34:56 <mzero> the biggest thing wrong with C++?   null  !
14:35:03 <Lethalman> S_J, this is a good summary: http://www.haskell.org/haskellwiki/Why_Haskell_Matters
14:35:19 <sm> so Ur apparently makes very efficient executables and has no garbage collector. How does that work ?
14:35:26 <haasn> another big advantage = code reuse
14:35:30 <johnw> typoclass: last night I tried to nest a runResourceT inside a runContT, and the type checker just wouldn't let me do it.  Why?  Because snoyberg correctly discovered problems with that combination, so the types forced me to do the right thing: runContT inside runResourceT
14:35:54 <johnw> in C++, that would have been "Well, up to you if you want to do that"
14:36:05 <haasn> it's hard to describe just how much generalization and abstraction can be done in Haskell in order to re-use code
14:36:39 <johnw> haasn: I haven't even touched the surface of "data-type generic programming" yet
14:37:19 <haasn> I think a good example would be to look at the lens codebase =P
14:37:45 <haasn> or even something like diagrams
14:38:36 <NiceOneBrah> if you have an algorithm where you loop over a list and then for each iteration you loop over the list again, but in the inner loop you start at index i instead of the beginning of the list - is this still an O(n^2) algorithm or is there a more precise way to describe it?
14:38:59 <byorgey> it is still O(n^2).
14:39:15 <monochrom> it is stil O(n^2). and the only more precise way is Î˜(n^2)
14:39:44 <NiceOneBrah> cool. thanks guys
14:40:06 <byorgey> in particular 1 + 2 + 3 + ... + n = (n + 1)n/2
14:40:14 <typoclass> zq: as mzero mentioned, null for starters is a problem with c++. the inventor of the null pointer says it was his billion-dollar mistake ... http://en.wikipedia.org/wiki/Tony_Hoare#Quotations
14:40:37 <simukis_> only a billion?
14:40:58 <johnw> yeah, that sounds very cheap
14:41:22 <simukis_> byorgey: but in O notation you must remove all constants so it still becomes nÂ²
14:41:26 <typoclass> simukis_: that's what i keep thinking as well :-) but poetic license, i guess
14:41:57 <Peaker> is it correct to say that O(n^2) and O(n^2+n) are both O(n^2) because applying constant multiplications on n can tightly bind both from below and from above?
14:42:01 <Lethalman> simukis_, except constants tend to be important when comparing algorithms that have the same asymptotic complexity
14:42:04 <Hafydd> In the talk, Hoare said that a billion was a lower bound.
14:42:24 <monochrom> yes Peaker
14:42:35 <Lethalman> Peaker, yes, but there's a substantial difference between those two algorithms
14:42:46 * tac continues to voice his opinion that undefined is the new null :P
14:43:29 <typoclass> tac: yeah ... well ... it's not like all kinds of things routinely get initialized to undefined
14:43:31 <S_J> how could something like quickcheck be made in C?
14:43:33 <Peaker> tac, null is an Eq instance
14:43:46 <monochrom> undefined is not the new null. null is detectable by the program itself, undefined is not
14:43:58 <Peaker> tac, meaning it is actually meant to be used to signify things, meaning that people use it to signify things
14:44:08 <Peaker> and the compiler has no idea that it is used to signify things
14:44:24 <erisco> r { rField = newValue }  is alright, but if newValue is computed from the oldValue, it is quite cumbersome...  r { rField = f (rField r) }  is there a better version other than manually defining helper functions for this?
14:44:36 <typoclass> monochrom: right, that's arguably a large part of the problem. "well you just need to do 'if (x == null)' all the time, every time"
14:44:36 <Hafydd> C++ has both undefined and null, where "undefined" occurs when the program never terminates.
14:44:41 <tromp_> the problem is ppl saying, let's encode this special case by setting it to null. they won't they that with undefined:)
14:44:55 <Peaker> erisco, welcome to the lens library!
14:45:03 <typoclass> monochrom: if a c program had no way of detecting if a pointer is a null pointer, i bet history would have played out differently
14:45:15 <monochrom> yes, that's what Hoare thinks too
14:45:35 <Peaker> erisco, {-# LANGUAGE TemplateHaskell #-} import Control.Lens ; data MyRecord = MyRecord { _myField :: Int, _otherField :: Char } ; Lens.makeLenses ''MyRecord
14:45:42 <haasn> erisco: just take this pill here and I'll lead you to the rabbit hole
14:45:43 <typoclass> tromp_: good point
14:45:44 <Hafydd> Javascript has undefined, undefined, and null.
14:45:49 <monochrom> the talk video is at http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare
14:46:02 <Peaker> erisco, now you can use: r & rField %~ f
14:46:19 <zq> what's the alternative to null?
14:46:28 <typoclass> zq: Maybe!
14:46:32 <Peaker> erisco, better yet, if you have nested records one inside another, you can do something like: r & rField . otherField . anotherField %~ foo.  Or if "f/foo" are effectful, you can use: %%~
14:46:32 <typoclass> @src Maybe
14:46:33 <lambdabot> data Maybe a = Nothing | Just a
14:46:40 <zq> how is that any better?
14:46:43 <erisco> Peaker, this is based off code gen?
14:46:53 <zq> now you just need to check if a given object is a nothin
14:46:54 <zq> g
14:46:56 <Peaker> erisco, The "makeLenses" part is, but you can avoid it and write your own lenses if you want
14:47:06 <monochrom> the type is "Maybe Int" not "Int"
14:47:15 <Hafydd> zq: you only need to check that for values of type Maybe a.
14:47:24 <monochrom> if you use null, the type is still "Int"
14:47:27 <haasn> zq: Maybe is a choice; null is always there - since Maybe is a choice, the compiler knows that Nothign can be expected here, as such will warn you if you don't include it in your pattern match
14:47:39 <jmcarthur_mobile> zq: the compiler won't let you misuse it, and it doesn't poison every value
14:47:39 <Peaker> erisco, assuming the MyRecord example from above, the lenses code looks like:  myField :: Lens MyRecord Int ; myField f (MyRecord x y) = (`MyRecord` y) <$> f x
14:47:40 <dyn> zq: it's safe. The compiler forces to check for null every time so it won't just blow in your face
14:47:50 <Peaker> erisco, s/Lens/Lens'  there
14:47:53 <erisco> Peaker, the syntax "r & rField %~ f" doesn't make any sense to me
14:47:54 <typoclass> zq: the system in haskell is that a String (for example) is definitely a String, not String-or-possibly-null. a Maybe String is another type, incompatible with String. the compiler will explicitly alert you if you try to use a Maybe String where you need a String, and you'll have to convert, handling the Nothing case explicitly
14:48:05 <dyn> zq: also you can combine operations on it safely and null won't blow up the series of operations either
14:48:12 <Peaker> erisco, & is just reversed $, so you can write it as:   rField %~ f $ r
14:48:19 * hackagebot testloop 0.1.0.2 - Quick feedback loop for test suites  http://hackage.haskell.org/package/testloop-0.1.0.2 (RomanGonzalez)
14:48:32 <Peaker> erisco, rField %~ f   lifts the function f into the rField position
14:48:47 <typoclass> zq: the difference is that Maybe ends up being used a fraction of the time. it's not that everything in haskell all the time is declared to be Maybe Something
14:48:47 <Peaker> erisco, so:   (rField %~) :: (Int -> Int) -> MyRecord -> MyRecord
14:49:08 <monochrom> usage of "Maybe Int" is more machine-checkable, usage of "Int but could be null" is less machine-checkable
14:49:10 <zq> so just a mechanism for compiler-enforced checking
14:49:13 <haasn> erisco: (&) is just a flipped version of ($), â€˜rFieldâ€™ here is a lens; and (%~) :: Lens' a b -> (b -> b) -> a -> a -- takes a lens and a function to apply to the value pointed at by the lens
14:49:22 <Peaker> erisco, if you just want to add 1 to rField, you can use +~:   rField +~ 1      basically all of the standard operators have a lens counterpart with ~ at the end, to apply at a lens position
14:49:52 <typoclass> zq: so, the null (or Nothing) issue is made clear and compiler-checkable, and there is explicit conversion at the edges
14:50:07 <zq> typoclass: with no performance degradation
14:50:15 <jmcarthur_mobile> zq: it's also mote convenient this way because you *know* that unless Maybe is in the type then it can't be Nothing
14:50:22 <S_J> how could something like quickcheck be made in C?
14:50:25 <jmcarthur_mobile> *more
14:50:52 <typoclass> zq: well, to phrase it provocatively, it is "just" a mechanism for compiler-enforced checking in the sense that c compilers haven't discovered it in 40 years and counting ;-)
14:50:53 <Peaker> erisco, the lens library is a whole new world of useful utilities to work with Haskell data, with useful compositions between them. Whenever I think I know how awesome the lens lib is, I see new things that it makes possible that I didn't know before
14:51:14 <monochrom> I don't talk about performance before you have nailed correctness first. as Gerald Weinberg writes, if it doesn't have to be correct, I know how to make it 10 times faster.
14:51:15 <Peaker> erisco, do you know what Data.Traversable is?
14:51:36 <erisco> I wonder how well template haskell plays with IDEs
14:51:40 <typoclass> S_J: good question. i guess you'd have to detect types and stuff ... ?
14:51:43 <zq> very very cool
14:51:56 <Peaker> monochrom, sometimes performance is as important as correctness... so the corrollary is: "If it doesn't finish on time, I don't care how correct it is"
14:52:00 <zq> wondering why c++ with all its compile-time bells and whistles doesn't have this
14:52:01 <dyn> Peaker: is there any introductiory material for the lens library?
14:52:11 <johnw> erisco: in terms of our IDE, it's fine.  we compile the go in the background to get the type info, and template haskell just slows down the compliation
14:52:45 <typoclass> monochrom: if they'll accept a crashing program, i will totally win the benchmark ;-)
14:52:54 <Peaker> dyn, I'm not sure, probably there is.. There's at least this: http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html   but it only scratches the surface
14:53:17 <dyn> Peaker: thanks
14:53:23 <Peaker> erisco, Note the lens is just a single line for the type, and a single line for the lens code -- you don't have to use TH if you don't want to, it boils down to 2 lines of code per record field
14:53:37 <haasn> zq: that Maybe can be used to machine-check error cases isn't a specific â€˜compiler featureâ€™ or design as such; it's just a natural product of the way sum types and pattern matching works
14:54:00 <haasn> so to get the same thing in C++, you'd need sum types and pattern matching in C++ first
14:54:05 <Peaker> S_J, QuickCheck in C would probably be made as some sort of preprocessor that scans your code and generates other code or such
14:54:08 <erisco> johnw, what IDE? leksah?
14:54:13 <monochrom> Peaker: I talk about correctness more because other people talk about premature finishing too much.
14:54:39 <Hafydd> Premature finishing is a serious condition.
14:54:40 <johnw> erisco: fpcomplete.com
14:54:41 <typoclass> Peaker: i think there are cases like that, yes. but i also think that all the talk about performance encourages joe random programmer to think about performance first, and somehow assume that this is the deciding factor for all projects, instead of a one-in-a-thousand minority
14:54:48 <Peaker> monochrom, usually correctness is more important, but sometimes they are equally important.. sometimes small bugs are tolerable but small performance problems are not
14:55:12 <haasn> Peaker: as the saying goes, â€œlens is so generalized, you don't even have to import itâ€
14:55:23 <Peaker> haasn, heh I think the original quote was even funnier :)
14:55:56 <haasn> I can't seem to find it
14:56:14 <Hafydd> @quote generalized
14:56:14 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
14:56:17 <Hafydd> @quote generalised
14:56:17 <lambdabot> No quotes match. I've seen penguins that can type better than that.
14:56:21 <Hafydd> @quote lens
14:56:21 <lambdabot> elliott says: I think lens is the first library I've seen that promises letting you write abstract totally-inefficient-looking compositional code and getting reliably good compilation which has
14:56:21 <lambdabot> actually delivered on that promise.
14:57:09 <Peaker> typoclass, Maybe, I think maybe the pendulum has actually swung too far in the other direction
14:57:26 <typoclass> Peaker: ok, the way you're phrasing it, it's a conscious decision to deviate from correctness. that's different from deviating out of incompetence or ignorance, or while being distracted avoiding ++ because it's "slow"
14:57:32 <Peaker> I am quite annoyed now when people write terrible code and excuse it with "premature optimization is.." bah
14:58:09 <typoclass> Peaker: ok, we agree that terrible code is terrible. fsvo terrible
14:58:21 <erisco> johnw, um, I can't find where any IDE is mentioned
14:58:35 <Peaker> typoclass, there's not necessarily time to write it correct and then rewrite it correct&fast.  maybe you hope to be skilled enough to get it correct&fast in fewer iterations
14:58:36 <johnw> erisco: our beta is starting next week, there should be a sign up page
14:58:44 <Peaker> (in some scenarios)
14:58:48 <johnw> https://www.fpcomplete.com/blog/2013/06/beta-sign-up
14:59:03 <JoeyA> In some cases, the more efficient solution is actually more straightforward.
14:59:09 <Peaker> I think that may have sounded bad -- I just meant that I don't think the "correct, then fast" is always applicable
14:59:15 <erisco> johnw, "fp haskell center beta" ?
14:59:16 <JoeyA> For example, using a Map to maintain a dictionary instead of a list.
14:59:19 <johnw> yes
14:59:28 <johnw> where haskell center == ide, roughly
14:59:40 <dyn> gotta go.. thanks for all the help I got tonight
14:59:41 <JoeyA> With a list, you have to worry about items appearing twice and such.  With Map, it's more clear what's going on.
14:59:54 <erisco> johnw, oh. confusing :)
15:00:10 <Peaker> johnw, I noticed that in the demo there were multiple steps involved in getting to see the new modified color.. I assume that in the works is Bret Victor style auto-reload of a running webapp?
15:00:29 <johnw> "modified color"?
15:00:49 <Peaker> the fpguy demo where he changes the background color and re-deploys
15:00:54 <johnw> ah
15:01:12 <johnw> well, this is a beta after all.  we're eager for feedback on how to improve and streamline the development experience
15:01:41 <typoclass> Peaker: (sounds like something you'd normally do in javascript?)
15:04:23 <luite> johnw: have a contest for a better name!
15:04:28 <Peaker> typoclass, the auto-reload of new code?
15:04:28 <luite> with prizes and stuff
15:04:38 <johnw> luite: haha, all suggestions welcome!
15:05:05 <johnw> we're not sold on anything except that we want to make Haskell useful to a lot more people
15:05:28 <typoclass> Peaker: no, i thought the change of the background color. i think i completely misunderstood something
15:05:36 <mzero> johnw - you should steal Barley's giant run/edit rocker switch
15:05:38 <luite> johnw: i'm guessing it must be a 'safe' name, no weird/new words?
15:05:47 <mzero> (assuming you've looked at Barley?)
15:05:51 <Peaker> typoclass, did you watch the video by fpguy showing the FPComplete ide?
15:05:56 <typoclass> "The FP Make Haskell Useful to a Lot Moar People Center, Beta"
15:06:23 <johnw> mzero: I haven't
15:06:32 * mzero <-- developer of Barley
15:06:34 <johnw> I'm not the UI designer, that's chrisdone and mgsloan's area
15:06:39 <typoclass> Peaker: nope, i can has link?
15:06:50 <luite> hmm, i played with barley a long time ago i think
15:06:55 <Peaker> typoclass, http://www.youtube.com/watch?v=cyyDmQKcHMs
15:06:58 <johnw> I do most of the backendy stuff that involves Haskell
15:06:58 <luite> but kind of forgot what it was :)
15:06:59 <mzero> Barley is the web-based Haskell IDE  Johan Tibbe and I wrote in 2010
15:07:09 <johnw> mzero: link?
15:07:09 <typoclass> Peaker: k thanks
15:07:13 <luite> did it have graphics?
15:07:18 <luite> or does
15:08:23 <mzero> on hackage!
15:08:56 <erisco> Peaker, no I don't know what Data.Traversable is but it looks a lot like Functor
15:08:58 <typoclass> it all needs moar shapr and ghc live?
15:09:01 <mzero> might be a little bit rotted with newer GHC as it needs plugins
15:09:05 <mzero> and that tends to bitrot
15:09:12 <luite> typoclass: that's going to with notdan
15:09:13 <johnw> mmm... rotted bits
15:09:15 <mzero> @hackage barley
15:09:16 <lambdabot> http://hackage.haskell.org/package/barley
15:09:25 <luite> typoclass: at least a more publicly hosted web based interactive ghc thing
15:09:47 <mzero> aslo https://code.google.com/p/barley/
15:09:49 <luite> since that was the main criticism against shapr's project, invisible because no public site
15:09:57 <typoclass> luite: absolutely! i loved it
15:10:00 <typoclass> luite: right
15:10:22 <luite> of course ghcjs and diagrams are involved \o/
15:10:24 <Peaker> erisco, it's kind of like a Functor except the lifted function can have effects in some Applicative
15:10:54 <stevejb> my_InputSt
15:11:03 <Peaker> erisco, it's also a generalization of "mapM :: Monad m => (a -> m b) -> [a] -> m [b]"   such that instead of [] you get any Traversable instance. And instead of Monad m, you get Applicative m
15:11:10 <mzero> luite: no, it didn't have graphics back then - but it would be easy to add any of the graphic libs that render to canvas
15:11:38 <mzero> remember- it was in 2010
15:11:55 <zRecursive>  /msg lambdabot @hoogle Lens
15:12:23 <luite> mzero: how is the code run? is it something like gloss-web?
15:12:32 <Peaker> erisco, so anyway, it turns out that using "traverse" and functions like "traverse" for components of your data structure, you can express effectful, polymorphic updates of parts of your data structure, as well as getters for the same part of the data structure via the same code
15:13:42 <stevejb> hello, I am trying to declare the following function
15:13:43 <stevejb> tyying
15:13:44 <Peaker> erisco, for example:  first f (x, y) = (, y) <$> f x    ;    second f (x, y) = (x,) <$> f y       now "first" and "second" can be used to read or update, polymorphically and effectfully, either part of the tuple
15:13:45 <stevejb> normal_Kg :: InputSt iparam =>  Double -> Int -> iparam -> Double
15:14:02 <mzero> it is setup like (gasp) PHP: Each foo.hs file in the project trree corresponds to a URL at the same relative place --- fetching that URL causes that module to be loaded (if it isn't already), and if it compiles, then a function (page)? is evaluated to get the HTML output (as a structure)
15:14:06 <stevejb> what does "`InputSt' is applied to too many type arguments" mean?
15:14:16 <luite> mzero: ah
15:14:38 <Peaker> stevejb, it means that your "InputSt" is probably defined to have 0 arguments?  What does the definition of "InputSt" look like?
15:14:39 <luite> mzero: yeah i had something similar too, but i wanted more direct interaction with the result
15:14:40 <mzero> the editor (based on CodeMirror - like everyone else does) lets you jump very quickly back and forth
15:14:45 <mzero> and we did in-line GHCI error messages
15:14:58 <stevejb> Peaker: it is a bunch of Ints and floats
15:15:09 <mzero> I wanted to hook the PHP/Ruby crowd with --- "just write some source and BAM look at it run"
15:15:13 <sm> mzero: awesome php-like setup!
15:15:13 <Peaker> stevejb, InputSt is supposed to be a type-class
15:15:17 <stevejb> http://hpaste.org/90586
15:15:31 <luite> mzero: same... although not exactly aimed at that crowd :)
15:15:53 <typoclass> stevejb: right, so that right now does not have a type argument
15:16:29 <luite> i hope to be able to do nice demos and visualisations with editable code, from haskell to (popular) math/science
15:16:32 <stevejb> typoclass: so, my InputSt is not an actual type?
15:16:42 <zRecursive> hi haskellers, what is the canonical way to debug a haskell app ?  Is there GDB similar too using GHC ?
15:16:56 <luite> zRecursive: ghci has a debugger
15:17:03 <luite> that can step through the code
15:17:13 <luite> but no one uses it, i think ;)
15:17:14 <S_J> Property based testing, does it work in practice?
15:17:14 <typoclass> stevejb: here is an example of how it might look like with 1 type argument. suppose you don't always want Doubles, but sometimes something else. you could then use "InputSt Double" once, and at other times use "InputSt Int" or whatever http://hpaste.org/90586
15:17:22 <mzero> luite - I'd love such a thing now - especially some diagram stuff so I can hook my 11 year old on Haskell
15:17:24 <zRecursive> luite: then use what ?
15:17:32 <typoclass> stevejb: (i'm not saying you should use this; it's just an example how the syntax would look)
15:17:40 <plhk> zRecursive: brain
15:17:45 <mzero> he's at that perfect "logo" age - and generating HTML isn't going to excite him
15:17:56 <mzero> but fractal monsters will!
15:18:00 <zRecursive> plhk: brain is NOT enough sometimes
15:18:32 <typoclass> stevejb: no, your definition of InputSt makes it an actual type. you can use it e.g. as normal_Kg :: Double -> Int -> InputSt -> Double
15:18:44 <luite> mzero: yes! that's the target audience i have in mind, curious children who want to play with those things and older people who haven't lost their curiosity yet :p
15:19:12 <mzero> woot - let's resurrect something!
15:19:22 <typoclass> S_J: the quickcheck people will say 'yes', i bet :-)
15:19:48 <mzero> S_J: YES! yes it does!
15:19:48 <plhk> 85,000,000,000 neurons should be enough for everyone ;)
15:19:49 <luite> mzero: hehe, well i'm trying to resurrect my 'wolfgang' project, which was a wiki with editable code and diagrams
15:19:50 <stevejb> typoclass: thank you. That worked. So, when I have expressions for the form f :: (Num a) => a -> a, that is because I want to have different types of a (Int, Float, Double, Integral)?
15:19:58 <luite> mzero: codemirror obviously ;p
15:20:08 <mzero> oooooo ---- the one that looked slightly like Alpha?
15:20:09 <zRecursive> Can typecheck guarantee the app right ?
15:20:15 <luite> mzero: right
15:20:31 <luite> mzero: only now i've rewritten ghcjs, so the results can be client side, with real interaction
15:20:36 <mzero> oh man - your screenshots were so lush - I've always wanted it to be
15:20:40 <Peaker> zRecursive, unfortunately, debugging Haskell programs is a PITA :(
15:20:47 <Peaker> zRecursive, fortunately, you only have to do it pretty rarely
15:21:02 <zRecursive> Peaker: what's PITA ?
15:21:04 <johnw> fewer, but deeper, problems
15:21:18 <typoclass> stevejb: right. and that's also what you did (inadvertently) with what you wrote earlier. "n :: InputSt iparam => ..." means InputSt would have to be a typeclass, not a type. Num is a typeclass
15:21:24 <Peaker> zRecursive, Pain-in-the-ass... I just add prints with something like: http://hackage.haskell.org/packages/archive/file-location/0.4.5.2/doc/html/Debug-FileLocation.html
15:21:35 <typoclass> @instances Num
15:21:36 <lambdabot> Double, Float, Int, Integer
15:21:36 <S_J> im interested in improving the way i test my code. unittesting is actually quite cumbersome and i rarely find i can write the tests beforehand. now property based testing is even harder than writing unittests. maybe have propertybased tests for more high level interfaces?
15:21:52 <johnw> S_J: why is property testing harder?
15:21:58 <typoclass> stevejb: here ^^ are the instances that typeclass Num has. you could declare additional ones if you want
15:22:17 <stevejb> typoclass: thank you. I really appreciate it
15:22:27 <johnw> just write a function that should always hold true no matter its inputs
15:22:43 <S_J> johnw: maybe not harder, the same i guess.
15:23:05 <luite> mzero: with notdan's gsoc project we can test drive the server-side sandboxing and compilation/evaluation (not a wiki but a simpler pastebin site, performance requirements for that are also a bit lower)
15:23:05 <Ralith> I have a haskell package that needs at buildtime a program that has multiple possible names. It's currently using cabal's Program infrastructure to search for one specific name. Is there a standard way to list multiple alternative names for a single Program?
15:23:17 <johnw> i tend to write regression tests more than anything: given a bug report, write a test case to show that it's broken, fix the test, check it in
15:23:24 <Andrea__> has someone an idea how to make an inverse list ( each number shows the index of the real entry)
15:23:30 <erisco> Peaker, yeah, but that is manually defining the method, which is a bit cumbersome. how does lens do this without TH?
15:23:31 <S_J> but how does quickcheck know what conrercases are, how could it possibly?
15:23:36 <mzero> luite - yes - looking forward to seeing what gets done there
15:24:28 <mzero> Ralith: not that I know of -- buy you could have a custom Setup.hs file that essentially looks at config or build time for the right name, and the modifies the in-memory read cabal config
15:24:59 <luite> mzero: the most important thing that remains for the wiki is figuring out how to do incremental linking/loading with ghcjs so that code changes can be shown quickly
15:24:59 <mzero> I essentially do this with the version string for my program - so that I can have the git tag/hash code as part of the version object
15:25:01 <Peaker> erisco, either you define the lenses yourself or with TH, there's no way for them to magically appear :)
15:25:09 <typoclass> stevejb: so just to clarify "f :: (Num a) => a -> a" means "f takes any type, call it 'a', as long as we have an instance of typeclass Num available for type 'a'"
15:25:28 <mzero> Ralith: see https://github.com/mzero/plush/blob/master/Setup.hs
15:25:30 <Ralith> mzero: the custom Setup.hs is the only place I actually need the program anyway, I'm just trying to avoid duplicating any logic here
15:25:47 <typoclass> stevejb: (compare e.g. id :: a -> a. this function has no constraints. it takes any type at all; no instance of any typeclass needed)
15:25:58 <Andrea__> my idea for an inverse list : http://hpaste.org/90589
15:26:07 <typoclass> stevejb: ... and you're welcome :)
15:26:17 <stevejb> typoclass: whereas Num a constrains a to be numeric, which has some types already defined and I can add more if I want
15:26:26 <Andrea__> better / faster / easiers  solution possible ?
15:26:26 <stevejb> :) I think it is clicking
15:26:34 <hpc> stevejb: or in more mathy language, for all solutions to the constraint (Num a)
15:26:40 <Ralith> mzero: specifically I'm trying to extend https://github.com/bscarlet/llvm-general/blob/master/Setup.hs to accept 'llvm-config-3.3' as a subsitutute for 'llvm-config' (or vis versa)
15:26:50 <chrisdone> so, hpaste is going to go down in the next day or so
15:26:58 <luite> aw :(
15:27:06 <typoclass> stevejb: yep, basically
15:27:28 <typoclass> chrisdone: omg omg do not want
15:27:39 <monochrom> chrisdone: what for? will it come back?
15:27:41 <Peaker> Andrea__, this doesn't seem like it's an actual "inverse"... it will skip indices for values that don't exist in the list, which will shift all the next indices back making them meaningless, probably not useful
15:28:05 <mzero> Ralith: well then - you've got the spot!
15:28:13 <luite> how long is it going to be down? do i need to prepare, buy extra supplies?
15:28:21 <stevejb> typoclass: excellent. Thanks! Right now I am laying out all of my function definitions for my first Haskell project. I am really looking forward to getting it running (and hopeuflly beat my advisor's matlab)
15:28:29 <Peaker> Andrea__, also, you have an automatic hlint suggestion:  "use isJust", because "/= Nothing" is bad practice in general (requires an Eq instance for your "Maybe a" unnecessarily). Also,  "fromJust" after "IsJust" is a terrible practice
15:28:32 <Ralith> mzero: I'm not really sure where to stick the check, though; before or after programDb is computed?
15:28:44 <typoclass> stevejb: very good :-)
15:28:54 <Ralith> mzero: should I just duplicate programDb for both possibilities?
15:28:55 <hpc> luite: http://labs.echonest.com/Uploader/index.html?trid=TRIWRRC13B033CBF3E -- my hpaste outage plans
15:29:21 <chrisdone> i moved it from the old (linode) vm to the new (hetzner) dedicated host, two weeks ago which is when i asked for the dns to be updated to the new host. the old host is reverse proxying to the new one presently, that's why it still works. i planned for a seamless transition but c'est la vie when depending on other people
15:29:41 <mzero> Ralith: now you're beyond my depth
15:29:47 <chrisdone> i've requested paste.haskell.org from the haskell committee who've agreed to set it up and i'm waiting for a response on setting that up
15:29:49 <luite> ah
15:29:56 <luite> ooh
15:30:02 <monochrom> alright, migration downtime is normal, don't feel bad about it
15:30:02 <Ralith> mzero: aw.
15:30:05 <Peaker> Andrea__, http://hpaste.org/90589
15:30:11 * Ralith continues digging through docs
15:30:22 <Andrea__> thx Peaker
15:30:36 <monochrom> Andrea__: see my http://www.vex.net/~trebla/haskell/crossroad.xhtml
15:30:39 <Peaker> Andrea__, but again, the [0..maximum list] thing is a terrible idea, probably
15:31:04 <Peaker> Andrea__, not sure what the exact constraints of your problem are
15:31:24 <luite> hpc: hmm, i suppose that song is better with some mdma
15:32:26 <Andrea__> in my lists are nou dobles
15:32:31 <Andrea__> doubles
15:32:42 <luite> who's the hscolour maintainer?
15:33:11 <Andrea__> i will use this to make an excact cover algorithm with inverted lists
15:33:33 <typoclass> chrisdone: ok thanks :-) i was concerned for a moment since it kinda sounded like it's going offline permanently or for a longer time. but fair enough
15:33:48 <luite> oh hmm, malcolm wallace, tell him to fix parsing of multiline strings, at least in foreign imports
15:34:13 <luite> i hope that's how reporting bugs works ;)
15:36:46 <typoclass> @remember olsner I think doing eta something means to make it more or less pointless. But I don't recall which eta does what
15:36:47 <lambdabot> Okay.
15:37:36 <Andrea__> Peaker, thx for your edit
15:38:13 <chrisdone> typoclass: the hpaste.org domain will be down for an indefinite time. so any links pointing to it won't work
15:38:41 <typoclass> chrisdone: oh i see. well as long as things will be right eventually ...
15:38:56 <Peaker> Andrea__, your "inverted lists" are basically index lists.. maybe better to use: elemIndices rather than elemIndex, and keep empty lists for missing values in the range
15:39:05 <monochrom> chrisdone: what new domain name will be up?
15:39:14 <FreeFull> > fix (\xs -> [0..maximum xs])
15:39:17 <lambdabot>   mueval-core: Time limit exceeded
15:39:31 <chrisdone> monochrom: i haven't received answer about that, either. suffice to say i dislike depending on other people =)
15:39:36 <FreeFull> > let x = [0..maximum x] in x
15:39:38 <monochrom> yikes, ok
15:39:40 <lambdabot>   mueval-core: Time limit exceeded
15:39:56 <FreeFull> It's just bottom it seems
15:41:06 <Andrea__> Peaker,  each index in only one time included , so elemIndices is not the best
15:41:14 <chrisdone> monochrom: here's a temporary domain http://paste.tryhaskell.org/ i suppose we could use this meanwhile?
15:41:30 <Ralith> mzero: the solution was to call configureProgram on both, then get the results with lookupProgram.
15:41:37 <Peaker> Andrea__, ah, I see, then it is better to give an error when extracting from Just with "fromJust" without using "isJust" or "/=Nothing" first
15:41:45 <Peaker> Andrea__, if an index is missing, you want a crash rather than an incorrect result
15:42:14 <Ralith> mzero: what's the standard way to report an fatal error in a Setup.hs?
15:42:33 <mzero> don't know - never done it!
15:42:41 <Ralith> kk
15:42:50 <Andrea__> i use it to create the x algorithm ( exact cover) with two list ( one inverted list)
15:43:57 <Andrea__> an alternative where sets
15:44:07 <Andrea__> but i prefer lists
15:44:36 <chrisdone> can someone update the topic to reflect that domain for now?
15:46:55 --- mode: ChanServ set +o monochrom
15:47:01 <Andrea__> thx for your help, Peaker, cu
15:47:15 --- topic: set to 'http://haskell.org | Paste code/errors: http://paste.tryhaskell.org/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com' by monochrom
15:47:43 --- mode: monochrom set -o monochrom
15:48:44 <chrisdone> monochrom: thanks =)
15:51:50 <ion> Why the redirect?
15:52:04 <ion> That is, whatâ€™s wrong with hpaste.org?
15:52:56 <chrisdone> ion: read up
15:54:17 <ion> I mean, why canâ€™t the hpaste.org DNS records be changed to point to the server hosting paste.tryhaskell.org if the hpaste.org server is going to be down?
15:57:04 <chrisdone> ion: because i don't control the domain.
15:57:39 <chrisdone> ion: which is why it's a good idea to start using paste.haskell.org, to have a community controlled domain
15:58:16 <typoclass> chrisdone: who is this mysterious power that controls hpaste.org?
15:58:18 <chrisdone> it also means if i get hit by a bus, the haskell committee can just point the domain elsewhere =)
15:58:28 <monochrom> paste.haskell.org is much better
15:58:46 <ion> bos controls the domain, right? Could he not give the domain to the committee?
15:59:05 <chrisdone> monochrom: i like it too
15:59:31 <typoclass> monochrom: yeah ... but much longer. i like to tell people "if more than 1 line, please use hpaste.org". i guess i won't type in the other thing :-)
16:00:09 <chrisdone> typoclass: there's always @paste, which could be updated
16:00:10 <monochrom> hmm, short name, that's harder
16:00:29 <typoclass> monochrom: i can has hpas.te ?
16:00:49 <chrisdone> meh, gist.github.com/chrisdone/b28fade4fd8905a39125 isn't that short either
16:00:57 <monochrom> your client may have auto-correction, and it may be configurable to replace hand-typed "hpaste" to "paste.haskell.org"
16:01:53 <monochrom> it may be called "auto-replaement" instead. it's the mechanism in many clients that auto-corrects "teh" to "the"
16:01:56 <byorgey> it seems there is no .te TLD =(
16:02:27 <typoclass> monochrom: yeah, my client may also have auto-correction that i can configure to expand "hpaste" to the ip address. but why not use the global ip-replace thingy that we have in place :-)
16:02:27 <chrisdone> monochrom: auto-replaement, haha
16:02:33 <ion> There is .tel. Alas, pas.tel has been taken already. hpas.tel is available. :-P
16:02:43 <Peaker> is the Haskell libs list the appropriate place to discuss changes to the social norms around hackage?
16:02:46 <mauke> someone needs to port https://metacpan.org/module/Acme::LookOfDisapproval to haskell
16:02:47 <monochrom> yikes
16:03:05 <typoclass> byorgey: right, i noticed that afterwards. but hpa.st is possible :-)
16:03:17 <byorgey> ugh
16:03:19 <chrisdone> ew
16:03:59 <ion> class Monad m => MonadFail m where à² _à²  :: String -> m a
16:04:05 <chrisdone> lol
16:04:08 <typoclass> ... fine, "hpa.st/e" to placate the spelling fetishists
16:04:26 <typoclass> (now it's a grate improvement)
16:04:47 <ion> â€“ Damn, a dam!  â€“ Great, a grate!
16:05:08 <typoclass> ion++, hidden futurama reference
16:05:15 <byorgey> typoclass: it's certainly a grating improvement
16:06:17 <typoclass> byorgey: how about we try to set up a country that will get the .te suffix? or convince an existing one to rename itself
16:06:19 <c_wraith> http://stackoverflow.com/questions/14636178/unsure-if-i-understand-transactionawarepersistencemanagerfactoryproxy/  I feel like this is the joke that keeps on giving.
16:06:34 <ion> :-D
16:06:50 <monochrom> Peaker: I don't think so. I think haskell-cafe or reddit (!) is better
16:07:12 <c_wraith> crap, that was meant for -blah.  Sorry for the off-topicness
16:07:43 <monochrom> the libraries mailing list seems to be about the standard libraries only, fsvo standard, but definitely not all of hackage
16:07:45 * chrisdone looks away from c_wraith in disgust
16:07:58 <kryft> haha
16:08:36 <ion> Letâ€™s have a discussion about how bad the infraction was.
16:09:25 <Peaker> monochrom, thanks, I'll try Haskell-cafe
16:09:56 <chrisdone> @quote mmorrow xeyes
16:09:56 <lambdabot> mmorrow says: {-# RULES "HAI; CAN HAS STDIO?"  id = unsafePerformIO (system "killall -9 breathingMachine && xeyes &" >> return id)  #-}
16:10:23 <typoclass> c_wraith: i assume the java people are loling at the haskellers with their 40 monad tutorials and haddock documentation that says things like "well this function is just the right-to-left kleisli funkthing, where's the problem" :-/
16:10:38 <applicative> aren't there java monad tutorials?
16:11:06 <typoclass> applicative: "best of both worlds"?
16:11:10 <Ralith> Is there a way to get the cabal version number from inside Setup.hs?
16:11:27 <Ralith> that is to say
16:11:33 <Ralith> the version number of the associated cabal package
16:12:09 <byorgey> Ralith: no
16:12:17 <Ralith> aw.
16:12:27 <byorgey> Ralith: you can get it inside your package, by importing the special Paths_packagename module which can be generated by cabal
16:12:38 <johnw> what about MIN_VER_cabal(1,16)?
16:12:42 <byorgey> Ralith: but at the time Setup.hs runs your package hasn't been built yet.
16:12:55 <applicative> Ralith: you mean, the number of your own package
16:12:56 <typoclass> Ralith: how about this? http://www.haskell.org/ghc/docs/7.6.3/html/libraries/Cabal-1.16.0/Distribution-Simple-Utils.html#v:cabalVersion
16:13:26 <typoclass> Ralith: i probably misunderstood you. (what's the associated cabal package?)
16:13:30 <c_wraith> I think my only problem with monad tutorials is that they exist.
16:13:39 <Ralith> the package defined in the associated .cabal file
16:13:48 * Ralith is putting this confusingly
16:14:00 <typoclass> Ralith: oh i see. yeah then my link is not the right thing
16:14:07 <Ralith> applicative: that's correct
16:14:42 <applicative> why do you need it in Setup.hs?  (not that I doubt it)
16:14:55 <c_wraith> you probably could manage it with a custom Setup.hs, but it would be really hostile to tools like hackage
16:15:55 <Ralith> applicative, c_wraith: I'm working on some LLVM bindings which encode the supported LLVM version in their own version number, and it'd be nice to have to duplicate that information in multiple places.
16:16:17 <Ralith> the Setup.hs needs the supported llvm version number to properly search for llvm-config
16:16:23 <c_wraith> Ralith: would you ever plan to upload those bindings to hackage?
16:16:44 <Ralith> c_wraith: I'm referring to llvm-general, which is already on hackage
16:16:51 <applicative> oh I see
16:16:54 <Ralith> (not my bindings, to be clear)
16:17:10 <c_wraith> It's *very* hostile to the ecosystem for hackage to not know what the version number of a package on it is.
16:17:58 <Ralith> c_wraith: huh?
16:18:01 <c_wraith> You might be able to do it, but it would break tons of assumptions built into hackage and cabal-install
16:18:01 <Ralith> why wouldn't it know that?
16:18:13 <applicative> I think there is trouble in communication
16:18:14 <typoclass> c_wraith: i think Ralith is putting it into foo.cabal as usual, and just wants to get at the number from the haskell source code
16:18:20 <Ralith> yes
16:18:43 <applicative> but Ralith, there must be a way to get Setup.hs or whatever to figure out what llvm you have?
16:18:55 <c_wraith> Setup.hs can run arbitrary IO code
16:19:19 <c_wraith> and I believe it can alter any of the structures parsed out of the .cabal file before they're processed
16:20:22 <Ralith> applicative: there may be multiple LLVMs. a given version of the bindings supports a specific llvm, and to accurately find that version, it helps to have the version number.
16:20:34 <applicative> I like this idea, I will make a package that only has XYZ.cabal and Setup.hs files
16:20:37 <Ralith> c_wraith: I don't want to alter any structures, I want to read the specified version number.
16:21:43 <applicative> how about another package find-llvm ...
16:23:02 <typoclass> Ralith: anyway, as byorgey says, you can import the autogenerated module Paths_nameofyourpackage. after "cabal build", have a look at dist/build/autogen/Paths_abc.hs
16:23:39 <Ralith> typoclass: unfortunately I need it in Setup.hs; the whole point is finding the right llvm for purposes of determining linker flags and such.
16:23:59 <typoclass> Ralith: ah
16:24:36 <applicative> Ralith: but shouldn't this be decided beforehand anyway, when i do cabal install llvm-general or whatever?
16:24:50 <applicative> Ralith: sorry these remarks are probably stupid, just wondering
16:24:52 <Ralith> applicative: it's decided by the version of llvm-general you select to install.
16:25:25 <applicative> I see, so the obvious alternative would be the unpleasant llvm-X.X-general-0.1
16:25:40 <Ralith> I'm not sure what that would change
16:25:56 <Ralith> there's already different branches and hackage packagings for each recent LLVM version
16:25:57 <applicative> I mean, many packages, I choose which package by which llvm i think i have
16:26:03 <Ralith> that isn't the problem
16:26:15 <Ralith> the problem is duplicating the information of 'the version of llvm targeted by this particular tree'.
16:26:54 <Ralith> right now that information is written in both llvm-general.cabal and Setup.hs
16:27:18 <Ralith> I'm wondering if there's a way to read the llvm-general version number specified in llvm-general.cabal from inside Setup.hs
16:27:23 <Ralith> the answer appears to be no
16:27:24 <tabemann> does anyone know anything about producing automatically generated functions with *multiple arguments* with QuickCheck.Function?
16:27:34 <tij> im trying to learn yesod, so I was following their guide online, and they said to cabal install yesod-platform and cabal install yesod-bin
16:27:54 <tij> but cabal install yesod-bin is giving me problems: http://paste.tryhaskell.org/90592
16:28:01 <tabemann> (QuickCheck.Function seems to support only single-argument function, and doesn't seem to provide any apparent means of producing curried functions)
16:28:34 <applicative> this looks bad tij
16:28:42 <kmc> well that's the point of currying isn't it? that a two-argument function is a single-argument function returning a single-argument function
16:29:03 <tabemann> kmc: I know, and I can't see how to produce that with QuickCheck
16:29:08 <Eduard_Munteanu> Whoa.
16:29:12 <tij> also, I'm not sure if i was supposed to do this, but I had to pass the --force-install flag to cabal install yesod-platform
16:29:15 <tabemann> wait
16:29:16 <applicative> tij the ghc package should already be there
16:29:21 <tij> it was the only way it would work
16:29:22 <sm> Ralith: will http://new-hackage.haskell.org/package/cabal-file-th work ?
16:29:25 <Eduard_Munteanu> A kmc! \o/
16:29:31 <tabemann> I do see how it can create a function that takes a tuple as an argument
16:29:34 <kmc> hi Eduard_Munteanu
16:29:36 <applicative> tij ah, thats bad news, I think
16:29:38 <Eduard_Munteanu> Hi.
16:29:41 <mzero> oh noâ€¦ never use --force-install ....
16:29:49 <tij> uhoh :((
16:29:51 <kmc> I guess there isn't an Arbitrary instance for (a -> b), drat
16:29:53 <tabemann> and I can just wrap it in another function like \x y -> f (x, y)
16:29:56 <applicative> ah mzero is here to spread gloom tij...
16:30:10 <kmc> wait, no, here it is  (CoArbitrary a, Arbitrary b) => Arbitrary (a -> b)
16:30:19 <tabemann> no
16:30:33 <mzero> sorry - but if you've installed anything elseâ€¦. --force-install will probably break what you had installed in the past
16:30:35 <Ralith> sm: looks like it might, but if the information isn't available from cabal proper I'm not sure it's worth a dep
16:30:38 <typoclass> Ralith: how about doing "pkgVersion . package" on the LocalBuildInfo thing that you get e.g. when you give a postConf hook or buildHook? http://www.haskell.org/ghc/docs/7.6.3/html/libraries/Cabal-1.16.0/Distribution-Simple-UserHooks.html
16:30:41 <tabemann> (Function a, CoArbitrary a, Arbitrary b) => Arbitrary (Fun a b)
16:30:42 <tij> what should i do? do I have to uninstall stuff?
16:30:48 <applicative> tij I think you should look at what ghc-pkg is saying  "ghc-pkg check" for one
16:31:21 <Ralith> typoclass: I don't see a binding named package
16:31:22 <typoclass> kmc: ohai! o/
16:31:27 <applicative> tij have you installed a lot of other things?  do you have the most recent haskell platform?
16:31:34 <sm> Ralith: I think the cabal macros aren't available until after the first cabal configure, but cabal-file-th reads from the cabal file so should work
16:31:41 <tabemann> you can produce a (Fun a (Fun b c)), but when you extract a function from the first you end up with a -> Fun b c, which isn't very useful
16:31:52 <mzero> tij: wellâ€¦ your yesod stuff will be fine (for now) as you force reinstalled things to match it ---- but anything else you had might be broken
16:32:18 <applicative> well, he needs ghc which he can't have somehow, mzero
16:32:23 <mzero> so for now, you're cool - just be prepared for the future to have issues, you'll know why and just clear up everything and restart
16:32:23 <sm> it'll break other stuff though. There's no way to do this that doesn't break something I think
16:32:29 <Ralith> typoclass: ah, locakPkgDescr looks like it
16:32:29 <tij> i havent cabal installed very much (just gloss and a couple more) - my ghc is 7.4.2, so not the latest
16:32:37 <typoclass> Ralith: check this field in LocalBuildInfo -- "localPkgDescr :: PackageDescription The resolved package description, that does not contain any conditionals."
16:32:41 <mzero> oh - did it force reinstall anything that comes with GHC? that would be a disaster!
16:32:42 <typoclass> Ralith: erm yeah :-)
16:32:46 <Ralith> ^^
16:32:52 <Ralith> okay, I'll look into using that, thanks
16:32:54 <tabemann> methinks producing Fun (a, b) c and then extracting (a, b) -> c from that, and then feeding that into \x y -> f (x, y) looks like the best approach
16:33:04 <applicative> tij that may account for the force install you needed to do for yesod.  i think you should upgrade ghc anyway
16:33:30 <tij> ok let me try upgrading to 7.6
16:33:48 <applicative> mzero it can t decide between Win32==2.2.2.0/installed-082..., ghc => Win32==2.2.2.0/installed-669...)
16:34:25 <mzero> cripes - why would that be? Well, you definitiely want the one that ghc forced
16:34:32 <applicative> one of them would have come with the platform , but anyway, ghc-lib which it is trying to install did...
16:34:55 <typoclass> Ralith: ah, found it. the minimal example would be a Setup.hs that consists of import Distribution.Simple, then "main = defaultMainWithHooks $ simpleUserHooks { buildHook = ...your thing... }". (i hope this file is correct :-) might be outdated or something)
16:35:05 <applicative> tij: what does ghc-pkg list bytestring say  -- thats trouble for ghc-7.4
16:35:49 <tij> applicative: where do i find this?
16:36:43 <applicative> tij oh, on the cmd.exe command line or whatever you call it
16:37:07 <tij> when loading ghci?
16:37:15 <applicative> if you do the command ghc-pkg list bytestring or ghc-pkg.exe ...
16:37:39 <applicative> tij: how are you using cabal install?
16:37:56 <Ralith> typoclass: unfortunately, localBuildInfo doesn't seem to be available in the hookedPrograms hook
16:38:26 <applicative> tij: actually, you might get away with doing it in ghci with the :!  as prefix...
16:38:33 <tij> heres the ghc-pkg list bytestring: http://paste.tryhaskell.org/90595
16:39:30 <tij> i just cabal update, and cabal install whatever package i need - this was the first time i needed to do a --force-install
16:39:32 <tij> usually it works fine
16:39:34 <applicative> tij: that's what I thought, the one above is somewhat built into your ghc, the one below is a dependency of everything in yesod
16:39:39 <typoclass> Ralith: right, i suppose more and more information becomes available as it walks through one hook after the other
16:40:02 <Ralith> but the LBI is static, no?
16:40:22 <applicative> tij: I think this is all due to bytestring but there may be other things, your ghc 7.4 is 'old' by the somewhat insane lights of hackage
16:41:06 <typoclass> Ralith: i'm guessing it needs to produce the LocalBuildInfo thingy, it needs to resolve any conditional sections "if flag(such and such)" in the *cabal file. i.e. it needs to know already a fair bit about the environment
16:41:07 <tij> i just ran ghc-pkg check: a metric ton of warnings and 10 broken packages
16:41:14 <typoclass> dcoutts: hi?
16:41:49 <applicative> tij: you can probably get rid of the broken packages with ghc-pkg unregister <broken-pkg-0.3>
16:41:59 <applicative> tij: but this wont solve the bytestring version problem
16:42:07 <tij> should i just install 7.6?
16:42:16 <applicative> tij: I think so.
16:42:28 <tij> alright
16:42:32 <Ralith> typoclass: ah, that's plausible
16:42:42 <applicative> It is generally said that yesod is such a monster that you should begin with a clean slate anyway
16:43:28 <tij> does this happen with a lot of people?
16:44:06 <applicative> tij if this had happened because of a conflict with the stuff you'd previously cabal installed, I would be recommending something different. ... not that i'm ultra-expert ...!
16:45:01 <applicative> tij: people dont complain about cabal install so much
16:45:30 <applicative> tij but this package conflict problem is a standard hair-pulling case
16:45:46 <tij> yeah, cabal install was working perfectly fantastic until yesod
16:46:30 <applicative> tij: i'm afraid yesod is notorious, they devote a lot of time to working on this problem, on account of the immensity of the pile of deps
16:46:32 <typoclass> Ralith: i mean, you don't technically need LocalBuildInfo; anything that contains a PackageIdentifier would be fine. have you tried hanging around until dcoutts shows up? i bet he'd solve this in about 10 seconds if you tell him you need the version number from Setup.hs
16:47:37 <applicative> tij but I think this boils down to bytestring and maybe something similar, which is really insoluble, clearly yesod is presupposing the going platform version
16:48:18 <mzero> tij - any reason to not just restart by reinstalling the current Haskell Platform (I realize you shouldn't have toâ€¦ but looks like yesod is forcing your hand)
16:48:57 <tij> mzero: no, not really - im installing 7.6 right now
16:49:08 <mzero> fromt he platform, or by itself?
16:49:09 <typoclass> Ralith: oh, how about the confHook? it's getting a GenericPackageDescription, which contains something that contains the PackageIdentifier
16:49:15 <tij> mzero: platform
16:49:20 <mzero> great
16:49:22 <applicative> the version change in bytestring was pretty radical and a big improvement, I think it's irresistable not to use it
16:49:31 * mzero <-- is partial to the platformâ€¦. d'uh!
16:49:45 <Ralith> typoclass: the problem is hookedPrograms
16:49:49 <applicative> tij: mzero is the Haskell Platform czar
16:49:51 <typoclass> mzero: we all are! :-)
16:49:52 <Ralith> unless there's some way to make that unnecessary
16:50:09 * mzero has been outed
16:50:13 <tij> hahaha
16:50:19 <applicative> tij: so you can thank him for the smooth install you are about to experience ...
16:50:22 <applicative> ha
16:50:34 <tij> it's beautiful
16:50:48 <mzero> well - only partially - many others risked their lives to bring you that installer (especially if it is on Windows)
16:51:01 <applicative> i think tij said it was
16:51:50 <tij> im planning on switching to linux soon... windows is kinda of a pain for dev (at least in my experience)
16:51:53 <applicative> irssi must have a /showhistory command or something
16:53:24 <applicative> tij no this channel could use more competent windows/haskell users esp. for purposes of prosyletizing
16:53:47 <tij> everytime i download something on windows, I have to sacrifice a goat for it to hopefully work... which half of the time it doesnt
16:54:31 * typoclass . o O ( we have a monad for that )
16:54:46 <tij> applicative: LOL
16:55:06 <tij> i dont know if i have the brass balls for it
16:59:09 <tij> haskell platform is taking a long time to carry out the action "Target was prepended to PATH" (loading bar is pretty much full)
16:59:50 <mzero> I think this is a know issue
16:59:54 <mzero> justâ€¦ erâ€¦ wait
17:00:13 <monochrom> oh, I observed that too. but yeah, it terminates :)
17:00:54 <monochrom> is it accidentally using a cubic algorithm for modifying PATH? :)
17:12:24 <typoclass> monochrom: btw, the hypothetical shell, written in haskell, that i may well start working on one of these years, will allow for runtime changes of variables. cause it's getting on my nerves that you can't change a variable without restarting all of your shells, or pressing buttons in each of them
17:21:02 <S_J> in haskell quickcheck you still have to define generators for your own type?
17:21:12 <Nisstyre> S_J: not necessarily
17:21:31 <shachaf> byorgey: In theory maybe making a Data.Sequence would be one way to do a balanced fold.
17:21:39 <Ralith> What's the right way to inform cabal of data files that are generated during 'cabal build', and as such shouldn't be in the sdist?
17:21:45 <S_J> i guess in C youd have to write all generators yourself
17:21:45 <shachaf> byorgey: In practice Data.Sequence's Foldable instance defines foldr instead of foldMap. :-(
17:21:46 <Nisstyre> S_J: oh, you might have to define your own instance yeah
17:21:52 <byorgey> shachaf: ah =(
17:21:57 <Nisstyre> but the rest of the heavy handling could be done by QC
17:22:06 <shachaf> byorgey: (But you can use traverse.)
17:22:33 <shachaf> Hmm, I'm not sure whether Sequence gives you the best balanced behavior, actually...
17:26:48 <shachaf> kappabot: @run foldMap N $ Seq.fromList "byorgey"
17:26:50 <kappabot>   N 'b' â—‡ (N 'y' â—‡ (N 'o' â—‡ (N 'r' â—‡ (N 'g' â—‡ (N 'e' â—‡ (N 'y' â—‡...
17:27:16 <shachaf> kappabot: @run foldMapOf traverse N $ Seq.fromList [1..7]
17:27:18 <kappabot>   (N 1 â—‡ ((N 2 â—‡ N 3) â—‡ N 4)) â—‡ ((N 5 â—‡ N 6) â—‡ N 7)
17:28:10 <shachaf> kappabot: @run foldMapOf traverse N $ Seq.fromList [1..9]
17:28:12 <kappabot>   (N 1 â—‡ ((((N 2 â—‡ N 3) â—‡ N 4) â—‡ Îµ) â—‡ ((N 5 â—‡ N 6) â—‡ N 7))) â—...
17:28:25 <byorgey> I see
17:28:27 <shachaf> Hah.
17:28:33 <shachaf> I guess that's not really optimal either.
17:28:43 <shachaf> Oh well, it's a thought.
17:29:24 <shachaf> (Also this uses a monoid rather than a function and value. Though it's possible to go back and forth with a bit of evil.)
17:29:36 <shachaf> kappabot: @run foldMapOf traverse N $ Seq.fromList [1..8]
17:29:38 <kappabot>   (N 1 â—‡ ((N 2 â—‡ N 3) â—‡ N 4)) â—‡ (((N 5 â—‡ N 6) â—‡ N 7) â—‡ N 8)
17:30:40 <shachaf> At least Milan applied my changes to make folding Data.Set/Map more efficient.
17:31:09 <shachaf> Maybe I should bug someone about this too.
17:31:18 <shachaf> kappabot: @part
17:31:18 <kappabot> Plugin `system' failed with: Prelude.last: empty list
17:31:22 <shachaf> kappabot: @part #haskell
17:33:14 <joelteon> huh
17:33:21 <joelteon> so is that like an alternative mappend
17:33:40 <joelteon> i like that diamond thing
17:34:10 <typoclass> shachaf: what is the system behind the grouping? (((5 6) 7) 8) seem to have an obivous order, but why (1 ((2 3) 4))?
17:34:39 <shachaf> like, finger trees, man
17:34:51 <typoclass> joelteon: yeah, <> is a synonym for `mappend` since a few versions. kappabot seems to have a prettier variant of that
17:35:41 <djahandarie> Down with all unicode
17:35:45 <typoclass> shachaf: hmmm
17:36:00 <typoclass> djahandarie: how about 0..127 then?
17:36:06 <shachaf> kappabot: @run foldMapOf N $ S.fromList [1,2,3,4,5,6]
17:36:07 <kappabot>   Couldn't match expected type `s0
17:36:07 <kappabot>                                -> Control....
17:36:13 <shachaf> kappabot: @run foldMap N $ S.fromList [1,2,3,4,5,6]
17:36:15 <kappabot>   (((((Îµ â—‡ N 1) â—‡ Îµ) â—‡ N 2) â—‡ ((Îµ â—‡ N 3) â—‡ Îµ)) â—‡ N 4) â—‡ (...
17:36:27 <shachaf> kappabot: @run foldMap N $ [1,2,3,4,5,6]
17:36:29 <kappabot>   N 1 â—‡ (N 2 â—‡ (N 3 â—‡ (N 4 â—‡ (N 5 â—‡ (N 6 â—‡ Îµ)))))
17:37:20 <shachaf> kappabot: @run getDual . foldMap (Dual . N) $ [1,2,3,4,5,6]
17:37:22 <kappabot>   (((((Îµ â—‡ N 6) â—‡ N 5) â—‡ N 4) â—‡ N 3) â—‡ N 2) â—‡ N 1
17:38:45 <shachaf> > ($ mempty) . appEndo . foldMap (Endo . (<>) . N) $ S.fromList [1,2,3,4]
17:38:46 <lambdabot>   Not in scope: data constructor `N'
17:38:47 <kappabot>   N 1 â—‡ (N 2 â—‡ (N 3 â—‡ (N 4 â—‡ Îµ)))
17:38:51 <shachaf> It's fun!
17:38:58 <shachaf> kappabot: @part #haskell
17:39:14 <martint> is the naive definition of reverse (no accumulator, using naive append) O(n) under lazy evaluation but O(n^2) under eager evaluation? (because naive append is O(1) lazily but O(n) eagerly?)
17:39:24 <joobus> haha, cabal update success!  watch out m******f***********aaassssss.  :D
17:39:48 <typoclass> shachaf: right. thanks
17:40:22 <shachaf> martint: That depends on what you mean by "O(n)".
17:40:42 <shachaf> You're going to have to do the same amount of work, in the end, if you force the whole list.
17:40:58 <shachaf> There's no getting around that.
17:41:18 <shachaf> On the other hand, if you don't force any of the list, you could call it "O(1)"!
17:41:54 <augur> unicode! \o/
17:41:57 <augur> unicode is the greatest
17:42:21 <augur> wtf is kappabot XD
17:46:39 <martint> shachaf, i'm not really sure what i mean. i think in my imagination, a cons operation is cost 1, everything else doesn't count, then i have the lazy and eager version of reverse, then i reverse and force a list and count the number of cons done... in my imagination of course
17:49:21 <joobus> wtf is a samo flange? https://www.youtube.com/watch?v=1AJWRPaKHxQ
17:54:32 <joobus> does anyone here run some haskell on their rPi?
17:54:53 <Hermit> me
17:55:00 <joobus> to do what?
17:55:07 <Hermit> backup server
17:55:15 <joobus> usb drive attached?
17:55:19 <monochrom> augur: for more unicode, use \âˆ©/
17:55:33 <Hermit> yep, 2 for redundancy
17:55:38 <augur> \\\cup/
17:55:38 <augur> :D
17:55:39 <joobus> cool beans
17:55:41 <augur> er
17:55:43 <augur> \\\cap/
17:55:51 <joobus> what is the haskell part doing?
17:56:13 <Hermit> indexing and  de-duplication
17:59:49 <Hermit> also integrity checks
17:59:52 * tabemann is wishing he wrote his QuickCheck tests *while* writing all 850 lines of very dense code he has been working on rather than afterwards as he is
18:01:31 <tij> Yesod finally works!
18:01:31 <joobus> bummer for tabemann i guess
18:01:36 <tij> thanks everyone!
18:01:53 <tabemann> well it would still be harder to test all this code by hand
18:01:57 <joobus> tij, was it on strike before?  I'm currently installing on my rPi.
18:02:15 <tabemann> and QuickCheck means I don't have to actually think up test cases by hand, just supply equalities for checking results
18:02:53 <tij> joobus: on 7.4, dependencies went nuts
18:14:15 <socratesxd> hi guys
18:14:38 <joobus> hola socrates
18:14:39 <tac> hi socratesxd
18:14:45 <socratesxd> ( length "foo" ) / 2
18:14:51 <socratesxd> joobus, hola
18:15:04 <socratesxd> that didn't work guys, why?
18:15:12 <socratesxd> (length "foo") / 2
18:15:13 <tac> You need a > in front
18:15:14 <tac> > 1 + 2
18:15:15 <lambdabot>   3
18:15:22 <Hafydd> > (length "foo")/2
18:15:22 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
18:15:22 <lambdabot>    arising from a use o...
18:15:26 <byorgey> because / only works on floating-point types
18:15:28 <socratesxd> see?
18:15:29 <troydm> > putStrLn("Hola!")
18:15:30 <lambdabot>   <IO ()>
18:15:31 <shachaf> tac: Huh? This person is asking about some Haskell code, not about lambdabot.
18:15:34 <Hafydd> > (fromIntegral $ length "foo")/2
18:15:34 <lambdabot>   1.5
18:15:37 <tac> > length "asdf" `div` 3
18:15:38 <lambdabot>   1
18:15:45 <socratesxd> ooh, i see
18:15:52 <byorgey> use `div` to do integer division, or convert the length to a Double first with 'fromIntegral'
18:15:52 <shachaf> byorgey: Well, Fractional types.
18:16:01 <socratesxd> cool, thanks
18:16:02 <tac> shachaf: Well now he knows about lambdabot if he didn't already.
18:16:22 <socratesxd> tac, i knew about it :)
18:17:09 <byorgey> shachaf: I was intentionally sacrificing accuracy for comprehensibility.
18:17:17 <joobus> do you guys prefer the inplace `command`?
18:17:23 <tac> socratesxd: then my statement holds vacuously :P
18:17:30 <socratesxd> yep
18:17:33 <joobus> i kinda like the scheme way
18:18:16 <shachaf> byorgey: OK. :-)
18:19:06 <joobus> isn't `command` a bastardization of a functional paradigm, where an operation is mapping over lists, etc?
18:19:21 <tac> command?
18:19:34 <joobus> the in place backtick thing
18:19:40 <tac> ah
18:19:45 <joobus> i'm blanking on the proper term for it now
18:19:46 <tac> not really. If anything it's more math-y
18:19:52 <tac> Infix operator syntax
18:20:03 <tac> It lets you turn binary functions into operators
18:20:12 <tac> Just as sections let you turn binary operators info functions
18:21:38 * shachaf sighs vaguely.
18:21:47 <joobus> hmmm, i'm absorbing what you said.  hmmm.
18:25:00 <chrisdone> @tell merijn fixed the announcer
18:25:00 <lambdabot> Consider it noted.
18:33:33 <lcfrs> Hi, are there any comparisons between Concurrent ML's channel/events and Haskell's STM?
18:33:35 <erisco_> what is the type class for filtering?
18:42:13 <jmcarthur> erisco_: there isn't one, at least not in the standard libs
18:44:33 <acowley> jmcarthur: You haven't by any chance made use of the vinyl-gl library I linked you to a while back, have you?
18:45:00 <erisco_> jmcarthur, I don't understand...
18:45:34 <acowley> erisco_: What are you expecting to find?
18:46:20 <anonlsdljsdflsdn> Hi all, does this function have a standard name?  tail $ scanl (\(a,b) c -> (b,c)) (0,1) [1..10]
18:46:24 <jmcarthur> erisco_: there is a filter function, but no type class that generalizes it
18:46:39 <jmcarthur> acowley: i've not used it, no
18:47:12 <jmcarthur> > tail $ scanl (\(a,b) c -> (b,c)) (0,1) [1..10]
18:47:13 <lambdabot>   [(1,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
18:47:56 <acowley> jmcarthur: If you (or anyone else listening) get a chance, take a look at http://www.arcadianvisions.com/blog/?p=388&shareadraft=baba388_51ce3a0a85af1 which is a draft of a blog post walking through one of the examples.
18:48:10 <jmcarthur> > (zip <*> tail) [0..10]
18:48:11 <lambdabot>   [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
18:48:19 <jmcarthur> not quite the same i guess
18:48:37 <acowley> I think it glosses over some things that should be called out, but it's a pain finding the right pacing for it.
18:48:40 <jmcarthur> acowley: will it be too late if i look at this tomorrow?
18:48:48 <anonlsdljsdflsdn> jmcarthur: close enough. thanks
18:48:52 <acowley> jmcarthur: Not at all. I'm going to sit on it for at least a few days
18:49:05 <jmcarthur> acowley: alright, then it's on my stack
18:51:32 <acowley> jmcarthur: thanks!
18:56:02 <erisco_> well, you have a generalization of map, fmap, it just seems strange to not have one for filter
18:56:41 <erisco_> you're stuck with using a different name like 'reduce'
18:57:31 <zzo38> How can you make up a type (Collects x y) that you have a collection of values of type (x) and a type (z) of the index into that collection and then you have (y z)?
18:58:13 <chrisdone> hpaste has 'secret' pastes now, fwiw =)
18:58:25 * hackagebot GLUtil 0.6.3 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.6.3 (AnthonyCowley)
18:59:34 <erisco_> is there not a type class for a forward iterator?
18:59:41 <acowley> I don't know that filter generalizes as nicely
18:59:59 <erisco_> that is a basic pattern that would define many functions... map, filter, foldl ...
19:00:00 <acowley> You need to rebuild a new structure as you go along the old one
19:00:01 <ion> erisco: What would the laws be for the filter generalization? Anything other than filter (const True) = id?
19:00:14 <acowley> erisco_: Perhaps you want Traversable or Foldable
19:01:07 <acowley> The point being that some functors have fixed shapes, which makes filter awkward. Then, as ion suggests, the relationship between the filtered value and the original is something of a mouthful.
19:01:42 <zzo38> How can I make a collection of values of some type (x) as a value (not a type or a class), and then locally have a type that specifically indexes that collection? Haskell doesn't seems to have local types; can you add that feature?
19:02:19 <erisco_> ion, {x | x in X if f x == True }   I don't see what is special about that
19:02:51 <acowley> erisco_: By that rule, filter (const True) [] == [1,2,3]
19:03:28 <erisco_> acowley, what? how?
19:03:35 <acowley> zzo38: Are you after something like Indexed? http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/Control-Lens-Indexed.html
19:03:58 <acowley> {1 | 1 in [1,2,3] if const True 1 == True} holds, same for 2 and 3.
19:04:30 <erisco_> acowley, I don't understand what you're saying
19:05:01 <arkeet> I am a buffalo. http://paste.tryhaskell.org/5649976426451959808
19:05:02 <acowley> "x in X if f x == True" seems to suggest that "x is in X if f x == True", where are the x's drawn from?
19:05:13 <erisco_> from the set X
19:05:15 <acowley> Perhaps you meant, {x | x in X && f x == True} ?
19:05:33 <zzo38> acowley: I don't think so.
19:05:41 <erisco_> now, I understand that uniqueness is implied by the set, but not by a typical data structure, but the idea is the same
19:05:59 <arkeet> zzo38: smart constructors is probably as close as you'll get
19:06:19 <ion> arkeet: hah
19:06:20 <erisco_> acowley, no I was just using notation to state a condition on which to include 'x', but the second definition you gave is fine too
19:06:47 <arkeet> ion: I'm a bit embarrassed about that Alternative instance but it makes the grammar specification look ok.
19:06:53 <arkeet> (it's not associative)
19:07:11 <zzo38> If it is not associative then it is no good.
19:07:17 <acowley> erisco_: So there is another problem, how about filter (const True) [1,2,3] == []
19:07:26 <arkeet> actually, I don't think I'd want it to be associative.
19:07:36 <arkeet> Alternative is the wrong thing anyway.
19:07:38 <acowley> erisco_: You need to express that you don't lose any elements of X for which x is True
19:07:48 <acowley> erisco_: In any case, I think LiquidHaskell aims to support this kind of annotation
19:07:50 <arkeet> I need some sort of probability applicative.
19:08:15 <arkeet> but finding/making one would have been too much effort for this :p
19:08:26 <acowley> erisco_: http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2013/03/26/talking-about-sets.lhs/
19:09:27 <erisco_> acowley, 'x is True' I don't see why we wouldn't drop those elements if f x == False
19:09:34 <acowley> Although their filter suffers the same problem of not being a maximal subset of the input.
19:09:50 <acowley> erisco_: My point is that [] satisfies {x in X && f x == True}
19:10:11 <erisco_> what is your X?
19:10:18 <acowley> []
19:10:25 <erisco_> okay, so?
19:10:28 <acowley> Well, anything really
19:10:35 <erisco_> what do you mean anything?
19:10:48 <erisco_> if f x == True for any x in X then [] is not the right answer
19:11:04 <tabemann> it is
19:11:22 <ion> If we had a FromList typeclass in addition to Foldable, we could implement a generalized <anything that works on lists> in terms of those two. :-P
19:11:31 <erisco_> um, well, I fail to see how
19:11:51 <arkeet> ion: it wouldn't be very nice though.
19:11:52 <tabemann> if you are testing every member of the set for their meeting a predicate, and then there's no members of the set, so no members of the set failed to meet the predicate!
19:11:56 <ion> arkeet: Agreed.
19:12:02 <arkeet> it would fail to preserve any extra non-list-like structure.
19:12:06 <arkeet> (consider fmap)
19:12:09 <joelteon> is there a generalized catch in the stdlib?
19:12:18 <erisco_> tabemann, so?
19:12:21 <ion> arkeet: true
19:12:31 <arkeet> I think Traversable is the right thing in that case.
19:12:40 <acowley> erisco_: The condition that f x == True isn't sufficient. You want to say that every element of the output collection was an element of the input, *and* that no element of the input that passes the predicate is missing.
19:13:01 <arkeet> f x == True  =  f x
19:13:09 <erisco_> that is what I said with the notation I used. if that wasn't clear then I apologize
19:13:28 <erisco_> I was leveraging typical set notation to descibe the intent, minus the uniqueness aspect
19:13:43 <acowley> In your notation, is X the input or the output?
19:16:29 <erisco_> input
19:16:57 <copumpkin> byorgey: that foldb of yours exists as part of the GHC mergesort, but not generally
19:17:04 <copumpkin> (I think that's it)
19:19:40 <erisco_> but regardless, if you had a type class that would allow you to iterate, then both map and filter are easy
19:20:50 <erisco_> and fold. l or r is determinedby the iterator
19:21:56 <ion> erisco: What would the type signature of the iterate function be?
19:23:35 <erisco_> ion, I don't know. is this the reason Haskell doens't have this?
19:23:41 <johnw> erisco_: Doesn't Traversable give you that, or do you need fewer constraints?  Sorry if I've missed context
19:23:53 <erisco_> I'm curious because this is how a few other languages make their abstractions for these operations
19:25:38 <tabemann> you *could* implement a Filterable type class, to provide an interface for things implementing a filter (you'd have to rename it) function
19:26:01 <tabemann> (you can't implement a generalized filter on the basis of the Foldable or Traversable type classes)
19:26:09 <acowley> I can iterate across a 3D vector defined as "data V3 a = V3 a a a", but filtering doesn't make sense.
19:26:16 <johnw> Foldable allows you to filter
19:26:32 <tabemann> johnw: filter while keeping the underlying data structure type
19:26:34 <johnw> tabemann: Why not?
19:26:41 <tabemann> not filtering while converting to a list
19:27:01 <tabemann> Foldable basically flattens everything into what is effectively a list
19:27:12 <johnw> @type Data.Foldable.foldr
19:27:12 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
19:27:27 <acowley> johnw: I don't think it does
19:27:37 <augur> the type of foldable's foldr is kind of boring :(
19:27:37 <tabemann> you can't filter a structure in a way that preserves its existing structure with that
19:27:40 <acowley> johnw: What about my V3 example?
19:27:51 <tabemann> the best you can do is rebuild a new structure from scratch with that
19:27:54 <augur> better to have   (f a -> a) -> Fix f -> a
19:27:55 <augur> :D
19:28:09 <acowley> It's Foldable, but if I want to filter out one of the elements, I no longer have a V3.
19:28:09 <johnw> tabemann: Right
19:28:25 <tabemann> you can't, say, delete leaves from a binary tree with foldr; you can only build a whole new tree from scratch
19:28:33 <johnw> acowley: Then it sounds like a Monad
19:28:44 <augur> fold :: Functor f => (f a -> a) -> Fix f -> a   ;   fold f (In x) = f (fmap (fold f) x)
19:28:47 <tabemann> to delete leaves from, say, a binary tree, you need a specialized deletion function
19:28:47 <augur> generic fold! \o/
19:29:33 <acowley> johnw: You mean filtering? V3 is a monad, but still doesn't allow filtering.
19:29:40 <tabemann> (and mind you that a specialized deletion function is likely to be less expensive than rebuilding an entirely new tree)
19:30:12 <johnw> Can you bind to a function that returns a new V3 with the filtering applied?
19:30:58 <tabemann> (consider the case of if you have a tree and you want to delete a few leaves that meet a predicate - with a specific Filterable type class one would be able to do that while preserving most of the tree's structure - but with foldr you have to rebuild every single node in the tree)
19:31:01 <acowley> What can the filtering do, though? You would need to supply a placeholder for each element. You could for example filter a V3 (Maybe a).
19:31:55 <johnw> Hmm...
19:32:48 <johnw> I did miss some context :)
19:32:54 <acowley> I think filtering is a pain, honestly. I spent some time working with a filter-like operation in Coq a while ago, and it was nothing but trouble.
19:33:09 <ion> I assume e.g. V3 and IO canâ€™t be instances of the Filterable class.
19:33:15 <johnw> I'm at dinner, chatting from my phone, so I'm ill-equipped
19:33:49 <acowley> You've got food and IRC on your phone, I'd say that, against the backdrop of human history, you were fantastically well equipped.
19:34:05 <johnw> Haha, good point!
19:34:32 <johnw> Still doesn't help you filter though
19:35:17 <joelteon> so, if I want to create a handy generic error catcher that prints out the type of the error caught
19:35:25 <tabemann> filtering *is* an expensive operation, as it has O(n) time and up to O(n) space (depending on what is being filtered)
19:35:28 <johnw> I read about a Buildable class that sounded interesting (sort of dual to Foldable), but I haven't come across Filterable
19:36:55 <tabemann> you could implement a filter on a tree that has even just O(log n) space complexity, but list filtering is always O(n) space complexity
19:39:58 <copumpkin> tabemann: it happens lazily though, and can be discarded
19:40:12 <blackdog> is there a good resource on understanding the difference between the threaded & non-threaded GHC runtime?
19:40:53 <blackdog> i have a fairly IO-heavy program, using many threads. My understanding was that the non-threaded runtime would multiplex between them, just not on more than one core - is that wrong?
19:40:59 <min|dvir|us> Where did f come from? https://gist.github.com/dan-transparensee/b8ba6bc2e5a2c98a5c92
19:41:06 <copumpkin> blackdog: probably the ghc commentary? that's where I'd look
19:41:24 <blackdog> copumpkin: cheers mate, i'll have a look
19:41:37 <johnw> min|dvir|us: f is an argument
19:41:41 <ion> mindvirus: From whoever calls (>>=)
19:42:37 <min|dvir|us> OK, what does = mean?
19:42:51 <johnw> Definition
19:43:03 <min|dvir|us> We're defining f, right?
19:43:05 <tabemann> compumpkin: okay, I admit I was thinking of the space complexity of list filtering in how it would be implemented in a strict language (and assuming tail recursion)
19:43:10 <geekosaur> no
19:43:13 <ion> No, that is the definition of (>>=).
19:43:14 <geekosaur> defining (>>=)
19:43:15 <johnw> No, the operator >>=
19:43:29 <johnw> Which takes two arguments
19:43:29 <blackdog> ah, so if i have many threads wanting to block on file handles i'm screwed unless i create one OS thread per haskell thread
19:43:37 <min|dvir|us> Oh, I see, the order of operations was wrong in my head.
19:43:47 <blackdog> or use the threaded runtime. that makes sense. thanks copumpkin
19:44:16 <ion> mindvirus: foo >>= bar is the same as (>>=) foo bar
19:44:28 <min|dvir|us> That much I know.
19:44:34 <shachaf> blackdog: Wait, why?
19:44:44 <min|dvir|us> Can you surround (Just x) >>= f = f x with parentheses?
19:44:53 <min|dvir|us> So I can see the order of operation?
19:44:53 <dolio> tabemann: Maybe writing a library of strict lists and tail recursive algorithms in Haskell is counter productive toward learning to think about lazy evaluation. :)
19:45:03 <geekosaur> um?
19:45:04 <shachaf> ==dolio
19:45:07 <geekosaur> that's a definition
19:45:23 <shachaf> blackdog: You should be able to do a lot of "blocking" I/O in your Haskell program just fine.
19:45:24 <ion> (((>>=) (Just x)) f) = f x
19:45:25 <blackdog> shachaf: reading http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/IOManager
19:45:40 <blackdog> noticed when i compiled without -threaded that my performance plummeted
19:45:45 <min|dvir|us> Got it.
19:46:11 <ion> ((>>=) (Just x)) f = f x will actually compile.
19:46:14 <tabemann> dolio: actually I'm writing lazy functions in it too, because most of the functions that produce new lists have versions that do an automatic conversion to a lazy list (as that's less expensive than explicitly converting later), and those take advantage of laziness
19:46:42 <carter> blackdog that'd do it
19:46:49 <carter> blackdog also make sure you're using the safe FFI
19:46:56 <carter> for any C calls
19:47:05 <carter> in your case unsafe calls would be bad
19:47:08 <geekosaur> defining function using operator syntax is somewhat strange looking at first
19:47:12 <blackdog> carter: that's the annoying thing, i don't do any FFI myself.
19:47:20 <blackdog> so it'd have to be a library crash.
19:47:21 <carter> blackdog look at the ffi's of all your deps
19:47:23 <ion> mindvirus: f a b c d is the same as ((((f a) b) c) d)
19:47:42 <carter> blackdog grep for foreign ccall unsafe
19:47:48 <carter> lemme check my code
19:47:50 <carter> i do that one :)
19:48:23 <tabemann> why do people seem to use "unsafe" by default, when for most things except when you know your C code is not thread-safe "safe" would have much better threading behavior?
19:48:27 <blackdog> carter: huh, that's weird - looking at dmesg, it's actually segfaulting in libc?
19:48:28 <carter> blackdog yup foreign import ccall unsafe
19:48:45 <carter> tabemann "foreign import ccall unsafe" has a very specific meaning
19:49:00 <shachaf> blackdog: Segfaulting in libc doesn't necessarily mean that it's libc's fault. :-)
19:49:01 <blackdog> carter: just means that the c isn't gonna callback, doesn't it?
19:49:01 <carter> its not safe and unsafe in the "shit will break or crash sense"
19:49:06 <tabemann> carter: I know
19:49:07 <carter> blackdog more than that
19:49:18 <blackdog> shachaf: true :)
19:49:22 <geekosaur> unsafe/safe conflates two meanings, only one involving threads
19:49:37 <carter> blackdog it means that core "ghc scheduler capability" is waiting for the c call to return
19:49:47 <carter> instead of running other haskell threads
19:50:23 <blackdog> hrm. that would be bad in my case, i typically have tens of thousands of runnable threads...
19:50:39 * tabemann remembers seeing unsafe C calls in places like ByteString...
19:50:44 <carter> blackdog sinceyou're  IO bound i thinkâ€¦ you want ot change all your ffi calls ot do "foreign import ccall safe"
19:50:57 <shachaf> blackdog isn't doing any FFI calls.
19:51:04 <carter> shachaf but libs he's using may!
19:51:17 <shachaf> Also I think he was talking about the I/O manager, which is a completely different story.
19:51:19 <tabemann> why do people even use unsafe?
19:51:37 <carter> tabemann when you're doing a short computation
19:51:49 <dolio> Because it's better most of the time.
19:51:53 <carter> or if you're throughput rather than latency oriented
19:51:56 <geekosaur> unsafe means don't assume the C function will block and don't make arrangements for it to be able to call back into Haskell
19:52:02 <carter> yeah
19:52:18 <tabemann> is stopping all the threads on all the CPUs better than a small but measurable constant increase of time in a single thread?
19:52:27 <carter> tabemann ITS NOT SMALL
19:52:39 <carter> for my use case, its several order of magnitude of dfferent
19:52:42 <carter> lemme pull up the numbers
19:52:45 <blackdog> carter: though, i am throughput oriented
19:52:54 <Ralith> Is it possible to get cabal install's --with-PROG=path option to work for package-specified programs?
19:52:57 <carter> blackdog yes, but you're IO bound rather than CPU bound
19:53:03 <carter> Ralith sorta
19:53:16 <carter> Ralith remember that Setup.hs i showed you?
19:53:25 <Ralith> vaguely
19:53:34 <Ralith> the one with the elaborate ghc option passing thing?
19:53:36 <carter> Ralith https://gist.github.com/cartazio/5842786
19:53:37 <carter> yes
19:53:47 <Ralith> what about it?
19:53:50 <carter> that lets you also do it for any other program cabal runs
19:53:59 <blackdog> carter: sure. so if i have any FFI calls blocking and imported unsafe, i could be in trouble?
19:54:05 <carter> blackdog yes
19:54:36 <carter> blackdog worth doing a cabal get for all the libs you use
19:54:41 <carter> and grep through
19:54:53 <Ralith> carter: I'm not trying to pass options to programs cabal runs, I'm trying to add a cabal option of the form "--with-PROG=path"
19:55:05 <carter> Ralith I don't think thats possible
19:55:14 <carter> whats the use case goal?
19:55:32 <Ralith> specifying alternative llvm installations
19:55:41 <blackdog> carter: yeah. i'm also getting some info from dmesg that shows where it's crashing in libc - that might be another angle of attack
19:55:41 <Ralith> and/or weirdly named llvm-configs
19:55:56 <carter> Ralith have a cabal flag for different major versions
19:56:01 <carter> with a default one
19:56:10 <Ralith> that's not the usecase
19:56:12 <carter> oh
19:56:16 <carter> whats the use case?
19:56:22 <Ralith> you might have multiple installs of the same version compiled with different options, for example
19:56:27 <Ralith> or multiple svn revisions
19:56:29 <carter> thats not the use case
19:56:33 <carter> whats the use case?
19:56:39 <Ralith> ...what I just said?
19:56:44 <carter> whats the thing you're cabalizing?
19:56:50 <Ralith> llvm-general
19:57:09 <carter> Ralith you mean you want to support all the llvm's?
19:57:12 <Ralith> no
19:57:13 <carter> with a single llvm-general?
19:57:22 <Ralith> I mean I want to support user-specified paths to llvm-config
19:57:33 <Ralith> see https://github.com/bscarlet/llvm-general/pull/41
19:57:35 <carter> Ralith i think that theres a way to pass args to a cabal user flag
19:57:46 <carter> andn then you need to do some parsing in ssetup hs
19:58:08 <Ralith> cabal has a well defined notion of 'programs' and 'user-specified program paths' and such
19:58:14 <Ralith> I'm trying to work out how to use them
19:58:41 <Ralith> see http://www.haskell.org/ghc/docs/7.6.3/html/libraries/Cabal-1.16.0/Distribution-Simple-Program.html
19:58:43 <carter> lemme know wha tyou learn!
19:58:48 <Ralith> will do
19:58:57 <carter> Ralith those are for programs cabal is managing running
19:59:12 <Ralith> from the docs, I quote:
19:59:14 <Ralith> "One nice thing about using it is that any program that is registered with Cabal will get some "configure" and ".cabal" helpers like --with-foo-args --foo-path= and extra-foo-args.
19:59:18 <Ralith> "
19:59:30 <Ralith> cabal provides the infrastructure to use these systems from within Setup.hs for arbitrary purposes
19:59:42 <Ralith> wait a moment
19:59:46 <carter> Ralith in which case you should stare at my weird setup.hs more :)
19:59:47 <Ralith> that doc line is inconsistent with the help message
19:59:54 <Ralith> carter: I don't see the relation
20:00:09 <Ralith> hm, doesn't like --foo-path= either
20:00:44 <carter> --w  --with-PROG=PATH
20:00:51 <carter> cabal help install
20:01:08 <min|dvir|us> Are monads blocking?
20:01:17 <Ralith> carter: yes, recall:
20:01:20 <Ralith> 19:54:37 < Ralith> Is it possible to get cabal install's --with-PROG=path option to work for package-specified programs?
20:01:21 <ion> â€œBlockingâ€ is meaningless in the context of monads.
20:01:26 <carter> Ralith make a toy example
20:01:39 <carter> and then using the configureHook rather than the build hook
20:01:45 <carter> use my cook to pull out the program options db
20:01:49 <carter> and look up llvm-config
20:01:51 <carter> and see what happens
20:02:39 <Ralith> it would be absent, because it needs to be explicitly added by Setup.hs
20:02:41 <min|dvir|us> Whitespace is completely insignificant, right?
20:02:47 <carter> Ralith then it can't work
20:02:52 <ion> Where?
20:02:53 <Ralith> why not?
20:02:57 <carter> or maybe it can?
20:02:58 <carter> hrmmm
20:02:59 <geekosaur> um? indentation is very significant
20:03:43 <Ralith> min|dvir|us: you may be interested in a haskell tutorial.
20:03:53 <min|dvir|us> Ralith: yep, I realize that. :)
20:03:56 <Ralith> @where lyah
20:03:57 <lambdabot> http://www.learnyouahaskell.com/
20:04:41 <Demos> lyah is the best peice of technical writing I have read in a very long time
20:05:05 <geekosaur> it has some flaws (and some out of date pieces, but I gather an update is in the works)
20:05:07 <carter> Ralith the configFlag or extraConfigFlags fields in the localBuildInfo record may be the relevant ones
20:05:19 <geekosaur> but it's one of the better haskell tutorials all the same
20:05:35 <Ralith> carter: https://github.com/bscarlet/llvm-general/blob/master/Setup.hs#L38
20:05:37 <Demos> geekosaur, please elaborate...
20:05:38 <carter> geekosaur we break old features to build more awesome once every 3 years
20:05:40 <ion> preflex: seen BONUS
20:05:40 <preflex>  BONUS was last seen on #haskell 2 years, 60 days, 7 hours, 37 minutes and 41 seconds ago, saying: yeah i think that's better as well
20:06:03 <carter> oh cool
20:06:06 <carter> so it already does it?
20:06:11 <Ralith> it does
20:06:12 <Ralith> it still doesn't work
20:06:20 <carter> Ralith make a mini cabal...
20:06:30 <carter> that jsut takes a mock flag and path
20:06:40 <carter> and have the setup.hs print it out
20:06:47 <carter> or try to look i tup
20:07:18 <geekosaur> Jun 26 19:40:06 <kurak0t>	BONUS said it will be coming soon
20:07:40 <Ralith> lemme see where the 'unrecognized option' message comes up
20:07:50 <Ralith> I suspect that Setup.hs isn't actually expected to add programs
20:07:50 * geekosaur looks for additional context
20:08:24 <carter> Ralith there are weird corners of cabal that need fixing
20:08:37 <carter> dcoutts or someone else who's kind an expert might be able to help
20:08:39 <geekosaur> hm, apparently was quoting a faq on the website, and who knows when that faq was last updated
20:08:48 <geekosaur> so maybe no update coming soon after all :(
20:09:57 <ion> Any statement on the Intertubes that uses words like â€œsoonâ€ should have a timestamp. :-P
20:14:36 <geekosaur> anyway one of the out of date things one runs into is that when lyah was written, the State/Reader/Writer monads were standalone. these days they've been turned into applications of the corresponding transformers, and slight source changes are needed to work with them
20:14:36 <geekosaur> I don't think lyah gets into the other changes like exceptions and the change to Num's "superclasses"
20:14:52 * geekosaur sent those some minutes ago... to the wrong channel. ooooops
20:23:38 <Gildarts> hello
20:23:50 <Gildarts> can anyone answer small question about haskell?
20:24:15 <geekosaur> @where justask
20:24:15 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
20:25:01 <Gildarts> fillRow Board =  Board >>= map (flip (:) xss) $ fillelem.(\(xs:xss) -> xs) is there any way to get acces to xss in map
20:25:19 <Gildarts> i mean ghc throws error xss not in scope
20:25:54 <Ralith> carter: okay, it looks like cabal does not support user specified programs that way.
20:26:13 <Ralith> carter: what was that you were saying about passing options to cabal flags?
20:26:37 <geekosaur> you can't use exactly the same xss, because ti si indeed not in scope (its scope is the outer parentheses in (\(xs:xss) -> xs) )
20:26:49 <geekosaur> you should however be able to use the same kind of lambda expression in the map
20:27:34 <Gildarts> yea but that would require getting my hands on argument sent from board
20:27:36 <geekosaur> hm, or not, come to think of it. but then you don;t have quite enough there to know the actual shape of the data
20:28:13 <geekosaur> also that uppercase Board looks wrong
20:28:46 <geekosaur> (it *may* be right, but seems unlikely)
20:29:00 <c_wraith> I don't think it can be right, unless map is not Prelude.map
20:29:03 <Gildarts> well sorry i was translating it to english to be more understable it should be lowercase
20:29:27 <geekosaur> if you're asking questions about haskell code, best to stick to haskell instead of trying to translate it to English :)
20:30:01 <geekosaur> anyway you can grab and name the parameter with a lambda: fillRow board = board >>= \thing -> ...
20:30:32 <geekosaur> (possibly usinbg a pattern to deconstruct `thing`)
20:31:31 <c_wraith> by the way, the expression (\(xs:xss) -> xs) is equivalent to the function head, except for the error message if it's given an empty list
20:32:48 <Gildarts> well its a little simplefied code :P this lamda funtion is needed cuz board for real is touple (board,state) and i need to take out state :)
20:33:19 <erisco> :t filter
20:33:19 <erisco> >:t filter
20:33:20 <geekosaur> so apply the lambda where I did instead
20:33:20 <lambdabot> (a -> Bool) -> [a] -> [a]
20:33:45 <geekosaur> then xs and xss are in scope across the whole expression instead of that one part
20:34:04 <Gildarts> yea that is true sems reasonable
20:34:09 <Gildarts> thank you
20:34:11 <erisco> lambdabot help
20:37:11 <erisco> hm is lambdabot being sluggish? :s
20:37:16 <arkeet> always
20:37:40 <Gildarts> argh that won't work  cuz [([[Char]],([Int],[Int],[Int],[(Int,Int)],Int))] -> [[[Char]]] i don't know which board am i evaluating now
20:38:15 <ekipan> have you considered using real data instead of type aliases?
20:38:48 <geekosaur> er? you managed to pull it apart to (xs:xss) once, do you really need the full type information in the map?
20:39:47 <carter> Ralith brb
20:43:42 <tabemann> holy crap running QuickCheck under ghci absolutely exploded my memory usage
20:43:42 <Cale> Gildarts: It would be a really good idea to learn about and use data declarations, looking at that type signature
20:44:20 <Gildarts> i have list of list of lists i am using it in list monad and for each list of lists i wanna pull out head put it in another list monad then get result from that computation and join it with tail of list from which i took head
20:45:16 <Gildarts> Cale maybe u are right but i rly like more that type signature :)
20:45:48 <NemesisD> hey guys. here for my nightly bug #haskell about the logict package
20:47:08 <NemesisD> it exports a function called runLogic :: Logic a -> (a -> r -> r) -> r -> r, described as "Runs a Logic computation with the specified initial success/failure continuations", don't quite understand the contiuation part
20:48:09 <geekosaur> Gildarts, that's a rather horrid type signature, actually. I'd be using record syntax myself so I could sanely pull out parts of that as needed...
20:50:50 <augur> NemesisD: (a -> b) -> b is a b-continuation of a
20:52:17 <NemesisD> augur: is there another way to put it?
20:52:27 <augur> NemesisD: another way to put what?
20:52:55 <NemesisD> augur: what does that mean?
20:53:10 <augur> which? the quoted portion, or the type?
20:53:17 <Cale> NemesisD: the result (of type a) of the computation is passed to the function of type (a -> r -> r) if there is one, and you get the other value of type r otherwise
20:53:36 <Cale> er, well...
20:54:17 <Cale> heh, right, recursively, the function of type (a -> r -> r) is used to build a result from *all* the results of the computation
20:54:22 <Cale> this is like foldr for the list monad
20:54:42 <Cale> If you pass (:) and [] to runLogic x, then you'll get a list of the results
20:54:53 <NemesisD> Cale: is the second -> r a default value then?
20:55:20 <Cale> NemesisD: yeah, in a sense -- it handles the case when there are no results of the Logic computation.
20:55:44 <Cale> (and is also the base case for the recursion when collecting the results)
20:56:11 <augur> its an interesting fact that the list fold has a very continuationy type
20:56:27 <Cale> Well, all folds do.
20:56:32 <augur> really?
20:56:38 <Cale> all catamorphisms do
20:56:45 <Cale> to be more precise :)
20:56:48 <augur> oh well i guess if you move the data to the front you're right
20:56:58 <augur> sort of
20:57:03 <augur> Fix f -> (f a -> a) -> a
20:57:09 <augur> hmm
20:57:25 <NemesisD> Cale: have you looked into the logic monad at all
20:57:27 <augur> i wonder what that means
20:57:29 <Cale> NemesisD: sure
20:57:37 <Cale> NemesisD: I've used logict before
20:58:12 <Cale> NemesisD: You can basically think of it as a somewhat more efficient list monad
20:58:34 <NemesisD> Cale: i'm toying around with a cart optimization algorithm: given a wishlist, build the cheapest cart that satisfies it with the fewest vendors, all thins equal
20:58:45 <Cale> (The implementation is in terms of success and failure continuations though)
21:00:19 <NemesisD> Cale: my thought was 2 approaches: use logict to constrain the problem space to only carts which satisfy the list, then sorting the list by favorability of the order, take the first one
21:00:30 <Cale> I'd usually advise working with the list monad as long as you can, and then if you want to try to speed things up a bit, switch to Logic, though LogicT can be convenient sometimes too.
21:00:48 <Cale> (and it's actually a monad transformer, unlike the mtl's ListT)
21:00:50 <NemesisD> Cale: possibly more space-efficeint: somehow combine logict with a state monad that can store the current winner
21:01:41 <jmcarthur> you only need a writer monad for that, really
21:03:25 <augur> i dont get LogicT at all
21:03:28 <jmcarthur> also, even with your other idea, you don't need to sort first. just linearly search for the best from the results
21:03:28 <augur> or the underlying monad
21:03:57 <jmcarthur> augur: it's just ListT at its core
21:04:07 <jmcarthur> augur: the "ListT Done Right" kind
21:04:07 <Aetherspawn> :t [
21:04:08 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
21:04:11 <Aetherspawn> :t ([)
21:04:12 <lambdabot> parse error on input `)'
21:04:20 <augur> jmcarthur: but i mean, i dont get how its used or what its for or anything
21:04:32 <jmcarthur> augur: have you ever used the list monad?
21:04:39 <augur> jmcarthur: yes :P
21:04:40 <jmcarthur> knowingly
21:04:45 <jmcarthur> that, then :)
21:04:47 <dmwit> Aetherspawn: There's some syntax for lists; [ is not an operator.
21:04:55 <augur> jmcarthur: its used for making lists?!
21:04:56 <Aetherspawn> Thought so
21:05:08 <augur> :t []
21:05:08 <lambdabot> [a]
21:05:15 <augur> and here i was hoping for * -> *
21:05:16 <augur> :(
21:05:24 <dmwit> :k []
21:05:25 <lambdabot> * -> *
21:05:49 <ekipan> if you're hoping for kinds, ask for kinds instead of types, silly
21:05:52 <jmcarthur> augur: basically, yes. the main difference is the CPS style and some nice combinators for breadth first search and stuf (the list monad itself is depth first)
21:05:58 <jmcarthur> *stuff
21:06:06 <augur> jmcarthur: :|
21:06:13 <augur> then why is it "logic"?
21:06:39 <jmcarthur> augur: to be clear, both [] and LogicT monads are depth first. it's just that the latter has some nice combinators for breadth first in addition to that
21:06:40 <NemesisD> small gripe but why are none of the methods in he writer monad documented?
21:06:46 <NemesisD> does this come from a time before haddock?
21:06:46 <jmcarthur> augur: because it's for logic programming
21:06:52 <jmcarthur> augur: just like the list monad :)
21:06:54 <augur> jmcarthur: how do you use it for logic programming
21:07:13 <jmcarthur> augur: the resulting list is just all possible results
21:07:24 <augur> hmm
21:07:30 <augur> ok
21:07:35 <jmcarthur> > do { x <- [1..3]; y <- [4..6]; return (x*y) }
21:07:36 <lambdabot>   [4,5,6,8,10,12,12,15,18]
21:08:03 <jmcarthur> augur: you can read "x <- [1..3]" as "x can be 1, 2, or 3". similarly for y
21:08:15 <augur> hm
21:08:16 <jmcarthur> augur: and the result is all possible results for all possible choices
21:08:21 <augur> sure
21:08:32 <jmcarthur> augur: you can, of course, just pick the first, or pick a random result, or something else
21:08:40 <augur> but logic programming is more than that!
21:08:41 <jmcarthur> augur: the essense of "nondeterminism"
21:08:53 <jmcarthur> augur: sure, it is also about constraints and other fun stuff
21:08:55 <jmcarthur> :t guard
21:08:55 <lambdabot> MonadPlus m => Bool -> m ()
21:08:58 <jmcarthur> and so on
21:09:06 <augur> hmm
21:09:18 <augur> i guess i'd need to see a good example of this thing being used
21:09:20 <augur> ah well
21:09:32 <NemesisD> jmcarthur: i don't really understand how i could use a writer monad, don't you need a monoid instance on the log type. what would that be?
21:10:57 <jmcarthur> NemesisD: it would be Max or Min or whatever you define Best as. it should be associative. you just need to make sure there is an identity
21:11:33 <jmcarthur> the identity would be whatever value is "worst"
21:11:42 <joelteon> do you guys have any suggestions for how to display arbitrary exceptions helpfully? ideally more than just using show
21:11:46 <hpaste> tabemann pasted â€œReplicate causes a stack overflowâ€ at http://hpaste.org/4407227231332466688
21:12:14 <NemesisD> *checks the monoid laws*
21:12:28 <jmcarthur> tabemann: this is a classic case of writing a tail recursive function when a non tail recursive function would be better
21:12:49 <jmcarthur> tabemann: in haskell, a tail recursive function with a strict accumulator should usually make the accumulator *explicitly* strict
21:13:09 <tabemann> I wrote it that way because List a is strict
21:13:15 <jmcarthur> well, there you go :)
21:13:30 <tabemann> but what I am wondering about is why is it causing a stack overflow
21:13:37 <hpaste> jmcarthur revised â€œReplicate causes a stack overflowâ€: â€œfixed!â€ at http://hpaste.org/4407227231332466688
21:13:43 <jmcarthur> tabemann: ^^
21:13:54 <jmcarthur> tabemann: i can try to explain why that bang pattern helps
21:14:18 <jmcarthur> tabemann: the gist is that that accumulator is not being forced along the way, so it's actually just building up a chain of thunks
21:14:21 <chrisdotcode> so guys...
21:14:27 <chrisdotcode> haskell has ruined every other language for me.
21:14:41 <jmcarthur> tabemann: then when the result is finally ready to be evaluated, it has to push all those thunks to the stack
21:14:45 <tabemann> why do I need a bang if List is defined as data List a = Cons !a !(List a) | Nil?
21:14:46 <chrisdotcode> I miss Maybes so much in Java and JavaScript...
21:14:50 <jmcarthur> tabemann: totally defeating the purpose of tail recursion ^_^
21:15:04 <ekipan> the afterglow will wear off eventually, chrisdotcode
21:15:14 <NemesisD> jmcarthur: so i'd create a type like Best and its mappend would take 2 values and return the better one?
21:15:16 <chrisdotcode> ekipan: is that a good thing, or not?
21:15:20 <tabemann> shouldn't Cons itself force each successive thunk?
21:15:22 <jmcarthur> tabemann: this bang forces the accumulator to be forced at all. without that, your constructors won't even be evaluated. the fact that those fields are strict is irrelevant
21:15:27 <augur> Cale: what sets apart the usual fold tho is that you've got some linkage between the continue type and the continuized type
21:15:28 <jmcarthur> NemesisD: yup!
21:15:49 <ekipan> Haskell is a tool, a nice tool, but it really matters more what you make with the tool
21:15:51 <jmcarthur> tabemann: the point is that you have to force Cons itself
21:15:57 <tabemann> sounds like there's quite a few bangs I'll need to add to my code here
21:16:08 <tabemann> no wonder it was having horrible performance when I was testing it with QuickCheck
21:16:24 <augur> Cale:   Fix f -> (f r -> r) -> r   is somewhat unusual. i mean, you'd expect a given type a not f r
21:16:31 <jmcarthur> tabemann: this is an interesting interplay between tail recursion and laziness
21:17:03 <NemesisD> jmcarthur: i think i may be a approaching a "woah dude" moment where i understand an instance of monoid that isn't analogous to appending lists
21:17:11 <jmcarthur> tabemann: lazy results tend to favor non tail recursive functions. strict results tend to favor tail recursive ones, but you have to *really* make sure the function is strict
21:17:27 <jmcarthur> NemesisD: all monoid instances are related to appending lists, really
21:17:50 <ekipan> > Sum 2 `mappend` Sum 3
21:17:51 <lambdabot>   Sum {getSum = 5}
21:17:53 <tabemann> jmcarthur: so I'll need to force all my accumulators manually basically
21:17:55 <jmcarthur> NemesisD: lists are the so-called "free monoid" because [] applied to any type forms a monoid even though the type you apply it to is not necessarily a monoid
21:18:00 <ekipan> > Product 2 `mappend` Product 3
21:18:01 <lambdabot>   Product {getProduct = 6}
21:18:02 <jmcarthur> tabemann: your strict ones, at least
21:18:11 <jmcarthur> tabemann: also, ghc can infer some of them, but you shouldn't trust it to
21:18:13 <tabemann> that I mean
21:18:48 <NemesisD> jmcarthur: in my case though i'm not really doing anything like a list, which makes me think i'm breaking the law
21:18:51 <jmcarthur> (there is a better explanation of why lists are free monoids, but i haven't the time or experience to try it)
21:19:31 <jmcarthur> NemesisD: nope! this is actually still just like a list in the sense that you could instead use lists and then do   foldr mappend mempty   to the result
21:19:45 <augur> Cale: if you know of anything i can read about the relationship between continuations and catamorphisms do let me know, i'd be very interested in reading it
21:19:52 <rarash> Hello friends! How difficult would it be to implement TDNR or a mini-version of it? I'm thinking about what to do for my master's project. However I bet it's way too big of an undertaking to implement it for ghc. However this is one of very few things I feel passionate about now. Would it be a yearlong project or is it possible to do it in 4 months. Alternatively implement it for a much smaller subset of
21:19:54 <rarash> haskell.
21:20:00 <jmcarthur> NemesisD: note how nicely foldr fits with mappend and mempty. no coincidence, here
21:20:27 <NemesisD> jmcarthur: see in my head, if items are say integers, then i'd be writing something like 3 `mappend` 2 == 3
21:20:50 <jmcarthur> NemesisD: well, it would be your own type, since you don't want to write an orphan instance or conflict with existing instances
21:20:51 <rarash> And I've never hacked ghc before so I guess I'm not too prepared for such an endouvur either.
21:21:01 <NemesisD> which isn't so much appending as it is choosing
21:21:13 <jmcarthur> NemesisD: "mappend" is a bad name
21:21:31 <jmcarthur> NemesisD: my only point is that you can relate all monoids to lists in some way
21:21:32 <augur> so, any good paper suggestions?
21:21:34 <augur> anyone?
21:21:41 <augur> jmcarthur: you probably know of some good papers i could read
21:21:59 <augur> all monoids are the evaluation of lists!
21:22:00 <jmcarthur> augur: on continuations vs. catamorphisms? not really
21:22:06 <augur> jmcarthur: no just on anything
21:22:28 <jmcarthur> augur: http://okmij.org/ftp/papers/LogicT.pdf :P
21:22:28 <NemesisD> jmcarthur: is it possible/common to test your compliance with the monoid laws with quickcheck
21:22:31 <augur> lists are syntax for monoid values :D
21:22:36 <augur> jmcarthur: and not that :P
21:22:36 <jmcarthur> NemesisD: yes/yes
21:22:47 <augur> that was my first exposure to LogicT and i was terribly confused
21:22:48 <carter> Ralith i'm curious about this now, so i'll hack on it a smidge and see
21:23:13 <jmcarthur> augur: https://personal.cis.strath.ac.uk/conor.mcbride/pub/hasochism.pdf
21:23:20 <ekipan> newtype Max a = Max a; instance Bounded a => Monoid (Max a) where mempty = minBound; mappend = max
21:23:28 <tabemann> jmcarthur: random question - if I have lazy list accumulators, should I force them to WNHF too?
21:24:02 <jmcarthur> tabemann: i won't claim that you should force all accumulators, but it is very rare that you wouldn't want to
21:24:05 <augur> jmcarthur: but i use agda for my DTP :(
21:24:22 <jmcarthur> augur: haskell can do some things agda can't in this area, actually
21:24:27 <jmcarthur> augur: that paper explains some of it
21:24:37 <AsgardBSD> Hi, is there a way in haskell to use REAL array instead of list? Some algorithm work better on array than on list
21:24:55 <jmcarthur> augur: for example, using the constraint solver to generate proofs instead of doing them all by hand
21:25:05 <geekosaur> AsgardBSD, Data.Array or Data.Vector
21:25:18 <augur> jmcarthur: i write my proofs on paper
21:25:23 <AsgardBSD> i intend to purchase either CLRS or the sedgwick book and practice those algo on haskell
21:25:35 <AsgardBSD> geekosaur: what is the difference
21:26:05 <carter> jmcarthur which things can't agda do?
21:26:16 <carter> AsgardBSD the CLRS book is terrible for learning
21:26:17 <jmcarthur> carter: see my "for example" above
21:26:30 <jmcarthur> carter: or, of course, the paper i linked
21:26:40 <AsgardBSD> Well, im the type of guy who love intense theory
21:26:40 <carter> i skimmed hasochism earlier this week
21:26:48 <carter> AsgardBSD i TA'd using that book
21:26:51 <carter> its not a good book
21:26:54 <carter> for learning
21:26:55 <carter> its a reference
21:27:02 <geekosaur> Vector is easier to use and 1-dimensional. Array can do multiple dimensions, is more flexible but somewhat more work to use in my experience
21:27:12 <geekosaur> Vector is also somewhat better optimized
21:27:13 <carter> jmcarthur what time stamp is the example at?
21:27:18 <jmcarthur> vector also encourages a more functional style
21:27:21 <carter> geekosaur don't use array
21:27:25 <geekosaur> Array is rtather "raw"
21:27:43 <geekosaur> why are you tellimg *me* this?
21:27:43 <carter> yeahâ€¦ Unboxed gives a better memory layout than a naive use of storable or array will giveyou
21:27:45 <jmcarthur> carter: all it was was "augur: for example, using the constraint solver to generate proofs instead of doing them all by hand"
21:27:45 <carter> oh
21:27:46 <carter> sorry
21:27:49 <carter> oh
21:27:53 <carter> jmcarthur ahh
21:27:54 <carter> yeah that
21:28:03 <callen> So as somebody who doesn't care about the theory and just wants a useful programming language with a 'better' type system, is this the right place to be?
21:28:17 <jmcarthur> i disagree that unboxed is always a better layout than storable
21:28:29 <carter> jmcarthur example?
21:28:35 <callen> my experience of Haskell so far has been that it takes commonplace problems and turns them into puzzles. I'm not alone in this from my conversations with other developers - are we missing soemthing?
21:28:36 <augur> jmcarthur: ill give it a read tho. it might be interesting for that alone
21:29:00 <carter> jmcarthur it does depend on the access pattern, but what do you have in mind?
21:29:13 <geekosaur> anyway, as carter says, Array is often not the ideal choice, but there are still some things it does better than Vector. (although there is work being done to replace it in those areas too, because Array is just painful)
21:29:27 <carter> geekosaur which areas are you thinking of?
21:29:32 <jmcarthur> carter: branch prediction / cache lines only scale so far when it comes to struct of arrays style. for "large" data types, array of structs can work better
21:29:42 <geekosaur> carter: repa and dph, mostly
21:29:58 <carter> geekosaur I mean what are the cases for array beeing better than vector?
21:30:07 <AsgardBSD> why CLRS is bad?
21:30:10 <jmcarthur> callen: at first it feels like puzzles, but now i feel that way about imperative programming
21:30:12 <callen> I've been following along with Real World Haskell so far.
21:30:27 <jmcarthur> carter: 'why must i keep all this state and context in my head just to solve these "simple" problems?'
21:30:44 <AsgardBSD> im looking to get some CS mathematical background
21:30:46 <carter> jmcarthur hrm?
21:31:03 <carter> AsgardBSD it doesn't really teach the thinking style
21:31:23 <callen> jmcarthur: uhm, okay? The thing is myself and the colleagues I've discussed Haskell with have been getting things done with an imperative lang of some sort (Common Lisp, Python, Java in my case) for years. The unproven and less understood quantity is Haskell. The world's systems aren't in HS so there isn't a plethora of industry experience to work off of.
21:31:25 <AsgardBSD> carter: but it teach the math
21:31:31 <carter> it does?
21:31:32 <carter> where?
21:31:45 <carter> it does some basic big oh
21:31:50 <carter> + some algorithsm and data structre
21:31:59 <carter> the kleinberg book is better for learning
21:32:03 <callen> jmcarthur: I know not everybody who's been using Haskell for a sufficiently long period of time experiences the "puzzle" the way I do, but that's not exactly a comfort if it means a 3+ year ramp-up before my productivity levels off anywhere near where it usually is.
21:32:11 <AsgardBSD> kleinberg?
21:32:16 <jmcarthur> carter: well, how many L2 cache lines do you have? i'd ask L1, but it's so common to use L1 badly anyway that it might be a bad example
21:32:29 <carter> jmcarthur at least 2
21:32:31 <callen> jmcarthur: what was the ramp-up for you before you were productive?
21:32:54 <carter> jmcarthur funnily enough, i'm going to write a hwloc binding this weekend so i can do cache aware scheduling :)
21:33:31 <jmcarthur> carter: i'm sure you have more than that, but sure let's assume it's two. now say you want to iterate over an array of triples, using all three components in each step...
21:33:39 <carter> yes
21:33:46 <jmcarthur> carter: you're dead already
21:33:48 <carter> nope
21:35:11 <jmcarthur> callen: i was productive within a few months, but it took a year before i realized i was significantly more comfortable with haskell than with the imperative langauges i had otherwise been using
21:35:12 <callen> how long did it take everybody in here to become productive in Haskell, relative to previous langs?
21:35:30 <callen> jmcarthur: how long had you been programming before that?
21:35:47 <callen> I wouldn't call my experience of trying to process a tree data structure in Haskell productive :|
21:35:52 <jmcarthur> carter: i don't understand how this scenario could play out in your favor. you can only load two cache lines, but you have three arrays you're tracking
21:36:52 <jmcarthur> callen: i had been programming for a while at the time already. at least 15 years
21:36:54 <AsgardBSD> So Sedgwick book is better than CLRS?
21:37:05 <dufflebunk> Is Data.Serialize recommended for dealing with binary data?
21:37:17 <carter_> AsgardBSD http://www.cs.cornell.edu/home/kleinber/ ?
21:37:19 <carter_> that book
21:37:28 <jmcarthur> carter: i don't understand how this scenario could play out in your favor. you can only load two cache lines, but you have three arrays you're tracking
21:37:48 <carter> jmcarthur ohhh, you mean 2 cache lines per cycle?
21:37:59 <jmcarthur> no
21:38:09 <carter> jmcarthur give me the exact example
21:38:20 <jmcarthur> i mean the total number of cache lines you can hold in L2 (this is why 2 is unrealistically small)
21:38:20 <carter> i'm i'll happily write some code in boht styles and benchmark it
21:38:34 <carter> you have have LOTS
21:38:36 <carter> in l2
21:38:39 <jmcarthur> i know
21:38:48 <jmcarthur> but i can make a large data structure pretty easily, too
21:38:53 <carter> jmcarthur yes
21:38:56 <jmcarthur> especially by composing a bunch of already large ones
21:38:59 <carter> for really large data structures
21:38:59 <carter> sure
21:39:03 <carter> i agree
21:39:22 <carter> then its like a sequence of packets in an array or something :)
21:39:24 <jmcarthur> also, if we're in a situation where we're thinking about L1, this is even more of a big deal
21:39:50 <carter> jmcarthur agreed, storable style layout makes sense for network packets and other complex data types
21:39:51 <callen> jmcarthur: what resources were you using to learn Haskell along the way?
21:39:53 <carter> *really complicated*
21:39:58 <jmcarthur> right
21:40:13 <jmcarthur> for basic linear alg and stuff, unboxed is usually fine
21:40:24 <carter> jmcarthur so we agree
21:40:40 <jmcarthur> carter: at the time i believe i learned a lot from the so-called "gentle introduction", but it's not as gentle as it may sound, and we have better things today
21:40:57 <carter> jmcarthur you mgiht be meaning callen
21:41:13 <jmcarthur> carter: indeed
21:41:27 <jmcarthur> carter: where we disagree is the unqualified claim "Unboxed gives a better memory layout than a naive use of storable or array will giveyou"
21:41:34 <carter> yes
21:41:35 <carter> ok
21:41:38 <jmcarthur> although it may have just been a slip :)
21:41:49 <AsgardBSD> Any suggestion for good math book?
21:41:58 <carter> AsgardBSD ooooo, i know a GREEAT ONE
21:42:46 <carter> analytic combinatorics http://algo.inria.fr/flajolet/Publications/AnaCombi/
21:42:49 <carter> BEAUTIFUCL
21:42:53 <carter> *beautiful
21:42:57 <AsgardBSD> More precisly on linear algebra, matrix, transformation.... Also a book on how does those arbitrary precision number library work
21:43:07 <AsgardBSD> carter that was already on my wish list
21:43:36 <jmcarthur> off to bed
21:43:44 <carter> AsgardBSD  for the latter, http://shoup.net/ntb/ is great
21:43:45 <carter> jmcarthur cool
21:44:11 <carter> jmcarthur i think that the moment the "values" dont fit in all the simd registers, Storable wins
21:44:17 <carter> but smaller than that, unboxed wins
21:44:42 <carter> AsgardBSD for the formerâ€¦ hrmmm
21:44:48 <AsgardBSD> carter: that book cover how to create big variable, create algorithm to manipulate them (and mroe important, explain how it work, from math to implementation)?
21:44:49 <jmcarthur> i think the cutover is likely to be in the L1 or L2 area, not SIMD, but sure, we basically agree
21:44:56 <jmcarthur> gnite!
21:45:08 <carter> jmcarthur yeah, l2 sized things should be storabe :)
21:45:08 <carter> night
21:45:24 <carter> AsgardBSD you've got a lot to learn before you start doing that :)
21:45:37 <carter> AsgardBSD look at those two books ive linked you to
21:45:42 <carter> they both ahve nice pdfs online
21:46:00 <jmcarthur> well, it doesn't have to be fully L2 sized. just sized such that there are more individual components than there are cache lines
21:46:05 <AsgardBSD> carter: I have to learn such thing, since i work i pursue study in embeded, and i will use DSP
21:46:32 <carter> jmcarthur yeah, even l1 or nearly l1 filling
21:46:45 <carter> AsgardBSD i dont' understand, please say that differently?
21:47:43 <AsgardBSD> carter: I pursue study in embeded (electronics) we will work with digital signal processing micro processor (processor that got math module to take natively multiplication and division)
21:47:56 <carter> AsgardBSD http://people.maths.ox.ac.uk/trefethen/text.html is a great book on numerical linear algebra
21:47:58 <AsgardBSD> But in digital signal processing, we may work with really big number
21:48:19 <AsgardBSD> and most of the time, DSP is limited to 16 bit operation
21:48:29 <carter> AsgardBSD yes
21:48:29 <AsgardBSD> (16 bit processor)
21:48:36 <carter> DSP hardware is weird
21:48:38 <carter> yes
21:48:39 <carter> i know
21:48:53 <carter> AsgardBSD whats your goal?
21:48:56 <AsgardBSD> So i need to learn how to implement simple arbitary precision number
21:49:07 <carter> AsgardBSD that wont' end well for embedded systems
21:49:09 <carter> toooo slow
21:49:23 <AsgardBSD> With DSP processor, that will work fine
21:49:32 <AsgardBSD> as long as i dont go too big
21:49:42 <carter> AsgardBSD then you jsut want to allow larger numbers
21:49:45 <carter> not arbitrary
21:49:59 <AsgardBSD> my arbitrary number will be in 20-32 bit resolution
21:50:02 <carter> yes
21:50:08 <carter> so just use 2 16bit words
21:50:13 <carter> thats simplest
21:50:38 <carter> the fancier algs will be complicated and slower
21:50:49 <AsgardBSD> but will be interesting to learn
21:50:53 <carter> AsgardBSD yes
21:50:58 <carter> start with the shoup book
21:51:00 <AsgardBSD> Since i may also work with some arm cortex
21:51:02 <carter> i linked you to it
21:51:09 <AsgardBSD> more power = more fun doing a calculator
21:51:22 <carter> AsgardBSD the books i'm pointing you at are a *great* way to start
21:51:30 <carter> I'm writing numerical computing tools as my job
21:51:36 <carter> so i'm a bit opnionated :)
21:51:51 <carter> the shoup book is a *great* reference and way fo learnign computational mathematical
21:51:53 <carter> things
21:52:01 <AsgardBSD> i know it teach number theory, i was just wondering if it cover arbitrary precision number algorithm and design
21:52:10 <carter> AsgardBSD look at the index
21:52:14 <carter> i mean contents
21:52:16 <carter> before
21:52:19 <carter> you ask these questions
21:53:11 <carter> it has that
21:53:18 <carter> and links to all the background beyond
21:54:06 * tabemann just discovered a hazard with QuickCheck - don't let it feed random numbers that are unlimited into functions that use those numbers to determine how much memory they allocate... (random 64-bit integers are a good way to explode your memory usage that way)
21:54:21 <carter> heheh
21:54:28 <carter> tabemann stuff like that has happened to me
21:56:01 <AsgardBSD> Also, do you happen to know any book on boolean algebra(well, not just one that teach karnaugh table, NOT, AND, XOR, OR, but one that teach lot of stuff)
21:56:15 <tabemann> I was kind of implicitly assuming that QuickCheck would generate *sane* numbers for some reason...
21:56:38 <carter> tabemann pick the right input distributions
21:56:43 <carter> AsgardBSD "hackers delight"
21:56:50 <carter> and the "hakmem"
21:56:56 <carter> wil teach you all the bit fiddly tricks
21:57:00 <carter> and i need to crash
21:57:08 <AsgardBSD> crash?
21:57:21 <carter> sleep
21:57:22 <carter> rest
21:57:26 <carter> etc
21:57:53 <AsgardBSD> mv carter /dev/null
21:58:01 <AsgardBSD> You can now sleep
21:58:06 <AsgardBSD> :P
21:58:08 <carter> Nope
21:58:09 <carter> ttyl
21:58:13 <carter> look up those books
21:58:17 <carter> and their tables of contents
21:58:24 <Freze> carter isin't haskell good for analyzing languages
21:58:31 <carter> that'll keep you busy and learning for at least a 6 months
21:58:36 <NerrZ> Is it possible to compile to a windows executable on linux with GHC?
21:59:39 <carter> Freze programming language or natural language?
21:59:45 <carter> theres a bajillion libs on hackage for both
21:59:50 <Freze> natural language
21:59:52 <AsgardBSD> carter: I was also about to get the Knuth book on math
21:59:53 <tabemann> back
21:59:59 <AsgardBSD> http://www.amazon.com/Concrete-Mathematics-Foundation-Computer-Science/dp/0201558025/ref=pd_sim_b_8
22:00:04 <carter> AsgardBSD start with these other things
22:00:13 <carter> they will keep you busy for at least a few months
22:00:26 <AsgardBSD> carter: i am already busy with college
22:00:28 <carter> cool
22:00:36 <tabemann> carter: I just went and put a limit of < 1000 on the numbers fed into my variable-memory-allocating functions
22:00:43 <carter> tabemann woot
22:00:47 <carter> that a good idea
22:01:24 <tabemann> now all the tests pass (after a few fixes) without eating all the memory on my system
22:01:25 <carter> i have algorithms which I test over a range of inputs from 2^8  through 2^22 ish, longer and the benchmarks take more than 5 minutes
22:01:31 <carter> *larger
22:01:32 <carter> woot
22:01:36 <carter> night all
22:01:39 <tabemann> g'night
22:02:43 <AsgardBSD> thanks for those book
22:03:29 * hackagebot oeis 0.3.2 - Interface to the Online Encyclopedia of Integer Sequences (OEIS)  http://hackage.haskell.org/package/oeis-0.3.2 (BrianLewis)
22:05:45 <DiegoNolan> why is rnf of the NFData type class hidden in Control.Parallel.Strategies
22:08:29 <johnw> DiegoNolan: I don't quite understand the question
22:08:35 <johnw> where do you think it should be?
22:08:55 <DiegoNolan> i want to be able to use rdeepseq on a PixelRGB8
22:09:17 <DiegoNolan> so just a PixelRGB8 Word8 Word8 Word8
22:09:20 <johnw> is there something stopping you from using it?
22:09:27 <DiegoNolan> it has to be in the NFData typeclass
22:09:34 <johnw> instance NFData PixelRGB8
22:09:36 <johnw> should be all you need
22:09:46 <DiegoNolan> oh
22:09:46 <DiegoNolan> huh
22:09:50 <blackdog> is there a way to find out what type an exception has? I'm getting a SomeException at the top level, and printing it gives <<timeout>>, but running typeOf over it just gives me Some
22:09:54 <blackdog> Exception
22:11:05 <johnw> blackdog: there is a Typeable constraint
22:11:12 <johnw> ah, I see
22:11:21 <blackdog> johnw: yes. it tells me it has type SomeException :)
22:11:32 <blackdog> it is 100% corrcet and 100% useless
22:11:50 <DiegoNolan> what is the point of not allowing me derive the typeclass if i can just make an instance like that?
22:12:00 <johnw> SomeException wraps the exception, does it not?
22:12:08 <johnw> can you pattern match on (SomeException e) and then use typeable on e?
22:12:41 <johnw> DiegoNolan: I don't know what you mean by it not allowing you to derive the type class
22:13:01 <blackdog> johnw: oh! yes, that looks like it might work. thanks!
22:13:15 <johnw> DiegoNolan: if you turn on GeneralizedNewtypeDeriving, can you then using deriving NFData?  I haven't tried
22:13:20 <carter> johnw yeahâ€¦ I think blackdog  can use the reflection stuff to sort out the actual cnstructor type
22:14:01 <DiegoNolan> idk.  I was unaware of that flag
22:14:44 <DiegoNolan> and the type is defined in another module.  i was just testing on a test type to see if it worked
22:15:01 <johnw> the instance line I gave above is what I commonly use
22:15:14 <DiegoNolan> yeah the instance works
22:16:04 <Cale> DiegoNolan: I guess the point is that the compiler can't know about every typeclass people will define?
22:16:34 <johnw> plus, you may have reason for not wanting them to use a function like rnf.  Haskell is not permissive by default about these things
22:16:38 <carter_> blackdog http://hackage.haskell.org/package/exceptions might catch your fancy :)
22:16:48 <carter> blackdog check it out :)
22:16:52 <DiegoNolan> true
22:17:11 <johnw> carter: is that just another version of what lifted-base does?
22:17:22 <carter> i have no idea what lifted-base does
22:17:33 <blackdog> carter: cheers, i'll check it out.
22:17:44 <johnw> Control.Exception.Lifted makes all the functions from Control.Exception usable in any monad transformer over IO
22:17:54 <carter> johnw this lets you do cases over exceptions
22:17:57 <carter> so Nope :)
22:18:02 <johnw> cool, I'll check it out!
22:18:20 <johnw> ah, an edwardk library
22:18:23 <johnw> you had me at e
22:18:35 <carter> johnw say no to e, its bad for your
22:18:43 <carter> unless E gives you its capability
22:18:46 <carter> but thats not e :)
22:18:52 <johnw> plus, lifted-based requires MonadBaseControl IO
22:18:56 <johnw> this package works for non-IO
22:19:37 <johnw> you know the world still holds wonder when you learn there are still more edwardk packages you have yet to discover
22:19:38 <carter> johnw you're faster at reading than I am at answering!
22:20:08 <johnw> carter: well, I've been dealing intimately with the issues this package addresses, so a lot of it is instantly familiar
22:20:15 <AsgardBSD> carter is still there...
22:20:31 <AsgardBSD> was sure you where sleeping
22:20:37 <carter> AsgardBSD this is a robot
22:20:42 <carter> the teaching one is gone
22:20:46 <AsgardBSD> do you got any book suggestion on parsing technics
22:20:55 <johnw> in fact, I'm going to queue this Haddock to my iPad for proper consumption later
22:21:08 <carter> johnw because of some pending change with 7.8 (that you cant write your own Typeables in 7.8), he coudln't use a fake typeable trick to do the same stuff
22:21:13 <johnw> AsgardBSD: what kind of parsing do you want to learn about?
22:21:25 <AsgardBSD> like how to parse expression such as : 4*a + sin(4*b) -c^3
22:21:33 <carter> so i think he just pushed a new version that will do a slower hack
22:21:36 <johnw> ah, I recommend starting with simple top-down LL(1) grammars
22:21:37 <carter> AsgardBSD use parsec
22:21:51 <carter> AsgardBSD for now just use parsec or *maybe* attoparsec
22:22:01 <carter> but you've already given yourself a HUGE reading list
22:22:06 <carter> lets first finish the pile :)
22:22:15 <AsgardBSD> parsec is a book?
22:22:16 <johnw> carter: well, if he just wants to parse such strings, parsec is fine; if he really wants to understand how parsers work, I wouldn't recommend parsec yet
22:22:21 <carter> yes
22:22:37 <carter> johnw he's just collected 6months-2 years of reading in computational math
22:22:40 <johnw> my favorite parsing book of all time was Holub's "Compiler Design in C", which sadly is out of print
22:22:43 <carter> we dont need to add more on top :)
22:23:11 <carter> johnw ooo, btw, sclv pointed out a C-- like would be a good quasiquoter notation for generating LLVM IR AST fragments
22:23:22 <johnw> and you know you've read a book thoroughly when you've built up a list of corrections to send back to the author :)
22:23:30 <carter> hehe
22:23:32 <carter> neat
22:23:37 <AsgardBSD> i cant find a book named parsec
22:23:43 <carter> AsgardBSD google parsec
22:23:45 <carter> its a library
22:23:48 <johnw> AsgardBSD: parsec is a library, that comes with an excellent manual
22:23:51 <tac> Does anyone have any ideas why running cabal install cabal-install doesn't prevent the message "There is a new version of cabal install, use cabal install cabal-install to upgrade it"?
22:23:52 <AsgardBSD> from what i found parsec is a library, not a book
22:24:06 <carter> tac cabal install cabal ; cabal install cabal-install
22:24:08 <carter> AsgardBSD yes
22:24:08 <Ralith> johnw: I found the manual rather lacking; was I looking in the wrong place?
22:24:09 <carter> we know
22:24:12 <johnw> parsec is what they call a "combinator parsing library".  But it won't really teach you much about parsing  per es
22:24:21 <blackdog> so, printing the typerep of this thing just gives me Timeout
22:24:29 <johnw> Ralith: huh, I quite enjoyed it
22:24:35 <AsgardBSD> im looking for a book that teach theory, algorithm behind simple parser, so i can apply that knowledge to any language/situation
22:24:36 <blackdog> any idea where that might be from?
22:24:40 <carter> blackdog so brep for timeouts in the package
22:24:49 <Ralith> tac: is your package list up to date?
22:24:50 <carter> AsgardBSD the answer is use a parser generator
22:24:55 <tac> yeah
22:24:57 <johnw> http://legacy.cs.uu.nl/daan/download/parsec/parsec.pdf
22:25:02 <johnw> Ralith: that one?
22:25:07 <tac> Ralith: I keep going back and forth between cabal install cabal-install
22:25:08 <carter> AsgardBSD read "sipser theory of computation"
22:25:09 <tac> and cabal update
22:25:17 <tac> just one then the other, then the first again...
22:25:18 <dufflebunk> tac, perhaps you have  two versions installed. One system wide, and one locally. If you then un cabal as a regular user, it might try to only update the local version, not the system wide version?
22:25:19 <carter> tac cabal install cabal
22:25:21 <Ralith> johnw: ah, no, I was indeed looking in the wrong place
22:25:28 <tac> carter: trying it now
22:25:33 <blackdog> carter: i've used it once, but that's System.Timeout - that doesn't have a Timeout datatype
22:25:43 <johnw> AsgardBSD: that link ^^ is the book on parsec
22:26:00 <carter> blackdog so theres no way to grep for all the places its used in your code or the libs you use
22:26:04 <carter> to find where it might be happening?
22:26:28 <johnw> tac: I always do: cabal install Cabal cabal-install
22:26:33 <johnw> never tried without the Cabal part
22:26:57 <carter> johnw i just bootstrap by my own heels using the github repo :)
22:27:06 <carter> cabal 1.17 is looking pretty good
22:27:13 <johnw> yeah, that works too
22:27:23 <johnw> carter: I even have a feature in that version!  waiting for it to be realesed
22:27:34 <carter> johnw me too
22:27:39 <tomboy64> okay
22:27:53 <AsgardBSD> Well, i could use a parser generator
22:27:58 <tomboy64> sum [1..10^11] hogs on 3gig of memory immediately
22:28:02 * tomboy64 slaps his hand
22:28:06 <carter> i think might just say is a commented out  -- hs-source-dirs:
22:28:10 <carter> *my patch
22:28:19 <carter> AsgardBSD given finite time and all of math, good call :)
22:41:01 <carter> egads, i'm trying out the bazqux feed reader and its NICE  http://www.reddit.com/r/haskell/comments/1ha5dd/rss_reader_written_in_haskell_and_urweb/
22:42:25 <Cale> tomboy64: compile your program with -O2 and it won't (but it's still much slower than using the closed form of course :)
22:43:06 <tomboy64> errr closed form?
22:43:14 <tomboy64> Cale: errr closed form?
22:43:27 <Cale> sum over k = 1 to n of k is equal to k (k + 1) / 2
22:43:47 <Cale> > 10^11 * (10^11 + 1) `div` 2
22:43:48 <lambdabot>   5000000000050000000000
22:44:10 <tomboy64> holy ... ^^
22:44:18 <tomboy64> there you go
22:44:26 <tomboy64> made me look like a pre-schooler
22:44:42 <tomboy64> thanks for that
22:44:45 <Cale> no problem
22:47:41 <OffsetGoose_> > 666 * 2 + 5
22:47:42 <lambdabot>   1337
22:55:50 <mm_freak_> > 1111111111111111111111111111111111111111111111 `div` 100000000000000000000001
22:55:50 <lambdabot>   11111111111111111111111
22:57:18 <NemesisD> jmcarthur: you still around?
22:59:55 <OffsetGoose_> > 800 * 10000 + 8135
22:59:56 <lambdabot>   8008135
23:00:25 <carter> OffsetGoose_ you should cabal install lambdabot
23:00:31 <carter> soyou can play with it at home :)
23:01:01 <OffsetGoose_> I'm done :P  What's the difference between lambdabot and GHCi?
23:01:24 <carter> ghci isn't sandboxed by default
23:01:51 <carter> so you could could do  runShellStringAsSudo "rm -rf / " or something :)
23:01:57 <carter> or launchNukes
23:01:59 <carter> or something
23:02:02 <OffsetGoose_> Alright, I'll give it a go, thanks mate.
23:02:22 <carter> glad to help
23:03:41 <johnw> I use a local lambdabot, it's quite handy
23:04:14 <dmwit> ...there are a lot bigger differences between lambdabot and ghci than that.
23:04:40 <carter> dmwit whats a good example?
23:04:54 <dmwit> lambdabot has dozens of commands that ghci doesn't have, like ?src, ?djinn, ?instances, etc.
23:04:58 <dmwit> ?index
23:04:58 <lambdabot> bzzt
23:05:04 <dmwit> ?list
23:05:04 <lambdabot> What module?  Try @listmodules for some ideas.
23:05:08 <dmwit> ?listmodules
23:05:08 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap
23:05:08 <lambdabot> source spell system tell ticker todo topic type undo unlambda unmtl version where
23:08:11 <carter> dmwit i still have this idea in my head that lambdabot wont' build from cabal
23:08:17 <carter> but thats no longer true :)
23:11:56 <johnw> it builds quite nicely in fact
23:12:08 <johnw> plus it's nice to have @djinn, @undo, @pl, all nearby when offline
23:25:00 <erisco> not sure exactly what  * -> *  means. Can * be promoted to * -> * ?
23:25:18 <johnw> * -> * is a kind that says it takes a type and yields a type
23:25:27 <johnw> the kind of Maybe is * -> *
23:25:30 <johnw> and the kind of Maybe Int is *
23:25:37 <johnw> Int itself is *
23:25:47 <johnw> so, it is a "type function"
23:26:36 <erisco> so, a type which has one variablr?
23:26:54 <Wizek_> Morning! Is this a good place to ask Elm-related questions?
23:26:55 <johnw> well, I wouldn't say it that way, since I'm not sure what you mean
23:27:02 <erisco> data Foo a
23:27:06 <johnw> right
23:27:07 <erisco> is Foo *-> *?
23:27:10 <johnw> exactly
23:27:32 <johnw> Wizek_: the programming language, or the web-development library?
23:27:43 <erisco> interesting. okay
23:28:03 <Wizek_> johnw, this one: http://elm-lang.org/
23:28:10 <johnw> ah, #elm would be the place
23:30:03 <erisco> johnw, so when you make a type class  Foo a   and write "a n" in a type signature for a function of that type class, you are saying a is * -> * and 'n' is the first *
23:30:19 <johnw> erisco: yep
23:30:23 <erisco> johnw, and this necessarily means you are talking about data types with exactly one type variable?
23:30:35 <johnw> in fact, in modern GHC you can even say "class Foo a :: * -> * where"
23:30:46 <arkeet> you can?
23:30:48 <johnw> yes
23:30:59 <arkeet> I know you can say "class Foo (a :: * -> *) where"
23:31:03 <arkeet> is that what you meant?
23:31:06 <johnw> ah, that's it
23:31:09 <johnw> yes, I haven't used it yet
23:31:18 <Wizek_> johnw, Are you sure? The room description is quite very vague.
23:31:26 <arkeet> it would be nice to be able to say class Foo :: (* -> *) -> Constraint
23:31:28 <johnw> Wizek_: the webpage you linked to mentions #elm
23:31:43 <arkeet> but then there would be no way to mention the argument in the definition
23:32:07 <wleslie> bit of a newbie question, but what does @ mean in a lhs? like f d@(Foo bar baz) = ...
23:32:13 <Wizek_> johnw, You are correct. Thanks!
23:32:19 <johnw> wleslie: it names the arguments
23:32:29 <arkeet> wleslie: same as f d = ..., except also matches d against Foo bar baz
23:32:34 <arkeet> so it's something like
23:32:34 <johnw> foo x@(Foo y@(Bar z@(_ _)))
23:32:38 <arkeet> f d = let Foo bar baz = d in ...
23:32:39 <wleslie> oh excellent
23:32:45 <johnw> this lets me name all the sub-parts of a pattern match
23:33:34 <arkeet> oh, they're called as-patterns.
23:33:35 <johnw> arkeet: what is the name of the extension that allows (a :: * -> *)?
23:33:54 <arkeet> KindSignatures?
23:34:04 <arkeet> anyway, as-patterns are described in http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
23:34:15 <arkeet> if you want to know exactly how they're specified.
23:34:28 <johnw> hmm.. you can say data Foo :: * -> * where
23:34:34 <johnw> maybe that's the syntax I was thinking of
23:34:35 <arkeet> that's also KindSignatures
23:34:35 <wleslie> thanks, I need to go back over that stuff. but for now, it just happens to be the thing I was looking for.
23:34:43 <arkeet> (with GADTs)
23:35:37 <johnw> http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/other-type-extensions.html
23:35:44 <johnw> that lists all the places where explicit kinds are allowed
23:38:26 <erisco> what does a free type variable mean in a type class?
23:38:31 * hackagebot shelly 1.3.0.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.3.0.1 (GregWeber)
23:38:39 <erisco> class Foo a where blah :: a -> x
23:38:41 <erisco> for example
23:38:50 <johnw> I think it means the x, doesn't it?
23:39:03 <erisco> what is 'x'? it is determined by the instance?
23:39:09 <johnw> it's determined by use of blah
23:39:20 <erisco> okay, not following
23:39:32 <johnw> ok, so, x is a free variable which means its type cannot be known
23:39:42 <johnw> so all blah can do is return something which carries no information about what it is
23:39:46 <johnw> more likely you'd have this:
23:39:47 <erisco> but when I instance the class, and give a definition to blah...
23:39:54 <johnw> blah :: Show x => a -> x
23:40:12 <johnw> now blah returns something that is Show'able, although the caller of blah will never know what that x is
23:40:39 <johnw> you can't define blah :: a -> x without using something like unsafeCoerce, or returning undefined, or not returning at all
23:40:46 <erisco> so you're saying the free variable cannot be satisfied without a constraint?
23:41:16 <johnw> if we're talking about a subset of Haskell where you never used undefined or unsafe functions, then yes
23:41:30 <johnw> how would you create a value of x, when nobody knows anything about x (not even you)
23:41:47 <erisco> I was imagining it would be defined by the instance
23:41:49 <erisco> but I suppose not then
23:41:58 <johnw> the instance only establishes a type for a
23:42:01 <mikeplus64> anyone with a new ghc know if +/* work in GHC.TypeLits yet?
23:42:05 <johnw> the free variable is free, unbound
23:42:22 <mikeplus64> so you can do e.g. fromSing (sing :: Sing (10 * 10)) and get 100
23:43:09 <NemesisD> how would i tell if a list is a subset of another?
23:43:18 <erisco> hm. okay then
23:43:31 * hackagebot threadmanager 0.1.6 - (deprecated in favor of 'threads') Simple thread management  http://hackage.haskell.org/package/threadmanager-0.1.6 (BrianLewis)
23:43:45 <erisco> can I define a function to return a type and use that in type signatures? :)
23:43:50 <johnw> NemesisD: all you knows is that it's [a], and you want to know if the particular value that you have is presently a member of some [[a]]?
23:44:10 <johnw> erisco: that would require a dependently typed language, for example
23:44:27 <johnw> erisco: in Agda, Idris, Coq, you could do just that
23:44:47 <NemesisD> johnw: not just membership but subset, meaning ys must contain all elements of xs, including duplicates
23:45:24 <johnw> do you mean, you want to know if your [a] is a subset of another [a]?
23:45:30 <NemesisD> johnw: exactly
23:45:37 <NemesisD> i could do it the hard way with a recursive function
23:45:48 <johnw> see if the difference is empty
23:46:03 <johnw> > [1,2,3] \\ [1,2,3,4,5]
23:46:03 <lambdabot>   []
23:46:09 <johnw> > [1,2,3] \\ [1,2,4,5]
23:46:10 <lambdabot>   [3]
23:46:32 <OffsetGoose_> > [1..] \\ [2..]
23:46:37 <lambdabot>   mueval-core: Time limit exceeded
23:46:46 <OffsetGoose_> Aw :-(
23:47:11 <OffsetGoose_> That makes sense though, it only stops evaluating when one list is empty.
23:47:18 <johnw> OffsetGoose_: if it depended on sorted order, that could work
23:47:27 <OffsetGoose_> > [1..5] \\ [3..]
23:47:31 <lambdabot>   mueval-core: Time limit exceeded
23:47:37 <OffsetGoose_> WHat?
23:47:48 <NemesisD> johnw: ah i tried that i thought, im not sure why i didn't think that worked
23:47:50 <johnw> well, it would know that 1 is not in the second set right away
23:47:59 <johnw> so it could lazily return a list of difference values, if it knew both were sorted
23:48:03 <OffsetGoose_> > [3..] \\ [1..5]
23:48:04 <lambdabot>   [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,...
23:48:13 <OffsetGoose_> Odd...
23:48:19 <OffsetGoose_> Let me check (\\)
23:48:30 <johnw> @src (\\)
23:48:30 <lambdabot> (\\) = foldl (flip delete)
23:49:14 <OffsetGoose_> Ohh, foldl
23:49:32 <OffsetGoose_> > let test = 0
23:49:33 <lambdabot>   not an expression: `let test = 0'
23:49:39 <johnw> @let test = 0
23:49:41 <lambdabot>  Defined.
23:49:46 <OffsetGoose_> > test
23:49:50 <lambdabot>   mueval-core: Time limit exceeded
23:49:55 <OffsetGoose_> ?
23:49:58 <johnw> that's odd
23:50:02 <johnw> @type test
23:50:02 <lambdabot> Integer
23:50:05 <wleslie> > show test
23:50:09 <lambdabot>   mueval-core: Time limit exceeded
23:50:16 <OffsetGoose_> Wtheck?
23:50:34 <johnw> lambdabot is not perfect :(
23:51:00 <wleslie> > 0
23:51:01 <lambdabot>   0
23:51:25 <OffsetGoose_> @let string = "mystring"
23:51:26 <lambdabot>  Defined.
23:51:34 <OffsetGoose_> > @string
23:51:35 <lambdabot>   <hint>:1:1: parse error on input `@'
23:51:37 <johnw> btw, you can /msg lambdabot
23:51:43 <johnw> or /query him, and play to your heart's desire
23:52:01 <johnw> even cabal install him!
23:52:01 <OffsetGoose_> Oh, hehe good idea, thanks :)
23:52:16 <OffsetGoose_> I tried that, it says he's already installed?
23:52:25 <johnw> type "lambdabot" at the shell
23:52:45 <ion> â€œhimâ€?
23:53:11 <johnw> ion: granted, it's questionable
23:53:31 <OffsetGoose_> Her?  It?  Them o_o
23:54:29 <wleslie> I don't think e's offended either way
23:55:27 <ion> lambdabot is female.
23:55:37 <Gracenotes> ze/zir
23:56:22 <dmwit> > string
23:56:25 <lambdabot>   "mystring"
23:56:27 <dmwit> > test
23:56:30 <lambdabot>   0
23:56:35 <dmwit> just have to have magic fingers
23:57:19 <johnw> dmwit: apparently!
