00:01:28 <johnw> > let xs = [1,2,3,4] in zipWith (+) xs (tail xs)
00:01:29 <lambdabot>   [3,5,7]
00:01:34 <johnw> > let xs = [1,2,3,4,5] in zipWith (+) xs (tail xs)
00:01:35 <lambdabot>   [3,5,7,9]
00:02:46 <Aetherspawn> > (\f xs -> map (\x -> map (x) xs) (map f xs)) (,) [1..5]
00:02:47 <lambdabot>   [[(1,1),(1,2),(1,3),(1,4),(1,5)],[(2,1),(2,2),(2,3),(2,4),(2,5)],[(3,1),(3,...
00:02:55 <Aetherspawn> Now to reduce that, hehe :)
00:03:07 <johnw> i'm not clear about what you want anymore
00:03:21 <Aetherspawn> Notice (,) gets applied to all permutations of the list
00:03:32 <Aetherspawn> @pl (\x -> map (x) xs)
00:03:33 <lambdabot> flip map xs
00:03:41 <johnw> why not use the list monad then?
00:03:51 <johnw> for the list [1,2], what result do you want?
00:04:57 <Aetherspawn> [f [1,1],f [1,2],f [2,1],f [2,2]]
00:05:10 <Aetherspawn> (I just realised my solution was wrong) :[
00:05:26 <johnw> > let xs = [1,2] in do { x <- xs; y <- xs; return $ f  x y }
00:05:27 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
00:05:28 <lambdabot>    arising from a us...
00:05:39 <johnw> or do it with a list comprehension
00:06:10 <Aetherspawn> > permutations [1..3]
00:06:11 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
00:06:23 <johnw> > permutations [1..2]
00:06:24 <lambdabot>   [[1,2],[2,1]]
00:06:35 <Aetherspawn> aw.
00:06:48 <Aetherspawn> @src permutations
00:06:49 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
00:06:59 <Aetherspawn> lambdabot is rude nowadays.
00:07:20 <rgrinberg> has anybody delivered cookie cutter CRUD with snap or yesod in the real world yet?
00:07:46 <johnw> what is cookie cutter CRUD?
00:08:11 <rgrinberg> stuff that you'd normally use django or rails for
00:08:22 <johnw> can you be more specific?
00:08:34 <blackdog> Aetherspawn: used to be ruder before @vixen got excised
00:08:47 <johnw> > let xs = [1,2] in [ f x y | x <- xs, y <- xs ]
00:08:48 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr t0)
00:08:48 <lambdabot>    arising from a us...
00:08:53 <johnw> > let xs = [1,2] in [ x + y | x <- xs, y <- xs ]
00:08:54 <lambdabot>   [2,3,3,4]
00:09:02 <johnw> Aetherspawn: I think that's what you're asking for
00:09:20 <Aetherspawn> yes, it is.
00:09:23 <Aetherspawn> Can lambdabot unsugar it
00:09:37 <johnw> what is wrong with its form?
00:09:45 <augur> (+) <$> xs <*> xs
00:09:46 <augur> :D
00:09:47 <Aetherspawn> I want to see how to do it without comprehensions
00:09:52 <johnw> augur: thank you!
00:09:58 <augur> thats not unsugared tho
00:10:06 <johnw> > let xs = [1,2] in (+) <$> xs <*> xs
00:10:07 <augur> Aetherspawn: how much desugaring do you want for that
00:10:07 <lambdabot>   [2,3,3,4]
00:10:18 <Aetherspawn> preferrably just folds, flips, maps etc
00:10:18 <johnw> i always forget about the list applicative
00:10:24 <Aetherspawn> ;__;
00:10:24 <johnw> Aetherspawn: why?
00:10:31 <augur> Aetherspawn: well you'll have to use bind at least
00:10:47 <augur> xs >>= \x -> xs >>= \y -> return (x + y)
00:10:54 <augur> > let xs = [1,2] in xs >>= \x -> xs >>= \y -> return (x + y)
00:10:55 <lambdabot>   [2,3,3,4]
00:11:20 <augur> you can further evaluate (>>=) and return for lists tho
00:11:29 <augur> so that becomes, well..
00:11:33 <johnw> isn't it mapConcat?
00:11:38 <arkeet> no, it's concatMap
00:11:42 <johnw> ah, that's what I meant
00:11:43 <arkeet> ;)
00:11:59 <arkeet> x >>= f = concat (map f x)
00:12:00 * hackagebot hack2-contrib 2013.6.15 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2013.6.15 (JinjingWang)
00:12:02 <augur> concat (map (\x -> concat (map (\y -> [x+y]) xs)) xs)
00:12:18 <augur> arkeet: technically, x >>= f == join (fmap f x)
00:12:25 <augur> concat and map are list specific
00:12:40 <augur> Aetherspawn: map and concat are both instances of fold
00:12:42 <arkeet> augur: this is how the [] monad instance is.
00:12:48 <glguy> > ( \xs -> foldr (\x rest -> foldr (\y xs -> x + y : xs) rest xs) [] xs) [1..3]
00:12:48 <arkeet> defined.
00:12:49 <augur> arkeet: yes
00:12:49 <lambdabot>   [2,3,4,3,4,5,4,5,6]
00:13:17 <augur> Aetherspawn: map f xs = fold (\x xs' -> f x : xs) [] xs
00:13:24 <augur> er, foldr
00:13:43 <augur> Aetherspawn: concat xs = foldr (\xs xss -> xs ++ xss) [] xs
00:13:53 <glguy> Aetherspawn: how's that?
00:14:13 <arkeet> concat = foldr (++) []
00:14:16 <arkeet> :c
00:14:21 <augur> arkeet: that too :)
00:14:35 <johnw> I'm not sure there's much value for anyone in us doing this expansion for him
00:14:41 <augur> @unmtl [x+y | x <- xs, y <- xs]
00:14:41 <lambdabot> Plugin `unmtl' failed with: Parse error: |
00:14:43 <arkeet> I don't know what we're doing.
00:14:47 <augur> @unmtl [ x+y | x <- xs, y <- xs ]
00:14:47 <lambdabot> Plugin `unmtl' failed with: Parse error: |
00:14:54 <augur> well i guess unmtl doesnt like comprehensions
00:15:03 <johnw> I do appreciate the list applicative reminder; I need to write that on my hand or something
00:15:06 <glguy> did you mean "undo"
00:15:11 <glguy> not that it likes them any better
00:15:15 <zRecursive> @undo [ x+y | x <- xs, y <- xs ]
00:15:16 <lambdabot> concatMap (\ x -> concatMap (\ y -> [x + y]) xs) xs
00:15:20 <glguy> but unmtl is about unwrapping mtl types
00:15:21 <arkeet> heh.
00:15:33 <augur> @unmtl concatMap (\ x -> concatMap (\ y -> [x + y]) xs) xs
00:15:33 <lambdabot> Plugin `unmtl' failed with: Parse error: \
00:15:36 <augur> :|
00:15:37 <arkeet> I didn't know @undo could do that.
00:15:42 <augur> oh maybe its not unmtl im thinking of
00:15:54 <arkeet> @unmtl StateT s (Reader r a)
00:15:55 <lambdabot> Plugin `unmtl' failed with: `StateT s (Reader r a)' is not applied to enough arguments, giving `/\A. s -> (Reader r a) (A, s)'
00:15:55 <augur> whats that thing that gives you points-free code
00:16:01 <arkeet> @unmtl StateT s (Reader r) a
00:16:02 <lambdabot> s -> (Reader r) (a, s)
00:16:07 <arkeet> uh
00:16:14 <johnw> augur: @pl?
00:16:16 <augur> oh thats it
00:16:23 <augur> @pl [ x + y | x <- xs, y <- xs ]
00:16:23 <lambdabot> [x + y | x <- xs, y <- xs]
00:16:25 <augur> :|
00:16:26 <johnw> :)
00:16:28 <augur> THANKS LAMBDABOT
00:16:37 <augur> @pl concatMap (\ x -> concatMap (\ y -> [x + y]) xs) xs
00:16:37 <lambdabot> (xs >>=) . flip flip [] . ((:) .) . (+) =<< xs
00:16:41 <augur> bwahaha
00:16:41 <johnw> well, poor lambdabot is just using the pointfree library
00:17:00 * hackagebot hack2-contrib 2013.6.15.1 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2013.6.15.1 (JinjingWang)
00:17:08 <augur> shame aetherspawn is gone :D
00:17:16 <augur> !
00:17:18 <augur> Aetherspawn:
00:17:21 <augur> @pl concatMap (\ x -> concatMap (\ y -> [x + y]) xs) xs
00:17:21 <lambdabot> (xs >>=) . flip flip [] . ((:) .) . (+) =<< xs
00:17:28 <Aetherspawn> Yeah. my net died.
00:17:29 <Aetherspawn> thanks
00:17:37 <augur> Aetherspawn: but no, thats garbage that is
00:17:45 <augur> Aetherspawn: why are you looking for stuff just in terms of fold, map, etc.?
00:17:50 <Aetherspawn> concatMap (\ x -> concatMap (\ y -> [x + y]) xs) xs is nice.
00:17:59 <Aetherspawn> concatMap is in prelude and I can understand it easily
00:18:09 <augur> Aetherspawn: whats tricky about comprehensions?
00:18:12 <johnw> you understand that better than the list comprehension form??
00:18:17 <zRecursive> @ty concatMap
00:18:18 <lambdabot> (a -> [b]) -> [a] -> [b]
00:18:25 <Aetherspawn> The list comprehension form I understood
00:18:29 <augur> zRecursive: concatMap = concat . map
00:18:33 <arkeet> not quite
00:18:35 <augur> well
00:18:43 <augur> (concat.).map
00:18:45 <Aetherspawn> I just wanted to know how to do it without comprehensions
00:18:46 <arkeet> :)
00:18:50 <zRecursive> @ty concat . map
00:18:51 <lambdabot>     Couldn't match type `[a1] -> [b0]' with `[[a0]]'
00:18:51 <lambdabot>     Expected type: (a1 -> b0) -> [[a0]]
00:18:51 <lambdabot>       Actual type: (a1 -> b0) -> [a1] -> [b0]
00:18:59 <arkeet> what was the original goal?
00:19:04 <augur> Aetherspawn: write it by hand!
00:19:15 <augur> multiplyThem f xs = ...
00:19:26 <arkeet> [ x + y | x <- xs, y <- xs ] without list comprehension?
00:19:27 <augur> well, apply them, not multiply
00:19:29 <arkeet> liftA2 (+) xs ys
00:19:40 <augur> arkeet: i suggested (+) <$> xs <*> xs
00:19:46 <zRecursive> augur: concatMap /= concat . map
00:19:48 <arkeet> I prefer liftA2.
00:20:00 <johnw> liftA2 (+) xs xs is indeed shorter
00:20:02 <augur> zRecursive: i think you'll find it is (concat .) . map, as i corrected myself :P
00:20:10 <augur> arkeet: agreed
00:20:17 <augur> arkeet: tho ofcourse what we REALLY mean to write is
00:20:23 <augur> {| (+) xs xs |}
00:20:28 <augur> or if we're especially sneaky
00:20:32 <augur> {| xs + xs |}
00:20:36 <arkeet> heh
00:20:48 <Aetherspawn> concatMap f = foldr ((++) . f) []
00:21:26 <arkeet> foldr has the wrong argument order :(
00:21:27 <augur> Aetherspawn: fortunately, foldr ((++) . f) [] = concat . map f
00:21:43 <augur> arkeet: ugh i know. i hate haskell's argument order for folds
00:22:06 <Aetherspawn> (\f -> foldl (f:) [] [1..5]) (+1)
00:22:09 <Aetherspawn> > (\f -> foldl (f:) [] [1..5]) (+1)
00:22:10 <lambdabot>   Couldn't match type `[a0 -> a0]' with `b0 -> [a0 -> a0]'
00:22:10 <lambdabot>  Expected type: [a...
00:22:25 <augur> arkeet: the natural order mirrors the types constructor order, which is almost conventionally low-branching number constructors first
00:22:34 <arkeet> yup
00:22:55 <Aetherspawn> > (\f -> foldl (\x -> (f x):) [] [1..5]) (+1)
00:22:55 <augur> arkeet: tho if we'd just use Epigram we'd never need to write folds and maps anyway!
00:22:56 <lambdabot>   <hint>:1:27: parse error on input `)'
00:25:17 <Aetherspawn> Theres an optimization rule that could be applied for concat map here
00:25:29 <augur> Aetherspawn: indeed
00:25:40 <augur> the rule is actually more general, falled map-fold fusion
00:25:50 <Aetherspawn> does it exist?
00:26:00 <augur> foldr f z (map g xs) = foldr (f . g) z xs
00:26:11 <augur> or something roughly like that
00:26:16 <Aetherspawn> Do you know C?
00:26:26 <augur> and yes, it does exist, haskell has lots of optimizations that take place prior to compilation
00:26:55 <arkeet> there's even a more general version of that rule :c
00:26:57 <augur> i think there's also fold-fold fusion? or whatever. there are a lot of papers on these things
00:27:00 <arkeet> yeah
00:27:23 <arkeet> http://eprints.nottingham.ac.uk/224/01/fold.pdf
00:27:43 <augur> theres a paper on builder fusion somewhere
00:27:48 <Aetherspawn> should be able to be optimized to this: http://hpaste.org/89947
00:27:56 <Aetherspawn> sorry I can't haskell well enough to show it
00:28:16 <johnw> that's *still* not the same as your requirements above
00:28:28 <augur> Aetherspawn: thats a different thing entirely tho
00:28:28 <Aetherspawn> I think it is
00:28:33 <Aetherspawn> Let me test.
00:28:45 <augur> Aetherspawn: also in general that wont work
00:29:05 <augur> the problem is that foldr works from the tail of the list
00:29:18 <johnw> your C code does this: [ (x + y, y + x) | x <- xs, y <- tail xs ]
00:29:40 <augur> the optimization also only works when the operation, in this case, +, has certain properties
00:29:53 <augur> notice that x + (y + z) == (x + y) + z
00:30:09 <johnw> or rather: concat [ [x + y, y + x] | x <- xs, y <- tail xs ]
00:30:27 <augur> because of this, you can change a whole bunch of stuff around and get that optimization, or things like it, as valid
00:31:12 <Aetherspawn> It's indeed permutations and not what I was looking for
00:31:15 <augur> anyway, these optimizations wouldnt need to exist if the LC were the machine language
00:31:15 <Aetherspawn> thanks for correcting me.
00:31:32 <augur> which, i would add, it COULD be
00:31:41 <augur> but you'd need lots of registers
00:31:42 <Aetherspawn> (output: http://hpaste.org/89948 )
00:34:20 <Aetherspawn> augur, that should be expected of a pure function mapped to permutations
00:34:31 <augur> Aetherspawn: what?
00:34:42 <Aetherspawn> the x + (y + z) == (x + y) + z thing
00:34:59 <augur> Aetherspawn: im not sure what you mean tho
00:35:52 <Aetherspawn> Uh, what I mean is, I think that it only matters if the mapping depends on the order that the permutations are produced
00:36:03 <Aetherspawn> so it'd be a monad or something, so it'd be through mapM not map ?
00:36:49 <augur> Aetherspawn: what i was saying there is that the optimization you suggest is available because of specific properties of the combining operation (+)
00:37:13 <augur> Aetherspawn: an equivalent loop operation isn't so obvious if you used (-): [ x - y | x <- xs, y <- ys ]
00:37:32 <augur> well tho i guess for this particular thing it is
00:38:11 <augur> anyway my broader point is that some optimizations are non-generic
00:38:46 <augur> map-fold fusion just works. every time, no matter what, its true that   foldr f z . map g   ==   foldr (f . g) z
00:39:14 <augur> but for lots of other optimizations, you need to know something about f or z or g or whatever, for example
00:39:42 <augur> for instance,   foldr f z == foldl f z   if (f,z) form a monoid
00:40:44 <Aetherspawn> ok
01:00:54 <hoyang> hi. any one want to learn Chinese?
01:01:15 <hoyang> Â§ßÂì•Â§ßÂßê‰ª¨„ÄÇ
01:02:18 <Aetherspawn> elliott, wanna learn chinese? ^
01:02:43 <Dtgr> hoyang: didn't help. still don't know chinese
01:04:08 <hoyang> ÂïäÂìàÔºåchinese is NOT helpful for Haskell or any other programming language. but it is funny.
01:04:40 <Aetherspawn> I cant see the unicode
01:35:34 <notdan> http://hpaste.org/89949 Hi! Can somebody help me out with GHC API and exception handling? For some reason if I have some sort of error in a module that I am loading, it still prints the error to the stdin
01:35:45 <notdan> even tho I've set up the handlers properly
01:49:30 <osa1> where can I learn about linking C libraries to haskell programs packaged with Cabal?
02:25:19 <osa1> is there a way to run Cabal in 'verbose' mode to see what compiler commands does it call?
02:25:36 <Heffalump> -v3
02:27:24 <osa1> great, thanks
02:29:02 <merijn> @remember DavidJacobs Code is like poetry; most of it shouldn't have been written.
02:29:02 <lambdabot> I will never forget.
02:30:57 <notdan> http://www.haskell.org/pipermail/haskell-cafe/2013-June/108751.html
02:42:07 * hackagebot Workflow 0.8.0.6 - Workflow patterns over a monad for thread state logging & recovery  http://hackage.haskell.org/package/Workflow-0.8.0.6 (AlbertoCorona)
02:52:59 <dormi> hello, couple of Yi-questions: I couldn'f figure out how to synchronously compose YiM-s: two "promptFile" - prompt second filename and after first
02:53:40 <dormi> and is there a way to run custom "hooks" on current-buffer-change (use case toggle cursor color depending on top/insert mode)?
02:56:24 <ramses_> dormi: maybe try #yi
02:56:35 <Lethalman> ok so I want to do a difference between (Int, Int) and (Int, Int)
02:56:51 <Lethalman> diff (x,y) (x',y') = ...
02:57:04 <Lethalman> that's trivial
02:57:09 <Lethalman> anyway I was thinking of (***)
02:57:29 <dormi> ramses_:  already tried, but there are no many haskellers and unfortunately no response
02:58:02 <Lethalman> so something like diff (x,y) p = ((x-) *** (y-)) p
02:58:20 <dormi> Lethalman: NumInstances?
02:59:04 <Lethalman> dormi, good to know thnaks
02:59:54 <Lethalman> anyway continuing my thing, how can I transform (x,y) into (x-) *** (y-) uhm, let me think
03:00:00 <Lethalman> as an exercise
03:00:05 <structuralist> Hi, I really don't know where to ask this question but I'm hoping some of you guys would know‚Ä¶ is there some connection between terminal coalgebras and universal Turing machines? They both seem to have the property of being like systems that can simulate all other systems of their type.
03:00:57 <Lethalman> is tuple an instance of functor? how can I check?
03:01:07 <Lethalman> err no (Int, Int) should be
03:01:25 <mauke> wrong kind
03:01:31 <nithp> Lethalman, in ghci => :i ()
03:01:34 <Kneiva> > :i (,)
03:01:35 <lambdabot>   <hint>:1:1: parse error on input `:'
03:01:40 <Kneiva> > i (,)
03:01:42 <lambdabot>   Couldn't match expected type `(a0 -> b0 -> (a0, b0)) -> t0'
03:01:42 <lambdabot>              wi...
03:01:43 <mauke> in ghci
03:01:55 <Kneiva> woot
03:02:09 <Kneiva> data (,) a b = (,) a b 	-- Defined in `GHC.Tuple'
03:02:09 <Kneiva> instance (Bounded a, Bounded b) => Bounded (a, b) -- Defined in `GHC.Enum'
03:02:09 <Kneiva> instance (Eq a, Eq b) => Eq (a, b) -- Defined in `GHC.Classes'
03:02:09 <Kneiva> instance Functor ((,) a) -- Defined in `GHC.Base'
03:02:11 <osa1> wow. I'm reading a code that changing `return undefined` to `undefined` makes it crash. interesting ...
03:02:40 <simukis_> Why doesn't Data.Map.fromList [("html", undefined)] typecheck as value for http://hackage.haskell.org/packages/archive/snap-core/0.4.2/doc/html/Snap-Util-FileServe.html#v:dynamicHandlers?
03:03:15 <shachaf> simukis_: I don't know, but I bet you know.
03:04:34 <shachaf> You have a big informational advantage over us, namely, you know what code you wrote and what error you got.
03:04:42 <Lethalman> Kneiva, so (,) a is a functor
03:04:54 <Lethalman> yeah
03:05:45 <Lethalman> :t (+3) <$> (2,3)
03:05:46 <dormi> Lethalman: but over second value (simple writer), there is also lens with "both" combinator
03:05:46 <lambdabot> (Num b, Num t) => (t, b)
03:05:51 <Lethalman> ah
03:06:41 <ramses_> Lethalman: you can use the bifunctor package and use something like "join bimap" to get a ""(a -> b) -> (a, a) -> (b, b)"
03:09:07 <Lethalman> ramses_, uhm
03:09:29 <Lethalman> but I'd like two different functions to be applied
03:09:42 <ramses_> ah, then don't join :)
03:09:45 <Lethalman> :t ((-) *** (-))
03:09:46 <lambdabot> (Num a, Num a1) => (a, a1) -> (a -> a, a1 -> a1)
03:10:00 <ramses_> :t bimap
03:10:00 <lambdabot> Not in scope: `bimap'
03:10:20 <ramses_> you could pass that to "curry bimap", I'd think
03:11:37 <Lethalman> right, can't go anywhere
03:12:17 <Lethalman> or...
03:12:50 <simukis_> shachaf: I got it üòä Was looking at ancient documentation here.
03:13:20 <shachaf> simukis_: OK. You can still treat this as a learning opportunity on how to ask questions. :-)
03:13:21 <simukis_> shachaf: and thanks for reminding to post the code. I noticed the problem just before pressing a submit üòä
03:15:24 <Lethalman> :t ((-) *** (-)) (2,3)
03:15:25 <lambdabot> (Num a, Num a1) => (a -> a, a1 -> a1)
03:15:36 <Lethalman> ok now I have to feed another tuple, I can do it
03:22:09 <Lethalman> @pf \x -> x 4
03:22:09 <lambdabot> Maybe you meant: pl bf
03:22:14 <Lethalman> @pl \x -> x 4
03:22:14 <lambdabot> ($ 4)
03:22:36 <Lethalman> :t (($ 4) *** ($ 5))
03:22:36 <lambdabot> (Num a, Num a1) => (a -> b, a1 -> b1) -> (b, b1)
03:22:52 <Lethalman> :t (($ 4) *** ($ 5)) (((-) *** (-)) (2,3)
03:22:52 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
03:22:55 <Lethalman> :t (($ 4) *** ($ 5)) (((-) *** (-)) (2,3))
03:22:56 <lambdabot> (Num a, Num a1) => (a, a1)
03:23:06 <Lethalman> ok now how do I take out 4 and 5 from there :P
03:24:31 * zRecursive function combination sometimes make code VERY ugly 
03:25:04 <Kaidelong> what is the difference between "co-recursion" and induction?
03:25:35 <isBEKaml> Who do I talk to about building Haskell Platform on windows?
03:28:04 <isBEKaml> I'm currently running the build on my 64 bit machine and I may need some help when I get stuck :-)
03:28:11 <Kaidelong> umm best I can tell you right now is to ask on both the haskell-cafe mailing list and on stackoverflow.com, I don't know any specific person to point to
03:28:25 <Kaidelong> dons may well know who to talk to
03:28:44 <Kaidelong> and if you post in one of those places he might see it and tell you
03:28:49 <shachaf> Asking on both would be rude.
03:29:01 <Kaidelong> shachaf: what, why?
03:29:02 <isBEKaml> hmm, there seems to be a haskell-platform mailing list - I guess I'll post there.
03:29:40 <shachaf> mzero would surely know whom to talk to.
03:29:45 <isomorphic> Anybody around who works with c2hs?
03:29:55 <isBEKaml> shachaf: ah, right - mzero. Thanks!
03:30:31 <isBEKaml> shachaf: I was actually looking at his commits on haskell-platform repository. :-)
03:33:14 <Lethalman> why is: (($ 1) *** ($ 2)) different than ((flip $) *** (flip $)) (1,2)
03:33:19 <Lethalman> :t (($ 1) *** ($ 2))
03:33:20 <lambdabot> (Num a, Num a1) => (a -> b, a1 -> b1) -> (b, b1)
03:33:36 <Lethalman> :t ((flip $) *** (flip $)) (1,2)
03:33:37 <lambdabot> (Num (a -> b -> c), Num (a1 -> b1 -> c1)) => (b -> a -> c, b1 -> a1 -> c1)
03:34:30 <Lethalman> mh right
03:34:58 <Lethalman> @pl \x y -> (($ x) *** ($ y))
03:35:01 <lambdabot> flip ((.) . (***) . flip ($)) (flip ($))
03:35:01 <lambdabot> optimization suspended, use @pl-resume to continue.
03:35:10 <Lethalman> @pl-resume
03:35:16 <lambdabot> flip ((.) . (***) . flip ($)) (flip ($))
03:35:16 <lambdabot> optimization suspended, use @pl-resume to continue.
03:35:20 <Lethalman> :P
03:35:42 <shachaf> Are you trying to make your life complicated or something?
03:35:46 <generic> you can also /msg lambdabot
03:35:47 <Lethalman> shachaf, yes
03:35:48 <Lethalman> :P
03:35:55 <Lethalman> generic, but then nobody helps me :P
03:36:13 <ramses_> Lethalman: the bimap approach I suggested before works pretty good (although if not for the sake of it, I would write that function pointfull)
03:36:14 <Lethalman> @pl \(x, y) -> (($ x) *** ($ y))
03:36:17 <lambdabot> ap (flip ((.) . (***) . flip ($)) (flip ($)) . fst) snd
03:36:17 <lambdabot> optimization suspended, use @pl-resume to continue.
03:36:37 <isBEKaml> Lethalman: Careful! your puns are getting lethal. :)
03:36:39 <shachaf> Helps you with what?
03:36:48 <Lethalman> ok i'm almost there
03:37:02 <shachaf> If there was a question I missed it amidst all the lambdabot spam.
03:37:52 <Lethalman> @pl \(x,y) (x',y') -> (x-y, x'-y')
03:37:52 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip (-) . (((.) . (.) . (,)) .) . (-))
03:37:55 <Lethalman> this one!
03:38:06 <FreeFull> @pl \(x,y) p -> ((x-) *** (y-)) p
03:38:06 <Lethalman> except with ***
03:38:09 <lambdabot> ap (flip ((.) . (***) . (-)) (-) . fst) snd
03:38:09 <lambdabot> optimization suspended, use @pl-resume to continue.
03:40:12 <ramses_> uncurry bimap . (join (***) (-)) works
03:41:53 <typoclass> Lethalman: i think it's not going to get any clearer than "\(x,y) (x',y') -> (x-y, x'-y')". or "let reduce f (x,y) (x',y') = (f x y, f x' y') in reduce (-) ..."
03:42:20 <Lethalman> typoclass, of course
03:42:21 <Lethalman> :-)
03:42:56 <simon> typoclass, then you are overlooking the idiom of uncurry-flip-flip-second-ap-flip-flip-fst!
03:43:03 <typoclass> simon: =)
03:43:38 <Lethalman> :t \f (x,y) (x',y') -> (f x y, f x' y')
03:43:39 <lambdabot> (t -> t1 -> t2) -> (t, t1) -> (t, t1) -> (t2, t2)
03:43:51 <Lethalman> @hoogle (t -> t1 -> t2) -> (t, t1) -> (t, t1) -> (t2, t2)
03:43:51 <lambdabot> Data.Array.IArray accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
03:43:52 <lambdabot> Data.Array.IArray accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
03:43:57 <Lethalman> ok stop
03:43:59 <Lethalman> :-)
04:27:12 * hackagebot cabal2nix 1.52 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.52 (PeterSimons)
04:54:01 <BitPuffin> Heyo! :D
04:54:04 <BitPuffin> I'm learning haskell
04:55:15 <Kaidelong> BitPuffin, out of curiousity, any particular reason?
04:55:20 <notdan> hi
04:56:21 <BitPuffin> Kaidelong: well a few. But it started with curiosity I guess. And also that I want to try using xmonad
04:56:58 <Kaidelong> Mm, neither of those really inspire much optimism in me for sticking to it for the long haul but hopefully you do enjoy it
04:57:21 <Kaidelong> (unless you're already using xmonad and enjoying it and want to learn to extend it, I guess)
04:57:36 <elliott> no need to demoralise beginners, I think...
04:57:48 <Kaidelong> Not meaning to demoralize, sorry if I did
04:57:57 <BitPuffin> Kaidelong: Well I also might write a webapp with yesod
04:58:34 <BitPuffin> or two
04:59:31 <Kaidelong> ah yes, it's not just haskell that is doing well on the web dev front in terms of attracting new attention
05:00:22 <Kaidelong> in fact I suppose that is entirely what made Ruby
05:00:45 <BitPuffin> is haskell doing well in that area?
05:01:06 <BitPuffin> I didn't think many was using it for that. But it seemed like it was well suited for the usecase
05:01:12 <aristid> BitPuffin: there certainly are quite a few people using haskell for web dev stuff.
05:01:15 <Kaidelong> any time you're attracting fresh users and their ideas it's a good thing
05:01:18 <elliott> I think a lot of the commercial use of Haskell is web dev
05:01:21 <hpc> BitPuffin: take a look at happstack, snap, and yesod
05:01:46 <Kaidelong> F#, Scala, and Erlang have all also gotten a boost due to web dev I believe
05:02:30 <Kaidelong> due to similar libraries being made for them
05:03:47 <FreeFull> F# has .NET behind it, Scala has Java, Erlang has good concurrency
05:04:06 <BitPuffin> hpc: I'm currently looking at yesod
05:04:58 <BitPuffin> hpc: not really for any particular reason, it seemed to be the most popular
05:05:40 <Kaidelong> Mm, I thought that was Happstack?
05:05:55 <Kaidelong> as far as I remember Yesod is the most sophisticated in terms of its underlying design
05:06:44 <Kaidelong> happstack had a lot of existing work done in it and extensions, and snap was supposed to be very easy to deploy and work with
05:06:58 <BitPuffin> Kaidelong: well it was the only one that showed up on explore in github haha. And it seemed very active
05:08:10 <hpc> i haven't used yesod and snap much
05:08:23 <hpc> but my understanding is that they are much more "framework-y" than happstack
05:08:31 <hpc> which is really a collection of libraries
05:09:46 <Kaidelong> As I recall Yesod was something of an experiment with using the haskell type system to put static checking into web development
05:10:27 <Kaidelong> which, as far as I know, isn't something web developers generally get much of with existing tools, so I guess that's kind of exciting
05:11:37 <BitPuffin> yeah that is something that seemed really nice about it
05:11:53 <BitPuffin> didn't know the others didn't have that though
05:12:03 <FreeFull> It's nice to avoid injection attacks
05:12:22 <BitPuffin> it seems like I can't install hjsmin
05:12:56 <BitPuffin> with cabal
05:13:52 <Kaidelong> BitPuffin again out of curiousity, what other languages have you played with?
05:14:08 <BitPuffin> Kaidelong: Uh quite a few
05:14:56 <BitPuffin> Java, C++, C, D, Rust, JavaScript, Ruby, Python I'd say are the major ones
05:15:23 <Kaidelong> Mm, is haskell the first language you're using outside of the imperative paradigm?
05:16:34 <BitPuffin> Kaidelong: I've played slightly with erlang but not much
05:17:11 <BitPuffin> Kaidelong: Some of tha languages though have a bit of functional in them, like D (it even has lazy evaluation!) and Rust
05:17:12 <Kaidelong> ah okay, thanks for sharing with me
05:17:21 <BitPuffin> the*
05:17:51 <BitPuffin> but yes purely functional Haskell is probably the first one I'm looking closer at
05:18:18 <BitPuffin> at first I was gonna continue playing with Erlang, but for some reason I like Haskell a bit better
05:18:31 <Kaidelong> I like haskell's consistent syntax mostly
05:18:51 <BitPuffin> yeah it looks clean
05:18:57 <BitPuffin> compared to erlang I think
05:19:06 <BitPuffin> Erlang is awoseme too but yeah
05:19:17 <BitPuffin> I like Haskell for it's mathyness
05:20:13 <Kaidelong> purely functional as far as I can tell mostly only matters for big giant projects where code has to be maintainable and easy to reason about
05:20:14 <BitPuffin> weird, had to install happy manully to be able to install language-javascript and hjsmin
05:20:44 <BitPuffin> Kaidelong: well my main profession is game development, so haskell seems kind of interesting for that. At least knowing haskell
05:20:48 <Kaidelong> it's analogous to object oriented programming in that regard, perhaps they're just two different approaches to the same problem
05:22:31 <BitPuffin> I'm more interested in Rust for that area though. But maybe haskell is more impressive
05:22:54 <isomorphic> Can anybody point to an example of using function pointers with c2hs?  I've found the generic FFI instructions
05:22:59 <BitPuffin> Kaidelong: well I think pure functional is a better solution. As it also enables concurrency
05:23:33 <Kaidelong> there have been proof of concepts, I think with performance demanding games haskell actually becomes somewhat difficult due to the need to avoid hitting the garbage collector
05:23:46 <Kaidelong> which is possible but heroic
05:25:41 <elliott> well, GHC has a parallel garbage collector
05:25:48 <elliott> and pretty good control over it
05:26:16 <Kaidelong> then again C++ is difficult by default
05:26:22 <BitPuffin> Kaidelong: well from what I've seen it has been good for most things, and where it falls short you could just step down to C
05:26:42 <Kaidelong> so even if you need to do a ton of low level magic in haskell it might still be better than doin gthe whole thing in C++
05:27:21 <hpc> a haskell game can use multiple processors much more effectively than other languages
05:27:38 <AeroNotix> hpc: [citation needed] ?
05:27:41 <hpc> the most you typically see in a game is one logic thread, one rendering thread, and whatever computation is offloaded to the GPU
05:28:11 <hpc> in haskell, you have STM, par/pseq
05:28:26 <Kaidelong> hpc: I found some slides that pretty much said that, perhaps you made them? Title was something like "the next mainstream language for game development"
05:28:31 <FreeFull> The compiler won't automatically make your code parallel/concurrent without asking
05:28:38 <FreeFull> So you do have to put in some effort
05:28:42 <hpc> with carefully applied annotations, you can consume as many threads as the system has
05:28:56 <FreeFull> STM is very nice
05:28:58 <hpc> it takes effort, but it's much easier
05:29:00 <mgsloan> It'd be neat if you could turn off automatic GC / have manual invocation of it.  This'd be particularly awesome if it could be a partial GC - in game loops, you'll end up with a situation where you know you have 7 ms left before you need to start working on the next frame
05:29:06 <hpc> Kaidelong: i think that was carmack
05:29:10 <Kaidelong> FreeFull: In theory, it actually can, though
05:29:13 <FreeFull> Remember to compile with -threaded
05:29:19 <typoclass> AeroNotix: well it was a very broad tendency, same as what Kaidelong said earlier about gc
05:29:20 <hpc> and run with +N
05:29:25 <FreeFull> Kaidelong: The problem is that then it would have to decide on the grain of parallelism
05:29:27 <Kaidelong> just it's so hard to get that right nobody has dared to do that
05:29:36 <FreeFull> And a wrong decision means that your code won't perform as well as it could
05:31:20 <AeroNotix> is there something like "Haskell for Erlang Programmers"
05:31:24 <AeroNotix> reading lyah atm
05:31:28 <Kaidelong> . o O (could a purely functional JITed language exploit profiling at runtime to figure out where to make things parallel? )
05:31:53 <BitPuffin> hpc: no I don't think it was carmack, he did mention haskell in a blog post though about functional programming in c++
05:31:59 <elliott> Kaidelong: sounds like a good opportunity for research.
05:32:06 <elliott> haskell would benefit from JITting in many ways, actually
05:32:21 <Kaidelong> I think MSR is in fact doing work like that with their javascript compiler
05:32:38 <Kaidelong> which the IE team still refuses to use, last I heard, even though it's apparently quite mature now
05:33:49 <hpc> having trident written in F# would be pretty awesome
05:35:35 <Kaidelong> There was a haskell JIT in the past, wasn't there? Think it was called Gopher
05:36:37 <AeroNotix> Hm, haskell gets partial application by default?
05:37:07 <Kaidelong> AeroNotix: If I understand what you mean, yes
05:37:19 <FreeFull> AeroNotix: Yeah, that's why everything is curried
05:37:21 <Kaidelong> application is essentially just a binary relation of a sort like +
05:37:29 <BitPuffin> doesn't GHC compile native code?
05:37:34 <Kaidelong> and it's left associative
05:37:39 <Kaidelong> BitPuffin: Yes
05:37:40 <BitPuffin> Which is better than JIT? or do you guys mean for scripting
05:37:40 <AeroNotix> I mean, just any function call with not enough arguments returns a partial application of the original function?
05:37:43 <Kaidelong> well
05:37:47 <FreeFull> > let x = map (+3) in x [1..5]
05:37:48 <lambdabot>   [4,5,6,7,8]
05:38:03 <Kaidelong> it outputs core, which then gets transformed to a target which can be native code
05:38:08 <FreeFull> :t map (+3)
05:38:09 <lambdabot> Num b => [b] -> [b]
05:38:14 <FreeFull> :t map
05:38:15 <Kaidelong> or something like LLVM bytecode
05:38:15 <lambdabot> (a -> b) -> [a] -> [b]
05:38:24 <FreeFull> AeroNotix: Yes
05:38:28 <AeroNotix> Interesting
05:39:05 <Kaidelong> AeroNotix: f a b = (f a) b
05:39:13 <AeroNotix> Haskell's syntax didn't really make sense to me as an erlang programmer until I saw pattern matching, which usually isn't the first syntax they show you. Just FYI if anyone makes a lot of tutorials.
05:39:34 <AeroNotix> > f a b = (f a) b
05:39:35 <lambdabot>   <hint>:1:7: parse error on input `='
05:39:38 <FreeFull> A type signature like    a -> b -> c -> d -> e      can be read as    a -> (b -> (c -> (d -> e)))
05:39:49 <AeroNotix> Yeah, that makes sense
05:40:23 <Kaidelong> @check associativityOfApplication f a b = f a b == (f a) b
05:40:24 <lambdabot>  <unknown>.hs: 1: 34:Parse error: =
05:40:30 <BitPuffin> do you have to always write let? or are there exceptions
05:41:07 <FreeFull> BitPuffin: lambdabot evaluates everything as an expression
05:41:12 <typoclass> AeroNotix: thanks for the feedback
05:41:19 <AeroNotix> np
05:41:32 <Kaidelong> BitPuffin: No but GHCi is special, it is something like being inside the IO monad
05:41:41 <Kaidelong> hence why you need to use let there
05:41:48 <BitPuffin> hmm
05:42:03 <BitPuffin> but when should you use let an not in actual source?
05:42:12 <Kaidelong> @check \f a b -> f a b == (f a) b
05:42:16 <lambdabot>   mueval-core: Time limit exceeded
05:42:23 <typoclass> BitPuffin: i didn't quite understand the earlier discussion, but i thought the jit compiler was supposed to do something for parallelization. but yes, haskell is usually compiled to native code. an interpreter (ghci) is also available for trying out stuff
05:42:27 <FreeFull> BitPuffin: You'd use let in expressions or in do notation
05:42:36 <Kaidelong> oh right
05:42:46 <Kaidelong> quickcheck can't generate functions, can it?
05:43:35 <BitPuffin> FreeFull: so if you don't use let it has to be constant everywhere? like you need to do let x = y in a functions if y is a parameter
05:43:50 <typoclass> BitPuffin: roughly, use "let" inside of functions (and inside of do blocks). at the top level of your file, no need for "let". in ghci, you're more or less inside of a big do block
05:43:50 <Kaidelong> GHCi isn't actually an interpreter is it? Incremental compiler was the term?
05:43:51 <supki> @check \f -> f () == f ()
05:43:54 <lambdabot>   +++ OK, passed 100 tests.
05:44:18 <Kaidelong> expressions have the general form let { ... } in { ... } where { ... }
05:44:37 <BitPuffin> isn't GHCi a REPL?
05:44:44 <FreeFull> @check \f -> f () () == (f ()) ()
05:44:45 <typoclass> BitPuffin: yes, exactly
05:44:48 <lambdabot>   +++ OK, passed 100 tests.
05:45:20 <BitPuffin> typoclass: since top level values won't take on different values
05:45:28 <Kaidelong> Read-Transform-Compile-Link-Run-Print loop?
05:45:52 <typoclass> Kaidelong: well, "4+2" is also an expression, isn't it
05:46:00 <Kaidelong> Yes
05:46:03 <Kaidelong> it has no let or where
05:46:32 <bel3atar> how do I learn Haskell quick?
05:46:34 <BitPuffin> so which haskell book should I read? I'm currently reading speeding through haskell
05:46:39 <typoclass> @where lyah
05:46:40 <lambdabot> http://www.learnyouahaskell.com/
05:46:54 <typoclass> bel3atar: try this book :) not sure if it'll be quick, but it's approachable
05:46:55 <FreeFull> Lyah is a good starting point
05:47:03 <typoclass> BitPuffin: see link :)
05:47:16 <Kaidelong> Real World Haskell seems to give the broadest range of applications that I've seen
05:47:49 <FreeFull> Real World Haskell is a bit more difficult
05:47:55 <elliott> I think RWH is best read after LYAH
05:47:56 <Kaidelong> honestly I haven't really found very many good haskell books past tutorial level stuff but you can read your favorite books that give examples for other platforms and adapt them to haskell
05:48:01 <chrisdone> learn haskell now with my five-point program
05:48:08 <BitPuffin> typoclass: learnyouahaskell? I was currently looking at it. Speeding through haskell is good but maybe it's too quick haha
05:48:22 <elliott> chrisdone: can I have a point-free version? I hate doing anything with a point.
05:48:54 * elliott has never even heard of "Speeding Through Haskell".
05:48:55 <Kaidelong> Well, there is the B&W book but that's not really so much about applying haskell's libraries as it is about the language itself and functional programming at a deep level
05:49:17 <Kaidelong> I think it was called Programming Haskell? Just look for "bird and wadler"
05:49:19 <FreeFull> Typeclassopedia is useful
05:49:38 <FreeFull> And also, just go ahead and read through the documentation for libraries and stuff, and just experiment with things
05:49:40 <typoclass> BitPuffin: top level definitions are constant, and definitions inside of functions can only change when the function is called ("applied" is the preferred term). so in "f x   =   x * 2", the x can change, but only from one application of f to the next. inside of one application, x won't change
05:49:50 <shanse> Kaidelong: Introduction to functional programming
05:50:16 <typoclass> (i hope it makes sense. i'm not sure i expressed that well)
05:50:19 <fikusz> hm, I want to have a "mutable" context when mapping over a list (a bit like fold, but without aggregation) :: (context -> a -> (context, b)) -> context -> [a] -> [b]
05:50:24 <fikusz> is there something like this already?
05:50:29 <Kaidelong> Experiment with things and read source code because the documentation is often quite terrible or Hackage doesn't manage to compile the package and the haddock documentation doesn't show on the project page
05:50:42 <BitPuffin> typoclass: yes it definitely makes sense :)
05:50:43 <BitPuffin> thanks
05:50:46 <nivox> BitPuffin: I'm also quite new to Haskell (but somewhat familiar with the general concepts of functional programming) and I find that Real Word Haskell is the one to go after you're at least a little bit familiar with the basics
05:51:31 <Kaidelong> fikusz, do you actually need destructive updates?
05:51:35 <FreeFull> Sadly RWH doesn't talk about lenses
05:51:46 <BitPuffin> nivox: hmm! Well I usually can't focus on reading all that much, so in my experience after knowing basics you should start doing stuff. At least that's how it works for me :)
05:51:57 <Kaidelong> otherwise you're really just looking at snd . foldr
05:52:11 <Kaidelong> (otherwise what you're after is runST)
05:52:16 <fikusz> Kaidelong: for example if I map over a list of dates and I have to decide halfway over the list to overflow the year
05:52:35 <typoclass> fikusz: that looks very much like a fold to me :)
05:52:55 <Kaidelong> foldr is powerful enough to do that, you can discard the threaded state with a function like snd
05:53:06 <nivox> BitPuffin: the problem with that approach (coming from a mostly imperative world) is that you just don't know what's possible... either you look at code from someone else or read it in books/paper...
05:53:09 <fikusz> typoclass: I don't want to aggregate: I don't want to get a single value at the end
05:53:52 <typoclass> fikusz: hm ... you mean, the single value being the [b] you mentioned earlier?
05:54:11 <BitPuffin> nivox: hmm. Well I might consider reading the book then. Is it free? I'll at least start doing some things after reading LYAH but then delve deeper
05:54:29 <Kaidelong> ah lemme come up with an example
05:54:39 <FreeFull> :t snd . foldr
05:54:40 <lambdabot>     Couldn't match type `b0 -> [a1] -> b0' with `(a0, c0)'
05:54:41 <lambdabot>     Expected type: (a1 -> b0 -> b0) -> (a0, c0)
05:54:41 <lambdabot>       Actual type: (a1 -> b0 -> b0) -> b0 -> [a1] -> b0
05:54:58 <FreeFull> :t \x y z -> snd (foldr x y z)
05:54:58 <lambdabot> (a1 -> (a, b) -> (a, b)) -> (a, b) -> [a1] -> b
05:55:24 <fikusz> typoclass: yeah, something like this: mapWithContext functionWhichReturnsNewContextAndNewValueBasedOnContextAndSingleValueOfTheList initialContext listOfValues
05:55:31 <bel3atar> how does this guy in http://www.youtube.com/user/lazycasts make ghci reload the file he's writing on without doing anything?
05:55:33 <FreeFull> :t \x y z -> snd (foldl x y z)
05:55:34 <lambdabot> ((a, b) -> b1 -> (a, b)) -> (a, b) -> [b1] -> b
05:55:42 <nivox> BitPuffin: you can read through it for free: http://book.realworldhaskell.org/read/
05:56:12 <BitPuffin> nivox: nice :)
05:56:13 <fikusz> FreeFull: that looks like it
05:56:15 <Kaidelong> what you're looking for is scanl
05:56:23 <Kaidelong> which is a specific form of foldr
05:56:43 <FreeFull> :t scanl
05:56:44 <fikusz> still it looks kinda strange, since I'm not really folding
05:56:44 <Kaidelong> if the two lengths can be of different lengths then what you're looking for is (>>=)
05:56:44 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
05:57:33 <Kaidelong> the complication is that you'd have to map the function that disposes of the state over the list
05:57:38 <Kaidelong> but that's not really a big complication
05:58:01 <Kaidelong> you'd have something in the general form map snd . foldr whatever whateverelse
05:58:48 <fikusz> maybe it's easier if I explain my usecase: I have a list of month and day tuples and have to decide which year they belong to. I know they start in the current year, but they could overflow to the next year.
05:59:32 <typoclass> fikusz: so the list is sorted?
05:59:38 <FreeFull> fikusz: Can you end up with something like   (1,40)
05:59:39 <fikusz> typoclass: yes
06:00:08 <fikusz> the list is sorted, but I need to decide to overflow the year if I get january after december
06:01:04 <FreeFull> fikusz: Do you end up with the number of days bigger than how many days there are in a month?
06:01:11 <FreeFull> Or is it just the months that can overflow?
06:01:20 <Kaidelong> @let samplelistfikusz = [(1,1),(4,4),(12,26),(3,16),(2,28),(9,11)]
06:01:21 <lambdabot>  Defined.
06:01:27 <fikusz> FreeFull: no, I have a valid list of (month-number, day-of-month)
06:01:31 <AeroNotix> I'm not a haskell guy but can't you just fold with a argument holding the current year and increase it everytime you get a Jan after Dec?
06:01:50 <fikusz> I just need to figure out the year: I know the list starts in the current year, but it may end in the next year
06:02:31 <fikusz> and I only know based on the previous list elements (that's why I wanted something like a map, but with an acc like fold)
06:03:16 <FreeFull> What do you mean by only know based on previous elements?
06:03:27 <FreeFull> :t any
06:03:28 <lambdabot> (a -> Bool) -> [a] -> Bool
06:03:37 <AeroNotix> he means he only knows it overflows if the previous was Dec and this is Jan, I gather.
06:04:03 <fikusz> example: [(12, 29), (12, 30), (12, 31), (1, 1), ...] :: [(Month, DayOfMonth]
06:04:04 <Kaidelong> @let scanStep ((previousMonth,year),result) (month,date) = (month,date,year + (if previousMonth > month then 1 else 0))
06:04:04 <AeroNotix> In haskell can't the accumulator in fold be an arbitrary term?
06:04:05 <lambdabot>  Defined.
06:04:21 <AeroNotix> yeah^
06:04:43 <FreeFull> fikusz: That would be an example that doesn't overflow?
06:04:55 <fikusz> FreeFull: it would be an example which does
06:05:07 <FreeFull> Oh, I see
06:05:20 <FreeFull> You're looking for if you get a change from a larger number to a smaller number
06:05:25 <Kaidelong> > map snd . drop 1 . scanl scanStep ((1,1999),undefined) examplelistfikusz
06:05:26 <fikusz> correct solution for year would be: [2013, 2013, 2013, 2014, ...]
06:05:26 <lambdabot>   Not in scope: `examplelistfikusz'
06:05:26 <lambdabot>  Perhaps you meant `samplelistfikusz' (li...
06:05:35 <Kaidelong> > map snd . drop 1 . scanl scanStep ((1,1999),undefined) samplelistfikusz
06:05:35 <lambdabot>   Couldn't match expected type `a0 -> [(a1, b0)]'
06:05:36 <lambdabot>              with actual ty...
06:05:51 <Kaidelong> > map snd . drop 1 . scanl scanStep ((1,1999),undefined) $ samplelistfikusz
06:05:52 <lambdabot>   Couldn't match type `(a0, t10, t20)' with `((a0, t20), b0)'
06:05:52 <lambdabot>  Expected type:...
06:06:26 <typoclass> why is it "ats" and not "at", "s"? s comes before t. i don't understand the groupBy function anymore (or i never understood it)
06:06:27 <typoclass> > groupBy (<) "lolcats"
06:06:28 <Kaidelong> @ty scanStep
06:06:29 <lambdabot>   ["lo","l","c","ats"]
06:06:34 <fikusz> I don't need to deal with multi-year ranges, just with a few days (when it's december)
06:06:51 <FreeFull> fikusz: How do you know you don't have something for which [2013, 2014] would actually be right for  [(1,1), (1,3)] because you are missing a bunch of months?
06:08:36 <drbean> The API I'm working with has a function, push c p stack = p (c:stack). Is there any way of fashioning c so that 2 elements are added to the stack list with one call of this function?
06:08:58 <fikusz> FreeFull: it's a continous sequence of days (no gaps)
06:09:19 <shachaf> drbean: No.
06:09:20 <FreeFull> fikusz: If you don't have gaps, then you can just look for the transition between 12 and 1
06:09:27 <shachaf> drbean: That's a weird CPSy API. What's the point?
06:09:57 <nooodl> @src groupBy
06:09:57 <lambdabot> groupBy _  []       =  []
06:09:57 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
06:09:57 <lambdabot>     where (ys,zs) = span (eq x) xs
06:10:18 <fikusz> FreeFull: yeah, that's what I want to do (but I can't decide based on a single item only, so I was looking to carry something like a boolean "overflow-day?" with me then mapping over the list)
06:10:20 <nooodl> typoclass: note the use of "span"
06:10:24 <Kaidelong> @let scanStep ((previousMonth,year),result) (month,date) = let thisYear = if previousMonth > month then year + 1 else year in ((month,thisYear),(month,date,thisYear))
06:10:25 <lambdabot>  .L.hs:137:10:
06:10:25 <lambdabot>      Couldn't match expected type `(t0, t1, t2)'
06:10:25 <lambdabot>              ...
06:10:59 <nooodl> > groupBy (<) "98765098765"
06:11:01 <lambdabot>   ["9","8","7","6","5","098765"]
06:11:04 <FreeFull> :t scanl
06:11:04 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
06:11:10 <typoclass> nooodl: right, it's comparing "a < t", then "a < s". it's not comparing adjacent guys from the list, like i thought
06:11:18 <shachaf> nooodl: I tried to read the documentation in order to understand that function, but it was spanish.
06:11:30 <drbean> It's parsing English sentences with a stack for words that are refered to with "who", etc.
06:11:57 <FreeFull> > scanl (>) 1 . map fst $ [(1,1),(12,1),(1,12)]
06:11:59 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
06:11:59 <lambdabot>    arising from the literal `1...
06:12:17 * hackagebot hOpenPGP 0.6.3 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.6.3 (ClintAdams)
06:12:22 <FreeFull> Wait
06:12:25 <Kaidelong> @let scanStep ((previousMonth,year),_) (month,date) = let thisYear = if previousMonth > month then year + 1 else year in ((month,thisYear),(month,date,thisYear))
06:12:25 <lambdabot>  .L.hs:137:10:
06:12:26 <lambdabot>      Couldn't match expected type `(t0, t1, t2)'
06:12:26 <lambdabot>              ...
06:12:35 <Kaidelong> why on earth doesn't this definition work
06:12:55 <FreeFull> > (\xs -> zipWith (>) xs (drop 1 xs)) [1,2,3,4,12,1]
06:12:56 <lambdabot>   [False,False,False,False,True]
06:13:04 <FreeFull> > (\xs -> zipWith (>) xs (drop 1 xs)) [1,2,3,4,12,1,2,3]
06:13:05 <lambdabot>   [False,False,False,False,True,False,False]
06:13:12 <fikusz> isn't there some standard function like fold which returns a tuble of (new acc, new value) instead of just the new acc (kinda like map)
06:13:34 <Saizan> mapAccumL ?
06:13:47 <sipa> t mapAccumL
06:13:52 <fikusz> @type mapAccumL
06:13:53 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
06:14:26 <fikusz> Saizan: perfect, thanks!
06:14:27 <FreeFull> > map (fromEnum) $ (\xs -> zipWith (>) xs (drop 1 xs)) [1,2,3,4,12,1,2,3]
06:14:29 <lambdabot>   [0,0,0,0,1,0,0]
06:14:31 <shachaf> Also, mapM with State acc.
06:14:50 <FreeFull> > scanl max . map (fromEnum) $ (\xs -> zipWith (>) xs (drop 1 xs)) [1,2,3,4,12,1,2,3]
06:14:52 <lambdabot>   <[[Int]] -> [[Int]]>
06:14:56 <FreeFull> > scanl max 0 . map (fromEnum) $ (\xs -> zipWith (>) xs (drop 1 xs)) [1,2,3,4,12,1,2,3]
06:14:57 <lambdabot>   [0,0,0,0,0,1,1,1]
06:15:16 <Kaidelong> @undefine
06:15:16 <lambdabot> Undefined.
06:15:29 <fikusz> here I can just discard the previous accumulator and set it based on the current element of the list
06:15:52 <Kaidelong> @src mapAccumL
06:15:53 <lambdabot> mapAccumL _ s []        =  (s, [])
06:15:53 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
06:15:53 <lambdabot>    where (s', y ) = f s x
06:15:53 <lambdabot>          (s'',ys) = mapAccumL f s' xs
06:15:55 <FreeFull> > map (+2013) . scanl max 0 . map fromEnum . (\xs -> zipWith (>) xs (drop 1 xs)) . map fst $ [(1,1),(12,1),(1,3),(2,4),(3,5)]
06:15:56 <lambdabot>   [2013,2013,2014,2014,2014]
06:16:09 <FreeFull> Note that is overly complicated
06:16:12 <BitPuffin> wow you guys really went on a roll here :O
06:16:27 <FreeFull> And can be simplified by quite a lot
06:16:31 <fikusz> FreeFull: looks good to me
06:16:41 <fikusz> I have to confess I actually need this in clojure ;)
06:17:01 <fikusz> just wanted to get the idea here
06:17:23 <Kaidelong> "implement mapAccumL in terms of foldr" might not be a bad homework exercise
06:17:41 <typoclass> fikusz: here is another example. it detects when the month number is getting smaller and says True. 'annotate' and the output format are just to show what's going on
06:17:42 <typoclass> > let annotate f x y = (x, y, f x y) ; z = zipWith (annotate ((>) `on` fst)) <*> drop 1 in z [(1,20),(5,20),(10,20),(3,20),(5,20),(2,20),(4,20)]
06:17:44 <lambdabot>   [((1,20),(5,20),False),((5,20),(10,20),False),((10,20),(3,20),True),((3,20)...
06:18:26 <typoclass> fikusz: (there'll be a problem if you have, like "may 20 -- may 19", which i think won't be detected as starting a new year. but you said this isn't present in the input)
06:18:53 <fikusz> typoclass: wow, thanks! very interesting.
06:19:23 <fikusz> typoclass: it isn't in the input, so it's not an issue :)
06:20:08 <nooodl> hey, groupBy working the way it does actually allows you to write a pretty cool "split" function:
06:20:11 <nooodl> > (map tail . groupBy (/=) . (' ':)) "this is a list of words"
06:20:12 <lambdabot>   ["this","is","a","list","of","words"]
06:20:48 <FreeFull> > words "this is a list of words"
06:20:49 <lambdabot>   ["this","is","a","list","of","words"]
06:21:11 <nooodl> yeah it's a generalization of words/lines
06:21:25 <FreeFull> words and lines are actually implemented differently
06:21:31 <FreeFull> For some reason
06:21:47 <typoclass> fikusz: just as a bit of further explanation, zipWith (which FreeFull also used) is essentially map but stepping over two lists simultaneously. here, the lists are the input list and "drop 1" of the input list (i.e. its tail). the (->) instance of <*> will pass input through a function (here: drop 1), then pass the result and the original input through another function (here: zipWith ...)
06:22:00 <nooodl> > words "a  b"
06:22:01 <lambdabot>   ["a","b"]
06:22:08 <nooodl> mhmmm
06:22:18 <FreeFull> > lines "a\n\nb"
06:22:19 <typoclass> fikusz: other than that, there's basically just (>) `on` fst, which is shorthand for "\x y -> fst x < fst y"
06:22:19 <lambdabot>   ["a","","b"]
06:22:25 <FreeFull> That explains why
06:23:03 <nooodl> oh, in fact:
06:23:07 <nooodl> > words "a\nb"
06:23:08 <lambdabot>   ["a","b"]
06:23:14 <nooodl> i didn't know about that :o
06:23:26 <typoclass> nooodl: heh, cute split function
06:23:28 <fikusz> typoclass: it's a very nice idea (a bit like the famous fib implementation with zip)
06:23:49 <typoclass> fikusz: i guess it's similar to that, yeah
06:23:55 <FreeFull> words ignores multiple separators in a row
06:23:59 <FreeFull> lines doesn't
06:24:37 <fikusz> typoclass: but I wonder how it compares performance-wise (to keeping track of only the last month number)
06:26:04 <typoclass> > groupBy (const (/= ' ')) "this is a list of words" -- nooodl: see also :-)
06:26:05 <lambdabot>   ["this"," is"," a"," list"," of"," words"]
06:27:06 <typoclass> fikusz: profile it. i don't know about the performance, but i wouldn't expect it to be exceptionally slow or something
06:28:17 <notdan> Can somebody familiar with GHC API help me out with this? https://groups.google.com/forum/?fromgroups#!topic/haskell-cafe/4jDGTN83D28
06:28:43 <fikusz> typoclass: as I mentioned I want to do a clojure solution to this problem, I think clojure loop will do nicely http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/loop
06:29:16 <typoclass> so, yes! groupBy is essentially 'span' called repeatedly. need to remember that, i've wanted a recursive span quite a few times
06:30:41 <typoclass> fikusz: i don't know clojure, but that link seems to indicate 'map' can be called as "map f collection1 collection2" ...?
06:31:45 <fikusz> typoclass: yes, it can. Are you suggesting to do map list (rest list) where rest == tail?
06:32:13 <typoclass> fikusz: yes you could use that. it's what FreeFull and i did :-)
06:32:14 <hidenori> Real World Haskell says "A source file must have the same base name (the component before the suffix) as the name of the module it contains."
06:32:20 <hidenori>  but i can load a module with a name different from basename.did ghc change sth?
06:32:36 <chrisdone> @hoogle [a -> a] -> a -> a
06:32:36 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
06:32:37 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
06:32:37 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
06:32:39 <fikusz> typoclass: hm, looks like a more functional solution
06:32:48 <notdan> hidenori: I think you wouldn't be able to 'import' it
06:33:23 <chrisdone> :t foldr ($)
06:33:24 <lambdabot> b -> [b -> b] -> b
06:33:30 <chrisdone> hm, perfect
06:33:47 <fikusz> typoclass: thanks, I'll give it a shot!
06:34:19 <typoclass> hidenori: hm ... basically i think that's still the rule. there's an exception for Main, however. if i have a file "Doodle.hs" or even "doodle.hs" which has no "module ... where" line in it, then the file will get the module name "Main"
06:34:21 <hidenori> notdan: Ahh you are right .Thanks!
06:34:53 <typoclass> hidenori: (this is handy for script-type programs that don't have more than one module)
06:36:02 <CaptainK> no, that is a list of list of words
06:38:11 <Taneb> Will Data.ByteString.Lazy.readFile actually execute if its value is never needed?
06:38:21 <hidenori> typoclass: i see. is that why i see  "Ok, modules loaded: Main." whenever i load file w/o "module .. where" in GHCi,?
06:38:35 <Taneb> Like if I do "_ <- B.readFile fp; somethingElse"
06:38:36 <notdan> Taneb: it will open the file
06:38:46 <typoclass> CaptainK: the output is a list of lists of Chars. the input is a list of Char as far as i can see
06:38:51 <notdan> so it probably will leak handlers
06:38:57 <typoclass> hidenori: yes, exactly
06:38:59 <notdan> hidenori: yes
06:39:01 <CaptainK> ah ya, that is a better definition
06:39:16 <hidenori> i see thanks =)
06:39:23 <chrisdone> ok i've added some improved spam handling support on hpaste
06:39:36 <Taneb> notDan, thanks
06:40:27 <hidenori> typoclass: By the way, what is "script-type programs"?
06:40:28 <typoclass> chrisdone: thanks, that's great
06:40:43 <chrisdone> when something's marked as spam by a person it sends me an email, but also when a paste is created it consults spamassassin on the contents and subject of the paste. if the rating is above the threshold, it doesn't display the paste on the public listing, but still accepts. if the paste is above the limit, it ignores the paste submission entirely
06:41:06 <chrisdone> then there are some hpaste-specific multipliers of the score, such as n * number of links, having anonymous as author and containing "stooorage"
06:41:31 <typoclass> hidenori: i meant quick little programs that i sometimes write. only consisting of 1 file (= 1  Main module). other people might use shellscripts instead
06:41:42 <notdan> chrisdone: cool!
06:41:52 <notdan> Better than adding captch, IMO
06:42:11 <typoclass> chrisdone: does spamassassin sort out dvd metadata guy? ("stooorage")
06:42:53 <chrisdone> i deleted his pastes a couple days back, so not sure. would be interested to see
06:43:16 <hidenori> typoclass: i see. thank you
06:43:44 <chrisdone> ah, i found one of his on another pastebin: http://pastebin.com/dxnmzPwz i'll try it
06:43:47 <mauke> The paste dxnmzPwz has been copied to http://sprunge.us/YLNI?haskell
06:44:15 <typoclass> chrisdone: i've saved one in a file for reference. can i put it on hpaste? is the change already live?
06:44:24 <elliott> chrisdone: does it give a notification when the paste won't be publicly listed?
06:44:25 <FreeFull> > mconcat [id,id]
06:44:27 <lambdabot>   No instance for (Data.Monoid.Monoid a0) arising from a use of `e_1'
06:44:27 <lambdabot>  The ty...
06:44:32 <elliott> other than checking hpaste.org manually
06:44:33 <FreeFull> > mconcat [id,id] 3
06:44:34 <lambdabot>   No instance for (Data.Monoid.Monoid a0)
06:44:34 <lambdabot>    arising from a use of `e_13'
06:44:34 <lambdabot>  Th...
06:44:45 <chrisdone> typoclass: yeah, i just tested it. it ignores the paste entirely. you can try yours, too
06:45:38 <chrisdone> elliott: no. should it? i suppose a spammer doesn't read things like that, so it wouldn't hurt
06:46:41 <elliott> chrisdone: well, I'd find it reassuring :) I suspect spammers aren't targetting hpaste specifically, yeah
06:47:04 <b2coutts> I'm trying to install hoogle on archlinux, but I'm missing 12 packages, and none of them seem to be in the repositories. Is there an easier way to install it than manually tracking down and building each dependency?
06:47:21 <typoclass> chrisdone: i pressed submit and got back to the empty "new paste" page. not sure what happened. i guess that means spamassassin blocked it
06:48:21 <chrisdone> typoclass: yeah, it simply redirects to the home page when it ignores things
06:48:48 <Saizan> b2coutts: cabal-install
06:52:21 <b2coutts> Saizan: thanks
07:19:08 <chrisdone> typoclass: fwiw: https://github.com/chrisdone/hpaste/blob/master/src/Hpaste/Model/Spam.hs if any more spam gets through, just report it and i'll get an email and adjust the filter as needed
07:20:38 <typoclass> @tell chrisdone very nice, thanks
07:20:39 <lambdabot> Consider it noted.
07:22:16 <b2coutts> so I'm trying to install hoogle via cabal-install, and it fails because it can't install haskell-src-exts; when I try to install that, it fails because it can't install cpphs; when I try to install that, it gives me this error message: http://hpaste.org/89961
07:23:23 <geekosaur> cabal update
07:23:48 <b2coutts> geekosaur: did that
07:24:11 <geekosaur> 1.13 is old and I see a couple of point releases for it, so apparently it was buggy
07:25:12 <b2coutts> I assumed 1.13 was old because its date says 2011, but according to http://projects.haskell.org/cpphs/#download it's the latest stable versoin
07:25:39 <b2coutts> is that site out of date, or should I just try an unstable version?
07:25:45 <typoclass> b2coutts: http://hackage.haskell.org/package/cpphs-1.16 suggests 1.16 is the current one. could you re-run cabal with the -v3 switch on? it'll tell you if something odd is going on (e.g. it's rejecting 1.16 because of some incompatibility)
07:27:08 <geekosaur> they don't seem to be using / updating that page, yeh
07:27:08 <typoclass> b2coutts: seems like a mistake on the website! that's pretty unfortunate
07:28:22 <BitPuffin> why does tail [2] return an empty list? [2] doesn't have a tail so it should error shouldn't it?
07:28:35 <elliott> sure [2] has a tail
07:28:38 <elliott> [2] is 2 : []
07:28:44 <elliott> [1,2,3] is 1 : 2 : 3 : []
07:28:52 <elliott> tail of [1,2,3] is 2 : 3 : []
07:28:54 <elliott> tail of [2] is []
07:29:03 <merijn> > []
07:29:05 <lambdabot>   []
07:29:07 <merijn> > 2 : []
07:29:08 <lambdabot>   [2]
07:29:49 <typoclass> BitPuffin: what will get an error is "tail []", though
07:29:59 <BitPuffin> hmm
07:30:09 <BitPuffin> I guess it kind of makes sense
07:30:10 <merijn> BitPuffin: The definition of haskell lists is identical (modulo some syntactic sugar) to "data List a = Empty | Cons a (List a)"
07:30:14 <typoclass> BitPuffin: drop 1 [] will give [], tail [] will give an exception (abort your program)
07:30:34 <merijn> And tail would be "tail (Cons x xs) = xs; tail Empty = undefined"
07:31:40 <BitPuffin> Cons?
07:32:35 <elliott> see merijn's previous line
07:32:44 <elliott> (it won't help if you don't know about declaring data types, though)
07:32:59 <augur> BitPuffin: cons/(:) means "followed by"
07:33:14 <augur> BitPuffin: the tail of x:xs is just xs
07:33:21 <typoclass> BitPuffin: i think that explanation was in case you knew lisp :-) anyway, lists in haskell consist basically of an element plus the rest of the list. this rest may be an empty list, or a list with whatever elements
07:33:26 <merijn> BitPuffin: Cons is the traditional name (coming from Lisp) for adding something to a list, it's short for CONStruct
07:33:36 <augur> since [2] is 2 followed by nothing, its 2:[] so the tail must be everything after 2, ie, []!
07:33:43 <typoclass> (written as theElement : theRest )
07:33:47 <merijn> typoclass: That explanation works if you just understand datatypes too
07:33:48 <BitPuffin> typoclass: I'm actually learning lisp too :)
07:34:01 <augur> BitPuffin: watch SICP
07:34:16 <typoclass> merijn: right :-) i meant mostly that the name 'cons' is lispish
07:34:27 * elliott doesn't think that explanation has much to do with lisp
07:34:32 <typoclass> BitPuffin: bah. needs moar type system. do not want ;-)
07:34:33 <augur> typoclass: thank goodness we dont use car and cdr!
07:34:37 <elliott> lists don't even really work like that in lisp.
07:34:48 <augur> elliott: dont they?
07:34:58 <augur> ir is it not that way in CL?
07:34:59 <b2coutts> so I have cpphs installed, the issue is now with happy; `cabal install happy` seems to install it properly, it ends with 'Installed happy-1.18-10', but afterwards, `cabal info happy` says 'versions installed: [ Unknown ]', and haskell-src-exts says it isn't installed
07:35:04 <BitPuffin> augur: SICP?
07:35:05 <elliott> well, they have the same structure of cons cells. but it's more like they're made out of tuples and (), from a haskell point of view.
07:35:13 <elliott> lisp's cons isn't anything list-specific
07:35:13 <augur> BitPuffin: structure and interpretation of computer programs
07:35:23 <augur> elliott: oh yes, well, its untyped so what do you expect
07:35:33 <BitPuffin> augur: I should watch it?
07:35:35 <augur> BitPuffin: there's a whole video series on youtube you can watch
07:35:37 <augur> BitPuffin: yep!
07:35:39 <augur> definitely watch it
07:35:50 <augur> itll make you a lisp hacker for sure!
07:36:31 <BitPuffin> I will when I'm on good bandwidth
07:36:31 <BitPuffin> you might have to remind me though :)
07:36:44 <augur> BitPuffin: http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/
07:37:13 <augur> or http://www.youtube.com/playlist?list=PLB63C06FAF154F047
07:37:17 <augur> whichever you prefer
07:38:47 <BitPuffin> thanks :)
07:39:07 <augur> BitPuffin: its a full hardcore course, mind you
07:39:23 <augur> 20 1-hour+ lectures
07:39:23 <BitPuffin> yeah it looks like it
07:39:32 <augur> but its definitely worth watching at least once
07:39:46 <BitPuffin> I'd imagine
07:39:56 <augur> there are probably going to be some sticking points for some issues but thats what we're here for :)
07:40:03 <BitPuffin> do they have a bunch of useful stuff like that up?
07:41:54 * elliott doesn't think SICP is necessarily helpful from a learning-Haskell POV. there's a distinct cultural difference compared to lisp
07:42:11 <b2coutts> eh, it's still a very good introduction to functional programming
07:42:34 <elliott> as long as you avoid having an "omg! everything is a list" epiphany, I guess :)
07:43:39 <bitonic> @google calculating better than scheming
07:43:40 <lambdabot> http://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf
07:43:41 <lambdabot> Title: A critique of Abelson and Sussman Why calculating is better than scheming
07:43:51 <merijn> elliott: Well, he mentioned he was learning lisp *and* Haskell
07:44:21 <elliott> I daresay that learning both simultaneously isn't the grandest idea, personally
07:44:54 <FreeFull> "It puts the state in the monad or it gets the hose again. "
07:45:04 <b2coutts> I sort of did that, in that when I learned scheme, lectures were taught in haskell but assignments were done in scheme
07:45:29 <b2coutts> well, lectures were taught mostly in haskell anyway
07:45:38 <elliott> that sounds horrific
07:46:05 <augur> elliott: probably not from a learning haskell POV but hes learning lisp anyway, so
07:46:26 <darenthis> aeson question: I'm trying to use it to parse a file but it wants a Lazy.Internal.ByteString and Data.ByteString.readFile doesn't give me one. I'm probably missing something obvious
07:46:32 <b2coutts> it was actually kind of nice, when he needed to teach actual scheme things, he used scheme, but he used haskell to show basic algorithm things
07:46:47 <FreeFull> darenthis: Are you getting an error?
07:46:53 <b2coutts> (it was a scheme course, not a haskell course)
07:46:56 <darenthis> type mismatch
07:47:22 * hackagebot timeplot 1.0.21 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.21 (EugeneKirpichov)
07:47:37 <darenthis> D.B.L.I.ByteString is not a D.B.ByteString
07:47:37 <elliott> darenthis: it's giving you a strict bytestring
07:47:41 <darenthis> yep
07:47:44 <elliott> so use Data.ByteString.Lazy.
07:48:15 <darenthis> aha! Thanks. My hoogle fu was not strong
07:48:59 <elliott> @@ darenthis: @hackage bytestring -- has a nice module list :)
07:48:59 <lambdabot>  darenthis: http://hackage.haskell.org/package/bytestring -- has a nice module list :)
07:51:54 <Bor0> what's the inverse of succ? I thought prev but it's not defined
07:52:09 <merijn> pred
07:52:14 <merijn> successor and predecssor
07:52:17 <merijn> > pred 3
07:52:18 <lambdabot>   2
07:52:22 <darenthis> @elliott thanks, I think I was looking 1 module too low
07:52:22 <lambdabot> Unknown command, try @list
07:52:23 <Bor0> wow. why did I think prev
07:52:26 <Bor0> thanks.
07:53:11 <FreeFull> > pred True
07:53:12 <lambdabot>   False
07:53:14 <Bor0> is there a neater way to implement caesar-1, my current implementation is \x -> map succ x
07:53:15 <FreeFull> > pred False
07:53:16 <lambdabot>   *Exception: Prelude.Enum.Bool.pred: bad argument
07:53:34 <FreeFull> Bor0: Your implementation isn't even correct
07:53:40 <FreeFull> > succ 'z'
07:53:41 <lambdabot>   '{'
07:53:45 <Bor0> how do you mean
07:54:02 <Bor0> (\x -> map succ x) "asdf" -- this seems to work
07:54:12 <shanse> include a z in there
07:54:13 <geekosaur> see what FreeFull just asked lambdabot
07:54:26 <Bor0> oh, I see
07:54:53 <merijn> You probably wanna do
07:56:00 <merijn> > let ceasar i c = (ord c - ord 'a' + i) `mod` 26 + ord 'a' in ceasar 13 'z'
07:56:02 <lambdabot>   109
07:56:02 <Bor0> so cycles should be around ['a'..'z']? I had a wrong definition of caesar I guess
07:56:04 <merijn> hmm
07:56:07 <merijn> oh, duh
07:56:17 <merijn> > let ceasar i c = char ((ord c - ord 'a' + i) `mod` 26 + ord 'a') in ceasar 13 'z'
07:56:18 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
07:56:19 <lambdabot>              with actual type...
07:56:23 <merijn> :t chr
07:56:23 <lambdabot> Int -> Char
07:56:28 <merijn> > let ceasar i c = chr ((ord c - ord 'a' + i) `mod` 26 + ord 'a') in ceasar 13 'z'
07:56:30 <lambdabot>   'm'
07:56:34 <merijn> > let ceasar i c = chr ((ord c - ord 'a' + i) `mod` 26 + ord 'a') in ceasar 13 'a'
07:56:35 <lambdabot>   'n'
07:56:45 <b2coutts> so `cabal install happy` appears to install happy without any issues, but checking afterwards, happy still isn't installed. Is there a way for me to uninstall all packages in cabal to try restarting from scratch?
07:56:46 <FreeFull> merijn: Doesn't that only work for lowercase
07:56:51 <merijn> FreeFull: Yeah
07:56:56 <elliott> b2coutts: is ~/.cabal/bin in your $PATH
07:56:58 <merijn> But generalising to uppercase should be simple
07:57:28 <FreeFull> I'd use toEnum and fromEnum rather than chr and ord
07:58:20 <FreeFull> Actually, chr and ord is probably better
08:01:13 <Bor0> would this one-liner for caesar1 work? [ if x == 'z' then 'a' else if x == 'Z' then 'A' else succ x | x <- "wxyz", x `elem` ['a'..'z'] ++ ['A'..'Z'] ]
08:02:08 <merijn> Bor0: Sure, but I'd split it into multiple functions, though
08:02:38 <Bor0> how do you mean?
08:03:24 <FreeFull> Bor0: Sure, it'd work
08:03:24 <merijn> Bor0: It's a bit ugly as a one-liner
08:03:49 <merijn> one liners are overrated, clean readable code is where it's at
08:05:29 <Taneb> > fix (\r -> 0 : 1 : zipWith (+) r (tail r))
08:05:30 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:06:14 <Taneb> incomprehensible one liners ftw
08:06:36 <Bor0> I'm just playing around with ghci, hobby coding, not for profit :)
08:06:47 <geekosaur> Just Another Haskell Hacker,
08:07:18 <FreeFull> Taneb: That is comprehensible though
08:07:26 <Taneb> FreeFull, shh
08:08:39 <FreeFull> > view _2 (4,5)
08:08:40 <lambdabot>   Not in scope: `view'
08:08:40 <lambdabot>  Perhaps you meant one of these:
08:08:40 <lambdabot>    `Seq.viewl' (impor...
08:11:39 <b2coutts> elliott: it wasn't in my PATH before, I tried appending it to my PATH but I have the same issue
08:11:57 <elliott> how did you append it?
08:12:46 <b2coutts> in .zshrc, export PATH=PATH:/home/b2coutts/.cabal/bin
08:13:11 <b2coutts> and `which happy` finds it properly
08:13:28 <b2coutts> but cabal doesn't seem to understand that it's installed
08:13:31 <elliott> b2coutts: erm, that command is rather bad. you want $PATH on the right hand side
08:13:40 <b2coutts> elliott: does it make a difference?
08:13:42 <elliott> or you will be unable to run anything not installed via cabal!
08:13:48 <elliott> unless zsh has some weird syntax
08:13:54 <monochrom> precedence makes a difference
08:13:59 <b2coutts> oh, right
08:14:14 <b2coutts> well I don't have anything else named happy, and in any case it's resolving fine
08:14:17 <elliott> anyway, I suggest running cabal with -v3 and hpasting the output
08:14:21 <b2coutts> (I'm changhing it now anyway)
08:14:42 <FreeFull> b2coutts: Shouldn't that be $PATH and not PATH after the =
08:14:48 <monochrom> that too
08:15:11 <b2coutts> FreeFull: typo in irc, it's correct in .zshrc though
08:15:24 <b2coutts> elliott: which command do I run with -v3?
08:15:44 <monochrom> what is the command that led you to believe that cabal cannot find happy?
08:15:55 <elliott> what monochrom said
08:16:10 <b2coutts> cabal info happy, and cabal install haskell-src-exts
08:16:36 <monochrom> I'd ignore "cabal info happy"
08:16:49 <monochrom> "cabal install haskell-src-exts" is the real deal
08:17:07 <merijn> preflex: seen mm_freeak
08:17:07 <preflex>  Sorry, I haven't seen mm_freeak
08:17:08 <merijn> eh
08:17:11 <merijn> preflex: seen mm_freak
08:17:11 <preflex>  mm_freak was last seen on #haskell 4 days, 19 hours and 58 seconds ago, saying: or pretty much enforces
08:18:55 <Saizan> b2coutts: do me a favor, run the export command in the current shell too, then call cabal install haskell-src-exts
08:20:59 <monochrom> wow, it still uses -fglasgow-exts ? :)
08:22:33 <elliott> Saizan: you're going to owe b2coutts after that favour!
08:23:24 <BitPuffin> someone should write a graph database in haskell
08:23:26 <monochrom> with luck, the favour itself already returns the favour
08:23:35 <b2coutts> strange, I ran `cabal install haskell-src-exts -v3`, and it gave me longer output and still didn't work, but when I tried `cabal install haskell-src-exts` right after that it seemed to work
08:24:02 <b2coutts> and I'd been opening new shells all the tame to make sure changes to PATH, cabal installs, etc were taking
08:24:05 <monochrom> what is graph database?
08:24:24 <jmcarthur> does anybody know if there is a way to do something like rewrite rules for data structures? in particular, i would like to be able to specialize a type (with a hidden representation) for certain type parameters without making client code have to see it as anything different from normal polymorphism. e.g. for some types i might just use the same representation but with unboxed fields. i'm thinking this is not
08:24:26 <b2coutts> but hoogle seems to be installed now, so I won't complain about whatever black magic has caused this
08:24:27 <jmcarthur> really doable without leaking into the interface at all, though
08:24:29 <b2coutts> thanks for the help, everyone
08:24:47 <BitPuffin> monochrom: it's a database that uses graph theory instead of relational for example
08:24:47 <jmcarthur> i know i can use data families, but then client code needs to be aware of that
08:24:59 <BitPuffin> monochrom: look at neo4j for example
08:25:05 <jmcarthur> or at least have some type class constraint
08:25:09 <merijn> jmcarthur: Data families?
08:25:13 <jmcarthur> ^^
08:25:15 <simon> jmcarthur, your sentence ended at "i'm thinking this is not"
08:25:22 <simon> jmcarthur, ah, never mind.
08:25:53 <BitPuffin> http://www.slideshare.net/purbon/graph-databases-the-web-of-data-storage-engines monochrom
08:26:15 <merijn> jmcarthur: How does client code need to be aware of data families? You mean that it has to enable the extension?
08:26:49 <jmcarthur> merijn: i mean it keeps me from doing things like Functor instances and other stuff that needs to be fully generic over the type parameter
08:27:07 <jmcarthur> merijn: the "model" type is a Functor, but the data family wouldn't be
08:27:44 <jmcarthur> i figure if this was possible then we would see it all the time
08:27:56 <Vulfe> good morning, all
08:28:08 <b2coutts> good morning
08:29:17 <merijn> jmcarthur: I'm not sure I understand that?
08:29:32 <jmcarthur> merijn: take this interface: http://hackage.haskell.org/packages/archive/linear/1.1.2/doc/html/Linear-V2.html
08:29:55 <jmcarthur> merijn: i wouldn't mind hiding the representation for this, but many of those nice instances would have to go
08:30:17 <jmcarthur> merijn: since they
08:30:19 <jmcarthur> oops
08:30:32 <jmcarthur> merijn: since they don't allow constraints on the type parameter
08:31:10 <jmcarthur> merijn: consider the use case of making a version of V2 for Ints with unboxed fields, say
08:31:29 <jmcarthur> actually, this happens with Data.Vector.Unboxed
08:31:37 <jmcarthur> you can write map function but no Functor instance
08:31:42 <jmcarthur> etc.
08:34:02 <merijn> oh
08:34:09 <merijn> right
08:34:42 <jmcarthur> but i don't even mean just restricted monad kinds of things, since actually there is a model type for which you *can* write such an instance
08:35:40 <merijn> bleh, I'm not GLFW's callback approach to things :\
08:35:49 <merijn> s/I'm not/I'm not happy
08:36:31 <jmcarthur> merijn: GLFW also provides ways to use directly style
08:36:33 <jmcarthur> *direct
08:36:38 <merijn> jmcarthur: Oh? How?
08:37:26 <jmcarthur> merijn: the haskell wiki example covers active polling before callback style: http://www.haskell.org/haskellwiki/GLFW
08:37:56 <jmcarthur> merijn: also, if that doesn't work for you, you can do the "uninversion of control" trick
08:37:56 <FreeFull> Callbacks are the way to go in imperative programming
08:38:13 <jmcarthur> *reinversion
08:38:16 <merijn> jmcarthur: I could just set the callbacks to write into a Chan, but that seems a bit ugly
08:38:21 <jmcarthur> http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
08:41:10 <merijn> jmcarthur: The "active" polling thing only lets you check "is button X pressed"
08:41:23 <merijn> ot "wait until something happens, then return that thing"
08:41:56 <merijn> Also, I'm just talking about the input from GLFW here, not the GL rendering code
08:42:34 <merijn> I have a sample program using SDL that polls for events, but that doesn't work properly on my macbook, it racks up 110% CPU load without actually doing anything
08:42:46 <jmcarthur> merijn: http://www.glfw.org/docs/3.0/group__window.html#ga554e37d781f0a997656c26b2c56c835e
08:43:02 <merijn> So I figured I'd switch to GLFW, but the only approach I can see there is to set the GLFW callbacks to write to a chan and then poll that Chan
08:43:32 <merijn> jmcarthur: That doesn't actually return what happened
08:43:43 <jmcarthur> merijn: i'm not 100% sure, but i think you can just use waitEvents without any callbacks set up and then grab them manually
08:43:48 <merijn> jmcarthur: You'd have to walk a loop through all possible keys, etc. to check what button was pressed
08:43:57 <jmcarthur> oh, i do recall something lame like that
08:43:59 <merijn> jmcarthur: The haskell GLFW library doesn't expose an interface for that
08:44:49 <jmcarthur> you're right, it's lame
08:45:00 <jmcarthur> the C lib is also lame
08:45:21 <merijn> And fixing the SDL library doesn't seem like a lot of fun, because I have no clue where to even start debugging things
08:45:41 <merijn> Also, it requires ridiculously ugly hacks on OSX (main in C that calls the haskell main)
08:45:46 <jmcarthur> yeah
08:45:53 <jmcarthur> but that actually applies to all the window toolkits
08:46:11 <merijn> GLFW doesn't seem to require that
08:46:18 <jmcarthur> but you don't *have* to structure it that way, even with the SDL bindings
08:46:26 <jmcarthur> yeah, some of the packages have workaround
08:46:29 <jmcarthur> s
08:46:30 <merijn> jmcarthur: oh, I'm open how to get it to run
08:46:31 <jmcarthur> the SDL one could, too
08:46:57 <jmcarthur> the main thing is that OS X requires that the main thread be dedicated to the OS event loop
08:47:00 <merijn> All I really want to do is take http://hpaste.org/83098 and get it to run succesfully, which so far seems out of the question
08:47:23 <jmcarthur> you can actually, in haskell land, make the appropriate C calls and then spawn a new thread to serve as the main for the remainder of your program, and it works
08:48:00 <merijn> The C code in the SDL case seems to only setup some cocoa garbage collection
08:48:04 <jmcarthur> i know this because Allegro exposes a function for doing it, and i tested by binding to it myself
08:48:12 <jmcarthur> yeah
08:48:35 <jmcarthur> well, it's something like that. you have to arrange from some cocoa stuff to run in the main thread is all i recall for sure
08:49:04 <xplat> cocoa and ghc runtime are both control freaks, it's hard to make them get along :)
08:49:09 <jmcarthur> i guess SDL's problem is that it hijacks main, not the thread stuff itself
08:49:11 <hodapp> jmcarthur: 'serve as the main' in what sense?
08:49:30 <jmcarthur> hodapp: as the "main thread" from that point on
08:49:50 <hodapp> jmcarthur: huh, so the other thread is then the one doing the C calls?
08:50:04 <jmcarthur> hodapp: no, you just abandon the original main thread
08:50:19 <hodapp> jmcarthur: but then what's the point?
08:50:21 <jmcarthur> hodapp: you just give it over to the OS for UI stuff
08:50:36 <jmcarthur> hodapp: it's stuck in an event loop that you don't control anymore or something
08:50:40 <hodapp> well, that's kind of what I mean - that other thread is still being used, e.g. for callbacks
08:50:52 <jmcarthur> yeah, but you don't really see them yourself
08:51:00 <hodapp> any kind of link on this?
08:51:02 <hodapp> I may need it
08:51:09 <jmcarthur> hodapp: the allegro source code?
08:51:29 <xplat> allegro what?  common lisp?
08:51:45 <jmcarthur> hodapp: there's some sort of run_main function (not quite called that) that does this and calls you back in a new thread
08:51:54 <jmcarthur> xplat: no, the multimedia library
08:53:04 <xplat> alleg.sourceforge.net?
08:53:11 <jmcarthur> i imagine SDL's main does the same thing, calling your main in a new thread while the original main is handed over to the UI event loop
08:53:19 <jmcarthur> xplat: yes
08:53:41 <merijn> Peaker: Where is Graphics.UI.GLFW.Events coming from in Lamdu?
08:54:45 <Peaker_> merijn, bottlelib/
08:55:17 <Peaker> hmm.. getting segfaults in hashable/sse2
08:55:35 <jmcarthur> i believe that has been reported already?
08:55:39 <jmcarthur> (segfaults)
08:55:45 <elliott> new hashable disables all that stuff i think
08:55:55 <merijn> Peaker: oh, doh...I missed the .UI >.<
08:56:13 <Peaker> merijn, find -iname "Events.*" is easiest...
08:56:49 <Peaker> How do I enable debug information so gdb is more useful with core dumps in C code called by Haskell?
08:56:51 <merijn> Peaker: Right, so you ended up doing the same thing I proposed, having callbacks add everything to an event list which can be polled
08:57:23 <Peaker> merijn, perhaps, I don't remember, it was 18 months ago or so when this was written
08:57:26 <merijn> A pox on the GLFW designers!
08:57:29 <xplat> 'Please wait while Leksah collects information about Haskell packages on your system' -- can't do this lazily?  :(
08:57:41 <Peaker> merijn, oh that part, well, I wanted SDL-like event lists :)
08:57:48 <merijn> Peaker: Me too
08:57:49 <Peaker> merijn, so had to do inversion of control
08:57:56 <hodapp> Are there as many jokes about lazy evaluation in Haskell as there are jokes about parentheses in Lisp?
08:58:03 <acube> Hmm, is there support for compiling only a single file in cabal?
08:58:18 <Peaker> hodapp, A professor enters his class, and says: "Today's lecture will be about lazy evaluation.  Any questions?"
08:58:21 <merijn> Peaker: I actually had sample code using SDL, but it is broken horribly on my OSX system, so that was the idea I proposed to
08:58:52 <merijn> Well, I was thinking of using a Chan, but still
08:59:13 <hodapp> Peaker: Wouldn't it be more like "This is today's lecture." followed by silence?
08:59:40 <jmcarthur> hodapp: there are some strict fields in this data structure
08:59:41 <Peaker> hodapp, Hmm... probably won't work as well :)
08:59:45 <xplat> hodapp: that wouldn't be true
09:00:31 <merijn> Ok, another question
09:01:01 <merijn> If I provide a generic library with N specific implementations of its interface, what's the best way to organise my stuff?
09:02:30 <xplat> merijn: what kind of interface?  common API for a module, or a typeclass, or a record of things?
09:02:33 <merijn> i.e. how can I avoid code duplication while developing without requiring everyone to install all N implementations if they only need a specific one?
09:02:37 <merijn> xplat: common API
09:02:49 <elliott> merijn: use ML.
09:02:57 <elliott> or give up
09:03:04 <elliott> or hack it in incredibly awkwardly with typeclasses
09:03:08 <merijn> elliott: Not an option
09:03:11 <merijn> (the ML part)
09:03:17 <Peaker> merijn, Make a package for the interface, and a package per implementation?
09:03:28 <jmcarthur> elliott beat me to what i was going to say
09:03:50 <merijn> Peaker: What would a package with the interface contain?
09:04:03 <jmcarthur> some type classes?
09:04:04 <Peaker> merijn, a type-class, or just some types, or a record of actions, or any combination of these
09:04:39 <merijn> Actually I think it's not that hard to just have multiple implementations, I just don't know a good way to tie them together
09:04:46 <xplat> merijn: anything useful that will be the same across implementations, presumably
09:05:23 <hodapp> elliott: why ML here?
09:05:30 <jmcarthur> hodapp: functors!
09:05:34 <elliott> hodapp: because it has the advanced module system that Haskell doesn't bother with
09:05:34 <merijn> hodapp: ML has parameterised modules
09:05:36 <xplat> hodapp: modules with signatures
09:05:49 <jmcarthur> hodapp: as in ML functors, not as in the Functor type class or functors from category theory
09:05:54 <elliott> without it, expressing this thing is going to be ugly. probably more ugly than simply not bothering.
09:05:59 <hodapp> huh, I had no idea.
09:06:13 <merijn> elliott: Well, I'd be okay with just passing in a record of actions as way of configuring
09:06:15 <elliott> of course, the downside is that you have to use ML
09:06:18 <Peaker> a parameterized module kinda corresponds (awkwardly) with a type-class given TF's/DF's
09:06:29 <jmcarthur> Peaker: very awkwardly :\
09:06:29 <merijn> But then I'm unsure how to arrange dependencies and package structures
09:06:30 <elliott> keyword awkwardly :)
09:06:39 <elliott> augustss has a good series of blog posts on this topic
09:06:48 <eikke> functors & first-class modules are the only thing I like in ML which I don't have in Haskell
09:06:57 <merijn> elliott: Link?
09:07:03 <xplat> a module (or typeclass) can have things in it that a record can't, but if a record will work then good on you
09:07:04 <elliott> merijn: uh, one second
09:07:16 <Peaker> But if you just want a common interface, you do not necessarily need either an ML functor or a type-class.. maybe a simple set of types to be instantiated by various implementations is enough
09:07:19 <jmcarthur> Peaker: it's like the argument that ocaml has higher kinded types. it doesn't really, because you have to implement everything using functors. each higher order function is encoded as a functor in order to make this claim
09:07:38 <merijn> Peaker: Yes, but I'm unsure how to make that work
09:07:43 <jmcarthur> dependent on the fact that functors can be parameterized on other functors
09:07:51 <Peaker> merijn, what's your common interface?
09:08:24 <xplat> jmcarthur: so higher-order modules stand in for higher-kinded types?
09:08:30 <elliott> merijn: http://augustss.blogspot.co.uk/2008/12/somewhat-failed-adventure-in-haskell.html http://augustss.blogspot.co.uk/2008/12/abstraction-continues-i-got-several.html http://augustss.blogspot.co.uk/2008/12/abstracting-on-suggested-solutions-i.html http://augustss.blogspot.co.uk/2008/12/ocaml-code-again-im-posting-slight.html
09:08:35 <elliott> merijn: that may have gotten cut off.
09:08:37 <merijn> Peaker: I'm once again toying with some GUI stuff and I wanted to have multiple concrete implementations of the interface for creating them
09:08:38 <jmcarthur> xplat: basically
09:09:07 <xplat> jmcarthur: this is similar to the claim that haskell has parameterized modules because it has typeclasses :-/
09:09:15 <elliott> merijn: ended at http://augustss.blogspot.co.uk/2008/12/ocaml-code-again-im-posting-slight.html
09:09:25 <merijn> elliott: Yeah, I got it all, I think
09:10:39 <hodapp> I have never been aware that ML and Haskell differed substantially here.
09:10:43 <hodapp> of course I've hardly touched ML.
09:10:55 <jmcarthur> xplat: yeah, that was what i was trying to highlight
09:11:25 <jmcarthur> hodapp: the module system is, IMO, ML's best claim
09:13:22 <merijn> elliott: augustss stuff seems different for what I want though. I don't actually expect types and data structures to change
09:13:40 <elliott> merijn: well, I don't know your library, of course.
09:13:43 <hodapp> jmcarthur: are they 'modules' in some crazy functional sense that I've never conceived of before, like every other thing I encounter in functional languages that uses a term I've heard before?
09:13:50 <merijn> I just want to change underlying implementation of code
09:14:04 <elliott> hodapp: they're modules as in units of code abstraction.
09:14:39 <hodapp> sounds like 'yes' :P
09:15:19 <merijn> elliott: I'm playing with some GUI type stuff, which is fairly generic and I want it to be able to switch between multiple actual implementations (think terminal, openGL, whatever) preferably without having to change the code using said GUI interface
09:16:35 <merijn> Maybe I can get away with having operations read an implementation from an IORef and calling that, then I can switch implementations by just changing the IORef's content upon some global initialisation or something
09:18:04 <elliott> gross :)
09:18:35 <merijn> elliott: Well, I'm open to better suggestions
09:19:14 <merijn> Having multiple completely redundant implementations of everything seems worse
09:19:29 <b_jonas> merijn: I think some gui toolkits already have multiple backends you can compile to
09:19:31 <hjukih7> hello
09:19:48 <hjukih7> who do i contact to unlift a ban?
09:19:48 <merijn> b_jonas: That doesn't help if I think all current toolkits suck
09:20:13 <merijn> hjukih7: #haskell-ops I think?
09:20:22 <b_jonas> merijn: I see
09:20:37 <merijn> b_jonas: Hence why I'm implementing my own things
09:21:06 <merijn> But I'm interested in terminal stuff as well as non-terminal stuff for some different applications and I expect a bunch of stuff will be portable between both
09:21:15 <merijn> So I'm trying to figure out how to best approach it
09:23:01 <Peaker> merijn, then basically you just need a record like bottle's Widget?
09:23:02 <xplat> merijn: i guess you could make your GUI stuff live in a monad (or monad transformer) and have a typeclass for it that defines all the operations
09:23:17 <Peaker> merijn, and various Widget makers as implementations?
09:23:27 <merijn> xplat: That only works for a monadic interface
09:23:45 <merijn> Maybe I should just start coding and figure it out later
09:23:52 <xplat> merijn: ah, what kind of interface are you going for?
09:24:02 <merijn> xplat: We'll find out!
09:24:16 <Peaker> ok, so using my Dwarf ADT parser/pretty printer, I can see that the hashable debug info in fact did not get into the lamdu executable :( Which is annoying because I get segfaults in the hashable code...
09:24:42 <xplat> ah, yeah, maybe you should make one or two first that switch by a cabal flag or something and see if you can come up with an abstraction mechanism once you know what you're abstracting
09:24:57 <socumbersome> Hi. If we have undef = undef then what is  undef undef ?
09:25:15 <merijn> I'm not sure whether I should have multiple Library definitions in one cabal file or multiple cabal files
09:25:37 <xplat> socumbersome: undef undef = undef undef
09:25:44 <merijn> It seems like it'd be annoying to have everything in one cabal file if you don't want to drag in the dependencies for some interface you're not using
09:26:02 <socumbersome> Well, yeah. But is it true that undef undef = undef ? :)
09:26:48 <Peaker> socumbersome, yeah, _|_ = _|_, but it is undecidable in general
09:27:06 <xplat> socumbersome: if you try to force 'undef undef' then haskell will try to force undef to a function so it can hand the argument in
09:27:12 <darenthis> is there a way to coerce string literals to types? eg. I have newtype Firstname = Firstname String deriving (Eq, Show) and a record data Person = Person {firstname :: Firstname}
09:27:34 <xplat> socumbersome: so it will substitute the first 'undef' with 'undef'
09:27:37 <darenthis> I want to say 'let me = Person "Me"'
09:27:39 <Peaker> darenthis, you can use the OverloadedStrings LANGUAGE extension
09:27:42 <merijn> dcoutts: When will cabal get support for multiple packages per repo? :p
09:27:55 <Peaker> darenthis, that works regardless of any extensions
09:28:05 <Peaker> oh, whoops, it doesn't, sorry
09:28:12 <xplat> socumbersome: (and STG-style implementations will detect the infinite loop with a blackhole and fail yielding an error message, because it's a very simple infinite loop)
09:28:21 <Peaker> darenthis, if you enable OverloadedStrings, and then make an instance IsString Firstname
09:28:28 <Peaker> darenthis, it can work
09:28:32 <eikke> darenthis: you can make an IsString instance for Firstname, and enable OverloadedStrings
09:28:43 <darenthis> great, thanks
09:28:46 <xplat> socumbersome: of course, i am talking operationally, and Peaker is talking denotationally
09:29:02 <socumbersome> Ok, I think I get it : )
09:33:43 <Peaker> Upgraded the hashable library. hopefully this resolves the segfaults.. I've had a lot of trouble from the hashable library :(
09:34:47 <Peaker> first, unsafePerformIO'd effects behind a pure API were added that broke my code... now I'm getting segfaults in hashable
09:35:45 <Peaker> using Haskell for a while, you stop looking for impurity bugs in pure values, so it took a long time to find that one
09:36:09 <xplat> eww
09:37:05 <socumbersome> Is it true that if for all x, y  (f . g) x y = h x y  then f . g = h  ?
09:38:56 <elliott> socumbersome: it is true that if (for all x, f x = g x), then f = g (except when f is _|_ and g is const _|_ (because of seq))
09:39:05 <elliott> you can derive your statement from that -- give it a try :)
09:39:37 <elliott> it is the principle of functional extensionality: that functions are defined only by how they act on inputs. (it is a shame seq breaks it in an edge-case)
09:42:14 <socumbersome> so are we treating  x y  as a one argument here in order to use that principle (because it applies directly to one argument functions, doesn't it? )
09:42:35 <Peaker> seq breaks modularity, too
09:42:38 --- mode: ChanServ set +o elliott
09:42:52 --- mode: elliott set +b *!~elaineben@*
09:42:58 --- kick: hjukih7 was kicked by elliott (ban evasion)
09:43:04 --- mode: elliott set -o elliott
09:46:44 <FreeFull> elliott: How do you differentiate between _|_ and const _|_?
09:46:57 <elliott> FreeFull: seq undefined x = undefined
09:47:00 <elliott> seq (const undefined) x = x
09:47:28 --- mode: ChanServ set +o elliott
09:47:32 --- mode: elliott set +b $a:mrBG
09:47:35 --- mode: elliott set -o elliott
09:49:07 <augustss> Yeah, that's what's bad about seq. :(
09:50:10 <elliott> it's especially annoying because seqing a function for performance reasons isn't totally unreasonable, so even just a Haskell 1.4 style Eval thing wouldn't necessarily be ideal
09:51:38 <dolio> It's pretty seldom that it's useful.
09:51:53 <acube> elliott: What is Eval?
09:51:58 <FreeFull> > seq (const undefined) 3
09:52:00 <lambdabot>   3
09:52:05 <FreeFull> Why?
09:52:10 <dolio> Haskell 1.4 was just as broken, though, because there was a magic instance of Eval for functions that did what it does now.
09:52:12 <Peaker> also, seq is typically used for operational reasons rather than denotational reasons, and it isn't guaranteed to give these operational semantics at all :(
09:52:34 <Peaker> and seq can be used on abstract values, where WHNF exposes implementation details that should not be exposed
09:52:46 <merijn> :t const undefined
09:52:47 <lambdabot> b -> a
09:52:49 <augustss> dolio, what's broken about that?
09:53:00 <FreeFull> :t const 3
09:53:01 <lambdabot> Num a => b -> a
09:53:05 <dolio> It still ruins eta.
09:53:09 <merijn> FreeFull: "const undefined" returns a function, it doesnt evaluate the undefined
09:53:21 <Peaker> any reason to use seq rather than pseq?
09:53:21 <FreeFull> merijn: Oh, I see
09:53:37 <FreeFull> merijn: So seq can allow you to distinguish between functions and bottom
09:53:37 <merijn> Peaker: You don't care about ordering?
09:53:48 <merijn> FreeFull: Not necessarily
09:53:50 <Peaker> merijn, why do you care about your function being more refined?
09:54:07 <Peaker> I guess you might want bottom in your semantics if you use assertions or such
09:54:13 <merijn> > const 3 (seq undefined 3)
09:54:13 <augustss> dolio, yeah, I know seq ruins eta.  But at least Eval tells you where you have been ruining eta.
09:54:14 <lambdabot>   3
09:54:20 <merijn> hell
09:54:24 <merijn> > const 3 (seq undefined undefined)
09:54:25 <lambdabot>   3
09:54:31 <FreeFull> merijn: Well, const doesn't care about its second argument
09:54:38 <FreeFull> So I'd be surprised if you got anything other than 3
09:55:12 <dolio> augustss: Not really. Only in places where the argument to Eval is just a variable.
09:55:15 <elliott> acube: a typeclass
09:55:21 <elliott> class Eval a where seq :: a -> b -> b
09:55:26 <merijn> FreeFull: "seq x y" can be described as "if neither x nor y are bottom, then evaluating, "seq x y" will return y after evaluating both in an unspecified order"
09:55:26 <acube> ah ok
09:55:52 * elliott agrees with dolio that that situation would still be broken.
09:55:57 <acube> @where seq
09:55:57 <lambdabot> I know nothing about seq.
09:56:01 <acube> wow
09:56:07 <elliott> but I would be ok with unsafeSeq####!!! :: a -> b -> b in addition to an Eval class without a function instance
09:56:07 <augustss> dolio, Oh, right.
09:56:09 <merijn> FreeFull: i.e. seq might evaluate x first, it might evaluate y first, it might (theoretically) evaluate both at the same time
09:56:16 <elliott> when you really want the behaviour for functions
09:56:17 <acube> @where laziness
09:56:17 <lambdabot> I know nothing about laziness.
09:56:23 <dolio> strictComp :: (b -> c) -> (a -> b) -> a -> c ; strictComp f g = f `seq` (f . g)
09:56:25 <dolio> And such.
09:56:38 <monochrom> acube: http://www.vex.net/~trebla/haskell/lazy.xhtml
09:56:41 <augustss> dolio, I think the Eval instance for functions should be omitted, and then we could have an unsafeSeq for those who don't care.
09:56:57 <dolio> Yeah, I'd get behind that.
09:57:08 <dolio> We'd have to bring back data type contexts, though. :)
09:57:37 <augustss> dolio, For strict constructors, you mean?
09:57:42 <dolio> Yeah.
09:57:51 <dolio> That's the only real use of them I've ever seen.
09:58:09 <int-e> @index pseq
09:58:10 <lambdabot> GHC.Conc
09:58:21 <augustss> Fine by me.  You don't often put ! on type variables anyway/
09:58:25 <monochrom> pseq is also in Control.Parallel
09:59:18 <elliott> augustss++
09:59:32 <FreeFull> merijn: Well, evaluation order is never defined strictly anyway
09:59:34 <elliott> dolio: might as well just do it GADT-style
09:59:39 <elliott> I guess that has runtime overhead though
09:59:51 <dolio> A little.
09:59:58 <augustss> No it doesn't.
10:00:02 <elliott> or just disallowing cases where the Eval instance can't be resolved for your ! annotation. hey, we already have to repeat ourselves for unboxing...
10:00:10 <elliott> augustss: it will store an Eval dictionary with your data, no?
10:00:13 <FreeFull> With something like (a,b), whatever you access first will get evaluated first
10:00:14 <merijn> FreeFull: The evaluation order of haskell is pretty strictly defined normally!
10:00:14 <elliott> when done GADT-style
10:00:26 <augustss> Eval is special.  There's no need for a dictionary.
10:00:27 <Peaker> Is there any language with explicit Lazy thunks, perhaps sugar to make it easy to get suspended computations as thunks, and polymorphism over whether a function is lazy or not?
10:00:36 <elliott> merijn: the Report doesn't really specify evaluation order
10:00:41 <elliott> augustss: fair
10:00:47 <augustss> Eval would have to be special.  No user instances.
10:00:47 <merijn> elliott: ok, let me rephrase
10:00:57 <elliott> augustss: like Typeable :)
10:00:59 <merijn> GHC haskell has a pretty strictly defined evaluation order
10:01:06 <FreeFull> I don't see why evaluation order would matter that much unless you use something like unsafePerformIO
10:01:17 * elliott tries to imagine the boundless possibilities caused by giving your Eval instance...
10:01:36 <Peaker> map :: Eval l => (a -> b) -> ListT l a -> ListT l b  (for a list with a strict/lazy spine)
10:01:40 <dolio> I guess it could be represented by one of GHC's 0-bit constraint witnesses.
10:01:47 <Zekka> I'm tending to agree with FreeFull here, although it's possible that there's something I'm not understanding here.
10:01:50 <dolio> That just told you it was okay to call seq on something.
10:01:53 <elliott> Peaker: is that a... polykinded eval?
10:02:07 <Peaker> elliott, no no, I should have used a different name
10:02:24 <Zekka> I mean, of course, unsafePerformIO is so cool there's no reason you wouldn't want to use it, but as a general rule I'm not sure how evaluation order is something you have to think about with pure code.
10:02:25 <Peaker> elliott, perhaps the constraint isn't even necessary here.. but the idea is to have l = Lazy or Identity(Strict)
10:02:35 <merijn> FreeFull: It matters for efficiency
10:02:40 <elliott> Peaker: oh, I see
10:02:49 <merijn> FreeFull: How else would you reason about how efficient a computation is in haskell?
10:02:50 <elliott> FreeFull: Zekka: performance
10:03:07 <Peaker> Having polymorphism about whether you're lazy or not doesn't seem so hard -- so I wonder if any language tried this approach pervasively
10:03:21 <Zekka> You've got a point in that case.
10:03:52 <merijn> Zekka, FreeFull: laziness let's you reason that "map f . map g" only traverses the list once
10:05:28 <FreeFull> Peaker: idris is strict by default, but allows you to have lazy functions
10:05:39 <Peaker> FreeFull, I want a function to be either lazy/strict based on user choice
10:05:50 <Peaker> rather than write it twice
10:06:01 <copumpkin> there are many different ways to be lazy/strict
10:06:12 <FreeFull> Peaker: I think that could be possible with a lazy id function
10:06:40 <Peaker> copumpkin, precise types could help, or perhaps some cases would still be uncovered
10:06:54 <Peaker> copumpkin, there are many ways for a function to be impure, too, and we have precise types for the various ways
10:07:39 <monochrom> evaluation order matters when you ask "but why foldl (+) 0 xs uses so much memory"
10:08:57 <augustss> Peaker, precise types are not enough.  There are expressions internal to a function that can be strict or lazy that don't show up in the type (in any sensible way).
10:09:24 <Peaker> augustss, Can you give an example?
10:09:57 <augustss> f x = [x, length [1..] > 0]
10:10:18 <augustss> How do you indicate how you want length to be computed?
10:10:56 <FreeFull> You know, I wish Haskell was smart enough for    length [1..] > 0  to terminate
10:11:21 <augustss> FreeFull, It is if you use lazy naturals.
10:11:21 <FreeFull> I guess you could potentially do it with Nats
10:11:23 <Peaker> f :: Bool -> ListT l1 (l2 Bool)    where l2 may be lazy or strict, to force the list values or not, perhaps?
10:11:42 <augustss> f x = fst (x, length [1..] > 0)
10:11:55 <FreeFull> augustss: That's id
10:12:22 <augustss> Yes, in Haskell.  But not with strict pairs.
10:12:34 <Peaker> augustss, so I guess cases where the function makes up a value, and then (in some cases) throws part of it away?
10:12:45 <augustss> Peaker, yes
10:12:58 <augustss> Or uses it in some way.
10:13:16 <Peaker> well, then either the function can be non-polymorphic about laziness/strictness of that computation, or perhaps it could use a Proxy type to control it
10:13:45 <augustss> That's why I put "(in any sensible way)" in my first statement.
10:14:11 <augustss> Peaker, It will be quite ugly and difficult with all these proxies.
10:14:22 <Zekka> When do you think it would it be useful to alter how strictly a function performs that kind of computation?
10:14:57 <Zekka> I have a feeling you have a stronger idea than I do about the implications of Peaker's idea.
10:15:00 <Peaker> augustss, well, maybe you don't need that much fine-grained control, only control over the computation of the direct function outputs
10:15:20 <xplat> argh
10:15:23 <augustss> Peaker, I don't know.
10:15:51 <xplat> i hit 'update (something) for workspace' on the leksah toolbar and now it looks like it's frozen
10:15:56 <dolio> It already looks pretty ugly with everything parameterized in 2+ different ways. :)
10:15:59 <Peaker> augustss, a large body of functions (map, filter, ...) would not need to have a lazy version and a strict version
10:16:14 <copumpkin> I think we need a variable-strictness version of Pipes
10:16:16 <augustss> Why not?
10:16:20 <copumpkin> so we can get up to 15 type parameters
10:16:27 <copumpkin> 7 just isn't enough
10:16:40 <Peaker> augustss, because for these functions, controlling laziness via the effective output type works, unless I'm missing something
10:16:43 <augustss> There must be some simple way to double that.
10:16:54 <Zekka> I attempted to use Leksah briefly but didn't enjoy working with it.
10:16:55 <elliott> copumpkin: I like how it doubled *and* grew another one
10:17:01 <Zekka> ended up working in Vim.
10:17:08 <copumpkin> well, you need to be able to decide if the pipe itself is strict
10:17:12 <copumpkin> as well as all of its type parameters
10:17:32 <augustss> Peaker, Quite possibly.  Since I don't really know what system you have in mind. :)
10:17:54 <Peaker> augustss, btw, I don't recall if I thanked you for the "Simpler, Easier" blog posts and lambda cube stuff you wrote.. So thanks! :) We learned all the System F theory primarily from that, that we're using for the lamdu IDE
10:18:13 <Peaker> augustss, so much more approachable than the various greek/English hybrid papers :)
10:18:22 <copumpkin> quick, everyone apply peer pressure to augustss to get him blogging again
10:18:23 <copumpkin> that'll work!
10:19:29 * monochrom has a cunning plan
10:19:43 <elliott> I nominate augustss for president
10:19:51 <copumpkin> BDFL?
10:19:59 <int-e> copumpkin: peer pressure? you mean we should all start our own blog?
10:20:09 <copumpkin> nah, just lazy annoyance in IRC
10:20:20 <int-e> copumpkin: that's so dishonest though
10:20:42 * monochrom was thinking exactly that "peer pressure" means I compete with augustss in producing articles
10:20:46 <copumpkin> lol
10:20:53 <Zekka> Well, IRC is kind of like a blog in that it's above twitter on the verbosity scale and lots of people read it without commenting.
10:21:34 <monochrom> "with IRC like this, who needs enemies?"
10:21:52 <merijn> Is ArrowCircuit a deprecated name for ArrowLoop?
10:22:03 <joe9> what is system F for?
10:22:34 <Peaker> joe9, Extending the lambda calculus with parameteric polymorphism
10:22:46 <monochrom> I think ArrowCircuit subclasses ArrowLoop to add something for things like electronic circuits
10:22:56 <xplat> how do you even manage to get a frozen UI with no CPU use and no swapping?
10:23:13 <monochrom> threadDelay can do that
10:23:25 <copumpkin> xplat: deadlock of some sort perhaps?
10:23:30 <xplat> if the UI thread dies it seems like the UI should close ...
10:23:49 <Peaker> xplat, frozen temporarily or forever?
10:23:51 <monochrom> therefore it hasn't died
10:24:01 <geekosaur> or, blocked on an external program that is sleeping on a lock, or reading from a terminal that you started the original program from but are not using, or etc.
10:24:17 <geekosaur> (I am considering context here)
10:25:11 <monochrom> it is very easy to write a gtk program (or a windows program, or...) that idles and is unresponsive
10:27:55 <merijn> Sounds like an Alderson loop
10:30:03 <int-e> xplat: the program may be blocked reading from a socket with no data available. (should be typical for X11 toolkits)
10:30:40 <external-reality> why is stateT not an instance of MonadState
10:30:42 <external-reality> ??
10:30:50 <merijn> It is
10:31:07 <external-reality> It doesn't say that in the docs
10:31:12 <int-e> instance Monad m => MonadState s (StateT s m)
10:31:12 <int-e>   -- Defined in `Control.Monad.State.Class'
10:31:34 <merijn> "Monad m => MonadState s (StateT s m)"
10:31:38 <xplat> Peaker: well, it's still frozen, so i'm conservatively guessing 'forever'
10:31:40 <merijn> external-reality: It does, in the MonadState docs
10:31:47 <int-e> If in doubt, ask ghci (:m +Control.Monad.State  then  :i StateT)
10:32:20 <xplat> it's probably one of these things
10:32:36 <external-reality> Oh, yes it is. I see now.
10:32:43 <external-reality> Thx guys
10:32:52 <ksf_> since when is having an instance (Foo,Bar) Baz and calling it with Bar and Baz fixed ambigious in Foo?
10:33:08 <xplat> there's a 'leksah-server' with 6 kids
10:33:08 <elliott> monochrom: I believe the next Cabal will support building source-linked documentation by default by editing your ~/.cabal/config
10:33:31 <xplat> maybe ti's waiting for that, but then why is that frozen with the socket still open?
10:33:33 <ksf_> and is there an extension I can use to get around messing with my source?
10:33:50 <elliott> ksf_: you could also have (Quux,Bar) Baz.
10:33:51 <ksf_> that's annoying, because I really don't care about Foo
10:33:55 <monochrom> that's good to hear, elliott
10:34:00 <elliott> you can set a fundep on your class
10:34:06 <elliott> or change the instance to use a ~ constraint
10:34:10 <ksf_> *but it once worked*
10:34:18 <elliott> monochrom: basing this claim on https://github.com/haskell/cabal/commit/12285275ae1a6d0f983e5ae1f76a432dfccee1bb
10:34:30 <ksf_> hmm. wait. there might've been a fundep and shake removed it.
10:34:34 <xplat> this version of gnome's wm doesn't seem to have a way to kill unresponsive windows ...
10:34:51 <ksf_> maybe I should newtype my tuple.
10:35:05 <geekosaur> xplat, if it did it probably wouldn't work
10:35:47 <geekosaur> since the way you "kill" windows in x11 is by using XKillClient() which causes the server to drop its connection to the client. and if it's not processing events it probably wouldn't notice
10:35:50 <xplat> geekosaur: true, because they probably would have removed the one that worked and rewritten it
10:36:31 <xplat> geekosaur: oh, and maybe that too
10:37:11 <elliott> you can just look up the process responsible for the window, right?
10:37:12 <elliott> and kill that
10:37:23 <geekosaur> (no, you can't reliably map a window to a process id. for one thing there might not be one. for another, there may be many windows sharing a process id [terminal factories, etc.] or it could be on a remote system via X11 network transparency or ssh x11 forwarding or etc.)
10:37:25 <Peaker> xplat, you could try to strace -p it
10:37:46 <elliott> well, at least presumably for a terminal factory, one frozen window implies they're likely all frozen
10:37:47 <Peaker> xplat, there's the "xkill" program that lets you target any window to kill
10:37:58 <xplat> anyway, i did all this with leksah just so i could browse some source with hyperlinked definitions, but that feature didn't seem to work anyway
10:38:01 <geekosaur> Peaker, that does XKillClient as I earlier described
10:38:40 <geekosaur> it's completely useless against a client that isn't processing events
10:38:45 <xplat> Peaker: if i'm going to do it from the terminal i may as well use 'killall' anyway
10:39:14 <xplat> geekosaur: some clients wake up when you kill their X11 socket even if they're otherwise frozen, but yes, you have a point
10:39:15 <Peaker> geekosaur, I thought it kills the process too, perhaps indirectly by causing it to get a SIGPIPE signal or such? At least I've seen that happen in some cases
10:39:34 <monochrom> kill the processes themselves.
10:39:38 <geekosaur> SIGPIPE only if it tries to write to the server
10:39:44 <Peaker> xplat, alt-f2, xkill   is nicer than a terminal, typing process name, etc
10:40:08 <danbst> Hello guys. I have piece of code http://hpaste.org/89966 . It has two different implementations of some function - verbose and concise. I'd like to use smaller version, but it has partial `fromMaybe`. I'm curious if there is some type-safe (or type level) trick to write such a small function without partial components. Can you point me it, or using partial functions is good?
10:40:59 <Peaker> geekosaur, another option is that I've leaked bad processes that didn't bother me :)
10:41:12 <elliott> danbst: I vastly prefer the original function. if you really want to make it shorter, how about this:
10:41:34 <elliott> danbst: index = f where f EAX = 0; f ECX = 1; f EDX = 2; f EBX = 3
10:42:03 <Peaker> danbst, "deriving Enum" gives you toInt
10:42:05 <xplat> danbst: that use of 'fromJust' should be safe, but you could also just add 'Enum, ' to deriving and use fromEnum for index'
10:42:13 <Peaker> danbst, "fromEnum", that is
10:42:18 <xplat> as in 'index' = fromEnum'
10:42:19 <monochrom> danbst: I have a cunning plan. data R32 = EAX | ... | EDX deriving (Eq, Enum).
10:42:59 <danbst> elliott, there is also another type - data R8 = AL | CL | DL | BL | AH | CH | DH | BH | SPL | BPL | SIL | DIL . It will be too verbose...
10:43:21 <xplat> of course, you have to list your registers in the 'right' order in the datatype definition
10:43:25 <elliott> you say too verbose, I say too readable if it'll look anything like your second version! but yes, monochrom has it right
10:43:31 <geekosaur> danbst, really you want deriving Enum
10:44:09 <danbst> monochrom, Peaker, thanks
10:44:36 <ksf_> ...and now that I've replaced tuples with explicit data stuff all my zipping and unzipping breaks.
10:44:36 <ksf_> nice.
10:44:43 * ksf_ hopes there's a typeclass for that.
10:44:56 <ksf> If in doubt, throw a typeclass at it.
10:45:23 <xplat> ksf: zipWith
10:45:26 <Peaker> terrible advice.. if anything, newbies use too many type classes
10:45:33 <ksf> xplat, nah.
10:45:43 <ksf> I need unzip
10:46:30 <xplat> ksf: spend the two lines to write unzipWith, or import it from somewhere if you can find it
10:46:52 <elliott> unzipWith f = unzip . map f?
10:46:57 <FreeFull> What would the type of unzip be?  [(a,b)] -> ([a],[b])?
10:46:58 <elliott> barely deserving of a name
10:47:03 <elliott> :t unzip
10:47:04 <lambdabot> [(a, b)] -> ([a], [b])
10:47:43 <FreeFull> unzip = map fst *** map snd     right?
10:48:00 <danbst> by the way, typeclasses. I want to eliminate one typeclass, but don't know how. http://hpaste.org/89969 . Is it `code smell` to use typeclasses in such problems?
10:48:09 <ksf> hmm wait. I could just write a monoid instance.
10:48:09 <xplat> FreeFull: tends to be more efficient though
10:49:19 <monochrom> "data R64 = ..." will also be pretty spectacular :)
10:49:29 <FreeFull> xplat: Probably a foldl' then
10:50:21 <elliott> danbst: regToIndex is just fromEnum if you do the deriving thing
10:50:26 <xplat> danbst: your IsReg is just a duplicate of Enum that seems to exist only to let you write the data definitions in alphabetical order
10:50:29 <elliott> well, fromIntegral . fromEnum, I guess.
10:50:55 <danbst> oh sure! now got it!
10:51:10 <xplat> danbst: (except that RSeg is still not in alphabetical order)
10:52:11 <xplat> i'm sure there's a lovely shaggy dog story explaining how the registers came to be numbered in that order too ...
10:52:43 <danbst> xplat, alphabetical order in data definition is unnecessary?
10:52:51 <monochrom> danbst will have to decide the order. all we can suggest is "deriving Enum"
10:53:23 <xplat> monochrom: i think the indexes here are probably defined by IA32 ...
10:54:07 <geekosaur> alphabetical order is not necessary
10:54:26 <geekosaur> or even desirable sometimes (data Maybe a = Nothing | Just a)
10:55:11 <danbst> many thanks, again =)
10:56:46 <schoppenhauer> out of my current frustration: https://blog.uxul.de/e?e=lazyeval *advertize*
10:57:08 <xplat> actually i can completely see where the 'BX last' convention came from (BX was the only 8086 register with no special functions, it was probably an afterthought) but the one that really mystifies me is ES=0
10:57:54 <geekosaur> not an afterthought
10:58:44 <geekosaur> 8086 registers evolved from 8080 registers. they just didn't come up with a special function to use the extended version with
10:59:24 <xplat> geekosaur: so they thought of it ... after the 8080 registers
10:59:49 <aristid> xplat: so it's a thought-after, not an afterthought!
11:00:02 <xplat> and just called it 'BX' because they already had A, C, and D?
11:00:12 <geekosaur> ...
11:00:39 <geekosaur> I guess if you'd prefer your version of history to the real one, go ahead
11:00:46 <xplat> hm, no, 8080 has already got a B register
11:01:03 <aristid> hmm
11:01:15 <aristid> does that mean that "EAX" stands for "extended A extended"?
11:01:22 <geekosaur> yep :)
11:01:25 <aristid> lol
11:01:27 <xplat> it's a very strange version of 'extended' where you somehow drop 3 registers
11:02:00 <aristid> xplat: there's just so much place on a chip for huuuge 16-bit registers
11:02:41 <xplat> and where A pairs with D instead of flags
11:04:28 <geekosaur> wut
11:05:44 <xplat> ... how is 8086 assembly-language compatible with 8080?!?!
11:06:26 <geekosaur> it's not source compatible but it was easy to write minimal translators (that didn't take advantage of the 8086's extensions over the 8080)
11:06:28 <ksf> somehow haskell seems to cater towards dependency explosion.
11:07:59 <geekosaur> there were even a few assemblers that took 8080 source and generated said minimally converted 8086/8088 machine code, although they weren't that popular; mostly used by companies to rush out first versions while they retooled for the new CPU
11:08:45 <ksf> s/([abcd])/\1l/g
11:08:47 <geekosaur> ...and not as much of that as you might exect either since the original belief had been that CP/M would be dominant on 8086/8088 as it had been on 8080/Z80
11:10:21 <xplat> i wonder how history would have been different if that IBM procurement guy had decided to go with arrogant douchebag instead of backstabbing weasel for the OS
11:10:44 <ksf> should've gone with Sun.
11:10:59 <geekosaur> might as well ask how it would have been different if they'd gone with the 68000 instead of the 8088
11:11:19 <geekosaur> (which they did consider seriously, but motorola missed a few shipping deadlines and they punted)
11:11:41 <ksf> did ARM exist back then?
11:12:18 <xplat> geekosaur: that would be an interesting difference too ...
11:12:24 <merijn> ksf: You say dependency explosion, I say code reuse :p
11:12:52 <ksf> nah, it's really explosion. every package uses something different.
11:13:00 <ksf> which is essentially doing the same thing.
11:13:08 <merijn> ksf: Like?
11:13:11 <tunixman> ARM started in 83, but I think ARM as licensable IP came much later: https://en.wikipedia.org/wiki/ARM_architecture#Acorn_RISC_Machine:_ARM2
11:13:12 <geekosaur> no. somewhat ironically given the current state of ARM, a large part of the reason for its existence was fear of the Intel processor hegemony that resulted from the way the IBM PC and clones took off
11:13:22 <ksf> well, just take the gazillions of pretty printers and parsers.
11:13:41 <ksf> we barely scraped past desaster with that mtl thing.
11:14:10 <merijn> Not everyone needs the same thing from their parsers
11:14:46 <xplat> gazillions?  doesn't almost everybody use either parsec or attoparsec for parsing unless it's a main focus of their app or they are edwardk?
11:14:58 <ksf> hey. I like trifecta.
11:15:10 <geekosaur> a lot of the divergence in parsers is less practicality and more research
11:15:20 <ksf> uu-parsinglib also has its reasons.
11:15:26 <geekosaur> but that state of things has settled down a bit
11:15:27 <xplat> ksf: sure, trifecta's great, but not many people use it to parse random config files and batch commands
11:15:52 <Cale> xplat: I like ReadP for some things
11:16:00 <Cale> (particularly for writing Read instances!)
11:16:09 <xplat> Cale: readP hardly even counts :)
11:16:22 <ksf> Read is the devil.
11:16:40 <xplat> not sure who uses uu-parsinglib
11:16:47 <ksf> ...parsing a human-writeable format with such a thing isn't a good idea.
11:16:57 <ksf> dutch people.
11:17:08 <byorgey> xplat: presumably the people working on UHC.
11:17:19 <ksf> and everyone who needs error correction
11:17:39 <byorgey> yes, I hear nice things about uu-parsinglib, haven't had a chance to try it myself.
11:18:58 <chrisdone> you can probably unmute hpaste now
11:19:05 <zvrba> hello
11:19:15 --- mode: ChanServ set +o elliott
11:19:19 <zvrba> I'm running hoogle data on windows 8 and get this error: gzip: ..\hackage-cabal.tar.gz: No such file or directory
11:19:22 --- mode: elliott set -q hpaste!*@*
11:19:23 <xplat> i'd actually prefer it if parsec dropped off the face of the earth, myself, it has neither the luxury appointments of trifecta, the blazing speed of attoparsec nor the mathematical saneness of good old parser generators
11:19:36 <zvrba> I have installed the previous version of haskell platform
11:19:37 <chrisdone> elliott =)
11:19:46 <elliott> I actually don't know if that was the +q set. in fact I don't even know how to check what +qs are set, embarrassingly!
11:19:54 <elliott> let's test
11:19:55 <zvrba> any suggestions on how to fix that_
11:20:08 <chrisdone> it's still unable to send anything
11:20:10 <elliott> apparently not. just made a paste
11:20:11 <zvrba> haskell platfor 2012.4.0
11:20:19 <int-e> /mode #haskell +q
11:20:23 <chrisdone> it might be a ban, one of those no-talky bans
11:20:24 <int-e> lists them al
11:20:32 <elliott> right it's a +q. thank you int-e!
11:20:43 --- mode: elliott set -q *!*hpaste@*
11:20:46 <hpaste> \o/
11:20:52 <geekosaur> hee
11:20:57 --- mode: elliott set -q $a:mrBG
11:21:12 --- mode: elliott set -o elliott
11:21:50 <elliott> mauke: hi
11:23:09 <byorgey> zvrba: maybe this is relevant? http://code.google.com/p/ndmitchell/issues/detail?id=609
11:23:28 <xplat> okay, so what's a good way to view haskell source with some kind of definition hyperlinks?
11:23:34 <byorgey> zvrba: also this: http://stackoverflow.com/questions/7523151/hoogle-data-on-windows
11:23:47 <byorgey> I just found those by googling the error message, I have no idea myself
11:24:07 <mauke> elliott: http://mauke.hopto.org/stuff/irssi/whyban.pl
11:24:28 <elliott> mauke: how many ban-related scripts do you have?!
11:26:01 <mauke> elliott: at least 6
11:26:40 * elliott can't figure out what that one is doing
11:26:40 <zvrba> byorgey: hm, thanks
11:27:27 <mauke> elliott: tells you which bans/quiets apply to a given user
11:27:53 <elliott> ah, ok. I didn't make the connection to "why'
11:27:54 <elliott> *"
11:27:57 <mauke> it was written to answer the question "why can't I join/talk in channel #foo?"
11:28:21 <chrisdone> get banned a lot, do you? ;-P
11:28:40 <mauke> it wasn't my question
11:28:45 <elliott> more like bans a lot :P
11:28:49 <mauke> but I used to hang out in #freenode
11:29:25 <danbst> guys, one more Registers question. Is it idiomatic Haskell to use typeclasses as constraints like in http://hpaste.org/89971 ?
11:30:33 <chrisdone> sure
11:31:08 <merijn> danbst: Yeah, I've seen a bunch of libraries do that
11:31:39 <elliott> danbst: I would just define fromEnum8
11:32:19 <byorgey> danbst: looks nice to me
11:32:33 <danbst> ellott what about defaultModRM? I don't want to use Enum constraints there
11:32:54 <elliott> danbst: why not? you already have an Enum constraint, implied by the IsReg constraint, and it looks like you only use that function internally (i.e. no reason to export it)
11:34:21 * ksf wonders why shake dropped that fundep in Rule
11:35:12 <danbst> elliott, I'm practicing type safety currently, I'd like to see more type constraints in code now
11:36:00 <xplat> ksf: i thought shake was a buildtool, how could it even do that?
11:36:06 * byorgey disagrees with elliott 
11:36:46 <byorgey> I think it's quite nice to have an IsReg class which (a) restricts instances to only be Register-y things and not arbitrary Enum things, and (b) makes the types more perspicuous
11:36:50 <elliott> well, I'm all for type safety, just don't personally see the point here. if IsReg had methods I might agree
11:37:00 <elliott> or if this stuff was exported as a public API
11:37:39 <elliott> haha, lambdabot defines an arePrefixesWithSpaceOf function in a utility module and then proceeds to use it exactly one time in the entire rest of the codebase...
11:37:45 <byorgey> even if it's only internal, it's nice.  After all, you are exporting the internal API to your future self.
11:38:06 <byorgey> might as well give your future self the most precise, helpful types you can.
11:38:29 <xplat> could do 'makeModRM :: (IsReg a) => a -> a -> Word8'
11:38:48 <danbst> xplat, sure, thanks!
11:38:50 <elliott> byorgey: fair enough. my claim is more that there's a function with an overly-specific name and type, I guess :)
11:38:52 <chrisdone> seems a bit premature to comment on architecture until there's an actual working program
11:39:40 <xplat> danbst: what is the purpose of SomeOtherPair anyway?
11:39:52 <ksf> xplat, it changed its source.
11:39:58 <ksf> *its*, that is, not any other.
11:40:23 <xplat> ksf: oh, so the shake maintainer did away with it
11:40:28 <zvrba> byorgey: ok, that seemed to work. MinGW and msys are broken. by design :S
11:40:56 <danbst> xplat, there will be Reg32RMPair R32 SIB Displacement instead, but I simplified example
11:41:36 <xplat> SIB?
11:42:20 <danbst> SIB - scale index base
11:42:47 <xplat> danbst: are you working from a specific document?
11:43:48 <danbst> xplat, I'm refactoring existing code, https://github.com/EarlGray/language-snippets/blob/master/x86/hasm.hs
11:44:35 <ksf> speaking of earl grey
11:59:19 <merijn> If you'd want to write something like "Arrow a => a (forall b . Foo b) c" I'd need ImpredicativeTypes, right? If yes, how bad of an idea is that? I heard ImpredicativeTypes is a fairly shaky extension?
11:59:56 <elliott> yes, and I think you're basically not meant to use it at all
12:00:00 <elliott> I think it was slated for removal at one point?
12:00:14 <merijn> That's the answer I was afraid of
12:01:40 <merijn> Maybe I can get what I want using typefamily abuse
12:07:26 <ksf> is there a library function that does what unix tr does?
12:07:58 <monochrom> not exactly
12:08:07 <jmcarthur> which functionality of tr?
12:08:22 <ksf> say, replacing dots with slashes.
12:08:36 <monochrom> is that "map"?
12:08:36 <jmcarthur> you could always just use map, no?
12:08:38 <ksf> a selective map.
12:08:41 <ksf> yep it's a map.
12:09:06 <monochrom> give map a selective function. map (\c -> if ... then ... else c)
12:09:23 <merijn> Is there a way to silence the "main = undefined"
12:09:26 <merijn> hmm
12:09:29 <merijn> copy+paste fail
12:09:48 <merijn> Is there a way to silence the "The function `main' is not defined in module `Main'" error from hdevtools?
12:09:58 <monochrom> I add "module F where" to silence that. change F to match filename
12:10:16 <monochrom> oh hdevtools, nevermind, I don't know hdevtools
12:10:57 <merijn> monochrom: Yeah, right now I add that or "module F where" but it's kinda annoying to have to do that everytime you open a scratch haskell file
12:11:42 <ksf> :t let tr xs ys = let zs = zip xs ys in map (\x -> maybe x id $ lookup x zs)
12:11:43 <lambdabot> <no location info>:
12:11:44 <lambdabot>     not an expression: `let tr xs ys = let zs = zip xs ys in map (\x -> maybe x id $ lookup x zs)'
12:11:52 <ksf> damn you.
12:12:01 <ksf> :t \xs ys -> let zs = zip xs ys in map (\x -> maybe x id $ lookup x zs)
12:12:03 <lambdabot> Eq b => [b] -> [b] -> [b] -> [b]
12:12:11 <joelteon> wowzer
12:12:35 * hackagebot non-empty 0.1.2 - List-like structures with static restrictions on the number of elements  http://hackage.haskell.org/package/non-empty-0.1.2 (HenningThielemann)
12:12:43 <chrisdone> you can cheat if you want where
12:12:45 <ksf> > (\xs ys -> let zs = zip xs ys in map (\x -> maybe x id $ lookup x zs)) "ab" "xy" "ab84aba2a3ba3"
12:12:47 <lambdabot>   "xy84xyx2x3yx3"
12:12:47 <chrisdone> > let in x where x = 123
12:12:49 <lambdabot>   <hint>:1:10: parse error on input `where'
12:13:10 <chrisdone> ah, that didn't go as planned
12:13:11 <monochrom> "cheating is forbidden" :)
12:13:34 <chrisdone> should've realised that wouldn't work having spent so much time starting at haskell ASTs
12:14:20 <ksf> ...optimising the whole thing to use a map is left as an exercise to the heavy replacer.
12:14:44 <monochrom> @type fromJust
12:14:46 <lambdabot> Maybe a -> a
12:14:51 <monochrom> err sorry
12:14:53 <monochrom> @type fromMaybe
12:14:54 <lambdabot> a -> Maybe a -> a
12:15:26 <monochrom> (\x -> fromMaybe x (lookup x zs))
12:16:05 <monochrom> zs = fromList (zipWith xs ys)
12:17:28 <ksf> "maybe id" is shorter than "fromMaybe".
12:17:32 <ksf> by a whole character.
12:17:43 <monochrom> I prefer to count tokens
12:18:15 <ksf> I don't, ever since I got a second monitor to fit java identifiers on one line.
12:18:15 <monochrom> I am a bean counter, not a byte counter
12:18:48 <monochrom> then the blame is on the religion of "meaningful identifiers"
12:19:07 <monochrom> MeaningfulIdentifierAbstractFactory
12:20:10 <chrisdone> anyone know a way in bash to lazily read from a pipe and execute a command for each line received?
12:20:12 <Fuuzetsu> Only one level factory?
12:20:36 <amadeus> ciao
12:22:41 <arkeet> :t maybe id
12:22:42 <lambdabot> (a -> a1 -> a1) -> Maybe a -> a1 -> a1
12:22:56 <arkeet> :t maybe??id
12:22:58 <lambdabot> b -> Maybe b -> b
12:24:21 <chrisdone> :t (??)
12:24:22 <lambdabot> Functor f => f (a -> b) -> a -> f b
12:24:45 <chrisdone> :t (<*>)
12:24:46 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:24:59 <chrisdone> where does (??) come from?
12:25:20 <chrisdone> @hoogle (??)
12:25:21 <lambdabot> No results found
12:25:22 <elliott> lens
12:25:29 <chrisdone> oh ok
12:25:36 <copumpkin> Cale used to call it flip
12:26:05 <Cale> (ski suggested that)
12:26:39 <merijn> @hoogle Arrow a => [a b c] -> a b [c]
12:26:40 <lambdabot> Graphics.Rendering.OpenGL.GL.IOState nTimes :: Integral a => a -> IOState b c -> IOState b [c]
12:26:40 <lambdabot> Data.Graph.Inductive.Query.Dominators dom :: Graph gr => gr a b -> Node -> [(Node, [Node])]
12:27:04 <geekosaur> hayoo knows of several such operators but none with that signature
12:27:48 <byorgey> merijn: that's just  sequenceA if you have an instance  Applicative (a b)
12:27:54 <byorgey> which is often the case for arrow instances
12:28:13 <byorgey> (or at least often *could be* the case)
12:28:41 <merijn> :t sequenceA
12:28:42 <lambdabot>     Not in scope: `sequenceA'
12:28:42 <lambdabot>     Perhaps you meant one of these:
12:28:42 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
12:28:51 <merijn> :t Data.Traversable.sequenceA
12:28:52 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
12:29:09 <merijn> byorgey: That one?
12:29:56 <byorgey> yep
12:30:13 <merijn> Looks like I do have an applicative \o/
12:31:36 <byorgey> excellent =)
12:33:54 <xico> chrisdone: while/read?
12:35:21 <merijn> Can data families have multiple constructors? Or is that a silly question?
12:35:34 <elliott> instances of data families can, yes
12:35:46 <merijn> Yeah, that's what I meant
12:35:50 <merijn> Neat
12:35:51 <elliott> IIRC you can also have newtype instances
12:36:09 <monochrom> yes
12:36:45 <merijn> Yes
12:37:02 <monochrom> examples: http://hpaste.org/83483
12:43:10 <merijn> Yeah, in hindsight I think I just want GADTs, like always
12:43:36 <merijn> Is there any utility of data families that can't be subsumed by GADTs?
12:43:39 <xico> is there a better way to write "a >>= \s -> (f $ g s)"?
12:43:53 <mauke> @pl a >>= \s -> (f $ g s)
12:43:53 <elliott> a >>= f . g
12:43:56 <lambdabot> a >>= (f $) . g
12:43:56 <lambdabot> optimization suspended, use @pl-resume to continue.
12:44:05 <elliott> I wonder what broke @pl.
12:44:10 <mauke> @pl-resume
12:44:15 <xico> elliott: thanks!
12:44:16 <lambdabot> a >>= (f $) . g
12:44:16 <lambdabot> optimization suspended, use @pl-resume to continue.
12:44:46 <Cale> merijn: Data families are open, meaning that you can add to the definition in future modules, which is something that can't be done with GADTs
12:45:06 <int-e> @pl (f $)
12:45:07 <lambdabot> f
12:45:22 <int-e> @pl f >>= g .h
12:45:25 <lambdabot> f >>= g . h
12:45:25 <lambdabot> optimization suspended, use @pl-resume to continue.
12:45:30 <chrisdone> xico: n/m ended up just patching the program i wanted to pipe from
12:45:47 <merijn> Cale: oh, right
12:47:37 * hackagebot non-empty 0.1.3 - List-like structures with static restrictions on the number of elements  http://hackage.haskell.org/package/non-empty-0.1.3 (HenningThielemann)
12:49:52 <xico> what's behind lambdabot's @pl?
12:50:02 <joshc> the pointfree gnome
12:50:09 <merijn> I have two distinct classes of events, with some operations that work on one, some that work on the other and some that work on both. The first two cases are simple to handle with some phantom types, but that ruins the latter cases as it becomes impossible to write functions that accept both
12:50:22 <merijn> (As that would need ImpredicativeTypes)
12:50:33 <xico> joshc: there is even a haskell pkg for it!
12:50:51 <merijn> xico: I believe it is based on the paper "Theorems for free!"
12:51:24 <xico> merijn: i will definitively read that
12:51:26 <shachaf> No, that's @free.
12:51:28 <ksf> \o/ trifecta doesn't change its behaviour due to arbitrary refactoring.
12:51:34 <ksf> it was me being dense, all along.
12:51:43 <merijn> shachaf: I stand corrected, what's the basis for @pl?
12:52:01 <merijn> And does anyone have any ideas for my problem?
12:52:05 <joe9> is there a way to find the size of a haskell data structure?
12:52:15 <merijn> joe9: Define size?
12:52:39 <merijn> Or rather, maybe define "data structure"...
12:52:46 <joe9> number of bytes that the data structure would occupy. there are no lists in that, merjin.
12:52:56 <shachaf> merijn: It isn't a vector space, so it doesn't need one.
12:53:11 <joe9> i convert all the contents of the data structure to [Word8] and then do length on it.
12:53:17 <geekosaur> joe9, not meaningfully in most cases. if you want to serialize it, you probably wan Storable which has functions to tell you the serialized size of a serializable type
12:53:38 <joe9> merjin, just wanted to check if there is an easier way of going about it.
12:53:41 <joe9> geekosaur: ok, thanks.
12:54:14 <geekosaur> as for @pl, see http://www.haskell.org/haskellwiki/Pointfree
12:54:15 <shachaf> merijn: I mean, you could talk about one of the combinatory logic things, I guess.
12:55:05 <shachaf> merijn: It's an optimizing compiler from a subset of Haskell with named arguments to a subset of Haskell without them, with a lot of heuristics.
12:55:30 <ksf> joe9, when it comes to figuring out how big  astructure is in memory that's more involved.
12:55:38 <elliott> merijn: can your vim indent stuff be made to not align with the constructor name when I say "data Foo = Bar" and hit enter?
12:55:43 <elliott> I'd prefer to get an indent instead.
12:56:26 <merijn> elliott: It could, I'll add it to my todo list for tomorrow
13:03:56 <meditans> Hi, I constructed the monad "StateT ... (SupplyT ... (Rand StdGen)) a" but, when I try using fromList, it complains this monad is not instance of MonadRandom. Why is this?
13:04:33 <preyalone> I'm trying to derive Binary for message data types in Cloud Haskell, but GHC complains "No instance for (Binary ProcessId)". Yet, the docs say ProcessId DOES have this instance. http://hackage.haskell.org/packages/archive/distributed-process/latest/doc/html/Control-Distributed-Process.html
13:04:42 <geekosaur> because either you need to lift to reach the Rand or you need to derive MonadRandom through your stack
13:05:08 <shachaf> preyalone: Have you checked your version?
13:05:44 <shachaf> OK, that's not an issue.
13:05:45 <preyalone> shachaf: distributed-process 0.4.2 (latest), on GHC 7.6.3.
13:05:57 <meditans> geekosaur: is there an automated way to derive the instance through the stack?
13:05:58 <shachaf> Have you @pasted your full code and full error message?
13:07:16 <preyalone> Code: https://github.com/mcandre/parhello/tree/master/haskell/parhello-actors
13:07:21 <preyalone> Error: https://gist.github.com/mcandre/5789433
13:07:55 <byorgey> meditans: the problem there would be SupplyT
13:08:08 <merijn> I guess there's no way to have a GADT "data Foo a where ..." and then write a function that accepts only Foo's whose 'a' matches either of two types (and no others)
13:08:08 <byorgey> meditans: I assume SupplyT has not defined a MonadRandom instance
13:08:26 <merijn> i.e. a function that accepts both "Foo Int" and "Foo Char", but nothing else
13:08:53 <[swift]> i'm quite confused. trying to build the haskell platform on ubuntu 13.04. it tries to link against libopengl32, which doesn't seem to exist on ubuntu at all. how are others getting around this problem?
13:08:55 <byorgey> merijn: no, there isn't, unfortunately
13:09:02 <merijn> byorgey: That makes me so sad :(
13:09:06 <shachaf> preyalone: Builds for me.
13:09:23 <byorgey> merijn: of course you could always make   data RestrictedFoo where  FooInt :: Foo Int -> RestrictedFoo ;  FooChar :: Foo Char -> RestrictedFoo
13:09:26 <merijn> byorgey: Any suggestions for "second best" alternatives
13:09:28 <byorgey> and then require a RestrictedFoo
13:09:41 <meditans> byorgey: could you explain me how to lift the function in the rand monad? Using liftM?
13:09:43 <byorgey> it's a bit of annoying extra boilerplate but it certainly gets the job done
13:09:49 <preyalone> shachaf: I'm using Haskell Platform 2013.2.0.0, on Mac OS X 10.8.3.
13:09:51 <byorgey> meditans: no, using 'lift'
13:09:53 <preyalone> You?
13:10:17 <shachaf> I'm using GHC 7.6.3 on x86_64-unknown-linux
13:10:25 <byorgey> meditans: if  m :: Rand StdGen a,  then  lift (lift m) :: StateT ... (Supply T ... (Rand StdGen)) a
13:10:49 <preyalone> shachaf: I might just bug report this then. Kinda asinine of the compiler.
13:11:06 <preyalone> shachaf: Ubuntu, by chance?
13:11:12 <shachaf> Not Ubuntu.
13:11:22 <shachaf> And you shouldn't open a bug report, you should figure out what's going on.
13:12:01 <preyalone> shachaf: According to you, the very same code builds fine in Linux, but yields a spurious compiler error in Mac OS X.
13:12:15 <meditans> byorgey: why are you lifting the monad? Could you lift the function? (Feel free to point me to a reference)
13:12:16 <[swift]> argh. forget this. does arch have the current haskell platform and ghc 7.6.3 packaged?
13:12:30 <shachaf> According to me, the very code you posted builds fine on my computer.
13:12:43 <[swift]> i've wasted far too much time trying to get this working on ubuntu 13.04
13:12:45 <shachaf> According to you it doesn't build on your computer.
13:12:53 <acube> [swift]: it has ghc 7.6.3
13:12:53 <byorgey> meditans: I just mean if m is some expression which has type  Rand StdGen a.
13:12:56 <shachaf> I doubt it has anything at all to do with an operating system.
13:13:07 <shachaf> I'm still suspecting versions.
13:13:11 <acube> [swift]: I don't think it has the HP in it's repo
13:13:14 <shachaf> For example, maybe the version of binary is to blame.
13:13:23 <preyalone> Let's compare versions then :)
13:13:24 <[swift]> acube: as long as it builds, that's ok
13:13:38 <byorgey> meditans: for example you could do  lift (lift getRandoms), or  lift (lift (getRandomR (2,5)))
13:14:26 <byorgey> meditans: you could lift a function by composing with lift.  e.g.  if   f :: x -> Rand StdGen a,  then   lift . lift . f :: x -> StateT ...  blah blah.
13:14:38 <preyalone> This can't be good--two versions of the "binary" package on my computer. https://gist.github.com/mcandre/5789457
13:14:55 <elliott> mikeplus64: it looks like repl's prompt_ has a race condition if you're sending stuff from multiple threads (i.e. you might get back a result for a different query). is this correct? or is evaluation not asynchronous at all?
13:14:55 <meditans> byorgey: ok, perfect, that's clear. Thanks!
13:14:56 <shachaf> Surprise.
13:16:08 <m4b> looking for a data structure suggestion: suppose I have terms in a simple non-linear algebra, for example something like: ((1 + (-a + (-b + ((a * b))))) * (1 + (-d + (c * d)))); I need to fully distribute multiplied terms, so the container will expand, etc.; originally implemented using lists, but inefficient for large terms; any suggestions?
13:18:08 <preyalone> I can't ghc-pkg recache, complains about file permissions. "sudo ghc-pkg recache" returns with no output/errors, but doesn't clear away the ghc-pkg cache warnings.
13:18:40 <Peaker> m4b, you have Negate,Sum,Mul,Term constructors and you transform these?
13:18:50 <Peaker> (a tree of these?)
13:19:11 <preyalone> Weird ghc-pkg permissions error: https://gist.github.com/mcandre/5789475
13:20:37 <Peaker> preyalone, what's the permission of the containing directory?
13:21:17 <m4b> Peaker: yes, exactly: performing symbolic manipulation
13:21:22 <geekosaur> that directory should not be writable by (or owned by) the current user
13:21:28 <Peaker> m4b, where were you using lists? I don't understand your question
13:21:41 <preyalone> Peaker: chmod'ing the directory fixed the permissions error (yay!)
13:22:07 <preyalone> However, "ghc-pkg recache" doesn't fix the "WARNING: cache is out of date" message in "ghc-pkg list binary".
13:22:26 <Peaker> preyalone, you shouldn't really have ordinary user touch the system-wide ghc stuff
13:22:27 <geekosaur> ...ok, fix the wrog problem the wrong way
13:22:43 <m4b> Peaker: originally implemented in OCaml: in Haskell, something like: data Term = One | Zero | Inv Term | Plus [Term] | Mul [Term]
13:22:44 <geekosaur> "it's good enough, who cares if stuff breaks later"
13:22:48 <merijn> byorgey: I'm deserve an award! I managed to get a restriction like that without wrapping :)
13:23:08 <byorgey> merijn: really? how?
13:23:19 <Peaker> m4b, oh.. where are the "a"s and "b"s in there?
13:23:21 <m4b> Peaker: sorry, and Var String
13:23:23 * byorgey awards merijn a Golden LAmbda
13:23:27 <byorgey> *Lambda
13:23:42 <Peaker> m4b, you could just have Plus/Mul be binary ops?
13:23:47 <merijn> byorgey: Holdon, let me clean up
13:23:49 <m4b> Peaker: so (a + (b * 1)) = Plus [Var "a", Mul [Var "b", One]]
13:24:30 <Peaker> m4b, or maybe a vector if it's used multiple times as an actual data structure (rather than generated/consumed in a single traversal)
13:24:48 <m4b> Peaker: yes, could use tuples; but distributing inverses, multiplication *not* fun; lists or a container like structure give you a normal form by sorting, commutativity, etc.
13:25:09 <Peaker> m4b, not tuples, btw: just direct pairs of terms stored in there (maybe strict terms, too)
13:25:25 <m4b> Peaker: could you give me an example, not sure I follow
13:25:37 <Peaker> m4b, in OCaml you say:  Foo of (a,b)    in Haskell you just have:  Foo a b
13:25:46 <preyalone> :( So "ghc-pkg list binary" recommends "ghc-pkg recache", but that does nothing.
13:25:47 <Peaker> m4b, (no tuple involved)
13:25:47 <merijn> byorgey: http://hpaste.org/89975
13:25:48 <geekosaur> @@ preyalone, can you @paste the actual complete error you are getting from ghc-pkg list?
13:25:49 <lambdabot> Plugin `compose' failed with: Unknown command: ""
13:25:52 <geekosaur> bah
13:26:04 <merijn> I'm pretty sure you can do it cleaner than that, but it's pretty ok
13:26:10 <merijn> Requires 7.7 or newer, though
13:26:15 <geekosaur> because, at a guess, you want ghc-pkg recache --user
13:26:27 <merijn> I feel like I just levelled up in type wizardry
13:26:28 <m4b> Peaker: yes, I'm aware; but my again, distribution of inverses, cancellationg of terms, distribution of multiplication is not nice for binary representation
13:26:42 <geekosaur> (the default is --global but if the global oneisn't fixing it then it's probably havng an issue with the --user cache)
13:26:57 <preyalone> geekosaur: Sure! https://gist.github.com/mcandre/5789498
13:26:59 <Peaker> m4b, I see.. how did you figure that lists were causing the inefficiency before?
13:27:13 <merijn> There's probably a cleaner way to add the constraint than using type equality on Void, but I don't know enough to do that
13:27:16 <geekosaur> exactly. ghc-pkg recache --user
13:27:25 <geekosaur> see line 2
13:27:36 <xplat> chrisdone: there are namespace issues but you can pipe something to 'while read FOO; do blah; done'.  if the namespace issues are bothering you, instead do 'exec 3<(some command); while read FOO <&3; do blah; done'
13:27:41 <byorgey> merijn: ooh, nice =)
13:27:47 <preyalone> Yes, "ghc-pkg --user recache" fixed the warning!
13:27:59 <m4b> Peaker: because lists are dumb ;)
13:28:04 <merijn> Is there a discussion on what I'm allowed to do with Constraint somewhere?
13:28:18 <preyalone> It would be helpful if ghc-pkg recommended a more exact command for refreshing old caches (--user vs --global).
13:28:29 <Peaker> merijn, I don't understand why lines 18-19 catch different cases?
13:28:40 <Peaker> merijn, oh, a=a vs x=a
13:28:44 <Peaker> merijn, type-level is confusing :)
13:29:01 <byorgey> merijn: the only problem with this approach is if someone tries to call foo with a Foo Int they will get an error message about "Couldn't prove  Int ~ Void"
13:29:03 <m4b> Peaker: ok, because essentially the terms expand exponentially; and many times symbolic manipulation only needs to perform one manipulation on a single term in a list; so access time not great
13:29:12 <byorgey> merijn: which might be confusing
13:29:17 <merijn> byorgey: Yeah
13:29:34 <merijn> Like I said, there's probably a cleaner way, but I've never used ConstraintKinds before
13:29:56 <merijn> If you remove line 20 you get "Could not deduce (Restrict Int ('[] *)) arising from a use of ‚Äõfoo‚Äô"
13:30:01 <m4b> Peaker: so i'm not saying lists were a bad idea; what I am hoping to get suggestions for, is if possible, a more efficient representation
13:30:02 <merijn> Which is probably better
13:30:27 <merijn> Also removes the dependency on Data.Void
13:30:28 <Peaker> m4b, but if you have a single generation of the structure and a single consumption of it, then due to laziness, the list is just a way to plug a producer and a consumer, rather than an inefficient data structure you're traversing with too much indirection
13:30:29 <byorgey> merijn: yes, I was just going to suggest removing that line
13:30:40 <Peaker> m4b, Can you paste your algorithm which was inefficient?
13:30:41 <merijn> btw
13:31:04 <merijn> Is there a reason why I can't write "type family Restrict :: * -> [*] -> Constraint" when I have KindSignatures?
13:31:22 <merijn> I get "Number of parameters must match family declaration; expected 0"
13:31:34 <merijn> "In the type instance group declaration for ‚ÄõRestricted‚Äô"
13:32:12 <merijn> I dislike the "Restrict a (as :: [*]) :: Constraint" syntax
13:32:27 <Peaker> merijn, hmm.. sounds like it interprets that declaration as the definition of the type family, rather than a separate type signature declaration as in the value level?
13:32:35 <Jeanne-Kamikaze> does anyone else find the "amount of monad tutorials" chart on the wiki rather funny ?
13:32:39 <Peaker> merijn, btw: Why "Restrict" and not "Member" or such?
13:33:05 <merijn> Peaker: Seemed a clearer error message in this context
13:33:22 <merijn> Peaker: Yes, but I dunno why
13:33:27 <merijn> Maybe a question for the #ghc folks
13:33:31 <geekosaur> well, yes, monad tutorials are a running joke in the haskell community
13:34:07 <preyalone> shachef: Which version of the binary package are you using?
13:34:20 <Peaker> Scala got Functor=>Applicative=>Monad before Haskell :(
13:34:23 <m4b> Peaker: I don't really have an "algorithm" to paste; essentially what I'm doing is reducing a term, t1, in an algebra {0,1,-,+,*}, and x1..xn variables, "closed over substitution" with a single equation with the shape (1 + -(x*y)) to a sum-product normal form, whose definition is the intuitive notion, but which I can provide if you like
13:34:36 <Jeanne-Kamikaze> would be a killer if it said "well, that escalated pretty quickly"
13:34:42 <Jeanne-Kamikaze> xDD
13:35:53 <preyalone> Ah, binary-0.5.1.1, brought in by distributed-process, works. There's a newer version of binary, 0.7.1.0, but distributed-process doesn't work with it yet.
13:35:58 <Peaker> m4b, I'm a bit slower today, I think :)  did you mean above that when you manipulate the whole expression -- you need to change something inside a list, so you have to copy the whole init of the list to that point?
13:36:54 <Peaker> m4b, so it sounds like you'd gain from using a structure better at middle modification/deletion/insertion... So maybe Seq (or if appropriate, Set)
13:37:19 <m4b> Peaker: yes, for example, (1 + a) * (1 + b) reduces to (1 + a + b + ab), not only changes the outer constructor of Mul to Plu, but similarly increases the size of the resulting list, etc.
13:37:22 <merijn> There's no void constraint that never holds, right?
13:38:28 <shachaf> merijn: You can use equality of two different types or something.
13:38:33 <shachaf> It doesn't really work that well.
13:38:52 <m4b> Peaker: I thought of set, but redundant terms are removed; hence (1 + 2a) in a set representation would just be 1 + a; unfortunately, they're not Zhegalkin polynomials
13:39:04 <Peaker> m4b, There's http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Sequence.html
13:39:35 <merijn> shachaf: Yeah, that's what I used initially, but the produces really confusing errors
13:39:46 <xplat> merijn: you can do something similar with DataKinds
13:40:05 <merijn> xplat: something similar to what?
13:40:09 <Peaker> m4b, appending 2 Seqs (><) is O(log(min(n1,n2))
13:40:10 <m4b> Peaker: ok, I'll check it out; however, I'm not so much looking for a library, but ideas on how to implement a reasonably efficient data structure
13:40:32 <preyalone> Thanks all! My code now compiles, it's just a matter of tweaking the POSIX part of my app.
13:40:39 <merijn> If you're not subscribed to -case do you still get replies to your emails?
13:40:44 <merijn> eh
13:40:47 <merijn> -cafe
13:40:55 <elliott> (if you're not subscribed to -if...)
13:41:36 <m4b> Peaker: ok, awesome link gives a paper for the details of the implementation
13:41:40 <Peaker> m4b, oh. Then maybe I'd suggest having a different type for your flexible input term (with just binary tree of terms), and canonicalizing it to a different, less flexible data type, but I might have thought this through less thoroughly than you have
13:42:06 <Peaker> m4b, ah, misunderstood - thought you were talking about a reasonably efficient data structure for the terms
13:42:36 <merijn> Or better yet, is there a ghc specific mailing list? If not where should ghc questions/suggestions go?
13:42:42 <m4b> Peaker: that's currently what I do; I parse the input into tuples, then want to convert it to a representation that will represent that distribution, cancellation easier (and efficiently)
13:43:05 <m4b> Peaker: yes I am looking for a reasonably efficient data structure; but I'm also interested in implementing one myself, for one benefit, fun, practice, etc.
13:43:11 <monochrom> elliott: some repliers send to both cafe and you, some others (such as me) don't
13:43:20 <elliott> monochrom: itym merijn :)
13:44:09 <Peaker> m4b, ah, ok..  I'll suggest http://matthew.brecknell.net/post/btree-gadt/   a pretty dense screen cast, but awesome video about writing such data structures with GADTs that enforce the invariants
13:44:14 <monochrom> the ghc specific mailing list is glasgow-haskell-users
13:44:19 <merijn> I don't think subscribing to extra mailing lists is good for my productivity, but I'd still like to see response to my mail :p
13:45:13 <Peaker> merijn, http://www.haskell.org/pipermail/haskell-cafe/2013-June/thread.html ?
13:46:02 <m4b> Peaker: ok, thank you for the links, discussion, etc. :) but yea, this sort of driving me crazy, can't seem to find a compromise between an intuitive and efficient representation of the terms
13:46:15 <merijn> Peaker: I'd need to remember, I'm lazy :p
13:46:38 <Peaker> m4b, if all else fails, you could always revert to ST for a more efficient algorithm :)
13:46:43 <xplat> merijn: hm, i'm surprised you can do what you're doing without OverlappingInstances.  surprised and dismayed ...
13:46:44 <merijn> Peaker: Anyway, I think glasgow-haskell-users is probably a better place for complaints about missing GHC features :p
13:46:50 <merijn> xplat: Why?
13:47:01 <Peaker> xplat, I think that's the purpose of the "type instance .. where" thing
13:47:08 <merijn> xplat: I'm not using any typeclasses and also there's no overlap
13:47:28 <merijn> xplat: type family instances in a where block are tried in lexical order
13:49:19 <m4b> Peaker: yea, I'm not sure.  My latest idea is to represent the terms as arrays (or some kind of container) of tuples, (Term, Int); where the array either has a Plus or Mult constructor; the tuples represent what kind of term it is, an the number of occurences; if the int is -, then this can be treated as the inverse, etc.;  but not sure how easy distribution of multiplication will be to implement, etc.
13:50:35 <m4b> so something like: data Term = Zero | One | Var "s" | Mult [(Term, Int)] | Plus [(Term,Int)]
13:51:01 <xplat> merijn: something similar to restriction-by-type (ref 16:42)
13:52:53 <merijn> xplat: What's ref 16:42 mean?
13:56:14 <owen1> When trying to install hpodder on debian and run 'cabal install' i get: "src/Text/XML/HaXml.hs:1:1: Ambiguous module name `Prelude': it was found in multiple packages: base haskell98-2.0.0.1"   I tried 'sudo ghc-pkg hide haskell98' but i still get this error. do i need to restart X?
13:56:18 <m4b> Peaker: ok, thank you again for suggestions, have a good day (or night)
13:57:05 <xplat> merijn: i'm dismayed because this lets you pattern-match on types (types proper, not datakinds) rather than inverting an injective function from 'secret type codes' to types.
13:57:55 <xplat> merijn: i feel like in an open universe like types an 'everything else' match doesn't make semantic sense
13:58:30 <xplat> (similarly an inequality constraint)
13:59:19 <Peaker> xplat, what about type families in general? They've always let you pattern-match types (with a special constraint though)
13:59:53 <merijn> xplat: I love this, it's nearly impossible to write useful type families without this behaviour
14:00:04 <merijn> I frequently want to write closed type families
14:00:11 <xplat> merijn: ref 16:42 meant 'i was answering your remark at time 16:42'; the 16 is not portable outside my time zone, of course, but the 42 should be
14:00:12 <merijn> Barring those, this is a good second best
14:00:24 <Peaker> merijn, type families are very useful (replacing fundeps, generally)
14:00:52 <xplat> merijn: if you want to write closed type families, that's what DataKinds are (well, should be?) for
14:01:00 <merijn> Peaker: I'm not saying they're not, I'm just saying they're much better!
14:01:10 <merijn> xplat: How so? DataKinds doesn't let you write functions...
14:01:46 <xplat> Peaker: the constraint helps make sense of pattern matching in an open world.  there are alternate ways to do that of course, but i don't see any of them in play when 'type instance where' matches on kind *
14:02:44 <xplat> merijn: DataKinds lets you write type families that are based on a closed universe of arguments, rather than the open universe of *
14:04:00 <merijn> xplat: Yes, but that doesn't let you decide anything on real types...
14:04:22 <merijn> You'd have to somehow lift every real type to DataKind and back to do anything
14:06:18 <xplat> this form of type families should let you do basically anything you can do with OverlappingInstances; so i don't understand saying this is fine and OverlappingInstances is not
14:07:06 <merijn> Who says OverlappingInstances isn't fine?
14:07:25 <xplat> ah, so we come to the true crux of the disagreement :)
14:08:18 <elliott> merijn: everybody?
14:08:39 <merijn> elliott: Ssshh :p
14:09:42 <merijn> Anyone here use hdevtools?
14:11:56 <xplat> hdevtools author seems rather energetic
14:13:01 <merijn> I'm wondering if there's a way to get hdevtools to play nice with multiple versions of GHC
14:13:16 <merijn> Because right now it's reporting errors in code that's valid for 7.7
14:13:27 <shachaf> Change the GHC version it's using to 7.7?
14:13:45 <merijn> shachaf: How? That was my question :p
14:14:22 <xplat> merijn: you probably need to rebuild it against 7.7 API
14:15:43 <shachaf> Right, the same binary won't do multiple version, if that's what you mean.
14:15:44 <elliott> I hear rumours 7.7 has per-thread heap limits, can anyone confirm that?
14:17:37 <xplat> speaking of haskell tools, any suggestions for a haskell code browser (with or without editing) with identifiers hyperlinked to their definitions?
14:17:49 <ksf> xplat, vim.
14:18:05 <xplat> ksf: vim plus what?
14:18:08 <shachaf> hasktags?
14:18:31 <xplat> how accurate is hasktags?
14:18:45 <acube> emacs + hasktags works too
14:18:58 <shachaf> It's worked pretty well for me.
14:19:09 <xplat> like if someone shadows map in a where clause, will it link to the where clause for occurrences of map in that function body?
14:19:09 <shachaf> hasktags + anything that can handle tags files.
14:19:14 <ksf> I have no idea what I'm using, I just hit _ct and it creates tags.
14:19:28 <acube> xplat: it doesn't do where clauses afaik
14:20:19 <shachaf> Right.
14:20:54 <xplat> how much is that a limitation of hasktags, and how much of the ctags/etags formats, i wonder?
14:20:55 <Peaker> does PolymorphicComponents work well?
14:21:00 <Peaker> or should I use a newtype again?
14:21:25 <acube> What is PolymorphicComponents? :O
14:21:27 <shachaf> PolymorphicComponents is probably just an alias of RankNTypes by now.
14:21:51 <shachaf> Peaker: But that's kind of an odd question. PolymorphicComponents is in order to make the newtype work.
14:22:07 <Peaker> acube, forall on the type of a record field (maybe a data field too?)
14:22:28 <merijn> Peaker: Just use GADTs?
14:22:29 <Peaker> shachaf, well, it's on one of my record fields
14:22:41 * hackagebot lgtk 0.5.3 - lens-based API for Gtk  http://hackage.haskell.org/package/lgtk-0.5.3 (PeterDivianszky)
14:22:45 <shachaf> Peaker: Well, if you make a newtype, it'll still be on that newtype's record field.
14:23:06 <Peaker> I thought that was a special case
14:23:18 <shachaf> Not really (as far as I know).
14:23:21 <Peaker> If not that means I made a superfluous newtype I'll go ahead and delete now :)
14:23:32 <shachaf> Go for it.
14:23:57 <shachaf> I thought you added a newtype to avoid an impredicative type recently.
14:24:07 <shachaf> That's e.g. f (forall x. ...)
14:24:08 <Peaker> Yeah, that's a newtype I'll keep
14:24:20 <shachaf> For a record field you shouldn't need one.
14:24:24 <Peaker> I have a monadic action like: m (forall a. m a -> a)
14:24:36 <Peaker> but I also made a newtype for a record field with a forall
14:24:54 <merijn> bleh, hdevtools doesn't even build with 7.7
14:25:19 <shachaf> Is there even a difference between newtype and data as far as type checking is concerned?
14:26:25 <Peaker> I don't know, but I thought maybe single field with forall around it was a different case than forall's on each of some fields.. but I am not sure why I thought that
14:27:39 <shachaf> I,I data Functor f = Functor { fmap :: forall a b. (a -> b) -> f a -> f b }
14:29:09 <Nik05> hey guys whats wrong with foo (x, y):xys = (bar x y) : foo xys
14:29:14 <Nik05> i get a syntax error
14:29:31 <shachaf> That is parsed as: (foo (x, y)) : xys = ...
14:29:47 <shachaf> Because function application is sticker than any operator.
14:30:09 <Peaker> Nik05, also: function application binds more tightly than infix application, so you don't need () around (bar x y)
14:30:43 <Nik05> ok but how do i solve the first problem?
14:30:57 <shachaf> Do you understand wht the problem is?
14:31:01 <preyalone> Whew, finally finished. A reasonably clean Hello World example for Cloud Haskell actors. https://github.com/mcandre/parhello/tree/master/haskell/parhello-actors#example
14:31:55 <Nik05> so foo ((x, y):xys) = ... ?
14:32:50 <shachaf> What happens when you try that?
14:33:00 <Nik05> it works :p
14:33:14 <shachaf> Then allow me to take the credit.
14:33:20 <Nik05> thanks shachaf :
14:33:26 <Nik05> :D
14:34:16 <shachaf> And you can even learn a new habit: When you get a parse error add a bunch of parentheses to make things completely unambiguous.
14:36:43 <xplat> Peaker: you may have been thinking of the existential case where a GADT type constructor itself has a polymorphic type; this is indeed a special case and different from taking a polymorphic argument
14:38:35 <FreeFull> Generally when you pattern match you'll want brackets, unless the constructor doesn't take any arguments
14:39:42 <merijn> lens is broken in 7.7? :(
14:40:56 <FreeFull> :t _1
14:40:58 <lambdabot> (Functor f, Indexable Int p, Field1 s t a b) => p a (f b) -> s -> f t
14:42:31 <FreeFull> merijn: 7.7 of what?
14:42:36 <FreeFull> GHC>
14:42:37 <FreeFull> ?
14:42:43 <merijn> FreeFull: GHC
14:43:28 <FreeFull> Does it error out or does it do the wrong thing?
14:43:43 <FreeFull> Oh, apparently build error
14:43:44 <merijn> It doesn't compile
14:43:56 <FreeFull> That got fixed 5 months ago
14:45:06 <FreeFull> Wait, maybe the reflection thing
14:46:12 <robde> hello. I have a datatype data Pair a = Pair a a, and I want to use the constructor like Pair 1 2, but GHCI gives me an error "o instance for (Num (Pair a0))".
14:47:00 <Peaker> robde, that's probably not the whole code, the error is from another piece of code
14:47:27 <shachaf> robde: You're leaving something out.
14:47:57 <shachaf> You should show your whole code and whole error message.
14:48:05 <merijn> Awww
14:48:14 <merijn> edwardk isn't online either :\
14:49:49 <merijn> blah, looks like my ghc 7.7 is buggy
14:51:22 <merijn> Is it just me or is http://www.haskell.org/ghc/dist/current/dist/ empty for everyone?
14:54:57 <shanse> yeah, that's empty
14:55:08 <nexx> same for stable/dist
14:56:15 <nexx> btw why is haskell.org using PHP?
14:56:53 <sclv> mediawiki
14:57:07 <sclv> standard, well supported
14:57:37 <sclv> if we had some serious admins ready to step up + could develop the few missing pieces of gitit/darcsit i suppose we could switch
14:57:44 <sclv> darcs.org uses darcsit iirc
14:58:00 <shachaf> Why?
14:58:07 <sclv> do we use mediawiki?
14:58:12 <shachaf> Why switch?
14:58:13 <sclv> we were using it before there were wikis in haskell
14:58:18 <sclv> oh right, that too :-)
14:58:27 <sclv> yeah, mediawiki works well
14:58:54 <sclv> i suppose as a general rule i'd feel better about security on a non-php system
14:58:58 <xplat> 'eat your own dogfood' argues for switching
14:59:11 <merijn> Anyway, where can I find recent 7.7's if those two are empty?
14:59:13 <sclv> we have enough webpages dogfooding haskell web frameworks tho
14:59:41 <xplat> haskell.org is kind of a flagship though
14:59:45 <sclv> the main thing w/ mediawiki is we pay i barely any mind and it plugs along
14:59:53 <xplat> where most of those other webpages are not
14:59:54 <nexx> and php kind of looks bad
14:59:55 <shachaf> Next up, the OS that runs haskell.org is written in C.
15:00:13 <sclv> so xplat are you volunteering to port the wiki to darcsit/lead development on missing darcsit features?
15:00:19 <sclv> and then administer it?
15:00:27 <sclv> because if so awesome!
15:00:55 <xplat> shachaf: well, first off it's much less visible, secondly it's not like that makes haskell look bad next to any language other than C, since effectively every OS is written in C.
15:00:58 <sclv> (note: this offer extends to anyone else too)
15:00:59 <Peaker> shachaf, Haskell is viewed as a better replacement than PHP for websites, but not necessarily as better than C for OS's
15:02:03 <xplat> (also what Peaker said)
15:02:08 <robde> thanks for the hint that the problem must be something else. I solved it now.
15:02:23 <xplat> sclv: what are the missing darcsit features?
15:02:33 <sclv> probably not much.
15:02:39 <sclv> step one is just to figure that out :-P
15:02:46 <sclv> maybe there's some capcha stuff
15:02:46 <nexx> :D
15:02:53 <shachaf> Probably a lot.
15:02:58 <sclv> the whatsnew/user pages
15:03:28 <sclv> i'd check how well templates and tables of contents work a well
15:03:30 <sclv> as well
15:03:33 <sclv> plus category pages
15:04:06 <xplat> shachaf: well, a list of 'features that mediawiki has that darcsit doesn't' will be long, sure; the more important question is which ones would be missed
15:05:28 <shachaf> And also actually being used as a real wiki with thousands of people.
15:05:51 <shachaf> I have no particular fondness for PHP or mediawiki, but you're underestimating the amount of work involved.
15:06:03 <shachaf> Not to mention another pointless wiki migration.
15:06:33 <nexx> another?
15:06:44 <shachaf> Yes, haskell.org used to use a different wiki.
15:06:52 <shachaf> http://www.haskell.org/haskellwiki/HaWiki_migration
15:07:40 <sclv> yeah the problem is really mediawiki is an industry standard
15:07:45 <xplat> maybe it would be better to port mediawiki, only i don't think there are good solutions for intermediate stages of a php->haskell port at this time
15:07:58 <bitonic> are there any big problems with mediawiki?
15:08:11 <bitonic> or is it just the PHP?
15:08:26 <xplat> maybe jfischoff's company has some?
15:09:21 <xplat> bitonic: well, i've heard of a lot of problems with mediawiki, other than being in PHP, but it's hard to rewrite things from scratch and get 'X with all the good stuff and none of the problems'
15:09:38 <elliott> afaik, no wiki that isn't in perl, php or java is even close to mediawiki's functionality
15:09:49 <bitonic> xplat: I was just curious on the nature of this discussion
15:10:12 <elliott> rubyonrails.org is PHP too. nobody cares apart from a few trolls
15:10:17 <bitonic> in the end if you want to get a wiki going mediawiki it‚Äôs pretty much universally accepted as a working solution
15:10:55 <xplat> it's basically the microsoft windows of wiki software
15:11:09 <elliott> that's a bit silly.
15:11:17 <bitonic> I think that‚Äôs a bit unfair.  there isn‚Äôt lock in with wiki software
15:11:35 <elliott> I think it would have to make sense to be unfair :P
15:11:35 <bitonic> or anyway, not as much
15:11:52 <bitonic> mediawiki is popular because it works and does a lot of stuff
15:11:55 <nexx> <bitonic> xplat: I was just curious on the nature of this discussion <<< I was just wondering why haskell.org uses php
15:12:12 <xplat> well, maybe more the microsoft office
15:12:17 <bitonic> nexx: did you wonder why the web server uses C too?
15:12:43 * hackagebot monadplus 1.4 - Haskell98 partial maps and filters over MonadPlus.  http://hackage.haskell.org/package/monadplus-1.4 (HansHoglund)
15:12:48 <shachaf> I would spend more time arguing against this silliness but fortunately the power of inertia is on my side.
15:13:25 <carter> shachaf recursive yak shaving does have its  place, but agreed, migrating a large wiki for no reason ins't one of them
15:13:33 <nexx> bitonic the webserver seems reasonable to server PHP
15:13:37 <sclv> gitit is really good tho,
15:13:44 <sclv> so i'd be curious what its missing, just as an exercise
15:13:46 <xplat> it's basically the 'it's got everything you could possibly want, everybody knows how to use the basics, and even though most of the features are broken in some way the workarounds are well known' kind of thing that office is
15:14:22 <bitonic> xplat: mediawiki didn‚Äôt gain its dominance by aggressive marketing, extend and extinguish, etc etc.  unless we mean different things with ‚Äòit‚Äôs like microsoft‚Äô
15:14:32 <bitonic> if you mean that it‚Äôs the dominant thing in some area, sure
15:14:52 <carter> sclv i do like gitit
15:15:02 <carter> and have a notes wiki i keep  using it
15:16:31 <xplat> bitonic: well, actually the main thing microsoft did with their agressive business strategies wasn't spread windows so much as make it possible to effectively offer windows for free while still getting paid for it.  and wikipedia served as a huge free marketing outreach for mediawiki.
15:17:17 <bitonic> xplat: I really don‚Äôt think that wikipedia was ever thought as a marketing platform for mediawiki by anyone inside wikipedia.  that seems backward
15:17:35 <xplat> bitonic: it doesn't matter what it was thought of as
15:17:44 <DanBurton> @hackage monad-coroutine
15:17:44 <lambdabot> http://hackage.haskell.org/package/monad-coroutine
15:18:22 <DanBurton> I want to make the assertion that Coroutine from Control.Monad.Coroutine is just the free monad transformer in disguise
15:18:23 <bitonic> xplat: OK, then we‚Äôre talking about different things.  I thought you were implying some undeserved success.  proving a piece of software worthy by having it run wikipedia is perfectly fine by me
15:18:26 <DanBurton> Am I correct?
15:18:28 <merijn> johnw: I've been informed you were doing builds of 7.7?
15:18:44 <elliott> DanBurton: what package?
15:18:53 <DanBurton> elliott: monad-coroutine
15:18:58 <xplat> bitonic: microsoft's main marketing strategy for office was making sure everybody knew how to use it by giving them free samples at their own expense, so then those same people would want to use it elsewhere
15:18:59 <shachaf> DanBurton: Yep.
15:19:07 <elliott> @hackage monad-coroutine
15:19:07 <lambdabot> http://hackage.haskell.org/package/monad-coroutine
15:19:22 <elliott> looks it.
15:19:31 <shachaf> monad-coroutine is FreeT
15:19:36 <DanBurton> a'ight, so I'm not crazy
15:19:43 <bitonic> xplat: well, I don‚Äôt know microsoft that well.  I think I just misunderstood your intentions with the ‚Äòit‚Äôs like microsoft‚Äô comments.  anyway this is all pretty silly
15:19:44 <elliott> it's not even much of a disguise
15:19:48 <xplat> bitonic: wikipedia achieved the same effect for a different motive
15:20:03 <carter> and its GPL without a version, so i can't look at it
15:20:30 <xplat> bitonic: yeah, i guess it is pretty silly to spend a lot of time analysing whether a throwaway analogy is appropriate
15:20:38 <bitonic> :)
15:21:44 <xplat> i'm putting off running the vacuum cleaner so i guess it seemed a more attractive use of time than it should ...
15:22:52 <bitonic> ehe.  I‚Äôm falling asleep while writing.  I better go back to work
15:25:38 <nexx> Why is gitit using highlighting-kate instead of pandoc for syntax highlighting?
15:26:02 <bitonic> nexx: pandoc uses highlighting-kate for syntax highlighting
15:26:10 <nexx> oh ok. Thanks
15:29:10 <owen1> When trying to install hpodder on debian and run 'cabal install' i get: "src/Text/XML/HaXml.hs:1:1: Ambiguous module name `Prelude': it was found in multiple packages: base haskell98-2.0.0.1"   I tried 'sudo ghc-pkg hide haskell98' but i still get this error. do i need to restart X?
15:29:27 <owen1> (just restarted x but it didn't solve it)
15:32:44 * hackagebot kure 2.8.0 - Combinators for Strategic Programming  http://hackage.haskell.org/package/kure-2.8.0 (NeilSculthorpe)
15:32:46 * hackagebot monadplus 1.4.1 - Haskell98 partial maps and filters over MonadPlus.  http://hackage.haskell.org/package/monadplus-1.4.1 (HansHoglund)
15:34:13 <meditans> so, I have a computation of type f :: A -> M () where m is instance of MonadState. This computation changes the internal state. Now, when I do  "sequence_ $ replicate n (f a)" can I ensure that these actions are executed in order?
15:34:28 <shachaf> @src replicateM_
15:34:28 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
15:34:45 <shachaf> meditans: Yes, sequence_ eecutes the actions in order.
15:34:47 <shachaf> Hence the name. :-)
15:35:18 <shachaf> You can also figure that out yourself by looking at the source.
15:35:20 <shachaf> @src sequence_
15:35:20 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
15:35:23 <meditans> shachaf: it's a shame, cause then the error is elsewhere XD. Thanks!
15:35:43 <meditans> ah, thanks for the source!
15:35:52 <shachaf> You can also look up the source by yourself.
15:35:54 <shachaf> @where hoogle
15:35:55 <lambdabot> http://haskell.org/hoogle
15:36:08 <shachaf> That gives you documentation and source.
16:10:58 <maurer> Is there a flavor of haskell network library that will give me a Handle instead of a Socket?
16:11:12 <maurer> Oh, nvm
16:11:47 <merijn> loop (from ArrowLoop) doesn't provide a way to specify what the initial state value should be, does it?
16:12:19 <copumpkin> loop is like fixed
16:12:23 <copumpkin> there is no "initial state"
16:12:25 <copumpkin> *fix
16:13:01 <elliott> yeah, it's not "iteration", it's knot-tying
16:13:06 <merijn> hmm
16:13:13 <copumpkin> it's kind of wonky :)
16:13:15 <copumpkin> :t loop
16:13:16 <lambdabot> ArrowLoop a => a (b, d) (c, d) -> a b c
16:13:34 <copumpkin> think of how you'd implement that signature for a = ->
16:13:44 <merijn> I basically need "d -> a (b, d) (c, d) -> a b c"
16:14:05 <elliott> with what semantics?
16:14:39 <copumpkin> merijn: keep in mind that fix allows you to implement anything recursive, and loop is the same for other arrows
16:14:40 <merijn> elliott: The d output by the first activation should feed back in for the second
16:15:13 <elliott> ok, so "first activation", "second activation", iteration rather than a knot
16:15:20 <elliott> how would you implement it for (->)? or would you not?
16:16:17 <merijn> for -> it would just be fold (>>)
16:16:21 <merijn> for State
16:16:34 <Guest82033> Clint: pass me the irssi script that someone passed to you here please.
16:16:38 <merijn> eh, no
16:16:59 <merijn> hmm
16:19:01 <elliott> Guest82033: ?
16:19:06 <FreeFull> :t foldr1 (>>)
16:19:07 <lambdabot> Monad m => [m a] -> m a
16:19:58 <merijn> This stuff keeps breaking my brain
16:20:02 <chrisdone> hm
16:21:06 <merijn> elliott: See, I'm not even sure that makes sense for functions...
16:21:15 <byorgey> merijn: in that case I don't see how you can decide at what point to stop iterating, throw away the current d value, and return the c.
16:21:27 <elliott> merijn: I agree :P
16:21:47 <merijn> byorgey: You can't, it doesn't make sense for functions
16:21:57 <merijn> Which is irrelevant, since I'm not dealing with functions
16:22:19 <byorgey> if something doesn't make sense for functions then it doesn't make sense for general Arrows.
16:22:28 <merijn> byorgey: Why?
16:22:36 <byorgey> because (->) is an instance of Arrow.
16:22:44 <elliott> byorgey: ArrowLoop isn't Arrow, though...
16:22:53 <elliott> loop itself doesn't make sense for all Arrows, but it still exists :)
16:22:55 <merijn> byorgey: Is -> an instance of ArrowLoop?
16:22:56 <byorgey> (->) is an instance of ArrowLoop too.
16:23:00 <byorgey> yes.
16:23:02 <elliott> sure. but it doesn't necessarily have to be
16:23:12 <byorgey> wat.
16:23:30 <elliott> well, I can write "class Arrow a => ArrowFoo a where ..." and the ...s don't necessarily need to admit (->) for a
16:23:37 <byorgey> oh, sure.
16:23:45 <elliott> and I think this is about defining such a class
16:24:00 <byorgey> my point is that merijn cannot hope to implement what he wants solely in terms of ArrowLoop.
16:24:04 <merijn> hmm
16:24:05 <merijn> Yeah
16:24:11 <merijn> I guess I don't need arrow
16:24:12 <byorgey> but perhaps it does make sense for merijn's particular instance, whatever it is
16:24:19 <Peaker> I hate Arrow
16:24:26 <merijn> I think I want mkStateM :: Monad m => s -> (Time -> (a, s) -> m (Either e b, s)) -> Wire e m a b
16:24:28 <Peaker> Pretty useless
16:24:56 <sclv> http://www.youtube.com/watch?v=U1n9QTkrkP0
16:25:33 <yitz> i don't know much about ArrowLoop, but right now it looks to me like part of Haskell's Twilight Zone
16:26:20 <merijn> yitz: It's worse
16:27:22 <sclv> ^^ great album about geometry btw, imho
16:52:15 <owen1> When trying to install hpodder on debian and run 'cabal install' i get: "src/Text/XML/HaXml.hs:1:1: Ambiguous module name `Prelude': it was found in multiple packages: base haskell98-2.0.0.1"   I tried 'sudo ghc-pkg hide haskell98' but i still get this error.
16:53:10 <geekosaur> you can take that as a hint that hpodder hasn't been updated in a while
16:54:56 <geekosaur> ghc-pkg hide won't help you because cabal does its own hides / unhides based on the cabal file. you need to add base to the dependencies in its cabal file. ('cabal unpack hpodder'; go into the new directory and edit hpodder.cabal to include a dependency on base, and you may also have to correct some module names if it's using old ones; 'cabal install' (note no package name!))
16:57:33 <geekosaur> some issues you're likely to run into: various flat package names are gone (for example Char is now Data.Char, and System is divided into a bunch of different System.* modules); exception handling has changed, and you my need to modify code: see http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
17:00:42 <int-e> actually it seems to be compiling HaXml. hpodder wants version 1.20.*
17:17:00 <flebron> Hi. Will the following code be optimized due to tail recursion? http://hpaste.org/89978 How could I check the Core to understand if it is or isn't?
17:17:33 <flebron> (Assume GHC.)
17:18:28 <elliott> there is no tail recursion there by any definition I know of.
17:19:21 <int-e> flebron: that's not tail recursion.
17:19:40 <flebron> OK, should I make that into some accumulator form then?
17:19:49 <flebron> fib (a + b, a), essentially.
17:19:52 <int-e> flebron: you'll be using O(n) stack and you'll be building a pair of thunks (nothing is evaluating all those  a+b  things) rather than values.
17:20:06 <copumpkin> > let foo [] = 1; foo x = foo (tail x) in foo [1..10] -- look ma, tail recursion, it even says so!
17:20:07 <lambdabot>   1
17:20:13 * copumpkin runs
17:20:57 <int-e> > let fib = go 0 1 where go !a !b 0 = a; go a b n = go b (a+b) (n-1) in fib 100
17:20:59 <lambdabot>   <hint>:1:24:
17:20:59 <lambdabot>      Illegal bang-pattern (use -XBangPatterns):
17:20:59 <lambdabot>      ! a
17:21:21 <josephle> int-e: seems lambdabot is not as strict as we'd like it to be
17:21:39 <copumpkin> when did lambdabot forget its bang patterns
17:21:41 <copumpkin> Cale: !!!!
17:21:43 <int-e> it's too strict about the language definition :)
17:21:44 <copumpkin> or is elliott managing it now?
17:21:51 <elliott> i'm to blame
17:21:58 * copumpkin shakes his head at elliott 
17:22:04 <elliott> I need to move the extension list to the config instead of in L.hs like it is in upstream
17:22:20 <elliott> but, as we speak I am working on a rewrite of the eval plugin anyway
17:22:24 <elliott> so I figure it can wait for that
17:22:35 <flebron> fib 0 = 0; fib n = fib' n (1, 0); fib' 1 (a, b) = a; fib' n (a, b) = fib' (n - 1) (a + b, a)
17:22:51 <int-e> flebron: there is no need to pack the values into a pair
17:22:51 <flebron> Something like that. Will that be optimized?
17:23:24 <flebron> Of course, I just use it for convenience :p I'm writing about this and I'll later consider (a, b) a vector (for obvious reasons ;))
17:23:27 <int-e> and it'll still be building big thunks (that's why I wanted those ! in my code above)
17:23:49 <flebron> Will it be a linear number of thunks, though?
17:24:00 <int-e> flebron: I'm not sure how clever ghc is about undoing such notational convenience.
17:24:05 <int-e> yes.
17:24:11 <int-e> (it will be linear)
17:24:12 <flebron> OK, what if I was not using tuples?
17:24:32 <int-e> same thing. the bang pattern makes the difference.
17:24:53 <flebron> Without using bang patterns, GHC will not optimize tail recursion?
17:25:22 <int-e> it's not about the tail recursion anymore, it's about building thunks rather than fully evaluated values in the result.
17:25:26 <Hafydd> @pl \n -> (œÜ^n + (1-œÜ)^n)/(sqrt 5)
17:25:26 <lambdabot> (line 1, column 9):
17:25:26 <lambdabot> unexpected "\134"
17:25:26 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
17:25:42 <Hafydd> @pl \n -> (f^n + (1-f)^n)/(sqrt 5)
17:25:45 <lambdabot> flip ((/) . ap ((+) . (f ^)) ((1 - f) ^)) (sqrt 5)
17:25:45 <lambdabot> optimization suspended, use @pl-resume to continue.
17:26:15 <Hafydd> let f=(1+sqrt 5)/2, fib=flip ((/) . ap ((+) . (f ^)) ((1 - f) ^)) (sqrt 5) in map fib [1..]
17:26:18 <Hafydd> > let f=(1+sqrt 5)/2, fib=flip ((/) . ap ((+) . (f ^)) ((1 - f) ^)) (sqrt 5) in map fib [1..]
17:26:19 <lambdabot>   <hint>:1:19: parse error on input `,'
17:26:28 <Hafydd> > let f=(1+sqrt 5)/2; fib=flip ((/) . ap ((+) . (f ^)) ((1 - f) ^)) (sqrt 5) in map fib [1..]
17:26:29 <lambdabot>   [0.4472135954999579,1.3416407864998738,1.7888543819998317,3.130495168499705...
17:26:52 <Hafydd> Oh.
17:27:07 <meditans> I'd like to write a program that I'd like to model with a strange combination of Type and Value interaction, but I don't have the type-wizardry to support it. Could anyone give me an opinion?
17:27:52 <int-e> Hafydd: please consider exponentiating the matrix [0,1;1,1] instead.
17:28:37 <Hafydd> int-e: that's basically the same thing.
17:28:46 <flebron> Up to precision :p
17:28:47 <Hafydd> I'm just exponentiating the diagonalised form of that matrix.
17:28:52 <int-e> Hafydd: but it's much easier to do with perfect precision
17:29:19 <Hafydd> > let f=(1+sqrt 5)/2; fib=flip ((/) . ap ((-) . (f ^)) ((1 - f) ^)) (sqrt 5) in map (floor . fib) [1..]
17:29:21 <lambdabot>   [1,1,2,3,5,8,13,21,34,54,89,143,232,377,610,986,1596,2584,4181,6764,10945,1...
17:29:48 <flebron> The cool thing I found out yesterday is that if we consider the k-generalized Fibonacci, f n = f (n - 1) + f (n - 2) + ... + f(n - k), then we can compute f n in O(k^2 log n), instead of the typical O(k^3 log n) for matrix multiplication.
17:30:43 <int-e> flebron: that's possible for arbitrary linear recurrences. :)
17:31:11 <flebron> Yep :) Though the matrix comes up as very pretty in this case.
17:31:23 <copumpkin> @let impreciseFibs = let f=(1+sqrt 5)/2; fib=flip ((/) . ap ((-) . (f ^)) ((1 - f) ^)) (sqrt 5) in map (floor . fib) [1..]
17:31:24 <lambdabot>  Defined.
17:31:32 <flebron> (Since the lower part of it is just the identity, when you multiply by it it's like you're "shifting" the matrix up.)
17:31:37 <int-e> flebron: http://int-e.home.tlink.de/haskell/LinRec.hs
17:31:49 <Hafydd> I know what copumpkin is going to do!
17:32:05 <copumpkin> @let preciseFibs = fix (scanl (+) 0 . (1:)) -- :)
17:32:06 <lambdabot>  Defined.
17:33:04 <copumpkin> > find not $ zipWith (==) preciseFibs impreciseFibs
17:33:08 <lambdabot>   mueval-core: Time limit exceeded
17:33:10 <copumpkin> dammit
17:33:36 <Hafydd> > dropWhile (uncurry (==)) zip preciseFibs impreciseFibs
17:33:38 <flebron> int-e: Mine's a bit uglier :p http://codepad.org/8CBAlZwY . It also uses the fact that if one takes that matrix Q (for any k), and one's computing (mod m), there's some n such that Q^n = I (in the case k = 2, this is called the Pisano period), so computing F_k is the same as computing F_{k % n} :)
17:33:38 <lambdabot>   Couldn't match expected type `[b2] -> [b3] -> t0'
17:33:38 <lambdabot>              with actual ...
17:33:47 <Hafydd> > dropWhile (uncurry (==)) (zip preciseFibs impreciseFibs)
17:33:51 <lambdabot>   mueval-core: Time limit exceeded
17:33:54 <int-e> flebron: oh I actually have a writeup of the math: http://int-e.home.tlink.de/haskell/LinRec.pdf :-)
17:33:54 <copumpkin> :(
17:34:05 <Hafydd> Hheh.
17:34:32 <flebron> Haha I was just writing about something like that. I'm going from the initial definition, to the matrix version, and then the period thing, and the generalization for k previous terms.
17:35:07 <copumpkin> int-e: you should come to the US
17:35:19 <copumpkin> this is where all the cool people are!
17:35:46 <int-e> flebron: I'll not try to understand what that code does. :-)
17:36:20 <flebron> Hehe :) My current write up, half written: http://fedelebron.com/fast-modular-fibonacci
17:38:01 <meditans> could I construct a type which is "like" (5, Char), or (6, Char), ie mixing values and types to obtain a type?
17:38:29 <copumpkin> not really, although you can fake it (it's a decent amount of work to work wtih types of that sort though)
17:38:37 <meditans> do you know a method to do that, with whatever extension:
17:38:51 <meditans> copumpkin: could you suggest me a reference?
17:39:00 <copumpkin> http://hackage.haskell.org/trac/ghc/wiki/TypeNats/Basics
17:39:54 <meditans> copumpkin: thanks, I'm reading
17:45:02 <evan_> from the haskell tutorial: "For example, the principal type of head is [a]->a; [b]->a, a->a, or even a are correct types, but too general "
17:45:17 <evan_> what's the difference between [a]->b and [b]->a ?
17:45:50 <tgeeky> evan_: nothing except naming of the type variables
17:45:52 <flebron> The type that it mentions ins't [a] -> b, it's [a] -> a.
17:46:23 <flebron> [a] -> a means that the same type is in both places. So [Int] -> Int, but not [Int] -> Char. [a] -> b and [b] -> a, which are the same, do match [Int] -> Char.
17:46:58 <evan_> ahhhhh I see thank you
17:47:22 <evan_> wasn't reading closely enough /shame
17:48:44 <meditans> :copumpkin that is quite it, thanks. Now, if I wish a function between types and function, say to construct from the Int 5 and the Type Char the type (5, Char), how could I do it?
17:49:08 <meditans> I don't think a typeclass is enough
17:49:55 <meditans> or could I write (sing 5, Char)?
17:50:46 * elliott wonders what on earth you want the type (5, Char) to do
17:51:54 <sclv> just sit there really
17:51:56 <sclv> hang out
17:52:12 <sclv> chill with the other types
17:52:14 <int-e> owen1: http://int-e.eu/~bf3/tmp/hpodder.patch is a quick and dirty patch that allows hpodder to be built; but I'm not sure about the change in FeedParser.hs.
17:52:18 <josephle> people want singleton types? In Haskell?
17:52:59 <Hafydd> It's isomorphic to ((), Char), I believe.
17:53:03 <sclv> josephle: http://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf
17:53:06 <Hafydd> Just use that!
17:53:08 * josephle thinks at this rate, Haskell should just become a dependently typed programming language
17:53:26 <Hafydd> Or write an Integral instance of ().
17:55:59 <DanBurton> obviously, the type (5, Char) is inhabited by tuples whose first element is the Integer 5, and whose second element is a Char
17:56:19 <meditans> :elliott I'm trying to write a program with makes extensive use of a "tagging system", and I figured out that I could leave the tagging system at a string level, or take it at type level to obtain more guarantees
17:57:34 <josephle> meditans: are you planning to have potentially an infinite amount of tags?
17:57:35 <elliott> meditans: hmmmm, okay.
17:57:35 <meditans> Hafydd: yes, but I would a distinction, at Type level, between (4, Char) and (5, Char)
17:57:44 <elliott> you probably want Tagged 4 Char or such
17:57:46 <elliott> at least
17:57:49 <elliott> @hackage tagged
17:57:49 <lambdabot> http://hackage.haskell.org/package/tagged
17:58:15 <meditans> josephle: yes, that's the problem: one of the tag types I'd like to use is Integer
17:58:56 <meditans> elliott: thanks, I'm checking tagged
18:01:05 <owen1> int-e: do i need to clone the repo and apply that patch?
18:04:20 <jnerula> Anyone here a postgresql-simple guru?
18:08:20 <meditans> I read the documentation but... how do I construct a Tagged value? Tagged Int 4 complains that Int is not a data constructor
18:08:54 <elliott> Tagged a b just contains a b.
18:09:00 <elliott> newtype Tagged a b = Tagged b
18:09:07 <elliott> so Tagged "hello" :: Tagged 4 String.
18:09:47 <carter> meditans you need Data Kinds
18:09:54 <carter> and the associated ghc module with type level nats
18:10:01 <carter> or the type nats lib
18:10:12 <shachaf> It sounds to me like meditans was just confused and trying to use Int as a value.
18:10:16 <meditans> :elliott thanks, I will experiment a bit
18:10:37 <meditans> carter: I will search for data kinds thanks
18:11:09 <shachaf> I'm pretty sure DataKinds isn't what you want.
18:11:23 <shachaf> Oh. Maybe I missed an earlier message.
18:12:09 <meditans> shachaf: so, problem is that I effectively don't know how I could do this: I have, originally, a common value (value::type)
18:12:14 <b2coutts> if I want to make my own Type an instance of a Typeclass, where can I easily find a reference of what methods need to be implemented for that typeclass?
18:12:52 * hackagebot prizm 0.3.0.0 - A haskell library for computing with colors  http://hackage.haskell.org/package/prizm-0.3.0.0 (ParnellSpringmeyer)
18:13:10 <meditans> then i'd like to construct a new thing which has value AnotherUnrelatedValue a type which encodes both value and type of the first one
18:13:31 <meditans> but maybe this is just crazyness and I should try a simpler way XD
18:13:48 <enthropy> b2coutts: the source code of the package that defines Typeclass (or other code that defines "valid" instances)
18:14:01 <meditans> however, I'm preparing a hpaste.. wait a minute
18:15:17 <b2coutts> enthropy: is there somewhere on my computer I can view haskell source code (i.e. for Ord)
18:15:55 <enthropy> @src ord
18:15:55 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:16:01 <enthropy> @src Ord
18:16:01 <lambdabot> class  (Eq a) => Ord a  where
18:16:01 <lambdabot>     compare      :: a -> a -> Ordering
18:16:01 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
18:16:01 <lambdabot>     max, min         :: a -> a -> a
18:16:37 <Demos> I /belive/ you can see the source of any modules on hackage
18:16:38 <elliott> note: @src is full of lies. well, at least one lie.
18:16:40 <elliott> and lots of omissions.
18:16:45 <Demos> dont know about on your computer though
18:17:10 <enthropy> ghc comes with documentation for libraries
18:17:23 <byorgey> Demos: indeed, you can.
18:17:43 <geekosaur> b2coutts, there are some limits (primops, mainly) but you can use hoogle (with explicit package spec) or hayoo to find the documentation online, and then click the source link on the right to see the source code
18:17:54 <enthropy> for example I have a link file:///usr/share/doc/ghc/html/libraries/base-4.6.0.1/Prelude.html#t:Ord
18:20:17 <Demos> if you tell cabal to install documentation does it include source?
18:20:49 <byorgey> Demos: not linked from the documentation, no
18:21:01 <byorgey> though there might be a way to configure it to do so, I'm not sure
18:21:27 <geekosaur> cabal does not currently know how to do so. I *think* there are plans to change that
18:22:10 <geekosaur> there is also the package announced recently that will build you your own copy of html docs including hyperlinked and syntax-highlighted source
18:22:33 <Demos> well cabal does that sans the source right?
18:22:38 <geekosaur> right
18:22:42 <b2coutts> can hoogle show you source code? I thought it only told you where something is defined
18:22:43 <Demos> err rather cabal-install
18:23:08 <geekosaur> (the rerason for the package is that cabal builds local documentation which doesn't work if you try to point a web server at it)
18:23:10 <Demos> it does only show you where something is defined but it linkes to the hackage page which can show source
18:23:15 <b2coutts> do you generally have the source code for any library you have available on your machine, or might you just have compiled binaries?
18:23:35 <Demos> I belive you have 3 or 4 copies of everything actually
18:23:53 <tgeeky> Demos: like the NSA?
18:24:03 <b2coutts> I'd ideally like to be able to view source code when necessary on my machine, since I'm often using it without internet
18:24:17 <b2coutts> and since it also sounds more convenient
18:24:18 <geekosaur> distribution packages will be binaries only. if you used cabal-install, the source probably is present on your machine but as a .tar.gz
18:24:20 <Demos> static, dynamic, stuff for GHCI, and maybe something else but I dont really know what I am talking about.
18:24:37 <byorgey> b2coutts: you do have the source code for any Haskell library on your machine.
18:24:37 <tgeeky> b2coutts: when you say "view source" you mean in the haddock documentation
18:24:45 <tgeeky> b2coutts: that can be turned on by changing your cabal.config
18:24:52 <Demos> b2counts you can actually download all of hackage if you try hard enough
18:24:56 <geekosaur> Demos: by default static only. you can enable dynamic and profiling
18:25:13 <geekosaur> "ghci" is only needed on some platforms, I think
18:25:25 <byorgey> b2coutts: you can instruct cabal to give you the source code with 'cabal unpack <packagename>'.  If it's a package you already have installed it will just get the source from a local cache, it does not have to download it.
18:25:42 <geekosaur> modern ghci can load the normal static libraries fine on most platforms
18:26:01 <Demos> allright, like I said I dont know what I am talking about
18:28:50 <b2coutts> so in general, if I want to see source code for a function, I search for it with hoogle, then `cabal unpack search_result`?
18:29:55 <b2coutts> because, for example, when searching for Ord, Prelude and Data.Ord both seem promising, but neither are found by `cabal unpack`
18:30:22 <tgeeky> b2coutts: those are the modules, you want the cabal package they contain: Prelude is in 'base' and Data.Ord is also in 'base' probably
18:31:21 <b2coutts> tgeeky: is there a way to look up the package in which a module is located?
18:31:39 <tgeeky> b2coutts: I bet if you look carefully hoogle will tell you
18:31:43 <elliott> @index Data.Ord
18:31:43 <lambdabot> bzzt
18:31:45 <elliott> hm.
18:32:31 <b2coutts> tgeeky: `hoogle search Ord` doesn't have 'base' anywhere in it, and hoogle --help doesn't seem to have a suitable option
18:32:40 <shachaf> Try http://www.haskell.org/hoogle/
18:32:42 <tgeeky> b2coutts: oh, I was looking at hoogle itself
18:32:57 <b2coutts> ah
18:33:00 <tgeeky> b2coutts: when I search for Data.Ord, the first result says: "base Prelude" "base Data.Ord"
18:33:09 <shachaf> elliott: For the lambdabot todo list: Add lens etc. to Hoogle.
18:33:24 <tgeeky> @todo
18:33:24 <lambdabot> 0. SamB: A way to get multiple results from a google search
18:33:24 <lambdabot> 1. dons: improve formatting of @dict
18:33:24 <lambdabot> 2. dons: write Haskell Manifesto
18:33:24 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
18:33:24 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
18:33:26 <lambdabot> [37 @more lines]
18:33:47 <b2coutts> I guess I can probably make do with online hoogle, but would really like something from the command-line, and something local
18:34:27 <elliott> shachaf: has anyone actually tried lens with hoogle? I assumed that it would be no good at the whole subtyping thing
18:34:45 <shachaf> elliott: It's good for looking up names if nothing else.
18:36:25 <elliott> fair. will take a look
18:36:32 <shachaf> Also add other useful things.
18:36:38 <shachaf> You can add pretty much any package to Hoogle.
18:37:03 <elliott> I don't really know how it works. I just did "hoogle data default".
18:38:32 <shachaf> I don't really know either but I managed to figure it out last time.
18:38:43 <shachaf> As I remember I merged some files together or something.
18:38:49 <tgeeky> shachaf: well hell, that means any of us could do it!
18:39:22 <tgeeky> shachaf: just kidding I know you're s.m.r.t.
18:40:51 <elliott> "Packages on Hackage usually have .txt databases generated for you" maybe this
18:41:05 <shachaf> I had to look in ~/.hoogle/blah to find the files.
18:41:11 <shachaf> Then I had to merge them manually.
18:41:16 <shachaf> There's probably "a better way".
18:41:32 <elliott> it doesn't even have ~/.hoogle
18:41:38 <Saizan> cabal haddock --hoogle can generate the text databases
18:41:40 <shachaf> OK, well, wherever the things went.
18:42:12 <Saizan> and they go into the share/doc dir like the haddock docs
18:42:30 <elliott> Saizan: hmm, the lambdabot user doesn't have any docs built
18:42:37 <elliott> I guess I'll have to redownload packages and stuff?
18:43:02 <Saizan> yeah, haddock works on sources
18:43:17 <Saizan> make sure you set the appropriate flags though
18:43:21 <elliott> right
18:43:37 <elliott> well... it has to rebuild ~all its packages for hashable anyway
18:43:41 <elliott> so I guess I'll do it then
18:43:54 <elliott> can just pass --haddock-options=--hoogle to cabal-install I suppose
18:44:30 <Saizan> --haddock-hoogle actually
18:44:41 <Saizan> cabal install --help | grep haddock
18:44:59 <elliott> huh. I had no idea that integration existed
18:45:05 <elliott> is there a ~/.cabal/config setting for it?
18:45:19 <Saizan> not sure
19:10:24 <xico> any idea why "cabal list" says "Default available version: 1.0.4.3", but "cabal install pointfree" try to build 1.0.3 (and fails du to the old-style State monad)?
19:10:56 <copumpkin> > let n = 10 in map (\p -> n*2^p) [0..]
19:10:57 <lambdabot>   [10,20,40,80,160,320,640,1280,2560,5120,10240,20480,40960,81920,163840,3276...
19:11:29 <xico> ah did not saw the base<4.6
19:27:34 <CaptainK> Was going to ask how to change the colors of the ArchLinux site, but figured it out for myself.
19:27:48 <CaptainK> White Background web pages...hurt
19:28:27 <elliott> (intended for #archlinux maybe? :) )
19:29:20 <CaptainK> lol ... dohhh
19:29:55 <Twey> Are there any reasons why Haskell doesn't have implicit arguments (√† la Agda)?  Are there any plans to implement that?
19:30:32 <Twey> It seems like it should be pretty trivial to just search the scope for anything that unifies with the given type.
19:31:05 <geekosaur> there are implicit parameters (effectively part of the context instead of explicitly passed), otherwise there is a problem with optional parameters because it doesn't go well with curried parameters and partial application
19:31:15 <geekosaur> (implicit parameters are a ghc extension)_
19:31:58 <Twey> geekosaur: Neither of those are what I'm asking about, sorry :√æ
19:32:47 <Twey> geekosaur: Agda lets you specify a function with an implicit argument, like foo : { n : Nat } ‚Üí Vec Int n
19:33:05 <applikativ> do you mean, I should be able to mark some arguments as implicit in the signature too?
19:33:08 <applikativ> oh you do
19:33:32 <Twey> geekosaur: Then you can use ‚Äòfoo‚Äô in calling code as if it's of type Vec Int n, for some Nat n that is picked out of the scope (or specified explicitly using special syntax, foo { n = bar })
19:34:27 <applikativ> are you running into trouble by not having this?
19:34:30 <Twey> It seems like it would be a nicer equivalent to typeclasses, but I know Idris has both, so I assume there must be some feature that makes typeclasses more than a special case
19:34:37 <Twey> applikativ: No, I'm just curious.
19:35:16 <applikativ> i don't see the similarity to typeclasses, except that there is a unification problem
19:35:19 <Twey> I was reading that blog post that suggests we all do the typeclass-to-dictionary transformation by hand so we can do value-level computations on instances
19:35:50 <geekosaur> sounds like a reader monad with a degree of indeterminacy in the case that there's more than one possible choice at the same binding/scope depth
19:36:52 <applikativ> one thing is agda in particular insists that there are a lot more parameters to a given function, say, then might usually be thought necessary....
19:37:09 <applikativ> foo :: {A : Set} -> blah blah
19:37:21 <Twey> applikativ: Well, you can write foo : { show : Show a } ‚Üí a ‚Üí String to get the benefits of having first-class instances without having to manually pass them
19:37:54 <parcs> do you mean {{ show : Show a }} ?
19:38:29 <Twey> parcs: Er, I don't think so ‚Äî what's the difference?
19:38:41 <applikativ> what blog post do you mean Twey?
19:38:55 <Twey> applikativ: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
19:39:03 <applikativ> oh yes Tekmo
19:39:17 <applikativ> I think he grew out of that phase
19:39:29 <Tekmo> Yeah
19:39:31 <Tekmo> I grew out of it
19:39:42 <Twey> Tekmo: Are you aware of Agda's implicit arguments?
19:39:45 <Tekmo> Yes
19:39:52 <Tekmo> I'm aware that's the principled solution to the problem
19:39:58 <Twey> Tekmo: Why do you consider them not a good solution?
19:40:14 <Tekmo> I didn't even know Agda existed when I wrote that post
19:40:19 <Twey> Ah
19:40:21 <Tekmo> :)
19:40:34 <Twey> So my question stands: why don't we have them in Haskell?  :√æ
19:40:50 <Tekmo> Because it would be too big of a change
19:41:07 <Tekmo> Remember: we can't even get 'Applicative' to be a superclass of 'Monad' yet
19:41:09 <elliott> Twey: foo :: (?show :: ShowDict a) => a -> String
19:41:15 <elliott> data ShowDict a = ShowDict { show :: a -> String }
19:41:27 <elliott> admittedly it's not fileld in automatically, but sounds like the closest thing to what you want.
19:41:30 <Tekmo> There's a difference between what's possible and what is idiomatic
19:41:39 <Twey> elliott: ‚ÄòFilled in‚Äô?
19:41:41 <applikativ> blech
19:41:50 <parcs> Twey: { } is for implicit arguments, {{ }} for instance arguments
19:41:52 <Tekmo> Haskell already has a very entrenched culture around its current type class solution, so it's unlikely to change in the near future
19:41:56 <elliott> Twey: filled in
19:42:06 <fractalsea> hi, does anyone know why I'm getting these "No Instance ..." errors from: solve eqString =
19:42:06 <fractalsea>  do
19:42:06 <fractalsea>  result <- runInterpreter (setImports ["Prelude"] >> eval eqString)
19:42:06 <fractalsea> ; case result of Left _ -> "0"; Right output -> output
19:42:25 <geekosaur> don't paste into the channel please
19:42:26 <copumpkin> Twey: implicit parameters don't really work
19:42:26 <geekosaur> @paste
19:42:26 <lambdabot> Haskell pastebin: http://hpaste.org/
19:42:34 <applikativ> I think no one has had a sufficiently obviously brilliant idea.
19:42:41 <copumpkin> Twey: or rather, don't really have the same properties
19:42:43 <fractalsea> I get: OK
19:42:47 <fractalsea> will do, sorry
19:43:04 <Twey> parcs: Oh, I think that is what I meant
19:43:07 <geekosaur> also that's not really enough code to figure it out; we have no idea what instances are supposed to be there or what types are involved
19:43:10 <copumpkin> Twey: in Agda, we can put values into types so it's not a big deal, and you can get around the issues you get in a non-dependent language
19:43:12 <Twey> copumpkin: Yeah, I noticed
19:43:30 <copumpkin> there's also the issue of partial application and "transporting" contexts around
19:43:38 <copumpkin> which neither Agda nor scala do, but haskell does
19:43:43 <fractalsea> geekosaur: I was just about to type them
19:43:44 <Twey> Ah, I see
19:43:48 <geekosaur> (it might be ghc-lib? or hint?)
19:44:33 <Twey> Do you need to transport contexts around?  Doesn't it make sense to only infer arguments from the current lexical scope?
19:44:51 <copumpkin> :t (5 +)
19:44:52 <lambdabot> Num a => a -> a
19:44:55 <applikativ> it seems all the objections to type classes are sound, but all the solutions are much more heavy handed. They have this absurd usability...
19:44:56 <copumpkin> :t (+)
19:44:57 <lambdabot> Num a => a -> a -> a
19:45:09 <copumpkin> that {num : Num a} just moved!
19:45:16 <copumpkin> and wasn't determined immediately
19:45:17 <Twey> copumpkin: Oh, I see
19:45:20 <Tekmo> I don't mind type classes if I don't have to start turning on extensions
19:45:39 <copumpkin> in Scala, it'll just force you to decide what the type was immediately
19:46:35 <copumpkin> hell, I can even stay polymorphic
19:46:39 <copumpkin> :t 5 + 6
19:46:40 <lambdabot> Num a => a
19:46:44 <copumpkin> still haven't received that implicit
19:46:44 <fractalsea> OK if someone could help with the following errors, it would be greatly appreciated! I'm very new to haskell (a couple of days) and think I've got a rough idea of monads now, but I can't work out what in my code requres these type intances...
19:46:49 <fractalsea> http://hpaste.org/89982
19:47:02 <copumpkin> I'll decide what that expression means later :)
19:47:23 <Tekmo> Oh
19:47:26 <Twey> copumpkin: Shouldn't it be okay to make the resulting function take the implicit arguments, instead?  So it becomes a property of applications that it preserves the implicit argument until the last moment (where Haskell would default)
19:47:37 <Tekmo> fractalsea: You need to wrap the `case` in a `putStrLn` statement
19:47:45 <Tekmo> putStrLn $ case result of ...
19:47:58 <Tekmo> Also, change the type to:
19:48:00 <copumpkin> Twey: sure, it might be possible, but nobody who implements implicits does that right now and it sort of breaks the function model
19:48:04 <fractalsea> Doesn't that output the result? I want to return it
19:48:04 <Tekmo> solve :: String -> IO ()
19:48:08 <copumpkin> Twey: it just feels a bit inelegant, too
19:48:17 <Twey> It does feel slightly arbitrary
19:48:24 <copumpkin> what if you take multiple constraints, for example?
19:48:28 <copumpkin> is their order preserved?
19:48:30 <Twey> But then, so does defaulting
19:48:36 <Tekmo> runInterpreter requires that the evaluation is done impurely
19:48:37 <copumpkin> what if a new argument introduces new constraints?
19:48:41 <copumpkin> like
19:48:45 <shachaf> fractalsea: You probably shouldn't be using runInterpreter etc. if you're very new to Haskell.
19:48:48 <copumpkin> :t 5 + toEnum 3
19:48:49 <geekosaur> fractalsea, even so, you need to be in IO to use anything IO related
19:48:50 <lambdabot> (Enum a, Num a) => a
19:48:53 <Tekmo> However, you can still bind the result in `IO` if you do:
19:48:56 <shachaf> fractalsea: Are you the person who was doing that in order to avoid writing their own evaluator?
19:48:57 <Tekmo> return $ case result of ...
19:49:00 <Twey> Hm, yes
19:49:07 <geekosaur> @where lyah
19:49:08 <lambdabot> http://www.learnyouahaskell.com/
19:49:10 <copumpkin> they pile up nicely in Haskell
19:49:19 <copumpkin> and getting that with implicits gets ugly quickly
19:49:22 <Tekmo> Then you can have the type: String -> IO String
19:49:23 <applikativ> why shouldn't he use runInterpreter
19:49:26 <fractalsea> shachaf: probably not but it seemed like the most consise solution for what I'm doing
19:49:36 <Twey> I was going to say that it should just be named, as in Agda, but I guess it's reasonable to have two constraints with the same name across functions
19:49:41 <shachaf> fractalsea: Evaluating Haskell code is a very very complicated way to about about evaluating arithmetic expressions. If that's what you're doing.
19:49:48 <shachaf> It might've been someone else, though.
19:50:31 <Twey> fractalsea: Unless you have some really weird instances in scope, that doesn't look like a String to me.
19:51:01 <roconnor> Twey: Have you seen how ssreflect uses canonical instances to do "type-classes"?
19:51:02 <fractalsea> Tekmo: hmm OK, but the reason I didn't think I should have return is because I don't want it to return the monadic type
19:51:04 <Twey> fractalsea: Maybe you wanted solve ‚à∑ String ‚Üí IO String ?
19:51:07 <Tekmo> Maybe you should explain why you need to interpret Haskell code in the first place
19:51:14 <geekosaur> fractalsea, you *must* return it
19:51:19 <copumpkin> Twey: it's also just weird how the constraints happen in that expression I wrote. say you have (+) : {num : Num a} -> a -> a -> a and fromEnum : {enum : Enum a} -> Int -> a; it's a pretty weird operation for that {enum : Enum a} requirement to get lifted out into the (+) result
19:51:32 <geekosaur> you can't just magic up an IO and make it go away to return something pure
19:51:33 <Twey> copumpkin: I agree
19:51:38 <Tekmo> fractalsea: The idea behind `IO` is that it contaminates everything it touches
19:51:42 <Twey> It does seem less hackish than typeclasses, though
19:51:47 <fractalsea> shachaf: yes that was me, I know it probably isn't the best language to do it in, but I'm doing it to learn Haskell and so far I've leared lots
19:51:47 <copumpkin> yeah, exactly
19:51:51 <Tekmo> fractalsea: If `runInterpreter` uses `IO` then anything that depends on its result must use `IO`
19:52:02 <copumpkin> they're constraints on types, not parameters to functions
19:52:06 <copumpkin> so it makes sense for them to accumulate
19:52:12 <Twey> roconnor: I haven't
19:52:23 <Twey> copumpkin: Yeah
19:53:22 <fractalsea> So essenitally my entire program must use IO because it all depends on this function?
19:53:28 <Tekmo> Right
19:53:33 <Tekmo> But you are using a very heavy sledgehammer
19:53:40 <Twey> roconnor: Do you have a link to some nice explanation?  The documentation appears to be blank
19:53:52 <Tekmo> Haskell programs very rarely need to interpret Haskell code
19:53:52 <roconnor> Twey: no :(  If I find one, I'll let you know.
19:54:01 <Twey> Thanks
19:54:07 <geekosaur> fractalsea, not exactly. you can write mostly pure code and lift it into IO
19:54:08 <fractalsea> I understand that. My use case is evaluating simple arithmatic expressions
19:54:10 <geekosaur> again
19:54:15 <geekosaur> @where lyah
19:54:15 <lambdabot> http://www.learnyouahaskell.com/
19:54:20 <geekosaur> fractalsea, ^^ read
19:54:29 <geekosaur> learn how to work with IO
19:54:32 <Tekmo> fractalsea: You can do that without using an evaluator
19:54:53 <Tekmo> fractalsea: A simpler way is to write a function that parses a string into an expression and then evaluates the expression
19:54:59 <Twey> fractalsea: Write a parser, then write an evaluator; it shouldn't be that tricky
19:55:01 <Tekmo> fractalsea: Parsers are very easy to write in Haskell
19:55:09 <Tekmo> fractalsea: Much easier than most languages
19:55:13 <Twey> Parsec is fun!  \o/
19:55:16 <fractalsea> geekosaur, I've read a lot of that, but yes I'll check out the IO section.
19:55:24 <Twey> Fuuzetsu knows
19:55:44 <Tekmo> fractalsea: I would recommend you study either the `Parsec` or `attoparsec` libraries
19:56:00 <Tekmo> fractalsea: They are the standard ways to convert untyped data like Strings/Text/ByteString into typed expressions
19:56:17 <Tekmo> fractalsea: And they work purely
19:56:25 <fractalsea> Tekmo: Makes sense. That was my first thought actually. But I googled how to evulate arithmatic in strings and the highest SO answer suggested using runInterpreter, so I went wth that because I didn't know much better and it seemed concise.
19:57:00 <Tekmo> fractalsea: Yeah, but that is not very idiomatic.
19:57:02 <fractalsea> Tekmo: Thanks, I'll look into that.
19:57:11 <Tekmo> fractalsea: You're welcome.  Also I can help you if you have any questions
19:57:17 <Tekmo> fractalsea: Parsing is one of my specialties
19:57:39 <geekosaur> I'm not sure why anyone would recomemnd that unless the question was actually how to evaluate arbitrary haskell (like lambdabot does)
19:57:46 <fractalsea> Tekmo: Great!
19:58:18 <fractalsea> geekosaur: http://stackoverflow.com/questions/5582926/haskell-how-to-evaluate-a-string-like-12
19:58:34 <fractalsea> geekosaur, that's where I found it
19:58:51 <elliott> that answer is bizarre.
19:58:56 <elliott> you should pretend you never read it
19:59:00 <fractalsea> The question below that seems to be what you guys are suggesting
19:59:08 <fractalsea> or at least along those lines
19:59:12 <cl1> howdy folks, long time no see
19:59:16 <geekosaur> ok, that answer specifically says "Haskell expressions", and that's a really weird response to the question
19:59:21 <Tekmo> fractalsea: The main disadvantages of that answer are that you must use `IO` to evaluate the expression and it's also really really inefficient
19:59:37 <Tekmo> fractalsea: If you use `attoparsec`, for example, it's pure and it is crazy fast
19:59:51 <Tekmo> fractalsea: `attoparsec` is insanely fast
20:00:09 <Twey> And it gives you arbitrary Haskell, not just arithmetic.  This may not be what you want.
20:00:09 <fractalsea> Tekmo: I see. For this toy program I'm writing speed isn't really an issue, but I guess it's a nice advantage!
20:00:13 <geekosaur> fractalsea, if you're wondering *why* that is bizarre... it's linkingthe whole compiler into your program and invoking it
20:00:23 <Tekmo> fractalsea: The trick is to learn how to write parser combinators
20:00:24 <geekosaur> which is a nutso way to evaluate simple expressions
20:00:25 <fractalsea> Twey: It's a superset of what I want :)
20:00:28 <Tekmo> fractalsea: They are pretty easy to write
20:00:39 <Tekmo> fractalsea: Let me see if I can find a good tutorial for you.  Hold on
20:00:51 <fractalsea> Tekmo: OK, thanks
20:00:54 <cl1> so, i'm going to really buckle down and learn category theory, however finding free stuff online that I can understand is proving difficult. I have some spotty calc1, calc2, and descrete math knowledge. any book recomendations?
20:01:48 <Tekmo> May I suggest an alternative route?
20:02:00 <Tekmo> My experience is that the fastest way to learn category is to author Haskell libraries
20:02:04 <Tekmo> *category theory
20:02:18 <Twey> Ha
20:02:23 <Tekmo> The reason is that the art of good API design is very closely intertwined with category theory
20:02:26 <Tekmo> No joke
20:02:40 <Twey> cl1: I found Maarten Fokkinga's notes to be quite accessible
20:02:49 <fractalsea> Anyway I need to go for about 10 mins, but I'll be back to check if you have found that tutorial Tekmo. Thanks again for the advise all.
20:02:57 <Tekmo> fractalsea: Alright
20:03:07 <Tekmo> Gosh, maybe I need to write an `attoparsec` tutorial
20:03:12 <Twey> Tekmo: Seems like an invitation for ‚Äòspottiness‚Äô, though.
20:03:46 <Tekmo> It's better to have a firm understanding of a few core concepts than a shallow understanding of everything
20:04:46 <Tekmo> Most people who read category theory texts just learn to recite what they read in the books about such and such correspondence to esoteric mathematical topics like abstract algebra
20:06:43 <josephle> Tekmo: perhaps its because the power of category theory lies in being able to make such correspondences?
20:06:51 <cl1> Tekmo, I have so much object oriented unlearning to do, I'm not sure that API writing would work for me in this case due to all the unlearning I need to do
20:06:51 <Twey> Tekmo: In my understanding, use of a concept builds a good intuitive understanding, but leaves patches untouched.  I worked with Booleans in programming languages before I learnt Boolean algebra, for example, and I found that it was much easier to comprehend Boolean algebra thanks to my experience with using Booleans, but I couldn't rearrange a Boolean expression until I learnt about it in mathematical terms.
20:07:03 <DanBurton> Hey all, can I get some proofreading and feedback before I post this to reddit? (part 4 still very raw but parts 1-3 are "done") https://www.fpcomplete.com/content#/group/coroutines-for-streaming
20:07:25 <Tekmo> josephle: The problem is that they don't.  These same people fail to make any connections to category theory in programming.
20:07:35 <DanBurton> Tekmo: I'm interested to hear what you think of this ^
20:08:11 <Tekmo> josephle: They always recite the well-trodden connections like monads and the "category of Hask", whatever that is supposed to mean
20:08:20 <Tekmo> DanBurton: Yeah, I will read it right now
20:08:44 <Tekmo> Can you hpaste it, Dan?  I can't access it without your account
20:08:47 <DanBurton> whoops wrong link
20:09:05 <DanBurton> try this https://www.fpcomplete.com/user/DanBurton/coroutines-for-streaming
20:09:15 <DanBurton> warning: long
20:09:31 <Tekmo> That's okay
20:09:46 <josephle> Tekmo: it seems that category theory doesn't stand up well on its own. You need a strong background in some other math in order to fully appreciate Categories.
20:09:59 <josephle> at least that's how I felt when I took a course in it
20:10:02 <Tekmo> josephle: I disagree
20:10:15 <Tekmo> josephle: If you approach category theory from the mathematical angle you will feel that it depends on math to understand it
20:10:27 <Tekmo> josephle: But if you approach it from the programming angle you will perceive no such deficiency
20:10:38 <Tekmo> josephle: That's why I advocate a programming-first approach to learning it
20:10:49 <DanBurton> cat theory obviously depends on comp sci to fully appreciate it :P
20:11:12 <josephle> DanBurton: I sense a disdain for physicists who use category theory there...
20:11:36 <DanBurton> I kid, I kid
20:11:45 <Tekmo> DanBurton: Ok, I'll comment out loud as I read
20:11:59 <DanBurton> Tekmo: sounds good
20:12:04 <shachaf> Maybe in #haskell-overflow, if there'll be a lot of comments?
20:12:07 <Tekmo> DanBurton: Avoid using examples that the user can't run, like your 'invokeIOExample'
20:12:14 <Tekmo> DanBurton: I've made this mistake a lot in my own tutorials
20:12:16 <shachaf> Less likely to get drowned out in here etc.
20:12:29 <Tekmo> DanBurton: Always go the extra mile to make every single example complete and testable
20:12:50 <Tekmo> I can whisper Dan
20:12:53 <Tekmo> What's the command for that?
20:12:54 <DanBurton> ugh, but that takes so much work >,<
20:13:15 <Tekmo> Did you get that?
20:13:18 <DanBurton> yeah
20:13:23 <Tekmo> Ok, because I can't see it
20:13:25 <Tekmo> :)
20:13:30 <Tekmo> Alright, I'll just whisper you
20:13:51 <frankbro> Is there a way to format strings like what Text.Printf does but lets you store it to string
20:14:34 <DanBurton> Tekmo: I whispered back; you should have a tab for it or something in your chat client
20:21:00 <cl1> Tekmo: lets say I take a programmatic approach to it. Why do I have to wait until I'm highly proficient in haskell before I learn category theory, when the reason I want to learn category theory is to help me become proficient in Haskell? LOL
20:22:16 <josephle> cl1: Tekmo is arguing that studying category theory from books won't make you a better haskell programmer.
20:22:48 --- mode: ChanServ set +o copumpkin
20:22:53 --- mode: copumpkin set -o copumpkin
20:23:02 <DanBurton> there's a certain intuition to good programming that "just happens" to be described by category theory
20:23:25 <DanBurton> knowing category theory can't give you that intuition, but it can help you strengthen it once you've got it
20:23:30 <DanBurton> imo
20:23:42 <josephle> category theory gives out names to certain patterns in haskell programming that you pick up by intuition
20:23:53 <josephle> but a category theory book isn't going to magically give you that intuition
20:23:53 <kimochiwarui> DanBurton: just as a lot of mathematical structures that can be borrowed across seemingly unrelated fields "just happen" to be described by CT?
20:24:13 <DanBurton> kimochiwarui: yes
20:24:33 <lightquake> downside of installing everything in userland: i changed my username and cabal is massively confused
20:24:34 <josephle> DanBurton: more like we arbitrarily made the structures fit, yes? :P
20:25:52 <DanBurton> josephle: more like, there are core ideas behind the "good ideas" of one field of study that are equally good when applied to other fields of study, and CT is the quest to find out what those core ideas are
20:25:53 <elliott> downside to using unix, more like :P
20:26:33 <Tekmo> cl1: You have it all wrong.  It's not "learn Haskell and then learn category theory".  It's "learn category theory as a side effect of learning Haskell"
20:26:36 <josephle> DanBurton: I've read the Rosetta Stone paper, I was just joking with you.
20:27:52 <josephle> DanBurton: also, I never knew you could make functions of type Pause IO, considering the type is of kind (* -> *).
20:28:07 <josephle> I learn more about Haskell's type system everyday
20:28:54 <shachaf> josephle: Were you the Joseph-person at the hacker-dojo-place on Thu?
20:29:02 <DanBurton> josephle: look again, Pause is of kind (* -> *) -> *, not (* -> *) -> * -> *
20:29:16 <josephle> shachaf: yes, yes I was!
20:29:19 <DanBurton> josephle: but of course later this is corrected with PauseT
20:29:38 <josephle> DanBurton: Oh! You're right!
20:30:31 * DanBurton wrote these tutorials instead of going to the hacker dojo... got stuck in traffic in SF 'cause I forgot my computer charger cord.. :(
20:30:54 <shachaf> wait, what's Pause?
20:30:58 <Tekmo> I still haven't met you in person, Dan!
20:31:00 <shachaf> \x -> Free x ()?
20:31:00 <Tekmo> We need to meet soon
20:31:07 <Tekmo> I'm very free for the next few weeks
20:31:53 <shachaf> And DanBurton is pretty forgetful.
20:31:57 <shachaf> It's a perfect match.
20:32:34 <Tekmo> Are you saying that I'm pretty forgetful?  Because you would be correct
20:32:50 <shachaf> No, DanBurton is forgetful. For instance of his charger cord.
20:33:16 <DanBurton> I would call myself "scatterbrained" or "absent minded" rather than "forgetful"
20:33:18 <cl1> I see, that makes total sense. like design patterns in c#, which I work with all the time. When I read about them I learned a lot. However I, just as you said, in many cases it gave me names to apply to concepts I had already figured out.
20:33:24 <elliott> scatterbrained functor
20:33:30 <shachaf> DanBurton: But that doesn't make an adjunction, now does it.
20:34:23 <Tekmo> Yes, category theory concepts are very much like design patterns
20:34:34 <Tekmo> Except, unlike most design patterns, they actually work
20:34:55 <cl1> lol, i here you.
20:35:07 <cl1> s/here/hear/
20:35:11 <Tekmo> :)
20:35:12 <josephle> rigorous mathematical proofs have a way of making sure things work
20:35:48 <cl1> i hate to ask and run, but my wife is bugging me to go get father's day cards. Thanks for the insight
20:36:28 <pozori> speaking of math, do I need a strong background in math to understand functional programming?
20:36:36 <Tekmo> No
20:36:47 <DanBurton> Tekmo: yeah we should meet up sometime, I'm pretty free as well. Any other SF-area peeps want to meet up for dinner sometime soon?
20:36:54 <dmj> Small issue parsing strings and integers in Parsec, appreciate another set of eyes.
20:37:02 <dmj> http://hpaste.org/89983
20:37:14 <shachaf> bahaskell in SF is hopefully happening this month.
20:37:25 <Tekmo> DanBurton: How about next weekend?
20:38:21 <DanBurton> there's a bahaskell in SF? I thought that bahaskell was the same as haskellers in hacker dojo
20:38:28 <DanBurton> Tekmo: sounds good to me
20:38:43 <shachaf> DanBurton: Nope. bahaskell is separate.
20:38:56 <shachaf> Everyone should sign up for the mailing list if they haven't.
20:39:05 <DanBurton> link?
20:39:10 <DanBurton> @where bahaskell
20:39:10 <lambdabot> http://groups.google.com/group/bahaskell
20:39:22 <shachaf> Yes, that.
20:39:35 <shachaf> It hasn't been happening recently. But Ivan mentioned that he wants to do one soon, I think.
20:39:59 <shachaf> If anyone knows a good venue in SF -- near Caltrain if possible -- you should mention it!
20:40:19 <DanBurton> Oh I'm already a member; there just haven't been a lot of posts lately
20:40:44 <shachaf> Yep.
20:40:48 <arkeet> I guess I'll subscribe.
20:40:58 <shachaf> Conal mentioned he might do a talk.
20:41:27 * DanBurton wonders if Stripe would be willing to host the haskellers, like it hosts the category theory meetups
20:41:56 <shachaf> Stripe is pretty far from Caltrain now.
20:47:09 <apples> DanBurton, is this the meetup page for the category theory meetups you mentioned? http://www.meetup.com/Bay-Area-Categories-And-Types/
20:47:35 <DanBurton> apples: yep
20:48:07 <apples> is it a public sort of thing? i don't know much about category or type theory, but i want to learn more
20:50:25 <shachaf> apples: Yep. Come next month!
20:50:36 <apples> awesome, i will :)
21:05:48 <Demos> at what point should I consider using lens instead of records?
21:06:09 <Tekmo> You can use both
21:06:30 <geekosaur> I was under the impression one point of lens was to make working with records saner
21:06:44 <arkeet> indeed.
21:06:45 <dmwit> at the point (3, 7)
21:06:47 <arkeet> it's not really an "instead" thing.
21:06:48 <Demos> I thought they were for making record syntax nicer
21:07:29 <arkeet> lens is worth learning, imo.
21:08:04 <Tekmo> Yeah, lens is definitely worth learning
21:08:05 <geekosaur> lens is about flexible access and manipulation. of records, or tuples, or anything else, really
21:08:34 <hodapp> lens is something I've yet to learn much about... in this context at least
21:08:50 <arkeet> lenses are pretty handy, sure.
21:08:54 <arkeet> but lens is much more than lenses.
21:08:54 <Demos> yeah I will learn it eventually, but I need to work with more basic haskell sutff first, get a good handle on the rest of the language and understand their rationale by running into the problems they solve
21:09:04 <arkeet> sure.
21:09:17 <Demos> I hear lens is a very abstract library
21:09:24 <DanBurton> we should just rename the package "edwardk". import Control.Edward.K
21:09:38 <Demos> the equivalent of a hardcore c++ template library
21:09:43 <Hafydd> At what point should I consider using records instead of tuples?
21:10:11 <applikativ> well, a record can be recursive, though mysteriously no one uses them that way
21:10:29 <Hafydd> I'm pretty sure most people use lists.
21:10:47 <slack1256> http://hpaste.org/89984 is ghci about the space usage of that string?
21:10:51 <applikativ> lists arent a record type, can you imagine the show instance??
21:11:01 <monochrom> when one or more of these conditions hold: you use a 3-tuple or longer; you use two n-tuples, same n, for two different purposes
21:11:09 <Hafydd> How are you defining a "record type"?
21:11:11 <shachaf> slack1256: ghci isn't telling you much about the space usage of that string.
21:11:34 <shachaf> It's telling you about (a) the total allocations it's doing (b) to do the whole thing it's doing, including printing out the string etc.
21:11:39 <slack1256> So, I can't say that ocupies around 1 Mb right?
21:11:41 <slack1256> Oh, okey
21:11:53 <slack1256> that makes sense
21:12:18 <dmwit> slack1256: http://stackoverflow.com/q/3254758/791604
21:13:33 <geekosaur> also note that ghci / bytecode is not optimized, so it tends to do a lot of unnecessary allocations
21:14:00 <dmwit> DanBurton: I don't think it's possible to Control Edward K.
21:14:16 <slack1256> OK, that SO answer helps alot, I will do some checking to see how that applies
21:14:30 <dmwit> Except insomuch as you can put a really hard problem in front of him and expect it to be either solved or deemed uninteresting within two months.
21:14:39 <dmwit> possibly both
21:14:40 <slack1256> right geekosaur, I have to keep in mind that.
21:15:12 <applikativ> so Chars take two words, : takes one
21:15:54 <dmwit> Char is one word, I'm sure.
21:16:23 <dmwit> ...oh, you think it's boxed, huh?
21:16:27 <dmwit> I guess I believe that.
21:16:37 <applikativ> Well it's Char# #Char
21:16:44 <dmwit> right
21:16:47 <applikativ> or however you do the darn #s
21:16:56 <applikativ> oh yeah we agree
21:17:25 <applikativ> > 3 * 8 * length "/home/slack/P2P/bittorrent/torrents/cargar/0f2153256a3750e408930d75c92fee03.torrent"
21:17:26 <lambdabot>   1992
21:17:32 <geekosaur> again, no optimization; it'll be boxed. unless invoked compiled code unboxes (and possibly reboxes) it
21:17:36 <applikativ> sorta
21:17:45 <shachaf> copumpkin: Nope.
21:18:05 <applikativ> isn't there some function that declares this outright somehow?
21:19:45 <slack1256> oh
21:19:55 <slack1256> OK a word per char, that make sense
21:20:01 <applikativ> slack1256: of course the corresponding Text will be much smaller, since its just the unboxed Chars smushed against each other, to put it crudely
21:20:24 <applikativ> slack1256: well really two, unless it is unboxed by optimization
21:20:39 <geekosaur> yeh, String is convenient but a bit 'sloppy' and wasteful of space
21:23:35 <xico> lambdabot: @fp f $
21:23:35 <lambdabot> Maybe you meant: wn v rc pl id faq do bf @ ? .
21:23:38 <xico> nah
21:23:44 <applikativ> fp?
21:23:49 <xico> lambdabot: @pl f $
21:23:49 <lambdabot> (line 1, column 4):
21:23:49 <lambdabot> unexpected end of input
21:23:49 <lambdabot> expecting white space or simple term
21:24:08 <applikativ> @pl g f x =  f $ x
21:24:11 <lambdabot> g = id (fix (const ($)))
21:24:11 <lambdabot> optimization suspended, use @pl-resume to continue.
21:24:16 <applikativ> hag
21:24:19 <applikativ> hah
21:24:36 <applikativ> @pl g f x =  f  x
21:24:36 <lambdabot> g = id
21:24:43 <xico> @pl f c 0 b a >>= \x -> (f s 0 b a >>= return . (x -^))
21:24:46 <lambdabot> f c 0 b a >>= (f s 0 b a >>=) . (return .) . (-^)
21:24:46 <lambdabot> optimization suspended, use @pl-resume to continue.
21:25:05 <applikativ> @pl-resume
21:25:11 <lambdabot> f c 0 b a >>= (f s 0 b a >>=) . (return .) . (-^)
21:25:12 <lambdabot> optimization suspended, use @pl-resume to continue.
21:25:26 <xico> beautiful :)
21:25:33 <xico> thanks applikativ
21:26:28 <dmwit> "foo >>= return . bar" probably better spelled "fmap bar foo"
21:26:38 <dmwit> or use one of fmap's many synonyms
21:27:20 <applikativ> @pl f c 0 b a >>= \x -> liftM (x -^) (f s 0 b a)
21:27:23 <lambdabot> flip (liftM . (-^)) (f s 0 b a) =<< f c 0 b a
21:27:24 <lambdabot> optimization suspended, use @pl-resume to continue.
21:28:03 <applikativ> @pl goo a b c s =  f c 0 b a >>= \x -> liftM (x -^) (f s 0 b a)
21:28:05 <dmwit> oh, even better
21:28:06 <lambdabot> goo = id (fix (const (ap (ap . (flip .) . (((.) .) .) . (((>>=) .) .) . flip (flip . flip (flip f 0))) (((flip (liftM . (-^)) .) .) . flip (flip . flip (flip f 0))))))
21:28:06 <lambdabot> optimization suspended, use @pl-resume to continue.
21:28:15 <dmwit> Just use liftM2 (-^) (f c 0 b a) (f s 0 b a)
21:28:17 <applikativ> sorry , sorry
21:28:20 <dmwit> xico: ^^
21:28:57 <xico> awesome!
21:29:06 <applikativ> oh i see it,
21:29:10 <dmwit> Bonus points if you eliminate the 0 b a arguments somehow. More liftM2's and some on, probably.
21:30:06 <applikativ> liftM2 (liftM2 (-^)) (f c 0 b ) (f s 0 b )
21:30:12 <applikativ> if a is the last parameter
21:30:33 <copumpkin> :t liftM2 . liftM2
21:30:34 <lambdabot> (Monad m, Monad m1) => (a1 -> a2 -> r) -> m (m1 a1) -> m (m1 a2) -> m (m1 r)
21:30:38 <applikativ> this progress is not going to increase intelligibility
21:31:01 <dmwit> (liftM2 . liftM2 . liftM2 . liftM2) (-^) (f c) (f s) 0 b a
21:31:30 <copumpkin> dmwit: I don't like repeating myself. Can you factor out that f and all those liftM2s, please
21:31:45 <applikativ> :t join (.) liftM2
21:31:46 <lambdabot>     Occurs check: cannot construct the infinite type: r0 = m0 r0
21:31:46 <lambdabot>     Expected type: ((a10 -> a20 -> r0) -> m0 a10 -> m0 a20 -> m0 r0)
21:31:46 <lambdabot>                    -> ((a10 -> a20 -> r0) -> m0 a10 -> m0 a20 -> m0 r0)
21:31:53 <applikativ> oops
21:32:00 <copumpkin> that would be too easy
21:32:00 <dmwit> on f ((liftM2 . liftM2 . liftM2 . liftM2) (-^)) c s 0 b a -- hth, copumpkin
21:32:12 <copumpkin> wait, but what about all those liftM2s!?
21:32:13 <dmwit> needs dependent types for other request, hth
21:32:21 <copumpkin> :(
21:32:33 <copumpkin> I guess I'll make do
21:33:01 <applikativ> iterate (liftM2 .) id
21:33:09 <applikativ> :t iterate (liftM2 .) id
21:33:10 <lambdabot>     Occurs check: cannot construct the infinite type: a10 = m0 a10
21:33:10 <lambdabot>     Expected type: (a10 -> a20 -> r0) -> a10 -> a20 -> r0
21:33:10 <lambdabot>       Actual type: (a10 -> a20 -> r0) -> m0 a10 -> m0 a20 -> m0 r0
21:33:19 <applikativ> i'm having bad luck
21:33:20 <dmwit> applikativ: The liftM2's are each at a different type.
21:33:27 <dmwit> So you're not going to be able to get there that way.
21:33:53 <applikativ> yes, I wont make it all the way. but what i was just interested in (a -> ...)
21:33:58 <applikativ> blah
21:34:09 <dmwit> (Indeed, it's not 100% clear that "on" is a correct function to use here -- perhaps the f's were also being used at different types, and this distinction is erased when using "on".)
21:35:10 <xico> :t on
21:35:11 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
21:35:14 <dmwit> applikativ: Even the reader bits were each at different types...
21:35:17 <xico> :info on
21:35:21 <dmwit> ?src on
21:35:22 <lambdabot> (*) `on` f = \x y -> f x * f y
21:35:33 <xico> :)
21:35:57 <dmwit> I guess I got my argument order backwards.
21:36:11 <dmwit> ...and miscellaneous other bugs, too, I'm sure.
21:37:03 <applikativ> oh i see now, noodling in ghci. mechanism takes over as usual at some point
21:37:30 <dmwit> mechanism?
21:38:01 <applikativ> in the brain, in place of the usual ... spritual operation?
21:39:13 <applikativ> i wish i could think of some interesting-to-me use of some concurrent haskell; i have been studying smarlow's manuscript again
21:40:09 <dmwit> Network and/or database stuff is the usual culprit.
21:40:13 <dmwit> ...or GUI stuff.
21:40:33 <applikativ> yes, i know, network stuff is the obvious answer
21:40:39 <Tekmo> Games are an interesting use of concurrent programming
21:40:42 <applikativ> since i know 0 about databaes
21:41:10 <Tekmo> Make a multiplayer text-based game
21:41:35 <monochrom> then type in "number of human players: 0"
21:41:40 <Twey> applikativ: Almost anything can be made concurrent if you try hard enough.  Ask the Erlang folks :√æ
21:41:41 <dmwit> Set up a bot that does something useful on your favorite website.
21:42:14 <monochrom> solve all project euler problems in parallel
21:42:43 <applikativ> thats parallelism monochrom; concurrency is when you download each problem separately...
21:42:52 <monochrom> solve each project euler prime number problem by dividing n by 2, 3, 4, 5... in parallel
21:42:59 <dmwit> applikativ: Find a problem that's not solvable by brute force and kick off one thread per CPU trying random solutions...
21:43:14 <Tekmo> No
21:43:22 <Tekmo> Submit one stack overflow question per project euler problem
21:43:27 <Tekmo> then collect the results
21:43:30 <Tekmo> Retry as necessary
21:43:32 <applikativ> hah
21:43:55 <monochrom> write yet another irc bot
21:44:31 <tunixman> I'm thinking about replacing an IRC bot I had done in Python with Haskell to learn it better.
21:44:34 <applikativ> there's been a lot of those; they have the advantage of being intelligble.
21:44:57 <applikativ> maybe i'll make an ircbot with pipes-concurrency, wonder how that would work.
21:45:02 <mikeplus64> elliott: yes, that's could happen
21:45:04 <monochrom> high frequency bitcoin trading
21:45:25 <Tekmo> Speaking of that, I've been thinking of making a `pipes`-based console
21:45:33 <shachaf> as
21:45:35 <shachaf> Er.
21:45:53 <tunixman> Or maybe something with Machines, but I'd need to really learn a lot to pull that off.
21:45:58 <Tekmo> i.e. something that opens up a prompt and output and you interface with them as pipes
21:46:04 <cl1> any operation on a list that is not an aggregate operation is a candidate for parallelism
21:46:13 <applikativ> not into machines, still figuring out proxies, tunixman
21:46:17 <elliott> mikeplus64: alright
21:46:28 <Tekmo> The `pipes-4.0` branch is much simpler now
21:46:37 <Tekmo> Let me link you to it
21:46:38 <dmwit> cl1: (...but we're discussing concurrency, not parallelism.)
21:46:44 <applikativ> is it buried on github somewhere
21:46:47 <JoeyA> high frequency bitcoin trading with -enumerators- -conduits- -pipes- -iostreams- pipes
21:46:52 <applikativ> yes we were discussing concurrency
21:46:53 <Tekmo> https://github.com/Gabriel439/Haskell-Pipes-Library/tree/aleksey
21:46:58 <Tekmo> That's the active branch
21:47:14 <Tekmo> It's done at this point and I'm just working on the new tutorial
21:47:18 <elliott> mikeplus64: I'm playing around with a work-in-progress @run plugin replacement based on repl, it's very promising in terms of speed but I think I'll have to either hack up at least half the repl code or just integrate it directly for it to be viable :P
21:47:24 <cl1> s/parallelism/concurency/
21:47:28 <cl1> better?
21:47:36 <dmwit> Not really.
21:47:46 <dmwit> You used the right word. We're just not interested in that.
21:47:52 <dmwit> (at the moment)
21:48:40 <Tekmo> (I'm interested)
21:48:48 <mikeplus64> elliott: i'm not sure why you'd send things from multiple threads though
21:49:46 <elliott> mikeplus64: well, lambdabot runs asynchronously. you can have two @runs fired up near-simultaneously and running independently
21:50:57 <mikeplus64> why does it matter? the results should be the same, ie "<nick>: <result>"
21:51:25 <mikeplus64> actually i forget if i made it format the results as "<nick>: " in repl or just my irc bot
21:52:32 <mikeplus64> elliott: yeah if you use repl' with the defaults but change defaultProcessOutput, then it should be O.K.?
21:53:19 <elliott> well, users can /msg lambdabot -- those replies need to go to the right place. I suppose you are right that I could include such a tag with the output, however it would mean I couldn't use prompt_ directly and such and would have to feed stuff through more indirectly?
21:53:29 <cl1> wtf is concurrent that wouldn't also be parallel?
21:53:32 <elliott> which seems like a pain
21:53:38 <mnbernstein> cl1: lots of things
21:53:49 <Tekmo> A multiplayer game
21:54:27 <mnbernstein> cl1: http://vimeo.com/49718712 that's a pretty decent talk on the differences
21:54:44 <mnbernstein> (Rob Pike who works on go)
21:55:33 <cl1> so are we talking concurrency in the since that we are simulating parallelism on a single processor machine?
21:55:51 <cl1> s/since/sense/
21:55:58 <monochrom> 10 threads time-sharing one CPU is concurrent but not parallel
21:56:24 <mnbernstein> cl1: A web server serving pages to 5 people in one process is concurrent but not parallel
21:57:12 <monochrom> sometimes you create those 10 threads just for convenience, not really caring about parallel
21:57:50 <dmwit> cl1: "parallel" is for code where the answer doesn't depend on execution order; "concurrent" is for code where you hope the answer does depend on execution order
21:59:12 <shachaf> conal's thing about efficient parallel algorithms on perfect binary trees was interesting.
22:00:14 <applikativ> i think i hadn't notice type synonymns like type Effect m r = Proxy a' a b' b m r
22:00:26 <applikativ> were permissible, though it stands to reason
22:00:36 <Tekmo> They were
22:00:51 <Tekmo> The only reason I didn't have them before was to avoid some problem with RankNTypes
22:00:58 <Tekmo> But now I keep both the concrete and polymorphic versions
22:01:19 * shachaf is now in favor of requiring an explicit forall there.
22:01:35 <Tekmo> Where?
22:02:29 <shachaf> The right side of a type synonym, for every variable not mentioned on the left side.
22:02:49 <applikativ> forall a' a b' b . Proxy ...
22:02:51 <Tekmo> Isn't that the current behavior?
22:02:56 <applikativ> shachaf is trying to kill us
22:03:12 <shachaf> Is it? The type applikativ gave doesn't have them.
22:03:13 <Tekmo> type Effect m r = forall a' a b' b . Proxy a' a b' b m r
22:03:17 <Tekmo> It's there
22:03:19 <shachaf> GHC doesn't require them.
22:03:19 <Tekmo> He just didn't mention it
22:03:27 <Tekmo> I didn't know that
22:03:30 <Tekmo> I thought you needed the forall
22:03:39 <shachaf> Hmm.
22:03:45 <shachaf> Maybe you don't need it only if there's a constraint...
22:03:53 <Tekmo> Let me test
22:03:54 <shachaf> @let type Foo a = a -> b
22:03:56 <lambdabot>  .L.hs:142:19: Not in scope: type variable `b'
22:03:56 <applikativ> oh i know how it happened, I did :browse, and it showed the type
22:03:58 <shachaf> @let type Foo a = () => a -> b
22:03:59 <lambdabot>  .L.hs:142:19: Not in scope: type variable `b'
22:04:03 <applikativ> omitting the forall
22:04:04 <shachaf> @let type Foo a = (Show b) => a -> b
22:04:05 <elliott> mikeplus64: anyway, I don't know quite how it'll look yet, especially with the need for a separate server process etc., so right now I'm just hacking the repl code into a complete specialised-for-lambdabot mess and maybe something mergeable into repl could be made out of that at a later date once I figure out exactly how it should work :P
22:04:08 <lambdabot>  Defined.
22:04:08 <cl1> write a no lock reader writer on a single resource, that would be concurrent
22:04:09 <shachaf> There we go.
22:04:15 <shachaf> If you have a constraint it doesn't need the forall.
22:04:22 <Tekmo> That makes sense
22:04:26 <shachaf> Which is just completely broken behavior, because constraints and foralls are independent.
22:05:03 <mikeplus64> elliott: alright. it was really easy to put into my simple irc bot (seeing as i more or less designed repl for it ;)) but i'm not sure how the lambdabot plugin system works
22:05:21 <cl1> dmwit: so you are say concurent is defined by a shared resource, where parallel is not?
22:06:36 <elliott> mikeplus64: yeah, it needs hacking with to support persistence of definitions anyway, so I just figure it's easier to find out exactly what lambdabot wants from an "evaluation server" and then work backwards from that
22:06:44 <applikativ> I missed this, there is still the curiosity that ghci thinks that the synonym doesn't have a forall
22:07:23 <Tekmo> cl1: That's sort of on the right track
22:07:40 <Tekmo> cl1: Parallelism is usually for computing things faster by leveraging more cores
22:08:05 <Tekmo> cl1: Concurrency is more about just having multiple threads multiplex several resources simultaneously
22:08:39 <Tekmo> The classic example of concurrency is your IRC chat bot
22:08:50 <Tekmo> -bot
22:09:03 <Tekmo> You have two things going on at the same time: input and output
22:09:07 <Tekmo> They are both concurrent
22:09:39 <Tekmo> They manage two separate potentially blocking resources
22:09:49 <cl1> a shared resource
22:09:59 <Tekmo> The first resource is your input
22:10:05 <Tekmo> The second resource is other people's input
22:10:10 <Tekmo> You want to collect both simultaneously
22:10:30 <Tekmo> So you have two threads, one for each source and they both interact with the shared resource of your terminal
22:11:40 <danbst> Hello guys. I have data R32 = EAX | ECX | EDX | EBX | ESP | EBP | ESI | EDI . In some cases, I want to reject ESP data constructor (and in other - ESP and EBP). How can I do it type-level, so improper constructor throws a type-check error?
22:12:26 <applikativ> but some constructors are used in all cases?
22:12:36 <danbst> yes
22:13:01 <danbst> in fact, all, except ESP
22:13:31 <applikativ> if you scrap ESP
22:14:04 <applikativ> then you the original type will be Maybe R32
22:14:05 <danbst> that would give more boilerplait
22:14:13 <applikativ> to look at it in an unpleasant way.
22:14:15 <applikativ> yes.
22:14:25 <Tekmo> So there's a quick and dirty trick
22:14:35 <Tekmo> I can think of two separate tricks
22:14:41 <Tekmo> The first is:
22:14:55 <Tekmo> data R32 a = EAX | ECX | EDX | EBX | ESP a | EBP
22:15:08 <Tekmo> Then you can statically forbid the ESP constructor by requesting something of type `R32 Void`
22:15:13 <applikativ> right
22:15:21 <Tekmo> The second way is to do the same thing with GADTs
22:15:22 <applikativ> this was my next plan
22:15:43 <danbst> oh
22:15:56 <Tekmo> The point is that
22:16:04 <Tekmo> There has to be a change to the shape of the type
22:16:14 <Tekmo> It can't be just a plain `R32`
22:16:19 <applikativ> data R32 :: Bool -> * where EAX :: R32 b; ESP :: R32 True
22:16:24 * danbst thinks, that he understood the purpose of phantom types
22:16:40 <Tekmo> Yeah, applikativ has the right idea
22:16:53 <Tekmo> No matter what you will need to add some sort of type parameter to R32
22:17:11 <Tekmo> The idea is that there has to be a difference in type between the case where you accept all constructors and the case where you accept all-but-one constructor
22:17:23 <Tekmo> If there is no type parameter then you cannot express the difference in the type
22:17:55 <danbst> ok. Can Enum be automatically derived in such case?
22:18:03 <Tekmo> Does it need to be?
22:18:06 <Tekmo> You only have 6 constructors
22:18:57 <danbst> Tekmo, there was a bunch of question yesterday
22:19:40 <Tekmo> About what?
22:19:56 <danbst> http://hpaste.org/89966
22:20:24 <danbst> index function can be replaced with fromEnum, when properly ordered data constructors
22:20:43 <Tekmo> I mean, you can define `Enum` yourself by hand
22:20:58 <Tekmo> instance Enum (R32 a) where ...
22:21:45 <Tekmo> Even better
22:21:50 <Tekmo> If all you need is the index function
22:21:55 <Tekmo> Just define that by hand
22:22:02 <blackdog> tunixman: hey, nice to see you in-channel :)
22:22:03 <lispy> :t Just undefined :: Maybe Void
22:22:04 <lambdabot> Not in scope: type constructor or class `Void'
22:22:13 <Aetherspawn> wow Rust is inspired by haskell so much
22:22:24 <Tekmo> index r = case r of EAX -> 0; ECX -> 1; EDX -> 2; EBX -> 3
22:22:53 <danbst> Tekmo, sure.
22:23:02 <Tekmo> Or define the `Enum` instance and define:
22:23:13 <danbst> it distracts me, because of a lot of additional code
22:23:15 <Tekmo> fromEnum r = case r of EAX -> 0; ECX -> 1; EDX -> 2; EBX -> 3
22:23:20 <Tekmo> It's just a different name for the same function
22:23:39 <danbst> but I've got the idea
22:24:01 <Tekmo> No matter which path you choose you should be using pattern matching and not `elemIndex`
22:24:24 <Tekmo> Pattern matching is more efficient and doesn't require the use of partial functions like `fromJust`
22:24:48 <danbst> agree
22:26:28 <lispy> I just want to point out that with this solution, data R32 a = EAX | ECX | EDX | EBX | ESP a | EBP, even if you use R32 Void, someone can cheat with ESP undefined
22:27:26 <Tekmo> They could also cheat by passing `undefined` directly
22:28:14 <Tekmo> myFunctionThatDoesNotAcceptESP undefined
22:28:57 <lispy> but unless you look at the `a` in ESP a, you can still process ESP undefined
22:29:06 <Tekmo> I think if you are willfully using `undefined` anywhere then that violation is the least of your worries
22:29:20 <danbst> Tekmo, and what do you think about using typeclass like in http://hpaste.org/89971 ?
22:29:21 <lispy> And given than the `a` is just there for static typing it's unlikely you'll look at it
22:30:03 <Tekmo> Right, but the user cannot synthesize a value of type `ESP Void` without using `undefined`
22:30:08 <Tekmo> Also, you can use `absurd` to eliminate that case
22:30:14 <Letchik> http://hpaste.org/89989
22:30:14 <Letchik> Hi. I've just install Leksah and there is a hello world package leksah-welcome and there at the line 64 there is a dollar sign which is not used as a syntactic sugar for no parentheses. What is this?
22:30:14 <Letchik> Also another question: there is a cpp define defining MAIN_FUNCTION as exeMain but no such define for testMain but still testMain gets successfully launched by QuickCheck. How does it work? Where does the other define come from?
22:30:33 <lispy> undefined or let x = x in x, or something that is accidentally forall a. a
22:31:10 <Tekmo> The type class solution won't do what you want it to, if I understand your solution correctly
22:31:20 <lispy> Tekmo: I understand that it's a pragmatic compromise that works in most cases. I just like to point out that it's not a proof.
22:31:31 <hamishmack> Letchik: http://stackoverflow.com/questions/940382/haskell-difference-between-dot-and-dollar-sign
22:32:12 <shachaf> hamishmack: This $ is a TH splice. I don't think that link really explains it.
22:32:20 <Tekmo> I think it's implicit that most proofs in Haskell are unsound thanks to `undefined`
22:32:31 <hamishmack> ooops
22:32:40 <Letchik> shachaf: yep, the link is about other $. With this $ it stops working if I put a space between $ and function name.
22:32:52 <shachaf> Letchik: This is a Template Haskell splice.
22:33:07 * hackagebot dom-selector 0.2.0.0 - DOM traversal by CSS selectors for xml-conduit package  http://hackage.haskell.org/package/dom-selector-0.2.0.0 (nebuta)
22:34:04 <lispy> Tekmo: not everyone is well versed in that :)
22:34:05 <hamishmack> (I should have looked at the code before commenting)
22:34:24 <danbst> thanks. I've thought, it would be good to have type constraints, even if they are typeclass based
22:34:27 <Tekmo> lispy: :)
22:35:21 <Letchik> shachaf: ok, thx, I'll better read some tutorial about template haskell
22:37:15 <hamishmack> Letchik: IIRC MAIN_FUNCTION is defined as testMain in the .cabal file, but only when building the test suite
22:38:36 <Letchik> hamishmack: So if I make my own packages will I have to define that myself or is that defined in QuickCheck?
22:39:37 <Letchik> hamishmack: nvm, I opened the .cabal file and it is self-explanatory
22:39:44 <Letchik> hamishmack: thanks for help
22:39:51 <hamishmack> It might be simpler to have a sepparate Main module for your test suite
22:52:39 <applikativ> danbst: http://hpaste.org/89991 has a datakinds version; i was hoping for more from StandaloneDeriving, but it gives Show and Eq
22:54:36 <applikativ> oh wait, it gives an Ord instance too, danbst
22:55:32 <danbst> applikativ, examining...
22:55:58 <applikativ> it might not be practical but this procedure has a number of nice features
23:01:24 <danbst> applikativ, cool, it works! big thanks
23:02:15 <applikativ> danbst heres a couple more doodads http://hpaste.org/89992
23:03:44 <SingingBoyo> Does SDL-gfx just not work for haskell?  Standard SDL stuff works fine, but SDL-gfx calls don't render anything
23:07:15 <SingingBoyo> ah nvm, seems I'm misusing a function somewhere when creating my colors
