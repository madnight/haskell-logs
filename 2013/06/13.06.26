00:00:24 <Reite> The issue for me is more that when I get an error that noone else seems to be getting theres always a suspicion that its related to windows
00:00:28 <luite> OS X can be a bit tricky with dependencies like gtk
00:00:48 <luite> and the gcc/clang business
00:00:57 <u_> right gtk that's what i was forgetting
00:00:58 <Moggle_> really, why use OS X when you can just use a nice linux distro?
00:01:01 <u_> oh god yeah gcc
00:01:02 <Moggle_> what are the advantages?
00:01:10 <u_> all this "missing symbol" stuff
00:01:32 <u_> Moggle_ none, i was considering switching to linux for dev stuff actually
00:01:49 <Moggle_> u_: just use a VM! i'm doing that
00:01:59 <u_> same only
00:02:11 <u_> i'm trying to write a bitcoin trading bot atm
00:02:11 <johnw> Moggle_: if you don't think OS X has any advantages, then use Linux
00:02:21 <u_> and im not sure i wanna try to run that from inside a VM
00:02:30 <u_> or develop it in the VM then carry it out
00:02:57 <u_> so im just gonna tolerate emacs and abstain from using various packages like cairo for now
00:03:04 <Moggle_> johnw: i'm curious, are there advantages to OS X? i'm sort of biased against apple in general here, i'd like to get past that
00:03:08 <u_> (i really needed cairo for making charts)
00:03:30 <Twey> Moggle_: http://chocolatey.org/ :þ
00:03:49 <johnw> Moggle_: I have a huge software investment in OS X, so I have a ton of apps that I wouldn't have access to on Linux
00:04:03 <johnw> if I were only using Emacs and the terminal, then it wouldn't matter
00:04:22 <u_> imo osx just has a cleaner more organized feel to it than windows
00:04:44 <u_> no bs "wizards", no hideous rainbows, more attention to detail
00:05:04 * Kinnison generally finds that people who like OS X see only the good, and people who don't see only the bad.  It's a mixed-bag like any other OS.
00:05:05 <johnw> but this is really about Haskell on these platforms, not the platforms themselves
00:05:16 <johnw> Haskell is a bit better supported on Linux, but it's well supported on OS X also
00:05:26 <Moggle_> u_: to be fair, most everything has a cleaner, more organized feel to it than windows. only reason I'm using windows is because I enjoy gaming and dual booting is a pain.
00:05:34 <johnw> at work, we use Haskell on Linux only
00:05:43 <johnw> but I still do all my work development and testing on OS X.  Rarely has this caused a problem
00:05:45 <Twey> johnw: You use Haskell at work?  I'm jealous
00:05:54 <johnw> Twey: fpcomplete.com
00:06:03 <Moggle_> Twey: this looks nice actually, though it doesnt seem to have all the packages that my Mint VM has :( no GTK for example
00:06:21 <u_> actually id say the biggest problem with osx is all the problems i run into are a lot rarer.
00:06:42 <u_> seems like i'm the only one in the world to get a certain error message sometimes
00:07:42 <johnw> does explain all those userId == "u_" lines in the GHC code...
00:07:56 <Moggle_> haha
00:08:11 <Twey> johnw: Aha
00:08:30 <Twey> Hehe
00:09:13 <u_> heh
00:09:21 <Moggle_> huh, does darcs have a lot going for it over git?
00:09:30 <Moggle_> i see darcs everywhere but rarely git
00:09:35 <johnw> i'd ask that in #darcs or #git
00:10:21 <Twey> Or both, to get a balanced answer
00:10:25 <dmwit> darcs has a wonderful UI, and it was written in Haskell long before git existed.
00:10:42 <arkeet> don't people tend to prefer git now?
00:10:43 <dmwit> Probably the latter explains its popularity in the Haskell community.
00:10:56 <arkeet> well, the fact that it was written in haskell probably explains its popularity.
00:11:14 <dmwit> (Isn't that what I said?)
00:11:19 <Twey> The answer as I see it is that darcs is theoretically much nicer, but git is significantly faster and promoted by Torvalds.
00:11:26 <arkeet> my only experience with darcs is that it's sloooow.
00:11:30 <adnap> With darcs, I have to copy my directory to create a "branch"
00:11:45 <chrisdone> adnap++
00:11:57 <arkeet> with darcs, I can't use github.
00:11:58 <arkeet> :p
00:12:29 <adnap> I like how darcs lets you record (commit) in little bite-sized) chunks
00:12:34 <Moggle_> dmwit: well it compiled beautifully and without any pain, so all I can say is thanks for the help i appear to be a moron.
00:12:41 <johnw> adnap: git add -p
00:12:43 <chrisdone> adnap: eh, git does that too
00:13:13 <dmwit> Moggle_: Great! I'm happy it's working now. =)
00:13:24 <adnap> Is git just as good at separating "hunks"?
00:13:54 <Moggle_> dmwit: out of curiosity, I just did "ghc Drawing", got an error, so I tried "ghc --make Drawing.hs" and that worked
00:13:58 <Moggle_> dmwit: is that normally a thing
00:14:07 <arkeet> Moggle_: --make is unnecessary.
00:14:18 <dmwit> Moggle_: That is not normally a thing. Are you using a GHC older than 7.0?
00:14:30 <Moggle_> dmwit: nope, 7.6.3
00:14:32 <arkeet> well, it is unnecessary with recent ghc.
00:14:46 <adnap> I didn't know that
00:14:46 <dmwit> What was the error?
00:14:51 <Moggle_> dmwit: well, the error I got wasD:/Programs/Haskell/mingw/bin/ld.exe: reopening Drawing.exe: Permission denied
00:14:52 <adnap> I still use --make
00:15:06 <arkeet> Moggle_: try it again the first way.
00:15:07 <dmwit> Moggle_: I would file a bug on GHC's Trac.
00:15:32 <dmwit> Especially if you can find a way to reproduce it that doesn't depend on having gtk2hs installed. =)
00:15:41 <Moggle_> arkeet: it's already compiled so it ain't gonna do anything, but yeah i'll try cleaning the dir and doing it again. does ghc have a "ghc clean" command or something to make it easier?
00:15:43 <arkeet> sounds more like something was holding onto Drawing.exe
00:15:45 <Moggle_> dmwit: haha
00:15:48 <arkeet> you can alway s-fforce-recomp
00:16:06 <arkeet> or just remove the exe
00:16:06 <adnap> Is git just as distributed, practically, as darcs?
00:16:09 <Moggle_> arkeet: how on earth do you remember that flag, it's like -ddump-simpl or whatever for seeing output
00:16:18 <johnw> adnap: these are better questions for #git, really
00:16:23 <adnap> I guess I should try asking in #darcs
00:16:23 <adnap> Yeah
00:16:26 <arkeet> it doesn't seem that hard to remember.
00:16:30 <johnw> thanks
00:16:47 <arkeet> and I've used it a few times.
00:16:48 <adnap> I guess more darcs users know about git than the other way around
00:16:58 <johnw> likely!
00:17:17 <dmwit> adnap: I'm sure you can find a couple thousand darcs v. git articles with the interesting differences on the web.
00:18:08 <Moggle_> figures, trying it again made it work.
00:18:17 <Moggle_> i despise unreproducible bugs.
00:19:04 * hackagebot wai-app-file-cgi 0.8.4 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.8.4 (KazuYamamoto)
00:19:06 * hackagebot mighttpd2 2.8.5 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.8.5 (KazuYamamoto)
00:19:06 <arkeet> I'd blame Windows.
00:19:12 <Moggle_> yeeeeeah.
00:42:03 <Moggle_> oh cool
00:42:08 <Moggle_> i just reproduced it.
00:42:09 <Moggle_> >_>
00:42:14 <Moggle_> oh well redoing it fixes the problem
00:42:17 <Moggle_> such is windows.
00:44:00 <anonlsdljsdflsdn> http://hpaste.org/90445 I haven't been able to figure out the syntax to achieve what I want in this hpaste.  Can anyone please point me in the right direction?
00:46:16 <srhb> anonlsdljsdflsdn: data Atom = Atom { ... }; data MolSpec = AtomSpec Atom; ...?
00:47:42 <Moggle_> aha, a problem with gtk2hs when I got a friend to try installing it, the tutorial forgets to mention
00:47:49 <Moggle_> that you have to add your cabal bin to your path
00:48:00 <Moggle_> i must not have done that last time i tried to install it
00:48:09 <Moggle_> but at some point when messing around with cygwin and msys I had done that!
00:48:32 <anonlsdljsdflsdn> srhb: I think I tried that a while ago and it didn't work, but I've been modifying it since then. Let me try again.
00:49:05 <Moggle_> aha nevermind the tutorial DOES mention this
00:49:12 <Moggle_> but it's sort of all unclear and all over the place
00:49:19 <Moggle_> i shall edit this tutorial and make it a touch cleaner.
00:49:19 <srhb> anonlsdljsdflsdn: What I suggested does work. :)
00:49:33 <srhb> Moggle_: Thanks :)
00:50:05 <Moggle_> nevermind i dont have permission
00:50:18 <Moggle_> the likes of the haskell wiki are far too highbrow to let me edit it
00:50:23 <Moggle_> also known as i need to make an account.
00:51:02 <Twey> anonlsdljsdflsdn: You could also use a type synonym to avoid the syntactic overhead of wrapping/unwrapping the value if you're only going to use it there
00:51:54 <Twey> anonlsdljsdflsdn: The list already can only contain values constructed with Ctwo or Cthree (or bottom), by dint of being a list of Connection
00:55:47 <Moggle_> dumb question, ghc --help didn't have it, is there a flag to compile a haskell program so that no console shows up?
00:56:11 <Moggle_> if not i'm sure there's an "aftermarket" sort of way to do it, or I could just make a simple wrapper script.
00:56:40 <anonlsdljsdflsdn> srhb: I'm not sure what the hell I was doing earlier, but it works now.  Thanks!
00:56:43 <srhb> Moggle_: What do you mean console?
00:56:45 <srhb> anonlsdljsdflsdn: :)
00:57:06 <Moggle_> srhb: on windows, you double click an exe, a console shows up, despite the fact you're running a GUI
00:57:07 <dmj> ghc Main.hs > /dev/null
00:57:12 <dmj> after market
00:57:18 <Moggle_> srhb: just hiding that console is what I want.
00:57:31 <Moggle_> if this was python
00:57:35 <Moggle_> i'd run the script with pythonw
00:57:49 <srhb> Moggle_: Oh, I didn't know Windows versions did that.
00:58:00 <Moggle_> srhb: windows is a special snowflake of an OS and is silly.
00:58:07 <srhb> Yes, indeed.
00:58:10 <Twey> Windows executables have a flag of some kind that indicates whether or not to show a console when running the program
00:58:23 <shachaf> @google ghc windows hide console
00:58:24 <lambdabot> http://www.haskell.org/gtk2hs/archives/2005/06/23/hiding-the-console-on-windows/
00:58:24 <lambdabot> Title: Gtk2Hs » Blog Archive » Hiding the console on Windows
00:58:38 <Twey> Beaten to it ☹
00:58:44 <Moggle_> -optl-mwindows
00:58:46 <Moggle_> thanks shachaf!
00:59:08 <Walther> am I the only one who, while using consoles/terminals daily, still think something sketchy is going on when launching an app causes a console window to flash in the background :P
01:00:02 <srhb> Walther: In Windows, that would worry me, yeah.
01:00:07 <abc12345> Is there a moderator of www.haskell.org here?
01:00:11 <Botje> that just means it's written in a decent language.
01:00:46 <dmj> shachaf: Do you know any good introduction to functional dependencies in class declarations? The grabmuller paper introduced them. The ghc user guide says "There should be more documentation, but there isn't (yet). Yell if you need it."
01:00:59 <dmj> I'm not yelling, just asking
01:01:31 <dmj> Seems theres a paper on it, but its behind a paywall
01:02:06 <shachaf> Why ask me?
01:02:25 <Ralith> why not?
01:02:36 <shachaf> If I had a better Internet connection here I might look it up on the Google and give you some links.
01:02:37 <dmwit> abc12345: "moderator"?
01:03:09 <shachaf> With the 3-second latency as it is, someone else (e.g. you) will have to do it.
01:03:22 <abc12345> dmwit: someone who edits pages and maintains the site :)
01:03:45 <dmwit> abc12345: It is a wiki.
01:03:57 <abc12345> dmwit: Can i PM you?
01:04:00 <dmwit> So: you are a moderator.
01:04:09 <dmwit> I suppose, if you must.
01:05:55 <shachaf> abc12345: Generally you shouldn't /msg people unless there's a particular reason to.
01:06:06 <dmwit> There is a reason to.
01:06:19 <shachaf> OK. :-)
01:06:39 <abc12345> shachaf: true, dmwit: thank you :)
01:17:12 <chrisdone> Twey: http://ircbrowse.net/nick/Twey?recent=false
01:18:52 <dmj> http://web.cecs.pdx.edu/~mpj/pubs/fundeps-esop2000.pdf
01:20:12 <johnw> is there a way to use functional dependencies with a regular aDT?
01:20:25 <johnw> say I have Foo a b, and I want to state that only one b is possible for any given a
01:20:43 <johnw> well, since there are no instances, I guess that makes no sense really
01:21:57 <efie> http://jtdaugherty.github.io/vty-ui/ says I can use "$ cabal install vty-ui -fdemos" to install demos of this package, but where do I find or how can I evoke this demos? I searched for these demos at "/.cabal/lib/vty-ui"
01:22:44 <supki> I bet they are in ~/.cabal/bin
01:25:20 <arcatan> chrisdone: where does the oneliner in the nick subtitle come from?
01:25:33 <chrisdone> arcatan: random line from all time =)
01:25:47 <arcatan> okay :)
01:27:08 <dmwit> johnw: It can make sense. Define a type family (let's say, Bar), and then use "Bar a" instead of "b" everywhere in the definition of "Foo".
01:27:15 <efie> supki: thanks!
01:27:17 <dmwit> Seems like a strange thing to want, though.
01:29:01 <typoclass> oh grate. my own tagline is «circle: i think "@" synatx will work http://hpaste.org/89670», complete with a typo
01:29:23 <chrisdone> typoclass: idiot!!!1
01:29:34 * chrisdone napoleon dynamite face
01:31:48 <dmwit> typoclass: ...and my tagline is "eh".
01:31:52 <arcatan> my taglines represent the high quality of my contributions to the discussion. "so no hi to you" "monocat"
01:32:36 <typoclass> dmwit: for me, http://ircbrowse.net/nick/dmwit displays “Yes, I acknowledge this.” — dmwit
01:33:24 <typoclass> oh i see, you get another one on the 'all time' tab
01:34:34 <dmwit> man
01:34:40 <dmwit> I can't believe how much I agree with myself.
01:34:51 <alpounet> johnw, sounds like type families may fit
01:35:05 <kurak0t> dmwit has written 24,171 words, 2,420 lines (averaging 10 words per line), in the past 30 days, most active at around 5:00 (UTC).
01:35:14 <companion_cube> “sometimes, you have to do imperative things, like "write something on the console"” — companion_cube
01:35:17 <companion_cube> yay.
01:35:43 <kurak0t> haha
01:35:51 * shachaf : "I don't think so." / "No, wait."
01:35:55 <typoclass> i wonder if the style of messages will change, now that any of them could become your widely publicized tagline
01:36:07 <dmwit> chrisdone: Strange. My page says that there are logs for me in #haskell and #lisp, but clicking #lisp gives no results.
01:36:30 <Twey> chrisdone: Clearly I'm past my peak
01:36:32 <shachaf> dmwit: I think it says that for everybody.
01:36:56 <chrisdone> dmwit: yeah it's really just a link to search
01:36:59 <shachaf> dmwit: I.e., those links are "logs for this person in X", and it happens that this website only checks those two channels.
01:37:33 <dmwit> ...I see.
01:37:33 <Twey> chrisdone: Where do these quotes come from?
01:37:39 <chrisdone> dmwit: haha, an all time random choice of "eh", excellent
01:37:57 <Twey> chrisdone: Is #gurgling a replacement for an actual channel name?
01:38:03 * Twey does not remember ever being in such a place
01:38:12 <dmwit> shachaf: You really do have the greatest tagline pair.
01:38:15 <dmwit> so perfect
01:38:28 <chrisdone> Twey: the ones at the top are a random selection of all logs. it's supposed to look like a serious quote, but really it's random (and hopefully embarassing =p)
01:38:44 <typoclass> memorable quote from edwardk: "er that was a tongue sticking out, not an operator suggestion"
01:38:47 <Twey> The bottom
01:38:56 <typoclass> chrisdone: it's a beautiful idea, i love it =D
01:39:02 <Twey> I got a pretty good one, though: “‘DSL’ confuses me. When exactly does something become a DSL? HXT claims to be a DSL, but it's just a bunch of arrows.” — Twey
01:39:05 <chrisdone> Twey: ah the bottom are anything that someone wrote @remember for
01:39:09 <Twey> Aha
01:39:24 <chrisdone> dmwit: haha yeah, shachaf's quotes are perfect xD
01:39:28 <dmwit> shachaf's activity curve is a much more beautiful sine than mine. =(
01:41:04 <shachaf> dmwit: And you have more samples!
01:41:31 <dmwit> I wonder if there are any classes of sleeping disorder or similar that you can detect with this data.
01:41:52 <shachaf> I don't need classes on sleeping disorder! I'm an expert.
01:42:23 <dmwit> hehe
01:42:56 <cutsea110> Hi all
01:42:57 <typoclass> elliott's quotes are “Cale: ok, cool” and “gwern: hehe, indeed”
01:43:01 <typoclass> cutsea110: hello
01:43:39 <cutsea110> Hi typoclass.
01:43:57 <osa1> when I use ViewPatterns, I'm getting not matched pattern warnings even though I match all patterns(that can be returned from view function), is there a directive or something like that to suppress that warning?
01:44:19 <dmwit> chrisdone: When (if ever) does the random selection change?
01:44:30 <Twey> A large proportion of shachaf's quotes are edwardk-related
01:44:46 <Twey> Poor edwardk :þ
01:44:49 <cutsea110> I've failed to load regex-pcre-builtin. :-(
01:45:19 <cutsea110> >>= ghci -package regex-pcre-builtin
01:45:20 <cutsea110> GHCi, version 7.6.3: http://www.haskell.org/ghc/  :? for help
01:45:20 <cutsea110> Loading package ghc-prim ... linking ... done.
01:45:20 <cutsea110> Loading package integer-gmp ... linking ... done.
01:45:20 <cutsea110> Loading package base ... linking ... done.
01:45:20 <cutsea110> Loading package array-0.4.0.1 ... linking ... done.
01:45:20 <cutsea110> Loading package deepseq-1.3.0.1 ... linking ... done.
01:45:21 <cutsea110> Loading package containers-0.5.0.0 ... linking ... done.
01:45:21 <cutsea110> Loading package transformers-0.3.0.0 ... linking ... done.
01:45:22 <cutsea110> Loading package mtl-2.1.2 ... linking ... done.
01:45:22 <cutsea110> Loading package regex-base-0.93.2 ... linking ... done.
01:45:24 <cutsea110> ghc: unable to load package `regex-pcre-builtin-0.94.4.6.8.31'
01:45:44 <typoclass> cutsea110: when pasting more than one line, please use hpaste.org, thanks
01:45:44 <dmwit> osa1: possibly -fno-warn-incomplete-patterns
01:45:59 <cutsea110> Oh sorry!
01:46:02 <typoclass> osa1: hm ... so you have f (... -> Just ...) = ... ; f (... -> Nothing) = ... ? i can kinda see how it will think that's incomplete. could you move it into a case-of?
01:46:03 <osa1> dmwit: I mean suppressing only the warning for that code piece, not the whole module
01:46:16 <typoclass> cutsea110: don't worry :)
01:46:26 <dmwit> osa1: Unfortunately, I don't know of a way to do selective suppression. I often wish for it.
01:46:30 <Twey> cutsea110: Your prompt is >>= ?
01:46:38 <osa1> typoclass: moving it into a case-of solves
01:46:39 <Twey> That's dedication.
01:46:46 <dmwit> osa1: Perhaps you could code up some kind of pragma and benefit the whole community!
01:47:18 <chrisdone> dmwit: they get reset when the cache is reset, which is when the server is restarted, which once a day or when i make a change, like just now. i changed that bit to "Search logs for this nick" =)
01:47:22 <dmwit> cutsea110: Perhaps you should try ghc-pkg check.
01:47:24 <cutsea110> see http://hpaste.org/90447
01:47:54 <osa1> typoclass: http://hpaste.org/90448 here currently enabled definitions works without warnings, but second definition throws warnings
01:47:57 <dmwit> cutsea110: If you need help reading the output of ghc-pkg, you could send us another hpaste. =)
01:48:17 <typoclass> osa1: ah, another thought: what happens with "f (... -> _) =" ? maybe it's clever enough to understand that _ will match everything
01:48:20 <dmwit> chrisdone: oh, thanks for the change =)
01:48:37 <osa1> typoclass: and what do I write for body part of that pattern? undefined ?
01:48:38 <typoclass> osa1: (in this case, you could use the line "f (... -> _)" as the "suppress pragma"
01:48:49 <typoclass> osa1: i guess so!
01:49:04 <osa1> I think I prefer a warning :-P
01:49:05 <cutsea110> I'd checked it, but only warnings around haddocs
01:49:19 <cutsea110> http://hpaste.org/90449
01:49:29 <KingofFerrets> Do there exist any tutorials or anything with examples of using System.Console.GetOpt that actually show what it looks like to call it from the command line? :/
01:49:44 <dmwit> osa1: I think a feature request would not be out of line.
01:50:47 <dmwit> KingofFerrets: GetOpt is the GNU library, so calls look like GNU-standard stuff: --foo for long arguments, -f for short ones.
01:51:15 <dmwit> cutsea110: Very strange! Perhaps you could turn the verbosity of ghci up a bit.
01:51:37 <cutsea110> Yes my shell prompt is >>= > Tway
01:51:50 <cutsea110> sorry Twey
01:53:53 <cutsea110> turn the verbosity of ghci what?
01:55:17 <dmwit> -v3
01:56:03 <typoclass> cutsea110: try starting ghci as "ghci -v3"
01:57:17 <cutsea110> ok
01:57:18 <KingofFerrets> Aha.
01:57:21 <dmwit> KingofFerrets: If you're still having trouble, I guess you could look at the "yeganesh" package. I can give you a couple sample command-line calls.
01:57:54 <KingofFerrets> I didn't know the -- part, was the problem.
01:58:38 <KingofFerrets> Other thing that matters: if an option takes an argument, is the syntax approximately "-o arg"?
01:58:58 <dmwit> That should work, yes.
01:59:13 <KingofFerrets> Mmkay. Think I can work it out from there, then... Thanks!
01:59:23 <dmwit> So should --option arg and --option=arg. Not sure about -o=arg, but probably.
02:00:23 <dmwit> Short options can be collapsed; e.g. -abcd foo is short for -a -b -c -d foo
02:01:49 <cutsea110> http://hpaste.org/90450
02:02:16 <cutsea110> http://hpaste.org/90450
02:02:36 <cutsea110> http://hpaste.org/90450
02:02:48 <dmwit> Well... no regex packages failed. Unfortunately, no regex packages succeeded, either. =P
02:03:35 <dmwit> But there is some serious damage showing here.
02:03:44 <dmwit> Are you sure you were showing us the whole output of ghc-pkg check?
02:04:03 <cutsea110> yes, That was all.
02:04:51 <dmwit> Oh, I misread. This is like five copies of the same thing, so there aren't 15 built-in packages missing, just 3.
02:04:54 <cutsea110> http://hpaste.org/90449 this output is all of
02:07:08 <cutsea110> Some serious damage ?
02:07:40 <cutsea110> you mean that not found dph-seq/par?
02:09:57 <dmwit> I read too quickly.
02:10:10 <dmwit> Suffice it to say, I have no idea what's wrong.
02:10:37 <dmwit> ...but that run of ghci didn't even attempt to load any regex packages, so adding -v3 didn't really help.
02:11:00 <dmwit> Or rather, -v3 was good, but the run didn't help because you didn't end up getting diagnostics about the attempt to load your regex package. =P
02:12:06 <osa1> so I derived fold(catamorphism) and unfold(anamorphism) for Fix'ed data types. now can I define foldl/foldr for Fix ListF where `data ListF a l = NilF | ConsF a l` using only fold? or do I need to use unfold too?
02:13:56 <dmwit> Yes, foldr = fold.
02:14:47 <dmwit> foldl is trickier but also doable with only fold.
02:15:09 <osa1> I still can't see how is fold = foldr
02:15:20 <cutsea110> http://hpaste.org/90451
02:15:27 <cutsea110> I shamed...
02:15:33 <dmwit> osa1: What's the type of fold?
02:15:42 <dmwit> osa1: Specialize that type to ListF.
02:15:45 <dmwit> osa1: Then think hard.
02:16:34 <dmwit> cutsea110: Is regex-pcre-builtin a binding to a C library?
02:16:39 <dmwit> If so, do you have that library installed?
02:17:15 <cutsea110> I don't know, I didn't install directly.
02:17:46 <cutsea110> This is installed by pandoc.
02:18:13 <dmwit> osa1: As a hint, (Either a b -> c) is a lot like (a -> c, b -> c); do you see why?
02:18:53 <cutsea110> http://hpaste.org/90452
02:19:23 <cutsea110> pandoc is depend on highlighting-kate, kate is depend on regex-pcre-builtin.
02:19:46 <cutsea110> So, I dont know this package is what and why?
02:19:58 <cutsea110> :-(
02:20:33 <osa1> dmwit: yes, because we can get (Either a b -> c) from ((a -> c, b -> c) -> c) and the other way around?
02:21:10 <dobblego> osa1: this might help http://blog.tmorris.net/posts/list-folds-bfpg/
02:21:39 <dmwit> osa1: Whoa, where'd the extra (-> c) at the end there come from?
02:21:50 <osa1> dobblego: well I don't want to spoil the fun :-)
02:22:04 <dmwit> cutsea110: I'm not sure what to suggest other than looking at the code yourself or writing to the maintainer of regex-pcre-builtin.
02:23:02 <osa1> dmwit: well (Either a b -> c) is a function, so I put it to make similar functions
02:23:03 <dmwit> cutsea110: You could try installing an older version of the library.
02:23:04 <dobblego> if a coproduct of free monads is a free monad, where is the code that witnesses this?
02:23:15 <dmwit> It does look a bit odd that the most recent release is by somebody different than any of the previous ones.
02:23:27 <dmwit> osa1: Well, unput it!
02:23:42 <dmwit> osa1: (Either a b -> c) is a function, (a -> c, b -> c) isn't. Deal with it.
02:23:48 <osa1> dmwit: ok
02:24:03 <osa1> dmwit: so how are they similar?
02:24:08 <dmwit> Alternately: try to write the functions that translate back and forth between the two types you suggested and see where you get stuck. =)
02:24:45 <alpounet> osa1, if you write a function Either a b -> c, you'll most likely write a case for "Left smth", and another for "Right smthElse"
02:24:47 <dmwit> osa1: Well, that would be telling... =)
02:24:53 <alpounet> smith being of type a, smthElse of type b
02:24:58 <dmwit> osa1: But again, try writing the conversions and see if you can do it.
02:25:08 <osa1> I'm trying
02:25:11 <alpounet> either way, you must return a 'c'
02:25:25 <alpounet> isn't that somehow similar to (a -> c, b -> c) ? :-)
02:26:35 <dobblego> "a coproduct of free monads is a free monad" — more to the point, what exactly does this mean?
02:27:42 <dmwit> dobblego: I don't know. Also, where do you see it? Also, I'm not claiming it's so in this case, but there doesn't necessarily have to exist code that witnesses it.
02:27:55 <cutsea110> ok, i'll try it. thanks.
02:27:59 <dmwit> e.g. maybe the correspondence is non-parametric or has some other funny business
02:28:44 <dobblego> dmwit: I first felt it in my bones, that coproducts somehow give us a free monad, so I googled it and saw a couple of supporting statements (but they were as handwavy as my bones), then I tried to write the code, but my bones are not coming up with anything — it may just be nonsense
02:29:14 <dmwit> Well, you'll have to say which category you want to take your coproduct in first. =P
02:29:35 <dobblego> I was thinking Coproduct f g a = Either (f a) (g a)
02:29:41 <dmwit> sure
02:30:07 <dobblego> http://www.alpheccar.org/content/86.html "a coproduct of free monads is a free monad"
02:30:28 <osa1> dmwit: http://hpaste.org/90453 now how does that help :-)
02:32:27 <dmwit> osa1: Looks good to me. Now, what's the type of fold?
02:32:36 <osa1> fold :: Functor f => (f a -> a) -> Fix f -> a
02:32:43 <dmwit> Okay. Let's specialize f.
02:32:45 <dmwit> So?
02:33:23 <osa1> (ListF a -> a) -> Fix (ListF a l) -> a
02:33:32 <osa1> (ListF a -> a) -> Fix (ListF a) -> a
02:33:37 <dmwit> Doesn't look quite right yet.
02:33:53 <osa1> (ListF a1 a -> a) -> Fix (ListF a1) -> a
02:33:58 <dmwit> better =)
02:34:18 <dmwit> Okay, now let's use my hint.
02:34:40 <dmwit> That (ListF a1 a -> a) argument looks a bit like an (Either *mumble* *mumble* -> a) argument if you squint, right?
02:34:45 <dmwit> Since ListF has two constructors.
02:35:06 <osa1> yea
02:35:44 <dmwit> Okay, so let's try to fill in the mumbly bits...
02:37:07 <dmwit> (By the way, the goal of this argument is to get a type that "looks like" foldr's type, as a sanity check that fold and foldr might be implemented similarly.)
02:37:37 <shachaf> I,I foldr :: (Maybe (a,b) -> b) -> [a] -> b
02:38:12 <dmwit> shachaf: We're getting there. =)
02:38:14 <osa1> shachaf: where is the initial accumulator?
02:39:03 <shachaf> osa1: I bet you can find it.
02:39:16 <shachaf> dmwit: Oh, did I just spoil something?
02:39:16 <dmwit> osa1: Let's finish with ListF.
02:39:16 <dmwit> osa1: Since, after all, Maybe (a, b) and ListF a b look a lot alike.
02:39:34 <dmwit> shachaf: I think you confused things, but nothing is spoiled yet. =)
02:40:22 <shachaf> :t unfoldr -- it's just unfoldr backwards!
02:40:22 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
02:40:26 <dmwit> osa1: So, are you going to take a stab at the mumbly bits, or should I try to come up with some more hints?
02:41:15 <osa1> dmwit: I'm confused :-)
02:41:20 <dmwit> osa1:
02:41:27 <dmwit> Okay, let's review why we're here.
02:42:00 <dmwit> We started with fold :: Functor f => (f a -> a) -> Fix f -> a.
02:42:11 <dmwit> We'd like to check that this type look's like foldr's type, namely:
02:42:13 <dmwit> :t foldr
02:42:13 <lambdabot> (a -> b -> b) -> b -> [a] -> b
02:42:53 <dmwit> The first step in doing that is specializing to lists, so we'll use "f = ListF a" and "a = b":
02:43:23 <dmwit> fold :: (ListF a b -> b) -> Fix (ListF a) -> b.
02:43:51 <dmwit> If you squint, the end looks like [a] -> b already.
02:44:02 <osa1> except the first parameter
02:44:11 <dmwit> Right, so we need to fix up that first parameter.
02:44:25 <dmwit> We need to explode it into two parameters.
02:44:41 <dmwit> But we already know a way to turn a single function which takes a sum into two functions.
02:44:53 <dmwit> Namely, we can turn (Either a b -> c) into (a -> c) and (b -> c), and vice versa.
02:45:09 <dmwit> Well, ListF is a sum type very like Either.
02:45:12 <dmwit> Compare:
02:45:18 <dmwit> data Either a b = Left a | Right b
02:45:23 <osa1> ooh
02:45:27 <dmwit> data ListF a b = Nil | Cons a b
02:46:05 <osa1> how can we handle that `b` in Cons constructor?
02:46:19 <dmwit> Well, let's make it data ListF a b = Nil | Cons (a, b)
02:46:25 <dmwit> Does that make it easier to handle?
02:46:50 <osa1> yes
02:47:03 <osa1> it makes it same as Right b case, except b is (a, b)
02:47:10 <dmwit> right
02:47:22 <dmwit> Perhaps I made it a bit confusing by using the same type variables for both things.
02:47:30 <dmwit> Anyway, what about the Left/Nil case?
02:47:33 <dmwit> How can we handle that?
02:47:59 <osa1> () -> ListF?
02:48:15 <dmwit> Yeah, Nil is a bit like Left, except a is ()
02:48:41 <dmwit> so ListF a b is a bit like Either {- ??? -} {- ??? -} ...?
02:49:08 * hackagebot snaplet-mongodb-minimalistic 0.0.6.10 - Minimalistic MongoDB Snaplet.  http://hackage.haskell.org/package/snaplet-mongodb-minimalistic-0.0.6.10 (PetrPilar)
02:49:12 <osa1> Either (() -> Fix (ListF a), a -> Fix (ListF a))
02:49:17 <osa1> maybe?
02:49:20 <erisco> if you have two types each with one type var, A and B, how can you parameterize A with B and B with A? is this not possible?
02:49:26 <dmwit> youch!
02:49:30 <dmwit> That looks too complicated to me.
02:49:43 <dmwit> We shouldn't need any Fix yet.
02:49:52 <osa1> then Either (() -> ListF a b, a -> ListF a b)
02:49:52 <dmwit> (After all, ListF doesn't mention Fix anywhere!)
02:49:55 <shachaf> It also has kind * -> *
02:50:10 <dobblego> erisco: like this? newtype ComposeAB a = (ComposeAB (A (B a)))
02:50:43 <erisco> dobblego, but then you have to give a type argument to ComposeAB, right?
02:50:58 <dobblego> erisco: of course, how can it make sense otherwise?
02:50:58 <dmwit> osa1: Well, try writing conversion functions between that type and ListF a b, then. =)
02:51:05 <osa1> ok
02:51:15 <erisco> dobblego, I don't know
02:51:21 <alpounet> erisco, it's possible if A and B's parameters have kind * -> *
02:51:53 <dmwit> erisco: newtype ComposeAB = ComposeAB (A (B ComposeAB))
02:52:34 <erisco> I'm trying to figure out how to do this. If A and B represent two grammar rules of a language (so if the grammar rule is A -> a B | c   then  data A b = A0 b | A1
02:53:12 <erisco> so if the two grammar rules reference each other, you'd have to somehow dodge an infinite type
02:53:38 <dmwit> erisco: newtype or data are the way you dodge it
02:53:45 <dmwit> Break each cycle with a constructor
02:53:48 <erisco> in a language with pointers or references it doesn't seem that difficult
02:53:50 <dmwit> (In the way I showed.)
02:54:02 <dmwit> Alternately: make all of the stuff be in one data type.
02:54:50 <dmwit> data A = A0 B | A1; data B = {- whatever, lol -}
02:54:52 <osa1> dmwit: hmm. what should I pass to f in (Right f) when converting from Either to tuple?
02:55:27 <dmwit> osa1: Why are you converting from Either to a tuple?
02:55:30 <erisco> interesting. I don't understand really but I'll trying it out and see
02:56:20 <osa1> dmwit: because I messed up the concepts .. give me a sec
02:57:03 <erisco> oh I kinda see what is happening now... self-referential types are permitted so we're really just encoding the cycle A, B into a self-referential type
02:57:07 <osa1> dmwit: ok so I still need to pass a `a` when converting from Either to List
02:57:45 <osa1> I'm trying to write these two, right: listFToEither :: ListF a b -> Either (() -> ListF a b) (a -> ListF a b) and eitherToListF :: Either (() -> ListF a b) (a -> ListF a b) -> ListF a b
02:57:46 <dmwit> erisco: But really it's an XY problem. You shouldn't let A and B have type parameters to begin with.
02:58:18 <erisco> dmwit, how am I to avoid that? use one type?
02:58:19 <dmwit> osa1: That sounds like the task to attempt if you believe that ListF a b is isomorphic to Either (() -> ListF a b) (a -> ListF a b).
02:58:37 <erisco> I just figured one type per rule would be a natural translation but perhaps it isn't of much benefit
02:58:41 <dmwit> erisco: Did you not like my suggestion? "data A = A0 B | A1; data B = {- whatever, lol -}"
02:59:15 <dmwit> You didn't give a grammar rule for B, so filling in {- whatever, lol -} is left to you.
02:59:34 <erisco> oh...
02:59:48 <erisco> maybe if it wasn't 6am I wouldn't have tried to overthink that
03:00:22 <erisco> thanks dmwit
03:00:32 <erisco> dmwit, btw, with that parser, I suspect that it didn't parse the entire input
03:00:57 <dmwit> What's that parser?
03:01:09 <erisco> dmwit, you had that Parsec parser for S -> aSa | aa
03:01:33 <dmwit> oh yeah
03:01:39 <dmwit> Okay, well, that's easy to test.
03:02:12 <dmwit> What was the parser? s = try (char 'a' >> s >> char 'a') <|> (char 'a' >> char 'a') -- ?
03:02:31 <erisco> can Haskell even come up with a type for that?
03:02:38 <erisco> seems right in principle though
03:04:09 <dmwit> guess you're right
03:04:19 <dmwit> Now that's quite interesting. What's going on there?
03:04:22 <erisco> it gets 4/6 a's right?
03:04:54 <erisco> well, so that was my example for the problem recursive descent has with backtracking
03:05:10 <osa1> dmwit: ok so Either (() -> ListF a b, a -> ListF a b) is not isomorphic with ListF a b, so what should I convert ListF ?
03:05:47 <dmwit> osa1: Okay. =)
03:05:52 <dmwit> osa1: Well, try again.
03:06:04 <dmwit> osa1: We lined up Nil with Left (), right?
03:06:05 <erisco> basically, imagine you are some rule in the parser, and you have to invoke another rule as part of your operation
03:06:11 <osa1> right
03:06:13 <dmwit> osa1: And we lined up Cons (a, b) with Right (a, b)?
03:06:25 <osa1> ok
03:06:31 <dmwit> osa1: So, what type is the one that both Left () and Right (a,b) fit into...?
03:06:44 <osa1> Either () (a, b)
03:06:47 <dmwit> uh huh
03:06:53 <erisco> we'll say you're the parent, and the guy you're invoking is the child. this child has at least two options he can try for a valid parse (with me?)
03:07:04 <dmwit> erisco: sure
03:07:21 <erisco> so the child tries his first option, and greedily takes all the characters he needs, and the parse passes
03:08:20 <osa1> dmwit: ok it's time for me to leave. many thanks for your help. I'll go on deriving fold later.
03:08:24 <erisco> so he tells the parent that "hey, my parse is fine", and the parent continues. the parent discovers that it can't complete its parse, though (and in the scenario we just saw, the child ate the 'a' character the parent needed to match the trailing 'a' in aSa)
03:08:31 <osa1> maybe I can derive rest of it by myself
03:08:43 <dmwit> osa1: g'luck
03:08:54 <dmwit> osa1: many smart people on here who can help in case I'm not around =)
03:08:55 <erisco> so the parent has to fail. meanwhile, the child never gets the chance to try its second option
03:10:14 <erisco> so specifically this arises when you have a recursive rule with a tail (like the trailing 'a' in aSa), and the child has the potential to greedily consume the trailing 'a'
03:10:27 <klrr> morning haskellers
03:10:48 <prophile> o/
03:11:08 <alpounet> wow, we're almost constantly over 1000 users (and bots) here
03:11:43 <erisco> dmwit, so when I said "perfect backtracking", I meant guarantee that all possible parse trees are tried
03:11:50 <dmwit> erisco: Okay, that description actually tells how to fix it. =)
03:12:03 <erisco> dmwit, cool. how are you fixing it?
03:12:16 <prophile> am I right in saying that if a call/cc primitive (:: ((a -> b) -> a) -> a) existed, the curry-howard isomorphism would extend to full propositional logic rather than just intuitionistic logic?
03:12:17 <dmwit> s = try (char 'a' >> s >> char 'a' >> eof) <|> (char 'a' >> char 'a' >> return ())
03:12:42 <dmwit> err
03:12:52 <dmwit> Sorry, I fail.
03:12:55 <dobblego> dmwit: I think my bones were lying
03:12:57 <erisco> its okay :)
03:13:40 <erisco> I'm interested in learning a bit about parsing, so I was going to write some kind of parser anyways... I've devised an improved parser which is much the same but shouldn't suffer the same problem
03:14:56 <erisco> dmwit, the problem is fairly simple, but since I am weak at Haskell it is taking a lot of thought and time :P
03:16:45 <dmwit> erisco: You might look into ReadP.
03:17:14 <dmwit> let s = (string "a" >> s >> string "a") <|> string "aa" in readP_to_S s "aaaaaa"
03:17:17 <dmwit> [("aa","aaaa"),("a","aa"),("a","")]
03:17:33 <dmwit> The last tuple there is indicating that it's consumed all of the input.
03:18:01 <erisco> dmwit, for parsers which can accept many strings (they have more than one grammar rule, or a EBNF-style + or * is used, or similar), then what is often done (based on my reading), is to accept the longest match
03:18:48 <dmwit> (The tuples are (result of successful parse, remaining unparsed text) each.)
03:19:11 <erisco> I figure, instead of longest match, if you know what has to come after your parser, then you can change the string you're accepting until the next parser matches too
03:19:34 <erisco> this means you necessarily exhaust all possible options before giving up
03:19:48 <Peaker> about 70 users needed to bypass #python and probably be the largest language channel?
03:20:00 <dmwit> erisco: Sounds like http://en.wikipedia.org/wiki/Earley_parsing
03:20:24 <erisco> maybe, I haven't read that article through
03:21:19 <erisco> I wasn't going to publish a paper or anything. I doubt its new
03:21:29 <dmwit> (The idea of Earley parsing, I gather, is that it computes all parses of all substrings, but still in a reasonable asymptotic time.)
03:21:59 <dmwit> (...and ReadP computes all parses of all prefixes, but doesn't care at all about asymptotic time. =)
03:22:10 <erisco> well, I am not too interested in performance for this case. I am just interested in taking the RDP and improving it a bit
03:22:46 <dmwit> Okay, this seems as good a place as any to head to bed.
03:22:49 <dmwit> Good luck!
03:22:55 <erisco> thanks. nighty night
03:23:09 <erisco> no one uses RDP for performance :P
03:27:18 <erisco> hrm... if you define an infix operator (I've simplified for sake of question):   (/>) :: a -> b -> (a, b)    then   a \> b \> c    will be   ((a, b), c)  or (a, (b, c))   (I don't know which way associativity goes)
03:27:33 <erisco> is there a way instead to get (a, b, c) without extra work on the user of the infix operator?
03:27:35 <Twey> erisco: Depends how you define it
03:27:58 <Twey> I don't think so, sadly
03:28:01 <tdammers> heh, just solved a debugging problem by adding -Wall -Werror to my ghc flags :x
03:28:07 <Twey> Because of the fact that tuples are defined magically instead of recursively
03:29:00 <erisco> I can imagine in a language with argument overloading being able to do this by specializing on the tuple and unpacking it
03:29:22 <erisco> and in Haskell the analog to this (approx) is classes?
03:29:39 <tdammers> I did something like this: foo <- getFoo; let foo = modifyFoo foo; setFoo foo
03:29:41 <Twey> erisco: That's not the same thing; what do you do if you want b to be a tuple?
03:29:53 <erisco> it means that the definition of /> necessarily changes based on the argument types, and I don't know if Haskell ever does this
03:30:53 <merijn> erisco: Default associativity is infixl 9
03:30:58 <Twey> erisco: You can do it, but you'd have to create an instance for every type of tuple, I think
03:31:19 <erisco> Twey, you're saying that that case is not distinguishable. okay, then you might use a data type rather than a tuple
03:31:48 <erisco> Twey, well, if it looks magical to the caller, I don't have much issue with having a few defintions
03:32:00 <erisco> it is about playful prettiness :)
03:32:33 <merijn> erisco: You can define a heterogeneous lists to have arbitrary size tuples (you'd get linear lookup, rather than constant for tuples, though)
03:33:35 <supki> merijn: hey, I think that's not how indenting should behave:  http://hpaste.org/90419 =)
03:33:43 <erisco> ultimately I want to plug the three items as function arguments
03:33:55 <merijn> erisco: Oh, good news!
03:33:56 <erisco> and it just seems a bit too ugly to unpack them
03:34:05 <merijn> erisco: I implemented something like that already
03:34:34 <merijn> erisco: I have a statically typed list which I apply (type safely!) to a function of arbitrary (but statically known) number of arguments
03:34:46 <merijn> I use it to interact with FFI imports
03:34:59 <merijn> supki: Yeah, see the todo :p
03:35:16 <merijn> supki: syntax in multiline comments is broken and really hard to fix, I'm still looking into it
03:35:34 <Twey> erisco: You might be interested in this: http://okmij.org/ftp/Haskell/vararg-fn.lhs
03:35:37 <erisco> okay bear with me... statically typed list as opposed to what? aren't all lists in Haskell statically typed?
03:35:46 <merijn> erisco: Heterogeneous list
03:35:56 <merijn> erisco: i.e. not all arguments are the same type
03:36:26 <merijn> erisco: And I match those different types to the function arguments to make sure I get a type error when I try to apply a function to a list of the wrong arguments
03:36:31 <Twey> Hey, the HList article has vanished
03:36:41 <erisco> a bit confusing why compilers don't magic this problem away
03:37:35 <merijn> erisco: I.e. my code can have a list with elements of type a, b and c in it and apply a function "a -> b -> c -> d" to that list and have the compiler check that the number of arguments in the list and function match
03:38:23 <erisco> okay sorry, still at the start here. what kind of haskell function has a variable number of arguments?
03:38:23 <merijn> oh
03:38:43 <merijn> I'm not working with variable numbers of arguments
03:39:00 <erisco> sorry, you said "arbitrary"
03:39:07 <erisco> not sure what your distinction is
03:39:27 <supki> merijn: is it hard because indent is line based?
03:39:43 <merijn> I am foreign importing functions, each foreign import has different argument numbers, but of course every *specific* imported function has a fixed number of arguments
03:39:55 <merijn> supki: Yes, also I effectively need to parse haskell to detect comments
03:40:44 <erisco> merijn, I think with a few more months of Haskell-fu I could come back and understand what you're doing, but right now I think my understanding of it is a lost cause ;)
03:40:48 <merijn> erisco: I'm saying that I have a function "apply :: HeterogeneousList -> ImportedFunction -> Result" which works regardless of the list length and number of function arguments in the imported function. But still checks at compile time that they match
03:41:32 <merijn> erisco: i.e. applying a list of the wrong number of arguments to an imported function is a type error. But if the list and function match, then it is applied, regardless of the number of function arguments
03:42:27 <erisco> I understand "convoluted workaround solution that involves some dynamic aspects but still manages to guarantee type safety"
03:42:45 <erisco> but otherwise I don't know enough about all of Haskell's systems. I know nothing about its module system, for instance
03:43:18 <erisco> unless "imported function" means something different than in the context of modules
03:43:40 <merijn> erisco: It's not very convoluted, tbh. It just means writing a few lines (few == about 7 relatively simple lines) to tell the compiler that what you want actually makes static sense
03:44:09 <erisco> I didn't say *very* convoluted, I just said convoluted ;)
03:45:24 <merijn> erisco: The basic issue I had is that I was writing an EDSL that's calling C functions, but for all practical purposes they could just as well be haskell functions. The problem I was having was that they all had the type "?? -> IO ()" but the arguments were different "a -> b -> IO ()", "c -> a -> c -> b -> IO ()", etc.
03:46:25 <merijn> I wanted to make sure that, you didn't have to write obnoxious code to apply the functions to their arguments, as the arguments you were giving were statically typed in the DSL
03:47:08 <merijn> So I had a "list" containing elements of types 'a' and 'b' and wanted to apply that to "a -> b -> IO ()", obviously the compiler should be able to see that those two match at compile time
03:48:02 <erisco> well I can follow you on that, but I presume it wasn't actually a list then
03:48:29 <erisco> and you said it wasn't a heterogenous list
03:48:33 <merijn> erisco: Basically it was a list with the type of each element encoded in the type
03:49:09 * erisco *whoosh*
03:49:43 <merijn> if the normal list is "data List a = Nil | Cons a (List a)" a similar thing (this is not entirely valid code) would be "data HList a b = Nil | Cons a (List b)"
03:50:42 <erisco> not valid why?
03:50:50 <erisco> (other than possible name conflicts)
03:51:03 <merijn> Actually, that's valid but you can only have 1 a element followed by a List of b's there
03:52:36 <shachaf> I,I data HList :: [*] -> * where { Nil :: HList '[]; Cons :: a -> HList as -> HList (a ': as) }
03:52:37 <erisco> well, for someone who is still new, is  (fst r) (fst . snd r) (snd . snd r)  the best I can do to unpack the tuple 'r'?
03:52:46 <merijn> In reality (with GADTs) you can write "data HList :: [*] -> * where" which says HList is a type constructor that takes a *list* of types and returns a type. With "Nil :: HList '[]" (Nil is a constructor with an empty list of types) and "Cons :: a -> HList list -> HList (a ': list)"
03:53:00 <elliott> erisco: you should not have a tuple like that.
03:53:06 <elliott> make a data type, or at least use a triple
03:53:16 <merijn> erisco: Well, you have lens, which is nicer, but more complicated and rather you shouldn't have a tuple like that
03:53:30 <erisco> elliott, it is coming from an infix operator  a -> b -> (a, b)
03:53:43 <elliott> I suggest not using that operator then
03:53:53 <erisco> but... :(
03:54:08 <Lethalman> erisco, what about pattern matching?
03:54:25 <merijn> erisco: Really, it seems like you would want a heterogeneous list, but that might be a bit complicated for you right know
03:54:30 <erisco> ah see I could make a lambda to pattern match it yeah?
03:54:45 <mauke> why not just pattern match?
03:54:45 <Lethalman> erisco, let ((_,((_, .........))) = yourtuple
03:54:55 <mauke> case/of
03:55:13 <erisco> you can just do it that way Lethalman? didn't know that was valid
03:55:27 <erisco> have only seen pattern matching on function arguments
03:55:32 <Lethalman> > let ((_,(a,_))) = ((2,(3,4))) in a
03:55:35 <lambdabot>   3
03:55:44 <erisco> I wasn't doubting you
03:55:55 <Lethalman> erisco, I was doubting myself :P I'm newbie
03:56:11 <erisco> oh, welcome aboard
03:56:19 <mauke> pattern matching in function arguments is just syntactic sugar for case
03:56:35 <mauke> > case (2, (3, 4)) of (_, (a, _)) -> a
03:56:36 <lambdabot>   3
03:56:54 <shachaf> Hmm, let !Refl = x in ... doesn't work.
03:56:57 <erisco> okay interesting
03:57:01 <shachaf> I wonder whether it should.
03:57:05 <mauke> > case (a, (b, c)) of (_, (a, _)) -> a
03:57:06 <lambdabot>   b
03:57:21 <mauke> this is your confuser for today
03:57:48 <erisco> what do you mean?
03:57:58 <shachaf> mauke: Did you figure out whether you can do QuasiQuotes, speaking of confusers?
03:58:27 <erisco> I am not sure why plain 'ol letters is valid
03:58:31 <hpc> > let (a, b, c, d, e, f) = (3, c, a, b, f, e, d) in (a, b, c, d, e, f)
03:58:33 <lambdabot>   Couldn't match expected type `(t2, t3, t1, t6, t5, t4)'
03:58:33 <lambdabot>              with a...
03:58:39 <hpc> :(
03:58:40 <osfameron> :t a
03:58:41 <lambdabot> Expr
03:58:55 <erisco> is that mauke's a?
03:59:03 <mauke> shachaf: didn't find any predefined quasiquoters
03:59:14 <mauke> erisco: it's lambdabot's
03:59:29 <shachaf> mauke: Oh, stage restrictions?
03:59:29 <mauke> or rather, it imports a module that defines all single-letter identifiers
03:59:33 <shachaf> I guess that's a problem.
03:59:35 <mauke> shachaf: yeah
03:59:40 <mauke> apart from that it's easy
03:59:45 <erisco> mauke, ah, well, that was the confusing part I think :P
03:59:50 <shachaf> How do you make it work apart from that?
03:59:53 <Lethalman> :t f a
03:59:54 <lambdabot> FromExpr (Expr -> t) => t
04:00:04 <mauke> <mauke> shachaf: QuasiQuotes are detectable (null [qqx| qqx <- "|]--"]) but you need a separate module for qqx due to staging restrictions
04:00:11 <osfameron> seller agrees a price reduction of 10,000.
04:00:11 <osfameron> >
04:00:11 <osfameron> >
04:00:14 <osfameron> bah
04:00:15 <osfameron> sorry
04:00:27 <shachaf> mauke: Oh, I missed that message. Never mind then.
04:00:27 * osfameron grumbles at linux middle-click pasting
04:00:59 <erisco> just as many lines in apology as accidentally posted ;)
04:10:16 <merijn> singletons would let me get a value level representation of a type level "value", right?
04:14:06 <hpc> merijn: how do you mean?
04:14:31 <typoclass> merijn: is a singleton some sort of TypeLit whatnot?
04:20:10 <merijn> hpc: I want to reify a DataKinds style type. It seems the singletons does that, at least for Nat, I'm wondering if that extends to types other than Nat
04:21:13 <hpc> well, suppose you had a type like
04:21:24 <hpc> data Tree = Leaf | Node Tree Tree
04:21:39 <hpc> to find the depth of a data-kinded tree value, you could do something like
04:21:54 <hpc> class TreeDepth (t :: Tree) where treeDepth :: Int
04:22:03 <hpc> instance TreeDepth Leaf where treeDepth = 0
04:22:46 <hpc> instance TreeDepth (Node a b) where treeDepth = max treeDepth treeDepth -- with some kind of trick to disambiguate a/b
04:23:08 <hpc> er, and plus 1 in there somewhere
04:23:37 <mikeplus64> hpc: you'd need treeDepth :: f (t :: Tree) -> Int
04:24:49 <mikeplus64> then you can write treeDepth (_ :: f (Tree a b)) = max (treeDepth (undefined :: g a)) (treeDepth (undefined :: h b))
04:25:51 <dEPy> guys, I'm thinking of porting some of my porting my java project to haskell, any idea on how to start?:)  and btw, it's  physics, 3d graphics and some AI mixture.
04:27:00 <mikeplus64> @hoogle OpenGLRaw
04:27:00 <lambdabot> package OpenGLRaw
04:27:00 <lambdabot> package OpenGLRaw21
04:27:00 <lambdabot> package Vec-OpenGLRaw
04:27:01 <typoclass> http://stackoverflow.com/questions/9198112/haskell-unnecessary-binary-growth-with-module-imports/9198223#9198223
04:27:08 <mikeplus64> err
04:27:10 <mikeplus64> @hackage OpenGLRaw
04:27:11 <lambdabot> http://hackage.haskell.org/package/OpenGLRaw
04:27:12 <mikeplus64> @hackage hmatrix
04:27:12 <lambdabot> http://hackage.haskell.org/package/hmatrix
04:27:35 <alpounet> dEPy, for what it's worth, there's a #haskell-game channel
04:27:37 <mikeplus64> dEPy: those two will probably be of use, hmatrix might be to your taste though
04:27:47 <typoclass> according to this ^^, the ghc manual is saying about the -split-objs switch: "warning: don't use it unless you know what you're doing!" why is that? what's dangerous about it?
04:29:29 <dEPy> tnx guys
04:29:52 <mikeplus64> i mean hmatrix might not be to your taste*
04:31:07 <typoclass> dEPy: on how to start, you probably first need a basic grasp of haskell :-) have you read lyah?
04:31:09 <typoclass> @where lyah
04:31:10 <lambdabot> http://www.learnyouahaskell.com/
04:31:24 <dEPy> hmatrix is for graphix?
04:31:38 <mikeplus64> not really, no, but it can be used for it
04:31:59 <dEPy> I was hopeing there's some engine already built? :)
04:32:29 <typoclass> dEPy: in general, expect that a well-structured haskell program will look somewhat different from a well-structured java program. so don't plan to port the object-oriented design 1:1. that wouldn't produce a haskell program that's as good as it can be
04:32:45 <mikeplus64> dEPy: http://hackage.haskell.org/package/lambdacube-engine
04:33:04 <dEPy> typoclass: I didn't expect that. I hope I learn to do it haskell-way that's why I want to port it. :)
04:33:32 <dEPy> oh I see haskell has Bullet physics engine wrapper, that's cool because I'm using bullet right now in java
04:37:30 <dEPy> Ah well, I guess I'll start by building stuff which is independent of the libraries then if all goes well I'll then worry about libraries :)
04:38:14 <Aetherspawn> holy crap. Lambdacube is huuuuuge
04:38:25 <mikeplus64> Aetherspawn: yeah. it has some *hairy* code too
05:09:12 * hackagebot tkyprof 0.2.0 - A web-based visualizer for GHC Profiling Reports  http://hackage.haskell.org/package/tkyprof-0.2.0 (MitsutoshiAoe)
05:12:44 <trevor_>  /ignore * JOINS PARTS QUITS NICKS
05:15:15 <alpounet> neat
05:15:47 <trace30m> par p $ pseq q $ f p q
05:17:13 <trace30m> is f called last or as a argument called before
05:18:03 <trace30m> ok forget it
05:20:55 <KingofFerrets> ...Hm. It's probably a bad idea to write two files that import each other, isn't it.
05:21:59 <typoclass> KingofFerrets: if it's really necessary, it's possible via the hs-boot mechanism, but in general you should try to structure your code differently
05:22:24 <KingofFerrets> ...It's not, I'm an idiot. x.x
05:23:13 <KingofFerrets> Had a function that required file A and file B, had it in file A importing file B, then moved it to file B which made file B have to import file A, forgot that I didn't need file A to import file B anymore.
05:44:12 * hackagebot cmdargs 0.10.4 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.10.4 (NeilMitchell)
05:47:59 <t7> whats the largest haskell codebase, excluding ghc?
05:48:54 <Entroacceptor> it's probably not public
05:50:23 <Twey> Would darcs be the second-largest public codebase?
05:50:45 <tero-> what about pugs?
05:50:56 <companion_cube> what about lambdabot?
05:51:06 <Entroacceptor> xmonad+contrib?
05:51:14 <Entroacceptor> gitit?
05:51:46 <companion_cube> pandoc?
05:51:57 <KingofFerrets> What package should I be looking at for regexes if I want to use them to easily pull a bunch of numbers from a config file? Or is regexes not even the right thing to be using?
05:52:01 <jmcarthur_mobile> Probably Standard Chartered has it.
05:52:04 <Entroacceptor> or maybe that xournal clone?
05:52:24 <Entroacceptor> or yi?
05:52:32 <Entroacceptor> leksah?
05:52:41 <Entroacceptor> and how do you define size, anyway?
05:54:48 <elliott> companion_cube: lambdabot isn't that big I think
05:55:15 <elliott> 10k lines or so in total
05:56:24 <t7> someone do cloc in darcs src tree
05:59:17 <tero-> does darcs still suffer from exponential worst-case when merging?
06:01:10 <Entroacceptor> ugh, "darcs get"ting darcs itself takes ages
06:04:17 <Entroacceptor> cloc says darcs has 35373 lines of Haskell code
06:04:55 <Entroacceptor> 23 in Lisp, 164 XSD (what is that?) 10556 bourne shell and 770 C.
06:05:28 <CaptainK> anyone get haskell onto tinycore?
06:06:26 <tero-> pugs has 20173 lines of Haskell code
06:08:35 <Entroacceptor> what about snap with associated libs?
06:08:56 <Entroacceptor> it's bad that there's so much modularization :)
06:11:00 <Entroacceptor> pandoc only 18694, that's comparable to xmonads+contrib 16481+2379
06:12:17 <HugoDaniel> what does the lines of code metric tell ?
06:12:40 <flebron> how many lines your code has.
06:12:49 <HugoDaniel> besides the number of lines in a file (can it even discriminate between code and comments ?)
06:13:48 <Entroacceptor> it says it does, yes
06:13:57 <Entroacceptor> and we were talking about size of the code base
06:13:59 <supki> for my code it mostly tells how much code I could not outsource to ekmett's libraries
06:14:20 <HugoDaniel> :D
06:14:24 <HugoDaniel> ekmett's libs :D
06:14:31 <HugoDaniel> Prelude.Ekmett
06:14:37 <Entroacceptor> for example, xmonad has 1381 comments to 2379 LOC
06:14:40 <Entroacceptor> hrhr
06:14:55 <Entroacceptor> can I have that as a Template Haskell extension? =)
06:15:10 <Entroacceptor> $(deriveProgram)
06:15:46 <parcs> > logBase 2 1661606280
06:15:48 <lambdabot>   30.629931427922127
06:34:14 * hackagebot file-embed 0.0.4.9 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.4.9 (MichaelSnoyman)
06:38:17 <xplat> Agda is a pretty big codebase too ... cloc says 57735 lines of haskell and 13100 of comments ..
06:38:31 <Entroacceptor> ah, right
06:38:43 <xplat> so bigger than anything already measured here
06:40:07 <xplat> i wonder when pipes-bytestring is going to come out
06:40:34 <xplat> it looks like probably july or august will be the month to start porting all your libraries to use pipes
06:41:06 <andrea__> which editor/ ide do you use ?
06:41:31 <opqdonut> emacs
06:41:32 <xplat> i use vi, sometimes emacs
06:42:00 <andrea__> i use emacs, but perhaps i decide switch to leksah
06:42:14 <andrea__> does someone has experience with leksah ?
06:43:28 <xplat> my experience with leksah was brief.  i wasn't that impressed.  but maybe it takes longer to get used to it enough to appreciate the good parts.
06:43:31 <Entroacceptor> emacs, eclipse, vi
06:44:13 <xplat> i must remind myself that that was very much the case with vi :)
06:44:31 <luite> leksah is a bit understaffed, you should use and improve it :p
06:44:47 <andrea__> xplat, do you use an extension for vi ?
06:45:27 <xplat> andrea__: no, just plain vim
06:45:57 <andrea__> i tried vim, too
06:46:49 <xplat> i really underutilize the tools available for haskell, no doubt, i was always a 'use a good language' guy and so i never got used to having good tools
06:47:13 <xplat> (since it's so rare to have both)
06:48:40 <dolio> I used emacs for Haskell for a while, and never used any of the fancy stuff that people do with it.
06:48:46 <xplat> mainly i only use ghci and profiling out of everything that's available (and there's a lot available)
06:49:15 <xplat> well, and cabal obviously
06:49:15 <dolio> Now I use vim, and I have a thing installed that has several things (run compiler from vim, send hpaste from vim, ...) that I'll also never use.
06:49:45 <dolio> I just use coloring and indenting.
06:50:12 <mauke> oh, I wrote a thing that pastes from vim :-)
06:51:02 <andrea__> emacs makes indent wit tab key
06:51:09 <andrea__> +h
06:52:39 <flebron> Well this is nice. (arr ! 4, arr `unsafeAt` 4) == (3, 0), with arr a Data.Array.Unboxed Int Int.
06:52:48 <flebron> I guess it really isn't safe at all.
06:53:04 <dolio> You array bounds aren't 0-based, are they?
06:53:20 <dolio> Your, even.
06:53:40 <flebron> The array has 500 elements, so that shouldn't be a problem.
06:54:01 <mauke> ???
06:54:18 <dolio> unsafeAt indexed into the array as if it were 0-based.
06:54:44 <flebron> Ahhhh, OK. I thought you were suggesting an unbounded access issue.
06:54:55 <flebron> Yeah, that would be it, thanks :)
06:55:01 <dolio> So (`unsafeAt` 4) gets the fifth element, always.
06:55:08 <dolio> Fifth from the beginning.
06:55:26 <flebron> Yeah, forgot about that :)
07:00:45 <mapreduce> Hi.  I can't seem to get the if on the last uncommented line to compile, any ideas?  http://codepad.org/AkwtNTN1
07:02:59 <tero-> uh, "This package indirectly depends on multiple versions of the same package. This is highly likely to cause a compile failure."
07:04:01 <mauke> mapreduce: the 'if' is fine here but I get a type error
07:04:04 <tero-> wouldn't cabal just do The Right Thing if I ask nicely...
07:04:51 <mapreduce> mauke: Ah, so the syntax problem is likely just codepad?
07:06:17 <mr-> > if 1 > 0 then True else False
07:06:18 <lambdabot>   True
07:06:30 <mauke> mapreduce: yes
07:07:44 <mapreduce> Is there a better web-based tool?  Use case: programming on the train with an Android phone; connectivity fluctuating.
07:07:51 <merijn> mauke: It's a syntax error if he's using an old GHC
07:08:06 <mapreduce> merijn: Why?
07:08:17 <merijn> actually
07:08:22 <merijn> it's a syntax error anyway
07:09:00 <merijn> I suspect, it's hard to tell how the layout rules affect this case
07:09:07 <mauke> merijn: what
07:09:09 <tero-> regex-base-0.93.2 requires mtl-2.0.1.0, parsec-3.1.3 requires mtl-2.1.2, etc.
07:09:20 <mauke> merijn: I literally ran this thing with ghc and hugs
07:09:33 <elliott> mauke: hugs used a relaxed form of the if/then layout syntax iirc
07:09:35 <mauke> why do you think layout matters here?
07:09:37 <tero-> I assume cabal wants to use the latest package possible, so it's up to me to specify constraints for versions
07:09:38 <elliott> which the report and ghc only adopted recently
07:09:44 <elliott> oh hm
07:09:45 <mapreduce> merijn: I'm not talking about 'ifTest'
07:09:46 <mauke> if doesn't layout
07:09:46 <elliott> maybe that only mattered in do blocks
07:09:53 <merijn> elliott: There's no do block, I missed that
07:09:56 <merijn> I thought there was
07:10:05 <elliott> right, if there was then http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse would apply
07:10:08 <mauke> even if there was, it's all on one line
07:10:25 <mauke> > do if 1 > 2 then 3 else 4
07:10:26 <elliott> (and that *does* change the syntax of if)
07:10:29 <lambdabot>   mueval-core: Time limit exceeded
07:10:32 <elliott> > if 1 > 2 ; then 3 ; else 4
07:10:34 <mauke> o_O
07:10:36 <lambdabot>   mueval-core: Time limit exceeded
07:10:39 <mauke> > ()
07:10:40 <elliott> > if 1 > 2 ; then 3 ; else 4
07:10:43 <lambdabot>   mueval-core: Time limit exceeded
07:10:44 <lambdabot>   4
07:10:51 <mauke> > do if 1 > 2 then 3 else 4
07:10:54 <lambdabot>   mueval-core: Time limit exceeded
07:10:55 <flebron> Is there a reasonable way of using template Haskell to force evaluation of a constant at compile time?
07:11:03 <mauke> I give up
07:11:08 <merijn> I thought it wasn't compiling with the uncommented line
07:11:13 <merijn> eh, commented line
07:11:19 <merijn> The current line is just a type error, yes
07:11:33 <mapreduce> Thanks guys.. afk
07:29:22 <tomboy64> sorry, newbie question
07:29:33 <tomboy64> what am i doing wrong here? row x = [ z .. z+x ]
07:29:35 <tomboy64>         where z = sum(x-1) + 1
07:29:39 <elliott> nothing wrong with newbie questions :)
07:29:48 <elliott> tomboy64: sum takes a list, not a number
07:29:55 <elliott> what is the row function supposed to do?
07:31:00 <tomboy64> it's supposed to give me the row of a dataset of number added according to certain rules. but thank you, that was what i needed. i oversaw the list <-> number thing
07:31:22 <parcs> > logBase 2 1661545027
07:31:23 <lambdabot>   30.62987824382596
07:31:55 <mauke> hmm. german?
07:45:52 <tomboy64> i found this code in the haskell wiki, as a test for primality:
07:45:52 <tomboy64> isPrime n = n > 1 && foldr (\p r -> p*p > n || ((n `rem` p) /= 0 && r)) True primes
07:45:53 <tomboy64> primes = 2 : filter isPrime [3,5..]
07:46:27 <flebron> Is there a list comprehension syntax to loop [1..k] skipping multiples of 3?
07:46:40 <flebron> Err, not comprehension, but the enumeration syntax. I know I can filter by `mod` 3.
07:47:01 <tomboy64> when i call it repeatedly, will ghc evaluate the whole thing over and over again? or will it remember "earlier" primes?
07:47:20 <tomboy64> flebron: tried 0, 3 .. k?
07:47:29 <flebron> That will loop the multiples of 3.
07:47:59 <tomboy64> oh
07:48:40 <tomboy64> then i think filter is your friend
07:48:42 <bscarlet> flebron: I think the best you could do would be to filter with list comprehension syntax
07:49:09 <bscarlet> > [ i | i <- [1..], i `mod` 3 == 0 ]
07:49:12 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
07:49:30 <bscarlet> > [ i | i <- [1..], i `mod` 3 /= 0 ]
07:49:33 <lambdabot>   [1,2,4,5,7,8,10,11,13,14,16,17,19,20,22,23,25,26,28,29,31,32,34,35,37,38,40...
07:50:17 <b2coutts> > filter ((/= 0) . `mod 3`) [1..]
07:50:18 <lambdabot>   <hint>:1:18: parse error on input ``'
07:50:25 <b2coutts> > filter ((/= 0) . `mod` 3) [1..]
07:50:28 <lambdabot>   <hint>:1:18: parse error on input ``'
07:50:44 <flebron> Yeah, I'm aware of the filtering syntax :)
07:50:52 <b2coutts> yeah, I was trying to demonstrate that it's shorter than list comprehensions anyway
07:50:54 <Hafydd> > [i+j | i <- [0,3..9], j <- [1,2]]
07:50:55 <lambdabot>   [1,2,4,5,7,8,10,11]
07:51:09 <Sculptor> yo
07:51:26 <b2coutts> Hafydd: ++
07:51:27 <bscarlet> Hafydd: cute
07:51:55 <flebron> Heh, thanks :)
07:54:21 <hashcat> > filter ((/= 0) . mod 3) [1..]
07:54:22 <lambdabot>   [2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
07:55:51 <bscarlet> hashcat: I think you've got the arguments to mod flipped.
07:56:15 <bscarlet> > filter ((/= 0). (`mod` 3)) [1..]
07:56:16 <lambdabot>   [1,2,4,5,7,8,10,11,13,14,16,17,19,20,22,23,25,26,28,29,31,32,34,35,37,38,40...
07:56:30 <hashcat> > filter ((/= 0) . (\x->mod x 3)) [1..]
07:56:32 <lambdabot>   [1,2,4,5,7,8,10,11,13,14,16,17,19,20,22,23,25,26,28,29,31,32,34,35,37,38,40...
07:56:57 <bscarlet> > filter ((/=0) . flip mod 3) [1..]
07:56:58 <lambdabot>   [1,2,4,5,7,8,10,11,13,14,16,17,19,20,22,23,25,26,28,29,31,32,34,35,37,38,40...
07:57:59 <hashcat> :)
07:58:36 <hashcat> did anyone know what fpcomplete is really doing?
07:58:42 <bscarlet> > merge [1,4 ..] [2,5..]
07:58:43 <lambdabot>   Not in scope: `merge'
07:59:02 <benj_> > (+) <$> [0,3..] <*> [1,2]
07:59:03 <lambdabot>   [1,2,4,5,7,8,10,11,13,14,16,17,19,20,22,23,25,26,28,29,31,32,34,35,37,38,40...
07:59:46 <b2coutts> is there a function that builds an infinite list by applying a function over and over again to a seed?
07:59:51 <flebron> iterate
07:59:58 <flebron> > iterate (*2) 1
07:59:59 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
08:00:42 <bartavelle> ok, for some reason, trifecta is extremely slow compared to parsec
08:01:33 <lingxiao> has anyone dabbled with machines?
08:01:42 <bscarlet> quick! to the ekmett signal!
08:01:48 <lingxiao> lol...
08:03:53 <b2coutts> iterate (\x -> x + rem x 3) 1
08:03:57 <b2coutts> > iterate (\x -> x + rem x 3) 1
08:03:58 <lambdabot>   [1,2,4,5,7,8,10,11,13,14,16,17,19,20,22,23,25,26,28,29,31,32,34,35,37,38,40...
08:06:15 <Hafydd> > iterate (liftM2 (+) id (`rem` 4)) 1
08:06:16 <lambdabot>   [1,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
08:07:16 <Hafydd> > iterate (liftM2 (+) id (`rem` 5)) 1
08:07:16 <lambdabot>   [1,2,4,8,11,12,14,18,21,22,24,28,31,32,34,38,41,42,44,48,51,52,54,58,61,62,...
08:07:20 <Hafydd> > iterate (liftM2 (+) id (`rem` 6)) 1
08:07:21 <lambdabot>   [1,2,4,8,10,14,16,20,22,26,28,32,34,38,40,44,46,50,52,56,58,62,64,68,70,74,...
08:09:18 * hackagebot yesod-dsl 0.1.1.2 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.2 (TeroLaitinen)
08:09:20 <mjrosenb> does Control.Monad.Maybe exist anywhere?
08:09:41 <plhk> is there a way to build a self-contained library with cabal? with all *.a files it depends on packed into one?
08:09:59 <elliott> mjrosenb: transformers has MaybeT
08:10:05 <elliott> and if you use mtl you depend on transformers indirectly
08:10:10 <Hafydd> It's in Control.Monad.Instances now.
08:11:32 <Hafydd> > (id + id) 1
08:11:34 <lambdabot>   No instance for (GHC.Show.Show a0)
08:11:34 <lambdabot>    arising from a use of `M2069470582.sh...
08:11:57 <Hafydd> :t id + id
08:11:57 <lambdabot> Num (a -> a) => a -> a
08:12:11 <mjrosenb> elliott: danke.  I love setting up a new system "what do you mean you can't find it? oh, what isn't installed now?"
08:12:29 <lingxiao> :t 2
08:12:32 <lambdabot> Num a => a
08:13:37 <elliott> mjrosenb: :)
08:15:19 <mjrosenb> still can't find Control.Monad.Maybe
08:16:16 <mjrosenb> whereas, on my old machine, "Could not find module `System'
08:17:54 <geekosaur> http://new-hackage.haskell.org/package/MaybeT
08:18:27 <geekosaur> as for the old machine, that sounds like it's trying to use old haskell98 modules and the code needs to be updated for haskell2010+
08:25:07 <Luke> is there something for durations and formatting durations?
08:27:04 <Luke> so "formatDuration "{0} hours" . durationToHours . secondsToDuration 1234" or something like that
08:28:39 <m_hyperbolic> Hello people, would somebody be willing to take a look at this error and maybe give en idea of what if happening?
08:34:41 <magicman> ... how long has new-hackage been a thing? Or is it a thing-in-testing?
08:34:56 <geekosaur> it's a thing in testing
08:35:15 <magicman> Ah, cool.
08:42:16 <mjrosenb> where is getArgs located these days?
08:42:27 <mjrosenb> it isn't in System.
08:42:42 <dolio> System.Environment
08:43:07 <mjrosenb> dolio: thanks.
08:43:22 <mjrosenb> actually, I could have probably done that myself
08:43:25 <mjrosenb> @hoogle getArgs
08:43:25 <lambdabot> System.Environment getArgs :: IO [String]
08:43:26 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
08:43:26 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
08:43:30 <mjrosenb> yup.
08:45:53 <sm> morning all
08:47:23 <m_hyperbolic> Hello people, I have a type error I don't understand at all. Would somebody be willing to take a look? Thanks. (http://hpaste.org/90461)
08:49:07 <elliott> m_hyperbolic: eh, did you turn off the monomorphism restriction?
08:49:36 <m_hyperbolic> elliott: Not to my knowlegde..
08:50:12 <m_hyperbolic> elliott: Should I do that?
08:50:13 <elliott> uh, you could give isPrime a type signature. I'm a little puzzled as to why you're getting this ambiguity error in the first place unless you're using compiler flags or pragmas
08:50:16 <mauke> sqrt n and mod n are incompatible
08:50:45 <mauke> :t sqrt
08:50:48 <lambdabot> Floating a => a -> a
08:50:53 <elliott> oh, it wants both Floating and Integral
08:50:53 <mauke> you've got both an Integral and a Floating constraint on a0
08:50:55 <dolio> Psshhh
08:50:57 <mauke> adding a type signature would improve things, yes
08:50:59 <dolio> > sqrt x `mod` 5
08:51:00 <lambdabot>   sqrt x `mod` 5
08:51:02 <elliott> teaches me to read the compiler error and not the code
08:51:28 <elliott> er, the opposite of that. whatever
08:51:53 <m_hyperbolic> Hm I see.. So is it impossible to both use mod and sqrt with the same input?
08:52:47 <dolio> For most stuff, yes.
08:52:48 <elliott> without adding new instances, yes (and adding new instances is not the solution)
08:53:34 <m_hyperbolic> Ok. Thanks for the help!
08:53:56 <mauke> m_hyperbolic: but you can convert between Integer and Double
08:55:23 <bscarlet> m_hyperbolic: x <= ceiling (sqrt (fromIntegral n)) or x*x <= n
08:59:16 <bartavelle> I am probably doing something wrong, I am rewriting my parsec parser using trifecta this time, and it is at least 1500x slower
09:00:01 <elliott> sounds like a bug
09:00:13 <elliott> though iirc trifecta isn't focused on performance much
09:00:24 <bartavelle> yeah but 1500x really sounds like a bug
09:02:06 <elliott> yeah, tell edwardk :)
09:02:17 <trace30m> I dont unterstand what rdeepseq does
09:03:01 <m_hyperbolic> Can I make a shortcuirting edition of [x | x <- [1..], x <= 100] ? So I wont keep evaluating numbers after the condition is met?
09:03:25 <elliott> > takeWhile (<= 100) [1..]
09:03:27 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:03:28 <elliott> or
09:03:31 <elliott> > [1..100]
09:03:33 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:04:11 <alpounet> trace30m, it will evaluate everything in your value, enter your fields and evaluate them if it's a data type, fully evaluate the content of a container, etc
09:04:12 <b2coutts> the former is likely what you want if you're asking about the more general case of ending the list comprehension when a condition is met
09:04:38 <trace30m> alpounet: what does evaluate mean?
09:04:56 <b2coutts> > [x | x <- takeWhile (/= 10) [1..] ]
09:04:56 <lambdabot>   [1,2,3,4,5,6,7,8,9]
09:04:57 <m_hyperbolic> Yes takeWhile look like what I want
09:05:27 <alpounet> trace30m, "computed" if you prefer
09:05:53 <CaptainK> can you combine two lines of code with a seperator say let a =x; let b =y?
09:06:26 <trace30m> ( map prime [lo .. hi]
09:06:26 <trace30m> `using` parListChunk (div (hi-lo) 8) rdeepseq
09:06:26 <trace30m> )
09:06:30 <trace30m> sry
09:06:48 <trace30m> rdeepseq has no values
09:07:08 <elliott> CaptainK: in what context?
09:07:37 <ocharles> CaptainK: maybe let { a = x; b = y } in ....
09:07:39 <NemesisD> any of you guys have experience with the logic monad?
09:07:41 <alpounet> trace30m, the `using` … part means that the list will be evaluated by chunks of (hi-lo)/8 elements, in parallel, and the evaluation strategy will be to fully evaluate the list
09:07:43 <ocharles> > let { a = 5 } in a
09:07:44 <lambdabot>   5
09:07:52 <mauke> > let a = 5; b = c in a
09:07:53 <lambdabot>   5
09:07:54 <alpounet> trace30m, read about lazy evaluation if that sentence isn't clear to you
09:07:54 <ocharles> > let { a = 5; b = 10 } in a + b
09:07:55 <lambdabot>   15
09:08:05 <ocharles> oh, no need for braces
09:08:15 <mauke> > do let a = 1; b = 2; ""
09:08:16 <lambdabot>   <hint>:1:24:
09:08:16 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
09:08:20 <mauke> > do let a = 1; let b = 2; ""
09:08:21 <lambdabot>   <hint>:1:28:
09:08:21 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
09:08:24 <mauke> thought so
09:08:31 <mauke> > do let {a = 1}; let {b = 2}; ""
09:08:34 <lambdabot>   ""
09:08:54 <ocharles> > do { let a = 1; let b = 2; "" }
09:08:55 <lambdabot>   <hint>:1:31: parse error on input `}'
09:08:59 <ocharles> > do { let a = 1; let b = 2; ""; }
09:09:00 <lambdabot>   <hint>:1:30: parse error on input `;'
09:09:02 <ocharles> meh
09:09:18 <CaptainK> ya this is what has me pulling out my hairs on such a simple thing
09:10:04 <trace30m> alpounet: thx
09:16:19 <CaptainK> do let a = 1; b = 2; ""
09:16:49 <NNOTM> Will (\xs -> length . filter (const True) $ xs) require one or two passes through the list?
09:17:48 <elliott> one
09:17:54 <ocharles> It should only require one, but that be the case regardless of the predicate to filter
09:18:04 <elliott> ocharles: are you a pirate?
09:18:18 <ocharles> elliott: que?
09:18:22 <mauke> `Jake`: what's the difference?
09:18:25 <elliott> "that be the case" :)
09:18:33 <ocharles> arrrr
09:18:35 <ocharles> :)
09:19:18 <`Jake`> I would think that having to go twice though als those (:)s would require quite a bit more time
09:19:49 <ocharles> In a strict language, yes
09:20:08 <ocharles> or call by value, whatever the semantics are called
09:20:22 <`Jake`> ocharles: The predicate was just as an example
09:20:23 <ocharles> though maybe this is fusion that helps here, not call-by-nees
09:20:24 <elliott> filter will produce a cons cell, then length will consume it, and cause filter to produce another,
09:20:28 <elliott> which length will consume, etc. etc. etc.
09:20:47 <ocharles> need*
09:20:53 <ocharles> damn it fingers, do what I want you to od
09:20:53 <ocharles> DO
09:20:54 * ocharles gives up
09:20:57 <`Jake`> :D
09:21:04 <`Jake`> So it would be one pass?
09:21:19 <ocharles> yep
09:21:23 <`Jake`> ok, thanks
09:22:19 <ocharles> There is research at the moment going on that means even (sum xs / length xs) will take only one pass
09:22:43 <ocharles> but I don't think that's got much past the research stage just yet, and I'm not sure it will be used in Prelude functions
09:22:49 <mauke> `Jake`: what's the difference between doing N things twice and doing 2 things N times?
09:23:16 <bscarlet> mauke: locality
09:23:54 <trace30m> why has a function the result type IO () and not just () ?
09:24:02 <xico> hi
09:24:28 <bscarlet> trace30m: depends on the function. They mean different things.
09:24:37 <`Jake`> mauke: I might be thinking in a strict way or in a wrong way, but it seems to me like for one pass you'd have to go through filter and length once for each element in any case, but you'd need to deconstruct the (:)s twice for two passes and once for one pass
09:24:46 <b2coutts> trace30m: the `IO ()` type means it's a value that, when evaluated in a do block, will do some IO things, then return ()
09:24:52 <b2coutts> () is just an empty tuple
09:25:09 <`Jake`> replace the first "for one pass" with nothing
09:25:12 <`Jake`> in my sentence
09:25:28 <trace30m> bscarlet: ahhh so its only IO () because other algorithms can work with it
09:25:54 <xico> i am trying to defined the following code: http://hpaste.org/90462
09:25:59 <xico> but the compiler complains
09:26:07 <xico> it is trivial to implement with gadts
09:26:28 <xico> but why does not it work with phantom types? (though less safe of course)
09:26:34 <ocharles> xico: what does the compiler "complain" about?
09:26:46 <bscarlet> trace30m: "because" could mean many things as you're using it. Do you mean "why would one write a function of type returning IO (), rather than ()?" or "Given a function, what makes its type come out something returning IO () rather than ()?"
09:26:55 <elliott> xico: Intg 123 :: Term String
09:27:03 <elliott> so eval (Intg 123 :: Term String) must :: String
09:27:06 <ocharles> for a start your Add expression doesn't even make sense
09:27:22 <elliott> xico: you never constrain "a" anywhere after all
09:27:40 <xico> ocharles: what do you mean?
09:27:52 <ocharles> eval Add = (+) means: eval :: Num n => Expr (n -> n -> n) -> (n -> n -> n)
09:28:03 <ocharles> is that what you wanted?
09:28:12 <trace30m> bscarlet: I guess I understood
09:28:16 <elliott> well, it works if you declare it as a GADT properly. because you get the type refinement
09:28:20 <elliott> but of course that isn't the case here
09:29:08 <xico> ocharles: yes. why not?
09:29:19 <flebron> So I'm spending 75% of my program's time in output, it seems. Given that factor :: Int -> [Int], is there a way to improve upon this? http://hpaste.org/90464 . It should read Ints separated by newlines, and print that list of prime factors. I can't use Data.ByteString.Builder due to the old (6.10) GHC version.
09:29:21 <xico> the working gadt is this one: http://hpaste.org/90465
09:31:00 <trace30m> can a function be the result of a function ?
09:31:01 <xico> why not?
09:31:01 <elliott> xico: did you understand my objection?
09:31:02 <elliott> Intg 123 :: Term String, Intg 123 :: Term (IO ()), Intg 123 :: Term (String -> String -> Int)
09:31:02 <xico> elliott: no :)
09:31:11 <elliott> there is nothing linking the "a" type parameter and the Int parameter of Intg
09:31:18 <elliott> you can check for yourself that Intg 123 admits all these types in GHCi
09:31:34 <elliott> therefore, eval (Intg 123) can :: String, it can :: IO (), it can :: String -> String -> Int
09:31:37 <elliott> and your eval definition must support this
09:31:40 <elliott> because that is what you claim: Term a -> a
09:31:44 <xico> ah!
09:31:47 <xico> elliott: thanks :)
09:31:54 <elliott> :)
09:32:08 <xico> no i am wondering what this type refinement is
09:32:16 <elliott> what GADTs give you is precisely the type restriction where a constructor forces a type parameter to be something and letting you get it "refined" when you pattern match on it
09:32:19 <xico> i mean how it works
09:32:43 <elliott> when you say eval (Intg n) = ... with the GADT version, then it knows a ~ Int because Intg :: ... -> Term Int
09:32:59 <elliott> so you only have to give an Int result, not any old "a", because now you know what "a" is.
09:33:00 <xico> ok
09:33:08 <xico> makes sense thanks!
09:34:14 <CaptainK> main = do putStr "Hello"; putStrLn " World" w
09:35:27 <CaptainK> works for concatenating lines onto one line of code
09:36:05 <CaptainK> but why main = do let a = 1; b = 2 does not work?
09:36:58 <CaptainK> lambdabot: /query
09:37:30 <lambdabot> try /query lambdabot
09:39:34 <prophile> :hoogle (a -> b -> c) -> (a -> b) -> a -> c
09:39:42 <prophile> @hoogle (a -> b -> c) -> (a -> b) -> a -> c
09:39:43 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
09:39:43 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
09:39:43 <lambdabot> Data.IntMap.Strict mapKeysWith :: (a -> a -> a) -> (Key -> Key) -> IntMap a -> IntMap a
09:40:19 <elliott> prophile: (<*>)
09:40:21 <elliott> > (f <*> g) x                            :: Expr
09:40:22 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
09:40:24 <lambdabot>    arising from a us...
09:40:27 <elliott> pah.
09:41:11 <prophile> is that the applicative instance for ((->) r)?
09:41:37 <prophile> ah, that makes sense
09:41:39 <byorgey> CaptainK: good question, I am not sure
09:42:16 <elliott> prophile: yep
09:42:20 <mauke> because the last statement in a do block must be an expression
09:42:22 <elliott> prophile: pure = K, (<*>) = S, if you know your combinators
09:42:28 <CaptainK> byorgey: ok, then its not just me,,,hewww
09:42:55 <mauke> CaptainK: it is just you
09:43:00 <CaptainK> mauke: damit!
09:43:05 <byorgey> mauke: that's not why.  do let a = 1; let b = 2; putStr "Hello"  does not parse either
09:43:15 <mauke> byorgey: duh?
09:43:18 <prophile> elliott: that's what I was thinking of, yeah
09:43:24 <mauke> that was demonstrated earlier, along with the correct way
09:43:29 <elliott> i believe that parses as do { let { a = 1 }; let { b = 2; putStr "Hello" } }
09:43:31 <prophile> that's pretty neat
09:43:44 <elliott> prophile: I believe this is where the name "applicative" comes from
09:43:45 <byorgey> CaptainK: however, do let {a = 1; b = 2}; putStr "Hello" works
09:44:19 <prophile> elliott: intriguing
09:44:50 <CaptainK> ah ok, so the let has to encapsulate and not be implied on multiple declarations
09:44:50 <elliott> prophile: also, flip = C (generalises to distribute in the distributive package), W = join, B = (.)
09:45:01 <elliott> (generalises to Control.Category.(.))
09:45:10 <elliott> not that all these generalisations are related.
09:45:16 <prophile> :t (<*>) (pure (<*> id)) pure
09:45:17 <lambdabot> (a -> b) -> a -> b
09:45:34 <byorgey> mauke: insulting people's intelligence is not helpful.  You really get away with a lot in this channel because you are so knowledgeable, but it gets annoying sometimes.
09:45:34 <CaptainK> elliott: and so your example is why it does not work
09:45:48 <FreeFull> :t join id
09:45:48 <lambdabot>     Occurs check: cannot construct the infinite type: a1 = a1 -> a0
09:45:49 <lambdabot>     Expected type: a1 -> a1 -> a0
09:45:49 <lambdabot>       Actual type: a1 -> a1
09:46:08 <FreeFull> :t join (+) 3
09:46:08 <prophile> elliott: clearly I have a lot still to learn about haskell...
09:46:08 <lambdabot> Num a => a
09:46:09 <kurama> I'm having linking problems when building the latest stable version of ghc. >_<
09:46:28 <elliott> prophile: well, at least one of the generalisations I mentioned is hopelessly obscure :)
09:47:12 <CaptainK> when I query lambdabot, I can test these declarations without poluting this channel?
09:47:24 <FreeFull> CaptainK: yes
09:47:25 <byorgey> CaptainK: yes.
09:47:41 <FreeFull> Lambdabot doesn't do IO though
09:47:58 <CaptainK> ah ok,
09:49:03 <CaptainK> trying to get my head around just the simplest construction, they call it "lazy" but I feel its anything but
09:49:53 <byorgey> CaptainK: which construction are you talking about?
09:53:12 <prophile> elliott: does the writer applicative instance have any interesting properties?
09:54:37 <elliott> well, it, uh, follows the Applicative laws.
09:58:04 <prophile> elliott: naturally, but it has no curious correspondance like reader and the SK combinators?
09:58:18 <CaptainK> byorgey: like making a simple program "Hello World", you can't do the same things in GHCi as you do in <file>.hs
09:58:36 <elliott> prophile: well, it's more like Applicative is a generalisation of S and K.
09:58:48 <elliott> and under the view, the ((->) r) instance is the most trivial one.
09:58:56 <CaptainK> looking for a manual to describe this right from the beginning, LYAH does NOT explain this at all
09:59:48 <prophile> elliott: hm, okay
10:00:39 <byorgey> CaptainK: you are not intended to do the same things in GHCi as you do in a .hs file.
10:01:01 <byorgey> CaptainK: ghci is for interactively evaluating expressions.  It is not very useful for making definitions.
10:01:11 <byorgey> you should make your definitions in an .hs file (open in one window) and then :reload it in ghci, in another window
10:01:20 <elliott> (and you can spell it ":r")
10:01:31 <dolio> They've made it a lot better for defining random stuff lately.
10:02:02 <alpounet> yeah, we can even define data types now
10:02:15 <FreeFull> CaptainK: GHCi behaves like you are in the IO monad
10:02:17 <elliott> @let data Foo = A | B | C
10:02:18 <lambdabot>  Defined.
10:02:23 <alpounet> + we can write 'import' instead of using :m +
10:02:28 <FreeFull> Except any non-IO values get printed out
10:03:18 <acube> CaptainK: LYAH notes the let syntax in GHCi http://learnyouahaskell.com/starting-out#an-intro-to-lists
10:05:55 <ziman> > A
10:05:55 <lambdabot>   No instance for (GHC.Show.Show L.Foo)
10:05:55 <lambdabot>    arising from a use of `M922137543....
10:06:25 <bscarlet> Is there a name for or instance of a monad like  m (m a)? (I only half know exactly what I'm asking)
10:06:26 <acube> @ty A
10:06:27 <lambdabot> Foo
10:06:30 <elliott> bscarlet: uh, perhaps you want the join function? your question is unclear
10:06:47 <ziman> :t join
10:06:47 <lambdabot> Monad m => m (m a) -> m a
10:06:47 <CaptainK> FreeFull: ah ok, that is a good analogy
10:07:15 <CaptainK> better than the lyah touching on it in lists anyway
10:07:27 <testable> hi
10:07:36 <testable> Im interested in testability.
10:07:41 <FreeFull> x <- getLine  -- This will work just fine in ghci
10:08:14 <FreeFull> testable: Like hunit and quickcheck?
10:09:11 <testable> GUI:s, communication, etc can be hard to test because it is not like a normal function which you can just pass input to. Does there exists tools for for example testing GUI:s automatically somehow. I guess then it would be for a specific GUI lib. Because manually clicking all buttons would be quite cumbersome.
10:09:19 <bscarlet> elliott: I know my question was unclear. I think if it were clear I'd have an answer. I know what join is. I want either something like
10:09:21 <bscarlet> newtype Foo m a = Foo { unFoo :: m (m a) }
10:09:23 <bscarlet> instance Monad m => Monad (Foo m) where ...
10:09:25 <bscarlet> or insight into the same - i.e. a monad (transformer?) for things that have to be "run" twice.
10:11:06 <bscarlet> elliott: I should say I can write the instance. It just feels like I'm probably reinventing something.
10:11:11 <FreeFull> testable: I remember reading about testing GUIs and similar things, but I don't know if there is a ready solution for that
10:11:24 <lysgaard> What is the de-facto way to create a command line program in Haskell. What I'm thinking about is parsing all the options, generating the --help text etc in a simple way.
10:11:25 <FreeFull> Basically you have a set of transformers with a polymorphic base monad
10:11:32 <FreeFull> And you can either have the base as IO or as something else
10:11:47 <FreeFull> IO would be for normal operations, something else would be for testing, etc
10:12:05 <xico> can someone recommend a nice library to generate basic animations? i would need simple objects like squares/circles, transforms like blurring, and various animations? i wrote cairo-based functions but it seems quite odd for filters.
10:12:42 <elliott> bscarlet: ah
10:12:49 <elliott> bscarlet: monads do not in general compose
10:12:56 <elliott> m and n exist if they "commute"
10:12:59 <elliott> er
10:13:05 <elliott> the monad m . n exists if they "commute"
10:13:16 <elliott> you need commute :: m (n a) -> n (m a) (or maybe the other way around) satisfying some laws that I forget.
10:13:33 <testable> FreeFull: was that directed at me? :) . Have to look into transformers and polymorphic base monads then...
10:13:34 <FreeFull> Does list compose with maybe?
10:13:53 <FreeFull> testable: I have no idea where I saw it and google isn't helping
10:14:05 <FreeFull> There *might* be some gui library that allows for it
10:14:11 <FreeFull> Go and look around
10:14:25 <FreeFull> I probably described it a bit wrong
10:16:12 <lingxiao> could someone provide a simple example of machines where a list of ints are pushed downstream, where another machine adds each int to an internal counter (so a hidden state), and then the machine pushs the ints downstream again to print to console?
10:18:24 <bscarlet> elliott: I do actually mean m (m a), with the same m.
10:18:41 <elliott> bscarlet: right. I'm just saying what I know :)
10:18:50 <elliott> bscarlet: I'm not sure there's anything interesting to say about the monad (m . m)
10:19:35 <bscarlet> hmm. Well, I'm finding it useful. I guess I'll find out.
10:20:25 <testable> FreeFull: thanks anyhow
10:21:04 <elliott> bscarlet: how are you using it?
10:21:58 <jfischoff> @type join
10:21:58 <jfischoff> man its been awhile since I have used lambdabot
10:22:05 <lambdabot> Monad m => m (m a) -> m a
10:23:08 <acube> @@ lysgaard: I think many people use (@hackage optparse-applicative) or (@hackage cmdargs)
10:23:08 <lambdabot>  lysgaard: I think many people use http://hackage.haskell.org/package/optparse-applicative or http://hackage.haskell.org/package/cmdargs
10:24:23 <bscarlet> elliott: Think of m like IO. an IO (IO a) is a computation with a stopping point (where join squashes out the stopping point, for instance). The interesting operation is \mma mmb -> do ma <- mma; mb <- mmb; a <- ma; b <- mb; f a b - i.e. interleave the two computations.
10:24:51 <FreeFull> safeInterleaveIO?
10:24:59 <elliott> bscarlet: hm.
10:25:06 <elliott> bscarlet: ok, maybe you are right that this can be interesting :)
10:25:44 <jfischoff> its seems like a free monad is where you are going if you want to maintain structure
10:27:21 <FreeFull> :t \mma mmb f -> do { ma <- mma; mb <- mmb; a <- ma; b <- mb; f a b }
10:27:21 <lambdabot> Monad m => m (m t) -> m (m t1) -> (t -> t1 -> m b) -> m b
10:27:31 <testable> So websites, are there tools to setup tests like make this request to this adress and expect this response back and then lets you autorun a bunch of tests?
10:28:16 <elliott> testable: btw... this channel is about the Haskell programming language :) just letting you know, in case you didn't
10:29:29 <flebron> So I profiled my code and the bottleneck is the output. Without access to Text.Show.ByteString, and no ByteString.Builder (GHC 6.10), how could I improve the output times here? http://codepad.org/N9bCsxL7
10:30:28 <CaptainK> is there a write up on how to use lambdabot?
10:30:43 <elliott> you can view @help for the individual commands
10:30:50 <elliott> and maybe the (outdated) haskellwiki page has info?
10:30:52 <elliott> @wiki lambdabot
10:30:52 <lambdabot> http://www.haskell.org/haskellwiki/lambdabot
10:30:58 <jfischoff> @list
10:30:58 <lambdabot> What module?  Try @listmodules for some ideas.
10:31:08 <jfischoff> @listmodules
10:31:08 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap
10:31:08 <lambdabot> source spell system tell ticker todo topic type undo unlambda unmtl version where
10:31:27 <flebron> (Or does anyone know who I should ask about this?)
10:31:39 <jfischoff> @help unmtl
10:31:39 <lambdabot> unroll mtl monads
10:32:11 <elliott> flebron: all I can say is yikes, why are you using 6.10? :)
10:32:29 <flebron> Not my install, it's for the programming competition site SPOJ.
10:32:47 <flebron> My kingdom for a newer Haskell platform.
10:33:03 <testable> elliott: yes, i want to implement something like this in haskell. haskell has really otten me interested in testability. it made me think more about how i write program, writing more pure or at least pure-ish code and isolating nonpure stuff and hard stuff to small parts of the program.
10:33:25 <elliott> testable: ah, ok.
10:35:03 <phulin> I wrote a monad transformer to track the progress of my State computation, but it's giving big performance overhead (20%). Can anyone suggest ways to make it faster?
10:35:13 <phulin> http://hpaste.org/90467
10:36:18 <CaptainK> take 5 [1..] ==> [1,2,3,4,5]
10:36:35 <phulin> I have a State computation that runs through maybe a million iterations, posting a Progress marker every 1000 iterations
10:36:53 <CaptainK> sorry, testing lambdabot, meant for query screen
10:36:54 <testable> > take 5 [1..]
10:36:59 <lambdabot>   [1,2,3,4,5]
10:37:18 <CaptainK> nice for evaluations
10:37:18 <phulin> but going through all those constructors on every iteration of the coputation is taking significant time.
10:38:31 <CaptainK> take 10 [1..]
10:38:54 <jfischoff> I guess you have the progress be a component of State's state …
10:39:09 <jfischoff> but maybe that defeats the purpose
10:39:13 <phulin> yeah
10:39:14 <elliott> CaptainK: you need the >
10:39:26 <phulin> it's supposed to use lazy evaluation to be able to print progress data without unsafePerformIO
10:39:31 <FreeFull> > map (+3) [1..10]
10:39:34 <lambdabot>   [4,5,6,7,8,9,10,11,12,13]
10:39:37 <phulin> (jfischoff)
10:39:57 <CaptainK> lol, gtk
10:40:06 <Raydiation> im viewing http://www.youtube.com/watch?v=z0N1aZ6SnBk&list=WL5582D6CFD90D8851 atm (24:25 and following). the IO monad explanation kinda sounds like Dependency Injection
10:40:14 <Raydiation> without shared objects
10:40:42 <elliott> phulin: you may be able to implement the same Progress interface with an unsafe but more efficient internal implementation
10:41:28 <phulin> elliott, I could get the same result - I'm not really attached to this interface.
10:41:37 <phulin> (with unsafePerformIO, for example)
10:41:39 <Raydiation> does the IO monad return a new world for each function?
10:41:46 <monochrom> no
10:42:11 <elliott> phulin: well, not having unsafePerformIO in your actual progressing code is nice.
10:42:17 <elliott> phulin: encapsulation is good.
10:42:21 <phulin> fair enough.
10:42:40 <elliott> Raydiation: if you're talking about "worlds" then it's very likely the IO monad explanation you have heard is misleading and bad pegagogy.
10:42:58 <elliott> hmm, but I click the link and it's Erik Meijer, so perhaps not
10:43:21 <monochrom> who knows, maybe he talks about worlds too
10:43:37 <jfischoff> phulin: I have no idea if it is applicable but there is the CPS (codensity) transformations of monad transformers that can improve performance … I can't speak to it practical applicability here … hopefully someone else can...
10:44:03 <elliott> monochrom: but I would like to believe he would not give misleading explanations :)
10:44:06 <Raydiation> im trying to understand the whole monad thing in haskell
10:44:32 <Raydiation> so basically the IO monad holds an instance of the operating system and you can use it via partial application
10:44:59 <monochrom> "the whole monad thing" is too big. don't try, at least not now. pick one monad (IO, or [], or Maybe, or ...) and try it alone first.
10:45:00 <Raydiation> basically pass a function into the io monad and the monad executes the function with the os state
10:45:14 <elliott> no
10:45:27 <elliott> re Raydiation, not monochrom
10:45:41 <phulin> jfischoff, in general I have hardly any experience with haskell performance engineering, so I could be doing something dumb here.
10:45:50 <elliott> a value of (IO a) is a description of some IO you could perform (any number of times; it's just a description) to get a final result of a.
10:45:54 <elliott> @wiki Introduction_to_IO
10:45:54 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
10:45:57 <elliott> take a look at ^ for more information
10:47:25 <jfischoff> phulin: I very little experience with optmization myself. I was hoping someone would chime in :s
10:47:41 <CaptainK> probably best I practice from .hs files until I understandthe IO monad better
10:48:30 <elliott> CaptainK: you're wondering how to do definitions in GHCi right?
10:48:32 <elliott> it's just: let foo = ...
10:48:34 <elliott> instead of foo = ...
10:48:34 <Raydiation> >>= is this like a unix pipe?
10:48:51 <monochrom> not like.
10:49:02 <elliott> there are similarities
10:49:27 <elliott> e.g., http://okmij.org/ftp/Computation/monadic-shell.html
10:50:12 <elliott> (though it's more like (>=>) really... but anyway)
10:50:26 <monochrom> yes, that one I would agree
10:51:39 <Raydiation> hm, i dont really see a difference
10:51:40 <monochrom> except that unix pipes are restriction to ByteString -> IO ByteString, no general a -> IO b
10:51:46 <monochrom> s/restriction/restricted/
10:52:02 <elliott> Raydiation: if it helps you understand, then great.
10:52:04 <monochrom> perhaps microsoft's powershell could do general a -> IO b
10:52:21 <monochrom> ah, but what counts as "understand"?
10:52:22 <Raydiation> and you need >> and >>= to compose pure and impure functions right?
10:52:37 <Raydiation> syntactical sugar
10:53:09 <elliott> they're plain old functions, not sugar, but let's say: sure.
10:53:16 <elliott> they are certainly composition.
10:53:24 <johnw> Raydiation: if f is monadic and g is pure, then f >>= return . g === fmap g f
10:53:44 <johnw> (assuming your Monad is also a Functor; if not, use liftM instead of fmap)
10:54:07 <monochrom> "composition" is broad and vague
10:54:08 <elliott> eh, f isn't (necessarily) a function there.
10:54:16 <johnw> oh, right, it's not at all
10:54:19 <johnw> f >=> return .g
10:55:06 <elliott> I'm not sure this helps :P
10:55:12 <jlouis> lpsmith: here?
10:55:53 <johnw> well, I was making the point that you can't compose pure and impure functions using >> and >>= alone, you need to combine the pure function in some additional way (using return, or fmap/liftM)
10:56:08 <elliott> I suspect by "impure function" Raydiation just means an IO action. but I could be wrong.
10:56:08 <johnw> but if it doesn't help, please ignore
10:56:15 <Raydiation> elliott: es
10:56:15 <Raydiation> yes*
10:56:30 <elliott> those aren't functions, for what it's worth :) though they correspond to things that would be functions in other languages.
10:56:50 <CaptainK> elliott: ok but why do I need to still have "let" in my .hs file, say for example: main = do  x = "Hello" print x
10:57:44 <monochrom> "f :: Int -> IO Bool" is a function. see the "->" there. "getChar :: IO Char" is not a function. see no "->" there. end of story.
10:57:47 <CaptainK> took out the new lines so as not to polute the channel...another lesson that was not apparent to me in LYAH, that you need to have the proper indentation.
10:58:01 <elliott> CaptainK: because you're in a do block.
10:58:06 <elliott> that's how definitions in a do block work
10:58:15 <elliott> (and GHCi's syntax works by analogy)
10:58:26 <DR6> quick question about the free package: is 'retract . hoistFree f . liftF = f ' always correct?
10:58:42 <elliott> monochrom: and then I do type ScrewMonochrom a = Int -> a... :)
10:59:00 <CaptainK> ah, ok...god dang...where do I read about these rules?  they talk about it later on in lyah?
10:59:29 <Raydiation> btw, comparing java to haskell is this correct: haskell: IO a     java: IO<a>
10:59:46 <Raydiation> theres an IO something that holds an a
10:59:50 <monochrom> guess what, GHC_Screws_You.hs contains a line "newtype IO a = ... -> ..." :)
10:59:50 <elliott> uh, sure. except that java has no IO
10:59:57 <elliott> no, it doesn't necessarily contain an "a".
11:00:08 <elliott> even in Java, I don't think IO<a> necessarily contains an a.
11:00:16 <Raydiation> yeah theres always null
11:00:20 <Raydiation> or subclasses
11:00:23 <elliott> it's deeper than that
11:00:43 <alpounet> Raydiation, IO is a parametrized type, meaning it takes a type parameter, the same way Java generics do. but the inner workings and properties of how they work are very different
11:00:46 <elliott> what if I just defined: class Foo<A> { void foo(A x); }
11:00:57 <elliott> I don't know Java so my syntax may be wrong.
11:01:01 <elliott> here, Foo<A> doesn't contain any As. but it can still work with As.
11:01:07 <elliott> "containment" is a separate notion to being generic over types
11:01:21 <elliott> do you know data types in Haskell?
11:01:21 <alpounet> Raydiation, that parameter may not necessarily be used for a field though
11:01:27 <Raydiation> elliott: not yet i think
11:01:31 <monochrom> class USEconomy<a> { void consume(a money) { ... } }  this does not contain a, in fact it is a blackhole, it eats up all your a's.
11:01:35 <elliott> if so, you can imagine IO like this: data IO a = Return a | GetLineThen (String -> IO a) | PutStrLnThen String (IO a) | ...
11:01:42 <elliott> if not, well, you should learn them before thinking about IO :)
11:02:01 <monochrom> you have only seen boring classes and types, this is why you think of containment only
11:02:31 <Raydiation> so its more correct to say IO a works with types of a
11:02:53 <monochrom> "getChar :: IO Char" does not contain a Char. this should be clear. if it contained a Char, it would be the same Char every time. this does not happen.
11:03:12 <alpounet> Raydiation, something of type 'IO a' is a recipe for getting a value of type 'a' by doing some IO
11:03:27 <Raydiation> i see thanks
11:03:38 <elliott> @quote shachaf /bin/ls
11:03:38 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
11:03:52 <elliott> I should put that quote on my wall.
11:04:00 <elliott> or other people's walls.
11:04:05 <mapreduce> I've got a function that has missing patterns because I haven't finished writing it yet, but ghc doesn't give me any warnings or errors, even with -fwarn-incomplete-patterns - any suggestions?
11:04:10 <Raydiation> and if i execute? that monad i could get a different value each time?
11:04:35 <elliott> mapreduce: please hpaste :)
11:04:59 <alpounet> using elliott's picture of IO, you can see that GetLineThen (String -> IO a) is a recipe: you get a string from standard input (that's some IO), and then you feed it to a function that produces some IO (writing that string to a file for example?) and returns a value of type a (could be the length of the string you entered)
11:05:06 <elliott> Raydiation: in haskell, you never "execute" an IO action. you compose up IO actions into one big one, and then the friendly computer executes it for you. it's something that happens outside of the language.
11:05:10 <alpounet> Raydiation, ^^^
11:05:40 <mapreduce> elliott: Nevermind, the warnings appeared next time.  Probably a pebkac, thanks. :)
11:05:52 <elliott> mapreduce: happy to help :P
11:07:08 <chrisdotcode_> hola everyone
11:10:10 <johnw> hi chris.code
11:14:06 <testable> is there some way to generate mouseclicks from code, and to catch the output from a program. Can I programmatically say click mouse on pixel(x,y) and then catch then get the result as something i can use. if i press a button then X should happen , for example open a file menu, can i record that somehow?
11:14:31 <johnw> testable: that's called "automation"
11:14:38 <johnw> i know you can do it with Haskell and a web browser
11:14:42 <johnw> i'm not sure about with general UIs
11:15:32 <dmwit> testable: http://stackoverflow.com/q/11896870/791604
11:18:23 <mapreduce> If I find myself wanting to refer to a value in more than one guard, is that what a where clause is for?
11:18:53 <mapreduce> I found an example of that, so yes. :)
11:18:59 <elliott> yes :)
11:19:39 <monochrom> I do that all the time too
11:20:21 <testable> dmwit: ty
11:20:32 <monochrom> it is also ok to define something in the where-clause, and that thing makes no sense in some guards and branches
11:28:03 <chreekat> I wanted to try reactive-banana-wx on ubuntu 12.04, so I installed wx < 0.90 to match the wx libraries available on the system. When I try to run one of the reactive-banana-wx examples, I get the message you see here:
11:28:17 <Peaker> is there a Monoid-over-any-Applicative newtype implemented anywhere?
11:28:46 <testable> would a program that automates testing of X11 be appreciated?
11:28:51 <testable> X11-GUIs
11:28:52 <elliott> Peaker: I think lens has one
11:29:02 <elliott> maybe semigroups too?
11:29:09 <chreekat> http://hpaste.org/90472
11:29:46 <chreekat> (I expected lambdabot to post its usual message...)
11:29:52 <Peaker> elliott, where in lens?
11:30:18 <elliott> Peaker: um, one of the internal modules :P
11:30:56 <elliott> chreekat: hm, the hpaste bot (lambdabot doesn't do it) checks that people are on freenode before announcing pastes now, perhaps it is malfunctioning
11:31:00 <elliott> chrisdone: ping?
11:31:32 <dmwit> testable: sure it would
11:31:39 <chreekat> elliott: gotcha. At any rate, I get a message about a missing symbol, and i'm not sure what part of the system might need poking
11:32:08 <elliott> I think this is a common problem; unfortunately I don't know the common solution.
11:32:09 <jonkri> I have a type that I'm exporting. I want to hide one of the type class instances from this type, as it's only used internally. Can that be done?
11:32:58 <Fuuzetsu> testable: Sure it would
11:33:23 <elliott> jonkri: no
11:33:33 <Peaker> where can I find the "Const a b" type?
11:33:41 <jonkri> elliott: Okay, thanks.
11:33:46 <elliott> @hoogle Const
11:33:47 <lambdabot> Prelude const :: a -> b -> a
11:33:47 <lambdabot> Data.Function const :: a -> b -> a
11:33:47 <lambdabot> Control.Applicative Const :: a -> Const a b
11:34:00 <Peaker> oh, cool, missed that :)
11:34:25 * hackagebot shelly 1.2.0.0 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.2.0.0 (GregWeber)
11:36:35 <joelteon> :t const id
11:36:36 <lambdabot> b -> a -> a
11:36:50 <joelteon> :t const const
11:36:51 <lambdabot> b -> a -> b1 -> a
11:37:09 <joelteon> @pl \a b c d e f g -> d
11:37:09 <lambdabot> const (const (const (const . const . const)))
11:37:49 <chreekat> Apparently my problem is a "side effect of dynamic linking"; i can compile it with ghc but can't run it in ghci
11:37:57 <trace30m> is it possible that the result of a function is another function ?
11:38:05 <geekosaur> sure
11:38:16 <trace30m> geekosaur: thx
11:38:25 <elliott> trace30m: yes. in fact all "multiple-argument" functions are just functions that return functions.
11:38:26 <geekosaur> in fact it's a common occurrence (that's how partial application works)
11:38:40 <geekosaur> and that
11:38:41 <DR6> a -> b -> c = a -> (b  -> c)
11:38:56 <DR6> that is what elliot says
11:42:39 <FreeFull> :t const . const
11:42:40 <lambdabot> a -> b -> b1 -> a
11:47:04 <DanielDiaz> hi there
11:47:30 <johnw> hi!
11:47:37 <DanielDiaz> I have some Haskell code that does not build with *any* of the versions it depends on
11:48:00 <DanielDiaz> what's the best way to introduce version constraints without using cabal?
11:48:19 <DanielDiaz> I meant, any of the versions of the libraries it depends on
11:48:24 <mm_freak> DanielDiaz: i think -XPackageImports allows you to set a version constraint
11:48:30 <johnw> DanielDiaz: why would you want to do that?
11:48:38 <mm_freak> import "mtl >= 2.1" Control.Monad.Reader
11:48:40 <johnw> that's kind of part of the job of cabal
11:49:10 <DanielDiaz> yes, I know, but I do not want to create executables that are accessible from anywhere in the computer
11:49:11 <mm_freak> but yeah, i agree with johnw…  you should probably just cabalize your project
11:49:39 <mm_freak> DanielDiaz: so you want to interpret?
11:49:49 <DanielDiaz> that would work
11:50:24 <mm_freak> i don't really understand what you're asking for
11:50:49 <DanielDiaz> sorry
11:50:55 <DanielDiaz> say I cabalize the project
11:51:15 <DanielDiaz> then I type "cabal install" and an executable is built and is accessible from other folders
11:51:29 <mm_freak> you don't have to cabal-install
11:51:30 <alpounet> DanielDiaz, cabal configure && cabal build just builds the executable
11:51:36 <mm_freak> also cabal-install installs to your $HOME by default
11:51:36 <DanielDiaz> yes, right
11:51:37 <alpounet> and puts it in dist/bin
11:51:40 <mm_freak> ~/.cabal/bin
11:52:11 <DanielDiaz> can I choose where the bin goes?
11:52:11 <mm_freak> sure
11:52:14 <mm_freak> cabal configure --prefix=…
11:52:36 <DanielDiaz> so... if I do that, when I do "cabal build"
11:52:45 <DanielDiaz> it will appear wherever I want?
11:52:48 <mm_freak> i use cabal-dev, then the project files never leave the source tree, including the installation
11:52:58 <mm_freak> no, cabal-build just builds
11:53:02 <CaptainK> ok, starting to understand how haskell starts, thanks for the patient help guys
11:53:03 <mm_freak> it does not install at all
11:53:15 <alpounet> DanielDiaz, cabal build will still leave a bin in dist/bin
11:53:16 <monochrom> it appears after "cabal copy"
11:53:23 <alpounet> something like that
11:53:49 <CaptainK> laziness is not what I thought it was...omg...my brain hurts reading this...understaning it is another story: http://en.wikibooks.org/wiki/Haskell/Laziness
11:54:21 <mm_freak> CaptainK: laziness is best understood by asking what happens when you pattern-match
11:54:31 <mm_freak> ones = 1 : ones
11:54:33 <DanielDiaz> so what does "cabal copy" exactly? what does it copy? and where?
11:54:40 <mm_freak> case ones of x:xs -> …; [] -> …
11:54:43 <mm_freak> which case matches?
11:54:49 <alpounet> CaptainK, i have a tutorial coming about this
11:55:05 <monochrom> also, see my http://article.gmane.org/gmane.comp.lang.haskell.cafe/101796
11:55:08 <alpounet> waiting for some proofreading by a few people and it'll go live
11:55:30 <monochrom> CaptainK: see my http://www.vex.net/~trebla/haskell/lazy.xhtml
11:55:31 <CaptainK> looking forward to it!
11:55:44 <mm_freak> CaptainK: the question was for you =)
11:55:44 <testable> is GNOME and KDE built on top of X?
11:55:58 <CaptainK> lol
11:56:06 <mm_freak> testable: i think you're asking in the wrong channel
11:56:22 <monochrom> "cabal copy" copies binaries to whatever you set with "cabal configure --prefix=blah"
11:56:30 <DanielDiaz> thank you, monochrom
11:56:39 <DanielDiaz> I think that is good to know
11:56:51 <monochrom> also, see my http://article.gmane.org/gmane.comp.lang.haskell.cafe/101796
11:57:03 <mm_freak> CaptainK: it's an exercise…  and it will help you, so answer it =)
11:57:32 <mm_freak> ones = 1 : ones;  case ones of x:xs -> …; [] -> …;  -- which case matches?  x:xs or []?
11:57:48 <DR6> I have a question about rankN types
11:58:41 <johnw> for any question concerning a ranked type, I'll give you an answer
11:59:32 <DR6> let's imagine a function of type (forall a. m a -> m b)
11:59:47 <DR6> a is affected by the forall, but b isn't
12:00:02 <elliott> if the whole type of the function is that, then it's a scope error
12:00:05 <elliott> where does "b" come from?
12:00:14 <elliott> note that e.g. "id :: a -> a" really means "id :: forall a. a -> a"
12:00:20 <mm_freak> DR6: you should quantify all type variables
12:00:24 <DR6> okay, i'll give a better context
12:00:58 <monochrom> give the complete type
12:01:08 <DR6> I wanted something like (forall a. f a -> f b) -> f c -> f b
12:01:18 <mm_freak> DR6: is that the full type?
12:01:24 <mm_freak> or are you missing a constraint on f?
12:01:33 <elliott> for reference, that really means (forall f b c. (forall a. f a -> f b) -> f c -> f b)
12:01:39 <elliott> unless we're working with a particular f you have in mind?
12:01:47 <elliott> if so, I suggest saying e.g. F so it cannot be mistaken for a type variable
12:01:47 <DR6> particular f
12:01:52 <tobias_> Hi, I am quite new to Haskell and wondering why specifying the type of my list makes the program slower. http://codepad.org/KYlunK74 -> 0.2s - http://codepad.org/VqmvCE9s -> 4.4s - I am using GHCI.
12:01:56 <DR6> yes, sory
12:02:03 <elliott> and particular b or c, or working generically over them?
12:02:15 <DR6> generically over them
12:02:18 <mm_freak> (forall a. F a -> F b) -> F c -> F b
12:02:25 <elliott> ok, so let's say (forall b c. (forall a. F a -> F b) -> F c -> F b)
12:02:38 <DR6> yes
12:02:39 <mm_freak> go ahead
12:02:57 <DR6> may I use a function like (fmap id) there?
12:03:09 <DR6> or must the result be defined?
12:03:21 <elliott> you mean as an argument to this function?
12:03:28 <elliott> you can't know that the "a" you get will be equal to "b"
12:03:29 <DR6> yes
12:03:30 <johnw> tobias_: have you compared compiling that code with -O?
12:03:32 <elliott> or...
12:03:44 <elliott> right, yes
12:03:45 <iteratee> tobias_: yes, try them compiled.
12:03:49 <johnw> tobias_: I'm not sure whether ghci is going to be smart enough to optimize for the specific case of usage after you generalize the type
12:03:54 <elliott> if you are (forall a. F a -> F b), you know what "b" is, but you don't know what "a" is
12:04:07 <elliott> let's say the function you're being passed to is devious
12:04:16 <elliott> for whatever "b" has been picked, it will call your function with a = [b]
12:04:27 <elliott> but b can never equal [b]!
12:04:49 <elliott> so you know that you cannot possibly use fmap id, because the function calling you gets to choose the "a"
12:05:04 <elliott> and it can defeat you by picking one that is most certainly different from whatever "b" you have picked when calling the function
12:05:14 <iteratee> DR6: the simplest function that fills that role is: id
12:05:44 <elliott> er, sorry.
12:05:47 <elliott> I meant to ping DR6, not tobias_.
12:05:52 <elliott> tobias_: please disregard :)
12:05:58 <elliott> oh wait, I never pinged tobias_. argh!
12:05:58 <mm_freak> DR6: another way to put it:  the argument passed to your higher order function must be fully polymorphic in 'a'…  in particular it may not unify with other type variables…  in other words, you can read the "forall" literally
12:06:07 <mm_freak> a function that promises to work "for all" types 'a'
12:06:09 <DR6> okay, than you
12:06:27 <FreeFull> Which function chooses the b?
12:06:35 <mm_freak> FreeFull: the caller of the HOF
12:06:54 <mm_freak> and the HOF itself chooses 'a'
12:06:55 <FreeFull> Would something like  const whatever    work?
12:07:11 <mm_freak> FreeFull: fmap . const
12:07:15 <mm_freak> but yeah, that would work
12:07:27 <DR6> maybe I should explain my problem
12:07:35 <mm_freak> f (fmap (const x)) y
12:07:44 <DR6> I am writing a wrapper for reddit
12:07:53 <DR6> I use first a free monad as interface
12:07:53 <mm_freak> (assuming that F is a functor as suggested by its name)
12:08:08 <DR6> that gets converted to Network.Browser.BrowserAction and then to IO
12:08:45 <DR6> I have a function that converts directly to IO
12:08:46 <tobias_> johnw: Compiling with ghc -o test test.hs did not help.
12:09:08 <DR6> but I'd like it to be able to tamper with the BrowserState before converting it to IO
12:09:09 <b52> does someone possess a nice cheat sheet how to document code to get proper haddock documentation including best practices and common idiom?
12:09:47 <DR6> I wanted to know if the same function could handle functions that altered the output of the action and functions that needed
12:09:48 <mm_freak> b52: is the haddock documentation insufficient?
12:09:59 <b52> which one do you mean/
12:10:04 <DR6> you made clear that the same function can't do it
12:10:16 <mm_freak> b52: http://www.haskell.org/haddock/doc/html/
12:11:13 <b52> mm_freak: thanks, i wasn't aware that haddock ships with such a comprehense doku
12:11:15 <tobias_> johnw: ghc -O -o test test.hs also made no difference.
12:11:17 <johnw> tobias_: now this is getting interesting!
12:11:31 <johnw> if I wasn't buried in bugs at the moment, I'd look at the core for both and see what's going on
12:11:31 <mm_freak> b52: that would be utterly bad =)
12:11:36 <johnw> perhaps someone else here can help with that
12:11:47 <b52> mm_freak: indeed ,)
12:12:05 <b52> how could i even dare to doubt
12:13:43 <kurama> My pathetic attempt to build ghc from source fails again. *sigh*
12:14:18 <tobias_> johnq: Oh, I am sorry. I only deleted the executable, so it was just relinked, not recompiled. If I resafe my file (new last mod date) and then compile with -O it is fast.
12:14:24 * kurama bangs head wishing the haskell portage overlay would "just work" so that he wouldn't have to do this.
12:14:33 <tobias_> I meant johnw. ;)
12:14:52 <apples`> is there a reason to use the least fixed point version of a data type over one that's explicitly recursive?
12:15:18 <tobias_> johnw: So unfortunately nothing interesting here. ^_-
12:16:05 <roconnor> kurama: try nixos
12:16:55 <roconnor> apples`: often the functor used in the fixed point is quite useful in of itself.
12:16:56 <elliott> tobias_: you can -fforce-recomp
12:17:17 <roconnor> apples`: examples, generic fold for fixpoints and data type a-la carte.
12:17:29 <tobias_> elliott: cool, thanks
12:17:32 <apples`> i see
12:17:39 <elliott> tobias_: :)
12:17:41 <johnw> tobias_: ok, that's expected then
12:17:55 <johnw> tobias_: but do you know why ghci shows them as different?
12:18:10 <johnw> without at type signature, I'm guessing the type is being inferred as Int -> [Int], which is fairly cheap
12:18:29 <johnw> with the type signature, you have a much more general function, and there is no optimization pass to specialize it for your use case of a ~ Int
12:18:44 <tobias_> Ah, ok.
12:19:06 <elliott> saved by the DMR :P
12:19:17 <tobias_> But even with a general type I think 4 seconds is quite long for there few values.
12:19:41 <mapreduce> I thought I might be able to use the same name twice in a pattern to only match if the value is the same in both places, but I get an error about conflicting definitions.
12:19:52 <b52> mm_freak: is it also possible to include some sort of mathml markup in annotations?
12:19:54 <mapreduce> Does that need to be pushed into guards?
12:20:02 <mm_freak> b52: unfortunately no
12:20:05 <apples`> roconnor: i also read that using a f-algebra might be faster in implementation than the alternative recursive approach? is there somewhere i could read more about that?
12:20:32 <johnw> and generality is good, because it restricts what your function can do and makes it easier to reason about
12:20:54 <johnw> tobias_: i really don't know much about how ghci interprets Haskell code
12:21:02 <mm_freak> b52: if you have a darcs/git repository, just write a README.md
12:21:06 <roconnor> apples`: I'd find that very surprising
12:21:16 <mm_freak> it is rendered via markdown on hub.darcs.net/github
12:21:44 <mm_freak> although i don't know how good the markdown implementation of github is…  i doubt that it supports math notation
12:21:49 <apples`> roconnor: i read it in the acknowledgements section of https://www.fpcomplete.com/user/bartosz/understanding-algebras
12:22:29 <tobias_> johnw: np. Thanks for the solution. Have a nice day. : )
12:22:35 <bingsaw> hey is there a built-in function that just does something like this: g a b = b a
12:22:49 <bingsaw> so that i can do this: g [1, 2, 3, 4] $ map (^2)
12:22:49 <tac> @type flip ($)
12:22:50 <lambdabot> b -> (b -> c) -> c
12:23:06 <tac> (flip ($)) 3 (+1)
12:23:07 <roconnor> apples`: interesting
12:23:10 <tac> > (flip ($)) 3 (+1)
12:23:11 <lambdabot>   4
12:23:33 <tac> (flip ($)) [1,2,3,4] (map (^2))
12:23:35 <elliott> bingsaw: (&) in lens
12:23:37 <tac> > (flip ($)) [1,2,3,4] (map (^2))
12:23:38 <lambdabot>   [1,4,9,16]
12:23:41 <elliott> > [1,2,3,4] & map (^2)
12:23:42 <lambdabot>   Not in scope: `&'
12:23:44 <roconnor> apples`: it's true that GHC tends to throw it's hands up when it encounters an explicitly recursive function.
12:23:45 <elliott> eh. right.
12:24:11 <bingsaw> elliott: how do i get access to that function?
12:24:19 <roconnor> apples`: for example GHC can fuse map f (map g x) into map (f . g) x  (at least I beleive it can)
12:24:40 <apples`> ah, yeah. i've read a little about that
12:24:45 <elliott> bingsaw: import Control.Lens. it's overkill if this is all you want.
12:24:54 <elliott> apples`: I have no idea what that quote is going on about, frankly
12:25:06 <roconnor> apples`: but if you wrote (map f) as an explictly recursive funciton, and (map g) as another explitly recursive function, GHC wouldn't figure out that they are maps and can be fused (at least I don't think it can).
12:26:03 <elliott> roconnor: this is only because of explicit RULEs about map though I think.
12:26:04 <roconnor> apples`: still, this is because GHC has been given RULES about map
12:26:04 <dolio> No, it will certainly not do that.
12:26:09 <roconnor> apples`: and it won't apply to F-algebras in general (though you can write your own RULEs)
12:26:15 <apples`> interesting, i didn't know about RULEs
12:27:00 <apples`> thanks elliott and roconnor
12:27:13 <CaptainK> monochrom: will read more when I have some space in my head, looks like a good article
12:27:15 <mapreduce> http://hpaste.org/90473 - using the same name twice in a pattern - line 26 is the first place I've tried to do it.  Do I need to rewrite that as a guard?
12:27:25 <CaptainK> Here is an interesting read on why Haskell is bloated:
12:27:26 <CaptainK> http://www.reddit.com/r/haskell/comments/sb80y/why_is_haskell_so_large/
12:28:27 <CaptainK> Still dedicated to learning Haskell none the less, my square brain will be squished into this round hole
12:28:36 <dolio> Fusion also doesn't have anything to do with writing your data types explicitly as algebras.
12:28:48 <dolio> foldr/build/augment doesn't do that at all.
12:29:08 <tac> Algebras are just the right thing to do from a category theorist's standpoint.
12:29:51 <dolio> I don't know what that means.
12:30:00 <elliott> CaptainK: eh, that post is a bit confused.
12:30:41 <dolio> Algebras are the categorical semantics of data types.
12:30:53 <dolio> I don't know why you'd be obligated to represent your data types in a certain way because of that.
12:30:56 <tac> CaptainK: There's a lot of Haskell that isn't so important. It's a researcher's playground that moonlights as a close-to-being-practical language :)
12:31:25 <elliott> well, that post is more about libraries than the language.
12:32:14 <dolio> I suspect the reason that stream fusion uses an explicit coalgebra representation of streams is that any recursive function written in terms of that automatically qualifies as something written in terms of destroy.
12:32:23 <dolio> Which is half of the unfold/destory fusion.
12:32:30 <roconnor> dolio: foldr/build fuision is almost entirely about algebras
12:32:34 <dolio> Except you don't have to use a 'destroy' function explicitly.
12:32:37 <CaptainK> ya, the core is tiny, and that attracts me, you make it as fat as you want I guess
12:32:54 <b52> why does haddock fail to parse "-- * 9. PKCS#7 padding" in my module's export list?
12:33:19 <CaptainK> Interesting that it has evolutional problems just like any language, no matter how hard you try to make it perfect
12:33:51 <tac> Haskell also has comparatively more evolution, because when they started back around 1989, there was no such thing as a language with no side effects.
12:34:18 <tac> It wasn't even until Moggi's paper on monads and effects that they even had a way to do nontrivial IO.
12:34:24 <dolio> roconnor: You need to reread what I said, and the statement at the bottom of that article.
12:34:54 <roconnor> dolio: ah
12:34:55 <Cale> Well, that's not entirely true...
12:35:05 <Cale> They had a way to do IO before monadic IO.
12:35:22 <roconnor> Cale: to be fair the IO before monadic IO was pretty trivial
12:35:24 <dolio> I mean, F-algebras are everywhere in Haskell code, because data types are F-algebras.
12:35:44 <dolio> That has nothing to do with high-performance.
12:35:51 <Cale> It was a little bit clumsy, but it was more complex than saying "every program transforms stdin to stdout"
12:35:53 <mgaunard__> hi folks
12:35:57 <mgaunard__> I'm trying to understand the do notation
12:36:05 <tac> Cale: Yeah. They didn't have things like concurrency or IORefs, but they did have STDIN and STDOUT.
12:36:06 <roconnor> Cale: I guess that is true.
12:36:08 <mgaunard__> unfortunately I can't seem to find a good resource for its exact semantics
12:36:09 <Cale> Everything we express with the IO monad would have been expressible with the continuation style of IO
12:36:13 <tac> hi mgaunard__
12:36:14 <levi> Cale: There's even a paper that describes how awesome it is, which is kind of funny in retrospect.
12:36:15 <johnw> dolio: are data types initial F-algebras?
12:36:20 <roconnor> tac: you cound even read and write to files
12:36:34 <dolio> johnw: Yes.
12:36:43 <tac> roconnor: I didn't know that :)
12:36:43 <Cale> mgaunard: okay
12:36:52 <Cale> mgaunard: the translation for the do notation is basically this:
12:36:55 <mgaunard> I'm interesting in what the do notation translates to, which calls to >>, >>= etc.
12:36:57 <Cale> do { x } = x  -- base case
12:36:59 <mgaunard> I'm interested*
12:37:09 <Cale> do { x ; ... } = x >> do { ... }
12:37:10 <johnw> @undo do { x }
12:37:10 <lambdabot> x
12:37:16 <Cale> do { v <- x ; ... } = x >>= \v -> do { ... }
12:37:31 <Cale> do { let { ... } ; ... } = let { ... } in do { ... }
12:37:33 <tac> johnw: Initial F-algebras are more or less algebraic data types. The "initial" part means there's a unique morphism to any other F-algebra. This unique morphism happens to be the (primitive) recursion principle for the data type.
12:37:49 <elliott> we need to put the do rules on a wiki page rather than repeating them all the time
12:37:56 <Cale> They're in the Report
12:38:01 <johnw> tac: right, catamorphism
12:38:02 <dolio> johnw: In Haskell, they're also final coalgebras.
12:38:10 <Cale> It's easier for me to repeat them than to find a link :P
12:38:17 <elliott> I seemed to recall the Report's presentation wasn't ideal, pedagogically
12:38:20 <johnw> dolio: because we don't distinguish between data and codata?
12:38:26 <elliott> if not, we should @where+ it :)
12:38:29 <mgaunard> Cale: makes sense. Thanks.
12:38:31 <Cale> (and they're also in my monad tutorial)
12:38:36 <dolio> Yes, and because of laziness.
12:38:55 <tac> Yeah. In Haskell (or any partial language), you don't really have a good distinction between initial algebras and final coalgebras.
12:38:57 <levi> mgaunard: What Cale said is pretty much line-for-line from the Haskell 98 Report, which is a good place to look if you need a precise description of something in Haskell.
12:39:04 <tac> General recursion breaks everything :)
12:39:07 <mgaunard> I'm scared of pdfs
12:39:17 <dolio> Maybe it's true in, like, ML as well, but I haven't thought about it very hard.
12:39:18 <Cale> Get a better PDF reader
12:39:19 <tac> mgaunard: You will get over your fear quickly if you stick with Haskell :)
12:39:20 <Cale> :)
12:39:26 <johnw> haha
12:39:32 <elliott> the report is available in html
12:39:37 <dolio> I suspect not, actually.
12:39:41 <Cale> I actually read most PDFs in Chrome now...
12:39:42 <johnw> the fear just changes
12:39:46 <johnw> from format to content
12:40:03 <levi> http://www.haskell.org/onlinereport/exps.html
12:40:15 <Cale> There is one thing I left out
12:40:34 <Cale> When p is a more complex pattern in  do { p <- x ; ... }
12:40:34 <CaptainK> foxit is a decent pdf viewer
12:41:01 <levi> mupdf is great if you want something fast and minimal.
12:41:17 <elliott> @where do
12:41:17 <lambdabot> http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
12:41:20 <elliott> uh.
12:41:27 <elliott> anyone object to replacing that with a link to the do notation rules?
12:41:33 <dolio> Heh.
12:41:47 <tac> lol]
12:41:47 <Cale> the translation is something along the lines of   let { ok p = do { ... }; ok _ = fail "some message" } in x >>= ok
12:42:00 <Cale> I have no objection
12:42:01 <mgaunard> to use >>= directly you have to understand what do does in the first place
12:42:05 <Cale> do notation isn't harmful :P
12:42:05 <elliott> @where+ do http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-480003.14
12:42:06 <lambdabot> I will never forget.
12:42:19 <Cale> mgaunard: Well, you don't have to...
12:42:28 <Cale> mgaunard: Either one can be understood in terms of the other :)
12:42:46 <mgaunard> the "do notation considered harmful" page suggests you should use >>= when you can do so with partial function evaluation
12:43:02 <Cale> mgaunard: Some people are opinionated.
12:43:42 <elliott> @where+ do The rules of do notation: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-480003.14
12:43:42 <lambdabot> Okay.
12:43:43 <Cale> There are cases where you can simplify expressions, and that can be a good idea.
12:44:20 <elliott> @where+ do The rules of do notation: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-480003.14 (Note that "do { v <- m; ... }" is the same as "m >>= \v -> do { ... }" when v is a simple variable, rather than a more complex pattern.)
12:44:20 <dolio> Just always write the nicest expression possible, whether that uses do or doesn't use do.
12:44:20 <lambdabot> I will remember.
12:44:21 <Cale> But quite often going out of your way to avoid do will result in something that's actually harder to understand
12:44:56 <elliott> a nicer rendition would have the simple variable case separate, I think.
12:45:49 <elliott> @where+ do The rules of do notation: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-480003.14 (Note that "do { v <- m; ... }" is the same as "m >>= \v -> do { ... }" when v is a variable, rather than a more complex pattern.)
12:45:50 <lambdabot> Good to know.
12:45:51 <Cale> elliott: In fact, the *actual* translation which GHC uses is not the Report's one, and you can tell the difference with a custom prelude :)
12:46:01 <Cale> elliott: It's closer to the translation used in Haskell 1.4
12:46:11 <elliott> perhaps we should link to the 1.4 report then :)
12:46:47 <b52> why do have haddock export list header annotations have to start with an alpha character?
12:47:27 <CaptainK> elliott: the do notation link is a good read for newbies...good to learn now and not later
12:47:34 <Cale> Where there's a distinction between failable patterns and non-failable ones (a failable pattern contains a match against a constructor of a type with more than one, or an n-pattern)
12:47:57 <Cale> and that decides whether the translation contains 'fail' anywhere
12:48:14 <Cale> This means that if you move fail out into its own class, you get sensible constraints
12:48:24 <Cale> which hopefully we'll eventually be able to do!
12:49:24 <sclv_> fail breaks referential transparency, it was pointed out to me
12:49:38 <Cale> Yeah, slightly :)
12:49:48 <sclv_> you can slightly break rt?
12:49:58 <elliott> eh, so does TH
12:50:01 <Cale> sclv_: It's hard to abuse :)
12:50:03 <elliott> I'm ok with sugar doing things like that
12:50:08 <sclv_> it gives you a source location for free
12:50:11 <sclv_> which is sorta neat!
12:50:48 <sclv_> i guess we can say that the 'rt violation' is not in fail but in pattern matching sugar
12:50:48 <Cale> Yeah, in fact, we make a lot of use of that in skedge.me's backend
12:50:49 <sclv_> in which case its legit
12:50:55 <tac> How does fail kill ref. trans.?
12:50:56 <sclv_> i want us to add src location as a real primitive
12:51:07 <sclv_> it would be so handy
12:51:24 <Cale> We'll often use  pat <- return ...  if we want to avoid handling other cases for now, in order to get a nicely meaningful error for free.
12:51:34 <dolio> > (do Just _ <- Nothing ; Just 5) :: Either String Int
12:51:35 <lambdabot>   Couldn't match type `Data.Maybe.Maybe'
12:51:35 <lambdabot>                with `Data.Either.Eit...
12:51:42 <dolio> > (do Just _ <- Nothing ; Right 5) :: Either String Int
12:51:43 <lambdabot>   Couldn't match type `Data.Maybe.Maybe'
12:51:43 <lambdabot>                with `Data.Either.Eit...
12:51:51 <dolio> > (do Just _ <- Right Nothing ; Right 5) :: Either String Int
12:51:52 <lambdabot>   *Exception: Pattern match failure in do expression at <interactive>:3:5-10
12:51:55 <Cale> Though, admittedly, this is all in monads over IO
12:52:05 <dolio> Oh right, Either just uses error.
12:52:17 <mgaunard> Cale: couldn't the fail thing be handled by a monad?
12:52:23 <Cale> mgaunard: hm?
12:52:38 <elliott> probably ErrorT lets you exploit it
12:52:41 <Cale> mgaunard: fail is currently a method of the Monad class, but it shouldn't be
12:53:01 <Cale> mgaunard: There are a lot of monads which can't really implement fail in a very sensible way.
12:53:09 <Cale> (apart from just crashing)
12:53:31 <sclv_> that's the only sensible thing to do!
12:53:40 <dolio>  > runIdentity . runErrorT $ (do Just _ <- return Nothing ; return 5) :: Either String Int
12:53:42 <sclv_> (as long as error messages contain source locations)
12:53:53 <dolio> > runIdentity . runErrorT $ (do Just _ <- return Nothing ; return 5) :: Either String Int
12:53:54 <lambdabot>   Left "Pattern match failure in do expression at <interactive>:3:31-36"
12:53:58 <sclv_> bingo
12:54:02 <dolio> There we go.
12:57:04 <mgaunard> Cale: couldn't the fail just be called in a the >>= operator of the ok monad or something?
12:58:07 <roconnor> The best solution IMHO is to require a MonadPlus (or MonadZero) on do blocks that have pattern matching.
12:58:11 <Cale> mgaunard: ok is just a normal function there, it's not a monad (monads are functions from types to types)
12:58:19 <mgaunard> Cale: or some CheckPattern monad
12:58:52 <Cale> mgaunard: I'm not sure that I understand what you're proposing
12:59:16 <dolio> That automatically happens in GHC if you put fail in MonadPlus.
12:59:51 <mgaunard> it would generate some monad whose >>= operator would continue if the requested pattern matching is ok and call fail otherwise.
13:00:05 <dolio> Well, actually, GHC is slightly better than that, even, depending on how precise your statement is.
13:00:57 <Lethalman> if in haskell we have let y = f x; z = g x and f and g are pure, is haskell going to parallelize those two calls?
13:00:57 <shachaf> Not as good as Haskell 1.4!
13:01:13 <Lethalman> I was looking at the swift language and wondering if that's possible in haskell, implemented, or nothing like that
13:01:14 <dolio> Yes, as good as 1.4.
13:01:21 <dolio> I think.
13:01:33 <shachaf> Not unless you split out MonadZero.
13:01:45 <johnw> Lethalman: automatically, no
13:01:45 <dolio> Oh, well, yeah, but you could do that.
13:01:51 <applicative> Lethalman: how could it calculate y and z independently
13:02:00 <dolio> GHC's machinery doesn't care.
13:02:03 <Lethalman> applicative, cause f and g are independent?
13:02:13 <Lethalman> applicative, the swift language does that apparently automatically
13:02:25 <applicative> oh sorry, misread it of course as z = g y
13:02:33 <Lethalman> oh :)
13:02:34 <shachaf> Lethalman: Yes, if you're using an implementation that does that.
13:02:40 <shachaf> (Which GHC is not.)
13:02:57 <Lethalman> shachaf, ok, so it's something implementable
13:03:07 <Cale> mgaunard: It would be weird for the desugaring of an expression to construct a newly defined monad on the fly like that... unless I just don't understand what you're proposing.
13:03:07 <elliott> dolio: I like my version of fail.
13:03:08 <shachaf> (Your question is about what an implementation does, not what "haskell" does.)
13:03:15 <johnw> shachaf is right, there's nothing in the Haskell language specification to stop an implementation from doing so, but the implementation most widely use does not do that automatically
13:03:18 <applicative> you can do it with par, no?
13:03:22 <Philippa_> Lethalman: the problem Haskell has is /too many/ parallelism opportunities
13:03:31 <elliott> dolio: class Monad m => MonadZero m where mzero :: m a; fail :: (forall a. a) -> m a; fail _ = mzero
13:03:32 <Philippa_> figuring out the right granularity is a PITA
13:03:32 <alpounet> mgaunard, what you suggest is pretty much ErrorT (or Either your-error-type your-value-type, in short)
13:03:32 <Cale> mgaunard: Monads live at the type level, and are usually defined by data declarations (or newtype)
13:03:34 <Lethalman> Philippa_, that's something you shouldn't care about
13:03:45 <elliott> dolio: fail (error "foo.hs:12:34-38")
13:03:48 <applicative> @type par
13:03:49 <lambdabot>     Not in scope: `par'
13:03:49 <lambdabot>     Perhaps you meant one of these:
13:03:49 <lambdabot>       `var' (imported from Data.Number.Symbolic),
13:03:51 <elliott> then in IO you just catch the exception!
13:03:52 <Philippa_> Lethalman: on what basis?
13:03:52 <applicative> bah
13:04:03 <elliott> dolio: and then we do data Maybe a = Nothing (forall b. b) | Just a...
13:04:07 <Philippa_> I mean, do you think there's no such possible thing, or just that we ought to have the means to Get It Right?
13:04:20 <Philippa_> because the latter is what we call an ongoing research problem
13:04:32 <Lethalman> Philippa_, that's it's one possible way and would be interesting to take in consideration rather than dropping it right away
13:04:57 <shachaf> elliott does have a unique brand of fail.
13:04:57 <elliott> that consideration is being taken
13:05:01 <elliott> it's called "research"
13:05:08 <elliott> sometimes we even put "research" into GHC :)
13:05:59 <Lethalman> elliott, my question was two questions: 1) is it something possible in haskell? 2) is it already implemented in ghc?
13:05:59 <Philippa_> quite. When I say "too many", that's having looked into it and knowing that figuring out when to stay sequential and when not to is a hard problem
13:06:00 <Peaker> I wonder what would happen if GHC sprinkled par into code sparsely in random positions, what it would do to typical performance :)
13:06:12 <Philippa_> Lethalman: 1) Yes. You may, optionally, want do some back end work so that x may get evaluated twice, but still
13:06:12 <Philippa_> 2) No, and for good reason
13:06:12 <dolio> Lethalman: You must have missed when people spent a decade trying to do auto-parallelism in GHC.
13:06:34 <alpounet> Peaker, go on write the plugin
13:06:44 <Peaker> did anyone try runtime-profile-guided parallelism?
13:06:44 <alpounet> i'm curious too
13:06:50 <dolio> Don't think so.
13:06:50 <Lethalman> dolio, indeed
13:06:50 <elliott> Lethalman: (1) yes but we don't know whether it's viable, and signs point to no (2) no
13:06:51 <elliott> (3) however, there are strategies, which are lightweight ways of doing parallelism
13:07:08 <elliott> Peaker: no. that's one of the reasons I'd love to see an advanced Haskell JIT
13:07:24 <Lethalman> elliott, I was reading some of the swift language, and thought that haskell had all the type-level knowledge to auto parallelize _certain_ stuff, not everything obviously
13:07:25 <Philippa_> (4) Don't declare that I /shouldn't/ care about something until you can show I don't have to
13:07:46 <dolio> Philippa's objection wasn't discarding out of hand. It was the result of that decade of research.
13:07:48 <elliott> it doesn't have much to do with types.
13:07:51 <alpounet> Lethalman, you can evaluate a list in parallel, using chunks of <your desired number> elements, for example. see parallel strategies
13:08:00 <elliott> anyway I know nothing about this swift language you speak of
13:08:05 <elliott> but I rather suspect it's being over-hyped
13:08:06 <Philippa_> there are cases where I know some class of crap can be automated and just isn't yet. Those most certainly should go away. There are others where there are strategic decisions a programmer may legitimately wish to make
13:08:10 <alpounet> Lethalman, you may also be interested in 'repa'
13:08:13 <alpounet> @hackage repa
13:08:13 <lambdabot> http://hackage.haskell.org/package/repa
13:08:19 <Lethalman> (5) never say I said that you are discarding it out of hand, it was something you could possibly do
13:08:36 <elliott> anyway, we have fancy, easy parallelism. you can replace map with parMap someStrategy just like that.
13:08:43 <elliott> it's not totally automatic.
13:08:47 <Lethalman> alpounet, I'm talking about something automatic in ghc, not a library
13:08:58 <elliott> eh.
13:09:03 <elliott> you're being pretty disingenuous about this.
13:09:07 <johnw> if it were totally automatic, we'd just end up doing equally as much work to turn it off where it doesn't help
13:09:17 <elliott> what repa does *is* startlingly automatic parallelism for certain use-cases.
13:09:23 <elliott> but you won't know that if you dismiss it out of hand...
13:09:31 <alpounet> Lethalman, i know, but people told you it wasn't there already (although some bits in GHC help) - i'm trying to give pointers to the state of the art in haskell land
13:10:02 <alpounet> try to follow them if you're really interested in these topics :-)
13:10:52 <Lethalman> elliott, fyi: http://www.ci.uchicago.edu/swift/guides/release-0.94/userguide/userguide.html#_ordering_of_execution
13:11:04 <Philippa_> Lethalman: you said specifically that "would be interesting to take in consideration rather than dropping it right away". The implication being that others are doing the latter, ie "discarding it out of hand". Please don't pull this stuff in here
13:11:53 <Lethalman> Philippa_, stop that please, you're misreading it as well I didn't explain it in perfection
13:12:04 <elliott> Lethalman: sounds interesting. sounds also like it's not going to work in general -- this seems more like a glue type language.
13:12:14 <joelteon> is repa short for regular parallel arrays
13:12:15 * elliott agrees w/ Philippa_, original comment was rude
13:12:17 <applicative> the website for the swift programming language is too glitzy
13:12:34 <Philippa_> Lethalman: *sigh*. I may be misreading your intent, I am not misreading what you /wrote/. I'm happy to accept that you didn't mean what you said.
13:12:56 <Lethalman> Philippa_, you can be misreading what I wrote as well, I point out
13:13:25 <elliott> Lethalman: you'd do well to drop this, I think.
13:13:48 <elliott> anyway, you should look into strategies and repa if you are interested in parallelism that is anywhere from slightly to mostly automatic.
13:14:02 <elliott> if you're not satisfied unless it's 100% then you have to read research papers instead.
13:14:08 <Lethalman> ok
13:14:36 <Philippa_> quick explanation of some of what's difficult about it: when to not do/undo common subexpression elimination is a subproblem
13:14:47 <Philippa_> GHC just /doesn't do CSE/ because it plays badly with lazy evaluation
13:15:51 <alpounet> it does but in very specific cases, doesn't it?
13:16:02 <elliott> yeah it does very conservative CSE
13:16:24 <Philippa_> huh. How much is it actually happy doing these days?
13:16:46 <Philippa_> (is there a reasonably well-defined fragment it'll do CSE for, say?)
13:16:56 <elliott> Philippa_: enough that cmdargs has to turn it off and do extra hacks in its evil, evil impure module
13:17:06 <Philippa_> oh, ouch
13:17:07 <elliott> hacks like a NOINLINE'd reverse "" type thing.
13:17:08 <applicative> Lethalman: it seems this swift language is encoding some of the things that are pretty easy in haskell into the syntax, which makes sense in a 'scripting language' maybe
13:17:18 <elliott> I consider this a good thing -- perhaps eventually it will get smart enough to break that horrible module completely!
13:18:32 <Lethalman> applicative, yes it's a language designed right for that to have all the necessary information in order to parallelize execution... and I thought that haskell would have quite the same information in that regard, except the laziness that might be the source of all eventual problems :S
13:18:41 <Philippa_> *nod*. Personally I'd be happy knowing that it'll spot me reconstructing something that I pattern-matched on the LHS and add the @-pattern for me :-)
13:18:51 <Philippa_> (exactly the sort of low-level BS that /does/ wind me right up)
13:19:03 <alpounet> Philippa_, see https://raw.github.com/thoughtpolice/cse-ghc-plugin/master/CSE/Pass.lhs "Simple common sub-expression" section
13:19:06 <applicative> it will parallelize a 'program'  y = g x; z = f x ; print (y+z)
13:19:08 <Philippa_> foo@Con{} is good. foo@Con bar baz, not so much
13:19:25 <Fuuzetsu> tryhaskell.org broken
13:19:40 <elliott> Philippa_: too bad that isn't enough when you have a phantom type parameter you need to *recursively* reconstruct
13:19:48 <elliott> these days I just use unsafeCoerce from the get-go. it's less typing and faster
13:19:53 <Lethalman> applicative, yes, it also has single assignment only to variables
13:19:53 <Philippa_> Lethalman: you need a cost model that tells you when the cost of a spark is worth it
13:20:02 <Philippa_> elliott: Hah! Yeah
13:20:27 * Philippa_ wonders what Idris does for the equivalent problem
13:20:39 <elliott> I wonder what kind of change to the language would be necessary to have "foo :: Phantom a -> Phantom b; foo x = x" typecheck
13:20:44 <Philippa_> (worst case would be OTT, I guess)
13:21:13 <shachaf> elliott: I'm not sure it should just type-check as-is.
13:21:14 <Philippa_> elliott: that in particular shouldn't typecheck on that little knowledge
13:21:26 <shachaf> It defeats a lot of the point of phantom types, presumably.
13:21:39 <elliott> well, OK
13:21:43 <elliott> foo x = magic x
13:21:43 <Philippa_> I'd need to know that I have the 'right' to rebuild the same type-erased value at that type, for minimum
13:21:45 <shachaf> But it would be nice if there was some safe way to "cast" things.
13:21:48 <elliott> for some magic syntactic x
13:22:00 <elliott> that requires the constructors being in scope
13:22:11 <elliott> Philippa_: right, only working for a Phantom that isn't misleadingly named :)
13:22:13 <shachaf> Even non-recursive f (Foo x) = Foo x is a bit annoying because it allocates a new Foo.
13:22:28 <Cale> Lethalman: (Note: I haven't read all the context of this conversation.) Throughout the 1980s, people were very interested in automatic parallelisation of the sort you're discussing, but it never really worked because it's very hard to determine the costs of computations you're auto-parallelising and do load-balancing effectively. If you parallelise too many things, the scheduling costs outweigh any benefit.
13:22:35 <Philippa_> shachaf: well, that's a comparatively easy case to CSE
13:23:00 <Philippa_> that is: you can do "typeless" CSE, and you can return "the same damn thing, only I applied a coercion to it" and those things are okay
13:23:06 <Cale> Lethalman: The general approach taken in Haskell is to have annotations of various sorts as hints about what to parallelise, which don't otherwise affect the meaning of the program.
13:23:46 <applicative> swift doesn't have 'automatic' parallelism in the sense they mean, Lethalman . It has parallelism friendly syntax
13:23:46 <shachaf> Philippa_: Yep. It would be nice if GHC did that.
13:23:50 <elliott> Philippa_: I had a fancy notion of "equal up to newtypes" to make this sort of coercion stuff fast (that was incredibly invasive and required adding things to Functor and stuff) that handled this. too bad I've forgotten it.
13:23:59 <Lethalman> Cale, I understand that, which is probably far the best approach in a language like haskell that offers much syntactic sugar for custom stuff
13:24:01 <Cale> Lethalman: Or more recently, there's been work on array structures which automatically parallelise computations over their elements (and where those computations can themselves be parallel, and things will be balanced nicely)
13:24:09 <elliott> I don't see what it has to do with syntax sugar
13:24:37 <Cale> Lethalman: Have you looked at the Nested Data Parallelism stuff?
13:24:49 <applicative> Lethalman: if e.g. the async library was used for a 'MonadZip' instance for IO then we could have 'concurrent syntax' with parallel list comprehension notation
13:24:50 <Lethalman> elliott, in the sense that, it may not be worth implementing it in haskell like it would in be in, say, java :P in terms of LoC
13:24:50 <shachaf> foo :: Phantom Opera -> Phantom a
13:24:55 <Philippa_> shachaf: I think you need a more precise intermediate language to say "I can do it for this constructor" etc though
13:25:15 <Philippa_> shachaf: plus the recursive cases you'd need to tag as "I know this terminates, honest!" and treat it as similarly erasable proof
13:25:23 <applicative> [x ++ y | x <- readFile "a.txt" | y <- readFile "b.txt"] , Lethalman
13:25:26 <Philippa_> so you end up trying to embed a fragment of OTT or something
13:25:54 <Philippa_> (OTT being Altenkirch & McBride's type theory where the notion of equality is effectively "is it the same bit pattern?")
13:26:13 <applicative> ^^^ that would read the files 'concurrently' , something similar is true of 'MonadPar'
13:26:16 <Lethalman> Cale, no don't think so, let me look
13:26:28 <Philippa_> (Observational Type Theory, rather)
13:26:40 <Lethalman> Cale, I'm not a researcher but I like reading papers of that sort... though I understand a minimal percentage of them :P
13:26:49 <Cale> http://www.youtube.com/watch?v=NWSZ4c9yqW8&t=20s
13:27:17 <Lethalman> mh I got some slides
13:27:49 <Cale> 2:26 or so Simon actually starts :)
13:28:41 <Lethalman> think I got the slides here: research.microsoft.com/~simonpj/papers/ndp/ndpslides.pdf‎
13:29:28 * hackagebot shelly 1.3.0.0 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.3.0.0 (GregWeber)
13:29:44 <johnw> yay, shelly releases!
13:29:59 <b2coutts> hmm
13:30:09 <Lethalman> \o/ good, I'm just selling haskell to a friend through shelly for his next shell script :P
13:30:11 <b2coutts> is shelly meant more for writing scripts, or as a shell?
13:30:15 <johnw> scripts
13:30:20 <b2coutts> aw
13:32:25 <Rhainur> I'm trying to solve this problem in haskell: http://projecteuler.net/problem=2
13:32:32 <Rhainur> and while I can do it easily in an imperative language
13:32:39 <testable> i registered with nickname, does it take long to et the email?
13:32:45 <Rhainur> I'm struggling to do it in a way that seems Haskell-y
13:32:52 <Lethalman> Cale, yes, reading through the slides that's exactly what I imagine could be done in a language like haskell
13:33:07 <Lethalman> interesting thanks
13:33:22 <ion> rhainur: Try to define a self-referencing list. You may want to look at zipWith.
13:33:34 <Cale> Lethalman: It's turned out to be *quite* tricky to do well, but it's at the point where you can start to play around with it.
13:33:41 <b2coutts> Rhainur: consider generating an infinite list
13:34:20 <ion> “self-referencing list” was inaccurate. A list whose definition refers to self.
13:34:35 <Rhainur> maybe I'm too new/inexperienced to do that, but the only infinite lists  I've encountered so far was of the [2,4,6..] variety
13:34:43 <Rhainur> I have no idea how to make a self-referencing list
13:34:59 <ion> > let xs = 1:2:xs in xs
13:35:00 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
13:35:19 <ion> > let xs = 1:2:map (*10) xs in xs
13:35:20 <lambdabot>   [1,2,10,20,100,200,1000,2000,10000,20000,100000,200000,1000000,2000000,1000...
13:35:27 <Rhainur> hm
13:35:28 <ion> Is this enough of a hint?
13:35:54 <mapreduce> > fix ("a list whose definition refers to "++) --actually not a self-referencing list, but I couldn't help myself
13:35:57 <lambdabot>   "a list whose definition refers to a list whose definition refers to a list...
13:37:07 <applicative> Rhainur: have you tried to do this problem in Haskell yet?
13:37:28 <Rhainur> applicative: that's what I'm trying right now, and my mind keeps going into "for loop" mode
13:37:36 <Rhainur> or while loop
13:37:37 <Rhainur> w/e
13:37:38 <applicative> Rhainur: it is basically about keeping fibonacci from goig exponential
13:37:44 <applicative> going
13:38:30 <applicative> if you had an infinite sequence of fibonacci numbers 'fibs' how would you write the rest of the program?
13:39:08 <Lethalman> Cale, so is that [: .. :] already in ghc or experimental somewhere?
13:39:22 <applicative> it's in 'data parallel haskell'
13:39:54 <Rhainur> applicative: if I had an infinite sequence, I can do the rest using a list comprehension
13:40:03 <b2coutts> Rhainur: a fun and valuable excersise is to learn how to make infinite lists using recursion
13:40:13 <b2coutts> for example, to make a list of all natural numbers:
13:40:16 <Cale> Lethalman: already in
13:40:22 <Lethalman> \o/
13:40:40 <b2coutts> > let nats = 0:map (+1) nats in nats
13:40:42 <Cale> Lethalman: but it's still experimental
13:40:45 <lambdabot>   mueval-core: Time limit exceeded
13:40:47 <Rhainur> applicative: [ x | x <-infinifibs, x < 4000000, even x ]
13:40:55 <Rhainur> sum that
13:40:59 <applicative> right
13:41:07 <applicative> so you just need infinifibs
13:41:12 <Lethalman> Cale, ghc version?
13:41:14 <Rhainur> yup
13:41:34 <Cale> Lethalman: It's been in since 7.4 or so
13:41:37 <Lethalman> oh
13:41:38 <applicative> Rhainur: but it will be a catastrophe if you define fib n and then do map fib [1...]
13:42:22 <b2coutts> as an interesting side note for PE 2, if you want further optimization, you can generate only the even terms of the fibonacci sequence
13:42:23 <applicative> @type iterate
13:42:23 <lambdabot> (a -> a) -> a -> [a]
13:42:33 <Lethalman> Cale, is it this? http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell or isn't this nested?
13:42:34 <b2coutts> look at the first several even terms of the sequence and see if you can find a pattern
13:42:44 <Cale> Lethalman: that's right
13:43:02 <ion> rhainur: If you had the lists xs = [1,2,…] and ys = [2,…], you can use zipWith (+) to get the list zs = [3,…]. Now, you can define xs in terms of 1, 2 and zs, and you can also define ys based on xs.
13:43:13 <b2coutts> such a solution can also be simpler than generating all fibonacci numbers and filtering for even ones
13:43:18 <Rhainur> oh so that would be tail
13:43:22 <applicative> Rhainur: what would fibstep be if infinibs = iterate fibstep (1,2) -- to start with them
13:43:24 <Rhainur> like
13:43:40 <applicative> Rhainur: what would fibstep be if infinibs = map fst $ iterate fibstep (1,2) -- to start with them
13:43:45 <applicative> rathe
13:43:46 <Rhainur> 1:1:zipWith (+)
13:43:47 <Rhainur> wait
13:44:11 <applicative> the zipWith path is much sexier
13:44:19 <testable> Can I have my register-email resent?
13:44:22 <Rhainur> can I do fibo = 1:1:zipWith (+) fibo tail fibo?
13:44:24 <Rhainur> (tail fibo)
13:44:29 <applicative> right
13:44:31 <ion> rhainur: Bingo
13:44:35 <Rhainur> wat
13:44:38 <applicative> > let  applicative> right
13:44:38 <Rhainur> this language is ridiculous
13:44:40 <lambdabot>   <hint>:1:24:
13:44:40 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
13:45:01 <applicative> > let fibo = 1:1:zipWith (+) fibo  (tail fibo) in take 10 fibo
13:45:02 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
13:45:56 <Cale> Lethalman: there's also non-nested data parallel arrays which are significantly less experimental than the NDP stuff, implemented in the Repa library
13:45:57 <Cale> http://hackage.haskell.org/package/repa http://hackage.haskell.org/package/repa-algorithms
13:46:38 <Lethalman> ok thanks a lot
13:46:51 <Cale> Lethalman: For practical work right now, Repa has a much higher probability of being usable :)
13:46:57 <Lethalman> oh :S
13:47:06 <Rhainur> hmm
13:47:10 <Lethalman> Cale, what about non-nested stuff done with the NDP?
13:47:53 <Rhainur> when I do sum [x | x <- fibs, x < 4000000, even x]
13:47:55 <Cale> Well, you still incur the trickiness of doing the vectorisation transformation whether you make use of the abilities it gives you or not.
13:47:58 <Rhainur> it runs out of memory
13:48:14 <applicative> Rhainur: yes
13:48:22 <Cale> I don't have a lot of experience actually trying to make DPH work, but definitely it's worth a shot
13:48:37 <applicative> x < 1000000 shouldnt be in the comprehension Rhainur it's just testing them forever
13:48:39 <Lethalman> will certainly give it a shot, thanks
13:48:44 <ion> rhainur: Oh, btw, there’s one problem with the list comprehension. x < 4000000 works as a filter that will keep evaluating an infinite list forever. You’ll want takeWhile.
13:48:52 <Rhainur> oh
13:49:05 <applicative> sum $ takeWhile (< 100000) etc
13:49:07 <Cale> There are much more lightweight things you can usually try before DPH, like just replacing some applications of map with parMap from Control.Parallel.Strategies
13:49:19 <Cale> (or similar uses of simple strategies)
13:49:36 <applicative> Rhainur: this feature of list comprehensions if frequently confusing.
13:50:19 <applicative> Rhainur: it thinks 'maybe they'll get below a million at some point in the remote future'
13:50:54 <Rhainur> ah
13:50:54 <applicative> 4 million rather
13:50:55 <Rhainur> I see
13:50:57 <Rhainur> and takewhile just breaks on the first one that is above 4mill
13:50:58 <applicative> exactly
13:51:07 <Rhainur> fair enough
13:51:16 <Rhainur> so use takewhile rather than a predicate to filter infinite lists?
13:51:59 <Philippa_> use takewhile when you're looking to /cut/ the list and not just filter it
13:52:08 <Philippa_> you know the list is ever-increasing
13:52:21 <alpounet> takeWhile will stop adding elements when the predicate isn't satisfied for the first time.
13:52:29 <Philippa_> so you can cut it when the predicate switches
13:59:13 <Lethalman> oh in the NDP slides there's even a recall on stream fusion, which I was going to read :-)
13:59:51 * applicative hadn't known that stream fusion was holding elective office
14:01:08 <Lethalman> ?
14:05:13 <Rhainur> so my naive method of finding prime factors of a number looks like this: primeFactor x = filter (\y -> mod x y == 0) [2..x/2]
14:05:23 <Rhainur> or rather
14:05:24 <Rhainur> factors
14:07:44 <Rhainur> ion, applicative: but it's taking a helluva lot of time to chew on this: http://projecteuler.net/problem=3
14:08:23 <Rhainur> am I missing something
14:08:45 <Rhainur> actually
14:08:45 <Rhainur> yes I am
14:13:56 <S_J> im testable, now registration worked
14:14:03 <S_J> _ is not .!
14:21:46 <u_> i do cabal install alex-3.0.5
14:21:53 <u_> and it says it installs it successfully
14:21:58 <u_> then i do cabal info alex
14:22:08 <u_> and its says Versions installed: [ Unknown ]
14:22:25 <u_> then cabal install yi
14:22:30 <u_> (what i was originally trying to do)
14:22:33 <u_> says
14:22:50 <u_> cabal: The program alex version >=3.0.3 && <=3.0.5 is required but the version found at /usr/bin/alex is version 3.0.1
14:22:52 <u_> wtf
14:23:16 <applicative> right, u_ the alex you just installed is in $HOME/.cabal/bin
14:23:39 <u_> how do i make it look there instead?
14:23:42 <applicative> u_: so you need to get that to be the one that's in path
14:24:30 * hackagebot apelsin 1.2.3 - Server and community browser for the game Tremulous  http://hackage.haskell.org/package/apelsin-1.2.3 (ChristofferOjeling)
14:24:55 <applicative> what os are you using, you just need to adjust the path or make /usr/bin/alex point to $HOME/.cabal/bin/alex
14:25:05 <u_> ah ok
14:25:53 <bingsaw> for applicative functions, why is 'pure' called 'pure' ?
14:26:13 <applicative> if in bashrc or .profile $HOME/.cabal/bin is ahead of /usr/bin,that would work; I don't know if that's best though, u_
14:26:47 <dropdrive> Hi.  As an exercise, I'm writing code that analyzes inventory changes.  So I have things like: soldOn :: Date -> IntMap Int -- which tells me how much of an item (identified by an int) was sold.  This is all loaded from CSV files.  Now I want to do calculations like: do we sell more on Fridays?  But it strikes me that "adding" two IntMap Ints is kind of slow (repeated lookups).  Am I using the right data structure?
14:27:16 <bingsaw> applicative functors*
14:27:18 <u_> applicative: linking works, thanks
14:28:26 <u_> now watch as it breaks on something else...
14:28:44 <applicative> bingsaw: if you think of the functor as 'having effects' then pure x never does.
14:28:45 <u_> actually watching makes me nervous, im gonna minimize it until i hear my hard drive stop churning
14:29:39 <applicative> bingsaw: thus getLine :: IO String has effects , but pure "Hi":: IO String doesnt
14:30:21 <applicative> bingsaw: if lists represent 'indeterminism', then [1,4,3] :: [Int] is an indeterminate Int; pure 1 :: [Int] is [1
14:30:28 <applicative> [1] and thus determinate
14:30:40 <u_> oh it worked
14:30:41 <u_> huh
14:31:49 <roconnor> bingsaw: also for historical reasons they couldn't reuse the name 'return'.
14:32:04 <roconnor> ... not that 'return' is a particularly good name to begin with.
14:32:23 <u_> oh my lord it actually works
14:32:26 <u_> im so surprised
14:32:41 <joelteon> return is a lousy name
14:33:18 <mapreduce> http://hpaste.org/90477 - I don't understand the compiler's non-exhaustiveness warnings, nor why this function (consolidateTwo) is not exhaustive.  Any ideas?
14:33:25 <S_J> what would be a better name than return?
14:33:36 <roconnor> S_J: pure is a better name ;)
14:33:39 <hpc> how about return'?
14:33:40 <hpc> ;)
14:33:41 <applicative> pure
14:33:43 <S_J> > Just 5 >>= \r -> (+1) . return
14:33:44 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b0'
14:33:44 <lambdabot>              with actual...
14:33:54 <mm_freak> dropdrive: no, that's fine
14:33:55 <roconnor> maybe not a great name, but a better one
14:33:55 <S_J> > Just 5 >>= \r -> return . (+1)
14:33:56 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b0'
14:33:57 <lambdabot>              with actual...
14:33:59 <bingsaw> roconnor: yeah that's what i was thinking, it looks exactl the same as 'return'
14:34:06 <mapreduce> For a start, most of the compiler's warning lines are identical, but more confusingly they never cover my second parameter.
14:34:07 <S_J> > Just 5 >>= return . (+1)
14:34:08 <lambdabot>   Just 6
14:34:09 <bingsaw> roconnor: so why not just use 'return' ? why define a new thing that does the same thing?
14:34:10 <mm_freak> dropdrive: Im.unionWith (+)
14:34:20 <dropdrive> bingsaw: Was "applicative" directed at me?
14:34:27 <joelteon> mapreduce: it could be that some of them do
14:34:28 <bingsaw> huh?
14:34:30 <FreeFull> > fmap (+1) (Just 5)
14:34:32 <lambdabot>   Just 6
14:34:37 <S_J> why pure?
14:34:42 <mm_freak> (assuming: import qualified Data.IntMap as Im)
14:34:44 <Peaker> I use: class (Monad m, Applicative m) => MonadA m ; instance (Monad m, Applicative m) => MonadA m
14:34:47 <roconnor> bingsaw: because you cannot invent Applicative and then stick it above Monad in the heirarchy in Haskell.
14:34:51 <S_J> @type (>>=)
14:34:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:34:52 <mapreduce> joelteon: I don't follow.
14:34:54 <roconnor> bingsaw: it is a deficency of the Haskell langauge.
14:34:54 <Peaker> And then use a MonadA constraint rather than Monad everywhere, so I can use pure
14:35:00 <FreeFull> @type (join . fmap)
14:35:01 <lambdabot>     Occurs check: cannot construct the infinite type: f0 = (->) (f0 a0)
14:35:01 <lambdabot>     Expected type: (a0 -> b0) -> f0 a0 -> f0 a0 -> b0
14:35:01 <lambdabot>       Actual type: (a0 -> b0) -> f0 a0 -> f0 b0
14:35:08 <mm_freak> dropdrive: no, that was not directed at you, but my answers are =)
14:35:14 <bingsaw> roconnor: but it is the same as 'return' right?
14:35:15 <FreeFull> @type (join . fmap (+1))
14:35:16 <lambdabot> (Monad m, Functor m, Num (m a)) => m (m a) -> m a
14:35:39 <mm_freak> dropdrive: someone here actually has the nickname "applicative" =)
14:35:43 <joelteon> mapreduce: it looks like a GHC bug to me, actually
14:35:43 <roconnor> bingsaw: for Applicatives that are monads, return is the same as pure.
14:35:45 <FreeFull> @type (\f -> join . fmap f)
14:35:45 <lambdabot> (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
14:35:47 <Peaker> bingsaw, "pure" is the same thing as "return" only when both are defined.  It is different when "pure" is defined and "return" isn't
14:35:56 <bingsaw> roconnor: man this stuff is so confusing
14:35:58 <dropdrive> mm_freak: Ah, you're saying that Im.unionWith is very fast.
14:36:00 <S_J> > let f x = return (x+1) in Left 5 >>= f
14:36:01 <lambdabot>   Left 5
14:36:10 <joelteon> mapreduce: also, what I meant was that maybe some of those patterns are for either the first or second argument
14:36:13 <roconnor> bingsaw: well, not every Applicative is a Monad.
14:36:15 <joelteon> and it's just not telling you that
14:36:18 <S_J> > let f x = return (x+1) in Right 5 >>= f
14:36:18 <lambdabot>   Right 6
14:36:19 <mapreduce> joelteon: I see.
14:36:20 <applikativ> bingsaw: sometimes Applicative can be defined but Monad cant
14:36:31 <mm_freak> dropdrive: i think it's even linear for IntMap
14:36:31 <bingsaw> applikativ: ah ok
14:36:38 <Peaker> mapreduce, it's telling you why it's not comprehensive
14:36:44 <FreeFull> > fmap (+1) (Left 5)
14:36:45 <lambdabot>   Left 5
14:36:45 <Peaker> mapreduce, exhaustive*
14:36:48 <applikativ> bingsaw: sometimes both can, but Applicative in two ways, then the standard rules require pure = return
14:36:57 <FreeFull> > fmap (+1) (Left "Moo")
14:36:57 <lambdabot>   Left "Moo"
14:37:01 <bingsaw> roconnor: are there any other type classes that have their own analogs of pure/return but give it another name too?
14:37:05 <joelteon> mapreduce: but I don't know, I've never done something that complicated involving pattern matching, so I'd file a bug
14:37:12 <dropdrive> mm_freak: What alternatives to IntMap do I have if my data is indexed by, say, an enumeration and two integers?
14:37:21 <applikativ> Pointed !
14:37:23 <mm_freak> dropdrive: Map
14:37:38 <roconnor> bingsaw: the only thing that comes to mind is the "Default" class, of where there are a few implementations, mostly unused.
14:37:50 <roconnor> er right
14:37:56 <dropdrive> mm_freak: But that's not as speedy as IntMap, correct?
14:37:56 <roconnor> s/Default/Pointed
14:38:02 <mapreduce> joelteon: I'd also like to try to make it less complicated.  Most of those lines are duplicated because basically there are 4 things that could be empty lists or not.
14:38:03 <applikativ> I invented a new Pointed today, where point :: a -> f a; pmap :: (a -> b) -> f a -> f b
14:38:06 <roconnor> Default is something else.
14:38:24 <dropdrive> mm_freak: Are there standard ways of "prealigning" my data so that (+) just becomes array addition?
14:38:27 <mm_freak> dropdrive: correct…  there is also HashMap
14:38:29 <applikativ> it occured to me all the objections to pointed presuppose fmap
14:38:48 <Peaker> mapreduce, the warning is only showing the first pattern apparently
14:38:50 <FreeFull> applikativ: Pointed is between Functor and Applicative?
14:38:51 <dropdrive> mm_freak: Sort of, "secretly prealigning my data so (+) is just array addition when possible"
14:38:56 <mm_freak> dropdrive: no, because (+) comes along with Num, which also needs fromInteger
14:39:03 <Peaker> mapreduce, if you replace that with a "case" on a tuple of 2 in the function body
14:39:07 <Peaker> mapreduce, you'll get a better warning
14:39:16 <applikativ> but if pmap has the laws pmap f . pmap g = pmap (f . g) and pmap f . point = point . f then
14:39:20 <bingsaw> applikativ: now that monad is being made a subclass of applicative, does that mean that it's best to use 'pure' instead of 'return' from now on?
14:39:30 <applikativ> a lot of GADTs that dont have Functor instances have Pointed instances
14:39:32 <mapreduce> Peaker: How about if I get rid of the tuples and just have four parameters?
14:39:36 <roconnor> bingsaw: now we enter the phase of #haskell where we circle around the merits and demerits of the Pointed class.
14:39:40 <mapreduce> is that likely to help?
14:39:47 <FreeFull> applikativ: I'm thinking your Pointed is just a Functor + pure
14:39:58 <Peaker> mapreduce, I think the tuples are nice - they show the grouping
14:40:01 <FreeFull> So you don't need that pmap
14:40:05 <applikativ> FreeFull: no, it lacks the law pmap id = id
14:40:08 <Peaker> mapreduce, but you can do:  foo x y = case (x, y) of ...
14:40:12 <mm_freak> dropdrive: however, the usual way is to wrap your values by an applicative functor
14:40:13 <FreeFull> applikativ: Oh, you're right
14:40:14 <applikativ> this is what GADTs always lack
14:40:22 <Peaker> mapreduce, and then just put all your matches as cases, with tuple syntax
14:40:25 <mm_freak> in which case "+" is just "liftA2 (+)"
14:40:40 <dropdrive> mm_freak: Do you have an example?  I'm kind of green.
14:40:41 <Peaker> mapreduce, then the warning should improve
14:40:51 <FreeFull> I wonder if   pmap f . pmap g = pmap (f . g)  could imply the id law though
14:40:51 <mapreduce> Peaker: Ok, that makes sense and will help with the warning.  How about getting rid of my duplicates?
14:40:56 <FreeFull> What if both f and g are id?
14:41:07 <Peaker> mapreduce, this is pretty hard to read, hard to see the duplicates
14:41:26 <applikativ> FreeFull: pmap id . pmap id = pmap id should hold
14:41:35 <FreeFull> Actually, nevermind
14:41:35 <mapreduce> If you see minimum == nuk, for instance, all the lines that begin with that will be either duplicates or close enough.
14:41:52 <mapreduce> I.e., if they're not duplicates I can make them so without breaking anything.
14:41:58 <applikativ> say the GADT is data I a where Int :: I Int; Any :: a -> I a
14:41:59 <bingsaw> roconnor: can i ask you a slightly unrelated qeustion? are 'promises' monads?
14:42:02 <Peaker> mapreduce, if you use lens you can improve all those "let"s
14:42:09 <applikativ> say the GADT is data I a where Int :: Int -> I Int; Any :: a -> I a
14:42:12 <applikativ> rather
14:42:16 <roconnor> bingsaw: I don't know much about Promises, but I think the answer is yes.
14:42:32 <mapreduce> Peaker: Ok, thank you.
14:42:42 <applikativ> Imaginary is not a monad
14:42:44 * Philippa_ doesn't like pure as a name that much
14:42:45 <Peaker> mapreduce, let (nextDeletes, Upserts nextUpserts) =  ... in (nextDeletes, Upserts ((nuk, nuv):nextUpserts))      becomes:  ... & _2 . upserts %~ ((nuk,nuv):)
14:42:48 <bingsaw> roconnor: i thought they were, but i got confused since promises effecitvely have two bind functions dont they? the error bind and the success bind function
14:42:49 <mm_freak> dropdrive: example: data Vector3 a = Vector3 a a a
14:42:58 <roconnor> bingsaw: the easiest way to spot a monad is to look for a join funciton of time Promise (Promise a) -> Promise a.
14:43:02 <Peaker> mapreduce, do you know the lens library?
14:43:05 <roconnor> *of type
14:43:11 <mapreduce> Peaker: I know of its existence.  I haven't used it.
14:43:12 <mm_freak> Vector3 is an applicative functor, which allows you to distribute operations over the entire structure
14:43:15 <Philippa_> sometimes useful, but
14:43:19 <Philippa_> saves two chars? :p
14:43:34 <Peaker> mapreduce, do you follow the simplification above?
14:43:58 <mapreduce> I believe so.
14:44:19 <Peaker> mapreduce, I think you should do that, and then more, until this code becomes more sane :)
14:44:35 <Peaker> this code is way too gzip'able
14:44:42 <applikativ> FreeFull: data I a where Int :: Int -> I Int; Any :: a -> I a lacks a Functor instance but has a pmap and point
14:45:10 <mapreduce> I want to find a way of not repeating that.  You've helped me to make it smaller, but it's still repeated. :)
14:45:47 <FreeFull> applikativ: Because of pmap id?
14:45:49 <Peaker> mapreduce, well, each of the "let"s will have much less repetition inside it, and it will expose new DRY opportunities
14:45:50 <applikativ> FreeFull: yes, this happens all the time with GADTs
14:45:52 <Peaker> mapreduce, easier to work with and improve smaller code than larger code
14:45:53 <bingsaw> applikativ: what about you?  are promises monads? :)
14:45:56 <applikativ> fmap id = id fails
14:46:25 <FreeFull> What do you get when you do  pmap id (Int 3)
14:46:34 <FreeFull> vs    pmap id (Any 'a')
14:46:53 <applikativ> pmap id (Int 3) = Any 3
14:47:04 <hpc> applikativ: you can't even do that
14:47:16 <applikativ> FreeFull: but point x = Any x
14:47:46 <hpc> applikativ: suppose, pmap (don't know if id or cycle) (Any [1,2,3])
14:47:48 <applikativ> then the laws stated above work out, FreeFull , or so it seems
14:48:10 <FreeFull> I'm not used to gadts, why is   pmap id (Int 3) = Any 3 rather than Int 3?
14:48:11 <S_J> Name an advantage of Java over Haskell. Only the language, not libraries and popularity etc.
14:48:21 <applikativ> pmap f (Any x) = Any (f x) ; pmap f (Int n) = Any (f n)
14:48:29 <Peaker> S_J, more control over memory allocation
14:48:33 <hpc> > "Haskell" > "Java" -- S_J
14:48:34 <lambdabot>   False
14:48:37 <FreeFull> Oooh, I see
14:48:39 <hpc> you heard it here first!
14:48:40 <FreeFull> Because of the type of f
14:48:45 <applikativ> yeah
14:48:47 <Peaker> S_J, more predictable performance
14:49:00 <neutrino> > "GHC" > "JVM"
14:49:00 <lambdabot>   False
14:49:02 <neutrino> :(
14:49:21 <Taneb> > "Haskell" > "C++"
14:49:21 <lambdabot>   True
14:49:24 <Peaker> S_J, Simpler type system which makes it easier to implement, and possibly easier to first learn (not sure about that)
14:49:28 <FreeFull> I'm interested in, what error do you get when you try to make it   Int (f n)   anyway?
14:49:55 <FreeFull> > "" > ""
14:49:56 <lambdabot>   False
14:50:13 <applikativ> FreeFull: I dont know if it would be much use, but the usual objection to Pointed presupposes that there is an fmap, which there neednt be
14:50:20 <FreeFull> > False > False > False > False
14:50:21 <lambdabot>   Precedence parsing error
14:50:21 <lambdabot>      cannot mix `GHC.Classes.>' [infix 4] and `GHC...
14:50:49 <FreeFull> applikativ: Are you going to make a library then?
14:51:50 <applikativ> FreeFull: the error is Could not deduce (b ~ Int)  from the context (a ~ Int)
14:51:51 <Peaker> I am not sure Pointed is useful (I think it is), but I don't see the downside of having a few extra classes in the hierarchy
14:52:13 <hpc> Peaker: it's useful as a "this type has a function of this type"
14:52:16 <Peaker> and the downside of not having them is that it is far harder to fix later on
14:52:24 <hpc> Peaker: but it has no laws
14:52:48 <Peaker> hpc, the lawlessness assumes no interaction between different classes
14:52:48 <applikativ> hpc sure if its accompanied  by a pmap method
14:53:00 <Peaker> hpc, it can have laws relating it to a Functor/Applicative instance
14:53:06 <Peaker> hpc, (but only if they exist)
14:53:08 <hpc> Peaker: the only law it had was related to Functor
14:53:15 <hpc> Peaker: and that law was later found a free theorem
14:53:23 <Peaker> hpc, great, what's wrong with a free theorem law?
14:53:30 <FreeFull> applikativ: I'm thinking, if there is a Pointed, then there is also something that has pmap but not point
14:53:35 <Peaker> hpc, the utility of a class is not dependent on there being non-free-theorem laws
14:53:41 <hpc> Peaker: it's a useless law
14:53:46 <applikativ> hpc it just needs its own pmap method; then the free theorem argument goes ojut the window
14:53:59 <hpc> Peaker: it is true by construction of having a valid fmap and literally any definition of point
14:53:59 <Peaker> hpc, no, you know what Pointed does when combined with fmap, regardless of the source of the law
14:54:09 <Peaker> hpc, and you can compose code that uses pointed with code that uses applicative
14:54:34 <hpc> Peaker: it's useless in the sense that specifying a law about liftM2 is useless
14:54:44 <Peaker> you get the law for free
14:55:01 <Peaker> but it's still a law, it still makes use of Pointed useful
14:55:08 <hpc> it's a vacuous law
14:55:13 <hpc> like...
14:55:24 <Peaker> hpc, If I write code that uses Pointed but not Applicative, my code has tighter constraints, making it easier to know what it cannot do
14:55:30 <hpc> :t undefined :: (Ord a, Eq a) => a -- (Eq a) here is a vacuous constraint
14:55:31 <lambdabot> Ord a => a
14:55:35 <hpc> Peaker: it's like that
14:56:04 <Peaker> hpc, if I have a   LensLike f     where    Pointed f     then I know it's an affine traversal
14:56:05 <FreeFull> hpc: what about Pointed as applikativ defined it?
14:56:06 <Peaker> hpc, and I can combine it with other traversals
14:56:11 <Peaker> hpc, This is useful stuff
14:56:30 <Peaker> hpc, The constraint on my code being "Pointed" rather than "Applicative" tells me useful things
14:56:40 <hpc> i am not arguing with that
14:56:41 <hpc> i am arguing with the LAW ONLY
14:56:41 <Peaker> hpc, so why deprive me of this usefulness?
14:56:53 <hpc> i never said it was useless
14:56:56 <hpc> i said it has no laws
14:57:15 <Peaker> <hpc> Peaker: it's useful as a "this type has a function of this type"  <-- this implies it's not useful,  but in fact, it tells me more than just "it has a function of this type"
14:57:27 <Peaker> it tells me that *if* there's also an Applicative instance, it will behave a certain way
14:57:36 <hpc> "it's useful" implies "it's not useful" -- i am confused
14:57:36 <FreeFull> pmap f (point x) = point (f x)   is a free law?
14:57:49 <Peaker> hpc, it's as useful as "something not useful"
14:58:26 <applikativ> FreeFull: no, it's not a free theorem, it's a law associated with a possible class, which shows hpc's argument to be no good
14:58:34 <Peaker> hpc, also, it tells me what the code can or cannot do on any type I give it
14:59:09 <dolio> So, it gives you a rule that is useless for the code you're writing that doesn't use Applicative?
14:59:12 <hpc> applikativ: and if that class ever gets off the ground, we can add the law
14:59:26 <hpc> contrary to the math it comes from, type classes can change
14:59:34 <hpc> see: MonadPlus and its contradictory set of laws
14:59:56 <hpc> this is silly
15:00:20 <Peaker> having too many type-classes is a smaller problem than too few
15:00:22 <S_J> is the haskell torrent programs any good?
15:00:24 <applikativ> no, the receive argument is straightforwardly sophistical, not that I favor Pointed
15:01:07 * roconnor wants Pointed so he can write partial lenses in van Laarhoven style.
15:04:29 <Peaker> roconnor, Affine traversals?
15:04:37 <Peaker> roconnor, 0/1 traversals
15:05:03 <roconnor> Peaker: yes, also know an affine traversals
15:05:09 <roconnor> *known
15:05:14 <applikativ> in the Alternative class, it just says empty and <|> must be Monoid, does this entail that empty is a 'zero' for <*> ?
15:05:27 <Peaker> Who's "van Laarhoven"? How did traversal-lens get that name?
15:05:39 <mapreduce> S_J: @hoogle [a] -> a -> a
15:05:40 <mapreduce> whoops
15:05:41 <mapreduce> @hoogle [a] -> a -> a
15:05:42 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
15:05:42 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
15:05:42 <lambdabot> Prelude (!!) :: [a] -> Int -> a
15:05:48 <applikativ> Peaker: the lens library is van Laarhoven lense
15:05:50 <roconnor> Peaker: I named it that way because I read about the represenation in Twan van Laarhoven's blog
15:05:50 <applikativ> s
15:06:01 <Xunie_> > -0/1
15:06:03 <lambdabot>   -0.0
15:06:06 <Xunie_> > 0/1
15:06:07 <lambdabot>   0.0
15:06:10 <mapreduce> ! intersperse 3 []
15:06:18 <mapreduce> > intersperse 3 []
15:06:19 <lambdabot>   []
15:06:31 <Xunie_> Alright, wati, I've been up for too long:
15:06:36 <Xunie_> > 1/0
15:06:37 <lambdabot>   Infinity
15:06:40 <Xunie_> > (-1)/0
15:06:41 <lambdabot>   -Infinity
15:06:45 <Xunie_> Honestly, is that... correct?
15:06:46 <mapreduce> Those hoogle results didn't seem to match my query.
15:06:48 <twanvl> Peaker: It's all Russell's fault!
15:07:03 <roconnor> If someone points me to an earlier use/understaning of the representation I'll rename :)
15:07:29 <dolio> Xunie_: What's wrong with it?
15:08:25 <geekosaur> Xunie_, it's as specified by IEEE floating point. haskell doesn't really get to choose there
15:08:57 <elliott> Peaker: twanvl
15:08:58 <Peaker> twanvl, you have a big-sounding name :)
15:08:58 <Xunie_> Well. I just thought that divison by zero should always be undefined, but I guess if the IEEE says so... :3
15:09:09 <Xunie_> > 0/0
15:09:10 <lambdabot>   NaN
15:09:14 <Xunie_> Well then.
15:09:21 <elliott> twanvl is a proto-lens theorist, worked out all this stuff years before us newbies :P
15:09:23 <roconnor> twanvl: I also enjoy beginning sentences with a lower case letter.
15:09:57 <Peaker> Xunie_, if you consider that floating point numbers can become 0 because of approximations/errors rather than the right value, that makes some sense
15:10:24 <jfischoff> roconnor: what do partial lenses give us that Prisms don't?
15:10:47 <shachaf> jfischoff: Lots of things are partial lenses but not prisms.
15:10:51 <shachaf> (Every prism is a partial lens.)
15:11:03 * jfischoff nods
15:11:27 <jfischoff> what laws do partial lenses have?
15:11:28 <roconnor> jfischoff: a lens witnesses an isomorphism A ~ exists r. (r,B)
15:11:39 <roconnor> jfischoff: a prism witnesses an isomorphism A ~ exists r. Either r B
15:12:04 <roconnor> jfischoff: a partial lens witnesses an isomorphism A ~ exists r. exists s. Either r (s,B)
15:12:41 <ion> prism also watches us
15:12:50 <roconnor> jfischoff: the laws for lenses, prisms, partial lenses, and traversals are all identical in the van Laarhoven representation.
15:12:50 <jfischoff> hmm it seems like that algebra could keep going
15:13:01 <elliott> roconnor: that isomorphism is not quite right I think
15:13:09 <elliott> in fact none of them are
15:13:15 <elliott> it's exists r. (A ~ (r,B))
15:13:23 <elliott> you can't just plug in () for r when going back to A
15:13:26 <Clint> odd
15:13:30 <roconnor> elliott: ah right.
15:13:37 <roconnor> Good thing I haven't made my slides yet.
15:13:50 <roconnor> jfischoff: float all thoses exists outside.
15:13:58 <elliott> btw, if you figure out a nice existential expression of traversals, let me know
15:14:06 <elliott> all my attempts have involved pairing it with some "length" function
15:14:37 <roconnor> elliott: exists (f:Finitary Container). A ~ f B
15:14:54 <elliott> roconnor: pah, I guess
15:15:01 <roconnor> not all that nice
15:15:09 <shachaf> What about infinite traversals?!
15:15:10 <dolio> Except the finitary part is wrong. :)
15:15:21 <roconnor> shachaf: those are kinda sort of illegalish
15:16:02 <roconnor> shachaf: In that I have a proof.
15:16:06 <shachaf> In Coq.
15:16:09 <roconnor> yes
15:16:21 <dolio> A proof that your specification is wrong. :)
15:16:23 <roconnor> but in Haskell, Finitary Containers can arguably be infinite.
15:16:36 <twanvl> what is so bad about  exists r. A ~ (r, (n : Nat), Vec B n) ?
15:16:38 <mapreduce> How can I get the minimum value of the heads of four lists?
15:16:39 <roconnor> in the same way that Natural Numbers can be infinite
15:16:52 <mapreduce> Bearing in mind that each could be empty.
15:17:15 <roconnor> twanvl: is that a Pi?  That looks incorrect.
15:17:25 <mapreduce> I already have a case handling what happens when all of them are empty, so there is no error case.
15:17:27 <twanvl> roconnor: that's a Sigma
15:17:50 <mauke> > minimum . head . transpose $ ["foo", "bar", "", "x"]
15:17:51 <lambdabot>   'b'
15:17:58 <roconnor> twanvl: That is also incorrect I believe.
15:18:05 <mapreduce> :t transpose
15:18:05 <lambdabot> [[a]] -> [[a]]
15:18:16 <twanvl> so  exists r. A ~ (exists n. (r, Vec B n))
15:18:20 <mapreduce> > transpose ["foo", "bar", "", "x"]
15:18:21 <lambdabot>   ["fbx","oa","or"]
15:18:23 <roconnor> twanvl: if it were true you could update the length of a traversal, but you cannot.
15:18:30 <twanvl> right
15:18:31 <mauke> > minimum . head . transpose $ ["foo", repeat 'b', "", "x"]
15:18:32 <lambdabot>   'b'
15:18:34 <mapreduce> rows to columns, nice
15:19:02 <twanvl> so it should be  exists r. A ~ (exists n. (r n, Vec B n))
15:19:05 <dolio> Actually, that brings up another question....
15:19:39 <dolio> Should we have a precursor of Applicative that carves out the types for which infinite traversals work?
15:19:52 <dolio> Since lens is dictating the structure of base?
15:19:55 <shachaf> Someone should update https://github.com/ekmett/lens/wiki/Types to match the modern lens world.
15:20:16 <twanvl> dolio: interesting question. What would it look like?
15:20:27 <dolio> It would be identical to Applicative, with fewer instances.
15:21:55 <dolio> Actually, it's not a precursor, it's a subclass.
15:22:08 <elliott> isn't it technically Applicative
15:22:14 <elliott> depending on how strictly you read the laws
15:23:10 * wavewave say hi to everyone!
15:23:38 <shachaf> hi wavewave
15:23:40 <roconnor> twanvl: That might be correct and equivalent to a finitary container representation.
15:23:47 <wavewave> shachaf: hi!
15:23:52 <roconnor> twanvl: it is an interesting way to present finitary containers.
15:24:05 <wavewave> shachaf: i am now in berkeley.
15:24:28 <dolio> roconnor: Seems pretty species-y.
15:25:50 <wavewave> shachaf: are you in bay area?
15:25:53 <shachaf> wavewave: Oh, welcome to CA! Did you move here or are you just visiting?
15:25:56 <shachaf> wavewave: Yep.
15:26:25 <wavewave> shachaf: just for work. I am now in LBL. untill 7/3
15:26:37 <wavewave> visit.
15:27:39 <roconnor> twanvl, dolio, it would seem that finitary containers are the closure of (X,) and (Either Y) under composition for aribtrary X and Y.  Does this sound true?
15:29:06 <dolio> What about unordered things?
15:29:08 <roconnor> no that isn't right
15:29:10 <roconnor> nevermind
15:29:37 <roconnor> dolio: finitary containers / traversals are ordered by definition.
15:29:59 <roconnor> if we had commutative applicative functors ...
15:30:02 <joelteon> so GHC reproduces asexually?
15:30:06 <dolio> Ah.
15:31:43 <twanvl_> some infinite containers might also be ordered
15:32:03 <hpc> joelteon: it absorbs features from other compilers and leaves the uninteresting parts to die of age
15:32:15 <joelteon> nice
15:32:17 <joelteon> so it's...borg
15:34:22 <pozorvlak> your individuality will be added to the optimiser
15:34:27 <pozorvlak> resistance is futile
15:35:20 <nexx> lol
15:35:58 <joelteon> speaking of which, it seems like people {-# INLINE #-} pretty much everything they put in libraries
15:35:58 <joelteon> what's up with that
15:36:03 <pozorvlak> is there a way of getting cabal to time-out and/or retry failed downloads?
15:36:08 <pozorvlak> Currently it seems to hang forever until I kill it
15:36:59 <pozorvlak> as in, they mark every export as "to be inlined"?
15:37:15 <pozorvlak> that sounds... contrary to the whole point of separate compilation
15:37:28 <hpc> clearly they think they are writing python
15:37:31 <joelteon> I guess
15:37:42 <hpc> where function calls take hundreds of cycles to move a stack frame
15:37:59 <joelteon> i dunno
15:38:16 <acowley> It allows for type specialization at the call-site
15:38:17 <joelteon> it seems like one of those things where you'd say "well, it can't hurt, and sometimes 'inlining' improves performance, so hell, I'll do it"
15:38:23 <joelteon> oh or that
15:38:28 <acowley> It makes a huge difference
15:38:30 <pozorvlak> inlining *can* be a win in C-level languages
15:38:48 <acowley> It can also make things worse, so it's not a gimme either way
15:39:05 <pozorvlak> you tradeoff icache pressure against function-call overhead
15:39:06 <acowley> But the ability to lose typeclass dictionary passing can't be ignored
15:39:15 <acowley> You also need it to get RULES to fire
15:39:26 <pozorvlak> acowley, oh, sure
15:39:41 <acowley> pozorvlak: Yes, that's when it goes bad. When everything's working out you end up with smaller generated code.
15:40:59 <pozorvlak> acowley, ah, interesting. I generally assume inlining => larger code size
15:41:03 <pozorvlak> but if you get lucky with optimisations that may not be the case
15:41:49 <pozorvlak> allowing RULES is a pretty big win, AIUI
15:56:00 --- mode: ChanServ set +o johnw
15:56:03 --- topic: set to 'For discussion of the Haskell language, its implementations and their libraries. Visit http://haskell.org for more information and downloads. Paste code/errors to http://hpaste.org/new/haskell. Channel logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D. Contact #haskell-ops if you have administrative issues. If Hackage is down, try: http://hdiff.luite.com.' by johnw
15:56:14 <dolio> It's not just type-class specialization.
15:56:21 <dolio> It's _value_ specialization.
15:56:22 <joelteon> why the big topic change
15:56:25 <johnw> it's time
15:56:27 <dolio> And there's no other way to get it.
15:56:45 --- topic: set to 'For discussion of the Haskell language, its implementations and their libraries. Visit http://haskell.org for more information and downloads. Paste code/errors to http://hpaste.org/new/haskell. Channel logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D. Contact #haskell-ops if you have administrative issues. If Hackage is down, try: http://hdiff.luite.com' by johnw
15:56:52 <mauke> a bit verbose
15:57:28 <dolio> Inlining foldl' lets GHC specialize the loop to the reduction function, which may result in a completely unboxed loop.
15:57:44 <dolio> Whereas if you don't inline, it has to allocate on every iteration.
15:58:19 <johnw> mauke: it has grown by 50 characters
15:58:41 <elliott> well, it was already long.
15:58:48 <johnw> scratch that, 19
15:59:13 <johnw> once I have the new guidelines page written, I will shorten the topic by referring to it for everything but the essentials
16:00:07 <mauke> Haskell - language, implementations, libraries | http://haskell.org/ | Paste code/errors: http://hpaste.org/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com
16:00:16 <johnw> nice
16:00:30 <elliott> the "language, implementations, libraries" part can probably jsut go.
16:00:50 --- topic: set to 'Haskell - language, implementations, libraries | http://haskell.org/ | Paste code/errors: http://hpaste.org/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com' by johnw
16:00:53 <johnw> thanks, mauke
16:00:53 <wahwah> what is the <*> function called? and the <$>
16:01:01 <wahwah> for applicatives
16:01:05 <Cale> wahwah: <*> and <$> respectively
16:01:12 <wahwah> Cale: how do i pronounce them i mean? :P
16:01:12 <Cale> ;)
16:01:13 <ion> wahwah: ap, (f)map
16:01:13 <monochrom> you can say "ap" and "fmap", respectively
16:01:15 <wahwah> say im talking to a fren
16:01:23 <wahwah> ah
16:01:25 <wahwah> thanks
16:01:35 --- topic: set to 'Haskell - language, implementations, libraries | http://haskell.org/ | Paste code/errors: http://hpaste.org/new/haskell | Logs: http://j.mp/19DchhQ | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com' by johnw
16:01:48 <kryft> Most of my friends go away when I start talking about <*> or <$>, no matter what I call them :(
16:02:00 <monochrom> but use a blackboard or whiteboard
16:02:09 <elliott> I really don't like using a URL shortener in the topic.
16:02:26 <ion> johnw++ – that ["topic", "style"] was a bit corny. :-P
16:02:40 <johnw> ion: I think it existing for a technical reason at one point
16:02:43 <johnw> existed
16:02:52 <Cale> ion: The reason for it was just that lambdabot has stuff for manipulating topics in list syntax
16:02:55 <hpc> lambdabot could push and pop from the topic
16:03:03 <mauke> Logs: http://5z8.info/hitler_beyk
16:03:08 <ion> And the kluges with spaces to keep URLs clickable even with the dumbest clients were hairy.
16:03:12 <monochrom> onoes
16:03:19 <mauke> or not
16:03:24 <elliott> johnw: can we re-expand the URL? the "language, implementations, libraries" part could be dropped to make space, it's mostly fluff anyway.
16:03:27 <shachaf> lambdabot can't change the topic because lambdabot is not an op.
16:03:41 <johnw> elliott: why expand it?  is there value to knowing the original URL?
16:03:59 <shachaf> Yes, URL shorteners should be avoided because you don't know where they lead and they track you.
16:04:04 <elliott> johnw: why should we rely on another for-profit corporation for our log URL to work?
16:04:22 <elliott> why should we give them information about everyone who wants to look at the logs? why should we hide where our logs are from people looking at the topic? and for what gain?
16:04:32 --- topic: set to 'http://haskell.org/ | Paste code/errors: http://hpaste.org/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/ | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com' by johnw
16:04:51 <johnw> I think that's the essence
16:04:55 <lcfrs> Hi, can I get help with deriving a binary instance for data Foo = Foo using GHC Generic? See http://hpaste.org/90479.
16:05:10 --- topic: set to 'http://haskell.org | Paste code/errors: http://hpaste.org/new/haskell | Logs: http://tunes.org/~nef/logs/haskell | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com' by johnw
16:05:12 <elliott> ?C=M;O=D back in the log URL please? it makes it much more usable since the usual use-case is looking at the past day or so :)
16:05:12 <lambdabot> Unknown command, try @list
16:05:34 <johnw> elliott: just to make you happy :)
16:05:44 --- topic: set to 'http://haskell.org | Paste code/errors: http://hpaste.org/new/haskell | Logs: http://tunes.org/~nef/logs/haskell?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com' by johnw
16:06:07 <ion> elliott: The default sorting could be configured on the server.
16:06:17 <elliott> ion: as if anyone maintains clog.
16:06:18 <johnw> all that missing now is the "Channel guidelines" section, which will be rectified shortly
16:06:22 <lpsmith> jlouis, well I've kinda been emulating some OTP-like design patterns in Haskell for some of my projects
16:06:29 <monochrom> thanks johnw
16:06:36 <pnielsen> I know it's been on r/haskell, and probably linked in here a few times, but this is incredibly awesome: http://weblog.luite.com/wordpress/?p=14 -- good work luite
16:07:00 <lpsmith> But supervision leaves a lot to be desired;  I've been basically building a ad-hoc supervision into each process individually
16:09:10 <ion> I’m looking forward to someone reproducing some of the OTP modules in Cloud Haskell.
16:11:14 <johnw> ion: if you want to help, Tim Watson would love to hear from you
16:14:36 <ion> johnw: If i ever feel energetic and productive enough, sure.
16:14:54 <johnw> well, it was something we were discussing at the pub, actually, so I know he's excited about it
16:15:00 <johnw> just one man, lots to do, sort of thing
16:20:28 <kurak0t> what is the best book in haskell in your opinion, anyone?
16:20:46 <johnw> kurak0t: for newcomers?
16:20:53 <kurak0t> yeah
16:20:56 <hpc> lyah
16:20:57 <johnw> I like Learn You a Haskell
16:21:35 <erisco> Learn You a Haskell: A Haskell Learn You Will
16:22:41 <wahwah> how do i do this in haskell? i want this: fmap (+10) [(*2), (*3), (*4)]
16:22:51 <joelteon> looks good
16:22:54 <elliott> :t fmap (+10) [(*2), (*3), (*4)]
16:22:56 <wahwah> where i get an array of functions that are compositions of (+10) with the one that's there
16:22:56 <lambdabot> (Num (a -> a), Num a) => [a -> a]
16:23:06 <kurak0t> well, thanks.
16:23:07 <elliott> :t fmap (\f -> (+10) . f) [(*2), (*3), (*4)]
16:23:08 <joelteon> ahh
16:23:09 <lambdabot> Num c => [c -> c]
16:23:11 <joelteon> there you go
16:23:19 <wahwah> doesnt seem to work for me
16:23:27 <joelteon> map (fmap (+10)) [(*2), (*3), (*4)]
16:23:29 <wahwah> joelteon: doesnt work for me, do i have to import something?
16:23:59 <joelteon> you should probably reboot
16:24:07 <wahwah> what do i need to import for that to work?
16:24:13 <Nisstyre> :t sequence
16:24:15 <lambdabot> Monad m => [m a] -> m [a]
16:24:44 <Nisstyre> :t sequence [(*2), (*3), (*4)]
16:24:47 <lambdabot> Num a => a -> [a]
16:25:02 <Nisstyre> > (sequence [(*2), (*3), (*4)]) 2
16:25:05 <lambdabot>   [4,6,8]
16:32:22 <kurak0t> anyone know when will the exercises be added in Learn You a Haskell book?
16:32:44 <elliott> probably never
16:32:50 <Nisstyre> kurak0t: there were plans to?
16:33:08 <Cale> I wonder where BONUS has gone
16:33:10 --- mode: ChanServ set +o elliott
16:33:18 --- topic: set to 'http://haskell.org | Paste code/errors: http://hpaste.org/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com' by elliott
16:33:22 <elliott> (saves a redirect)
16:33:23 --- mode: elliott set -o elliott
16:33:33 <dolio> Rolling around on piles of money, obviously.
16:33:49 <Nisstyre> yeah that book is fairly popular
16:34:09 <Nisstyre> my university runs a level 1 CS course that uses Haskell
16:34:17 <Nisstyre> and I see people recommending it to each other on facebook
16:39:48 <kurak0t> I read it from the FAQ of lyah's web site.
16:40:24 <levi> Well, there's no guarantee it's actually going to happen.
16:40:28 <kurak0t> BONUS said it will be coming soon
16:41:12 <Nisstyre> exercises are very difficult to do well
16:41:21 <ion> preflex: seen BONUS
16:41:22 <preflex>  BONUS was last seen on #haskell 2 years, 58 days, 4 hours, 13 minutes and 21 seconds ago, saying: yeah i think that's better as well
16:41:30 <Nisstyre> lol
16:41:33 <thoughtpolice> :(
16:41:52 <elliott> it's an old soon
16:42:23 <kurak0t> i thought BONUS was bonsu now. XD
16:42:39 <Nisstyre> preflex: seen bonsu
16:42:40 <preflex>  bonsu was last seen on #haskell 16 days, 20 hours, 45 minutes and 56 seconds ago, saying: right
16:42:54 <Nisstyre> preflex: seen pigworker
16:42:55 <preflex>  pigworker was last seen on #haskell 1 year, 65 days, 2 hours, 27 minutes and 57 seconds ago, saying: * pigworker hacked all day, hits the hay.
16:43:26 <kurak0t> i wish my company could give me more time to learn haskell
16:45:45 <mm_freak> > visit (http://haskell.org)
16:45:45 <lambdabot>   "great stuff!"
16:46:03 <mauke> :t visit
16:46:04 <lambdabot> b -> [Char]
16:46:10 <mm_freak> @undefine
16:46:10 <lambdabot> Undefined.
16:48:33 <acowley> I'm trying to link to a C++ library and getting linker errors. I'm passing -lstdc++ to GHC but still no joy. Any tips?
16:49:02 <mm_freak> acowley: suffering from C++'s name mangling perhaps?
16:49:03 <mauke> what's the errors?
16:49:29 <acowley> e.g. Undefined symbols for architecture x86_64:
16:49:31 <acowley>   "std::__1::locale::use_facet(std::__1::locale::id&) const", referenced from:
16:49:42 <acowley> mm_freak: The functions I'm importing are extern "C"
16:49:48 <elliott> > visit http://haskell.org
16:49:51 <lambdabot>   great stuff!
16:49:59 <ion> @type (://)
16:49:59 <lambdabot> () -> (() -> ()) -> Foo
16:50:08 <acowley> These errors are due to iostream stuff mostly
16:50:09 <johnw> acowley: you'll need to specify g++ as your linker
16:50:25 <acowley> johnw: will clang++ do?
16:50:27 <johnw> sure
16:50:51 <acowley> Okay, next question: how do I do that?
16:50:56 <johnw> trying to remember
16:50:59 <acowley> -pgml?
16:51:02 <johnw> yes!
16:51:07 <johnw> and -pgmc
16:51:11 <johnw> for any compilation that needs to happen
16:51:42 <acowley> I compiled the C++ to a .a previously
16:52:00 <mauke> @let a === b = cast a == Just b
16:52:01 <lambdabot>  Defined.
16:52:23 <mm_freak> :t (===)
16:52:23 <lambdabot> (Eq b, Typeable a, Typeable b) => a -> b -> Bool
16:52:29 <ion> > 5 === 5.0
16:52:32 <lambdabot>   False
16:52:42 <acowley> -pgml doesn't seem to be helping me here
16:53:01 <mm_freak> > (5 :: Integer) === (5 :: Rational)
16:53:04 <lambdabot>   False
16:53:24 <mm_freak> > cast (5 :: Integer) :: Maybe Rational
16:53:26 <lambdabot>   Nothing
16:56:11 <acowley> Got it!
16:56:17 <acowley> @johnw: Thanks for the help
16:56:18 <lambdabot> Unknown command, try @list
16:56:27 <acowley> I have too many versions of clang installed
16:56:47 <thoughtpolice> i had 4 installed at one point i think, for various toolchains
16:56:57 <joelteon> > (5 :: Integer) == 5.0
16:56:58 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
16:56:58 <lambdabot>    arising f...
16:57:01 <acowley> thoughtpolice: I have 2. This is 1 too many apparently :P
16:57:10 <thoughtpolice> :P
16:57:23 <acowley> thoughtpolice: I also screwed up on which stdlib was being linked into each part
16:57:38 <acowley> But now all is well and I can pretend the rest of the world uses Haskell
16:58:14 <joelteon> @let id x = unsafePerformIO (print x) `seq` x
16:58:15 <lambdabot>  .L.hs:121:11:
16:58:15 <lambdabot>      Ambiguous occurrence `id'
16:58:15 <lambdabot>      It could refer to either `...
16:58:20 <joelteon> damn it
16:59:16 <joelteon> anyway, that unnecessarily restricts the type of id
16:59:27 <joelteon> we need a sneakier one
17:01:05 <ion> print (unsafeCoerce x)
17:01:17 <joelteon> huh
17:02:05 <joelteon> that just always prints () though
17:02:18 <joelteon> I can't imagine there's any type that can't be coerced to ()
17:02:19 <ion> Yes, but it doesn’t restrict the type. :-P
17:03:38 <joelteon> rats
17:04:08 <kurak0t> :t []
17:04:08 <lambdabot> [a]
17:13:03 <jejones3141> I have a function that the -hc graph shows is grabbing a couple of megabytes of RAM, which seems a lot more than is proper. How can I find out where all that RAM is going?
17:16:40 <wavewave> jejones3141: use other profiling options.
17:17:08 <wavewave> like retainer
17:17:26 <jejones3141> wavewave: thanks. I will check it out.
17:18:19 <wavewave> hc hm hd hy hr hb
17:19:41 <adnap> cyan magenta ? yellow red blue
17:20:32 <Mikicacarica> FREE BRAZZERS ACCOUNTS EVERYDAY HERE ---> http://gratisbrazzers.blogspot.com
17:21:44 --- mode: ChanServ set +o dolio
17:21:55 <Cale> too late
17:22:06 --- mode: ChanServ set -o dolio
17:23:08 <elliott> dolio: what a waste. you should have banned someone while you had the opportunity.
17:24:14 <dolio> Yeah.
17:39:57 <Tekmo> Alright, so I'm writing a pipes library to pipe directory streams and I noticed that the `unix` package provides `FilePath` and `RawFilePath` versions of the same operations.  Is `RawFilePath` relatively new and more correct?
17:41:09 <shachaf> FilePath is from base, isn't it?
17:41:14 <Tekmo> Yes
17:41:30 <Tekmo> I mean that the `unix` package provide directory stream operations for both filename types
17:41:45 <shachaf> POSIX file paths are sequences of bytes.
17:41:47 <Tekmo> One module produces streams of `FilePath`s and the other produces streams of `RawFilePath`s
17:42:05 <Tekmo> So the `RawFilePath` is the more correct way of doing things?
17:42:19 <shachaf> Haskell FilePaths are sequences of code points, which are normally UTF-8 decoded from POSIX file paths, under POSIX.
17:42:24 <shachaf> The correspondence isn't perfect.
17:42:34 <shachaf> On Windows, on the other hand, I think file paths are actually unicode strings.
17:42:45 <Tekmo> The limited material I found by a Google search says that not all valid file paths are UTF-8
17:43:02 <Tekmo> or something like that ... I may have misread
17:43:39 <shachaf> Right. A POSIX filepath is just [Word8].
17:43:48 <shachaf> (Except without 0.)
17:44:17 <Tekmo> The issue is that packages like `filepath` only provide operations for `FilePath`
17:44:26 <Tekmo> Will they eventually be upgraded to `RawFilePath`?
17:44:39 <ion>  http://hackage.haskell.org/package/system-filepath
17:44:51 <shachaf> It's not so simple because they care about being cross-platform.
17:45:12 <Tekmo> Thanks for the link to `system-filepath`.  I didn't know about that library
17:45:33 <Tekmo> So is `system-filepath` competing with `unix` for the standard file path type?
17:46:53 <Tekmo> For example, I don't see an obvious way to convert `RawFilePath` to `system-filepath:FilePath` without going through a `String` representation first
17:48:11 <felix__> hello. this might seem like a silly question.  I'm trying to figure out why in function definitions, I have to use ( ) instead of [ ] when referring to lists.  As an example   myLength [x:y] = 1+ myLength y  returns an error whereas myLength (x:y) = 1+ myLength y  works just fine
17:48:15 <ion> Filesystem.Path.CurrentOS.decode
17:48:53 <p0a> Hello I evaluate the expression ((+) 1) and I get an error. I know that this is a function that takes an integer and returns its sum with 1. But why do I get an error when evaluating this?
17:48:53 <ion> felix: [x,y] is syntactic sugar for x:y:[]
17:49:05 <ion> > ((+) 1) 42
17:49:06 <lambdabot>   43
17:49:25 <Tekmo> I just realized there is a `filesystem-conduit`, so I can cheat off of that.  Thank you for the help, though.
17:49:31 <p0a> I have also noticed that this works. But that was expected. It is unexpected to me that ((+) 1) does not work
17:49:40 <felix__> ah, so ( ) are just scoping ?
17:49:41 <ion> p0a: Define “work”
17:49:54 <geekosaur> p0a, what error are you getting? please show actual code and actual full error
17:49:54 <elliott> p0a: it does work (if you try :t it'll show the type), it's just that functions cannot be displayed.
17:49:56 <geekosaur> @paste
17:49:56 <lambdabot> Haskell pastebin: http://hpaste.org/
17:50:03 <ion> felix: yeah, myLength x:y would parse as (myLength x):y
17:50:15 <p0a> elliott: nope
17:50:22 <felix__> ahhh
17:50:26 <felix__> thanks soo much ion :)
17:50:36 <p0a> No need to paste, try to evaluate (\x->χ) example
17:50:38 <elliott> p0a: ok, well, what geekosaur said then :)
17:50:41 <p0a> oops, sorry for greek letter
17:50:42 <elliott> my explanation covers typing (\x->x) into ghci
17:50:51 <elliott> so, you must be doing something else, or mistaken about "nope" :)
17:51:12 <p0a> elliott: I am mistaken indeed,. I had to use :t ((+) 1)
17:51:15 <p0a> and yes, that works. thanks
17:51:31 <elliott> yeah, it's just that functions can't be converted to Strings for display in much of a reasonable way.
17:51:39 <elliott> so when you get an error about Show instances when typing into GHCi, that's usually why.
17:51:46 <p0a> aah alright
17:52:19 <acowley> cabal-install doesn't want to compile my C++ into my package
17:53:04 <acowley> I need a "Makefile -> custom cabal" utility
17:53:24 <p0a> thanks a lot
18:00:25 <cutsea110> Hi dmwit
18:00:32 <cutsea110> Thank you.
18:01:00 <cutsea110> I've reinstalled regex-pcre-built previous version.
18:01:12 <cutsea110> I've success to load the package.
18:01:48 <cutsea110> I'd sent email to the package maintainer, too.
18:45:10 <shachaf> "This issue covers the week of June 9 to 11, 2013."
18:49:54 <monochrom> oh! finally Haskell Weekly News!
18:54:11 <shachaf> kappabot: @part
18:54:11 <kappabot> Plugin `system' failed with: Prelude.last: empty list
18:54:14 <shachaf> kappabot: @part #haskell
19:39:59 <erisco> it seems to me that one of the biggest ideas in computing is the idea of inferring information about data based on the location in which it is stored
19:40:22 <erisco> are there theories which discuss this idea?
19:43:09 <erisco> in fact the only two sources of information seem to be the location of data, and the data itself (the content contained at that location)
19:44:34 <erisco> possibly corresponding to a priori and a posteriori types of knowledge
19:46:43 <erisco> sorry... not really Haskell related... just figured this channel is more likely to have minds insightful to the idea
19:56:57 <koala_man> in parsec, is there any way to run a parser with the current context on a new string?
19:57:33 <Fuuzetsu> recursive with backtracking?
19:57:53 <koala_man> yes
19:58:16 <Fuuzetsu> does foo = try foo not work?
19:58:41 <koala_man> what?
19:59:24 <Fuuzetsu> I'm just asking why you aren't just making the recursive call in itself
19:59:28 <Fuuzetsu> is there anything stopping you?
19:59:55 <koala_man> I don't want to run a parser recursively on the same input. I want to run a different parser on new input
20:00:47 <Fuuzetsu> parser1 *> parser2?
20:01:07 <Fuuzetsu> Sorry, I don't quite understand what you're trying to achieve. Do you have an example usecase?
20:02:18 <koala_man> let's say I have a file format with an encrypted section. I want to parse the file, read the encrypted section, decrypt it, and run my parser on the decrypted result
20:03:17 <koala_man> i.e. transparently parsing the encrypted bit
20:03:32 <erisco> just a second parser, then. the nature of Parsec is that a parser isn't a monolithic thing, but rather composed from little parsers with specialized jobs
20:06:50 * tabemann is implementing a O(1) stack space strict concat... but it isn't necessarily that efficient in other ways...
20:06:53 <Fuuzetsu> Depending on the format, you might just get away with a single-pass, just have a (encrypted <|> decrypted) parsers for your sections
20:07:27 <koala_man> Fuuzetsu: the problem is, how do I implement my encrypted in terms of decrypted?
20:08:57 <koala_man> encrypted = do { s <- readSection; let plainText = decode s; ...
20:09:33 <koala_man> now how do I run 'decrypted' with plainText as the input, in the same context and state?
20:10:48 <Fuuzetsu> How about just passing plainText to the separate parsing function?
20:11:28 <koala_man> pass how, as a parameter?
20:11:37 <Fuuzetsu> I'm not sure what Parsec uses but something like ‘let plainText = decode s; decoded <- parseOnly decrypted plainText … ’
20:11:52 <Fuuzetsu> or rather, let decoded = parseOnly…
20:12:10 <Fuuzetsu> Apparently Parsec doesn't use parseOnly, whatever the equivalent is
20:13:10 <Fuuzetsu> ‘parse’
20:14:35 <koala_man> Fuuzetsu: that runs the parser with a new state
20:16:18 <koala_man> looks like setInput may be what I want
20:18:07 <Fuuzetsu> this doesn't work? http://hpaste.org/90487
20:19:28 <Fuuzetsu> Well, if setInput works then cool. Sorry, I only dabble with Attoparsec
20:19:50 <koala_man> Fuuzetsu: unfortunately not, since getPosition would start returning line 1 char 1, and the parser state is similarly reset
20:21:11 <Fuuzetsu> Right, that goes back to the “Depending on the format”. If the sections didn't need context, that'd be fine. In this case, you might just have to do two passes (or use that setInput function or whatever it is)
20:35:25 <koala_man> haha holy crap, it was so simple and worked so well
20:36:28 * tabemann wonders why there isn't a "more efficient but not order-preserving" version of concat in the Prelude or Data.List as he is making in his Data.List.Strict module
20:37:14 <copumpkin> more efficient how?
20:39:15 <tabemann> at least with strict lists, doing append is inefficient because you have to reverse the first list and then do a reverse-append onto the second list; doing a concat requires doing that with append after having reversed the overall list before feeding it into foldl1` (foldr can't be used because it would explode the stack due to creating cons cells in strict lists being a strict operation)
20:39:51 <copumpkin> oh sure, but the current lazy concat is as efficient as it can be, as far as I can tell
20:39:56 <tabemann> s/foldr/foldr1
20:39:59 <copumpkin> so I don't think there's really any reason to
20:40:41 <shachaf> Lazy lists are not strict lists.
20:40:57 <tabemann> (by reverse-append I mean an operation that reverses one list before appending it onto another list, which (with strict lists) is more efficient than a plain append)
20:41:25 <copumpkin> > concat (repeat [1,2,3])
20:41:28 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
20:41:32 <copumpkin> we can do things like that :)
20:43:11 <tabemann> strict lists are really not as convenient to work with as normal lists
20:43:57 <tabemann> (usually the versions of my functions that do a simultaneous conversion to a lazy list are *far* more straightforward than those which produce strict lists)
20:45:03 <tabemann> this little project's really making me appreciate laziness - heh
20:46:08 <applikativ> can I have a strict list of anything?
20:46:16 <applikativ> of infinite streams for example
20:46:18 <Cale> Usually if you have a lot of list appending to do, instead of working with lists of type [a], it's better to work with functions [a] -> [a], and replace [] with id and [x] with (x:) and (++) with (.)
20:46:37 <tabemann> applikativ: of course not
20:46:39 <Cale> and then at the end, apply the function to [] to get a normal list again
20:46:48 <tabemann> Cale: well yeah
20:47:17 <Cale> This can also be true with ByteStrings :)
20:47:23 <applikativ> tabemann: what can I put in a 'strict list'
20:47:31 <Fuuzetsu> @pl f g (Just (h, x)) (Just (y, z)) = Just (g h y, z)
20:47:31 <lambdabot> (line 1, column 34):
20:47:31 <lambdabot> unexpected " "
20:47:31 <lambdabot> expecting operator
20:47:47 <tabemann> applikativ: anything, as long as it fits in memory
20:48:37 <applikativ> I guess the 'lists' in Data.Vector are 'spine strict' so to say
20:49:04 <applikativ> they can hold infinite streams ...
20:50:37 <Cale> (I recall on one occasion our terrain generator had a bunch of manipulation of data files to do which required rearranging and splicing together lots of segments, and it was using way too much memory and taking 15 minutes or so to run, and without really trying to understand what the problem was, I just half-heartedly replaced ByteString by ByteString -> ByteString and did that trick, and that was enough to get it to r
20:50:37 <Cale> un in a few megabytes and take less than a minute :)
20:50:39 * tabemann is implementing strict lists primarily because they haven't been implemented before and he needed something to do other than trying to wrap OpenGLRaw, not because of how useful (or not) they may actually be
20:51:19 <tabemann> and because I picture that *someone* has implemented them before, but without any kind of complete library
20:51:56 <johnw> tabemann: http://stackoverflow.com/questions/8124359/libraries-for-strict-data-structures-in-haskell
20:52:03 <applikativ> Cale, but aren't bytestring builders 'difference bytestrings', if I remember
20:52:03 <johnw> seems like you may be right
20:52:55 <Cale> applikativ: I don't know what you're referring to
20:54:26 * tabemann is implementing Data.List.Strict with value-strict and spine-strict cons cells, whereas Data.Vector and Data.Seq.Sequence are only spine-strict
20:54:40 <Cale> applikativ: But this trick of using function composition in place of concatenation is quite effective, so I wouldn't be too surprised if there were a library which just wrapped it up.
20:54:50 <tabemann> there is
20:54:56 <Cale> (but I think it's often a little bit silly to do so)
20:55:02 <tabemann> there's a DList library somewhere in Hackage, I know
20:55:05 <Zer000> I'm really new to haskell and I wanted to play around with another person's program. Its a cabal package, how should I install it in such a way that allows easy recompilation?
20:55:13 <Cale> Oh, yes, there's definitely DList for lists
20:55:22 <Fuuzetsu> I have a ‘m ((a -> b), c)’ and I need a ‘(a -> b) -> m (a, c) -> m (b, c)’. Ideas for implementing this?
20:55:25 <Cale> Zer000: cabal unpack foo
20:55:57 <Zer000> its already unpacked. should I just run cabal install every time I make a change?
20:56:03 <Fuuzetsu> cabal build
20:56:14 <Zer000> ah ty
20:57:45 <applikativ> Cale I meant http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString-Builder.html but they're more complicated than that
20:57:50 <Cale> Fuuzetsu: foo f x = do (a,c) <- x; return (f a, c) ?
20:58:10 <applikativ> I was remembering newtype Builder = Builder (forall r. BuildStep r -> BuildStep r)
20:58:30 <applikativ> where type BuildStep a = BufferRange -> IO (BuildSignal a)
20:58:38 <applikativ> and it gets worse ...
20:58:40 <Cale> applikativ: I'm pretty sure those also didn't exist when I was doing that work :)
20:59:09 <Fuuzetsu> I guess ‘do’ works. I thought there might be some nice functions already.
20:59:10 <applikativ> they're very nice, though at the moment I'm regretting looking at the "Internal" module...
20:59:39 * hackagebot highlighting-kate 0.5.4 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.4 (JohnMacFarlane)
21:00:29 <tabemann> am I right, but can you convert a foldr into a foldl by reversing your list first?
21:01:40 <tabemann> forget that
21:01:45 <Cale> tabemann: You'll also have to flip the function
21:02:08 <tabemann> Cale: well yeah
21:03:08 <tabemann> I'm just thinking of how to make foldr act in constant stack space (as I'm planning on implementing Foldable in terms of it, and I don't want to make everything that uses Foldable act in O(n) stack space
21:04:23 <Nazeer> Hi. I am new. Is there any proof or sample to the statement "If Haskel function is called manytime in difference places with same argument, it returns the same". It does the same in all programming languages, no?
21:04:55 <tabemann> no, thanks to unsafePerformIO
21:04:58 <tabemann> and other stuff
21:05:18 <applikativ> just add {-#LANGUAGE Safe #-}
21:05:20 <Cale> tabemann: foldr does operate in constant stack space
21:05:48 <Cale> (as does foldl)
21:05:56 <dmwit> > foldr (\x y -> y + 1) 0 [1..1000000]
21:05:57 <lambdabot>   *Exception: stack overflow
21:06:03 <johnw> Nazeer: in many languages, calling the same function with the same arguments holds no guarantees; in Haskell, barring the use of things like unsafePerformIO, you can rely on what is called "referential transparency"
21:06:04 <Cale> Nazeer: no
21:06:05 <dmwit> Cale: Oh yeah? =)
21:06:24 <Cale> dmwit: (+) is the culprit responsible for using stack there
21:06:35 <Cale> foldr is blameless ;)
21:06:42 <dmwit> I don't really believe that.
21:06:49 <dmwit> foldr and (+) are jointly to blame.
21:07:10 <dmwit> e.g. foldl' would not cause a stack overflow for the analogous computation.
21:07:20 <Cale> foldr is responsible for one stack spot at a time, as it evaluates [1..1000000]
21:07:21 <tabemann> foldr uses O(n) stack space whenever f evaluates its second argument
21:07:32 <monochrom> dmwit: have you read my http://www.vex.net/~trebla/haskell/lazy.xhtml ? I have an example of using much memory, and an example of using little memory
21:07:38 <applikativ> yes, thats thanks to the strictness of (+) dmwit , no credit of foldl'
21:08:07 <Cale> tabemann: The stack essentially consists of case expressions which are waiting for their scrutinee to be evaluated enough to match.
21:08:43 <tabemann> but is it not advantageous to avoid this behavior, as much as one might try to blame f?
21:08:47 <Nazeer> Johnw:Thanks. Theoritically I understand, but I want to do some experiement on that. I will explore what you said
21:09:20 <tabemann> if one can make an foldr that uses O(1) stack space, at the slight expense of having to reverse your list first, why not do it?
21:09:24 <applikativ> Nazeer: there is a lot of difficulty stating the principle of referential transparency
21:09:42 <johnw> Nazeer: http://stackoverflow.com/questions/210835/what-is-referential-transparency
21:09:43 <monochrom> reversing a list may be more than slight expense
21:09:57 <tabemann> sure it doesn't work with infinite lists, but i'm using strict lists so they *can't* be infinite anyways
21:10:07 <monochrom> in fact, why not label O(n) stack as slight expense?
21:10:19 <applikativ> God thinks in terms of strict infinite lists
21:11:08 <monochrom> in fact, that's exactly what Lawrence Paulson says. O(n) stack for processing a O(n)-length list is slight expense. he is talking about map f xs in SML
21:11:49 <tabemann> except then you have a cliff that you can't be sure if you're going to run into (as you can't be sure how much stack space you have left)
21:12:11 <tabemann> whereas the implementation that uses O(1) stack space has no such cliff, even if it might be a bit slower as a constant factor
21:12:39 <tabemann> ideally what you'd want is a function that can tell you how much stack space you have left
21:12:54 <tabemann> and have your function switch between both modes depending on whether it is going to run out or not
21:13:18 <dolio> What's the point of this strict list stuff?
21:13:28 <johnw> tabemann: there's actually research ongoing in the field of "starved resource" computing; that would be an interesting idea in that camp
21:13:33 <tabemann> dolio: because it's not been implemented (with a proper library) yet
21:14:26 <tabemann> and partially as an alternative to deepseq
21:14:46 <NemesisD> hey guys. has anyone read that paper by ezyang about 3 useful monads and/or know about the Logic monad
21:14:55 <johnw> tabemann: you mean you not only make the cons cells WHNF, but you deepseq them too?
21:14:59 <dolio> I may know about Logic.
21:15:22 <tabemann> johnw: I mean that each cons cell has both a strict head and a strict tail
21:15:42 <johnw> tabemann: and by strict you mean its value is WHNF?
21:15:49 <tabemann> yes
21:15:57 <johnw> then it's not an alternative to deepseq
21:16:04 <tabemann> well it's up to the user to make what they put in the head strict in its fields as well
21:16:04 <NemesisD> dolio: i had a problem to solve that would take a user's wishlist and given a list of stores that have those items in stock, it would create an optimized cart, optimizing for the lowest cost
21:16:43 <johnw> tabemann: have you seen the rwhnf strategy in parallel?  you could use it to strictify a list's cells that way during its construction
21:16:44 <NemesisD> dolio: i've been told this may be NP hard. but when i was reading about Logic, it kind of sounded like it would be a good fit?
21:16:59 <dolio> Is it the Logic from logict?
21:17:00 <tabemann> johnw: rwhnf?
21:17:13 <johnw> http://hackage.haskell.org/packages/archive/parallel/latest/doc/html/Control-Parallel-Strategies.html#v:rwhnf
21:17:35 <johnw> ah, apparently called resq nowadays
21:17:36 <NemesisD> dolio: it looks like it
21:17:52 <applikativ> 'resolutely weak head normal form'?
21:18:19 <dolio> Okay. Well, you can certainly do backtracking kinds of stuff in Logic. Which may be good enough for your problem.
21:18:27 <johnw> anyway, properly parallelizing algorithms often carries with it a need to apply the right amount of strictness to guarantee that evaluation occurs within the spark, which kind of sounds similar to what you're aiming at
21:18:29 <NemesisD> dolio: the reason why it might be a good fit was that the paper said it was good for traversing a problem space, although maybe not since the solution to my problem would require a lot of comparing results
21:18:55 <dolio> It doesn't have anything fancy like logic variables, though.
21:19:06 <NemesisD> dolio: i ended up doing it a while ago using plain old lists, but for sufficiently large wishlists, the delay was brutal
21:19:17 <dolio> It's basically a faster backtracking monad than list for most uses.
21:19:47 <monochrom> NemesisD: look up various variations of the knapsack problem. they are NP-complete. and there is no conflict between NP-completeness and using a good backtracking library or language.
21:19:52 <tabemann> johnw: this *was* partially inspired by the idea of how to force a list over an MVar or TVar or like without its evaluation occurring in the receiving thread, even though now I'm doing it mostly because I can
21:20:06 <NemesisD> dolio: do you know of any other fancy tools that may help with this problem?
21:20:49 <dolio> I know that there's also another similar construct by Oleg, called FBacktrack or something.
21:20:57 <NemesisD> monochrom: that's what i figured. my solution required several nights of staring at papaer until smoke started to billow from my head
21:21:11 <dolio> It's not technically a monad, but it does some stuff to have certain nicer behavior than Logic.
21:21:44 <dolio> Not sure how it compare speed wise, except when it happens to search the problem space in a better order.
21:21:54 <dolio> Which sometimes happens.
21:22:27 <dolio> Might happen a lot, actually, unless depth-first is optimal, which is what Logic does.
21:22:45 <monochrom> don't read too many papers.
21:23:10 <NemesisD> dolio: im not sure if this problem will actually come up in our business for real but i have faith that coding algorithms will be way nicer in haskell than ruby
21:23:30 <NemesisD> dolio: well the way i see it, a successful algorithm might be one that know when to quit while its ahead
21:24:32 <dolio> If you want something actually intelligent, you're going to have to talk to someone else, I think.
21:24:34 <applikativ> *** Exception This looks hopeless
21:25:27 <dolio> Like, actual logic programming languages use better algorithms than either Logic or FBacktrack, I think.
21:25:39 <NemesisD> dolio: i don't think this will come up for a while, i just read the paper about the logic monad and had it in my head i could crack this problem easily, strut into work beating my chest about FP :P
21:25:46 <NemesisD> dolio: like prolog?
21:25:55 <dolio> And maybe something like a SAT solver would be better.
21:27:39 <SrPx> Hm, sorry, but how do I make a function that returns a function if the argument is an int, but returns an int if the argument is a function?
21:27:42 <dolio> Yeah, probably some prologs.
21:28:07 <monochrom> cannot
21:28:08 <dolio> When searching is your primary mode of computation, you want something a little non-naive.
21:28:27 <SrPx> monochrom: hm? Was that for me?
21:28:32 <monochrom> yes
21:29:20 <SrPx> monochrom: oh ... ... so how do I implement this function? f(f(x)) = -x
21:29:52 <SrPx> (without using addition and multiplication obviously)
21:31:24 <johnw> SrPx: f x = -abs(x)
21:31:46 <SrPx> hm no
21:31:50 <SrPx> won't work for negative numbers
21:31:57 <applikativ> >  4 :: Complex Double
21:31:58 <lambdabot>   4.0 :+ 0.0
21:32:00 <applikativ> hmm
21:32:26 <monochrom> oh, thanks, complex numbers solve it
21:32:43 <SrPx> no exponentiation plz
21:32:51 <monochrom> f x = (0 :+ 1)*x
21:32:56 <cespinoza> Hi guys, a newbie here, I'm very interested in haskell, and I would get some feedback about it, now I'm working with python(web frameworks), but I'd like improve my skills and add FP to my toolbox.
21:33:01 <monochrom> 0:+1 stands for the imaginary number i
21:33:07 <johnw> cespinoza: welcome
21:33:17 <cespinoza> I will use it mainly for web apps development and some async stuff..
21:33:27 <SrPx> no exponentiation, it would be easy w/ complex numbers
21:33:41 <cespinoza> Hi johnw, thanks
21:34:22 <NemesisD> monochrom: wow the knapsack problem is pretty much exactly my problem, except optimizing for lower prices and weight -> shipping price
21:34:33 <bscarlet> SrPx: monochrom's solution w/ complex numbers doesn't use exponentiation.
21:34:35 <tabemann> by async stuff you mean?
21:34:48 <SrPx> bscarlet: i've said no multiplication before!
21:35:00 <cespinoza> gps monitoring mainly
21:35:05 <johnw> SrPx: what is the point of this exercise?  it would seem better suited to ##math than here
21:35:44 <SrPx> I just want the equivalent of this function people: f(x) -> if is_int x then f(y) -> -x else x()
21:36:11 <erisco> define this function, but don't use the following valid definitions: .... but, why?
21:36:36 <monochrom> I have said everything I know. I have no further comment.
21:37:00 <SrPx> erisco: because they're valid only for that specific problem, if I want (x) -> if is_int x then f(y) -> foo x else x() instead, what now?
21:37:29 <monochrom> is it a Haskell programming question?
21:37:43 <erisco> I don't understand your notation
21:37:47 <shachaf> SrPx: It is impossible in Haskell, and moreover it's not the right thing to want. And moreover being rude won't get people to help you.
21:37:50 <SrPx> so again, how do I make this in haskell: f(f(x)) = foo x ... that's what I actually need. Sorry for asking it wrong on the first time.
21:37:52 <erisco> can extra parens clear it up?
21:38:10 <SrPx> shachaf: I'm not being rude at all
21:38:17 <SrPx> Sorry if I sounded like I were
21:38:51 <johnw> SrPx: foo = f . f
21:39:21 <SrPx> I... mean... foo is defined, you have to define f. OK I suck at asking, nevermind.
21:39:28 <johnw> good luck!
21:39:32 <SrPx> thanks :/
21:40:03 <copumpkin> johnw: you forgot your hat on
21:40:04 <shachaf> SrPx: You asked fine. You got an answer: It can't be done.
21:40:11 <Fuuzetsu> you can't have f . f = foo if that's what you're after
21:40:13 <johnw> copumpkin: my hat?
21:40:23 <dmwit> ur an op lol
21:40:30 <johnw> ah, yes, scary scary
21:40:33 --- mode: johnw set -o johnw
21:40:35 <SrPx> shachaf: why f(f(x)) = foo x can't be done!?
21:40:52 <Sonarpulse> what is the best way to make charts from vectors?
21:41:10 <dmwit> SrPx: It can be done. It just requires some pencil and paper work. =)
21:41:17 <johnw> Sonarpulse: is the diagrams library good for charts?  I don't know
21:41:23 <dmwit> (In *some* cases it can be done.)
21:41:46 <Sonarpulse> I try
21:41:50 <Sonarpulse> I think i am using repa
21:42:01 <Sonarpulse> got to kinda emulate matlab
21:45:47 <bscarlet> SrPx: I suspect this will open more cans of worms than you really want, but http://hpaste.org/90488
21:48:03 <SrPx> bscarlet: cans of worm?
21:48:38 <SrPx> bscarlet: that's interesting, I'm gonna study it now. lmgf instance/newtype brb
21:51:14 <bscarlet> SrPx: "to open a can of worms" is an English idiom, meaning to make a mess that's hard to clean up. My answer is something of a smartass answer. I suspect it meets the technical requirements you've specified, but won't make you happy w/o much study.
21:51:46 <bscarlet> SrPx: But those suspicions are just based on guesses about what you do & don't know.
21:52:15 <SrPx> bscarlet: it sounds like what I want but I'll need some time to get it
21:53:09 <shachaf> SrPx: The reason this is difficult -- and it's not exactly what you're after, having trouble with polymorphism etc. -- is that it's the wrong thing to want.
21:53:21 <bscarlet> SrPx: perhaps the most important point, and the reason everyone else was saying what you ask is impossible, is that Haskell is statically typed. Whether the argument to a function is an Int or not is a compile time question in Haskell, not a runtime question.
21:53:34 <erisco> I think it is more literally about the idea of trying to get all the wriggling worms back into the can again, but that doesn't really sound too difficult
21:53:37 <shachaf> You're asking how to do X, but X isn't the right way to accomplish whatever you want to accomplish.
21:53:39 <erisco> maybe you have to try it to know
21:54:07 <dmwit> bscarlet: Well, that *is* a cheeky answer.
21:54:17 <dmwit> There's two different 'f's there! =D
21:54:49 <erisco> they sell those inflating foam figurine thingies which react with oxygen (or water) and that is surely a better analogy
21:55:34 <Sonarpulse> johnw: I mean charts from vectors of numbers
21:55:34 <Sonarpulse> not graphics vectors
21:55:53 <Sonarpulse> chart, the lib, seems rather symbolic
21:56:27 <bscarlet> dmwit: Yes, and no. From a Haskell perspective it's two functions named f. The difference between that and one "function" "f" with two behaviors, esp. to someone who doesn't yet have their head in a Haskell mindset, is very small. As I said to SrPx - it's technically what was requested, but probably ultimately not what is desired.
21:56:46 <Sonarpulse> looks like it's just chart and plot
22:01:13 <bscarlet> SrPx: Depending on where you're coming from, you might instead want something like f (Right x) = Left x; f (Left x) = Right (-x). You can't make one Haskell function dynamically take an Int and something else, but you can choose or make another "bigger" type (in this case Either Int Int) which can hold an Int sometimes and some other state as well, and then write your function to operate on that type instead.
22:01:19 <m3ga> when using cabal to build a project, what's the best way of getting the package version number as a String or Text?
22:02:29 <SrPx> okay, I get your point
22:03:16 <SrPx> that still scares me, but I accept it
22:03:21 <shachaf> m3ga: http://www.haskell.org/pipermail/haskell-cafe/2012-February/099646.html
22:04:11 <bscarlet> If you care to articulate what you find scary, we might be able to help you.
22:04:26 <NemesisD> monochrom: upon doing some research, i'm tempted to say that my problem is almost more of a bin packing problem, or a mix between bin packin and knapsack
22:06:32 <erisco> what's the difference? is knapsack just one bin? what about the problem of taking arbitrary items and packing them in the smallest space?
22:08:22 <m3ga> shachaf: thanks. almost had it, but i was missing Paths_myprogram from the exposed-modules part of the cabal file
22:08:31 <NemesisD> erisco: my problem is to find the cheapest order total across the smallest number of vendors
22:08:34 <Cale> > let { f 0 = 0; f x | odd x = signum x * (abs x + 1) | even x = - signum x * (abs x - 1)} in map (f . f) [-10..10]
22:08:36 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
22:08:57 <Cale> > let { f 0 = 0; f x | odd x = signum x * (abs x + 1) | even x = - signum x * (abs x - 1)} in map f [-10..10]
22:08:58 <lambdabot>   [9,-10,7,-8,5,-6,3,-4,1,-2,0,2,-1,4,-3,6,-5,8,-7,10,-9]
22:09:38 <NemesisD> erisco: though i think there needs to be more parameters because at some point you must choose cheaper vs fewer vendors
22:10:22 <Cale> > let { f 0 = 0; f x | odd x = signum x * (abs x + 1) | even x = - signum x * (abs x - 1)} in f (f maxBound) :: Int
22:10:25 <lambdabot>   2147483647
22:10:32 <Cale> > let { f 0 = 0; f x | odd x = signum x * (abs x + 1) | even x = - signum x * (abs x - 1)} in f (f minBound) :: Int
22:10:34 <lambdabot>   -2147483648
22:10:42 <erisco> NemesisD, I don't know about your problem. I was just asking what the difference in problem types were
22:11:46 <NemesisD> erisco: i just learned about both concepts so i'm not sure i can say
22:14:57 <Xunie__> Hey, I saw you guys don't have a built in 'e' constant...
22:14:57 <Xunie__> > 1 + sum ( take 1000 [ 1/(product [ x | x <- [1..n] ]) | n <- [1..]] )
22:14:58 <lambdabot>   2.7182818284590455
22:15:22 <Sonarpulse> charts working
22:15:23 <Sonarpulse> thanks all
22:15:31 <Sonarpulse> :q
22:15:50 <Sonarpulse> ..... not ghci
22:16:03 <alkabetz> I wonder if anybody's written a GHCi IRC plugin.
22:16:03 <Xunie__> Is it efficient to use the following in my code?: e = 1 + sum ( take 1000 [ 1/(product [ x | x <- [1..n] ]) | n <- [1..]] )
22:16:04 <Xunie__> I hope any Haskell implementations don't recalculate this value too much?
22:16:23 <Xunie__> alkabetz, never underestimate the power of free time. :3
22:16:34 <shachaf> Xunie__: I imagine that code is a terribly inefficient way to calculate e, but assuming you don't give it a polymorphic type, it should be shared.
22:16:50 <Gracenotes> > exp 1
22:16:50 <lambdabot>   2.718281828459045
22:17:07 <shachaf> If it's a CAF (i.e. top-level) and monomorphic then it'll surely be shared among all uses.
22:17:14 <erisco> better accuracy on that one too
22:17:17 <shachaf> But what Gracenotes said is much more reasonable if you actually want this value.
22:17:24 <shachaf> > exp 1 :: CReal
22:17:25 <Gracenotes> (as an aside, you have to do it like that in many other languages with a vaguely C-based math library)
22:17:26 <lambdabot>   2.7182818284590452353602874713526624977572
22:17:40 <shachaf> > showCReal 100 (exp 1)
22:17:41 <lambdabot>   "2.718281828459045235360287471352662497757247093699959574966967627724076630...
22:18:02 <Gracenotes> I do love the way e starts. 2.7 1828 1828 45 90 45.
22:18:47 <Xunie__> Gracenotes, oh my god, I never saw that. That's brilliant.
22:18:53 <erisco> brilliant isn't it? leads many people astray on the common 10-digit calculator to think it repeats
22:19:27 <Gracenotes> if you wanted to use the formula, it seems pretty efficient overall, I think, for a given num type
22:19:34 <shachaf> How many people compute e on 10-digit calculators?
22:19:38 <anonlsdljsdflsdn> Hi all, is there a way to check if a field in a record has been initialized?
22:19:56 <shachaf> No.
22:19:57 <erisco> shachaf, the internal calculations use more digits, but the display on a typical calculator is 10
22:20:06 <Gracenotes> hm, what do you intend to do if it's not 'initialized'?
22:20:07 <shachaf> Alternatively: Yes: Turn on -Wall so you always get a warning when you don't initialize a field.
22:20:19 <Hafydd> > let e = 2.7 + 1828/99990 in e
22:20:20 <lambdabot>   2.7182818281828185
22:20:30 <Gracenotes> oh, is that the feature where it's set to some weird value if you don't say what it is explicitly?
22:20:39 <shachaf> Gracenotes: I assume anonlsdljsdflsdn (please do change that username, by the way!) means data Foo = Foo { x, y :: ... }; blah = Foo { x = ... }
22:20:46 <Gracenotes> records are weird.
22:20:47 <Hafydd> > let e = 2.7 + 1828/99990 in (showCReal 100 e)
22:20:48 <lambdabot>   "2.718281828182818281828182818281828182818281828182818281828182818281828182...
22:21:07 <Xunie__> Hafydd, now that is just... wrong.
22:21:08 <anonlsdljsdflsdn> I intend to simply ignore uninitialized values.  I should probably be using a hashmap, but this is what I've got so far...
22:21:10 <dolio> 5?
22:21:38 <Xunie__> Hafydd, if you use that in any code I have to read EVER? I will come over to your and rape your stuffed animals. I'm serious. ._.
22:21:38 <Hafydd> :t let e = 2.7 + 1828/99990 in e
22:21:38 <lambdabot> Fractional a => a
22:21:41 * dmwit whispers "teaspoon"
22:21:59 <Hafydd> I guess it chooses some low-precision type by default.
22:22:07 <dmwit> anonlsdljsdflsdn: Maybe is Haskell's way of having observable uninitialization.
22:22:18 <dmwit> anonlsdljsdflsdn: So make your fields have a Maybe type and interpret Nothing as uninitialized.
22:22:21 <dmwit> NEXT
22:22:26 <shachaf> Xunie__: That joke is not appropriate for this channel.
22:22:37 <Xunie__> Sorry. I'll try to be more PG-13.
22:22:38 <anonlsdljsdflsdn> dmwit: that might work
22:23:25 <Gracenotes> you need surprisingly few digits of mathematical constants to get a precise enough end-result, for many calculations.
22:23:47 <shachaf> Gracenotes: Especially when those mathematical constants are integers.
22:23:56 <Hafydd> Heh.
22:24:09 <xico> Hafydd: what do you mean by low precision by default?
22:24:10 <dolio> Like Graham's number?
22:24:11 <Fr4n> what about huge primes?
22:24:53 <Hafydd> > typeOf $ let e = 2.7 + 1828/99990 in e
22:24:54 <lambdabot>   Double
22:25:51 <Gracenotes> yeah, it's a great way to make RSA decryption more efficient, just round d to 30 significant digits
22:26:00 <Hafydd> Hahah.
22:26:03 <shachaf> I was thinking of the important mathematical constants. Like 0.
22:26:35 <Hafydd> > let zero = 1 in zero -- accurate to ~0 s.f.
22:26:36 <lambdabot>   1
22:26:36 <xico> Hafydd: you can just use the 'default' keyword if you are not happy with doubles
22:27:00 <shachaf> Or you can turn the monomorphism restriction off.
22:27:14 <shachaf> @where+ mr http://www.haskell.org/haskellwiki/Monomorphism_restriction
22:27:15 <lambdabot> I will remember.
22:27:28 <Gracenotes> but, it's for your own good
22:27:37 <Gracenotes> for the greater good, even
22:30:22 <Hafydd> Great, another article that doesn't explain anything.
22:33:42 <sclv> preflex: seen tazjin
22:33:44 <preflex>  tazjin was last seen on #haskell 6 days, 18 hours, 17 minutes and 38 seconds ago, saying: * charging
22:34:04 <sclv> @tell tazjin ok, hackage trac fixed now. sorry it took a while, thanks for the report!
22:34:04 <lambdabot> Consider it noted.
22:34:16 <sclv> preflex: seen typoclass
22:34:23 <preflex>  typoclass was last seen on #haskell 17 hours, 12 minutes and 21 seconds ago, saying: KingofFerrets: if it's really necessary, it's possible via the hs-boot mechanism, but in general you should try to structure your code differently
22:34:58 <sclv> @tell typoclass hackage trac fixed now, took a while to get setup to get around to it. thx for the report
22:34:58 <lambdabot> Consider it noted.
22:36:02 <NihilistDandy> There was an interesting discussion in /r/programming about OCaml ints being stored in 31 bits as sort of a bid to preserve type information during compilation, and I was curious if Haskell did anything similar to that
22:36:12 <NihilistDandy> http://www.reddit.com/r/programming/comments/1h3w6k/why_is_an_int_in_ocaml_only_31_bits/
22:36:28 <shachaf> NihilistDandy: "Haskell" is allowed to do lots of things.
22:36:34 <NihilistDandy> Right, sorry
22:36:41 <NihilistDandy> GHC
22:36:45 <shachaf> NihilistDandy: The report specifically makes allowances for this sort of thing.
22:36:55 <shachaf> An Int is only required to be 30 bits.
22:37:01 <shachaf> But in GHC it's 32 bits and stored boxed.
22:37:14 <Gracenotes> GHC pays special attention to boxed vs unboxed
22:37:20 <shachaf> (So no, it doesn't do it.)
22:37:25 <NihilistDandy> Neat
22:37:33 <shachaf> GHC's unboxed Int#s are a different sort of thing, though.
22:37:40 <shachaf> They also don't use tag bits.
22:37:57 <NihilistDandy> Do any of the other implementations make this sort of design decision. I admit to being rather uninformed about most of the other compiler options
22:38:07 <NihilistDandy> *?
22:38:19 <shachaf> For Haskell? I don't know.
22:38:41 <NihilistDandy> Hmm. I'll have to do some reading, then
22:38:48 <NihilistDandy> Thanks for the answers, anyway
22:39:05 <Moggle_> from my understanding, there are no real alternatives to GHC?
22:39:28 <shachaf> That depends on what "real" means.
22:39:29 <Moggle_> I mean I don't even think hugs is still being actively developed?
22:40:07 <shachaf> If "there are no real alternatives to GHC" means "hugs is not still being actively develope", then yes, there are no real alternatives to GHC. :-)
22:40:08 <NihilistDandy> UHC, Disciple
22:40:10 <shachaf> http://www.haskell.org/haskellwiki/Implementations
22:40:39 <NihilistDandy> I'm actually fairly curious about Disciple. I may see if I can get it to build this weekend
22:40:40 <akegalj> hi all. I am using gtk2hs to render some gui with haskell but i get stuck at treeview widget. My treeview (listview model) is populated with one column [String]. Now, what i want is, if anyone mouse clicks on some row i whant to print String on that row to stdout. Could you point me to some reading to solve this? thnx
22:41:32 <shachaf> akegalj: Reading other than the Gtk2hs and Gtk documentation?
22:41:37 <Gracenotes> GHC has a lot of ways to extend 'feelers' out into possible new features or dataflows
22:41:41 <Gracenotes> it seems to me
22:41:48 <shachaf> I mean, I think it's covered there. You make the GUI thing and set up a click event handler and so on.
22:43:42 <akegalj> shachaf: ok.. i'll try reading gtk doc.
22:44:32 <erisco> am I the only one who stares off into space while trying to write a difficult program?
22:45:13 <erisco> part of me is saying "this can't be productive" and the other part is saying "and what exactly do you propose will speed things along then?"
22:45:41 <johnw> erisco: try to solve a part of the problem first
22:46:16 <johnw> or, get out some paper and start sketching
22:46:16 <Moggle_> erisco: pacing around the house is my time honored tradition in cases like that, though it's usually time spent thinking about the program
22:46:26 <erisco> the presumes decomposing the problem is simpler, and before that presumes the problem is easy to define
22:47:41 <NihilistDandy> I tend to just think about a problem for a couple of days without writing any code. Eventually the solution is mostly obvious and I just bang it out. But most of my life is proofs, so that may be a weird way to go about it
22:47:49 <erisco> hm, I dunno. I used to think obsessively about specific things but I've developed a different habit of thinking in bursts
22:48:42 <erisco> personally I've felt that prolonged intense focus loses the bigger picture where the solutions may lie
22:49:34 <NihilistDandy> Not thinking about the problem is often as important as actually thinking about it
22:50:53 <NihilistDandy> Take in lots of tangentially related information and wait for something to crystallize. The worst that'll happen is you'll learn something new
22:50:54 <johnw> i spent all day yesterday beating my head against a wall that wouldn't move; and today, within an hour after walking, it just melted away before my eyes
22:51:32 <dmwit> The sad reality is that, had you not beat your head against the wall all day yesterday, the wall would not have melted today.
22:51:41 <johnw> this is extremely true
22:52:18 <erisco> sounds familiar ... the pacing is different than writing sorts of things you've written many times before
22:53:49 <erisco> to the point that it is basically guesswork and hoping some eureka moment comes ... and I find that increasingly difficult to support when one could just fall down an octave and write more mundane things
22:54:09 <erisco> getting a whole lot more accomplished in the time given
22:54:20 <NihilistDandy> Where's the fun in that?
22:54:23 <NihilistDandy> It's not a race
22:54:30 <Xunie> ^+1
22:54:35 <Gracenotes> I advise: Train Your Subconscious To Do Everything For You in Thirty and a Half Easy Steps
22:54:46 <Gracenotes> coming to market when I think of the steps
22:54:49 <NihilistDandy> Gracenotes: Exactly
22:55:26 <johnw> i actually do assign stuff to my subconscious, and came back from time to time to see how it's doing
22:55:53 <erisco> you get those "run in background" dialogs popping up in front of your eyes too eh?
22:55:53 <johnw> haha
22:56:30 <erisco> NihilistDandy, pragmatically time does matter
22:56:31 <johnw> it actually really helped with yoneda's lemma.  just queue it, and then keep chewing on it, discussing with friends, talking about it here, attempting to code it, repeat.  took a few months, but it paid off in the end
22:56:52 <NihilistDandy> erisco: I'm a pure mathematician. Pragmatism is a dirty word for me :P
22:56:58 <johnw> trying to do it as a fully conscious "right now" sort of process is self-defeating for me
22:57:11 <erisco> if you're looking at what direction you want your career to take, race is very much a part of it
22:57:39 <erisco> um, race in terms of time .... socio-economic trends are aside on this issue :P
22:57:50 <NihilistDandy> ha
22:58:46 <NihilistDandy> Just put a half hour into whatever you're having trouble with, once a day
22:58:51 <NihilistDandy> Those half hours add up fast
22:58:59 <johnw> NihilistDandy++
23:00:02 <erisco> it isn't a thing on the side, though. I generally think that someone who wants to work on challenging programming problems also wants to work full time at the drug store
23:00:16 <erisco> doesn't want to*
23:01:31 <NihilistDandy> If it makes you feel any better, erisco, most of the code I write for money is PHP. No pushing boundaries, no fun, no joy. I've actually spent more time this week working out ways to *not* write PHP than I have actually writing
23:01:47 <NihilistDandy> And I'm still a month ahead on my deadlines
23:02:15 <erisco> hm.
23:02:34 <NihilistDandy> If you want to work on challenging programming problems for money, just set time aside while you're doing the daily slog to pick up the skills that interest you
23:02:42 <NihilistDandy> Subscribe to some mailing lists in the topics you like
23:02:46 <NihilistDandy> Get on IRC
23:02:48 <NihilistDandy> Absorb
23:03:00 <erisco> IRC and mailing lists don't pay :P
23:03:02 <NihilistDandy> You'll meet people and find out about opportunities to do what you want
23:03:14 <NihilistDandy> What you lack isn't technical skill, it's connections
23:03:42 <NihilistDandy> Technical skill is just practice
23:03:49 <NihilistDandy> Connections are about *being there*
23:03:50 <johnw> that's is so right
23:03:53 <NihilistDandy> Wherever "there" is
23:04:29 <johnw> being in the right place at the right time, it is sometimes assumed you'll learn what you need to know
23:04:51 <johnw> erisco: Are you interested in Haskell programming?
23:05:21 <kurak0t> i'm interested! o/
23:05:46 <erisco> halfway. it is the only language from what I've seen that has a type system to be taken seriously
23:05:46 <johnw> watch reddit, and the planet haskell
23:05:47 <erisco> then again I come from OOP land
23:05:51 <johnw> people are looking for Haskellers from time to time
23:06:05 <NihilistDandy> The mailing lists have all kinds of openings that pop up
23:06:10 <johnw> right
23:06:49 <erisco> I just want to steal its ideas really ;)
23:06:52 <Gracenotes> I haven't done any programming in the last month
23:07:18 <johnw> erisco: and where will you take these thefted ideas?
23:07:21 <NihilistDandy> erisco: Look for a job where you have to think rather than one where you have to program. :D
23:07:25 <Gracenotes> working on other skills. like doing logistics of everything. and be better at Go.
23:07:29 * zRecursive haskell is worth learning. But it is NOT practical for real development ? C/ObjC,java are dominant.
23:07:30 <Gracenotes> the board game.
23:07:40 <erisco> NihilistDandy, maybe I am the devil's advocate but I don't see why there is necessarily anyone that is going to coincide with my objectives
23:07:53 <johnw> zRecursive: ?
23:07:54 <NihilistDandy> erisco: What are your objectives?
23:08:04 <erisco> johnw, selling them to the kaiser for much profit
23:08:15 <zRecursive> johnw: it is hard to find a haskell job
23:08:27 <johnw> that doesn't make it not practical, just harder
23:08:33 <NihilistDandy> I started picking up Cocoa development because it seemed fun. I like the message-passing style
23:08:46 <johnw> jobs that are easy to get aren't always the ones worth getting, if you can choose
23:08:46 <NihilistDandy> I don't know that I'll ever make money at it, but it's a neat thing to explore
23:09:36 <erisco> NihilistDandy, I see mismatch as commonplace and working partnerships a rarity
23:09:50 <Xunie> I don't want to sound elitist or have a 'holier than thou' attitude over you, NihilistDandy. But I picked up Haskell to expand my horizons. So far? It has paid off.
23:10:07 <NihilistDandy> Xunie: I was talking about Cocoa
23:10:10 <Xunie> Most of the time? It's good to sample things in the software world and see hwo things can be done better.
23:10:32 <NihilistDandy> I like to sample things. I don't really care much about the money
23:10:51 <shachaf> Xunie: Uh, what?
23:11:21 <NihilistDandy> erisco: I don't follow. What are your objectives?
23:11:28 <erisco> NihilistDandy, first you need people with some common ground on what are the interesting problems to solve, and after that is all the near-impossible practicality of location and meeting and finances and all sorts of nonsense
23:11:40 <Xunie> shachaf, I meant: picking up new things as a developer almost always pays off somehow. Either with information to do things better or experience that 'solution x sucks'.
23:11:47 * apples can't wait for the category theory meetup in july
23:11:54 <apples> just got my copy of the book, gonna catch up :)
23:11:55 <NihilistDandy> erisco: You're putting the cart before the horse
23:12:01 <zvrba> apples: which book?
23:12:10 <apples> basic category theory for computer scientists, by pierce
23:12:12 <erisco> I don't see the horse. Show me the horse.
23:12:18 <shachaf> apples: There's also a Haskell meeting in Mountain View the day after.
23:12:27 <zvrba> oh. that's a dense book :S
23:12:38 <apples> surely it's easier than mac lane's
23:12:47 <apples> shachaf: that might be a little too far for me, not sure
23:12:52 <shachaf> zvrba: It doesn't seem particularly dense.
23:12:54 <NihilistDandy> erisco: You're worrying too much about the logistics before you've even settled on what you need the logistics for. What do *you* think is an interesting problem? I guarantee there's a whole group of people who agree.
23:13:13 <shachaf> apples: Ah. Depends on where you're coming from.
23:13:22 <erisco> NihilistDandy, I'm saying this out of having been in more than one group before
23:13:33 <zvrba> shachaf: it's... hollow. it defines a thing, gives maybe one example and goes on to define the next thing.
23:13:41 <apples> i live in the top of SF, but i don't have a bike or anything so getting to the caltrain is a good distance
23:14:01 <apples> anywho, i'll stop the off-topic chat now :)
23:14:25 <zvrba> is there a category theory textbook written by a  Russian mathematician?
23:14:26 <NihilistDandy> erisco: So? Do you swear off your sex of choice because you've been burned by a former lover?
23:14:43 <shachaf> NihilistDandy: I think this is getting pretty off-topic.
23:15:06 <NihilistDandy> I'm still trying to figure out what sorts of problems are interesting T_T
23:15:19 <zvrba> NihilistDandy: opinions differ.
23:15:28 <zvrba> every person has their own preferences.
23:15:38 <NihilistDandy> zvrba: I know, I just mean the ones that erisco finds interesting
23:15:54 <erisco> NihilistDandy, I don't think people do that but rather are sore from dating. I don't know because I've never been into that sort of thing
23:15:56 <johnw> our biggest preference here is discussion about Haskell :)
23:16:12 <shachaf> erisco: I think this is getting pretty off-topic.
23:16:23 <NihilistDandy> To #haskell-blah
23:16:24 <erisco> NihilistDandy, well that isn't really the point, what I find interesting or not. the point is that even if you could link me to three people I haven't met before that share interests, what happens from there
23:16:27 <erisco> shachaf, fair enough
23:16:33 <johnw> thanks, erisco
23:17:12 <blackdog> zRecursive: I'm building practical software in Haskell right now and will be hiring soon. there's nothing wrong with haskell for practical code.
23:20:00 <OffsetGoose> blackdog: What kind of work?
23:20:20 <blackdog> OffsetGoose: largescale webscraping.
23:20:33 <blackdog> (well, semi-large. i'm not google. enough boxes to give me headaches, put it that way)
23:21:29 <OffsetGoose> Cool :D  Concurrency must be great for that kind of task
23:21:39 <OffsetGoose> What's the profit in webscraping?
23:22:16 <blackdog> business intelligence, basically.
23:22:26 <blackdog> we do a big scrape of the web every day - not quite launched yet.
23:22:36 <OffsetGoose> Market trends?
23:23:14 <blackdog> actually, speaking of which, i was thinking of outsourcing some work - we need to do things like analyse webpages to pull out interesting chunks of text
23:23:27 <johnw> blackdog: what sort of volume?
23:23:39 <blackdog> johnw: 150 million domains a day
23:24:08 <apriori_> hey guys. does anyone know a fast vector library? (implying operations on3d/4d vectors?)
23:24:09 <blackdog> will have more details soon, but if anyone's interested in that kind of thing and wouldn't mind a short remote contract ping me at mark@meanpath.com
23:24:20 <johnw> so, estimating 24GB/hour?
23:24:30 <apriori_> I've tried to implement my own vectors using "vector" arleady, but those clearly dont end up as being SIMD generated
23:24:50 <blackdog> johnw: hang on, let me do the sums :)
23:24:53 <johnw> apriori_: you should ask carter
23:25:14 <apriori_> johnw: ok, waiting for him then
23:25:16 <apriori_> thank you
23:25:44 <blackdog> johnw: i know we're pulling about 40 mbit/s from each bot, and we have about 50 of them
23:25:46 <johnw> @tell carter I am sending apriori_ your way, as he is looking for a fast vector library
23:25:46 <lambdabot> Consider it noted.
23:25:58 <blackdog> goal is to scrape in 4 hours-
23:26:14 <johnw> oh, I was dividing evenly across 24 hours, assuming avg 4K per page
23:26:25 <zvrba> btw. haskell + simd? are there simd operations in haskell that get compiled to actual simd instructions?
23:26:26 <johnw> and that was only one page per domain, so a low-ball
23:26:51 <johnw> zvrba: recent GHC does, I'm not sure which version exactly
23:27:00 <zvrba> ok
23:27:26 <blackdog> i think they're usually bigger, and we have to grab robots.txt, and we follow redirects etc
23:27:45 <blackdog> 5 mb a second is about 3-400 completed domains
23:32:16 <zvrba> i've come half-way through LYAH and still can't decide whether Haskell is something worth pursuing...
23:32:32 <zvrba> it seems like a nice language for modeling, but otherwise impractical.
23:32:44 <zvrba> (modeling data structures and prototyping algorithms)
23:32:44 <johnw> zvrba: it's quite practical; you should pick a real problem you want to solve with it
23:33:08 <blackdog> zvrba: i use it for dirty systems problems.
23:33:11 <blackdog> it's pretty great at it.
23:33:11 <Kinnison> Indeed, it's not good to just "try" a language.  The only real way to see if you like it is to try and solve a real world problem with it
23:33:28 <Moggle_> zvrba: you're not even at monads yet, i recommend you keep going :D
23:33:48 <zvrba> Moggle_: :) yeah, I've read through type classes
23:33:49 <johnw> zvrba: and certainly I wouldn't not recommend forming a blank opinion like "it's impractical" after only reading half of an introductory text
23:33:54 <johnw> s/not//
23:34:52 <zvrba> well, this "impractical" conclusion has two sources..
23:35:32 <zvrba> 1) it seems hard/convoluted to mix computation with IO (like, how do you output a DOT while an algorithm is in progress...)
23:35:41 <Kinnison> As someone who actively wants Haskell in more places in his life, the most impractical thing about it is that ghc cannot bootstrap without ghc :-(
23:35:53 <zvrba> 2) vast majority of real-world algorithms are described in terms of mutable data structures.
23:36:13 <zvrba> (I'm talking about published papers)
23:36:21 <Moggle_> zvrba: interestingly enough, haskell is FANTASTIC at concurrency
23:36:37 <blackdog> zvrba: yes. it's unfortunate that people keep doing that, most algorithms are simpler when stated functionally.
23:36:46 * Kinnison leaves convincing zvrba to the rest of you.  I'm off to work
23:36:52 <zvrba> Kinnison: :)
23:37:04 <zvrba> I guess my next book should be RWH
23:37:04 <johnw> zvrba: if you define practical as "that which best suits what the majority are used to", then yes, it's highly impractical.  I define it as "that which lets me get real work done, with few errors in shorter time than other languages"
23:37:16 <blackdog> zvrba: it's like project mayhem. you choose your own level of involvement.
23:37:31 <johnw> but we're not really here to debate whether Haskell should exist or why, we already take that as a given.  We'd be happy to answer specific questions about the language
23:37:32 <blackdog> for instance, my current project uses MVars and IORefs all over the place - really, at large scale, it's pretty damn imperative
23:37:52 <blackdog> but i still get the benefits of purity at a small scale, and eventually i'll refactor it to something less dodgy
23:38:02 <blackdog> probably about the time we hire someone who knows enough haskell to make fun of me :)
23:38:36 <zvrba> hmm
23:40:48 <akegalj> shachaf: thnx for pointing out to gtk2hs doc. I am not used to reading offitial documentation, but it's quit usefull
23:41:37 <zvrba> I have a real-world problem, but it involves calling out to Win32 API to read memory from a remote process and parse data structures from raw byte string... :S
23:41:47 <zvrba> (remote = another)
23:41:51 <Moggle_> zvrba: to answer your #1 from before, look up forkIO
23:42:11 <Moggle_> as for the win32 api, look up haskell's FFI
23:42:28 <Moggle_> I haven't done more than tinker with it but it's fairly easy to use.
23:42:31 <johnw> zvrba: I do a very similar thing in my gitlib library, it's just a different API
23:43:12 <zvrba> with which compiler is GHC on windows integrated?
23:43:25 <zvrba> i've installed haskell platform. will it work out of the box?
23:43:32 <zvrba> i need only 3-4 FFI calls..
23:43:44 <johnw> yes, it should
23:44:01 <zvrba> ok. does FFI exist only in IO monad?
23:44:02 <johnw> i'm not sure which linker Cabal is going to invoke
23:44:08 <johnw> yes, FFI is all in IO
23:44:24 <johnw> see the Foreign. family of modules
23:44:31 <johnw> Foreign.Ptr, Foreign.C.Types, etc.
23:44:32 <shachaf> Well, you can use import foreign functions unsafely without IO in their type.
23:44:50 <Moggle_> On windows, my haskell platform came included with mingw
23:45:04 <shachaf> foreign import ccall "sin" c_sin :: CDouble -> CDouble
23:45:17 <shachaf> But you have to promise that it's safe.
23:45:30 <zvrba> what is "safe"  in this context?
23:45:41 <zvrba> ReadProcessMemory is certainly not pure :)
23:46:38 <shachaf> Yes. Then give it an IO type.
23:46:39 <zvrba> ok. i'll finish LYAH and continue to RWH.
23:46:42 <johnw> zvrba: safe for his hypothetical function would mean that the same argument always yields the same answer, without any other effects.  If you know that's the case (and sometimes it is, even for C functions), you can drop the IO requirement
23:46:56 <zvrba> johnw: ok, got it.
23:47:00 <shachaf> There are good slides on the FFI which you can read.
23:47:10 <zvrba> shachaf: do you have a link?
23:47:15 <shachaf> http://www.ugcs.caltech.edu/~keegan/talks/high-level-ffi/talk.pdf
23:47:47 <zvrba> cool, thanks.
23:48:14 <kurak0t> how to view previously entered command in ghci?
23:48:28 <shachaf> ↑
23:48:41 <johnw> up arrow
23:48:58 <zvrba> re ghci: how to access previous results?
23:49:12 <zvrba> (i.e., are they stored in some special variable(s))
23:49:14 <shachaf> it
23:49:17 <Moggle_> zvrba: the 'it'  holds the result of the last computation as well
23:49:29 <Moggle_> i was going to call it a variable but i dont know if that's strictly correct
23:49:36 <Moggle_> i suppose it is.
23:49:46 <zvrba> ok
23:49:50 <kurak0t> shachaf: arrow up, that does not work for me :(
23:50:04 <Moggle_> kurak0t: what OS are you on?
23:50:16 <Moggle_> (not that it should matter)
23:50:19 <kurak0t> windows, running in cygwin
23:50:33 <Moggle_> ghci runs outside of cygwin, try it there maybe?
23:51:35 <kurak0t> Moggle_: i tried in cmd.exe, it was ok using the arrow up key
23:52:03 <kurak0t> ghci does not like cygwin?
23:52:42 <Moggle_> kurak0t: cygwin uses its own terminal sort of thing, i imagine that anything like ghci (irb, python's interpreter) will have the up arrow work
23:52:48 <Moggle_> let me test that theory real quick though
23:53:09 <shachaf> Perhaps this can help:
23:53:10 <shachaf> @google ghci cygwin
23:53:11 <lambdabot> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/ghci-cygwin.html
23:53:11 <lambdabot> Title: 12.5.� Using GHC (and other GHC-compiled executables) with cygwin
23:53:33 <shachaf> Probably the answer is just to run it in the regular Windows console.
23:53:35 <kurak0t> Moggle_: I use mintty by the way.
23:53:47 * shachaf sighs.
23:54:28 <Moggle_> well
23:54:36 <Moggle_> irb wont even start in cygwin, and python plays nicely with cygwin
23:54:42 <Moggle_> so yeah sounds like a ghci thing
23:57:09 <zvrba> is "deriving (Show)" some kind of compiler magic?
23:57:16 <shachaf> It is.
23:58:56 <Moggle_> it's entirely possible to use Template Haskell and do something similar yourself, it's not thaaaat magical.
