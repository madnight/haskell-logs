00:01:23 <Aetherspawn> :t castPtr
00:01:24 <lambdabot> Not in scope: `castPtr'
00:02:18 <Ralith> @hoogle Ptr a -> Ptr b
00:02:19 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
00:02:19 <lambdabot> Foreign.Ptr plusPtr :: Ptr a -> Int -> Ptr b
00:02:19 <lambdabot> Foreign.Ptr alignPtr :: Ptr a -> Int -> Ptr a
00:05:00 <Aetherspawn> :t sizeOf Int
00:05:01 <lambdabot>     Not in scope: `sizeOf'
00:05:01 <lambdabot>     Perhaps you meant one of these:
00:05:01 <lambdabot>       `IM.size' (imported from Data.IntMap),
00:05:08 <Aetherspawn> > sizeOf (1 :: Int)
00:05:11 <lambdabot>   Not in scope: `sizeOf'
00:05:11 <lambdabot>  Perhaps you meant one of these:
00:05:11 <lambdabot>    `IM.size' (impor...
00:21:06 <notdan> What can you recommend as a DB interface/library for Haskell?
00:21:46 <notdan> I was thinking about haskelldb, but apparantly it's not active and the bug mentioned here - http://chrisdone.com/posts/haskelldb-more-type-safe - has not be resolved
00:23:52 <notdan> altho I can say that I do love the idea of using rel algebra :|
00:25:06 <mgsloan> notdan: I haven't tried the others, so this isn't /that/ informed of a suggestion, but persistent is pretty awesome.  It doesn't have the bug mentioned there
00:26:34 <notdan> I was using persistent only a little bit when I was playing with Yesod. It's kinda cool and I know that various people has put a lot of work into it, but the only thing that slightly bother me is the use of TH
00:29:02 <mgsloan> notdan: What's wrong with TH?  The compilation time?
00:29:26 <notdan> Error messages are scary :D
00:30:10 <notdan> I think I'll play with persistent, haskelldb and acid-state and see what is more suitable/easier
00:31:56 <mgsloan> Sounds good!  It would be nice if TH encouraged code to generate nicer errors / let you tap into some of GHC's errors stuff
00:32:42 <mgsloan> Especially if it let you intercept type errors and the like, that'd be pretty interesting
00:40:14 <kostja> hi! I'm trying to do an exercise from typeclassopedia and prooving that monoidal is equivalent to applicative. I think I have a right implementation of pure a = fmap $ (,) a $ unit but I have no idea how to implement <*>. Maybe you can give me a small hint?
00:40:50 <shachaf> @ty uncurry ($)
00:40:51 <lambdabot> (b -> c, b) -> c
00:41:08 <notdan> @ty (<*>)
00:41:09 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
00:41:14 <Aetherspawn> @pl (f -> NxState f f)
00:41:14 <lambdabot> (line 1, column 6):
00:41:14 <lambdabot> unexpected '>'
00:41:14 <lambdabot> expecting operator
00:41:18 <Aetherspawn> @pl (\f -> NxState f f)
00:41:18 <lambdabot> join NxState
00:41:36 <kostja> shachaf: thank you!
00:41:41 <Aetherspawn> Uh, what.
00:41:43 <Aetherspawn> @pl (\f -> NxState f f)
00:41:44 <lambdabot> join NxState
00:42:25 <supki> > join (f :: Expr -> Expr -> Expr) x
00:42:26 <lambdabot>   f x x
00:42:52 <kostja> shachaf: I thought uncurry has type (a -> b -> c) -> (a,b) -> c
00:42:59 <shachaf> It does.
00:43:14 <shachaf> Can you work out what a, b, and c are?
00:43:56 <kostja> yeah, type of ($) is (a->b) - > a -> b
00:44:22 <shachaf> No, those 'a' and 'b' are different.
00:44:33 <shachaf> uncurry :: (a -> b -> c) -> (a,b) -> c
00:44:38 <shachaf> ($) :: (d -> e) -> d -> e
00:44:49 <shachaf> uncurry ($) :: ...
00:44:55 <kostja> ok, you would need to have d = b and e = c
00:44:56 <shachaf> Can you work out what a,b,c,d,e turn into?
00:45:19 <sankrant> Will haskell standard remain as elegant and simple as it is in the future standards
00:45:20 <sankrant> ?
00:45:45 * hackagebot uhc-util 0.1.2.0 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.2.0 (AtzeDijkstra)
00:46:57 <Aetherspawn_> @pl (\f -> NxState f f)
00:46:58 <lambdabot> join NxState
00:47:03 <Aetherspawn_> :t join
00:47:05 <lambdabot> Monad m => m (m a) -> m a
00:47:23 <Aetherspawn_> I don't understand how that can possibly work
00:47:43 <supki> m ~ (e ->)
00:48:00 <supki> join :: (e -> e -> a) -> (e -> a)
00:50:54 <kostja> shachaf: g <*> u = fmap $ uncurry ($) ( g ** u ) is this right?
00:51:35 <shachaf> Probably not. But why are you asking me? Ask GHC!
00:52:01 <kostja> shachaf: I don't have an installation at hand :(
00:53:05 <shachaf> Ah. Probably you should get one if possible. It'll make life much easier.
00:53:20 <kostja> shachaf: yeah! :D I have one, but nor here
00:54:48 <kostja> :t uncurry (**)
00:54:50 <lambdabot> Floating c => (c, c) -> c
00:55:19 <kostja> :t uncurry Control.Applicative.(**)
00:55:20 <lambdabot> Couldn't find qualified module.
00:55:36 <kostja> :t uncurry Control.Monoidal.(**)
00:55:38 <lambdabot> Couldn't find qualified module.
00:58:25 <kostja> :t let (**) :: f a -> f b -> f (a,b) uncurry (**)
00:58:26 <lambdabot> <no location info>:
00:58:26 <lambdabot>     not an expression: `let (**) :: f a -> f b -> f (a,b) uncurry (**)'
01:02:00 <dobblego> which package for Identity?
01:03:46 <supki> transformers
01:05:07 <Aetherspawn_> anyone know if theres an example of stateful "fread" in haskell anywhere?
01:05:55 <blz37> ski, tabemann, applicative, and all. Thnx for the explanations. Will continue tomorrow.
01:13:12 <randomclown> :t uncurry(<>)
01:13:13 <lambdabot> Monoid c => (c, c) -> c
01:13:14 <randomclown> :t uncurry (<>)
01:13:15 <lambdabot> Monoid c => (c, c) -> c
01:15:46 * hackagebot control-bool 0.1 - Useful combinators for boolean expressions  http://hackage.haskell.org/package/control-bool-0.1 (FumiakiKinoshita)
01:19:39 <t7> im in callback hell
01:19:55 <t7> with jquery
01:23:36 <nlogax> My condolences, t7
01:33:15 <Ghoul_> :t (>>=)
01:33:16 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:34:29 <no-n> :t (>=>)
01:34:30 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
01:35:14 <no-n> what is an example use-case of >=>
01:37:16 <randomclown> no-n: folding monadic actions?
01:37:25 <nlogax> Writing the associative law in a more obvious way :P
01:39:10 <dobblego> no-n: whenever you have \x -> f x >>= g
01:39:45 <no-n> ah
01:47:12 <tomejaguar> no-n: You use it where you would use (.) [but for in monad an with the arguments in the opposite order]
01:54:59 <simukis_> :t foldl'
01:55:00 <lambdabot> (a -> b -> a) -> a -> [b] -> a
01:55:11 <simukis_> :t foldl
01:55:12 <lambdabot> (a -> b -> a) -> a -> [b] -> a
02:20:50 * hackagebot null-canvas 0.2.5 - HTML5 Canvas Graphics Library - forked Blank Canvas  http://hackage.haskell.org/package/null-canvas-0.2.5 (KrzysztofSkrzetnicki)
03:07:54 <tero-> what's does the following mean in the function parameter declaration "serveFile StaticSettings {..} req file"
03:08:16 <tero-> specifically, I'm confused by the use of type name and {..}
03:10:17 <supki> tero-: http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/syntax-extns.html#record-wildcards
03:10:54 <tero-> supki: thanks
03:15:52 * hackagebot BigPixel 1.0.0 - Image editor for pixel art  http://hackage.haskell.org/package/BigPixel-1.0.0 (ManuelChakravarty)
03:16:17 <merijn> tero-: Relatedly, you can't have type names outside of type signatures, which means that anything starting with a capital letter in expressions is always a constructor
03:18:23 <tero-> merijn: ah, true
03:20:52 * hackagebot BigPixel 1.0.1 - Image editor for pixel art  http://hackage.haskell.org/package/BigPixel-1.0.1 (ManuelChakravarty)
03:24:54 <jpod> Is there a way to suppress the terminal window from runghc or runhaskell like pythonw does? Thanks.
03:31:43 <supki> jpod: do you mean something like  nohup ./foo & ?
03:31:55 <supki> ..or is it Windows question?
03:33:06 <jpod> supki: yes, I am on windows
03:33:36 <supki> okay. sorry, no idea then
03:38:42 <pjdelport> jpod: cmd.exe may have some options
03:38:50 <pjdelport> check cmd /?
03:38:57 <pjdelport> (or whatever it is)
03:40:56 <jpod> pjdelport: I just tried nohup which I have on my windows box. But it did not work as expected. I will check cmd switches. Sorry that I am not messaging you each via nicks. Forgot irc commands for that since I have not used IRC in years :-(.
03:41:51 <Bor0> if haskell has no such option you can use WINAPI CreateProcess(), by default (if you do not call ShowWindow()) the process should be windowless
03:41:56 <pjdelport> jpod: don't have to msg; other people might be interested in the answer :)
03:42:42 <pjdelport> jpod: nohup probably works at a different (POSIX) level, i think
03:43:01 <pjdelport> the cmd window is some Win32-specific thing
03:43:35 <jpod> OK. I meant in a way that shows a notification that I answered. Never mind. I am rusty. Bor0: I am just trying to get SciTE editor to invoke it without a terminal, not from a program.
03:45:26 <merijn> jpod: Might also want to hit the mailing list, I think that has a bigger audience, so is more likely to find other windows developers
03:46:58 <pjdelport> jpod: hmm, you could try start /min runhaskell ...
03:47:14 <pjdelport> it will flash a minimized window, but that's maybe an impromevent
03:47:19 <pjdelport> improvement, even
03:51:02 <jpod> OK. If Haskell does not have this built in like Python does, I can certainly look for other ways. I think I can write a little Python or VBScript runner. Trying start /min
03:51:51 <merijn> jpod: I think there's probably a built in way, it's just that the overwhelming majority here are linux/osx developers. So if you ask these questions at an unlucky time there might not be any windows developers around that know the answer
03:55:12 <notdan> @pl mconcat . map
03:55:12 <lambdabot> mconcat . map
03:55:19 <notdan> @ty mconcat . map
03:55:21 <lambdabot>     Couldn't match expected type `[c0]' with actual type `[a0] -> [b0]'
03:55:21 <lambdabot>     Expected type: (a0 -> b0) -> [c0]
03:55:21 <lambdabot>       Actual type: (a0 -> b0) -> [a0] -> [b0]
03:55:26 <notdan> erm
03:55:54 * hackagebot warp-tls 1.4.1.3 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.4.1.3 (MichaelSnoyman)
03:56:16 <ski> @type (mconcat .) . map
03:56:17 <lambdabot> Monoid c => (a -> c) -> [a] -> c
03:56:24 <jpod> merijin: Thanks. This is not critical anyway. I have a Linux box too but wondered how this might work on Windows.
03:56:34 <notdan> @hoogle Monoid c => (a -> c) -> [a] -> c
03:56:34 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
03:56:34 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
03:56:35 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
03:56:46 <notdan> oh, foldMap
04:08:17 <Aetherspawn__> building lambdabot
04:08:20 <Aetherspawn__> here goes everything
04:11:05 <fruitFly> anyone here us sublimeHaskell? The firs time I opened it it told me to change add_(path?) to true/false to enable some functionality, but every time I opne sublime now haskell module inspector compiles but nothing looks different? How can I test if it's working?
04:11:32 <jpod> merjin: pjdelport: Thanks. I just had to change the command subsystem to 0 in SciTE properties file. That made sure the window was not created.
04:11:39 <fruitFly> it didn't prompt me to change anything the second time opening it
04:17:51 <randomclown> why is generating random numbers such a pain
04:18:53 <randomclown> No other pure functional way apart from using the state monad?
04:19:14 <hpc> you can get an infinite list of randoms from an stdgen
04:19:30 <hpc> @hoogle Random a => IO [a]
04:19:30 <lambdabot> Control.Concurrent nmergeIO :: [[a]] -> IO [a]
04:19:30 <lambdabot> Test.QuickCheck.Gen sample' :: Gen a -> IO [a]
04:19:30 <lambdabot> Test.QuickCheck sample' :: Gen a -> IO [a]
04:19:37 <hpc> hmm
04:20:36 <randomclown> Infinite list of randoms doesn't really help in my case since it'd need to threaded through all the functions in the parameter
04:21:43 <randomclown> And now the state monad herpes has infested my code.
04:21:44 <hpc> if you are single-threaded and stuck in IO anyway, you can use randomIO
04:21:46 <hpc> :t randomIO
04:21:48 <lambdabot> Random a => IO a
04:22:02 <randomclown> Well either IO everything or State everything
04:22:25 <Aetherspawn__> Really
04:22:28 <Aetherspawn__> like, really ;__;
04:22:31 <Aetherspawn__> http://puu.sh/3861z/57c1cdedf9.png
04:22:44 <Aetherspawn__> when installing lambdabot. gg
04:23:12 <ski> @type System.Random.split  -- randomclown, would this help ?
04:23:12 <randomclown> Aetherspawn__: welcome to cabal
04:23:13 <lambdabot> RandomGen g => g -> (g, g)
04:23:34 <elliott> that doesn't look like a cabal problem at all
04:23:40 <elliott> that looks like using an OS lambdabot doesn't support problem
04:23:44 <Mortomes|Uni> randomclown: Random numbers in pure functional code would break referential transparency
04:23:55 <Aetherspawn__> I can't build lambdabot on my AWS because it requires more than 600mb ram to build
04:24:08 <Aetherspawn__> ;__; maybe I'll try a VM next
04:24:09 <elliott> probably you can use cygwin
04:24:22 <Aetherspawn__> hmm.
04:24:28 <Aetherspawn__> I'll just use a ubuntu vm
04:24:30 <randomclown> ski: not sure about split, I've heard it leads to lower quality randoms?
04:24:38 <Aetherspawn__> and the binary /might/ copy over into the aws
04:24:38 <hpc> Aetherspawn__: knowledge of how to compile lambdabot is a carefully guarded secret ;)
04:25:37 <ski> well, it would avoid state-threading of the PRNG state
04:25:52 <merijn> Or use a bigger AWS :p
04:25:57 <merijn> @quote bug.cost.me
04:25:57 <lambdabot> SimonMarlow says: This is the largest program (in terms of memory requirements) I've ever seen anyone run using GHC.  In fact there was no machine in our building capable of running it, I had to
04:25:57 <lambdabot> fire up the largest Amazon EC2 instance available (68GB) to debug it - this bug cost me $26.
04:26:14 <Botje> hahaha, that's dedication
04:26:16 <hpc> i love that quote
04:26:40 <Adeonasus> which program is that
04:26:49 <merijn> Adeonasus: Unknown, I think?
04:26:58 <randomclown> ski: yes it would, I'm probably just going to split unless it messes up my convergence
04:27:05 <randomclown> will soon find out
04:27:27 <hpc> http://www.haskell.org/pipermail/haskell-cafe/2010-June/079332.html
04:28:05 <hpc> it was a twitter data harvester
04:28:13 <hpc> and an overflow issue in the allocator
04:28:19 <merijn> The main difference between STRef and IORef is that you can "purify" operations that use STRef's, right?
04:28:27 <Botje> yes
04:28:36 <danr> yep
04:28:46 <merijn> oh, wait. I guess STRef can't be accessed concurrently anyway so that's kind of a silly comparison
04:28:47 <hpc> that is to say, it's the same as the difference between ST and IO
04:29:45 <jmcarthur> merijn: STRef RealWorld can be accessed concurrently
04:32:14 <tero-> is "(Just <$> decimal) <|> (pure Nothing)" a valid way to parse Maybe Integer?
04:32:43 <randomclown> Rank2Types implies ExplicitForall right?
04:33:08 <merijn> randomclown: Yeah, iirc
04:33:33 <merijn> At least, my Rank2Types code doesn't have ExplicitForall and I don't get complaints :p
04:33:43 <randomclown> cool
04:36:49 <tero-> hmm.. it works if I add some garbage in the end but not if the input string has only digits
04:37:21 <kqr> i can't for the life of me figure out why i didn't think to ask about this here earlier! i read somewhere a few months ago that both haskell and lisp work in terms of "code is data." however, it was argued that haskell does it slightly different than lisp. i can't imagine the exact way it was said but it was very enlightening. does anyone have any idea of what i'm talking about?
04:38:33 <pjdelport> people probably mean those very differently for the two languages
04:38:49 <kqr> yeah
04:38:59 <kqr> in the case of haskell it had to do with.. i don't know, compisition, somehow
04:39:04 <kqr> composition*
04:39:06 <kqr> and monads and stuff like that
04:39:32 <kqr> i'm not enough of a mathematician to piece it together myself, but I remember reading it and getting it explained to me was a revelation
04:40:12 <merijn> kqr: I actually wouldn't argue that "code is data" in haskell
04:40:16 <pjdelport> for Lisp, they probably mean syntactic macros (compare Template Haskell); for Haskell, they probably mean the kind of reified control allowed by non-strict semantics, monads, etc. (compare Lisp/Scheme first-class continuations)
04:40:48 <merijn> I would be moderately okay with the observation that laziness let's you use data as code/control flow
04:40:56 <ski> more like "functions are data (FSVO that term)"
04:40:58 <pjdelport> in Haskell, data is code :)
04:41:19 <merijn> ski: That's now what people usually mean by code is data
04:41:23 <pjdelport> a Haskell list is actually a loop
04:41:30 <merijn> s/now/not
04:41:31 <pjdelport> etc.
04:41:39 <ski> merijn : it's not what i would think it would mean in a Lisp context ..
04:42:42 <ski> oh, "not"
04:45:40 <kqr> hm
04:45:46 <kqr> i wonder if it was someone here saying it
04:47:19 <ski> merijn : .. i think i've seen that usage, though
04:50:26 <pjdelport> ski: an example of the parallel is the subset of lisp macros that essentially just exist in order to delay evaluation of their arguments
04:50:57 <pjdelport> such as if, and other control structures
04:51:12 <pjdelport> in a non-strict language like Haskell, those reduce to plain functions
04:52:13 <ski> i suppose, though i view those as mostly convenience
04:59:11 <Aetherspawn__> I would have thought it the other way around
04:59:13 <Aetherspawn__> data is code
04:59:46 <Aetherspawn__> (since that makes sense -- any data has to come from a function typed to return said data which is really just a function to ghc or whatever)
05:00:24 <elliott> that's not really true.
05:01:17 <merijn> Aetherspawn__: Oh? What is 'c', then?
05:01:31 <Aetherspawn__> hrnng you got me there.
05:01:51 <Aetherspawn__> Oh, maybe, idk
05:01:52 <merijn> See also
05:01:58 <Aetherspawn__> 'c' = \_ -> 'c'
05:02:00 <Aetherspawn__> lol
05:02:03 <merijn> @google conal haskell everything is a function
05:02:04 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
05:02:04 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
05:07:25 <Aetherspawn__> merijn, good blog
05:07:27 <Aetherspawn__> thanks for link
05:07:37 <pjdelport> http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html
05:07:47 <pjdelport> something similar applies in this case
05:10:58 <pjdelport> code and data are two ways of thinking about things, but under the hood a Haskell implementation can constantly convert between one and the other, as convenient
05:11:10 <Aetherspawn__> :t |
05:11:11 <lambdabot> parse error on input `|'
05:11:14 <magneticduck> does anybody else here think there should be a function in prelude defined as (foldl (.) id)?
05:11:16 <Aetherspawn__> :t (|)
05:11:17 <lambdabot> parse error on input `|'
05:11:24 <merijn> Aetherspawn__: | is reserved
05:11:33 <magneticduck> I use that function so much and I have to either make a silly little export of it or write it in manually
05:11:38 <Aetherspawn__> :t (_|_)
05:11:39 <lambdabot> parse error on input `|'
05:11:50 <merijn> :t (.|.)
05:11:50 <Aetherspawn__> Well, okay. I have no idea what _|_ is, lol.
05:11:51 <lambdabot> Bits a => a -> a -> a
05:12:05 <Aetherspawn__> I thought it might have been some operator | with _ applied to each side
05:12:16 <merijn> Aetherspawn__: _ is not an operator symbol so you can't have operators with _ in them
05:12:17 <magneticduck> > (foldl (.) id) (map (+) [1, 2. ..5]) $ 2
05:12:18 <lambdabot>   <hint>:1:32: parse error on input `..'
05:12:28 <magneticduck> > (foldl (.) id) (map (+) [1, 2 ..5]) $ 2
05:12:29 <lambdabot>   17
05:12:38 <pjdelport> your lists and other data structures will be fused into code loops, and your functions and code evaluation will suspended and reified as thunk data
05:12:39 <magneticduck> that should be in the prelude.
05:13:10 <magneticduck> although I know that my example is completely useless...
05:13:13 <merijn> magneticduck: libraries@ is the place to suggest changes, but be warned that changes to prelude are not always received favourably :)
05:13:30 <magneticduck> yeah
05:13:30 <Aetherspawn__> bool would be nice
05:13:42 <Aetherspawn__> as shorthand for if
05:13:52 <merijn> Aetherspawn__: What would it return?
05:13:56 <merijn> oh
05:14:00 <merijn> you mean the famous if'
05:14:03 <merijn> :t if'
05:14:04 <lambdabot>     Not in scope: if'
05:14:04 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
05:14:09 <magneticduck> heh
05:14:11 <merijn> wut?
05:14:15 <Aetherspawn__> bool b x y = if b then x else y
05:14:27 <supki> no
05:14:28 <merijn> Aetherspawn__: Yeah, usually that's called if' :)
05:14:32 <magneticduck> :t if'
05:14:33 <Aetherspawn__> and yeah I called it if' here once, and people said bool would be a better name for it
05:14:34 <lambdabot>     Not in scope: if'
05:14:34 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
05:14:38 <Aetherspawn__> in line with maybe, either, etc
05:14:38 <supki> bool f t b = if b then t else f
05:14:39 <magneticduck> ::<
05:14:52 <magneticduck> lol supki
05:14:57 <Aetherspawn__> err, wut
05:15:03 <merijn> Aetherspawn__: Nicer for composition
05:15:09 <Aetherspawn__> oh, yeah
05:15:15 <supki> it's like maybe for Bool
05:15:24 <supki> :t maybe
05:15:25 <lambdabot> b -> (a -> b) -> Maybe a -> b
05:16:39 <Aetherspawn__> ?: is really cool
05:16:39 <lambdabot> Maybe you meant: . ? @ v
05:16:54 <Aetherspawn__> Bool -> (a, a) -> a
05:16:55 <wael> hey there
05:17:35 <Aetherspawn__> b ?: (f,g) = if b then f else g
05:17:35 <magneticduck> oh wait... *gets an idea*
05:17:40 <magneticduck> is (a -> a) a Monoid?
05:17:42 <Aetherspawn__> so, basically C unary operator
05:17:56 <elliott> magneticduck: newtype Endo a = Endo { appEndo :: a -> a } has a Monoid instance
05:17:56 <Aetherspawn__> im a noob I dont know what that means
05:18:17 <magneticduck> elliott: but wouldn't you say that all (a -> a) functions should be monoids?
05:18:29 <elliott> no, because the instance is Monoid a => Monoid (r -> a)
05:18:36 <magneticduck> mempty = id, mappend = (.), mconcat = (foldl (.) id)
05:18:38 <elliott> which is a more general instance that infers better
05:18:41 <elliott> yes, that is what Endo's instance is
05:18:42 <magneticduck> ah
05:19:05 <magneticduck> > mconcat (map (+) [1, 2..5]) $ 0
05:19:07 <lambdabot>   Ambiguous type variable `a0' in the constraints:
05:19:07 <lambdabot>    (GHC.Enum.Enum a0)
05:19:07 <lambdabot>     ...
05:19:14 <magneticduck> uh
05:19:16 <magneticduck> lol fail
05:19:25 <magneticduck> misread elliott's explination
05:19:27 <supki> > ala Endo foldMap (map (+) [1, 2 ..5]) 2
05:19:29 <lambdabot>   17
05:19:46 <magneticduck> ala?!?
05:20:01 <magneticduck> can't find on hoogle
05:20:26 <NinjaPenguin> > ala
05:20:27 <magneticduck> :t ala
05:20:28 <lambdabot>   Ambiguous type variables `s0', `a0' in the constraint:
05:20:28 <lambdabot>    (Control.Lens.Wra...
05:20:28 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
05:20:42 <magneticduck> wut
05:20:58 * hackagebot modbus-tcp 0.0 - Communicate with Modbus devices over TCP  http://hackage.haskell.org/package/modbus-tcp-0.0 (RoelVanDijk)
05:21:07 <quchen> magneticduck: ala f = "runF" . mconcat . "toF"
05:21:20 <quchen> ala Endo = appEnde . mconcat . map Endo
05:21:21 <quchen> etc.
05:21:34 <quchen> It's a Lens thing.
05:21:36 <magneticduck> oh
05:21:38 <magneticduck> k
05:21:40 <magneticduck> oh k
05:22:51 <Aetherspawn__> @src hoist
05:22:51 <lambdabot> Source not found. There are some things that I just don't know.
05:22:57 <Aetherspawn__> :t hoist
05:22:58 <lambdabot> Not in scope: `hoist'
05:23:02 <Aetherspawn__> ;_;
05:24:36 <quchen> Aetherspawn__: http://hackage.haskell.org/packages/archive/mmorph/latest/doc/html/Control-Monad-Morph.html#v:hoist
05:24:53 <quchen> ^ Hayoo.
05:25:22 <elliott> quchen: huh? that's not what ala is
05:25:30 <Aetherspawn__> Bleh, I dont understand any of that
05:25:43 <magneticduck> the mystery of Ala
05:25:58 * hackagebot egison 3.0.7 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-3.0.7 (SatoshiEgi)
05:26:20 <byorgey> @type ala
05:26:21 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
05:26:25 <elliott> it's ala Endo f = appEndo . f Endo
05:26:54 <byorgey> ala Endo foldMap [(+1), (*2), (^2)] 4
05:26:59 <byorgey> > ala Endo foldMap [(+1), (*2), (^2)] 4
05:27:01 <lambdabot>   33
05:28:18 <byorgey> also, it was a Control.Newtype thing before it was a lens thing.  I think pigworker came up with the idea and djahandarie implemented it, IIRC.
05:28:30 <byorgey> but it fits very nicely into the more general lens framework.
05:29:12 <quchen> elliott: That was just my gut feeling talking there. "Do the wrapping automatically" would probably have been better, yeah
05:40:01 <rightfold> Hello.
05:40:16 <applicative> hey rightfold
05:40:35 <QInGW> hi
06:13:41 <Taneb> I've found a weird bug in null-canvas, that is probably in blank-canvas too
06:13:46 <hseg> I'm writing my own typeclass for converting between two representations of some data. Problem is, for some types, the conversion is dependent on some external data. How should I define the class?
06:16:03 <hseg> Specifically, I'm writing a compiler for a toy OO language for school. The language spec requires that all function definitions be prefixed by their enclosing class's name. No function will be converted without converting its class first, which gives me access to the class name. However, I'd like for the conversion function to work both on classes and functions, modulo some hackery.
06:18:43 <randomclown> hseg: I don't think typeclasses do what you think they do
06:19:03 <hseg> What do you think I think typeclasses do?
06:20:37 <randomclown> Without any more information I have no idea what you are doing. It's a big red flag when you said you want to convert typeclasses into each other
06:21:07 <Taneb> randomclown, he said he's using typeclasses to translate one representation of data into another
06:21:08 <simukis_> randomclown: He said he's writing typeclass for converting between two different representations of data.
06:21:29 <Taneb> I presume he wants something like "class ConvertRep a b where convert :: a -> b"
06:21:42 <Taneb> Except some conversions need another parameter
06:22:14 <hseg> Precisely. And the additional parameter is always available earlier in the call graph
06:22:22 <supki> instance ConvertRep A (AnotherParameter -> B) where
06:22:26 <supki> also that's awful
06:22:29 <Taneb> So... class ConvertRep a b where type ExternalData a b; convert :: ExternalData a b -> a -> b
06:22:38 <byorgey> hseg: you could use an associatied type
06:22:43 <supki> why not just convertFunction and convertClass ?
06:22:43 <byorgey> what Taneb just said
06:22:46 <Taneb> And for most of them "type ExternalData Foo Bar = ()"
06:23:35 <hseg> Oh. That could work. Also would be more general than my previous idea. Will have to read up a bit on associated types, though.
06:24:15 <elliott> so do you always call "convert" knowing what a and b are?
06:24:26 <elliott> given that you have to pass an unknown ExternalData a b value otherwise
06:25:34 <hseg> elliott: I don't understand the question
06:27:12 <randomclown> are STUArrays O(1) access?
06:27:26 <elliott> hseg: when you call "convert", do you know what the concrete types "a" and "b" are?
06:28:08 <hseg> Yes.
06:28:50 <byorgey> randomclown: yes.
06:29:19 <hseg> The initial representation is emitted by a parser, and then I just have a couple of conversion compositions, before I write the output to a file.
06:29:27 <elliott> hseg: I suggest just writing multiple functions then
06:29:30 <Jookia> Hello!
06:29:33 <elliott> instead of using a typeclass
06:29:55 <byorgey> hi Jookia
06:30:08 <hseg> Hi Jookia!
06:30:15 <Jookia> I've been using my parsed command line arguments to do things (exciting), but I've hit something that doesn't sit well with me
06:30:59 <Jookia> Damn.
06:31:18 <hseg> elliott: May I ask why?
06:31:39 <Jookia> Now that I've typed that up and realized a better way to do it, maybe I should just hang here :V'
06:32:42 <elliott> hseg: because I don't see that you gain anything from this typeclass approach except complexity. especially given that you now need an associated type, and things that don't depend on any external data will have ugly invocations like "convert ()"
06:34:30 <hseg> Point taken. This does mean that I need to come up with unique names for each such function.
06:35:37 <hseg> Thanks. Need to leave.
06:35:56 <cmtptr> Can someone please explain to me what my problem is here?  I ask ghci to tell me the type of a function, but then ghc barfs on it: http://hpaste.org/89286
06:36:30 <Botje> cmtptr: try main = print (fac 42) instead
06:37:06 <cmtptr> Botje, thanks that removed the second error.  I still have the first, though
06:37:44 <supki> cmtptr: note that line 6 and 7 define two different fac functions (probably not what you intended)
06:38:35 <cmtptr> supki, oh I didn't realize that.  How do I achieve what I intended in ghci?
06:39:18 <supki> let fac 0 = 1; fac n = n * fac (n - 1)
06:39:20 <Botje> cmtptr: well, then add Eq a to the context
06:39:27 <Botje> fac :: (Num a, Eq a) => a -> a
06:39:35 <supki> that will also reveal correct type for fac :)
06:40:00 <cmtptr> excellent, thanks guys!
06:40:36 <supki> cmtptr: also, in haskell2010 Num implies Eq, so your type is correct, but in GHC it does not, so you need additional constraint
06:43:14 <merijn> Presumably switching on haskell2010 makes it correct in GHC too?
06:43:55 <cmtptr> is 2010 the latest standard or is there a more recent?
06:44:02 <merijn> 2010 is the latest
06:44:06 <cmtptr> thanks
06:44:37 <merijn> But the standard is update pretty infrequently and is pretty conservative (and by pretty I mean *really* :p)
06:45:44 <cmtptr> it's weird because coming from C, usually when compilers deviate from the standard they become more liberal in what they accept, not more restrictive :p
06:47:19 <merijn> cmtptr: GHC defaults to Haskell98 unless otherwise specified, I think
06:47:34 <merijn> In haskell98 that behaviour is correct
06:47:40 <cmtptr> ah, I see
06:48:00 <supki> it's more liberal in a sense
06:48:12 <supki> you can have Num instances for which Eq is not definable (in general)
06:48:14 <supki> like functions
06:48:34 <merijn> cmtptr: GHC only becomes more liberal if you explicitly enable extensions
06:49:03 <Taneb> merijn, GHC defaults to Haskell 2010 with a handful of exceptions
06:49:10 <Taneb> For instance, the Num and Bits classes
06:49:29 <merijn> Ah
06:49:34 <Jookia> is it possible to have some functions that return IO functions (that haven't been executed) pure?
06:49:55 <Taneb> Jookia, yes
06:50:00 <merijn> Jookia: I don't understand what that means
06:50:18 <merijn> Jookia you can return IO actions without executing said action, yes
06:50:19 <Taneb> > length [print 1, putStrLn "hello", getLine >>= putStr]
06:50:20 <lambdabot>   3
06:50:27 <quchen> Jookia: I frequently use IOs containing IOs, e.g. to send data to a dedicated printer thread.
06:50:39 <merijn> Jookia: In fact, not executing is the normal behaviour
06:51:01 <Jookia> What I mean is I have a 'String -> TaskFunc' where 'TaskFunc = TaskArgs -> IO Bool'
06:51:02 <Taneb> Jookia, my example showed calculating the length of a list of IO actions without executing them
06:51:02 <merijn> > const True (putStrLn "ola")
06:51:04 <lambdabot>   True
06:51:20 <Jookia> will my String -> TaskFunc be impure due to the IO at the end?
06:51:48 <merijn> Jookia: No, but that also depends on what you mean by impure...
06:52:16 <byorgey> Jookia: a function of type  String -> TaskFunc  is exactly the same as a function of type   String -> TaskArgs -> IO Bool
06:52:36 <Jookia> byorgey: That's what I thought.
06:52:36 <byorgey> asking whether something is "pure" or "impure" does not really make sense.
06:52:43 <byorgey> your function will return a result in the IO monad.
06:52:55 <Jookia> I'm trying to use as little IO as possible I guess?
06:53:05 <merijn> s/result in the IO monad./an IO action.
06:53:37 <byorgey> merijn: thanks, you're right, that's more precise.
06:53:41 <merijn> Jookia: You can think of "IO a" as being a program fragment that produces an "a" when executed
06:53:55 <Jookia> merijn: Ah.
06:54:23 <merijn> Jookia: There is only one way to "execute" such a program statement, the runtime executes the "main" IO action if your program
06:54:47 <merijn> You can, however, glue smaller program fragments (IO actions) into bigger program fragments using ">>=" and do-notation
06:55:07 <merijn> But the only way to execute them is if the execution of "main" executes
06:55:16 <Jookia> Ah
06:55:35 <Jookia> I have a list of functions that just need to be executed, but if one of them fails, I want to stop executing them.
06:56:06 <merijn> Jookia: Look at the monad-loops package?
06:56:14 <merijn> Maybe it contains something useful for you
06:56:17 <merijn> @hackage monad-loops
06:56:18 <lambdabot> http://hackage.haskell.org/package/monad-loops
06:56:52 <merijn> It has things like "whileM" that keep executing IO actions until a certain condition is no longer true
06:57:31 <Jookia> Would it be better to just write a recursive function?
06:58:32 <merijn> Jookia: That would be the same as the stuff in monad-loops. The functions in monad-loops are just very generic recursions using the Monad typeclass
06:58:32 <RichyB> Not necessarily. Similarly to writing "map f" instead of "fix (\r l -> case l of { [] -> []; (a:as) -> f a : r as; })"
06:59:02 <RichyB> using a specific loop HOF often shows your intention more directly than using general recursion.
06:59:14 <merijn> byorgey: Yeah, I think being pedantic about calling things "IO actions" helps keep newbies unconfused. "result in the IO monad" is so vague and ambiguous
06:59:31 <Jookia> I'm going to go to bed. Thanks for your helps #haskell!
07:01:24 <merijn> Quick check, are there any top level definitions in haskell other than: --, {-, data, newtype, type, foreign, import, module, class, instance, infix, type signatures and function/value definitions?
07:04:38 <Botje> standalone derive things?
07:06:51 <merijn> Good catch
07:06:57 <merijn> I forgot $( for TH too
07:09:12 <Botje> and the {-#LANGUAGE ... #-} thing, if you didn't have that already.
07:12:48 <merijn> Yeah, I shoved those under {-
07:16:07 <quchen> merijn: default
07:17:38 <quchen> ... or I'm mis-remembering something
07:17:55 <byorgey> quchen: no, you're right
07:18:20 <quchen> I just remember there was this keyword that I never use and every time I see it I'm surprised.
07:21:17 <merijn> default is not top level, that's only inside a class/instance definition, right?
07:22:03 <quchen> merijn: No, it's top level, report page 35
07:22:32 <quchen> Actually, reading the report about what default does finally answered my long-term question about why GHC "usually" chooses Integer and Double.
07:22:50 <quchen> merijn: Thanks for asking that question :-D
07:23:02 <merijn> Which section is that?
07:23:11 <quchen> Chapter 4
07:23:21 <quchen> The beginning lists the grammatic rules
07:23:35 <quchen> And in there theres "topdecl -> ... default ..."
07:24:11 <merijn> Yeah, I see it
07:36:55 <warrrrr> hello, im trying ti play with ord and implement my own variation - starting with taking prelude's implementation to play with. what's wrong with this though: http://hpaste.org/89289
07:37:05 <warrrrr> i just renamed some functions
07:37:11 <warrrrr> and added a maybe instance
07:38:23 <Botje> what is it complaining about?
07:39:00 <warrrrr> it says theres an ambigius tye variable
07:39:04 <warrrrr> ill paste the error
07:39:26 <warrrrr> oh i cant copy paste on windows sadly
07:39:43 <warrrrr> does it look wrong, what i did ?
07:42:35 <Sculptor> hello
07:44:44 <ski> ello
07:44:54 <Jefferson> llo
07:45:21 <Cale> lo
07:45:34 <Botje> warrrrr: I can't download your code and check it for you, don't really have time
07:47:06 <ski> warrrrr : why `Maybe' ?
07:47:28 <ski> warrrrr : you forgot to update the "minimally complete" comment
07:47:33 * geekosaur guessed that POrd meant partial ordering
07:47:35 <obiwahn> hi i have had a lecture on haskell / functional programming it was fun but i never got really into haskell i would love to read a guide that lets me actually do things: like reading a xml / ini file from disk and generate some output. probably the most important is to learn how to use other peoples libs
07:47:56 <geekosaur> although the comparisons are then the wrong types
07:48:16 <ski> warrrrr : if you want partial order, why "note that (min x y, max x y) = (x,y) or (y,x)" (update ?) or no `Maybe' in `pmin',`pmax' ?
07:48:38 <Botje> obiwahn: real world haskell is full of those things
07:48:46 <dipra> Is there any learning video-course with subtitle about Haskell? (English subtitle is important for me)
07:48:50 <obiwahn> that is a book?
07:48:52 <warrrrr> ski:  forgot to delete the comments after ive got the errors, just sloppy work
07:48:56 <Botje> obiwahn: although it has a tendency to get snowed in with technical details
07:49:08 <Botje> obiwahn: yes. free to read online
07:49:09 <obiwahn> deatails are good
07:49:11 <ski> @where RWH  -- obiwahn
07:49:11 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
07:49:22 <obiwahn> brr spelling .. sorry:)
07:49:25 <obiwahn> thanks
07:49:35 <merijn> Ok, poll time!
07:49:48 <obiwahn> how old is the book?
07:49:56 <obiwahn> younger than 2 years?
07:49:56 <liyang> merijn: NAck.
07:50:00 <merijn> I'm trying to make a better vim code folding plugin for haskell and trying to decide how things "should" be folded
07:50:03 <merijn> http://hpaste.org/89290
07:50:05 <ski> @poll-list
07:50:05 <lambdabot> ["(++)","ConfusedWithVixenSituation","FlavaOfJRuby","Prelude-(.)?","best-programming-language","best-spoken-language","food","funniest-thing-in-the-whole-world","naming","nethack","president","prove-
07:50:05 <lambdabot> >","remove@src","sleep"]
07:50:18 <obiwahn> mmh 2008:9
07:50:21 <ofan> 5 years
07:50:26 <merijn> Entries with a + will be folded into a single bigger fold
07:50:55 <merijn> My question is: should multiple adjacent $() TH splices and multiple adjacent class definitions be folded together?
07:50:57 <liyang> obiwahn: Learn You a Haskell and Programming in Haskell might give you better foundations that don't date so quickly.
07:51:16 <obiwahn> i think i read most of that
07:51:39 <obiwahn> but i has been a while:)
07:51:47 <merijn> obiwahn: Finishing that and then moving on to RWH should be a good way to start
07:52:10 * liyang wouldn't consider RWH 'moving on'...
07:52:21 <obiwahn> why
07:52:49 <liyang> Too much RW stuff that you've probably already done in other languages anyway. And dated.
07:53:06 <liyang> Just go to Hackage and start browsing around.
07:53:45 <merijn> liyang: I think you underestimate the difficulty of starting with stuff like monad transformers, etc.
07:53:56 <adinapoli> I think that if I had a "intermediate/advanced" textbook on Haskell I'll jizz in my lambda pants. Sorry for the out-of-the-blue comment, I was just lurking :D
07:54:01 <liyang> Oh, LYaH doesn't cover that?
07:54:12 <liyang> Does RWH?
07:54:23 <merijn> Yes
07:54:30 <obiwahn> yes it gets a bit boring if you read the same stuff over and over again so i tend to get references but as i am new to functional programming it might do some good and i have wasted time with worse
07:54:54 <liyang> obiwahn: well it's available online. Stop wasting time talking to us and go read it. :)
07:58:56 <merijn> No opinions whatsoever on how to properly fold haskell code? #haskell i am dissappoint
08:00:01 <liyang> merijn: fold according to Haskell lexical blocks.
08:00:33 <merijn> liyang: That's a separate issue which I consider "obvious" so don't need input on
08:00:44 <liyang> And additionally accept foldmarker.
08:01:05 <merijn> I'm undecided on whether multiple class/TH splices should be folded together in a "super" fold
08:01:29 <liyang> I'm not sure I see what you mean.
08:01:59 <supki> merijn: so type family (instance) declarations will fold under "type"?
08:02:09 <liyang> If it's a single top-level line, fold if there are no intervening blank lines.
08:02:39 <liyang> s/a single//; s/line/&s/
08:03:17 * liyang folds manually, FWIW.
08:03:19 <merijn> supki: Oh, good point
08:03:45 <dipra> I'm gonna to start Haskell by a book! I've a list of book, Which ones are not uptodate? which one is the best one?
08:03:45 <dipra> list of My Books: Haskell, the craft of functional programming ⚃ Learn You a Haskell for Great Good! 2011 (Miran Lipovaca) ⚃ The Haskell Road to Logic, Math and Programming Kees Doets and Jan van Eijck March 4, 2004 ⚃ The Haskell school of expression (2000) (Professor_Paul) ⚃ Yet Another Haskell Tutorial (Hal Daum ́e III) ⚃ Two Dozen Short Lessons in Haskell, a participatory textbook on functional programming (Rex Page, University of Oklahoma) ⚃ Rea
08:03:45 <dipra> which one? if there is one a beter book/tutorial, let me to know, thank you.
08:03:52 <merijn> supki: I should treat type familyt separately yeah
08:04:10 <supki> also data families, I think
08:04:31 <merijn> supki: Those are only inside class/instance blocks
08:04:41 <supki> really?
08:04:55 <liyang> merijn: you're thinking of associated types.
08:04:56 <merijn> I think so? How do you declare a data family outside a class?
08:05:07 <liyang> type family Foo x = ...
08:05:09 <merijn> Now I'm unsure? :(
08:05:15 <liyang> or data.
08:05:38 <merijn> hmm
08:05:44 <merijn> ok
08:05:51 <supki> also there is 'newtype instance'
08:06:20 <liyang> But no 'newtype family'! Aren't extensions wonderful.
08:06:28 <merijn> Should those be folded into the "data" top level?
08:06:50 <liyang> Fold if there's no intervening blank line.
08:07:16 <ski> dipra : iiuc, YAHT is perhaps not up to date
08:07:33 <ski> there's also RWH
08:07:38 <ski> @where RWH
08:07:38 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
08:07:39 <liyang> Don't try to add too much logic to handle various extensions... you'll never keep up.
08:07:42 <merijn> liyang: The goal is "fold blank line separated blocks, then fold those blocks"
08:08:58 <liyang> merijn: oh like a second level? What if someone writes code that doesn't conform to what you expect?
08:09:06 <merijn> Like how?
08:09:38 <liyang> I don't know. I'm just suggesting to keep it simple.
08:09:39 <merijn> If the blocks are not contiguous they can't be folded into a second level
08:10:03 <merijn> That's not a big deal
08:10:44 <tomboy64> i want to write a program that executes operations on rational fractions in a parallel fashion. i tried to do it in c with the gmp lib, but the parallel bit is becoming cumbersome. now i want to try another approach with haskell. now to the real question: is using gmp reasonably easy? and how difficult is it to get something with stm work?
08:10:49 <tomboy64> *working?
08:11:12 <armlesshobo> i'll join in over here
08:11:27 <armlesshobo> merijn: i feel the same way about what liyang is getting at.
08:12:12 <merijn> I don't feel that collapsing a second level is really complicated
08:12:32 <armlesshobo> that you'd inadvertently coerce developers into writing a certain way to be able to fold code.
08:12:46 <merijn> Well, good!
08:13:20 <merijn> If I subtly goad people into writing code in a style that pleases me, mission accomplished!
08:13:34 <armlesshobo> merijn: you are an evil mastermind!
08:13:35 <armlesshobo> :P
08:13:51 <armlesshobo> you were serious when you said you wanted to take over the world.
08:13:55 <liyang> Too much agenda for me. Pass, lol.
08:13:55 <merijn> If they don't like it, they can go implement their own folding. With blackjack! And hookers!
08:14:01 <armlesshobo> :D
08:14:05 <Botje> in fact, forget the folding!
08:14:05 <merijn> In fact, forget the folding!
08:14:21 <merijn> liyang: If you fold manually anyway, what do you care? :p
08:14:33 <armlesshobo> i don't ever need to fold
08:14:43 <dipra> Is there any learning video-course with subtitle about Haskell? (English subtitle is important for me)
08:14:47 <armlesshobo> bro, do you even fold?
08:14:48 <merijn> I don't ever need to fold either. I don't ever need autoindent, either
08:14:59 <merijn> But I still like having it available!
08:15:13 <armlesshobo> having it just to have it. i see :)
08:15:15 <merijn> (Speaking of which, implementing non-sucky auto-indent is my next mission after solving folding)
08:15:22 <applicative> dipra: 'learn you a haskell', which is also online.  the others are pretty out of date; it is a defect of all elementary tutorials and texts not to emphasize IO adequately, Real World Haskell is best that way, but you can ask here.
08:15:26 <satc> I am using haskell-mode for emacs and whenever I open the file and press tab it opens a help message about haskell-mode-hook and I have to manually turn on indentation. I am not an emacs expert so if anybody else had the same problem ??
08:15:28 <liyang> merijn: because I care...
08:16:13 <liyang> merijn: usually I'm working in a 70-odd row terminal, so I only fold large (a screenful or two) chunks of code at a time.
08:16:22 <applicative> dipra: I think you'll have trouble finding such video...
08:16:47 <armlesshobo> liyang: are you doing this willingly?
08:16:56 <armlesshobo> dipra: I doubt such thing exists
08:17:15 <liyang> armlesshobo: doing what exactly?
08:17:29 <armlesshobo> liyang: working in a terminal like that?
08:17:45 <liyang> armlesshobo: I just make it the full height of the screen.
08:18:28 <ski> merijn : what happens if i indent the whole of a module, except `module' line and intitial pragmas (like `LANGUAGE') ?
08:18:59 <merijn> ski: How would I know, I just start planning what it *should* do
08:19:14 <ski> ok
08:19:29 <liyang> You should write a full formal requirements specification.
08:19:47 <merijn> ski: Also, if you do that we won't be friends anyway, so I don't care about supporting your awful habits!
08:20:14 * ski grins
08:20:38 <merijn> In fact, if I could I would program it to stab you in the face upon encountering code like that
08:20:39 * liyang feels mildly guilty for puchasing a YAPC::Asia ticket now.
08:21:40 <dipra> applicative: yes, "C9 Lectures" has a series of course without subtitle, (http://channel9.msdn.com/tags/C9+Lectures/); If pepople, here, know english, it'll be appreciated to make subtitles for them!
08:21:45 <fryguybob> tomboy64: Can you explain more what you are trying to do?
08:23:38 <tomboy64> fryguybob: i have an algorithm performing a specific geometrical computation. that computation can be split up into lots of tiny parallelizable operations. this is important since the algorithm is supposed to iterate in the magnitude of 10^15 times, so speed is imperative.
08:24:49 <tomboy64> fryguybob: the other thing is that the variables i am handling will be (necessarily exact) rational fractions of a huge size, easily millions of digits long each. that means i require safe operations on bignums, hence i wanted to use the gmp library for c.
08:26:43 <tomboy64> fryguybob: so yeah, these are the 2 main requirements for my program. how to get there is secondary.
08:27:20 <tomboy64> or rather, how to implement it is secondary. basically i'm just looking for "the right way" to do it in haskell
08:27:29 <fryguybob> tomboy64: STM solves concurrency problems which may or may not be beneficial for achieving parallelism, typically you would expect it to be used in conjunction with some data structure that the computation will touch part of, but not know what part.
08:28:09 <fryguybob> tomboy64: If it is clear before the computation how the structure will be visited and manipulated you might have something that is data parallel and should use something appropriate for that.
08:28:34 <tomboy64> fryguybob: data parallel?
08:29:51 <tomboy64> and yes, i will use one data structure which will be repeatedly visited. at certain "checkpoints" the program will have to synchronize the data, but in between checkpoints parts of the algorithm will run in parallel.
08:29:53 <fryguybob> tomboy64: So for instance, if you geometry is a grid and your computation visits each pixel, the locality of the computation is known before you do anything.
08:31:18 <tomboy64> yes, kind of like that
08:31:20 <dipra> Do you have any idea to create subtitle for this: http://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals/ , by online collaboration?
08:32:55 <tomboy64> fryguybob: do you have more information about gmp in haskell?
08:32:56 <fryguybob> tomboy64: If the dependencies are all known upfront STM probably won't help you (it might).  But if you don't know where you will need to synchronize think of STM as a way to express how to make consistent updates to your data structure.
08:33:37 <tomboy64> ahhh, i see
08:33:45 <dipra> Are you willing to contribute for `subtitl`ing that series of film?
08:33:55 <fryguybob> tomboy64: I don't know much about it but it is used for Integer and Integer is used for Rational
08:34:07 <deltaluca> is there any practical use to nested maybe types? ie. Maybe (Maybe a) ?
08:34:23 <Botje> deltaluca: I use them all the time.
08:34:30 <deltaluca> i can't think of a scenario where you wouldn't want to treat Just (Nothing) and Nothing as the same thing
08:34:48 <Cale> deltaluca: Perhaps you have two different ways to fail
08:35:00 <tomboy64> fryguybob: gmp also provides rational fractions (mpq_t) and and floating point (mpfr_t) types
08:35:28 <tomboy64> fryguybob: or do you mean it is used by ghc natively?
08:36:09 <fryguybob> tomboy64: GHC's runtime uses gmp for Integer, I don't think it uses it for Rational, but I could be wrong.
08:36:33 <tomboy64> okay. let's see.
08:36:36 <tomboy64> thanks so far.
08:36:43 <pjdelport> deltaluca: you could have e.g. reading and parsing a value
08:37:36 <pjdelport> with Nothing being a read failure, and Just (Nothing) a parse failure
08:38:01 <pjdelport> with different meanings and responses
08:38:03 <deltaluca> sounds a bit archaci
08:39:13 <bitonic> deltaluca: there are many uses.  for example I use a library by edwardk that uses them to represent bound variables
08:39:29 <pjdelport> deltaluca: it's a bit like asking whether there's any use for nested lists
08:39:51 <edwardk> @hackage bound
08:39:52 <lambdabot> http://hackage.haskell.org/package/bound
08:40:54 <ski> @src Rational
08:40:54 <lambdabot> type Rational = Ratio Integer
08:51:31 <randomclown> is there a way to turn Data.Set.map into mapM?
08:51:43 <randomclown> mapM for sets essentially
08:52:23 <geekosaur> @src mapM
08:52:23 <lambdabot> mapM f as = sequence (map f as)
08:53:18 <geekosaur> probably need a toList in there, since sequence wants a list
08:53:28 <merijn> randomclown: Maybe if Map is Traversable?
08:54:22 <merijn> It's not, afaict
08:54:33 <merijn> I know lens probably has some stuff you could use?
08:55:01 <randomclown> merijn: can you show me how data.traversable could work if the structure was an instance?
08:55:23 <randomclown> oh data.traverable has a mapM
08:55:24 <edwardk> lens doesn't provide a traversal for sets because there isn't a law abiding way to do it, as you change the number of targets when there is a duplication
08:55:25 <randomclown> duh
08:55:28 <Peaker> Map is Traversable, but Set isn't
08:55:53 <merijn> Yeah, I meant Set
08:55:58 <randomclown> Peaker: so I'll just need to import mapM from traversable and bam done.
08:56:01 <Peaker> edwardk, isn't that broken in the same way Lens.filter is?
08:56:02 <randomclown> for Maps that is
08:56:13 <merijn> randomclown: Yes
08:56:20 <Peaker> randomclown, or "traverse", depending on what constraint you have in scope
08:56:29 <edwardk> Peaker: filter is illegal but i think a less evil form of illegal.
08:56:42 <edwardk> Peaker: notably you can reason about the correctness of filter on a per-element basis.
08:56:56 <edwardk> reasoning about a traversal of set requires knowing something about all of the elements collectively
08:57:32 <edwardk> i've been willing to build some illegal traversals that are clearly documented that can be reasoned about locally, but when it comes to big global invariants like 'no duplications' i have shied away
08:58:49 <Peaker> I think maybe a solution could be having a Bag/MultiSet type,  then having a Prism between Set and MultiSet, and then a lens on MultiSet?
09:00:44 <edwardk> probably
09:01:00 <edwardk> in practice it hasn't been an issue for me =)
09:01:20 <edwardk> > iso S.fromList S.toList -- can be used in a pinch ;)
09:01:22 <lambdabot>   Ambiguous type variable `p0' in the constraint:
09:01:22 <lambdabot>    (Data.Profunctor.Unsafe....
09:01:31 <edwardk> :t  iso S.fromList S.toList -- can be used in a pinch ;)
09:01:32 <lambdabot> (Functor f, Ord a, Profunctor p) => p (S.Set a) (f (S.Set a1)) -> p [a] (f [a1])
09:02:53 <Peaker> such terrible looking types :-)
09:06:06 <Peaker> why does ":t" expand the "Iso" type synonym?
09:06:35 <Peaker> iso :: (s -> a) -> (b -> t) -> Iso s t a b  <-- GHC could do a better job on presenting that type
09:07:02 <fizbin> ghci expands most type synonyms.
09:16:12 * hackagebot lifted-base 0.2.1.0 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.2.1.0 (BasVanDijk)
09:23:33 <joelteon> most, but not all
09:23:47 <joelteon> namely, the type signatures it gives me for functions in my yesod app are horrible abominations
09:24:36 <c_wraith> I think ghc expands type synonyms that aren't directly specified in a type
09:27:35 <ion> I suppose it’s not possible to create tranlucent windows with an alpha channel with gloss (when a compositing window damager is in use)?
09:27:43 <ion> modulo typos
09:28:02 * applicative kind of liked the window damager
09:28:21 <ion> That one was intentional. :-)
09:28:53 * applicative expecialy likes xnomad widnow damager
09:32:30 <acube> Is there a way to get a stack trace when error is called in haskell? (I think there was some option, but I forgot it)
09:33:12 <Kinnison> +RTS -xc
09:33:17 <Kinnison> but you need to compile with profiling
09:33:22 <Kinnison> see http://www.haskell.org/haskellwiki/Debugging
09:34:06 <acube> Kinnison: ok, and I probably also need --rtsopts?
09:34:20 <Kinnison> probably
09:35:14 <ion> Gloss seems to initialize GLUT in hardcoded RGBMode.
09:36:14 * hackagebot Clean 0.4 - A light, clean and powerful utility library  http://hackage.haskell.org/package/Clean-0.4 (MarcCoiffier)
09:37:38 <Taneb> Okay, having tried both, I think null-canvas and sunroof-compiler solve different problems
09:39:59 <Taneb> What I want is a slightly more powerful null-canvas
09:49:04 <FreeFull> How could I implement a command in ghci, which, say, filters the output of another command?
09:49:30 <Ankhers> How do you want to filter it?
09:49:39 <Clint> same way you'd do it compiled?
09:50:03 <FreeFull> Ankhers: I want to filter out lines that don't match a pattern
09:51:15 <FreeFull> I want to implement a command that searches through the types of functions currently in scope
09:51:41 <FreeFull> :browse will display the types of all functions in scope, which is too much
09:56:23 <Ankhers> So... You want something like :browse, but isn't that?
09:56:27 <acube> FreeFull: cabal-ghci does define a ghci command (look at the instructions) afaik, you might want to look at it's source code
09:57:16 <FreeFull> acube: I know there is a :def for defining new ghci commands but I don't see a way of reading/redirecting the output of a command
09:57:54 <acube> FreeFull: right, I remember now, I was wondering about that too when I first saw it
10:11:16 <acube> I'm using +RTS -xc, and I still get Prelude.head: empty list. Can I still get a stack trace somehow?
10:11:42 <acube> (I'm getting a lot of stacktraces for unrelated things, like THUNK_0_1, ...)
10:22:54 <johnw> acube: Are you using GHC 7.4?
10:24:05 <acube> johnw: ghc The Glorious Glasgow Haskell Compilation System, version 7.6.3
10:24:27 <johnw> ah, then I have to say that I've never been able to squeeze more stack trace when nothing useful is being given, sorry
10:25:01 <johnw> this is why I treat use of "head" as though I'm begging for a future "bug hunt"
10:25:42 <irene-knapp> I have been able to, but it's a vegetarian pita (er, a pain in the a*)
10:25:43 <irene-knapp> ot
10:25:52 <irene-knapp> *it's much better to not use non-total functions to begin with
10:26:44 <johnw> agreed
10:27:16 <johnw> although, there is the edge case where a function is partial but its composition with another function is by definition total; I'm still ambivalent about those
10:27:38 <johnw> stupid example: head . (:[])
10:28:02 <joelteon> :t head . (:[])
10:28:03 <lambdabot> c -> c
10:28:27 <acube> = id :P
10:28:31 <joelteon> oh, i get it
10:28:40 <joelteon> that took me too long
10:28:47 <Andrea_> hi friends
10:29:14 <Andrea_> why does this example work : http://hpaste.org/89296 ?
10:29:32 <Andrea_> the line 8 and 9 are indented
10:29:55 <joelteon> that's not a hugely intuitive list comprehension indentation style
10:30:07 <Andrea_> with ghc this work, with hugs , this doesn't work
10:30:47 <geekosaur> why are you using hugs?
10:31:03 <geekosaur> hugs is loooong dead/unmaintained
10:31:21 <Andrea_> ok , i don't like hugs, i prefer ghc
10:31:36 <joelteon> don't use hugs
10:31:44 <Andrea_> but i dont understand why the example works
10:32:01 <Andrea_> the lines 8 and 9 are indented
10:32:09 <Hodapp> what's wrong with Hugs?
10:32:13 <joelteon> why is that a problem
10:32:15 <Hodapp> ...I use GHC, I'd just like to know
10:32:27 <joelteon> <geekosaur> hugs is loooong dead/unmaintained
10:32:33 <Hodapp> ohhh
10:35:34 <scottj> ghc-mod in emacs appears to only show type signatures when you press C-c C-t. Is there a way to get automatic display of non-Prelude type signatures ala haskell-doc-mode does for prelude signatures?
10:40:39 <johnw> yes, you can
10:40:43 <johnw> I've written such code
10:41:08 <johnw> but I ended up disabling it, because it was a real pain due to the fact that type information can only be obtained from ghc-mod when your module is compilable
10:41:57 <scottj> hmm, bummer
10:42:29 <scottj> is there non-ghc-mod code you use for real-time type signature display?
10:42:35 <c_wraith> sounds like something the defer type errors stuff would be helpful for
10:42:43 <johnw> yeah, you really want type info at the time when you're scratching your head.  So better to use "undefined" and "()" and read the type error
10:42:49 <geekosaur> doesnt help if there's a *syntax* error
10:43:24 <c_wraith> true, but at least it works more often
10:43:29 <shergill> defer-syntax-errors to the rescue!
10:44:18 <johnw> shachaf says that implicit params are helpful here, but I haven't used that approach yet
10:44:21 <c_wraith> there are some errors in between. unbound names, for instance, are neither syntax nor type.
10:44:50 <shergill> defer all errors?
10:45:05 <johnw> defer-it,-defer-it-all
10:45:44 <shergill> jokes aside, that's some of the reason why the intellisense stuff in visual studio is so impressive (from the technology side of things)
10:46:08 <acube> :t show (?x)
10:46:09 <lambdabot> (?x::a, Show a) => String
10:47:10 <kennycason> is anyone available to help me with something? i'm new to haskell and been stuck on this for awhile
10:47:13 <acube> lambdabot dead?
10:47:13 <acube> @ty show (?x)
10:47:13 <acube> > show "Hello!"
10:47:14 <lambdabot> (?x::a, Show a) => String
10:47:15 <lambdabot>   "\"Hello!\""
10:47:37 <bgamari> kennycason, You'll get a better response if you just ask your question
10:47:39 <geekosaur> @where justask
10:47:39 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
10:49:40 <ski> la la la
10:49:59 <johnw> hi ski!
10:50:17 <ski> where ?!
10:50:22 <johnw> ski: do you mind if I reformat that discussion we had about pushouts into a dialog form and then post it somewhere?
10:50:26 * ski looks around
10:50:39 <kennycason> So I'm working on a neural network: https://github.com/kennycason/haskell_nn/blob/master/Layer.hs I am having a problem in the Layer.hs, The function I am having an issue with is on line 36, I added a comment to the code that may help understand what I wnat to do
10:50:40 <ski> johnw : np
10:50:52 <johnw> thanks, it was super clear and I'm still enjoying it
10:51:13 <ski> (it was the one in #emacs, yes ?)
10:51:17 <johnw> yes
10:52:37 <ski> johnw : note that it really only touched the constructions in the category `Set' (more or less)
10:53:02 <johnw> it's a good start though
10:53:17 <ski> yea, i hoped so
10:55:14 <byorgey> kennycason: so you want to call 'calculateNodeError' once for each of the nodes in layer, each time also passing it 'childLayer' as an argument?
10:56:50 <byorgey> kennycason: if so, you want something like   map (\n -> calculateNodeError n childLayer) (nodes layer)
10:57:07 <byorgey> kennycason: however, this suggests that you probably want the arguments to calculateNodeError the other way around
10:57:19 <johnw> byorgey: how about (let n = nodes layer in map (uncurry calculateNodeError) $ zip n (map childLayer n)
10:57:38 <byorgey> kennycason: in which case you could instead write  map (calculateNodeError childLayer) (nodes layer)
10:58:31 <johnw> oh I see, childLayer is just passed down, it's not a function
10:58:51 <kennycason> history
10:59:07 <kennycason> help
10:59:16 <kennycason> ugh sorry about that, new to irc
11:04:24 <pxqr> is it possible to use a cabal flag as value or macro? for exsample I want just specify  `buildable: testing' instead of `if !flag(testing) { buildable: False }'
11:06:08 <byorgey> pxqr: no
11:06:40 <pxqr> okies
11:08:22 <kennycason> Sorry for the repost, my connection reset: I'm working on a neural network: https://github.com/kennycason/haskell_nn/blob/master/Layer.hs I am having a problem in the Layer.hs, The function I am having an issue with is on line 36, I added a comment to the code that may help understand what I wnat to do
11:31:25 <adirat> hello, i'm trying to install leksah and i get this error http://hpaste.org/89298
11:31:54 <adirat> can someone help me find this package to compile it?
11:33:22 <Heffalump> with ConstraintKinds, is there a way to express or encode that one constraint variable implies another?
11:37:02 <ski>   calculateErrors layer childLayer = layer
11:37:08 <ski>     { errors = map (\node -> calculateNodeError node childLayer) (nodes layer)
11:37:09 <ski>     }
11:37:19 <ski> kennycason : how about that ?
11:37:48 <ski> if you swap the args on `calculateNodeError', you could write it as
11:38:02 <ski>   errors = map (calculateNodeError childLayer) (nodes layer)
11:38:51 <shachaf> I,I layer & errors.mapped %~ calculateNodeError childLayer
11:39:49 <ski> kennycason : also, in `createLayer', instead of `Layer (...) (...) (...) learningrate', you could likewise say `Layer {nodes = ...,errors = ...,teacherSignals = ...,learningRate = learningRate}' (well, maybe you'll have to rename the argument)
11:45:26 <byorgey> shachaf: what is "I,I" ?
11:47:16 <geekosaur> "I have no (point|joke) here, I just like saying"? (CMU-ism)
11:56:35 --- topic: '["Haskell Platform 2013.2: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down, try: http://hdiff.luite.com "]'
11:56:35 --- topic: set by shachaf!~shachaf@unaffiliated/shachaf on [Tue May 28 01:16:22 2013]
11:56:35 --- names: list (clog mahogny danvet Licenser_ dcoutts__ Darkflux rgrinberg1 EvilTownCat theRealPermagree albel727 dju vvein petanqk Zouppen Boreeas chuzz2 lukleh_ 92AAASU01 demolithion jonkri_ jang2 oz1 thunderrd__ djahandarie Slowpoke_Man ique Siod__ Sebastien-Lo joneshf-laptop_ xvilka_ CosmicRa` verrens kyle__ Vq_ solarus_ Guest74216 bgeek raichoo_ anders^^ liyang_ def-lkb_ spacebar1 pettter sully_ agumonke1 SirChurc1ill agundry_ noj voyd_ meyersh_ davd_ cmtptr fry)
11:56:35 --- names: list (copton_ otto_s_ Liskni_s1 pyykkis yan__ naz_ hvr_ ChewieBeardy wereHamster bholst_ Clint_ mr- panda_man rs0 wto_ Ornedan alessand1o tobiassjosten davorak_ int-e_ sipa_ jlaire_ koninkje_away krkini pfoetchen mandu_ Boney heath Eiam gereedy_ weebl_ mgile_ ahkurtz_ eldariof amyers pgiarrusso McManiaC_ xxen simon___ Afish [swift]_ Kuraitou niko pmade Y_Less pantsman bjackman lunarjar chidy bitonic roconnor_ Puffton netj carter Internet13 sepp2k message144)
11:56:35 --- names: list (Khisanth mgsloan parcs ParahSai1in threesome srh ivan\ elliottcable uu1101 etabot aszlig junsuijin alang__ aoshi|2 Ke Sunhay_ Ptival_ gdsx_ Th0mas_ Nik05_ integral dobblego mceier Jambato jlamothe dario1 artefon TweyII kennyd hpc ecube lusory sordina cmsmcq bz horlicks aess paullik1 edsko jaimef zaphar_ps mrpantoufle ziman burp Nanar brett_ byorgey DolphR1 _janne Will| tew88- timemage_ zomg__ jlouis puzza007 agr gthorslund_ sunnavy tamiko_ oyvindio Martty)
11:56:35 --- names: list (ghorn_ natte hc bcoppens_ Rembane_ Shou SquidTamer helgikrs1 bstrie_ jyyou_ justdit pharaun_ osfameron wollw_ chirpsalot walter joogi _d3f lpsmith Brando753 numberten Valodim wting stephe mirsal gridaphobe strmpnk ehd ghorn ktosiek Nik_89 Cerise skyf_ wagle liszt sirspazz1lot skchrko duairc BrianHV LeaChim _atuin_ jkoppel_ lispy_ mikecaruso RoXtein SeanTAllen cjay Shin-LaC path[l] adirat edwardk Gunni Rutger`_ aninhume1 warpy bytbox_ fergusnoble henrikho_)
11:56:35 --- names: list (canvon etrepum_ dropdrive Nimatek_ q66 smarter_ Walther zvrba kushal gabor Ralith_ nwf supki_ luite_ deavid Jaak seneca zoktar mm_freak flux Franciman b2coutts Maxdaman1us _{^_^}__ XMunkki_ hattusili_III_ akurei_ Guest38925 slobo_ nicoo_ ousado_ kanwei akahn_ EarlGray^ cyphase levi Natch_r mithsv_ Raynes nimish ijp` xrq` Morgawr s_quark_ elgot Tesseraction WzC xplat_ doomlord__ asQuirreL MasseR_ jackhill_ shepheb Reite twanvl_ tensorpudding flebron Draconx)
11:56:35 --- names: list (applicat1ve jlewis fizruk2 arbn doomlord_ mornfall bbee2 Sgeo ahf ido msuszczy confound Guest22326 gds DrCode Fnar otterdam jdoliner shergill kaictl c_wraith yam mlinksva yiannis_t macron `0660_ Kiryx AntiSpamMeta dpratt71 blz37 trism s00pcan Heffalump aford_ jrslepak_ mortberg Gothmog_ gdeest tero-_ mjrosenb_ Entroacc1ptor harrison prophile_ terjr satshaba1 hebz0rl MercurialAlchemi kakos_ apples Lethalman Chousuke_ jnerula mattp__ execc_13 kosmikus)
11:56:35 --- names: list (walter|r lemao_ thetallguy1 Tene tahu tomku shelf Cryovat Zariel mel- Khady ChongLi araujo cross kshannon bezik purefn1 lightquake JoeHazzers WhereIsMySpoon genisage tomboy64 wizard` ljhms saurik Debaser xnyhps unlink em valdyn MetaCosm theorbtwo SaBer mkrull johanbev Hafydd Starfire sprang jbauman_ tanakh domingo skchrko_ pcapriotti ttm F1skr machisuji_ liammclennan PiepScuim erkin hpd jajamana amiller_ so morolin trybeca_ Bwild_ kloeri mietek Adios_)
11:56:35 --- names: list (fruitFly ceti331_ crdueck_ FreeFull bxc earthy KitB__ matheus23_ uniquenick shachaf schoppenhauer jayne Kinnison mmarusea1ph2 conal_ SuperNoeMan_ A1kmm kryft necrobious bowmanb_ Watabou_ rainmaker bananagram pyrtsa FireFly rachit7 copumpkin imphasing hamilyon1 hiptobecubic_ jliikka yogurt_truck crotchet1 zerokarm1left Claudius1aximus Bigcheese dbelange epta_ Adeon mimico__ thoughtpolice Gilly sunfun_ mike2_ tessier_ electrog1ek asante10111 RichyB tboyt_)
11:56:35 --- names: list (PrO_OkI_____ apaku_ SegFaultAX PHO__ vraid Counter-Strike dysinger [1]phil yogert Jefferson plucas jeremyjh Paprikac_ geisthaus tharugrim Pranz erochester mrsolo konundra aesptux Hodapp bos Jeanne-Kamikaze joelb taterbase piezoid heruur1 josephle jml kobain d_arcy phyrex1an _emm_ suporte85 lennart__ farn Noldorin MindlessDrone whaletechno kazimir42 knightshade jobstijl Mortomes bben tac execut3 oconnor0 ZynACK bergey therootcafe ketil benprew nooodl saep)
11:56:35 --- names: list (obiwahn Sculptor scriptor Hannibal_Smith EvilPenguin maxter_ armlesshobo boothead_ h4199 Desheng alszar setmeaway ntus1017 Targen ThatOtherPerson dgvncsz0f NowKnownAs enthropy joaopizani `^_^v atamagawarui augur NinjaPenguin mike4_ S11001001 guampa quux hinst fizbin Asterfield heyduck Eduard_Munteanu natechan fgomez hamishmack quazimodo morazow arun ccc gautamc shreesh _justjust Apocalisp u_ Rarrikins mattrepl osa1 solancile akiress edwtjo DrSyzygy)
11:56:35 --- names: list (hive-mind qwandor petermw randomclown Thra11 k00mi_ kludge` Dybber m3ga Luke nus- scalable boegel marr maoe DexterLB neutrino_ arthur_honeynet snowylike piotr Alice3 mlh Guest20265 milessabin zammy tavelram ParadoxMuffin Swizec juhp shintah eccstartup no-n Jesin td123 Mon_Ouie dmarker ssbr preflex mauke shanse SoupE JKL|Away [[zz]] ttuegel predator117 PANDORAS_OWN a- tgeeky nuttycom1 IbnFirnas Baughn gemelen barrucadu Zeev guymann jknick stepkut Dtgr_)
11:56:35 --- names: list (eacameron redjohn joe9 Mowah IanKelling dan_johnsin illissius` Jasu c_14 vehk heilkn cdh473 XexonixXexillion sawjig arlinius Enigmagic Mayazcherquoi jonke Xorlev hiratara Kabaka doshitan frontend1oader Athas comak ccxCZ mikee csg brisbin isenmann isomorphic yacks JPohlmann ajhager rofer johnw pikhq krig malcontentment70 SHODAN cmears ericmj Vorpal egerlach vikraman idnar threedaymonk bgamari dsantiago gwern weie idoru floatingman alexander__b ab9rf)
11:56:35 --- names: list (DigitalKiwi s4msung Ulrar dlundy tmiw vermeille MoALTz adlan newsham Draggor finnrobi petekaz` solirc ent tippenein Paks liori haasn andrewsw zaiste sohum fxrh statusfailed torkjak bd__ drbean yumike tsinnema Eelis thetallguy2 dreixel obiwanko tomjack centrinia Fuuzetsu vobi Raynos perlite tudalex|away scottj tomh- jmcarthur Nahra Ghoul_ shennyg liammcl lopex mtlatif__ phyrephox bobry skuggi zz_nh2 BMeph_ brianloveswords Watcher7 melter aluink bartavelle)
11:56:35 --- names: list (ericmathison Soft kaol tswett obcode waterlaz lahwran hobson hackagebot Tarential saiam_ mendez_ __main__ destiny_ kstuart myme1 jacobw Astro- gpampara_off lattenwald kav Jonte birkenfeld joelteon ethercrow sajith schroedinbug hiredman mannyv knyppeldynan robbert Axman6 Tinned_Tuna plhk ibid n00dle kennyp Excureo zebr Sagi aristid adimit Proteumus greeny irene-knapp epsylon` ninegrid ehamberg mgaare Igloo eyck def- mrshoe mike_pizza tomejaguar vmeson)
11:56:35 --- names: list (Guest83875 gbarboza monochrom Ycros troydm lenstr ninwa dabradley bqp fryguybob ByronJohnson bakingbread colah folone fikusz sm mikeplus64 Velpoman geekosaur Eridius arkeet dilinger_ acfoltzer stvc sg ahihi sbahra CoverSlide ipuustin rfw foobarbaz voxpopuli meretrix jroesch pi8028 swistak35 leifw dented42 transfinite \q dmwit vvv fireglow alpounet imles k0ral_ Razz_ timbod stelleg_away Megant wei2912 ciaranm Kuba noam marienz M-ou-se joar ironm tunixman)
11:56:35 --- names: list (thorkilnaur_ Gibheer sjl Riussi_ jcp Fubar^ magicman KaneTW bens Laney ski leroux mrd flowsnake gspr Minos prh lpvb blackdog jaspervdj alang_ tomprince b52 neurocyte drmegahertz mavam yano klugez janinge fionnan aleator alang ccasin caligula dpwright chrra yeltzooo machisuji averell nxorg8 divarvel absence opqdonut suiside TML tvaalen Elision_ mephx arnsholt knz taylorgb DustyDin1o adnap taruti HalfWayM1n othiym23 rmunroe fall_- fayden notdan)
11:56:35 --- names: list (companion_cube quuxman Kneiva ft popx Saizan tdammers cods ggreg maxorator @ChanServ Yawgmoth zenzike davean_ blakesmith froztbyte sgronblo_ mami bind bogner brainproxy mechairo` tromp Nickeeh Jaxan maksbotan pnielsen thirsteh cynick alcz scgilardi guerrilla cajla_ dixie mokus FUZxxl quicksilver hyko Gracenotes arkx aar__ kqr raid drewr ernst Dashkal KitB schlumpi flori oldmanstan hiroyuki3 joachifm gbluma_ xymox eL_Bart0 Hardolaf wtw cmsd2 tomaw kmicu)
11:56:35 --- names: list (Plex- brixen dyreshark mononofu nlogax ofan noplamodo matzo JoshuaA_ hanDerPeder mollerstrand zeiris dmp1ce gseitz pr linduxed greymalkin hannes Nshag lokydor peltchu Canar betawaffle cow-orker majoh jamwt ninzine mimi_vx felipe_ pdxleif_away _flow_ frio nikola iulian jrib qz Dodek oelewapperke TheSpectre banjiewen mixi pqmodn MK_FG Derander Deewiant stepcut Eliel endojelly Reiser ivan` ryanakca Innominate jessexoc rhodesd milli ocharles whoops elliott mux)
11:56:35 --- names: list (CindyLinz anachron theDon kryptiskt_ jzelinskie h_chiro_ dwcook tinyghost)
11:57:38 <applicat1ve> with this highlighting, a netsplit is like an aurora borealis or something
11:58:02 <klrr> i get an parse error, https://gist.github.com/klrr/5708584 , anyone got an idea what i do wrong? :x
11:58:38 <byorgey> klrr: you need commas between the record fields
11:58:46 <byorgey> server = srv, port = prt, ...
11:59:06 <klrr> byorgey: aa, im stupid, thanks! :D
11:59:12 <byorgey> =)
12:01:12 <klrr> byorgey: still get same error :/ https://gist.github.com/klrr/5708584
12:01:23 <lennart__> klrr: the indentation after "let conf = do"
12:01:37 <klrr> lennart__: does they have to be beyond the "do"?
12:01:42 <lennart__> you are too far left, because of the indentation of "conf"
12:01:51 <lennart__> no, but right of conf
12:02:18 <klrr> ok
12:03:22 <lennart__> (more indented than conf, that is)
12:04:42 <danl-ndi> what's the syntax to partially apply Data.List.find id <some func this is a -> [b]>
12:05:15 <danl-ndi> like... Data.List.find id (getList thing)
12:05:32 <danl-ndi> except partially applied to the result still takes thing
12:05:51 <byorgey> danl-ndi: Data.List.find id . getList ?
12:06:09 <byorgey> @type find id
12:06:32 <byorgey> danl-ndi: I'm not sure what you're trying to do, but 'find id' does not seem very useful
12:06:38 <skuggi> @pl \thing -> Data.List.find id (getList thing)
12:06:42 <byorgey> it has type  [Bool] -> Maybe Bool
12:07:04 <skuggi> isn't that how you do it?
12:07:05 <byorgey> and gives you 'Just True' exactly when the list contains 'True'
12:07:19 <byorgey> but if that's what you want to know you can just use 'or' or 'any'
12:07:43 <danl-ndi> byorgey: yeah I have a different func than id... just using it for a simple example
12:08:21 <danl-ndi> byorgey: Data.List.find id . getList  will compose getList with id, leaving a function that still wants a list
12:08:36 <byorgey> danl-ndi: right
12:08:37 <danl-ndi> byorgey: I'm looking for syntax that will yield a function that still wants 'thing'
12:09:12 <applicat1ve> =========
12:09:15 <applicat1ve> 0
12:09:19 <byorgey> wait, I'm confused now.  what is the type of getList?
12:09:47 <danl-ndi> getList :: a -> [b]
12:09:52 <danl-ndi> thing :: a
12:10:17 <byorgey> danl-ndi: ok. In that case   Data.List.find id . getList  is a function which expects a 'thing'
12:10:20 <byorgey> not a list
12:10:54 <klrr> if i have a variable "config" that points to a record, how to i retrieve its content?
12:11:03 <byorgey> danl-ndi: Data.List.find id . getList  does not compose  id and getList.  It composes (find id) and getList.
12:11:14 <danl-ndi> byorgey: really...?  ok I'll try that. thanks!
12:11:35 <byorgey> klrr: there are no pointers in Haskell.
12:11:58 <byorgey> variables are just names for content.  So if you want the content, you just use the variable.
12:12:00 <klrr> byorgey: -.-, i can still say a variable "points" to a value
12:12:09 <byorgey> klrr: You can.  But I wouldn't.
12:12:12 <klrr> i dont mean C shit, im talking about haskell
12:12:34 <byorgey> nomenclature matters.  Use confusing language, get yourself confused.
12:12:34 <klrr> how do i retrive stuff from a record that's inputed into my function?
12:12:52 <byorgey> klrr: the field names of records are also projection functions
12:13:07 <klrr> but when i call them i get an error
12:13:15 <FreeFull> What error is it?
12:13:17 <klrr> even if ive derived them to Show
12:13:17 <byorgey> klrr: so if you have some record type like  data Foo = Foo { bar :: Int, baz :: Char },  you have  bar :: Foo -> Int  and  baz :: Foo -> Char
12:13:34 <byorgey> klrr: in that case you'll have to paste your code and the error message
12:14:10 <klrr> wait the problem was i forgot to lift awaay that IO monad stuff
12:14:36 <applicat1ve> @type uncurry (fmap . (,))......................................................................................................................................................................................................................................................................................................................................................................................................................
12:14:43 <fryguybob> D:
12:14:56 <byorgey> klrr: in the future, it's much easier and faster to paste some code and an error message in the first place, rather than ask about what you think is wrong.
12:15:03 <byorgey> because sometimes you're wrong about what is wrong.
12:15:54 <klrr> byorgey: yeah, but this time im not wrong :D i just need a way to turn my IO Config into a Config
12:15:54 <FreeFull> You can also use pattern matching instead of the accessor functions
12:16:16 <geekosaur> um
12:16:19 <byorgey> klrr: you cannot do that.
12:16:23 <dwcook> klrr, (>>=)
12:16:24 <geekosaur> you still don't understand IO
12:16:28 <klrr> i used <-
12:16:32 <dwcook> Or that.
12:16:38 <klrr> geekosaur: i do :P
12:16:48 <klrr> problem is solved :D
12:16:57 <klrr> byorgey: yes i can do that, i just used (<-) in ghci
12:17:21 <byorgey> klrr: ah.  ghci is kind of cheating =)
12:17:27 <klrr> now everythings work and i can continue working on my IRC bot
12:17:34 <byorgey> because you get to interleave actual execution of IO actions with evaluating expressions.
12:17:47 <klrr> byorgey: no it's not, it will work in my program too, i will just need to use liftIO since i got my own monad
12:19:28 <byorgey> klrr: yes, but it's not actually "turning an IO Config into a Config".  It's using the (>>=) method to sequence together the IO Config with a function of type (Config -> IO something).  But in this case it doesn't really matter that much.
12:19:56 <danl-ndi> so, Data.List.find id . getList  seems good
12:20:04 <danl-ndi> now I'd like to 'maybe' it
12:20:23 <danl-ndi> as in: maybe False (\x -> True) $ Data.List.find id . getList
12:20:49 <joelteon> maybe False (const True)
12:20:51 <danl-ndi> it's not binding together the way I'm intending... probably something basic
12:20:55 <danl-ndi> const
12:20:59 <joelteon> wouldn't that be isJust?
12:21:07 <klrr> byorgey: isn't that more of a matter of term(ology)? i think i need to learn more terms to talk better about my haskell code
12:21:26 <danl-ndi> joelteon: what is isJust?
12:21:30 <joelteon> :t isJust
12:21:36 <joelteon> lambdabot...
12:21:45 <danl-ndi> <interactive>:1:1: Not in scope: `isJust'
12:21:46 <joelteon> danl-ndi: isJust (Just _) = True; isJust Nothing = False
12:21:52 <joelteon> it's in Data.Maybe
12:21:55 <danl-ndi> ah
12:21:59 <byorgey> klrr: it's hard to know.  Perhaps you understand it perfectly and are just using the wrong terminology; perhaps you are confused.  I can't tell. =)
12:22:44 <danl-ndi> joelteon: that's what I'm looking for, but I'm still not binding properly
12:22:47 <joelteon> danl-ndi: maybe False (const True) :: Maybe a -> Bool; isJust :: Maybe a -> Bool
12:22:59 <byorgey> danl-ndi: maybe False (\x -> True)  is a function which expects a  (Maybe something).  So in  maybe False (\x -> True) $ blah,  blah has to have type  (Maybe something).
12:23:07 <byorgey> danl-ndi: but in your example, 'blah' is a function.
12:23:31 <byorgey> danl-ndi: I'm guessing you want to instead use another composition, like   isJust . find id . getList
12:24:32 <joelteon> isJust . find id is the same as any, isn't it?
12:24:44 <FreeFull> danl-ndi: If you're putting some piece of data right at the end you want to put a $ before it
12:24:54 <FreeFull> danl-ndi: Or just show us the whole code
12:25:03 <FreeFull> And the error
12:25:37 <dmwit> joelteon: perhaps it's the same as "or"
12:25:51 <dmwit> :t isJust . find id
12:25:51 <joelteon> oh yeah
12:25:56 <joelteon> or === any id
12:26:00 <dmwit> yeah =)
12:26:17 <dmwit> no bot?
12:26:20 <joelteon> nope
12:27:06 <dmwit> < "foo"
12:27:06 <goodfellow>   mueval-core: /usr/lib/ghc/ghc-prim-0.3.0.0/HSghc-prim-0.3.0.0.o: unknown sy...
12:27:12 <dmwit> uh, hm
12:29:33 <dmwit> oh, sigh
12:30:18 <dmwit> I installed updates and it converted GHC 7.4 into GHC 7.6.
12:30:28 <carter> wat
12:30:44 <dmwit> not "wat"-worthy
12:30:55 <dmwit> Changing versions is the package manager's job. =)
12:30:59 <carter> ohhh
12:31:00 <carter> linxu
12:31:02 <carter> *linux
12:34:26 <klrr> https://gist.github.com/klrr/5708906 <- strange error :x, any ideas?
12:39:29 <byorgey> klrr: (asks config >>= chan)  does not have type  String.
12:40:56 <dmwit> (Unless Config is [a] and chan is (a -> String) for some a.)
12:45:42 <bitonic> I wonder what would be a good way to produce a literate blog post where the code gets changed ‘incrementally’
12:45:50 <bitonic> the best thing would be to have first class modules
12:45:59 <bitonic> but we don’t have ’em
12:46:22 <dmwit> > {-
12:46:44 <dmwit> > now finished incrementing the version number on wrongness, time to give the real deal -}
12:47:05 <bitonic> dmwit: that’s ugly.  I’d like to typecheck the whole thing.
12:47:14 <bitonic> and have hakyll highlight the whole thing, too
12:47:45 <dmwit> Oh, is Hakyll that smart?
12:47:48 <dmwit> Impressive.
12:48:05 <Sonarpulse> has anybody done anything with house (the os) in recent years?
12:48:16 <dmwit> I haven't really heard much recently.
12:48:36 <Sonarpulse> all the links to the light house continuation on the project are dead
12:48:46 <bitonic> dmwit: ‘that smart’?
12:48:47 <dmwit> bitonic: As an approximation to first-class modules, how about
12:48:58 <dmwit> notTheRealDealv1 = undefined where
12:49:03 <dmwit>   wrongImp1 = ...
12:49:12 <dmwit> s/1// on the last line
12:49:18 <klrr> byorgey: it doesnt, but it evaluates to a string?
12:49:23 <Sonarpulse> however, it looks like moving the concurrency primitives out of the C run time and into a haskell library is still active?
12:49:28 <bitonic> that’s still ugly.  I think I’m just daydreaming since I know there is no easy way to do that in Haskell
12:49:40 <dmwit> klrr: What does "evaluates to a String" mean, if not "has type String"?
12:50:22 <Sonarpulse> scala' implicits show an interesting model for this
12:50:28 <klrr> dmwit: it means that when the parentheses is gone there should be a string in that position
12:50:31 <dmwit> bitonic: "that smart": I would have expected Hakyll to just use some regexen to highlight keywords on lines that start with ">".
12:50:48 <klrr> https://gist.github.com/klrr/5708906
12:50:49 <dmwit> If it keeps track of when you're in a comment, even across non-code blocks, that's smart.
12:51:07 <bitonic> dmwit: well it does what pandoc does.  it’s as smart as pandoc.  I would guess that pandoc highlights Haskell correctly
12:51:17 <klrr> dmwit: doesnt it return a string?
12:51:21 <byorgey> klrr: it doesn't work that way.
12:51:28 * hackagebot restful-snap 0.2 -   http://hackage.haskell.org/package/restful-snap-0.2 (DougBeardsley)
12:51:30 <dmwit> klrr: I don't know, you haven't shown us what Config and chan are.
12:51:33 <byorgey> klrr: it has type  M String  for some monad M.
12:51:34 <klrr> byorgey: why did it work with all other cases i used it?
12:51:40 <bitonic> dmwit: I don’t understand what’s difficult about doing that.  emacs has no problem in recognising comments in literate Haskell
12:51:40 <klrr> oh sry
12:51:58 <byorgey> klrr: things of one type do not magically "evaluate" to something of another type
12:52:40 <klrr> https://gist.github.com/klrr/5708906
12:52:49 <klrr> byorgey: but chan is of type String
12:52:58 <byorgey> klrr: presumably you want to do something like   do  c <- asks config >>= chan; write "PRIVMSG" $ c ++ ...
12:53:07 <klrr> ok
12:53:15 <klrr> i thought (>>=) fixed that
12:53:22 <byorgey> klrr: if  chan :: String,  then  asks config >>= chan  does not type check either.
12:53:25 <dmwit> klrr: If chan is of type String, then (>>=) surely can't work.
12:53:27 <byorgey> @type (>>=)
12:53:35 <dmwit> klrr: (>>=) expects a function as its second argument.
12:53:50 <dmwit> (>>=) :: Monad m => m a -> (a -> m b) -> m b -- I'm a bot!
12:54:46 <fruitFly> in prelude I used ":l" and then it's telling me my function are not in scope
12:54:55 <dmwit> klrr: Oh, chan :: Config -> String?
12:55:13 <dmwit> klrr: Perhaps you want do c <- asks (chan . config); write "PRIVMSG" $ c ++ ...
12:56:06 <dmwit> fruitFly: That doesn't make a lot of sense. Perhaps you mean "in ghci" instead of "in prelude"; then ":l" by itself doesn't load any files at all.
12:56:14 <dmwit> You have to name the file you want to load.
12:56:19 <dmwit> file(s)
12:56:23 <klrr> now chan turns into a char or sth :x
12:56:35 <dmwit> klrr: huh?
12:56:57 <klrr> im too tired of ghc and her complaints, i thought she was my friend now she starts yelling at me again
12:57:03 <fruitFly> dmwit:  in terminal I type ghci ... then ":' file.name" then not in scope?
12:57:05 <klrr> night
12:57:24 <fruitFly> dmwit: ":l blah.hs" *
12:57:40 <byorgey> ghc is loving klrr with some tough love
12:57:45 <dmwit> fruitFly: Perhaps your file has some errors -- e.g. perhaps it refers to some names you have not yet defined.
12:58:00 <dmwit> fruitFly: If you shared the file with us, we might be able to help you spot the problem.
12:58:11 <dmwit> hpaste.org if the file is longer than one line. =)
12:59:38 <fruitFly> dmwit: I'm trying to debug the shit out of this: http://hpaste.org/89302
13:01:11 <dmwit> Hm.
13:01:14 <dmwit> That file loads cleanly here.
13:01:19 <fruitFly> dmwit: i compile that shit and it runs, but some of the logic is off I wanna debug
13:01:20 <dmwit> Could you paste the exact error, as well?
13:01:47 <lispy_> fruitFly: you could try Debug.Trace
13:02:00 <fruitFly> dmwit: I do this ":l blah.hs" ... modules loaded OK ... base64toIndex 'c' ... NOT IN SCOPE?1
13:02:17 <fruitFly> lispy: i dn't know wut the fudge that is
13:02:18 <byorgey> ah, it might be because it has been compiled
13:02:49 <lispy> is it because you define main? Do you need to export that function?
13:02:50 <byorgey> fruitFly: if there is a file called blah.o, try deleting it
13:03:01 <ski> @tell kennycason also, in `createLayer', instead of `Layer (...) (...) (...) learningrate', you could likewise say `Layer {nodes = ...,errors = ...,teacherSignals = ...,learningRate = learningRate}' (well, maybe you'll have to rename the argument)
13:03:09 * lispy can never remember the default behavior for exposing things when there is no module ... where line
13:03:18 <ski> hm, no lambdabot
13:03:29 <byorgey> lispy: in that case everything is exported
13:03:36 <byorgey> lispy: just as if you had typed  'module Main where'
13:03:36 <mlauria> hello
13:03:40 <fruitFly> byorgey: it works now... that was really gay
13:03:47 <byorgey> hi mlauria
13:03:56 <geekosaur> language
13:03:58 <fruitFly> mlauria: hey :)
13:04:04 <applicative> mlauria: hello
13:04:17 <mlauria> I'm hoping to ask a question about Parsec
13:04:20 <fruitFly> wonder if she could be a girl.... jk ... girls dnt haskell... maybe python or sum other shit
13:04:38 <byorgey> fruitFly: please tone down the language.  Words like 'shit' and 'gay' are not appropriate in this channel.
13:04:53 <fruitFly> byorgey: ok :) ... so what was that about... deleting .o ?
13:04:57 <geekosaur> bigotry is off topic for #haskell
13:05:02 <applicative> mlauria: the answer is {-#LANGUAGE NoMonomorphismRestriction#-}
13:05:13 <applicative> thanks byorgey
13:05:27 <dmwit> fruitFly: In the future, you can use ":l *foo.hs" or "ghci '*foo.hs'" to load a file in interpreted mode even if there is a .o lying around.
13:05:28 <byorgey> fruitFly: also, 'girls don't haskell' is even more inappropriate than the language.
13:05:30 <applicative> do you have a module to paste mlauria
13:05:33 <applicative> omg
13:06:13 <byorgey> and also false.
13:06:34 <fruitFly> byorgey: with the stares and ' 's?
13:06:46 <fruitFly> byorgey: asteriks* ?
13:07:18 <byorgey> fruitFly: an asterisk at the beginning of a file name tells ghci to load it in interpreted mode.
13:07:28 <fruitFly> ok thanks
13:07:35 <byorgey> fruitFly: but to avoid your shell interpreting * as a wildcard you probably need to enclose it in  ' '
13:07:38 <mlauria> applicative: It's just a question: Is there a way to have a Parser fail, but still return what it parsed up to failure?
13:07:44 <byorgey> so like    ghci '*Foo.hs'
13:08:06 <dmwit> mlauria: Not with Parsec, no.
13:08:08 <mlauria> I'd like to have another take over on failure (where it left off, no try), and go back and forth
13:08:51 <dmwit> Huh, that sounds very strange.
13:08:59 <roSievers> Hi, I'd like to traverse a Map, using the keys as well as the values. However, the Travesable typeclass only allows me to traverse the values. (At least I think so) As I don't actually need a result, is there some kind of :: Map α β -> (α -> β -> IO ()) -> IO ()?
13:09:26 <roSievers> Hi, I'd like to traverse a Map, using the keys as well as the values. However, the Travesable typeclass only allows me to traverse the values. (At least I think so) As I don't actually need a result, is there some kind of :: Map α β -> (α -> β -> IO ()) -> IO ()? (resending because of netsplit)
13:09:32 <mlauria> dmwit: Is there another way to do it, then?
13:09:40 <dmwit> If you really want the other one to take over no matter *where* the first one failed... very strange. If you have a pretty good guess of where it will fail, you can push the alternation to that position.
13:09:41 <byorgey> mlauria: it sounds like instead you should make a parser that stops whenever you want it to stop
13:09:55 <byorgey> mlauria: instead of using failure to indicate that it should stop.
13:10:00 <dmwit> exactly
13:10:16 <mlauria> yes so it stops, then the other goes, then stops and calls the first one again?
13:10:34 <byorgey> mlauria: sure, you can do that
13:10:39 <byorgey> just use recursion
13:10:47 <applicative> traverseWithKey ::   (k -> a -> t b) -> Map k a -> t (Map k b)
13:10:49 <dmwit> roSievers: The "keys" package offers this operation, I believe.
13:11:07 <roSievers> applicative, dmwit: thank you
13:11:32 <byorgey> traverseWithKey is in Data.Map itself, isn't it?
13:11:53 <applicative> yeah
13:12:03 <byorgey> I'm sure you could also use an indexed traversal from lens, but that's probably overkill =)
13:12:28 <byorgey> but if you were interested in such "indexed traversals" more generally (not just for Map) that would be the place to look
13:13:41 <mlauria> I have this:   str <- many (satisfy (\x -> (all (x /=) ['>', '<', '&'])));
13:13:55 <dmwit> What package provides the SimpleReflect module?
13:14:09 <dmwit> I would have guessed simple-reflect, but that's not it.
13:14:12 <mlauria> but I don't know how to make it stop instead of just continuing and omitting the characters I list
13:14:44 <dmwit> mlauria: That stops as soon as it sees a '>', '<', or '&'.
13:14:53 <shachaf> dmwit: show 0.5 has it...
13:15:01 <dmwit> aha
13:15:13 <shachaf> But I suppose it got moved into its own package, and the module renamed to Debug.SimpleReflect.
13:15:44 <ski> mlauria : `notElem :: Eq a => a -> [a] -> Bool'
13:15:46 <Luke> dmwit: you ready for the party this weekend?
13:16:03 <dmwit> Very nearly.
13:16:13 <Luke> dmwit: thanks for letting me stay at your place btw!
13:16:17 <Luke> ;-P
13:16:23 <dmwit> hm =)
13:16:41 <Luke> ok bad joke =D
13:16:44 <dmwit> Well, you're welcome at my place, so long as you can convince either Tom or Ed to share their bed. =)
13:17:01 <dmwit> Or... if you can convince Tom and Ed to share with each other, that would work, too. ;-)
13:17:18 <Luke> no no I have a place. thanks though ;-)
13:17:50 <Luke> serious question though: anyone know of a log aggregation and rotation app written in haskell?
13:17:54 * dmwit sighs at "show"
13:18:02 <Luke> I'm thinking something like Angel
13:18:38 <dmwit> Maybe it's time to see how good the new release of \bot is.
13:18:41 <dmwit> =/
13:19:14 <Luke> freenode's kicking ass today
13:19:17 <fruitFly> byorgey: "ghci '*foo.hs'" did not load the module in interpreted mode. and what is the difference between Prelude>, Prelude Main> and *Main> ?!
13:20:31 <fruitFly> and I just want to apologize for my language earlier, I don't want to offend anyone, have nothing against gays or girls.
13:20:45 <mlauria> ^ cool
13:21:59 <dmwit> fruitFly: Prelude> means only the Prelude is loaded. Prelude Main> means both the Prelude and Main are loaded. *Main> means Main is loaded, and everything defined in Main is in scope (even if it's not exported from the module).
13:22:18 <Mortomes> fruitFly: What you're saying is you do have something against straights and guys?
13:22:44 <dmwit> fruitFly: When you say "ghci '*foo.hs'" did not load the module in interpreted mode, what does that mean? What went wrong?
13:22:58 <fruitFly> dmwit: my funcs are not in scope
13:23:09 <dmwit> Mortomes: Now, now, fruitFly is graciously apologizing. No need to make fun of him for that.
13:23:25 <dmwit> fruitFly: Did it show "*Main>" as your prompt?
13:23:53 <fruitFly> NO .. Prelude Main> .. I'm wondering what the differences are, I'm trying to learn me a haskell here.
13:24:10 <dmwit> Interesting.
13:24:32 <fruitFly> dmwit: actually ... only Prelude> sorry
13:24:39 <dmwit> uh
13:24:43 <fruitFly> '*foo.hs' was unrecognized
13:24:54 <dmwit> Is your file named foo.hs?
13:25:10 <fruitFly> matasano.hs
13:25:14 <fruitFly> dmwit: ^
13:25:20 <Mortomes> dmwit: It's all in good fun :P
13:25:22 <dmwit> Well, you should use '*matasano.hs', then, of course.
13:25:34 <fruitFly> dmwit:  I did!
13:25:36 <fruitFly> lol
13:25:37 <dmwit> Also, what shell are you using?
13:25:44 <fruitFly> cmd windows 7
13:25:51 <dmwit> Oh, Windows, lol.
13:25:59 <dmwit> I have no idea how to properly escape things in Windows.
13:26:05 <fruitFly> dmwit: lol I know... should I just start using linux now?
13:26:07 <dmwit> Maybe try without the single quotes or something.
13:26:16 <Sonarpulse> yes, try linux
13:26:21 <dmwit> Or possibly try double quotes.
13:26:29 <Sonarpulse> or powershell
13:26:32 <dmwit> Anyway, does :l *matasano.hs work once you're in ghci?
13:26:53 <geekosaur> double quotes or possibly escape the * as ^*
13:27:23 <dmwit> I mean, I guess part of the joke is that the right way to escape things depends on code in GHC, right?
13:27:33 <fruitFly> Sonarpulse: dmwit i got dual boot mint, right now. But I don't know how to install shit in linux lol. I just don't feel like I understand the OS enough. What distro do you recommend? nixos, arch, gentoo?
13:27:52 <dmwit> Ubuntu is a popular gateway drug.
13:28:08 <gustavderdrache1> i'm having trouble with my copy of cabal -- it seems to freeze whenever it needs to access the network (cabal fetch, cabal update, ...)
13:28:21 <fruitFly> dmwit: lol
13:28:25 <gustavderdrache1> are there good resources to help diagnose this?
13:28:31 <dmwit> (It was mine. Then I went Gobo, and briefly tried Arch and Debian; my current preference is Fedora.)
13:28:51 <Shamar> does exist a base function like this: (<&>) f g a = (f a, g a)
13:28:56 <fruitFly> Sonarpulse: dmwit what about nixos? I actually have dual boot mint right now
13:29:10 <dmwit> Shamar: (&&&), and also Hoogle can probably find it.
13:29:17 <dmwit> :t \f g a -> (f a, g a)
13:29:28 <dmwit> ?hoogle (a -> b) -> (a -> c) -> a -> (b, c)
13:29:32 <dmwit> urgh, yes
13:29:45 <ski> hm, WinHaskell/GuiHaskell stalled ?
13:29:51 <dmwit> Hm, Hoogle does not find it. Bummer.
13:30:02 <Shamar> hoogle can find functions from signatures?
13:30:05 <dmwit> yes =)
13:30:37 <ski> (Control.Arrow.&&&)
13:30:49 <ski> Shamar ^
13:31:08 <Shamar> I'm using arrow?
13:31:21 <ski> oh, dmwit said
13:31:23 <Shamar> Am I using arrow? I don't know arrows...
13:31:31 <dmwit> (->) is an Arrow, yes
13:31:35 <dmwit> You know (->).
13:31:36 <ski> i don't know if you're using arrows yet
13:31:38 <applicative> well, you're always using arrow
13:31:42 <applicative> oh like dmwit says
13:31:55 <ski> (iow, the arrow combinators)
13:32:02 <Shamar> that's funny
13:32:16 <applicative> > 0 + 3 -- check out this monoid!!
13:32:24 <Fuuzetsu> ^production code
13:32:27 <applicative> uh oh
13:32:30 <dmwit> (Why do you think they picked the name Arrow? =)
13:32:43 <dmwit> applicative: I'm building a replacement as fast as I can!
13:32:47 <dmwit> But I'm kind of slow.
13:32:53 <Luke> When I make a JSON Object with Aeson and then encode it, it's escaping the string escape characters. Ex: encode $ object ["name" .= "test", "age" .= 1] yields "\"{\\\"age\\\":1,\\\"name\\\":\\\"test\\\"}\""
13:32:54 <applicative> dmwit: it's okay
13:33:07 <Luke> is there a way to get it to encode to {"age": ..
13:33:21 <geekosaur> Luke: one layer of that is from the Show instance, try displaying with putStrLn
13:33:22 <dmwit> Luke: Is it possible you just called show one too many times.
13:33:35 <geekosaur> or that
13:33:35 <dmwit> s/\./?/
13:33:40 <Luke> haha
13:33:40 <applicative> > show $ show $ show "hi"
13:33:47 <Luke> I'm not calling show at all
13:33:54 <ski>  "\\\"hi\\\""
13:33:56 <Luke> just that exact line I pasted
13:34:00 <applicative> thank you ski
13:34:04 <dmwit> Luke: ghci calls show for you
13:34:09 <Luke> right... where's the other one from?
13:34:15 <Luke> encode?
13:34:24 <Luke> that's Aeson.encode btw'
13:34:30 <Shamar> let me guess: (,) is an arrow too?
13:34:35 <ski> nope
13:34:38 <applicative> no way
13:34:45 <Shamar> mmm
13:35:07 <applicative> don't worry Shamar the cool haskellizers are using Profunctors these days anyway
13:36:06 <applicative> @hoogle dimap
13:36:21 <Shamar> what's a Profunctor? :-o
13:36:28 <dmwit> Luke: Could not reproduce.
13:36:36 <applicative> dimap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
13:36:39 <dmwit> Luke: I get "{\"name\":\"test\",\"age\":1}"
13:36:39 <Luke> wtf is going on
13:37:10 <applicative> Shamar: I can't remember how did Arrow come up?
13:37:23 <dmwit> Shamar wanted to use (&&&) specialized to (->).
13:37:35 <dmwit> (Which is not the same as dimap.)
13:38:03 <applicative> no it isn't, I wasnt supposing that
13:38:07 <oax> I'm tryint to use ghci as an interactive environment like I used ipython previously.  I was irked to find my bindings go away when I :reload, so I tried to make a "script" (for running with ghci's :script) that would set up my stuff.  the setup is IO based (reads and processes large files), but I figured :script would operate like typing lines into ghci directly.  alas it does not
13:38:10 <joelteon> oh, I get it
13:38:15 <joelteon> so (->) could be a Profunctor
13:38:17 <dmwit> applicative: I'm sure you know. I was informing Shamar, mostly.
13:38:48 <Shamar> thanks both...
13:38:55 <oax> so how do I fire off a bunch of readFiles and processing of those files and bind them in my session with one easy command?
13:39:18 <applicative> Shamar: it's just a tradition that if people want a predefined combinator to do \f g a -> (f a, g a) they use the much more general one in Control.Arrow
13:39:34 <dmwit> "much" more general
13:39:44 <applicative> slightly more general?
13:39:45 <dmwit> There's not *that* many Arrow instances floating around.
13:39:48 <dmwit> =P
13:40:00 * applicative figures there are countably many
13:40:09 <Shamar> just 2?
13:40:30 <applicative> just 2 what?
13:40:33 <dmwit> I guess there's (->) and the one that one XML package uses.
13:40:42 <applicative> and Kleisli m a b
13:40:45 <joelteon> there's a finite list of Arrow instances that typecheck
13:40:57 <Shamar> hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Arrow.html
13:41:11 <joelteon> well actually
13:41:13 <joelteon> there might not be
13:41:52 <dmwit> Yeah, and Kleisli.
13:41:54 <Shamar> why there are so many Monads and so few Arrows?
13:42:06 <joelteon> because monads are like burritos
13:42:07 * Shamar naive...
13:42:09 <applicative> the laws for ArrowLoop have a gallows character to them: right tightening, left tightening, extension, sliding
13:42:11 <dmwit> Well, thanks to Kleisli, there are at least as many Arrows as Monads. =)
13:42:14 <applicative> an arrow is like a noose
13:42:26 <applicative> an ArrowLoop is like a noose
13:42:44 <dmwit> The problem is that there's not a lot of Arrows that are not also Monads, so most of the time you might as well just use Monad instead.
13:42:54 <leifw> an ArrowHoop is like a moose
13:43:03 <dmwit> (Interpret this loosely enough that there is no kind error, please. Thank you.)
13:43:16 <dgpratt> following someone's advice, whenever I get the warning from cabal telling me that what I've asked it to do may break existing packages, I've been adding the mentioned packages to the list of packages to install, which seems to work...
13:43:28 <applicative> Arrow trolling is a favorite #haskell pasttime
13:43:49 <dgpratt> ...but it has me wondering: is this something a slightly more clever cabal could do itself?
13:44:01 <dgpratt> (with appropriate warnings, of course)
13:44:38 <geekosaur> um, reinstalling packages like that is not really a good idea, it can just spread the breakage to other installed packages dependent on the originals
13:45:01 <dgpratt> geekosaur: would cabal not warn about that possibility?
13:45:01 <applicative> I'm not familiar with this advice, I wonder what it does
13:45:01 <dmwit> It's a fine idea, but cabal definitely shouldn't do it itself.
13:45:27 <dmwit> applicative: It lets cabal replace the other package's underlying dependencies.
13:45:39 <dgpratt> dmwit: why not?
13:45:46 <dmwit> applicative: e.g. it would let cabal change foo-0.1 (which depends on bytestring-0.9) to foo-0.1 (which depends on bytestring-0.10).
13:46:21 <dmwit> applicative: ...where here "it" is "adding foo to the cabal install line"
13:46:34 <applicative> yeah i see
13:47:06 <applicative> but now you have two bytestrings still
13:47:07 <cariveri> How to implement a read until "<specific command key>" in haskell ?
13:47:12 <dmwit> dgpratt: Well, actually... I'm not sure.
13:47:36 <dmwit> dgpratt: It would be a bit annoying to find it rebuilding apparently unrelated packages -- possibly taking a long time.
13:47:42 <joelteon> cariveri: hGetChar + recursion
13:47:43 <nomeata> Hi. How do I make "cabal install --enable-tests" run the test suites of newly installed dependencies as well, and not just the package I am listing on the command line?
13:47:51 <dmwit> But that could easily be a "warning: tell me --take-a-long-time to use this crazy plan".
13:48:01 <dgpratt> dmwit: I'm not thinking it should do it automatically
13:48:26 <dgpratt> or...oh, maybe it's bad form to have cabal prompt you, eh?
13:48:44 <dmwit> I guess they've tried to stay away from being interactive.
13:48:54 <dgpratt> dmwit: yeah, makes sense
13:49:07 <dmwit> But they cheat a bit in a couple places (e.g. with text like "add --force-reinstalls if you think this is a good idea anyway").
13:49:16 <Fuuzetsu> nomeata: I don't believe you can.
13:49:18 <dmwit> So it might not be horrible to add another such cheat.
13:49:24 <dmwit> I'm warming up to this idea. =)
13:49:29 <dgpratt> I think we need a new --try-harder option
13:49:37 <Fuuzetsu> If you want to test the packages you pull in, you'll have to do it by hand.
13:49:58 <nomeata> Fuuzetsu: ok, thx
13:50:09 <cariveri> joelteon: aint that combersom ? the command key could also be "exit" word or so.
13:50:15 <joelteon> yeah
13:50:19 <applicative>  cariveri what is the difficulty you are having? is it different from ...
13:50:21 <joelteon> but there's no "get until separator" in the standard library
13:50:40 <dmwit> cariveri: Perhaps you would like the Shellac package?
13:50:47 <dmwit> cariveri: or "wizards"
13:51:05 <applicative> cariveri: there are various line oriented libraries of different degrees of immensity
13:51:12 <fruitFly> question in the title http://hpaste.org/89307
13:51:15 <fruitFly> simple stuff
13:51:17 <applicative> wizards??
13:51:19 <cariveri> dmwit: ok Ill check this.
13:51:44 <applicative> ah I see http://hackage.haskell.org/package/wizards
13:51:49 <Botje_> fruitFly: looks like elemIndex returned Nothing.
13:52:04 <Botje_> (probably because base64Values doesn't contain =)
13:52:16 <cariveri> applicative: ok . give me a minute.
13:52:29 <applicative> ah wizards uses terminfo
13:53:31 <dmwit> fruitFly: Well, do you understand what the error says?
13:53:32 <applicative> or rather haskeline
13:54:08 <fruitFly> dmwit: Botje_ I get it, surprised the logic was not right, checking it now though
13:54:47 <joelteon> I wish I had known wizards existed 6 months ago
13:55:11 <carter> anyone else see the neil mitchell remark about using Shake to build LLVM from source a bajillion times faster? https://plus.google.com/113926289500476760879/posts/8wd8ACANcnP
13:55:19 <carter> i really need to mess with shake :)
13:55:36 <applicative> cariveri: here's a sort of haskeline demo http://code.haskell.org/haskeline/examples/Test.hs which is perhaps a bit much trouble
13:56:00 <dmwit> carter: That didn't build anything faster. It just *started* the build faster.
13:56:06 <dmwit> (no?)
13:56:15 <fruitFly> dmwit: Botje_ omg what is the easiest to tell what char is going into the function? I do NOT see how it is not a member?
13:56:37 <dmwit> carter: ...but you still really need to mess with shake. ;-)
13:56:40 <carter> yes
13:56:42 <carter> that too
13:56:54 <Botje_> fruitFly: Nothing -> error ("Unexpected character: " ++ [char])
13:57:02 <carter> either way, its very cool
13:57:08 <carter> and worth being intrigued by :)
13:57:35 <dmwit> agreed
13:57:57 <carter> even if i may or may not be interpreting it correctly :)
13:58:20 <dmwit> Stop being so reasonable, yeesh.
13:58:27 <dmwit> You'd think we weren't on the Internet or something.
13:58:30 <carter> dmwit pester me into converting my benchmark demo code that i've not made public yet to using shake
13:58:33 <fruitFly> Botje_: thanks! so error just breaks from the program and allows you to print?
13:58:34 <carter> during hacphi
13:58:42 <carter> dmwit if i admit when i'm wrong
13:58:52 <carter> i'm more likely to be right the rest of the time :)
13:58:57 <carter> mwhahahahahaha
13:59:05 <Botje_> fruitFly: yes.
13:59:05 <dmwit> carter: Convert your benchmark demo code to shake during HacPhi.
13:59:09 <dmwit> carter: do it do it do it
13:59:20 <carter> dmwit i'll need cheer leading in situ :)
13:59:28 <carter> because otherwise i'll get nerd sniped HARD
13:59:34 <carter> you may remember me being distratable last year
13:59:42 <dmwit> nerd sniping is SOP at hackathons
14:00:09 * carter has to wear flak armor and a helmet just to get work done
14:01:09 <carter> dmwit I am happy that i'm good at nerd sniping everyone else now
14:01:18 <carter> ish
14:03:43 <fruitFly> problem in the title?!?!?! http://hpaste.org/89310
14:03:58 <fruitFly> how is it parsing '+' ?!
14:04:49 <dmwit> > "foo"
14:04:49 <goodfellow>   "foo"
14:04:53 <dmwit> amazing
14:04:58 <dmwit> :t "foo"
14:04:58 <goodfellow> [Char]
14:05:08 <dmwit> ?tell dmwit_ something
14:05:08 <goodfellow> Consider it noted.
14:05:12 <oax> does is there some way to get ghci to read a text file just as lines entered interactively?  :sccript does not do this
14:05:15 <oax> :script i mean
14:05:15 <dmwit_> ?messages
14:05:32 <dmwit_> ?botsnack?
14:05:32 <goodfellow> :)
14:05:35 <dmwit_> urk
14:05:37 <dmwit_> ?nick dmwit
14:05:38 <goodfellow> unexpected "m": expecting number
14:06:08 <dmwit> Oh, lambdabot doesn't respond to ?messages in-channel any more. Okay, then.
14:08:10 <dolio> It might be quiet.
14:08:19 <dmwit> No, it responded in privmsg.
14:08:22 <dolio> Due to issues I don't recall.
14:08:34 <dmwit> ...and by "it" I mean "goodfellow".
14:08:58 <dmwit> There is no lambdabot in-channel with the nick "lambdabot" at the moment.
14:09:05 <dolio> Oh.
14:10:05 <dmwit> fruitFly: Your implementation of base64valid is horrible. You should probably rethink it entirely instead of trying to fix what you have.
14:10:22 <danl-ndi> byorgey: FreeFull:  thanks... just got back from lunch
14:10:51 <fruitFly> dmwit: thanks :) ... anything in particular? would I benefit from vectors? know nothing about them?
14:12:07 <dmwit> That seems unnecessary.
14:12:18 <dmwit> Just think more carefully about what it means to be valid base64.
14:12:23 <lispy> @remember geekosaur bigotry is off topic for #haskell
14:12:24 <goodfellow> Good to know.
14:12:46 <dmwit> lispy: You might want to do that again once the real bot comes back.
14:13:31 <lispy> dmwit: yeah
14:13:38 * lispy didn't know lambdabot was down
14:14:07 <dmwit> Heck, I would even be tempted to delete "base64Valid" as a function entirely.
14:14:17 <dmwit> Check whether it's valid during conversion instead.
14:17:57 <dmwit> Let's see, just for fun...
14:18:04 <dmwit> > U.universe :: [()]
14:18:05 <goodfellow>   Not in scope: `U.universe'
14:18:09 <dmwit> bummer
14:18:12 <dmwit> ...wait, what?
14:18:31 <dmwit> ?quit
14:18:59 <dmwit> > U.universe :: [()]
14:18:59 <goodfellow>   Not in scope: `U.universe'
14:19:03 <dmwit> huh
14:19:55 <dmwit> I would have expected modifying ~/.cabal/share/lambdabot-4.3/State/{L,Pristine}.hs would... modify something.
14:23:52 <Shamar> sometimes I wonder if maths (and haskellers) invent new words just to look cool
14:24:24 <cariveri> epl :: String -> (String -> IO()) -> IO ()
14:24:39 <josephle> Shamar: examples of said words?
14:24:45 <dmwit> Shamar: invent new words: yes; just to look cool: very no
14:24:46 <applicative> foldr?
14:24:54 <applicative> zip?
14:24:56 <cariveri> i> epl :: String -> (String -> IO()) -> IO ()
14:24:59 <Shamar> Category
14:25:13 <geekosaur> how is that a new word?
14:25:14 <dmwit> ...that word long predates its usage in math and Haskell.
14:25:18 <scriptor> what would you have called them?
14:25:28 <acowley> dmwit: I think some people do. People try to name things in papers all the time, and 90+% of those names don't catch on.
14:25:30 <josephle> applicative: I think zip has been around since the invention of the...Zipper
14:25:31 <ski> the cetegory terrorists stole the word "category" (and "monad") from the philosophers
14:25:32 <applicative> 'category' was coined by Aristotle.
14:25:49 <josephle> 'monad' was also coined before Category Theory
14:26:02 <josephle> not that anyone uses its original meaning anymore
14:26:06 <ski> eh s/cete/cate/
14:26:16 <dmwit> acowley: I can just imagine Gauss strutting down the street going "I invented the word monoid, and I am a RAD DUDE"
14:26:20 <applicative> the categories' means something like 'the charges' -- theft, aggravated assault, etc
14:26:21 <josephle> ski: you beat me to it
14:26:27 <dmwit> (I'm sure he didn't invent the word monoid. Go with it.)
14:26:47 <cariveri> applicative: how to call this ?: epl p f = do with signature i> epl :: String -> (String -> IO()) -> IO ()
14:26:53 <acowley> dmwit: I'm pretty sure Gauss did strut down the street going, "I am a RAD DUDE." If he didn't, and I was there, I would have encouraged him to do so.
14:26:54 <applicative> the -oid ending is unusually revolting
14:27:15 <applicative> epl = flip ($)
14:27:24 <ski> cariveri : dunno .. perhaps `epl myString putStrLn' or something
14:27:53 <applicative> @type (&)
14:27:54 <goodfellow> Not in scope: `&'
14:28:03 <applicative> :(
14:28:12 <dmwit> lens is not Safe Haskell
14:28:17 <applicative> thanks goodfellow
14:28:22 <dmwit> So I doubt it will work.
14:28:25 <dmwit> But I'll give it a shot.
14:28:34 <applicative> safe haskell needs redefined then
14:28:47 <dmwit> I mean... it literally uses unsafeCoerce.
14:28:48 <Shamar> safe haskell? what's that?
14:29:00 <applicative> Shamar:  a language extension
14:29:01 <Shamar> the safe package?
14:29:02 <acowley> If "Safe Haskell" is redefined to mean lens, then it's name would be rather too ironic for actual use.
14:29:09 <dmwit> It's a subset of Haskell that can't do anything interesting like IO.
14:29:11 <acowley> its, too!
14:29:21 <ski> @wiki Safe Haskell
14:29:21 <goodfellow> http://www.haskell.org/haskellwiki/Safe_Haskell
14:29:25 <applicative> Shamar: no, it recursively checks that certain obnoxious language features are not used
14:29:26 <cariveri> ski: this is all of it : http://hpaste.org/89313
14:29:33 <acowley> lens celebrates unsafeCoerce's entire catalog
14:29:54 <cariveri> ski: but I dont know how to call it . repl "string" <what? a function?>
14:31:13 <dmwit> cariveri: Did you try ski's suggestion?
14:31:17 <dmwit> If not, do.
14:31:31 <ski> cariveri : oh, it's apparently in CPS, you call it like `repl "myPrompt>" $ \command -> ..command..'
14:31:40 <applicative> Shamar: so the lens package is out for the reason acowley mentioned
14:31:47 <cariveri> dmwit: yes putStrLn did it.  repl string PutStrLn
14:31:53 <cariveri> thansk ski
14:32:04 <ski> cariveri : where `..command..' is any `IO'-action that does something depending on the value of the read `command'
14:32:40 <ski> cariveri : and apparently if you want to continue with a repl prompt after this, you need to explicitly (tail-)call `repl' again -- it doesn't do that itself
14:32:52 <dmwit> :t (&)
14:32:53 <goodfellow> Not in scope: `&'
14:33:00 <dmwit> huh
14:33:35 <Shamar> and what about the safe package? anyone use it? Actually I'm wondering why head don't returns a Maybe by default..
14:33:40 <dmwit> Okay, I very don't understand new-lambdabot.
14:33:41 <ski>   repl "myPrompt>" $ \command -> do
14:33:42 <ski>     ...
14:34:06 <applicative> Shamar: that's a different matter.
14:34:08 <ski> would be one common way to format it, where `..' may be multiple `do'-commands
14:34:51 <applicative> Shamar: i'm not sure what good a Maybe would do; you can pattern match on it but you can pattern match [] vs. (x:xs) already
14:34:55 <dmwit> > 3
14:34:56 <goodfellow>   L.hs:34:1:
14:34:56 <goodfellow>      Control.Lens: Can't be safely imported!
14:34:56 <goodfellow>      The module its...
14:35:06 <nooodl> haha
14:35:06 <applicative> heartbreaker
14:35:11 <dmwit> Okay, I guess :t and > might work differently?
14:35:26 <ski> cariveri : it would be possible to say `repl :: String -> ContT () IO String', and then you could just write `do command <- repl myPrompt; ..command' instead -- but you may safely ignore this for now, if you wish
14:35:28 <applicative> >< for UnsafeHaskell
14:35:29 <dmwit> > 3
14:35:30 <goodfellow>   L.hs:32:1:
14:35:30 <goodfellow>      Control.Lens: Can't be safely imported!
14:35:30 <goodfellow>      The module its...
14:35:36 <Shamar> applicative... well at least I could use the do notation
14:35:46 <dmwit> > 3
14:35:46 <goodfellow>   3
14:35:57 <applicative> @type (&)
14:35:58 <goodfellow> Not in scope: `&'
14:36:07 <applicative> thanks goodfellow
14:36:22 <dmwit> I don't know, don't ask me. I just work here.
14:36:37 <applicative> I want to speak to the management!
14:36:51 <cariveri> ski: I think its fine. it works so far next thing is find the process package in the ubuntu repos
14:36:56 <ski> @hoogle (&)
14:36:57 <goodfellow> Could not find some databases: default
14:36:57 <goodfellow> Searching in:
14:36:57 <goodfellow>   .
14:37:04 <dmwit> Oh, FFS.
14:37:09 <quchen> (&) = flip ($)
14:37:11 <ski> cariveri : ooc, did you write `repl' yourself, or did you see it somewhere ?
14:37:55 <applicative> ooc? OOC. your teeth will shine. ooc is a programming language with objects, first-class functions, and pink unicorns. rock is an ooc compiler that generates C99.
14:38:27 <cariveri> ski: its a copy from somewhere else.
14:38:35 <ski> cariveri : also `case (length expr) of' can be written as `case length expr of' -- but in this case, it'd better to check `null expr' (in an `if'-`then'-`else', say)
14:38:43 <dmwit> applicative: (out of curiosity)
14:38:51 <applicative> ooc can also mean, out of context, out of character, out of control
14:38:54 <ski> (no need to check the whole length just to determine if it's empty or not)
14:39:00 <wavewave> i just made a sample for fficxx library. go check at http://www.github.com/wavewave/fficxx  :-D
14:40:17 <quchen> wavewave: Thanks for starting your readme with "This library does ...". Just a random remark.
14:40:42 <FreeFull> applicative: Are the pink unicorns invisible?
14:40:48 <wavewave> quchen: yeah. I did long time due finally. hehe
14:41:37 <quchen> ... so many libraries just say "hey I'm awesome and the update brings this, also thanks to my grandma for support".
14:42:13 * applicative thinks, pink unicorns? this channel is like hashish today...
14:42:43 <wavewave> I am planning to release version 0.1 during HacPhi. :-)
14:42:51 <wavewave> also with HROOT-0.8
14:43:11 <FreeFull> applicative: You are the one who mentioned them
14:43:36 <wavewave> fficxx can generate multiple cabal packages for C++ library at once.
14:43:44 <applicative> ah, the first hit for ooc was a programming language FreeFull
14:43:55 <FreeFull> applicative: I know
14:44:00 <FreeFull> Are the pink unicorns invisible?
14:44:12 <applicative> oh yes. this is oo. we hide them.
14:44:28 <wavewave> for example, HROOT has HROOT-core, HROOT-hist, HROOT-math, HROOT-io, HROOT-RooFit, HROOT-RooFit-RooStats etc....
14:44:33 <FreeFull> Pink unicorns do like being private
14:44:46 <applicative> in haskell by contrast we pattern match on pink unicorns
14:45:04 <FreeFull> What's the data declaration for them?
14:46:21 <josephle> PinkUnicorns :: forall a . a
14:46:48 <Fuuzetsu> unsafeCoerceUnicorn
14:47:26 <applicative> probably data Unicorn :: Color -> * where U :: Unicorn c
14:48:01 <kosmikus> GHC has -XPinkUnicorns now? are they in 7.10, or will it only be in 8.0?
14:48:15 <applicative> data Color = Pink | Blue ...; pinkUnicorn :: UnicornPink; pinkUnicorn = U
14:48:32 <applicative>  pinkUnicorn :: Unicorn Pink; pinkUnicorn = U
14:49:08 <Fuuzetsu> I think there's a discussion on libraries in order for whether we make class Horse u => Unicorn u …
14:49:33 * ski imagines a topological suspension of a pink unicorn
14:51:02 <kosmikus> Fuuzetsu: no, let's introduce that 10 years from now, when it will potentially break lots of code to do so ...
14:51:29 <Fuuzetsu> I'm just glad that Applicative => Monad is finally coming.
14:51:48 <Fuuzetsu> applicative: how do you live with all the name highlights you must get in Haskell channels?
14:51:57 <Peaker> it is?? when??
14:51:58 <kosmikus> is this decided then?
14:52:19 <Fuuzetsu> Well, it's not decided yet but it seems that it's pretty much sealed from libraries@
14:52:49 <Peaker> I'm already programming with a workaround: class (Applicative m, Monad m) => MonadA m where {} ; instance (Applicative m, Monad m) => MonadA m where {}
14:52:54 <ski> `pure' and `return' getting unified ?
14:53:03 <anthezium> hey y'all.  question: I have a simple algebraic data type data A = A1 | A2 | A3.  Is there a more automatic way to make an Arbitrary instance for it than instance Arbitrary A where arbitrary = elements [A1, A2, A3]
14:53:10 <Peaker> so I thread around a MonadA constraint instead of a Monad constraint
14:53:39 <Peaker> anthezium, http://hackage.haskell.org/packages/archive/derive/2.5.11/doc/html/Data-Derive-Arbitrary.html
14:53:40 <goodfellow> Title: Data.Derive.Arbitrary, http://tinyurl.com/l9kl7qo
14:53:44 <kosmikus> I've been following all these discussions on libraries, but am not really motivated to join them
14:54:21 <tabemann> too bad they didn't unify functor, applicative, and monad like that when they started using them
14:54:21 <anthezium> Peaker: ty, checking out
14:54:25 <Peaker> having return, mapM, filterM, zipWithM and many others with an Applicative constraint would be nice
14:54:30 <applicative> arbitrary = elements [minBound .. maxBound] with appropriate deriving is better than TH
14:54:32 <FreeFull> ski: There are data structures that are applicatives but not monads
14:54:33 <FreeFull> So no
14:54:54 <Peaker> applicative, unless you derive a whole bunch of stuff anyway
14:55:08 <Peaker> FreeFull, ??
14:55:19 <Peaker> FreeFull, you could have "pure" without "return"
14:55:25 <tabemann> to unify applicative and monad, they'd have to basically derive return from pure to avoid breaking a *lot* of code
14:55:26 <Peaker> FreeFull, (breaking all Haskell code in existence)
14:55:27 <kosmikus> FreeFull: I don't understand that argument
14:55:35 <ski> FreeFull : i know that, but i'm not seeing how it pertains to my question
14:55:36 <FreeFull> Peaker: Oh, yeah, you could
14:55:44 <anthezium> that source looks crazy
14:55:46 <tabemann> go and put return x = pure x in the definition of the type class Monad
14:56:00 <Peaker> tabemann, why do you eta expand like that?
14:56:08 <Peaker> it strains my hlint-trained brain
14:56:14 <applicative> I don't see the point of this.
14:56:17 <tabemann> Peaker: habit from working in languages other than Haskell
14:56:25 * ski extensionalizes
14:56:27 <applicative> yeah, tabemann quit eta-expanding!
14:56:28 <kosmikus> Peaker: you want mapM to have an Applicative constraint instead of a Monad constraint? but it should still be called mapM???
14:56:41 <Peaker> kosmikus, yeah
14:56:49 <Peaker> kosmikus, and I want a Monad constraint to imply an Applicative constraint
14:56:55 <tabemann> for some reason I practically never used partial application in OCaml, even though OCaml has it...
14:56:57 <applicative> tabemann: quit spamming the channel with all the eta expansion!
14:57:08 <FreeFull> mapA
14:57:11 <kosmikus> Peaker: but what's the point of the M in the name then?
14:57:21 <ski> kosmikus : though it could be deprecated in favor of a `mapA :: Applicative i => (a -> i b) -> ([a] -> i [b])' after a while ..
14:57:31 <tabemann> kosmikus: a synonym to avoid breaking so much existing code
14:57:32 <Peaker> kosmikus, I'd say there was never a point in the first place, except a silly way of doing module qualification
14:57:47 <applicative> why not just use return and ap and have done with it, then you can use a different applicative instance if there is one
14:57:49 <cariveri> ski: gosh I cant find the process package in ubuntu quantal.
14:57:52 <Peaker> kosmikus, it should have been: import qualified Control.Monad as M   M.filter, M.map, etc
14:58:10 <FreeFull> Of course, having Monad depend on Applicative implies that the Monad and Applicative instance for any type must agree
14:58:24 <Peaker> applicative, are you proposing having inconsistent Applicative/Monad instances??
14:58:29 <Peaker> applicative, that's terrible
14:58:38 <kosmikus> Peaker: fair enough. still, it's not quite the same function as fmap. (at least not in normal Haskell generalization terms)
14:58:57 <applicative> yeah, why not? or should I introduce a class OtherApplicative where pur ...
14:59:14 <tabemann> what they *should* have done is define >>= in terms of fmap and join...
14:59:15 <kosmikus> it's a bit unclear to me if the current proposals for Prelude changes will also re-unify map with fmap
14:59:16 <FreeFull> :t fmap
14:59:17 <goodfellow> Functor f => (a -> b) -> f a -> f b
14:59:19 <FreeFull> :t mapM
14:59:19 <goodfellow> Monad m => (a -> m b) -> [a] -> m [b]
14:59:22 <Peaker> kosmikus, That's why it's not Functor.map, but Monad.map (or in the new spirit: Traversable.traverse)
14:59:36 <ski> tabemann : .. as a default implementation
15:00:08 <enthropy> amazing that "ancient" haskell code like http://hackage.haskell.org/package/hacanon-light builds
15:00:08 <goodfellow> Title: HackageDB: hacanon-light-2008.10.28
15:00:09 <applicative> fmap and liftM have to be the same, but <*> and ap dont, so why insist on it?
15:00:11 <shachaf> hi goodfellow
15:00:15 <ski> @type liftM
15:00:16 <goodfellow> Monad m => (a1 -> r) -> m a1 -> m r
15:00:21 <tabemann> ski: of course
15:00:22 <ski> @type liftA
15:00:23 <goodfellow> Applicative f => (a -> b) -> f a -> f b
15:00:29 <kosmikus> Peaker: I still don't like it. mapM has a different feel than map; it should have a different name.
15:00:32 <applicative> enthropy: it has to be sufficiently ancient, if its merely medieval it doesnt build
15:01:17 <enthropy> this involves template haskell which has changed a little... could be there will be some runtime failures
15:01:44 <kosmikus> all I hope is that all these changes (if they're done) will be applied at once
15:01:54 <Peaker> kosmikus, well, it should just be discarded for "traverse", as "map" should become "fmap"
15:02:10 <kosmikus> yes, map -> fmap would be nice
15:02:15 <Peaker> kosmikus, but anyway, Control.Monad.map is a different name from "map"
15:02:19 <Peaker> Prelude.map or Data.List.map
15:02:20 <tabemann> why not make fmap map?
15:02:31 <tabemann> it wouldn't break any existing code
15:02:32 <applicative> that's a terrible idea too.
15:02:44 <tabemann> (if you kept fmap as a synonym)
15:02:46 <applicative> I want a separate concrete map for each fmap instance
15:02:50 <nathanfh> Can anyone tell me if there is a Foldable equivalent of Prelude.zip and if not, why not?
15:03:03 <applicative> I often define jmap :: (a->b) -> Maybe a -> Maybe b
15:03:11 <applicative> when it ought to be in the prelude
15:03:20 <tabemann> why have type classes then?
15:03:23 <kosmikus> applicative: why? and why j?
15:03:27 <S11001001> @ty map (1+) . read
15:03:28 <goodfellow> (Num b, Read b) => String -> [b]
15:03:41 <applicative> kosmikus: mmap too, but that's sort of the wrong association
15:03:49 <FreeFull> applicative: Why do you define jmap when you can use fmap?
15:03:58 <applicative> kosmikus: so that it is specialized; and so that if you are three fmaps deep you know where you are
15:03:59 <tabemann> reusing the name mmap would really not be a good choice
15:04:03 <kosmikus> applicative: well, it'd be more plausible to me than jmap ;)
15:04:26 <Taneb> nathanfh, you need Applicative. You might be able to do it with Traversable, but I don't think so. Foldable is basically just foldMap (:: Monoid m => (a -> m) -> t a -> m), you can't get the structure back
15:04:43 <S11001001> @djinn [a -> a] -> a -> [a]
15:04:43 <goodfellow> Djinn command failed: fd:10: hClose: resource vanished (Broken pipe)
15:04:48 <FreeFull> :t fmap fmap fmap fmap fmap
15:04:49 <goodfellow> Functor f => (a1 -> b) -> (a -> a1) -> f a -> f b
15:04:54 <geekosaur> so polymorphism should be discraded as an unworkable concept and be done with it?
15:04:58 <kosmikus> applicative: I can see your point, but it would apply to all overloaded functions, really
15:05:02 <Taneb> :t liftA2 (,) -- nathanfh
15:05:03 <goodfellow> Applicative f => f a -> f b -> f (a, b)
15:05:38 <S11001001> tabemann: it would break code anywhere the newly introduced Functor constraint couldn't propagate outwards.
15:05:54 <applicative> kosmikus: no, it's really distinctive of fmap in particular, I find; fmap (fmap (fmap g))) where they are all different is a nightmare
15:06:23 <kosmikus> applicative: :)
15:06:27 <applicative> and the type error will be totally obscure when map (jmap (emap f)) will be clear and what the error is will be clear
15:06:31 <Peaker> applicative, Do you also define (+.) :: Float -> Float -> Float
15:06:35 <applicative> making up emap for eithermap
15:06:41 <applicative> Peaker: there's no analogy
15:06:55 <Taneb> applicative, isn't fmap (fmap (fmap g)) almost lens in disguise?
15:07:01 <applicative> a + b +. c will be atype error anyway
15:07:06 <kosmikus> I'm ok having specialized versions
15:07:10 <Peaker> applicative, I missed your reply above about the inconsistent Monad/Applicative
15:07:18 <Peaker> applicative, there are laws binding Applicative and Monad as there well should be
15:07:31 <kosmikus> but it'd be somewhat more fair to have map and <$> be overloaded, and have all monomorphic versions have longer names
15:07:35 <kosmikus> or simply qualified names
15:07:39 <Peaker> applicative, because the Applicative/Monad instance semantics are not part of the instance -- they're part of the type.. if you want a different semantics, you should use a newtype
15:07:43 <kosmikus> like Data.List.map
15:07:49 <applicative> the same type * -> * can have more than one applicative instance, but only one functor or monad instance
15:08:04 <kosmikus> ok, qualified names are impractical here
15:08:07 <kosmikus> I'll take that back
15:08:12 <applicative> one of the applicative instances follows from the monad instance, and is return/ap
15:08:14 <Peaker> applicative, it should still have a newtype, because its Applicative and Monad instances are part of the type's meaning
15:08:26 <Taneb> applicative, I think it can have more than one Monad instance
15:08:32 <applicative> no way
15:08:43 <applicative> excluding the usual nonsense
15:08:57 <Peaker> applicative, AFAIK, there's always only zero or one valid Functor instances
15:08:57 <Taneb> Compare a Writer monad that appends to the right to one that appends to the left
15:09:05 <applicative> Peaker: right
15:09:11 <applicative> same with Monad
15:09:17 <applicative> not the same with Applicative
15:09:18 <Taneb> They are both valid Monads, but have different behaviour with non-commutative monoids
15:09:21 <Peaker> applicative, there can be multiple Monad instances
15:09:31 <Peaker> applicative, e.g: Taneb's example above
15:09:58 <applicative> this is a different case, there is a Monoid constraint
15:10:06 <Peaker> applicative, Anyway, if there are multiple possible instances for any class, then one should use newtypes
15:10:23 <Peaker> because instances aren't entities, they become part of the meaning of the type itself
15:10:23 <Taneb> Or data Pair a = Pair a a
15:10:44 <applicative> Peaker: why if I already have return and 'ap' for the stupid applicative instance that predated control.applicative
15:10:54 <applicative> why not use the new class to express something new?
15:11:12 <Taneb> join could be "\(Pair (Pair a _) (Pair _ b)) -> Pair a b" or it could be "\(Pair (Pair _ b) (Pair a _)) -> Pair a b"
15:11:23 <kosmikus> applicative: because it's confusing? :)
15:11:24 <Peaker> applicative, because everyone expects Applicative and Monad to have a relationship
15:11:33 <Peaker> applicative, and it's nice to be able to have Applicative => Monad
15:11:37 <applicative> Peaker: the whole point is that they shouldn't
15:11:47 <Taneb> Because there really should be "class Applicative m => Monad m"
15:11:50 <applicative> Peaker, if anything, the model for Applicative is zip
15:11:51 <Peaker> applicative, I want to be able to use all the Applicative-generic code on my Monads
15:12:00 <Peaker> applicative, and also on my non-monad applicatives
15:12:09 <applicative> Peaker: fine
15:12:16 <Peaker> applicative, and there are sensible laws binding Monad and Applicative
15:12:32 <applicative> Peaker: I am not making a technical error of any kind
15:12:34 <kosmikus> applicative: by saying you want to make incompatible instances you're actually convincing me that the superclass should really be added (when until now I just didn't care) :)
15:12:37 <Peaker> applicative, I don't want to have to make a silly choice between a Monad and an Applicative constraint when I'm writing Applicative-generic code
15:12:50 <Peaker> applicative, and if I choose Applicative, I can't use that code with any Monad!
15:12:52 <enthropy> does somebody have an account on darcs.haskell.org that could access http://darcs.haskell.org/~lemmih/hacanon/ ? I think it's a 404 because what used to be a /home/lemmih/public_html is now a  /home/lemmih/public_html-disabled after that time they had some security issues and could not verify that nothing was messed up
15:13:06 <Peaker> applicative, or rather, I can't use it with code that only passes around a Monad constraint (oops)
15:13:07 <applicative> if i can write an applicative instance on a newtype, I can I write it on the original type; similarly with monad
15:13:17 <applicative> your arguments are transparently empty
15:13:34 <Peaker> applicative, Why not have Eq and Ord use different ordinal relationships?
15:13:38 <applicative> or rather it seems to entail that we must not use zippy applicative instances at all
15:13:40 <Peaker> applicative, Num and Floating?
15:14:03 <applicative> since they cant be extended to monad instances, but the types in the cases in question do have monad instances
15:14:04 <Peaker> applicative, no, it just means the zippy and non-zippy semantics of a type need to be represented by differing newtypes
15:14:06 <Taneb> applicative, for [], the default Applicative instance is based on the Monad instance, and the zippy one is in a newtype
15:14:21 <FreeFull> When I use the applicative instance for lists, I don't tend to want the zippy behaviour
15:14:38 <enthropy> the alternative is to figure out how to darcs get this http://web.archive.org/web/20090104060313/http://darcs.haskell.org/~lemmih/hacanon/
15:14:38 <goodfellow> Title: Index of /~lemmih/hacanon, http://tinyurl.com/mtf6s7l
15:14:40 <Peaker> applicative, ala: ZipList and []
15:14:51 <applicative> Peaker: Eq and Ord are so unlike Functor Applicative and Monad. The laws barely determine anything in those cases
15:15:13 <Peaker> applicative, they're *exactly* the same.  Eq is a subset of the structure of Ord in exactly the same way that Applicative is a subset of the structure of Monad
15:15:14 <applicative> yes peaker but why shouldn't I declare a monad instance for ZipList
15:15:15 <applicative> ?
15:15:30 <Peaker> applicative, because it wouldn't have ZipList semantics or it wouldn't be a lawful Monad
15:15:41 <enthropy> dmwit: is goodfellow yours? Did you intentionally enable that url shortening bit, or that's just a default lambdabot thing?
15:15:44 <applicative> no, there is never a unique Eq instance, except in the case of () etc
15:15:53 <FreeFull> are ziplists relative monads?
15:15:59 <Peaker> applicative, So choose Num and Floating
15:16:14 <Peaker> applicative, or any sub-class relationship that expresses subset structure
15:16:29 <applicative> ZipList has the 'semantics' it has before any class instances are written; otherwise the whole idea of a type class makes no sense
15:16:35 <enthropy> hmm, seems that the wayback machine didn't save the files, just the index.html
15:16:41 <Peaker> applicative, no, the semantics of a type include its instances
15:16:59 <applicative> FreeFull: ZipList is a newtyped []
15:17:42 <applicative> so before class Profunctor existed -> had a different semantics
15:18:05 <Peaker> Profunctor might be a bad example because it only has one possible intance for (->)
15:18:13 <tabemann> you can also get the same thing with different applicatives for the same underlying values, such as Sum and Product
15:18:22 <Peaker> but if you make a class where multiple instances are possible, then yes -- adding a new class & instance does indeed change the type's semantics
15:18:29 <Peaker> or rather, refine them
15:18:30 <tabemann> whoops forget that
15:18:40 * tabemann forgot those were Monoids
15:18:46 <Peaker> applicative, do you know how GeneralizedNewtypeDeriving and TypeFamilies together make the type system unsound?
15:19:45 <applicative> Peaker, I'm not making any of the mistakes you're imagining
15:20:02 <Peaker> applicative, You're making the mistake of writing code that will break when Applicative becomes a superclass of Monad
15:20:13 <applicative> yeah, thats why I argue that it
15:20:17 <applicative> is a moronic idea
15:20:20 <Peaker> applicative, and will break in the presence of the assumptions virtually all Haskellers agree on
15:20:27 <applicative> by contrast, a Functor constraint is rational
15:20:46 <Peaker> applicative, having duplicate functionality in differing classes is a violation of DRY... writing every function twice: once for Monad and once for Applicative is dumb
15:20:50 <applicative> Peaker emphatically not. the core idea of applicative is Zip
15:21:03 <Peaker> applicative, The core idea of Applicative is having phase distinction about effects
15:21:16 <Peaker> applicative, Zip is merely one special case instance
15:21:26 <kosmikus> applicative: I'm sorry, but picking one instance and calling that "the core idea" is very strange
15:21:28 <applicative> this actually opposes the Applicative constraint on monad, as it excludes the correct Applicative instance in the cases where there is a zippy oinstance
15:21:37 <applicative> its a historical fact
15:21:55 <kosmikus> applicative: can you prove that?
15:21:56 <geekosaur> wat
15:22:00 <Peaker> Applicative lets you have a "phase" of composing together effects, and then a phase of composing together the values generated by those effects.. Monad lets you un-phase/interleave into a single phase
15:22:29 <Peaker> this phase distinction is an incredibly useful restriction on effect composition for many purposes
15:22:41 <applicative> http://hackage.haskell.org/packages/archive/hinze-streams/1.0/doc/html/Data-Stream-Hinze-Idiom.html
15:22:41 <goodfellow> Title: Data.Stream.Hinze.Idiom, http://tinyurl.com/27ckvo8
15:23:00 <applicative> liftA2 is properly a zip
15:23:02 <Peaker> Also, Applicative composes while Monad doesn't, and interesting types (e.g: Const a) have lawful Applicative instances and no Monad instances
15:23:19 <Peaker> applicative, It's not a "zip". zip is just a single instance
15:23:25 <ski> Peaker : hm, couldn't you make `ZipList' into a `Monad', by making `join' check the presence of a "square" instead of just extracting the diagonal ?
15:23:39 <applicative> see the original applicative class linked above
15:24:03 <Peaker> ski, I have never gone through the motion myself, as far as I've heard, it is either going to have a lot of partiality, or break Monad laws, but for me that's just hearsay :)
15:24:09 <applicative> ski is clearly you Peaker
15:24:15 <kosmikus> applicative: "Streams and Unique Fixpoints" came after the original Idioms paper
15:24:19 <Peaker> applicative, what?
15:24:20 <applicative> ski is clearly trolling you rather
15:24:38 <applicative> we can keep going
15:24:50 <Peaker> applicative, anyway, you seem to be thinking of Applicative in terms of one of its instances (maybe the original one)
15:24:56 <applicative> it is only the zip instances that give any point to the applicative class
15:25:04 <geekosaur> wat
15:25:06 <Peaker> applicative, but that's like thinking that Monads are about "allowing IO effects in a pure language"
15:25:13 <applicative> apart from them it's just return/ap
15:25:32 <Peaker> applicative, do you know the Applicative instance of "Const a"?
15:25:48 <Peaker> do you consider that "zip"?
15:26:04 <ski> Peaker : `join (ZipList [ZipList [0],ZipList [1,2]]) = ZipList [0]' here, iirc
15:26:06 <kosmikus> fwiw, in what I believe to be one of the first presentations of Conor on idioms (before the paper was written), I don't think the zip-idea was promoted to the core idea. many examples were mentioned.
15:26:09 <ski> applicative : not trolling
15:26:12 <applicative> this is really trying, i give up.
15:26:54 <Peaker> applicative, in closing, my main technical argument is that I don't want to write code that works for any Applicative twice -- once with an Applicative constraint, and once with a Monad constraint.. but you do -- and you want to make me duplicate all my code with you :(
15:27:04 <geekosaur> you are rather trying, yes. there's been a lot done with applicatives that you seem to think is either evil or nonexistent
15:27:13 <geekosaur> I can't quite tell which you've decided on
15:27:32 <geekosaur> but either way it sounds like nonsense
15:27:57 <applicative> not at all, I am only opposing the dogmatic insistance on adding the Applicative constraint to Monad, which arises from a logical error applied to to the fact that there must be one
15:28:03 <geekosaur> yes, the very original early applicative was a rather limited concept. so we've added to polymorphism is bad that generalization is bad
15:28:17 <geekosaur> what else shall we do to make the next haskell as stupid as possible?
15:28:36 * applicative favors adding a Functor constraint to Monad
15:28:59 <geekosaur> no, clearly that's too general
15:29:03 <applicative> adding an Applicative constraint really is a simple mistake
15:29:23 <applicative> it comes from reading Typeclassopedia too much
15:29:33 <Peaker> applicative, how do you suggest I avoid writing all my applicative generic code twice?
15:29:35 <ski> applicative : if you care for it, i'd be interested in hearing your argument another time (i'm a bit tired atm, and you said you gave up ftm)
15:29:50 <Peaker> applicative, (once with Applicative constraint, and once with Monad constraint)?
15:30:19 <geekosaur> obviously there shouldn't be an applicative constraint because it's not really an applicative, is it?
15:30:28 <geekosaur> only siplists are real applicatives y'know
15:30:32 <geekosaur> *ziplists
15:30:44 <geekosaur> if you think you have a monad that looks like an applicative, our leader here tells us you are wrong
15:30:47 <applicative> that isn't what I said
15:30:52 <geekosaur> and it can't possibly be applicative
15:30:54 <geekosaur> yes, it is
15:30:54 <kosmikus> Peaker: I don't quite understand why you have to. Generally, the only extra thing you have to define is an entirely trivial Applicative instance ...
15:31:04 <Peaker> applicative, do you have a suggestion for me? I stopped talking about tiring philosophy -- and started talking about a concrete technical thing
15:31:14 <geekosaur> ifg thtas not what uyou *meant* then you need to come back with something that is not nonsense
15:31:34 <Peaker> kosmikus, consider:  userCode :: Monad m => ....  ;  userCode = ... use genericApplicativeFunc here
15:31:39 * hackagebot xmobar 0.18 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.18 (JoseAntonioOrtegaRuiz)
15:31:39 <goodfellow> Title: HackageDB: xmobar-0.18
15:31:50 <Peaker> kosmikus, that won't work, because "m" is Monad, but not Applicative, even if you added Applicative instances to all Monads
15:32:06 <Peaker> kosmikus, you need to use: (Monad m, Applicative m) =>  ... *everywhere* to propagate that constraint
15:32:15 <Peaker> kosmikus, and that's the whole point of having Applicative m as a superclass for Monad m
15:32:28 <kosmikus> ok, but then I still misunderstood you
15:32:49 <kosmikus> an extra constraint is more harmless then duplicating actual code
15:33:03 <Peaker> kosmikus, so to be fair, I have two choices:  Write all applicative-generic code twice, or thread along an Applicative constraint with all my Monad constraint everywhere
15:33:20 <kosmikus> the latter being clearly preferable imho
15:33:22 <arkeet> type Monad' m = (Applicative m, Monad m)
15:33:29 <applicative> why not just write monad generic code, if thats what youre doing
15:33:31 <Peaker> kosmikus, there's also a third choice, and that is to wrap all my Applicative-generic calls on Monads with Applicative.WrapMonad and unwraps
15:33:32 <ski> kosmikus : except when you have to conform to an existing interface, maybe
15:33:39 <Peaker> applicative, because I want my code to work with types that aren't monads too
15:33:49 <kosmikus> perhaps
15:33:50 <Peaker> kosmikus, all three options are pretty bad
15:34:05 <applicative> I think your objection is the system of type classes.
15:34:08 <dmwit> enthropy: goodfellow is mine, and nothing was intentionally changed to be different from what you get with "cabal install goodfellow".
15:34:12 <dmwit> uh
15:34:17 <dmwit> "cabal install lambdabot", of course =P
15:34:18 <Peaker> applicative, what??
15:34:22 <applicative> All such objections are sound, so long as we forget the alternatives...
15:34:27 <kosmikus> so I'm actually mildly positive on adding the superclass constraint. I'm just surprised that so many people care so deeply. I hardly ever suffered. and I'm writing a lot of Haskell code.
15:35:48 <Peaker> applicative, imagine I have:  foo = traverse . traverse . traverse ;  with your system, I now need to also write:   fooM = T.mapM . T.mapM . T.mapM   if I want to be able to use foo with an Applicative constraint or with a Monad constraint
15:36:02 <Peaker> applicative, with my system, "foo" is usable with either constraint
15:36:09 <kosmikus> I just hope that all the Prelude changes will be collected an applied in one go. And soon (within the next year). So that I can write my Haskell book w.r.t. a "stable" version of Haskell :)
15:36:33 <applicative> hm, I wonder what the 'semantics' of the Pointed class are going to be ....
15:36:41 <Peaker> applicative, you make me write my code twice :(
15:38:08 <dmwit> ?djinn a -> a
15:38:08 <goodfellow> f a = a
15:38:47 <josephle> kosmikus: what will your haskell book be about?
15:39:17 <dmwit> ?djinn [a -> a] -> a -> [a]
15:39:17 <goodfellow> Error: Undefined type []
15:39:26 <dmwit> ?djinn Monad m => m (a -> a) -> a -> m a
15:39:26 <kosmikus> josephle: Haskell :)
15:39:26 <goodfellow> f _ a = return a
15:39:30 <dmwit> hm =)
15:39:50 <josephle> kosmikus: I knew that was going to be your answer. Anything specific about it?
15:40:03 <Peaker> dmwit, 0 is as good a number as any :)
15:40:13 <josephle> ?djinn [(a -> a)] -> a -> [a]
15:40:13 <goodfellow> Error: Undefined type []
15:40:14 <Peaker> (it could apply the function an arbitrary number of times
15:40:16 <dmwit> :t sequence
15:40:17 <goodfellow> Monad m => [m a] -> m [a]
15:40:38 <dmwit> Whoever was originally asking: sequence :: [a -> a] -> a -> [a] is probably the implementation you were looking for.
15:41:07 <quchen> kosmikus: One year might not be enough. Libraries have to be prepared for such a change, consensus has to be reached etc.
15:41:16 <kosmikus> josephle: you can look at http://kosmikus.org/~andres/TOC.pdf for a current planning of the TOC.
15:41:29 <josephle> kosmikus: thanks!
15:42:03 <kosmikus> quchen: I know. that's why I'm worried ;)
15:42:08 <applicative> ah, I see adding join to Monad failed in the minds of the enthusiasts for practical reasons, but of course it's the only rational proposal they had....
15:42:41 <kosmikus> in all the discussions about teaching it's often overlooked that any language-internal inconsistency is still much easier to explain than inconsistencies between language versions.
15:42:50 <Peaker> applicative, you still haven't told me why you want me to write my code twice :(
15:42:59 <josephle> kosmikus: that's quite the comprehensive set of topics
15:43:14 <eikke> applicative: adding join to monad would introduce loops with default implementations, which is why it's not proposed until the 'minimal implementation' pragma (forgot the real proposed name) is done
15:43:19 <kosmikus> josephle: does that mean you like it? :)
15:43:26 <applicative> yes I know eikke
15:43:34 <Peaker> applicative, same as: liftM2 duplicates liftA2, sequence duplicates sequenceA, and most of Control.Monad functions duplicate implementations for Control.Applicative
15:43:49 <applicative> liftM2 is different from zipWith
15:43:54 <quchen> applicative: The AMP discussion is still open on the libraries mailing list. Feel free to post your standpoint there.
15:44:00 <Peaker> applicative, liftM2 is a DRY violation of liftA2
15:44:08 <Peaker> applicative, sequence is a DRY violation of sequenceA
15:44:19 <Peaker> applicative, because your system is in place -- which forces all Applicative code to be written twice
15:44:20 <applicative> why do I have to write zipWith and zipWith3 and so on twice
15:44:24 <josephle> kosmikus: I'd like a book that had all of those topics :)
15:44:39 <kosmikus> josephle: ok, I'll hurry up then ;)
15:44:40 <Peaker> applicative, you don't have to ever write zipWith, you can use Applicative instance on ZipLists
15:44:48 * shachaf notes that even for the same type, (<*>)/liftA2/etc. can be more efficient than ap/liftM2/etc.
15:44:51 <josephle> kosmikus: it would beat having to go over n different documents
15:45:27 <eikke> shachaf: in theory
15:45:30 <Peaker> applicative, so... is it that you believe that your system doesn't cause all Applicative code to be written twice? Or do you believe that writing that code twice is a good thing?
15:45:58 <dmwit> kosmikus: Wait, you expect to write all this in one year?
15:46:04 <dmwit> ...or you just intend to start within one year? =P
15:46:31 <Peaker> applicative, or do you believe that code that is generic to all Applicatives is necessarily not useful when you're carrying a Monad constraint? (because this is demonstratably untrue)
15:46:32 <shachaf> kosmikus is writing a Haskell book?
15:46:37 <tabemann> I gathered *start*, as obviously one would want changes in Haskell to happen *before* starting to write
15:46:40 <josephle> dmwit: I suspect real world haskell would be a subset of his book :)
15:46:40 <quchen> dmwit: Google "structured procrastination". Ig Nobel Prize winning article, and highly relevant :-D
15:46:44 <Peaker> applicative, I think I covered all bases here
15:46:46 <kosmikus> dmwit: I have started. My "official" schedule is to finish in November 2014. so more than a year.
15:46:55 <shachaf> Oh, that TOC looks good.
15:47:00 <kosmikus> shachaf: yes.
15:47:02 <Peaker> applicative, tell me if I missed one -- or otherwise tell me which of these options do you believe
15:47:57 <geekosaur> I think applicative tried to claim that the fact you need to write them multiple times is a shortcoming similar to ZipListN
15:48:07 <kosmikus> shachaf, dmwit, josephle: I'm planning to formally announce that within a month or so. so I'd appreciate if you'd not post that anywhere just yet, although I'm of course perfectly aware that this channel is public.
15:48:16 <applicative> Peaker I would be happy to use MonadZip, which is in base, except it has a Monad constraint ...
15:48:20 <dmwit> kosmikus: noted
15:48:22 <geekosaur> but then they seem to have a hangup on ZipList being the only real abstraction in general
15:48:23 <josephle> kosmikus: got it.
15:48:25 <elliott> hm, is this a beginner haskell book or something else? (/me should read the TOC...)
15:48:28 <AStorm> hello, you folks seem to know a thing about functional programmin
15:48:28 <shachaf> kosmikus: Sure.
15:48:30 <Peaker> applicative, I don't understand -- which of these 3?
15:48:38 <eikke> kosmikus: looks interesting
15:48:52 <AStorm> so here's the hard task: how do I do OLS fitted natural cubic splines, fully functionally?
15:49:02 <applicative> Peaker: the complaint about (Monad m, Applicative m) carries less than zero weight with me
15:49:22 <eikke> kosmikus: why the explicit partim about Typeable?
15:49:27 <Peaker> applicative, better list: 1) no duplication actually needed 2) duplication is not avoidable 3) duplication is desirable ?
15:49:37 <applicative> duplication is desirable
15:49:40 <AStorm> no monads, no state other than perhaps knot points (and preferably instead only number of  splines)
15:49:41 <quchen> wat
15:49:42 <kosmikus> eikke: ?
15:49:45 <geekosaur> wat
15:49:52 <Peaker> applicative, so it is a good thing that we have to write all the Applicative code twice?
15:50:01 <eikke> kosmikus: in that TOC, why would you talk about Typeable in such book?
15:50:09 <geekosaur> again, you;re not supposed to because those aren't "real" applicatives...
15:50:15 <Peaker> or do you mean that it's good that we have to carry around (Applicative m, Monad m) whereever we carry around a (Monad m) ?
15:50:16 <josephle> eikke: I assume it'd be for dynamic exception handling?
15:50:53 <eikke> josephle: that seems the context indeed. not sure one needs to know *how* that works though
15:50:53 <applicative> the latter, Peaker
15:51:04 <Peaker> applicative, Why is that good?
15:51:10 <kosmikus> Typeable is useful for a number of things
15:51:16 <AStorm> or if you happen to not know how to put that specific problem in a pure functional form, do you happen to know who might know?
15:51:16 <kosmikus> I'm not overly fond of it either
15:51:19 <Peaker> applicative, "Monad m" becomes a bad thing, and we *always* want (Applicative m, Monad m), so why have the former at all?
15:51:24 <josephle> eikke: true. I don't know if people need to know the theory of dynamic classification.
15:51:32 <kosmikus> but it's good to mention it somewhere, I think
15:51:34 <shachaf> applicative: Uh, that's not true.
15:51:35 <josephle> eikke: but I suspect that section is on how to *use* typeable
15:51:37 <eikke> I'm not sure it's a good fit in an introductory book
15:51:41 <applicative> if you want return/ap use them
15:51:43 <kosmikus> also, with automatic deriving it becomes special
15:51:53 <shachaf> applicative: Er, never mind.
15:51:54 <Peaker> applicative, but I want code that has an Applicative constraint
15:52:00 <kosmikus> eikke: this isn't an introductory book (even though it starts from the beginning)
15:52:01 <Peaker> applicative, not return/ap
15:52:12 <eikke> kosmikus: regarding current discussion here and on libraries-list, sure you want to introduce Monad first, then Applicative in ch11? ;-)
15:52:23 <cariveri> dmwit: ski  thank oyu so much. now it works all liek a charme.
15:52:36 <shachaf> applicative: (Was responding to logs from a while ago.)
15:53:05 <eikke> kosmikus: right... I'd think there are more 'useful' type-classes than typeable to be introduced first, no?
15:53:06 <applicative> shachaf: I probably contradicted it several times later
15:53:17 <ski> cariveri : yw
15:53:19 <Peaker> applicative, So deep in some function, I want to call a piece of code that was written to work on any Applicative instance
15:53:24 <kosmikus> eikke: both Monad and Applicative are introduced in chapter 11.
15:53:27 <eikke> (just trying to give some constructive remarks)
15:53:34 <Peaker> applicative, now, my function has (Monad m) constraint.. so you say, no problem, just convert that to (Monad m, Applicative m), right?
15:53:43 <Peaker> applicative, but then, its caller breaks, because it too only has a (Monad m) constraint
15:53:45 <eikke> ah, so the items within a chapter aren't necessarily in order?
15:53:58 <applicative> like what Peaker, how many combinations of fmap and pure and <*> do you have in your giant variant of Control.Applicative
15:54:15 <Peaker> applicative, and soon enough, I have to fix a whole chain of callers to also thread around an extra constraint. Even worse, maybe this chain includes third party code that only has a Monad constraint, and cannot thread around an Applicative constraint?
15:54:15 <applicative> there isn't much there really.
15:54:38 <applicative> all of the interesting functions are already in control.applicative and there aren't many
15:54:39 <Peaker> applicative, Applicative-generic code isn't just code that purely uses these 3 functions. It can also use other functions
15:54:42 <kosmikus> eikke: the TOC is certainly preliminary. if I feel that something is better in a different order, I'll not hesitate and change it.
15:54:54 <Peaker> applicative, For example, I want to use lens functions that work with any Applicative
15:55:27 <applicative> Peaker you are just fighting against the type class system
15:55:34 <Peaker> applicative, no I'm not
15:55:35 <geekosaur> ...
15:55:42 <kosmikus> eikke: ah, so if you meant if I want to introduce Monad before Applicative within Chapter 11: I would if the libraries are as they're now.
15:55:49 <AStorm> the tricky part I think is purely functional linear system solving
15:55:52 <AStorm> possible?
15:55:52 <Peaker> applicative, The set of code that has   (Applicative f, NonMonadConstraintsHere)  => ...   is infinite because if you compose applicative code with arbitrary code -- you get code that's usable on any applicative
15:55:55 <eikke> that's what i meant indeed :)
15:55:59 <kosmikus> eikke: that's why I want all this to be resolved befoee I actually write it ;)
15:56:09 <applicative> I think you should begin with Pointed that really stimulates intuition
15:56:11 <Peaker> applicative, and this code is all going to need to be written *again* for a (Monad f) constraint
15:56:21 <Peaker> applicative, don't change the subject please :)
15:56:30 <Peaker> we're almost at an agreement here!
15:56:35 <kosmikus> applicative: no, I don't like Pointed.
15:56:35 <applicative> Peaker: I am familiar with the Haskell programming language
15:56:42 <eikke> kosmikus: looks interesting & 'complete' (although I'd move things around a bit, like push ch22 up)
15:56:50 <shachaf> Peaker, applicative: I think this belongs in #haskell-overflow at this point.
15:57:10 <applicative> i dropped long ago, but the enthusiasts keep attacking me
15:57:23 <eikke> kosmikus: if you're ever looking for proofreaders, I'd love to get a shout and give it a shot :-)
15:57:51 <kosmikus> eikke: Chapter 22 depends on most other chapters.
15:58:03 <kosmikus> eikke: being near the end doesn't mean it's unimportant though.
15:58:15 <kosmikus> eikke: thanks. I'll keep that in mind.
15:58:37 <dmwit> kosmikus++ in anticipation
15:59:24 * kosmikus actually has to prepare a 2-hour tutorial on type-level programming within the next few weeks.
15:59:26 <applicative> kosmikus: yes I was making a surly joke mentioning Pointed.
16:00:16 * eikke used type-level programming for a 'real engineering' use-case recently
16:00:17 <kosmikus> applicative: sorry, after the discussions today my sarcasm detector seems to be malfunctioning slightly ;)
16:00:44 <josephle> so is type-level programming just gateway drug into dependent types?
16:00:51 <dmwit> yes
16:00:53 <kosmikus> josephle: yes
16:00:59 <kosmikus> eikke: what for?
16:01:38 <elliott> josephle: types are the gateway to dependent types. advanced haskell type hackery is the dodgy street version
16:01:57 <eikke> enforce some invariants on some datatype describing some datastructure, so I can't write functions over the type which would break the invariants
16:02:09 <tabemann> by type-level programming... that's where you use multivariable type classes with type dependencies as functions? (or do I have the wrong idea here?)
16:02:28 <dmwit> That's one way, yes.
16:02:31 <kosmikus> eikke: can you make that more concrete. I'm always looking for concrete examples.
16:02:32 <elliott> you can do type-level functions much easier than that with type families nowadays
16:02:33 <dmwit> TypeFamilies and GADTs are another way.
16:02:38 <eikke> tabemann: that can be part of it, yes
16:02:46 <ChongLi> what about type-level peano arithmetic?
16:03:18 <eikke> kosmikus: the gist of it is in https://gist.github.com/NicolasT/5672973
16:03:18 * tabemann is less familiar with type families and GADTs, even though he's seen examples of GADTs
16:03:25 <dmwit> ChongLi: What about it?
16:03:25 <applicative> types arent a gateway to dependent types. this is pure advertising.
16:03:27 <eikke> I got a more cleaned-up version, but taht's not OK for publication
16:03:41 <Peaker> tabemann, GADTs are pretty great
16:03:42 <ChongLi> dmwit: I figured it'd be another example
16:03:54 * dmwit nods agreeably
16:04:00 <Peaker> tabemann, https://github.com/yairchu/red-black-tree/blob/master/RedBlackTree.hs#L27 <-- written by a friend of mine, is my go-to example to show why GADTs are great
16:04:51 * elliott wonders what it looks like when dmwit nods disagreeably
16:05:02 <eikke> kosmikus: I should look for a way to describe/maintain sorted'ness at type level, that would be awesome
16:05:18 <dmwit> One never nods disagreeably; one must shake their head disagreeably.
16:05:20 <DiegoNolan> can anyone help me with this cabal install yesod-bin error I'm getting?
16:05:31 <blackdog> dmwit: isn't that a double negative?
16:05:33 <shachaf> Maybe #yesod can help.
16:05:38 <kosmikus> eikke: thanks
16:05:39 <DiegoNolan> ahh
16:05:40 <augur> yo kosmikus
16:05:43 <DiegoNolan> k lemme check it out
16:05:46 <dmwit> blackdog: ain't no such thing
16:06:00 <kosmikus> augur: hi
16:06:15 <josephle> eikke: are you sure you don't want to just use depended types?
16:06:28 <levi> kosmikus: Just looked at your ToC, looks good! Looks like a lot of work and a very large book, though.
16:06:54 <blackdog> dmwit: :) reminds me of that old joke about the linguistics lecturer explaining that there are some cases of double-negative being a positive, and some of it being a negative, but no cases of double-positive ever being negative
16:07:05 <eikke> josephle: I should play around with Agda I guess. Tried to get into Coq quite some time ago but next to some very basic/simple things, the barrier to entry was just too high back then
16:07:09 <blackdog> and "Yeah, right" floats in from the back of the class.
16:07:11 <kosmikus> josephle: even if we wanted to (use dependent types), we also sometimes want to run code efficiently, and then currently Haskell is still > {Agda, Idris, Coq}
16:07:37 <kosmikus> levi: thanks. yes, it is. currently hoping to finish it with ~700 pages.
16:07:39 <Peaker> kosmikus, Agda should have more optimization opportunities than Haskell
16:07:39 <augur> running code is for the weak of heart!
16:07:59 <eikke> kosmikus: you're welcome. good luck with the writing, and if you'd ever like feedback from someone with some basic haskell knowledge, poke me ;-)
16:08:00 <kosmikus> Peaker: and Haskell should have more optimization opportunities than C.
16:08:02 <josephle> kosmikus: is there any good reason why Agda, Idris, and Coq are inefficient?
16:08:14 <kosmikus> Peaker: opportunities don't translate into speed directly.
16:08:23 <augur> josephle: not as much time and effort put into compiler tech for them
16:08:30 * eikke sleepy-time
16:09:13 * tabemann is trying to wrap his brain around GADTs, particularly how it works when you have type variables to the left of the last -> in the type of a constructor that are missing to its right
16:09:13 <Peaker> kosmikus, well, unless you use explicitly unsafe stuff in Haskell, you're forced to go through runtime checks that Agda could avoid.  whereas in C you can write pretty much any program that's outputted by the Haskell optimizer (even if very ugly).  So the analogy is a bit broken
16:09:33 <levi> kosmikus: My only suggestion, and it is from a position of not knowing at all what your goals are, so for what it's worth... you might consider focusing just on the more recent developments and more advanced topics.  There's a lot of good material out there on the basics of data types and pattern matching and such.
16:09:48 <Peaker> tabemann, they're "forall"d around that constructor, effectively becoming existentials
16:10:05 <c_wraith> tabemann: you don't need GADTs for that, by the way.  data Foo a = Foo
16:10:13 <kosmikus> levi: that's a valid point. but I honestly don't feel I can tell a coherent story without covering the more basic parts as well.
16:10:14 <Peaker> c_wraith, other way around
16:10:22 <kosmikus> levi: and I do care about coherence ...
16:10:27 <c_wraith> oh, man, I have so much trouble with left and right.
16:10:43 <Peaker> tabemann, do you know ExistentialQuantification?
16:10:44 <augur> tabemann: you have to let go of your intuitions
16:10:46 <tabemann> Peaker: okay, so types to the left of the last -> that are not found to its right are implicit foralls
16:10:51 <josephle> Peaker: I think what he's saying is, just because we're allowed to make optimizations doesn't mean there's someone willing to write them :)
16:11:00 <eikke> tabemann: see e.g. https://github.com/NicolasT/kontiki/blob/master/src/Network/Kontiki/Types.hs#L242 and how&why that type is used throughout the code
16:11:04 <tabemann> Peaker: no
16:11:18 <levi> kosmikus: Yeah, I do understand that. :)
16:11:27 <kosmikus> Peaker: the amount of time that has been spent on designing the Agda backend(s) is insanely small compared to the amount of time that has been going into optimizing Haskell
16:11:33 <levi> Despite my advice, I would probably do things that way too.
16:11:35 <augur> tabemann: you should watch some stuff on type theory!
16:11:42 <kosmikus> Peaker: so it's really not a question about theory, but one about practice
16:11:54 <kosmikus> Peaker: and in that sense, it's still true for Haskell vs. C
16:12:04 <Peaker> kosmikus, yeah, I see.. I think Haskell optimizers on uniprocessor will never quite catch up to well tuned C though.. otherwise I understand your point and agree
16:12:13 <Peaker> (about Haskell/Agda)
16:12:25 <kosmikus> Peaker: gcc is older and has far more people looking into making it efficient han GHC, even if the people doing GHC are extremely brilliant geniuses
16:12:46 <josephle> kosmikus: one of these days, gcc will actually have register allocation (hah.)
16:12:49 <bitonic> Agda does have more challenges as a language though, in terms of performance
16:12:59 <Peaker> kosmikus, I don't think it's the thing though, I think C just allows faster uniprocessor code to be written than virtually any mandatory-GC'd language
16:13:02 <kosmikus> bitonic: also true.
16:13:05 <bitonic> the main challenge would be to remove irrelevant things in a precise way
16:13:15 <tabemann> augur: my knowledge of type theory basically goes as far as M-H type systems, algebraic data types, and things like parameterized modules in ML
16:13:21 <kosmikus> while dependent types introduce new optimization opportunities, they also pose new challenges.
16:13:27 <bitonic> and the oh-so-flexible modules (although solving that problem is similar to solving the type class problem, e.g. specialization)
16:13:27 <Peaker> tabemann, data Foo = forall a. Foo a
16:13:34 <augur> tabemann: i figured, hence the suggestion :)
16:13:39 <kosmikus> lacking a phase distinction, you have to discover what you can safely eliminate, whereas it's obvious in Haskell.
16:13:49 <tabemann> Peaker: well that I know; I'm more trying to figure out how GADTs work
16:13:57 <Peaker> tabemann, so you do know ExistentialQuantification then?
16:14:13 <bitonic> there’s also the fact that we don’t really know how Agda is supposed to be evaluated.  if we decide it should be strict, then that makes things easier again :P
16:14:14 <kosmikus> levi: :)
16:14:24 <bitonic> and it makes more sense for Agda to be strict
16:14:27 <tabemann> I didn't know the name for it
16:14:29 <Peaker> tabemann, that's like doing:  data Foo where Foo :: a -> Foo
16:14:31 <applicative> awesome type that data Foo = forall a . Foo a
16:14:36 <augur> tabemann: ignore this channel for a while
16:14:39 <josephle> tabemann, if you know how SML compiles its parameterized modules (dependent kinds), you only have one more level of abstraction to go!
16:14:39 <kosmikus> alright. time for bed. good night.
16:14:49 <augur> http://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
16:15:05 <augur> tabemann: watch the proof theory and type theory lectures there
16:15:07 <bitonic> josephle: again the big problem would be to eliminate irrelevant stuff
16:15:14 <augur> in that order
16:15:19 <bitonic> more than parametrised modules which as you say it’s a bit of a solved problem
16:15:21 <jiag> Hi, this may seem like a silly question.  I'm trying to find out the difference between <- and =  .  Can somebody point me at the right spot?
16:15:24 <Peaker> tabemann, so basically, GADTs let you have existentially quantified types in your constructors with less hassle
16:15:28 <Peaker> tabemann, (amongst many other things)
16:15:34 <tabemann> augur: following that link...
16:15:40 <josephle> bitonic: it was a suggestion on how to grok depndent types/GADTs
16:15:54 <applicative> jiag: you mean in do notion, x <- readFile "blah.txt"?
16:15:55 <josephle> bitonic: i've been burned by agda's typechecker enough times to know what you're talking about
16:15:57 <bitonic> josephle: oops, I thought we were still talking about optimization
16:16:14 <bitonic> josephle: what I’m talking about doesn’t really have to do with type checking
16:16:18 <josephle> bitonic: agda's typechecker should not send me to page swap hell
16:16:32 <levi> augur: Hah, just reading the prerequisite material for the type theory lectures there could take months. :)
16:16:33 <bitonic> josephle: well OK, but that’s due to different problems
16:16:37 <josephle> I suspect that has everything to do with optimization
16:16:45 <augur> levi: the videos suffice :)
16:16:52 <bitonic> josephle: not the same problems that you have when you compile
16:16:53 <jiag> applicative: yeah.  I'm trying to write my first program.  Trying to load a text file and I've used let x = readFile "blah.txt"
16:16:58 <josephle> bitonic: true.
16:17:01 <bitonic> it’s a whole different set of problems
16:17:22 <bitonic> so many problems.  implementing those things nicely is damn hard
16:17:22 <Peaker> jiag,    readFile "blah.txt"    is an IO action that will read the file.. a description of the action to perform.  It is not the content of the file
16:17:24 <tabemann> augur: okay, that's a lot to watch from just looking at their page
16:17:35 <augur> tabemann: its worth it
16:17:46 <tabemann> and I'm going to have far less time to watch it after tomorrow, as I actually got a job now
16:17:47 <levi> augur: Well, I'm taking note of the link, thanks for posting it.
16:17:47 <applicative> jiag: right, they're very different, let x = blah, and x <- blah
16:17:51 <Peaker> jiag, are you learning about how to do IO in a Haskell program with "main" ?
16:18:07 <applicative> jiag: imperative languages use = and =: and whatever for both of them
16:18:11 <josephle> speaking of the summer school
16:18:20 <josephle> those of you who want to learn dependent types
16:18:36 <thoughtpolice> tabemann: so, the way i think about GADTs is that they basically 'witness a type equality'. consider 'data Eq a b where Refl :: Eq a a' <- this GADT can be written another way though, like 'data Refl a b = (a ~ b) => Refl'
16:18:38 <josephle> Dan Licata is doing a lecture on that
16:19:06 <bitonic> I’d guess Dan Licata would be speaking about HoTT and stuf
16:19:06 <bitonic> f
16:19:10 <thoughtpolice> so, the ~ is basically an operator for type equality. it says two types are equal. when you use the 'Refl' value, it will 'automatically' bring that constraint of a ~ b around
16:19:11 <applicative> jiag: in the io case, x <- getChar is a bit like: assign the name x to the value obtained by now doing getChar
16:19:21 <bitonic> josephle: is this lecture public?
16:19:23 <thoughtpolice> tabemann: so in this sense, the 'Refl' constructor "witnesses" the fact that 'a' and 'b' are equivalent.
16:19:35 <applicative> jiag: let = getChar is renaming the action of getting a character because it's too long to spell, so to say
16:19:37 <josephle> bitonic: the previous year's lectures are. I don't know if induction applies
16:19:38 <jiag> applicative, Peaker : I started off with learnmeahaskell, and then jumped ahead after the getting startedI wanted to write a fun program to count letters in words
16:20:05 <applicative> jiag: good, the tutorials are never good at getting io across quickly
16:20:28 <applicative> jiag: if you paste it people can probably make more intelligent remarks than can be made in the abstract
16:20:33 <thoughtpolice> tabemann: this is basically the real power of a GADT, to witness some kind of equality between two types. the terms merely carry around different constraints on the left side of the '=>' sign
16:20:47 <Peaker> jiag, do you want a deeper understanding of what goes on in <- vs =, or just enough to get going and write working code?
16:21:05 <applicative> jiag: the default paste site is hpaste.org
16:21:16 <thoughtpolice> tabemann: so i could also write, "data Foo a = (a ~ Int) => FooInt | (a ~ Char) => FooChar" and if i use 'FooChar' then I get that the type variable 'a' must be equal to 'Char'
16:21:26 <thoughtpolice> but FooInt will bring along the 'a ~ Int' constraint.
16:21:43 <jiag> Peaker: I wouldn't mind a deeper understanding
16:22:12 <applicative> a deeper understanding of <- and let in IO do blocks comes from getting code working...
16:22:16 <Peaker> jiag, cool, so the crux of the matter is that Haskell makes a distinction that most languages don't
16:22:23 <ski> tabemann : ".. are implicit foralls" -- it's probably better to think "are effecively existentials" (recall that `forall a. F a -> T' is logically equivalent to `(exists a. F a) -> T')
16:22:27 <ski> tabemann : itum s/M-H/H-M/ :)
16:22:31 <tabemann> thoughtpolice: I figured that the different data constructors acted to control the type variables to the right of the type constructor, which simply serves to hold type variables that are quantified in the different data constructors
16:22:36 <Peaker> jiag, most languages have a single "function" thing that does both input->output processing and sequencing of effects (e.g: statement lists)
16:22:45 <rondon> Are you doing something wrong if the abstract is more than half a page?
16:22:54 <jiag> applicative, Peaker: this is my start http://hpaste.org/89326
16:23:02 <Peaker> jiag, Haskell distinguishes both purposes and has function types that are very much like mathematical functions and *only* map an input value to an output value
16:23:13 <Peaker> jiag, and it has "actions" that sequence effects, like "procedures"
16:23:40 <Peaker> jiag, if you want to both process input into output, and also have effects along the way, you can use a function that returns a procedure, which is very common in Haskell
16:23:57 <Peaker> jiag, so, for example:   the type of readFile:   readFile :: FilePath -> IO String
16:24:15 <ski> @type putStrLn
16:24:25 <ski>   putStrLn :: String -> IO ()
16:24:32 <Peaker> jiag, It's a (pure) function from a FilePath value to an "IO String" value..   an "IO String" value is a procedure/action that does some effects and then eventually yields a String
16:24:39 <Peaker> jiag, so far so good?
16:24:48 <ski> preflex: xseen goodfellow
16:24:48 <preflex>  goodfellow was last seen on freenode/#haskell 44 minutes and 30 seconds ago, saying: Monad m => [m a] -> m [a]
16:25:19 <Peaker> jiag, functions look like:  a -> b     and procedures/actions look like:  IO result
16:25:49 <jiag> Peaker: I think so
16:25:59 <thoughtpolice> tabemann: but hopefully that helps! in my experience, boiling GADTs down to "constructors carry type equality constraints" is one of the simplest ways to explain it IMO
16:26:35 <applicative> poor goodfellow
16:26:36 <thoughtpolice> (although it's a little odd if you've never seen ~ before. you mostly see this operator with TypeFamilies)
16:26:41 <Peaker> jiag, now, Haskell doesn't let you take the value of type "a" from an action "IO a" because that would require executing the effects as part of the computation - which would mean that the functions aren't actually just mapping input to output, violating the distinction we wanted to make in the first place
16:27:08 <bitonic> thoughtpolice: well then you need how to derive bottom from constraints and thus GADTs pattern matching.  I think to give intuition explaining indices directly is much better
16:27:13 <tabemann> thoughtplice: I've never seen ~ before myself
16:27:14 <shachaf> There isn't even a value of type "a" inside a value of type "IO a".
16:27:18 <shachaf> @quote /bin/ls
16:27:28 <shachaf> Bahmbdabot.
16:27:35 <applicative> jiag: i added an 'annotation' to http://hpaste.org/89326 to write it as we would
16:27:50 <shachaf> getLine :: IO String contains a String in the same way /bin/ls contains a list of files.
16:27:59 <rondon> a
16:28:07 <applicative> @remember < shachaf> getLine :: IO String contains a String in the same way /bin/ls  contains a list of files.
16:28:19 <shachaf> applicative: It's already in the database.
16:28:23 <shachaf> lambdabot is just not here.
16:28:32 <applicative> <lambdabot> I will never forget.
16:28:33 <Peaker> jiag, instead, if you want to access the result values of an IO action, you use an operator called (>>=) (pronounced "bind") -- which doesn't execute the IO action, but rather, sequences it to a "callback" that can see the result value -- and builds a bigger IO action which does both things
16:28:44 <jiag> applicative: thanks,  for the annotation
16:29:03 --- mode: ChanServ set +o elliott
16:29:22 --- mode: elliott set +b *!rondon@*
16:29:25 --- kick: rondon was kicked by elliott (rondon)
16:29:26 --- mode: elliott set -o elliott
16:29:42 <Peaker> jiag, and then, "do" blocks and <- are just syntactic sugar to do the (>>=) applications for you  (I jumped to the end since it seems like you might not be interested)
16:30:07 <thoughtpolice> bitonic: sure, it's definitely a bit hand-wavy (i knowingly overlooked pattern matching,) just an easy 1-minute bit to get a good chunk of the idea, i think (the indicies explanation may be just as good, perhaps i just don't have a good 2 minute approach :P)
16:30:41 <jiag> Peaker: so readFile returns an IO String which needs to be bound to a callback, which <- does, and '=' does not?
16:30:49 <Peaker> jiag, exactly
16:30:56 <shachaf> jiag: "=" means substitution, more or less.
16:31:13 <shachaf> jiag: If I write "a = b", then any time you see an "a", you can replace it with a "b".
16:31:28 <Peaker> jiag,  contents <- readFile "foo" ; ....        is translated into:     readFile "foo" >>= \contents -> ....
16:31:29 <shachaf> Just like when solving equations etc.
16:31:38 <Peaker> jiag, the \contents -> ...   is an anonymous callback
16:31:46 <shachaf> If I write "foo x = x + x", that means that when you see "foo 5", you can replace it with "5 + 5"
16:32:21 <shachaf> <- means something rather different.
16:33:12 <applicative> jiag: the simpler point is that 'readFile "/usr/..."' isn't a String, it's an action, which can 'return' or 'yield' a String, depending on how things stand on your machin.
16:33:46 <bitonic> thoughtpolice: the thing is that the arguments for dependent pattern matching are particularly subtle
16:33:52 <Peaker> jiag, the rationale for all of this is less about what you can do or assume about IO values and much more about what you can do or assume about function types.   Since we know all IO effects are quarantined inside "IO foo" values, we know applying some function (a -> b) is not going to execute any IO effects, greatly enhancing our ability to reason about arbitrary functions
16:34:03 <applicative> so your original 'let contents = readFile "blah"' meant: consider the action of reading the file 'blah', let's call that action 'contents'
16:34:16 <applicative> there is no string in sight
16:34:20 <bitonic> thoughtpolice: they imply subtle things etc.  so I usually leave it at an handwavy argument about the indices
16:34:31 <tabemann> also, this "String" is really a list of Chars, which may only be read off the disk as the "String" is evaluated
16:34:41 <tabemann> thanks to lazy evaluation
16:34:57 <shachaf> tabemann: No, not (just) thanks to lazy evaluation. Thanks to unsafeInterleaveIO.
16:34:59 <monochrom> lazy evaluation is an orthogonal issue
16:35:20 <monochrom> please don't cause information overload
16:35:29 <jiag> shachaf, Peaker, applicative: one part that is still confusing me is how <- converts IO String into just plane String
16:35:37 <dmwit> jiag: It doesn't.
16:35:43 <monochrom> does not convert.
16:35:48 <Peaker> jiag, it doesn't -- the rest of the do block after the "<-" line is in a "hidden" callback wrapper
16:35:48 <applicative> jiag: it doesn't convert it, you are defining one big Action in main
16:35:56 <dmwit> jiag: It converts the remainder of the code from a "String -> IO a" into an "IO String -> IO a".
16:36:24 <applicative> jiag, you are defining an Action in terms of two Actions, readFile and putStr ... to put it crudely
16:36:26 <Peaker> jiag, so:   do { contents <- readFile "foo" ; .... }        your .... code sees a simple "contents" String because it lives in a callback that got that String as an argument
16:36:27 <monochrom> recall the callback story. no one converts. instead the callback is given a String because the runtime system can do that.
16:36:30 <applicative> you never touch an actual String
16:36:44 <josephle> wouldn't a good way to think about this, is that <- will give you a type under the context of the monad (or monad stack) you're in?
16:37:18 <Peaker> josephle, that's a valid view, but it's nicer to get the view derived from desugaring first
16:37:50 <sequence> so 'contents <- readFile "foo"' is the same as 'readFile "foo" >>= \contents ...', which creates an anonymous function with 'contents' as the parameter?
16:37:54 <Peaker> jiag, it might be a good idea, while you're still learning, to replace the "do" block with actual >>= calls and lambdas
16:38:09 <monochrom> yes sequence
16:38:10 <Peaker> sequence, yeah
16:38:17 <shachaf> «contents <- readFile "foo"» doesn't make any sense on its own. It has to be followed by the ...
16:38:36 <sequence> I'm reminded a bit of a for comprehension in scala
16:38:45 <sequence> for (contents <- readfile "foo") ...
16:38:52 <dmwit> It's a good thing to be reminded of.
16:39:00 <josephle> Peaker, fair enough. jiag did ask for an in-depth description of do-notation.
16:39:10 <dmwit> flatMap was directly inspired by (>>=).
16:39:16 * applicative is worried by the deep riddle, how to I extract the words in the book, from the action of reading the book?
16:39:17 <shachaf> sequence: Yep, same thing. (>>=) is flatMap.
16:39:25 <shachaf> Or, OK, directly inspired.
16:40:02 <dmwit> If you know the "is", I won't contradict it. I just didn't know that, and didn't want to claim something stronger than I knew.
16:40:16 <josephle> applicative: You're in the wrong monad. Clearly.
16:40:33 <applicative> its the same monad
16:40:47 <shachaf> dmwit: I don't know the "is" either.
16:40:59 <elliott> I'm pretty sure it's is
16:41:01 <shachaf> Or, let's say, I used "is" in a vague Englishy sense, not in an equality sense.
16:41:20 * applicative has done putChar 'a' quite a few times, even in the last few seconds
16:42:27 <josephle> applicative: depends on your definition of "reading" a book
16:42:42 <applicative> the isn't anything about the other uses of is, distinct from the socalled is of identity
16:43:02 <sm> hey all. Can I get ghc to stop after reporting the first compilation error ?
16:43:16 <applicative> haha, i alawys feel that way sm
16:43:24 <sequence> 'main = do contents -> readFile "foo" ...' === 'main = readFile "foo" >>= \contents ...' === 'def main () = readFile "foo" flatMap ( contents => ... )'
16:43:25 <sm> this wall of errors is making it hard to debug the first
16:43:33 <dmwit> debug the last, then
16:43:38 <sequence> (where the last bit is scala)
16:44:01 <sm> hmm, is that always productive ? I guess so eh
16:44:16 <Fuuzetsu> How can I achieve something like ‘data Foo = Foo { fooId ∷ Foo }’ where ‘fooId x ≡ x’?
16:44:17 <josephle> sequence: triple '='? We're programming in typesafe javascript now!
16:44:26 <applicative> --ddump-minimal-type-errors
16:44:26 <jiag> so its only when I refer to 'contents' where "something" happens, and in this case something is reading the io ?
16:44:31 <sm> in other languages I would fear that later errors are meaningless, but that's probably not an issue with haskell
16:44:34 <dmwit> I don't think there's anything special about the order GHC reports its errors in.
16:44:47 <sequence> josephle: its my equivalence operator :P
16:45:12 <dmwit> jiag: Yes, but that's... let's call it a historical accident.
16:46:30 <sm> applicative: my ghc 7.6.3 doesn't recognise that flag
16:46:39 <dmwit> It was a joke.
16:46:43 <applicative> sm, oh sorry
16:46:45 <sm> gamn
16:46:57 <dmwit> You can tell because all ddump flags start with only a single -.
16:47:06 <dmwit> ;-)
16:47:06 <applicative> hah indeed
16:47:14 <sm> tried that too. damn. :)
16:48:11 <applicative> how about a variant of deferring type errors, that lets you see the first one ...
16:48:21 <jiag> dmwit, applicative, josephle, Peaker :  thanks all for your wonderful explanations :)
16:48:25 <sm> now I'm confused. It's reporting only the first error. I don't know why
16:48:50 <applicative> maybe there's only one error!
16:49:27 <applicative> its after you repair it that all hell will break loose
16:49:50 <josephle> syntax errors are notorious for hiding the 100x more type errors you have
16:50:15 <josephle> such is the way of compiler phases
16:50:32 <applicative> that 'toLower' is not in scope is usually the least of my problems...
16:50:33 <elliott> Fuuzetsu: fix Foo?
16:50:55 <hpc> the only sure way to get something to compile is to keep fixing errors until the compiler runs out of ways to complain
16:51:04 <hpc> make ghc happy out of /spite/
16:51:12 <mgsloan> -fdefer-parse-errors would be nice :)
16:51:17 <hpc> haha
16:51:35 <applicative> geekosaur once mentioned a compiler that did spell correct so to speak
16:51:37 <mgsloan> -fdefer-scope-errors seems doable
16:52:14 <josephle> mgsloan: careful, that flag might make inference undecidable :P
16:53:37 <mgsloan> josephle: I dunno, isn't it pretty "safe" to replace things with undefined?
16:54:00 <hpc> i just want -fdefer-logic-errors
16:54:02 <mgsloan> I guess you might need to turn on NoMonomorphismRestriction, and it might make some of your types more general
16:54:29 <mgsloan> Hmm, yeah, that could cause issues
16:54:31 <cmears> logic errors are already deferred to runtime by default
16:54:36 <Fuuzetsu> elliott: I think that's right, thanks!
16:54:44 <mgsloan> -fdefer-race-conditions
16:54:45 <Fuuzetsu> Not that I have any practical use for it :P
16:54:48 <josephle> mgsloan: RankNTypes would also be bad
16:55:02 <monochrom> hugs defers all errors to run time :)
16:55:21 <cmears> you really need -fwarn-logic-errors
16:55:22 <monochrom> (unless you use its REPL :) )
16:55:36 <mgsloan> monochrom: But it's still eager about its errors, right?
16:55:54 <monochrom> the statement "your program is wrong" has 99.9% probability of being true
16:55:55 <Fuuzetsu> I still wonder how do people manage to come in here and try to get help with Hugs. How do they even come into obtaining Hugs and not vastly more popular GHC?
16:56:04 <monochrom> yes mgsloan
16:56:08 <elliott> Fuuzetsu: university
16:56:30 <Fuuzetsu> Hmm, my lecturer does host Hugs on his account I guess…
16:56:42 <monochrom> they ask about hugs because I talk about hugs here all the time :)
16:56:51 <elliott> I have heard many times that Hugs is required for their course
16:57:06 <alpounet> Fuuzetsu, some teachers still make their students use Hugs, the main argument I've seen being clearer error messages I think
16:57:07 <monochrom> "hugs defers type errors", "hugs solves half of the cabal problems", "use hugs" :)
16:57:08 <elliott> and it would almost be depressing, if it didn't imply that the course was about Haskell!
16:57:12 <mgsloan> Hmm, why aren't they using helium?
16:57:15 <geekosaur> academentia is infamous for being well behind the times
16:57:35 <Fuuzetsu> I don't think GHC's error messages are very cryptic if you have about 3 minutes to spend Googling around.
16:57:40 <monochrom> hugs works. hugs is just fine.
16:57:48 <hpc> monochrom: oh dear god
16:58:01 <mgsloan> (Note: I haven't tried helium, but from the paper, the error messages looked pretty awesome)
16:58:16 <dmwit> Hugs defers type errors?
16:58:18 <josephle> Fuuzetsu: SML/NJ's error messages are cryptic. GHC is pretty straightforward compared SML/NJ.
16:58:19 <monochrom> I'm sorry, I'm not your dear god.
16:58:42 <hpc> deer lord! http://fc09.deviantart.net/fs70/i/2010/293/3/3/oh_deer_lord_by_virrewe-d3153r3.jpg
16:58:43 <goodfellow> http://tinyurl.com/3kspl24
16:58:51 <elliott> Fuuzetsu: hard to google for "~"
16:58:56 <tabemann> the problem with helium is that it gets rid of type classes, which are a pretty important point in haskell
16:58:58 <hpc> goodfellow: hivemind
16:59:01 <elliott> http://example.com/
16:59:01 <goodfellow> Title: Example Domain
16:59:08 <elliott> http://example.com/.jpg
16:59:08 <goodfellow> Title: Example Domain
16:59:11 <elliott> hm.
16:59:12 <hpc> or is that a bot...
16:59:14 <elliott> yes
16:59:19 <elliott> I'm trying to figure out why it spat out a tinyurl
16:59:25 <geekosaur> goodfellow is standing in for lambdabot
16:59:40 <dmwit> elliott: At a guess: it spits out a tinyurl if there's already a tinyurl for the URL.
16:59:49 <mgsloan> tabeman: Ahh, good point.  Someone ought to make something like helium with type classes
16:59:49 <Fuuzetsu> is lambdabot ill again? ;_;
16:59:53 <hpc> > "an odd way to stand in for lambdabot, to be sure"
16:59:55 <goodfellow>   "an odd way to stand in for lambdabot, to be sure"
17:00:00 <elliott> dmwit: ok, I can do science with this.
17:00:08 <geekosaur> I think LB got netsplit and didn't recover?
17:00:18 <elliott> http://goodfellow.invalid/
17:00:18 <geekosaur> (freenode was having Issues earlier)
17:00:31 <elliott> http://goodfellowinvalid.com/
17:00:38 <elliott> maybe the URL has to actually go somewhere too.
17:00:43 <geekosaur> yes
17:00:52 <Fuuzetsu> elliott: I think a better guess is that it only spits out the tinyurls it has seen and followed before
17:00:59 <elliott> http://example.com/?hello-goodfellow
17:01:00 <goodfellow> Title: Example Domain
17:01:01 <geekosaur> it doesn't report if the URL fetch errors or it can't find anything to do with it
17:01:20 <elliott> dmwit: my guess was that it does it for images, since they have no title.
17:01:33 <dmwit> It shortened a non-image earlier today.
17:01:39 <dmwit> You could always source-dive.
17:01:45 <Fuuzetsu> Too easy.
17:01:45 <dmwit> ?hackage lambdabot
17:01:46 <goodfellow> http://hackage.haskell.org/package/lambdabot
17:01:55 <elliott> I like mystery.
17:02:54 <dmwit> Answer: the URL must be readable, not ignored, and longer than 60 characters.
17:02:57 <elliott> well. I like solving mysteries.
17:03:55 <dmwit> paste, cpp.sourcforge.net [sic], HaskellIrcPastePage, title of that page, and Title: are ignored.
17:04:26 <elliott> wat
17:04:37 <dmwit> IAMA source diver, AMA
17:06:11 <hpc> dmwit: dynamic-scoped macros: great idea or the greatest idea? ;)
17:07:24 <dmwit> unstatic-scoped macros are double-plus good
17:07:38 <mgsloan> screw type-directed name resolution, we need some type-directed fixity resolution
17:08:31 <dmwit> One of my colleagues proposed a language whose semantics was, whenever there's an ambiguous parse, I'm ALL of them.
17:08:53 <tabemann> brilliant idea that
17:08:55 <elliott> in parallel?
17:09:01 <mgsloan> hahah, and all return types are implicitly wrapped in a set?
17:09:04 <elliott> but with side effects divided by the number of parses.
17:09:52 <dmwit> I believe the proposal was that it was an error if the ambiguity was not resolved by the time we reached the top level of the parse tree.
17:10:16 <mgsloan> My toy tarpit language idea is that scope errors are comments, and the first way of applying identifiers to eachother that typechecks is what's used
17:10:17 <dmwit> (resolved by type-checking)
17:10:35 <mgsloan> ahh, interesting
17:11:16 <hpc> perl does something like that
17:11:48 <hpc> a slash can be part of a division or a regex, depending on the prototype of the preceeding operator
17:12:00 <Fuuzetsu> perl is not parsable
17:12:06 <hpc> and that can be set programatically in a BEGIN
17:12:17 <mgsloan> all I need to do is write to haskell-cafe that it's impossible to do this as a haskell e-DSL, and oleg's sure to correct me
17:13:24 <Fuuzetsu> mgsloan: solving Haskell problems: 1. Define problem 2. Say it's impossible on haskell-cafe 3. Wait for oleg to write a solution
17:13:34 <mgsloan> (it actually seems rather obvious that this is impossible, at least in general)
17:13:45 <mgsloan> Fuuzetsu: I've definitely seen it happen at least once or twice
17:13:52 <threedaymonk> mgsloan: that's the classic Linux problem solving technique
17:14:21 <hpc> Fuuzetsu: if you need the problem solved immediately, 1. Define problem 2. Say it's impossible on stack overflow 3. Wait for dons to write a solution
17:14:28 <Fuuzetsu> a huge part of his site is just his replies to people thinking something is not possible
17:14:30 <threedaymonk> "Linux sucks because it can't print to A4" > "How do I set up A4 as my default paper size"
17:14:36 <monochrom> what if we combine the two. "how do I install Linux at the type level?"
17:14:49 <joelteon> someone can write thta
17:17:55 <shachaf> GHC trac is down?
17:17:59 <dolio> I compile my types to javascript and run linux in the browser.
17:18:31 <dmwit> but why
17:19:00 <threedaymonk> That reminds me of the thing I was struggling with last night: I want to map over the chars in a ByteString, but the ByteString map is (Char -> Char) -> ByteString -> ByteString. I need something like (Char -> a) -> ByteString -> [a]. What would that be?
17:19:19 <shachaf> threedaymonk: There are no Chars in a ByteString, only bytes.
17:19:22 <dolio> dmwit: Because everything should compile to javascript and run in a browser. It's the best assembly language ever invented.
17:19:44 <shachaf> The ByteString map is (Word8 -> Word8) -> ByteString -> ByteString. Data.ByteString.Char8 is terrible and please don't use it.
17:20:07 <shachaf> With that said, probably the right thing to do is to unpack/decode the ByteString to a list, and then map over the list.
17:20:26 <threedaymonk> shachaf: gladly :-) is it still possible to use OverloadedStrings with Word8?
17:20:59 <shachaf> It doesn't really make any sense to. What does the string "aβ" turn into?
17:21:14 <tabemann> is there a fold over a ByteString that is of the form (a -> Word8 -> a) -> a -> ByteString -> a?
17:21:22 <threedaymonk> shachaf: hopefully UTF08
17:21:25 <tabemann> one could construct a map like you want with that
17:21:25 <threedaymonk> *UTF-8
17:21:27 <dmwit> There is a Traversal ByteString Word8.
17:21:32 <shachaf> tabemann: Yes, foldr and foldl.
17:21:43 <shachaf> dmwit: There's even a clever tree-y Traversal!
17:21:57 <dmwit> Then why are you not suggesting this.
17:21:57 <shachaf> threedaymonk: OK. There's no UTF-8 instance for it.
17:22:18 <threedaymonk> shachaf: though really, all my strings at the code level are ASCII, and I'm doing bytewise operations
17:22:48 <tabemann> code that will take ASCII should take UTF-8 fine for many applications
17:22:55 <Fuuzetsu> threedaymonk: I just got lectured by shachaf about pretty much the same thing yesterday.
17:22:56 <tabemann> 8-bit ASCII I mean
17:22:58 <dmwit> Why are we getting so sidetracked.
17:22:59 <threedaymonk> so what I really want is to be able to type in "foo" and have it as three bytes, munge it, and then spit out ASCII at the other end
17:23:08 <dmwit> My head is exploding.
17:23:13 <threedaymonk> tabemann: no such thing as 8-bit ASCII!
17:23:23 <dmwit> Just unpack and map.
17:23:34 <shachaf> dmwit: :-(
17:23:34 <dmwit> Also, don't use ByteString for text.
17:23:36 <dmwit> Next.
17:23:41 <tabemann> threedaymonk: I mean the characters are in the range 0x00-0x7F, but the top bit isn't getting stripped
17:23:54 <threedaymonk> the munging I'm doing includes XOR, btw
17:24:17 <shachaf> There is no "top bit" for Unicode codepoints.
17:24:43 <tabemann> hmm... applying arbitrary XORing to UTF-8 is likely to corrupt it really badly...
17:24:54 <dmwit> Now my head is exploding for two reasons.
17:25:00 <shachaf> The trouble with writing code that pretends Char = Word8 is that it'll work fine for you, but then someone will try to use it with some non-English language and it'll break.
17:25:09 <copumpkin> the top 0.087461546321563 bit?
17:25:12 <copumpkin> >_>
17:25:15 <tabemann> shachaf: considering that ASCII is typically stored in octets, there is
17:25:29 <shachaf> tabemann: What?
17:25:34 * copumpkin hands dmwit a pill
17:25:36 <threedaymonk> hence why I thought ByteString might be the right thing
17:25:53 <dmwit> ByteString is right for strings of bytes.
17:25:56 <dmwit> Text is not strings of bytes.
17:26:38 <dmwit> We cannot judge whether you are really munging text or strings of bytes.
17:26:50 <dmwit> But if you are really munging text, don't pretend ASCII is a solution.
17:26:52 <tabemann> shachaf: I don't see what's controversial about that ASCII text is typically stored in octets, which have eight bits (obviously); hence the "top bit" of that is the bit 0x80
17:27:07 <geekosaur> tabemann, there has not been ASCII text since the 1960s
17:27:15 <shachaf> tabemann: I said "Unicode codepoints", not "ASCII text".
17:27:26 <shachaf> And you shouldn't be using ASCII.
17:27:28 <dmwit> tabemann: ASCII is stored in octets, but the top bit is not 0x80.
17:27:37 <dmwit> The top bit is 0x40.
17:28:03 <tabemann> dmwit: I meant the top bit of the octets they are stored in, not of the 7-bit character values themselves
17:28:06 <geekosaur> yes, we understand that in your little corner of reality nobody ever uses characters outside the range 0x20 - 0x7e, but your little corner of reality is not the reality Haskell must deal with
17:28:20 <threedaymonk> dmwit: definitely bytes. those bytes will ultimately be presented as ASCII-encoded text
17:28:32 <geekosaur> ...
17:29:16 <dmwit> That's a pretty crappy way to present most bytes. Just so you know.
17:29:28 <threedaymonk> for fuck's sake, I KNOW THAT
17:29:33 * dmwit nods
17:29:39 <tabemann> geekosaur: how isn't text that uses the standard ASCII characters of 0x00-0x7F not ASCII text, even if it is being used in a context where, say, latin-1 could be used?
17:29:52 <geekosaur> ...
17:29:58 <threedaymonk> by definition, if the result is not ASCII, I've failed :-)
17:30:28 <threedaymonk> for example, if I were to turn a SHA256 into a hex representation, that would all be ASCII
17:30:46 <dmwit> no no no
17:30:50 <dmwit> You would not turn that into bytes.
17:30:54 <dmwit> You would turn that into text.
17:31:08 <dmwit> See, I feel like you say you got the point, but you didn't yet.
17:31:11 <threedaymonk> yes, which, at the interface to the outside world, would be ASCII
17:31:15 <dmwit> no
17:31:17 <geekosaur> The American Standard Code for Information Interchange is from the 1960s and died with the 1970s. It is a non-thing, except for people who consider anyone outside the US to be dubiously human.
17:31:48 <geekosaur> merely *mentioning* ASCII is proof of wrongness.
17:31:51 <dolio> I use non-ASCII characters all the time, and I'm a Murrican.
17:31:51 <copumpkin> lol
17:31:53 <threedaymonk> ASCII is a strict subset of UTF-8
17:32:07 * copumpkin hears the pedants rumble
17:32:14 <dmwit> You should not be turning your SHA256 into a hex representation in UTF-8, either.
17:32:22 <Fuuzetsu> I bet geekosaur is steaming
17:32:26 <threedaymonk> アメリカ人じゃないよ
17:32:27 <tabemann> any text that was valid ASCII is valid UTF-8
17:32:33 <dmwit> You should be turning it into *text*.
17:33:44 <dolio> Sometimes you really need a mathematical sans-serif bold italic lamda.
17:33:46 <copumpkin> threedaymonk: I think dmwit's point is that you're confusing the "presentation layer" with your conceptual needs
17:33:46 <tabemann> except the outside world operates in terms of octets, and at some point one ought to be controlling the encoding that reaches the outside world (i.e. encoding it into octets); one shouldn't leave it up to code designed to work based off some locale to do it for you
17:34:09 <copumpkin> threedaymonk: ASCII/UTF-8/whatever are encodings of the underlying unit of meaning
17:34:09 <tabemann> who's to say that your Chars aren't being turned into UTF-16LE upon reaching the outside world?
17:34:10 <copumpkin> which is text
17:34:24 <copumpkin> threedaymonk: you should talk about those when you encode it, but your internal tranformations should use the correct type
17:34:59 <threedaymonk> I think this has probably actually been wuite useful for me
17:35:19 <tabemann> random question
17:35:20 <copumpkin> just because the outside world might store a filesystem as a flat string of bytes doesn't mean you wouldn't use a conceptually more meaningful datastructure when operating on it
17:35:29 <tabemann> what *is* the range of a Char?
17:35:39 <copumpkin> up to 0x10ffff
17:35:42 <dmwit> > [minBound, maxBound] :: String
17:35:43 <goodfellow>   "\NUL\1114111"
17:35:50 <copumpkin> > ord maxBound
17:35:51 <goodfellow>   1114111
17:35:52 <threedaymonk> that's the max in Unicode as currently defined
17:36:05 <threedaymonk> (iirc)
17:36:11 <dmwit> urc
17:36:22 <elliott> copumpkin: don't you know anything about unix? data structures richer than bytestrings are The Right Thing, and therefore the wrong thing.
17:36:35 <threedaymonk> though xenolinguists of the 31st century may need more bits
17:37:07 <Fuuzetsu> I don't think we'll still be dealing with just bits in 31st century.
17:37:08 <copumpkin> 21 bits should be enough for everyone
17:37:10 <sequence> how do you do a pretty print output? I don't want to always have to use putStr all over the place
17:37:15 <dolio> elliott: I think ad-hoc rose trees annotated with symbols is the way to go.
17:37:32 <sequence> something where I can put arbitrary types in, and get a recursive print
17:37:35 <sequence> even of the types, would be nice
17:37:40 <shachaf> copumpkin: I'm OK with up to 1/3rd of a bit more per character.
17:37:45 <shachaf> As long as it still fits UCS-2.625
17:37:55 <Fuuzetsu> sequence: Debug.Trace.trace is what you might be looking for
17:38:01 <dolio> shachaf: Aren't you all about the UTF-64?
17:38:06 <tabemann> dmwit, copumpkin: I was wondering because I was hoping Haskell didn't do some stupid shit where there defined a char as 16-bits al a Java and then were forced to use UTF-16 to represent higher characters
17:38:10 <elliott> dolio: I think we should build up all our data with terrifying winding call graphs. explicit representations as for losers.
17:38:14 <elliott> *are
17:38:29 <dmwit> Yes, Haskell got this right.
17:38:35 <cmears> is there any "stripSuffix" function as an analog to "stripPrefix" ?
17:38:49 <dmwit> Char is a Unicode codepoint -- here using the technical meaning of "codepoint".
17:38:54 <Nisstyre> elliott: you could say the same of a lot of functional programs except s/bytestrings/lists/
17:38:59 * tabemann remembers working with an XML library that worked in terms of UCS-2... that sucked
17:39:07 <shachaf> dmwit: Not *too* technical! Some Chars are invalid codepoints.
17:39:13 <sequence> Fuuzetsu: I'm not necessarily after something like printf debugging, more after some function that does a recursive print
17:39:28 <tabemann> this was C++ though, and I was really wishing the XML library developers had just gone and used UTF-8...
17:39:29 <Fuuzetsu> cmears: stripSuffix p xs = stripPrefix (reverse p) (reverse xs)
17:39:30 <elliott> Nisstyre: yes, those are wrong too. lisp is almost as wrong as C. but lists go a lot further than bytestrings
17:39:30 <Fuuzetsu> I think.
17:39:31 <threedaymonk> Now, despite what you've all said, if I write a program that outputs a Base64-encoded string, it outputs *text*, correct?
17:39:53 <cmears> Fuuzetsu, yeah, that's how I usually end up doing it (you need an extra reverse at the top too)
17:39:56 <elliott> Fuuzetsu: you might want another reverse there
17:39:59 <Nisstyre> elliott: even a lot of Haskell programmers rely on lists too much
17:40:02 <Fuuzetsu> ah, yes, missed it
17:40:03 <threedaymonk> However, what that text is depends on the encoding of the data that went into the Base64 encoder
17:40:12 <elliott> threedaymonk: what do you count as outputting text, vs. outputting a bytestring?
17:40:17 <elliott> as in, how do you distinguish?
17:40:17 <dmwit> threedaymonk: No, base64-encoded text is bytes.
17:40:38 <Nisstyre> though you could argue that's no fault of Haskell
17:40:47 <elliott> dmwit: well, I'm sure UTF-16 base64 is used enough in practice... :/
17:40:54 <tabemann> but what if your base64-encoded text is interleaved with plain text?
17:41:01 <threedaymonk> right, but what's the Base64 encoding of, say, é?
17:41:06 <yrlnry> I'm trying to define an infinite family of types for mod-n arithmetic.  What I've done so far is https://gist.github.com/mjdominus/5710839
17:41:14 <Fuuzetsu> sequence: There are some pretty printing libs but I don't think anything that will automagically do it for arbitrary types
17:41:25 <dmwit> "encoding" is, in most cases, the process of converting some rich format into bytes.
17:41:34 <dmwit> So the name "base64 encoding" should be a clue.
17:41:49 <tabemann> but base64 is the opposite direction - it is turning octets into text
17:41:57 <yrlnry> I want the 'modulus' function to return 0 when applied to a datum of type Zero , 1 on a datum of type Succ Zero, 2 o a datum of type Succ (Succ Zero), and so on.
17:42:09 <tabemann> (and likewise decoding base64 is turning text into octets)
17:42:10 <elliott> yrlnry: this is totally different to your approach, but I have to plug the reflection package for doing this in practice.
17:42:12 <dmwit> tabemann: It is turning octets into other octets.
17:42:17 <yrlnry> But I don't understand how to define the "modulus" instance for  (Modulus a) => Modulus (Succ a)
17:42:19 <threedaymonk> So there is a need to represent text as an explicitly encoded byte form internally, before the Base64 encoding process
17:42:30 <m3ga> dumb ass question here, whats the difference between Control.Exception.Base.catch and Control.Monad.Error.catchError? it seems I can catch some exceptions with one but not the other.
17:42:47 <elliott> yrlnry: if you write lower :: Succ a -> a; lower _ = undefined, then you can say modulus (lower a)
17:42:48 <dmwit> threedaymonk: I believe so, yes.
17:42:56 <tabemann> base64 is meant to be used with other text, including in contexts where only printing ASCII characters are treated as valid
17:42:57 <elliott> yrlnry: or, maybe with turning on ScopedTypeVariables, modulus (undefined :: a)
17:43:16 <tabemann> it is meant to turn octets into that
17:43:34 <yrlnry> Thanks, that is a nice idea.  But I still don't know how to define the modulus instance for Succ a.
17:43:46 <elliott> yrlnry: btw, I suggest using the tagged package's Data.Proxy.Proxy (data Proxy s = Proxy), and having "modulus :: proxy a -> Int" instead (lowercase on purpose -- it can be very useful to choose another type to stand in for Proxy). helps avoid distasteful undefineds and can be nicer to use in practice
17:43:54 <elliott> yrlnry: oh, that was for the instance
17:43:57 <dmwit> yrlnry: How about "foo :: Succ a -> a; foo = undefined"
17:44:08 <elliott> instance Modulus a => Modulus (Succ a) where modulus a = 1 + modulus (lower a) -- using my lower
17:44:15 <yrlnry> Oh, I see.
17:44:16 <elliott> instance Modulus a => Modulus (Succ a) where modulus a = 1 + modulus (undefined :: a) -- maybe requires ScopedTypeVariables
17:44:17 <yrlnry> Thanks!
17:44:20 <dmwit> yrlnry: But yes, using Proxy and friends is even better.
17:44:33 <Fuuzetsu> Who in here runs fpcomplete.com haddocks?
17:44:51 <dolio> m3ga: Control.Monad.Error is arguably more like a checked exception, where the monadic type of a value indicates that it can throw exceptions.
17:45:36 <zRecursive> @ty (&&&)
17:45:36 <goodfellow> Arrow a => a b c -> a b c' -> a b (c, c')
17:45:37 <yrlnry> elliott:  just what I needed, thanks.
17:45:54 <m3ga> dolio: so functions that need to be caught with C.M.Error should have a typeclass constraint?
17:46:09 <dolio> Control.Exception deals with IO exceptions, some of which can originate in pure code, but be caught in IO, although I'm not sure if Base.catch does that.
17:46:29 <dolio> Yes.
17:46:54 <m3ga> dolio: thanks. i should write a small test program to play with this and udnerstand it fully.
17:47:13 <dolio> The simplest C.M.Error is, I think, Either e, where e is your exception type.
17:47:41 <elliott> yrlnry: :)
17:51:48 <yrlnry> I put  instance (Modulus m, Eq n) => Eq (ModN m n)  and it compiled okay, but I was expecting a warning about my failure to define either == or != for the instance.  What do I misunderstand?
17:52:21 <elliott> (==) and (/=) have mutually recursive default definitions
17:52:25 <elliott> a == b = not (a /= b)
17:52:26 <yrlnry> Oh, right.
17:52:27 <yrlnry> Thanks.
17:52:28 <elliott> a /= b = not (a == b)
17:52:55 <yrlnry> That's not the first time I've made that mistake.
17:52:56 <elliott> the first one is a little stupid to have, really. if shachaf's GHC ticket gets resolved you'll get a warning for not defining a minimal complete definition because the requirements will be specified
17:54:20 <dmwit> yrlnry: I think we've all spent at least one hour tracking an infinite loop down to either this one or the Traversable one.
17:54:46 <elliott> I haven't. perhaps I am just too good
17:55:04 <dmwit> =(
17:55:32 <mgsloan> yeah, fmapDefault + Traversable default doesn't work out too well :)
17:56:05 <elliott> alternatively, perhaps I spend too much time on IRC, and not enough writing Haskell.
17:56:24 <yrlnry> =)
17:56:47 <yrlnry> Haskell may be the only language where I ask "I expected error message X, but didn't get it; what am I doing wrong?"
17:57:38 <dolio> I spent an hour tracking down an infinite loop to serializeWith = serializeWith in edwardk's package the other day. :)
17:57:42 <dolio> But that won't give you an error.
17:58:10 <dolio> Or warning.
17:58:49 <elliott> dolio: it does. just not on edwardk's code. GHC doesn't dare to warn about that.
18:01:28 <zRecursive> Is lambdabot retire  ?
18:01:43 <tabemann> there was some issue with Freenode earlier apparently
18:01:59 <dmwit> > "I am a lambdabot"
18:02:00 <goodfellow>   "I am a lambdabot"
18:02:20 <zRecursive> then use goodfellow temporarily ?
18:02:24 <dmwit> right
18:13:48 <zebr> hey all. would you say "dynamic dependent typing" (so the type is checked, but at runtime) is bona fide dependent typing?
18:14:18 <saml> what?
18:14:55 <saml> define type checking
18:15:04 <saml> checking type at runtime doesn't make sense
18:15:16 <dmwit> saml: Contracts are a thing.
18:15:31 <dmwit> They are essentially dynamic dependent typing.
18:15:50 <dmwit> For bonus points, throw in blame labels so you know who's at fault.
18:16:05 <zebr> i'm just wondering whether it's legitimate to say that a typesystem has "dependent types" if it makes sure the type is correct and if it isn't it panics, during runtime but before anything else is actually computed... if that makes sense.
18:16:11 <dmwit> Anyway, a question like "bona fide dependent typing" is too subjective to answer in a meaningful way.
18:16:33 <zebr> well, i guess so :p
18:17:00 <zebr> i just don't want people telling me "but that's not dependent typing because it's not static!" and throwing fruit and things at me.
18:17:49 <elliott> it might be true to say that if you have to ask this question of your system, it is more likely than not that you have designed something that doesn't meet the criteria for dependent types
18:19:35 <mgsloan> Haha, that would be funny to annotate runtime errors with info from git blame
18:19:48 <zebr> lol
18:19:51 <dmwit> heh
18:20:06 <mgsloan> A truely worthy use of "blame" :D
18:20:06 <dmwit> ...not that kind of "who"
18:20:28 <zebr> elliott: that is entirely possible. i mean, is there a distinction between, say, bounds checking on 'xs[i]' and a variable 'i' with a dependent type '< xs.length'? i presume there is.
18:20:46 <saml> types give meaning to bitstrings
18:20:57 <dmwit> ew
18:21:01 <dmwit> I don't like that definition at all.
18:21:16 <dolio> zebr: Yes, there is a difference.
18:21:23 <zebr> well darn. :p
18:21:38 <saml> so xml is the ultimate type because xml can encode everything
18:21:39 <elliott> types don't give meaning to anything. types are the meaning.
18:21:48 <elliott> saml: please don't troll.
18:21:57 <dmwit> Why do types and meanings have to be tied together?
18:22:22 <saml> ok maybe meaning is too vague
18:22:34 <dmwit> What if my types talk about what steps are allowed next in a protocol or something?
18:22:44 <dolio> zebr: The point of contention isn't over 'dependent' though. It's over 'typing.'
18:22:56 <saml> types form a system . it has symbols and stuff
18:23:04 <zebr> dolio: oh? how so?
18:23:15 <copumpkin> I saw a language recently claiming to have dynamic dependent types
18:23:21 <copumpkin> zebr: which is the one you're thinking of?
18:23:24 <copumpkin> I was trying to find it
18:23:30 <dmwit> Or, like... Boomerang uses typing to make sure that lenses satisfy the roundtrip properties. All the values are strings, but with different types.
18:23:48 <zebr> copumpkin: oh, i'm scribbling together an idea for a new language and i was wondering if it made sense to make that claim. :p
18:23:53 <copumpkin> oh
18:24:11 <copumpkin> zebr: it doesn't!
18:24:16 <dolio> zebr: Because the question is whether typing is something you do statically, and then can throw a bunch of stuff away and not worry about bad things happening later.
18:24:53 * Hodapp looks at channel, sighs, looks back at Haskell textbook and puts on kettle for tea.
18:25:14 <zebr> dolio: i suppose so. but then no dynamic type systems, if they are type systems, do type erasure.
18:25:30 <elliott> I wouldn't say type erasure is a property of a type system
18:25:32 <saml> dynamic type means you can alter types at runtime, right?
18:25:34 <dolio> You bounds check an array at every access at runtime, presumably. But the ideal for the i : Finite (xs.length) would be that you prove when you compile that the bounds are never violated, and don't do any checks at runtime, because they aren't necessary.
18:25:52 <saml> x :: T    at t1  but at t2,  x :: G
18:26:09 * zRecursive drinking green tea while watching the channel :)
18:26:12 <saml> where x is value and T, G are types. and t1, t2 are different times
18:26:17 <dolio> zebr: Right. And I don't really like calling them type systems. :)
18:26:22 <copumpkin> o.O
18:26:24 <dolio> Not everyone agrees with that classification.
18:26:33 <Hodapp> my type system is just QWERTY I guess.
18:26:39 <zebr> guys, it's 2:36am and you're making a very good case for brewing some tea. stop tempting me.
18:26:56 * Hodapp waves the tea leaves annoyingly in zebr's face
18:26:57 <dmwit> Brewing tea is awesome. You should definitely do it.
18:27:02 <dmwit> You don't even need to drink it after.
18:27:46 <saml> maybe dynamic types make sense if you define types as meaning of bitstring.  bitstring stays. but you can interprete it differently, giving it different types
18:27:47 <zRecursive> donot drink tea before sleeping
18:28:12 <Hodapp> zRecursive: well, anything but black tea, yerba mate, or very strong green tea is probably okay
18:28:13 <PhineasRex> Brew the tea, put it in the fridge, wake up to ice tea.
18:28:36 <zebr> i am suddenly curious what iced lapsang souchong would be like.
18:28:47 <zRecursive> Hodapp: no coffeine ?
18:29:06 <Hodapp> zRecursive: hrm?
18:29:39 <zRecursive> Hodapp: coffeine will make you not to sleep well
18:29:55 <zebr> * caffeine, btw. :)
18:30:20 <Hodapp> zRecursive: oh, caffeine? yeah, I was just saying that if you stay away from things like black tea, yerba mate, or strong green teas before sleeping, most other teas are fine, caffeine-wise
18:30:27 <johnw> guys, #haskell is really for discussing Haskell, not caffeinated beverages
18:30:44 <Hodapp> we're discussing non-caffeinated beverages too :|
18:31:07 <elliott> johnw: oh. I've been in the wrong place for a long time.
18:31:21 <zebr> ok everyone, back to the uh, type systems and things. (i think people have pretty much answered my questions, though. :) )
18:31:30 <PhineasRex> Gotta take this discussion to #haskell-tea
18:31:36 <zebr> lol
18:31:37 <zRecursive> :)
18:47:54 <shachaf> dmwit: Using fmapDefault without defining sequenceA isn't caught by {-# MINIMAL #-}. :-(
18:50:00 <dmwit> huh
18:50:09 <dmwit> That's a funny cross-class case.
18:50:17 <dmwit> Worth thinking about.
18:51:20 <dolio> MINIMAL also won't catch your explicit 'x == y = not (x /= y)' instance of Eq.
18:51:40 <elliott> dolio: good instance.
18:53:16 <dmwit> shachaf: Especially considering the existince of DefaultSignatures, it seems like that's a niche you'd want to handle.
18:53:40 <dmwit> Perhaps MINIMAL ought to be able to talk about the current class and any superclasses.
18:53:45 <shachaf> dmwit: I don't see an obvious way to do it.
18:53:52 <shachaf> fmapDefault is just a regular function.
18:54:11 <shachaf> Oh, maybe with the superclass defaults thing you could allow that.
18:54:38 <dmwit> shachaf: Sure, I'm just picturing a world where fmapDefault is the default implementation of fmap.
18:54:54 <dmwit> Obviously this doesn't scale to non-default implementations.
18:55:06 <dmwit> ...and I don't really think you can hope to.
18:56:42 <dolio> I can believe that you could say that fmap or sequenceA constitute a minimal definition of those two classes.
18:57:08 <dmwit> Right.
18:57:51 <mgsloan> Hmm, I suppose you could have mutually recursive DefaultSignatures.  That's tricky..
18:59:10 <mgsloan> (which is tricky, because it doesn't even have to be a superclass relation)
18:59:22 <dolio> Where are we on having multiple sets of default definitions?
18:59:26 <mgsloan> Trickier still is that you might have multiple constraints in the default signatures
18:59:45 <elliott> dolio: I think that's considered undesirable for open world reasons
18:59:55 <mgsloan> So, I think making MINIMAL work for all default signatures cases is not gonna be very feasible
19:00:18 <dolio> Instead of one weird loop if you can accomplish it, and arbitrarily picking 2 of 6 possible minimal class methods otherwise.
19:00:55 <elliott> dolio: oh, I see
19:01:07 <elliott> dolio: you mean multiple default definitions depending on which methods you define
19:01:11 <elliott> that sounds nice
19:01:32 <dolio> elliott: Yeah. Like, any of Ord's methods is minimal (I think). But only compare and (<=) really work.
19:01:34 <mgsloan> My instance templates proposal would handle that
19:02:18 <elliott> dolio: technically you could say that most of them are minimal only if the Eq instance doesn't depend on teh Ord instance, tying in with the fmapDefault thing.
19:02:26 <dolio> Right.
19:02:34 <elliott> *the
19:02:42 <mgsloan> Unfortunately, as it stands it's pretty ugly, but if you're willing to read between the lines a bit, I think the idea is good
19:02:51 <dolio> I think we should just embed prolog and encode all this there.
19:03:00 <elliott> I vote dolio for prez.
19:03:02 <dolio> Seems like the simplest solution.
19:03:48 <mgsloan> (though would require tool support - building an abstraction atop the abstraction of typeclasses is one too many levels of indirection)
19:04:12 * elliott wishes we had fewer abstractions, not more
19:04:55 <mgsloan> elliott: Well, the idea of instance templates does make instances more value-like, but yeah, it's unfortunate that that isn't just a given
19:05:37 <elliott> the genius of the function type is that it is the way to abstract over itself. we lose that with typeclasses
19:06:58 * hackagebot hledger-lib 0.21.2 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.21.2 (SimonMichael)
19:06:58 <goodfellow> Title: HackageDB: hledger-lib-0.21.2
19:07:03 <mgsloan> elliott: Are you referring to functions taking / returning functions, or something else?
19:08:27 <elliott> mgsloan: right. to abstract over functions, you just use a (higher-order) function
19:08:51 <elliott> to abstract over typeclasses, you need ConstraintKinds, or depending, something like universally quantified constraints, etc.
19:09:00 <mgsloan> Yeah, I considered having instance templates that yielded instance templates, but it got nuts
19:09:18 <elliott> (you could argue that ConstraintKinds is how typeclasses should have been from the start. but you also kind of want to use them with GADTs, etc.)
19:09:41 <mgsloan> You'd need to generalize Generics to typeclass dictionaries, and I find generics kinda ugly in practice
19:09:45 <elliott> I like flat things where I know that if I ever need to generalise I just use the same thing one layer up
19:11:52 <mgsloan> elliott: I found this braindump of a possible unification of different Haskell syntax to be pretty neat: https://github.com/colah/Haskell-Re-Syntaxed/blob/master/brainstorm.hs
19:12:18 <EvanR> so i noticed when writing socket code in haskell that long running server code might crash if you dont catch certain (sometimes inevitable) exceptions, is there any documentation, guides, or divinations to help know which ones you may encounter or care about catching
19:12:26 <EvanR> catching 'all exceptions' sounds really dumb
19:12:35 <EvanR> (unless rethrowing them)
19:13:26 <elliott> mgsloan: this syntax looks like it has the right ideas behind it, but as it is I think it would only increase the complexity of the language: it unifies things that are not the same at all in Haskell, so it'd have to be picked apart after the fact to re-separate it into the different categories. and we'd have to do that mentally, too
19:13:54 <elliott> mgsloan: if you introduce dependent types, then you get a lot of these unifications at a much deeper level than syntactic overloading
19:13:57 <mgsloan> Particularly because by making instances look like values, it immediately suggests the missing abstractions of mappings from one set of instance dictionaries to another
19:14:35 <mgsloan> elliott: Right, I don't think it's a very practical idea
19:14:47 <elliott> (also, yikes, that curry!)
19:14:55 <mgsloan> hahaha
19:18:57 * mgsloan heads to SeaFunc to pontificate about the benefits of static typing
19:42:14 <shachaf> yornlry
19:43:00 <yrlnry> It seems like instead of types Zero and Succ, it would be generally easier and more efficient to represent the type-level arithmetic in binary, using End, OneBit, and ZeroBit, so that instead of Succ(Succ(Succ(Succ(Succ(Succ(Succ(Succ(Succ Zero)))) one would use OneBit(ZeroBit(ZeroBit(OneBit End))
19:43:08 <yrlnry> for numeral 9.
19:43:20 <yrlnry> Is that obviously a stupid idea?
19:43:22 <shachaf> yrlnry: Yes; the reflection paper does that, for instance.
19:43:40 <yrlnry> pointer please?
19:43:45 <yrlnry> URL?  Title?  Anything?
19:44:01 <shachaf> http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
19:44:03 <goodfellow> Title: Functional Pearl: Implicit Configurations
19:44:11 <yrlnry> thanks
19:44:57 <shachaf> I don't know about "easier".
19:45:10 <yrlnry> Hmm, but I don't see how to apply elliott's "lower" trick.
19:45:13 <copumpkin> it's more efficient
19:45:24 <shachaf> lower?
19:45:25 <geekosaur> it's also horrible to work with
19:45:31 <copumpkin> I think edwardk has a library that uses a fancier representation
19:45:33 <yrlnry> I can have lower :: Succ a -> a ; lower =undefined   and then define stuff using lower.
19:45:36 <shachaf> copumpkin: Sure.
19:45:48 <yrlnry> But how can I define a function analogous to lower for ZeroBit / OneBit?
19:45:49 <shachaf> copumpkin: I would not like to represent a 64-bit pointer on the type level with peano naturals.
19:45:52 <shachaf> But it would be easier.
19:45:57 <sellout-> I’m having a cabal hell issue that I know I’ve run into and dealt with before, but I installed the latest Haskell Platform and it’s back: “conflict: my-pkg =>
19:45:57 <sellout-> hashable==1.2.0.7/installed-cc5..., lens =>
19:45:57 <sellout-> hashable==1.1.2.5/installed-e0f…”
19:46:35 <sellout-> lens should be fine with hashable-1.2, and I’ve tried unregistering and re-installing lens to no avail.
19:46:48 <shachaf> yrlnry: In that paper (section 4.1) they use Twice, Succ, Zero, Pred
19:47:05 <yrlnry> I'll read the paper, but not today.
19:47:08 <yrlnry> Thanks.
19:47:15 <shachaf> I'm not sure I understand the question, though?
19:47:35 <shachaf> I guess I didn't read the conversation from before.
19:48:02 <shachaf> yrlnry: A number probably wouldn't be a bit, it would be a type-level list of bits or something.
19:48:12 <yrlnry> Well, I have for example  class Modulus a where modulus :: a -> Integer    and instance declarations for Zero and Succ so that modulus ( undefined :: Succ (Succ (Succ Zero)) )     yields 3.
19:48:41 <yrlnry> The instance declaration for Succ is    instance (Modulus a) => Modulus (Succ a) where modulus = \a -> 1 + modulus (lower a) 
19:48:42 <monochrom> sellout-: how come you have two hashable's? allow only one to live.
19:48:53 <yrlnry> where "lower" is as I suggested.
19:49:17 <yrlnry> But to make this trick work for ZeroBit/OneBit/Start I need an analogue of "lower" that is polymorphic in a funny way.
19:49:21 <sellout-> monochrom: I think the older one is part of Haskell Platform, and I need the newer one.
19:51:49 <monochrom> then you will run into the same kind of problem again next time you have software that wants unordered-containers (which is in Haskell Platform and wants Haskell Platform's hashable) and my-pkg (which wants a different hashable)
19:52:33 <sellout-> monochrom: Then, I should just unregister the old hashable with --force, or what?
19:52:52 <monochrom> if you do that, then your unordered-containers will be useless
19:52:54 <copumpkin> yrlnry: hmm
19:53:11 <shachaf> yrlnry: I'm not sure I understand the problem.
19:53:24 <copumpkin> yrlnry: I think your lower is just "tail"
19:53:26 <copumpkin> or whatever :P
19:53:33 <shachaf> Yep.
19:53:38 <sellout-> monochrom: I remember this having a simple solution last time I ran into it. Just wish I could remember what it was.
19:54:19 <monochrom> there are two simple solutions
19:54:21 <shachaf> yrlnry: Something like http://shachaf.net/clrk.hs ?
19:54:22 <yrlnry> copumpkin:  let me paste this code somewhere so you can see it complete.  It's short, but not short enough to paste here
19:54:35 <monochrom> one is keep Haskell Platform and refuse newer versions
19:54:50 <yrlnry> shachaf:  Oh, that's a much better idea than my idea.  Thanks.
19:54:52 <shachaf> yrlnry: (By the way, you should use Proxy! Like elliott said earlier, it seems.)
19:54:58 <monochrom> the other is to chase newer versions and give up Haskell Platform
19:55:06 <yrlnry> One thing at a time.
19:55:15 <monochrom> I chose to keep Haskell Platform
19:55:20 <shachaf> I feel bad for not using proxy.
19:55:48 <shachaf> Oh well.
19:55:59 <shachaf> Anyway this seems to work.
19:56:11 <copumpkin> works for me
19:56:22 <yrlnry> copumpkin: https://gist.github.com/mjdominus/5711342
19:56:30 <monochrom> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml#correction
19:56:31 <goodfellow> http://tinyurl.com/2v8duo8
19:56:42 <yrlnry> copumpkin:  see, lower is not at all tail
19:56:51 <monochrom> but you can choose the opposite
19:57:08 <shachaf> yrlnry: Your lower is tail, for a list of ()s. :-)
19:57:28 <yrlnry> it's a type-level tail.
19:57:33 <shachaf> Right.
19:57:34 <yrlnry> But I don't know what you mean  by a list of ()s.
19:57:41 <shachaf> Nat ~ [()]
19:57:55 <yrlnry> What does ~ mean here?
19:57:59 <copumpkin> isomorphic
19:58:04 <shachaf> "isomorphic", in this case.
19:58:18 <yrlnry> isomorphic in what sense?
19:58:20 <copumpkin> yrlnry: http://hpaste.org/89333
19:58:20 <shachaf> It's a bit of an abuse since GHC uses ~ to mean type equality these days.
19:58:32 <shachaf> yrlnry: [] = Z, ():[] = S Z, etc.
19:58:39 <shachaf> S = (() :), Z = []
19:59:05 <yrlnry> shachaf:  but you are mixing up types and values when you do that.
19:59:13 <copumpkin> nope
19:59:15 <shachaf> No, it works the same way on the kind level. :-)
19:59:35 <yrlnry> I don't understand what you mean by "the same way"
19:59:36 <copumpkin> just ignore laziness
19:59:47 <yrlnry> Sorry, I'm missing something crucial.
20:00:00 <shachaf> yrlnry: I'm talking on the value level because it's more convenient.
20:00:05 <copumpkin> so the inhabitants of [()] and Nat are the same size. S S S S Z = ():():():():[]
20:00:15 <shachaf> Does the value-level part make sense?
20:00:18 <copumpkin> things can get lifted transparently if you want them to, but it's just conceptual
20:01:10 <yrlnry> I don't even understand what your point is.
20:01:14 <shachaf> yrlnry: copumpkin's type is the same as mine, except the Bool constructors are "distributed" through the list constructors.
20:01:25 <copumpkin> yrlnry: just explaining the parallel with "tail"
20:01:46 <copumpkin> in my paste, I call them unZero and unOne
20:01:49 <copumpkin> but that could be "tail" too
20:02:08 <yrlnry> Sure, I understand the parallel with tail, but it's only an analogy.
20:02:18 <shachaf> Given "data List = Nil | Cons x (List x); data Bool = False | True", [Bool] is isomorphic to Bint, where "data Bint = Zero | One Bint | Zero Bint"
20:02:23 <shachaf> Yes, this is all conceptual.
20:02:28 <shachaf> It's not actually the function tail :: [a] -> [a]
20:02:35 <copumpkin> yrlnry: just pointing out that the lower function is not special in any way
20:03:03 <yrlnry> shachaf:  yes, but when I said you were mixing up the type and value levels, you disagreed!
20:03:05 <copumpkin> what's funny about mine is that since it's a bunch of newtypes, the data itself is ()
20:03:30 <shachaf> yrlnry: I suppose I didn't understand your objection.
20:05:05 <shachaf> (What the paper I linked to does, by the way, is take a StablePtr to a Haskell value, lift it to the type level via this trick, and then reify the type later in order to get a pointer to dereference.)
20:05:42 <copumpkin> should've used peano
20:05:55 <yrlnry> Heh.  I now have code where I put in  mod7 13  and it prints 6.
20:06:04 <yrlnry> But in a *really complicated way*
20:06:16 <shachaf> yrlnry: Also relevant: http://hackage.haskell.org/package/reflection
20:06:17 <goodfellow> Title: HackageDB: reflection-1.3.2
20:06:31 <shachaf> Which is even more evil than anything else mentioned so far.
20:06:39 <yrlnry> How come Num n doesn't imply Integral n?
20:06:59 <shachaf> Because not all Nums are Integral.
20:06:59 <copumpkin> Integral implies Num
20:07:02 <shachaf> For example Double
20:07:08 <yrlnry> Oh, OK
20:07:13 <shachaf> @src Integral
20:07:13 <goodfellow> Plugin `source' failed with: state not initialized
20:07:21 <yrlnry> Wait, that's what I thought, but then it didn't work.
20:07:38 <yrlnry> Hmm.  It does work.
20:07:41 <yrlnry> Good.
20:08:07 <yrlnry> What's the name for the thing on the left of => ?
20:08:16 <shachaf> Constraint?
20:08:21 <yrlnry> yeah, that's what I thought.
20:08:25 <yrlnry> Is there a thing that diagnoses redundant  type constraints?
20:08:36 <shachaf> Hmm, I don't think so.
20:08:39 <yrlnry> OK
20:09:39 <copumpkin> just write it down with too many type constraints
20:09:41 <copumpkin> and ask GHC for the type
20:09:42 <yrlnry> This is good, I'm getting just what I wanted.
20:09:47 <monochrom> omit the type signature, use type inference to obtain minimum constraints
20:09:55 <yrlnry>  mod7 3 == mod6 10 fails with a type error.
20:10:08 <yrlnry> But mod7 3 == mod7 10 is True.
20:10:18 <yrlnry> Thanks for all your help.
20:12:54 <od__> anyone have a septum piercing here?
20:13:04 <dmwit> Wrong channel.
20:13:13 <od__> can you recommend one
20:13:29 <yrlnry> I have an interventricular septum piercing.
20:13:47 <monochrom> please don't prolong this.
20:14:21 <od__> is it normal for the hole to be exposed the first few days?
20:14:26 <copumpkin> od__: this is not the place
20:14:28 <od__> like i can literally see into it
20:14:31 <od__> seems bad
20:14:31 <od__> haha
20:14:42 <od__> well obviously but irc is mostly dead
20:14:45 <dmwit> kick pls
20:14:46 <od__> aside from programmers channels
20:14:48 --- mode: ChanServ set +o monochrom
20:14:49 <copumpkin> this is still not the place
20:14:52 --- mode: monochrom set +b *!*@gateway/web/freenode/ip.83.252.185.206
20:14:53 --- kick: od__ was kicked by monochrom (od__)
20:18:22 <yrlnry> @src negate
20:18:22 <goodfellow> Plugin `source' failed with: state not initialized
20:18:25 <yrlnry> beh
20:18:38 <dmwit> uh
20:18:49 <dmwit> Some lambdabot expert want to tell me what I have to do to initialize the state?
20:19:16 <dmwit> Anyway, I'm betting that wouldn't be in there even if the state were initialized.
20:19:20 <dmwit> It's different for each Num instance.
20:19:21 <shachaf> Where did you run goodfellow from?
20:19:36 <shachaf> I think you have to run it from the lambdabot source directory.
20:19:40 <shachaf> There's a State/ subdirectory.
20:19:52 <yrlnry> I wanted to see the  default definition that is autogenerated from other functions in class Num
20:19:53 <dmwit> There's ~/.lambdabot/State, what do I do in there?
20:19:58 <DigeoNolan> how do you do regular IO inside the SnapMonad?
20:20:14 <shachaf> dmwit: I don't know.
20:20:22 <yrlnry> I did  negate (mod7 3) and immediately got undefined, but I got no warning about it being omitted from  my instance declaration.
20:20:23 <shachaf> I can bring kappabot back if you like.
20:20:31 <shachaf> yrlnry: I think it's (0 -)
20:20:31 <yrlnry> So I wanted to know what it was being generated from.
20:20:44 <Hodapp> ...wow, even #haskell gets trolls.
20:20:54 <yrlnry> I didn't get a warning for - either, so I guess that's defined as x + (negate y)
20:20:57 <dmwit> ?src sum
20:20:57 <goodfellow> Plugin `source' failed with: state not initialized
20:20:57 <kappabot> sum = foldl (+) 0
20:21:01 <shachaf> yrlnry: Yep.
20:21:07 <dmwit> goodfellow: ?quit
20:21:07 <shachaf> yrlnry: 7633 would fix it!
20:21:16 <yrlnry> 7633?
20:21:26 <shachaf> http://hackage.haskell.org/trac/ghc/ticket/7633
20:22:08 <dmwit> DigeoNolan: Not a snap expert, but if it's an instance of MonadIO, you can use liftIO.
20:22:10 <Clint> dmwit: a bunch of gzipped files?
20:22:26 <dmwit> Clint: And ten pounds of flax!
20:22:28 <monochrom> yrlnry: the Haskell 2010 Report has information on minimal completions
20:22:36 <Clint> well, no, i guess only a couple of them are gzipped
20:22:44 <yrlnry> shachaf:  that seems to be sensible for Eq but less so for Num
20:23:06 <shachaf> yrlnry: What isn't sensible? Mutually-recursive definitions or using MINIMAL?
20:23:07 <dmwit> I copied ~/.cabal/share/lambdabot/State/source to ~/.lambdabot/State/source, but it didn't help.
20:23:14 <yrlnry> As the class grows larger, the number of minimal sets potentially grows exponentially
20:23:16 <dmwit> Doesn't matter anyway, kappabot seems fine.
20:24:04 <yrlnry> Suppose your class has N pairs of functions, with each function in each pair defined in terms of the other function in the same pair.  Then you have to specify 2^N minimal sets.
20:24:20 <shachaf> Most classes aren't pairs of functions.
20:24:27 <dmwit> yrlnry: Yes, you want some language for defining the minimal set.
20:24:40 <shachaf> Also, the proposed syntax lets you say something like {-# MINIMAL (a | b), (c | d), ... #-}
20:24:41 <dmwit> yrlnry: What that language is seems orthogonal to whether you want to have a MINIMAL pragma or not.
20:24:49 <monochrom> imo your time is better spent on reading the Num part of the report than on discussing theoretical upper bounds
20:24:59 <dmwit> Depends on goals.
20:25:06 <dmwit> Maybe the goal is to think about something fun.
20:25:44 <monochrom> ok, then go on, I'll just have to ignore
20:25:50 <yrlnry> Maybe goal is to get back to what I was doing and not let this be yet another Haskell project I never finished because the scope kept creeping.
20:26:20 <dmwit> That's such a practical sentiment. You're breaking my heart. =(
20:27:56 <monochrom> yes, I'm practical at the meta level
20:28:36 <monochrom> at the target level, I dabble in practical coding and theoretical mathing alike.
20:29:22 <monochrom> at the meta level, you get to ask: but why this area of theoretical mathing, not that area of theoretical mathing?
20:30:00 <monochrom> and the answer is, at the meta level, I'm still practical, I pick this area of theoretical mathing because I learn something new, something worthwhile from it
20:30:50 <monochrom> and frankly, exponential growth of minimal sets tells me nothing new, I have already known it.
20:37:17 <shachaf> kappabot: @admin + Cale
20:37:17 <yrlnry> Instead of  class Modulus a where   modulus :: a -> Integer  is there a way to say that modulus returns some type b where (Integral b), but not be more specific than that?
20:37:18 <shachaf> kappabot: @admin + dmwit
20:37:21 <shachaf> kappabot: @admin + elliott
20:37:34 <shachaf> yrlnry: Sure. Or even Num.
20:37:37 <yrlnry> Oh, sure there is.
20:37:41 <shachaf> modulus :: Num b => a -> b
20:37:44 <yrlnry> modulus :: Integral b => a -> b
20:37:51 <shachaf> You don't need Integral here.
20:38:04 <shachaf> Er.
20:38:06 <shachaf> Never mind.
20:38:35 <yrlnry> I think I do, because the main use of modulus is to appear in expressions like  foo `mod` (modulus ...)
20:41:04 <shachaf> yrlnry: No, what I was saying makes sense.
20:41:07 <shachaf> yrlnry: Make it Num.
20:41:26 <shachaf> The user can always pick an Integral instance.
20:43:09 <yrlnry> Oh, I just remembered why I'm doing this.
20:47:57 <shachaf> > "hi"
20:47:58 <kappabot>   "hi"
20:48:05 <lambdabot>   "hi"
20:48:05 <s00pcan> hi
20:48:14 <shachaf> @quit forever
20:48:19 <lambdabot> Not enough privileges
20:48:46 <yrlnry> > fix
20:48:52 <yrlnry> @type fix
20:48:53 <lambdabot>   *Exception: show: No overloading for function
20:48:57 <dmwit> Wow, I'm an idiot. I copied .cabal/share/source to .lambdabot/source... on the wrong machine.
20:48:59 <lambdabot> (a -> a) -> a
20:49:06 <yrlnry> @where fix
20:49:12 <Clint> haha
20:49:13 <lambdabot> I know nothing about fix.
20:49:24 <shachaf> @src fix
20:49:29 <lambdabot> fix f = let x = f x in x
20:49:39 <yrlnry> I want to know what import delcaration I need to import it.
20:49:46 <dmwit> ?index fix
20:49:47 <shachaf> Data.Function?
20:49:51 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
20:49:54 <yrlnry> Thanks.
20:50:16 <shachaf> Don't take Control.Monad.Fix. :-( Data.Function is much nicer.
20:50:31 <shachaf> I,I polykinded typ-level Fix
20:51:13 <yrlnry> > fix (\x -> x+1)
20:51:21 <no-n> :t fix
20:51:22 <lambdabot> (a -> a) -> a
20:51:28 <lambdabot>   thread killed
20:51:30 <copumpkin> > fix (\x -> () : x)
20:51:31 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
20:51:35 <copumpkin> infinity!
20:51:56 <dmwit> yrlnry: If you want to iterate to an Eq-fixpoint, you need a different thing.
20:52:08 <yrlnry> No, I just wanted to see if lambdabot would crash.
20:52:20 <dmwit> oh =)
20:52:24 <ski> kennycason : you disappeared a bit earlier ..
20:52:24 <yrlnry> :fix \x -> zipWith (+) (0:x) (0:1:x)
20:52:43 <ski> kennycason : i meant to mention :
20:52:47 <dmwit> > fix (\x -> zipWith (+) (0:x) (0:1:x))
20:52:47 <yrlnry> > fix \x -> zipWith (+) (0:x) (0:1:x)
20:52:48 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:52:48 <lambdabot>   can't find file: L.hs
20:52:51 <ski> kennycason : also, in `createLayer', instead of `Layer (...) (...) (...) learningrate', you could likewise say `Layer {nodes = ...,errors = ...,teacherSignals = ...,learningRate = learningRate}' (well, maybe you'll have to rename the argument)
20:52:53 <yrlnry> Woo
20:52:55 <ski> kennycason : and `(sumNodeError node childLayer) * (value node) * (1.0 - (value node))' could be written as just `sumNodeError node childLayer * value node * (1.0 - value node)'
20:53:56 <dmwit> > fix (\x -> 0:zipWith (+) x (1:x)) -- loop unrolling for extra speed
20:53:57 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:53:59 <yrlnry> It would be pretty funny if fix \x -> x+1 printed "⟘"
20:54:46 <shachaf> GHC can do it!
20:54:52 <shachaf> Well, it can print "<<loop>>"
20:54:54 <yrlnry> Crud, I left my cable at work.
20:55:20 --- mode: monochrom set -b *!*@gateway/web/freenode/ip.83.252.185.206
20:55:25 --- mode: monochrom set -o monochrom
20:55:48 <yrlnry> battery fading.  good night and thanks again
20:55:54 <shachaf> adieurlnry
20:56:37 <dmwit> farewellnry
20:56:49 <yrlnry> Until le week-end, mes amis
20:56:56 <monochrom> see yrlnry
21:00:25 <kennycason> in irc, how do i publicly "tag" a user by nickname when sending him a message?
21:00:46 <shachaf> kennycason: Type their name. Then type a colon and a space. Then type your message.
21:00:46 <kennycason> i keep finding backslash msg, but i think that's private msg :/
21:01:00 <kennycason> shachaf: thanks!
21:01:06 <shachaf> Sometimes you can type part of their name and then press Tab.
21:01:18 <geekosaur> kennycason, the tagging is done by the lient; most tag the nick appearing anywhere, some only notice it as ther first thing on the line
21:01:20 <shachaf> For example with xchat.
21:01:21 <ski> kennycason : try pressing your `<tab>'key after typing the first few characters in the nickname
21:01:25 <geekosaur> *by the client
21:01:40 <kennycason> ski: got it, that worked
21:01:50 <kennycason> geekosaur: nice. tabbing worked for me
21:02:10 <monochrom> you don't have to tag, if it's obvious
21:02:11 <ski> kennycason : did you see the earlier suggestion before your client disappeared, or shall i repeat it ?
21:02:30 <kennycason> ski: thanks for the answer earlier, i will implement some of your suggestions. still very new to haskell
21:02:41 <ski> kennycason : .. in addition to the two above suggestions about ten minutes ago, i mean
21:02:41 <kennycason> ski: you sent 2 lines correct?
21:02:47 <monochrom> for example, suppose you ask a question and want everyone to see it. you don't have to add 986 tags. and yet I will see it.
21:02:50 <kennycason> ski: oh no
21:03:13 <kennycason> hehe right that makes sense
21:03:37 <monochrom> but you can. and I want to see someone do it.
21:03:59 <monochrom> it makes more logical sense for a group of people. or of a group of people.
21:04:09 <ski> kennycason : i suggested another way to write `calculateErrors'
21:04:32 <kennycason> i did some more work on the neural network as well, https://github.com/kennycason/haskell_nn/ (i'm porting from this https://github.com/kennycason/neuralnetwork )
21:04:33 <monochrom> the group of people who say, "I didn't see your answer because you didn't say my name"
21:04:52 <monochrom> ok, your question did not have my name, and yet I saw it?
21:04:56 <ski> kennycason : shall i repeat it ?
21:05:12 <monochrom> logical conclusion: you should add all 900 names to your question.
21:05:21 <kennycason> ski: yes please i can only see createLayer and sumNodeError
21:05:38 <ski> <ski>   calculateErrors layer childLayer = layer
21:05:46 <ski> <ski>     { errors = map (\node -> calculateNodeError node childLayer) (nodes layer)
21:05:52 <ski> <ski>     }
21:05:55 <kennycason> i would love to see more ways to write haskell, in a haskell way, it's so much easier when i try it my way, and then see a haskell expert do it :)
21:06:02 <ski> <ski> kennycason : how about that ?
21:06:09 <ski> <ski> if you swap the args on `calculateNodeError', you could write it as
21:06:13 <ski> <ski>   errors = map (calculateNodeError childLayer) (nodes layer)
21:06:22 <kennycason> oh nice
21:06:24 <kennycason> thanks
21:06:27 <yogert> Which Curses library would people recommend using. At the moment it's between hscurses and ncurses
21:07:09 <monochrom> to add to your confusion, you could also consider vty
21:07:39 <yogert> yeah I saw that too, but I ruled it out based on a single negative comment I saw regarding it : P
21:07:56 <ski> kennycason : this `layer { errors = ... }' is using record syntax to replace the field `errors' in `layer' with a new field value, keeping the other fields (you can update several fields at once, if you separate the updates them by commas)
21:08:12 <monochrom> ah, but you will receive many positive comments for vty and negative comments for all the other *curses
21:08:27 <monochrom> I mean in this channel
21:08:38 <yogert> hah why's that?
21:08:42 <yogert> is it the best?
21:08:57 <monochrom> I don't actually know, but I saw it happened.
21:09:26 <m3ga> Conduit question: is it possible to write a Conduit which feeds two Sinks? eg sinkFile as one Sink, and another Data.Conduit.List.consume?
21:09:44 <yogert> you mean, someone asked the same question, and the general response was to use vty?
21:09:49 <monochrom> yes
21:09:56 <kennycason> ski: i think i get it. btw, is my thinking that if i want to "update" a variable in a record, that i have to create a new one, with the new/updated values? even if only one out of N fields changed?
21:10:06 <yogert> okay
21:10:11 <yogert> vty it is then : )
21:10:12 <kennycason> ski: is my thinking correct*
21:10:58 <yogert> I've never done anything with curses before, so I don't know what I should look for from a library in the first place
21:11:04 <monochrom> it creates a new record
21:11:20 <applicative> yogert: it seems to have more dependencies on http://packdeps.haskellers.com/reverse though this is hardly decisive
21:11:53 <applicative> especially given how few there are for any of them
21:13:32 <johnw> kennycason: if you have a record value named "x", you can create a new value with a single member having been changed by saying: x { fieldName = value }
21:14:43 <dmwit> kennycason: Yes, that is correct, though the syntax is slightly more compact.
21:15:05 <yogert> applicative: hmmm, maybe I'll give each a try then…
21:16:40 <applicative> https://github.com/mchakravarty/BigPixel "is an image editor for pixel art"
21:17:00 <applicative> it kind of freaked me out that M Chakravarty was devising such a thing...
21:17:22 <applicative> The Haskell code is relatively simple on purpose. It is part of an effort to teach programming to children. Contributions are most welcome, but please keep them in this spirit.
21:17:33 <applicative> I'm sending in lens support ...
21:17:36 <mm_freak> yogert: if it's of any help i'm a happy vty user
21:18:18 <mm_freak> vty at least allows you to construct pictures purely
21:19:08 <ski> kennycason : yes
21:19:21 <kennycason> thanks guys
21:19:24 <yogert> mm_freak: what about vty-ui?
21:19:37 <yogert> i noticed it has a very nice manual
21:19:46 <yogert> http://jtdaugherty.github.io/vty-ui/manuals/vty-ui-users-manual-1.6.pdf
21:20:04 <mm_freak> yogert: i've only done a few small experiments with vty-ui in the past…  it's a nice library, but i don't use it myself
21:21:31 <yogert> okay, but vty is easy and full featured enough for your purposes? I've never done anything with curses before, and this interface won't be too complex
21:22:07 <mm_freak> yogert: i guess it's full-featured enough for about anything
21:22:18 <mm_freak> yogert: btw, vty is /not/ a curses wrapper
21:22:26 <mm_freak> it does its own termcap/terminfo
21:22:46 <yogert> ohh okay
21:22:59 <geekosaur> and this is a good thing because curses was named that for a reason :)_
21:23:07 <mm_freak> hehe
21:23:15 <mm_freak> i can only agree
21:23:48 <yogert> okay. vty it is then
21:24:38 <mm_freak> i wonder if vty runs on windows
21:25:00 <yogert> no i dont think so… : /
21:25:19 <yogert> and the dependencies might be a problem
21:25:32 <mm_freak> don't be too pessimistic…  haskell is a very portable language =)
21:25:39 <mm_freak> i'm just worried about the termcap/terminfo stuff
21:26:01 <yogert> well looking at
21:26:02 <yogert> https://github.com/coreyoconnor/vty#windows
21:26:23 <mm_freak> and about dependencies…  most serious haskell projects will have many dependencies…  that's because libraries in haskell are usually comparatively small
21:26:46 <mm_freak> ok, so much for windows =)
21:27:02 <mm_freak> but then i guess nobody runs terminal applications on windows
21:27:25 <yogert> well cabal has warned me that installing this may break a bunch of preexisting packages
21:27:55 <mm_freak> ah, welcome to dependency hell =)
21:28:02 <mm_freak> i've recently switched to cabal-dev
21:28:11 <lispy> cabal-dev, FTW
21:28:14 <yogert> whats that?
21:28:26 <lispy> yogert: it's a wrapper around the normal cabal command that adds sandboxing
21:28:29 <mm_freak> yogert: separate cabal worls for your projects
21:28:41 <yogert> oh so its like virtual-env?
21:29:08 <mm_freak> yeah…  but the message you are seeing is very likely because you're installing vty much later than other packages
21:29:14 <lispy> yogert: cabal install cabal-dev, and then use cabal-dev like you would use cabal normally, with the caveat that where every you run cabal-dev from it will expect the sandbox to be in _that_ directory.
21:29:45 <yogert> ok
21:29:51 <lispy> yogert: so I just make sure to use cabal-dev from the top of the project directory everytime
21:29:53 <mm_freak> doing this would probably fix it:  cabal update && rm -rf ~/.cabal/{bin,lib,setup-exe-cache,share} .ghc && cabal install world vty vty-ui
21:29:58 <applicative> yogert: or just figure what the problem is
21:30:32 <mm_freak> yogert: you may want to add -jN to the cabal-install command
21:30:37 <mm_freak> where N is your number of cores
21:30:47 <yogert> eh, too late
21:31:00 <johnw> yogert: C-c and add -j, it makes a huge difference
21:31:00 <lispy> or just -j
21:31:12 <yogert> why?
21:31:15 <lispy> mm_freak: newer versions of cabal can figure out how many cores to use
21:31:24 <applicative> runs in parallel with -j
21:31:30 <yogert> for compiling
21:31:31 <yogert> ?
21:31:33 <lispy> yeah
21:31:49 <mm_freak> lispy: ah, cool
21:32:31 <applicative> its much faster for a lot of packages, but inevitably you dont get as much information at the point of breakdown
21:32:53 <mm_freak> in which case just run again without -j to see the messages
21:33:00 <applicative> yes
21:33:29 <mm_freak> don't be confused if it suddenly works…  cabal may have install a configure-time dependency along the way
21:33:30 <monochrom> alternatively look for logs in .cabal/logs
21:33:38 <lispy> monochrom++
21:33:48 <monochrom> I found out accidentally
21:33:53 <yogert> hmmm… I would invoke the command like so… "cabal install cabal-dev -j"?
21:34:17 <applicative> yes
21:34:23 <mm_freak> yogert: if you want to use cabal-dev i suggest maintaining your ~/.cabal/world
21:34:24 <yogert> yeah, doesn't work
21:34:46 <yogert> says it is an unrecognized option
21:34:50 <applicative> what version of cabal?
21:35:19 <applicative> what version of ghc I was going to ask earlier.
21:35:24 <mm_freak> yogert: add all packages you want to have installed globally to your ~/.cabal/world (only cabal-dev probably suffices), then you can update much easier in the future
21:35:53 <yogert> 0.14.0 / 1.14.0 for cabal
21:35:58 <applicative> -j is a fairly new addition
21:36:01 <mm_freak> yogert: note that adding common packages doesn't make a difference…  cabal-dev ignores packages in ~/.cabal anyway
21:36:02 <yogert> ok
21:37:08 <applicative> i guess a more recent cabal-install will be more trouble than it is worth
21:37:35 <mm_freak> unless your distribution provides it
21:37:37 <monochrom> upgrading software is a rabbit hole
21:38:39 <lispy> I've never really had an issue upgrading cabal-install. I've only ever had trouble getting it instead from scratch.
21:38:40 <carter> lispy once they fix some bugs in cabal sandboxing, cabal head / 1.17 (the soon to be 1.18)
21:38:42 <carter> will be very very nice
21:38:44 <yogert> yeah. I've been having a lot of trouble with it lately. I completely broke my Scipy installation the other day, and haven't been able to get matplotlib working yet....
21:39:27 <lispy> carter: I'll have to make some new aliases. The new commands are soooo long, but I do look forward to being able to retire cabal-dev.
21:39:38 <carter> lispy huh?
21:39:53 <carter> the new UI chrome has landed already
21:40:01 <carter> you just need to do cabal sandbox init
21:40:04 <carter> then just the normal style command
21:40:07 <carter> and you're good
21:40:09 <carter> dont' use it yet
21:40:15 <carter> 1-2 bugs still to shake out
21:40:58 <yogert> so should I not get cabal-dev then/
21:40:59 <yogert> ?
21:41:08 <carter> yogert use cabal-dev
21:41:18 <carter> until cabal/cabal-install head stabilizes
21:41:25 <yogert> ok
21:41:26 <carter> (ie when 1.18 comes out, USE IT)
21:41:40 <carter> it takes the good ideas
21:41:43 <carter> and makes them better
21:41:53 <carter> or ask me in a few weeks
21:41:56 <carter> and if i'm using it again
21:42:01 <carter> its probably not *too* borken :)
21:42:02 <applicative> and what does it do with the bad ideas?
21:42:43 <carter> applicative which one is those?
21:42:44 <lispy> carter: ah, I thought you had to type 'cabal sandbox ...' where ... = all the normal cabal commands.
21:42:52 <carter> yes
21:42:54 <carter> nope
21:42:56 <carter> you dont :)
21:42:59 <lispy> yay
21:43:06 * lispy goes back to reading
21:43:08 <carter> als you can point to other sandboxed things
21:43:17 <carter> and i think it does *the right thing*
21:43:20 <carter> not sure what that right thing is
21:43:39 <carter> because I hit a pattern matchign bug
21:43:45 <carter> that make things borken
21:43:55 <crotchet> In a constructor callout like "Vertex2 !a !a " what is the significance of the "!" ?
21:44:09 <geekosaur> strict
21:44:37 <shachaf> Hoogle can answer that!
21:44:38 <shachaf> @where hoogle
21:44:38 <lambdabot> http://haskell.org/hoogle
21:44:44 <geekosaur> (so the parameters to Vertex2 are always in WHNF)
21:46:38 <arkeet> crotchet: it makes the constructor strict, so  Vertex2 x y  really means  x `seq` y `seq` Vertex2 x y
21:46:50 <applicative> crotchet: its a good plan for a non-recursive type in any case
21:47:21 <arkeet> well, sort of.
21:47:34 <applicative> Vertex2 !Double !Double is even more valuable
21:47:35 <arkeet> http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-690004.2.1 -- where it talks about strictness flags
21:48:07 <crotchet> arkeet: applicative: thank you, I will check those out :)
21:48:20 <arkeet> applicative: and then you can unbox them.
21:48:41 <applicative> right but with 02 or the like in theory this is done anyway
21:49:17 <lispy> Are you sure that -O2 implies unbox-strict-fierds?
21:49:20 <lispy> fields*
21:49:21 <applicative> yeah
21:49:33 <applicative> or Im imagining I'm sure ...
21:49:52 <lispy> Maybe I just use -O2 as a cargo cult measure :)
21:50:12 <lispy> I don't actually know a good way with ghc to know what -ON implies for each N.
21:50:24 <lispy> They need to maintain a per-release table in the user-guide. Do they?
21:51:27 <applicative> there is a table somewhere, no? i cant find it though
21:51:59 <cmears> "The easiest way to see what -O (etc.) really mean is to run with -v, then stand back in amazement."
21:52:04 <cmears> there's your table
21:52:22 <crotchet> shachaf: thanks for the Hoogle link. Didn't know about that
21:52:55 <carter> lispy someone should write that table and given them a ticket for it
21:53:11 <carter> GHC team is epic underresourced
21:53:17 <carter> i'm doing enough GHC related stuff as is
21:53:18 <carter> someone else do it
21:54:53 * lispy nods
21:55:06 <carter> PLEAASE
21:55:40 * carter DO YOUR PART, AID THE CAMPAIGN FOR AWESOME FP FOR ALL.
21:58:35 <thoughtpolice> -O2 does not imply -funbox-strict-fields
21:59:49 <carter> no funbox for you
21:59:52 <carter> thanks for chiming in :)
22:00:22 <carter> or just {-# Options -funbox-strict-fields #-}
22:00:26 <carter> i'm getting the syntax wrong
22:01:08 <applicative> thoughtpolice: :(
22:01:37 <lispy> carter: OPTIONS_GHC, IIRC
22:01:48 <carter> sounds about right
22:01:50 <lispy> carter: am I not doing my part?
22:01:50 <johnw> lispy is correct
22:01:51 <thoughtpolice> the basic overview of what gets turned on by the various -O flags is here: https://github.com/ghc/ghc/blob/master/compiler/main/DynFlags.hs#L2790
22:02:10 <carter> applicative you kinda want to only do that per module anyways
22:02:11 <lispy> if I'm not, I will do more.
22:02:23 <thoughtpolice> (i think it's totally reasonable to document this FWIW. patches welcome :)
22:02:26 <lispy> But, I'm kind of hoping that I'm contributing a reasonable amount already :)
22:02:40 <carter> lispy you do maintain opengl bindings
22:02:42 <carter> thats kinda big :)
22:02:51 <carter> hey other people on channel
22:03:08 <carter> those lurkers seeking more gold in them thar hills of lambda awesome
22:03:12 <carter> JOIN US :)
22:03:23 <carter> or someting
22:03:31 <carter> we need recruitment posters
22:03:45 <carter> Chak was just remarking in a twitter thread about how under resourced ghc dev team is
22:03:46 <lispy> Someone was making one. mzero?
22:03:53 <lispy> yeah true
22:04:00 <lispy> We need another Simon Marlow or three.
22:04:04 <carter> i'm hopefully getting 1-2 patches in thsi summer
22:04:07 <carter> maybe more
22:04:21 <carter> lispy…. acfoltzer  has kinda sniped me about NUMA
22:04:26 <johnw> carter: I would actually love to help, give me a little task and help me get started!
22:04:35 * applicative sees his strict fields failing to be unboxed now 
22:04:35 <carter> johnw i'm still getting strated myself :)
22:04:47 <carter> *started myself
22:04:49 <johnw> I have GHC HEAD building on my Mac every day through Jenkins, so that part is setup
22:05:01 <carter> johnw you're better equiped than I then :)
22:05:01 <johnw> well, if you find something a GHC contributor newb could do, let me know
22:05:03 * applicative doesnt want to type -funbox-strict-fields 
22:05:11 <carter> johnw , as thoughtpolice  jsut said,
22:05:13 <lispy> johnw: have you already read the getting started documentation on the GHC trac?
22:05:20 <johnw> lispy: yes
22:05:23 <thoughtpolice> the only advice i can offer you all (as a committer) is just to be persistent and have fun :)
22:05:30 <carter> thoughtpolice yes
22:05:37 <thoughtpolice> i have really been meaning however to write something about "Getting running with GHC as quickly as possible for hackers" or somesuch
22:05:44 <carter> thoughtpolice i'd read it
22:05:56 <carter> even though i'm kinda starting to not be ignorant
22:05:58 <carter> or at least
22:06:01 <thoughtpolice> because people are often confused by OTHER things aside from you know, all the GHC complexity. filing tickets, making sure they're in the right state, attaching patches, making sure ./validate is OK, etc etc
22:06:10 <lispy> johnw: do you understand any of the bugs in tracker that are marked as probably easy?
22:06:18 <thoughtpolice> but these are all just as important as you work, and MORE important in the beginning where you work on small things
22:06:30 <carter> johnw or you coudl do the docs for that thing we just discused :)
22:06:31 <johnw> lispy: I didn't even know I could make such a query :)
22:06:42 <thoughtpolice> i feel that the overload on Trac and the commentary can very easily 'information overload' people, and something with the focus of "Get to this point and you can give us patches!" would be good
22:06:52 <johnw> carter: I'm terrible at getting motivated to do docs; my own users complain about that pretty constantly already
22:07:04 <carter> johnw then think about it as a personal growth challenge
22:07:08 * hackagebot hledger 0.21.2 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.21.2 (SimonMichael)
22:07:12 <carter> the one patch in ghc that mentions my name
22:07:13 <lispy> johnw: ah, in one of the random wiki pages it tells you what keywords to use. So, the idea is that at some point someone marked certain bugs as likely to be easier for beginners.
22:07:20 <johnw> carter: if I were to take up that challenge, I'd have to do it elsewhere than GHC first
22:07:28 <carter> is me reading the souce
22:07:33 <carter> then seeing a comment that is a lie
22:07:38 <carter> then opening a ticket with my patch
22:07:47 <carter> then SimonM and SPJ susing it out
22:08:04 <carter> and correciting the comment
22:09:18 <lispy> johnw: FWIW, I think if you had an interest in windows support there is probably more low hanging fruit.
22:09:33 <thoughtpolice> johnw: honestly, if you have a build bot and can contribute that
22:09:34 <lispy> johnw: Just look for any ticket that I'm watching :)
22:09:36 <thoughtpolice> i would love you
22:09:51 <thoughtpolice> if you can actually make the argument for using jenkins, which is probably easy if you have a running example, i would love you more
22:10:04 <carter> oh yeah
22:10:12 <johnw> thoughtpolice: sure, I've spent quite a bit of time with both buildbot and jenkins, and jenkins is 1000x easier to keep running
22:10:25 <carter> johnw i need to learn about those BUILD / CI tools mroe
22:10:54 <thoughtpolice> GHC build bots are IME horribly neglected. occasionally you see people talk on ghc-builds about some failure, but really it seems like no people pay attention to the tickets. they also use Ben's odd buildbox package, which i don't know why it's necessary.
22:11:07 <thoughtpolice> er, s/tickets/builds/
22:11:14 <johnw> we use Jenkins at my company too, so I interact with it daily in a production environment
22:11:23 <carter> https://github.com/ghc/ghc/commit/a44978b94c63d7b67adc76fdf4093b97e41d8c81 the commit with the comment bug i pointed out
22:11:24 <thoughtpolice> i'd love to see a publicly viewable jenkins instance with a set of GHC builders that could complain
22:11:27 <carter> ooo
22:11:30 <carter> yessss
22:11:31 <thoughtpolice> yes, we use Jenkins at work too, it's quite nice
22:11:38 <lispy> johnw: the things that make me dislike jenkins are a) the UI seems unnecessarily opaque, b) every jenkins system I've seen has mysterious failed builds and people just "resubmit them".
22:11:46 <carter> theres another one too
22:11:56 <johnw> lispy: TeamCity is another good one
22:12:00 <carter> lispy i know nothing about build tools
22:12:07 <johnw> but I can't help with that one, since I have no reason to use it
22:12:08 * hackagebot hledger-web 0.21.2 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.21.2 (SimonMichael)
22:12:17 <lispy> johnw: I like travis-ci, but I've never tried to configure my own.
22:12:35 <thoughtpolice> i would also like to see performance buildbots, and this can be done with jenkins as well.
22:12:47 <johnw> thoughtpolice: yes, I run nofib every day
22:12:50 <johnw> and I keep the logs for every day
22:12:56 <carter> OOOOOOO
22:12:57 <johnw> so that someday, I can produce some meaningful historical trend graphs
22:13:04 <carter> johnw SHARE THIS
22:13:09 <johnw> one sec
22:13:16 <carter> also email ghc-devs
22:13:17 <carter> :)
22:13:18 <carter> plese
22:13:20 <carter> please
22:13:25 <carter> they will give you their loves
22:13:27 <lispy> carter: these CI systems are only nice when they're not creating fires of their own to put out. So, I'm sort of neutral to them. I appreciate the need/change of keeping HEAD building for the whole team but without a dedicated build manager it can be a real time sink and demoralizer for the team.
22:13:37 <sm> I'm using (not operating) hydra, a nix-based built bot, and it seems pretty good
22:13:50 <carter> lispy you mean a "master of builds"
22:13:57 <carter> "person who manages the builders"
22:14:00 <lispy> yes
22:14:05 <johnw> carter: http://dl.dropbox.com/u/137615/ghc-nofib-mac.zip
22:14:18 <johnw> my logs stopped recently, because a UTF-8 bug in Java (or Jenkins) is preventing my GHC builds from completing
22:14:37 <johnw> but those nofibs go back to Jan 19
22:14:38 <carter> http://hackage.haskell.org/trac/ghc/ticket/7907 was the other commit based on me seeing a bug in the comments
22:14:46 <lispy> I would blame GHC. It's unicode support is very sensitive to the LOCALE and other related settings in the environment.
22:14:46 <thoughtpolice> my main worry with jenkins is that i don't know how well it will run on my ARM boxes which i would like to get performance numbers on
22:15:06 <lispy> thoughtpolice: it's written in java, is there a JVM for arm?
22:15:15 <carter> lispy yes
22:15:23 <carter> apparently oracle enterprise apps
22:15:26 <carter> on IOS
22:15:29 <carter> use JVM
22:15:42 <carter> because you are allowed to JIT on apps in enterprise
22:15:47 <carter> IOS
22:16:07 <thoughtpolice> lispy: there is, but jenkins requires an agent on the host. on smaller ARM machines, i could definitely forsee jenkins muddling with performance numbers
22:16:18 <lispy> gotcha
22:16:28 <thoughtpolice> another alternative that i really liked for speed runs is the tool used by PyPy, CodeSpeed
22:16:41 <thoughtpolice> it's very slick, and can do JSON submitted reports through a POST API which would be great
22:16:44 <ndrbr> \quit
22:16:57 <thoughtpolice> because we could just post JSON created after the run to the server. the problem is that codespeed supports no forms of authentication
22:17:15 * lispy wonders, whenever he sees "\quit", if it's a troll to get people to /quit on accident
22:17:17 <thoughtpolice> which is terrible :( you can just POST random JSON to it all day and it won't care, it seems. either that, or i don't know how to django/python i guess
22:17:19 <carter> thoughtpolice proxy with snap
22:17:27 <carter> or somethign
22:17:38 * applicative was tempted to /quit
22:17:44 <carter> thoughtpolice i know some python folks who'd be happy to help
22:17:49 <thoughtpolice> the point is i don't want to do much work! :P the fact codespeed allows random JSON requests seems like the bigger problem to me :P
22:17:59 <carter>  slash / i've nerd sniped them into liking haskell
22:18:00 <thoughtpolice> but i also only played with codespeed for a short time. otherwise it was very, very nice
22:18:12 <carter> so an excuse to help with GHC dev stuff
22:18:17 <carter> would be fun!
22:18:40 <lispy> carter: funny you mention that, I often think that python programmers are the most likely to try haskell for the first time and like it.
22:19:13 <thoughtpolice> johnw: but yes, if you would be willing to contribute your machine, that would definitely be a very real impact. tibbe is also using jenkins for his GHC builds i believe, it's maybe worth bringing up to the list
22:19:20 <carter> lispy one of them was asking me about exactly the rando monomorphic foldables in Prelude
22:19:22 <thoughtpolice> (FWIW, i have no clue how you get your machine to become a GHC buildbot :P)
22:19:26 <carter> right before that go voted fixed
22:19:39 <johnw> thoughtpolice: I'd be happy to run daily builds, but I cannot give access to others to this machine, there is too much sensitive data on it
22:19:55 <thoughtpolice> ah, personal machine?
22:19:57 <johnw> yes
22:20:03 <carter> johnw how beefy is the hardware?
22:20:05 <johnw> i run the build in the wee hours, it takes up to 7 hours to run
22:20:10 <johnw> 8-core i7 24G RAM
22:20:18 <johnw> i do: build, fulltest, nofib
22:20:20 <carter> 7 hours for nofib?
22:20:24 <carter> ahhhhhh
22:20:28 * lispy has been tempted to get a cloud based windows server and attempt to configure a windows specific haskell build bot, but the project is very daunting.
22:20:31 <johnw> i keep the test logs for each run too
22:20:37 <carter> cool
22:20:45 <thoughtpolice> that seems absurdly long, i can do a performance build of GHC on a dual core machine and run the whole testsuite in less than 2-3 hours easily
22:20:49 <carter> johnw if you could standardize setting that up
22:21:03 <carter> thoughtpolice: maybe he doesn't have SSDs on that machine
22:21:03 <thoughtpolice> are you parallelizing your builds in jenkins?
22:21:03 <johnw> carter: oh yes, my build script is actually quite simple, I'll show you
22:21:14 <johnw> no, parallelizing is unreliable
22:21:16 <thoughtpolice> carter: SSDs don't have that dramatic of an impact
22:21:19 <carter> oh
22:21:19 <carter> ok
22:21:29 <johnw> it runs on a RAID-10
22:21:38 <thoughtpolice> johnw: if it's unreliable, you need to tell us. 'make -j3' should roughly speaking always have a pretty complete dependency graph and always work.
22:21:51 <thoughtpolice> it if doesn't, our dependencies are wrong, and that's a bug. even if it's a tough one :P
22:22:01 <thoughtpolice> really ANY 'make -jX' setting at all
22:22:04 <thoughtpolice> on any amount of cores
22:22:08 <johnw> the problem is, when the "unreliable" thing happens (maybe 1 out of every 20 days), the build actually hangs and the processes never die
22:22:16 <johnw> I only notice it because my forks stop failing
22:22:31 <johnw> s/stop/start
22:22:42 <lispy> carter: thoughtpolice just reminded me of this paper. Considering that we were just talking about build systems earlier, I highly recommend you read this: http://aegis.sourceforge.net/auug97.pdf
22:22:44 <carter> thoughtpolice johnw  yeah… parallel build failrus are a bug
22:23:01 <johnw> so, since it happens when I'm asleep, I don't care about 3hrs vs. 7hrs
22:23:06 <johnw> so I go for reliability
22:23:20 <carter> johnw parallel builds FUZZ the build spec
22:23:28 <carter> stuff is underspecified if it breaks
22:23:35 <lispy> johnw: so that's a great example of the jenkins thing I was talking about. Why does everyone have random jenkins failures on an otherwise functional build?
22:23:46 <lispy> johnw: is jenkins simply buggy in this regard?
22:23:53 <carter> those are bug reports Begging  to be reproduced and filed on trac
22:23:58 <johnw> lispy: I don't think jenkins is the problem here
22:24:14 <carter> lispy yeah… ghc make -j will fail
22:24:17 <johnw> Jenkins is just running a shell script, and from that point onwards, jenkins  is just waiting fro the script to end
22:24:26 <lispy> okay
22:24:32 <carter> on sufficiently parallel machines
22:24:37 <lispy> I have seen this behavior for lots of projects though.
22:24:42 <carter> because the deps or timing info is impresice
22:25:00 <johnw> carter: here is my jenkins build script: https://gist.github.com/5711810
22:25:01 <carter> thoughtpolice didn't geoff or someone fiddle with the time stamp info somtime recently?
22:25:16 <thoughtpolice> missing a build dependency is entirely possible. what worries me more is the whole 'the build never finishes thing'
22:25:20 <thoughtpolice> and that kind of worries me a lot :P
22:25:29 <thoughtpolice> carter: no clue
22:25:33 <carter> johnw thanks, now I just need to at some point setup jenkins
22:25:34 <carter> :P
22:25:35 <johnw> thoughtpolice: I'm willing to re-enable parallelism, if it would help you track it down
22:25:42 <carter> johnw please
22:25:44 <carter> the more info
22:25:46 <carter> the better
22:25:51 <johnw> carter: if you can set it up on a machine and give me access, I will replicate my ghc job there for you
22:26:08 <johnw> I do run the tests with THREADS=64
22:26:10 <carter> johnw i won't have any fun build machines to ask for help to setup till after wellposed.com product launch :)
22:26:25 <thoughtpolice> johnw: do you know where the deadlock occurs by chance?
22:26:33 <johnw> no, I did not analyze it
22:26:35 <carter> and either i've got customers signed by mid summer or i've got a day job
22:26:41 <johnw> but now I know who to talk to about it, I will track this down
22:26:46 <carter> johnw please
22:26:56 <thoughtpolice> johnw: OK. i think the possibility of a bug in the test suite is also likely too, and probably more likely than 'make' being the problem
22:26:58 <johnw> i usually build with -j22, is that just beginning for trouble?
22:26:58 <carter> i'm bad at this too, the repro phase of bug reports :)
22:27:05 <thoughtpolice> but who knows! i've been wrong before, and it turned out crazy shit was the cause
22:27:05 <johnw> s/beginning/begging
22:27:14 <carter> johnw thats pretty parallel
22:27:26 <carter> i don't think most ghc devs are building on that parallel a level
22:27:31 <carter> so could be good FUzzing
22:27:34 <johnw> 8x2 (hyper-threading, means I need a lot of jobs to guarantee saturation almost all of the time
22:27:46 <carter> johnw its good
22:27:50 <thoughtpolice> johnw: but yes, just tracking it down perhaps to what was building would help tremendously. FWIW, if it happens, just doing something like 'ps aux | grep ghc' should give you a good idea
22:27:53 <carter> because there are funny parallel build bugs
22:28:02 <carter> and fixing them
22:28:03 <johnw> ok, i'll enable verbosity on make too
22:28:07 <carter> would let everyoen build faster
22:28:13 <carter> YAY
22:28:27 <carter> im glad my daft exhortations got someones productive attention :)
22:28:32 <thoughtpolice> johnw: the 'ps aux' but is mostly helpful because if the GHC process is there, you can make a pretty good bet about 'what' is happening by the process invocation
22:28:37 <thoughtpolice> s/but/bit/
22:28:51 <thoughtpolice> like whether it's in the testsuite or in a particular part of the build system
22:28:59 <thoughtpolice> well, *I* might be able to recognize this at least :P
22:29:19 <thoughtpolice> johnw: but thanks!
22:29:34 <johnw> ok, once I have data I will ping you, thoughtpolice
22:49:13 <Fuuzetsu> Is there no (\x -> [x]) in Prelude?
22:49:23 <johnw> (:[])
22:49:25 <shachaf> return is in Prelude.
22:49:34 <johnw> ah, yes, and pure
22:49:43 <johnw> maybe not
22:49:45 <Fuuzetsu> Didn't think of it that way, thanks
22:49:45 * johnw shuts up
22:49:52 <shachaf> ?
22:50:06 <johnw> shachaf: I don't even know why I speak sometimes
22:50:22 <shachaf> (:[]) does what Fuuzetsu asked for.
22:50:33 <Sonarpulse> ^^ looks good to me
22:51:08 <ski> johnw : just wondered whether you had put the log online somewhere ..
22:51:19 <johnw> ski: i can do that now, one sec
22:51:32 <ski> no hurry
22:51:37 <ski> i just wondered
22:51:41 <carter> night all
22:51:51 <ski> @botsnack
22:51:51 <lambdabot> :)
22:54:02 <johnw> ski: https://gist.github.com/jwiegley/5711906
22:54:12 <ski> hm, could boolean-blindness be categoriezed under antipatterns ?
22:54:28 <lispy> ski: what is boolean-blindness?
22:54:37 <shachaf> @where boolean-blindness
22:54:37 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
22:54:55 <shachaf> ski: Some cases of it are hard to get rid of, especially in Haskell.
22:55:27 <shachaf> Some instances of it, certainly. But eliminating booleans in general it's hard.
22:55:48 <ski> yeah, i was just pondering whether it should be included in
22:55:53 <ski> @where antipatterns
22:55:53 <lambdabot> See `existential-antipattern' and `incremental-parameter-antipattern'
22:56:04 <shachaf> @where incremental-parameter-antipattern
22:56:04 <lambdabot> "Haskell anti-pattern: incremental ad-hoc parameter abstraction" by Brent Yorgey at <http://byorgey.wordpress.com/2010/04/03/haskell-anti-pattern-incremental-ad-hoc-parameter-abstraction/>
22:56:15 <shachaf> @where existential-antipattern
22:56:15 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
22:56:19 <shachaf> Oh, ski.
22:56:24 <shachaf> @where blah
22:56:24 <lambdabot> I know nothing about blah.
22:56:27 <shachaf> @where test
22:56:28 <lambdabot> ߪ
22:56:36 <shachaf> @where test /me . o O ( hi )
22:56:36 <lambdabot> ߪ
22:56:39 <shachaf> @where+ test /me . o O ( hi )
22:56:40 <lambdabot> I will remember.
22:56:41 <shachaf> @where test
22:56:42 * lambdabot . o O ( hi )
22:56:49 <ski> .. interesting
22:58:08 <johnw> ski: if you want to doctor that log yourself into prose form, you'd be better suited to it than me, I'd love to read it again as a blog entry ... :)
22:59:12 <Fuuzetsu> How about this one: f g (x, y) = (g x, g y)
22:59:19 <johnw> ***
22:59:26 <Fuuzetsu> :t (***)
22:59:27 <shachaf> (&&&) :-)
22:59:28 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
22:59:28 <johnw> GAH
22:59:35 <arkeet> :t over both
22:59:36 <lambdabot> (a -> b) -> (a, a) -> (b, b)
22:59:43 <shachaf> Hmm, no.
23:00:04 <Fuuzetsu> …I recommended (&&&) so many times myself.
23:00:05 <johnw> @pl \f g (x, y) = (g x, g y)
23:00:05 <lambdabot> (line 1, column 13):
23:00:06 <lambdabot> unexpected "="
23:00:06 <lambdabot> expecting pattern or "->"
23:00:06 <shachaf> join (***). Ugly.
23:00:08 <Fuuzetsu> I think I need to go to bed
23:00:11 <johnw> @pl \f g (x, y) -> (g x, g y)
23:00:11 <lambdabot> const ((`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .)))
23:00:19 <arkeet> :t join (***)
23:00:20 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
23:00:21 <johnw> it doesn't use Control.Arrow I guess
23:00:23 <shachaf> over both is how I would write it, allowing for lens.
23:00:41 <Fuuzetsu> :t join
23:00:42 <lambdabot> Monad m => m (m a) -> m a
23:00:43 <ski> @pl \g (x, y) -> (g x, g y)
23:00:43 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
23:01:14 <arkeet> @pl f g (x, y) = (g x, g y)
23:01:14 <lambdabot> f = (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
23:01:17 <Fuuzetsu> pl-style totally worth it
23:01:21 <johnw> lol
23:01:51 <arkeet> @pl f (***) g (x, y) = (g *** g) (x,y)
23:01:51 <shachaf> johnw: The other day I wrote (. (. f)). It was great.
23:01:51 <lambdabot> (line 1, column 19):
23:01:52 <lambdabot> unexpected " "
23:01:52 <lambdabot> expecting operator
23:02:03 <johnw> shachaf: no, I cannot believe it!
23:02:04 <arkeet> @pl f (***) g (x, y) = (***) g g (x,y)
23:02:05 <lambdabot> (line 1, column 19):
23:02:05 <lambdabot> unexpected " "
23:02:05 <lambdabot> expecting operator
23:02:06 <arkeet> heh
23:02:14 <arkeet> :t \f -> (.(.f))
23:02:15 <lambdabot> (a -> b) -> ((a -> c1) -> c) -> (b -> c1) -> c
23:02:36 <arkeet> fmap for cont.
23:02:41 <shachaf> Yep.
23:02:53 <Fuuzetsu> @pl (\(x, y) -> (c:x, y))
23:02:53 <lambdabot> first (c :)
23:02:59 <arkeet> c:
23:03:17 <Fuuzetsu> :t first
23:03:18 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
23:03:35 <johnw> :t first &&& second
23:03:36 <lambdabot> Arrow a => a b c -> (a (b, d) (c, d), a (d1, b) (d1, c))
23:03:50 <johnw> :t first *** second
23:03:51 <lambdabot> (Arrow a1, Arrow a) => (a b c, a1 b1 c1) -> (a (b, d) (c, d), a1 (d1, b1) (d1, c1))
23:03:59 <shachaf> For Cont, join = (. return)
23:04:01 <shachaf> Isn't it great?
23:04:07 <Fuuzetsu> > let c = 'a' in (first (c :)) ("ab", "cd")
23:04:08 <lambdabot>   ("aab","cd")
23:04:35 <johnw> I discovered InterleaveT for the first time the other day
23:05:05 <johnw> (from the interleave package)
23:05:22 <johnw> a rather handy way of doing tricky stuff with <|> chains
23:05:38 <johnw> shachaf: what were you doing with Cont?
23:05:45 <kennycason> ski: finally had a chance to read/implement your changes! thanks again. much simpler :)
23:05:56 <shachaf> johnw: Codensity, actually.
23:06:09 <johnw> oh, are you familiar with the Prompt monad?
23:06:14 <shachaf> johnw: I was trying to get more intuition for the right-reässociating it does.
23:06:21 <shachaf> Nope.
23:06:41 <johnw> i would like to gain that intuition too; if you discover something, I'd love to hear it
23:07:18 <shachaf> I haven't discovered much, alas.
23:07:21 <johnw> from what I was reading in the Monad.Reader, it really sounds like Prompt ≅ operational ≅ Free + Codensity
23:07:36 <shachaf> Free + Codensity
23:07:37 <zvrba> hm.
23:07:52 <johnw> although I'm not sure if Prompt does the right-reässociating
23:08:15 <shachaf> Do you mean Free + CoYoneda?
23:08:24 <johnw> ah, yes, that is what I meant
23:08:31 <shachaf> (That diæresis thing looks really weird when someone else does it.)
23:08:41 <johnw> is there a link between Free + CoYoneda and Codensity?
23:08:42 <shachaf> (Especially for a complete abuse of it like mine.)
23:09:00 <shachaf> I don't know. Probably.
23:09:01 <shachaf> Hmm...
23:09:15 <johnw> i think edwardk said that CoYoneda is for forcing fmap fusion, and Codensity is for forcing bind fusion
23:09:17 <shachaf> I wonder if that ties in with the class Functor m => Monad m where monad :: Free m a -> m a
23:09:24 <shachaf> thing that I was talking about the other day.
23:09:29 <zvrba> any opinions on languages based on rewriting logic (Maude / Pure languages) vs those based on lambda calculus (Haskell) ?
23:09:40 <shachaf> (cf. class Monoid m where mconcat :: [m] -> m)
23:09:48 <shachaf> (Where [] is the free Monoid, of course.)
23:09:50 <ski> kennycason : btw, the `::'s in the declaration of `Layer' look a bit cramped -- maybe give them some air to breathe ?
23:09:56 <johnw> shachaf: I missed that discussion
23:10:26 <ski> kennycason : and you can omit the outer brackets in the body of `createNodeRow'
23:10:48 <kennycason> ski: ah yes, i usually always give  operators space to breath hehe
23:10:52 <shachaf> If you rewrite your monad code to only use "monad" once, you're guaranteed that things will be right-associated.
23:11:10 <ski> zvrba : i think i know too little about them to be able to comment much usefully
23:11:11 <shachaf> Anyway, the whole right-reassociating thing can be thought of as converting (join . fmap join) to (join . join)
23:11:23 <johnw> ah
23:11:27 <zvrba> ski: ok.
23:11:42 <shachaf> (Or is it the other way around? Suddenly I'm not sure.)
23:12:01 <johnw> how can you just drop the fmap?
23:12:11 <ski> kennycason : also, you didn't use the `Layer { nodes = ... , errors = ... , teacherSignals = ... , learningRate = ... }' when constructing fresh `Layer's there -- was this deliberate ?
23:12:12 * hackagebot soap 0.2.0.4 - SOAP client tools  http://hackage.haskell.org/package/soap-0.2.0.4 (AlexanderBondarenko)
23:12:26 <shachaf> johnw: Work it out.
23:12:42 <shachaf> It's a good exercise, what join . join vs. join . fmap join really do.
23:12:48 <shachaf> (Or maybe it's not. I don't really know.)
23:12:51 <johnw> ok, let me work that out
23:13:01 <shachaf> (Anyway I need to go for a bit now.)
23:13:07 <ski> shachaf : `join . fmap join' correspons to `T . (T . T)' and `join . join' to `(T . T) . T'
23:13:08 <johnw> k, later shachaf
23:13:08 <Fuuzetsu> @pl f (a, b) = f a b
23:13:09 <lambdabot> f = fix ((`ap` snd) . (. fst))
23:13:19 <shachaf> ski: Yep.
23:13:35 <shachaf> ski: So I guess I got it backwards.
23:13:51 <shachaf> You want to *introduce* fmaps. Weird.
23:14:41 <kennycason> ski: yes, the examples i showed showed that you didn't have to (i.e. you had to maintain order, which i thought was very strange, i much prefer the syntax you showed me
23:14:49 <johnw> you introduce them to make it right-associative, because then you don't need to eat up stack to represent a series of left-associative binds?
23:14:56 <kennycason> ski: i have already did that through out my code, just not pushed to github yet
23:15:40 <ski> kennycason : ok, i see
23:15:48 <kennycason> ski: i'm also watching many videos/reading many examples/ and trying to code algorithms i'm already familiar with in haskell to ramp up fast, so i really appreciate your advice
23:16:25 <kennycason> ski: i feel like i'm learning programming again haha i'm just glad i'm proficient in math or this would be tougher
23:16:48 <ski> kennycason : fyi, `listProduct a b = zipWith (*) a b' could be simplified to just `listProduct = zipWith (*)' (though you may then want a type signature on it, if you keep it, unless you disable DMR)
23:17:22 <ski> kennycason : perhaps you haven't learned Functional Programming before ?
23:18:02 <ski> kennycason : btw, did you decide to swap argument order of `calculateNodeError' or not ?
23:18:31 <ski> .. and `adjustNodesWeight' as well, would be useful
23:18:56 <ski> note that `\error -> sumAdjustWeight (learningRate childLayer) (value node) error' can be "eta-contracted" to just `sumAdjustWeight (learningRate childLayer) (value node)'
23:19:04 <kennycason> ski: i've dabbled fairly shallowly in it, i understand the theory of it, drive for it and did lisp for about a semester before. but never really pushed myself in it before
23:19:29 <kennycason> ski: i have not decided yet as i haven't visited that part of you suggestion yet. i'll let you know when i get there. :)
23:20:05 <ski> kennycason : note that `length (...) == 0' is better written as `null (...)'
23:20:36 <kennycason> nice
23:20:37 <johnw> hlint will make a lot of those kinds of suggestions
23:20:50 <ski> kennycason : also, are you sure you want to carry around the possibility for `EmptyLayer' *everywhere* you can pass and return a `Layer' ?
23:21:03 <Fuuzetsu> note that if you're doing ‘length xs == 0’, you probably should be using pattern matching somewhere instead
23:21:16 <kennycason> ski: no i don't plan on using it
23:21:17 <ski> (hint, this is a bit like manually reintroducing a `null', so you can enjoy getting null pointer exceptions)
23:22:07 <kennycason> ski: my java version each layer actually has a parent/child layer, which the last layer's child layer is null, so i introduced it, but i won't need it in my haskell version
23:22:29 <ski> kennycason : if you need it in *some* places, then i suggest using the type `Maybe Layer' then (`Nothing' corresponds to `EmptyLayer'), or maybe define `data PerhapsLayer = ALayer Layer | EmptyLayer' and use `PerhapsLayer'
23:23:14 <kennycason> oh nice
23:23:24 <kennycason> haskell's typing is very interesting
23:25:17 <ski> kennycason : it's usually not a very good idea to use record syntax together with multiple data constructors in the data type, unless each record field occurs in each constructor
23:25:31 <kennycason> ski: also keep in mind that some functions like calculatenodeValues are not fully implemented as this is a learn-as-i-go project
23:25:48 <kennycason> ski: what do you mean by that? sorry i don't follow
23:25:56 <ski> kennycason : because, if you e.g. try `nodes EmptyLayer', it'll typecheck, but error out at run-time -- which you generally want to avoid
23:26:29 <kennycason> ski: because it doesn't have the fields correct?
23:26:43 <ski> (yea, i figured `calculateNodeValues' wasn't done, since it currently returned `layer' in both branches)
23:26:44 <kennycason> i.e. EmptyLayer doesn't have nodes,errors,teacherSignals, etc
23:26:46 <ski> kennycason : yep
23:26:54 <kennycason> gotcha
23:28:16 <ski> if you need the possibility for absence of a layer / empty layer in some places, it's better to use `Maybe' or an explicit custom wrapper like `PossibleLayer', so that you have to explicitly unwrap it (and explicitly handle the empty/absence case), before e.g. using the field selectors on it (in case it was actually a proper layer)
23:28:27 <kennycason> ski: i pushed some updates i've made so far to Layer
23:28:50 <kennycason> ski: ah, that makes sense
23:30:34 <ski> kennycason : also so that in the cases where you don't expect/want to allow empty, you just use `Layer', so that you know it can't happen (and so that you don't needlessly have to write code handling the impossible empty case)
23:31:34 <ski>   weights = (map ...)
23:31:46 <ski> and earlier
23:31:54 <ski>   errors = (map ...)
23:32:02 <ski> you don't need to outer brackets there
23:34:34 <johnw> is there an option to tell cabal to *not* install any packages from the Net?
23:34:47 <johnw> that is, if I don't have a dependency, I want an error
23:35:30 <shachaf> You can give a dependency of "installed", which is similar.
23:37:10 <shachaf> johnw: It's not exactly "eating up stack", but yes, something along those lines.
23:37:27 <shachaf> ((a ++ b) ++ c) vs. (a ++ (b ++ c)) is a good analogy.
23:37:32 <johnw> shachaf: ok, that actually makes a lot of sense
23:37:41 <shachaf> In fact it's more than an analogy, when you use the (w,) monad.
23:37:44 <shachaf> It's waht happens.
23:39:26 <shachaf> > runWriter $ tell "a" >> (tell "b" >> tell "c")
23:39:28 <lambdabot>   ((),"abc")
23:39:32 <shachaf> > runWriter $ (tell "a" >> tell "b") >> tell "c"
23:39:34 <lambdabot>   ((),"abc")
23:40:00 <shachaf> The first one is right-associative, and generally what you want for monoids like [a].
23:40:13 <shachaf> (Guess which fixity >> has?)
23:40:25 <arkeet> the wrong one :(
23:40:50 <shachaf> Anyway, Codensity of Writer turns lists into DLists.
23:41:13 <johnw> really!
23:41:25 <shachaf> In fact Codensity is a pretty direct generalization of the idea of DLists.
23:41:56 <johnw> ok, you are definitely helping on the intuition front :)
23:42:22 <johnw> I will reread edwardk's posts now with that thought in mind
23:42:24 <shachaf> Really? I'd think you would have to go through this yourself before it starts making any sense.
23:42:36 <johnw> until now, it hadn't started making any sense :)
23:42:52 <shachaf> I wish we had a Magma type in lambdabot.
23:43:06 <johnw> i had back-burner'd Codensity because I wasn't done with grokking (Co)Yoneda
23:43:28 <shachaf> Cale: Maybe you could add one? data Evil a = Zero | One a | Two (Evil a) (Evil a); instance Monoid (Evil a) where mempty = Zero; mappend = Two
23:43:33 <shachaf> Possibly with better constructor names.
23:44:20 <arkeet> FreePointedMagma
23:45:31 <shachaf> > (("a" <>) <> ("b" <>) <> ("c" <>)) [] -- wait, why is this working?
23:45:32 <lambdabot>   "abc"
23:45:56 <arkeet> > :t \f g x -> (f <> g) x
23:45:57 <shachaf> Oh, it's the Monoid b => Monoid (a -> b) instance.
23:45:58 <lambdabot>   <hint>:1:1: parse error on input `:'
23:46:01 <shachaf> How misleading.
23:46:03 <arkeet> :t \f g x -> (f <> g) x
23:46:04 <lambdabot> Monoid t => (t1 -> t) -> (t1 -> t) -> t1 -> t
23:46:08 <arkeet> yeah
23:46:28 <shachaf> I should start giving good explanations with a misleading thing like that in the middle.
23:46:35 <shachaf> > let liftD x = (x <>); lowerD x = x mempty in lowerD $ (liftD "a" <> liftD "b")
23:46:36 <lambdabot>   "ab"
23:46:43 <arkeet> haha
23:47:09 <arkeet> > let liftD x = Endo (x <>); lowerD x = appEndo x mempty in lowerD $ (liftD "a" <> liftD "b")
23:47:10 <lambdabot>   "ab"
23:47:32 <shachaf> johnw: What is there left to understand in (Co)Yoneda?
23:48:02 <shachaf> > let liftD x = Endo (x <>); lowerD x = appEndo x mempty in lowerD $ ((liftD "a" <> liftD "b") <> liftD "c") -- turns into ("a" ++ ("b" ++ "c"))
23:48:03 <lambdabot>   "abc"
23:48:33 <arkeet> > x <> y
23:48:34 <lambdabot>   x <> y
23:48:42 <arkeet> > x <> y <> z
23:48:43 <lambdabot>   x <> y <> z
23:48:48 <arkeet> > (x <> y) <> z
23:48:49 <lambdabot>   (x <> y) <> z
23:49:02 <arkeet> > let liftD x = Endo (x <>); lowerD x = appEndo x mempty in lowerD $ ((liftD a <> liftD b) <> liftD c)
23:49:04 <lambdabot>   a <> b <> c <> mempty
23:49:08 <shachaf> arkeet++
23:49:35 <shachaf> > let liftC x = Codensity (x >>=); lowerC x = runCodensity x return in runWriter . lowerC $ ((liftC (tell "a") >> liftC (tell "b")) >> liftC (tell "c"))
23:49:36 <lambdabot>   Not in scope: data constructor `Codensity'Not in scope: `runCodensity'
23:49:37 <lambdabot>  Per...
23:49:39 <shachaf> Bah.
23:50:18 <johnw> shachaf: just need to understand more cases of its use, and how it comes up.  I _think_ that the central idea is that knowing anything about an object is the same as knowing the set of morphisms relating to that object.  If I'm wrong about that, then I have even more drawing board to go back to...
23:50:27 <shachaf> > let liftC x = cont (x >>=); lowerC x = runCont x return in runWriter . lowerC $ ((liftC (tell "a") >> liftC (tell "b")) >> liftC (tell "c")) -- poor individual's codensity
23:50:29 <lambdabot>   ((),"abc")
23:51:07 <shachaf> johnw: Are you talking about the types Yoneda/CoYoneda in Haskell, or the Yoneda lemma in general?
23:51:31 <shachaf> As usual, I recommend understanding the former on their own, in a Haskell context. They are not very complicated.
23:51:45 <johnw> the lemma in general, but at the moment I'm mostly interested in how it relates to the types in Haskell
23:51:51 * arkeet only understands them from the math side
23:52:00 <johnw> forall b. (a -> b) -> f b ≅ f a
23:52:05 <shachaf> I recommend CoYoneda.
23:52:12 <shachaf> It's much more intuitive for me.
23:52:17 <arkeet> not for me :(
23:52:18 <adinapoli> small digression, last night I dreamt about monoids, do you think it's normal? :D
23:52:38 <arkeet> adinapoli: no, but I do think they're easy.
23:52:52 <arkeet> I'll stop.
23:53:29 <johnw> the most concrete thing I've worked out so far is using yoneda to CPS-transform any function, so a -> b goes to a -> (b -> c) -> c
23:53:51 <shachaf> I will explain why CoYoneda is intuitive.
23:53:55 <johnw> please do!
23:54:13 <adinapoli> arkeet, sure they are, but I think it didn't help the fact I was dreaming about their properties from the CT point of view. Furthermore I was watching a video which was mocking Node.js, so basically I dreamt about Monoids and JS, which is creepy
23:54:24 <johnw> adinapoli: I dreamt about semigroups a couple weeks ago, I'm catching up to you
23:54:49 <shachaf> Imagine you have some functor, say a tree. Say a strict tree or something. Such that mapping over it is very expensive.
23:54:51 <adinapoli> johnw, well you beat me hands down then :D
23:55:13 <shachaf> Now, you have some specific tree, and you want to map a bunch of functions over it.
23:55:24 <shachaf> Say you want to fmap (*2), an then fmap (+1), and so on.
23:55:40 <shachaf> Each of these operations is cheap, but the mapping is expensive. So you want to minimize the number of times you use fmap.
23:55:47 <shachaf> Makes sense?
23:55:51 <johnw> yes, very much so
23:56:00 <johnw> I think I know where you're headed, even
23:56:04 <johnw> please go on
23:56:13 <shachaf> The obvious solution is: Instead of fmap (+1) . fmap (*2), you fmap ((+1) . (*2))
23:56:27 <shachaf> Those are the same thing for any functor.
23:56:38 <shachaf> (Functor law #2)
23:56:58 <arkeet> and instead of id, you fmap id.
23:57:05 <johnw> and such fusion does not happen automatically
23:57:06 <shachaf> No, id comes later.
23:57:11 <arkeet> :(
23:57:14 <shachaf> Now, what if you want to map a whole bunch of operations?
23:57:35 <shachaf> It makes sense to keep two things: A tree and a function.
23:57:41 <shachaf> So you might have (Tree Int, Int -> Int)
23:57:53 <shachaf> Then you can keep composing things onto that function, and only fmap it once, at the very end.
23:58:02 <johnw> right
23:58:14 <shachaf> You can even change the type. If you want to map chr, you just compose it onto the function, so you get (Tree Int, Int -> Char)
23:58:42 <shachaf> All reasonable things to do.
23:58:51 <shachaf> Now, we can even make this thing its own data type:
23:59:05 <shachaf> data FTree a = FTree (Tree Int) (Int -> a)
23:59:12 <shachaf> This is just like the tuple except it's its own data type.
23:59:19 <shachaf> Exercise: Write the Functor instance.
23:59:58 <johnw> fmap f (FTree tr g) = FTree tr (f . g)
