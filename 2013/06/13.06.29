00:07:11 <erisco> if you have a multi-parameter type constraint, such as (Foo a b), then how do you refer to a type that is a member of that class?
00:07:28 <erisco> with single parameter, Foo a, you can just use 'a', if I know correctly
00:10:07 <johnw> do you mean, a multi-parameter type class?
00:10:21 <johnw> class Foo a b where blah :: a -> b
00:10:44 <OffsetGoose_> johnw: how do those work?
00:10:56 <johnw> instance Foo Int String where blah = show
00:11:59 <OffsetGoose_> Oh :D  So basically infinity^2 different instances you can make. (sort-of :)
00:12:13 <erisco> yes but write a function that accepts a type constrained to Foo Int String
00:12:25 <johnw> OffsetGoose_: you can use functional dependencies the constrain the possibilities
00:12:36 <johnw> class Foo a b | a -> b where blah :: a -> b
00:12:45 <johnw> this means that the choice of a constrains the choice of b
00:12:52 <erisco> OffsetGoose_, no, still infinity. you can alternate which set you choose from
00:12:59 <johnw> so, instance Foo Int String will prevent any other instance of Foo Int x
00:13:17 <erisco> I don't want that
00:13:50 <OffsetGoose_> Interesting... Thanks!
00:14:08 <erisco> say I am defining a function (not in the type class), called bar.      bar :: (Foo a b) => foo -> x      say that is my siganture. how do I actually constrain 'foo' to (Foo a b) ?
00:14:28 <johnw> well, you have to use a and b
00:14:32 <erisco> I don't even get what the constraint (Foo a b) would mean, since 'a' and 'b' on their own doesn't mean anything about the constraint
00:14:38 <johnw> bar :: Foo a b => a -> b
00:14:55 <johnw> or: bar :: Foo a b => (a -> b) -> x
00:15:19 <erisco> johnw, but I can't make use of any relation between 'a' and 'b' if I just have a -> b
00:15:26 <johnw> you can use the function "blah"
00:15:29 <erisco> johnw, this leads me to ambiguous types
00:15:53 <johnw> right, only the functions in the type class express any relation between that a and b
00:16:11 <johnw> which is why the type class exists :)
00:16:30 <johnw> other than the function "blah", you can make no use of a Foo a b constraint
00:16:48 <erisco> okay.  if I have a single-param type class, Foo a, then  (Foo a) => a -> a   means that any 'a' I have satisfies Foo. Right?  with two parameters,   (Foo a b) => a -> b -> (a, b)   say, neither 'a' nor 'b' satisfy Foo a b
00:17:08 <johnw> the pair satisfies the constraint
00:17:11 <erisco> how??
00:17:13 <johnw> a and b together
00:17:28 <erisco> that is what I am asking :P how do I say "a and b" together in my signature?
00:17:36 <johnw> Foo a b says that you have two types, and that you can use the functions of the type class to do something with values of these types
00:17:56 <johnw> class Foo a b where blah :: a -> b
00:18:22 <erisco> okay either I am confused or I am not getting through
00:19:30 <johnw> say you had: foo :: Foo a b => a -> (b -> x) -> x
00:19:33 <augur> whats a singleton GADT and why is it called such a thing
00:19:33 <erisco> johnw, write   blah :: a -> b  instead so that the return type is some type that satisfies Foo
00:19:34 <johnw> foo x y = y (blah x)
00:20:03 <erisco> what?
00:21:01 <johnw> foo gets to use blah to make use of a b.  I have an a.  blah lets me take a -> b.  I can then pass that b to another function that returns some x, and then return that x
00:21:13 <johnw> but maybe we should step back
00:21:20 <johnw> what is the point of confusion at the moment?
00:21:45 <erisco> I don't know how else to state it
00:21:51 <augur> erisco: "if you have a multi-parameter type constraint, such as (Foo a b), then how do you refer to a type that is a member of that class?"
00:21:53 <augur> what do you mean by this
00:22:01 <augur> what do you mean "refer to a type ..."?
00:22:08 <erisco> in the same way with  Foo a,  a satisfies Foo
00:22:14 <erisco> syntatically
00:22:17 <erisco> well, semantically
00:22:27 <Lethalman> hi, I've run dph-spectral-quicksort +RTS -N6 from dph-examples which is supposed to be executed in parallel, but it uses only one CPU
00:22:30 <augur> erisco: Foo a means a is a Foo
00:22:34 <Lethalman> do you think I should report a bug?
00:22:35 <erisco> yes, I know
00:22:37 <augur> Foo a b means a and b are Foo-related
00:22:55 <augur> lets say Bar a b instead
00:22:57 <erisco> yes, but can I not have a single type which is Foo a b related?
00:23:10 <johnw> ah
00:23:11 <augur> erisco: that doesnt make any sense
00:23:14 <johnw> I think I see the confusion here
00:23:20 <augur> "Foo a b" is a statement
00:23:25 <augur> "a and b are Foo-related"
00:23:29 <johnw> erisco is thinking of instances like deriving a type from the type class
00:23:50 <erisco> well don't be too sure about what I am thinking :P
00:23:52 <johnw> Foo a does not mean that a *is* a Foo
00:24:07 <augur> erisco: secretly, a type class is just a fancy record type
00:24:08 <johnw> it means that there is a set of functions, in the type class Foo, which can be applied to a
00:24:24 <augur> erisco: so if you have like... class Foo a where foo :: thing
00:24:39 <augur> this is secretly just   data Foo a = Foo { foo :: thing }
00:24:55 <augur> class Bar a b where bar :: otherThing
00:25:05 <augur> is just   data Bar a b = Bar { bar :: otherThing }
00:25:25 <johnw> augur: I'm not sure that's clarifying things...
00:25:37 <augur> to say Bar a b just means somewhere you've gotten some data of the specified sort
00:25:39 <yesthisisuser> http://paste.tryhaskell.org/6498975874711289856
00:25:46 <erisco> okay...
00:25:47 <augur> theres nothing sort of magical about what these things do
00:26:03 <augur> so a constraint like   "Bar a b => c"
00:26:38 <augur> just means somewhere around there's some data, as specified by the Bar class, that involves a and b (or maybe only one or neither who knows)
00:27:30 <augur> if you think of these things as predicates, Foo a is a predicate, and the instance declaration is the "evidence" that a satisfies the Foo predicate
00:27:46 <augur> while for Bar a b, its just evidence that the two of them, a and b, _together_ satisfy the predicate
00:28:45 <johnw> augur: that's a good way to put it
00:28:54 <erisco> class Foo a b where blah :: a -> b  ;  qux :: (Foo a b) => a -> Int -> b  ; qux a 0 = blah a   ;  qux a n = qux a (n-1)
00:29:24 <erisco> is that not an ambiguous type error?
00:29:30 <johnw> try it!
00:29:35 <augur> erisco: why would it be ambiguous?
00:29:44 <erisco> I'm about to
00:29:48 <johnw> looks good to me
00:29:58 <johnw> erisco: see also http://stackoverflow.com/questions/8122109/difference-between-oop-interfaces-and-fp-type-classes
00:30:23 <augur> erisco: another way to think of type classes is as algebraic structures
00:30:31 <augur> erisco: so you know how in mathematics you have definitions like
00:30:52 <erisco> hang on I have to work out why I am getting an ambiguous type error
00:31:03 <erisco> I thought that example would be analogous but I guess it isn't
00:31:16 <augur> a set A is a monoid if there is an element e :: A and an operation m :: A -> A -> A such that ...
00:31:18 <johnw> can you pastie us the error?
00:31:49 <augur> or, in haskelly terms,   class Monoid a where { mempty :: a ; mappend :: a -> a -> a }
00:31:58 <erisco> I've understood 5% of what has been said so far, so, I'm not sure passing off the burden of finding the problem will be beneficial
00:32:40 <augur> erisco: i think its important for you to get clear on what type classes "are" before worrying about a particular type error
00:33:23 <erisco> please explain in OOP or C or assembly or something roughly familiar please :)
00:33:44 <erisco> the issue with the explanations thus far, and I do appreciate them, is that I don't know Haskell jargon
00:33:58 <erisco> and I understand things in terms of implementation mainly
00:35:02 <johnw> well, the problem there is
00:35:08 <johnw> Haskell's type classes don't really fit those models
00:35:15 <johnw> so trying to explain them in those terms will just further confuse the matter
00:35:25 <erisco> then I am between a rock and a hard place
00:35:29 <johnw> the stack overflow link I pasted above is an excellent summary of the differences
00:35:37 <johnw> just avoid multi-parameter type classes for now
00:35:49 <erisco> I can cross compare between the example and my code and try to pinpoint where the difference is. I thought conceptually they were the same thing, but evidently not so
00:35:50 <johnw> they are not needed or used very often
00:35:52 <erisco> that is a starting point
00:37:04 <augur> erisco: there is nothing siimlar in OOP/C
00:37:41 <johnw> also, type classes can be abused.  they aren't the best solution for everything people use them for.  often, a simple record type, or some higher-order functions, can solve the same problem in a more straightforward manner
00:37:44 <augur> but there are rough analogies, erisco
00:37:55 <Lethalman> here there's "Please enter the text below to prove you're not a machine.", but I don't see any particular text: http://hackage.haskell.org/trac/ghc/register
00:37:59 <erisco> augur, like I said, in terms of implementation. I wasn't expecting an exact match
00:38:01 <augur> i think SPJ has given the analogy that a type class is like a dispatch table, only not quite
00:38:20 <erisco> but rather "if you were to emulate Haskell type classes in language X then you'd get closest by doing blah blah and blah"
00:38:35 <augur> erisco: you'd get closest by using records, like i said
00:38:40 <erisco> and I'm not necessarily expecting the same static checking
00:38:41 <Hannibal_Smith> I used to view typeclass as an interface that you cam implement
00:38:44 <Lethalman> ah ok now I see somehow
00:38:51 <Hannibal_Smith> *can
00:39:15 <erisco> Hannibal_Smith, that is my working model of them but evidently somewhat misguided
00:39:46 <augur> erisco: my_fun(Foo<A> f_a, A a) { ... f_a.foo(...) ... }
00:40:21 <augur> other_fun(Bar<A,B> b_a_b, A a, B b) { ... b_a_b.bar(...) ... }
00:40:51 <erisco> right, so b_a_b is of take Bar<A,B>. that is what I am missing
00:41:08 <erisco> I think. like I said I don't know where my error is actually coming from, so, I'll get to that first
00:41:16 <augur> erisco: thats what i said before about the records
00:41:25 <augur> class Bar a b where bar :: thing
00:41:28 <augur> is just secretly
00:41:35 <augur> data Bar a b = Bar { bar :: thing }
00:41:52 <augur> and the instances are just definitions
00:41:57 <erisco> it gets boxed?
00:42:01 <augur> no
00:42:02 <erisco> I'm confused by that
00:42:05 <augur> dont say boxed
00:42:09 <augur> instance Bar Int String where bar = blah
00:42:11 <augur> just becomes
00:42:32 <augur> BarIntString :: Bar Int String
00:42:43 <augur> BarIntString = Bar blah
00:42:59 <augur> so when you then have   Bar a b => ...
00:43:05 <augur> secretly this is really Bar a b -> ...
00:43:07 <Philippa_> erisco: it ends up in something a little like a C++ vtable, which we call a "dictionary" (or if we're thinking of it at a higher level, we call it the evidence for that instance)
00:43:26 <augur> and the haskell compiler finds the right value of Bar a b to use for you
00:44:02 <augur> erisco: but there's nothing mysterious to what multi-param type classes mean. it just means theres a type class with _two_ params (or more) not just one
00:44:20 <johnw> Philippa_: except that with a vtable, the first parameter of every function is the type class parameter, whereas type classes don't have that requirement.  Also, multi-parameter type classes I don't think fit that description very well
00:44:58 <Philippa_> johnw: that's because you're reading more into "a little like a C++ vtable" than was intended, or than I suspect was received by erisco for that matter
00:45:12 <johnw> augur's description is the most demystifying, I agree, but might be hard to digest
00:45:28 <johnw> Philippa_: quite possible, since I was a C++ compiler writer :)
00:46:33 <Philippa_> as a rule, when someone says "a little like..." they are /pointedly/ hand-waving :p
00:46:42 <johnw> :)
00:47:24 <Philippa_> and yeah, it helps to have "dictionary" as the name for "the concrete thing behind an instance" if you're going to explain the dictionary-passing translation
00:47:44 <augur> erisco: the error you're getting probably just has to do with Haskell being unable to figure out what the right instance to use is
00:48:25 <johnw> I usually think of it as a bit closer to: template <class A, class B> { typedef first_type A; typedef second_type B; B blah(const &&A); }
00:48:47 <Philippa_> I avoid thinking in C++
00:48:56 <johnw> well, actually I never think of it that way
00:48:59 <johnw> figure of speech
00:49:08 <johnw> "If I had to use C++ as my language of exposition..."
00:49:30 <Philippa_> "...I would be found dead shortly after"?
00:49:34 <johnw> haha
00:50:03 <johnw> erisco: have we helped at all?
00:50:10 <erisco> johnw, no
00:50:26 <erisco> sorry :P I need to find why the error is happening. I can't say or assume anything else until then
00:50:33 <erisco> that is my actual problem
00:50:34 <johnw> fair enough
00:50:51 <johnw> if you want to resolve it on your own, I respect that; we're also here to help explain the error if that would assist you
00:51:27 <erisco> well if I am clueless in 10-15 mins then I'll pastebin it. I was curious about an iterator pattern in Haskell so I decided to give it a whirl
00:51:35 <erisco> seems to bring up interesting questions for me
00:51:55 <augur> erisco: show us the code!
00:51:56 <johnw> good for you
00:52:06 <pharaun> ++ its a good way to learn :)
00:52:09 <johnw> enduring the pain of confusing type errors is a very good way to build stronger Haskell muscles
00:52:38 <pharaun> the first time i saw some of those complicated type errors it made my head hurt but after a while you get better at it :)
00:52:43 <johnw> it may be inefficient, but you'll be certain to recognize it again when it happens in other contexts
00:52:55 <johnw> pharaun: yeah, in the beginning type errors were soooo painful
00:53:10 <augur> erisco: code code code!
00:53:19 <erisco> augur, patience ;)
00:53:26 <augur> erisco: im impatient
00:53:27 <johnw> i drained away more hours than I care to think about.  but even though those hours weren't spent getting anything useful done, I think it led to inner changes that couldn't be rushed
00:53:43 <startling> the trick is to read each part carefully
00:53:53 <pharaun> johnw: yes they were >_< however now days i can usually.... make an attempt to decoding them and i've started to get a bit of a better guts feeling on how pieces fits together
00:54:21 <startling> other languages' errors tend to be mostly line noise, it seems, so we get in the habit of ignoring most of the error and scan until we see something we think we understand.
00:54:56 <johnw> startling: very true
00:55:13 <johnw> Haskell's errors have a great signal/noise ratio most of the time
00:55:13 <pharaun> johnw: now days its *starting* to feel like the type system in some case is guiding me in the right path if its a well done one :)
00:55:46 <johnw> yes, it's like a conversation with a code reviewer sitting next to you, who keeps insisting that you be clear and correct about what you mean
00:56:00 <startling> right, GHC's errors tell you exactly what it got, what it was expecting, and how those are different.
00:56:26 <johnw> "What?  You can't do that, because you told me that was impossible right over here."
00:56:29 <pharaun> tho once you get typeclass involved or some of the fancier types features it can get a bit strange again but yeah :)
00:56:46 <johnw> I find that the worst errors came with monad transformer stacks
00:56:59 <johnw> very regularly I get 4 errors, but only the 4th has any meaning
00:57:08 <pharaun> there's a reason why i have kinda avoided most of them, i shouldn't, i'm starting to use them more
00:57:19 <pharaun> because i'm starting to feel more comfortable but man some of those things can be strange
00:58:15 <johnw> the majority of the code I write at the moment is in a transformer
00:58:35 <johnw> either ResourceT, or Handler, or Sh, or ReaderT...
00:59:31 <pharaun> don't know if its right path but i try to keep things as simple as possible before starting to reach for some of the ... stronger abstraction
00:59:52 <osa1> can anyone recommend me a simple timing function to run some simple benchmarks?
01:00:05 <pharaun> well not timing but i can recommend you
01:00:18 <pharaun> criterion
01:00:24 <johnw> osa1: getCurrentTime has very fine precision
01:00:40 <pharaun> yeah you can do that too ^ but if you are going to benchmark i would suggest criterion
01:00:52 <osa1> ok let me see criterion
01:01:08 <johnw> criterion is far superior, but if you just want to identify whether a particular part of your code is slow, it's not nearly as simple
01:01:08 <pharaun> it just does lots of the stats/sampling/benchmarking activity for you
01:01:10 <pharaun> so its useful
01:01:12 <pharaun> but yah
01:01:16 <osa1> ok criterion is probably too complex for my needs
01:01:27 <pharaun> it really depends on what you want to do here, are you trying to identify if something is slow ?
01:02:24 <osa1> pharaun: no, I'll make an improvement in my code and I want to make sure it's really an `improvement`
01:02:59 <pharaun> osa1: then for those you probably *do* want benchmarking like criterion but *shrugs* for simple cases the getCurrentTime could work
01:03:41 <erisco> oh wow was that obtuse
01:03:53 <pharaun> ?
01:04:17 <erisco> I didn't use both type variables in one of the functions in my type class... the error caused was on the usage site of a different function of that same class
01:04:22 <johnw> obtusity ftw!
01:05:39 <angelsl> > (-1)**(1/3)
01:05:40 <lambdabot>   NaN
01:05:43 <angelsl> :(
01:09:16 <FreeFull> > (-1)**(1/3) :: Complex Double
01:09:17 <lambdabot>   0.5000000000000001 :+ (-0.8660254037844386)
01:09:24 <FreeFull> angelsl: ^
01:09:34 <angelsl> ..whut
01:09:49 <angelsl> > (-1)**3
01:09:50 <lambdabot>   -1.0
01:09:59 <angelsl> > ((-1)**3)**(1/3)
01:10:00 <lambdabot>   NaN
01:10:09 <angelsl> > ((-1)**3)**(1/3) :: Complex Double
01:10:10 <lambdabot>   0.5000000000000003 :+ (-0.8660254037844385)
01:10:13 <angelsl> whoop
01:10:23 <FreeFull> (-1)**(1/3)  is a NaN when using doubles, but works when you use complex numbers
01:10:25 <applicative> > (-1)**(1/2) :: Complex Double
01:10:26 <lambdabot>   6.123031769111886e-17 :+ (-1.0)
01:10:37 <angelsl> -1 = 0.5 - 0.8660254037844385i
01:10:40 <angelsl> i didn't know that :l
01:10:44 <applicative> oh I don't understand **
01:10:56 <applicative> > (-1)^(1/2) :: Complex Double
01:10:56 <lambdabot>   No instance for (GHC.Num.Num b0) arising from the literal `1'
01:10:57 <lambdabot>  The type var...
01:11:03 <angelsl> FreeFull: the problem is the cube root of -1 is not complex
01:11:14 <FreeFull> angelsl: It is
01:11:28 <FreeFull> Oh, it isn't
01:11:32 <applicative> one of them is
01:11:57 <angelsl> FreeFull: i just demonstrated (-1)^3 = -1 lol
01:11:59 <FreeFull> Seems there are three
01:12:35 <FreeFull> > (0.5000000000000001 :+ (-0.8660254037844386))**3
01:12:36 <lambdabot>   (-1.0) :+ (-1.2246063538223773e-16)
01:13:03 <FreeFull> See, that's  -1 (discounting floating point errors)
01:13:27 <FreeFull> https://www.wolframalpha.com/input/?i=cube+root+of+-1
01:13:47 <applicative> it's a little confusing; when there are several roots or solutions of a polynomial, some of them are 'the same', if I remember
01:14:32 <FreeFull> In the complex plane, there are three cube roots for any non-zero number
01:14:42 <applicative> ah wolfam gives all three
01:15:22 <angelsl> so how do i get the real root of -1?
01:15:54 <FreeFull> :t (^)
01:15:55 <lambdabot> (Integral b, Num a) => a -> b -> a
01:15:57 <FreeFull> :t (^^)
01:15:58 <lambdabot> (Fractional a, Integral b) => a -> b -> a
01:16:02 <FreeFull> :t (**)
01:16:03 <lambdabot> Floating a => a -> a -> a
01:16:14 <FreeFull> angelsl: Let's try using rationals and see what happens
01:16:15 <applicative> (-1)^(1/2) :: Complex Rational
01:16:29 <applicative> > (-1)^(1/2) :: Complex Rational
01:16:29 <angelsl> > (-1)^(1/3) :: Complex Rational
01:16:30 <lambdabot>   No instance for (GHC.Float.RealFloat
01:16:30 <lambdabot>                     (GHC.Real.Ratio GH...
01:16:30 <lambdabot>   No instance for (GHC.Float.RealFloat
01:16:30 <lambdabot>                     (GHC.Real.Ratio GH...
01:16:40 <FreeFull> > (-1)**(1/3) :: Complex Rational
01:16:42 <lambdabot>   No instance for (GHC.Float.RealFloat
01:16:43 <lambdabot>                     (GHC.Real.Ratio GH...
01:16:47 <applicative> curses! this Num hierarchy is too hard for me
01:16:48 <FreeFull> > (-1)**(1/3) :: Rational
01:16:49 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
01:16:49 <lambdabot>    arising from a us...
01:16:55 <FreeFull> Oh, right
01:16:58 <FreeFull> not /
01:17:01 <haasn> Ration doesn't have exponentiation with fractional exponents
01:17:04 <FreeFull> > (-1)**(1 % 3) :: Complex Rational
01:17:04 <haasn> Rational*
01:17:04 <lambdabot>   Couldn't match expected type `Data.Complex.Complex
01:17:05 <lambdabot>                         ...
01:17:11 <FreeFull> > (-1)**(1 % 3) :: Rational
01:17:12 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
01:17:12 <lambdabot>    arising from a us...
01:17:17 <haasn> think about 2**0.5 :: Rational
01:17:21 <haasn> that's impossible
01:17:26 <FreeFull> Seems Rationals aren't floating
01:17:31 <haasn> of course not
01:17:45 <FreeFull> Yeah, I see
01:17:46 <applicative> I think the operations are defined for Floating only in Data.Complex
01:17:50 <FreeFull> > (-1)**(1 % 3) :: CReal
01:17:51 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
01:17:51 <lambdabot>              with ac...
01:17:55 <FreeFull> > (-1)**(1/3) :: CReal
01:17:55 <lambdabot>   *Exception: log of negative number
01:18:03 <applicative> FreeFull: hah, I was about to do that
01:18:20 <applicative> > (-1)**(1/3) :: Complex CReal
01:18:21 <lambdabot>   0.5 :+ 0.8660254037844386467637231707529361834714
01:18:28 <applicative> > (-1)**(1/2) :: Complex CReal
01:18:29 <lambdabot>   0.0 :+ 1.0
01:18:29 <FreeFull> Mmmm, I love complex cereal
01:18:32 <applicative> bingo!
01:19:05 <FreeFull> Wolfram Alpha gives exact solutions somehow
01:19:23 <applicative> the one above is exact
01:19:29 <angelsl> W|A has Mathematica as a backend
01:19:32 <angelsl> what can you expect :p
01:19:37 <applicative> it refuses to print more than 40 digits or something
01:19:43 <applicative> I mean, CReal does
01:19:57 <haasn> it doesn't ‘refuse’, that's just the default Show instance
01:20:14 <applicative> I wan't a show instance that just keeps going!
01:20:26 <applicative> want it, even
01:21:11 <haasn> “instance Show CReal where show = showCReal 40” -- essentially
01:22:22 <applicative> I noticed the author of CReal has a new version somewhere. It wasn't much different though. It could do with a few optimizations, I think, not that that's what it's about exactly.
01:22:46 <johnw> applicative: are you referring to "numbers"?
01:22:54 <Gracenotes> iirc it can't quite be done as an infinite list
01:23:02 <applicative> the numbers package?
01:23:05 <johnw> yes
01:23:42 <applicative> The CReal module is from a published paper, not the author of the package, who is I think, augussts
01:23:52 <haasn> showCReal is not lazy
01:23:58 <Gracenotes> for an arbitrary fixed precision it can get you any number of digits. i.e. show recomputers the number every time.
01:24:02 <haasn> you don't get digits as they pop up, iirc
01:24:44 <Gracenotes> *recomputes. this is still pretty impressive, as a lot of other libraries require you to specify your precision upfront.
01:25:05 <Gracenotes> it's also pretty inefficient :p
01:25:46 <applicative> johnw: it's the first paper listed here. It was a little disappointing, sort of academic recycling -- and I could have golfed much shorter ;) http://www.manchester.ac.uk/research/david.r.lester/publications
01:26:02 <applicative> golfed it, moreover
01:27:12 <applicative> bah, it's behind a paywall
01:27:30 <tomboy64> @pretty
01:28:20 <applicative> ah here it is http://hodapple.com/files/1-s2.0-S0890540112000727-main.pdf
01:28:27 <applicative> god knows who hodapple are
01:28:57 <applicative> it's a recent paper but they 'import Char' and 'import Real'
01:29:19 <Gracenotes> heh
01:29:58 <Gracenotes> they say they use GHC in Fedora, but not which version
01:30:47 <OffsetGoose_> Does anybody here know anything about xmonad?
01:30:54 <haasn> OffsetGoose_: I use it, as do a few others
01:31:04 <haasn> OffsetGoose_: there's also #xmonad
01:31:05 <applicative> oh, i remember, they do mention some optimizations that could be made in the paper, alluding to devices used in other languages.  I wonder if they could be used in the Haskell CReal
01:31:23 <OffsetGoose_> Excellent, thanks haasn :-D
01:58:43 <erisco> if you are definition function foo, and within foo you call function bar, if you explicitly define the signature to bar, do the type variables in the signature of 'foo' the same as you give to 'bar'?
01:59:19 <mauke> example?
01:59:45 <erisco> foo :: a -> b     foo = bar :: a -> b
01:59:52 <erisco> are the 'a' and 'b' referring to the same thing?
02:00:23 <mauke> no
02:00:28 <erisco> damn
02:00:48 <mauke> {-# LANGUAGE ScopedTypeVariables #-}
02:00:53 <erisco> :D
02:00:53 <mauke> foo :: forall a b. a -> b
02:00:58 <mauke> foo = bar :: a -> b
02:01:05 <erisco> why the forall?
02:01:13 <erisco> does that simply scope them?
02:04:08 <johnw> you can omit the forall in that example and it means the same thing
02:04:27 <shachaf> No you can't...
02:04:32 <johnw> really?
02:04:36 <johnw> I stand corrected
02:04:37 <shachaf> Truly.
02:05:24 <shachaf> mauke: Hmm, I wonder whether you can detect ScopedTypeVariables.
02:05:52 <arkeet> erisco: correct.
02:06:11 <erisco> how does this 'forall' work in with constraints?   (Foo a) => forall a. a -> a    ?
02:06:25 <erisco> (I'm having difficulties with errors and can't seem to sort this out)
02:06:33 <arkeet> forall goes to the left
02:06:39 <arkeet> forall a. Foo a => a -> a
02:06:49 <arkeet> becuase you want 'a' inside the scope.
02:06:51 <arkeet> everywhere
02:06:56 <sipa> detect as in "my program doesn't compile without them" or "have different runtime behaviour depending on whether scopedtypevariables was enabled"
02:07:05 <johnw> shachaf: trying it with sample code, deleting the forall doesn't seem to change anything; what exactly is its effect here?
02:07:22 <shachaf> johnw: Its effect is scoping the type variables.
02:07:34 <shachaf> Read the GHC user's guide section on ScopedTypeVariables for an explanation.
02:07:35 <shachaf> mauke: Yes! You can detect ScopedTypeVariables.
02:07:41 <erisco> and you have to list *all* of the type variables you then use? seems to be what I have to do, else I get "not in scope" error
02:07:42 <johnw> without it, shouldn't I think have a type error saying that a /~ a0?
02:07:43 <arkeet> chances are if your program compiles without it, you don't need it.
02:07:44 <mauke> sipa: the latter
02:07:56 <johnw> shachaf: OK
02:08:04 <arkeet> erisco: yes.
02:08:15 <arkeet> fortunately STV isn't necessary most of the time.
02:08:17 <shachaf> mauke: class Show a => Foo a where { blah :: a -> String; blah _ = let z :: [a]; z = [] in show z }
02:08:21 <shachaf> mauke: instance Foo Char
02:08:24 <shachaf> mauke: blah 'a'
02:08:35 <erisco> I also found this article (http://www.haskellforall.com/2012/05/scrap-your-type-classes.html) combined with what augur was saying, what is the real point of classes then?
02:08:44 <johnw> Ah: "The type variables bound by a forall scope over the entire definition of the accompanying value declaration."
02:08:49 <erisco> this article makes classes sound like a useless layer
02:08:50 <mauke> > let { foo :: a -> (a, a); foo x = (x, y :: a) where { y = x } } in foo ()
02:08:51 <lambdabot>   Couldn't match expected type `a1' with actual type `a'
02:08:51 <lambdabot>    `a1' is a rigid t...
02:09:41 <shachaf> I think you have to use my trick (class declaration with default method) to make it work.
02:10:18 <augur> erisco: the point of type classes is to allow you to use things implicitly
02:10:21 <shachaf> That's one of the only places where types are scoped in H98. And ScopedTypeVariables changes the scope so that they're scoped inside the definition, not just in the signature.
02:10:34 <arkeet> type classes essentially give you implicit function arguments.
02:10:37 <augur> erisco: and to have haskell figure out what you mean when necessary
02:10:59 <shachaf> (Of course the Show part isn't necessary here.)
02:11:19 <arkeet> that are inferred by the type checker.
02:11:22 <erisco> so... syntactical shortcuts... this seems roughly equivalent to implementing an interface versus type conversion in an OOP language
02:11:29 <augur> erisco: also im not sure what this guy is on about
02:11:35 <augur> since thats exactly what Haskell does
02:12:10 <erisco> augur, it seems to be about ditching use of classes altogether. Haskell doesn't do this
02:12:25 <johnw> it's about not abusing type classes when plain records are just as capable
02:12:30 <augur> erisco: haskell translates under the hood
02:13:36 <arkeet> typeclasses let you do cool things like get the compiler to calculate stuff for you.
02:13:38 <johnw> for example, if you see a type class Foo a, full of methods whose first argument is always "a", that can be a sign that you're not gaining anything from using a type class except additional complexity
02:13:42 <arkeet> especially with stuff like type families.
02:14:13 <erisco> okay... so if we don't use type classes, how do we solve... erm, what I'll call the "reentry" problem?
02:14:24 <johnw> arkeet: you also don't need to use a type class to have a type family
02:14:35 <augur> arkeet: which calculations were you thinking of?
02:14:39 <arkeet> augur: idk
02:14:40 <erisco> that is, if I start with type A, convert to type B so that I can use algorithm X on my data, how do I get back to type A?
02:14:56 <augur> erisco: you cant always do that
02:14:57 <erisco> this only works if the conversion is lossless, which easily isn't the case
02:14:59 <arkeet> johnw: but you do need them to get the compiler to infer things.
02:15:10 <mauke> erisco: with a conversion function
02:15:18 <erisco> whereas if you have a type class that describes what algorithm X requires, you don't have this problem
02:15:22 <Gracenotes> it's a bad idea to make a typeclass called Animal, and a typeclass called Dog, where every Dog is an Animal, .... etc. Typeclasses model computational structure very well, which is what classes *should* be used for in OOP honestly.
02:15:27 <mauke> erisco: false dichotomy
02:15:34 <Gracenotes> enough of this real-world hierarchy nonsense
02:15:40 <Gracenotes> burn the strawman!etc.
02:15:45 <augur> erisco: thats not.. true at all
02:15:49 <augur> if i understand what you're saying
02:15:53 <erisco> okay, a) conversion function doesn't work from B -> A as I said, and b) I am not making a dichotomy
02:16:00 <mauke> yes, you are
02:16:35 <erisco> no, I'm not. I'm saying using conversion functions, you hit a snag, whereas using a type class you do not. I have not excluded other options
02:16:42 <mauke> yes, you have
02:17:00 <erisco> then it isn't a false dichotomy!
02:17:01 <mauke> the choice is not between "convert A to B" and "use type classes"
02:17:02 <augur> erisco: thats not true at all
02:17:04 <Gracenotes> what is this snag?
02:17:07 <augur> you dont hit any snags
02:17:14 <augur> no more than with type classes
02:17:24 <augur> since type classes _ARE_ data types
02:17:34 <augur> the only difference being that haskell finds the values for you
02:18:00 <erisco> I don't know why this isn't clear
02:18:36 <augur> maybe its because you dont know how to express the ideas very well!
02:18:45 <augur> alternatively, you're wrong and dont realize it
02:18:46 <erisco> that is clear :P
02:18:48 <mauke> erisco: because you're wrong
02:18:55 <astor`> I'm looking for a relational join, like [(a,b)] -> [(a,c)] -> [(a, Maybe b, Maybe c)]
02:18:55 <mauke> hmm, no
02:18:58 <mauke> you're not even wrong
02:19:34 <Gracenotes> an outer join
02:19:55 <mauke> :t lookup
02:19:55 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
02:20:28 <johnw> astor`: unionWith, or mergeWithKeys
02:21:45 <johnw> erisco: I think some unlearning of the way types and interfaces work in OOP might be helpful
02:22:09 <erisco> okay, so say I have   data A = A Int String   and   data B = More Char B | End    and   x :: (B -> B) -> B -> B
02:22:55 <erisco> I can, say, convert A to B by taking the String in A and converting it to a B. This is a lossy conversion, of course, since I don't have the Int anymore
02:23:05 <mauke> ok
02:23:29 <erisco> then when I pass the first arg to x, B -> B, say that I want to use that Int as part of the calculation
02:23:35 * hackagebot yarr 1.3.2 - Yet another array library  http://hackage.haskell.org/package/yarr-1.3.2 (RomanLeventov)
02:23:53 <mauke> ok
02:23:55 <astor`> johnw: thanks for the pointers! I'm looking for a streaming version though.
02:23:56 <erisco> I suppose I've gimped my example because you can just have Int -> B -> B
02:24:17 <augur> erisco: how does this relate to type classes
02:24:20 <mauke> \(A i s) -> calculate i (x (convert s))
02:24:27 <Gracenotes> astor`: are the two input lists guaranteed to be sorted?
02:24:33 <Gracenotes> that might be important...
02:24:34 <astor`> Gracenotes: yes
02:24:42 <johnw> heh, was just going to ask that
02:25:12 <erisco> augur, because instead of requiring B, I can use any concrete type, so I can bring along all the information I want
02:25:26 <augur> erisco: what
02:25:30 <arkeet> ^
02:25:33 <astor`> I'm basically reimplementing the 'comm' and 'join' shell commands.
02:25:58 <augur> erisco: that sentence makes no sense, either with or without type classes as a topic of discussion
02:26:05 <Gracenotes> I can't think of any standard libraries off the top of my head, but it seems similar to a generic recursively defined 'merge' function
02:26:06 <mauke> erisco: x :: (B -> B) -> B -> B won't magically get more flexible just because you've defined a class elsewhere
02:26:20 <johnw> astor`: if they are sorted, I think a simple foldr should do it
02:26:24 <Gracenotes> which is usually pretty compact
02:26:40 <astor`> ok. thanks.  will do my foldl'
02:26:41 <erisco> class MyClass a where x :: (a -> a) -> a -> a
02:26:44 <Gracenotes> e.g. http://stackoverflow.com/questions/3938438/merging-two-lists-in-haskell
02:27:27 <Gracenotes> hm, no, wrong link
02:27:36 <Gracenotes> something that requires Ord
02:28:05 <augur> erisco: except thats not the same?
02:28:20 <augur> x :: (B -> B) -> B -> B is fixed for B
02:28:24 <augur> it must use be, by definition
02:28:33 <erisco> yes
02:28:34 <augur> x' :: MyClass a => (a -> a) -> a -> a
02:28:37 <augur> is not fixed for anything
02:28:42 <erisco> right
02:28:47 <augur> it just requires that a be an instance of MyClass
02:28:52 <namoamitabuddha> In the abstraction of language, does Haskell have side-effects?
02:28:52 <augur> these are not equivalent things
02:28:52 <erisco> precisely
02:28:57 <augur> erisco: precisely what?
02:29:01 <erisco> exactly my point?
02:29:07 <Gracenotes> I don't quite see where the Int comes into it, anyway...
02:29:07 <augur> what point?
02:29:29 <erisco> if you have an algorithm, in this case 'x', then instead of restricting it to one type, you can abstract it to many
02:29:44 <namoamitabuddha> I mean, is there any side-effect operations in the language?
02:29:45 <augur> erisco: a) not always, b) so what?
02:29:52 <augur> what does that have to do with type classes
02:29:55 <erisco> you don't have lossy conversions
02:29:58 <Gracenotes> Haskell has pure-nature, buddha
02:30:02 <astor`> Is there a nice type for "a or b or 'a and b'"  (Maybe a, Maybe b) has a third option which is neither a nor b.
02:30:13 <ktosiek> namoamitabuddha: any examples of what you mean from other languages?
02:30:20 <augur> erisco: what
02:30:52 <augur> astor`: I dont think there's any existing type for that
02:30:53 <erisco> I don't think I can make it any more clear
02:30:54 <Gracenotes> astor`: you can define one :)
02:31:12 <mauke> erisco: you don't have a point you could make more clear
02:31:16 <augur> erisco: i dont think you know what "it" is that you're trying to make clear
02:31:22 <namoamitabuddha> ktosiek: I'm trying to understand how System.IO or something about IORef works.
02:31:31 <johnw> astor`: These
02:31:33 <augur> astor`: data BetterEither a b = Left a | Right b | Both a b
02:31:33 <erisco> I do know what "it" is. maybe it doesn't apply to Haskell but I am not seeing where the issue goes away
02:31:34 <augur> :D
02:31:45 <augur> erisco: what frelling issue
02:31:47 <johnw> astor`: there is a "these" package even
02:31:47 <augur> there is no issue
02:31:53 <Cale> namoamitabuddha: Expression evaluation in Haskell is pure, the execution of IO actions can have any effect whatsoever.
02:32:16 <erisco> I've just tried to explain the issue. saying "what" doesn't help me clarify what is confusing
02:32:23 <Cale> namoamitabuddha: In a compiled Haskell program, the IO action named 'main' is executed, which will cause things to happen.
02:32:43 <johnw> erisco: then may I recommend taking some time to think about it, and coming back when you have something more Haskell-relevant?
02:32:47 <mauke> erisco: you haven't explained anything
02:32:48 <ktosiek> namoamitabuddha: all the operations on IORefs are inside IO monad, so you can think of an Haskell program as building a huge "IO action" and then handing it to runtime environment to run
02:32:57 * shachaf notes that people say that do { x <- y; z } "executes" y, and that the RTS "executes" main, and that those aren't exactly the same thing.
02:32:58 <astor`> johnw: brilliant! These is exactly it.
02:33:01 <Cale> namoamitabuddha: But the process of reducing expressions to values has no visible effects
02:33:01 <mauke> erisco: you wrote two pieces of code and said "so there"
02:33:07 <erisco> johnw, type classes and data types are not haskell relevant?
02:33:20 <erisco> mauke, I did more than that
02:33:22 <augur> erisco: what youve said is just some random words strung together
02:33:22 <johnw> erisco: the "it" you are talking about may not be
02:33:31 <astor`> Gracenotes: Yes I know I can define one, but I like to reuse existing vocabulary.
02:33:33 <augur> erisco: that doesnt make the result meaningful
02:33:48 <mauke> erisco: like what?
02:33:58 <augur> erisco: you need to explicitly state the point you're trying to make first. noone has any idea what that is, right now
02:33:59 <mauke> so far all I'm getting is "if I change the code, it works differently"
02:34:06 <Gracenotes> is this the issue of needing late binding to achieve procedural abstraction? ...I mean... ... yeah, sure.
02:34:19 <erisco> okay then I guess I need to answer it myself then. thanks anyways
02:34:25 <johnw> erisco: sure thing!
02:34:59 <augur> erisco: i think you need to figure out a better way to express "it" so that people know what you're talking about
02:35:06 <augur> because noone here has any clue what you're even saying
02:35:15 <erisco> augur, then the best I can think of is some Haskell code
02:35:24 <erisco> but I need to sleep so maybe another time
02:35:31 <augur> erisco: try using english first
02:35:33 <namoamitabuddha> I'm considering where permits side-effects. At a glance of Haskell, at least, axiomatically, there seems no side-effect.
02:35:36 <johnw> augur: please do not be rude
02:36:20 <Gracenotes> erisco: for a vocabulary about these matters, I'd recommend http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf
02:36:27 <Gracenotes> if you haven't read it already
02:36:28 <augur> johnw: im not being rude, im stating the fact of the matter. he's failed to make it clear what he's even trying to get at.
02:36:46 <mauke> johnw: was the "rude" re: "using english"?
02:36:52 <johnw> erisco has tried to explain his idea many times, rather patiently too.  We just lack a common vocabulary right now
02:36:54 <Gracenotes> it's not the most up-to-date bit of literature, but it's pretty good, and clearly written
02:37:14 <johnw> mauke: "using english" could be taken more than one way
02:37:30 <mauke> is that a yes or a no?
02:37:32 <augur> mauke: it was clearly meant as "instead of haskell"
02:37:38 <augur> er, johnw ^
02:37:42 <johnw> augur: ah, in that case I misread, my apologies
02:37:56 <arkeet> english is a common vocabulary I think.
02:37:59 <erisco> augur, mauke I apologize for not being clear. I new to Haskell and thus not familiar with the language or the jargon. The issue I speak of I run into with programs from other languages, and that same issue may not exist in Haskell as I am seeing it
02:38:14 <arkeet> haskell is not like many other languages.
02:38:16 * shachaf thinks e.g. "maybe its because you dont know how to express the ideas very well!" was much ruder. But whatever.
02:38:23 <augur> erisco: this is why im saying express the issue in english
02:38:28 <augur> because you know english
02:38:30 <erisco> augur, mauke so if I am still having a problem tomorrow, I think the best description will be some Haskell code that demonstrates the two things I am comparing. You can directly poke holes in that
02:38:41 <arkeet> or maybe describe how the issue occurs in some real code possibly in some other language
02:38:57 <augur> erisco: you might be comparing apples and oranges
02:38:58 <Gracenotes> the thing I linked explores a basic link between functional languages and OOP
02:39:04 <augur> and from the looks of what youve tried to show us, you are doing just that
02:39:08 <erisco> why not in Haskell? I am fairly sure I can translate the problem to Haskell and, if I can't, I'll have answered my own question :P
02:39:23 <augur> erisco: because you dont know haskell?
02:39:34 <johnw> erisco: in fact, commented Haskell, so we can read both Haskell and english, would be best
02:39:39 <augur> i mean, you might write some code, but how do you know it means what you think it means?
02:39:44 <arkeet> I would rather just see english.
02:39:44 <Gracenotes> also, a lot of us here know imperative languages, so no harm in exploring Haskell using those languages in some cases...
02:39:56 <arkeet> anyone agree with my suggestion?
02:40:02 <arkeet> (about other languages)
02:40:11 <johnw> arkeet: that could be quite illuminating
02:40:28 <augur> arkeet: it could be problematic, because he's trying to ask something about type classes
02:40:46 <johnw> erisco: if you could show us your "it" in a different language, that might actually help
02:40:49 <erisco> okay enough meta talk :P I'll get back to you on the issue if it persists
02:40:51 <augur> and given that type classes are fairly unique to haskell, any other language he uses will naturally fail to express the issue even remotely well
02:41:01 <arkeet> well, if he's new to haskell, I don't think he's in a position to ask something about whether a specific feature solves some problem.
02:41:04 <arkeet> or something.
02:41:15 <arkeet> er, not quite what I said. but whatever.
02:41:50 <arkeet> well, that is what I said, but not what I meant.
02:41:56 <johnw> :)
02:42:13 <arkeet> or maybe I meant "what I meant was not quite what I said."
02:42:20 <augur> hm i wonder why shachaf left
02:42:31 <arkeet> he went to bed, hopefully!
02:42:39 <augur> hes still in blah, tho
02:42:44 <arkeet> I know.
02:42:51 <mauke> maybe he's sleeping there
02:43:05 <augur> i know he doesnt like me. maybe he left because he had to see my username in messages!
02:43:34 <augur> shachafs a silly one
02:44:03 <mauke> I used to not like you but I forgot why and now I'm neutral towards you
02:44:03 <arkeet> anyway, it seems reasonable that if erisco is asking about some issue he experiences with other languages, he should give an example in one of these other languages. oh he left.
02:44:19 <arkeet> also, the answer is lens.
02:44:33 <augur> mauke: lol
02:44:42 <augur> shachaf seems to not like linguists
02:44:55 <mauke> maybe he's watching us through logs
02:45:23 <arkeet> I wonder if we'll see some cool new library/paradigm in 2013 like lens was in 2012.
02:45:59 <LordBrain> I am trying out leksah, first time, and it puts up a dialog on first run which asks for folders to sources of cabal packages. I do not understand what it is goign to to, is it going to expand every tarball in my .cabal folder? because if so, I need to make room on this hard drive first...
02:46:02 <johnw> arkeet: I would like to see FRP becoming more advanced
02:46:10 <augur> arkeet: maybe we'll see agda take off!
02:46:11 <augur> :D
02:46:11 <augur> :x
02:46:13 <arkeet> I'm all for frp.
02:46:20 <johnw> plus, I bet all the constraint kinds stuff will create some cool new libraries
02:46:23 <augur> or less likely, maybe we'll see epigram 2 come out!
02:46:31 <johnw> idris looks pretty nice
02:46:39 <Gracenotes> 2013 is basically half over now
02:46:50 <arkeet> Gracenotes: lens didn't exist until july 2012
02:46:53 <arkeet> or maybe june?
02:47:09 <arkeet> 0.1 was july 25.
02:47:15 <augur> johnw: blegh, idris. :(
02:47:20 <arkeet> well, certainly there were ideas in place well before it.
02:47:29 <Gracenotes> well, that's fair, I can't handle rewriting my entire codebase to incorporate the latest trends more than twice a year.
02:47:32 <augur> no unicode, no editor
02:47:43 <Gracenotes> (this is a lie; I do not have a codebase)
02:47:48 <augur> i could deal with no unicode
02:47:54 <augur> but no editor is a deal breaker
02:47:54 <arkeet> Gracenotes: well, then it should be trivial to rewrite it!
02:48:16 <arkeet> I suppose that's the lie; I'm sure you could handle trivially rewriting nothing.
02:48:34 <ion> Vaporware is the easiest to refactor.
02:51:50 <Gracenotes> The RSS reader looks pretty exciting.
02:52:09 <astor`> I hope FPComplete starts a '2 minute response-time space-leak removal service' for professional haskell programmers.  That would solve the #1 issue with Haskell adoption :-)
02:52:29 <johnw> astor`: I'd be happy to provide you that service personally, if I get to name the cost
02:52:51 <luite> johnw: but it's free if you don't fix it in 2 minutes!
02:52:58 <johnw> hmm
02:53:07 <johnw> i thought he just wanted me to start looking at it in 2 minutes...
02:53:11 <arkeet> haha
02:53:25 <astor`> johnw: name your price, in btc.
02:53:45 <Gracenotes> in hundredths of btc, rather
02:53:53 <arkeet> bitcents.
02:54:05 <johnw> one meelyun bitpence
02:54:14 <arkeet> bitpence sounds cooler.
02:54:22 <sipa> millibits!
02:54:37 <arkeet> I love when people quote their internet speeds in millibits per second.
02:54:56 <johnw> arkeet: can sometimes feel that way, for sure
02:55:11 <shachaf> arkeet: I guess they actually mean bits per millisecond.
02:55:31 <shachaf> (OK, they actually mean per microsecond.)
02:55:42 <arkeet> yes
02:56:14 <arkeet> picobits per attosecond.
02:56:25 <arkeet> if I remember my SI prefixes correctly.
02:56:36 <johnw> i think femto is what you want
02:56:45 <arkeet> I thought femto was 10^-15?
02:56:47 <sipa> you can use more original units for information amounts
02:56:47 <arkeet> and atto was -18
02:56:56 <quchen> We already have attoparsec, there's no need for other silly units :-D
02:57:08 <johnw> yes
02:57:15 <arkeet> femtofortnight?
02:57:17 <sipa> like a bit is an exponential unit (log2(number_of_possibilities))
02:57:26 <tomboy64> shachaf: there is no such thing as microsecond, it's millisecond.
02:57:29 <johnw> yoctoparsec
02:57:34 <shachaf> sipa: Just like an octave!
02:57:44 <shachaf> tomboy64: ?
02:57:45 <sipa> there are other exponential units, like neper or bell
02:57:46 <arkeet> nats are better than bits.
02:57:52 <tomboy64> ^^
02:57:57 <shachaf> sipa: Or a cent!
02:58:02 <sipa> shachaf: ha!
02:58:12 <shachaf> sipa: 1200 cents = 1 octave (= 1 bit)
02:58:30 <arkeet> shachaf: maybe in weird log-is-linear land
02:58:31 <shachaf> So it's a factor of the 1200th root of 2, I guess.
02:58:31 <Gracenotes> http://www.haskell.org/haskellwiki/Physical_units
02:59:36 <sipa> shachaf: soooo... my bandwidth is about 90 gigacent/s
03:00:41 <arkeet> nats are better if you're a physicist.
03:00:48 <arkeet> or, well, they're just better.
03:01:00 <johnw> this discussion has officially become -blah material :)
03:01:08 <arkeet> that's what we were talking about in -blah.
03:01:28 <sipa> oops, wrong channel!
03:15:54 <sipa> @src Applicative Maybe
03:15:54 <lambdabot> Source not found. Abort, Retry, Panic?
03:16:29 <sipa> @src <|>
03:16:29 <lambdabot> Source not found. You type like i drive.
03:16:44 <mauke> instance Applicative Maybe where pure = return; (<*>) = ap
03:17:17 <augur> mauke: :|
03:17:19 <sipa> thanks, maukebot
03:17:45 <augur> instance Applicative Maybe where pure = Just ; Nothing <*> _ = Nothing ; Just x <*> f = f x
03:17:54 <augur> no thats not right
03:17:56 <augur> thats bind
03:17:58 <augur> derp
03:18:19 <augur> Just f <*> Just x = Just (f x) ; _ <*> _ = Nothing
03:18:53 <shachaf> ap is a pretty good definition.
03:19:07 <augur> it is, but it expects you know what ap is doing!
03:19:15 <shachaf> @src ap
03:19:16 <lambdabot> ap = liftM2 id
03:19:18 <mauke> I,I what's ap?
03:19:26 <augur> xD
03:19:30 <augur> so useful
03:34:57 <Aetherspawn> Typeclasses are close enough to C++ virtuals and C#/Java interfaces mashed together that you could probably emulate them in many languages ?
03:35:15 <Aetherspawn> (in regards the conversation a few screens up)
03:35:36 <shachaf> Type classes are quite far from those things.
03:36:09 <haasn> typeclasses can do something things you'd use C# interfaces for, but they can also do so much more
03:36:13 <haasn> some things*
03:36:45 <haasn> canonical example would be return :: Monad m => a -> m a
03:37:22 <sipa> @djinn (b -> c) -> (a -> Maybe b) -> (a -> Maybe c)
03:37:22 <lambdabot> f a b c =
03:37:23 <lambdabot>     case b c of
03:37:23 <lambdabot>     Nothing -> Nothing
03:37:23 <lambdabot>     Just d -> Just (a d)
03:37:43 <shachaf> Monad is a pretty complicated example, what with being a constructor class and all.
03:37:45 <sipa> @pl (b -> c) -> (a -> Maybe b) -> (a -> Maybe c)
03:37:45 <lambdabot> (line 1, column 6):
03:37:45 <lambdabot> unexpected '>'
03:37:45 <lambdabot> expecting operator
03:37:50 <shachaf> Monoid is an easier example.
03:38:33 <haasn> oh, yeah
03:38:41 <haasn> mempty :: Monoid m => m -- Aetherspawn
03:39:20 <shachaf> so easy
03:39:46 <Gracenotes> hm... is there a good writeup on software engineering aspects of typeclasses?
03:39:49 <mikeplus64> how 'fast' should a function be if you foreign import it with 'unsafe'?
03:40:06 <mauke> about 5
03:40:08 <haasn> mikeplus64: about 20 miles per hour
03:40:09 <shachaf> 'pretty' hth
03:40:12 <Gracenotes> not compared to modules, or interfaces, or whatever, but just for ground-up programming (plus ones in the standard library)
03:40:29 <mikeplus64> haasn: excellent
03:40:36 <shachaf> @google ghc foreign import unsafe overhead
03:40:37 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2012-February/099753.html
03:40:37 <lambdabot> Title: [Haskell-cafe] FFI: Overhead of foreign unsafe imports
03:43:27 <osa1_> hGetChar reads unicode chars by default, right?
03:43:44 <shachaf> Is there any other kind?
03:44:23 <osa1_> .. I mean utf8 encoding
03:44:24 <Aetherspawn> Hmm, ok. Thanks
03:44:51 <shachaf> I don't know. At least over here it'll read UTF-8 by default.
03:45:06 <osa1_> I'm looking at documentation right now but it only says "reads character", it doesn't mention encoding
03:45:08 <shachaf> Maybe e.g. Windows does something different? I hear they don't like UTF-8 much there.
03:45:18 <shachaf> Encoding isn't a property of hGetChar.
03:45:27 <osa1_> it's a property of handle?
03:45:28 <shachaf> It's a property of the Handle.
03:45:31 <shachaf> Yes.
03:45:31 <osa1_> ahh
03:45:35 <shachaf> See hSetEncoding etc.
03:45:54 <haasn> as far as I'm aware the primitive IO functions base stuff on your system's locale
03:46:07 <shachaf> That sounds reasonable to me.
03:46:47 <haasn> Not sure what it translates to under windows either
03:49:57 <zvrba> hmm
03:50:09 <zvrba> i'm using eclispe for LYAH
03:50:19 <zvrba> now, everything works fine except interactive programs
03:50:37 <zvrba> putStrLn doesn't seem to flush the buffer so stuff is printed out only after the program has exited
03:50:44 <zvrba> any hints on how to enable autoflush on stdout?
03:50:50 <zvrba> i.e., disable buffering?
03:51:08 <quchen> stdout flushes on newline by default.
03:51:24 <FreeFull> Hmm, doesn't getLine flush stdout too?
03:51:26 <shachaf> You can disable buffering with hSetBuffering.
03:52:19 <luite> if the output is redirected, it will switch from line buffering to block buffering
03:52:24 <luite> if it's not a terminal
03:52:38 <luite> perhaps that happens with eclipse
03:54:36 <zvrba> quchen: perhasp, if it finds out it is attached to some "terminal". something I suspect isn't the case when run from within Eclipse's console
03:54:59 <zvrba> so what is the name of stdout to give to hSetBuffering ?
03:55:12 <luite> stdout
03:55:18 <quchen> `hSetBuffering stdout NoBuffering` or something
03:55:23 <zvrba> I guess I have to import System.IO ?
03:55:25 <luite> yep
03:55:28 <zvrba> ok, let me try..
03:55:35 <luite> but you already needed to import that for hSetBuffering :)
03:55:53 <quchen> That may not be a good idea to have in production code though, buffering exists for a (performance) reason after all. Give it a "DEBUG" comment or something.
03:57:26 <zvrba> ok, that worked.
03:58:36 <zvrba> it works also with line buffering
03:59:13 <zvrba> bah
03:59:15 <quchen> zvrba: You can check whether stdout is a terminal and write something along the lines of http://paste.tryhaskell.org/2188770335392792576
03:59:58 <zvrba> the hardest part of getting started with a new language is getting acquainted with standard libraries that make it possible to make s* done. like this example
04:00:03 <quchen> (But that'll set no buffering if you're piping stdout to another program, but you get the idea - make sure to use the right buffering in each case)
04:00:30 <zvrba> this won't ever be production code ;) [just code samples from LYAH]
04:00:49 <zvrba> plus, I doubt that hIsTerminalDevice returns something sane on Win32 :-)
04:01:24 <zvrba> what's the difference between System.IO and GHC.IO.Handle ?
04:02:01 <haasn> zvrba: I bet it returns FileNotFound
04:02:48 <quchen> zvrba: The GHC.* stuff is GHC specific, whereas System.* is (mostly) all of Haskell.
04:03:06 <zvrba> wow, it actually returns correct values (cmd.exe vs eclipse)
04:03:10 <zvrba> just tested :)
04:03:19 <quchen> If you're using GHC.*, it's safe to assume that no other compiler can run it.
04:03:35 <zvrba> are there any substantial differences between Haskell98 and Haskell 2010 _
04:03:38 <quchen> (GHC itself defines its core functions there, and then refers to them from other modules.)
04:04:26 <quchen> Not really. 2010 is a pretty small change, there's pattern guards added and n+k patterns removed
04:04:38 <zvrba> what's pattern guard?
04:04:54 <quchen> And the FFI
04:05:08 <quchen> And new module names, e.g. Bool is now Data.Bool.
04:05:23 <quchen> http://www.haskell.org/haskellwiki/Pattern_guard
04:07:12 <zvrba> ok
04:07:36 <zvrba> does there exist a nice standard library quickref?
04:09:01 <quchen> I don't think so.
04:10:01 <quchen> There's the GHC haddock in your .cabal directory
04:10:19 <quchen> ~/.cabal/share/doc/index.html
04:10:28 <zvrba> ok, there's a nice cabal package browser in eclipse
04:11:16 <zvrba> except it lists *packages* instead of *modules*
04:11:18 <zvrba> BAH!
04:12:16 <arkeet> lol
04:12:33 <quchen> Haha.
04:12:45 <quchen> Good luck finding Map in "containers" if you don't know it's in there.
04:16:07 <zvrba> quchen: exctly.
04:16:25 <zvrba> ok, I could have guessed for Map. but for System.IO, I have no idea.
04:17:19 <zvrba> is HAskell platform delivered with module source code?
04:17:32 <zvrba> I could think of making some additions to Win32.Process ...
04:20:49 <zvrba> anyway. bbl.
04:20:53 <haasn> you should be able to find the relevant package on hackage
04:20:59 <haasn> and contribute towards it there
04:33:37 * hackagebot smallcheck 1.0.3 - A property-based testing library  http://hackage.haskell.org/package/smallcheck-1.0.3 (RomanCheplyaka)
04:38:56 <S_J> in quickcheck a function inc :: Int -> Int can be quickchecked without doign anything more than inc x == x + 1 right? odnt have to define a generator(is that what you do with arbitrary?)?
04:39:09 <S_J> I found a quickcheck library for C but it seems limited.
04:40:11 <haasn> you have to define generators for custom types, but Int already has one
04:40:41 <haasn> where ‘define generators’ means ‘write an Arbitrary instance’
04:42:10 <S_J> quickcheck isnt that much code is it?
04:42:25 <haasn> probably not
04:43:08 <S_J> I mean basically just a few functions to run the tests and they take a generator and a condition as input, and maybe a struct for storin the result
04:46:19 <Eelis> johnw: could one use gitlib-s3 to push/pull commits between a regular git repository stored on disk, and a git repository stored in an object store?
04:54:25 <klrr> morning haskellers
04:54:26 <klrr> morning haskellers
04:56:45 <neolax> klrr: evening haskeller :P
04:57:12 <klrr> i got problem with the logic in my program, im trying to prototype a simple blog which only takes an imput via a form and produces a static html file that the web server serve, everything compiles and everything but when i reqest that file i get "File doesnt exist", BUT it exist on my filesystem, any ideas how to solve this? (it's built with scotty/blaze-html/pandoc) https://gist.github.com/klrr/5890869
05:00:17 <S_J> I am implementing quickcheck in C so I hope it is still OK if I ask here? Anyone here good with random number generation? I heard the C rand isnt that great and if you do modular arithmetic on it it disturbs the uniformity. I assume the quality of quickcheck  is very highly correlated to the quality of the random generator or would a decent generator be good enough?
05:01:13 <S_J> Is there some sort of name issue with quickcheck?
05:11:11 <S_J> can i clal my lib quickcheck or cquickcheck?
05:11:48 <S_J> why quickcheck anyway? why not propertycheck(ok, doesnt sound as good)
05:13:38 * hackagebot spy 0.8 - A compact file system watcher for Mac OS X, Linux and Windows  http://hackage.haskell.org/package/spy-0.8 (StefanSaasen)
05:22:33 <Andrea_> how delete (2, _) from list:  [(1, [0]), (2, [1,2]), (3, [2]), (4, [1])] ? with deleteBy ?
05:23:04 <Andrea_> how works deleteBy ?
05:23:22 <haasn> (maybe you want to be using a Map here?)
05:24:00 <haasn> anyhow, using something like filter (\(a,_) -> a /= 2)
05:24:41 <Andrea_> ok, that's possible, i thoght there was an easy way
05:25:00 <haasn> oh
05:25:13 <haasn> deleteBy (comparing fst) (2, []) -- should work too
05:25:28 <Andrea_> the type   is [ (Int, [ Int] ) ]
05:25:29 <shachaf> Except it's (==) `on` fst, not comparing.
05:25:38 <haasn> oh, yeah
05:25:49 <Andrea_> only compare the first element
05:26:04 <shachaf> Er, that's not that great either.
05:26:11 <shachaf> You have to make up an snd value for the tuple.
05:26:19 <haasn> yeah
05:26:20 <shachaf> I guess you said that.
05:26:34 <haasn> what's the lensy way to do this?
05:27:14 <shachaf> I wonder whether there's a lensy thing to traverse [(a,b)] with a as the index and b as the value.
05:27:49 <haasn> probably via some list<->map prism?
05:28:22 <Andrea_> how works deleteBy ?
05:28:32 <chrisdone> @src deleteBy
05:28:32 <lambdabot> deleteBy eq x []        = []
05:28:32 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
05:28:32 <kappabot> deleteBy eq x []        = []
05:28:32 <kappabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
05:28:41 <chrisdone> kappabot: shaddap
05:29:41 <haasn> wait, didn't we have Data.Map.Lens
05:29:42 <Andrea_> deleteBy (\(x,y) -> x==2) [(1,[0]),(2,[1,2]),(3,[2]),(4,[1])]
05:29:47 <Andrea_> > deleteBy (\(x,y) -> x==2) [(1,[0]),(2,[1,2]),(3,[2]),(4,[1])]
05:29:47 <shachaf> > let foo :: IndexedLens i (i,a) (i,b) a b; foo f (x,y) = (,) x <$> indexed f x y in [(1, [0]), (2, [1,2]), (3, [2]), (4, [1])] ^@.. traverse . foo . Lens.indices (/= 2)
05:29:48 <lambdabot>   Couldn't match expected type `(a0, t0) -> GHC.Types.Bool'
05:29:48 <lambdabot>              with...
05:29:48 <lambdabot>   can't find file: L.hs
05:29:48 <kappabot>   Couldn't match expected type `(t0, t1) -> GHC.Types.Bool'
05:29:49 <kappabot>              with...
05:29:49 <kappabot>   can't find file: L.hs
05:29:57 <Andrea_> :(
05:30:09 <shachaf> Hmm, it worked in /msg a moment ago.
05:30:19 <haasn> shachaf: that was the L.hs error
05:30:28 <shachaf> Oh.
05:30:33 <shachaf> kappabot: @run let foo :: IndexedLens i (i,a) (i,b) a b; foo f (x,y) = (,) x <$> indexed f x y in [(1, [0]), (2, [1,2]), (3, [2]), (4, [1])] ^@.. traverse . foo . Lens.indices (/= 2)
05:30:35 <kappabot>   [(1,[0]),(3,[2]),(4,[1])]
05:30:46 <shachaf> haasn: Anyway, you don't need to make this indexed thing it for the whole list. It's enough to make it for the tuple.
05:31:09 <shachaf> (I hope I haven't broken any laws here. It's 05:30.)
05:31:31 <haasn> doesn't look like it to me
05:31:37 <shachaf> Does foo exist in lens?
05:32:22 <haasn> doesn't seem like it
05:32:35 <haasn> the tuple lenses are all indexed by their position in the tuple
05:33:49 <Andrea_> :t deleteBy
05:33:49 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
05:33:50 <kappabot> Not in scope: `deleteBy'
05:33:53 <shachaf> @ask edwardk Does this exist in lens? It seems useful for e.g. doing an indexed traversal of an [(a,b)] list: foo :: IndexedLens i (i,a) (i,b) a b; foo f (x,y) = (,) x <$> indexed f x y
05:33:53 <lambdabot> Consider it noted.
05:33:53 <kappabot> Consider it noted.
05:34:01 <shachaf> Oops.
05:34:04 <shachaf> kappabot: @part #haskell
05:34:21 <Andrea_> why a -> a -> Bool , why <a> twice ?
05:34:40 <haasn> Andrea_: it just allows you to specify your own ‘equality’ to use instead of (==)
05:34:41 <Hafydd> Using {-# LANGUAGE LambdaCase -#}:
05:34:42 <haasn> :t (==)
05:34:43 <lambdabot> Eq a => a -> a -> Bool
05:34:48 <Hafydd> Prelude> (uncurry (++) . fmap (drop 1) . break (\case (2,_)->True; _->False)) [(1, [0]), (2, [1,2]), (3, [2]), (4, [1])][(1,[0]),(3,[2]),(4,[1])]
05:35:04 <haasn> shachaf: so is kappabot just lambdabot with an updated version of lens imported?
05:35:32 <Hafydd> > (uncurry (++) . fmap (drop 1) . break (\x -> case x of (2,_)->True; _->False)) [(1, [0]), (2, [1,2]), (3, [2]), (4, [1])] -- or without it
05:35:33 <lambdabot>   [(1,[0]),(3,[2]),(4,[1])]
05:35:34 <shachaf> haasn: It's an old version of lambdabot with any version of lens imported.
05:35:49 <Andrea_> leteBy (\(x,y) (x1,y1) -> x==y1) [(1,[0]),(2,[1,2]),(3,[2]),(4,[1])]
05:35:55 <Andrea_> > deleteBy (\(x,y) (x1,y1) -> x==y1) [(1,[0]),(2,[1,2]),(3,[2]),(4,[1])]
05:35:56 <lambdabot>   Couldn't match expected type `(a0, a0)'
05:35:56 <lambdabot>              with actual type `[(t0...
05:35:56 <haasn> I thought lambdabot has lens, but most of it qualified or outdated
05:36:13 <haasn> Andrea_: you probably meant x == y
05:36:15 <Andrea_> > deleteBy (\(x,y) (x1,y1) -> x==x1) [(1,[0]),(2,[1,2]),(3,[2]),(4,[1])]
05:36:16 <lambdabot>   Couldn't match expected type `(a0, t0)'
05:36:16 <lambdabot>              with actual type `[(t1...
05:36:20 <shachaf> lambdabot is dead. Long live lambdabot.
05:36:22 <haasn> you're also not specifying the element to delete
05:36:58 <haasn> s/x == y/x == x1/ -- whoops
05:37:04 <Andrea_> > deleteBy (\(x,y) (x1,y1) -> x==x1)  (2,[]) [(1,[0]),(2,[1,2]),(3,[2]),(4,[1])]
05:37:05 <lambdabot>   [(1,[0]),(3,[2]),(4,[1])]
05:37:10 <Andrea_> yeah
05:37:31 <haasn> still, ‘filter’ is more canonical than ‘delete’ here
05:37:48 <haasn> I sort of always wonder why we don't have an inverted version of ‘filter’ though
05:38:24 <merijn> haasn: you mean "filter (not . f)"?
05:38:31 <haasn> yeah
05:38:38 <merijn> It's trivial to compose using not, so why bother adding it?
05:38:39 <haasn> aka filter . not
05:38:57 <haasn> minor convenience, I guess?
05:39:05 <shachaf> @ty filter . not
05:39:06 <lambdabot>     Couldn't match type `Bool' with `a0 -> Bool'
05:39:06 <lambdabot>     Expected type: Bool -> a0 -> Bool
05:39:06 <lambdabot>       Actual type: Bool -> Bool
05:39:30 <haasn> > [(x,y) | (x,y) <- [(1,[0]),(2,[1,2]),(3,[2]),(4,[1])], x /= 2]
05:39:31 <lambdabot>   [(1,[0]),(3,[2]),(4,[1])]
05:39:33 <Hafydd> :t filter . fmap not
05:39:34 <lambdabot> (a -> Bool) -> [a] -> [a]
05:40:03 <Andrea_> perhaps filter or map foldl etc. has less performance ?
05:40:05 <Hafydd> :t filter . (not.)
05:40:06 <lambdabot> (a -> Bool) -> [a] -> [a]
05:40:19 <haasn> Andrea_: they're both worse than using a Map if all you want is an index of key/value pairs
05:40:24 <haasn> a collection of*
05:40:47 <haasn> (of course, using a list means you get extra ordering as well, which may be needed)
05:41:03 <haasn> (and also duplicate keys)
05:41:32 <Andrea_> in my list are no duplicate keys and the enties are deterministic
05:42:14 <haasn> Andrea_: have a look at http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html
05:42:27 <Andrea_> thx
05:42:32 <haasn> or http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map-Lazy.html rather
05:42:49 <Andrea_> ok i thought to use a set or a map ;)
05:43:20 <Andrea_> i use this for develop an exact cover algorithm
05:43:22 <elliott> haasn: lambdabot's "lens" is up to date
05:43:50 <shachaf> lambdabot has lens?
05:43:57 <haasn> elliott: where can I find stuff like ‘base’?
05:43:57 <elliott> yes, if you @let imoprt it
05:44:00 <elliott> the quotes were intentional
05:44:05 <shachaf> hoorambdabot
05:44:06 <elliott> @let import Numeric.Lens
05:44:07 <lambdabot>  .L.hs:93:1:
05:44:07 <lambdabot>      Numeric.Lens: Can't be safely imported!
05:44:07 <lambdabot>      The module its...
05:44:12 <elliott> haasn: you don't until I recompile it today.
05:44:20 <haasn> alright
05:44:23 <elliott> btw, it's hashable's fault, not mine :P
05:44:40 <haasn> needs to be imported at all times =)
05:44:52 <haasn> what use is a lambdabot without lens ready to use
05:49:14 <astor`> is there a common type for a non-empty list?
05:49:35 <elliott> semigroups has one.
05:50:25 <astor`> elliott: looks good.  Data.List.NonEmpty
05:52:04 * haasn .oO( Free (a,) Void )
05:52:19 <haasn> oh
05:52:21 <haasn> no
05:52:23 <haasn> that's endless lists
05:52:33 <haasn> .. and also just Fix (a,)
05:52:59 <elliott> you're thinking of Cofree Maybe.
05:53:08 <Hafydd> > (uncurry(++).fmap(drop 1).break((==2).fst)) [(1,[0]),(2,[1,2]),(3,[2]),(4,[1])]
05:53:09 <lambdabot>   [(1,[0]),(3,[2]),(4,[1])]
05:53:14 <Hafydd> Another unreadable triumph.
05:53:23 <haasn> elliott: yeah that seems better
05:53:56 <Hafydd> @pl \x->(uncurry(++).fmap(drop 1).break((==x).fst))
05:53:59 <lambdabot> (uncurry (++) .) . (fmap (drop 1) .) . break . flip ((.) . flip (==)) fst
05:53:59 <lambdabot> optimization suspended, use @pl-resume to continue.
05:54:28 <Hafydd> @pl-resume
05:54:34 <lambdabot> (uncurry (++) .) . (fmap (drop 1) .) . break . flip ((.) . flip (==)) fst
05:54:34 <lambdabot> optimization suspended, use @pl-resume to continue.
05:55:14 <elliott> patches to fix @pl welcome.
05:55:21 <elliott> no idea what's wrong with it
05:55:23 <elliott> maybe I should bisect
05:55:50 <astor`> elliott: 'These' has a semigroup instance, but there's no function: These a a -> NonEmpty a
05:56:19 <elliott> are you talking about cmccann's these library?
05:56:24 <elliott> he'll probably accept a patch to add that if so
05:56:33 <elliott> hm
05:56:39 <elliott> maybe you can write it with Align or something.
05:56:56 <Andrea_> > (uncurry(++).fmap(drop 1).break((==2).fst)) [(1,[0]),(5,[1,2]),(3,[2]),(4,[1])]
05:56:57 <lambdabot>   [(1,[0]),(5,[1,2]),(3,[2]),(4,[1])]
05:57:02 <astor`> yes.  I'm thinking that These is the general base case for NonEmpty.
05:58:03 <Andrea_> > (uncurry(++).fmap(drop 1).break((==1).fst)) [(1,[0]),(2,[1,2]),(3,[2]),(4,[1])]
05:58:04 <lambdabot>   [(2,[1,2]),(3,[2]),(4,[1])]
06:02:36 <astor`> elliott: the documentation for Align is gibberish to me, but I'll look into it.
06:04:39 <elliott> astor`: it's like Applicative except different.
06:04:53 <elliott> align is like zip for Theses.
06:06:18 <astor`> I don't even understand the laws.  join? isn't that only defined for a Monad while f is only a functor.
06:07:51 <elliott> it's join on functions there.
06:07:55 <elliott> you should uh, probably ignore the laws.
06:08:06 <elliott> also there's only one typeclass there we actually have a use for.
06:08:32 <astor`> elliott: if I ignore the laws then it's only the description left, which is math gibberish ;-)
06:09:10 <elliott> no, there's also the types.
06:09:14 <elliott> think about the case where f = [] for the motivation.
06:09:27 <elliott> it's like a zip
06:15:13 <zvrba> how does one use "unless" ?
06:15:40 <FreeFull> :t unless
06:15:41 <lambdabot> Monad m => Bool -> m () -> m ()
06:17:20 <pxqr> consider the following situation: we have N threads and each thread periodically might want to send a message to the _all_ other threads. two things are required: cheap broadcasting and bounded length of the each channel. How to solve this problem properly?  (I guess I can use something like MVar (Queue Message), but maybe there is a better solution)
06:17:40 <pxqr> BoundedChan doesn't have dupChan unfortunately
06:18:41 <FreeFull> :t when
06:18:42 <lambdabot> Monad m => Bool -> m () -> m ()
06:18:54 <FreeFull> zvrba: unless is like when but opposite
06:19:13 <zvrba> FreeFull: ok, i didn't realize it was something for use in monads only
06:19:28 <zvrba> because the textbook says 'if null ..' in IO
06:19:32 <zvrba> pxqr: perhaps you want a barrier
06:19:58 <zvrba> pxqr: or a semaphore + queue
06:20:10 <pxqr> zvrba: I don't want to block writer
06:20:25 <pxqr> if a queue is full I want to drop old messages
06:21:25 <zvrba> so have a circular queue with overwriting and simply replicate the message N times. all threads read from the same queue.
06:21:32 <FreeFull> What would dupChan do?
06:22:03 <zvrba> in any case, it's unclear whether the N threads are synchronized in some way.
06:22:05 <FreeFull> pxqr: You can modify BoundedChan to drop rather than block when the channel is full
06:22:29 <pxqr> FreeFull: yes, this is nice solution!
06:22:56 <pxqr> and pretty simple
06:24:42 <Andrea_> cu
06:35:41 <astor`> elliot:  the function I want is probably this:  join' :: (Traversable f, Ord a) => f (a, b) -> f (a, c) -> f (a, These b c).  Does Align help?
06:37:14 <mauke> TIL if you combine literate haskell and cpp, unlit runs first
06:38:30 <elliott> astor`: um, I have no idea. that sounds scary.
06:38:47 <elliott> astor`: I think maybe yes. except it might have to be Crosswalk not Traversable.
06:38:56 <elliott> or uh um uh.
06:39:00 <elliott> I don't think that function makes sense.
06:39:21 <zvrba> let x = print 4 ... and evaluating x prints 4 each time. that's way cool :-)
06:39:35 <mauke> evaluating x doesn't print
06:39:38 <zvrba> i can give names to side-effects :)
06:39:39 <mauke> executing x does
06:39:44 <zvrba> ok
06:40:04 <chrisdone> case in point, ghci's API has an eval command and a run command
06:40:22 <chrisdone> elliott: i've got my ghc-server loading itself and inspecting types and such, hurrah :D
06:40:31 <elliott> chrisdone: cool :)
06:40:57 <elliott> chrisdone: is it going to be a general library type thing?
06:41:21 <zvrba> mauke: so what's the difference between evaluation and execution?
06:41:42 <mauke> evaluation is the normal thing that happens in your expressions
06:41:50 <chrisdone> elliott: can be, nothing ties to emacs specifically, apart from that you send it s-expressions
06:42:07 <mauke> execution is an artificial procedure in the bowels of the runtime system
06:42:09 <chrisdone> elliott: but that's just a transfer format, so =)
06:42:27 <mauke> it's something that can be done with IO values
06:43:33 <chrisdone> elliott: i can now hack on hpaste remotely xD
06:43:50 <chrisdone> (from my local emacs)
06:44:16 <elliott> cool
06:44:29 <elliott> chrisdone: now run the actual hpaste server in it so you can hotpatch it :P
06:44:47 <zvrba> mapM print [1,2,3,4] returns a list of 4 ()
06:44:59 <zvrba> mapM show [1,2,3,4] returns a list containing ["1234"]
06:45:09 <zvrba> why only 1-element list in the 2nd example?
06:46:22 <zvrba> i expected [["1"],["2"]..]
06:46:30 <simukis_> because "1" is ['1']
06:46:34 <zvrba> or, since string is a list: ["1","2",..]
06:46:54 <simukis_> :t String
06:46:55 <lambdabot> Not in scope: data constructor `String'
06:47:02 <simukis_> String = [Char]
06:47:04 <mauke> @src mapM
06:47:04 <lambdabot> mapM f as = sequence (map f as)
06:47:07 <S_J> are message broekrs hard to implement? RabbitMQ seems like a simple enough program?
06:47:16 <mauke> > sequence (map show [1,2,3,4])
06:47:17 <lambdabot>   ["1234"]
06:48:46 <zvrba> map show [1..4] produces, as expected, 4-element list
06:49:03 <zvrba> so why does sequence convert it to 1-elt list?
06:49:05 <chrisdone> elliott: i've done that with ghci before =p
06:50:26 <mauke> zvrba: because that's what sequence does
06:50:51 <sepp2k> zvrba: Why do you expect sequence to produce a list that's nested more deeply than the input list? sequence takes a list of lists and produces a list of lists. So producing a list of lists of lists wouldn't fit its type.
06:51:34 <elliott> > sequence [[a,b],[c,d],[],[e]]
06:51:35 <lambdabot>   []
06:51:40 <elliott> er, right.
06:51:43 <elliott> > sequence [[a,b],[c,d],[e]]
06:51:43 <lambdabot>   [[a,c,e],[a,d,e],[b,c,e],[b,d,e]]
06:51:50 <zvrba> :t sequence
06:51:50 <lambdabot> Monad m => [m a] -> m [a]
06:52:42 <zvrba> sepp2k: I expect it to produce the same cardinality.
06:52:49 <nexx> > sequence [[a,c,e],[a,d,e],[b,c,e],[b,d,e]]
06:52:49 <lambdabot>   [[a,a,b,b],[a,a,b,d],[a,a,b,e],[a,a,c,b],[a,a,c,d],[a,a,c,e],[a,a,e,b],[a,a...
06:52:54 <astor`> elliott: It is supposed to be an outer join on 'a'.
06:52:55 <zvrba> ["1234"] doesn't have the same cardinality as input, ["1","2",..] does
06:53:00 <zvrba> and it's the same nesting level
06:53:11 <elliott> zvrba: what gave you these expectations?
06:53:28 <zvrba> elliott: example in LYAH where sequence is first demonstrated on IO monad.
06:53:29 <Lethalman> S_J, http://hackage.haskell.org/package/amqp
06:53:34 <zvrba> sequence [print 1, print 2]
06:53:40 <zvrba> so I tried it on  list.
06:53:50 <elliott> ok. sequence [print 1, print 2] is do { x <- print 1; y <- print 2; return [x, y] }
06:53:50 <zvrba> the above returned [(), ()]
06:53:58 <elliott> now, print always returns (), so this is equivalent to
06:54:03 <elliott> do { print 1; print 2; return [(), ()] }
06:54:06 <elliott> now,
06:54:08 <zvrba> cool. so far so clear.
06:54:14 <elliott> sequence ["1","2","3","4"]
06:54:15 <elliott> is:
06:54:27 <mauke> zvrba: sequence [print 1, print 2] didn't return a list
06:54:39 <mauke> that is, it returned IO [()], not [()]
06:55:06 <elliott> do { a <- "1"; b <- "2"; c <- "3"; d <- "4"; return [a,b,c,d] }
06:55:08 <zvrba> mauke: the concrete example is sequence $ map print [1,2,3,4]
06:55:10 <elliott> this is running in the list monad
06:55:16 <zvrba> mauke: sure.
06:55:30 <mauke> zvrba: that's the entire point
06:55:38 <elliott> but yes what mauke says is true, I fear not quite seeing how the IO monad works is clouding your view when it's another monad?
06:55:51 <mauke> with print you get an outer layer of IO
06:55:56 <mauke> with show you get an outer layer of []
06:56:08 <zvrba> the problem may be that the book didn't explain monads yet.
06:57:03 <Sculptor> ludo burazeru, ludo
06:57:16 <zvrba> mauke: what do you mean by 'outer layer' ?
06:57:32 <mauke> zvrba: the return type/value
06:57:39 <zvrba> intuitively, monad is something that invlisibly "threads" state throughout a computation, right?
06:57:43 <mauke> no
06:58:01 <mauke> there is no intuition. ~free your mind~
06:58:05 <mauke> :t sequence
06:58:05 <lambdabot> Monad m => [m a] -> m [a]
06:58:07 <elliott> "intuitively" is the hard part. nobody can access another person's intuition
06:58:14 <mauke> in the print example, m = IO
06:58:17 <elliott> and it is hard to tell when someone's intuition is getting in the way
06:58:23 <mauke> with show, m = []
06:58:38 <mauke> you can forget the "Monad m =>" part
06:58:40 * hackagebot cabal-meta 0.4.1.2 - build multiple packages at once  http://hackage.haskell.org/package/cabal-meta-0.4.1.2 (GregWeber)
06:58:51 <zvrba> ok, it's a typeclass.
06:59:02 <zvrba> so sequence transforms a list of m a to m [a]
06:59:09 <mauke> [IO a] -> IO [a] vs. [[Char]] -> [[Char]]
06:59:30 <zvrba> oh
06:59:46 <zvrba> but still, both ["1","2"] and ["12"] fits the latter result signature.
06:59:51 <mauke> yes
06:59:57 <zvrba> so, why is ["12"] preferred?
07:00:01 <zvrba> or, more useful?
07:00:02 <mauke> ... preferred?
07:00:04 <zvrba> or defined that way?
07:00:05 <mauke> what
07:00:13 <mauke> @src sequence
07:00:13 <lambdabot> sequence []     = return []
07:00:13 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:00:13 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
07:00:19 <mauke> there is no choice
07:00:23 <elliott> zvrba: the function you want cannot have sequence's type
07:00:31 <elliott> so, it is a completely different function
07:00:45 <elliott> zvrba: I fear the confusion stems from the fact that in your example, all the sublists were of length one
07:00:52 <elliott> > sequence ["123","456","789"]
07:00:53 <lambdabot>   ["147","148","149","157","158","159","167","168","169","247","248","249","2...
07:00:59 <elliott> > sequence ["123","456","789","1011"]
07:01:00 <lambdabot>   ["1471","1470","1471","1471","1481","1480","1481","1481","1491","1490","149...
07:01:01 <mauke> > mapM show [1, 23, 456]
07:01:02 <lambdabot>   ["124","125","126","134","135","136"]
07:01:11 <elliott> (mapM f = sequence . map f, to explain mauke's example)
07:01:12 <zvrba> oh!
07:02:13 <zvrba> so the documentation for sequence says: Evaluate each action in the sequence from left to right, and collect the results.
07:02:22 <zvrba> so what is the "action" in the example with show?
07:02:41 <mauke> the actions are the list elements
07:02:44 <mauke> i.e. "1", "2", "3"
07:03:08 <zvrba> and what does the element "do" when it's evaluated or "run" or whatever is done with actions?
07:03:26 <mauke> the "action" interpretation of lists is parallel universes
07:03:35 <mauke> each element represents a separate universe
07:03:45 <zvrba> > length $ sequence ["123","456","789"]
07:03:45 <lambdabot>   27
07:04:00 <mauke> so "123" is three universes containing '1', '2', '3' respectively
07:04:36 <astor`> It seems that `align' is the same operation as an outer join does, but an outer join would require a Traversable+Sorted.  Is there a typeclass for TraversableByOrd?
07:04:36 <astor`>  
07:04:49 <mauke> running "123" >> "456" combines each element of the first list with each element of the second list
07:05:30 <elliott> yuck, the docs shouldn't say "evaluate" ther
07:05:31 <elliott> e
07:05:35 <elliott> "execute" would be correct
07:05:48 <elliott> zvrba: the list monad models nondeterminism
07:06:00 <mauke> ... in a very deterministic way
07:06:01 <zvrba> but how can you "Execute" a pure value like a list of numbers?
07:06:02 <elliott> > do { x <- [1,2,3]; y <- [4,5,6]; guard (x+1 == y); return (x,y) }
07:06:04 <lambdabot>   [(3,4)]
07:06:13 <mauke> zvrba: "execute" is virtual. it means whatever it needs to mean
07:06:14 <elliott> how can you "execute" a pure value like a description of some IO?
07:06:31 <elliott> monads are not special things that add impurity to the language
07:06:38 <zvrba> i didn't think so
07:06:42 <elliott> they're just a generic interface within the language that many things implement
07:06:54 <elliott> that lets you think of certain types as representing "little DSLs"
07:07:03 <elliott> for the list monad, that DSL is Prolog-esque nondeterminism
07:07:13 <elliott> and "executing" a list like [1,2,3] is picking a single element out of that list
07:07:28 <elliott> (in reality, all the elements are picked out, and the results that you get when picking each one are collected in the resulting list)
07:07:46 <elliott> > do { x <- [1..10]; y <- [1..10]; guard (x+1 == y); return (x,y) }
07:07:47 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
07:07:52 <mauke> bah
07:07:55 <mauke> don't bother with guard
07:08:05 <elliott> fair. just showing how you can use it for nondeterministic programming
07:08:06 <mauke> > do { x <- [1,2]; y <- "abc"; return (x,y) }
07:08:06 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c')]
07:08:26 <elliott> zvrba: if you know how list comprehensions work, then you know how the list monad works
07:08:30 <zvrba> how does that "do" know to execute in list monad?
07:08:38 <haasn> > [(x,y) | x <- [1..10], y <- [1..10], x+1 == y]
07:08:38 <elliott> the equivalent of mauke's expression is [(x,y) | x <- [1,2], y <- "abc"]
07:08:39 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
07:08:46 <elliott> zvrba: because do desugars to return and (>>=)
07:08:49 <elliott> which are members of the Monad class
07:08:53 <elliott> and [] implements that class
07:08:57 <zvrba> ah!
07:09:01 <elliott> (i.e., there is an instance Monad [])
07:09:06 <elliott> actually I lied
07:09:09 <elliott> do never uses return itself
07:09:11 <elliott> but whatever
07:09:12 <chrisdone> NEVER LIE!
07:09:19 <elliott> @where do
07:09:19 <lambdabot> The rules of do notation: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-480003.14 (Note that "do { v <- m; ... }" is the same as "m >>= \v -> do { ... }" when v is a variable,
07:09:19 <lambdabot> rather than a more complex pattern.)
07:09:24 <mauke> zvrba: because the things on the right of <- have list type
07:10:04 <zvrba> many class instances for a type => javascript :p
07:10:29 <edvardkk> I was confused a bit at first because much docs for monads make it seem like the "actions" actually will take when evaluated, when, instead, your code is more of a recipe of what shall be done, and the actions actually take place when the monad is run (whatever that means in the context)
07:10:47 <elliott> edvardkk: right
07:10:55 <Cubic_> @pl \t b a -> a ^+^ (t ^* (a ^-^ b) )
07:10:58 <lambdabot> (ap (^+^) .) . flip ((.) . (.) . (^*)) (flip (^-^))
07:10:58 <lambdabot> optimization suspended, use @pl-resume to continue.
07:11:06 <elliott> there's a lot of potential to be misleading without realising it, mixing up evaluation and execution is very common :)
07:11:10 <edvardkk> yep
07:11:35 <zvrba> elliott: so how is one supposed to "get it" when even the official docs are lax in the use of these terms?
07:11:37 <elliott> doesn't help that "evaluation" and "execution" sound like similar things but take place on completely different conceptual levels
07:11:49 <elliott> zvrba: asking in #haskell? :)
07:11:52 <zvrba> ...
07:11:55 <zvrba> :)
07:11:57 <elliott> I think LYAH explains monads quite well... but it's been a long time so I don't remember.
07:12:02 <edvardkk> so, for example, shifting from thinking about sequence from "do this things in order", to "stitch these recipies together", made things much easier for me
07:12:07 <zvrba> well, it starts with IO in chapter 8
07:12:11 <zvrba> and monads are like in chapter 12
07:12:15 <Cubic_> Where are the official docs lax?
07:12:21 <elliott> someone should fix outright misleading documentation like sequence's, but I don't think putting a monad tutorial in the reference API documentation is the answer
07:12:22 <mauke> zvrba: yeah, you're not supposed to understand monads yet
07:12:38 <zvrba> elliott said that the description of sequence was wrong, for example
07:12:40 <elliott> zvrba: right. you can use the IO interface without understanding the general pattern that it's a special case of.
07:12:40 <mauke> IO comes first
07:12:50 <haasn> the haskell council decrees it unlawful to be understanding monads without a proper license
07:12:53 <elliott> just think of it as a DSL for modelling imperative programming.
07:12:58 <elliott> (that the runtime system helpfully executes for you.)
07:13:00 <Cubic_> And you don't need to understand monads for IO. Monads are just a generalization of things you do with IO, Lists and other things
07:13:23 <elliott> s/imperative, IO-performing/
07:13:33 <zvrba> but seeing >>= defined for lists made the connection 'click'. why sequence behaves that way.
07:14:06 <zvrba> type may declare itself to be an instance of Monad and is free to define "combination of actions" as it sees fit.
07:14:31 <edvardkk> as long as it respects the monad rules
07:14:35 <zvrba> yeah
07:14:55 <edvardkk> erh, laws
07:15:12 <elliott> right. though often for a given type there is only one possible valid implementation
07:15:19 <elliott> (I think this is true for []?)
07:15:32 <mauke> hwat
07:15:43 <mauke> oh, right
07:15:45 <edvardkk> if so, can it be derived automatically? (for [])
07:16:34 <elliott> not by Haskell
07:16:45 <edvardkk> kk
07:16:48 <elliott> maybe you could extend djinn to do it, though it doesn't (can't) do recursive types in general
07:17:52 <zvrba> this talk about actions/values/evaluation/execution is confusing.
07:17:55 <edvardkk> the details are way over my head. but it would be cool if instances with only 1 valid impl. could be found automatically :-)
07:19:04 <zvrba> if monad is a "recipe" for doing something, can I execute only one step at a time?
07:19:09 <zvrba> or does it have to run atomically?
07:19:12 <mauke> there are no steps
07:19:24 <zvrba> sure there are, a list of <- in do
07:19:28 <mauke> no
07:19:42 <mauke> and it's not a monad that's the recipe, it's monadic values
07:19:53 <mauke> a list is a monadic value
07:20:04 <chrisdone> zvrba: do you know lambda calculus?
07:20:10 <mauke> given a list, you can't recover the <-'s
07:20:10 <edvardkk> zvrba: I learned a lot reading tutorials on (variants of) the state transformer monad.
07:20:13 <zvrba> chrisdone: not really.
07:20:22 <zvrba> chrisdone: i'm familiar with basic concepts.
07:20:28 <edvardkk> IMO, also, State monad is a really confusing name for ex-imperative programmers.
07:21:09 <tomejaguar> edvardkk: how come?
07:21:16 <zvrba> chrisdone: but what does LC have to do with monads?
07:21:17 <chrisdone> zvrba: well, the lambda calculus is useful as an example of a pure language that can only be evaluated. you recognise that, right?
07:21:18 <tomejaguar> It always seemed natural to me.
07:21:22 <Adeon> it's a monad, it got state. therefore it is a state monad
07:21:24 <edvardkk> at least the various monads threading state (st, writer, reader, ...) makes it very clear what is evaluating monadic values, and what is "execution"
07:21:29 <zvrba> chrisdone: right.
07:21:40 <edvardkk> I understand that the name is "correct" :-)
07:23:14 <zvrba> .. it's a friggin' shorthand notation for a sequence of nested function "calls" / evaluations. why do you have to involve execution here?
07:23:15 <chrisdone> zvrba: and you're familiar that you can define pure data structures like lists and or trees or whatever in lambda calculus?
07:23:24 <zvrba> yes
07:23:37 <chrisdone> zvrba: ok, so from the lambda calculus, you could produce a list of commands as output, like "beep" and "wait"
07:23:37 <elliott> "execution" is useful.
07:23:38 <zvrba> i mean, I've seen do-notation desugared to a chain of lambdas and >>= operators
07:23:49 <elliott> it refers to something happening *inside* the language of the monad you're using
07:23:51 <zvrba> and it's all evaluation in the end.
07:23:56 <chrisdone> zvrba: then you could pass that list of commands to a person or a machine that would execute the list of commands
07:24:02 <elliott> doesn't correspond to a native Haskell concept.
07:24:07 <zvrba> chrisdone: right.
07:24:34 <zvrba> but is the list of commands atomic?
07:24:34 <edvardkk> tomejaguar: basically, I somehow figured that there would be state inside the monadic values, and not state threaded through, using transformers
07:24:44 <edvardkk> tomejaguar: but this was when I was a total noob. not a half-total, like now
07:24:47 <zvrba> can the "executor" choose to run only a part of th elist?
07:25:40 <mauke> depends on how you write it
07:25:46 <chrisdone> zvrba: that's what haskell is doing. it's also pure. the IO monad is just making a list of commands. the list of commands is limited in scope, putChar, getChar, things like that. you can extend it with an FFI too
07:26:02 <mauke> IO isn't making a list of commands
07:26:07 <mauke> it's making a single command
07:26:39 <chrisdone> that's not a distinction that seems useful
07:26:49 <chrisdone> zvrba: does that make any sense?
07:27:22 <zvrba> well, yes, you have an external interpreter that does something with the list of commands :p
07:27:34 <zvrba> "deus ex machina"
07:27:37 <edvardkk> chrisdone: agreed. ofc it's packed into one command, but it often seems more useful to think of it as a list of commands
07:27:43 <edvardkk> zvrba: yes. in the case of IO
07:27:57 <edvardkk> or, depending on what you mean by "external" :p
07:27:58 <mauke> it's not a list, though
07:28:06 <edvardkk> true
07:28:19 <FreeFull> I'm wondering if zvrba wants a free monad
07:28:23 <mauke> it's a wrapped value or a command plus a callback
07:28:55 <zvrba> so there's a distinction between a list of commands and "interpreting" it.
07:29:05 <mauke> data IO a where { Return :: a -> IO a; Bind :: a -> (a -> IO b) -> IO b }
07:29:22 <chrisdone> zvrba: sure
07:29:46 <chrisdone> mauke: again, the details don't matter for an explanation of evaluation vs execution
07:30:01 <chrisdone> it could easily be [Command] or Tree Command or w/e
07:30:13 <mauke> how could it, with >>= ?
07:30:57 <zvrba> chrisdone: so, what 'recipes' exist in the list monad, for example?
07:31:01 <chrisdone> that's the details i mentioned. i'm not explaining how Haskell implements IO with monads, nor applicative, or whatever. nevermind, i'm sure this is all very helpful to zvrba's understanding </sarc>
07:31:54 <edvardkk> IMO, the "recipe" metaphor is easier to see for IO, State, Reader, ...  but chrisdone might get it for list :p
07:32:24 <haasn> I'm slowly coming to believe that a ‘monad’ is a metaphor for metaphors
07:32:30 <elliott> I know how to write Prolog code, so it's easy to see it as a recipe for me
07:32:34 <elliott> well, basic Prolog.
07:32:48 <zvrba> I had a course i prolog a long time ago.
07:32:56 <zvrba> aha!
07:33:22 <FreeFull> I don't see recipes anywhere
07:33:30 <FreeFull> I just see the flow of data
07:33:34 <zvrba> so where Prolog would make a nondeterministic choice, you would have a list of eligible values in the list monad?
07:33:51 <elliott> right.
07:33:56 <chrisdone> zvrba: the concept of 'recipies' isn't really specific to monads as such, it's any inherent in any kind of mini language that is interpreted by some interpreter
07:33:57 <edvardkk> All I see is blonde, brunette, red-head. Want a drink?
07:34:25 <FreeFull> edvardkk: Sure
07:34:48 <zvrba> FreeFull: the others are keen on talking about actions/executions/etc. whereas do desugars to nested lambdas...
07:35:45 <zvrba> if you have a nice dataflow explanation of monads, feel free to share it :p
07:36:06 <chrisdone> 'action' is just a handy term to refer to monadic values, and actions are executed by their interpreter. in the case of monads the instance provides the interpretation of what the values mean
07:36:08 <FreeFull> zvrba: Something of type   m a   can be said to be an action. You don't know what it desugars to underneath, and  usually can't find out
07:36:11 <elliott> you need some way to refer to a value of type (m a) for some monad m
07:36:22 <elliott> "action" is just one word fort hat
07:36:25 <elliott> "monadic value" is another
07:36:35 <FreeFull> I think execution would be in regards to runtime
07:36:48 <hvr> chrisdone: ping
07:36:49 <zvrba> chrisdone: \o/
07:37:08 <zvrba> but why does everybody have to say "monadic value", when it's a value just like any other? :P
07:37:28 <chrisdone> zvrba: because it's easier than saying "a value which happens to be an instance of monad"?
07:37:35 <chrisdone> hvr: pong
07:38:11 <hvr> chrisdone: -> /msg
07:38:17 <mauke> no, "a value of a type whose constructor happens to be an instance of monad"
07:38:40 <mauke> e.g. in [1,2,3] :: [Int] the instance of monad is []
07:38:41 <elliott> zvrba: I don't, because there's nothing monad about the value.
07:38:50 <elliott> but from the POV of the [] monad's semantics, [1,2,3] is an action.
07:38:56 <zvrba> elliott: ahh, I got it.
07:38:56 <elliott> *monadic about
07:39:10 <zvrba> elliott: the WHOLE value of type (m a) is an "action", not individual "statements" within do.
07:39:16 <zvrba> ?
07:39:25 <elliott> sure. though those statements usually contain actions
07:39:31 <elliott> in "x <- m; ..." m is an action
07:39:32 <zvrba> ...
07:39:33 <elliott> as in "m; ..."
07:39:37 <elliott> you can say
07:39:38 <edvardkk> you can compose one action, from several smaller
07:39:42 <elliott> do { x <- do { a; b; c }; ... }
07:39:46 <monochrom> you can just say "value" for all of these: value, function, monadic value, action, data constructor, map, set, graph
07:39:49 <elliott> i.e., do turns actions into more actions.
07:40:12 <FreeFull> return turns something into an action
07:40:27 <zvrba> elliott: ah, but that makes more sense.
07:41:03 <FreeFull> Hmm
07:41:19 <zvrba> because, based on the examples of IO, I believed that the whole "statement" like x <- putStrLn "blah" was an "action"
07:41:28 <zvrba> and that do consisted of a list of actions
07:41:30 <FreeFull> > do { x <- [1..]; filter odd; take 3; return x }
07:41:31 <lambdabot>   Couldn't match expected type `[a0]' with actual type `[a1] -> [a1]'Couldn't...
07:41:40 <FreeFull> Oh, right, that won't work
07:41:47 <elliott> zvrba: right, "x <- m" isn't really anything outside of a do block
07:41:53 <elliott> just sugar
07:42:00 <elliott> the term for something like that in do block is "statement"
07:42:02 <FreeFull> > do { x <- [1..]; filter odd (return x); take 3 (return x); return x }
07:42:03 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
07:42:04 <edvardkk> zvrba: there putStrLn *is* an action, but do composes it together to a larger action (using bind)
07:42:05 <zvrba> but *inside* the do block, only "m" is the action
07:42:08 <zvrba> NOT "x <- m"
07:42:11 <FreeFull> Funny
07:42:12 <Luke1> This isn't exactly a haskell question but I'm using postgresql-simple for queries and it's failing with a sql syntax error on "." but running the query directly doesn't yield any errors. I'm using formatQuery to print it. any ideas how to debug this further?
07:42:28 <elliott> zvrba: right.
07:42:42 <FreeFull> > do { x <- [1..]; y <- filter odd (return x); take 3 (return y); return y }
07:42:43 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
07:42:46 <FreeFull> Nope
07:42:51 <FreeFull> > do { x <- [1..]; y <- filter odd (return x); take 3 (return y);}
07:42:52 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
07:43:31 <FreeFull> > do { x <- [1..]; take 3 . filter odd $ return x;}
07:43:32 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
07:43:40 <elliott> uh.
07:43:42 <FreeFull> Of course it won't work
07:43:44 <elliott> that doesn't really make sense
07:44:01 <FreeFull> > do { take 3 . filter odd [1..] }
07:44:02 <lambdabot>   Couldn't match expected type `a0 -> [a1]' with actual type `[a2]'
07:44:06 <FreeFull> > do { take 3 . filter odd $ [1..] }
07:44:07 <lambdabot>   [1,3,5]
07:45:04 <zvrba> bah
07:45:34 <zvrba> this whole thing seems to be made more complicated than necessary because of inconsistent/lax use of terms...
07:45:37 <zvrba> anyway
07:45:38 <zvrba> back to the book
07:45:41 <haasn> FreeFull: oh, I just realized how that one works
07:45:54 <elliott> zvrba: well, I think my use of terms is precise, at least. handwaveyness is a big problem though, I agree
07:45:58 <haasn> filter odd (return x)  -> [x] for odd x, [] otherwise; and then [] >> ... = []
07:46:46 <zvrba> elliott: i wasn't pointing specifically at you.
07:47:00 <elliott> fair 'nuff, wasn't interpreting it as that
07:47:03 <elliott> never mind :)
07:47:14 <zvrba> ok >(
07:47:16 <zvrba> :)
07:51:50 <S_J> is hpaste down for you too?
07:52:42 <FreeFull> S_J: Yes
07:53:42 * hackagebot prednote 0.10.0.0 - Build and evaluate trees of predicates  http://hackage.haskell.org/package/prednote-0.10.0.0 (OmariNorman)
07:53:51 <elliott> chrisdone!!!!
07:56:19 <FreeFull> I was thinking of connecting up list functions using do syntax, but it clearly doesn't work that well
07:58:40 <sclv> elliott: hpaste is now paste.haskell.org
07:58:51 <sclv> or paste.tryhaskell.org i guess
07:59:06 <elliott> so all hpaste.org links are going to be broken forever??
07:59:19 <sclv> it'll be paste.haskell.org soon enough
07:59:36 <sclv> and maybe we can set the old domain up with redirects eventually
07:59:39 <FreeFull> What was wrong with it being hpaste.org? Domain costs?
07:59:42 <elliott> right, but I mean hpaste.org is not responding
07:59:58 <Andrea__> in hpaste away ?
07:59:58 <sclv> right afaik the server moved and the domain admin for hpaste wasn't responsive
08:00:08 <sclv> so they couldn't repoint the domain to the new ip
08:00:13 <elliott> ah...
08:00:20 <sclv> so its temporarily at tryhaskell.org, which chris controls. and then it will be at haskell.org
08:00:24 <elliott> ok. a shame, all hpaste links already broke at least twice :(
08:00:28 <sclv> so the domain will be community managed
08:00:43 <elliott> all the old pastes are still there though I hope?
08:00:44 <sclv> afaik yes
08:00:45 <elliott> so it is just a mechanical URL substitution
08:00:47 <Andrea__> i will check it
08:01:11 <sclv> right -- and if ppl end up being able to do something with the hpaste domain
08:01:26 <sclv> then ideally we can make it autoredirect
08:02:55 <Andrea__> i wrote a program with explanation : http://paste.tryhaskell.org/1595083315373670400
08:11:26 <pxqr> could stm force the current thread to yield? as MVar do for example.
08:12:40 <pxqr> yield here = Control.Concurrent.yield
08:12:57 <pxqr> :t yield
08:12:57 <lambdabot> Not in scope: `yield'
08:13:06 <luite> pxqr: yes, if you retry a transaction it's suspended until any of the touched TVars change
08:14:01 <pxqr> luite: reasonable
08:18:42 * hackagebot HaTeX 3.6.0.1 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.6.0.1 (DanielDiaz)
08:24:06 <simon> I'm doing something like a map on a syntax tree, but because expressions have different amounts of sub-expressions, I can't use the same map function for each sub-expression. so I've generalized this to map1, map2, mapN, map1N. can anyone recommend a better way?
08:25:08 <simon> I don't like so much the idea of having one mapN that just fits a list of expressions into a sub-expression's fields and just hopes the lists are long enough at run-time.
08:32:04 <Lethalman> git clone git://darcs.haskell.org/ghc.git times out, should I use the mirror?
08:32:53 <elliott> simon: erm, maybe you want to implement Applicative? unclear from your question
08:38:03 <S_J> Whats a good property test for factorial? fac n == n * fac(n-1) ?
08:38:09 <S_J> or to selfevident?
08:40:39 <copumpkin> S_J: if your definition is a more clever one, you could compare against that one
08:40:43 <elliott> fac n == product [1..n]
08:40:47 <copumpkin> S_J: if that's your definition, then it's kind of pointless
08:41:15 <simon> elliott, that sounds like a good idea.
08:43:06 <osa1_> this function http://hackage.haskell.org/packages/archive/plugins/1.5.3.0/doc/html/System-Plugins-Load.html#v:load_ fails with "undefined" when first parameter is invalid(ie. path is wrong, file does not exists etc.). is there anything I can do about it without modifying it's source?
08:43:35 <hashcat> > let (facList::[Integer]) = 1:[ n * (facList !! (n-1)) | n <- [1..]] ; facList
08:43:36 <lambdabot>   <hint>:1:78:
08:43:36 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
08:43:43 * hackagebot regex-pcre-builtin 0.94.4.7.8.31 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pcre-builtin-0.94.4.7.8.31 (TimothyHobbs)
08:43:55 <osa1_> other than manually checking the file
08:47:33 <hashcat> facList = 1:[ n * (facList !! (n-1)) | n <- [1..]]
08:48:55 <elliott> > let facts = 1 : zipWith (*) facts (tail facts) in facts
08:48:58 <elliott> uh.
08:48:58 <lambdabot>   mueval-core: Time limit exceeded
08:49:26 <Sonarpulse> I know you can abstract over abstract reference types with stuff like Ptr () (when writing FFI bindings)
08:49:32 <Sonarpulse> what about value types?
08:49:42 <Sonarpulse> I have a header with has it's own socket type
08:49:47 <copumpkin> value types?
08:49:47 <Sonarpulse> system specfic
08:49:53 <Sonarpulse> yeah
08:50:09 <Sonarpulse> like its a SCOCKET on windows, and an int on unix
08:50:15 <Sonarpulse> *SOCKET
08:50:42 <copumpkin> just leave it completely abstract and deal with it on a different level
08:50:49 <Sonarpulse> I rather not to #ifdef _Win32 on the haskell end
08:50:57 <Sonarpulse> well that's what I am trying to do
08:51:36 <copumpkin> fundamentally it seems like you'll need to provide some uniformity of interface, or have a conditional on OS
08:52:11 <Sonarpulse> let me link you src
08:53:08 <Sonarpulse> https://github.com/Ericson2314/henet/blob/manual/src/Network/ENet/Bindings/System.hsc
08:53:12 <Sonarpulse> I feel like that should work
08:53:26 <Sonarpulse> on the haskell side you can only pass it around/copy it
08:53:38 <Sonarpulse> and the length is resolved system specific compile time
08:54:01 <Sonarpulse> (should and some peek _ _ = error "not implemented", but that is not causing my compile errors)
08:55:01 <Sonarpulse> also, if you know how to use hsc2hs's #aligment macro, pls let me know :)
08:55:27 <copumpkin> hah nope, never used hsc2hs
08:55:59 <Sonarpulse> well any idea with the main problem?
08:56:14 <Sonarpulse> the wiki only reccomends the EmptyDataDecls trick for reference types
08:57:09 <Sonarpulse> so I am worried FFI will simply complain about them for value types no matter what
08:57:34 <copumpkin> well, fundamentally all you need them to be is a pointer and an int, right? why even keep a storable instance if you don't need to read them
08:57:44 <mauke> oh, does hsc2hs have built-in support for alignment now?
08:58:00 <Sonarpulse> #alignment exists, but is undocumented
08:58:05 <mauke> haha
08:58:21 <Sonarpulse> also, takes 2 arguemnts (I think)
08:58:28 <mauke> it shouldn't
08:58:31 <Sonarpulse> I didn't use it
08:58:38 <mauke> I wrote it
08:58:43 <Sonarpulse> oh!
08:58:54 <Sonarpulse> you write hs2hsc?
08:59:10 <mauke> no, the #ALIGNOF macro
08:59:23 <Sonarpulse> I'll try that
08:59:50 <mauke> what
09:00:00 <Sonarpulse> #ALIGNOF
09:01:19 <Sonarpulse> oops
09:01:30 <Sonarpulse> neither #ALIGNOF #alignof or #alignment is in
09:01:34 <mauke> as far as I can tell there is no #alignment
09:01:36 <mauke> yeah
09:01:40 <Sonarpulse> I miss interpreted the preprocessor error
09:01:42 <Sonarpulse> oh well
09:02:05 <Sonarpulse> well, do you know how i can make https://github.com/Ericson2314/henet/blob/manual/src/Network/ENet/Bindings/System.hsc work then?
09:02:44 <Sonarpulse> copumpkin: I am pretty sure both ultimentally are integer values
09:02:47 <Sonarpulse> no pointers
09:03:08 <mauke> #let alignment t = "%lu", (unsigned long)offsetof(struct {char x__; t (y__); }, y__)
09:03:16 <S_J> so is property based testing really better? I mean you really want to test a function for some edgcases right. So the rand function really has to hit them as well or it is kind of dangerous, makes you think it is ok when it is not. cant you often just explicitly write a function to test for all input sinstead without much more work?
09:03:22 <mauke> may need #include <stddef.h>
09:04:45 <jmcarthur> S_J: i don't think property testing will always replace "old fashioned" unit tests, but it generally is going to catch more
09:05:20 <jmcarthur> S_J: usually the problems with my code are going to be for inputs i didn't anticipate, of course
09:06:12 <jmcarthur> at least not specifically
09:06:58 <Sonarpulse> mauke: how does that work?
09:07:04 <mauke> ~magic~
09:07:09 <mauke> which part of it?
09:08:06 <Sonarpulse> oh actually I get it
09:08:13 <Sonarpulse> ok
09:09:17 <illissius> ...is there any effective difference between a subkind of a kind and a (presumably empty) type class on that kind? (leaving aside the question of how types are added to it)
09:09:32 <Sonarpulse> mauke: but what about my compiling error?
09:09:42 <Sonarpulse> socket.hsc always compiled
09:09:47 <mauke> what error?
09:09:48 <Sonarpulse> *system.hsc
09:10:08 <Sonarpulse> whenever my bindings use any of these types
09:10:12 <Sonarpulse> the FFI complains
09:10:32 <Sonarpulse> it doesn't seem to like emtpy data declerations for value types
09:10:53 <Sonarpulse> (value type as in -> Socket ->, not -> Ptr Socket ->)
09:10:56 <mauke> you can't make value types
09:12:06 <Sonarpulse> I can newtype existing ones, right?
09:12:12 <mauke> yeah
09:12:43 <Sonarpulse> so my best choice
09:13:02 <Sonarpulse> is to hide the constructor
09:13:08 <Sonarpulse> *not export the newtype constructor
09:13:18 <Sonarpulse> for safe #ifdef _win32 newtyping
09:18:37 <Sonarpulse> what about passing structs by value?
09:18:49 <mauke> nope
09:19:23 <Sonarpulse> whew, well the library didn't do it after all
09:21:30 <johnrx> Good morning everybody. :)
09:22:35 <johnrx> I'm having an issue installing the haskell-platform 2013.2
09:24:18 <Sonarpulse> well, it looks like winsock's SOCKET is a UINT too
09:24:24 <Sonarpulse> ... time to cheat!
09:26:28 <elliott> @@ johnrx: @where justask
09:26:29 <lambdabot>  johnrx: Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
09:26:30 <elliott> :)
09:26:41 <isomorphic> If I make a data constructor data Foo = Int | String , what's its constructor?
09:26:56 <isomorphic> (sorry, data type Foo)
09:27:14 <Sonarpulse> ^ Int and String are the constructors
09:27:18 <Sonarpulse> it's an enum
09:27:20 <typoclass> isomorphic: both. you can use either "x = Int" or "y = String"
09:27:21 <Sonarpulse> with confusing names
09:27:22 <newsham_> data RGB = Red | Green | Blue    <-  there are three constructors, Red, green and Blue
09:27:38 <newsham_> iso: perhaps you meant:   data Foo = Foo1 Int | Foo2 String    ?
09:27:54 <isomorphic> newsham_Yes, that's the effect I'm looking for.
09:28:09 <isomorphic> I want more or less a type that's a union of other types
09:28:27 <newsham_> so then "Foo1" is a constructor and "Foo1 3" is a value
09:29:04 <isomorphic> newsham_:  That's perfect, thanks :)
09:29:15 <newsham_> yw
09:29:34 <isomorphic> thanks everyone :)
09:29:47 <johnrx> Ah oh thanks :)
09:29:47 <johnrx> Well building the haskell platform-2013.2 on CentOS 6.4 fails because Alex is searching for Happy, which isn't installed at the time... I did download the most recent sources on the website.
09:31:03 <elliott> hm, I thought the HP install bootstrapped happy
09:31:17 <elliott> johnrx: you may be interested in http://www.justhub.org
09:33:34 <johnrx> elliott : they don't seem to have the latest haskell-platform on there though. I was curious to try it :)
09:34:30 <pxqr> where is something like forM_,mapM_, foldM etc.. for Data.Set?
09:34:50 <pxqr> no way to avoid toList?
09:35:53 <geekosaur> Data.Traversable?
09:37:07 <pxqr> Data.Set have no instance for Traversable because it requres (Ord a)
09:37:27 <Fuuzetsu> @pl a f g t = first f <$> g t
09:37:27 <lambdabot> a = (.) . (<$>) . first
09:37:32 <Sonarpulse> are C enums always CInt ?
09:38:17 <jmcarthur> pxqr: even the lens library doesn't have one. this is the best there is, there: http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/Data-Set-Lens.html
09:38:29 <jmcarthur> pxqr: s/have one/have a traversal for it/
09:38:34 <Sonarpulse> or CUInt ?
09:39:08 <pxqr> jmcarthur: oh i can use forM_ from Data.Foldable
09:40:06 <pxqr> Data.Set have instance for Foldable (no tree rebuilding => no (Ord a))
09:40:13 <jmcarthur> yup
09:40:33 <jmcarthur> sorry, i missed your actual question and focused on Traversable
09:40:38 <elliott> jmcarthur: i think we do have a traversal for it
09:40:41 <elliott> just in one of the generic modules
09:40:44 <elliott> like Map
09:41:02 <jmcarthur> oh?
09:41:10 <elliott> not sure though
09:41:13 <elliott> take a look at .Each
09:41:55 <jmcarthur> elliott: i don't see anything particularly interesting there
09:42:11 <jmcarthur> elliott: there is Map, of course, but there is no difficultly in Map anyway
09:42:51 <elliott> well I may be wrong :)
09:42:52 <jmcarthur> i'm not even sure a valid Traversal is possible
09:43:05 <elliott> oh I guess not
09:43:05 <jmcarthur> since it would reorder and dedup all your results anyway
09:43:15 <jmcarthur> assuming the Ord constraint isn't a problem in the first place
09:43:32 <elliott> right
09:43:34 <elliott> (it isn't)
09:43:39 <jmcarthur> just wasn't sure
09:43:51 <jmcarthur> but yeah, reordering and deduping sounds problematic either way
09:46:31 <benmachine> @pl let (x,y) = (1,2) in y
09:46:31 <lambdabot> (line 1, column 5):
09:46:31 <lambdabot> unexpected "("
09:46:31 <lambdabot> expecting "()", natural, identifier or "in"
09:46:41 <benmachine> ^ does anyone expect this to work, or care if it does/does not?
09:46:49 <elliott> well, @pl is totally broken.
09:46:53 <benmachine> it's a failing testcase in the pointfree package that I've never seen pass
09:46:58 <elliott> so that's more generating of care for me.
09:47:09 <elliott> @pl \x y z -> x + y z
09:47:09 <lambdabot> (.) . (+)
09:47:11 <elliott> ugh
09:47:13 <elliott> it just had to work that one time
09:47:25 <benmachine> elliott: I think it's the pointfree binary package that's broken
09:47:31 <elliott> @pl \x y z -> x >>= \foo -> y (z x)
09:47:34 <lambdabot> ap ((.) . (.) . (>>=)) (fmap (const .) . flip (.) . flip id)
09:47:34 <lambdabot> optimization suspended, use @pl-resume to continue.
09:47:36 <elliott> there.
09:47:38 <benmachine> the lambdabot plugin is different
09:47:38 <elliott> it does that all the time.
09:47:42 <benmachine> oh ok
09:47:42 <elliott> likes getting stuck on ($)s and stuff
09:47:45 <elliott> benmachine: oh hm
09:47:50 <elliott> benmachine: maybe it's using the command-line version now
09:47:56 <benmachine> elliott: I maintain the command-line version
09:47:58 <elliott> since I think there was a push to get rid of duplicated code in lambdabot
09:48:00 <benmachine> except "maintain" is a strong word
09:48:02 <benmachine> it doesn't work
09:48:07 <elliott> okay great, well you should fix it
09:48:08 <benmachine> @pl return ()
09:48:08 <lambdabot> return ()
09:48:17 <benmachine> ^ in the current command line version, that's just "return"
09:48:26 <benmachine> I think it's something to do with the parsec parser being screwed up
09:48:33 <elliott> okay I was wrong -- it still has its own copy of the pl code
09:48:38 <benmachine> I'm midway through replacing it with the haskell-src-exts parser
09:48:41 <elliott> however, if you fix it I can fix @pl being broken by making it use your version instead
09:48:54 <benmachine> I've got nine failing test cases left, or thereabouts
09:48:56 <elliott> do you offer a trivial API?
09:48:59 <elliott> that's more convenient than spawning a process
09:49:06 <benmachine> elliott: not yet, but I could
09:49:50 <elliott> just String -> String would be enough
09:50:07 <elliott> though I guess @pl-resume would need work
09:50:07 <benmachine> elliott: noted
09:50:25 <benmachine> elliott: I don't understand this code much better than anyone else
09:50:32 <elliott> maybe String -> SomeMeasureOfTime -> IO String or something :)
09:50:36 <benmachine> hah
09:50:42 <benmachine> maybe
09:51:37 <benmachine> String -> Tuits -> Maybe String
09:53:08 <elliott> does it have an internal measure of time?
09:53:14 <elliott> I think you need to return a String even if it times out
09:53:22 <elliott> because @pl gives a partial result and feeds it back into @pl-resume or such
09:53:47 <benmachine> elliott: I don't know how that bit works yet, I'm still focussing on the parser
09:53:53 <elliott> alright
09:56:07 <FreeFull> @pl \a -> b const a
09:56:07 <lambdabot> b const
09:56:11 <FreeFull> @pl \a -> b (const a)
09:56:11 <lambdabot> b . const
09:57:32 <FreeFull> @pl concatMap (\x -> when (x>3) [x]) [1,2,3,4,5]
09:57:35 <lambdabot> concatMap (ap (when . (> 3)) (: [])) [1, 2, 3, 4, 5]
09:57:35 <lambdabot> optimization suspended, use @pl-resume to continue.
09:57:40 <FreeFull> > concatMap (\x -> when (x>3) [x]) [1,2,3,4,5]
09:57:42 <lambdabot>   No instance for (GHC.Num.Num ()) arising from the literal `3'
09:57:42 <lambdabot>  Possible fix...
09:58:10 <FreeFull> > concatMap (\x -> when (x>3) [()]) [1,2,3,4,5]
09:58:12 <lambdabot>   [(),(),(),(),()]
09:58:20 <FreeFull> Ok, that's not very useful
10:01:01 <Sonarpulse> what do you guys think of converting CInt error returns to Bool?
10:05:47 <S_J> What is the most idiomatic way to deal with fac 0 in haskell? error or Nothing?
10:05:52 <S_J> or just trust the caller not to call with 0?
10:06:08 <hpc> https://www.wolframalpha.com/input/?i=0!
10:06:59 <S_J> (-1)! then?
10:07:01 <S_J> infinity
10:07:02 <luite> don't forget to encode the !
10:07:14 <S_J> complex infinity even!
10:07:16 <S_J> encode?
10:07:17 <luite> oh hmm, that's interesting
10:07:19 <copumpkin> S_J: fac 0 = 1
10:07:29 <S_J> fac (-1) = complex infinity
10:07:40 <luite> my terminal thought that the ! wasn't part of the url
10:07:48 <copumpkin> S_J: if you want the generalization, look up the gamma function, but fac 0 is definitely 1
10:08:08 <hpc> luite: the only thing consistent about url regexes is their poor quality ;)
10:08:14 <jmcarthur> S_J: see the recursive definition here: http://en.wikipedia.org/wiki/Factorial
10:09:49 <FreeFull> S_J: Is your factorial function only over integers?
10:10:25 <themagneticduck_> hey guys, is CReal a good choice for a light game engine?
10:10:49 <elliott> um, not really
10:10:50 <elliott> CReal doesn't even have decidable equality/
10:11:03 <themagneticduck_> it'd represent a vector
10:11:15 <themagneticduck_> and actually, if I used a Double, I wouldn't be able to decide equality either
10:11:33 <benmachine> themagneticduck_: Doubles can have equality in some cases
10:11:39 <elliott> also, it will be incredibly slow.
10:11:42 <themagneticduck_> > (sqrt 2) ^ 2
10:11:43 <lambdabot>   2.0000000000000004
10:11:44 <themagneticduck_> >_>
10:11:45 <themagneticduck_> > (sqrt 2) ^ 2 :: DOuble
10:11:46 <lambdabot>   Not in scope: type constructor or class `DOuble'
10:11:47 <lambdabot>  Perhaps you meant `Double...
10:11:49 <themagneticduck_> > (sqrt 2) ^ 2 :: Double
10:11:50 <lambdabot>   2.0000000000000004
10:11:50 <benmachine> but yes, it will probably be incredibly slow
10:12:00 <themagneticduck_> hm, alright
10:12:04 <byorgey> themagneticduck_: if you want extra accuracy, you should instead look at the compensated package
10:12:07 <dolio> Using CReal will not result in a light game engine. :)
10:12:07 <byorgey> @package compensated
10:12:07 <lambdabot> http://hackage.haskell.org/package/compensated
10:12:16 <benmachine> I'd be really interested to see how the performance of http://hackage.haskell.org/package/cyclotomic held up
10:12:20 <benmachine> but I suspect it's not optimised
10:12:25 <themagneticduck_> yeah, I did some proliminary tests, and it looks like CReal isn't very.. fast
10:12:29 <benmachine> I guess it depends how much performance you need
10:12:40 <themagneticduck_> I'd like to be able to scale things indefinitly though
10:12:41 <benmachine> themagneticduck_: well, you ask a computer to solve a difficult problem, it'll take its time about it :P
10:12:50 <themagneticduck_> no rounding error is kind of a nice prospect
10:12:54 <benmachine> themagneticduck_: would Rational do?
10:13:08 <themagneticduck_> I'm doing euclidean geometry routines
10:13:13 <themagneticduck_> lots of sqrts
10:13:14 <benmachine> (probably /still/ slower than Float/Double, people have gotten really good at optimising them)
10:13:16 <themagneticduck_> and exponents
10:13:18 <themagneticduck_> :P
10:13:39 <benmachine> themagneticduck_: cyclotomic will get you some sqrts
10:13:40 <elliott> I really don't suggest using CReal for anything non-academic.
10:13:44 <benmachine> what kind of exponents are they?
10:14:12 <themagneticduck_> well, just the fact that I'm using sqrt renders Rationals pretty useless in terms of trying to get precision
10:14:25 <themagneticduck_> uh
10:14:28 <benmachine> themagneticduck_: in principle all floats represent rationals :P
10:14:31 <themagneticduck_> > (sqrt 2) :: Rational
10:14:32 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
10:14:32 <lambdabot>    arising from a us...
10:14:39 <themagneticduck_> mathematically yeah
10:14:57 <themagneticduck_> just sometimes not the ones you want
10:14:58 <themagneticduck_> :P
10:15:14 <benmachine> themagneticduck_: I mean to imply that you could take a rational approximation to a square root
10:15:20 <benmachine> and indeed you will almost certainly have to :P
10:15:25 <benmachine> but no
10:15:28 <byorgey> I don't see how that would help.
10:15:32 <benmachine> floats and doubles are almost certainly the right answer
10:15:41 <dolio> Do you really need more precision than a Double?
10:15:46 <themagneticduck_> alright
10:15:50 <jmcarthur> themagneticduck_: i really doubt that rounding error is going to be a big deal in a game engine. physical accuracy is not is good as "feeling right" anyway, in games
10:15:57 <themagneticduck_> well, I just wouldn't be able to scale things after I made them
10:15:58 <dolio> Or two Doubles, if you're using the package byorgey recommended?
10:16:07 <themagneticduck_> like, 10^whatever it is
10:16:12 <byorgey> you can even nest Compensated so you can get as many Doubles as you want.
10:16:18 <themagneticduck_> not that that's a huge problem, but I want to have some good foundations
10:16:25 <dolio> Yeah.
10:16:30 <themagneticduck_> as precise as possible; besides, I'm actually making a geometry engine right now
10:16:35 <themagneticduck_> and I might want to use it for other things
10:16:49 <themagneticduck_> mm, looking into COmpensated
10:16:55 <byorgey> themagneticduck_: in that case I suggest that you simply parameterize everything over the numeric type
10:17:03 <jmcarthur> huh, i've never heard of Compensated
10:17:07 <themagneticduck_> I see
10:17:14 <byorgey> then you can instantiate it with Double, Compensated Double, etc., whatever is necessary to get the precision needed for a particular application
10:17:14 <themagneticduck_> looks cool
10:17:22 <dolio> jmcarthur: It's something edwardk banged out in a couple days, I think.
10:17:36 <themagneticduck_> uh, looks like a bit more than that
10:17:37 <byorgey> jmcarthur: it's pretty new, spun out of edwardk's current work on 'analytics'
10:17:58 <jmcarthur> neat
10:18:26 <byorgey> themagneticduck_: if you think 'compensated' looks like it took edwardk more than a couple days, you don't know edwardk.
10:18:32 <themagneticduck_> hah
10:18:39 <byorgey> in fact I doubt it took him one.
10:19:04 <dolio> I wouldn't go that far.
10:19:08 <dolio> I think I was there.
10:19:40 <dolio> We spent a couple hours playing with adding circuits.
10:19:48 <dolio> After that it was pretty easy, I suspect.
10:20:31 <haasn> byorgey: where have I heard that line before...
10:20:37 <dolio> So, probably like 4 hours at least. :)
10:20:54 <haasn> “huge library Y, spun out of edwardk's current work on X”
10:20:55 <themagneticduck_> probably everywhere
10:23:43 <themagneticduck_> parmetizing something deep down in a nested project is always fun
10:23:53 <themagneticduck_> it feels a bit like drilling a hole
10:24:05 <FreeFull> The entirety of lens took edwardk 5 minutes
10:24:36 <themagneticduck_> so, edwardk is a bit of a Chuck Norris figure around here I presume
10:25:34 <benmachine> I don't like Chuck Norris
10:25:45 <benmachine> but yes
10:25:46 <benmachine> more or less
10:26:38 <mm_freak_> @add-command edwardk-facts
10:26:38 <lambdabot> Unknown command, try @list
10:26:49 <thoughtpolice> if you look at the contributors graph for lens, the edwardk factor is pretty hysterical
10:27:16 <mm_freak_> edwardk fact: "Edwardk knows how to get out of a monad. Twice."
10:28:15 <thoughtpolice> shachaf comes in #2nd place with about 7k total lines of code both added, and deleted. ed is #1 with only, oh, 70,000 inserts and 50,000 deletions alone
10:29:17 <ion> ed wardk
10:29:27 <mm_freak_> i always knew it
10:29:36 <mm_freak_> instance Comonad RoundhouseKick where …
10:29:51 <byorgey> themagneticduck_: the proper parallel to Chuck Norris around here is Oleg.  edwardk is actually around so it's hard for him to be quite so mythical.
10:30:13 <mm_freak_> indeed
10:31:15 <joelteon> we should make do-notation for comonads and it just uses -> instead of <-
10:31:26 <byorgey> edwardk is more like the Paul Erdos of Haskell.  Instead of turning coffee into theorems he turns diet coke into packages.
10:31:44 <ion> He drinks diet coke? :-(
10:31:45 <mm_freak_> what's that π joke equivalent for oleg?  "Oleg knows what's at the end of foldr f z [1..]."
10:31:57 <byorgey> ion: I think so, not 100% sure though
10:32:04 <ion> I’m sad for his aspartame poisoning.
10:32:08 <byorgey> mm_freak_: haha, I like it
10:32:33 <mm_freak_> joelteon: i've never really needed co-do, and i use comonads a lot
10:32:46 <joelteon> I've never needed co-do either, but I've never consciously used a comonoda
10:32:48 <mm_freak_> although it's 99% store comonad =)
10:32:48 <joelteon> comonad.
10:32:51 <FreeFull> > concatMap (filter (>3) . return) [1..5]
10:32:52 <lambdabot>   [4,5]
10:32:57 <joelteon> damn alternating vowels
10:32:57 <mm_freak_> comonoda =)
10:33:12 <byorgey> joelteon: there has actually been some work on that.
10:33:14 <joelteon> "ok, are we out of os yet? better add one more, the a comes after the next consonant"
10:33:23 <joelteon> comand
10:33:25 <FreeFull> :t \f -> concatMap (f . return)
10:33:25 <lambdabot> Monad m => (m a -> [b]) -> [a] -> [b]
10:33:27 <joelteon> typing is hard
10:34:04 <ion> Was it okay to @remember a part of a message? Like this. Please edit if it’s not.
10:34:06 <ion> @remember mm_freak Oleg knows what's at the end of foldr f z [1..].
10:34:07 <lambdabot> Done.
10:34:16 <mm_freak_> oh, there is this bruce schneier joke:  he counted to infinity. twice.
10:34:31 <joelteon> "one, two, three, ..., infinity"
10:34:34 <mm_freak_> oleg equivalent:  "Oleg knows what's at the end of foldr f z [1..].  For all f."
10:34:49 <FreeFull> :t \f -> concatMap (f . (:[]))
10:34:50 <lambdabot> ([a] -> [b]) -> [a] -> [b]
10:34:54 <FreeFull> @pl \f -> concatMap (f . (:[]))
10:34:57 <lambdabot> (=<<) . (. return)
10:34:57 <lambdabot> optimization suspended, use @pl-resume to continue.
10:35:05 <FreeFull> @pl-resume
10:35:10 <mm_freak_> @quote schneier
10:35:11 <lambdabot> (=<<) . (. return)
10:35:11 <lambdabot> optimization suspended, use @pl-resume to continue.
10:35:11 <lambdabot> mm_freak says: bruce schneier is an endofunctor that turns all automorphisms into identities
10:35:28 <FreeFull> I was hoping to see it optimise to something less
10:35:57 <FreeFull> :t id :: ([a] -> [b]) -> [a] -> [b]
10:35:58 <lambdabot> ([a] -> [b]) -> [a] -> [b]
10:36:10 <themagneticduck_> I have to learn lenses someday.
10:36:16 <themagneticduck_> they sound really great and ninja-y
10:36:19 <mm_freak_> FreeFull: \f -> concatMap (f . pure) = flip (>>=) . (. pure)
10:36:37 <mm_freak_> i don't think you can optimize that much further
10:36:49 <mm_freak_> also i'd hardly call this an optimization
10:36:53 <FreeFull> mm_freak_: Because you're using applicatives rather than just lists
10:36:53 <themagneticduck_> lol, love that analogy byorgey (was afk)
10:36:54 <dolio> flip (>>=) = (=<<)
10:36:57 <dolio> Optamized.
10:37:12 <mm_freak_> FreeFull: the original pointed version is the nicest
10:37:50 <FreeFull> mm_freak_: You can optimise it down to id if you use only lists
10:37:54 <themagneticduck_> > let x = ('a':x) in head x
10:37:55 <lambdabot>   'a'
10:37:58 <themagneticduck_> huh
10:38:04 <themagneticduck_> > let x = ('a':x) in last x
10:38:33 <themagneticduck_> just makin' sure; should probably have done that in GHCi, but whatever
10:39:08 <mm_freak_> FreeFull: i don't know how much lambdabot applies laws
10:39:15 <mm_freak_> i guess it's strictly syntactic
10:39:33 <joelteon> > let !x = ('a':x) in head x
10:39:34 <lambdabot>   <hint>:1:5:
10:39:34 <lambdabot>      Illegal bang-pattern (use -XBangPatterns):
10:39:34 <lambdabot>      ! x
10:39:38 <joelteon> rats
10:40:13 <FreeFull> > let x = seq x ('a':x) in head x
10:40:17 <lambdabot>   mueval-core: Time limit exceeded
10:44:00 <min|dvir|us> Why do we use Nothing rather than Nil in monads?
10:44:24 <pxqr> getChanContents always returns infinite list?
10:45:06 <geekosaur> what is Nil?
10:45:23 <ion> We don’t use Nothing in any other monad than Maybe.
10:45:40 <pxqr> cuz we can't :(
10:46:31 <Cale> min|dvir|us: "In monads" is a strange thing to say there
10:46:59 <FreeFull> Nothing is just a part of Maybe
10:47:01 <FreeFull> :t Nothing
10:47:01 <typoclass> min|dvir|us: Nothing doesn't have much to do with monads. if you meant, why did they choose the name Nothing (and not Nil, or None, or some other name), i don't really know. they easily could have chosen another name
10:47:02 <lambdabot> Maybe a
10:47:03 <Cale> min|dvir|us: Nothing is specifically a value of type Maybe a, and has nothing to do with general monads.
10:47:29 <monochrom> I am going to guess: the question means "why is it named Nothing, not Nil"
10:47:55 <monochrom> and my answer: too bad your favourite name wasn't chosen when you were away
10:47:56 <pxqr> None is shorter; ML wins again
10:48:06 <FreeFull> Maybe because Nil indicates something similar to 0, where Nothing just indicates not having anything
10:48:35 <FreeFull> pxqr: You probably use perl then
10:48:38 <monochrom> but ML loses out with :: for cons :)
10:48:40 <typoclass> monochrom: well, None would have been nice (shorter). data Maybe = None | Some a ... why not, why not
10:48:53 <peterjoel> hi, anyone know if it's possible to export all lenses (created with Control.Lens makeLenses) without having to do it explicitly?
10:48:54 <pxqr> FreeFull: no, thanks :)
10:48:54 <FreeFull> :: makes more sense for cons though
10:49:00 <S_J> So is this correct: Property based testing is well suited for testin datastructures sicne it is hard or impossible to cover every case. But property based testing is less relevant for for example mathematical functions.
10:49:13 <nooodl> it uses : for type signatures?
10:49:25 <FreeFull> Since all other List operators use two characters
10:49:26 <monochrom> well, yeah, "loses out" as in shortness competition, but I don't mind either way :)
10:49:44 <nooodl> because i use "::" in haskell much more often than (:)
10:49:48 <FreeFull> pxqr: But perl is shorter than everything else
10:49:51 <monochrom> yes nooodl, f : int list, f = 0 :: 1 :: []
10:50:14 <Clint> peterjoel: you can put just what you want to export into a separate module, then import and export the entire new module from where they used to be
10:50:22 <pxqr> FreeFull: too shorter
10:50:43 <pxqr> property based testing is similar to smoke tests
10:50:45 <nooodl> APL!
10:50:54 <peterjoel> ah ok, yes that will work. Thanks Clint.
10:50:55 <pxqr> if you are pessimistic
10:50:59 <chrisdotcode> hi all
10:51:01 <Cale> nooodl: But often when you're writing a list with conses, you're going to use more than one, and :: is more annoying as a delimiter if there are lots of them.
10:51:06 <monochrom> ML also has nil for [], you can use either
10:51:20 <nooodl> Cale: hmm, that's true
10:51:25 <S_J> pxqr: smoke tests?
10:51:31 <nooodl> stuff like (a::b::as) looks bad
10:52:55 <pxqr> S_J: it could cover the most cases, but even for simple datastructures QC not always cover all cases;
10:53:10 <pxqr> you can use HPC to control this
10:53:17 <S_J> HPC?
10:53:44 <S_J> thats what im saying kind of, sicne it is random, you can never really trust it.
10:53:57 <pxqr> S_J: Haskell Program Coverage -- http://www.haskell.org/haskellwiki/Haskell_program_coverage
10:54:16 <hpc> S_J: hello!
10:54:39 <S_J> :)
10:54:50 <pxqr> S_J: yes, but in practice it catch most bugs, depending on how good you property set
10:55:07 <pxqr> (in my experience at least)
10:59:09 <S_J> pxqr: well if it doesnt how do you know :)
11:00:26 <monochrom> you know when users tell you next month
11:00:37 <pxqr> yes
11:00:53 <monochrom> but you have already received payment, so you don't care
11:01:28 <S_J> well i guess you want to keep receivin payment
11:01:28 <S_J> now to more important issues
11:01:28 <S_J> sushi or pizza?
11:01:34 <min|dvir|us> Pizza.
11:02:00 <monochrom> you will still get their business next time. it is not like your competitors do any better.
11:02:27 <monochrom> yes I'm almost painting programmers as a cartel of scam
11:03:19 <ksf> S_J, you can direct quickcheck to be non-random, and, more importantly, direct it to generate values for edge cases over the bulk ones.
11:03:32 <typoclass> lambdabot: you're not a cartel of scam :-( good girl
11:03:35 <ksf> that is yes, it's able to serve as unit test.
11:03:36 <typoclass> @botsnack
11:03:36 <lambdabot> :)
11:36:44 <orzo> anybody use MaybeT much?
11:37:07 <orzo> i have some code where i used it all over the place to do quit-on-exception type things
11:37:24 <benmachine> orzo: I've used it before
11:37:25 <prophile> I experimented with MaybeT a time or two, and I didn't like it. I didn't instantiate and never tried it again.
11:37:31 <orzo> but then i found it started tempting me to just ignore exceptions
11:37:41 <orzo> by exception here i mean "Nothing"
11:37:55 <prophile> ignoring nothing seems pretty disciplined
11:38:00 <Eduard_Munteanu> There's Either if you need meaningful errors.
11:38:01 <orzo> heh
11:38:03 <chrisdone> ignoring exceptions is ok, because they're exceptional
11:38:33 <chrisdone> if something's expected to fail, that's an error case, and you should handle it
11:39:33 <orzo> well my sistuation is that i'm talking on a socket to client that is supposed to be following an rfc, there's cases where i expect no failure, but the client cna make one if they violate spec
11:40:19 <orzo> i started using <- to pull out maybe values because Maybe itself feels rather combersomem
11:40:36 <robde> hello, using Parsec, how can I match an additional character followed by each line in this expression? do lines <- many line ..
11:40:56 <robde> something like do lines <- many (line char '.')?
11:41:12 <orzo> i dont know
11:42:04 <applicative> robde: is the additional character at the end of each line?
11:42:12 <benmachine> robde: it's been a while since I've done this stuff, but you might want <* from Control.Applicative
11:42:16 <benmachine> line <* char '.'
11:42:28 <k0ral> Hello guys, I'm looking for a Haskell project to get committed on, whether it is a new one to start, or an existing one that would welcome contributions; any suggestions/advertisement ? :)
11:42:31 <benmachine> that will give you jsut the line
11:42:46 <applicative> that's what I was going to suggest but the . will be on the next line
11:43:00 <benmachine> applicative: huh?
11:43:17 <robde> oh, right, it will be next line :/
11:43:21 <chrisdone> manyTill anyChar newline, or so
11:43:57 <chrisdone> or manyTill (char '.') <* newline
11:43:59 <applicative> manyTill anyChar (char '.' >> newline)
11:44:03 <chrisdone> depending on whether you want the char included
11:44:12 <applicative> bah mine was a mess
11:44:21 <orzo> prophile: why do you dislike maybet ?
11:45:07 <orzo> i have code that uses MaybeT that i'm about to rewrite
11:45:15 <chrisdone> oh, does lambdabot have parsec?
11:45:21 <chrisdone> :t Text.Parsec.parse
11:45:22 <lambdabot> Text.Parsec.Prim.Stream s Identity t => Text.Parsec.Prim.Parsec s () a -> Text.Parsec.Pos.SourceName -> s -> Either Text.Parsec.Error.ParseError a
11:45:23 <applicative> no, it's really irritating
11:45:23 <orzo> and i'm pondering whether to carry over the MaybeT into the rewrite
11:45:24 <chrisdone> cool!
11:45:28 <elliott> prophile is making a reference to something Bill Clinton said once, but I can't for the life of me work out why
11:46:03 <chrisdone> :t Text.Parsec.parse (manyTill anyChar (char '.') <* newline) "" "hello.\n"
11:46:04 <lambdabot> Not in scope: `manyTill'
11:46:04 <lambdabot> Not in scope: `anyChar'
11:46:04 <lambdabot> Not in scope: `newline'
11:46:26 <chrisdone> :t Text.Parsec.parse (Text.Parsec.manyTill Text.Parsec.anyChar (Text.Parsec.char '.') <* Text.Parsec.newline) "" "hello.\n"
11:46:26 <lambdabot> Either Text.Parsec.Error.ParseError [Char]
11:46:29 <chrisdone> > Text.Parsec.parse (Text.Parsec.manyTill Text.Parsec.anyChar (Text.Parsec.char '.') <* Text.Parsec.newline) "" "hello.\n"
11:46:30 <lambdabot>   Not in scope: `Text.Parsec.parse'Not in scope: `Text.Parsec.manyTill'Not in...
11:46:34 <chrisdone> lol
11:46:35 <chrisdone> what?
11:46:39 <applicative> > Text.Parsec.parse (Text.Parsec.char ".") "" "."
11:46:39 <lambdabot>   Not in scope: `Text.Parsec.parse'Not in scope: `Text.Parsec.char'
11:46:52 <elliott> chrisdone: :t and > can disagree
11:46:54 <chrisdone> :t and > are inconsistent
11:46:54 <lambdabot>     Not in scope: `are'
11:46:54 <lambdabot>     Perhaps you meant `arr' (imported from Control.Arrow)
11:46:54 <lambdabot> Not in scope: `inconsistent'
11:46:59 <elliott> chrisdone: :t can find anything installed
11:47:08 <elliott>  > only works with... some things
11:47:20 <elliott> @let import Text.Parsec
11:47:21 <lambdabot>  Defined.
11:47:27 <chrisdone> > Text.Parsec.parse (manyTill anyChar (char '.') <* newline) "" "hello.\n"
11:47:28 <lambdabot>   Ambiguous occurrence `char'
11:47:28 <lambdabot>  It could refer to either `Text.Parsec.Char.cha...
11:47:29 <applicative> I think it would be awesome if it had a few bits of Parsec exposed
11:47:34 <chrisdone> > Text.Parsec.parse (manyTill anyChar (Text.Parsec.char '.') <* newline) "" "hello.\n"
11:47:35 <lambdabot>   Right "hello"
11:47:37 <chrisdone> yaaaay
11:47:38 <elliott> I don't actually know why > works with fully qualified lens names but not fully qualified Parsec names.
11:47:40 <applicative> oh
11:47:54 <elliott> it is conflicting with prettyprinting for "char" there
11:47:55 <chrisdone> yeah, exposing parsec as P would be ok?
11:48:00 <elliott> @undefine
11:48:00 <lambdabot> Undefined.
11:48:06 <elliott> @import import qualified Text.Parsec as P
11:48:07 <lambdabot> Unknown command, try @list
11:48:07 <Banistergalaxy>  Is haskells support for concurrent/multi thread programming as sophisticated as scalas and clojures?
11:48:09 <elliott> @let import qualified Text.Parsec as P
11:48:10 <lambdabot>  Defined.
11:48:12 <elliott> anyone can do that, btw.
11:48:20 <elliott> also P might already be something, but whatever.
11:48:26 <chrisdone> i never knew @let supported any line o_o
11:48:30 <elliott> it didn't
11:48:34 <chrisdone> @let -- hello
11:48:35 <lambdabot>  Defined.
11:48:37 <chrisdone> lol
11:48:38 <orzo> i'm not familiar with scalas and clojures, but haskell multithreaded is impressive
11:48:41 <elliott> Banistergalaxy: sure. it has good support. parallel strategies, STM, efficient threading, async IO implementation...
11:48:47 <chrisdone> @let {-# LANGUAGE TemplateHaskell #-}
11:48:47 <lambdabot>  Parse failed: Parse error: EOF
11:48:47 <applicative> Banistergalaxy: oh, come on scala and clojure are always playing catch up
11:48:50 <chrisdone> =p
11:48:58 <kmc> i think Clojure's STM is fancier than GHC's
11:49:06 <elliott> Banistergalaxy: but I don't think comparing them is worthwhile
11:49:11 <Banistergalaxy> Cool
11:49:13 <applicative> kmc heresy!
11:49:14 <elliott> what's important is that Haskell has very good support
11:49:26 <FreeFull> kmc: How come?
11:49:30 <elliott> kmc: well, it still does sort of badly because of the no side-effect tracking right? :/
11:49:38 <elliott> though I assume you're referring to something else about it
11:49:54 <kmc> it has some kind of hybrid optimistic locking-based MVCC something
11:50:37 <Banistergalaxy> Also what would you guys recommend for a restful API in haskell? I looked at yeseod but it's too weird for me
11:50:55 <applicative> Banistergalaxy: here's a partial manuscript from one of the ghc brains http://ofps.oreilly.com/titles/9781449335946/ and an earlier essay community.haskell.org/~simonmar/par-tutorial.pdf
11:51:22 <chrisdone> yesod and happstack are pretty good with type-safe urls
11:51:41 <chrisdone> you can do it ontop of snap too, but it's not default
11:52:53 <elliott> Banistergalaxy: in general, haskell will have lots of things that are too weird; I recommend taking it as a learning opportunity :p
11:53:12 <hpc> weird is always better :P
11:55:16 <benmachine> I think I've found a bug in haskell-src-exts, having some difficulty locating the bug tracket
11:55:20 <benmachine> anyone know where it is?
11:55:47 <elliott> "bug: takes five years to compile"
11:56:01 <byorgey> benmachine: yes, let me find you a link
11:56:23 <benmachine> it's exhibited by parsePat "(a:b:c):d" getting the fixities wrong
11:56:41 <benmachine> gives you ((a:b):c):d roughly speaking
11:56:41 <byorgey> I told Niklas to add a bug-tracker: field to the .cabal file but it looks like he hasn't taken me up on the advice yet
11:56:52 <benmachine> even though "a:b:c" gets you a:(b:c)
11:57:06 <benmachine> byorgey: right, and the homepage is not much use
11:57:12 <byorgey> indeed
11:58:02 <hpc> elliott: i always like agda bug reports: "bug: it compiles"
11:58:26 <chrisdone> benmachine: yeah, while you're at it, be wary of bang patterns without parens, it fails to parse them in some contexts
11:58:29 <byorgey> benmachine: still finding the link, hang tight
11:58:43 <tomboy64> > map (zip (repeat 5)) [1..6]
11:58:43 <lambdabot>   No instance for (GHC.Show.Show b0)
11:58:44 <lambdabot>    arising from a use of `M1096187413.sh...
11:58:47 <byorgey> pretty sure it's in my archived inbox but it takes a long time to load =P
11:58:54 <tomboy64> why does that not work?
11:58:57 <elliott> hpc: haha :)
11:59:16 <tomboy64> okay
11:59:16 <Banistergalaxy> Elliott tag the various templating languages with shakespearean names made me cringe ;)
11:59:17 <tomboy64> nvm
11:59:20 <tomboy64> i'm being a moron
11:59:26 <chrisdone> tomboy64: because zip isn't being given two lists
11:59:34 <tomboy64> yes
11:59:36 <tomboy64> i just saw
12:02:57 <FreeFull> > map (zip (repeat 5)) [[1..6]]
12:02:57 <lambdabot>   [[(5,1),(5,2),(5,3),(5,4),(5,5),(5,6)]]
12:03:47 * hackagebot hsbencher 1.2 - Flexible benchmark runner for Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.2 (RyanNewton)
12:04:44 <Cubic_> Does anyone know if there are any plans to add an if-function to Prelude someday?
12:05:07 <byorgey> benmachine: http://trac.haskell.org/haskell-src-exts/
12:05:24 <benmachine> byorgey: aha
12:05:26 <typoclass> Cubic_: not sure if there's plans, but it's quite easy to write one yourself, if you want. also, there's of course the existing if then else
12:05:38 <typoclass> > if 3 > 5 then "lol" else "cats"
12:05:39 <lambdabot>   "cats"
12:05:39 <byorgey> benmachine: wait, no!!
12:05:44 <byorgey> benmachine: sorry, I gave you the wrong one
12:06:00 <benmachine> (things I did not notice: ghc was sitting on half of my memory and agda a further 10%, so then when I tried to load lots of images in firefox it died)
12:06:17 <byorgey> benmachine: http://code.google.com/p/haskell-src-exts/issues/list  -- this is the current one
12:06:20 <benmachine> aha
12:06:23 <benmachine> thanks :)
12:06:28 <byorgey> sure =)
12:07:46 <benmachine> yeah, loading the HSE source in ghci chews memory like nobody's business
12:08:03 <benmachine> possibly something to do with the happy generated source
12:08:48 * hackagebot module-management 0.10 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.10 (DavidFox)
12:12:32 <robde> in practice, how fluently do I need to know the "inner workings" of monads.. should I always be able to reimplement everything I use?
12:12:56 <tomboy64> which is faster, rem or mod?
12:13:09 <tomboy64> or rather, what is the difference, since both give the same result?
12:13:28 <hpc> tomboy64: typically rem is the machine instruction and mod is rem plus a sign check
12:13:34 <elliott> they don't give the same result on negative values
12:13:48 <hpc> but it's not guaranteed
12:14:05 <tomboy64> so rem should be faster if i don't care about negative values?
12:14:08 <benmachine> robde: often if you learn enough about them to reimplement them you'll realise you didn't need them anyway :P
12:14:12 <tomboy64> marginally
12:14:27 <kmc> robde: you don't really need it, but most of the standard monads (Reader, State, etc.) can be implemented in a few lines of code, and it's fun to do so
12:14:50 <hpc> it can be significantly faster if you are solving the right kind of problem
12:15:02 <tomboy64> ^^ okay
12:15:03 <hpc> but you should wait for it to matter before you look into optimizing at that level
12:15:03 <kmc> other monads like IO, ST, and STM are baked deeply into the language implementation
12:15:04 <tomboy64> lezzee
12:15:07 <hpc> the algorithm always wins
12:15:18 <kmc> and looking at their guts is probably not instructive on how to use them
12:18:22 <nikolx> Is there a more concise way to say x <- f ; case x of ...
12:18:49 <hpc> robde: to elaborate on kmc's answer and clear up what is a common newbie error, you should not be worrying about learning "monads"
12:19:38 <hpc> robde: you learn types and their interfaces; it so happens that Monad is a very convenient interface that many types share
12:19:46 <tomboy64> hpc: i am trying to understand my algorithm. cause it's not working :p
12:20:01 <byorgey> nikolx: yes, with the LambdaCase extension
12:20:37 <hpc> and IO, ST, STM are all "magical" types; their Monad instances are along the lines of "instance Monad IO where return = magicReturn, (>>=) = magicBind"
12:21:27 <kmc> right, and they differ between Haskell implementations
12:21:38 <byorgey> unfortunately I cannot find documentation on what the actual syntax of LambdaCase ended up being
12:22:11 <byorgey> nikolx: ah, here we are: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#lambda-case
12:22:24 <hpc> robde: kmc's answer holds for any type, not just Monad instances; you can usually manage on docs, but reimplementation is a good exercise
12:22:32 <byorgey> nikolx: so you can say   f >>= \case { Foo -> ...; Blah -> ... }
12:22:50 <luite> yeah i learned a bit reimplementing STM :)
12:22:54 <zq> Maybes are very very cool
12:24:27 <jfischoff> is there an implementation of haskell 98/2010 that is designed for pedagogical purposes?
12:25:36 <luite> jfischoff:  perhaps Fay, if you don't care about typecheckign
12:26:14 <jfischoff> No type classes though right?
12:26:23 <nikolx> byorgey: it must be post 7.4.1
12:26:33 <luite> jfischoff: no, but those are converted to dictionaries anyway
12:26:44 <byorgey> nikolx: yes, 7.6
12:27:09 <luite> jfischoff: a problem with Fay might be that it uses JavaScript closures to implement Haskell closures, so some of the details get hidden here
12:27:43 <jfischoff> Collecting the constraints during unification is something I would like to see
12:28:08 <jfischoff> the transformation of type class methods to take dictionary arguments is less interesting
12:28:56 <nikolx> I also wonder about "do" being necessary inside case. It seems awkward because I'm already in a "do".
12:29:47 <hpc> nikolx: the RHSs of a case are new expressions
12:30:14 <hpc> do {} is an expression, but it doesn't confer extra parsing context on sub-exrpessions
12:30:49 <byorgey> nikolx: there's nothing magic about "being in a do".  do is just syntax sugar for 'return' and (>>=).
12:31:02 <byorgey> and (>>).
12:31:26 <byorgey> do a; b === a >> b.   do x <- a; b ===  a >>= \x -> b.
12:32:08 <nikolx> I know what "do" is, I'm saying that even knowing that, the effect of "case" is not at all obvious. "do" does look at subexpressions, just not nested ones.
12:32:54 <Peaker> nikolx, do is never necessary inside a case, what do you mean?
12:35:00 * elliott has an idea: make lambdabot output the rest of the do laws if someone types any one of them
12:35:06 <elliott> save hours of #haskeller time
12:38:30 <nikolx> Peaker: Peaker: of course it's not necessary. The syntax is unfortunate, though. case x of _ -> stuff should be equivalent to stuff. But that means "do case x of _ -> do stuff" translates to "do do stuff".
12:39:05 <nikolx> I understand exactly what "do" is, I'm pointing out the syntax irregularity.
12:39:12 <Peaker> nikolx, I don't get it... :P
12:39:29 <Peaker> nikolx, case x of _ -> stuff   is equivalent to stuff..
12:39:42 <geekosaur> I don't see any syntactic irregularity
12:39:49 <elliott> nikolx: do case x of _ -> stuff translates to do stuff
12:39:56 <elliott> of course, stuff here is an expression.
12:40:03 <Peaker> nikolx, what irregularity do you mean?
12:40:08 <elliott> your change would introduce irregularity, not remove it
12:40:15 <DiegoNolan> Are there any of examples of SDL for windowing and events and OpenGL for graphics combined?
12:40:19 <Peaker> elliott, what change?
12:40:38 <Peaker> DiegoNolan, I suggest using GLFW-b package instead of SDL
12:40:46 <elliott> Peaker: making "do case of blah -> ..." have ... be inside a do-block
12:40:49 <DiegoNolan> k
12:41:01 <Peaker> DiegoNolan, SDL 2 was just released, I don't know if there are bindings. But SDL 1 makes OSX compatibility difficulty due to C preprocessor abuse in SDL
12:41:28 <Peaker> elliott, very weird
12:41:31 <mustard> I have a general debugging question. How would I end up with a result of [] if I have an equation f1 ++ f2 and I can GUARANTEE one of the functions delivers something? That is, regardless of whatever the function that fails to produce does
12:41:37 <elliott> Peaker: yes
12:41:50 <nikolx> Peaker: Right, but then we have "do case x _ -> do stuff" translating to "do do stuff"
12:41:54 <elliott> mustard: you cannot. therefore there is an error in your proof or you do not have a result of []
12:41:59 <DiegoNolan> Peaker, okay
12:42:06 <Peaker> mustard, f1 and f2 aren't functions...
12:42:14 <DiegoNolan> I don't know why the state of graphics programming is so terrible
12:42:15 <Peaker> mustard, and they are both [] if their (++) result is []
12:42:18 <mustard> well yah, you know what I mean
12:42:24 <Peaker> DiegoNolan, I don't think it's that bad
12:42:39 <Peaker> DiegoNolan, well, it is bad in the sense that many people (*cough*shachaf*cough*) don't have working OpenGL
12:42:39 <jfischoff> mustard: @hpaste
12:42:44 <DiegoNolan> it's just a hassle because you have to do some much low level stuff
12:42:55 <DiegoNolan> i'm just saying like
12:43:02 <Peaker> DiegoNolan, If you want 2d graphics, then graphics-drawingcombinators saves you from the low-level grunt work of OpenGL
12:43:28 <DiegoNolan> i'm saying all opengl tutorials still show GLBegin stuff with points
12:43:33 <DiegoNolan> when no one uses them anymore
12:43:37 <Peaker> DiegoNolan, and GLFW-b makes starting up relatively easy (it requires callback registration though, which requires inversion of control or using IORefs/MVars to send events from these callbacks or such)
12:43:53 <Peaker> DiegoNolan, Haskell OpenGL doesn't use glBegin, iirc
12:44:03 <DiegoNolan> no
12:44:08 <DiegoNolan> but it does draw points
12:44:18 <Peaker> DiegoNolan, unless you use an abstraction layer that hides it
12:44:20 <DiegoNolan> my point is that everything is VBO's or VBA or VA's
12:44:43 <Peaker> DiegoNolan, what are VBO's/VBA/VA's?
12:44:54 <mustard> http://paste.tryhaskell.org/2205096103085342720
12:44:58 <DiegoNolan> vertex buffer objects, vertex array objects, vertex arrays
12:45:08 <elliott> yikes, since when are hpaste urls so ugly?
12:45:19 <DiegoNolan> but tutorials take forever to get to those
12:45:36 <mustard> So the what I'm referring to is the "skip ++ choose" part. I can feed choose a predetermined piece of data and it will pass the filter. But if I throw skip into the mix, now I get []
12:45:59 <banister_> does anyone else here find 'real world haskell' much easier to grasp than 'learn you the haskell' ?
12:46:01 <mustard> so I get results if I just don't call skip
12:46:07 <elliott> mustard: I believe vs can be []
12:46:16 <elliott> therefore I believe spanTrs g vs can be []
12:46:25 <elliott> therefore I believe split can be []
12:46:33 <chrisdone> @quote potatoes
12:46:33 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
12:46:51 <banister_> @:t fmap
12:46:51 <lambdabot> Maybe you meant: wn v rc pl let id do bf @ ? .
12:46:55 <chrisdone> no quotes about potatoes? what kind of people frequent this posh too-good-for-potatoes court?
12:47:00 <banister_> @?
12:47:09 <jfischoff> > :t fmap
12:47:10 <lambdabot>   <hint>:1:1: parse error on input `:'
12:47:13 <chrisdone> lol
12:47:18 <jfischoff> @type fmap
12:47:19 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:47:20 <chrisdone> nobody interrupt the fails
12:47:21 <chrisdone> aww
12:47:33 <banister_> thx
12:47:39 <typoclass> :t fmap
12:47:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:47:44 <typoclass> jfischoff: this works as well
12:47:47 <jfischoff> ah
12:48:10 <chrisdone> ?ty (<$>)
12:48:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:48:33 <jfischoff> ?ty (<$)
12:48:34 <lambdabot> Functor f => a -> f b -> f a
12:49:05 <mustard> elliot: right, spanTrs can be []. But I'm still not getting it. If I just replace "skip ++ choose" with "choose" it gets results. what does adding skip do? I can give my argument if you want
12:49:18 <elliott> mustard: uh, I don't believe you
12:49:27 <elliott> xs ++ ys is always nonempty when ys is nonempty
12:49:32 <Peaker> DiegoNolan, do you want to do 2d graphics or 3d graphics?
12:49:44 <mustard> okay, hold on
12:49:45 <elliott> mustard: what's happening is your recursive call is changed because of that probably
12:50:01 <elliott> i.e. the choose isn't the same as the choose in skip ++ choose
12:50:07 <DiegoNolan> Peaker, both
12:50:08 <elliott> because choose depends on the recursive call that also has that change etc.
12:50:48 <Peaker> DiegoNolan, There's a library that's supposed to be nice, not sure how complete/comprehensive for 3d graphics: FieldTrip. And graphics-drawingcombinators for 2d.  Hopefully with these 2 you won't have to touch icky OpenGL APIs
12:50:58 <mustard> right-o...that's it
12:51:04 <mustard> @elliot
12:51:04 <lambdabot> Unknown command, try @list
12:52:27 <banister_> where can i find the source for the haskell repl?
12:52:29 <DiegoNolan> Peaker, looks cool but i don't know FRP
12:52:39 <banister_> and are there any more advanced repls available? (like pry for ruby, for example)
12:52:57 <Mon_Ouie> I like your example
12:53:05 <banister_> Mon_Ouie: ;)
12:53:15 <banister_> Mon_Ouie: you're learning haskell again?
12:53:36 <Peaker> DiegoNolan, AFAIK, neither of these have anything to do with FRP
12:53:53 <Mon_Ouie> Haven't done any in a while, I just stay on this channel still
12:54:20 <banister_> Mon_Ouie: i just finished LYAH and still feeling a bit stunned
12:57:18 <DiegoNolan> Peaker, their page on haskellwiki says they have no animation because it is intended to be used with FRP
12:58:06 <Peaker> DiegoNolan, or with your own mainloop
12:58:12 <Peaker> DiegoNolan, it doesn't matter
12:58:22 <Peaker> DiegoNolan, you can start with an imperative mainloop at first
12:59:21 <Peaker> DiegoNolan, OpenGL doesn't have animations either -- animations require that you draw incrementally different frames.  FieldTrip/drawingcombinators just abstract the GL drawing capabilities into nicer API's, while not adding animations. Makes no sense to forego that abstraction and use OpenGL because they don't have animation, since OpenGL doens't either
13:00:09 <Peaker> DiegoNolan, at least the problem of having to use icky low-level API's is solved, whereas animation remains your only problem
13:00:45 <DiegoNolan> Peaker, yeah
13:05:52 <CaptainK> how to get ('A','O')  to A
13:06:02 <CaptainK> or how do you get rid of the '   ?
13:06:10 <Clint> what do you mean?
13:06:35 <CaptainK> output just A for example to a variable
13:06:43 <kini> what is A?
13:06:57 <CaptainK> having input from ('A','O')
13:07:10 <Clint> are you writing a parser?
13:07:23 <Ralith> @where lyah
13:07:23 <lambdabot> http://www.learnyouahaskell.com/
13:08:13 <CaptainK> let lyah = fst ('A','O')
13:09:00 <geekosaur> you seem a bit confused about something. possibly the fact that ghci uses a Show instance, so a Char containing the letter A will be shown with quotes
13:09:07 <geekosaur> but they are not actually part of the value
13:09:55 <CaptainK> ok, then how do you print the value without the quotes?
13:10:54 <chrisdone> putStrLn (show 'a') → a
13:11:01 <chrisdone> er
13:11:07 <chrisdone> putStrLn ['a'] → a
13:11:07 <chrisdone> =)
13:11:58 <geekosaur> Prelude> let xx = 'A' in putStrLn [xx]
13:11:59 <haasn> hPutChar or something? :P
13:11:59 <geekosaur> A
13:12:10 <geekosaur> or putChar/hPutChar, yes
13:14:49 <newsham_> > show 'a'
13:14:50 <lambdabot>   "'a'"
13:15:07 <newsham_> > ['a'] == "a"
13:15:08 <lambdabot>   True
13:15:40 <mauke> printf "%c" 'A'
13:15:54 <elliott> mauke.....
13:15:56 <newsham_> > printf "%c" 'A' :: String
13:15:57 <lambdabot>   "A"
13:16:32 <mauke> (system . printf "echo %c") 'A'
13:16:41 <newsham_> ?type putStrLn $ return 'a'
13:16:41 <lambdabot> IO ()
13:16:48 <kini> an application written in an interpreted language such as, say, Lisp, might offer user-facing scripting facilities - for example some dialog box might allow you to enter a Lisp s-expression to more precisely control the application's behavior than just allowing the user to choose from finite sets of options and on/off checkboxes would
13:16:48 <kini> for example, in the emacs configuration dialogs, there are various configuration options which allow you to enter an s-expression which can include any code you like
13:16:48 <kini> is such a thing imaginable in a Haskell-based application? or would you have to embed an interpreter for for some scripting language like Lua, and then painstakingly map Haskell values to references in the scripting language?
13:17:04 <mauke> kini: stopped reading at "an interpreted language such as lisp"
13:17:18 <mcstar> :)
13:17:21 <kini> some lisps are interpreted :)
13:17:22 <newsham_> kini: there was a library for dynamically loading haskell modules
13:17:31 <kini> such as the one I mentioned in the example on the next line >mauke
13:17:45 <newsham_> i dont know what the current status is
13:17:55 <Demos_> check out hint
13:18:06 <Demos_> warning: large executables lite in that direction
13:18:26 <kini> oo, thanks Demos_
13:18:51 <elliott> xmonad and yi and stuff have this kind of thing.
13:18:56 <elliott> there's also the dyre library (yi uses it)
13:19:28 <kini> I use xmonad and afaik you need to recompile your xmonad executable whenever you change the "config file" ~/.xmonad/xmonad.hs
13:19:33 <kini> which is what prompted the question
13:20:19 <banister_> am i right to think there's two meanings of 'continuation? 1. just a callback passed to a function and 2. a snapshot of the entire callstack that can later be resumed
13:21:27 <banister_> not sure if 2. exists in haskell, but ruby has something called callcc that implements that
13:21:49 <mauke> @hoogle callCC
13:21:49 <lambdabot> Control.Monad.Trans.Cont callCC :: ((a -> ContT r m b) -> ContT r m a) -> ContT r m a
13:21:49 <lambdabot> Control.Monad.Cont.Class callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
13:21:49 <lambdabot> Control.Monad.Cont callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
13:22:10 <orzo> i've been using conduits and I've used MaybeT with it, because the "await" call to peel off an event from a stream can return Nothing, and I treat that as an end-of-stream condition and my handler should quit, but i'm doing a complicated state machine so its a highly repeated pattern
13:22:16 <banister_> mauke: so the term continuation is overloaded ?
13:22:22 <mauke> banister_: I don't think so
13:22:39 <banister_> mauke: hmm, but javasript for example uses 'continuation passing style' regarding most of its async APIs, yet it definiteily doesn't have callcc
13:22:45 <mauke> banister_: the only difference is whether you have to build your continuations manually, or whether the language has built-in support for them
13:23:06 <mauke> "continuation passing style" means building continuations manually
13:24:02 <banister_> mauke: thx, is there another term for the callcc variant to more strongly differentiate it ?
13:24:49 <newsham_> banister: if the callback is the rest of the program (ie. the callback calls another callback when it is done and so on), then they are the same thing
13:25:28 <orzo> Is it proper, with the conduit package, to treat a result of Nothing from a call to await to mean the stream has ended?  That's not really documented clearly, it says "If no data is available, returns Nothing. " which could be interpreted to mean its not always blocking or ... i dont know
13:26:49 <banister_> newsham_: i guess 2. could be called first-class continuations?
13:27:10 <S_J> Hmm Im stumblin on problems tryin to make quickcheck in C. It is hard to make anything general. Really, does it matter if you can at most quickcheck functions with maximum 3 args? How often do you have functions with more args than that?
13:27:22 <S_J> hmm i guess it happens fairly often though
13:27:23 <newsham_> first class would just mean that its something you could hold onto in your program (ie. put in a variable, pass to functions, etc)
13:28:01 <banister_> newsham_: hmm so if i was to describe 2. to someone, are there really not any snappy terminology i could use so they're clear it's different to just manually passing a callback?
13:28:33 <newsham_> I think really 1) is kind of an abuse of the word that some people have used when describing continuations to people who know callbacks, and has kind of stuck around
13:29:21 <banister_> thx
13:29:41 <newsham_> if you express your program in continuation-passing-style every function is getting a callback argument, and none of the functions are returning, they're just calling the next thing
13:33:37 <CaptainK> where is a more comprehensive book than lyah explaining string manipulations?
13:34:14 <newsham_> in haskell string manipulation is just list manipulation (except for the bytestring or text stuff)
13:34:39 <newsham_> i'm not sure a good answer to yoru question.. do you have a specific string manip question?
13:36:26 <robde> what does the expression "a function gets bound" mean exactly?
13:36:34 <robde> f gets bound to..
13:37:09 <mauke> a value is associated with a name
13:37:20 <newsham_> variables get bound. like if you have "f x = x + 5" and you ask for "f 3" then 3 gets boudn to x
13:37:45 <mauke> I'd say it's the other way around
13:37:47 <mauke> x gets bound to 3
13:37:58 <mauke> also f got bound to \x -> x + 5
13:38:06 <newsham_> "map f xs = ..."       when you call "map (+1) [1,2,3]"   f gets bound
13:38:06 <elliott> it might help to say where you're reading this
13:38:09 <newsham_> mauke: yes, danke.
13:38:40 <sipa> and if you ask for f (1+3), x gets bound to 1+3, not to 4 (as it would be in a strict language)
13:39:12 <banister_> am i right to think that the -> used in function definition syntax is itself a function?
13:39:19 <S_J> How does Haskell deal with datatype overflows, for example Integer overflow?
13:39:27 <S_J> > product [1..12]
13:39:28 <lambdabot>   479001600
13:39:28 <newsham_> ?type (->)
13:39:29 <lambdabot> parse error on input `->'
13:39:32 <S_J> > product [1..20]
13:39:32 <newsham_> nope :)
13:39:33 <lambdabot>   2432902008176640000
13:39:37 <S_J> > product [1..30]
13:39:38 <lambdabot>   265252859812191058636308480000000
13:39:42 <roconnor> > maxBound + 1
13:39:42 <S_J> > product [1..300]
13:39:42 <lambdabot>   No instance for (GHC.Show.Show a0)
13:39:43 <lambdabot>    arising from a use of `M1992923260.sh...
13:39:43 <lambdabot>   306057512216440636035370461297268629388588804173576999416776741259476533176...
13:39:53 <banister_> newsham_: hmm so what is it?
13:39:55 <S_J> > maxBound
13:39:56 <lambdabot>   ()
13:40:01 <newsham_> > (127 :: Int8) + 1
13:40:01 <lambdabot>   -128
13:40:05 <acube> Is it possible to wait for mutliple threads to exit in GHC Haskell?
13:40:22 <S_J> > (127 ::UInt8)+1
13:40:24 <lambdabot>   Not in scope: type constructor or class `UInt8'
13:40:25 <lambdabot>  Perhaps you meant `Int8' (...
13:40:39 <newsham_> s_j: we've got both fixed and normal integers
13:40:42 <elliott> S_J: btw, you can /msg lambdabot too
13:40:47 <gelisam> @banister it's an infix type constructor with two arguments. hmm, that probably doesn't help, does it?
13:40:47 <lambdabot> Unknown command, try @list
13:40:57 <S_J> So signed itnegers also wrap around? not just unsigned ones?
13:41:05 <robde> elliott: I don’t remember exactly where I heard it. I think a professor used it in a lecture, without explaining what it means.
13:41:12 <banister_> newsham_: oh it's a type constructor?
13:41:12 <roconnor> > (255 :: Word8) + 1
13:41:13 <lambdabot>   0
13:41:46 <newsham_> banister: I think the arrow is just syntax.
13:41:59 <CaptainK> I'm missing the understanding of how to print ony A from ('A','O')
13:42:04 <gelisam> banister, newsham_: the arrow is indeed a type constructor!
13:42:11 <sipa> banister_: -> is special syntax, with both a meaning in type expressions and value expressions
13:42:14 <newsham_> oh, gelisam said its a type constructor.
13:42:17 <newsham_> ?kind (->)
13:42:18 <lambdabot> * -> * -> *
13:42:24 <CaptainK> because haskell want to print out the 'A' which is not its actual store state
13:42:30 <banister_> newsham_: i thought so too, but then i read this which blew my mind: http://cl.ly/image/2s3N2U173N2U
13:42:32 <sipa> ah, at the type level it's less special
13:43:13 <newsham_> overlaoding of value and type syntax is confusing at times :)
13:43:22 <haasn> > 127 + 1 :: Word8
13:43:23 <lambdabot>   128
13:43:29 <CaptainK> just A is stored, but when I print it I get 'A'
13:43:29 <haasn> S_J: unsigned 8-bit integer ^
13:43:30 <elliott> > 1237128937189346378467487145146712541234781254781234124512834581235124591824678912451237845127845245457195238745359103 :: Integer
13:43:31 <lambdabot>   123712893718934637846748714514671254123478125478123412451283458123512459182...
13:43:44 <newsham_> > maxBound :: Word8
13:43:45 <lambdabot>   255
13:44:01 <benmachine> CaptainK: maybe you want putChar?
13:44:24 <CaptainK> ok will read up on it
13:45:16 <newsham_> ?type let x = ('A','O'), charToString x = [x] in putStr $ charToString $ fst x
13:45:17 <lambdabot> parse error on input `,'
13:45:28 <newsham_> ?type let x = ('A','O'); charToString x = [x] in putStr $ charToString $ fst x
13:45:29 <lambdabot> IO ()
13:45:58 <newsham_> (instead of using "show $ fst x" for example)
13:46:22 <banister_> since value constructors are just functions (apparently) how would i write one manually? (without using data Circle = Circle Float Float Float)
13:47:08 <CaptainK> perfect, now I understand
13:47:26 * CaptainK fits the missing piece into his haskell puzzle
13:47:44 <benmachine> banister_: data (and newtype) declarations are the only way to make new value constructors
13:48:10 <robde> so what does it mean? "x :: Int -> Int -> Int; x y = 1 + 3" === "x gets bound to 1 + 3" or "x gets bound to Int -> Int -> Int", or "x 3" === "x gets bound to 3?
13:48:14 <banister_> benmachine: ah ok, thanks
13:48:19 <benmachine> value constructors are functions in the sense that they are values that you can apply to other values
13:48:43 <newsham_> rodb: x is bound to the function that takes one arg and returns 1 + 3
13:48:44 <benmachine> but they aren't defined like other functions, and you can use them in pattern-matching, which you can't do with other functions
13:48:44 <sipa> robde: x gets bound to (\y -> 1 + 3) :: Int -> Int -> Int
13:48:48 <benmachine> so they are special functions
13:48:56 <banister_> benmachine: good point
13:49:35 <banister_> i just remembered reading 'value constructors are just functions' in lyah, and i thought perhaps it was possible to manually define one
13:49:42 <robde> newsham_, sipa: thanks.
13:49:55 <newsham_> ?type Just
13:49:56 <lambdabot> a -> Maybe a
13:50:13 <sipa> robde: oh, that's wrong even; it's just Int -> Int
13:50:38 <robde> sipa: oh, right
13:53:25 <chrisdone> benmachine: whatcha working on these days?
13:54:02 <benmachine> chrisdone: basically just finished a degree, so, mostly been that :P
13:54:55 <chrisdone> benmachine: and then you turned 360 degrees and got the hell outta there?
13:55:14 <benmachine> chrisdone: ...
13:55:16 <benmachine> chrisdone: sure why not
13:55:28 <newsham_> turning 360 degrees is a poor flight plan
13:55:54 <benmachine> newsham_: depends on which axis
13:55:55 <benmachine> maybe you just pressed Z or R twice
13:56:21 <benmachine> chrisdone: anyway, the other day I did a bit of cabal stuff and today I've been faffing with pointfree again
13:56:33 <benmachine> chrisdone: pointfree has several testcases that I'm pretty sure never passed
13:56:50 <benmachine> but then I found a bug in HSE which was kind of a surprise
13:56:57 <benmachine> which reminds me, I got distracted before I reported that
13:57:56 <newsham_> benmachine: afaict turning 360 on any axis gives the same result.
13:58:14 <benmachine> newsham_: well, it gives the same /final orientation/
13:58:28 <benmachine> but that's not the only relevant outcome
13:58:48 <banister_> you mean you might see a cute girl on your way round?
13:59:14 <rhodesd> unless the axis belongs to a space with 720 degrees of rotation, maybe a mobius type thing
13:59:50 <newsham_> are there such spaces?  i'm not a geomathologist
13:59:58 <benmachine> banister_: or a guy, indeed
14:00:40 <benmachine> banister_: or a cute non-binary gendered person
14:00:49 <banister_> :P
14:01:31 <quchen> rhodesd: Or spin.
14:01:43 <quchen> But quantum mechanics is OT here isn't it
14:02:12 <benmachine> most of what we're talking about right now is OT to be fair
14:02:26 <benmachine> but we're not really displacing anything else so it isn't too important
14:02:53 <Nisstyre> benmachine: inb4 "I wanted to ask questions but it seemed like they were talking"
14:03:30 <benmachine> Nisstyre: "I wanted to ask questions but it seemed like no-one was talking"
14:03:39 <Nisstyre> fair point
14:04:08 * typoclass purrs unspecifically
14:10:45 * chrisdone gives typoclass a bowl of milk
14:11:43 <quchen> Typoclass now has diarrhea. Careful what you feed your cat.
14:12:50 <mcstar> ive got a cat ~ 2 weeks ago
14:13:36 <typoclass> chrisdone: thanks a lot, very good :-) i'll share a mouse with you later
14:13:49 <typoclass> quchen: that's a ridiculous notion
14:14:46 <mcstar> no it isnt, i ate 1kg of yogurt today at once and ive contracted diarrhea :)
14:19:47 <quchen> typoclass: Not sure what part of feeding things to something that doesn't normally eat it is ridiculous.
14:19:49 <elliott> @remember copumpkin it's like grasping desperately for the rope of induction as you fall down the bottomless pit of coinduction
14:19:49 <lambdabot> Done.
14:19:57 <quchen> Anyway, OT, I'm out.
14:21:08 <CaptainK> there was a url for a good description on where do loops are good to use and where they are not,
14:21:32 <CaptainK> please point me in the right direction?
14:21:55 <Ralith> @where lyah
14:21:56 <lambdabot> http://www.learnyouahaskell.com/
14:22:07 <Ralith> you should read that. from the start.
14:23:06 <Demos_> wha, haskell has do loops?
14:23:13 <CaptainK> been thmain = do
14:23:37 <Demos_> that is not a loop
14:23:55 * hackagebot lio 0.11.0.1 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.11.0.1 (DeianStefan)
14:24:32 <typoclass> CaptainK: we call it "do block"
14:25:04 <Demos_> and it is not a loop
14:25:20 <typoclass> Demos_: yes, you mentioned it
14:25:38 <chrisdone> man i wish ANYTHING in the ghc api had Show instances
14:26:26 <chrisdone> such a pain in the ass for inspection of values
14:26:50 <Peaker> chrisdone, There ought to be a DebugShow class that *everything* is magically an instance (where you can override it or not), and is enabled in some sort of debug mode
14:27:13 <typoclass> quchen: well if the issue is "normally consumes", then milk is clearly excellent for me. also whiskey (i prefer islay)
14:27:38 <chrisdone> Peaker: agreed
14:27:57 <typoclass> CaptainK: do you have a specific case where you're wondering if you should use a do block? feel free to put it on hpaste
14:28:00 <typoclass> @where hpaste
14:28:00 <lambdabot> http://paste.tryhaskell.org/new/haskell
14:28:06 <chrisdone> Peaker: i try to use Show like that, but people using Show as a pretty printer or something ruins it. thisiswhywecanthavenicethings.jpg
14:28:08 <Peaker> it would break parametricity to have it on all the time, but propagating a Show constraint everywhere when you want to trace some stuff :(
14:28:39 <brett`> elliott: how did you become so successful?
14:28:44 <typoclass> Peaker: whoa, good idea
14:29:09 <chrisdone> Peaker: hm, though, i've recently started using Data as a workaround for the stupid Show implementations people make with gshow
14:29:12 <Peaker> or maybe, like "seq", it could require no type-class at all, just magic
14:29:40 <Peaker> chrisdone, what do you do with the Data? derive the original Show instance?
14:29:47 <chrisdone> indeed
14:29:52 <chrisdone> if you want it i can paste it
14:29:53 <Peaker> btw: I never checked, what happens when GeneralizedNewtypeDeriving is enabled -- and you "deriving Show"?
14:30:00 <CaptainK> typoclass: it wasn't apparent to me in lyah why i have to declare variables with a 'let'?
14:30:05 <Peaker> chrisdone, sure, would probably be useful :)
14:30:12 <chrisdone> Peaker: you mean for newtypes? it adds the newtype constructor
14:30:13 <CaptainK> inside a do "block"
14:30:28 <CaptainK> want to get rid of the excessive "lets"
14:30:28 <Peaker> chrisdone, because GeneralizedNewtypeDeriving makes it ambiguous, ordinarily it would copy the inner instance as-is
14:30:36 <chrisdone> Peaker: newtype Foo = Foo Int, Foo 2 -> "Foo 2"
14:31:27 <typoclass> CaptainK: yes you have to use 'let', the only exceptions are top-level definitions ("foo = ...") or "x <- ..." inside of do blocks
14:31:28 <hpaste> chrisdone pasted “gshow” at http://hpaste.org/8955059099091861504
14:31:39 <mcstar> you can bind many names with a single let
14:31:45 <typoclass> CaptainK: however, a single 'let' can introduce any number of definitions. you just need to indent them correctly
14:32:01 <chrisdone> Peaker: might be buggy or not very good, i whipped it up very quickly one time while trying to inspect GHC's core output (again, yet another thing with no Show)
14:32:12 <ekipan> top level defintions themselves are no exception: they're all inside a where clause (module Foo where { ... })
14:32:17 <Peaker> also, a single-let allows the definitions to be co-recursive, and nested lets do not
14:32:27 <mcstar> typoclass: i cant show you my kitty, damn bluetooth refuses to work :(
14:32:39 <typoclass> mcstar: aw :-(
14:32:46 <CaptainK> and can you just program in the top level and not use a do block and thus not use lets
14:32:47 <CaptainK> ?
14:33:06 <Peaker> chrisdone, "hpaste" bot still uses the old/broken URLs
14:33:20 <chrisdone> Peaker: ah, good point. will fix
14:33:45 <Peaker> chrisdone, the hlint warning there is useful -- since it exposes that it really means to say "all" there :)
14:34:18 <tomboy64> > map (\n -> putStrLn ((show n) ++ ": " ++ show (s n))) [1..30]
14:34:19 <lambdabot>   Couldn't match expected type `a0 -> a1'
14:34:19 <lambdabot>              with actual type `Debu...
14:34:22 <tomboy64> hm
14:34:39 <ekipan> personally I think the monadic bind syntax in do blocks is more ugly because it doesn't look like the (>>=) and lambda it actually is
14:34:53 <tomboy64> it says here i don't have an instance for Show
14:34:58 <tomboy64> what am i doing wrong?
14:35:10 <hpaste> chrisdone revised “gshow”: “Added imports” at http://paste.tryhaskell.org/8955059099091861504
14:35:14 <Cale> ekipan: ?
14:35:21 <mcstar> you probably missing an argument for a function
14:35:32 <Cale> ekipan: You might find that =<< works well in conjunction with do
14:35:32 <Peaker> ekipan, if syntax sugar looked exactly like the desugared notation, what would be the point?
14:35:39 <tomboy64> am i?
14:35:52 <Cale> :t s
14:35:52 <lambdabot> Expr
14:35:59 <newsham_> s expr!
14:36:00 <ekipan> my point is that the sugar is perhaps a confusing point for a complete newbie
14:36:00 <mcstar> what's s?
14:36:05 <mcstar> oh
14:36:08 <newsham_> > s + 1
14:36:09 <lambdabot>   s + 1
14:36:13 <Cale> > s 5
14:36:13 <typoclass> CaptainK: still there?
14:36:14 <lambdabot>   Couldn't match expected type `a0 -> t0'
14:36:14 <lambdabot>              with actual type `Debu...
14:38:05 <Peaker> ekipan, Monads are not newbie friendly either, the say :)
14:38:07 <ekipan> and that between the <- syntax and lets, <- is more confusing
14:38:12 <ekipan> in do blocks
14:38:40 <elliott> brett`: are you thinking of another elliott?
14:38:41 <ekipan> well "they" are full of it then, I say
14:38:56 <newsham_> as a newb you can pretend that the <-'s you see in do blocks are just "lets" for values you get back from procedures (vs. functions)
14:39:19 <elliott> chrisdone: btw, is there a reason the hpaste urls are so long now? :p
14:40:22 <brett`> elliott: conal elliott? if that's you, then no
14:40:22 <typoclass> elliott: something about moving the server and not controlling the hpaste.org domain
14:40:24 <chrisdone> elliott: to support private pastes =)
14:40:37 <newsham_> brett`: he uses "conal" on irc.
14:40:51 <elliott> brett`: that's conal on IRC
14:41:06 <brett`> oh
14:41:10 <brett`> sorry ;)
14:41:15 <elliott> chrisdone: hmm, ok. pastie gives the private pastes only longer URLs
14:41:33 <elliott> I have lambdabot's @paste updated locally for the haskell.org URL whenever it starts resolving, fwiw
14:41:42 <chrisdone> elliott: i could do that
14:42:12 <elliott> chrisdone: no big deal, they're just ugly after years of nice hpaste.org urls ;)
14:49:23 <sclv> does anyone know why erik meijer thinks comonads make sense for asynchrony
14:49:28 <sclv> what is he talking about?
14:49:51 <jmcarthur> link?
14:51:30 <hpc> sclv: perhaps he is imagining a pure version of http://hackage.haskell.org/packages/archive/async/2.0.1.4/doc/html/Control-Concurrent-Async.html
14:51:35 <hpc> sclv: with wait :: Async a -> a
14:51:42 <sclv> jmcarthur: his recent tweets https://twitter.com/headinthebox
14:52:07 * typoclass . o O ( if monadic code is impure, and pure code is pure, what is comonadic code? )
14:52:20 <FreeFull> Monadic code is pure though
14:52:21 <hpc> typoclass: monadic code is pure
14:52:23 <ciaranm> antipure
14:52:39 <ion> copure
14:52:51 <djahandarie> coimpure
14:52:52 <sclv> hpc: well sure and he's talking about rx
14:53:10 <typoclass> hpc: yes yes, at compile time everything is pure :-)
14:53:18 <sclv> i mean you need Async a -> a, modulo IO, sure
14:53:26 <sclv> but what is the purpose/meaning of duplicate?
14:53:35 <sclv> otherwise you just have a functor with an algebra
14:53:36 <ciaranm> it's cojoin
14:53:45 <sclv> thank you for that useless answer!
14:54:06 <sclv> the purpose/meaning of duplicate with regards to an asynchronous API I mean
14:54:28 <hpc> sclv: dunno; i can't derive in a few seconds what erik meijer likely spent weeks thinking about
14:54:31 <hpc> :P
14:55:18 <jmcarthur> sclv: (Async a -> b) -> (Async a -> Async b)   -- would be able to avoid waiting for the result
14:55:38 <hpc> sclv: the more interesting question... was just answered
14:55:41 <hpc> (what is fmap)
14:56:21 <robde> since there are functions without argument, why aren’t there lambda expressions with 0 arguments? like \ -> 2?
14:56:27 <jmcarthur> sclv: i think this is intended to feel a little like lazy IO except that the actual side effect is still performed eagerly
14:56:38 <jmcarthur> sclv: you can just block on the result in pure code
14:56:39 <djahandarie> robde, there aren't functions without arguments.
14:56:48 <typoclass> robde: well, haskell is lazy
14:56:49 <ciaranm> > return 42 "monkeys"
14:56:50 <lambdabot>   42
14:57:00 <hpc> robde: the definition of a function in haskell is that it takes a single argument
14:57:04 <sclv> jmcarthur: hmm. that extend is interesting i guess.
14:57:04 <ekipan> > (\() -> 42) ()
14:57:05 <lambdabot>   42
14:57:09 <elliott> robde: haskell does not have functions without arguments
14:57:12 <hpc> see also: currying
14:57:13 * elliott doesn't know what typoclass is saying...
14:57:28 * djahandarie either.
14:57:33 <elliott> in fact, a function in Haskell is just a thing with one argument. "multiple-argument" functions are defined in terms of single-argument functions
14:57:40 <robde> but f :: Int; f = 2 clearly has no argument
14:57:44 <elliott> yes, that is because it is an Int
14:57:46 <elliott> not a function
14:57:53 <elliott> @google everything a function in haskell
14:57:55 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
14:57:56 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
14:57:57 <elliott> perhaps see ^
14:58:07 <copumpkin> nothing is a function
14:58:17 <ciaranm> :t nothing
14:58:18 <lambdabot> Not in scope: `nothing'
14:58:28 <hpc> everything is nothing!
14:59:04 <ciaranm> a nothing is just a morphism in the trivial category
14:59:21 <sclv> i wonder if we can add that extend to the haskell async library and if it would be useful
14:59:42 <ekipan> I remember being confused at the beginning because in, say, Javascript I'm used to the fact that (function() {return 42;}) and 42 itself are very different things
14:59:47 * djahandarie can't tell if ciaranm is a troll or just bad at making jokes
15:00:05 <Peaker> sclv, Erik Meijer is held with high regard, but when I saw him speak, he said silly things like "FP has the powerful notion of higher-order funcs, but OO is actually more powerful because you pass multiple funcs"
15:00:08 <ekipan> but they may as well be the same in haskell because function arguments may only depend on their inputs, because of purity
15:00:12 <Peaker> I might have seen the wrong talks, though
15:00:33 <ekipan> function results* may only depend
15:00:38 <ekipan> on their arguments
15:00:57 <jmcarthur> ekipan: there are still ways that Int and (() -> Int) are different (unfortunately)
15:00:59 <sclv> i remember the discussion around Marlow's Async library. I forget why we can't make it a monad
15:01:11 <jmcarthur> apart from that you have to apply the latter to () to get the value
15:01:15 <jmcarthur> s/value/Int/
15:01:16 <sclv> but i think there was a discussion that it was a perfectly cromulent applicative!
15:01:22 <hpc> they're mostly evil ways
15:01:39 <hpc> (except for seq, which has the occasional legit use)
15:01:40 <ekipan> but () -> Int isn't a nullary function though
15:01:59 <typoclass> robde: f is evaluated lazily, when you need it (e.g. when you want to print it). with "f = 2", there's not much work to be done, but the expression "2" could be arbitrarily complex. so because of laziness, if you squint right, f could look like a zero-argument function, but we don't call it that in haskell
15:02:08 <jmcarthur> ekipan: neither is function() {return 42;}, really
15:02:17 <typoclass> robde: ... i hope i'm not making a mess of explaining this :-/
15:02:58 <ekipan> well javascript functions aren't really functions in the same sense then, because of statefulness and now we're just splitting hairs without actually disagreeing I think
15:03:00 <jmcarthur> ekipan: one could argue that javascript functions all that one argument, like haskell does. they are just tuples
15:03:08 <jmcarthur> *are all
15:03:13 <ekipan> I suppose
15:03:27 <elliott> typoclass: I don't think it has very much to do with laziness
15:03:33 <Peaker> we often talk of curried functions as having N arguments -- under that view, it might make sense to say that non-functions have 0 arguments.  It becomes hairy when polymorphism is involved
15:03:49 <elliott> I mean, f does have zero arity, if you take a reasonable definition of arity.
15:03:59 <ciaranm> does a car have zero legs?
15:04:00 <elliott> but it's not a function; "n-arity function" only works when n >= 1.
15:04:15 <elliott> though admittedly if n is a free variable you can consider it an acceptable abuse of notation to say that.
15:04:35 <ekipan> i.e. "function" is defined as a value with arity >= 1
15:06:24 <johnw> @tell Eelis Yes, you should be able to do that with gitlib-s3
15:06:24 <lambdabot> Consider it noted.
15:06:29 <jmcarthur> sclv: i think the reason is that one would have to use atomically in the definition of bind, and so you'd need unsafePerformIO, and so atomically is actually unsafe since it could be evaluated in the middle of a legit transaction
15:06:43 <erisco> so here is my mess with iterators: http://paste.tryhaskell.org/8186017789966811136  :P not sure what to make of it
15:06:50 <Eelis> johnw: cool!! i think i'll try it out :)
15:06:52 <Eelis> johnw: thanks
15:06:56 <jmcarthur> sclv: and the reason for this is that otherwise the results from the bind wouldn't be shared
15:07:05 <typoclass> elliott: my *guess* was that rob's confusion came from thinking "f is called, does some work, then gives back a 2, so it looks like f is a function", possibly after sticking Debug.Trace.trace in there or some such. of course i don't know
15:07:14 * elliott doesn't know, either
15:07:21 <erisco> lots of interesting problems.... map is hard to define in the way I set it up without an 'end', but that makes infinite iterators awkward to map over
15:07:43 <sclv> jmcarthur: ah so not a semantic reason, but an implementation specific one?
15:08:04 <erisco> also I am confused as to why I need to explicitly state the signatures I did for the main function. Haskell didn't have enough information to infer them otherwise it eems
15:08:16 <jmcarthur> sclv: i think that was the conclusion i came to when i explored the same problem before. i forgot what i had done, to be honest
15:09:22 <sclv> erisco: the reason it can't infer everything is your typeclass constraints get in the way of how far it can "see"
15:09:47 <sclv> a fundep would probably help
15:09:49 <erisco> sclv, well I know it is because of the type class, but I am not sure what it can't see
15:10:05 <erisco> fundep... is this anything like a dependent type?
15:10:13 <sclv> just a functional dependency
15:10:21 <sclv> it can see the "i" but it doesn't know what x to produce
15:10:30 <sclv> if you do Iterable i x | i -> x
15:10:33 <Nisstyre> erisco: it's sort of a way to state that a certain type "determines" another
15:10:36 <sclv> then that says each i uniquely determines an x
15:10:42 <Nisstyre> I realize that doesn't tell you how to use it
15:10:53 <hpc> it's a way of disambiguating instance resolution
15:10:55 <ekipan> your iterable element type x ought to depend on the type fixed for the container i
15:10:57 <typoclass> tangentially, why do we never talk about f#? i mean, we sometimes mention ml, and also scala, don't we
15:11:05 <Nisstyre> typoclass: I talk about it
15:11:06 <Nisstyre> not in here though
15:11:12 <typoclass> Nisstyre: ah :)
15:11:25 <Nisstyre> typoclass: if I had to use .NET I would run towards it
15:11:42 <erisco> can you explain i -> x a bit futher? I've seen this notation but it seems rather strange. So it is saying that for any given 'i', there are no two possible x's? that is what it seems to say
15:11:43 <Demos_> eagh c# is not bad for what it is.
15:11:52 <erisco> which isn't what I want
15:12:12 <hpc> erisco: suppose you had a class for various container types
15:12:13 <Demos_> then you may want i -> [x]
15:12:17 <sclv> well your i is something like [Int] right
15:12:26 <hpc> class Container c k v where lookup :: c -> k -> v
15:12:28 <erisco> maybe... it can be something like my Bar example
15:12:37 <typoclass> Nisstyre: is it more or less confused than scala? how much does it borrow from haskell?
15:12:38 <erisco> or my Foo example :)
15:12:45 <hpc> erisco: you could write instance Container (IntMap a) Int a
15:12:48 <Nisstyre> typoclass: it borrows a lot from SML and OCaml afaict
15:12:57 <sclv> your bar example is isomorphic to a list of ints
15:13:00 <hpc> erisco: and then turn right around and write instance Container (IntMap a) Double a
15:13:01 <erisco> 'i' is the container type, 'x' is the type the container has
15:13:09 <sclv> right
15:13:16 <sclv> so Bar always has Int
15:13:21 <sclv> and Foo Int always has Int
15:13:21 <Demos_> one of the largest problems with f# is that it is .net and thus the standards libraries are not functional
15:13:23 <sclv> etc.
15:13:25 <hpc> erisco: a fundep "c -> k v" will say
15:13:33 <sclv> You can also have a "Foo a" always has "a"
15:13:36 <hpc> "for each c, there is exactly one combination of k and v"
15:14:20 <typoclass> Demos_: right
15:14:27 <erisco> hpc, sorry I am not sure I follow... where does "Container" come from?
15:14:39 <Demos_> hpc, could there not also ve _|_ there?
15:14:56 <hpc> erisco: i defined it on the line "class Container ..."
15:16:31 <chrisdone> elliott: ok, public pastes use the normal id numbering
15:17:51 <erisco> okay... so to clarify what I don't understand.... i -> x  would seem to mean that both the instances  Int Char  and  Int Double  cannot exist
15:18:01 <ekipan> correct
15:18:22 <erisco> okay but then I am saying my container which is iterable can only ever contain one type
15:18:31 <ekipan> so you want something like this?
15:18:33 <ekipan> newtype IC = IC [(Int, Char)]; instance Iterator IC Int where {...}; instance Iterator IC Char where {...}
15:19:12 <erisco> not sure what you're saying with that
15:19:37 <ekipan> if that happened, the compiler wouldn't know which instance to choose at each callsite
15:19:54 <erisco> oh, I see what you're saying :)
15:20:16 <ekipan> the fundep prevents such a thing from even being definable
15:20:16 <erisco> why not?
15:21:21 <erisco> okay if we had    data IC a = ...     instance (IC a) a     what in that case?
15:21:22 <ekipan> advance (IC [(1, 'a']) -- what type is it?
15:21:27 <erisco> that is more like what I'd actually have
15:21:40 <ekipan> advance (IC [(1, 'a')])
15:22:08 <elliott> chrisdone: cool
15:22:38 <erisco> it would seem that  i -> x   would only allow one instance of 'a' in   instance (IC a) a
15:22:44 <erisco> unless I am not understanding
15:23:16 <ekipan> if you defined that and imported it, I could come around and define instance (IC a) String where advance x = Just ("My favorite string", x)
15:23:30 <ekipan> and I* imported it
15:23:45 <ekipan> the fundep prevents me from doing that
15:23:47 <erisco> doesn't  (IC a) a  mean that both 'a' are the same?
15:23:56 <ekipan> in your instance yes
15:24:06 <ekipan> but instances are open, you can add more
15:24:25 <ekipan> the fundep prevents other people from making instances that would confuse the compiler
15:27:38 <erisco> okay so my suspicion is false...
15:27:46 <erisco> not precisely sure what the fundep means then sorry :P
15:28:04 <ekipan> hm? I think your intuition is right though
15:28:10 <erisco> but it wasn't
15:28:17 <erisco> either that or I just broke fundeps
15:28:30 <ekipan> i -> x, the type of x is uniquely determined by the type of i
15:28:52 <ekipan> s/type of/type/g
15:29:20 <erisco> class Iterable i x | i -> x      I presumed this meant that if I had     instance (Foo a) a      then I could only make 'a' one type, ever, in my entire program
15:29:49 <erisco> but I used the instance with both  (Foo Int) Int   and  (Foo String) String
15:29:57 <ekipan> it says that give a type i = Foo Int, a could only be Int
15:30:13 <ekipan> sorry, x could only be Int
15:30:14 <erisco> okay I don't understand how it says that
15:30:49 <erisco> how does 'i' know that I am providing a data type with one type variable and which type variable I am referring to?
15:31:13 <ekipan> (Foo a) and a are constrained with each other, the a's are equal
15:31:25 <ekipan> by the instance you gave
15:31:30 <erisco> but isn't this determined by my instance?
15:31:34 <erisco> what does the fundep do?
15:31:52 <ekipan> it prevents instance (Foo a) SomethingThatIsntA
15:32:08 <ekipan> provided your instance already exists
15:32:27 <erisco> it isn't clicking. well, I have to go. I'll think about it and see if I smarten up
15:32:34 <erisco> thanks for your time ekipan
15:32:43 <ekipan> two constraints here: a = a, and i determines x
15:32:52 <ekipan> they combine together
15:33:05 <ekipan> the first in your instance, the second defined in the class's fundep
15:33:56 <erisco> ekipan, I think I grasp that part, but I am not entirely ... oh okay
15:34:38 <erisco> it is really faint but I can maybe see why the compiler can't infer the type ... because an instance (Foo a) b    *could* exist
15:34:53 <ekipan> the a = a constraint is easier to take for granted, it is surely syntactically quieter
15:34:58 <chebert> hello friends - I have a hopefully quick question. I want to use two libraries -- lens and gtk -- but they each use a different version of bytestring. How can I resolve this?
15:35:04 <erisco> not exactly sure why  i -> x says that can't be the case but I'll think about it
15:35:06 <erisco> thanks
15:35:21 <Demos_> haskell's type system is powerfull enough that it sometimes needs a nudge in the right direction
15:36:28 <ekipan> you've defined an instance with some i (Foo a) and also given its corresponding x (a). If that the instance exists, the compiler will prevent the definition of some other instance where i = Foo a but x = something else
15:36:59 <chebert> it looks like he logged off...
15:37:35 <ekipan> I'll PM lambdabot to @tell tell him then
15:41:17 <chebert> ^^ can anyone tell me if the two libraries _can_ be resolved?
15:43:10 <elliott> chebert: ideally make them use the same version instead
15:43:29 <elliott> chebert: you could try "cabal install lens gtk" after cleaning out your packages
15:43:33 <elliott> that should pick one and only one version
15:43:55 <chebert> wow that's actually pretty neat
15:44:14 <sepia> ISON davidad
15:44:25 <chebert> if that doesn't work though, I'll just recompile them, then
15:45:13 <chebert> anyway, thanks for the help, elliot
15:45:20 <chebert> * elliott
15:46:08 <elliott> chebert: oh, that's what I mean
15:46:13 <elliott> by cleaning out I mean removing everything :)
15:47:02 <chebert> seems easier than trying to rebuild!
15:47:12 <elliott> well, it will then rebuild them.
15:47:15 <elliott> the point is doing it in one command
15:47:22 <elliott> cabal's dependency resolution is better if you do things in one go
15:47:46 <chebert> yeah I understand. I meant easier than rebuilding manually
15:48:10 <Peaker> chebert, for me, cabal install gtk lens seems to Just Work, and my package database isn't clean
15:48:29 <chebert> I'll try that first
15:51:53 <chebert> heck yeah
15:51:56 <chebert> that worked perfectly
15:52:09 <chebert> no need to clean the db since I only had gtk
15:52:18 <chebert> thanks again Peaker, elliott
15:52:41 <elliott> :)
15:52:46 <elliott> Peaker: by clean, I just meant not having either installed
15:53:16 <Peaker> I have lens installed, and that was fine too
15:53:56 <chebert> well that's good news for my partner
15:55:50 <chebert> alright thanks again buh-bye
16:01:52 <ivoscc> #emacs
16:27:20 <robde> hm. that article http://conal.net/blog/posts/everything-is-a-function-in-haskell didn’t not really explain. so in x :: Int; x = 5, what does x get bound to?
16:28:02 <elliott> x is 5.
16:28:21 <elliott> 5 is an Int. not a function
16:28:45 <robde> it’s a non-function, could I call it literal?
16:29:07 <robde> or a member of the set Int?
16:29:11 <elliott> yes but not all non-functions are literals
16:29:20 <elliott> "member of the set Int" is ok but better is "member of the type Int"
16:29:25 <elliott> but I prefer "Int"
16:29:33 <elliott> it is many fewer words to say the same thing :)
16:29:48 <lispy> I could use some help: http://stackoverflow.com/questions/17385635/how-to-work-around-the-first-order-constraint-on-arrows
16:30:12 <robde> what is the difference between set and type?
16:31:16 <tac> Hmm....
16:31:33 <tac> In Aeson, if I know how to parse an object, but my JSON is a 1-length list of that kind of object I know how to parse
16:31:36 <lispy> robde: in set theory, sets have no structure. in type theory, types have structure.
16:31:39 <tac> How do I strip off that layer of list?
16:32:01 <elliott> robde: the difference is that Haskell has types and not sets.
16:32:04 <tac> ah, nvm
16:32:05 <elliott> you can reason about types as sets, though.
16:32:06 <tac> I think I got it
16:32:27 <tac> robde: A type has structure, a set is just a bag of things.
16:32:29 <elliott> (for instance there is no such thing as an intersection of types.)
16:32:40 <tac> robde: All operations for a type must respect the structure of the type.
16:33:43 <tac> robde: If you're familiar with set theory in math... you might be subtly aware that given two integers n and m, you can represent n and m both sets sets. Thus, you can take the union (or intersection) of two integers.
16:33:56 <tac> That is weird and horrifying (no one ever intends to do such an insane thing)
16:33:58 * hackagebot tianbar 0.1.3.1 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.1.3.1 (AlexeyKotlyarov)
16:34:05 <tac> But type theory makes that nonsense impossible
16:34:35 <lispy> robde: http://golem.ph.utexas.edu/category/2013/01/from_set_theory_to_type_theory.html
16:35:14 * elliott doesn't think robde wants to learn type theory to learn how to talk about "x :: Int; x = 5" ;)
16:35:25 <tac> Probably not :P
16:35:26 <S_J> Anyone have some good propertys for a linked list? insertSorted for example. Obv the listlength should be increased with 1. more?
16:36:45 <tac> S_J: what is the question exactly? Properties that hold for all link lists?
16:37:22 <FreeFull> All Haskell functions are unary
16:37:46 <FreeFull> x :: Int  isn't unary, and therefore isn't a function
16:39:05 <robde> are type constructors functions?
16:39:14 <tac> sort of....
16:39:18 <ion> If they take a parameter, yes.
16:39:19 <tac> They are type-level functions
16:39:32 <FreeFull> :k Maybe
16:39:33 <lambdabot> * -> *
16:39:35 <tac> @kind ([])
16:39:36 <lambdabot> * -> *
16:39:47 <tac> * is the kind/type of types.
16:40:44 <FreeFull> I like dependent typing because then you don't have to worry about the type/code distinction as much, and can mix the two
16:40:56 <shelf> mind if i ask a silly question?
16:41:03 <tac> shelf: go for it :)
16:41:08 <shelf> what do we call a type constructor / data declaration that has a type variable? is that an example of an indexed type?
16:41:26 <shelf> (i'm in a subject spanning agda and GADTs, just not sure how the terminology spreads)
16:42:04 <Peaker> shelf, "type constructor" is when it has a type variable, otherwise it's just a plain type
16:42:06 <tac> There are some differences in how Haskellers and Agdars call things. I don't think I've heard "indexed type" in Haskell
16:42:20 <shelf> type families?
16:43:46 <shelf> thanks Peaker . do you think that is semantically different to an indexed type family or a function onn types in agda
16:44:48 <shelf> i see from haskellwiki that 'parametric type' seems to be the phrase used
16:45:05 <shelf> to distinguish from type families
16:45:07 <FreeFull> Wouldn't an indexed type be something like   Vec Nat a
16:45:16 <Peaker> shelf, a type family is always indexed, isn't it?
16:45:26 <shelf> yeah, i think so
16:46:14 <robde> what does a type constructor "return" (is this the right word?)? a value? data?
16:46:30 <shelf> so the difference between a parametric type like Maybe and an indexed type family like Vec...
16:46:34 <robde> it probably "constructs", right?
16:46:45 <shelf> robde: would not use 'return' here, perhaps 'define'?
16:46:51 <FreeFull> robde: a type
16:47:06 <FreeFull> Or another type constructor
16:47:31 <FreeFull> :k Either String
16:47:32 <lambdabot> * -> *
16:47:59 <Peaker> shelf, A type family is projective and a type constructor is is injective, so that's an important semantic difference (though a data family is injective again)
16:49:11 <shelf> i'll google and try to understand that :>
16:49:49 <Peaker> shelf, if you have   Foo a, and Foo b   then if a and b are distinct, Foo a and Foo b will always be distinct.  With type families, Foo a and Foo b can be the same even if a and b are different
16:49:57 <johnw> @tell Eelis if you have questions, feel free to contact me at johnw@fpcomplete.com
16:49:57 <lambdabot> Consider it noted.
16:50:23 <shelf> woah now. i had it around the opposite way
16:50:36 <shelf> most interesting.
16:51:12 <Peaker> shelf, Maybe Int and Maybe String are necessarily different types, also if you s/Maybe/AnyConcreteTypeConstructor.    But  TypeFamily Int can easily equal TypeFamily String
16:51:13 <FreeFull> Maybe Int will be always different from Maybe Bool
16:54:05 <arkeet> A type family is projective <- I have no idea what this means.
16:54:10 <shelf> i follow. the type families example i'm looking at now resembles something i achieved using classes, though
16:54:21 <robde> FreeFull: a type constructor defines a type? so (Just 5) is a type?
16:54:33 <tac> robde: Just 5 is a value
16:54:34 <arkeet> Just is not a type constructor.
16:54:38 <arkeet> Maybe is a type constructor.
16:54:38 <tac> :t Just 5
16:54:39 <lambdabot> Num a => Maybe a
16:54:48 <tac> :k Num a => Maybe a
16:54:48 <lambdabot> *
16:54:53 <arkeet> :k Maybe
16:54:53 <lambdabot> * -> *
16:54:55 <robde> oh!
16:54:59 <tac> Every term has a type and every type has a kind.
16:55:10 <arkeet> type constructors make new types out of old types.
16:55:15 <Zorg__> read "5" may not work because it may not know which type to convert, so I can do read "5" :: Integer. Ok. How would I be able to mend this though? map read ["5"]
16:55:16 <FreeFull> robde: Just is a data constructor
16:55:26 <FreeFull> Because it makes data, and not a type
16:55:33 <arkeet> I might call it a value constructor.
16:55:49 <tac> Just is just a function :)
16:55:53 <tac> @type Just
16:55:54 <lambdabot> a -> Maybe a
16:56:16 <tac> But it's also a constructor, and so you can pattern-match on it
16:56:31 <tac> Since every Maybe a is either created with Just or with Nothing
16:56:46 <geekosaur> :t map read [5] :: [Integer]
16:56:46 <lambdabot>     No instance for (Num String) arising from the literal `5'
16:56:47 <lambdabot>     Possible fix: add an instance declaration for (Num String)
16:56:47 <lambdabot>     In the expression: 5
16:56:48 <geekosaur> oops
16:56:49 <tabemann> what does dropWhileEnd really do? (how does it differ from dropWhile)?
16:56:53 <geekosaur> :t map read ["5"] :: [Integer]
16:56:53 <lambdabot> [Integer]
16:57:19 <FreeFull> I want to add an instance for Num String now
16:57:20 <geekosaur> alternately
16:57:22 <tabemann> oh I see
16:57:42 <tac> @src dropWhileEnd
16:57:42 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:57:43 <geekosaur> :t map (read :: String -> Integer) ["5"]
16:57:44 <lambdabot> [Integer]
16:58:03 <FreeFull> geekosaur: There is a third alternative
16:58:15 <geekosaur> sure, I'm not claimig that's the only one
16:58:37 <FreeFull> :t (map :: (String -> Integer) -> [String] -> Integer) read ["5"]
16:58:37 <lambdabot>     Couldn't match type `[Integer]' with `Integer'
16:58:37 <lambdabot>     Expected type: (String -> Integer) -> [String] -> Integer
16:58:37 <lambdabot>       Actual type: (String -> Integer) -> [String] -> [Integer]
16:58:46 <FreeFull> :t (map :: (String -> Integer) -> [String] -> [Integer]) read ["5"]
16:58:46 <lambdabot> [Integer]
17:00:13 <arkeet> it would be nice to be able to partially specify a type, and have it infer the rest.
17:00:17 <geekosaur> :t (map :: (String -> Integer) -> ([String] -> [Integer])) read ["5"]
17:00:17 <Zorg__> hm. i like the "read :: String -> Integer" one, thanks.
17:00:18 <lambdabot> [Integer]
17:00:22 <arkeet> so you could say map :: (_ -> Integer) -> _
17:00:25 <geekosaur> :)
17:00:29 <arkeet> or so
17:00:34 <FreeFull> @let geekosaur = maybe "sexy" ("Just "++)
17:00:42 <lambdabot>  Defined.
17:01:14 <arkeet> @let type Foo a b = (a -> Integer) -> b
17:01:19 <lambdabot>  Defined.
17:01:20 <FreeFull> arkeet: I'm  sure there is a GHC extension for that
17:01:21 <arkeet> @let foo :: Foo a b -> Foo a b; foo = id
17:01:24 <lambdabot>  Defined.
17:01:29 <arkeet> FreeFull: I'm pretty sure I didn't see one.
17:01:30 <arkeet> :t foo map
17:01:36 <lambdabot> Foo a ([a] -> [Integer])
17:01:38 <arkeet> aw.
17:01:41 <FreeFull> Let's try type holes
17:01:45 <shelf> okay. so the type parameter in a normal type constructor produces a unique type that must be statically matched (or replaced with a type variable), whereas type families produce a common type with an underlying representation / constructor that is different depending on the type index / family instance?
17:01:49 <arkeet> FreeFull: those are a lie. they're really value holes.
17:02:06 <shelf> and the relevant operations are defined in each instance
17:02:12 <FreeFull> :t map (read :: ?a -> Integer) ["5"]
17:02:14 <shelf> does that seem somewhat correct?
17:02:17 <lambdabot> parse error on input `?'
17:02:23 <FreeFull> :t map (read :: _ -> Integer) ["5"]
17:02:28 <lambdabot> parse error on input `_'
17:02:32 <shelf> (type families and GADTs slowly merging in my mind)
17:02:37 <FreeFull> :t geekosaur
17:02:42 <lambdabot> Maybe [Char] -> [Char]
17:03:16 <arkeet> tbh I'd still rather use ImplicitParams than TypeHoles.
17:03:36 <arkeet> because you basically get the same thing, except you get to name the holes.
17:04:22 <FreeFull> :t ?a
17:04:22 <lambdabot> parse error on input `?'
17:04:33 <arkeet> lambdabot doesn't have it :(
17:04:35 <elliott> arkeet: you can name holes _foo or whatever.
17:04:37 <arkeet> elliott: fix that
17:04:37 <FreeFull> :t parse error on input ?
17:04:38 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
17:04:39 <elliott> which is awful.
17:04:46 <FreeFull> :t parse error on input `?'
17:04:47 <lambdabot> parse error on input `?'
17:04:49 <FreeFull> :D
17:05:05 <FreeFull> Error quine
17:05:47 <geekosaur> hrm, used to have implicit parameters...
17:05:48 <arkeet> :t _foo
17:05:49 <lambdabot>     Not in scope: `_foo'
17:05:49 <lambdabot>     Perhaps you meant `foo' (line 125)
17:05:54 <arkeet> elliott: oh, with TypeHoles?
17:05:58 <elliott> arkeet: yes.
17:06:06 <arkeet> :(
17:06:17 <arkeet> can we have honest type holes?
17:06:22 <arkeet> instead of type-holes-which-are-really-value-holes
17:07:07 <elliott> those will be called kindholes.
17:07:13 <elliott> similarly data kinds will be called datasorts.
17:07:15 <arkeet> :(
17:08:32 <geekosaur> :t show (?a)
17:08:32 <lambdabot> Not in scope: `?'
17:08:33 <CODEtaku> can anyone give me a simple example of how I would create/use a type hole?
17:08:36 <geekosaur> bleh
17:08:43 <FreeFull> > geekosaur Nothing
17:08:47 <lambdabot>   "sexy"
17:08:49 <arkeet> CODEtaku: http://www.haskell.org/haskellwiki/GHC/TypeHoles
17:09:25 <CODEtaku> thanks arkeet, I think they might be helpful for something I'm trying to do... someone suggested GADTs before, but I don't understand them
17:09:59 <arkeet> CODEtaku: huh?
17:10:21 <arkeet> typeholes have nothing to do with gadts
17:11:14 <CODEtaku> I want to deal with RNA and DNA sequences.  Both are lists of Nucleotides, but DNA can't have U and RNA can't have T... that's not something I could do with type holes?
17:11:21 <geekosaur> no
17:11:39 <geekosaur> type hole is "make the compiler tell you what type it inferred at some point"
17:14:12 <CODEtaku> ohhh, ok, I suppose I've got to try to figure out GADTs then if I don't want to resort to messiness like pattern matching on invalid values and kicking errors
17:16:51 <Peaker> CODEtaku, Another alternative is to have 2 duplicate data constructors
17:17:12 <latro`a> :t geekosaur
17:17:13 <lambdabot> Maybe [Char] -> [Char]
17:17:35 <geekosaur> this might also just be typeclasses (Purine, Pyrimidine, DNAtide, RNAtide?)
17:18:31 <jxm> Guys, I joined this chan earlier today and I am amazed. I keeps rolling like hell. Why is that ? I mean, it seems that there _always_ is someone active there.
17:18:32 <CODEtaku> how do you mean?  I first tried DNA = A|C|G|T and RNA = A|C|G|U and it complained about the 'redefinition' of A, C, and G
17:18:38 <geekosaur> although I think that's not sufficient to express in the type system that two values should be both purines or both pyrimidines...
17:18:45 <Peaker> CODEtaku, add a prefix like "D" and "R" to each
17:18:50 <geekosaur> yes, those are redefinitions
17:19:04 <jxm> It's not like if Haskell was the most popular language in use..
17:19:30 <Peaker> CODEtaku, another alternative:  data Nucleotide = A|C|G|TU
17:19:31 <jxm> See, 4 people spoke just in the time it took me to write the above !
17:19:49 <jxm> I mean it seriously, I do not understand. What is the "secret" ?
17:19:51 <CODEtaku> Peaker: Ahh!  I like that one!
17:20:28 <geekosaur> depends on whether you need a DA and an RA to be recognized as "the same thing"
17:21:11 <jxm> #ocaml is quiet, #erlang is slow, what makw #askell so lively ?
17:21:16 <CODEtaku> jxm: It might have to do with the fact that this community is terribly helpful... many other language rooms you get nothing, when I ask a question here I get such great answers I feel bad for taking up the peoples brain cycles
17:22:10 <CODEtaku> geekosaur: I won't really need to mix and match DNA and RNA, I just wanted it to be conceptually clean to start with since I'll be building a lot on top of it
17:22:10 <johnw> CODEtaku: we're here to help anyone with their adventures in Haskell
17:22:29 <jxm> CODEtaku, sure, but believe me, #erlang community is amazingly helpful too, but people sleep sometimes :-)
17:22:37 <CODEtaku> I'm just learning Haskell and re-doing all the Project Rosalind problems I already solved in other languages
17:22:46 <johnw> the quality of help on #coq is also stellar, when people are around
17:23:06 <jmcarthur> maybe it's due to #erlang having 337 people while we have 1046
17:23:14 * jxm think that (and please, no offense intended) maybe the less mainstream a language is, the more active the community is striving to be. But that cannot explain it all.
17:23:17 <CODEtaku> that's good to hear, when I get time I wanted to investigate Coq too... never enough hours in the day
17:23:19 <jmcarthur> easy to be lively with lots of people
17:23:32 <Zesler> coq?
17:23:46 <jxm> jmcarthur, yeah, maybe haskellers have more of an irc culture ...
17:23:47 <jmcarthur> coq is a pretty nice theorem prover
17:23:48 <CODEtaku> it's for developing proofs
17:23:49 <Demos_> coq is a trap for haskellers
17:23:56 <johnw> jxm: well, people here are using Haskell because almost universally they want to be.  Popular languages become industrial languages, which means people are using it because work requires them too, but it may have nothing at all to do with their interests
17:24:16 <Zesler> Ahh never used it before.
17:24:37 <jxm> In any casem thans guys, makes me think of the IRC chans I was hanging out in almost 20 years ago when BBS dropouts were looking for a more interactive place to chat :-)
17:24:38 <johnw> Zesler: if you are looking for brain candy, start here: http://www.cis.upenn.edu/~bcpierce/sf/
17:24:39 <jmcarthur> Zesler: see http://adam.chlipala.net/cpdt/
17:25:00 <jmcarthur> both are good :)
17:25:02 <jxm> s/typos/correct works/g
17:25:35 <jxm> (that last regex is an implicit implementation of the famed do_as_I_say function)
17:25:41 <jxm> s/works/words/
17:26:10 <jxm> Fascinating. Coq is not even turing complete and is sooo useful
17:26:38 <jxm> Anyone had ever thought of comparing it to what quickcheck can do ?
17:27:03 <johnw> compare Coq with quickcheck?
17:27:07 <jxm> johnw, I get your point
17:27:14 <Demos_> the very fact that it is not turing complete makes it usefull. And I think the jist is that formal verification is good when a) you have the time. b) you have a critical system, and c) you know what the system is actually supposed to do
17:27:30 <johnw> Demos_++
17:27:37 <jmcarthur> Turing completeness is overrated. all it means is that you can write useless programs.
17:27:38 <jxm> johnw, well, the other way around, as in "quickcheck is just a subset of coq"
17:27:57 <johnw> Demos_: I often wonder how long it took them to build the compcert compiler (a C compiler formally verified in Coq)
17:27:59 <jxm> jmcarthur, hehehe, I like your attitude :-)
17:28:00 <Demos_> what is the difference between coq and agda?
17:28:22 <CODEtaku> how are quickcheck and Coq comparable?  quickcheck runs random test cases, right?
17:28:29 <elliott> they are different languages.
17:28:30 <Demos_> johnw, oh wow, that is a cool idea!
17:28:49 <jxm> johnw, rake it from someone who does not know about Coq so much (despite being french), but find quickcheck immensely useful
17:29:00 <Nisstyre> CODEtaku: quickcheck can never prove your code works, it can only try to falsify assertions that would be true if it did
17:29:02 <CODEtaku> just in terms of showing a function is correct?
17:29:07 <jmcarthur> Demos_: agda is a bit more useful for general programming and has, IMO, a nicer syntax. it doesn't have tactics. it doesn't distinguish between Prop and Set. you pretty much have to use emacs to be productive with it. agda-mode is awesome
17:29:07 <jxm> s/rake/take/g(although I think I got this one wrong only once)
17:29:07 <S_J> what is BBS?
17:29:29 <jmcarthur> Demos_: not all of those points are meant to reinforce that agda is "better", to be clear
17:29:33 <geekosaur> heeeeh
17:29:40 <geekosaur> dial-up computer bulletin board systems
17:29:58 <geekosaur> what we did in the 1970s - 1980s
17:29:59 * jxm loves it how reaction get triggered _fast_ on this channel whith just that tiny bit of subversive/seemingly uninformed remark :-)
17:30:18 <jmcarthur> jxm: wait, what was subversive/uninformed?
17:30:23 <CODEtaku> living in West Virginia, I was doing BBS well into the 90s
17:30:28 <johnw> jxm: I can see where Coq and quickcheck might be seen to do a similar thing -- that of verifying software, but the way they do it is so different I think it's hard to compare them.  quickcheck is a brief, randomized search for the existence of values which invalidate your program's invariants, while Coq formally proves that your program follows from your types.  At least, that's my take on it
17:30:41 <Nisstyre> I think of quickcheck as the scientific approach to validating code, and dependent typing as the mathematical approach
17:30:49 <Nisstyre> both are useful and good ideas
17:31:11 <S_J> jxm: how do you use quickcheck normally? I mean obv you cant rely on it fully since it is random. can you explain how you use it in your development process? do you test every function with quickcheck and then write unittests manually for the really important ones?
17:31:36 <Demos_> you use quickcheck when you can come up with properties about functions
17:31:50 <jxm> jmcarthur, I mean that the comparison if invalid in that Coq has obviously nothing to do with Coq in itself and my remark could be interpreted as one done by someone who does not understand what the difference is between Coq and Quickcheck
17:32:07 <jmcarthur> jxm: ah!
17:32:07 <Nisstyre> quickcheck is basically the idea of falsifiability ala Karl Popper applied to software
17:32:15 <Nisstyre> it looks for "black swans"
17:32:19 <Zesler> Thanks for the links johnw and jmcarthuer, never seen the day when I would get responses that quickly
17:32:25 <Zesler> Yep this channel has magical powers.
17:32:26 <Nisstyre> Agda and co. try to prove things about it mathematically
17:32:26 <jxm> S_J, I do not use it myself, but I witnessed several uses of it that are amazing (to me)
17:32:52 <S_J> such as
17:33:05 <johnw> I think idris combines some of the best of Agda and Coq, but it's young enough that it lacks the cool software built around Agda (agda-mode) and Coq (proof-general)
17:33:06 <jmcarthur> jxm: Coq is for *actual* proofs. a valid proof in Coq is absolute, but can be difficult to write. QuickCheck is for things like unit tests. a passing test is QuickCheck is not absolute, but is much easier to write than a proof.
17:33:11 <CODEtaku> does quickcheck automatically test bounds or only random cases?  I just assume it tests with maxvals of the parameters and maybe some other 'special' values in addition to random?
17:33:13 <jmcarthur> *in QuickCheck
17:33:20 <jxm> The last one being this: http://www.erlang-factory.com/conference/ErlangUserConference2013/speakers/JesperLouisAndersen -Safetyvalve - Load Regulation with Specifications
17:33:21 <jmcarthur> CODEtaku: just random, afaik
17:33:29 <elliott> I can imagine something like quickcheck being a tactic to let you *disprove* a proposition.
17:33:35 <Nisstyre> jmcarthur: quickcheck does help to avoid confirmation bias though
17:33:38 <Nisstyre> if you do it right
17:33:40 <elliott> it can never prove a proposition, or at least if it could it would just be brute-forcing.
17:33:46 <jmcarthur> elliott: ah, yes
17:33:50 <elliott> so it could integrate into proof assistants in that way.
17:33:54 <johnw> elliott: although, you'll still get false positives even then
17:33:55 * geekosaur thinks of quickcheck as a fuzzer
17:33:57 <Nisstyre> elliott: that's what I said basically
17:34:02 <elliott> if random testing shows a counterexample you've disproved it, so that's formally valid.
17:34:05 <jxm> johnw, yes, of course you are right - please read my other comments before thinking I am mixing apples and oranges
17:34:08 <Nisstyre> it's a more sciency approach to testing
17:34:09 <elliott> johnw: I don't see how
17:34:11 <geekosaur> throw random stuff at a function, see if it produces unexpected output
17:34:15 <S_J> Nisstyre: what do you mean confirmation bias?
17:34:19 <elliott> (exists x. ~ P x) -> ~ forall x, P x
17:34:20 <jmcarthur> informally, quickcheck can prove existentials, but not universals
17:34:21 <johnw> elliott: if the random set doesn't contain an invalidating value
17:34:24 <Nisstyre> S_J: I mean looking for things that validate your assumptions
17:34:25 <elliott> oh, sure
17:34:29 <elliott> that's why it's a tactic; tactics can fail
17:34:31 <Nisstyre> S_J: rather than trying to disprove them
17:34:34 <johnw> ah, ok
17:34:36 <Nisstyre> which is what QC is designed for
17:34:36 <elliott> you could even write something like
17:34:38 <johnw> jxm: got it :)
17:34:41 <jxm> jmcarthur, I am french, do not get me started on how good Coq ids ;-)
17:34:43 <jfischoff> randomly searching for counter examples is a tried and true mathematical process
17:34:48 <Zesler> lol
17:34:48 <fwappy> :t Num
17:34:49 <lambdabot>     Not in scope: data constructor `Num'
17:34:49 <lambdabot>     Perhaps you meant `Sum' (imported from Data.Monoid)
17:34:51 <jmcarthur> jxm: fine fine :)
17:35:01 <elliott> quickcheck : RNGSeed -> (Maybe (Ex (\x -> ~ P x)), RNGSeed)
17:35:04 <elliott> but whatever.
17:35:05 <CaptainK> need to ask some newbie qlarifications, (not being able to fully comprehend the lyah)...
17:35:07 <jfischoff> by that I mean it has been used by mathematicans and continues to be
17:35:08 <jxm> Guys, I think I like you, the whole bunch :-)
17:35:32 <fwappy> :i Num
17:35:35 <Nisstyre> jfischoff: yeah, that's a good point.
17:35:39 <geekosaur> (I don't even think of it as scientific approach so much as engineering approach)
17:35:45 <jxm> Stop arguing over my remarks, you are all right, never saw a chan jump on me like that ;-)
17:35:54 <geekosaur> :)
17:35:59 <elliott> I don't think we're arguing.
17:36:06 <geekosaur> you never know what starts the juices flwoing around here :)
17:36:09 * jxm thinks ther is hope for the workd after all
17:36:30 <jxm> gee, use the do_what_I_mean() fun on that last one
17:36:52 <CaptainK> what is the first line in a program?  main = do?
17:36:52 <Peaker> that looks like a C function call!
17:37:06 <jxm> You reply do fast, my scrollback buffer is in pain
17:37:11 <jxm> s/do/too
17:37:51 <CaptainK> unless importing or typing variables
17:37:51 <jxm> Demos_, agda is newer but not so much better
17:37:52 <elliott> CaptainK: whatever you want it to be.
17:37:52 <geekosaur> main is the program entrypoint. note that it doesn't have to necessarily be a "do" expression, but it *does* have to have type (IO a) for some a
17:37:52 <geekosaur> (most commonly a is ())
17:37:57 <dwcook> CaptainK, what does it matter what the first line is?
17:38:02 <shelf> schonfinkeling
17:38:03 <jxm> Demos_, http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.AgdaVsCoq
17:38:13 <geekosaur> it doesn't have to be the physically first definition in the program
17:38:31 <iKlsR> any screencast sites for haskell?
17:38:36 <CaptainK> well don't want to use a bunch of let statements for one, so don't want a main = do
17:38:37 <iKlsR> paid or free..
17:39:24 <jxm> Demos_, one big difference is that Coq had Gallia, the DSL that specifies rules, and a second DSL for engine works, all with some vernacular language for tying it all
17:39:42 <jxm> Demos_, agda uses a more unified syntax
17:39:56 <Nisstyre> jxm: also http://www.cis.upenn.edu/~bcpierce/sf/
17:40:19 <CaptainK> so not sure what the rules are for do block..save that you use let alot
17:40:28 <jxm> Nisstyre, looking
17:40:44 <geekosaur> um. you use let a lot anyway
17:40:56 <jxm> Nisstyre, yes, saz that one some time ago, a good prez indeed
17:40:56 <geekosaur> it's not at all specific to do
17:40:59 <Nisstyre> jxm: it's a book that uses Coq to teach operational semantics
17:41:03 <Nisstyre> yeah
17:41:03 <Peaker> CaptainK, do block is composed of "statements" that perform "actions" and may or may not bind the result value to a name, and giving names to pure expressions (that's when you use "let")
17:41:09 <jxm> s/prez/book sorry
17:41:31 <elliott> you can just put definitions at the top level like main;.
17:41:33 <elliott> and then use them in main.
17:41:39 <elliott> but I don't really understand the problem
17:41:52 <Demos_> do is a way to chain a lot of >>= in a nice way
17:41:54 <CaptainK> ah ok, so it is to make a branch of some logic and when done the values can be reassigned ?
17:42:07 <CaptainK> not global necessarily
17:42:10 <geekosaur> reassigned?
17:42:16 <CaptainK> reset
17:42:44 <geekosaur> it establishes local bindings within an expression
17:43:11 <jxm> Guys, lets switch topics (let's see if I get the second strike right on the sweet spot hehehe :-) ) - I was wondering earlier if monads could themselves be abstracted with a generic "combine" operator that would be redifed whenever needed and define some "context" in the code
17:43:12 <CaptainK> thats sounds like a good answer
17:43:35 <geekosaur> often this is done to tell the copmpiler you're using the result of some expression multiple times and it should try to only compute it once
17:43:50 <geekosaur> other times it's just convenience
17:44:08 <geekosaur> (so I can say `x` instead of `some long expression`)
17:44:14 <jxm> aka, use a o (in french "rond" dunno in english, the combine operator as in (f o g )(args)) operator and redefine it on-the-fly
17:44:35 <jxm> Like you would use a monad but instead just redefine the term separator on-the-fly
17:44:39 <CaptainK> geekosaur: using the let, establishes that?
17:44:53 <geekosaur> yes
17:44:59 <CaptainK> ok, got it.
17:44:59 <jxm> s/redified/redifiNed/
17:45:19 <jxm> Nisstyre, BTW thank for the link I did loose that one
17:45:34 <CaptainK> so I can start my program with "main =" and start from there
17:46:16 * jxm is scrollign back to check the replies he missed, but this is too dense (2:45 AM here)
17:46:24 <tac> CaptainK: btw, let is totally just a convenience in Haskell. You never actually ever *need* let.
17:48:01 <geekosaur> (although achieving some of its recursive features may be rather more involved otherwise. mmm, fixpoint combinators)
17:49:29 <tabemann> umm... isn't let kind of necessary when, within an expression, you want to use a value more than once, and that value is dependent upon previously calculated values in that expression (not on parameters or like, which would enable using where)?
17:50:05 <tabemann> well
17:50:37 <CaptainK> curious
17:50:38 <tabemann> you could break out your expression dependent on multiple references to the value into a separate lambda and pass the value to that (but somehow that doesn't seem as nice as using let)
17:51:02 <geekosaur> most haskell expressions are pure and immutable, so you could always just write the same expression out again and it would be indistinguishable in result from binding it once
17:51:09 <Rarrikins> tabemann: You can do something completely pointless.
17:51:14 <geekosaur> "referential transparency"
17:51:17 <elliott> geekosaur: only most?
17:51:44 <jxm> What, noone bites on my monads vs programmatic separators questions ? I am _almost_ disapointed ( :-)
17:51:46 <geekosaur> I'm assuming CaptainK is not quite up to that level
17:52:06 <CaptainK> geekosaur: I'm still bottom feeding, there are more levels?
17:52:16 <CaptainK> :P
17:52:17 <tabemann> geekosaur: doesn't that have the difference that it creates two different thunks, that will have to be evaluated twice?
17:52:19 <geekosaur> insert /bin/ls quote here :[
17:52:22 <geekosaur> er :p
17:53:14 <geekosaur> tabemann, yes, but referential transparency means the result should be the same however many times it's done
17:53:15 <jxm> Anyone doing Ocaml in addition to Haskell around here ?
17:53:17 <elliott> well, getChar is pure and immutable too. that's the point, after all :)
17:53:27 <jxm> s/doing/using/
17:53:32 <Rarrikins> @. pl undo do { a <- b c; d a; e a }
17:53:32 <elliott> jxm: why, are you trying to troll? :P
17:53:35 <lambdabot> b c >>= ap ((>>) . d) e
17:53:35 <lambdabot> optimization suspended, use @pl-resume to continue.
17:53:43 <elliott> er, that was re the previous question.
17:53:46 <Rarrikins> No need to do it twice, even without let.
17:53:46 <geekosaur> performance isn't really captured by this
17:53:56 <jxm> elliott, really, not - I am trying to understanf the functional languages panorama
17:54:07 * tabemann is a (former) OCaml coder
17:54:21 <jxm> Not trying to launch a who has the biggest one topic
17:54:46 <jxm> Merely trying to understand which languages are attractiove to what kind of minds
17:55:20 <jxm> (sorry if that sounded like trolling - I am just on an exploratio ntrip here)
17:55:32 * tabemann used to code in OCaml because he couldn't wrap his brain around laziness and monads in the past, and thus couldn't get beyond strict languages with imperative features
17:56:28 <jxm> @undo fpobar
17:56:28 <lambdabot> fpobar
17:56:30 <prophile> I think there's probably more to ocaml than "haskell for people that don't haskell"
17:56:37 <geekosaur> and yes, there are ways to do it without any bindings --- but it is worth noting that @pl (which is a bot function that transforms expressions to point-fre form) is infamous for producing unreadable output
17:56:50 <jxm> @undo [x | x <- mylist]
17:56:50 <lambdabot> concatMap (\ x -> [x]) mylist
17:56:55 <geekosaur> it works, but there is a lot to be said for code that you can actually understand :)
17:57:40 <jxm> mmmh, y0ou guys have a fancy bo
17:57:43 <jxm> bot
17:58:58 <tac> yep
17:59:28 <tac> @djinn Not (Not (Not (Either (Not a) a))) -> Not (Either a (Not a))
17:59:28 <lambdabot> f a b =
17:59:28 <lambdabot>     case b of
17:59:28 <lambdabot>     Left c -> void (a (\ d -> d (Right c)))
17:59:28 <lambdabot>     Right _ -> void (a (\ e -> void (e (Left (\ f -> e (Right f))))))
17:59:31 <prophile> @pl \a b c d e f g -> g f e d c b a
17:59:33 <lambdabot> flip (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id)))))
17:59:40 <prophile> far more readable
18:00:24 <CODEtaku> what is that "void" in there?  I haven't come across void in Haskell before
18:00:50 <prophile> void in djinn is a value of type Void -> a iirc
18:00:52 <tac> CODEtaku: It's not really useful in Haskell
18:00:56 <johnw> void f = f >> return ()
18:01:13 <tac> Yeah void is "ex falso quodlibet"
18:01:31 <prophile> johnw: it's defined on functors rather than monads isn't it?
18:01:37 <johnw> :t void
18:01:38 <lambdabot> Functor f => f a -> f ()
18:01:42 <johnw> good point
18:01:45 <prophile> so it's fmap (const ())
18:01:50 <johnw> right
18:01:52 <tac> void is like this: You give it a genie, and it will grant you any wish.... the trouble is genies don't exist in real life.
18:02:06 <johnw> I think tac and I are talking about different voids
18:02:13 <tac> @djinn (a, Not a) -> b
18:02:13 <lambdabot> f (a, b) = void (b a)
18:02:14 <prophile> tac's talking about the djinn void
18:02:23 <prophile> which was the context of the original question
18:02:39 <johnw> sorry to confuse the matter
18:03:10 <tac> @djinn Not genie -> genie -> anyWishYouWant
18:03:10 <lambdabot> f a b = void (a b)
18:03:14 <kini> <tac> Yeah void is "ex falso quodlibet"
18:03:14 <kini> whoa
18:03:50 <prophile> delicious curry-howard
18:04:00 <tac> It tastes like logic
18:04:11 <elliott> it's called "absurd" in the void package
18:04:13 <elliott> also it's not totally useless.
18:04:32 <prophile> apparently Applicative is the SKI combinator calculus too, which is pretty insane
18:04:35 <CODEtaku> how can it be used elliott?
18:04:43 <elliott> for instance, vacuous :: Functor f => f Void -> f a.
18:04:47 <elliott> that's implemented as fmap absurd.
18:04:53 <elliott> and [] :: [Void].
18:04:56 <elliott> so vacuous [] :: [a]
18:05:03 <elliott> that example isn't useful but you can do things like that.
18:05:16 <elliott> you can use Void as the base-case for a variable type when doing strongly-typed de bruijn type thing
18:05:23 <DiegoNolan> what is the point of the NOINLINE pragma
18:05:27 <elliott> and then vacuous lets you lift stuff with no free variables to accept any number of free variables. etc.
18:05:31 <DiegoNolan> why would you not want a function to be inlined
18:05:44 <elliott> DiegoNolan: because the optimiser doesn't always get it right and because you have to be careful if doing unsafe stuff
18:06:08 <prophile> DiegoNolan: unsafePerformIO might need to only be evaluated once, but if it's inlined it might be evaluated a bunch of times
18:06:21 <geekosaur> also because sometimes delaying inlining may allow some other (sometimes better) optimization to fire instead
18:06:53 <DiegoNolan> prophile, could you provide an example where this could happen
18:07:43 <geekosaur> DiegoNolan, most often you're simulating a global mutable variable by a top level declaration which uses unsafePerformIO to create an IORef
18:07:53 <jxm> Des gens qui parlent ma langue dans le coin ?
18:08:02 <geekosaur> if that gets inlined, every inlining gets its own variable instead of using the single common top level one
18:08:11 <geekosaur> er, its own IORef
18:08:23 <DiegoNolan> ic
18:08:25 <jxm> (sorry, just a tongue-specific poll to check if I have fellow french guys around here)
18:08:51 <DiegoNolan> je suis
18:08:56 <DiegoNolan> not french
18:09:16 <Freze> je suis tres genial
18:09:31 * geekosaur understood the question, barely, but his French is rather rusty and somewhat limited (and decidedly nontechnical)
18:10:49 <CODEtaku> croissant baguette mon amie c'est la vie ballet Louvre
18:11:03 <CaptainK> Still trying to find out where they explain how to START your program.  Its not clear to me since all I have working so far is main = do, which requires the let
18:11:13 <Nisstyre> CaptainK: runghc
18:11:45 <CaptainK> no I mean when physically writing it out, what ways do you word it?
18:11:51 <CaptainK> main = do
18:12:02 <CaptainK> have that, but don't want to use lets all the time
18:12:05 <elliott> CaptainK: your question doesn't really make any sense, I'm afraid
18:12:06 <geekosaur> you keep repeating that some magic incantation
18:12:19 <elliott> and didn't any of the other times you asked it :P
18:12:47 <prophile> main = putStrLn "Hello, world!" is a good starting point :
18:12:50 <prophile> *:)
18:13:06 <CaptainK> yes, now how do you add to that?
18:13:14 <Nisstyre> CaptainK: you can define main as anything of type IO a
18:13:18 <CaptainK> a = 123; print a
18:13:23 <johnw> main = do
18:13:24 <johnw>     putStrLn "Hello"
18:13:24 <johnw>     putStrLn "and Hello again"
18:13:39 <prophile> main = do let a = 123
18:13:44 <prophile>            print a
18:14:08 <geekosaur> also sayable as:  main = putStrLn "Hello" >> putStrLn "and Hello again"
18:14:32 <Nisstyre> CaptainK: get a ghci session running, type main = print "hello, world!"
18:14:34 <CaptainK> johnw: now without the "do" please
18:14:36 <Nisstyre> type main again
18:14:44 <johnw> CaptainK: see geekosaur's answer
18:14:55 <Nisstyre> er, let main = print "hello, world!"
18:15:04 <Rarrikins> main = putStrLn "Hello\nand Hello again"
18:15:31 <CaptainK> when I type that of course it works, now press enter and type a=123 and enter and print a
18:15:31 <geekosaur> there is also
18:15:34 <geekosaur> :t interact
18:15:35 <lambdabot> (String -> String) -> IO ()
18:15:46 <CODEtaku> CaptainK: your main will probably call other functions and in those other functions you do not need 'let' like you do in a do block... does that help?
18:16:06 <johnw> CaptainK: it needs to be "let a = 123"
18:16:11 <elliott> CaptainK: perhaps you should work in a file rather than GHCi or something?
18:16:16 <elliott> I really don't know where you're having difficulty
18:16:19 <geekosaur> oh, hm. is your confusion because of the difference between ghci and ghc?
18:16:31 <geekosaur> ghci is not a top level, it's kinda like the inside of a do
18:16:41 <CaptainK> well, I don't want the main = do
18:16:48 <Nisstyre> that still trips me up because of muscle memory
18:16:48 <geekosaur> ...?
18:16:50 <hpaste> johnw pasted “CaptainK.hs” at http://paste.tryhaskell.org/90600
18:17:00 <elliott> ok, well, don't tell us what you don't want
18:17:03 <geekosaur> I still do not understand that assertion
18:17:04 <elliott> tell us what you do want and we might be able to help
18:17:08 <johnw> yes
18:17:18 <johnw> CaptainK: you are making us have to guess
18:17:18 <elliott> I told you before that you don't have to define everything with "let" in a do block
18:17:29 <elliott> you can say "foo = 3" and then "main = print foo", all at top level, no "let", no indentation
18:17:34 <elliott> if that doesn't satisfy then I don't know what you're looking for
18:17:58 <Nisstyre> elliott: I think he is confused about ghci vs. ghc
18:18:09 <geekosaur> although I wonder if you're instead tripping over the difference between an interpreter like perl / python / ruby and a compiled program which must have a well defined entry point (main in C and Haskell, sometimes other names in other languages)
18:18:17 <CaptainK> ah ok, let me digest that, seems like you can't have a naked expression at the top, so I can give it whatever I want?
18:18:41 <johnw> CaptainK: right, in a source file you cannot have naked global expressions like you can in Perl/Python/Ruby/etc.
18:18:53 <Nisstyre> CaptainK: you can have things like function declarations, type definitions, and other stuff at the top level
18:19:09 <Nisstyre> but no naked expressions as johnw said
18:19:10 <CaptainK> and library imports?
18:19:14 <Nisstyre> yes
18:19:40 <Nisstyre> also language pragmas, class declarations, instances, but you don't need to worry about those for a while
18:20:13 <CODEtaku> you said you were reading Learn You A Haskell, right?
18:21:18 <CaptainK> ya trying, maybe it needs more pictures for guys like me :P
18:21:39 <CODEtaku> I had a bit of difficulty after reading it going from it to actually making programs, as it doesn't really deal with many of the things you need, like how a whole program is usually structured
18:21:56 <Nisstyre> CaptainK: if you're learning Haskell coming from a language like C, Java, or Python then you will have a hard time
18:22:01 <Nisstyre> that's just going to happen
18:22:29 <CODEtaku> yeah, going from imperative "run this command, then this command, then this one" to the functional style is a challenge, but its worth the effort
18:23:04 <CaptainK> thats exactly it...trying to wrap my head around that...reminds me of fortran and pascal in my younger days
18:23:05 <Nisstyre> CODEtaku: I totally agree
18:23:18 <Nisstyre> CaptainK: maybe Scheme would be easier to start with
18:23:25 <Nisstyre> a lot of the tricks are transferable
18:23:35 <tac> After you drink the punch, you will hate every other language.
18:23:49 <CODEtaku> in the functional style you are doing more like declaring what your program is (rather than what it does), and when executed the computer evaluates the code and figures out what to do to 'run' the program
18:23:54 <tac> Side effects run rampant. There is no way to prevent people from doing obnoxious things in your type systems.
18:24:00 <tac> You will see corner cases everywhere >___>
18:24:02 <Nisstyre> tac: I would like just static typing in a lot of other languages
18:24:18 <tac> Nisstyre: yeah. Me too. I do PHP at work :<
18:24:33 <Nisstyre> tac: please don't talk to me about PHP. I just spent >30 hours debugging PHP.
18:24:48 <CODEtaku> is there a stackless version of Haskell?
18:24:57 <elliott> what do you mean by stackless?
18:25:04 <CaptainK> non functional?
18:25:11 <CaptainK> :P
18:25:14 <CODEtaku> does not use a stack for function calls when executing, so deep recursion can't blow the stack
18:25:21 <elliott> ghc doesn't really use such a stack.
18:25:25 <elliott> it has a pattern-matching stack. that's pretty inherent
18:25:28 <tac> CODEtaku: I'm not sure stackless even makes total sense. Haskell's evaluation model is completely bizarre
18:25:40 <tac> Things don't take up space that you would expect. And things you wouldn't expect do.
18:25:42 <elliott> "tail calls" work in GHC, but they're not quite as important.
18:26:05 <CODEtaku> I have run into stack overflows when screwing things up, and it made me concerned as the way things are defined there will often be a lot of deep recursion going on
18:26:14 <tac> (Incidentally, I actually had a friend exploit my new dice feature for my bot today because I didn't use tailcalls)
18:26:23 <CODEtaku> I know there is a 'stackless Python' and thought maybe someone had made a stackless Haskell
18:26:27 <Nisstyre> CODEtaku: in languages such as Scheme, you get around that because the language mandates that functions which are tail-recursive will only use up constant stack space
18:26:57 * tac likes to pretend that stacks are unbounded and that programs need only be correct to be useful.
18:26:59 <CaptainK> johnw: how do you use hpaste to create the output http://paste.tryhaskell.org/90600?
18:27:02 * tac lives in a bit of a fantasy world.
18:27:06 <CODEtaku> if you write a function which is not tail recursive though, the function can still be correct but it just won't run because it overflows the stack
18:27:13 <johnw> CaptainK: see the channel topic
18:27:15 <banister> how come the number 5 doesn't have a  type but just has a type constraint? can i define my own types like that too or is 5 special?
18:27:32 <Nisstyre> CODEtaku: it's certainly possible to do that in Scheme dialects
18:27:36 <geekosaur> numeric literals are special-cased
18:28:01 <geekosaur> this requires compiler support; there's an extension in GHC which, if you enable it, extends that special casing to strings
18:28:09 <tac> @type "abc"
18:28:10 <lambdabot> [Char]
18:28:20 <banister> @type 5.5
18:28:21 <lambdabot> Fractional a => a
18:28:56 <Nisstyre> geekosaur: and it's awesome for Text
18:29:17 <johnw> banister: because there are many kinds of 5.  Int, Integer, Int32, Float, etc.
18:29:24 <geekosaur> http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1360006.4.1 is the formal definition of how numeric literals are handled
18:29:30 <ion> Complex CReal
18:29:37 <johnw> banister: as geekosaur said, this is a GHC feature
18:29:46 <banister> johnw: yeah, i was just curious if we could do something smiilar with our own types
18:29:54 <geekosaur> not without compiler support
18:30:07 <johnw> banister: it only makes sense for literals, and you can't define new literals
18:30:09 <geekosaur> as I mentioned, there is an extension in GHC that can extend it to strings
18:30:19 <Nisstyre> banister: you can certainly make instances of Num and IsString or whatever
18:30:22 <elliott> CODEtaku: when you get a "stack overflow" it isn't because of something like function calls
18:30:24 <geekosaur> someone proposed one for lists but it got shot down (for good reason, I think)
18:30:27 <elliott> it's because you actually have a space leak.
18:30:31 <Nisstyre> but you can't make your own classes with special syntax/semantics
18:30:36 <elliott> you can increase the size of the stack used but its existence is more or less inherent
18:30:44 <elliott> and if there was no such stack then your program would just use all your RAM instead
18:30:50 <geekosaur> also I would not be surprised if SugarHaskell had some way to do it
18:30:57 <geekosaur> but, well, that's not standard Haskell
18:31:08 <Nisstyre> geekosaur: interesting idea
18:31:24 <Nisstyre> geekosaur: isn't MonadComprehensions sort of along those lines?
18:32:14 <johnw> I thought OverloadedLists was coming soon
18:32:17 <CODEtaku> I'm referring to the stack in the process space maintained by the OS, the place where registers and instruction pointer get pushed when a function is called, are you referring to the same thing?
18:32:23 <geekosaur> which, the list extension? it was more like imputing a fromList so you could e.g. initialize a set or map with a list literal
18:32:30 <johnw> http://hackage.haskell.org/trac/ghc/wiki/OverloadedLists
18:32:51 <johnw> and this commit message: http://www.haskell.org/pipermail/ghc-commits/2013-February/000796.html would seem to indicate it's already in GHC HEAD
18:33:03 <geekosaur> CODEtaku, that's applicable to strict evaluation, not so much to the way Haskell does evaluation
18:34:07 <CODEtaku> yeah, I realize that functions in haskell have essentially nothing to do with function calls after compile time, but it obviously does still do such things in at least some circumstances
18:34:12 <johnw> CODEtaku: trying to think about how Haskell code actually execute (operationally) too early in the learning cycle is not helpful, based on my personal experience of trying to do so too many times :)
18:34:22 <geekosaur> ^^
18:34:26 <tac> Yeah.
18:34:36 <Nisstyre> geekosaur: this is valid code with -XMonadComprehensions "[a | a <- (*3)] 3"
18:34:37 <tac> It's best to pretend like the evaluation order acts like it does in any other language
18:34:40 <Nisstyre> o_O
18:34:40 <tac> At first*
18:34:49 * elliott agrees with johnw but not with tac.
18:35:02 <CODEtaku> heh, yeah, I try not to johnw, I was just surprised when I got a stack overflow... I've always considered the functioning of the stack to be hostile to recursion, I expected Haskell would work around it
18:35:21 <Zesler> so long as its tail-based recursion
18:35:31 <johnw> CODEtaku: well, let's just so it's not so cut and dry
18:35:36 <johnw> s/so/say
18:35:37 <CODEtaku> I do really want to read about the internal details of the Haskell compiler, but not until I understand it better
18:35:38 <geekosaur> right but a stack overflow in Haskell is not a function call stack overflow, it's a pattern matching stack overflow.
18:35:40 <Nisstyre> johnw: so what happens if I enable both MonadComprehensions and OverloadedLists?
18:35:40 <elliott> Zesler: it's not really that closely related to tails in haskell.
18:35:42 <ekipan> tail-based recursion strict in the accumulator*
18:35:55 <johnw> Nisstyre: I don't have a newer GHC installed to tell you :)
18:36:10 <johnw> but I have nightlies at http://ghc.newartisans.com that you can try out, if you're on Mac or Linux
18:36:26 <CODEtaku> geekosaur: Oh!  I hadn't thought of that... I wish I still had the code or remembered what I was doing when I got the stack overflow
18:36:35 <Nisstyre> johnw: I am on Lunix yeah
18:36:41 <johnw> then enjoy!
18:36:48 <johnw> hsenv will make it very easy to play around with it
18:37:17 <johnw> Nisstyre: mkdir test ; cd test; hsenv --ghc=TARBALL
18:37:28 <Nisstyre> johnw: I might later
18:43:08 <geekosaur> so, one way to think about it is that haskell stacks horizontally instead of vertically: when evaluating some expression, it pushes onto the stack when it sees something it can evaluate later instead of immediately. this means that excessive laziness leads to a stack full of "pending" evaluations. making something strict causes it to be evaluated immediately instead of being stacked. (this is kinda the reverse of a strict language, where you pu
18:43:08 <geekosaur> sh on the stack when evaluating some function)
18:44:23 <ekipan> indeed in a strict language you can do the reverse and create localized laziness by making your own thunks: function() {return 42;} instead of 42
18:44:55 <CODEtaku> that makes sense... in general though you don't need to work to reduce laziness do you?  Even when doing things with big graphs and the like?
18:45:02 <geekosaur> it's a pattern match stack because pattern matches are how you force something to be evaluated... but only evaluated to one level; it's the deeper evaluations that get stacked
18:45:16 <Nisstyre> ekipan: (define-syntax-rule (lazy exp) (lambda () exp))
18:45:19 <Nisstyre> >.>
18:46:12 <geekosaur> well, in some sense you do need to work. but ghc has a strictness analyzer that usually does a good job of figuring out where it should just do the work instead of deferring it
18:46:32 <geekosaur> but sometimes you need to help it out
18:49:37 <geekosaur> but it's very common that some program does no actual work until it reaches the point where the program does output; then it suddenly goes back and does all the pending evaluation so it can output the result
18:50:01 <newsham_> > foldr (+) z [a,b,c,d,e,f]
18:50:02 <lambdabot>   a + (b + (c + (d + (e + (f + z)))))
18:50:13 <CODEtaku> that is what I would expect, glad to hear my intuition is correct at least in that
18:50:18 <geekosaur> (you see this in profiling when all the program runtime is accounted to the function that does output)
18:52:34 * tabemann is finding going and QuickCheck writing tests for *every* function he writes to be tiring, but ultimately easier and more reliable than actually testing those functions by hand
18:53:46 <newsham_> and easier than writing coq proofs? :)
18:54:18 <elliott> > foldl' (+) z [a,b,c]
18:54:19 <lambdabot>   z + a + b + c
18:54:21 <elliott> pfft.
18:54:26 <elliott> it should do hacks to detect seq before show
18:54:26 <tabemann> never tried working with Coq myself
18:54:35 <tac> *writing* coq proofs isn't so bad
18:54:39 <tac> Reading them is suicide
18:57:51 <jxm> tac, a little worse than agda, but still not _so_ bad
18:59:02 * tabemann has yet to wrap his brain around agda, with the tutorials on it managing to confuse him at points so far
18:59:36 <jxm> tabemann, what is wrong with half # of DSLs and no vernacular to link it all ?
18:59:55 <tac> jxm: I'm not saying Agda does everything as well as it could, but tactics flatten the nested structure of your proofs
19:00:18 <tac> (same is true of proofs written in mathematics, of course)
19:00:35 <arkeet> tac tics.
19:00:37 <newsham_> tac: proving arbitrary quickcheck properties can be very difficult
19:01:15 <jxm> newsham_, quickcheck is an arbitrarily small subset of Coq though
19:01:24 <applicative> strangely, I find quickcheck more convincing; by the time one puts something in shape for a 'proof', it's unrecognizable
19:01:25 <elliott> wat
19:01:31 <tac> arkeet: /whois tac
19:01:41 <tac> [tac] is logged in as tac-tics
19:01:43 <arkeet> ok.
19:01:43 <tac> :)
19:01:48 <newsham_> applicative: thats why you should extract haskell from coq, no? :)
19:01:49 <jxm> tac: s/Agda/Coq/ ????
19:02:02 <tabemann> because I'm doing a lot of things with list, I wonder if I'm adequately checking some of my functions, as, for instance, when testing elemIndices (which I'm implementing due to implementing strict lists), who says if the element being checked for is a member of *any* of my lists?
19:02:09 <tac> jxm: yeah, Coq flattens the structure of your proofs
19:02:15 <jxm> tac-tics,  s/Agda/Coq/ ????
19:02:20 <jxm> (you were faster)
19:02:35 <applicative> newsham_: I like that idea. "This all well and good, but can we extract the haskell so I can do quickcheck on it?"
19:02:39 <jxm> tac: until you try to understand them
19:02:51 <jxm> tactics are sexy but _additional_ stuff
19:02:57 <jxm> One DSL should be enought
19:03:02 <jxm> Or am I misleaded ?
19:03:13 <jxm> s/_/enough
19:03:14 <applicative> substititute idris for both of them
19:03:17 <johnw> misled
19:03:29 <jxm> applicative, ok, you are right of course
19:03:35 <tabemann> idris seems like it's a language for doing "real work" rather than a theorem prover
19:03:36 <tac> I personally feel like some kind of disciplined reflection is the Right Way to do things.
19:03:52 <johnw> tabemann: and yet, with an automated theorem prover in it, which is very cool
19:04:01 * hackagebot gitlib 1.0.1 - API library for working with Git repositories  http://hackage.haskell.org/package/gitlib-1.0.1 (JohnWiegley)
19:04:03 <applicative> idris has a regular theorem prover built in
19:04:03 * hackagebot gitlib-utils 1.0.1 - Generic utility functions for working with Git repositories  http://hackage.haskell.org/package/gitlib-utils-1.0.1 (JohnWiegley)
19:04:05 * hackagebot gitlib-libgit2 1.0.1 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-1.0.1 (JohnWiegley)
19:04:14 <jxm> tabemann, hey, do not tell that to the man who is hanging on #haskell even though he is an erlang guy ;-)
19:04:35 <jxm> (well, do it, but do not explect much)
19:04:39 <jxm> expect
19:04:45 <tac> Idris's intent is definitely geared towards "what can dependent types do for me?"
19:04:54 <tac> Not "what can I do for dependent types" :)
19:04:58 <jxm> Types
19:04:59 <tabemann> yeah
19:05:06 <jxm> Not _synamic_ ones
19:05:11 <jxm> dynamic
19:05:20 <jxm> But static, real, hard, solid ones
19:05:22 * elliott is confused.
19:05:25 <applicative> it's just a more beautiful sensible language.
19:05:34 <jxm> Are you guys so sure this is the real end-it-all ?
19:05:45 <jxm> (asking in genuine good faith - curious)
19:06:00 <applicative> yes, Idris VIII is the real end it all
19:06:10 <applicative> or maybe Idris XLVII
19:06:42 <CODEtaku> they need a better web server... trying to discover what Idris is and their site is limping
19:06:51 <applicative> hm
19:07:22 <applicative> CODEtaku: here's the github site https://github.com/edwinb/Idris-dev
19:08:00 <applicative> yeah, I'm not getting the site either; I assume its at his univ
19:08:43 <Ralith> augur: idris will get an editor, it's just a matter of time
19:08:57 <applicative> boo no editor
19:09:01 * hackagebot gitlib-cmdline 1.0.1 - Gitlib repository backend that uses the git command-line tool.  http://hackage.haskell.org/package/gitlib-cmdline-1.0.1 (JohnWiegley)
19:09:03 * hackagebot gitlib-cross 1.0.1 - Run tests between repositories  http://hackage.haskell.org/package/gitlib-cross-1.0.1 (JohnWiegley)
19:09:05 * hackagebot gitlib-sample 1.0.1 - Sample backend for gitlib showing the basic structure for any backend.  http://hackage.haskell.org/package/gitlib-sample-1.0.1 (JohnWiegley)
19:09:07 * hackagebot gitlib-test 1.0.1 - Test library for confirming gitlib backend compliance  http://hackage.haskell.org/package/gitlib-test-1.0.1 (JohnWiegley)
19:09:09 * hackagebot git-monitor 1.0.0 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-1.0.0 (JohnWiegley)
19:09:12 <augur> Ralith: i know
19:09:16 <Ralith> okay
19:09:19 <applicative> johnw: youre a madman
19:09:23 <johnw> :)
19:09:40 <applicative> I wonder if I would understand git better if I studied you libraries
19:09:40 <augur> Ralith: i was talking to someone the other day about making an editor that has generic hooks for holes, etc.
19:09:42 <tac> I agree boo no editor, but who's gonna write it?
19:09:53 <tac> Editors are hard :<
19:09:55 <augur> Ralith: so it might get an editor because i end up making one! :)
19:09:59 <augur> tac: wuss
19:09:59 <johnw> applicative: git-monitor is the main one to get excited about
19:10:02 <tabemann> why have a dedicated editor when one can have an Emacs major mode?
19:10:21 <applicative> no, i meant the opposite, everything should be done to make unnecessary, or as much as possible.  maybe a more complex proof helper
19:10:22 <tac> Stop being a weak ω-groupoid, augur
19:10:23 <johnw> just run git-monitor -v in any working tree, and it will start making really cheap snapshots for you at one minute intervals
19:10:23 <tac> ;P
19:10:26 <Ralith> augur: that would be awesome! we're putting an editor API together already
19:12:09 <Ralith> augur: the responsible parties would likely be interested in your perspective
19:12:28 <augur> Ralith: lemme know what kinds of interactions you're going to have in your API. the general plan is to have a generic editor-side API for things like showing information in panes, and for holes, but itd be good to have a sense of what the interaction moves are
19:12:36 <Ralith> tabemann: for practical purposes, 'emacs mode' = 'editor' :P
19:12:44 <applicative> johnw: the cabal/hackage homepage shouldn't be a git:// but an http:// no?
19:12:55 <tabemann> Ralith: I was wondering
19:13:07 <Ralith> augur: so far it's being modeled after SLIME, but there isn't really a detailed plan laid out; thus the value if other perspectives.
19:13:09 <johnw> applicative: where are you seeing that?
19:13:53 <Ralith> augur: see https://github.com/edwinb/Idris-dev/pull/312
19:14:11 * hackagebot gitlib-s3 1.0.1 - Gitlib repository backend for storing Git objects in Amazon S3  http://hackage.haskell.org/package/gitlib-s3-1.0.1 (JohnWiegley)
19:14:28 <augur> Ralith: ill give it a look.
19:14:32 <Ralith> it's just the bare beginnings and a few basic easily-implemented proof of concept commands so far
19:15:21 <applicative> johnw:  on the hackage page for git-monitor : i couldn't 'click through' to the github page
19:15:36 <applicative> then you give the address for cloning on the next line
19:15:37 <johnw> ah, you are right
19:16:11 <johnw> uploading the change
19:16:31 <johnw> there is also gitlib-github, but it depends on libraries we haven't released yet
19:16:43 <applicative> hah, I was about to send a patch just to amuse you
19:17:50 <applicative> now I'm kind of confused, how is hackage /haddock deriving the webpage and git repo both
19:18:30 <augur> Ralith: its good that there is this push with idris
19:18:44 <augur> its the only reason i refuse to try using it, currently
19:19:02 * hackagebot git-monitor 1.0.1 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-1.0.1 (JohnWiegley)
19:19:26 <Ralith> augur: we've got a lot of people familiar with both SLIME and agda-mode; we appreciate the value of good integration and interactivity
19:19:48 <applicative> johnw oh i see there is a separate heading source-repository head ;  type: git ; location: git://github.com/fpco/gitlib
19:20:13 <augur> Agda-mode is what im used to
19:20:24 <augur> oh also, Ralith, the intention is to have Conor's feature :)
19:20:51 <carter> elliott or someone else who knows lambda bot: I can't seem to build ti with a sanboxed build… looks like GHC hangs on building Data.Random.Distribution.Categorical of random-fu
19:21:08 <elliott> works for me, what error?
19:21:09 <applicative> hanging? hm
19:21:13 <elliott> oh hangs
19:21:16 <elliott> are you using HEAD or something?
19:21:19 <johnw> hmm... gitlib-libgit2 failed to build on Linux via Hackage, which is very odd since we build it on Linux every day
19:21:36 <Ralith> augur: sorry, conor's feature?
19:21:48 <augur> Ralith: whack a variable to case split!
19:22:14 <Ralith> I thought agda-mode did that?
19:22:17 * Ralith is one of the SLIME people
19:22:29 <augur> Ralith: you can specify a variable to split on
19:22:35 <augur> but you cant click on it and split
19:23:01 <Ralith> weird.
19:23:14 <Ralith> that seems like a trivial and obvious interaction.
19:23:28 <Ralith> at least if we accept 'key chord' as a substitute for 'click'
19:23:30 <augur> yeah, well
19:23:39 <augur> no no we dont accept that at all
19:23:42 <augur> thats the point
19:23:47 <augur> click, as in click.
19:23:48 <augur> with a mouse.
19:23:55 <augur> yes, you can C-c C-c x to split on x
19:24:03 <carter> elliott its that building that module seems to take forever.....
19:24:05 <augur> but conor wants to be able to just click
19:24:14 <CaptainK> what am I missing here to make this run? http://paste.tryhaskell.org/90601
19:24:26 <elliott> carter: what ghc version?
19:24:31 <carter> elliott 7.6.3
19:24:38 <johnw> CaptainK: you need a function called "main" that calls your function with some arguments and prints the result
19:24:39 <hpaste> palmje pasted “compile / linker error” at http://paste.tryhaskell.org/90602
19:24:40 <elliott> CaptainK: topArea needs to align with sideArea
19:24:46 <carter> ghc's just running  on that module
19:24:51 <elliott> main isn't a function, btw :)
19:24:56 <palmje> does anyone know what could be causing this compile error at the linker step? http://paste.tryhaskell.org/90602
19:25:01 <carter> just doing "cabal install random-fu"
19:25:04 <carter> seems to be stuck there
19:25:04 <johnw> also, the topArea line needs to be indented by 4 spaces more
19:25:10 <elliott> (unlike in C, where as kmc knows, main is usually a function)
19:25:20 <elliott> carter: not sure, honestly; it works fine for me
19:25:30 <carter> elliott what ghc version do you have?
19:25:33 <elliott> 7.6.3
19:25:44 <carter> ohhh, could it be that i'm using cabal head...?
19:25:46 <carter> no….
19:26:14 <carter> its a simple cabal build
19:26:34 <elliott> I use HEAD cabal too
19:26:36 <applicative> CaptainK: tabs are probably a bad idea, you should get your editor to put in spaces for Haskell
19:26:43 <Ralith> augur: well, there's a great deal opportunity for interesting new modes of editing with such an editor. Conor certainly knows better than me what would be useful.
19:27:01 <carter> elliott could you try and do a sandboxed install of random-fu?
19:27:06 <CaptainK> applicative: ok will check Sublime
19:27:14 <carter> eg: mkdir Foo ; cabal sandbox init ; cabal install random-fu
19:27:18 <elliott> carter: well, I have a sandboxed build of lambdabot
19:27:22 <elliott> so it contains random-fu :)
19:27:26 <carter> elliott i'm getting this problem there :)
19:27:47 <elliott> maybe send a bug upstream to random-fu?
19:27:51 <carter> ok
19:27:58 <carter> i'm trying to test it again before i do that
19:28:27 <augur> Ralith: indeed. thats why i find the current editors to be such a clincher. DTP profits drastically from certain modes of editing, and the current absence of those mods with Idris means I don't gain as much as if i were using Agda
19:28:41 <augur> who knows what else there is to do with DTP editors!
19:28:50 <Ralith> yeah, I'm really excited about the potential of type-directed structural editing
19:29:02 * hackagebot hlibgit2 0.18.0.7 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.18.0.7 (JohnWiegley)
19:29:04 * hackagebot gitlib-libgit2 1.0.2 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-1.0.2 (JohnWiegley)
19:29:07 <carter> it might be sanish to write a structural editor layer for ST3
19:29:09 <Ralith> I just don't quite follow how case-split-on-click in particular is in and of itself compelling
19:29:11 <carter> idk kknow
19:29:13 <Ralith> ST3?
19:29:14 <hpaste> CaptainK pasted “cylinder2” at http://paste.tryhaskell.org/90603
19:29:16 <carter> sublime text
19:29:19 <tac> Ralith: Yes. That would be awesome.
19:29:25 <Ralith> carter: is its interface flexible enough?
19:29:33 <carter> Ralith i think so!
19:29:33 <applicative> http://codepad.org/hilQ0Snb here its 'running' CaptainK
19:29:39 <geekosaur> wow, that indentation :(
19:29:47 <Ralith> tac: certainly if there's anything that could make mousey programming viable, that's it
19:29:58 <tac> heh, mousey programming?
19:30:03 <Ralith> carter: seems like a reasonable idea then
19:30:03 <elliott> CaptainK: you have to get your indentation right in haskell.
19:30:07 <Ralith> carter: good for bringing in the trendy crowd
19:30:22 <Ralith> tac: programming making heavy use of a pointer
19:30:31 <augur> Ralith: i cant conceive of how a good structural editor would work :\
19:30:34 <carter> Ralith also some people have trouble using emacs
19:30:41 <Ralith> augur: ever used paredit?
19:30:43 <carter> Sublime is a pretty solid portable editor
19:30:48 <augur> Ralith: i mean, basically its a tree editor, and thats a pain
19:30:50 <augur> no, i havent
19:30:52 <tac> augur: Can we take your lack of vision as proof it can't work ;P ;P
19:30:53 <augur> link?
19:31:00 <Ralith> it only really makes sense for a lisp
19:31:00 <augur> tac: no!
19:31:05 <Ralith> paredit, that is
19:31:08 <Ralith> not structural editing in genreal
19:31:15 <Ralith> augur: http://www.emacswiki.org/emacs/ParEdit
19:31:47 <carter> Ralith http://www.sublimetext.com/docs/3/api_reference.html is the basic api stuff
19:31:47 <Ralith> augur: it's a light structural editing interface for s-expressions which I used heavily in practice and found to be a wonderful experience.
19:31:54 <CaptainK> applicative: ok, now I'm starting to see how things start :))
19:31:59 <Ralith> and it would not exactly be a lie to call it a tree editor
19:32:02 <applicative> CaptainK: http://codepad.org/5C2MBKF1
19:32:23 <Ralith> the thing is, it would not exactly be a lie to call any text editor, applied to tree-structured data, a really ham-handed tree editor
19:33:03 <Ralith> the idea is to add structure-aware ways to manipulate your program so you can edit in terms of, well, terms, instead of characters.
19:33:10 <johnw> this really isn't the place for discussion of editors, but rather Haskell :)
19:33:20 <carter> elliott could you at least try doing the build ?
19:33:28 <carter> it might be that there was a recent change in depdencies or sometign
19:33:51 <Ralith> johnw: it's a theoretical editor for a language having syntatic similarity to haskell, of course it's relevant! >_>
19:33:52 <carter> mkdir foo ; cd foo ; cabal sandbox init ; cabal install random-fu
19:34:04 <carter> johnw let Ralith have his evening
19:34:06 <carter> :)
19:34:19 <johnw> i don't mind if it goes to #haskell-overflow
19:34:21 <Ralith> we can move into -blah but I don't intend to pursue the hard sell here
19:34:30 <augur> Ralith: i mean, is there anything i can look at to see how the editing process looks?
19:34:50 <elliott> more -blah than -overflow
19:34:51 <carter> blah is more open, few people lurk at overlfow
19:34:55 <elliott> carter: hmm, my sandboxing stuff seems to be broken somehow :(
19:34:57 <Ralith> augur: I'm sure there's some decent screencasts of paredit+slime around somewhere...
19:34:59 <elliott> will play with it a bit
19:35:05 <carter> elliott broken how?
19:35:12 <elliott> as in it doesn't want to install anything
19:35:17 <Ralith> augur: the emacs wiki page links https://imageshack.us/a/img8/9479/openparen.gif
19:35:54 <tac> that's kinda neat
19:36:07 <elliott> ok, fixed. building
19:36:21 <hpaste> geekosaur annotated “cylinder2” with “cylinder2 (input and output; look ma, no do!)” at http://paste.tryhaskell.org/90603#a90604
19:36:41 <tac> it's still lisp and thus, unintelligible, but still neat >:P
19:36:50 <augur> Ralith: hmm.. but thats just auto paren balancing, surely
19:36:53 <CaptainK> applicative: now how do I run that in GHCi? with a get line?
19:37:34 <Ralith> augur: paredit does much more than that; http://www.slideshare.net/mudphone/paredit-preso looks more comprehensive at a glance
19:37:45 <augur> ok
19:39:05 <applicative> http://ideone.com/naFh5d CaptainK what do you want to run in ghci
19:39:48 <applicative> CaptainK: you should be able to run geekosaur 's code by :l geeko.hs and then typing main
19:40:49 <CODEtaku> CaptainK: What other languages do you know?
19:41:15 <Sonarpulse> is there a standard function to convert CamelCase to camel_case ?
19:41:21 <Sonarpulse> (for template haskell?)\
19:42:10 <CaptainK> started in Fortran, Pascal ...(which I would not say I know now), bash, Basic, Perl and few others hacking away, started C++ but thought Haskell would be better to learn first
19:42:28 * tabemann didn't know people even learned Fortran these days
19:42:35 <tabemann> Pascal either
19:42:45 <tabemann> Basic either
19:42:51 <CaptainK> Haskell feels like Pascal to me, (I know it not)
19:43:15 <CaptainK> I mean, I know its not Pascal
19:43:21 <newsham_> captaink: because IO names procedures, and others are functions?
19:43:30 <CODEtaku> something that helped me at the start was rewriting imperative code with a couple restrictions: No loops and no if statements
19:43:32 <CaptainK> yes
19:44:01 <newsham_> code: you can have if "statements" (ie. "when")
19:44:02 * hackagebot plot 0.2.1 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.2.1 (VivianMcPhail)
19:44:26 <CODEtaku> newsham_: I know, I'm just talking about helping to understand the functional paradigm coming from an imperative background
19:44:53 * CaptainK doesn't want to admit he did some VIsual Basic programming
19:45:30 <CODEtaku> visual basic is fine too, just take some simple code in a language you are comfortable in and rewrite it with no loops and no conditionals
19:45:43 * tabemann started off in Applesoft BASIC way back when
19:46:24 <newsham_> thing is, if you start rewriting it without loops you're probably writing it with recursion..  and not taking advantage of higher order functions
19:46:27 <CODEtaku> functions aren't just a way to group instructions in functional languages, they're much more powerful than that.  They are in imperative languages (most of em anyway) too, but they're just not used that way
19:46:33 <newsham_> perhaps a good first step though
19:47:14 <CaptainK> lol, I actually owned this as my first computer http://en.wikipedia.org/wiki/Timex_Sinclair_1000
19:47:39 <newsham_> i almost bought that as my first computer (used one in school a little bit).
19:48:32 * tac always found a lot of higher order functions as control structures to be more confusing than explicit recursion
19:48:54 <CaptainK> Apple soft and Vic 20s with the acoustic coupler for a 300baud modem...ya Apple Basic, those where the days.
19:49:07 <CaptainK> BBS was the Internet
19:49:16 <newsham_> tac: why?  lots of loops in C and similar languages that accumualte a value map very cleanly to foldM_ (forM_)
19:49:26 <newsham_> some map very cleanly to map and mapM_
19:49:51 * tac shrugs
19:50:01 <newsham_> cK: my first at home was c64.  lots of basic, then some 6502 asm..  dataset for a long time, etc..
19:50:10 <tac> There's just a lot of slightly different combinators
19:50:29 <tac> I find it hard to keep track of them all. Recursion isn't so bad for short functions.
19:50:38 <geekosaur> the first computer I ever used was http://en.wikipedia.org/wiki/Commodore_PET and the first one I owned was http://oldcomputers.net/osi-600.html
19:51:04 <tabemann> as I started out with functional programming in OCaml I got the idea that I *shouldn't* use foldr, and that I *should* use rev_map (instead of map) whenever possible
19:51:39 <tac> I personally never saw a need for foldl
19:51:50 <bobajett> how can I write a function "get_n_lines", where given an Int n, it just calls getLine n times and returns [String]?
19:51:51 <tac> foldr is fine, because it's just the iteration principle for lists.
19:51:56 <tac> But foldl is just... weird.
19:52:19 <newsham_> remember: lefty loosey, righty tighty.
19:52:25 <tac> :P
19:52:34 <bobajett> Im having trouble figuring out how to recurse with IO ()
19:52:42 <tabemann> heh - I used foldl a lot myself, because it would iterate over lists in order and it wouldn't explode the stack
19:52:46 <newsham_> ?src forever
19:52:46 <lambdabot> Source not found. Take a stress pill and think things over.
19:52:47 <tac> @type sequence_ $ replicate 3 getLine
19:52:48 <lambdabot> IO ()
19:52:55 <newsham_> ?src mapM_
19:52:55 <lambdabot> mapM_ f as = sequence_ (map f as)
19:52:57 <tac> oops, wrong one
19:53:01 <tac> @type sequence $ replicate 3 getLine
19:53:01 <lambdabot> IO [String]
19:53:04 <newsham_> ?src foldM_
19:53:04 <lambdabot> foldM_ f a xs = foldM f a xs >> return ()
19:53:05 <ekipan> @type replicateM
19:53:05 <lambdabot> Monad m => Int -> m a -> m [a]
19:53:21 <tabemann> bobajett: what are you exactly trying to do?
19:53:21 <elliott> bobajett: get_n_lines 0 = return []; get_n_lines n = do { line <- getLine; lines <- get_n_lines (n-1); return (line:lines) }
19:53:23 <tac> fine yeah, that one :P See? Too many combinators!
19:53:29 <ekipan> @type replicateM 10 getLine
19:53:29 <lambdabot> IO [String]
19:53:30 <elliott> the other forms are valid but this one is more likely to make sense to you.
19:53:38 <geekosaur> :t \n -> replicateM n getLine
19:53:39 <lambdabot> Int -> IO [String]
19:54:01 <bobajett> elliott: yep thats exactly what I was stumbling towards. Thanks!!!
19:54:18 <elliott> bobajett: :)
19:54:29 <ekipan> @src sequence
19:54:29 <lambdabot> sequence []     = return []
19:54:29 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:54:29 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
19:54:34 <CODEtaku> I imagine that would help CaptainK too
19:55:46 <CaptainK> tac: when I want to go from ["T","E","N"] to TEN, can I do that with  fold?
19:56:01 <tac> Concat map would work too, I think?
19:56:07 <tac> > concatMap ["T", "E", "N"]
19:56:08 <lambdabot>   Couldn't match expected type `a0 -> [b0]'
19:56:08 <lambdabot>              with actual type `[[...
19:56:09 <tac> err
19:56:11 <tac> just concat
19:56:14 <tac> > concat ["T", "E", "N"]
19:56:15 <lambdabot>   "TEN"
19:56:25 <ekipan> concat = foldr (++) []
19:56:49 <CaptainK> and with numbers [1,2,3]?
19:56:53 <newsham_> > foldr (++) [] [a,b,c]
19:56:54 <lambdabot>   Couldn't match expected type `[a0]'
19:56:54 <lambdabot>              with actual type `Debug.Si...
19:57:01 <tac> CaptainK: what do you want to do with [1,2,3]?
19:57:05 <CODEtaku> :t concat
19:57:05 <lambdabot> [[a]] -> [a]
19:57:06 <CaptainK> 123
19:57:15 <ekipan> map show
19:57:16 <tac> You need to map show to them first
19:57:17 <newsham_> > concat $ map show [1,2,3]
19:57:17 <lambdabot>   "123"
19:57:33 <ekipan> or concatMap show
19:57:39 <tac> @src concatMap
19:57:40 <lambdabot> concatMap f = foldr ((++) . f) []
19:57:44 <ekipan> which is bind in [], but don't tell anyone that!
19:57:50 <tac> concatMap = concat . map, right?
19:57:50 <ekipan> > [1,2,3] >>= show
19:57:51 <lambdabot>   "123"
19:57:52 <CaptainK> lol,
19:57:58 <tac> err
19:58:00 <tac> yeah
19:58:19 <CaptainK> oh i like the >>=
19:58:31 <ekipan> (>>=) is just another name for concatMap
19:58:38 <ekipan> > [1,2,3] `concatMap` show
19:58:39 <CaptainK> nice
19:58:40 <lambdabot>   Couldn't match expected type `a0 -> [b0]' with actual type `[t0]'Couldn't m...
19:58:44 <tac> > concatMap show [1,2,3]
19:58:45 <lambdabot>   "123"
19:58:49 <ekipan> modulo arg order
19:58:53 <tac> > concat . map $ show [1,2,3]
19:58:53 <lambdabot>   Couldn't match type `[a1] -> [b0]' with `[[a0]]'
19:58:54 <lambdabot>  Expected type: (a1 -> b0)...
19:59:03 <tac> > concat $ map show [1,2,3]
19:59:03 <lambdabot>   "123"
19:59:05 <newsham_> > intercalate ", " $ map show [1, 23, 55]
19:59:06 <lambdabot>   "1, 23, 55"
19:59:18 <ekipan> > let paMtacnoc = flip concatMap in [1,2,3] `paMtacnoc` show
19:59:19 <lambdabot>   "123"
20:00:13 <CaptainK> haha, that is a lot compare to [1,2,3] >>= show
20:00:40 <tac> > (\f -> concat . map f) show [1,2,3]
20:00:42 <lambdabot>   "123"
20:00:50 <ekipan> that's only because (>>=) (over lists) is already defined elsewhere
20:01:37 <newsham_> ?src intercalate
20:01:38 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
20:01:51 <ekipan> > do x <- [1,2,3]; return (show x)
20:01:51 <lambdabot>   ["1","2","3"]
20:01:52 <newsham_> ?src intersperse
20:01:52 <lambdabot> intersperse _   []     = []
20:01:52 <lambdabot> intersperse _   [x]    = [x]
20:01:52 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
20:02:01 <ekipan> > do x <- [1,2,3]; show x
20:02:01 <lambdabot>   "123"
20:03:08 <ekipan> do gets desugared: do {x <- xs; show x} ---> xs >>= (\x -> do {show x}) ----> xs >>= (\x -> show x)
20:03:20 <ekipan> from there we can reduce the lambda (\x -> show x) into just show
20:03:25 <newsham_> ?undo do x <- [1,2,3]; show x
20:03:25 <lambdabot> [1, 2, 3] >>= \ x -> show x
20:04:05 <carter> elliott still building or dead?
20:04:14 <prophile> yes
20:04:17 <ekipan> I consider do notation to be more like syntax vinegar than sugar
20:04:20 <ekipan> but that's just me
20:04:42 <newsham_> add oil and shake
20:04:47 <elliott> carter: oh, it installed successfully
20:04:55 <geekosaur> syntax relish, not for all tastes or application to all things :)
20:04:55 <carter> wtf
20:04:58 <carter> darn
20:05:35 <carter> elliott are you on  a mac?
20:06:28 <elliott> yes
20:06:36 <carter> elliott what os x version?
20:06:44 <elliott> 10.8.4
20:06:51 <carter> HEISENBUG
20:06:55 <CaptainK> ekipan: great examples...I feel like I'm looking up at K2 and thinking to myself...do I want to climb so high?  (thinking metaphorically like haskell is K2)
20:07:11 <carter> well, machine dependent heisenbug
20:07:19 <carter> elliott this is doing it sanboxed?
20:07:23 <elliott> yep
20:07:26 <carter> like, from a fresh sandbox?
20:07:29 <carter> from scratch?
20:07:29 <elliott> yep
20:07:30 <CaptainK> but once you know that logic, you can build some elegant code
20:07:38 <carter> elliott haskell platform ghc/
20:07:39 <carter> ?
20:07:44 <carter> or built your own?
20:07:48 <elliott> built my own ghc
20:07:54 <ekipan> this is just trivial oneliner golfing
20:08:12 <ekipan> nothing even fancy going on
20:08:12 <carter> elliott hrmmm….
20:08:24 <carter> elliott i'll ask you more questions on this later
20:08:41 <carter> honestly i only care because I want to understand whats wrong, not because i need to build lambda bot
20:08:56 <carter> so either a) my cabal config defaults are borking it
20:08:58 <carter> or
20:09:00 <carter> hrmm
20:09:02 <carter> idk
20:15:03 <carter_> darn, i have no idea why textual keeps on disocnnecting
20:24:15 <Ralith> carter: did you get it past random-fu?
20:34:25 <carter> Ralith NOPE
20:34:29 <carter> just building it alone hangs
20:34:55 <Ralith> weird, I use that lib and it works great
20:35:04 <carter> Ralith whats your setup?
20:35:07 <carter> HP ghc or other?
20:35:52 <carter> whatever
20:35:53 <Ralith> package manager installed ghc, everything from then installed by cabal as needed
20:36:20 <carter> blah, Ralith  and elliott  could you share your caba config files mebe?
20:36:39 <Ralith> I haven't edited mine
20:36:40 <carter> i should just do a verbose cabal build to see what happens
20:36:47 <carter> i'm using a modified version of the HP one
20:36:47 <Ralith> http://sprunge.us/HVBd
20:37:50 <carter> Ralith https://gist.github.com/cartazio/79c99ba07106ac46f31f
20:38:15 <Ralith> I know little about reconfiguring cabal
20:38:23 <carter> Ralith how long did it take for you to build random fu?
20:38:47 <Ralith> about typical for a haskell package that size, I think
20:38:49 * Ralith reinstalls
20:39:08 <carter> does it stop at [10 of 27] Compiling Data.Random.Distribution.Categorical  for a while?
20:39:14 <Ralith> scratch that, faster than usual for a package that size
20:39:21 <Ralith> nope
20:39:22 <Ralith> goes right past it
20:39:30 <Ralith> in a fraction of a second
20:39:37 <carter> DARN
20:40:29 <carter> OHHH
20:41:53 <carter> Ralith https://gist.github.com/cartazio/5893750
20:42:00 <carter> type checker loop?
20:42:10 <carter> from bad packages?
20:43:23 <carter> nope
20:43:25 <carter> idkd
20:43:32 <carter> grrrr
20:43:34 <carter> whatever
20:43:43 <carter> doesn't matter just annoys
20:45:05 <carter> bleh
20:45:08 <carter> time to take a break
20:45:28 <Ralith> carter: I definitely don't get that error, but perhaps you're missing some pragmas
20:45:40 <carter> Ralith thats from doing a ghci run :)
20:45:43 <carter> so its irrelevant
20:45:49 <Ralith> kay
20:46:06 <carter> i filed a ticket
20:46:10 <carter> so theres ther
20:50:09 <carter> either way frustrating
20:50:26 <carter> i'm going to wipe my local package db
20:50:51 <carter> i forget
20:51:08 <carter> do i just delete my ./ghc/x86_64-darwin-7.6.3 + do ghc-package recache?
20:53:37 <carter> time to find out :P]
20:54:47 <carter> Ralith I have a theory!
20:54:51 <carter> do ghc-pkg list
20:55:15 <carter> and tell me what packages in your list disagree with the Haskell  Platform versions?
20:55:20 <carter> https://gist.github.com/cartazio/3debd4765f5ad8060e85
20:55:59 <carter> Ralith or not
20:56:13 <carter> though thats likely the issue
20:57:17 <Ralith> carter: it's a rather large list...
20:57:26 <carter> Ralith hence don't boter :)
20:57:33 <carter> i added it to the ticket
20:57:36 <Ralith> kk
20:57:43 <carter> this is why versions are hard
20:57:50 <CaptainK> hey this, foldl1 ((+).(*10)) [1,2,3] works great -> 123
20:57:51 <Ralith> an untested dependency version does seem a likely reason
20:58:16 * CaptainK is not sure how it works though :%
20:58:27 <carter> Ralith ish: usually that gives an ERROR
20:58:56 <carter> rather than GHC grinding on a file forever
20:59:00 <carter> fuck… might be a ghc bug
20:59:07 <carter> i'll file a ticke there
20:59:29 <Ralith> perhaps there's a way to, using unsafe typeclass extensions, loop typeclass resolution?
21:01:29 <geekosaur> the whole reason for UndecidableInstances is that it enables typechecking that might not terminate
21:02:47 <carter> yeah
21:02:52 <carter> does that package do it?
21:02:58 <pharaun> maan i'm so rusty with my types! >_< this is taking longer than it should be!
21:04:39 <carter> geekosaur you may be right, but its not exactly a code base i'm familiar with
21:05:01 * geekosaur does not know it either
21:05:37 <carter> grep indicates, yes undecidable instances are in that package
21:05:46 <ion> I hear rust programmers are rusty, too.
21:06:13 <carter> ion yes, because the language changes its type system every month :P
21:06:15 <carter> i kid i kid
21:06:21 <carter> they're dog fooding the changes hard
21:07:34 <carter> embedded systems folks are pretty excited about it
21:08:25 <elliott> geekosaur: but GHC is never meant to hang.
21:08:31 <elliott> it has an explicit limited stack for that
21:10:03 <Aetherspawn> Where does the second parameter come from
21:10:09 <Aetherspawn> > (uncurry id) ((+2), 2)
21:10:10 <lambdabot>   4
21:10:36 <elliott> what do you mean?
21:10:40 <Aetherspawn> :t id
21:10:41 <lambdabot> a -> a
21:10:42 <Aetherspawn> :t uncurry
21:10:43 <lambdabot> (a -> b -> c) -> (a, b) -> c
21:10:55 <Aetherspawn> :t (uncurry id)
21:10:55 <lambdabot> (b -> c, b) -> c
21:11:14 <geekosaur> :t (+2)
21:11:15 <lambdabot> Num a => a -> a
21:11:15 <Aetherspawn> id takes 1 argument, uncurry requires a function taking 2
21:11:16 <elliott> note that id there = ($)
21:11:19 <carter> elliott if you could test doing a build with haskell platform would be cool :)
21:11:24 <elliott> Aetherspawn: no
21:11:26 <elliott> id is a -> a
21:11:29 <elliott> so it can be (b -> c) -> (b -> c)
21:11:37 <elliott> which is (b -> c) -> b -> c, the type of ($)
21:11:40 <elliott> just by setting a = (b -> c)
21:12:26 <Aetherspawn> Oh I think I get it
21:12:27 <Aetherspawn> thanks
21:12:30 <elliott> carter: I don't really want to mess up my GHC setup, it takes many hours to compile here and I'll be going quite soon :/ sorry
21:12:33 <carter> ok
21:12:43 <carter> some other time then :P
21:12:54 <carter> or i may just swtich to a vanilla ghc at this rate
21:13:00 <elliott> Aetherspawn: another way of looking at it: uncurry f (x, y) = f x y; so uncurry id ((+2), 2) = id (+2) 2 = (+2) 2 = 2 + 2
21:13:05 <carter> or at least unregister the global packags
21:13:11 <carter> blerg
21:13:17 <carter> configuration is hard, lets do math
21:13:33 <ion> math is hard, lets do meth
21:13:49 <carter> prescription stimulants help you do math
21:13:51 <carter> lets not go there
21:13:56 <Aetherspawn> :t (uncurry (+3))
21:13:57 <lambdabot> Num (b -> c) => (b -> c, b) -> c
21:14:08 <ion> But do they help you do configuration?
21:14:14 <Aetherspawn> > uncurry (+3) ((+1), 3)
21:14:15 <lambdabot>   No instance for (GHC.Show.Show a0)
21:14:15 <lambdabot>    arising from a use of `M1315043649.sh...
21:14:31 <Aetherspawn> I know it's not supposed to be used like that, but I thought it strange it has a type
21:14:38 <geekosaur> that (Num (b -> c)) should give you pause
21:14:42 <elliott> well, 3 there is a function.
21:14:50 <elliott> the constraint says "functions need to be numbers for this to work".
21:14:56 <elliott> and you can define an instance for that if you really want to.
21:15:36 <imeredith> hi all, im trying to install blaze builder but am getting cannot satisfy -package-id text-0.11.3.1-f49c096093e03f96dfcd6a84bb11661e - but text-0.11.3.1 is already installed - anyone know whats up?
21:15:59 <imeredith> ah, may need to cabal update...
21:16:00 <carter> imeredith what were you trying to build as part of building blaze builder?
21:16:08 <geekosaur> how are you installing it and how was text-0.11.3.1 installed?
21:16:26 <ion> uncurry (+3) ((+1), 3) = (+3) (+1) 3 = ((+1) + 3) 3
21:17:00 <imeredith> carter: blazebuilder was being build for something that sublime text was going to use
21:17:06 <carter> cool
21:17:07 <imeredith> geekosaur: im not sure, it was just installed
21:17:08 <Aetherspawn> ion, thanks
21:17:41 <imeredith> geekosaur: carter, am very new to haskell and cabal, every time i try and learn something with cabal stops me rofl
21:17:45 <geekosaur> my point being that if text was installed as a user package but you are now installing blaze-builder asa global package, it can't see or use the user package
21:18:30 <imeredith> geekosaur: oh right, i installed haskell platform
21:18:33 <geekosaur> (this can happen if you use cabal to install text, but then use the runhaskell Setup.(l)hs method to install blaze-builder, for example)
21:18:37 <Moggle_> @src filterM
21:18:37 <lambdabot> Source not found. Are you on drugs?
21:19:07 <geekosaur> hm, text should be global then
21:19:08 <imeredith> geekosaur: nah just being using cabal
21:19:16 <imeredith> how can i tell ?
21:19:40 <geekosaur> oh hm, right, can't trust ghc-pkg to be right on here, package manager install :/
21:19:46 <geekosaur> ghc-pkg list
21:20:01 <geekosaur> the first set is global, the second is user
21:20:47 <imeredith> geekosaur: ghc-pjg recache seemed to work
21:20:57 <imeredith> to fix the eissue
21:21:02 <geekosaur> interesting
21:21:30 <imeredith> i have no idea what the implications of doing that command are, it just said i should do it when i did ghc-list
21:21:32 <imeredith> err
21:21:36 <imeredith> ghc-pkg list
21:21:58 <Aetherspawn> This type looks impossible to me..
21:21:59 <Aetherspawn> :t (uncurry (+3)) ((+1), 2)
21:21:59 <lambdabot> (Num (c -> c), Num c) => c
21:22:32 <ion> instance Num c => Num (c -> c) where … and it’ll work just fine.
21:22:32 <geekosaur> it's not actually impossible. I think that might even have worked back when lambdabot had the function Num instance in it?
21:22:46 <ion> Yeah, lambdabot used to have that nasty instance. :-P
21:23:24 <imeredith> geekosaur: anyway, thanks, hopefully this time i wont get stuck before i get to actaul coding :D
21:23:33 <ion> aetherspawn: It might be a fun exercise to implement that Num instance, btw.
21:23:52 <ekipan> fromInteger n = (!! n) . iterate -- isn't all that nasty
21:24:01 <Sonarpulse> what is the best way to flip a Word32
21:24:10 <Sonarpulse> *change endianness of
21:24:19 <geekosaur> Aetherspawn, part of the trick is that any numeric literal gets fromIntegral applied to it --- so if there is a Num instance for functions, numeric literals can "magivally" become functions
21:24:29 <carter_> elliott Ralith  darn, it dstill wont build
21:24:29 <carter_> haskell platform is the likely fault
21:24:29 <carter_> i'll sort it out later
21:24:48 <Aetherspawn> uh, thanks, I'll stare at it a little longer :)
21:24:48 <geekosaur> it is kind of mindwarpy, which is why a lot of people hated when lambdabot had such an instance
21:24:48 <NemesisD> in the list monad, how would one return a value early and abort the rest of the monad?
21:25:29 <ion> nemesisd: EitherT perhaps.
21:26:12 <ion> I mean, ErrorT.
21:26:35 <elliott> you mean, EitherT.
21:26:36 <elliott> @hackage either
21:26:37 <lambdabot> http://hackage.haskell.org/package/either
21:26:57 <NemesisD> ion: it isn't really an error though, hmm. it should either stop with the monad and return the result or soldier on
21:27:26 <ion> elliott: Oh, i’ll keep in mind that this package exists.
21:27:38 <Sonarpulse> need to go from little endian to network byte order
21:30:15 <ion> sonarpulse: Well, shifts and .&.s and .|.s would work.
21:30:45 <elliott> NemesisD: don't think about "error". just think about "either"
21:32:27 <NemesisD> elliott: hmm so then: left "successful result, stop here" and right "nope, keep going" ?
21:32:50 <elliott> NemesisD: right.
21:32:53 <elliott> (no, left :) )
21:33:00 <ion> > cycle "HA"
21:33:01 <lambdabot>   "HAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHA...
21:33:06 <elliott> thank you ion.
21:33:34 <DiegoNolan> i saw on hacker news that someone said they were releasing a linear algebra library soon, anyone know anything about that?
21:35:54 <Sonarpulse> ion: There is a cpu package
21:35:59 <Sonarpulse> with system.endian
21:36:14 <Sonarpulse> i dunno, there is probably other ways deep with bytestring or GHC
21:36:19 <Sonarpulse> but this should work
21:36:26 <Sonarpulse> unfortunately
21:36:45 <Sonarpulse> they are all to/from system specific
21:37:02 <Sonarpulse> but this specific usage needs no speed
21:37:34 <ion> Well, you can always convert to system endianness and from that to whatever you want.
21:38:29 <Aetherspawn> @where xmonad
21:38:29 <lambdabot> #xmonad | http://xmonad.org/
21:40:15 <Sonarpulse> yeah
21:40:24 <Sonarpulse> that's what I'll do
21:41:33 <NemesisD> elliott: is there a clean way to collect the results of that?
21:42:04 <NemesisD> i think i'm just going to get lefts
21:42:16 <NemesisD> oh, data.either has "lefts"
21:48:42 <CaptainK> Why do I get this parse error? http://ideone.com/5VbWsh
21:49:20 <ion> captaink: You can’t use <- outside do blocks, and you can only use do blocks where expressions are allowed.
21:49:44 <geekosaur> you still don't quite get the difference between a REPL and a compiled program, I see
21:49:49 <ion> (modulo PatternGuards)
21:49:54 <CaptainK> dang, keep learning more about do exceptions
21:50:04 <geekosaur> "exceptions"?
21:50:47 <geekosaur> ghci's behavior is the exception
21:51:09 <geekosaur> it behaves like a big do block in IO, for convenience
21:52:22 <CaptainK> and why <- is only allowed in a do block?
21:52:38 <geekosaur> because it's specifically part of do syntax?
21:52:43 <blackdog> anyone had a play with bazqux.com? amazingly fast.
21:53:13 <ekipan> @undo do {val <- action; rest}
21:53:13 <lambdabot> action >>= \ val -> rest
21:53:45 <copumpkin> blackdog: the guy clearly put a lot of thought into his name
21:53:58 <CaptainK> thats what I mean by exceptions, gtk that it is part of the do action
21:54:19 <blackdog> copumpkin: hehe, yes. upgrade from foobar, i guess.
21:54:24 <ion> captaink: main = do foo <- readFile "bar"; putStr foo
21:54:38 <geekosaur> you're trying to think like perl or python still
21:56:08 <CaptainK> hard to get that out.
21:56:44 <CaptainK> but how do you know without being told that <- is part of do?
21:57:01 <ion> How do you know anything without being told?
21:57:20 <CaptainK> by intuitiveness
21:58:02 <hagb4rd> *intuition
21:58:06 <ion> One can feel free to intuit things, but intuition can also be wrong, especially if trained using something completely different.
21:58:12 <ekipan> well, GHC did have the courtesy to tell you that it wasn't
21:58:14 <tac> CaptainK: <- is just magic. It does the right thing almost every time.
21:58:26 <ekipan> it yelled PARSE ERROR at you
22:00:34 <CaptainK> if its in a do loop it will work every time :P
22:00:43 <ion> Not loop
22:00:56 <CaptainK> ok so when I see parse error '<-' I know its not inside a do
22:01:03 <CaptainK> oh ya, block!
22:01:08 <CaptainK> do block
22:05:13 <isomorphic> CaptainK:  the other thing you should watch out for is when you do a <- and the thing isn't a monad ;)
22:16:08 <CaptainK> ok, lyah chapter 12-13, I have a long way too go...good god, its hard to deprogram
22:16:54 <pharaun> its rewarding imho :)
22:17:12 <CaptainK> well, thanks for being patient with me, will continue to plug away at lyah and get some guidance in the morning.
22:17:28 * CaptainK smells burning rubber...
22:18:21 <CaptainK> ya I like it so far even if I don't understand it yet
22:19:06 * hackagebot securemem 0.1.2 - abstraction to an auto scrubbing and const time eq, memory chunk.  http://hackage.haskell.org/package/securemem-0.1.2 (VincentHanquez)
22:19:40 <lispy> auto scrubbing?
22:22:11 <CaptainK> night gents
22:25:01 <flebron> Is there a more idiomatic way of writing \x -> if x > limit then Nothing else Just x?
22:26:19 <NihilistDandy> ap (flip if' Nothing . (> limit)) Just ?
22:26:36 <flebron> Did you just @pl it? :p
22:26:40 <codesoup> i don't think that would be considered more idiomatic by most people
22:26:53 <NihilistDandy> Well, I pointfree'd it, but yes
22:27:05 <NihilistDandy> The opposite of idiomatic, I would think
22:27:14 <flebron> Enigmatic? :)
22:27:26 <pharaun> i don't mind pl but sometime it gets a bit.... silly
22:27:27 <NihilistDandy> Could you handle it with a guard?
22:27:50 <flebron> Sure.
22:28:00 <apples> mfilter (> limit) . Just works
22:28:07 <johnw> > let x = 10; limit = 5 in do { guard (x > limit); return x }
22:28:08 <lambdabot>   No instance for (Control.Monad.MonadPlus m0)
22:28:08 <lambdabot>    arising from a use of `e_11...
22:28:10 <NihilistDandy> Ooh, that's nice
22:28:17 <johnw> ah, nice
22:28:32 <Aetherspawn> does haskell use tcmalloc
22:28:55 <johnw> > let x = 10; limit = 5 in mfilter (> limit) (Just x)
22:28:56 <lambdabot>   Just 10
22:30:13 <ion> x <$ guard (x <= limit)
22:30:34 <tabemann> hmm... how do I get quickCheck to generate a function for me that acts like an equality function, or should I just quickCheck with (==) as an equality function rather than autogenerating one?
22:31:54 <flebron> If I use foldM with Maybe, when it reaches a Nothing, will it stop processing the list or will it create more thunks?
22:37:24 <johnw> > foldM (\acc x -> Nothing) [] [undefined]
22:37:24 <lambdabot>   Nothing
22:37:52 <johnw> not sure what you mean about "creating more thunks"
22:38:03 <johnw> foldM is over the Maybe Monad, which expresses short-circuiting behavior
22:44:08 <palmje> does anyone know what could be causing this compile error at the linker step? http://paste.tryhaskell.org/90602
22:44:34 <johnw> palmje: I have no idea
22:44:44 <johnw> never seen that kind of linker error before, and I've seen most
22:44:50 <lispy> palmje: that's odd
22:44:58 <tabemann> that is... very strange
22:45:05 <lispy> palmje: how did you get your ghc?
22:45:09 <johnw> what is your platform, and how did you install ghc?
22:45:30 <lispy> palmje: looks like you're using a special linker
22:45:42 <palmje> it's ghc 7.6.3, generic amd64 build
22:45:51 <johnw> which Linux?
22:45:58 <palmje> using sabayon linux
22:46:01 <lispy> /usr/lib/gcc/x86_64-pc-linux-gnu/4.7.3/../../../../x86_64-pc-linux-gnu/bin/ld
22:46:02 <johnw> never heard of that one
22:46:04 <lispy> dat path
22:46:06 <tabemann> neither have I
22:46:24 <palmje> gentoo based - basically a binary version of gentoo
22:46:46 <johnw> is any part of your development environment 32-bit only?
22:47:11 <lispy> does ghc take -fPIC? or would it be like -opt-c-fPIC
22:47:27 <palmje> should be all 64bit
22:47:54 <palmje> I can get it to compile if I use --dynamic and -fPIC, but shouldn't need that for a simple hello world program
22:47:58 <lispy> palmje: so was this a distro install?
22:48:23 <palmje> no, it's the generic amd64 build of ghc 7.6.3
22:48:47 <lispy> when you use --dynamic and -fPIC what does ldd say when you run it on the resulting binary?
22:49:10 <lispy> ghc is becoming more and more dynamic wrt linking
22:49:17 <palmje> let me check
22:50:30 <palmje> ok... now it's telling me --dynamic isn't recognised...
22:52:07 <hpaste> palmje pasted “compile / linker error with -fPIC” at http://paste.tryhaskell.org/90605
22:52:36 <johnw> I think you need to build ghc from source
22:52:45 <johnw> I'm not sure that the binary tarball you downloaded is compatible with your platform
22:53:09 <johnw> the linker it's finding something in the symbol table for some object files that it doesn't accept
22:54:33 <palmje> hmmm, I'll give that a shot
22:54:55 <palmje> thanks
22:58:34 <lispy> well, I'm not sure how you'll build from source
22:58:38 <lispy> You need a Haskell compiler
23:09:02 <johnw> hmm... that's a good point
23:09:17 <johnw> i wonder if his platform has an install target for an older version that works
23:28:35 <shachaf> Are least and greatest fixed points categorical (co)limits or something like that?
23:29:20 <shachaf> I assume "least" and "greatest" means that there's a category of fixed points of a functor where they're initial and terminal objects.
23:29:54 <shachaf> If that's so, what's that category like?
23:30:29 <elliott> shachaf: mumble mumble F-algebra?
23:30:42 <shachaf> elliott: Ah, that clarifies it.
23:33:14 <shachaf> Oh, it is that simple, actually.
23:33:49 <elliott> glad I could help, shachaf. any time. don't mention it
23:34:17 <shachaf> Thanks, elliott.
23:34:37 <elliott> I said don't mention it.
23:34:51 <johnw> shachaf: I really don't know if this helps or not: http://www.sciencedirect.com/science/article/pii/0304397593901127
23:35:27 <shachaf> What about greatest fixed point? Are those terminal coalgebras or something else?
23:35:46 <shachaf> johnw: I don't either!
23:36:32 <johnw> there is also this paper: http://homepages.inf.ed.ac.uk/gdp/publications/fixpoints.pdf
23:36:49 <johnw> which discusses F-algebras and F-coalgebras in conjunction with least and greatest fixed point
23:39:51 <shachaf> Hmm, maybe that's relevant.
23:40:24 <shachaf> I guess f-algebras are really simple in lattices.
23:42:22 <shachaf> I should probably be thinking about this in a language that distinguishes data and codata...
23:46:04 <shachaf> If you have a type which happens to have a complete definedness lattice, can you define a function to compute a greatest fixed point?
23:50:51 <chao_aero_> has anyone use haskell for more than 10 years?
23:51:00 <shachaf> Yes, some people have.
23:51:06 <elliott> sure
23:51:11 <elliott> why 10?
23:51:36 <shachaf> I must be missing something in http://ncatlab.org/nlab/show/fixed+point -- it talks about "completeness of fix(f)" but I'm not sure it says what fix(f) is.
23:52:34 <shachaf> Is it just a subcategory of F-Alg(L) which just has the fixed points, or something like that?
23:53:03 <shachaf> That doesn't sound right, actually.
