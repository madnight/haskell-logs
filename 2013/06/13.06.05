00:00:34 <shachaf> Yep.
00:00:48 <shachaf> Now write a function :: FTree a -> Tree a
00:01:12 <johnw> f (FTree tr _) = tr
00:01:25 <shachaf> I don't think that type-checks. :-)
00:01:26 <arkeet> :(
00:01:28 <shachaf> (Hooray for types!)
00:01:42 <johnw> oh, right, Tree Int is specialized in the data type
00:01:43 <arkeet> hooray
00:01:47 <johnw> let me turn my file into a real haskell-mode
00:02:45 <arkeet> where is CoYoneda on hackage now? I only see it in category-extras
00:02:53 <johnw> f (FTree tr f) = fmap f tr
00:02:58 <arkeet> correct
00:02:59 <shachaf> kan-extensions
00:03:02 <shachaf> But it's just called Yoneda.
00:03:06 <shachaf> Right.
00:03:12 <shachaf> Now write f :: Tree Int -> FTree Int
00:03:40 <johnw> f tr = FTree tr id
00:03:43 <shachaf> Yep.
00:03:51 <shachaf> OK, two more generalizations to make.
00:04:03 <shachaf> One: We don't actually care that the original Tree had Ints in it.
00:04:24 <shachaf> We don't care what the type was at all, in fact, as long as it matches the domain of the function.
00:04:27 <shachaf> Do you see what I mean?
00:04:45 <johnw> yes
00:04:47 <arkeet> shachaf++
00:04:55 <shachaf> So, we can say: data FTree a = forall x. FTree (Tree x) (x -> a)
00:05:08 <johnw> ooh... that is a clever way of sneaking up on the CoYoneda definition
00:05:36 <shachaf> Two: We don't actually care that we're dealing with Trees. We just care about the Functor laws (both of them! Figure out where we're using the other one).
00:05:53 <shachaf> So we can parameterize: data Foo f a = forall x. Foo (f x) (x -> a)
00:05:56 <shachaf> And that's CoYoneda.
00:06:08 <johnw> beautiful!
00:06:11 <h4199> this is great stuff
00:06:36 <shachaf> arkeet: Have I transferred my intuition for CoYoneda? :-)
00:06:48 <arkeet> in the context of haskell, sure
00:06:50 <johnw> instance Functor f => Functor (CoYoneda f) where fmap f (CoYoneda tr g) = CoYoneda tr (f . g)
00:06:57 <johnw> i think I've actually seen that before, but now it makes complete sense
00:07:07 <arkeet> CoYoneda f is a functor even if f isn't
00:07:10 <shachaf> Right, that's all I was after.
00:07:28 <arkeet> you just can't write CoYoneda f a -> f a without Functor f
00:07:34 <shachaf> When f is a Functor, CoYoneda f is isomorphic to f
00:07:48 <shachaf> You can prove this using the Functor laws.
00:08:04 <shachaf> There are two functions, lift :: f a -> CoYoneda f a, and lower :: Functor f => CoYoneda f a -> f a
00:08:14 <shachaf> (Notice how lift doesn't even have a Functor constraint.)
00:09:57 <arkeet> I love presheaves.
00:10:35 <shachaf> Exercise: Figure out Yoneda.
00:10:41 <arkeet> I can't believe the wikipeda article on the yoneda lemma doesn't mention presheaves.
00:10:42 <shachaf> It's the same thing except backwards.
00:10:49 <johnw> yeah, was doing Yoneda now :)
00:11:03 <shachaf> Here's a hint for Yoneda intuition:
00:11:11 <shachaf> fmap :: CoYoneda f a -> f a
00:11:15 <shachaf> fmap :: f a -> Yoneda f a
00:11:32 <arkeet> fmap?
00:11:37 <shachaf> fmap
00:11:41 <arkeet> I don't get it.
00:11:45 <shachaf> (Or something isomorphic to fmap.)
00:11:55 <arkeet> sure.
00:12:08 <arkeet> ok
00:12:13 <shachaf> I.e. CoYoneda is "the arguments to fmap". Yoneda is "the result of fmap"
00:12:38 <shachaf> Similarly: (>>=) :: m a -> Codensity m a
00:12:51 <shachaf> (=>>) :: Density w a -> w a
00:13:39 <shachaf> I feel kind of bad for explaining things in IRC instead of writing up a web page or something.
00:16:29 <johnw> shachaf: I can only write Contravariant for Yoneda right, not Functor?
00:16:46 <johnw> i need contrafmap
00:17:27 <shachaf> No.
00:17:40 <johnw> I have: data Yoneda f a = forall x. Yoneda ((a -> x) -> f x)
00:17:48 <shachaf> That's not Yoneda.
00:17:57 <johnw> oh?
00:18:10 <johnw> is it Yoneda (a -> x) (f x)?
00:18:17 <shachaf> newtype Yoneda f a = Yoneda (forall b. (a -> b) -> f b)
00:18:28 <johnw> ahh
00:18:37 <shachaf> Do you know the difference between those two?
00:18:54 <johnw> one fixes the type of b when the value is constructed
00:19:06 <johnw> is the other permits b to range over all types
00:19:14 <shachaf> Yes.
00:19:28 <shachaf> If you give me a (Yoneda f a), the question is: who gets to choose b?
00:19:41 <shachaf> If it's existential, you get to choose it. If it's universal, I get to choose it.
00:19:49 <johnw> that's a very good way of expresses it
00:20:28 <johnw> the Functor constraint moved to the lift function
00:20:34 <shachaf> Yep.
00:20:34 <johnw> lowerYoneda (Yoneda f) = f id
00:20:36 <johnw> liftYoneda a = Yoneda $ \f -> fmap f a
00:21:40 <johnw> can I write a Functor instance for Yoneda?
00:21:48 <shachaf> I don't know.
00:22:06 <johnw> i need to map over a contravariant argument
00:22:07 <arkeet> you should be able to.
00:22:15 <johnw> in (a -> x) -> f x, don't I need to fmap over the "a"?
00:22:18 <shachaf> With enough unsafeCoerce. :-)
00:22:41 <arkeet> you don't need unsafeCoerce
00:22:48 <shachaf> I know.
00:22:57 <johnw> i wonder if I can inject a function: (a -> b) -> (b -> x) -> f x...
00:24:00 <johnw> that doesn't help me at all
00:24:53 <shachaf> Here, I'll take the opportunity to explain how to use ImplicitParams.
00:25:00 <shachaf> Î»> instance Functor (Yoneda f) where fmap f (Yoneda k) = ?hi
00:25:03 <thoughtpolice> shachaf: i like that explanation of CoYoneda! also you should write a blog or something
00:25:04 <shachaf>     Unbound implicit parameter (?hi::Yoneda f b)
00:25:14 <shachaf> OK, so I need to give a Yoneda value.
00:25:21 <shachaf> Î»> instance Functor (Yoneda f) where fmap f (Yoneda k) = Yoneda $ ?hi f k
00:25:24 <shachaf>       (?hi::(a -> b) -> ((a -> b0) -> f b0) -> (b -> b1) -> f b1)
00:25:26 <thoughtpolice> the other day i had to use ImplicitParams instead of TypeHoles since I was using GHC 7.6
00:25:36 <thoughtpolice> and i was sad :(
00:26:00 <shachaf> OK, that looks promising. I have three "ingredients": (a -> b), ((a -> b0) -> f b0), and (b -> b1)
00:26:13 <shachaf> The quantification is unfortunately not written here.
00:26:19 <shachaf> Î»> instance Functor (Yoneda f) where fmap f (Yoneda k) = Yoneda $ \x -> ?hi x f k
00:26:22 <shachaf>       (?hi::(b -> b1) -> (a -> b) -> ((a -> b0) -> f b0) -> f b1)
00:26:30 <shachaf> It looks like I can compose those two, maybe.
00:26:35 <shachaf> Î»> instance Functor (Yoneda f) where fmap f (Yoneda k) = Yoneda $ \x -> ?hi (x . f) k
00:26:38 <shachaf>       (?hi::(a -> b1) -> ((a -> b0) -> f b0) -> f b1)
00:26:54 <shachaf> Now it looks like I can give the first thing as an argument to the second thing. b1 and b0 will unify.
00:27:02 <shachaf> Î»> instance Functor (Yoneda f) where fmap f (Yoneda k) = Yoneda $ \x -> ?hi (k (x . f))
00:27:05 <shachaf>     Unbound implicit parameter (?hi::f b1 -> f b1)
00:27:10 <shachaf> Now ?hi = id, so I can get rid ofit.
00:27:19 <johnw> whoa
00:27:21 <shachaf> And I just gave the exercise away. Oh well.
00:27:24 <johnw> that was super cool
00:27:43 <shachaf> thoughtpolice: I prefer ImplicitParams to TypeHoles, at least the way it was last time I looked at it.
00:28:01 <thoughtpolice> johnw: it's also the only real reason people use ImplicitParams in my experience :P
00:28:22 <johnw> shachaf: I had gotten to here: fmap f (Yoneda g) = Yoneda (fmap g (flip f)), which complained that a -> b did not match a -> (b -> x) -> x, which looked like it just needed Yoneda again!
00:28:41 <arkeet> if you need a function, start by making a lambda.
00:28:43 <shachaf> Symptom: Over-@pling.
00:28:48 <arkeet> you can always pl later.
00:28:54 <johnw> arkeet: right, that's excellent advice
00:28:56 <shachaf> Do what arkeet says. Don't use flip pretty mcuh ever.
00:28:58 <thoughtpolice> shachaf: why? my main thing is that i just like having the list of some of the stuff in scope
00:29:19 <shachaf> thoughtpolice: Maybe it's improved since last time. When I tested TypeHoles, it showed *less* information than ImplicitParams.
00:29:29 <shachaf> Also the holes were unnamed, but I think that's "fixed".
00:29:41 <shachaf> (In a very bizarre way, but oh well.)
00:29:44 <johnw> i also finally got to see how shachaf uses ImplicitParams, which was just... awesome.  That alone deserves a blog post imho
00:30:05 <thoughtpolice> shachaf: named parameters? i'm not sure if they made it in yet
00:30:11 <shachaf> OK.
00:30:19 <arkeet> I support the idea of shachaf having a blog.
00:30:24 <arkeet> I'd have a blog too if I had anything to write about.
00:30:48 <johnw> arkeet: take what shachaf says, and make it publishable
00:31:12 <shachaf> arkeet: Compromise: I have one, and you write all the articles for it.
00:31:18 <arkeet> ha
00:31:50 <thoughtpolice> even i have a blog, it's easy!
00:31:56 <arkeet> I think I have a blog somewhere.
00:32:01 <arkeet> I don't remember.
00:32:04 <arkeet> it probably didn't have any posts anyway
00:32:26 <arkeet> well, it might have had a "hi I have a blog" post
00:32:34 <h4199> I support putting this mini lecture series somewhere, even if it is just a cut and paste of the IRC log
00:35:14 <johnw> shachaf: that example you started out with of (Tree Int, Int -> Int), and then proceeded to generalize to CoYoneda, do you have a similar starting example for Yoneda?
00:35:58 <johnw> if CoYoneda is for associating a "transform" with a map, then Yoneda is...
00:36:05 <shachaf> Not exactly. That's why I said CoYoneda seems more intuitive to me.
00:36:11 <shachaf> But there's the hint I gave above.
00:37:20 * hackagebot magma 0.1.0.0 - magma is an algebraic structure consisting a set together with an binary operation.  http://hackage.haskell.org/package/magma-0.1.0.0 (KatsutoshiItoh)
00:37:31 <shachaf> Oh boy.
00:37:53 <shachaf> class Magma a where (<>) :: a -> a -> a
00:39:15 <shachaf> Here's a fun type:
00:39:19 <shachaf> data CoYoSet a = forall b. Ord b => CoYoSet (b -> a) (S.Set b)
00:39:29 <shachaf> It's a Functor, and you can lift and lower Sets to it.
00:39:47 <arkeet> fun
00:40:22 <shachaf> However, (S.map f . S.map g) might be *more* efficient than (S.map (f . g))
00:40:29 <arkeet> why is that?
00:40:30 <shachaf> If g = const x, for instance.
00:40:34 <arkeet> oh
00:40:43 <shachaf> CoYoSet can't help you with that.
00:40:50 <arkeet> that sounds like an unusual case
00:41:03 <johnw> CoYoneda is really just turning repeated fmaps into composition, and then you do one fmap at the time that you lower.  In a way, it a lot like DLists, but for arbitrary functors.  How does this relate to Codensity?
00:41:03 <shachaf> Well, it's true for any non-injective function, to some degree.
00:41:31 <osa1> I'm looking for a way to implement `instance (Binary (MV.MVector GHC.Prim.RealWorld Val))` where there is already a Binary Val instance, how can I do that? is it possible without calling unsafePerformIO ?
00:41:35 <shachaf> arkeet: The place where you really suffer is when you try to do the same trick with Codensity to make a Set monad.
00:41:49 <johnw> CoDensity is turning repeated binds into composition?
00:41:56 <shachaf> Because you don't get merging until the very end, when you lower.
00:42:29 <shachaf> osa1: It is not possible.
00:42:48 <osa1> shachaf: so IOVectors are not serializable ?
00:43:11 <shachaf> I don't think it makes sense to serialize an IOVector.
00:43:18 <shachaf> You can serialize its *contents*.
00:43:26 <shachaf> I don't know how. I've never used vector.
00:43:43 <shachaf> But serializing a mutable thing doesn't make a lot of sense in general.
00:43:49 <shachaf> Codensity is...
00:43:54 <shachaf> I'll leave Codensity to arkeet.
00:44:03 <arkeet> I don't know what codensity is
00:44:17 <arkeet> and comonad.com is down
00:44:53 <arkeet> http://en.wikipedia.org/wiki/Takuan is yummy
00:45:08 <johnw> shachaf: I see what you mean now about CoYoneda intuition being much easier
00:45:25 <shachaf> Here is my hint for Codensity:
00:45:33 <johnw> in one sense, it's just "deferring fmap"
00:45:34 <shachaf> newtype   Codensity m a = Codensity { runCodensity :: forall b. (a -> m b) -> m b }
00:45:37 <shachaf> (>>=) :: Monad m => m a ->                           (forall b. (a -> m b) -> m b)
00:46:08 <shachaf> johnw: CoYoneda and Yoneda do the same thing.
00:46:17 <shachaf> They both turn multiple fmaps into one fmap via function composition.
00:46:37 <johnw> but they change the directionality of the composition?
00:46:50 <shachaf> ?
00:46:59 <johnw> one is f . g, the other is g . (. f)
00:47:16 <shachaf> I think you need to go through the code you wrote for Yoneda and evaluate it by hand.
00:47:23 <johnw> ok, that's a good idea
00:47:30 <shachaf> Note: I don't recommend (g . (. f))
00:47:40 <johnw> i think you've made that abundantly clear by now :)
00:47:52 <shachaf> And yet you keep doing it.
00:47:58 <johnw> I like it, and so will keep doing so
00:48:10 <johnw> besides, you wrote (. (. f)) :)
00:49:38 <shachaf> I wrote (. (. f)), but: It was in code that I was using to experiment with something myself; I wasn't using it to explain things to other people; and I didn't get it wrong.
00:50:01 <shachaf> It's a bit like pedantry. I don't really mind it if you're a pedant, and I don't really mind it if you're wrong, but I mind it if you're a pedant and wrong.
00:50:06 <johnw> I got it wrong that one time
00:50:19 <shachaf> Anyway, not now.
00:50:37 <shachaf> I was advising  it for your own sake.
00:50:50 <shachaf> For what it's worth your (. (. f)) is the same as my (. (. f))
00:50:53 <shachaf> (I.e. (. (. f)) g)
00:51:15 <johnw> i'm quite comfortable with it; my misuse before was not due to (.), but having misread something else
00:51:21 <johnw> ah, true!
00:52:41 <johnw> k . (. f) means that when a function is passed, it will be "inserted", so: k . (. f) $ id = k . id . f.  That's why I thought that Yoneda was composing in reverse.
00:53:52 <shachaf> (. f) means "map over f's argument"
00:54:03 <shachaf> (I.e. apply a function *before* it gets the argument.)
00:54:16 <shachaf> (. (. f)) means "map over f's argument's argument"
00:54:33 <shachaf> Similarly (f .) means "map over f's result" (*after* it returns the result).
00:54:42 <johnw> wait, huh?
00:54:51 <johnw> (. f) k == k . f
00:54:56 <shachaf> So ((f .) .) means "map over f's result's result", i.e., the result of the function it returns.
00:54:56 <johnw> isn't that mapping over f's result?
00:55:20 <shachaf> OK, I said that wrong. It's "map f over the argument"
00:55:22 <arkeet> I'm going to bed.
00:55:24 <shachaf> And "map f over the result"
00:55:28 <johnw> ah, ok
00:56:12 <johnw> i think that you've convinced me to not introduce this syntax to newcomers, though
00:56:23 <arkeet> stick with lambdas.
00:57:25 <dipra> Is anyone willing to write the subtitles for the series of training courses about Haskell (ex: http://bit.ly/10PwK0G). There are many services that can provide online collaboration to build subtitles. Including: http://.capnsub.com, http://amara.org, etc. Are you ready for contributing?
00:59:31 <t7> born ready
01:06:24 <shachaf> arkeet: What are the monad laws for class Functor m => Monad where monad :: Free m a -> m a?
01:06:32 <dipra> t7
01:06:58 <arkeet> shachaf: ??
01:07:09 <shachaf> ????
01:07:22 <arkeet> did you mean to have a nullary class?
01:07:28 <shachaf> Er, Monad m
01:07:41 <arkeet> I guessed so.
01:07:43 <arkeet> oh I get it.
01:07:54 <shachaf> Compare: class Monoid m where mconcat :: [m] -> m
01:08:03 <arkeet> yes
01:08:15 <arkeet> which has a law
01:08:21 <shachaf> (Also: class Functor w => Comonad w where comonad :: w a -> Cofree w a)
01:09:21 <shachaf> What law?
01:10:00 <arkeet> stuff like mconcat [x] = x
01:10:22 <shachaf> Sure, but what one law in particular?
01:10:24 <arkeet> uh
01:11:09 <shachaf> I think ellliottt suggested mconcat . map mconcat = mconcat . mconcat
01:11:25 <arkeet> that doesn't make sense.
01:11:30 <arkeet> but mconcat . map mconcat = mconcat . concat
01:11:54 <shachaf> Yes.
01:12:06 <shachaf> concat = mconcat here
01:12:09 <arkeet> fine.
01:12:19 <shachaf> OK, he suggested it without the m.
01:12:24 <arkeet> but you also need mconcat [x] = x
01:12:49 <shachaf> Can you find me some good laws for the Free version of Monad, anyway?
01:12:58 <shachaf> That's your exercise.
01:13:12 <shachaf> (Actually your exercise is going to bed.)
01:13:16 <arkeet> well, the monoid thing basically says that mconcat is a [] monad algebra.
01:13:31 <arkeet> so write out what the laws for a free monad monad algebra are.
01:15:13 <johnw> shachaf: https://gist.github.com/5712423
01:15:55 <shachaf> You're missing the id in the top half, I think.
01:16:24 <shachaf> Anyway, looks reasonable.
01:16:56 <johnw> ah, right
01:17:04 <johnw> i elided that, but shouldn't have
01:17:29 <johnw> so, if they end up being the same, I guess you just need Yoneda when you need the forall b in the covariant position?
01:17:32 <shachaf> Eliding it is reasonable but should be done uniformly.
01:17:45 <shachaf> I'm not sure what you mean by "need the forall b in the covariant position"
01:18:12 <johnw> (I updated the gist)
01:18:31 <johnw> well, with CoYoneda, you have forall b. ... b -> a
01:18:32 <dipra> Nobody else? British or American or anybody who speaks English can make the main subtitle because courses are in English. others can translate them to their own language.
01:18:45 <johnw> in Yoneda, you have forall b. a -> b ...
01:19:03 <johnw> which Tekmo uses for his GADT transformation
01:19:08 <shachaf> I don't know what you mean by "in the covariant position", and I don't know what you mean by "need".
01:19:29 <johnw> in a -> b, b is the type in the covariant position (wrong terminology)?
01:19:33 <shachaf> I also don't know, in general, when you would want to use Yoneda, or want to use CoYoneda.
01:19:46 <shachaf> Yes, but the "forall b" isn't.
01:19:47 <johnw> well, you gave us a use of CoYoneda
01:19:57 <johnw> ah, I see the confusion
01:20:01 <blz37> > :type foldl
01:20:01 <shachaf> The use of CoYoneda that I gave you works equally well for Yoneda.
01:20:02 <lambdabot>   <hint>:1:1: parse error on input `:'
01:20:08 <blz37> :type foldl
01:20:29 <shachaf> Maybe another perspective... fmap takes two arguments, a function and an action. something :: Yoneda f a is fmap already applied to the action. You just need to give it a function to fmap.
01:20:48 <shachaf> But before you apply the function you can map over its argument.
01:21:41 <shachaf> johnw: (Also, is your "y" being mutated in that code, or what?)
01:21:49 <johnw> say I have a -> f Int, and a -> f Char, but what I need is a -> f b, then I can use Yoneda to get a -> (Int -> b) -> f b and a -> (Char -> b) -> f b.  I don't think CoYoneda helps me there?
01:22:11 <johnw> yes, y was being mutated, but in the Monadic "y <-" sense, in that each line shadows the previous
01:22:26 <johnw> the code is terrible, don't try too hard to make sense of it
01:22:34 <shachaf> That is a terribly confusing notation that I strongly recommend getting out of the habit of writing.
01:23:01 <shachaf> Also, "y <-" is not mutation. Monads are not about mutation. There is no mutation going on when you "y <-"
01:23:20 <arkeet> mootation.
01:23:21 <johnw> what I mean is, imagine there was a y <- return $ fmap g y, for example
01:23:23 <shachaf> Anyway, strong recommendation. Write your own code however you want. But it'll make your life easier.
01:23:27 <arkeet> mutato.
01:23:29 <johnw> anyway, that's neither here nor there
01:23:50 <arkeet> I wonder what a mutato looks like.
01:23:56 <arkeet> or tastes like.
01:24:03 <shachaf> Or sounds like.
01:24:06 <shachaf> Well, it's probably very quiet.
01:24:22 <johnw> so, Yoneda is like a "premade fmap" just waiting for the function, while CoYoneda is the ingredients, just waiting to be fmapped, but they are isomorphic
01:24:57 <johnw> why use one over the other then, I wonder?
01:25:05 <shachaf> When f is a Functor, Yoneda f a ~ CoYoneda f a ~ f a
01:25:14 <shachaf> I don't know in general.
01:25:14 <johnw> ahhh
01:25:40 <johnw> we need it to be a functor to lowerCoY, and we need it to be a functor to liftY
01:25:50 <johnw> so it seems like we're not going to get much use out of them without functors?
01:26:12 <shachaf> Let's see.
01:26:14 <johnw> CoYoneda seems preferable, then, if only because it's trivial to reason about
01:26:20 <shachaf> Yoneda f a = forall b. (a -> b) -> f b
01:26:29 <shachaf> CoYoneda Endo a = foall b. (a -> b) -> b -> b
01:26:33 <shachaf> I.e. Maybe a
01:26:36 <shachaf> s/Co//
01:26:42 <adinapoli> guys, I have a naive question. What am I doing wrong in this piece of code? I'm just doodling around, ideally I want to abstract a bit from the particular monoid, but I don't know if I'm making sense at all :D
01:26:43 <adinapoli> sumIt' :: (Num a, Monoid (m a)) => a -> m a
01:26:43 <adinapoli> sumIt' x = Sum (x + x)
01:26:51 <shachaf> CoYoneda IORef a = exists x. (IORef x, x -> a)
01:26:55 <shachaf> I.e. a read-only IORef
01:27:10 <shachaf> adinapoli: Why don't you tell us?
01:27:32 <adinapoli> shachaf: my speculation is that is too generic
01:27:44 <shachaf> My speculation is that it works perfectly.
01:27:49 <johnw> Yoneda IORef a = forall b. (a -> b) -> IORef b, a write-only IORef?
01:27:52 <arkeet> I don't know what the code is supposed to try to do.
01:28:00 <shachaf> johnw: No.
01:28:00 <adinapoli> shachaf: but ghc barks at me :(
01:28:04 <shachaf> More like a useless thing.
01:28:12 <johnw> oh, a function that produces on IORef, yeah
01:28:23 <shachaf> adinapoli: Aha! Then go to hpaste.org and paste your full code, and the full error message.
01:28:26 <arkeet> the coyoneda one looks more useful.
01:28:37 <shachaf> And maybe explain what you were trying to do.
01:28:45 <shachaf> Otherwise it is very difficult to help.
01:28:46 <arkeet> well, it's read-only.
01:28:49 <bitonic> adinapoli: Sum is not any â€˜mâ€™
01:28:55 <shachaf> arkeet: Except for âŠ¥. :-(
01:29:08 <arkeet> damn that âŠ¥
01:29:52 <adinapoli> bitonic: aha! Great point, dumb me
01:29:53 <bitonic> adinapoli: if the body of the function has to be that, you want â€˜sumIt' :: (Num a) => a -> Sum aâ€™
01:30:08 <bitonic> adinapoli: tbh, GHC was pretty clear on that â€˜Could not deduce (m ~ Sum)â€™
01:30:32 <bitonic> which means that GHC couldnâ€™t come up with evidence that m is equal to Sum
01:30:41 <adinapoli> bitonic: you're right, it's just that I'm doodling around and I wanted to play with the intuition that "functions are a monoidal category closed under the function composition"
01:31:06 <bitonic> adinapoli: Iâ€™m not sure what Sum has to do with that but OK
01:31:41 <adinapoli> bitonic: the idea was to have functions which yield monoids, so that I can write function composition in terms of mappend
01:32:04 <arkeet> that's Endo.
01:32:10 <bitonic> adinapoli: I understand that â€˜a -> aâ€™ is a monoid (modulo strictness probably), but I donâ€™t see what that has to do with Sum
01:32:55 <shachaf> It turns out Hunt the Wumpus was written in Agda. That's why it has bottomless pits.
01:33:08 <adinapoli> bitonic: probably you need a bit of context about what I was trying to do, let me hpaste the whole program
01:33:53 <bitonic> shachaf: I would say that â€˜bottomlessâ€™ is actually _|_, while things â€˜with a bottomâ€™ are not _|_.
01:34:35 <shachaf> bitonic: Fine! They should have written Hunt the Wumpus in Agda.
01:34:50 <shachaf> That way it wouldn't have had bottomless pits.
01:34:54 <bitonic> right.
01:34:57 <osfameron> hahahaha
01:35:14 <bitonic> those game designers really need to get their terminology right
01:35:22 <shachaf> No, I don't like that either.
01:35:22 <bitonic> â€˜non-terminating pitsâ€™ would have been less misleading
01:35:25 <shachaf> Oh well.
01:35:32 <shachaf> Partial pits.
01:35:36 <adinapoli> ok, as said it's just for doodling, probably you'll find it "pointless"
01:35:37 <adinapoli> http://hpaste.org/89339
01:35:38 <shachaf> Hmm, that doesn't work at all.
01:35:41 <bitonic> undefined pits
01:36:04 <adinapoli> …and probably a bit "informal" on the CT side
01:36:27 <bitonic> adinapoli: the fact that â€˜a -> aâ€™ is a Monoid is unrelated to Sum being a Monoid, too
01:36:57 <bitonic> adinapoli: and there is already a Monoid instance for â€˜a -> aâ€™ under the guise of â€˜Endo aâ€™
01:37:01 <adinapoli> bitonic: I know, and to be honest, I just discovered "a -> a" is a monoid too, which is enlightening
01:37:09 <shachaf> I think you've entirely misunderstood the phrase that you're trying to get at.
01:37:11 <adinapoli> bitonic: aha! Endo, we meet again
01:37:14 <bitonic> so â€˜Endo sumIt <> Endo squareItâ€™ will work
01:37:32 <arkeet> that's Endo.
01:37:48 <adinapoli> bitonic: that's cool. Endo states for "Endofunctor"?
01:37:52 <arkeet> no.
01:37:56 <adinapoli> lol
01:38:02 <adinapoli> endomorphism?
01:38:05 <arkeet> probably
01:38:13 <adinapoli> ok :D
01:38:41 <shachaf> Endofunction! "endo" just means "from something to itself".
01:38:49 <shachaf> Endonote: Come up with better terminology.
01:38:55 <blz37> is accumulator position for foldl and foldr reversed in the function argument list ?
01:38:56 <arkeet> :(
01:38:58 <Shamar> why I'm getting  "file.csv: openFile: resource busy (file is locked)" with fuser and lsof stating that no one is using the file?
01:39:03 <Shamar> on linux
01:39:12 <arkeet> blz37: I'm not sure what your question means exactly, but yes
01:39:24 <shachaf> arkeet: Cheerkit up! That's what you get for not going to bed.
01:39:30 <arkeet> :(
01:39:34 <adinapoli> thanks guys, I happy I dreamt monoids last night, I built another piece of intuition about Haskell and CT today
01:41:17 <blz37> arkeet: This is from "Learn you a Haskell"   -->    sum' xs = foldl (\acc x -> acc + x) 0 xs
01:41:42 <blz37> if I use foldr instead, will it be   sum' xs = foldr (\x acc -> acc + x) 0 xs    ?
01:41:46 <Rail> Hey, just learning Haskell, going over kinds. I'm a little more comfortable with C++ and I was wondering, are kinds more or less equivelent to template templates in C++?
01:42:07 <shachaf> Rail: Not really?
01:42:14 <arkeet> blz37: if you want acc to mean something reasonable, yes
01:42:18 <arkeet> look at the types.
01:42:18 <johnw> shachaf: thank you very much for that elucidation of (Co)Yoneda, that helped a great deal
01:42:19 <arkeet> :t foldl
01:42:20 <Rail> As I can manage to define a lot of the types with higher kinds with C++ tempalte templates
01:42:20 <lambdabot> (a -> b -> a) -> a -> [b] -> a
01:42:21 <bitonic> Rail: no
01:42:21 <arkeet> :t foldr
01:42:22 <Rail> and get similar errors
01:42:22 <lambdabot> (a -> b -> b) -> b -> [a] -> b
01:42:40 <bitonic> Rail: similar errors?
01:42:41 <arkeet> whatever the "accumulator" is, it's what gets returned at the end.
01:42:50 <Rail> bitonic, shachaf: http://pastie.org/private/kzrcu183yjrxktutertq
01:43:01 <arkeet> foldl and foldr are rather different though.
01:43:06 <shachaf> Are types more or less equivalent to numbers?
01:43:12 <Rail> As in, if I try and use a template that has the wrong number of type parameters
01:43:27 <Rail> Sorry if I'm being dumb here
01:43:33 <bitonic> Rail: yes, type constructors and templates both have parameters.  in that sense they are similar
01:43:51 <bitonic> although type constructors always have one parameter
01:43:55 <shachaf> I see what you are after. There is a similarity.
01:44:02 <Rail> It's just, I can specify a template template that takes a certain number of parameters, in the same way a kind specifies
01:44:06 <Rail> Ah, hmm
01:44:24 <bitonic> Rail: but thatâ€™s not saying much, is it?
01:44:35 <shachaf> But "kinds" are just things that type-level things have. Everything has kinds. Int and Maybe and Maybe Int have kinds.
01:44:48 <blz37> arkeet: I can understand how foldl and foldr are different but it should not affect the implementation even if the position of accumulator in the argument list is the same.
01:45:10 <Rail> Right I'm just a little confused at how It's different that's all, I know there aren't kinds in C++, but it seems to represent the same information
01:45:13 <shachaf> Some specific things have a kind like (* -> *) -> *. In a general sort of sense those are similar to the template things you mentioned.
01:45:30 <shachaf> But I think you're confused about what the word "kind" means.
01:45:30 <arkeet> > foldl f z [a,b,c]
01:45:32 <lambdabot>   f (f (f z a) b) c
01:45:34 <arkeet> > foldr (flip f) z [a,b,c]
01:45:36 <lambdabot>   f (f (f z c) b) a
01:46:19 <Rail> shachaf: I probably am, the way I've been thinking about it was that, kinds were essentially types for types
01:46:32 <shachaf> Yep.
01:46:43 <bitonic> Rail: thatâ€™s precisely what they are
01:47:04 <Rail> Then I'm definitely confused on why they aren't equivelent
01:47:12 <Rail> I mean, I'm not saying C++ has kinds, just that I can achieve the same thing
01:47:24 <shachaf> So you mean, maybe, things that have "higher-kinded types" are similar to those template things you mentioned.
01:47:24 * hackagebot graph-rewriting-gl 0.7.3 - OpenGL interface for interactive port graph rewriting  http://hackage.haskell.org/package/graph-rewriting-gl-0.7.3 (JanRochel)
01:47:28 <bitonic> Rail: â€˜achieve the same thingâ€™ is a vague comparison
01:47:33 <Rail> Right
01:47:46 <shachaf> OK, I am unable to explain this.
01:48:06 <bitonic> Rail: C++ templates are very different in nature, theyâ€™re sort of type checked macros.  in Haskell kinds are internalised into the language
01:48:54 <Rail> Hmm
01:49:08 <bitonic> Rail: which gives them very different characteristics.  itâ€™s much more accurate to think of types as just another argument to the functions, arguments whose type is a kind
01:49:19 <Rail> I might be thinking about this in too practical a nature, in my mind. I'm thinking of Haskell kinds as 'restrictions on what types I can use to construct other types'
01:49:31 <Rail> And in C++, Im' imagining template templates as 'restructions on what templates I can use to construct other types'
01:50:48 <bitonic> Rail: so if kinds are the type of types, templates are the type of what?
01:51:17 <bitonic> Rail: in Haskell youâ€™ve got this three-floor building: value :: type :: kind
01:51:21 <Rail> well, template templates specifically, I was imagining template templates as the type of types
01:51:51 <bitonic> Rail: in C++ you have values and types and then youâ€™ve got a way to automatically paste a type everywhere in some class or function
01:51:52 <blz37> arkeet: why flip in foldr ?
01:51:58 <blz37> what are you trying to accomplish there ?
01:52:24 <arkeet> exercise: figure out what I was trying to accomplish there.
01:52:51 <arkeet> :t foldl
01:52:52 <lambdabot> (a -> b -> a) -> a -> [b] -> a
01:52:53 <arkeet> :t foldr . flip
01:52:54 <lambdabot> (b -> a -> b) -> b -> [a] -> b
01:52:56 <Rail> bitonic: but isn't that almost what happens with Haskell? with data Wrap a = Wrap (a f), the a from the left is pasted on the right, and the kind of a being * -> * restricts what a can be
01:54:19 <blz37> I think you are trying to show whether the accumulator position makes a difference.
01:54:51 <arkeet> the exercise was half for me.
01:55:09 <bitonic> Rail: well in a way you can see application as substitution, yes.  but the difference is that C++ templates are a notion outside C++â€™s type system, and this creates a big divideâ€”I havenâ€™t done C++ in years so Iâ€™m hesitant in giving specific examples, because I donâ€™t know templates well
01:55:16 <Hafydd> I don't want the whole exercise - I only want your half.
01:55:36 <bitonic> Rail: but you could just trust me and avoid thinking at C++ templates :P.  or wait for someone else to come up with meaningful examples.  I donâ€™t want to confuse you with poor examples
01:55:45 <shachaf> There's plenty of exercise to go around for everyone.
01:55:46 <blz37> > foldr f [a,b,c] z
01:55:47 <lambdabot>   Couldn't match expected type `[a0]'
01:55:47 <lambdabot>              with actual type `Debug.Si...
01:56:05 <blz37> :t foldr
01:56:06 <lambdabot> (a -> b -> b) -> b -> [a] -> b
01:56:17 <Rail> bitonic: no problem no problem, I'm not trying to argue they are the same concept, just that the parallels at least as I'm seeing them so far seem to be very very similar, I'll hang around :)
01:56:18 <Rail> Thank you
01:57:26 <shachaf> Perhaps what you mean to say is along the lines:
01:57:32 <shachaf> Templates are similar to parametric polymorphism.
01:57:40 <bitonic> Rail: there is some overlap in functionality, but theyâ€™re wildly different notions
01:57:49 <shachaf> "template templates" are similar to parametric polymorphism with a higher-kinded type.
01:57:54 <Rail> bitonic: functionality is what I'm after though, I'm wondering if the functionality is equivelent
01:58:06 <bitonic> Rail: there was a guy who wrote templates to calculate the area of ASCII polygons.  you are not going to do that with â€˜kindsâ€™ in a million years :)
01:58:08 <arkeet> is there anything similar to kind polymorphism?
01:58:15 <Rail> shachaf: that's exactly it, that's much better said than I, sorry I'm not so clear
01:58:24 <shachaf> Both of these are sort of vaguely correct in general but not really correct in detail.
01:58:30 <bitonic> Rail: Iâ€™m not sure how to convey effectively the difference between a meta-theoretic thing like C++ templates and kinds
01:58:32 <shachaf> arkeet: In (standard) Haskell? No.
01:58:42 <arkeet> no, on the template side.
01:58:55 <arkeet> I'm being silly.
01:58:59 <bitonic> arkeet: asking that question perpetuates a false truth :P
01:59:04 <shachaf> There are a bunch of differences between templates and parametric polymorphism.
01:59:11 <shachaf> For one, you don't get parametricity.
01:59:53 <blz37> :t foldr
01:59:55 <lambdabot> (a -> b -> b) -> b -> [a] -> b
02:00:07 <arkeet> the type of foldr has not changed in the last 4 minutes.
02:00:28 <arkeet> (or it changed and then changed back. who knows?)
02:00:29 <bitonic> repetitia iuvant
02:00:51 <blz37> sorry.. just "thinking out loud."
02:01:02 <shachaf> Compiling templates involves making a copy of "template" code and filling in the blanks with specific things.
02:01:08 <bitonic> blz37: feel free to get the type of foldr as many times as you want :P
02:01:15 <bitonic> well, as long as youâ€™re not flooding the channel
02:01:21 <shachaf> That's not how parametric code is (usually) compiled.
02:01:30 <shachaf> blz37: You can also /msg lambdabot.
02:01:45 <shachaf> @nixon Isn't that so?
02:01:45 <Rail> shachaf: how is it usually compiled? Just out of interest
02:01:45 <lambdabot> I believe in the battle-whether it's the battle of a campaign or the battle of this office, which is a continuing battle.
02:02:25 * hackagebot cabal2nix 1.51 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.51 (PeterSimons)
02:02:28 <arkeet> it's compiled by forgetting the types.
02:02:43 <shachaf> Yes.
02:02:44 <shachaf> Rail: You can think of it as passing a void * value, for instance.
02:02:45 <arkeet> if you have typeclass constraints, those are turned into dictionary arguments.
02:03:19 <Rail> Ah, sorry, I was still think of data types so I was confused as to the void *
02:03:23 <shachaf> Parametricity works perfectly well without type classes, though.
02:03:28 <arkeet> yes
02:03:38 <shachaf> Rail: "f" doesn't turn into anything, at compile time.
02:03:50 <Rail> shachaf: sorry, I should've used 'Int', or used f as a type parameter
02:03:56 <Rail> It was an error on my part with that example
02:04:25 <bitonic> Rail: Int is a â€˜void *â€™ too
02:04:48 <shachaf> In general, anyway.
02:04:52 <bitonic> types are all boxed in Haskell, for that specific reason
02:04:52 <Rail> bitonic: so when I define a type in Haskell, all the members are essentially void *? As in representation?
02:05:06 <Rail> Interesting
02:05:06 <bitonic> Rail: yes, datatypes are going to be referenced, not used â€˜in placeâ€™
02:05:21 <bitonic> Rail: obviously a Sufficiently Smart Compiler (tm) will unbox them when possible
02:05:29 <Rail> Just real quick, sorry I'm asking so much here
02:05:39 <bitonic> thatâ€™s what #haskell is for ehe
02:06:09 <Rail> But so, say I define data Example a = Example a, this is compiled with a void*, and I assume the type system just makes sure you never pass something where void* points to the wrong type?
02:06:29 <bitonic> Rail: yep
02:06:45 <bitonic> once you typechecked everything, you can forget about the types at runtime.  neat isnâ€™t it?
02:07:30 <Rail> Makes sense, so the C++ equivelent would just have several structures with a template
02:07:35 <shachaf> Rail: I think your life will be much easier if you stop thinking about C++.
02:08:06 <bitonic> yeah
02:08:12 <arkeet> what if he writes C++ to survive?
02:08:13 <Rail> shachaf: Sure ;), this is mainly just because I program in C++ as my actual day work, Haskell is just my spare time
02:08:18 <arkeet> well then
02:08:21 <Rail> I just wanted to know if my intuitions weren't wrong about C++
02:08:26 <cariveri> hi. how do I produce a portable binary with ghc ?
02:08:33 <bitonic> Rail: C++ will probably hinder your Haskell learning
02:08:35 <Rail> I probably would've been better off asking the question in #c++ and hoping someone there knew Haskell, it was more a C++ focused curiosity here
02:08:37 <bitonic> cariveri: portable across what?
02:08:50 <arkeet> I have a bunch of haskell binaries on my laptop.
02:08:54 <arkeet> does that count?
02:08:56 <cariveri> bitonic: ubuntu systems e.g.
02:08:57 <Rail> bitonic: well, I can't quit my job sadly :(, so it'll just be something I have to deal with
02:08:59 <shachaf> Rail: I'm not saying it's because people don't know the answers. I'm suggesting it'll give you the wrong intuition.
02:09:09 <shachaf> Haskell is a rather different language from C++.
02:09:30 <bitonic> cariveri: if the systems are similar simple GHC are already portableâ€”Haskell libraries are statically linked
02:09:35 <Rail> shachaf: Yeah, I understand, I mean, I don't think my intuition about kinds is wrong, you guys seemd to say I had the right understanding of it
02:09:37 <bitonic> *simple GHC binaries
02:09:43 <Rail> I was just curious about the parallels with template templates that's all
02:09:55 <shachaf> I think what you said was "not even wrong".
02:09:57 <Rail> I'm not trying to say kinds ARE template templtes in any manner
02:10:13 <Rail> ?
02:10:18 <bitonic> Rail: I didnâ€™t say that :P.  I think you lack the bigger picture about how types/kinds play with the rest of the language
02:10:19 <cariveri> bitonic: I thought statically means, that the libraries must be in the same place on the other system to work likewise.
02:10:29 <bitonic> cariveri: it means the opposite
02:10:34 <bitonic> cariveri: thatâ€™s dynamic linking
02:10:43 <Rail> bitonic: Yeah definitely, I'm only a beginner :)
02:10:48 <cariveri> bitonic: oh I confused them then.
02:10:53 <shachaf> It's like saying that high temperatures are similar to walking.
02:11:05 <bitonic> Rail: right, so imo itâ€™s better not to try to draw dangerous parallels between two very different things, as a beginner
02:11:11 <bitonic> well I mean
02:11:11 <shachaf> The things exist in two different worlds.
02:11:15 <bitonic> do think about those things :P
02:11:21 <bitonic> but donâ€™t let yourself transport too much
02:11:30 <bitonic> Iâ€™m not trying to say you shouldnâ€™t question things ehe
02:11:37 <shachaf> Kinds are a system for classifying type-level things. templates don't "classify" anything.
02:12:06 <Rail> shachaf: no no I know, but template templates do 'classify' in a way the kinds of templates you can pass to a template
02:12:17 <Rail> I know It's not the same thing
02:12:22 <Rail> And I know I can't use this to think about Haskell
02:12:24 <cariveri> bitonic: so I could work out of the box ? I will try this. the goal is to give away the programm with the need of haskell development environment.
02:12:26 <shachaf> No, that is completely different from kinds.
02:12:42 <bitonic> cariveri: the main problem is going to be different glibc versions
02:12:55 <bitonic> assuming the architectures are the same
02:13:18 <Rail> shachaf: No I know I know, I'm defining things in C++ to be what they are not, as in. If a template in C++ is a type constructor, and a template template decides how that constructor looks, it seems similar
02:13:51 <arkeet> but they aren't, and it isn't.
02:14:33 <Rail> Ok
02:15:47 <arkeet> so it's best not to try to make analogies between them.
02:16:12 <Rail> Fair enough, the behaviour just seemed to be identical that's all, I'll just try and not think about it
02:17:05 <bitonic> Rail: I donâ€™t want you to accept what we say as truth, but please learn Haskell first and try the comparison second.  then you wonâ€™t need us to convince you
02:18:05 <Rail> bitonic: I understand, I do take what you guys say as truth though ;p, I was just hoping to understand why, I'll keep at Haskell and hopefully it'll become obvious
02:18:25 <cariveri> bitonic: thank you sofar.
02:18:58 <bitonic> Rail: tbh weâ€™re doing a pretty good job at coming up with good examples, as far as Iâ€™m concerned is because I donâ€™t know much C++ ehe
02:19:04 <bitonic> *pretty bad job
02:19:25 <Rail> I was hoping the pastebin would be useful for that, I'm not sure how though
02:20:24 <bitonic> Iâ€™m willfully avoiding a discussion on the details of C++ templates if that wasnâ€™t understood :P
02:20:47 <Rail> Yeah ;p
02:23:31 <blarghgh> hello
02:23:47 <bitonic> hi
02:25:00 <bitonic> that didnâ€™t last.
02:25:11 <bitonic> ah no, blarghgh is back!
02:25:35 <blz37> arkeet: you are trying to flip the arguments of the function which are just the  current  element of the list and accumulator.
02:25:37 <blarghgh> when defining a class such as: class Herp a where { herpoperator :: a -> a  -> a } and i implement herpoperator to be :: a (herpoperator) b = a, what mistake am i making ?
02:25:43 <blarghgh> bitonic: hugs
02:25:54 <blz37> and the result in accumulator will be the same.
02:26:19 <johnw> blarghgh: can you show us real code?
02:26:28 <bitonic> blarghgh: syntax mistake.  1. operators are not alphanumeric 2. if you want to infix functions, use `function`
02:27:12 <bitonic> blarghgh: so for example â€˜(:/!) :: a -> a -> aâ€™ and then â€˜a :/! b = ...â€™ would work
02:27:15 <blarghgh> i will write code soon and show you
02:27:29 <bitonic> blarghgh: or alternatively â€˜herpderp :: a -> a -> aâ€™  and then â€˜a `herpderp` b = ...â€™
02:28:03 <blarghgh> guys, gotta go, will check back later
02:28:07 <bitonic> ciao
02:28:08 <blarghgh> thanks anyway
02:28:10 <johnw> bitonic: I believe that operators beginning with : are always type operators
02:28:23 <johnw> (except for (:), of course)
02:28:43 <johnw> or making I'm thinking of data constructors
02:28:43 <bitonic> johnw: oh, right
02:28:46 <johnw> s/making/maybe
02:29:31 <johnw> data Foo a b = a :> b
02:31:22 <no-n> :>
02:40:43 <merijn> johnw: I think they're type and constructor operators
02:40:56 <shachaf> TypeOperators no longer require :
02:41:00 <merijn> By the same logic that both type and constructors start with capital letters
02:45:25 <ski> but infix data constructors still need to start with `:', no ?
02:45:49 <shachaf> Yes.
02:48:55 <hsn> is there any other compiler then ghc with jvm target
02:58:43 <supki> no
02:59:10 <merijn> GHC has a jvm target?
02:59:10 <supki> also ghc does not target JVM
02:59:16 <merijn> oh, whew
02:59:26 <merijn> I'm not crazy :p
03:01:15 <quicksilver> there have been 3 or 4 attempts to compiled haskell to JVM
03:01:29 <quicksilver> they've all bitrotted because nobody actually wants to do that.
03:10:33 <happyherp> hi. Why does  " do a <- return 1; a" not work?
03:11:02 <quicksilver> that gives a the value 1
03:11:07 <quicksilver> a is then not a monadic action
03:11:08 <quicksilver> it's the value 1.
03:11:13 <quicksilver> what did you hope it might do?
03:11:28 <happyherp> hoped the whole thing becomes 1
03:11:38 <alpounet> because a do block only returns a value of type 'm a', for some 'm' that is an instance of the Monad type class, and some arbitrary type 'a'
03:11:51 <quicksilver> well, then you wanted "do a <- return 1; return a"
03:11:53 <happyherp> do a <- 1 ; a
03:11:55 <happyherp> does not work either
03:12:14 <happyherp> ok, thx
03:12:14 <quicksilver> no, because the thing on the right of the "<-" needs to be a monadic action
03:12:19 <quicksilver> and 1 is not a monadic action.
03:12:40 <happyherp> so i need the second return to demonad a
03:12:54 <happyherp> thanks quicksilver
03:16:07 <hsn> why not to target jvm
03:17:17 <ski> happyherp : note that `do a <- return 1; return a', by a monad law, is equal to `return 1'
03:21:54 <quicksilver> hsn: because nobody seems to want it enough to keep the projects alive.
03:22:53 <hsn> thats sad java has lot of good libraries. such as spring
03:30:55 <merijn> Also, don't forget Haskell predates the existence of the JVM in the first place
03:31:30 <hsn> lisp does
03:32:09 <merijn> Yes, and many (the overwhelming majority!) of lisps don't target the JVM either
03:32:58 <k00mi_> hsn: have a look at Scala if you want something Haskell-ish on the JVM
03:33:28 <merijn> k00mi_: Scala is anything but haskell-ish
03:33:58 <k00mi_> I know it has quite a lot of differences
03:34:15 <k00mi_> but it's the closest you can get
03:34:25 <Jeanne-Kamikaze> isn't there a haskell compiler targetting the jvm ?
03:34:25 <lambdabot> Jeanne-Kamikaze: You have 1 new message. '/msg lambdabot @messages' to read it.
03:35:18 <dobblego> k00mi_: Frege is a whole lot closer to Haskell than Scala. Scala is not even in the same ball park.
03:36:56 <k00mi_> isn't that one of the dead attempts to port Haskell to the JVM?
03:37:17 <dobblego> k00mi_: no, it is quite recent
03:37:21 <Jeanne-Kamikaze> could be, didn't seem very alive last time I checkd
03:42:23 <k00mi_> ok, so it is not a port but very much like Haskell and the Github repo has been updated two days ago
03:52:46 <lisa1> CIAO
03:53:01 <lisa1> !LIST
03:53:09 <Botje_> *sigh*
03:53:12 <Botje_> are those bots still going around.
03:59:47 <fruitFly> any func that tell how many times an element is in a list? or should I just make a fold?
04:00:22 <ciaranm> @hoogle (Eq a) => [a] -> a -> Int
04:00:23 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
04:00:23 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
04:00:23 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
04:00:36 <ciaranm> @hoogle (Eq a) => a -> [a] -> Int
04:00:36 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
04:00:36 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
04:00:36 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
04:00:47 <aleator> count p = length . filter p
04:00:49 <ciaranm> hrm. that usually works.
04:00:55 <hpc> fruitFly: map (head &&& length) . group . sort
04:01:03 <hpc> :t map (head &&& length) . group . sort
04:01:04 <lambdabot> Ord c => [c] -> [(c, Int)]
04:01:05 <ChongLi> fruitFly: the function is count
04:01:35 <ChongLi> but hpc's solution is more general
04:01:40 <ChongLi> giving the counts of evertyhing
04:01:55 <ChongLi> actually, aleator's is good too
04:02:06 <ChongLi> since it counts with a predicate
04:05:04 <fruitFly> I like: count p = length . filter p
04:05:20 <fruitFly> hpc: trying to understand your though
04:05:30 <Bor0> length [ y | y <- [1, 2, 3, 4, 4, 4] , y == 4]
04:06:06 <hpc> > (head &&& length) [1,1,1,1,1] -- fruitFly
04:06:07 <lambdabot>   (1,5)
04:06:08 <fruitFly> hpc: what is &&?
04:06:14 <fruitFly> hpc &&&?
04:06:23 <merijn> :t (&&&)
04:06:24 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
04:06:32 <ChongLi> fruitFly: it's the juxtaposition of two functions
04:06:35 <merijn> fruitFly: read "a" as "(->)"
04:06:52 <hpc> > let xs = [1,1,1,1,1] in (head xs, length xs) -- this is the same thing
04:06:53 <lambdabot>   (1,5)
04:07:15 <fruitFly> count p = length . filter p ............... seems like the simplest
04:07:24 <merijn> "(->) b c -> (->) b c' -> (->) b (c, c')" -> "(b -> c) -> (b -> c') -> b -> (c, c')"
04:08:24 <ChongLi> > map (head &&& length) . group . sort $ [1,23,76,12,23,7,125,89,12,76,1,1,89,7]
04:08:26 <lambdabot>   [(1,3),(7,2),(12,2),(23,2),(76,2),(89,2),(125,1)]
04:14:36 <ChongLi> > map (head &&& length) . group . sort . take 20 $ randomRs ('a','z') (mkStdGen 4)
04:14:38 <lambdabot>   [('a',1),('b',2),('c',1),('d',1),('f',1),('i',1),('j',1),('k',2),('l',1),('...
04:16:25 <ciaranm> > fmap fmap fmap toUpper ["now", "you're", "being", "silly"]
04:16:27 <lambdabot>   ["NOW","YOU'RE","BEING","SILLY"]
04:18:34 <Taneb> > ["now", "you're", "being", "silly"] & mapped . mapped %~ toUpper
04:18:36 <lambdabot>   ["NOW","YOU'RE","BEING","SILLY"]
04:18:47 <ChongLi> nice work!
04:18:54 <MasseR_> What's %~?
04:19:06 <simukis_> :t (%~)
04:19:07 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
04:19:07 <supki> > ["now", "you're", "being", "silly"] & template %~ toUpper
04:19:08 <ChongLi> it's part of lens
04:19:09 <lambdabot>   ["NOW","YOU'RE","BEING","SILLY"]
04:19:21 <danr> :t template
04:19:22 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f) => (a -> f a) -> s -> f s
04:19:31 <ChongLi> Data.Data.Data
04:19:32 <ChongLi> haha
04:19:48 <danr> definitely about Data :)
04:19:53 <Hafydd> I was just thinking about Data.Data.Data. I was reminded by fmap fmap fmap
04:19:59 <simukis_> <insert picture> data. data everywhere.
04:20:11 <hpc> module Beetlejuice.Beetlejuice.Beetlejuice where
04:20:30 <alpounet> hah
04:20:39 <Hafydd> The image macro for "fmap fmap fmap" is unfortunately too much for #haskell.
04:20:52 <ChongLi> that movie is so bizarre
04:21:08 <alpounet> functors gone wild
04:27:32 * hackagebot graph-rewriting-trs 0.1.4 - Evaluate a first-order applicative term rewrite system interactively using graph reduction  http://hackage.haskell.org/package/graph-rewriting-trs-0.1.4 (JanRochel)
04:29:18 <supki> MasseR_: %~ applies function to the target(s) of Setter
04:29:28 <supki> MasseR_: you can read  p  as  (->)
04:29:47 <supki> Profunctor is here only because we want %~ to work on indexed stuff too
04:32:10 <MasseR_> Ah ok
04:32:32 <fruitFly> I think this is failing at the indexToBase64 function on line 44 .. but i don't know why? http://ideone.com/e0z2e7
04:42:20 <ion> @tell dcoutts Youâ€™re a developer for the cairo package, right? Iâ€™d really appreciate an Applicative instance for Render.
04:42:20 <lambdabot> Consider it noted.
04:44:58 <supki> fruitFly: surely  shiftL y 4  and  shiftL x 6  may be bigger than 64 ?
04:46:12 <fruitFly> supki: i don't think so, I will look at it
04:47:06 <fruitFly> supki: how do i throw an error message to see what value it's failing on?
04:49:01 <supki> throwing an error message on that is bad
04:49:19 <supki> why not indexToBase64 :: Word8 -> Either Word8 Char?
04:49:57 <supki> that way bad value would result in Left <something> so you can inspect it
04:50:08 <fruitFly> supki: to debug? never used either before, I'll look it up, but i'd appreciate if you could help me with the implimentation
04:52:09 <quchen> For debugging error is fine.
04:52:21 <quchen> Or Debug.Trace.
04:52:42 <supki> I think Debug.Trace would be more useful here
04:52:46 <supki> and certainly less work
04:53:25 <quchen> Yeah, and another benefit of Debug.Trace is that you can remove the import and the compiler will tell you where you forgot to remove the trace calls manually
04:53:25 <supki> fruitFly: i.e. for debugging you can use indexToBase64 i = i `traceShow` <your current implementation>
05:00:22 <fruitFly> supki: how do I use that? I tried putting an error message in, but it's not working, what do you think? http://ideone.com/PsELVh
05:10:57 <quchen> fruitFly: You have a line with 404 characters.
05:11:05 <quchen> Don't do that. :s
05:11:28 <supki> @ty (!!)
05:11:29 <lambdabot> [a] -> Int -> a
05:11:42 <supki> fruitFly: I don't understand what you are trying to do there
05:12:43 <fruitFly> quchen: lol .. I'll fix it, but that isn't my probllem now. This is: http://ideone.com/e0z2e7 .....I think it's in the indexTobase64 function line 44
05:12:55 <quchen> Also you're using 'length' a lot, you can combine those into folds with the "all" calls. "length xs . all p xs" traverses the list twice. Here's hexValid as a fold: http://hpaste.org/89351
05:13:31 <quchen> Ideone is awfully slow for me right now.
05:13:45 <fruitFly> supki: i'm trying to figure out why it's saying my index is too large, I swear it's not :S ... I not sure how to efficiently debug this, I'm still learning
05:14:04 <supki> fruitFly: did you try traceShow?
05:14:24 <fruitFly> supki: where do I do that, how does it work?
05:14:46 <fruitFly> quchen: thanks I'll take a look at it
05:14:46 <quchen> > length (['A' .. 'Z' ] ++ ['a' .. 'z'] ++ ['0' .. '9'] ++ "+/=")
05:14:48 <lambdabot>   65
05:14:59 <supki> indexToBase64 i = i `traceShow` <your current implementation>
05:15:03 <quchen> Word8 ranges from 0 to 255.
05:15:04 <fruitFly> I am feeding it some 64s
05:15:06 <fruitFly> max
05:15:13 <supki> fruitFly: that would trace every index passed to indexToBase64
05:15:27 <supki> eventually it would error with exception you getting
05:16:11 <fruitFly> quchen: yes, but I am taking groups of 3 bytes and ripping them into 4 6bit segments
05:16:16 <supki> in the long run I think it's better to rework your partial functions into nice total ones, but for quick debug traceShow is okay
05:16:32 <fruitFly> quchen:  with bytesTobase64indices just above
05:17:40 <supki> > let y = 5 in shiftL y 4 :: Word8
05:17:41 <lambdabot>   80
05:17:47 <supki> maximum is not really 64
05:20:16 <fruitFly> let y = 5 in shiftL (y :: Word8) 4
05:20:37 <fruitFly> ??? supki ^
05:21:31 <fruitFly> supki: y has to be a word8 before the operation, like in my implimentation, try it, it's less than 64
05:22:08 <quchen> > let y = 5 in shiftL (y :: Word8)
05:22:09 <lambdabot>   *Exception: show: No overloading for function
05:22:14 <quchen> > let y = 5 in shiftL (y :: Word8) 4
05:22:16 <lambdabot>   80
05:23:54 <supki> shiftL does not change type
05:26:54 <fruitFly> supki: i got the trace to work :)
05:27:45 <supki> fruitFly: was it useful?
05:28:18 <ion> Is there a popular package with a divMod for RealFrac?
05:29:24 <fruitFly> says it's getting 240? will look at it soon
05:30:31 <supki> ion: Data.Fixed.divMod' ?
05:30:44 <supki> > divMod' (1.5) (0.7)
05:30:46 <lambdabot>   (2,0.10000000000000009)
05:31:55 <ion> supki: Oh, dâ€™oh. I remembered Fixed had something like that but mistakenly thought it was only for Fixed values. Thanks.
05:33:00 <ion> Because why would they put it into Data.Fixed if it was more generic ;-)
05:35:19 <quchen> Arr HLint can't parse LambdaCase :-(
05:36:10 <Botje> ... yet!
05:36:13 <dario> hy
05:36:54 <dario> are there cases wher point-free style allows more optimizations?
05:37:59 <irene-knapp> I wouldn't think so
05:40:19 <no-n> > let a = let b = let c = let d = let e = 1 in e in d in c in b in a
05:40:20 <lambdabot>   1
05:40:26 <irene-knapp> lol
05:40:36 <irene-knapp> aggressively pointed style
05:40:54 <quchen> I find "1" much easier to read.
05:40:58 <ion> > let a = let a = let a = let a = let a = 1 in a in a in a in a in a
05:40:58 <no-n> 8)
05:40:59 <lambdabot>   1
05:42:09 <ion> > let a = do let a = do let a = do let a = do let a = 1 in do a in do a in do a in do a in do a
05:42:10 <lambdabot>   1
05:42:14 <mm_freak> l %~ fmap f  -- is there a shorter way to write this?
05:42:30 <no-n> 8D
05:42:45 <mm_freak> i.e. is there a lens operator that includes the fmap?
05:45:06 <ion> l . mapped %~ f :-P
05:49:57 <mm_freak> lol ok
05:50:13 <mm_freak> (%~ fmap f) it is =)
05:51:20 <elliott> . mapped is probably more idiomatic.
05:51:27 <elliott> albeit longer.
05:54:15 <amyers> dario: It will likely be worse
05:54:51 <juxovec> hi there, I have a problem to update cabal. it throws a lot of error messages
05:54:53 <juxovec> here's printout http://pastebin.com/eQnm2DLA
05:55:01 <mauke> The paste eQnm2DLA has been copied to http://hpaste.org/89353
05:55:03 <juxovec> please do any of you know what should I try now?
05:55:34 <dario> amyers: ok.. how come?
05:55:36 <mm_freak> elliott: depends on your notion of "idiomatic" =)
05:56:54 <elliott> mm_freak: well, because (x %~ fmap f) is (x %~ (mapped %~ f)).
05:57:03 <mm_freak> elliott: it's idiomatic for Maybe ComplicatedStructure, but probably not for Maybe Int
05:57:15 <elliott> and it's more lens-idiomatic to chain your optics all in one go
05:57:17 <typoclass> juxovec: hello. that looks very odd to me! almost as if a c compiler is run on .hs code, and predictably getting all kinds of parse errors
05:57:27 <mm_freak> elliott: yeah, i understand your point
05:58:08 <juxovec> typoclass: I have the same problem with all libraries I try to install with cabal
05:58:27 <juxovec> And when you say it looks like true.
05:58:29 <typoclass> juxovec: if you run the "cabal install cabal-install" command with -v3, it will show the exact commands that it is running
05:59:10 <typoclass> juxovec: you don't have a symlink "ghc -> gcc" or something like that?
05:59:50 <juxovec> cat /usr/local/bin/hgc
06:00:00 <juxovec> exedir="/usr/local/Cellar/ghc/7.4.2/lib/ghc-7.4.2"
06:00:01 <juxovec> ...
06:00:10 <juxovec> it runs ghc
06:00:33 <juxovec> but with -v3 runs cabal /usr/bin/gcc
06:00:51 <juxovec> and one line before it says "No uhc found"
06:01:45 <supki> juxovec: is ghc in your path?
06:02:06 <typoclass> juxovec: i suppose cabal is just looking for a few compilers it knows about. usually you use ghc these days
06:02:29 <supki> juxovec: also you can try with  cabal install --with-ghc=<path to ghc> ...
06:02:37 <juxovec> ok, I will try
06:04:12 <typoclass> supki: i don't know, i feel the deeper problem is why cabal got the idea to call gcc in the first place :-)
06:05:09 <typoclass> juxovec: could your ~/.cabal/config file be messed up in some way? (suppose it forces --with-ghc=/usr/bin/gcc or something)
06:05:38 <juxovec> there is printout http://hpaste.org/89354
06:05:47 <juxovec> with commands -v3 and --with-ghc
06:07:19 <typoclass> juxovec: could you run "where ghc"?
06:07:27 <elliott> it is calling cc as a preprocessor.
06:07:35 <elliott> that is why all the errors are lexical in nature.
06:07:35 <juxovec>  /usr/local/bin/ghc
06:07:49 <typoclass> juxovec: ok
06:07:57 <elliott> I have a guess. my guess is that it is clang's fault
06:08:06 <elliott> my guess is that if cabal used gcc to do the preprocessing instead, it would work
06:08:23 <elliott> perhaps you can say --with-cc=$(which gcc) or such to cabal
06:08:52 <quchen> juxovec: What did you do to have to upgrade cabal-install? Reinstalled GHC/HP?
06:08:55 <juxovec> Setup script is out of date, compiling...
06:08:55 <juxovec> ("/usr/local/bin/ghc",["-v","--make","/var/folders/gx/rz1s8t5s5rxfqq3dn8wn13w80000gn/T/Cabal-1.16.0.355580/Cabal-1.16.0.3/Setup.hs","-
06:09:12 <typoclass> juxovec: i think elliott is on to something
06:09:53 <juxovec> I have the same problem not only on installing cabal-install. The same thing happens when I install any other package
06:10:12 <elliott> that is consistent with my guess
06:10:20 <juxovec> this happens when I try to install elm http://pastebin.com/z7nA1d1q
06:10:29 <mauke> The paste z7nA1d1q has been copied to http://hpaste.org/89355
06:11:44 <typoclass> juxovec: ah
06:12:11 <applicative> nice errors juxovec
06:12:21 <applicative> what does which gcc say?
06:12:39 <juxovec> with --with-cc=/usr/local/bin/gcc it still runs hs files against clang
06:12:44 <typoclass> applicative: see the earlier paste; cabal ends up calling clang
06:12:51 <elliott> juxovec: perhaps --with-cpp=$(which gcc)
06:13:00 <elliott> I am not sure how cabal decides how to invoke the preprocessor
06:13:17 <applicative> I was wondering if there was no gcc
06:13:47 <typoclass> juxovec: that ton of warnings is a bit distracting, but it doesn't seem to halt compilation. it's warnings, not errors. in line 796 of the newest paste, cabal calls ghc and starts compiling, which then fails with a parse error. i suspect the c preprocessor (= clang) mangled the .hs source file
06:14:23 <elliott> I tentatively blame this on OS X not having gcc any more, which IIRC it doesn't
06:14:33 <magicman> @pl \(a,b) -> fmap (\x -> (x,b)) a
06:14:41 <elliott> but also GHC might be at fault in the end here. I doubt it should be passing --traditional
06:14:43 <juxovec> when I ran against --with-cpp it runned code against gcc but the error is still the same
06:14:58 <typoclass> juxovec: i'm pretty sure you'll be able to find the preprocessed file that cabal gives to ghc. (use -v3 if necessary)
06:15:19 <magicman> @botsnack
06:15:24 <typoclass> elliott: hm. interesting. but we have several mac people here, wouldn't they have noticed something obvious like that?
06:16:29 <elliott> well, perhaps there is something unusual about juxovec's setup. like using a prelease OS X version or having configured compiler defaults or something differently. no idea
06:16:45 <typoclass> elliott: right, that would make some sense
06:16:55 <juxovec> I use very default XCode compiler and homebrew package
06:17:09 <applicative> that gcc is in /usr/local is already unfamiliar to me on os x
06:17:44 <magicman> :(
06:17:53 <juxovec> it is in /usr/bin/gcc now
06:18:02 <elliott> juxovec: maybe you could report this problem with the homebrew folks? it seems to be a "system integration" type issue
06:18:06 <juxovec> ghc is in /usr/local/bin
06:18:20 <applicative> oh above it seemed gcc was too
06:18:53 <juxovec> elliott: I will probably report it
06:19:24 <applicative> ghc is a script, does something like cat /usr/local/bin/ghc point to a wrong gcc?
06:19:38 <juxovec> maybe problem is that I have installed both ghc and haskell-platform packages
06:19:56 <typoclass> juxovec: i think it'll help the bug report if you include the failing Codec/Binary/UTF8/String.hs file after the preprocessing stage (= when it is being given into ghc)
06:20:00 <applicative> you installed haskell platform how, though?
06:20:14 <juxovec> brew install haskell-platform...
06:20:41 <juxovec> but when I try to brew upgrade haskell-platform I get the same error (running C on hs file)
06:22:25 <applicative> bah. I was never able to get the homebrew ghc machinery working, but that was a long time ago.  just putting the bindist in ~/ghc/... is so much easier...
06:22:29 <typoclass> uhm. String.hs has a tab in the failing line (153). i got the file from "cabal unpack utf8-string"
06:24:48 <applicative> juxovec: frankly I think the official haskell platform installer or else just using the binary distribution of ghc only from the ghc site is more prudent than introducing another layer of error-proneness like homebreww
06:25:05 <lambdabot> uncurry (flip (fmap . flip (,)))
06:25:05 <lambdabot> :)
06:28:47 --- topic: '["Haskell Platform 2013.2: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down, try: http://hdiff.luite.com "]'
06:28:47 --- topic: set by shachaf!~shachaf@unaffiliated/shachaf on [Tue May 28 01:16:17 2013]
06:30:02 <latermuse> hehehe just got this error: ghc: panic! (the 'impossible' happened)
06:30:29 <typoclass> applicative: well, juxovec's paste indicated that ghc sees a parse error in line 153, which is the first one with a tab character. it doesn't *have* to be related, i just thought it's probable
06:37:43 * hackagebot acme-http 0.2.2 - fastest Haskell PONG server in the world  http://hackage.haskell.org/package/acme-http-0.2.2 (JeremyShaw)
06:38:27 --- mode: sendak.freenode.net set +o ChanServ
06:40:16 <typoclass> could anyone check if "clang -E" expands tab characters that are present in the input file? (i don't have clang installed)
06:41:06 <juxovec> I seems this https://github.com/mxcl/homebrew/issues/12225 is the reason of problem (and solution)
06:42:44 * hackagebot debian 3.79.1 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.79.1 (DavidFox)
06:44:03 <applicative> typoclass: there are no tabs in the result of clang -E blah.c
06:44:18 <typoclass> applicative: thanks for verifying!
06:46:23 <typoclass> ok this is my theory: the stray tab character in utf8-string's String.hs will not cause trouble on most systems because gcc is used for preprocessing. but on systems using clang, the tab will get expanded, causing ghc to fail with a parse error due to incorrect indentation
06:47:42 <typoclass> juxovec: ok if it works, then great. but i'm not sure what that bug report means ... "compile with llvm instead of clang" (i thought clang was part of llvm?)
06:49:01 * applicative cant tell what the --use-llvm means there
06:50:20 <applicative> typoclass: the brew formula says fails_with :clang do    cause <<-EOS.undent  Building with Clang configures GHC to use Clang as its preprocessor,  which causes subsequent GHC-based builds to fail.
06:50:38 <applicative> what does utf8-string have to do with this, though?
06:52:23 <typoclass> applicative: it was the package with juxovec's original build failure. of course it could be the first of many ("basically every package fails to build with clang as the preprocessor, utf8-string was just the first that was tried on his system")
06:52:48 <applicative> ah ok
06:53:27 <applicative> problems that reduce to the use of tabs somewhere are really a strain
06:54:10 <typoclass> not sure what the lesson is =) "clang isn't really suitable as a preprocessor" ...?
06:54:21 <typoclass> applicative: yep
06:54:55 <applicative> somehow i'm always irritated by the energetic dogmatism of the anti-tabs people, but of course they're right
06:56:21 <typoclass> applicative: i think a consistent tab style is not really a problem. the problem are single stray tabs that get put in by mistake (random patches that someone sent, etc.)
06:57:53 <typoclass> applicative: in other words, the world would be moar better(tm) if ghc had -fwarn-tabs on by default, and the few projects that use tabs consistently can add the -fno-warn-tabs switch to their *.cabal file
07:05:55 <fizbin> I think gcc also expands tabs.
07:05:55 <fizbin> I wonder if clang and gcc just have different default tab widths.
07:05:55 <merijn> fizbin: How would the tab width matter for gcc and clang?
07:05:56 <applicative> merijn it was to do with preprocessing hs files
07:05:56 <merijn> oh
07:05:56 <merijn> right
07:05:56 <pjdelport> obligatory: http://www.python.org/dev/peps/pep-0666/
07:05:56 <typoclass> merijn: the initial problem was the preprocessor expanding tabs, then ghc saying "parse error" due to indentation. or at least that's my best guess of what went on
07:06:14 <applicative> People who mix tabs and spaces, naturally, will find that their programs do not run.  Alas, we haven't found a way to give them an electric shock as from a cattle prod remotely.  (Though if somebody finds out a way to do this, I will be pleased to add this option to  the PEP.)
07:06:30 <applicative> I like this Laura C. we convince her to take up Haskell
07:06:54 <fizbin> I wonder what options are passed to the preprocessor.
07:08:03 <fizbin> It seems that the default for both gcc -E and clang -E is to convert all tabs to a single space. I suspect ghc passes some gcc-specific option to preserve tabs or to expand out tabstops to a specific width.
07:08:20 <FreeFull> ghc should spit out a scary warning when it sees a tab
07:08:52 <typoclass> fizbin: see http://hpaste.org/89354 around 132
07:09:46 <applicative> oh the thought is, clang just overlooks the additional instruction
07:09:58 <fizbin> Ah. -traditional is probably what makes gcc preserve whitespace. I'm not surprised clang doesn't support that.
07:11:00 <applicative>  '-traditional' is one of ... oh i see you noticed...
07:11:25 <tromp_> > 0.1+0.2
07:11:27 <lambdabot>   0.30000000000000004
07:11:31 <applicative> clang follows a different tradition; it's Protestant
07:11:33 <fizbin> Yep, that's it. gcc with -traditional passes whitespace through unchanged. clang either ignores -traditional or only sets some of the behaviors -traditional implies with gcc.
07:11:42 <quchen> tromp_: SMBC? :-D
07:11:57 <tromp_> yep:)
07:12:27 <tromp_> they even got the number of 0s correct
07:12:57 * typoclass . o O ( i wonder if floats could be turned off by default. literals like 0.3 could be, i dunno, Rationals or something )
07:13:25 <tromp_> > 0.1+0.2 :: Double
07:13:26 <lambdabot>   0.30000000000000004
07:13:31 <tromp_> > 0.1+0.2 :: Float
07:13:33 <lambdabot>   0.3
07:20:18 --- topic: '["Haskell Platform 2013.2: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down, try: http://hdiff.luite.com "]'
07:20:18 --- topic: set by shachaf!~shachaf@unaffiliated/shachaf on [Tue May 28 01:16:22 2013]
07:20:27 <fizbin> Huh. How does 0.3 :: Rational work? According to my ghci here, Rational doesn't have a Fractional instance.
07:20:46 <applicative> Fractional is defined in terms of Rational, no?
07:20:48 <Taneb> Rational = Ratio Integer
07:20:51 <byorgey> fizbin: yes it does.
07:21:05 <Taneb> There is an instance "Integral a => Fractional (Ratio a)
07:21:06 <Taneb> "
07:21:10 <applicative> ah
07:21:27 <applicative> Cyclone's a comin'
07:22:22 <fizbin> Huh. So there is, if I ask ghci for ":info GHC.Real.Ratio". I wonder why it didn't show it when I asked for ":info Fractional"
07:23:04 <merijn> fizbin: Did you import the Rational module?
07:23:14 <merijn> fizbin: :i only reports instances that are in scope
07:23:18 <applicative> it does if you import Data.Ratio
07:25:08 <typoclass> oddly, i can do "0.3::Rational" in ghci, but :i Fractional does not list the Ratio instance. probably something about imports, but still, it's curious
07:29:23 <merijn> Why do many Prelude functions have so much whitespace in their definition?
07:29:28 <merijn> e.g. "sum                     =  foldl (+) 0"
07:29:57 <shanse> to line up all the equal signs?
07:30:57 <merijn> No, because there's 4 lines in a row with that much whitespace and maybe 3 characters of arguments in the other definitions
07:31:12 <fizbin> It's faster to scan a whole huge amount of text when everything's lined up like that.
07:31:44 <merijn> fizbin: It's not about lining up as it could be lined up with half that whitespace too
07:32:16 <fizbin> And even though there are only 4 lines in a row now that are lined up like that, they may in the past have been part of a longer contiguous block that then got broken up as other functions were inserted.
07:33:14 <typoclass> merijn: maybe it made some sense in the past, then stuff moved out into another module, other stuff was inserted, etc
07:36:19 <Taneb> I have no idea why it took me so many tries to subscribe to the Libraries mailing list
07:47:25 <applicative> Taneb: they make it hard to join; you have to go through hoops to show that you are sufficiently irrational and emotional
07:48:03 <Taneb> applicative, I think that's a rather unfunny joke
07:48:22 <supki> S7uoI82h
07:48:27 <supki> oops
07:48:33 <Ankhers> nice password.
07:48:37 <geekosaur> so much for that nickserv pw...
07:48:59 <Ankhers> on the bright side, it is a fairly secure password...
07:49:19 <Ankhers> well... was...
07:49:27 <Taneb> Ankhers, it was until he showed it to over 1000 people in a publicly logged channel
07:49:40 <Ankhers> fact
07:49:51 * applicative is sufficiently irrational and emotional but also lacks patience...
07:49:56 <Ankhers> I just meant good practice. Upper and lowercase alpha numeric.
07:50:17 <merijn> supki: You know you can set a server password that auto identifies you, right?
07:50:17 <dwcook> The upper case numbers are especially important.
07:50:27 <Ankhers> Indeed.
07:51:35 <ziman_> > map isUpper "ï¼ï¼‘ï¼’ï¼“ï¼”ï¼•ï¼–ï¼—ï¼˜ï¼™"
07:51:35 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
07:52:19 <mr-> [False,False,False,False,False,False,False,False,False,False]
07:52:38 <Ankhers> On US layout keyboards... I would consider "!@#$%^&*()" to be upper case numbers
07:53:06 <applicative> > toUpper '8'
07:53:07 <lambdabot>   '8'
07:53:29 <dwcook> > isUpper . toUpper $ '8' -- :(
07:53:30 <lambdabot>   False
07:54:24 <supki> merijn: yeah, that didn't stop me from typing some unrelated password in though
07:54:31 <Cale> dwcook: What would you expect?
07:55:05 <dwcook> Cale, that's exactly what I expected given the circumstances.
07:55:21 <elliott> supki: I'm going to have nightmares about this happening to me now.
07:55:21 <dwcook> It's just that the name "toUpper" suggests that the thing it returns will be uppercase.
07:55:41 <dwcook> But this isn't always the case. Not a problem, I was just being silly. :P
07:56:17 <Ankhers> OH! seemingly random question I've been meaning to ask... Anyone know the Canadian convention for separating numbers? IE '1,000' '1 000' or '1.000'?
07:56:28 <ziman> > map isUpper "Â¹Â²Â³â´âµâ¶â·â¸â¹â°"
07:56:49 <Cale> Ankhers: comma
07:57:00 * ziman stops being foolish
07:57:15 <Cale> Ankhers: 1,000.00
07:57:23 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
07:57:34 <dwcook> mueval is dying again. :(
07:57:35 <Ankhers> Cale: Are you 100%? I was told recently it would be '1 000.00'
07:57:47 <dpratt71> Cale should know
07:57:55 <Cale> If you were to use a space, nobody would be too confused.
07:58:01 <pjdelport> > toUpper 'â˜¹' == 'â˜º'
07:58:01 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
07:58:21 <Cale> But I happen to be Canadian :P
07:58:22 <applicative> @botsnack
07:58:22 <lambdabot> :)
07:58:27 <merijn> dwcook: mueval has never supported unicode over IRC
07:58:35 <dwcook> Ahh.
07:58:43 <merijn> dwcook: Mostly because there's no sane way to do it
07:58:52 <Ankhers> Cale: So do I... as is the person that told me to use spaces...
07:58:57 <merijn> dwcook: IRC doesn't specify an encoding, so you'd have to guess
07:59:11 <Cale> You could also just use nothing.
07:59:24 <Cale> The important bit is that the decimal point is a period.
07:59:26 <pjdelport> merijn: just assume UTF-8, and don't support anything else?
07:59:33 <Ankhers> Cale: Fair enough, I'm going to stick with the comma.
07:59:37 <applicative> merijn: it should just go by the users intention
07:59:48 <Ankhers> Cale: Thanks.
08:03:23 <Ankhers> Is there a suggested book or anything else to do after reading LYAH or just jump in?
08:03:28 <dpratt71> Ankhers: you might find this useful: http://pic.dhe.ibm.com/infocenter/forms/v3r5m1/index.jsp?topic=%2Fcom.ibm.form.designer.locales.doc%2Fi_xfdl_r_formats_en_CA.html
08:04:32 <Ankhers> dpratt71: That looks really useful, thanks.
08:06:42 <FreeFull_> Ankhers: You could read http://www.haskell.org/haskellwiki/Typeclassopedia or look at http://hackage.haskell.org/package/lens or http://book.realworldhaskell.org/read/  or just jump in and if you encounter something inconvienient, research if someone has created a solution
08:06:45 <elliott> Ankhers: you might find RWH useful
08:06:48 <elliott> though there is some overlap
08:06:56 <FreeFull_> Ankhers: You could also read GHC's docs
08:07:14 <saep> Or try to solve the project-euler riddles :)
08:07:17 <FreeFull_> Or look at what other people have written in Haskell
08:08:02 <pjdelport> Ankhers: pick a project that interests you and see if the bug tracker has anything you can tackle?
08:08:28 <Ankhers> saep: I always do Euler when learning a new language. I've done the first few in Haskell, probably horribly, but that is okay.
08:08:59 <merijn> gah
08:09:11 <Ankhers> elliot, FreeFull, pjdelport: Thanks for the suggestions.
08:09:13 <merijn> Haskell is making me forget to type "return" at the end of functions :(
08:09:27 <merijn> @where exercises -- Ankhers
08:09:28 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
08:09:41 <Ankhers> Ruby did that for me... and right now I have to work in PHP... /sigh
08:10:01 <FreeFull_> Ankhers: You can also look at your old code and see how you can improve it
08:10:03 <merijn> Ankhers: Especially the last two have exercises that are better than project Euler while still being relatively small
08:10:42 <FreeFull> Ankhers: If you really feel up to it you could look at concurrency
08:10:59 <Ankhers> FreeFull: unfortunately, I don't really have 'old code' in Haskell yet.
08:11:45 <Ankhers> Concurrency is something specifically that I wanted to look into. I just do not think I have enough of an understanding yet to want to use it...
08:12:50 <Ankhers> merijn: Thanks for those, I will take a look at them a little later.
08:14:13 <Ankhers> Is there a way to pattern match on the length of a list or should I use a guard for that?
08:14:37 <sipa> lists don't have a length as direct member
08:14:38 <elliott> you generally don't want to take the length of a list, but yes you should use a guard. you could also use a view pattern like xs@(length -> 123), but that's weird
08:14:40 <merijn> Ankhers: Well, you could write out the pattern for list of that length, but in general, use a guard
08:14:45 <latermuse> under what circumstances does "Prelude.read: no parse" usually show up?
08:14:47 <sipa> so you can't pattern match on it
08:15:00 <merijn> > read "foo" :: Int -- latermuse
08:15:02 <lambdabot>   *Exception: Prelude.read: no parse
08:15:09 <elliott> latermuse: evaluating (read s :: t) where s is invalid syntax for the type t
08:15:10 <Ankhers> kk, thanks.
08:15:16 <tac> > parse "234foo" :: Int
08:15:17 <lambdabot>   Not in scope: `parse'
08:15:20 <tac> > read "234foo" :: Int
08:15:21 <lambdabot>   *Exception: Prelude.read: no parse
08:15:29 <latermuse> but this "read" function is working correctly on my dev machine. its only shooting that error when i move to my live server
08:15:31 <merijn> Ankhers: Or better, don't rely on the length of lists :p
08:16:31 <latermuse> i think this is the function where its having problems:
08:16:45 <latermuse> read $ T.unpack x :: Integer
08:16:52 <merijn> latermuse: Use Text.Read.readMaybe if you're using GHC7.6
08:17:11 <latermuse> version 7.0 on live server, version 7.4 on dev machine
08:20:31 <Ankhers> > reads "234foo" :: Int
08:20:33 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:20:33 <lambdabot>              with actual type ...
08:28:20 <merijn> Ankhers: You probably meant
08:28:24 <merijn> > reads "234foo" :: [(Int, String)]
08:28:25 <lambdabot>   [(234,"foo")]
08:29:09 <Ankhers> merijn: Right... I forgot it returns a tuple... thanks!
08:30:25 <phulin> If I have a monad (let's call it Messenger) that i often used wrapped in a transformer, is it reasonable to define the monad's methods inside a typeclass so I don't have "lift"s everywhere?
08:30:40 <phulin> i.e. class Messenger m where message :: String -> m ()
08:30:50 <phulin> instance Messenger MyMonad
08:31:06 <seliopou> phulin: yup
08:31:11 <phulin> instance (MonadTrans t, Messenger MyMonad) => Messenger (t MyMonad)
08:31:20 <phulin> okay
08:31:43 <phulin> seliopou, is it normal for GHC to make me enable a whole bunch of language options
08:31:59 <seliopou> phulin: depends on your code ;)
08:32:08 <phulin> (FlexibleInstances, FlexibleContexts, UndecidableInstances)
08:32:15 <seliopou> but when you're dealing with anything but the simplest type classes, yes
08:32:16 <seliopou> you need those
08:32:17 <seliopou> wait
08:32:25 <seliopou> undecidable instances? whutchudoin?
08:32:56 <applicative> it's really YouDecidableInstances
08:33:03 <seliopou> applicative: :)
08:33:41 <phulin> okay as far as I could tell, GHC made me make the context (Messenger m, MonadTrans t, Monad (t m))
08:33:51 <phulin> that seems weird and unnecessary, so maybe there was a different solution
08:33:56 <phulin> it was yelling about that
08:34:07 <geekosaur> looks right to me
08:34:27 <geekosaur> well, dependong on what exactly you're doing
08:34:29 <seliopou> phulin: check out the instances for MonadReader and MonadState
08:34:37 <seliopou> that'll probably give you a good idea of what needs to be done
08:34:42 <phulin> okay, thanks
08:35:01 <geekosaur> I think the final instance may be implied by MonadTrans unless you have something wrong somewhere else
08:35:02 <phulin> i haven't really done anything nontrivial with typeclasses before, so thanks for the help
08:35:24 <seliopou> erm, or more specifically, MonadWriter
08:35:47 <byorgey> geekosaur: I initially thought that too, but is there really an instance  Monad m, MonadTrans t => Monad (t m) ?  That would overlap with, like, everything
08:36:53 <seliopou> actually, phulin you should check out the MonadWriter type class and see if that'll do it for you
08:37:03 <geekosaur> no, I don't think there's such an instance; I thought it should be inferred from MonadTrans, but that may mean looking at a context when it's not supposed to
08:37:09 <seliopou> see if you can reuse that and write an instance for your particular moand
08:37:53 <socumbersome> Hi. What is happening "internally" with x when I write: let x = f x y in [x] (where f takes 2 arguments)? Is it the case that Haskell allocates memory for a pointer to x and within f I can change or assign some value to x?
08:38:42 <geekosaur> it is not that case
08:38:52 <phulin> geekosaur, that's why i was confusede
08:38:52 <phulin> i have class Monad m => Messenger m
08:38:53 <phulin> and instance (Messenger m, MonadTrans t, Monad (t m)) => Messenger (t m)
08:38:53 <phulin> GHC said "Constraint is no smaller than the instance head" and made me add UndecidableInstances
08:39:07 <geekosaur> there are no magic tricks whereby you can pretend that binding is really just like an imperative language's assignment
08:39:29 <socumbersome> hmm, ok. So what is happening there really?
08:40:39 <fryguybob> socumbersome: If you would like to understand how GHC does this I would recommend reading the STG paper.
08:40:52 <socumbersome> (and is it possible to hide all those notifications that someone has entered or quited from chat? It makes it difficult to read messages.. )
08:41:33 <elliott> yes, in most clients
08:42:07 <socumbersome> ah, ok, I'd better check it :D
08:42:07 <geekosaur> but we'd have to know which client to tell you how to do it in yours
08:42:14 <seliopou> socumbersome: it's a netsplit, even if you could read what's going on, it's not the entire conversation D:
08:44:21 <phulin> seliopou, it looks like the approach MonadWriter takes is to define the instance for all the popular monad transformers, not for MonadTrans in general
08:44:55 <phulin> is my approach evil for some reason? like, is it likely to cause overlaps?
08:45:01 <phulin> i don't really see how it could
08:45:37 <simukis_> phulin: could you repost all your messages before â€œis my approach evil for some reason? like, is it likely to cause overlaps?â€?
08:46:12 <socumbersome> @fryguybob - ok, I'll check STG. But isn't it possible to explain it just more or less? : )
08:46:49 <applicative> it's like salsa verde
08:46:52 <fryguybob> socumbersome: The intuition is that  let  is allocation and  case  is evaluation.
08:47:29 <geekosaur> but it is allocation of an immutable value, not of a mutable  variable cell
08:47:37 <latermuse> what is the cabal package name for Data.Map?
08:47:49 <latermuse> im not finding it with cabal list
08:47:50 <applicative> containers, latermuse, but it comes with ghc
08:47:56 <latermuse> gotcha
08:48:01 <byorgey> phulin: it will overlap if you ever have some data type like  data Foo a b = ...  and you want to make an instance  Messenger (Foo a)
08:48:34 <byorgey> phulin: which is not all that unlikely.
08:48:51 <fryguybob> socumbersome: This might be helpful too: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
08:48:51 <phulin> okay
08:49:05 <phulin> i think i'll just define it with the two transformers i'm using, then.
08:49:10 <byorgey> er, hmm, maybe not, I'm not sure how kinds enter the picture here
08:49:36 <phulin> well, as of now i'm getting an overlap and i don't understand why, byorgey
08:49:49 <byorgey> phulin: what overlap?
08:50:04 <Ankhers> Is anyone else getting disconnected from freenode the past couple days?
08:50:04 <seliopou> phulin: it might help if you put some of your code in pastebin
08:50:13 <phulin> yeah i will give me a minute
08:53:14 <dmwit> ?botsnack?
08:53:33 <Hamidhasan> isUpper 'Â§'
08:53:47 <dmwit> > isUpper 'Â§'
08:53:49 <goodfellow>   False
08:53:56 <dmwit> ?src not
08:53:56 <goodfellow> not True   =  False
08:53:56 <goodfellow> not False  =  True
08:54:20 <pgiarrusso> Question: I'm trying to use the symbol for bottom as identifier, but get parse errors. Yet Emacs claims that it's a Unicode mathematical symbol, so it should be fine
08:54:49 <elliott> it's an operator to Haskell. it'll work if you enclose it in parentheses
08:55:02 <phulin> seliopou, byorgey, http://pastebin.com/3La7CfL0
08:55:08 <mauke> The paste 3La7CfL0 has been copied to http://hpaste.org/89363
08:55:25 <phulin> that should be all the relevant things
08:55:49 <byorgey> phulin: can you also paste the actual error message, please?
08:56:18 <pgiarrusso> elliott: thanks. How could I miss that!
08:56:27 <dmwit> > generalCategory 'âŸ‚'
08:56:28 <goodfellow>   MathSymbol
08:56:39 <FreeFull> > let (âŸ‚) = (âŸ‚) in (âŸ‚)
08:56:41 <goodfellow>   No instance for (GHC.Show.Show a0)
08:56:41 <goodfellow>    arising from a use of `M3913906675930...
08:56:49 <dmwit> > let (âŸ‚) = (+) in 1 âŸ‚ 2
08:56:50 <goodfellow>   3
08:57:04 <FreeFull> :t let (âŸ‚) = (âŸ‚) in (âŸ‚)
08:57:06 <goodfellow> lexical error at character '\159'
08:57:12 <pgiarrusso> > let (âŸ‚) = undefined in (âŸ‚)
08:57:13 <goodfellow>   No instance for (GHC.Show.Show a0)
08:57:13 <goodfellow>    arising from a use of `M2425677497327...
08:57:32 <dmwit> > let (âŸ‚) = undefined in (âŸ‚) :: Int
08:57:33 <goodfellow>   *Exception: Prelude.undefined
08:57:38 <FreeFull> goodfellow seems to have less defaulting than lambdabot
08:57:44 <phulin> byorgey, http://pastebin.com/wJJUyF5q
08:57:50 <mauke> The paste wJJUyF5q has been copied to http://hpaste.org/89364
08:57:54 <phulin> oops
08:58:12 <S11001001> pgiarrusso: if you only care about seeing it, haskell-mode has an option for displaying e.g. undefined as \bot, and you can patch that whichever way or use the same elisp functions yourself
08:58:13 <pgiarrusso> I'm coming back from Agda to haskell and missing some of Agda's flexibility
08:58:29 <dolio> > generalCategory 'ðž´'
08:58:30 <goodfellow>   LowercaseLetter
08:58:39 <dmwit> Yep, Agda is very pretty that way.
08:58:42 <FreeFull> > generalCategory 'â€œ'
08:58:43 <goodfellow>   InitialQuote
08:58:49 <pgiarrusso> S11001001: yeah, but I was trying to also type less
08:59:02 <byorgey> phulin: ah, it's even worse than I thought.
08:59:02 <S11001001> pgiarrusso: abbrev-mode :)
08:59:11 <pgiarrusso> but I guess I should just use some type-less facility (like abbrev-mode indeed)
08:59:20 <byorgey> phulin: Symbolic = State SymbolicState = StateT SymbolicState Identity
08:59:32 <byorgey> phulin: so your  Messenger (t m)  instance matches
08:59:43 <phulin> right, but Identity isn't a messenger
08:59:51 <byorgey> indeed.
08:59:52 <pgiarrusso> S11001001: since you seem to be experienced with Emacs, do you happen to know how much ghci-in-emacs likes unicode?
09:00:01 <dmwit> phulin: instance heads are ignored when checking whether an instance matches.
09:00:02 <phulin> byorgey, I guess I don't understand how GHC does typeclass checking
09:00:04 <byorgey> phulin: this is why you can't give a single  Messenger (t m) instance.
09:00:47 <byorgey> phulin: did you understand what I wrote above?  (Symbolic = ...)
09:00:53 <pgiarrusso> S11001001: I get "parse error" when typing ":t toBagâ„¤" in emacs's ghci interface, not in ghci's prompt directly
09:00:58 <phulin> yeah, I understand that :)
09:01:15 <byorgey> phulin: and do you understand why the  Messenger (t m)  instance matches?
09:01:20 <dmwit> phulin: So first it sees that "t m" matches, then afterwards (once it's already committed to this instance) it will check whether "Messenger m, MonadTrans t, Monad (t m)" are satisfiable and error out if not.
09:01:22 <phulin> yeah.
09:01:27 <dmwit> oh, okay
09:01:31 <byorgey> phulin: so what don't you understand? =)
09:02:09 <byorgey> phulin: oh! wait.
09:02:16 <phulin> i guess i understand why it fails, i just wish it wouldn't
09:02:24 <phulin> it seems like it's avoidable
09:02:41 --- topic: '["Haskell Platform 2013.2: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down, try: http://hdiff.luite.com "]'
09:02:41 --- topic: set by shachaf!~shachaf@unaffiliated/shachaf on [Tue May 28 01:16:22 2013]
09:02:43 <byorgey> phulin: the solution is that you have to make Symbolic a newtype.
09:03:01 <phulin> ohhh
09:03:03 <byorgey> then you can also keep your  Messenger (t m)  instance (though you might still run into problems with it later).
09:03:35 <phulin> yeah i think i will forget the general approach and just write specific instances for the two transformers i'm wrapping around symbolic
09:03:49 <S11001001> pgiarrusso: emacs seems to send the right codes but ghci uses the wrong coding system for stdin/out
09:03:55 <byorgey> phulin: newtype Symbolic a = Symbolic { unSymbolic :: State SymbolicState a }  deriving (Functor, Applicative, Monad, MonadState SymbolicState)
09:04:08 <S11001001> pgiarrusso: don't know how to set that; I always use LC_ALL=en_US.UTF-8 in env
09:04:13 <phulin> wait you can actually just derive all that?
09:04:17 <phulin> if it's that easy...
09:04:20 <byorgey> phulin: yes, with GeneralizedNewtypeDeriving
09:04:31 <pgiarrusso> S11001001: so you've seen the issue and managed to fix that, right?
09:04:32 <dmwit> ghc++
09:04:54 <S11001001> pgiarrusso: haven't seen the issue
09:05:36 <S11001001> pgiarrusso: 'cause emacs showing things in big chars doesn't mean they actually are big chars
09:05:46 <latermuse> is there any way to cast "123" as an Integer 123 without using read?
09:07:25 <latermuse> nevermind, just found a workaround
09:07:36 <phulin> oh byorgey, the only issue is that i've been using transformers, not mtl
09:07:54 <byorgey> phulin: ok, why is that an issue?
09:08:00 <phulin> no MonadState
09:08:08 <byorgey> OK, that's fine
09:08:12 <byorgey> so don't derive MonadState
09:08:20 <phulin> yeah it just makes it more annoying
09:08:22 <byorgey> if you don't need it, you don't need it.
09:08:23 <phulin> i know i'm whining
09:08:30 <byorgey> well why not use mtl?
09:08:34 <dmwit> ...if you need it, use mtl.
09:08:39 <byorgey> note mtl just re-exports transformers + some other stuff.
09:08:50 <dmwit> Hell, if you *want* it, use mtl.
09:08:50 <byorgey> it's not like they're incompatible or something.
09:09:04 <phulin> okay i was getting dependency issues because my libraries used transformers
09:09:08 <phulin> maybe i was just confused
09:09:13 <FreeFull> How could I simplify this ugly beast?   concat . zipWith (\y -> map (zip (zip [y,y..] [0..]))) [0..] . (:[])
09:09:19 <byorgey> you might need to list both transformers and mtl as dependencies.
09:09:22 <phulin> i was under the impression you couldn't use both but clearly i was wrong
09:09:29 <byorgey> but that's fine.
09:09:39 <dmwit> :t concat . zipWith (\y -> map (zxp (zip [y,y..] [0..]))) [0..] . (:[])
09:09:40 <lambdabot>     Not in scope: `zxp'
09:09:41 <goodfellow>     Not in scope: `zxp'
09:09:41 <goodfellow>     Perhaps you meant one of these:
09:09:41 <goodfellow>       `exp' (imported from Prelude), `zip' (imported from Data.List),
09:09:41 <lambdabot>     Perhaps you meant one of these:
09:09:41 <lambdabot>       `exp' (imported from Prelude), `zip' (imported from Data.List),
09:09:49 <dmwit> Oh, hi lambdabot!
09:09:51 <dmwit> goodfellow: ?quit
09:09:59 <dmwit> :t concat . zipWith (\y -> map (zip (zip [y,y..] [0..]))) [0..] . (:[])
09:10:00 <lambdabot> (Enum b1, Enum a, Num a, Num b1) => [[b]] -> [[((a, b1), b)]]
09:10:18 <dolio> > generalCategory 'ðœ†'
09:10:19 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
09:10:27 <dolio> Awesome.
09:10:32 <FreeFull> > concat . zipWith (\y -> map (zip (zip [y,y..] [0..]))) [0..] . (:[]) $ ["Hello","There"]
09:10:34 <lambdabot>   [[((0,0),'H'),((0,1),'e'),((0,2),'l'),((0,3),'l'),((0,4),'o')],[((0,0),'T')...
09:10:51 <FreeFull> Waait
09:10:54 <FreeFull> It doesn't even do the right thing
09:11:01 <byorgey> hehe
09:11:16 <dolio> I wonder what lambdabot's doing. That just worked on goodfellow.
09:11:29 <dmwit> dolio: I think lambdabot runs in an environment with a different locale.
09:11:35 <dolio> Ah.
09:11:46 <dmwit> It's my best hypothesis so far.
09:11:51 <supki> > ["Hello","There"] ^@.. icompose (,) itraversed itraversed
09:11:52 <lambdabot>   [((0,0),'H'),((0,1),'e'),((0,2),'l'),((0,3),'l'),((0,4),'o'),((1,0),'T'),((...
09:12:08 <FreeFull> supki: Good enough for what I need
09:12:45 <FreeFull> I didn't even think of lenses
09:12:50 <byorgey> > zipWith zip [[(i,j) | i<-[0..]] | j<-[0..]] ["Hello", "There"]
09:12:51 <lambdabot>   [[((0,0),'H'),((1,0),'e'),((2,0),'l'),((3,0),'l'),((4,0),'o')],[((0,1),'T')...
09:13:02 <byorgey> oh, mine is backwards
09:13:04 <byorgey> but you get the idea
09:13:22 <FreeFull> byorgey: Perfect
09:13:38 <byorgey> there might even be a nicer way to do that list comprehension
09:14:18 <phulin> byorgey, dmwit, perfect. thanks for the help!
09:14:24 <FreeFull> I don't actually need the result to have each bit as a separate list though, so supki's is good too
09:15:24 <dmwit> byorgey++
09:15:41 <elliott> :t zipWith zip
09:15:42 <lambdabot> [[a]] -> [[b]] -> [[(a, b)]]
09:15:52 <elliott> cute
09:15:58 <elliott> and obvious in retrospect
09:16:24 <byorgey> zipWith is fmap2
09:16:52 <dmwit> zipWith is (<*>)
09:17:03 <dmwit> Applicatives are types with n-ary zips.
09:17:04 <merijn> Is it Freenode DDOS day again?
09:17:12 <FreeFull> merijn: Yes
09:17:30 <dmwit> ...in the grand spirit of "monads are boxes".
09:18:00 <osa1> is type of this exception `IOException`: "Exception: Data.Vector.Mutable: uninitialised element" ?
09:18:13 <joelteon> A monad is a datatype with return and >>= defined
09:18:34 <byorgey> > let is2 = map repeat [0..]; zz = zipWith zip in  zz (zz is2 (transpose is2)) ["Hello", "there"]
09:18:35 <lambdabot>   [[((0,0),'H'),((0,1),'e'),((0,2),'l'),((0,3),'l'),((0,4),'o')],[((1,0),'t')...
09:19:13 <elliott> dmwit: it's pretty funny that that analogy is based on an instance we don't have.
09:19:46 <dmwit> Is that funny?
09:19:59 <dmwit> Oh, I guess you thought I based that analogy on ZipList. Yeah, that is funny.
09:20:06 <dmwit> There's no Applicative instance for ZipList?
09:20:12 <byorgey> of course there is
09:20:20 <byorgey> there's no Monad instance though.
09:20:29 <applicative> it's the only instance ...
09:20:33 <dmwit> i am confuse
09:20:36 <byorgey> > let is2 = map repeat [0..]; zz = zipWith zip in  is2 `zz` transpose is2 `zz` ["Hello", "there"]
09:20:38 <lambdabot>   [[((0,0),'H'),((0,1),'e'),((0,2),'l'),((0,3),'l'),((0,4),'o')],[((1,0),'t')...
09:20:39 <elliott> dmwit: I mean that the analogy for zips would suggest a zippy Applicative insatnce for []
09:20:43 <elliott> *analogy of
09:20:47 <dmwit> oh
09:21:02 <elliott> and indeed, that's the first instance introduced in the original idioms paper
09:21:18 <FreeFull> dmwit: Monads are obviously spacesuit burritos
09:22:32 <dmwit> Well, I based my analogy on my Applicative instance for square matrices that I never finished writing up. And that's not funny at all! =P
09:23:30 <joelteon> monads *are* burritos though
09:24:01 <Luke> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/GHC-MVar.html what are these # marks all over the source code here?
09:24:02 <joelteon> just a burrito with return :: a -> burrito a and (>>=) :: burrito a -> (a -> burrito b) -> burrito b
09:24:23 <Ankhers> Where did this burrito analogy come from?
09:24:51 <dmwit> It's a joke.
09:25:02 <Ankhers> I know, I'm just wondering how it started.
09:25:14 <joelteon> I think it's from the monad tutorial fallacy post
09:25:47 <elliott> the burrito thing is past its expiry date I think
09:25:59 <elliott> Luke: they mean "unboxed" or "GHC internal"
09:26:06 <elliott> also, that's an old version of the source, fwiw
09:27:00 <joelteon> yeah expired burritos are nasty
09:27:21 <Luke> elliott: is that just part of the variable name by convention or is that enfored by the compiler?
09:27:50 <osa1> uh, is there a way to catch `error` ?
09:28:03 <osa1> I think Data.Vector calls `error` when uninitialized elements are accessed
09:29:09 <elliott> Luke: in syntax like unboxed integer literals 0# and unboxed tuples (# a, b #) it is syntax; in names like foo# it is convention (foo# is not a valid name in standard Haskell, it is a GHC extension (MagicHash) to allow it)
09:30:30 <applicative> in io of course there is osa1 error s = throw (ErrorCall s)
09:30:42 <Luke> so MVar# comes from MagicHash?
09:31:12 <elliott> yes
09:31:18 <Luke> ok thanks!
09:31:32 <elliott> and usually stuff named that way is built into GHC
09:31:34 <elliott> i.e. no source code
09:31:44 <elliott> (no vaguely Haskell-ish source code)
09:32:08 <mm_freak> is there an xquery library?  i don't need a parser, just a DSL + compiler
09:33:34 <osa1> ok so am I missing something or Data.Vector really doesn't give users any way to check in an index is initialised, but when accessed an uninitialized element calls `error` ??
09:33:54 <osa1> s/in/if
09:34:12 <geekosaur> uninitialized is generally problematic in haskell, since it's typically bottom and impossible to test for
09:34:23 <Benzi-Junior> is it possible to make a data constructor for something containing items (i.e. lists or trees etc.) without the empty instance (like [] or N)?
09:34:55 <applicative> Benzi-Junior: put just like that, no
09:35:03 <osa1> and for some reason I can't even handle that `error` call, catch (\(e :: SomeException) ..) .. doesn't work
09:35:25 <applicative> if one thing of a type can follow a constructor, so can another.
09:36:36 <applicative> Benzi-Junior: a typical expedient is to 'hide' the definition of the type, exporting means that will permit only the nice cases
09:37:03 <applicative> Benzi-Junior: the other is swank type hackery, though it would depend what you want exactly
09:37:14 <Luke> elliott: http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/primitives.html#glasgow-unboxed
09:37:20 <Luke> thanks for helping me
09:37:49 <applicative> Benzi-Junior: but maybe i'm so far saying the obvious
09:38:44 <mm_freak> osa1: the 'error' may be triggered outside of the actionâ€¦  see 'evaluate'
09:39:02 <Benzi-Junior> applicative: so I can't make a constructor for a tree that MUST contain a value in every leaf
09:39:23 <mm_freak> osa1: also there is no "uninitialized" in haskellâ€¦  there is "defined" vs. "bottom"
09:39:38 <mm_freak> to get "does not currently have a value", you can have something like Vector (Maybe X)
09:40:12 <osa1> mm_freak: of course there are workarounds like Vector (Maybe X),
09:40:28 <osa1> one reason I'm trying to do this way is learning
09:41:30 <mm_freak> osa1: your mistake is to see Maybe as a "workaround"
09:41:39 <osa1> hmm
09:43:27 <osa1> it's still strange. `new` function in vector package creates a vector full of `bottom` values, and then doesn't provide a way to distinguish bottom vs. defined. maybe it should have create a vector with some default value and doesn't provide a function to define with bottom values ...
09:44:06 <mm_freak> osa1: that's because typically you wouldn't use 'new'
09:44:50 <dolio> You would for mutable vectors.
09:44:52 <osa1> mm_freak: well I'm just learning this here, it's not written anywhere in documentation that I shouldn't use new or otherwise can't distinguish buttom values ...
09:45:05 <osa1> and yes, I'm using mutable vectors
09:45:12 <dolio> But vector isn't designed for sparse vectors.
09:45:38 <mm_freak> osa1: may i ask what algorithm you're trying to implement?
10:00:15 --- mode: cameron.freenode.net set +o ChanServ
10:00:34 <FreeFull> Ok, seems I won't have access to lenses
10:00:36 <nooodl> FreeFull: how so?
10:00:36 <mm_freak> hidenori: i still recommend criterion, because it saves you from having to run the program 100 times manually to get a representative result
10:00:36 <hidenori> applicative: i see. thank you! its really simple :)
10:01:17 <hidenori> mm_freak: ohh i see. what does criterion do?
10:02:49 <mm_freak> hidenori: you give it a function/action and a result evaluation strategyâ€¦  it then performs repeated benchmarks and gives you statistics (high peak, low peak, average running time, deviation, etc.)
10:04:52 <hidenori> mm_freak: sounds very cool but it may be challenging to me. is it difficult to start?
10:06:31 <mm_freak> hidenori: where you would write "timeit (f x)" you write:  defaultMain [bench "blah" (nf f x)]
10:06:53 <mm_freak> and yes, you can have multiple benchmarks in that list
10:07:45 <applicative> i think the timeit function is just a simple expedient to get around it that on windows there is no simple expedient like unix time
10:08:59 <mm_freak> (the "blah" is just a benchmark name that is printed along with its stats + allows you to refer to benchmarks from the command line interface that defaultMain provides; import Criterion.Main instead of Criterion)
10:09:06 <applicative> in powershell there are simple expedients it is seeming from the internets
10:09:28 <hidenori> mm_freak: do i need to down load criterion-0.8.0.0.tar.gz (Cabal source package)?
10:09:34 <c_wraith> well, Powershell is where they've done all their work in the last 20ish years
10:09:54 <c_wraith> CMD hasn't been touched in a long time
10:11:00 <applicative> hidenori: do you have cabal.exe ?
10:11:49 <hidenori> applicative: I only have downloaded haskell platform
10:11:56 <mm_freak> hidenori: cabal install criterion
10:12:24 <geekosaur> hidenori: haskell platform includes cabal
10:12:26 <applicative> like mm_freak says
10:13:12 <applicative> do you by default type 'cabal.exe install criterion' in the windows console
10:13:19 * applicative cant remember a thing
10:13:38 <geekosaur> extension shouldn't be necessary
10:14:09 <applicative> hidenori: so like mm_freak said. it has a lot of dependencies but they are all wholesome anyway
10:15:03 <hidenori> i finally found cabal.exe install criterion but i have no idea what to do with it...
10:16:00 <applicative> the platform installer should make cabal.exe in path so typing 'cabal install criterion' in the terminal window should work
10:16:29 <applicative> probably 'cabal update' first; do you have the new haskell platform by the way
10:17:50 <hidenori> aww i was confused "cabal" with "cabal.exe install criterion". i typed "cabal.exe install criterion" on my GHCi but it says "install, criterion, exe" are all not in scope
10:17:59 <applicative> haha
10:18:11 <applicative> just in the plain windows cmd terminal thingy
10:18:20 <applicative> type 'cabal update' which will take a minute
10:18:43 <applicative> then type 'cabal install criterion' which will take a minute for another more perceptible reason
10:19:28 <applicative> or maybe first 'cabal install criterion --dry-run' first; this will tell you if there will be some kind of chaos and what will happen
10:19:45 <Hafydd> :t cabal.exe
10:19:47 <lambdabot> Not in scope: `cabal'
10:19:47 <lambdabot>     Not in scope: `exe'
10:19:47 <lambdabot>     Perhaps you meant `exp' (imported from Prelude)
10:19:55 <hidenori> hmm i should type it on GHCi? when i typed "cabal update" my ghci says "not in scopre cabal"
10:19:57 <applicative> :t cabal.exe install criterion
10:19:59 <lambdabot> Not in scope: `cabal'
10:19:59 <lambdabot>     Not in scope: `exe'
10:19:59 <lambdabot>     Perhaps you meant `exp' (imported from Prelude)
10:20:12 <applicative> type :q in ghci first ;)
10:20:36 <applicative> how are you entering ghci?
10:20:43 <Hafydd> (Actually, :!cabal.exe install criterion might work in ghci).
10:20:46 <hidenori> ohh i typed ":q cabal update" on my GHCi and my GHCi disappeared
10:20:56 <mauke> good
10:21:01 <mauke> you're not supposed to be running ghci
10:21:38 <applicative> hidenori: I didn't know how you were enter ghci, but now you are in the plain console and use cabal
10:21:52 <applicative> how were *entering* ghci rather
10:22:00 <mm_freak> there is winghci, which is runs standalone, outside of windows' shell
10:22:05 <mauke> applicative: that doesn't necessarily follow
10:22:14 <applicative> yes it doesnt necessarily
10:22:25 <mm_freak> likely hidenori was running that, which explains why it disappeared after :q
10:22:26 <applicative> is winghci what you get with haskell platform
10:22:27 <hidenori> hmm so should i open ghci again..?
10:22:32 <mm_freak> applicative: yes
10:22:33 <mauke> hidenori: no
10:22:38 <mm_freak> in the start menu
10:22:41 <applicative> how did you open it before?
10:22:41 <mauke> hidenori: stop trying to use ghci
10:22:49 <mm_freak> or whatever it's called in today's windowses
10:22:55 <applicative> hidenori: cabal install has nothing to do with ghci
10:23:06 <applicative> geekosaur always knows all shells
10:23:06 <mm_freak> hidenori: in other words, you should find the command line of your windows =)
10:23:28 <mm_freak> hidenori: if all else fails you can select "run application" and type "cmd" somewhere in your start menu
10:23:28 <geekosaur> not really
10:23:36 <applicative> they hide it a bit, like on a mac
10:23:38 <hidenori> @.@ im confused lol
10:23:38 <lambdabot> Maybe you meant: . @
10:23:47 <mauke> hidenori: step 1: stop laughing
10:23:54 <mm_freak> hidenori: never worked on the command line before?  never typed "dir"?
10:24:01 <mm_freak> or "cd" or â€¦
10:24:18 <applicative> chdir isn't it?
10:24:28 <hidenori> ive never done that
10:24:39 <mm_freak> you would think that, but windows actually only provides the abbreviations for most commands
10:24:53 <mauke> applicative: no
10:24:58 <applicative> hidenori: this is unfortunately a highly unixy channel; or fortunately or whatever; advice about windows tends to be a little speculative
10:25:01 <mm_freak> hidenori: ok, first step:  learn to use the command lineâ€¦  you will need it for haskell development
10:25:10 <mauke> hidenori: which version of windows are you using?
10:25:28 <hidenori> mauke: im using windows 7
10:25:29 <mm_freak> hidenori: (strictly speaking you don't need it, but it's very difficult to get around it)
10:25:31 * applicative figured out command lines exactly the way hidenori is, improbably
10:26:16 <mauke> IIRC the easiest way to open a console window on win7 is to hit the windows key to open the start menu, then type "cmd" into it
10:26:19 <hidenori> applicative: i see. mb i should try unix sometime soon
10:26:19 <mauke> then <enter>
10:26:38 <applicative> hidenori: don't worry this is pretty simple.
10:27:49 <mm_freak> hidenori: the command line is a 'shell', although i hardly consider the windows command line a real shellâ€¦  that's why i call it "command line"
10:28:13 <applicative> it's perfectly good for 'cabal install criterion'
10:28:26 <mm_freak> in any case it's the traditional way to navigate directories and start programsâ€¦  you should learn the basics of the shell
10:28:36 <mauke> the windows GUI (explorer) is also a shell
10:28:50 <hidenori> hmm i typed cmd and sth opened. is this "console window"?
10:28:56 <applicative> YES
10:29:00 <mm_freak> hidenori: there you go =)
10:29:02 <FreeFull> Development on Windows is a pain
10:29:03 <applicative> FINALLY A COMPUTER
10:29:20 <applicative> now type 'cabal update' and see what happens hidenori
10:29:37 <hidenori> ok i'll try
10:30:15 <hidenori> it says "downloading the latest package list from hackage.haskell.org
10:30:26 <applicative> awesome, just like it does on my computer
10:30:53 <hidenori> ohh i see. thank you guys :)
10:31:07 <applicative> note for future reference that you can also call ghci from this terminal, by typing 'ghci'
10:31:58 <hidenori> ohh i see.
10:32:01 <applicative> and you can also of course compile by typing 'ghc my.hs' and so on
10:32:17 <FreeFull> Does ghci on windows do readline yet/
10:32:18 <FreeFull> ?
10:32:23 <applicative> then run the resulting executable by typing  my.exe
10:32:29 <applicative> ghci uses haskeline
10:32:37 <FreeFull> Ah, should be good then
10:32:46 <hidenori> i see. i'll try later :)
10:33:32 <applicative> you should look up the simple windows command line commands, so you can navigate to a directory with your haskell modules compile run delete them, etc
10:33:49 <hidenori> now i can type "cabal.exe install criterion"?
10:34:02 <mauke> I don't think you need the ".exe" part
10:34:09 <applicative> type cabal install criterion --dry-run
10:34:20 <mauke> ooh, there's a --dry-run option?
10:34:25 <applicative> just to make sure no chaos will happen
10:34:33 <applicative> mauke: am i hallucinating? it happens
10:35:33 <dpratt71> I use --dry-run all the time
10:35:38 <applicative> if it doesn't complain about things, then do 'cabal install criterion'
10:35:41 <hidenori> okay, i'll try to learn command line commands.
10:38:10 * hackagebot quickcheck-assertions 0.1.1 - HUnit like assertions for QuickCheck  http://hackage.haskell.org/package/quickcheck-assertions-0.1.1 (AlekseyUymanov)
10:42:31 <hidenori> applicative: after typing "cabal install criterion" its been downlading, compiling for 5 mins ish. is it alright?
10:42:45 <applicative> yes
10:42:55 <applicative> it is telling you what it is doing?
10:43:17 <hidenori> now it says compiling criterion.IO
10:43:27 <applicative> we are close to the end then
10:43:57 <hidenori> it seems to be done.
10:43:57 <applicative> it downloaded the other packages criterion depends on, installed them, and now is installing criterion itself
10:44:11 <hidenori> got it
10:44:14 <applicative> now the criterion library is installed.
10:44:40 <applicative> if you do 'ghc-pkg list' you will see criterion and some other packages listed -- after those that came with the haskell platform
10:45:43 <lcfrs> stepcut: Is acme the new HTTP server built with pipes?
10:46:13 <applicative> lcfrs: haha, no way
10:46:23 <applicative> its called 'hyperdrive' or something
10:46:43 <hidenori> applicative: i see a lot of stuffs  like vector-binary-instances
10:46:52 <applicative> hidenori: excellent.
10:47:01 <applicative> hidenori: now look at https://github.com/bos/criterion/blob/master/examples/Fibber.hs
10:47:01 <lcfrs> Right, that sounds more familiar.
10:47:25 <applicative> lcfrs: i think some version was on darcs hub or somewhere
10:48:17 <lcfrs> applicative: Yeah, I read development was halted waiting for pipes-parse. What's acme then?
10:48:20 <applicative> http://hub.darcs.net/stepcut/hyperdrive but it hasn't been edited lately
10:48:53 <applicative> isn't acme like the worlds fastest pong server or something?
10:50:03 <applicative> hidenori: the Fibber.hs file is the swank criterion version of the http://codepad.org/TFdaLwRa I showed you before, speaking crudely
10:50:32 <hidenori> applicative: i just tried the one from github and it shows a lot of results.
10:50:34 <lcfrs> applicative: Yes, yes it is. I was reading the web server benchmarks at http://www.techempower.com/blog/2013/05/02/frameworks-round-4/, and was a little surprised the Haskell frameworks scored as low as they did.
10:51:44 <hidenori> appicative: i see. this has way more info than timeIt.
10:51:50 <applicative> yes, it is measuring how long 'fib' and 'fac' and 'fio' take for various sizes of arguments.
10:52:07 <applicative> hidenori: yes, it's more sophisticated in a million ways, of course
10:52:50 <applicative> but for example, if you had several implementations of the same function, and wanted to see which is fastest, this would be a way.
10:53:44 <applicative> rather than fib and fac you'd have as it were fib1 fib2 fib3 or euler400a euler400b euler400c, to see how much time each takes
10:56:25 <hidenori> applicative: i see.
10:57:04 <hidenori> thank you guys for a lot of help =)
11:01:50 <yogert> To use cabal-dev with GHCI, do I need to package my source first
11:01:51 <yogert> ?
11:02:05 <yogert> it appears to be that way...
11:05:35 <mauke> anyone here going to HaL8?
11:07:57 <applicative> @tell hidenori http://hpaste.org/89371
11:07:57 <lambdabot> Consider it noted.
11:09:18 <Cread_> On ArchLinux ARM there are ghc packages for the armv5 and armv7 architecture. Does anybody know why there is no one for the armv6 architecture? Is it the lack of time/interest or are there any building problems?
11:09:29 <merijn> Does anyone here use let/in (frequently)?
11:09:51 * applicative is disgusted by it frequently
11:09:58 <merijn> If yes, could you pastebin some "typical" uses/layouts you use it with?
11:10:23 <merijn> applicative: Me too, hence I have no clue how I should deal with indenting it. Just saying "No autoindent for let/in" seems a bit harsh :p
11:10:49 <merijn> Cread_: Probably lack of manpower/time
11:11:16 <supki> merijn: http://hpaste.org/89374
11:13:02 <merijn> supki: Yeah, I was afraid of that, that's a tricky layout to do
11:13:34 <dmwit> http://hpaste.org/89375 <- styles I have used
11:22:17 <lpsmith> preflex: seen joeya
11:22:17 <preflex>  joeya was last seen on #haskell 3 days, 20 hours, 12 minutes and 48 seconds ago, saying: Hence you'll need MonadBaseControl m or such
11:23:15 <w3pm> what channel should I go to to discuss grammars?
11:25:08 <w3pm> well ok here goes? I'm trying to understand grammars and write a recursive-descent parser, but if I have a rule of the form A-> B | BA, how can it know which production to use?
11:25:32 <w3pm> A -> B | e is more clear but then I was reading things about removing epsilon productions, etc.. not sure why, exactly
11:25:51 <w3pm> err A -> BA | e
11:27:34 <merijn> supki, dmwit: I take I can safely ignore the "= let\n {- indented definitions here -}" case? (and similar for -> let and <- let)
11:28:12 * hackagebot notmuch-web 0.1.1 - A web interface to the notmuch email indexer  http://hackage.haskell.org/package/notmuch-web-0.1.1 (JohnLenz)
11:31:52 <supki> merijn: I've never seen these but who knows..
11:32:49 <merijn> supki: Well, by "safely ignore" I mean "tell people who use that style to suck it and deal with it not being supported" :p
11:33:12 * hackagebot ghc-parmake 0.1.3 - A parallel wrapper for 'ghc --make'.  http://hackage.haskell.org/package/ghc-parmake-0.1.3 (MikhailGlushenkov)
11:34:23 <merijn> Semi-relatedly, I guess there's no way sane way to encode "arbitrary string that doesn't contain 'foo'" in a regex other than "([^f]|f[^o]|fo[^o])*"
11:34:59 <Peaker> merijn, so did you toy with lamdu?
11:34:59 <mauke> merijn: ^(?s)(?!.*foo)
11:35:17 <geekosaur> only in pcre, not posix regex...
11:35:29 <geekosaur> I believe the platform only includes posix
11:35:56 <merijn> I think vim only does posix, so it doesn't matter
11:36:11 <mauke> vim doesn't do posix
11:36:23 <merijn> Peaker: A little, neat improvements since last time I used it :)
11:36:26 <Botje> and regexps suck at negated matches :]
11:36:38 <merijn> Botje: I know, but it's all I have at my disposal
11:36:38 <mauke> merijn: ^\%(\_.*foo\)\@!
11:36:40 <mauke> vim syntax
11:37:22 <geekosaur> ick
11:37:24 <Peaker> merijn, cool :)  one really really nice feature in lamdu now, is that if you have some hole of type: a -> { x : Int, y : Int}       you can just press <return> on it and you get:  \<some free var name> -> { x : <hole>, y : <hole> }    all inserted already
11:37:30 <merijn> mauke: I'm now picturing you in a necromancer robe surrounded by candles and skulls
11:37:46 <Peaker> merijn, and holes are numbered alt-<0..9> so you can reach any of them with a single key press :)
11:38:18 <merijn> Peaker: Cool, I'll play with that later today (depending on how well my other project goes :p)
11:39:55 <dpratt71> Peaker: lamdu is not Haskell, correct?
11:40:27 <Peaker> dpratt71, right, but similar
11:40:47 <Peaker> dpratt71, once you throw away the textual language and design a structural IDE, some of the trade-offs are different and some of Haskell's decisions no longer make sense
11:41:09 <Peaker> so it makes sense to change the language to better fit the medium
11:41:26 <dpratt71> Peaker: what sort of things no longer make sense?
11:41:50 <Peaker> dpratt71, for example, currying is a very useful technique for concise partial application, but it comes at the expense of having named arguments at application sites
11:42:30 <Peaker> dpratt71, with structural editing, we can have both concise partial applications, and named arguments at the application sites, without having to spell the names out and with allowing the names to form less visual noise with various visual techniques (e.g: less contrasted color, small font)
11:43:17 <Peaker> dpratt71, so we don't really need currying as a first-class citizen notationally, so left-associativity no longer makes sense for function application, because currying is rare, and ordinary application chains ( f (g (h x)) ) are common
11:43:44 <dpratt71> very interesting
11:43:51 <dpratt71> I'll have to check it out
11:44:06 <dpratt71> is lamdu non-strict?
11:44:22 <Peaker> dpratt71, it doesn't execute yet, heh
11:44:29 <Peaker> dpratt71, so there are no execution semantics
11:44:35 <dpratt71> Peaker: oh, very non-strict then :)
11:44:38 <Peaker> :)
11:44:46 <tdammers> maximum laziness
11:44:50 <Peaker> it does type-infer on the fly, though
11:45:36 <Ralith> "on the fly"?
11:46:02 <tdammers> in order to define and implement the language, you need to trigger evaluation of an actual program fragment
11:46:20 <Guest23239> does anyone know what happened to comonad.com?
11:46:24 <Ralith> Peaker: ooh, you're doing a structural editor?
11:46:31 <Peaker> Ralith, yeah
11:46:42 <Ralith> awesome
11:46:56 <Peaker> Ralith, https://github.com/Peaker/lamdu  :)
11:47:04 <Ralith> you should come do one for idris instead! :D
11:47:05 <dpratt71> important question: it looks like I should pronounce it lam-doo, but I suppose lam-duh is the intension, yes?
11:47:25 <Peaker> Ralith, Idris and Haskell both make the trade-offs I mentioned above...
11:47:35 <Peaker> dpratt71, we say lam-doo
11:47:45 <dpratt71> oh, ok
11:47:50 <Peaker> but we were worried that if it were spelled "lamdoo" people would figure it's object-oriented
11:47:57 <dpratt71> :)
11:48:04 <Ralith> Peaker: idris is open to alternative syntaxes
11:48:40 <Ralith> the important part--the core type theory--is unaffected
11:48:43 <Peaker> Ralith, well, we're implementing the type system from scratch, and since we've got enough innovation on our hands, we're sticking to simple non-DT at first..
11:49:05 <Ralith> Peaker: ah, but that's the great thing about using idris; the type system already works!
11:49:11 <Ralith> you can just drop it in.
11:49:35 <Peaker> Ralith, I think we tried looking at Idris's API too, and we didn't find an API that actually was like what we need
11:49:41 <Peaker> (we looked at a bunch of API's)
11:50:26 <Ralith> Peaker: idris's IDE support API is only just beginning, and I doubt it existed at all when you looked; it's hardly set in stone, nor will it be for some time.
11:50:49 <Ralith> your input would be nice to have
11:51:12 <Ralith> and certainly extension can be easier than building from scratch
11:51:20 <Peaker> Ralith, basically we'd want it to match the general structure of our annotated expressions, see: https://github.com/Peaker/lamdu/blob/master/src/Lamdu/Data/Expression.hs
11:52:11 <Ralith> alternate high level representations should not be hard to add
11:52:40 <Peaker> Ralith, also, we need real-time inference that is fast.. and for slow inference parts (e.g: DT normalizations) we need async support. And we need to be able to type check "continuations" (e.g: set subexpression into something else, see if it still type-checks without re-doing all the work)
11:53:15 <bitonic> Peaker: wait a second are you writing lambdu in your own language?
11:53:18 <Peaker> but currently we're optimizing the UI around the "edit values, infer types" model, and the DT model seems to more be around: "edit rich types, infer much of the value"
11:53:25 <Peaker> bitonic, lamdu is implemented in Haskell
11:53:42 <bitonic> Peaker: OK, there seemed to be PL implementation talk around here
11:53:46 <Peaker> bitonic, the language lamdu implements is not complete, but it's very similar to Haskell
11:53:56 <Ralith> Peaker: it's more that in DT your procedures for handling types vs values are the same
11:54:26 <w3pm> Projucer
11:54:26 <bitonic> Peaker: so the language to extend the editor?
11:54:30 <Peaker> Ralith, it's harder to infer as much, so the model of editing mostly just the values and getting the types from that won't work as well (which is OK, but our UI is already heading in that direction ATM)
11:54:38 <Peaker> bitonic, there's no language to extend the editor :)
11:54:42 <Peaker> (yet, it will be lamdu)
11:54:43 <Ralith> Peaker: idris can, and in some cases ultimately must, support most of the features you list
11:55:03 <bitonic> Peaker: then I donâ€™t understand where the â€˜languageâ€™ you are talking about fits
11:55:11 <Ralith> Peaker: simple types, such as most of what you'll be using as is, are theoretically inferrable even in DT.
11:55:29 <Peaker> Ralith, how much inference does the Idris type system do?
11:55:39 <Ralith> Peaker: that depends what exactly you mean by inference
11:55:45 <Ralith> mostly Idris does unification
11:56:08 <Ralith> it could do inference for many cases, but that hasn't yet been implemented for most because unification is generally more than enough.
11:56:12 <Peaker> bitonic, lamdu aims to implement a language similar to Haskell (well, no sum/recursive types yet or pattern matching) and a UI to edit it far more efficiently than a text editor
11:56:35 <tac> Ralith: (personally, I'd rather have too little inference than too much)
11:56:42 <bitonic> Peaker: oh wow, some serious second system here eh :).  looking forward to try it
11:56:44 <Peaker> Ralith, What license is Idris API under, btw?
11:56:50 <Ralith> tac: well of course, but I'm plugging it to Peaker here :P
11:57:01 <tac> heh, yeah...
11:57:14 <Ralith> Peaker: https://github.com/edwinb/Idris-dev/blob/master/LICENSE
11:57:20 <Ralith> that covers all the cod
11:57:21 <Ralith> e
11:57:36 <Ralith> so, standard permissive license
11:57:47 <merijn> mauke: I'm trying to decipher your regex, but I can't find the \% in the vim docs?
11:57:48 <tac> Peaker: https://github.com/edwinb/Idris-dev/blob/master/LICENSE
11:57:55 * Ralith elbows tac 
11:57:55 <mauke> merijn: should be under \%(
11:58:16 <Peaker> Ralith, cool.. and do you know if Idris is fast about its type inference/checking?
11:58:30 <merijn> mauke: Oh, yeah, I thought the ( was separate from it
11:58:49 <mlauria> hello
11:59:25 <Ralith> Peaker: typechecking DTs is often very slow. That's why idris will ultimately need very good support for saving and restoring partial results. For non-DT code, typechecking is in my experience fast enough to ignore.
11:59:55 <Ralith> that is, for code written in a haskell style.
11:59:57 <mlauria> does anyone know things about Simple Program?
12:00:24 <mauke> heh, misread idris as idra and DT as dark templars
12:00:27 <Ralith> note that idris is designed such that you are not required to write code in a DT style
12:00:50 <dmwit> mlauria: I've never even heard of "Simple Program".
12:00:51 <Ralith> mauke: proven-correct pointy sticks!
12:00:52 <bitonic> Peaker: Idris is just going to use the usual Miller unification, which you can optimise quite a bit
12:00:59 <bitonic> Peaker: Iâ€™m not sure how much Idris does optimise it
12:01:01 <Peaker> Ralith, fast enough to ignore in a less interactive environment like emacs+idris is not fast enough to ignore in our 60FPS animation...
12:01:06 <dmwit> mlauria: But even if I had that question is way too vague to answer. =)
12:01:19 <mlauria> dmwit sorry
12:01:22 <Ralith> Peaker: I don't imagine you need to recheck the entire program every frame.
12:01:25 <bitonic> Idris doesnâ€™t have any interactive emacs mode yet :(
12:01:27 <dolio> I guess H-M is merely double exponential, but dependent types might require you to compute Ackermann and such. :)
12:01:51 <Peaker> Ralith, of course not, but you make changes to parts of the program all the time, and these changes might cause some arbitrary re-computation of the types
12:01:55 <Ralith> bitonic: we're very close to getting the basics up; as I mentioned above, there's already a SLIME-like protocol being put together
12:02:08 <bitonic> Ralith: coolio
12:02:19 <mlauria> dmwit: http://www.haskell.org/cabal/release/cabal-latest/doc/API/Cabal/Distribution-Simple-Program.html
12:02:27 <Ralith> Peaker: that need not be a problem.
12:02:53 <bitonic> but yeah itâ€™s not going to be better than H-M, very bad worse case
12:02:54 <Ralith> async API calls, caching, etc
12:02:56 <Peaker> Ralith, we might place much more of an emphasis on responsiveness/quickness of type inference than emacs integration
12:03:01 <mlauria> I'm trying to build something using cabal, and it's giving me an error "Unknown build tool hsx2hs"
12:03:18 <dmwit> mlauria: Maybe you meant hsc2hs?
12:03:18 <mlauria> where hsx2hs is a simple program
12:03:19 <Ralith> Peaker: for the code which you're currently targeting--non-DT code--there's no reason idris can't be as fast as any other impl.
12:03:25 <dmwit> Oh, okay.
12:03:32 <mlauria> hsx2hsProgram :: Program hsx2hsProgram =     simpleProgram  "hsx2hs.hs"
12:03:36 <bitonic> Peaker: inference speed is rarely a problem in Haskell in the end
12:04:04 <bitonic> if youâ€™re going to have dependent types you can make inference arbitrarily slow anyway :P
12:04:12 <bitonic> just make it compute a lot
12:04:27 <mlauria> before I added the .hs, the error was setup: The program hsx2hs is required but it could not be found.
12:04:49 <dmwit> Well, is the program in your path?
12:04:58 <mlauria> I can paste hsx2hs if that would help
12:05:04 <mlauria> yes
12:05:18 <mlauria> sorry my irc doesn't autoscroll
12:05:37 <Ralith> Peaker: and, again, idris has far more reason to concern itself with speed of typechecking than other compilers, as it also must support the DT case.
12:05:44 <mlauria> so the hsx2hs.hs is a file in my path
12:05:59 <dmwit> wait
12:06:02 <bitonic> there are so many low-hanging fruits in Agda/Idris
12:06:10 <bitonic> cons hashing anyone?
12:06:12 <dmwit> You need a program named hsx2hs, not a source file named hsx2hs.hs.
12:06:22 <mlauria> dmwit: i'm going to start tagging you (completely new to irc here)
12:06:41 <mlauria> dmwit: Okay, but I tried compiling it first
12:07:05 <dmwit> And where did you put the resulting program?
12:07:31 <mlauria> dmwit: in the same directory
12:07:40 <mlauria> dmwit: "setup: The program hsx2hs is required but it could not be found"
12:07:47 <dmwit> mlauria: Okay. You need to put it in your path.
12:07:55 <dmwit> As in, in one of the directories listed in $PATH or %PATH%.
12:08:09 <mlauria> dmwit: so apparently even though the compiled program is in the correct directory, it was not found
12:08:23 <dmwit> mlauria: It is not yet in the correct directory, is what I'm saying.
12:08:53 <mlauria> dmwit: okay, but it's the same directory i'm calling cabal configure in...
12:09:01 <dmwit> That's not where it's looking.
12:09:45 <mlauria> dmwit: simpleProgram  "hsx2hs" { programFindLocation = "/Users/mdlauria/Desktop/Haskell/mastermind/mastermind"}
12:10:10 <mlauria> dmwit: Couldn't match expected type `String' with actual type `Program'
12:10:58 <schoppenhauer> hello. is there something similar to guards which is applicable directly after a lambda?
12:11:07 <dmwit> programFindLocation is not a String, it's a Verbosity -> IO (Maybe FilePath).
12:11:08 <merijn> schoppenhauer: case?
12:11:14 <schoppenhauer> I currently use \ x -> case x of x | ..., but that is probably not intended
12:11:28 <schoppenhauer> merijn: case can only destructurize, can't it?
12:11:35 <merijn> schoppenhauer: MultiWayIf if you use a new ghc
12:11:39 <mlauria> dmwit: so now I'm confused because according to the documentation I linked, this should work
12:11:44 <dmwit> mlauria: no
12:11:46 <merijn> schoppenhauer: You can just do "case x of _ |"
12:11:51 <dmwit> mlauria: Look again. =P
12:12:11 <merijn> schoppenhauer: Oh, actually, you could do better
12:12:34 <mlauria> dmwit: By default we'll just search for it in the path and not try to find the version name. You can override these behaviours if necessary, eg:   simpleProgram "foo" { programFindLocation = ... , programFindVersion ... }
12:12:54 <dmwit> schoppenhauer: {-# LANGUAGE LambdaCase #-} \case x | ... -> ...
12:13:06 <dmwit> mlauria: I'm with you so far.
12:13:07 <merijn> schoppenhauer: LambdaCase could work "\case\n _ | guard1 -> foo\n _ | guard2 -> bar"
12:13:22 <Peaker> Ralith, would be interesting to try it out if Idris could work with something like our expression format and yield results as nice expression annotations
12:13:32 <dmwit> mlauria: But those "..."s aren't of type String, is all.
12:14:03 <dmwit> mlauria: They're of type Verbosity -> IO (Maybe FilePath) and Verbosity -> FilePath -> IO (Maybe Version), as documented in your link.
12:14:05 <Ralith> Peaker: you should come hang out in #idris! :D
12:14:13 <kini> someone is having fun with hpaste... http://hpaste.org/browse
12:14:28 <arkeet> it's not new :(
12:14:35 <dmwit> kini: That is why hpastebot is not making announcements here any more. =(
12:14:40 <kini> aww
12:14:43 <mlauria> dmwit: yes I see. So is FilePath not just another name for type String?
12:14:53 <arkeet> it is.
12:14:58 <arkeet> type FilePath = String
12:15:22 <mlauria> arkeet: so all I'm messing up is Verbosity
12:15:24 <dmwit> Verbosity -> IO (Maybe FilePath) is not just another name for String.
12:15:30 <schoppenhauer>     Unsupported extension: LambdaCase ... meh ... but ok, at least I know that it can be done, thx merijn
12:15:32 <dmwit> No, you're also messing up with IO and Maybe.
12:15:38 <mlauria> dmwit, arkeet: should it be a Bool?
12:15:43 <dmwit> what
12:15:44 <schoppenhauer> (have version 7.4.1)
12:15:44 <arkeet> I haven't been following.
12:15:50 <mlauria> oh okay
12:16:05 <arkeet> :t return.return.return
12:16:06 <lambdabot> (Monad m2, Monad m1, Monad m) => a -> m (m1 (m2 a))
12:16:13 <mlauria> dmwit: give me a minute to solve this
12:16:20 <dmwit> I would try to be helpful, but I can't even imagine what kind of confusion would lead to asking about Bool here.
12:16:23 <arkeet> that'll turn a String into a Verbosity -> IO (Maybe FilePath)
12:16:24 <arkeet> :(
12:17:03 <mlauria> dmwit: my thought was that Verbosity would be T/F
12:17:26 <dmwit> If you click on a type, it will tell you more about that type.
12:17:51 <dmwit> For example, clicking on Verbosity takes you to http://hackage.haskell.org/packages/archive/Cabal/latest/doc/html/Distribution-Verbosity.html#t:Verbosity
12:19:30 <mlauria> dmwit: I attempted to fix it by changing the string to /Users/mdlauria/Desktop/Haskell/mastermind/mastermind/hsx2hs
12:19:45 <mlauria> and not specifying the findProgramLocation
12:19:59 <mlauria> but that just gave me setup: Unknown build tool hsx2hs
12:20:12 <mlauria> so I feel like it's looking in the right place now
12:23:00 <dmwit> Can you give us enough stuff to reproduce your problem, preferably with some work done to make it just barely enough stuff?
12:23:20 <m4b> after installing all the deps, can't seem to get lamdu to run; according to TUTORIAL there should be a dist/build/Editor/Editor bin but not present
12:24:07 <mlauria> dmwit: I'm trying to figure out how to make a web app with Haskell. What I'm doing right now is attempting to get this working: http://hub.darcs.net/stepcut/mastermind
12:24:14 <m4b> m4b: you can fix your problem by making a fonts dir in the lambda dir inside of dist/build, and copying DejaVu to that folder; and sending this link to friends, very cool editor guys
12:24:28 <mlauria> dmwit: next step, modify it and hope to learn things along the way
12:26:16 <dmwit> Is there a reason you can't put hsx2hs on your path and use the build-tools: section of the .cabal file instead of writing low-level Cabal code?
12:26:58 <mlauria> actually the only reason I'm doing it this way is because it's in the Setup.hs file which stepcut uses
12:28:44 <dmwit> Okay. And when you put hsx2hs on your path, does the code that's already in the repository not build?
12:29:06 <dmwit> This mucking about trying to hack Setup into looking a different place strikes me as the wrong way to fix it, and unreliable to boot.
12:31:44 <mlauria> dmwit: thanks! I tried it earlier but I must have gotten the dir wrong. I think it must have been the double mastermind
12:38:00 <dpratt71> <No panes> !!! :D so excited right now!
12:38:22 <Peaker> dpratt71, cool :)
12:38:35 <dpratt71> :)
12:40:55 <Peaker> dpratt71, TUTORIAL basically says you should press Alt-n, "fac x = if x=0 1 x*f x-1"
12:41:00 <pgiarrusso> Hi, I have a problem with type families, and it's not the standard injectivity one
12:41:09 <pgiarrusso> maybe it's another standard problem, but I don't get it
12:41:16 <pgiarrusso> Example at https://gist.github.com/Blaisorblade/5716721
12:41:19 <dpratt71> Peaker: will try that, thx
12:42:22 <pgiarrusso> The problem seems to arise from `type Delta Integer = Integer` (line 13), `diff :: a -> a -> Delta a` (line 10) and it arises on the expression `diff 2 1`
12:42:27 <Peaker> pgiarrusso, that does seem like a standard injectivity problem
12:43:23 <Peaker> pgiarrusso, try annotating the "2" or "1" as Integers
12:43:23 * hackagebot null-canvas 0.2.6 - HTML5 Canvas Graphics Library - forked Blank Canvas  http://hackage.haskell.org/package/null-canvas-0.2.6 (KrzysztofSkrzetnicki)
12:43:45 <pgiarrusso> that works indeed
12:44:03 <pgiarrusso> After a few changes, I got "Could not deduce (Delta a ~ Delta a0)"
12:44:32 <pgiarrusso> Peaker: yes, it's injectivity but less obviously so
12:44:35 <pgiarrusso> (for me)
12:44:54 <pgiarrusso> after I got to "Could not deduce (Delta a ~ Delta a0)", that became clearer
12:44:55 <pgiarrusso> thanks
12:45:10 <pgiarrusso> Peaker: and apologies for my mistaken claim
12:47:42 <mm_freak> @src foldMap
12:47:42 <lambdabot> Source not found. I've seen penguins that can type better than that.
12:47:58 <mm_freak> is foldMap left- or right-associative?
12:48:14 <arkeet> depends on the Foldable instance.
12:48:20 <magicman> @type foldMap
12:48:21 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
12:49:29 <magicman> If you have a law-abiding Monoid, that shouldn't matter for the result. If not, what arkeet says.
12:49:40 <arkeet> it matters for performance, sometimes.
12:50:06 <elliott> mm_freak: tree-associative, given ideal instances.
12:50:11 <magicman> In that case, use Endo a, where a is your original Monoid, and inject them as (a `mappend`).
12:50:31 <arkeet> or just use foldr
12:50:33 <elliott> wouldn't it be - yes
12:50:44 <arkeet> :t Data.Foldable.foldr
12:50:45 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:51:08 <magicman> Right. I think that's actually implemented using foldMap and Endo.
12:51:13 <arkeet> :t \f -> Data.Foldable.foldr (mappend . f)
12:51:14 <lambdabot> (Foldable t, Monoid b) => (a -> b) -> b -> t a -> b
12:51:17 <arkeet> nope.
12:51:21 <arkeet> yeah it is
12:51:42 <mm_freak> i'll go with foldr
12:51:43 <arkeet> :t \f -> Data.Foldable.foldr (mappend . f) mempty
12:51:44 <elliott> it's part of the class
12:51:44 <lambdabot> (Foldable t, Monoid b) => (a -> b) -> t a -> b
12:51:52 <elliott> mm_freak: foldMap is generally better
12:51:56 <elliott> unless you have strictness requirements
12:51:56 <mm_freak> because i want to make sure it applies right-associatively
12:51:59 <magicman> foldMap and foldr have a default implementation in terms of eachother, but you have to define one of the two.
12:52:00 <elliott> since it uses the natural order of the tree
12:52:03 <mm_freak> elliott: i do
12:52:33 <arkeet> :t Node
12:52:34 <lambdabot> a -> Forest a -> Tree a
12:52:45 <magicman> (of course, if you use a predefined instance, it'll probably have foldMap defined, and foldr'll auto-right-associate things)
12:53:20 <arkeet> > fold (Node a [Node b [Node c], Node d [Node e]])
12:53:20 <lambdabot>   Couldn't match expected type `Data.Tree.Tree
12:53:21 <lambdabot>                               ...
12:53:23 <hamid> how? how can I write this stream in haskell ? "0:0:0:1:2:4:7:12:22:...". :/
12:53:31 <arkeet> > fold (Node a [Node b [Node c []], Node d [Node e []]])
12:53:32 <lambdabot>   a <> (b <> (c <> mempty) <> mempty) <> (d <> (e <> mempty) <> mempty) <> me...
12:53:50 <mm_freak> @oeis 0 0 0 1 2 4 7 12 22
12:53:51 <lambdabot>  Sequence not found.
12:54:00 <arkeet> @oeis 1 2 4 7 12 22
12:54:01 <lambdabot>  Restricted partitions.
12:54:01 <lambdabot>  [0,1,1,2,4,7,12,22,39,70,126,225,404,725,1299,2331,4182,7501,13458,24145,433...
12:54:15 <arkeet> it doesn't give the sequence number?
12:54:29 <mm_freak> @oeis 2 3 5 7 11
12:54:34 <lambdabot>  The prime numbers.
12:54:34 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:54:36 <mm_freak> apparently not
12:54:55 <magicman> > foldr mappend mempty (Node a [Node b [Node c[]], Node d [Node e []]])
12:54:57 <lambdabot>   Couldn't match expected type `[b0]'
12:54:57 <lambdabot>              with actual type `Data.Tre...
12:55:13 <magicman> Oh, derp.
12:55:43 <magicman> > Data.Foldable.foldr mappend mempty (Node a [Node b [Node c[]], Node d [Node e []]])
12:55:45 <lambdabot>   a <> b <> c <> d <> e <> mempty
12:56:11 <mm_freak> > foldMap id [a, b, c, d, e]
12:56:13 <lambdabot>   a <> b <> c <> d <> e <> mempty
12:56:16 <arkeet> fold = foldMap id
12:57:25 <Lethalman> anybody used hsmagick? I can't read a simple .png file
12:58:28 <Lethalman> this guy had my same error: http://hpaste.org/9424
12:59:37 <hamid> @oeis 0 0 0 1 2 4 7 12
12:59:38 <lambdabot>  Partial sums of round(Fibonacci(n)/11)
12:59:38 <lambdabot>  [0,0,0,0,0,0,1,2,4,7,12,20,33,54,88,143,233,378,613,993,1608,2603,4213,6818,...
13:03:11 <joelteon> round(Fibonacci(n)/11)
13:03:13 <joelteon> is that used for anything?
13:05:37 <hamid> no idea! not the one which i want :|
13:05:58 <joelteon> @oeis 1 2 3 4 6
13:06:03 <lambdabot>  3-smooth numbers: numbers of the form 2^i*3^j with i, j >= 0.
13:06:03 <lambdabot>  [1,2,3,4,6,8,9,12,16,18,24,27,32,36,48,54,64,72,81,96,108,128,144,162,192,21...
13:06:20 <arkeet> hamid: well, who knows what you want.
13:06:52 <hamid> arkeet, yep! i should write mine in c++ and give to you maybe you'll get what i want :P
13:07:04 <arkeet> =(
13:08:24 * hackagebot null-canvas 0.2.7 - HTML5 Canvas Graphics Library - forked Blank Canvas  http://hackage.haskell.org/package/null-canvas-0.2.7 (KrzysztofSkrzetnicki)
13:15:27 <pgiarrusso> Other question: I have an expression which is ambiguous in a program but type checks at the GHCi prompt, in both cases with the monomorphism disabled. Where do I start investigating?
13:15:47 <pgiarrusso> is that even possible?
13:16:01 <DanBurton> can you hpaste it?
13:16:07 <shachaf> pgiarrusso: ghci does more defaulting
13:16:09 <DanBurton> what does the compiler say?
13:16:14 <shachaf> @google extended default rules ghci
13:16:16 <lambdabot> http://www.haskell.org/ghc/docs/6.6/html/users_guide/ghc-language-features.html
13:16:16 <lambdabot> Title: Chapterï¿½7.ï¿½GHC Language Features
13:16:27 <shachaf> OK, that page is a little old. But that's the idea.
13:17:50 <pgiarrusso> is there some flag to disable this defaulting in ghci?
13:18:23 <pgiarrusso> `:set -fnoextended-default-rules` doesn't work
13:18:39 <reiko> hi
13:18:42 <pgiarrusso> DanBurton: I guess shachaf is right here
13:19:28 <shachaf> Yes, turn off ExtendedDefaultRules.
13:19:44 <geekosaur> -XNoExtendedDefaultRules
13:19:50 <geekosaur> not -f
13:19:50 <pgiarrusso> geekosaur: thanks
13:20:07 <shachaf> -fno-extended-default-rules also works
13:20:12 <pgiarrusso> geekosaur: I was swayed by the link above, which is for GHC 6.6
13:20:13 <shachaf> (And tells you about the new way.)
13:20:49 <pgiarrusso> shachaf: yes, but it doesn't work inside GHCi as argument of `:set`
13:20:53 <shachaf> It does.
13:21:07 <pgiarrusso> *DeltaInt> :set -fnoextended-default-rules
13:21:07 <pgiarrusso> Some flags have not been recognized: -fnoextended-default-rules
13:21:12 <geekosaur> note hyphen after no
13:21:13 <shachaf> 13:29 <shachaf> -fno-extended-default-rules also works
13:21:19 <pgiarrusso> whoops, sorry
13:21:35 <shachaf> Note that you can tab-complete options for :set
13:23:06 <pgiarrusso> amazing, still not that one
13:24:07 <geekosaur> I expect it wants the -X one since the -f one is deprecated
13:24:46 <pgiarrusso> shachaf: I seem to have disabled successfully defaulting, yet the same code is not ambiguous in GHCi
13:24:51 <shachaf> Yep. The -f option warns to use -X.
13:24:58 <pgiarrusso> *DeltaBag> :set -XNoExtendedDefaultRules
13:24:59 <pgiarrusso> *DeltaBag> :t check il1A il1B $ diffN il1A il1B
13:24:59 <pgiarrusso> check il1A il1B $ diffN il1A il1B :: Integer -> Bool
13:25:18 <pgiarrusso> now, the "argument" of :t does not work in the program
13:25:19 <shachaf> That's not defaulting, not with :t.
13:25:57 <pgiarrusso> interesting
13:26:04 <shachaf> I suspect you're wrong somewhere. I can't really say more.
13:26:14 <pgiarrusso> however, foo = that expression works in the program with ExtendedDefaultRules
13:26:44 <shachaf> OK, then I'll give you my hypothesis, but you should *really* show your code when you ask questions like this.
13:27:06 <shachaf> Otherwise people have to make random guesses. It's not good for anybody.
13:27:27 <shachaf> Hypothesis: One of check, il1A, il1B, diffN is being defaulted.
13:28:19 <pgiarrusso> shachaf: sorry about that, I'll try reducing the example
13:29:11 <Peaker> dpratt71, hey, would be glad to hear your feedback, did you manage to do something at all in the editor?
13:29:36 <Peaker> dpratt71, or too confusing? :)
13:30:46 <dpratt71> Peaker: well, I did the tutorial and that worked, after that I just poked around a bit
13:31:03 <dpratt71> I plan to look at it a bit more, later
13:31:06 <Peaker> dpratt71, ah, cool, is it generally understandable?
13:31:11 <shachaf> Any chance of support for lack of support for OpenGL?
13:31:27 <Peaker> shachaf, not sure how we might do that :(
13:31:41 <Peaker> shachaf, what drawing APIs are available on your system?
13:31:50 <Peaker> shachaf, do you have hardware accelerated drawing?
13:31:54 <shachaf> I don't know.
13:31:59 <shachaf> I don't think so.
13:32:04 <dpratt71> Peaker: I had a bit of a tough time getting started, but I think it may have been because I first jumped in without reading the directions
13:32:05 <shachaf> My graphics card drivers are messed up.
13:32:08 <luite> is hardware acceleration really required for an editor?
13:32:12 <shachaf> Is it necessary?
13:32:14 <dpratt71> and then things were in a weird state
13:32:19 <Peaker> dpratt71, yeah, and things are very preliminary so not all things work as they should
13:32:25 <Peaker> dpratt71, yeah, that's too easy to get to
13:32:36 <Peaker> luite, it is for the smooth animations
13:32:46 <Peaker> luite, and smooth animations make the experience so much more pleasant
13:33:01 <Peaker> (we could make a non-smooth variant for people with broken drivers)
13:33:19 <Peaker> shachaf, are all your computers without graphics drivers?
13:33:32 <dpratt71> Peaker: as a concept, I find it very compelling -- quite interested to see where it goes
13:33:36 <shachaf> There is only one computer that I use regularly.
13:33:48 <shachaf> This isn't really a huge deal.
13:34:00 <functorfun> g'day
13:34:06 <shachaf> Also offtopic for this channel by now.
13:35:01 <dpratt71> Peaker: but -- and this will probably sound silly -- aesthetically, I found it somewhat...less than pleasant
13:35:08 <functorfun> transformers is broken on hackage :/ is it possible for anyone to fix that? Control/Monad/Trans/Error.hs:55:21: Not in scope: `catch'
13:35:11 <functorfun> Failed to install transformers-0.2.2.0
13:35:30 <functorfun> This always happens when I am in the middle of something
13:35:40 <Peaker> dpratt71, can you join #haskell-blah
13:36:12 <supki> functorfun: why are you trying to install transformers-0.2.2.0
13:36:19 <supki> it's from 2010
13:36:25 <thoughtpolice> functorfun: use transformers-0.3
13:36:39 <functorfun> its a dep for improve that I am trying to install
13:37:10 <functorfun> looks like I already have that on a closer look
13:37:40 <pgiarrusso> shachaf: is it acceptable to hpaste a non-reduced example?
13:37:43 <thoughtpolice> functorfun: the thing is, transformers isn't broken. what happened was that something was deprecated (prelude exporting 'catch') and for a long time this was maintained and finally removed. so the older version of transformers-0.2.2.0 will never work on a newer GHC, due to the changed API
13:37:54 <shachaf> pgiarrusso: Better than nothing.
13:37:55 <functorfun> some of cabals messages are really misleading :/ it said I needed a newer version
13:37:57 <thoughtpolice> functorfun: you're better off just tweaking the dependencies for 'improve' to allow transformers-0.3.0.0
13:38:05 <shachaf> pgiarrusso: Often reducing it will help you figure out what the problem really is.
13:38:43 <functorfun> thoughtpolice: yep, I understand many thanks.. I was mislead by cabal lying to me about having a transformers that i too old
13:39:24 <thoughtpolice> np
13:40:04 <functorfun> how do I tweak improve..
13:40:41 <functorfun> cabal fetch and unpack?
13:41:02 <merijn> functorfun: You can do "cabal unpack" directly and it will fetch too
13:41:06 <merijn> functorfun: And yes
13:43:13 <functorfun> yikes, yices comes up with some nasty looking warnings and its a SMT prover lol
13:43:48 <functorfun> packages like that look like they are almost about to break, prob at the next ghc version bump..
13:44:33 <functorfun> Is there any plan to get hackage to support some kind of notice board thingo that could point out packages that need a quick clean up..
13:46:02 <merijn> functorfun: Well, if you volunteer to implement I think people would like that :)
13:46:09 <merijn> s/:)/;)
13:46:39 <pgiarrusso> shachaf: is it possible to confirm that `:set -XNoExtendedDefaultRules` worked? I'm not able to do that with `:show languages`
13:46:48 <shachaf> I don't think so.
13:47:01 <functorfun> yes it maybe something I will have to plan on doing merijn since its something that intensely annoys me :)
13:47:15 <shachaf> pgiarrusso: Note that ghciing a file and then using :set Foo will only put Foo into effect *after* the file is loaded, of course.
13:47:26 <pgiarrusso> shachaf: that's clear
13:47:37 <pgiarrusso> but by now, the only confusing thing
13:47:56 <pgiarrusso> is that -XNoExtendedDefaultRules seems to make no difference
13:48:04 <pgiarrusso> if I then try to get an ambiguity in GHCi
13:48:15 <shachaf> You still haven't @pasted code, I think.
13:48:16 <shachaf> Prelude> []
13:48:16 <shachaf> []
13:48:19 <shachaf> Prelude> :set -XNoExtendedDefaultRules
13:48:19 <shachaf> Prelude> []
13:48:37 <shachaf> The latter gives an error for me.
13:50:04 <pgiarrusso> shachaf: http://hpaste.org/89384 shows the output on my system
13:50:13 <pgiarrusso> In particular, I don't get the error
13:50:33 <shachaf> Hmm, 7.4 and 7.6 behave differently.
13:50:47 <pgiarrusso> if your GHCi is later than 7.4.2, that seems (arguably?) a bug in my GHCi
13:50:52 <shachaf> Maybe this is a bug.
13:51:06 <shachaf> OK, well, that's possible.
13:51:22 <pgiarrusso> I guess there'd be no point in investigating the bug, since it's fixed in 7.6, right?
13:51:35 <shachaf> Yes, it's fixed.
13:51:45 <pgiarrusso> or do people bother to backport such fixes to previous series?
13:52:11 <shachaf> I doubt it'll get backported to 7.4 at this point.
13:52:18 <shachaf> But I don't know.
13:54:19 <byorgey> such fixes do not get backported to previous major versions.
13:54:19 <pgiarrusso> shachaf: thanks a lot for your help!
13:55:17 <dmwit> functorfun: Somebody hooked up Hackage and Disqus, I think.
13:55:28 <dmwit> Dunno how it works, but I have a thing at the bottom of every Hackage page in my browser.
13:55:49 <dmwit> Can't remember whether I had to install a plugin for that or whether it Just Happens.
13:55:55 <hpc> dmwit: CNR
13:56:00 * byorgey has that too.
13:56:06 <byorgey> there are never any comments.
13:56:10 <dmwit> right
13:56:22 <dmwit> Well, sometimes there is some spam.
13:56:29 <byorgey> hehe
13:57:10 <byorgey> I think you have to install something.  Which is a big part of the reason why there aren't any comments.
13:59:32 <functorfun> thanks I managed to fix imporve and I am submitting a patch
14:00:26 <pgiarrusso> byorgey: thanks, then I'll abort the bug report I guess
14:01:45 <taylanub> I have a question about a specific optimization strategy in Scheme implementations and don't know what channel to turn to.  Does anyone know what "delayed boxing of procedures" is ?  ("Delayed boxing" in general is, I think, the strategy of e.g. automatically switching between fixnums and bignums.)
14:02:03 <shachaf> Perhaps #scheme would be an appropriate channel?
14:02:08 <taylanub> It's slow. :(
14:03:15 <eikke> wouldn't it be something like GHC's integer being or an Int, or a GMP Integer?
14:03:25 <shachaf> Yes, but it's actually about Scheme.
14:03:25 <leroux> How do I use functions from Data.List.Ordered?
14:03:50 <ion> Import it.
14:03:54 <merijn> leroux: "import Data.List.Ordered" and then use them? :p
14:04:21 <leroux> Could not find module `Data.List.Ordered'
14:04:35 <geekosaur> then you need to install it first, presumably
14:04:54 <leroux> Shouldn't it be installed?
14:05:15 <geekosaur> no? hayoo tells me it's in data-ordlist, which I odn't recall being an HP package
14:05:25 <leroux> Ahh.
14:05:26 <leroux> Thanks.
14:06:12 <ion> Hayoo is pronounced pretty much like the Finnish word for smell.
14:06:30 <taylanub> shachaf: For some reason I came here before actually asking there, I now asked it there but can't know whether it'll be answered in the next couple hours, or ever. :)
14:07:50 <taylanub> ... Riastradh to the rescue. O_o
14:09:06 <shachaf> You also asked a much better question in #scheme, i.e. you linked to a place that used the phrase rather than asking about the phrase.
14:09:38 <taylanub> My mind works in mysterious ways in the late evening. :(
14:09:53 <shachaf> Fortunately it all worked out!
14:10:02 <taylanub> Indeed. :D
14:10:32 <taylanub> Thanks.
14:12:02 <merijn> ok, another code sample request: different ways you write ADT declarations using record syntax
14:21:06 * KingofFerrets waves.
14:25:53 <DanBurton> Hey, does anyone remember where Tekmo moved the "Frames" code when he split it out of the pipes package?
14:29:49 <DanBurton> also, what is the difference from Tekmo's indexed monads, and edwardk's?
14:34:42 <Botje> @pl \a b c -> f a c b
14:34:43 <lambdabot> flip . f
14:34:43 <c_wraith> DanBurton: is it the stuff the pipes-safe package now handles?
14:35:32 <DanBurton> c_wraith: it was made for the same purpose, but interests me for a different reason
14:35:46 <DanBurton> mainly I am taking another look at indexed monads
14:37:12 <c_wraith> DanBurton: Looks like pipes-safe doesn't use that mechanism, so it's possible it's just no longer in his ecosystem
14:38:11 <DanBurton> indeed; he pulled it out of the pipes ecosystem when he introduced Proxy, but I'm pretty sure he left it somewhere on hackage
14:39:17 <c_wraith> too bad you can't search hackage by author
14:41:09 <Saizan> where are Tekmo's indexed monads?
14:41:46 <c_wraith> that's one question DanBurton is trying to answer
14:42:04 <Saizan> fair enough
14:43:48 <merijn> Woah, wtf
14:43:55 <merijn> Why did I not know about LiberalTypeSynonyms?!?
14:44:12 <rck> creating a warp/WAI/scotty REST api that needs to store very simple state across requests. (a list of items that are marked as served once served)
14:44:19 <rck> do I want an IORef?
14:44:34 <merijn> rck: Do you need to update the state?
14:44:53 <Saizan> MVar, maybe?
14:45:37 <Saizan> anyhow i suspect you do want some reference type
14:46:11 <rck> merijn: yep. I start with a list of values to be served, and as a request comes in I need to atomically remove one item from the list, serve it, and continue
14:46:38 <merijn> oh
14:46:46 <merijn> Maybe Chan is nicer than
14:47:09 <rck> not sure what that is; will look it up. thanks.
14:47:13 <merijn> Dump all values into the Chan and then read one whenever a request comes in
14:47:22 <merijn> Control.Concurrent.Chan
14:49:34 <rck> reads are atomic from a chan?
14:50:55 <merijn> rck: Yup
14:52:39 <DanBurton> Saizan: tekmo's indexed monads are at index-core
14:54:46 <Saizan> DanBurton: they look the same
15:26:32 <NovaDenizen> @pf \f x -> (f x) x
15:26:32 <lambdabot> Maybe you meant: bf pl
15:26:49 <quchen> @pl \f x -> (f x) x
15:26:50 <lambdabot> join
15:27:07 <NovaDenizen> thanks.
15:27:19 <NovaDenizen> @type join
15:27:20 <lambdabot> Monad m => m (m a) -> m a
15:27:50 <quchen> join m = m >>= id. The specific join Lambdabot just gave you is the one for Reader.
15:28:22 <quchen> But you don't really need to know that in order to use it as "join f x = f x x" :-)
15:29:26 <quchen> @type join `asAppliedTo` (undefined :: a -> a -> b)
15:29:27 <lambdabot> (a1 -> a1 -> a) -> a1 -> a
15:29:56 <quchen> That's the type signature when you break it down to functions.
15:30:54 <NovaDenizen> Thanks, I'm familiar with it.  I just wanted to be reminded of how lambdabot took care of @pf (f x) x
15:31:59 <quchen> pl. PointLess.
15:32:12 <quchen> Many people have tried pf, including me  ;-)
15:32:42 <Hafydd> @bg
15:32:42 <lambdabot> Maybe you meant: bf bug
15:32:43 <Hafydd> @bf
15:32:44 <lambdabot>  Done.
15:32:50 <Hafydd> What did I do?!
15:33:19 <Hafydd> Oh, brainfuck.
15:33:27 <hodapp> o_O
15:33:30 <eikke> @bf ...
15:33:30 <lambdabot>  Done.
15:34:02 <quchen> @bf ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
15:34:02 <lambdabot>   H
15:34:04 <quchen> :-D
15:34:06 <joelteon> @bf +++++++[>++++++<-]>.
15:34:07 <lambdabot>   *
15:34:35 <joelteon> it's like some kind of fish
15:34:39 <eikke> @bf +[[>+]>[+>]+]
15:34:44 <lambdabot>  Done.
15:35:02 <quchen> @bf +++++[>++++++++++<-]>. Should be ASCII 50
15:35:03 <lambdabot>   2
15:35:20 <quchen> Or 49? Anyway, offtopic.
15:35:59 <DanBurton> #haskell-blah exists for such things :)
15:36:10 <eikke> @bf +[]
15:36:15 <lambdabot>  Done.
15:36:43 <eikke> hmh... lambdabot knows how to handle inifinite computations?
15:36:52 <joelteon> probably limits it to some number of opcodes
15:36:55 <Hafydd> Not all of them, I trust.
15:36:59 <joelteon> i made a brainfuck bot that executed up to 100,000
15:41:28 <KingofFerrets> People of #haskell! I am random, newbish, and bursting with vaguely-question-shaped-and-question-sized-things-that-are-presumably questions. Would any of you be willing to answer them?
15:43:01 <Hafydd> KingofFerrets: yes, I'm sure many of us would - t3h penguin of doom
15:43:15 <KingofFerrets> Awesomesauce.
15:44:50 <DanBurton> KingofFerrets: fire away
15:45:09 <NovaDenizen> @pl \a b c x -> a (b x) (c x)
15:45:10 <lambdabot> liftM2
15:45:20 <NovaDenizen> @type liftM2
15:45:31 <tabemann> there's a brainfuck implementation embedded in lambdabot?
15:45:35 <lambdabot> thread killed
15:45:48 <KingofFerrets> So, I'm getting ready to work on a project that involves a lot of random number generation, and I'm trying to figure out if Haskell's tools for that are good enough. There seem to be three seperate things for random number generation, according to me typing "random" into Hoogle. What do you guys recommend using?
15:45:49 <NovaDenizen> odd.
15:46:01 <NovaDenizen> @hoogle liftM2
15:46:03 <tabemann> @bf +[]
15:46:07 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:46:12 <lambdabot>  Done.
15:46:46 <tabemann> @bf +[.+]
15:46:46 <lambdabot>    !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghij...
15:47:25 <DanBurton> KingofFerrets: when I say the word "monad", what is your initial impulse? a) run away! b) run towards! c) poke with stick
15:47:45 <NovaDenizen> @KingofFerrets it kind of depends on what kind of code you want to write, pure or imperative IO
15:47:46 <lambdabot> Unknown command, try @list
15:48:30 <tabemann> mind you you can always put your random number generator in a State monad, or a StateT monad transformer wrapped around another monad (such as IO)
15:48:33 <KingofFerrets> I'm going to go with "note on my map, run away /now/, then come back and poke with a stick later".
15:49:30 <NovaDenizen> If you're used to imperative programming then you're probably used to a model where the rng state sits outside of the flow of your normal code and you just yank a number from it every once in a while.
15:49:40 <KingofFerrets> Think we're going to need some IO stuff... Not 100% sure what all we need with it.
15:49:53 <DanBurton> in that case, I recommend http://hackage.haskell.org/packages/archive/random/latest/doc/html/System-Random.html
15:50:24 <DanBurton> here's what you do: use "g <- getStdGen" in an IO block, and then write your randomness code by passing around generators
15:50:27 <KingofFerrets> I am used to imperative programming. I've done some Scheme and a little bit of Haskell before, but that was last fall and I remember the Scheme a lot better than the Haskell, and never did random number generation in either.
15:50:38 <tabemann> if you want to access the IO monad and yet want to be able to pull out random numbers arbitrarily without having to explicitly pass around RNGs you probably want a StateT containing an RNG mapped around the IO monad
15:50:54 <tabemann> *wrapped around
15:51:07 <NovaDenizen> The ugly and simple way is just to use "val < randomIO" every time you want a new one.
15:51:26 <NovaDenizen> But if you're writing pure code you have to thread the rng state through it one way or another.
15:51:33 <KingofFerrets> Hm. Alright.
15:51:49 <tabemann> where then using State or StateT is a good way of hiding the piping
15:52:00 <KingofFerrets> Do you guys happen to know how Haskell seeds its RNG by default?
15:52:58 <DanBurton> not sure
15:53:12 <NovaDenizen> mkStdRNG :: Integer -> IO StdGen
15:53:12 <NovaDenizen> mkStdRNG o = do
15:53:12 <NovaDenizen>     ct          <- getCPUTime
15:53:12 <NovaDenizen>     (sec, psec) <- getTime
15:53:13 <NovaDenizen>     return (createStdGen (sec * 12345 + psec + ct + o))
15:53:39 <josephle> NovaDenizen: you know what they say about hpaste...
15:53:47 <NovaDenizen> The default system RNG is initialized with mkStdRng 0
15:53:54 <NovaDenizen> What do they say about hpaste?
15:54:17 <KingofFerrets> So, seeds based on the system clock, looks like? Apparently I don't want that, so will probably need to get my own seeds somewhere.
15:54:23 <josephle> probably something along the lines of using it to link to haskell code that isn't a one-liner
15:55:12 <DanBurton> Or link to the sauce: http://hackage.haskell.org/packages/archive/random/latest/doc/html/src/System-Random.html#mkStdRNG
15:55:30 <NovaDenizen> I figured 5 lines wasn't a big deal.
15:55:31 <merijn> Ok, vim lovers, I need some beta (well, alpha...) testers for the auto-indent stuff I have so far :p
15:56:04 <josephle> KingofFerrets: spawn a thread, take threadID!
15:56:08 <merijn> https://bitbucket.org/merijnv/haskellfoldindent or https://github.com/merijn/haskellFoldIndent
15:56:11 <Bor0> why is it that when I have putStrLn, readLn the putStrLn is printed after read? but with print, readLn it's fine. however, I don't like the double quotes when I use "print"
15:56:16 <Bor0> (printing a string by the way)
15:56:50 <josephle> Bor0: do you know if print flushes the buffer? I know putStrLn doesn't
15:56:58 <KingofFerrets> Can two threads ever have the same ID? Like, if I ran the program once and then ran it again later. I assume they can't have the same ID simultaneously.
15:57:04 <merijn> Not yet implemented: let/in indenting, handling record syntax, where clauses are broken and "then do foo" and "else do bar" don't indent properly either "then do\nfoo" works fine, though
15:57:08 <NovaDenizen> KingofFerrets: You  just need to come up with a random Int and pass it through mkStdGen to explicitly seed a RNG.
15:57:54 <merijn> Haskell2010 *should* work properly, including: LambdaCase, MultiWayIf, TypeFamilies, GADTs and KindSignatures
15:59:03 <Bor0> josephle,  how can I flush the buffer using putStrLn
15:59:03 <KingofFerrets> I'll probably consult random.org for a bunch of seeds, then.
15:59:22 <josephle> Bor0: hFlush stdout
15:59:32 <josephle> Bor0: might need to import System.IO
16:00:07 <NovaDenizen> hSetBuffering stdout NoBuffering
16:00:08 <Bor0> great, that worked, thank you!
16:00:19 <KingofFerrets> Anyway... so, it sounds like I can probably in fact use Haskell for this... So that's good.
16:00:59 <KingofFerrets> But at least half of this has flown over my head, which is bad.
16:01:05 <Bor0> I produced a binary using ghc, will it work on another system that doesn't have haskell installed?
16:01:29 <NovaDenizen> Unix?  Check the dynamic libraries it needs with ldd.
16:01:57 <merijn> Bor0: It will, if it's the same architecture and OS
16:02:08 <Bor0> excellent!
16:02:15 <KingofFerrets> So I should probably go refresh my memory on Haskell, then bother you guys about things. Would you guys recommend anything other than Learn You A Haskell to get back up to speed?
16:02:32 <FreeFull> KingofFerrets: Mess around in ghci
16:02:59 <KingofFerrets> I will when I remember where I put it on this computer...
16:03:14 <merijn> KingofFerrets: Real World Haskell?
16:03:18 <merijn> @where rwh
16:03:18 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:03:25 <FreeFull> @where lambdabot
16:03:25 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
16:03:36 <josephle> merijn: you beat me to it!
16:04:03 <KingofFerrets> Mmkay, awesome.
16:04:23 <FreeFull> @where where
16:04:23 <lambdabot> ^^^^^^
16:04:35 <NovaDenizen> @where am i
16:04:36 <lambdabot> I know nothing about am.
16:04:47 <NovaDenizen> @where clitoris
16:04:48 <lambdabot> I know nothing about clitoris.
16:04:49 <wilfredh> what are my library options for making an HTTPS GET? I've tried curl but my host doesn't have a compatible version of libcurl
16:04:53 <wilfredh> there must be other options
16:05:04 <FreeFull> @where god
16:05:04 <lambdabot> I know nothing about god.
16:05:05 <hpc> does simpleHTTP do https?
16:05:14 <shanse> i believe so
16:05:17 <geekosaur> play with the bot elsewhere, please
16:05:40 <mm_freak> KingofFerrets: different invocations of the same program don't share the same ThreadId space, so they may have colliding thread ids
16:05:49 <mm_freak> KingofFerrets: remember that haskell threads are not operating system threads
16:06:24 <wilfredh> isn't simpleHTTP just built on Network.HTTP? That explicitly doesn't support HTTPS.
16:06:29 <mm_freak> hundreds of thousands of haskell threads may be distributed over only as many OS threads as you have cores
16:06:40 <KingofFerrets> Ah, alright. That definitely wouldn't work as a seeding mechanism, then, looking to not get the same seed twice.
16:06:50 <hpc> wilfredh: ah, that's right
16:07:01 <mm_freak> hpc: simpleHTTP from happstack?
16:07:23 <hpc> @hoogle simpleHTTPS
16:07:24 <lambdabot> No results found
16:07:29 <hpc> well that was depressing
16:07:40 <stepcut> hpc: you need the happstack-server-tls package
16:08:06 <FreeFull> @hoogle https
16:08:07 <lambdabot> package httpspec
16:08:07 <lambdabot> package haskoon-httpspec
16:08:07 <wilfredh> I want to make a request, i.e. I want an HTTPS client, not to host something
16:08:08 <stepcut> http://hackage.haskell.org/packages/archive/happstack-server-tls/7.0.2/doc/html/Happstack-Server-SimpleHTTPS.html
16:08:29 <stepcut> ah
16:08:29 <mm_freak> either what stepcut said or the more common approach:  a reverse proxy from nginx/apache to your happstack application
16:08:39 <stepcut> the other simpleHTTP :)
16:08:41 <wilfredh> so surely happstack isn't relevant?
16:08:46 <stepcut> indeed
16:08:57 <mm_freak> oh hehe
16:09:28 <josephle> @where where
16:09:28 <lambdabot> ^^^^^^
16:10:01 <mm_freak> stepcut: btw, i'm working on an HSP-like DSL for stylesheetsâ€¦  and yes, it supports arbitrary underlying monads
16:10:14 <stepcut> \o/
16:11:57 <KingofFerrets> After checking some stuff, apparently I need to know what kind of pseudo-random number generator Haskell uses, too. Anyone know that?
16:13:13 <Ralith> KingofFerrets: there are some packages with pure RNG impls like MT1337
16:13:21 <Ralith> you should use those if you care about the details
16:15:07 <wilfredh> ah, looks like I can use http-conduit with simpleHTTP: http://stackoverflow.com/a/9986695/509706
16:15:45 <KingofFerrets> ...Gah. I wish my teacher would stop giving me tasks where a good answer sounds like gibberish. >.>
16:16:19 <KingofFerrets> What packages are those, and what's MT1337? Can't find anything about it on Google.
16:16:47 <Bor0> is there a neater way to achieve this: http://hpaste.org/89386
16:17:12 <wilfredh> seems there's also an http-wget
16:18:24 <Ralith> KingofFerrets: aka the mersenne twister
16:18:32 <Ralith> https://en.wikipedia.org/wiki/Mersenne_twister
16:18:41 <Ralith> oh
16:18:42 <Ralith> it's 19937
16:18:43 <Ralith> my bad
16:19:49 <FreeFull> http://hackage.haskell.org/package/mersenne-random
16:20:06 <startling> Ralith: haha 1337
16:20:36 <mm_freak> just for the record, cprng-aes is always a safe choice
16:20:55 <Ralith> startling: ...man I didn't even realize I did that
16:20:57 * Ralith facepalm
16:21:00 <mm_freak> mersenne-twister is faster, but not suitable for all applications (e.g. crypto)
16:21:01 <Ralith> KingofFerrets: http://hackage.haskell.org/package/mersenne-random-pure64-0.2.0.3
16:21:36 <Ralith> KingofFerrets: if you feel monady, use that with http://hackage.haskell.org/package/random-fu
16:21:38 <KingofFerrets> Aha.
16:21:52 <startling> mm_freak: is it the same algorithm? why is one implementation of an algorithm more suitable than another?
16:21:54 <KingofFerrets> Thank you.
16:22:30 <startling> mm_freak: (at a guess, timing attacks?)
16:23:43 <Ralith> startling: MT19937 is predictable, if you can get ahold of enough contiguous samples
16:23:49 <Ralith> you can reconstruct the state
16:23:56 <Ralith> iirc
16:26:26 <startling> oh
16:27:02 <startling> I thought mm_freak was talking about a different package called "mersenne-twister". >.>
16:27:20 <mm_freak> startling: no, i mentioned cprng-aes
16:28:37 <Ralith> startling: it's a vulnerability in the mersenne twister algorithm itself, whatever period you choose
16:29:10 <startling> Ralith, mm_freak: understood.
16:29:12 <Ralith> KingofFerrets: so what's this for? It sounds like homework, but it sounds like fun homework
16:35:25 <wilfredh> I have a function with type: (MonadIO m, Failure WgetException m) => String -> m String
16:35:49 <wilfredh> how can m be two different monads?
16:36:20 <geekosaur> MonadIO is a typeclass
16:37:06 <geekosaur> a typeclass which adds functionality to existing monads
16:37:10 <wilfredh> OK, so m is a monadic type that belongs to two different typeclasses?
16:37:55 <merijn> wilfredh: MonadIO has a Monad constraint (i.e. everything that is MonadIO *has to be* Monad too)
16:38:18 <KingofFerrets> Ralith: I guess I'm technically getting course credit for it, so you could consider it homework. :P
16:38:34 <KingofFerrets> It's a research project I'm working on with one of the professors here.
16:39:02 <KingofFerrets> We're making new random models for Buechi automata.
16:39:33 <Ralith> KingofFerrets: I have no idea what that is but it sounds fun.
16:39:35 <Ralith> good luck!
16:39:39 <KingofFerrets> I didn't think you would. :P
16:39:48 <KingofFerrets> Do you know what a Turing machine is?
16:39:55 <Ralith> yes.
16:41:07 <KingofFerrets> We're randomly generating machines that are related to Turing machines.
16:41:32 <wilfredh> I think I can work from here, thanks
16:41:40 <geekosaur> wilfredh, MonadIO is a typeclass, the other thing is a monad which is parameterized over m.
16:43:10 <KingofFerrets> We got a whole bunch of different methods for randomly generating ones with different properties, and we're trying to implement it in Haskell because the professor has a codebase for working with automata in Haskell already.
16:43:31 <KingofFerrets> so we write code, generate a bunch of things, analyze the results... and then ideally get published somewhere.
16:44:02 <wilfredh> is there a convenient way of catching exceptions and returning Maybe?
16:49:58 <josephle> @hoogle catch
16:49:58 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
16:49:58 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
16:49:58 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
16:53:34 <josephle> @hoogle handle
16:53:34 <lambdabot> System.IO data Handle
16:53:34 <lambdabot> GHC.IO.Handle data Handle
16:53:35 <lambdabot> Control.OldException handle :: (Exception -> IO a) -> IO a -> IO a
16:53:54 <josephle> wait, is handle = flip catch in Control.OldException?
17:12:12 <hcaulfield57> I'm trying to get the following list comprehension to work with every element of 'y' is that possible? In other words so that x is only added to the list if every element of y is evenly divisible within it. http://hpaste.org/89388
17:14:27 <shachaf> Perhaps you can say something like "| x <- [1..], all (\y -> x `mod` y == 0) [1..20]"
17:14:50 <shachaf> List comprehensions are not the answer to everything. In fact they are overrated.
17:15:23 <hcaulfield57> shachaf: Okay thanks, I didn't know about 'all' that's helpful.
17:28:48 <arkeet> shachaf: did you work out the free monad monad algebra laws?
17:29:56 <shachaf> arkeet: No, I didn't think about it.
17:29:59 <shachaf> Did you work it out?
17:30:34 <arkeet> no
17:30:41 <arkeet> I didn't think about it either.
17:31:46 --- mode: ChanServ set +o geekosaur
17:31:46 <shachaf> Maybe I should ask about it at bacat in ~an hour!
17:31:51 --- mode: geekosaur set -o geekosaur
17:31:56 <geekosaur> guess freenode beat me to it
17:34:24 <blackdog> is there a way of baking "+RTS -N" in so i don't have to specify it on the command line?
17:34:45 <geekosaur> -with-rtsopts
17:35:18 <geekosaur> (probably also need -rtsopts)
17:35:39 <shachaf> I doubt you need -rtsopts for -with-rtsopts.
17:36:45 <blackdog> geekosaur: to cabal, or to ghc?
17:37:16 <shachaf> To ghc.
17:37:47 <blackdog> ok. so including it in ghc-options in cabal should do the trick
17:40:41 <IanMc> hi
17:41:00 <IanMc> are there really that many who program in haskell?
17:41:16 <joelteon> yeah
17:41:42 <shachaf> As many as four tens.
17:41:51 <KoF> I've been told that it's the language theorist's baby, so apparently it's reasonably popular.
17:41:59 <IanMc> I know it is promoted in universities, like Oxford
17:42:03 <KoF> With at least a certain subset of people.
17:42:07 <IanMc> but I didn't know it was that popular
17:42:33 <IanMc> 'the language theorist's baby' wow
17:43:06 <IanMc> I just looked at how many where on all the channels and this came nearly tops
17:43:12 <IanMc> were
17:43:57 <bitonic> @faq can Haskell be used?
17:43:57 <lambdabot> The answer is: Yes! Haskell can do that.
17:44:10 <IanMc> cool
17:44:12 <sellout-> IanMc: People lurk here just to make their /whois more impressive ;)
17:44:17 <KoF> I'd guess that the type of people who program Haskell are also the type of people who go on chatrooms like this.
17:44:31 <joelteon> yeah I like #haskell
17:44:36 <KoF> Not that I'm particularly informed.
17:44:51 <startling> KoF: more like the type of people who program haskell are the type of people with a lot of questions about haskell.
17:44:55 <IanMc> I knew a young student once, a chinese girl who went to ... trying to remember the college,, worcester, she was really good at math but got stumped by haskell
17:44:58 <KoF> Heh.
17:45:48 <KoF> Haskell's kind of weird. I remember that my traveling salesman solver was super unsatisfying because I knew exactly where all the recursion happenedin the call, but it really didn't look like it would really do it.
17:45:53 <IanMc> so alas she flunked, I tried to teach her about the thing we all know 'arrays' but I am not a good teacher
17:46:44 <IanMc> I had no idea that haskell was that popular
17:47:03 <IanMc> i presume its oop ?
17:47:38 <KoF> OOP is more of an imperative language thing, I think. Haskell is a functional language.
17:48:14 <startling> IanMc: there's no inheritance or classes (in the OOP sense) in haskell.
17:49:05 <IanMc> ok, I started with procedural language, eventually figured that oop was better, would you say that haskell has something even better?
17:49:29 <startling> I guess.
17:49:32 <KoF> Haskelll has something /completely different/.
17:49:38 <KoF> Whether it's better probably depends on what you're doing.
17:49:43 <IanMc> do you look at it from a point because you are really good at math?
17:50:07 <startling> Most of the reason I like math now is from having liked haskell.
17:50:14 <IanMc> where as I look at it from a point because I love computers but I'm really bad at math
17:50:21 <KoF> Most procedural languages are OOP now.
17:50:35 <KoF> But functional languages are kind of a completely different beast.
17:51:16 <IanMc> I'd probably have to get haskell, install it, find it bewildering, to get a better insight
17:51:18 <KoF> In general, there's few to no side effects, data isn't mutable, and recursion is used instead of looping.
17:51:39 <IanMc> I almost understood that
17:52:05 <IanMc> what's recursion again?
17:52:15 <KoF> Oh, and people use lists instead of arrays, usually....
17:52:24 <KoF> Recursion is a function that calls itself.
17:52:48 <IanMc> I've always thought that it should be the job of the language to figure out lists as in expandable arrays
17:53:02 <IanMc> without throwing exception errors for going out of bounds
17:53:22 <IanMc> recursion is like time travel, full of paradoxes
17:53:22 <blackdog> IanMc: to take a concrete example, in an OO or imperative language, if you wanted to compute the length of a list, you'd initialise a variable at 0, and then loop over the list until you came to the end, adding one each time.
17:53:35 <IanMc> yep
17:53:50 <KoF> I would keep explaining, but it is now foodtime.
17:53:57 <blackdog> in an FP language like haskell, you'd think about it inductively. An empty list has length 0, so you check if the list is empty. if so, return that.
17:54:00 <IanMc> ok, but thanks
17:54:08 <IanMc> FP ?
17:54:08 <blackdog> otherwise, the answer is 1 plus the length of the rest of the list.
17:54:15 <blackdog> functional programming
17:54:18 <IanMc> ok
17:54:21 <IanMc> thanks
17:54:54 <IanMc> I dabbled in a bit of machine code programming ya know, in my commodore 64 days :)
17:55:01 <amosr> and we have very clever compiler optimisations so that ends up as the same ugly/fast loop code, but you don't have to write it :-)
17:55:07 <blackdog> so that's a full solution - we have solved it for n=0, and the answer for n=k+1 is solved so long as we know it for n=k.
17:55:20 <flebron> (to nitpick: in an OO language, you'd send the list a message called "length", and it would reply with its length.)
17:55:46 <blackdog> amosr: begone with your filthy machine underpinnings, we are aloft in a world of pure semantics :p
17:56:02 <IanMc> back to silly old me.... hands up those who want to invent true AI ?
17:56:58 <IanMc> I mean a machine that takes on itself a true being, a sentience
17:57:01 <startling> IanMc, you should check out #lesswrong
17:57:27 <shachaf> IanMc: Do you have anything related to Haskell to say in here?
17:57:40 <IanMc> harsh
17:58:20 <hodapp> true AI... un-ironically wanting to invent it...
17:58:23 <hodapp> hmmm, maybe you want #lisp
17:58:44 <IanMc> I would like to learn why there are so many people in this channel and then yes I want to question them about haskell, it is obviously something that I have missed
17:59:16 <IanMc> do I have to ask questions about haskell or am I allowed to ask about asking about haskell ?
17:59:37 <shachaf> People are in this channel because they enjoy it. But they aren't here to talk about inventing true AI, or time travel. There are other channels for that.
17:59:53 <IanMc> do you censor what we can say ?'
18:00:00 <startling> yes.
18:00:02 <shachaf> No, don't ask to ask, or ask to ask to ask. If you have an on-topic question you should ask it.
18:00:07 * hodapp sighs, shuffles off, puts on kettle for tea.
18:00:10 <shachaf> Yes, I do.
18:00:26 <hodapp> at least it's not #java, at least it's not #c++.
18:01:03 <IanMc> I'm interested in haskell, and about why there are so many obviously very intelligent people in this channel, I'd like to stick around, I'll shut up if that's what you want
18:01:26 <amosr> @google learn you a haskell
18:01:26 <lambdabot> http://learnyouahaskell.com/
18:01:27 <lambdabot> Title: Learn You a Haskell for Great Good!
18:01:48 <IanMc> thanks! I'll have a look at that
18:02:03 <hodapp> IanMc: if you're curious about AI, have you also read about Lisp and some of its early history?
18:02:11 <IanMc> Elephants!
18:03:10 <IanMc> thanks hodapp
18:04:10 <IanMc> is there a 'haskell chat' channel?
18:04:41 <IanMc> where we can talk about elephants, time travel and the such?
18:04:54 <bitonic> IanMc: #haskell-blah
18:05:09 <IanMc> Thanks bitonic
18:05:46 <IanMc> thank you for your patience
18:09:12 <Licenser> Out of curiosity, does haskell compile to native binaries?
18:09:35 <shachaf> GHC compiles Haskell code to native machine code, yes.
18:09:47 <shachaf> (E.g. Hugs interprets Haskell code.)
18:10:03 <koala_man> what does ghci do?
18:10:05 <Licenser> ah cool :)
18:10:14 <startling> koala_man, it's complicated.
18:11:32 * Licenser is still looking for a problem to the haskel solution :P
18:18:08 <applicative> what problem is python or, say, java the solution to, Licenser ?
18:19:01 <Licenser> applicative they are great solutions when I would want to be depressed ;)
18:19:29 <startling> python is a good solution to getting the cpython vm to do what I want.
18:19:34 <byorgey> Haskell is a good solution for when you want to be really frustrated, followed by deliriously happy
18:20:06 <hodapp> I for one find Python to be wonderfully easy to do a lot of things in.
18:21:18 <hodapp> it's displaced MATLAB where I work for a lot of interactive analysis, text processing, prototyping, plotting, glue, general mathematics, and so on.
18:21:41 <Licenser> applicative I didn't meant to imply that haskel is missing problems to solve just that I want to learn it but don't yet see a problem I direction have at hand that I would apply haskel to as solution :) sorry just realized what I said could be understood badly :)
18:37:02 <fizbin> @type 1
18:37:03 <lambdabot> Num a => a
18:37:31 <jmcarthur> > 1 1
18:37:32 <lambdabot>   1
18:38:52 <arkeet> @type 1 `asAppliedTo` 1
18:38:53 <lambdabot> (Num t, Num b) => t -> b
18:39:02 <jmcarthur> :t (1 `asTypeOf` ?foo) 1
18:39:03 <lambdabot> (?foo::a -> t, Num a, Num t) => t
18:39:11 <arkeet> neat
18:39:18 <arkeet> I like that.
18:40:01 <jmcarthur> that instance of Num or the implicit params trick?
18:40:16 <arkeet> the latter
18:40:21 <arkeet> I don't like the former.
18:40:37 <jmcarthur> yeah, that's the first time i had used asTypeOf with the implicit param trick at the same time
18:40:54 <joelteon> @type undefined `asAppliedTo` undefined
18:40:55 <lambdabot> t -> b
18:42:50 <jmcarthur> i like the instance, too, though. i wish it got more love from everybody else
18:49:26 <covi> scala feels like an awkard copycat of haskell
18:49:35 <covi> Option, Some, None. Lol
18:49:44 <blackdog> covi: classic diss is "haskell fanfic" :)
18:50:04 <blackdog> (although i think that's stolen from tim chevalier's strangeloop diss...)
18:50:05 <covi> Lots of syntax are more verbose, regardless of having the same meaning as their Haskell counterparts
18:50:10 <fizbin> In some ways, scala is a little bit like haskell assembly.
18:50:36 <fizbin> Or at least, like something where you've expanded out some of the typeclass handling.
18:51:31 <fizbin> (since you can use implicit parameters in scala to simulate something very like Haskell's typeclasses)
18:52:17 <jmcarthur> covi: option/some/none occur in other languages, too, especially in the ML family
18:52:28 <DigitalKiwi> i was about to say
18:53:38 <jmcarthur> i am not a fan of either Just or Some. i prefer Nothing to None since the former doesn't seem to imply that the other case could be greater than one element or something
18:54:16 <jmcarthur> i prefer Maybe or Option since "option" could be useful for more other purposes
18:54:20 <jmcarthur> *Maybe to Option
18:54:38 <jmcarthur> so i guess haskell wins, for me
18:54:49 <jmcarthur> i don't know what i would prefer over Just or Some
18:55:04 <jmcarthur> Something would be a good dual to Nothing i guess
18:55:53 <josephle> jmcarthur: "Just" and "Some" seem to be chosen to be easy to say aloud
18:55:58 <josephle> "Some x" or "Just y"
18:56:54 <dmwit> NoThing, OneThing
18:57:05 <fizbin> I use enough python that None in my head means what Scala means by "null". That Scala also has a type called Nothing that means something completely different from the Haskell meaning of the characters "Nothing" is just mean.
18:57:11 <dmwit> dangit, missed a golden opportunity to suggest Yesthing
18:57:32 <fizbin> OneThing, TwoThing, RedThing, BlueThing
18:57:37 <covi> dmwit: lol
18:57:38 <jmcarthur> i defined an option-like type yesterday with Yes and No, actually
18:57:50 <jmcarthur> it was actually just a type witness, so Yes and No made a little more sense
18:58:07 <covi> Knowing basic Haskell and more Java, what else should I learn about Scala?
18:58:16 <jmcarthur> but it was intended to cover some of the use cases of option (this was in ocaml)
18:58:29 <fizbin> Scala's "Nothing" is kind of like Haskell's "Void".
18:59:00 <jmcarthur> we added a Nothing to the ocaml Core library recently with that meaning
18:59:21 <fizbin> covi: I respectfully submit that you'll get better answers to that question somewhere else.
19:00:00 <fizbin> jmcarthur: Was the ocaml Nothing a subtype of everything? That
19:00:09 <jmcarthur> covi: you should learn enough to make you sick, vomit, pass out, wake up with a hangover, and don't remember any of it
19:00:10 <fizbin> That's what scala's Nothing is.
19:00:19 <jmcarthur> fizbin: no, it's just an empty data declaration
19:00:37 <covi> jmcarthur: I started to feel in a less-exaggerated way.
19:00:42 <jmcarthur> it doesn't sound like scala's Nothing is like haskell's Void
19:01:16 <jmcarthur> covi: if you don't remember it then who's to say you didn't have fun? :)
19:01:22 <fizbin> True. Maybe it'd be better to say it's like Haskell's bottom? (aka, the type of _|_ )
19:01:33 <KoF> Huh. Scala/Haskell comparisons.
19:02:13 <jmcarthur> fizbin: i assume Nothing is observable though (i mean you can tell that a value is Nothing instead of just failing to terminate when you observe it)
19:02:20 <KoF> I used Scala imperatively rather than functionally when I learned it, though I know it's got some suppport for programming functionally...
19:02:40 <jmcarthur> fizbin: which is very different from _|_
19:03:29 <fizbin> jmcarthur: No; there are no values at runtime of type Nothing. The only way to have a function compile with Nothing as its declared return type is to have it unconditionally throw an exception.
19:03:40 <jmcarthur> KoF: i'm somewhat surprised (as one who has never very seriously used either scala or java) that you didn't just use java. does scala make for a good imperative language in ways that java doesn't?
19:03:53 <jmcarthur> fizbin: ah, then it does indeed sound much like _|_
19:04:00 <jmcarthur> fizbin: weird for a strict language to have such a thing, though...
19:04:21 <KoF> It has some stuff that's better for imperative, yes.
19:04:33 <no-n-> what does strict mean?
19:04:48 <dmwit> f is strict if f _|_ = _|_
19:04:56 <KoF> Off the top of my head, it's got a good xml parsing library and good multithreading.
19:05:23 <no-n-> dmwit, dunno what you mean, sorry
19:05:32 <jmcarthur> no-n-: informally: when you are talking about languages or evaluation orders, it's just the eager evaluation imperative programmers are mostly used to. evaluate the arguments, then apply functions and evalute that. etc.
19:05:49 <no-n-> ah, okay
19:05:55 <jmcarthur> no-n-: dmwit was giving a very specific definition of what it means for a function to be strict
19:06:04 <fizbin> jmcarthur: Not so weird. It's a bit of an odd corner in the type system, sure, but there's a nice symmetry in having it be the dual of the type Any. Any in scala is a superclass of every type. Nothing is a subclass of every type.
19:06:29 <jmcarthur> no-n-: basically, _|_ means "some expression that doesn't terminate"
19:06:34 <KoF> Though, the primary reason I was taught Scala was just because my professor wrote a Scala textbook. :P
19:06:55 <jmcarthur> no-n-: so f _|_ = _|_  means that f applied to something that doesn't terminate itself does not terminate... that's what it means for f to be strict
19:07:30 <jmcarthur> no-n-: whereas if f was a non-strict function, it would still terminate
19:07:46 <KoF> http://www.amazon.com/Introduction-Programming-Chapman-Textbooks-Computing/dp/1439896666
19:08:20 <jmcarthur> no-n-: strictness of functions really only makes sense to talk about at all in a language that supports, at least in part, some sort of non-strict evaluation order, since otherwise *every* function is strict anyway
19:08:42 <no-n-> I don't know what you mean by an expression terminating
19:08:44 <fizbin> Coursera had a pretty awesome scala functional programming course last fall. You might still be able to sign up and watch the videos. (You'll need some other way to evaluate your work on the exercises, but the nice thing about programming is that you usually know if you succeeded without another human telling you)
19:09:00 <jmcarthur> no-n-: here is an example of an expression that does not terminate:
19:09:04 <jmcarthur> > sum [1..]
19:09:10 <lambdabot>  Terminated
19:09:11 <jmcarthur> no-n-: (when evaluated)
19:09:13 <no-n-> okay
19:09:31 <b2coutts> haha, I like how lambdabot says "Terminated", as if to contradict you
19:09:35 <jmcarthur> no-n-: so to say that f is not strict is to say that it does not have to evaluate that argument in order to return its result
19:09:40 <jmcarthur> b2coutts: haha
19:09:46 <no-n-> I get it
19:10:16 <jmcarthur> > let f = const True in f (sum [1..])   -- this f is non-strict
19:10:25 <no-n-> ye
19:10:31 <lambdabot>   thread killed
19:10:33 <jmcarthur> lambdabot...?
19:10:35 <jmcarthur> > let f = const True in f (sum [1..])   -- this f is non-strict
19:10:42 <jmcarthur> well, it should return True
19:10:48 <lambdabot>   True
19:10:52 <jmcarthur> thank you
19:11:03 <joelteon> > let f !x = True in f (sum [1..])
19:11:11 <lambdabot>  Terminated
19:11:13 <jmcarthur> > let f x = x in f (sum [1..])   -- this f is strict
19:11:29 <lambdabot>   thread killed
19:14:14 <hodapp> hrm, RWH mentions that foldl is rarely used in practice because of how much space it takes up to run, but they don't say the same of foldr, and I'm trying to get a sense for why this is
19:14:33 <jmcarthur> hodapp: there are three main folds for list to consider here
19:14:41 <dmwit> > let f x = error "foo" in f (sum [1..]) -- this f is strict, even though it doesn't even touch its argument!
19:14:41 <jmcarthur> hodapp: foldr, foldl, and foldl'
19:14:46 <lambdabot>   *Exception: foo
19:14:49 <jmcarthur> hodapp: let's consider them in turn
19:15:14 <jmcarthur> hodapp: foldr is interesting because it is "productive"
19:15:20 <hodapp> jmcarthur: what does 'productive' mean?
19:15:25 <jmcarthur> bout to explain
19:15:58 <jmcarthur> hodapp: what i mean by that is that if you are folding a properly lazy function over a list, the result can be lazily generated, incrementally
19:16:02 <jmcarthur> example:
19:16:16 <jmcarthur> > foldr (++) "" ["foo", "bar", "baz", undefined]
19:16:19 <lambdabot>   "foobarbaz*Exception: Prelude.undefined
19:16:36 <jmcarthur> hodapp: see how it was able to generate results *before* reaching undefined?
19:16:55 <jmcarthur> hodapp: those results are actually available for other computations
19:17:02 <jmcarthur> hodapp: because foldr can generate results lazily
19:17:31 <jmcarthur> hodapp: also, if the results are only used once, the garbage collector can follow along and clean up behind us
19:17:36 <hodapp> jmcarthur: what makes a function 'properly lazy'?
19:17:42 <jmcarthur> hodapp: so in fact, we could sometimes even end up not using much space
19:18:09 <hodapp> jmcarthur: I have some hazy idea why it works in your case with it being a list, but not a sharper notion
19:18:29 <jmcarthur> hodapp: the answer to that is complicated, but in general that just means that it takes a bounded or constant amount of work to produce each part of the result
19:18:57 * hackagebot bmp 1.2.5.2 - Read and write uncompressed BMP image files.  http://hackage.haskell.org/package/bmp-1.2.5.2 (BenLippmeier)
19:19:06 <jmcarthur> hodapp: (++), for example, can produce its head without computing its tail first
19:20:10 <jmcarthur> hodapp: foldl, in contrast, works roughly the way a tail recursive function might work in a strict language, except that it does it very poorly due to some issues with the usual evaluation strategy for haskell
19:20:54 <hodapp> strict as in strict/eager evaluation, I assume?
19:20:56 <jmcarthur> hodapp: so, not only do you lose the benefits of laziness, but you also lose the benefits of strict tail recursion. the reason is that the accumulator isn't forced as you go along, so it accumulates this big chain of thunks that just has to be evaluated at the end anyway
19:21:02 <jmcarthur> yes
19:21:22 <jmcarthur> i'm getting a little ahead, but you can still ask questions about stuff from earlier
19:21:44 <jmcarthur> hodapp: finally, we get to foldl', which is just foldl, but it forces the accumulator to be evaluated as it goes
19:22:30 <hodapp> their example just uses (+) as the function, which I'm guessing is not 'properly lazy'; it's a bit easier to get with something like (++)
19:22:30 <jmcarthur> hodapp: basically just to get around some awkwardness that results from trying to use tail recursion lazily (by simply not doing it lazily)
19:22:44 <jmcarthur> yeah, (+) is (for most types) a strict function
19:23:09 <jmcarthur> in the sense that f _|_ = _|_ is a strict function, as explained just before you asked your question
19:24:11 <copumpkin> is f _ = undefined a strict function? :)
19:24:17 <dmwit> yes
19:24:19 <jmcarthur> i claim that it is
19:24:25 <jmcarthur> trivially, even
19:24:30 <copumpkin> just making sure!
19:24:45 <hodapp> so, for instance, you could foldr over an infinite list provided that the function is properly lazy? even if it might be silly to
19:24:56 <tikhonjelvis> it's not necessarily silly, even
19:25:03 <jmcarthur> hodapp: "properly lazy" is not a formal term, by the way
19:25:11 <dmwit> > and (False:repeat True)
19:25:11 <tikhonjelvis> e.g. if you're folding an infinite list into another infinite list
19:25:12 <lambdabot>   False
19:25:16 <dmwit> ?src and
19:25:16 <lambdabot> and   =  foldr (&&) True
19:25:17 <jmcarthur> hodapp: but yeah, you got it right, except that it's not silly at all
19:25:30 <jmcarthur> tikhonjelvis: when do you start?
19:25:41 <copumpkin> at the end
19:25:43 <tikhonjelvis> I started on monday, actually
19:25:45 <dmwit> ^^ You can foldr over an infinite list, and it's not silly to want to do that.
19:25:50 <jmcarthur> oh. did i just miss you entirely?
19:25:56 <copumpkin> omg I know where tikhonjelvis works
19:25:58 <hodapp> well, whatever example I conjure up for doing it would probably end up being silly, but I'm sure it's a legitimate means of things
19:26:10 * copumpkin is so clever
19:26:15 <tikhonjelvis> maybe
19:26:17 <jmcarthur> hardyharhar
19:26:27 * jmcarthur knows where copumpkin works!
19:26:32 <copumpkin> shit
19:26:33 <tikhonjelvis> I haven't had that much time to get anything done thanks to paperwork and stuff
19:26:44 <jmcarthur> :(
19:26:49 * dmwit knows where work lives!
19:26:57 * copumpkin knows where dmwit dmwits
19:28:03 <hodapp> jmcarthur: alright, that makes some more sense. Thanks.
19:28:20 <dmwit> > foldl f z [w,x,y]
19:28:21 <lambdabot>   f (f (f z w) x) y
19:28:40 <dmwit> Why this sucks: we have to walk down the whole list before we know the second argument to the inner-most f.
19:29:05 <copumpkin> so much hate for the lefties :(
19:29:08 * copumpkin hugs foldl
19:29:11 <jmcarthur> hodapp: say i want the first 100 natural numbers divisible by x. i don't have to precompute the largest possible number and only generate numbers that high. i can simply generate an infinite list of numbers, filter them, and take the first 100 results
19:29:21 <dmwit> no wait
19:29:27 <jmcarthur> (not that that is the most efficient way to go)
19:29:47 <tikhonjelvis> if you want a more practical example, I recently wrote an emulator for some esoteric hardware
19:29:51 <copumpkin> is there a haskell library that could help me write my own email server?
19:29:57 <jmcarthur> > take 100 . filter (\x -> x `mod` 7 == 0) $ [0..]
19:29:57 <copumpkin> I just need it to forward email :P
19:29:59 <lambdabot>   [0,7,14,21,28,35,42,49,56,63,70,77,84,91,98,105,112,119,126,133,140,147,154...
19:30:00 <tikhonjelvis> the neat bit is that I can just return a list as a program trace
19:30:21 <tikhonjelvis> and the user can decide how far to "run" the program by looking at only a portion of the trace
19:30:44 <dmwit> copumpkin: main = writeFile "/home/copumpkin/.forward" "copumpkin@copumpkin.com"
19:30:44 <mm_freak> copumpkin: you could modernize my ismtp library =)
19:30:46 <jmcarthur> copumpkin: don't do that
19:30:48 <jmcarthur> copumpkin: trust me
19:30:53 <jmcarthur> :)
19:31:06 <tikhonjelvis> you could start from the ground up using some network library :)
19:31:13 <jmcarthur> definitely don't do that
19:31:17 <copumpkin> jmcarthur: well, I want to host a server that forwards addresses based on programmatic criteria
19:31:36 <jmcarthur> if you can just use gmail filters then you should do that
19:31:36 <dmwit> Yes, starting with a network library is cheating. Start with a breadboard.
19:31:45 <copumpkin> I can't
19:31:50 <hodapp> hrm, so, if you are working with foldl', and you had a properly lazy function, and you're only examining particular values - is that still 'productive' in some cases? It looks like 'no' to me but I'm trying to be certain.
19:31:51 <jmcarthur> if not, you should find some other way to not do the hard work
19:31:57 <jmcarthur> emails servers suck to write
19:32:02 <copumpkin> jmcarthur: the whole goal is to make spam suck less :)
19:32:11 <hodapp> tikhonjelvis: that is an interesting use of laziness that I'd not have thought of...
19:32:32 <tikhonjelvis> once you get used to it, it'll come naturally
19:32:37 <tikhonjelvis> at least that's what I've found myself
19:32:37 <jmcarthur> copumpkin: couldn't you just write a plugin for some existing server?
19:32:57 <copumpkin> perhaps, I just wanted to write something simple and focused
19:33:02 <tikhonjelvis> now when writing OCaml I have to sometimes remind myself that it's strict :P
19:33:14 * hodapp jots that down.
19:33:27 <jmcarthur> hodapp: foldl and foldl' don't return their results until the very end. you can see this syntactically, since the only case that isn't a recursive call is []
19:33:33 <mm_freak> copumpkin: that's impossible for SMTP
19:33:38 <jmcarthur> hodapp: so there is not really anything you can do with the result until the whole thing has run
19:33:40 <copumpkin> :P
19:34:20 <copumpkin> the goal is to have a scheme along the lines of humanreadable-a34gaf3cy@copumpk.in
19:34:23 <copumpkin> where the second part is a MAC
19:34:24 <mm_freak> copumpkin: your best bet is to write a postfix milter or similarâ€¦  that may actually be a haskell program
19:34:26 <copumpkin> and I don't want to use the +
19:35:29 <Clint> what's wrong with +
19:35:29 <copumpkin> I want to give every service I sign up for a distinct email address (that they can't sanitize and have reach me anyway) so I can track who's leaking them
19:35:38 <copumpkin> and block leaked addresses
19:36:01 <Clint> i do this by hand and it seems futile
19:36:01 <copumpkin> Clint: if I have foo+bar@gmail.com, and you were a smart spammer, you'd just strip off the +bar before adding me to your list
19:36:01 <mm_freak> copumpkin: for that i'd just use postfix
19:36:09 <wavewave> hi
19:36:16 <Clint> copumpkin: ah, i see
19:36:24 <Clint> i thought you meant + vs. -
19:36:49 <jmcarthur> copumpkin: the trick is to always give out addresses with + and just filter out the ones that *don't* have it :P
19:36:50 <copumpkin> my goal is to create an unstrippable +, basically, noting that email addresses for receiving and email addresses for sending are often have very different needs
19:37:13 <Clint> they all seem to get sold eventually
19:37:15 <copumpkin> jmcarthur: then I'd have a whitelist of allowed +s that I still need to enforce programmatically
19:37:46 <jmcarthur> copumpkin: sure
19:37:49 <copumpkin> Clint: yeah, but I want to know who does it, so if I get spam at foo-123asfjakl4@mysite.com I can look up that second component and find out that I signed up for xyz.com with it
19:37:56 <jmcarthur> but at least it's a whitelist instead of a blacklist
19:38:04 <copumpkin> my other thing is a whitelist too
19:38:21 <copumpkin> I'd just remove things from it as they got leaked, while publicly shaming the sites that leak the addresses
19:38:37 <jmcarthur> ha, automated public shame
19:38:39 <Clint> copumpkin: ah, well, i haven't tried publicly shaming
19:39:07 <copumpkin> but the basic idea is that they can't just make stuff up and have it reach me. They need to use the address I gave them
19:39:20 <copumpkin> and if they do that, I can know who tehy are
19:39:32 <hodapp> ...is public-shaming a good approach to get coworkers to quit saying "We aren't solving any of those problems!" when I try to show what problems functional languages can help a lot with?
19:39:45 <copumpkin> public shaming is always a good answer
19:40:02 <copumpkin> praise in private, shame in public
19:40:05 <Clint> right, all you need to do is maintain a virtual alias db
19:40:10 <copumpkin> yeah
19:40:21 <copumpkin> what I want is basically that
19:40:27 <mm_freak> then we finally know which of copumpkin's favorite porn sites are most leaky
19:40:37 <copumpkin> exactly
19:41:18 <mm_freak> anyway, if you don't want this project to be a never-ending story, i recommend using something that already exists
19:42:21 <mm_freak> postfix can do something like thatâ€¦  my approach would be to forward emails with that pattern to my regular mail address, perhaps with an additional X-header set
19:42:39 <copumpkin> yeah, not sure I even need an additional header really
19:42:45 <Clint> you don't really need the extra header; it already puts it in Received
19:42:46 <mm_freak> you don't =)
19:43:03 <copumpkin> and the other observation is that I almost never have to send email from addresses I give to sign up for things
19:43:18 <copumpkin> so it's not as if I have to set up a crapload of aliases on gmail
19:43:30 <mm_freak> but an additional X-header is easier to parse than the Received-header and more trustworthy than the To header
19:43:45 <copumpkin> fair enough
19:43:57 <Clint> i have 381 of these
19:43:58 * Clint sighs.
19:45:50 <mm_freak> also you need human intervention to decide whether a mail is actually spamâ€¦  the e-mail address, not even the domain, are insufficient criteria
19:46:31 <confound> since To: is completely untrustworthy, I would say almost anything is more so
19:47:18 <mm_freak> the only trustworthy header is the most recent Received header
19:47:22 <confound> right
19:47:55 <confound> it can tell you that you should possibly trust some of the others
20:40:58 <hoqhuuep> Can anyone help me understand why these types cannot be inferred? http://pastebin.com/krbyxr7A
20:41:03 <mauke> The paste krbyxr7A has been copied to http://hpaste.org/89394
20:44:34 <argiopeweb> I'm using Hspec to write test cases, but I'm having trouble deciding what to do with my modules. On the one hand, I can export only top-level functionality (my preferred method), but that keeps me from testing individual functions. On the other hand, I can export everything, but that becomes messy from an information hiding/haddock point of view. Is there a middle ground I'm missing?
20:44:58 <johnw> hoqhuuep: the type of (!) turns an a and b into a c.  There is no way to know that the Show instances of a and b have anything to do with the Show constraint of c.  Even though you have one instance for which that's clearly true, it's not guarantee by your type class method
20:45:11 <enthropy> hoqhuuep: instances aren't chosen based on "here's one that can work, so use it". That's to keep sanity, since otherwise adding some imports could change the result
20:47:15 <enthropy> one way around it would be have less parameters in the class, or use extensions like -XFunctionalDependencies or -XTypeFamilies
20:48:07 <enthropy> which will allow you to reduce the number of possible instances that could be written, which will let ghc pick the instance you want with less annotations
20:49:24 <hoqhuuep> johnw, enthropy: thanks! I think I understand a bit more now :)
20:59:34 * tabemann is looking up type families to see what they are
21:00:13 <td123> does anyone have any suggestions on what libraries to look into for creating a rest api that will pretty much provide crud operations?
21:01:02 <td123> I googled, but got a bunch of articles from 2009/10. they're great, but maybe there's something else that came along
21:01:28 <Clint> you could try to forward-port yesod-vend or one of the other ones
21:40:18 <hoqhuuep> @ty \f x -> ($x) <$> f
21:40:26 <lambdabot> Functor f => f (a -> b) -> a -> f b
21:40:48 <hoqhuuep> is there a nicer way to express that function?
21:41:53 <hoqhuuep> @pl \f x -> ($x) <$> f
21:41:53 <lambdabot> flip ((<$>) . flip id)
21:45:53 <hoqhuuep>  @djinn Functor f => f (a -> b) -> a -> f b
21:51:43 <josephle> ?djinn a -> a
21:51:44 <lambdabot> f a = a
21:51:56 <josephle> yep, use ?
21:52:09 <hoqhuuep> ?djinn Functor f => f (a -> b) -> a -> f b
21:52:09 <lambdabot> Error: Class not found: Functor
21:52:12 <hoqhuuep> ta
21:56:16 <arkeet> @djinn Functor f => f (a -> b) -> a -> f b
21:56:17 <lambdabot> Error: Class not found: Functor
21:56:34 <arkeet> the problem was you had a space before @
21:56:50 <josephle> doesn't help his problem though :(
21:56:55 <hoqhuuep> ah, right thanks
22:30:26 <adnap> Can I send GHCI output to a file within the REPL?
22:32:05 <adnap> I guess I could use Haskell libs
22:32:30 <cmears> writeFile "my-output" $ ...
22:32:31 <adnap> No... I don't know how to write the output of the REPL though
22:33:03 <adnap> Currently, I want to grep the output of ":browse Module"
22:33:08 <cmears> ah
22:33:26 <adnap> Or, if there is an alternative to this that makes sense...
22:34:12 <cmears> echo ":browse Data.List" | ghci
22:34:18 <cmears> might be good enough
22:34:23 <cmears> (you can redirect the output)
23:02:44 <hamid> guys, I want to rewrite this c++ code in haskell within a stream of "fooling around" numbers. http://ideone.com/pCCs8e
23:04:44 <hamid> I just got a headache because of all thinking of lists and etc :P
23:05:04 <johnw> what is your question?
23:06:44 <hamid> johnw, it's a stream like : 1 2 4 7 12 20 33 ...
23:07:23 <notdan> hamid: judging from your code you want something like a queue?
23:07:29 <notdan> You can use Data.Sequence or Data.Deque
23:08:16 <hamid> notdan, Not the code was just for showing the logic behind the "stream" that I want to write in haskell.
23:08:21 <hamid> s/not/no/
23:08:33 <johnw> still waiting on a question
23:08:47 <hamid> notdan, I'm not capable of writing the STREAM guys!
23:09:55 <Ghoul_> Sigh transformers 3 or 4 deep are so confusing
23:09:57 <hamid> johnw, did you see the code? and comments on top of it? I want to produce those "fooling around" numbers in stream (haskell streams )
23:10:10 <johnw> the fact that you want to do that isn't something I can help with
23:10:22 <johnw> when you have a specific question about Haskell, I'm all ears
23:11:00 <hamid> johnw, that's my question! how can I write such a thing in haskell :|
23:11:18 <hamid> johnw, anyway. thank you :)
23:11:29 <johnw> that would require more research that I want to do, but I wish you luck
23:11:39 <Ghoul_> Lol
23:11:42 <mm_freak> Ghoul_: that's what you get the mtl type classes for
23:12:13 <Ghoul_> Ughh yeah but mostly nested conduit stuff
23:12:20 <Ghoul_> Painful no matter how
23:13:00 <Ghoul_> With an upper StateT ReaderT I have trouble dropping
23:13:18 <notdan> hamid: can you turn the for cycle into recursoin?
23:13:22 <notdan> *recursion
23:13:34 <mm_freak> Ghoul_: that's no problem while writing computations:  f :: (MonadState S m, MonadReader E m) => m X
23:13:49 <mm_freak> Ghoul_: only the run* function really needs to be aware of the actual monad stack
23:13:51 <notdan> hamid: if you have stream :: [Int], can you compute joined, left, next :: Int ?
23:13:52 <hamid> notdan, Yes. I think so.
23:14:19 <Ghoul_> Hmm I should learn what that actually brings to the table
23:14:22 <notdan> Ok. The "fooling around" numbers are just the 'next' values
23:14:28 <Ghoul_> I'm only familiar with monad io
23:14:29 <notdan> in each run of the cycle
23:14:37 <hamid> notdan, yes. exactly
23:14:51 <notdan> hamid: ok, so what is exactly your problem with the code?
23:15:02 <mm_freak> Ghoul_: http://hub.darcs.net/ertes/cascading/browse/Data/CSS/Build.hs
23:15:03 <Ghoul_> Sorry on swipe keyboard not always logical letter case or spacing
23:15:07 <mm_freak> see the importUrl function
23:15:13 <notdan> go ahead and write it down if you want to
23:15:40 <mm_freak> Ghoul_: i know i need showURL and tell there, so i express the proper constraint
23:16:10 <hamid> notdan, I'll try it now. thanks. I just saw the fibonacci seq in stream in wiki and they just comfused me. how they work :|
23:16:12 <Ghoul_> That's handy
23:16:31 <Ghoul_> Means everything is more generic I guess
23:16:40 <mm_freak> Ghoul_: exactly
23:16:46 <Ghoul_> Do you still bed to lift many times?
23:16:55 <mm_freak> Ghoul_: usually i never lift
23:16:55 <Ghoul_> To for example get to io
23:17:05 <Ghoul_> Ah
23:17:24 <mm_freak> Ghoul_: liftIO is the only exception there, to get the types right
23:17:39 <hamid> notdan, the problem is the next number depends on 3rd previous number in the list.
23:17:47 <supki> > let xs = 0:0:1:zipWith3 (\a _ c -> 2 * c - a) xs (tail xs) (tail (tail xs)) in xs
23:17:48 <lambdabot>   [0,0,1,2,4,7,12,20,33,54,88,143,232,376,609,986,1596,2583,4180,6764,10945,1...
23:18:02 <notdan> hamid: well in order to write the code smarter you actually have to understand the problem. fibbonacci seequence have a well-defined equation etc
23:18:04 <mm_freak> Ghoul_: but then for most applications you don't need too many liftIOs
23:18:24 <notdan> hamid: well you keep the list with 3 numbers?
23:18:32 <notdan> I dont see the problem here
23:18:40 <TravisD> I don't want to give up on FP or Haskell, but I'm finding that the time it takes me substantially longer to write code, and I feel like I don't understand what I write as well as in other languages. Do any of you have tips for getting over the initial hurdle? I have a pretty strong background in math and I am comfortable with a lot of the category theoretic parts of the language, but that doesn't seem to help me much when I just want t
23:18:40 <TravisD> sit down and get something working
23:18:54 <TravisD> s/the time//
23:19:03 <notdan> mm_freak: I don't know, I use 'lift' frequently
23:19:28 <TravisD> Part of the reason I'm asking is that I've been stuck at this stage for a pretty long time now
23:19:50 <notdan> mm_freak: sometimes you have monads that are not MonadState/Reader/Writer
23:20:04 <mm_freak> TravisD: my suggestion is to write a nontrivial applicationâ€¦  don't bother to find the most elegant solution in the beginningâ€¦  you can always improve later
23:20:09 <Ghoul_> Like conduit
23:20:25 <mm_freak> notdan: those monads are MonadWhatever
23:20:26 <Ghoul_> Which is hellish for me as a beginnerr
23:20:33 <mm_freak> notdan: like MonadRoute in the example i linked
23:20:38 <mm_freak> it's from web-routes
23:21:02 <startling> TravisD, do you understand Reader, Writer, and State?
23:21:25 <TravisD> startling: I haven't looked at reader too closely, but I understand Writer and State
23:21:37 <mm_freak> TravisD: have you implemented Writer and State?
23:21:44 <Ghoul_> What's good for tracking the seek in file reading
23:21:44 <startling> TravisD: could you reimplement them as functions wrapped in newtypes?
23:21:52 <Ghoul_> State T?
23:21:54 <startling> ^ what mm_freak says
23:21:59 <hamid> supki, that's what I want :D but I really I have to try to understand it. ;) thank you
23:21:59 <TravisD> mm_freak: I implemented a monad for generating random numbers which was a special case of State
23:22:19 <TravisD> mm_freak: And I implemented Writer as part of some exercises from Real World Haskell
23:22:22 <hamid> :t zipWith3
23:22:23 <lambdabot> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
23:22:58 <TravisD> startling: Isn't that the usual implementation of State?
23:22:59 <mm_freak> TravisD: State and Writer are eye-openers by themselvesâ€¦  and it's eye-opening to discover that Reader E is isomorphic to (->) E
23:23:27 <mm_freak> > (do x <- id; y <- sin; return (x, y)) 5
23:23:29 <lambdabot>   (5.0,-0.9589242746631385)
23:23:42 <mm_freak> > runReader (do x <- get; y <- gets sin; return (x, y)) 5
23:23:44 <lambdabot>   No instance for (Control.Monad.State.Class.MonadState
23:23:44 <lambdabot>                     t...
23:23:52 <mm_freak> > runReader (do x <- ask; y <- asks sin; return (x, y)) 5
23:23:54 <lambdabot>   (5.0,-0.9589242746631385)
23:24:42 <mm_freak> Ghoul_: either State Int or Writer Int
23:24:51 <mm_freak> (or Int64 to be more portable)
23:25:18 <mm_freak> Writer (Sum Int)
23:25:36 <mm_freak> the Writer variant is very elegant, but you need to get used to it
23:26:35 <mm_freak> TravisD: to encourage you, i went through the same struggleâ€¦  nowadays i write haskell like i used to write C =)
23:26:49 <startling> yeah, there's definitely a bump.
23:26:54 <TravisD> mm_freak: That sounds pleasant :)
23:26:59 <startling> TravisD: lenses are another thing to dive into
23:27:14 <Ghoul_> Asks is cool
23:27:58 <mm_freak> TravisD: if you're really confident that you understand the RWS group of monads, now is the time to implement their transformer variants
23:28:03 <TravisD> startling: Yeah, I want to understand lenses (at least well enough to use them). Right now some of my code is really ugly because it picks apart data structures
23:28:33 <mm_freak> TravisD: start with this one:  newtype WriterT l m a = WriterT { runWriterT :: m (a, l) }
23:29:05 <mm_freak> implement Functor, Monad and Applicative, then implement 'tell' and 'listen' as defined by mtl's WriterT
23:29:41 <startling> :t tell
23:29:43 <lambdabot> MonadWriter w m => w -> m ()
23:29:45 <startling> :t listen
23:29:46 <lambdabot> MonadWriter w m => m a -> m (a, w)
23:30:03 <TravisD> I'll have to read a bit about monad transformers first
23:30:09 <startling> in other words, implement MonadWriter
23:30:15 <TravisD> but that sounds like a good exercise
23:30:38 <mm_freak> TravisD: there isn't much to readâ€¦  just read the type definitionâ€¦  you should be able to understand the difference between Writer and WriterT
23:31:08 <mm_freak> while State s a denotes a function of type s -> (a, s), StateT s m a denotes a function of type s -> m (a, s)
23:31:17 <mm_freak> @unmtl StateT S M A
23:31:17 <lambdabot> S -> M (A, S)
23:31:33 <shachaf> I,I s -> (s, a)
23:32:03 <hamid> supki, lazy evalution helps that code to get executed in O(N). right?
23:33:51 <startling> it's not O(n), is it?
23:33:52 <Ghoul_> State = state
23:33:57 <Ghoul_> Woops
23:34:18 <Ghoul_> State = StateT Identity I think
23:34:27 <mm_freak> State s = StateT s Identity
23:34:31 <hamid> > let xs = 0:0:1:zipWith3 (\a _ c -> 2 * c - a) xs (tail xs) (tail (tail xs)) in xs
23:34:32 <lambdabot>   [0,0,1,2,4,7,12,20,33,54,88,143,232,376,609,986,1596,2583,4180,6764,10945,1...
23:34:35 <Ghoul_> Yeah that's the one
23:35:22 <hamid> lots of tails I see but it's probably generating each element in O(1)
23:36:12 <hamid> startling, I'm just guessing blindly :|
23:36:13 <Ghoul_> Gotta be careful ghc doesnt handle that as you'd expect atm
23:36:18 <Ghoul_> See trac
23:36:39 <Ghoul_> I don't know what cases it affects though
23:37:03 <mm_freak> hamid: to give a running time you need to ask a more specific question
23:37:13 <mm_freak> asking for the n-th element is in O(n)
23:37:17 <mm_freak> (as far as i see)
23:37:24 <hamid> mm_freak, yed
23:37:28 <hamid> yes :|
23:38:07 <startling> does sharing help with computational complexity?
23:38:13 <no-n> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in fib
23:38:15 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:38:20 <startling> I guess not, because it's 1x rather than 3x
23:38:36 <startling> no-n: heh
23:38:53 <mm_freak> hamid: i don't understand your ":|"
23:38:59 <mm_freak> O(n) is reasonable
23:39:17 <Ghoul_> Very
23:39:23 <mm_freak> unless you find a closed formula
23:39:35 <hamid> mm_freak, Is that because of lazy evaluation? right? cause I see more calls to xs.
23:39:35 <startling> hamid, anyway, I think the deeper point is that laziness makes that algorithm *possible*
23:39:51 <startling> I don't think it makes it any computationally simpler, though.
23:39:59 <mm_freak> hamid: it's because of the way you defined the list
23:40:19 <mm_freak> hamid: think about it:  asking for the n-th element in a list takes O(n) in generalâ€¦  you can't get faster than that
23:40:55 <mm_freak> hamid: to understand the strictness properties of your code you should always ask yourself this question:  "what happens when i pattern-match?"
23:41:01 <hamid> mm_freak, yes but i expected O(N^3 ) :P
23:41:28 <startling> hamid, why?
23:41:52 <mm_freak> hamid: intuitively it's O(c*n) for some constant c, but that's equivalent to O(n) ;)
23:41:59 <blackdog> any tips on tracking down why i'm getting huge amounts of data PINNED in a heap profile?
23:42:23 <carlo5m> I have a question I need answered are you guys willing to answer it for $$/
23:42:23 <carlo5m> ?
23:42:28 <startling> recursive calls only contribute to computational complexity when they depend on the n, right?
23:42:35 <Walther> mm_freak: ...with what implementation of lists can you get nth element of a list in O(n)? I thought in linked lists you have to scroll through the entire list
23:42:38 <hamid> startling, cause it just makes me think that every call to xs makes another loop over it!
23:42:52 <Walther> mm_freak: of course if the list is stored as array/table, but...
23:43:00 <startling> hamid: it does! but that has nothing to do with n
23:43:32 <joelteon> anybody use wizards here? how do you force a Wizard to fail/retry?
23:43:53 <Walther> Also, I'm not sure if it fits the channel rules (don't answer if you don't feel like it), but how are actual real-life uses of Haskell - is it mostly academic, or are some of you actually getting paid to code in Haskell?
23:44:01 <startling> joelteon: twist their arms and threaten to break their staves?
23:44:15 <joelteon> ok
23:44:19 <joelteon> what else
23:44:35 <johnw> Walther: several are us are paid to work in Haskell, yes; it is quite appropriate to any task
23:44:39 <hamid> startling, I see :)
23:44:39 <blackdog> Walther: i'm building a webscraper in haskell for money.
23:45:25 <mm_freak> Walther: think about it:  what's the complexity of 'head'?
23:46:10 <mm_freak> Walther: haskell lists are not linked lists in the same sense as linked lists in C++
23:46:13 <joelteon> ok, that works actually
23:46:14 <joelteon> woohoo
23:46:40 <mm_freak> Walther: i'm programming haskell for a living
23:46:55 <joelteon> anybody happen to know if it's possible to remove the Maybe from a Wizard's return type?
23:47:07 <joelteon> like, if it fails, it'll retry, and the only way the user can get out of the loop is by interrupting
23:47:21 <startling> joelteon, you could do that trivially
23:47:22 <notdan> amortized complexity is hard  :(
23:47:27 <Ghoul_> Does adding more monads and not using them make 'thing' slower?
23:47:40 <joelteon> startling: which one
23:48:00 <Ghoul_> It just increases the size of the box, right?
23:48:02 <johnw> Ghoul_: do you mean monad transformers when you say "adding"?
23:48:20 <Ghoul_> Yes
23:48:21 <startling> joelteon, whatever = do x <- somethingElse; case x of Nothing -> whatever; Just x -> return x;
23:48:32 <joelteon> yeah, but
23:48:39 <startling> joelteon: yeah but what?
23:48:48 <johnw> it's hard to answer that simply, because the compiler is able to make many kinds of things "disappear" in the optimizer; some monads do make things slower, some vanish, some don't
23:48:48 <joelteon> run :: Wizard f a -> b (Maybe a)
23:48:52 <joelteon> so I guess not, then
23:49:03 <startling> joelteon: oh, that's slightly different
23:49:12 <startling> joelteon: what's b?
23:49:15 <johnw> you would have to do performance analysis to know
23:49:18 <joelteon> oh, it's a long ass type signature
23:49:19 <joelteon> hang on
23:49:25 <Ghoul_> But if you don't use it, it should never see the light of day
23:49:40 <Ghoul_> Or is it seen in do sugar?
23:49:40 <startling> Ghoul_: I suspect newtype makes it a lot cheaper
23:50:07 <joelteon> run :: (Monad b, Functor f, System.Console.Wizard.Internal.Run b f) => Wizard f a -> b (Maybe a)
23:50:27 <Ghoul_> Can someone explain how adding more monads adds more code if you don't use them?
23:50:35 <ktosiek> Ghoul_: remember that all transformers change what >>= means
23:50:38 <Ghoul_> Even if it might get optimized away
23:50:39 <startling> joelteon: well, write a System.Console.Wizard.Internal.Run b f that calls run repetetively
23:50:43 <Ghoul_> Ah
23:50:46 <joelteon> haha :(
23:50:53 <mm_freak> Ghoul_: adding Identity doesn't change the performance â€” in theory
23:51:06 <mm_freak> the run-time representation of a newtype is exactly that of the type it implements
23:51:07 <Walther> mm_freak: Hm, so lists are implemented in similar fashion as in python then? lists are arrays and deques/dicts are linked lists :P
23:51:14 <johnw> FreeT can make performance terrible I hear
23:51:26 <mm_freak> Walther: no, you need non-strict semantics to get haskell lists
23:51:31 <startling> Walther: no, lists in haskell are linked lists
23:51:39 <mm_freak> Walther: finite, completely evaluated lists are linked lists
23:51:59 <mm_freak> infinite or unevaluated lists may not be present in memory at all
23:52:10 <mm_freak> johnw: that's true
23:52:17 <Walther> and lazy-evaluated possibly infinite lists are treated as ...what?
23:52:28 <mm_freak> Walther: you're thinking very operationally
23:52:29 <Ghoul_> Magic
23:52:30 <Walther> if you're promising O(n) for retrieving nth element of a list
23:52:41 <Walther> mm_freak: Oh yes I am, I'm very new to Haskell
23:53:07 <mm_freak> Walther: when inspecting a haskell data structure it is most helpful to understand how it behaves when pattern-matched against
23:53:15 <mm_freak> example:  ones = 1 : ones
23:53:37 <Walther> and just passed an interesting course on data structures and algorithms, but oviously the course was pretty much revolving around C, java, python etc
23:53:44 <joelteon> okay and now what do I do if I want to combine a State and a Wizard?
23:53:50 <joelteon> should I wrap the Wizard in a StateT?
23:54:04 <mm_freak> Walther: such a definition is really just that:  a definition
23:54:20 * Walther nods
23:54:21 <mm_freak> the memory representation is only determined when you pattern-match against 'ones'
23:54:50 <mm_freak> when you pattern-match 'ones' against x : xs, what's x?
23:55:17 <Walther> ah, the malloc only happens when you say "take 50 ones" -> allocates a finite array for 50 ones (...obviousyl there's probably better optimization behind this but yeah)
23:55:30 <mm_freak> forget malloc or arraysâ€¦  answer the question
23:55:31 <mm_freak> what's x?
23:55:50 <Walther> infinite list of "ones"?
23:56:09 <hamid> @src head
23:56:09 <lambdabot> head (x:_) = x
23:56:09 <lambdabot> head []    = undefined
23:56:12 <mm_freak> no, match 'ones' as defined by "ones = 1 : ones" against the pattern "x : xs"
23:56:14 <mm_freak> what's x?
23:56:24 <mm_freak> (just read the definition)
23:56:37 <Walther> 1
23:56:40 <mm_freak> and xs?
23:56:43 <Walther> ones
23:56:49 <mm_freak> how long does it take to determine that?
23:57:13 <Walther> O(n) (unless you're slow like me)
23:57:17 <hamid> mm_freak, as long as you pattern match against?
23:57:18 <mm_freak> no, O(1)
23:57:23 <Walther> ...derp, O(1)
23:57:31 <Walther> slow morning today :D
23:57:36 <joelteon> that's because it's midnight
23:57:38 <joelteon> :)
23:57:39 <mm_freak> there you goâ€¦  you just understood infinite lists =)
23:58:09 <mm_freak> Walther: the reason is that the actual underlying implementation won't be anywhere near what you would expect in a language like C
23:58:22 <mm_freak> GHC haskell doesn't even use a call stack
23:58:32 <Ghoul_> They are the same as c with indefinite base pointers...
23:58:42 <mm_freak> so you should think in terms of definitions and pattern matching instead of machine instructions
23:59:35 <mm_freak> hamid: i didn't understand your question
23:59:52 <hamid> mm_freak, 11:35 < mm_freak> how long does it take to determine that?
23:59:58 <hamid> mm_freak, as long as you pattern match against?
