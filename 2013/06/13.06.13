00:26:28 <Reite> How can I compose Aesons (.:) functions before I apply them? So that I can do this point free: myfunc a = a .: "foo" >>= (.: "bar")
00:26:56 <shachaf> If you can't figure it out by yourself, you probably shouldn't be putting it in your code.
00:27:12 <Reite> :/
00:27:22 <shachaf> Hmm, maybe that came across as overly rude.
00:27:30 <Reite> Ive tried like 10 different ways
00:27:42 <shachaf> Even if you *can* figure it out by yourself, you probably shouldn't be putting it in your code. It makes it hard to read.
00:28:06 <shachaf> I spent a bit wondering what (.: "bar") meant, but it turns out to be a type error.
00:28:22 <shachaf> Oh, maybe (.:) isn't the lambdabot (.:).
00:28:33 <shachaf> I guess it's not.
00:28:39 <shachaf> OK, maybe it's not so bad, then.
00:28:54 <Reite> http://hackage.haskell.org/packages/archive/aeson/0.6.0.2/doc/html/Data-Aeson-Types.html#v:.:-63-
00:28:55 <shachaf> I still have no idea what you're trying to accomplish, though, so I can't help. :-)
00:30:04 <Reite> Just rewrite myfunc so it doesnt need the explicit a
00:30:20 <Reite> (a .: "foo") :: Parser Object
00:30:31 <Reite> (.: "bar") :: Object -> Parser a
00:30:42 <shachaf> Oh.
00:30:48 <shachaf> @pl myfunc a = a .: "foo" >>= (.: "bar")
00:30:51 <lambdabot> myfunc = id (fix (const (flip ((>>=) . (.: "foo")) (.: "bar"))))
00:30:51 <lambdabot> optimization suspended, use @pl-resume to continue.
00:31:04 <shachaf> OK, I recommend not doing it.
00:31:08 <Reite> well thats pretty ugly :P
00:31:09 <frerich> :-))
00:31:11 <Reite> Guess I wont do it then
00:31:16 <shachaf> Hmm.
00:31:19 <shachaf> No, that's broken.
00:31:20 <Reite> I thought there might be a pretty way
00:31:25 <shachaf> @pl-resume
00:31:31 <lambdabot> myfunc = id (fix (const (flip ((>>=) . (.: "foo")) (.: "bar"))))
00:31:31 <lambdabot> optimization suspended, use @pl-resume to continue.
00:31:36 <shachaf> @pl foo x = x + x
00:31:37 <lambdabot> foo = join (+)
00:31:53 <shachaf> @pl \ a -> a .: "foo" >>= (.: "bar")
00:31:56 <lambdabot> flip ((>>=) . (.: "foo")) (.: "bar")
00:31:56 <lambdabot> optimization suspended, use @pl-resume to continue.
00:32:12 <shachaf> @ask elliott what's going on with @pl. (and also @where prefix)
00:32:12 <lambdabot> Consider it noted.
00:36:53 <supki> isn't it  (.: "foo") >=> (.: "bar")  ?
00:38:30 <Reite> supki signature looks correct, il try it
00:39:21 <Reite> supki: Exactly what I was looking for, and ofc. its beautiful! Thanks :D
00:54:03 <akamaus> is there something like System.FilePath but for URLs?
00:54:13 <johnw> PathPieces is one
00:54:32 <johnw> @hackage path
00:54:32 <lambdabot> http://hackage.haskell.org/package/path
00:54:35 <johnw> @hackage path-pieces
00:54:35 <lambdabot> http://hackage.haskell.org/package/path-pieces
00:54:53 <johnw> hmm.. that doesn't have the API I remembered
00:54:54 <johnw> n/m
00:56:05 <joelteon> :t id . fix . const
00:56:07 <lambdabot> c -> c
00:56:11 <joelteon> oh, duh
00:58:14 <akamaus> johnw, looks like path-pieces is for parsing the pieces of urls, and I'm looking for operations like path catenation, getting the domain,path,query of the url and so. Network.URI partly fits.
00:58:25 <Bor0> @src foldl
00:58:25 <lambdabot> foldl f z []     = z
00:58:25 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
01:00:24 <akamaus> oh, there is also Text.URI in uri package
01:35:00 <supki> can I have GADTs without implicit existential quantification? data T a where T :: b -> T Int  not raising an error is pretty annoying.
01:35:51 <shachaf> Why would it raise an error?
01:36:20 <shachaf> (Note that the letter "a" is entirely irrelevant there. It's not scoped like a regular ADT declaration.)
01:36:21 <supki> I would like to have something like "b is not in scope"
01:36:28 <supki> yes
01:36:35 <shachaf> There is no scope, though.
01:36:46 <shachaf> You want an error because "b" isn't mentioned in the return type?
01:39:35 * hackagebot nemesis 2013.6.13 - a Rake like task management tool  http://hackage.haskell.org/package/nemesis-2013.6.13 (JinjingWang)
01:39:39 <supki> I actually didn't realize there is no scope at all
01:39:51 <supki> OK, I don't understand gadts then :[
01:40:05 <shachaf> data T :: * -> * where ... would be the same thing.
01:40:16 <shachaf> Or data T :: k -> * or something.
01:40:28 <shachaf> All you give in a GADT is the type of the constructor.
01:41:23 <shachaf> That has all the necessary information. If a type variable is used but not mentioned in the return type, then it's existential.
01:46:02 <adnap> It seems that it is possible to name a file with a module whatever you want if you specify the filename as an argument to GHC. What are the consequences of naming files differently from the name of the module they contain?
01:48:03 <supki> shachaf: OK, I withdraw my question then, since it only makes sense for my imaginary gadts
01:51:24 <quchen> So in `data T a where T :: a -> T a`, the first "a" has nothing to do with the other ones? Trying to make sure I understand that "no scope" statement
01:51:55 <quchen> Is that a little like having no ScopedTypeVariables, but on type level?
01:52:18 <dreixel> quchen: I guess you can think of it like that, yes
01:52:20 <quchen> (Well, "but on a different type level")
01:52:37 <dreixel> I prefer never to use type variables on the declaration of a GADT
01:52:46 <dreixel> data T :: * -> * where T :: a -> T a
01:53:13 <dreixel> (this prob requires -XKindSignatures... or maybe that's implied by -XGADTs...)
01:53:26 <shachaf> It's not a different type level. It's the same type level.
01:54:28 <shachaf> There are two places where Haskell98 has scoped type variables: data type declarations and class declarations.
01:54:54 <shachaf> But anyway, yes, data T :: * -> * where ... is the same as data T a where ...
01:57:21 <quchen> shachaf: What I meant with that was that the problem that scoped type variables solve is typically in a function's type and in its where clauses, whereas here we're declaring a type constructor.
01:57:55 <quchen> But I see what you mean.
01:57:57 <t7> does haskell RT use generational GC?
02:01:15 <shachaf> But it's the same level.
02:01:20 <quchen> Yes.
02:06:32 <kosc> Hello
02:06:39 <Botje> GREETINGS
02:06:55 <kosc> I've got a trouble with infix synonym for fmap
02:07:00 <kosc> Prelude> (+3) <$> (Just 5)
02:07:00 <kosc> <interactive>:4:6: Not in scope: `<$>'
02:07:11 <johnw> import Control.Applicative
02:07:13 <Botje> you need to import Control.Applicative for that
02:07:37 <kosc> Oh. thanks a lot!
02:07:54 <shachaf> @where hoogle will help with things like that.
02:07:54 <lambdabot> http://haskell.org/hoogle
02:11:20 <simukis_> `type Template m a = Monad m => (String -> m String) -> a -> m Text.Blaze.Html` and I'm getting `Illegal polymorphic or qualified type`. Could anyone explain what I'm doing wrong here?
02:11:57 <Botje> I don't think you're allowed to put constraints in type aliases
02:12:28 <simukis_> oh. Right. Thanks :)
02:15:17 <sopvop> well you can
02:15:29 <sopvop> type Getter s a = forall f. (Contravariant f, Functor f) => (a -> f a) -> s -> f s
02:15:58 <sopvop> But that needs some extensions I think
02:16:16 <simukis_> probably XRankN(2)Types
02:16:41 <simukis_> that's what ghc suggested me…
02:17:56 <gspr> How much overhead is there to STRefs? While inside the ST monad, are readSTRef and writeSTRef close to reading at a memory location specified by a pointer in other languages?
02:18:21 <shachaf> gspr: Yep.
02:18:44 <gspr> shachaf: Great. Thanks.
02:19:48 <gspr> shachaf: I was a bit worried after reading http://lists.lurk.org/pipermail/haskell-art/2011-July/000571.html
02:19:50 <frelux> is there any way to specialize Text.Printf.printf to always add a newline and return IO ()? (short of me finally understanding the beautiful black magic that makes it work : ) )
02:20:02 <pxqr> I trying to locate a space leak but without no luck. Is there a way to take snapshots of the heap ?
02:20:31 <pxqr> by heap I mean all the heap, not a particular expression/thunk/whatever
02:20:44 <pxqr> or dump it some way
02:21:41 <johnw> pxqr: that would indeed be pretty handy
02:22:25 <shachaf> gspr: Yes, an IO/STRef (they're the same thing) won't go in a register, it'll be a boxed value in memory somewhere, like that post says.
02:22:39 <pxqr> as far as I can see both ghc-heap-view and vacuum can't do this for the all heap
02:22:50 <shachaf> You can get better performance from GHC than STRef in some specific cases.
02:23:16 <gspr> shachaf: Right. So instead of thinking of them as pointers, I should perhaps think of them as pointers to pointers?
02:23:44 <shachaf> Well, they're pointers to boxed Haskell values.
02:24:02 <Botje> (the boxes are for the lambdacats)
02:24:05 <shachaf> Which in turn do give you another layer of indirection.
02:26:01 <gspr> Right. Hmm… this is my first time working with a completely "non-functional" data structure in haskell. I really need the ability to re-point pointers and so forth. The extra layer of indirection sounds kinda bad performance-wise
02:26:57 <shachaf> Well, there are possibly various other things you can do.
02:27:14 <shachaf> STRefs do have more overhead than you might hope for...
02:27:49 <gspr> So, this project is highly centered around this iffy data structure, *but* I'd still prefer to stay in Haskell, because a lot of the things that go around it all can be made pure
02:28:00 <yitz> hmm kosc left already. but <$> is actually in Data.Functor. Control.Applicative just re-exports it.
02:28:01 <gspr> s/pure/functional/
02:28:10 <johnw> is a CInt an unboxed type?
02:28:20 <shachaf> I'm looking at the generated code for a simple STRef thing and it's worse than I expected.
02:28:29 <shachaf> No.
02:28:44 <gspr> shachaf: I tried to look at it aswell, but I'm really bad a reading GHC's output assembly :p
02:30:04 <gspr> shachaf: There's no monad for unboxed pointer-to-value?
02:30:48 <johnw> gspr: how many operations are you doing, that it makes that much difference?
02:32:00 <gspr> johnw: Well, the algorithm is far from complete, but the dominating operations will *essentially* be walking and cutting/pasting in a graph-like structure
02:32:19 <gspr> johnw: And I know not to consider performance too early - but really, it is of the essence here
02:32:25 <shachaf> There are various other ways you can write things. For example you can use an unboxed array, or the various FFI functions to do things with memory addresses directly, and so on.
02:32:39 <gspr> johnw: If it hadn't been for the fact that I've come to love haskell so much, this is the kind of thing I'd surely write in C
02:32:55 <gspr> shachaf: Yeah, I might have to end up doing that :/
02:33:09 <dncr> On quad-core, this parMap gives a 2x speed-up; how would I get closer to 4x?  https://github.com/dancor/one-off/blob/master/hs-par-lines/ProcData.hs
02:33:48 <dncr> By chunking the list I'm mapping over into fewer-and-larger tasks to parallelize?
02:34:08 <johnw> have you use threadscope yet?
02:34:14 <dncr> no
02:34:36 <johnw> i highly recommend googling for "haskell threadscope", for tricks on finding out how to optimize these types of things
02:34:58 <johnw> it could very well be that you're hitting an overhead walk by sparking too many threads, but threadscope eliminates the guesswork
02:35:03 <johnw> s/walk/wall
02:35:07 <dncr> ok thank you
02:38:51 <johnw> dncr: http://www.youtube.com/watch?v=kFrAqWLHUDo
02:39:02 <johnw> dcoutts has some really excellent presentations on this stuff
02:39:11 <johnw> both in slide, article on video form
02:39:42 <pxqr> is it known issue? http://hpaste.org/89858
02:40:48 <Botje> don't you need the BangPatterns extension for that?
02:40:50 <supki> pxqr: ?
02:41:01 <supki> pxqr: that code tries to define operator (!)
02:41:02 <johnw> Botje: yep
02:41:12 <pxqr> oh yes
02:41:26 <pxqr> i just tired >.<
02:41:37 <dncr> ok, but i'm not very optimistic as in the past i've had some large tool thrown at me (e.g. heap profiling graph) when in fact I may need more help developing an initial elementary sense of do/don't (e.g. a good starting point is having all record fields strict but functions lazy).
02:42:38 <tomejaguar> What is "<-" called?
02:43:17 <Kinnison> I call it "comes from"
02:43:22 <Kinnison> I imagine it has a real name
02:43:30 <srhb> I don't think it does.
02:43:32 <Cale> It's an arrow
02:43:33 <tdammers> I call it "left arrow" :P
02:43:36 <merijn> tomejaguar: Usually "bind", as it is syntactic sugar for the operator >>= (which is called bind)
02:44:00 <tdammers> merijn: what about list comprehensions?
02:44:13 <srhb> Same thing?
02:44:14 <Cale> tdammers: It's technically the same as bind there too
02:44:16 <merijn> tdammers: What do you think <- is in a list comprehension?
02:44:26 <Cale> (bind for lists)
02:44:27 <tdammers> hmm, yeah
02:44:32 <tdammers> true that
02:44:43 <merijn> "[x | x <- xs]" == do { x <- xs; return x }
02:44:58 <tdammers> for some reason, though, I tend to read list comprehension as "x for x in xs"
02:45:19 <merijn> Sure
02:45:39 <Kinnison> I read it as "x given x comes from xs"
02:45:40 <shachaf> I think there's an implicit "in" on the xs itself, not on the <-
02:46:09 <shachaf> If we used a newtype for [] like we do for Reader and Writer, we would have newtype Nondet a = Nondet { runNondent :: [a] } or something silly like that.
02:46:18 <tdammers> also I may have had a bit too much python
02:46:19 <shachaf> And then you would say [x | x <- choose xs]
02:46:26 <shachaf> (Where choose = Nondet.)
02:47:38 <pxqr> johnw: does threadscope suitable for concurrent programs or only parallel?
02:47:53 <johnw> it works for anything that uses threads
02:48:01 <johnw> so, both
02:49:26 <Cale> It suitables every of the time. ;)
02:50:22 <johnw> lol
03:14:40 * hackagebot ghc-make 0.1 - Accelerated version of ghc --make  http://hackage.haskell.org/package/ghc-make-0.1 (NeilMitchell)
03:14:51 <johnw> ooh
03:15:07 <hamid_> accelerated hmm
03:16:27 <johnw> well, "only in the case where there is no work to do"
03:16:44 <johnw> it makes doing nothing faster!
03:17:21 <supki> ghc program can be used as an alternative to ghc --make
03:20:35 <Lethalman> I bet it's done with Shake
03:20:42 <johnw> yep
03:21:09 <Lethalman> now, ghc-parmake is really interesting
03:22:02 <Lethalman> it's what I was looking for so far through ghc options
03:22:13 <Lethalman> now I have to see how to feed that to cabal!
03:28:36 <johnw> you have to hack the cabal sources
03:28:46 <johnw> i actually did it, but I wasn't happy enough with the result
03:37:05 <alpounet> johnw, in what regard?
03:37:17 <alpounet> would be interested to check out the sources, if that's public
03:44:23 <Bor0> @src @src
03:44:24 <lambdabot> Source not found. Whoa.
03:44:30 <Bor0> @src :t
03:44:30 <lambdabot> Source not found.
03:45:27 <johnw> alpounet: i didn't keep the change, and I don't quite remember; but it was a trivial change to make, if you're interested in going that route
03:46:12 <alpounet> johnw, i was wondering how annoying ("not at all" is a possible answer) it was to make that change
03:46:18 <johnw> not at all
03:46:21 <johnw> took me i think 15 mins
03:46:39 <johnw> you just hack it to use ghc-par instead of ghc in the right places
03:46:59 <johnw> and there was another change needed, like adding the -j if -j had been passed, or something like that
03:47:36 <dafds> lol spion
03:47:43 <dafds> anaffiliated lol
03:52:28 <alpounet> johnw, alright. so, didn't give satisfactory results?
04:02:16 <merijn> Maybe we should disallow unregistered pasting to hpaste? The recent pastes list looks...bad
04:02:57 <merijn> And it is time for my daily haskell layout poll: http://hpaste.org/89868
04:03:05 <merijn> Pick your favorite, or suggested a preferred one
04:04:41 <merijn> I'm indenting line continuations like here by half an indent, but I'm unsure where I should leave the where clause in this scenario
04:10:17 <bitonic> merijn: second, obviously
04:10:29 <bitonic> who the hell uses the first?  never seen that
04:13:45 <merijn> bitonic: I was trying to figure out how to deal with some edge condition in auto-indent
04:14:37 <merijn> bitonic: Normally I avoid lining up where with the line above it, i.e. any of these: http://hpaste.org/89872
04:15:00 <bitonic> merijn: I don’t do hanging dos
04:15:21 <merijn> The problem is, that I avoid lining up by dedenting where half an indent. If a line continuation is already only indented half an indent, that's not possible, so I was trying to figure out how to handle that case
04:15:49 <bitonic> merijn: are you writing an editor?  I think the best way is to have a ‘stupid’ algorithm that just tries to align stuff
04:15:51 <merijn> bitonic: Well, the auto indent also works with non-hanging do's, but in that case you don't run into this issue anyway, as there will always be room to dedent there
04:15:57 <bitonic> and cycle through alignments
04:15:59 <bitonic> (with tab)
04:16:05 <merijn> bitonic: I'm writing a vim auto-indent script for haskell
04:16:07 <bitonic> like Agda mode’s
04:16:29 <bitonic> merijn: so you’re writing an Haskell pretty-printer?
04:16:39 <bitonic> and parser possibly ehe
04:16:53 <merijn> bitonic: No, vim only supports making line based decisions >.>
04:17:21 <merijn> The goal is to make it do sane auto indentation for a styles I find acceptable, the rest is SOL :p
04:17:24 <bitonic> merijn: I really suggest writing something stupid that just speeds up the user’s decision
04:17:38 <tdammers> just to confuse you, I annotated with my own preferred style
04:17:41 <tdammers> http://hpaste.org/89868
04:17:48 <bitonic> having an (line-based!) Haskell indenter always do the right thing is impossible
04:17:50 <merijn> bitonic: It's already quite far along, and it's working rather nice, actually
04:17:56 <tdammers> feel free to ignore me
04:18:06 <merijn> bitonic: It doesn't have to always do the right thing, I agree that is impossible
04:18:23 <merijn> bitonic: It has to do the right thing when people write "sane" layouts
04:18:53 <merijn> Where sane is defined as "those I approve of" :p
04:19:01 <bitonic> merijn: oh well, OK.  it’s probably something similar to the fancy indentation mode for emacs
04:19:16 <merijn> bitonic: Yes, that's what I'm trying to establish, yes
04:19:26 <bitonic> I personally don’t like that one anymore
04:19:39 <bitonic> if you code following its style it’s fine, otherwise very irritating
04:19:40 <merijn> Lining up | and = in data declarations, lining up type signatures that are multiline, etc.
04:20:07 <bitonic> well for example trying to indent = and |s with 4 spaces results in a bag of fail, with emacs
04:20:16 <bitonic> it insists aligning the constructors with the data type name
04:20:24 <bitonic> same for module imports
04:20:26 <bitonic> *exports
04:21:04 <merijn> bitonic: Sure, I'm not claiming the auto-indent will be un-opinionated
04:21:28 <bitonic> I can understand an opinionated indenter aligned with your opinions ehe
04:21:31 <merijn> In fact, it's *very* opinionated about making people follow styles I like, if people disagree they're welcome to implement their own ;)
04:29:28 <supki> merijn: I annotated with that I use
04:30:34 <supki> oh, the second then
04:30:58 <supki> It's hard to think in 4-space indentation =[
04:34:28 <fruitFly> Hey i ddn't exactly get why this is at the end?
04:34:29 <fruitFly> ghci> sequence (map print [1,2,3,4,5])
04:34:29 <fruitFly> 1
04:34:29 <fruitFly> 2
04:34:29 <fruitFly> 3
04:34:29 <fruitFly> 4
04:34:30 <fruitFly> 5
04:34:34 <fruitFly> [(),(),(),(),()]
04:34:55 <Jaxan> fruitFly: it the return value of sequence (map print [1,2,3,4,5])
04:35:04 <merijn> fruitFly: :t sequence
04:35:07 <merijn> :t sequence
04:35:08 <lambdabot> Monad m => [m a] -> m [a]
04:35:09 <fruitFly> Jaxan: yes
04:35:14 <gpampara> print returns (), hence the result
04:35:17 <merijn> :t map print [1..]
04:35:17 <gpampara> :t print
04:35:19 <lambdabot> [IO ()]
04:35:20 <lambdabot> Show a => a -> IO ()
04:35:47 <merijn> fruitFly: print returns IO (), so "map print" returns [IO ()], and sequence returns "IO [()]
04:35:56 <merijn> You're probably looking for
04:35:58 <merijn> :t sequence_
04:35:59 <lambdabot> Monad m => [m a] -> m ()
04:36:20 <merijn> Self-pimping time!
04:36:35 <merijn> https://github.com/merijn/haskellFoldIndent <- now with support for where blocks and better record syntax support!
04:37:01 <fruitFly> I haven't even gotten to monads yet, but ok... so it's like [print 1, print 2, print 3] then it evaluates them--printing to the screen and they leave those brackets in the list lol... i think I get it
04:37:11 <merijn> unfortunately still no let/in plus some other warts, but all in all it should be usable for actually writing code with!
04:37:29 <merijn> fruitFly: I recommend using :t in ghci a lot and looking at the return types
04:37:40 <fruitFly> merijn: yes, will do
04:38:03 <merijn> fruitFly: While you're at it, also inspect the types of mapM, mapM_ and sequence_ and see how they fit in your code
04:38:17 <fruitFly> merijn: yes Sir
04:40:03 <fruitFly> man what the hell r monads... and monoids? he just started talking about them in the input out chap of lyah, should I look into them now?
04:42:56 <merijn> fruitFly: I'd recommend the following: focus on understanding type signatures and typeclasses, ignore monads and monoids and keep reading LYAH until all becomes clear
04:43:02 <mikeplus64> have there been any benchmarks of hmatrix vs linear vs ... ?
04:43:24 <fruitFly> merijn: alright, thanks :)
04:43:47 <mikeplus64> i /guess/ hmatrix will be faster since it's based on Storable vectors but could be wrong
04:54:34 <alpounet> mikeplus64, it's not really comparable
04:54:41 <alpounet> linear only implements low dimensional linear algebra
04:56:18 <alpounet> so basically, you have: data V a = V !a ; data V2 a = V2 !a !a  ; data V3 a = V3 !a !a !a; data V4 a = V4 !a !a !a !a and that's it
04:56:44 <alpounet> otherwise it just uses Data.Vector.Vector for higher dimensional vectors
04:56:53 <alpounet> (it wasn't there a few months back I think, thus my second statement)
04:57:08 <alpounet> anyway, if license isn't an issue for you, probably go with hmatrix
05:04:45 * hackagebot yesod-auth-pam 1.0.0.0 - Provides PAM authentication module  http://hackage.haskell.org/package/yesod-auth-pam-1.0.0.0 (KazuoKoga)
05:06:40 <mikeplus64> alpounet: it's annoying that with hmatrix i have to define so many trivial functions, e.g. magnitude of a vector, normalize
05:07:44 <mikeplus64> everything except the kitchen sink :)
05:10:24 <alpounet> mikeplus64, aren't these covered?
05:10:53 <alpounet> all the type classes and modules make it a bit difficult to have a good overview of what you can do on a matrix or a vector
05:11:11 <alpounet> but I'm pretty sure the magnitude, for example, is implemented
05:12:15 <alpounet> mikeplus64, don't get me wrong though. there are several people including myself who really care about having a better, permissively-licensed linalg library
05:12:46 <alpounet> half of my haskell code is for math/AI, i really would love a comprehensive, consistent and fast linalg library
05:17:15 <Aetherspawn> https://ccplz.net/threads/need-help-with-writepointer.54802/#post-705750
05:17:22 <Aetherspawn> woops, crap, irc client fail
05:21:27 <mikeplus64> alpounet: i can't find them, no :(
05:25:43 <Zariel> I have a function (ByteString -> Maybe Record) and i need to call it in IO, how can I wrap it in IO? ie (ByteString -> IO (Maybe Record)) ? (if thats what I need to do)
05:27:39 <Botje> just use a let
05:27:44 <Peaker> Zariel, what do you mean?  Is your function effectful? Or just called in an effectful context?
05:27:50 <Botje> let blah = function foo
05:28:09 <Botje> (which is equivalent to blah <- return (function foo), but less noisy)
05:28:12 <Zariel> Peaker: called from IO context
05:28:22 <Zariel> Peaker: it is not effectful
05:28:28 <Peaker> Zariel, the type of your function shouldn't change because of the context it is called from
05:28:46 <Peaker> Zariel, just use it from anywhere you want in its pure form
05:31:53 <Gracenotes> do you want to fail in IO if the Record doesn't exist? Or does the Maybe-ness of the type there not matter?
05:31:55 <lpsmith> If you have newtype NewT a = NewT { unNewT ::  a }, does na
05:31:59 <lpsmith> If you have newtype NewT a = NewT { unNewT ::  a }, does an
05:32:08 <Gracenotes> ...maybe
05:32:47 <lpsmith> If you have newtype NewT a = NewT { unNewT ::  a }, does anybody know offhand if GHC is smart enough to optimize (map NewT) and (map (unNewT)) to id?
05:33:11 <lpsmith> (sorry for the junk,  my keyboard was acting funny.)
05:33:21 <Botje> NewT does not exist at runtime.
05:33:44 <mauke> lpsmith: I don't think it is
05:33:50 <luite_> she turned me into a NewT
05:34:06 <Gracenotes> there's gotta be a rule for map id -> id, yeah?
05:35:29 <lpsmith> luite_, i got better ;-)
05:36:24 <Gracenotes> "map"       [~1] forall f xs.   map f xs                = build (\c n -> foldr (mapFB c f) n xs)
05:36:28 <Gracenotes> "foldr/id"            foldr (:) [] = \x  -> x
05:36:45 <Gracenotes> I dunno that much about the RULES system, but it seems a priori plausible
05:37:03 <Gracenotes> er... hm... no, missing a step
05:37:19 <Gracenotes> I guess there's always unsafeCoerce :p
05:37:26 <lpsmith> =)
05:37:50 <Gracenotes> either way, map id has got to be mad efficient at runtime, even if GHC doesn't erase it
05:38:32 <lpsmith> Somebody should improve Data.Fixed, the code there is naive enough that I found it worthwhile to unsafeCoerce it back to an Integer
05:38:34 <Gracenotes> one can always look at IRs to double-check
05:38:35 <luite_> Gracenotes: if it isn't optimized away, it will allocate all the (:) constructors again
05:39:16 <Gracenotes> I don't think GHC allocates every constructor on the heap/stack
05:39:37 <Gracenotes> but yeah, it's extra work
05:39:52 <spatialul> TAKE YOUR FREE 20GB OF CLOUD STORAGE NOW !!!  https://copy.com?r=ELUhyu
05:40:21 --- mode: ChanServ set +o mauke
05:40:22 --- kick: spatialul was kicked by mauke (no)
05:40:24 <shanse> AWESOME
05:41:44 <Gracenotes> nice try, government agency
05:41:44 <joe9> I want to use parsec to read a data structure (x,y), where both x and y are between 1 and 5. Any suggestions on what would be a good data structure to represent it, please? Array with bounds? or, implement the bounds checker in parsec?
05:41:47 <Peaker> nice, #haskell is similarly sized to #python :)  It used to be that way, then smaller, then for the longest time I didn't check...
05:42:22 --- mode: mauke set -o mauke
05:44:18 <Gracenotes> lpsmith: actually though, if you compose mapping newtype/unnewtype in source code with other operations, GHC might well fuse it
05:53:30 <mentis> joe9: data Bounded = ONE | TWO | .. | FIVE  type XY = (Bounded, Bounded)
05:53:47 <Gracenotes> lpsmith: okaaay.. I was curious enough to verify this. Even in -O2, GHC doesn't optimize away map unFoo
05:53:58 <mentis> and construct in the parser appropriate Xy data
05:54:28 <Gracenotes> unFoo itself is very simple, just a register operation and a jump
05:55:35 <Gracenotes> and it does seem to be fused with adjacent maps
05:57:17 <lpsmith> hmm :-/
05:58:04 <Gracenotes> er, wait, the unFoo I'm looking at is actually just a function of the datatype I declared
05:58:08 <Gracenotes> arg
05:58:11 <Gracenotes> Cmm is confusing
05:59:48 * hackagebot air-extra 2013.6.13 - air-extra  http://hackage.haskell.org/package/air-extra-2013.6.13 (JinjingWang)
06:00:53 <aleator_> Would anyone be willing to participate in a small, 5min, experiment on teaching haskell?
06:00:55 <Gracenotes> Yeah, so unFoo appears nowhere in the main function, when compiled with -O2; it mainly seems required for the interface file
06:01:21 <Gracenotes> I am going to stop poking around in things for which I only have marginal knowledge, like GHC optimization
06:02:10 <mauke> aleator_: will it hurt?
06:02:25 <aleator_> mauke: Most definately!
06:02:37 <mauke> that spelling does, yes
06:02:57 <aleator_> mauke: Sorry. I'm non native and have bad habits.
06:03:03 <Gracenotes> dishin it today, mauke
06:03:05 <mauke> do people also write "infinaty"?
06:03:37 <aleator_> Well, english is the cobol of spoken languages..
06:12:07 <dgpratt> I guess I see English as more the C++ of spoken languages
06:12:35 <joe9> mentis, thanks.
06:13:17 <hodapp> dgpratt: As an English speaker, I resent that.
06:13:45 <dgpratt> hodapp: :)
06:14:18 <Gracenotes> English doesn't have that much boilerplate, though. Pretty simple case analysis in theory, very ad-hoc and irregular in practice.
06:15:10 <dgpratt> I take it back -- I just realized English is the JavaScript of spoken languages
06:15:19 <hodapp> I'd go more with Perl.
06:15:46 <Gracenotes> I think Perl is perfect. Wall was a linguist, after all.
06:15:54 <Gracenotes> (as an analogy)
06:15:58 <companion_cube> chinese would be a better fit for the perl of natural languages
06:16:02 <companion_cube> at least for the written part
06:16:12 <akamaus> can I use Data.Encoding from encoding package to get a Text right from Bytestring, without intermediate String?
06:16:14 <dgpratt> only problem is you can pretty much avoid Perl if you want to
06:16:24 <Gracenotes> companion_cube: I think Chinese is more the J/APL of natural languages
06:16:45 <Gracenotes> really there are many possible properties of any pair that map and don't map...
06:17:28 <companion_cube> so which language is the haskell of natural languages? german? :p
06:17:43 <supki> akamaus: what's wrong with Data.Text.Encoding?
06:17:46 <dgpratt> Esperanto? :)
06:17:47 <Gracenotes> readability, terseness, popularity, word order strictness, irregularity, conjugation/declension, ...
06:18:38 <akamaus> supki, my bytestrings aren't in UTF. I need to decode a cp1251 for example.
06:18:54 <Gracenotes> politeness, even
06:21:16 <akamaus> encoding perfectly worked for me, but now I'm going to move to Text from Strings.
06:21:53 <fizbin> akamaus: I was going to ask if 'encoding' was sufficient for your needs or if you needed text-icu
06:22:19 <edwardk> heh lens is a substring of declension thats why that highlighted
06:23:37 <supki> yeah, took a while to figure it out
06:23:55 <pxqr> what does mean STACK in heap profile report?
06:24:22 <fizbin> So you'll also get pinged if we talk about the Russian city of Smolensk?
06:24:29 <edwardk> apparently
06:24:49 * hackagebot nemesis-titan 2013.6.13 - A collection of Nemesis tasks to bootstrap a Haskell project with a focus on continuous integration  http://hackage.haskell.org/package/nemesis-titan-2013.6.13 (JinjingWang)
06:26:26 <fizbin> Or if I talk about needing my wife's instructions to figure out how to properly launder these woolens that… well, I can't imagine why I'd be dealing with woolens in the summer, but...
06:26:30 <edwardk> Or if you want to talk about flensing or Hawaiian selensulpher
06:27:50 <edwardk> or the different pollens in the air, the Cullens from twilight, the hills and glens, or if you split the channel into the chipper and the sullens...
06:28:07 <edwardk> so many discussions i find myself dragged into
06:28:25 <Gracenotes> so many meta-discussions
06:29:25 <edwardk> it is a bit of a slow day =)
06:30:19 <tdammers> Gracenotes: can we please not discuss meta-discussions right now? I'd much rather we talk about those who complain about them, or the general concept.
06:30:23 <tdammers> (sorry)
06:30:33 <akamaus> fizbin, I've looked at text-icu. Seems like it doesn't support cyrillic encodings, like windows-1251, koi8-r.
06:30:58 <edwardk> tdammers: i'd rather not have this meta-meta-meta discussion though.
06:31:01 <nooodl> re: languages: i think haskell corresponds more to lojban or something? maybe there's a better fit for that though
06:31:32 <tdammers> :D
06:31:49 <nooodl> edwardk: do you realize that sentence starts a meta-meta-meta-meta one! that's dangerous
06:32:17 <tdammers> what if we discuss the general concept of lifting a conversation into the meta realm?
06:32:37 <nooodl> meta^\omega-discussion
06:32:43 <mauke> nooodl: NOOOO
06:32:46 <edwardk> fortunately we're still only growing one step at a time. someone will figure out how to lift this to meta^\omega
06:33:03 <tdammers> I think I just did
06:33:06 <fizbin> akamaus: The underlying icu libraries can convert to/from almost any known binary encoding on the planet. Perhaps there's some sort of setup of the icu database that needs to happen first?
06:33:16 <edwardk> or at least meta^\infinity depending on if they need to deal with any funny behavior in the limit
06:33:17 <Eduard_Munteanu> Do you get a paradox if meta-discussion = discussion?
06:33:18 <Gracenotes> though, those are meta^n comments, not meta^n discussions
06:33:45 <nooodl> isn't talking about meta^\omega discussions a meta^{\omega + 1} discussion?
06:33:46 <Gracenotes> humans can manipulate grammatical structures about meta ideas much more easily than those ideas themselves
06:34:07 <Eduard_Munteanu> Indeed. :)
06:34:09 <Gracenotes> or, even invent notation for them, evidently
06:34:27 <akamaus> fizbin, looks like it does, actually. They just have different names.
06:34:46 <tdammers> one could argue that manipulating a formal representation of an idea is equivalent to manipulating the idea itself
06:34:47 * Eduard_Munteanu {-# OPTIONS --discussion-in-discussion #-}
06:34:50 * hackagebot nemesis-titan 2013.6.13.1 - A collection of Nemesis tasks to bootstrap a Haskell project with a focus on continuous integration  http://hackage.haskell.org/package/nemesis-titan-2013.6.13.1 (JinjingWang)
06:35:01 <akamaus> fizbin, aliases "cp-1251"
06:35:01 <akamaus> ["ibm-5347_P100-1998","ibm-5347","windows-1251","cp1251","ANSI1251"]
06:35:10 <fizbin> It should accept "cp1252" as an alias for whatever it internally calls…. right.
06:35:16 <tdammers> (I think I lost track of the exact meta-topological positioning of the current thread of discussion)
06:35:24 <dgpratt> this seems like a good time to ask: would Haskell be better if it was strict, with opt-in laziness?
06:35:51 <tdammers> dgpratt: I think it would cease being Haskell
06:36:11 <Eduard_Munteanu> There are aspects where Haskell isn't fully non-strict though.
06:36:40 <fizbin> akamaus: You seem to have found the converter you want, but you may also find http://demo.icu-project.org/icu-bin/convexp interesting.
06:36:48 <_kwstas> hi guys! I have a1, a2 :: Either a [b]. I want to get as a result a new Either a [b] which will contain the concatenations of the two lists, or if for example a1 = Left somethn and a2 = Right x, to get Right x and not Left smth...Is this possible?
06:36:49 <dgpratt> Eduard_Munteanu: to many negatives -- cannot parse :)
06:36:56 <joe9> I want to define a datatype with an Instance to the Enum class but with minBound starting from 1 instead of 0. Is that possible?
06:37:00 <tener_> dgpratt: I think it would harm general usefullness of many constructs, but I wouldn't mind a neat language extension to enable full strictness on per-module basis
06:37:04 <joe9> I can define Bounded with minBound.
06:37:15 <Gracenotes> non-strictness and laziness are different concepts.
06:37:17 <Eduard_Munteanu> I meant stuff like irrefutable patterns.
06:37:17 <mauke> _kwstas: what if you have two Lefts?
06:37:47 <_kwstas> mauke: Then should return Left smth
06:38:12 <mauke> _kwstas: what is "smth"?
06:38:17 <Gracenotes> both revolve around functions, but in being both non-strict and lazy in various places, Haskell doesn't rely on functions for control flow, but rather expressions (particularly, various constructors)
06:38:40 <_kwstas> mauke: whatever, String for example
06:38:52 <nooodl> _kwstas: what if the two Left values are different?
06:38:58 <nooodl> should it give you the one in a1 or a2?
06:39:14 <mauke> _kwstas: String is not a value
06:39:27 <dgpratt> I generally like the non-strict nature of Haskell, but there is something that bothers me about it:
06:39:52 <dgpratt> one of the great things about Haskell is that it's much easier to have confidence in the correctness of your code...
06:40:07 <_kwstas> nooodl: If there are two left then it i don't care.
06:40:17 <dgpratt> ...but not so easy to discern whether it will perform acceptably at runtime
06:40:23 <_kwstas> _mauke: I know ;) I mean a string value
06:40:44 <mauke> _kwstas: which string value?
06:40:52 <nooodl> if you don't care about what the Left values contain at all, i think you might want Maybe, really
06:41:19 <akamaus> fizbin, omg, a whole zoo :)
06:41:26 <nooodl> > Nothing `mappend` Just [1,2,3]
06:41:30 <lambdabot>   Just [
06:41:35 <nooodl> > Just [4,5,6] `mappend` Just [1,2,3]
06:41:37 <lambdabot>   Just [4,5,6,1,2,3]
06:41:51 <_kwstas> nooodl: no, i care for the value. But I don't cate if it is the first or the second
06:42:33 <fizbin> akamaus: And that's just the ones included by default. There's a whole huge library of other encodings you can add that the icu authors considered too obscure for the default build.
06:42:34 <dgpratt> I would like to have my cake and eat it to -- to be able to write code that I have confidence in both in terms of correctness and performance
06:42:59 <Gracenotes> dgpratt: let me tell u a thing. u can do it.
06:43:12 <dgpratt> Gracenotes: do go on
06:44:11 <Gracenotes> ...yeah... it does have a bit of a learning curve, but the difference between code that performs so-so and code that performs well isn't as huge as it is in some other languages.
06:44:44 <Gracenotes> although, maybe the difference between code that performs well and code that performs jaw-droppingly fast can be a bit big in some cases
06:45:00 <nooodl> @hoogle Either a b -> Either a b -> Either a b
06:45:00 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
06:45:00 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
06:45:00 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
06:45:10 <Gracenotes> It is mainly a matter of absorbing Haskell's evaluation model in your head, to some extent
06:45:13 <dgpratt> Gracenotes: for the things I'm interested in, jaw-droppingly fast is not a goal
06:45:35 <Gracenotes> Much like getting the correctness benefits are a matter of absorbing Haskell's type system into your head
06:46:08 <dgpratt> but I see people much smarter and more experienced with Haskell than myself get caught out by space/time blow ups due to non-strictness
06:47:02 <_kwstas> nooodl: thanks I'l study it.
06:47:10 <nooodl> i don't think any of those will help you :(
06:47:26 <nooodl> this sounds sorty writer monad-ish though
06:47:49 <Gracenotes> so as far as those differences.. some of it is not allowing thunks to form (forcing things before the closure stays on heap for too long, if at all), via bangs, choosing things like foldl' or the strict state monad, etc...
06:49:09 <Gracenotes> but it can be the case, I think, that letting things be totally lazy can be better than forcing it every step of the way.
06:49:51 <_kwstas> Generally speaking, I understand that when you use monads you know that if a failure occurs (Nothing, Left etc) this failure will be propagated to the other actions, until the end. What I don't know if there is a clean way to just ignore a failure and move to the next action
06:49:51 <Gracenotes> if need be
06:50:16 <merijn> _kwstas: That behaviour depends on the Monad
06:50:43 <merijn> _kwstas: If you want to ignore a failure, don't use a short-circuiting monad like Maybe/Either e/etc
06:51:30 <Gracenotes> or just run the monad separately
06:52:10 <merijn> _kwstas: Oh, wait you want to run two things and get back the value of one of the two?
06:52:41 <Gracenotes> so: do { x <- needThisThing; let y = dunnoAboutThisOne; case y of Nothing -> do whatever; Just z -> do otherjunk; }
06:52:47 <merijn> Eh
06:52:53 <merijn> I was just gonna say this
06:52:55 <Gracenotes> or something nicer than a case statement
06:52:56 <merijn> :t (<|>)
06:52:57 <lambdabot> Alternative f => f a -> f a -> f a
06:53:14 <merijn> > Nothing <|> Just 1
06:53:16 <lambdabot>   Just 1
06:53:20 <Gracenotes> that too, if you don't care about the result if it's Nothing
06:53:24 <merijn> > Just 1 <|> Just 2
06:53:25 <lambdabot>   Just 1
06:53:28 <merijn> > Just 1 <|> Nothing
06:53:29 <lambdabot>   Just 1
06:53:30 <nooodl> he wants to concat the Right values though
06:53:35 <merijn> > Nothing <|> Nothing
06:53:36 <lambdabot>   Nothing
06:53:58 <merijn> nooodl: He said "nooodl: no, i care for the value. But I don't cate if it is the first or the second"
06:54:08 <_kwstas> I want -> Right [1,2] and Right [3.4] -> right [1,2,3,4]
06:54:08 <Gracenotes> Or, for simple types like Either and Maybe, monads may not need be involved...
06:54:08 <nooodl> that's for the Left one
06:54:09 <merijn> Sounds like Alternative
06:54:28 <_kwstas> Left "error" and Right [1,2] -> Right [1,2]
06:54:33 <merijn> oh
06:54:39 <nooodl> oh maybe it's... arrow (<|>) (<>)
06:54:43 <merijn> You'll have to write that yourself, but that shouldn't be hard
06:54:47 <nooodl> i mean... either
06:54:50 * hackagebot shake 0.10.4 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.10.4 (NeilMitchell)
06:55:08 <merijn> _kwstas: Right always contains a list?
06:55:13 <nooodl> ugh. what do i mean
06:55:20 <_kwstas> merijn: yes
06:55:24 <merijn> > Right [1,2] `mappend` Right [3,4]
06:55:25 <lambdabot>   No instance for (Data.Monoid.Monoid (Data.Either.Either a0 [t0]))
06:55:25 <lambdabot>    arisin...
06:55:27 <merijn> hmm
06:55:40 <byorgey> Either is not a monoid.
06:55:46 <byorgey> what is  Left x <> Right y?
06:56:12 <merijn> byorgey: he just wants to coerce Left x to Right [], I think
06:56:20 <byorgey> I guess you could make it a monoid with an arbitrary choice that Right always overrides Left (or vice versa)
06:56:23 <Gracenotes> are you looking for Data.Either.partitionEithers?
06:56:42 <merijn> Or maybe just
06:56:44 <merijn> :t rights
06:56:44 <Gracenotes> and then, perhaps, concat . snd
06:56:45 <lambdabot> [Either a b] -> [b]
06:56:47 <byorgey> that monoid is in http://hackage.haskell.org/packages/archive/monoid-extras/0.3.0.0/doc/html/Data-Monoid-Recommend.html
06:56:57 <merijn> :t concat . rights
06:56:59 <lambdabot> [Either a1 [a]] -> [a]
06:57:02 <Gracenotes> Ah. Yes, forgot about that one.
06:57:24 <sopvop> mconcat $ hush eithers
06:57:28 <merijn> > concat . rights $ [Left "foo", Right [1,2,3], Left "bar", Right [4,5,6]]
06:57:31 <lambdabot>   [1,2,3,4,5,6]
06:57:34 <sopvop> :t hush
06:57:38 <lambdabot> Not in scope: `hush'
06:57:49 <byorgey> sopvop: is that from lens?
06:57:55 <sopvop> from errors
06:58:01 <Gracenotes> byorgey: a lot of the other typeclasses are fairly opinionated about Left/Right, though
06:58:10 <byorgey> trye
06:58:12 <byorgey> *true
06:58:22 <sopvop> byorgey: http://hackage.haskell.org/packages/archive/errors/1.4.1/doc/html/Control-Error-Util.html
06:58:30 <Gracenotes> ah, well that's what newtypes are for
06:58:31 <sopvop> hush ::  Either a b -> Maybe b
06:58:38 <byorgey> sopvop: ah, cool
06:58:58 <sopvop> that one is cool :) note ::  a -> Maybe b -> Either a b
07:00:09 <Gracenotes> @djinn a -> Maybe b -> Either a b
07:00:09 <lambdabot> f a b =
07:00:10 <lambdabot>     case b of
07:00:10 <lambdabot>     Nothing -> Left a
07:00:10 <lambdabot>     Just c -> Right c
07:00:43 <sopvop> How does it know?!
07:00:54 <Eduard_Munteanu> For djinn, that could've been  f a _ = Left a   just as well. :)
07:01:03 <supki> @ty (^? _Right)
07:01:03 <Gracenotes> well, it guessed. It just chose the more diverse option.
07:01:03 <lambdabot>     Not in scope: `^?'
07:01:03 <lambdabot>     Perhaps you meant one of these:
07:01:03 <lambdabot>       `^' (imported from Prelude), `^^' (imported from Prelude)
07:01:08 <supki> huh
07:01:34 <byorgey> supki: lens is not in lambdabot at the moment, some problem to do with hashable and SafeHaskell
07:01:36 <Gracenotes> we can also try, I suppose
07:01:41 <cpa> hi, is it possible to use system from Sytem.Process but to get the results in a IO string rather than have it outputed to stdout ?
07:01:43 <Gracenotes> @djinn Either a b -> Maybe b
07:01:43 <lambdabot> f a =
07:01:43 <lambdabot>     case a of
07:01:43 <lambdabot>     Left _ -> Nothing
07:01:43 <lambdabot>     Right b -> Just b
07:02:05 <sopvop> Black magic!
07:02:13 <sopvop> Burn the witchbot!
07:02:16 <Eduard_Munteanu> Haha.
07:02:22 <cpa> the type signature would be system' :: String -> IO (String, ExitCode)
07:03:19 <byorgey> cpa: it is not possible with the 'system' function, but you can use another function like runInteractiveCommand
07:03:29 <byorgey> cpa: there are lots of such functions here: http://hackage.haskell.org/packages/archive/process/1.1.0.2/doc/html/System-Process.html
07:03:40 <_kwstas> ok then, I'l probably create my own function for this case. I don't think it's difficult. I just asked in case I miss a really  trivial solution (I'm really new to Haskel). Thank you all again :)
07:03:53 <byorgey> cpa: or maybe you want 'readProcessWithExitCode'
07:04:25 <Eduard_Munteanu> I think he wants to be able to run shell internals, no?
07:05:22 <Aetherspawn> @djinn wat
07:05:22 <lambdabot> -- f cannot be realized.
07:05:28 <cpa> byorgey: okay, that's what I thought, thanks. BTW, my understanding of ProcessHandle is that it can only be used to get the state of a process but it does not give access to std{in,out,err}, am I right?
07:05:31 <Aetherspawn> @djinn [a] -> a
07:05:31 <lambdabot> Error: Undefined type []
07:05:31 <Eduard_Munteanu> Sounds like 'createProcess' + 'shell' might do in that case.
07:06:17 <Eduard_Munteanu> @hoogle shell
07:06:17 <lambdabot> System.Process shell :: String -> CreateProcess
07:06:17 <lambdabot> package shell-escape
07:06:17 <lambdabot> package shell-pipe
07:06:20 <cpa> yep, but I thought it was too much for a simple task. I'll do like that if there's not other choice, thanks
07:06:25 <byorgey> cpa, Eduard_Munteanu : if you want to process things with the shell you can use the 'shell' function.
07:06:29 <byorgey> right
07:07:01 <byorgey> cpa: right, I don't think it does.
07:07:13 <Eduard_Munteanu> "system" sounds a lot like it's been borrowed from another language.
07:07:18 <Eduard_Munteanu> (Java?)
07:07:33 <yitz> Eduard_Munteanu: a lot of languages have system
07:07:39 <Eduard_Munteanu> I think certain C implementations have it too, yeah.
07:08:06 <Eduard_Munteanu> Oh, hm. It's standard.
07:08:17 <sopvop> it's posix
07:08:34 <Eduard_Munteanu> CONFORMING TO  C89, C99, POSIX.1-2001.
07:08:40 <Eduard_Munteanu> Weird though.
07:11:01 <jesyspa> I'm trying to use GADTs for extra type-safety.  I'd like to express that every Thing which is an L-kind-of-value is also an R-kind-of-value, but I can't get the thing to type-check.  What am I missing? http://hpaste.org/89881
07:12:04 <byorgey> jesyspa: can you also paste the error message(s)?
07:12:57 <byorgey> jesyspa: note also, that code does not say "anything which is an L-value is also an R-value".  What it actually says is "every Thing is an R-value, and also, it had better be an L-value".
07:13:05 <byorgey> OR ELSE
07:13:07 <fruitFly> Couldn't match (String -> String) with actual type String? main = interact (head (sortPlainTexts [bytesToAscii $ xorSingleChar (case hexToBytes (bytesToHex (hexToBytes lines)) of Just bytes -> bytes) byte | byte <- [(0 :: Word8) .. 255]]))
07:13:24 <fruitFly> head is being applied on [String]
07:13:32 <fruitFly> is there something with my placement of lines?
07:13:33 <byorgey> fruitFly: right, which gives you a String
07:13:41 <byorgey> fruitFly: but  interact  expects a  String -> String  function
07:14:02 <byorgey> oh, wait, hexToBytes lines ?
07:14:07 <fruitFly> byorgey: isn't it taking a string in the form of a line, and then I'm outputting a string?
07:14:11 <byorgey> what is the type of hexToBytes ?
07:14:25 <jesyspa> Here's what I tried: http://hpaste.org/89881
07:14:26 <fruitFly> String -> [Word8]
07:14:36 <byorgey> fruitFly: and what is the type of lines?
07:14:45 <jesyspa> byorgey: But it looks like the approach is flawed, seeing as it never gets to the instance declaration.
07:14:54 <fruitFly> byorgey: String
07:14:57 <byorgey> fruitFly: no
07:15:05 <fruitFly> ?
07:15:07 <nooodl> hexToBytes (bytesToHex (hexToBytes lines)) -- what does this do?
07:15:09 <byorgey> @type lines
07:15:10 <lambdabot> String -> [String]
07:15:28 <fruitFly> byorgey: oh...
07:15:41 <fruitFly> byorgey: ok
07:15:42 <nooodl> (imagine lines is something else and it works)
07:16:01 <fruitFly> byorgey: I think I get it :)
07:16:13 <jesyspa> byorgey: Interesting...  Then how could I express "if it's an L-value, it is also an R-value"?
07:16:27 <yitz> @hoogle hexToBytes
07:16:27 <lambdabot> No results found
07:16:28 <byorgey> jesyspa: you can't, really
07:16:48 <byorgey> jesyspa: not using type classes at least.
07:17:22 <byorgey> jesyspa: however, the error message is because there is no way to determine the types sz and lr from just the type v in a Value instance
07:17:42 <byorgey> jesyspa: perhaps you want a functional dependency like  Value sz lr v | v -> sz lr
07:17:57 <byorgey> jesyspa: but that won't work with your "every L-value is also an R-value" thing
07:18:15 <jesyspa> byorgey: Thanks, I'll read up on those first.
07:18:38 <byorgey> jesyspa: it's quite likely you don't really want type classes here.
07:18:56 <byorgey> if I were you I would try doing whatever you want to do just using higher-order functions.
07:19:05 <byorgey> then perhaps later you might see a way that type classes would help.
07:20:27 <jesyspa> byorgey: My initial solution was having LValue and RValue be types that had various constructors for Things and each other, and another LRValue type which had constructors from LValues and RValues, but the whole thing ended up very verbose.
07:21:10 <jesyspa> How would HOFs fit in here?
07:21:38 <byorgey> jesyspa: everywhere you wanted a Value constraint, instead just take an argument of type  (v -> String)
07:22:13 <byorgey> jesyspa: I agree having separate LValue and RValue types does not sound so great.  Using GADTs with L and R as phantom type tags is a great idea.
07:22:26 <byorgey> but you don't need to go all the way to using type classes as well.
07:22:40 <jesyspa> Ah, doh, how didn't I think of that.  Thanks!
07:44:13 * ksf wonders how he's supposed to change what trifecta considers to be whitespace
07:44:40 <ksf> ...can't import parseFromFile etc. without importing that TokenParsing instance.
07:48:54 <sohum> in monads that allow it, what's the inverse of return called, f :: m a -> a?
07:49:21 <Botje> run, usually.
07:49:32 <sohum> mmm
07:49:37 <sohum> okay, thanks!
07:49:53 * hackagebot nemesis-titan 2013.6.13.2 - A collection of Nemesis tasks to bootstrap a Haskell project with a focus on continuous integration  http://hackage.haskell.org/package/nemesis-titan-2013.6.13.2 (JinjingWang)
07:49:55 * hackagebot type-level-numbers 0.1.1.0 - Type level numbers implemented using type families.  http://hackage.haskell.org/package/type-level-numbers-0.1.1.0 (AlexeyKhudyakov)
07:50:12 <ksf> or extract, if you like category theory.
07:50:46 <ksf> http://hackage.haskell.org/packages/archive/pointed/2.0.2/doc/html/Data-Copointed.html
07:52:18 <sohum> ksf: huh
07:52:59 <ksf> there's also http://hackage.haskell.org/packages/archive/pointed/2.0.2/doc/html/Data-Pointed.html
07:53:04 <ksf> which is a generalised "return".
07:54:29 <elliott> (note that pointed is sorta-half-deprecated)
07:56:39 <supki> the set of monads allowing :: m a -> a is kinda boring, isn't it?
07:57:52 <ksf> that function strictly speaking isn't a feature of monads.
07:58:09 <yitz> ksf: hmm at first glance trifecta seems to have the opposite problem. how do you parse anything at all? the library seems to contain is ways to combine existing parsers, but no obvious way to create any primitive parsers at all.
07:58:14 <ksf> of comonads, though.
07:58:29 <ksf> yitz, there's a separate combinator package.
07:58:34 <yitz> ahhh
07:58:52 <ksf> ...just click yourself through the interfaces Parser implements.
08:00:10 <yitz> ksf: where is this separate package? hackage only knows about one package whose name contains "trifecta"
08:00:49 <Aetherspawn> what are some network optimization tips in haskell?
08:00:58 <elliott> yitz: parsers
08:01:02 <ksf> we're talking about ekmett, here. it's of course completely general, and thus simply called "parsers"
08:01:16 <elliott> yitz: it's edwardk, you write http://hackage.haskell.org/package/ and then what you're dealing with
08:02:24 <Aetherspawn> No package to moderate a forum for me
08:02:27 <Aetherspawn>  http://hackage.haskell.org/package/idiots :(
08:03:21 <merijn> supki: How so? Maybe, ST, Either e, etc. all allow "m a -> a" and they're not specifically boring
08:03:29 <yitz> elliott: next he'll upload a package called haskell then i suppose
08:03:31 <merijn> Also State, Writer, etc.
08:04:13 <ksf> on the top of my head, only IO and STM come without such a function.
08:04:23 <supki> merijn: well, I assumed reasonable :: m a -> a
08:04:25 <yitz> ksf: so that answers your question then. someSpace is a member of the TokenParsing class. you can define it to be whatever you want.
08:04:32 <ksf> but that's because you write the monads in haskell and *want to get a value out*.
08:04:35 <supki> i.e. not fromJust
08:04:43 <sclv_> merijn: state doesn't really allow that
08:04:43 <ksf> otherwise, what'd be the reason to have them in the first place.
08:04:51 <merijn> sclv_: Oh?
08:04:54 * hackagebot fixed-vector 0.4.4.0 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.4.4.0 (AlexeyKhudyakov)
08:04:57 <sclv_> ditto either
08:04:59 <elliott> merijn: ST does not allow m a -> a
08:05:03 <sclv_> you need to pass in a state
08:05:12 <elliott> oh, wait
08:05:16 <sclv_> ?ty runST
08:05:17 <elliott> none of your other examples do either except Writer
08:05:18 <lambdabot> (forall s. ST s a) -> a
08:05:25 <ksf> yitz, yes I *could* if Text.Trifecta.Parser wouldn't give an implementation.
08:05:26 <sclv_> and in writer the answer you get is boring
08:05:31 <merijn> elliott: What is runST, then?
08:05:39 <ksf> (the default one, on top of that)
08:05:45 <sclv_> look at the quantification :-)
08:05:45 <elliott> merijn: there is no m for which runST's type unifies with m a -> a
08:05:51 <elliott> you're making a scope error or such
08:05:54 <ksf> speak of the devil.
08:06:04 <sclv_> however, many monads allow _specific_ m a -> a for specific a
08:06:09 <elliott> runST :: (a :: *) -> ((s :: *) -> ST s a) -> a -- a "dependently-typed" view might help
08:06:12 <sclv_> these are monad algebras, and they are very interesting
08:06:31 <sclv_> as someone pointed out, for list, the monad algebras are mconcat
08:06:37 <dolio> They're not necessarily monad algebras.
08:06:58 <sclv_> or rather specific m a -> a such that join . run = run . run
08:07:07 <ksf> edwardk, Text.Trifecta.Parser contains a TokenParsing instance for Parser, which means that I can't tell my parser to ignore commets like other whitespace (at least without bending over)
08:07:11 <fruitFly> I don't see how I
08:07:12 <sclv_> right, i corrected myself
08:07:19 <fruitFly> I don't see how I'm using lines wrong? http://ideone.com/JNzLar
08:07:28 <sclv_> the ones that are monad algebras are interesting, but they need to respect monad structure
08:07:39 <dolio> I think that should be run . join.
08:07:46 <sclv_> probably
08:07:58 <edwardk> ksf: sure you can. make a monad transformer and overload it
08:08:11 <dolio> Also run . liftM run.
08:08:13 <sclv_> there's also a return condition -- run . return = id
08:08:26 <sclv_> yeah i'm being sloppy
08:08:28 <edwardk> ksf: the design goal is that there would be a monad transformer for parameterizing on a CommentStyle
08:08:31 <byorgey> fruitFly: you are trying to apply a function to it which expects a [String]
08:08:37 <byorgey> fruitFly: but lines is not a [String].
08:08:43 <ksf> edwardk, but parseFromFile, even stepParser doesn't work on the class, but on the Parser type.
08:08:44 <edwardk> this is actually important because otherwise we can't have the layout monad transformer
08:08:49 <byorgey> fruitFly: perhaps you want to compose them, with .  ?
08:09:08 <byorgey> @type concat
08:09:09 <lambdabot> [[a]] -> [a]
08:09:18 <byorgey> > concat lines  -- type error
08:09:20 <lambdabot>   Couldn't match expected type `[[a0]]'
08:09:20 <lambdabot>              with actual type `GHC.Ba...
08:09:25 <edwardk> ksf: yes, but with that transformer you can parseFromFile (runMyParser yourParser)
08:09:30 <byorgey> > concat . lines --  function from String -> String
08:09:31 <lambdabot>   <[Char] -> [Char]>
08:09:33 <sclv_> so join is universally a monad algebra i guess is the way to remember it.
08:09:55 <sclv_> and any other one must be one such that you can substitute it for join where the types match and keep your laws
08:09:56 <edwardk> i'll have to chew on that some more though
08:09:58 <edwardk> i admit its awkward
08:10:02 <dolio> Yes.
08:10:03 <fruitFly> byorgey: I though lines returns [String], i.e. the lines in the document?
08:10:23 <dolio> Actually, there's a second way to view the Kleisli category from the way people usually do it in Haskell.
08:10:27 <byorgey> fruitFly: lines has type  [String] -> [String],  so it returns  [String], yes.
08:10:41 <sopvop> edwardk, ksf : http://hpaste.org/89884 like that?
08:10:43 <fizbin> > lines "a\nmf\ner"
08:10:44 <lambdabot>   ["a","mf","er"]
08:10:45 <byorgey> fruitFly: but you cannot pass something of type   [String] -> [String]   to something expecting a  [String].
08:11:00 <byorgey> fruitFly: ([String] -> [String]) /= [String]
08:11:04 <dolio> For every a, there's the free m-algebra (m a, join).
08:11:07 <edwardk> sopvop: yeah
08:11:08 <fizbin> lines is of type String -> [String], byorgety
08:11:15 <byorgey> right, sorry
08:11:17 <fizbin> Um, byorgey.
08:11:20 <edwardk> you may still have issues running it in parseFile. i admit that was hard wired for Parser
08:11:20 <sopvop> can't derive multi parameter unfortunately :(
08:11:24 <mentis> \quit
08:11:27 <byorgey> the important point is that lines is a function, not a list.
08:11:29 <dolio> And those free algebras form a category, which is the Kleisli category.
08:11:35 <edwardk> sopvop: sure you can, as long as the monad is the last arg
08:11:57 <edwardk> deriving (MonadReader e)
08:11:57 <sopvop> edwardk: But I couldn't derive MarkParsing for some reason
08:12:03 <sopvop> Oh
08:12:05 <byorgey> fruitFly: if I were you I would break up that argument to 'interact' into smaller pieces, and get each piece to typecheck.
08:12:10 <edwardk> MarkParsing Delta
08:12:11 <sclv_> that's "for every a _and_ fixing any given m" right?
08:12:22 <ksf> well yes, just that IdentityT suffices in my case.
08:12:27 <sopvop> edwardk: Got it, thanks!
08:12:30 <byorgey> fruitFly: with such a huge expression you have to do a lot of type inference in your head, and it's easier if you can get the compiler to help
08:12:35 <yitz> ksf: it looks like there are a total of about 20 lines of code that deal with the concrete Parser type.
08:12:48 <fruitFly> byorgey: I see what's going on, thanks :)
08:12:49 <edwardk> sopvop: btw- the comment style stuff will auto-generate those whitespace functions for you
08:12:50 <yitz> ksf: everything else is in all those type classes
08:13:26 <yitz> ksf: so you could just roll your own very easily, or wrap Parser in a newtype.
08:13:29 <fruitFly> byorgey: wait, I thinking where to start
08:13:53 <edwardk> http://hackage.haskell.org/packages/archive/parsers/0.8/doc/html/src/Text-Parser-Token-Style.html#buildSomeSpaceParser
08:14:11 <fruitFly> byorgey: how is interact supposed to be couple with lines, what's the relationship?
08:14:17 <sopvop> edwardk: I was also planing on gathering #pragmas in skipWS, thats what StatT is there for. But for now it's just StateT () :)
08:14:33 <byorgey> fruitFly: the relationship is encoded in the types.
08:14:35 <edwardk> buildSomeSpaceParser (lift someWhiteSpace) javaCommentStyle
08:14:37 <byorgey> fruitFly: what is the type of interact?
08:14:52 <ksf> I'm going to go the newtype route.
08:15:05 <ksf> It's just bloody unexpected to have an interface like that.
08:15:06 <fruitFly> byorgey: interact :: (String -> String) -> IO ()
08:15:25 <byorgey> fruitFly: right. so your job is to construct something of type  String -> String.  In order to do that you may use lines to help, if you wish.
08:15:28 <edwardk> ksf: yeah i used to have a built-in transformer that exposed it, but it got dropped somewhere along the path to 1.0
08:15:35 <edwardk> mostly because i was accumulating a lot of little transformers
08:15:37 <fruitFly> byorgey: I think it's just dynamically reads the lines of a file, applies a function to them and spits them out
08:15:58 <edwardk> perhaps a more lensy HasCommentStyle approach for a common state might be better
08:16:02 <byorgey> fruitFly: interact reads the contents of standard input, applies a function to it, and prints the result.
08:16:20 <byorgey> fruitFly: it has nothing to do with files, or lines.
08:16:27 <edwardk> but that has other interactions that are poor
08:16:41 <byorgey> if you want to break up the String representing standard input into lines, you can use the 'lines' function.
08:16:51 <sopvop> edwardk: Well, the built-in runParser can take another function as a parameter... or a dict. Though it will destroy all the inlining
08:16:53 <applicativ> fruitFly: to use an executable defined with interact on  a file
08:17:02 <yitz> edwardk: ksf just wants to change the definition of whitespace
08:17:11 <edwardk> ksf: keep in mind the alternative is to have to do crap like parsec where you open some ginormous record to get all the combinators, and then can't access any of their parts.
08:17:12 <sopvop> But make parser compile in less than half a minute
08:17:12 <applicativ> fruitFly: you would do , say , cat file.txt | ./myhaskellinteractexec
08:17:28 <fruitFly> byorgey: that's how I was trying to build my funtion, maybe there's a quick fix? lines in my function represents [String] of each line of my code
08:17:45 <ksf> I'm not even opposed to the general model.
08:17:57 <edwardk> ksf: and worse, you can't do layout, etc. because all those combinators then break.
08:18:00 <bartavelle> how would architecture a parser that must "jump" in the stream (such as a disassembler) ? it doesn't seem obvious to me how to write a good api for that
08:18:03 <byorgey> fruitFly: the quick fix might be putting a .  before 'lines'.  But I have no idea if that will work. Probably not.
08:18:06 <fruitFly> applicativ: yes, oh shizzle, so maybe it'll work now
08:18:22 <applicativ> fruitFly: did you paste something?
08:18:24 <byorgey> fruitFly: applicativ's hint has nothing to do with whether your code type checks.
08:18:25 <edwardk> thats why we went with this direction rather than what parsec did. the token parsing in parsec is a black box that literally every time I've used parsec i've had to cut and paste into my own module
08:19:24 <fruitFly> byorgey: ur right
08:19:36 <fruitFly> but it is what i'm trying to do
08:19:39 <fruitFly> ok.. looking at it
08:19:42 <edwardk> right now the 'ritual' around using parsers is to set up some kind of parser you want to work in, with its own comment style, etc. which may involve extra state for things like layout, and then open up a couple of identifier styles to make things like constructor and value identifier/keyword matching combinators, and then go to town.
08:19:56 <byorgey> fruitFly: repeat after me: types. types. types. types. types. Say this word to yourself when you wake up in the morning and when you go to bed.
08:20:07 <fruitFly> types. types. types. types. types
08:20:08 <fruitFly> .
08:20:34 <byorgey> fruitFly: take apart that long, complex 'main' into tiny pieces.  Make sure each piece type checks and that you understand the types.
08:22:31 <bartavelle> (my question was not retorical, it is something I am really wondering about)
08:23:27 <bartavelle> I suppose you'd need to keep the results in a state monad, because you need to check if some address is already known
08:24:11 <sopvop> edwardk: btw, skipping lines with rope still does not work in the beginning of the rope unless it has non zero "bytes", just lines/columns are not advancing the parser delta
08:24:24 <edwardk> sopvop: patch!
08:24:25 <sopvop> And not only beginning
08:24:40 <edwardk> i'm pretty sure there is a bug in the handling of that. someone else mentioned the issue
08:24:42 <sopvop> I would, if I've known where :)
08:24:57 <edwardk> i haven't had time to look. if nothing else isolate some test cases and throw an issue on the repo
08:25:18 <sopvop> Thethre is that "It" type and everything around it which I don't understand.
08:25:30 <sopvop> Lacks comments :(
08:25:54 <sopvop> Ok, will try to find something
08:26:56 <edwardk> "It" is almost an iteratee, but it holds onto the entire history of its input. think of it as the 'are we there yet?' data It r a = Pure a | It a (r -> It r a)
08:26:58 <ksf> -XGeneralisedNewtypeDeriveEverythingYouNeed
08:27:46 <edwardk> that is either an answer we have given sufficient input to resolve, or what the answer would be if the input cut off now, and a function that can take a bigger input (all of it! including what we sent in before, but with the extra stuff bolted on the end) and continue on
08:28:11 <fruitFly> what's wrong with this?
08:28:12 <edwardk> if it says Pure then it'll ignore any extra input so don't bother sending it
08:28:12 <fruitFly> Couldn't match expected type `[a0]'
08:28:12 <fruitFly>                 with actual type `String -> [String]'
08:28:12 <fruitFly>     In the second argument of `mapM', namely `lines'
08:28:12 <fruitFly>     In the expression: mapM print lines
08:28:12 <fruitFly>     In an equation for `main': main = mapM print lines
08:28:27 <edwardk> fruitFly: please do not spam the channel like that. you've been told before
08:28:46 <fruitFly> edwardk: sorry, I thought it was alright if it was short, will paste it
08:28:49 <geekosaur> lines is a function. what is it supposed to operate on?
08:29:02 <sopvop> edwardk: It gets the whole input, and then skips to the delta where it stopped?
08:29:02 <edwardk> fruitFly: if it doesn't fit on a line, you probably shoudn't do it
08:29:26 <fruitFly> geekosaur: a .txt I want to pass it, oh will putting interact infront fix it?
08:29:36 <fruitFly> edwardk: ok gotchya :)
08:29:55 * hackagebot genetics 0.0.2 - A Genetic Algorithm library  http://hackage.haskell.org/package/genetics-0.0.2 (AndrewPennebaker)
08:30:44 <fruitFly> geekosaur: I thought lines is automatically reading the input, I must be missing something. I'll take a look
08:30:45 <edwardk> sopvop: basically you wind up with the entire rope being 'r'. the parser lives on top of 'It Rope' because then it can track the current location and line contents and can go fetch new lines when it has to move outside of the current one
08:31:01 <ekipan> @type lines
08:31:02 <lambdabot> String -> [String]
08:31:12 <geekosaur> no, lines just splits some input that you pass it. it doesn't magick up that input from somewhere by itself
08:31:12 <ekipan> lines expects an argument of type String
08:31:21 <byorgey> fruitFly: stop thinking in terms of what you think the code is *doing* and start thinking about the types.
08:31:31 <edwardk> sopvop: basically what happens is the Parser compiles down to It actions that push for more input when absolutely necessary
08:31:32 <byorgey> fruitFly: types. types. types.  I am not joking.
08:31:50 <byorgey> it will be painful at first but this is the only way to become a better Haskell programmer.
08:32:04 <edwardk> unlike an iteratee an 'It' action always succeeds, it just may get less input than it could otherwise use
08:33:11 <edwardk> consider parsing many (char 'x') you could always accept more input, so long as they are 'x's, so it'll always return the 'It' 'hey please try to feed me some more data' result rather than Pure when it gets down to the underlying It calculation.
08:34:07 <edwardk> once it has seen something that isn't an 'x' though, it'll give back a Pure result.
08:35:48 <sopvop> edwardk: Now I get it
08:36:30 <edwardk> if at any point there isn't any more input you can always use the (lazy) value that It has put aside for just that case.
08:37:03 <edwardk> It was named because I wasn't sure quite what 'It' was, and its not quite an 'It'eratee
08:38:25 <fruitFly> byorgey: yes! geekosaur but I thought I could pass the lines to that function in terminal like " cat file.txt | ./program"?
08:38:31 <yitz> edwardk: did anyone ever do any benchmarking of trifecta?
08:39:11 <byorgey> fruitFly: forget about running it in the terminal.  That will come later.
08:39:18 <byorgey> first you have to get your program to type check.
08:39:56 * hackagebot transformations 0.1.0.0 - Generic representation of tree transformations  http://hackage.haskell.org/package/transformations-0.1.0.0 (JosePedroMagalhaes)
08:39:57 <yitz> edwardk: ksf induced me to look at it finally. very nice interface. but - how much am i losing for the usual case (for me) of parsing many megabytes of input?
08:40:25 * ksf currently doesn't care.
08:40:53 <ksf> if my application needs performance it's going to need a streaming parser, anyway, and that's vapourware.
08:41:03 <ksf> (the performance, not the streaming parser)
08:41:05 <sopvop> It's fast enough for me also. And it's much much faster than peggy parser I had before.
08:41:28 <ksf> there's one in the SCC framework.
08:41:29 <yitz> ksf: attoparsec works very well for me in terms of performance
08:41:38 <Aetherspawn> I don't understand how to use MonadIO
08:41:40 <Aetherspawn> http://hpaste.org/89885
08:41:44 <sopvop> It is slower than attoparsec for sure
08:42:04 <Aetherspawn> if I add () after the m I get a (m ~ a) error thing, and if I don't add a type it dies
08:42:26 <ksf> well, not only consume incrementally, but also produce.
08:42:59 <byorgey> Aetherspawn: First, you need  MonadIO m => m a.  Then, you need to add a call to 'liftIO' in front of 'putStrLn "Testing"'
08:43:06 <ksf> and while attoparsec is blazingly fast, it doesn't support anything when it comes to error messages.
08:43:13 <byorgey> Aetherspawn: because  putStrLn "Testing" :: IO ()
08:43:24 <ksf> so in the end I'm using trifecta as a replacement for parsec.
08:43:26 <byorgey> Aetherspawn: liftIO takes concrete IO actions and lifts them into any monad which is an instance of MonadIO.
08:44:16 <Aetherspawn> byorgey, thanks, but I tried that and got this; http://hpaste.org/89885
08:44:38 <ksf> I think about the only thing trifecta (currently?) doesn't do is error correcting.
08:44:41 <byorgey> Aetherspawn: oh, sorry, right, you need  m ()  not  m a
08:44:56 <byorgey> Aetherspawn: putStrLn :: IO ().  You cannot magically turn () into any type a.
08:45:25 <byorgey> Aetherspawn: the type  MonadIO m => m a  says "this computation can return a value of *any type you want*!" which is obviously nonsense.
08:45:33 <Aetherspawn> Now it wants my function to return an m () :P
08:45:44 <Aetherspawn> Oh, nevermind, that's my fault!
08:46:30 <brainwash> So I'm working through some haskell tutorials and encountered this error "Could not find module `Data.MemoTrie'". Not sure how to deal with it. Any hints?
08:47:25 <Clint> brainwash: install the MemoTrie package
08:48:01 <fruitFly> byorgey: yes, I whole heartedly take your advice to heart, it's just that I'm trying to copy almost directly from lyah.
08:48:08 <fruitFly> byorgey: and it's not working
08:48:17 <edwardk> ksf: i have a Burke-Fisher transformer lying around somewhere for trifecta, but it was rather peculiar to the grammar i was parsing at the time
08:48:34 <edwardk> ksf: that gives a limited notion of error correction
08:48:36 <fruitFly> byorgey: like this: main = interact $ unlines . filter ((<10) . length) . lines
08:48:51 <edwardk> you really need some kind of 'lexing' layer for it though
08:49:03 <brainwash> Clint: thanks, just discovered cabal some seconds ago :)
08:49:12 <fruitFly> byorgey: my func is: main = interact (mapM print lines) ... what's the difference?
08:49:14 <edwardk> @google burke-fisher error repair
08:49:16 <lambdabot> http://en.wikipedia.org/wiki/Burke%E2%80%93Fisher_error_repair
08:49:16 <lambdabot> Title: Burke–Fisher error repair - Wikipedia, the free encyclopedia
08:49:25 <byorgey> fruitFly: the difference is types.
08:49:36 <ekipan> fruitFly: (f . g) x = f (g x)
08:49:57 <ekipan> interact (f . g) = interact (\x -> f (g x))
08:50:04 <ekipan> lines needs an argument
08:50:11 <byorgey> fruitFly: you say you have taken my advice to heart but you have not.  I suggest you study the example interact $ unlines . filter ((<10) . length) . lines  and make sure you understand the type of every single piece, and the type of the whole
08:50:17 <ekipan> whether through composition with another function or directly
08:54:56 * hackagebot nemesis-titan 2013.6.13.3 - A collection of Nemesis tasks to bootstrap a Haskell project with a focus on continuous integration  http://hackage.haskell.org/package/nemesis-titan-2013.6.13.3 (JinjingWang)
08:55:12 <yitz> edwardk: oh burke fisher sounds pretty crude. can't something be learned from uu-parsinglib?
09:04:42 <acube> Do I have to write a whenM myself, or does it exist somewhere already?
09:05:14 <acube> whenM :: (Monad m) => m Bool -> m () -> m ()
09:05:14 <byorgey> @package IfElse
09:05:14 <lambdabot> http://hackage.haskell.org/package/IfElse
09:05:35 <acube> Ah nice, thanks byorgey
09:13:29 <Aetherspawn> I wish someone bound lift to a unary operator
09:13:38 <mauke> there are no unary operators
09:14:14 <int-e> Aetherspawn: you can make a Num instance ... *ducks*
09:14:17 <Aetherspawn> > let (!!!) = (1+) in !!! 3
09:14:18 <lambdabot>   <hint>:1:21: parse error on input `!!!'
09:14:39 <Aetherspawn> Just a short thing to put at the beginning of a lifted line
09:14:54 <Aetherspawn> would be so much better than lift $ or liftIO $ at the start of everything
09:14:57 <merijn> Aetherspawn: Why are you needing to lift so many lines that it is a problem?
09:15:09 <int-e> > - - - - - 1
09:15:10 <lambdabot>   <hint>:1:3: parse error on input `-'
09:15:11 <Aetherspawn> its mainly IO
09:15:14 <merijn> Aetherspawn: Eh, why not "liftIO $ do {- code here -}"?
09:15:23 <Aetherspawn> then I lose my readers and stuff
09:15:34 <merijn> How so?
09:15:40 <Aetherspawn> :t liftIO
09:15:41 <lambdabot> MonadIO m => IO a -> m a
09:15:51 <Aetherspawn> Wait, nevermind
09:15:57 <Aetherspawn> Wait, un-neveent
09:16:06 <Aetherspawn> It'd have to be pure IO
09:16:19 <Aetherspawn> so I couldn't use asks, etc, anymore?
09:16:21 <merijn> Aetherspawn: hpaste some sample code?
09:16:58 <byorgey> Aetherspawn: yes, you are correct.
09:17:11 <supki> Aetherspawn: I often define io = liftIO
09:17:21 <byorgey> Aetherspawn: all the liftIOs can indeed get annoying.  I often define  io = liftIO  just to save a bit of typing.
09:17:30 <byorgey> ah, I see I'm not the only one =)
09:17:33 <xplat> is there a sortWith exported from somewhere ... better ... than GHC.Exts?
09:18:13 <byorgey> @type sortBy . comparing
09:18:14 <lambdabot> Ord a1 => (a -> a1) -> [a] -> [a]
09:18:30 <Aetherspawn> > ^ 3
09:18:31 <lambdabot>   <hint>:1:1: parse error on input `^'
09:18:38 <byorgey> xplat: ^^^
09:18:52 <xplat> byorgey: i guess that would be a 'no' ?:)
09:19:05 <byorgey> xplat: I guess so =)
09:19:11 <Aetherspawn> blegh
09:19:25 <Aetherspawn> Oh well, night guys. Thanks for the suggestions :)
09:19:58 <Rags_> how do I process a csv file stored on a webserver?
09:20:59 <yitz> Rags_: which problem would you like to focus on first - processing csv or doing stuff on a webserver?
09:21:24 <Rags_> read the file first
09:21:34 <xplat> byorgey: and is there an equivalent of 'comparing' for 'Eq' other than 'on (==)' ?
09:21:57 <dolio> xplat: No.
09:22:12 <yitz> tibbe wrote a nice csv parser (there are a lot of them). let's see what tibbe's is called... one sec...
09:22:35 <Saizan> ?hoogle equating
09:22:35 <lambdabot> No results found
09:22:38 <Cale> http://hackage.haskell.org/package/download -- you might want to use this package to get the time
09:22:39 <Cale> file*
09:23:10 <xplat> i didn't think so, but i thought i'd check while i was here :-/
09:23:25 <Saizan> hayoo finds a few but not in standard places
09:23:27 <notdan> https://gist.github.com/co-dan/21b557de871cb877b085 does anybody know why this GHC API code does not work?
09:23:36 <nooodl> Distribution.Simple.Utils has equating
09:23:39 <dolio> There was a proposal to add it once, but it got vetoed because on existed.
09:23:51 <notdan> When I run the 'test' from Eval.hs it gives me an error as pasted in 'res_osx.txt'
09:23:54 <Rags_> yitz - it;s cassava
09:26:06 <yitz> Rags_: ah yes i see it too now
09:26:34 <yitz> Rags_: makes it easy to parse the items and produce whatever types you want
09:26:56 <monochrom> notdan: looking
09:27:37 <yitz> Rags_: it comes with built-in instances for common types - so you can autmomatically get them out of a CSV. or you can define your own instances for your own types.
09:30:13 <yitz> Rags_: a different direction is csv-conduit. it does similar things, but based on conduits.
09:30:15 <xplat> grp = liftA2 (.) (groupBy . on (==) .) (sortBy . comparing) -- :(
09:30:36 <yitz> Rags_:  so you can combine that with http-conduit or http-conduit-browser to get rich interaction with the web site - https, cookies, sessions, etc.
09:30:45 <nooodl> xplat: ewww
09:32:00 <monochrom> notdan: setSessionDynFlags $ dfs { hscTarget = HscInterpreted, ghcLink = LinkInMemory }
09:32:39 <chrisdone> @botsnack
09:32:39 <lambdabot> :)
09:33:33 <notdan> monochrom: wow, thanks!
09:33:34 <yitz> xplat: ((==) `on` whatever) reads pretty nicely I find
09:33:49 <notdan> monochrom: do you mind me asking, how did you figure out what was missing?
09:34:08 <notdan> I have just started learning GHC API and I don't know much so far
09:34:27 <monochrom> I spent a long time.
09:34:36 <yitz> elliott: request for new lambdabot feature - botsnack returns a frown when lambdabot is not feeling well
09:34:39 <xplat> yitz: yeah but ((==) `on`) reads like bastardized lisp
09:34:49 <yitz> xplat: right :)
09:35:22 <xplat> groupWith f xs = build (\c n -> groupByFB c n (\x y -> f x == f y) (sortWith f xs)) -- the version of grp from GHC.Exts, doesn't seem to read much better
09:36:11 <yitz> xplat: true, but not really fair. they made it a builder so that is subject to fusion
09:36:13 <chrisdone> yitz: the age old question: did Data *already* have emotions before the “emotion chip"?
09:36:39 <yitz> chrisdone: or did geeks just *imagine* it?
09:38:00 <chrisdone> yitz: i wonder if there is an anthropomorphism in category theory?
09:38:51 <yitz> chrisdone: well we always used to draw our diagrams to look like faces. does that count?
09:39:07 <xplat> chrisdone: oistomorphism aplenty
09:40:19 <elliott> yitz: based on system load? :)
09:40:33 <elliott> or maybe the number of recent type errors in user-submitted code!
09:40:48 <chrisdone> type errors!
09:41:22 <yitz> elliott: weird errors involving L.foo
09:43:03 <chrisdone> i wonder if anyone's ever written a dramatization of type errors in the style of shakespeare
09:43:23 <elliott> chrisdone: any progress on the hpaste spam problem, btw? some lambdabot messages were sent about it
09:43:51 <chrisdone> this friday i'm moving hpaste to another server so i'll address it while i'm doing that
09:44:11 <elliott> okay, cool
09:44:14 <josephle> chrisdone: Alas, poor Monad! I knew him, Functor.
09:44:21 <elliott> would be great to have the hpaste bot back :)
09:45:23 <chrisdone> elliott: at least in the way we discussed a while back: only announcing nicks in the chan. should sort it out
09:46:12 <xplat>     grp f = groupBy ((==) `on` f) . sortBy (comparing f) -- fine, i gave up on points-freedom and made it nicer :P
09:46:31 <chrisdone> josthe: the lengthy twine in all its bountiful browns cannot but abide thine given kinde and character!
09:46:57 <chrisdone> z
09:48:22 <elliott> chrisdone: did you see typoclass's message about all the spam containing a link to one domain?
09:48:34 <elliott> so a single blacklist should solve the problem
09:49:15 <josephle> If we Maybes have offended,
09:49:21 <yitz> xplat: now you're talking
09:49:23 <josephle> Think but Just and all is mended,
09:49:36 <josephle> That you have but Nothing'd here
09:49:43 <josephle> While these type errors did appear.
09:49:52 <nooodl> applauds
09:49:57 <thoughtpolice> @tell johnw pong
09:49:58 <lambdabot> Consider it noted.
09:49:59 <yitz> xplat: there is a difference between combinator style and point-free style
09:50:21 * chrisdone slow claps josephle 
09:50:32 <xplat> okay, my warmup exercise is done, now to write real code
09:50:38 <chrisdone> elliott: i can do that. seems like a short-term solution but it's trivial, yeah
09:50:59 <yitz> xplat: combinator style is good. it often happens to be point-free, or somewhat point-free.
09:51:16 <xplat> i kind of wish warmup exercises didn't need to be built into my real code though :-/
09:51:18 <yitz> xplat: point-free for its own sake is just an intellectual exercise, not for real code.
09:51:56 <int-e> @type ap const id
09:51:57 <lambdabot> a -> a
09:52:12 <xplat> you would think this group-and-sort stuff would be common enough to get in a real library on hackage, not just in GHC.Exts
09:52:15 <yitz> xplat: i would use the last version you wrote in real code.
09:52:27 <Clint> yitz: what is "combinator style"?
09:52:42 <xplat> yitz: yeah, i was.  but i'd rather just import something ...
09:53:32 <elliott> chrisdone: yeah. another thing is that they're all posting with an empty name
09:53:47 <yitz> Clint: expressing complex functions as a composition of a number of simpler ones
09:53:56 <Clint> yitz: ah ok
09:54:09 <yitz> Clint: like what xplat wrote above for sort-then-group
09:54:52 <chrisdone> elliott: seems a subset of requiring nicks. we talking about just solving the problem of bad announcements or general paste spam?
09:55:20 <monochrom> chrisdone: haha great idea. "expected type: String; inferred type: IO String" -> "to String or to IO String, that's the question!"
09:55:41 <yitz> yeah. the paste spam is what keeps bringing down hpaste. although announcement spam is also very annoying of course
09:56:27 <chrisdone> monochrom: haha :D
09:56:31 <xplat> pastebin spam.  this is why we can't have nice things :(
09:56:36 <elliott> chrisdone: well, the announcements are the bigger problem, but I think it's also bad for hpaste.org to list such stuff. especially since it could get it blocked for adult content by web filters etc.
09:57:35 <chrisdone> elliott: nod
09:59:07 <elliott> chrisdone: anyway, thanks for looking into it and for keeping hpaste up in general :)
10:00:21 <chrisdone> elliott: sure!
10:01:44 <yitz> monochrom: reminds me of the famous salon magazine haiku versions of windows error messages
10:03:29 <yitz> your very large file / can be extremely useful / but now it is gone
10:05:31 <notdan> In GHC API, how can I get ModuleSum or Module from Target?
10:05:36 <chrisdone> @tell typoclass tunes had a day with an incomplete log, parser rejected it, import process wouldn't continue until i manually intervened. manually patched it now and it should be back in business. you can now stalk your friends and find their embarassing comments with daily granularity
10:05:37 <lambdabot> Consider it noted.
10:05:52 <notdan> I don't know module name beforehand, but I do know the filename
10:07:26 <acube> Is there a way to get the version of GHC with the GHC-API?
10:12:25 <acube> If anyone wants to know, you can find the ghc version as cProjectVersion in the Config module of the GHC API
10:15:36 <chrisdone> acube: cool
10:16:12 <acube> So, another question, how can I use a parser of type ReadP something?
10:16:25 <yitz> acube: good work! i was going to say look up the package info for base :)
10:16:37 <acube> (From Text.ParserCombinators.ReadP)
10:17:11 <xplat> agh, filemanip's 'find' reports a directory as being at the same recursion depth as its contents ...
10:17:12 <Gracenotes> mainly, you use the Alternative and Applicative instances
10:17:37 <xplat> or *something* weird is going on anyway
10:17:38 <Gracenotes> and all of the combinators
10:17:44 <Gracenotes> some of the combinators
10:18:00 <acube> ah, there is readP_to_S. Maybe I should look at the module before asking ... (I was only using tab-completion of the functions in that module in GHCi and didn't find anything like run*)
10:18:02 <chrisdone> Gracenotes: !!!
10:18:43 <Gracenotes> chrisdone: ¡¡¡
10:18:48 <dmwit> ???
10:19:01 <chrisdone> Gracenotes: (:
10:19:40 <xplat> oh man, it really does do that
10:19:52 <xplat> that is ... i mean really?
10:21:49 <chrisdotcode_> hello everyone :)
10:26:31 <yitz> chrisdone: ¡¡¡ ǝuopsוɹɥɔ
10:27:17 <chrisdone> zt!λ
10:27:53 <chrisdone> chrisdotcode_: ^5
10:28:53 <yitz> zʇוʎ
10:29:44 * geekosaur squeegees brain, which managed to misinterpret "zt!λ" and wonder who died
10:30:44 <dmwit> Is there some abbreviation for "foo died" that I don't know?
10:31:44 <geekosaur> zt"l, Hebrew initialism (the memory of a righteous person is a blessing)
10:31:55 <yitz> dmwit: yes it's: *** Exception: Prelude.head: empty list
10:32:26 <geekosaur> (roughly)
10:32:38 <dmwit> geekosaur: aha! and lambda is an l... =D
10:32:45 <sepia> @pl \ceiling ep -> ceiling $ ep / (1 - ep)
10:32:48 <lambdabot> (. ap (/) ((-) 1)) . id
10:32:49 <lambdabot> optimization suspended, use @pl-resume to continue.
10:33:20 <dmwit> ?pl \ep -> ceiling $ ep / (1 - ep)
10:33:21 <lambdabot> ceiling . ap (/) ((-) 1)
10:33:51 <sepia> oops
10:33:54 <sepia> dmwit: thanks
10:35:20 <dmwit> I'm curious now.
10:35:24 <Rags_> if I have OverloadedStrings, can I call a function that takes ByteString with String?
10:35:25 <dmwit> ?pl \ceiling ep -> ceiling $ ep / (1 - ep)
10:35:28 <lambdabot> (. ap (/) ((-) 1)) . id
10:35:28 <lambdabot> optimization suspended, use @pl-resume to continue.
10:35:29 <dmwit> ?pl-resume
10:35:35 <lambdabot> (. ap (/) ((-) 1)) . id
10:35:35 <lambdabot> optimization suspended, use @pl-resume to continue.
10:35:39 <dmwit> Rags_: no
10:35:59 <dmwit> Rags_: Also, ByteString is not for text. Text is for text.
10:39:51 <Rags_> dmwit -> what does overloadedstrings do?
10:40:55 <chrisdone> Rags_: overloadedstrings replaces all "foo" with fromString "foo" where fromString :: IsString string => String -> string
10:40:59 <dmwit> OverloadedStrings makes string literals polymorphic.
10:42:09 <Rags_> :t fromString
10:42:09 <lambdabot>     Not in scope: `fromString'
10:42:10 <lambdabot>     Perhaps you meant one of these:
10:42:10 <lambdabot>       `BSLC.fromStrict' (imported from Data.ByteString.Lazy.Char8),
10:42:30 <acube> :t isString
10:42:31 <lambdabot> Not in scope: `isString'
10:42:55 <dmwit> :t Data.String.fromString
10:42:56 <lambdabot> Data.String.IsString a => String -> a
10:43:19 <Rags_> I have a string, the function takes bytestring; how do i convert string to bytestring.lazy?
10:43:29 <dmwit> :t fromInteger -- the analogue to polymorphic number literals
10:43:30 <lambdabot> Num a => Integer -> a
10:43:37 <dmwit> Rags_: First, choose an encoding.
10:43:49 <acube> Rags_: you probably want Data.Text, not Data.ByteString
10:43:50 <dmwit> In case your preferred encoding is UTF-8...
10:44:00 <dmwit> ?where utf8
10:44:00 <lambdabot> A ByteString containing UTF8 can be decoded into a String with "Data.Text.unpack $ Data.Text.Encoding.decodeUtf8 theByteString", from the 'text' package. (There's also the 'utf8-string' package, but
10:44:00 <lambdabot> that is old and apparently not recommended.)
10:44:02 <maxorator> how can I have a custom list type with an overloaded : and ++ operators?
10:44:10 <dmwit> ugh
10:44:17 <dmwit> That does decoding, but not encoding.
10:44:26 <dmwit> Well, anyway, there's the encoding and utf8-string packages.
10:44:46 <elliott> I don't like how that entry roundtrips through Text to get a String.
10:44:46 <acube> maxorator: You cannot overload (++) or (:), but you can overload (<>) from monoid
10:44:52 <dmwit> Despite the apparent disrecommendation, the utf8-string package is a very lightweight dependency for String -> ByteString conversion and back.
10:44:56 <elliott> you're depending on the text package. you should probably just use the resulting Text.
10:44:59 <dmwit> elliott: me neither
10:45:16 <acube> (<>) is an alias for mappend
10:45:44 <jfischoff> The hacky way would be to use Data.ByteString.Lazy.Char8.pack
10:45:44 <acube> maxorator: or do you mean custom (:) and (++) operators (with different names) ?
10:45:57 <elliott> there should be a good HaskellWiki article about the difference between ByteString and String and Text and encodings and what to use for decoding and encoding and stuff.
10:46:04 <elliott> someone should write it and then make @where utf8 link there.
10:46:20 <byorgey> jfischoff: it's not hacky.  It's either fine (if you can absolutely guarantee that you have only ASCII), or it's wrong.
10:46:23 <elliott> jfischoff: :(
10:46:32 <jfischoff> yeah
10:46:35 <elliott> jfischoff: that is like telling people to use unsafeCoerce to convert from Int to String
10:46:40 <byorgey> "hacky" implies that it works but is suboptimal somehow.
10:46:55 <jfischoff> elliot: no its not
10:46:59 <dmwit> It's hacky because it means elsewhere in your program, you are storing some ASCII as a String for some reason.
10:47:06 <maxorator> acube, I actually meant that I have something like "type CustomList a = [a]", where : operator would for example actually add to both beginning and end
10:47:11 <dmwit> ;-)
10:47:37 <elliott> ok, it's not like unsafeCoerce but it won't crash your program. but it's like unsafeCoerce in that it's a function of the right type, but with totally wrong semantics
10:47:38 <acube> maxorator: you cannot change the meaning of (:) or (++), but you can define your own operators that do that
10:47:54 <jfischoff> sure
10:47:58 <chrisdone> i always use utf8-string for string <-> bytestring
10:48:10 <dmwit> Yes, I really don't understand the hate for that package.
10:48:14 <chrisdone> sadly hackage is full of badly chosen String or ByteString
10:48:37 <dmwit> If you just avoid the String<->String conversions, everything about it seems fine.
10:49:05 <chrisdone> nod
10:49:16 <elliott> dmwit: http://hackage.haskell.org/packages/archive/utf8-string/0.3.7/doc/html/Data-ByteString-UTF8.html contains some evil functions.
10:49:31 <Rags_> dmwit or chrisdone -> I am calling getResponseBody in Network.HTTP, the getResponseBody returns a string, I then would like to call decode in cassava to parse the csv file
10:49:36 <elliott> in particular, functions that are about operating on a bytestring in utf-8 format directly rather than decoding it and then operating on that. actually, i would be fine if it even just used a newtype over bytestring
10:49:40 <Rags_> is there a better way
10:49:46 <elliott> it could even export the constructor and accessor
10:50:08 <chrisdone> Rags_: is it not overloaded to possibly return a bytestring anywhere? (like the curl API)
10:50:15 * dmwit shrugs at elliott with deep, deep apathy
10:50:18 <acube> maxorator: Except by hiding (++) and (:) from Prelude and defining your own, generalized (:) and (++)
10:50:35 <Rags_> :t getResponseBody
10:50:37 <lambdabot> Not in scope: `getResponseBody'
10:50:50 <elliott> dmwit: :(
10:50:51 <Rags_> :t Network.HTTP.getResponseBody
10:50:53 <lambdabot> Network.Stream.Result (Network.HTTP.Base.Response ty) -> IO ty
10:51:34 <Rags_> what is the meaing of type "IO ty"
10:51:35 <chrisdone> yeah like that. that's gotta be able to return a ByteString, no?
10:51:35 <elliott> @where io
10:51:35 <lambdabot> Raphael L. Levien's language with continuations as fundamental structure, described in his paper "Io: a new programming notation" (1989-09-10) at <http://dl.acm.org/citation.cfm?id=70931.70934> and
10:51:35 <jfischoff> chrisdone: you can get a ByteString
10:51:35 <lambdabot> in chapter 2 of Raphael A. Finkel's book `APLD', implementations `Amalthea',`Ganymede' - (perhaps you were looking for `@wiki Introduction to IO' ?)
10:51:35 <elliott> uh.
10:51:35 <chrisdone> it returns some ty that is an instance of Response
10:51:35 <elliott> Rags_: see http://www.haskell.org/haskellwiki/Introduction_to_IO
10:51:47 <elliott> IO ty is a description of some IO that, when performed, would result in something of type ty.
10:52:08 <Rags_> is ty a type variable?
10:52:11 <chrisdone> yeah
10:52:41 <elliott> right. it could be "a" or whatever instead
10:52:43 <chrisdone> i'd read more of your haskell book on the type system section to get more comfortable
10:52:43 <frerich> chrisdone: I don't think "instance" is the right word here.
10:52:53 <dmwit> I don't either.
10:53:08 <dmwit> The real question here is about where you're getting your Result from.
10:53:18 <chrisdone> ah, you're right. my bad, i read it as =>
10:53:32 <chrisdone> probably some function somewhere has a class constraint like Stream or so-so
10:54:13 <chrisdone> yeah: simpleHTTP :: HStream ty => Request ty -> IO (Result (Response ty))
10:54:40 <chrisdone> the curl api is pretty much the same. instances of HStream are String, ByteString (lazy) and ByteString strict
10:59:23 <acube> What? There are even monads that are not an instance of functor? :( [Distribution.ParseUtils.ParseResult from Cabal is a Monad, but not a Functor :(]
11:01:04 <elliott> hm, this is a cool use of lambdabot's @@:
11:01:09 <elliott> @@ some-newbie: @where lyah
11:01:10 <lambdabot>  some-newbie: http://www.learnyouahaskell.com/
11:01:20 <acube> what is @@?
11:01:23 <elliott> @help @@
11:01:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:01:26 <elliott> hm
11:01:27 <elliott> @help @
11:01:27 <lambdabot>  @@ [args].
11:01:27 <lambdabot>  @@ executes plugin invocations in its arguments, parentheses can be used.
11:01:27 <lambdabot>  The commands are right associative.
11:01:27 <lambdabot>  For example:    @@ @pl @undo code
11:01:27 <lambdabot>  is the same as: @@ (@pl (@undo code))
11:01:48 <elliott> it turns lambdabot's command language into a functional text expansion language, basically. :p
11:02:12 <acube> @@ some text ... @package apackage some more text
11:02:12 <lambdabot> Plugin `compose' failed with: Unknown command: "package"
11:02:19 <elliott> but its structure means you can use "@@ foo:" as a prefix to address a command's output to foo.
11:02:23 <acube> @@ some text ... @hackage apackage some more text
11:02:23 <lambdabot>  some text ... http://hackage.haskell.org/package/apackage some more text
11:02:31 <acube> nice, inline @hackage :)
11:02:49 <elliott> you might have needed parens around that @hackage, it's just coincidence that it outputs the rest
11:02:53 <elliott> as in, " some more text" was passed to @hackage there
11:03:03 <elliott> so that precise syntax wouldn't work for all commands
11:03:09 <acube> right
11:04:45 <dmwit> @@ some text ... (@hackage apackage) this text was not passed to hackage
11:04:45 <lambdabot>  some text ... http://hackage.haskell.org/package/apackage this text was not passed to hackage
11:05:21 <dmwit> ...probably
11:05:27 <acube> @@ some text (@pl \x -> x) this text was left as-is
11:05:28 <lambdabot>  some text id this text was left as-is
11:05:33 <acube> :)
11:05:44 <acube> @@ some text @pl \x -> x this text was left as-is
11:05:45 <lambdabot>  some text subtract is . flip (flip (flip (flip ($ this) text) was) left) as
11:05:49 <acube> :O
11:05:56 <chrisdone> hmm ?a is better than Hole, but Hole works in types
11:06:24 <acube> @pl a b c
11:06:25 <lambdabot> a b c
11:06:41 <chrisdone> both are cool though. i'm gonna add emacs support for them. i used to use () but Hole/?foo is nicer
11:06:47 <acube> @pl a (b (c x))
11:06:47 <lambdabot> a (b (c x))
11:06:51 <acube> hmm
11:06:56 <elliott> chrisdone: I still use () when I'm too lazy to turn on ImplicitParams
11:07:03 <chrisdone> elliott: =)
11:07:12 <elliott> chrisdone: isn't Hole just data Hole = Hole? or do you mean the GHC extensions?
11:07:26 <chrisdone> elliott: yeah just data Hole = Hole. not on a GHC that has the extensions yet
11:07:34 <chrisdone> (work-related restriction)
11:07:55 <elliott> chrisdone: how is that any different to ()?
11:07:57 <elliott> data () = ()
11:08:02 <elliott> except for being longer :)
11:08:31 <tomejaguar> It seems that any variable name beginning with _ is ignored by the unused binds warning.  What's the rationale for this?  (Not that I dislike it.  It's handy!)
11:09:10 <geekosaur> _ is generally a wildcard ("don't care")
11:09:25 <tomejaguar> Yeah, but _ is not actually a variable name.
11:09:27 <tomejaguar> _foo is.
11:09:31 <shachaf> tomejaguar: The rationale is that it's unused like _, but you want people to know what it is anyway.
11:09:32 <chrisdone> elliott: just more explicit, like as a convention for talking about / teaching it's quite good
11:09:46 <Bor0> what is the difference between _foo and _, except for that '_' is not accessible
11:10:19 <tomejaguar> Well _ is a null pattern match and doesn't bind any names
11:10:21 <chrisdone> elliott: though thinking more about it editor-wise, i could have a key to insert () and then add a mark on it. if a type error comes up whose line-column matches that mark, it could handle it specially rather than displaying a type error
11:10:25 <tomejaguar> _foo does bind the name _foo
11:10:29 <elliott> chrisdone: fair enough
11:10:35 <dmwit> Bor0: No other difference.
11:10:37 <tomejaguar> > let _ = 1 in _
11:10:38 <Bor0> I remember something in erlang, _Var doesn't cause warning
11:10:38 <lambdabot>   Pattern syntax in expression context: _
11:10:41 <elliott> I guess Hole is also better in that () is "used" for things
11:10:41 <tomejaguar> > let _foo = 1 in _foo
11:10:42 <lambdabot>   1
11:10:49 <elliott> though whenever () "fills" a hole accidentally, it's probably what you wanted there anyway\
11:11:01 <dmwit> Bor0: There is a difference between _foo and foo, however, and it is the difference you are saying: _foo doesn't cause a warning if you don't use it.
11:11:11 <Bor0> oh, okay, cool to know
11:11:15 <chrisdone> elliott: yeah. i thought the same just now. if () matches, you're good to go
11:11:22 <dmwit> (...and may cause a warning if you do use it, though I'm not 100% sure of that.)
11:11:49 <chrisdone> elliott: hm, maybe it would give less information in some cases because () is an instance of a bunch of things, whereas you might want to know "what can i put here?"
11:12:12 <chrisdone> e.g. ghc might come back with no instance for Show Hole
11:12:13 <geekosaur> the idea is that it may be easier for a person (not the computer!) to read some pattern match if you name a component even though you're not using it
11:12:26 <tomejaguar> dmwit: it doesn't
11:12:54 <elliott> chrisdone: I know. how about convert the Haskell code to Agda, insert an Agda hole in the appropriate location, and then parse back Agda's output?
11:13:01 <elliott> I think you will agree that this is perfect
11:13:02 <shachaf> _foo also does things with TypeHoles when it's unbound.
11:13:21 <chrisdone> λ> Prelude.show Hole  → <interactive>:1049:1: No instance for (Show Hole)
11:13:21 <chrisdone> λ> Prelude.show ?hole → <interactive>:1050:1: Unbound implicit parameter (?hole::a0)
11:13:21 <chrisdone> in this sense Hole's better than () and implicitparams
11:13:24 <shachaf> I have no idea why they did that.
11:13:29 <chrisdone> elliott: hehe
11:13:39 <elliott> chrisdone: I think ImplicitParams does it right there if you add a type sig
11:13:43 <elliott> i.e. :: String to the end
11:14:01 <chrisdone> but show's type is explicitly String?
11:14:33 <shachaf> chrisdone: There are two errors. The second one is a no instance for Show error.
11:14:36 <acube> :t show ?a
11:14:37 <lambdabot> Not in scope: `?'
11:14:52 <shachaf> The first one is telling you extra information about the implicitparam hole. This is useful information.
11:15:14 <dmwit> chrisdone: :t show ?hole works perfectly for me
11:15:23 <chrisdone> dmwit: what does it say?
11:15:25 <dmwit> show ?hole :: (Show a, ?hole::a) => String
11:15:28 <elliott> chrisdone: no, show ?foo's type is ?foo :: ... => String
11:15:33 <elliott> right
11:15:34 <elliott> so if you say
11:15:37 <elliott> > show ?foo :: String
11:15:38 <lambdabot>   Not in scope: `foo'
11:15:39 <lambdabot>  Perhaps you meant `T.for' (imported from Data.Traversa...
11:15:41 <elliott> I bet you get a better error
11:15:47 <elliott> hmm, implicit params are off in lambdabot?
11:15:48 <elliott> :t ?x
11:15:49 <lambdabot> parse error on input `?'
11:15:55 * elliott goes to fix
11:15:57 <dmwit> But why should you have to give an explicit type?
11:15:59 <dmwit> Just ask for the type.
11:16:01 <dmwit> Much better.
11:16:04 <shachaf> elliott: You get the same error (pair of errors).
11:16:15 <elliott> dmwit: well, the context is that you usually use implicit param holes by saying
11:16:19 <elliott> f :: A -> B; f = ... ?foo ...
11:16:28 <shachaf> ImplicitParams is better than ()/Hole/whatever (/even TypeHoles last time I checked) in most cases that actually matter. The error gives you more useful information.
11:16:28 <elliott> and then inspecting the resulting error (where it complains that f lacks the ?foo :: ... constraint)
11:16:36 <chrisdone> ahhh, you guys are using :t
11:16:46 <chrisdone> the context of use here is "i've got some code in the middle of a function"
11:16:48 <elliott> I don't usually use :t!
11:17:04 <dmwit> I see.
11:17:15 <elliott> > let ?x = 3 in ?x
11:17:16 <lambdabot>   <hint>:1:5: parse error on input `?'
11:17:19 <elliott> :/
11:17:19 <dmwit> chrisdone: Okay, you should ignore me, and not use my claims as evidence that the ImplicitParams way doesn't work.
11:17:24 <elliott> ImplicitParams is on in Pristine.hs
11:17:25 <dmwit> You'll be knocking down a straw man. =P
11:17:36 <chrisdone> Prelude> :t show ?hole → show ?hole :: (?hole::a, Show a) => String
11:17:36 <chrisdone> Prelude> show ?hole → <interactive>:10:6: Unbound implicit parameter (?hole::a0) arising from a use of implicit parameter `?hole'
11:17:37 <dmwit> ?undefine
11:17:38 <lambdabot> Undefined.
11:17:47 <dmwit> > let ?x = 3 in ?x
11:17:48 <elliott> dmwit: no, I mean, it was on in Pristine.hs when I went to look at it
11:17:48 <lambdabot>   <hint>:1:5: parse error on input `?'
11:17:51 <shachaf> chrisdone: Are you looking at the second error?
11:18:02 <elliott> dmwit: maybe it's only on for the parts of L.hs and not the evaluated code
11:18:02 <acube> :t show ?a
11:18:03 <lambdabot> Not in scope: `?'
11:18:03 <shachaf> There are two errors. The other one is like your Hole error.
11:18:10 <elliott> :t foo#
11:18:11 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
11:18:13 <shachaf> elliott: Flags are passes to mueval explicitly.
11:18:15 <elliott> > foo#
11:18:16 <lambdabot>   <hint>:1:5:
11:18:16 <lambdabot>      parse error (possibly incorrect indentation or mismatched ...
11:18:16 <chrisdone> dmwit: i'm referring to this methodology: http://matthew.brecknell.net/post/hole-driven-haskell/
11:18:24 <chrisdone> shachaf: the second error is the important one
11:18:25 <elliott> > let foo | Nothing <- Nothing = () in foo
11:18:26 <lambdabot>   ()
11:18:27 <shachaf> -XFlags, I mean.
11:18:39 <elliott> > [(x,y) | x <- [1..] | y <- [1..]]
11:18:40 <lambdabot>   Unexpected parallel statement in a list comprehension
11:18:40 <lambdabot>  Use -XParallelListComp
11:18:43 <elliott> ok, right.
11:18:43 <shachaf> chrisdone: In actual code they are both important.
11:18:50 <elliott> so 90% of these flags in Pristine.hs are ineffectual
11:19:04 <chrisdone> shachaf: why?
11:19:12 <elliott> @let test = [(x,y) | x <- [1..] | y <[ [1..]]
11:19:12 <lambdabot>  Parse failed: Parse error: EOF
11:19:16 <elliott> @let test = [(x,y) | x <- [1..] | y <- [1..]]
11:19:16 <lambdabot>  .L.hs:118:31: parse error on input `|'
11:19:22 <elliott> uhhhhhhh, what?
11:19:44 <shachaf> Because you want as much information about the Hole type as possible.
11:19:50 <elliott> well, whatever. rewriting lambdabot's eval code is high on my todo list anyway, I'll fix it then.
11:19:53 <dmwit> Conclusion: elliott does not understand lambdabot. Is not big surprise.
11:20:05 <elliott> dmwit: my plan is to understand parts of it incrementally, by rewriting them.
11:20:26 <dmwit> ambitious
11:20:35 <elliott> I think if you start understanding lambdabot you have to hand it over to someone who doesn't, though.
11:20:41 <elliott> it's the rule of mystery.
11:21:45 <elliott> dmwit: unfortunately it turns out that rewriting parts of lambdabot often seems to require understanding the old parts first.
11:21:48 <shachaf> Well, I have no need to convince people to use ImplicitParams holes.
11:22:03 <shachaf> I already convinced elliott!
11:22:17 <shachaf> (Or did I?)
11:22:26 <elliott> chrisdone: note that you often want to use multiple holes in an expression at once
11:22:36 <elliott> for instance, f x = g ?a ?b
11:22:52 <elliott> you could do f x = g ?a undefined and then f x = g ... ?b, but that's slower
11:22:54 <shachaf> I wish TypeHoles was renamed to Holes or ValueHoles or something.
11:23:07 <elliott> having names for each hole (and those showing up) is useful because of this
11:24:20 * LargePizza  Picture of my ex-girlfriend naked: http://imagetwist.com/mfryntbe0bsj
11:24:55 <chrisdone> elliott: sure that's brought up in the post i linked
11:25:40 <shergill> i like valueholes
11:26:40 <shergill> shachaf: aren't implicitparams considered dangerous though?
11:28:04 <chrisdone> there's also type lits… like Hole "1"
11:28:37 <elliott> shergill: you never actually use the implicitparams
11:28:40 <elliott> you only use them for the errors they produce
11:28:43 <elliott> and then you remove the extension
11:29:17 <chrisdone> pretty much sums up implicitparams
11:29:44 <chrisdone> in before random guy says "i used it in one obscure case once and it was very useful!"
11:29:58 <shergill> elliott: right. i was wondering if by enabling it might mess things to the point where you have to expend debugging effort once you take them out
11:30:01 <chrisdone> hm actually have you seen the gfold based on it?
11:30:47 <dmwit> I maintain a package that uses ImplicitParams. -_-
11:30:52 <chrisdone> sorry, not fold. traverse: http://hackage.haskell.org/packages/archive/traverse-with-class/0.1.1/doc/html/Data-Generics-Traversable.html
11:30:54 <shergill> i should probably read up in depth as to exactly what things are affected by implicitparams. i'm unclear on that. i'd merely avoided it like the plague
11:31:05 <chrisdone> gtraverse :: (Applicative f, ?c :: p c) => (forall d. c d => d -> f d) -> a -> f a
11:31:09 <dmwit> (I wouldn't go as far as to say "it was very useful", though.)
11:32:03 <elliott> shergill: I don't think so. their debugging use is very simple
11:32:14 <elliott> dmwit: we all experiment in our youth
11:36:25 <chrisdone> heh, someone tweeted to me that their 6yo daughter was on tryhaskell
11:36:37 <byorgey> haha, awesome =)
11:36:39 <chrisdone> :D
11:36:50 <Bor0> what is tryhaskell?
11:36:59 <byorgey> @where tryhaskell
11:36:59 <lambdabot> http://tryhaskell.org/
11:37:07 <hamid> 6yo, amazing
11:37:07 <Hafydd> Excellent.
11:37:09 <dmwit> I wonder how exciting @@'s rewrite system is.
11:37:13 <byorgey> created by the illustrious chrisdone
11:37:17 <shergill> so http://hackage.haskell.org/trac/ghc/wiki/Holes says implicit params aren't suited for debugging. apparently they aren't suitable for typing things with unknown types
11:37:23 <dmwit> > ord '@'
11:37:24 <Bor0> cool
11:37:25 <lambdabot>   64
11:37:35 <dmwit> @@ @eval text "\64botsnack"
11:37:51 <dmwit> @@ @run text "\64botsnack"
11:37:52 <lambdabot>   @botsnack
11:38:08 <elliott> dmwit: spoilers: https://github.com/mokus0/lambdabot/blob/master/lambdabot-core/src/Lambdabot/Plugin/Core/Compose.hs
11:38:14 <dmwit> not exciting enough, apparently
11:38:18 <elliott> @@ @@ @run text "\64botsnack"
11:38:19 <lambdabot> Plugin `compose' failed with: Unknown command: "botsnack\n"
11:38:24 <elliott> so close...
11:38:27 <dmwit> @botsnack
11:38:28 <lambdabot> :)
11:38:30 <elliott> @@ @@ @id @run text "\64botsnack"
11:38:31 <lambdabot>    :)
11:38:32 <dmwit> oh, lol
11:38:34 <elliott> voila
11:38:37 <byorgey> nice!!
11:38:51 <elliott> disgusting, yet beautiful.
11:38:58 <dmwit> @@ @run text "@botsnack"
11:38:59 <lambdabot>   @botsnack
11:39:07 <dmwit> o... k...
11:39:16 <dmwit> @@ @run text " @botsnack "
11:39:18 <lambdabot>    @botsnack
11:39:25 <elliott> dmwit: @@ @foo ... is just @foo ...
11:39:26 * dmwit wiggles his fingers
11:39:27 <dmwit> MAGIC
11:39:29 <elliott> oh, I see
11:39:35 <chrisdone> lol
11:39:41 <elliott> @@ @run text " (@botsnack) "
11:39:42 <lambdabot>    (@botsnack)
11:39:46 <elliott> um.
11:40:02 <frerich> dmwit: http://3.bp.blogspot.com/-fuukRVObpiI/T_W_LVsivkI/AAAAAAAABB8/YcXkIn4QeDE/s1600/magic.gif
11:40:20 <chrisdone> orly
11:40:42 <maxorator> when I try to define operators on my data, for example minus, I get errors like: Ambiguous occurrence `-'. It could refer to either `Main.-', defined at tester.hs:21:1 or `Prelude.-', imported from `Prelude' at tester.hs:1:1
11:40:45 <Bor0> @run (\x -> 3*x) 5
11:40:46 <lambdabot>   15
11:40:53 <dmwit> frerich: Conclusion: that GIF is worth exactly four words.
11:41:08 <chrisdone> @@ @run text "\nPRIVMSG #haskell :idoubtthisworks"
11:41:09 <lambdabot>   PRIVMSG #haskell :idoubtthisworks
11:41:15 <chrisdone> =(
11:41:17 <frerich> dmwit: "I cannot count"? :)
11:41:25 <monochrom> yes you have a name clash maxorator, the error message says that. choose a different name.
11:41:26 <Bor0> @@ @run text "\10PRIVMSG #haskell :idoubtthisworks"
11:41:27 <lambdabot>   PRIVMSG #haskell :idoubtthisworks
11:41:29 <simukis_> maxorator: use qualified imports or/and NoImplicitPrelude
11:41:37 <dmwit> > length (words "dmwit wiggles his fingers MAGIC")
11:41:37 <elliott> maxorator: you probably meant to give an instance of Num.
11:41:38 <lambdabot>   5
11:41:41 <chrisdone> :t text
11:41:42 <lambdabot> String -> Doc
11:41:44 <chrisdone> ahh
11:41:45 <dmwit> frerich: correct =P
11:41:46 <byorgey> @@ @@ @id @run text "\nPRIVMSG #haskell :idoubtthisworks"
11:41:48 <lambdabot>    PRIVMSG #haskell :idoubtthisworks
11:42:03 <elliott> that definitely won't work
11:42:06 <maxorator> monochrom, so I cannot use custom operators that are already used for something else for some other types?
11:42:09 <Bor0> @@ @run text "\r\rPRIVMSG #haskell :idoubtthisworks"
11:42:10 <lambdabot>   PRIVMSG #haskell :idoubtthisworks
11:42:27 <elliott> lambdabot handles multiple line output anyway
11:42:42 <maxorator> elliott, Num? My minus operator doesn't actually do anything related to numbers
11:42:45 <monochrom> you have to resolve name clashes one way or another
11:43:05 <dmwit> maxorator: You can, but it can be a bit of a pain: you must hide the import of those operators when defining yours; and you must either hide those other operators when using yours or import the new ones with qualification.
11:43:13 <Bor0> @@ @run text "PRIVMSG #haskell\10:idoubtthisworks"
11:43:14 <lambdabot>   PRIVMSG #haskell
11:43:14 <lambdabot>  :idoubtthisworks
11:43:17 <Bor0> doh.
11:43:57 <dmwit> I don't understand.
11:44:05 <chrisdone> @@ @run @quote -- it's like lambdaroulette!
11:44:06 <lambdabot>   <hint>:1:28: parse error on input `:'
11:44:06 <dmwit> The parsing code in Compose.hs doesn't mention " anywhere.
11:44:14 <frerich> maxorator: The thing is that the "Prelude" (a module which is always imported unless you explicitly told it not to" has a function called '-' as well (it's part of the "Num" type class). So when you now say "-" ghc is confused whether you mean your own function, or the one from the Prelude.
11:44:53 <xico> how do i display a stacktrace in a program run from runghc?
11:44:54 <xico> and make runghc use the _p libs
11:44:54 <dmwit> Stack trace? What's that? =P
11:45:37 <monochrom> give up one: runghc, _p
11:46:01 * chrisdone runs the word around in his mouth. “staaark-ck tray… tra—see”
11:46:49 <xico> monochrom: guess ill have to
11:47:12 <dmwit> ...then again, I don't see where it mentions @, either.
11:47:41 <monochrom> ghc -prof -fprof-auto foo.hs; foo +RTS -xs -RTS
11:47:48 <monochrom> err, typo
11:47:51 <monochrom> ghc -prof -fprof-auto foo.hs; foo +RTS -xc -RTS
11:48:26 <xico> monochrom: thx
11:48:38 <monochrom> it's in GHC user's guide 4.17.7, look for "-xc"
11:48:55 <mr-> dmwit: [ (command "@") ;-P
11:49:02 <xico> yep. i just did not knew it wasnt in runghc
11:49:06 <xico> got my stacktrace :)
11:49:14 <mr-> in composePlugin
11:49:27 <dmwit> mr-: Is that intended to be a serious suggestion?
11:49:46 <ChongLi> anyone have that link to the example of a simple haskell machine?
11:50:23 <ChongLi> it allows you to click a button to see the steps of reduction involed in evaluating a haskell program?
11:50:33 <dmwit> I mean, yes, that catches the @@ at the very beginning of the line. But it isn't clear that this catches the @'s later in the line, which is what I was talking about.
11:52:39 <elliott> maxorator: I posit that (-) is a bad name for an operator unrelated to subtraction
11:53:33 <mr-> dmwit: Does it catch it at the beginning of a line, or after each command?
11:53:34 <elliott> dmwit: re @:
11:53:35 <elliott>     let conf = cmdPrefixes
11:53:35 <elliott>     xs <- mapM evalExpr (fst (parseBracket 0 True args conf))
11:53:39 <elliott> it plumbs through the command prefixes
11:57:01 <monochrom> @where stack
11:57:01 <lambdabot> I know nothing about stack.
11:57:04 <monochrom> @where stack-trace
11:57:04 <lambdabot> I know nothing about stack-trace.
11:57:07 <monochrom> @where stacktrace
11:57:07 <lambdabot> compile with -prof -fprof-auto -rtsopts and run with +RTS -xc
11:57:38 <acube> How does cabal handle dependencies to the library that is build by the current cabal file? Does it just use -I flags to GHC, or does it use some other option the specify a package that isn't installed?
11:57:40 <elliott> hm, @where needs redirects.
11:57:51 <satc> What is a good way of parallelizing statements like let a = b + c; a' = b'+c'; a''=b''+c'';  Here b,b',b'' ,c,c',c'' are independent so a,a',a'' can be calculated in parallel. I want the way to be least intrusive to the code which I have right now.
11:58:01 <dcoutts> acube: it uses a local package db
11:58:34 <elliott> satc: you can say a `par` a' `par` a'' `par` ... in the "in" clause, for example
11:58:52 <elliott> dcoutts: I got sandboxing working and it's great, btw :)
11:58:53 <acube> dcoutts: the package.conf.inplace file?
11:58:58 <dcoutts> elliott: oh good
11:59:01 <satc> elliott: Thanks.
11:59:06 <dcoutts> acube: right
11:59:14 <acube> dcoutts: thanks
11:59:31 <dmwit> elliott: Surely parseBracket has to break things up at command boundaries, no?
11:59:37 <dcoutts> elliott: compares favourably with cabal-dev yet in your opinion?
11:59:45 <dmwit> or...
11:59:59 <dmwit> yeah, doesn't it?
12:00:09 <dcoutts> elliott: or any other feedback?
12:01:53 <elliott> dcoutts: well, I don't think I have any reason to use cabal-dev at all now :) I would say that only getting the last ten lines of the build log without opening it manually is annoying for development (though this is the fault of -j rather than sandboxing, it's part of the general user experience of a multiple-package project), and that the noisy list of every package that will be reinstalled (and the meaningless warning that it's dangerous) is distra
12:02:00 <elliott> (did that get cut off?)
12:02:04 <elliott> I can open issues for these, if they're not known and you'd like
12:03:02 <dcoutts> elliott: did get cut off at " warning that it's dangerous) is distra..." but I assume you mean it's distracting.
12:03:10 <elliott> distracting, esp. that it repeats the list when the build fails
12:03:51 <dcoutts> elliott: yes, file a ticket about these unhelpful output / logging issues together as one ticket I think
12:04:22 <elliott> dcoutts: alright
12:04:43 <ChongLi> ahh!
12:04:46 <ChongLi> I found it!
12:04:48 <ChongLi> http://www.berniepope.id.au/html/ministg/step0.html
12:11:06 <elliott> dcoutts: ok, filed https://github.com/haskell/cabal/issues/1373 :)
12:11:12 <dcoutts> ta
12:12:17 <meditans> Hi, a question related with emacs haskell-mode installation. In the installation instructions, there is a reference to something named haskell-site-file, but I don't know what is it..
12:12:27 <meditans> i'm linking the github example
12:12:38 <meditans> https://github.com/haskell/haskell-mode/blob/master/examples/init.el
12:13:10 <dcoutts> elliott: hmm, the build log could be quite long, it's a somewhat tricky ui issue, the current shortened thing was in response to the problem of getting huge dumps
12:13:56 <elliott> dcoutts: I think it makes sense when installing a package as a user
12:14:07 <elliott> dcoutts: but as a developer, a cut-off error message about code I've just written is completely useless to me
12:14:30 <elliott> dcoutts: perhaps the right solution is something to open the build log in less(1) afterwards or such...
12:14:31 <dcoutts> elliott: perhaps we just want a different default when building a local target
12:15:12 <dcoutts> elliott: hmm, I can see the appeal but it's also a bit surprising, suddenly being interactive
12:15:41 <dcoutts> elliott: ideally we'd collect just the error message of course
12:15:42 <elliott> yes, it would probably have to be an option or such
12:15:42 <elliott> right
12:15:52 <elliott> it just seems a shame to have to drop -j to get warnings and stuff too
12:15:59 <elliott> since without -j the build log is given in full
12:17:12 <dcoutts> elliott: though of course it does tell you the location of the build log to look at
12:17:21 <tgeeky> any iphone developers who can trigger an iOS 7 upgrade for a small fee?
12:17:31 <dcoutts> elliott: but yes, it's a fair point, it's not quite what you want when hacking
12:20:54 <Lethalman_> do hpaste links get shown here or something is broken?
12:21:14 <Lethalman_> I have this code: http://hpaste.org/89890
12:21:17 <monochrom> we suppressed it. there was spam.
12:21:46 <Lethalman_> ok
12:21:51 <Lethalman_> I've updated it with the error
12:21:58 <Lethalman_> so, I can grasp what that can't work
12:22:20 <Lethalman_> anyway I'd like to have a pixel and read its value somehow
12:22:43 <Lethalman_> *why that can't work
12:23:06 <Lethalman_> how can I discriminate the type of pixel given a generic image?
12:23:38 <Lethalman_> here's the relevant docs: http://hackage.haskell.org/packages/archive/JuicyPixels/3.0/doc/html/Codec-Picture-Types.html#t:PixelRGB8
12:24:28 <supki> what if pixel is not rgb?
12:24:53 <Lethalman_> supki, an error is fine, but that's not the point
12:25:00 <Lethalman_> supki, how can I test whether it's rgb?
12:25:40 <monochrom> cannot
12:25:44 <Lethalman_> awesome
12:26:17 <Lethalman_> monochrom, so I have to create a class I guess
12:26:35 <monochrom> will not change the matter
12:27:16 <monochrom> you already have many classes. one of them is Pixel, for example. see how that doesn't let you "test the type"
12:27:24 <Lethalman_> indeed
12:27:28 <Lethalman_> how can I solve the problem?
12:27:36 <Lethalman_> other than duplicating the code for each pixel type
12:28:10 <monochrom> I am not convinced that you can't afford simply pixelIsTrue :: Image PixelRGB8 -> Point2' Int -> Bool
12:29:11 <Lethalman_> monochrom, I'm starting from this: http://hpaste.org/89892
12:29:32 <Lethalman_> readImage returns a DynamicImage
12:29:39 <Lethalman_> from which I can get the inner image
12:30:17 <Lethalman_> monochrom, why should I use PixelRGB8 only
12:31:26 <elliott> why would an error be fine?
12:31:34 <elliott> you're given the opportunity to have static checking and you want to have runtime errors instead?
12:31:42 <Lethalman_> elliott, again that's not the point
12:32:03 <Lethalman_> it was an example to ask: how can I get a value out of a pixel in an image
12:32:06 <sykora> I'm sure this is a common question, but can anyone point out for me the issues with http://hpaste.org/89894 ? It's a Int/Float/Num polymorphism issue, and one I think I've solved before, but can't remember.
12:32:42 <merijn> sykora: "op a b" returns an a, not a Value
12:32:49 <merijn> sykora: Your type signature is wrong
12:32:59 <merijn> sykora: Also, it helps to pastebin the error too, next time
12:33:13 <sykora> right, let me fix that stupid mistake, and add the error
12:33:46 <geekosaur> also, a -> a -> a means the same a for both parameters and result; it's not going to work with your example usage which is Int -> Double -> (what?)
12:33:48 <merijn> sykora: And you were probably looking for fromIntegral to convert Int into Double
12:34:02 <merijn> geekosaur: I think that was his real question :p
12:34:08 <merijn> @quote monochrom fromIntegral
12:34:08 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
12:35:32 <Lethalman_> so I have to create a pixelIsTrue for each pixel directly in the main
12:35:38 <Lethalman_> where I know the type of the pixel
12:35:41 <Lethalman_> is that the only solution?
12:36:11 <applicativ> wow what is it for a pixel to be True?
12:36:23 <Lethalman_> applicativ, application specific
12:36:26 <monochrom> factor out functions of types (PixelRGB8 -> Bool), (PixelYCbCr8 -> Bool), etc.
12:36:58 <Lethalman_> monochrom, so you mean data SupportedPixel = PixelRGB8 | ...
12:37:07 <monochrom> no, I do not mean that
12:37:17 <monochrom> I mean factor out functions of types (PixelRGB8 -> Bool), (PixelYCbCr8 -> Bool), etc. I really mean it.
12:37:27 <fruitFly> Why? http://hpaste.org/89896
12:37:32 <Lethalman_> monochrom, which means create a pixelIsTrue like function for each pixel type
12:37:47 <Lethalman_> what I said above, or I still don't understand
12:38:09 <Lethalman_> pixelRGB8IsTrue :: PixelRGB8 -> Bool , etc.?
12:38:25 <applicativ> oh i see there's a pile of types wrapped by different constructors .  hm
12:38:31 <sykora> merijn: I've updated it, and added one of the error messages, the others are similar
12:38:44 <monochrom> look, some things don't need to be specific. "let p = pixelAt image x y" this much is general, no?
12:38:58 <Lethalman_> monochrom, sure, except how do I get the value of the pixel
12:41:12 <merijn> sykora: I think the problem is that the type of (+) gets decided at the call site of binary, not inside the binary function
12:42:13 <merijn> sykora: This can be fixed using some Rank2Type magic, though
12:42:45 <merijn> sykora: See my annotation http://hpaste.org/89894
12:43:49 <merijn> sykora: The difference between your and my version is that your type claims "given a function a -> a -> a, where a is an instance of Num, I have this type"
12:44:33 <merijn> sykora: i.e. if I pass a function "foo :: Int -> Int -> Int" to binary, that type checks and should work. But how can the VReal case ever work with a function of type "Int -> Int -> Int"?
12:44:59 <monochrom> Lethalman_: http://hpaste.org/89899
12:45:06 <merijn> sykora: My type says, "given a function a -> a -> a that works on *any* Num, I have this type"
12:45:24 <sykora> Makes sense.
12:45:28 <merijn> sykora: Since the "op" function has to work for any Num in my case, I can decide to pass it a Double or an Int
12:46:23 <Lethalman_> ah yes, not fast enough to write it :P thanks monochrom, lastly I figured out that data wasn't suitable for that :(
12:46:29 <merijn> i.e. "binary (foo :: Int -> Int -> Int)" is a type error in my version, GHC will complain that foo doesn't work for all possible Num's. Whereas "binary (+)" works, because (+) *does* work for any Num
12:46:32 <Lethalman_> have to check per image basis
12:47:04 <Lethalman_> monochrom, not much like that though, that's nice
12:47:24 <merijn> sykora: This is a good example, actually. I've been asked "when do I need RankNTypes?" before, and I didn't have a simple example ready :p
12:47:44 <Lethalman_> monochrom, was writing case ImageRGB8 i -> process (pixelIsTrueRGB8)
12:48:12 <sykora> merijn: Well, glad I could help with that :). Thanks.
12:50:05 <fruitFly> oh yeah haskell is awesome...the things you can do with simple case expression... so happy to be using haskell :)
12:50:27 <fruitFly> and I noticed idris uses eager evalution btw, can anyone comment on that design philosophy?
12:51:09 <maxorator> how do I define an IO procedure that does absolutely nothing
12:51:26 <monochrom> write "return () :: IO ()"
12:51:50 <fruitFly> I learned that today :D
12:52:34 <elliott> fruitFly: #idris will be better at answering questions about idris
12:52:48 <fruitFly> elliott: yea just went in there
13:02:36 <chrisdotcode_> :i splitBy
13:04:53 <Jeanne-Kamikaze> how can I disable this shitty haskell-mode help message popping up on every key press on emacs ?
13:05:10 <frerich> I often have a hard time keeping code readable and < 80 columns. Here's a recent case where I'm writing data to a temporary file, call a program which processes the file, and then later on delete the temporary file again: http://hpaste.org/89900
13:05:28 <fruitFly> @type lines
13:05:29 <frerich> Does anybody know how to realign that to make it more readable, is there some common way to do this?
13:05:30 <lambdabot> String -> [String]
13:05:31 <fruitFly> how do I get just one string of the whole document instead of [String]?
13:05:48 <frerich> @type unlines
13:05:49 <lambdabot> [String] -> String
13:06:26 <acube> @type id :: String -> String
13:06:29 <fruitFly> frerich: will the compiler parse the \n s?
13:06:31 <lambdabot> String -> String
13:07:01 <fruitFly> acube: I'm using interact to pull everything from a text file
13:07:08 <fruitFly> what does id do?
13:08:01 <chrisdotcode_> :t split
13:08:01 <lambdabot>     Ambiguous occurrence `split'
13:08:02 <lambdabot>     It could refer to either `Data.List.Split.split',
13:08:02 <lambdabot>                              imported from `Data.List.Split' at /home/lambdabot/.lambdabot/State/L.hs:79:1-22
13:08:11 <elliott> hm
13:08:17 <tohie> fruitFly: id returns whatever you pass to it, e.g. id 3 == 3, id x == x
13:08:20 <frerich> fruitFly: 'unlined' will insert \n, yes:
13:08:26 <frerich> > unlines ["alpha","beta","gamma"]
13:08:27 <lambdabot>   "alpha\nbeta\ngamma\n"
13:08:33 <Lethalman_> ok, this is what I've done so far with pixels :-) http://hpaste.org/89901
13:08:33 <elliott> I wonder what it is clashing with
13:08:38 <Lethalman_> how does it look?
13:08:59 <applicativ> fruitFly: main = interact id would just pass through what is piped to it
13:09:06 <elliott> ah, System.Random.split
13:09:09 <fruitFly> applicativ: Thanks!
13:09:12 <chrisdotcode_> hey guys, split has taken splitBy's signature in ghci, weirdly:
13:09:15 <chrisdotcode_> Prelude> import Data.Text
13:09:15 <chrisdotcode_> Prelude Data.Text> :t split
13:09:15 <chrisdotcode_> split :: (Char -> Bool) -> Text -> [Text]
13:09:23 <chrisdotcode_> elliott: that's why I was trying to check it here.
13:09:34 <elliott> @undefine
13:09:34 <lambdabot> Undefined.
13:09:36 <elliott> :t split
13:09:37 <lambdabot> Splitter a -> [a] -> [[a]]
13:09:49 <elliott> :t R.split
13:09:50 <lambdabot> RandomGen g => g -> (g, g)
13:10:04 <elliott> chrisdotcode_: perhaps the signature changed in some version of the tex tpackage
13:10:05 <chrisdotcode_> it's different in the doc: hackage.haskell.org/packages/archive/text/0.5/doc/html/Data-Text.html
13:10:24 <elliott> http://hackage.haskell.org/packages/archive/text/0.11.3.1/doc/html/Data-Text.html
13:10:27 <elliott> don't look at ancient versions
13:10:33 <chrisdotcode_> oops
13:10:38 <chrisdotcode_> completely forgot to look at the url
13:10:44 <elliott> :)
13:10:50 <chrisdotcode_> it was the first google result, but I should know better
13:10:52 <chrisdotcode_> thanks, elliott :)
13:11:05 <elliott> it's annoying, I wish hackage put some kind of big red warning at the top of old doc pages
13:11:08 <elliott> with a link to the new ones
13:11:09 <chrisdotcode_> is there a "/latest/"?
13:11:12 <elliott> yes
13:11:23 <killy9999> is the C backend in GHC being completely deprecated or will it be retained and used for non-registred builds?
13:11:57 <chrisdotcode_> okay, found the latest. thanks!
13:14:21 <chrisdotcode_> :t splitOn
13:14:22 <lambdabot> Eq a => [a] -> [a] -> [[a]]
13:14:29 <chrisdotcode_> > splitOn "aaa"  "aaaXaaaXaaaXaaa"
13:14:30 <lambdabot>   ["","X","X","X",""]
13:14:37 <chrisdotcode_> sheesh.
13:14:46 <chrisdotcode_> the latest Data.Text isn't correct either...
13:15:01 <chrisdotcode_> it's type signature is Text -> Text -> [Text] and the String examples don't where
13:15:06 <chrisdotcode_> but lambdabot gets it right...
13:15:10 <chrisdotcode_> am I missing something, perhaps?
13:15:23 <chrisdone> :t Data.List.splitOn
13:15:24 <lambdabot>     Not in scope: `Data.List.splitOn'
13:15:24 <lambdabot>     Perhaps you meant one of these:
13:15:24 <lambdabot>       `Data.List.splitAt' (imported from Data.List),
13:15:31 <chrisdone> :t Data.List.Split.splitOn
13:15:33 <lambdabot> Eq a => [a] -> [a] -> [[a]]
13:15:40 <chrisdone> yeah, lambdabot's not using Data.Text
13:15:46 <elliott> :t T.splitOn
13:15:47 <lambdabot> Couldn't find qualified module.
13:15:49 <elliott> hmm
13:16:05 <chrisdone> iirc split has different options about including or excluding things
13:16:07 <elliott> yeah lambdabot doesn't have Data.Text supported
13:16:11 <elliott> *imported
13:16:13 <elliott> maybe it should, it has bytestring
13:16:14 <chrisdone> there was a load of debate when it was first written about what a correct split is
13:17:08 <chrisdone> elliott: probs makes sense with text being so well recommended, good for examples
13:17:36 <chrisdotcode_> chrisdone: so I should use Data.List.splitOn?
13:17:41 <chrisdone> hmm, i'm sure splitWhen is different
13:17:44 <chrisdotcode_> * Data.List.Split.splitOn
13:17:49 <chrisdone> > splitWhen (==',') "a,b,c"
13:17:51 <lambdabot>   ["a","b","c"]
13:17:52 <elliott> always one more thing to import :)
13:17:59 <chrisdone> maybe there's a variation on splitWhen that takes a string
13:18:04 <elliott> oh, it's even in my todo
13:18:17 <elliott> I think text might run into the hashable safe-haskell bug though, so I will wait
13:18:31 <chrisdone> chrisdotcode_: if you're using Data.Text, no, i suggest you use Data.Text and filter (not.null)
13:18:53 <chrisdotcode_> chrisdone: I'm just trying to split some simple strings; which is preferable?
13:19:16 <chrisdotcode_> (string as in [Char])
13:19:36 <elliott> if you are working with String then you don't want Data.Text
13:19:37 <chrisdone> ah, then Data.List.Split is ok, yeah
13:19:42 <elliott> however, you may want to be working with Text in the first place
13:20:10 <fruitFly> I have a [String] , can I just inset a \n inbetween each element with intercalculate or something and it'll printout in terminal on different lines?
13:20:11 * hackagebot angel 0.4.3 - Process management and supervision daemon  http://hackage.haskell.org/package/angel-0.4.3 (MichaelXavier)
13:20:15 <chrisdone> you'll have to cabal install split, haskell's base doesn't have any decent string manipulation built-in to speak of like other languages
13:20:15 <Rags_> Is there a Google maps wrapper for haskell similar to https://code.google.com/p/pygmaps/source/browse/trunk/pygmaps.py?
13:20:24 <elliott> chrisdone: split comes iwth the platform now
13:20:30 <elliott> *with
13:20:50 <chrisdotcode_> elliott: is there any specific reason why working with Data.Text prefferable?
13:20:51 <Lethalman_> given the bitmapFromDynImage function from http://hpaste.org/89901 , if I don't support a format, is it better to return Maybe Bitmap or whatelse?
13:21:15 <Lethalman_> I think Maybe Bitmap is ok
13:21:29 <chrisdone> elliott: ah, that's good (i don't use haskell platform, i forget people are encouraged to use that)
13:21:50 <elliott> chrisdotcode_: Text is more space-efficient and faster for many operations. String is a linked list of boxed 32-bit integers, so it's kind of a bad representation for a lot of things
13:21:53 <Bor0> what's wrong with the haskell platform?
13:21:59 <elliott> Text also has more tools for dealing with Unicode and stuff
13:23:36 <chrisdotcode_> elliott: okay, cool. but that makes it even harder, because now I need to wrap my strings in Text ADTs (assuming Text is an ADT)
13:24:13 <chrisdotcode_> pack and unpack? well that was easy...
13:24:30 <chrisdone> Bor0: nothing, i got comfortable managing haskell packages before it existed. i'm not really the target audience
13:24:33 <applicativ> Bor0: nothing is wrong with the Haskell Platform surely...
13:25:12 <applicativ> oh I see.  I misunderstood Bor0 as making a statement out of the blue.
13:25:13 <Bor0> okay, I was just curious. I'm a pretty fresh haskeller myself
13:25:46 * Lethalman_ also uses cabal for everything
13:25:54 <chrisdone> if it had existed when i started i would've been using it
13:26:00 <applicativ> Bor0: it's essential on windows, convenient on os x, with a package manager, it is really just a bunch of libraries + ghc + cabal-install etc
13:26:28 <applicativ> ... but  with a package manager, it is ..
13:26:37 <Bor0> I'm using it on both windows and ubuntu
13:26:59 <chrisdone> all my jobs involve very specific package systems and sometimes custom ghcs so i've never really been on vanilla haskell
13:27:24 <Bor0> all my jobs include imperative programming languages :p
13:27:24 <elliott> chrisdone: no, no
13:27:25 <elliott> oops
13:27:27 <elliott> chrisdotcode_: no, no
13:27:40 <elliott> chrisdotcode_: you should not just be wrapping up Strings in Text to perform single operations on them like that
13:27:52 <chrisdone> Bor0: it starts that way, just give it time =p
13:27:54 <elliott> the point is, if you have Strings, use string operations; but consider first whether you shouldn't have Texts instead
13:28:39 <chrisdotcode_> elliott: well I have about a thousand lines, and I need to do a single manipulation on all of them, and then print them. should I still use Texts?
13:29:11 <chrisdone> depending on the manipulation, that's fine for strings or text. a thousand lines is nothing
13:29:14 <applicativ> that doesn't sound like an objectionable use of String.
13:29:41 <Bor0> on a scale from 1 to 10, what's the most you can achieve with LYAH only? not even sure if this question makes a lot of sense
13:29:44 <applicativ> but a zillion Chars if it is in memory is no good if it's String. that's one point
13:30:46 <applicativ> Bor0: it give the structural essentials -- though not enough about IO -- to be proficient you would then need to learn about the important libraries.
13:31:08 <chrisdotcode_> yeah, I'm just gonna stick with Strings for the simple stuff for now :)
13:31:12 <Bor0> I see. I'm not far from the IO chapter
13:31:16 <applicativ> e.g. the `text` package elliott is trying to talk chrisdotcode_ into using...
13:31:23 <Bor0> but I do experiment with ghci a lot
13:31:54 <chrisdone> there is a sort of scale: use Strings and list functions for stuff that who cares?, use Data.Text and text's functions for stuff that should be decent and repetitive, use Parsec or attoparsec for text parsing that has to be optimal, use binary or cereal to parse binary data
13:32:35 <chrisdone> there's also using bytestring + bytestring-based regexes, also fast, but regexes are frowned upon
13:32:50 <chrisdone> i wonder. has there been a tutorial written on handling text in haskell that covers all these levels with examples and benchmarks and such?
13:33:13 <chrisdotcode_> Bor0: yeah, I just finished LYAH recently, and I"m half-way done with RWH. I've got a grip on the type system, and I have a gist of how IO works (and I get monads!), but I don't know how to use liftIO forM_ and all of that other stuff.
13:33:41 <chrisdone> forM_ is easy if you try to implement it
13:33:43 <Bor0> okay, so from what I can conclude LYAH is intro level to haskell
13:33:52 <chrisdone> liftIO requires some thinking/reading, yeah
13:33:53 <applicativ> > forM [1,3,5] show
13:33:54 <lambdabot>   ["135"]
13:34:32 <sipa> :t forM_
13:34:34 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
13:34:44 <elliott> applicativ: I'm not necessarily advocating Text! :)
13:34:46 <chrisdotcode_> Bor0: yeah, LYAH taught me a lot. the chapter on applicative functors and monads didn't really help me much, but the beginning of typeclassopedia and this link (http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html) helped me understand them 100%.
13:34:54 <chrisdone> Bor0: it's intro but pretty decent to get you starting to write programs. RWH gives you things to do with performance and profiling and such
13:34:56 <elliott> I use String a lot. in fact I don't even like Text's representation much
13:35:07 <elliott> but it bears considering whenever you're working with a lot of, well, text.
13:35:17 <applicativ> elliott: no, i was arbitrarily grabbing at it, to make a point to Bor0
13:35:24 <elliott> hehe, I know
13:35:35 <elliott> no offence taken
13:35:49 <chrisdotcode_> what does "forall" mean? I've seen it in a few type signatures now...
13:36:00 <elliott> chrisdotcode_: "for all types ..."
13:36:07 <elliott> for instance, "id :: a -> a" is really "id :: forall a. a -> a"
13:36:18 <elliott> hence, "for all types a, id has type a -> a"
13:36:20 <eikke> is there an easy way to define a type family where the RHS must be a list of list of types?
13:36:22 <elliott> the outermost foralls are implicit
13:36:23 <applicativ> writing efficient haskell has its own curiosities Bor0 but again it's really crucial to use the right libraries, which put a lot of that into expert hands .....
13:36:28 <augur> koninkje1away: we should write an arXiv like thing in haskell, for linguistics papers
13:36:33 <elliott> you get foralls in arguments when working with "rank-2" (then "rank-N") types, like runST
13:36:34 <eikke> type family Foo a = [[*]] seems not to work as I'd expect
13:36:53 <Bor0> I see, thanks. this is helpful and good to know
13:37:05 <chrisdotcode_> elliott: so it seems that "forall a" is just the same as "a" to me?
13:37:09 <chrisdone> GHC has an ImplicitForall extension enabled by default, even, iirc
13:37:16 <applicativ> eikke: no, isn't it precluded by the fact that only Haskell98 types can be promoted, or am I making no sense?
13:37:35 <elliott> chrisdotcode_: if "forall a" was the same as "a", then "id :: forall a. a -> a" would be "id :: a. a -> a"
13:37:38 <eikke> applicativ: normally [] is promoted AFAIK
13:37:39 <elliott> but the latter is a syntax error
13:37:54 <elliott> chrisdotcode_: it is the case that "foo :: ... x ... y ... z" is implicitly "foo :: forall x y z. ..."
13:38:11 <applicativ> eikke: yes, it's that you're using two layers, I was thinking.
13:38:21 <elliott> chrisdotcode_: i.e., the type variables you leave free in a type signature are implicitly universally quantified; when you say "foo :: ... a ..." you say: I work for any "a" you can think of
13:38:23 <chrisdone> elliott: i think he means that "forall a. a" is just the same as "a"
13:38:33 <elliott> which means "forall a. ... a ...": "for any a you can think of, I am ... a ..."
13:38:35 <eikke> oh, right
13:38:42 <chrisdotcode_> chrisdone: er, I have no idea, I'm actually asking :)
13:38:51 <chrisdone> oh, okies
13:39:00 <chrisdotcode_> so "forall a. a" is that dot composition there?
13:39:04 <elliott> it's true that "undefined :: a" is the same as "undefined :: forall a. a" yes
13:39:10 <elliott> chrisdotcode_: no, it's part of the syntax of forall
13:39:15 <elliott> the syntax is: forall a b c. ...
13:39:25 <elliott> the things before the . are the type variables you're saying you work for any choice of
13:39:33 <chrisdotcode_> elliott: is there an "there exists" qualifier?
13:39:37 <elliott> the thing after the . is the type you are, given choices for those variables
13:39:45 <elliott> chrisdotcode_: sort of
13:39:51 <chrisdone> in practice you can ignore forall most of the time. if it appears inside parentheses then you're encountering an extension
13:39:55 <elliott> not quite a first-class one; there are two options for representing existentials
13:40:13 <elliott> if you do: data MyExists = forall a. Witness (...)
13:40:17 <applicativ> chrisdotcode_: no 'exists', it is represented by using forall in the antecedent so to say
13:40:21 <elliott> then MyExists is like (exists a. ...)
13:40:34 <elliott> (this requires an extension)
13:40:36 <chrisdotcode_> okay, that makes sense
13:40:52 <chrisdotcode_> forall meaning implicitly universally qualified types makes sense ...but it seems redundant. I'm assuming that it's for some higher-level stuff (like you guys said extensions) that I don't know about yet.
13:40:52 <elliott> you might find that "forall" syntax a little weird. it is because the type of the *constructor* is Witness :: forall a. ... -> MyExists, exploiting the duality of universal/existential quantification
13:41:21 <applicativ> the constructor Witness can take any a as argument. So a given "Witness ..." might have anything there, so to say
13:41:31 <elliott> the other option is doing it "continuation-passing style"... instead of (exists a. ...), (forall r. (forall a. ... -> r) -> r)
13:41:42 <elliott> if you know formal logic, this will make sense. otherwise you probably don't have to care, at least not right now.
13:42:05 <chrisdone> fwiw i wouldn't have had any idea what you guys are talking about when i was starting haskell. i'd be surprised if chrisdotcode_ is not confused by all the mumbo jumbo, but fair play if not
13:42:34 <chrisdotcode_> chrisdone: I'm confused as to why it couldn't just be "data MyExists a = Witness a" instead.
13:42:35 <nooodl> is there a good example of a type signature where the "forall." part really matters
13:42:53 <applicativ> chrisdotcode_: in the "GADT" syntax, it is clear that you are typing the constructor, and so I think more intelligible data Witness where Witness :: forall a . Show a => a -> Witness
13:42:55 <eikke> :k [Int, Int]
13:42:56 <lambdabot>     Illegal type: '[Int, Int] Perhaps you intended to use -XDataKinds
13:43:10 <applicativ> yeah we did intend that lambdabot
13:43:17 <eikke> this is strange
13:43:26 <chrisdone> nooodl:
13:43:28 <chrisdone> :t runST
13:43:30 <lambdabot> (forall s. ST s a) -> a
13:43:33 <eikke> :k [Int, Int] -> [*], and :k [Int] -> *
13:43:34 <lambdabot> parse error on input `*'
13:43:39 <elliott> chrisdone: well, chrisdotcode_ asked if there was a "there exists"
13:43:39 <eikke> that's not exactly what I expect :-/
13:43:43 <monoidal> eikke: * is not a type
13:43:47 <jyeo> lambdabot: help
13:43:47 <elliott> chrisdone: so I figured it was alright to go a bit abstract :P
13:44:05 <chrisdotcode_> heh. I think I'm gonna need to read more about this. also, kinds, too, which I don't understand.
13:44:06 <monoidal> eikke: merely ":k *" fails
13:44:25 <eikke> monoidal: err?
13:44:28 <chrisdotcode_> s/understand/understand yet/
13:44:33 <chrisdone> nooodl: the 's' in runST is restricted to inside of the parens, it doesn't exist as a variable outside
13:44:39 <elliott> chrisdotcode_: but chrisdotcode_ has a point: you rarely need to care about this forall/exists stuff
13:44:59 <monoidal> eikke: after ":k" you are expected to give a type. Int is a type, [Int] is a type, but [Int] -> * or * are not types.
13:45:05 <chrisdotcode_> oddly, I'd actually *like* to learn some of the theory behind Haskell when I get a bit more versed :)
13:45:22 <eikke> monoidal: that was just a figure of speech :)
13:45:34 <chrisdone> that's not odd, that's normal for haskellers =p
13:45:54 <chrisdotcode_> a promising future is always a good thing =p
13:46:01 <chrisdone> elliott: yeah i can see why asking about exists implies a theoretic understanding
13:46:42 <chrisdone> do any of the other MLs have exists?
13:47:12 <elliott> do you consider Coq an ML? :P
13:47:17 <eikke> so, could anyone explain? :)
13:47:26 <chrisdone> that's cheating =p
13:47:46 <elliott> eikke: I am not sure what you want explaining (perhaps show some unexpected output?)
13:48:11 <nooodl> ":k [Int, Int] is [*], and :k [Int] is *"
13:48:16 <nooodl> (the ->s were kinda confusing there)
13:48:39 <chrisdotcode_> :t map
13:48:40 <eikke> yeah, sorry
13:48:40 <lambdabot> (a -> b) -> [a] -> [b]
13:50:04 <elliott> eikke: ah
13:50:09 <monoidal> noodl, eikke: Ah. that's because one-element is [x] is special syntax
13:50:12 * hackagebot hashable 1.2.0.8 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.0.8 (JohanTibell)
13:50:24 <elliott> eikke: I can explain. when there is a clash between type and lifted type, type wins
13:50:28 <elliott> and you need to use ' in front to get lifted type
13:50:29 <nooodl> what is [Int, Int] even
13:50:34 <chrisdone> chrisdotcode_: actually the wiki seems to have a not bad summary of rank in haskell's types: http://www.haskell.org/haskellwiki/Rank-N_types
13:50:39 <elliott> eikke: similarly, data Foo = Foo
13:50:45 <elliott> eikke: then Foo :: * and 'Foo :: Foo
13:50:50 <monoidal> noodl, eikke: '[Int] (note the ') has kind [*]
13:50:54 <chrisdotcode_> chrisdone: thank you. :)
13:50:55 <elliott> when you do [Int, Int] it cannot possibly be of kind *
13:50:55 <eikke> interesting
13:51:01 <chrisdotcode_> I find it hard to follow a trail through the wiki
13:51:03 <eikke> and makes sense
13:51:09 <elliott> I assume you are intending to use DataKinds/know about the extension?
13:51:11 <chrisdotcode_> there's no "begin here, then go here, next here..."
13:51:16 <elliott> if not then the answer is "you don't want [Int, Int]"
13:52:16 <eikke> elliott: yeah, it certainly is what I'm intending :)
13:52:23 <Tohie> How would you solve this problem in haskell? http://stackoverflow.com/questions/710670/c-sharp-permutation-of-an-array-of-arraylists
13:52:38 <elliott> eikke: you may wish to consider writing '[Int, Int] anyway, to avoid confusing other people like you have been confused
13:52:49 <elliott> I think the ' should always be required
13:53:04 <monoidal> > sequence [[1,5,3,9],[2,3],[93]] -- Tohie
13:53:06 <lambdabot>   [[1,2,93],[1,3,93],[5,2,93],[5,3,93],[3,2,93],[3,3,93],[9,2,93],[9,3,93]]
13:53:28 <eikke> yeah, would make sense
13:53:35 <elliott> Tohie:
13:53:45 <elliott> > [(x,y,z) | x <- [1,5,3,9], y <- [2,3], z <- [93]]
13:53:46 <lambdabot>   [(1,2,93),(1,3,93),(5,2,93),(5,3,93),(3,2,93),(3,3,93),(9,2,93),(9,3,93)]
13:53:59 <elliott> > (,,) <$> [1,5,3,9] <*> [2,3] <*> [93]
13:54:00 <lambdabot>   [(1,2,93),(1,3,93),(5,2,93),(5,3,93),(3,2,93),(3,3,93),(9,2,93),(9,3,93)]
13:54:06 <elliott> lots of exciting options, some more obfuscated than others
13:54:58 <Tohie> Thank you, sorry for the really stupid question
13:55:13 * hackagebot hashable 1.2.0.9 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.0.9 (JohanTibell)
13:56:18 <elliott> tibbe: ooh, does that have the Safe Haskell fix?
13:56:36 <tibbe> elliott: not yet
13:56:40 <tibbe> I'm leaving on vacation!
13:56:44 <tibbe> is the fix really easy?
13:56:54 * tibbe dislikes how SafeHaskell infects every library
13:57:07 <elliott> tibbe: you just need to add three lines
13:57:14 <tibbe> I haven't vetted the whole library enough to know if the Thrustworthy claim is actually true
13:57:18 <tibbe> elliott: ^^
13:57:22 <elliott> Safe Haskell doesn't really infect every library, only ones that use unsafePerformIO to generate random seeds ;)
13:57:31 <sclv_> trustworthy i thought was "trustable"
13:57:32 <elliott> tibbe: Trustworthy claim isn't the same as a Safe claim
13:57:41 <sclv_> the claim is "someone else may want to trust this"
13:57:45 <elliott> tibbe: it just means that if I *decide* to trust hashable, I'm allowed to consider Data.Hashable safe
13:57:53 <tibbe> elliott: no no
13:58:12 <tibbe> it's an assertion by me that it doesn't break type safety and you can chose to trust that assertion
13:58:21 <chrisdone> tibbe: where you going?
13:58:23 <tibbe> I'm not going to make that assertion without actually checking that it's true
13:58:32 <tibbe> chrisdone: here and there, I'll be gone for 2.5 months
13:58:38 <elliott> tibbe: how about when -ffixed-salt is on?
13:58:42 <elliott> you don't use unsafePerformIO then, right?
13:58:44 <chrisdone> tibbe: a haskell nomad, huh? ;-)
13:58:51 <tibbe> elliott: no
13:58:55 <tibbe> chrisdone: :)
13:59:04 <elliott> currently this issue blocks having lens, void, and just about any package that depends on hashable in lambdabot's evaluation
13:59:14 <elliott> because it's based on safe haskell
13:59:16 <Hafydd> is Thrustworthy a type class?
13:59:28 <elliott> I'm happy to compile hashable with -ffixed-salt for the purpose, of course
13:59:57 <elliott> tibbe: btw, enjoy your vacation, when you won't have people pestering you about safe haskell :P
14:00:18 <tibbe> elliott: they can try, but I bet they won't reach me in madagascar
14:00:20 <tibbe> ;)
14:00:26 <Taneb> (is it even possible to break type safety with Hashable?
14:00:31 <eikke> tibbe: oh, so 2.5 is *months* ?!
14:00:46 <tibbe> eikke: yes
14:00:51 <eikke> woah, that's nice
14:00:54 <tibbe> :)
14:00:59 <tibbe> not all in madagascar though
14:01:04 <tibbe> will be around europe for most of the time
14:01:10 <elliott> Taneb: well, it's not obvious that hashable can claim to be RT with the randomised salts
14:01:11 <fruitFly> I'm trying to add onto the arguments of a list comprehension recursively: [[a] | a < - [0..255]], then [[a,b] | a <- [0..255], b <- [0.255] ? how do you think I should do this?
14:01:14 <elliott> even though it's consistent between program runs
14:01:18 <eikke> tibbe: give me a ping if you'd be around Belgium ;-)
14:01:23 <elliott> but I think with -ffixed-salt it obviously is safe
14:01:24 <Taneb> "RT"?
14:01:26 <chrisdone> tibbe: hm, will you be at zurihac?
14:01:27 <tibbe> eikke: i wont be im afraid
14:01:29 <fruitFly> I'm trying to add onto the arguments of a list comprehension recursively: [[a] | a < - [0..255]], then [[a,b] | a <- [0..255], b <- [0..255] ? how do you think I should do this?
14:01:36 <tibbe> chrisdone: no, wont be in zurich at that time
14:01:41 <chrisdone> okies
14:02:04 <tibbe> damn ghc 7.0.4
14:02:15 <elliott> tibbe: hm. if you only import System.IO.Unsafe behind a #ifdef FIXED_SALT
14:02:17 <elliott> barrier
14:02:23 <elliott> er, ifndef
14:02:26 <elliott> I think it would get inferred as safe given -ffixed-salt
14:02:36 <tibbe> elliott: can you bug bryan about it once I'm gone?
14:02:41 <elliott> oh... I guess it uses Data.ByteString.Unsafe :(
14:02:42 <tibbe> I don't really have time now, sorry
14:02:49 <elliott> tibbe: sure, there's already a bug on the issue tracker
14:02:54 <elliott> it does look more complicated than I thought
14:03:16 <sclv_> elliott: in the meantime, you can just run your own patched version locally for \bot, right?
14:03:19 <tibbe> elliott: he might not see it, we're both pretty busy
14:03:51 <elliott> sclv_: yeah, I guess I'll slap a big ol' potentially-lying Trustworthy on it and install it with -ffixed-salt
14:04:01 <applicativ> fruitFly: It's hard to figure what you want. Those are valid comprehensions, no?
14:04:42 <elliott> sclv_: I'll look into it after the big unicode-handling change I'm planning now
14:04:50 <elliott> which I suspect is going to be intensely annoying
14:04:53 <applicativ> fruitFly: consider how [[a,b] | a <- [0..255], b <- [0..a]] differs from the second
14:05:13 * hackagebot hashable 1.2.0.10 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.0.10 (JohanTibell)
14:05:15 <applicativ> >  [[a,b] | a <- [0..5], b <- [0..a]]
14:05:16 <lambdabot>   [[0,0],[1,0],[1,1],[2,0],[2,1],[2,2],[3,0],[3,1],[3,2],[3,3],[4,0],[4,1],[4...
14:05:42 <fruitFly> applicativ: I'm xoring [Word8] against a variable length key, so I need to get a result of all the xors of key [0..255], [[0..255], [0..255]] etc.
14:05:59 <merijn> I need more vim test monkey^H^H^H^H^H^Hhaskell programmers
14:06:07 <merijn> Any volunteers? :p
14:06:46 <elliott> merijn: is this about that haskell indentation thing?
14:07:04 <fruitFly> applicativ: I get that
14:07:09 <Andrea_> >range(0,4)
14:07:31 <Peaker> > [0..3]
14:07:32 <lambdabot>   [0,1,2,3]
14:07:35 <merijn> elliott: Yes, it should be mostly ready for real world use
14:08:25 <chrisdotcode_> can someone please tell me why "fileName = getArgs >>= take 1" doesn't work?
14:08:38 <jyeo> > :type f g h = g (h f)
14:08:39 <elliott> merijn: I could give it a go, although I find I tend to develop a very personal hatred of haskell autoindenters quickly
14:08:39 <lambdabot>   <hint>:1:1: parse error on input `:'
14:08:43 <Peaker> chrisdone, >>= wants (a -> m b) as it's right-side argument
14:08:55 <Peaker> @type take 1
14:08:56 <lambdabot> [a] -> [a]
14:08:59 <mithsv> merijn: sounds interesting, link?
14:09:00 <Peaker> oops
14:09:03 <merijn> Biggest issues left are nested where and let/in clauses not working too well (but who uses those?!), multiline comments (i.e {- -}) and detecting line continuations within various braces/parens
14:09:03 <Peaker> chrisdotcode_, ^^
14:09:06 <jyeo> @type f g h = g (h f)
14:09:07 <lambdabot> parse error on input `='
14:09:10 <merijn> elliott, mithsv: https://github.com/merijn/haskellFoldIndent
14:09:43 <Peaker> chrisdotcode_, so for take 1, a=[_a], m = [], b = _a  (_a is take's a).  But in getArgs, m=IO
14:09:45 <jyeo> @type (\ f g h -> g (h f))
14:09:45 <chrisdotcode_> Peaker: oh, right. take doesn't return a monad.
14:09:45 <lambdabot> t2 -> (t1 -> t) -> (t2 -> t1) -> t
14:09:50 <merijn> I've reached the point where I can reindent something like https://github.com/merijn/posix-pty/blob/master/System/Posix/Pty.hs and get almost the exact same layout from autoindent :)
14:09:58 * jyeo hugs lambdabot
14:10:11 <chrisdotcode_> merijn: are you working on a plugin for vim and indentation? :D
14:10:14 <Peaker> chrisdotcode_, don't say "a monad" for a value of type "m a".  the *type* "m" is the monad.  the value of type "m a" is "an action"
14:10:37 <Peaker> chrisdotcode_, IO is a monad. IO a   is an action type.
14:10:41 <merijn> chrisdotcode_: Yeah, see the link just now
14:11:00 <chrisdone> Peaker: huh?
14:11:04 <chrisdotcode_> Peaker: huh, okay. so then how would I make that code work?
14:11:04 <chrisdone> oh
14:11:15 <Peaker> chrisdone, sorry, xchat has awful completion :(
14:11:16 * chrisdone peaks at peaker
14:11:16 <chrisdotcode_> chrisdone: he meant me, but tab completion got him :)
14:11:37 <Peaker> it doesn't have any heuristic about who talked last, or even who I completed last
14:11:50 <Peaker> chrisdone, did you try out lamdu recently?
14:11:59 <chrisdone> i saw a screenshot mgsloan linked me
14:12:08 <chrisdone> it looks insane
14:12:11 <chrisdone> keep up the good work =p
14:12:15 <Peaker> Thanks! :)
14:12:25 <Peaker> we've diverged from Haskell somewhat (e.g: no currying)
14:12:34 <elliott> merijn: my immediate feedback is that after typing in a do block and backspacing away the indents and starting a new line, it shoves me back into the do block, indentation-wise
14:12:44 <elliott> (I'm the kind of terrible person that does way too much in insert mode)
14:12:50 <chrisdone> Peaker: does it have the keyword style/record passing thingie?
14:13:04 <merijn> elliott: Yeah, the handling of blank lines needs work
14:13:06 <Peaker> chrisdone, yeah, but of course you don't have to manually type in the argument names
14:13:25 <elliott> merijn: is there anything in particular you'd like comments on?
14:13:27 <josephle> Peaker: is this similar to ATS's creator's reasons? (i.e. tuples are more efficient, so I see no point in currying)
14:13:27 <merijn> elliott: See the todo list at the bottom of the README ;)
14:13:30 <chrisdotcode_> Peaker: so how would I get the filename from the IO action? I need something that removes the "unlifts" the monad, I guess? (guess at the terminology)
14:13:35 <merijn> elliott: "better indentation adjustment after blank lines"
14:13:50 <elliott> pfft, reading
14:13:53 <Peaker> josephle, it's because we want named arguments in call sites, and records are useful for that
14:13:55 <chrisdotcode_> *something that "unlifts" the monad
14:14:03 <Peaker> josephle, and because our UI can deliver the benefits of currying
14:14:05 <merijn> elliott: Mostly, I'm looking for people to play with it and report any broken/ugly things that should be fixed
14:14:22 <elliott> alright
14:14:51 <et09> is there a working haskell graph database queryable by another language?
14:15:00 <elliott> merijn: do you know of any good plugin to make backspace delete full shiftwidths of indents when deleting whitespace at the start of the line?
14:15:10 <elliott> I need that when using autoindenters or else I start throwing my computer out the window quicker
14:15:15 <chrisdone> elliott: what editor do you use?
14:15:22 <Tohie> chrisdotcode_: Use bind (>>=)
14:15:27 <merijn> blank lines and mixing haddock comments in with multiline type signatures are things I'm aware off, also a "smart" backspace/tab key
14:15:33 <merijn> elliott: There's a vim setting, hold on
14:15:48 <chrisdotcode_> Tohie: I was using bind, heh. I was doing "fileName = getArgs >>= take 1", but that doesn't work.
14:16:07 <elliott> chrisdone: vim, since I'm trying out merijn's vim haskell indentation plugin after all :)
14:16:15 <Peaker> chrisdotcode_, http://hpaste.org/89903
14:16:18 <et09> elliott: i just use ctrl-w
14:16:26 <monochrom> fmap (take 1) getArgs
14:16:48 <merijn> elliott: You want "set smarttab"
14:17:00 <monochrom> equivalently: getArgs >>= \x -> return (take 1 x)
14:17:04 <Andrea_> :t (>>=)
14:17:05 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:17:06 <et09> however you can write a bash plugin that maps a key to delete the last tab or (shiftwidth) * space characters of the line you're on
14:17:06 <Peaker> chrisdotcode_, if you have a pure function and an effect, (<$>) works. pure/pure: $, impure/impure: =<< or <*> depending on where the effect is in the function
14:17:17 <Andrea_> :t (=<<)
14:17:18 <lambdabot> Monad m => (a -> m b) -> m a -> m b
14:17:19 <merijn> elliott: "When on, a <Tab> in front of a line inserts blanks according to 'shiftwidth'.  'tabstop' or 'softtabstop' is used in other places.  A <BS> will delete a 'shiftwidth' worth of space at the start of the line."
14:17:32 <Peaker> chrisdotcode_, choose the right function application operator based on what kind of function/argument you have
14:17:33 <et09> ah
14:17:39 <chrisdone> elliott: ah, ok. i have a pretty sweet indentation support in a minor mode i'm working on locally called structured-haskell-mode. it parses the declaration with hse and you indent/navigate like paredit with lisp
14:17:43 <elliott> merijn: cool, thanks. I'm totally terrible at vim config, I actually just started using it almost by accident because I got sick of the emacs haskell-mode autoindentation, I think
14:17:57 <chrisdone> this whole deleting whitespace stuff is soooo 2012
14:18:05 <merijn> elliott: See https://github.com/merijn/dotfiles/blob/master/vimrc
14:18:12 <merijn> elliott: I documented mine for scenarios like this :p
14:18:14 <Peaker> chrisdone, how usable/far along is your structural haskell support in emacs?
14:18:16 <et09> what's the new thing chrisdone
14:18:34 <elliott> merijn: configuration like this is what makes me give up on editors :P
14:18:42 <chrisdone> Peaker: i've been using it for a couple weeks. it's still buggy, but in terms of editing it's more or less like paredit
14:18:49 <Andrea_> (=<<) what is this ?
14:18:52 <Peaker> chrisdone, haven't used paredit
14:19:09 <Peaker> Andrea_, it's flip (>>=).. more easy to contrast with ($) and (<$>) and (<*>)
14:19:39 <Peaker> chrisdone, I saw some screencasts of yours with structural mode in emacs, seemed pretty slick
14:19:45 <Andrea_> Peaker, (>>=) is bind, and (=<<) ???
14:19:55 <nooodl> Andrea: flip bind
14:19:57 <merijn> Andrea_: The same, just reversed argument order
14:20:05 <Peaker> Andrea_, bind with its arguments flipped
14:20:07 <Andrea_> thx
14:20:15 <Peaker> @type flip
14:20:16 <lambdabot> (a -> b -> c) -> b -> a -> c
14:20:20 <Peaker> @type flip (>>=)
14:20:21 <lambdabot> Monad m => (a -> m b) -> m a -> m b
14:20:54 <merijn> elliott: I invested a week once t set up my entire command line environment and now I just version control and document any new changes, which keeps things manageable :)
14:21:42 <chrisdotcode_> Peaker: there's no (m a -> a) function?
14:21:44 <elliott> merijn: yeah, I should probably set up a repo of stuff, but I find that I actually work quite well with pretty crappy tools... for a few days I've been using a vim without even any syntax highlighting or nocompatible set, and it was only minorly annoying me
14:22:11 <Andrea_> >flip(\a b -> a - b) 3 4
14:22:17 <chrisdotcode_> like, if I was in main, and I wanted to get the filename of the first passed in argument without using do notation.
14:22:35 <elliott> chrisdone: (IO a -> a) would break the semantics of the language
14:22:45 <elliott> it would defeat the whole purpose of having first-class IO actions
14:22:47 <Peaker> chrisdotcode_, that would defeat the whole point
14:22:50 <geekosaur> chrisdone, some monads let you do that, IP emphatically does not  (and would break things badly if it did)
14:22:52 <chrisdotcode_> elliott: ...right. >_>
14:23:02 <chrisdotcode_> so how should I go about doing it?
14:23:03 <chrisdone> dudes fix your tab completors
14:23:03 <Hafydd> @hoogle unsafePerformIO
14:23:03 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
14:23:03 <lambdabot> Foreign unsafePerformIO :: IO a -> a
14:23:03 <lambdabot> Graphics.UI.GLUT.Raw.APIEntry unsafePerformIO :: IO a -> a
14:23:06 <Tohie> chrisdotcode_: You would write a normal function that takes a string and then lift it using fmap or applicatives etc.
14:23:12 <elliott> Hafydd: please don't
14:23:18 <geekosaur> hiwever do notation turns into uses of >>=
14:23:41 <Hafydd> I don't recommend using unsafePerformIO.
14:23:46 * hodapp steps up on a soapbox with a megaphone in hand.
14:23:47 <geekosaur> and when you someIOFunction >>= \thing -> ..., within the ... `thing` is directly usable
14:23:51 <chrisdotcode_> basically, I want to read in a filename as the first argument, and then print it, without using do notation
14:23:57 <chrisdotcode_> (in the main function)
14:24:01 <geekosaur> without the IO wrapper. (but the ... must ultimately be an IO action)
14:24:02 <hodapp> I would like to thank #haskell for not being a bunch of assholes to me. That is all.
14:24:04 * hodapp steps down
14:24:28 <Peaker> for xchat, use: /set completion_sort 1   (just fixed mine)
14:24:45 <Hafydd> @hoogle Monad m => m a -> a
14:24:45 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
14:24:45 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
14:24:45 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
14:24:53 <geekosaur> @undo do { args <- getArgs; foo (args !! 0) }
14:24:53 <lambdabot> getArgs >>= \ args -> foo (args !! 0)
14:25:14 * hackagebot Nomyx-Language 0.2.2 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.2.2 (CorentinDupont)
14:25:18 <Peaker> chrisdotcode_, the idea is that instead of taking values out from the monad to your function, you lift your function into the monad... basically you give a callback to handle the value, and you get back a chained action
14:25:40 <Hafydd> Why does hoogle give me signatures which clearly aren't of the form "m a -> a" when I ask for that?
14:25:56 <arkeet> because it doesn't find an exact match and gives its best guess.
14:26:02 <chrisdotcode_> Peaker: okay, that makes sense, and I'm sure it's a simple two liner, too. but I can't wrap my mind around it at the moment...
14:26:15 <Hafydd> I'm pretty sure unsafePerformIO is an exact match to that.
14:26:29 <arkeet> no. unsafePerformIO has type IO a -> a
14:26:37 <Hafydd> It's of the form m a -> a
14:27:00 <Peaker> chrisdotcode_, if you read my paste, the fix to your original attempt is easy
14:27:10 <geekosaur> there is no generic way to escape a Monad, m a -> a
14:27:23 <Peaker> chrisdotcode_, you used (=<<) (impure/impure) when you have pure/impure   which is a case for (<$>)
14:27:28 <elliott> maybe hoogle tries not to be unhelpful :)
14:27:32 <arkeet> Hafydd: ok, I looked on hoogle myself. it's there.
14:27:48 <arkeet> further down on the list.
14:27:59 <chrisdotcode_> Peaker: fileName = take 1 <$> getArgs?
14:28:02 <Hafydd> I see...
14:28:09 <arkeet> also try removing the Monad constraint.
14:28:15 <Peaker> unsafePerformIO is not a good thing to mention to someone asking how to do basic IO
14:28:16 <eikke> elliott: type family D (a :: T) :: ['[T]] -> parse error on the `'', is that expected?
14:28:19 <arkeet> hoogle doesn't really know anything about instances.
14:28:28 <Hafydd> @hoogle m a -> a
14:28:29 <lambdabot> Language.Haskell.TH.Syntax Q :: (forall m. Quasi m => m a) -> Q a
14:28:29 <lambdabot> Network.BufferType buf_empty :: BufferOp a -> a
14:28:29 <lambdabot> Data.Monoid getDual :: Dual a -> a
14:28:36 <Peaker> @type take 1 <$> getArgs
14:28:37 <lambdabot> Not in scope: `getArgs'
14:28:43 <arkeet> http://www.haskell.org/hoogle/?hoogle=m+a+-%3E+a
14:28:47 <elliott> eikke: um, er, I don't quite know what you mean yb that declaration
14:29:01 <elliott> my mental category checker is confused
14:29:23 <eikke> "a type family called D for types of kind T who map to a list of lists of types of kind T"
14:29:29 <Peaker> chrisdotcode_, well, that works but it gets a list of length 0 or 1, rather than a single filename.  also, it's wrapped in IO (as it well should be)
14:29:30 <Andrea_> getArgs is monadic , I think
14:29:51 <elliott> eikke: how about '[[T]]?
14:30:04 <Peaker> chrisdotcode_, do { args <- getArgs ; case args of ... } might be a better way to do cmdline handling
14:30:09 <eikke> elliott: same thing on that '
14:30:14 * hackagebot Nomyx 0.2.2 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.2.2 (CorentinDupont)
14:30:15 <Peaker> chrisdotcode_, (or a cmdline library better still)
14:30:17 <elliott> eikke: oh!
14:30:19 <elliott> eikke: it's a kind
14:30:22 <elliott> there's no ambiguity
14:30:24 <merijn> Hafydd, Peaker: unsafePerformIO is not a good thing to mention to someone, ever. People who need it and are capable of using it already know it exists
14:30:25 <elliott> so there's no use for '
14:30:27 <elliott> just [[T]]
14:30:42 <chrisdotcode_> Peaker: yeah, but for now, I'm trying to learn how to do it manually, and I want to try it without do notation :)
14:30:48 <elliott> merijn: well, it is a good answer to things like "how can I write a fast memoiser using state under the hood?" or whatever.
14:30:56 <arkeet> @undo do { args <- getArgs ; case args of ... }
14:30:56 <elliott> or "I really, really, really need a global mutable variable"
14:30:56 <lambdabot> <unknown>.hs: 1: 37:Parse error: ...
14:31:03 <chrisdotcode_> Peaker: what's the right^H^H^H^H^H preferred way to use getArgs to get the contents of the first file? because I think I'm just shooting in the dark at this point
14:31:07 <merijn> elliott: See my second sentence
14:31:12 <hodapp> elliott: ...does Haskell even allow that?
14:31:13 <arkeet> @undo do { args <- getArgs ; "..." }
14:31:13 <lambdabot> getArgs >>= \ args -> "..."
14:31:13 <elliott> merijn: well, people don't always know that
14:31:17 <Peaker> chrisdotcode_, getArgs returns a list of arguments, not files
14:31:23 <elliott> merijn: but I agree that it's very inappropriate to use it in response to "m a -> a" type questions
14:31:32 <elliott> hodapp: yep
14:31:33 <joelteon> :t (>>=) . const
14:31:34 <lambdabot> a -> (a -> b1 -> b) -> b1 -> b
14:31:41 <elliott> hodapp: well, it's not in the standard
14:31:43 <elliott> but GHC lets you do it
14:31:45 <eikke> elliott: for some reason then, in type instance decls, I get "Expected kind `*', but '[One, Two] has kind `[T]'
14:31:47 <chrisdotcode_> Peaker: the first argument is gonna be a file
14:31:56 <elliott> eikke: you need the 's in the instance decls
14:31:57 <merijn> elliott: unafePerformIO is in Haskell2010, isn't it?
14:31:58 <elliott> or something
14:32:01 <elliott> aaargh :)
14:32:07 <Hafydd> merijn: if I didn't know about unsafePerformIO, I wouldn't want people to keep it secret from me.
14:32:07 <monochrom> what if there is no first argument?
14:32:08 <merijn> Which would make global mutable MVar's standard too
14:32:15 <Peaker> chrisdotcode_, well, you probably want to handle the case of a missing arg. or having more than one arg.. best to pattern match on the args list
14:32:16 <elliott> merijn: no actually, it's in the FFI addendum to 98, 2010 just has "unsafeLocalState" which is a weird super-restricted version
14:32:21 <byorgey> eikke: did you paste your code somewhere?
14:32:22 <elliott> (this surprised me)
14:32:27 <eikke> byorgey: I will
14:32:30 <Peaker> chrisdotcode_, getArgs >>= \args -> case args of ...
14:32:30 <elliott> merijn: MVars aren't standard either!
14:32:33 <elliott> in fact, IIRC IORefs aren't even
14:32:37 <josephle> merijn: somebody solve the open problem of benevolent effects already! That'll allow us to write safePerformIO, right?
14:32:44 <joelteon> chrisdotcode_: or getArgs >>= \case ...
14:32:53 <chrisdotcode_> Peaker: for the sake of my learning, I'm assuming that it's a closed system where one and only arg, with the exact same name is passed in each time.
14:32:56 <byorgey> eikke: ' is neither needed nor allowed in the syntax of kinds
14:32:59 <josephle> s/benevolent/benign/
14:33:00 * elliott did a safePerformIO type formalisation in coq once
14:33:03 <elliott> it was cute.
14:33:07 <josephle> hehe
14:33:07 <Peaker> josephle, a library that hides all the benign effects you need is basically that?
14:33:12 <elliott> of course, the proofs kind of amounted to giving the pure definition.
14:33:22 <arkeet> safePerformIO :: IO a -> IO a
14:33:26 <arkeet> ??
14:33:30 <Hafydd> Hahah.
14:33:33 <joelteon> safePerformIO :: a -> a
14:33:40 <Peaker> chrisdotcode_, then you can use "head" (while knowing that using head in that way is terrible practice in general)
14:33:42 <elliott> arkeet: safePerformIO :: (m :: IO a) -> Safe m -> a
14:33:53 <arkeet> I don't know what Safe is.
14:33:55 <josephle> arkeet: there's an open problem where *some* IO effects are known to be safe. The question is whether or not you can make a formalism that separates those from the unsafe ones.
14:33:59 <eikke> byorgey, elliott: http://hpaste.org/89904
14:34:00 <arkeet> I see.
14:34:05 <elliott> arkeet: well, I narrowed down the problem to ST.
14:34:14 <elliott> or someting close to ST
14:34:29 <josephle> but there are some stuff that are slightly beyond the scope of ST that could be considered benign
14:34:36 <elliott> arkeet: it was safePerformST :: (m :: ST s a) -> Safe m -> a; Safe m = forall (h1 h2 : Heap s). run m h1 = run m h2, or such.
14:34:38 <josephle> I used to have notes on this...where did I put them?
14:34:42 <Hafydd> @let safePerformIO = id
14:34:43 <lambdabot>  Defined.
14:34:53 <elliott> arkeet: I managed to prove that a memoiser was pure, anyway.
14:35:10 <chrisdotcode_> Peaker: duly noted :)
14:35:13 <elliott> of course if you actually run it it would just use the unmemoised version, but you could tell Coq to extract it as unsafe mutable state instead
14:35:21 <chrisdotcode_> and main :: IO ()
14:35:21 <chrisdotcode_> main = fileName = getArgs >>= head
14:35:21 <chrisdotcode_> gives me a parse error...
14:35:40 <eikke> chrisdotcode_: that's wrong
14:35:44 <Peaker> chrisdotcode_, put "fileName = ..." on its own definition
14:35:52 <Peaker> chrisdotcode_, or use "let" to make a local main definition
14:35:55 <Peaker> chrisdotcode_, or "where"
14:36:00 <merijn> Peaker: That's still wrong
14:36:04 <chrisdone> Peaker: i made a simple screen recording of my structured-haskell-mode minor mode
14:36:07 <geekosaur> but that would be wrong still
14:36:08 <Peaker> chrisdotcode_, and "main" is going to need to have its own body too
14:36:09 <eikke> chrisdotcode_: main = getArgs >>= \args -> return (head args) >>= \filename -> ...
14:36:12 <merijn> head is not a monadic function
14:36:18 <geekosaur> I do not understand what that is supposed to be
14:36:21 <elliott> chrisdotcode_: use do notation.
14:36:28 <Peaker> chrisdone, if it's generally better than haskell-mode, I'd love to use it
14:36:30 <chrisdone> use the donads, luke
14:36:30 <chrisdotcode_> elliott: I'm trying to understand it without do notation
14:36:42 <Peaker> chrisdotcode_, you reverted to >>=
14:36:45 <byorgey> eikke: you need ' in front of all the [  in the instances on lines 7 and 8
14:36:47 <elliott> ok. then almost what eikke said, except it's overcomplicated
14:36:53 <Peaker> chrisdotcode_, is head an effectful function?
14:36:56 <elliott> main = getArgs >>= \args -> ... (head args) ...
14:37:05 <elliott> where ... (head args) ... is the rest of your program
14:37:06 <chrisdotcode_> elliott: yeah, after seeing what eikke wrote, it seems much easier with do.
14:37:22 <Clint> does ryan ingram come here?
14:37:22 <Peaker> chrisdotcode_, you started with >>=  fixed it to <$> and then came back to >>= ?
14:37:24 <elliott> I meant eikke's version was overcomplicated (return x >>= ... can always be reduced)
14:37:28 <elliott> but yeah, you should just be using do...
14:37:30 <eikke> byorgey: I tried that, gives parser errors on all of them
14:37:44 <nooodl> if you're absolutely sure you'll pass one arg to it, and you're gonna call "head" on it anyway, you might as well write: main = getArgs >>= \[filename] -> ...
14:37:45 <byorgey> eikke: there has to be a space, like '[ '[
14:37:53 <eikke> byorgey: oh, that might explain
14:37:56 <byorgey> eikke: if you have '['[  it thinks '[' is a char literal
14:37:59 <chrisdotcode_> Peaker: obviously I'm very confused xD
14:38:00 <byorgey> or something
14:38:01 <elliott> merijn: hey you use hdevtools. I used to. but I gave up because it squashed all errors to one line. any solution?
14:38:28 <Peaker> chrisdotcode_, just think what the types of your function and argument are, and use the appropriate operator from my paste
14:38:49 <byorgey> eikke: I now get a type error on 'finished', but that type indeed looks wrong to me
14:38:56 <chrisdotcode_> Peaker: Ironically, I know how to use monads, but not quite <$>.
14:38:56 <eikke> byorgey: yeah
14:39:12 <elliott> chrisdotcode_: f <$> m = do { x <- m; return (f x) }
14:39:14 <byorgey> you need State s -> Proxy (a :: Task) -> ...  or something like that
14:39:16 <elliott> for the purposes of a monad
14:39:31 <byorgey> or in general something which has the Task as a type parameter
14:39:33 <luqui> For those of you who help beginners a lot, what are some of the most common performance problems beginners often run into?
14:39:43 <Peaker> chrisdotcode_, well, you're trying to use monads incorrectly (>>= into a pure function)
14:39:43 <josephle> hmm, are splay trees implementable just in the ST monad?
14:39:47 <eikke> byorgey: luckily this is just me messing around, no 'real' code
14:39:52 <byorgey> eikke: sure =)
14:39:52 * josephle goes off to finds splay tree implementations
14:39:58 <chrisdotcode_> elliott: now I get it :)
14:40:15 <elliott> chrisdotcode_: you can think of it as "lifting" a pure function to operate on the results of a monadic action.
14:40:16 <chrisdotcode_> Peaker: yeah, I was struggling with that, but now I think I got it, thanks to you guys.
14:40:37 <Peaker> josephle, ephemeral splay trees?
14:40:37 <elliott> chrisdotcode_: whereas (>>=) (closer to (<$>) if you consider the flipped form, (=<<)) "lifts" a monadic function to operate on the results
14:40:39 <merijn> elliott: The "errors" window shows multiline errors, though still very small
14:40:48 <merijn> elliott: I mostly use it for the highlighting of errors
14:40:57 <chrisdotcode_> elliott: for some reason, the name "lift" makes more sense to me than "pure"
14:41:06 <josephle> Peaker: yes, not the splay heaps of PFDS.
14:41:12 <jmcarthur_mobile> luqui: list indexing, non-strict tail recursion, and strict non-tail recursion
14:41:41 <luqui> ah, strict non-tail, hadn't thought about that one
14:41:42 <Peaker> josephle, then ST will let you have a local/hidden splay tree.. otherwise you need it persistent/copied
14:42:24 <Peaker> luqui, hey, someone wants to run lamdu (which uses drawingcombinators) with SDL instead of OpenGL.. I'm wondering about doing a port
14:42:32 <chrisdone> Peaker: here's the latest functionality: http://chrisdone.com/structured-haskell-mode.ogv still not ready for prime time, a bit flaky atm
14:42:38 <Peaker> luqui, and I see your commit history has an SDL past
14:42:57 <josephle> Peaker: so no global immutable splay trees without unsafePerformIO?
14:43:13 <jmcarthur_mobile> Wait, you mean using SDL drawing primitives?
14:43:18 <josephle> erm ephemeral
14:43:22 <Peaker> josephle, global immutable implies they're persistent, basically?
14:43:37 <josephle> Peaker, sorry global *ephemeral* splay trees
14:43:38 <Peaker> josephle, or just have them in IO?
14:43:48 <Peaker> jmcarthur_mobile, yeah
14:43:53 <josephle> well, of course we can keep them in IO
14:44:12 <josephle> separation of Church and State
14:44:15 <luqui> Peaker: you mean instead of GLUT?
14:44:18 <jmcarthur_mobile> Is there some reason they care what drawingcombinators uses under the hood?
14:44:25 <Peaker> luqui, instead of GL entirely
14:44:35 <Peaker> luqui, I think I've replaced GLUT with GLFW in the example already
14:44:51 <Peaker> (though it's still there for lame fonts)
14:45:12 <luqui> Okay.  I have mostly used SDL as a windowing layer for opengl, not done much with it directly (though I did write one game that way, not in haskell though)
14:45:16 <Peaker> jmcarthur_mobile, it's shachaf and his opengl doesn't work
14:45:27 <Peaker> jmcarthur_mobile, I know of another dude who has no working opengl
14:45:58 <luqui> I have been thinking about doing a 2.0 release that restructures the interface to make it easier to port
14:46:03 <Peaker> luqui, also, did you run lamdu? :) I think you might like this use of drawingcombinators
14:46:05 <jmcarthur_mobile> Peaker: due to the bindings or due to driver issues?
14:46:13 <Peaker> jmcarthur_mobile, driver
14:46:16 <jmcarthur_mobile> Ah
14:46:25 <luqui> Peaker: I tried.  It didn't work...
14:46:33 <Peaker> luqui, recently?
14:46:40 <luqui> like, three days ago
14:46:46 <Peaker> luqui, really? what happened?
14:46:55 <luqui> It gave me a mostly blank screen, a few items on it
14:47:01 <luqui> no keyboard anything did anything
14:47:07 <luqui> I quit, and restart, and it was different
14:47:15 <luqui> which makes me think it did do something, but it didn't update the screen
14:47:52 <Andrea_> putStrLn "\ESC[31mhello\ESC[30m, friends"
14:47:54 <chrisdone> dmwit: ah, might be of interest to you too: http://chrisdone.com/structured-haskell-mode.ogv
14:48:00 <jmcarthur_mobile> I have been working on a g-dc-like library lately. It's not ready for general consumption yet, but it is working. Unfortunately it is not suitable for this purpose because it relies heavily on OpenGL too.
14:48:01 <Peaker> luqui, weird :(
14:48:26 <Peaker> luqui, I'd love to help debug that if you want to as well
14:48:33 <luqui> sure.
14:48:37 <luqui> I'm totally interested in the project
14:48:47 <luqui> should we do it on PM?
14:48:55 <Peaker> luqui, #haskell-overflow ?
14:49:38 <jmcarthur_mobile> I want to follow alonh
14:49:43 <jmcarthur_mobile> Haskell-game
14:50:02 <jmcarthur_mobile> Err, I mean #haskell-game
14:52:15 <Andrea_> the last days I wrote my first haskell program
14:52:16 <shergill> roconnor: are you the maintainer for the coq package on nix?
14:52:20 <kayloos> I've made a small template parser for my own template language (91 loc), which i'd love to get some general input on, https://gist.github.com/kayloos/5777652
14:54:51 <johnw> thoughtpolice: hi
14:55:13 <merijn> Peaker: Since you're using OpenGL for a UI, is the experience better than using any of the GUI frameworks? If so, which libraries do I start to look at to start making GUIs the same way?
14:55:15 <johnw> @tell thoughtpolice I have my Mac ghc dailies up at ghc.newartisans.com
14:55:15 <lambdabot> Consider it noted.
14:55:57 <Peaker> merijn, I think it's much nicer than the standard Gtk/Qt stuff
14:56:19 <Peaker> merijn, the code is all in there, but it's not comprehensive.. no clipboard support, various bits are missing for general purpose use
14:56:33 <Peaker> merijn, but it's not hard to add functionality to widgets
14:57:02 <merijn> Peaker: "in there" being?
14:57:25 <chrisdone> merijn: i suppose xclip is a trivial way to get copy/paste to and from the ide
14:57:29 <chrisdone> err, i meant peaker
14:57:33 <chrisdone> hey cmccann
14:57:39 <merijn> kayloos: At quick superficial glance it looks decent enough
14:57:49 <cmccann> chrisdone: yo
14:58:00 <merijn> kayloos: Personally I prefer keeping the "do" on the same line as the =, though
14:58:01 <chrisdone> how goes it :: You?
14:58:35 <cmccann> chrisdone: I've been busy with non-Haskell stuff lately, alas
14:58:39 <cmccann> hac phi was p cool though
14:58:40 <Peaker> merijn, in the lamdu repo
14:58:46 <jmcarthur_mobile> :/
14:58:50 <Peaker> merijn, bottlelib/Graphics/UI/Bottle/Widgets
14:59:05 <jmcarthur_mobile> I wish I could have gone to Hac phi
14:59:12 <jmcarthur_mobile> Maybe next uear
14:59:15 <jmcarthur_mobile> Year
14:59:19 <chrisdone> cmccann: no haskell at work?
14:59:20 <cmccann> chrisdone: you should go to hac phi next time, clearly that's not at all inconvenient for you
14:59:22 <Peaker> chrisdone, hooking up clipboard is probably not that hard.. just not a priority
14:59:27 <kayloos> merijn: thanks, i like to have the `do' in the next line, since then i have more horizontal space for code.. but then again maybe thats a bad thing
14:59:30 <Peaker> chrisdone, how do I get your emacs code? :)
14:59:32 <jmcarthur_mobile> I shouldn't IRC on my phone.
14:59:46 <cmccann> jmcarthur_mobile: hopefully! I'll be there next year if at all possible
14:59:49 <merijn> kayloos: i.e. this way https://gist.github.com/merijn/5777756
15:00:00 <cmccann> chrisdone: no, my day job is C#
15:00:02 <chrisdone> Peaker: have to wait =p
15:00:03 <merijn> kayloos: Ah, but you don't have to indent to match the do :)
15:00:28 <merijn> kayloos: The indent level is decided by the first non-whitespace that follows do, which may be on the next line
15:00:30 <chrisdone> cmccann: ah ok. oh well. c#'s not the worst you could be stuck with i guess
15:00:41 <cmccann> it's surprisingly tolerable for a mainstream language
15:00:47 <Peaker> chrisdone, bummer
15:00:54 <kayloos> merijn: Wow, I didn't know that :)
15:01:00 <kayloos> mind blown
15:01:02 <merijn> kayloos: (as my example shows) For a more in-depth exact explanation of haskell indenting: http://en.wikibooks.org/wiki/Haskell/Indentation
15:01:20 <chrisdone> Peaker: i was careful not to do anything in the screenshot that didn't break. johnw's tried it, he'll tell ya, it's unusable =p
15:01:37 <dmwit> chrisdone: peaking
15:01:38 <chrisdone> cmccann: yeah, my experience too
15:01:49 <johnw> what did I try?
15:03:45 <merijn> kayloos: My auto-indent readme also has a list of rather common layout styles: https://github.com/merijn/haskellFoldIndent#automatic-block-indent
15:04:07 <chrisdone> johnw: my structured-haskell-mode =)
15:04:21 <elliott> cmccann: no, your day job is not doing shachaf's work.
15:04:25 <dmwit> chrisdone: Here's something I want to see: swap the arguments to a plus (or other infix operator). =P
15:05:12 <dmwit> chrisdone: (In general it looks very impressive, though!)
15:05:27 <cmccann> elliott: shachaf's work doesn't involve C#, therefore programming in C# is an excellent way to not do it.
15:05:32 <kayloos> merijn: Thanks for the sources, they will be going in to my haskell bookmarks folder
15:06:10 <merijn> Peaker: Ha, I didn't realise lamdu installed all the stuff as separate library too :)
15:06:45 <merijn> Although I guess that means I have to reverse engineer how to use things :p
15:06:57 <Peaker> merijn, I can help with that..
15:07:03 <Peaker> merijn, read View.hs/Widget.hs first
15:12:36 <merijn> Peaker: Well, there's not much too read :p
15:13:31 <Peaker> merijn, Widget f = ... is important to understand
15:13:52 <Peaker> merijn, Animation Frame is a mapping of identities to rect-positions and Draw.Images
15:14:09 <Peaker> merijn, Widget makes a "dest frame" and the main loop interpolates a current frame to dest frame
15:14:37 <merijn> Peaker: Yeah, the Widget looks fairly reminiscent of the Widgets in vty
15:14:52 <Peaker> merijn, widget also has an "enter" handler for cursor entry and an event map for input handling
15:15:16 <Peaker> it's agnostic about what kind of handling that is.. except whatever handling you have, you must also output a new potential cursor and animation id mappings
15:16:42 <merijn> Peaker: Right, so it's a rather stateful approach where you mutate the state associated with various id's?
15:17:21 <chrisdone> dmwit: yeah infix stuff works. but you have to be careful not to have incomplete expressions. if/case/lambda are easier to avoid with snippets, but infix ops are hard to restrict without annoying the user
15:17:52 <dmj> @src tell
15:17:52 <lambdabot> Source not found. The more you drive -- the dumber you get.
15:18:28 <merijn> Is there a way to search the logs if you don't remember the relevant date?
15:18:30 <Peaker> merijn, well, the Widget is pure
15:18:41 <Peaker> merijn, but its outputs may be actions or pure, as you use it
15:19:13 <Peaker> note that Widgets/* are all pure. Only the user code in lamdu maps over them to make Transaction monad actions
15:19:37 <dmwit> dmj: The source varies by MonadWriter instance.
15:19:41 <acowley> I think I wish </> bound super tightly so I could use it more pervasively without also needing to worry about parentheses
15:19:50 <acowley> But I'm probably not thinking that through
15:19:55 <chrisdone> dmwit: some infix messing: http://chrisdone.com/structured-haskell-mode-infix.ogv
15:19:56 <merijn> Peaker: Yeah, I meant stateful as opposed to say the FRP approach
15:21:05 <merijn> How can I search the #haskell logs quickly? Anyone?
15:21:25 <dmj> http://ircbrowse.net/browse/haskell
15:21:31 <dmj> merijin: ^
15:21:36 <dmj> merijn: ^
15:22:17 <Peaker> merijn, yes, we went for an easier approach.. it worked well so far
15:22:56 <dmwit> Pretty impressive. Much less restrictive than most structured editors I've seen. But you still didn't swap two arguments to an infix operator. :3
15:23:10 <dmwit> merijn: grep ;-)
15:23:21 <chrisdone> dmwit: can you give an example? not quite sure the case you're describing
15:23:26 <dmwit> (What, not everybody has five years of logs sitting on their disk?)
15:23:28 <merijn> dmwit: That means I'd have to download everything first
15:23:33 <dmwit> chrisdone: "3 + 4" -> "4 + 3"
15:23:45 <chrisdone> oh that's genuinely trivial
15:23:53 <chrisdone> i don't have a command to do it, but that's very easy
15:23:56 <dmwit> I know. But no editor now does it, and it's so annoying!
15:24:00 <chrisdone> ah, hehe
15:25:18 <elliott> dmwit: you can download #haskell logs quite easily, in fact
15:25:21 <elliott> there's a .zip of all the ones up to 2013
15:25:39 <dmwit> I make my own logs, thank you very much.
15:25:47 <elliott> that was re "not everybody" :)
15:26:07 <dmwit> ah =)
15:26:23 <johnw> I hand-craft my artisinal logs
15:26:26 <chrisdone> tunes sometimes just cutts off random logs
15:26:44 <elliott> I get my logs directly from the trees.
15:27:34 <johnw> all my logs descend from yggdrisil.com
15:27:37 <chrisdone> on the 23rd of may half the day is missing. that's why ircbrowse doesn't have the logs. i might make ircbrowse join #haskell to get them live somewhen, but i'm not in a rush
15:27:50 <chrisdone> johnw: is that an icelandic name?
15:27:54 <dmj> dmwit: So is MonadWriter just a wrapper around Writer for convenience functions like tell, listen and pass?
15:27:59 <johnw> it's the name of the World Tree
15:28:06 <johnw> i don't know which mythology it comes from, actually
15:28:08 <dmj> dmwit: Couldn't those have been written standalone?
15:28:12 <dmwit> dmj: no wrapper; it's a class
15:28:26 <chrisdone> johnw: nordic, ironically. i was close!
15:28:48 <dmwit> MonadWrapper is an interface that Writer and WriterT both implement; if you're into the Java style of jargon.
15:29:29 <elliott> MonadWrapper???
15:29:33 <dmwit> um
15:29:37 <dmwit> s/MonadWrapper/MonadWriter/
15:29:43 <elliott> phew
15:29:54 <Peaker> Writer is just a type synonym these days isn't it?
15:29:56 <dmwit> I mean, who would wrap a burrito??
15:29:58 <chrisdone> wrapper usually implies a more sane interface to a complex or annoying thing to use
15:30:17 <chrisdone> but i wouldn't put it past java folk to use it like that =p
15:30:36 <johnw> every tutorial is an instance of MonadBurrito
15:31:02 <chrisdone> every haskell tutorial reader is an instance of ComonadSauce?
15:32:02 <dmj> dmwit: So MonadWriter is used for to make it easier to create Lazy, Strict transformer instances, along with the non-transformer version.
15:32:09 <johnw> dmj: in general, you should use the most abstract types that you can
15:32:27 <johnw> so if the *only* monadic thing that your function is doing is 'tell', then make its type: MonadWriter m => m (), for example
15:32:41 <dmwit> dmj: I think you're misunderstanding something about classes.
15:32:46 <dmwit> The class isn't magic.
15:32:49 <johnw> that way, by looking at the type I know that there is really only one effectful thing your function could possibly be doing
15:32:59 <dmwit> Its existence doesn't make code for the various transformers appear out of thin air.
15:33:04 <chrisdone> or make it Foo where Foo is an instance of MonadWriter that you can change what's inside later
15:33:12 <roconnor> shergill: I probably am, though your question is more appropriate for the #nixos channel
15:33:21 <dmwit> Everything you could do with the class, you could do without; you just couldn't give all those functions you wrote the same name.
15:34:25 <dmwit> That is to say: no, MonadWriter does not make it easier to create monad transformers. You're still writing all the same code. It's just that users of your code get a single function name that works at many different types, because you wrote implementations at each of those types.
15:35:19 <dmj> dmwit: Yes, I see the transformer instances, but before I get to those I want to write newtype Writer w a = Writer { runWriter :: (a,w) } with listen, tell, ask from scratch. But I see that I need to make Writer an instance of MonadWriter first in doing so.
15:35:44 <johnw> why do you need to?
15:35:47 <merijn> dmj: No, you don't need to do that at all
15:36:46 <dmj> I see, I guess I want to stay as close to the original implementation as possible.
15:36:48 <dmj> http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/src/Control-Monad-Writer-Lazy.html#Writer
15:37:07 <dmj> merijn: the above code implements Writer as MonadWriter instance.
15:38:44 <merijn> dmj: No, it implements a MonadWriter instance for Writer
15:40:14 <monochrom> I think the distinction is subtle.
15:40:18 * hackagebot nitro 0.2.0.0 - Haskell bindings for Nitro  http://hackage.haskell.org/package/nitro-0.2.0.0 (ErinDahlgren)
15:40:44 <monochrom> but when you write "newtype Writer w a = Writer { runWriter :: (a,w) }", that already implements Writer.
15:41:20 <merijn> ugh
15:41:37 <merijn> Nothing so sad as running some example code and it crashing and burning horribly :\
15:44:51 <monochrom> "instance MonadWriter Writer ..." is "add one more MonadWriter instance" rather than "implement Writer"
15:47:29 <acowley> What's a shorter way to say, fmap ((sequence_ .) . sequence) . sequence
15:47:46 <dmwit> wow, that's...
15:47:46 <dibblego> acowley: use TypeCompose, also traverse
15:47:54 <acowley> I ended up there chasing types
15:47:54 <dmwit> :t fmap ((sequence_ .) . sequence) . sequence
15:47:55 <lambdabot> (Monad m, Monad f, Functor f) => [f (a -> m a1)] -> f (a -> m ())
15:48:01 <copumpkin> o.O
15:48:09 <acowley> It's neat, right?
15:48:51 <acowley> dibblego: I could use traverse, but I didn't think it would actually simplify the expression
15:49:39 <dibblego> acowley: any time you write: fmap . sequence
15:50:00 <dmwit> :t mapM ((sequence_ .) . sequence)
15:50:00 <lambdabot> Monad m => [[a -> m a1]] -> a -> [m ()]
15:50:33 <dmwit> hum
15:50:37 <acowley> dmwit: It took me a few tries to end up at the implementation I pasted
15:50:39 <dmwit> :t traverse
15:50:40 <lambdabot>     Not in scope: `traverse'
15:50:40 <lambdabot>     Perhaps you meant one of these:
15:50:40 <lambdabot>       `T.traverse' (imported from Data.Traversable),
15:50:44 <dmwit> :t T.traverse
15:50:44 <lambdabot> (Applicative f, T.Traversable t) => (a -> f b) -> t a -> f (t b)
15:51:06 <dmwit> That doesn't really look helpful.
15:51:36 <dmwit> :t T.sequenceA
15:51:37 <lambdabot> (Applicative f, T.Traversable t) => t (f a) -> f (t a)
15:52:49 <dibblego> sorry you're right, I had my head backwards
15:52:55 <dibblego> sequence . fmap f
15:53:06 <dmwit> ?src mapM
15:53:06 <lambdabot> mapM f as = sequence (map f as)
15:54:58 <dmwit> ([] `O` f `O` (a ->) `O` m) a -> (f `O` (a ->) `O` m `O` []) a
15:55:20 <dmwit> that looks a bit like sequenceA
15:56:48 <Hrumph> hi
15:56:48 <Hrumph> sup?
15:57:01 <Peaker> sequenceA :: [(f :. (r ->) :. m) a] -> (f :. (r ->) :. m) [a]
15:57:01 <Hrumph> how come ErrorT isn't defined for Text?
15:57:13 <dmwit> Peaker: right
15:57:22 <Peaker> but (r ->) isn't traversable
15:57:33 <Hrumph> i mean we have an instance for String but not Text. why is this?
15:57:39 <dmwit> Peaker: Only [] has to be traversable, right?
15:57:41 <dmwit> which it is
15:57:47 <Peaker> oh right
15:58:16 <dmwit> Hrumph: I doubt there's a deep reason.
15:58:20 <dmwit> So implement it if you need it.
15:59:17 <Hrumph> i guess i could implement it. i'll just stick with string and pack and unpack for now
15:59:35 <Hrumph> i was wondering why it wasn't there already when everyone says "use Text for everything"
16:02:06 <dmwit> acowley: Okay, I believe you can write your function as "sequenceA_" + some newtype nonsense.
16:02:26 <dmwit> No idea if it has the right behavior. But it has the right type. =P
16:02:41 <acowley> Hrumph: That's rule #1. Rule #2 is to choose your battles.
16:03:12 <acowley> dmwit: Yeah, I think it's just a sequenceA of a composite thing.
16:03:40 <dmwit> unO . unO . sequenceA_ . O . O
16:03:44 <dmwit> very clean
16:03:53 <acowley> Hahaha
16:03:53 <Adeon> O.O
16:03:57 <acowley> that is spectacular!
16:04:08 <elliott> dmwit: over (_O._O) sequenceA_
16:04:09 <shachaf> under (_O._O) sequenceA_
16:04:10 <acowley> I can't help but read that code outloud
16:04:12 <elliott> oh under
16:04:19 <merijn> Anyone here ever use SDL on OSX?
16:05:15 <dmwit> uh
16:05:17 <dmwit> hm
16:05:28 <geekosaur> no. have built it, beware of an unfortunate behavior if you are missing any SDL C libraries when you try to build various SDL libraries (it will claim your compiler is broken when what it means is it can't find -lSDL-image or whatever)
16:05:38 <dmwit> I guess I meant unO . unO . sequenceA_ . map (O . O)
16:05:53 <shachaf> help
16:05:58 <elliott> this function sounds disgusting.
16:06:17 <merijn> geekosaur: I just managed to build an old example of mm_freak, but when I run the binary it just shows a blank window and consumes 90% CPU >.<
16:06:41 <Peaker> dmwit, unwrapped . unwrapped %~ sequenceA_
16:06:50 <merijn> And that's after tricking ghc into actually building things (by using a C main functions and calling to haskell from there...
16:06:56 <Peaker> (for the first, wrong code)
16:07:01 <geekosaur> hm. wouldn't know about that
16:07:25 <dmwit> In the spirit of lens: unsafeCoerce . sequenceA_ . unsafeCoerce
16:07:44 <Peaker> heh
16:07:50 <merijn> And of course mm_freak isn't here to help me with my incessant bugging >.<
16:08:32 <Peaker> GHC will give the new kind of ambiguous type error (complain about missing instance and buried in there say "ambiguous type t0.."
16:08:57 <merijn> I guess the alternative is to try using GLFW instead of SDL
16:09:16 <Peaker> merijn, GLFW-b
16:09:20 <merijn> Anyone have any better experiences with that? :p
16:09:46 * dmwit . o O ( class Newtype a b where safeCoerce :: a -> b )
16:10:00 <merijn> Peaker: What's the difference between GLFW-b and GLFW?
16:10:11 <shachaf> dmwit: newtype :: p a -> p b
16:10:27 <Peaker> merijn, former is newer, latter is old/unmaintained.. former packages the dependent C code insidei t
16:10:55 <acowley> merijn: I do lots with GLFW-b
16:11:29 <merijn> ah, right
16:11:37 <merijn> acowley: On OSX by any chance? :p
16:11:41 <acowley> merijn: Yep!
16:12:14 <merijn> acowley: Any problems? If no, then I'll just try rewriting this SDL example with GLFW and use that instead
16:13:06 <acowley> merijn: I'm sure I've suppressed a lot of painful memories, but it works great. I can develop with GHCi in emacs and reload code into a GLFW window.
16:13:29 <acowley> merijn: What do you need from the library?
16:14:16 <merijn> acowley: I was playing around with this netwire example: http://hpaste.org/83098
16:14:26 <merijn> acowley: But it uses SDL which breaks in all sorts of freakish ways
16:15:03 <merijn> GLFW seems to use callbacks, though :(
16:15:12 <acowley> merijn: I have code to make it okay
16:15:14 <merijn> Instead of giving you a "poll for input" function
16:15:29 <acowley> merijn: I'm actually preparing a new OpenGL helper library and example programs, but haven't written the text to go with the examples yet.
16:15:31 <merijn> Which means it most likely won't work with that netwire example anyway
16:15:40 <aoshi> does anyone know of a tutorial for using snap starting with simply serving  a static website?
16:15:53 <aoshi> https://github.com/J-Hannes/snap-tutorial this was nice but the author seems to have abandoned it a while ago
16:16:39 <acowley> merijn: I'm more disconcerted by the use of old-school OpenGL. Would you be okay with switching to OpenGL > 3?
16:17:12 <merijn> acowley: In that code, you mean?
16:17:18 <acowley> merijn: Yeah
16:17:33 <merijn> I was actually planning to strip out the OpenGL code once I had it running
16:17:35 <acowley> Does anyone have a good strategy for attaching example code to a package?
16:17:47 <merijn> acowley: Stuff it in the Haddock?
16:18:10 <acowley> merijn: I think running the code is cool, though
16:18:12 <merijn> Or just have an examples directory?
16:18:19 <acowley> merijn: The examples have their own dependencies
16:18:34 <acowley> so I'd need to guard those dependencies with a flag in the cabal file of the package, or just have a README
16:18:38 <merijn> examples dir + cabal file in there
16:18:45 <acowley> Good point.
16:19:32 <merijn> acowley: The biggest issue I have right now is just that the SDL stuff doesn't work, and I have no clue where to start fixing it which means that changing or fixing the OpenGL code in there is out of the question
16:19:52 <acowley> merijn: I'm moving my code around so I can link you a repo in a couple minutes
16:20:11 <merijn> I guess I could set up GLFW callbacks that dump values in a Chan and the block the appLoop on reading from that channel...
16:21:07 <merijn> acowley: btw, is switching to OpenGL >3 even an option, without having to install a ton of stuff, I though OSX still shipped with 2.something?
16:21:18 <acowley> merijn: How recent is your computer?
16:21:50 <acowley> Mine's a MBP from 2010 which is fine with 3.2, but an older one from 2006 won't work.
16:23:11 <merijn> Closer to 2010 than 2006, probably
16:35:20 * hackagebot accelerate 0.13.0.5 - An embedded language for accelerated array processing  http://hackage.haskell.org/package/accelerate-0.13.0.5 (TrevorMcDonell)
16:35:50 <merijn> acowley: It's bed time for me, just @tell me the link when you get around to it :)
16:36:02 <acowley> merijn: Darn! Okay, I'm almost there
16:36:35 <Aetherspawn> @where mtl
16:36:36 <lambdabot> http://www.haskell.org/haskellwiki/Monad_Transformer_Library
16:36:53 <Aetherspawn> There we go! No longer points to the c++ matrix transformer library :P
16:37:08 <shachaf> ?
16:37:23 <Aetherspawn> A few days ago @where mtl pointed to a random C++ library
16:40:20 * hackagebot accelerate-cuda 0.13.0.3 - Accelerate backend for NVIDIA GPUs  http://hackage.haskell.org/package/accelerate-cuda-0.13.0.3 (TrevorMcDonell)
16:40:22 * hackagebot GLUtil 0.6.2 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.6.2 (AnthonyCowley)
16:40:25 * hackagebot accelerate-io 0.13.0.2 - Read and write Accelerate arrays in various formats  http://hackage.haskell.org/package/accelerate-io-0.13.0.2 (TrevorMcDonell)
16:43:51 <acowley> Anyone feel like testing some OpenGL things? I should probably verify that this code works on more than one computer.
16:44:19 <Aetherspawn> If I put a TChan in a reader
16:44:25 <Aetherspawn> will it still work like it's supposed to?
16:44:36 <Aetherspawn> (or does it need to be in a State?)
16:45:17 <luqui> in a ReaderT will be fine
16:45:29 <luqui> the TChan itself does not change
16:45:40 <luqui> it is only accessed (even when you write to it)
16:45:55 <Aetherspawn> cool, thanks :)
16:46:41 <luqui> unfortunately, atomically :: STM a -> IO a… not ReaderT r STM a -> ReaderT r IO a
16:46:57 <luqui> so you'll have to 'ask' for the chan before you do lift . atomically $ ...
16:47:21 <luqui> either that or write an adapter for atomically that does that for reader
16:50:40 <jmcarthur_mobile> acowley: I'm down for that, if you don't ming waiting for me to do it at my leisure
16:50:52 <jmcarthur_mobile> *mind
16:51:02 <Peaker> @type mapReaderT
16:51:03 <lambdabot> (m a -> n b) -> ReaderT r m a -> ReaderT r n b
16:51:08 <Peaker> luqui, ^^
16:51:25 <luqui> ooh how nice.
16:51:37 <acowley> jmcarthur_mobile: Okay, the repository is at https://github.com/acowley/vinyl-gl  You would need to install that library, and then you can "cabal build" in the examples directory.
16:52:13 <acowley> I ming mercilessly
16:52:45 <acowley> That may be too old a reference.
16:53:35 <Aetherspawn> is there an easy way to replace a ton of stuff in a record with IO stuff by name
16:53:46 <Aetherspawn> like, can I do record { x <- a } or something?
16:54:04 <acowley> You are on the path to lens
16:54:41 <acowley> The record update syntax isn't first-class, as it were, so doesn't lend itself to abstractions.
16:55:08 <Aetherspawn> which lens function inparticular (if you can remember?)
16:55:21 <luqui> heheh if only it were so simple
16:55:21 <dibblego> Aetherspawn: Control.Lens see lens on hackage
16:55:22 <jmcarthur_mobile> I wish we had the ability to define mutable record fields without having to use IORefs
16:55:25 <dibblego> @hackage lens
16:55:25 <lambdabot> http://hackage.haskell.org/package/lens
16:55:58 <Aetherspawn> Didn't realize it was so huge.
16:56:14 <jmcarthur> it's a big toolkit
16:56:34 <luqui> It desperately needs a ensmallening
16:56:44 <luqui> but it's unclear where to draw the line
16:56:51 <luqui> because as you get more advanced using it, you want more of it
16:56:58 <elliott> it can't really be very ensmallened without strictly decreasing user experience
16:57:10 <elliott> I say we move it into base. :p
16:57:11 <acowley> Aetherspawn: Basically you'd do "_x <~ a" for your example
16:57:22 <acowley> Aetherspawn: assuming you used StateT
16:57:46 <Aetherspawn> I guess I should break into a StateT then
16:58:04 <acowley> Lens often leads to very compact code. The only price is your soul. So, there's that.
16:58:35 <Peaker> Lens is awesome. All my Haskell code looks so different now since lens exist. More DRY
16:58:55 <luqui> Aetherspawn: warning: lens is an advanced library.  You can use it without understanding it, but it is a long road to understanding
16:59:12 <acowley> Oh yeah, lens is not one of those libraries that you learn it inside and out before using it.
16:59:16 <Peaker> I like to view lens as a very cool generalization of SECs
16:59:18 <shachaf> You can say that about base too.
16:59:34 <shachaf> Peaker's perspective is the good one.
16:59:35 <acowley> shachaf: True, true.
16:59:39 <luqui> I don't know how experienced you are in haskell… but I'm going to recommend against it if "new" is an adjective that might describe you and Haskell
17:00:25 <lolcathost> luqui: why? because template haskell?
17:00:26 * elliott learned lens inside and out before using it!
17:00:34 <jmcarthur> acowley: alright, installing (but using a new sandbox, so it will take some time)
17:00:47 <elliott> in fact I mostly learned it by restructuring parts of it.
17:00:48 <acowley> jmcarthur: No rush!
17:00:52 <luqui> lolcathost: no, because of the way it does its thing...
17:01:21 <luqui> lolcathost: just look at the docs.
17:01:31 <Peaker> traversals may be hard for newbies.. the types are hard for everyone
17:02:05 <luqui> I guess I'm coming from the point of view that a firm understanding of types is an important skill to develop for newbies
17:02:20 <shachaf> It is an important skill for everyone.
17:02:21 <luqui> and lens encourages anybody who is not a genius not to worry about the types, because they'll "work out"
17:02:39 <luqui> the way they work is too advanced for a newbie
17:02:47 <acowley> That's actually quite a good point
17:02:48 <shachaf> luqui: I didn't understand lens before I understood its types.
17:03:20 <luqui> shachaf: so you think its types are approachable to a beginner?
17:03:29 <lolcathost> luqui: but when you read the lens laws, you think "oh, but it's really natural!"
17:03:39 <shachaf> I don't think learning lens would be a good thing for Aetherspawn to do right now.
17:03:52 <Aetherspawn> ;__; don't judge
17:04:08 <acowley> Perhaps not, but it's good to be aware of lens moving forward so you know there's hope for some things that may seem awkward to express now.
17:04:30 <luqui> judging is not at all what we're doing.  I'm just trying to guide you so you don't get lost in the lens sea
17:04:43 <acowley> It's very wet.
17:05:00 <luqui> really -- learning lens is a challenge for quite experienced Haskellers
17:05:03 <jmcarthur> types are, in my opinion, critical to using haskell effectively, and that applies doubly to lens
17:05:43 <elliott> I think lens is simpler than luqui makes it sound, but I agree with the sentiment
17:06:09 <luqui> elliott: yeah I guess I'm speaking on two different levels without making a distinction
17:06:20 <luqui> from the beginner perspective… 4 type parameters is too many
17:06:31 <elliott> it's really two type function parameters :(
17:07:20 <luqui> and from the experienced perspective, a deep understanding requires some study, you don't just look at the type signatures and get it.
17:07:31 <aoshi> writing in python well is to be pythonic, writing well in haskell is to be...?
17:07:44 <acowley> It's not just 4, it's the algebra required to see what happens when you smoosh together a bunch of combinators with that many type variables.
17:07:58 <shachaf> What algebra?
17:08:06 <jmcarthur> aoshi: i don't think there is a haskell-specific word for that
17:08:25 <luqui> I say haskelly
17:08:26 <dibblego> writing in haskell is to be yes haskell can do that
17:08:49 <dmwit> "idiomatic" is a language-agnostic term for "doing it right"
17:08:59 <shachaf> dmwit++
17:09:23 <elliott> dibblego: wat
17:09:35 <shachaf> (for focusing on language agnosticism)
17:09:40 <dibblego> @faq Can I use terrible grammar and get away with it?
17:09:41 <lambdabot> The answer is: Yes! Haskell can do that.
17:09:53 <blackdog> haskellian? i quite like "haskellite" for the monastic tone
17:10:29 <shachaf> dibblego: Don't you think the @faq thing is tired and overdone?
17:10:48 <shachaf> (The plan is to replace/eliminate it so I hope your answer is yes.)
17:10:53 <dibblego> yes, but I can do that
17:11:47 <dgpratt> I can cabal-dev install in a source directory, of course, easy peasy :) but...
17:11:54 <jmcarthur> i don't really associate "idiomatic" with, necessarily, "doing it right", actually
17:12:08 <jmcarthur> to me it's more like "doing it in the most commonly accepted way"
17:12:20 <dibblego> some people use idiomatic to mean popular — now they have problems
17:12:58 * dmwit sighs
17:13:00 <jmcarthur> @faq can haskell make a better faq?
17:13:01 <lambdabot> The answer is: Yes! Haskell can do that.
17:13:01 <dgpratt> what if I want to cabal-dev install a library from source and then use that in another source project?
17:13:07 <dgpratt> if that makes sense
17:13:22 <jmcarthur> dgpratt: cabal-dev project1/ project2/
17:13:32 <shachaf> kmc already made a better FAQ
17:13:35 <shachaf> @where faq
17:13:35 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
17:13:41 <jmcarthur> dgpratt: will create a cabal-dev dir in your current directory
17:13:46 <dgpratt> jmcarthur, thanks :)
17:13:47 <jmcarthur> dgpratt: you can keep adding packages to it that way
17:13:58 <Aetherspawn> <~ seems to unwrap my TChan
17:14:54 <elliott> dibblego: as a wise person once said: "sometimes i am confronted with a problem and i think "I know, I'll use Banach-Tarski""
17:15:20 <Aetherspawn> This looks a little wierd to me. is <~ supposed to do this?
17:15:21 <Aetherspawn> http://hpaste.org/89906
17:15:22 * hackagebot keyvaluehash 0.3.1.2 - Pure Haskell key/value store implementation  http://hackage.haskell.org/package/keyvaluehash-0.3.1.2 (EyalLotem)
17:15:23 <alpounet> dgpratt, also see cabal-dev add-source
17:15:24 <jmcarthur> acowley: http://hpaste.org/edit/89907
17:15:31 <monochrom> I'll use forkIO
17:15:33 <Aetherspawn> It's pulled the Broadcast type out of my TCHan
17:15:41 <dgpratt> alpounet, will do, thanks
17:16:04 <acowley> jmcarthur: Yeah, that's a silly error. I didn't mean for that cabal file to be used to install things.
17:16:27 <monochrom> Indeed I have just been playing C dlopen a haskell lib and the haskell lib does forkIO
17:16:28 <acowley> jmcarthur: I put a note to that effect in the description, but I should probably address the error in any case.
17:16:36 <jmcarthur> acowley: something unusual i'm doing is building via cabal-dev from outside the source dir. the source dir isn't my current working directory
17:16:44 <dmwit> Aetherspawn: I'm just going to go ahead and guess that this is a parenthesization issue without even reading the code carefully to check.
17:17:17 <acowley> jmcarthur: The executables expect to be run from their source dir, but building should be fine. The error is just in my data-files section.
17:17:50 <jmcarthur> ah
17:17:55 <Aetherspawn> (Oh, looks like <~ isn't high enough. I have to wrap the thing to the right of it in brackets)
17:18:05 <dmwit> called it
17:18:19 <jmcarthur> acowley: anything i should be on the lookout for when testing?
17:18:43 <jmcarthur> acowley: it doesn't fail catastrophically
17:19:09 <acowley> jmcarthur: My four favorite words!
17:19:20 <jmcarthur> acowley: there seem to be real shaders loaded doing real work
17:20:11 <acowley> jmcarthur: It's really just a smoke test to get the engine running. The stuff being exercised is the use of vinyl records to describe things like vertex data so that the GLSL binding is all automatic.
17:20:26 <jmcarthur> alright, seems good to me then
17:20:37 <jmcarthur> escape isn't exiting though :P
17:20:44 <acowley> jmcarthur: Thanks, what environment are you using to test?
17:20:49 <acowley> jmcarthur: Does the window have focus?
17:21:04 <jmcarthur> it did (i did ^C now)
17:21:46 <jmcarthur> acowley: Linux beast-linux 3.9.4-1-ARCH #1 SMP PREEMPT Sat May 25 16:14:55 CEST 2013 x86_64 GNU/Linux; OpenGL renderer string: GeForce GTX 560/PCIe/SSE2; OpenGL core profile version string: 4.3.0 NVIDIA 319.23
17:22:00 <acowley> Awesome, thanks!
17:22:07 <jmcarthur> The Glorious Glasgow Haskell Compilation System, version 7.6.3
17:22:12 <acowley> I'll have to test on linux to figure out that escape key thing.
17:22:24 <jmcarthur> it worked the second time
17:22:41 <jmcarthur> seems fine now
17:22:45 <acowley> The exiting code is a bit delicate as I have it set up so I can reload from ghci without things breaking
17:22:50 <jmcarthur> i had used it a bit the first time
17:22:55 <jmcarthur> ah
17:23:28 <solclum> close
17:23:39 <jmcarthur> but no cigar
17:24:00 <acowley> jmcarthur: I'd be interested in any feedback you have on the code, too, btw. I recall you've been doing some OpenGL work lately, so I'd like to know if this stuff would be helpful for you.
17:24:08 <rance35> xmonad
17:24:13 <jmcarthur> acowley: i'll take a look
17:24:19 <heatsink> There's over a kilouser in this channel.  I remember when it was regularly around 700.
17:24:22 <jmcarthur> acowley: i've been doing OpenGLRaw stuff, mostly
17:24:39 <acowley> jmcarthur: What made you go that way?
17:25:55 <jmcarthur> acowley: the "higher level" bindings don't seem to add much in terms of usability, to me; Raw makes it easier to use the GL spec as a reference; Raw supports more stuff
17:26:34 <acowley> Yeah, the applicability of the spec and the volumes of code out there always pushes me away from doing anything too DSLy.
17:27:10 <acowley> But there's a tremendous amount of boilerplate involved in GL code, which I think can be reduced without tipping the scales too far to obscurity.
17:27:35 <jmcarthur> i agree, but haskell makes it easy enough to stay DRY anyway, i think
17:27:50 <jmcarthur> without having to completely obscure what the documentation describes
17:28:23 <jmcarthur> also, the supporting more stuff is a big deal
17:29:08 <jmcarthur> i haven't taken much advantage of it for the lib i'm working on yet, but in the long run i plan to use some extensions that the OpenGL package doesn't support
17:29:16 <jmcarthur> e.g. i believe it doesn't support array textures
17:29:26 <acowley> jmcarthur: I pull out a few in GLUtil.
17:31:20 <Aetherspawn> :t evalState
17:31:21 <lambdabot> State s a -> s -> a
17:32:43 <jmcarthur> acowley: what do you mean "pull out a few"
17:32:46 <jmcarthur> ?
17:32:54 <DiegoNolan> is There a way to just enumAll instead of enumFrom incase someone changes the order of the type it doesn't mess up the code?
17:32:55 <acowley> jmcarthur: OpenGL extensions not covered by OpenGL
17:33:20 <jmcarthur> ah
17:33:32 <jmcarthur> yeah i guess nothing prevents one from using both
17:33:39 <shachaf> What's this quote doing in HWN?
17:33:40 <acowley> jmcarthur: The way I thought about it a while ago is that the OpenGL package is a reasonable effort to make the API more comfortable in Haskell, so I tried to avoid shaving that yak myself.
17:33:55 <shachaf> This is its third HWN appearance.
17:33:57 <monochrom> DiegoNolan: derive Bounded, then enumFrom minBound
17:34:08 <acowley> jmcarthur: So I just pull in unwrapped parts from the Core modules, and wrap them myself the way I want to use them.
17:34:10 <jmcarthur> acowley: i basically just shoot for very raw opengl style without much wrapping it, just a few helper functions and such
17:34:12 <hidenori> im reading real world haskell, and confused with the chapter 5 about JSON. Im not too sure what the module made in this chapter does. Do they just print JValue in a readable way?
17:34:30 <DiegoNolan> monochrom: ty
17:34:32 <acowley> jmcarthur: There is a lot of trouble due to various things not being exported from OpenGL, so I may change course at some point.
17:34:59 <jmcarthur> acowley: raw is quite verbose and annoying to write, i have to say, but i don't feel my overall code quality suffers for it
17:35:16 <jmcarthur> especially since opengl is quite low level regardless of which of these two libraries you choose
17:36:16 <acowley> jmcarthur: I find that verbosity hurts readability, so, as I said, I try to find a balance in the abstractions. The vinyl-gl stuff is the furthest I've pushed things, but I think the crud it handles for you is liberating as it keeps the Haskell code extremely flexible.
17:37:05 <jmcarthur> acowley: i agree that verbosity hurts readability. i may have overstated my indifference to the code quality
17:37:06 <acowley> jmcarthur: Yeah, true enough. I just found myself defining some newtypes over things in Raw before, then felt silly since I was just going to re-implement part of the OpenGL package.
17:37:34 <acowley> The main thing that vinyl-gl buys you is that it name and type checks your uniform parameters, and it figures out array offsets for vertex attributes.
17:38:04 <acowley> GLUtil provides conveniences for loading things and then actually putting things on the screen.
17:38:36 <jmcarthur> yeah the vertex attributes thing is something i have made a few attempts to clean up before
17:39:28 <jmcarthur> ah, DataKinds. i haven't tried that one before
17:39:32 <jmcarthur> the list of types
17:39:47 <jmcarthur> i had done some GADT stuff before. didn't like it
17:40:39 <acowley> jmcarthur: I hope the examples demonstrate the value. I'm not trying to sell it for some dubious intrinsic value.
17:41:29 <jmcarthur> acowley: i rather like this approach, i think, although i would have to play with it to be sure
17:41:38 <jmcarthur> acowley: i guess you are pretty happy with it or you wouldn't have gotten this far?
17:41:40 <acowley> jmcarthur: For my own code, switching over to this style cut out a significant amount of code and made it easier to change things without any goblins emerging from the gap between Haskell and GLSL
17:42:22 <acowley> jmcarthur: I developed parts of it over the past year (e.g. my parts of linear), and I've been trying to extract things into reusable libraries as I move on to the next thing.
17:42:57 <jmcarthur> acowley: i have a GPipe-like library in my head that i might use this approach for. it would be very compatible with other ideas i've had, i think
17:43:26 <acowley> jmcarthur: I have a huge amount of respect for GPipe, but I felt that it went too far, making it hard to use OpenGL references found online (as per our discussion just now)
17:43:33 <jmcarthur> agreed
17:43:36 <jmcarthur> well
17:43:45 <jmcarthur> the idea is that you *shouldn't* need to know opengl to use gpipe
17:44:05 <jmcarthur> i think gpipe didn't go too far, just in the wrong direction
17:44:34 <acowley> jmcarthur: Another thought I had is that abstracting GLSL itself doesn't necessarily buy you a lot. We sometimes want Haskell code that magically runs on the GPU, but supporting the syntax for the DSL ends up demanding separate files, etc.
17:44:35 <jmcarthur> it went so far in the "well-typed" direction that there wasn't enough care in preserving the cost model
17:44:51 <acowley> jmcarthur: Yeah, that's part of it
17:45:31 <acowley> jmcarthur: With GPipe, I felt like when I did care about costs, I was so far up the creek that it was hopeless for me to improve things
17:45:37 <jmcarthur> yeah
17:46:19 <acowley> jmcarthur: So I came away a fan of the practical things GLSL affords, and the fact that any extension or whatever I need is there ready to be used.
17:46:34 <jmcarthur> my idea is a bit closer to what opengl does. the idea is to set up a "program", "compile" it, and then feed it dynamic data
17:47:03 <jmcarthur> instead of trying to hide the staging under the hood
17:48:11 <acowley> Most of my work code that uses OpenGL ends up with types that are basically, Vector Foo -> IO (Vector Foo)
17:48:33 <jmcarthur> oh?
17:48:53 <jmcarthur> i don't think i've noticed that pattern
17:51:23 <acowley> It's not in that code
17:59:46 <Aetherspawn_> is there a version of `local` for MonadReader that takes an (r -> IO r)
18:01:16 <monochrom> no
18:03:54 <Aetherspawn> monochrom, aww. Is there a way I can get the same kind of thing via function composition?
18:04:27 <Aetherspawn> Hayoo says no :(
18:09:09 <jmcarthur> Aetherspawn: hayoo isn't always right
18:11:29 <arkeet> on the other hand, shachaf is always right.
18:11:42 <shachaf> hi arkeet
18:11:44 <arkeet> hi
18:11:46 <shachaf> Are you coming to the thing?
18:11:49 <arkeet> what thing?
18:11:57 <byorgey> you know, the thing at the place
18:12:03 <shachaf> What byorgey said.
18:12:03 <arkeet> oh that thing
18:12:06 <arkeet> uh
18:12:12 <arkeet> when is it?
18:12:17 <arkeet> at that time, I suppose.
18:12:17 <shachaf> In 45 minutes.
18:12:40 <monochrom> arkeet: are you coming to the thing at the place at the time for the purpose? :)
18:12:50 <arkeet> unfortunately no, I can't make it
18:13:01 <arkeet> I will go the next time there is a thing at a place.
18:13:07 <arkeet> hopefully.
18:13:15 <byorgey> arkeet cannot go, because of a reason
18:13:24 <arkeet> that is correct
18:22:54 <Luke_> I need some ideas. I'm using google's API to get a timezone from a lat, lng: https://developers.google.com/maps/documentation/timezone/ -- I want to build a Haskell TimeZone from it but the fields don't line up. Any ideas about how to losslessly coerce between the type and the google info?
18:22:58 <joeyh> I'm looking at Crypto.Classes and wondering what provides instances of BlockCipher and StreamCipher. Anyone know? (hayoo came up empty)
18:24:55 <Aetherspawn> Hayoo is missing a lot of lens
18:25:46 <c_wraith> lens changes fast.  How often does Hayoo reindex?
18:28:18 <Aetherspawn> Wouldn't have a clue
18:29:22 <Luke> isn't haskell's timezone ambiguous? I think the 3-4 letter codes are not exact
18:40:13 <roconnor> Luke: you mean in Data.Time?
18:40:42 <roconnor> Luke: A timzone in Data.Time is simply an offset from UTC.  Arguably it isn't a "timezone".
18:40:53 <Clint> joeyh: cryptocipher used to
18:42:12 <joeyh> Clint: used to eh
18:42:26 <Luke> roconnor: http://hackage.haskell.org/packages/archive/time/1.4.0.2/doc/html/Data-Time-LocalTime.html#t:TimeZone
18:42:34 <Clint> joeyh: looks like it went in january
18:44:13 <roconnor> Luke: okay, I see
18:45:02 <roconnor> Luke: it seems likely you should sum dstOffset and rawOffset and divide it by 60 to fill in timeZoneMinutes
18:45:25 <roconnor> Luke: timeZoneSummerOnly should be set to True if and only if dstOffset is 0
18:45:44 <Luke> roconnor: yeah i think I just want rawOffset and T or F for Summer
18:45:56 <roconnor> Luke: and you can put anything into timeZoneName, such as timeZoneName
18:46:01 <Luke> actually I think Summer only is if dstOffset is NOT zero
18:46:10 <roconnor> right
18:46:17 <Luke> roconnor: right i think the string is just convenience
18:46:18 <Luke> ok thanks
18:46:32 <roconnor> Given the examples on the website, I'm pretty sure you will need to add dstOffset and rawOffset
18:47:33 <joeyh> Clint: so it had an instance for AES, but dropped it when switching to cipher-aes
18:47:42 <Luke> roconnor: what specifically makes you say that?
18:48:20 <Luke> roconnor: I think hanlders of TimeZone will do the offset based on the flag
18:48:20 <Clint> joeyh: and it had one for blowfish and dropped it
18:48:30 <Luke> roconnor: I don't want the offset to be double-applied
18:48:40 <roconnor> Luke: the fact that rawOffset is the same in the PST and PDT examples
18:48:48 <Luke> roconnor: it should be
18:49:09 <Luke> the summer flag tells Haskell (like postgresql-simple) to apply an hour offset
18:49:20 <roconnor> well if you want to make a Haskell TimeZone value, you will need to sum them.
18:49:40 <Luke> no I don't think so. check out postgresql-simple's code
18:49:42 <roconnor> Luke: I think timeZoneSummerOnly is simply an informative flag
18:49:46 <roconnor> like timeZoneName
18:49:53 <roconnor> only timeZoneMinutes is normative.
18:50:22 <Luke> roconnor: that can't be. depending on the local time associated with the timezone, the flag may or may not be applied
18:50:51 <Luke> roconnor: let me try to find an example in source
18:51:33 <joeyh> Clint: so I think the idea is end users make their own instances with the key size etc they need
18:52:09 <Luke> roconnor: I can't see it in the code: https://github.com/lpsmith/postgresql-simple/blob/master/src/Database/PostgreSQL/Simple/Time/Implementation.hs#L191
18:52:50 <roconnor> Prelude Data.Time> print . timeZoneMinutes =<< getTimeZone (UTCTime (fromGregorian 2013 1 1) 0)
18:52:52 <roconnor> -300
18:52:53 <roconnor> Prelude Data.Time> print . timeZoneMinutes =<< getTimeZone (UTCTime (fromGregorian 2013 6 1) 0)
18:52:55 <roconnor> -240
18:53:09 <Hrumph> ;;ticker
18:53:15 <Luke> is getTimeZone applying the offset though?
18:53:16 <Hrumph> oops wrong chan
18:53:17 <roconnor> Luke: See, the timeZoneMinutes for eastern time changes when you switch to DST
18:53:30 <Hafydd> I ;;ticker you too!
18:53:37 <roconnor> Luke: getTImeZone is just returning a TimeZone value
18:53:46 <roconnor> Luke: and timeZoneMinutes is extracting the field.
18:53:59 <Luke> ok thanks
18:55:02 <Luke> yup - i think you're right
18:55:07 <Luke> thanks a lot
19:02:03 <Luke> roconnor: actually in the example you gave, if you look at the DST timezone with timeZoneMinutes and timeZoneOffsetString, they show different values
19:04:11 <Luke> so it still applies the summer flag, but you're right, the offset is still summed
19:05:49 <NerrZ> Hey, I have a simple question that may be pretty obvious
19:06:32 <roconnor> Luke: timeZoneOffsetString doesn't depend on the summer flag
19:06:49 <roconnor> timeZoneOffsetString' :: NumericPadOption -> TimeZone -> String
19:06:50 <roconnor> timeZoneOffsetString' opt (TimeZone t _ _) | t < 0 = '-':(showT opt (negate t))
19:06:52 <roconnor> timeZoneOffsetString' opt (TimeZone t _ _) = '+':(showT opt t)
19:07:06 <Luke> so weird
19:07:24 <roconnor> As I keep saying, the summer flag is just informative, not normative.
19:07:29 <Luke> timeZoneMinutes  timezone = -300
19:07:43 <Luke> timeZoneOffsetString timezone = "-0500"
19:07:50 <Luke> same timezone
19:07:59 <roconnor> -0500 mean 5 hours and 0 minutes
19:08:04 <roconnor> -300 means 300 minutes
19:08:06 <Luke> ooooh right
19:08:07 <Luke> thanks thanks
19:08:33 <Luke> stupid me =)
19:08:40 <Luke> i've been looking at this for too long
19:08:43 <roconnor> heh
19:08:48 <Luke> thanks though
19:08:50 <roconnor> np
19:11:49 <NerrZ> My question is does someing like list!!10 + list!!11 hold the pointer in the linked list and only take T(c) to execute the addition after indexing at 10, or does it step through to index at 10, then go back to the head pointer and step through to 11
19:12:52 <enthropy> pretty likely that it does the second
19:12:56 <roconnor> NerrZ: !! always goes back to the beginning to traverse.
19:13:10 <NerrZ> really, that is a shame
19:13:14 <blackdog> NerrZ: if you need random access, a list is probably the wrong data structure
19:13:20 <NerrZ> Ik
19:13:26 <roconnor> NerrZ: more specifically list!!10 will force the spine upto the first 10 places, and then !!11 will traverse that forced spine and then force the 11 place.
19:13:28 <dibblego> if you use (!!) then [] is the wrong data structure
19:14:04 <blackdog> languages like C tend to use random access even for simple iterations - it's worth getting into the habit of thinking of them separately.
19:14:04 <roconnor> NerrZ: so you get some memoization advantage if forcing the spine is expensive ... but usually the spine is cheap and it is the data that is expensive.
19:14:23 <NerrZ> okay, so it does remember the location
19:14:43 <roconnor> okay, it doesn't remember the location
19:15:01 * roconnor feels like he has just made things more confusing.
19:15:01 <blackdog> NerrZ: no - it still traverses the spine. it's just already evaluated it, so if they were thunks waiting to be evaluated it, it doesn't have to force the spine again.
19:15:14 <NerrZ> okay
19:15:16 <NerrZ> thank you
19:15:47 <NerrZ> I know that random indexing is wrong for lists, I was just wondering how something like that would be evaluated
19:16:38 <blackdog> NerrZ: so, assume the list is something like [1..]
19:16:58 * geekosaur is not sure what "remember the location" is supposed to mean
19:17:08 <blackdog> in memory, that's just a thunk, right? nothing of the list actually exists yet
19:17:37 <blackdog> so when you go for l !! 10, you evaluate the fact that the list has at least ten elements
19:17:58 <geekosaur> non-strict evaluation means that every "value" is a pointer to a routine which will (a) evaluate the value to the required depth (might be the first constructor, might be the final value if any, depending on what is demanded) and (b) replace itself with a pointer to the result
19:18:14 <blackdog> the nodes of the list are still thunks - they haven't been evaluated yet. but if the original definition was different, l !! 10 might have thrown an error because it was only 5 elements long
19:18:27 <geekosaur> so it doesn't need to "remember the location", it "remembers" the result of an evaluation by replacing pointers
19:19:02 <geekosaur> there is no counter associated with a list that says that 10 elements have been evaluated, or anything like that
19:20:13 <NerrZ> Thank you for the detailed explanation, lazy evaluation didnt really make sense until now, kind of answered two questions at once
19:24:52 <NerrZ> People here are so helpful compared to other discussion locations
19:29:19 <orangerobot> NerrZ: it's amazing how people are nice when they are not *forced* to be nice
19:29:48 <hodapp> NerrZ: you know, I've commented on the same thing here
19:29:55 <NerrZ> what do you mean by that orange?
19:29:57 <Cale> NerrZ: Lazy evaluation is just outermost-first evaluation, together with sharing: each bound variable will only be evaluated at most once while it remains in scope.
19:30:07 <orangerobot> what i mean is that freedom works, that's all.
19:30:12 <NerrZ> ahh
19:30:30 <hodapp> orangerobot: where are people forced to be nice?
19:30:32 <Cale> I like to give the example of evaluating  double (double 5)  where  double x = x + x
19:30:54 <Cale> Under strict (innermost-first) evaluation, it reduces like:
19:30:58 <Cale> double (double 5)
19:31:02 <Cale> double (5 + 5)
19:31:04 <Cale> double 10
19:31:07 <Cale> 10 + 10
19:31:08 <orangerobot> hodapp: in a country where socialism is the status quo
19:31:09 <Cale> 20
19:31:40 <Cale> Under plain outermost-first evaluation, that would become:
19:31:43 <Cale> double (double 5)
19:31:46 <hodapp> orangerobot: not sure what that has to do with conduct in an IRC channel >_>
19:31:51 <Cale> -> (double 5) + (double 5)
19:32:00 <Cale> -> (5 + 5) + (double 5)
19:32:09 <Cale> -> 10 + (double 5)
19:32:14 <Cale> -> 10 + (5 + 5)
19:32:19 <Cale> -> 10 + 10
19:32:20 <Cale> -> 20
19:32:39 <orangerobot> hodapp: it has a lot to do
19:32:45 <NerrZ> Cale, so does that mean that if I write a function, f, and then exaluate f x, that functions result is memoized until the program ends as long as it is a global function?
19:32:51 <Cale> Which is bad, because we end up duplicating the work of evaluating double 5 since x occurs twice in the body of double
19:32:55 <Cale> no
19:33:08 <NerrZ> so when is the result collected?
19:33:17 <dibblego> NerrZ: if you wrote let z = f x, then use z more than once …
19:33:18 <Cale> We don't memoise
19:34:07 <Cale> Instead, we say that any work done evaluating the parameters to a function (or other bound variables) is shared between the occurrences of the variables
19:34:17 <NerrZ> okay
19:34:40 <Cale> So, if you'll allow me to use  let ... in ...  to represent that sharing, we'd have in this case:
19:34:43 <Cale> double (double 5)
19:34:43 <NerrZ> so since it already did double 5 it shared that with the other occurance?
19:34:58 <Cale> -> let x = double 5 in x + x  -- still outermost first!
19:35:11 <Cale> -> let x = 5 + 5 in x + x
19:35:17 <Cale> -> let x = 10 in x + x
19:35:22 <Cale> -> 10 + 10
19:35:23 <Cale> -> 20
19:35:35 <NerrZ> okay, so it only did double 5 once in that case
19:35:39 <NerrZ> I understand
19:35:54 <Cale> It is a little bit like memoisation, but it's just memoisation of bound variables inside their scope. Functions aren't memoised.
19:36:27 <NerrZ> That makes more sense then
19:36:30 <Cale> (well, any evaluation which can be done to figure out which function something is will be retained, but frequently that's not much)
19:37:58 <Cale> NerrZ: If we explicitly wrote double 5 + double 5, it would of course duplicate the work here.
19:38:42 <NerrZ> so if i have a list comprehenstion, and I do [f x | x <- [1..], even (f x)] does f x get evaluated twice?
19:38:44 <Cale> The transformation which turns that into  let x = double 5 in x + x  is called common subexpression elimination, and GHC does almost none of that, because it frequently makes space performance worse.
19:38:54 <Cale> yes, it will
19:39:03 <Cale> (for each element of the list)
19:39:05 <NerrZ> so I would do let y = f x in ...?
19:39:21 <NerrZ> or no since x is not in scope
19:39:27 <Cale> or  [y | x <- [1..], let { y = f x }, even y]
19:39:49 <Aetherspawn> Math-Combinatorics-Poset#divides
19:39:55 <Aetherspawn> could be optimized into rem?
19:40:09 <NerrZ> oh my, there are a lot of things I need to change
19:40:21 <NerrZ> I didn't realize that was evaluating twice
19:42:00 <Cale> Aetherspawn: It's currently using mod... I suppose it's possible that rem is faster.
19:43:24 <Cale> I seem to recall the argument for the inclusion of rem being that there are hardware implementations of it, even though most of the time what you actually want is mod.
19:44:14 <Cale> (but in this case it obviously doesn't matter much)
19:46:31 <Aetherspawn> Cale, mod implements rem
19:46:35 <Aetherspawn> with a branch
19:46:37 <Aetherspawn> for negatives
19:46:41 <Aetherspawn> (I think)
19:48:09 <Cale> mod x y has the nice property that when y is positive, then the result will be nonnegative.
19:49:14 <Cale> (it'll be between 0 and y-1)
19:49:40 <Cale> > map (`mod` 5) [-10..10]
19:49:41 <lambdabot>   [0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0]
19:49:46 <Cale> > map (`rem` 5) [-10..10]
19:49:47 <lambdabot>   [0,-4,-3,-2,-1,0,-4,-3,-2,-1,0,1,2,3,4,0,1,2,3,4,0]
19:50:04 <Aetherspawn> divisor doesn't need that property, does it?
19:50:12 <Aetherspawn> @src mod
19:50:12 <Cale> Not particularly.
19:50:12 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:50:32 <Aetherspawn> and since it's only checking for zero, you don't even notice it, I shouldn't think so
19:52:01 <NovaDenizen> > (-9) `quot` 5
19:52:01 <Cale> Well, right
19:52:02 <lambdabot>   -1
19:52:21 <Cale> It would be correct either way
19:52:36 <NovaDenizen> > all (\x -> (x `quot` 5) + (x `rem` 5) == x) [-100..100]
19:52:37 <lambdabot>   False
19:53:24 <NovaDenizen> all (\x -> (x `wuot` 5)*5 + (x`rem`5) == x) [-100..100]
19:53:24 <Aetherspawn> @src quot
19:53:25 <lambdabot> Source not found. I am sorry.
19:55:54 <Cale> foreign import prim "integer_cmm_divIntegerzh" divInteger#
19:55:54 <Cale>   :: Int# -> ByteArray# -> Int# -> ByteArray# -> (# Int#, ByteArray# #)
19:55:54 <Cale> foreign import prim "integer_cmm_modIntegerzh" modInteger#
19:55:54 <Cale>   :: Int# -> ByteArray# -> Int# -> ByteArray# -> (# Int#, ByteArray# #)
19:56:18 <Cale> those are the primitives that div and mod eventually result in using -- their definitions are otherwise identical
19:56:47 <Cale> (in ghc-7.6.3/libraries/integer-gmp/GHC/Integer/GMP.hs)
19:57:12 <Cale> So, to see the difference, you'll have to look into what GMP does
19:57:19 <Cale> This is just for Integer though
19:57:25 <Cale> I believe that's a polymorphic function
19:58:10 <Cale> oh, hmm, integer_cmm_* doesn't actually sound like GMP
19:59:40 <Cale> Ah, right foreign import prim... I'll see if I can find the implementation of the primops
20:05:52 <Cale> GMP_TAKE2_RET1(integer_cmm_divIntegerzh,      __gmpz_fdiv_q)
20:05:52 <Cale> GMP_TAKE2_RET1(integer_cmm_modIntegerzh,      __gmpz_fdiv_r)
20:07:28 <Cale> http://gmplib.org/manual/Integer-Division.html#Integer-Division -- okay, so GMP just has different operations for these which are used directly, as I suspected
20:11:22 <Cale> Aetherspawn: Internally to GMP, both div and mod reduce to similar calls to mpn_tdiv_qr after what looks like a fairly similar amount of work, but I might be missing some detail.
20:11:30 <Cale> er, rem and mod rather
20:14:21 <b6> i think it might be worthwhile to replace 3 nested alloca's with an allocaArray. the pointer i get back will be to a[0]. do i use plusPtr or something to get the addresses of a[1] and a[2]? (the array is of CInt)
20:15:10 <Tekmo> Well, sometimes you can avoid using plusPtr by using a derived operation
20:15:12 <Cale> advancePtr :: Storable a => Ptr a -> Int -> Ptr a
20:15:31 <Tekmo> For example, methods in the `Storable` class like `peekElemOff`
20:15:41 <Cale> (that just does a plusPtr)
20:15:55 <b6> Cale: oh, that's nicer than plusPtr. safer.
20:15:58 <Cale> ah, yeah, that's true as well
20:16:37 <Tekmo> Also, if you are using this to define `Storable` instances you can use `hsc2hs` to automate a lot of this for you
20:17:22 <b6> is hsc2hs being used under the hood if i'm writing *.hsc?
20:17:39 <Tekmo> Cabal will auto-run hsc for you if a file has a *.hsc suffix
20:17:48 <Tekmo> Without cabal, you would have to run it manually
20:18:07 <b6> i'm working on new glfw bindings. (i maintain GLFW-b).
20:18:15 <Tekmo> Oh nice!
20:19:15 <b6> thanks, guys.
20:19:20 <Tekmo> You're welcome!
20:19:47 <Cale> Aetherspawn: oh, actually, I misread -- mpq_fdiv_r (which is used to implement mod) indeed calls mpq_tdiv_r (which is used to implement rem). The amount of work in between is pretty minimal, but we could expect rem to be slightly faster. I've never personally had it matter.
20:20:29 <Cale> er, mpz in both cases
20:20:44 <Cale> damn GMP's insane naming conventions
20:25:45 <Aetherspawn> Cale, it makes quite a difference in that thing on stack overflow
20:26:16 <Aetherspawn> Cale, http://stackoverflow.com/a/6964760/1220423
20:40:12 <kvda> Confused by types I'm returning [Text], but the type checker is saying it's getting [a0]
20:40:22 <kvda> what does that [a0 ] suggest?
20:40:30 <Tekmo> The type checker only reports as much about the type as relevant to the type error
20:41:00 <Tekmo> So usually that means that it figured out there was a type error purely by virtue of there being a list
20:41:12 <Tekmo> It didn't need to know the element type of the list to deduce the type error, so it didnt' bother mentioning it
20:42:23 <Aetherspawn> can I use guard statements in the middle of non-do expressions
20:42:50 <Tekmo> You can fake it if you do:
20:43:00 <Tekmo> case () of _ | predicate = ...
20:43:16 <Aetherspawn> oh cool.
20:43:17 <Tekmo> In ghc-7.6 there is multiway if, which is nicer
20:44:45 <b6> wow, nice @ multi-way if.
20:45:10 <Tekmo> Yeah, it's nicer
20:45:22 <b6> does it complain if there isn't 'else' at the end or something?
20:45:33 * hackagebot Control-Monad-MultiPass 0.1.0.0 - A Library for Writing Multi-Pass Algorithms.  http://hackage.haskell.org/package/Control-Monad-MultiPass-0.1.0.0 (KevinBackhouse)
20:45:35 * hackagebot scc 0.8.1 - Streaming component combinators  http://hackage.haskell.org/package/scc-0.8.1 (MarioBlazevic)
20:45:37 <Tekmo> I don't know.  I haven't used it myself, yet
20:45:41 <Tekmo> I still use ghc-7.4
20:46:14 * tabemann is still stuck with GHC 7.4 as that's what comes with Debian
20:46:28 <Tekmo> Well, I stick with whatever is in the Haskell platform
20:46:51 <Tekmo> I just haven't had a chance to upgrade to the latest one just yet
20:46:53 <Clint> tabemann: 7.6 will be in testing "soon"
20:47:04 <b6> i'm lost as to what's going on with the HP. arch doesn't even seem to have a well-supported HP package now.
20:47:19 <Tekmo> I use Debian and it works out well for me
20:47:27 <kvda> Thanks Tekmo.
20:47:33 <Tekmo> You're welcome!
20:47:51 <tabemann> Clint: good
20:48:53 <Clint> tabemann: (where soon is probably somewhere between 2 days and the end of the month)
20:49:13 * tabemann has decided to take a stab at implementing red-black trees for the hell of it, and has managed to get so far as implementing insertion
20:50:58 <Aetherspawn> @pl (\x -> peekByteOff file (x*4))
20:51:01 <lambdabot> peekByteOff file . (* 4)
20:51:01 <lambdabot> optimization suspended, use @pl-resume to continue.
20:51:11 <Aetherspawn> @pl-resume
20:51:17 <lambdabot> peekByteOff file . (* 4)
20:51:17 <lambdabot> optimization suspended, use @pl-resume to continue.
20:51:25 <Aetherspawn> Never seen it do that before
20:51:32 <Tekmo> @pl-resume
20:51:45 <lambdabot> peekByteOff file . (* 4)
20:51:45 <lambdabot> optimization suspended, use @pl-resume to continue.
20:53:04 <copumpkin> @pl (\x -> x x) (\x -> x x)
20:53:08 <lambdabot> ap id id (ap id id)
20:53:08 <lambdabot> optimization suspended, use @pl-resume to continue.
20:53:17 <copumpkin> @pl-resume
20:53:22 <lambdabot> Plugin `pl' failed with: stack overflow
20:53:52 <Tekmo> Now look what you did!
20:54:01 <copumpkin> @pl \x -> f x x
20:54:01 <lambdabot> join f
20:54:04 <copumpkin> alive again!
20:56:44 <tabemann> @pl (.).(.).(.)
20:56:45 <lambdabot> (.) . (.) . (.)
21:02:59 <saml> how do I compose different monads? transformer?
21:03:25 <Eduard_Munteanu> saml: FSVO compose, yes
21:04:14 <Eduard_Munteanu> You probably mean "combine", rather than the too-specific "compose".
21:06:55 <DiegoNolan> how come you can't define a type like this
21:07:04 <DiegoNolan> data Test = Pass | (Int,Int)
21:07:18 <c_wraith> each alternative needs a constructor
21:07:24 <DiegoNolan> oh
21:07:29 <DiegoNolan> balls
21:07:32 <DiegoNolan> ty
21:07:33 <c_wraith> and if you have a constructor, you don't need to nest a pair in it
21:07:40 <c_wraith> data Test = Pass | Fail Int Int
21:07:47 <DiegoNolan> true
21:07:56 <DiegoNolan> I feel that (Int,Int) would be shorter though
21:08:06 <DiegoNolan> becase you can do data Test = Pass | Int
21:08:07 <tabemann> why?
21:08:20 <DiegoNolan> because then I have to patter match against it
21:08:26 <tabemann> you can't do that
21:08:27 <DiegoNolan> and i don't get all the functions that work on tuples
21:08:40 <tabemann> well you might be able to, but that's because Int isn't a data constructor
21:08:47 <saml> data Try a err = Success a | Failure err
21:08:51 <pqmodn> @pl \f (a,b) -> (a, f (a,b))
21:08:54 <lambdabot> flip ap snd . (. fst) . liftM2 (.) (,) . (. (,)) . (.)
21:08:55 <lambdabot> optimization suspended, use @pl-resume to continue.
21:08:57 <saml> or just use Either
21:09:30 <DiegoNolan> hmm
21:09:34 <tabemann> note that with Either a b, failure states should be specified with Left a, and success states should be specified with Right b
21:09:42 <Aetherspawn> Am I allowed to do multi line let's in non-do code?
21:09:42 <saml> Left 2    ,  Right (2,3)
21:09:43 <tabemann> by convention
21:10:06 <dmj> Aetherspawn: I believe so
21:10:06 <saml> Left (2,3)       Right 234232532
21:10:56 <DiegoNolan> I always thought it was kind of clumsy to use Right and Left
21:11:03 <Eduard_Munteanu> Multi-line let? Let is already like that.
21:11:14 <Eduard_Munteanu> let ... in ..., that is
21:11:22 <tabemann> for practically all such things in Haskell one will need to use data constructors
21:11:26 <tabemann> and thus pattern matching
21:12:32 <dmj> > let { a = 5; b = 6; } in a + b
21:12:33 <lambdabot>   11
21:12:45 <dmj> first time lambda bot has been nice to me
21:14:11 <dmj> Does anyone know how acid-state saves data from memory to disk? Is there a worker thread? I know it keeps a log, but when does it decide to write to it?
21:15:33 <tabemann> > let factorial n | n > 0 = n * factorial (n - 1) | n == 0 = 1 | otherwise = error "foo" in factorial 1000
21:15:34 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
21:15:45 <CaptainLex> So is using the GHCi as nice using LISP REPLs?
21:15:51 <elliott> sure
21:15:51 <tabemann> > let factorial n | n > 0 = n * factorial (n - 1) | n == 0 = 1 | otherwise = error "foo" in factorial 10000
21:15:52 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
21:15:56 <CaptainLex> as^
21:15:59 <tabemann> > let factorial n | n > 0 = n * factorial (n - 1) | n == 0 = 1 | otherwise = error "foo" in factorial 100000
21:16:03 <lambdabot>   mueval-core: Time limit exceeded
21:16:09 <blackdog> elliott: still can't define datatypes at the repl, can you?
21:16:13 <elliott> yes
21:16:15 <elliott> you can
21:16:19 <elliott> with a recent enough GHC anyway
21:16:25 <elliott> (also with lambdabot now!)
21:16:40 <blackdog> oooh. shiny.
21:17:27 <CaptainLex> elliott: The thing I'm most concerned about is redefining functions used by a running thread
21:17:37 <CaptainLex> And I'm a Haskell brand-noob
21:17:54 <elliott> you can't redefine anything, so that's ok
21:18:02 <elliott> at most you can shadow an old name
21:18:03 <CaptainLex> Hahaha
21:18:30 <elliott> i'm not kidding :)
21:18:34 <CaptainLex> No, I no
21:18:40 <elliott> ghci is a bit less fancy than slime or whatever
21:18:44 <CaptainLex> I'm not *that* much of a noob
21:18:49 <elliott> but we have types and lisp doesn't, and types are pretty great for interactive programming
21:19:07 <CaptainLex> I just want to know about altering the behavior of a running program
21:19:26 <CaptainLex> I'm beginning to feel its uses in game development, but I don't want to stay in clojure forever
21:19:29 <tabemann> one can't modify something that has already been created
21:19:44 <tabemann> you can only define something with the same name which rebinds the name for future usage
21:20:24 <enthropy> you could be over-writing functions if you stored them in IORefs or MVars or other things like that
21:20:48 <CaptainLex> tabemann: That's all I'd need - but the rebinding would stick for a thread that was currently running?
21:20:55 <tabemann> enthropy: but that's still not overwriting the function itself, but rather pointing the IORef or MVar to point at something else
21:21:04 <elliott> the "rebinding" is a purely lexical thing
21:21:14 <tabemann> CaptainLex: it would not affect previous references to the name, so no
21:21:15 <blackdog> CaptainLex: the difference is basically that you'd have to work out where your change points will be
21:21:17 <elliott> if you do "let x = ..." then "let x = ..." the only thing that changes is the environment at your ghci prompt
21:21:32 <CaptainLex> Oh I suppose
21:21:35 <elliott> a haskell implementation could support stuff like erlang-style hotplugging and the like but ghc doesn't really
21:21:38 <blackdog> and then store them in mvars, as tabemann said
21:21:43 <CaptainLex> I suppose I haven't asked
21:21:45 <CaptainLex> Ahhhhhhh
21:21:46 <elliott> however, you can quickly iterate things by reloading and restarting them
21:21:50 <elliott> which is a pretty good substitute
21:21:51 <CaptainLex> Light Table is spoiling me!
21:21:59 <blackdog> CaptainLex: if you're interested in this sort of stuff, don stewart's thesis is very interesting
21:22:00 <tabemann> blackdog: but even that isn't really it
21:22:12 <elliott> right, you can do hotplugging if you're more explicit about it.
21:22:16 <tabemann> because previous references to the value, as extracted from the MVar, don't change
21:22:17 <CaptainLex> blackdog: Oh? Linky-link?
21:22:18 <blackdog> tabemann: no, it's not the same as being able to change everything.
21:22:41 <blackdog> http://code.haskell.org/~dons/papers/thesis/dons-phd-thesis.pdf
21:22:55 <blackdog> there may be more recent work, i haven't kept in touch.
21:23:53 <Aetherspawn> Anyone know how to un-IO the list? http://hpaste.org/89913
21:24:09 <CaptainLex> blackdog: Oooh this is exciting
21:24:26 <CaptainLex> Every now and then I saw I don't care about CSci research, that I'm in it for what can be /made/
21:24:33 <CaptainLex> But I'm glad SOMEONE's doing :D
21:24:54 <arkeet> Aetherspawn: in fields <- ...,
21:24:59 <arkeet> the stuff on the right is a list of IO actions.
21:25:02 <arkeet> not an IO action returning a list.
21:25:07 <arkeet> you probably want mapM
21:25:16 <Aetherspawn> Thanks, I'll try that :)
21:25:56 <tabemann> one problem is that you are feeding "read" into "error"
21:26:11 <tabemann> forget that
21:26:32 <Aetherspawn> When I changed to mapM I moved it directly into the case
21:26:40 <Aetherspawn> otherwise it was being wrapped by MonadIO m automatically
21:26:49 <tabemann> oh I got it
21:26:56 <Aetherspawn> now there's another error
21:26:59 <arkeet> huh?
21:27:02 <tabemann> you have to do return (NXFile ...)
21:27:05 <arkeet> nothing is wrapped automatically.
21:27:30 <arkeet> all of your stuff is just in IO, and not a MonadIO in general
21:27:32 <tabemann> because you're in the IO monad, you have to turn NXFile into IO NXFile with return
21:28:00 <Aetherspawn> That one hasn't come up yet tabemann :P
21:28:06 <Aetherspawn> sec
21:29:10 <tabemann> another problem
21:29:25 <tabemann> base   <- mmapFilePtr f ReadOnly Nothing >>= (\(p, _, o, _) -> plusPtr p o)
21:29:27 <tabemann> should be
21:29:33 <tabemann> base   <- mmapFilePtr f ReadOnly Nothing >>= (\(p, _, o, _) -> return $ plusPtr p o)
21:30:09 <Aetherspawn> oh
21:30:26 <arkeet> well, that should really be a fmap
21:30:30 <arkeet> (or mapM)
21:30:58 <tabemann> arkeet: you mean liftM by mapM?
21:31:08 <arkeet> you know,
21:31:17 <arkeet> I think you should just write this for uh
21:31:24 <arkeet> just FilePath -> IO NXFile
21:31:40 <arkeet> and then liftIO the whole thing at the very end
21:32:30 <Aetherspawn> turns out I shouldn't be using the applicative stuff
21:32:39 <Aetherspawn> I don't think
21:32:56 <arkeet> probably
21:33:18 <tabemann> yeah, it seemed superfluous to me when I saw it
21:33:56 <tabemann> and, yeah, now that I think of it, it shouldn't work at all
21:34:12 <Hrumph> is it better to use errorT or exceptionalT?
21:35:03 <Hrumph> they seem awfully similar
21:35:14 <Hrumph> except exceptionalT specifically deals in exceptions
21:35:43 <arkeet> don't use ErrorT.
21:35:48 <arkeet> at least use EitherT instead.
21:36:00 <Hrumph> ok why eitherT instead of errort?
21:36:31 <arkeet> ErrorT has a dumb Error constraint on the left type.
21:37:02 <Hrumph> yes that's why it doesn't work with Text out of the box
21:37:21 <Hrumph> still doesn't seem to be a significant difference
21:38:50 <arkeet> and by EitherT, I mean the one in the either package
21:39:53 <arkeet> I would go with it just because it's an edwardk library. =)
21:41:09 <Hrumph> i really want just to have a set of my own conventions to work with now
21:41:22 <Aetherspawn> > case [1..3] of a@[b,c,d] -> a
21:41:24 <lambdabot>   [1,2,3]
21:41:24 <Hrumph> i find all the possibilities when it comes to errors and so on to be too sprawling
21:41:25 <arkeet> together with errors maybe.
21:41:26 <Aetherspawn> > case [1..3] of a@[b,c,d] -> b
21:41:28 <lambdabot>   1
21:41:30 <arkeet> the 'errors' package, I mean.
21:42:36 <Hrumph> i'm going to go with exceptionalT this time and see if i like it
21:42:45 <Aetherspawn> Got a cool trick apply functions a and b alternating to each member of a list? :P
21:42:56 <arkeet> zipWith ($) (cycle a b)
21:43:01 <arkeet> er
21:43:03 <arkeet> zipWith ($) (cycle [a,b])
21:43:14 <Aetherspawn> Oh wow haha
21:43:28 <arkeet> btw, ($) = id
21:43:38 <Hrumph> i'm not the only one to have whined about this
21:54:13 <top> male no ghriend here plz
22:08:10 <tabemann> http://hpaste.org/89915 < I'm having trouble with this somehow creating infinite trees after two inserts in a row
22:09:25 <tabemann> any clue?
22:11:03 <mjrosenb> tabemann: let foo = bar foo -- this  doesn't redefine foo, in terms of its old binding
22:11:12 <mjrosenb> tabemann: it defines foo in terms of itself.
22:12:28 <tabemann> yes
22:12:31 <tabemann> but if you do
22:12:40 <tabemann> let foo = baz
22:12:41 <tabemann> in
22:12:49 <tabemann> let foo = quux
22:13:03 <tabemann> it's simply rebinding the name "foo"
22:13:16 <mjrosenb>     let (left, right) =
22:13:16 <mjrosenb>           if key < nodeKey
22:13:17 <mjrosenb>           then (insertNode left pair (depth + 1), right)
22:14:11 <tabemann> oh that
22:15:00 <mjrosenb> yes, that.
22:15:44 <tabemann> weird
22:16:09 <tabemann> I replaced "(left, right)" with "(left', right')", and likewise with subsequent references, and it still doesn't work
22:17:17 <dmj> PRIVMSG Lemmih :are you there?
22:18:41 <Aetherspawn> dmj: that was not so private
22:19:20 <NemesisD> hey guys. i was wondering if any of you have figured out tools for a rapid test feedback cycle in haskell
22:19:44 <NemesisD> i'd ideally like to rig something to monitor my haskell source/test files and quickly recompile/rerun tests
22:19:53 <blackdog> NemesisD: yeah, i did something like that with guard
22:20:19 <blackdog> NemesisD: https://gist.github.com/mwotton/5682243
22:20:36 <NemesisD> blackdog: how did you get it fast? currently to rerun tests i do something like cabal configure --enable-tests && cabal build && cabal test which is on the order of 7 secs
22:20:57 <blackdog> you can get it to run ghc -fno-code -e 'return 0'
22:21:10 <blackdog> you migh thave to fiddle with it
22:21:27 <NemesisD> hmmm interesting
22:21:55 <blackdog> i have some extra stuff in there to ignore the flymake files, so i have that first line of defence of getting type checks in my editor
22:23:50 <mjrosenb> tabemann: can you print out a session where you've made a self-referential tree? and the updated code?
22:24:58 <b6> if a c function returns x** where x is some opaque type, does the foreign import line really look like ... -> Ptr (Ptr X) ?
22:26:31 <NemesisD> blackdog: hmm for me it doesn't seem to actually run the tests. maybe its suppressing stderr? the last thing i see is some "linking" messages
22:26:43 <elliott> b6: sure
22:26:59 <b6> elliott: thanks, confused myself.
22:27:13 <tabemann> mjrosenb: I've changed the function quite a bit to avoid unnecessarily allocating a tuple, which I'll put up on the board
22:27:20 <NemesisD> ah i think it doesn't like the &&
22:27:20 <dmj> > @src msum
22:27:22 <lambdabot>   <hint>:1:1: parse error on input `@'
22:27:29 <dmj> @src msum
22:27:29 <lambdabot> msum =  foldr mplus mzero
22:27:30 <tabemann> but despite the significant changes to the insertNode function, it still hangs when I try to do show on a tree
22:29:01 <blackdog> NemesisD: oh, sorry, that was the wrong prat
22:29:03 <blackdog> *part
22:29:21 <blackdog> it's the last part -  with the test/dummy.hs bit
22:29:56 <tabemann> agh hpaste just broke
22:30:42 <NemesisD> blackdog: that part is what? what i should use or...
22:30:52 <tabemann> http://pastebin.com/sv86AkM1
22:33:50 <blackdog> NemesisD: the stanza with test/dummy.hs in it
22:34:55 <blackdog> so test/dummy.hs for me just has
22:34:55 <blackdog> module Dummy(module Test.Hspec) where
22:34:56 <blackdog> import Test.Hspec
22:35:19 <blackdog> leave the other stanzas off for the moment, they're more about compile failures
22:35:39 <blackdog> just checked it on my box - that piece runs in about 0.3 seconds
22:36:30 <blackdog> anyone played with ekg? it's telling me that i'm not using any memory etc, which seems wrong
22:37:09 <NemesisD> blackdog: hmm. i've got a file test/Spec.hs that's got the whole {-# OPTIONS_GHC -F -pgmF hspec-discover #-} thing in it
22:37:30 <blackdog> NemesisD: yes, me too.
22:37:35 <blackdog> tbh i forget what the dummy file was for
22:37:53 <blackdog> (answering my own question - needed to pass -T to the runtime)
22:37:56 <NemesisD> hmm i wonder if i could replace dummy with Spec
22:38:30 <NemesisD> wait hspec has a binary?
22:39:34 <blackdog> NemesisD: don't believe so
22:39:46 <blackdog> ask in #hspec, solirc is pretty good about helping out.
22:40:50 <NemesisD> blackdog: hmm well replacing dummy with Spec.hs results in about a 3s test run from start to finish, which isn't too bad
22:41:14 <blackdog> better than waiting for cabal :)
22:41:39 <NemesisD> now i'll just need to do some rewrites so that i can edit a source file and have it run the associated specfile
22:41:47 <NemesisD> blackdog: sure is! thanks!
22:42:06 <NemesisD> but you're calling collect instead of map!
22:42:19 <NemesisD> cardinal FP sin
22:43:05 <blackdog> NemesisD: hehe. i've been tainted by my time in the ruby wilderness
22:46:29 <blackdog> well, this is confusing. i can talk to ekg locally fine. on the remote box, i can talk to it with json, but not with http
22:46:43 <blackdog> uh, not with html
22:47:32 <tabemann> hah
22:48:04 <tabemann> that wasn't working because I had recursive definitions in GHCi... (I'm so used to ML's semantics for these sorts of things)
22:50:04 <CaptainLex> Well, that's quite enough FPL theory for tonight. Wodehouse and bed for me! Night all!
23:15:03 <KoF> bleh
23:15:04 <KoF> so
23:15:11 <KoF> I have a couple dozen .hs files
23:15:18 <KoF> which were written in Linux
23:15:31 <KoF> which apparently makes their line breaks not work on my Windows computer
23:15:44 <KoF> which is bad, because I need to understand what they're doing, plus whitespace syntax
23:15:45 <pharaun> \n vs \r\n
23:15:57 <pharaun> KoF: get an editor that can open unix line=-ending?
23:16:05 <pharaun> and outta be able to resave it into windows line-ending
23:16:13 <KoF> well
23:16:15 <KoF> I have methods of doing it
23:16:17 <KoF> just
23:16:26 <KoF> I'm hoping there's an easier wa
23:16:28 <KoF> *way
23:16:38 <KoF> because I have two dozen of them
23:16:41 <pharaun> unix2dos dos2unix ?
23:17:08 <KoF> I found a couple tools for that
23:17:13 <KoF> but they don't like me :<
23:17:17 <pharaun> sed?
23:17:37 <KoF> one of them only takes .txt files, one of them I can't read the help for or the comments on the C source because Spanish
23:17:42 <KoF> sed?
23:17:48 <pharaun> streaming line editor
23:17:59 <pharaun> it can do search and replace on a line by line basis in your file
23:18:44 <pharaun> currywust!
23:22:30 <KoF> Aha
23:22:32 <KoF> Cool.
23:23:25 <aleator_> KoF: This is one of the things that is solved easier on linux than on windows.
23:23:45 <b6> trying to think of something that isn't. :'(
23:23:51 <aleator_> KoF: Also, if you happen to have git-bash installed, you can use that: https://gist.github.com/koistya/1803285
23:24:12 <KoF> I don't.
23:24:27 <KoF> ...Is there a way to rename a bunch of things at once on Windows command line?
23:24:51 <aleator_> b6: Welcome to the world of gigE cameras and pc-controlled microscopes then ;)
23:25:19 <b6> ok, i can accept that theoretically, something is easier in windows. i am that open-minded.
23:26:00 <aleator_> b6: Except for one thing. When the bloody things don't work on linux they just don't work. When they don't work on windows, you have to restart the pc. :(
23:27:41 <aleator_> KoF: I'd think git-bash might actually be easiest if you can't find a windows native program to do this. Also, emacs, vim etc. will help.
23:29:48 <Kneiva> Any idea why my cabal installs keep failing (/usr/bin/ghc returned ExitFailure 11) on Mac? Fails don't necessarily happen at same point and I've successfully installed some packages by just running install again and again until it completes successfully.
23:30:42 <aleator_> Kneiva: I had similar behaviour when I was running out of disk space.
23:31:42 <b6> could ExitFailure 11 mean something died with signal 11?
23:32:08 <Kneiva> I have 143 G of free space
23:34:30 <mjrosenb> Kneiva: is it possible you're running out of inodes?
23:35:07 <Kneiva> b6: but that is really vague, and I don't get anything else even with verbose=3
23:35:29 <elliott> Kneiva: the error message is usually further up
23:36:21 <Kneiva> mjrosenb: how can I check that?
23:36:27 <mjrosenb> Kneiva: df -i?
23:38:00 <Kneiva> %iused 52%    ?
23:45:16 <Aetherspawn> If I'm going to forkIO a new thread and I want it to have the same reader as the current thread is there an easy way to do that
23:45:26 <Kneiva> hmm, hpaste is down
23:46:05 <johnw> Aetherspawn: you can "get" in the calling thread and then do a runReader in the child thread, is that what you mean?
23:46:39 <blackdog> hrm. 35% productivity makes blackdog so sad.
23:47:05 <Aetherspawn> Hmm, sec, let me just try with ask
23:47:23 <blackdog> any hints on making my code do more of the good stuff and less of the bad stuff?
23:47:43 <johnw> ah, I meant "ask"
23:47:43 <Aetherspawn> that did the trick! :)
23:47:52 <johnw> always get those confused...
23:47:55 <Kneiva> elliott: I didn't find anything suspicious before those lasts lines. Can you check this? http://pastebin.com/Gxjtzfa4
23:48:26 <Aetherspawn> maybe there is an easier way to do it though
23:48:41 <Aetherspawn> than r <- ask; forkIO $ runReaderT handleSocket r
23:49:45 <elliott> Kneiva: "sudo cabal" is usually not what you want, btw. weird error though
23:49:55 <elliott> can't see any obvious problem.
23:50:35 <johnw> Aetherspawn: how are you calling forkIO inside ReaderT?
23:50:45 <johnw> @type forkIO
23:50:46 <lambdabot> Not in scope: `forkIO'
23:51:52 <Kneiva> elliott: ok, thanks
23:52:39 <Aetherspawn> johnw, http://pastie.org/private/6ofoecfe9hieerqgjudg
23:52:44 <Aetherspawn> hpaste is down, sorry.
23:52:59 <johnw> ahhh
23:53:05 <johnw> MonadReader
23:53:26 <Aetherspawn> I love mtl
23:53:27 <johnw> I don't use mtl, so I don't rely on those classes
23:53:31 <Aetherspawn> it removes transformer headaches
23:54:06 <johnw> i've read in a few places that transformers is the way of the future
23:54:57 <Aetherspawn> TransformersT GiveT YouT (HugeT a1 (RidiculousT type (errors IO ())))
23:55:34 <ktosiek> I'm always afraid I'll be lost in all the lifting when using transformers
23:56:44 <Aetherspawn> johnw, I've been using the transformer functions inside mtl
23:56:55 <Aetherspawn> like "runReaderT" -- should I be doing that?
23:57:32 <johnw> ah, looks like mtl uses transformer nowadays
23:57:34 <johnw> i didn't realize that
23:57:51 <johnw> nice!  you just added to my toolkit
23:57:56 <Aetherspawn> I'm in the future then :)
23:57:59 <Aetherspawn> hehe
23:58:01 <johnw> indeed
23:58:05 <johnw> glad this came up
23:58:08 <Heffalump> the idea of the transformers/mtl split was to allow for an alternate implementation of the type classes using type families
23:58:19 <Heffalump> so there's transformers, then monads-tf or mtl on top if it
23:58:47 <johnw> how does monads-tf compare to mtl?
23:58:59 <elliott> unfavourably
23:59:12 <Heffalump> johnw: type families probably look nicer in general where they apply cleanly, but I've never used it personally
