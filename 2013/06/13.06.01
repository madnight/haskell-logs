00:00:25 <EarlGray> Hello
00:00:43 <EarlGray> is there a way to make GHC produce 32-bit executables on 64-bit machine?
00:01:29 <EarlGray> I'm writing an assembler for (very limited yet) subset of what GAS supports, and it's strictly 32-bit
00:02:16 <shachaf> Use 32-bit GHC?
00:02:23 <EarlGray> and I'd like to run compiled snippets in C code, which requires 32-bit environment
00:03:05 <roconnor_> EarlGray: the easiest way is to boot a 32-bit OS.
00:03:11 <EarlGray> oh
00:03:47 <EarlGray> ok. let's separate the assembler and the running program
00:03:58 <bobry> Is there an emacs mode for editing Alex files?
00:11:27 <fractalsea> Great, that where claused worked fine :) Last question before I finish this: Is there a version of replicateM that doesn't produce lists with duplicate elements?
00:12:07 <EarlGray> to remove duplicate elements, Data.List.nub may be used
00:12:30 <roconnor_> isn't the point of replicate to produce duplicate elements?
00:12:52 <EarlGray> nub `fmap` replicate<
00:12:57 <EarlGray> *replicateM
00:13:51 <fractalsea> replicateM produces all orderings of a list including multiple copies of the same value
00:13:58 <fractalsea> yes I could use nub on the result
00:14:56 <fractalsea> replicateM will produce a list of lists of combinations. I don't want to remove duplicates from sub lists. I want to remove the sublists that have duplicates
00:15:06 <fractalsea> Or better yet not produce those sub lists at all
00:17:01 <fractalsea> BTW Example of replicateM: replicateM 2 "ab" will give ["aa", "ab", "ba, "bb"] and what I want is simply ["ab", "ba"]
00:17:11 <fractalsea> so essentially just different orderings
00:17:12 <savask> fractalsea: Do you want all permutations?
00:17:44 <fractalsea> I always forget the difference between combinations and permutations
00:17:49 <fractalsea> umm
00:17:52 <savask> fractalsea: It looks like you do :-P There is a function "permutations" in Data.List
00:18:02 <savask> permutations "abc" == ["abc","bac","cba","bca","cab","acb"]
00:18:05 <fractalsea> ah nice. I'll check it out. Thanks
00:18:16 <fractalsea> yeah that's what I need! Thanks.
00:18:25 <savask> No problem.
00:56:51 <Jookia> Cabal closed my GitHub issue about adding support for generating test documentation as 'wontfix, by design'. Great.
01:00:54 <kurenai> probably have too much on the plate already
01:01:47 <Jookia> I'm prepared to write a patch I just don't want to spend time on nothing
01:03:14 <Jookia> Apparently the rationale is that because no modules are exposed, there's no sense building test documentation, like executables. But we still have the ability to generate executable documentation?
01:09:50 <no-n> >
02:07:41 <matheus23> "Monads are a kind of overloadable semicolon. – Paul Johnson Sep 1 '11 at 16:31" What does he mean by that?
02:08:32 <Ralith> matheus23: one common use of monads is to sequentially compose side-effecting operations
02:09:17 <matheus23> yes... that comment is from stackoverflow from a question regarding why something like getting the current time is allowed in a purely functional way
02:12:07 <kaikokaur> Is there a way to declare function in class that has no instance variable in arguments? (This function uses function that belong to same class.)
02:15:58 <elliott> kaikokaur: just declare it outside the class?
02:16:35 <kaikokaur> but there are class functions used inside
02:16:55 <dp_wiz> Are hgettext functions thred-safe? I.e. can i use them to set language per-request in a web server?
02:17:43 <elliott> definitions outside a class can use its members
02:18:20 <kaikokaur> second... thinking :)
02:18:53 <kaikokaur> no, I can't understand or see a way how to do it
02:19:01 <kaikokaur> I made example: http://kaikokaur.com/make-select.hs
02:20:22 <kaikokaur> it's like making correct sql for different sql engines and toRawSql is depending on instance (SqlLt is for SQLite, Pg for postgres)
02:20:48 <kaikokaur> if I take makeSelect out of class how Haskell knows what "version" on toRawSql it should use?
02:22:28 <roSievers> I believe haskell should automatically use the one provided with the typeclass
02:22:41 <roSievers> kaikokaur: did you try it out already?
02:22:58 <kaikokaur> no
02:23:49 <dp_wiz> so.. it turns out that "setlocale() is not thread-safe on most systems", so how can i chose a language for gettext per-request?
02:25:08 <roSievers> kaikokaur: I believe haskell uses it's type system to figure out which “version“ of toRawSql it uses
02:26:18 <kaikokaur> "makeSelect :: [SqlExp] -> String" have absolutely no hint should it use SqlLt or SqlPg
02:27:13 <Boney> win 10
02:35:10 <bartavelle> hello, I have a hackage question
02:35:24 <bartavelle> this package will probably never build, as it requires ruby1.8 to be installed : http://hackage.haskell.org/package/hruby
02:35:37 <bartavelle> this one depends on it, so will not build : http://hackage.haskell.org/package/language-puppet
02:36:01 <bartavelle> I introduced a flag with no default value to make de dependency optionnal : https://github.com/bartavelle/language-puppet/blob/master/language-puppet.cabal
02:36:16 <bartavelle> it doesn't seem to do what I expected, is there some way to make it right ?
02:36:38 <bartavelle> (ie. build on hackage without the hruby dependency, yet have it work seamlessly for people that already have hruby installed)
03:17:23 <jonkri> If I want to link my Apache License (Version 2) library against a GPL (Version 3) library, I have to dual license my library under both licenses, right?
03:17:40 <jonkri> Sorry, I just realized that's completely off-topic.
03:20:15 <Heffalump> I don't think that can be right - if you did have to dual licenc that would mean a receiver could choose either for the whole code, so you could have made that choice too
03:20:47 <Heffalump> but licencing confuses me
03:21:33 <Botje> jonkri: if you're the author, you can relicense at will
03:34:55 <hoisted> hello
03:47:29 <Chat2155> Giftgg
03:59:01 * hackagebot cabal2nix 1.50 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.50 (PeterSimons)
04:15:30 <krsrk> Hi
04:18:20 <krsrk> Is there a separate newcomers channel, or this channel is OK if I simply want to ask very basic questions (without reading all the comprehensive manuals)?
04:18:41 <kryft> krsrk: As far as I know it's ok to ask anything
04:18:48 <krsrk> cool
04:18:52 <elliott> it's fine to ask basic questions
04:20:47 <krsrk> I have a data structure deriving Show, Eq, Ord and Enum. For me, this data structure should be what Enumerators are in imperative world. How could I match stdin IO String to these "enums"?
04:21:18 <mauke> huh?
04:21:59 <mauke> let me make a few guesses: readLn
04:22:13 <elliott> krsrk: what kind of matching?
04:22:50 <krsrk> e.g from stdin someone gives "hello", and I could somehow take MyData.hello, and continue working with that data structure value instead.
04:23:31 <savask> Is your data a kind of string container or what?
04:23:35 <elliott> how is MyData defined?
04:25:17 <roSievers> I would implement read for MyData, allowing you to do read "hello", but I'm not sure if haskell can derive that itself
04:25:49 <krsrk> here's some pseudocode: http://pastebin.com/w7DnC55T
04:25:55 <mauke> The paste w7DnC55T has been copied to http://hpaste.org/89056
04:26:20 <savask> krsrk: Yeah, as roSievers said you have to make your type a "read" class instance.
04:26:21 <mauke> krsrk: read
04:26:39 <roSievers> krsrk: well, can you derive show or doois that throw an error?
04:26:43 <elliott> you can derive it, btw
04:26:48 <weebl> or use a parser
04:27:03 <elliott> and you can just say letter <- readLn
04:27:13 <elliott> which does getLine + read (+ handling of the error)
04:28:04 <elliott> mauke gets one psychic point :p
04:28:21 <mauke> (psychic debugging)++
04:28:38 <mauke> preflex: karma psychic debugging
04:28:38 <preflex>  psychic debugging: 28
04:29:26 <savask> What are those psychic points? o_O
04:29:35 <elliott> mauke: however, you are deducted points for saying you would make a few guesses and then only making one.
04:30:09 <mauke> elliott: I chained them without showing the intermediate results
04:35:13 <savask> Are there any custom Integer implementations available which don't use external C libraries?
04:35:30 <roSievers> is there an “inverse !!” :: [a] -> Int -> [a] which drops one of the elements?
04:36:26 <mauke> :t uncurry (++) . fmap (drop 1) . splitAt ?n
04:36:27 <lambdabot> (?n::Int) => [a] -> [a]
04:36:56 <roSievers> mauke: thanks :-)
04:37:12 <no-n> what's ?
04:37:55 <no-n> or rather ?n
04:37:56 <roSievers> I guess  that implies n is a variable in the given context
04:38:07 <roSievers> :t uncurry (++) . fmap (drop 1) . splitAt n
04:38:08 <lambdabot>     Couldn't match expected type `Int' with actual type `Expr'
04:38:08 <lambdabot>     In the first argument of `splitAt', namely `n'
04:38:08 <lambdabot>     In the second argument of `(.)', namely `splitAt n'
04:40:27 <elliott> savask: does integer-simple in ghc use a C library?
04:43:21 <savask> elliott: It does "#include "MachDeps.h"" but inside it looks pretty much what I wanted. Though I thought there were simpler examples.
04:43:51 <elliott> well, you can just use a peano representation and it becomes a fairly boring "solved problem" :P
04:44:15 <savask> Peano will waste a lot of memory.
04:44:55 <savask> I was thinking of representing them as lists of Word, just as your example does, but I think I'm too stupid to do all the work without mistakes :C
04:45:22 <bad_alloc> Hi, I'm trying to get this code to work: http://cxg.de/_7b29b8.htm  This is part of a levelorder implementation for binary trees. Why do my function calls fail but equivalent statements on the REPL work?
04:45:36 <elliott> well, if you start caring about operational concerns you might as well go all the way and make it fast enough to be usable
04:47:21 <krsrk> Thanks all, I added Read to deriving list, and readLn and later specifying the 'variable' type where I use it as MyEnum, seems to be working.
04:47:48 <savask> elliott: JHC has only small Integers, while I need arbitrary. I see no way other than writing my own Integer implementation.
04:50:34 <elliott> huh, I didn't know that
05:59:35 <Fuuzetsu> I have a ‘Ghc a’ type being used here and I have no idea where it's coming from. Hoogle and Hayoo are bringing up no hits
05:59:38 <Fuuzetsu> :i Ghc
05:59:44 <Fuuzetsu> oh, no :i
06:02:13 <Hafydd> Fuuzetsu, could it be this? http://hackage.haskell.org/packages/archive/ghc-mtl/1.0.1.1/doc/html/Control-Monad-Ghc.html
06:02:20 <rfw> hi, can someone answer a very quick question for me about curry-howard?
06:02:41 <Fuuzetsu> Hafydd: Quite possibly! Thanks.
06:02:45 <Fuuzetsu> @where justask
06:02:45 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
06:02:53 <rfw> hold on, i'm typing it :)
06:03:09 <rfw> so if i have a type data Foo = Foo A B then would it be regarded as Foo |- A /\ B since product types are equivalent to logical conjunction?
06:04:39 <rfw> so now i'm wondering if i had the type data Vector2 = Vector2 Int Int, you would express it as Vector2 |- Int /\ Int and since Int /\ Int seems to be a tautology wouldn't it just be Vector2 |- Int
06:04:58 <elliott> rfw: well, proofs can be interesting for more than what they prove, in this interpretation.
06:05:11 <elliott> in particular, Int -> Int -> Int is a pretty boring proposition. you can prove it with \a _ -> a, \_ _ -> 42, etc.
06:05:18 <elliott> but also by (+), (*) etc.
06:05:34 <elliott> you could describe a proposition as a type for which you don't care about the differences of the values
06:05:37 <Hafydd> I wouldn't call Int /\ Int a "tautology".
06:06:12 <rfw> Hafydd: but isn't Int /\ Int equivalent to Int
06:06:37 <elliott> logically, yes
06:06:38 <Hafydd> Yes, but "tautology" means it's true regardless of the truth of Int.
06:06:44 <elliott> but Int is also equivalent to simple truth, logically
06:06:46 <rfw> ah, my bad
06:07:08 <elliott> since after all, with a proposition you only care about whether it has a proof or not (i.e. the type is inhabited), really
06:07:21 <rfw> aha, i get it
06:07:23 <elliott> (of course, details of proofs are often interesting -- Curry-Howard just adds another way they can be interesting: by their computational content)
06:07:52 <rfw> it's kind of messing with my brain a little but i get the gist of it
06:08:00 <elliott> something like: (a -> c) -> (b -> c) -> Either a b -> c makes a more compelling theorem
06:08:14 <elliott> since it's something you would actually see in logic
06:11:12 <rfw> ah cool, thanks!
06:12:31 <elliott> :)
06:12:47 <elliott> rfw: ...of course, if you want to state actually interesting theorems, you tend to have to step into dependent types
06:13:05 <rfw> heh, that sounds a bit too scary for me right now
06:13:39 <elliott> all in good time :)
06:32:59 <Fuuzetsu> @src nub
06:33:00 <lambdabot> nub = nubBy (==)
06:33:03 <Fuuzetsu> @src nubBy
06:33:03 <lambdabot> nubBy eq []             =  []
06:33:03 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
06:39:03 <renke> Do you think it's risky to write my master thesis in Haskell? I mostly programmed in Java so far. I read a lot about Haskell and played around with it, but I have no real experience with it.
06:39:11 <Fuuzetsu> Why are GHC docs not on Hackage?
06:39:33 <Fuuzetsu> renke: That of course depends on what your thesis is…
06:40:00 <elliott> if you're asking #haskell about it on IRC then I'd say yes it is risky :)
06:40:16 <renke> Fuuzetsu: It includes an algorithmic part and a user interface part. The former should be no problem with Haskell.
06:40:22 <Fuuzetsu> elliott: Are you trying to say this isn't the best place for life advice?
06:40:22 <augur> renke: nothing ventured nothing gained!
06:40:56 <krsrk> http://hpaste.org/89065
06:41:14 <krsrk> why is it saying The equation(s) for `sendCoordinates' have one argument,
06:41:15 <krsrk> --    but its type `[(Int, Int)]' has none
06:41:21 <renke> elliott: To be honest, I don't know a better place to ask such a question.
06:41:24 <Fuuzetsu> krsrk: your type is wrong
06:41:35 <Fuuzetsu> :: [(Int, Int)] is just a function with 0 arguments
06:41:52 <Fuuzetsu> and you are clearly passing it ‘coordinates’.
06:41:56 <krsrk> hmm, I can't quite understand why
06:42:06 <FreeFull> krsrk: What monad is sendCoordinates in? IO?
06:42:08 <Fuuzetsu> Perhaps you want :: [(Int, Int)] -> IO ()
06:42:14 <Fuuzetsu> FreeFull: He's printing
06:43:26 <renke> I am not sure if I am able to structure a rather big projects in Haskell. That is something that usually requires a lot of experience to do.
06:43:28 <elliott> a better way to understand it: it's not a function with 0 arguments. it's not a function at all. it's just a list
06:43:32 <elliott> only functions take arguments
06:44:20 <elliott> but of course, the way you define sendCoordinates is wrong
06:44:21 <Fuuzetsu> nullary function is still a function *grumble*
06:44:24 <elliott> you define it as a function
06:44:30 <krsrk> thx, its working now, but I cant understand why its not a function, afaik everything after :: is the argument types and then after -> is the return type
06:44:50 <elliott> this is the kind of confusion promoted by everything-is-a-function thinking :)
06:44:54 <FreeFull> A function always takes exactly one parameter
06:44:55 <elliott> what comes after the :: is just the type
06:45:06 <elliott> [(Int, Int)] is the type of lists of tuples of Ints
06:45:17 <elliott> so a definition would look like sendCoordinates = [(1,2), (3,4)]
06:45:30 <elliott> if you want to take [(Int, Int)] as a parameter, then
06:45:36 <elliott> sendCoordinates :: [(Int, Int)] -> returntype
06:45:45 <elliott> which is the type of functions from [(Int, Int)]s to returntype
06:46:01 <elliott> in this case, Fuuzetsu is right, you seem to be returning an IO action because you do printing, so IO () is a good choice of return type
06:46:02 <krsrk> So, I was missing a return type
06:46:16 <Fuuzetsu> yes
06:46:34 <krsrk> though it said I was missing argument type
06:46:42 <elliott> because you gave a definition with an argument
06:46:52 <elliott> but the type is not a function type, so it doesn't take arguments
06:47:32 <geekosaur> ghc cannot read your mind, if there is one type then it is taken as the return type and ghc will report that you are missing a parameter]
06:47:59 <elliott> Fuuzetsu: (btw, have you seen http://conal.net/blog/posts/everything-is-a-function-in-haskell? it's no more true to say everything is a function than to say everything is a nested list (since you can do the same pattern: 0-nested list of a = a, 1-nested list of a = [a], 2-nested list of a = [[a]] etc.); the notion of "no arguments"/0-arity is well-defined, but it is false to say that the things it describes are functions)
06:48:06 <geekosaur> (and it is far more common to onit a parameter than to omit the return type, which is usually pretty obvious)
06:48:12 <randomclown> I often find I'm threading state using foldr. i.e. foldr (\x (state, acc)) (defaultstate, stuff) xs. Is there a better way other than using the state monad?
06:48:26 <elliott> (and I think this terminology confuses people in its inaccuracy, since it makes function types seem special somehow, rather than (a -> b) just being a regular old type when a and b are)
06:49:47 <miguelnegrao> hello
06:50:20 <miguelnegrao> I'm looking for a very simple example of a haskell program that explodes in memory usage but without consuming 100% cpu
06:50:41 <krsrk> hmm, geekosaur, I thought return type can only be after ->, but from your statement I read as if there is only "one type" given, then this is return type (even if it is not after ->)
06:51:02 <miguelnegrao> I was trying to use threadDelay, but then I don't get the memory consuption anymore...
06:51:25 <miguelnegrao> example f n = f (n+1)  main = f 1
06:51:54 <geekosaur> krsrk, if you haven't defined a function but have instead defined a value, it still has a result/return type, what it does not have are parameters (therefore parameter types)
06:52:00 <miguelnegrao> that will use 100%cpu and increase in memory fast until the operating system kills it
06:52:09 <FreeFull> miguelnegrao: Try   main = print $ length [1..]
06:52:18 <FreeFull> I'm not sure how fast it'd grow though
06:52:26 <geekosaur> krsrk, foo :: Int; foo = 5 -- return type is Int, no parameters
06:52:44 <FreeFull> Actually, that might not work
06:52:45 <elliott> krsrk: it's actually as simple as this: just like Int and [Int] are types, a -> b is a type of functions from a to b. not everything is a function. so, Int -> Int -> String is a function from Ints to functions from Ints to Strings (this is "curried", a more conventional way of saying it is (Int, Int) -> String -- a function from an Int and an Int to a String)
06:52:49 <pantsman-> is there somehwere I can grab an instance of Contravariant ((->) a) or should I just write my own
06:52:55 <elliott> krsrk: there's no special handling of "return types" or anything.
06:53:09 <elliott> the reason the return type comes after the last -> is because "a" is the input type and "b" is the return type in a -> b
06:53:29 <elliott> "foo :: ..." just means foo has the type ..., whatever it is. "foo :: Int" -- foo is an integer. "foo :: [Int]" -- foo is a list of integers. "foo :: Int -> String" -- foo is a function from integers to strings
06:54:14 <miguelnegrao> FreeFull: that will result in 100% cpu but 0% memory usage (using htop)... so I need the opposite :-)
06:54:57 <Fuuzetsu> elliott: I can't say I like that list argument at all.
06:55:12 <FreeFull> What about    main = print $ (length x, sum x) where x = [1..]
06:55:38 <krsrk> thanks, I think I got it
06:55:48 <FreeFull> Although anything simple like that is likely to use 100% cpu
06:56:12 <krsrk> great support here
06:56:14 <acube> window swap
06:56:21 <elliott> krsrk: :)
06:56:33 <kqr> i don't quite grasp lenses -- most of my usage of them have been via trial and error. i mostly find them useful to mutate lists and tuples and such, is there any good tutorial or getting started guide for this?
06:56:47 <elliott> kqr: I assume you've heard of edwardk's mammoth video?
06:56:53 <kqr> i have not
06:56:59 <ion> Yeah, watch edwardk’s talk.
06:57:02 <elliott> kqr: http://youtu.be/cefnmjtAolY?hd=1
06:57:09 <elliott> (link grabbed from the topic of #haskell-lens :) )
06:57:28 <ion> IIRC it’s in the readme as well.
06:57:30 <elliott> probably the best place to start if you want a ground-up understanding of how the lens stuff interacts (though I admit I haven't gotten around to watching it myself)
06:57:33 <miguelnegrao_> any simple way to increase memory usage, but still keep computation down ? I'm trying to troubleshoot an issue with me linux machine
06:58:17 <kqr> elliott, thanks
06:58:18 <dmwit> miguelnegrao_: Filling up memory requires your CPU.
06:58:22 <kqr> elliott, am i the only one unable to access the slides?
06:58:27 <miguelnegrao_> yes, but can I fill it slowly ?
06:58:35 <miguelnegrao_> like using 50% of one core ?
06:58:52 <dmwit> You could make it disk-limited. =)
06:58:53 <geekosaur> it's going to be easier to do that kind of thing in C than in Haskell
06:58:54 <elliott> kqr: are they on comonad.com? then nobody can access it, it's down
06:59:01 <kqr> yeah, they are
06:59:14 <dmwit> Or you could make a loop that calls threadDelay and some allocation function in alternation.
06:59:26 <geekosaur> main() { while (1) { malloc(1048576); usleep(250000); } }
06:59:48 <pantsman-> o i c, I should use the Op newtype for a Contravariant (->) a
06:59:57 <elliott> kqr: there's a copy of the video on vimeo, I think it might have easier to see slides in the video? don't have a link unfortunately
07:00:08 <kqr> no i think this is fine
07:00:10 <ion> or malloc(1000000); usleep(262144); It’s important to make one of them a power-of-two.
07:00:12 <dmwit> main = alloca (\x -> threadDelay 250000 >> main)
07:00:33 <kqr> i just wanted to glance over the slides during the intro to get a sense of how the talk is structured
07:00:50 <geekosaur> power of 2 times make less sense
07:01:39 <ion> What difference does 1048576 for malloc make here?
07:02:07 <elliott> kqr: also, the lens library has made some big advances since that talk, especially getting a solid version of isomorphisms and especially prisms (which seem to turn out to be almost as important as lenses) down, so it's not the whole story
07:02:14 <geekosaur> probably none, just habit since lalloc buckets *are* power of 2
07:02:17 <geekosaur> *malloc
07:02:24 <miguelnegrao_> geekosaur: ok, that causes the virtual memory to increase but not the (real ?) memory usage
07:02:31 <miguelnegrao_> in htop at least
07:02:32 <geekosaur> well, yes
07:02:38 <dmwit> Write a byte to each allocated block.
07:02:44 <geekosaur> the system is smarter than that. if you want to force use, write something to each block
07:03:13 <geekosaur> preferably something nonzero since the system memory manager *might* be smart enough to recognize a 0 as a no-op
07:03:17 <dmwit> In fact, you may want to allocate pages instead of megabytes...
07:03:33 <ion> *((char *)malloc(1000000)) = 42; or something
07:06:20 <geekosaur> ((char *) sbrk(1000000))[-1] = 4; /* smartassery */
07:06:54 <randomclown> geekosaur: didn't realise the was python
07:07:00 <randomclown> this*
07:07:13 <geekosaur> wat
07:07:28 <miguelnegrao_> ok main() { while (1) {  *((char *)malloc(1000000)) = 42; usleep(25); } } does what I need
07:07:33 <miguelnegrao_> thanks !
07:07:49 <randomclown> what about krenel memory overcommit?
07:09:10 * hackagebot colors 0.1 - A type for colors  http://hackage.haskell.org/package/colors-0.1 (FumiakiKinoshita)
07:09:35 <elliott> great, now haskell has support for both colours and colors
07:10:04 <geekosaur> couleurs, anyone?
07:12:24 <ion> s/while \(1\)/for (;;)/
07:19:10 * hackagebot multimap 1.2 - A multimap.  http://hackage.haskell.org/package/multimap-1.2 (JulianFleischer)
07:24:10 * hackagebot multimap 1.2.1 - A multimap.  http://hackage.haskell.org/package/multimap-1.2.1 (JulianFleischer)
07:28:39 <augur> @ask koninkje_away lets start a journal!
07:28:39 <lambdabot> Consider it noted.
07:29:10 * hackagebot null-canvas 0.2.4 - HTML5 Canvas Graphics Library - forked Blank Canvas  http://hackage.haskell.org/package/null-canvas-0.2.4 (KrzysztofSkrzetnicki)
07:35:14 <trevize_> hello fellow haskellers. I'm having trouble with working out how to properly use Data types with multiple type variables where constructors use less that all the type variables. Would anyone be able to point me to examples where such types are used with classes (and type constrains in the classes)?
07:37:24 <dwcook> @src Functor
07:37:24 <lambdabot> class  Functor f  where
07:37:24 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
07:37:51 <dwcook> trevize_, f is of kind * -> *, since it needs to be applied to a type in the body of the class
07:37:59 <Rarrikins> trevize_: Nothing.
07:38:12 <Rarrikins> Oh, classes.
07:38:32 <jonkri> How do I add a "Distribution" to a Cabal/Hackage package?
07:38:43 <dwcook> @src Functor Const
07:38:43 <lambdabot> Source not found. Are you on drugs?
07:38:51 <dwcook> Hmm, I forgot how to find instance declarations
07:38:56 <dwcook> @src instance Functor Const
07:38:56 <lambdabot> Source not found. You untyped fool!
07:39:06 <Eelis> what's the deal with lambdabot being so rude?
07:39:13 <dcoutts_> jonkri: not sure what you mean, what do you want to do exactly?
07:39:25 <dcoutts_> @slap lambdabot
07:39:25 * lambdabot slaps lambdabot with a slab of concrete
07:39:46 <dwcook> trevize_, http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#g:3
07:39:54 <jonkri> dcoutts_: Some Hackage pages provide links to distributions, such as NixOS and Debian. However, when I open the Cabal file, there is no reference to the distributions there as far as I can see.
07:40:23 <dcoutts_> jonkri: oh right, that's the distributions themselves that provide that info
07:40:36 <jonkri> dcoutts_: I see. Thanks!
07:41:38 <trevize_> dwcook: thanks, I will try to follow that through. I keep bumping into ambigous type problems
07:42:15 <dwcook> trevize_, you could post code and let the channel take a crack at it.
07:43:05 <trevize_> yep, one sec
07:43:09 <latermuse> what does this mean and how can i fix it? GHCi runtime linker: fatal error: I found a duplicate definition for symbol _fps_count
07:48:20 <supki> latermuse: error message should describe why that may happen
07:48:55 <meretrix> What persistence package would you recommend for an application based on immutable events?  All events will simply be recorded during runtime and some of them will be replayed at startup.  There will never be any querying of state.
07:48:58 <supki> (I mean the part you omitted)
07:49:12 <latermuse> thanks supki
07:50:06 <meretrix> acid-state looks interesting, but seems to be too focused on managing state.
07:50:21 <elliott> it's in the name :)
07:50:37 <meretrix> yes, that does give it away..
07:51:21 <hpc> meretrix: acid-state does store state, but you can also see it as storing a stream of events
07:51:30 <hpc> meretrix: where events are encoded as transactions
07:52:24 <hpc> if you look through the docs, you'll notice that acid-state has TH to turn Query and Update actions into data types
07:52:49 <hpc> and those data types are what gets stored between "checkpoints"
07:52:56 <meretrix> Ok, I'll take another look.
07:53:38 <trevize_> dwcook: http://pastebin.com/x56ZV9GH
07:53:41 <meretrix> I'm also concerned about performance. I want separate any persistence overhead from the main thread.
07:53:50 <mauke> The paste x56ZV9GH has been copied to http://hpaste.org/89068
07:54:34 <Taneb> How's AMP going
07:54:35 <hpc> acid-state is quite fast, but not as fast as something like mongodb
07:54:37 <trevize_> like 66 is where I get the problem http://pastebin.com/pUJ0bujF
07:54:42 <mauke> The paste pUJ0bujF has been copied to http://hpaste.org/89069
07:54:59 <hpc> because acid-state blocks on writes as part of observing acid properties, while mongodb doesn't really care :P
07:55:13 <hpc> depending on the application, you might not need full acid
07:55:24 <meretrix> Yeah, I don't need acid at all.
07:55:25 <trevize_> I sort of understand what it means, but not each to fix it property
07:56:02 <meretrix> I'm storing financial market data and trades.
07:56:36 <dwcook> trevize_, what's the actual error message you're getting?
07:57:14 <trevize_> dwcook: I put it into another paste bin http://pastebin.com/pUJ0bujF
07:57:15 <mauke> The paste pUJ0bujF has been copied to http://hpaste.org/89069
07:57:55 <dwcook> trevize_, sounds like you just made a typo. You want to write (BuiltString a, BuiltString b)
07:58:01 <dwcook> Instead of (BuiltString a, BuiltString a)
07:59:24 <trevize_> dwcook: sorry, I did that while extracting the code: the error is still there http://pastebin.com/dEfNXK06
07:59:29 <mauke> The paste dEfNXK06 has been copied to http://hpaste.org/89070
08:00:41 <dwcook> trevize_, okay, the problem is it doesn't know enough about b1's type to know which instance to use.
08:02:08 <dwcook> It's suggesting that you limit it to some more specific type.
08:02:31 <trevize_> where do I give the specification?
08:02:57 <dwcook> In the type signature would work.
08:03:37 <dwcook> Oh, or in this case the instance declaration.
08:04:01 <dwcook> Hmm, actually I think I am confused myself.
08:05:24 <trevize_> I'm confused because I'm not using the second type with 'toByte (FrontPad count str)'
08:05:38 <trevize_> I'm not sure why it's looking for the type of b in this case
08:05:55 <Aetherspawn> mapM_ (mapM ....) .... using 1 function in C
08:05:57 <Aetherspawn> http://puu.sh/35Ui0/6a1d15f54b.png
08:07:51 <Enigmagic> meretrix: i recommend a binary stream of some sort, one per day. no need for a database. i use protocol buffers to encode events. if you need to do range queries you might look at LevelDB's SST table builder, which makes it easier to do index scans.
08:12:23 <meretrix> Enigmagic: I've thought about a simple binary format, but I would like to be able to query the data for later historical analysis.  I'll check out the table builder.
08:13:02 <dwcook> trevize_, I just took another look at it, and this time I noticed the problem. You don't have an instance for BuiltString that is as general as possible, but your (BuiltString b) constraint is. You need to constrain it to something for which you have a BuiltString instance.
08:13:55 <Enigmagic> meretrix: regular database are a poor fit for large volumes of time series data. specialized products like kdb+ are much better but also $$$$.
08:15:31 <trevize_> dwcook: Sorry, I'm not following. which type am I missing? Do I need to have 'instance BuiltString a where ...' ?
08:15:32 <meretrix> My data isn't huge yet.  I do use kdb at work though. Q is beautiful.
08:17:24 <dwcook> trevize_, I would say not. But it might be worth asking someone else at this point. I think I may have reached the end of my usefulness for this problem.
08:18:08 <trevize_> ok, well many thanks for taking a look.
08:18:29 <Enigmagic> meretrix: then split up your work. stream to a binary file during market hours, load into your analytics solution in the evening.
08:24:30 <supki> trevize_: instance (BuiltString a, BuiltString a) => BuiltString (PadUnit a b) where  looks strange
08:24:35 <latermuse> hey can you guys check out this function and tell me if theres any easier way to do it?
08:24:40 <latermuse> http://hpaste.org/89071
08:25:00 <supki> trevize_: I think you mean (BuiltString a, BuiltString b) ?
08:25:07 <trevize_> supki: yes, I had a typo
08:25:23 <supki> oh, I see
08:25:39 <trevize_> supki: but it complains about b1 being ambiguous
08:26:02 <trevize_> when the Filler case is being evaluated
08:28:11 <latermuse> guess not :)
08:28:46 <supki> trevize_: okay, Filler :: PadUnit Char b, what b should it peek?
08:28:50 <randomclown> @pl \x y -> (f x) `union` (f y)
08:28:50 <lambdabot> (. f) . union . f
08:29:16 <randomclown> :w
08:29:26 <supki> trevize_: sorry, Filler gcount ('C' :: Char)) :: PadUnit Char b
08:30:07 <trevize_> supki: it is intended that b is any built string that it can covert to bytes
08:30:27 <supki> yeah, but how ghc will know that?
08:30:58 <trevize_> thought the constraints tell it that
08:32:31 <supki> trevize_: no, constraints tell that (FrontPad count str) :: PadUnit a b, where both a and b are instances of BuiltString
08:32:43 <supki> trevize_: Filler has unrelated b in its type :)
08:33:20 <latermuse> randomclown: thanks :)
08:34:25 <randomclown> latermuse: I think you have the wrong person
08:34:32 <trevize_> so the declaration of filler: Filler Integer a, doesn't require b. Kind of how 'Either a b'. How do I go around this? because I want to use constructors with many types and some with less
08:34:41 <latermuse> randomclown: well you answered my questions anyways hehe
08:35:23 <trevize_> supki: am I not able to not use types I constrained? Is my only option to create another data type?
08:36:58 <supki> trevize_: you can annotate filler to specify b to some type that has that instance, like  (Filler gcount ('C' :: Char)) :: PadUnit Char Char)
08:37:49 <supki> I think there could also be trick with -XScopedTypeVariables to use that b from constraints too
08:39:24 <randomclown> > liftM2 (&&&) `join` succ
08:39:25 <lambdabot>   No instance for (GHC.Enum.Enum (a0 b0 c0))
08:39:25 <lambdabot>    arising from a use of `e_12'
08:39:25 <lambdabot> ...
08:39:35 <randomclown> > (liftM2 (&&&) `join` succ) (1,1)
08:39:37 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
08:39:37 <lambdabot>    arising from a use of `Control...
08:39:53 <trevize_> supki: is this correct?     toByte (FrontPad count str) = L.append (toByte ((Filler gcount 'C') :: (PadUnit Char Char)) content... I'm getting a syntax error
08:40:13 <trevize_> supki: paren problems
08:40:55 <randomclown> > (liftM2 (***) `join` succ) (1,1)
08:40:56 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
08:40:56 <lambdabot>    arising from a use of `Control...
08:41:03 <randomclown> why doesn't that work?
08:41:44 <randomclown> > (succ *** succ) (1,1)
08:41:45 <lambdabot>   (2,2)
08:41:46 <randomclown> works fine
08:41:47 <trevize_> supki: fixed it :) I may have to rethink my construct
08:41:56 <trevize_> supki: thank you for you help, I understand it now
08:43:33 <monochrom> I don't know. why should that work?
08:44:00 <monochrom> I'm too lazy to calculate the type. but you should.
08:44:11 <DarkFox> Hmm…
08:44:46 <DarkFox> Anyone here know how I can run a function through monadic forwarding on a list?
08:44:57 * DarkFox shouldn't have taken the break from haskell… forgotten so much. 
08:44:59 <DarkFox> :(
08:45:54 <DarkFox> What come to mind. >>= return fmap map myfun -- Unsure how to put them together…
08:46:07 <hpc> DarkFox: use the types, luke
08:46:25 <DarkFox> Luke?
08:47:07 <monochrom> "use the ___, Luke" is a Star Wars reference
08:47:15 <DarkFox> Oh
08:47:23 <DarkFox> [Item String]
08:47:41 <DarkFox> Need to work on the String's each.
08:47:41 <monochrom> but I don't understand the question
08:48:04 <monochrom> it's too abstract
08:48:33 <DarkFox> [Item String] >>= something myFunc where myFunc = unlines . takeWhile (/= "<-- MORE -->") . lines
08:49:33 <DarkFox> monochrom: How would I go about running that function on the list?
08:50:38 <monochrom> what is an example of [Item String]?
08:50:59 <DarkFox> http://hub.darcs.net/DarkFox/DarkFox-blog/browse/site.hs
08:51:18 <monochrom> which line should I look at?
08:51:40 <DarkFox> around 60s
08:51:46 <mjrosenb> is sortBy stable?
08:51:57 <monochrom> yes
08:52:25 <monochrom> ok I asked for an example of [Item String] and I am not seeing one near 60
08:52:36 <randomclown> monochrom: well liftM2 (function) `join` arg1 usually passes arg1 as the first two arguments. Not sure why it doesn't like (***)
08:52:58 <DarkFox> monochrom: It's the string / blog post. I'm not sure how I could give an example of it.
08:53:21 <monochrom> is it "hello" or is it ["hello", "kitty"]?
08:53:36 <DarkFox> [Item "Hello", Item "Kitty"]
08:54:14 <Michael__> Is there a way to partially overide the deriving mechanism in an algebraic data type? For example, if I want to change how to show a single constructor, but the rest can be derivived normally?
08:54:31 <sm> \Item s -> Item $ blahblah s ?
08:55:04 <DarkFox> … I guess kinda like that; but on the list of Item
08:55:06 <sm> \(Item s) -> ..., actually
08:55:17 <salvociro> List!
08:55:48 <monochrom> ok, what monad is it?
08:56:19 <randomclown> monochrom: (->), maybe arrow is messing with it
08:56:28 <DarkFox> monochrom: Hakyll's compiler monad
08:56:48 <DarkFox> http://jaspervdj.be/hakyll/reference/Hakyll-Core-Compiler.html
08:57:57 <DarkFox> Acturally
08:58:10 <sm> jaspervdj will know
08:58:13 <DarkFox> I guess it'd be better to run when I'm saving the snapshot content on line 36
08:58:34 <DarkFox> sm: Indeed, and this is around his timezone now.
08:58:50 * DarkFox was going to ask eariler but he didn't reply to something else I asked.
08:58:59 <sm> send him coffee/chocolate/toys and see what happens
08:59:07 <DarkFox> Heh
08:59:24 <sm> I dunno what he likes. A skateboard ?
09:00:11 <monochrom> ok, so you have [Item "hello", Item "kitty"]. 2 string. but unlines . takeWhile (/= "<-- MORE -->") . lines wants just 1 string. should I combine 2 strings into 1 or what?
09:00:47 <monochrom> to be frank I'm pretty sure jaspervdj would just want a well-defined question like I do
09:01:08 <sm> no, no he'll just know I tell you
09:01:10 * DarkFox thinks he got it
09:01:41 <DarkFox> Shit
09:01:45 <DarkFox> Kinda
09:01:46 <DarkFox> Lol
09:02:10 <fruitFly_> http://ideone.com/IlQ7Ae
09:03:11 <fruitFly_> what is non-exhaustive about http://ideone.com/IlQ7Ae ?
09:03:57 <geekosaur> doesn't handle empty string
09:04:34 <dwcook> base64toIndex seems to lack Nothing as well
09:05:03 <geekosaur> note "but I know it can't be empty" is incorrect because it's a runtime error, meaning that it *did* get an empty string
09:05:33 <DarkFox> >>= saveSnapshot "content" . fmap dropMore >>=  -- Need to have the same unmodified data on each side; any suggestion?
09:06:59 <fruitFly_> geekosaur: it will NEVER reach an empty string, does it always just have to have a an empty string arg?
09:07:14 <geekosaur> fruitFly, again: it is a runtime error
09:07:26 <geekosaur> it DID, unequivocally, get something the pattern does not match
09:07:48 <geekosaur> it is not a compiler warning. look at your own paste, next to "result:"
09:07:58 <geekosaur> in bright red even
09:08:25 <geekosaur> if you think it can't possibly get that thn you think wrongly and may have a logic error elsewhere
09:08:47 <fruitFly_> geekosaur: aah k ... i will look at it ;)
09:09:01 <fruitFly_> good to pay attention to run time, compilation etc ... heck.. i'm learning
09:09:05 <geekosaur> but the only pattern you are not handling is empty string and the pattern match is throwing a runtime error so it must be getting an empty string
09:10:02 <fruitFly_> geekosaur: dwcook  in my base64ToIndex function do I need a case for Nothing as well? I know it elemIndex HAS to evaluate to an Int here
09:12:10 <dwcook> fruitFly_, not necessarily. I was just pointing out that it too is non-exhaustive.
09:12:14 <geekosaur> fruitFly, I would probably catch it just to produce a better error message (e.g. Nothing -> error "Invalid base64 content")
09:12:58 <geekosaur> you are doing that, but at the wrong place since you'll hit a non-exhaustive pattern error before you reach the point where you check for it, as currently coded
09:13:01 <fruitFly_> dwcook: but I have another measure for that alread in base64Valid ... and evaluating nothing in main
09:13:38 <geekosaur> hm, ok, spre-pass to validate
09:13:42 <rrc7cz> in HXT, what is the purpose of processChildren? seems to me "/> addAttr …" would have the same effect as "processChildren (addAttr …"
09:13:44 <geekosaur> not sure that's the best way to do it
09:16:37 <geekosaur> btw, looks to me like the problem is you are expecting base64 strings to end with = but your test string doesn't
09:18:01 <Luke_> does anyone know if haskell has a way to know what exceptions will be thrown from a given function?
09:18:13 <Luke_> also, has anyone ever used fluentd for error logging from haskell?
09:19:56 <jmcarthur> Luke_: you could define a data type with different constructors for each exception and use it with Either
09:20:21 <Luke_> jmcarthur: No i mean detect if another library throws exceptions.
09:20:28 <jmcarthur> statically?
09:20:34 <Luke_> jmcarthur: i'm not using them myself. but, for example, if you don't know head throws
09:20:36 <Luke_> yeah statically
09:20:47 <jmcarthur> yeah that isn't going to be doable
09:20:52 <jmcarthur> there is no type information for that
09:21:05 <jmcarthur> head doesn't throw an exception. it's just partial
09:21:08 <enthropy> @hackage explicit-exception if people used this...
09:21:08 <lambdabot> http://hackage.haskell.org/package/explicit-exception if people used this...
09:21:12 <jmcarthur> (it's kind of an exception if you squint i guess)
09:21:26 <jmcarthur> (and is literally implemented as an exception, but you aren't supposed to think of it that way)
09:22:26 <Guest95809> Should I learn Haskell?
09:22:42 <Eelis> depends
09:22:45 <Luke_> jmcarthur: interesting. how can I use this? turn exceptions into explicit exceptions somehow?
09:22:57 <jmcarthur> Luke_: use what?
09:23:11 <Guest95809> Eelis: ok, I'll learn me it then
09:23:16 <Eelis> splendid
09:23:18 <Taneb> @where lyah
09:23:19 <lambdabot> http://www.learnyouahaskell.com/
09:23:19 <Luke_> jmcarthur: oh i meant enthropy
09:24:03 <jmcarthur> Luke_: whatever it is, it won't magically turn exceptions in other libraries into types
09:24:28 <enthropy> @hackage spoon is almost magic
09:24:28 <lambdabot> http://hackage.haskell.org/package/spoon is almost magic
09:24:29 <Luke_> jmcarthur: I just meant i was referencing the link enthropy mentioned.
09:24:50 <Luke_> holy awesome. how does that work?
09:24:59 <enthropy> yeah, explicit-exception doesn't help you for libraries that weren't written with it
09:25:16 <jmcarthur> Luke_: don't use spoon, btw
09:25:19 <jmcarthur> just don't
09:25:30 <Luke_> it looks like a joke =)
09:25:40 <jmcarthur> it's not a joke, but it's not meant to be taken seriously
09:25:57 <jmcarthur> (it has specific use cases in mind, to get around limitations of certain other libraries)
09:27:11 <jmcarthur> e.g. a library that does only provides a partial version of some important function such that the partiality comes in the form of some "catchable" exception at a low level you aren't supposed to be aware of in pure code
09:27:38 <Luke_> yeah
09:31:14 <monochrom> "use the spoon, Luke_" :)
09:31:25 <Luke_> ;-P
09:34:08 <Luke_> anyway thanks enthropy and jmcarthur
09:34:27 <Luke_> just wanted to confirm my suspicions that exceptions were (sadly) not statically detectable
09:34:50 <Luke_> back to my other question: anyone use any type of error/log collection mechanism?
09:34:59 <Luke_> more of an operational question. but something like Fluentd
09:35:22 <Luke_> i see there are some fluentd libraries on hackage but i'm not sure what the alternatives are
10:17:32 <simon> I've got a happy-generated parser that makes GHCI run out of memory and crash. is that common?
10:17:49 <simon> GHC can compile it.
10:18:46 <hpc> likely an optimization is changing the asymptotic efficiency of your parser
10:19:39 <nicoo> simon: And does the generated binary run as expected ?
10:20:50 <simon> nicoo, yes.
10:20:59 <simon> hpc, ok.
10:22:02 <hpc> sometimes the optimizations can mask a poorly written function that leaks space
10:22:44 <hpc> i don't really do much with optimization and profiling though
10:22:57 <hpc> you should probably paste your code and see if someone else has a better idea
10:22:59 <hpc> @where hpaste
10:22:59 <lambdabot> http://hpaste.org/
10:23:03 <jmcarthur> yeah i feel like the strictness analyzer is probably the most apparently magical of ghc's optimizations, sometimes
10:23:36 <jmcarthur> in the sense that it actually optimizes away a certain class of bugs... sometimes
10:23:57 <jmcarthur> if it was reliable i wouldn't even call them bugs i guess
10:24:04 <simon> hpc, the happy parser is huge.
10:24:28 <simon> is there a way I can compile something using GHCI that depends on it, but where it just uses a precompiled version of it?
10:24:54 <jmcarthur> once you compile a module you can load the object file in ghci
10:25:05 <jmcarthur> alternatively, there is a setting for ghci that makes it compile before running
10:25:25 <jmcarthur> the latter even compiles expressions you type in at the prompt
10:25:27 <simon> ah, :load rather than :m +
10:25:49 <jmcarthur> you may need to specify optimization levels for the latter
10:39:51 <meretrix> Is there any way to simplify "toRow (Quote a b c d) = [toField a, toField b, toField c, toField d]" with some kind of mapping over Quote?
10:40:33 <meretrix> Where a,b,c,d are members of a ToField class.
10:40:35 <jmcarthur> meretrix: do a b c and d all have the same type? even better, is your data type parameterized on that type?
10:41:13 <skuggi> What do I import to get plusInt64# and so on?
10:41:16 <meretrix> jmcarthur: They could be of different types.
10:41:27 <jmcarthur> meretrix: what is the definition of the data type that has the Quote constructor?
10:41:57 <jmcarthur> skuggi: GHC.Prim, iirc
10:42:24 <meretrix> jmcarthur: Something like "data Quote = Quote { a :: String, b :: Double, c :: Int, d :: UTCTime}"
10:43:10 <jmcarthur> in that case i can't think of anything especially simpler than what you have
10:43:58 <AglG> hi everybody
10:44:07 <meretrix> Ok, thanks.
10:44:53 <skuggi> jmcarthur: doesn't work
10:45:06 <jmcarthur> skuggi: what do you mean doesn't work?
10:45:46 <skuggi> jmcarthur:  Not in scope: `plusInt64#'
10:46:35 <Hafydd> @pl \x -> map (\f -> toField (f x)) [a,b,c,d]
10:46:36 <lambdabot> flip map [a, b, c, d] . (toField .) . flip id
10:47:04 <jmcarthur> skuggi: google?
10:48:51 <Hafydd> @pl \f -> toField (f x)
10:48:51 <lambdabot> toField . ($ x)
10:49:10 <Hafydd> toRow x = map (toField . ($ x)) [a,b,c,d]
10:49:30 <jmcarthur> skuggi: GHC.IntWord64 apparently
10:49:51 <jmcarthur> Hafydd: that won't work becase a,b,c,d have different types
10:50:04 <skuggi> jmcarthur: yeah, i tried that, and that doesn't work either
10:51:23 <jmcarthur> skuggi: i guess that one is only for 32 bit machines
10:55:57 <Hafydd> Curses.
10:56:10 <skuggi> jmcarthur: oh, i see
10:56:29 <skuggi> that's weird.
10:57:00 <skuggi> Would have been better to keep Int 32-bit and always have Int64, IMO.
10:57:50 <skuggi> Int64# rather
10:59:58 <jmcarthur> Int was never defined to be 32 bit
11:00:14 <jmcarthur> skuggi: Int is only defined as having "at least 31 bits" or something like that
11:00:17 <shachaf> jmcarthur: Well, it was, in 32-bit GHC.
11:00:32 <Fuuzetsu> Is there a way to find out where I got a module from? I have a ‘Panic’ module and I have no idea how it got on my system.
11:00:36 <shachaf> skuggi: In GHC's implementation, an Int32 or Int8 takes a machine word to represent.
11:00:39 <skuggi> jmcarthur: what shachaf said. :)
11:00:42 <shachaf> (I mean, even unboxed etc.)
11:00:55 <skuggi> shachaf: even in an array?
11:01:04 <skuggi> unboxed array i mean
11:01:13 <shachaf> Unboxed arrays do something special.
11:01:22 <shachaf> They handle their own storage in their own way.
11:01:25 <jmcarthur> skuggi: we have Int32 and Int64 for that anyway. i'm fine with Int being just whatever is native
11:02:09 <skuggi> jmcarthur: yeah, i guess. it just causes problems for me right now, so i don't like it :P
11:02:23 <jmcarthur> what is your problem?
11:03:14 <skuggi> I'm generating haskell code for an EDSL and i'm generating code with primitive types
11:03:39 <skuggi> EDSL for array stuff
11:03:44 <skuggi> similar to Repa
11:04:17 <jmcarthur> ah
11:07:44 <merijn> jmcarthur: At least 27 bits
11:07:53 <merijn> In Haskell98, at least
11:11:34 <jmcarthur> that's not many bits
11:11:53 <jmcarthur> > 2^27
11:11:55 <lambdabot>   134217728
11:13:55 <geekosaur> Fuuzetsu, "ghc-pkg find-module Panic"?
11:14:18 <merijn> jmcarthur: GHC has 31 or 32 bit Int, though
11:15:15 <shachaf> 30, isn't it?
11:15:41 <geekosaur> 32, I think; ghc uses a separate constructor "field" instead of stealing bits
11:15:55 <shachaf> I mean Haskell98.
11:16:13 <geekosaur> I thought h'98 was 31, but dont recall
11:16:38 <merijn> shachaf: I remember 27 bits after a similar discussion in here earlier
11:17:15 <merijn> Answer on SO: "The Haskell language definition states that the Int type has to be at least 28 bits wide. There are other compilers/interpreters that use this property to boost the execution time of the resulting program."
11:17:16 <shachaf> Fortunately the Report is one of those things you can look at. :-)
11:17:24 <merijn> shachaf: I'm to lazy :p
11:17:33 <shachaf> "The standard numeric types are listed in Table 6.1. The finite-precision integer type Int covers at least the range [ - 2^29, 2^29 - 1]."
11:17:33 <geekosaur> yeh, I'm actualy poking
11:17:52 <shachaf> So, 30 bits.
11:18:10 <shachaf> Can't always trust SO.
11:19:17 <shachaf> To be fair, an answer with more points to the same question is correct. You scrolled all the way to the last, 0-point answer.
11:20:42 <merijn> "last" being 3rd, where the 1st mentions no bits and the 2nd one isn't sure either, anyway I concede that the report probably knows better :p
11:21:23 <Fuuzetsu> geekosaur: Brilliant, thanks.
11:28:09 <phamiltiz> I want to code a script that can scan through a log, and identify objects that occur X or more times. For example, it scans a log and finds objects that occur 14 or more times.
11:28:31 <phamiltiz> At time of scan, the log will be abou 2-3 thousand lines. The log is a voting log for a Minecraft server. Here's a log sample;  Code: Vote (from:minestatus username:jamesus address:75.109.**.*** timeStamp:2012-04-30 20:12:31 -0700)
11:29:01 <phamiltiz> I want to scan the whole
11:29:04 <phamiltiz> Log
11:30:25 <dwcook> phamiltiz, split the log into an array of strings. Use an object whose keys will be those strings. Iterate over the array, adding 1 to the associated value for the string. Then iterate over the object, display the keys with an associated value of X or more.
11:30:36 <phamiltiz> I want to find repeats in the username, eg. a username that occurs more then 14 times. Here's a 30 line sample: http://pastebin.com/uwbmWGSz
11:30:39 <mauke> The paste uwbmWGSz has been copied to http://hpaste.org/89073
11:31:05 <dwcook> Ah, so your "object" is not the entire line
11:31:09 <dwcook> Still doable in a similar fashion
11:31:29 <dwcook> Do you want, given that the username appeared X or more times, all the lines on which it appeared?
11:31:50 <phamiltiz> http://pastebin.com/1FN9A7HS
11:31:56 <mauke> The paste 1FN9A7HS has been copied to http://hpaste.org/89074
11:31:56 <phamiltiz> I did that in perl
11:32:13 <phamiltiz> But I would like to see a haskell implementation
11:32:24 <dwcook> Woops, I accidentally tabbed over one. Thought I was in JavaScript. Fortunately the algorithm I gave was fairly general :P
11:32:52 <mekeor> :D
11:32:55 <enthropy> it'd be nicer to do it with a Data.Map
11:33:22 <phamiltiz> http://pastebin.com/jv19y9xv
11:33:24 <mauke> The paste jv19y9xv has been copied to http://hpaste.org/89075
11:33:30 <phamiltiz> That's the output of the perl
11:33:51 <phamiltiz> (Which is what I want, but in haskell)
11:34:32 <mekeor> phamiltiz: what's your question? :D
11:35:13 <phamiltiz> To see a haskell implementation of my perl script
11:35:55 <hpc> main = system "./your_script.pl" -- :D
11:35:56 <leino> Hello all. Quick HaskellDB question: how to batch-insert many rows at a time? (I did find the 'insert' function, but it seems to be only for inserting single rows)
11:36:53 <phamiltiz> hpc, that is just running my perl script
11:36:56 <merijn> phamiltiz: How much are you paying?
11:37:16 <phamiltiz> I thought haskell would be more efficient
11:37:23 <mekeor> phamiltiz: i'm better and cheaper than merijn!
11:37:33 <merijn> mekeor: Cheaper, maybe...
11:37:37 <mekeor> :D
11:37:50 <phamiltiz> Cheaper code
11:38:25 <merijn> The point I was subtly trying to make is that coming into a channel and saying "implement this code for me" is a bit rude...
11:38:55 <enthropy> leino: you can mapM the insert if performance doesn't matter
11:38:58 <merijn> I'm pretty sure people wouldn't ind giving you pointers and helping you when you get stuck doing it yourself, but that's something different from demanding someone else do it
11:38:59 <phamiltiz> I was just asking if anyone would show me a haskell implementation of it
11:39:36 <Fuuzetsu> phamiltiz: I doubt there's a ready-made one which means someone would have to write it first.
11:39:40 <phamiltiz> Mainly because I was told haskell was more efficient
11:40:07 <enthropy> phamiltiz: get the person who told you it's more efficient to do it
11:40:44 <phamiltiz> It was someone on irc
11:40:52 <phamiltiz> I do not even remember his name
11:41:06 <leino> enthropy: yeah, I thought about that, but I find it surprising that I couldn't find a way to do "insertMany", like in HDBC for instance
11:42:14 <mekeor> phamiltiz: does your perl-script do the job? yes -> use it. no -> learn haskell and write your own. (#haskell might help you at concrete implementation problems.)
11:42:39 <phamiltiz> My perl script does the job
11:43:20 <mekeor> okay, then just forget the guy from irc whose name you already forgot and use your perl script :)
11:43:47 <phamiltiz> Perl
11:43:53 <mekeor> i don't see any problem here...
11:44:15 <phamiltiz> Could it be done shorter in haskell?
11:44:55 <mekeor> why shorter?  how large is the perl-code? gigabytes?  dude, it doesn't matter....
11:51:22 <kartlos> I've been playing with Scala a little bit, I'm kinda liking the Scala worksheets, it's basically a REPL that works on a complete file instead of line by line. I was wondering whether something like that is available for Haskell?
11:51:26 <jmcarthur> shorter code is often easier to understand
11:51:45 <phamiltiz> Exactly
11:52:00 <jmcarthur> kartlos: i don't know anything about scala worksheets. we have a repl, but probably not what you mean
11:52:26 <jmcarthur> kartlos: i'm imagining worksheets are something like coqide, if you know what this?
11:52:27 <merijn> kartlos: You can just ":l filename.hs" in ghci to load the entire file
11:52:32 <jmcarthur> *what that is
11:52:39 <phamiltiz> Please show me
11:52:49 <merijn> kartlos: And use ":r" to reload
11:52:55 <kartlos> wait I'll look for an example/screenshot of worksheets
11:53:14 <alexander__b> lambdabot: > Empty
11:53:24 <alexander__b> > Empty
11:53:26 <lambdabot>   Not in scope: data constructor `Empty'
11:53:26 <lambdabot>  Perhaps you meant one of these:
11:53:26 <lambdabot>    ...
11:53:32 <jmcarthur> kartlos: or agda has something i like even more, which is working with "holes" in your code (and this with editor support should in theory be coming soon for haskell, but i don't know who's working on it or what progress has been made)
11:53:43 <kartlos> http://darknightelf.files.wordpress.com/2012/09/scalaide_worksheet1.png
11:53:44 <alexander__b> right. why does learnyouahaskell do that and it evaluates to "Empty"
11:54:13 <jmcarthur> kartlos: can you go back and edit history and have it update everything after that point?
11:54:15 * hackagebot handa-gdata 0.6.2 - Library and command-line utility for accessing Google services and APIs.  http://hackage.haskell.org/package/handa-gdata-0.6.2 (BrianBush)
11:54:16 <kartlos> as you can see in the screenshot, you type code and the evaluation of that code is shown on the right
11:54:42 <Fuuzetsu> jmcarthur: hasn't there been a post or something recently about working with holes in Haskell?
11:54:45 <jmcarthur> kartlos: i don't think we have anything like that in haskell
11:54:59 <jmcarthur> Fuuzetsu: that was more like simulated holes rather than proper holes, if you mean those screencasts
11:55:05 <alexander__b> oh rite figured it out.
11:55:07 <dmwit> alexander__b: Perhaps LYAH defined a data type with an Empty constructor.
11:55:08 <kartlos> jmcarthur: too bad, seems like a nice alternative for single line REPL's
11:55:21 <merijn> kartlos, jmcarthur: Lamdu! :p
11:55:24 <alexander__b> dmwit: yeh forgot to :w in vim before I :r in ghci
11:55:26 <Fuuzetsu> jmcarthur: Yeah, it was screencasts. Yeah, they weren't Proper Holes™ but I thought it was worth a mention.
11:55:28 <jmcarthur> kartlos: it's pretty easy to load haskell modules into the repl
11:55:36 <merijn> That's mostly a joke, Lamdu is nowhere near production ready :p
11:56:22 <jmcarthur> phamiltiz: show you what?
11:56:56 <kartlos> jmcarthur: it's easy to load modules in the REPL, but in the worksheet concept you have real-time evaluation whenever you write/change code
11:57:15 <kartlos> merijn: Lamdu? :-)
11:57:36 <jmcarthur> kartlos: sure, i'm not saying anything about this being just as good... just that it's "pretty good" already
11:57:44 <phamiltiz> jmmcarthur, what?
11:57:50 <jmcarthur> phamiltiz: "Please show me"
11:58:04 <jmcarthur> phamiltiz: i was disconnected for a bit, so if you said something before that, i missed it
11:58:19 <jmcarthur> phamiltiz: i just saw the stuff about shorter code
11:58:41 <merijn> kartlos: It's a structural editor, but it's very much "work in progress" and not production ready, so it was mostly a joke
11:59:00 <merijn> kartlos: The demo is pretty neat, though!
11:59:15 <kartlos> merijn: interesting, is the development active?
11:59:20 <merijn> Yes
11:59:37 <merijn> Man, I should charge Peaker and thoughtpolice PR fees for selling their projects for them :p
11:59:42 <kartlos> nice, I'll take a look
12:00:00 <merijn> kartlos: https://github.com/Peaker/lamdu
12:00:03 <phamiltiz> phamiltiz http://pastebin.com/v1kbjhBS
12:00:05 <mauke> The paste v1kbjhBS has been copied to http://hpaste.org/89076
12:00:15 <kartlos> merijn: thanks
12:00:15 <phamiltiz> phamiltiz Input: http://pastebin.com/uwbmWGSz
12:00:16 <mauke> The paste uwbmWGSz has been copied to http://hpaste.org/89073
12:00:28 <phamiltiz> phamiltiz My perl script produces this output: http://pastebin.com/pnpsUgu5
12:00:30 <mauke> The paste pnpsUgu5 has been copied to http://hpaste.org/89077
12:00:37 <b2coutts> Hi, I want to learn haskell, and am not sure which tutorial to use. Most of my programming experience is evenly divided between C++ and scheme, and I have a math background. Which tutorial would be best for me?
12:00:38 <phamiltiz> Can it be made shorter in haskell
12:00:47 <hpc> @where lyah
12:00:48 <lambdabot> http://www.learnyouahaskell.com/
12:00:49 <hpc> boccato: ^
12:00:54 <hpc> b2coutts: rather
12:00:57 <jmcarthur> probably
12:01:29 <merijn> b2coutts: I think LYAH is best, you might have some success with RWH if you're already a decent functional programmer, but I think it glosses over some simple things
12:01:56 <tabemann> I found LYAH covered the basics better than RWH myself
12:01:59 <merijn> b2coutts: Personally I think LYAH where you just speed through the easy bits is the best bang for the time invested
12:02:09 <hpc> RWH is generally more useful as a reference
12:02:17 <b2coutts> merijn: can rwh be read if I don't understand anything about haskell, or would I need to go through a basic tutorial first?
12:02:21 <hpc> go through LYAH, make sure to have a specific program in mind that you want to make
12:02:22 <boccato> hpc: ^.^
12:02:31 <hpc> and use RWH as a reference to learn specific libraries
12:02:31 <geekosaur> RWH is more of an intermediate book, although it includes some beginner stuff
12:02:40 <hpc> the later chapters are very good at getting into specific details
12:03:18 <geekosaur> for a beginner it's better to go with LYAH, then proceed to RWH to learn how to turn a basic knowledge of Haskell into a working knowledge of how to use it effectively
12:03:21 <merijn> b2coutts: It covers the intro, but it glosses over some useful things. I usually recommend LYAH first, then RWH from like chapter 5 for real world examples
12:04:06 <monochrom> The Gentle Introduction assumes you already know ML. RWH assumes you already know Haskell. :)
12:04:16 * tabemann read LYAH first, and then RWH, and this is from having a good knowledge of OCaml already
12:04:19 <b2coutts> thanks for the advice guys, I'll probably start with lyah and see where it takes me
12:04:23 <phamiltiz> jmcarthur, show me
12:04:35 <tabemann> the Gentle Introduction was fine for me, but I could see how it wasn't exactly gentle for most
12:04:43 <merijn> monochrom: I read the first 2/3 chapters of RWH as basic syntax intro and that was ok, but then there's a sudden leap in difficulty :p
12:04:44 <dmwit> b2coutts: I liked the Gentle Introduction a lot.
12:04:46 <merijn> @quote Gentle
12:04:46 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
12:04:54 <dmwit> If you're a no-nonsense kind of guy, you'll like it a lot, too.
12:04:54 <merijn> tabemann: See that quote :p
12:04:56 <geekosaur> GI was okay for me, but I already had exposure to ML
12:04:59 <b2coutts> hahaha
12:05:03 <jmcarthur> phamiltiz: please ask rather than command. i'm doing it because it sounds fun, not because you are telling me to
12:05:18 <tabemann> geekosaur: same here
12:05:22 <b2coutts> would I _need_ to no ML to gentle introduction?
12:05:27 <dmwit> no
12:05:29 <phamiltiz> jmcarthur sorry did not mean to come across rude
12:05:40 <dmwit> b2coutts: When I read it, I knew C++ and Python.
12:05:40 <phamiltiz> Typing on my tablet it a pain
12:05:46 <geekosaur> you don't *need* to know it, but it'll be easier to follow
12:06:10 <merijn> geekosaur: You might as well just say "if you already know ML learning haskell will be easier" :p
12:06:31 <monochrom> with LYAH, your prerequisite is just highschool algebra skill
12:06:44 <merijn> Naming question!
12:06:47 <geekosaur> but that's not necessarily true. the syntax will be a little easier, but the semantics are considerably different thanks to non-strict evaluation
12:06:54 <tabemann> being an ML programmer in background does make me wish at times "why can't Haskell just be a pure, *strict* language?"
12:07:25 <monochrom> naw, it makes me go back and ask "why can't ML just be a pure, non-strict language?"
12:07:27 <merijn> I have some generic functions like "read", how should I name them? 1) fooRead 2) readFoo 3) read (import qualified as Foo.read) 4) something else entirely
12:07:35 <jmcarthur> tabemann: i feel the opposite when i use ocaml
12:07:51 <merijn> tabemann: Habit! A strict haskell dialect for systems programming (that is currently mostly/entirely vapourware, afaik)
12:07:54 <b2coutts> having read the intro to gentle, it sounds like exactly what I'm looking for
12:07:58 <b2coutts> thanks again everyone
12:07:59 <tabemann> monochrom: then you would just have haskell minus type classes and plus parametrized modules
12:08:01 <dmwit> tabemann: http://stackoverflow.com/q/7868507/791604 <- "Why laziness?"
12:08:08 * BMeph_ thinks tabemann's remark sounds like the perfect introduction to the "My Fair Lady" song, "Why Can't a Woman Be More Like a Man"... ;)
12:08:25 <tabemann> and plus side effects
12:08:27 <dmwit> merijn: parse
12:08:36 <monochrom> merijn: I vote for readFoo, or parseFoo
12:08:53 <mekeor> merijn: i vote for readFoo
12:09:00 <monochrom> but fooRead and fooParse are also ok
12:09:30 <monochrom> why can't assembly be more like Haskell?
12:09:49 <merijn> More specifically, I'm working on library for dealing with pty controlled processes so you'd get something like "readPty :: Pty -> {- stuff -} -> IO ByteString"
12:10:08 <monochrom> unsafereadFoo :)
12:10:15 <mekeor> "read {a book}" is "[verb] [object]". so "readFoo" is better imo :)
12:10:32 <dmwit> So English-centric.
12:10:41 <mekeor> well, "read" is english too
12:10:52 <mekeor> and "parse" as well...
12:11:02 <jmcarthur> phamiltiz: do you care about the filename prompt and such or are you happy with a hardcoded file name?
12:11:04 <tabemann> practically all programming languages are english-centric in their keywords
12:11:15 <monochrom> reada_foois = foois_reada in Latin :)
12:11:17 <dmwit> That doesn't mean you should base your decisions on what English does.
12:11:21 <simukis_> tabemann: http://adam-lynch.github.io/ked/
12:11:22 <b2coutts> well bash is consonant-centric
12:11:32 <tabemann> even ones created by people who natively speak languages other than english, e.g. ocaml
12:11:32 <phamiltiz> jmcarthur, file name prompt would be better
12:11:45 <merijn> Relatedly, I will have to version of read. "Pty -> IO (Either ControlCode ByteString)" and "Pty -> Io ByteString", normally I'd name the version that throws away an output with an underscore (like readPty_), but I consider the one without Either to be the "main" implementation, so everyone using readPty_ everywhere seems ugly
12:11:50 <merijn> Any opinions?
12:12:08 <merijn> s/to/two
12:12:11 <mekeor> dmwit: i just find it more natural, thus easier to understand/follow, thus better *shrug*
12:12:26 <dmwit> merijn: I think it's common to use _ as an indicator for "the internal, very powerful implementation".
12:12:37 <dmwit> (...."that you normally don't use")
12:12:41 <monochrom> readFoo :: Pty -> IO ByteString; readFooCarefully :: Pty -> IO (Either ControlCode ByteString
12:12:50 <merijn> dmwit: Not for things like modifyIORef_ and mapM_ etc
12:13:02 * dmwit nods agreeably
12:13:03 <jmcarthur> phamiltiz: huh, looks like the bot is missing (should have put the link here), but here is a quickie http://hpaste.org/89078
12:13:09 <merijn> Yeah, I was considering readPtyEither
12:13:18 <merijn> Hmm, maybe "tryReadPty"
12:13:23 <dmwit> readPty :: Result a => Pty -> IO a
12:13:35 <jmcarthur> not sure if it's actually shorter in terms of token count. probably not, actually
12:13:37 <monochrom> oh, the try- prefix is also ok
12:14:14 <merijn> dmwit: I propose creating the "Most Useless Use of Typeclass" award (closely resembling the Useless Use of cat one)
12:14:36 <jmcarthur> ah, yeah, it's actually shorter
12:16:00 <merijn> Why is hpastebot gone? :(
12:16:05 <merijn> He's been away for days
12:16:21 <dmwit> merijn: Anything with two instances is automatically disqualified.
12:16:29 <geekosaur> because it was being used to spam the channel
12:16:37 <jmcarthur> phamiltiz: reaction?
12:16:46 <mekeor> is there a way to write ">>= \x -> case x of ..." more elegantly within haskell2010 without language extensions?
12:16:51 <geekosaur> (literally, someone was pasting spam and it was showing up here)
12:16:55 <merijn> geekosaur: I thought the bot had been changed to not advertise pastes with URLs in them?
12:17:03 <hpc> mekeor: without do-notation?
12:17:04 <merijn> mekeor: Nope
12:17:17 <dmwit> mekeor: Name the function you're binding to. =)
12:17:17 <merijn> Well, do notation, yeah
12:17:22 <geekosaur> the pastes didn't have URLs, just ads for e.g. cialis
12:17:23 <phamiltiz> jmcarthur, more conscise, and I guess if I knew haskell would be easier to understand
12:17:24 <jmcarthur> merijn: apart from not needing case if there is only one constructor, not that i know of
12:17:28 <monochrom> if you allow \case, it is more elegant
12:17:33 <geekosaur> or something like that
12:17:34 <mekeor> dmwit: oh right, best suggestion :)
12:17:36 <jmcarthur> phamiltiz: i don't think either is easy to understand, to be honest
12:17:43 <jmcarthur> phamiltiz: better would be really parsing the file and stuff
12:17:43 <merijn> LambdaCase to the rescue!
12:17:54 <jmcarthur> phamiltiz: would be both easier to understand and more robust
12:17:57 <mekeor> hpc: without?
12:18:08 * dmwit feels 90% confident that mekeor knew about and rejected LambdaCase given the setup "...without language extensions"
12:18:21 <phamiltiz> Just use sed
12:18:28 <merijn> dmwit: Yeah, that's why I said "no" initially :p
12:19:26 <mekeor> dmwit: i knew there were some language extensions which make it easier... – isn't there also some extension like "case of" means "\x -> case x of"?
12:20:15 <dmwit> The syntax is "\case", hence the extension name "LambdaCase".
12:20:22 <mekeor> ah :)
12:20:27 <mekeor> AH
12:22:31 <merijn> x >>= \case {- constructor matching here -}
12:22:52 <tabemann> why is it that there always seems to be some important feature to have that requires using a language extension in haskell? I'm used to coding in other languages with no extensions at all, but in Haskell it seems that there's always some need for an extension somewhere
12:23:30 <merijn> tabemann: Because by default GHC confirms to the Haskell2010 standard
12:23:32 <hpc> tabemann: the philosophy of haskell is to have a conservative core language, with fancier features enabled as extensions
12:23:40 <merijn> tabemann: And the writes of the standard are really conservative
12:23:55 <hpc> tabemann: it's a better alternative to the gcc way of just blatantly deviating from the standard by default
12:23:58 <merijn> tabemann: Imagine gcc where all the GNU extensions where of by default
12:23:59 <wwt> haskellers are more obsessed with brevity? It's not liek base haskell can't do everything
12:24:08 <merijn> s/where/were
12:24:10 <hpc> merijn: haha
12:24:24 <tabemann> in C and C++ I typically don't even use the GNU extensions when they are available
12:24:36 <merijn> tabemann: It's almost impossible to write portable C using gcc as you use them without even noticing
12:24:49 <merijn> tabemann: I find that highly improbable
12:25:01 <hpc> tabemann: in any event, haskell is a popular research language, and so it's common to write an extension that does something new just to see if it works
12:25:08 <merijn> tabemann: Ever ran your C code through ICC? Odds are it'll throw a hissy fit at your GNU-isms
12:25:09 <tabemann> considering at my two most recent jobs I was coding C on compilers other than gcc...
12:25:09 <hpc> rather than writing a new language with the feature baked in
12:25:22 <merijn> tabemann: Ah, in that case your probably fine :p
12:25:28 <hpc> if it's a good feature, it gets integrated into ghc
12:25:30 <geekosaur> and clang keeps getting extended with new gcc-isms that need to be emulated for code to build with it
12:25:37 <merijn> tabemann: GHC is just trying to aovid that situation by making all extensions explicit
12:25:48 <merijn> geekosaur: -fheinous-gnu-extensions? :)
12:25:56 <mekeor> merijn: you're (!)
12:26:02 <tabemann> lol
12:26:03 <hpc> there's several extensions in ghc that wildly alter the behavior of the language
12:26:15 <hpc> like the ones that make forall explicit
12:26:25 <merijn> mekeor: I suck at typing
12:26:26 <hpc> or the ones that change type class behavior
12:26:34 <mekeor> merijn: i see
12:26:44 <merijn> Fun fact, "-fheinous-gnu-extensions" is a real flag
12:26:47 <tabemann> haha
12:26:51 <mekeor> dafuq
12:27:14 <geekosaur> merijn, indeed :)
12:27:26 <monochrom> onoes
12:27:28 <merijn> Search for "heinous": http://clang.llvm.org/doxygen/SemaStmtAsm_8cpp_source.html
12:27:47 <geekosaur> (all too aware of it, life got "interesting" in macports land when we started making ports clang compatible)
12:28:52 * tabemann has yet to wrap his brain around what exactly forall does (what exactly is forall a. a -> b or whatever actually doing)
12:29:37 <hpc> tabemann: forall is what brings type variables into scope
12:29:59 <mekeor> ah
12:30:21 <hpc> it's implicit in standard haskell, but there's well-defined functions that you can't write in standard haskell
12:30:35 <tabemann> I've seen that, but I've had no clue as to what it *means* when you actually use that in-scope type variable somewhere, like if you have a forall a. somewhere and then buried in the body of the function you have a as well
12:30:38 <hpc> and RankNTypes lets you write them
12:30:41 <FreeFull> tabemann: Maybe you should look at learning first-order logic
12:31:29 <tabemann> I've learned about it, but it's been a while (you mean the logic with up-side-down As and reversed Es and like)
12:31:36 <dmwit> tabemann: forall a. e is the type of a function which takes a type and returns a value of type e.
12:32:37 <dmwit> ...with all the occurrences of "a" in "e" substituted by the type you passed.
12:33:03 <dmwit> tabemann: So, "forall a b. (a -> b) -> ([a] -> [b])" is the type of a function whose first two arguments are types.
12:33:49 <dmwit> Once you've picked two types, let's say, Int and Double, it returns a function which takes an Int to Double conversion and produces an [Int] to [Double] conversion.
12:35:04 <merijn> tabemann: Well, think about what does "a" mean in "id :: a -> a"
12:35:13 <dmwit> (If you also want to know about existentials, you can think of "exists a. e" as being a tuple whose first part is a type and whose second part is a value of type "e", again with all the "a"s in "e" substituted away for the type given in the first part.)
12:35:23 <tabemann> merijn: what I was wondering is how is forall different from that
12:35:36 <dmwit> tabemann: It isn't. There's an implicit, unwritten forall there.
12:35:38 <dmwit> :t id
12:35:39 <merijn> tabemann: It literally means that "id has type a -> a *forall* values of a"
12:35:40 <lambdabot> a -> a
12:35:48 <dmwit> id :: forall a. a -> a
12:36:01 <merijn> tabemann: It isn't, in standard haskell any type variable is implicitly forall'ed on the left
12:36:21 <tabemann> merijn: well that I knew; I was wondering is how is explicit forall different from that
12:36:35 <mekeor> forall is like the opposite of binding a type variable to a type class, right?
12:36:47 <merijn> tabemann: It lets you write variable scopes that are smaller than the entire type signature
12:37:13 <mekeor> merijn: ah
12:37:16 <merijn> tabemann: "foo :: (forall a . a -> a) -> b" = "foo :: forall b . (forall a . a -> a) -> b"
12:37:34 <tabemann> okay, so if you have a function (forall a. a -> a) -> a the "a"s in the parens are different from the "a" outside the parens?
12:37:42 <Michael__> Is it possible to specify the input type of a data constructor as a typeclass?
12:37:44 <merijn> tabemann: Yes
12:38:16 <merijn> tabemann: More specifically "(a -> a) -> b" means, given a function from any type a to a value of the same type, produce a b"
12:38:40 <merijn> tabemann: But "(forall a. a -> a) -> b" means "given a function that accepts *all* types, produces a b
12:39:07 <FreeFull> Wouldn't id be the only function that fits
12:39:20 <monochrom> yes
12:39:20 <tabemann> okay, so the first will take a Double -> Double, but the latter takes only a function defined as a -> a
12:39:28 <merijn> tabemann: Giving "Int -> Int" to the "(a -> a) -> b" function is fine, giving "Int -> Int" to the function (forall a. a -> a) ->b is a type error
12:39:33 <merijn> tabemann: Correct
12:39:59 <merijn> FreeFull: Yes, but sometimes you want to use that + typeclass constraints for things
12:40:26 <FreeFull> merijn: That would be more usefuk
12:40:30 <FreeFull> useful*
12:40:37 <tabemann> couldn't you have other functions that fit forall a. a -> a, like foo x = x `seq` x ?
12:40:52 <jmcarthur> tabemann: think about what that does
12:40:53 <monochrom> but more interesting examples are runST :: (forall s. ST s a) -> a, build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
12:41:11 <tabemann> monochrom: I was particularly wondering what that forall s. in runST did
12:41:13 <merijn> FreeFull: Another example, if you have a GADT with a phantom type you can write "f :: a -> (forall b . a -> Foo b -> c) -> c"
12:41:42 <merijn> FreeFull: There you ignore the phantom type of the "Foo" value
12:42:01 <merijn> i.e. "this works for all Foo's regardless what's inside them
12:42:06 <merijn> "
12:42:15 <jmcarthur> tabemann: when you evaluate (foo x), evaluate x and return x. this is the same thing as id
12:42:35 <FreeFull> I know ST uses a phantom type
12:42:59 <mekeor> Michael__: i don't know, but maybe using GADTs syntax?
12:43:19 <merijn> Michael__: It's possible using GADTs, yes
12:43:42 <mekeor> Michael__: like "data Foo = { FooConstructor :: Num a => a -> Foo; ... }" or so
12:43:42 <merijn> "data Foo a where MyFoo :: Eq a => a -> Foo a"
12:43:51 <mekeor> oh
12:43:52 <mekeor> :D
12:44:03 <tabemann> jmcarthur: I wouldn't say it's the same as id, because, if you are calling putMVar mVar (foo x) your value will be evaluated in the putting thread, whereas if you call foo (takeMVar mVar) your value will be evaluated in the receiving thread
12:44:16 * hackagebot monadplus 1.0 - To be written.  http://hackage.haskell.org/package/monadplus-1.0 (HansHoglund)
12:44:18 * hackagebot monadplus 1.1 - To be written.  http://hackage.haskell.org/package/monadplus-1.1 (HansHoglund)
12:44:29 <FreeFull> monochrom: How would build be implemented?
12:44:31 <tdammers> hey, anyone familiar with TagSoup?
12:44:32 <merijn> Michael__: Note that that's just using ExistentialQuantification internally, but the GADT version is (in my opinion) much nicer than using ExistentialQuantification yourself
12:44:33 <tabemann> whoops
12:44:35 <FreeFull> I can only think of   build _ = []
12:44:47 <jmcarthur> tabemann: that isn't true
12:44:49 <merijn> tabemann: Nope, it won't be
12:44:54 <tabemann> value <- takeMVar mVar ; let value' = foo value
12:45:03 <tdammers> I get the impression that it doesn't handle <script> correctly
12:45:10 <monochrom> build is implemented at http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/GHC-Exts.html#g:4
12:45:25 <jmcarthur> tabemann: let does not evaluate things
12:45:36 <tabemann> jmcarthur: no, I meant foo would evaluate things
12:45:41 <jmcarthur> tabemann: no it won't
12:45:47 <jmcarthur> tabemann: at least not any more than id does
12:45:57 <tabemann> x `seq` x isn't evaluating x and then returning the evaluated value?
12:46:04 <jmcarthur> tabemann: it only evaluates x when the result is demanded
12:46:06 <jmcarthur> tabemann: the same as id
12:46:18 <monochrom> > const True (undefined `seq` undefined)
12:46:20 <lambdabot>   True
12:46:41 <monochrom> first horror of non-strictness
12:46:57 <jmcarthur> (it's not a horror at all)
12:47:03 <FreeFull> :t \g -> g (:) []
12:47:04 <lambdabot> ((a -> [a] -> [a]) -> [a1] -> t) -> t
12:47:11 <tabemann> jmcarthur: oh, so if you do putMVar mVar (foo x), you're putting the thunk for (foo x) in mVar, to be evaluated by whoever finally does something with it
12:47:13 <monochrom> i.e., in some contexts, it does not matter how many more seq's you pile up
12:47:37 <jmcarthur> tabemann: right, which is exactly the same as if you had done putMVar mVar (id x) instead
12:47:52 <merijn> tabemann: It says that "If neither x nor y evaluate to bottom, then evaluating "x `seq` y" will evaluate both x and y"
12:48:10 <monochrom> > const True (undefined `pseq` undefined)
12:48:12 <lambdabot>   True
12:48:24 <merijn> tabemann: "x `seq` x" just says if you evaluate x, then evaluate x
12:48:32 * tabemann is still getting used to lazy evaluation
12:48:48 <jmcarthur> *if you evaluate (x `seq` x) then evaluate x
12:49:22 <tabemann> isn't that more like, if you try to evaluate (x `seq` x) to some degree, evaluate it completely?
12:49:30 <monochrom> no
12:49:35 <jmcarthur> tabemann: x `seq` putMVar mVar x   would evaluate x first, though
12:49:45 <merijn> jmcarthur: Not necessarily
12:49:47 <jmcarthur> tabemann: seq only evaluated to week head normal form, just like normal evaluation
12:50:02 <merijn> jmcarthur: It might evaluate "putMVar mVar x" first and then x
12:50:08 <jmcarthur> merijn: well, before the IO action executes
12:50:16 <merijn> jmcarthur: Sure
12:50:54 <jmcarthur> *evaluates   *weak
12:51:38 <monochrom> x `seq` x `seq` x `seq` x is like http://xkcd.com/1185/
12:51:51 <tabemann> if you're using putMVar, and you really want to make sure x is evaluated in your thread, would the following work (I'm not sure):
12:52:01 <tabemann> !x' <- return x
12:52:02 <monochrom> particularly the one that says "come on come on"
12:52:07 <tabemann> putMVar mVar x'
12:52:18 <tabemann> (assuming you've enabled BangPatterns)
12:53:11 <tabemann> or does !x' not actually force its complete evaluation
12:53:45 <jmcarthur> tabemann: only to weak head normal form
12:54:06 <merijn> tabemann: ! is just similar to seq
12:54:24 <jmcarthur> > (1:undefined) `seq` "foo"
12:54:25 <lambdabot>   "foo"
12:54:30 <jmcarthur> > undefined `seq` "foo"
12:54:31 <lambdabot>   "*Exception: Prelude.undefined
12:54:55 <monochrom> why use foo, when you already have True, or ()
12:55:15 <jmcarthur> tabemann: you could use the deepseq stuff (which i'm not a fan of, but it's there if you're in a pinch otherwise)
12:55:28 <jmcarthur> monochrom: because foo
12:55:28 <merijn> > const True (undefined `seq` undefined)
12:55:30 <lambdabot>   True
12:55:34 * tabemann didn't know there was that
12:55:51 <jmcarthur> seq is an ugly hack anyway
12:56:25 <jmcarthur> > (\_ -> undefined) `seq` True
12:56:26 <lambdabot>   True
12:56:38 <jmcarthur> well, i wouldn't say "ugly" i guess
12:57:09 <jmcarthur> but a little awkward sometimes. it at least makes some theory less convenient
12:57:39 <tabemann> it points at that being lazy all the time might not be what one necessarily wants in all cases
12:57:57 <jmcarthur> haskell is not lazy all the time anyway
12:58:06 <jmcarthur> pattern matching is strict
12:58:33 <tabemann> it's strict as far as evaluating the constructor(s) for that being matched
12:58:39 <jmcarthur> yeah
12:58:47 <jmcarthur> which is strict enough to do pretty much anything you want
12:59:20 <merijn> Oh! I have another tricky question!
12:59:21 <tabemann> unless you're trying to do something like, say, trying to keep your workload in the proper thread (hence my putMVar examples)
12:59:49 <jmcarthur> tabemann: you could implement seq in terms of pattern matching using a type class (except for functions, which shouldn't be seqable anyway)
12:59:54 <jmcarthur> tabemann: and then deepseq in terms of that
13:00:17 <merijn> Given "newtype Foo = Foo Bar" and a bunch of functions working on Bar, is there a way to export that set of functions working on Foo without manually defining wrappers for each of those functions?
13:00:53 <FreeFull> merijn: Like an implicit fmap?
13:00:56 <jmcarthur> merijn: the principled way to go would be for those operations to be in type classes, since they are duplicated for multiple types anyway
13:01:02 <jmcarthur> merijn: then just use generalized newtype deriving
13:01:08 <tabemann> NewtypleDeriving was what I thought
13:01:16 <tabemann> *NewTypeDeriving
13:01:26 <tabemann> *NewtypeDeriving
13:01:27 <jmcarthur> merijn: apart from that... some template haskell?
13:01:36 <merijn> jmcarthur: Not an option, the functions already exist in another library that I'm not gonna modify and the modification to use typeclasses would be unacceptable anyway
13:01:43 <jmcarthur> would still have to name each function once to make the wrapped versions
13:02:09 <merijn> jmcarthur: Yes, I was hoping to automate that bit with TH
13:02:15 <wavewave> started implementing cairo-gl. soon opengl with cairo in haskell :-D
13:02:28 <jmcarthur> wavewave: :D
13:02:38 <merijn> If I have to manually enumerate all the functions I might as well add the "unwrapFoo" function immediately
13:03:03 <merijn> FreeFull: Pretty much, yes
13:03:24 <wavewave> see http://github.com/wavewave/cairo-gl and http://github.com/wavewave/EGLRaw
13:03:39 <FreeFull> I guess more implicit Applicative
13:03:57 <wavewave> EGL part is bogus yet.
13:06:55 <Hafydd> NewTupleDeriving
13:07:39 <Hafydd> That would be useful - I could finally show my 9999-unit tuple.
13:07:54 <Nisstyre> What type of tree (preferably with an implementation on Hackage) would be best to implement a probability distribution? Basically I want to put values into ranges of values based on their weights, and then use a search tree to select a value based on a random number (I haven't decided if I want it to be normalized to [0,1] yet)
13:08:13 <Nisstyre> I looked at B-trees
13:08:18 <Nisstyre> also I want efficient insertions
13:09:24 <tabemann> Hafydd: one thing I have wished for at moments are statically typed, fixed-size vectors and matrices
13:09:37 <tabemann> when working on my OpenGL code
13:10:17 <tabemann> the Linear package I ended up using uses multi-parameter type constructors for that, but that means having to explicitly deconstruct them whenever trying to access them (rather than being able to access them by index)
13:10:25 <Hafydd> tabemann: do you mean to imply that these are difficult to achieve currently?
13:10:32 <tabemann> s/type constructors/value constructors
13:10:45 <Hafydd> Oh...
13:10:55 <Hafydd> Well, you could make a Lens instance for them.
13:11:28 <tabemann> I mean, for instance, to get something defined how Linear defines a 4x4 matrix, that is, as type M44 a  = V4 (V4 a)
13:11:54 <tabemann> I have to break it out like V4 (V4 m0 m1 m2 m3) (V4 m4 m5 m6 m7) (V4 m8 m9 m10 m11) (V4 m12 m13 m14 m15)
13:12:30 <c_wraith> Nisstyre: you might be able to get one of the structures in the fingertree package to do what you like
13:12:42 <Nisstyre> c_wraith: I'll check it out
13:13:22 <Hafydd> tabemann: but I suppose your point is you wished they could be automatically derived?
13:13:40 <Hafydd> That could be possible to some degree using Template Haskell.
13:13:51 <tabemann> tis true
13:15:00 <Hafydd> (Heheh, "degree')
13:15:22 <merijn> I have a question about combining qualified imports, unqualified imports and reexporting modules
13:16:22 <merijn> If I import Foo unqualified hiding some functions and qualified hiding nothing, and then reexport Foo will I export 1) everything 2) everything except the hidden functions 3) who knows?
13:17:07 <Hafydd> merijn, how would you "rexport" Foo?
13:18:16 <merijn> Hafydd: "module Bar (module Foo) where import Foo"
13:18:27 <merijn> Or, in my case
13:18:39 <Fuuzetsu> I have GHCi I built yesterday from git segfaulting after running some tests for Haddock in it and the segfault doesn't happen in GHCi 7.6.3. How would I go about finding out what's wrong for a potential bug report?
13:18:48 <Hafydd> Oh. I'd be interested to know that too, then.
13:18:59 <merijn> "module Bar (module Foo) where import Foo hiding (foo,bar,xyzzy); import qualified Foo"
13:19:42 <tabemann> my quess is that it would export everything in Foo, but my guess is rather uneducated
13:20:49 <merijn> Hafydd: Quick ghci test implies that it exports everything in Foo, except the hidden functions
13:20:52 <merijn> This is excellent :)
13:23:06 <supki> tabemann: what do you mean "access them by index"? I would expect something like  m ^. _x . _x  to get you  m0  in your example
13:24:31 <Hafydd> I see.
13:25:17 <merijn> Next style question, how should I linewrap long "hiding" clauses in imports? i.e. this one: http://hpaste.org/89084
13:26:01 <Hafydd> If it's going to exceed 80 characters, I would say so.
13:26:06 <tabemann> supki: I mean there being some operator or syntax which accesses entries by index or indices
13:26:22 <Hafydd> (Some would say 79, and some others 78, but I don't put so fine a point on it)
13:26:49 <Hafydd> tabemann: that's what Lens achieves.
13:26:54 <merijn> Hafydd: Yeah, but I wanted to know *how*, not whether I should wrap it :p
13:27:06 <Hafydd> merijn: oh, sorry, I misread.
13:29:23 <roSievers> Looks like I have do decide between TypeSynonymInstances and FlexibleInstances: http://hpaste.org/89085 any recommendations?
13:29:28 <FreeFull> Hafydd: I think he means like using an Int/Integer
13:30:22 <jmcarthur> tabemann: you could define indexed traversable (for which there are tons of functions in the lens package) for them
13:30:32 <jmcarthur> *indexed traversals
13:30:47 <Jaxan> roSievers: if you're going to use Move anyways, the first one seems to fit best, right?
13:31:00 <jmcarthur> that may be less good than it sounds though
13:31:20 <roSievers> Jaxan: the second one should read Move, too, sorry about that
13:31:31 <jmcarthur> afaik indexing is linear with those? i could be wrong. i know little about them
13:31:43 <Jaxan> roSievers: oh, so the code is the same in both cases?
13:31:57 <roSievers> Jaxan: Yes it is.
13:32:16 <Jaxan> roSievers: then it doesn't matter, I often have both extensions
13:32:41 <roSievers> Jaxan: Thanks, I guess i will flip a coin then :-)
13:36:01 <whittle> I'm dipping my toes in the waters of Attoparsec, and having some trouble understanding. Specifically, I'm getting Partial results when I specifically expect the parser to fail.
13:36:15 <tabemann> jmcarthur: the key part here that I was wishing for was something where the size was part of a *static* type, unlike, say, if I used Array for this purpose, where the units of the index are part of the type, but the size isn't; but of course there's no such thing as a numeric *value* that is part of a type signature in Haskell
13:36:34 <tabemann> unlike in, say, hardware design languages
13:37:18 <jmcarthur> tabemann: that's actually perfectly doable
13:37:56 <jmcarthur> data Vector :: Nat -> * -> * where Nil :: Vector Z a; Cons :: a -> Vector n a -> Vector (S n) a
13:38:06 <jmcarthur> that's more list-like than array-like
13:38:21 <jmcarthur> the array version would require some implementation hiding or something
13:38:34 <merijn> You can even use actual numbers, if you accept only working with 7.6 or HEAD :p
13:38:38 <jmcarthur> right
13:39:09 <tabemann> that I did not know
13:39:40 <jmcarthur> tabemann: for indexing to be type safe you would have to use a special type for indices
13:40:03 <jmcarthur> tabemann: so numeric literals would probably be out of the picture
13:40:19 <Botje> whittle: that's typically caused by not expecting eof.
13:40:34 <jmcarthur> tabemann: because there is no way for the type to depend on the number you generate it from
13:40:36 <merijn> hmm
13:40:43 <Botje> whittle: try "parser <* eof" instead of just "parser"
13:40:44 <jmcarthur> tabemann: unless it's a partial or Maybe kind of function
13:41:05 <jmcarthur> fromInteger :: Integer -> Maybe (Fin n)
13:41:17 <merijn> Haddock is shortening 'Foo.Bar.Baz' to Baz (hyperlinked), how can I stop the hyperlink from dropping the qualifiers?
13:41:17 <jmcarthur> but then you end up using Maybe everywhere
13:42:24 <whittle> Thanks, Botje.
13:43:46 <tabemann> jmcarthur: indexing would probably have to be a partial function or Maybe function
13:44:08 <merijn> Also, http://www.haskell.org/haddock/doc/html/ch03s04.html claims that Haddock will export all reexported functions if I import a module hiding some functions, but this is not happening for me?
13:44:14 <jmcarthur> tabemann: not fundamentally, if the indexes themselves are already checked
13:44:23 <jmcarthur> tabemann: hence that type for fromInteger that i gave above
13:44:49 <jmcarthur> tabemann: that would allow the index to be used as many types as you want, after generating it once, without dynamic checks
13:44:56 <jmcarthur> *as many times as
13:45:17 <tabemann> hmm yeah if your index type was parameterized itself by the size of the range it was indexing for
13:45:44 <jmcarthur> data Fin :: Nat -> * where Zero :: Fin (S n); Succ :: Fin n -> Fin (S n)
13:46:53 <jmcarthur> just as with Vector, a more space and time efficient representation would require a hidden implementation instead of being able to just expose the whole thing like that
13:53:52 <tabemann> well yeah, it would be rather, well, inconvenient and slow to make the user write Succ $ Succ $ Succ $ Zero for what should be 3
13:55:19 <merijn> Bah, why do module export lists require listing every exported thing instead of just letting me specify the things to hide? :(
13:55:54 <tabemann> from what I'm used to, I wonder why Haskell doesn't used full interface files like ML (well, it *did*, but they got rid of them)
13:55:58 <tabemann> *use*
13:59:33 <whittle> Is there any way to guarantee that if an attoparsec parser’s input has a valid result it will return that result instead of returning Partial? Without terminating the input?
14:00:38 <b2coutts> I'm reading through LYAH, but when I try to define variables or functions in ghci (i.e., `doubleMe x = x + x'), I get the error `parse error on input `=''. Was there some syntax change in a recent version?
14:00:56 <tabemann> you have to use let before them in ghci
14:01:01 <Botje> b2coutts: you're supposed to write those things into a file and load that file
14:01:09 <shachaf> No, "let" has been required since it's been allowed.
14:01:12 <Botje> b2coutts: alternatively, you cna write let doubleMe x = x + x
14:01:33 <Botje> b2coutts: but that's really only for small functions. defining big functions like that is a pain
14:01:38 <b2coutts> ah, thanks
14:02:06 <Botje> I think that's hidden in the "getting started chapter"
14:07:12 <merijn> Haddock experts, how do I stop haddock from shortening my 'System.Posix.Terminal' hyperlink to just "Terminal" and why isn't it explicitly listing all functions that are part of a partial re-export like the docs say it should?
14:08:52 <ghorn_> i think i broke ghc http://hpaste.org/89089
14:13:22 <othiym23> so I have a script: https://gist.github.com/303da7488e273443f8bf with a profile: https://gist.github.com/1096260580ae92ce6b36 and no idea why my network client is spending 70% of its time making network connections
14:13:55 <othiym23> anybody got any ideas why performance is so horrifically bad?
14:14:53 <merijn> "getPtySize", "getPtyDims" or "getPtyDimensions"?
14:15:21 <Botje> othiym23: requestproof makes a new connection every time, and it takes a while, even on localhost.
14:16:09 <Botje> have you checked with "time" how much time you spend waiting for the kernel?
14:16:44 <othiym23> Botje: I have an implementation of this client in Node.js that also makes a new connection per request that can handle at least 280K requests per minute, no problem
14:16:54 <othiym23> and it spends most of its time doing V8 things
14:18:38 <Botje> and your node.js app also has 16 "threads" connecting at one time?
14:19:01 <ghorn_> looks like it's fixed in head though http://hackage.haskell.org/trac/ghc/ticket/7920
14:19:27 <Nisstyre> Botje: I think nodejs uses a simple event based model that doesn't require any concurrency, right?
14:19:36 <Botje> that's why i quoted threads :)
14:19:44 <Nisstyre> right
14:19:47 <othiym23> Botje: the Node.js app is single-threaded
14:19:51 <othiym23> but nonblocking
14:19:59 <othiym23> and it's using 64 concurrent connections
14:20:08 <Botje> ah
14:20:26 <othiym23> I've tried varying the number of connections between 16 and 64, makes no difference to the amount of overhead consumed by socket creation
14:20:30 <Nisstyre> othiym23: so internally it's using some kind of scheduler or what?
14:20:50 <merijn> Nisstyre: No, you program everything via callbacks
14:21:06 <Nisstyre> merijn: and when do they get called?
14:21:21 <merijn> Nisstyre: Whenever an event happens in the main loop
14:21:23 <Nisstyre> immediately when it encounters the event associated with it?
14:21:29 <Nisstyre> merijn: so how is it "non-blocking" ?
14:21:37 <Botje> othiym23: one thing i can think of is that you're getting blocking sockets
14:22:04 <zomg> Nisstyre: things like listening for connections etc. are purely callback based and in that it's non-blocking
14:22:07 <merijn> Nisstyre: They mean nonblocking in the sense of "stringing callbacks and nonblocking IO calls together into spaghetti code"
14:22:17 <zomg> however if you put a while(true) { } into the code it will never do anything else :P
14:22:19 <othiym23> yeah, it's entirely based on an epoll / kqueues-based polling system that's tied into a simple event loop, so you tie callbacks to events
14:22:47 <Botje> hmm, no. socket guarantees a non-blocking socket.
14:22:50 <zomg> merijn: I suppose you could phrase it like that too if you wanted it to sound bad ;>
14:22:51 <othiym23> Botje: yeah, I was thikning about rewriting it with nonblocking I/O -- do you know what I should google for to find a good example?
14:24:10 <merijn> Can I make something an instance of a typeclass but not export said typeclass instance?
14:24:20 <Nisstyre> merijn: so it just means that it doesn't strictly read IO?
14:24:23 <merijn> i.e. only have it available in my module
14:25:09 <merijn> Nisstyre: It means "We didn't realise that lightweight threads, blocking IO and an IO event based scheduler was a simpler solution for actually writing code"
14:25:49 <Nisstyre> merijn: yeah, that's what I would do
14:25:53 <Nisstyre> and in fact that's what I have done
14:26:05 <Botje> othiym23: well, I have no clue what happens. which GHC are you testing this with?
14:26:07 <othiym23> merijn, Nisstyre: here's the node equivalent: https://github.com/othiym23/nonsense-benchmark/blob/master/node/clients/client.js
14:26:24 <othiym23> Botje: 7.6.3 / newest haskell-platform available via Homebrew
14:27:38 <whittle> merijn: AFAIK, There is no explicit access control for instances.
14:27:58 <othiym23> cabal list --installed network -> network 2.4.1.2, if that makes any difference
14:28:10 <Nisstyre> merijn: I would add "and only let the threads run for a reasonable amount of time before killing them safely" (although it depends on your threading implementation)
14:28:42 <Botje> othiym23: I can't help you any further, unfortunately
14:28:45 <Nisstyre> merijn: I did something like that in Racket using their greenthreading implementation
14:28:54 <Botje> try posting on the haskell reddit or haskell-cafe mailing list
14:29:07 <Botje> or ask your question again during the week
14:29:23 <Botje> my uneducated guess is that connect is blocking behind your back and slowing everything down
14:29:34 <merijn> whittle: Bummer
14:29:55 <othiym23> Botje: thanks for taking a look!
14:29:57 <whittle> merijn: The usual fix is to create a type internal to the module that has the instance, and then export a wrapped type which doesn't.
14:30:05 <merijn> Naming opinions, which is better: "getPtySize", "getPtyDims" or "getPtyDimensions"? (or something else entirely, like getSizePty)
14:30:26 <merijn> whittle: Well, it just means I'll have to manually unwrap the newtype in my module, it's not a big problem
14:30:33 <othiym23> it's entirely possible there's some kind of I/O coordination overhead with connect I'm not understanding, there's a bunch of other strategies I'll try to make this faster
14:30:49 <tdammers> Dims feels wrong, I have no opinions wrt the others
14:30:53 <ofan> i prefer 'getPtyDimensions'
14:31:10 <othiym23> +1 on 'getPtyDimensions'
14:31:15 <jnerula> @hoogle ByteString -> Query
14:31:16 <lambdabot> Warning: Unknown type Query
14:31:16 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:31:16 <lambdabot> Data.ByteString.Lazy foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
14:31:58 <Botje> othiym23: looking at the implementation of connect, I think it's the source of your problems
14:32:17 <Botje> it calls C connect() in a loop until the connection succeeds.
14:32:35 <Botje> so you effectively have 16 threads calling connect in a loop. silly.
14:34:04 <merijn> You can't really change that, though. Connect has to block until the TCP handshake finishes
14:34:29 <supki> merijn: I would s/getP/p/
14:35:45 <merijn> supki: Why?
14:36:06 <merijn> ptyDimensions seems wrong for "IO (Int, Int)"
14:36:16 <merijn> eh
14:36:27 <merijn> "Pty -> IO (Int, Int)"
14:36:37 <supki> (Int, Int) :-(
14:37:04 <supki> merijn: well, I can infer "get" part from that type
14:37:20 <merijn> supki: What would you rather have than (Int, Int)?
14:37:48 <supki> data Dimensions = Dimensions { width :: Int, height :: Int }
14:37:54 <merijn> Why?
14:38:11 <merijn> Seems annoying to have to constantly wrap and unwrap
14:38:26 <supki> well, (Int, Int) says nothing about which Int is what
14:39:20 <merijn> Fine, but I personally hate having to wrap/unwrap values in verbose constructors for almost no reason
14:39:21 <othiym23> Botje: thanks for checking the source
14:39:23 <supki> also you need to unwrap (,) anyway
14:39:29 <othiym23> I may have to rethink using Haskell for this, then
14:39:47 <ofan> type Dimensioins = (Int, Int); ptyWidth = fst; ptyHeight = snd; is better?
14:39:48 <merijn> supki: I can do that in a pattern match, whereas pattern matching Dimensions would be really verbose
14:40:14 <quchen> merijn: case x of Dimension x y -> ...?
14:40:34 <quchen> vs case x of (x,y) ->
14:40:44 <quchen> Don't mind the double x :x
14:41:47 <merijn> quchen: heh
14:41:50 <merijn> No...
14:42:00 <quchen> No?
14:42:38 <merijn> "(x, y) <- ptyDimensions foo; {- stuff -}" vs "Dimensions { x, y } <- ptyDimensions foo; {- stuff -}"
14:42:47 <merijn> I don't even know how to properly match that
14:43:08 <shachaf> "Dimensions x y", if you're OK with not using labels.
14:43:09 <quchen> (Dimensions x y) <- ..
14:43:33 <quchen> merijn: Record names are an additional option, you can still use all the good things you had without records
14:43:48 <shachaf> Like the nice concise derived Show instance!
14:43:55 <merijn> Yeah, but why bother with that type at all if (Int, Int) suffices?
14:44:55 <quchen> (Int, Int) is triple blind: it could be the tuple of day and month. The Int could be a Unix timestamp. The order could be the other way round.
14:45:07 <quchen> Using "Dimension Int Int" solves one of these.
14:45:38 <quchen> (Not sure whether that's worth it. Adding a "Height" type might be a little too much.)
14:45:43 <merijn> Yes, but there's no reason whatsoever to move the dimensions around very long...
14:45:59 <merijn> The only thing you can do with the is get them and set them
14:46:14 <merijn> No one is going to be moving them through 15 different functions and type signatures...
14:46:26 <merijn> And if they are, then they can fix that in their code and unwrap before calling mine >.<
14:47:37 <quchen> It's a very bikesheddy discussion anyway, I think anything would be fine. I just wanted to remark that you can use the usual pattern matching on record types.
14:48:35 <merijn> Nothing is more fun than bikeshedding my API of a library that may or may not be released :p
14:49:04 <irene-knapp> lol yes
14:49:07 <quchen> IT MAY BE RELEASED!?
14:49:15 <quchen> Why didn't you say that before
14:49:50 <quchen> Now you need turbo mode type safety. data Dimension = Dimension { width :: Width, height :: Height }; newtype Width = Width Int; newtype Height = Height Int
14:50:18 <quchen> Also don't pattern match because your code won't be invariant under swapping Dimension's field order.
14:50:50 <shachaf> If you use Width and Height types like that, it won't matter!
14:51:09 <merijn> quchen: If you like bikeshedding, you are now charged with worrying about how to linewrap: http://hpaste.org/89084
14:52:10 <quchen> merijn: I would write a "silly hiding import" submodule that reexports all the non-hidden stuff.
14:52:14 <quchen> I would call it Yellow.h
14:52:15 <quchen> s
14:52:49 <ofan> just use (Int, Int) and create a type synonym for it.
14:53:37 <quchen> Call it Tuple.
14:53:55 <jnerula> @src readsPrec
14:53:55 <lambdabot> Source not found. Sorry.
14:54:20 <quchen> jnerula: readsPrec is the function of the Read typeclass. It doesn't have "a" source, but one for every instance.
14:54:57 <jnerula> quchen: cool
14:55:19 <jnerula> Oh, yeah I see that now
14:55:33 <quchen> jnerula: You can see some instances here: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Read.html
14:56:04 <quchen> Search for "instance Read Bool where", that might be a good start.
14:56:19 <JoeyA> Just curious, is it possible to define (,) and Either purely with functions and newtypes (i.e. no tuples and data declarations), without using Rank2Types?  It's pretty easy to do with rank-2 newtypes: http://hpaste.org/89097
14:56:22 <scottj> in haskell-mode in emacs I'm not seeing type signatures for imported functions in the echo area. Is there something I have to do to enable this?
14:56:50 <jnerula> quchen: I was actually looking at the code for PostgreSQL.Simple.Types, because Query is an instance of Read
14:57:32 <quchen> jnerula: I use read very carefully, I consider it a very smelly replacement for proper parsing.
14:58:26 <merijn> I wonder if I should set the portability field of my code to "haha" :)
14:58:50 <quchen> merijn: That's not using the full power of Unicode
14:59:00 <Nisstyre> merijn: http://stackoverflow.com/a/3858684/903589
14:59:08 <Nisstyre> that is basically what you wanted to say right?
14:59:18 <Nisstyre> (beforehand)
14:59:48 <merijn> Nisstyre: Pretty much
15:00:08 <Nisstyre> merijn: I <3 that answer so much
15:00:17 <Nisstyre> so many people have this idea that threads are somehow "evil" or "wrong"
15:01:46 <merijn> Threads + mutable state = evil & wrong
15:01:49 <merijn> eh
15:01:56 <merijn> s/mutable/shared mutable
15:02:04 <merijn> Thread + no shared mutable state = <3
15:02:09 <geekosaur> threads can be pretty dangerous. haskell has the facilities to handle them without getting into trouble; most languages don't, and real threads become a fertile source of errors
15:03:42 <geekosaur> (note that I exclude "green threads" --- including Haskell's --- as those are not really threads at all, but a thread-like interface to an event manager. in particular you cannot get real concurrency from such, where code is simultaneously executing on multiple CPUs and can access and modify data that is being used by another thread at the same time.)
15:04:18 <geekosaur> ...note also that haskell being mostly about pure immutable values all by itself defangs concurrency...
15:05:31 <quchen> What I really like about Haskell concurrency is how natural it comes. Very often I'm just writing code, and when I see a section that takes longer to execute but I kind of want to go on with my actual program, I add "forkIO $" and that's it.
15:06:02 <ofan> "those are not really threads at all" why?
15:06:21 <quchen> Example: Server loop. Handle request, but don't wanna wait for the first request to finish before you loop? Forking solves my problem, and as a secondary (!) bonus makes the server scale well.
15:06:41 <geekosaur> ofan, two green threads cannot be executing at *exactly* the same time, there must be a context switch between them. *real* threads can be executing on different CPUs at identically the same time
15:07:16 <geekosaur> (note that N:M threading blurs the line here, but most "green threads" systems have only one OS thread)
15:07:17 <JoeyA> If running with +RTS -N2, two Haskell threads can be running on two different capabilities
15:07:18 <quchen> geekosaur: Green threads are what Haskell has when you link concurrent code against the non-threaded runtime?
15:07:19 <black_13> how do install haskel or a hugs for osx
15:07:40 <ofan> JoeyA: +1
15:08:20 <JoeyA> With -threaded and multiple capabilities (e.g. -N2 or setNumCapabilities), multiple green threads can be assigned to a single OS thread
15:08:26 <geekosaur> JoeyA / quchen, yes, when I said green threads I meant the non-threaded runtime. it;s when you have multuple CPU threads (or what ghc calls capabilities) that you get into real threading and real concurrency
15:08:29 <JoeyA> Green threads can even hop from one OS thread to another.
15:08:47 <Cale> black_13: http://www.haskell.org/ghc/download_ghc_7_6_3#macosxintel
15:09:02 <JoeyA> (that's done for safe FFI calls, so one thread making a blocking call to a C function won't block the other green threads on the same OS thread)
15:09:05 <geekosaur> and you'd be amazed how many "threaded" programs --- in languages other than Haskell --- die very badly if you swap the single-threaded runtime for a multi-threaded one
15:09:25 <geekosaur> black_13, don't install Hugs, it hasn't been maintained for years
15:09:48 <black_13> what was or is hugs
15:10:36 <quchen> Are green threads some well-defined term, or is it used for vaguely identical things? Wikipedia makes it sound like all non-OS (but software handled) threads are green. In that case, wouldn't even the threaded runtime of Haskell be full of green threads? (Plus a couple of OS threads they are mapped to on the back end)
15:11:15 <geekosaur> quchen, it is full of green threads. but it's also a hybrid thread system, aka N:M threading
15:11:29 <geekosaur> (N green threads multiplexed across M real threads)
15:12:01 <quchen> Ah, now I understand what you meant with the comment above ("note that ...")
15:12:25 <jmcarthur> "green thread" is fairly well defined, but the definition is not widely accepted (by which i mean that there is a real definition but many people don't understand that)
15:12:58 <quchen> And what is that definition (and who is the authority behind it)?
15:13:25 <merijn> black_13: It's compiler/interpreter for teaching haskell, but it stopped being maintained years ago. Right now there is no reason to use it instead of ghc/ghci
15:13:34 <jmcarthur> "green" is often used to mean "in user space", that is, in OSes where most OS functionality occurs in kernel space, not by the operating system itself.
15:13:44 <black_13> ok
15:13:52 <jmcarthur> "green threads" are just threads that are managed and scheduled by some user space VM
15:13:57 <black_13> ok
15:14:15 <black_13> i have intel mac that still has 10.6.8
15:14:19 * hackagebot codec-mbox 0.2.0.0 - A library to read and write mailboxes in mbox format  http://hackage.haskell.org/package/codec-mbox-0.2.0.0 (NicolasPouillard)
15:15:38 <merijn> Is there any reason not to return "MonadIO m" instead of IO?
15:15:45 <geekosaur> actually, pedantically speaking I think "green threads" was defined by Java and means whatever Java says it means.
15:15:48 <hpc> merijn: monomorphism restriction
15:16:05 <hpc> dependency on mtl
15:16:11 <jmcarthur> geekosaur: i doubt that, but have no evidence otherwise at the moment
15:16:17 <hpc> don't feel like typing out longer signatures
15:16:18 <hpc> etc
15:16:30 <geekosaur> at least I do not recall "green threads" being a Thing until they were added to Java
15:16:48 <Nisstyre> geekosaur: you can get "real concurrency" from green threads
15:16:53 <hpc> the wikipedia article even says "threads managed by a virtual machine"
15:16:55 <Nisstyre> concurrency does not necessarily imply parallelism
15:16:59 <merijn> hpc: ok, so no real big ones when it comes to deciding on which to use for my API
15:17:06 <hpc> with sections "green threads in java" and "other languages"
15:17:32 <jmcarthur> hpc: "virtual machine" is a broad term. java is a popular language. i don't think this is very strong evidence.
15:17:34 <Nisstyre> and parallelism has different concerns from the concurrency you get from green threading
15:17:41 <ofan> need a wiki page for that too
15:17:54 <davd_> is there some clever way to negate type equality? (a ~ b) should not hold.
15:18:08 <Nisstyre> Haskell separates parallelism and concurrency, which I think is an exceptionally good idea
15:18:11 <JoeyA> merijn: if callbacks are involved, MonadIO can hurt your ability to adjust the definition: withTransaction :: MonadIO m => Database -> m a -> m a; withTransaction db body = do begin db; body; commit db
15:18:11 <ofan> i thought "green thread" may refer to coroutines
15:18:21 <jmcarthur> davd_: data Void;   type Not a = Void -> a
15:18:26 <Nisstyre> ofan: green thread basically means threads not done by an OS
15:18:33 <jmcarthur> davd_: type NotEqual a b = Not (Equal a b)
15:18:36 <Nisstyre> and not capable of parallelism
15:18:41 <Nisstyre> which isn't a bad thing necessarily
15:18:41 <JoeyA> merijn: if you want to fix 'withTransaction' to rollback in the event of an exception, you'll need 'mask', 'catch', and 'throwIO'.
15:18:46 <geekosaur> Nisstyre, I am not sure you're reading what I wrote, or at least not all of it
15:18:49 <Nisstyre> because it forces you to think about parallelism separately
15:18:50 <jmcarthur> Nisstyre: "not capable of parallelism" is not true
15:18:53 <JoeyA> Hence you'll need MonadBaseControl m or such
15:19:01 <geekosaur> in particular I think you completely spaced on what N:M threading is
15:19:02 <Nisstyre> jmcarthur: in most cases
15:19:05 <merijn> JoeyA: Yeah, but none of those really apply for me
15:19:07 <jmcarthur> Nisstyre: no
15:19:10 <davd_> jmcarthur: thanks!
15:19:26 <Nisstyre> jmcarthur: obviously you can run parallel code in green threads
15:19:36 <jmcarthur> Nisstyre: green threads can use OS threads under the hood to implement certain things (like using multiple cores) and still be green threads
15:19:55 <jmcarthur> Nisstyre: the only requirement is that they be managed by a non-OS VM
15:20:11 <Nisstyre> jmcarthur: okay, then "threads managed by a scheduler that is not the OS scheduler(s)"
15:20:13 <Nisstyre> is that better?
15:20:14 <jmcarthur> (which if you think about it is already a pretty fuzzy definition)
15:20:21 <jmcarthur> yeah
15:20:34 <ofan> "Green threads emulate multithreaded environments without relying on any native OS capabilities" from wikipedia
15:21:20 <jmcarthur> i think being 1:1 with OS threads would imply not being green threads, but any other kind of relationship still fits the definition
15:21:56 <merijn> A pox upon the person who decided that >>= and >=> should have the same precedence AND be left associative
15:22:01 <jmcarthur> but that's just a rule of thumb, not a definition
15:22:01 <Peaker> I think it's true that green threads aren't capable of parallelism -- they don't have to be capable, that's what real/kernel threads are used for, in conjunction with green threads
15:22:08 <jmcarthur> right
15:22:48 <jmcarthur> Peaker: but a lot of people seem to think that green threads cannot be used for parallelism
15:22:59 <jmcarthur> it just depends on the implementation
15:23:49 <geekosaur> jmcarthur, the original green threads were to emulate multiple CPU threads when none existed, so was implicitly N:1. N:M threading came later
15:24:06 <Nisstyre> Peaker: or other forms of parallelism in conjunction with green threads
15:24:07 <geekosaur> admittedly most people miss that N:M is explicitly green threading...
15:24:09 <monochrom> standard JVM offers only N:1 or N:N. it has nurtured a false dichotomy in many minds
15:24:29 <jmcarthur> geekosaur: i knew my rule of thumb was going to be useless
15:24:39 <Nisstyre> geekosaur: also I missed your original statement about N:M
15:24:42 <jmcarthur> wait, no, it fits
15:24:48 <Nisstyre> I just scrolled up when I got back
15:24:50 <Peaker> Green threads in a "mutable shared state" environment (that most PLs offer) is nice in that they can be used as coroutines and explicitly not preemptive, greatly reducing non-determinism
15:24:54 <jmcarthur> they are N:1, therefore green
15:25:02 <jmcarthur> N:M, also green
15:25:07 <jmcarthur> 1:1, not green
15:25:11 <Nisstyre> Peaker: some form of message passing is useful though
15:25:13 <geekosaur> right
15:25:33 <Peaker> N:M means N green threads sharing M real threads
15:25:42 <jmcarthur> i could think of ways that 1:1 could still be green
15:25:46 <jmcarthur> i guess
15:25:55 <jmcarthur> global interpreter locks could lead to such a situation
15:26:38 <Nisstyre> jmcarthur: well, by our definition of green threads, Python's threads for example, are not green
15:26:38 <Peaker> I think green threads are of course much nicer than kernel threads, but slightly over-rated, as they're still pretty far from the optimum
15:26:38 <Nisstyre> since they are OS threads
15:26:45 <Nisstyre> well, actually I'm not sure if they get managed by the OS
15:26:52 <jmcarthur> Nisstyre: it depends on if they are managed and scheduled by the OS
15:27:02 <Nisstyre> I'd have to do some research
15:27:10 <jmcarthur> Nisstyre: the OS always does, when OS threads are involved, but that could be controlled by locks and a userspace schedule anyway
15:27:34 <Nisstyre> jmcarthur: so a GIL would mean it's being managed by the VM in some form I guess
15:28:18 <jmcarthur> it gets fuzzy if you look too closely. maybe the runtime doesn't actually have any one thing called a "scheduler"
15:30:02 <geekosaur> I would not actually say OS threads; while the OS *usually* handles CPU threads, it doesn't necessarily do so (microkernels, possibly some embedded environments)
15:30:48 <jmcarthur> the line separating the "OS" from the "VM" or other "system services" also gets blurry when you think about it enough
15:31:51 <Peaker> in C: async code that looks like:    void some_async_func(struct async_func_frame *); struct async_func_frame { <some params>; void (*ret_address)(<some result>); some_async_func__private data; };      is basically like a 2-stack function (ordinary stack + async stack) where the async stack is being explicitly allocated ahead of time, allowing it to be even allocated statically.  nicely, this means you don't need dynamically growing stacks/e
15:31:51 <Peaker> tc. You have a "thread" with the precise stack size it needs, and no copying around
15:32:40 <Peaker> the "data" part is basically where some_async_func can put the nested stack frames of whatever it needs to call.  If it needs to make 2 concurrent calls, it can put 2 nested structs in there. If it needs sequential calls, then in a union.
15:33:15 <Peaker> Whereas with green threads, you'd need to spawn new threads for all this, copy/enlarge stacks, do unnecessary register saving, etc.
15:33:27 <Nisstyre> Peaker: I'm not a C expert, but isn't that basically threading by trampolining/continuations ?
15:34:09 <jmcarthur> that's just because threads are dynamic, but that async C code is more static in structure and therefore amendable to more optimizations
15:34:10 <Peaker> Nisstyre, Sort of -- but the nice thing about it is that the stack space needed by any particular function (including its concurrent needs) is reified as a C struct that the *caller* needs to allocate, allowing avoidance of dynamic allocations
15:34:16 <geekosaur> who else remembers "threads" via longjmp()? :p
15:34:20 * hackagebot haskell-spacegoo 0.2 - Client API for Rocket Scissor Spacegoo  http://hackage.haskell.org/package/haskell-spacegoo-0.2 (JoachimBreitner)
15:34:28 <jmcarthur> often those optimizations must be hand-rolled anyway
15:34:36 <monochrom> I love longjump
15:34:38 <hpc> geekosaur: i remember threads via unsafeInterleaveIO
15:34:38 <Peaker> jmcarthur, the vast majority of code in my experience doesn't need the extra dynamism, so I dislike having it there by default
15:34:39 <jmcarthur> (because there is no runtime support to take the responsibility from you anyway)
15:34:43 <nicferrier> hey haskellers
15:34:49 <jmcarthur> it's the same story as with GC
15:34:51 <hpc> someone here actually made it into a proper monad for async semantics
15:35:02 <hpc> it was pretty hilarious to see
15:35:03 <shachaf> geekosaur: Unfortunately the longjmp API isn't enough to implement threading.
15:35:05 <Peaker> jmcarthur, I'd love to have a language with reified stacks for non-recursive functions
15:35:31 <geekosaur> shachaf, scare quotes for a reason :)
15:35:32 <Peaker> jmcarthur, I dislike GC too :-(
15:35:40 <monochrom> unsafeInterleveIO: http://hpaste.org/77374
15:35:50 <shachaf> geekosaur: And by the time you make all the machine-specific assumptions you need for it, there's not a whole lot of point to using longjmp rather than writing it yourself.
15:35:51 <Peaker> jmcarthur, But I don't have a good solution to that one... I figure I need to use monadic regions and Rust more
15:36:21 <roSievers> Hi, I get a non-exhaustive pattern on http://hpaste.org/89100 but the function just takes an Either apart into Left and Right. How can that happen?
15:36:24 <jmcarthur> i like both GC and threads. they are generally better defaults than doing everything by hand, and statically inferring all this in the compiler is not a well explored problem yet
15:36:35 <jmcarthur> regions are probably the best effort so far
15:36:40 <shachaf> POSIX ucontext.h is enough to implement your own threads. But it's terribly inefficient. :-(
15:36:46 <roSievers> nevermind, I found a typo
15:36:57 <jmcarthur> (and pretty good for certain styles of programming)
15:37:08 <jmcarthur> *region inference
15:37:18 <jmcarthur> explicit regions is also nice, but not the default i want
15:37:37 <geekosaur> shachaf, back in the Bad Old Days, well before POSIX, we did in fact abuse setjmp/longjmp. it was hackish but mostly worked.
15:37:47 <Peaker> jmcarthur, I think that we can have nice looking threads that can be compiled down to the kind of C code I described above -- and when dynamism is needed (e.g: large variance in potential call stacks, recursive calls) -- have some help from the programmer to resolve (e.g: explicit dynamism)
15:38:16 <ofan> roSievers: "leftFinite (Right game)" -> "liftFinite..." ?
15:38:18 <Peaker> jmcarthur, I don't have a good idea about how to get rid of GC while retaining many of the benefits.. I hope Rust did a good job there
15:38:23 <shachaf> geekosaur: But you can't really allocate a new stack/jmp_buf, etc.
15:38:44 <shachaf> Peaker: Rust has (optional) GC.
15:38:55 <geekosaur> shachaf, ok, argue as much as you need to. doesn't change the fact that we *did* it
15:38:58 <Peaker> shachaf, I know -- supposedly it has memory safety without GC too though, which is a huge benefit usually attributed to GC
15:39:08 <jmcarthur> Peaker: my understanding on the state of region inference is that it at least works very well for strict languages
15:39:56 <jmcarthur> Peaker: but you do have to learn some different intuitions about the cost model relative to something like mark and sweep
15:39:58 <shachaf> geekosaur: We did something like it too! Except with our own context-switching code.
15:40:20 <Peaker> jmcarthur, I'm not sure I know what region inference is
15:40:22 <geekosaur> shachaf, also worth remembering is that setjmp/longjmp was specifically neutered to prevent people abusing it that way (and then the ucontext stuff brought in to replace it)
15:40:29 <Peaker> jmcarthur, is it inferring locality of resource allocations?
15:40:36 <jmcarthur> Peaker: roughly that, yes
15:40:44 <roSievers> ofan: yes, thank you that was a typo, correcting it fixed the problem
15:41:36 <jmcarthur> Peaker: it's basically just region-based memory management without the explicit annotations
15:42:02 <Peaker> jmcarthur, so no traversals of all of memory are needed to release memory?
15:42:07 <jmcarthur> nope
15:42:15 <jmcarthur> regions are actually very cheap
15:42:30 <Peaker> what about allocations that have no locality pattern?
15:43:02 <Peaker> or rather, may be local to some region, but actually releas-able before leaving that region in many dynamic cases
15:43:53 <jmcarthur> Peaker: depending on how it's set up, you may be able to explicitly free such a resource, or combine it with GC (which needn't be invoked very often) if you'd still rather not think about it
15:44:59 <merijn> If I want to (safely) peek at the head of a ByteString I guess I want Data.ByteString.uncons?
15:47:02 <jmcarthur> Peaker: for explicitly freeing, there are safe ways and unsafe ways
15:47:02 <Peaker> jmcarthur, I really hate the notion of GC scanning of *all* live application memory..   Maybe with regions, the scan can be limited to objects with dynamic life-spans, marked somehow
15:47:12 <Peaker> jmcarthur, how do you do safe explicit freeing?
15:47:34 <jmcarthur> Peaker: regions have a pretty decent type theory around them
15:48:01 <jmcarthur> Peaker: but of course that may still be too constraining for certain hand optimizations
15:48:29 <Peaker> it would be nice to have a powerful type-systems where you can prove things about reachability or so
15:48:34 <jmcarthur> yup
15:48:46 <Peaker> even in the case where they're not nicely nested as regions
15:49:43 <Peaker> Thunks mutating all over the place sure does sound like it could complicate things
15:49:49 <jmcarthur> yeah
15:50:04 <merijn> Peaker: You mean like Habit's having a separate Kind for typed memory allocations? :)
15:50:13 <jmcarthur> mutation always gets in the way
15:50:21 <Peaker> merijn, perhaps.. I don't know Habit very well
15:52:40 <jmcarthur> my general reaction to the idea that a programmer can optimize better than the compiler due to having better knowledge of the problem is that we aren't properly communicating the problem to the compiler
15:52:49 <Ralith> Peaker: precise GCs do not scan all live memory
15:53:06 <Ralith> only very conservative ones do that
15:53:14 <Peaker> Ralith, right. But they scan O(live memory) of memory, with an O that's relatively close to 1
15:53:19 <Peaker> or rather, to 0.5 :)
15:53:25 <monochrom> we can never communicate properly the problem to the compiler.
15:53:27 <Peaker> I'm not sure, but it's not a very low constant
15:53:28 <Ralith> Peaker: no, not remotely
15:53:48 <Peaker> Ralith, not remotely 1 or not remotely O(live memory)?
15:54:28 <Ralith> of course, it depends what you're allocating
15:54:54 <Ralith> but a precise GC does not scan memory in bulk like that
15:56:15 <jmcarthur> is "precise GC" some well-defined class of garbage collectors?
15:56:27 <Peaker> basically, ghc starts with roots (remembered sets iirc), and uses an info table to know what extra pointers to scan. IIRC commonly used GHC objects ((:), ints) have an info table ptr, and a data ptr?
15:57:09 <Peaker> jmcarthur, I think it just means a GC that has basic knowledge about which parts of memory have ptrs keeping objects alive, and which are not ptrs and don't need to be scanned (unlike GC's for C, for example, that don't have that kind of information)
15:58:13 <Ralith> jmcarthur: a precise GC is a GC that only scans memory locations that contain pointers.
15:58:56 <Peaker> I think GHC could make more of an effort to do LIFO allocations, as to mess fewer cache lines in the nursery  and re-use stack-like memory cache lines
15:58:58 <int-e> "conservative GC" is the opposite, where the GC tries to recognize pointers by looking at its value (whether it is somewhere inside the heap or not)
15:59:02 <arnsholt> As opposed to a conservative GC (like the Boehm GC), which looks at memory and tracks everything that looks like a pointer
15:59:23 <Peaker> (where LIFO allocations are basically "region inference" I guess)
15:59:25 <Ralith> you can, of course, write a program that allocates nothing but pointers in the heap, but I don't believe this is remotely typical.
15:59:26 <jmcarthur> Ralith: oh, then i agree with Peaker that it's on the order of O(livememory)
16:00:05 <int-e> Ralith: it's fairly typical in haskell.
16:00:05 <Ralith> jmcarthur: insofar as that it an upper bound, yes
16:00:20 <Ralith> int-e: for programs that use enough memory for GC to be a performance concern?
16:00:21 <Peaker> Ralith, even if the constant is 0.1 (it's probably higher than that), it is still an unscalable idea if soft real time is sought
16:00:44 <jmcarthur> Ralith: if what you say were true then it would be very rare for something to concern himself with the GC
16:00:44 <enthropy> mgsloan: does your zeroth (https://github.com/mgsloan/zeroth) compile/work better than technogeeky's github?
16:00:46 <jmcarthur> *somebody
16:01:00 <mgsloan> enthropy: Nope, sorry about that
16:01:09 <Ralith> jmcarthur: not that that follows, but for general use people don't :P
16:01:43 <Ralith> that's why gc is useful, after all.
16:01:55 <int-e> Ralith: as usual it depends on what you're doing. If you do text processing or numerical stuff then hopefully the bulk of your data in in unbboxed arrays. If you do compiler style stuff with abstract syntax trees then the situation is very different. Using Data.Map etc. has the same characteristic.
16:01:58 <Peaker> Also, the way things are boxed in GHC means there's a lot more pointer chasing than would be necessary if much more things were unboxed..  In a related note, I don't think there should be a contradiction between laziness and unboxing
16:02:01 <jmcarthur> i agree. it's a matter of what "very rare" means to you
16:02:13 <Ralith> int-e: right, that's rather my point
16:02:54 <int-e> Ralith: it just so happens that I tend to write more code of the latter sort :)
16:02:58 <Peaker> Does anyone know what kind of memory representations/GC are used by the competitors of GHC?
16:02:59 <Ralith> there exist some applications where real precise gc scan space is directly proportional to live memory, and there exist others where it is not
16:03:09 <Ralith> their relative proportion is up for debate, I suppose
16:03:11 <jmcarthur> Peaker: the other haskell compilers?
16:03:17 <Peaker> jmcarthur, yeah
16:03:21 <mgsloan> enthropy: I think I saw a more recent project with similar intent, that was much simpler than zeroth - lemme see if I can dig it up
16:03:29 <jmcarthur> Peaker: JHC uses boehm, i think
16:03:32 <jmcarthur> not sure about the rest
16:03:33 <Ralith> int-e: as do I, in practice
16:03:59 <jmcarthur> Peaker: beohm is just a conservative collector
16:04:04 <Peaker> I hate boxing.. C++ is "fast" and "close to the metal" because it avoids boxing by default (you need to write your own boxes to box things). While maybe boxing should be easier than in C++, I think unboxing is a saner default than boxing
16:04:14 <Peaker> jmcarthur, wow, that sucks
16:04:22 <Ralith> it doesn't suck for most people
16:04:43 <Peaker> Ralith, It can manifest as a huge memory leak under some particular circumstances, not necessarily that rare
16:04:45 <merijn> Can I tell ghci to load a module build using cabal without ghci trying to rebuild it? (i.e. so I have access to the compiled C bits)
16:04:52 <Ralith> I wager there are more bugs arising from incorrect manual memory management than there are critical performance problems arising from conservative GCs
16:04:57 <jmcarthur> the nice thing about conservative collection is that you don't have to add extra structure to your data just for the GC
16:05:06 <Ralith> jmcarthur: you don't need to do that regardless
16:05:17 <int-e> Ralith: and then the majority of data on the heap is pointers though that's not the entire story; a large part of those pointers does not point to the heap but to info tables. (still the GC has to look at them, so it seems fair to count them for GC, too).
16:05:19 <monochrom> merijn: yes, but you have to set a lot of -i paths
16:05:20 <jmcarthur> Ralith: you are referring type type directed GC?
16:05:27 <jmcarthur> *to type
16:05:35 <monochrom> ghci's -i paths
16:05:41 <Ralith> jmcarthur: if you mean what I think you do, yes
16:05:48 <jmcarthur> Ralith: type directed GC is still a fairly open research problem, isn't it?
16:05:58 <monochrom> but I think it's probably just -i dist/build
16:06:03 <Ralith> jmcarthur: is it?
16:06:06 <merijn> monochrom: What is "a lot" of -i paths? Just the dist dir?
16:06:13 <jmcarthur> Ralith: at least, i know of nothing that uses it
16:06:20 <monochrom> yeah, I guess I exaggerated :)
16:06:41 <Ralith> jmcarthur: I understand that rust plans to, at least
16:06:43 <jmcarthur> Ralith: all non-conservative GCs i know of rely on some sort of tagging or block headers
16:06:51 <Ralith> I can link some quite old papers on tagless gc if you're interested
16:06:52 <monochrom> I love a lot of paths!
16:07:12 <Peaker> How much code uses the laziness of the sized WordX/IntX types? I'd wager that not much
16:07:34 <Ralith> Peaker: you should help me implement unboxing for idris
16:07:38 <merijn> What exactly do I do? "target `dist/build' is not a module name or a source file"
16:07:54 <Ralith> Peaker: idris is strict, so we can do it pretty freely
16:08:02 <monochrom> oh, no space between -i and the path. -idist/build
16:08:03 <jmcarthur> Peaker: yeah, i don't think i woudl refute that
16:08:17 <Peaker> Ralith, I am wondering why everyone is convinced that unboxing contradicts laziness
16:08:20 <jmcarthur> i did not know idris is strict
16:08:27 <jmcarthur> :(
16:08:43 <Ralith> Peaker: I only mentioned it because you seemed to be of that opinion
16:08:43 <Peaker> Ralith, laziness requires stealing one bit of the data to mark "is evaluated" in the unboxed representation
16:08:44 <jmcarthur> Peaker: i don't think many people actually believe that
16:09:08 <Peaker> Ralith, I'd love to help, btw, my hands are full with a huge project of my own though :)
16:09:08 <jmcarthur> Peaker: it's just that conflating boxing and laziness is a practical decision for implementations because it's easy
16:09:15 <Ralith> Peaker: aw.
16:09:20 <merijn> monochrom: that still doesn't find the C symbols
16:09:39 <Ralith> Peaker: but think how much more own project would be in idris!
16:09:45 <int-e> Ralith: hmm, I'd welcome a link. (you can generate specific GC routines, but how do you keep track of which objects have been processed? forwarding pointers seem to require tags, at least one bit worth.)
16:09:58 <jmcarthur> for what it's worth, i actually don't think you always even need a tag for laziness
16:10:06 <merijn> It tells me to specify a library and library path, but I just have 2 C files that I have cabal compile for me
16:10:16 <Peaker> jmcarthur, how do you save whether it's evaluated?
16:10:21 <merijn> Do I have to manually librarify those?
16:10:25 <jmcarthur> e.g. fusion can produce tight loops over unboxed data, but it's still lazy evaluation from the point of view of the programmer who isn't paying attention to the compiler
16:10:37 <jmcarthur> it just depends on if you need the sharing
16:10:42 <jmcarthur> if not, you can drop the tagging
16:10:48 <jmcarthur> and just compute on demand
16:10:48 <monochrom> oh, then I misread your question last time
16:10:49 <merijn> Ah, bollocks
16:11:02 <merijn> I can't even manuall librarify them without finding HsFFI.h first...
16:11:14 <monochrom> if you have compiled x.c to x.o, then you have to say "ghci x.o"
16:11:23 <Peaker> jmcarthur, perhaps it could be nice to have a type-tag for a value that may be a thunk or an actual value (Lazy a):  force :: Lazy a -> a ; suspend :: (() -> a) -> Lazy a  (suspend has very ugly implications, so maybe it ought to be built into language syntax somehow)
16:11:24 <Ralith> int-e: http://www.cs.princeton.edu/~appel/papers/142.ps
16:11:46 <jmcarthur> Peaker: e.g. OCaml's lazy_t?
16:11:47 <int-e> Ralith: thanks.
16:11:58 <Peaker> jmcarthur, how does it do suspend?
16:12:04 <jmcarthur> Peaker: (except that OCaml does the dumb boxing thing under the hood)
16:12:05 <merijn> monochrom: That works \o/
16:12:19 <Peaker> jmcarthur, your point about fusion -- doesn't it depend on ghc's strictness detection?
16:12:20 <jmcarthur> Peaker: (in fact, OCaml's laziness is awful under the hood)
16:12:21 <Ralith> int-e: let me know what you make of it; I'm not truly an expert on GC design, but I'm very interested in eventually building a very good one for idris.
16:12:28 <mgsloan> enthropy: Ahh, unfortunately not.  I'd be pretty excited to see a working version of zeroth (especially if it was implemented more simply..).  here's what I was thinking of: https://github.com/mainland/th-new
16:12:35 <jmcarthur> Peaker: the unboxing does, the fusion doesn't
16:12:58 <Ralith> Peaker: idris has built-in laziness annotations which function like that except without requiring programmer overhead
16:12:59 <Peaker> jmcarthur, I still don't understand -- why does the fusion avoid the tag?
16:13:11 <Peaker> jmcarthur, you mean the actual resulting evaluation order is simply statically deduced?
16:13:13 <mgsloan> enthropy: It seems like some of this new TH stuff / modifying that repo might be a good start towards new version of zeroth
16:13:25 <mgsloan> enthropy: But I really haven't thought it through
16:13:29 <enthropy> at least the zeroth in your repo compiles. It doesn't call ghc properly now
16:13:31 <Peaker> Ralith, how do you avoid the programmer overhead?
16:13:59 <monochrom> I love beheading the programmer
16:14:18 <jmcarthur> Peaker: i just mean that if you can see that you only need something once then you don't have to share it at all, so there is no need to see whether it's evaluated since you can just assume that it isn't, and you don't have to do the mutation after, either
16:14:18 <Ralith> Peaker: it's analogous to autogenerating the suspend/force applications, iirc
16:14:20 * hackagebot prelude-safeenum 0.1.0.1 - A redefinition of the Prelude's Enum class in order to render it safe.  http://hackage.haskell.org/package/prelude-safeenum-0.1.0.1 (WrenThornton)
16:14:22 * hackagebot hledger-lib 0.21 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.21 (SimonMichael)
16:14:24 * hackagebot hledger 0.21 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.21 (SimonMichael)
16:14:26 * hackagebot hledger-web 0.21 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.21 (SimonMichael)
16:15:08 <jmcarthur> Peaker: the fusion example is just to show that you can use language and library features that are, for all practical purposes, lazy, but not end up with code that uses the RTS's facilities for dynamic laziness
16:15:17 <Peaker> jmcarthur, ah, I see.. basically it's a special case of "detect actual evaluation order statically".  Even if you have sharing, but can figure out statically who will force it, you can just do the forcing call there, and know when its forced without a runtime tag
16:15:20 <jmcarthur> Peaker: e.g. fusion of linked list stuff
16:15:27 <jmcarthur> right
16:15:55 <Peaker> Ralith, you mean the underlying intermediate language being compiled to has the laziness annotations be explicit?
16:16:04 <Peaker> (whereas they are Haskell-like implicit in the source)
16:16:16 <Ralith> Peaker: sorta.
16:17:13 <Ralith> the laziness annotations are explicit in the source language, but they're applied to function arguments, not values
16:17:24 <Ralith> you can mark arbitrary arguments as lazy
16:17:52 <Peaker> so Idris is strict by default, but makes laziness easy by allowing "this arg is lazy" or "this constructor field is lazy" annotations?
16:17:57 <Ralith> precisely
16:18:12 <Ralith> and that's then reduced to the regular HOF form in the IR
16:18:20 <Peaker> and compiles down to having explicit "Lazy a" wrapper types that specify the thunks?
16:20:26 <Peaker> Ralith, how about being polymorphic about whether you're lazy or not?  e.g: a "map" function could be usefully lazy in most cases, or usefully strict in others..  Something like:   data Lazy a ; type Strict = Identity ;    map :: Laziness l => (a -> b) -> ListT l a -> ListT l b
16:20:59 <Peaker> (ListT Lazy = Haskell's [], ListT Strict = a strict list value)
16:21:11 <Ralith> you might be able to do that
16:21:32 <Peaker> Laziness has pros/cons.. it's a bit sad to have to commit all your built in functions to one form or another
16:21:39 <Peaker> (and then all the functions in terms of those)
16:21:42 <ChongLi> I love laziness
16:22:26 <Peaker> I guess my map above is simply fmap anyway :)
16:23:36 <Peaker> Ralith, I loved almost everything that I saw about Idris so far, btw :)  I didn't like the way proofs looked like in source files after the interactive proof helper was done though
16:23:53 <Ralith> Peaker: well, you aren't required to use proof scripts
16:24:04 <Ralith> I'm pretty sure you can do all your proofs in-language, too
16:24:19 <Ralith> I've found that way easier myself so far
16:24:28 <Peaker> Ralith, why not expand the tactics thing into the actual terms deduced? It's redundant, but it's checked-redundant, and it makes the proof sequence less opaque
16:24:59 <Ralith> you'd have to ask #idris; I'm not qualified to discuss design pertaining to tactics
16:27:22 <jmcarthur> Peaker: one problem with just using a parameter to distinguish between strict and lazy functions like that is that it doesn't allow you to do things like use a tail recursion in the strict version and non tail recursion in the lazy version
16:27:50 <jmcarthur> unless, i suppose, you have some type class like mechanism for using different code based on the types
16:27:56 <jmcarthur> but then there's nothing special happening anyway
16:30:05 <Ralith> I don't think anything special needs to be happening :P
16:31:38 <Peaker> what are the difficulties with auto-transforming code to be tail-recursive when it's known to be strict?  i.e:   foo f (x:xs) = f x : foo f xs   to something like:   foo f (x:xs) acc = foo f xs (acc . (f x :))  ?
16:31:59 <Peaker> (auto accumulating the functions being applied to the non-tail-recursive result)
16:33:17 <Ralith> Peaker: doesn't that translation use O(n) space too?
16:34:07 <Peaker> Ralith, Well, for foo=map here, isn't that inherent?
16:34:24 <Peaker> (for the tail recursive variant)
16:35:22 <Ralith> Peaker: perhaps; I just thought you might choose an example where the improvement wasn't constant-factor.
16:35:37 <Peaker> fac x = fac (x-1) * x  ->   fac x acc = fac (x-1) (acc . (*x))    <-- now this would naively translate to O(n) space, but if optimizer had also known to optimize (*x) . (*y)   to (* x*y)  then it could work
16:36:00 <jmcarthur> what package is the most standardized which provides a proper ListT?
16:36:22 <Peaker> not sure, but we use the "List" package
16:36:24 <int-e> Ralith: The paper is silent on the problem I see. Section 8 starts with "Though this algorithm has not been implemented," which may be why. (The problem is this: Imagine a record of ints { a: int, b: int, c: int, d:int }. In a copying GC, you want to copy that record (easy) and replace it by a forwarding pointer so that other references to that record will continue to be shared. How do you recognize that forwarding pointer...
16:36:27 <jmcarthur> as in ListT Done Right, not as in transformers
16:36:30 <int-e> ...when you encounter that record again?) I wonder though, does the underlying idea of reconstructing types from stack and heap work for dependent types?
16:37:35 <int-e> Ralith: (the problem goes away if you assume that every heap object has at least one pointer; then you can use that pointer field for the forwarding pointer and recognize it by a simple range check)
16:37:52 <Ralith> int-e: I don't know that this technique is necessarily applicable to a copying GC.
16:38:15 <int-e> Ralith: that's claimed in section 6.
16:38:18 <Peaker> jmcarthur, http://hackage.haskell.org/package/List  is nice, but I know other ListT implementations use CPS (for performance? I'm not sure) and/or focus on logic programming capabilities, whereas ListT is mainly focused on having effects in between list cons's
16:38:34 <Ralith> Peaker: optimizing across application boundaries seems very hard.
16:38:48 <jmcarthur> Peaker: thanks
16:39:01 <Fuuzetsu> I have a Haddock module here that imports HscTypes but if I try to import it in GHCi, I get ‘    Could not find module ‛HscTypes’ It is a member of the hidden package ‛ghc-7.7.20130531’.’. How do I go around getting the module into GHCi?
16:39:18 <Peaker> Ralith, I thought GHC does that all the time (basically all RULES?)
16:39:34 <Peaker> or rather, inline+RULES does that all the time?
16:40:14 <skuggi> http://hpaste.org/89104  Could someone help me understand this mysterious error message?
16:40:40 <int-e> Ralith: (The emphasis of the whole paper is on type reconstruction - which I easily believe will work for Hindley-Milner type systems. It's the small technical details where I'm not quite convinced.)
16:40:52 <shachaf> skuggi: Perhaps it would be less mysterious if you had access to the code that caused it.
16:41:22 <jmcarthur> Peaker: weird, that package depends on transformers and provides a module with the same name as one from transformers
16:41:23 <skuggi> It complains about unboxed tuples in function arguments, when the unboxed tuple is in the return type
16:41:39 <Peaker> jmcarthur, same name? not slightly different?
16:41:45 <jmcarthur> Control.Monad.Trans.List
16:41:54 <skuggi> shachaf: sure, but it's not very readable. it's generated code
16:41:58 <monochrom> Fuuzetsu: "ghci -package ghc"
16:42:12 <jmcarthur> Peaker: they look like exactly the same name to me
16:42:36 <Fuuzetsu> monochrom: Lovely. Is there a way to get it in after GHCi has been started?
16:42:39 <monochrom> I love playing the role of the GHC user's guide
16:42:45 <skuggi> shachaf: the part it complains about is in the first paste
16:42:49 <Peaker> jmcarthur, interesting, I don't recall why this works :) let me check
16:42:52 <monochrom> ":set -package ghc" may work
16:42:56 <skuggi> http://hpaste.org/89105  here's all of the code
16:42:58 * jmcarthur is afraid to install it
16:43:05 <shachaf> skuggi: λ> :t let x3 :: Int# -> Int#; x3 = undefined in (\ x0_0 x0_1 -> (# (x0_0 +# 1#), let t0 = x0_1 in x3 t0 #) )
16:43:10 <shachaf> Works for me in ghci.
16:43:14 <Ralith> Peaker: if you inline everything, of course it becomes trivial, but at that point you don't even get anything from the tail recursive transformation, and it's only useful in trivially constant cases besides
16:43:17 <wavewave> what would be the best way to obtain egl context in haskell? hm
16:43:19 <shachaf> Oh, you have a Word#.
16:43:40 <skuggi> shachaf: yeah, the strange this is, it seems to be complaining about the type signature.
16:43:43 <shachaf> That works for me in ghci too, if you change x3's type. :-)
16:43:46 <Fuuzetsu> monochrom: Yep, that worked. Thansk.
16:43:48 <Peaker> jmcarthur, oh, now I see, Control.Monad.ListT is the one you're supposed to use
16:43:50 <Fuuzetsu> Thanks*
16:43:55 <shachaf> skuggi: Oh, you pasted the code.
16:44:00 <Peaker> jmcarthur, whereas Control.Monad.Trans.List shadows transformers' one because it is wrong, to make sure you don't use it :)
16:44:06 <Ralith> int-e: it seems to me that the technique described that section solves the problem you describe, though perhaps I don't understand you
16:44:14 <jmcarthur> Peaker: it's still weird, but okay
16:44:25 <jmcarthur> i didn't realize module shadowing worked
16:44:39 <wavewave> somehow, haskell libraries abstract things too well, so I cannot get the actual C struct or type out of that.
16:44:44 <Peaker> jmcarthur, I personally think it's the wrong thing to do here, but yairchu thinks nobody should ever ever use Control.Monad.Trans.List so he took the liberty of forbidding it
16:44:49 <Ralith> int-e: the first word of the object in from-space is replaced with the forwarding pointer, regardless of whether the object actually has a pointer space
16:44:56 <Peaker> jmcarthur, I think there are probably some circumstances where you might need to work around stuff and use it
16:45:05 <Ralith> a pointer element, that is
16:45:18 <skuggi> shachaf: i tried to boil it down like this: http://hpaste.org/89106
16:45:20 <Peaker> jmcarthur, the module shadowing breaking the compilation rather than working is what he depends on here :)
16:45:24 <skuggi> but that seems to work.
16:45:25 <jmcarthur> Peaker: i'd be fine with Control.Monad.Trans.List if it just had a more specific constraint on its Monad instance (and whatever other instances should be more strict about the underlying monad)
16:45:34 <Peaker> Ralith, you can't inline the recursive application in "map" though but you can inline the (x*).(y*) part
16:45:35 <jmcarthur> Peaker: ah
16:46:04 <jmcarthur> Peaker: iirc, it's a perfectly fine monad as long as the underlying monad is commutative
16:46:10 <Ralith> Peaker: there is no (x*).(y*) part unless you've inlined the recursive application.
16:46:10 <int-e> Ralith: Right. So how do you distinguish between a record of ints that has a forwarding pointer in its first word and a record of ints whose first word *looks like* a forwarding pointer of the right type?
16:46:27 <shachaf> skuggi: I suspect the problem isn't where you think it is. :-)
16:46:45 <shachaf> skuggi: Do you happen to have a full .hs file that exhibits it?
16:46:56 <shachaf> (What's generating this code, by the way?)
16:47:08 <jmcarthur> Peaker: gah, no Alternative instance, either :(
16:47:22 <Ralith> int-e: ah, good question; hm.
16:47:28 <Peaker> jmcarthur, He'll accept pull requests for that
16:47:35 <jmcarthur> yeah...
16:47:55 <jmcarthur> guess i'll just use this. thanks
16:47:58 <Ralith> int-e: (and, of course, I can't say for sure how well this will work for DT; it's a research area, but one I'd like to plumb)
16:48:19 <skuggi> shachaf: no. it's a template haskell splice, and what i get from -ddump-splices doesn't compile
16:48:35 <skuggi> shachaf: http://hpaste.org/89105  here's how ghc outputs the splice
16:48:46 <Ralith> (my expectation is that it will work just fine)
16:49:42 <Ralith> int-e: trivially, you could keep a record of the from-space regions you've copied and check against it, though that might not perform well
16:49:59 <Ralith> though, perhaps it would
16:50:02 <Ralith> IntSet is very fast.
16:50:02 <Peaker> Ralith, I think a lot of the difficulty with optimizers, is that the whole optimization process is an opaque phase after you're done with the text source file
16:50:16 <Ralith> Peaker: I don't know what you mean
16:50:48 <shachaf> skuggi: Do you have anything I can compile to see the probem myself?
16:50:52 <shachaf> Even THed code.
16:50:57 <Peaker> Ralith, if the whole compilation process was more interactive, annotating the source objects and perhaps the intermediate compilation results of those, seeing what the optimizations passes do rather easily in the interactive IDE, then optimizers could have far more useful input
16:51:36 <shachaf> (For example what's runMutableArray?)
16:51:46 <jmcarthur> Peaker: i've wanted something like this for years
16:51:48 <shachaf> (Or Eval.)
16:51:52 <Peaker> Imagine a profile shows a hotspot, streamlining the whole "-ddump-core"/etc process experts use and others fear into the IDE and adding new annotation features on the source, which can be hidden when normally viewing the code would be awesome
16:52:03 <Ralith> oh, sure, better tools are always nice
16:52:03 <Peaker> jmcarthur, it's in the (very) long term plans for lamdu
16:52:23 <jmcarthur> Peaker: i've envisioned optimization passes looking a lot like Coq tactics or something
16:52:32 <jmcarthur> Peaker: somewhat automated, but human guided
16:52:39 <Peaker> jmcarthur, and less opaque
16:52:46 <jmcarthur> yup
16:53:09 <skuggi> shachaf: runMutableArray arr = unsafePerformIO (arr >>= unsafeFreeze)
16:53:12 <Peaker> you could annotate certain optimizations as "must occur" or such so that if something breaks performance later you get a warning/error about it
16:53:34 <jmcarthur> Peaker: essentially computer assisted program derivation
16:53:52 <jmcarthur> would allow for both better optimizations and higher level code
16:54:01 <Peaker> yeah.. the parallel with proof derivation is a nice insight
16:54:13 <skuggi> shachaf: it turns an IO (IOUArray Int a) into a UArray Int a
16:54:50 <Peaker> jmcarthur, and more redundancy to maintain, unfortunately, but that's a nicer downside than having to switch to lower-level languages for those parts altogether
16:55:01 <skuggi> shachaf: i'm going to try to get the splice code to ocmpile.
16:56:08 <wavewave> is there any way to get X11 display out of Gdk display in gtk2hs?
16:56:31 <jmcarthur> Peaker: i think for the most part, you could just use very high level, "intelligent" optimization tactics, with quite general types. you only have to deal with much extra redundancy when you're trying to do something tricky
16:56:41 <int-e> Ralith: in some more detail, http://hpaste.org/89107
16:56:43 <wavewave> ah. maybe using displayGetName can do that.
16:57:22 <shachaf> skuggi: Sigh, the pretty-printer isn't putting parentheses around lambdas.
16:58:17 <skuggi> shachaf: yeah
16:58:18 <Ralith> int-e: yes; what do you think of using an IntSet or similar to store locations that have been converted into forwarding pointers?
16:58:22 <FreeFull> Pretty-printer for error messages?
16:59:35 <int-e> Ralith: hmm, I think that sounds bad for locality, and will use more memory than the tags that you're saving.
17:00:31 * shachaf gives up on simplifying that thing, especially without the original code.
17:00:38 <shachaf> Good luck.
17:00:45 <skuggi> thanks :)
17:00:45 <Ralith> int-e: do you know the space complexity of patricia trees?
17:01:35 <skuggi> shachaf: the whole project i kinda big and has a bunch of dependencies so i wouldn't bother you with it.
17:02:43 <int-e> Ralith: (you could use a bitmap of size (heap size / word size in bits)--one bit per word--though that's cheating, providing "external" space for tags.
17:03:44 <int-e> Ralith: hard to say, but getting below two pointers per internal node is expensive (in terms of runtime), I think.
17:04:18 <Ralith> maintaining boolean tags for the copy process is distinct from maintaining type tags throughout all execution.
17:04:51 <Ralith> I think IntMap is a lot more efficient than you expect, am verifying
17:05:17 <irene-knapp> the efficiency of IntMap depends on how much it updates, surely?
17:06:43 <jmcarthur> ah, it actually turns out I want FreeT [] rather than ListT anyway
17:08:00 <int-e> Ralith: IntMap Int is easy. ignoring the actual stored data, we have 3 words per 'tip', that is, per entry, and another 5 words per internal node, for a whopping 8 words per entry.
17:08:31 <Ralith> int-e: we can use a set, not a map, since all we care about is membership
17:08:36 <Peaker> jmcarthur, what is this for?
17:09:04 <Ralith> int-e: but your bitmap idea might work better.
17:09:28 <int-e> Ralith: right. then it all depends on how dense your data is
17:10:28 <int-e> Ralith: it will occupy 8 words for each populated interval of length 64 (or 32 if int is 32 bits) in the range of ints.
17:11:14 <jmcarthur> Peaker: i already had a CPSified implementation of this because it's what came more naturally to me, but i decided to run with a more clear implementation and had to reverse engineer myself. the monad tracks transformations on all objects (the leaves) in a scene.
17:11:47 <Ralith> int-e: so it seems clear that it's functional; it may or may not be feasible to obtain a performance improvement in the specific case of a structure-preserving copy collector.
17:13:16 <int-e> Ralith: personally, I'd probably go with the restriction that each heap object should have at least one pointer field.
17:13:27 * Ralith shrug
17:13:49 <int-e> but I'm not inclined to try an actual implementation anytime soon
17:14:09 <Ralith> and I don't expect to use a copying collector in my own efforts
17:14:31 <int-e> And I don't see how not copying helps you.
17:14:31 <Peaker> jmcarthur, I've never used Free/FreeT myself. Now looking at FreeT, I'm having trouble figuring out the significant difference between FreeT f m and FreeT (f :. m)   (I guess at the outer-most layer, it's wrapped by m but not f)?
17:14:42 <Ralith> int-e: ..?
17:14:46 <Peaker> jmcarthur, Free (f :. m)  that is
17:15:01 <Ralith> int-e: you don't see how not copying helps you solve a problem exclusive to copying collectors?
17:15:06 <jmcarthur> Peaker: the latter, for one, doesn't apply m to the Return value
17:15:46 <jmcarthur> Peaker: but more to the point, FreeT wraps the whole thing in m, including the choice of constructor
17:16:14 <jmcarthur> Peaker: whereas Free (f :. m) or Free (m :. f) would have the choice available at its head
17:17:13 <int-e> Ralith: I guess then you have to keep track of live objects anyway.
17:17:28 <Peaker> FreeT f m = m :. f :. m :. .... :. f :. m :. Identity     so the only difference seems to be one extra m wrapper
17:17:53 <carter> jmcarthur i've thought about the interactive refinement optimization stuff myself
17:18:05 <Peaker> Free (f :. m) = f :. m :. ... :. f :. m :. Identity...  So FreeT f m a = m (Free (f :. m) a) ?
17:18:12 <int-e> Ralith: in that sense the problem does indeed not add to your burden.
17:18:51 <Peaker> or rather:    FreeT f m = m :. Free (f :. m)
17:20:05 <Peaker> jmcarthur, so:  FreeT [] m =  [] :. Free ([] :. m),  if you ignore the outer-most wrapper (which I think is probably ignorable usually?)  then it's pretty much the Free form of ListT m ?
17:20:58 <Peaker> hmm.. I guess not.. it's more of a [] at the bottom, rather than on top
17:21:32 <jmcarthur> Peaker: it's more of a tree than a list
17:21:35 <carter> acfoltzer : the tristan libs are nice
17:22:05 <Peaker> jmcarthur, yeah:   FooT []    tends to be a tree, whereas ListT m  tends to be a linear structure with effects at each cons
17:22:21 <Peaker> jmcarthur, so it sounds like what you have/need is more like the former
17:22:46 <Ralith> int-e: what do you mean?
17:22:50 <Peaker> And of course: ListT []   is exactly a tree
17:23:08 <int-e> Ralith: what kind of GC do you want to implement?
17:27:03 <FreeFull> Is it valid to stack a monad transformer more than once?
17:27:15 <FreeFull> So for example  ListT ListT IO
17:29:40 <zRecursive> @unmtl ListT ListT IO String
17:29:40 <lambdabot> [IO] [String]
17:30:07 <Ralith> that looks inconsistent
17:30:20 <Ralith> int-e: what sort of 'keeping track' do you have in mind?
17:31:07 <Saizan> @unmtl ListT (ListT IO) String
17:31:07 <lambdabot> IO [[String]]
17:31:58 <Saizan> FreeFull: anyhow yes, you can stack them, ListT from mtl is a bit dodgy in particular though
17:33:29 <int-e> Ralith: Every GC has to separate live data (survivors) from dead data. The information about this separation must be available somehow so that the dead data can be reused for allocation. In mark & sweep garbage collectors, heap objects typically carry one or two bits of information for that purpose. In the copying GCs, the information is implicit; the survivors are those that were copied into to-space; the rest will be...
17:33:35 <int-e> ...discarded. (As a side note, this easy identification of dead data, together with linear allocation (just increment a pointer) is why copying GCs are so popular.) But the point is, if you don't move (copy) objects, the information about survivors must be stored in a different way.
17:34:52 <Peaker> FreeFull, sure, ListT IO  is like a list where each "rest of list" in the (:) pair has an IO around it.. like:  data (ListT IO) a = [] | a : IO [a].    ListT (ListT IO) is like a list, where each (:) has not a single rest-of-list, but a (ListT IO) of them. so many IO-threaded lists of next lists.. basically a tree where each of the nodes in the tree is linked to each child node through an IO action
17:36:26 <Peaker> @unmtl StateT s1 (EitherT e (StateT s2 Identity)) a
17:36:27 <lambdabot> s1 -> EitherT e (StateT s2 Identity) (a, s1)
17:36:55 <Peaker> @unmtl StateT s1 (ErrorT e (StateT s2 Identity)) a
17:36:55 <lambdabot> s1 -> s2 -> (Either e (a, s1), s2)
17:37:44 <Peaker> FreeFull, ^^ much easier to grok this example:   Two State transformers in same stack, in both ends of an ErrorT:  both states are input alike, but only s2 available in case of error. s1 only available in success
17:38:07 <Ralith> int-e: er, with static type information you can work solely from stack roots...
17:40:48 * zRecursive the result of unmtl is much clear than its original version
17:41:25 <int-e> Ralith: I wasn't talking about roots. I was talking about the GC itself, which takes the roots and then does <something> and finally should release some memory for future allocation, based on information collected during <something>.
17:42:12 <Fuuzetsu> @src </>
17:42:12 <lambdabot> Source not found. Are you on drugs?
17:42:14 <Fuuzetsu> :t </>
17:42:16 <lambdabot> parse error on input `</>'
17:42:21 <Fuuzetsu> :t (</>)
17:42:22 <lambdabot>     Not in scope: `</>'
17:42:23 <lambdabot>     Perhaps you meant one of these:
17:42:23 <lambdabot>       `<>' (imported from Data.Monoid),
17:43:27 <byorgey> Fuuzetsu: where did you see </> ?
17:43:28 <int-e> Ralith: You can discard the data again after GC, but it still contributes to your total memory usage.
17:44:13 <int-e> (and GC runtime etc.)
17:44:23 <ChongLi> why is it Data.Monoid and not Control.Monoid?
17:44:43 <merijn> ChongLi: Because the difference between Data and Control is mostly arbitrary
17:44:57 <ChongLi> hehe
17:45:26 <dmwit> Data/Control is simultaneously too fine (they don't meaningfully distinguish anything) and not fine enough (damn near everything goes under one or the other of them).
17:45:30 <Fuuzetsu> byorgey: it's okay, it's just FilePath
17:45:39 <byorgey> Fuuzetsu: ah, right
17:45:47 <Fuuzetsu> It looked familiar but I didn't think it was from Applicative so I got confused
17:46:06 <byorgey> right, definitely not Applicative =)
17:46:55 <ChongLi> dmwit: this is always the problem with classification
17:47:11 <int-e> Ralith: let's continue this on #haskell-overflow (currently quiet) or in private messages.
17:47:28 * byorgey recommends using Data if you make a module which literally implements a general-purpose data structure; Control if you come up with some fundamental new way of structuring computation/control flow (e.g. Applicative), and staying far away from them otherwise.
17:48:15 <byorgey> Data.Monoid should just be called Monoid.
17:48:58 <Peaker> Where should Functor be?
17:49:05 <ChongLi> what about grouping algebraic structures together?
17:49:17 <dmwit> What if we had an "Algebra" hierarchy?
17:49:19 <byorgey> There might be an argument for  Algebra.Monoid  or something like that.
17:49:21 <byorgey> sure.
17:49:22 <dmwit> Or something similarly named.
17:49:35 <shachaf> Easy.Monoid
17:49:36 <dmwit> Something generic enough that categorical constructs would be allowed. =)
17:49:48 <tikhonjelvis> then again, why have the hierarchy at all?
17:49:52 <shachaf> import Nonsense.Abstract.Category
17:49:55 <byorgey> StuffNamedForMathConcepts.Monoid
17:50:00 <ChongLi> then we could have Algebra.Semigroup, Algebra.Quasigroup, Algebra.Abeliangroup
17:50:04 <ChongLi> would be great!
17:50:13 <dmwit> Oh, Math. wouldn't be too horrible.
17:50:28 <tikhonjelvis> hmm, I would assume Math.* would be for *doing* math
17:50:33 <tikhonjelvis> rather than *using* it
17:50:33 <byorgey> we already have Math.  It tends to be for more computation-oriented stuff as opposed to abstraction-oriented.
17:50:37 <tikhonjelvis> if you see the distinction
17:50:44 <dmwit> uh huh
17:50:53 <ChongLi> byorgey: which is silly when you think about it
17:51:03 <ChongLi> math *is* the abstraction-oriented stuff
17:51:11 <byorgey> I don't think it's silly.
17:51:24 <ChongLi> the computation-oriented stuff ought to be grouped under Computation
17:51:25 <tikhonjelvis> it certainly makes sense to differentiate between the two
17:51:36 <ChongLi> but that'd be too general
17:51:38 <ChongLi> or something
17:51:44 * byorgey actually doesn't care what color the bikeshed is
17:51:47 <ChongLi> naming is hard
17:52:08 <tikhonjelvis> maybe we should just put all the monoid stuff in the prelude
17:52:12 * byorgey just likes riding bikes around
17:52:15 <dmwit> byorgey: Liar! You have already expressed your dislike for the bikeshed colored Control/Data.
17:52:41 <ChongLi> it seems like the prelude is basically locked down at this point
17:52:46 <byorgey> touché!
17:53:09 <shachaf> Bicycle haters unike!
17:53:28 <dmwit> groachaf
17:53:30 <int-e> Control.Data.Foldable  and  Data.Control.List
17:53:52 <int-e> ("lists are our loops", did Cale say that?)
17:53:52 <ChongLi> ugh
17:53:57 <ChongLi> now that is abhorrent
17:54:01 <ChongLi> Control.Data
17:54:05 <ChongLi> and Data.Control
17:54:06 <Cale> int-e: I did
17:54:06 <dmwit> Yes, the thing that Data.Data.Data is missing is Control.Data.Data.Data
17:54:11 <tikhonjelvis> hmm, is there something wrong with just having, say, Foldable and List?
17:54:29 <tikhonjelvis> that is, does the extra level of hierarchy do anything except make it look hierarchical?
17:54:32 <enthropy> that would be Haskell-98
17:54:40 <tikhonjelvis> yes
17:54:40 <Cale> Data.Adjective.Noun.Verb.Verb.Verb
17:54:45 <Peaker> Maybe we could have "import Prelude<Version>" and maintain backwards compatibility regarding old names having old semantics, and no new names, but still let us upgrade prelude?
17:54:54 <tikhonjelvis> and I see the advantage of having hierarchical modules for most libraries
17:55:02 <tikhonjelvis> but not necessarily for really basic things like lists
17:55:04 <Peaker> so old code could work with new "base" and we could improve Prelude nicely?
17:55:19 <tikhonjelvis> but maybe I'm missing something obvious?
17:55:19 <ChongLi> no you never want to put versions in your imports
17:55:35 <Peaker> ChongLi, it's not a package version -- it's an export signature version
17:55:49 <Cale> Data.Bold.ModuleNamingSchemes.Crafting.Inventing.Following
17:55:50 <Peaker> ChongLi, every time Prelude is changed in a backwards incompatible way, you bump that
17:56:01 <Peaker> ChongLi, even if only new names were added
17:56:22 <ChongLi> still don't like it
17:56:48 <Peaker> instead of making the whole package only linkable with an old base -- you'd just have a facade API for emulating older Preludes
17:56:50 <Cale> (I wonder if anyone gets what I'm referencing)
17:57:03 <carter> Cale daft punk?
17:57:12 <Cale> Nope
17:57:15 <carter> darn
17:57:18 <carter> Lens?
17:57:25 <carter> kmett?
17:57:27 <ChongLi> just leave the prelude alone; if someone wants to write an alternative one they can
17:57:28 <Cale> http://www.faqs.org/faqs/verb-verb-verb/
17:57:34 <ChongLi> there have been a few
17:58:01 <ChongLi> and stick with semver in the package versions
17:58:17 <Saizan> tikhonjelvis: http://www.haskell.org/ghc/docs/latest/html/libraries/ <- take this, if you removed the hierarchy you'd have closely related modules scattered over the place
17:58:47 <Saizan> tikhonjelvis: if we don't get too deep it's quite tidier this way
17:59:15 <tikhonjelvis> Yes, I see it in general, but I'm deeply unconvinced by much of Control and Data
17:59:37 <tikhonjelvis> also, what's up with Numeric?
18:00:04 <Saizan> i like that Applicative, Category and Monad are together
18:00:12 <shachaf> tikhonjelvis would rather use  than Control
18:00:20 <shachaf> I bet his editor changes it automatically.
18:02:37 <shachaf> import Control.Monad.Trans.Die.Die.Die
18:05:16 <Peaker> import Control.Monad.Trans.Class (MonadIO (lift))
18:05:28 <Peaker> lamdu will resolve all this :-)
18:05:40 <shachaf> It'll make monad transformers good?!
18:06:05 <Peaker> well, at least their imports :)
18:06:10 <irene-knapp> will it make free monads 1,000 times more efficient?
18:06:25 <shachaf> 1,000 times cheaper
18:06:43 <irene-knapp> 1,000 times free is free =p
18:07:01 <shachaf> What's 1,000 times cofree?
18:07:28 <irene-knapp> I don't know, but it sounds like it would induce bad physiological side-effects
18:07:54 <no-n> 1,000 coffees?
18:07:57 <irene-knapp> yeah
18:08:07 <no-n> :}
18:08:10 <irene-knapp> (not really.  we were punning.)
18:09:19 <Peaker> shachaf, I take it you don't like monad transformers?
18:09:48 <shachaf> They're a mostly-inelegant mostly-mess.
18:09:54 <shachaf> Not that I know how to do it better.
18:10:10 <irene-knapp> really?  I find them pretty elegant…. except for the efficiency problem :(
18:14:21 <Cale> It's very easy to apply them in cases where they're not actually helping you accomplish your goals.
18:14:41 <irene-knapp> true
18:15:17 <Cale> e.g. in cases where you'd otherwise not have considered creating a new monad
18:17:10 <shachaf> Cale: It might be that I'd not've considered creating a new monad because of the overhead, but I still want monady behavior.
18:18:09 <shachaf> A monad like Maybe is useful. IO is... Well, useful too. But you can't get Maybe-y behavior with IO actions normally. Perhaps it's worth just using transformers directly in a case like that.
18:20:15 <hiptobecubic> Is anyone familiar with the SREP compression algorithm? I only ask here because I was surprised to find that it was implemented in haskell
18:20:30 <hiptobecubic> part of FreeArc?
18:21:30 <irene-knapp> no, what is it?
18:21:36 <hiptobecubic> http://freearc.org/Research.aspx
18:21:43 <irene-knapp> ah!  neat
18:21:52 <irene-knapp> that sounds very awesome for, uhhhhhh
18:21:56 <hiptobecubic> Well specifically, this http://freearc.org/research/SREP.aspx
18:22:16 <irene-knapp> compressing the data files of the http://en.wikipedia.org/wiki/Large_Synoptic_Survey_Telescope
18:22:44 <irene-knapp> which has generated, I'm told, a hundred or so exabytes of data without anyone thinking too deeply about how the h*ll to store it all
18:22:49 <hiptobecubic> Well maybe. There are binaries on the site, but the source is a total mess
18:22:53 <irene-knapp> ahh
18:23:19 <irene-knapp> often happens with research code, unfortunately
18:23:22 <hiptobecubic> i think the comments and the source actually have different encodings O_o
18:23:25 <irene-knapp> ouch!!!!
18:23:27 <irene-knapp> that hurts :)
18:23:51 <hiptobecubic> and there is a really ugly makefile system thrown together
18:23:58 <irene-knapp> I hate those :(
18:24:06 <wavewave> so familiar to me.
18:24:39 <hiptobecubic> it looks like he wrote this with windows and its miserable software management infrastructure in mind, then just made some tweaks to get it to work on linux, ignore all convention
18:24:42 <hiptobecubic> ignoring*
18:25:05 <irene-knapp> yuck :(
18:25:12 <irene-knapp> but it has a Haskell reimplementation?
18:25:15 <irene-knapp> that's awesome if so
18:25:20 <hiptobecubic> Anyway, it's not particularly important. I just wondered if anyone had seen it before
18:25:24 <irene-knapp> yeah
18:25:25 <irene-knapp> I haven't
18:25:29 <hiptobecubic> irene-knapp, no. The original is in haskell.
18:25:48 <hiptobecubic> http://freearc.org/download/0.666/FreeArc-0.666-sources.tar.bz2 hold your nose and take a look
18:26:00 <irene-knapp> no, I'm in a hurry :(
18:26:03 <irene-knapp> but I see :(
18:26:10 <hiptobecubic> fair enough
18:26:15 <hiptobecubic> I'm off to bed
18:26:16 <irene-knapp> well, people can write bad code in any language :(
18:26:17 <irene-knapp> night!
18:26:59 <hiptobecubic> I don't have any reason to think the code is bad necessarily. The program appears to work and the results are impressive, but the build system is just really badly written
18:27:03 <hiptobecubic> night
18:28:04 <irene-knapp> well, people can follow bad programming practices, lol
18:34:24 * hackagebot git-annex 4.20130601 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20130601 (JoeyHess)
18:34:45 <irene-knapp> interesting concept
19:44:07 <tomjack> is a cofree comonad a fixpoint of functor representation?
19:44:43 <tomjack> I mean if representation is log, what's exp?
19:45:58 <shachaf> tomjack: I'm not sure I understand your question.
19:46:34 <tomjack> I'm not sure I do either
19:48:10 <tomjack> 'representing applicatives' had a note about representation being a type-level logarithm
19:48:45 <shachaf> sclv's article?
19:48:55 <shachaf> comonad.com is still down. :-(
19:48:57 <tomjack> yeah :(
19:49:12 <tomjack> I just realized that, uh, exp is obviously the inverse of log
19:49:21 <shachaf> edwardk: What's keeping it down?
19:49:36 <sclv> exp is actually more common
19:49:49 <sclv> a -> b ~= b^a
19:49:58 <shachaf> It's logBase b, presumably, not base e.
19:49:58 <tomjack> I was really wondering whether there is a functor 'that it is own representation'
19:49:59 <sclv> you can figure this out intuitively by "counting inhabitants"
19:50:01 <tomjack> not sure what that means though
19:50:19 <tomjack> if it means
19:51:04 <sclv> a representable functor is just a functor that's equivalent to (->) r for some r.
19:51:20 <sclv> so any functor of the form (->) r for some r is 'its own representation' in that sense
19:51:46 <tomjack> I see, thanks
19:52:18 <tomjack> I was also confused by thinking about type-level derivative, my 'exp' failing to refer to the fixpoint of that
20:07:45 <edwardk> shachaf: haven't had time to fix up DNS and setup wordpress and i need to talk to the guy who set up the box to get in and try to remember how all my latex crap worked
20:08:44 <carter> edwardk mathjx
20:08:45 <carter> do it
20:19:50 <DiegoNolan> when i run the command: $ cabal install yesod-bin
20:19:53 <DiegoNolan> i get this error
20:20:11 <DiegoNolan> cabal: Could not resolve dependencies: trying: yesod-bin-1.2.0 (user goal) next goal: ghc (dependency of yesod-bin-1.2.0)
20:20:17 <DiegoNolan> anyone know what the deal is?
20:22:22 <geekosaur> what version of ghc do you have installed?
20:23:53 <DiegoNolan> 7.4.1
20:26:37 <shachaf> edwardk: If you have all the posts in some plaintext format or something, could you just put those up somewhere?
20:27:01 <edwardk> i'm just going to fix the site. the posts are all in the crappy little wordpress mysql database for it
20:27:25 <edwardk> carter: sounds good. i'll grant you access, and you can make it happen ;)
20:27:33 <carter> WAT
20:28:01 <edwardk> carter: glad you volunteered
20:28:10 <dmwit> Complaining about open source projects is dangerous.
20:28:44 <dmwit> DiegoNolan: ghc-pkg list ghc
20:28:48 <carter> i wasn't complaining
20:28:59 <shachaf> edwardk: I'll volunteer to have a look at the mysql database if you upload it somewhere! (If it's not too big.)
20:28:59 <carter> i was just saying i'm happy with mathjax in my own uses
20:29:00 <dmwit> DiegoNolan: Also, you should probably give the whole output of the failed command.
20:29:34 <bos> i swear that 75% of the time i try to use GADTs, i tie myself in mental knots
20:29:50 <DiegoNolan> that was the full thing
20:29:54 <edwardk> shachaf: i sent off an email asking for a copy of it off the old box. when i get it, i can start working on fixing up the new one and/or send you a copy
20:30:01 <DiegoNolan> i have broken packages though
20:30:13 <DiegoNolan> and it looks like yesod-auth and core are one of them
20:30:14 <edwardk> bos: what has you twisted up?
20:30:17 <dmwit> I'm going to blame that until I have a better idea. =)
20:30:22 <shachaf> OK.
20:30:45 <bos> edwardk: criterion has a very simple core GADT that describes the things you want to benchmark, and I want to extend it
20:31:16 <bos> edwardk: it looks like this right now: https://github.com/bos/criterion/blob/master/Criterion/Types.hs#L114
20:31:32 <bos> and i want to add the ability to measure two things and compute their difference
20:32:04 <bos> but the only thing that it makes sense to compute the difference of is two individual benchmarks, represented by the Benchmark constructor
20:32:20 <edwardk> then unpack it instead of using Benchmark -> Benchmark -> Benchmark
20:32:28 <bos> i'd like to represent this in the type itself
20:32:36 <dmwit> BenchDifference :: (Benchmarkable b, Benchmarkable b') => b -> b' -> Benchmark -- ?
20:32:40 <edwardk> use (Benchmarkable a, Benchmarkable b) => String -> a -> String -> b -> Benchmark
20:32:50 <dmwit> right
20:32:51 <edwardk> or no strings or what have you
20:32:56 <bos> yes, that would work
20:33:09 <bos> it's just fuglier than i hoped for
20:33:27 <edwardk> alternately you could refactor things so you had a simple individual benchmark type, and then make this type be some kind of Benchmarks, made out of individual ones
20:33:35 <edwardk> if i had it to refactor. i'd go with
20:33:43 <dmwit> Another option is to add a phantom parameter that's a type-level bool saying whether something is a Benchmark-constructor or not...
20:34:00 <edwardk> data Benchmark = forall b. Benchmarkable b => Benchmark String b
20:34:03 <dmwit> Or skip the phantom parameter and just make two types. =)
20:34:07 <bos> dmwit: i tried it with a phantom parameter, but it kills type inference later
20:34:30 <edwardk> data Benchmarks = Single Benchmark | Group String [Benchmark] | Compare [Benchmark] | Diff Benchmark Benchmark
20:34:53 <dmwit> Right, this is the "skip the phantom parameter and just make two types" thing.
20:34:54 <dmwit> right
20:34:55 <edwardk> er Group String [Benchmarks]
20:35:03 <dmwit> Better that you've spelled it out, though.
20:35:03 <bos> edwardk: right, that's probably a better option
20:35:29 <edwardk> also, there is another simpler point in the design space you can do
20:35:31 <shachaf> Why is there an existential type here at all?
20:35:35 <bos> i suppose i also face the question of "how much can i monkey with the types in a widely used package, even if nobody uses the package in production?"
20:35:45 <edwardk> right now you have an existential parameter for things that are benchmarkable
20:35:47 <shachaf> Looks to me like a function would fit better.
20:36:00 <edwardk> but that is better served as just the function that that represents
20:36:12 <edwardk> data Benchmark = Benchmark String (Int -> IO ())
20:36:15 <edwardk> is much simpler
20:36:17 <shachaf> I.e. Benchmark :: String -> (Int -> IO ()) -> Benchmark
20:36:36 <edwardk> (in the split Benchmark/Benchmarks model)
20:36:48 <edwardk> and no functionality is lost
20:36:49 <sclv> i suspect 95% of criterion users use the default functions since they give the core use cases out of the biox
20:36:52 <bos> shachaf: the existential is there because that's what i thought of at the time
20:37:33 <bos> sclv: i'd guess it's closer to 100%
20:37:36 <edwardk> bos: sure, its just one of those things that i tend to spot and rewrite out of my code when i realize i'm getting no benefit from it
20:37:49 <sclv> :-P
20:38:09 <bos> edwardk: criterion could do with a good refactor.
20:38:28 <shachaf> bos: OK. :-) Existential types like this are often simpler if you just use the typeclass dictionary directly.
20:39:19 <bos> yeah
20:39:39 <bos> i spent much of the day on a statistical snipe hunt around this, too.
20:40:03 <bos> namely how to safely compute differences of statistical estimators
20:40:26 <bos> turns out it's only slightly more complex than plain old arithmetic, but i had a lot of learning to do to figure that out
20:41:00 <sclv> another bit of low hanging fruit: Compare should probably take be Compare :: Benchmark -> [Benchmark] -> Benchmark
20:41:13 <sclv> since it only makes sense if you have an initial benchmark to compare to
20:41:15 <bos> long detours down the dead end roads of student's t-test and mann-wilcoxon's u-test
20:41:54 <bos> sclv: are you thinking in terms of the totality of the function, or something else?
20:42:16 <sclv> just semantic clarity even
20:42:32 <sclv> the description of bcompare is that it compares everything else against the first element of the list
20:43:04 <sclv> since the first is assumed to be there, in terms of the purpose of the function, and also since it has a different 'meaning' than everything else in the list, its clearer to give it as a different argument
20:43:32 <bos> agreed
20:44:31 * hackagebot free-game 0.9.3.2 - Create graphical applications for free  http://hackage.haskell.org/package/free-game-0.9.3.2 (FumiakiKinoshita)
21:23:51 <dacdave> Problems building Haskell on new Windows 8 laptop. Had it working on Windows 7. Link errors postgresql-2.3.2.1.a(Utils.o):fake:(.text+0x5e8): undefined reference to `PQerrorMessage'
21:24:14 <shachaf> "building Haskell"?
21:24:58 <dacdave> Have haskell soirce code that wa building fine on Windows 7 machine. Trying to move it to my new Windows 8 laptop.
21:25:21 <shachaf> Ah.
21:25:33 <dacdave> Installed PostgreSQL and HDBC-postgresql
21:25:35 <shachaf> Is it the same version of postgresql?
21:25:45 <dacdave> No
21:26:09 <dacdave> new version is latest 9.2 for Windows
21:26:10 <shachaf> @google "undefined reference to PQerrorMessage"
21:26:11 <lambdabot> http://www.postgresql.org/docs/8.1/static/libpq-build.html
21:26:11 <lambdabot> Title: PostgreSQL: Documentation: 8.1: Building libpq Programs
21:26:36 <shachaf> Did you "forget -lpq"?
21:26:45 <shachaf> Maybe cabal did somehow.
21:27:29 <dacdave> Thikn it might be a cabal problem. I am not sure I got the cabal install right for postgresql.
21:28:21 <dmwit> Is it possible you are trying to build from a directory where you previously built, and did not "cabal clean" since then?
21:28:36 <shachaf> Perhaps you should look at cabal -v output.
21:30:15 <dacdave> PQerrorMessage is just one example. I have a loooong list of PQ* methods that the linker cannot find.
21:33:11 <dacdave> bash-4.1$ cabal -v build
21:33:11 <dacdave> creating dist\build
21:33:11 <dacdave> creating dist\build\autogen
21:33:11 <dacdave> Building CreateExcel-1.0...
21:33:11 <dacdave> Preprocessing executable 'CreateExcel' for CreateExcel-1.0...
21:33:11 <dacdave> Building executable CreateExcel...
21:33:11 <dacdave> creating dist\build\CreateExcel
21:33:30 <dmwit> ?tell dacdave Use hpaste.org for long pastes.
21:33:30 <lambdabot> Consider it noted.
21:34:03 <dmwit> ?hpaste
21:34:03 <lambdabot> Haskell pastebin: http://hpaste.org/
21:34:53 <dacdave> Thank you
21:34:53 <lambdabot> dacdave: You have 1 new message. '/msg lambdabot @messages' to read it.
22:00:52 <randomclown> Say I have a data Test = Test [Int] [Int], what's the best way to map function f :: Int -> Int to both of the lists "Test"
22:01:31 <randomclown> Soemthing that does Test [Int] [Int] => Test (map f [Int]) (map f [Int])
22:05:49 <Hafydd> g (Test t1 t2) = Test `on` (map f) t1 t2
22:05:59 <Hafydd> Er...
22:06:15 <Hafydd> g (Test t1 t2) = (Test `on` (map f)) t1 t2
22:06:22 <randomclown> Can it be done with lenses?
22:06:53 <Hafydd> I bet it can.
22:07:17 <randomclown> ahaha
22:08:15 <Hafydd> Or if you made an Applicative instance: fmap (map f)
22:09:02 <Hafydd> Er... well, a Functor instance.
22:10:00 <Hafydd> (It would be dishonest for me to try and advise you on the best way to use Lens, so I'll leave that for someone with more expertise)
22:10:45 <randomclown> Ah ok, I totoally forgot about the functor typeclass
22:11:08 * RenJuan notes Bloomberg is starting up a big Haskell based project.
22:11:56 <latermuse> renjuan: do you know what the project is?
22:12:10 <RenJuan> McDerivates oder
22:13:11 <RenJuan> they actuall say functional p and mention ocaml and Haskell
22:13:18 <RenJuan> *actually
22:13:57 <Hafydd> Also, I suppose the Functor instance would only work if your data type were parametrically polymorphic.
22:14:25 <randomclown> Hafydd: so it can't be specalised to Ints?
22:15:28 <randomclown> fmap :: (Int -> Int) -> Test -> Test
22:15:34 <randomclown> should still work
22:15:49 <RenJuan> ( http://www.bloomberg.com/careers/opportunities/job/show/36230/senior-functional-programmer.html )
22:16:07 <Hafydd> fmap :: (a -> b) -> f a -> f b
22:17:24 <randomclown> Hafydd: next best thing other than functor?
22:18:27 <Hafydd> I don't know. Probably Lens, if it's worth making the instance.
22:24:37 <dmwit> randomclown: You can make a functor instance if you parametrize: data Test a = Test [a] [a]
22:24:47 <dmwit> (In fact, this is just the composition of the Pair and [] functors.)
22:25:27 <dmwit> type Test = Pair `O` []
22:25:40 <randomclown> dmwit: The type I'm using really shouldn't be parametarised though
22:25:48 <shachaf> Then Functor isn't appropriate.
22:26:03 <shachaf> Making a specialized function with its own name and the type you gave is reasonable, though.
22:26:13 <shachaf> Or a traversal, as Hafydd maybe implied.
22:26:26 <dmwit> randomclown: Why not "type Test = (Pair `O` []) Int", then?
22:26:40 <dmwit> You still get to use fmap :: (Int -> Int) -> Test -> Test.
22:26:54 <shachaf> I.e. Applicative f => (Int -> f Int) -> Test -> f Test -- think of it as mapM
22:28:03 <randomclown> dmwit: what's `0`?
22:28:04 <Hafydd> Hahah, Fillet `O` Fish
22:28:19 <dmwit> randomclown: It's a memory error. At the type level, the name is .:
22:28:25 <dmwit> http://hackage.haskell.org/packages/archive/functor-combo/0.3/doc/html/FunctorCombo-Functor.html
22:28:36 <dmwit> http://hackage.haskell.org/packages/archive/functor-combo/0.3/doc/html/FunctorCombo-Functor.html#t::.
22:28:45 <dmwit> argh, :. not .:
22:28:51 <dmwit> dmwit-- for so many errors in a row
22:45:27 <dhun> hello, I would like to embed a file into a ghc executable, I looked at Data.FileEmbed. Ok I know how to embed it but I don't know how I can access it during the program, it is hidden in Q Exp
22:46:17 <shachaf> Q Exp doesn't contain an Exp. It's a program that you can run at compiletime.
22:46:39 <shachaf> Look into templaet Haskell splices or something like that.
22:47:10 <enthropy> @hoogle runQ
22:47:10 <lambdabot> Language.Haskell.TH.Syntax runQ :: Quasi m => Q a -> m a
22:47:11 <lambdabot> Language.Haskell.TH runQ :: Quasi m => Q a -> m a
22:48:21 <shachaf> You don't need runQ.
22:48:38 <shachaf> You shouldn't use it.
22:48:57 <dhun> I tried to read stuff in template haskell but didn't understand it
22:49:32 <dhun> could someone code an example where he embeddes a file at compile time and prints it at runtime
22:50:13 <shachaf> No, you probably won't get someone doing that, since it's a lot of trouble (they have to download and install a new library, figure out how it works, make a new Haskell file, compile it, etc.).
22:50:46 <shachaf> Instead you should make a simple test case -- the closest thing to what you want that you can get to -- and go to http://hpaste.org/ and paste it, along with the error you get.
22:51:01 <enthropy> dhun: you have constructed your value with type Q Exp, right?
22:51:34 <dhun> no I think I get Q Exp from File.Embed but I need String
22:51:58 <enthropy> so if you have  (x :: Q Exp),  ($x :: String) probably
22:52:14 <dhun> ah that might be an idea
22:52:18 <enthropy> provided that you've got {-# LANGUAGE TemplateHaskell #-} at the top of your file
22:52:45 <Kinjen> hi, why is the ghci 2013.2 smaller by 7MB than ghci 2012.4 what files have been removed?
22:53:24 <notdan> Why doesn't cabal-dev pick up dependencies that I've installed with cabal-install? http://hpaste.org/89111
22:54:34 * hackagebot equational-reasoning 0.0.1.0 - Proof assistant for Haskell using DataKinds & PolyKinds  http://hackage.haskell.org/package/equational-reasoning-0.0.1.0 (HiromiIshii)
22:55:26 <enthropy> dhun: these are pretty much working examples http://hackage.haskell.org/packages/archive/file-embed/0.0.4/doc/html/Data-FileEmbed.html
22:55:53 <dhun> I just made it work, thank you enthropy for the $ idea
22:56:20 <shachaf> dhun: What was confusing about the documentation? Maybe you can submit a patch to improve it so it'll be clearer for other people.
22:56:51 <dmwit> notdan: The whole point of cabal-dev is that it's a sandbox, right?
22:57:01 <dmwit> sandbox = doesn't interact with outside environment
22:58:08 <dhun> I saw the Q Exp and was trying to figure out how to get the file back from that type, thinking it might be wrapped in the monad
22:58:34 <dhun> I didn't know the $ syntax, so I overlooked the $ in the documentation
22:59:29 <shachaf> Hmm, you should've tried the working example in the documentation before asking someone here to make a working example. :-)
23:00:01 <dhun> I saw the documentation but somehow didn't see that was a working example
23:00:54 <dhun> I don't know why I didn't see that. Probably because I thought it would return Q Exp and not ByteString
23:01:30 <notdan> right, it's just that i heard someone claiming that it can pickup packages from the outside environment granting it does not modify them
23:04:24 <jnerula> @src <>
23:04:24 <lambdabot> Source not found.
23:06:36 <notdan> @src (<>)
23:06:36 <lambdabot> Source not found. You speak an infinite deal of nothing
23:06:41 <notdan> @src mappend
23:06:41 <lambdabot> Source not found. I am sorry.
23:06:44 <notdan> eh
23:06:52 <notdan> @src Data.Monoid.mappend
23:06:52 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
23:06:54 <notdan> welp
23:14:01 <dmwit> notdan: The implementation is different for each instance of Monoid, of course.
23:14:28 <randomclown> @pl \x y -> (f x) `f` (f y)
23:14:28 <lambdabot> (. f) . f . f
23:14:28 <dmwit> oh
23:14:34 <dmwit> jnerula: That was at you, too.
23:14:34 * hackagebot x509-validation 1.4.4 - X.509 Certificate and CRL validation  http://hackage.haskell.org/package/x509-validation-1.4.4 (VincentHanquez)
23:14:55 <dmwit> randomclown: That's very unlikely to be well-typed.
23:15:06 <dmwit> :t \f x y -> (f x) `f` (f y)
23:15:07 <lambdabot>     Occurs check: cannot construct the infinite type: t1 = t1 -> t0
23:15:07 <lambdabot>     In the return type of a call of `f'
23:15:07 <lambdabot>     Probable cause: `f' is applied to too few arguments
23:15:25 <randomclown> @pl \x y -> (x `f` x) `f` (y `f` y)
23:15:25 <lambdabot> (. join f) . f . join f
23:15:41 <randomclown> Indeed I mistyped it
23:15:43 <dmwit> f `on` join f
23:16:08 <randomclown> dmwit: how do you a case for "on"
23:16:18 <dmwit> ENOPARSE
23:16:19 <randomclown> how do you know when to use "on"
23:16:37 <dmwit> When you are applying a binary operator to a term that has the same function at its head, I guess.
23:16:50 <dmwit> That is, when your code looks like the RHS of "on"... =P
23:19:34 * hackagebot tls-extra 0.6.4 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.6.4 (VincentHanquez)
23:24:34 * hackagebot embeddock 0.3.0.1 - Embed the values in scope in the haddock documentation of the module  http://hackage.haskell.org/package/embeddock-0.3.0.1 (TakayukiMuranushi)
23:28:12 <adnauseam> guys, does this look right to you, http://hpaste.org/89114 ?
23:31:15 <notdan> adnauseam: depends on what are you trying to do?
23:31:55 <Aetherspawn_> Dont indent using tabs adnauseam
23:32:32 <adnauseam> Aetherspawn_: ill fix that in the editor
23:33:33 <adnauseam> notdan: im trying to understand that tree structure and fold over it. right now it seems to be defective since my size function keeps returning 0 for atree
23:33:34 <Aetherspawn_> You've shown f as taking 3 arguments
23:33:51 <Aetherspawn_> Wait, nevermind. Misread.
23:34:00 <adnauseam> notdan: so i think either my understanding for tfold is wrong, or i'm missing something about it
23:34:23 <notdan> adnauseam: I'd recommend to use the fold from here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html#g:1
23:34:27 <adnauseam> well yeah tfold takes 3 arguments since a brach has 3 elements
23:34:56 <adnauseam> notdan: it's an academic exercise - not anything for production. i know about the already existant functions and they are excellent. but i'd like to understand trees better
23:34:58 <notdan> adnauseam: Aetherspawn_ is talking not about yout 'tfold' function but about the 'f' argument you pass to it
23:35:08 <adnauseam> notdan: oh my bad
23:35:41 <adnauseam> notdan: yeah i was talking about it too actually, tfold takes 2 argument,s the anon function takes 3
23:35:55 <adnauseam> it's pretty early here =p
23:36:13 <Aetherspawn_> (For something like this, maybe it would help setting your type in stone where you can see it)
23:37:00 <adnauseam> Aetherspawn_: what do you mean ?
23:39:53 <notdan> adnauseam: writing the type of tfold explicitly
23:39:58 <notdan> writing down*
23:40:16 <notdan> @ty foldr
23:40:17 <lambdabot> (a -> b -> b) -> b -> [a] -> b
23:40:35 <notdan> You want to have something like that for trees, right?
23:40:44 <mamiphin> checking build system type... Invalid configuration `x86_64-unknown-linux-': machine `x86_64-unknown-linux' not recognized configure: error: /bin/bash scripts/config.sub x86_64-unknown-linux- failed
23:40:46 <mamiphin> why?
23:41:05 <mamiphin> haskell-platform-2013.2.0.0
23:41:09 <notdan> So your type must be somethin like (a -> b -> b) -> b -> BinTree a -> b
23:42:25 <Aetherspawn_> tfold :: (BinTree a -> a -> BinTree a) -> a -> BinTree a
23:42:31 <Aetherspawn_> would have been what I came up with
23:42:49 <shachaf> That is not a fold.
23:43:04 <shachaf> notdan's type is a fold, but not for trees.
23:43:38 <Aetherspawn_> Mine is very incorrect, ick.
23:43:54 <notdan> shachaf: why not?
23:44:13 <shachaf> @ty foldr -- because it's a fold for lists
23:44:14 <lambdabot> (a -> b -> b) -> b -> [a] -> b
23:44:46 <notdan> yeah, I was talking about coming up with a type for trees based on a tytpe for lists
23:44:55 <notdan> I was trying to get to Data.Foldable.foldr tbh
23:45:16 <shachaf> Foldable gives you list folds, not real folds. :-(
23:45:22 <shachaf> It loses all structure.
23:46:28 <notdan> Ok, I am not sure what you are saying, shachaf. I understand that foldr looses the structure, but isn't that the point?
23:46:36 <notdan> It folds some strcuture into one value
23:46:39 <latermuse> shachaf: whats the point of using foldable then?
23:46:42 <shachaf> foldr doesn't lose structure for lists.
23:46:52 <shachaf> It's good for lists.
23:47:07 <shachaf> latermuse: Flattening some arbitrary paramteterized type into a list of values.
23:47:31 <latermuse> i understand what foldable does. but if it only works on lists, then why would you use it for anything else?
23:47:59 <shachaf> It works on everything that's an instance of it.
23:48:15 <shachaf> It's just not a "fold", not in the usual sense. It just turns things into a list.
23:48:28 --- mode: ChanServ set +o shachaf
23:49:33 --- mode: shachaf set +b yezariaely!*@*$##fixyourconnection
23:49:37 <notdan> I see. What are the folds in the natural sense then?
23:49:40 --- mode: shachaf set -o shachaf
23:50:06 <shachaf> What's the tree definition? (Can't really use a browser right now.)
23:50:40 <notdan> data Treea  = Empty | Node (Tree a) a (Tree a)
23:50:51 <notdan> s/Treea/Tree a/
23:50:59 <mamiphin> http://pastie.org/pastes/7995514/text?key=0tcktsb8igadzpstlzgwa
23:51:01 <mamiphin> test.hs:1:0: parse error on input `<'
23:51:03 <mamiphin> why?
23:51:09 * adnauseam sighs
23:51:24 <shachaf> So you might make fold :: b -> (b -> a -> b -> b) -> Tree a -> b, I guess?
23:51:59 <mamiphin> Why am i getting the parse error?
23:52:04 <shachaf> mamiphin: That says you have a < right at the beginning of your file.
23:52:12 <shachaf> The thing you pasted doesn't.
23:52:23 <shachaf> Therefore my guess is that you're not running the thing you pasted.
23:52:30 <adnauseam> notdan: i haven't thought of the type thoroughly, i think that's where my current issues lies
23:52:37 <shachaf> adnauseam: It is.
23:53:25 <adnauseam> shachaf: what is ?
23:54:06 <mamiphin> shachaf: Yea, fixed the problem
23:54:07 <mamiphin> thanks
23:54:20 <notdan> shachaf: hm, yeah, that can be see as more natural
23:54:35 <notdan> but it does not generalize very well, i guess
23:55:22 <shachaf> It doesn't?
23:55:25 <adnauseam> i'll be back in a bit. this needs more coffee
23:56:15 <shachaf> notdan: Note: fold Empty Node x = x
