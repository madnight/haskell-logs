00:00:07 <carter> kryft start with trying out hakyll
00:00:10 <carter> for static web
00:00:12 <carter> easier
00:00:15 <luite> carter: it's just a package that depends on specific lib versions, can help with build problems. although i think the problems aren't as bad as they used to be, with recent cabal-install
00:00:20 <biscarch> kryft: of course, and I'd suggest getting to know both frameworks (or all three) as you learn more
00:00:28 <kryft> biscarch: Sure
00:00:48 <carter> biscarch theres so many other cool tools out there
00:00:57 <carter> kryft have you seen the ad lib?
00:00:58 <biscarch> carter: such as?
00:00:58 <carter> http://hackage.haskell.org/package/ad
00:00:59 <luite> hehe
00:01:05 <carter> all the otehr cool tools haskell rocks at
00:01:09 <carter> not just web
00:01:25 <carter> kryft, auto differentiation is worth playing with
00:01:30 <carter> and i shoudl head to beeeeddddddd
00:01:37 <kryft> carter: Yeah that looks cool
00:01:39 <biscarch> oh for sure. haha
00:01:45 <luite> yeah it's annoying that everyone keeps thinking of haskell as just a language for writing websites ;)
00:02:01 <kryft> carter: If I ever end up doing machine learning in haskell I'll try it
00:02:16 <carter> kryft one of the thign i'll be exploring in a few months i hope is takign AD and writing compiler that uses llvm to make AD expressions faster :)
00:02:23 <carter> also gpu things
00:02:24 <carter> ish
00:02:28 <biscarch> luite: people think that?
00:02:34 <carter> biscarch no clue
00:02:37 <kryft> luite: Haha, really? :)
00:02:45 <Hafydd> luite: do they?!
00:02:49 <carter> idk
00:03:15 <carter> kryft http://blog.felixriedel.com/2012/10/speed-up-r-by-using-a-different-blas-implementation/
00:03:21 <carter> open blas is pretty close to mkl
00:03:51 <carter> having simple code that beats the hand written assembly of open blas is a good first step to beat mkl maybe :)
00:03:52 <luite> hehe, well not really i guess, but web stuff in haskell is pretty active
00:04:05 <luite> it's not become ruby 2.0 yet
00:04:19 <carter> that happened to ruby a month ago right?
00:04:44 <kryft> carter: Right
00:04:54 <luite> oh they did release 2.0 already? i'm behind, clearly :)
00:05:07 <johnw> luite, a month or two ago I thought
00:05:16 <carter> http://blog.felixriedel.com/2012/11/r-blas-gotoblas2-vs-openblas-vs-mkl/ is probably more accurte
00:05:35 <kryft> luite: Damn, haskell missed it's chance to become ruby 2.0
00:05:53 <frerich> kryft: So it successfully avoided success at all costs.
00:06:17 <luite> oh well, i should get back to writing some more php and javascript
00:06:17 <kryft> carter: Yeah I saw those when I was trying to figure out whether it was worth it to compile octave with MKL
00:06:29 <luite> snap and haskell are cool, but not as good as wordpress ;)
00:06:32 <arkeet> is ruby 2.0 something that may have well been called ruby 1.10?
00:06:44 <carter> kryft a friend was trying to build R with MKL
00:06:46 <carter> for his work
00:06:46 <arkeet> or is it bigger than that. or is this the wrong channel
00:06:49 <carter> it was hard
00:07:14 <carter> kryft once i get my open stuff out, i'm open to patches to support mkl
00:07:26 <kryft> Heh, I just transferred a wordpress site from one server and domain to another; that was my first dip into anything vaguely related to web programming
00:07:32 <carter> i'm trying to avoid any autoconf
00:07:47 <kryft> I thought that if I set up a blog for myself or something, I'd really rather not build on php ;)
00:07:55 <carter> hakyll
00:08:00 <carter> is the way to go for flogs
00:08:02 <carter> blogs
00:08:10 <carter> host it as static content
00:08:17 <carter> add new things when you write them
00:08:21 <carter> pandoc to gen the pages
00:08:23 <carter> etc
00:08:24 <carter> ok
00:08:26 <carter> i should rest
00:08:27 <carter> night
00:08:33 <kryft> Night
00:08:34 <luite> carter: i already use pandoc to gen the pages!
00:08:40 <carter> WOOO
00:08:55 <luite> through byorgey's BlogLiterately
00:09:14 <luite> i just need to write a bit of php and js to tweak some output
00:10:21 <Hrumph> hi osomething is confusing me
00:11:12 <Hrumph> if i have a data type like data X = X {f::Int , G::Text}
00:11:40 <Hrumph> won't f have type Int->X and g will have type Text->X ?
00:12:08 <elliott> f :: X -> Int
00:12:10 <elliott> g :: X -> Text
00:12:31 <Hrumph> right i got that backwards
00:12:53 <Hrumph> but i'm having a wierd problem
00:16:22 <ksf> first, there was panic, then, there was relief.
00:16:52 <ksf>     Couldn't match type `t0' with `b'      because type variable `b' would escape its scope    This (rigid, skolem) type variable is bound by     a pattern with constructor [...]
00:17:28 <ksf> It's astonishing how much relief the realisation that a type error gets fixed by providing a trivial type signature can bring.
00:18:01 <b6> yeah, man. help it help you.
00:18:38 <kryft> If you take care of the types, they will take care of you
00:19:05 <P1RATEZ> even if she wasn't my type?
00:33:49 <tdammers> Loading package hscurses-1.4.1.0.1 ... can't load .so/.DLL for: libncurses.so (libncurses.so: cannot open shared object file: No such file or directory)
00:33:55 <tdammers> any clues why?
00:34:05 <tdammers> debian wheezy, I have libncurses5 installed
00:35:43 <tdammers> nm, fixed it
00:35:46 <tdammers> apparently I also need ncurses-dev
00:36:15 <osa1> I'm trying to install a cabal package from hackage, is there a way to override `extra-libraries` field without modifying .cabal file?
00:36:29 <osa1> I mean with a parameter in the shell
00:38:02 <luite> osa1: you can dev ghcjs with the vagrant image by the way. it just builds an initial version with the base libs. you can change/reinstall the compiler. if you change somethingthat changes the generated code, you need to run ghcjs-boot --reboot
00:39:05 <luite> osa1: and the rts is in ~/.ghcjs/x86_64-0.1.0-ghcversion/shims, git pull there to get the latest changes, edit the js files etc
00:39:20 <osa1> luite: thanks. I'm a bit worried about compilation times, my machine is not very fast. compiling after initial compilation should be faster, right?
00:39:55 <b6> 'cabal configure' does tend to be slow. don't clean and reconfigure unless you need to.
00:40:25 <luite> osa1: ghcjs-boot --reboot is not terribly fast, since it recompiles base, containers, template-haskell, integer-gmp etc
00:40:35 <luite> osa1: but just reinstalling ghcjs itself only takes a few seconds
00:40:51 <luite> most things can be developed without rebooting :)
00:40:59 <osa1> luite: great. and do I need to --reboot frequently?
00:41:12 <osa1> ah
00:41:12 <osa1> great
00:41:41 <osa1> my main and only development environment is a 13" ultrabook :-)
00:41:47 <luite> osa1: reboot takes ~5 minutes on my server wth the optimizer disabled, ~13 with it enabled, so we really need the optimizer to be a bit faster :)
00:43:07 <luite> fortunately the code still works perfectly with the optimizer disabled, it's just rather big :)
00:45:19 <osa1> luite: how can we have GHCJS that compiles every Haskell program to JS, I've heard from last G+ discussion that Haskell's runtime makes running Haskell programs on JS machines very hard. and as far as I can remember this was one of the reasons why we can't have JS using LLVM->Emscriptten
00:50:40 <luite> osa1: it doesn't compile everything, there are a few limitations. for example JavaScript doesn't have pointers. A limited form of pointer emulation is supported by GHCJS, but you can't for example convert from a pointer to an int and back. fortunately not may programs use that
00:52:08 <luite> osa1: also if a package has foreign imports, they need to be converted (rewritten, compiled with emscripten, etc..) to JS. usually that's pretty simple, the imports for the text package are here, for example: https://github.com/ghcjs/shims/blob/master/pkg/text.js
00:53:25 <luite> osa1: this looks very much like the C code used by the text package, only using JavaScript typed array functions instead of pointer things
00:56:06 <luite> osa1: GHCJS uses JS objects for most of its functionality, they get automatically collected by the JS garbage collector. for some things, like weak references, we have a heap scanner, since it's impossible to support it directly with JS objects. you can disable the heap scanner temporarily and the program will still run (but lazy IO finalizers and similar things will run later)
00:56:57 <luite> osa1: with LLVM -> JS you can't rely on the JS garbage collector anymore, so you'd have to port the one from the GHC RTS (emscripten might help here again)
00:58:00 <luite> osa1: but you'd still end up with much lower level code (might be faster than what we currently have for GHCJS though), that makes it much harder to get convenient interaction between js and haskell
00:58:14 <osa1> luite: and how hard would porting GHC RTS? I'm asking this because I still think that would be a better idea.
00:58:15 <osa1> hmm
00:59:15 <adas> I am not able to do ":t (<-)" in ghci. Am I missing someting?
00:59:37 <luite> ozgura: i'm not sure, i haven't tried. the RTS is written in C and Cmm, both of which can be translated to LLVM, and then to JS with emscripten, but it would probably require quite a bit of tweaking to make it work properly
00:59:38 <Kinnison> <- is not a function
00:59:41 <osa1> adas: <- is a part of `do` syntax
00:59:42 <frerich> adas: (<-) is not a value, so it has no type
00:59:43 <Kinnison> it's syntactic sugar
01:00:00 <Kinnison> Just like you can't do ':t let'
01:00:03 <luite> oops i meant osa1
01:02:39 <luite> osa1: we already have most of the RTS' functionality in JS though, and it's much more convenient to implement it in JS than it is in Cmm. also we always have a single threaded runtime (JS limitation), so we can skip locking etc. for example our STM implementation took me only about a week, and the code is pretty accessible: https://github.com/ghcjs/shims/blob/master/src/stm.js  (a bit longer than necessary due to the ugly google closure library StopIteration thing
01:03:00 <adas> oh.. and it only works for values in the IO context? Like I can do "n <- getLine" but not "n <- (Just 3)"?
01:03:37 <luite> osa1: and we also discovered bugs in the GHC STM implementation writing this :) ( fryguybob, Ryan Yates, helped me check the semantics )
01:03:42 <Kinnison> It works for monadic values
01:03:59 <Kinnison> adas: No reason n <- (Just 3) wouldn't work if you're in the Maybe monad
01:04:09 <c_wraith> > do n <- Just 3 ; return $ n * 5
01:04:10 <lambdabot>   Just 15
01:04:10 <osa1> luite: nice :-D
01:04:34 <arkeet> @undo do n <- Just 3 ; return $ n * 5
01:04:34 <lambdabot> Just 3 >>= \ n -> return $ n * 5
01:04:37 <Blkt> good day everyone
01:04:49 <luite> osa1: also we have some special threading constructs, asynchronous threads that let us do AJAX requests, asynchronous IO that waits for user input etc (sleeps the current haskell thread), and more limited synchronous threads for things like animaitions
01:05:01 <luite> those don't really make sense in the native GHC
01:05:50 <osa1> luite: ok so this looks like a huge project, where should I try reading and changing the source?
01:06:04 <luite> osa1: anyway, compiling the native RTS might be a good alternative approach, and i expect that if done right, code can be a bit faster than what we have now, but it would be hard to make everything as convenient.
01:06:29 <luite> osa1: the optimizer might be a good start
01:06:37 <adas> thanks for the clarification
01:07:07 <luite> osa1: it's a function JStat -> JStat  (JMacro statement), it just rewrites some javascript to some better (shorter) javascript
01:07:46 <luite> osa1: so you can understand it without knowing the details of the calling convention and threading. if your optimized JS does the same as the original, then it's ok! :)
01:08:28 <osa1> luite: haha, that was also how I started contributing to Fay. I started with the optimizer :-)
01:08:31 <luite> osa1: it's a tad complex, it does dataflow analysis on the JMacro statements, so it checks for example if a variable is ever used. if it isn't it removes it
01:09:01 <luite> osa1: and it uses a bit of GHCJS-specific knowledge to do some optimizations
01:09:36 <luite> osa1: one of the things that it currently does not do is combine all constants in arithmetic expressions
01:10:09 <osa1> luite: hmm, I always thought that kind of optimizations should be done by GHC, before coming to GHCJS backend
01:10:11 <luite> osa1: for example h$stack[(h$sp+3)-4)] is not always rewritten to h$stack[h$sp-1]
01:10:41 <luite> osa1: this is only hte low level optimizations, after generating code and inserting the primitive operations
01:10:53 <osa1> ah
01:10:54 <luite> all the core -> core optimizations are already done by GHC indeed
01:11:16 <luite> GHC itself also has an extra optimization pass, using hoopl, that does this
01:11:44 <osa1> hoopl?
01:11:58 <luite> but since we take STG code, before hoopl, we have to do it ourselves (and hoopl isn't terribly great for rewriting javascript...)
01:12:25 <luite> osa1: yeah, hoopl is a dataflow analysis lib (it's on hackage), in GHC it optimizes the Cmm code
01:13:55 <luite> but it's really hard to translate something like Cmm back to reasonable JS statements (hoopl code works with basic blocks, conditional jumps etc, javascript doesn't have goto, and it's hard to translate arbitrary jumps back to while loops, if statements etc... that's actually one of the most complex parts of emscripten, and it only does an ok job)
01:15:19 <luite> osa1: anyway, the code for rewriting h$stack[(h$sp+3)-4] to h$stack[h$sp-1] is already there in Optimizer.hs, but it's disabled since it can mess with precision
01:16:12 <osa1> luite: thanks for help. I should leave now, but before leaving can you tell me which github packages do I need? does vagrant job pulls are required source?
01:16:16 <luite> osa1: but for expressions that only use h$sp (h$sp is the index of the top of the stack array in the current thread), that never happens, and h$sp manipulation is really common. so it would be useful to enable this for expressions that only use h$sp
01:16:24 <luite> osa1: the vagrant build pulls everything
01:16:43 <osa1> great
01:17:03 <luite> osa1: the packages you want to hack are ghcjs (see src/Gen2/Optimizer.hs for the optimizer) and shims (javascript code for the RTS and package, installed in ~/.ghcjs/x86_64-version/shims )
01:19:04 <osa1> luite: oh wait. do I need to install my development environment for vagrant machine? seems like I can't use gvim etc.
01:21:03 <luite> osa1: oh you can edit files on the vagrant machine if you mount it with sshfs, also the /vagrant dir inside the machine is the installation directory on the host, so you can edit files directly there
01:21:35 <luite> osa1: I hope we can get rid of this vagrant business in a few months, when ghc 7.8.1 is out, but for now it's the most reliable way to make sure that patches are applied correctly
01:21:59 <luite> since there are lots of packages that need some adjustments to build with the latest ghc
01:22:41 <osa1> ok, I didn't know about sshfs, will try when I come back.
01:22:49 <osa1> luite: thanks very much, I'm leaving now
01:23:02 <luite> osa1: oh i saw that there is a new comonads package uploaded, it might break again, if your build breaks it probably means that we need to update a few more packages
01:23:09 <luite> ok, i have to go now too :)
01:25:19 <adas> when i do "(x:_) <- val" and val was (Just [1,2,3]) then x would be bound to 1. And if val is "Nothing" am I correct in assuming that the "fail" function specified by the monad typeclass is executed instead?
01:26:18 <Lethalman> adas, afaik, that is a pattern matching error
01:26:33 <Lethalman> nothing to do with monad
01:27:47 <bartavelle> Lethalman, I believe the "fail" function is called in case of pattern matching errors in "do" blocks
01:27:55 <Lethalman> ah
01:28:08 <johnw> bartavelle: that is correct
01:28:40 <adas> thans..glad i was correct )
01:28:45 <Lethalman> thought that was something called by the programmer when something fails
01:29:14 <Lethalman> is it used when defining a monad or then it's the compiler that takes care of calling fail?
01:30:01 <bartavelle> you might want to use it yourself in parsers
01:30:12 <b6> fail is a part of Monad, but i think most people think it shouldn't be.
01:30:12 <bartavelle> default implementation is "error"
01:30:58 <Lethalman> ok but in case of pattern match failure, is it the compiler that calls fail?
01:31:21 <bartavelle> it's the "do" block desugaring that does this
01:31:28 <bartavelle> so yes it is the compiler
01:32:39 <Lethalman> \o/ unexpected
01:33:03 * Lethalman doesn't expect the compiler to automagically call user functions except for threading
01:38:25 <quchen> There's no magic in here.
01:39:37 <mm_freak> 'fail' is a hack…  it's illdefined and best avoided
01:39:39 <Lethalman> quchen, well I don't expect the compiler to call fail on pattern match failure, I see an error outside of monads that I can't control
01:39:54 <Lethalman> why monads should have it controllable?
01:39:58 <mm_freak> Lethalman: that /is/ 'fail'
01:40:00 <Fuuzetsu> I kind of want to grep for‘magic’ in #haskell logs for the last year…
01:40:26 <mm_freak> > (fail "blah" :: () -> b) ()
01:40:28 <lambdabot>   *Exception: blah
01:41:35 <shachaf> @let data Blah a = No String | Yes a deriving Show
01:41:36 <lambdabot>  Defined.
01:41:50 <quchen> Lethalman: Well, it's a sometimes convenient shortcut. With the downside that it breaks more than it helps.
01:42:01 <shachaf> @let instance Monad Blah where { return = Yes; No s >>= _ = No s; Yes x >>= f = f x; fail = No }
01:42:02 <lambdabot>  Defined.
01:42:25 * Lethalman wonders why can't define data or instance in his lambdabot copy :-(
01:42:48 <elliott> Lethalman: because it is useful e.g. in the list monad
01:42:50 <mm_freak> > do x:ys <- tails "abcd"; y <- ys; return (x,y)
01:42:51 <lambdabot>   [('a','b'),('a','c'),('a','d'),('b','c'),('b','d'),('c','d')]
01:42:53 <elliott> or STM (does STM get fail right?)
01:42:59 <mm_freak> that's a good usage of 'fail'
01:43:08 <shachaf> > do { Nothing <- Yes (Just 'a'); return () }
01:43:11 <lambdabot>   No "Pattern match failure in do expression at <interactive>:3:6-12"
01:43:13 <quchen> elliott: Nope, I think STM has an error call on fail.
01:43:14 <shachaf> > do {  Nothing <- Yes (Just 'a'); return () }
01:43:17 <lambdabot>   No "Pattern match failure in do expression at <interactive>:3:7-13"
01:43:20 <quchen> elliott: Let me look it up though.
01:43:32 <shachaf> Isn't it great how those are different?
01:43:33 <mm_freak> i think having something like that is fine, but 'fail' is so arbitrary and illdefined that i don't define it for most monads
01:43:47 <shachaf> I should write some embedded domain-specific language thing that uses that.
01:44:21 <elliott> shachaf: implement Whitespace in fail
01:44:28 <elliott> except you couldn't distinguish the whitespaces properly :(
01:44:53 <quchen> elliott: STM doesn't define fail, so it defaults to error. http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Conc-Sync.html
01:45:04 <elliott> that sucks. someone should fix that
01:45:12 <elliott> do { Just foo <- readTChan foo; ... }
01:45:19 <elliott> hm maybe that wouldn't work if Nothing ever got written to it
01:45:23 <shachaf> I'm not sure that STM fail should be mzero.
01:45:27 <mm_freak> > let pairs xs = [ (x, y) | x:ys <- tails xs, y <- ys ] in pairs [1..5]
01:45:29 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
01:45:30 <elliott> do { Just foo <- readTVar foo; ... } would work anyway
01:45:31 <elliott> and be cool
01:45:49 <quchen> elliott: Probably a good idea. On the other hand, that would encourage code to rely on `fail`, which I'm not sure is a good thing.
01:46:01 <elliott> well, the behaviour of pattern matching in do blocks is pretty good
01:46:07 <elliott> it's just fail being in the Monad class that's bad
01:47:35 <quchen> What is fail useful for right now anyway? Maybe, List, parsers?
01:47:39 <quchen> Anything else?
01:48:48 <mm_freak> quchen: most monads that have an 'empty'/'mzero'
01:49:07 <mm_freak> example:  (Alternative m) => StateT s m
01:49:33 <quchen> Hm, right
01:49:35 <mm_freak> that's also a reason why 'fail' should be off-Monad
01:49:46 <mm_freak> because right now you can't write a sensible 'fail' for that one
01:50:50 <quchen> That would be a tough thing to change though
01:51:17 <mm_freak> in terms of breaking existing code, yes
01:51:43 <mm_freak> but it wouldn't be much worse than Num independent of Eq
01:51:44 <quchen> That's what I meant. Implementing it shouldn't be hard at all.
01:52:00 <mm_freak> and we've done that already =)
01:52:02 <quchen> Oh, was the Num/Show/Eq thing a big compatibility issue?
01:52:10 <quchen> I wasn't aware of that
01:52:20 <mm_freak> not as big as expected
01:54:27 <quchen> At least fixing what it breaks was pretty easy, right?
01:55:05 <quchen> (In a bazillion of instances though)
01:55:52 <supki> function signatures were a problem, not instances
01:56:45 <supki> same with Bits
02:00:34 <quchen> supki: At least it's trivial to add the constraints. It's not like you have to refactor your code on a large scale.
02:11:03 <Fuuzetsu> Is there a tarball of nightly GHC git sources or am I misremembering?
02:11:51 <alpounet> Fuuzetsu, I think there is indeed
02:12:45 <latermuse> im trying to install regex-pcre through cabal, but its saying my pcre.h file is missing. I have the pcre installed, but i dont think cabal is looking in the right place for it. How can I see where cabal is searching for that file so I can link it?
02:12:47 <Fuuzetsu> I can't find it… I know that the binaries have been gone for a while.
02:12:57 <johnw> Fuuzetsu: what is your platform?
02:13:19 <alpounet> Fuuzetsu, at least there were, but the ghc-tarballs dirs at http://darcs.haskell.org don't seem to be recent enough
02:13:35 <alpounet> i remember using them back in the time the llvm backend wasn't yet in GHC
02:13:47 <Fuuzetsu> Oh, that's a good point. This is going to be running on a random build bot… I think I'll just have it fetch from git or something
02:14:05 * hackagebot bliplib 0.2.0 - Support code for Blip.  http://hackage.haskell.org/package/bliplib-0.2.0 (BerniePope)
02:14:07 * hackagebot blip 0.2.0 - Python to bytecode compiler.  http://hackage.haskell.org/package/blip-0.2.0 (BerniePope)
02:14:09 * hackagebot readpyc 0.2.0 - Read and pretty print Python bytecode (.pyc) files.  http://hackage.haskell.org/package/readpyc-0.2.0 (BerniePope)
02:14:13 <Fuuzetsu> I think GitHub does tarballs.
02:14:15 <johnw> Fuuzetsu: I'm building nightly binaries; having the process tarball the sources is a good idea
02:29:05 * hackagebot blip 0.2.1 - Python to bytecode compiler.  http://hackage.haskell.org/package/blip-0.2.1 (BerniePope)
02:29:07 * hackagebot bliplib 0.2.1 - Support code for Blip.  http://hackage.haskell.org/package/bliplib-0.2.1 (BerniePope)
02:30:57 <Fuuzetsu> I hope the GHC guys reach an agreement about the state of the repository soon… It's such a mess of submodules and not-quite-submodules and sync scripts &c…
02:33:42 <alpounet> Fuuzetsu, i guess you have seen the recent discussions about it
02:34:06 * hackagebot readpyc 0.2.1 - Read and pretty print Python bytecode (.pyc) files.  http://hackage.haskell.org/package/readpyc-0.2.1 (BerniePope)
02:35:08 <tdammers> huh... a python compiler written in haskell... gets you thinking, doesn't it?
02:35:41 <Fuuzetsu> alpounet: Yeah. Everyone agrees that it's a mess but they have yet to agree on the criterion of splitting the packages up…
02:36:00 <Fuuzetsu> tdammers: Has it been done?
02:36:05 <thoughtpolice> i'm hoping to keep pushing on the matter soon
02:36:10 <thoughtpolice> (i started the whole thing)
02:36:14 <startling> tdammers, doesn't look like a compiler
02:36:43 <adas> what happened to the state library in ghc 7.6.3?
02:36:47 <Fuuzetsu> thoughtpolice: Heh, I was actually getting really annoyed with it all the day before the posting started but I'm not a GHC dev so I don't say anything.
02:37:04 <thoughtpolice> i think with edwardk's formulation of the core libraries committee (i.e. actual maintainers) we can move more things to submodules. base will still kind of suck i guess, but it's better than nothing
02:37:04 <startling> I wonder if he plans on supporting the bytecode from every minor version of python
02:37:12 <Fuuzetsu> adas: What happened to it? Use the ‘state’ function instead of the State constructor but that's about it I think.
02:37:21 <alpounet> thoughtpolice, greatly appreciated your arguments, you got me convinced btw
02:37:30 <thoughtpolice> (because if base is a submodule, that'll still be painful, but whatever)
02:37:53 <Fuuzetsu> ah http://hackage.haskell.org/package/berp-0.0.1 and http://code.google.com/p/haspy/
02:38:06 <thoughtpolice> and a few repositories should just become GHC's anyway still
02:38:13 <adas> Fuuzetsu: im not able to find the docs for the state monad in the documentation
02:38:17 <thoughtpolice> i should probably write something up on the wiki i guess
02:38:22 <alpounet> Fuuzetsu, i think he was referring to "blip", see the hackagebot announcements from 10 mins ago
02:38:59 <Fuuzetsu> Oh, I didn't see that
02:41:35 <jpcooper> hello
02:43:14 <jpcooper> I am trying to use parsec to parse "CREATE TABLE" statements in SQL, written between "START TRANSACTION;" and "COMMIT;". I am using between (string "START TRANSACTION;" >> space) (space >> string "COMMIT;") tablesParser
02:43:25 <jpcooper> tablesParser = sepBy (try tableParser) space
02:44:09 <jpcooper> the problem is that it is still trying to parse the ending "COMMIT;" as a "CREATE TABLE", saying that the "O" in the commit is unexpected. Why should it be doing this, given then sepBy (try tableParser) space?
02:44:18 <adas> got it. i shouuld have searched for the haskell platform docs not ghc 7.6.3 docs
02:44:26 <tdammers> startling: no idea, really. Just noticed the hackage upload.
02:44:32 <tdammers> "python-to-bytecode compiler"
02:52:29 <startling> tdammers: oh, there was coincidentally another one for parsing python bytecode right before you said that
02:54:05 <merijn> adas: I tend to just search Hoogle
02:54:32 <merijn> adas: I don't think anything changed about State in 7.6, but if you're reading LYAH it did change a little since that was written
02:56:07 <alpounet> the same goes for RWH iirc
02:56:20 <merijn> Probably
02:56:38 <alpounet> i also think there were some issues with exception-related code in RWH
03:04:25 <adas> merijn: thanks.. the thing is i installed ghc 7.6.3 and ended up installing only the bare libraries. I should have installed the haskell-platform instead.
03:05:19 <merijn> adas: Ah :)
03:05:38 <merijn> Is there a way to write type signatures for typeclass instances?
03:06:06 <merijn> Just a sort of memory-aid to myself when the types get complicated
03:06:15 <adas> one more issue is that.. I have an old version of 'mtl' package. i want to update it to the latest version 'mtl 2.1.2'. Can someone please tell me how do it? Cos last time I had a problem where i had an old version of a package and then i installed the new version using cabal.. and after that i couldn't access neither the old nor new version of the package
03:06:24 <thoughtpolice> merijn: yes, if you use -XInstanceSigs
03:06:31 <thoughtpolice> 7.6+ i think
03:07:27 <merijn> thoughtpolice: Ha, as if *any* of my code is portable to <7.6 :p
03:07:35 <alpounet> adas, may I advise you to use cabal-dev or hsenv or a similar tool? that'll build and install packages (your dependencies) locally to a project (or to a few projects)
03:08:18 <merijn> adas: Use "ghc-pkg list" to find the package name, "ghc-pkg unregister <name>" to unregister it (you'll have to delete the files manually)
03:08:37 <merijn> adas: The file deletion is optional (it will waste disk space if you don't, the location depends on your OS)
03:09:20 <RichyB> adas, I second alpounet's recommendation for hsenv.
03:10:00 <merijn> adas: In general, never reinstall/upgrade packages without unregistering it first (unregistering will warn you if you break anything else so you can upgrade those things too)
03:10:11 * merijn has never had dependency issues with that approach
03:10:15 <adas> alpounet: wont i be wasting space if i do that. say i have 2 projects.. both using mtl. Wouldn't mtl get locally installed twice? once for each project ...?
03:10:42 <alpounet> adas, yes
03:10:52 <alpounet> but before your drive gets filled, there'll be a while
03:11:02 <alpounet> and it pretty much avoids any conflict you can have
03:11:07 <merijn> adas: Like I said, I don't use cabal-dev/hsenv and things work fine for me
03:11:32 <hpaste> Gurgeh pasted “Type class problem” at http://hpaste.org/90218
03:11:46 <adas> alpounet: and if im done with the project .. i can simply delete the folder along with the dependencies?
03:11:58 <adas> merijn: but seems like there is some manual work involved..
03:11:58 <alpounet> adas, yes
03:12:15 <merijn> Who is Gurgeh?
03:12:32 <alpounet> adas, with cabal-dev, everything gets built in the cabal-dev/ subdir of your project. rm -r cabal-dev and it's like you never installed anything
03:13:06 <hpaste> Gurgeh revised “Type class problem”: “Type class problem” at http://hpaste.org/90218
03:13:08 <merijn> Gurgeh: Simple answer, type variables are local to a type signature
03:13:28 <merijn> Gurgeh: i.e. the a in your function body is not the same as the one in your type signature
03:13:40 <Gurgeh> I'm here now
03:13:49 <merijn> Gurgeh: Fortunately there's a solution
03:13:56 <adas> alpounet: thanks for the pointer. i thin ill go with cabal-dev. cabal-dev vs hsenv? or it deosn't matter?
03:13:57 <Gurgeh> aha
03:14:02 <alpounet> adas, i spend exactly NONE of my time unregistering/registering/whatnot packages, fixing issues like the ones you have now. 0 burden. also, cabal-dev supports the -j option if you have a recent enough version of cabal-install.
03:14:03 <merijn> ScopedTypeVariables let's you do this
03:14:48 <adas> alpounet: -j option?
03:14:50 <Gurgeh> I suspected that it would
03:14:53 <merijn> Gurgeh: {-# LANGUAGE ScopedTypeVariables #-} enables the extension, then you need to change your type signature for typeprec to "forall a . (Bounded a, Integral a) => a -> Int"
03:15:15 <alpounet> adas, to be honest, I can't tell much about hsenv. i tried cabal-dev first and was happy with it, but I know a lot of people using hsenv just fine too, so check out their respective README and choose the one that suits you better :-) also note that the next release of cabal-install will have features "à la cabal-dev", but on steroids
03:15:17 <merijn> Gurgeh: The explicit forall brings the type variable into scope for the rest of your function body
03:15:18 <alpounet> but in the meantime...
03:15:44 <Gurgeh> thanks!
03:15:45 <Gurgeh> I'll try that
03:16:28 <merijn> Gurgeh: Basically, without that the "(maxBound :: a)" is exactly the same as writing "(maxBound :: b)" in your function body
03:16:49 <merijn> Gurgeh: I typed most of the syntax from memory, there might be syntax errors, so Google if it goes wrong ;)
03:17:11 <alpounet> adas, -j4 will use 4 cores to build. this isn't optimal, it "just" builds packages in parallel, not modules -- but that still speeds up things significantly. especially for the initial build of your project, when it has to fetch all the dependencies and build them.
03:17:14 <Gurgeh> I think I understand now. I'll be able to figure it out on my own
03:18:06 <Gurgeh> bwaha, it worked
03:23:50 <zebr> hey all. i remember reading a blog post a while back about how, iirc, haskell variables should not be called variables, but symbols (i think). does anyone happen to know what post it was?
03:24:23 <Fuuzetsu> Well, they don't vary ;)
03:25:02 <zebr> Fuuzetsu: well, they do insofar as variables in algebra do
03:26:04 <zebr> hm, thinkign about it maybe it was the other way round: another name for mutable variables. sigh, it was so long ago.
03:35:45 <zebr> ah, found it: http://existentialtype.wordpress.com/2012/02/01/words-matter/
03:35:49 <zebr> it's more general than i remembered, though.
03:38:49 <zebr> (i also think 'slot' is a more intuitive name than 'assignable'.)
03:41:09 <hvr> Luke: fyi, https://github.com/haskell/haskell-mode/commit/7fbcde0f69330657842fc54a0a11380404a83f38
03:49:07 * hackagebot hedn 0.1.7.0 - EDN parsing and encoding  http://hackage.haskell.org/package/hedn-0.1.7.0 (AlexanderBondarenko)
03:53:57 <Gurgeh> Hi, I have a performance question
03:55:05 <Gurgeh> Will there be a difference (with ghc -O) between passing a data struct {a::Int, b::Int, c::Int} and a triple (Int, Int, Int) to a function?
03:55:13 <quicksilver> no.
03:55:24 <quicksilver> those are the same thing
03:55:51 <Gurgeh> great
03:55:54 <Gurgeh> thanks
03:56:00 <quicksilver> the names on record syntax just give you some other ways to refer to parts
03:56:00 <quicksilver> they're not actually a different memory storage arrangement
03:56:11 * elliott suspects it's a personal flaw that he started trying to think of ways they could possibly end up differing operationally with GHC...
03:56:15 <Gurgeh> just for completeness Int -> Int -> Int would be the same too?
03:56:26 <quicksilver> no, that's quite a different
03:56:28 <quicksilver> functions aren't data
03:57:01 <elliott> Gurgeh: btw, best to say (Int -> Int -> Int -> ...) or such; (Int -> Int -> Int) means something quite different
03:57:07 <elliott> since the function arrow associates rightwards
03:57:11 <Gurgeh> But I mean a performance different between a function with the signature Int -> Int -> Int -> .. and (Int, Int, Int)?
03:58:42 <quicksilver> Gurgeh: ah, right.
03:58:51 <quicksilver> Gurgeh: in general the function is faster
03:59:08 <Gurgeh> it might skip an extra pointer indirection?
03:59:13 <quicksilver> changing data structures into parameters using a CPS-transform normally makes GHC code faster
03:59:30 <quicksilver> Gurgeh: yes, and it's also more susceptibel to optimisations
03:59:40 <elliott> also, passing multiple parameters is often more idiomatic.
03:59:45 <elliott> as a rule of thumb. except when it's not.
04:01:31 <Fuuzetsu> Can someone confirm that this throws an exception?: https://www.fpcomplete.com/hoogle?q=(a+->+a+->+a)+->+[a]+->+[a]+->+[a]
04:01:51 <Gurgeh> I have a small stateful C bit-fiddling function that I want to translate to fast Haskell. I'll try myself, but perhaps afterwards someone could criticize?
04:02:42 <quicksilver> works for me Fuuzetsu
04:02:42 <quicksilver> https://www.fpcomplete.com/hoogle?q=(a+-%3E+a+-%3E+a)+-%3E+%5Ba%5D+-%3E+%5Ba%5D+-%3E+%5Ba%5D
04:03:03 <Fuuzetsu> It just gives me >src/Hoogle/Type/TypeSig.hs:(117,9)-(121,26): Non-exhaustive patterns in case
04:03:05 <Fuuzetsu> every time
04:03:44 <Fuuzetsu> oh, it does for something as simple as ‘a’ too… >src/Hoogle/Type/Item.hs:(148,14)-(158,42): Non-exhaustive patterns in case
04:08:46 <merijn> Fuuzetsu: odd, seems to work for me
04:09:51 <Fuuzetsu> @pl f x y = x + 0.5 * y ** 2.0
04:09:54 <lambdabot> f = id (fix (const (flip ((.) . (+)) ((0 . 5 *) . (** 2 . 0)))))
04:09:54 <lambdabot> optimization suspended, use @pl-resume to continue.
04:10:11 <Fuuzetsu> @pl f x y = x + 0.5 * (y * y)
04:10:14 <lambdabot> f = id (fix (const (flip ((.) . (+)) ((0 . 5 *) . ap (*) id))))
04:10:14 <lambdabot> optimization suspended, use @pl-resume to continue.
04:10:21 <Fuuzetsu> @pl-resume
04:10:27 <lambdabot> f = id (fix (const (flip ((.) . (+)) ((0 . 5 *) . ap (*) id))))
04:10:27 <lambdabot> optimization suspended, use @pl-resume to continue.
04:10:48 <Fuuzetsu> @pl-resume
04:10:55 <lambdabot> f = id (fix (const (flip ((.) . (+)) ((0 . 5 *) . ap (*) id))))
04:10:55 <lambdabot> optimization suspended, use @pl-resume to continue.
04:11:03 <quchen> Looks like you found a fixed point.
04:11:07 <Fuuzetsu> yeah
04:31:09 <Fuuzetsu> @pl f x y -> x { g = y }
04:31:09 <lambdabot> (line 1, column 9):
04:31:09 <lambdabot> unexpected '>'
04:31:09 <lambdabot> expecting operator
04:31:20 <Fuuzetsu> @pl f x y = x { g = y }
04:31:21 <lambdabot> (line 1, column 11):
04:31:21 <lambdabot> unexpected '{'
04:31:21 <lambdabot> expecting variable, "(", operator or end of input
04:31:36 <Fuuzetsu> How boring
04:44:06 <supki> @pl \x y -> set (upon g) y x
04:44:09 <lambdabot> flip (set (upon g))
04:44:10 <lambdabot> optimization suspended, use @pl-resume to continue.
04:50:04 <schoppenhauer> hello. what is the best way to read a file characterwise inside the IO Monas?
04:50:25 <schoppenhauer> not characterwise ... word8-wise.
04:50:40 <elliott> is the file huge?
04:50:43 <elliott> as in reading it all into memory isn't an option
04:51:11 <schoppenhauer> elliott: mmap(2) would be an option, but yes, the files can get huge.
04:51:30 <schoppenhauer> even "infinitely long"
04:51:40 <schoppenhauer> elliott: I want to code a stream processor.
04:52:23 <quchen> elliott: Won't lazy ByteStrings read it chunk by chunk?
04:52:24 <elliott> schoppenhauer: well, you could do a very silly inefficient read-exactly-one-byte-at-a-time thing, use ByteString's hGet thing and handle rotating the buffers and such yourself, or look into the conduit/pipes family of libraries
04:52:40 <elliott> oh, I guess a lazy bytestring would work too, with the usual pitfalls of lazy IO
04:52:49 <Fuuzetsu> @pl f _ [] = []
04:52:50 <lambdabot> (line 1, column 3):
04:52:50 <lambdabot> unexpected '_'
04:52:50 <lambdabot> expecting variable, "(", operator or end of input
04:53:07 <quchen> elliott: I guess the only problem with lazy BS is if the stream blocks before a chunk is filled.
04:53:15 <schoppenhauer> elliott: a lazy bytestring would be fine.
04:53:26 <schoppenhauer> elliott: how do I get such a thing?
04:53:48 <schoppenhauer> elliott: I use Data.ByteString.readFile but this appears not to be lazy
04:53:48 <quchen> schoppenhauer: http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Lazy.html#t:ByteString
04:54:06 <elliott> http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString-Lazy.html#g:25
04:54:13 <elliott> need to import .Lazy
04:55:26 <schoppenhauer> elliott: this looks like it will still, in the end, save the whole file into memory.
04:55:43 <schoppenhauer> elliott: just lazily
04:56:17 <schoppenhauer> elliott: I need haskell to forget about most of the back-history of the file
04:57:25 <supki> schoppenhauer: you use GC for that
04:57:58 <schoppenhauer> supki: a bytestring is accessible like an array. that is, it cannot collect old parts, because they must stay accessible.
04:58:34 <supki> why would they stay accessible if you don't need them?
04:58:48 <quchen> schoppenhauer: In that case, you should have a look at pipes/conduit, like elliott mentioned above.
04:59:06 <elliott> schoppenhauer: no
04:59:12 <schoppenhauer> supki: because the GC cannot know that I am unable to access them
04:59:16 <elliott> schoppenhauer: it's effectively a linked list of strict bytestrings
04:59:23 <elliott> if you traverse it properly previous parts will be collected
04:59:30 <elliott> in chunks
04:59:39 <elliott> subject to the usual lazy IO perils
05:00:08 <schoppenhauer> hm. thank you.
05:00:54 <elliott> :)
05:01:01 <schoppenhauer> well, too much frustration. I guess I will switch to Standard ML instead of using haskell for this.
05:01:01 <schoppenhauer> thank you anyway for trying.
05:08:39 <Fuuzetsu> >    The operator `lift' takes two arguments,ghc: panic! (the 'impossible' happened)
05:08:40 <lambdabot>   <hint>:1:21: parse error on input `takes'
05:08:54 <Fuuzetsu> I was hoping to not get the impossible this week…
05:09:49 <Cale> Fuuzetsu: which version of ghc?
05:10:05 <Cale> (and how'd you cause that?)
05:10:29 <Fuuzetsu> 7.6.3… It seems fixed in head.
05:10:34 <quchen> Did GHC become sentient again?
05:10:41 <Hafydd> Oh no, the 'impossible'.
05:11:02 <Cale> I believe it was shachaf who had a really amusing ghc bug of that sort
05:11:31 <Fuuzetsu> Every 5th bug on the GHC Trac seems to be shachaf's.
05:25:37 <KingofFerrets> ...Arg. Is there an existing version of the State monad that keeps coming up that I can actually use, or do I have to do something with the StateT thing?
05:25:54 <Kinnison> Erm, if you don't need StateT then use State
05:26:03 <Kinnison> State is, (I believe) essentially StateT over Identity
05:26:11 <akegalj> i wrote example which is trying to strictly read 100,000 small files into a memory ([String]) but it is failing hard. Size of 1 file on file system is 4kb which maps to 400Mb for 100,000 files. I would expect haskell program not to take >2Gb on my system, and >10min for that simple task. Could you please look at my example i try figure out where am i doing wrong?
05:26:15 <hpaste> akegalj pasted “Inafficient strict file read” at http://hpaste.org/90223
05:26:34 <elliott> KingofFerrets: what problem are you having?
05:26:42 <elliott> if you import Control.Monad.State and use State it should work
05:27:14 <KingofFerrets> so, I was trying to use this to understate the State monad: http://brandon.si/code/the-state-monad-a-tutorial-for-the-confused/
05:27:54 <merijn> akegalj: What error/problems are you getting? One issue could be that String is a terrible datatype for this
05:28:24 <merijn> akegalj: String is literally a linked list of characters. For dealing with files you probably wanna use Text (for text) or ByteString (for binary data)
05:28:40 <quicksilver> String uses 24 bytes per char
05:28:55 <akegalj> quicksilver: :O
05:28:56 <Kinnison> akegalj: Each 'character' in String is likely to be sizeof(void*) + sizeof(unicode_char) at minimum
05:28:59 <KingofFerrets> And so I tried to do the thing where he did stateIntString = State fromStoAandS
05:29:05 <quicksilver> so your 400Mb of files will be around 10GB if they are mostly ASCII
05:29:14 <Kinnison> akegalj: If you want to efficiently process a lot of on-disk data, then you will probably want ByteString
05:29:17 <akegalj> marijn: can Text do Strict file IO ?
05:29:23 <merijn> akegalj: No clue, probably
05:29:37 <KingofFerrets> and ghci complained "Not in scope: data constructor `State'     Perhaps you meant `StateT' (imported from Control.Monad.State)"
05:29:46 <akegalj> Kinnison: does ByteString supports utf8 or unicode?
05:29:56 <merijn> akegalj: ByteString is for literally just bytes
05:30:03 <merijn> akegalj: Use Text for unicode text
05:30:04 <quchen> quicksilver: 24 Bytes per char? That doesn't sound right.
05:30:16 <quicksilver> on a 64 bit system
05:30:47 <Kinnison> IIRC, Data.Text is strict, where Data.Text.Lazy is lazy
05:30:47 <quicksilver> 8 bytes for the cons cell, 8 bytes for the indirection and 8 bytes for the character itself, quchen ?
05:30:47 <merijn> quchen: 4 byte unicode codepoint, box around the codepoint, pointer to the box, pointer to the tail of the list, box for the list
05:30:48 <quicksilver> sounds ight to me.
05:31:15 <merijn> akegalj: Text is encoding aware, ByteString is the haskell equivalent of char* in C
05:31:18 <quchen> quicksilver: Ah, right, I didn't count the Haskell boxing.
05:31:24 <quicksilver> maybe it's 32 bytes if there are two indirection but the number 24 sounds familiar
05:31:25 <merijn> akegalj: i.e. just blocks of Word8/bytes
05:31:46 <adas> is there a good intuition for understanding the state monad?
05:31:59 <merijn> adas: "s -> (a, s)"
05:32:03 <elliott> KingofFerrets: ok. that tutorial is outdated
05:32:12 <elliott> KingofFerrets: you can use "state" instead of "State" for the constructor
05:32:17 <KingofFerrets> ah
05:32:31 <merijn> adas: i.e. the state monad is just passing in an extra function argument and returning an extra result of the same type
05:32:40 <akegalj> marijn: thnx, i wasn't aware of that
05:32:57 <merijn> adas: The only annoying thing about that is manually moving the "s" around, the State monad takes care of shifting the s around for you
05:33:00 <akegalj> marijn: will try Data.Text now
05:33:05 <akegalj> thnx all
05:33:32 <KingofFerrets> Okay. So.
05:33:38 <KingofFerrets> I did that, the error changed. <.<
05:33:53 <KingofFerrets> Currently, I have stateRandom :: state StdGen Int
05:33:55 <KingofFerrets> stateRandom = state random
05:34:33 <elliott> state only for the constructor
05:34:34 <elliott> the type is still State
05:34:53 <KingofFerrets> So State in the top one, state in the bottom?
05:35:01 <adas> merijn: thanks. i don't think i still get it .. its not so easy
05:35:11 <elliott> yep
05:35:19 <KingofFerrets> It works! Geeeenius.
05:35:48 <elliott> I have a Ph.D. in Haskell identifier capitalisation
05:36:17 <quchen> adas: Do you understand the State instance?
05:36:22 <quchen> Monad instance, that is
05:38:20 <merijn> adas: An example: "newtype State s a = State (s -> (a, s))" what does this mean? Say we "incrementer :: Int -> State Int ()", which takes an Int a produces a State action that increases a counter
05:39:09 <merijn> What does that translate to? Well, State s a means that we have s = Int and a = (), resulting in "incrementer :: Int -> Int -> ((), Int)"
05:39:59 <Fuuzetsu> @pl f x = get >>= g . h x
05:40:02 <lambdabot> f = (get >>=) . (g .) . h
05:40:02 <lambdabot> optimization suspended, use @pl-resume to continue.
05:40:13 <merijn> adas: What kind of function looks like that? Well, "incrementer inc state -> ((), inc + state)" for example
05:40:17 <adas> quchen: you mean the monad laws of state?
05:40:57 <ramses_> is there a better way to go from Integer to Text then "pack . show"?
05:40:59 <merijn> adas: So, let's look at the Monad instance. "Monad (State s)" and (>>=) :: m a -> (a -> m b) -> m b"
05:41:02 <quchen> adas: "Could you write the Monad instance for State yourself?"
05:41:14 <merijn> adas: Replace m with "State s" and we get "(>>=) :: State s a -> (a -> State s b) -> State s b"
05:41:22 <quchen> "m >>= f = State $ \s -> ..."
05:41:24 <merijn> Let's simplify again!
05:41:59 <merijn> "(>>=) :: (s -> (a, s)) -> (a -> s -> (b, s)) -> s -> (b, s)"
05:42:35 <merijn> adas: If you look at the type you see it's secretly just passing an extra s as argument to every function and returning an extra s as result!
05:43:08 <merijn> adas: Of course, since you return a *different* s every time (look at our incrementer function!) it looks as if we're "changing" the state
05:43:23 <merijn> While in reality we're just passing extra arguments and returning slightly modified versions of it
05:43:35 <KingofFerrets> ...Hm.
05:44:26 <adas> merijn: thanks.. i like the substitution method of explaining the state monad
05:44:48 <merijn> adas: When in doubt, grab a piece of paper and manually substitute/expand type variables!
05:44:53 <merijn> adas: You'll learn a ton
05:45:08 * Kinnison found the State monad to be one of the best ways to learn and understand monads
05:45:34 <merijn> adas: Of course in reality (>>=) does a little bit more, since it has to wrap/unwrap the State constructor from the function, but that's basically all
05:45:45 <KingofFerrets> Okay. So I have it so that runState stateRandom (insert a generator here) returns a random number, but I'm having trouble chaining that together.
05:46:04 <KingofFerrets> (a random number and a new generator, of course)
05:46:08 <merijn> KingofFerrets: You're not supposed to runState, you're supposed to chain using >>= and >> and runState the end result of that
05:46:18 <KingofFerrets> Alright.
05:46:26 <int-e> ramses_: There's Data.Text.Lazy.Builder in conjunction with D.T.L.B.Int.decimal - but for big integers the pack . show version will perform better. (the D.T.L.B.I.decimal implementation uses iterated division by 10, while 'show' uses a more clever divide and conquer algorithm, which performs better (in conjunction with gmp; integer-simple is a different story).)
05:47:33 <merijn> :t let increment = do { x <- get; put (x+1) } in increment
05:47:34 <lambdabot> (Num s, MonadState s m) => m ()
05:47:48 <ramses_> int-e: ah, that's interesting, is the string in between elliminated somehow then? Because it was the string that made me worry about the performance
05:47:53 <merijn> :t let increment = do { x <- get; put (x+1) } in (increment >> increment)
05:47:54 <lambdabot> (Num s, MonadState s m) => m ()
05:48:07 <merijn> > let increment = do { x <- get; put (x+1) } in runState (increment >> increment) 0
05:48:07 <ramses_> eliminated*
05:48:08 <lambdabot>   ((),2)
05:48:18 <KingofFerrets> merijn: Can you give me an example syntax on that? I'm trying a few different ways of doing that and they're not working. x.x
05:48:33 <merijn> KingofFerrets: There you go :p
05:49:22 <KingofFerrets> aha.
05:50:24 <merijn> KingofFerrets: >> puts multiple independent State action in a row, >>= lets you use the result of the previous State action (like it does with IO)
05:50:50 <int-e> ramses_: well, it'll be produced lazily and turned directly into a stream.
05:50:55 <merijn> You can use do notation to, since that just desugars to >> and >>=
05:51:12 <merijn> > let increment = get >>= \x -> put (x+1) in runState (increment >> increment) 0
05:51:14 <lambdabot>   ((),2)
05:52:00 <ramses_> int-e: right, pack will just consume one lazily produced digit after the other. Ok, thanks :)
05:53:34 <KingofFerrets> Does >> pass along just the updated state, and in >>= it cares about what the a you got from the previous iteration was?
05:53:54 <Mon_Ouie> You can also use modify to define increment
05:54:01 <Mon_Ouie> :t modify (+1)
05:54:02 <lambdabot> (Num s, MonadState s m) => m ()
05:54:04 <merijn> KingofFerrets: Yes
05:54:06 <quicksilver> KingofFerrets: yes.
05:54:12 <merijn> KingofFerrets: Look at the types
05:54:16 <merijn> :t (>>)
05:54:17 <lambdabot> Monad m => m a -> m b -> m b
05:54:19 <merijn> :t (>>=)
05:54:19 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:54:53 <merijn> Let's specialise to State s: "(>>) :: State s a -> State s b -> State s b" and "(>>=) :: State s a -> (a -> State s b) -> State s b"
05:55:02 <KingofFerrets> Alright, that clarifies some of my confusion... I was thinking I needed to use >>= to get the state to go anywhere.
05:55:22 <merijn> KingofFerrets: What >> and >>= do is transport the State around for you
05:55:22 <quchen> KingofFerrets:  a >> b  =  a >>= \_ -> b. >> and >>= don't do anything different conceptually, except that >> doesn't use the value that it receives.
05:56:10 <merijn> KingofFerrets: How they do that, depends on your implementation of >> and >>= for State
05:57:15 <KingofFerrets> quchen: Yeah, that's why I got confused. I knew >> didn't normally use the value, and I thought the state was part of the value. But I can sorta see how it works now.
05:57:49 <merijn> KingofFerrets: The trick is to see that "State s" is the monad, and not "State"
05:58:08 <KingofFerrets> merijn: ....ahhhh. That's true.
05:58:09 <Kinnison> Indeed
05:58:33 <merijn> KingofFerrets: That's the feeling of enlightenment ;)
05:58:46 <KingofFerrets> So since I have State StdGen, it passes the generator around by using the monad, even though it's ignoring the value actually wrapped in the monad.
05:59:08 <merijn> KingofFerrets: You could implement your own implementation of State with the info from this discussion, it's very helpful in understanding and fairly simple
05:59:22 <merijn> KingofFerrets: Yes
05:59:31 <KingofFerrets> I'm considering doing that.
05:59:41 * Kinnison highly recommends doing your own basic state monad
05:59:45 <Kinnison> it's very very handy
05:59:52 <Kinnison> (for learning)
06:00:02 <merijn> Most of the code has been typed in here already, only the actual implementation of >>= and return wasn't :p
06:00:13 <prophile> fun fact of the day
06:00:20 <KingofFerrets> Bleh... going to need to review how to make instances of stuff. :P
06:00:26 <prophile> FRP-style event streams are just the continuation monad with IO () as the eventual type
06:00:53 <prophile> and you can just bind to their events with `runCont` (doSomething)
06:01:46 <merijn> KingofFerrets: "instance Monad (State s) where" there, done reviewing :p
06:02:06 <merijn> KingofFerrets: All you need to do is implement (>>=) and return after that where
06:02:07 <quchen> KingofFerrets: Every Monad only has one "value". The rest is environmental stuff. It's important to note that "State" isn't actually a Monad, but "State s" is.
06:02:10 <merijn> Might wanna use "MyState s" instead of State to avoid name clashes, though
06:02:48 <KingofFerrets> merijn: I actually already have that, copy-pasted from the State monad tutorial I linked earlier. It's being troublesome, though.
06:03:09 <merijn> KingofFerrets: In what sense?
06:03:24 <prophile> and adding a simple MonadPlus instance with (IO (), >>, return ()) as the monoid gives you merging and filtering
06:04:39 <KingofFerrets> Here's the contents of a StateMonad.hs I made: http://pastebin.com/kknqbRUQ
06:04:40 <mauke> The paste kknqbRUQ has been copied to http://sprunge.us/KIDT?haskell
06:05:18 <merijn> KingofFerrets: two things, by default you can't type type signatures for instances (you need an extension to write those)
06:05:33 <merijn> KingofFerrets: Two, you need to indent the function relative to the start of "instance"
06:05:54 <quchen> Three, you need to define "data MyState ..." somewhere.
06:06:25 <hpaste> merijn pasted “indent + comment” at http://hpaste.org/90224
06:06:32 <merijn> oh, true
06:06:45 <quicksilver> or newtype perhaps
06:07:01 <merijn> And you need to implement runState
06:07:27 <hpaste> quchen annotated “indent + comment” with “indent + comment (annotation)” at http://hpaste.org/90224#a90225
06:07:36 <prophile> is there a Monoid instance for IO () anywhere sensible?
06:07:45 <KingofFerrets> What language extension do I need?
06:07:54 <quchen> Eh, sorry if that was a spoiler.
06:08:17 <merijn> Not sure, really, easiest to leave the type signatures commented out
06:08:27 <KingofFerrets> Mmkay.
06:08:45 <merijn> KingofFerrets: The type signatures were already provided by the class, so GHC already knows what they are
06:10:50 <supki> KingofFerrets: InstanceSigs
06:12:03 <KingofFerrets> Bleh, so, I need to figure out runState... hm.
06:13:57 <KingofFerrets> Yay, functioningness.
06:15:45 <jbnicolai> Hi guys, so I have a no doubt ridiculously basic question regarding Hakyll. Would any of you be able to have a quick look at http://jbna.nl/hakyll.txt and tell me how to merge all he duplicate blocks?
06:15:56 <jbnicolai> What I'm simply trying to do is match posts/{topicname}/* to {topicname}.html
06:16:10 <akegalj> merijn: thans once again, Data.Text works great
06:16:12 <jbnicolai> Right now I'm explicitly listing each topic, which seems redundant
06:17:17 <jbnicolai> I'm obviously fairly new to haskell :)
06:19:55 <ion> jbnicolai: I don’t know what facilities hakyll provides for this, but you could refactor the current code to use forM_. Something like: forM_ ["cs", "philosophy", "practical", …] $ \cat -> do match (cat ++ ".html") $ route idRoute; create (cat ++ ".html") $ constA mempty >>> …
06:20:59 <merijn> akegalj: In general, avoid String for anything that's more than 10-20 characters
06:21:00 <merijn> akegalj: Glad it works :)
06:22:48 <applikativ> avoid String, use Data.Vector.Unboxed.Vector Char
06:23:03 <ksf> @djinn a -> b -> (a -> b)
06:23:03 <lambdabot> f _ a _ = a
06:23:39 <ksf> aaaaaaaah
06:23:52 <ksf> that's what the product stuff in CCCs is about
06:24:04 <applikativ> @djinn a -> b -> c -> b
06:24:04 <lambdabot> f _ a _ = a
06:24:08 <KingofFerrets> So, if I have a do block, does the block itself return the monad at the end? Since it desugars to a bunch of >> and >>=, and those all return m b?
06:24:18 <quchen> KingofFerrets: Yes.
06:24:27 <applikativ> the whole block has the type of the last line
06:24:39 <ion> applikativ: Why not Data.Text?
06:24:53 <ion> ksf: CCCs?
06:25:18 <ksf> cartesian closed categories, but I think I just brainfarted.
06:25:19 <applikativ> what if I want to zip it with enunFromTo 1 n ?
06:25:28 <applikativ> you can't do anything with Text
06:25:48 <applikativ> enumFromTo
06:27:04 <ion> That’s a special case. “Use Vector Char instead of Text in the following special cases” is fine. :-)
06:27:20 <ksf> how is (->) pronounced, anyway?
06:27:24 <ksf> aside from "implies"
06:27:41 <applikativ> ion of course I agree
06:27:55 <applikativ> ksf 'to'
06:27:56 <b2coutts> I personally pronounce it as "makes"
06:28:02 <b2coutts> oh, I guess that makes more sense
06:28:25 <ksf> "to" would work, I guess.
06:29:00 <ion> ksf: “a -> b”: “a function from a to b”, perhaps leaving “a function from” implicit if appropriate.
06:31:59 <jbnicolai> ion: Thanks! I'm getting an error though, could you have a quick look? The line with match (cat ++ ".html) $ roude idRoute -s giving me "Couldn't match epected type Pattern a0 with actial type [a1]. http://jbna.nl/hakyll.txt
06:33:28 <applikativ> what is the type of 'match'?
06:33:28 <ion> jbnicolai: Please paste the full error message.
06:33:44 <b2coutts> huh
06:34:00 <merijn> KingofFerrets: Well, after desugaring the entire block is just a single expression whose return value is the type of the last line
06:34:04 <b2coutts> I only just realized that f :: a -> b syntax is designed to mimic math notation
06:34:12 <b2coutts> seems kind of obvious in retrospect
06:34:22 <merijn> KingofFerrets: Which, incidentally, is why you need to end the block with "return x" if x is pure
06:35:44 <jbnicolai> ion: http://jbna.nl/hakyll.txt updated with full error on top.
06:36:04 <jbnicolai> applikativ: match :: Pattern -> Rules () -> Rules ()Source
06:36:38 <ion> jbnicolai: Alright, so those are overloaded strings. That means we won’t be able to use ++ directly. Would this work? match (fromString (cat ++ ".html"))?
06:36:42 <applikativ> right, so Pattern is an IsString thing, so the problem is ++
06:36:56 <applikativ> like ion says...
06:37:04 <ion> jbnicolai: fromString is in Data.String if you don’t have it in scope.
06:37:16 <applikativ> or is Pattern a monoid?
06:37:40 <applikativ> since the things in the list are explicit literals and can be read as Patterns
06:37:56 <ion> Also, does setFieldPageList want a Pattern. a String or something else?
06:37:58 <applikativ> so cat <> ".html" would make sense.
06:38:18 <ion> @hoogle setFieldPageList
06:38:18 <lambdabot> No results found
06:39:24 <applikativ> the hakyll dsl is comparatively handsome
06:39:44 <applikativ> needs more template haskell !!
06:41:32 <jbnicolai> Thanks guys, so the error indeed went away. Now, however, it gives me a parsing error on the first line of the next block
06:41:54 <KingofFerrets> Hm. I guess I need to return a monadic type in this function instead of a pure one. :/
06:42:07 <ion> jbnicolai: Count your parentheses.
06:42:09 <jbnicolai> http://jbna.nl/hakyll.txt again, suggesting incorrect indentation on match "index.html" ... line 51
06:43:18 <applikativ> (fromString (("posts/" ++ cat ++ "/")
06:43:22 <jbnicolai> Sorry, that was just dumb. Thanks a LOT ion and applikativ  :)
06:43:30 <ion> jbnicolai: Also note that fromString is redundant for anything that already takes a String. So, for instance, if setFieldPageList happens to take a String, ("posts/" ++ cat ++ "/") works without fromString.
06:44:10 <jbnicolai> ion: Doesn't work I'm afraid, so I guess it doesn't take a string
06:44:23 <ion> alright
06:44:32 <jbnicolai> setFieldPageListSource
06:44:33 <jbnicolai> :: ([Page String] -> [Page String])
06:44:36 <KingofFerrets> So, I have a function that's going to be Automaton -> Double -> Double -> State StdGen Double -> State StdGen Automaton, I think... Because I want to get the random number generator back out after I've used it...
06:44:50 <KingofFerrets> (Automaton being a special type for my work)
06:45:33 <merijn> KingofFerrets: What problem are you having with that?
06:45:52 <KingofFerrets> But, the State stuff is essentially a function, I think, right?
06:46:15 <merijn> KingofFerrets: Yes
06:46:17 <ion> Yeah, it’s a wrapper over s -> (a, s)
06:47:09 <ion> Are you sure you need a parameter of type State StdGen Double, btw?
06:47:19 <KingofFerrets> Yeah, I'm thinking I might not...
06:47:39 <merijn> KingofFerrets: What would you use it for?
06:48:11 <KingofFerrets> Basically, I have an Automaton, which is a ring lattice graph, and I'm turning it into a small-world graph.
06:48:26 <ion> You rarely want a parameter of type SomeMonad a when you return a SomeMonad a. (A good example of an exception to this is e.g. Control.Exception.bracket.)
06:49:04 <ion> or anything named withSomething
06:49:34 <ion> (Well, those typically want a parameter of type (foo -> SomeMonad a).)
06:49:50 <KingofFerrets> ...would I want to do Automaton -> Double -> Double -> State StdGen Automaton, and the State StdGen Automaton is a function that, given a generator, gives back the appropriate automaton?
06:50:18 <KingofFerrets> Is that how I'd implement it properly?
06:50:41 <merijn> KingofFerrets: Sure
06:50:45 <ion> Probably.
06:51:21 <Aetherspawn> | looks nicer than $
06:51:55 <supki> | is syntax though
06:52:00 <Aetherspawn> I know :(
06:52:00 <ion> ☺ looks even nicer
06:52:04 <Aetherspawn> lol
06:52:08 <KingofFerrets> ...That could be useful, actually. Run it a few times, and it'd give me a new random small-world graph based on the lattice...
06:53:04 <merijn> KingofFerrets: I dunno what the Doubles are, but you might even want to have "Double -> Double -> Automation -> State StdGen Automaton"
06:53:29 <Gurgeh> hi
06:54:00 <quchen> How long does the Haskell Reddit usually take to submit something? It's been two hours and it hasn't appeared on the front page.
06:54:01 <ion> kingofferrets: There’s also MonadRandom which like State StdGen, but with some additional niceties.
06:54:17 <merijn> That way you could do like "foldr1 (>>) repeat (myThing 0.0 1.0)"
06:54:31 <merijn> eh, insert a $ after (>>) there
06:54:45 <KingofFerrets> merijn: They're parameters for the model. Like, "it has a 30% chance of this thing" is representing by passing in 0.3 for one of the Doubles.
06:55:04 <Gurgeh> I have translated a C snippet to Haskell. I'd like it to perform well, but I think that it currently is a bit embarrasing. Would someone like to take a look at a hpaste?
06:55:21 <merijn> KingofFerrets: My order you can partially apply the double and then chain the remaining "Automaton -> State StdGen Automaton"
06:55:48 <KingofFerrets> No, I wouldn't want to foldr; an Automaton that's suitable as the first parameter isn't the same Automaton I'll get back. I'd want to run it on the Automaton repeatedly.
06:55:54 <b2coutts> ion: haha, I just because I was wondering whether or not it would work; you can actually define ☺ as an operator
06:55:58 <ion> gurgeh: You’ll get better results on IRC by just sharing the hpaste.
06:56:00 <ion> b2coutts: yeah
06:56:00 <KingofFerrets> I'd actually be more likely to want to partially apply the Automaton and then stick in different Double values.
06:56:04 <ksf> you can also call (->) "category", as it figures.
06:56:28 <ksf> but "to" really is better.
06:57:16 <h4199> Gurgeh: Just paste it. If someone can help you they will
06:57:29 <KingofFerrets> So that I could get "oh hey here's a random version of this modified with these Double parameters, and here's one with these other parameters, and..."
06:58:05 <burkaman> quchen: If it still isn't there then it's probably caught in the spam filter. Message the mods and they can check for you.
06:58:14 <elliott> "category" seems like a hideously misleading name for (->)...
07:01:26 <quchen> burkaman: Thanks
07:01:27 <hpaste> Gurgeh pasted “An attempt to translate a C function” at http://hpaste.org/90226
07:02:32 <ksf> elliott, well, it's "instance Category (->)".
07:02:38 <ksf> so what is ->? a category.
07:03:04 <elliott> I'll start calling [a] "category" too then :)
07:03:11 <ion> So what is ->? a Strong.
07:03:28 <ksf> well, you could call it Hask or such.
07:03:59 <ksf> but that's actually only because haskell is lame enough not to make (->) a typeclass.
07:05:18 <elliott> wat
07:05:47 <KingofFerrets> merijn: So, would it work to have something like "myFunc aut doub1 doub2 = State randomAut where randomAut :: StdGen -> (Automaton, StdGen)" and then make a randomAut that has certain values in it determined by the arguments to myFunc?
07:05:56 <ion> gurgeh: I wonder if “low2 `seq` range2 `seq` loop low2 range2 xs <> makeCode low2 range2” makes it any better?
07:06:35 <merijn> KingofFerrets: Yes
07:06:54 <KingofFerrets> Okay, awesome. Time to write that.
07:07:05 <merijn> KingofFerrets: Generally you wouldn't use "State" and "StdGen -> (Automaton, StdGen)" directly, though
07:07:09 <hpaste> Gurgeh revised “An attempt to translate a C function”: “A cleaned up attempt” at http://hpaste.org/90226
07:07:18 <KingofFerrets> What would I use, then?
07:07:20 <merijn> KingofFerrets: You'd just use get/put/modify to create a State StdGen Automaton
07:07:32 <merijn> :t get
07:07:33 <lambdabot> MonadState s m => m s
07:07:36 <KingofFerrets> aha
07:07:48 <merijn> KingofFerrets: And write the entire thing using do
07:08:17 <merijn> :t let foo = do { x <- get; put (x+x); return x } in foo
07:08:18 <lambdabot> (Num b, MonadState b m) => m b
07:08:43 <merijn> Pretend that that says "Num a => State a a"
07:09:02 <ion> > let r = state . randomR in (`runState` mkStdGen 42) $ do a <- s (0,10); b <- s (20, 30); return (a, b, a+b)
07:09:03 <lambdabot>   Couldn't match expected type `(t0, t1)
07:09:03 <lambdabot>                                -> Co...
07:09:12 <merijn> You could use "let foo = do { x <- get; put (x+x); createAuomaton x } in foo"
07:09:13 <ion> > let r = state . randomR in (`runState` mkStdGen 42) $ do a <- r (0,10); b <- r (20, 30); return (a, b, a+b)
07:09:15 <lambdabot>   ((4,29,33),128694412 1655838864)
07:09:27 <merijn> Where createAutomaton :: StdGen -> Automaton
07:09:41 <Gurgeh> ion: please explain why you think it would
07:10:21 <KingofFerrets> merijn: ...hm. So, would I be better off trying to learn the more standard Haskell syntax now, or working with the way that's currently intuitive to me and learning to translate that into a more standard form once I have a better grasp on monads in general?
07:10:40 <merijn> KingofFerrets: Your call, either would work
07:11:21 <ion> gurgeh: encode might be accumulating a huge thunk out of low2 and range2 that will get evaluated only when you use the resulting Builder somewhere. *If* that happens to be the case, forcing the values on each iteration should help.
07:11:51 <Gurgeh> would an alternative to seq be to use bang patterns in the definition of loop?
07:12:17 <ion> Pretty much, yeah.
07:12:37 <ion> Perhaps in makeCode as well.
07:13:07 <applikativ> isn't one problem that loop isn't properly 'tail recursive' as well
07:13:34 <applikativ> it should have another parameter to which <> makeCode low2 range2 is appended?
07:15:12 <KingofFerrets> merijn: If I used "let foo = do { x <- get; put (x+x); createAutomaton x } in foo", can I have a "where" or something that lets me say what createAutomaton is, since I have to have a different createAutomaton based on what the arguments to my original function are?
07:16:44 <Gurgeh> OK, ion, I added the bang patterns. I should probably do some criterion benchmarks now to know what I'm doing
07:17:52 <ion> kingofferrets: I’m not sure i’d use get and put in the main State StdGen.code. I’d rather use State wrappers for random and randomR (which already happen to have the (s -> (a, s)) form). Also, MonadState already has them for you if you don’t feel like NIHing it.
07:18:16 <merijn> KingofFerrets: Sure
07:18:17 <hpaste> applicative annotated “An attempt to translate a C function” with “An attempt to translate a C function (annotation)” at http://hpaste.org/90226#a90228
07:18:30 <merijn> KingofFerrets: It's still just a normal function
07:19:23 <applikat1v> Gurgeh: here's my version http://hpaste.org/90228 fwiw
07:22:15 <applikativ> Gurgeh: I'm not sure this idea of making it loop that way is right for Builder on reflection but maybe.
07:24:17 * hackagebot citation-resolve 0.2.4 - convert document IDs such as DOI, ISBN, arXiv ID to bibliographic reference.  http://hackage.haskell.org/package/citation-resolve-0.2.4 (TakayukiMuranushi)
07:26:29 <Aetherspawn> > let a = [1..5] in \(a:b:c:xs) -> (show a) ++ ", " ++ (show b) ++ ", " ++ (show c)
07:26:30 <lambdabot>   <[()] -> [Char]>
07:27:04 <Aetherspawn> > let { a = [1..5]; f (a:b:c:xs) -> (show a) ++ ", " ++ (show b) ++ ", " ++ (show c) } in f a
07:27:05 <lambdabot>   <hint>:1:32: parse error on input `->'
07:27:14 <Aetherspawn> Ugh, sorry.
07:27:52 <Aetherspawn> > let { a = [1..5]; f (a:b:c:xs) = (show a) ++ ", " ++ (show b) ++ ", " ++ (show c) } in f a
07:27:53 <lambdabot>   "1, 2, 3"
07:28:28 <ion> > intercalate ", " [1,2,3]
07:28:30 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
07:28:30 <lambdabot>    arising from the literal ...
07:28:38 <ion> > intercalate ", " . map show $ [1,2,3]
07:28:39 <lambdabot>   "1, 2, 3"
07:29:11 <Aetherspawn> ion, I was testing a:b:c.. didn't know that worked
07:29:20 <Aetherspawn> I thought it was strictly a a:b thing :)
07:29:47 <ion> a:b:c:ds is still strictly an a:b thing, it’s just there thrice. :-P
07:30:11 <ion> a:foo where foo = b:bar where bar = c:ds
07:30:26 <Aetherspawn> oh dear.
07:31:01 <ion> > 1:(2:(3:[]))
07:31:01 <lambdabot>   [1,2,3]
07:31:09 <Aetherspawn> let { a = [1..5]; f (x:(a:b)) = (x,a,b) } in f a
07:31:13 <Aetherspawn> > let { a = [1..5]; f (x:(a:b)) = (x,a,b) } in f a
07:31:14 <lambdabot>   (1,2,[3,4,5])
07:31:25 <Aetherspawn> syntax sugar, mind blown.
07:31:37 <ion> The only syntactic sugar in there is [1..5]
07:35:11 <KingofFerrets> merijn: So is this approximately a format that should work, if I went and defined a genTrans and genFin? http://pastebin.com/8Eac9nAp
07:35:16 <mauke> The paste 8Eac9nAp has been copied to http://hpaste.org/90229
07:36:34 <KingofFerrets> (also, ignore the fact that a bunch of things talk about states inside Automaton constructors, we have a thing called states in our automata that's completely unrelated to the State monad)
07:36:43 <ion> kingofferrets: State . runState is redundant.
07:37:37 <KingofFerrets> ion: I knew there was something weird with that... So just get rid of the Where and move the do block up?
07:38:29 <ion> kingofferrets: Yeah. Also, genTrans and genFin share the same state of the random generator which is probably not what you want. You’ll want to refrain from accessing a “gen” directly in most places, that’s the point of the State monad.
07:38:41 <KingofFerrets> ah, true.
07:39:13 <ion> kingofferrets: You’ll want “newTrans <- genTrans; finalStates <- genFin” where both genTrans and genFin are State StdGen actions as well.
07:39:59 <KingofFerrets> so they're of type StdGen -> (Whatever, StdGen)?
07:40:27 <ion> To be precise, they’re of type State StdGen Whatever, which wraps a function of that type.
07:40:49 <KingofFerrets> aha. Hm.
07:42:00 <KingofFerrets> If I define them in a where block, I should be able to access transFunc and states from the arguments of smallWorldRewire without actually passing them into those, right?
07:42:33 <ion> yeah
07:44:31 <ion> If you use these, you should be able to avoid referrin directly to the StdGen within your State code altogether. And of course, MonadRandom would also provide these for you. sRandom :: (MonadState g m, RandomGen g, Random a) => m a; sRandom = state random; sRandomR :: (MonadState g m, RandomGen g, Random a) => (a, a) -> m a; sRandomR range = state (randomR range)
07:45:45 <KingofFerrets> genTrans :: RandomState [(State, Int, State)]    genFin :: RandomState [State] (where State is a type imported from Automaton that has nothing to do with the State monad) should be the right type signatures, if I want newTrans to be [(State,Int,State)] and finalStates to be [State]?
07:46:14 <ion> yeah
07:46:38 <KingofFerrets> Alright.
07:48:08 <ion> > let sRandom :: (MonadState g m, RandomGen g, Random a) => m a; sRandom = state random; sRandomR :: (MonadState g m, RandomGen g, Random a) => (a, a) -> m a; sRandomR = state . randomR in (`runState` mkStdGen 42) $ do a <- sRandom; b <- sRandom; c <- replicateM 10 (sRandomR ('a', 'z')); return (a :: Word8, b :: Char; c)
07:48:09 <lambdabot>   <hint>:1:317: parse error on input `;'
07:48:29 <ion> > let sRandom :: (MonadState g m, RandomGen g, Random a) => m a; sRandom = state random; sRandomR :: (MonadState g m, RandomGen g, Random a) => (a, a) -> m a; sRandomR = state . randomR in (`runState` mkStdGen 42) $ do a <- sRandom; b <- sRandom; c <- replicateM 10 (sRandomR ('a', 'z')); return (a :: Word8, b :: Char, c)
07:48:31 <lambdabot>   ((207,'\368463',"feolyrgnvd"),150664982 1924298326)
07:53:08 <ion> kingofferrets: http://hackage.haskell.org/packages/archive/MonadRandom/latest/doc/html/Control-Monad-Random.html
07:53:54 <KingofFerrets> ion: Sweet, thanks.
07:54:00 <ion> kingofferrets: getRandom and getRandomR are the MonadRandom equivalents to sRandom and sRandomR above.
07:55:07 <ion> and evalRandIO is the equivalent to evalState yourCode <$> newStdGen
07:59:10 <robde> hello. is it even possible to implement a function with this type signature? foo e :: (Monoid m) => a -> (m,a)
07:59:59 <ion> foo e = (mempty, e)
08:03:36 <hvr> Luke: for some reason I couldn't get yasnippets to work with ido-mode yet (but I'll try again later)
08:03:57 <Luke> hvr: do you have the latest version of yasnippet?
08:04:07 <Luke> some of the function names changed from yas/* to yas-*
08:04:23 <hvr> Luke: i've got one from MELPA, that should be at most 1 month old
08:04:36 <Luke> hvr: I'm not sure when the function names changed
08:04:42 <hvr> I
08:04:54 <hvr> 'll update to latest snapshot before I re-try
08:05:00 * hvr needs to go now
08:05:03 <Luke> hvr: ok
08:08:56 <robde> ion: oh. that makes sense.
08:09:46 <robde> how about  :: (e -> (e -> a)) -> (e -> a)?
08:11:11 <Taneb> robde, yes
08:11:28 <Taneb> Think about it as (e -> e -> a) -> e -> a
08:13:10 <dmwit> robde:
08:13:19 <dmwit> ?djinn (e -> (e -> a)) -> (e -> a)
08:13:19 <lambdabot> f a b = a b b
08:13:45 <ksf> @djinn  (Monoid m) => a -> (m,a)
08:13:45 <lambdabot> Error: Class not found: Monoid
08:14:00 <ksf> f a = (mempty, a)
08:14:10 <dmwit> ?djinn-add class Monoid m where mempty :: m; mappend :: m -> m -> m
08:14:22 <dmwit> ?djinn Monoid m => a -> (m, a)
08:14:22 <lambdabot> f a = (mappend mempty mempty, a)
08:14:22 <ksf> @djinn  (Monoid m) => a -> (m,a)
08:14:23 <lambdabot> f a = (mappend mempty mempty, a)
08:14:31 <dmwit> hah
08:14:41 <chrisdone> how do you pronounce mappend and mempty?
08:14:51 <ksf> emappend emempty
08:14:51 <dmwit> chrisdone: 0 and + ;-)
08:14:57 <chrisdone> dmwit: purist!
08:15:05 <chrisdone> ksf: me2
08:15:59 <chrisdone> dmwit: actually it could be 0 and *, depending on the instance!!
08:16:07 <Hafydd> > "hello" `mappend` "world"
08:16:08 <lambdabot>   "helloworld"
08:16:16 <chrisdone> dmwit: needs moar 0 and • =p
08:16:20 <Hafydd> I suppose that's why they named it so.
08:17:15 <Hafydd> But the elephant in the room is that the class itself is called "Monoid"!
08:17:19 <dmwit> chrisdone: I'm sure you meant 1 and *
08:17:51 <t7> > mempty `mappend` mempty :: String
08:17:52 <lambdabot>   ""
08:18:22 <Dtgr> how would one link a haskell program from .o files made with "ghc -c"? i'm getting a bunch of linker errors (using ghc --make) from libraries that i've been using in the program
08:18:45 <ksf> Dtgr, it's involved.
08:18:56 <ksf> and that's still an euphemism.
08:18:57 <elliott> is there a particular reason you're using ghc -c?
08:19:13 <elliott> dmwit: 0 and + for monoids? disgusting.
08:19:19 <ksf> let's start by calling ghc-pkg to get at the .o files of the libraries.
08:19:26 <elliott> I think you'll find that multiplication is by far the easier operation.
08:19:36 <ksf> for which you must know what libraries you need in the first place, which requires dependency analysis, tec.
08:20:35 <elliott> chrisdone: I pronounce "em-empty" and either "mappend" like some freaky hybrid of "map" and "append" or just "em-append" depending
08:20:48 <dmwit> Dtgr: Unless there's a good reason not to, just use ghc name-of-module-with-main-in-it or "cabal install".
08:21:04 <dmwit> Dtgr: Don't worry; it won't recompile things unless something drastic has changed.
08:21:20 <dmwit> Dtgr: In case you are on a GHC that is more than, let's say... two years old? you may need to add --make.
08:21:58 <Dtgr> ah, okay. seems that it's more clever than i thought
08:22:11 <Clint> chrisdone: məˈpɛnd and ˈmɛmpti
08:22:49 <Hafydd> http://www.proofwiki.org/wiki/Definition:Monoid http://en.wikipedia.org/wiki/Monoid#Definition http://www.encyclopediaofmath.org/index.php/Monoid all favour some variant of "*".
08:24:09 <ksf> Dtgr, even if you compile file by file, you can use ghc's make stuff for linking at the end.
08:24:10 <Hafydd> So mtimes and mone could be reasonable alternatives, perhaps.
08:24:26 <Gothmog_> + is usually used for commutative structures only
08:24:31 <ksf> just make sure the linking invocation can find the rest, it's going to think the files are from a previous run.
08:24:42 <Dtgr> aight
08:24:43 <ksf> ...in case you *really* need parallel builds.
08:25:13 <ksf> to the best of my knowledge, only ghc itself uses make
08:25:24 <robde> Taneb: I’m trying to find a function that matches (e -> (e -> a)) -> (e -> a)
08:26:04 <Hafydd> Like IEEE floating point arithmetic.
08:26:11 <ksf> ...or packages that are so old that they don't compile anymore, anyway.
08:26:20 <analog> hi guys, just a quick question, are there any plans to bring dependent types to Haskell ? was it ever an intent to do that ?
08:26:31 <ksf> nope. but yes, there's related languages.
08:26:39 <ksf> the reason is type inference.
08:27:50 <ksf> haskell (without extensions) is supposed to need no type annotations and need no proof obligations, and that clashes with dependent types.
08:28:25 <Peaker> ksf, except in ambiguous type situations
08:28:48 <analog> i understand this was the original design
08:29:14 <analog> but i also see a lot of work done to try to emulate dependent types
08:29:33 <analog> *simulate
08:29:34 <edvardkk> so I am a total noob. I have a RVarT (Writer String) (Population [Bool]), but can't figure out how to run it
08:30:34 <edvardkk> tried various combinations of runRVarT, but seems I can't get the type annotation correct
08:30:56 <Lethalman> hi, i'm getting http://hpaste.org/90231 while cabal instal djinn
08:30:58 <Lethalman> any hints?
08:31:06 <edvardkk> any help would be greatly appreciated :-)
08:31:28 <robde> dmwit: I don’t quite understand why ? djinn returns f a b = a b b
08:32:26 <ksf> analog, yes, but it's all trying to keep as much inference as possible.
08:32:40 <dmwit> robde: Okay. Can you explain why it surprises you? Do you agree it has the right type?
08:32:51 <ksf> maybe once that design space has been completely exhausted simon will move on to -XDependentTypes.
08:33:02 <ksf> meanwhile, use idris.
08:34:11 <dmwit> edvardkk: Bonus points for posting some minimal example code and the exact error you got to hpaste.org.
08:35:07 <dmwit> Lethalman: Dunno! Maybe cabal unpack djinn and take -Wl out of the cabal file and see what happens?
08:35:26 <t7> ksf: or use constraint haskell
08:35:42 <t7> 123 :: Int where n < 256
08:36:06 <analog> :) i was just writing something and was in need to parametrize over some dimensions and the way repa does it using type families looks kind of hackish although it works
08:36:22 <Lethalman> dmwit, yes the problem is -optl-Wl , it must be something problematic with ghc anyway
08:36:24 <Lethalman> thanks :-)
08:40:31 <edvardkk> dmwit: http://hpaste.org/90232  hope that's enough.  tho, not really 40% sure what I'm doing :-)
08:40:52 <geekosaur> Lethalman, is this OS X by any chance?
08:41:00 <Lethalman> geekosaur, ubuntu precise
08:41:08 <geekosaur> oh
08:41:16 <Lethalman> ghc 7.6.2
08:41:23 * geekosaur gets that error from a number of things with OS X, ghc 7.6.2
08:41:43 <Lethalman> so we can conclude -optl-Wl is just broken :S
08:41:57 <geekosaur> quite possibly :/
08:42:16 <monochrom> "-optl-Wl" without a follow-up "-optl-what?" is like you go to IRC and say "hi monochrom I have a question" and then don't ask any question
08:42:46 <monochrom> "hi gcc I have an option for the linker"
08:43:13 <elliott> hi monochrom I have a question
08:43:41 <chrisdone> unsafePerformAskIncompleteQuestion
08:43:55 <Lethalman> monochrom, so -optl-Wl is straight -Wl for gcc?
08:44:14 <Peaker> where is the Generic class supposed to be imported from?  GHC.Generic? Having GHC in a module name feels unclean :(
08:44:14 * hackagebot NetSNMP 0.3.0.3 - Bindings for net-snmp's C API for clients  http://hackage.haskell.org/package/NetSNMP-0.3.0.3 (PavloKerestey)
08:44:37 * chrisdone washes Peaker with portability cream
08:44:58 <monochrom> perhaps a long time ago, it happened to work by chance of other options that ghc happen to pass to gcc in a lucky order
08:45:04 <monochrom> yes Lethalman
08:45:27 <Lethalman> monochrom, ah, so indeed djinn cabal is broken :P
08:45:43 <dmwit> edvardkk: It is not enough. Give us enough code that we can pop it into our favorite compiler and play around. Including the error is just in case it's so obvious we don't even need to do that. =)
08:46:53 <edvardkk> ah, kk :-)
08:46:54 <Peaker> is there a nice pretty printing library that I can use to derive a pretty-printer for my type, pretty print a list of values of my types, etc?  i.e: a Show-like instance + deriving + standard instances for things like Data.Text?
08:51:53 <dmwit> Peaker: yeah, one moment
08:52:20 <dmwit> ?hackage ipprint
08:52:20 <lambdabot> http://hackage.haskell.org/package/ipprint
08:52:31 <dmwit> Really ingenious approach: it just embeds a Haskell parser and pretty-printer.
08:52:59 <dmwit> Perfect for debugging.
08:53:07 <quicksilver> so it uses the Show instances?
08:53:13 <Peaker> i.e: goes via Show?
08:53:17 <quicksilver> Shows it to haskell text and then pretties that?
08:53:31 <dmwit> Right.
08:54:20 <Peaker> interesting, depends on Haskelly Show instance though
08:54:40 <quicksilver> on the other hand, non-Haskelly Show instances are immoral.
08:54:57 <monochrom> it calls show, then parses the String back to a simple AST (assumes sane Show instances such as you add parentheses right), then it can layout the AST
08:55:00 <Peaker> The "GenericPretty" package is managing to print my record field names using only the "deriving Generic" clause -- and I thought Generic only exposed products/sums, and not the names (as to not allow renaming to break things)
08:55:50 <monochrom> it's a pretty lol approach and yet sadly 99% effective
08:57:55 <Peaker> dmwit, thanks, I'll use ipprint rather than the various Generics' based hammers
08:58:47 <elliott> there's also groom, dunno the differences
08:59:45 <Peaker> doh, installing ipprint installs the whole world
08:59:54 <monochrom> haha
09:00:35 <edvardkk> dmwit: okay, http://hpaste.org/90236, is the essence, I think. I want my random data back, and my writer output, but I'm not smart enough (yet) to know how ;)
09:00:40 <monochrom> um, what is it doing with all the pureMD5 and crypto-api stuff? is it to fight PRISM? :)
09:01:46 <Peaker> groom depends on sane packages I already had :)
09:02:48 <Peaker> yay, groom it is :)
09:02:52 <quchen> Did someone say MD5? Boo.
09:02:53 <Peaker> elliott, thanks
09:03:38 <quicksilver> Peaker: the source code to groom is pretty intimidating
09:03:40 <quicksilver> http://hackage.haskell.org/packages/archive/groom/0.1.2/doc/html/src/Text-Groom.html#groomString
09:03:50 <dmwit> edvardkk: At a guess, your monad transformer stack is going to have to have IO at the bottom.
09:03:55 <dmwit> or similar
09:04:16 <dmwit> edvardkk: e.g. RVarT (WriterT String IO) Double
09:04:21 <dmwit> edvardkk: But give me a few more seconds.
09:04:28 <edvardkk> hmmm, ok, yep, thanks
09:04:29 <Peaker> quicksilver, hah, nice :)
09:04:31 <edvardkk> :-)
09:04:55 <Peaker> except the unhygienic imports :)
09:07:42 <quicksilver> Peaker: forgivable in a program which only contains 3 references to external symbols I feel.
09:07:59 <quicksilver> or five including constructors.
09:08:36 <Peaker> hmm.. the limit here is the number of uses/exports which could raise ambiguity issues.. so really only "groomString"
09:09:13 <Peaker> if "groomString" is ever exported from these haskell-src-exts modules, it'll get a build error.. which is very unlikely, but the amount of work needed for hygiene is very small as well
09:09:23 <hpaste> dmwit annotated “bonkabonk” with “bonkabonk (annotation)” at http://hpaste.org/90236#a90237
09:09:27 <dmwit> edvardkk: ^^
09:09:43 <monochrom> this is analogous to what I said in the past. "what's the problem with one-liner web servers? isn't that progress?"
09:09:54 <monochrom> s/the problem/wrong/
09:10:28 <quicksilver> Peaker: will it?
09:10:37 <joelteon> why can't identifiers have dollar signs in them :(
09:10:37 <quicksilver> Peaker: I thought that local names always overrode imports
09:10:47 <dmwit> joelteon: they can
09:10:47 <monochrom> (I said it on slashdot a long time ago when those elitists objected one-liner web servers and wanted everyone to write long programs)
09:10:50 <quicksilver> and you only get ambiguity if you had the same name from two imports.
09:10:58 <adas> i got it. i think I got it... so the state monad can be described as a series of closures propagating from beginning till end..
09:11:05 <dmwit> > let foo $:$ bar = foo * 2 + bar in 3 $:$ 5
09:11:06 <lambdabot>   11
09:11:08 <adas> is that true?? ^^^
09:11:10 <edvardkk> dmwit: sweet! thanks :-) you saved me K hours with head-scratching
09:11:37 <monochrom> adas: that may be true just because of broad vagueness
09:12:36 <adas> monochrom: im sory. i know im way offf..im trying to get an intuition about it. merijn  was helping me this afternoon. and this is how far i got...
09:12:53 <Peaker> quicksilver, just checked, you get ambiguity errors for exports of a name that is both local and imported, and also errors for use of a name that is both local and imported
09:12:54 <chrisdone> <quicksilver> Peaker: the source code to groom is pretty intimidating — haha xD
09:13:05 <monochrom> too many things qualify as "closures". and all program executions are "propagating from beginning till end". it's a tautology.
09:13:41 <Peaker> "closure" is a pairing of some static piece of code with its dynamic lexical scope cells/values?
09:13:58 <quicksilver> adas: I think what you said is true if we take closure to mean what you want it to mean
09:14:05 <quicksilver> that's not really what closure really means though.
09:14:09 <gspr> adas: If I recall correctly, the "random numbers" example in http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html gives nice intuition about the State monad.
09:14:14 <quicksilver> and it's a bit vague even with that meaning
09:14:26 <gspr> adas: (Caveat: I may remember incorrectly)
09:14:40 <adas> thanks all. just realized i suck. back to the books..and the link : )
09:15:05 <Peaker> adas, the state monad is just how you generate a non-state-modifying for: a -> (s -> (s, a))   and how you chain two potentially-state-reading-and-writing functions of type (s -> (s, a)) together
09:15:32 <Peaker> (well, how you chain:  (s -> (a, s))   and:   (a -> s -> (b, s))
09:15:55 <Peaker> adas, "closures" is a low-level implementation detail, better to think of high-level functions here
09:16:19 <quicksilver> adas: you don't suck at all. You just didn't have the right word. I think you have got the idea fine.
09:16:45 <Peaker> quicksilver, everyone trivializes name conflict build errors, but when they happen you have to go through the ordeal of uploading a new version to hackage, and updating all the dependents too, and this can easily get horrific
09:16:57 <quicksilver> Peaker: you take me too seriously :) I agree with you.
09:17:12 <Peaker> quicksilver, a trivial fix in a package you indirectly depend on through 5 packages can become a nightmare (I went through such a nightmare and eventually had to fork a bunch of things :-(  )
09:17:23 <quicksilver> Peaker: although it sucks how much work is involved in maintaining explicit import lists of course.
09:17:35 <Peaker> quicksilver, I just use mostly qualified imports
09:18:13 <quicksilver> sure.
09:18:20 <quicksilver> I think that's pragmatic but ugly.
09:18:22 <quicksilver> you can't win :)
09:19:03 <Peaker> well, ugly&works is better than 10 slow email round trips, giving up, and forking a bunch of packages :)
09:19:30 <Peaker> "Oh I'm about to release a new major version in a few days anyway, so I'll reject your trivial fix".. 1 month later: "Oh, I didn't get to it yet, but I still reject your trivial fix" :(
09:19:50 <quicksilver> yes.
09:20:01 <quicksilver> ugly and works is the sensible choice.
09:20:02 <Peaker> Hackage should have some sort of mechanism to override bad package maintainers on clear-cut issues like build errors
09:20:07 * quicksilver chooses beautiful and broken.
09:20:34 <Peaker> you have a build error and a trivial fix? The package author isn't responding in a few days? Fix accepted until author overrides
09:22:01 <BigTom> Hi
09:22:35 <BigTom> does anyone have experience setting up haskellmode-vim on Windows
09:22:36 <BigTom> ?
09:23:02 <joelteon> so I'm trying to add a type to the markdown config that allows people to pass their own function for rendering code blocks
09:23:31 <joelteon> the problem is that code blocks can encapsulate other bits of markdown and ordinarily the practice is to call toMarkdown on the inside of the code block after rendering the <code> tags
09:24:05 <joelteon> so if I want to provide some field that's a function that allows you to render code blocks, it has to take a (Text -> Html) function that represents toMarkdown
09:24:15 <joelteon> and that seems really unintuitive to me
09:26:54 <joelteon> other option is to prerender the inside of the code block then pass that to the user-defined function, but then they get Html instead of Text
09:31:56 <joelteon> meh, I'll just thoroughly document it
09:32:28 <joelteon> or should I provide the Text version and the Html version to the function instead?
09:41:09 <dmwit> Peaker: Well, it does have such a mechanism.
09:41:17 <dmwit> There's just no access control at all. =)
09:42:23 <Peaker> dmwit, it would be considered a violation to upload a trivial build fix to someone's package, wouldn't it?
09:42:47 <Peaker> it would be nice if there was some sort of way to volunteer reviews of trivial fixes that they really are trivial fixes, and allow them
09:43:00 <Peaker> even if author sillily resists (as I've unfortunately encountered)
09:43:35 <dmwit> Yes, it's probably socially unacceptable to abuse Hackage's security model in this way.
09:44:50 <c_wraith> "security" model
09:46:24 <Peaker> not sure if sarcastic..  I really don't know if it would be considered unacceptable if I went ahead and did such an upload
09:46:46 <c_wraith> If the maintainer has rejected the patch, I'd have to say no.
09:46:59 <c_wraith> Even if their reason for rejecting it was no good
09:47:06 <c_wraith> You just don't want to set that precedent
09:47:52 <dmwit> Peaker: I am not being sarcastic at all.
09:48:45 <Peaker> well, hackage should probably allow it
09:49:01 <Peaker> that'd make everybody's horrible import styles be less of a terrible pandemic
09:50:04 <dmwit> ...Hackage allows it.
09:50:16 <dmwit> Hackage doesn't care.
09:50:21 <dmwit> There's no access control at all, like I said.
09:50:42 <c_wraith> hackage allows it mostly out of laziness, and the fact that it has some value when the maintainer of a package vanishes
09:50:45 <Peaker> dmwit, by "hackage", I mean the social norms around it
09:50:50 <dmwit> Okay.
09:53:36 <efie> how do I know which version of the haskell platform I have installed? I'm on Ubuntu and it tells me I installed "2012.1.0.0 haskell platform", however I cannot find 2012.1.0.0 at http://www.haskell.org/platform/prior.html ?
09:54:45 <geekosaur> ubuntu has shipped at least one "rogue" haskell platform
09:54:52 <KingofFerrets> For the sake of all the people who have been helping me in here, I would just like to say that I now have a pretty darn good understanding of the State monad. \o/
09:55:01 <geekosaur> (they upgraded the compiiler and patched the then current platform to work with it)
09:57:45 <merijn> KingofFerrets: Good news, after understanding the State monad, Reader/Writer and most others are pretty easy to get
09:59:06 <quchen> Eh, how do I get the GHC source tarballs? The "snapshot distribution" directory is empty :-| http://www.haskell.org/ghc/download
09:59:11 <NihilistDandy> Just understand Cont and you'll be all set~
09:59:54 <quchen> (In order to clone from Github I need autoconf and all that stuff, and my repos are outdated it seems)
10:01:35 <KingofFerrets> merijn: Sweet.
10:01:42 <monochrom> quchen: must you need the snapshot source? is 7.6.3 source not enough?
10:01:52 <quchen> monochrom: I need HEAD
10:02:04 <monochrom> alright, then I can't help
10:02:04 <quchen> (AMP patch ...)
10:02:09 <KingofFerrets> ...I should probably go learn the Random monad and then use that after this, since I wrote a couple functions that are already in the Random monad for my State monad randomness.
10:02:39 <NihilistDandy> quchen: Download as a ZIP?
10:03:04 <quchen> NihilistDandy: Cloning works fine, but after cloning I need to run the boot script which fails
10:03:08 <NihilistDandy> Ah
10:03:21 <monochrom> NihilistDandy: the problem is still need autoconf etc to configure and build in the source tree
10:03:22 <quchen> Alternative: get the required programs. Which is probably a pain.
10:03:26 <Taneb> Hayoo down?
10:03:39 <NihilistDandy> quchen: Why such a pain?
10:03:47 <NihilistDandy> Isn't autoconf pretty easy to install?
10:04:10 <quchen> Repo gives me a "not found".
10:04:26 <monochrom> very old linux you're on?
10:04:34 <quchen> Arguably, Ubuntu 11.04
10:04:46 <quchen> In Shuttleworth time that's ancient, so yes I guess.
10:05:31 <monochrom> they have probably stopped supporting 11.04 altogether
10:05:43 <quchen> Well, they dropped support at some point
10:05:48 <quchen> Then they dropped it some more
10:05:53 <monochrom> each ubuntu version has an announced die time
10:05:55 <quchen> And now it seems like they have *dropped* it.
10:06:14 <quchen> Yeah, I was young and stupid to install Ubuntu.
10:06:15 <monochrom> oh well, you will have to choose your poison :)
10:06:41 <monochrom> eh? I use ubuntu too. I just keep upgrading. yes every 6 months. no big deal to me.
10:08:18 <monochrom> between "I don't want change", "I am not paying money", "I want latest software", "the computer should read my mind", you have to give up some, you know, you can't have them all.
10:09:58 <quchen> monochrom: I chose "no Unity at all cost".
10:10:16 <merijn> quchen: Install OSX! :)
10:10:16 <quchen> Anyway, Ubuntu ranting is OT. Manual autoconf installation seems to have worked.
10:10:32 <merijn> Or Windows!
10:10:48 <quchen> I think suicide would be less painful here, but thanks for the suggestions
10:10:58 <merijn> quchen: You mentioned "at all cost"
10:11:17 <quchen> At all* cost
10:11:34 <quchen> * is left as an exercise to the reader.
10:14:57 <ashwinsa> How to parse a recursive XML schema using HXT.
10:16:25 <Sonarpulse> if you have (WIP) bindings with types but no data (functions, constants, etc)
10:16:30 <Sonarpulse> it should still compile right?
10:16:57 <merijn> Sonarpulse: No
10:17:14 <merijn> Well, maybe
10:17:22 <merijn> What do you mean by bindings?
10:17:58 <Sonarpulse> FFI
10:18:03 <Sonarpulse> https://github.com/Ericson2314/henet
10:18:21 <Sonarpulse> master uses a tool to generate them fairly automatically by johnw
10:18:32 <Sonarpulse> manual is just me rolling the hsc by hand
10:18:35 <merijn> That should probably compile, yeah
10:18:48 <Sonarpulse> well, neither are, and the errors are cryptic
10:19:01 <Sonarpulse> I have never used the FFI before, so I don't really know where to start
10:19:09 <merijn> c2hsc doesn't completely errorlessly compile, I think
10:19:31 <merijn> It only works immediately for very simple cases, I believe the goal was to have people manually fix up the generated code
10:19:41 <Sonarpulse> no it doesn't, but I got a LOT of errors, kinda implying (to me, at least) that I set something up wrong
10:19:48 <merijn> Anyway, I need to reboot quickly, so can't help right now
10:19:59 <Sonarpulse> ok, thanks anyways
10:20:59 <hpaste> AshwinSa pasted “XML Parsing” at http://hpaste.org/90242
10:22:10 <ashwinsa> I have gotten so far to read the individual attributes and values, but need a way to parse the entire xml into the data model commented in the code
10:29:09 <Ralith> Is Benjamin S. Scarlet here?
10:30:44 <troydm> Ralith: it might take some time for him to notice this if he rly is here
10:31:00 <troydm> but usually u should search ppl by nicknames
10:31:04 <Ralith> troydm: yes, well, it's a quiet time of day and I've got nothing else to go on :P
10:46:09 <stelleg> @djinn (a -> b) -> (a -> b)
10:46:09 <lambdabot> f a = a
10:46:52 <stelleg> @djinn (a -> b) -> a -> b
10:46:52 <lambdabot> f a = a
10:47:17 <merijn> stelleg: Those two types are identical
10:47:26 <DanBurton> @djinn (a -> (b,c)) -> a -> c
10:47:26 <lambdabot> f a b =
10:47:26 <lambdabot>     case a b of
10:47:26 <lambdabot>     (_, c) -> c
10:47:38 <stelleg> merijn: yeah I just realized that
10:47:44 <stelleg> a bit slow
10:49:17 * hackagebot not-gloss 0.5.0.4 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.5.0.4 (GregHorn)
10:50:17 <Peaker> bah, groom is having stack overflows, prettying my large data
10:51:38 <Peaker> and ipprint stack overflows too, bah
10:53:12 <Nisstyre-laptop> I just realized there's an electronic artist named System F
10:53:20 <joelteon> Is there any nub-ish operation for vectors?
10:53:44 <geekosaur> yes, I've been amuysed by that for a while
10:54:02 <joelteon> any operation that isn't fromList . nub . toList
10:54:25 <Peaker> pretty annoying.. I'll try to go back to the pretty printing route
10:58:04 <Peaker> the pretty printing also stack overflows, so maybe it's the pretty printing of a very large thingie that's stack overflowing
11:05:11 <Ralith> Nisstyre: haha
11:07:09 <monochrom> "pretty printing is pretty annoying"? hehe
11:07:32 <carter> Ralith i think i'm going to try patching the llvm-general setup.hs to use clang for the c++ instead of gcc
11:08:33 <Ralith> carter: it doesn't seem to reference gcc
11:08:59 <Ralith> carter: are you sure it's not ghc making that decision?
11:09:08 <carter> Ralith cabal defaults to gcc
11:09:27 <Ralith> or cabal, then
11:09:32 <Ralith> surely there's a command line option?
11:09:34 <carter> and doesn't pass the ghc-options when it calls ghc for c codes
11:09:37 <Ralith> or it checks CC?
11:10:02 <carter> Ralith i'll try the ghcoptions flags
11:20:31 <Sonarpulse> anybody else want to help me figure out why https://github.com/Ericson2314/henet/tree/manual isn't building?
11:20:53 <Sonarpulse> unless you are back, merijn
11:21:56 <carter> damnit, borked my llvm
11:22:03 <carter> need to create my own brew tap now
11:22:10 <carter> 'cause brew's now at llvm 3.3
11:22:12 <carter> its ok
11:42:00 <orzo> hmm, -D defines are not passed on to gcc when ghc invokes it to compile c files
11:42:05 <orzo> that seems wrong
11:42:11 <Sonarpulse> interesting!
11:42:23 <Sonarpulse> I am having my own problems with the FFI
11:42:42 <Sonarpulse> it uses them to preprocess at least?
11:43:38 <quchen> Why does GHC use Alex/Happy? Is there a good reason not to use a parser like Parsec for example?
11:43:53 <orzo> I dont understand your question.  when {-# LANGUAGE CPP #-} is at the top of the haskell file, you can use preprocessor directives ifdef and friends and the -D defines work as expected
11:45:43 <orzo> quchen: i'm no expert, but i think Alex/Happy make faster code than Parsec.  That's a good enough reason isn't it?
11:46:18 <xplat> Alex/Happy are also nicer mathematically than Parsec
11:46:20 <quchen> orzo: I'm not sure the parser is the bottleneck of compiling with GHC.
11:46:59 <stelleg> xplat: care to elaborate on that?
11:47:07 <orzo> yeah, ^
11:47:29 <bitonic> stelleg: Happy grammars have a clearer meaning than parsec programs
11:47:39 <bitonic> that is, LALR grammars
11:48:17 <c_wraith> parsec is LL(1)
11:48:20 <c_wraith> that's just as formal
11:48:23 <stelleg> bitonic: as oppsed to LL
11:48:31 <c_wraith> well, LL(1) with some extra extensions
11:48:34 <xplat> stelleg: CFGs are compositional, and even LR(1) and LALR(1) only have certain obstructions to composition in the case where local ambiguities are introduced; furthermore if one is encountered happy can report it
11:48:51 <c_wraith> try allows it to be ll(k) in certain circumstances
11:49:23 <Sonarpulse> without knowing much about grammers, I think hsc2hs could use a bit of an overhaul
11:49:27 <bitonic> c_wraith, stelleg: but with parsec you don’t really know what’s going on—happy tells you if what you have is actually ambiguous or not, etc
11:49:28 <xplat> and parsec is *not* LL(1) unless you put try around everything, and then it performs horribly (and if you do that it's also LL(*))
11:49:59 <Sonarpulse> I tried using this: https://github.com/jwiegley/c2hsc
11:50:13 <Sonarpulse> couldn't get it to work for me, but the idea is quite sound
11:50:35 <stelleg> xplat: I thought <|> is LL(1) with good performance, and try <|> gives you LL(*) with a performance hit
11:50:43 <bitonic> c_wraith, stelleg: for example with parsec you easily end with infinite loops if you’re not careful
11:50:44 <c_wraith> xplat: how is it not LL(1)? it looks one token ahead.
11:50:59 <Sonarpulse> I think seperately parsing the C code vs CPP + #include header is much more sound
11:51:06 <xplat> c_wraith: it doesn't look ahead the same way as LL(1) in the case of possibly-null alternatives
11:51:18 <stelleg> bitonic: yeah I suppose thats an inherent different between parser generators and parser combinators
11:51:27 <bitonic> stelleg: right.
11:51:52 <bitonic> but it’s a big difference, I find parser generators much more usable for complex grammars
11:52:51 <stelleg> bitonic: fair enough, I suppose I've used mostly LL(1) grammars, so parsec has worked well for me
11:53:00 <xplat> (also if you use parsec without a scanner then even if it were LL(1) it'd be the wrong kind of LL(1) for programming languages, and it's more awkward to use a scanner with parsec than with happy)
11:53:52 <bitonic> stelleg: the thing is that parser generators ‘understand’ the grammar much more—they internalise the fact that they accept LALR or whatever grammars and they work accordingly
11:54:18 <bitonic> so in that sense I find them nicer ‘mathematically’
11:54:18 * hackagebot tagged-transformer 0.3.1 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-transformer-0.3.1 (EdwardKmett)
11:54:39 <quchen> Anyway, I got it to run, and 7.7 is building now. :-)
11:54:51 * bitonic writes his lexers with parsec and parsers with happy :P
11:55:15 <bitonic> we badly need a better parser generator though... I wonder how hard would it be to simply give a better interface to the happy machinery
11:55:59 <edwardk> the main problem with the happy approach is it is a real pain in the ass to actually get it working well with things like layout, etc.
11:55:59 <quchen> Apart from mathematical considerations, is there any need?
11:56:16 <bitonic> quchen: any need for what?
11:56:20 <quchen> "Happy is prettier mathematically" doesn't seem very compelling from a practical point of view.
11:56:23 <edwardk> if you look at how GHC internally has to juggle it, it is somewhat terrifying ;)
11:56:27 <quchen> If it's *just* that.
11:56:44 <xplat> edwardk: apart from trifecta is there anything that isn't a pain in the ass to get working well with layout?
11:56:46 <bitonic> quchen: it’s not, as I said to handle big grammars happy is much more useful
11:57:02 <edwardk> quchen: i _do_ like the fact that LALR style parsers do tend to allow you to give multiple parse errors as they can resume from error tokens unambiguously in ways that LL(*) style parsers just can't
11:57:06 <quchen> What do you mean with "big" here?
11:57:18 <bitonic> edwardk, xplat: you might be interested in <http://michaeldadams.org/papers/layout_parsing/>
11:57:42 <bitonic> quchen: well big is fuzzy, but in general I find it very nice to have a DSL to express my grammar that matches the implementation
11:57:45 <edwardk> bitonic: sadly i already bothered to come up with my own formalism for working with it ;)
11:57:53 <bitonic> I find myself thinking much more when working with Parsec
11:58:05 <bitonic> edwardk: which is?
11:58:10 <quchen> edwardk: So you can make parsers that can just keep parsing on error? That sounds nice indeed.
11:58:27 <edwardk> bitonic: i used to have a bunch of articles up on comonad.com going on about monoidal parsing
11:58:37 <bitonic> edwardk: OK, I’ll dig around
11:58:42 <bitonic> is it available as a library?
11:58:49 <edwardk> bitonic: i need to resurrect the server it was on sometime soon
11:58:55 <quchen> And now I need to look up what LALR is. :-)
11:59:01 <edwardk> for various petty reasons, no. ;)
11:59:09 <bitonic> edwardk: legal petty?
11:59:15 <edwardk> no, truly petty
11:59:18 <bitonic> ah, OK
11:59:37 <edwardk> i had been working on it for 8-9 months as 'parsimony' and they a couple of people grabbed the name out from under me
11:59:49 <bitonic> edwardk: btw, I think I found a nice way to handle substitutions with ‘heterogeneous’ datatypes
11:59:49 <edwardk> for some parsec 3 clone that nobody has done anything with
11:59:58 <bitonic> lol OK
12:00:03 <edwardk> so i just stopped working on it and moved onto the next problem in my queue ;)
12:00:16 <edwardk> i said it was a petty reason =)
12:00:22 <hpaste> bitonic pasted “substitutions, edwardk” at http://hpaste.org/90246
12:00:23 <orzo> i have a project that does xmpp streams on sockets, it uses parsec-style haxml, but i'm not very pleased with my code at the moment.  Anbody care to share their thoughts on what parsing solution they'd reach for in this case?
12:00:32 <bitonic> edwardk: something like the link above
12:00:42 <bitonic> so you can decide what’s the thing to substitute inside
12:01:04 <bitonic> you can have very nice telescopes
12:01:05 <xplat> edwardk: one of the advantages/dangers of having a wide and deep problem queue ...
12:01:34 <edwardk> xplat: works out pretty well. if i put something away long enough and come back to it there is new research for me to read and i can get excited about it again
12:02:18 <edwardk> bitonic: neat. i'll have to dig in a bit deeper when i get more time
12:02:50 <edwardk> so far it looks like the standard Maybe-based de Bruijn for the Term example at the bottom
12:03:09 <merijn> I should just upload the version 0.0 of any library I come up with, even if the project is empty, just to claim the name :p
12:03:14 <bitonic> edwardk: yes, but the difference is that the ‘Subst’ instance lets you for example write
12:03:30 <bitonic> ‘Fwd Tm Tm v’
12:03:36 <bitonic> which is a telescope where each binding binds a term
12:03:42 <edwardk> bitonic: sure
12:03:49 <xplat> merijn: then if someone else wants it you can charge them $1000
12:03:53 <bitonic> or ‘Fwd Tm Proxy1 v’, which is a telescope with nothing at the end—a context
12:03:58 <bitonic> or whatever
12:04:03 <merijn> xplat: Or they clobber my Hackage upload :p
12:04:04 <bitonic> which is what I wanted
12:04:08 <edwardk> cute
12:04:12 <bitonic> you can even have chained telescopes
12:04:21 <bitonic> ‘Fwd Tm (Fwd Tm Tm) v’
12:04:30 <merijn> Telescope? Two lenses in a pipe?
12:04:33 <xplat> merijn: yeah, i guess you can only lean on propriety for maybe $30
12:04:40 <merijn> (Ohoho! I made a haskell joke!)
12:05:00 <bitonic> edwardk: and I also have ‘backward’ telescopes, to traverse bindings (the Bwd)
12:05:14 <joelteon> microscopes
12:05:15 <bitonic> it can probably be adapted to how bound works
12:05:28 <edwardk> you'll should show dolio when he gets back to his desk in a few minutes ;)
12:05:43 <edwardk> er you should
12:05:48 <xplat> bitonic: what problem is this solving?
12:06:16 <xplat> bitonic: (just out of interest in term representations)
12:06:17 <bitonic> xplat: the fact that expressing substitution by having your term type be an instance of Monad creates problems
12:06:34 <bitonic> the problem being that you can only substitute things that are the same type as the term itself
12:06:45 <bitonic> and that you have to have ‘return’
12:06:47 <quchen> Haha, make -j9 failed.
12:06:55 <quchen> Time to take apart the spaghetti error message.
12:07:17 <bitonic> xplat: instead I want to be able to specify what thing variable represents in each structure
12:08:02 <bitonic> that’s basically a generalisation of ‘de Bruijn notation as a nested datatype’
12:08:33 <xplat> bitonic: ah, so this is an attempt at multi-sorted substitution.  sort of a multicategory enriched in endofunctors?
12:08:42 <bitonic> xplat: I have no clue :P.
12:08:56 <bitonic> if someone can give categorical meaning to that I’ll be happy
12:10:12 <xplat> i barely have a clue either :-/
12:11:26 <bitonic> the thing is that I just cannot go back to simple de Bruijn or—God forbid—names
12:12:15 <bitonic> my goal as a testbed for *the* term representation library is implementing pattern unification, because you have to do a lot of context juggling there
12:12:18 <merijn> On a scale of 1 to murdering a puppy, how bad should I feel for contemplating moderately heavy use of unsafeCoerce?
12:12:29 <bitonic> maybe I should just do all this in Agda
12:13:02 <jeff_s1> merijin: Feel bad enough to make you do it in C.
12:13:12 <Sculptor> merijn, right about 'tripping a blind guy'
12:13:40 <Saizan> i wonder if these nested Maybe types are really better than a straight Fin
12:13:51 <Sculptor> maybe
12:14:20 <edwardk> merijn: If abusing unsafeCoerce is comparable to killing a puppy then I'm pretty sure lens makes me Cruella de Vil
12:14:29 <xplat> merijn: what do you mean by 'moderately heavy?'
12:14:45 <bitonic> Saizan: probably not, but we can’t have a decent Fin in Haskell
12:14:53 <quchen> edwardk: How many unsafeCoerces are there in 3.10?
12:14:55 <bitonic> the Fin becomes better when you can match on the index
12:15:01 <Saizan> bitonic: using a MPTC instead of type families you could even allow substituting different stuff in the same thing
12:15:05 <edwardk> ~124
12:15:27 <merijn> xplat: Well, one or two usecases, but they will be used *a lot*
12:15:32 <bitonic> Saizan: I’m not sure what you mean, but with fundeps that was much less nice
12:15:40 <Saizan> bitonic: i mean without fundeps
12:15:53 <chrisdone> edvardkk meet edwardk, your names are similar and that amuses my small mind
12:15:58 <xplat> merijn: i think it depends at least as much on the usecases as the number of uses
12:16:20 <bitonic> Saizan: so some sort of type-directed substitution :P?
12:16:28 <edwardk> edvardkk: uhoh. i thought having Eduard_Munteanu around was bad ;)
12:16:44 <Saizan> the class would look like class Subst f m where (//=) :: f a -> (a -> m a) -> f a -- plus constraints
12:17:15 <Saizan> but i can't think of compelling examples otoh
12:17:22 <bitonic> Saizan: I don’t see how that allows for substituting different stuff in the same thing—isn’t it always going to be ‘m’?
12:17:28 <bitonic> ah yes, you mean separate instances
12:17:30 <bitonic> for the same ‘f’
12:17:31 <edwardk> Saizan: the one i use is class Monad m => BoundBy tm m | tm -> m where boundBy :: (a -> m b) -> tm a -> tm b
12:17:33 <Saizan> yeah
12:17:48 <edwardk> that is stolen out of the compiler here
12:17:54 <xplat> Saizan: help me out here, (//=)'s signature looks like something i've seen before ... (and i mean more specifically than bind)
12:17:59 <dolio> Also, fin doesn't cover all use cases of bound, if that's what you're talking about.
12:18:17 <edwardk> instance Monad m => BoundBy (Scope b m) m where boundBy = flip (>>>=)
12:18:23 <Saizan> bitonic: you could for example have instance Subst (Fwd m g) m; and instance (Fwd m g) g
12:18:23 <dolio> You can't just index your type by a natural number. You need to index by the types you're using as indices at each binder. Which may vary.
12:18:55 <merijn> xplat: Index that tells me the type of the value associated the key I'm looking up, but the container doesn't know said type, thus forcing me to unsafeCoerce after lookup
12:18:57 <bitonic> dolio: the file I pasted above does not do that—but could be extended to.  besides, you can have a Fin + a function telling you what each scopes binds, I think
12:19:32 <Saizan> dolio: that was just a tangent of mine
12:19:48 <bitonic> Saizan: yeah but I didn’t want to get into UndecidableInstances
12:19:53 <dolio> And I'm skeptical that indexing by a list is going to be a lot nicer than the nested type.
12:20:16 <bitonic> dolio: the big difference is that you can match on the index, while the nested type is polymorphic
12:20:32 <dolio> That's a bad thing.
12:20:46 <bitonic> dolio: I think it’d be useful to traverse contexts
12:21:12 <xplat> merijn: is there anything preventing the caller from giving you the wrong type for the value?
12:21:15 <dolio> Bound also gives you all kinds of nice properties due to parametricity.
12:21:48 <bitonic> dolio: my hunch is that the power that you gain with Fin would be worth the occasions that you gain to screw up
12:21:51 <dolio> Well, maybe not 'all kinds'.
12:22:02 <merijn> xplat: It should be impossible (you know, without unsafeCoerce or whatever) to produce unmatching keys
12:22:06 <bitonic> because I think it’d take some effort to screw up
12:22:25 <bitonic> but sure with nested datatypes you *can’t* screw up :P
12:22:33 <dolio> Well, I'm working on a compiler using bound and I've not wanted to do what you're talking about yet, so I can't really agree.
12:22:34 <Saizan> xplat: it's not matching anything in particular for me, maybe the monoidal stuff from soeq?
12:23:12 <bitonic> dolio: well for example building telescopes/contexts with bound is quite a hassle
12:23:29 <xplat> merijn: that doesn't sound so bad
12:23:35 <bitonic> or factoring out certain parts of the term representation
12:24:38 <merijn> xplat: The alternative is making the values existential Typeable instances and doing cast to ensure the keys match, but seems to me that will only introduce overhead for almost no benefit (i.e. I'd just crash upon cast failing)
12:25:31 <xplat> merijn: maybe you want to have that with a compile-time switch if you can abstract out the difference
12:26:07 <xplat> since crashing from Typeable cast failure is a safer failure mode than misinterpreting bits
12:26:37 <fruitFly> hey, I have an idea for a fault tolerant news distributing application, i think after a time it would be uncompetitive if it wasn't free and am just wondering how free services that don't solicit any private information might receive profits? is it only from venture capital to fund the developers?
12:27:25 <xplat> fruitFly: advertising, usually.
12:27:32 <fruitFly> xplat: ok
12:27:42 <xplat> fruitFly: (note: i hate this fact)
12:29:14 <roconnor> @botsnack
12:29:14 <lambdabot> :)
12:29:21 <BigTom> quit
12:29:50 <geekosaur> also see http://synecdochic.dreamwidth.org/234496.html
12:32:45 <monochrom> I have just accomplished: C code contains main and also exports a "tryme", main dlopens a *.so written in Haskell, which uses GHC API to load (interpret) a *.hs file, which foreign-imports tryme, and it works
12:34:07 <merijn> monochrom: Sweet
12:34:46 <c_wraith> monochrom: that's kinda scary.
12:34:54 <monochrom> hehehe
12:35:10 <monochrom> it is important and useful
12:35:28 <c_wraith> I'm not going to ask why.  And if you explain, I'll plug my ears and yell "lalalala" a lot.  And also, look away from the screen, since that might actually help. :)
12:36:20 <aristid> c_wraith: you could try emitting light as well
12:36:31 <c_wraith> I'm not very good at that.
12:36:56 <aristid> shame
12:36:57 <monochrom> the canonical application is e.g. write a plugin for xchat, the plugin has to be *.so, I want to write one that uses GHC API to interpret Haskell code, and I want that interpreted Haskell code to be able to call xchat exported hooks like every xchat plugin can
12:37:17 <xplat> c_wraith: it takes practice.  and a bit of elective gene therapy.
12:38:17 <merijn> monochrom: I was actually fairly surprised by how easy it was to have a C main that calls out to haskell (which calls back to C)
12:39:24 <merijn> I didn't go the extra mile of going via interpreted haskell and dlopen, but still :p
12:39:35 <xplat> i have half-done porting projects that start out by just having the C main renamed and called from an otherwise-dummy Haskell main
12:40:08 <merijn> And the new cabal supports Main-Is with a C file!
12:40:17 <xplat> then halfway through i always try to rewrite lens :)
12:40:18 <merijn> <3 dcoutts
12:40:20 <monochrom> onoes
12:40:20 <c_wraith> Oh really? That's a cool feature.
12:40:41 <merijn> c_wraith: Yeah, I had to upgrade because cabal was complaining :p
12:41:00 <edwardk> xplat: hah
12:41:08 <monochrom> nice
12:42:15 <merijn> Cabal 1.17 (which fortunately works just fine with platform everything, so upgrading is no hassle)
12:42:24 <hvr> Luke: btw, how can I differentiate between two snippets with conflicting keys *without* ido-mode?
12:42:37 <xplat> the sad thing is that the existing lens would work fine when i'm finished porting, it's just the intermediate stages that need weird stuff
12:42:57 <Luke> hvr: i think YASnippets defaults to a prompt
12:43:04 <c_wraith> xplat: does this mean you really want a foreign-lens intermediate compatibility package?
12:43:04 <hvr> Luke: for me it doesn't
12:43:06 <Luke> hvr: it has 4 prompt methods so I'm not sure what it will use
12:43:14 <Luke> hvr: hmm something might be wrong with your YASnippet install
12:43:20 <hvr> Luke: that's why I used impq vs imp in the first place
12:43:32 <xplat> c_wraith: mmmmaybe
12:43:49 <Luke> hvr: hmm something's wrong for you. check this out: http://capitaomorte.github.io/yasnippet/snippet-menu.html#prompting-method
12:44:00 <Luke> hvr: I'm running a clean version of yas from git head
12:44:35 <Luke> hvr: try "H-v yas-prompt-functions"
12:44:44 <xplat> c_wraith: when i have only haskell code accessing stuff i can use plain lens with a state record, but when i need haskell and C to access the same state it needs to live in a static Ptr
12:45:17 <c_wraith> yeah, I figured that was the case you run into
12:45:43 <c_wraith> I have no clue how to design the library you'd want to handle that, though. It seems like a big problem, in terms of number of cases
12:47:35 <osa1_> after compiling a Haskell executable, only dependencies for that executable are those listed in `ldd HaskellExecutable` output, right?
12:47:42 <tlunter> is it possible to get a value out of the IO monad besides using do notation or bind?
12:47:54 <tlunter> since you can't pattern match against it
12:48:06 <quchen> You have to use >>=.
12:48:13 <quchen> Everything else is black magic.
12:48:17 <josephle> tlunter: what do you mean you can't pattern match against it?
12:48:21 <geekosaur> osa1_: barring use of ghc-api or plugins to dynamically load something
12:48:45 <hvr> Luke: I've got http://melpa.milkbox.net/packages/yasnippet-20130505.2115.tar installed btw
12:48:46 <c_wraith> josephle: well, you *shouldn't* pattern-match against it.  It has... interesting... results. :)
12:48:47 <merijn> josephle: He means you can't match on the IO constructor to get the value out of IO
12:49:00 <osa1_> geekosaur: oh do you mean functions like `dload`?
12:49:07 <merijn> tlunter: Why do you want to get a value out of IO?
12:49:08 <josephle> merijn: ah, I misread him
12:49:11 <Luke> hvr: seems new enough
12:49:30 <Luke> hvr: do you have any other yasnippet installed via apt or anything?
12:49:36 <tlunter> josephle: merijn: I'm trying make things easier to use than the basically just FFI haskell-x11 library
12:49:39 <geekosaur> tlunter, the whole idea of IO is you can't get something "out" of it
12:49:45 <Luke> hvr: ubuntu has a yasnippet package you could have installed which may be conflicting?
12:49:46 <geekosaur> @quote /bin/ls
12:49:46 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
12:50:04 <geekosaur> there isn't a value there. there is a recipe to obtain a value at runtime
12:50:05 <c_wraith> Admittedly, you can find code that *does* pattern-match against the IO constructor.  bytestring has a function that does, for instance.  But it comes with all kinds of warnings about how it can break things.
12:50:13 <hvr> Luke: Emacs does load the correction version
12:50:13 <osa1_> looks like my executable links with `libdl`, I think this contains dload
12:50:23 <josephle> c_wraith: that sounds scary
12:50:30 <Luke> hvr: what was the variable yas-prompt-functions set to btw?
12:50:41 <Luke> hvr: i set mine to (yas-ido-prompt yas-dropdown-prompt)
12:50:41 <monochrom> tlunter: there is no getting out, it has a reason. use bind. think of it as callback. getLine >>= your_callback
12:50:52 <xplat> note to self: wear brown pants next time you read bytestring source
12:51:03 <merijn> Or fmap, or any one of the other ways to do it
12:51:13 <hvr> Luke: I've got the same setting right now, but I don't see result from that
12:51:19 <Luke> weird
12:51:36 <geekosaur> tlunter, *if* you are specifically trying to use a pure function via the FFI, you may be interested in unsafeLocalState. note that using it for anything else *will* cause bizarre behavior
12:51:37 <Luke> just to be clear, what happens when you run the "fn" or "imp" expansions?
12:51:39 <hvr> Luke: everything else yas-related is at default settings
12:52:23 <Luke> hvr: i wonder if it's a problem with ido-mode. does that work for opening files and buffers normally?
12:52:33 <hvr> yeah, I use ido-mode for everything else
12:52:51 <tlunter> monochrom: i guess that makes sense. thanks.
12:53:01 <tlunter> geekosaur: eh, i'd rather not doing anything weird and stick to classic bind
12:53:30 <hvr> Luke: lemme investigate a bit; when should I see ido-mode in action w.r.t. to yasnippet?
12:53:47 <merijn> tlunter: >>= is for function that are "a -> IO b" and you have fmap for applying "a -> b" to "IO a"
12:54:23 <Luke> hvr: when you try to expand a key that has multiple expansions (like fn and imp). I'm also curios what the lang expansion will do without ido-mode.
12:58:04 <hvr> Luke: ok, now I see ido-mode in the minibuffer
12:58:26 <hvr> btw, where does 'nil-blank-string' come from?
13:01:09 <hvr> oh, it's defined in em-unix.el
13:09:02 <hvr> Luke: now it works; is there a way to cause a certain choice to be default? (for me the qualified import is default, but I'd like the simple import to be default)
13:20:47 <ksf> http://hpaste.org/90249
13:20:55 <ksf> someone help me write (.) for ReprCategory?
13:21:16 <ksf> ...for TLambda/TypedLambda/TEval, that is.
13:22:47 <Lethalman_> I've put flags: -fPIC into cabal config but it doesn't seem to be passed to ghc
13:23:03 <ksf> Lethalman_, let me guess, hardened gcc?
13:23:16 <Lethalman_> ksf, no, x64 needing -fPIC for shared libraries
13:23:25 <ksf> yes exactly.
13:23:33 <ksf> that error occurs with hardened gcc.
13:23:39 <ksf> add -optl-nopie
13:23:53 <Lethalman_> ksf, to cabal flags?
13:24:04 <ksf> try the ghc command line.
13:24:10 <ksf> if that works, add it to the wrapper.
13:24:20 <ksf> ghc links statically by default
13:24:33 <Lethalman_> ksf, I?ve enabled dynamic in cabal
13:24:38 <ksf> oh.
13:24:40 <Lethalman_> ksf, and, what wrapper you're talking about
13:24:42 <ksf> there be dragons
13:24:50 <ksf> Lethalman_, `which ghc`
13:24:56 <ksf> it's a shell script calling the actual ghc
13:25:09 <Lethalman_> ksf, I don't change that
13:25:12 <Lethalman_> I want to change the cabal config
13:25:26 <ksf> nevermind, my guess was wrong anyway.
13:25:37 <ksf> (though you're free to try passing it as an option)
13:25:50 <Lethalman_> I'm talking about .cabal/config
13:26:03 <ksf> ghc *should* compile PIC automatically
13:30:07 <Lethalman_> ksf, -optl-nopie not recognized
13:30:12 <Lethalman_> and -fPIC does nothing apparently
13:30:56 <ksf> do you pass both -shared and -dynamic? I remember having to play around with combinations last time I compiled dynamically
13:31:19 <Lethalman_> ksf, I don't pass anything, it's cabal
13:31:35 <Lethalman_> /usr/bin/ld: dist/build/Mueval/Parallel.dyn_o: relocation R_X86_64_PC32 against undefined symbol `base_GHCziIOziException_ThreadKilled_closure' can not be used when making a shared object; recompile with -fPIC
13:31:45 <Lethalman_> but probably the problem is something in ghc not being linked with fPIC
13:31:46 <Lethalman_> :-(
13:34:09 <ksf> Lethalman_, well, you need to install base dynamically.
13:34:24 <ksf> your distro could be stripping those libs to reduce ghc's size.
13:34:27 <Lethalman_> ksf, I've installed ghc-dynamic
13:34:55 <Lethalman_> maybe I have to reinstall with cabal
13:36:02 <ksf> Lethalman_, do you have *.dyn_hi and libHSbase*.so in your base library path?
13:36:12 <ksf> (you can figure that one out with ghc-pkg describe base)
13:36:17 <ksf> (field library-dirs)
13:36:54 <ksf> does building a simple dynamic hello world work?
13:37:19 <Lethalman_> ksf, I have
13:37:39 <Lethalman_> ksf, yes
13:37:53 <Lethalman_> ksf, but -dynamic -shared doesn't work
13:38:02 <Lethalman_> but -dynamic -shared -fPIC does work
13:38:19 <Sonarpulse> monochrom: very impressive!
13:38:31 <Lethalman_> problem is, I put -fPIC into the ghc wrapper but it still gives the error, uhm
13:38:55 <Lethalman_> anyway, just disabled shared for now :-(
13:38:56 <Lethalman_> thanks ksf
13:39:04 * Lethalman_ now trying to grasp http://www.haskell.org/haskellwiki/Free_structure
13:39:04 <ksf> if nothing else, then you should complain about that on your distro's or ghc's bug tracker, the -fPIC shouldn't be necessary.
13:39:20 <Sonarpulse> merijn: do you think you could help my with my FFI problems now?
13:45:08 * ksf needs a kind system.
13:45:35 <merijn> Sonarpulse: Maybe? Depends on the problem? :p
13:49:43 <Sonarpulse> well i don't really know what the underlying problem is
13:50:23 <Sonarpulse> merijn: https://github.com/Ericson2314/henet/tree/manual
13:53:25 <merijn> Sonarpulse: What kind of error are you getting?
13:53:51 <merijn> Sonarpulse: Also, what's the use of this file? https://github.com/Ericson2314/henet/blob/manual/src/Network/ENet/Bindings.hsc
13:54:10 <merijn> It doesn't expose any Haskell functions/data
13:54:39 <ksf>     The function `fmap . (.)' is applied to two arguments, but its type `(a1 -> b) -> TLambda (TEval a) s (s -> a1) -> TLambda (TEval a) s (s -> b)' has only two
13:54:49 <ksf> no wonder I get dizzy looking at that type error, even ghc does.
13:55:30 <Sonarpulse> sorry for delayed responce
13:56:01 <Sonarpulse> I get path/to/henet/Bindings.hsc:8: undefined reference to `hsc_import'
13:56:32 <merijn> Is that of the manual one or the master branch?
13:56:39 <ksf> if you can, avoid hsc2hs
13:56:47 <ksf> c2hs is superior.
13:56:49 <Sonarpulse> manual
13:57:03 <merijn> Better yet
13:57:05 <Sonarpulse> master is with johnw's tools, tonnes of preprocessing erors
13:57:08 <merijn> Use c2hsc :p
13:57:20 <merijn> Sonarpulse: Well, what's Bindings.hsc supposed to do?
13:57:27 <Sonarpulse> just get it to compile
13:57:31 <Sonarpulse> as that is only exported one
13:57:53 <merijn> Sonarpulse: But it doesn't do anything in the manual branch...
13:57:54 <Sonarpulse> I figure even though I haven't actually added any function yet
13:58:01 <Sonarpulse> no it doesn't
13:58:03 <merijn> It's empty except for C code...
13:58:12 <Sonarpulse> but master ONLY has bindings.hsc
13:58:14 <merijn> Well, C headers
13:58:14 <Sonarpulse> yes
13:58:21 <Sonarpulse> but should that cause error?
13:58:24 <Sonarpulse> or just worthless file?
13:58:27 <merijn> I have no clue, tbh
13:58:40 <Sonarpulse> I figure I should fix build system errors, THEN added actual stuff
13:58:58 <Sonarpulse> well there actually exists c2hsc bindings of this library, but they aren't really bindings
13:59:04 <Sonarpulse> an C++ interface is written in C
13:59:20 <Sonarpulse> * interface written in C++, and THAT has bindings
13:59:23 <merijn> Sonarpulse: It's been a while since I used this
13:59:47 <Sonarpulse> no worrie
13:59:48 <merijn> Sonarpulse: I have a repo that generates hsc from a header file and then uses that, maybe take a look at that
13:59:50 <Sonarpulse> *worries
13:59:57 <Sonarpulse> oh cool
14:00:06 <Sonarpulse> maybe I will have better luck than johnw's tool
14:00:36 <merijn> Sonarpulse: I meant that I use johnw's c2hsc in my repo, maybe you adapt it for your stuff https://github.com/merijn/snet2.0
14:01:07 <merijn> Sonarpulse: I generate a hsc file from SNet/Interface/CHandle.h, then compile that to haskell
14:01:44 <Sonarpulse> with bindings-dsl?
14:02:03 <merijn> Sonarpulse: Oh!
14:02:27 <Sonarpulse> ah
14:02:33 <Sonarpulse> yeah the old bindigns are not c2hsc
14:02:36 <Sonarpulse> but c->hs
14:02:40 <Sonarpulse> which is from like 08
14:02:44 <merijn> You don't have bindings-dsl in your cabal!
14:02:46 <Sonarpulse> and seems abandoned
14:02:52 <Sonarpulse> in manual I don't
14:02:54 <Sonarpulse> in master i do
14:02:57 <Sonarpulse> AFIAK
14:03:01 <merijn> Oh
14:03:04 <merijn> hmm
14:03:10 <Sonarpulse> wanna try master?
14:03:30 <Sonarpulse> or man
14:03:32 <Sonarpulse> *many
14:03:35 <Sonarpulse> which is c2hsc
14:03:47 <Sonarpulse> but imports on all the headers besides system specific
14:04:23 <Sonarpulse> a problem with ENet is the headers make almost no distinction between internal and external interfaces
14:04:49 <Sonarpulse> so not totally sure what hsc files should corrospound to what headers
14:04:59 <merijn> I have no idea why your stuff would complain about a missing hsc_import definition, that seems odd
14:05:46 <Sonarpulse> yeah, very weird
14:06:00 <Sonarpulse> so with your library, you run c2hsc compile time? no tweaking nessisary?
14:06:10 <Sonarpulse> i didn't see any *.hsc in the repo
14:06:38 <Lethalman_> :t Pure 2
14:06:39 <lambdabot> Not in scope: data constructor `Pure'
14:06:44 <Lethalman_> no Free monad
14:07:01 <S11001001> Lethalman_: or maybe just the church one :)
14:07:10 <Lethalman_> S11001001, ?
14:07:15 <merijn> Sonarpulse: Yeah, I only have a really simple header, so I just run c2hsc and use that without tweaking
14:07:29 <Sonarpulse> I might copy your cabal then
14:07:39 <S11001001> Lethalman_: http://hackage.haskell.org/packages/archive/free/latest/doc/html/Control-Monad-Free-Church.html
14:07:50 <Sonarpulse> confusion of internal and external aside, there is nothing weird in enet like varargs that would mess it up
14:08:21 <Lethalman_> S11001001, how can I use that in lambdabot?
14:08:34 <S11001001> maybe
14:08:34 <Lethalman_> :t runF
14:08:35 <lambdabot> Not in scope: `runF'
14:08:40 <Lethalman_> mh apparently not
14:08:40 <Sonarpulse> do you know exactly when c2hsc chooses to make "opaque types" that you can only pass around in haskell
14:08:46 <S11001001> @ty Control.Monad.Free.Church.F
14:08:47 <lambdabot> Couldn't find qualified module.
14:08:51 <S11001001> ah well
14:09:01 <Sonarpulse> it looked like types included within the header you point it to works that way
14:09:20 <Lethalman_> it has no safeness/trusted flags :-(
14:10:36 <augur> what are the good haskell GUI libraries (if any) and are there any good tutorials for doing stuff with them?
14:11:01 <merijn> Sonarpulse: I don;t know what opaque types are, tbh
14:11:07 <merijn> augur: Ask me again in 6 months
14:11:24 <Sonarpulse> well like C structs/unions where you don't know there contents
14:11:30 <Sonarpulse> abstract data types basically
14:11:51 <merijn> augur: I've decided they all suck, so I'm trying to design one that doesn't suck. Which is a wee bit tricky :p
14:11:52 <Sonarpulse> but for some reason in the wikis on the FFI they are call opque types instead
14:12:34 <augur> merijn: lol
14:12:34 <augur> ok
14:12:35 <Sonarpulse> yeah, haskell needs the One GUI Library to Rule Them All!
14:13:02 <augur> merijn: also be sure to write a proper tutorial on doing IO that doesnt have laziness problems. ive heard there are issues with lazy io but i dont know of a good writeup
14:15:00 <merijn> augur: The problem is that there's no way to force garbage collection, as a result lazy IO can leak file descriptors (they don't get released until they're GCed) and memory (that 100 mb file you read into memory wasn't GCed yet)
14:15:51 <augur> merijn: ive also found some interesting problems with sequencing of reads and writes from the terminal
14:15:53 <merijn> augur: Also, if the fd gets closed before you're done reading (somehow) the pretty String/Text/ByteString might suddenly throw exceptions when you force them a bit further
14:16:12 <merijn> augur: oh? That sounds less likely to be due to lazy IO
14:16:26 <merijn> Probably more related to the terminal model
14:16:34 <augur> maybe
14:17:46 <merijn> But, good news!
14:17:49 <Sonarpulse> conduits?
14:17:55 <merijn> I intend to have a terminal version GUI too!
14:19:29 <merijn> Yeah, conduits, io-streams and pipes try to solve these lazy IO issues
14:20:59 <applikativ> lazy io is the best kind; no 100 MB files, and never 100 million files
14:25:37 <Sonarpulse> merijn: hmm I like your approach. I made an issue in the github repo of ENet itself to refactor the enet headers
14:26:06 <Sonarpulse> if that can happen, it would probably be very possible to run c2hsc compile time
14:27:14 <Sonarpulse> ah! i temporary changed my caball file to point to a different hsc with actual content, and my errors are much more readable now
14:32:06 <Tene> Is there any haskell equivalent of perldoc to reference module documentation in the terminal, besides a terminal browser?
14:32:36 <monochrom> no
14:32:43 <Tene> Damn.
14:32:46 <Tene> Thanks.
14:33:17 <merijn> I thought command line hoogle could print the documentation of a function?
14:33:36 <Tene> Not that I've been able to tell from looking at its documentation
14:35:51 <levi> You could use pandoc to convert the html to plain text.
14:36:17 <levi> pandoc -f html -t plain <filename.html>
14:37:15 <byorgey> Tene: someone made a program/script to do that, I think.  I forget who.  Maybe chrisdone ?
14:49:20 <applikativ> pandoc -r html -w plain <haddock html> leaves a little to be desired, hm
14:53:03 <merijn> Man...I wish there was a way to make "Foo (Just v)" a Functor :(
14:54:23 * hackagebot parsers 0.8.2 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.8.2 (EdwardKmett)
14:57:04 <tabemann> is there any way to more fine-grainedly control importing of names in GHCi than simply :m +Foo, which doesn't seem nearly fine-grained enough
14:57:44 <edwardk> tabemann: you can use 'import Foo qualified ....
14:57:45 <tabemann> e.g. I want to just import a selected name in a given module
14:57:58 <edwardk> er import qualified Foo as Bar  and all the usual noise
14:58:02 <edwardk> at least in recent GHCs
14:59:04 <tabemann> I try doing import Foo (bar), but it seems to import everything in a given module
14:59:09 <Saizan> Tene: hoogle --info
14:59:28 <edwardk> hrmm
14:59:40 <tabemann> oh, import qualified Foo as Bar does work
14:59:45 <Saizan> not sure if it handles modules or just functions, though
14:59:49 <tabemann> but not import Foo (bar)
15:00:25 <tabemann> wait, no
15:00:37 <tabemann> import qualified Foo as Bar still imports everything in Foo
15:00:45 <tabemann> e.g. I did:
15:00:54 <geekosaur> are you doing this in ghci?
15:01:02 <tabemann> import qualified Control.Applicative as A
15:01:15 <tabemann> and it recognizes the name "pure" without me saying "A.pure"
15:01:20 <tabemann> geekosaur: yeah
15:01:46 <geekosaur> ghci doens;t worke xactly the same as ghc. this might be worth a bug report though
15:02:08 <Saizan> tabemann: ghc version? it works as expected on 7.4.1
15:02:19 <tabemann> I'm using 7.4.1 myself
15:02:42 <Saizan> maybe you have pure imported from somewhere else then?
15:03:01 <geekosaur> you can use :i to see where it imported the bare name from
15:03:19 <tabemann> *RBMap> import qualified Control.Applicative as A
15:03:20 <tabemann> *RBMap A> pure "foo" :: [String]
15:03:20 <tabemann> ["foo"]
15:03:52 <edwardk> tabemann: does RBMap import Control.Applicative as well?
15:04:00 <tabemann> *RBMap A> :i pure
15:04:00 <tabemann> class Functor f => A.Applicative f where
15:04:01 <tabemann>   pure :: a -> f a
15:04:01 <tabemann>   ...
15:04:01 <tabemann>         -- Defined in `Control.Applicative'
15:04:27 <tabemann> edwardk: just looked back... yeah, it does, which might be it
15:04:34 <edwardk> thats where you're getting it from
15:04:50 <edwardk> you get the modules imported for the current context too
15:05:17 <edwardk> >>> import qualified Control.Applicative as A
15:05:17 <edwardk> >>> :t pure   ====> Not in scope: `pure'
15:05:46 <tabemann> okay, I tried again with using import qualified Data.List as L
15:06:00 <tabemann> and then foldl' and it can't find foldl' unless I do L.foldl'
15:10:41 <Tene> Saizan: That mostly does what I want, yes.  Any idea why that's not listed in the output of hoogle --help or how I could have found that myself?
15:13:01 <Saizan> Tene: no idea, and i don't remember how i've found it, maybe in the manual
15:26:25 <Ralith> Can anyone give advice on how to test Data.Binary instances in ghci?
15:28:18 <xico> is there a function and typeclass which return [] for lists, 0 for Int, and (hopefully) "" for Text?
15:28:38 <joelteon> mempty does 2 of those 3
15:28:43 <joelteon> :t mempty
15:28:44 <lambdabot> Monoid a => a
15:28:57 <joelteon> the problem is that there are multiple sensible implementations of Monoid Int
15:29:32 <chrisdone> Data.Default
15:30:06 <joelteon> yeah, but 1 could also be a default int
15:30:07 <xico> for sum and prod you mean?
15:30:15 <joelteon> yeah
15:30:20 <joelteon> that's why Sum and Product exist
15:30:22 <merijn> Bah
15:30:25 <chrisdone> xico: def :: Int → 0, def :: [a] → []
15:30:51 <acube> > mempty :: Sum Int
15:30:52 <lambdabot>   Sum {getSum = 0}
15:30:56 <xico> thanks :)
15:31:01 <acube> > mempty :: Product Int
15:31:02 <lambdabot>   Product {getProduct = 1}
15:31:03 <Ralith> nevermind, found encode
15:41:23 <Ralith> Vector has a Data.Binary instance, right?
15:43:22 <hpaste> “Anonymous Coward” pasted “Example” at http://hpaste.org/90253
15:44:22 <Ralith> apparently not
15:44:54 <raisdead> I am trying to get the code http://hpaste.org/90253 to work. I know that there must be some extensions to get this to work, but I am new to GHC extensions. Can someone help me?
15:48:44 <xico> raisdead: you are redefining mkStdGen from Random
15:48:59 <xico> raisdead: so you would have to hideit
15:49:24 <xico> raisdead: then you need MultiParamTypeClasses (since your typeclass is indeed taking two params)
15:52:34 <monochrom> "import" should be before your class, instances, etc
15:53:33 <raisdead> xico: monochrom: I forgot to remove the 'import System.Random' sorry. Just pretend it isn't there.
15:55:38 <xico> put a {-# LANGUAGE MultiParamTypeClasses, FlexibleInstances #-} as first line and you should be ok then.
15:55:38 <merijn> mm_freak: I looked at a bunch of the formlet stuff, and looks like that'd indeed be useful. Although I stil have to figure out a better way to separate the layout from it. The digestive-functor stuff uses String/Text based indexes, which seems really awful from a type safety point of view
15:56:57 <merijn> mm_freak: But getting safe identifiers to use seems to be a not so simple issue
15:59:06 <raisdead> xico: ghci complains about the different types of Possion and Uniform. Couldn't match expected type `λ' with actual type `(λ, λ)'
16:00:50 <monochrom> your class is designed poorly
16:02:42 <xico> raisdead: because you only pass one argument to Uniform constructor
16:02:53 <xico> i mean you do not pass it a tuple
16:04:57 <raisdead> xico: I was hoping to pass a tuple as the single parameter. mkStdGen (1,2) :: `Uniform (Double,Double)`
16:06:20 <merijn> raisdead: Your code does the equivalent of
16:06:36 <merijn> > let foo (x,y) = x in foo 1
16:06:37 <lambdabot>   Could not deduce (GHC.Num.Num (t, t0))
16:06:37 <lambdabot>    arising from the ambiguity check ...
16:06:41 <xico> raisdead: i mean not the (1,2), in the instance declaration, it should be (λ,λ)
16:12:04 <raisdead> merijn: I am not sure understand how they are the same
16:13:54 <merijn> raisdead: Uniform :: (l, l) -> Uniform l
16:14:40 <merijn> "g2 = mkStdGen (1.0,2.0) :: Uniform Double" would work
16:20:39 <hpaste> “Anonymous Coward” pasted “raisdead” at http://hpaste.org/90254
16:21:41 <geekosaur> raisdead, you are confusing type level and value level
16:22:06 <geekosaur> at *type* level, you have (for example) a Uniform Double, as on line 12 of your paste
16:22:14 <merijn> oh, yeah, I think your Uniform instance is impossible to write, because of the way you wrote the Uniform newtype down...
16:22:46 <geekosaur> hm, right, s aismple rewrite of that win't help :/
16:23:04 * geekosaur glares at finfers, decides he's not quite up to irc tonight... oops
16:23:57 <hpaste> “Anonymous Coward” pasted “raisdead” at http://hpaste.org/90255
16:24:11 <hpaste> merijn annotated “raisdead” with “Possible fix” at http://hpaste.org/90254#a90256
16:24:20 <merijn> That's one possible fix
16:24:35 <merijn> But it's not clear what you want, as you seem to be fairly confused about what you're doing...
16:25:25 <roboguy_> raisdead: when you try to make the instance for Uniform, the type of mkStdGen is "λ -> Uniform λ" not "(λ, λ) -> Uniform λ"
16:26:00 <geekosaur> the instance at lines 8--9 is difficult
16:26:19 <geekosaur> at value level, Uniform on line 9 requires a tuple
16:28:38 <raisdead> Thank everyone for the help. I got it. '
16:29:06 <xico> you should probably use different names at the type and the value level for now
16:29:08 <roboguy_> geekosaur: I just noticed something unrelated… is it just me or do those line numbers not match up with the lines?
16:29:46 <geekosaur> it's not just you. there's a preamble missing, probably with imports and such
16:30:33 <roboguy_> no, I mean the line numbers on the side are off center from the actual lines on my browser
16:30:50 <geekosaur> I'm not seeing that
16:30:55 <geekosaur> *but*
16:31:14 <raisdead> roboguy_: I don't see that either
16:31:57 <geekosaur> hm, no, my greasemonkey script wouldn't affect this
16:32:15 <geekosaur> (it tweaks the paste textbox which for some reason uses a proportional font by default)
16:36:53 <roboguy_> geekosaur: I'm looking at it on Chrome on OS X (although Firefox looks like this too). here's what it looks like to me http://tinypic.com/r/4slkic/5
16:37:48 <geekosaur> I'm also on Chrome for OS X
16:38:11 <mapreduce> Poisson, not Possion :)
16:38:27 <geekosaur> and the vertical alignment is fine here
16:39:02 <roboguy_> huh
16:39:13 <roboguy_> strange
16:39:25 * hackagebot nitro 0.2.2.3 - Haskell bindings for Nitro  http://hackage.haskell.org/package/nitro-0.2.2.3 (ErinDahlgren)
16:39:32 <raisdead> mapreduce: Thanks! my mistake...
16:39:33 <monochrom> bugs fix themselves when you try to report them :)
16:54:55 <chrisdotcode> hello everyone :)
16:56:23 <applikativ> hello chrisdotcode
16:56:31 <chrisdotcode> hi, applikativ
16:56:36 <chrisdotcode> how are you?
16:56:44 * xico
16:56:54 * xico wished i knew about haskell 5 years ago
16:57:14 <xico> (though probably the language was not as good at that time)
16:57:20 * applikativ ok grunt
16:57:50 * lispy wants for Data.List to have chunks :: Int -> [a] -> [[a]]
16:58:06 <lispy> or perhaps reshape?
16:58:15 <chrisdone> chunks exists somewhere
16:58:25 <applikativ> Data.List.Split
16:58:26 <xico> ,hoogle Int -> [a] -> [[a]]
16:58:31 <chrisdone> @hoogle chunk
16:58:31 <lambdabot> Data.ByteString.Builder.Extra Chunk :: ByteString -> BufferWriter -> Next
16:58:32 <lambdabot> Data.Text.Lazy.Internal chunk :: Text -> Text -> Text
16:58:32 <lambdabot> Network.HTTP.Base chunkedTransfer :: BufferOp a -> IO (Result a) -> (Int -> IO (Result a)) -> IO (Result ([Header], a))
16:58:50 <chrisdone> http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html#v:chunk
16:59:01 <applikativ> chunk :: Int -> [e] -> [[e]]
16:59:07 <applikativ> ah chrisdone has it
16:59:32 <frelux> trying this again... does anyone know how to functionify liftIO . putStrLn $ printf ?
16:59:34 <applikativ> hm how does it differ from chunksOf :: Int -> [e] -> [[e]]
17:02:44 <applikativ> hm, the difference is that chunk says     Deprecated: "Use chunksOf."
17:03:50 <chrisdone> D:
17:04:01 <frelux> as in liftIO . putStrLn $ printf "some thing: %s some other thing %s" (show someThing) (show someOtherThing) -- I find myself typing it often, and can't figure out how to work with Text.Printf's magical machinery to make a lifted version that also adds newlines
17:04:33 <chrisdone> printf is overloaded enough to be IO ()
17:04:40 <chrisdone> liftIO $ printf "hello\n" should work fine
17:07:20 <frelux> yeah, for sure that works too. just trying to yak-shave off those two bits of repetition : ) (liftIO and adding the \n)
17:08:33 <chrisdone> i tend to use io :: MonadIO m => IO a -> m a
17:08:57 <chrisdone> got the practice from dons. i like it. liftIO is too much work
17:09:51 <chrisdone> tos have off the io you could possibly add your monad as an instance of the printf
17:10:12 <chrisdone> though iirc base's printf (arbitrarily) doesn't expose the typeclass methods iirc
17:10:16 <hpc> when i find lifting gets annoying, i come up with a new set of types that requires less of it
17:10:16 <erisco> just trying to grok some basic concepts... so I can define   data T x = A x | B x    but if A indicates success, and B indicates failure, then why not   type T x = (x, bool) ?
17:10:26 <hpc> usually the result is a better underlying structure
17:10:40 <frelux> nice, agreed : ) yeah I'll give that a try, thanks!
17:10:41 <chrisdone> hpc: what's your better structure for liftIO?
17:10:58 <hpc> chrisdone: ML ;)
17:11:09 <chrisdone> monkey lips!
17:12:32 <erisco> I can understand if they are not constructed with the same data, but since they are, I am not sure if using different constructors is the right way to indicate failure
17:14:33 <monochrom> (x, Bool) works too
17:14:35 <hpc> erisco: it depends; there's an art to defining data types that are otherwise equal
17:14:45 <chrisdone> if x is the same type it's ok
17:15:05 <chrisdone> but generally it's nice to label booleans with proper names
17:15:56 <erisco> just a type synonym would work for that yes?
17:16:20 <monochrom> wouldn't even bother with giving it a name.
17:16:21 <chrisdone> actually i meant have a constructor for each case
17:17:17 <roboguy_> chrisdone: hey, are you the Chris Done of hpaste? the line numbers seem to be off center on my browser
17:17:26 <chrisdone> in the small case it doesn't matter. in a big system you appreciate Enabled | Disabled rather than True/False
17:17:34 <chrisdone> roboguy_: example?
17:18:15 <roboguy_> I'm on Chrome on OS X and this is what it looks like (Firefox looks like this, too): http://tinypic.com/view.php?pic=4slkic&s=5
17:22:33 <chrisdone> roboguy_: hmm. the fonts and sizes are the same, perhaps the lambdas are from a fallback front adjusting the line height
17:24:31 <roboguy_> chrisdone: yeah other pastes seem to look okay, so it's probably something to do with the lambdas. not really a huge issue, but I thought I'd mention it
17:26:15 <erisco> if there is only one constructor, and the data is not self-referential, is there any difference if you make it a type synonym instead?
17:27:43 <roboguy_> erisco: well, you can't really make type class instances of a type synonym (or if you enable the extension to do that, I think it would work a little differently than if it was a new type altogether). if you want that and you only have one type constructor you should use newtype
17:27:46 <applikativ> right, there cant be a recursive type synonym
17:29:30 <erisco> roboguy_, data T = T a b c    versus  type T = (a, b, c)  ;  t :: () -> T   t a b c = (a, b, c)
17:29:38 <erisco> t :: (a, b, c) sorry
17:29:43 <erisco> () -> ... whatever
17:30:47 <applikativ> is the question, why write data T  = T a b c  rather than type T = (a,b,c)
17:31:03 <erisco> I suppose. I'm asking what the difference is
17:31:30 <applikativ> there is also data T = T {x:: a, y:: b, x ::c}
17:31:41 <monochrom> you have two x's
17:31:42 <napping> the only difference is that a type T = (a,b,c) can be confused with any other triple
17:31:43 <applikativ> here a b c are concrete types so maybe they should be capitalized
17:31:49 <applikativ> monochrom: ah
17:31:58 <erisco> napping, how so?
17:32:00 <applikativ> data T = T {x:: a, y:: b, z ::c}
17:32:10 <napping> like if you have type T2 = (a,b,c) also, then id :: T -> T2
17:32:34 <erisco> napping, still not sure what you're saying
17:32:40 <AsgardBSD> Hi
17:33:01 <AsgardBSD> I advenced in my reading of LYAH
17:33:08 <chrisdone> hm
17:33:12 <napping> well, part of the point of making a separate type for something is to keep it from getting confused with other things
17:33:18 <applikativ> erisco, note that a def of the other forms can be recursive, data T = T Int Char T
17:33:34 <applikativ> otherwise it is just the 'product' of three types
17:33:39 <erisco> applikativ, sure. I acknowledged this earlier
17:33:41 <napping> at least, sometimes that's the point. "type" just makes a transparent synonym
17:34:10 <erisco> napping, but the types do not become interchangeable do they? I didn't think that was the case
17:34:18 <erisco> napping, so I am not sure how they become confused
17:34:19 <applikativ> erisco: also, you can for example manage some features of a data definition, e.g. strictness
17:34:27 * hackagebot sodium 0.6.0.1 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.6.0.1 (StephenBlackheath)
17:34:42 <applikativ> erisco: type synonyms are interchangeable
17:35:23 <monochrom> (Int, Char) is interchangeable with (Int, Char), no matter how many "type GNU = (Int, Char)", "type Unix = (Int, Char)", "GNU is not Unix" you write
17:35:24 <erisco> oh... well then that changes everything
17:36:02 <erisco> okay then thanks
17:36:08 <napping> data and newtype are not interchangeable
17:36:11 <applikativ> data Gnu = Gnu {-#UNPACK#-} !Char {-#UNPACK#-} !Int by contrast is not Unix
17:36:28 <napping> both of them make new types distinct from other types, I mean
17:36:36 <napping> "type" is just an abbreviation
17:37:17 <applikativ> a function :: GNU -> GNU in monochrom 's sense will apply to (3::Int,'a') whatever you call the type of it
17:38:27 <erisco> so type synonyms seem more useful for aliasing functions
17:40:57 <dolio> They are not for abstraction.
17:41:00 <dolio> Unless you use Hugs.
17:41:13 <erisco> what do you mean?
17:41:28 <dolio> Hugs has a feature where you can hide the implementation of a type synonym.
17:42:13 <erisco> okay, but what other options do you have if you don't want to type out the same signature repeatedly?
17:42:28 <dolio> So internally to a module, it is the same as the type it's aliased to, but externally you can't tell.
17:43:04 <monochrom> you can omit the type signature altogether
17:43:10 <monochrom> you can copy and paste
17:43:20 <monochrom> you can set an editor macro
17:43:49 <erisco> that isn't quite what I meant but I asked it stupidly
17:44:12 <monochrom> always say only what you meant
17:44:26 <erisco> wish that was easier
17:44:39 <napping> if you want to abbreviate a type it works
17:45:24 <monochrom> it is of the same difficulty as programming
17:45:28 <erisco> what I meant was, you can define a data type instead of using a tuple and this protects  you (or others) from assuming interchangeability
17:46:06 <erisco> well, that works for data, but if you have even a simple function  a ->a  then is the way to abstract that a type synonym + hugs as dolio said?
17:46:34 <monochrom> will you use hugs?
17:46:35 <swistak35> hi, can I say "or" in signature? I mean, I want that my function "is ok" for (example) "Char -> Bool" and "Integer -> Bool". Can I say "Char or Integer" in type signatures?
17:46:41 <dolio> If you want it to be a different type, use newtype.
17:46:58 <dolio> Using Hugs isn't a very realistic solution.
17:47:03 <monochrom> Either Char Integer -> Bool
17:47:29 <roboguy_> erisco: I'm not sure I completely understand. maybe you could give a more concrete example?
17:47:31 <swistak35> monochrom: I don't want Either
17:47:37 <flebron> swistak35: If your function is just polymorphic, you can let Haskell infer the type.
17:47:40 <monochrom> then cannot
17:47:41 <swistak35> I want my function is good for both
17:47:48 <swistak35> flebron: so just "a -> Bool" ?
17:47:52 <flebron> (Or you can see which operations you need and make a signature accordingly.)
17:48:05 <flebron> If your function works for any a, then yes. There are only two such (total) functions.
17:48:24 <roboguy_> swistak35: you could make a type class that has whatever function you need then make instances for Integer and Char, I guess
17:48:31 <flebron> If your function has restrictions on what its input can be, state those in the type signature.
17:49:02 <swistak35> flebron: not really, that's I wanted to avoid putting (Num a, Ord a)
17:49:03 <roboguy_> swistak35: or maybe one already exists, like Ord
17:49:12 <flebron> swistak35: Why do you want to avoid it?
17:49:30 <flebron> (Again, if your aim is just to avoid typing those ~10 characters, just let Haskell infer the type by not using a type signature.)
17:49:35 <swistak35> roboguy_: yeah, I figured out this solution but it's kind of complex (for simple purposes)
17:50:12 <swistak35> flebron: Too general, but of course it's not really but - I was just curious if there is maybe some kind of syntax for that, but this is not a huge problem : )
17:50:34 <flebron> There is, "(Num a, Ord a) => a -> Bool" :)
17:50:50 <swistak35> Yeah, I have this currently, thanks : )
17:59:12 <AsgardBSD_> Can we have our own company will being hired by another one?
17:59:39 <AsgardBSD_> Im considering starting a company as free time will being an employee in another one
18:00:01 <monochrom> that is #haskell-blah material
18:08:12 <Hidenori> I cannot import a module "System.Directory" which I found on Learn You. Is it like Haskell does not have it?
18:09:35 <troydm> Hidenori: works for me
18:09:35 <bgamari> Hidenori, How did you install ghc?
18:10:02 <bgamari> Hidenori, It's provided by the `directory` package
18:10:10 <Hidenori> i got Haskell platform a few months ago.
18:10:14 <bgamari> hmm
18:10:24 <troydm> it should be installed if you installed haskell-platform
18:10:25 <bgamari> HP should should certainly include it
18:10:42 <wavewave> hi
18:10:44 <bgamari> ghc-pkg list | grep directory
18:11:09 <Hidenori> My ghci shows this " Could not find module `System.Directory'     It is not a module in the current program, or in any known package."
18:11:19 <bgamari> Hidenori, or ghc-pkg describe directory
18:11:39 <bgamari> for lack of a better idea, you could just try `cabal install directory`
18:11:53 <bgamari> although multiple versions of directory can sometimes come back to bite you
18:11:59 <Hidenori> bgamari okay. I will do that
18:12:00 <troydm> Hidenori: cabal list --installed --simple-output | grep director
18:13:48 <Hidenori> bgamari: cmd.exe says "directory-1.2.0.1 depends on time-1.4.0.2 which failed to install"
18:14:02 <Hidenori> troydm: i'll try that.
18:14:37 <troydm> Hidenori: ohh you are on windows
18:14:44 <troydm> then don't try
18:15:00 <troydm> i tend to forget that ppl still use that evil os
18:15:43 <applikativ> Hidenori: just type 'ghc-pkg list' and see what it says about directory
18:15:57 <Hidenori> troydm ohh okay. I am thinking of trying ubuntu sometime soon, but i am afraid i am not good at compter enough ...
18:16:04 <applikativ> 'ghc-pkg check' it sounds like there is something wrong
18:16:27 <applikativ> Hidenori: this is not the new haskell platform, I take it; it just came out a couple weeks ago
18:16:46 <monochrom> older haskell platform has System.Directory too
18:16:49 <chrisdone> monochrom: http://ircbrowse.net/nick/monochrom
18:16:57 <applikativ> Hidenori: I wonder if you installed something that required a more recent directory
18:17:05 <applikativ> and then something went wrong
18:17:29 <applikativ> monochrom: yes of course, i was wondering if somethign else was up
18:18:03 <Hidenori> applikativ: i tried ghc-pkg list but there are too many and could not find directory.
18:18:17 <chrisdone> monochrom: i know when you sleep >:D
18:18:31 * chrisdone scratches against window pane
18:18:42 <monochrom> creepy!
18:18:51 <chrisdone> (╯°_°）╯
18:19:09 <ion> ︵ ┻━┻
18:19:18 <Hidenori> applikativ: i just remembered that i got free-game a few days ago and i used '-forceinstall' or sth like that. does it matter?
18:19:31 <monochrom> "ghc -v" may actually be more to the point than "ghc-pkg whatever"
18:19:36 <chrisdone> ion: you're comparatively evenly distributed http://ircbrowse.net/nick/ion
18:19:59 <ion> heh
18:20:34 <monochrom> yes --force-reinstall matters and carries exactly this risk. think: why is it not automatic? who bears the liability?
18:22:07 <applikativ> Hidenori: did you say that you have had this ghc/haskell platform for a while?
18:22:25 <Hidenori> monochrom: I see. Hmm I guess I was too careless.
18:22:37 <chrisdotcode> chrisdone: is it only for #haskell?
18:22:41 <chrisdotcode> (ircbrowse, that is)
18:22:47 <chrisdone> chrisdotcode: #haskell and #lisp
18:22:56 <Hidenori> applikativ: I installed haskell platform a few months ago for the first time.
18:23:04 <applikativ> Hidenori: I suspect the reason why unpleasantness was arising with e.g. free-game is your pile of hackage things is getting stale
18:23:06 <chrisdotcode> ah, okay
18:23:35 <applikativ> Hidenori: yes, the Haskell Platform was already a bit stale by then. I think you should install the new one.  I dont know how hard it is to uninstall....
18:24:02 <applikativ> Hidenori: http://www.haskell.org/platform/windows.html
18:24:18 <monochrom> it has standard uninstall for windows
18:24:29 <Hidenori> applikativ: oh i need to unsitall once?
18:24:35 <applikativ> Hidenori I think by now a lot of things go wrong with the previous version, e.g. it has bytestring-0.9 etc
18:25:04 <applikativ> Hidenori: I'm not sure maybe uninstalling the old one is a part of installing the new one.
18:25:29 <Hidenori> applikativ: I see.
18:25:37 <applikativ> after you do it, do cabal update, and install the things you used most, which you can do all at once.
18:26:06 <applikativ> then cabal can do its solving with a clear view of things.
18:26:32 <Hidenori> applikativ: okay thenks
18:26:34 <applikativ> cabal install free-game pandoc hakyll ... whatever
18:27:15 <Hidenori> i see
18:34:06 <chrisdone> Cale: http://ircbrowse.net/nick/Cale get more sleep
18:34:19 * applikativ declares 'cabal sandox' to be awesome
18:34:49 * applikativ likes 'cabal sandbox' even better
18:35:27 <chrisdone> applikativ: are you the same as applicative or another one?
18:35:52 <applikativ> the same I got tired of my stupid nick; time for mzip or something
18:36:10 <papyrus_> hello? i am new to haskell. could i have a qustion ?
18:36:22 <chrisdone> @justask
18:36:22 <lambdabot> Unknown command, try @list
18:36:22 <applikativ> please ask, papyrus_
18:36:37 <papyrus_> thanks. ^^
18:36:39 <papyrus_> (2+3)::Int
18:36:44 <chrisdone> applikativ: k 'cause that screws up your delicious stats
18:36:49 <papyrus_> (2)::Int
18:37:01 <papyrus_> polyTest3 ::  Num a => a -> Int
18:37:02 <applikativ> chrisdone: yeah, another purpose !
18:37:09 <papyrus_> polyTest3 x = x::Int
18:37:15 <papyrus_> compile error.
18:37:38 <applikativ> > let polyTest3 x = x :: Int in polyTest3 2
18:37:39 <lambdabot>   2
18:38:17 <napping> (2)::Int is saying what type 2 is supposed to be, not changing anything
18:38:31 <applikativ> > 2 :: Int
18:38:32 <lambdabot>   2
18:38:56 <napping> in polyTest3 x = x::Int, you say on the right side that x is an Int, so the type of the function can only be Int -> Int
18:39:11 <applikativ> @type let polyTest3 x = x::Int in polyTest3
18:39:11 <lambdabot> Int -> Int
18:39:16 <applikativ> hm
18:39:26 <papyrus_> hmm...
18:40:09 <applikativ> @type let polyTest3 x = (fromIntegral x)::Int in polyTest3
18:40:10 <lambdabot> Integral a => a -> Int
18:40:25 <papyrus_> oh....
18:40:33 <papyrus_> I understand.
18:40:44 <papyrus_> thanks a ton. :-) .
18:47:02 <papyrus_> Can i convert Num type to Int ?
18:47:29 <monochrom> Num is not a type
18:47:41 <papyrus_> yes.  my mistake
18:48:10 <papyrus_> how to convert Num class to Int ?
18:48:18 <monochrom> cannot
18:48:35 <napping> Num only has a method for going from integers
18:48:45 <napping> Integral has toInteger
18:49:00 <monochrom> that is still not "convert Num class to/from Integers"
18:51:32 <applikativ> there are methods for functions that take Float and Double to Int and Integer eg floor and ceiling
18:53:37 <papyrus_> thanks a ton. :-)
18:55:48 <chrisdone> quicksilver: your irc timing is impressively consistent: http://ircbrowse.net/nick/quicksilver
18:56:55 <djahandarie> Wow, I'm pretty inactive compared to some other people I guess :)
18:58:13 <chrisdone> your sleep cycle is pretty decent too. congrats =)
18:58:29 <djahandarie> Haha.
18:58:30 <chrisdone> what time zone are you in? east coast?
18:58:36 <djahandarie> Yeah.
18:58:47 <chrisdone> =)
18:59:41 <vraid> chrisdone: you maintain that?
19:00:14 <vraid> here's an example of an inconsistent sleep cycle http://ircbrowse.net/nick/vraid
19:01:05 <djahandarie> No, here's one: http://ircbrowse.net/nick/Cale
19:01:06 <djahandarie> Haha
19:01:10 <chrisdone> vraid: yeah i maintain it. looks pretty inconsistent but you've barely said anything for two years. that's like less than a single line every two days =p
19:01:21 <vraid> ..barely?
19:01:41 <chrisdone> yeah cale and elliott don't sleep
19:01:52 <chrisdone> vraid: 247 lines in 2 years?
19:02:54 <vraid> o.O
19:03:04 <quux> yais?
19:03:05 <vraid> erm
19:03:14 <vraid> more like 247 lines in 24 hours
19:03:47 <djahandarie> Also can't believe I've been around for 6 years now
19:03:54 <copumpkin> yeah wtf
19:04:26 <chrisdone> yeah i still think "a few years" in my head, not 6
19:04:42 <djahandarie> I think I was mainly a lurker for the first year
19:04:50 <byorgey> hah, 7 for me, seems like yesterday =)
19:05:13 <vraid> djahandarie: this channel hasn't been around for 6 years, has it?
19:05:20 <djahandarie> Of course it has lol
19:05:26 <chrisdone> vraid: http://ircbrowse.net/nick/shapr ← at least 14 years
19:05:27 <djahandarie> I think it's been around for over a decade
19:05:27 <copumpkin> a lot longer than that
19:05:46 <JoeyA> djahandarie: You're 6 years old?  Wow, talk about a head start in life :-)
19:05:51 <vraid> chrisdone: oh, i'm sorry, i thought this was another channel -_-
19:05:59 <vraid> it makes sense now
19:06:31 <djahandarie> shachaf has been around for 7 years apparently, didn't know he'd been around longer than me
19:06:59 <copumpkin> shachaf the omnipresent
19:07:26 <vraid> chrisdone: yeah. i don't use haskell much unfortunately :P
19:07:36 <vraid> but i like it in theory
19:07:58 <djahandarie> You'll fit right in, we love theory too
19:08:34 <JoeyA> Hmm, it doesn't have much data on me: http://ircbrowse.net/nick/joeyadams "joeyadams has written 22 lines in 2 years, most active at around 1:00 (UTC)."
19:08:42 <vraid> djahandarie: ^^
19:09:35 <JoeyA> '; UPDATE stats SET count=1000000000 WHERE name='joeyadams'; SELECT '
19:09:37 <djahandarie> Wow, my activity really dropped in 2012, heh.
19:09:40 <JoeyA> That should do the trick.
19:09:43 <chrisdone> just updated it with activity over years
19:10:06 <chrisdone> http://ircbrowse.net/nick/shachaf ← looks like shachaf kinda gave up and then in 2011 something changed =)
19:10:11 <djahandarie> copumpkin has slowly been fading away
19:10:20 <copumpkin> http://nooooooooooooooo.com
19:10:20 <chrisdone> woah, yeah
19:10:27 <djahandarie> Haha
19:11:11 <copumpkin> :)
19:11:19 <chrisdone> djahandarie: you too actually. what happened in 2012?
19:11:27 <djahandarie> School.
19:11:28 <JoeyA> Maybe he lost his job?
19:11:37 <JoeyA> kidding
19:11:46 <chrisdone> school, s'a killer
19:12:23 <djahandarie> I was in school before that too of course, but I finally decided to focus on it more in '12 and '13. I'm at a new job now, we'll see how that affects my IRC activity.
19:12:38 <djahandarie> I haven't even gotten internet at my apartment yet so it's not looking so good.
19:12:44 <copumpkin> lol
19:13:15 <chrisdone> in the hierarchy of needs mine's like: internet -> shelter -> food -> …
19:13:36 <djahandarie> Yeah it's been an interesting experience not having internet (aside from phone which is really annoying)
19:13:46 <djahandarie> I've been reading... a lot. I usually don't touch books at all.
19:13:51 <chrisdone> how much are you paying for phone internet?
19:13:52 <djahandarie> But so far I've read like 3.
19:13:58 <chrisdone> oh, that's cool
19:14:14 <djahandarie> Yeah it's pretty interesting, I didn't think I could even finish a book.
19:15:10 <djahandarie> I plan on going and yelling at Comcast tomorrow to make them finally get me some internet hopefully. It's been a real pain.
19:16:08 <chrisdone> can you get fibre there?
19:16:20 <djahandarie> Nope, Comcast has the monopoly
19:16:31 <djahandarie> I wonder where ddarius's earlier history is: http://ircbrowse.net/nick/ddarius
19:16:42 <djahandarie> Ah, actually I think it was pre-2000
19:16:56 <djahandarie> Maybe? I don't have a good handle on these things.
19:17:20 <chrisdone> http://ircbrowse.net/nick/mmorrow ;_;
19:17:49 <copumpkin> I wonder if he's still climbing
19:17:55 <copumpkin> or what he's doing
19:18:36 <applikativ> climbing?
19:18:44 <chrisdone> they say he's still reading that manual …
19:18:58 <copumpkin> I tracked down a childhood friend of his and asked him if he knew what was up
19:19:21 <djahandarie> Another fade-out: http://ircbrowse.net/nick/gwern
19:19:28 <copumpkin> he said everyone was wondering that but that his parents said he'd gone off to the mountains to climb
19:19:37 <copumpkin> who knows
19:19:50 <djahandarie> It seems like a lot of people showed up around 08 and were very active the faded out
19:20:00 <djahandarie> then*
19:20:26 <chrisdone> some think that this is matt: http://math.uchicago.edu/~mmorrow/
19:20:40 <copumpkin> nah, pretty sure that isn't him, even though it's same location and name
19:20:50 <chrisdone>  don't think he was publishing papers in 2008 tho
19:20:54 <chrisdone> yeah
19:21:07 <thoughtpolice> oh matt, i hope you're doing well
19:21:25 <thoughtpolice> he had several intriguing works (one of which, i 'maintain')
19:21:27 <copumpkin> our mmorrow went to columbia for undergrad
19:21:45 <djahandarie> sup thoughtpolice
19:22:04 <JoeyA> Does ircbrowse just record stats, or content as well?  I'm curious what I got up at 9:00 AM to say.
19:22:08 <thoughtpolice> hi djahandarie, how are you?
19:22:17 <JoeyA> It should also have an NSA panel :-)
19:22:21 <thoughtpolice> copumpkin: and how're you?
19:22:23 <djahandarie> Good!
19:22:32 <copumpkin> I'm quite well!
19:22:53 <copumpkin> perhaps we should move to #haskell-blah :)
19:22:56 <chrisdone> yeah i wonder if there's an anti-climax effect now that haskell has kind of 'made it', at least irc-wise. maybe there's less feeling or need to evangelize and communicate as much?
19:22:58 <thoughtpolice> oh, yes
19:23:21 <copumpkin> chrisdone: yeah, also the same questions/discussions over and over again get a bit old
19:23:29 <chrisdone> nod
19:23:43 <copumpkin> interests also change over time :)
19:24:00 <chrisdone> JoeyA: content: http://ircbrowse.net/browse/haskell
19:24:34 <chrisdone> copumpkin: where did vixey go?
19:24:54 <copumpkin> came back under a bajillion nicknames and then stopped coming back, as far as I can tell
19:25:02 <copumpkin> also sad :/
19:25:08 <thoughtpolice> well, there are also several better forums for communication these days
19:25:09 <chrisdone> might be here now… <_<    >_>
19:25:12 <thoughtpolice> like reddit, or SO
19:25:25 <applikativ> well, it probably doesn't matter since edwardk seems to be increasing exponentially
19:25:30 <JoeyA> chrisdone: thanks
19:25:44 <djahandarie> applikativ, hahaha
19:25:45 <thoughtpolice> well, no better, but different. SO is nice for some kinds of questions i think don't do well here
19:25:46 <chrisdone> copumpkin: yeah vixey was pretty intense
19:25:48 <thoughtpolice> *not
19:26:27 <chrisdone> ah, edwardk's the only one i've seen that's actually increasing
19:26:38 <copumpkin> he gets paid to do that :)
19:26:48 <hodapp> huh, so if I have... fn :: (Ord a) => [[a]] -> [Set a], fn l = map fromList l - why is this ambiguous? Is it that (map fromList) is actually done first?
19:27:13 <JoeyA> ; instead of ,
19:27:29 <hodapp> yeah, I don't know how to do it on one line... I'm just doing crappy-IRC-translation
19:27:39 <applikativ> what do you mean, ambiguous hodapp
19:27:41 <copumpkin> perhaps the fromList is ambiguous?
19:27:50 <copumpkin> if you import Map and Set unqualified for example
19:27:54 <JoeyA> :t S.fromList
19:27:55 <lambdabot> Ord a => [a] -> S.Set a
19:27:57 <applikativ> oh is something like Data.Map ...
19:28:04 <applikativ> like copumpkin says
19:28:24 <JoeyA> :t let fn :: (Ord a) => [[a]] -> [S.Set a]; fn l = map fromList l in fn
19:28:24 <lambdabot>     Not in scope: `fromList'
19:28:25 <lambdabot>     Perhaps you meant one of these:
19:28:25 <lambdabot>       `IM.fromList' (imported from Data.IntMap),
19:28:28 <monochrom> "map" is ambiguous. Prelude.map or Data.Set.map
19:28:32 <hodapp> well, I'd think that the 'l' makes it clear that I'm meaning Data.List.map, but I suppose it's not clear if it applies fromList first by itself
19:28:33 <JoeyA> :t let fn :: (Ord a) => [[a]] -> [S.Set a]; fn l = map S.fromList l in fn
19:28:33 <lambdabot> Ord a => [[a]] -> [S.Set a]
19:29:05 <monochrom> no, type does not resolve name clashes.
19:30:35 <applikativ> hodapp: people sometimes say it could do a bit of 'type directed name resolution', but it doesn't
19:30:51 <monochrom> "map id []" and "map id empty" are both name clashes, no matter how much you say [] is clearly a list and empty is clearly a set
19:31:41 <applikativ> hodapp: it is in connection with record fields especially that people are intemperate on the subject...
19:42:44 <ctult> How easy would it be to comfortably put Haskell on an embedded handheld device (eg. the Nintendo 3DS)?
19:45:55 <slack1256> is the Nintendo 3Ds an arm based device?
19:47:12 <ctult> slack1256: It's a custom SoC, so I will have to look that up.
19:47:36 <ctult> Yes, it is an arm device.
19:51:49 <dmwit> ctult: It would probably take a bit of work. I know there's been some effort to make ARM-y GHCs, but I suspect each new device brings its own foibles.
19:52:21 <dmwit> Also, cross-compilation isn't really there yet.
19:53:16 <slack1256> also nintendo would not like it.
19:53:44 <ctult> slack1256: I am getting a 3DS developer's license.
19:54:44 <erisco> ctult, I got one of those
19:54:58 <erisco> ctult, ... in Game Dev Tycoon. Is it transferrable?
19:56:46 <mhr> Have any of you read this article: http://e-texteditor.com/blog/2010/beyond-vi ?  Their website is gone forever, and I can't find a mirror.  I'm trying to find someone with a local copy.
19:56:49 <ctult> erisco: I don't know, I am still in the process of getting it.
19:57:25 <ctult> (or rather acquiring it)
19:57:42 <mhr> Is there a comprehensive archiving service other than archive.org that ignores robots.txt?  Maybe the website would be backed up on there...
19:58:01 <erisco> isn't there timemachine or something?
19:58:09 <erisco> waybackamachine?
19:58:22 <erisco> okay that's just archive.org :P
19:58:32 <mhr> They respect robots.txt...
19:58:42 <ctult> erisco: What do you mean "transferrable"?
19:59:06 <mhr> The damn website blocked EVERY SINGLE CACHE SERVICE.  Argh.  I can hardly express the extent of my frustration right now.
19:59:51 <mhr> erisco: for a second, I thought you were talking about the Mac software, which had me confused.
20:01:53 <ctult> I just realized what you meant, erisco.  I feel like an idiot. :P
20:02:02 <erisco> ctult, :P
20:02:06 <ctult> btw, I love that game
20:04:56 <erisco> ctult, I found the idea interesting but I found the game creation process too arbitrary, and unfortunately instead of insightful reviews they are meaningless
20:05:54 <erisco> I would have liked the development categories to be contextualized to the type of game so that you'd have some inkling on what they meant. and, if the reviews that came back actually contained information about what was wrong, you'd be able to improve for next time
20:06:25 <rance35> hey!
20:06:52 <rance35> which is the best place to learn about foldr and foldl functions?
20:07:15 <erisco> and a minor gripe is that they punish you for making the same types of games, which spoiled my initial plan of having a studio that only made fantasy rpgs
20:08:44 <Aetherspawn> anyone know where I can find the haskell parser in ghc?
20:09:46 <gwern> @quote parser
20:09:47 <lambdabot> augur says: I WANT TO HAVE SEX WITH A PARSER
20:09:58 <dmwit> rance35: There's a nice page on the wiki.
20:09:59 <Aetherspawn> ok.
20:10:44 <erisco> Parsec is interesting... they mush the parsing together with transforming the parse tree. at least that is how the examples seem to go
20:10:57 <dmwit> rance35: http://www.haskell.org/haskellwiki/Fold I think
20:10:58 <erisco> which basically makes it a recursive descent parser
20:11:03 <dmwit> though it's been a while
20:11:10 <erisco> with helper functions
20:11:10 <dmwit> rance35: Alternately: just stare at the source really hard. ;-)
20:11:55 <dmwit> erisco: I'm not sure calling Parsec a recursive descent parser is quite fair...
20:12:03 <erisco> I don't see how it differs
20:12:29 <erisco> I've only looked at a couple examples though, and I think this is the clearest: http://book.realworldhaskell.org/read/using-parsec.html
20:12:50 <dmwit> Well, I mean, recursive descent is an algorithm, but Parsec is an interface.
20:13:09 <erisco> Parsec is a helper library to implement recursive descent parsers
20:13:22 <erisco> is what it looks like, to me, is what I meant
20:13:54 <erisco> it even has the same backtracking problem as recursive descent parsers, and is top down
20:14:08 <erisco> unless there is uber magic under the hood
20:15:03 <Aetherspawn> lol, these ghc comments are so funny
20:15:13 <Aetherspawn> it's like reading a forum thread sometimes.
20:16:31 <erisco> I dunno, I was expecting something slightly different when I envision a parser. I'd expect to construct the parser using its "primitives" (basic parsers such as "match this single character") and combinators (such as "match the longest from this or this")
20:16:57 <erisco> and that parser, when given input, would return a parse tree
20:17:06 <erisco> and then you'd massage the parse tree into what you wanted
20:17:16 <erisco> rather than doing both the parsing and the massaging at the same time
20:17:34 <napping> it's easy to just assemble a parse tree if you want
20:18:03 <dmwit> Indeed, it's quite normal to munge the parse tree afterwards.
20:18:21 <napping> parsec also handles backtracking with "try"
20:18:31 <Aetherspawn> be careful with try
20:18:35 <napping> you have to ask for it explicitly, but it will backtrack rather than just getting stuck
20:18:41 <Aetherspawn> I misplaced it and it's hard to spot, but it made my parser like 1500% slower
20:18:50 <napping> oh, and nice error messages
20:19:11 <napping> if you just want recursive descent with no backtracking you can do something yourself in maybe 20 lines of code
20:19:18 <erisco> napping, is it perfect backtracking?
20:20:07 <napping> yes
20:20:15 <dmwit> "perfect backtracking"?
20:20:20 <dmwit> What does that mean?
20:20:32 <napping> pure code doesn't have side effects
20:20:41 <erisco> dmwit, I dunno, I made up the term. But what I mean is that no possible substitutions are left untried
20:20:52 <napping> substitutions?
20:20:53 <erisco> dmwit, which can easily happen in a recursive descent parser
20:21:27 <erisco> if you look at the grammar rules as substitution rules
20:21:30 <napping> it tries other alternatives, and backtracks on parse errors
20:21:49 <erisco> so like     A -> b | c   means that A can be substituted for a 'b' or a 'c' is what I mean
20:22:27 <dmwit> try b <|> c will certainly attempt c if b fails
20:22:27 <erisco> napping, yeah but does it try *all* alternatives? based on the example I linked to I don't see how it could be doing that
20:22:53 <napping> it gives you the first successful parse
20:23:04 <dmwit> try p succeeds if p does, and fails without consuming any input if p fails (even after consuming some input)
20:23:38 <erisco> the problem doesn't occur with   try b <|> c ... let me explain further
20:23:40 <dmwit> (...and when p succeeds, try p consumes the same thing that p did)
20:24:26 <napping> yeah, try is how you request backtracking
20:26:38 <napping> hmm, why is this a type error: (\f -> ((f :: forall x . x -> x)(\x ->x))(f ())) (\x ->x)
20:27:33 <erisco> when you apply another rule, and it isn't the tail, that is when the problem can occur, and it is because of greediness
20:28:22 <dmwit> erisco: I'm not sure I understand what you're worried about yet. Can you give a crisp example with a grammar like you did before?
20:28:41 <napping> erisco: yeah, you have to consider some things like that to get the correct parse with parsec, but at least by using try and some of the factorization combinators you can deal with it if you have to
20:29:00 <dmwit> napping: I guess you probably need to annotate f's type a bit higher.
20:29:16 <dmwit> napping: e.g. something like (\(f :: forall x. x -> x) -> ...) (\x -> x)
20:29:22 <napping> Yeah, I guess 7.6 is more predicative than I thought
20:29:28 <dmwit> napping: You may also need to annotate (\x -> x)'s type, though I'm not sure.
20:29:34 <erisco> dmwit, yes. If I can dig up the simple example here...
20:29:39 <dmwit> napping: 7.6 is 100% predicative =)
20:29:40 <napping> putting it arond the first lambda is enough
20:29:44 <pavonia> Hi! Could anyone please help me to understand the following error? http://hpaste.org/90258
20:29:45 <erisco> I don't want to give one that doesn't actually cause the issue
20:29:54 <dmwit> (I think even the ImpredicativeTypes extension doesn't do anything any more...)
20:30:13 <erisco> dmwit, Internet is going down here. m ight be a bit
20:30:19 <dmwit> erisco: Okay, no worries.
20:30:21 <napping> I just finished implementing the bidirectional system from this year's ICFP, noticed you couldn't force a polymorphic type from an internal annotation like that, and tried in GHC
20:30:46 <dmwit> pavonia: looking
20:30:55 <pavonia> thanks
20:31:12 <napping> pavonia: you probably need something like lift
20:31:51 <pavonia> napping: Where exactly?
20:31:58 <napping> return is trying to give the block a type like (ReaderT r m) (m a)
20:31:59 <dmwit> pavonia: lift isn't the issue, I think
20:32:11 <dmwit> pavonia: Ask yourself this: what type do you expect "a" and "b" to have in your last line?
20:32:17 <Saizan> napping: un-annotated lambdas have always been defaulted to monotypes
20:32:18 <napping> right, there are also bigger issues
20:32:42 <pavonia> Oh wait
20:32:55 <napping> Saizan: defaulted, yes. I was thinking they started out as unification variables that might be forced polymorphic with a type annotation
20:33:11 <pavonia> Right, a and b are not the Applicatives
20:33:22 <dmwit> pavonia: right =)
20:34:13 <Saizan> napping: well, maybe defaulted is the wrong word, there never was a way to override that with an annotation in the body
20:35:44 <Saizan> nor inference from the body, only from the outside
20:38:51 <pavonia> Hm, I have no idea how to write that Alternative instance :s
20:39:30 <napping> you'll need to look at the implementation of ReaderT, and depend on the Alternative m instance
20:40:17 <pavonia> You mean I have to use the ReaderT wrapper?
20:40:25 <dmwit> presumably
20:40:46 <dmwit> pavonia: You really should be using it in your Applicative instance, too, so that you don't need to depend on Monad m. ;-)
20:41:25 <dmwit> pavonia: (Chances are good that any instance of these things that doesn't use the constructor can be improved somehow. Rule of thumb for all types/classes.)
20:41:34 <pavonia> Yeah... for the actual code it doesn't matter though :p
20:42:06 <dmwit> Wait, there's actual code behind this? Doesn't ReaderT already suply these instances...?
20:42:31 <pavonia> No
20:42:34 <dmwit> ...yes it does
20:42:38 <dmwit> According to the documentation.
20:42:49 <dmwit> http://hackage.haskell.org/packages/archive/mtl/2.1.2/doc/html/Control-Monad-Reader.html#t:ReaderT
20:43:03 <pavonia> :o
20:43:18 <dmwit> I thought you were just doing this as a learning exercise.
20:43:22 <erisco> okay
20:43:35 <erisco> dmwit, A -> aAa | aa
20:44:09 <dmwit> erisco: a = many (string "aa") -- ;-)
20:44:18 <erisco> dmwit, a recursive descent parser that faithfully follows this grammar will fail to match the string "aaaaaa"
20:44:23 <pavonia> Ah, it's because my mtl version is outdated
20:44:44 <erisco> dmwit, yes, you can cheat your way out of it, but that is only by breaking out of a recursive descent parser
20:44:53 <dmwit> more helpfully: a = char 'a' >> try a >> char 'a' -- will work just fine
20:45:07 <dmwit> I don't know why you're so stuck on recursive descent.
20:45:19 <erisco> because at the end of the day that is still what the parser is
20:45:24 <dmwit> err, yeah, actually, that probably will not work fine
20:45:25 <dmwit> sorry
20:45:28 <dmwit> I mean this:
20:45:42 <dmwit> a = try (char 'a' >> a >> char 'a') <|> (char 'a' >> char 'a')
20:45:54 <dmwit> This is the transliteration of that grammar.
20:45:54 <erisco> so, yes, you can refactor the grammar, make it different, and avoid the problem, but my contention is about the backtracking. nothing else.
20:45:58 <dmwit> But you should not write it this way.
20:46:17 <erisco> dmwit, and I am presuming that will fail on the string "aaaaaa"
20:46:24 <dmwit> It shouldn't, no.
20:46:26 <dmwit> Let's try it!
20:47:33 <monochrom> A->aAa|aa is both expensive for recursive descent and unrealistic
20:47:46 <pavonia> dmwit: Do you know where these Applicative/Alternative instances are defined? I can't find them in the Reader sources
20:48:30 <erisco_> wish xchat was smart enough to ghost my other nick
20:48:31 <OxGOOSE> I have a related question:
20:48:38 <monochrom> B->(B)|() poses little problem to parsec and is actually close to real world grammars
20:48:48 <dmwit> erisco_:Nope, it works fine.
20:48:56 <OxGOOSE> What is the char funtion in: char 'a' >> a >> char 'a'?
20:49:01 <dmwit> Prelude Text.Parsec> parse a "" "aaaaaa"
20:49:02 <dmwit> Right 'a'
20:49:02 <dmwit> Prelude Text.Parsec> parse a "" "aaaaaa"
20:49:02 <dmwit> Right 'a'
20:49:07 <dmwit> Sorry for the double-paste.
20:49:19 <erisco> what does the empty string mean?
20:49:29 <monochrom> input filename
20:49:32 <dmwit> OxGOOSE: It's a Parsec function that produces a parser that consumes exactly the character 'a' (and returns it) and fails if that's not what it sees.
20:50:01 <dmwit> erisco: The empty string is a piece used for reporting errors, so unimportant in case the parse has succeeded.
20:50:28 <OxGOOSE> dmwit: Thank you.  I've never worked with the parsec libraries, but I'll read up on those right now
20:50:44 <erisco> interesting. I hope I didn't muck up my trace by hand... I couldn't dig up the exact example so had to recreate it
20:51:01 <erisco> dmwit, I'd be interested in a more detailed trace of what it is doing. hm.
20:51:04 <chrisdotcode> guys, I have yesod installed, but it won't let me import it.
20:51:14 <chrisdotcode> And what's the difference between the "yesod" binary and "yesodweb"?
20:51:24 <dmwit> erisco: Well, there's not much to it. It just backtracks. =)
20:51:53 <Saizan> monochrom: what's the difference between A and B?
20:51:59 <dmwit> erisco: So, first it tries to parse the whole thing as if there were six starting 'a's and six ending 'a's; this doesn't work, so it tries five, then four, then succeeds at three.
20:52:17 <monochrom> a tiny bit of lookahead saves you a million backtrackings
20:52:31 <monochrom> moreoever, A is regular, B is non-regular
20:52:34 <dmwit> erisco: If you pass it an odd number of 'a's, it will fail all the way down to zero and then fail completely.
20:52:39 <erisco> dmwit, I will have to double check my trace. I may have screwed up the example
20:53:01 <monochrom> A is really meant to be just many1 (string "aa"). it's a bloody regular language
20:53:08 <erisco> I went and cleaned out a bunch of old files and unfortunately it was one of them -.-
20:53:14 <dmwit> (Assuming you had an "eof" parser at the end, of course. Otherwise every string will succeed but will not do what you thought it did.)
20:53:22 <erisco> and I was saying to myself "just delete this stuff.. you won't need it anymore"
20:53:22 <dmwit> monochrom: I proposed this already.
20:53:53 <monochrom> I'm answering Saizan
20:54:37 <Saizan> monochrom: oh, yeah, too late/early to pay attention to ( /= )
20:54:48 <pavonia> Had to install the transformer package and now it works!!
20:54:53 <pavonia> Thanks guys :)
20:55:13 <OxGOOSE> Here's another question if anybody wants to answer: in the type signature "class Monad m => Stream s m t | s -> t where", what does the pipe mean?  Is it similar to the pipe used with constructing a data type?
20:55:47 <dmwit> OxGOOSE: Read about the FunctionalDependencies extension.
20:55:50 <dmwit> might be called FunDeps
20:56:02 <OxGOOSE> Thanks again!
20:57:34 <fosskers> hey guys, I've banged out a lot more for my haskell-based Lisp: sharing, let, higher-order functions, faster recursion
20:58:44 <Aetherspawn> fosskers, haskell-based lisp?
20:59:26 <carter> sclv how likely are you to do the jmacro analogue idea before mid september?
20:59:28 <dmwit> OxGOOSE: Helping people that are just looking for the name of the right heading in TFM is fun. =)
20:59:39 <dmwit> OxGOOSE++
21:00:10 <fosskers> Aetherspawn: Lisp implemented in haskell, i suppose i should've said
21:00:15 <carter> or if i reallly want it within the next month or so, should i learn jmacro some and then just do it myself and pester you for help once i get it rolling?
21:00:24 <OxGOOSE> :-)
21:00:37 <fosskers> Aetherspawn: although it would be neat if you could combine it with Haskell modules or something
21:00:45 <fosskers> a la Closure
21:00:51 <fosskers> Clojure?
21:00:53 <carter> whats the projects?
21:01:13 <carter> you can emdedd other languages via quasiquoters
21:01:32 <carter> and some cool things for enabling crazy   / neat use cases should land in ghc 7.8
21:02:20 <fosskers> https://github.com/fosskers/hisp
21:02:46 <erisco> dmwit, I'm getting my head twisted on the trace. Maybe I could explain it another way but its not that important
21:03:14 <erisco> anyways, point is, I was just curious that Parsec was designed in such a way
21:05:35 <hodapp> gaaaaah, it seems like every time I find an example for something involving OpenGL or FRP, it always relies on some broken cabal package
21:05:37 <Aetherspawn> fosskers, that's quite cool
21:06:00 <hodapp> e.g. https://github.com/ony/yampa-glut/blob/master/example.lhs
21:07:17 <hodapp> this is most irritating when all I want is to find some working examples
21:07:50 <erisco> dmwit, unless you are actually interested
21:09:24 <monochrom> hodapp: I think http://www.youtube.com/watch?v=-IpE0CyHK7Q (part 1) and http://www.youtube.com/watch?v=T3xXebIr8AM (part 2) help? the package name is cuboid, it uses yampa
21:14:27 <fosskers> Aetherspawn: thanks
21:14:49 <chrisdotcode> so guys...
21:14:52 <chrisdotcode> I totally messed up my cabal.
21:14:55 <chrisdotcode> like totally.
21:15:01 <fosskers> chrisdotcode: nuke and pave
21:15:09 <chrisdotcode> fosskers: that's how I messed it up
21:15:18 <fosskers> uh oh!
21:15:26 <slack1256> rm -rf the whole thing?
21:15:28 <slack1256> what?
21:15:32 <chrisdotcode> removed everything in .ghc/<arch>/* and .cabal/{packages,bin,etc}/
21:15:35 <hodapp> monochrom: thanks, that seems to be functioning
21:15:35 <chrisdotcode> slack1256: I didn't remove it all
21:15:41 <chrisdotcode> just selectively
21:15:43 <fosskers> chrisdotcode: what OS are you running
21:15:57 <chrisdotcode> linux, 64 bit, mint
21:16:02 <chrisdotcode> should I rm -rf it all?
21:16:06 <chrisdotcode> both .cabal and .ghc?
21:16:08 <fosskers> chrisdotcode: yeah you shouldn't have done that
21:16:09 <slack1256> yeah.
21:16:20 <fosskers> chrisdotcode: you could have accomplished the same thing by removing the ghc package
21:16:28 <fosskers> chrisdotcode: via your package manager
21:16:36 <monochrom> no, that's different
21:16:39 <fosskers> chrisdotcode: you could always still try that
21:16:50 <fosskers> that's what i meant by nuke and pave, at least
21:16:55 <chrisdotcode> so purge haskell-platform, then reinstall it?
21:17:09 <fosskers> chrisdotcode: that's my suggestion
21:17:15 <slack1256> but packages on mint don't remove configuration right?
21:17:23 <fosskers> chrisdotcode: that's what i do when certain things break on ghc updates on my Arch
21:17:25 <monochrom> SIGH
21:17:37 <chrisdotcode> monochrom: oh guru, should I follow the given advice?
21:17:43 <monochrom> NO
21:17:46 <slack1256> heh
21:17:51 <fosskers> monochrom: then enlighten us
21:18:26 <slack1256> I'm sure it is on some FAQ, I will search it
21:18:28 <monochrom> cabal mess is $HOME/.ghc only. nothing to do with system-wide ghc and haskell-platform
21:18:37 <chrisdotcode> ....right.
21:19:04 <monochrom> that is, unless you routinely did "cabal install --global", but I doubt you even knew it existed
21:19:25 <chrisdotcode> nope...
21:19:36 <fosskers> monochrom: it's a bit different for me, as i never do `cabal --install`
21:19:53 <fosskers> i install packages
21:20:19 <chrisdotcode> monochrom: I installed yesod and all other accompanying libs, but I still couldn't import Yesod, nor did I have the yesod tool, but it was telling me it was already installed. so I selectively deleted everything. how do I "clean" my environment?
21:20:23 <monochrom> sure, therefore "cabal mess" is unrelated to what you do or see
21:20:41 <fosskers> right. i still happens though
21:21:00 <monochrom> just clean $HOME/.ghc
21:21:24 <chrisdotcode> monochrom: okay, done. that it?
21:21:27 <monochrom> maybe $HOME/.cabal/bin too?  do an ls and decide who to delete
21:22:40 <chrisdotcode> monochrom: will I get in trouble if I rm -r .cabal/* ?
21:23:23 <monochrom> no trouble, except for losing .cabal/config
21:23:24 <JoeyA> chrisdotcode: Not necessary, and probably not a good idea.
21:23:31 <JoeyA> And losing everything installed to .cabal/bin
21:23:43 <chrisdotcode> JoeyA: well I'm trying to purge everything
21:23:44 <JoeyA> and losing your package cache
21:23:50 <chrisdotcode> I don't mind that that much
21:23:53 <JoeyA> (cached downloads)
21:23:56 <AfC> chrisdotcode: might want to keep .cabal/config and .cabal/packages/
21:24:25 <JoeyA> Simply moving .ghc/i386-linux-7.6.2 (or whatever it is on your system) out of the way should be fine.
21:25:08 <JoeyA> Note that there's also a global package database (/var/lib/ghc/package.conf.d on my system).
21:26:05 <JoeyA> You may want to remove .cabal/bin/{anything,yesod,related}
21:26:23 <JoeyA> But you might have some important programs you built that you want to keep (e.g. cabal).
21:28:55 <tam1138> hello!
21:30:46 <tam1138> i'm trying to define a datatype with two fields, both functions: X -> a, a -> Y, where X and Y are concrete types, but I don't care about the type of 'a' so long as it's Showable.  i can't figure out where in the datatype definition to put the "Show a =>" part, any advice?
21:32:58 <monochrom> "I don't care" is ambiguous. is "I" the author of that data type? is "I" the user of that data type? big difference.
21:33:48 <b6> is there something wrong with cabal and profiling lately? i'm configuring with --enable-executable-profiling, but ./foo +RTS -p reports it wasn't built with -prof.
21:34:13 <tam1138> i want to define the datatype to allow users to use any Showable for 'a', but that 'a' must be the same for both fields
21:34:15 <monochrom> if author, data T a = T (X->a) (a->Y). forget putting "Show a" there. just forget. put it in type sigs of functions
21:34:51 <monochrom> alright, then it's author, and above.
21:35:19 <tam1138> cool, thanks
21:37:26 <tam1138> now i want to include a value of this datatype in yet another datatype (eg, data Foo = Foo String T) but that doesn't work because it wants a parameter for T
21:37:46 <monochrom> data Foo a = Foo String (T a)
21:38:38 <monochrom> unless, you say, this time, the user of Foo doesn't care
21:38:42 <tam1138> ugh.  but now i have to propagate 'a' to every use of Foo
21:38:47 <tam1138> and yes, the user of Foo doeesn't care
21:39:09 <monochrom> data Foo = forall a. Show a => Foo String (T a)
21:41:35 <tam1138> awesome.  thank you!
21:42:05 <monochrom> it needs extension ExistentialQuantification
21:42:13 <tam1138> yep, got that =)
21:42:20 <tam1138> how dangerous is that extension?
21:42:59 <monochrom> not dangerous in type safety. only dangerous in "is it really a solution to your problem"
21:43:07 <tam1138> in this case, i believe it is
21:43:16 <monochrom> I guess that doesn't count as danger
21:43:21 <shachaf> chrisdone: Can you count words as well as lines?
21:43:37 <tam1138> i was thinking more in the sense of language/compiler stability
21:44:00 <monochrom> it is very unlikely to disappear in future GHC
21:44:11 <tam1138> excellent, thank you
21:44:21 <monochrom> it's both type-safe and useful
21:44:32 * hackagebot llvm-general 3.2.0.2 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.0.2 (BenjaminScarlet)
21:46:26 <chrisdotcode> JoeyA, monochrom: okay, thanks guys. cabal all purged, and yesod installed :)
21:47:28 <monochrom> good good
21:49:32 * hackagebot llvm-general 3.3.0.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.0.0 (BenjaminScarlet)
21:52:31 <slack1256> In the mails about AMP I read about the classes Apply/Bind of edwardk, in which package do they live?
21:53:00 <shachaf> semigroupoids
21:53:02 <slack1256> (sorry hayoo is kind of down :S)
21:53:09 <slack1256> ok
21:56:30 <blackdog> i have a very slow function defined as "newCAString . unpack"
21:57:21 <blackdog> this converts my bytestring to a string, so that it can then turn it back into a CString. This seems insane - is there a better way that doesn't involve detouring through large lists of characters?
21:58:11 <JoeyA> blackdog: Data.ByteString has useAsCString
21:58:15 <blackdog> all the Bytestring -> CString functions seem to want to do it in a scoped way, but i want the string to be kept & freed by the other side
21:58:18 <JoeyA> useAsCString :: ByteString -> (CString -> IO a) -> IO a
21:58:22 <shachaf> blackdog: If "unpack" converts your ByteString to a String, you're using .Char8. :-(
21:58:26 <JoeyA> oh
21:59:11 <JoeyA> blackdog: you can use useAsCStringLen and copy the bytes to a malloc'd buffer.
21:59:11 <blackdog> shachaf: yeah. it's not my library, i'm just trying to patch a performance bug
21:59:26 <JoeyA> But how is it going to be freed?
21:59:40 <shachaf> JoeyA: That still involves two copies...
21:59:56 <blackdog> JoeyA: i think it's already being accounted for.
22:00:02 <shachaf> (And an allocation and all that.)
22:00:05 <shachaf> You could import .Internal and just do it directly.
22:00:08 <blackdog> shachaf: unsafeUseAsCSTtring, maybe?
22:00:10 <JoeyA> You can use unsafeUseAsCStringLen to avoid one of the copies
22:00:22 <shachaf> Oh, true.
22:00:25 <blackdog> shachaf: .Internal?
22:00:41 <shachaf> Never mind, you don't need .Internal.
22:01:03 <JoeyA> Data.ByteString.Unsafe
22:01:13 <shachaf> unsafeUseAsCStringLen + copy should be OK.
22:01:19 <bscarlet_> I it possible to get a cabal package add ghc RTS options to the execution of haddock? I've got a package that makes haddock overflow the default stack.
22:01:24 <JoeyA> copy just returns another ByteString
22:01:28 <JoeyA> oh
22:01:37 <blackdog> so otherwise just Foreign.Ptr to copy the thing directly?
22:01:38 <JoeyA> copy as in an approach, rather than Data.ByteString.copy
22:01:38 <shachaf> Er, not the function "copy". Just copying it.
22:02:27 <JoeyA> Foreign.Marshal.* have some helpful functions for this sort of thing.
22:02:32 <blackdog> Ah, Foreign.Marshal.Utils seems to have copyBytes
22:03:02 <JoeyA> You can use Foreign.Marshal.Alloc.mallocBytes to allocate the bytes.
22:03:45 <JoeyA> The resulting CString can be freed in C or in Haskell using free.
22:03:56 <JoeyA> I thinkl
22:04:27 <shachaf> Yep.
22:04:27 <b6> bscarlet_: you might set the environment variable instead. i think it's GHCRTS?
22:04:31 <JoeyA> mallocBytes is just C's malloc with a null check.
22:05:16 <bscarlet_> b6: That's a thought. Thanks.
22:05:36 <b6> hopefully haddock runs with your env, or cabal passes it on.
22:14:33 * hackagebot air 2013.6.22 - air  http://hackage.haskell.org/package/air-2013.6.22 (JinjingWang)
22:17:21 <olalonde> is there a chan somewhere for general functional programming questions?
22:17:34 <olalonde> or can I ask here even if it's unrelated to haskell?
22:19:15 <hamid> being functional and unrelated to haskell
22:19:33 * hackagebot air-extra 2013.6.22 - air-extra  http://hackage.haskell.org/package/air-extra-2013.6.22 (JinjingWang)
22:19:35 * hackagebot nemesis 2013.6.22 - a task management tool for Haskell  http://hackage.haskell.org/package/nemesis-2013.6.22 (JinjingWang)
22:19:37 * hackagebot nemesis-titan 2013.6.22 - A collection of Nemesis tasks to bootstrap a Haskell project with a focus on continuous integration  http://hackage.haskell.org/package/nemesis-titan-2013.6.22 (JinjingWang)
22:19:39 * hackagebot hack2-contrib 2013.6.22 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2013.6.22 (JinjingWang)
22:19:41 * hackagebot moe 2013.6.22 - html with style  http://hackage.haskell.org/package/moe-2013.6.22 (JinjingWang)
22:23:36 <hamid> olalonde, i'm pretty sure here people don't mind asking only functional questions :P
22:26:13 <Gracenotes> 'what is functional programming' is certainly a good question
22:26:44 <Gracenotes> although, depending on how you ask it, you might get a question back in response, of how you got here :)
22:28:41 <olalonde> I'm trying to rewrite my JS library in a functional style
22:29:22 <olalonde> I have a cache and was not sure how I could implement this in a functional style
22:30:21 <dmwit> olalonde: If the cache is of a pure function, there's half a dozen packages on Hackage for this.
22:30:26 <ijp> a cache isn't inherently against functional programming style, since it only affects efficiency, not the answer
22:30:51 <Gracenotes> in JS, at least, you could use a decorator-type thing.
22:31:44 <Gracenotes> assuming the arguments to a function to cache are serializable
22:31:57 <olalonde> so I guess I could cheat with my cache as long as i make sure the return value of my function is always the same?
22:31:59 <Gracenotes> and you don't care about memory potentially blowing up
22:32:26 <dmwit> If you want to cache something impure, things get more exciting. But also easier, because presumably then you don't mind being inside a monad of some kind.
22:32:27 <olalonde> the cache only lives for a few seconds
22:32:50 <olalonde> dmwit: I'm asking a general functional programming question, not in haskell :(
22:32:57 <dmwit> But then you get to write all the fun cache invalidation code and stuff.
22:33:19 <Gracenotes> there's also the question of if you want to make it generalizable or make it fast
22:33:23 <dmwit> This is not a general functional programming question, because the various functional programming languages take such different approaches to impure bits.
22:33:58 <olalonde> ok
22:34:33 * hackagebot plot 0.2 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.2 (VivianMcPhail)
22:34:52 <olalonde> js isn't a functional language so it's hard for me to tell whether or not im writing in a functional style
22:35:15 <Ralith> olalonde: "functional style" is not incompatible with caching things in a conventional stateful fashion.
22:35:26 <Ralith> just be careful that doing so does not change anything's behavior.
22:35:33 <olalonde> Ralith: ok thanks
22:35:39 <olalonde> will keep in mind
22:35:56 <carter> Ralith i'm bad at ignoring those
22:36:13 <carter> Ralith ooo, cache oblviious stuff is all i doooo
22:36:27 <Gracenotes> in most implementations of JS, a lot of the optimization is of constant-time things, since in most applications you can't improve asymptotic complexity usually
22:36:38 <Ralith> carter: it's not always easy to distinguish between 'misguided but earnest' and 'not interested in learning'
22:36:47 <Ralith> also
22:36:52 <Ralith> where does the term "cache oblivious" come from, anyway
22:36:55 <carter> oooo
22:37:00 <carter> lemme link you
22:37:00 <Gracenotes> it turns out that functional programming in JS makes constant-time things a bit slower
22:37:02 <Ralith> it always makes me think exactly the wrong thing
22:37:19 <carter> http://supertech.csail.mit.edu/papers/Prokop99.pdf http://erikdemaine.org/papers/BRICS2002/paper.pdf
22:37:23 <Gracenotes> Ralith: what does it make you think?
22:37:25 <carter> "cache oblvious optimal"
22:37:30 <carter> is what people really mean
22:37:42 <cl1> :t (++)
22:37:43 <lambdabot> [a] -> [a] -> [a]
22:37:45 <Ralith> Gracenotes: "designed without any consideration of the cache"
22:37:57 <cl1>  > show 0 ++ " - " ++ "ab cd ef"
22:38:01 <Gracenotes> ah. yes. or cache-size oblivious, is what I think
22:38:17 <carter> Ralith idea is "you have essentially the optimal number of loads and stores"
22:38:24 <Ralith> carter: I've actually got the former of those in my papers dir already, hah
22:38:26 <cl1> > 0 ++ " - " ++ "ab cd ef"
22:38:26 <carter> across the multiple levels of cache
22:38:27 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
22:38:27 <lambdabot>    arising from the literal ...
22:38:37 <Ralith> didn't spend much time looking through it yet though
22:38:45 <carter> withouth needing to tune the parameters   / know what sizes the caches are
22:38:59 <Ralith> I think I see
22:39:05 <carter> Ralith i've a sequential untuned cache obvlious mat mult thats within 2x of openblas
22:39:11 <carter> well, sequential open blas
22:39:12 <cl1> how come show 0 ++ " - " ++ "ab cd ef" works if (++) :: [a] -> [a] -> [a]
22:39:18 <Ralith> so optimal for hierarchical caches as a class, rather than subject to particular parameters (of which it is in fact oblivious)
22:39:21 <carter> that has a really untuned loop in haskell
22:39:27 <carter> yess
22:39:31 <carter> yes
22:39:42 <carter> asmptotic number of loads stores matches optimal
22:40:28 <carter> cache optimal stuff gets more subtle once you add prefetching to the model
22:41:25 <roboguy_> olalonde: it seems to me that it's better to write in a style that is idiomatic for the language you're working in. so rather than worrying about whether it's functional or not, I would worry about the code being nice
22:41:25 <carter> you want to maximize the fraction of the time the prefetcher is pulling stuff down speculative that you'll actually look at
22:41:30 <roboguy_> and maybe it's functional, maybe it isn't
22:41:34 <Gracenotes> many cache-oblivious algorithms are divide-and-conquer-looking to me
22:41:39 <carter> Gracenotes INDEED
22:41:44 <carter> they are
22:41:45 <Gracenotes> which is not normally a strength of cached code, done naively
22:41:54 <carter> cached in what sense?
22:41:56 <Gracenotes> er, cached data
22:42:19 <carter> Gracenotes http://en.wikipedia.org/wiki/Z-order_curve
22:42:29 <carter> is a nice recursive layout
22:42:41 <carter> that lets you do matrix block decompositionwith nice locality
22:42:59 <olalonde> roboguy_: I don't know. I've found that functional javascript libraries are very elegant and easy to read
22:43:09 <carter> my fancy mat mult thats untuned uses the Z and upsidedown N order curves
22:43:13 <Gracenotes> carter: ah, that looks pretty planar to me
22:43:19 <olalonde> roboguy_: but there aren't many so I guess it's not very idiomatic
22:43:32 <carter> Gracenotes recursively split it into the 4 quadrants
22:43:50 <carter> and do matrix mult per quadrant, recursively
22:43:53 <carter> down to some base size
22:44:02 <Gracenotes> ah. I see
22:44:10 <olalonde> roboguy_: I mostly just want to learn some functional programming and doing it in JS because I still need got work to do :)
22:44:27 <Gracenotes> so division may not be strictly cache-friendly... you may need some transformation first
22:44:27 <Ralith> CS can be so entertaining
22:44:35 <roboguy_> olalonde: well, if that's how it works best then that's how you should do it. I'm just saying that functional isn't *always* the best in all languages and all situations. haha, maybe that's not a super popular opinion here, but there you have it
22:44:40 <carter> Gracenotes nope! look at that curve order
22:44:42 <roboguy_> olalonde: for learning that might be good too, actually
22:44:48 <Ralith> "Z order curve? Hm, I bet the Z refers to a specific special class of curves, or has some subtle meaning"
22:44:53 <carter> yes
22:44:54 <Ralith> "oh wait no it just literally looks like a Z"
22:45:00 <carter> yes
22:45:04 <carter> :)
22:45:05 <olalonde> roboguy_: alright. yes, I bet that opinion will not be popular here :)
22:45:11 <carter> its a fractal of Z's
22:45:17 <carter> draw a z,
22:45:29 <carter> replace each vertex / endpoint with a Z
22:45:31 <carter> RECUR
22:45:32 <Ralith> anyway this is pretty neat
22:45:43 <carter> theres some tricks to make it work with not power of 2 sized things
22:45:44 <Gracenotes> I mean, I'd imagine this would be mainly useful with very very large matrices
22:45:51 <Gracenotes> ...as recursive matrix operations usually are
22:45:51 <Ralith> eh, who needs those
22:45:53 <olalonde> roboguy_: I guess when I am any good with functional programming at least I will be able to recognize where it's a good fit
22:45:58 <carter> Gracenotes it does decently on Even small stuff
22:46:22 <Gracenotes> hm. not bad.
22:46:33 <carter> the constant factor gets a wee bit better on larger stuff
22:46:54 <carter> the trick is I wrote a 4x4 and 8x8 and 16x16 kernel in SIMD C
22:46:58 <carter> and i do that at the bottom
22:47:25 <carter> i've some tricks for defunctionalizing it and making it represent the recursion using a fixed buffer / array i'll allocate
22:47:34 <carter> that i'll be trying over the next week
22:47:36 <roboguy_> olalonde: when you say caching, what do you mean? memoization can fit functional pretty well
22:47:57 <Gracenotes> yes. even e.g. timsort takes the tack of mergesort on big things, insertion sort on small
22:48:13 <olalonde> roboguy_: it's a bit long story but yes, pretty close to memoization
22:48:19 <Gracenotes> you could probably do well with sorting networks on small things
22:48:28 <carter> Gracenotes maybe
22:48:29 <olalonde> roboguy_: I'll come back here if I need help :)
22:48:37 <Gracenotes> all in all, the obvious conclusion that recursion has overhead :p
22:48:53 <Gracenotes> in an otherwise imperative setup
22:49:50 <carter> Gracenotes to be fair, matrix mult engineering really stresses the perf of any modern cpu
22:50:01 <carter> in that its sensitive to so many things
22:50:09 <carter> and is really memory bus bound
22:51:33 <carter> like, the performance of the best mat mults on decent CPU's is within 10percent of theoretical peak throughput
22:51:42 <carter> ish
22:51:43 <carter> i think
22:52:06 <carter> i'll be messing aroudn with mat mult code gen via llvm in another month or so
22:52:14 <carter> C gets stale fast :P
22:53:23 <Gracenotes> llvm gets dem loops pretty well, eh
22:53:50 <carter> Gracenotes more like i can also maybe do FFTW like "try all the code lets"
22:53:53 <carter> *codelets
22:54:01 <carter> but that too
22:54:07 <carter> clang actually makes C ok
22:54:08 <carter> ot use
22:54:16 <carter> has *HELPFUL* error messages
22:54:31 <carter> Ralith knows i don't understand C++ stack traces
22:54:39 <carter> at least after 2am
22:54:45 <Ralith> well, now I do anyway
22:54:45 <Gracenotes> stack?
22:55:09 <carter> Gracenotes for the recursion?
22:55:11 <carter> oh c++
22:55:23 <carter> gcc + clang stdlibs had a fight last night
22:55:27 <carter> it made me confused
22:55:38 <carter> dont ask
22:55:56 <carter> well, basically xcode 5 dev has no gcc
22:56:02 <Gracenotes> the only stack traces I've seen are in gdb
22:56:05 <carter> old apple gcc is too old to support simd
22:56:14 <carter> so i have my own gcc 4.8 build on my machine
22:56:24 <carter> and it and clang made sad
22:58:11 <roboguy_> carter: isn't there an option to install the command line tools package, which i think comes with gcc?
22:58:27 <carter> roboguy_ i'm talking about the CLI tols
22:58:32 <carter> the apple GCC is OLD
22:58:35 <roboguy_> oh
22:58:44 <carter> and xcode 5 gcc is actually just clang wrappered
22:58:47 <carter> shhhh
22:59:05 <carter> you just know that because you also have xcode 5 dev preview of course
22:59:16 <roboguy_> hmm
22:59:39 * hackagebot hack2-contrib-extra 2013.6.22 - Hack2 contrib extra  http://hackage.haskell.org/package/hack2-contrib-extra-2013.6.22 (JinjingWang)
22:59:40 <carter> but i've been using gcc 4.8 for a while
23:00:17 <carter> apple gcc-4.2 doesn't understand -march=native
23:00:20 <carter> and other fun things
23:01:24 <carter> Ralith is that dude still on the idris channel?
23:01:38 <Ralith> I don't think he's going anywhere in the short term
23:01:43 <carter> damnit
23:02:06 <carter> is it wrong that if i had op i'd ban or kick him? i never want to do that
23:03:10 <b6> carter: heh. what'd he do?
23:03:11 <carter> Gracenotes anyways, point being: thers some overhead for gcing and thigs, but you can totally write good cache oblivous optimal codes
23:03:12 <Ralith> if he's boastful of being banned from #haskell and #clojure I'd call it reasonable preventative action >_>
23:03:35 <carter> b6 no one makes me pissed, he did
23:03:39 <Ralith> b6: "Hi, so dependent types are basically exceptions right? No you're all wrong they totally are."
23:03:40 <carter> annoyed, yes
23:03:50 <b6> heh, ok. i know that type of person.
23:03:50 <carter> he also mentioned the holocaust
23:04:01 <carter> that was the line crosser
23:04:15 <carter> ANYWAYS
23:04:21 <carter> anyone started reading HOTT yet?
23:04:45 <b6> no. what is it?
23:05:13 <carter> https://github.com/HoTT/HoTT a book that explains homotopy type theory in a informal but mathy way
23:05:24 <carter> wait, wrong repo
23:05:36 <carter> https://github.com/HoTT/book
23:05:39 <carter> http://golem.ph.utexas.edu/category/2013/06/the_hott_book.html
23:05:41 <carter> http://homotopytypetheory.org/2013/06/20/the-hott-book/
23:05:42 <b6> thanks.
23:06:03 <carter> somehow its "informal type theory"
23:06:12 <carter> i need to read it to know what they mean by informal :P
23:06:54 <b6> let's just lean back, put our feet up, feel the breeze, and lay out 200 lemmas
23:07:09 <b6> (we are all wearing jeans)
23:08:54 <dmwit> With a name like "homotopy type theory", I feel informal is going to be a bit of a stretch.
23:09:05 <carter> dmwit no clue
23:09:08 <Ralith> heh
23:09:45 <Ralith> carter: skimming the links, it looks like they mean "automatically verifiable (and thus necessarily fully formalized) proofs, accompanied by intuitive explanations"
23:10:00 <Ralith> but you've read those too so I'm probably not adding anything
23:10:15 <carter> KILL THE WITCH
23:10:18 <Ralith> oh my god
23:10:25 <Ralith> they've got a kindle sized pdf
23:10:25 <carter> magical proofs
23:10:26 <Ralith> :O
23:10:32 <carter> and a lulu print
23:10:38 <Xunie> How often is recursion used in Haskell to solve practical problems? Is it encouraged or discouraged?
23:10:46 <carter> Xunie its good
23:10:53 <Xunie> What about the stack?
23:10:55 <carter> and tail calls to known functions are fast
23:10:59 <Gracenotes> recursion is good if you want turing-completeness
23:11:07 <carter> Xunie i have REALLY fast code that uses the stack for recursion
23:11:24 <Gracenotes> Haskell doesn't have a stack in the same way that languages like C and Java do
23:11:27 <carter> like, its within 2x of the fastest similar sequential fortran  / c codes i know
23:11:41 <Xunie> Gracenotes, yeah, I'm a Haskell noob. Let it be known!
23:11:44 <carter> Gracenotes except when you write really strict code
23:11:45 <carter> :)
23:11:59 <carter> Xunie for now you're going to struggle with perf, and thats ok
23:12:14 <Ralith> Xunie: basically, you shouldn't need to worry about it for a long time.
23:12:15 <carter> because the best ways fo getting good perf robusly in a large system with haskell
23:12:17 <dmwit> Okay, so "informal" means "100% formalized". Nice.
23:12:21 <carter> is to write high level code
23:12:26 <carter> dmwit wait.. really?!!?!
23:12:26 <dmwit> This is the kind of informal I can get behind!
23:12:37 <carter> dmwit wheres it say taht?
23:12:46 <dmwit> carter: That's my interpretation of Ralith's claim from three minutes ago...
23:12:51 <Ralith> dmwit: I think the point is it has informal accompaniment, instead of being just a mostly-formal proof
23:12:53 <Gracenotes> you can definitely translate an algorithm in Java/C to similar-looking Haskell, though, and get similar performance
23:13:02 <Gracenotes> or better
23:13:16 <carter> Gracenotes that too
23:13:19 <Ralith> I quote:
23:13:22 <Ralith> "fully formal proofs that can be run on the computer to ensure their absolute rigor, accompanied by informal exposition that can focus more on the intuition and examples"
23:13:25 <Gracenotes> As long as basic idioms are respected :)
23:13:29 <Xunie> [08:11:39]<carter> [...]you're going to struggle with perf, [...]
23:13:37 <Xunie> 'perf'?
23:13:39 <carter> Xunie you don't know the language well yet
23:13:45 <carter> so you'll have some weird bad performance sometimes
23:13:47 <carter> and thatsok
23:14:11 <carter> thats true with every language, its just you will actualy notice it more with new haskeller code
23:14:12 <Xunie> Oh, performance. Alright. Thanks for the headsup on me writing inefficient code.
23:14:17 <carter> Xunie and its ok
23:14:39 <carter> good perf in a system built with haskell is from having good abstractions that composably give good perf
23:14:44 <b6> speaking of performance, i do cabal configure --enable-library-profiling and --enable-executable-profiling as appropriate, but ./mybin +RTS -p reports it wasn't built with -prof.
23:14:52 <carter> b6 cabal clean
23:14:54 <carter> is your friend
23:15:03 <b6> i did, like a million times. is there anything else?
23:15:05 <Xunie> I didn't start learning Haskell for the speed. I'm learning it to broaden my horizons and the fact that I don't know an academic language like Haskell yet.
23:15:11 <carter> Xunie your'e doing it right :)
23:15:16 <Ralith> well, not quite right
23:15:22 <Ralith> if he wants to learn an academic language, he should learn agda!
23:15:23 <Ralith> :D
23:15:24 <carter> theres actually a few neat companies using haskell for hard core problems
23:15:26 <b6> Xunie: i don't think of haskell as academic. i use it for industrial strength.
23:15:38 <carter> it has probaby one of the best engineered runtime systems around
23:15:46 <carter> ghc source is actually redable
23:15:49 <carter> worth doing
23:16:01 <Ralith> Xunie: I'm aware of more use of hsakell for practical purposes than for research.
23:16:03 <carter> yes
23:16:11 <carter> but its great for either
23:16:37 <carter> once you're more comfortable
23:16:52 <Gracenotes> did you see that fp complete video? pretty good sales pitch...
23:17:11 <dmj> i liked that video :)
23:17:12 <carter> my sales pitch is cooler than whatever theirs is :P
23:17:15 <carter> i should watch it
23:17:21 <carter> aaron with a beard vid?
23:18:12 <carter> i'm commercializing haskell too
23:18:25 <carter> but for math rather than websites
23:18:55 <carter> "new programming language… thats been in development for 20 years"
23:19:01 <Gracenotes> heh yeah
23:19:19 <carter> it is articulate though
23:19:54 <carter> i do like to point to the pending AMP proposal as an example of how Haskell makes it feasible to make breaking changes bug free
23:21:22 <carter> ok, its a pretty solid general audience video
23:21:25 <carter> i'd do worse :P
23:21:38 <carter> there was a picture of spaghetti for the spaghetti code
23:21:51 <dmj> :)
23:22:08 <carter> he's not mentioning how haskell has a really nice C ffi
23:22:26 <Ralith> AMP proposal?
23:22:30 <Gracenotes> it's implied a bit toward the end
23:22:43 <carter> Applicative m => Monad m
23:22:44 <carter> finally
23:22:51 <carter> AGIAIN
23:23:13 <carter> old haskell from like 20 years ago has that
23:23:19 <carter> but H98 took it away
23:23:39 <roboguy_> carter: why?
23:23:55 <carter> because it confused the poorly taught students
23:23:57 <carter> or soething
23:24:05 <roboguy_> ahh
23:24:17 <carter> the only people who were against AMP were folks who were like "but then I can't use the same teaching materials exactly"
23:24:22 <carter> which kinda means they're shitty teachers
23:24:30 <Ralith> heh
23:24:35 <carter> the great teachers Fiddle and tune and change things up
23:24:40 <roboguy_> yeah
23:25:26 <carter> i need to bother a friend, my talk from haskell meetup last month isn't up yet
23:25:40 <Gracenotes> nowadays, any monad tutorial worth its salt that takes the monads-as-computation angle should talk about functor and applicative first
23:26:50 <carter> hehe, while some instructors / TAs argued against AMP, no author of a monad tutorial was sayin no
23:36:05 <dmj> Does anyone have any book recommendations on an independent study in haskell? I was thinking of going with this guy: http://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383/ref=sr_1_2?ie=UTF8&qid=1371882897&sr=8-2&keywords=functional+programming+algorithms
23:37:01 <carter> i've heard good tings
23:37:04 <carter> but haven't looked
23:37:35 <Ralith> dmj: what's your background? Any reason not to use something like LYAH?
23:38:21 <paintcan> dmj: it is a lovely book, but it is dense reading for a novice (my own experience)
23:39:20 <carter> yeah, if you're just starting out… LYAH is probably much better
23:39:33 <carter> ooo, do the computational bits of HTDP2E in haskell
23:39:41 <carter> or just lyah
23:40:20 <dmj> Ralith: Gone through a good amount of LYAH, want to go into deeper waters. Either with algorithms, monad transformers or concurrency
23:40:40 <carter> dmj the simon marlow book is out!
23:40:47 <carter> THAT ONE
23:40:51 <dmj> realllly :) !!
23:40:52 <carter> its also free online
23:41:06 <carter> i read the survey document its based upon
23:41:24 <carter> really nice overview of all the diferent ways of looking at concurrency and parallelism on multicore machine
23:41:36 <carter> that happens to use haskell code that works as the examples
23:41:49 <carter> look at the Online verision first
23:41:52 <dmj> It says August 1st on Amazon. Is his paper the same?
23:42:44 <dmj> http://community.haskell.org/~simonmar/par-tutorial.pdf
23:43:02 <carter> theres also an online version of the book you can read now
23:43:07 <carter> the par tutorial has lots
23:43:12 <carter> probably the online book has more polish
23:43:23 <carter> http://ofps.oreilly.com/titles/9781449335946/
23:43:53 <carter> the asssociated code in the GHC runtime system is very readable C too
23:45:16 <carter> as far as such things are readable
23:46:36 <carter> dmj intersting book yes/no?
23:47:00 <carter> there probably some cool stuff thats more chewable or different subject domain too
23:47:33 <b6> an ffi idiom seems to be, when you register a callback, you store the function pointer in an ioref. is this to keep a reference to it around?
23:47:48 <carter> b6 link to code in question?
23:48:16 <dmj> carter: very interesting. The distributed computing seems intriguing. I have an idea for a database solution, would be cool if it could be distributed
23:48:31 <carter> dmj look at github.com/analytics/analytics
23:49:01 <b6> carter: well, take a look at https://github.com/bsl/GLFW-b/blob/master/src/Graphics/UI/GLFW.hsc , storeCallback
23:49:01 <carter> edwardk is working onwriting a db
23:49:22 <carter> https://github.com/bsl/GLFW-b/blob/master/src/Graphics/UI/GLFW.hsc#L1085 ?
23:49:36 <carter> you can click on a gh line number so its in the link so you jump to the stop
23:50:03 <carter> b6 no clue
23:50:15 <b6> carter: ah, sorry.
23:50:21 <carter> GUIs have many different styles
23:50:28 <blackdog> carter: heya
23:50:28 <carter> i've never done gui stuff
23:50:32 <carter> blackdog YOURE HERE
23:50:34 <carter> hello
23:50:45 <carter> i'm just nerd sniping the younguns
23:50:47 <blackdog> just improved performance on hyperdex bindings by two orders of magnitude :)
23:50:49 <carter> i'm a youngun
23:50:50 <carter> OOO
23:50:56 <carter> you have bindings
23:50:59 <carter> or your own level db?
23:51:09 <carter> link to bindings?
23:51:20 <carter> https://github.com/sbillig/hyperdex-haskell/blob/master/hyperdex.cabal ?
23:51:26 <blackdog> carter: https://github.com/AaronFriel/hyhac/pull/4
23:51:38 <blackdog> you'll laugh when you see it
23:51:39 <carter> woot
23:51:47 <blackdog> have a look at the change
23:51:48 <carter> hehe
23:51:54 <carter> copy meeee
23:52:35 <carter> i need a better fixed width font default in my browser, the L looks like a 1
23:52:44 <b6> terminus.
23:53:20 <blackdog> carter: so hyperdex is fast as greased lightning now
23:53:25 <carter> cool
23:53:30 <carter> how're you liking ti?
23:53:35 <carter> i like the author
23:53:37 <blackdog> and still two orders of magnitude faster than cassandra
23:53:39 <carter> seems like a cool ddue
23:53:41 <blackdog> which is what i'm actually using.
23:53:44 <blackdog> le sigh.
23:53:47 <carter> ahhh
23:53:55 <blackdog> so i think i might just rewrite to back onto cassandra instead
23:53:58 <blackdog> uh, hyperdex
23:54:12 <blackdog> yeah, emin, right? was a clinical dissection of mongo's flaws.
23:54:23 <dmj> carter: the db I have uses a SQL-like DSL to manipulate stuff in memory, saves it to disk with acid-state. Underlying data structure is haskell lists...
23:54:29 <carter> ah
23:54:30 <carter> neat
23:54:32 <carter> cool
23:54:39 <carter> lists are good for sequential streams
23:54:44 <carter> not so much random access
23:54:51 <carter> unless you did a sort of skip lists overlay
23:54:58 <carter> or something
23:54:58 <carter> idk
23:55:32 <dmj> carter: Yea, a map may have been a better choice. Also figuring out how to use lenses to perform updates when dealing with lists that contain lists and so on.
23:55:47 <dmj> Actually, one sec, I'll put the code on github
23:55:52 <carter> dmj i used lenses for the first time last week
23:56:03 <carter> most of what i do isn't lensy optimized
23:56:11 <carter> either perf or "natural way to say it"
23:56:26 <carter> but mucking with cabal configuration is Setup.hs is a very lensy thing
23:56:34 <Lethalman> huh is that hyperdex written in haskell?
23:56:45 <carter> Lethalman nope… i think he meant a binding
23:56:50 <Lethalman> :(
23:56:51 <carter> no reason why couldn't have a haskell port though
23:57:09 <dmj> carter: Ha I thought I was the only one. I'm doing some crazy stuff with records trying to get it all to work
23:57:40 <carter> dmj heres how I made it sane (and then kmett out did me with a mini version of his lense stuff)
23:57:52 <carter> https://gist.github.com/cartazio/5777579
23:57:56 <carter> the simple one is mine
23:58:07 <carter> the generic one that lets you have effects and shorter notation isn't mine
23:58:57 <carter> Lethalman that said, theres so many other cool things that would have more impact on the haskell community
23:59:03 <carter> but it'd be a fun project
23:59:22 <Lethalman> carter, imo the thing that would impact most is a killer gui application
23:59:32 <carter> Lethalman you mean more guil libs?
23:59:41 <Lethalman> carter, gui _application_
23:59:46 <carter> thats many of those :P
23:59:49 <carter> soooo many
