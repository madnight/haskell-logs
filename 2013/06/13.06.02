00:04:35 * hackagebot embeddock-example 0.1 - Example of using embeddock.  http://hackage.haskell.org/package/embeddock-example-0.1 (TakayukiMuranushi)
00:11:58 <latermuse> what is the best MD5 library for haskell?
00:12:05 <latermuse> I want to get the md5 of a ByteString
00:21:31 <Hermit> latermuse: I'm doing it with a foreign call to openssl
00:21:38 <Hermit> pretty damn fast and simple
00:23:52 <latermuse> i just found the puremd5 library and it works well too
00:29:35 * hackagebot type-natural 0.0.1.0 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.0.1.0 (HiromiIshii)
00:32:00 <latermuse> whats the correct way to pack a string into a bytestring?
00:32:38 <latermuse> Word8 conversion
00:33:00 <shachaf> That depends on the encoding you want to use.
00:33:02 <shachaf> But probably UTF-8.
00:33:27 <shachaf> (There's no Char <-> Word8 correspondence -- Word8 isn't big enough. So at least some Chars need to turn into multiple Word8s.)
00:39:01 <paullik> Hi. I wrote two versions of a function to get a new list with some element at a certain index replaced, now I'd like to know which one is more optimal, more readable and why: http://hpaste.org/89115
00:39:51 <shachaf> Instead of using tail you should pattern-match.
00:40:03 <shachaf> I.e. (left, _:right) = ...
00:40:05 <dmwit> I prefer the first, but I would write the RHS as left ++ [newElem] ++ drop 1 right
00:40:20 <shachaf> And of course it could be empty.
00:40:33 <shachaf> So maybe dmwit's version is better.
00:40:42 <dmwit> (left, drop 1 -> right) = splitAt index xs -- ;-)
00:41:07 <paullik> dmwit, why would you rewrite it, I want to learn something, not just: this is how you do it
00:41:14 <shachaf> Eh. When you're reduced to using a function I don't care where you use it so much.
00:41:27 <dmwit> I would rewrite the : to ++ because I like symmetry, and I would use drop 1 instead of tail because it is total.
00:41:38 <dmwit> I prefer the first to the second because it reuses already-written library functions.
00:41:57 <shachaf> It's sad how drop 1 doesn't get optimized into a simple pattern match but stays a recursive thing.
00:42:01 <paullik> dmwit, "it is total", what is this?
00:42:05 <dmwit> > tail []
00:42:07 <lambdabot>   *Exception: Prelude.tail: empty list
00:42:08 <dmwit> > drop 1 []
00:42:10 <lambdabot>   []
00:42:16 <shachaf> That means it doesn't crash when you give it an empty list.
00:42:21 <paullik> oh, nice
00:42:51 <shachaf> You should avoid functions like head/tail/fromJust/etc. whenever you can because of that.
00:42:58 <paullik> you also wrote this: (left, drop 1 -> right) = splitAt index xs
00:43:00 <paullik> what is
00:43:00 <dmwit> (That is to say: I prefer the first to the second because I don't have to pay careful attention to your recursion to make sure there's no subtle bug.)
00:43:02 <paullik> ->
00:43:06 <paullik> what is "->" ?
00:43:10 <dmwit> That's a view pattern.
00:43:12 <shachaf> It's an extension to Haskell called ViewPatterns.
00:43:15 <dmwit> That suggestion was tongue-in-cheek.
00:43:21 <dmwit> I do not seriously recommend using that here.
00:43:35 <paullik> oh, ok, I;ll read about it
00:43:40 <dmwit> But the idea of view patterns is that they let you pattern match not on the value of a thing but on what you get from applying a function to the value of a thing.
00:44:38 <paullik> ok
00:44:49 <paullik> thank you shachaf, dmwit
00:49:36 * hackagebot type-natural 0.0.1.1 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.0.1.1 (HiromiIshii)
00:53:18 <latermuse> i always just rewrite the head/tail/fromjust functions into something that wont crash when I need it for a specific purpose
00:53:31 <latermuse> very situational though
00:59:37 * hackagebot type-natural 0.0.2.0 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.0.2.0 (HiromiIshii)
01:08:15 <tdammers> latermuse: import Safe; then tailSafe / headMay / headDefault
01:08:33 <latermuse> ohh thats convenient. thanks tdammers
01:14:37 * hackagebot sized-vector 0.0.2.0 - Size-parameterized vector types and functions.  http://hackage.haskell.org/package/sized-vector-0.0.2.0 (HiromiIshii)
01:27:47 <paullik> Hi again, I implemented a simple backtracking sudoku solver just to get familiar with the language and I'd like some advice regardin the code if it's possible: https://github.com/paullik/sudoku-solver/blob/master/SudokuSolver.hs
01:34:37 * hackagebot free-game 0.9.3.3 - Create graphical applications for free  http://hackage.haskell.org/package/free-game-0.9.3.3 (FumiakiKinoshita)
01:56:32 <krsrk> If I have some structures that I initiate when my program is starting, should I construct them in main block, or outside of main block?
01:58:02 <krsrk> or if my question was unclear, please tell me, I try to give an example
01:58:24 <shachaf> I say give an example anyway.
02:00:21 <Heffalump> krsrk: do the structures require IO?
02:01:35 <krsrk> http://hpaste.org/89119
02:02:00 <krsrk> Heffalump: not directly
02:02:14 <krsrk> The IO part is done before and after
02:03:24 <krsrk> I'll be using the field in some function called from main
02:04:10 <krsrk> I'm not really familiar with scopes in HS, so I'm not sure how it behaves with both cases.
02:04:19 <Heffalump> if it doesn't require IO then put it outside main like you've done in your hpaste
02:04:43 <Heffalump> unless you think you mighht want to clean up the memory it uses at some point, in which case you need to make it inside main so you can clean up the reference
02:05:17 <Heffalump> oh, but when you say you'll update the board later, then you need to put it in an IORef and initialise it in main or something mani calls
02:05:22 <Heffalump> otherwise you won't be able to update it
02:07:33 <krsrk> After every game step the tiles changes indeed, but in haskell, I assume, I'll construct a new tiles based on old one every time... not sure how to update existing field.tiles though
02:09:02 <Heffalump> that's what an IORef is for
02:09:15 <Heffalump> the initial fields for a new game can live outside main as you've done
02:10:05 <jesyspa> Why would an IORef be preferable to the State monad here/
02:10:28 <shachaf> I wonder why people say "the State monad" instead of "State".
02:10:35 <shachaf> They say "Maybe", after all.
02:10:39 <krsrk> There are no rules, I would prefer any haskelly-way to do it
02:10:47 <jesyspa> I was concerned there may be another thing called State.
02:11:08 <shachaf> Let's hope the other thing isn't a monad too. :-)
02:11:15 <Heffalump> jesyspa: good point, I was being sloppy
02:11:26 <Heffalump> a State monad would be preferable to an IORef in general
02:11:34 <jesyspa> Though I guess "the State monad" isn't all that correct, State not being a monad. :P
02:12:40 <Heffalump> shachaf: I would use 'monad' because it carries the implication of using do-notation/the monad operations to work with it, which I think are a good thing
02:13:56 <krsrk> so I should hoogle State?
02:14:06 <tdammers> Control.Monad.State
02:14:23 <Heffalump> krsrk: or lookup "state monad" in a monad tutorial of your choice
02:14:49 <tdammers> also, if you want stateful computations and you're in IO anyway, consider StateT IO
02:15:09 <krsrk> Thanks for your suggestions, I'll read some material...
02:15:14 <Ralith> if you want stateful computations and you're in IO anyway, consider IORef :P
02:15:58 <shachaf> Ralith: Or consider not "being in IO".
02:16:28 <Ralith> shachaf: of course.
02:16:33 <Ralith> StateT IO just seems doubly silly
02:16:43 <latermuse> IO StateT IO ()
02:16:46 <latermuse> hngg
02:16:56 <shachaf> It's pretty different from an IORef, though.
02:17:00 <shachaf> For example, concurrency.
02:17:06 <shachaf> Better than reading a "monad tutorial" would be to use s -> (s,a) functions yourself for a while.
02:17:06 <Ralith> true
02:18:19 <krsrk> In the end I want to "walk" somehow that 2-dimensional tiles list, from bottom, 1-3 rows at once, and update the tiles list (or construct a new one - but then update field.tiles, to have access to the new tiles later on)
02:18:31 <tdammers> the State part in StateT is just a monadic wrapper over pure code that passes the state around and updates it as you go (the s -> (s, a) thing)
02:18:39 <tdammers> IORefs are more "magical"
02:18:57 <tdammers> with impure state updates that actually live in IO
02:21:31 <Aetherspawn> gh
02:21:33 <Aetherspawn> *ugh
02:21:36 <Aetherspawn> dependancy hell again
02:21:51 <Aetherspawn> But this time, its on hackage and I can't do anything about it
02:22:45 <Aetherspawn> stm-chans recently update to 3.0 which adds broadcast chans which is great but stm-conduit and friends still have == 2.0.0 in their cabal file
02:24:08 <shachaf> Is there a way to say "I promise package X version V is compatible with package Y version W, despite what its dependency says"?
02:24:20 <shachaf> In .cabal/config or something like that.
02:24:50 <shachaf> When I'm sure about it and a package hasn't been updated, I sometimes cabal unpack and change the .cabal manually. But I feel horrible about it.
02:32:52 <krsrk> I though a bit about it, and instead of using state, I simply give the tiles as argument, works for my case.
02:33:40 <shachaf> Even better!
02:34:06 <shachaf> Control.Monad.State really just means "functions that take the old state as an argument and return the new state as a result".
02:34:49 <krsrk> random question: do you keep type definitions in the top of your code, or keep them where they are first used?
02:34:57 <krsrk> e.g type aliases
02:35:14 <Cale> Wherever makes the most sense
02:35:38 <Cale> Usually immediately preceding the most important stuff for working on the newly defined type.
02:36:14 <shachaf> I,I put them in their own modules, call them all T
02:36:22 <shachaf> (Don't do this.)
02:36:40 <lmfdvsu> what is cumulative universe and what is Universe polymorphism? I am just aware of the concept of kind polymorphism and higher kinds
02:37:11 <lmfdvsu> I have no notion of universe, kindly enlighten me
02:37:41 <Cale> Is this #agda? :)
02:37:52 <lmfdvsu> I saw posts about haskell and agda , where this was brought up
02:38:06 <lmfdvsu> sorry :(
02:38:13 <Cale> Nah, it's cool
02:39:44 <Cale> lmfdvsu: So, in Haskell we have values, types, and kinds
02:40:24 <lmfdvsu> Cale: yup
02:41:20 <Cale> lmfdvsu: So, it might make some kind of sense to extend this forever
02:42:10 <lmfdvsu> ok, what you mean by that, a type for a kind?
02:42:14 <Cale> yes
02:42:24 <lmfdvsu> and its type and so on ..?
02:42:25 <Cale> Of course, it sucks to keep coming up with new names
02:42:27 <Cale> yeah
02:42:37 <Cale> So, we'd start indexing these with natural numbers or something
02:42:38 <savask> "flavor"
02:43:14 <Cale> and then certain code might work at an arbitrary level -- it might be parameterised over that natural number index
02:43:24 <lmfdvsu> so instead of calling a, as a kind, you say universe[2]?
02:43:27 <Cale> and that's universe polymorphism, vaguely :)
02:43:51 <Cale> I believe in Agda, they use Set n, for each natural number n
02:44:19 <bitonic> yep, in Agda (and in most places) the hierarchy is indexed by the natural numbers
02:45:31 <savask> Cale: GHC has different kinds of kinds (a special kind for an unboxed value) - is it something like you were describing?
02:45:50 <Cale> savask: Well, those are still kinds
02:46:02 <lmfdvsu> two questions : one aren't higher-kinds enough? whydo we need a hierarchy of  type-stuff?
02:46:09 <bitonic> lmfdvsu: the idea is that type constructors will maintain the hierarchy by 1. taking the least upper bound of the type arguments 2. having the data constructors to have ‘smaller’ sets as arguments.  if that doesn’t happen you can prove falsity, which is not nice
02:46:10 <Cale> savask: However, there is (->) at the kind level in GHC
02:46:40 <savask> Cale: Eh, I have thought that (->) is a type.
02:46:40 <bitonic> lmfdvsu: ‘higher kinds’ are a hierarchy, if I’m not misunderstand what you mean by that
02:46:49 <Cale> Well, (->) is also at the type level
02:46:54 <savask> Ah
02:46:56 <Cale> But for example
02:47:00 <Cale> :k (->)
02:47:00 <savask> * -> *
02:47:01 <lambdabot> * -> * -> *
02:47:13 <Cale> yeah
02:47:20 <savask> Same way to show different things...
02:47:36 <lmfdvsu> Cale : how exactly you parameterize over natural numbers?
02:47:55 <lmfdvsu> just pass a list of natural numbers to a function? In agda??
02:48:09 <bitonic> lmfdvsu: ‘Set’, which is somewhat close to Haskell’s *, takes a natural.  e.g ‘Set 1’
02:48:21 <bitonic> bind: so you have that ‘Set 0 : Set 1 : Set 2 : ...’
02:48:25 <bitonic> sorry, lmfdvsu...
02:48:44 <Cale> Set 0 would be what you might normally think of as types, and then Set 1 would be their kinds, and so on.
02:48:58 <lmfdvsu> ok
02:49:03 <bitonic> then you can have functions that quantify on those numbers, e.g. ‘foo : forall a b. Set a -> Set b -> ...’
02:49:44 <lmfdvsu> where a and b are index lists or sequences?
02:49:57 <bitonic> lmfdvsu: ‘a’ and ‘b’ are naturals basically
02:49:59 <lmfdvsu> or just numbers.
02:50:01 <lmfdvsu> ??
02:50:09 <lmfdvsu> ok, I got it!
02:50:23 <bitonic> lmfdvsu: you should try to get some intuition on why this is important
02:50:33 <bitonic> e.g. what would happen if ‘Set 0 : Set 0’
02:50:56 <lmfdvsu> bitonic: may be you can motivate me a bit ?? :)
02:51:11 <Cale> (or if we decided to do away with the index and just say that the types of types are types)
02:51:16 <lmfdvsu> I see you get cool quantifers like forall
02:51:50 <bitonic> lmfdvsu: well if you are interested in how that works understanding that is crucial, and it’s a concept that spans a lot of foundational stuff, e.g. set theory and category theory
02:52:23 <lmfdvsu> but again ,, to what end??
02:52:26 <bitonic> I’m going for breakfast now but you might want to search for ‘Russel’s paradox’ :)
02:52:43 <bitonic> lmfdvsu: the end is to remain consistent, we don’t want to be able to prove falsity
02:52:48 <lmfdvsu> I am aware of Russell paradox
02:53:08 <Cale> lmfdvsu: To allow for the logic to be consistent while never just giving up and saying "there's nothing beyond this point"
02:53:18 <lmfdvsu> x E x? right?
02:54:06 <lmfdvsu> To allow for the logic to be consistent while never just giving up and saying "there's nothing beyond this point -- you reminded me of our freshman grumpy math teacher +1 for that
02:54:11 <Cale> Russell's paradox is about the (putative) "Set of all sets that don't belong to themselves"
02:54:32 <lmfdvsu> yes.. I do recall
02:55:25 <lmfdvsu> quick question  Cale: if a and b are just natural numbers, then aren't we passing values at type/kind level??
02:55:27 <klrr> i get a really strange error, it says it's possibly indentation error but i cant see where :x https://gist.github.com/klrr/5693194 any ideas?
02:55:37 <Cale> lmfdvsu: yes, we are
02:55:54 <Cale> lmfdvsu: dependently typed languages do that
02:56:02 <Cale> (unlike Haskell)
02:56:09 <lmfdvsu> Cale: is that ok? no problems resolving
02:56:22 <lmfdvsu> values which might come up in run time??
02:56:28 <Cale> klrr: You missed a )
02:56:39 <Cale> klrr: the parameter to dropWhile
02:56:47 <klrr> Cale: oh thank you! :D
02:57:42 <klrr> is Handle in prelude or do i have to import it?
02:58:11 <Cale> klrr: I think you may have to import System.IO
02:58:34 <Cale> (Just import the whole thing probably if you're going to be working with that stuff)
02:59:11 <lmfdvsu> " dependently typed languages" -- means types (hiearachy of types)depending on values?
02:59:20 <Cale> yes
02:59:22 <Cale> lmfdvsu: You need to keep some of the types around at runtime, but everything is checked statically.
02:59:47 <klrr> Cale: if i use less than two functions in an import i specify it, if there's more than two i import everything
03:01:10 <lmfdvsu> Cale: don't you think, there has to be restriction on indices? (values on which functions are parametrized?)
03:01:29 <Cale> lmfdvsu: Huh?
03:01:35 <Cale> lmfdvsu: What restriction do you mean?
03:01:43 <lmfdvsu> and thanks ,, this thing cleared a lot of things
03:02:23 <lmfdvsu> Cale: like you can't have indices to be real numbers, would you? that's absurd isn't it?
03:03:01 <lmfdvsu> or a function? or a record value?
03:03:08 <Cale> You could.
03:03:17 <Cale> Well, computable reals, at least.
03:03:28 <lmfdvsu> Cale: my head hurts!
03:03:49 <Cale> That's not so common, but there's no reason you shouldn't be able to do that.
03:04:27 <lmfdvsu> so when, you say about computable reals, you mean cardinality of real numbers?
03:04:45 <lmfdvsu> where some reals are computable
03:04:56 <lmfdvsu> and others can't be ..
03:05:06 <lmfdvsu> is there a result like that?
03:05:17 <lmfdvsu> sorry, not a math/cs student  :)
03:07:20 <Cale> lmfdvsu: Well, in traditional mathematics, there are more real numbers than there are programs for computing them.
03:08:12 <lmfdvsu> Cale: ok, any particular result or theorem, preferably googlable.
03:08:46 <Cale> Well, we write programs with a finite alphabet, and each one is finite, so there are countably many of them.
03:09:51 <Cale> (there are infinitely many, and they're in bijection with the natural numbers)
03:11:04 <wagle> not all strings are programs
03:11:11 <Cale> Sure
03:11:41 <Cale> Any infinite subset of the natural numbers is in bijection with the natural numbers.
03:11:58 <wagle> perhaps there is a theorem that no two programs are more than 70 million lexical units apart
03:12:12 <lmfdvsu> Cale: thanks , that is the first result  i got while googling
03:12:20 <Hafydd> Heh/
03:13:27 <krsrk> Can anyone understand what's wrong here: http://hpaste.org/89123
03:13:34 <krsrk> the error is in the title
03:14:04 <Hafydd> There are also uncountably many subsets of the natural numbers, but only countably many programs generating a set of natural numbers, since some sets of natural numbers are uncomputable.
03:14:24 <Cale> In findPosition, you don't bind rotations to anything else, so rotations refers to the field extractor for Tetromino
03:14:31 <krsrk> namely, how can I give tetromino.rotations to findPositionForRotation and use the pattern matching x:xs (to recursively deal with the first element)
03:14:46 <Cale> i.e. the function which takes a Tetromino and extracts the rotations field from it
03:14:56 <Cale> (rotations tetromino)
03:15:04 <Cale> is probably what you want there
03:15:12 <Hafydd> Any real number can be identified with a the set of rational numbers less than it, and the rationals can be indexed by the naturals, so computing every set of naturals would entail computing every real number.
03:15:45 <krsrk> also, ignore the tiles argument in findPosition, I tried to strip down the code snippet a bit
03:17:54 <krsrk> Cale++ thanks it worked!
03:21:24 <kqr> Hafydd, how would you identify a real number with the set of rational numbers less than it? can't there be many real numbers between two rational numbers?
03:21:53 <wagle> uncountably many
03:22:19 <kqr> quite a few, so to speak
03:22:24 <kqr> but yeah, that's what i'm saying
03:23:12 <Hafydd> kqr: it happens that {q in Q | q < r} is unique for each r in R.
03:23:20 <Hafydd> Note that it's <, not <=.
03:23:59 <Hafydd> Well, that wouldn't change it, actually.
03:24:04 <Cale> http://planetmath.org/dedekindcuts
03:24:20 <shachaf> Hafydd: Well, ≤ doesn't really work when you're trying to *construct* the reals. :-)
03:24:55 <shachaf> (Since r ∉ ℚ.)
03:24:55 <Hafydd> Good thing I'm not trying to construct the reals.
03:25:25 <Cale> ^^ That page shows how to do it if you want to construct the reals
03:25:40 <klrr> ?src take
03:25:40 <lambdabot> take n _      | n <= 0 =  []
03:25:41 <lambdabot> take _ []              =  []
03:25:41 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
03:26:45 <klrr> > take 1 "hello"
03:26:46 <lambdabot>   "h"
03:26:48 <klrr> > head "hello"
03:26:50 <lambdabot>   'h'
03:26:57 <kqr> Hafydd, Cale, thanks, that's interesting
03:27:16 <shachaf> /msg lambdabot @type "hello"
03:29:25 <krsrk> What is the best way to print something (for debugging, logging) in a function that doesnt return IO type?
03:30:16 <shachaf> For debugging you can use Debug.Trace.
03:30:41 <shachaf> For logging you should return the log message along with the value some way or another.
03:30:53 <socumbersome> Could someone tell me why it doesn't work ?
03:31:27 <socumbersome> ooops, I pasted sth on hpaste but it doesn't seem to be visible..
03:31:51 <socumbersome> here: hpaste.org/89124
03:32:41 <kqr> socumbersome, your indentation is off
03:32:52 <kqr> socumbersome, lines 5–8 should be indented equally
03:33:18 <kqr> socumbersome, (and as a helpful note, you can remove line 8 if you change mapM to mapM_)
03:33:18 <Cale> socumbersome: There are tabs in your file
03:33:51 <Hafydd> You could replace "mapM putStrLn args\nreturn ()" with "mapM_ putStrLn args"
03:33:58 <Cale> socumbersome: You should configure your text editor to replace them with spaces automatically, so that confusing things like this don't happen.
03:34:31 <socumbersome> ahh, I don't know why but in Notepad++ I couldn't see those silly indentations...
03:34:44 <Cale> socumbersome: Because your tab stop is set to 4
03:34:53 <Cale> socumbersome: But the compiler will always treat it as 8
03:35:37 <Cale> Because different people's editors have different tab stops, and making things line up matters, it's often considered best just to not use tabs at all, and configure the text editor to replace them with spaces appropriately.
03:35:41 <socumbersome> Hmm, and how can I fix it?
03:36:11 <Cale> Settings -> Preferences... -> Language Menu/Tab Settings -> Tab Settings (group) -> Replace by space
03:36:25 <socumbersome> Ok, thanks!
03:36:25 <Cale> (apparently)
03:36:46 <Hafydd> Er, someone already said that; nevermind.
03:39:05 <Aetherspawn> shachaf, I think it would be great if cabal gave a way for packages to tell cabal that they /themselves/ are backwards compatible with version xxxx
03:39:34 <Aetherspawn> That way each time they move up a major version and add a ton of features, you don't get hell from all the packages that use ==
03:40:30 <shachaf> No.
03:40:45 <shachaf> That sounds like an unpleasant arrangement.
03:42:57 <savask> I make my own integer type a Read class instance. Should I treat precedence parameter in readsPrec in someway?
03:43:34 <Cale> savask: Just ignore it
03:44:55 <savask> Cale: Okay. And that readParen thing - should I use readParen False?
03:46:40 <Aetherspawn> Unpleasant maybe, but what's unpleasant is not being able to use half a package stream because you need to use new feature xxx and A supports it and B /would/ but has an == in its cabal file
03:49:41 <Peaker> dependency information should probably be on a web server somewhere rather than in .cabal files
03:50:11 <Peaker> and ideally it'd be computed by import/export signatures rather than version numbers
03:52:30 <FreeFull> Peaker: What if what the library does changes in a breaking way?
03:52:52 <FreeFull> Maybe some way of tracking breaking changes is in order
03:53:21 <FreeFull> So you can specify "Anything newer than 0.4, if no breaking changes occur"
03:54:16 <Peaker> FreeFull, If the dependency information is in import/export signatures, then a type-breaking change will be detected. If it isn't a type-breaking change, it can add a "breaking change version flag" to the particular exports that changes semantics -- and all importers of those exports must explicitly state awareness of that flag in their import signatures
03:55:10 <efie> Hello, could you please take a look at this? http://hpaste.org/89126 (don't know why this does not appear here automatically)
03:55:16 <Peaker> Perhaps we can have a version number for each exported name, even, and then a tool to auto-generate an import signature based on what you actually use, with the current version number in it
03:59:13 <Botje> efie: I think it can.
04:00:17 <efie> Botje: that's also what is my impression when comparing how fast h and the call 'fib 70000' run; but how does it work?
04:01:50 <Botje> efie: fib encapsulates a lookup table
04:02:03 <klrr> MUAHHAHAHA)))))))))))))99
04:02:12 <Botje> uh oh
04:02:34 <ofan> the Trac system seems down for ghc? got 'Trac detected an internal error: OperationalError: database is locked'
04:03:30 <efie> Botje: do you know how long this table is stored for further requests?
04:03:32 <Aetherspawn> Peaker, I like that suggestion
04:04:05 <Botje> efie: as long as fib is in scope.
04:04:11 <FreeFull> > let fibs = 0:1:zipWith (+) fibs (tail fibs); fibs !! 70000
04:04:12 <lambdabot>   <hint>:1:59: parse error (possibly incorrect indentation)
04:04:14 <Botje> and since your script has it as a top-level function, forever :]
04:04:16 <FreeFull> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs !! 70000
04:04:17 <lambdabot>   610003738057746692267724564805437189422604376425784632897374626651440444988...
04:04:27 <FreeFull> That's pretty fast
04:11:00 <efie> Botje: um what does in scope mean exactly? I have top level function 'f' in which a function 'g' (similar to fib, with 2 arguments) is defined in a where statement, and in 'f' I sum over multiple calls g x1 x2, g x3 x4... I would like the different calls of g to reuse previous calculcations made in other calls of g
04:14:56 <kqr> efie, those should do so as long as you don't exit f
04:15:03 <kqr> efie, since g is in scope for the entirety of the body of f
04:15:15 <Botje> efie: and you memoized g correctly?
04:15:35 <efie> Botje: yes, like it is done for fib in the example above
04:15:35 <Botje> or rather, g is a memoized function here?
04:17:15 <efie> kqr: ah ok
04:17:18 <efie> thank you
04:17:27 <efie> both
04:19:14 <rec> @pl \f g x y -> f (g x y)
04:19:14 <lambdabot> (.) . (.)
05:05:26 <klrr> my bot doesnt work for some reason, it compiles and starts, but then gets "ERROR :Closing Link: 127.0.0.1 (Connection timed out)", https://gist.github.com/klrr/5693442 , any ideas?
05:10:31 <PaulVisschers> What´s a good library for creating a client/server network for a game?
05:11:45 <klrr> PaulVisschers: Network module, it's good abstraction over Network.Socket i think
05:11:59 <merijn> It depends on the type of game
05:12:28 <merijn> Different genres have different networking requirements
05:12:48 <merijn> Turn based? Real time? Twitch game?
05:13:02 <neutrino1> do you want a http front-end?
05:14:11 <PaulVisschers> merijn: it´s real-time and somewhat twitchy
05:14:30 <neutrino1> is it something like doom
05:14:40 <merijn> Then you will probably have to do your own networking thing based on UDP
05:14:54 <merijn> Otherwise you will suffer lagspikes
05:15:06 <merijn> PaulVisschers: Have you read the DOOM/Quake source reviews?
05:15:07 <neutrino1> or more like Crazy Chicken
05:15:28 <PaulVisschers> merijn: no, I have not
05:15:34 <neutrino1> merijn: it depends whether the various players actually need the lag between them to be low as well..
05:15:48 <neutrino1> or if the user just needs low lag time to the GUI
05:16:00 <merijn> PaulVisschers: http://fabiensanglard.net/
05:16:19 <neutrino1> i can recommend this link as well
05:16:28 <merijn> PaulVisschers: The source of all the old DOOM/Quake engines have been GPLed, that guy has discussion of the details of how they work, including networking
05:16:47 <neutrino1> it's a very interesting read
05:17:38 <merijn> PaulVisschers: The networking details/decisions will be the same in C and in haskell, so it's a good place to start
05:18:07 <merijn> (as they mostly depend on OS and network stack and not so much in the language you use to access those)
05:18:14 <PaulVisschers> Well I´ve been rolling my own module based on Network and ByteString but that just seems to be unstable for some reason
05:19:42 * hackagebot monadplus 1.2 - Filtering and folding over arbitrary MonadPlus instances.  http://hackage.haskell.org/package/monadplus-1.2 (HansHoglund)
05:20:14 <PaulVisschers> merijn: I´ll definitely check those pages, they seem like an interesting read
05:20:23 <DigitalKiwi> could use Enet via bindings i wonder...
05:20:28 <DigitalKiwi> ?
05:21:56 <PaulVisschers> neutrino1: it shouldn´t be super twitch, but there is some gunplay involved
05:22:24 <PaulVisschers> neutrino1: but does UDP even work over the internet?
05:25:55 <ghorn_> is it possible to do something like x = [0::Int, "hi"::String] :: [forall a. Show a => a] without using a data constructor on each element?
05:26:58 <elliott> no
05:27:02 <elliott> it would be [exists a. Show a => a] if you could
05:27:10 <elliott> however, you might as well just use [String].
05:29:03 <jesyspa> What problems would allowing it create, actually?
05:29:44 <elliott> I don't know if it necessarily creates problems. UHC has a restricted version of it
05:29:54 <elliott> it's just implementation effort and so on.
05:30:12 <jesyspa> Ah, okay.
05:32:34 <jesyspa> Hmm, I guess there'd be no way to get a specific type out of that list.  You couldn't exactly case over them.
05:32:42 <typoclass> jesyspa: the question is also what benefit it would really have. for a typeclass like Show, it's a lot easier to just "map show" and use the resulting [String]
05:32:42 <lambdabot> typoclass: You have 1 new message. '/msg lambdabot @messages' to read it.
05:32:56 <jesyspa> I see.
05:32:56 <typoclass> jesyspa: yes, you've spotted that exactly right
05:33:50 <elliott> you can't use "map show" here.
05:35:00 <merijn> PaulVisschers: Eh, why wouldn't UDP work over the internet?
05:35:11 <typoclass> elliott: i meant to just expand on what you said earlier ("you might as well just use [String]")
05:35:37 <elliott> right, but I mean even if you want to just use a [String], you can't use map show
05:35:46 <elliott> > map show ["abc", ()]
05:35:47 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
05:35:47 <lambdabot>              with actual ty...
05:35:59 <merijn> PaulVisschers: "the internet" is usually IP (i.e. Internet Protocol), both TCP and UDP run on top of IP
05:36:03 <elliott> > [show 'abc", show ()]
05:36:04 <lambdabot>   <hint>:1:22:
05:36:04 <lambdabot>      lexical error in string/character literal at end of input
05:36:06 <elliott> > [show "abc", show ()]
05:36:08 <lambdabot>   ["\"abc\"","()"]
05:36:33 <PaulVisschers> merijn: Ok, I thought it was all TCP/IP
05:36:47 <typoclass> elliott: oh yes, absolutely
05:38:31 <merijn> PaulVisschers: You might also wanna read http://beej.us/guide/bgnet/ for more low level details on networking
05:39:32 <PaulVisschers> merijn: probably a good idea, thanks
05:40:33 <merijn> PaulVisschers: Fair warning, though. Doing real time multiplayer is *hard*
05:40:44 <merijn> turn based + TCP is *much* easier
05:41:39 <Aetherspawn> Can someone help me with getting my code to typecheck
05:43:54 <Peaker> Aetherspawn, don't ask to ask...
05:43:58 <typoclass> Aetherspawn: sure, just ask your question
05:44:16 <Aetherspawn> It'll take a long time to write out, so I'll start now :P
05:44:40 <typoclass> Aetherspawn: if your code is longer than 1 line, please use hpaste.org :-)
05:45:58 <krsrk> Is there a simple way two XOR two lists with same length
05:46:17 <krsrk> e.g [1,0,1,1] xor [0,1,0,0] is true
05:46:18 <Aetherspawn> I need help converting my already quite deep monad into something that will satisfy ResourceT on line 43 http://hpaste.org/89134
05:46:21 <elliott> > zipWith (/=) [False,True,False] [True,True,True]
05:46:23 <lambdabot>   [True,False,True]
05:47:18 <krsrk> > zipWith (/=) [0,1,0] [1,1,1]
05:47:20 <lambdabot>   [True,False,True]
05:47:24 <krsrk> uu
05:47:29 <krsrk> cool, thx elliott
05:47:45 <elliott> if you want to reduce that to a single boolean afterwards you could foldr or such
05:48:02 <typoclass> krsrk: or you could use 'and'
05:48:04 <typoclass> > and $ zipWith (/=) [0,1,0] [1,1,1]
05:48:06 <lambdabot>   False
05:48:20 <krsrk> perfect
05:48:28 <fruitFly_> I am just not seeing why this runtime error is occuring. I don't see what's wrong with this logic? http://ideone.com/IlQ7Ae
05:48:32 <Peaker> > let xor=(/=) in foldl' xor False [True, False, True]
05:48:33 <PaulVisschers> merijn: yeah I´m sure it is
05:48:33 <lambdabot>   False
05:48:47 <PaulVisschers> merijn: but I really want to do realtime
05:49:11 <fruitFly_> can I load the functions from http://ideone.com/IlQ7Ae into the repl even if it has a main method?
05:49:13 <fruitFly_> hoe so?
05:49:18 <fruitFly_> how* so?
05:49:41 <fruitFly_> Peaker: u doing matasano?
05:50:30 <PaulVisschers> fruitFly_: you´re not pattern matching on the empty list there
05:50:37 <Peaker> fruitFly, nope
05:51:15 <fruitFly_> PaulVisschers: it will never get to a empty list? do I still need to put that case in?
05:52:00 <PaulVisschers> fruitFly_: you don´t have to if you never put an empty list in it, but you are putting one in now or you wouldn´t get the error
05:52:16 <Feuerbach> Has anyone set up multi-repositories builds on travis-ci?
05:52:24 <merijn> hmmm
05:52:27 <merijn> This is really odd
05:52:34 <fruitFly_> Paul, how am I putting an empty list in there? Where?
05:53:09 <typoclass> fruitFly_: i don't think there's a problem with doing ":load file.hs" in ghci if file.hs contains a 'main'. are you getting an error message when you do that?
05:53:25 <merijn> If I use fdToHandle on a pty and then use Data.ByteString.hGetSome I keep magically killing the process on the slave tty, but if I manually wrap read(2) and write(2) from haskell code it seems to work...
05:53:46 <merijn> What evil voodoo are ByteString and fdToHandle doing that is breaking things?
05:54:53 <fruitFly_> typoclass: i'm not even saying anything after the command.. no confirmation no nothing
05:55:05 <fruitFly_> typoclass:  oh wait
05:55:17 <PaulVisschers> fruitFly_: it´s too complex for me to see right away, but you are somewhere
05:56:00 <fruitFly_> PaulVisschers: alright, thanks :)
05:57:45 <PaulVisschers> fruitFly_: you are either putting in an empty string, or a string without an ´=´ in it
05:58:19 <PaulVisschers> fruitFly_: probably the latter, which means it will recurse until hitting the empty list and then it fails the pattern match
05:58:20 <fruitFly_> PaulVisschers: oh shit right!
05:59:01 <fruitFly_> PaulVisschers: Got it.. you're the man!
05:59:31 <PaulVisschers> fruitFly_: yw
06:04:11 <Aetherspawn> Argh its so infuriating
06:11:36 <merijn> I forget, how do specify the number of threads to use during compilation instead of as RTS flag when running my binary?
06:12:06 <Aetherspawn> You can do it through ghc like this
06:12:18 <Aetherspawn> -rtsopts -with-rtsopts=-N4
06:12:27 <Aetherspawn> for the equivalent of +RTS -N4
06:12:55 <merijn> Thanks
06:13:41 <Aetherspawn> I don't understand at all, do I need to wrap all my things in ResourceT
06:14:20 <Aetherspawn> if I have a higher monad like
06:14:39 <Aetherspawn> function :: UpperMonad InnerMonad
06:15:13 <Aetherspawn> and then I need to introduce another monad (transformer) in the function body, say, ResourceT but have it place nice with all my other innermonad typed stuff, how does that work
06:15:26 <gspr> Hmm, is GHC really meant to look for LLVM programs such as opt by looking for opt-3.0 *before* simply opt? (I have /usr/bin/opt as a symlink to opt-3.2, but GHC complains about not finding opt-3.0)
06:21:37 <jonkri> Can you hide a type class of a type?
06:21:38 <Peaker> Aetherspawn, You need to have ResourceT when the functions you work with need it
06:21:52 <Peaker> Aetherspawn, can you give a more specific example for your question?
06:22:20 <robstewartuk> Can anyone point me to a good example of UML diagram that documents a module view of a Haskell library?
06:22:26 <Aetherspawn> I think you just answered it :)
06:23:20 <Aetherspawn> But the problem is that I don't understand this ; if I need a ResourceT in the function type to use runResourceT then how do I get that resourceT in the first place?
06:23:31 <Aetherspawn> Doesn't  that mean I have to runResourceT the function, then the function above needs it, etc o-O
06:24:05 <ChongLi> robstewartuk: I don't know about a module view
06:24:26 <ChongLi> but lens has a UML diagram of its hierarchy of types
06:24:28 <ChongLi> http://hackage.haskell.org/package/lens
06:24:43 <robstewartuk> ah yes!
06:24:45 <robstewartuk> thanks.
06:25:39 <Peaker> Aetherspawn, ResourceT is about making sure resources are eventually released, and only released exactly once
06:25:40 <applicative_> jonkri, how do you mean, hide the typeclass of a type?
06:25:41 <elliott> is it actually UML?
06:25:51 <Peaker> Aetherspawn, can you show the code you have a problem with?
06:26:08 <jonkri> applicative_: i want to have a type class instance that is internal to my module, so that it's not visible when i export the type
06:26:09 <ChongLi> elliott: that I dont know
06:26:26 <Aetherspawn> Peaker, http://hpaste.org/89135
06:26:36 <applicative_> jonkri: but the type class itself if from outside the module?
06:26:43 <ChongLi> http://creately.com/diagram/h5nyo9ne1/QZ9UBOtw4AJWtmAKYK3wT8Mm1HM%3D
06:26:48 <Peaker> Aetherspawn, where in particular?
06:26:49 <jonkri> applicative_: no, inside
06:26:54 <Aetherspawn> mergeSources gives me back something which is wrapped funny
06:27:09 <Aetherspawn> It's on line 67
06:27:23 <applicative_> jonkri: oh, in that case if you don't export the class, it won't cause trouble.
06:28:06 <Aetherspawn> Peaker, and the types, for context; http://hpaste.org/89136
06:28:09 <jonkri> applicative_: thanks (i don't want it to be visible in the haddock)
06:28:14 <merijn> elliott: No one uses actual UML as the 50 page "spec" book is lik 60 euros
06:28:17 <Aetherspawn> I know, it's huge ;__;
06:28:31 <Kaidelong> JHC, which extensions will I miss if I use it?
06:28:34 <Kaidelong> the most
06:29:16 <Peaker> Aetherspawn, when you: runResourceT foo   you better not have "foo"s result type contain anything that depends on its resources being still available/unreleased
06:29:30 <applicative_> Kaidelong: have you built it?
06:29:43 <Peaker> Aetherspawn, usually you want the runResourceT to delimit resource-local computations that don't leak out anything that depends on their resource
06:30:02 <Kaidelong> is it not building right now?
06:30:45 <applicative_> Kaidelong: ah, good work.
06:30:55 <Peaker> Aetherspawn, do you have a git repo I can clone?
06:31:06 <Aetherspawn> Peaker, yes I do but its private
06:31:10 <applicative_> Kaidelong: it supports rank n types. be the first on your block to build Control.Lens with jhc
06:31:15 <Kaidelong> looks like JHC doesn't support GADTs
06:31:17 <Aetherspawn> Peaker, do you mind if I query you?
06:31:29 <Kaidelong> or type families
06:31:44 <Kaidelong> I guess the latter is a problem for me because of my addiction to Data.Vector
06:31:52 <jonkri> applicative_: the internal class is shown in the haddock even if i don't export it
06:33:13 <applicative_> hm jonkri
06:33:38 <jonkri> applicative_: there's no link, of course, but it still clutters the api
06:34:29 <randomclown> @pl \x y -> (a + x, b + y)
06:34:29 <lambdabot> (. (b +)) . (,) . (a +)
06:34:58 <Michae___>  Is there a defined algorithm/function for creating a new tree, from another tree, from the bottom up?
06:39:09 <Kaidelong> "All text based IO is performed according to the current locale. This means that Unicode works seamlessly, but older programs that assumed IO was performed by simple truncation of chars down to 8 bits will fail. Use the explicit binary routines if you need binary IO."
06:39:16 <Kaidelong> you're supposed to do that using GHC anyway, right?
06:39:36 <Botje> Michae___: doesn't the generalized fold do that? you have a function for leaves and a function for combining nodes
06:40:14 <Kaidelong> or more to the point, use ByteString instead
06:40:28 <applicative_> Michae___: fmap?  >>= ?
06:40:55 <applicative_> these make a new tree from an old tree, if the tree type is a functor or monad respectively
06:41:57 <applicative_> fold crushes the tree and yields a result, which of course might be a tree
06:42:48 <applicative_> Michae___: but I think folks would need to know more to answer this question properly
06:43:56 <Michae___> applicative_: I'm trying to infer concrete types from a parse tree, so I intended to start at the bottom of the parse tree, and build a new tree, of type Tree (Expr,Signature)
06:45:00 <applicative_> what is the type of the Tree __ you are starting with, Tree Expr?
06:45:01 <Botje> Michae___: if your parse tree has something let-like you'll need an explicit environment and a top-down approach, i'm afraid.
06:45:20 <Michae___> applicative: yes
06:45:40 <applicative_> ah I see Botje seems to be grasping the particulars
06:45:53 <Michae___> Botje: As of now, it doesn't, though I may add let in the future. Do you know of any good resources on top-down inference?
06:46:47 <Botje> Michae___: it's basically what the type rules encode.
06:47:37 <Botje> you have one type rule for each kind of syntax, and you need to verify the preconditions to proceed
06:49:23 <Botje> so in top down you start at the stuff underneath the line and you need to check the stuff above
06:49:41 <Botje> with a bottom-up approach, you're given the types of the subexpressions and you just need to apply the type rule
06:51:26 <Kaidelong> "build must equal host", I take it this means that GHC has to be built on the same system that is going to host it?
06:51:48 <Kaidelong> that's a limitation I'm used to, I think
06:52:06 <krsrk> hmm, xor wasnt what I really needed
06:52:13 <krsrk> > and $ zipWith (\x y -> not (x == 1 &&  y==1)) [0,1,0] [0,1,1]
06:52:15 <lambdabot>   False
06:52:23 <krsrk> is there a shorter way to write that_
06:52:24 <krsrk> ?
06:52:33 <elliott> why are you using lists of integers rather than booleans?
06:52:56 <Botje> krsrk: apply de morgan
06:53:03 <krsrk> I guess I dont have to use 1 and 0s
06:53:12 <Botje> \ x y -> x /= 1 || y /= 1
06:53:36 <Botje> and if you really want to shrink that down ..
06:53:39 <Botje> @pl \x y -> x /= 1 || y /= 1
06:53:40 <lambdabot> (. (1 /=)) . (||) . (1 /=)
06:53:43 <Botje> ew.
06:53:49 <simon> it's a gamble.
06:53:55 <Peaker> (||) `on` (/= 1)
06:53:57 <Botje> yeah, that.
06:54:09 <FreeFull> krsrk: What are you trying to do? See if the lists are equal?
06:54:28 <krsrk> FreeFull: no, see that are no 1-s at the same positions
06:55:18 <Botje> all (/= (1,1)) $ zip [...] [...]
06:55:34 <Botje> easy, and it expresses your intent best :)
06:55:41 <FreeFull> > (not . any (>1) . zipWith (+)) [0,1,0] [0,1,1]
06:55:42 <lambdabot>   Couldn't match expected type `[a0]' with actual type `[b0] -> [c0]'
06:55:43 <Aetherspawn> :t (>>)
06:55:44 <lambdabot> Monad m => m a -> m b -> m b
06:55:54 <FreeFull> Oh right
06:56:00 <Rarrikins> > all (== 0) $ zipWith (*) [0, 1, 0] [0, 1, 1]
06:56:01 <lambdabot>   False
06:56:03 <FreeFull> > not . any (>1) $ zipWith (+) [0,1,0] [0,1,1]
06:56:04 <lambdabot>   False
06:56:07 <Aetherspawn> :t liftA2
06:56:08 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
06:56:09 <FreeFull> > not . any (>1) $ zipWith (+) [0,1,0] [0,0,1]
06:56:10 <lambdabot>   True
06:56:23 <Rarrikins> > all (== 0) $ zipWith (*) [0, 1, 0] [0, 0, 1]
06:56:24 <lambdabot>   True
06:56:45 <FreeFull> Rarrikins's expression is slightly simpler
06:57:09 <FreeFull> But Botje might be right with his
06:57:16 <FreeFull> I'd go with Botje's
06:58:56 <krsrk> ok, thanks all of you
06:59:25 <krzysz00> :t on
06:59:26 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
07:16:53 <merijn> hmmm
07:17:11 <merijn> Interesting "Test: <stdin>: hSetBuffering: illegal operation (handle is closed)"
07:19:18 <merijn> oh, handleToFd closes the handle...inconvenient
07:20:06 <paullik> Hi. I have a function that splits a list into several sublists with equal length, but man it's ugly and hacky: http://hpaste.org/89141 How can I write it more idiomatically?
07:20:43 <elliott> :t splitAt
07:20:45 <lambdabot> Int -> [a] -> ([a], [a])
07:21:14 <fruitFly_> is there any way to put a boolean in pattern matching? like x : y : z where I want z to not be an equal sign?
07:21:34 <elliott> > let divide _ [] = []; divide n xss = xs : divide n xss' where (xs,xss') = splitAt n xs in divide 5 [1..20]
07:21:37 <elliott> > let divide _ [] = []; divide n xss = xs : divide n xss' where (xs,xss') = splitAt n xs in divide 5 [1..19]
07:21:38 <merijn> fruitFly_: Use guards
07:21:39 <paullik> elliott, I want to split a list into n lists, not in two lists, and I want to split it by a count of elements, not by an index
07:21:40 <geekosaur> not as a pattern, no
07:21:49 <lambdabot>   thread killed
07:21:52 <elliott> paullik: you can use splitAt to do it
07:21:53 <lambdabot>   thread killed
07:21:59 <elliott> but apparently not the way I did
07:22:04 <merijn> paullik: Recursively use splitat
07:22:27 <paullik> elliott, merijn, ok let me think about it and I'll try, thanks
07:22:40 <fruitFly_> merijn: ok thanks
07:23:22 <fruitFly_> how bad is it to put less likely cases first in certain cases?
07:25:20 <merijn> paullik: Something like this: http://hpaste.org/89142
07:25:43 <merijn> Mind you, that one might result in the last list being shorter than the rest
07:26:01 <merijn> And random error conditions like that, it was just to give you an idea on how to tackle it
07:27:00 <merijn> > splitAt 5 [1..4]
07:27:02 <lambdabot>   ([1,2,3,4],[])
07:27:04 <paullik> merijn, in my use scenario I'll always use it to divide lists of 81 elements in lists of 9 elements so I can display a sudoku board
07:27:14 <merijn> paullik: oh, then it should work
07:27:30 <merijn> > splitAt 5 [1..20]
07:27:31 <paullik> but I won;t look over your example since now I know I can do it with splitAt and I want to develop my haskell skills..
07:27:31 <lambdabot>   ([1,2,3,4,5],[6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])
07:27:56 <merijn> ok, good luck :)
07:28:01 <paullik> thanks
07:28:38 <Peaker> > let chunks n = map (take n) . takeWhile (not . null) . iterate (drop n) in chunks 3 "Hello world!"
07:28:39 <lambdabot>   ["Hel","lo ","wor","ld!"]
07:28:49 <merijn> Does System export "stdin :: Fd" somewhere? i.e. instead of "stdin :: Handle"?
07:28:53 <paullik> oh, and one more thing, that came to mind today, haskell doesn't have optional parameters for functions, does it?
07:29:06 <merijn> paullik: Not really
07:29:14 <merijn> paullik: People usually just use Maybe for that
07:29:16 <paullik> how is that?
07:29:23 <paullik> ah, ok
07:29:37 <merijn> paullik: You could do really complicated hacks with typeclasses to fake optional parameters, but you shouldn't
07:29:56 <paullik> complicated hack, yeah, that doesn't sound right
07:30:05 <geekosaur> that kind of optional parameter makes partial application difficult
07:30:22 <merijn> It can be fun to show it's possible, but you shouldn't use it for real code
07:30:39 <paullik> geekosaur, interesting point
07:31:19 <geekosaur> it's kinda the main point in a curried functional language :)
07:31:59 <merijn> paullik: Usually I'd approach it like this: "fooWithBellsAndWhistles :: Maybe Bar -> Maybe Baz -> Int -> OtherParameter -> IO (); fooNormal :: Int -> OtherParameter -> IO (); fooNormal = fooWithBellsAndWhistles Nothing Nothing"
07:32:16 <Aetherspawn> Hi, is it possible for this type to be expressed simpler
07:32:18 <Aetherspawn> http://hpaste.org/89143
07:32:18 <elliott> why not just Bar -> Baz -> ... and have fooNormal contain the defaults?
07:32:28 <Aetherspawn> it was the recommended type for one of my functions by a GHC warning
07:32:30 <merijn> elliott: Ha! Beat you to it :p
07:32:58 <quchen> paullik: Higher-order functions also make optional parameters unnecessary in many cases. For example, in `filter f`, you can insert `id` if you don't want to filter, or some predicate if yo do. In C, the predicate could be modeled as an optional parameter, in Haskell it's just some function.
07:33:17 <quchen> Eh, not `id` but `const True`
07:33:25 <elliott> merijn: that was addressed to you
07:33:51 <Peaker> quchen, better to "id" instead of the whole (filter f)
07:34:11 <paullik> quchen, merijn, I get it
07:34:25 <quchen> Peaker: But you can't make `id` filter even numbers out.
07:34:25 <merijn> elliott: Oh, well it depends on how optional things are, I guess
07:34:43 <Peaker> quchen, I mean, "filter (const True)" is a bad idea
07:34:50 <Peaker> quchen, O(N) instead of O(1)
07:35:10 <quchen> Peaker: `let f = const True in filter f` is a very good idea.
07:35:16 <elliott> it is?
07:35:19 <quchen> ... in some cases.
07:35:22 <merijn> Bah, passing "fromIntegral 0" to functions expecting Fd seems dirty...
07:35:33 <elliott> merijn: surely you can just pass 0?
07:35:35 <elliott> :t fromIntegral
07:35:36 <lambdabot> (Integral a, Num b) => a -> b
07:35:41 <merijn> oh, duh
07:35:49 <merijn> elliott: Still feels dirty, though
07:35:57 <Peaker> quchen, I disagree... make the whole (filter f) parameterized, rather than just the "f"
07:36:13 <merijn> Shame there's not "stdinFd :: Fd"
07:36:17 <merijn> s/not/no
07:36:47 <quchen> Peaker: That wouldn't make a very good example anymore to explain how functions as parameters can replace optional arguments, which was the point I invented this example for.
07:36:58 <hpc> merijn: stdinFd = 1
07:37:53 <quchen> Peaker: For production code you were right of course.
07:38:02 <Peaker> quchen, it's not a good example... filter does nothing but filter
07:38:30 <quchen> Peaker: I'll ask for a better example on stackoverflow next time so I don't upset the IRC then.
07:38:40 <merijn> hpc: *Bzzzt*
07:38:46 <merijn> hpc: stdinFd = 0
07:38:51 <merijn> 1 is stdout
07:39:00 <paullik> heh, did it (the divide  function) now on to merijn and Peaker examples for comparison
07:39:07 <krsrk> If I have a list, say [1,1,0,1], how could I get indexes which elements are 1, [0,1,3]
07:39:36 <Peaker> quchen, I think it's nicer to show compositional approach for avoiding many params, some of which optional:   filled Red . moved (100,200) . scale 3 $ circle      is nicer than:   circle(position=(100,200), filled=Red, ... <1 hundred optional params>)
07:39:38 <merijn> krsrk: "zip [1..]", filter on snd being 1, then lookup the fst of the remainder
07:39:42 <paullik> krsrk, elemIndices
07:39:48 <merijn> :t elemIndices
07:39:49 <lambdabot> Eq a => a -> [a] -> [Int]
07:39:52 <startling> > elemIndices [1, 0, 1, 1]
07:39:53 <geekosaur> or findIndices for a general predicate
07:39:54 <lambdabot>   *Exception: show: No overloading for function
07:40:01 <startling> er
07:40:11 <startling> oh, paullik beat me anyway
07:40:13 <merijn> Mine doesn't rely on an Eq constraint! :p
07:40:21 <startling> > elemIndices 1 [1, 0, 1, 1]
07:40:23 <lambdabot>   [0,2,3]
07:40:28 <merijn> (for predicates other than (==1), that is)
07:40:39 <startling> merijn: what about (== 2)?
07:40:44 <krsrk> cool, thanks again!
07:40:45 <startling> (sorry)
07:41:09 <merijn> hmm
07:41:21 <merijn> I'm becoming frighteningly good are borking my terminal...
07:54:24 <merijn> \o/
07:54:53 <merijn> I have succesfully run top in my pty, I still don't know why it didn't work 2 hours ago, but does work now, but who cares!
07:58:47 <tsinnema> note: FP conferences should serve lemonade
07:58:47 <merijn> hmm, bollocks...
07:58:56 <tsinnema> because it has the word monad in it
07:58:58 <merijn> I appear to still be subtly breaking my terminal >.<
07:59:05 <tsinnema> that being a sufficient reason for this suggestion
07:59:08 <tsinnema> note ends
07:59:57 <geekosaur> writing your own terminal emulator? that's always fun...
08:00:35 <merijn> geekosaur: Well, step one was, start writing posix-pty to have a nicer way to interact with terminals :p
08:00:39 <paullik> merijn, you doing that in haskell?
08:00:49 <merijn> paullik: haskell + C
08:00:53 <paullik> dude...
08:01:42 <merijn> geekosaur: But saving the terminal state and restoring it at the end of my program seems to not restore everything 100% accurately, as I still get weird errors like no linebreaks in my shell, etc.
08:02:43 <merijn> paullik: What's so odd about that?
08:02:47 <geekosaur> are you saving the whole state? that sounds like you're missing something like c_lflags
08:03:45 <merijn> I'm just doing "tcgetattr(fd, &save_termios)"
08:03:56 <merijn> And then at the end I tcsetattr that structure
08:04:02 <paullik> merijn, nothing, I was just thinking of the hard time I have writing simple stuff in haskell, you write terminal emulators... it's really cool
08:04:49 <merijn> Oh, wait, I'm using TCSAFLUSH on setting, so I might need to flush the thing
08:04:57 <merijn> Or try using TCSANOW
08:05:19 <merijn> paullik: If you're comfortable with C then the haskell FFI is actually incredibly comfortable and simple to use :)
08:05:46 <merijn> Seriously, whoever designed the FFI deserves a hug and some kind of reward
08:05:52 <paullik> really? nice
08:06:43 <paullik> yeah, I'm ok with C, anyway, is your project open-sourced somewhere?
08:06:46 <merijn> paullik: Most simple functions (i.e. not taking/returning structs) require only a 1/2 line import statement to use
08:06:57 <merijn> paullik: No, I want it to be a bit less crappy before I publish it :p
08:07:05 <paullik> ok
08:07:49 <merijn> paullik: Using something like read(2) only requires a simple import like: foreign import ccall "unistd.h read" read_fd :: Fd -> CString -> CInt -> IO CInt
08:08:11 <merijn> which basically defines a function "read_fd" that'll be linked to the C function "read"
08:09:04 <paullik> seems easy
08:09:26 <ion> like monoids
08:12:02 <Zeev> can anyone help me out with calling a simple dll func from haskell?
08:12:08 <paullik> I'm not familiar with monoids in haskell, but I learned them in maths
08:12:27 <merijn> paullik: It's just an injoke here :)
08:12:34 <Zeev> I saw this example http://therning.org/magnus/archives/315#comment-294102 but cannot reproduce
08:12:57 <merijn> The monoid typeclass in haskell just has a 0 element and binary operations on them and that's it
08:13:54 <merijn> Zeev: Can you be more specific in what problem you run into?
08:13:56 <Zeev> when I put #include "foo.h" in .hs I get "syntax error" from ghc
08:14:26 <Zeev> I wrote a simple add() function which takes a struct with integers a,b,c
08:14:33 <Zeev> does c = a+b
08:14:49 <Zeev> * struct1.c = struct1.a + struct1.b
08:15:02 <Zeev> * takes pointer to a struct, actually
08:15:03 <merijn> Zeev: That post seems a little out of date
08:15:09 <Zeev> and then returns the struct
08:16:03 <merijn> I think you need "{-# LANGUAGE CPP #-}" to have #include in haskell sources, but I don't think that should really be necessary at all anymore
08:16:21 <Zeev> * sry, returns void, but inside struct changes value of c
08:16:37 <quchen> Is there some standard variant of `forever` that lets me jump out of the infinite loop?
08:16:45 <quchen> Something like "foreverUntil"?
08:16:56 <merijn> quchen: forever + exception?
08:16:58 <startling> Zeev: you probably don't want to include a .h in your haskell file anyway
08:17:06 <quchen> merijn: Eww, you used the E-word.
08:17:10 <merijn> "handle myHandler . forever $ do"
08:17:22 <merijn> quchen: See also the billion loops in monad-loops
08:17:25 <startling> Zeev: oh, you missed that that's a hsc2hs file
08:17:27 <merijn> @hackage monad-loops
08:17:27 <lambdabot> http://hackage.haskell.org/package/monad-loops
08:17:59 <quchen> merijn: Oh boy, I thought you were exaggerating when you said 'billion'
08:19:13 <merijn> geekosaur: Bleh, it looks like I'm borking the scrolling behaviour of bash with my code, but I for the live of my can't see how :\
08:19:44 <geekosaur> compare stty -a output
08:21:15 <merijn> hmm
08:21:27 <merijn> -pendin before my program, "pendin" after...
08:22:06 <fruitFly_> how do I fix the print at the bottom? http://ideone.com/OVnE55
08:23:23 <merijn> I dunno how that could be getting changed, though
08:23:48 <merijn> How could the termios struct possibly be different before and after if I don't change it in between reading/setting
08:25:08 <geekosaur> fruitFly, you have two problems there. the parse error is because it's indented and so looks like a continuation of the case statement, but after that you're still missing parentheses around (bytesToBase64 bytes)
08:25:56 <Zeev> http://hpaste.org/89150
08:27:00 <fruitFly_> geekosaur: tried that.  stil not working? http://ideone.com/OVnE55
08:27:38 <geekosaur> right, because you now have it not indented *enough*
08:27:38 <yitz> merijn: really? how could a reference to a DLL possibly work without a reference to an interface file somewhere? unless you're using something higher-level, like COM.
08:28:06 <Zeev> merijn , startling: ^^
08:28:19 <geekosaur> it would be clearer to not "cuddle" the case like that so the layout is more obvious
08:28:39 <startling> Zeev, you need to compile it with hsc2hs
08:28:40 <Zeev> merijn, startling: could you please suggest where to dig
08:28:56 <startling> Zeev, hsc2hs will make it into a haskell source file
08:29:21 <fruitFly_> geekosaur: i'm not sure what's more ideal and if that would even help the comp error
08:29:23 <geekosaur> fruitFly, also you need either a do construct or use >>
08:29:30 <merijn> yitz: You usually put the header file in the foreign import
08:29:42 <merijn> yitz: "foreign import ccall "unistd.h read"" for example
08:29:56 <fruitFly_> geekosaur: could you show me? http://ideone.com/OVnE55#view_edit_box
08:29:56 <geekosaur> fruitFly, you seem to not have figured out haskell syntax very well
08:29:59 <yitz> oh ok
08:30:00 <monochrom> is "(#peek x, y)" valid syntax? should it be "#{peek x, y}" instead?
08:30:10 <yitz> what in the world are #poke #peek and #size?
08:30:13 <merijn> oh, I think
08:30:17 <merijn> yitz: hsc instructions
08:30:20 <startling> monochrom, it's hsc2hs
08:30:25 <startling> yitz ^
08:30:30 * yitz nods
08:30:36 <monochrom> yes, I'm talking about hsc2hs syntax
08:30:44 <fruitFly_> geekosaur: what am I doing wrong? I'm still learning
08:30:45 <merijn> Yes, I think it should be {
08:31:08 <geekosaur> well, I fixed the syntax but you don't seem to have defined bytes anywhere. http://ideone.com/j3OQ4X
08:31:30 <geekosaur> oh, i see, it's defined only inside the case
08:31:35 <startling> monochrom: pretty sure thats valid hsc2hs
08:31:40 <geekosaur> so you still don't really know what you're up to
08:32:03 <merijn> geekosaur: What I have right now is this: http://hpaste.org/89152
08:32:09 <monochrom> ok, I guess that works too
08:32:18 <merijn> geekosaur: I'm really not sure how the termios struct could be getting borked...
08:32:48 <startling> monochrom: is #{...} another way to do it? weird.
08:32:49 <geekosaur> mhrm, ideone.com does not like chrome or vice versa...
08:32:58 <monochrom> um, poke ptr (Triple_IntHs a' b') looks wrong. where is c' ?
08:33:39 <Zeev> monochrom: sry it's just halfway
08:33:47 <monochrom> also, I am unconvinced of #poke Triple_IntHs. shouldn't it be #poke triple_int?
08:33:53 <Zeev> I didn't get to that compiler error yet
08:34:14 <geekosaur> fruitFly, http://ideone.com/ahnYIp
08:34:18 <fruitFly_> geekosaur: bytes is coming from the case ... what's the easiest way to pull it out?
08:34:44 <fruitFly_> geekosaur:  THANKS!!!
08:34:49 <Zeev> monochrom: I will repost
08:34:52 <fruitFly_> geekosaur: it works... i am haskell god
08:34:53 <fruitFly_> jk lol
08:36:17 <monochrom> oh, the filename, don't you have to call it *.hsc rather than *.hs?
08:36:17 <geekosaur> merijn, what platform is this on? I've seen some platforms where termios doesn't actually capture the entire "native" terminal configuration (I recall that from older freebsd, for example)
08:36:32 <geekosaur> (like 4-STABLE freebsd)
08:36:37 <fruitFly_> geekosaur: that looks almost like a list comp with <- ... i don't even remember if they went over that in lyah ... probably did.. i'll look back ... i am only on the modules chapter.. just getting some practicvec
08:36:40 <fruitFly_> THANKS
08:37:00 <merijn> geekosaur: OSX
08:37:00 <geekosaur> not a list comprehension, no; list comps do have a certain similaroty to do syntax though
08:37:05 <geekosaur> hrm
08:37:16 <merijn> geekosaur: Well, if I use it in a C environment it seems to work
08:37:25 <merijn> Actually...lemme check that
08:37:59 <geekosaur> so the BSD observation may actually be relevant because OS X lifted most of this from freebsd...
08:38:55 <merijn> hmm, I'll investigate the difference between my example C code (which seems to work) and my haskell version...
08:39:56 <beefcube> I'm stumped by this error:  http://hpaste.org/89156, usually this is fixed by adding type constraints at the right spots, but that isn't working.
08:40:12 <geekosaur> that said, I would aoso check whether "stty pendin" fixes your shell; I don't *think* it's relevant to "line breaking"
08:40:33 <merijn> beefcube: It means it can't decide *which* random instance to use
08:40:45 <beefcube> merijn: oh
08:41:02 <geekosaur> (whatever exactly you mean by that, it could be related to input newline conversion, output newline conversion, or several other things)
08:41:14 <merijn> beefcube: You never use gen anywhere
08:42:01 <merijn> beefcube: Normally it'd use the type of gen to infer which Random instance to use in the recursion to neighbours, but since you pass gen', which has type a, it can't select which one to use
08:42:40 <merijn> geekosaur: I mean that if my shell reaches the last line of my terminal and I type "ls\n" it prints all output on the same line (i.e. the last one)
08:42:46 <merijn> whereas normally it'd scroll down
08:43:08 <geekosaur> oh
08:43:15 <geekosaur> I don't think that's termios
08:43:38 <geekosaur> something is not outputting the terminal reset sequence, when the terminal init sequence tells your terminal / emulator to disable scrolling or something
08:43:39 <merijn> reset fixes the issue
08:43:59 <geekosaur> reset outputs the terminalinit strings as well as fiddling termios
08:44:15 <geekosaur> (cf. tput reset, tput init)
08:44:42 <merijn> Shouldn't top exiting output the code to enable scrolling?
08:45:13 <merijn> Right now it's running "top" and just directly copying all in- and output
08:45:40 <merijn> When I hit 'q' top exits and my code hits the case where it reads "" from the pty, which causes it to exit
08:45:58 <geekosaur> it should, yes, but you may be failing to flush the buffer containing the last few characters before resetting termios, or perhaps you should be using TCSADRAIN
08:46:38 <merijn> geekosaur: But it shouldn't be possible to read "" from the pty until everything has been drained already, no?
08:46:54 <geekosaur> no, that's reading from the pty, not writing to your output?
08:47:45 <merijn> oh, true
08:49:21 <merijn> Something odd seems to be happening anyway, as it doesn't seem to be getting the right terminal size either...
08:49:40 <merijn> Maybe that's what's going wrong
08:49:43 <geekosaur> are you configuring the pty properly?
08:50:07 <geekosaur> usually you want to copy the original termios settings for the real terminal to the settings for the pty
08:51:00 <geekosaur> in particular, it's probably defaulting the terminal size instead of using the real one, so you'd either need to copy those to the pty's own termios or set $LINES and $COLUMNS in the environment before spawning the program to run in the pty
08:51:42 <geekosaur> (also note that real programs probably want to trap SIGWINCH and re-copy the "real" tty size to the pty's size)
08:51:55 <merijn> I'm just using forkpty and passing NULL for the termios and size
08:52:13 <merijn> Which should inherit the values of the terminal of the program calling forkpty
08:52:36 <merijn> geekosaur: oh, sure. but I figure I should first get the simple case working before worrying about that :p
08:52:58 <randomclown> is there a way to do  (if x then 1 else 0) without using the enum thing?
08:53:35 <geekosaur> um, docs here imply the size is not set at all if you don't pass a termios
08:54:05 <merijn> randomclown: fromBool in Foreign.Marshal.Utils
08:55:49 <randomclown> merijn: ugh yuck
08:56:24 <geekosaur> what's the problem with fromEnum?
08:56:25 <geekosaur> if you
08:56:35 <geekosaur> 're asking if haskell will do duck typing for you, the answer is no
08:57:23 <monochrom> in fact, why do you convert Bool to 0 and 1?
08:57:31 <randomclown> monochrom: bit fiddling
08:57:59 <randomclown> I was convering [Bool] -> Int
08:58:48 <merijn> geekosaur: bah, you're absolutely right >.<
08:58:56 <merijn> Explicitly copying the size works
08:58:58 <monochrom> then I have a better idea
08:59:37 <monochrom> f (True:bs) = 1 + 2 * f bs; f (False:bs) = 2 * f bs
08:59:39 <mekeor> > sum . zipWith (\n b -> if b then 2^n else 0) [1..] $ [True,False,True,True]
08:59:40 <lambdabot>   26
09:00:00 <paullik> is there a way I could rewrite the lambda in point free style: http://hpaste.org/89159 ?
09:00:07 <mekeor> > sum . zipWith (\n b -> if b then 2^n else 0) [1..] . reverse $ [True,False,True,True]
09:00:08 <lambdabot>   22
09:00:45 <elliott> what is the point of the zipWith?
09:00:46 <elliott> oh
09:01:01 <monochrom> but then another question is: why is there [Bool] in the first place?
09:02:07 <oio> how do you make a function that opens a file and outputs the string
09:02:11 <monochrom> [Bool] looks like something not from the world or user, but rather you take world/user's input and convert to [Bool] as a middleman
09:02:13 <Zeev> basically what I wanted to ask is like that: I've successfuly compiled and ran this: http://stackoverflow.com/a/1028417/2420939 also I've successfully called a c function from my dll: http://hpaste.org/89158 , my aim is to call some functions from windows' gdi+ dll which require marshalling some structs.
09:02:13 <Zeev> Now I wrote my own c++ dll, which accepts a ptr to a struct, and puts the result of addition of first 2 members within that struct into 3rd member
09:02:18 <oio> like  :: IO () -> String
09:02:22 <mekeor> @pl \a -> putStrLn "" >> mapM_ print a -- paullik, let's see...
09:02:22 <lambdabot> (putStrLn [] >>) . mapM_ print
09:02:27 <mekeor> not nice :/
09:02:29 <monochrom> and I usually like to kill the middleman
09:03:03 <paullik> mekeor, can you please explain what you just did? and what is >>? (i'll hoogle this)
09:03:18 <merijn> oio: How could "IO () -> String" ever output a string?
09:03:22 <geekosaur> Zeev, C++ from anything other than C++ requires some ```extern "C"``` glue in or around the C++ code
09:03:27 <merijn> oio: Also, output to where?
09:03:36 <paullik> oh man monads :)) I really need to advance through lyah.com
09:03:40 <Zeev> geekosaur: C *
09:03:52 <mekeor> paullik: http://hpaste.org/89159
09:03:53 <merijn> paullik: Monads are overhyped
09:04:06 <merijn> paullik: Focus on understanding types and typeclasses and monads will be trivial
09:04:14 <geekosaur> monads are easy. IO is the cesspool
09:04:28 <oio> i have several functions that repeat the same procedure of opening a file
09:04:32 <monochrom> Zeev: in fact I think even the struct has to be inside extern"C"
09:04:32 <mekeor> paullik: "foo >> bar" is like "do { foo; bar }" :)
09:04:55 <oio> i would like a to make a function that opens the file and returns the string?
09:05:10 <monochrom> if only because: outside extern"C", you get name mangling
09:05:31 <merijn> oio: Then you probably want "IO () -> IO String", have you looked at "readFile :: FilePath -> IO String"?
09:05:35 <mekeor> oio: readFile?
09:05:45 <geekosaur> monochrom, if it doesn't have any member functions then it's just a struct and directly C compatible. (even if you call it a class! by itself, that just controls whether symbols are visible or not)
09:05:50 <oio> yeah i use openFile
09:06:06 <paullik> mekeor, yep, it makes sense now that I read the doc on hackage, but the function signature is still blurry, I'll bother with it after I learn about monads
09:06:12 <paullik> mekeor, dully noted
09:06:16 <monochrom> yeah I am not worrying about addresses here
09:06:18 <geekosaur> also, name mangling applies only to functions
09:06:18 <paullik> merijn, ^
09:06:32 <merijn> openFile "foo" ReadMode >>= hGetLine :: IO String
09:06:33 <mekeor> paullik: ok :)
09:06:34 <geekosaur> structs don't have overloadable parameters to mangle into their names
09:06:39 <geekosaur> nor do classes
09:06:45 <monochrom> ok that's nice
09:06:57 <paullik> thanks, again!
09:07:07 <mekeor> np
09:07:13 <geekosaur> (a class with inheritance probably isn't compatible but that's because inheritance in and of itself brings in extra goop, not because of name mangling)
09:07:33 <oio> "openFile "foo" ReadMode >>= hGetLine :: IO String" i dont thin i understand that..
09:08:06 <merijn> Or maybe you want "foo :: FilePath -> IO (IO String); foo path = do { hnd <- openFile path ReadMode; return (hGetLine hnd) }"
09:08:37 <oio> mmmm
09:08:39 <merijn> oio: "openFile "foo" ReadMode" has type "IO Handle", in other words, it's an IO action that opens a file and produces a Handle to it
09:09:16 <oio> oooo.. return would do the trcik
09:09:46 <merijn> "hGetLine :: Handle -> IO String", iow, it's a function that, given a Handle, returns an IO action that reads a String from the Handle
09:10:35 <merijn> foo is a function that takes a path and returns an IO action that produces an IO action that reads a line from the file
09:10:59 <Zeev> monochrom: ok, but could you direct me, considering my successful attempt at compiling&running: http://hpaste.org/89150 direct me to text that will help me successfully compile and run: http://hpaste.org/89158
09:11:28 <oio> thnx
09:11:47 <Zeev> monochrom: http://hpaste.org/89150 <--> http://hpaste.org/89158 *
09:11:57 <monochrom> yeah, I was wondering
09:20:28 <jonkri> it seems like ghc 7.2.2 cannot be build using ghc 7.4.1 (base dependency is missing). how can i resolve this?
09:21:39 <simon> @pl \ (_,_,_,x,_) -> x
09:21:39 <lambdabot> (line 1, column 8):
09:21:40 <lambdabot> unexpected "_"
09:21:40 <lambdabot> ambiguous use of a non associative operator
09:21:54 <simon> @pl \(a,b,c,d,e) -> d
09:21:54 <lambdabot> (line 1, column 7):
09:21:54 <lambdabot> unexpected "c"
09:21:55 <lambdabot> ambiguous use of a non associative operator
09:22:28 <geekosaur> simon, arbitrary tuples can't be made pointfree
09:22:40 <simon> I miss ML's #4 macro!
09:23:17 <merijn> simon: Sounds like you want Control.Lens!
09:23:27 <simon> it does.
09:23:29 <merijn> > _4 & (1,2,3,4,5)
09:23:30 <lambdabot>   Couldn't match expected type `(p0 a0 (f0 b1) -> s0 -> f0 t0) -> b0'
09:23:30 <lambdabot>        ...
09:23:33 <merijn> hmm
09:23:34 <Taneb> > (1,2,3,4,5) ^. _4
09:23:35 <lambdabot>   4
09:23:37 <merijn> I suck at lens, though
09:23:40 <merijn> Ah, there we go
09:26:05 <merijn> Whoo!
09:26:15 <merijn> I think I've found my error from earlier this morning
09:26:43 <merijn> Apparently calling fdToHandle on the same fd multiple times breaks things
09:26:51 <merijn> Which idiot came up with that? >.<
09:26:51 <geekosaur> yes?
09:27:07 <elliott> that sounds unavoidable
09:27:10 <elliott> if a handle stores buffers
09:27:13 <geekosaur> I think that's (a) documented (b) a good way to confuse the heck out o the runtime
09:27:20 <merijn> geekosaur: Well, the not scrolling bug was not explicitly setting the size
09:27:27 <geekosaur> as elliott says
09:27:49 <merijn> I will just have to change my newtype to be (Fd, Handle) then
09:28:45 <merijn> I don't actually want a Handle, though. It's just there's no "Fd -> Int -> IO ByteString"
09:29:40 <merijn> So now I have to decide between implementing "Fd -> Int -> IO ByteString" myself using read(2) or to change my datatype to just track both the handle and Fd
09:30:46 <mekeor> assume "f :: IO Int" and "g :: IO ()", then compiling "main = do { f; g; ... }" gives an error for f saying that you should write "do { _ <- f; ...}" instead. why don't you get this error for g?
09:31:20 <mekeor> why is () treated differently? just curious...
09:31:36 <Botje> () carries no information.
09:31:45 <yitz> @type System.Posix.IO.ByteString.fdRead -- merijn
09:31:46 <lambdabot> System.Posix.Types.Fd -> System.Posix.Types.ByteCount -> IO (String, System.Posix.Types.ByteCount)
09:32:03 <mekeor> s/error/warning/g
09:32:07 <geekosaur> because there's no such thing as returning nothing, and () is information free, so IO () is treated as "void" for convenience
09:32:15 <mekeor> Botje: so, would i as well do not get this warning for "h :: IO Foo" with "data Foo = Foo" as well?
09:32:25 <dmwit> geekosaur: pfft, void is just a hack for ()
09:32:27 <mekeor> geekosaur: ↑
09:32:34 <ion> You would get the warning.
09:32:40 <dmwit> If you could just return and store void's, I would even call it a synonym. =)
09:32:40 <mekeor> hah!
09:32:44 <merijn> ion: oh, neat
09:32:51 <merijn> I wonder why hoogle didn't find that
09:33:13 <mekeor> you meant yitz...
09:33:21 <merijn> eh, yeah
09:33:25 <merijn> I can't type
09:33:32 <geekosaur> mekeor, it's only implemented for () because its behavior is well defined; ghc does not presume to know what you might be up to with 'data Foo = Foo' and in fact probably assumes you;re up to type hackery that it should not get in the way of
09:34:03 <mekeor> ... key ...
09:34:15 * mekeor is not satisfied :P
09:34:28 <elliott> mekeor: it's not an error
09:34:31 <elliott> it's just an annoying warning.
09:34:34 <elliott> you can turn it off
09:34:37 <mekeor> <mekeor> s/error/warning/g
09:34:45 <elliott> ok. you can still turn it off
09:34:51 <mekeor> elliott: actually, you have to turn it ON, don't you?
09:35:11 <elliott> yes. but most likely you want to -Wall and then turn off the bad ones
09:35:42 <geekosaur> that said, it is really just a convenience "hack" so people don;t have to throw away useless ()s all the time
09:35:45 <geekosaur> explicitly
09:35:47 <geekosaur> because really, who wants to have to write _ <- putStrLn "foo" all the time?
09:35:48 <mekeor> yep... but that wasn't my question ;)
09:36:11 <mekeor> geekosaur: nope, of course not :D
09:36:12 <merijn> I don't even write "_ <-" for non () IO actions
09:36:33 <mekeor> but wouldn't it be nice if this behaviour was valid for ALL types?
09:36:39 <geekosaur> no
09:36:40 <merijn> "-fno-warn-unused-do-bind"
09:36:41 <mekeor> i mean, without disabling it..
09:37:13 <mekeor> geekosaur: why is it good to be warned?
09:37:26 <geekosaur> because ghc would have to figure out if its really a void type or whether something more interesting is happening (since void types often indicate type hackery is going on)
09:37:29 <merijn> Because you might be forgetting to use a result you wanted
09:37:49 <elliott> who wants to have to write _ <- forkIO $ ... all the time?
09:37:54 <elliott> (ok, forkIO may be a bad example)
09:37:55 <geekosaur> and arbitrarily throwing out *non*void results is usually either a bug or insufficient validation
09:38:12 <geekosaur> (although the latter is, correctly speaking, an aspect of the former)
09:38:20 <elliott> lots of things return optional results you probably don't care about. in the data-lens era, all the State modification stuff returned the value
09:38:22 <geekosaur> it's like writing code without error checking
09:38:25 <elliott> and it was incredibly annoying
09:38:36 <elliott> and now lens has twice the number of State monad operators because of that one warning
09:38:48 <mekeor> :D
09:38:50 <edwardk> foam padding the world makes me sad
09:39:59 <edwardk> the place where it really troubles me is parsing combinators. it is occasionally useful to let parsers like char 'x' return the character they parsed
09:40:07 <edwardk> that way char 'x' | char 'y'   does something useful
09:40:31 <edwardk> but in light of the 'you must use the return type' noise, that makes parsers generally suck to write
09:40:36 <yitz> merijn: sorry got stuck on the phone after i typed that /:
09:41:07 <yitz> it's unix-specific, but low-level fd's are kinda like that
09:41:37 <merijn> yitz: I'm working with pty's and fork, I don't think the portability of fd's is gonna be a problem :p
09:41:47 <yitz> merijn: ok good :)
09:43:18 <merijn> Semi-related, is there a way to get access to CPP defines using the FFI?
09:43:36 <monochrom> Zeev: http://hpaste.org/89167
09:43:59 <yitz> edwardk: as a habitual consumer of parser libraries, but not a producer, i can't imagine writing nice readable parsers without them returning what they match
09:44:00 <dmwit> merijn: The old way is to write a function that wraps the define.
09:44:08 <dmwit> merijn: There's a new way, but I don't know it.
09:45:41 <edwardk> yitz: and yet we have to either make them not return or clutter up every parser since that warning went into GHC with void or use OPTIONS_GHC to shut off the warning =(
09:48:08 <merijn> dmwit: Looks like I want CApiFFI
09:48:22 <dmwit> edwardk: ...or bake the fmap in, I guess
09:48:28 <dmwit> char :: (Char -> a) -> Parser a
09:48:47 <elliott> dmwit: finally we can write our monadic code in explicit CPS style
09:48:48 <dmwit> char keep :: Parser Char; char toss :: Parser ()
09:49:14 <dmwit> eh, I wouldn't go that far
09:49:25 <edwardk> i do find it hilarous that 'void $' is longer than '() <$'
09:50:08 <startling> char' :: Char -> Parser ()
09:50:22 <startling> I guess char_ is more idiomatic
09:50:22 <dmwit> startling: Duplicating every function twice sucks.
09:50:32 <startling> dmwit, tell that to Control.Monad
09:50:34 <dmwit> Duplicating every function once sucks.
09:50:47 <merijn> Bah, the example doesn't seem to work, though :(
09:50:58 <dmwit> startling: "It's been done, therefore it isn't horrible."?
09:51:05 <edwardk> i just use char :: Char -> m Char  -- then use *> and <* a lot explicitly
09:51:12 <startling> (</>) :: Parser a -> Parser b -> Parser ()
09:51:21 <edwardk> idiomatically that seems to work
09:51:55 <startling> where is the return type annoying other than <|>?
09:52:02 <hpc> i just noticed one of my projects now has a dependency on old-locale
09:52:08 <hpc> but there's no locale package
09:52:22 <dmwit> Yes, old-locale is one of the funniest lies.
09:52:29 <hpc> haha
09:52:37 <krsrk> Is there a easy way to replace part of a list, e.g replace 3 [8,7,7,7,7,7, 7] [9,3,4] = [8, 7, 7, 9, 3, 4, 7]
09:52:42 <hpc> ill just add it to the cabal file, then :P
09:54:00 <yitz> edwardk: oh, the warning, i see. ugh.
09:54:20 <supki> > [8,7,7,7,7,7,7] & partsOf (dropping 3 traverse) .~ [9, 3, 4]
09:54:22 <lambdabot>   [8,7,7,9,3,4,7]
09:54:47 * hackagebot pipes-parse 1.0.0 - Parsing infrastructure for the pipes ecosystem  http://hackage.haskell.org/package/pipes-parse-1.0.0 (GabrielGonzalez)
09:54:58 <startling> it'd be funny if "locale" was something completely different
09:55:04 <startling> GPS interfacing in haskell?
09:55:30 <edwardk> i always joked that it was really nice of them to leave me the name 'locale' ;)
09:56:54 <mekeor> what's the best way to split "foo*bar+(asdf-qwer)" into ["foo","*","bar","(asdf-qwer)"]?  – or should i really use parsec? :/
09:57:33 <krsrk> supki, thx
09:57:34 <krsrk> take n x ++ y ++ drop (length x+y) x
09:57:44 <yitz> edwardk: the bright side is that it will encourage people to use applicative notation more
09:57:48 <krsrk> not sure which is better
09:58:07 <mekeor> mekeor: when manually doing it, the problem is in case of nested parantheses...
09:58:08 <edwardk> mekeor: parsec or the expression parser in parsers
09:58:08 <elliott> that one repeats work
09:58:32 <mekeor> elliott?
09:58:37 <elliott> that was to krsrk
09:59:47 * hackagebot avr-shake 0.0.0.1 - AVR Crosspack actions for shake build systems.  http://hackage.haskell.org/package/avr-shake-0.0.0.1 (JamesCook)
10:00:01 <mekeor> edwardk: parsers?
10:00:18 <mekeor> do you mean Text.Parsec.Expr or Text.ParserCombinators.Parsec.Expr or so?
10:00:35 <yitz> some should really write a locale package already. it's one of things that we really really need but is really really no fun to write.
10:01:04 <mekeor> what about old-locale? is it obosolete?
10:01:22 <yitz> mekeor: it was pretty much vacuous to begin with
10:01:26 <hpc> hmm, another question; i am having an issue with cabal-dev
10:01:39 <hpc> i have a package installed locally that isn't on hackage
10:01:44 <hpc> and another package that depends on it
10:01:52 <hpc> the depend was installed with cabal as user
10:02:01 <hpc> the target package is cabal-dev'd
10:02:08 <hpc> and i am getting this error with --verbose
10:02:09 <hpc> http://hpaste.org/89169
10:02:21 <yitz> hpc: cabal and cabal-dev don't mix well
10:02:27 <hpc> :(
10:02:44 <hpc> how do i resolve it?
10:02:56 <yitz> hpc: after each ghc/haskellplatform install i run cabal install exactly once: cabal install cabal-dev
10:03:17 <hpc> yitz: i usually do too, except in this case
10:03:30 <hpc> what should i do to get this package to build?
10:03:58 <yitz> hpc: if it were me i would re-install ghc/haskellplatform (takes only a few minutes) and then forget about cabal, except when you are using a new enough ghc to get cabal's new built-in sandboxing
10:04:42 <sm> just installing your non-hackage package again using cabal-dev should help, no ?
10:05:12 <yitz> hpc: as a temporary measure you could hide the user-global package db and then cabal-dev add-source. but just reisnstalling is actually easier and faster.
10:05:19 <quchen> When I open a new Socket using listenOn, it's fairly easy to get the port the Socket is using out of it (using socketPort). Is there an analogon to get the hostname?
10:06:19 <jmcarthur> oh pipes-parse is finally on hackage
10:06:20 <quchen> What I'm basically trying to do is to connect to another server, and tell it how to connect back to myself after the connection is closed.
10:06:23 <yitz> hpc, sm: hmm, yes, worth a try to use cabal-dev add-source without the re-install
10:06:35 <hpc> yitz: i don't think you understand my problem; i am not using cabal for any real packages; this instance of mixing cabal/cabal-dev was just me testing to see how to get it to recognize the depend
10:06:47 <hpc> all i want is for both packages to build
10:06:54 <oio> do nothing on a IO String type function?
10:07:00 <yitz> hpc: why won't add-source do it?
10:08:02 <hpc> trying
10:09:40 <geekosaur> oio, define "do nothing"
10:09:52 <hpc> yitz: it works now
10:10:31 <oio> nth :: IO (); nth = return ()
10:10:40 <geekosaur> just being in IO does not mean you can arbitrarily fail to return anything (except the way any function can, by using undefined or error); you may want an IO (Maybe String)
10:11:24 <oio> nth :: IO String ; nth = return () won't work
10:11:26 <jmcarthur> :t empty :: IO a
10:11:27 <elliott> well, technically IO gives you more ways of arbitrarily failing to return anything...
10:11:28 <lambdabot>     No instance for (Alternative IO)
10:11:28 <lambdabot>       arising from a use of `empty'
10:11:28 <lambdabot>     Possible fix: add an instance declaration for (Alternative IO)
10:11:34 <elliott> like exitSuccess
10:11:35 <jmcarthur> :t mzero :: IO a
10:11:37 <lambdabot> IO a
10:11:38 <startling> oio, const $ return ()
10:11:46 <elliott> startling: huh?
10:11:47 <startling> oh
10:11:52 <startling> misread that.
10:12:07 <jmcarthur> :t exitSuccess
10:12:09 <lambdabot> Not in scope: `exitSuccess'
10:12:24 <geekosaur> it's in System.Exit
10:15:46 <merijn> The GHC manual says I can use the capi calling convention for import CPP defined constants as values, but when I try this I get errors that the symbol ghc_wrapper_<mangled>_<name> can't be found
10:16:07 <merijn> http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi.html#ffi-capi
10:16:45 <tfan> hi all!!!
10:16:51 <mekeor> hi tfan :)
10:16:59 <merijn> Or is that a question for #ghc?
10:23:38 <meretrix> Hi. Could anyone assist me in creating a FromField instance? http://hpaste.org/89174
10:23:48 <meretrix> All of the internal types have me confused..
10:24:47 <tfan> I've question, I want to make a mini compilator for lisp with haskell, i did the lambda, let , list and type, but i'don't know how to make a Filtering lists exemple (case e b1 .. bn) it must be only with (cons and nil)
10:25:06 <tfan> anyone have an idea about this ?
10:27:50 <harrison> riddle: How is a migraine different from anything?
10:27:57 <harrison> A: Doing so makes the pain worse
10:29:35 <elliott> i don't get it
10:31:02 <jmcarthur> trying to decide if it would be nice for Ptr to be an instance of Enum
10:31:04 <monochrom> merijn: it worked for me a few days ago. actual code? don't forgot that the string must have "value" in it, e.g., "woot.h value MEE" if you have #define MEE 4
10:31:11 <edwardk> mekeor: i mean
10:31:11 <jmcarthur> i guess the int conversions are not great
10:31:13 <edwardk> @hackage parsers
10:31:13 <lambdabot> http://hackage.haskell.org/package/parsers
10:31:20 <edwardk> http://hackage.haskell.org/packages/archive/parsers/0.8/doc/html/Text-Parser-Expression.html
10:31:20 <jmcarthur> the actual enumeration would be nice though :\
10:32:36 <mekeor> edwardk: thanks (and sorry for disturbing you! :D)
10:34:57 <monochrom> interesting, malloc doesn't care about alignment, alloca does
10:35:54 <merijn> monochrom: It's a bug
10:36:05 <merijn> monochrom: It works in ghc, but ghci breaks
10:36:16 <merijn> monochrom: Probably no one tested that :p
10:36:30 <merijn> See here for minimal test case: http://hackage.haskell.org/trac/ghc/ticket/7955
10:39:03 <monochrom> I think they know. their method is: generate a C function that simply returns the 4, compile it, then tell the Haskell code to foreign-import and call that C function. this is supposed to be outside ghci's realm
10:39:08 <dmwit> tfan: Your question doesn't make a lot of sense to me.
10:39:20 <dmwit> I suspect other people feel the same way, and that's why you're not getting a lot of response.
10:40:13 <dmwit> ghci does other FFI stuff fine
10:40:56 <merijn> monochrom: Other FFI stuff works fine and I got told to file a bug in #ghc, so
10:41:22 <monochrom> foreign export is another thing ghci refuses to do
10:41:42 <merijn> You can load a module with foreign export just fine
10:42:01 <merijn> And accessing a foreign export from within ghci doesn't make any sense to me
10:42:15 <merijn> Whereas calling a foreign imported function/value *does* make sense
10:44:19 <monochrom> no, foreign export gets me "Illegal foreign declaration: requires via-C, llvm (-fllvm) or native code generation (-fvia-C)"
10:45:36 <merijn> oh, hmm, you're right. Faulty memory
10:45:49 <monochrom> but I could "ghci -fobject-code"
10:46:51 <monochrom> as it happens, "ghci -fobject-code" also accepts value import
10:47:18 <dmwit> Hm, I see.
10:49:03 * monochrom contemplates "ghc -fbyte-code"
10:49:44 <monochrom> yikes, ghc ignores -fbyte-code :)
10:55:09 <fixme> > take 5 [1..]
10:55:10 <lambdabot>   [1,2,3,4,5]
11:08:18 <Entroacceptor> > [1..5]
11:08:19 <lambdabot>   [1,2,3,4,5]
11:08:25 <DanmerZ> [1..]
11:21:15 <Athas> One particularly annoying GHCi feature is that if I reload a module containing type errors, the resulting lexical environment will not contain any of the imports.
11:21:22 <Athas> Is there a way to work around this?
11:22:15 <shachaf> mgsloan: You should do a talk on lens!
11:22:43 <mgsloan> shachaf: are you referring to Seafunc?
11:22:55 <shachaf> Of course.
11:22:59 <byorgey> Athas: if you have GHC 7.6, just do  ghci -fdefer-type-errors
11:23:06 <shachaf> I still get emails from there for some reason.
11:23:19 <Athas> byorgey: I suppose that is a solution.  Thank you.
11:23:49 <pferor> Hi, I'm trying to convert a list like [True, False, False, True, False, True] to [1,2,1,1,1], counting ocurrences. but I don't know how to approach. Any clue what functions should I read the reference of?
11:23:54 <byorgey> Athas: you don't seem very enthusiastic.  Is there something about it which isn't ideal in your situation?
11:24:12 <Athas> byorgey: no, sorry, that should work very fine, in fact.
11:24:16 <byorgey> ok =)
11:24:18 <mgsloan> shachaf: 'fraid I've got some catching up to do on the lens front, but I suppose I could give an intro thing
11:24:33 <Athas> I'm just surprised I didn't think of it myself, given that I've listened to at least two talks on that flag.
11:24:44 <joe9> this is not a haskell question, but, given the knowledge of folks here, wanted to check on this? I have straight edge that I want to convert to a round edge, using lots of vertex points to simulate a rounded edge.
11:24:54 <mgsloan> shachaf: This is actually the first time there's been a seafunc (since I found out about it / started going), that there's been a suggestion of presentations
11:24:54 <byorgey> pferor: 'group', 'map', 'length'
11:24:56 <byorgey> Athas: hehe =)
11:25:00 <joe9> Is there any way to generate such vertex points programmatically.
11:25:00 <pferor> thanks byorgey
11:25:17 <paullik> pferor, use map with a lambda like: \x -> if x then 1 else 2
11:25:29 <mgsloan> shachaf: Also, I've found that lispers generally respond poorly to lens.  You need to already have drunk the types kool-aid to buy into lens
11:25:42 <byorgey> paullik: I think pferor meant counting the number of consecutive identical values
11:25:57 <byorgey> pferor: [True,True,True] should give [3], right?
11:25:58 <pferor> right
11:26:03 <pferor> yes
11:26:12 <paullik> oh, man, my mistake, sorry
11:26:32 <pferor> byorgey, thanks. I got the solution now. I just needed to know that there is a group function
11:26:33 <ion> If base had a “bool”, bool 2 1. Alas, it doesn’t.
11:26:41 <paullik> yeah, the exmaple was pretty self explanatory, I didn't pay attention
11:26:48 <shachaf> mgsloan: You need to have drunk the immutability kool-aid to buy into lenses.
11:26:57 <ion> (Responding to paullik, not pferor)
11:27:02 <byorgey> joe9: I'm not sure I understand what you want.  what is a "round edge"?
11:27:28 <mgsloan> shachaf: That too :)  So I guess it's double trouble.  At least they've already drunk the abstraction kool-aid, though
11:27:30 <shachaf> And you can do a variation on the whole hierarchy without static typing if you like.
11:28:28 <mgsloan> Sure, structural or dynamic typing could actually work pretty well with lens stuff
11:28:29 <paullik> ion, yeah, you can't actually write bool 2 1, no?
11:29:16 <joe9> byorgey, I have a square polygon and I want to make the edges rounded. unfortunately, I do not have anything to draw a rounded edge. All I can do is to generate many vertex points around the edge to get a rounded edge.
11:29:30 <oio> can multi ways be used like case of?
11:29:42 <joe9> but, I have no clue about how to go about generating the vertex points to simulate a rounded egde.
11:29:47 <byorgey> joe9: oh, I see
11:29:47 <joe9> byorgey: does that make sense?
11:29:52 <byorgey> joe9: I think so
11:30:09 <ion> paullik: Well, bool f _ False = f; bool _ t True = t, but i just use a lambda expression like you wrote because bool doesn’t exist in something like Prelude or Data.Bool.
11:30:16 <byorgey> joe9: wait, maybe not quite.  Do you mean you want the *corners* to be rounded?
11:30:22 <paullik> ion, yep
11:30:35 <byorgey> if not, I am still not sure what you mean by a "rounded edge"
11:30:44 <joe9> byorgey: yes, the corners rounded.
11:31:01 <byorgey> ok.  shouldn't the vertices for a round corner just lie on a circle?
11:31:12 <joe9> yes, they doe
11:31:16 <joe9> s/doe/do/
11:31:36 <joe9> byorgey: I know the radius, etc.
11:31:57 <joe9> byorgey: I do not have the mathematical knowledge to figure out the points on a circle edge.
11:32:28 <dmwit> You could use the Bresenham algorithm. But surely you would rather just use a library that can draw arcs...?
11:32:38 <byorgey> joe9: ok.  and what are you using to draw these polygons?
11:32:57 <dmwit> (Fun fact: the algorithm wasn't actually invented by Bresenham. It's just named after him because it's inspired by his line algorithm.)
11:33:11 <byorgey> even without a library that can draw arcs, it would be way easier to compute rotations of points around a circle center than to use Bresenham.
11:33:22 <joe9> byorgey: it is a program called geda pcb in which I can input the vertexes of a polygon. I need to generate such vertexes outside that program.
11:33:35 <joe9> I could use haskell to generate such vertexes.
11:33:36 <byorgey> OK, I see.
11:34:15 <dmwit> Oh, if we're talking vector graphics, you don't want Bresenham, I agree.
11:34:52 <byorgey> joe9: I suggest using a Haskell library that can compute directly with 2D points and transformations
11:35:13 <byorgey> joe9: for example, diagrams is such a library (though it may be way overkill if you are not going to be using it to do any actual drawing)
11:36:00 <byorgey> in general, you want to do something like find a point at distance r from a vertex, perpendicular to the neighboring segment
11:36:18 <byorgey> then apply a rotation to that point (rotating around the vertex) to generate a series of points which lie along the circle
11:36:31 <joe9> yes
11:36:44 <byorgey> if you use a library which can do those things you don't need to know any of the underlying math, just how to use the library
11:36:45 * Athas wonders if -fdefer-parse-errors is next.
11:37:25 <byorgey> if you wanted to use diagrams for that I could help you figure out how
11:37:48 <joe9> byorgey: ok, just started reading up on diagrams. thanks for the hint.
11:38:34 <bad_alloc> Hello, I'm implementing a partial ordering based on a substring relation on lists for a college assignment (class POrd). I haven't quite understood how I can construct some list that is a partial ordering. What do I need to type into ghci to get one from this code?: http://cxg.de/_cdc79d.htm
11:39:53 <elliott> you'll want another instance of POrd
11:40:05 <elliott> since your only instance depends on another instance, you can't use it at all currently :)
11:41:18 <joe9> byorgey: let me join the #diagrams
11:41:25 <byorgey> joe9: sure
11:41:53 <meretrix> I'm trying to convert the output of a parser to an ADT using "read".  Is this the wrong approach? http://hpaste.org/89174
11:42:45 <meretrix> My thinking was the parser can already output a String, so why not just "read" it.
11:44:10 <dmwit> :i FieldParser ?
11:44:26 <dmwit> I'm guessing you're gonna need more fmaps.
11:44:38 <dmwit> Yeah, type FieldParser a = Field -> Maybe ByteString -> Conversion a
11:45:10 <meretrix> Ah, yeah that looks like it could help.
11:45:28 <dmwit> So you can go the explicit way "fromField f m = fmap read (fromField f m)" or the implicit way "fromField = fmap (fmap (fmap read)) fromField"
11:45:46 <bad_alloc> elliott: Does this mean i have to say (e.g.) that String is an instance of POrd?
11:45:52 <elliott> sure
11:45:54 <elliott> or ()
11:45:59 <dmwit> bad_alloc: I expect you will want to say that Char is an instance of POrd.
11:46:00 <elliott> or anything that doesn't erquire another pOrd instance to work :)
11:46:06 <elliott> oh, right, yeah, String is a bad example
11:46:11 <elliott> since it already is an instance, given one for Char
11:46:13 <dmwit> String is [Char], so it will overlap with your [a] instance.
11:46:45 <bad_alloc> I'll try that real quick.
11:46:56 <dmwit> (Or, the more optimistic way: by the time you've given an instance for Char you get an instance for String for free.)
11:47:16 <meretrix> Thanks dmwit, that was driving me crazy. :)
11:50:00 <bad_alloc> dmwit, elliott: "instance POrd Char" did the trick. Thanks for the help :)
11:51:26 <elliott> :)
11:53:52 <gertc> i am stuck at creating this proxy wai app http://hpaste.org/89177
11:54:49 * hackagebot temporal-media 0.3.3 - data types for temporal media  http://hackage.haskell.org/package/temporal-media-0.3.3 (AntonKholomiov)
11:54:51 * hackagebot temporal-music-notation 0.2.3 - music notation  http://hackage.haskell.org/package/temporal-music-notation-0.2.3 (AntonKholomiov)
11:54:54 * hackagebot temporal-music-notation-western 0.2.3 - western music notation  http://hackage.haskell.org/package/temporal-music-notation-western-0.2.3 (AntonKholomiov)
11:59:50 * hackagebot temporal-music-notation-demo 0.2.3 - generates midi from score notation.  http://hackage.haskell.org/package/temporal-music-notation-demo-0.2.3 (AntonKholomiov)
11:59:51 * hackagebot csound-expression 1.1.1 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-1.1.1 (AntonKholomiov)
11:59:53 * hackagebot temporal-csound 0.1.2 - brings together temporal-music-notation and csound-expression packages  http://hackage.haskell.org/package/temporal-csound-0.1.2 (AntonKholomiov)
12:00:02 <merijn> What's the minimal implementation of Enum?
12:01:02 <hpc> merijn: toEnum
12:01:14 <hpc> merijn: er, toEnum and fromEnum
12:01:30 <mekeor> maybe look at http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Enum.html#Enum
12:01:50 <hpc> succ, pred, enumFrom[Then][To] are all implemented in terms of succ/pred and [..] on Int
12:02:07 <dmwit> I don't believe you.
12:02:14 <dmwit> succ and pred throw exceptions.
12:02:24 <dmwit> enumFrom doesn't.
12:02:25 <hpc> dmwit: i used the sauce
12:02:48 <dmwit> crazy
12:02:54 <dmwit> How can that possibly work?
12:03:15 <hpc> i don't think it does
12:03:38 <dmwit> I'm lost.
12:03:53 <hpc> for an unbounded type, you can technically implement Enum correctly with just to/from
12:03:57 <dmwit> Oh, I misparsed your original question.
12:04:00 <dmwit> s/question/answer/
12:04:08 <hpc> and that's the minimal instance
12:04:13 <dmwit> You don't mean "enumFrom[Then][To] is implemented in terms of succ/pred in the Int instance".
12:04:27 <hpc> yeah
12:04:31 <dmwit> You mean "enumFrom[Then][To] have default implementations that use succ/pred on Ints".
12:04:36 <hpc> succ/pred in the instance, and [..] in the Int instance
12:04:45 <dmwit> okay
12:04:52 <dmwit> This I believe.
12:04:56 <hpc> enumFrom from = map toEnum [fromEnum from ..]
12:05:05 <hpc> which is horribly broken for bounded types
12:05:18 <dmwit> ...and for unbounded ones, too =)
12:05:27 <hpc> ;)
12:05:32 <yitz> gertc: why liftIO? that seems to be causing you trouble.
12:06:48 <yitz> gertc: besides that, you may have the number of parameters wrong. hard to tell; "Application" seems to be a type synonym
12:07:16 <yitz> gertc: what package is this in? wai? or is there some other wai-family package you are using?
12:07:34 <gertc> wai i will post the full code sec
12:10:18 <mekeor> "wai" – what an irony :D
12:12:25 <gertc> https://github.com/gertcuykens/haskell-design/blob/master/src/Main.hs
12:12:41 <gertc> lol
12:15:34 <gertc> so the thing is i want to replace $ middle $ staticApp ... with this proxy Application
12:16:29 <dmwit> merijn: (By the way, depending on what you're doing, you might like Universe/Finite instead of Enum.)
12:16:34 <dmwit> merijn: (shameless self-plug)
12:17:58 <dmwit> gertc: If you want help, the polite way to ask is to post a minimal, broken example, together with it's error.
12:18:10 <dmwit> If there's no error, you should say what you expected to happen and what happened instead.
12:18:19 <dmwit> s/it's/its/
12:19:28 <yitz> gertc: i can't find waiProxyTo in the wai package. there's actually not much there, it's just the basic interface. that's why i asked what package you are using. or did you write that yourself somewhere?
12:20:48 <gertc> http://hackage.haskell.org/packages/archive/http-reverse-proxy/0.1.1.6/doc/html/Network-HTTP-ReverseProxy.html
12:21:08 <yitz> dmwit: it's kind of hard with a web app like this. but the types should be helpful here, if we can see the signatures.
12:21:50 <yitz> dmwit: really i would say gertc could post this question to #yesod. but i just posted a question there, and it seems pretty quiet.
12:21:59 <dmwit> "minimal" doesn't necessarily mean "small".
12:23:06 <gertc> i was hoping it would be something stupid :)
12:24:36 <yitz> gertc: well as i said, waiProxyTo returns an Application, so you definitely do not want liftIO here
12:24:47 <merijn> dmwit: I'm encoding C enums/CPP defines, so I think those aren't really applicable :p
12:25:32 <dmwit> Okay. =)
12:25:39 <gertc> yitz, i will paste the reseult sec
12:26:11 <icarot> Is there a way to coerce a unary prefix operator to a postfix operator, just like a function can be coerced into an infix operator? I like the readability of, say, `if e isEofError then [..]` rather than `if isEofError e [..]`
12:26:14 <oio> haskell detect keypress in terminal?
12:26:26 <yitz> gertc: it actually looks quite simple to use this thing
12:27:13 <icarot> Better put, I just mean "Can you coerce a function to a postfix operator?"
12:28:02 <gertc> yea it probably is
12:28:38 <geekosaur> no and yes. there's a hack where you can use a unary infix as a postfix (I think it requires a language pragma to enable), but as with functions with alphanumeric names you would need to `` them to make them infix and I odn't know if that plays along with the pragma
12:28:38 <gertc> http://hpaste.org/89177
12:28:58 <yitz> gertc: i think the basic point is that the reverse proxy is a totally separate wai application from your actual web site.
12:29:25 <yitz> gertc: your web site is presumably running on some other server, or on this server on a weird port number
12:29:59 <geekosaur> icarot: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#postfix-operators
12:30:17 <yitz> gertc: then, separately, you run this proxy server to forward requests to the publicly visible url to your actual web server
12:30:20 <gertc> yes warp
12:30:43 <gertc> wait i have a beter example
12:30:58 <yitz> gertc: often you would just do this with, say nginx, or whatever, but this warp proxy is probably just as easy to set up. just a few lines of code.
12:31:14 <gertc> https://github.com/yesodweb/wai/blob/master/warp-static/warp.hs
12:31:43 <gertc> thats the static application
12:31:51 <gertc> in basic form
12:32:36 <gertc> now try to replace $ middle $ staticApp ... with my proxy1 or proxy2 paste
12:33:00 <yitz> gertc: ok, so you'll have two very small apps. one to run the static site somewhere hidden, and a proxy server to forward requests to the hidden static site.
12:33:05 <merijn> hmmm
12:33:35 <yitz> gertc: no why would you do that? the proxy server is a separate app, compiled separately, run separately.
12:34:20 <yitz> gertc: if they can run in the same process, then why proxy at all? just have the static app listen on whatever host and port you want
12:34:30 <merijn> An another API design question! When the process controlled via a pty dies, what should I do when a read/write is attempted to the terminal: 1) return ""/success 2) throw an exception 3) wrap all reads/writes in Maybe?
12:35:22 <gertc> in the end i just want to proxy every thing exept websocket request
12:35:39 <yitz> merijn: don't pty's just close when that happens?
12:36:15 <gertc> this waiProxyTo create a wai Aplication right just like the staticApp ?
12:36:22 <yitz> gertc: ok, so for a websocket request you return Left something. For everything else, you return Right <where to proxy to>.
12:36:23 <merijn> yitz: Yes, my question is: how would you prefer an API tells you that the pty has closed :p
12:36:44 <gertc> somthing like that but warp has a intercept for this
12:37:02 <gertc> so i just need to replcae the staticApp with a proxyApp
12:37:25 <gertc> and its alredeay designt to be a wai thing
12:37:45 <yitz> gertc: no you don't replace the static app. leave it just how it is.
12:38:28 <yitz> gertc: yes waiProxyTo creates its own separate wai app that you run separately.
12:38:58 <yitz> gertc: presumably on a different machine. or in a different process on a different port number.
12:39:36 <yitz> gertc: waiProxyTo will forward requests to your other app
12:40:06 <gertc> ok but the return type of waiProxyTo is the same as the return type of staticApp right?
12:40:54 <yitz> gertc: it gives you an Application, just like your web app does. each one runs its own warp server and passes its Application to it.
12:41:39 <gertc> can you show me a example using the small staticApp example?
12:43:02 <gertc> the problem is the websocet request and the proxy request use the same port
12:43:26 <oio> is there a non waiting version of nonchar
12:43:32 <yitz> gertc: you can set the port numbers to be whatever you want
12:43:52 <oio> or how yo put the terminal in modes from haskell
12:44:18 <gertc> yes but for firewall resons i can only use 80
12:45:19 <gertc> but if you can make a function i can replace the staticApp with i can figure things out from tjere
12:45:55 <gertc> i just stuck with this wai conduit manger stuff
12:46:09 <yitz> gertc: why do you want to replace the static app? what's wrong with it?
12:47:12 <gertc> nothing but i would understand more about this wai stuff if i know what i am doing :)
12:48:07 <oio> haskell tcsetattr?
12:48:23 <gertc> and i know its the same type so i know its possible to just replace it with aproxy function
12:49:38 <yitz> gertc: for proxying, you don't replace your web app. you leave it exactly as it is. you also write a second haskell program with a proxy app. compile both of them. run both of them.
12:50:48 <gertc> i agree but for now i just want to learn wai :)
12:51:25 <yitz> gertc: the proxy app will be something like: myProxyAp req = do if isWebSocket req then Left webSocketResponse req else Right (ProxyDest "example.com" 9999)
12:51:58 <gertc> ok testing somthing
12:52:53 <yitz> gertc: but don't you want to learn how to use wai to make something that actually works and you can try it? proxying doesn't work with just one app; it doesn't make sense (from a web programming point of view even, before you even get to wai)
12:56:52 <yitz> gertc: oh actually more like this: myProxyAp req | isWebSocket req = do response <-  webSocketResponse req; return (Left response) | otherwise = return (Right (ProxyDest "example.com" 9999))
13:03:58 <gertc> http://hpaste.org/89182
13:04:06 <dmwit> ?tell oio Perhaps you're looking for hSetBuffering, but I'm not totally sure.
13:04:07 <lambdabot> Consider it noted.
13:04:51 * hackagebot prizm 0.2.1.0 - A haskell library for computing with colors  http://hackage.haskell.org/package/prizm-0.2.1.0 (ParnellSpringmeyer)
13:04:55 <gertc> if can just make it compile without errors so i can learn from it
13:05:23 <gertc> it doesn't do anything i just want the type checker to be happy :)
13:06:09 <t4nk140> Great Haskell hive mind, is there an "opposite" of the join function?
13:06:23 <elliott> there's Comonad's duplicate
13:06:26 <elliott> w a -> w (w a)
13:06:37 <merijn> t4nk140: return?
13:06:42 <merijn> :t return
13:06:43 <lambdabot> Monad m => a -> m a
13:07:02 <t4nk140> hmmm...
13:07:04 <merijn> :t return :: Monad m => m a -> m (m a)
13:07:05 <lambdabot> Monad m => m a -> m (m a)
13:07:12 <merijn> :t join
13:07:13 <lambdabot> Monad m => m (m a) -> m a
13:07:26 <merijn> looks opposite to me?
13:07:48 <byorgey> t4nk140: it depends what you mean by "opposite"
13:08:22 <byorgey> if you mean "inverse", then the answer is not in general -- there would only be an inverse for certain special (and probably uninteresting) monads
13:09:34 <t4nk140> I guess I want to take [1,2,3] and get [[1],[2],[3]]
13:09:43 <dmwit> > map return [1,2,3]
13:09:44 <lambdabot>   No instance for (GHC.Show.Show (m0 a0))
13:09:45 <lambdabot>    arising from a use of `M38193841...
13:09:49 * dmwit sighs
13:09:53 <t4nk140> I feel like I've done this before, but I'm slipping
13:09:53 <dmwit> > map return [1,2,3] :: [[Integer]]
13:09:55 <lambdabot>   [[1],[2],[3]]
13:09:56 <Taneb> > map (:[]) [1,2,3]
13:09:57 <lambdabot>   [[1],[2],[3]]
13:10:01 <dmwit> > return [1,2,3] :: [[Integer]]
13:10:02 <lambdabot>   [[1,2,3]]
13:10:09 <acube> > duplicate [1,2,3]
13:10:10 <lambdabot>   Not in scope: `duplicate'
13:10:11 <lambdabot>  Perhaps you meant one of these:
13:10:11 <lambdabot>    `replicate' (...
13:10:29 <dmwit> > transpose (return [1,2,3])
13:10:31 <lambdabot>   [[1],[2],[3]]
13:10:42 <t4nk140> nice, I see
13:10:54 <merijn> > map pure [1,2,3] :: [[Integer]] -- if we're listing alternative spellings
13:10:56 <lambdabot>   [[1],[2],[3]]
13:10:58 <dmwit> (The transpose one is a bit of a joke.)
13:11:03 <byorgey> t4nk140: right, so merijn's answer was the closest, but it turns out that 'return' and 'map return' are both good candidates for "opposite of join"
13:11:13 <byorgey> you happen to want  'map return'.
13:11:31 <merijn> Man, I wonder if I could mention "was right N times on #haskell" on my resume :p
13:11:46 <dmwit> :t (>>= (return . return))
13:11:47 <byorgey> haha
13:11:47 <lambdabot> (Monad m1, Monad m) => m a -> m (m1 a)
13:11:55 <merijn> Haddock is misbehaving! >:(
13:12:14 <efie> is it possible to export a function in a module but don't show in the documentation when generating the documentation with haddock?
13:12:21 <dmwit> > (>>= (return . return)) [1,2,3] :: [[Integer]]
13:12:22 <lambdabot>   [[1],[2],[3]]
13:12:29 <merijn> The Haddock manual says the documentation of partially reexported modules will be included in the generated page, but it's not for me
13:12:41 <dmwit> (I would spell that with fmap if only Functor were a superclass of Monad. ;-)
13:12:43 <merijn> efie: Yes, there's a haddock option in the manual, I forgot what it was though
13:13:31 <ion> dmwit: Any day now.
13:13:53 <yitz> oops t4.... is gone
13:14:39 <yitz> even though people here may not like it, the spelling readers of t4....'s code would probably prefer is: map (:[])
13:15:15 <dmwit> That was one of the very first suggestions.
13:15:33 <ion> @type fmap pure
13:15:34 <lambdabot> (Functor f, Applicative f1) => f a -> f (f1 a)
13:15:45 <efie> merijn: thank's I will look though it
13:15:53 <dmwit> @type [pure, fmap pure]
13:15:55 <lambdabot> Applicative f => [f a -> f (f a)]
13:16:01 <acube> @hoogle (Functor f) => f (t a) -> t (f a)
13:16:02 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
13:16:02 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
13:16:02 <lambdabot> Test.QuickCheck.Gen promote :: Monad m => m (Gen a) -> Gen (m a)
13:16:34 <dmwit> :t Data.Traversable.traverse
13:16:35 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
13:16:59 <dmwit> > Data.Traversable.traverse pure [1,2,3] :: [[Integer]]
13:17:00 <lambdabot>   [[1,2,3]]
13:17:16 <dmwit> That's probably a law, huh?
13:17:21 <dmwit> traverse pure = pure?
13:17:23 <elliott> yes
13:17:33 <elliott> the traverse laws are the functor laws, "lifted up"
13:17:42 <dmwit> right
13:17:52 <dmwit> Functor1 ;-)
13:19:16 <yitz> gertc: for proxy1, start with proxy1 _ = do (i.e. add the _). see if that compiles.
13:19:31 <elliott> () parameters :(
13:19:40 <acube> What are the laws for distributive? Also the functor laws, but lifted up?
13:19:42 <elliott> ...assuming this is about the pipes proxy
13:19:56 <yitz> gertc: look carefully at the type of waiProxyToSettings and see if you can do something similar to get that one to compile.
13:20:11 <elliott> acube: hm, interesting question. I bet edwardk knows
13:20:57 <efie> Hm I found the  " prune" attribute, but I'd like to hide specific functions from the documentation
13:21:57 <pantsman> I just installed the newest version of Haskell Platform (for Windows) and it's no longer reading my .ghci script, any ideas?
13:24:04 <yitz> pantsman: rename it (so that ghci doesn't automatically run it), then try it manually line by line until you see what fails. (if there aren't too many lines)
13:24:47 <merijn> yitz: If there are too many lines you can always binary search
13:25:03 <yitz> dmwit: in that case, you gave the best two answers :)
13:25:34 <pantsman> yitz, I have reduced it down to a single line, :set prompt "ghci> ", yet ghci still opens with "Prelude >"
13:26:33 <yitz> hmm, that changed? doesn't make sense.
13:27:31 <yitz> pantsman: maybe some weird character? maybe indentation?
13:27:46 <pantsman> I wonder if it's changed the directory it expects to find .ghci (which wouldn't surprise me since this is Windows)
13:29:53 <pantsman> ha! I have figured out what it is
13:30:35 <pantsman> the installation replaced my shortcut to ghci so it was configured to open with the installation directory as the cwd, not the user home
13:31:23 <pantsman> thanks anyway, yitz
21:32:27 --- topic: '["Haskell Platform 2013.2: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down, try: http://hdiff.luite.com "]'
21:32:27 --- topic: set by shachaf!~shachaf@unaffiliated/shachaf on [Tue May 28 01:16:22 2013]
21:32:28 <applicative_> irene-knapp: you have the right github cabal https://github.com/haskell/cabal not the ghc one?
21:32:35 <irene-knapp> thanks, yes, I do have that one :)
21:32:58 <applicative_> 480 issues.
21:33:01 <newtme> ok, thanks @shachaf - I can take it from here. I'll have to give these a few minutes of thought though
21:33:06 <irene-knapp> I know, right ><
21:33:14 <irene-knapp> that's an awful lot of issues.  but I'm proposing to implement this myself
21:33:17 <Fuuzetsu> Just going off the latest commits, https://github.com/23Skidoo seems like the man to poke
21:33:20 <irene-knapp> ahhhh
21:33:22 <irene-knapp> ty!  good call
21:33:23 <applicative_> yes
21:34:11 <Fuuzetsu> …and wow, that's a lot of issues. Maybe I should consider helping out when less occupied…
21:34:16 <irene-knapp> I know, right!!!
21:34:21 <Fuuzetsu> half of these are just feature requests though so it's not as bad as it seems… probably
21:34:26 <irene-knapp> the great thing about github from a maintainer's perspective
21:34:36 <irene-knapp> is that you can just click through and let other people do the d*mn merges, lol
21:34:40 <irene-knapp> if you're so inclined
21:34:50 <travisb> random question; from looking at seq it takes the type NFData a => a -> b; is NFData automatically generated?
21:34:56 <irene-knapp> that is, it doesn't really take much if all you want to do is trust  your contributors
21:35:06 <applicative_> @type seq
21:35:07 <lambdabot> a -> b -> b
21:35:25 <Fuuzetsu> @src seq
21:35:25 <lambdabot> Source not found. :(
21:35:31 <Fuuzetsu> how boring, lambdabot
21:35:44 <applicative_> travisb: isn't it some other forms of seq -ish things that need NFData? like deepseq
21:35:48 <Fuuzetsu> >The requested URL /packages/archive///doc/html/src/GHC-Prim.html was not found on this server.
21:35:52 <travisb> okay, I'm looking at *deepseq* and it uses NFData
21:35:56 <Fuuzetsu> even Hackage is against me!
21:35:58 * applicative_ could be hallucinating
21:36:02 <applicative_> oh travisb right.
21:36:35 <shachaf> Don't use deepseq/NFData/etc., in general.
21:36:48 <applicative_> it isn't derived automatically, the NFData instance.
21:36:50 <shachaf> Use them only for specific purposes. The default answer is that they're not what you want.
21:37:26 <applicative_> they are all over the parallel haskell libraries, shachaf, but I agree thats a 'specific purpose'
21:37:47 <travisb> the big question that's been on my mind is, as I've mentioned before, how do you keep workload in particular threads, and it seems like deepseq is the only way to do it in many cases
21:38:00 <Fuuzetsu> > a `seq` b
21:38:02 <lambdabot>   b
21:38:29 <shachaf> There's a big difference between seq and deepseq. deepseq is a function. seq is more like a compiler hint.
21:38:37 <Fuuzetsu> so does the wiki say ‘⊥ `seq` b = ⊥’ because it's effectively trying to force ⊥?
21:38:40 <shachaf> If you're deepseqing a big structure, chances are it's too late.
21:38:55 <shachaf> Fuuzetsu: No, there's no such thing as "forcing" at this level.
21:39:26 <Fuuzetsu> shachaf: I'm unable to find information on how it works. Everything just implies magic.
21:39:46 <shachaf> Well, what do you expect?
21:39:49 <travisb> usually the main place I would see even trying to deepseq something is when trying to feed it into an MVar, Chan, TVar, TMVar, or TChan
21:39:50 <shachaf> It's a primitive.
21:39:56 <shachaf> Read the GHC source code if you want to see how it works.
21:40:08 <Fuuzetsu> Right, GHC source is where I need to look.
21:40:18 <shachaf> travisb: OK, and maybe your usage is valid, but without evidence I'll assume that it isn't.
21:40:23 <Fuuzetsu> I guess I just expected that as opposed to ‘it's magic’.
21:40:31 <shachaf> Like I said, by the time you deepseq, it's often too late.
21:41:33 <travisb> it's just that most things I've seen in example code for, say, making a strict modifyMVar don't actually do it
21:41:50 <shachaf> ?
21:41:57 <shachaf> "strict" means WHNF.
21:41:59 <travisb> for instance, if you had it return a list, it would really only evaluate the first entry in the list, and then place the result in the MVar
21:42:18 <travisb> rather than evaluating the entire list
21:42:19 <shachaf> No, it doesn't even evaluate the first entry in the list; just whether it's empty or not.
21:42:41 <shachaf> Evaluating the list is your job, though.
21:43:28 <applicative_> maybe it isn't such a great idea to be using lists in your particular case
21:43:38 <shachaf> Also possible.
21:44:10 <shachaf> Also keep in mind that you can use force, if you really want deepseq.
21:44:24 <travisb> the main question is how do you pass a non-trivial datastructure over some inter-thread communication construct without having a computation leak from the source thread into the destination thread
21:44:38 <shachaf> strictBlah ... (force list)
21:44:43 <travisb> and saying "deepseq isn't a good idea" doesn't answer that
21:45:05 <shachaf> The answer is to evaluate it before you pass it.
21:45:18 <applicative_> no, it causes you to say more travisb ...
21:45:53 <travisb> so the solution is to limit yourself to things that can be trivially evaluated fully when doing interthread communication
21:46:00 <shachaf> I can't answer your question because I don't know your code.
21:46:07 <travisb> e.g. Nums, ByteStrings, things like that
21:46:41 <travisb> I don't really have any code right now, but I'm just thinking from the perspective of having done plenty of multithreaded code in other languages in the past
21:46:43 <applicative_> travisb: it is a little abstract, this question, but of course you are right, that in these cases one wants tends to want things 'properly evaluated'
21:47:26 <applicative_> travisb: this sort of thing is discussed in simonmar's new primer on concurrent haskell, but I'm just studying it myself ...
21:47:41 <travisb> is it on the web or dead tree only?
21:48:06 <shachaf> It is on the web only, and in draft form only.
21:48:11 <applicative_> web, there an early version and a manuscript on O[Reilly
21:48:37 <shachaf> Here are some good slides by the same person: http://community.haskell.org/~simonmar/slides/cadarache2012/
21:48:40 <applicative_> this isn't a draft http://community.haskell.org/~simonmar/par-tutorial.pdf it's a precursor
21:48:52 <isomorphic> Does anybody know a good programmatic way to access all of the fields of a data type? Eg:  data Foo = Foo { bar :: Int, baz :: Int) , then access bar and baz in turn?
21:49:04 <applicative_> the oreilly thing is here travisb http://ofps.oreilly.com/titles/9781449335946/
21:50:08 <travisb> even without the final draft that probably wouldn't hurt to read
21:50:18 <Aetherspawn> Does anyone know how to fix this type error: http://hpaste.org/89201 ?
21:51:39 <travisb> too bad the line number in that error message isn't very helpful...
21:51:56 <Aetherspawn> Oh, sorry, I /kinda/ marked it but I should have translated it
21:52:01 <Aetherspawn> It's on 24
21:52:20 <monochrom> Burrito?!
21:52:28 <Aetherspawn> :P
21:52:36 <shachaf> Is this a Yesod question?
21:52:38 <Aetherspawn> Yes, a burrito monad (or something)
21:52:44 <shachaf> @where yesod
21:52:44 <lambdabot> #yesod - http://yesodweb.com/
21:53:16 <Aetherspawn> Well, it uses conduit types but it's not yesod and I dont think the type error is related to the conduit stuff
21:53:21 <johnw> Aetherspawn: x <- return y == let x = y
21:53:27 <applicative_> Aetherspawn: you know that y <- return $ foo is the same as let y = foo
21:53:51 <Aetherspawn> ok lemme quickly fix that up
21:53:55 <applicative_> oh that johnw is too fast, he's like Enigmagic
21:54:12 <Enigmagic> i like burritos
21:54:31 <Enigmagic> mmm monad super burrito
21:54:47 <travisb> what is being done with x there?
21:55:22 <travisb> x <- return foo and then not using x is a no-op
21:55:39 <travisb> you might as well have commented that out
21:56:01 <c_wraith> x <- return foo  is a no-op in every case where the monad instance obeys the monad laws.
21:56:07 <Aetherspawn> Uh, sec
21:56:09 <c_wraith> All it does is create a new name for foo
21:56:16 <Aetherspawn> I was trying to make it typecheck
21:56:31 <travisb> what I mean is that foo is being bound to x and then not used
21:56:42 <applicative_> Aetherspawn: yes, y is just an abbreviation for appSource appdata
21:57:09 <applicative_> so you need to figure out whats wrong with appSource appdata $= decoder , if anything
21:57:22 <monochrom> travis, in the actual code, x is subsequently used alright
21:57:50 <Aetherspawn> Here is the edited paste showing how x (now combsrc) is used; http://hpaste.org/89201
21:57:52 <applicative_> travisb is saying that the x <- ... line should be commented out with the one that uses it, which seems sensible
21:58:11 <Aetherspawn> I took the advice into consideration and refractored it a little
21:58:30 <Aetherspawn> I don't know how to fix appSource appdata $= decoder :(
21:59:06 * travisb can't help much, as he doesn't know what type appSource appdata is
21:59:14 <bos> does anyone use the result comparison feature of criterion?
21:59:25 <bos> because i want to kill it
21:59:53 <Aetherspawn> Application m = AppData m -> m ()
22:00:00 <monochrom> Fuuzetsu, bos
22:00:17 <Aetherspawn> sec
22:00:26 <bos> monochrom: what?
22:00:43 <shachaf> bos: What does result comparison do?
22:00:43 <Aetherspawn> appSource :: AppData m -> Source m ByteString
22:00:46 <monochrom> Fuuzetsu may have a question to ask you
22:01:11 <bos> shachaf: it's complicated and i don't fully understand it, because i didn't write it
22:01:48 <bos> shachaf: but in brief: it flattens out a tree of results, takes the first element as the reference, and compares the remaining elements against it
22:02:14 <bos> shachaf: but it's not wired up to the html/js reporting, the code is hard to understand, and i've never used it
22:02:22 <travisb> and I'm used to $= being used as a setter operation on things like IOVars, so I don't know what it does with Source m ByteString unless it spits out IO () just like it does normally
22:02:38 <monochrom> Aetherspawn: I don't know if this is right: socksrc and listsrc have different types
22:02:46 <elliott> travisb: different ($=).
22:02:58 <travisb> elliott: what I was thinking
22:03:26 <Aetherspawn> I thought it might be caused by the type of mergeSources
22:03:29 <Aetherspawn> which is [Source IO a]
22:03:29 <travisb> I'm not familiar enough with this Source a b type to really say much
22:04:01 <Aetherspawn> But if I replace IO with m then it won't validate since it needs IO
22:04:22 <Aetherspawn> and I'm unsure how to make the type match SessionIO, for example, which /does/ have IO
22:04:56 <travisb> is there some function for lifting an IO into a SessionIO?
22:05:07 <Fuuzetsu> bos: Do you have few minutes for a discussion? I'm actually nearly done writing an e-mail if you're busy and would prefer it that way.
22:05:22 <bos> Fuuzetsu: i'm busy coding, email is probably better
22:05:31 <Fuuzetsu> Right, I'll do that then.
22:05:31 <Aetherspawn> No I wouldn't know how to do that.
22:05:49 <travisb> nothing available like liftIO?
22:05:51 <Aetherspawn> Would it be easier to go the other way? SessionIO into IO?
22:05:53 <monochrom> Session IO = ReaderT SessionReader (StateT SessionState IO). it seems liftIO is relevant
22:05:58 <applicative_> bos this is bcompare youre talking about?
22:06:04 <bos> applicative_: yes
22:06:13 <travisb> monochrom: just my thought
22:06:30 <travisb> you always lift IO into other things, as IO is not a monad transformer
22:06:30 <monochrom> this is why I hate type snonyms
22:06:45 <shachaf> I,I type snoymans
22:07:31 <monochrom> type synonyms are types that need to be transparent but pretend to be opague
22:09:26 <Aetherspawn> is lifting socksrc with liftIO correct?
22:09:43 <monochrom> I don't know. I don't know the type of socksrc
22:09:55 * travisb doesn't mind using them for things like separating, say, a Float which is an Angle, from a Float which is a component of a V3
22:10:45 <travisb> or a GLint which is a Uniform from any old GLint
22:12:15 <monochrom> travisb, a type is not defined by its name, but by what operations are good for it. and in practice, most names don't even suggest what operations are good for it.
22:12:54 <Enigmagic> Aetherspawn: you might take a look at stm-conduit's mergeSources and see if that would work
22:13:02 <monochrom> suppose you see "action :: Application SessionIO", and the next line is "action param = ..."
22:13:08 <mgsloan> unsafeCoerce often isn't very good for it ;)
22:13:51 <monochrom> well, suppose I see it. that throws me off. the name "Application" does not suggest that it is a function type. but I need to know that it is a function type in order for "action param = ..." to make sense.
22:14:19 <Enigmagic> Aetherspawn: i also have a source merger (but for conduit-0.5) that works a little differently... https://github.com/alphaHeavy/alphaheavy-conduit/blob/master/src/AlphaHeavy/Conduit.hs#L432
22:15:15 <Aetherspawn> Enigmagic, thanks I'll take al ook
22:15:31 <monochrom> or maybe I am the one given the job of implementing action. then I need to know that "Application SessionIO" is a function type, and I need to know from what to what, in order to implement it
22:15:38 <Aetherspawn> monochrom, sorry abut that Application m = AppData m -> m ()
22:16:07 <monochrom> it's alright Aetherspawn, you're just following really bad "best practice"
22:16:15 <Aetherspawn> ok :P
22:16:20 <monochrom> it is the fault of opinion leaders, not you
22:16:33 <travisb> monochrom: which for, something like a Uniform, different operations make sense for it than, say, an integral value that is an index
22:17:31 <travisb> the reason why, in what I'm working on, I gave them their own type synonym is to specify that they were special values that had to be treated differently
22:17:36 <applicative_> bos, there are some uses of bcompare by reputable users eg vincenthz and basvandijk 31 all told on github
22:18:45 <Aetherspawn> Enigmagic, does your mergeSourcesAsync require the output source to be wrapped in runResourceT when used?
22:18:47 <monochrom> so "Application SessionIO" cannot be an abstraction, because I need to know its "internal" detail. the name gets into the way.
22:19:22 <carter> bcmpare?
22:19:23 <Enigmagic> Aetherspawn: yeah to control the lifetime of the background threads
22:19:24 <carter> whats that?
22:19:28 <bos> applicative_: that's a bummer.
22:19:32 <applicative_> bos: but bgroup is used 10 x as much.
22:19:36 <carter> oh
22:19:38 <bos> carter: it's a pain in the ass that happens to be useful
22:19:39 <carter> criterion
22:19:49 <carter> bos yes, i fixed up the template
22:19:50 <carter> :)
22:19:56 <monochrom> and Angle is not really treated differently either. suppose I have x::Angle and y::Float. I need to know: may I write "x+y" or not? at that point I need to know whether Angle=Float.
22:20:10 <Aetherspawn> Enigmagic, is there an example somewhere because I had confusion with runResourceT when the function calling it had a heap of transformers wrapping it (like in my case)
22:20:16 <carter> bos so i can see each bcompare group in a seperate plot
22:20:24 <carter> is this releavant?
22:20:36 <travisb> monochrom: actually, now that I think of it, I thought of doing that but decided not to
22:20:39 <carter> the basic template doesn't use the info well
22:20:52 <carter> https://bitbucket.org/carter/multicriterion-templates
22:20:58 <carter> its kinda a hack
22:21:03 <travisb> whereas I am doing type GLuint = Shader, type GLuint = Program, and type GLint = Uniform
22:21:16 <carter> applicative_ whats the context here?
22:21:49 <monochrom> suppose you say, you want to disallow "(x::Angle) + (y::Float)". then why don't you make Angle really abstract? "newtype Angle = whatever", now the computer can tell me to not add with a Float
22:21:49 <Enigmagic> Aetherspawn: nope... general issue is that the input sources to be merged need to be forkable. arbitrary transformer stacks can't be forked. so the inputs need to be IO or (ResourceT IO) unless you want to take a dependency on one of the monad-fork libraries.
22:21:55 <carter> should at some point lean enough java script to fix it up more
22:21:57 <carter> or
22:22:04 <applicative_> carter, for bcompare?  bos just wondered how much it was used.
22:22:26 <travisb> monochrom: now that I think of it, I *could* turn Shader, Program, and Uniform into newtypes
22:22:39 <Aetherspawn> Enigmagic, if I just liftIO should i be fine
22:22:40 <carter> well… technically i'm having the template do the normalization and joining
22:22:41 <monochrom> suppose you say instead, you allow "(x::Angle) + (y::Float)". then why add one more name "Angle" as a burden to my feeble memory?
22:22:55 <carter> whats the issue with bcompare?
22:23:00 <monochrom> Law of excluded middle: you either allow it or disallow it.
22:23:15 <travisb> monochrom: I originally was thinking of doing that solely to make my type signatures more self-documenting
22:23:18 <applicative_> carter he didn't say. I looked into it a little, since I hadn't noticed it before
22:23:19 <monochrom> in each case, type synonym has no place
22:23:33 <carter> the usesage?
22:23:41 <applicative_> yeah
22:23:42 <Enigmagic> Aetherspawn: in what sense?
22:23:43 <carter> i mean… its not really used well in the default template
22:24:00 <carter> applicative_ i might try to write a saner template that can use that info soon
22:24:17 <Aetherspawn> liftIO $ runResourceT $ mergeSourcesAsync [sources ...] from within my function with a huge transformer stack
22:24:20 <carter> maybe i'll use Elm to generate the html doc… JS is really weird
22:24:20 <travisb> monochrom: but with Shader, Program, Uniform, if type synonyms are not the right thing to do, that's only because newtypes would be the right thing to do, as those really are not supposed to be tampered with by the user
22:24:21 <Aetherspawn> sorry I'm not very good at this.
22:24:33 <carter> i had to have a JS expert friend babysit me for a day to fix it up
22:24:40 <monochrom> "Angle_which_is_Float" is self-documenting
22:25:01 <carter> applicative_ bos lemme post a screenshot of my "multicriterion template in action"
22:25:33 <monochrom> "Angle" is self-obstructing because sooner or later I have to look it up and discover that "it's just a Float, do anything you would do to a Float"
22:25:43 <Enigmagic> Aetherspawn: ah, uhm yeah that could work, depending on the stack. you'll need to actually run the conduit within the runResourceT though... so liftIO . runResourceT $ mergeSourcesAsync [sources...] $$ sink
22:25:57 <Aetherspawn> got it! :)
22:26:23 <monochrom> you say, "oh, but it's a Float meant to be an angle!"  ==> Angle_which_is_Float
22:26:58 <carter> https://alpha.app.net/cartazio/post/6306835/photo/1
22:27:00 <carter> is one
22:27:22 <travisb> monochrom: I've got the point, but I don't see why Shader, Program, and Uniform shouldn't have their own types
22:27:22 <carter> https://alpha.app.net/cartazio/post/6306847/photo/1
22:27:24 <carter> is another
22:27:42 <carter> bos applicative_  : thats the sort of info i'm use for comparision
22:27:51 <monochrom> yes they should be newtypes. real abstractions. not pretended abstractions.
22:27:52 <carter> the default hmtl report  template doesn't do that
22:27:59 <carter> so i imagine no one really uses compare well
22:28:06 <carter> because of the orders of magnitude confusion that happens
22:28:36 <carter> because the comparision info isn't meaningfully presented aside from coloring the barcharts in the default template
22:28:43 <carter> here the colors are messed up
22:28:53 <carter> but i'm seeing relative perf per benchmark group
22:31:25 <carter> phrased differently: bcompare is useful, but the presentation layer is wrong in default template :)
22:32:13 <bos> carter: i didn't know bcompare was visible in html reports at all, huh
22:32:35 <carter> bos : its only visible isofar as the coloring in the default template
22:33:12 <carter> it would be neater if bcompare also meant "put these guys in the same comparison bar chart"
22:33:42 <carter> because currently: you don't get a bar chart thats useful if you're running a suite with codes that run over various orders of magnitude of computer time
22:34:07 <carter> (the linked images above illustrate comparison bar charts for a number of different input sizes)
22:34:16 <carter> using the "multicriterion"
22:34:17 <carter> template
22:34:38 <carter> strictly speaking, i'm using the bgroup prefix to do this
22:34:52 <carter> as a hack
22:35:17 <carter> but bcompare would be a nice way of denoting that… since it doesn't really seem to do much  as is...
22:35:45 <carter> idk
22:35:52 <carter> would be worth looking at how other folks use it presently
22:48:25 <Aetherspawn> Enigmagic, What is GSource ?
23:01:17 <zRecursive> Can i remove "Warning: Top-level binding with no type signature:" for some functions only ?
23:02:22 <shachaf> You can remove it by adding a signature.
23:03:43 <zRecursive> thanks! but it is too complicate signature for myLayout = windowNavigation $ avoidStruts $ noBorders ...
23:04:34 <zRecursive> Of course i can ignore the warning
23:05:19 <Nisstyre-laptop> @hoogle [Maybe a] -> [a]
23:05:20 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
23:05:20 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
23:05:20 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
23:05:20 <zRecursive> i hope any pragma can make the warning disappear
23:09:01 <Aetherspawn> @hoogle GSource
23:09:01 <lambdabot> No results found
23:09:12 <c_wraith> zRecursive: you only even get that message with -Wall, iirc
23:10:16 <zRecursive> yeah
23:12:19 <c_wraith> zRecursive: your only options are at the module scope.  you can add a {-# OPTIONS_GHC -fno-warn-missing-signatures #-} pragma
23:12:20 <osfameron> {-# LANGUAGE IWouldDoAnythingForWall-ButIWontDoThat #-}
23:12:49 <zRecursive> thx
23:13:02 <c_wraith> http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html  for the full list of flags...
23:13:32 <zRecursive> c_wraith: great
23:13:46 <c_wraith> and http://www.haskell.org/ghc/docs/latest/html/users_guide/ch04s02.html#source-file-options for details on the OPTIONS_GHC pragma
23:13:54 <Tene> I feel like I might be rather overcomplicating this.  I wrote this to gather results of a function across all combinations of items in a list:
23:14:00 <Tene> combinationFold func initial list = foldl (\a (x, y) -> foldl (`func` x) a y) initial $ zip list $ drop 1 $ tails list
23:14:16 <Nisstyre-laptop> Tene: combinations?
23:15:07 <Tene> Nisstyre-laptop: Perhaps I've got my terminology wrong.  Each unique order-independent pair.
23:15:22 <Tene> So for [1,2,3] it's [1,2] [1,3] [2,3]
23:15:32 <Nisstyre-laptop> Tene: what about [1,1,1] ?
23:15:50 <Nisstyre-laptop> just [1] right?
23:15:57 <Nisstyre-laptop> er, [1,2]
23:16:00 <Nisstyre-laptop> [1,1]
23:16:05 <Nisstyre-laptop> I can't type right now
23:16:06 <c_wraith> > [ (x, y) | (x:xs) <- tails [1..3], y <- xs ]
23:16:08 <lambdabot>   [(1,2),(1,3),(2,3)]
23:17:04 <Tene> Ah.  That would get rid of the nested foldl
23:17:30 <c_wraith> obviously, you can apply any function you like, instead of just the pair constructor
23:20:49 <Tene> Thanks.
23:24:18 <isomorphic> Could somebody please explain the following issue when trying to derive a functor instance?
23:24:19 <isomorphic> http://hpaste.org/89210
23:24:21 <Kneiva> is there a more elegant way to count adjacent int elements in a list than this: http://hpaste.org/89209 ?
23:28:31 <c_wraith> > (\xs -> sum $ zipWith (\x y -> if x + 1 == y then 1 else 0) xs (tail xs)) [1,2,3,5,6,]
23:28:32 <lambdabot>   <hint>:1:86: parse error on input `]'
23:28:42 <c_wraith> hah
23:28:45 <c_wraith> > (\xs -> sum $ zipWith (\x y -> if x + 1 == y then 1 else 0) xs (tail xs)) [1,2,3,5,6,9]
23:28:46 <lambdabot>   3
23:31:13 <c_wraith> Kneiva: ^^^
23:31:53 <c_wraith> isomorphic: That data type can't be an instance of Functor. It doesn't have an argument.
23:32:20 <c_wraith> isomorphic: that's what the kind stuff it's telling you about means.  The type is the wrong kind to be an instance of Functor
23:33:52 <isomorphic> c_wraith:   Thanks!   I'm a bit new at this.  The effect I'm after is to be able to map a function into all of the members of the type (hopefully that's illustrated by the toUpper).  What's a good way of being able to map toUpper in that way?
23:34:47 <c_wraith> :t toUpper
23:34:48 <lambdabot> Char -> Char
23:35:23 <c_wraith> You've got a couple hoops to jump through.
23:35:25 <isomorphic> Kneiva:  Would it make sense to express it as a composition of a function that creates a difference list, a function that filters the difference list for 1, and a sum over that list?
23:35:49 <c_wraith> isomorphic: heh.  That's exactly what the code I suggested does.
23:36:48 <c_wraith> isomorphic: anyway, as far as your problem goes.. Does it make sense for your type to be a container of different types? If not, you don't want to be an instance of Functor
23:37:06 <isomorphic> c_wraith:  Ah - yes, different middle step - I'm thinking (
23:37:21 <c_wraith> :t fmap
23:37:23 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:37:42 <isomorphic> \x y -> x - y)   - then it's extensible if you'd like to do numbers that are adjacent by different amounts, i guess ;)
23:37:48 <c_wraith> that says the type that's the Functor needs to take a type argument, and that fmap is allowed to change what the type is.
23:38:50 <isomorphic> c_wraith:  That'll be okay - in my case it'll specialise to something like (Char -> Char) -> f Char -> f Char, yeah?
23:38:56 <c_wraith> yes
23:39:48 <c_wraith> though, you want to consider carefully.
23:40:08 <c_wraith> Do you actually want (String -> String) -> Sample String -> Sample String?
23:40:14 <c_wraith> That seems more natural
23:40:31 <c_wraith> though it means you'd need to write fmap (map toUpper)
23:43:31 <Kneiva> isomorphic & c_wraith: Thanks. I guess that's not that much readable.
23:46:16 <c_wraith> Kneiva: hmm, you could break it down a bit
23:46:43 <c_wraith> :t (\xs -> zipWith (-) xs (tail xs))
23:46:44 <lambdabot> Num c => [c] -> [c]
23:46:58 <c_wraith> :t filter (-1 ==) . (\xs -> zipWith (-) xs (tail xs))
23:46:59 <lambdabot> (Eq a, Num a) => [a] -> [a]
23:47:05 <c_wraith> :t length . filter (-1 ==) . (\xs -> zipWith (-) xs (tail xs))
23:47:07 <lambdabot> (Eq a, Num a) => [a] -> Int
23:47:12 <c_wraith> actually, that's cleaner
23:47:32 <c_wraith> > length . filter (-1 ==) . (\xs -> zipWith (-) xs (tail xs)) $ [1,2,3,5,6,9]
23:47:33 <lambdabot>   3
23:48:31 <Kneiva> heh
23:49:19 <ezyang> Hey PL nerds, I have a question about lambda calculi. In many cases, one defines some new feature by adding it to the syntax of expressions of the calculus
23:49:23 <c_wraith> it's also exactly isomorphic's description
23:49:37 <ezyang> So, for example, in a textbook, if I want to add products, I add "fst" and "snd" to the syntax
23:50:21 <ezyang> Now, given a sufficiently expressive type system, one might say, "Well, fst/snd should be part of some base environment, but they shouldn't be built into the AST!"
23:50:51 <ezyang> So what is it called when you split up the lambda calculus in this way? (And how come most textbooks don't divvy things up this way)
