00:00:17 <mikeplus64> elliott: yep
00:01:52 <mikeplus64> actually i forget whether if it fails to parse it goes to the repl anyway
00:02:16 <zRecursive> elliott: how to use that Repl directly ?
00:02:33 <zRecursive> mikeplus64:
00:03:53 <mikeplus64> @hackage repl
00:03:53 <lambdabot> http://hackage.haskell.org/package/repl
00:04:21 <mikeplus64> zRecursive: use newRepl, and prompt
00:04:26 <zRecursive> mikeplus64: thx
00:05:12 <zRecursive> mikeplus64: is it a mini-ghci ?
00:06:02 <mikeplus64> zRecursive: yes, it's like lambdabot
00:06:51 <zRecursive> mikeplus64: Can it be integrated into xmonad ?
00:07:41 <mikeplus64> probably
00:08:27 * zRecursive i always think to add a mini-repl into xmonad. XMonad.Actions.Eval.hs is huge and not work
00:14:44 <elliott> mikeplus64: it seems like there aren't any limits on the heap when evaluating -- is it conceivable that you could get the repl process killed by using up too much memory and running out of heap, before it could timeout?
00:14:49 <elliott> that seems to be the main problem with a server-based approach like this
00:16:16 <mikeplus64> elliott: yeah. it needs to be made into a server in its own process to get around that
00:16:20 <zRecursive> elliott: it should need little RAM compared with ghci ?
00:17:20 <mikeplus64> elliott: if ghc had a HeapOverflow exception that worked, that wouldn't be necessary
00:17:27 <elliott> mikeplus64: hm, how would a separate process help? it'd still be running the code in the same context as the "main loop", right?
00:17:47 <elliott> or would it be a delegate evaluations to a server and restart it if it runs out of heap type thing?
00:17:48 <mikeplus64> because you can set memory limits
00:17:52 <mikeplus64> yeah
00:18:05 <elliott> right, so the possibility of the evaluation process crashing is still there
00:18:15 <elliott> (and so having to restore persisted definitions, etc.)
00:18:28 <mikeplus64> yeah
00:18:41 <mikeplus64> i think in the next ghc it has per-thread memory limiting
00:18:48 <mikeplus64> that only works when compiled with profiling though
00:19:01 <elliott> hm
00:19:04 <elliott> that seems ok
00:19:15 <elliott> I don't think the performance downside of profiling is relevant when you're running things for ten seconds on IRC :)
00:19:15 <mikeplus64> it would still just crash, but only within the thread i guess
00:19:39 <mikeplus64> you can compile with optimizations and profiling anyway, right?
00:20:22 <elliott> I think so, yeah
00:20:30 <elliott> but there's still a performance hit always, is my understanding
00:22:51 <elliott> btw, I think http://hackage.haskell.org/trac/ghc/ticket/367 means that it should be using -fno-omit-yields (which I guess is also 7.8 only?)
00:24:15 <zRecursive> cabal: At least the following dependencies are missing: base ==4.6.*, ghc ==7.6.*  oh i am using ghc-7.4.1 :(
00:24:42 <mikeplus64> elliott: i'm not sure how or why but i didn't have that problem
00:24:57 <mikeplus64> with things like "forever (return ())" which would trigger that
00:25:15 <zRecursive> mikeplus64: repl MUST need ghc-7.6.* ?
00:25:20 <elliott> hm, maybe it's because you have the layer of indirection of the GHC API
00:25:54 <mikeplus64> zRecursive: i'm not sure. but it's likely
00:26:04 <Aetherspawn> is it worth using a state if its the same function being called over and over
00:26:13 <Aetherspawn> or would it be more performant to just tailcall
00:26:17 <Aetherspawn> w/ an argument
00:27:13 <mikeplus64> Aetherspawn: you should find that both using State and a tail recursive function will produce more or less the same code, the question i guess is which is most convenient
00:27:38 <Aetherspawn> thanks
00:27:42 <mikeplus64> if you just want to be sure, and not rely on optimizations, then use a recursive function
00:39:47 <johnw> Aetherspawn: In Haskell tail call optimizations aren't as big of a deal, so I wouldn't assume it's more optimal to write it that way
00:40:15 <johnw> write it the clearest way first, then optimize if it's not fast
00:51:56 <__rotorblad__> some grammar help plz
00:52:12 <johnw> __rotorblad__: "Some grammar help, please."
00:52:34 <__rotorblad__> The XXXX Operating System is an operating system designed ad-hoc for the YYYY-gateway. In order to port OPC UA to this platform the concepts and principles of operating systems NEEDS/NEED/? ?
00:52:54 <__rotorblad__> to be udnerstood
00:53:01 <__rotorblad__> what form of need should I put there?
00:53:18 <johnw> need
00:53:24 <johnw> the subject is plural
00:53:57 <Aetherspawn> is there something which does this; \f x y -> x  { f = y }
00:54:17 <johnw> I actually think you could say "needs" to, with the understanding that "by the reader" is elided
00:54:39 <supki> @ty (.~)
00:54:40 <lambdabot>     Not in scope: `.~'
00:54:40 <lambdabot>     Perhaps you meant `.' (imported from Data.Function)
00:54:40 <johnw> Aetherspawn: that's essentially what lens is all about, but otherwise, no
00:54:44 <supki> wut
00:54:47 <Cale> What's the verb in the second sentence?
00:54:48 <Aetherspawn> gah
00:55:03 <Cale> (also, this is really the wrong channel for this)
00:55:07 <supki> Aetherspawn: anyway, that's set/.~
00:55:23 <Cale> Did you mean "are needed"?
00:56:26 <supki> johnw: that's what tiny-tiny part of lens is all about :P
00:56:37 <johnw> supki: true, I realized that after I said it
01:00:10 <t7> is there something like excel but with a bit more safety ? like a tiny visual database ?
01:00:28 <johnw> t7: is that even remotely related to Haskell?
01:00:40 <t7> wrong channel
01:00:45 <elliott> __rotorblad__: can you please explain why you share a username with dontdoMDMA (among several others)? and why you are repeatedly joining this channel to ask off-topic questions despite quiets/bans...?
01:00:45 <johnw> thx
01:01:45 <elliott> ok, thought so
01:01:50 --- mode: ChanServ set +o elliott
01:01:54 --- mode: elliott set +b *!*elaineben@78.164.217.*
01:01:54 --- kick: __rotorblad__ was kicked by elliott (__rotorblad__)
01:01:57 --- mode: elliott set -o elliott
01:02:01 <Aetherspawn> nasty.
01:02:21 <elliott> they are repeatedly evading bans to ask off-topic questions.
01:02:23 <t7> > 2 R.% 3
01:02:24 <lambdabot>   Not in scope: `R.%'
01:02:31 <dmwit> > 2 / 3 :: Rational
01:02:32 <lambdabot>   2 % 3
01:02:32 <Aetherspawn> I think the extra build time from lens is annoying, but I can't not use it because my code turns to slop
01:02:37 <johnw> elliott: I don't understand why they would even want to
01:02:37 <Aetherspawn> ;__;
01:02:53 <dmwit> Extra build time?
01:02:57 <elliott> johnw: they're not even getting good answers most of the time :P
01:03:00 <Aetherspawn> template haskell starting up
01:03:01 <dmwit> You mean the one-time installation cost, or something else?
01:03:06 <dmwit> ah
01:03:15 <Aetherspawn> or whatever that thing that spits out the name of every package
01:03:17 <dmwit> You can use lens without using its TH bits. =)
01:03:19 <Aetherspawn> that takes quite a while on my computer
01:03:28 <Aetherspawn> Can I use 'set' without it?
01:03:31 <johnw> yes
01:03:33 <dmwit> Definitely.
01:03:41 <Aetherspawn> Oh cool, I'll give that a try
01:03:57 <t7> the TH part just generates instances right?
01:04:15 <t7> and accessor things
01:04:16 <johnw> pretty much
01:04:18 <dmwit> classes and instances, I guess
01:04:22 * Aetherspawn jumps for joy
01:04:26 <johnw> and the HasX type classes
01:04:46 <elliott> note that the boilerplate you have to write without TH is kind of ugly.
01:05:03 * hackagebot rws 0.1.1.2 - Packet Generation  http://hackage.haskell.org/package/rws-0.1.1.2 (KarlKnutsson)
01:05:19 <Aetherspawn> doh
01:05:43 <Aetherspawn> I get could not match Control.Lens....Mutator with actual type Options
01:05:44 <Shamar> I've to code a complex GUI with GTK/Glade and haskell. Can anyone point me to the right direction to organize the code? It's becoming a mess!
01:05:49 <Aetherspawn> So I guess that's what the TH does for me..
01:08:10 <elliott> Aetherspawn: sounds like you have some other problem
01:08:15 <supki> I don't think TH matches Mutator with Options either
01:10:51 <Aetherspawn> error: http://hpaste.org/89653
01:12:47 <elliott> you still need to make lenses to use lens
01:13:37 <elliott> data Options = Options { _configurationFile :: FilePath }; configurationFile :: Lens' Options FilePath; configurationFile f opts = f (_configurationFile opts) <&> \x -> opts { _configurationFile = x }
01:13:42 <elliott> then set configurationFile will work.
01:13:54 <elliott> that configurationFile definition is what the TH writes for you
01:14:03 <XexonixXexillion> Does anyone know of an actual use for a Zygohistomorphic Prepromorphism? Every time I try to think of one, I tend to either ignore the histomorphism or the prepromorphism. (i.e have fst . runEnvT or id)
01:14:46 <elliott> XexonixXexillion: http://stackoverflow.com/questions/5057136/real-world-applications-of-zygohistomorphic-prepromorphisms (short answer: no)
01:14:48 <Aetherspawn> ugh I'll just use the TH
01:15:03 * hackagebot nkjp 0.3.1 - Manipulating the National Corpus of Polish (NKJP)  http://hackage.haskell.org/package/nkjp-0.3.1 (JakubWaszczuk)
01:15:05 <Aetherspawn> I can't even say that word
01:18:13 <Aetherspawn> zygo-histo-morphic pre-pro-morphisms
01:20:41 <drbean> The lambda backslash confuses vim's parenthesis matching:
01:20:46 <drbean> (map (\(t,_,_,s) -> (t,s) ) schooling ) ++ possessions
01:21:24 <Walther> well, looks like it is a time to get a better editor then :/
01:21:25 * Walther runs
01:21:38 <zomg> drbean: I never had any issues with that in vim
01:22:30 <MasseR_> Neither have I
01:23:07 <drbean> (map (\ (t,_,_,s) -> (t,s) ) schooling ) ++ possessions
01:23:33 <drbean> Is OK, with a space between the backslash and the parenthesis.
01:24:13 <Walther> sublime text survives pretty nicely as well
01:24:52 <Shamar> guys, do you think that's coding glade designed GUIs in haskell is an error?
01:25:39 <MasseR_> drbean: Just tested, no confusion anywhere
01:27:00 <Aetherspawn> Visual Haskell disappeared off the internet
01:27:09 <Aetherspawn> which is a shame because it would be absolutely incredible in VS2012
01:27:38 <drbean> I see with the cpotions option M, backslashes are ignored.
01:27:48 <Walther> Aetherspawn: i think there's always the option of you making it :P
01:27:53 <Aetherspawn> and intellisense would make monad transformer type issues more bearable
01:28:00 <Aetherspawn> since you could ctrl+space to see what you /can/ do
01:28:05 <Aetherspawn> or have auto lifting/hoisting
01:40:10 <supki> I'd prefer if someone figured out monad transformers alternative that isn't a pain to use
01:41:00 <elliott> there's always effect systems.
01:46:59 <Zenol> Hi. Question about the Snap.Snaplet.Auth module. Did anyone knows why userISplices :: AuthUser -> [(Text, I.Splice m)] isn't exported? userCSplices (wich does the same thing with compiled splices) is exported from Auth, but not the first...
01:47:04 <Peaker> I wonder how effect systems model the equivalent of transformers that aren't commutative (ListT, EitherT, etc)
01:50:58 <elliott> Peaker: "not as well"
01:53:09 <efie> what's the right way to create a probability distribution of n elements? for each of the n elements I called "randomRIO (0.0, 1.0)" from System.Random, and divided each value by the sum of all values
01:53:48 <Peaker> efie, there's a random distribution monad
01:54:39 <efie> Peaker: thank, I will check it out; however do you think my appraoch is correct?
01:55:40 <Peaker> @type randoms
01:55:40 <lambdabot> (RandomGen g, Random a) => g -> [a]
01:56:08 <Peaker> the functions in System.Random suck, relatively to the functions in the Gen monad for Arbitrary/QuickCheck
01:56:56 <Peaker> efie, What kind of distribution do you want? What are the possible "outcomes"?
01:57:51 <efie> Peaker: a random probability distribution
01:59:14 <Peaker> efie, and you want it normalized? Exactly one element will be "Selected" and the probability you're attaching is that element's probability?  so your division sounds right and fair
02:01:10 <efie> yes exactly; ok thanks
02:06:55 <adnap> I'm getting "Control/Monad/CatchIO.hs:55:15: Not in scope: ‚ÄõE.block‚Äô" when trying to install MonadCatchIO-mtl-0.3.0.5
02:09:08 <luite> adnap: using GHC HEAD?
02:09:42 <applicativa> Zenol, it does seem strange, they don't make use of it 'internally' to define something else.
02:09:57 <Shamar> sigh... why none can help me? sigh sigh... I'm quite expert in GUI development... but  :-(
02:10:42 <applicativa> Zenol, I guess you can inquire with an issue https://github.com/snapframework/snap/issues
02:10:59 <adnap> luite: Yes
02:12:06 <adnap> luite: cabal-dev install --sandbox=/tmp/sandbox --with-compiler=/usr/local/bin/ghc
02:13:00 <supki> iirc block was removed from HEAD
02:16:36 <adnap> supki: I don't understand the connection to GHC. In CatchIO.hs, E refers to Control.Exception.Extensible
02:18:12 <supki> adnap: it reexports Control.Exception
02:19:54 <adnap> supki: I see that. I still don't understand the connection to GHC. Will you please explain?
02:20:12 * hackagebot atom-msp430 0.5.0 - Convenience functions for using Atom with the MSP430 microcontroller family.  http://hackage.haskell.org/package/atom-msp430-0.5.0 (DanielBuckmaster)
02:20:14 * hackagebot atom-msp430 0.5.1 - Convenience functions for using Atom with the MSP430 microcontroller family.  http://hackage.haskell.org/package/atom-msp430-0.5.1 (DanielBuckmaster)
02:20:14 <supki> Control.Exception is from base and base is tied to ghc version
02:21:24 <supki> i.e you can not use old base with new ghc nor new base with old ghc
02:21:48 <adnap> supki: Oh, okay. Do you think I can build the latest base and have it be compatible with the latest GHC?
02:22:38 <supki> not sure what problem are you trying to solve
02:23:01 <supki> MonadCatchIO won't build with HEAD
02:25:22 <Zenol> applicativa> Ok, i'll add an issue.
02:25:52 <adnap> supki: I'm trying to make changes to a package using the API of the latest GHC.
02:26:20 <adnap> supki: Well, I have made the changes; I am trying to test them
02:28:48 <mami> aristid: re the problem with the integers and ints i had yesterday
02:29:09 <mami> i left it alone and looked at it for 5 min this morning
02:29:23 <mami> found an example how to use fromIntegral and solved it ;)
02:29:42 <mami> i think my brain rewired for higher typesystem compatibility in my sleep
02:30:59 <Botje_> @remember mami i think my brain rewired for higher typesystem compatibility in my sleep
02:30:59 <lambdabot> Okay.
02:43:35 <Peaker> Decided to toy with probability distributions: http://hpaste.org/89659
02:43:43 <Zenol> Still a snap question : in a Handler App (AuthManager App), is there a way to come back to a Handler App (AuthManager App) ?
02:43:49 <Peaker> very cute, nice to express the difference between monty knows & doesn't know
02:43:54 <Zenol> *Handler App App, sorry.
02:45:54 <Peaker> runRandDist montyHallHostKnows => [(1/3,False),(2/3,True)] ; runRandDist montyHallHostDoesntKnow => [(0.5,False),(0.5,True)]
02:49:44 <elliott> have to restart lambdabot to correct a dumb locale mistake I made that broke Unicode, sorry
02:49:47 <elliott> lambdabot: @flush
02:49:59 <elliott> lambdabot: @quit
02:50:17 <elliott> > 'Œª'
02:50:26 <lambdabot>   '\955'
02:50:28 <elliott> \o/
02:50:49 <kryft> <o<
02:51:44 <elliott> > ['Œª'..]
02:51:52 <lambdabot>   "\955\956\957\958\959\960\961\962\963\964\965\966\967\968\969\970\971\972\9...
02:52:15 <elliott> > text ['Œª'..]
02:52:22 <lambdabot>   ŒªŒºŒΩŒæŒøœÄœÅœÇœÉœÑœÖœÜœáœàœâœäœãœåœçœéœèœêœëœíœìœîœïœñœóœòœôœöœõœúœùœûœüœ...
02:52:51 <elliott> > text [chr 0x1f300..]
02:52:58 <lambdabot>   üåÄüåÅüåÇüåÉüåÑüåÖüåÜüåáüåàüåâüåäüåãüååüåçüåéüåèüåêüåëüå...
02:53:24 <ramses_> is that output supposed to look like garbage?
02:53:38 <elliott> ramses_: which?
02:53:43 <elliott> the former is all Greek to me.
02:53:55 <elliott> the latter should, under ideal rendering conditions, look like a bunch of emoji.
02:54:01 <Walther> yeah, greek worked fine, except for the last letter
02:54:22 <Walther> and emojis were just bunch of <?> replacements
02:54:26 <elliott> here it renders as the replacement symbol (question mark in a triangle), but if I view the tunes.org logs and set the encoding to UTF-8 I get colourful emoji icons
02:54:29 <ramses_> ony the first five show as greek here, the emoji don't come through at all
02:54:45 <elliott> http://tunes.org/~nef/logs/haskell/13.06.10, go down to the bottom and make sure you have encoding set to UTF-8 if it looks wrong
02:54:50 <supki> @ty (.~)
02:54:50 <lambdabot>     Not in scope: `.~'
02:54:52 <lambdabot>     Perhaps you meant `.' (imported from Data.Function)
02:54:56 <supki> :(
02:55:28 <elliott> supki: sorry. had to reset L.hs for safe haskell reasons. will re-add stuff piece by piece, including lens, but don't feel like trawling through all the imports/defns right now
02:55:50 * elliott gets the feeling he'll be typing ^ a lot today
02:56:13 <elliott> at least this provides edwardk the fine opportunity of expanding to Unicode lens operators
03:00:21 <ramses_> elliott: ah, my irc client wasn't properly set-up for unicode
03:01:20 * Shamar surrenders... no GUI in haskell... 
03:01:39 <elliott> Shamar: have you tried an frp lib like reactive-banana?
03:01:44 <elliott> or perhaps the newly released lgtk thing
03:02:28 <luite> or a web gui, it's all the rage ;)
03:03:46 <Shamar> elliott, I've readed a lot about reactive-banana but it doesn't look what I need
03:04:46 <Shamar> I've also find a document that explain why most of GUI devs still stick with gtk2hs: frp, is much more useful for game development where you have a lot of signals to handle
03:05:24 <elliott> reactive-banana integrates with a GUI framework like gtk2hs... it's not an alternative to them
03:05:39 <elliott> anyway, if your current solution is so bad that you give up, then surely any other solution is worth trying :)
03:07:05 <Shamar> that's a good objection elliott
03:07:43 <Shamar> lgtk looks more in the direction...
03:11:33 <Zenol> ok now I think I understand why my last question was stupid :)
03:11:57 <Lethalman> about lgtk, what's the point of it except being harder to read than plain gtk2hs?
03:12:09 <Lethalman> I mean, what's the major benefit other than saying "it uses lenses"
03:13:44 <Shamar> I'm looking for a reasonable way to organize code... you know the MVP or MVC patterns from oop?
03:13:47 <supki> harder to read?
03:13:50 <elliott> Lethalman: I don't know much about it. I think it is meant to excel at the expression of certain GUI types that aren't as well suited to FRP.
03:13:53 <Shamar> something like that
03:14:01 <elliott> but yes as supki points out, I find the question loaded
03:15:01 <Lethalman> what's the rationale, why should I choose lgtk
03:15:21 <elliott> because,
03:15:22 <elliott> "I think FRP may not be the best tool for special user interfaces, like interfaces which consists of buttons, checkboxes, combo boxes, text entries and menus only.
03:15:27 <elliott> I present a prototype lens-based model which fits better these user interfaces."
03:15:45 <Lethalman> why fits better, why lens-based model is better
03:16:31 <elliott> perhaps you should try it and see?
03:16:37 <t7> ELLIOTT is that a paper?
03:16:46 <elliott> the library is meant to be constructive proof of the hypothesis, presumably
03:16:58 <elliott> t7: quote from http://people.inf.elte.hu/divip/LGtk.html but http://www.haskell.org/haskellwiki/LGtk may be more up to date
03:16:59 <t7> why did that auto caps...
03:17:22 <elliott> your IRC client knows how great I am!
03:17:23 <supki> data-lens-based model
03:17:48 <Walther> how is the licencing of (L)Gtk btw, does it instantly sell your soul for free to GPL?
03:17:49 <elliott> yeah, lgtk's use of data-lens is a shame. but I'm not one to discourage experimentation in API design
03:18:15 <elliott> http://hackage.haskell.org/package/lgtk sez BSD3.
03:18:35 <elliott> however: the gtk binding itself is LGPL, which is basically equivalent to GPL when it comes to haskell
03:18:44 <elliott> so you need to be aware of how linking to that works, etc.
03:19:07 <Aetherspawn> Monad transformers with automatic lifting
03:19:12 <Aetherspawn> would be a fix to monad transformers
03:19:18 <Aetherspawn> (in my opinion)
03:19:23 <elliott> Aetherspawn: mtl already has that.
03:19:26 <elliott> in fact it's the whole point
03:19:37 <elliott> you will still need to use liftIO but that's it.
03:20:15 <Aetherspawn> even when you add 3rd party transformers like conduit, resource, etc?
03:20:44 <elliott> given that they're designed right :)
03:20:46 <Aetherspawn> I dont have problems with the regular transformers, its just 3rd party library transformers that give me typing grief
03:21:10 <Aetherspawn> (mainly because I'm not at the point where I understand /exactly/ what goes on behind all the transformers)
03:21:11 <elliott> conduit is a bit tricky because they're a bit more complicated than just being plain "monad transformers" that stack like most others, I think.
03:21:13 <Aetherspawn> they're just lego to me.
03:21:25 <elliott> but I haven't used conduit for many months, so I may be wrong
03:21:45 <Aetherspawn> I like the idea of transformers though
03:25:36 <elliott> @hoogle a -> a
03:25:37 <lambdabot> Could not find some databases: default
03:25:37 <lambdabot> Searching in:
03:25:37 <lambdabot>   .
03:25:43 <elliott> ok. another thing i gotta fix
03:31:04 <elliott> @hoogle a -> a
03:31:04 <lambdabot> Prelude id :: a -> a
03:31:04 <lambdabot> Data.Function id :: a -> a
03:31:04 <lambdabot> GHC.Exts breakpoint :: a -> a
03:31:06 <elliott> yay.
03:31:35 <Walther> duct taped it back together?
03:32:27 <elliott> Walther: duct taped it into existence in the first place.
03:35:35 <tdammers> "duct taped" is a relative thing though
03:35:55 <tdammers> what #haskell considers duct taped might actually pass for "elegant" in PHP
03:37:25 <osfameron> and what #haskell considers elegant might pass as "huh? wtf?" in PHP
03:38:11 <Fuuzetsu> @src all
03:38:11 <lambdabot> all p =  and . map p
03:39:12 <Walther> one of the small things i don't like in Haskell despite looking very awesome is the use of grave accents / "backticks"
03:39:36 <Fuuzetsu> You don't have to use them.
03:39:48 <Shamar> elliott, as for lgtk, it looks a bit cleaner if you code the GUI completelly in haskell, but I use glade to draw ui components...
03:39:51 <Walther> Fuuzetsu: hm, is there a way around `mod`?
03:39:56 <Walther> etc
03:40:00 <kimochiwarui> Walther: mod a b
03:40:19 <kimochiwarui> Walther: Whenever you use backticks, you are actually infixing a prefix function.
03:40:20 <Walther> Whee.
03:40:24 <Fuuzetsu> (flip mod)
03:40:52 <tdammers> indeed
03:40:59 <tdammers> back-ticked infix is equivalent to prefix
03:41:08 <tdammers> it's a purely aesthetic choice
03:41:15 <tdammers> > mod 13 7
03:41:17 <lambdabot>   6
03:41:19 <tdammers> > 13 `mod` 7
03:41:20 <lambdabot>   6
03:41:34 <supki> Walther: you should see SML to like Haskell solution
03:41:41 <tdammers> sometimes the backticks make more sense, sometimes the prefix is more readable
03:42:08 <tdammers> and if you don't like the backticked infix, you can always make your own infix alias
03:42:16 <kimochiwarui> supki: SML is nice for many reasons (mainly, modules > type classes, IMO), but its handling of operators is not one of them.
03:42:16 <elliott> Walther: (x `f` y) is just (f x y)
03:42:22 <elliott> you can use it with any function
03:42:22 <tdammers> > let (%%%) = mod in 13 %%% 7
03:42:23 <lambdabot>   6
03:43:12 <tdammers> and, as you might have guessed, you can use parens to use an infix operator prefix-style
03:43:16 <tdammers> (+) 5 7
03:43:18 <tdammers> > (+) 5 7
03:43:19 <lambdabot>   12
03:44:14 <elliott> unfortunately, these notations do not nest.
03:45:33 <schoppenhauer> hello. is it possible to encapsulate a strict state (ST) into some object, and perform certain operations on it in an unsafe manner, by just telling the compiler to ignore that they are unsafe? [i need to implement a map with a buffer. the buffer will not be accessed at all, and it does not influence (except for bugs ...) the outcome of the calculation]
03:45:43 <schoppenhauer> [it is just for optimization]
03:47:24 <elliott> schoppenhauer: yes, generally you just use unsafePerformIO + IORefs for this purpose.
03:52:04 <ousado> hum - has lambdabot been restarted with an old database or something?
03:52:46 <elliott> ousado: yes, kind of
03:52:54 <elliott> ousado: what issues are you having?
03:53:16 <elliott> (I took over running the bot and the state file might not have been @flushed before transfer, so it could be a few days old or something)
03:53:30 <elliott> (if lots of things are missing it's probably something I haven't made work yet)
03:53:35 <ousado> it told me I have a new message
03:53:40 <ousado> and then:
03:53:46 <ousado> edwardk said 7m 12d 11h 8m 1s ago: thanks!
03:53:50 <ousado> :)
03:54:03 <elliott> hehe
03:54:10 <elliott> most likely you got notified about that message but then forgot about it
03:54:16 <elliott> and it didn't bother to remind you again until the restart now
03:54:22 <elliott> (without ever actually reading it)
03:55:16 <ousado> yes, true, I actually was on the channel and could read that without asking lambdabot
04:03:02 <volitek> What should I be using with vim to write haskell? syntax and indentation seems to be nonexistant
04:04:15 <tdammers> volitek: I use vanilla vim, with a two-line makefile and hasktags
04:04:38 <hpc> i use vanilla vim and cabal
04:04:52 <hpc> or cabal-dev, rather
04:05:05 <tdammers> well yes, cabal-dev too
04:05:07 <volitek> How do you live with the screwy indentation?
04:05:16 <tdammers> :set expandtab
04:06:00 <hpc> oh hey, that's what that is
04:06:02 <volitek> I have that on already
04:06:02 <merijn> volitek: I'm working on a better auto-indent for vim, but it's only half done
04:06:16 <schoppenhauer> elliott: thx. this looks like what I need.
04:06:31 <hpc> volitek: i manage by not indenting very var
04:06:33 <merijn> As for vim tab settings: https://github.com/merijn/dotfiles/blob/master/vimrc#L36
04:06:35 <volitek> merijn: awesome, where can I find it when it's done?
04:06:44 <merijn> That's the only way to configure tabs in vim
04:06:56 <hpc> large indentation is usually an indicator that you should be writing multiple functions
04:06:57 <merijn> volitek: https://github.com/merijn/haskellFoldIndent
04:07:29 <merijn> Folding is, as of yet completely absent :p
04:07:50 <hpc> i don't really see the value of folding in haskell
04:08:08 <hpc> i mean, unless you are constantly writing monstrosities like augustss-sort
04:08:12 <hpc> (the one in Prelude)
04:08:17 <volitek> as in folding the functions to hide them? never use that anyway :P
04:08:26 <supki> merijn: oh, I have feedback!
04:08:27 <merijn> hpc: I like to fold functions into type signatures
04:08:43 <hpc> ah, that could be useful then
04:08:56 <hpc> what if you fold a function with no explicit type?
04:09:18 <supki> merijn: cd6ee093 completely breaks handling do/case blocks for me
04:09:19 <merijn> hpc: I'm not sure whether folding data declarations/imports/class/instance things is useful
04:09:27 <supki> i.e. it works one commit earlier
04:09:34 <hpc> oh, i can see it being helpful for folding haddock
04:09:46 <hpc> some of those can get enormous
04:10:14 <merijn> supki: Really? What happens? Do you have a code sample that triggers it?
04:10:33 <supki> merijn: well, it just does not indent
04:10:39 <supki> any do-block would be a code sample
04:12:00 <merijn> supki: oh, bollocks. Fixed one issue, broke another :p
04:12:17 <merijn> supki: Without that "foo a = do bar\nbaz" doesn't indent
04:12:28 <schoppenhauer> can I use IOArray with performUnsafeIO as well?
04:12:28 <supki> ah
04:12:29 <merijn> But now I broke it for the "do\n" case >.<
04:12:55 <volitek> merijn: just installed your plugin, it's great!
04:14:05 <merijn> volitek: Well, apparently I just broke a really obvious case, so not that great just yet :p
04:14:52 <mm_freak> i have a data type with many constructors (CSS lengths to be precise) for lengths in different units‚Ä¶  some of the units are compatible (for example pc and pt)
04:14:54 <volitek> I have a habit of hitting gg=G and now its making things pretty rather than screwing things up, so its great in my books
04:14:54 <supki> merijn: somehow related: would you accept pull-request, or is it too much pain to work with them in hg-git?
04:15:25 <mm_freak> is there an easy way to make compatibility-aware prisms for this data type?
04:15:42 <mm_freak> or do i have to write those manually?
04:16:06 <functorfun> hi, any reason why first would say it was out of scope?
04:16:19 <hpc> @hoogle first
04:16:19 <lambdabot> Data.Monoid First :: Maybe a -> First a
04:16:19 <lambdabot> Data.Monoid newtype First a
04:16:19 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
04:16:22 <merijn> supki: Pull requests are easy, as long as they don't introduce new branches
04:16:28 <hpc> functorfun: did you import Control.Arrow?
04:16:30 <mm_freak> functorfun: very vague question
04:16:38 <mr-> functorfun: maybe you meant fst? ;-)
04:16:41 <functorfun> ah, its in arrow thanks, oops
04:16:50 <elliott> schoppenhauer: you can do more or less anything "externally pure" with unsafePerformIO.
04:16:54 <mm_freak> ah, why "first" itself is out of scope =)
04:17:04 <elliott> schoppenhauer: it can be tricky. you often need NOINLINE declarations and so on. that's the price of living in sin
04:17:27 <merijn> supki: The biggest pain is the fact that branches are very different between mercurial and git, but just new commits on master are easy to merge in
04:18:56 <elliott> mm_freak: I'd say write them manually. it won't be such a chore, I think
04:19:29 <functorfun> one other warning "this binding for loop overshadows an existing binding"
04:19:37 <merijn> supki: oh...damn
04:19:46 <merijn> supki: I've found the bug and it's really silly :p
04:20:02 <elliott> functorfun: when talking about an error, you should really hpaste full code + the full error
04:20:05 <functorfun> is that saying the the patern match is seeing two functions that look the same however are not (isomorphic)
04:20:05 <elliott> @hpaste
04:20:05 <lambdabot> Haskell pastebin: http://hpaste.org/
04:20:37 <functorfun> elliott: I know, I am more interesting in the compiler warning and figure it out for myself.
04:20:50 <functorfun> however thanks
04:20:52 <elliott> well, you're not even quoting the compiler directly
04:20:58 <elliott> we can't guess at what it's saying from your misquote :P
04:21:57 <functorfun> oops s/overshadows/shadows/
04:22:32 <elliott> shadowing is when you redefine a name in a local scope
04:22:43 <elliott> thus hiding access to the definition named the same from the outer scope.
04:23:03 <functorfun> ah never mind, apparently arrows has some loop definition too, I just did import/hiding
04:23:11 <merijn> supki: Pushed a fix for that, I forgot to enable "very magic" mode for regexes detecting do/case blocks when I fixed the issue of syntax inside comments.
04:23:43 <functorfun> elliott: thanks, does the compiler know this by checking bijectivity on the AST?
04:24:32 <merijn> supki: Althought now I seem to have broken do blocks that start on the same line >.> Ok, I need to postpone fixing this until I have more time
04:25:05 <elliott> functorfun: I don't see how it has anything to do with bijectivity or isomorphic
04:25:18 <elliott> x = ...; y = let x = ... in ... -- the binding of x in y shadows the x defined adjacent to y
04:25:25 <elliott> because in the "in ...", you can't access the outer x.
04:25:35 <functorfun> ah!
04:25:57 <functorfun> sorrying I was miss understand.
04:28:32 <supki> merijn: sure, thanks
04:33:56 <XexonixXexillion> Can someone help me work out why "ana (\x -> if x == 0 then Nil else Cons x (x-1))" using Data.Functor.Foldable from recursion-schemes won't type check? It says it can't match Base a0 with Prim b0, but I thought a0~b0 and Prim [a] is an instance of Base [a]...
04:38:28 <XexonixXexillion> strangely, it works if I give it a type like (Eq a, Num a) => a -> [a]
04:38:52 <typoclass> XexonixXexillion: dmr? this is a wild guess
04:39:28 <mm_freak> can a lens only modify or also create?
04:39:48 <mm_freak> (in general)
04:40:15 <elliott> lenses don't generally change structure.
04:40:18 * hackagebot BerlekampAlgorithm 0.1.0.0 - Factorization of polynomials over finite field  http://hackage.haskell.org/package/BerlekampAlgorithm-0.1.0.0 (AbdelwahebMiled)
04:40:23 <elliott> they poke at existing structure, whether that be by access or modification
04:42:32 <XexonixXexillion> ... why can't the monomorphism restriction just be turned off be default...
04:42:39 <XexonixXexillion> s/be/by/
04:44:15 <mm_freak> elliott: so only isos can create structure from other structure
04:44:23 <mm_freak> because everything else is partial
04:44:24 <mm_freak> right?
04:44:46 <elliott> i wouldn't say it like that
04:44:54 <elliott> i don't think isos even create structure if you look at them right, either
04:45:05 <typoclass> XexonixXexillion: i agree. it's a regular problem. and also it's disappointing to tell newbies "don't worry about that now, just put the weird {-# LANGUAGE #-} line at the top of the file"
04:45:19 * hackagebot snap-core 0.9.4.0 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.9.4.0 (GregoryCollins)
04:45:42 <mm_freak> elliott: technically
04:46:05 <fruitFly> why is there a parse error at ')' on: countChar char string = foldl (\ acc c -> if c == char then acc + 1) 0 string
04:46:06 <fruitFly> ???
04:46:27 <mm_freak> fruitFly: where is the "else"?
04:46:34 <hamid> fruitFly, cause there's no else
04:47:40 <mm_freak> fruitFly: btw, a better way to count characters is to use filter and length
04:48:14 <mm_freak> > let countChar c = length . filter (== c) in countChar '!' "this is a test!  a good test!!"
04:48:14 <lambdabot>   3
04:48:54 <tdammers> I get the urge to factor out the "count-by-predicate" part
04:49:12 <fruitFly> mm_freak: thanks :)
04:49:18 <tdammers> count p = length . filter p
04:49:19 <mm_freak> > let countChar p = length . filter p in countChar (== '!') "this is a test!  a good test!!"
04:49:20 <lambdabot>   3
04:49:24 <mm_freak> tdammers: like this?
04:49:39 <tdammers> mm_freak: pretty much, yeah
04:49:40 <mm_freak> i agree
04:49:55 <tdammers> crank up "separation of concerns" to 11
04:50:05 <mm_freak> and yeah, rename "countChar" to "count" =)
04:51:30 <XexonixXexillion> :t Data.Functor.Foldable.zygoHistoPrepro
04:51:32 <lambdabot> Couldn't find qualified module.
04:52:07 <XexonixXexillion> :'(
04:54:10 <supki> typoclass: yeah, MR is nice example of "but newbies would be less confused if..."
04:54:38 <mm_freak> let's say i have a Length type:  data Length a = MmLen a | PxLen a
04:54:47 <mm_freak> it captures length in either millimeters or pixels
04:54:53 <mm_freak> two incompatible units
04:55:03 <elliott> your prism had better take a ppi argument.
04:55:19 * hackagebot padKONTROL 0.1 - Controlling padKONTROL native mode  http://hackage.haskell.org/package/padKONTROL-0.1 (FumiakiKinoshita)
04:55:47 <mm_freak> now i can write a prism:  cmLen :: (Fractional a, Fractional b, Real a) => Prism (Length a) (Length b) a b
04:56:05 <typoclass> supki: true, but there's more. i still think that if you'd look at all the haskell source files in the world, many of them need NoMonomorphismRestriction, and a tiny number would need MonomorphismRestriction if the default was reversed
04:56:16 <mm_freak> can i somehow use/extend this prism to allow me to /create/ an MmLen out of centimeters?
04:56:40 <mm_freak> elliott: if i do that, i can make it a proper lens, but i don't want to‚Ä¶  the units should stay incompatible
04:57:16 <mm_freak> or should i just use a regular smart constructor?
04:57:17 <typoclass> supki: ... (and i don't think turning on NoMo would cause more confusing error messages, or some other big disadvantage?)
04:57:18 <elliott> mm_freak: you can make an MmLen out of an a, anyway.
04:57:27 <elliott> uh, I was about to demonstrate it in lambdabot but I ruined it.
04:57:37 <elliott> GHCi> _Just # 123
04:58:04 <elliott> typoclass: turning off the DMR can cause severe performance issues. I've answered one question where someone turned it off without understanding what it does and got completely confused by the result because of this
04:58:37 <typoclass> elliott: hmm. interesting!
04:58:56 <schoppenhauer> is unsafePerformIO atomic? that is, will the function I pass to it always be evaluated on the whole (I do not use threading anywhere)
04:59:00 <mm_freak> elliott: yes, i can write MmLen 50, but i'd like to write 'f cmLen 5'
04:59:14 <mm_freak> elliott: is there such an f, perhaps for an extended variant of my prism?
04:59:37 <mm_freak> do you understand what i'm trying to achieve?
04:59:49 <elliott> mm_freak: you can write _CmLen, surely
05:00:02 <elliott> there is an iso between cm and mm. hence compose with _MmLen and done
05:00:03 <typoclass> schoppenhauer: as a friendly double-check, what do are you using uPIO for?
05:00:18 <schoppenhauer> typoclass: implementing a buffer.
05:00:26 <mm_freak> _CmLen is not in scope‚Ä¶
05:00:42 <elliott> mm_freak: you write it
05:00:56 <mm_freak> i see
05:01:04 <schoppenhauer> typoclass: it is research, not software development, so I *know* that I want to use unsafe operations.
05:01:07 <elliott> _CmLen = centiMilli . _MmLen
05:01:12 <elliott> centiMilli :: Iso' ...
05:01:21 <mm_freak> thanks
05:01:26 <schoppenhauer> typoclass: even though I agree that in general it is the last resort.
05:04:51 <circle> For the question "Will an O(n^2) algorithm always perform slower than any O(nlogn) algorithm? Give a precise answer." Would I be right in saying "no", because big-Omicron is only a statement about the growth rate of a program as its inputs increase, rather than its absolute speed?
05:05:15 <typoclass> schoppenhauer: well ... as far as i've heard there's a few legitimate use-cases, most of them having to do with very specific performance stuff. but ok :-) there's no problem if you're just playing around and trying stuff out (if that's what you mean by research)
05:05:28 <circle> Or you could take n = 1, then O(n^2) = 1, and O(nlogn) = 1 too.
05:06:10 <parcs> circle: yep
05:06:22 <circle> parcs: Thanks.
05:06:34 <schoppenhauer> typoclass: it actually is about performance. I need a list with a certain backbuffer, such that !! works fast in a certain range of indices.
05:07:08 <schoppenhauer> typoclass: such a backbuffer has side-effects, but only below the abstraction I will use it
05:07:16 <parcs> i wonder if there any strictness analysis is performed on IORefs
05:07:37 <typoclass> schoppenhauer: well, obviously i didn't mean "if you have any kind of performance problem, use unsafePerformIO" :-)
05:08:54 <edgar_> hey there, is there anyone who can help me a bit with a totally weird problem. I am trying to write a parser and for some reason a function simply fails to return the value that it should when I come out of a recursion.
05:08:57 <schoppenhauer> typoclass: of course. well, I actually will try to re-implement everything in agda. and it is an interesting question whether it is possible to implement lowlevel-stuff in agda, with a provably side-effect-free interface but side-effects in the backend.
05:09:16 <schoppenhauer> typoclass: and a good start is to implement it in haskell, since agda is very similar to haskell.
05:11:36 <mm_freak> d'oh
05:11:41 <mm_freak> it's much simpler than i thought =)
05:11:50 <mm_freak> cmLen # 0.1
05:11:55 <mm_freak> gives me MmLen 0.1
05:11:58 <mm_freak> uh
05:12:00 <mm_freak> gives me MmLen 1
05:12:03 <elliott> yep
05:12:08 <elliott> (you should really call it _CmLen, btw)
05:12:55 <edgar_> test
05:13:03 <mm_freak> not sure about that‚Ä¶  i'd rather hide all constructors and only export prisms
05:13:14 <mm_freak> and call them mmLen, cmLen, percent, pixels, etc.
05:13:18 <elliott> yeah, but _Foo is how we name prisms :P
05:13:25 <elliott> prisms *are* constructors (smart constructors)
05:13:38 <elliott> _Foo is "the closest we get" to saying Foo, which is what we'd ideally write
05:13:48 <elliott> when you define your cmLen, you are actually defining a new constructor / pattern synonym
05:13:54 <Mortomes|Uni> circle: Also, O(n * log(n)) could be a function like 100000000000*n*log(n) while the O(n^2) could be a function like 0.0000000001*n^2,
05:13:55 <mm_freak> i see
05:14:03 <elliott> it deserves to have the same status as all the other constructors
05:14:13 <circle> Mortomes|Uni: Indeed.
05:14:15 <fruitFly> I have a function countCharacter that determines how many of a char are in a string. I want to apply it for every character ['a'..'z'] over a string and return [Int] , how do you think is an efficient way to go about doing that? a scan? some kind of list comprehension?
05:14:22 <elliott> that's why e.g. the Cons class exports _Cons: because it gives a way to view all instances as having a "Cons" constructor, and a way to pattern match on it
05:14:36 <mm_freak> fruitFly: map/concatMap
05:15:04 <mm_freak> elliott: ok, i'll follow the naming scheme
05:15:56 * typoclass mumbles something about map length . group, but probably you want to implement it yourself for practice :)
05:15:59 <typoclass> fruitFly: ^^
05:16:37 <fruitFly> typoclass: group? i'll have to look into it
05:17:08 <fruitFly> typoclass: mm_freak I want to results to be [Int] equivalent to [a-Int, b-Int, c-Int ...] only 26 elements
05:17:10 <typoclass> > group "aaabcc" -- fruitFly: example
05:17:11 <lambdabot>   ["aaa","b","cc"]
05:17:23 <fruitFly> ooooooooooooooooooooooooooh shit
05:17:25 <fruitFly> :P
05:17:41 <fruitFly> fuck
05:17:51 <fruitFly> i dn't even need countCharacters now
05:18:00 <mr-> > group "aabbaac"
05:18:01 <lambdabot>   ["aa","bb","aa","c"]
05:18:01 <fruitFly> lololol
05:18:13 <fruitFly> hmm
05:18:14 <fruitFly> ok
05:18:29 <mr-> maybe you want to sort first..
05:18:53 <fruitFly> mr- or maybe you mean group then sort
05:19:05 <fruitFly> oh yes that's what u meant
05:19:43 <fruitFly> any Data.Sort or anything, I can implement basic sorts myself but I'm just wondering what support is out there for sorting?
05:20:29 <mr-> fruitFly: Data.List has a sort
05:20:39 <fruitFly> mr thanks!
05:21:27 <edgar_> i have a totally weird problem: http://hpaste.org/89668 It would be really nice, if someone could help me a bit with it.
05:22:06 <typoclass> fruitFly: i suppose the documentation for Prelude, Data.List, and Data.Maybe are a good thing to read. just to get a feel for what's basically available
05:22:26 <mm_freak> elliott: _Cm = _Mm . iso (/ 10) (* 10)
05:22:27 <fruitFly> typoclass: yeaaah brooo!
05:22:28 <fruitFly> :)
05:22:28 <edgar_> apparently, everything is calculated correctly in that example, but it is just not returned correctly as a result. i have never seen something like that before
05:22:33 <fruitFly> haskell is the coolest! :D
05:22:34 <mm_freak> ell	 does this look sensible?
05:22:39 <KSkrzet> > map (id &&& length) . group . sort $ "aabbaac"
05:22:40 <lambdabot>   [("aaaa",4),("bb",2),("c",1)]
05:22:45 <elliott> edgar_: hm, are you sure [u|[u]<-restparse] is doing what you want there? that means "for all elements of restparse that are lists of one element, include that element in the resulting list; otherwise discard"
05:22:47 <mm_freak> elliott: does this look sensible?
05:23:01 <elliott> so if restparse is [[],[1],[1,2,3],[4,5],[6],[],[7]], the result will be [1,6,7]
05:23:17 <elliott> mm_freak: looks good to me :)
05:23:21 <mm_freak> great =)
05:23:22 <mm_freak> thanks
05:23:48 <elliott> mm_freak: though I forget whether the iso goes first or after. or if it even matters?
05:24:29 <edgar_> elliott: Oh, I see what i have done wrong!!!! thank you!!!!
05:24:57 <mm_freak> > 25.4 :: Rational
05:24:58 <lambdabot>   127 % 5
05:25:08 <edgar_> elliott: of course I want the entire content of restparse, not only the singleton elements
05:25:09 <mm_freak> elliott: yes, it matters
05:25:16 <mm_freak> otherwise it's a type error
05:25:58 <mm_freak> i have to say, i like this prism approach =)
05:26:19 <mm_freak> virtual constructors for everyone =)
05:26:57 <elliott> edgar_: right, maybe you want "concat restparse"?
05:27:04 <elliott> > concat [[1,2,3],[],[4],[5,6]]
05:27:04 <lambdabot>   [1,2,3,4,5,6]
05:27:26 <elliott> :t concat
05:27:27 <lambdabot> [[a]] -> [a]
05:27:30 <edgar_> elliott: yeah that is exactly what I wanted
05:29:26 <edgar_> elliott: yeah, great, my parser is now working perfectly!!!! I am so happy. I spend so many hours not understanding why it didn't work!!!!!
05:30:56 <elliott> edgar_: :)
05:31:25 <edgar_> elliott: I started doing haskell a few weeks ago. it is really the coolest language I have seen so far. ;-)
05:33:41 <elliott> wow, that made me realise it's been ~6 years since I first started reading YAHT.
05:34:01 <Walther> ...yaht?
05:34:12 <elliott> Yet Another Haskell Tutorial
05:34:18 <elliott> it was what we had to read back before LYAH and RWH existed!
05:34:26 <Walther> ah, i'll add that to my list (lyah+rwh)
05:34:58 <elliott> though, YAHT wasn't nearly as good as LYAH as an introductory tutorial, it has to be said. I picked up the basics and played around for a while, but drifted away from Haskell until I was reintroduced by LYAH
05:35:12 <typoclass> edgar_: i've annotated your hpaste post, since the syntax was a bit unidiomatic. hope this helps http://hpaste.org/89668
05:35:36 <elliott> edgar_ left, btw
05:35:43 <elliott> perhaps @tell?
05:36:00 <typoclass> elliott: right, thanks
05:36:05 <elliott> might want to fix the bug in the original code too :P
05:36:42 <typoclass> elliott: yeah ... i haven't touched the semantics :) it looks funky
05:37:24 <circle> what do I do if I want to pattern match a few different times
05:37:34 <circle> like, if it passes this test, then check it if passes this test, and so on
05:38:01 <elliott> typoclass: apparently using concat restparse was enough to fix it.
05:38:18 <typoclass> circle: sometimes it helps to do "case (firstTest, secondTest) of (True, True) -> ...". do you have some code for hpaste.org?
05:38:29 <circle> I will in a sec, one sec
05:49:23 <circle> I'm trying to make a sort of database but am getting a lot of errors
05:49:23 <circle> http://hpaste.org/89670
05:49:44 <circle> the function mfd, which is supposed to list all films from a specified directory, is having the problems
05:49:50 <circle> director*
05:50:52 <Botje_> circle: that !! 1 is very suspect.
05:51:08 <circle> trying to get the 2nd string in the film
05:51:14 <circle> but yeah what should I replace it with?
05:51:21 <Botje_> circle: then you need to pattern match on what's inside of Film as well.
05:51:38 <circle> but I can't pattern match inside the | bars
05:51:49 <typoclass> circle: ah. (!!) works only on lists, not tuples. you can see this from its type:
05:51:50 <Botje_> mfd (Film (_,d,_,_,_) : films) director | ...
05:51:52 <typoclass> @type (!!)
05:51:52 <lambdabot> [a] -> Int -> a
05:52:03 <typoclass> [a] indicates a list
05:52:15 <Botje_> circle: alternatively, you can define a getter function that pattern matches on Film and returns the director for you
05:52:32 <Botje_> circle: OR you use record syntax and get the getters for free.
05:53:21 <typoclass> circle: ... or you could use a record. a tuple with 5 elements, 3 of them strings, is a little difficult to read. you always have to remember what string number 3 was
05:53:38 <typoclass> circle: btw, you can write String for [Char]
05:53:49 <circle> hmm, true, not experienced with records
05:54:11 <circle> Botje_: what's the syntax you showed me when you gave "mfd (Film (_,d,_,_,_) : films) director | ",
05:54:28 <circle> Botje_: could you annotate/make a new paste with that in it? Just not 100% sure what you mean
05:54:29 <Botje_> that's just a definition of mfd that does deep pattern matching.
05:55:17 <Botje_> it's probably the worst of the three solutions I gave you.
05:55:22 <circle> you reckon?
05:55:27 <circle> I'll try make a getter function
05:55:29 <Botje_> directorOf (Film (_,d,_,_,_)) = d
05:55:49 <Botje_> mfd (film : films) director | directorOf film == director = film : mfd films director
05:55:57 <Botje_> | otherwise = mfd films director
05:56:13 <Botje_> with record syntax you get the definition of directorOf for free.
05:56:25 <Botje_> oh, wait. Film is a type alias.
05:56:27 <Botje_> then it's just
05:56:34 <Botje_> directorOf (_,d,_,_,_) = d
05:57:04 <typoclass> circle: check section "record syntax" on this page http://learnyouahaskell.com/making-our-own-types-and-typeclasses
05:57:24 <typoclass> circle: it's pretty straightforward, it's a variation on "data"
06:00:59 <typoclass> circle: another suggestion -- Documentary and Film seem to differ only in one field. Documentary is a tuple ([Char], [Char], Int, [Genre]), Film seems to be the same, just with one extra String. if there's too much overlap like that, you may want to rethink your data structure, or pull out the common part
06:01:14 <circle> hmm, alright
06:01:25 <circle> with your 'worst' solution (deep pattern matching), how would I access the actual film?
06:01:34 <circle> the actual full movie, not just the director
06:01:42 <circle> since you filled most fields with _
06:02:10 <circle> well, botje did
06:02:12 <circle> Botje_:
06:04:34 <typoclass> circle: i think "@" synatx will work http://hpaste.org/89670
06:04:57 <Botje_> mfd (f@(_,d,_,_,_) : films) director | ... = (use f here)
06:05:06 <circle> interesting
06:05:18 <circle> can you provide an example of how you'd implement it, typoclass?
06:05:25 <circle> not 100% clear on syntax
06:05:49 <typoclass> circle: yes, i did =) check my hpaste link. click "diff original" if you want
06:06:05 <circle> I had a look, but that's for the deep patteern matching
06:07:30 <XexonixXexillion> circle: This strongly reminds me of last year's exam for comp1100 at ANU. If that is the case, don't make Documentary and Film tuples. Make them data types and use record syntax as that is what is *strongly* preferred by the lecturer and what is taught during the course.
06:08:02 <typoclass> circle: yes it is. then which of the suggestions did you mean? what do you want an example for?
06:09:09 <fruitFly> what's different about a list of pairs from a map? and what's the simplest way to instantiate and initialize a map?
06:09:54 <byorgey> > Data.Map.fromList [('x',3), ('y', 4), ('z', 20)]
06:09:55 <lambdabot>   Not in scope: `Data.Map.fromList'
06:09:57 <fruitFly> I see lyah a haskell just writes it like a list of pair--one pair being on a line, but is that the de facto standard?
06:10:06 <byorgey> > M.fromList [('x',3), ('y', 4), ('z', 20)]
06:10:07 <lambdabot>   fromList [('x',3),('y',4),('z',20)]
06:10:16 <byorgey> fruitFly: you can create a Map with the 'fromList' function
06:10:26 <byorgey> fruitFly: Maps have much faster lookup than lists of pairs
06:10:32 <fruitFly> byorgey: ok, else you have to lay it out vertically?
06:10:33 <typoclass> fruitFly: they are quite similar; one difference is that Data.Map can contain a key only once, while a list [(42,0),(42,5)] is possible
06:10:35 <byorgey> and support lots of other nice operations
06:10:41 <circle> XexonixXexillion: how do you know what's prefers by the lecturer?'
06:10:50 <byorgey> fruitFly: horizontal vs. vertical layout makes no difference.
06:11:01 <byorgey> fruitFly: you have to use the 'fromList' function in either case.
06:11:10 <fruitFly> byorgey: typoclass you guys are the best! I LOVE the haskell community :D
06:11:16 <byorgey> =)
06:11:18 <fruitFly> thanks guys!
06:11:19 * typoclass purrs
06:11:28 <fruitFly> haha XD
06:13:01 <Nik05> hey guys i have a formule which maps from Integer -> Integer, but when i declare the function as Integer -> Integer it says something about Factional Integer
06:13:03 <XexonixXexillion> circle: I work for him tutoring the course. I'm kind of paid to know :p
06:13:04 <Nik05> how can i do this?
06:13:13 <circle> XexonixXexillion: nice!
06:13:41 <circle> XexonixXexillion: stay here, I'll try mock something up
06:13:57 <Nik05> in the formula some even number gets devided by 2, so that should be no problem for an Integral type
06:14:00 <typoclass> Nik05: hi. could you put your code on hpaste.org? be sure to include the error message
06:14:16 <Botje_> Nik05: you probably used / instead of `div`
06:14:25 <Nik05> oh ok i will use div :P
06:14:27 <circle> XexonixXexillion: does the lecturer mark the exams himself or get others to do it?
06:15:00 <Nik05> thanks that works :D
06:15:09 <Nik05> is only for floats?
06:15:10 <kartlos> does anyone know a good source with information about using hscurses? google doesn't come up with any tutorials. The documentation doesn't describe each function. specifically: I can't seem to set the Reverse attribute correctly...the application just displays in normal style
06:15:15 <Nik05>  / is only for floats?
06:15:18 <Botje_> Nik05: yes.
06:15:23 <Nik05> ok thank you
06:15:51 <Nik05> and `div` doesnt work for floats?
06:15:51 <Botje_> numeric code in haskell tends to become a mess of fromIntegral if you're not careful about it
06:15:59 <Botje_> :t div
06:15:59 <lambdabot> Integral a => a -> a -> a
06:16:03 <Nik05> :)
06:16:05 <XexonixXexillion> circle: He marks them all himself. The comp1130 lecturer will look over them and mark any that he can't mark (for example his son's)
06:16:09 <Botje_> Integral and Fractional are mutually exclusive
06:17:21 <Zenol> Reidy > ?
06:18:49 <circle> how do you pattern match for data types?
06:19:34 <Botje_> same way you create them, which is a general rule in haskell
06:19:47 <circle> example?
06:19:54 <Botje_> so if you have data Film = Film Int String
06:20:04 <Botje_> pattern matching on it is just Film year name
06:20:05 <Botje_> or whatever.
06:20:25 <circle> greater context? Say I have Film = Title String | Year Int
06:20:38 <Botje_> that's probably not how you want to define Film.
06:20:55 <Botje_> since a Film is now a Title String OR a Year Int.
06:21:00 <typoclass> circle: hm ... well that would mean "a Film is either a Title, containing a String, or a Film is a Year"
06:21:02 <circle> hmm, true
06:21:03 <circle> yeah, lol
06:21:04 <circle> oops
06:21:13 <Botje_> i'd say data Film = Film Year Director Title or somesuch.
06:21:23 <Botje_> with Year, Director and Title appropriate type aliases.
06:21:29 <Botje_> or, with record syntax
06:21:50 <Botje_> data Film = Film { year :: Year, director :: Director, title :: String }
06:22:09 <Botje_> then you get year ( :: Film -> Year ) and friends for fre.
06:22:11 <Botje_> *free
06:22:12 <circle> how does using film twice figure into it
06:22:35 <ludamad> circle: Ones the constructor name
06:22:40 <ludamad> ones the type name
06:22:43 <typoclass> circle: i don't recommend it for beginners. you're right about that, it can be confusing. i suggest you use two different names
06:22:54 <typoclass> circle: (though technically possible)
06:22:58 <circle> So like Film = Film' Year Dir Title etc
06:23:04 <ludamad> circle: or MakeFilm
06:23:09 <circle> that would make more sense to me
06:23:23 <circle> using Film twice seemed weird, but anyway, yeah, so say I have data Film = Film' { year :: Year, director :: Director, title :: String }
06:23:29 * ziman likes to use data Film = F { ... }
06:23:34 <ludamad> :-
06:23:35 <circle> and I wanted to pattern match and get films with director "bob"
06:23:36 <ludamad> )
06:23:49 <circle> qwhat would the expression be?
06:24:36 <typoclass> circle: yes, i recommend the {record}. "Film' Year Dir Title" doesn't solve the question of "there's a bunch of Strings in here and everyone has to be very careful which is which"
06:24:59 <circle> alright, but how do I pattern match on that?
06:25:16 <typoclass> circle: you can do "foo :: Film -> ... ; foo (Film' {director = "Bob"}) = ..."
06:25:23 <ziman> there are multiple options, you can match on (F _ bob _) or F{ director = bob } or just F{..} with some extension (PatternWildcards or so)
06:25:56 <typoclass> circle: note that you'll need a | guard, as you've used already
06:26:26 <typoclass> circle: try "mfd (Film' {director = d}) name | d == name = ..."
06:30:18 <circle> so typoclass
06:30:30 <circle> if you've built up a record like data Movie = Film {director :: String, year :: Int} | Documentary {director     :: String}
06:30:36 <jchild> ooo I wondered if record format could handle more than simple datatypes
06:30:39 <circle> how do you "build" it from inside the compiler to check your functins?
06:31:04 <fruitFly> Error: A section must be enclosed in parentheses thus (. 12702)??? ... for ..... letterFrequency = Map.fromList [('e', .12702), ('t', .09056), ('a', .08167), ('o', .07507), ('i', .06966)...
06:32:22 <ziman> use 0.12702, now it parses as ((.) 12702)
06:32:35 <Haswell> Newbie here, interested in haskell com package for COM automation, but failed to install, any help?
06:32:39 <circle> typoclass: ?'
06:32:40 <typoclass> circle: oh, you mean from inside the interpreter? ¬´Film "dude" 1997¬ª should still work. you can also use ¬´Film { director = "dude", year = 1997 }¬ª
06:32:41 <fruitFly> ziman: oh fuck thanks
06:32:49 <circle> typoclass: makes sense, thank you
06:32:59 <fruitFly> I'm sorry again for my use of language. I'll get better
06:33:08 <typoclass> fruitFly: thanks
06:33:26 <ziman> fruitFly, cool :)
06:35:09 <typoclass> Haswell: try rerunning cabal with "-v3" to make it more verbose. if you can't figure it out, you have the most chance for answers if you copy out output to hpaste.org and include that in your question
06:35:24 * hackagebot persistent 1.2.0.2 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.2.0.2 (GregWeber)
06:35:29 <Haswell> ok, will do that, thanks!
06:36:46 <fruitFly> Why is Data.Map doc soo empty? http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html ..... Doesn't even say how to check a value?
06:37:15 <fruitFly> Haswell: how is it?
06:37:35 <mauke> fruitFly: have you tried reading it?
06:37:37 <typoclass> fruitFly: yeah it's a bit silly. click the link "module Data.Map.Lazy"
06:39:26 <fruitFly> kind of off topic, but what would you guys do if you had a strong server box or 2? What would you dedicate the resources to?
06:40:06 <circle> typoclass: you've still got the problem with "mfd (Film' {director = d}) name | d == name = ..." that you don't have a name for the actual film
06:40:16 <fruitFly> mauke: will take another look, it's hard for me to read doc sometimes because I don't know all the terms... * learning* )
06:40:56 <typoclass> circle: try "mfd film@(Film' {..."
06:41:20 <Haswell> Hi, <typoclass> & <fruitFly>, please help check this -> http://hpaste.org/89678
06:41:28 <Haswell> thanks!
06:41:36 <typoclass> fruitFly: no need to apologize, his comment was kinda useless
06:42:14 <mauke> fruitFly: the crucial sentence is "This module re-exports the value lazy Lazy API, plus several value strict functions from Strict. "
06:43:45 <circle> typoclass: we're dealing with a list of films here, how does the syntax here fit in with grabbing the first one?
06:44:48 <fruitFly> mauke: don't understand exactly what that means at first, but I guessed the module was related to Map.Lazy
06:44:50 <mauke> lists are just another data type
06:45:00 <byorgey> Haswell: the key error is 'not in scope: `catch''
06:45:06 <fruitFly> Haswell: I'm not sure buddy, I'm new
06:45:40 <mauke> fruitFly: it means importing Data.Map gives you everything from Data.Map.Lazy, plus the 5 extra functions listed below
06:45:51 <typoclass> circle: same as always :) use (... : ...) with the left side being the pattern that you want to match to the first element. right side is the pattern you want to match on the rest of the list (usually just a simple name, 'xs' or something)
06:46:01 <mauke> so most of the functionality is in Data.Map.Lazy
06:46:09 <byorgey> Haswell: it looks like the com package has not been updated to work on base-4.6
06:46:26 <circle> typoclass:  Parse error in pattern: (Film {director = d})
06:46:51 <byorgey> Haswell: IIRC, 'catch' used to be exported by Prelude, but is not anymore.  It is now found in Control.Exception.
06:46:52 <typoclass> circle: try adding some extra parens. if that doesn't help, paste the complete line
06:47:50 <typoclass> Haswell: also, Control.OldException was removed recently (some months ago). so if you have a fairly new ghc and are trying to compile old code ...
06:47:52 <byorgey> Haswell: if you are comfortable making changes to cabal packages and such, you could try downloading the package ('cabal unpack com'), adding a Control.Exception import in the module that is failing, and try building it locally
06:49:05 <mauke> you probably want catchIOError from System.IO.Error
06:49:05 <Haswell> byorgey: I've added "import Control.Exception (catch)" to the source file, but still the same error...
06:49:07 <circle> typoclass: http://hpaste.org/89680
06:49:28 <byorgey> Haswell: is it the same error for the same module, or is the error for a different module now?
06:50:02 <Haswell> the same module
06:50:04 <byorgey> Haswell: also, what command did you type to try building it?
06:50:09 <Aetherspawn> Haswell ooh
06:50:14 <Aetherspawn> can't wait till that comes out in july
06:51:44 <Aetherspawn> I had an idea for an optimization that would apply to tailcalls that are not turned into iterators (due to their nature)
06:51:54 <Aetherspawn> I guess you could call it stack compression
06:53:04 <byorgey> mauke: oh, you're probably right
06:53:16 <byorgey> Haswell: what mauke said.
06:53:58 <byorgey> but if you're still getting the same error after adding that import then something else is wrong anyway, which we have to address first.
06:54:15 <fryguybob> Aetherspawn: Haswell in the sense of 4th generation Intel Core archetecture is out now.
06:54:29 <Aetherspawn> fryguybob, oh?
06:54:34 <Aetherspawn> Can't wait for them to feature in macbooks
06:54:40 <Aetherspawn> I've been waiting for that to happen before I get one.
06:54:48 <sirspazzolot> Aetherspawn: some clevo resellers are already offering em
06:55:25 * hackagebot mongodb-queue 0.2.1 - a queue using MongoDB  http://hackage.haskell.org/package/mongodb-queue-0.2.1 (GregWeber)
06:56:06 <sirspazzolot> I've been lurking this channel for a while now but I still don't really write haskell :(
06:56:38 <byorgey> sirspazzolot: well, what are you waiting for? write some Haskell!
06:56:42 <fryguybob> sirspazzolot: You should write some. It is fun!
06:56:43 <byorgey> here, it's easy:
06:56:46 <byorgey> > 3 + 5
06:56:47 <lambdabot>   8
06:57:00 <byorgey> it's easy to get started I mean.
06:57:18 * elliott wonders what portion of the channel's 1k members actually write Haskell code on a regular basis
06:57:32 <sirspazzolot> yeah, I've gone through tryhaskell.org and a bit of LYAH but I just haven't had the time to sit down and figure out what I'm really doing
06:57:41 * elliott suspects that 100 is a generous estimate
06:57:49 <Aetherspawn> I wish I could tkae a compsci course
06:57:52 <fryguybob> elliott: haha
06:57:59 * byorgey suspects it is higher than that.
06:58:01 <Aetherspawn> to explain graph/category and all the monad universe stuff
06:58:17 <typoclass> sirspazzolot: well, we all don't really know what we're doing :-)
06:58:38 <fryguybob> elliott: Before I wrote any Haskelll I used it to think about problems and wrote very poor haskell in other languages.
06:58:39 <sirspazzolot> heh. that's quite profound, typoclass
06:58:50 * typoclass purrs
06:59:26 <Haswell> Sorry byorgey, i actually downloaded com-1.2.3.1.tar.gz, unzip, change then compile
07:00:15 <byorgey> Haswell: right, and what command did you type to compile?
07:00:25 * hackagebot mongodb-queue 0.2.2 - a queue using MongoDB  http://hackage.haskell.org/package/mongodb-queue-0.2.2 (GregWeber)
07:00:30 <elliott> I know exactly what I'm doing. it's terrible.
07:00:38 <kartlos> sirspazzolot: maybe some lectures can help? https://www.youtube.com/watch?v=AOl2y5uW0mA&list=PL395B50FC04752DA8
07:01:03 <Haswell> But i got different error when using your method (cabal unpack com), it compile quite a few source files, then throw errors...
07:01:15 <Haswell> cabal install
07:01:18 <byorgey> ok
07:01:43 <volitek> Is there a shorthand way to write something == one || something == two?
07:01:43 <byorgey> Haswell: I suggest you email the maintainer and ask about the status of the package on GHC 7.6
07:01:58 <byorgey> volitek: something `elem` [one,two]
07:01:59 <nooodl> something `elem` [one, two]
07:02:09 <volitek> thanks!
07:02:21 <Haswell> i did, but so far no reply :-)
07:03:14 <fryguybob> Haswell: There is always avoiding doing COM to Haskell directly and wrap the COM in C and Haskell FFI to the C.
07:03:38 <fryguybob> (if you are trying to solve some problem and not just play with COM)
07:05:52 <Haswell> fryguybob: is there any other package to do that?
07:05:58 <sirspazzolot> kartlos: wow, I was gonna say I'd check em out when I'm on lunch but there's a LOT there. thanks!
07:06:33 <sirspazzolot> I love lectures. Things are just so much easier for me to understand when somebody smart speaks it aloud
07:06:46 <Haswell> fryguybob: I used to do this in python using comtypes (Python -> COM)
07:07:34 <fryguybob> Haswell: Well using C to glue things would be the ad hoc sort of thing to do rather then using a package to help.
07:08:08 <kartlos> sirspazzolot: the lectures are given by Philip Wadler, these helped me get started with Haskell. The true Haskell coverage starts in the second video @ 40 min, the first is just unix introduction. Watching that whole series has really opened my mind to Haskell. Wadler is awesome!
07:09:04 <sirspazzolot> awesome! I'm a linux kid, should I skip the first parts?
07:09:12 <sirspazzolot> nah, wouldn't hurt to listen anyway
07:09:48 <kartlos> true ;) but if you get bored just fast forward to Introduction 1 @ 40 min
07:10:10 <fruitFly> mauke: Thanks :)
07:11:48 <kartlos> sirspazzolot: here's a page with an earlier installment of the same course: http://groups.inf.ed.ac.uk/vision/VIDEO/2009/inf1fp.htm
07:12:11 <kartlos> includes podcasts aswel :-)
07:15:04 <sirspazzolot> thanks!
07:15:51 <sirspazzolot> haskell community is so nice. I don't even write haskell and you're all super helpful about providing me resources to learn, whereas I write python and their channel refuses to answer my questions because I used getattr()
07:16:48 <typoclass> sirspazzolot: yup :) we pride ourselves on that
07:17:08 <kartlos> group hug :)
07:17:13 <sellout-> sirspazzolot: Yeah, this is definitely the most friendly and helpful channel I frequent.
07:17:30 <kostja> hi! is it possible to define a pure function, like a -> a+1 and call it from assembler?
07:18:00 <kostja> using c calling convention for example?
07:19:45 <kartlos> would be nice if someone made a Haskell MOOC...there's a Scala course on coursera, and a languages course covering Racket and ML....but no Haskell :-(
07:19:49 <typoclass> kostja: hello. not sure. does this help? http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
07:21:14 <sirspazzolot> kartlos: I signed up for the scala one for funsies (but haven't watched a single lecture)
07:21:37 <sirspazzolot> basically I just sign up for a billion coursera courses and download all the lectures when the class ends so I can watch them when I have time
07:21:50 <scriptor> kartlos: if I remember correctly the Scala course is more about functional programming in general
07:21:57 <scriptor> just uses Scala as the main tool
07:21:57 <sirspazzolot> yeah, it's supposed to be
07:22:15 * josephle wonders if there's a person who really understands scala's type system
07:22:24 <scriptor> a course purely about Haskell syntax and semantics wouldn't be helpful, but an introduction to FP with haskell would be great
07:23:47 <haasn`windows> Hey
07:23:49 <josephle> does the scala coursera course even try to touch upon scala's subtyping system?
07:24:09 <eikke> IIRC no
07:24:16 <supki> scala coursera cource is mostly about recursion
07:24:25 <supki> I wouldn't say it's about fp in general even
07:24:25 <kartlos> scriptor: you're probably right, I'd just prefer the course to be in Haskell, but I'm Maybe Biased :)
07:24:27 <eikke> supki: that's a very limited view
07:24:28 <haasn`windows> Is there a working forum software written in Haskell (+some web framework like yesod) anywhere?
07:24:43 <scriptor> kartlos: me too
07:25:25 <supki> eikke: yeah, probably I just hate scala :(
07:27:41 <josephle> supki: why the hate?
07:29:11 <Capitan_Kevin> is this the proper channel to ask a totally n00b question
07:29:21 <geekosaur> Capitan_Kevin, sure
07:29:28 <geekosaur> @where justask
07:29:29 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
07:29:37 <Capitan_Kevin> ok, thanks
07:30:10 <Aetherspawn> "Don't ask to ask, just ask" in the topic wouldn't go astray
07:30:11 <Aetherspawn> hehe
07:30:25 <scriptor> the topic's already pretty big
07:31:01 <geekosaur> yeh, and irc imposes fairly severe limits on the size
07:31:51 <Capitan_Kevin> Using WinGHCi and would like to list the lines that have been entered, but since this is an interactive session it seems it only allows line by line, setting break points etc...otherwise I'm guessing the way I would like to view it is why we have emacs, notepad or my favoite vim
07:32:58 <Capitan_Kevin> Is there some sore of dump command to have it just list a *.hs file that is loaded?
07:33:53 <Capitan_Kevin> or do I just do that sort of thing with and editor not the compiler?  Might be my question is not phrased well because I'm missing a basic understanding.
07:33:56 <elliott> if only we could put the entire FAQ in the topic :)
07:35:29 <Capitan_Kevin> where is the FAQ? I only see, logs, news and pastebin urls
07:35:56 <typoclass> Capitan_Kevin: hm ... well you probably want to look at the *.hs file in your editor
07:36:24 <Capitan_Kevin> yes, for sure can do, but would really like to just list what I have loaded in the compiler screen
07:37:03 <typoclass> Capitan_Kevin: ghci writes the lines that you entered into a history file. it's in ~/.ghc/ghci_history on linux, it must be something similar on windows
07:38:03 <typoclass> Capitan_Kevin: in general, use ghci if you want to "just quickly" enter a line or two. use an editor, a file, and ghc for longer code
07:38:47 <Capitan_Kevin> ok, that is what I thought...so use to coding in basic and its been a while for my functional programming days in university
07:39:08 <ludamad> basic to haskell ... nice jump :-)
07:39:42 <Capitan_Kevin> From what I can tell from Haskell...it is one hell of a powerfull and simple programming language, missing a lot of the crap syntax from other higher level languages.
07:39:52 <typoclass> Capitan_Kevin: don't worry about that :-) haskell has a steep learning curve, but you'll get through it and it's worth it
07:40:08 <typoclass> Capitan_Kevin: have you seen lyah? it's available for free
07:40:08 <ludamad> Simple once your brain forms around it
07:40:10 <typoclass> @where lyah
07:40:10 <lambdabot> http://www.learnyouahaskell.com/
07:40:29 <ludamad> I also enjoyed Real World Haskell
07:40:34 <Capitan_Kevin> ya, I can tell...love the way it handles intuitively
07:41:14 <elliott> don't expect it to remain totally intuitive :P
07:41:46 <Capitan_Kevin> Read the lyah...so impressed with the layout of the information.
07:45:28 * hackagebot Agda 2.3.2.1 - A dependently typed functional programming language and proof assistant  http://hackage.haskell.org/package/Agda-2.3.2.1 (AndresSicardRamirez)
07:46:09 <elliott> yay, fixed Agda!
07:46:11 <irene-knapp> lol nice
07:48:27 <tomejaguar> Does anyone have a good suggestion for a good introduction to HaskellDB?
07:52:41 <t7> i demand a changelog for agda
08:01:21 <shanse> too hard to prove
08:05:29 * hackagebot cassandra-cql 0.0.0.1 - Haskell client for Cassandra's CQL protocol  http://hackage.haskell.org/package/cassandra-cql-0.0.0.1 (StephenBlackheath)
08:05:33 <hseg> Is the Monoid instance for [] optimized to use difference lists? Also, I have a problem where all arrows are to RWS r w s () - there is no output. Am I using RWS correctly?
08:06:13 <roconnor> hseg: the monoid instance for [] is just (++)
08:06:20 <hseg> Pity.
08:06:32 <Taneb> hseg, if you want difference lists, use difference lists
08:06:41 <roconnor> hseg: you can turn any monoid into a difference monid using a monoid wrapper.
08:06:55 <Taneb> Any semigroup, even
08:07:10 <Taneb> Anyway, check out http://hackage.haskell.org/package/dlist
08:07:12 <hseg> OK. What about using RWS where the only output I care about is the writer output?
08:07:27 <roconnor> @type runRWS
08:07:28 <lambdabot> Not in scope: `runRWS'
08:08:07 <roconnor> hseg: use something like evalRWS
08:08:15 <hseg> Can't use stuff from outside the Platform. But I'll keep that package in mind for a future project.
08:09:16 <applicativa> @unmtl RWST a b c IO r
08:09:16 <lambdabot> a -> c -> IO (r, c, b)
08:09:16 <hseg> The question is not how to obtain the writer output. The question is whether using RWS to simulate RS with a value that has a Monoid instance is a normal usage of RWS
08:09:34 <Taneb> hseg, in that case, use Endo [a] rather than [a]
08:09:37 <roconnor> RS?
08:09:46 <Taneb> diff = Endo . mappend turns any monoid into a difference monoid
08:09:47 <applicativa> @unmtl RWST read write state IO hi
08:09:47 <lambdabot> read -> state -> IO (hi, state, write)
08:10:02 <hseg> Computations dependent on a read-only environment and a read-write state.
08:10:32 <roconnor> hseg: I would use () as the writer monoid if I don't want the writer portion of RWS.
08:10:41 <Capitan_Kevin> found ghci_history in windows here: C:\Documents and Settings\Administrator\Application Data\ghc
08:10:47 * applicativa would reject any statistics about 'normal' use of RWS
08:11:12 <applicativa> @unmtl RWST read () state IO hi
08:11:12 <lambdabot> read -> state -> IO (hi, state, ())
08:11:37 <roconnor> hseg: oh wait
08:12:33 <roconnor> hseg: no, RWS read () state monoid and RWS read monoid state () are not really similar
08:13:09 <roconnor> hseg: the way bind operates on the monad value and the writer value are quite different.
08:13:19 <hseg> What is the difference?
08:14:06 <roconnor> well the bind operation for the writer data just mappends values.
08:14:39 <pavonia> Hi! I'm looking for a data structure for storing 2-dimensional, non-overlapping ranges (each with an associated value). Efficient operations should be finding a range by a point within that range, finding adjacent ranges for a range, and traversing all ranges in order from left to right and vice versa. Any ideas?
08:14:40 <roconnor> while the bind operation for the monoid value consumes the monoid value and replaces it.
08:16:51 <savask> pavonia: Do you mean "rectangles" as 2D ranges?
08:17:16 <hseg> So if I'm returning stuff in the writer value, it will automatically be concatenated, while if I return it in the monad value, I'll have to do the concatenation myself?
08:17:22 <pavonia> savask: No, sorry, 1-dimensional! :)
08:18:13 <applicativa> you are dividing the line into segments, and want to know which segment a real number falls in, and which segments are left and right of it?
08:18:29 <savask> pavonia: Are there spaces between ranges? If yes, what ranges can be considered adjacent, those which touch or just hose which lie to left and to right of the target range?
08:18:37 <pavonia> applicativa: exactly
08:18:44 <roconnor> hseg: I believe that is correct.
08:19:14 <roconnor> hseg: if all you want to do is concatinate values for your output, then maybe you do want RWS read monoid state ()
08:19:14 <applicativa> there aren't spaces between the ranges if there is a function :: Double -> Range
08:19:30 <pavonia> savask: Ther can be sapce between them but it doesn't matter for being adjacent
08:19:33 <hseg> OK.
08:19:40 <savask> pavonia: Ah, okay.
08:21:11 <typoclass> pavonia: i don't know about fancy data structures, but as a minimum, you could use a plain list that contains the boundaries between the ranges ...?
08:22:04 <Capitan_Kevin> how do you turn history on for winghci?  Found the ghc_history file, but it is empty.
08:22:27 <pavonia> typoclass: But that's not efficient for many ranges
08:22:48 <savask> pavonia: Why not? Sort it and use binary search.
08:23:20 <pavonia> How do you do binary search on lists?
08:23:45 <savask> Split in half, look at the middle element, then repeat the search either in the left or right side.
08:24:12 <pavonia> That O(n) time then, no?
08:24:18 <pavonia> That's
08:24:28 <mauke> pavonia: you don't
08:24:30 <mauke> it's pointless
08:24:41 <typoclass> savask: erm ... that kind of assumes you can find the middle element efficiently. which lists don't do (think linked lists). you'd need something random-access, like an array
08:25:15 <savask> typoclass: Well, yeah :C
08:26:46 <pavonia> So some kind of a map with doubly-linked entries would be a solution but no idea how to do that in Haskell
08:26:47 <typoclass> pavonia: if you have a lot of ranges, yes it'll be slow. but have you tried? the "n" in O(...) often needs to be quite large on modern hardware until the asymptotics start to matter
08:27:15 <savask> pavonia: Why doubly linked?
08:27:25 <mauke> pavonia: is your data static?
08:27:51 <pavonia> typoclass: The problem is that I need a lot of random access
08:27:57 <pavonia> mauke: yes
08:28:14 <mauke> hardcode everything
08:28:26 <pavonia> hardcode?
08:28:32 <bartavelle> write a program that generates code
08:28:45 <pavonia> I mean static in the sense that after constuction no new elements need to be inserted
08:28:59 <typoclass> pavonia: well, when you say random access, that doesn't sound like a good fit for linked lists
08:29:44 <pavonia> typoclass: That why I need some map/tree structure on top of it
08:29:54 <mauke> pavonia: doesn't need to be on top, necessarily
08:29:59 <mauke> you could have separate structures
08:30:28 <typoclass> pavonia: what i'm saying is, it might be worth trying the simplest possible thing (= a plain list and linear search), because it's so quick to implement, before bringing out the big guns. this is just to be sure. you wouldn't want to spend lots of time coming up with a fancy data structure, only to notice that it didn't make any important improvement compared to the simple data structure
08:31:21 <pavonia> I see
08:31:48 <typoclass> pavonia: plus, after you've written the simplest variant, profiling might show that the bottleneck in your program unexpectedly is in some completely different place, I/O or networking or whatnot
08:32:13 <typoclass> pavonia: (in which case any complicated structure would have been unnecessary anyway)
08:34:00 <pavonia> Okay, so I guess I'll use sequences for a first implementation because traversing in both directions is important
08:34:29 <savask> pavonia: Why not to use an array as it was suggested?
08:34:51 <pavonia> Oh, was it?
08:35:34 <savask> pavonia: It's not really complicated, has random access, you can "traverse" it easily (just store the index) + my favorite binary search will work on it.
08:36:00 <savask> And you said that you don't need to modify the data so it must work.
08:36:04 <Capitan_Kevin> seems :list can show you your code around a break point
08:36:26 <pavonia> savask: Yeah, that's even better then, thanks
08:36:50 <savask> Say thanks to typoclass, that was his idea.
08:37:56 <pavonia> Thanks typoclass :)
08:38:45 * typoclass purrs
08:39:06 <savask> If we can get zipper for any type by differentiating automatically, can we get "walking" functions for zippers automatically too?
08:47:00 <Capitan_Kevin> Anyone using WinGHCi?
08:47:27 <dgpratt> Capitan_Kevin: I use it occassionally
08:47:50 <Capitan_Kevin> just trying to figure out why my ghc_history file is empty.
08:48:40 <Capitan_Kevin> Sure would like to list what ghc has loaded, but :list command seems only to show code around breakpoints
08:49:17 <Capitan_Kevin> any suggestions, besides of course using an external editor
08:50:38 <Capitan_Kevin> dgpratt, does is you ghc_history file have anything in it?
08:51:35 <dgpratt> Capitan_Kevin: not sure I even have such a file, FYI WinGHCi appears to store history in the registry under "HKEY_CURRENT_USER\Software\Haskell\WinGHCi (version)"
08:51:43 <dgpratt> I have to run, sorry
08:52:52 <Capitan_Kevin> dgpratt: thanks...gtk
08:55:31 * hackagebot cabal-debian 3.4 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-3.4 (DavidFox)
09:07:01 <schoppenhauer> the DiffArray documentation claims that DiffArrays are very slow. Is there any explanation why that is the case? I do not know the actual implementation, but reading and writing should not have too much overhead, so that would be interesting.
09:14:20 <enigmuriatic1> is there any known way to convert a Maybe a value to an a value?
09:14:36 <enigmuriatic1> actually, nevermind
09:14:39 <enigmuriatic1> the maybe function
09:15:29 <tromp_> i was gonna reply: maybe there is...
09:15:43 <monochrom> haha
09:16:10 <mauke> enigmuriatic1: fromMaybe
09:16:23 <frerich> enigmuriatic1: You can also use pattern matching, e.g. "(Just x) = v"
09:17:15 <typoclass> enigmuriatic1: the basic thing is pattern matching "case ... of Just x -> ... ; Nothing -> ..."
09:17:18 <tromp_> i always overestimate my ability to remember important passwords...
09:40:33 * hackagebot cabal-debian 3.4.1 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-3.4.1 (DavidFox)
09:41:01 <killy9999> I'm trying to install GHC under Debian Wheezy, but Wheezy does not have libgmp3 - any ideas how to deal with this?
09:42:19 <parcs> i usually just build it from source
09:42:36 <killy9999> parcs: that's the solution I'm considering
09:42:45 <savask> killy9999: If I recall correctly, you can compile (or even install?) GHC with integer-simple (it doesn't use GMP)
09:43:26 <killy9999> savask: I guess I need to use integer-gmp
09:43:35 <parcs> killy9999: you can also build gmp 4 from source and move the appropriate .so to /usr/lib
09:43:48 <savask> killy9999: But you need GMP for that.
09:44:00 <killy9999> so I'm thinking about installing GHC from the repo, compiling my own GHC and removing the version from the repo
09:44:03 <killy9999> I have GMP
09:44:15 <killy9999> just not the version that the binary build is compiled against
09:44:18 <savask> "but Wheezy does not have libgmp3" @_@
09:44:19 <parcs> you have gmp 5 but the binary tarballs build against gmp4
09:44:31 <savask> Ah
09:44:32 <killy9999> gmp3 I believe, not gmp4
09:44:55 <killy9999> I mean it is build against gmp3, while wheezy has gmp5
09:44:56 <parcs> libgmp3 is actually gmp4 :P
09:45:06 <killy9999> whatever :)
09:45:15 <killy9999> just not the version that GHC is build against
09:45:33 <typoclass> @tell chrisdone ohai. ircbrowse.net seems to cut off on 23 may, not displaying anything more recent. is this by design? i just wanted to quickly give a link to someone showing a conversation from a few days ago, and couldn't
09:45:33 <lambdabot> Consider it noted.
09:45:38 <killy9999> OK, so I guess I better start compiling...
09:45:56 <killy9999> at least I will make myself a fully optimized LLVM version :)
09:46:04 <savask> killy9999: Maybe it will finish tomorrow xD
09:47:21 <killy9999> actually, it takes more time to build LLVM than to build GHC
09:47:25 <killy9999> at least in my machine
09:48:11 <savask> That's a tribute to GHC then.
09:50:03 <killy9999> yeah, I think I'll start with LLVm 3.0 and 3.2 and then compile GHC
09:51:59 <enigmuriatic1> what's the most simple and quickly usable library to parse JSON
09:52:05 <enigmuriatic1> (aka not Aeson)
09:52:39 <enigmuriatic1> i just want to take a JSON string and cast it into a type
09:52:48 <Taneb> aeson
09:53:59 <Taneb> Just right a fromJSON instance for your type, that should be 4 lines maximum, and bob's your uncle
09:55:05 <Taneb> (write
09:55:07 <Taneb> **
10:00:34 * hackagebot xing-api 0.1.1 - Wrapper for the XING API, v1.  http://hackage.haskell.org/package/xing-api-0.1.1 (JanAhrens)
10:02:51 <Bor0> is there a "time" fuinctkell hat measures the time of code execution? I have an implementation of tail recursion and ordinary recursion and I would like to measure the difference between both
10:03:21 <geekosaur> @hackage criterion
10:03:21 <lambdabot> http://hackage.haskell.org/package/criterion
10:03:35 <Bor0> uh. * "time" function in haskell that measures...
10:03:58 * geekosaur points up
10:04:13 <Bor0> thanks, I'll check that out
10:05:58 <micknel> gm :) i am building haskell-platform-2013-2.0 and the docs do not seem to be installed on the final "make install" cmd.  any clues?
10:08:10 <typoclass> Bor0: the poor man's solution could be do do "ghc -O2 thething.hs ; time thething", once for each of the variants
10:08:51 <Bor0> that's a solution too, but I guess I wanted something that could be run within the interpreter
10:10:33 <geekosaur> the interpreter is not in general a sensible thing to benchmark
10:10:52 <Jeanne-Kamikaze> ^^
10:11:03 <mm_freak> Bor0: try "print (sum [1..1000000])" in the interpreter vs. compiled
10:11:05 <Bor0> I see. so typoclass's poor man's solution isn't really that poor?
10:11:35 <Jeanne-Kamikaze> Bor0, also :s
10:12:05 <Jeanne-Kamikaze> in ghci at least
10:12:05 <geekosaur> it has some shortcomings, notably that a single run will not separate program startup overhead from what you're actually trying to measure and it has no way to limit cache effects
10:12:13 <Jeanne-Kamikaze> err
10:12:40 <geekosaur> criterion will do multiple runs and average them, in a single program instance, and won't capture the runtime startup overhead etc. in the run times
10:12:44 <typoclass> Bor0: well you should always use -O2 when benchmarking, no matter if you're measuring via criterion or "time" or some other method
10:13:03 <Jeanne-Kamikaze> what was the option in ghci to get it to show time taken ?
10:13:31 <geekosaur> :set +s
10:13:42 <typoclass> Jeanne-Kamikaze: right! good call
10:13:46 <geekosaur> but of course that'll be unoptimized bytecode
10:14:02 <Jeanne-Kamikaze> yeaa
10:15:24 <int-e> geekosaur: but you can load compiled code and still time it in ghci.
10:17:10 <Jeanne-Kamikaze> int-e, how ?
10:17:20 <Jeanne-Kamikaze> the .hi file ?
10:17:53 <int-e> if you have an up-to-date compiled version of the module lying around, :load will usually load that one.
10:18:29 <enigmuriatic1> in Text.JSON, how do I get a specific field from a Result JSValue?
10:28:48 <enigmuriatic1> in Text.JSON, how do I get a specific field from a Result JSValue?
10:30:46 <Sonarpulse> is it standard for bidings to go in modules called
10:30:49 <Sonarpulse> bindings.*
10:32:55 <apples> sh/buffer 4
10:37:06 <frerich> And this is why you have to be careful about side-effects!
10:37:33 <Cale> It feels weird to have a netsplit happen and still see over 1k users.
10:38:22 <janinge> it was just the London server going down I think
10:39:20 <Sonarpulse> hIRCd pls save us
10:40:00 <Capitan_Kevin> Is there a debug program to Haskell as Code::Blocks is to C++
10:40:02 <Capitan_Kevin> ???
10:40:52 <monochrom> I don't know what is Code::Blocks.
10:41:17 <Clint> it appears to be an IDE
10:43:37 <beefcube> I was having a look at Data.Either.lefts, and noticed this: lefts x = [a | Left a <- x]
10:43:49 <Capitan_Kevin> yep, ide.
10:44:09 <beefcube> sorry, ended the line prematurely
10:44:46 <geekosaur> Capitan_Kevin, ghci has a built in debugger, that's the best you can do since haskell doesn't do evaluation the same way C/C++ do and it's somewhat difficult to do traditional debugging meaningfully with it
10:44:56 <monochrom> ghc's repl (ghci) has a debugger, but it's a repl, not an ide
10:45:04 <geekosaur> I believe this is an open research area
10:45:15 <Capitan_Kevin> seems like ghc is split up between editor and compiler where Code::Blocks is all in one, which IMHO makes for easier debbuging and code creation on the fly.
10:45:30 <enigmuriatic1> what is .: and how do i get it? it's in a code example for a module I'm using and GHC is telling me that it isn't in the scope. same with <$> and <*>
10:45:51 <monochrom> <$> and <*> are in Control.Applicative
10:46:00 <monochrom> I forgot where is .:
10:46:29 <typoclass> enigmuriatic1: (.:) is an operator some people like to define. i don't think it's in the standard library (so far)
10:46:43 <enigmuriatic1> how do i do that typoclass?
10:46:47 <typoclass> enigmuriatic1: to find out stuff like that, use hoogle or hayoo
10:46:50 <typoclass> @where hoogle
10:46:50 <lambdabot> http://haskell.org/hoogle
10:46:51 <Capitan_Kevin> ok, so that is why I'm not finding a way to "list" the code in GHC
10:46:52 <typoclass> @where hayoo
10:46:53 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
10:46:56 <Sonarpulse> well I am a going to guess the netsplit took out my question. Should bindings (with FFI) go in bindings.<lib name> ?
10:47:00 <enigmuriatic1> you can't search those things effectively
10:47:04 <enigmuriatic1> because they're all symbols
10:47:17 <monochrom> EclipseFP says it has debugging. http://eclipsefp.github.io/
10:47:22 <geekosaur> depends on what the (.:) is. I see one in aeson and yaml which is a key lookup, and a different one in various other packages which is a combinator
10:47:29 <Capitan_Kevin> *looking
10:47:44 <typoclass> enigmuriatic1: yes you can :) see hoogle. you can also search for type signatures (suppose you need something that converts a Maybe to a list, etc.)
10:47:48 <monoidal> I believe often (.:) = (.).(.)
10:48:47 <Capitan_Kevin> monoschrom: ya you rock, been looking for this with no joy and boom...is in my lap, exactly what I want!
10:49:26 <monochrom> I wouldn't be so sure
10:49:53 <monochrom> first you have to install Eclipse itself
10:50:02 <monochrom> then you have to install EclipseFP
10:50:10 <monochrom> then you have to learn how to use it
10:50:29 <monochrom> and you still don't know what it means by "debugging" yet
10:50:54 <monochrom> currently you're just excited at superficial things like "it's an IDE"
10:51:01 <Capitan_Kevin> ya, and it takes java run time...not a fan of java at all
10:51:01 <frerich> Does anybody know what the status of peaker's Haskell editor ("bottle"?) is?
10:51:27 <enigmuriatic1> it's {considered good practice/expected} that people who write libraries don't overlap standard library functions, right? because it's concerning knowing that a standard library function can be silently redefined. it seems to really violate Haskell's mantra of safety and purity.
10:52:14 <typoclass> frerich: i think it was renamed (lamdu?)
10:52:42 <frerich> typoclass: Aha, indeed - looks like it: https://github.com/Peaker/lamdu -- thanks!
10:53:36 <quchen> enigmuriatic1: Well, lots of libraries have names clashing with the Prelude or Data.List specifically.
10:53:45 <quchen> Those usually tell you to import them qualified in the docs.
10:53:54 <typoclass> enigmuriatic1: it's not so much a safety or purity thing. the compiler won't accidentally get confused and run the wrong code, just because the code is in another function of the same name. however, you're absolutely right for human readers (including yourself a few months from now)
10:54:03 <quchen> There are only so many synonyms for "length" :-)
10:54:12 <monochrom> I don't write things to overlap standard library functions. I don't know what other people do. but most people are reasonable.
10:55:13 <typoclass> enigmuriatic1: i guess a rule of thumb is -- know what you're overlapping with, and think if that is a reasonable choice. i wouldn't make a blanket recommendation to never overlap
10:55:34 <monochrom> I agree
10:56:40 <bonobo123> hi
10:57:01 <monochrom> during more than a decade, I have only seen one unreasonable name clash with the standard libraries. someone hijacked the name (.) to achieve OOP-like syntax
10:57:34 <bonobo123> I continue my lens explorations from yesterday, can anybody help with an answer?
10:58:28 <typoclass> enigmuriatic1: but that said, i hate it when i read someone else's code and they have all kinds of functions from god knows where (no matter if the names overlap or not). i prefer when the author writes e.g. "import qualified Data.Map as M", then using "M.foo", "M.bar" to refer to all the functions. i think that's the best tradeoff
10:58:36 <Sonarpulse> johnw?
10:58:44 <Sonarpulse> trying out c2hsc
10:58:59 <Sonarpulse> but it can't find gcc even when i pass it in with -g
11:02:02 <bonobo123> I'm looking for a function with type: Prism' a b -> Prism' (a :- t) (b :- t)
11:02:11 <bonobo123> here is what I have so far: http://hpaste.org/89702
11:05:34 <Capitan_Kevin> what is the general sentiment here regarding IDE's?
11:06:26 <monochrom> neutral
11:06:34 <typoclass> Capitan_Kevin: i think most people use either vim or emacs. there's a good number of plugins for that
11:07:05 <enigmuriatic1> why did this code give the error at the bottom? it seems identical to multiple examples i've looked at   http://hpaste.org/89705
11:07:10 <dgpratt> Capitan_Kevin: most people here claim to be happy with vim/emacs and that ilk
11:07:22 <enigmuriatic1> oh right, maybe i have to use all fields
11:07:37 <enigmuriatic1> how do i ignore fields, though? there are about eleven and i only want those two
11:07:40 <dgpratt> dgpratt: which puts me in the minority of people who would prefer a good IDE, if such a thing existed
11:07:47 <Capitan_Kevin> ok, sounds good...I'm happy in vim but may try emacs...seems to have some better integration
11:08:41 <Capitan_Kevin> This looks nice though...http://www.sublimetext.com/
11:09:01 <geekosaur> enigmuriatic1, that error has nothing to do with missing fields, it's saying that you aren't passing the right number of parameters
11:09:11 <dgpratt> EclipseFP is impressive, but I struggle to use it effectively
11:09:11 <Sonarpulse> emacs works nicely
11:09:28 <Sonarpulse> save, than load in ghci that's already open
11:09:33 <Sonarpulse> just two key-chords
11:09:40 <Sonarpulse> Want to try Yi though
11:09:41 <beefcube> I would like to see someone put together a tool-chain for refactoring and working on Haskell code that is IDE independent, think buffer -> parameters -> solution, the politics and IDE biases are not constructive
11:10:03 <Sonarpulse> you could probably do it with template haskell stuff
11:10:17 <enigmuriatic1> geekosaur, how would i ignore certain fields?
11:10:27 <dgpratt> beefcube: isn't there a project that attempted to be that? HaRE or something?
11:10:29 <Sonarpulse> I am not sure how seperated parsing is from the rest of GHC
11:10:32 <dmwit> beefcube: haskell-source-exts is basically that, right?
11:10:47 <geekosaur> enigmuriatic1, did you even bother reading what I said, or did you stop at the fact that I said something?
11:10:48 <monochrom> enigmuriatic1: line 20 etc is creating a new record. what does it mean to "ignore" fields when creating a new record?
11:10:50 <dmwit> Well, the parsing and pretty-printing part of that, I guess.
11:10:53 <dmwit> never mind
11:11:17 <geekosaur> mind, missing fields could well be *a* problem, but it;s not the problem the compiler is complaining about
11:11:21 <beefcube> dgpratt: well, somewhat yes
11:11:37 <monochrom> when you're making babies, what does it mean to "ignore" the sperm?
11:11:47 <Sonarpulse> Yi is supposed  to have a good interface for giving it parsers
11:12:01 <Sonarpulse> while emacs i think is more messy ad-hoc
11:12:10 <enigmuriatic1> i'm taking a JSON file with a bunch of fields and I only want to put two into the Block datatype
11:12:18 <enigmuriatic1> geekosaur, monochrom
11:12:25 <beefcube> dmwit: haskell-src-exts could be applied to such a project, but I'm looking for a solution that models what eclipse does for Java, but more reusable across editors
11:12:28 <dgpratt> monochrom: that's the most...unique analogy I've heard in a while
11:12:31 <dmwit> enigmuriatic1: Then your Block datatype will need a constructor that can handle just having two fields.
11:12:33 <dolio> Yi is missing a lot of stuff.
11:12:48 <monochrom> then what value will the 3rd field have?
11:13:03 <dmwit> beefcube: Yes, I understand. I retract my suggestion (hence the "never mind").
11:13:03 <monochrom> it is not like we have "null pointer", you know
11:13:30 <geekosaur> enigmuriatic1,  ...right, missing fields necessarily must mean missing parameters in whatever hacked ghc you have, no matter that it's unrelated in the ghc the rest of us run. so can you explain to us any other incompatibilities in your ghc?
11:13:53 <geekosaur> since you are not fixing anything related to the problem that ghc is telling you that you have
11:16:46 <FreeFull> enigmuriatic1: You could set the fields to undefined
11:16:56 <FreeFull> If they turn out to have been necessary, you'll get a runtime error
11:17:29 <monochrom> that's legal, but I wouldn't recommend that, it is not like you can later use an if-then-else to tell "did I set this field"
11:18:07 <FreeFull> Generally a good default value would be better instead
11:18:09 <geekosaur> pretty sure the compiler already does that, the fields are "initialized" to an invocation of error
11:19:09 <geekosaur> I am still struggling to understand what uninitialized fields have to do with (String -> Block) not matching (Block) as per the error message, but apparently that's not the important part
11:19:38 <monochrom> it's a long story
11:20:24 <typoclass> geekosaur: i think the question is the Block record having 3 fields, and enigmuriatic1 wants to fill only 2 of them
11:20:28 <geekosaur> oh wait, I think I get it, it's using an applicative to treat it as ADT instead of record. which is an annoying way to do it
11:20:37 <enigmuriatic1> no, i was just being an idiot, sorry
11:20:57 <monochrom> do { h <- v .: "hash"; t <- v .: "transactions"; return Block{blockhash=h, txs=t} }
11:20:57 <mm_freak> data Point f a = Point { x :: a, y :: f Z a, z :: f (S Z) a }
11:20:58 <enigmuriatic1> i missed that because i removed a field to try to fix the error and then forgot about it
11:21:34 <geekosaur> if you want to do only some of the fields, initialize it with record syntax instead. or supply the third field; you can't omit one with ADT syntax
11:22:59 <mm_freak> if you're compelled to leave uninitialized fields, your data model is probably broken
11:23:11 <Vendethiel> What's the difference between Int and Num? Num is like "Int's parent"?
11:23:13 <mm_freak> there is nothing wrong with using two types and nesting them
11:23:28 <mm_freak> Vendethiel: Num is a type class, and Int is an instance of it
11:23:34 <mm_freak> like Double, Float, etc.
11:23:39 <monochrom> Num is not a type
11:23:51 <Vendethiel> which is why I can do fn :: (type class) => class
11:23:53 <Vendethiel> alright
11:24:32 <mm_freak> Vendethiel: "class"?
11:24:34 <mm_freak> no
11:24:44 <mm_freak> fn :: (TypeClass a) => a
11:24:49 <Vendethiel> I was just pasting "type class". but yes, (typeclass a) => a
11:25:21 <mm_freak> Vendethiel: my point is that "type classes" have nothing to do with OO classes, if you came from an OO language
11:25:25 <mm_freak> and types are types, not "classes"
11:25:27 <Vendethiel> I understand that
11:25:29 <Vendethiel> don't worry
11:25:37 <Vendethiel> mm_freak: any cheatsheet for those Data/type classes tho?
11:25:37 <monochrom> using KindConstraints, "fn :: (type class) => class" is now legal :)
11:26:07 <mm_freak> Vendethiel: well, you could read one of the tutorials online like LYAH or RWH
11:26:08 <mm_freak> @where lyah
11:26:09 <lambdabot> http://www.learnyouahaskell.com/
11:26:12 <monochrom> or close to legal
11:26:12 <mm_freak> @where rwh
11:26:12 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:26:22 <Vendethiel> I'm reading a tutorial currently. There's just no cheatsheet in it
11:26:43 <mm_freak> Vendethiel: because there is no cheatsheet =)
11:26:49 <Vendethiel> I just asked for that
11:27:00 <mm_freak> except perhaps for syntax, but understanding the meaning of types will make the syntax pretty much self-explanatory
11:27:56 <Vendethiel> that's fine
11:28:01 <monoidal> :t 3
11:28:02 <lambdabot> Num a => a
11:28:09 <monoidal> Num - type class, a - type variable
11:28:13 <mm_freak> Vendethiel: i would recommend to ignore type classes for now
11:28:29 <mm_freak> whenever you see "(Num a) => a", read it as Double or Integer or something
11:28:33 <fruitFly> whyyyy? http://hpaste.org/89707
11:28:35 <Vendethiel> monoidal: I understand that
11:28:39 <Vendethiel> mm_freak: that's fine really
11:28:53 <mm_freak> Vendethiel: then i'm not sure what you're asking for
11:29:01 <Capitan_Kevin> Anyone else using the Sublime IDE, seems excellent for coding
11:29:33 <monochrom> Vendethiel: I read the Haskell 2010 Report, some books, and library docs. I have never seen a cheatsheet.
11:29:41 <Vendethiel> except said in tutoriels, where I could know that Int is an instance of the type class of Num
11:30:31 <mm_freak> fruitFly: i don't see the quoted error in the code
11:30:43 <monoidal> fruitFly: I can compile your code with no error
11:30:49 <johnw> Sonarpulse: hi
11:30:52 <Sonarpulse> hey
11:30:58 <johnw> you were looking for me?
11:30:58 <Sonarpulse> well maybe it is finding gcc
11:30:59 <mm_freak> Vendethiel: ah, you can ask GHCi for an overview of types
11:31:00 <Sonarpulse> yeah
11:31:05 <Sonarpulse> trying to use your c2hsc
11:31:05 <monochrom> http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1270006.3 has awesome pictures
11:31:10 <mm_freak> Vendethiel: enter GHCi and type:  :i Num
11:31:13 * geekosaur suspects, but with so little information cannot prove, that the code that uses it is using letterFrequencies when it means letterFrequency
11:31:15 <johnw> how can I help?
11:31:21 <Vendethiel> mm_freak: Nice! thanks!
11:31:23 <Sonarpulse> let me paste you error (single line)
11:31:31 <mm_freak> Vendethiel: however, keep in mind that this list corresponds to the currently loaded modules
11:31:36 <Vendethiel> yes indeed
11:31:43 <Sonarpulse> gcc: error: : No such file or directory
11:31:43 <Sonarpulse> c2hsc: Failed to run cpp: ExitFailure 1
11:31:46 <mm_freak> Vendethiel: if you import Data.Complex prior to that command you will see at least one additional instance
11:31:53 <johnw> how are you running it?
11:32:05 <Vendethiel> I'll get back to learning then
11:32:19 <fruitFly> mm_freak: monoidal aaaaaaah haha... i called the wrong func :P
11:32:23 <Sonarpulse> c2hsc --prefix=Network.Enet.Bindings --gcc="/usr/bin/gcc" enet/include/enet/enet.h
11:32:30 <geekosaur> heeeh
11:32:34 <fruitFly> attention to detail guys
11:32:37 <fruitFly> pay attention*
11:32:49 <mm_freak> fruitFly: or rather you tried to apply ("call") a non-function ;)
11:33:06 <mm_freak> > let f = () in f 3
11:33:07 <lambdabot>   Couldn't match expected type `a0 -> t0' with actual type `()'
11:33:24 <mm_freak> > () 3
11:33:25 <lambdabot>   Couldn't match expected type `a0 -> t0' with actual type `()'
11:33:34 <johnw> Sonarpulse: add a -Ienet/include/enet
11:33:38 <Sonarpulse> ah ok
11:33:41 <mm_freak> is that a lambdabot artifact or a GHCi artifact?
11:34:01 <johnw> byorgey: ping
11:34:03 <phulin> i'm getting an undefined symbol linker error that i don't understand
11:34:04 <Sonarpulse> with -Ienet/include/enet
11:34:14 <Sonarpulse> sorry --cppopts=
11:34:14 <mm_freak> phulin: in a cabalized package?
11:34:15 <typoclass> mm_freak: some weird defaulting thing?
11:34:16 <Sonarpulse> ?
11:34:20 <johnw> no, just -I
11:34:24 <phulin> mm_freak: yeah, let me paste one sec
11:34:26 <Sonarpulse> that didn't work
11:34:28 <monoidal> mm_freak: what's wrong with it?
11:34:29 <johnw> oh, sorry
11:34:31 <johnw> you're right
11:34:35 <johnw> --cppopts=-I...
11:34:36 <typoclass> mm_freak: doesn't work in ghci for me. but i don't have much turned on
11:34:39 <mm_freak> phulin: you need to mention all modules, either in exposed-modules or other-modules
11:35:19 <mm_freak> typoclass, monoidal:  i would have expected "tried to apply non-function" as the type error
11:35:22 <Sonarpulse> c2hsc --prefix=Network.Enet.Bindings --gcc="/usr/bin/gcc" enet/include/enet/enet.h --cppopts='-Ienet/include/'
11:35:25 <Sonarpulse> ^ that worked!
11:35:27 <phulin> mm_freak: it's in one of my dependencies
11:35:33 <Sonarpulse> thanks so much johnw
11:35:42 <typoclass> mm_freak: yeah, i got "type is (), but needed "a -> b"
11:35:42 <johnw> cool, now you have to "massage" the result to be fully correct
11:35:45 <phulin> and i'm having trouble locating which one
11:35:50 <phulin> mm_freak: http://hpaste.org/89710
11:35:53 <johnw> c2hsc gets you 90% of the way, but it can't get you all the way there for a variety of reasons
11:36:03 <phulin> maybe it's in hashtables?
11:36:04 <monoidal> mm_freak: long version of this message (visible in ghci) says "the function is applied to one argument, but its type has zero" which is weird, but helpful
11:36:14 <typoclass> Cale: ohai
11:36:17 <Sonarpulse> oh i understand
11:36:23 <mm_freak> phulin: oh, good question then
11:36:23 <Sonarpulse> with all those gcc extensions and what not
11:36:31 <johnw> and anything preprocessor related
11:36:32 <Sonarpulse> 90% is still quite impressive
11:36:44 <mm_freak> phulin: i don't know the package you are using, but perhaps it requires compiling with -fllvm or something?
11:37:01 <phulin> mm_freak: i should mention that this wasn't a problem until i started using template haskell
11:37:08 <typoclass> monoidal: yeah that's what i meant :) i was quoting from memory and had the window already closed
11:37:22 <mm_freak> phulin: i don't know, sorry‚Ä¶  if you don't get an answer here, try again on haskell-cafe
11:37:34 <phulin> mm_freak, it's some LLVM bindings for haskell that i found on github
11:37:42 <phulin> certainly possible there's an error in his cabal file
11:37:52 <phulin> okay :/
11:37:55 <mm_freak> phulin: yeah, that's a reasonable conclusion
11:38:06 <mm_freak> phulin: it may also be a version mismatch
11:38:21 <mm_freak> if a C++ function changes its type, its mangled name also changes
11:38:32 <johnw> phulin: that looks like you aren't linking to a C++ lib that you need to be
11:39:27 <phulin> yeah, it does
11:39:32 <mm_freak> you may have to link against a different version of LLVM
11:39:45 <Sonarpulse> johnw: should the #include to the header be relative to the file
11:39:48 <Sonarpulse> or to the repo root?
11:39:58 <johnw> phulin: what if you feed that big mangled name to the demangler?
11:40:04 <Sonarpulse> I assume I should move the file into a folder to reflect its hierarchical location
11:40:16 <Sonarpulse> so Network/Enet/Bindings.hs
11:40:28 <johnw> Sonarpulse: yes, I would
11:41:59 <Sonarpulse> ok
11:42:51 <phulin> johnw, it's some hashtable function
11:43:31 <phulin> looks like i'm going to have to go digging through these bindings
11:43:34 <johnw> llvm version mismatch?
11:43:38 <phulin> possibly
11:43:51 <phulin> the author claims his bindings are compatible with llvm 3.0-3.2
11:43:56 <phulin> and i'm using 3.0.something
11:44:11 <phulin> again it's weird that it wasn't a problem until i started using template haskell
11:44:14 <Sonarpulse> so you do you need to put the --cppopts in the cabal file too then I assume?
11:44:27 <johnw> Sonarpulse: i don't call c2hsc from my cabal file
11:44:34 <johnw> i commit the generated flies (since they need massaging by hand)
11:44:47 <Sonarpulse> yeah
11:44:58 <Sonarpulse> well i mean so hsc knows what to call gcc with?
11:45:03 <johnw> ah, in that case, yeah
11:47:09 <Sonarpulse> also, I got a bunch of types like enet_uint32
11:47:35 <Sonarpulse> how should I "connect them" to haskel's fixed width types
11:47:46 <Sonarpulse> I guess this is more of a general FFI question
11:48:11 <johnw> they are probably typedefs for CUInt
11:48:27 <johnw> the Haskell type will be C'enet_unit32
11:48:34 <johnw> conversion is up to you
11:48:53 <FreeFull> All those joins and parts get annoying
11:49:17 <byorgey> FreeFull: so hide them.
11:49:25 <johnw> byorgey: hi!
11:49:35 <FreeFull> But then I won't know if someone who I was talking to left
11:49:39 <byorgey> FreeFull: and if your IRC client does not support hiding join/part messages, get a better IRC client.
11:49:40 <Sonarpulse> ah, so I convert them in haskell
11:49:44 <Sonarpulse> johnw
11:49:47 <Sonarpulse> ok
11:50:13 <byorgey> FreeFull: so write a plugin for your IRC client which only hides join/part messages for people you were not recently talking to. ;-)
11:50:20 <byorgey> hi johnw!
11:50:25 <FreeFull> byorgey: Too lazy =P
11:50:29 <johnw> byorgey: I had a data structures question for you
11:50:32 <FreeFull> And I don't think irssi does Haskell
11:50:38 <byorgey> FreeFull: nope, perl
11:50:53 <byorgey> FreeFull: so write Haskell bindings to the irssi plugin architecture!
11:50:54 <dmwit> irssi can hide netsplit/netjoins.
11:51:17 <byorgey> johnw: ok, shoot
11:51:19 <FreeFull> Perl is the default, but there are bindings to, for example, python
11:51:27 <johnw> byorgey: Has anyone looked at the connection between the most common data structures, and the free objects of algebraic structures?  Example: free semigroup -> Stream, free monoid -> List, free abelian group -> Set, free vector space -> Map, etc.?
11:51:47 <FreeFull> dmwit: That didn't look like a netsplit to my irssi though
11:51:55 <dmwit> bummer
11:52:50 <johnw> I wonder if every one of the "classic" data structures arises from an algebraic structure
11:53:00 <byorgey> johnw: google for the "Boom Hierarchy"
11:53:23 <typoclass> byorgey: kaboom?
11:53:23 <byorgey> that at least covers some of them
11:53:40 <DanBurton> johnw: what "classic" data structures are there, besides the ones you have just mentioned? And I don't think I'd call Stream classic.
11:53:41 <johnw> sweet, I knew you'd be the person to ask :)
11:53:56 <byorgey> johnw: I don't know if it's been investigated more systematically for arbitrary algebraic structures but I wouldn't be surprised
11:54:17 <fruitFly> :)
11:54:19 <johnw> DanBurton: hmm.. good question
11:54:27 <phulin> johnw, I think I'm just going to stop using TH. it seems like this is cause by the same issue htat prevents me from using GHCI...
11:54:50 <DanBurton> johnw: according to the old lisp-ers, cons is all you need :P
11:54:58 <johnw> I wonder what the free object for a ring looks like, for example
11:55:12 <monoidal> Polynomials
11:55:54 <monoidal> a free ring over A is the ring of polynomials where variables are taken from A
11:56:23 <johnw> thanks, monoidal!
11:56:58 <byorgey> from a structural point of view, free rings are not very interesting (they are just lists)
11:57:03 <monoidal> from a function f : A -> R you can get f' : Z[A] -> R by evaluating
11:57:13 <byorgey> but they are lists with some very interesting operations
11:57:21 <monoidal> like from a function A -> M you can get a monoid homomorphism list(A) -> M
11:57:23 <byorgey> corresponding to operations on polynomials.
11:57:30 <fruitFly> ok so I have a function that :: String -> Double. I want to sort [String] from lowest to highest based on the results of the String -> Double function. What do you think is a good way to go about doing this?
11:58:02 <byorgey> fruitFly: sortBy (comparing foo)
11:58:12 <byorgey> where  foo :: String -> Double
11:58:16 <byorgey> sortBy is in Data.List
11:58:18 <monoidal> sortBy (comparing that)
11:58:21 <byorgey> and comparing is in Data.Ord
11:58:30 <byorgey> hehe
11:58:37 <fruitFly> byorgey:  monoidal Thanks :)
12:00:04 <fruitFly> sortBy :: (a -> a -> Ordering) -> [a] -> [a]
12:00:12 <fruitFly> (a -> a -> Ordering)
12:00:15 <fruitFly> ?
12:00:25 <fruitFly> a -> a --> ordering?
12:00:32 <monoidal> :t comparing
12:00:32 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
12:00:43 <phulin> johnw, unless i'm very confused it looks like this is the relevant bug:
12:00:44 <phulin> http://hackage.haskell.org/trac/ghc/ticket/3333
12:01:05 <monoidal> sortBy sorts given a comparison function (a -> a -> Ordering). Normal sorting is sort = sortBy compare
12:01:17 <johnw> phulin: that's certainly a good guess!
12:01:24 <johnw> have you checked the symbol table for that symbol it's not finding?
12:01:31 <fruitFly> monoidal: ooooooooooooooooh
12:02:09 <phulin> johnw, which symbol table? i don't have a lot of experience tracking these down
12:02:12 <fruitFly> monoidal: omg god haskell is smart to have a function like comparing lol
12:02:20 <phulin> (though i know basically how to use nm, etc)
12:02:27 <fruitFly> monoidal: i dn't think haskell is ever gonna stop blowing my mind lol
12:02:34 <johnw> fruitFly: it gets even better, when you mix in monoids with comparing ;)
12:02:55 <fruitFly> johnw: haha... dn't explode my pew brain yet :P
12:02:55 <monoidal> Ordering is a monoid
12:03:06 <Sonarpulse> anybody gunna redo prelude with better abstract algebra?
12:03:08 <fruitFly> know nothing about monads, monoids etc
12:03:23 <johnw> you know lots about monoids, you just don't know it by that name yet :)
12:03:37 <fruitFly> off topic question: but how difficult would it be for haskell to swap the functions of :: and :?
12:03:42 <fruitFly> :: and :
12:03:50 <johnw> example: sortBy (comparing width <> comparing height)
12:03:59 <Sonarpulse> get rid of list functions and replace them with Ring typeclass then?
12:04:11 <monoidal> fruitFly: in the parser - I think it would not be *that* hard to switch
12:04:13 <johnw> fruitFly: that would require changes to the Haskell parser
12:04:31 <monoidal> fruitFly: but essentially every program would not compile
12:04:39 <Sonarpulse> and then make it so monad has to also be a functor
12:04:49 <johnw> Sonarpulse: that one might be coming soon
12:04:56 <johnw> instead, we'll make every monad an Applicative
12:04:57 <Sonarpulse> that's the only one I heard about
12:04:59 <fruitFly> monoidal: if one just swapped the :: with the : would they then compile?
12:05:02 <monoidal> Sonarpulse: there are many attempts, for example http://hackage.haskell.org/package/numeric-prelude
12:05:44 <monoidal> fruitFly: if you mean doing that by default, you would have to rewrite base, every place in ghc etc
12:05:50 <fruitFly> omg I can't wait till I'm as good as you guys lol
12:06:02 <monoidal> fruitFly: if there was a flag -XInvertColons then it wouldn't be that big IMO
12:06:24 <johnw> I wonder why Haskell chose ::/: the way it did
12:06:32 <johnw> when so many other languages have gone the other way
12:06:37 <monoidal> (I, for one, support inverting : and :: but this change is as hard as changing direction of current in electricity books.)
12:06:39 <phulin> yeah, me too - i use :: a lot more than :
12:07:01 <fruitFly> it sounds like it wouldn't be that difficult to switch from both the compiler and application side from what I understand from you guys
12:07:12 <Sonarpulse> template haskell your : and :: problems away!
12:08:00 <fruitFly> it's still a little surprising to me what languages are popular in industry considering functional programming
12:08:04 <jonkri> is bytestring incompatible with ghc 7.0.1? i'm using ghc 7.0.1 since i want to test my build against all 7.0+ versions of ghc (ghc panics while building bytestring with a "the impossible happened" error)
12:08:05 <fruitFly> as a newbie
12:08:51 <Sonarpulse> in general: popular of language = (quality of language)^(-1)
12:09:07 <Sonarpulse> *popularity
12:09:41 <johnw> fruitFly: when you can fathom the popularity of PHP when any other language exists, you will know the answer to that question too
12:10:56 <nexx> I think PHP is the second most mentioned languages in this channel
12:11:14 <johnw> nexx: in the same way that Bizarro shows up in so many Superman episodes
12:11:24 <josephle> the punching bag of all dynamically typed imperative languages
12:11:41 <nexx> hehe
12:12:04 <josephle> which is strange because you'd think Perl gets that dubious honor. But PHP manages to beat even that.
12:12:14 <monoidal> nexx: I checked, java is mentioned more often than perl and perl more often than php
12:12:21 <johnw> Perl isn't nearly as popular as PHP anymore, is it?
12:12:31 <monoidal> http://ircbrowse.net/browse/haskell?q=java if you want to play with
12:12:33 <nexx> I never saw perl in this channel before
12:12:43 <josephle> johnw: always a use for perl. sure beats having to bang out bash scripts.
12:12:51 <geekosaur> perl was mentioned a bit more when the Evil Mangler was still part of ghc
12:13:02 <johnw> I use, in this order: Haskell, Emacs Lisp, bash
12:13:22 <bscarlet> Is there an automatic system somewhere which build packages uploaded to Hackage?
12:13:33 <Sonarpulse> if they ever finish porting emacs to guille
12:13:38 <irene-knapp> yes.  not for distribution though.  only to check if they build.
12:13:39 <Sonarpulse> no more emacs lisp for me!
12:13:48 <johnw> Sonarpulse: yeah, been waiting 20 years for that actually, still waiting
12:13:51 <applicativa> nexx: there's some perl masters frequenting this place
12:13:54 <schoppenhauer> the DiffArray documentation claims that DiffArrays are very slow. Is there any explanation why that is the case? I do not know the actual implementation, but reading and writing should not have too much overhead, so that would be interesting. *push*
12:13:56 <josephle> is java the punching bag of all statically typed OO imperative languages?
12:14:13 <dmwit> Why can't we all just get along?
12:14:18 <ludamad> josephle, pretty much
12:14:18 <Sonarpulse> johnw: https://github.com/hraberg/deuce
12:14:18 <josephle> then again, it *is* the only one (since C# is basically the same)
12:14:27 <bscarlet> irene-knapp: How does that system handle dependencies for packages which use FFI and need outside code?
12:14:37 <ft> guile-emacs is a summer of code project this year, though.
12:14:43 <irene-knapp> bscarlet: it usually fails to
12:14:44 <Sonarpulse> and others too
12:14:46 <monoidal> jonkri: bytestring has been a long time before 7.0, if current version is compatible you might find some older version works
12:14:50 <nexx> applicativa kay
12:14:53 <josephle> dmwit: because people need to justify their funding in PL research!
12:14:58 <monoidal> jonkri: *incompatible
12:15:00 <geekosaur> C++ gets maligned at least as much, mainly because of templates
12:16:00 <Philonous> Since which version of ghc can I quote patterns?
12:16:13 <bscarlet> irene-knapp: I have such a package, and I'm considering uploading it to Hackage. Is doing so and allowing Hackage to be unhappy standard usage, or should I do something else? Who decides matters like this?
12:16:30 <irene-knapp> that's standard, don't worry about it
12:16:36 <irene-knapp> Hackage is a source distribution thing
12:16:39 <irene-knapp> we don't distribute binaries
12:16:40 <bscarlet> irene-knapp: Thank you.
12:16:44 <irene-knapp> np :)
12:16:55 <monoidal> Philonous: It is now possible to quasi-quote patterns with [p| ... |]. -- http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/release-7-0-1.html
12:17:10 <Philonous> monoidal:  Thanks!
12:17:15 <DanBurton> so, do we leave binary distribution to each platform's distribution mechanism then?
12:17:31 <DanBurton> is that the idea?
12:17:39 <Cale> geekosaur: It might also have something to do with the fact that the specification is somewhere on the order of 1.5k pages long and almost impossible to completely internalise at once. :)
12:17:39 <johnw> Sonarpulse: I just can't get excited about Clojure, sorry
12:17:55 <dmwit> josephle: I don't think anybody in PL research thinks the tool they're using their funding to research is going to replace all other languages ever.
12:18:03 <dmwit> That's not really a realistic goal.
12:18:21 <irene-knapp> yeah, agreed with dmwit
12:18:25 <tdammers> only pythonistas think that anyway
12:18:35 <josephle> dmwit: I was just being facetious :P
12:18:47 <irene-knapp> DanBurton: or to nobody.  Cabal is a wonderful tool for building against versions that aren't specifically designed to work together
12:19:27 <armlesshobo> Hooked on Pythonics
12:19:59 <enigmuriatic1> http://hpaste.org/89713     how do i get this to work with IO?
12:20:01 <josephle> armlesshobo: I had to go check that no one actually made that
12:21:11 <fruitFly> comparing is a part of data.what?
12:21:12 <dmwit> enigmuriatic1: Perhaps you will like liftM2 (:).
12:21:19 <dmwit> ?index comparing
12:21:19 <lambdabot> bzzt
12:21:21 <dmwit> Data.Ord
12:21:22 <johnw> @hoogle comparing
12:21:22 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
12:21:28 <enigmuriatic1> dmwit, i don't know about monads yet, how do i use that?
12:21:30 <fruitFly> o shizzle thanks
12:21:53 <dmwit> enigmuriatic1: http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
12:22:03 <dmwit> ...-who-simply-dont-care
12:22:17 <johnw> enigmuriatic1: decode . BL.pack <$>
12:22:28 <geekosaur> enigmuriatic1, getBlocks needs to be in IO if you want to use IO with it
12:22:31 <johnw> enigmuriatic1: and then: (:) <$> block <*> (getBlocks $ prevHash block)
12:22:57 <Sonarpulse> johnw: no, I am not excited about clojure, but the thing actually starts
12:23:23 <Sonarpulse> I hope once guile-emacs is more complete
12:23:29 <geekosaur> (line 24)
12:23:30 <DanBurton> enigmuriatic1: getBlocks is not a pure function, because it invokes readProcess. So firstly, the type signature should be BL.ByteString -> IO [Maybe Block]
12:23:31 <dmwit> johnw: Give a man a fish, teach a man to fish, etc.
12:23:38 <johnw> having a Scheme in Emacs would be brilliant
12:23:50 <irene-knapp> teach a man to tunefs?
12:23:52 <johnw> dmwit: i like to give them a fish to gnaw on while they are learning how to cast the pole
12:23:59 <Sonarpulse> my favorite lisp is racket
12:24:08 <Sonarpulse> I'd hope I could take deuce and port it to racket
12:24:27 <Sonarpulse> the emacslisp -> statically scoped lisp sould be preservable
12:24:30 <carter> lispy : yo! question, can I use Language-C-Quote to parse C declarations? i'm having trouble getting that to work
12:24:47 <Sonarpulse> because what deuce does the guille-emacs doesn't is also chuck most of the C code
12:24:53 <fruitFly> not in scope 'Comparing' .... and Import Data.Ord (Comparing) does not work ...... how do I get Comparing to be in da scope!
12:24:53 <johnw> carter: I use language-c to parse C declarations all the time, what's the problem?
12:24:59 <carter> ohh
12:25:06 <johnw> fruitFly: comparing, not Comparing
12:25:12 <carter> I'm trying to use it for something like "lapack_int lca, lapack_int lcb );"
12:25:15 <jonkri> monoidal: thanks. 0.9.2.1 seems to be the last version of bytestring that works in my ghc 7.0.1 environment
12:25:16 <carter> i mean
12:25:17 <carter> hang on
12:25:19 <fruitFly> oh johnny lololol
12:25:24 <carter> apack_logical LAPACK_lsame( char* ca,  char* cb,lapack_int lca, lapack_int lcb );
12:25:33 <johnw> carter: and your error is?
12:25:34 <carter> lapack_logical LAPACK_lsame( char* ca,  char* cb,lapack_int lca, lapack_int lcb );
12:26:01 <Sonarpulse> jown: according to the gsoc description, this is now the 4th year of guile-emacs in gsoc, and the others met their goals, so hopefully its actually comming this year or the next
12:26:05 <carter> johnw well, i'm probably doing it wrong <interactive>:26:9:
12:26:05 <carter>     <interactive>:26:10:
12:26:05 <carter>     parse error on `lapack_logical'
12:26:07 <Sonarpulse> *johnw
12:26:18 <carter> otoh, i'm not able to find the module which does the string -> AST work
12:26:21 <jonkri> (also, lifted-base-0.2.1.0 fails with an "unrecognized option: --disable-benchmarks" error)
12:26:26 <carter> eg [cedecl| lapack_logical LAPACK_lsame( char* ca,  char* cb,lapack_int lca, lapack_int lcb );|]
12:26:28 <johnw> carter: has the typedef for lapack_logical been seen?
12:26:37 <carter> i'm testing a snippet :)
12:26:50 <johnw> it needs a declaration
12:26:55 <johnw> otherwise, that isn't grammatical C
12:27:11 <carter> ok
12:27:14 <johnw> language-c is not a fuzzy parser that parses "C-ish" constructions
12:27:21 <carter> it doesn't allow free fariable?
12:27:24 <carter> *variables
12:27:34 <johnw> free type variables?  no
12:27:37 <carter> :P
12:27:42 <enigmuriatic1> i don't understand how you use this recursively though
12:27:46 <johnw> all types must be declared, or fundamental
12:27:51 <carter> johnw so it does validation
12:27:52 <carter> ok
12:27:53 <geekosaur> C can't be parsed without being able to identify types as such
12:27:58 <carter> ahhh
12:28:01 <josephle> in the presence of free type variables, C is no longer a context free grammar
12:28:03 <johnw> enigmuriatic1: I've been forbidden from giving you more fish
12:28:15 <geekosaur> (this leads to lots of fun in C parsers when you consider "typedef")
12:28:48 <josephle> geekosaur: that's when parser combinators start laughing at parser generators
12:28:58 <irene-knapp> I hope not
12:29:09 <carter> johnw so i'll probababy have to do a CPP pass before i can parse a given .h file that does other imports
12:29:26 <johnw> I always wondered what that giggling sound coming from my machine was.  It's Parsec laughing at Happy?
12:29:51 <johnw> carter: language-c will cause the cpp pass to happen
12:29:53 <kaiko> I'd like to do something like this: dbConn :: (IConnection conn) => String -> conn ;  dbConn "pg" = connectPostgreSQL "dbname=foo" ; dbConn "lt" = connectSqlite3 ":memory:" but get error: Couldn't match type `Database.HDBC.PostgreSQL.Connection' with `Database.HDBC.Sqlite3.Connection'
12:29:54 <josephle> johnw: have you been parsing context sensitive grammers?
12:30:01 <carter> johnw how'll it lookup  those ?
12:30:05 <carter> what if there are includes?
12:30:18 <johnw> carter: you need to pass in cppopts then
12:30:24 <carter> i'llok
12:30:28 <carter> huh
12:30:31 <johnw> josephle: hmm.... not lately
12:30:45 <carter> johnw http://hackage.haskell.org/packages/archive/language-c-quote/0.7.2/doc/html/Language-C-Parser.html ?
12:30:50 <dmwit> enigmuriatic1: What have you tried?
12:30:54 <josephle> then that laughing sound is still a mystery I fear
12:30:59 <enigmuriatic1> i don't understand how recursion is possible if I can't use functions on IO types
12:31:19 <josephle> enigmuriatic1: who told you you can't use functions on IO types?
12:31:23 <carter> so how do i do that?
12:31:27 <carter> the docs are a bit sparse...
12:31:39 <johnw> carter: Ah, you call runPreprocessor first
12:31:45 <enigmuriatic1> it tells me that it expected the non-IO form of the type
12:31:45 <carter> wheres that?
12:31:59 <johnw> Language.C.System.Preprocess
12:32:04 <dmwit> enigmuriatic1: You can use functions on IO types. But they have to be functions that understand what to do with IO types.
12:32:19 <Clint> kaiko: you want to what?
12:32:31 <enigmuriatic1> the functions that I need to write this function/script don't know what to do with IO types
12:32:51 <carter> johnw OH, thats different from language-c-quote
12:32:52 <carter> ok
12:32:53 <dmwit> Now I'm torn.
12:32:55 <carter> i'm less confused now
12:33:10 <carter> yay, theres docs
12:33:16 <dmwit> If you followed along with the tutorial, then you should be reading "IO" as "statement", and then it's true that you don't really hand statements to functions.
12:33:19 <kaiko> Clint: I want to make different db connections but I can't find a way to do it
12:33:34 <Clint> kaiko: you want to make two db connections and then do what with them?
12:33:36 <dmwit> But you also don't need to *pass* statements in -- only use them.
12:33:52 <enigmuriatic1> dmwit, i don't understand what you mean by that
12:34:00 <dmwit> right, let me try again
12:34:13 <carter> johnw thanks
12:34:17 <enigmuriatic1> i  have to get this script finished asap so I can't read a whole chapter on monads at the moment
12:34:18 <kaiko> Clint: I want to make one connection depending on configuration
12:34:24 <enigmuriatic1> i just need to get this two-line function working
12:34:42 <josephle> !poke bgates
12:34:45 <josephle> oops
12:34:47 <dmwit> Oh, well then I have no sympathy.
12:34:55 <dmwit> If you haven't read the chapter, you can just wallow.
12:35:11 <Clint> kaiko: oh, i see. you need to have dbConn return the same type no matter what.
12:35:18 <Clint> and you're not doing that
12:35:19 <kaiko> Clint: it would also be ok: if someCond then connectPostgreSQL "... else connectSqlite3 ":memory"
12:35:31 <dmwit> (Because explaining it to you here will just be me retyping that chapter. So I lose, and you don't win. What's the point of that?)
12:35:35 <Philonous> dmwit:  What do you mean by "you don't really hand IO actions to functions" ?
12:35:54 <nooodl> are there any laws for the Num typeclass?
12:35:58 <dmwit> Philonous: What I actually meant was "you don't need to hand IO actions to functions to fix your hpaste".
12:36:02 <enigmuriatic1> http://hpaste.org/89713
12:36:08 <enigmuriatic1> that's what i have now
12:36:10 <kaiko> but dbConn returns some instance in class IConnection as I understand. am I wrong?
12:36:50 <dmwit> Also: the link I sent you is not a chapter on monads. It is a chapter on IO.
12:37:05 <fruitFly> mm_freak: ???
12:37:22 <dmwit> It's very nearly the minimal possible set of explanations you can give and still hope that the person on the other end can write their own IO code.
12:38:11 <mm_freak> fruitFly: ?
12:38:17 <Clint> kaiko: String -> Database.HDBC.PostgreSQL.Connection is not the same type as String -> Database.HDBC.Sqlite3.Connection
12:38:28 <geekosaur> kaiko, that sounded suspiciously like OOP thinking. Haskell doesn't do OOP
12:38:52 <geekosaur> (at least, not as a fundamental part of the language)
12:38:54 <carter> johnw i'm sorting out writing an "auto ffi" for generating (sanishly) the ffi wrapping for the c-blas c-lapack
12:38:56 <carter> libs
12:39:04 <josephle> geekosaur: Objects are just co-falgebras, what's the problem?
12:39:12 <carter> and i may as well make it none fragile
12:39:15 * geekosaur *eyeroll*
12:39:17 <carter> by using an actual parser
12:40:00 <kaiko> geekosaur, I try hardly to get free of OOP thinking ;)
12:40:46 <fruitFly> mm_freak: I'm not neglecting your question, but the plainTexts that I'm trying to find which are english of, I'm testing letter frequency while they're in base64, right?
12:40:54 <FreeFull> I can't think OOP, functional is too ingrained in me
12:41:08 <apples> /buffer/buffer 5
12:41:11 <apples> sorry
12:41:18 <FreeFull> I can do procedural though if necessary
12:41:34 <kaiko> Clint, do you mean return like Monad function return?
12:42:02 <josephle> FreeFull: well, if haskell ever exposes recurive types to the programmer, OOP will be easy to implement :P
12:42:11 <josephle> *recursive
12:42:14 <Clint> kaiko: no, i do not
12:42:26 <kaiko> as I understand all connections are instances of IConnection (http://hackage.haskell.org/packages/archive/HDBC/2.3.1.1/doc/html/Database-HDBC-Types.html#t:IConnection)
12:42:36 <Clint> that doesn't make them the same type
12:42:52 <FreeFull> josephle: As in a type that references itself?
12:43:02 <Cale> The core of what OOP is can be expressed functionally quite nicely.
12:43:13 <ski> josephle : equi-recursive, itym ?
12:43:29 <johnw> carter: maybe c2hsc can give you a head start
12:43:32 <johnw> carter: you could probably hack it into something that does exactly what you want
12:43:53 <Sonarpulse> johnw: where is bindings.dsl.h supposed to be
12:44:03 <johnw> Sonarpulse: have you installed Bindings-DSL?
12:44:10 <fruitFly> quick poll: in 1 sentence how are you applying haskell and choice of os?
12:44:18 <johnw> it should have installed along with c2hsc
12:44:22 <fruitFly> primarily the first part  actually
12:44:28 <fruitFly> how are you applying haskell?
12:44:35 <mm_freak> fruitFly: i can't help you with that question, because that's your task
12:44:48 <fruitFly> mm_freak: I'm not seeking help :)
12:44:50 <Cale> fruitFly: The company I work for is using Haskell to implement its web application backend.
12:44:51 <johnw> fruitFly: fpcomplete.com
12:44:51 <fruitFly> oooooooooooh
12:45:08 <mm_freak> kaiko: that's where your misconception is
12:45:15 <mm_freak> not /connections/ are instances of IConnection
12:45:21 <mm_freak> but the /types/ of those connections
12:45:28 <josephle> ski: yes, yes. Keep forgetting about equi and iso-recursive
12:45:30 <mm_freak> that's why the name "IConnection" is highly misleading
12:45:55 <carter> johnw GOOD IDEAA
12:45:57 <carter> i'll find out
12:46:17 <fruitFly> Cale: interesting... what web app and what back end? happstack?
12:46:27 <Cale> skedge.me and snap
12:46:47 <johnw> carter: it's not the prettiest code, but it should give you a leg up
12:47:02 <johnw> fruitFly: we're using Yesod
12:47:02 <carter> johnw k, i'll need to read the docs a bit before i can invoke it it sounds like
12:47:13 <josephle> FreeFull: not quite. recursive types are types that fulfill certain isomorphisms
12:47:16 <Cale> Our old backend was a horrible mess that was written in Groovy, so I'm happy that we've decided to reimplement it.
12:47:18 <fruitFly> johnw: that's cool, I just read that you're giving away thousands in monthly challenges. I really want to apply haskell to real world problems, so maybe once I get my skills up and I can try at them :)
12:47:28 <johnw> carter: i invoke it like this: c2hsc --prefix=Bindings.Libgit2 --cppopts='-U__BLOCKS__ -I../../libgit2/include' file.h
12:47:48 <fruitFly> johnw: is Cale working at fpcomplete?
12:47:54 <Cale> no
12:47:55 <johnw> fruitFly: no, I wish
12:47:58 <carter> fruitFly nope, skedgme is different
12:48:00 <fruitFly> hahaha
12:48:01 <carter> also in nyc :P
12:48:04 <josephle> FreeFull: for example, the isomorphism intlist === unit + (int x list)
12:48:08 <carter> and no yesod :P
12:48:16 <josephle> erm intlist === unit + (int x intlist)
12:48:18 <carter> i kid  i kid
12:48:22 <Cale> fruitFly: Before that, I was working on an action role playing game for iPhones and other mobile devices in Haskell. That project only got about 80% finished before the startup ran out of money, but we should eventually come back to it and put together something we can sell.
12:48:34 <fruitFly> carter: what?
12:48:45 <carter> fruitFly skedgme is where Cale  works
12:48:48 <irene-knapp> Cale: oh, sorry to hear.  I was looking forward to that project :)
12:48:48 <carter> as he just linked to before
12:49:01 <mm_freak> wow, someone actually used groovy?  i thought no haskeller can take that language seriously
12:49:01 <FreeFull> [Int] === () | (Int,[a])  or what?
12:49:03 <fruitFly> carter: oooooooooh
12:49:17 <fruitFly> Cale: oh! so I could write ios apps with haskell?
12:49:22 <fruitFly> nice!
12:49:39 <Cale> mm_freak: The haskellers at skedge.me didn't actually make that decision ;)
12:49:45 <monoidal> FreeFull: [Int] === () | (Int,[Int])
12:49:52 <mm_freak> Cale: yeah, i assumed so =)
12:49:59 <Cale> fruitFly: Of course. With a little work, you can write ios apps in anything.
12:50:08 <jonkri> any idea why the build of Distribution.Client.Dependency.TopDown of cabal-install-1.16 crashes with an out of memory error?
12:50:19 <kaiko> mm_freak, so, I can't use type variables on returning part?
12:50:28 <mm_freak> kaiko: of course you can
12:50:39 <fruitFly> Cale: would you say your web app is smoothe compared to other languages and their frameworks? smoothe as silk?
12:50:41 <kaiko> mm_freak, then I'm still confused
12:50:54 <Cale> fruitFly: I don't know what that means
12:51:00 <mm_freak> kaiko: could you rephrase your question?
12:51:33 <fruitFly> Cale: would you say your web app is smoothe compared to other languages' and their frameworks' webapps***? smoothe as silk?
12:51:40 <carter> johnw i'm missing somethig, how do i use c2hs to *GENERATE* stuff
12:51:49 <fruitFly> Cale: are haskell web apps smoothe as silk is what I'm saying, comparitively?
12:51:54 <flebron> Hi. Could someone help me find inefficiencies in my code? http://hpaste.org/89715 What it's doing is getting coefficients a_i from stdin, and computing the polynomial p(x) = \prod_i (1 - x/a_i) = (\prod_i (x-a_i)) / ((-1)^n * (\prod_i a_i)). It's then computing the indefinite integral of p, and evaluating it at min {a_i}. Should this take a significant amount of time?
12:51:58 <carter> i actually don't want to write them all down ...
12:52:23 <kaiko> mm_freak: generally -- how can I create function that returns connection of different database engine and use this connection on same codebase (hdbc)?
12:52:23 <carter> like it'd be a terrible terrible idea to actualy do that
12:53:14 <mm_freak> kaiko: HDBC isn't really designed that way
12:53:23 <flebron> I've profiled it, and it spends 25% of the time in GC, about 70% in "MUT", which I don't know what it means. Sample input for the program is at http://hpaste.org/89716 .
12:53:30 <mm_freak> kaiko: in general you would capture the notion of a connection as a certain type, not a type class
12:54:10 <Cale> fruitFly: I don't understand the words you are using. What does "smoothe" mean, and why does it have a superfluous 'e' at the end?
12:54:27 <mm_freak> kaiko: i would go as far as to say that HDBC is badly designed, but then its design is inspired by JDBC, so it's not exactly a surprise =)
12:54:41 <ChongLi> hey, I was just checking out this case study posted to r/programming
12:54:49 <ChongLi> and one of the languages they tested was Haskell
12:54:53 <Philonous> Cale:  Sounds smoother with the e
12:55:04 <carter> johnw what are some good example projects that use c2hs?
12:55:24 <ChongLi> and it failed a test where a read-only stdout is given to a program which prints hello world
12:55:28 <noctux> hello, I've got a little question. I'm still rather new to haskell (and its monads) as such, and therefore wondered whether there is a better way to write this code: https://paste.xinu.at/jDTe/ . It's intented to do a quickSort, and then return how many comparisions (first entry) and writing list operations there have been. Because currently it looks really really ugly, and so much unlike the classical
12:55:29 <carter> 'cause honestly it looks like it'd be easier to just use language-c
12:55:30 <carter> :)
12:55:30 <noctux> haskell + quicksort example :(
12:55:31 <fruitFly> Cale, I was just wondering if webapps with a haskell back end have the potential to be highly responsive and performant, especially compared to web apps written in other languages' frameworks.
12:55:36 <Philonous> carter:  gtk2hs (it uses a modified version, though)
12:55:45 <ChongLi> and haskell fails silently without error
12:55:57 <fruitFly> Cale: popular industry frameworks, like rails and Django?
12:56:10 <fruitFly> or any in general in fact
12:56:10 <ChongLi> unless the code is interpreted directly through runhaskell
12:56:15 <Cale> fruitFly: yes. (Though I also hate the word "performant"
12:56:16 <Cale> )
12:56:16 <FreeFull> monoidal: well, that's pretty much the definition of a list though
12:56:25 <kaiko> mm_freak, so it's just different libraries with same function names?
12:56:32 <fruitFly> Cale: why?
12:56:35 <ChongLi> then it throws a "Bad file descriptor" exception
12:56:35 <ski> noctux : suspected cut off near "... Because currently it looks really really ugly, and so much unlike the classical"
12:56:36 <fruitFly> maybe I'm using it wrong
12:56:40 <ChongLi> what's going on here?
12:56:40 <carter> Philonous icky‚Ä¶.
12:56:43 <monoidal> FreeFull: indeed.
12:56:43 <carter> ok
12:56:45 <carter> thanks though
12:57:10 <mm_freak> kaiko: no, different libraries with a common interface captured by a type class
12:58:11 <Philonous> carter:  c2hs isn't automatic, btw. You have to write a binding definition for every function etc.
12:58:16 <ski> noctux : `arrayFilter' is strangely named. no arrays in sight
12:58:26 <carter> Philonous so i may as well just use Language-C
12:58:39 <Cale> fruitFly: It is a newly invented word (apart from the sense of "one who performs something", but that's a noun rather than an adjective) which tends only to be used by people who are trying to sell something.
12:59:03 <Philonous> carter:  I don't know Language-X
12:59:06 <Philonous> Language-C
12:59:09 <byorgey> noctux: unfortunately I don't know of any nice way to start with the classic Haskell quicksort implementation and just instrument it to get what you want.
12:59:09 <ski> noctux : and it's arguably not quicksort if it doesn't have similar efficiency as the usual in-place update algorithm
12:59:11 <Cale> There are more precise terms which one could always apply in place of it.
12:59:18 <monoidal> noctux: if you are willing to swap "rest <- arrayFilter f xs" and "comp <- f x", then your function already exists, it's called filterM
12:59:23 <Cale> (If one were not trying to be vague)
12:59:38 <noctux> ski: jeay, it is meant to simulate an operation on arrays :p
12:59:39 <monoidal> noctux: (arrayFilter = filterM)
12:59:46 <noctux> ski: and it is not about the efficiency as such...
12:59:54 <byorgey> noctux: your code could probably be cleaned up some but fundamentally I think the structure of it seems sound.
12:59:57 <noctux> monoidal: great =)
13:00:06 <tomejaguar> Are there best practices for typeclasses when you're only using the class to encode a type-dependent value, and the value does not depend on the actual value of the instance?
13:00:12 <noctux> byorgey: bad news somehow :(
13:00:15 <byorgey> noctux: you can abstract over lt, gt, and eq  and just make one function which takes a comparison as an argument
13:00:21 <kaiko> mm_freak, if interface is captured by type class then why I can't abstract function for all interfaces with IConnection interface...
13:00:22 <monoidal> noctux: res = fst $ runWriter $ quickSortM list and counts = snd $ runWriter $ quickSortM list
13:00:32 <monoidal> noctux: better: (res, counts) = runWriter $ ...
13:00:52 <ski> noctux : you could do a three-way partition, instead of the three filterings
13:00:54 <noctux> byorgey: I'm currently thinking about introducing different counters for eq, lt and gt =) but otherwise, you're right ;)
13:01:06 <tromp_> noctux: why use Writer instead of Sum?
13:01:08 <byorgey> ah =)
13:01:23 <ChongLi> http://roscidus.com/blog/blog/2013/06/09/choosing-a-python-replacement-for-0install/
13:01:56 <mm_freak> kaiko: because type classes do not act like OOP interfaces‚Ä¶  they are not types
13:01:56 <noctux> monoidal: hmm, gave me issues previously, but there had been another error in the code as well... I should try it out now =)
13:01:56 <Philonous> Cale:  Are there people who use "performant" unironically? It sounds so bullshitty.
13:02:07 <noctux> tromp_: I didn't know about it =)
13:02:21 <Cale> Philonous: Apparently so, but I agree.
13:02:24 <mm_freak> kaiko: you can achieve that by doing something like this:  connect :: (forall c. (IConnection c) => c -> IO a) -> IO a
13:02:30 <mm_freak> but that's very unlikely to be what you want
13:02:37 <monoidal> noctux: tromp_'s idea is a very good one; instead of [(Integer, Integer)] you can use (Sum Integer, Sum Integer) and you won't have to add the numbers in the end
13:02:38 <noctux> tromp_: I'm currently somewhere in the second half of lyah :P
13:03:12 <monoidal> noctux: http://blog.sigfpe.com/2009/01/haskell-monoids-and-their-uses.html‚Äé is highly recommended
13:03:13 <mm_freak> kaiko: however, i recall that HDBC has a connection wrapper type for that purpose
13:03:38 <mm_freak> kaiko: http://hackage.haskell.org/packages/archive/HDBC/2.3.1.2/doc/html/Database-HDBC.html#g:6
13:03:41 <noctux> ski: what i wonder is: how do i do the partition, while counting my "eq/lt/gt" operations?
13:04:01 <Sonarpulse> jownh: oh ok
13:04:22 <mm_freak> kaiko: write a withConn function:  withConn :: (ConnWrapper -> IO a) -> IO a
13:04:44 <mm_freak> kaiko: and that function should look like:  withConn = bracket init done where init = ‚Ä¶; done c = ‚Ä¶
13:04:44 <ski> noctux : `listFilter :: (a -> Writer [(Integer, Integer)] Ordering) -> [a] -> Writer [(Integer, Integer)] ([a],[a],[a])', perhaps ?
13:04:46 <kaiko> mm_freak, ok, this is very good hint
13:05:58 <ski> noctux : if you want to make sure the main algorithm code is separated from the instrumenting code (prevented from affecting it), you might perhaps want to try something similar to my "PoorManDebug" <http://hpaste.org/10060> thing
13:07:13 <kaiko> mm_freak: even I don't still understand. for example I can define function "foo :: (Eq a) => a -> a -> String". how Eq differs from IConnection?
13:07:38 <noctux> ski, byorgey, monoidal, tromp_: Ok, first of all, thank you, I'll go to your recommendations and look at what I can apply, and read into the rest
13:09:10 <noctux> ski: yepp, a clean separation would be ideal... but it seems I will really have to take a closer look (hoogle is my friend there I guess) at the Functions used in your code =)
13:09:16 <mm_freak> kaiko: type classes are type-bound, while interfaces are value-bound
13:09:30 <mm_freak> kaiko: try to express an interface Eq in an OO language and you'll see the difference =)
13:09:46 <ChongLi> anyone help me figure this out
13:09:47 <ChongLi> ?
13:09:57 <ofan> Does anyone know how to leave a message in lambdabot?
13:10:09 <mm_freak> ofan: @tell nick msg
13:10:18 <ofan> mm_freak: Thank you!
13:10:38 <kaiko> mm_freak: Thank you!
13:11:31 <ChongLi> http://hpaste.org/89719
13:11:54 <ChongLi> if I run this with runhaskell it correctly throws an exception
13:12:09 <ChongLi> but if I compile it with ghc and run the binary it does not
13:12:20 <mm_freak> kaiko: IConnection is an abuse of the type class system and leads more to confusion and inconvenience than anything else
13:12:28 <yapp_> I have something that runs almost twice as slowly when split into modules. I regain the performance perfectly by adding inline pragma to one function, but I'd like not to have to think about this as I go along. Is there some compiler optimization that will make inlining much more aggressive? I don't regain the performance with just "ghc -fexpose-all-unfoldings -funfolding-use-threshold=1024 -fforce-recomp --make -O2" and seperate mod
13:12:39 <mm_freak> and it inspires workarounds like ConnWrapper
13:12:50 <mm_freak> or pretty much enforces
13:15:45 * hackagebot network-simple-tls 0.1.0.1 - Simple interface to TLS secured network sockets.  http://hackage.haskell.org/package/network-simple-tls-0.1.0.1 (RenzoCarbonara)
13:15:48 <ski> noctux : what i'm doing is using rank-2 types to ensure that the "instrumented" functions (factorial and fibonacci in the example) doesn't know about the monad used to "debug" the recursive calling
13:17:37 <ski> noctux : the to-be-instrumented functions are polymorphic in the monad used, and my "run" functions (`trivialFix',`traceFix') takes these as argument, and provides the appropriate instrumentation in terms of a specific monad
13:18:14 <Guest55594> #haskell what's the best type for a grid that needs to be accessed and changed frequently by coordinate
13:18:14 <noctux> ski: and yet another haskell-wiki page pending for reading ;)
13:18:40 <noctux> ski: but your explanation seems plausible ;)
13:18:47 <noctux> (at a high level ;) )
13:18:59 <monochrom> Guest55594: mutable Vector
13:19:08 <Guest55594> well it's wrapped in a state?
13:19:18 <Guest55594> a bit inside, should I change it?
13:20:27 <monochrom> no, it's MVector, it's mutable, use in IO or ST
13:20:56 <Lemmih> \q
13:21:16 <Guest55594> what's the difference between ST and state?
13:21:34 <Sonarpulse> johnw: https://github.com/Ericson2314/henet
13:21:40 <Sonarpulse> got some semblance of a build system
13:21:55 <Sonarpulse> but a lot of errors I really don't know what to make of
13:21:58 <Guest55594> is it just strict?
13:22:15 <rhodesd> Guest55594: btw, there is a grid package: http://hackage.haskell.org/package/grid, I don't know if it will work for what you're doing, but it's got good documentation.
13:24:10 <Guest55594> that's mostly about coordinates it seems, which is useful but not all the infromation I'm storing. I can certainly use it but it doesn't seem to actually do this for me
13:25:01 * zammy is away: I'm busy
13:25:59 <monoidal> Guest55594: ST is actual mutable cells (references), while State s is just a value of type s passed around as an argument to functions
13:26:31 <Guest55594> okay, thanks
13:26:52 <noctux> ok, looks a bit cleaner now, so I'm now gonna try skis solution... (current code: https://paste.xinu.at/BOR/) Thanks guys!
13:27:18 <KoF> Gyeeeh. Damn you and your NP-complete problems with 12-digit N, Project Euler.
13:28:07 <monoidal> noctux: you can write where (res, (Sum comparisons, Sum arrayaccess)) = runWriter $ ...
13:29:35 <noctux> monoidal: seems like haskells pattern matching is even more awesome than I thought :p
13:31:54 <Guest55594> is there something to get lambda bot to try to generate a function from types
13:31:54 <Sonarpulse> so the library I am making bindings to uses it's own fix-width integer types (uhg)
13:32:10 <monoidal> @djinn a -> b -> a
13:32:10 <lambdabot> f a _ = a
13:32:31 <Sonarpulse> they DON't become c99 fix whidh types, but rather c89 unsigned longs, stc
13:32:41 <Guest55594> actually I need to understand ST's types better first
13:32:46 <Sonarpulse> trusting that whatever macros do this in the library
13:32:55 <Guest55594> I think it's ST s a -> s -> s that I need
13:32:56 <Sonarpulse> is it safe to just make the bindings with haskell fixed-int types?
13:33:06 <Guest55594> but actually, I had an IORef
13:33:07 <Cale> Guest55594: djinn doesn't know anything about ST or higher rank types though.
13:33:19 <monoidal> Guest55594: in ST s a, "s" is *not* a value you can use. it's just a tag
13:33:25 <Guest55594> Okay
13:33:35 <Sonarpulse> see https://github.com/Ericson2314/henet/blob/master/src/Network/ENet/Bindings.hsc
13:33:37 <monoidal> Guest55594: (it's different from State s a, where s is the type of the state.)
13:33:37 <Cale> Guest55594: The s in ST s a is a phantom type parameter, and should never actually be the type of a value.
13:33:54 <Guest55594> So I currently have something in an IORef, should I do something different to use ST
13:34:17 <monoidal> Guest55594: STRef (the API is essentially the same)
13:34:29 <Cale> (though if you want, you can think of it as the type of the entire heap which the ST monad will manipulate, but runST gets to choose that type, and you never get to work with its values directly.
13:34:31 <Cale> )
13:35:06 <Cale> ST actions operate on STRefs which are similar to IORefs
13:35:45 <Guest55594> So how would I get an IO () out of it?
13:35:54 <Cale> Out of what?
13:35:56 <Guest55594> I notice the only API one uses RealWorld
13:35:59 <Guest55594> out of ST
13:36:08 <Guest55594> ST s ()
13:36:11 <monoidal> Guest55594: for now, you can disregard it. ST gives you pure values
13:36:20 <monoidal> Guest55594: the function is called runST
13:36:35 <Guest55594> I do need to get IO () out of it
13:36:41 <Cale> Of course, you shouldn't apply runST to something of type ST s () directly, because that's useless.
13:36:41 <Guest55594> because I need to put it into a callback in glut
13:36:53 <Cale> Guest55594: apply return?
13:37:05 <Guest55594> but then don't I just have IO (ST ())?
13:37:08 <monoidal> > runST (do x <- newSTRef 0; modifySTRef x (+1); readSTRef x)
13:37:09 <lambdabot>   1
13:37:19 <Cale> Guest55594: I guess it would help to know what you're trying to do
13:37:25 <Guest55594> yeah I have no idea how to use ST
13:37:46 <Guest55594> this is my current code using IORef and State
13:37:47 <Guest55594> http://hpaste.org/
13:37:50 <Cale> ST is like the IO monad but is limited to single threaded memory effects
13:37:50 <Guest55594> oops
13:37:54 <Guest55594> http://hpaste.org/89720
13:38:03 <Cale> and its actions can be executed to produce pure values
13:38:35 <Cale> Applying runST to the same ST action multiple times is guaranteed to produce the same result.
13:39:01 <Cale> runST :: (forall s. ST s a) -> a
13:40:03 <c_wraith> Cale: unless you do something terrible.  (unsafeInterleaveST is so named for a reason)
13:40:44 <Cale> The fact that runST requires its parameter to be polymorphic in the type s prevents you from usefully sneaking STRefs that are created inside the action out in the result.
13:40:48 <tac> > runST $ do x <- newSTRef 1; let fact 0 = return (); fact n = do { modifySTRef x (*n); fact (n-1);} in  fact 5; readSTRef x
13:40:49 <lambdabot>   120
13:41:27 <Cale> (You might come up with a clever way to sneak them out, but they will be useless, since readSTRef and writeSTRef will need to be used for an arbitrary s, rather than a specific one.)
13:41:50 <c_wraith> ST abuse, for those looking for ways to make their software less reliable: http://hpaste.org/87378
13:42:21 <Cale> Well, there's a reason for the unsafe in the name :P
13:42:36 <dolio> In that case.
13:43:39 <Cale> Guest55594: IORefs seem appropriate here, is there a particular reason why you want to use ST?
13:43:46 <ski> "do not extend to any use" might be overstating it
13:44:00 <monoidal> trivia: unsafeInterleaveST in new GHC will require a separate import.
13:44:03 <FreeFull> unsafePerformIO . unsafeSTToIO
13:44:06 <FreeFull> Maybe that?
13:44:09 <c_wraith> monoidal: good
13:44:12 <lispy> ?tell carter yes you can use it to parse declarations, the trickiest part is that you need to bring any types you use into scope.
13:44:12 <lambdabot> Consider it noted.
13:44:19 <Cale> Guest55594: Also, there are tabs in this file. You should configure your text editor to replace them with spaces for you automatically.
13:44:26 <Guest55594> yeah i will
13:44:32 <Guest55594> because he told me to use ST
13:44:34 <Guest55594> what I have is this
13:44:55 <Guest55594> inside gameRef there is a value with another value that's a grid of things
13:45:15 <Guest55594> and I was asking what the best type to use for that is
13:45:17 <Cale> In fact, I don't think ST can be put to use in a meaningful way here
13:45:27 <Guest55594> so I should go back to State and IO
13:45:33 <c_wraith> ski: No, it's not really overstating it. unsafeInterleaveST breaks the guarantee built into the ST system. It forces you to manually ensure that the resulting action is safe, in every case.
13:45:46 * hackagebot acid-state 0.10.0 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.10.0 (DavidHimmelstrup)
13:45:52 <noctux> ski: I'm somewhat curious: what is the use of "fix", e.g. in line 37? hoogle tells me it calculates the fixpoints. What is the use of that?
13:45:53 <Cale> Guest55594: Oh, maybe ST in place of State...
13:45:59 <c_wraith> ski: which isn't to say it can't be safe - just that the type system isn't capable of checking what's going on anymore.
13:46:02 <monoidal> > fix (1:)
13:46:03 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:46:12 <Cale> Guest55594: But you can't use STRefs in place of your IORef here.
13:46:14 <monoidal> noctux: fix f computes x such that x = f x
13:46:29 <noctux> monoidal: yeah, thats a fixpoint
13:46:29 <monoidal> noctux: for example, if f is (1:), then it computes x such that x = 1:x
13:46:44 <noctux> monoidal: but I do not get ski's use of it here: http://hpaste.org/10060
13:46:46 <FreeFull> noctux: fix allows you to replace named recursion
13:47:06 <Guest55594> okay so how would I modify the IORef then?
13:47:07 <monoidal> noctux: you can replace any use of fix using a recursive definition, but people like to use combinators to avoid explicit recursion - just like people prefer folds, map etc. to recursion
13:47:28 <Guest55594> updateGame . return?
13:47:52 <Guest55594> er, runSt
13:47:58 <noctux> ah, ok, so to some degree it is a style-thing as well. Thanks
13:47:59 <Guest55594> that's not right though
13:48:33 <Cale> Guest55594: I would recommend changing the type of doUpdateGame to  IORef Game -> IO (), and putting the Just in when you set the idleCallback.
13:48:39 <monoidal> noctux: ski defines a modified version of fix that traces the value in recursion calls
13:48:49 <Guest55594> oh yeah that's probably better
13:48:57 <Cale> Guest55594: You can't update an IORef from inside an ST action.
13:49:22 <monoidal> noctux: in my opinion this might be an overkill in this case, though it's a matter of taste
13:49:57 <Guest55594> so how do I update the IORef then?
13:50:04 <Guest55594> in the best manner possible
13:50:46 <Guest55594> you know, I'm probably going to have to have the grid be forced to evaluate anyway
13:50:47 * hackagebot groundhog 0.3.1 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-0.3.1 (BorisLykah)
13:50:49 * hackagebot groundhog-th 0.3.1 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.3.1 (BorisLykah)
13:50:49 <ski> Cale : not even with `stToIO' and some conversion between `STRef RealWorld' and `IORef' ?
13:50:49 <Guest55594> when I draw it
13:51:13 <Cale> ski: Well, if you want to go that far :P
13:51:36 <Cale> ski: But I would guess that something has gone strangely if you end up in that situation.
13:51:38 <dtruby> Hi. I don't really understand what foldr is doing in this specific case: foldr (-) 0 [1,2,3], which returns 2. Anyone mind explaining this to me? Thanks!
13:51:57 <Guest55594> this whole thing was the type of that grid
13:52:00 <ski> c_wraith : it sounded like you were claiming that you can't make any useful guarantees, provided the programmer manually checks there separate state threads don't interact
13:52:00 <johnw> dtruby: "unfold" the foldr, to see what's happening
13:52:03 <geekosaur> > foldr (-) 0 [a,b,c]
13:52:04 <lambdabot>   Not in scope: `a'Not in scope: `b'Not in scope: `c'
13:52:04 <Guest55594> and someone said using a mutable Vector with ST
13:52:13 <geekosaur> oh, this lambdabot doesnt have simple-reflect :/
13:52:14 <c_wraith> ski: yeah, I think I worded it badly. That happens to me.
13:52:23 <Cale> dtruby: Well, it does what it always does... (-) 1 ((-) 2 ((-) 3 0))
13:52:41 <monoidal> >  1-(2-(3-0))
13:52:41 <lambdabot>   2
13:52:49 <Cale> which is 1 - (2 - (3 - 0))
13:52:55 <Cale> yeah
13:52:59 <ski> noctux : `fix' is a way to let a function effectively call itself, without actually referring to itself by name
13:53:12 * johnw hugs foldr
13:53:19 <Cale> Let me guess: Freenode is being DDoSed again?
13:53:25 <johnw> ski: or put another way: it lets you make recursive lambdas
13:53:28 * companion_cube hugs splitNode
13:54:02 <noctux> ski, johnw: hmm, I think I need 1-2 minutes to understand how it does that =)
13:54:09 <dolio> ski, c_wraith: This is just an opportunity for monochrom to explain why English phrases involving 'any' are bad, and you should use quantifiers.
13:54:17 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
13:54:18 <lambdabot>   3628800
13:54:29 <dtruby> Cale: Oh right, I see now. Thanks!
13:55:09 <johnw> noctux: fix $ \loop x = loop (x+1) is the same as saying let loop x = loop (x+1)
13:55:13 <Cale> dtruby: In general, you can think of foldr f z as replacing each (:) in the construction of the list with f, and the [] at the end (if any) with z.
13:55:49 <Cale> Y U LEFT
13:56:42 <geekosaur> of course freenode is being DDoSed. there is no shortage of punks who think they have to punish freenode for not letting them spam or not giving them network ops or not recognizng how special snowflake they are or ...
13:57:13 <rovar> Hey all, I'm a bit of a PL newbie and I'm trying to make a basic language which operates against collections.   It is an expression language, 0 side effects, but the language would feature the ability to fold, map and filter
13:57:54 <noctux> johnw: and loop x = loop (x+1) is solved by unification?
13:58:06 <rovar> I would like to use buildExpressionParser, but I'm struggling with the lazy evaluation of an expression that would be passed into a fold/map
13:58:10 <geekosaur> thuggery is the rule on most IRC networks; freenode insists on not treating thugs as the gods they are used to being on most IRC networks
13:58:35 <rovar> as it seems that I don't entirely get to decide when an expression is evaluated..
13:58:50 <Cale> rovar: don't you?
13:59:03 <Cale> rovar: The parser is just going to build you an expression tree isn't it?
13:59:11 <Cale> and you get to do whatever you want with it
13:59:16 <johnw> noctux: um, no, it's an infinite loop in this case
13:59:24 <johnw> noctux: it was only for demonstration, not use
13:59:32 <rovar> Cale: in buildExpressionParser that doesn't seem to be the case, but I'm likely missing something.
13:59:32 <Cale> See my example for "use"
13:59:35 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
13:59:36 <lambdabot>   3628800
13:59:48 <Cale> This computes the factorial of 10
13:59:50 <noctux> johnw: ah, ok...
14:00:01 <johnw> I find the use of "fix" pretty rare, but when you need it, you'll be very glad to have it
14:00:13 <johnw> you can *always* achieve the same thing by just defining a recursive function in a "where" clause
14:00:19 <Cale> It's actually a very useful thing to write loops in IO actions.
14:00:23 <johnw> but in that case, you may have to pass down many local variable
14:00:24 <noctux> Cale: ok, this clears it up somehow =)
14:00:54 <johnw> Cale: that's when I typically use it most too
14:01:19 <Cale> Quite often you'll see someone write something like:  do ... ; let { loop x y z = do ... } ; loop ...
14:01:24 <johnw> Cale: how familiar are you with kan-extensions?
14:01:30 <Cale> vaguely
14:01:41 <ParahSailin> :ty fix
14:01:42 <johnw> i'd love to have another whiteboard discussion about them (the CT flavor, that is)
14:01:46 <ski> dolio :)
14:01:52 <ski> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib 12
14:01:53 <lambdabot>   144
14:01:53 <johnw> @type fix
14:01:54 <lambdabot> (a -> a) -> a
14:02:00 <ski> > (fix $ \fib n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-1) + fib (n-2)) 12
14:02:01 <lambdabot>   144
14:02:15 <ski> @let tabulate :: Data.Ix.Ix i => (i,i) -> (i -> e) -> Data.Array.Array i e; tabulate ix f = Data.Array.array ix [(i,f i) | i <- Data.Array.range ix]
14:02:15 <lambdabot>  .L.hs:80:13: Not in scope: type constructor or class `Data.Ix.Ix'
14:02:15 <lambdabot>  
14:02:15 <lambdabot>  .L.hs:8...
14:02:26 * ski sighs
14:02:30 <joelteon> > (fix $ \n -> if n == 1 then 1 else (n - 1)) 4
14:02:31 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
14:02:31 <lambdabot>    arising f...
14:02:34 <joelteon> oh right
14:02:56 <johnw> > (fix $ \f n -> if n == 1 then 1 else f (n - 1)) 4
14:02:57 <lambdabot>   1
14:03:08 <joelteon> yeah, I just forgot the f
14:03:20 <joelteon> > (fix $ \f n -> if n == 1 then 1 else n + f (n - 1)) 10
14:03:21 <johnw> fix "receives the lambda itself" as its first argument
14:03:22 <lambdabot>   55
14:03:24 <joelteon> I know
14:03:31 <johnw> I was clarifying for the others in the discussion
14:03:34 <joelteon> @pl \f n -> if n == 1 then 1 else n + f (n - 1)
14:03:34 <lambdabot> ap (flip if' 1 . (1 ==)) . ap (+) . (. subtract 1)
14:03:36 <joelteon> oh, ok
14:03:40 <joelteon> pardon me (:
14:03:44 <johnw> n/p! :)
14:03:56 <ski> hm, `L.hs' seems to list `import Data.Ix' :
14:04:00 <ski> @where L.hs
14:04:00 <lambdabot> What lambdabot has in scope is at <http://code.haskell.org/lambdabot/State/L.hs>
14:04:15 <rovar> Cale, I guess you're right,  all of the examples I've seen use (+) and (*) as combinators so it automagically evals the results, but I could use my Expression datatype constructor as the combinator and build a tree.
14:04:17 <joelteon> holy nuts
14:04:31 * ski tries with unqualified names
14:04:34 <joelteon> sediment shaped sediment
14:04:34 <Cale> rovar: yeah, that's definitely what you want to be doing
14:04:53 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = array ix [(i,f i) | i <- range ix]
14:04:54 <lambdabot>  .L.hs:79:14:
14:04:54 <lambdabot>      Not in scope: type constructor or class `Ix'
14:04:54 <lambdabot>      Perhaps ...
14:04:55 <monoidal> > fromChuch
14:04:56 <lambdabot>   Not in scope: `fromChuch'
14:04:57 <Cale> > cake
14:04:57 <lambdabot>   Not in scope: `cake'
14:04:58 <lambdabot>  Perhaps you meant one of these:
14:04:58 <lambdabot>    `take' (imported f...
14:04:59 <monoidal> > fromChurch
14:05:00 <lambdabot>   Not in scope: `fromChurch'
14:05:02 <lambdabot>  Perhaps you meant `BSLC.fromChunks' (imported f...
14:05:10 <monoidal> hm. those functions are in L.hs
14:05:10 <johnw> cake = lie
14:05:10 <joelteon> :t (****)
14:05:11 <lambdabot>     Not in scope: `****'
14:05:11 <lambdabot>     Perhaps you meant `***' (imported from Control.Arrow)
14:05:14 <Cale> no cake anymore
14:05:17 <DanBurton> y'all know you can test things out in a private chat with lambdabot first... right?
14:05:22 <joelteon> how upsetting
14:05:43 <johnw> DanBurton: clearly that's not as much fun
14:07:29 <Cale> elliott didn't quite get the L.hs that I had working, probably just because of all the various things which were being imported.
14:08:55 <noctux> ah, fix allows a unnamed function to call itself because x = f x --> x = f f x --> x = f f f x ... and as soon as the recursion hits a base case, the expansion stops, and we're done...
14:09:17 <joelteon> :t foldl (.)
14:09:17 <lambdabot> (b -> c) -> [b -> b] -> b -> c
14:09:24 <ski> yes, except `f (f (f x))', usw
14:09:30 * noctux feels like an idiot sometimes when things suddenly seem so dead simple
14:09:40 <noctux> ski: oh, jeah
14:09:49 <johnw> noctux: that's been my entire experience of math
14:09:53 <ski> noctux : however, the main use here of `fix' is to untangle the recursion using it, then replace `fix' with something more sneaky
14:10:02 <johnw> "hard hard hard hard... feel like idiot"
14:10:27 <ski> noctux : i was meaning to show an example with memoizing, but it appears lambdabot is unco√∂perative atm
14:10:46 <Sonarpulse> johnw: I had to manually replace CUInt with Word32, and some similar replacements
14:10:48 <Sonarpulse> is that ok?
14:10:52 <noctux> johnw: oh yeah...
14:10:54 <ski> > let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = array ix [(i,f i) | i <- range ix]; memoArr :: Ix i => (i,i) -> ((i -> e) -> (i -> e)) -> Array i e; memoArr ix f = fix $ \arr -> tabulate ix (f (arr !)) in memoArr (0,12) $ \fib n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-1) + fib (n-2)
14:10:55 <lambdabot>   Not in scope: type constructor or class `Ix'
14:10:55 <lambdabot>  Perhaps you meant `IO' (impor...
14:11:04 <ski> noctux : ^ that's it if you want to try it yourself
14:11:40 <ski> `memoFix :: Ix i => (i,i) -> ((i -> e) -> (i -> e)) -> (i -> e); memoFix ix f = (memoArr ix f !)' might also be interesting (it'll work more or less as a replacement for `fix', provided you give bounds)
14:11:55 <ski> noctux : cf. with earlier `fib' examples which went through
14:13:51 <Cale> johnw: I don't think I understand Kan extensions well enough to say anything about them which the Wikipedia page doesn't already say.
14:14:24 <johnw> Cale: ok
14:14:37 <FreeFull> Hmm, I don't think a Stream is a monad
14:14:57 <johnw> Cale: so, you know how Yoneda is forall r. (a -> r) -> f r, right?
14:15:06 <byorgey> FreeFull: what is your definition of Stream?
14:15:18 <FreeFull> data Stream a = Cons a (Stream a)
14:15:23 <byorgey> that is a monad.
14:15:45 <FreeFull> How would you implement return and still satisfy the second law?
14:16:00 <ski>   return a = as where as = Cons a as  -- ?
14:16:09 <byorgey> FreeFull: there is only one way to implement something with the type of return.
14:16:19 <byorgey> how does the obvious implementation not satisfy the second law?
14:16:25 <noctux> ski: ok, the example is working (as soon as all imports are done)
14:17:12 <noctux> Thanks once again all around =)
14:17:13 <Cale> johnw: I guess it's kinda like that, if we identify Set with Hask and squish everything down.
14:17:17 <ski> noctux : what it does is it hides an intermediate array between the recursive calls, so that e.g. `fib 10' will only be computed once, instead of twice
14:17:20 <johnw> Cale: and then Codensity is forall r. (a -> m r) -> m r
14:17:35 <johnw> Cale: so, the right kan extension generalizes to forall r. (a -> m r) -> n r
14:17:47 <FreeFull> byorgey: If I have a stream of all integers
14:18:03 <johnw> Cale: yeah, it's not quite the CT Yoneda
14:18:07 <FreeFull> Hmm,  it would depend more on the implementation of >>= I suppose
14:18:12 <johnw> i'm reducing it down to what fits in Hask
14:18:27 <johnw> I wanted to get a better intuitive handle on how kan extensions generalize yoneda/codensity
14:18:37 <johnw> I figured you'd have a cool string diagram for that :)
14:18:38 <byorgey> FreeFull: indeed.
14:18:49 <ski> noctux : and if there had been recursive calls for numbers between `0' and `12' which weren't used by the ultimate `12' call, then the corresponding array cells wouldn't have been filled (the corresponding values not being computed) (though you still pay for the space) -- this is a simple and nice way to do some kinds of dynamic programming (in a demand-driven way)
14:19:26 <johnw> Cale: I also want to understand better how Yoneda relates to parametricity
14:20:23 <ski> FreeFull : `ma >>= amb = join (fmap amb ma) where join (Cons (Cons a _as) ass) = Cons a (join (fmap tail ass))' (for the obvious definition of `tail')
14:20:46 <Sonarpulse> johnw: language-c choked over     "void * (ENET_CALLBACK * malloc) (size_t size); " with your tool
14:20:48 * hackagebot groundhog-postgresql 0.3.1 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.3.1 (BorisLykah)
14:20:56 <johnw> Sonarpulse: what is ENET_CALLBACK?
14:21:08 <johnw> in general it handles function pointers just fine
14:21:14 <Sonarpulse> let me see
14:21:15 <johnw> so there must be something surprising in that macro
14:21:37 <johnw> or, the macro is not defined
14:22:08 <noctux> ski: ah, thanks once more. It really helps to see code for something that you know in the imperative variant ;)
14:23:36 <FreeFull> ski: And that join will satisfy the laws?
14:23:43 <ski> FreeFull : i believe so
14:23:51 <ski> (check them yourself ?)
14:25:45 <FreeFull> I wish join was part of the Monad class
14:26:17 <ParahSailin> @src join
14:26:17 <lambdabot> join x =  x >>= id
14:26:20 <Cale> johnw: You probably want to talk to edwardk about that, he's spent much more time thinking about those things than I have. It's actually interesting how they end up looking so similar when you squish them down into Haskell -- there are apparently some similarities between how basic theorems on Kan extensions and how the arguments surrounding Yoneda's lemma go as well.
14:27:22 <johnw> FreeFull: join the club
14:27:24 <byorgey> FreeFull: the Monad instance for Stream becomes more obvious if you note that Stream a  is isomorphic to  Nat -> a
14:27:33 <edwardk> dolio has an excellent article on comonad.com about how the parametricity we give in haskell isn't always quite the notion of parametricity that is right for reasoning about kan extensions
14:27:39 <byorgey> FreeFull: where Nat is the type of natural numbers, i.e. nonnegative integers
14:27:42 <edwardk> sadly i haven't fixed the server yet, bbiab
14:28:02 <FreeFull> I do know what Nat is
14:28:10 <byorgey> ok.
14:28:19 <johnw> edwardk!
14:28:20 <FreeFull> I can see why it's isomorphic
14:28:39 <byorgey> FreeFull: cool, and do you know what the Monad instance for  Nat -> a  would be like?
14:28:42 <roconnor> what does the package version policy say when you change the behaviour of functions to fix bugs?
14:28:48 <roconnor> what do I need to update?
14:28:50 <sclv_> johnw: the latter part of the chapter on kan extensions in mac lane deals with some relationship to yoneda
14:28:57 <johnw> sclv_: oh, nice!
14:29:02 <johnw> does Awodey cover it?
14:29:03 <byorgey> roconnor: anything you like
14:29:16 <ski> byorgey : .. which is an environment monad
14:29:20 <FreeFull> Doesn't join end up looking like   Nat -> (Nat -> a) -> (Nat -> a)
14:29:35 <ski>   (Nat -> (Nat -> a)) -> (Nat -> a)
14:29:42 <FreeFull> Ah, I bracketed it wrong
14:29:45 <roconnor> byorgey: even updating the 4th place version number?
14:29:47 <byorgey> roconnor: the PVP only requires bumps to certain parts of the version number when the API changes
14:29:48 <sclv_> iunno, i don't have awodey on my desk :-P
14:29:51 <byorgey> roconnor: sure
14:29:53 <roconnor> ok
14:29:59 <ski> @pl j ma rho = ma rho rho
14:30:02 <lambdabot> j = id (fix (const (flip ap id)))
14:30:02 <lambdabot> optimization suspended, use @pl-resume to continue.
14:30:09 <johnw> i may buy Mac Lane this month anyway; it's good to have as a final reference if my easier books don't have it
14:30:11 <ski> hm, interesting
14:30:26 <roconnor> byorgey: so PVP is about whether things compile, not whether they work?  (which is a fair scope IMHO).
14:30:31 <byorgey> roconnor: right.
14:30:36 <FreeFull> :t ap
14:30:37 <lambdabot> Monad m => m (a -> b) -> m a -> m b
14:30:57 <sclv_> johnw: i don't think awodey even has kan extensions?
14:31:04 <monoidal> :t flip ap id
14:31:04 <lambdabot> (a -> a -> b) -> a -> b
14:31:14 <johnw> wait, is mac lane out of copyright?
14:31:17 <sclv_> i keep coming back to them and bouncing off them. need more work on the fundamentals first
14:31:18 <johnw> http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf seems to be the full text
14:31:20 <FreeFull> Waaait
14:31:31 <monoidal> johnw: i doubt it
14:31:31 <FreeFull> Isn't fix . const  the same as id
14:31:34 <Cale> johnw: Actually... I was going to say that Awodey doesn't mention Kan extensions, but he actually does, just once, in an interesting context.
14:31:35 <FreeFull> :t fix . const
14:31:35 <lambdabot> c -> c
14:31:49 <FreeFull> lambdabot: Why are you messing with us?
14:31:54 <FreeFull> And that outermost id too
14:31:59 <byorgey> > (fix . const) 3
14:32:00 <lambdabot>   3
14:32:18 <ski> @botslack
14:32:18 <lambdabot> :)
14:32:27 <FreeFull> @botsnack
14:32:28 <lambdabot> :)
14:32:38 <ion> stepcut: ‚ÄúNot thrilling.. the alternative is for query and update to support some other sort of failure mechanism.‚Äù Yes please! :-)
14:32:42 <Bor0> @botspack
14:32:42 <lambdabot> :)
14:33:01 <Bor0> @bot
14:33:01 <lambdabot> :)
14:34:37 <Cale> johnw: He mentions that given a functor f: C -> D between small categories, the precomposition functor f*: Sets^(D^op) -> Sets^(C^op) has both left and right adjoints, which he mentions are sometimes referred to as Kan extensions.
14:34:43 <sclv_> > fmap fix return $ 5
14:34:44 <lambdabot>   5
14:35:05 <Cale> (see page 201)
14:35:25 <johnw> Cale: thanks
14:35:29 <sclv_> which are sometimes referred to as kan extensions? the left and right adjoints of the precomposition functur?
14:35:33 <sclv_> functor even?
14:36:03 <sclv_> that's a nice way to put it, if it means what i think
14:36:54 <sclv_> its sort of the dual of mac lane who starts with a subcategory...
14:39:52 <ChongLi> ahh, I was just reading about mac lane
14:57:11 <josephle> the interesting thing is that Kan extensions are a special case of adjoints, and adjoints are a special case of kan extensions! (if I remember my CT correctly)
14:58:28 <FreeFull> Is it possible to define concat in terms of list comprehensions?
14:58:39 <tromp_> sure
14:58:55 <Cale> concat xss = [x | xs <- xss, x <- xs]
14:59:37 <FreeFull> Oh, right, that works
15:00:03 <tromp_> > words "Oh, right, that works"
15:00:04 <lambdabot>   ["Oh,","right,","that","works"]
15:00:08 <tromp_> > words "Oh, right, that works" >>= id
15:00:09 <lambdabot>   "Oh,right,thatworks"
15:00:22 <joelteon> oo
15:04:44 <FreeFull> tromp_: Yeah, join is concat
15:06:44 <tromp_> yep, join = (>>= id), while id = (>>= return)
15:07:31 <tromp_> >  ["Oh,","right,","that","works"] >>= (>>= return)
15:07:32 <lambdabot>   "Oh,right,thatworks"
15:08:10 <josephle> can anyone explain to me why the new mac pro looks like r2d2?
15:08:15 <josephle> oops wrong channel
15:08:17 <tromp_> which corresponds to the two <- in the Cale's list comprehension
15:08:37 <FreeFull> The list monad makes more sense than list comprehensions to me though =P
15:08:49 <monochrom> that's good to hear
15:08:53 <FreeFull> Even though list comprehensions get desugared to the monad
15:09:19 <tromp_> does the new mac pro allow even less memory than the old??
15:10:01 <koala_man> b-b-but it's cylindrical!
15:10:04 <josephle> the curse of irssi and multiple windows. I can't tell which channel I'm typing into -_-
15:10:05 <tromp_> apple's mac-pro page completely kills my firefox
15:10:31 <josephle> and it seems I accidentally turned #haskell off topic >_>
15:10:50 <ChongLi> the new mac pro is crazy!
15:12:41 <tromp_> it would be nicer if it could use the new Haswell xeons
15:14:37 <josephle> will Haskell have Haswell support? :P
15:14:53 <josephle> I know STM is pretty cool, but will we also use HTM?
15:15:02 <KoF> Is there a function that can easily convert an int to a string or a list, or will I have to write one myself?
15:15:16 <Bor0> how can I easily convert a list in the form [1,2,3,4] into ['1','2','3','4'], that is "1234"
15:15:20 <tromp_> > show 42
15:15:21 <lambdabot>   "42"
15:15:28 <ChongLi> haha
15:15:29 <ChongLi> good one
15:15:54 <tromp_> > map intToDigit [1,2,3,4]
15:15:55 <lambdabot>   "1234"
15:15:57 <FreeFull> Bor0: What happens if you have a number larger than 9?
15:15:57 <joelteon> :t join . map
15:15:57 <lambdabot>     Couldn't match type `(->) [a0]' with `[]'
15:15:57 <lambdabot>     Expected type: (a0 -> b0) -> [a0] -> [a0] -> b0
15:15:57 <lambdabot>       Actual type: (a0 -> b0) -> [a0] -> [b0]
15:16:02 <joelteon> :t join . fmap
15:16:02 <lambdabot>     Occurs check: cannot construct the infinite type: f0 = (->) (f0 a0)
15:16:02 <lambdabot>     Expected type: (a0 -> b0) -> f0 a0 -> f0 a0 -> b0
15:16:02 <lambdabot>       Actual type: (a0 -> b0) -> f0 a0 -> f0 b0
15:16:04 <Bor0> FreeFull, they are 1-digit
15:16:11 <tromp_> you can go upto 15
15:16:16 <joelteon> > join . fmap show $ [1,2,3,4]
15:16:16 <lambdabot>   "1234"
15:16:21 <FreeFull> :t join . map show
15:16:21 <lambdabot> Show a => [a] -> [Char]
15:16:24 <joelteon> > [1,2,3,4] >>= show
15:16:25 <lambdabot>   "1234"
15:16:45 <Bor0> wow, what does >>= do
15:16:51 <tromp_> > map intToDigit [0..15]
15:16:52 <joelteon> it's bind
15:16:52 <lambdabot>   "0123456789abcdef"
15:16:58 <tromp_> > map intToDigit [0..19]
15:16:58 <joelteon> :t (>>=)
15:16:59 <lambdabot>   "0123456789abcdef*Exception: Char.intToDigit: not a digit 16
15:16:59 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:17:02 <josephle> Bor0: Magic! Until you learn Monads that is.
15:17:04 <FreeFull> Bor0: >>= is part of monads, if you haven't learned about them yet don't worry
15:17:15 <ski> > concatMap show [0,1,2,3]
15:17:16 <lambdabot>   "0123"
15:17:24 <joelteon> Bor0: to impress your friends, remember that join . fmap f is the same as >>= f
15:17:25 <Bor0> I see, I'm far from monads. using lyah but I like to experiment with ghci more than just reading
15:17:27 <Andrea_> i thought >>= is only for monads ?
15:17:29 <Bor0> thank you guys
15:17:35 <joelteon> Andrea_: [] is a monad
15:17:35 <ski> Andrea_ : `[]' is a monad
15:17:43 <Andrea_> ohh,
15:18:02 <FreeFull> Bor0: Just don't worry about it until you come across monads in lyah
15:18:04 <Andrea_> a list is a monad ?
15:18:06 <SingingBoyo> too many things are monads, I keep getting lost and I've been using haskell on and off for like a year lol
15:18:10 <FreeFull> And you'll be fne
15:18:12 <FreeFull> Andrea_: Yes
15:18:15 <SingingBoyo> Andrea_: yup, lists are monads
15:18:20 <Andrea_> ok
15:18:21 <ski> Andrea_ : no, the list type (constructor) is a monad
15:18:27 <FreeFull> >>= is concatMap
15:18:47 <josephle> It would be safe to say things that have kind (* -> ...) are candidates for being monads
15:18:49 <FreeFull> return is (:[])
15:18:52 <ski> Andrea_ : a monad is a type-level concept. a value (such as an actual list) can't be a monad, it's the wrong kind of thing
15:18:54 <Bor0> how would you write this? http://hpaste.org/89725
15:19:13 <Bor0> this is what I get from it: *Main> dec2binTail 10 ; "1010"
15:19:21 <ski> SingingBoyo : lists are not monads
15:19:36 <Bor0> it is correct as is, but I'm just wondering if it's written in a good form
15:19:43 <adnap> Can someone explain these errors? http://hpaste.org/89726
15:19:50 <FreeFull> Bor0: What does it do?
15:19:54 <ski> SingingBoyo : you could say "lists form a monad", with the understanding that it's the list construction (the type-level thing), not the actual list values, that forms the monad
15:20:04 <Bor0> takes an integer and converts it to binary string. e.g. dec2binTail 10 == "1010"
15:20:23 <Bor0> also it uses tail recursion
15:20:37 <SingingBoyo> ski: semantics. Sure, values can't be monads, but for anyone from imperative languages it makes more sense.
15:20:38 <Andrea_> > do "hello"
15:20:39 <lambdabot>   "hello"
15:20:48 <ski> > do x <- [0 .. 9]; y <- [0 .. x]; guard (x == y * y); return (x,y)
15:20:49 <lambdabot>   [(0,0),(1,1),(4,2),(9,3)]
15:21:01 <ski> > [(x,y) | x <- [0 .. 9] , y <- [0 .. x] , x == y * y]
15:21:02 <lambdabot>   [(0,0),(1,1),(4,2),(9,3)]
15:21:11 <Andrea_> "hello" >>= id
15:21:12 <ski> Andrea_ : those two expressions do basically the same thing
15:21:16 <Andrea_> > "hello" >>= id
15:21:17 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[b0]'
15:21:17 <lambdabot>  Expected type: GHC.Types....
15:21:20 <joelteon> Bor0: looks ok to me
15:21:55 <Andrea_> ski: which two expressions do you mean ?
15:21:55 <ski> SingingBoyo : i don't think it makes sense. it could give a false impression of understanding things
15:22:07 <joelteon> honestly for clarity's sake I'd use concat . map show $ dec2binTail' q []
15:22:09 <ski> Andrea_ : the ones i passed to lambdabot for evaluation, using `> '
15:22:10 <joelteon> or maybe concatMap show
15:22:17 <joelteon> >>= show won't click for most people
15:22:22 <Bor0> what does that dot do
15:22:26 <Bor0> concat . map
15:22:30 <joelteon> that's function composition
15:22:37 <joelteon> a . b y $ x == a (b y (x))
15:22:37 <Bor0> aha, I see
15:22:56 <FreeFull> lyah covers it all
15:23:11 <Bor0> haven't really got to it yet, I just finished recursion chapter
15:23:17 <fryguybob> josephle: I'm working on STM Haskell on TSX.
15:23:19 <joelteon> it's a good book
15:23:20 <SingingBoyo> ski: Well it's worked for me so far, 'cept for a couple datatypes that I had to go rewrite after trying to use typeclasses as values.
15:23:23 <ski> SingingBoyo : in C, an array value (not to mention an array location) is also different from the array-construction in C types
15:23:28 <joelteon> just keep on with it and don't let monads scare you, they're simple
15:23:48 <Andrea_> > ["hello"] >>= id
15:23:48 <lambdabot>   "hello"
15:23:52 <Bor0> I go slow chapter by chapter, because most of the time I'm playing with ghci, and it's fun :-D
15:24:01 <Andrea_> > "hello" >>= id
15:24:02 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[b0]'
15:24:02 <lambdabot>  Expected type: GHC.Types....
15:24:07 <Andrea_> tzzzz
15:24:09 <Andrea_> arggh
15:24:15 <FreeFull> :t (>>= id)
15:24:15 <lambdabot> Monad m => m (m b) -> m b
15:24:23 <Andrea_> "hello" is a list
15:24:25 <FreeFull> :t (>>= id) :: [[a]] -> [a]
15:24:26 <lambdabot> [[a]] -> [a]
15:24:32 <SingingBoyo> > "hello" `fmap` id
15:24:33 <joelteon> Andrea_: it needs to be a list of lists
15:24:33 <lambdabot>   Couldn't match expected type `a0 -> b0'
15:24:33 <lambdabot>              with actual type `[GHC...
15:24:45 <Andrea_> ["hello"] is a list of lists
15:24:50 <SingingBoyo> id `fmap` "hello"
15:24:54 <FreeFull> > "Hello" >>= return
15:24:54 <lambdabot>   "Hello"
15:25:06 <joelteon> Andrea_: right, but "hello" isn't
15:25:36 <Andrea_> joelteon, ok , why does it nor work for lists ?
15:25:47 <geekosaur> :t (>>= id)
15:25:47 <lambdabot> Monad m => m (m b) -> m b
15:25:59 <joelteon> because [a] is not analogous to m (m a) unless a is a monadic type
15:26:02 <FreeFull> geekosaur: (>>= id) is join
15:26:03 <joelteon> [[a]] is
15:26:04 <geekosaur> m there is [], so it's looking fr a list of lists
15:26:05 <joelteon> [] ([] a)
15:26:06 <geekosaur> yes
15:26:14 <jonkri> when getting a reinstall message with cabal, how can i see _which_ dependency is trying to pull the package that breaks the currently installed packages?
15:26:53 <ski> SingingBoyo : i'm not saying that you haven't gotten some implicit (and mayhaps explicit) sense into how to use monads and how types differ from values -- i'm merely saying that it's also good to get an explicit understanding of it as well, if for no other reason then so that you can communicate better with others, describing what you're doing or wanting to do
15:28:07 <ski> (also, i think semantics is one of the more interesting things. syntax typically isn't as rich)
15:32:00 <Andrea_> > x <- getLine
15:32:01 <lambdabot>   not an expression: `x <- getLine'
15:32:33 <c_wraith> lambdabot is not GHCI
15:32:38 <Andrea_> ok
15:34:44 <Andrea_> > ( 3 % 4) + ( 1 % 4)
15:34:44 <lambdabot>   1 % 1
15:35:06 <lispy> I have a question about reactive-banana
15:35:16 <lispy> In this blog post: http://apfelmus.nfshost.com/blog/2011/05/06-frp-why-functors.html
15:35:36 <lispy> apfelmus points out that you can't directly write the Behavior b = \t -> 2*t
15:35:54 <lispy> What I don't see is how to write that using the provided combinators
15:37:28 <lispy> Anyone here know the answer to that?
15:38:05 <lispy> accumE 0 (pure (2*))  ?
15:39:13 * ski hasn't looked at the above, but would ignorantly assume `fmap (2 *)'
15:40:22 <lispy> But wouldn't that apply (2*) to the `a` type variable instead of the time?
15:40:29 <lispy> The time is sort of bundled up and implicit
15:40:50 <ski> hm
15:41:00 <ski> yes, i'm misunderstanding it
15:41:14 <lispy> I think I'll email the author
15:41:23 <ski> (still trying to find the part of the blog you refer to)
15:41:31 <lispy> It's towards the end
15:41:40 <lispy> You'll probably need to read the whole thing
15:42:41 <ski> hm, i don't think `accumE' is it
15:43:18 <lispy> I suspect that the library very intentionally hides the Time from you
15:43:28 <lispy> So that unless you make a = Time you can't do this
15:44:10 <ski> perhaps there is a combinator with type `Behaviour Time'
15:44:28 <ski> (which you could then `fmap (2 *)' on)
15:45:23 <Andrea_> > do  putStrLn "Hello"; putStrLn "you"
15:45:24 <lambdabot>   <IO ()>
15:46:01 <ChongLi> anyone here use ghc-mod?
15:48:38 <ski> @help run
15:48:38 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
15:49:14 <ChongLi> 3 seconds seems like a long time
15:50:45 <jonkri> How can I specify the following in my Cabal file: "If GHC 7.0.1, specify this dependency, otherwise specify this."?
15:50:50 <hpc> ChongLi: excruciatingly long
15:51:23 <swistak35> beginners question: Is there any object, thats polymorphic with any type?
15:51:37 <hpc> jonkri: the answer you probably need is "depend on a version of base that's more recent than 7.0.1"
15:51:39 <monochrom> there is no object, period.
15:51:43 <ChongLi> :t undefined
15:51:43 <lambdabot> a
15:52:07 <joelteon> :t a
15:52:08 <lambdabot> Not in scope: `a'
15:52:11 <ChongLi> so there you have it
15:52:33 <ChongLi> just don't try to evaluate undefined
15:52:44 <jonkri> hpc: no, it's just that some bytestring versions are broken for ghc 7.0.1 specifically
15:52:45 <joelteon> > undefined
15:52:46 <lambdabot>   *Exception: Prelude.undefined
15:52:50 <joelteon> don't tell me what to do
15:53:08 <ChongLi> haha
15:53:20 <swistak35> ChongLi: Thanks, that's the answer I was looking for!
15:53:41 <swistak35> monochrom: It wasn't an answer I was looking for. : )
15:53:55 <jonkri> So I want to specify a different (capped) bytestring dependency range for GHC 7.0.1.
15:53:58 <ski> swistak35 : two other examples, depending on what you meant, are `[]' and `Nothing'
15:54:03 <hpc> swistak35: haskell doesn't have "objects" the way something like java does
15:54:13 <ChongLi> swistak35: check this out: http://matthew.brecknell.net/post/hole-driven-haskell/
15:54:15 <ski> @type Nothing
15:54:16 <lambdabot> Maybe a
15:54:18 <ski> @type []
15:54:18 <lambdabot> [a]
15:54:18 <josephle> hpc: perhaps he meant "values"?
15:54:24 <hpc> swistak35: there are types and values (and kinds and type classes and ...)
15:54:31 <swistak35> hpc: I know, but I didn't know which word I should use
15:54:35 <ChongLi> it's an interesting tutorial on the use of undefined to get the compiler to fill in types for you
15:54:36 <swistak35> Oh well, values, sorry : )
15:54:43 <ChongLi> it's obsolete now, with proper type holes
15:54:45 <monochrom> swistak35, then it is your inability to make clear what you look for.
15:54:50 <ChongLi> but it gets the idea across :)
15:54:51 <hpc> swistak35: tmyk!
15:55:14 <ski> "tmyk" ?
15:55:49 <swistak35> ski: Thanks, [] was what I needed for another example, now I needed undefined : )
15:55:57 <kylcarte> ski: "the more you know"
15:55:59 <monochrom> and I would also ask, "why would you want a polymorphic value like that". see also the XY Problem.
15:56:21 <Sonarpulse> johnw: sorry for belated response
15:56:37 <Sonarpulse> #define ENET_CALLBACK __cdecl
15:56:42 <Sonarpulse> ^ on windows
15:57:03 <Sonarpulse> on unix it is defined as nothing
15:57:32 <lispy> ski: the reason I thought accumE might be the right thing is that I think you have to track your own notion of time to make it work. Something like accumE {- time starts at 0 -} 0 {- update function -} ((2*) <$>). But that doesn't explain how time itself increases. I have seen some reactive-banana examples that in the loop that gathers events they poll for the current time and convert to Double. I think that may be required (due to not exposing T
15:57:37 <Ralith> lispy: for the record, I solved my problem by passing --ghc-options=-pgml=gcc to the cabal command in the MSYS shell
15:57:56 <lispy> Ralith: ah, cabal wasn't pass it?
15:58:33 <lispy> Ralith: oh, were you using anything fancy like a parallel cabal build? I think some versions (all?) don't do the right thing with passing on the build flags.
15:58:49 <Ralith> lispy: more accurately, cabal doesn't have any mechanism to propagate ghc options from libraries to binaries, and it's not clear that it should
15:58:59 <Ralith> really the problem here is just that the haskell package has a hardcoded gcc
15:59:02 <Ralith> er
15:59:04 <Ralith> haskell platform
15:59:07 <swistak35> monochrom: I am writing tools for simple parser as a university homework task. I needed an "option p", where p is a Parser. `option p` should be ok if p is parsing, or it's not - it's optional. So I did "(return undefined) `mplus` p" and it works great.
15:59:21 <ski> lispy : suspected cut off near "... (due to not exposing T"
15:59:23 <Ralith> and it's not a huge problem, since, as windows build instructions go, "pass this extra flag" is not very demanding.
15:59:42 <lispy> ski: sorry about that, "I think that may be required (due to not exposing Time to the user)
15:59:45 <lispy> "
15:59:58 <hpc> Ralith: i have seen projects with paradoxical flag requirements
16:00:03 <Ralith> hpc: ?
16:00:10 * lispy thought irssi split long messages but maybe that's a plugin he doesn't have enabled
16:00:23 <Ralith> lispy: splitlong.pl
16:00:29 <hpc> i was trying to build 7zip and ended up hitting a wall where flag X needed to be both set and unset
16:00:37 <hpc> i was getting different errors either way
16:00:48 <Ralith> huh.
16:02:28 <shanse> lispy: splitlong.pl or autowrap.pl
16:02:39 <shanse> nvm, too late
16:03:13 <lispy> I'm guessing I need to find that and download it? (it's not part of irssi?)
16:03:31 <Ralith> yep
16:03:32 * lispy found it
16:03:37 <Ralith> ^^
16:04:40 <lispy> I don't want to spam the channel. What is a good way to test this? :)
16:05:07 <Ralith> PM yourself
16:05:21 <Clint> temporary channel with your special friends
16:05:50 <FreeFull> I use a variant of splitlong.pl that works with /me
16:07:00 <lispy> thanks that seems to work
16:09:04 <Ralith> hpc: in this case, nothing needs special flags to build per se, but ghc uses the haskell platform gcc which causes the haskell platform libstdc++ to be linked, which is not binary compatible with the system mingw libstdc++
16:09:28 <Ralith> thereby breaking linked C++ libraries
16:09:39 <hpc> fun
16:11:06 <FreeFull> Ralith: That sounds like a pain
16:11:25 <Ralith> yep
16:11:40 <FreeFull> Ralith: If you install ghc and etc separately rather than using the platform, will it use the system gcc?
16:12:07 <Ralith> FreeFull: I'm not sure how you go about installing ghc standalone
16:12:22 <Ralith> failing all else, I imagine that it's possible to build your own suitable ghc
16:12:31 <Ralith> but it's much less effort to just pass a flag.
16:12:40 <FreeFull> Ralith: Well, Arch comes with a standalone ghc package
16:12:49 <Ralith> arch isn't windows
16:13:03 <FreeFull> True
16:13:12 <Ralith> I don't think the haskell platform ships a gcc on nonwindows
16:13:33 <FreeFull> You'd have to mess around in cygwin or mingw I suppose
16:13:46 <FreeFull> Windows is a pain and not suitable for software development
16:14:08 <Ralith> sadly, it must be targeted if you write native applications
16:14:15 <Ralith> (for general consumption)
16:14:32 <FreeFull> Would you write native applications for general consumption in haskell?
16:14:43 <Ralith> given the opportunity, yes
16:14:56 <Ralith> but in this case I'm more concerned about writing them in idris
16:15:07 <FreeFull> I guess the situation with that would be slightly better with windows than with linux
16:15:15 <Ralith> ?
16:15:31 <FreeFull> In linux, if you build a binary in one distro it isn't guaranteed to run in another
16:15:51 <FreeFull> Often due to differing library versions
16:15:58 <Ralith> if you build a binary for one windows, it isn't guaranteed to run in another
16:16:04 <ludamad> If you static link everything
16:16:08 <ludamad> you can get pretty generic linux builds
16:16:09 <FreeFull> You do have better chances on Windows
16:16:15 <ludamad> ive done it
16:16:20 <FreeFull> ludamad: libc version differences?
16:16:27 <ludamad> FreeFull: Static link it
16:16:34 <Ralith> and indeed program distributions for windows almost uniformly include redundant but mandatory installers for all of their dependent libraries, or simply ship them
16:16:45 <Ralith> windows isn't magic
16:16:50 <Clint> "distro" is a poor euphemism for "operating system"
16:17:33 <FreeFull> If you make an executable that runs on Windows 98, if you don't do anything too incompatible it should run on Windows 8 to
16:17:36 <FreeFull> too*
16:17:47 <ludamad> And it should run in wine too :-)
16:18:05 <FreeFull> Wine runs things that Windows won't anymore
16:18:17 <FreeFull> For example 64-bit windows won't run 16-bit windows binaries
16:19:04 <hpc> i would make a joke about foxpro here, but it's already a joke :P
16:20:12 <FreeFull> I will sometimes play Kye
16:22:36 <Philonous> Can I splice more than one declaration at once at the top level?
16:24:01 <hpc> Philonous: splice?
16:24:21 <FreeFull> Philonous: What do you mean?
16:24:21 <hpc> Philonous: if you mean a top-level (x, y) = let z = ugly expr in (f z, g z)
16:24:23 <hpc> then yes
16:24:49 <Philonous> hpc:  As in template haskell. I'd like to splice the type declaration and function definition at the same time
16:25:06 <johnw> Sonarpulse: hmm
16:26:08 <Sonarpulse> got it
16:26:29 <Sonarpulse> callback.h relied on callee also including proper header
16:26:47 <Sonarpulse> to avoid duplicating os conditional code
16:27:10 <Sonarpulse> i guess now the question is which of these headers are "internal" and which are "external"
16:27:10 <Philonous> hpc:  Never mind. Reading the documentation helps. Sorry that I bothered you ;)
16:27:28 <johnw> right, that's always a tricky dividing line, if the project doesn't make that distinction fro you
16:27:37 <Sonarpulse> yeah it doesn't really
16:27:50 <Sonarpulse> types.h for example just defines the ENet fixed width types, so don't need that
16:30:55 * hackagebot GLUtil 0.6.1 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.6.1 (AnthonyCowley)
16:33:17 <Sonarpulse> johnw: some anonymous enums or enums lacking a typedef (something like that) cases a blank "#integral " line to be generated
16:33:20 <Sonarpulse> should I remove those?
16:33:42 <johnw> yes
16:34:04 <johnw> also function pointer-style callbacks are handled very poorly right now
16:34:15 <vervic> Hi! Can someone give a direction what this consturctor stand for? And how to instantiate this type? http://hpaste.org/89730
16:35:46 <Sonarpulse> what about "import Network.ENet.Bindings/win32"
16:36:05 <Sonarpulse> what's the slash about?
16:36:33 <DanBurton> vervic: you can instantiate it like this: (Block { blockConsts=x, blockVars = y, blockProcs = z, blockStatement = s }), where x, y, z, and s are the appropriate pieces of instantiation data
16:36:35 <Sonarpulse> (win32 is a header i am NOT including, but this is just an example)
16:37:12 <vervic> DanBurton: ty! Whats the name for it? (eg. for google)
16:37:13 <DanBurton> vervic: without more context, I have no idea what Block is; if I were you I'd ask whoever you got that piece of code from.
16:38:15 <vervic> the typename is not relevant. has this type of constructor { X :: Y, Z :: ... } a special name?
16:38:17 <DanBurton> vervic: that was just instantiating it without a name. If you want to assign that block to a name, you do   name = Block { ... }
16:38:37 <DanBurton> it's called "record syntax"
16:38:46 <vervic> TY
16:38:58 <Aetherspawn> wow huge regression on the benchmarks game compared with ocaml
16:44:48 <Cale> Aetherspawn: Don Stewart, who was probably most committed to making those benchmarks fast sort of got too busy to do it in the last few years, so I wouldn't be too surprised, unless you're talking about something in particular.
16:45:51 <Aetherspawn> Cale, it doesnt look like the haskell one is forking
16:45:56 * hackagebot GLUtil 0.6.1.1 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.6.1.1 (AnthonyCowley)
16:45:58 <Aetherspawn> the ocaml one uses 32 workers, but the haskell one seems to only use 1 core
16:46:22 <Aetherspawn> might be because the ocaml one figured out map reduce or something
16:49:42 <DanBurton> So I randomly wondered just now. Why does `cabal update` take so long? Shouldn't it be a trivial operation?
16:50:47 <SrPx> How do you make a game in Haskell, where a player can move around a map, if you can't modify it's position?
16:51:29 <luite_> you can't modify the position, but you can make a new position
16:52:08 <luite_> SrPx: a game could be a function UserInput -> GameWorld -> GameWorld
16:52:15 <monochrom> DanBurton: it downloads a 6MB file, then gunzip-untars it to 95MB
16:52:48 <SrPx> luite_: what if the world is updated every cpu clock?
16:53:03 <Aetherspawn> Uh, CPU clock, wat.
16:53:11 <Aetherspawn> You mean like 2 billion times per second?
16:53:28 <SrPx> Aetherspawn: I mean as fast as the CPU can handle, you understood.
16:53:34 <luite_> SrPx: you can add a paremter that says how many milliseconds have elapsed since the previous call
16:53:58 <SrPx> how do I call it continously?
16:54:15 <luite_> SrPx: some part has to be in IO obviously, like querying the current time, rendering the game state to screen
16:54:31 <luite_> SrPx: an IO action that repeats forever, for example
16:54:39 <Aetherspawn> :t forever
16:54:40 <lambdabot> Monad m => m a -> m b
16:54:43 <Aetherspawn> Works in IO
16:55:09 <Aetherspawn> and then you can use threadDelay (or something like that) to keep the game tick constant
16:55:18 <Aetherspawn> :t threadDelay
16:55:18 <lambdabot> Not in scope: `threadDelay'
16:55:32 <ski> @index threadDelay
16:55:32 <lambdabot> GHC.Conc, Control.Concurrent
16:55:47 <ski> @type Control.Concurrent.threadDelay
16:55:48 <lambdabot> Int -> IO ()
16:56:07 <SrPx> it doesn't need to be constant, but I would like to see a small example, I'm not sure I get it? Just an object that has a position, a velocity, and every ms increases it's position by dt*velocity... how would that actually be, in code?
16:58:28 <c_wraith> SrPx: the big thing to do is stop thinking in terms of "objects that change".  You should be thinking in terms of "using the previous state and some extra information to generate a new state"
16:59:11 * ski . o O ( FRP )
17:01:05 <SrPx> c_wraith: whatever is the implementation, I just want to see it
17:01:08 <SrPx> could you provide an example?
17:03:15 <SrPx> obj = x:5, vx:1; t = now!; loop -> obj.x += vx * (now! - t); t := now!; log obj
17:03:25 <SrPx> that would be more or less the solution in a language I'm used to...
17:03:50 <monochrom> SrPx: http://www.youtube.com/watch?v=T3xXebIr8AM
17:04:40 <SrPx> monochrom: what about that video?
17:04:49 <monochrom> it answers your question
17:05:15 <glguy> SrPx: there you go
17:05:28 <Aetherspawn> :t mapM_
17:05:29 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
17:06:17 <Aetherspawn> :t map
17:06:18 <lambdabot> (a -> b) -> [a] -> [b]
17:07:24 <SrPx> monochrom: thanks, but I don't get where on that code he's doing what I'm asking.
17:07:29 <glguy> SrPx: http://hpaste.org/89731
17:07:38 <glguy> SrPx: I didn't notice the bot didn't paste the link
17:08:06 <glguy> SrPx: you'll have to pretend like that code is drawing to the screen rather than printing to console, but it's the same idea
17:08:56 <volitek> Is it possible to use the same name for two different functions in record syntax? So for example, I want to use the same function to get the pot of both a player and a poker table with the same function? If I can, is this potentially a bad idea?
17:09:33 <Aetherspawn> SrPx, http://hpaste.org/89732
17:09:37 <Aetherspawn> not the best code, I'm a noob.
17:10:36 <SrPx> glguy: that's more than what I wanted
17:10:42 <SrPx> glguy: it actually made me happy, thank you
17:11:08 <monochrom> SrPx: it is both code and demo for a ball that moves across the screen
17:11:10 <SrPx> Aetherspawn: oh let me see yours, thank you too
17:11:13 <Aetherspawn> wait
17:11:16 <Aetherspawn> actually it was retarded
17:11:19 <Aetherspawn> I just repasted a better one
17:11:23 <monochrom> if necessary you should also watch Part 1
17:11:50 <Aetherspawn> (how come threadDelay isn't working?)
17:12:02 <Aetherspawn> Oooh microseconds
17:12:05 <glguy> Aetherspawn: it is, but your 100 is too m
17:12:06 <glguy> smalal
17:12:13 <SrPx> Part 1?
17:12:29 <Sonarpulse> http://hpaste.org/89734 <- here is a diagram of the #includ ing in the library I am making binds for
17:12:30 <monochrom> yeah, Part 1. the url I gave is just Part 2.
17:12:35 <Philonous> Is template haskell supposed to be extremely slow?
17:13:05 <Aetherspawn> okay re-pasted a more reasonable example
17:13:06 <Aetherspawn> http://hpaste.org/89732
17:13:08 <Sonarpulse> johnw, you hve been of enormous help, but this question isn't specific to any method of generating bindings
17:13:38 <Sonarpulse> time.h and utility.h are only included in one file, and not in enet.h, so I assume they DON'T need bindings
17:13:57 <Aetherspawn> glguy made a better one than me :P
17:14:06 <Aetherspawn> but its kind of cheating because it isn't IO
17:19:02 <Sonarpulse> lispy? you here?
17:20:26 <Aetherspawn> I think if game studios made clients in haskell they wouldn't have hacker problems
17:20:44 <Sonarpulse> ^ that's kinda my plan
17:20:50 <Aetherspawn> pointers aren't static
17:21:00 <Aetherspawn> and its impossible to make heads or tails of the GHC binaries because of the runtime everywhere
17:21:01 <Aetherspawn> lol
17:21:11 <thisiswei> What's up people, learning haskell!
17:21:17 <Sonarpulse> making open source client to replace closed source client in game with lots of hackers + open source server
17:21:34 <Sonarpulse> either less skid, or more people know haskell, either of which is fine with me!
17:22:19 <ski> hello thisiswei
17:23:25 <thisiswei> hello ski
17:23:42 <ski> do you have any Haskell question yet ?
17:24:11 <thisiswei> I'm learning from the haskell school website.
17:24:27 <ChongLi> can anyone else confirm this issue for me?
17:24:29 <ChongLi> https://github.com/kazu-yamamoto/ghc-mod/issues/39
17:24:42 <SrPx> hmmm
17:24:45 <thisiswei> probably I'll get more question later, thanks.
17:24:45 <ChongLi> it's been closed for a year but I'm experiencing it with the latest version of ghc-mod
17:27:19 <thisiswei> ski, what are you doing?
17:27:30 * ski is eating a sandwich
17:27:46 <ab9rf> did i wander into twitter?
17:28:56 * josephle remembers when somebody used twitter bots as a lambda calculus interpreter
17:29:21 <josephle> twitter banned his bots faster than they could compute church numerals
17:29:51 <DiegoNolan> anybody no anything about Missing (or bad) header file: primitive-memops.h
17:29:52 <hodapp> bahahahaha
17:30:06 <ski> they don't like bots ?
17:31:57 <SrPx> Aetherspawn: I don't get what you are doing at all, but I like it
17:32:16 <SrPx> I mean, I don't know what "do" and "return" do yet
17:32:29 <SrPx> but I loved the use of fold
17:32:50 <Aetherspawn> I don't think that fold would be practical normally
17:32:58 <SrPx> why ?
17:33:02 <Aetherspawn> It would overflow and go back to negative eventually
17:33:07 <Aetherspawn> which might confuse the game.
17:33:13 <SrPx> wat
17:33:20 <Aetherspawn> Int has bounds
17:33:21 <SrPx> oh
17:33:23 <Aetherspawn> > maxBound :: Int
17:33:23 <lambdabot>   2147483647
17:33:28 <Aetherspawn> > minBound :: Int
17:33:29 <lambdabot>   -2147483648
17:33:49 * Aetherspawn thinks he's getting good at this aww yeah
17:34:11 <SrPx> you don't need to fold over an infinite array of ints, do you? can't you just fold over an infinite array of the initial state?
17:34:38 <zRecursive> How to understand "type classes are Prolog"?  http://hpaste.org/89738
17:34:45 <Aetherspawn> You can, yeah.
17:34:59 <Aetherspawn> But in the example I wanted to print out the tick
17:35:32 <monochrom> type classes are not Prolog.
17:36:02 <jchild> ok ok super n00b question but I can't seem to google-fu it
17:36:09 <Aetherspawn> I don't know how to easily do the tail recursion thing without the fold though
17:36:43 <ski> zRecursive : first step, understand Prolog
17:36:49 <jchild> I've got two directories side-by-side, /helpers, /project
17:37:03 <zRecursive> monochrom: just copy from reddit, and i donot understand it
17:37:06 <jchild> how do I runhaskell something in /project while including modules from /helpers?
17:37:15 <ski> (and what monochrom said)
17:37:30 <zRecursive> ski: yeah
17:37:36 <monochrom> must you understand it?
17:38:10 <ski> Prolog can be fun to understand
17:38:13 <zRecursive> just curious
17:38:18 <monochrom> Prolog backtracks, type class search doesn't. "type classes are Prolog" is a misunderstanding, not an understanding.
17:38:21 <geekosaur> jchild, runhaskell -i ../helpers foo.hs
17:38:42 <jchild> geekosaur ooo thank you so much; the option doesn't appear in --help
17:39:01 <ski> zRecursive : fyi, there is a ##prolog channel here
17:39:01 <geekosaur> (assuming you are in project; if in the parent dir, it'd be: runhaskell -i helpers project/foo.hs)
17:39:06 <geekosaur> right, becayse it's a ghc option
17:39:13 <geekosaur> you'd refer to the ghc manual for those
17:39:21 <zRecursive> ski: it is a quiet channel :)
17:39:25 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html
17:39:35 <jchild> double-thanks
17:39:51 <ski> zRecursive : yes, mostly
17:40:02 * jchild got some readin' to do
17:40:24 <DanBurton> does anybody here use or have passing interest in the "numbers" package?
17:40:32 <monochrom> also, reddit is not free of falsehoods
17:41:13 <DanBurton> I'd like to know what you think about these changes, which I am basically applying out of faith that the suggestions were good ones. https://github.com/DanBurton/numbers/pulls
17:45:32 <thisiswei_> ski: will it help if I learn some prolog along with haskell?
17:46:05 <monochrom> I don't know whether it helps or it confuses.
17:47:08 <thisiswei_> monochrom: thanks
17:47:24 <ski> at least initially, it would probably be easier to not learn both simultaneously
17:47:47 <ski> (not having to struggle with two different syntices at the same time)
17:47:56 <ski> some ideas are common to them
17:49:03 <ski> and unification of logic variables in Prolog can be useful to understand type variables, as used in e.g. polymorphism, in Haskell
17:49:32 <monochrom> even just superficially, you may fail to make up your mind between [X|Y] and x:y. and that's just syntax. semantics is even harder.
17:50:01 <thisiswei_> monochrom, ski: cool!
17:50:06 <ski> if you're interested in different programming approaches, i would recommend learning Prolog (or at least some logic programming language) at some point
17:51:01 <monochrom> some people write "f [x:xs] = x + f xs" when they mean "f (x:xs) = x + f xs". consequently they don't understand the type error message
17:51:24 <JoeyA> What's a good problem to solve with Prolog?  Preferably something a tad more real-world than 8 queens.
17:51:24 <thisiswei_> ski: people say  Prolog mindf_ck 'em, so I really wanna try,  should I just go to prolog.com to find more info right?
17:51:28 <monochrom> and "[x:xs]" would be an inspiration of prolog's "[x|xs]"
17:51:54 <monochrom> oh! if you like mindf_ck, then go ahead! :)
17:52:36 <thisiswei_> monochrom: I'll try it after haskell. :)
17:52:37 <monochrom> something close to an expert system is good for prolog
17:52:57 <monochrom> s/inspiration of/inspiration from/
17:53:05 <geekosaur> isn't the reference implementation of Hindley-Milner in Prolog?
17:53:30 <geekosaur> that's somewhat helpful for Haskell, since it's the basis of Haskell's type inference
17:54:01 <JoeyA> geekosaur: ah, good answer
17:54:14 <monochrom> Prolog usually doesn't do occurs-check. this may break Hindley-Milner
17:55:33 <kartlos> thisiswei_: maybe not very real world but quite educational: 99 prolog problems https://sites.google.com/site/prologsite/prolog-problems
17:55:47 <thisiswei_> kartlos: thanks
17:55:58 <kartlos> thisiswei_: and the Haskell version: http://www.haskell.org/haskellwiki/99_questions
17:56:13 <JoeyA> Thanks
17:56:25 <thisiswei_> thanks
18:04:04 <ski> thisiswei_ : perhaps try "Learn Prolog Now!" at <http://www.learnprolognow.org/> ?
18:04:42 <thisiswei_> ski: got it!
18:05:10 <Aetherspawn> I wonder if there is any benefit in implementing and/or/xor in terms of nand instead of pattern matching
18:05:59 <Aetherspawn> (those who have taken electronic systems or something similar will remember NAND can make any logic sequence : http://hyperphysics.phy-astr.gsu.edu/hbase/electronic/ietron/nand5.gif )
18:07:00 <SrPx> data Test = Aaa | Bbb deriving (Show)
18:07:31 <SrPx> (wops, sorry) - I'm not sure what this is doing. What is Aaa there?
18:07:31 <monochrom> in silicon, nand is basic, so you build everything else upon it
18:07:45 <monochrom> in haskell, pattern matching is basic, so you build everything else upon it
18:08:16 <SrPx> Aetherspawn: eh, I'm taking it now. What do you mean with implementing and with pattern matching?
18:08:17 <monochrom> it is counterproductive to build nand upon pattern matching in silicon, or build pattern matching upon nand in haskell
18:08:42 <Aetherspawn> nice explanation by monochrom actually
18:09:23 <Aetherspawn> (but it does make me wonder whether it would make K-map reduction or something visible to the compiler :P)
18:09:27 <ski> nand could build types as well ..
18:10:26 <monochrom> in a sense, I'm also counterproductive in insisting other people to build intuition upon logic. it is not how they work. to them, intuition is more basic than logic. but their basic intuition is wrong. oh well, we're doomed.
18:15:20 <Aetherspawn> let a and' b = a + b in 1 `and'` 2
18:15:22 <Aetherspawn> > let a and' b = a + b in 1 `and'` 2
18:15:23 <lambdabot>   Not in scope: and'
18:15:23 <lambdabot>  Perhaps you meant one of these:
18:15:23 <lambdabot>    `and' (imported from...
18:15:38 <Aetherspawn> I can't make ` and ' play nicely
18:15:40 <Aetherspawn> ;__;
18:15:52 <monochrom> hrm, that's strange yeah
18:16:07 <hodapp> hrmph, trying to install examples for Hopencl and getting "cabal: can't find source for cml in ." . . . not sure what to do with that error
18:16:14 <monochrom> oh, you have to use `and'` on the LHS too
18:16:23 <Aetherspawn> maybe
18:16:25 <monochrom> let a `and'` b = a+b
18:16:34 <ski> @tell JoeyA perhaps ccxCZ's <http://wpr.cz/ccx/loggerhead/prosys/view/head:/stagebuilder.pl> would be fun to look at
18:16:35 <lambdabot> Consider it noted.
18:16:44 <Aetherspawn> let a `and'` b = a + b in 1 `and'` 2
18:16:46 <Aetherspawn> >let a `and'` b = a + b in 1 `and'` 2
18:16:50 <Aetherspawn> ugh, I
18:16:53 <jchild> haha
18:16:56 <Aetherspawn> > let a `and'` b = a + b in 1 `and'` 2
18:16:57 <lambdabot>   3
18:17:27 <ski> > let and = (+) in 1 `and` 2
18:17:28 <lambdabot>   3
18:18:20 <ethoma> Is there a way to get fixed length arrays in Haskell with fast indexing?
18:19:53 <zRecursive> @google prolog+haskell
18:19:54 <lambdabot> http://stackoverflow.com/questions/1932770/haskell-vs-prolog-comparison
18:19:54 <lambdabot> Title: Haskell vs. Prolog comparison - Stack Overflow
18:20:00 <ski> ethoma : `Data.Array.Array' ?
18:22:25 <hodapp> ugggh, already getting linker errors trying to build the examples from hopencl
18:26:17 <hodapp> how in the heck did they manage to build a static library and not link it against OpenCL... I am confuzzled...
18:26:49 <ethoma> @ski thanks! I haven't done too much Haskell, but I was looking at starting the project of building a chess engine in Haskell. I am sure I will be running into some problems because a chess engine is very stateful.
18:26:49 <lambdabot> Maybe you meant: wiki src ask
18:30:18 <flebron> Suppose I am representing polynomials as lists of coefficients. I want to multiply two of them. This would be the convolution of the two lists, correct?
18:31:20 <monochrom> yes
18:31:52 <ski> ethoma : IRC custom to direct a message to someone is to start the message by the nickname, followed by a comma or a colon, and the message, not to prefix the nickname by an `@' character
18:32:08 <monochrom> http://www.cs.dartmouth.edu/~doug/powser.html  does polynomial, even power series
18:32:11 <hodapp> hrmph. I don't even know where to start with HOpenCL examples not wanting to build... I don't know much about Cabal
18:32:11 <ski> ethoma : there are also mutable arrays (`STArray',`IOArray',&c.) if you need them
18:33:03 <flebron> monochrom: That seems not to use FFT, however, and take \Theta(n^2) :p
18:33:09 <lispy> Sonarpulse: I'm back
18:33:26 <flebron> (That's what I'm currently doing, and was trying to use convolution to apply the FFT.)
18:34:35 <monochrom> that's also right
18:34:40 <ethoma> ski: thanks; I don't suppose it is necessary to mention that I am new here.
18:35:14 <monochrom> McIlroy just wants to show off infinite lists :)
18:35:25 <flebron> monochrom: I couldn't find any code out there that convolves Num a => [a] -> [a] -> [a], however :(
18:35:42 <Aetherspawn> kmap.hs:4:2: lexical error at character '}'
18:35:49 <flebron> (I'm still learning the DFT for it, so I'll get it sooner or later. If there's no code done for it, I'll be the one to :p)
18:35:55 <Aetherspawn> http://hpaste.org/89739
18:35:56 <Aetherspawn> ideas?
18:38:04 <flebron> (My a is Rational, so I'd try to not touch Double or Complex unless I absolutely need to)
18:41:15 <Hafydd> :t (1 :+ 1) :: Complex (Ratio Int)
18:41:16 <lambdabot> Complex (Ratio Int)
18:41:42 <flebron> Oh, I can have Complex (Rational)? That would be great :)
18:41:45 <arkeet> > 1 + (2 :+ 3) :: Complex Rational
18:41:46 <lambdabot>   No instance for (GHC.Float.RealFloat
18:41:46 <lambdabot>                     (GHC.Real.Ratio GH...
18:41:49 <arkeet> no yo ucan't.
18:41:58 <Hafydd> Rational is a class!
18:42:01 <arkeet> it isn't
18:42:05 <arkeet> type Rational = Ratio Integer
18:42:08 <flebron> Rational is Ratio Integer
18:42:15 <Hafydd> ._.
18:42:18 <flebron> So why can't I?
18:42:20 <Hafydd> My mistake.
18:42:28 <arkeet> but the point is that operations on  Complex a  require a  RealFloat a  instance
18:43:07 <flebron> Ewwww
18:43:09 <arkeet> yes.
18:43:14 <arkeet> probably for stuff like abs
18:43:37 <Aetherspawn> Anyone got any ideas why the RULES gives a parse error?
18:43:37 <arkeet> all you need to be able to do fourier transforms is enough roots of unity, though.
18:43:38 <Hafydd> Hmmh.
18:43:42 <Aetherspawn> http://hpaste.org/89739
18:43:47 <hodapp> And yet another package is failing to install via Cabal. This is rather pissing me off.
18:43:57 <arkeet> but you'd likely have to write your own DFT
18:44:09 <flebron> arkeet: That will introduce the pesky Double, won't it?
18:44:15 <arkeet> why?
18:44:26 <flebron> How would you represent the roots of unity?
18:44:39 <hodapp> I guess Reactive just isn't being maintained...?
18:44:44 <arkeet> same way you'd represent elements of other finite extensions of Q.
18:44:45 <ChongLi> hodapp: cabal is tricky, it's best to specify all of the things you want to install simultaneously
18:44:51 <arkeet> I dunno.
18:44:59 <ChongLi> and not install things incrementally over time
18:45:13 <ChongLi> that way the dependency solver has all the information up front
18:45:20 <hodapp> ChongLi: I am just trying to get FieldTrip and fieldtrip-reactive installed to work with some examples
18:45:36 <ChongLi> tried cabal-dev?
18:45:43 <hodapp> the channel?
18:45:48 <ChongLi> no, the tool
18:45:54 <hodapp> no
18:45:57 <ChongLi> http://hackage.haskell.org/package/cabal-dev
18:46:27 <hodapp> what'll it accomplish for me?
18:46:40 <ChongLi> it'll give you a sandbox local to a project
18:46:56 <ChongLi> allowing you to play with packages without conflicting with your global environment
18:47:03 <hodapp> I just installed Cabal; what I have is about as pristine as a sandbox
18:47:15 <arkeet> you don't have a sandbox.
18:47:38 <arkeet> but a sandbox wouldn't help with installing packages.
18:47:40 <hodapp> arkeet: I am not seeing how an actual sandbox is going to help with the errors I'm receiving.
18:47:55 <ChongLi> what errors are you receiving?
18:48:47 <arkeet> hodapp: you should paste your errors and build logs and such to hpaste.
18:49:53 <hodapp> http://hpaste.org/89742
18:50:10 <ChongLi> hodapp: ahh
18:50:16 <ChongLi> just add that to your build-depends
18:50:21 <ChongLi> in the .cabal file
18:50:52 <hodapp> what .cabal file?
18:50:56 <arkeet> that would make sense if that was his own package.
18:51:08 <arkeet> well,
18:51:12 * hackagebot Control-Monad-ST2 0.1.0.1 - A variation on the ST monad with two type parameters.  http://hackage.haskell.org/package/Control-Monad-ST2-0.1.0.1 (KevinBackhouse)
18:51:13 <arkeet> the issue is with the reactive package.
18:51:19 <arkeet> it depends on category-extras.
18:51:34 <ChongLi> ahh
18:51:47 <arkeet> and category-extras is gone.
18:51:51 <arkeet> well, deprecated and replaced with a stub.
18:52:02 <ChongLi> oh yeah
18:52:07 <arkeet> I suggest finding another FRP library.
18:52:08 <ChongLi> reactive was last built on 6.12
18:52:18 <ChongLi> it is no longersupported
18:55:06 <hodapp> in the case of HOpenCL it's piles and piles of linker errors when I try to build the examples, and there is probably some easy solution if I actually know something about Cabal
18:56:04 <lispy> hodapp: does this help? http://dagit.github.io/posts/2013-04-29-opencl-and-language-c-quote.html
18:56:33 <hodapp> lispy: perhaps, I'll give it a read
19:00:28 <hodapp> huh, this is the first I've heard of language-c-quote
19:01:53 <hodapp> ...or quasiquoting.
19:04:01 <lispy> hodapp: you can mostly ignore that
19:04:30 <lispy> hodapp: I plan to eventually use the quasiquoting so that Haskell can be my macro language for generating OpenCL code
19:04:39 <lispy> hodapp: at the moment all my OpenCL code is hand written
19:04:43 <hodapp> lispy: why ignore it? it looks interesting.
19:04:56 <lispy> How about, that part is optional :)
19:05:07 <hodapp> true, you did say _can_
19:05:51 <lispy> I have a very simple ray-tracer written in Haskell and I'm in the process of converting it to OpenCL
19:06:04 <hodapp> ooh, neat
19:06:08 <lispy> Because the ray-tracer is simple and the scenes are also simple I'm hoping it will be real-time
19:06:33 <hodapp> interested in any collaboration on that project?
19:06:56 <lispy> it's on github, so feel free to play with the code: https://github.com/dagit/haray
19:07:40 <lispy> So far it's just been an educational toy for me, but it's BSD3 code so feel free to play with it and if you add some cool feature send me a pull request
19:08:23 <lispy> until recently it was very good about always building, but then I went and started depending on development snapshots of things like Juicy.Pixels
19:18:40 <hodapp> lispy: thanks, I'll give it a look
19:19:13 <lispy> hodapp: I haven't pushed the OpenCL changes yet. Those are rotting at home on my harddrive. I'll try to clean that up and push something, someday :)
19:20:20 <hodapp> lispy: and are you using language.c.quote for this?
19:20:52 <lispy> Yes, the code I have at home uses language.c.quote to embed the OpenCL bits as Haskell values.
19:21:40 <hodapp> it looks a little more promising than hopencl
19:22:05 <lispy> I didn't push it because I was trying to use some things that weren't implemented yet for OpenCL in language-c-quote. The author has now added those features in the github version of the library (probably not on Hackage yet). So I need to update the README to explain which dependencies need to be install manually.
19:22:33 <lispy> Some types were missing like bool. I guess that's implemented now.
19:23:51 <thisiswei_> mchua_afk
19:23:55 <lispy> oh, looks like he published it to hackage: http://hackage.haskell.org/packages/archive/language-c-quote/0.7.2/doc/html/src/Language-C-Quote-OpenCL.html
19:24:18 <lispy> I should bug the juicypixels author to update as well
19:24:30 * lispy likes having simple to install packages
19:26:14 <hodapp> lispy: I am off to bed, but do ping me if you make those updates! I'll be looking a bit at the code, in part because I'm still pretty new to the language.
19:28:03 <lispy> hodapp: will do
19:47:35 <dibblego> is this function(s) possible? http://hpaste.org/89743
19:51:16 <Aetherspawn> Cabal is annoying because haskell evolves too fast
19:51:18 <Aetherspawn> not much can solve that
19:51:37 <Aetherspawn> maybe if it supported fully sandboxed packages
19:51:38 <shachaf> dibblego: I doubt it.
19:51:53 <dibblego> I am doubting it too
19:52:22 <bz> is it just me or does cabal need cabal to be installed?
19:52:49 <pxqr> why this doesn't works? http://hpaste.org/89744
19:53:06 <shachaf> cabal won't work when it's not installed, if that's what you mean.
19:53:48 <shachaf> pxqr: http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-Event.html says you need to run an EventManager.
19:53:49 <NihilistDandy> Aetherspawn: I think git versions of Cabal support sandboxing
19:53:50 <applicativ> bz there is a make file or other script in the source for cabal install
19:53:55 <bz> i git cloned from the gh repo, then bash bootstrap.sh but getting Cabal >=1.17.0 && <1.18
19:53:55 <shachaf> What are you expecting?
19:54:01 <bz> and yet
19:54:04 <NihilistDandy> I don't know how fully implemented it is, but that's my understanding
19:54:09 <bz> the bootstrap script only installs 1.16.*
19:54:15 <bz> having a real lolwtf moment
19:54:40 <shachaf> pxqr: This module is GHC-internal, not for users.
19:54:57 <pxqr> shachaf: ah, I didn't notice.
19:55:08 <NihilistDandy> bz: That's not my experience. Did you install the Cabal 17 first?
19:55:20 <pxqr> shachaf: I need just timeouts with callbacks actually. I should use System.Timeout?
19:55:33 <applicativ> bz do you need cabal 1.17
19:55:37 <shachaf> Maybe? I don't know what timeouts with callbacks is.
19:55:44 <shachaf> But System.Timeout sounds good for timeouts.
19:55:49 <bz> NihilistDandy: uh. how do i install cabal 17?
19:56:19 <NihilistDandy> ghc --make Setup.hs, then ./Setup configure -p; ./Setup build; ./Setup haddock; ./Setup install
19:56:24 <bz> NihilistDandy: i'm doing a fresh install of cabal straight from gh master on a system that previously has no cabal
19:56:27 <NihilistDandy> In the Cabal directory
19:56:35 <applicativ> bz get the dev source for the Cabal lib
19:56:37 <bz> you mean /cabal-install?
19:56:41 <Aetherspawn> does lambdabot have a haddock link command
19:56:44 <monochrom> bz: there is no need to use the version on github. just go to http://hackage.haskell.org/package/cabal-install/ , scroll down to the bottom, use that tarball, and use the bootstrap.sh inside it
19:56:50 <Aetherspawn> *hackage
19:56:51 <applicativ> bz, you already have a Cabal lib if youi have ghc of course
19:56:58 <NihilistDandy> bz: No, Cabal. There are two directories in the github repo
19:57:15 <Aetherspawn> @where stm
19:57:15 <lambdabot> http://haskell.org/haskellwiki/Software_transactional_memory
19:57:31 <monochrom> this is going to be an XYZ Problem
19:57:44 <applicativ> monochrom: the hackage version is 1.16 bz seemed bent on 1.17
19:58:03 <monochrom> or bent on github versions
19:58:16 <monochrom> perhaps one should also git clone ghc
19:58:27 <applicativ> pigeon-(github-version)
19:59:01 <Aetherspawn> chicken egg problem is the same on an amazon AWS
19:59:06 <applicativ> bz, did we establish that you really want the development cabal-install, rather than the one most of us are using, 1.16
19:59:14 <NihilistDandy> My usual strategy is installing a ghc bindist, then cloning the cabal repo, installing Cabal, then mucking with the cabal-install bootstrap.sh until it does the things I want
19:59:18 <monochrom> git clone https://github.com/ghc/ghc.git
19:59:43 <NihilistDandy> The default settings for the Haskell platform fit my needs, though, so I've switched back to that
19:59:57 <applicativ> but I want the branch simon pj is working on right now
20:00:22 <NihilistDandy> The 1.17 branch has sandboxing and stuff, though, which is fun
20:00:38 <applicativ> yes, I was wondering if bz had reason to be testing that or something
20:01:01 <sclv> dibblego: i'm pretty sure its not possible. you'll eventually need (a -> b) and you can't do that with f a -> f b
20:01:08 <sclv> you fan do it with forall f. f a -> f b though :-)
20:01:19 <sclv> bc then take f to be identity and boom
20:01:24 <NihilistDandy> applicativ: I generally use it so I can test the packages I use with it ahead of time. lens works with it now, thanks to a bug report from me :D
20:01:38 <NihilistDandy> I guess they changed the API in some break-y ways for more complex cabals
20:02:13 <NihilistDandy> Well, and main thanks to edwardk for being a genius :D
20:03:07 <monochrom> one doesn't just git clone into Mordor!
20:04:57 <bz> NihilistDandy: uh, Cabal/Setup configure requires >= 1.17.0 and < 1.18.0. what gives?
20:09:31 <applicativ> bz, wait are you talking about cabal-install or the Cabal libraries?
20:12:54 <bz> applicativ: um. i need to cabal-install something. as in have an executable cabal-install. i could install 9000 MB of old crud from my distro's package repo, or i could keep it all in a non-root install from, say, github.
20:13:44 <bz> applicativ: i'm 90% sure that i'm doing something wrong, but i'm not sure what. i assumde tht the tip of gh master would always be usable a la pypa/virtualenv.git (for python), but maybe i'm wrong.
20:14:37 <monochrom> why github?
20:15:00 <applicativ> ok, bz then monochrom is right.  skip github
20:15:03 <monochrom> well, I guess you don't have to answer, it's your life, you're free.
20:15:39 <applicativ> first, what Cabal library does ghc-pkg list show? or ghc-pkg list Cabal
20:15:57 <applicativ> you already have one, this may be of interest
20:16:07 <monochrom> anyway, hackage.haskell.org
20:16:26 <applicativ> bz, and what is the version of 'cabal --version'
20:16:40 <bz> applicativ: there is no 'cabal'
20:16:55 <bz> applicativ: i've only a bare ghc install from the package repo
20:17:02 <applicativ> ah okay but there is a Cabal library shown by ghc-pkg list Cabal
20:17:22 <applicativ> bz it is a 'boot' library, so you have it
20:18:21 <applicativ> bz the easy way will be to install the 'cabal install' executable that mirrors the Cabal library your ghc is already using
20:19:35 <applicativ> that number will be shown by the command 'ghc-pkg list Cabal'
20:19:37 <monochrom> http://hackage.haskell.org/packages/archive/cabal-install/1.16.0.2/cabal-install-1.16.0.2.tar.gz is most likely the right version
20:19:52 <applicativ> not if bz has ghc-6.12
20:20:18 <NihilistDandy> Ow, my heart
20:20:37 <monochrom> then keep decreasing (not increasing) version numbers until the right one is hit
20:21:06 <applicativ> you just keep trying on cabal-installs till you find one that fits....
20:21:21 <applicativ> or use the almight ghc-pkg
20:21:26 <applicativ> almighty too
20:21:38 <monochrom> I have an empirical law. 99% of errors are in information not given.
20:22:14 <flebron> So I'm using Numeric.FFT to compute a convolution, but it's giving me the wrong results. I've compared it to Octave's answer, which is correct. Am I doing something wrong? http://hpaste.org/89748
20:22:45 <applicativ> hah, Octave is right, Haskell is wrong???!!!
20:23:09 <Fuuzetsu> Regular reminder that Octave/MATLAB are the worst things ever.
20:23:10 <flebron> For some reason :p Although I'm fairly certain "Haskell is wrong" means "I'm using Haskell wrong."
20:23:49 <flebron> This is polynomial multiplication, so the expected result is pretty clear-cut. (1 + 5x + 4x^2) * (5 - 3x + x^2 + 4x^3) = 5 + 22x + 6x^2 - 3x^3 + 24x^4 + 16x^5.
20:24:29 <flebron> However, idft(zipWith (*) (dft a) (dft b)) is giving me the wrong result... am I using the dft wrong?
20:25:15 <NihilistDandy> Fuuzetsu: +1
20:25:42 <NihilistDandy> Fuuzetsu: I will give a slight edge to Octave, though. Matlab is just all kinds of ick
20:25:54 * flebron used both Haskell and Octave at his last job... Haskell for numbers and prototyping, Octave for plots and function behavior.
20:26:34 <Fuuzetsu> NihilistDandy: except Octave is just a free clone of MATLAB, and many functions are just ‚Äònot implemented yet, sorry!‚Äô.
20:27:04 <NihilistDandy> I like programming with restrictions~
20:27:47 <Clint> Fuuzetsu: it's free software; you could fix that
20:27:56 <applicativ> how come we cant do fancy plots and stuff with Haskell, is it because our language is bad?
20:27:58 <NihilistDandy> Also, every second I've been writing MATLAB I've just been stupendously angry at my chaos professor, so my opinion should be taken with a grain of salt
20:28:49 <flebron> I'm also doing it with C++, and it's giving the correct result... it seems only Numeric.FFT gives the incorrect one :s
20:31:48 <bz> monochrom: thanks, the older version worked. what do i need if i want to install from the tip of git?
20:32:21 <monochrom> begin by installing a newer GHC
20:32:30 <monochrom> git clone https://github.com/ghc/ghc.git
20:33:28 <monochrom> s/a newer/the newest/
20:34:06 <applicativ> i don't think he would need a new ghc to install Cabal-1.17 + cabal-install-1.17
20:34:34 <NihilistDandy> applicativ: I've done it with 7.4.2 and 7.6.1, at least
20:34:36 <applicativ> it's not particularly advisable; who needs the strain.
20:35:14 <NihilistDandy> It really only takes a few minutes to get it all set up, even from git (modulo compilation speed)
20:35:44 <applicativ> yes, it certainly possible  d coutts claims there should be little problem, since nothing else uses your extra Cabal library.
20:36:44 <applicativ> I mean the newer local Cabal library won't cause chaos with later installs from Hackage etc
20:37:00 <NihilistDandy> Yeah. I think I had some minor issues now and again when something implicitly required Cabal 1.16 but grabbed 1.17 because there was no upper bound, but that was rare if ever
20:37:26 <NihilistDandy> Those all seem to have stabilized, anyway
20:38:29 <applicativ> in theory bz if you are bent on the newer cabal-install, you would enter the Cabal directory in the git repo, do cabal install; then enter the cabal-install directory and do likewise.
20:38:34 <applicativ> but this is the theory.
20:39:14 <applicativ> then a new `cabal` will be put in $HOME/.cabal/bin
20:39:30 <NihilistDandy> And even without the theory, it's just cd cabal/Cabal then build the Setup file and install the lib, then cd ../cabal-install and sh bootstrap.sh
20:40:32 <applicativ> it should be akin to 'cabal install cabal-install' though, no?
20:40:56 <NihilistDandy> It sounds like bz doesn't have a cabal-install yet
20:41:01 <applicativ> why bootstrap when you have the boot? or how does that metaphor work
20:41:08 <bz> NihilistDandy: i don't
20:41:21 <applicativ> oh sorry bz, i thought you were saying you did. gr
20:41:40 <applicativ> but did we find out what ghc-pkg list Cabal said?
20:41:47 <bz> applicativ: no no. just a barebones ghc, ghci, ghc-pkg
20:41:48 <NihilistDandy> Right, so if you want to use the current git version, you need to install the Cabal 17 library before trying to install cabal-install
20:41:50 <bz> applicativ: and no
20:41:57 <bz> 05:46:42 CEST ~/c/c/cabal-install-1.16.0.2> ghc-pkg list Cbal
20:41:57 <bz> /var/lib/ghc/package.conf.d
20:41:57 <bz> /home/bryant/.ghc/x86_64-linux-7.4.2/package.conf.d
20:42:02 <bz> that's the output; not very helpful.
20:42:10 <applicativ> oooh
20:42:11 <NihilistDandy> ghc-pkg list Cabal
20:42:18 <NihilistDandy> That says Cbal
20:42:36 <bz> fml
20:42:42 <bz> 05:47:23 CEST ~/c/c/cabal-install-1.16.0.2> ghc-pkg list Cabal
20:42:42 <bz> /var/lib/ghc/package.conf.d Cabal-1.14.0
20:42:42 <bz> /home/bryant/.ghc/x86_64-linux-7.4.2/package.conf.d Cabal-1.16.0.3
20:42:46 <applicativ> bingo
20:42:51 <NihilistDandy> There we go
20:42:57 <bz> hard to concentrate when with a girlfriend yelling at me
20:43:11 <bz> so is my version 1.16 or 1.14?
20:43:15 <NihilistDandy> So, go to where you git cloned Cabal
20:43:17 <NihilistDandy> It's 1.14
20:43:33 <bz> okay, i'm in /cabal-install
20:43:37 <applicativ> he has 1.14 globally and 1.16 locally
20:43:37 <monochrom> no, 1.16 takes precedence for two reasons
20:43:46 <bz> right, it's just like virtualenv
20:43:48 <NihilistDandy> Wherever you cloned cabal, there are two directories, Cabal and cabal-install
20:43:58 <bz> NihilistDandy: yes
20:44:13 <NihilistDandy> So you need to cd Cabal
20:44:31 <bz> and do the setup schpiel?
20:44:36 <Clint> what is the purpose of this exercise?
20:44:39 <applicativ> maybe he should unregister Cabal-1.16.0.3 NihilistDandy ?
20:44:44 <applicativ> Clint, it's not clear
20:44:52 <Clint> in that case
20:44:54 <applicativ> I think bz is getting with the program though
20:44:55 <Clint> bz: rm -rf ~/.ghc ~/.cabal; sudo apt-get install cabal-install; cabal update
20:44:58 <bz> Clint: to get cabal-install working
20:45:01 <monochrom> inb4 "Setup configure --user"
20:45:07 <NihilistDandy> ghc --make Setup.hs && ./Setup configure --whatever-flags && ./Setup build && ./Setup haddock && ./Setup install
20:45:11 <bz> Clint: yeah, that's a really old cabal-install from the repositories
20:45:16 <monochrom> did you know: "Setup configure" implies --global
20:45:20 <Clint> what are you running?
20:45:23 <NihilistDandy> applicativ: Maybe, but I don't think it will matter much
20:45:54 <bz> Clint: old ubuntu
20:46:00 <NihilistDandy> Then once that's all done, cd ../cabal-install && sh bootstrap.sh
20:46:07 <Clint> have you considered upgrading to something modern?
20:46:10 <applicativ> well it's ghc-7.4 which isn't too ancient
20:46:47 <NihilistDandy> My real recommendation is just to use the Haskell Platform because it handles alex, happy, and cabal and because the default cabal config is pretty sane
20:47:01 <bz> interesting, ./Setup configure works now that i have 1.16 installed locally
20:47:07 * applicativ is with Clint, why not just to hell with apt-get, drag and drop the bindist ghc-7.6 and have done with this
20:47:14 <bz> applicativ: because i want a local install
20:47:42 <NihilistDandy> Setting up the bindist with a local install is just setting --prefix=$HOME/GHC or similar
20:47:47 <applicativ> bz, yes, that's my point, I only install ghc locally myself
20:48:04 <applicativ> it takes 2 minutes
20:48:30 <monochrom> <monochrom> begin by installing a newer GHC
20:49:12 <monochrom> the prophesy is strikingly right, even though I intended something else
20:49:12 <NihilistDandy> monochrom: Seconded
20:49:15 <applicativ> choose the appropriate 'unknown linux bindist' from http://www.haskell.org/ghc/download_ghc_7_6_3
20:49:34 <bz> monochrom: so the version of cabal-install is tied to ghc?
20:49:39 <applicativ> then follow the readme, or for the bigger picture monochrom's page about installing haskell platform locally
20:49:53 <bz> damn, i really wanted it to be like virtualenv
20:49:59 <monochrom> no, but look at how much time you spent
20:50:18 <bz> meh. cabal 1.16 i guess
20:50:35 <NihilistDandy> Clint: I like to believe that you're a bot that corrects C style errors
20:50:42 * flebron is sad there isn't a working fft from [Double] to [Double] :(
20:50:51 <applicativ> bz, you mean you want cabal-1.17  we can still build it. i recommend scrapping ghc-7.4 there will be other problems, e.g bytestring
20:51:33 <NihilistDandy> bz: That's what hsenv or cabal-dev are for.
20:51:40 * applicativ is about to install the dev cabal-install from the sheer love of chaos
20:53:33 <NihilistDandy> applicativ: Until this last platform release, that was the usual for me
20:56:35 * applicativ isn't sure he really needs the profiling version of Cabal 
20:57:10 <Fuuzetsu> Clint: I could but I have no interest in doing so. My tactic is to avoid it like fire.
20:59:58 <NihilistDandy> applicativ: It hasn't bitten me recently, but building with profiling has become a habit
21:00:00 <applicativ> hey I have it bz
21:00:17 <applicativ> NihilistDandy: yes, it was just following my config
21:00:35 <lispy> @tell carter re: makefiles, http://miller.emu.id.au/pmiller/books/rmch/ is a good intro, but there is much more to it than that. It's good to remember that your makefile is a program and treat it like software engineering.
21:00:35 <lambdabot> Consider it noted.
21:00:35 <joelteon> is there a container somewhere that acts as a weighted map?
21:00:46 <joelteon> like, the probability of retrieving element x is dependent on how many times x was inserted
21:00:50 <applicativ> bz, building the Cabal libs takes a few minutes, but all together it wasn't too bad with ghc-7.6
21:01:16 <joelteon> or should I just make one?
21:01:35 <applicativ> bz here's monochrom 's helper page http://www.vex.net/~trebla/haskell/haskell-platform.xhtml you don't have to install all of the haskell platform
21:02:45 * applicativ now wonders what to do with this sexy cabal-1.17
21:02:54 <bz> applicativ: nice. you just compiled it?
21:02:59 <applicativ> yes
21:03:02 <monochrom> I heard it has sandboxing
21:03:31 <applicativ> indeed , "  sandbox      Create/modify/delete a sandbox"
21:05:07 <NihilistDandy> joelteon: I think there is something, but I've no idea what
21:08:45 <applicativ> what would 'cabal sandbox list-sources' do or tell?
21:08:54 <monochrom> flebron: idft (dft [1, 1, 0, 0]) = [1, 0, 0, 1]. I am trying to think what this means.
21:09:12 <flebron> :s
21:09:52 <flebron> It would seem to be the case that "The first element is correct, everything else is reversed"?
21:10:22 <flebron> (btw, idft . dft = id should be a simple QuickCheck property...)
21:11:21 <monochrom> "=" and "id" are futile for Complex Double
21:12:26 <monochrom> idft (dft [1, 2, 0, 3]) = [1, 3, 0, 2]  your conjecture looks right
21:14:43 <monochrom> flebron: I hope my http://www.vex.net/~trebla/tmp/DSP.hs may be of use
21:15:01 <monochrom> I use Vector but you may be able to rewrite to []
21:18:58 <leftsaidtim> serious question: how many are you are in this channel to find out how big the haskell community is?
21:19:27 <monochrom> not me
21:20:12 <NihilistDandy> Spoiler alert: Honeycomb's big, yeah yeah yeah
21:30:28 <Chat3259> Ello
21:37:53 * lispy wonders if leftsaidtim is the cousin of rightsaidfred
21:45:09 <flebron> monochrom: Is there any way to do such an FFT with, say, Rational? (Ratio Integer). If I use Double, the precision isn't enough and I get numerical errors.
21:45:50 <monochrom> sin and cos stand in your way
21:46:12 <monochrom> but perhaps you can look for that "rational trig" guy and his trig tricks
21:46:36 * hackagebot xing-api 0.1.2 - Wrapper for the XING API, v1.  http://hackage.haskell.org/package/xing-api-0.1.2 (JanAhrens)
21:46:59 <flebron> (My objective is to compute a convolution of two lists of Rationals, it would seem to be weird that I can only do that by losing precision :p)
21:47:10 <external-reality> I need a bit of help with lens package. When want to update a piece of state from within MonadState s m, let say _x, I say `let lx = use x; x .= update lx`. Is there a better way to do this type of inplace update using lenses in MonadState?
21:54:10 <joelteon> is cabal configure -fsomeflag the right way to enable someflag in the cabal file?
21:54:50 <external-reality> cabal build -fsomeflag
21:55:26 <external-reality> cabal configure has predefined options
21:55:34 <joelteon> unrecognized option '-fdebug' but I specified Flag debug in the cabal file
21:55:53 <shachaf> build -fsomeflag? Are you sure about that?
21:56:02 <external-reality> no
21:56:20 <external-reality> :-)
21:57:19 <shachaf> It doesn't sound right to me.
21:57:46 <external-reality> Now we have to go look at the docs -- see what you did?
21:57:54 <pxqr> does flag "description" field anything particular useful?
21:57:55 <applicativ> external-reality: about the lens, what is wrong with just writing x .= 17
21:58:05 <tabemann> random question: I want to give a parameter to a lambda a type signature, but when I tried to do this in GHCi, it said it wasn't supported anymore
21:58:11 <joelteon> pxqr: ?
21:58:30 <tabemann> so how do I do this, other than find some other place the same value is being used in the function, and give it a type signature there
21:58:54 <shachaf> "it isn't supported anymore"? I hate that error.
21:59:39 <external-reality> @applicative One could do that but my question is how can I do the equivalent of x += 17?
21:59:39 <lambdabot> Unknown command, try @list
22:00:00 <tabemann> "Result signatures are no longer supported in pattern matches"
22:00:23 <applicativ> x += 17 is the equivalent of x += 17
22:00:34 <shachaf> tabemann: As usual, when you ask a question, you should specify: What you did; what you expected; what happened.
22:00:54 <tabemann> Prelude> (\x :: Float -> error "foo!") 0.0
22:01:16 <shachaf> OK. We'll call that close enough.
22:01:19 <applicativ> external-reality: i mustn't be understnding, but in a state monad, x += 17 adds 17 to the 'x' field of the underlying state
22:01:25 <shachaf> You need parentheses, as in (\(x :: Float) -> ... )
22:01:53 <tabemann> okay I tried:
22:02:05 <tabemann> Prelude> (\(x :: Float) -> error "foo!") 0.0
22:02:07 <tabemann> and got:
22:02:16 <tabemann>     Illegal signature in pattern: Float
22:02:17 <tabemann>         Use -XScopedTypeVariables to permit it
22:02:36 <applicativ> Excellent extension ScopedTypeVariables
22:02:36 <external-reality> applicativ: but what if you are doing an arbitrary in place update `x .= f(x)`. Feel me?
22:02:38 <shachaf> I wonder how you could fix that...
22:03:06 <tabemann> I know what ScopedTypeVariables does, but I am befuddled as to how it would apply there
22:03:10 <applicativ> external-reality: x %= (^2) squares the x component
22:04:04 <shachaf> I suppose you don't know what it does completely, then.
22:04:06 <applicativ> external-reality: x %= (\z -> z^2 + 2*z + 1) squares the successor of the x component
22:04:10 <external-reality> applicativ: Ok, i'll give it a try, thank you app
22:04:17 <shachaf> Did you read the GHC User's Guide entry on scoped type variables?
22:04:54 <tabemann> no I haven't
22:06:18 <applicativ> whoa, I built my first hello-world executable with 'cabal sandbox' using a sandboxed development version of text
22:06:40 <applicativ> this will end in ruin
22:08:04 <applicativ> I assumed `cabal sandbox` would just give me an ASCII picture of kids playing in a sandbox
22:08:42 <tabemann> I'm reading this, and I still am not sure just how it applies to me doing (\(x :: Float) -> error "foo!")
22:09:32 <shachaf> What's the page and section you're reading?
22:09:44 <tabemann> http://www.haskell.org/ghc/docs/4.04/users_guide/users_guide-5.html#scoped-type-variables
22:09:51 <tabemann> 5.9
22:09:54 <shachaf> GHC 4.04?
22:10:02 <shachaf> That's, uh, a very old version of GHC.
22:10:05 <tabemann> whoops
22:10:39 <shachaf> Anyway, section 5.9 specifies that this behavior is allowed.
22:10:43 <tabemann> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/other-type-extensions.html#scoped-type-variables
22:11:17 <NihilistDandy> applicativ: What a lewd package manager
22:11:25 <shachaf> 7.12.7.4?
22:12:08 <tabemann> well, I should actually be reading an earlier version of the docs, as I'm not using 7.6.1
22:12:13 <applicativ> what are these 'result signatures' that are no longer allowed
22:12:25 <applicativ>       Result signatures are no longer supported in pattern matches
22:12:43 <applicativ> for let f = \x :: Float -> error "Float"
22:12:45 <shachaf> applicativ: E.g. f (x :: Int) :: Int = x
22:13:05 <shachaf> The \ syntax makes slightly less syntactical sense but is probably analogous.
22:13:13 <applicativ> oh
22:14:07 <applicativ> i guess I see it; with let f = \(x :: Float) -> error "Float" it demands ScopedTypeVariable
22:14:10 <applicativ> s
22:14:15 <shachaf> Yep.
22:14:44 <tabemann> I don't see what lexically scoped type variable is being introduced there
22:15:44 <shachaf> It is part of the extension.
22:16:10 <shachaf> If you think it should be split into a different extension, you are free to submit a GHC feature request.
22:16:19 <applicativ> @type let f = \(x :: Float) -> x * x in f
22:16:20 <lambdabot>     Illegal type signature: `Float'
22:16:20 <lambdabot>       Perhaps you intended to use -XScopedTypeVariables
22:16:20 <lambdabot>     In a pattern type-signature
22:16:22 <dolio> It already is split.
22:16:24 <applicativ> bah!
22:16:29 <shachaf> Is it?
22:16:31 <dolio> But they've deprecated the other extension.
22:16:38 * hackagebot atom-msp430 0.5.2 - Convenience functions for using Atom with the MSP430 microcontroller family.  http://hackage.haskell.org/package/atom-msp430-0.5.2 (DanielBuckmaster)
22:16:38 <dolio> PatternSignatures.
22:16:46 <shachaf> Oh.
22:16:53 <shachaf> Deprecating it does seem a bit silly.
22:17:00 <dolio> Yeah, I don't get it.
22:17:02 <applicativ> PatternSignatures ?
22:17:06 <applicativ> oh dolio said
22:17:16 <shachaf> They already allow extensions to turn on other extensions.
22:17:26 <tabemann> oh I see it
22:17:39 <applicativ> wait, dolio, is PatternSignatures the deprecated on?
22:17:41 <applicativ> one?
22:17:46 * tabemann just noted in the user docs that "pattern type signatures" is under ScopedTypeVariable
22:17:47 <tabemann> weird
22:19:35 <ski>   x.= update (use x)  -- mayhaps
22:19:59 <applicativ> ah     -XPatternSignatures is deprecated: use -XScopedTypeVariables or pragma {-# LANGUAGE ScopedTypeVariables #-} instead
22:20:09 * carter acfoltzer what embedded APU  pray tell?
22:20:23 <external-reality> @ski aimed at me
22:20:23 <lambdabot> Maybe you meant: wiki src ask
22:21:15 * carter @tell ofan nope, theres no conflict wrt the wavewave work, just means you can move to the QT stuff sooner :) 
22:21:20 <tabemann> why would they merge the two?
22:21:29 * applicativ wonders how `cabal sandbox init` knows his email address
22:22:02 * ski wants `PatternSignatures' back
22:22:22 * applicativ wants it back too, now that he knows it was there ....
22:22:24 <shachaf> carter: You're saying everything with /me. It won't work.
22:22:38 <ski> (especially being able to bind type variables in them)
22:22:43 <carter> shachaf it ws because I pressed shift + enter
22:22:48 <carter> out of IMing habit
22:22:58 <carter> @tell ofan nope, theres no conflict wrt the wavewave work, just means you can move to the QT stuff sooner :)
22:22:58 <lambdabot> Consider it noted.
22:23:15 * carter shachaf thanks for catching that
22:23:20 <carter> damnit
22:23:37 <applicativ> @tell carter Consider it noted
22:23:37 <lambdabot> Consider it noted.
22:23:39 <dolio> I guess they think that most uses of it involve scoped type variables. But I personally I think it's way more common than scoped type variables period.
22:23:42 <carter> @tell ofan  darn
22:23:42 <lambdabot> Consider it noted.
22:23:44 <shachaf> If only your IRC client supported putting a : after people's names when you address them!
22:23:53 <carter> shachaf tough ;)
22:24:04 <shachaf> dolio: It's also a much smaller extension, e.g. more easily suitable for haskell'
22:24:05 <carter> applicativ: how're you doing?
22:24:36 <applicativ> it could be worse.  i'm studying `cabal sandbox`
22:24:58 <dolio> Especially with their new exceptions library.
22:25:52 <carter> applicativ oh? i like that tool
22:26:08 <carter> resumed using it now that whats his name fixed the bug i hit in it
22:26:14 <ski> (and also because i dislike the syntax for how `ScopedTypeVariables' works ..)
22:26:36 <applicativ> oh youve used cabal's own sandbox machine. I am assuming it is incomplete somehow...
22:26:49 <carter> applicativ is nice
22:26:52 <carter> its nice
22:26:53 <carter> use it
22:26:57 <carter> i'm pretty happy so far
22:27:14 <scottj> are there any webkit-wrapping web browsers written in haskell?
22:27:35 <scottj> a la the many vimperator clones
22:27:42 <ski> applicativ : you appear to have lost an `e'
22:27:54 <Pseudonym> It looks like #coq is dead at the moment. I have a probably simple Coq question. Anyone care to take a look?
22:27:56 <NihilistDandy> applicativ: I have't been able to get it to work, yet. It keeps whining about some kind of issue with an existing cabal-dev, which is just wrong
22:28:14 <tgeeky> ski: he's lost his identit-e!
22:28:39 <applicativ> NihilistDandy: hm, nothing about cabal-dev here, but so far my 'project' is unusually pathetic
22:28:51 <carter> applicativ NihilistDandy  just use cabal head
22:28:53 <carter> well
22:28:54 <NihilistDandy> scottj: I would use vimperator if pentadactyl weren't better
22:28:58 <carter> cabal-install  head
22:29:02 <applicativ> carter: that's what i'm doing
22:29:04 <carter> oh
22:29:06 <NihilistDandy> carter: I did.
22:29:13 <carter> did you update to current head as of today?
22:29:19 <carter> had a bug that was fixed in the past 2 days
22:29:25 <carter> that was breaking sandboxing
22:29:28 <applicativ> somebody was trying to install it earlier, so I did it to prove how easy it was ... or something like that
22:29:35 <NihilistDandy> Might have been from early this morning. I'll pull and give it a shot
22:29:46 <applicativ> i used head as of 45 min ago
22:29:55 <NihilistDandy> Though cabal 1.16 is proving quite nice
22:29:59 <carter> applicativ ah
22:30:02 <carter> well
22:30:16 <NihilistDandy> I was mainly using it in between platform versions since I moved to 7.6.3
22:30:21 <carter> NihilistDandy what problem were you hitting / did you file a bug report with a repro?
22:30:29 <applicativ> it built my 'project' with the github version of text, and permitted 'cabal sandbox run'
22:30:39 <applicativ> or was it cabal run
22:30:43 <lispy> carter: did you get my lambdabot message earlier?
22:30:50 <carter> lispy recursive make ?
22:30:55 <lispy> carter: ya
22:31:04 <carter> just opened link now
22:31:28 <lispy> carter: I don't have any good examples for you, but I've been meaning to dissect a template I have at work on my blog.
22:31:34 <carter> ah
22:31:36 <carter> cool
22:31:41 <lispy> one of my co-workers wrote it
22:31:43 <lambdabot> Here I am, brain the size of a planet, and they make me deliver messages.
22:32:05 <carter> random comments from lambda bot
22:32:06 <lispy> lambdabot: how else will we fuel the improbability drive?
22:32:09 <carter> oh
22:32:14 <carter> oh yeah hitch hickers
22:32:17 <applicativ> my hello world is very advanced because it uses strict Text
22:32:17 <carter> hikers
22:33:06 <applicativ> why did lambdabot say that?
22:33:53 <ski> she felt bored ?
22:34:15 <Pseudonym> Presumably.
22:35:29 * applicativ is worried about how neurons keep up with each other on a planetary scale
22:36:06 <Pseudonym> The speed of light is fairly quick, even on a planetary scale.
22:36:17 * carter applicativ : simple , neutrino lasers
22:36:20 <carter> applicativ : simple , neutrino lasers
22:38:55 <tabemann> the problem is, how do  you make a laser that fires neutrinos, considering they are pretty damn hard to confine with *anything*
22:39:25 <external-reality>   lifM $ mconcat $ m >>= thingamagig $ this . that <$> fromMaybe <-> (a ((b c) d) $ Hello <*> Stringify "goodBye"
22:39:56 <carter> tabemann magic butter
22:39:59 <carter> done
22:41:28 <tabemann> welp... implementing a wrapper multiDrawElements :: Primitive -> [[Int]] -> IO () was not fun...
22:42:23 <tabemann> it wouldn't been easier to just implement that as multiDrawElements primitive = drawElements primitive . concat ... but then it wouldn't've used glMultiDrawElements
22:43:09 <tabemann> it would've*
22:46:13 <carter> lispy reading that doc is making me more convinced i want to just figure out how to use shake instead
22:46:58 <lispy> carter: if you figure it out, please teach me :)
22:47:03 <carter> will do
22:47:08 <lispy> I've read enough about shake and I got it working for a trivial example
22:47:16 <lispy> And then stopped playing with it and forget everything
22:47:40 <carter> lispy basically i'm seeing a weird cousin of autoconf and m4 and shell in make
22:48:05 <NihilistDandy> I really like the idea of shake, I just don't need anything makelike often enough
22:48:17 <johnw> NihilistDandy: I'm in the same boat!
22:48:18 <carter> NihilistDandy i've some crazy ass stuff i'm working on
22:48:22 <johnw> I'm in search of a nail
22:49:12 <carter> johnw : getting my open stuff to build on your  fpcomplete vms is the nail if I wind up using shake for some of the stuff i need to do
22:49:41 <carter> well
22:49:42 <carter> some of it
22:50:25 <carter> johnw for reasons, I can't let cabal be my c build driver
22:50:31 <carter> because i'tll fuck up on mac
22:50:35 <carter> as i've been ranting about for a while :)
22:51:28 <johnw> really?  I'm developing on Mac
22:51:55 <carter> gcc + as on mac are old
22:51:59 <carter> and don't support nice things
22:52:01 <carter> like avx
22:52:15 <carter> or as of next week, avx2
22:52:18 <johnw> gcc isn't the default compiler on Mac anymore
22:52:19 <carter> or bmi2
22:52:25 <carter> johnw it is for cabal :(
22:52:29 <carter> its hard coded in
22:52:49 <carter> and clang needs some work before its the rigth default
22:52:58 <carter> well, ghc <-> clang interaction
22:53:31 <carter> johnw edit your ghc settings file (/usr/local/lib/ghcversionnumber/settings)
22:53:38 <carter> to have clang rather than gcc
22:53:44 <johnw> ah, thanks
22:53:52 <carter> and then things won't build :)
22:53:57 <carter> but try it as an experimetn
22:53:58 <carter> to see
22:54:36 <carter> johnw haskell paltform install?
22:54:43 <carter> lemme dig up the path you need to play wiht this
22:55:09 <NihilistDandy> /Library/Haskell/something/something
22:55:16 <carter>   /Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/lib/ghc-7.6.3/
22:55:21 <johnw> carter: no HP
22:55:25 <johnw> and I'm using 7.4.2
22:55:44 <carter> johnw so /usr/local/lib/ghc-7.4.2/settings ?
22:55:49 <NihilistDandy> carter: What issues have you had with cabal? I haven't run into anything that I've noticed
22:56:03 <carter> NihilistDandy thats cause you're not writing sse42/avx only codes :)
22:56:04 <johnw> i think: /usr/local/opt/ghc/lib
22:56:08 <carter> johnw ok
22:56:10 <carter> same idea
22:56:20 <NihilistDandy> I suppose that's true
22:56:33 <carter> NihilistDandy i'm writing c codes that have no fall back if those aren't enabled
22:56:41 <NihilistDandy> You can brew install new gccs, though
22:56:49 <carter> NihilistDandy that doesn't solve the assembler problem :)
22:56:54 <carter> the assembler
22:56:58 <carter> doesnt' suport them either
22:57:09 <carter> NihilistDandy well
22:57:12 <lispy> which assemblers support them?
22:57:13 <carter> doesn't support the avx version
22:57:19 <carter> lispy not mac
22:57:24 <lispy> only ones provided by apple?
22:57:28 <NihilistDandy> carter: What doesn't support the avx version
22:57:29 <NihilistDandy> ?
22:57:40 <carter> the as (gnu assembler) that apple provides
22:57:41 <carter> for macs
22:57:43 <carter> doesn't support avx
22:57:55 <carter> because its OLD
22:58:01 <carter> clang works as an assembler
22:58:05 <lispy> and which one does? can you brew/macports install that one?
22:58:07 <carter> nope
22:58:15 <carter> lispy clang supports it
22:58:16 <carter> via llvm
22:58:30 <lispy> ah, so you need to use clang but cabal doesn't use clang?
22:58:31 <carter> but cna't override which c compiler or assembler in a cabal build
22:58:35 <carter> lispy yes
22:58:50 <lispy> is this the same problem Ralith had?
22:58:52 <carter> and theres no exposed hook to allow that with current cabal
22:58:54 <carter> no clue
22:59:09 <joelteon> so anyway, where does cabal get flags from
22:59:16 <carter> what flags?
22:59:20 <lispy> he use something like ghc-options to tell ghc to use a different linker command
22:59:22 <joelteon> if Flag(foo)
22:59:26 <carter> lispy you can't
22:59:47 <carter> lispy cabal doesn't pass the ghc-options when using ghc to build c codes :(
22:59:50 <lispy> joelteon: some are builtin (and mentioned in the cabal user guide), the rest have to be defined in the .cabal file
23:00:03 <joelteon> yeah, but how do you TOGGLE them
23:00:15 <carter> joelteon with ifs
23:00:17 <carter> and defaults
23:00:21 <carter> and command line args
23:00:28 <joelteon> yeah, on the command line, how do you toggle them
23:00:38 <lispy> -fFoo or -f-Foo
23:00:39 <carter> -fFLAGNAME
23:00:50 <joelteon> during which command
23:00:53 <lispy> -fFoo means Foo = True, -f-Foo means Foo = False
23:01:41 <carter> joelteon configure
23:01:44 <lispy> joelteon: I usually do it for install. I think the othre command that uses them is, configure?
23:01:48 <carter> yes
23:02:09 <carter> install or configure are the only ones that let you configure
23:02:32 <joelteon> okay
23:02:53 <joelteon> so say I define a flag debug that adds the CPP option -DDEVELOPMENT
23:03:13 <carter> joelteon you can have it default to true or false
23:03:26 <joelteon> and check #ifdef DEVELOPMENT in my Main.hs, and if it is defined, make a toplevel definition with an incorrect type
23:03:31 <joelteon> and that doesn't cause a type error, because I just tried it
23:03:42 <joelteon> with cabal configure -fdebug and dist/build/foo/foo
23:03:53 <joelteon> it's not hitting that code path
23:03:56 <carter> joelteon you need to cabal build between the two :)
23:04:00 <joelteon> i did
23:04:19 <joelteon> can cabal-dev handle cabal flags? I'm tempted to use it
23:04:20 <carter> joelteon cabal clean and try again
23:04:25 <carter> joelteon cabal dev is weird
23:04:34 <carter> use cabal-install head
23:04:38 <carter> its better
23:04:39 <carter> :)
23:04:51 <carter> joelteon try cabal clean then repeat the process
23:05:04 <joelteon> kay
23:05:19 <joelteon> that doesn't help
23:05:21 <joelteon> I'll try cabal install head
23:05:24 <joelteon> cabal-install HEAD, that is
23:05:36 <NihilistDandy> cabal-dev is pretty usable. Seems to handle most flags that I throw at it all right. Doesn't seem to respect some of the flags I set in the config, but that may be a bootstrapping issue
23:05:45 <carter> joelteon could you hpaste your cabal and main files?
23:06:04 <carter> because it could be something simple you're overlooking because its 2am
23:06:51 <joelteon> yeah, hang on
23:08:45 <joelteon> i'm gonna shower first though, don't forget me
23:09:54 <carter> joelteon i'll be logging off soon
23:09:57 <carter> its 2am man :)
23:14:26 <lispy> hodapp: I updated haray to push the opencl stuff. I also added an INSTALL.md with build instructions.
23:14:44 <lispy> @tell hodapp I updated haray to push the opencl stuff. I also added an INSTALL.md with build instructions.
23:14:44 <lambdabot> Consider it noted.
23:17:42 <Ralith> lispy: did carter solve his problem?
23:20:27 <lispy> Ralith: I don't think so
23:21:08 <lispy> Ralith: his case might be slightly different? Telling cabal to use clang as the assembler.
23:21:55 <lispy> weird, hackage is timing out from my travis-ci build
23:22:03 <lispy> but i can get there just fine in a browser
23:23:53 <Ralith> lispy: --ghc-options=-pgma=clang
23:25:51 <lispy> @tell carter  < Ralith> lispy: --ghc-options=-pgma=clang
23:25:51 <lambdabot> Consider it noted.
23:26:05 <lispy> Ralith: that goes on the cabal commandline?
23:26:46 <Sonarpulse> johnw?
23:26:58 <Ralith> lispy: yep
23:27:04 <Sonarpulse> did other stuff for a while, but back at trying to get my FFI to build
23:27:10 <lispy> oh wow. It's late
23:27:13 <lispy> Ralith: thanks!
23:27:31 <Sonarpulse> did some thinking, I figure with your system, I only need to run the tool for headers I actually want to use
23:32:32 <Sonarpulse> lispy: is there anything to generate hsc?
23:32:39 <Sonarpulse> even if manual adjustment is still nessisary?
23:32:59 <lispy> Sonarpulse: I wrote my hsc files by hand
23:33:06 <lispy> you might ask johnw
23:33:08 <Sonarpulse> ah ok
23:33:11 * lispy -> bed
23:33:13 <lispy> good night!
23:33:15 <Sonarpulse> he seems to be afk
23:33:20 <Sonarpulse> thanks!
23:33:22 <Sonarpulse> good night
23:35:45 <NihilistDandy> @tell NihilistDandy carter  < Ralith> lispy: --ghc-options=-pgma=clang
23:35:45 <lambdabot> You can tell yourself!
23:35:57 <NihilistDandy> Aww, I was hoping for an easy reminder
23:37:17 <ski> i suppose you could try `/msg MemoServ send NihilistDandy ...'
23:38:43 <latermuse> can anyone recommend a library for binding cassandra into haskell?
23:38:43 <NihilistDandy> Yeah, I guess. I just threw it in a note. By the time I remember it, I'll know whether or not it fixes anything
23:38:52 <NihilistDandy> The best sort of todo list is the one that finishes itself
23:40:06 <adinapoli> latermuse: I think Soostone use this in production: https://github.com/ozataman/cassy
23:40:18 <latermuse> thanks a ton
23:54:13 <Sonarpulse> johnw: I at least confirmed it's failing on the gcc step, not haskell step of the hsc
