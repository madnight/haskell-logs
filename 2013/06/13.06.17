00:10:57 <b6> i'm really confused about this instance of Storable, especially the poke function. http://hpaste.org/90037
00:12:01 <b6> surely i shouldn't really do those withArray's there?
00:13:05 <Sonarpulse> no, you don't want to convert list to array that much I would guess
00:13:48 <Cale> b6: You could always use StorableArrays on the Haskell side of the representation.
00:14:34 <Sonarpulse> so the point of hsc is to do the storrable for you?
00:14:45 <Cale> I'm confused about how your lambdas got doubled
00:14:59 <b6> Cale: seems like an hpaste bug.
00:15:09 <b6> my actual code is ok.
00:15:17 <Cale> huh
00:15:37 <b6> in haskell land, i was planning to use [Int] for those ushort arrays.
00:15:40 <Cale> yeah, what...
00:16:02 <Cale> I'll have to ask chrisdone about that at some point :)
00:16:51 <Cale> Well, it can be perfectly all right having a Storable instance which does lots of marshalling work
00:17:36 <b6> i guess i don't understand where the memory should get allocated. this looks like a crashbug or memory leak waiting to happen.
00:18:05 <b6> it looks like it would allocate space and copy the arrays, and poke them into the struct, and then they'd instantly be eligible for freeing.
00:18:11 <Cale> Oh, well, yeah, rather than withArray, you'd want to mallocArray
00:18:42 <b6> ok, but then who frees? would i even have the pointers at that point?
00:19:27 <Cale> Well, you'd get pointers and put them into the structure, and then... well, whose responsibility is it normally? :)
00:19:51 <b6> ok. i'm still confused, but i think i can't have these allocations in the Storable instance.
00:20:02 <b6> i'll try doing that stuff where the call to the C function happens.
00:20:11 <Cale> Maybe what you really want to do is to dereference the pointers
00:20:18 <Cale> and then modify the memory at those locations
00:20:29 <Cale> -then
00:20:41 <Cale> pokeArray :: Storable a => Ptr a -> [a] -> IO ()
00:21:06 <Cale> ^^ this is quite dangerous with an unbounded list! :)
00:21:43 <Saizan> GLFWgammaramp has pointer fields, so whoever frees one of those has the resposibility to free the pointers inside first, i'd say
00:22:19 * Saizan not a C coder though
00:26:34 <yitz> b6: i'm pretty sure the Storable instance is not suppose to talk about allocation. it talks about how to store this type in memory, when already given memory of the size and alignment you specify.
00:27:22 <KoF__> Bah. Finally got the IO chapter of Real World Haskell. I immediately dislike the <-, because I want to be able to use :t on it and can't. <.<
00:27:29 <b6> yitz: ok. i'll try from the perspective of the function doing the c call it and will probably make sense.
00:28:42 <ekipan> desugar it then: do {x <- y; z} is y >>= \x -> z
00:29:01 <ekipan> you wouldn't ask for the type of the arrow in the lambda syntax, would you? It's just syntax.
00:29:23 <yitz> b6: yeah sounds better.
00:29:53 <b6> thanks, everyone.
00:36:00 <Ralith> Is it reasonable to return an IO action from ST as a means by which to interleave IO and ST operations?
00:36:39 <mauke> Ralith: if it does what you want, why not?
00:38:06 <Ralith> mauke: I'm a little fuzzy on the execution semantics. Lemme describe my problem more specifically
00:38:30 <Ralith> I have a binding for a C library which has a 'context' object that must be manually allocated and freed
00:38:55 <Ralith> I have an otensibly-safe pure interface to it built on ST
00:39:21 <Ralith> however, certain components of the library do IO, and I want to use those, too
00:39:51 <Ralith> the ST interface disposes its context after the ST computation completes
00:40:09 <Ralith> the IO operations are only legal while the context exists
00:40:24 <Kinnison> Can those IO operations alter the context?
00:40:42 <Ralith> define 'alter'
00:40:58 <Ralith> well, no regardless
00:41:11 <Ralith> the IO stuff is strictly on the order of "write this object to disk"
00:41:15 <mauke> Ralith: then you can't really do that
00:41:24 <mauke> you need to runST to get the IO object out
00:41:40 <Ralith> indeed
00:41:50 <Ralith> so what might be a better approach?
00:42:50 <Lethalman> hi, is it possible to enforce e.g. monoid laws with dependant types?
00:43:47 <Ralith> Lethalman: yes.
00:44:07 <Lethalman> Ralith, can you point me to a doc? can't find anything, I probably search for the wrong keywords
00:45:32 <Ralith> Lethalman: perhaps you should ask in the channel of whatever DT language you are using?
00:45:36 <Ralith> mauke: nevermind, I'm silly
00:45:55 <Ralith> I can just defer the context disposal to a finalizer
00:46:19 <Lethalman> Ralith, mh, in reality I was only curious not really involved in any language
00:46:53 <Lethalman> in haskell it's not really possible to do this?
00:47:03 <Ralith> haskell is not dependently typed
00:47:25 <Kinnison> Ralith: Use a state transformer and put IO inside it?
00:48:29 <Ralith> Kinnison: the point is to enable most library operations to be executed by pure code.
00:48:47 <Ralith> but I have a solution, as mentioned above
00:49:08 <Ralith> new problem!
00:49:20 <Lethalman> Ralith, I know, but is it possible to simulate them somehow?
00:49:32 <Lethalman> I've seen something with Nats but nothing more
00:49:47 <Ralith> Lethalman: if you can simulate full dependent types, you have full dependent types
00:51:09 <Ralith> ghc-built programs on mingw/win32 using aforementioned C bindings are giving me "Segmentation fault/access violation in generated code".
00:51:13 <Ralith> why might this be?
00:51:38 <Lethalman> Ralith, for example I've read this without understanding anything, but isn't this some sort of program using dependant types? http://blog.piechotka.com.pl/2013/04/10/statically-typed-red-black-trees/
00:51:55 <Lethalman> that is, to ensure certain properties based on the height of the tree or such
00:52:02 <Lethalman> at the type level
00:52:31 <kosc> Hello
00:52:32 <kosc> func 0 = 2
00:52:33 <kosc> func x = ((x/(x - 1))*(x/(x + 1)))*func(x-2)
00:52:49 <kosc> How can I rewrite it with tail recursion?
00:53:08 <mauke> kosc: introduce an accumulator
01:08:14 <adnap> I have a -> b, f (b -> b) (where f is an Applicative), and I want f (a -> b), where (b -> b) has been applied to the result of (a -> b). I can
01:08:21 <adnap> I can't figure out how to write this
01:10:02 <Kinnison> @djinn (a -> b) -> f (b -> b) -> f (a -> b)
01:10:02 <lambdabot> -- f cannot be realized.
01:10:12 <Kinnison> @djinn Applicative f => (a -> b) -> f (b -> b) -> f (a -> b)
01:10:12 <lambdabot> Error: Class not found: Applicative
01:10:18 <Kinnison> boo :-(
01:10:19 <Saizan> ?ty \f -> fmap (.f)
01:10:20 <lambdabot> Functor f => (a -> b) -> f (b -> c) -> f (a -> c)
01:10:30 <Saizan> adnap: ^^^
01:10:47 <Lethalman> \o/
01:10:47 <Kinnison> Saizan: I never think of dot in that way, I really should learn about the behaviours of partially applying it
01:11:08 <Lethalman> :t \f -> (.f)
01:11:09 <lambdabot> (a -> b) -> (b -> c) -> a -> c
01:11:32 <Saizan> ?ty flip (.)
01:11:33 <lambdabot> (a -> b) -> (b -> c) -> a -> c
01:11:47 <mauke> :t \f -> fmap (\g -> \x -> g (f x))
01:11:48 <lambdabot> Functor f => (t2 -> t1) -> f (t1 -> t) -> f (t2 -> t)
01:12:23 <adnap> Saizan: Can I get rid of f?
01:12:50 <Saizan> yes, it's not pretty though: fmap . flip (.)
01:14:50 * hackagebot conduit-resumablesink 0.1.1 - Allows conduit to resume sinks to feed multiple sources into it.  http://hackage.haskell.org/package/conduit-resumablesink-0.1.1 (AndrewMiller)
01:15:28 <mauke> @pl \f -> fmap (\g -> \x -> g (f x))
01:15:28 <lambdabot> fmap . flip (.)
01:15:36 <mauke> oh, pl is working again?
01:16:28 <t7> there is someone doing them by hand
01:17:36 <Lethalman> t7, lol
01:17:44 <Lethalman> hidden inside a box
01:19:19 <Nisstyre> What can I use an old copy of RWH for?
01:19:32 <mauke> smashing bugs
01:19:44 <Nisstyre> mauke: I was just about to use it to squish a spider actually
01:19:46 <Nisstyre> but it got away
01:24:32 <osfameron> it's a bit thick to be manoeuverable enough for spider squishing
01:24:43 <osfameron> you want a lighter book like Javascript: The Good Parts
01:27:47 <Nisstyre> osfameron: I could use it as a laptop rest though
01:30:17 <DarkFox> How does one get ghc to compile without needing over a gig of ram?
01:30:27 <DarkFox> For something that seems to want more
01:30:34 <Ralith> plenty of swap?
01:32:31 <DarkFox> Ralith: Nope
01:33:10 * DarkFox wass thinking about adding swap but SSD /= good for swap (well swap not good for the SSD)
01:33:42 <DarkFox> Ralith: No way to get ghc to say chunk it's work ?
01:33:56 <shachaf> Why do you have an SSD but only 1GB of RAM?
01:34:28 <DarkFox> shachaf: Friends VM
01:35:06 <DarkFox> shachaf: First time I've ever had this problem :P
01:35:18 <mauke> in my experience the linker is the bottleneck
01:35:31 <thoughtpolice> if you enable swap, it should be possible to build. normally, the linker is what hurts the most on low-memory systems
01:35:32 <DarkFox> Hmm
01:37:34 * DarkFox tries with another 600MB
01:38:45 <DarkFox> Yay
01:39:53 <tero-> can gold linker be used with ghc already?
01:46:40 <tero-> apparently not out of the box. I get "/usr/bin/ld: --hash-size=31: unknown option"
01:52:25 <yitz> tero-: yes it works. http://hackage.haskell.org/trac/ghc/ticket/4862
01:52:47 <yitz> tero-: there are some minor settings issues that you need to work around as per that ticket
01:54:33 <Lethalman> wouldn't a jit for haskell recognize fusion more efficiently, even among library calls?
01:54:39 <Lethalman> was wondering
01:57:15 <Lethalman> I've hard sometimes a trace jit compiler for haskell, is there something like that in ghc already or...
01:57:22 <tero-> yitz: okay, thanks
02:04:52 * hackagebot unique-logic 0.2 - Solve simple simultaneous equations  http://hackage.haskell.org/package/unique-logic-0.2 (HenningThielemann)
02:04:54 * hackagebot unique-logic 0.3 - Solve simple simultaneous equations  http://hackage.haskell.org/package/unique-logic-0.3 (HenningThielemann)
02:09:31 <yitz> Lethalman: one of the attratctions of developing the llvm backend for ghc was the potential of creating a jit.
02:09:52 * hackagebot unique-logic-tf 0.4 - Solve simple simultaneous equations  http://hackage.haskell.org/package/unique-logic-tf-0.4 (HenningThielemann)
02:10:19 <yitz> Lethalman: however, that has not been done yet afaik. just the llvm low-level code generation backend was a huge amount of work.
02:11:00 <yitz> Lethalman: also - i don't think such a jit would exactly give you "fusion" in the sense that we usually use that term for ghc.
02:11:46 <yitz> Lethalman: our fusion comes from the firing of high-level simplification rules.
02:12:50 <yitz> Lethalman: in a jit, the functions that are fused would be long gone, after many layers of compilation and optimization.
02:14:02 <yitz> Lethalman: here is the paper about the llvm backend: https://davidterei.com/downloads/papers/terei:2010:llvm.pdf
02:14:52 * hackagebot unique-logic-tf 0.4.0.1 - Solve simple simultaneous equations  http://hackage.haskell.org/package/unique-logic-tf-0.4.0.1 (HenningThielemann)
02:19:03 <yitz> Lethalman: when compiling a typical non-trivial haskell program, the linking step often takes a long time and uses a huge amount of memory
02:21:09 <yitz> Lethalman: so while you are right that there would likely be some nice new lower-level optimizations available if linking were postponed to run time, the whole thing would probably have to work very differently than it does for the conventional jit-based languages you are probably thinking of.
02:21:23 <Lethalman> mh
02:22:00 <yitz> Lethalman: all in all, it sounds like a great research project. go for it!
02:22:02 <Lethalman> yitz, you mean that, whatever that jit could do on doing fusion, there's no much gain because there's already the information at the type level when statically compiling?
02:22:45 <Lethalman> that is, it's not like an untyped language where you have to discover loops to be fused... you already have the information at the type level at compile time
02:23:46 <hoelzro> so I was reading this article at http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html, and it mentions a map lookup function with the signature lookup :: (Monad m, Ord k) => k -> Map k a -> m a
02:24:09 <hoelzro> I looked in the haskell documentation, and I could only find a Maybe-specific version; has the more general one been removed?
02:24:15 <hoelzro> or is this article inaccurate?
02:24:21 <yitz> Lethalman: actually the current fusion doesn't really use types very much. it's more of a superficial matching of function names to fire rewrite rules.
02:25:00 <mauke> hoelzro: the former
02:25:12 <Lethalman> yitz, ah so it's something predefined... if I define my own function using only recursion it doesn't get fused?
02:25:14 <hoelzro> bummer =(
02:25:38 <mauke> hoelzro: why?
02:25:39 <yitz> Lethalman: it does if you also define rewrite rules for it :)
02:25:54 <hoelzro> mauke: I guess I could try my hand at implementing it myself
02:26:10 <yitz> Lethalman: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/rewrite-rules.html
02:26:38 <mauke> :t maybe (fail "key not found") return
02:26:39 <lambdabot> Monad m => Maybe a -> m a
02:27:40 <shachaf> I should finish benchmarking alterF and get it into containers.
02:27:46 <shachaf> And also come up with a good name for it.
02:27:54 <yitz> shachaf: what does it do?
02:28:12 <hoelzro> I need to improve my Haskell =/
02:28:22 <mauke> > fix fail
02:28:22 <shachaf> (Ord k, Functor f) => k -> (Maybe a -> f (Maybe a)) -> Map k a -> f (Map k a)
02:28:23 <lambdabot>   ""
02:28:39 <shachaf> It's a lens Lens for a value at a particular key.
02:28:53 <yitz> shachaf: got it. cool.
02:29:26 <shachaf> With good inlining you can implement half of Data.Map with it and get almost the same performances.
02:29:40 <shachaf> In some cases I was getting better performance but I think that might be a benchmarking fluke.
02:29:50 <yitz> shachaf: that sounds kind of applicative. it's a little surprising that you're able to do that at the functor level.
02:29:53 <merijn> hoelzro: The problem with that type signature is what it should do if the key isn't found...
02:29:59 <shachaf> yitz: Functor gives you stronger guarantees.
02:30:07 <Philonous> Is there a guideline for naming packages? For example, I want to release a STUN library, but simply calling it "stun" would be assuming, wouldn't it?
02:30:12 <merijn> hoelzro: Maybe let's you signal absense using Nothing, not all monads can do that
02:30:28 <shachaf> yitz: In particular it means that alterF has to use the (Maybe a -> f (Maybe a)) function, because there's no other way it can get an (f anything).
02:30:31 <hoelzro> I see
02:30:41 <shachaf> yitz: And it means that it has to use it exactly once, because it can't combine values with <*>
02:31:50 <shachaf> And you can write update, insert, lookup, delete, etc. with it.
02:32:11 <yitz> @type T.traverse -- shachaf
02:32:12 <lambdabot> (Applicative f, T.Traversable t) => (a -> f b) -> t a -> f (t b)
02:32:28 <shachaf> yitz: Right, this type is a lot like traverse.
02:33:12 <shachaf> With an Applicative, it'll give you zero or more values, since it has the ability to use pure (for 0) and (<*>) (for more than one). With Functor it can't do anything like that.
02:34:00 <shachaf> This is pretty much the whole idea of lens.
02:34:47 <shachaf> @let view l s = getConst (l Const s)
02:34:48 <lambdabot>  Defined.
02:35:25 <shachaf> @let _2 :: Functor f => (a -> f b) -> (e,a) -> f (e,b); _2 (x,y) = (,) x <$> f y
02:35:26 <lambdabot>  .L.hs:131:4:
02:35:26 <lambdabot>      Couldn't match expected type `a -> f b' with actual type `...
02:35:35 <Lethalman> yitz, ah, I thought it was something more fancy theoretical that sorted out the stuff to do automatically
02:35:45 <shachaf> @let _2 :: Functor f => (a -> f b) -> (e,a) -> f (e,b); _2 f (x,y) = (,) x <$> f y
02:35:45 <lambdabot>  Defined.
02:36:04 <shachaf> @let both :: Applicative f => (a -> f b) -> (a,a) -> f (b,b); both f (x,y) = (,) <$> f x <*> f y
02:36:05 <lambdabot>  Defined.
02:36:29 <shachaf> _2 uses f once and both uses it twice. So both needs an Applicative to combine them.
02:36:31 <merijn> hoelzro: His examples only seem to use the Maybe result for lookup anyway
02:36:40 <shachaf> @let view l s = getConst (l Const s)
02:36:41 <lambdabot>  .L.hs:138:1: Warning:
02:36:41 <lambdabot>      Pattern match(es) are overlapped
02:36:41 <lambdabot>      In an equat...
02:36:47 <shachaf> Oops.
02:36:54 <hoelzro> right, but it should work for Either as well, yes?
02:36:58 <shachaf> > view _2 ("hello","there")
02:37:02 <lambdabot>   mueval-core: Time limit exceeded
02:37:11 <shachaf> > view _2 ("hello","there")
02:37:15 <lambdabot>   mueval-core: Time limit exceeded
02:37:19 <shachaf> Maybe it doesn't like overlapping patterns.
02:37:25 <shachaf> @let view' l s = getConst (l Const s)
02:37:26 <lambdabot>  Defined.
02:37:30 <shachaf> > view' _2 ("hello","there")
02:37:33 <lambdabot>   "there"
02:37:39 <shachaf> > view' both ("hello","there")
02:37:42 <lambdabot>   "hellothere"
02:37:52 <shachaf> Maybe no one is listening at this point. :-)
02:38:37 <yitz> i'm still here shachaf :)
02:38:45 <merijn> hoelzro: Oh sure, you could write a lookup that returns Either, but it's a bit hard to decide what the Left side should be in that type
02:38:55 <hoelzro> ah, I suppose spo
02:38:56 <hoelzro> *so
02:39:01 <shachaf> If you want to talk more about lens #haskell-lens is probably a better place.
02:39:30 <merijn> hoelzro: You could write "lookup :: Ord k => e -> k -> Map k a -> Either e a", but you can easily implement that in terms of the Maybe lookup
02:39:30 <shachaf> But that's the general idea. A whole bunch of functions with the shape (a -> f b) -> s -> f t, and a whole bunch of functions for doing things with them.
02:39:53 <shachaf> :t view both -- it's fun how this gets a Monoid constraint but view _2 doesn't
02:39:53 <lambdabot> Monoid a => (a, a) -> a
02:40:10 <yitz> shachaf: yes i see.
02:40:25 <merijn> hoelzro: Which is why the current lookup is as it is, it is easy to implement/extend it to all the other examples with almost no effort
02:40:35 <yitz> shachaf: the lens library also has both though ;)
02:40:41 <hoelzro> I see
02:40:51 <hoelzro> I think I just need to play with it more =)
02:40:56 <shachaf> yitz: Right, lens's both is this both.
02:41:05 <shachaf> lambdabot just doesn't import it.
02:41:11 <merijn> :t let lookupE x k = maybe (Left e) . Right . lookup k
02:41:12 <lambdabot> <no location info>:
02:41:12 <lambdabot>     not an expression: `let lookupE x k = maybe (Left e) . Right . lookup k'
02:41:14 <merijn> eh
02:41:19 <merijn> :t let lookupE x k = maybe (Left e) . Right . lookup k in lookupE
02:41:20 <lambdabot>     Couldn't match type `Either a1 (Maybe b1)'
02:41:20 <lambdabot>                   with `a0 -> Either Expr b0'
02:41:20 <lambdabot>     Expected type: Maybe b1 -> a0 -> Either Expr b0
02:41:34 <shachaf> merijn: e
02:41:35 <merijn> hmmm, silly me
02:41:53 <merijn> :t let lookupE x k = maybe (Left x) . Right $ lookup k in lookupE
02:41:54 <lambdabot>     Couldn't match type `Either a2 ([(a3, b1)] -> Maybe b1)'
02:41:55 <lambdabot>                   with `a0 -> Either a1 b0'
02:41:57 <lambdabot>     Expected type: ([(a3, b1)] -> Maybe b1) -> a0 -> Either a1 b0
02:42:03 <merijn> oh, wrong lookup too
02:42:14 <merijn> shachaf: I screwed up the composition too :p
02:42:24 <yitz> hoelzro: the point is that really you don't want Monad for that. You want something called MonanPlus. But Maybe is in certain sense the univeral example of MonadPlus, so it is simplest just to use that and forget the Monad thing.
02:42:35 <hoelzro> o_O
02:43:11 <shachaf> Or maybe you want MonadZero. Or something simpler.
02:44:03 <yitz> right MonadZero. that's another old story about why that disappeared. but never mind, no worries, just use Maybe. :)
02:44:34 <shachaf> how i learned to stop worrying and love the Maybe
02:44:40 <yitz> hehe
02:45:28 <Philonous> shachaf:  Are you implying that Maybe is a destructive war device that brings about a nuclear winter?
02:46:16 <shachaf> You can't spell "nuclear winter" without "winner".
02:47:42 <merijn> @quote defun
02:47:42 <lambdabot> defun says: [defun] conal: you seem knowledgable on the subject of FRP ... [conal] defun: btw, i invented frp.
02:47:46 <merijn> blah
02:47:51 <merijn> @quote without.defun
02:47:52 <lambdabot> djahandarie says: <Veinor> can't spell -funbox without fun!  <djahandarie> Veinor, can't write LISP without defun :-(
02:48:17 <shachaf> @quote funsafe
02:48:17 <lambdabot> shachaf says: You can't spell "-funsafe" without "fun" and "safe".
02:48:41 <merijn> shachaf: Narcissist
02:49:17 <shachaf> @quote merijn
02:49:17 <lambdabot> merijn says: after a week you can delete 80% of your code and replace it with whatever edwardk wrote that day ;-)
02:50:04 <shachaf> merijn: It's not my fault I'm so great.
02:50:08 <merijn> Unless PolyKinds breaks contravariant and all the rest of his code so you can't continue your experiments :(
02:50:36 <shachaf> PolyKinds breaks contravariant?
02:52:07 <merijn> shachaf: Yes
02:52:14 <merijn> Actually
02:52:23 <merijn> It might be a screwed up CPP macro
02:52:28 <merijn> I haven't tested that yet
02:52:33 <merijn> Good point, brb
02:55:19 <merijn> whoo
02:55:31 <merijn> I'm going to be the king of 1 and 2 character haskell bugfixes!
02:55:52 <typoclass> merijn: heh :) so it was your macro?
02:56:09 <merijn> typoclass: Not my macro, his macro
02:56:18 <typoclass> oh i see
02:57:33 <merijn> btw, can someone provide some git help? I wanna create a quick patch for ghc, but I'm to confused by ghc's git layout to do it
02:58:56 <merijn> I have a change under libraries/Cabal/Distribution, when I run "git status" in the top level ghc dir I only see "#       modified:   libraries/Cabal (modified content" and get useless output for "git diff"
02:59:24 <merijn> But if I go to libraries/Cabal I do see my change. Should I generate the patch relative to libraries/Cabal or should I do something else?
02:59:55 * hackagebot stunclient 0.1.0.0 - RFC 5389: Session Traversal Utilities for NAT (STUN) client  http://hackage.haskell.org/package/stunclient-0.1.0.0 (PhilippBalzarek)
03:05:43 <shachaf> merijn: You should've asked that question in here too!
03:06:19 <merijn> bummer
03:06:29 <shachaf> merijn: libraries/Cabal is a submodule -- it's its own git repository.
03:06:31 <merijn> It seems __GLASGOW_HASKELL__ is 707 for all snapshots
03:06:57 <merijn> So I'm not sure whether my patch breaks contravariant for older 7.7 snapshots, otoh is anyone likely to care?
03:07:17 <shachaf> Probably not...
03:07:40 <shachaf> There are other things than __GLASGOW_HASKELL__ that you could test, like package versions.
03:08:50 <merijn> shachaf: The bug is this
03:08:51 * yitz wonders if one of merijn's 2-character fixes was adding {- at the beginning of the module
03:09:09 <merijn> https://github.com/merijn/contravariant/commit/afbafc7302ecb01c5b6d1a0b533aa5af02efcfeb
03:09:23 <merijn> yitz: No, adding a couple of = to turn > and < into >= and <=
03:10:07 <merijn> Latest 7.7 lacks Typeable1, and edwardk's macro's check for versions newer than 7.7
03:10:14 <frerich> Does hpaste work for anybody?
03:10:23 <merijn> So contravariant doesn't build for latest 7.7
03:10:31 <supki> merijn: yeah, it should be >=
03:10:38 <merijn> frerich: not for me
03:10:38 <yitz> frerich: oh not again
03:11:00 <typoclass> frerich: takes forever for me
03:11:16 <yitz> http://www.downforeveryoneorjustme.com/http://hpaste.org/
03:12:01 <merijn> yitz: My other 2 character fix was adding ./ to a string in cabal :p
03:12:09 <merijn> I'm gonna repeat that one for ghc :p
03:12:39 <frerich> Ok, in that case I hope you can forgive me for using another paste service. I have asmall Haskell tool which does some quick and dirty command line parsing like this: http://pastebin.com/C1RTHmPF <-- can anybody suggest how to make that code shorter without obfuscating it?
03:12:44 <mauke> The paste C1RTHmPF has been copied to http://sprunge.us/BiJZ?haskell
03:12:53 <frerich> heh
03:13:22 <frerich> Actually, that sprunge paste looks much nicer.
03:13:25 <shachaf> merijn: I once spent quite a while tracking down a bug with a one-character fix.
03:13:34 <yitz> frerich: mauke doesn't like pastebin.
03:13:35 <shachaf> (The fix was to use < instead of <=.)
03:13:38 <Ralith> sprunge is very nice
03:13:58 <frerich> yitz: Neither do I
03:14:03 <mauke> frerich: case args of [portStr, cert, pw] ->
03:14:34 <frerich> mauke: Ah, good idea, that would avoid the length check
03:14:50 <shachaf> I,I case args of [readMaybe -> Just port, cert, pw] -> ...
03:14:50 <mauke> frerich: case readMaybe portStr of Just portNum | inRange (0, 0xffff) portNum ->
03:15:01 * hackagebot hakyll 4.3.1.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.3.1.0 (JasperVanDerJeugt)
03:15:44 <mauke> frerich: return $ case ...
03:16:10 <shachaf> Or case args of [portStr, cert, pw] | Just portNum <- readMaybe portStr, inRange (0, 0xffff) portNum -> ...
03:16:35 <merijn> Any good samaritans with a ghc checkout willing to dedicate their compile time to test a patch for me? :p
03:16:37 <typoclass> ... which requires PatternGuards iirc
03:16:46 <shachaf> PatternGuards are part of Haskell.
03:17:07 <mauke> shachaf: harder to do good error messages that way
03:17:14 <shachaf> mauke: True.
03:17:39 <yitz> use optparse-applicative
03:17:56 <shachaf> mauke: I was going to say you lose some detail with your method too, but it looks like those two errors are the same string.
03:18:17 <mauke> I checked :-)
03:18:47 <shachaf> The idea that you would not check did not even occur to me.
03:19:32 <typoclass> shachaf: you're right, it's turned on by default. thanks
03:20:09 <shachaf> Turned on by default in the Report.
03:21:26 <merijn> @tell elliott Good news, I update the autoindenting to be less annoying about dealing with empty lines *and* made the lining up with the = of data declarations optional! Just add "let g:HaskellFoldIndent_AlignDataDecl = 0" to your .vimrc
03:21:26 <lambdabot> Consider it noted.
03:23:16 <frerich> mauke, shachaf: thanks for your input, I believe I now incorporated all your suggestions (see the sprunge link which mauke's bot will post in response to me writing http://pastebin.com/U1LcGXZg ). The only thing which now bothers me about it is that I can't make up my mind where to wrap lines when hitting 80 columns. :-)
03:23:17 <mauke> The paste U1LcGXZg has been copied to http://sprunge.us/EBLV?haskell
03:24:08 <shachaf> You should put a space after inRange, just like any other function.
03:24:25 <frerich> Oh yeah that's just a typo.
03:24:31 <shachaf> And you should use something other than pastebin.com so mauke's poor bot doesn't have to go through all that trouble.
03:25:03 <frerich> I'd rather give some incentive to fix hpaste.org than to work around it. :)
03:25:17 <shachaf> Oh, hpaste.org is down?
03:25:18 <shachaf> OK then.
03:26:05 <shachaf> I wonder whether you could come up with a clever Conty trick for getting rid of all that nesting.
03:26:17 <shachaf> If only patterns were first-class.
03:26:27 <shachaf> You don't need Cont, just Either.
03:27:05 <magicman> @hackage first-class-patterns
03:27:06 <lambdabot> http://hackage.haskell.org/package/first-class-patterns
03:27:59 <shachaf> Something like do { (portStr, cert, pw) <- case args of { [a,b,c] -> Right (a,b,c); _ -> Left "blah" }; portNum <- case portStr of { ... }; ... }
03:28:03 <magicman> (not ideal, but but it's something)
03:28:06 <magicman> (-but)
03:28:12 <shachaf> It winds up being horribly ugly.
03:29:08 <shachaf> Any idea how to make that nice?
03:29:13 <frerich> another idea I had was to avoid 'readMaybe' in the first place but rather try whether I can use 'all(isDigit' in some good way.
03:30:57 <shachaf> That's not the same as readMaybe with Integer.
03:31:08 <frerich> Sure, but if it's good enough, that'll do.
03:33:02 <yitz> > read "001" :: Integer
03:33:04 <lambdabot>   1
03:36:25 <shachaf> > read " -0x05ef2   " :: Integer
03:36:26 <lambdabot>   -24306
03:44:52 <yitz> shachaf: it doesn't sound like frerich is very worried about -0x05ef2 not being a valid syntax for specifying a port number
03:45:39 <merijn> If I could program with arbitrary real world side effects I'd use "unsafeStabComputerUser" if someone attempted that
03:46:09 <frerich> One idea I just had: If I had a function 'f xs@[a,b,c] = Just xs; f _ = Nothing' then I could change 'case args of [portStr, cert, pw]' to 'case args of Just [portStr, cert, pw]'. The effect would be that the nested cases would both work on 'Maybe', so I could maybe use a monadic implementation
03:46:23 <frerich> And if the whole thing evaluates to Nothing, I just give a generic error message.
03:46:52 <magicman> [readMaybe -> Just (inRange (0,65535) -> True)), cert, pw] -> Right ...; [_,_,_] -> Left ...; _ -> Left ... -- because -XViewPatterns
03:47:04 <yitz> @remember merijn If I could program with arbitrary real world side effects I'd use "unsafeStabComputerUser" if someone attempted that
03:47:04 <lambdabot> It is stored.
03:47:05 <magicman> (also not nice)
03:47:25 <magicman> Oh, and a ) too much. Mneh.
03:47:27 <shachaf> magicman: You'll need an @ there for the port. But that can be improved.
03:47:43 <typoclass> frerich: not really sure what you're planning, but in general, i like specific error messages more than generic ones. (have you seen my message?)
03:47:49 <yitz> frerich: if a generic error message is good enough, you could forget all the case complexity and do the whole thing in one simple Maybe expression.
03:47:49 <shachaf> If you're willing to lose the different error messages, there are various other ways of simplifying it. I think I mentioned some above.
03:48:06 <yitz> like shachaf says
03:48:39 <frerich> Well I do like precise error messages better, but it would be interesting to see how short it can get if I would accept a generic error message anyway.
03:50:30 <shachaf> I think I mentioned a pretty compact way before but maybe you could improve it.
03:50:48 <shachaf> But optimizing this code for how short it is is probably not a good idea.
03:54:42 <magicman> @type maybe (Left "Hello") Right
03:54:43 <lambdabot> Maybe b -> Either [Char] b
03:55:27 <yitz> parseArgs = getArgs >>= maybe (Left "oops") Right . parse where {parse args = do { [port, cert, pw] <- args; portNum <- readMaybe port; guard $ inRange (0, 65535) portNum; return (portNum, cert, pw)}}
03:55:55 <yitz> oh well you also need a return in there
03:56:11 <shachaf> Perhaps what you need is fmap
03:56:35 <yitz> parseArgs = maybe (Left "oops") Right . parse <$> getArgs where {parse args = do { [port, cert, pw] <- args; portNum <- readMaybe port; guard $ inRange (0, 65535) portNum; return (portNum, cert, pw)}}
03:56:53 <magicman> Oh, it's definitely fmap parseArgs' -- parseArgs' :: [String] -> Either String ThatThing
03:56:59 <magicman> (err, on getArgs)
03:58:23 <magicman> parse [port,cert,pw] -> maybe (Left "msg1") Right $ do {portNum <- readMaybe port; guard $ inRange (0,65535); return (portNum, cert, pw)}; parse _ -> Left "msg2";
03:59:08 <yitz> magicman: s/->/=/
03:59:10 <magicman> Basically what yitz was doing, but with different error messages.
03:59:16 <magicman> Oh, right v_v
03:59:30 <magicman> Modulo syntax errors :p
04:05:54 <Moggle_> @src iterate
04:05:55 <lambdabot> iterate f x =  x : iterate f (f x)
04:06:48 <shachaf> iterate f x = pure x <|> f (iterate f x) -- sounds familiar?!
04:09:02 * Lethalman can't get the head around <|>
04:09:28 <Tinned_Tuna> @src <|>
04:09:28 <lambdabot> Source not found. Sorry.
04:10:19 <ramses_> Tinned_Tuna: that's a type class function
04:10:32 <Philonous> @type (<|>)
04:10:32 <lambdabot> Alternative f => f a -> f a -> f a
04:13:36 <kmels> hello, how can I compose f and g (f . g) when g takes two arguments?
04:13:58 <shachaf> \x -> f . g x
04:14:14 <shachaf> You can rewrite it to something like (f .) . g but that'll just make your code confusing.
04:17:07 <kmels> shachaf, right! that is definitely better than what I had
04:17:53 <Philonous> > let (.:) = (.).(.) in \f g -> f .: g
04:17:55 <merijn> libraries/Cabal in the ghc source tree is just a clone of cabal (i.e. github.com/haskell/cabal), right?
04:17:55 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a1)
04:17:55 <lambdabot>    arising from a use ...
04:18:00 <shachaf> Remember, (f . g) is just (\x -> f (g x))
04:18:03 <Philonous> @type let (.:) = (.).(.) in \f g -> f .: g
04:18:05 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
04:18:22 <shachaf> So start out by writing out what you want in long form: (\x y -> f (g x y))
04:18:29 <shachaf> Then you can start reducing it.
04:18:38 <shachaf> I don't recommend (.:).
04:19:14 <kmels> by reducing you mean, using "anonymous" functions?
04:19:37 <Philonous> I agree. The eta-expanded version (\x y -> f $ g x y) might actually be the most readable
04:20:10 <shachaf> By "reducing" I actually don't mean "reducing".
04:20:21 <Philonous> kmels:  eta-reducing
04:20:21 <shachaf> I mean "making it smaller". Bad choice of word.
04:20:34 <Philonous> In this case, at least
04:20:36 <magicman> @type let iterate' f x = pure x <|> f (iterate' f x) in iterate'
04:20:37 <lambdabot> Alternative f => (f a -> f a) -> a -> f a
04:20:41 <shachaf> You can't eta-reduce that.
04:21:17 <shachaf> Anyway, E.g. concatMap f = concat . map f seems like a reasonable definition to me.
04:22:35 <kmels> I see, I learned a new term today :)
04:23:15 <Philonous> shachaf:  You can after you transform it to \x y -> (f . g x) y
04:23:30 <shachaf> Philonous: Sure.
04:23:41 <shachaf> But that's a much bigger process than eta-reduction.
04:24:07 <KoF> Arg. How do I take [IO Int] and turn it into [Int] properly.
04:24:17 <hpc> you don't
04:24:18 <mauke> KoF: sequence, >>=
04:24:25 <Philonous> KoF:  You can't, best you can do is IO [Int]
04:25:03 <xplat> copumpkin: i was trying to figure out parameterized monads rather than indexed monads at the time.
04:25:07 <KoF> ...If I got IO [Int], then couldn't I take that and do whatever <- the IO [Int]?
04:25:21 <elliott> @tell merijin great, I'll try it out
04:25:21 <lambdabot> Consider it noted.
04:25:26 <elliott> @karma+ java
04:25:27 <lambdabot> elliott's karma lowered to 42.
04:25:38 <Philonous> KoF:  Yes.
04:25:40 <elliott> @tell shachaf uh, yeah, that's stupid, I'll remove it
04:25:40 <lambdabot> Consider it noted.
04:25:45 <shachaf> @karma+ java
04:25:45 <lambdabot> shachaf's karma lowered to 54.
04:25:46 <Philonous> @type sequence -- KoF
04:25:46 <lambdabot> Monad m => [m a] -> m [a]
04:25:53 <shachaf> hi
04:26:01 <elliott> though frankly @karma needs a lot of changes
04:26:05 <shachaf> Yep.
04:26:07 <elliott> like recognising parens like preflex does
04:26:12 <elliott> and not triggering on C/C++ and stuff
04:26:17 <mauke> preflex: karma C/C
04:26:18 <preflex>  C/C: 6923
04:26:18 <shachaf> Why?
04:26:24 <elliott> well if it's going to not trigger on C...
04:26:24 <shachaf> I think it should trigger on c/c++ and also on c
04:26:31 <mauke> preflex: karma C
04:26:31 <preflex>  C: 199385
04:26:32 <shachaf> s/\+\+//
04:26:34 <KoF> Cool.
04:26:42 <elliott> fair
04:26:52 <shachaf> @karma-all
04:26:53 <lambdabot>  nobody               2000
04:26:53 <lambdabot>  c/c                   498
04:26:53 <lambdabot>  (                     205
04:26:53 <lambdabot>  +                     147
04:26:53 <lambdabot>  g                     141
04:26:55 <lambdabot>  libc                   56
04:26:57 <lambdabot>  dmwit                  54
04:26:59 <lambdabot>  shachaf                54
04:26:59 <elliott> er
04:27:00 <shachaf> Oops.
04:27:01 <lambdabot>  monochrom              51
04:27:03 <elliott> don't do that
04:27:03 <lambdabot>  ##c                    48
04:27:05 <elliott> @part #haskell
04:27:05 <lambdabot>  Notepad                46
04:27:07 <lambdabot>  "C                     42
04:27:08 <shachaf> Isn't it suppose to cut it off?
04:27:09 <elliott> um.
04:27:09 <lambdabot> Plugin `karma' failed with: <<timeout>>
04:27:28 <elliott> lambdabot's line limiting is... not entirely standardised, I think
04:27:32 <shachaf> @karma+ java
04:27:32 <lambdabot> shachaf's karma lowered to 53.
04:27:35 <shachaf> dmwins!
04:27:38 <mauke> preflex: karmatop
04:27:46 <elliott> anyway I'll look at karma once I finish the last two 90%s of the run plugin. the first 90% is done
04:27:58 <elliott> also, do people say nobody++ a lot for some reason or is that a fake entry?
04:28:00 <elliott> @karma nobody
04:28:00 <lambdabot> nobody has a karma of 2001
04:28:06 <shachaf> It's a fake entry.
04:28:07 <preflex>  c: 199385; g: 9814; ##c: 7797; c/c: 6924; whiteknight: 4931; moritz: 4822; bacek: 4624; notepad: 4236; jnthn: 3779; #c: 3751
04:28:15 <elliott> nobody-- for being fake
04:29:24 <merijn> elliott: I've never seen that, so I suspect it's fake
04:29:52 <shachaf> monochrom++ # monochrom
04:30:13 <mauke> preflex: karma monochrom
04:30:14 <preflex>  monochrom: 84
04:31:02 <KoF> Yaaay. I know how to make random numbers work now.
04:31:49 <KoF> So, this is /functioning/ code, but is there anything I do in here that's a heinous abomination I should never repeat or anything, or does it look like reasonable Haskell? http://pastebin.com/qUqrsdDw
04:31:51 <mauke> The paste qUqrsdDw has been copied to http://sprunge.us/HeDX?haskell
04:33:27 <Philonous> KoF:  putStrLn (show nums) can be written more succinctly as (print nums)
04:34:26 <KoF> kay
04:34:34 <magicman> And not an abomination, but take a look at the replicate function from Prelude.
04:34:57 <magicman> > replicate 5 "Hello"
04:34:58 <lambdabot>   ["Hello","Hello","Hello","Hello","Hello"]
04:35:12 <KoF> Aha.
04:35:27 <KoF> So if I did replicate 5 for the random, I'd get 5 random numbers?
04:35:53 <Philonous> KoF:  You get 5 actions, each of which will yield a random number
04:35:55 <magicman> You'd get a list with 5 "IO Int"s.
04:36:29 <KoF> Right.
04:36:36 <Philonous> KoF:  replicateM 5 getStdRandom (randomR (1,10)) would be even more concise
04:36:41 <KoF> The part I wasn't sure about was whether the actions would yield identical numbers.
04:36:41 <Philonous> @type replicateM
04:36:42 <lambdabot> Monad m => Int -> m a -> m [a]
04:37:11 <Philonous> KoF:  sorry , I meant (replicateM 5 $ getStdRandom (randomR (1,10)) )
04:37:19 <frerich> yitz: The Maybe-based 'parseArgs' is neat. It taught me about 'guard' :-)
04:37:22 <ramses_> KoF: the action does not contain the number in any way, so using the same action multiple times will yield different numbers
04:37:24 <Kneiva> btw. My "ExitFailure 11" problems were caused by too old version of Xcode. I updated OS X and Xcode and now cabal install and ghci seem to work as expected.
04:39:04 <Philonous> KoF:  It's like calling the same program 5 times. Date, for example, will give 5 different answers even though it's the same program
04:39:07 <KoF> Mmkay. So it's a bunch of copies of "pull a random number from the generator". Right.
04:39:17 <merijn> KoF: You get a list of "action that produces a random number"
04:39:41 <merijn> KoF: Which (with help of sequence) can be turned into "action that produces a list of random numbers"
04:39:44 <merijn> :t sequence
04:39:45 <lambdabot> Monad m => [m a] -> m [a]
04:40:44 <merijn> KoF: To help see that it'll generate a different random number, sequence (x:xs) is just "sequence (x:xs) = do { r <- x; rs <- sequence xs; return (r:rs) }"
04:40:59 <KoF> Right.
04:41:24 <merijn> so if x is, for example, "randIO" it will just run randIO and then continue towards the rest of the list
04:42:47 <merijn> See also the difference of running "map print [1..10] !! 3" and "fmap (!!3) $ sequence (map print [1..10])" in ghci
04:44:10 <merijn> Actually main can be reduced to "sequence (ranList 5) >>= print"
04:44:17 <merijn> Although that's a matter of taste
04:45:06 <KoF> Trying to stick with the do syntax for now, since I'm new to dealing with Haskell's IO.
04:45:22 <merijn> KoF: I actually recommend using >>= over do syntax when just starting out
04:45:29 <KoF> Really? Why's that?
04:45:43 <elliott> I don't.
04:46:08 <merijn> KoF: People sometimes get confused by the behaviour of do-syntax in ways that wouldn't not be possible if you understand the way it is translated to >>= and >>
04:46:17 <KoF> Ahh.
04:46:41 <merijn> KoF: And knowing how to write stuff with >>= and >> makes understanding the translation of do syntax trivial
04:47:04 <KoF> (if I want to import someone else's module, is it just stick it in the same folder and stick "import <whatever>" at the top of the file?)
04:47:09 <elliott> people sometimes get confused by (>>=) syntax because it's incredibly noisy
04:47:16 <elliott> and do notation is much morel inear
04:47:19 <elliott> *linear
04:47:26 <merijn> KoF: Especially confusions of the type "why can't I write 'foo :: IO a -> a; foo x = do { result <- x; x }'"
04:47:38 <merijn> eh
04:47:42 <merijn> Replace last x with result
04:48:11 <merijn> If you look at the translation of that to >>= and the type of >>= then it immediately becomes obvious why that's wrong
04:48:44 <merijn> It'd translate to "foo x = x >>= \result -> result"
04:49:00 <elliott> no it wouldn't.
04:49:20 <merijn> elliott: It would if you fix my typo I just mentioned
04:49:24 <elliott> oh
04:49:29 <merijn> :)
04:50:36 <merijn> Given that the type of >>= is "IO a -> (a -> IO b) -> IO b" (if you specialise to IO), and "\result -> result" clearly doesn't match the type "a -> IO b"
04:50:46 <elliott> right.
04:51:09 <merijn> KoF: otoh, if what I just mentioned feels like reading "duh", then I'd say you already know all there is to know about that subject :p
04:52:33 <typoclass> KoF: yes you can import a module like that, if you have the package installed that contains the module
04:52:40 <merijn> (Actually, \result -> result would match "a -> IO b" in the trivial case where "a = IO b", in which case you'd just me implementing "join" :p)
04:52:49 <merijn> :t join
04:52:50 <lambdabot> Monad m => m (m a) -> m a
04:53:05 <merijn> s/me/be
04:53:43 <KoF> ...dunno if you can call it /installed/. My professor handed me a .hs file and I stuck it somewhere in the computer. :P
04:54:37 <shachaf> merijn: What if a = IO b?
04:54:43 <shachaf> Er, you just said that.
04:55:32 <merijn> KoF: In that case "import Foo" where you have Foo.hs in the same dir should work
04:56:02 <KoF> Let's see... I can pass the result of randoms into non-IO code and just have an infinite list of numbers to work with, right?
04:56:15 <KoF> And good, the importing part should be easy, then. <.<
04:56:58 <merijn> KoF: Yes
04:57:25 <KoF> Swoot, more easy hings.
04:57:27 <KoF> *things
04:57:38 <merijn> KoF: As long as your code eventually returns an IO, of course
04:58:08 <merijn> Or, you could do "fmap yourPurecode (randoms myGen)", of course
05:00:30 <KoF> I'm writing this under the assumption it eventually will be plugged into IO stuff. I'm randomly generating graph models, but instead of actually sticking the random generation in here, I'm just going to have it pull numbers off a list, and stick in a comment saying the list should be an infinite list of random numbers.
05:01:26 <KoF> Which is how I should be doing it, I think, based on how Real World Haskell was talking about it?
05:03:12 <merijn> KoF: Yes, you'd write your code to work with just a list of values and then use something like fmap to run it on the list of values produced by randoms
05:03:41 <pjdelport> KoF: have you looked at Control.Monad.Random?
05:04:01 <KoF> I haven't, no.
05:04:36 <merijn> pjdelport: If he only needs a list of randoms number that seems a bit overkill
05:05:22 <pjdelport> well, it depends how the graph model generation looks
05:06:06 <pjdelport> KoF: if you find yourself passing the random list around a lot, Control.Monad.Random could simplify the code
05:07:41 <typoclass> KoF: in principle you're on the right track. inside of main (or another IO action), use "<-" to fetch a (pure) list of random numbers. then pass the pure list into pure functions
05:07:52 <KoF> Hmm... I don't think I will have to pass it around that much.
05:08:53 <Lethalman> yitz, just reading http://www.cse.unsw.edu.au/~chak/papers/flow-fusion.pdf that refers to the stream fusion and rewrite rules :-) it's interesting
05:11:59 <KoF> I generate a regular graph that doesn't require any randomness, pass that into a randomizing function. Randomizing function will iterate through and have a random chance of adding another directed edge with random endpoints, then choose some states at random to be in a set that has some special characteristics.
05:12:01 <ramses_> what's with the girly pink flowers on the HP home page? I got some weird looks from colleagues :)
05:12:18 <KoF> Randomizing function then returns the resulting graph.
05:13:01 <merijn> ramses_: They're pretty! Like Haskell!
05:13:54 <ramses_> I don't really have a problem with them, but it's... weird. More like the home page of a perfume brand
05:17:05 <typoclass> why isn't there a hello kitty on the hp website :-( it would go great with the pink flowers
05:17:40 <shachaf> What is wrong with pink flowers? What is girly about pink flowers? What is wrong with girly?
05:18:39 <ramses_> typoclass: I feel like doing a mash-up now, but I really ought to do serious work :)
07:05:37 --- topic: '["Haskell Platform 2013.2: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down, try: http://hdiff.luite.com "]'
07:05:37 --- topic: set by shachaf!~shachaf@unaffiliated/shachaf on [Tue May 28 01:16:22 2013]
07:07:04 <merijn> \o/
07:07:52 <monochrom> kosc: see my http://www.vex.net/~trebla/haskell/lazy.xhtml
07:13:02 <kosc> monochrom: Thanks for the link.
07:13:35 <ramses_> isomorphic: yes, something like that, I think you'll have something like "class MyPtr p where unwrap :: p a -> a; wrap :: a -> p a" then, with suitable names
07:14:22 <ramses_> the ViewPatterns extension allows you to use that unwrap function in pattern matches then
07:14:59 <isomorphic> Ah - that would be helpful
07:15:08 <isomorphic> Thanks!
07:29:32 <isomorphic> Line 15 of the following paste gives me an error - Parse error in pattern: wrap - http://bpaste.net/show/zYLG0odlLqsqv9Ejr9MC/  - is this the right way to do a ViewPattern?
07:30:48 <typoclass> isomorphic: how about fromPtr (Just x) = castPtr (unwrap x) ?
07:32:17 <isomorphic> typoclass:  Ah, right you are.   So, I can do this without a view pattern
07:44:36 <enigmuriatic1> https://github.com/kim/leveldb-haskell   can anyone help me find out how to get all key/value pairs from a leveldb database using this? i'm new to this kind of thing and there isn't any documentation (only examples)
07:46:58 <tommd> @lambdabot ping
07:46:58 <lambdabot> Unknown command, try @list
07:47:02 <tommd> yay
07:52:27 <ramses_> isomorphic: a view pattern would let you write "fromPtr (Just (unwrap -> w)) = castPtr w", which moves the destruction into the pattern. But this might not be beneficial here
07:52:43 <isomorphic> Thanks :)
07:53:02 <ramses_> it applies unwrap to the contents of the Just and binds the result to w
07:55:55 <isomorphic> types, newtypes and data - which ones can I make an instance of, just data?
07:56:11 <ramses_> and newtypes
07:56:37 <isomorphic> thanks :)
07:57:17 <isomorphic> I'm navigating c2hs at the same time as dealing with this instance stuff, so it's a bit of a game figuring out how to get it to generate something I know how to handle ;)
07:57:21 <ramses_> data and newtype make truely new types, they can be made instances. Type only introduces an alias which is replaced by the original at compile time, so it just "inherits" all instances of the aliased type
08:00:35 <yitz> @botsnack tommd: we ping lambdabot by tossing her a snack
08:00:35 <lambdabot> :)
08:04:28 <Taneb> I thought that was how we rewarded lambdabot
08:14:44 <enigmuriatic1> if I'm passing a DB connection through a recursive function, should I commit every time i use executeMany, or should I commit after the entire recursive call?
08:32:15 <augustss> howdy
08:33:50 <byorgey> hi augustss
08:39:12 <sclv_> hi!
08:39:18 <enigmuriatic1> http://hpaste.org/90049   is committing the DB after the entire loop the most efficient way to do that, or should i commit after each call?
08:40:02 <yitz> hi augustss nice to see you here
08:41:31 <yitz> enigmuriatic1: generally you should commit when a transaction is complete
08:44:01 <enigmuriatic1> yitz, what do you mean by that?
08:44:12 <enigmuriatic1> they're all complete, i'm just collecting them via a system call
08:46:03 <yitz> enigmuriatic1: if you get part way through and an error occurs, what do you want the state of the database to be?
08:46:23 <enigmuriatic1> yitz i see
08:47:01 <yitz> enigmuriatic1: if someone else queries the database while you are in the middle (which might not be possible with sqlite, but is possible with most databases), what do you want them to see?
08:48:38 <enigmuriatic1> yitz, none of that is super relevant here. i'm collecting all bitcoin transactions in a database for my own use, so it's all-or-nothing and just for my own use
08:48:44 <enigmuriatic1> also, it isn't dynamically updated
08:49:29 <yitz> enigmuriatic1: then it probably doesn't make a difference, except for semantic neatness
08:50:30 <yitz> enigmuriatic1: generally databases are supposed to be very fast either way. if you want to try getting some benchmarks for sqlite, that might be interesting. (but hopefully it's boring)
08:51:27 <augustss> yitz, I reappear now and then. :)
08:52:22 <Philippa> augustss: snap!
08:52:36 <merijn> Control.Exception.block and unblock were removed in HEAD?
08:52:43 <Philippa> not that my own reappearances are as significant, but hey
08:52:53 <augustss> :)
08:53:22 <Philippa> how're things? I appear to be actually pretending to do research again for the first time since '07 or so
08:54:15 <yitz> merijn: in the haddocks for the current version: "Deprecated: use Control.Exception.mask instead"
08:54:28 <akegalj> in yesod, how to create a widget which loads remote script and adds hamlet from a file?       addRemoteScript url >> whamletFile name     doesnt work
08:55:14 <merijn> yitz: I know that, but that's not really an answer
08:55:33 <yitz> merijn: ok, then. yes. better?
08:55:37 <merijn> yitz: MonadCatchIO-transformers is broken and I'm guessing it's due to the removal of block/unblock
08:55:58 <merijn> yitz: ok, then at least I know I'm not wasting my time looking into it for nothing
08:56:13 <yitz> merijn: yeah could be. who's maintainer?
08:56:43 <merijn> "ariep@xs4all.nl"?
08:56:52 <eikke> we should have more CI against different GHC versions (including head) of hackage packages somehow
08:57:07 <yitz> akegalj: is it a compile error or it compiles and doesn't work?
08:57:23 <merijn> Which is unfortunate, as lens seems to depend on MonadCatchIO-transformers
08:57:28 <yitz> merijn: hmm sounds familiar
08:57:38 <akegalj> yitz: compile error
08:57:55 <edwardk> lens is switching to 'exceptions' as soon as i release it
08:58:00 <yitz> akegalj: ah ok good. can you paste it?
08:58:09 <merijn> And I'm not actually sure that MonadCatchIO-transformers is salvageable without block/unblock
08:58:14 <edwardk> github.com/ekmett/exceptions
08:58:20 <merijn> edwardk: I send you a pull request to fix contravariant for 7.7!
08:58:26 <edwardk> that works around the block/unblock issue
08:58:30 <edwardk> merijn: k
08:58:35 <merijn> edwardk: The removal of Typeable1 broke it
08:58:49 <edwardk> yeah
08:58:59 <merijn> And the CPP macro's didn't account for it being missing in 707 too
08:59:02 <edwardk> its breaking a lot of my packages i need to go and release about 60 of them
08:59:22 <merijn> Although fixing it might break older 7.7 snapshots (I guess no one cares about that, though)
08:59:23 <edwardk> the trick is is it missing in _all_ of 707 or just some versions?
08:59:34 <edwardk> exactly
08:59:59 <merijn> Yeah, I figured I'd let that dilemma be up to you :p
09:00:14 <merijn> I'm just checking out my fork and installing that when something gets stock on contravariant :p
09:00:22 <edwardk> worst case scenario is i break Typeable support for 707 entirely and let it restart working in 708, but then other things downstream break
09:00:47 <edwardk> contravariant patch merged
09:01:17 <merijn> I figure that people who are running 7.7 know the risk of being told "to bad, upgrade to a newer snapshot"
09:02:10 <akegalj> yitz: oh, i thought whamletFile looks in template directory automaticly insted of root directory. Solved, thanks. Duck debugging
09:02:21 <edwardk> fair enough
09:03:29 <yitz> edwardk: workaround? i thought block/unblock have an inherent flaw in their semantics, so you would want to switch to mask
09:03:41 <edwardk> i did
09:03:50 <edwardk> exceptions uses mask instead
09:04:01 <yitz> akegalj: ok glad to hear
09:04:14 <edwardk> yitz: http://ekmett.github.io/exceptions/Control-Monad-Catch.html
09:04:51 <edwardk> it also provides a pure 'CatchT' that can catch throwM thrown exceptions in pure code
09:04:55 <yitz> akegalj: btw you'll often get better results about yesod in the #yesod irc channel, or on the yesodweb google groups mailing list
09:05:02 <edwardk> so you can use it for modeling exceptions in something like quickcheck tests
09:06:07 <edwardk> come to think of it i'm just going to release it
09:06:11 <hcaulfield57> Could someone tell me what's wrong with this filter http://hpaste.org/90050 line 36
09:06:14 <edwardk> nobody has any complaints about the api so far
09:07:04 <eikke> edwardk: I read the API & code a couple of days ago (think when you mentioned it on some mailing list), looks very interesting!
09:08:03 <merijn> hcaulfield57: You have a double backslach in the lambda on line 36
09:08:12 <edwardk> there it is released. i told people 2 months ago i'd release it in a few weeks, so close enough =)
09:08:23 <mauke> hcaulfield57: \\
09:08:31 <eikke> 8 is still a few ;)
09:09:21 <hcaulfield57> That's a typo from hpaste, It's not there in the actual code, didn't notice that.
09:09:34 * eikke almost never gets to the 'releasing' stage
09:09:45 <mauke> hcaulfield57: show us the actual code and error message
09:10:16 <yitz> edwardk: hmm if you throw and catch in pure code is it equivalent to ErrorT, or is there u.s.P.IO voodoo going on in the background?
09:10:22 * hackagebot exceptions 0.1 - Extensible optionally-pure exceptions  http://hackage.haskell.org/package/exceptions-0.1 (EdwardKmett)
09:10:36 <edwardk> yitz: no. you can't catch 'throw' only 'throwM'
09:10:46 <akegalj> yitz: yes i'am active there too, but this chanell has faster response time
09:10:54 <edwardk> its basically ErrorT SomeException
09:11:11 <edwardk> masking doesn't do anything in the pure setting
09:11:33 <yitz> edwardk: i didn't mean literally the function catch
09:12:05 <edwardk> nah, the catch is literally just doing the case analysis/Typeable stuff on the left side of the Either.
09:12:16 <edwardk> http://ekmett.github.io/exceptions/src/Control-Monad-Catch.html#CatchT
09:12:34 <yitz> edwardk: so it's basically ErrorT? with the difference being that if an exception leaks out, it becomes an async exception?
09:13:01 <elliott> edwardk: nice Google copyright
09:13:02 <edwardk> and with the Typeable nonsense to avoid explicitly enumerating exceptions
09:13:10 <edwardk> elliott: blame mzero ;)
09:13:21 <elliott> edwardk: the same file claims to be both apache and bsd3-licensed
09:13:23 <edwardk> elliott: he wrote the initial code so i stuck with his original copyright and license
09:13:32 <edwardk> ack that was what i wanted to fix before releasing it
09:13:51 <elliott> hmm, is apache 2 safe from a haskell perspective?
09:14:29 <edwardk> afaik
09:14:37 <edwardk> there is plenty of other stuff out there under it
09:16:08 <edwardk> fixed
09:17:49 <hcaulfield57> mauke: Anytime I enter it into hpaste it adds that second '\'. I get this when I try to remove a directory http://hpaste.org/90052
09:18:20 <mauke> hcaulfield57: &&, not ||
09:19:23 <mauke> indeed it does
09:19:26 <mauke> *sigh*
09:20:17 <hcaulfield57> mauke: Thanks! That worked, dumb mistake, it's early.
09:20:23 * hackagebot exceptions 0.1.0.1 - Extensible optionally-pure exceptions  http://hackage.haskell.org/package/exceptions-0.1.0.1 (EdwardKmett)
09:20:48 <monochrom> interesting
09:21:37 <monochrom> on the bright side, next time I post "(\x -> 1 + x)", hlint will not be obnoxious about "why not (1 +)"
09:24:47 <merijn> So sad, travis-ci doesn't support the new platform yet?
09:25:22 <monochrom> need travis-ci-ci for that :)
09:25:24 * hackagebot wai-static-pages 0.2.0.1 - generate static html pages from a WAI application  http://hackage.haskell.org/package/wai-static-pages-0.2.0.1 (GregWeber)
09:29:41 <eikke> merijn: they use whatever's last in the ubuntu repos, but if there'd be some PPA which includes other ghc or platform releases, they might add those as well
09:30:04 <eikke> merijn: but sadly enough afaik there's no such PPA (and I'm no ubuntu user so wont get into that mess)
09:30:52 <merijn> eikke: Now I'm sad :(
09:32:57 <yitz> elliot: the apache license restricts use of trademarks. does that mean it is not compatible with debian? or has that whole mess been cleaned up?
09:34:19 <yitz> s/elliot/elliott/
09:36:38 <elliott> yitz: no idea
09:39:11 <yitz> ah i see edwardk has re-pinged mzero for permission to change the license to bsd3
09:48:44 <bscarlet> Anyone out there able to offer Cabal advice? cabal sdist isn't including all my test files.
09:48:57 <dcoutts_> bscarlet: extra-src-files
09:50:01 <bscarlet> dcoutts_: In my test-suite stanza?
09:50:21 <dcoutts_> bscarlet: that would do
09:50:35 <dcoutts_> bscarlet: oh hmm, or maybe it has to be in the global section, I forget
09:50:45 <dcoutts_> but if you get the wrong one, it'll tell you
09:51:50 <bscarlet> dcoutts_: Is it "normal" that they're not found without explicit listing?
09:52:31 <dcoutts_> bscarlet: oh if you mean .hs files, then you need to list all your modules in other-modules, and then they'll be found normally
09:52:57 <dcoutts_> extra-src-files is for extra things other than .hs files like test data or scripts or whatever else that needs to go into the tarball
09:54:05 <bscarlet> dcoutts_: For my library, I needed to use exposed/other modules to get everything to build correctly. Do I gather from your response that for a binary or test, most modules should wind up listed as "other"?
09:54:26 <dcoutts_> bscarlet: right, only libraries have exposed-modules
09:54:40 <dcoutts_> bscarlet: tests and exes have their main file, and other modules
09:55:00 <bscarlet> dcoutts_: Thank you. I think that's just what I needed.
09:55:23 <dcoutts_> bscarlet: every component should list all of its modules
10:14:08 <bscarlet> can/should C header files go in a module's c-sources list in a .cabal file?
10:14:15 <enigmuriatic1> does anyone have a concise description or a link to a lengthier one of what exactly happens to a database statement when it is executed but not yet committed? is it just stored in memory?
10:15:11 <bscarlet> enigmuriatic1: I would imagine that would depend on the database.
10:17:14 <bscarlet> enigmuriatic1: May I ask why you ask?
10:18:06 <enigmuriatic1> bscarlet, i'm writing a script that parses and commits a very large amount of data (the Bitcoin blockchain, about 9.1 GB) so I'm trying to maximize efficiency
10:19:38 <typoclass> enigmuriatic1: i'd say that after the transaction is committed, all of the stuff that it did is visible to all users of the database. before the transaction commits, it's only visible inside of the transaction itself. i guess different databases could implement this in different ways (write-ahead logging or whatnot)
10:20:33 <typoclass> enigmuriatic1: i don't think transactions are meant to be about performance, it's really about consistency
10:20:44 <geekosaur> ^^
10:20:55 <bscarlet> enigmuriatic1: I certainly wouldn't assume uncommitted data is "just in memory".
10:21:16 <geekosaur> transactions ensure that anything *outside* the transaction sees a consistent view of the database. how the database engine does this is up to the database engine
10:23:21 <geekosaur> the canonical example is double-entry bookkeeping, where any change in one account must be balanced by an offsetting change in another; in mid-transaction you may have only done one change, but this must not be visible to others using the database until the other change is done
10:28:48 <m4b> wrote parser using parsec essentially verbatim from tutorial, but for boolean logic; everything is fine; but annoying feature is that, for example, "a a  b" gets parsed as just "a", or similarly, "a  b b" gets parsed as "a  b"; in other words the parser consumes a boolean if it can, and then if the rest doesn't parse, it truncates and returns what it could; i want the above examples to be errors however; here is the code:
10:28:49 <m4b> http://dpaste.com/1248133/
10:29:14 <Philippa> m4b: you need eof on the end of your parser
10:29:44 <tac> m4b: yeah, eof marks that you must have consumed all your input for a successful parse
10:30:15 <Philippa> (there are sensible use cases for being allowed to do the other thing, plus parsec's design allowed eof = notFollowedBy anyChar which had a certain aesthetic appeal)
10:32:15 <m4b> Philippa, tac: thank you for your quick response: so would that go in the lit = m_parens booleanparser part, or the table?
10:33:18 <xplat> Philonous: call your package 'stun', take responsibility and make it so good nobody will want to make another one :)
10:34:01 <Philonous> xplat:  It's called stunclient now
10:34:31 <eikke> stun, the network hole punching thing?
10:34:35 <Philippa> m4b: it goes as the very last thing your parser calls. You can put it in the call to run the parser, if you like
10:34:37 <Philonous> xplat:  And I'm quite sure nobody will _want_ to make another one ;)
10:34:41 <Philonous> eikke:  Indeed
10:34:44 <eikke> ieuw
10:34:48 <eikke> link?
10:34:56 <Philonous> http://hackage.haskell.org/package/stunclient
10:35:17 * eikke has memories of spending^Wwasting time working on a STUN C library
10:35:29 * hackagebot snaplet-sqlite-simple 0.4.4 - sqlite-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-sqlite-simple-0.4.4 (JanneHellsten)
10:35:42 <Philonous> eikke:  libnice does stun (even without the glib stuff)
10:36:28 <Philonous> eikke:  And actually, when you want to do NAT hole punching, you should use ICE. STUN ist just part of it.
10:36:51 <m4b> Philippa: yea, I'm sorry but I don't understand eof's type signature: parse takes a parser, a message string, and the input to be parsed; not sure where eof fits in
10:37:35 <eikke> Philonous: I know ;)
10:37:56 <Philippa> m4b: eof is just another parsing action - a "null token", if you like
10:38:13 <eikke> was related to hacking on Ekiga (somewhere around 2006 appareantly)
10:38:29 <Philippa> so it becomes the last thing your parser does - a way of saying "and I'm done now, there'd better not be anything left"
10:40:34 <m4b> Philippa: ok, forgive me but this doesn't help me to understand its type signature, or more concretely, where in the actual code it fits
10:41:38 <m4b> I assume it doesn't go in the table; and it clearly doesn't go in the booleanparser <|> litparser <|> etc. ...
10:41:51 <Philonous> eikke:  I don't know Ekiga. Does it do jingle?
10:42:19 <eikke> Philonous: called GnomeMeeting before (IIRC), a SIP client/softphone
10:43:00 <Philonous> Ah, SIP.
10:44:47 <geekosaur> m4b, your paste doesn't show the part where you actualy run the parser?
10:48:07 <abitwizardly> anyone here on HN right now? I'd love feedback on this post (https://news.ycombinator.com/item?id=5894651) - essentially made for people in this channel
10:48:14 <m4b> geekosaur: yea its in a different module, didn't think it was relevant: http://dpaste.com/1248198/
10:48:55 <tgeeky> abitwizardly: I don't see any content
10:49:20 <abitwizardly> tgeeky: on the hn domain or on the actual site?
10:49:35 <abitwizardly> sorry not sure what you mean
10:49:55 <tgeeky> abitwizardly: both. HN just has a link, and the link has a headline, a blub, and a signup form.
10:50:05 <m4b> yea i don't see any content either
10:50:36 <geekosaur> m4b: easiest way to fit eof in is to import Control.Applicative and replace the `booleanparser` in the main module with `(booleanparser <* eof)`
10:51:00 <abitwizardly> I guess it's still in the idea stage, i was just chatting with one of my friends who is a cto trying to hire right now, and personally this is something that interests me
10:51:29 <eikke> hmh, Palantir... some recruiter is trying to connect me to them, guess I should take a closer look
10:51:34 <abitwizardly> i personally want to be doing interesting things (to me that means cutting edge ui/ux stuff, different to most)
10:51:47 <tgeeky> abitwizardly: add more content, an explanation, and some examples (even if they are fake). Right now it looks like you just want our e-mail addresses.
10:51:54 <abitwizardly> Palantir's interview process sucks though btw
10:52:01 <abitwizardly> okay good idea
10:52:21 <eikke> why's that?
10:52:38 <m4b> geekosaur: thank you very much, works as desired now!
10:53:11 <eikke> Philonous: I noticed you created bindings to htonl etc... why not do that in plain haskell? (there's some code for that in Binary, but not exported as-is)
10:53:52 <m4b> geekosaur: although I don't exactly see why yet, heh, but I'll play around with it some more, again, thank you
10:54:43 <abitwizardly> eikke: they make all the engineers who don't want/don't know how to do interviews - at least in Australia anyway
10:58:35 <dmwit> Ah, Palantir. Are thy still selling 80 hour work weeks like that's a good thing?
11:00:11 <zomg> dmwit: Huh? =)
11:00:22 <zomg> for one person 80 hours a week?
11:00:44 * geekosaur remembers getting headhunted by palantir, reading their stuff, and running the other way
11:00:49 <dmwit> Yes, when I visited they proudly showed off their room full of bunk beds.
11:01:01 <sellout-> zomg: You must not be in the US ;)
11:01:04 <eikke> interesting
11:01:33 <zomg> sellout-: nah but I work for a startup in the US and we have someone from Palantir
11:01:39 <sellout-> Yeah, my sister-in-laws bf works there. She is very not happy about his work schedule.
11:01:51 <zomg> Sounds pretty ridiculous though
11:02:03 <dmwit> They literally said "you should not have a girlfriend if you want to work here".
11:02:06 <zomg> I know startups do that but I don't think Palantir is a startup at this point
11:02:19 <zomg> dmwit: you should be a moron to work here more like... :p
11:02:25 <zomg> or maybe they just pay you so much
11:05:00 <Philonous> eikke:  I don't remember my reasoning. I suppose it was the easiest way I could come up with at that point.
11:05:31 * hackagebot Win32-services-wrapper 0.1.1.0 - Wrapper code for making a Win32 service  http://hackage.haskell.org/package/Win32-services-wrapper-0.1.1.0 (GaneshSittampalam)
11:08:17 <fizbin> Anyone experienced with HXT arrows?
11:10:53 <fizbin> Namely, I'd like an arrow/HXT expert to look at http://www.reddit.com/r/haskell/comments/1gfxum/question_about_web_scraping_and_parsing_html/cakkwzo and give me feedback on whether I'm doing something obviously wrong there or if serious arrow usage is supposed to look like that.
11:33:03 <acube> Is it possible to define infixl of some operator in ghci?
11:33:21 <Cale> fizbin: I'd tend to make more use of proc/do notation myself, though one can be forgiven for avoiding it in the case of HXT, whose instances of Arrow aren't terribly well-behaved.
11:34:21 <fizbin> Cale: HXT also gives you stuff like arr3 that tempts you to use &&& more than one might otherwise.
11:34:28 <acube> Ah ok, I have to infixl n op in the let definition that defines op
11:34:32 <Cale> acube: let infixl 6 *&; x *& y = x^2 - y^2
11:34:35 <Cale> yeah
11:35:06 <fizbin> I also haven't quite gotten the hang of proc/do yet.
11:35:25 <orzo> What's a good data structure for performing efficient symmetric differences?  I didn't see a symetric difference operation in Data.Set so I would have to make it out of union and intersection and I'm concerned that's inefficient
11:35:28 <Cale> fizbin: I'm not sure that I entirely believe in HXT's uses of Arrow. The arrows it defines are really monads, as far as I recall.
11:35:58 <fizbin> They do all seem to do their work inside IO...
11:36:52 <fizbin> Except for the HXT pickling framework, which is just whole other thing bolted on there
11:38:02 <Cale> orzo: Data.Map has mergeWithKey -- I really don't know why Data.Set doesn't have something analogous to that.
11:39:00 <orzo> thanks, Cale, I'm looking at that
11:40:13 <Cale> However, I also wouldn't expect  union (difference a b) (difference b a) to be too bad. At least, asymptotically, it's no worse than the usual O(n+m).
11:40:26 <Cale> It's also easy to read.
11:40:49 <Cale> Probably you should try it first, and then think about changing the algorithm if it's not efficient enough.
11:43:01 <orzo> hm, i've no need to do the union if i do the two differences anyway as i'm just going to toList it.
11:46:10 <orzo> My situation is such that I have a list xs and a replacement list xs' and i want to handle departures and new arrivals differently and after they are handled, keep xs' for the next event
11:46:41 <orzo> the type of xs and xs' may be a foldable data structure of my choosing
11:47:15 <xico> i often write things like "x <- f ; g x ; h x" where "f :: IO a; g,h :: a -> IO ()" since g is my save-to-file, and f and h are computations. is there a way to simplify the writting?
11:48:04 <orzo> xico: idunno, maybe a job for Arrows?
11:48:21 <xico> i could kleisli that yes
11:52:48 <Cale> xico: You could actually just abstract the pattern directly yourself.
11:54:21 <Cale> tee x g h = do v <- x; g v; h v
11:54:44 <Cale> (or with flipped arguments, depending on whatever's convenient :)
11:54:51 <Cale> Maybe g should be first
11:54:53 <xico> sounds nice! thanks :)
11:54:59 <acube> @ty \f g h -> f >>= liftA2 (>>) g h
11:55:00 <lambdabot> Monad m => m a -> (a -> m a1) -> (a -> m b) -> m b
11:55:30 <xico> @src liftA2
11:55:30 <lambdabot> liftA2 f a b = f <$> a <*> b
11:55:55 <xico> indeed :)
11:55:56 <acube> Take the Applicative instance for (-> r)
11:56:06 <acube> oops, I mean (->) r
11:56:44 <acube> It's liftA2 :: (a -> b -> c) -> (x -> a) -> (x -> b) -> x -> c then
11:57:53 <supki> @pl \f g h -> f >>= (>>) <$> g <*> h
11:57:53 <lambdabot> (. ((((>>) <$>) .) . (<*>))) . (.) . (>>=)
11:57:58 <acube> :O
11:58:09 <Cale> xico: In fact, tee could also just return instead of making h part of that.
11:58:23 <acube> it was so nice, and pl made it ugly :(
11:58:23 <Cale> tee g x = do v <- x; g v; return v
11:58:31 <tgeeky> @. pl djinn  (a -> b -> c) -> (x -> a) -> (x -> b) -> x -> c
11:58:31 <lambdabot> f = liftM2
11:58:45 <tgeeky> the one and only!
11:58:47 <Cale> @undo do v <- x; g v; return v
11:58:47 <lambdabot> x >>= \ v -> g v >> return v
11:58:54 <Cale> @pl x >>= \ v -> g v >> return v
11:58:57 <lambdabot> x >>= ap ((>>) . g) return
11:58:57 <lambdabot> optimization suspended, use @pl-resume to continue.
11:59:01 <Cale> meh
11:59:07 <tgeeky> Cale: meh indeed. :(
11:59:13 <elliott> Cale: @pl is broken, I think it's an upstream change
11:59:21 <elliott> been putting time into @run instead
11:59:27 <Cale> Better to just write your own function here anyway, I think.
11:59:32 <tgeeky> elliott: broken how?
11:59:41 <acube> elliott: Do you also host lambdabot on #lens?
12:00:00 <tgeeky> acube: there can only be one user per username, it must be the same user
12:00:06 <tgeeky> acube: on each IRC network, at least
12:00:07 <elliott> acube: nicks are per-network (modulo netsplits), not per-channel, so I have to be :)
12:00:18 <acube> elliott: Why is there no ix on lens?= :P
12:00:22 <Cale> Anyway, that would let you write   do v <- tee saveToFile x; h v
12:00:34 <tgeeky> elliott: is this the new code reorganized lambdabot?
12:01:02 <elliott> acube: the "lens" lambdabot has right now is just a bunch of imports arkeet did. it can't import the full thing because of silly Safe Haskell issues, which I know how to fix, but it requires a lot of rebuilding and I'm in the middle of rewriting the run plugin, so I'm waiting until after that
12:01:13 <elliott> tgeeky: it's running off a patched version of the git lambdabot
12:01:14 <elliott> @version
12:01:14 <lambdabot> lambdabot 5.0
12:01:14 <lambdabot> git clone git://github.com/mokus0/lambdabot.git
12:01:20 <acube> elliott: Ah ok
12:01:29 <tgeeky> elliott: your judgement is better than ours :O
12:01:41 <tgeeky> plus, isn't there a second lambdabot with lens stuff around here?
12:01:46 <tgeeky> < 2 + 2
12:01:52 <tgeeky> he's dead, jim.
12:01:53 <typoclass> elliott: btw, who is this upstream who we keep hearing about?
12:02:24 <typoclass> tgeeky: regular lambdabot also has lens. i think the "<" guy was for some other thing
12:02:25 <elliott> typoclass: anyone who has changed lambdabot since whatever version the old lambdabot was running on (which I think was from like 2010), mainly mokus
12:02:32 <tgeeky> typoclass: it's dmwit's bot
12:02:35 <typoclass> elliott: oh i see, thanks
12:02:44 <tgeeky> typoclass: I think it was for the "universe" function
12:02:48 <acube> yes
12:03:07 <typoclass> tgeeky: right, that was it. (whatever that is exactly :-)  )
12:03:15 <tgeeky> I think I'm gonna have to try building her again.
12:03:59 <tgeeky> has anyone read any of the icfp2013 preprints and knows one of them is a "must read"?
12:05:40 <eikke> tgeeky: depends on your personal interests ...
12:06:09 <tgeeky> eikke: I plan on glancing at all of them, I just wanted to find the one or two to print and read first
12:06:32 <tgeeky> usually I would go with the functional pearls, but they aren't linked yet
12:06:41 <eikke> tgeeky: I read all those about simd & gpu computing
12:11:15 <augustss> There's at least one pearl up.
12:12:02 <tgeeky> augustss: 2/4. not bad.
12:12:04 <tgeeky> augustss: thanks
12:12:38 <tgeeky> augustss: perhaps not, though. the 4th one doesn't look like a Pearl to me. :o
12:13:36 <augustss> tgeeky, No, Traytel&Nipkow doesn't feel like a pearl.
12:15:34 * hackagebot JuicyPixels 3.1 - Picture loading/serialization (in png, jpeg, bitmap, gif, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.1 (VincentBerthoux)
12:58:05 <oio_> map IO function over a [Strings]
12:58:20 <typoclass> oio_: try mapM or mapM_
12:58:23 <typoclass> @type mapM
12:58:25 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
12:58:43 <jnerula> @type mapM_
12:58:44 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
12:59:06 <jnerula> lambdabot: you're pretty cool
12:59:16 <Botje> @botsnack
12:59:16 <lambdabot> :)
12:59:35 <simon> I kind of like the consistent use of "x <- foo" rather than occasional "let x = foo" whenever my functions are not monadic.
13:00:05 <simon> still, x <- return foo seems a little silly. :)
13:00:20 <typoclass> simon: erm, yeah =)
13:00:31 <eikke> I saw x <- return foo in the distreibuted-process(-platform?) code yesterday while reading it
13:00:43 <eikke> (and some other rather unusual style things)
13:27:14 <canta> can i print something of type m String, where m is some monad?
13:27:32 <Taneb> canta, depends on the monad
13:27:35 <ion> If theres a Show instance for m String.
13:27:38 <ion> for the specific m
13:27:38 <Taneb> In general, no
13:27:56 <typoclass> canta: do you have an IO String or another m String?
13:28:01 <Taneb> You can't for, eg, e -> String, State s String, Cont r String...
13:28:47 <elliott> canta: to the point: what are you trying to do?
13:28:50 <canta> typoclass: I stumble through a bigger project and try to debug it, it is some custom monad, but now I know what to add :)
13:29:07 <typoclass> canta: hm i see
13:30:15 <typoclass> canta: Debug.Trace may be useful. or putting the code on hpaste.org for us to look at
13:31:19 <orzo> I do not like the "hiding" keyword.  I think I would prefer a "qualifying" word instead.  It would bring the entire module into scope, but require qualification for listed symbols.  As it is, you have to do a hiding import followed by a qualified import to acheive this
13:34:37 <josephle> canta: I agree with typoclass. Debug.Trace is a good friend (even if it breaks 1000 abstractions along the way).
13:34:43 <xplat> orzo: yeah, that is sort of annoying
13:35:22 <orzo> i can't imagine when i'd prefer the hiding semantics to the proposed qualifying one
13:35:39 <xplat> orzo: of course, you should be using 'using' rather than 'hiding'
13:35:46 <typoclass> orzo: so you want some keywords from module M available unqualified, others only qualified?
13:36:03 <sclv_> 'qualifying as' even better
13:36:32 <sclv_> or hrm 'qualified + using'
13:36:47 <xplat> also, i guess you could import several modules qualified with the same prefix and want to hide an identifier from one because it conflicts with another one you're using the same prefix for
13:36:48 <typoclass> orzo: you mean you have "import Foo hiding (doodle) ; import qualified Foo", and you'd like to combine this into one line?
13:36:54 <sclv_> so I could do import qualified Data.Text as T using Text
13:37:08 <sclv_> so I get Text unqualified and then the functions on it qualifed -- something like that
13:37:13 <orzo> typoclass: yes
13:37:33 <typoclass> sclv_: ok that gets at the same thing. currently you need two lines, you'd like to write only one
13:37:34 <sclv_> import Data.Text (Text); import qualified Data.Text as T
13:37:45 <sclv_> yeah, its just sort of a dual problem -- the one that's more common for me
13:37:45 <typoclass> sclv_: right
13:38:07 <sclv_> sometimes I have BS.ByteString all over my code b/c I'm too lazy to add a second import line
13:38:21 <fizbin> What's the easiest way to submit a bug report against the ghc html users_guide ? (A typo that makes an external link not work)
13:38:30 <orzo> well, i find the two-line case to be more commonly desired than the one-line case, and that doesnt really make sense, the common case should be less code than the uncomon
13:38:44 <xplat> in agda you could do "import Data.Text as T\nopen T using (text)\n"
13:38:47 <sclv_> fizbin: the ghc trac. but you could even pull and send in a patch if you really wanted :-)
13:39:00 <xplat> which is still 2 lines, but at least you don't have to repeat the module name
13:39:02 * elliott would like: import Foo {names} [as Bar {names}] where {names} = (a, b, c, ...) | hiding (a, b, c...)
13:39:15 <elliott> import Foo (a, b, c) as Bar would be import Foo (a, b, c); import qualified Foo as Bar
13:39:19 <typoclass> fizbin: http://hackage.haskell.org/trac/ghc/ <- there's a public user "guest", password "guest"
13:39:21 <elliott> import Foo as Bar would be import qualified Foo as Bar
13:39:33 <elliott> import Foo hiding (a, b, c) as Bar would be import Foo hiding (a, b, c); import qualified Foo as Bar etc.
13:39:45 <elliott> this would handle things like "import Data.Map (Map) as Map" nicely
13:40:05 <xplat> elliott: yeah, i think i'd like that better than the current system
13:40:26 <typoclass> hm, my ghci says "import Foo (a, b, c) as Bar" is currently not legal
13:40:28 <xplat> elliott: for silly bonus points allow more than one 'as'
13:40:41 <elliott> typoclass: yes, it's a proposal :P
13:40:52 <elliott> xplat: that sounds of questionable utility, but sure, why not!
13:40:58 <typoclass> elliott: sure :-) but i thought it'd collide. but it doesn't
13:41:18 <elliott> typoclass: it's a backwards incompatible change because it makes "qualified" implicit in "import Foo as Bar"
13:41:23 <orzo> its "import Foo qualified as Bar (a,b,c)"
13:41:38 <typoclass> elliott: oh yes
13:41:50 <orzo> er, misplaced my qualified
13:42:02 <orzo> current syntax: "import qualified Foo as Bar (a,b,c)"
13:42:26 <johnw> sclv: ping
13:42:30 <xplat> {-# LANGUAGE ElliottImports #-}
13:42:45 <elliott> I hope I get royalties whenever anyone uses them
13:43:17 <xplat> i wish i could think of a better name for the language flag that doesn't make this sound so ... idiosyncratic
13:43:39 <elliott> ooh, ooh, how about we steal record syntax!! then it does renames too!! Map{Map = Map} = Data.Map
13:43:45 <xplat> i like this proposal a lot, the 'qualified' is a huge waste of columns
13:43:45 <FreeFull> {-# LANGUAGE Nirvana #-}
13:43:49 <elliott> Prelude{id = monomorphicId} = Prelude
13:43:55 <elliott> T = Data.Text
13:44:03 <elliott> Foo{..} = Foo -- to import everything
13:44:07 <elliott> ok, this is silly.
13:44:17 <typoclass> 'qualified' is a bit of an oddball. i feel 80% of the time i use it together with 'as', and another 10% i use it in stuff like 'import D.Map (Map) ; import qualified D.Map'. i can hardly think of a case where i'd want an actual lone 'qualified'
13:44:37 <typoclass> in other words, plz remov current ting and maek elliott ghc, kthxbai
13:44:52 <elliott> i begrudgingly accept my position as dictator
13:45:51 <orzo> maybe rather than record syntax, reuse the "as" keyword in the symbol list
13:46:04 <typoclass> i dunno. i've always found it weird in Foo{id = blah} how the new name is on the right and the value is on the left. it feels backwards, doesn't it
13:46:12 <xplat> the only good thing about the current use of qualified is it allows you to line up your imports in a way that looks really impressive, probably because it reminds people of FORTRAN
13:46:22 <elliott> typoclass: it's consistent with the rest of pattern syntax
13:46:29 <orzo> import Foo (bar as cool,this2)
13:47:26 <typoclass> anyhoo. can i have an implementation for my poorly-thought-out new idea of indentation spaces in the import lines 'repeating' the characters from the previous line?
13:47:43 <FreeFull> Being able to choose if instances get imported would be nice
13:47:45 <typoclass> "import Data.Map ;           .Maybe" <- oh, also, repeat lines have to start with a dot
13:48:02 <elliott> no reason for such a mechanism to be restricted to imports
13:49:32 <typoclass> no reason indeed ... *cough*
13:49:48 <elliott> it can just operate on tokens
13:49:51 <elliott> maybe it should use the unicode ditto mark
13:50:35 <xplat> watch, in 3 minutes this proposal will expand to include ML-style functors, comonad syntax, and a compile-time email reader
13:51:18 <orzo> compile time email reader, nice
13:51:19 <typoclass> elliott: it would special-case indentation inside of import blocks, since we're restricted to one block at the start of a file anyway
13:51:45 <elliott> I don't like it being tied to indentation.
13:51:51 <elliott> looks inconsistent with layout everywhere else.
13:52:17 <dmwit> shell glob syntax for imports, pls
13:52:26 <dmwit> import Data.{Map,Maybe}
13:52:29 <elliott> think rust has that
13:52:33 <Ace_> **/*.c
13:52:35 <dmwit> import Data.Ma{p,ybe} -- YISS
13:52:39 <elliott> haha
13:52:41 <elliott> dmwit++
13:52:43 <typoclass> elliott: well it would be a big table of imports, essentially. (some people already format it that way.) that does look different from regular haskell, yes
13:52:55 <orzo> gcc and probably other c compilers let preprocessor derectives be indented, but {-# LANGUAGE CPP #-} does not.
13:53:17 <orzo> why not?
13:53:31 <elliott> orzo: because it passes -traditional, probably.
13:53:36 <xplat> i guess a separate proposal 'AsciiArtImports' which repeats up to an aligned dot *after a line-initial 'import'* could work
13:54:04 <Lethalman> are the authors of http://www.cse.unsw.edu.au/~chak/papers/BCKR13.html here?
13:54:06 <xplat> oh, and repeating past the end of the module name not allowed
13:54:10 <typoclass> xplat: 'import Data.Maybe ; import     .Map' ?
13:54:17 <xplat> typoclass: yes
13:54:20 <Lethalman> any of them, I'd like to know what rate type variables are
13:54:39 <Lethalman> if I can have a pointer to a definition
13:54:54 <typoclass> anyway. i'm kind of having second thoughts about spaces now, but elliott's unicode ditto mark seems a bit funky as well. what else could we use?
13:55:07 <xplat> Lethalman: $10/hr, doubled over 40 hrs/wk or if GADTs are involved
13:55:46 <eikke> Lethalman: I'm not an author, but what;s your question?
13:56:00 <Lethalman> eikke, what are rate type variables
13:56:30 <Lethalman> rate inference
13:56:57 <eikke> the 'k' things
13:57:16 <dmwit> Lethalman: It's explained in section three...
13:57:57 <eikke> Lethalman: I only read the paper diagonally, but as far as I understood, the rate type variables are the 'k's in e.g. figure 3, and are phantom types used to restrict which operations can be combined
13:58:19 <dmwit> "The rate k of a series is a type level representation of its length,
13:58:19 <dmwit> with the following key invariant: two series of the same rate are
13:58:20 <dmwit> guaranteed to have the same length.
13:58:21 <dmwit> "
13:58:49 <Lethalman> there's also the rate changing operation such as filter thing
13:59:05 <Lethalman> mh ok evidently I have to go further in reading the series paper
13:59:29 * Lethalman just started reading about fusion
14:00:08 <Lethalman> the water's series expression, I only fear a waterfall of papers to read :P
14:03:01 <sclv_> preflex: @bot
14:09:40 <orzo> it might be nice to treat operators specially and tell ghc to import operators unqualified.  Qualifying operators sort of defeats their point.
14:10:16 <elliott> I use qualified operators sometimes.
14:10:21 <ion> ditto
14:10:46 <ion> Usually imported qualified as a single-letter name.
14:11:01 <orzo> well, i do too, sometimes, but my point remains
14:11:16 <orzo> it'd be nice to refer to them collectively while importing
14:12:58 <elliott> yeah, lens has Control.Lens.Operators for this
14:13:05 <Guest55594> I'm still not sure what I should do, I have a grid of things which is wrapped inside some data in StateT, and I need to update values often, but I still want to use pure functions with it. Should I use MVector? or Sequence or something?
14:13:19 <Guest55594> MVector does not appear to play nice with anything at all
14:13:20 <acube> Using haskell filter expressions while importing: import MyModule matching (filter isOperator) :P
14:14:51 <merijn> Guest55594: Depending on how comfortable you are with haskell, there's also the ST monad
14:15:14 <Guest55594> I'm not comfortable with impure stuff like that
14:15:23 <Guest55594> I tried to use ST originally but it was annoying
14:15:24 <merijn> ST monad is pure
14:15:33 <orzo> i <3 ST
14:15:42 <Guest55594> Then what is different from State?
14:15:58 <merijn> Guest55594: It's pure with mutable state
14:15:58 <xplat> merijn: ST is pure on the outside, impure on the inside
14:15:59 <FreeFull> You can make STRefs
14:16:10 <FreeFull> And yeah
14:16:16 <merijn> xplat: Pretty sure it's still pure on the inside too
14:16:38 <merijn> Well, depending on what you mean by inside
14:16:46 <mauke> only in the sense that all haskell is pure
14:16:48 <FreeFull> merijn: If it was, there would be no need to stop STRefs from escaping the monad
14:16:49 <Guest55594> Is there a transformer version of ST?
14:17:03 <merijn> mauke: Well, yes
14:17:17 <FreeFull> Guest55594: I think ST would have to be at the bottom of a transformer stack
14:17:20 <johnw> Guest55594: yes
14:17:21 <Heffalump> Guest55594: no, and there can't be - consider what would happen if the underlying monad was [] or a similar forking monad
14:17:22 <xplat> Guest55594: not really.  there's a 'sort of' one but it's unsafe
14:17:24 <johnw> @hoogle STT
14:17:24 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
14:17:25 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
14:17:25 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
14:17:30 <johnw> there's a package that provides STT
14:17:35 <Heffalump> ok, there is one that someone uploaded, but don't use it :-)
14:17:54 <Guest55594> cause right now I"m using StateT over IO
14:18:06 <FreeFull> ST is basically IO but pure
14:18:16 <johnw> why not just use IORefs then?
14:18:18 <acube> If you use IO anyway, you don't need ST
14:18:21 <Guest55594> I do have IORefs
14:18:23 <acube> Either IO or ST
14:18:28 <Guest55594> but I have data inside another things
14:18:29 <Guest55594> thing
14:18:36 <merijn> FreeFull: IO is also pure, it's just the implementation that isn't :)
14:18:36 <Guest55594> that doesn't have IO with it
14:18:52 <merijn> FreeFull: You probably mean that ST is like IO, but with a way to get out
14:19:00 <eikke> Lethalman: sorry, dropped off the conversation
14:19:07 <Guest55594> that is there's data, which itself is bound to an IORef, but in that data is contained more data which is no longer part of it
14:19:14 <FreeFull> :t runST $ return 3
14:19:14 <lambdabot> Num a => a
14:19:16 <eikke> Lethalman: I'd advise reading some of the earlier papers on stream fusion first
14:19:28 <Lethalman> eikke, ok
14:19:30 <xplat> Guest55594: you can keep IORefs or whatever in data to be accessed by pure code, you just need to be in IO to deref them
14:19:41 <eikke> Lethalman: that might be a better starting point (both the ones about Vector as well as the Repa papers, see e.g. proceedings of Haskell Workshop 2012)
14:19:49 <Guest55594> yeah that means I have to pass down an IO in order to use one specific thing
14:19:50 <FreeFull> merijn: I meant from a runtime perspective
14:19:52 <merijn> :t map newIORef [1..10]
14:19:53 <lambdabot>     Not in scope: `newIORef'
14:19:53 <lambdabot>     Perhaps you meant `newSTRef' (imported from Data.STRef)
14:19:55 <Lethalman> right
14:19:55 <Guest55594> that could be arbitrarily deep
14:19:57 <merijn> aww
14:20:08 <FreeFull> ST can't cause any side effects
14:20:19 <Lethalman> eikke, I'm reading only the accessible ones though, for example the Water's series optimization is not free to read apparently :S
14:20:26 <FreeFull> merijn: lambdabot doesn't allow IO
14:20:30 <merijn> FreeFull: I know
14:20:39 <merijn> Doesn't mean it couldn't check the type of it
14:20:46 <FreeFull> :t map newSTRef [1..10]
14:20:46 <lambdabot> (Enum a, Num a) => [ST s (STRef s a)]
14:20:47 <merijn> :t map print [1..10] -- this works
14:20:48 <lambdabot> [IO ()]
14:20:58 <Guest55594> I know what the type is, I've already used it
14:20:58 <FreeFull> :t sequence_ $ map newSTRef [1..10]
14:20:59 <lambdabot> ST s ()
14:21:04 <merijn> hell
14:21:08 <FreeFull> :t runST . sequence_ $ map newSTRef [1..10]
14:21:09 <lambdabot>     Couldn't match type `ST s0 ()' with `forall s. ST s c0'
14:21:09 <lambdabot>     Expected type: [ST s0 (STRef s0 a0)] -> forall s. ST s c0
14:21:09 <lambdabot>       Actual type: [ST s0 (STRef s0 a0)] -> ST s0 ()
14:21:13 <merijn> :t sequence_ $ map print [1..10] -- this works
14:21:14 <lambdabot> IO ()
14:21:19 <eikke> Lethalman: didnt read that one, not interested :p
14:21:19 <FreeFull> And this is why ST is pure
14:21:28 <Lethalman> oh :)
14:23:08 <Guest55594> yeah but if I have it in an IORef it basically means all my code down to the deepest levels is IO
14:23:17 <ethoma7329> Does anyone know how to convert from CULLong to Word64? (CULLong is the C unsigned long long type). There is a type constructor CULLong Word64 that goes the other way.
14:23:35 <monochrom> fromIntegral
14:23:37 <Guest55594> well actually it's already in state, it's not that big a deal
14:24:12 <monochrom> or, use pattern matching. case x of CULLong y -> now y is your Word64
14:24:44 <monochrom> unless, one day, it changes to Word128 or something. you never know.
14:25:04 <monochrom> after all, not so long ago, CLong changed from Word32 to Word64
14:25:25 <monochrom> (those who have learned from history are doomed to helplessly watch it repeat)
14:25:48 <FreeFull> LongLong
14:26:05 <typoclass> ethoma7329: but yes, fromIntegral is the universal converter function
14:26:08 <monochrom> err, I had a sign error, CULong changed from Word32 to Word64.
14:26:08 <typoclass> @type fromIntegral
14:26:09 <lambdabot> (Integral a, Num b) => a -> b
14:26:18 <monochrom> C U Lang Lang
14:26:18 <ethoma7329> I will definitely have to change stuff then, because it is a 64 bit bit-board for represented a chess position. Thanks - I had tried that but I misinterpreted the error message.
14:26:50 <dmwit> Doesn't C have a real 64-bit type?
14:26:56 <dmwit> uint64 or some such thing?
14:26:59 <Clint> _t
14:27:11 <dmwit> ...or is it just a typedef?
14:27:23 <sipa> does that matter?
14:27:32 <Clint> stdint.h
14:27:32 <sipa> stdint.h defines uint64_t
14:27:36 <Lethalman> eikke, I believe I've understood the idea behind that paper, is something like that probable to improve ghc or it's not something worth in practice?
14:27:46 <sipa> how it defines it is not something you should care about :)
14:27:46 <monochrom> it is always a typedef. but it always typedefs to the right thing
14:27:48 <dmwit> It matters because if it's not a real type, Haskell's FFI won't have a real counterpart.
14:28:12 <merijn> dmwit: It's a typedef in most implementations, but it's a typedef that's guaranteed to be 64bit integer
14:28:35 <dmwit> merijn: see my last sentence
14:29:22 <monochrom> you can #include <HsFFI.h> and then use HsWord64 :)
14:29:55 <eikke> Lethalman: it's not really related to ghc itself, since it's implemented completely outside of the 'standard' compiler. but looking at their benchmark numbers, it does look encouraging. Also see some blogposts about repa & disciple
14:30:15 <monochrom> in fact, look: "unsigned integral type, 64 bit; uint64_t if available". right in Haskell 2010
14:30:29 <xplat> dmwit: i stopped keeping track of the C standards before that happened ... but it's probably something like 'a typedef, whose actual definition is implementation-defined, but whichever type it resolves to must be a 64-bit unsigned word or thereabouts'
14:30:33 <Peaker> monochrom, why did HsFFI duplicate stdint.h? :(
14:30:34 <Lethalman> eikke, you mean it's some transformation that can be done outside of ghc? i.e. transforming the haskell code itself?
14:30:49 <ethoma7329> Does anyone have any idea about the computational costs of changing from CULLong to Word64 and for fromIntegral? Or do they get taken away when compiling?
14:30:51 <eikke> Lethalman: it's based on a ghc plugin (which runs in the compiler, but is not part of ghc itself)
14:31:00 <monochrom> I don't know. redundancy implies fault tolerance? :)
14:31:19 <eikke> Lethalman: unlike standard stream fusion as implemented by vector/bytestring/text which is based on rewrite rules only
14:31:30 <Lethalman> eikke, I see, I mean is it something that can interest ghc people or it's the kind of thing that won't be considered?
14:32:07 <eikke> Lethalman: that's not up to me to say :) I'd think, as long as things like this can be implemented as a plugin, they shouldn't become part of ghc core, not to complicate the compiler even more
14:32:15 <Philippa> Lethalman: half the point of GHC plugins is you can grab and use them anyway
14:32:36 <Philippa> I mean, I for one won't complain if we end up with a range of sensible/useful plugins in the Platform in the long run?
14:32:56 <xplat> if it becomes popular enough it'll probably become part of GHC, at least in the sense of being packaged and tested with the distribution
14:33:06 <andrewsw> is there a way to remove certain cost centers from a heap profile?
14:33:06 <Lethalman> Philippa, are these plugins installable from cabal or they require a particular build?
14:33:07 <eikke> Philippa: most plugins are very tightly bound to specific library implementations, so there's quite a link there
14:33:29 <xplat> (or yeah, maybe platform instead, depending how practical that turns out to be)
14:33:31 <eikke> Lethalman: plugins can be part of any library, so can be installed using cabal
14:33:34 <monochrom> ethoma7329: it's a newtype, therefore there is no such overhead.
14:33:37 <Lethalman> oh
14:33:45 <andrewsw> I have some large objects that don't grow that I don't care about in favor of many small things that grow slowly that I'd like to observe
14:33:49 <Lethalman> eikke, like this? http://hackage.haskell.org/package/stream-fusion
14:33:57 <monochrom> it's only overhead in source code you write, not in generated code
14:34:07 <Lethalman> or maybe not mh
14:34:39 <eikke> Lethalman: that's not a plugin
14:35:47 <eikke> Lethalman: that's a library implementing stream fusion over lists (check the source of Data.List.Stream and the 'RULES' pragmas in there)
14:38:25 <Lethalman> this seems to be a plugin: https://github.com/ku-fpg/hermit/tree/master/optimizations/streamfusion/hermit-streamfusion
14:38:39 <Lethalman> interesting to see plugins into a compiler
14:39:04 <Lethalman> gtg, thanks :-)
14:39:18 <eikke> hermit is a rather complicated on ;)
14:39:41 <eikke> there was some 'simple' plugin related to automatic strictness based on some 'fake' '* -> *' type
14:42:02 <canta> well.. I give up on trying to fix bugs for now.. but I guess I got pretty good at adding traces.
14:42:15 <eikke> Lethalman: http://hackage.haskell.org/trac/ghc/wiki/NewPlugins links to some plugins by thoughtpolice which might be easier than hermit
14:46:41 <djahandarie> dolio, I vaguely wonder how you were coerced into being on that libraries committee... :P
14:47:29 <simon> @pl \x y z -> f x y z a b
14:47:30 <dolio> Temporary insanity.
14:47:32 <lambdabot> flip (flip . (flip .) . flip (flip . (flip .) . f) a) b
14:47:32 <lambdabot> optimization suspended, use @pl-resume to continue.
14:47:59 <djahandarie> That'll do it
14:48:03 * eikke would love to get into one of those things one day
14:48:36 <typoclass> djahandarie: i assume the coercing was an unsafe affair
14:48:36 <elliott> dolio is edwardk's second vote
14:49:36 <Taneb> I would one day like to be on one of these magic committees but I do not feel awesome enough to nominate myself for one
14:50:06 <quchen> Joining the mailing lists gets you into a committee for free.
14:50:13 <djahandarie> Everyone thinks they want to be on a committee
14:50:18 <djahandarie> Except those on committees
14:50:29 <eikke> Taneb: heh, that's the hard part :) sometimes I like the system where people suggest others
14:50:52 <monochrom> I use the mathematical idea of "inversion". I am in a committee!
14:51:30 <typoclass> itty bitty one-man committy
14:51:40 <Peaker> backlogging for a sec here, I'm guessing it is in fact safe to assume Word32 is usable in FFI context where uint32_t is expected, and ditto for the other sizes/signedness?
14:51:54 <monochrom> yes
14:52:57 <monochrom> since your C compiler does provide uint32_t anyway. then the Report's "if" clause kicks in. that nails it.
14:54:41 <sclv_> does anyone want to volunteer for responsibility without authority?
14:54:47 <sclv_> speaking of committees?
14:54:51 <johnw> I love for such things!
14:54:52 <johnw> sign me up
14:54:55 <johnw> s/love/live
14:55:07 <johnw> I have some strange kind of IRC dyslexia.  I think of one word, but type another
14:55:14 <merijn> sclv_: Depends on which responsibility? :p
14:55:17 <merijn> johnw: High five
14:55:21 <merijn> Me too
14:55:26 <sclv_> haha yes you are already going to be a victim
14:55:35 <sclv_> erm, i mean volunteer
14:55:36 * eikke was on an enterprise-style commitee once designing a spec for some RESTful XML based access to some systems
14:55:47 <sclv_> we might want some new admins for haskell community infrastructure
14:55:48 <eikke> the subject was boring, but I did like the way of working
14:56:01 <socumbersome> Hi. I have two mains and the first one yields a parse error - why?
14:56:06 <socumbersome> http://hpaste.org/90062
14:56:14 <sclv_> ideally ppl who are known enough that we'd trust them
14:56:28 <sclv_> but somehow not so insanely busy that they're not going to get anything done
14:56:34 <merijn> sclv_: I'd be game
14:56:37 <sclv_> lots of details still to be worked out
14:56:43 <merijn> Depending on how much time would need to be sunk in it
14:56:48 <shachaf> Hackage going down regularly is part of the rustic charm of Haskell!
14:56:58 <eikke> what exactly is 'haskell community infra'? server infra?
14:57:06 <johnw> @remember shachaf Hackage going down regularly is part of the rustic charm of Haskell!
14:57:06 <lambdabot> Nice!
14:57:35 <sclv_> merijn: cool -- i'll put you on my possibilities list.
14:58:09 <Peaker> socumbersome, I've used Haskell for years, and I don't yet know the rules regarding braces.. people don't really use them in real code, mostly in auto-generated Haskell code
14:58:27 <Peaker> socumbersome, I would assume it's the trailing semicolon, semicolons are separators rather than terminators, iirc
14:58:57 <typoclass> oddly, it says "parse error on input putStrLn" ...
14:59:01 <socumbersome> but even after deleting the last semicolon I get the same error
14:59:07 <monochrom> socumbersome: let {danePrzetworzone = parsujDane daneWejsciowe};
14:59:07 <typoclass> Peaker: i suspected that as well, but doesn't seem to be true
14:59:14 <eikke> sclv_: ^^
14:59:30 <monochrom> trailing semicolon is allowed and optional
14:59:57 <monochrom> in fact, leading semicolon too, for do-notation at least
14:59:59 <socumbersome> aaaah, ok! Thanks monochrom!
15:02:55 <shachaf> sclv_: I could possibly do it, depending on what "it" is.
15:03:05 <Peaker> typoclass, oh, because "do let" vs. "let .. in"
15:03:05 <monochrom> I think what happened is this. after de-layouting (and note that there are some explicit {;}s but not entirely), the token stream goes like this: do { whatever; let { x = y z ; } putStrLn "abba" ; }
15:03:15 <eikke> shachaf: exactly
15:03:54 <elliott> sclv_: I volunteer to be in the position with the most power and the least effort and oversight!
15:04:15 <elliott> sclv_: and the one with loosest background checks for evil.
15:04:21 <johnw> elliott: he was offering responsibility, not power
15:04:45 <elliott> johnw: with great power comes great responsibility. ergo, with great responsibility comes great power. Q.E.D.
15:04:54 <typoclass> 90 W
15:05:26 <johnw> great power => great responsibility, but not <=>
15:05:52 <elliott> johnw: careful or you may find your access to haskell infrastructure disrupted in the near future!!
15:06:26 <johnw> hmm
15:06:35 <johnw> with great criticism comes great consequences
15:07:25 <shachaf> johnw: I think elliott knows that much logic, and was saying those things he was saying entirely with humorous intent.
15:07:37 * johnw was being humorous too
15:08:11 <typoclass> sclv_: so, as a first step you're essentially asking for people to join the haskell-infrastructure list and do stuff that will be discussed there?
15:08:14 <elliott> no, I actually plan to become an evil genius and take over the world. haskell infrastructure is just step one.
15:10:41 <shachaf> One could make the argument that taking over haskell infrastructure is the opposite of genius.
15:10:52 <eikke> haha
15:16:28 <merijn> shachaf: He's just banking on haskell winning the PL revolution, so that once that happens he can flip the switch and control the world
15:17:16 <Guest17000> Hello people of the internet, can anyone recommend a good book for advancing my knowledge of haskell?
15:17:23 <johnw> @where lyah
15:17:24 <lambdabot> http://www.learnyouahaskell.com/
15:17:35 <johnw> you haven't told us how much Haskell you already know, though
15:17:42 <typoclass> Guest17000: hello, sure! try lyah, as johnw linked
15:17:50 <typoclass> @where rwh
15:17:50 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:18:03 <typoclass> Guest17000: here's another possibility (also available for free) ^^
15:18:29 <Guest17000> thank you!
15:19:39 <dmwit> ?where tutorials
15:19:40 <lambdabot> http://haskell.org/haskellwiki/Tutorials
15:20:28 <typoclass> Guest17000: oh, i forgot that -- check out http://tryhaskell.org/ :-)
15:20:53 <typoclass> Guest17000: (not a book, but it has some lessons and is practical)
15:21:14 <Guest17000> thanks :)
15:29:33 <cin> fixed hpaste. announcer was disabled by spam changes, and fixed the weird backslash stuff
15:30:59 <typoclass> cin: thanks! sounds good
15:31:48 <elliott> cin: (are you chrisdone?)
15:47:11 <cin> elliott: oh, yeah. this is my collision nick
15:52:03 <johnw> cin: hey man!
15:52:13 <monochrom> left
15:52:15 <typoclass> johnw: he's gone. elliott spooked him
15:52:17 <shachaf> right
15:52:19 <johnw> ah, well
15:52:26 <johnw> that's what I get for not seeing parts/joins
15:52:39 <johnw> (chrisdone is johnw's co-worker)
15:53:46 <merijn> oh, github's new repo layout is looking neat
15:53:47 <shachaf> (shachaf likes talking about himself in third-person too)
15:54:19 <johnw> (a man likes talking about himself in the indefinite third-person)
15:55:06 <merijn> This one likes talking about himself in third-person too
15:55:10 <typoclass> (one can cause quite some groaning by referring to oneself as one)
15:55:26 <johnw> A man agrees with one
15:55:38 <typoclass> it is agreed
15:55:42 <johnw> ooh
15:55:46 * hackagebot java-bridge 0.9 - Bindings to the JNI and a high level interface generator.  http://hackage.haskell.org/package/java-bridge-0.9 (JulianFleischer)
15:55:46 <johnw> passive voice, the ultimate
15:55:48 * hackagebot java-bridge-extras 0.9 - Utilities for working with the java-bridge package.  http://hackage.haskell.org/package/java-bridge-extras-0.9 (JulianFleischer)
15:56:19 * monochrom always talks to himself. it adds spices to his conversations
15:56:37 <simon> typoclass, it is known.
15:56:41 <merijn> typoclass: This one thinks you should prefer the Khajiti style of refering to ones self
15:56:45 <shachaf> CoYoneda . Is = (->)
15:56:59 <monochrom> change 'the one thinks" to "it is thought" :)
15:57:18 <elliott> shachaf: clearly CoYoneda should be the fundamental construct.
15:57:37 <shachaf> It already is fundamental as far as I'm concerned!
15:57:43 <monochrom> it is thought the Khajiti style should be preferred by you
15:57:53 <typoclass> CoYoneda . Is, CoYoneda . ShouldBe
15:58:18 <merijn> monochrom: No, Khajit refer to themselves as "this one"...
15:58:27 <shachaf> data MightBe a b where Is :: MightBe a a; Isn't :: MightBe a b
15:58:32 <monochrom> ok!
15:58:35 <merijn> @quote Neither
15:58:35 <lambdabot> jack-nicholson says: You only lie to two people in your life, Linux fanboys and the police. Neither can handle the truth.
15:58:39 <merijn> blah
15:58:43 <merijn> @quote data.Neither
15:58:43 <lambdabot> Berengal says: data Neither a b = Left | Right
15:58:49 <typoclass> merijn: i don't know who khajiti is but i don't like him on account of based on he talks funny
15:58:59 <johnw> typoclass: Elder Scrolls games
15:59:13 <merijn> typoclass: http://images1.wikia.nocookie.net/__cb20120124104241/elderscrolls/images/4/44/SepLnUp_Khajiit_a1%26c1.png
15:59:24 <merijn> typoclass: They're cat people in the Elder Scrolls games :p
15:59:27 <typoclass> merijn: awww kitty
15:59:46 <johnw> and... we have morphed into -blah
16:00:02 <typoclass> merijn: they talk through white text on pictures, bad spelling, and idiotic jokes?
16:00:04 <merijn> johnw: Mission accomplished
16:00:46 * hackagebot haskell-reflect 0.9 - Reflect Haskell types.  http://hackage.haskell.org/package/haskell-reflect-0.9 (JulianFleischer)
16:00:48 * hackagebot java-reflect 0.9 - Tools for reflecting on Java classes.  http://hackage.haskell.org/package/java-reflect-0.9 (JulianFleischer)
16:02:36 <FreeFull> data Meh a b = Meh
16:04:05 <monochrom> data Plot_twist a b = forall c. Murderer_is c
16:05:46 * hackagebot j2hs 0.9 - j2hs  http://hackage.haskell.org/package/j2hs-0.9 (JulianFleischer)
16:06:46 <hpc> data Shyamalan a = NopeIt'sActually b
16:08:00 <blaenk> hey cabal doesn't come with haskell platform on windows right?
16:08:04 <blaenk> that was my understanding
16:08:10 <elliott> it does
16:08:14 <blaenk> http://www.haskell.org/cabal/download.html
16:08:19 <blaenk> oh it does?? it never installs for me
16:08:21 <hpc> the platform is the same set of stuff everywhere
16:08:27 <hpc> it'd be a pretty shitty platform otherwise
16:08:39 <blaenk> last time I installed cabal by downloading the prebuild cabal.exe from that page
16:08:40 <blaenk> ^
16:08:49 <blaenk> but I noticed its version 0.14 or whatever and I think there's a newer version
16:09:00 <blaenk> but yeah, I don't see cabal.exe anywhere
16:09:10 <blaenk> checked C:\Program Files (x86)\Haskell Platform\2013.2.0.0\bin and it's not there
16:09:17 <hpc> hmm
16:09:52 <typoclass> blaenk: it might be present somewhere, but not be in your PATH? although i thought the installer would do that for you
16:10:02 <blaenk> I think it's in another directory actually
16:10:06 <blaenk> I'll try reinstalling very quickly
16:10:09 <blaenk> just installed now anyways
16:10:37 <blaenk> the HP installer/uninstaller is broken I think though. when it gets to the end where it prepends PATH, it outputs that message every 10 minutes, I eventually have to kill the process
16:10:44 <blaenk> did that last time I installed and everything worked fine
16:10:46 * hackagebot hermit 0.2.0.0 - Haskell Equational Reasoning Model-to-Implementation Tunnel  http://hackage.haskell.org/package/hermit-0.2.0.0 (AndrewFarmer)
16:11:27 <typoclass> blaenk: indeed. that sounds weird
16:11:34 <johnw> blaenk: except that you didn't get cabal
16:11:54 <hpc> i personally go with an install of ghc + cabal + cabal-dev
16:12:05 <hpc> perhaps that will have better luck?
16:12:05 <blaenk> hpc: on windows?
16:12:09 <hpc> in general
16:12:14 <blaenk> have you tried it on windows though
16:12:20 <blaenk> windows is something of an edge case sometimes
16:12:28 <blaenk> on linux I indeed don't use haskell platform
16:12:32 <blaenk> just ghc + cabal etc
16:12:49 <merijn> There's no pointfree way to do record update (without writing your own function for it), right?
16:13:04 <merijn> I installed platform on Windows 7 not too long ago, worked fine then
16:13:27 <hpc> merijn: lenses
16:13:41 <johnw> outside of lenses, no
16:14:01 <johnw> and even then, you either writing your own function by hand, or generating one via TH
16:14:52 <shachaf> Yes, lenses aren't magic. You are still writing your own function for it, it just has a standardized API.
16:15:48 <FreeFull> Lies
16:15:57 <FreeFull> Lenses are magic
16:16:15 <hpc> but i thought monads were magic?
16:16:56 <FreeFull> Monads are about as magical as horseshoes
16:17:11 <johnw> you mean, people hang them over their doors?
16:17:42 <johnw> "Abandon all hope of exit, ye who enter here (by return'ing, strangely enough)
16:18:52 <FreeFull> Oh, many monads have exits
16:19:01 * shachaf is tired of the "you can't escape a monad!!" thing.
16:19:16 <johnw> you can't except using Monad
16:19:21 <johnw> escape
16:19:33 <shachaf> And you can't escape a Foldable either.
16:19:35 <FreeFull> What would the sign for comonads be?
16:19:38 <shachaf> Or can you?
16:19:46 <johnw> shachaf: then we need more Foldable tutorials, clearly
16:19:49 <shachaf> OK, perhaps a bad example.
16:20:22 <johnw> i'm unreasonably excited about the AMP proposal
16:20:28 <FreeFull> "Abandon all hope of entrance, ye who exit here (by extract'ing, not that strange)"
16:21:35 <jmcarthur_mobile> AMP? What's that?
16:21:46 <johnw> that Applicative will be a superclass of Monad soon
16:22:00 <tac> woo
16:22:12 <jmcarthur_mobile> Ah, yeah that rocks.
16:22:19 <shachaf> You *could* just say Applicative m => Monad m or something like that.
16:22:24 <FreeFull> Will Monoid be a subclass of Semigroup?
16:22:25 <shachaf> Acronymitis is a disease.
16:22:53 <johnw> FreeFull: that didn't garner as much interest, sadly
16:23:03 <johnw> some, but not overwhelming approval as AMP did
16:23:22 <shachaf> If Semigroup m => Monoid m, then you'll need Apply m => Applicative m to match.
16:23:31 <johnw> right
16:23:39 <johnw> and people were about as excited about Apply as they were about Pointed
16:23:46 <johnw> which is to say, not much
16:24:28 <jmcarthur_mobile> I'd be more excited about apply than pointed.
16:24:55 <johnw> and then why not (Applicative m, Bind m) => Monad m, while we're at it
16:25:03 <jmcarthur_mobile> Pointed seems about as useful as Default to me, which is to say, not very useful. :p
16:25:17 <shachaf> jmcarthur_mobile: But affine traversals!
16:26:47 <jmcarthur_mobile> Affine traversals? Sound interesting, but I don't know what it is.
16:27:45 <shachaf> A traversal onto 0 or 1 values.
16:27:51 <shachaf> E.g. any prism is an affine traversal.
16:27:57 <blaenk> hey what do you know, it did come with cabal 1.16
16:27:58 <shachaf> Also called a "partial lens"
16:28:52 <shachaf> AffineTraversal s t a b = s -> Either t (a, b -> t)
16:28:55 <shachaf> Or something like that.
16:29:41 <blaenk> in case anyone cared, cabal on windows haskell platform is in: C:\Program Files (x86)\Haskell Platform\2013.2.0.0\lib\extralibs\bin
16:30:26 <blaenk> I realized what the problem was
16:30:45 <blaenk> well, more or less. like I said, the installer/uninstaller takes about 15-20 minutes between PATH prepending operations, for some reason
16:31:05 <blaenk> I don't know if it's actually doing some work during that time, compiling a package or something, perhaps that would explain that
16:31:16 * johnw wonders if shachaf is a world expert on affine traversals by now
16:31:18 <blaenk> one of the last prepends it makes is to prepend that extralibs\bin path
16:31:40 <blaenk> I guess last time when I terminated the process (because I thought it went bad) it didn't prepend the path cabal was in, all is good now :)
16:32:03 <shachaf> It is not difficult to be world expert on affine traversals.
16:33:01 <merijn> blaenk: Sounds odd, I can't remember it taking that long for me
16:33:09 <blaenk> yeah I can't account for it either
16:33:23 <merijn> blaenk: Might want to reach out to the Platform people to see if maybe you can help them diagnose the issue?
16:33:24 <blaenk> my only suspicion is that it's compiling something but I didn't think it would be doing that, figured it already came with binaries
16:33:33 <blaenk> yeah I'll look into that
16:34:12 <merijn> Oh!
16:34:35 <merijn> I just realised I can use my restrict trick to write functions that accept all except one type
16:34:39 <merijn> This is neat
16:34:57 <johnw> merijn: oh, that's pretty neat!
16:35:06 <johnw> go, merijn, go
16:35:09 <merijn> Well, except a set of types really
16:35:34 <johnw> i should setup a GHC HEAD environment on this machine soon
16:35:48 * hackagebot j2hs 0.9.1 - j2hs  http://hackage.haskell.org/package/j2hs-0.9.1 (JulianFleischer)
16:36:18 <merijn> hmm
16:36:35 <merijn> I'd have to resort back to the (a ~ Void) trick, though
16:36:48 <merijn> Because I don't think there's a vacuous Constraint yet
16:37:45 <johnw> what is a vacuous constraint?
16:38:45 <merijn> One that never holds
16:39:45 <merijn> i.e. if my type family returns a Constraint I might want to return a Constraint that can never hold to prevent something from happening
16:39:52 <johnw> i see
16:39:56 <merijn> Right now I'm just faking that by using type equality to Void
16:40:58 <merijn> johnw: Like this: http://hpaste.org/90068
16:41:11 <merijn> id for any type that is not () :)
16:41:34 <johnw> and for () it's a type check failure?
16:41:46 <merijn> Well, there's some ugly things there, for example "foo 1" doesn't type check, since there might be a Num instance for ()
16:41:49 <merijn> johnw: Yup
16:42:01 <johnw> A Haskeller likes
16:42:02 <merijn> johnw: Well, there's a type check failure for non-concrete types too :p
16:42:33 <merijn> "foo 1 :: Int" works, though
16:43:20 <merijn> And probably GHC isn't smart enough to infer that a constraint like that on a GADT restricts some cases
16:49:32 <Ralith> Enigmagic: you around?
16:55:15 <joelteon> can you add dependencies in .cabal if a flag is true?
16:55:19 <jnerula> @src fromJust
16:55:19 <lambdabot> fromJust Nothing  = undefined
16:55:19 <lambdabot> fromJust (Just x) = x
16:55:48 <merijn> joelteon: I believe so, but I'm not sure how
16:56:15 <merijn> jnerula: As should be clear from that source, you should never use fromJust
16:56:15 <joelteon> I don't wanna list out two separate build-depends fields
16:56:19 <blaenk> lol joelteon nice name
16:56:27 <blaenk> have a friend over named Joel imma go tell him it
16:56:44 <joelteon> my name is joel too
16:56:45 <joelteon> :x
16:56:51 <blaenk> yep, that's the point xD
16:57:27 <joelteon> I guess I have to specify two dependency lists
16:59:49 <joelteon> but I have a lot of dependencies and 4 separate possibilities at least
17:00:07 <joelteon> 32, actually, so that makes 128 total
17:00:28 <c_wraith> how is it you have that many possible dependencies?
17:00:43 <joelteon> well, one flag turns one dependency on/off, and the other turns another on/off
17:00:57 <joelteon> so I could have both off, 1 on/2 off, 1 off/2 on, or both on
17:01:13 <c_wraith> 128 total would be 7 binary flags
17:01:19 <joelteon> would it?
17:01:26 <joelteon> no, but I have 32 items in the list
17:01:38 <joelteon> no, I mean, 128 total dependencies listed
17:01:43 <c_wraith> ah.
17:01:44 <joelteon> but most of them would be specified 4 times
17:01:52 <joelteon> and it wouldn't be 128, it would be 124
17:01:57 <joelteon> but that's a minor detail
17:04:20 <joelteon> (also, this is an executable, not a library, so I'm not using binary flags to specify API endpoints)
17:04:26 <c_wraith> I figured as much
17:04:37 <c_wraith> Just because I can't think of any lib with that many dependencies
17:04:44 <joelteon> yesod maybe
17:05:03 <joelteon> huh, nope
17:05:11 <c_wraith> One thing to note, you can have multiple Build-depends sections
17:05:19 <joelteon> oh, that is useful
17:05:32 <c_wraith> This means that you can put everything that's common at the top level for the executable
17:05:41 <c_wraith> and only have the things that vary inside the ifs
17:05:51 <joelteon> hey, that's it!
17:05:58 <joelteon> I should've tried that before
17:07:04 <c_wraith> Hopefully that makes it sane to maintain. :)
17:16:57 <blaenk> merijn: haha about one hour it took to finish installing
17:23:34 <blaenk> what part of Haskell makes it possible for aeson's implicit parsing, or whatever it's called, where you just do instance FromJSON SomeType and it can somehow figure out how to do it
17:23:49 <blaenk> could it be that SomeType derives Generic?
17:23:54 <blaenk> guess I'll look into what that is
17:24:00 <elliott> probably that yes
17:26:21 <blaenk> elliott: oh okay yeah it seems like it's that
18:20:55 <Zoxc> There aren't any extensions which allows a type class passed a specific type to have different type class instances in a single program right?
18:21:51 <shachaf> What?
18:22:55 <Zoxc> Typeclass Int can't have two different typeclass instances in two different modules for example
18:23:27 <shachaf> Int isn't a type class.
18:23:33 <shachaf> Oh, you mean a type class called "Typeclass"?
18:23:42 <shachaf> Yes, there can only be one instance for a type.
18:23:51 <JoeyA> Will the compiler check for that?
18:23:55 <JoeyA> What about orphan instances?
18:24:12 <shachaf> If you have two orphan instances you'll get in trouble.
18:25:03 <enthropy> you could have overlapping instances like:   instance C a;  instance C Int, which could be seen as two instances for the same type (since 'a' could be Int)
18:26:21 <Zoxc> enthropy: But will the compiler always pick the more specific one, even across modules?
18:26:44 <enthropy> well it can't pick the more specific one if it isn't in scope
18:27:12 <byorgey> Zoxc: what enthropy is describing is only even allowed if you enable the OverlappingInstances extension, which is generally not a good idea
18:30:36 <Zoxc> Would limiting overlapping instances only to a instance in a single module prevent having the code generation of a module depend on which modules requires it?
18:31:56 <Zoxc> Which could be viewed as a single instance whose behavior depends on the type it's passed
18:32:42 <Zoxc> Doesn't the type family branches work like that?
18:36:08 <byorgey> Zoxc: I'm not sure
18:36:53 <DiegoNolan> anyone familiar with blaze and snap?
18:37:09 <shachaf> There's a channel for it, I think.
18:37:11 <shachaf> @where web
18:37:11 <lambdabot> #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
18:37:24 <DiegoNolan> hmm
18:37:35 <DiegoNolan> it's more of a blaze problem
18:37:47 <DiegoNolan> my image tag isn't linking correctly to the src of the img
18:37:51 <DiegoNolan> and the paths look fine
18:37:55 <DiegoNolan> far as i can tell
18:38:27 <shachaf> Well, I can't help you with Blaze, but I can help you with the rules of asking questions. The first one is to just ask your question rather than wait for someone to volunteer.
18:39:03 <DiegoNolan> k
18:39:12 <DiegoNolan> i think it's mroe of an html problem anyway
18:40:08 <graphs_howDoThey> I have some questions about Martin Erwig's FGL. First question, I saw some stuff about a "rewrite" in the works. Did this ever happen, or is there only one version of FGL?
18:41:37 <c_wraith> graphs_howDoThey: I think it did, given that the version on hackage is maintained by a couple other people and starts at version 5.3.  I think I recall that rewrite happening a couple years ago
18:42:15 <graphs_howDoThey> c_wraith: Aright.
18:45:15 <graphs_howDoThey> Okay, so another question about FGL. I read Martin Erwig's abstract, and it described something about an underlying BST data structure. I didn't see this in the hackage source. I couldn't quite visualize the implementation (kind of surprising he didn't make an image since he did nicely for other things)
18:48:11 <thoughtpolice> actually i don't think ivan ever published the big FGL update, the code repository has two packages and one is fgl-5 and the other labeled fgl 6
18:48:33 <Cale> http://hackage.haskell.org/packages/archive/fgl/5.4.2.4/doc/html/src/Data-Graph-Inductive-PatriciaTree.html#Gr
18:48:48 <graphs_howDoThey> Cale: TY
18:48:50 <Cale> Graphs are just IntMaps
18:52:31 <anonlsdljsdflsdn> Hi, everyone.  I'm just getting started with Haskell, and I'm trying to visualize some 3D structures.  What is the haskell equivalent for software like Jmol or PyMol?
18:58:05 <monochrom> today I use pattern guard in production code for the first time!
18:58:19 <monochrom> oh wait, what's its syntax again?
18:58:49 <canta> list comprehensions often contain guards if i remember correctly
18:59:04 <byorgey> monochrom: pat ::= (expr -> pat)
18:59:26 <byorgey> monochrom: congrats =)
18:59:40 <byorgey> oh, you said pattern guard
18:59:44 <byorgey> I was thinking view pattern
18:59:57 <arkeet> f ... | pat <- expr = ...
19:00:05 <byorgey> that's the one
19:00:07 <monochrom> case matchRegexAll r x of { Just (p, d, s, _) | Nothing <- matchRegex s d -> ...
19:00:26 <arkeet> or in a case sure.
19:00:28 <byorgey> sure enough, that's a pattern guard
19:01:02 <monochrom> so, x should match r, but a portion of it, called d, should not match s. then I do something.
19:03:44 <monochrom> guess what, I may probably merge that with its context to yield:
19:04:32 <monochrom> go (x:xs) | Just (p, d, s, _) <- matchRegexAll r x, Nothing <- matchRegex s d  =  (x, p, d, s) : go xs
19:05:00 <monochrom> err I have two "s"s and they mean different things
19:05:06 <monochrom> go (x:xs) | Just (p, d, s, _) <- matchRegexAll r x, Nothing <- matchRegex t d  =  (x, p, d, s) : go xs
19:05:39 <monochrom> anyway, the first time I use pattern guards for real, I use two of them at once!
19:05:54 <byorgey> when it rains it pours
19:06:26 <shachaf> "expedious" should be a word.
19:07:08 <elliott> @wn expedious
19:07:09 <lambdabot> No match for "expedious".
19:07:12 <elliott> gosh, really.
19:07:48 <byorgey> @wn expeditious
19:07:53 <lambdabot> *** "expeditious" wn "WordNet (r) 3.0 (2006)"
19:07:55 <lambdabot> expeditious
19:07:57 <lambdabot>     adj 1: marked by speed and efficiency
19:08:13 <byorgey> @wn expedient
19:08:14 <lambdabot> *** "expedient" wn "WordNet (r) 3.0 (2006)"
19:08:14 <lambdabot> expedient
19:08:14 <lambdabot>     adj 1: serving to promote your interest; "was merciful only when
19:08:14 <lambdabot>            mercy was expedient" [ant: {inexpedient}]
19:08:14 <lambdabot>     2: appropriate to a purpose; practical; "in the circumstances it
19:08:16 <lambdabot> [3 @more lines]
19:08:28 <shachaf> Neither of those are pronounced like (x,p,d,s).
19:08:34 <byorgey> oh, hehehe
19:09:07 <shachaf> s/are/is/, I suppose.
19:15:52 <richo> Can I refer to types as first class values?
19:16:15 <shachaf> Types aren't first-class in Haskell, no.
19:16:20 <richo> I'd like to pass a type into a function, in order to partially apply and return a function that pattern matches on the type initially passed in, if that makes sense.
19:16:41 <richo> Oh, ok so that's not something I can do? I have this working, but there'll be a lot of copypasting to be done as I add more types to this system.
19:16:53 <tabemann> you can't do that in Haskell
19:16:54 <shachaf> That sounds like the sort of thing you oughtn't do, but there might be ways to do it.
19:17:04 <shachaf> But it's more likely that there's a better solution to your higher-level problem.
19:17:16 <richo> If I show you the specific part of the code, you might have a netter idea. One second, I'll add some comments
19:17:37 <tabemann> if you want first-class types, the only languages I can think of that have those are some dependent-type-ish languages, like Agda....
19:18:08 <richo> https://gist.github.com/5802164
19:18:15 <richo> I'm working through the wikibook on building a scheme in haskell
19:19:15 <shachaf> richo: It looks like there's only one type there anyway?
19:19:32 <tabemann> that looks like you're just using data constructors for an algebraic data type there
19:19:33 <richo> for now, because while it wasn't compiling I was keeping it simple
19:19:39 <richo> but it'd support Number etc
19:19:47 <elliott> Agda can't "pattern-match on types". but it looks like what richo wants to do is perfectly possible because they are modelling a language's type system as a single type inside haskell. embedded types, not real haskell types
19:20:05 <tabemann> so then you make a constructor Number for the type LispVal
19:20:34 <shachaf> richo: What are the types here? The only one I see is LispVal.
19:20:38 <richo> I'll gist the whole file, I think I have that
19:20:43 <tabemann> elliott: yeah, I don't see anything odd about what richo is doing from actually seeing richo's code
19:20:48 <richo> https://gist.github.com/5802175
19:20:50 <shachaf> richo: Atom and Number and so on look like constructors, not types.
19:20:53 <richo> Sorry, I'm very new to haskell
19:21:21 <richo> Oh, right. Sorry, I'm using the wrong terms
19:21:22 <shachaf> (By the way, you should use pattern-matching instead of head. But that's orthogonal to everything else here.)
19:21:42 * tabemann seconds the thought about head
19:21:56 <tabemann> unpackNum should also return a Maybe Integer, not an Integer
19:22:20 <tabemann> as returning 0 for where it should return Nothing is bad practice
19:23:18 <shachaf> I'm not sure I quite follow what these functions are trying to do.
19:23:38 <shachaf> One solution is probably lens's Prisms, but I won't recommend that if you're just learning the language. :-)
19:24:35 <shachaf> As it is you might have to write a small predicate function for isFoo, i.e. isNumber :: LispVal -> Bool; isNumber (Number _) = True; isNumber _ = False
19:24:47 <shachaf> Then you can have a function which takes isNumber as a parameter.
19:26:33 <anonlsdljsdflsdn> Hi, everyone.  I'm just getting started with Haskell, and I'm trying to visualize some 3D structures.  What is the haskell equivalent for software like Jmol or PyMol?
19:28:26 <richo> shachaf: that's totally on my todo list, currently it ignored all the other arguments
19:29:25 <tabemann> typically it's good practice to have functions handle *all* possible arguments
19:29:52 <tabemann> functions which don't, i.e. partial functions, are not good practice, despite there being quite a few of them in the Prelude
19:30:12 <Moggle_> bloody windows
19:30:16 <Moggle_> why do i even bother programming on you
19:30:18 <shachaf> richo: What I'm suggesting is that you make simple functions like the one I mentioned, and then build up bigger functions out of them.
19:30:52 <shachaf> Of course I called my isNumber the same name as yours, even though it's a different function...
19:31:13 <shachaf> But think of how you can make your big isNumber out of my little isNumber.
19:32:41 <richo> Sculptor_: Ah, I think I see what you mean. I'll try that this afternoon
19:32:46 <richo> shachaf: **
19:33:20 <richo> So if I'm understanding this right though, Types aren't first class, but Constructors are? So I could feasibly pass the constructor names around like I'm trying to (but it would be considered distasteful?)
19:33:39 <shachaf> Constructors are also not really first-class, I'd say.
19:34:01 <shachaf> A prism is kind of like a first-class constructor (but never mind about that).
19:34:20 <richo> ok. It sounds like I should compose isOfType out of a bunch of smaller is[Foo] methods, and just pass about some enum'esque keys for the individual types
19:34:38 <richo> I'm at work so I can't fiddle with this too much right now. Thanks fot the advice, I'll hack on it tonight and probaly ask more stupid questions.
19:34:52 <bitonic> shachaf: you mean destructor?  or am I misremembering what a Prism is?
19:34:57 <bitonic> iirc prism was kind of like views
19:35:13 <shachaf> I don't know what "destructor" means.
19:35:27 <shachaf> richo: ALso, as a habit, you should get used to pattern-matching a lot more.
19:36:17 <shachaf> E.g. by default, avoid head, tail, fromJust, (!!), and also null, isJust
19:36:27 <bitonic> shachaf: very generally something with the type constructor as domain, but I was referring to view patterns specifically
19:36:31 <shachaf> They are sometimes justified but you should justify them when you use them.
19:38:20 <shachaf> bitonic: A view pattern is like a constructor.
19:38:28 <shachaf> Of a sum, that is.
19:38:34 <bitonic> shachaf: constructor for what?
19:39:16 <shachaf> A constructor lets you do two things: Construct -- e.g. Right :: a -> Either e a -- and match -- e.g. matchRight :: Either e a -> Maybe a.
19:39:40 <shachaf> (Except match needs to be a little more flexible to allow for changing a "phantom" type.)
19:40:04 <monochrom> richo: see my http://www.vex.net/~trebla/haskell/crossroad.xhtml
19:40:27 <bitonic> shachaf: usually when you talk about constructors/destructors you are talking about functions concerning a single type constructor.  in that case, Right is a constructor for Either, and matchRight is a destructor for Either
19:40:33 <bitonic> or at least, in the literature
19:40:46 <bitonic> in that sense, views are smart destructors
19:40:47 <shachaf> bitonic: I don't think I've heard "destructor" used that way, but OK.
19:41:09 <shachaf> "Right" is a combination constructor-destructor, then, because the name "Right" lets you do both.
19:41:15 <shachaf> Similarly the prism _Right lets you do both.
19:42:09 <bitonic> shachaf: well *the* destructor for a data type its its induction principle, but you have others.  again, when you talk about some type T constructors have T as codomain, destructors as domain.  I never heard Right called destructor either ehe
19:43:01 <shachaf> If I import the name Right from Data.Either, it lets me match and construct.
19:43:09 <shachaf> That's all.
19:43:22 <shachaf> Anyway, we're in agreement about what a prism is?
19:43:26 <bitonic> yes.
19:44:03 <bitonic> well yeah pattern matching + recursion are the familiar way to destruct things :)
19:45:35 <bitonic> but thats a different thing.  just so that I know, does the lens environment call things like Right destructors?
19:45:53 <shachaf> lens calls things like _Right prisms.
19:46:25 <shachaf> It calls things that only give you the matching ability "affine traversals", or something like that.
19:46:56 <bitonic> right, OK.  _Right is not Right
19:47:11 <bitonic> thats a lot of rights
19:47:13 <shachaf> Right. Because _Right is first-class.
19:47:48 <bitonic> _Right is precisely what Id call a destructor.  all good.
19:48:07 <shachaf> (_Right # 5) == Right 5
19:48:22 <shachaf> I.e. it lets you make an Either out of nothing.
19:48:35 <shachaf> Well, not nothing.
19:48:43 <shachaf> a -> Either e a. You know what I mean.
19:48:49 <bitonic> I know what you mean
19:49:00 <shachaf> elliott: Can we have lens in lambdabot?
19:49:14 <bitonic> in the papers those are called destructors, or eliminators
19:49:55 <monochrom> wait, a -> Either e a cannot be a destructor or eliminator
19:50:13 <shachaf> I would agree, but bitonic seems to call it otherwise.
19:50:18 <elliott> > _Right # 5
19:50:19 <lambdabot>   Not in scope: `_Right'
19:50:20 <lambdabot>  Perhaps you meant `right' (imported from Control.Ar...
19:50:21 <shachaf> I don't mind terminology much...
19:50:27 <elliott> @let import Control.Lens.Prism
19:50:28 <lambdabot>  Defined.
19:50:30 <elliott> > _Right # 5
19:50:31 <lambdabot>   Not in scope: `#'
19:50:34 <elliott> @let import Control.Lens.Operators
19:50:35 <lambdabot>  .L.hs:38:1:
19:50:35 <lambdabot>      Control.Lens.Operators: Can't be safely imported!
19:50:35 <lambdabot>      The ...
19:50:37 <shachaf> Oh, wait, "affine traversal" isn't right at all. I lied. I'm sorry. :-(
19:50:39 <elliott> hmmmm.
19:50:44 <shachaf> > review _Right 5
19:50:45 <lambdabot>   Not in scope: `review'
19:50:45 <lambdabot>  Perhaps you meant `view' (line 141)
19:50:49 <bitonic> _Right # 5 is not _Right.  you can use the eliminator to rebuild something of type Either, obviously
19:50:49 <elliott> @let import Control.Lens.Review
19:50:50 <lambdabot>  Defined.
19:50:54 <elliott> > _Right # 5
19:50:56 <lambdabot>   Right 5
19:51:04 <elliott> bitonic: you can't with the type theory kind of eliminator...
19:51:11 <elliott> you need a constructor for that
19:51:15 <elliott> _Right packages them both up into one
19:51:22 <elliott> so I don't see how that notion is obvious
19:51:32 <shachaf> Prism s t a b = (b -> t, s -> Either t a)
19:51:39 <bitonic> ohhh, OK.  my bad
19:51:45 <bitonic> so yes it is both at once
19:52:01 <shachaf> Perhaps I was unclear.
19:54:31 <bitonic> shachaf: the thing that confused me is calling a prism a constructor, since I remembered it did more.  but it does even more than what I remembered :P
19:55:06 <shachaf> Having the (prism) value _Right in scope lets you do pretty much the same things that having the name Right in scope does.
19:55:48 <dolio> Just some things better.
19:55:52 <dolio> And others worse.
19:56:12 <shachaf> Right.
19:56:43 <bitonic> shachaf: yes, but it also lets you tear down the Either, right?  e.g. can I express case_ :: Either a b -> (a -> c) -> (b -> c) -> c with the prism?  case_ is what Id call *the* eliminator for Either
19:57:22 <elliott> prisms don't give you full coverage.
19:57:47 <dolio> You need both _Right and _Left to write case_
19:58:04 <arkeet> :t either
19:58:05 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
19:58:10 <shachaf> And you don't get the guarantee of a complete pattern match, even then.
19:58:22 <bitonic> OK, then I misremembered prisms for something else.
19:58:49 <bitonic> I thought itd be a more general version of either, in the case of Either
19:59:17 <Lamen> > abs (minBound  :: Int)
19:59:18 <lambdabot>   -2147483648
20:00:18 <bitonic> > - (maxBound :: Int)
20:00:19 <lambdabot>   -2147483647
20:01:32 <dolio> Yes, in Agda, _Left and _Right would never be good enough to write either.
20:01:35 <dolio> I think.
20:01:42 <dolio> You need additional information.
20:01:52 <Lamen> I don't understand, abs supposed to return the absolute value
20:02:09 <dolio> Welcome to two's complement.
20:02:15 <elliott> > minBound :: Int
20:02:16 <lambdabot>   -2147483648
20:02:29 <elliott> > 2147483648 :: Int
20:02:31 <lambdabot>   -2147483648
20:02:40 <elliott> Lamen: does that help? :)
20:03:23 <Lamen> elliott: DING!
20:03:42 <Lamen> Thanks...
20:04:19 <elliott> overflow :)
20:04:46 <monochrom> wait, lambdabot is on a 32-bit computer?
20:04:51 <mnbernstein> abs $ (minBound  :: Int) - 1
20:05:03 <mnbernstein> > abs $ (minBound  :: Int) - 1
20:05:04 <lambdabot>   2147483647
20:05:07 <mnbernstein> :)
20:05:34 <elliott> monochrom: yes
20:05:37 <elliott> monochrom: maybe it shouldn't be though
20:05:41 <elliott> but it only has 1 gigabyte of ram
20:06:01 <monochrom> ok, maybe 32-bit is better with that little ram
20:06:06 <elliott> well, the computer is 64 bit. and also not real. the operating system is 32 bit
20:06:34 <monochrom> don't worry about it, 1GB ram is good enough reason
20:06:40 <mnbernstein> it shouldn't really make any difference either way
20:06:58 <elliott> but the extra performance for @run!!!!!
20:07:16 <elliott> apparently discarding cache it's only using half of it anyway :)
20:07:27 <elliott> and only 3% of it for lambdabot!
20:07:54 <mnbernstein> apparently you can downgrade it to a raspberry pi then and use less power :P
20:25:14 <tabemann> stupid, off-topic question
20:25:25 <tabemann> I'm implementing a red-black tree
20:25:37 <tabemann> and nothing I can find explains how to *delete* an individual node
20:25:59 <shachaf> If it's stupid *and* off-topic, why are you asking it here?
20:26:08 <tabemann> where both the node deleted and its parent node both have two non-leaf children
20:26:42 <tabemann> okay, it's not stupid, it's just that what I read on this makes me feel stupid as if I'm supposed to know how to do this
20:26:50 <tabemann> it is off-topic, though
20:27:00 <tabemann> even though I don't know where I would ask the question
20:27:40 <shachaf> Are you implementing it in Haskell (i.e. a persistent red-black tree)?
20:28:09 <tabemann> yes
20:28:58 <shachaf> OK, then it's probably not all that off-topic. But if you say -- oh, never mind.
20:29:20 <shachaf> Anyway, presumably you looked up "red-black tree deletion" on your favourite search engine, read through the first result or two, and are still confused.
20:29:24 <shachaf> So what's confusing?
20:29:55 <tabemann> they don't explain the case of deleting a node with *two* non-node children, i.e. how to reconnect the children to other nodes once their parent is deleted
20:30:55 <tabemann> and how to do so that doesn't violate the rule that every path to a leaf must have the same number of black nodes
20:31:41 <tabemann> I've found code examples, but they're very imperative in form (except for one example I found in Haskell that's doing something dependent-ish with type families)
20:32:38 <tabemann> partially I just wanted to implement this from scratch myself, but I'm stuck on this point
20:33:58 <tabemann> wait I think I just found an explanation mentioned momentarily in something
20:37:28 <lispy> tabemann: You might try implementing the parts of it that make sense to you and then posting the unfinished code to hpaste. Then ask people here for help.
20:37:41 <lispy> tabemann: I think that you'll find with concrete code to review it becomes easier to discuss it.
20:37:59 <carter> lispy did you see that xcode 5 has LTO?
20:38:20 <lispy> carter: I don't pay attention to such things :)
20:38:22 <tabemann> lispy: I think I figured out the point I was stuck on anyawys
20:38:23 <lispy> carter: so no
20:38:29 <carter> ok
20:38:30 <carter> point being
20:38:37 <carter> apple ld will have lto :)
20:38:48 <carter> so mac and linux both will have lto
20:38:57 <lispy> interesting
20:39:00 <carter> and i supposed windows has its own via seperate tooling
20:39:10 <carter> brb in a bit
20:40:16 <dolio> tabemann: As I recall, delete is ignored because it's significantly harder to implement in persistent red black trees.
20:40:36 <dolio> But it's supposed to be a lot easier in left-leaning red black trees. So you might want to check those out.
20:41:21 <monochrom> oh, no wonder Okasaki just did leftist
20:42:02 <tabemann> dolio, I think I found an algorithm that might not be *too* hard to implement, but it sounds like any given delete is going to replace a good part of the nodes in a given tree
20:45:44 <copumpkin> that doesn't sound right
20:46:46 <bscarlet> carter: how sure are you about apple ld having LTO? Is that LTO for mach_o or for LLVM bitcode?
20:48:24 <carter> bscarlet if you do "ld -v" with the new dev tools installed
20:48:27 <carter> it says LTO
20:48:32 <carter> also in one of the wwdc talks online
20:49:09 <carter> that may be in that darn "beta nda"
20:49:10 <carter> shit :)
20:50:55 <carter> bscarlet i'm going to install xcode 5 developer  beta
20:51:04 <carter> and double check
20:51:21 <blackdog> carter: heyo
20:51:23 <carter> lispy copumpkin   I think LTO if its not fragile would benefit ghc's binary sizes
20:51:30 <carter> blackdog OMG YOURE AWAKE AT THE SAME TIME AS ME
20:51:42 <blackdog> carter: turns out when you run a big scraper you get a hell of a lot of weird ioManager errors :)
20:51:45 <blackdog> carter: crazy, no?
20:51:53 <carter> blackdog COOL
20:51:54 <blackdog> also, i hate DNS
20:51:59 <blackdog> it breaks everything
20:52:07 <carter> i neeed to figure out a smaller repro for a monad-par bug i have
20:52:11 <lispy> carter: how would it benefit binary size?
20:52:39 <carter> lispy dead code eliminiation :)
20:52:56 <carter> that can be a tad smarter than strip
20:52:58 <lispy> carter: is that what causes ghc binaries to be large?
20:53:14 <carter> lispy well, the inlining probably doesn't help
20:53:34 <carter> but if you disassemble a static binary made with ghc
20:53:48 <carter> theres lots of stuff in the RTS thats never called in there
20:53:58 <lispy> interesting. I've never looked at it.
20:54:05 <carter> like, build a main =  putstrlin "hello world"
20:54:13 <carter> hell, lemme do that righ now
20:54:19 <carter> i'll gist it even
20:54:20 <blackdog> carter: ah, that makes some sense. i guess you've got dead code elimination, but only for client code, not the runtime.
20:54:33 <bscarlet> carter: I suppose if one used the LLVM GHC backend, one could use standard LLVM command-line tools to do LTO.
20:54:36 <carter> blackdog why not the run time?
20:54:48 <carter> bscarlet you'd need linker support for lto too
20:54:53 <carter> on mac thats a new thing
20:54:59 <blackdog> carter: the compiler doesn't run over that, right?
20:55:13 <blackdog> are you saying the linker should be smart enough to throw away unused code?
20:55:14 <carter> blackdog i'm talking about dead code elim in the linker :)
20:55:28 <carter> gold = should be able to do that
20:55:29 <blackdog> right. so you know much less about it at that stage, yes?
20:55:56 <carter> http://llvm.org/docs/GoldPlugin.html
20:56:01 <carter> http://gcc.gnu.org/wiki/LinkTimeOptimization
20:56:27 <carter> blackdog actually no you have to bake more meta data into your static objects for LTO to happen
20:56:50 <bscarlet> carter: My point was you could do most of your linking with LLVM (e.g. llvm-link), rolling together LLVM bitcode before lowering to actual object files.
20:57:08 <carter> bscarlet you're missin gmy point :)
20:57:23 <carter> which is the more I can use standardized tools to do that, the better
20:57:39 <bscarlet> carter: oh certainly.
20:57:58 <carter> bscarlet and if i cant make it easy to do with standardized tools, its too muc work to support for other people
20:59:06 <bscarlet> carter: does ghc with the llvm backend count as "standardized tools?"
20:59:15 <carter> bscarlet yes
20:59:25 <carter> but only if i could cabalize such a build process ;)
20:59:59 <carter> ie: its only worth it for me if i can get it supported in ghc propper
21:00:14 <carter> or easy for an end user haskeller to install
21:00:23 <carter> lispy i'll dig into the lto stuff more and figure out things
21:01:22 <bscarlet> carter: It might not take much to put the LLVM support into GHC. It'd be a lot like supporting a different object format.
21:01:42 <carter> bscarlet indeed, though I don't know enough yet about the bits needed to make it so
21:01:52 <carter> in a way that works on maverick macs and linux both
21:02:13 <carter> but i've a few folks i know who may know
21:02:18 <carter> and i can pester em I suppose
21:02:53 <anonlsdljsdflsdn> Does anyone know how to get cabal to install source code for libraries?
21:03:14 <arkeet> what does it mean to install source code?
21:03:22 <arkeet> you can get it to unpack a package for you. cabal unpack
21:03:27 <arkeet> and then the source will be there.
21:03:49 <bscarlet> carter: me neither. But if you were doing it by having ghc invoke llvm command line tools instead of system command line tools, I imagine it'd be nearly identical between mac and linux. Of course there's probably some different, but none is immediately obvious to me.
21:03:51 <arkeet> if you want it to generate documentation with source code, there are cabal options for haddock and hscolour
21:04:08 <carter> bscarlet i dare not assume they're the same
21:04:08 <anonlsdljsdflsdn> yes, I can do that manually, but I didn't know if there was an automated way to place the source code somewhere that is already on ghc's path
21:04:12 <carter> becaue they may not be
21:04:23 <arkeet> ghc doesn't look for source code.
21:04:50 <anonlsdljsdflsdn> it has a search path
21:04:57 <arkeet> yes, for libraries.
21:05:41 <anonlsdljsdflsdn> let's step back a second.  I have done "cabal install gnuplot" Now I want to actually use gnuplot in my code.  How do I do that?
21:06:02 <arkeet> you import a module.
21:06:15 <anonlsdljsdflsdn> Ive done the import
21:06:21 <arkeet> then you win.
21:06:23 <anonlsdljsdflsdn> how do I fix the path issues?
21:06:32 <arkeet> if your project uses cabal, you need to add gnuplot as a dependency.
21:06:55 <arkeet> if not, ghc should just find it.
21:07:17 <arkeet> would you care to paste the exact error you get?
21:07:25 <anonlsdljsdflsdn> I'm not using cabal right now. I'm just getting started with haskell and all I want to do is figure out my paths
21:07:34 <arkeet> step 1: cabal install gnuplot
21:07:51 <arkeet> step 2: in your code, import Graphics.Gnuplot.Whatever
21:07:56 <carter> bscarlet i'd love if they're the same on different platfomrs, but mach-o and elf aren't the same  object formats
21:07:59 <carter> so i should assume not
21:08:02 <carter> until i find they are
21:08:08 <anonlsdljsdflsdn> I told you, I already did all that
21:08:21 <arkeet> so what's not working?
21:08:24 <arkeet> paste error message, etc.
21:08:26 <shachaf> anonlsdljsdflsdn: arkeet told you what to do next. I recommend that you follow his advice.
21:09:04 <bscarlet> carter: wait. I'm not sure we're not talking past each other. What I'm talking about would barely use ELF or mach_o - only at the very end _after_ linking.
21:09:17 <arkeet> I recommend that you do not follow shachaf's advice.
21:09:27 <anonlsdljsdflsdn> I have "import Graphics.Gnuplot.Graph.ThreeDimensional" There is a data type "T" which I would like to use.  GHC says "Not in scope: data constructor `T'"
21:09:28 <carter> bscarlet i'm talking about multilingual LTO
21:09:37 <carter> where you emeddd the meta data in the ojbects..
21:10:10 <arkeet> anonlsdljsdflsdn: well, then the problem is not in importing the module. what exact version of gnuplot got installed?
21:10:35 <anonlsdljsdflsdn> the latest. 0.5.1
21:11:12 <arkeet> well, I don't know. could you paste your code and full error message?
21:11:12 <arkeet> @hpaste
21:11:13 <lambdabot> Haskell pastebin: http://hpaste.org/
21:11:31 <bscarlet> carter: I'm talking about LTO of LLVM bitcode, which might or might not be multilingual, depending on how many language front ends you get to product LLVM bitcode instead of going all the way to ELF or mach_o. I was not particularly thinking of multilingual cases.
21:11:40 <arkeet> it looks like the modules in gnuplot are meant to be imported qualified, btw. but that doesn't explain the problem.
21:11:44 <bscarlet> s/product/produce/
21:11:54 <carter> bscarlet i'd really really like to LTO some C and haskell :)
21:11:55 <arkeet> (what, with names like C and T.)
21:12:25 <bscarlet> carter: your C code, or someone elses they've already compiled?
21:12:27 <anonlsdljsdflsdn> arkeet: I could do that, but clearly the problem is with paths.  What is the standard procedure for putting the source code of a library you would like to use on your build path?
21:12:28 <arkeet> wait.
21:12:34 <arkeet> no, the problem is not.
21:12:38 <arkeet> I'm reading your error message again.
21:12:41 <carter> bscarlet mine or code i can build
21:12:55 <elliott> anonlsdljsdflsdn: i suggest you are overconfident
21:13:00 <bscarlet> carter: so the bitcode approach could work, yes?
21:13:09 <elliott> in fact, I suspect you have at least one important non-path-related problem.
21:13:11 <arkeet> anonlsdljsdflsdn: the error to me suggests you are using the type name T in a value context.
21:13:15 <carter> bscarlet i guess
21:13:22 <carter> i'll have to investigate mroe
21:13:23 <arkeet> which is why I suggested you paste your code.
21:13:39 <blackdog> arkeet: looking at http://hackage.haskell.org/packages/archive/gnuplot/0.3.3/doc/html/src/Graphics-Gnuplot-Private-Graph3D.html#T suggests you're right.
21:14:19 <anonlsdljsdflsdn> fantastic
21:14:19 <arkeet> anonlsdljsdflsdn: if ghc couldn't find the module, it would give an error saying it couldn't find the module.
21:14:21 <arkeet> not something else.
21:14:24 <elliott> so this is a henning package right :P
21:14:39 <elliott> yep.
21:14:50 <anonlsdljsdflsdn> arkeet: good to know
21:15:24 <arkeet> and I told you what I think is actually causing the error. so maybe that will help you fix your code. or maybe you still want to paste it for us to look at.
21:15:30 <shachaf> anonlsdljsdflsdn: You're being kind of rude and unpleasant to people who are trying to help you. Please try to be nicer.
21:16:46 <anonlsdljsdflsdn> shachaf: I could say the same.
21:17:36 <anonlsdljsdflsdn> to be clear, thank you for your help
21:18:03 <shachaf> You can say anything you want... The difference is that you're the one coming to this channel with some anonymous gibberish nick and asking for advice, and then being rude to people who are trying to help you, and I'm the one trying to keep this channel a pleasant place (in the long term).
21:18:46 <blackdog> anonlsdljsdflsdn: the problem's the stuff you think that you know that's incorrect. people here see a lot of it, because they've used haskell a lot, so they're not just being dicks when they ask for more information.
21:23:13 <anonlsdljsdflsdn> shachaf: fyi, I'm not trying to hide behind a jibberish name; there is a bug in my irc client that screws up my regular name & password and I couldn't be bothered with trying to workaround it right now
21:23:39 <shachaf> I didn't say anything about hiding. But that part doesn't really matter.
21:29:35 <xico> any idea on how to pass a function "f : a -> m b" as first argument of a function "g : (a -> b) -> m ()"?
21:29:57 <xico> (with Monad m)
21:30:18 <arkeet> you don't.
21:30:23 <arkeet> what do you actually want to do?
21:30:44 <xico> convert a MArray to a repa array
21:31:15 <xico> i can use "fromFunction sh (sh -> a)" to create a repa array by passing it a function to generate each element
21:31:25 <xico> (my g)
21:31:37 <xico> s/can/could
21:32:39 <xico> and i also could use marrays readArray to get each element. but readArray give a result in a monad.
21:32:41 <arkeet> I don't know anything about repa, but maybe you could freeze it into a Vector and use fromVector.
21:33:31 <arkeet> from ...Repa.Repr.Vector
21:33:48 <xico> indeed
21:34:15 <xico> i just have to check that the freezing does not copy
21:34:39 <xico> thanks arkeet :)
21:34:41 <arkeet> I'm pretty sure it does.
21:34:47 <arkeet> but fromVector looks like it does not.
21:35:00 <xico> fromVector does not
21:35:02 <arkeet> given that it says O(1)
21:38:42 <xico> you were right. freezing it is copying for my array.
21:38:51 <xico> arg. i hate how cairo uses marray...
21:39:01 <xico> wait...
21:39:44 <carter> bscarlet blackdog  "carter ~  ld -v
21:39:44 <carter> @(#)PROGRAM:ld  PROJECT:ld64-142
21:39:45 <carter> configured to support archs: armv6 armv7 armv7s i386 x86_64
21:39:45 <carter> LTO support using: LLVM version 3.3svn, from Apple Clang 5.0 (build 500.1.58)"
21:39:45 <lambdabot> Unknown command, try @list
21:40:13 <xico> ok found a way to create my data in a good place from the start.
21:42:51 <xico> (this is going to be so unsafe...)
22:00:01 <hpaste> DanBurton pasted IxMComonad at http://hpaste.org/90074
22:00:25 <DanBurton> Does this look legit? ^
22:00:43 <shachaf> The title certainly looks fishy.
22:00:54 <DanBurton> right
22:01:03 <shachaf> What is M?
22:01:13 <DanBurton> Monad... transformer... thingey
22:01:41 <DanBurton> It's a copy of IxBlah, but monad transformer-y
22:02:00 <DanBurton> mainly because I found myself writing duplicate
22:02:05 <DanBurton> or trying, anyways
22:02:49 <shachaf> elliott: Hmm, what's the equivalent of Free m a -> m a for indexed monads?
22:03:54 <elliott> IndexedFree m i j a -> m i j a
22:03:57 <elliott> hope this helps.
22:04:48 <shachaf> What's the Category equivalent of mconcat :: [m] -> m?
22:05:13 <arkeet> equivalent in the sense that a monoid is a 1-object category?
22:05:57 <arkeet> I guess that's where you take a sequence of composable arrows and compose them.
22:06:09 <elliott> shachaf: data Fratagory c a b = Id | forall x. Compose (c a x) (Fratagory c b x)?
22:06:34 <arkeet> not c x b?
22:06:41 <elliott> er, yes.
22:06:46 <canta> can it make sense to use such overly complicated flip expressions that lambdabot answers with @pl?
22:06:51 <shachaf> Right, but that's unsatisfying.
22:06:51 <elliott> canta: no.
22:06:59 <arkeet> @pl is mostly pointless.
22:06:59 <lambdabot> (line 1, column 21):
22:06:59 <lambdabot> unexpected end of input
22:06:59 <lambdabot> expecting white space or simple term
22:07:10 <elliott> shachaf: hey, you can give a Category instance for any c that follows the category laws.
22:07:15 <elliott> it's free enough.
22:08:44 <elliott> > (0$0.)
22:08:47 <lambdabot>   The operator `GHC.Base..' [infixr 9] of a section
22:08:47 <lambdabot>      must have lower prec...
22:09:10 <elliott> @let data Cat c a b = Id | forall x. c b x :.: Cat c a x
22:09:10 <lambdabot>  Parse failed: Illegal data/newtype declaration
22:09:13 <elliott> what
22:09:16 <elliott> oh.
22:09:18 <elliott> well.
22:09:50 <elliott> instance Category (Cat c) where id = Id; Id . g = g; f . Id = f; (f :.: g) . (h :.: i) = f :.: (g :.: (h :.: i))
22:10:01 <elliott> it's pretty great.
22:10:32 <shachaf> Do you need to match on Id on both sides like that?
22:10:44 <shachaf> @src (++)
22:10:44 <lambdabot> []     ++ ys = ys
22:10:45 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
22:10:45 <lambdabot> -- OR
22:10:45 <lambdabot> xs ++ ys = foldr (:) ys xs
22:11:01 <arkeet> shachaf: sure you do.
22:11:08 <shachaf> Oh, it's not really the same thing.
22:11:16 <elliott> well, you want the associativity
22:11:21 <elliott> so you need to dig into both (:.:)s
22:11:51 <arkeet> that's just the free category on a quiver.
22:12:09 <elliott> I don't know what the quiver is here. haskell is weird.
22:12:12 <elliott> almost as weird as CT.
22:12:19 <arkeet> a quiver is like a category, except without id and composition
22:12:28 <elliott> yes I know.
22:12:34 <elliott> oh, it's c here.
22:12:34 <arkeet> oh.
22:12:36 <arkeet> the quiver is c
22:12:38 <elliott> right.
22:12:40 <elliott> but it's kind of weird.
22:12:43 <arkeet> why?
22:12:49 <elliott> because ob(c) is restricted.
22:12:54 <elliott> because haskell
22:13:10 <arkeet> ??
22:13:18 <elliott> ok.
22:13:24 <arkeet> c could have any kind k -> k -> *
22:13:41 <arkeet> where k is ob(c)
22:14:32 <elliott> well, ok.
22:14:41 <elliott> I was assuming no polykinds.
22:15:04 <arkeet> what's wrong with polykinds?
22:15:17 <elliott> nothing.
22:15:28 <arkeet> ok.
22:30:40 <elliott> arkeet: well, i lied.
22:30:45 <elliott> polykinds is really annoying when using typeclasses.
22:30:56 <arkeet> I thought that was part of the point of polykinds.
22:32:07 <elliott> have you tried it? if you have polykinded instances then you get all sorts of silly errors about not being able to deduce instances
22:32:16 <elliott> because it finds an instance where the kinds are Any but doesn't realise those will work for * and sutff.
22:32:19 <elliott> stuff.
22:32:21 <elliott> it's a mess.
22:32:59 <carter> elliott have you filed a ticket? :)
22:33:11 <elliott> well, i don't think it's really a bug.
22:33:21 <elliott> it's just that bolting this kind of stuff on is inherently messy.
22:33:46 <elliott> it's roughly impossible to use PolyKinded classes without running into this at least once, so I'm sure the limitations are known about
22:34:15 <carter> would still be worth post a ticket explaing 1-2 usability examples
22:44:24 <arkeet> elliott: I haven't really used polykinds for anything worth anything.
22:46:13 <elliott> arkeet: me too.
22:46:25 <elliott> arkeet: also you can't write Absurd :: Void -> k.
22:46:26 <arkeet> then again, I haven't really used haskell for anything worth anything.
22:46:27 <elliott> which sucks.
22:46:36 <arkeet> that does suck.
22:46:45 <elliott> in fact, Void is inhabited.
22:46:48 <elliott> by Any
22:46:49 <arkeet> I know. :(
22:46:57 <arkeet> but isn't k inhabited too?
22:47:06 <elliott> well, sure.
22:47:11 <elliott> I guess you can write Absurd _ = Any
22:47:13 <elliott> but that's stupid.
22:47:15 <arkeet> of course.
22:47:30 <arkeet> I forget again why we need Any in the first place.
22:47:40 <elliott> because things aren't allowed to be good
22:47:52 <arkeet> sure, but I mean specifically.
22:56:10 <hpaste> DanBurton pasted Victory over IxMComonad at http://hpaste.org/90076
23:03:25 <jfischoff> isn't Any like undefined at the type level? I thought it was just used as a place holder while type checking.
23:05:01 <DanBurton> I believe that is correct
23:07:05 <carter> DanBurton whats this module do?
23:07:46 <shachaf> Any isn't exactly like undefined. Well, somewhat, I guess.
23:08:01 <DanBurton> carter: it is a coroutine module, sort of
23:08:07 <shachaf> In that it "inhabits" every kind. But not really the nontermination nonsense.
23:08:13 <carter> huh, neat
23:08:17 <carter> i need to crash
23:08:19 <elliott> jfischoff: you can pattern match on Any.
23:08:30 <jfischoff> I thought that was removed recently
23:08:30 <elliott> that's why it's really goddamn awful.
23:08:37 <elliott> was it? maybe it's only really awful now then
23:08:48 <DanBurton> lol
23:09:03 <jfischoff> I think the cool kids use this funky kind proxy now
23:10:04 <jfischoff> data OfKind (k :: *) = KindParam; type KindOf (a :: k) = (KindParam :: OfKind k)
23:10:19 <jfischoff> there is something similar in the GHC.TypeLits HEAD
23:10:30 <jfischoff> I don't fully grasp it
23:10:48 <jfischoff> but it is the Any pattern match replacement
23:11:07 <jfischoff> wait I mean I don't understand it basically at all ;)
23:16:05 <DanBurton> what junk do I have to enable so that I can write the constraint (MyMonadTrans t) which means (forall m. Monad m => Monad (t i j m)) ?
23:18:51 <arkeet> that doesn't look like a constraint.
23:19:18 <arkeet> wait, never mind.
23:19:40 <DanBurton> throw i and j into the "forall" as well
23:19:41 <Lamen> I was playing with mueval, and got this error: "Could not find module `ShowQ'". I know there's -n, and I checked "searchPath" which is ["."] by default, so does that mean I have to put all the modules defined in "defaultModules" under . to get it to work?
23:19:41 <arkeet> ConstraintKinds, and probably something like Rank2Types?
23:19:51 <arkeet> if it works at all, anyway.
23:19:56 <arkeet> I don't know what it would mean.
23:20:37 <shachaf> ==arkeet
23:25:02 <hpaste> DanBurton pasted ConstraintKind as superclass, nope at http://hpaste.org/90080
23:25:51 <latro`a> ...why doesn't that work? :/
23:25:58 <latro`a> I thought ConstraintKinds was basically just sugar
23:26:10 * DanBurton shrugs
23:26:12 <latro`a> it sure seems that way since they become invisible after compilation in ghci
23:27:38 <DanBurton> Well if you just inline the synonym, it still complains that the predicate is malformed
23:28:14 <latro`a> huh
23:29:21 <hpaste> DanBurton annotated ConstraintKind as superclass, nope with ConstraintKind as superclass, nope (annotation) at http://hpaste.org/90080#a90083
23:29:49 <shachaf> latro`a: Just sugar? Not really.
23:29:56 <latro`a> oh?
23:30:00 <shachaf> Well, I suppose if you just have a constraint kind type synonym, it is.
23:30:10 <shachaf> But that's more because type synonyms are just sugar than because constraint kinds are.
23:30:15 <latro`a> I see
23:31:12 <shachaf> Anyway, I'm not really sure what DanBurton is trying to achieve with that constraint, but I don't think it's possible.
23:31:22 <shachaf> I mean, I don't think the constraint is possible.
23:31:40 <DanBurton> You can't do constraints of the form (Constraint1 => Constraint 2) ?
23:32:22 <DanBurton> seems like as long as they aren't recursive then the constraints could be solved with the equivalent of "eauto"
23:33:05 <shachaf> forall is not a constraint.
23:33:23 <shachaf> And also I don't think you can do constraints of that form.
23:34:19 <DanBurton> so no "higher-order" constraints, I guess?
23:34:30 <DanBurton> or polymorphic, rather
23:36:35 <shachaf> I'm not even quite sure what it would mean in general.
23:37:45 <DanBurton> Well in this case, it means "assuming you can build a Monad instance for m, you should also always be able to build a Monad instance for t i j m"
23:38:24 <DanBurton> for all i, j, m
23:38:55 <latro`a> seems like a sensible thing
23:40:54 <DanBurton> The reason I want this is so that "duplicate" won't need a default type signature that includes ("Monad (t j k m)"), since I want the whole typeclass hierarchy to operate under the assumption that we have a proper monad transformer on our hands
