00:02:32 <shachaf> Is there a simple Functor that has, say, three fixed points?
00:10:17 <chao_aero_> snap and yesod , which one is better
00:10:18 <chao_aero_> ?
00:10:35 <johnw> chao_aero_: better for who?  better for what purpose?
00:10:55 <johnw> asking if x is better than y is generally not fruitful, but if you have a specific need to be addressed, we can help you find an answer for that need
00:10:57 <chao_aero_> for enterprise or small market
00:12:57 <chao_aero_> yes your  u right
00:16:17 <johnw> shachaf: I don't know about finding three fixed points for a Functor, but this line from that webpage you linked is interesting: "the category of fixed points, i.e., the category of F-algebras X for which the structure FX‚ÜíX is an isomorphism".  Is that part of you were looking for?
00:17:20 <arkeet> that sounds like it
00:17:22 <shachaf> Yes.
00:17:32 <shachaf> I guess that means that it's also the same thing for F-coalgebras.
00:17:41 <johnw> that would make sense
00:17:58 <shachaf> hi arkeet
00:18:08 <arkeet> hi shachaf
00:18:21 <shachaf> Now that you're here you can answer all my questions from the past half hour.
00:18:50 <Gracenotes> oh hallo
00:19:01 <elliott> shachaf: it turns out arkeet can't actually answer all our questions.
00:19:03 <elliott> I was surprised too.
00:19:18 <shachaf> hi Gracenotes
00:19:31 <shachaf> Today Gracenotes and I learned all about fixed points.
00:19:54 <Gracenotes> this seems interesting. FX->X, and X->FX are both definable using either GFix or LFix
00:20:00 <Gracenotes> so, yes, isomorphism
00:20:21 <shachaf> Right. So that's the category I was looking for.
00:20:45 <shachaf> The initial object is the least fixed point and the terminal object is the greatest fixed point.
00:21:14 <Gracenotes> because of the respective initial and terminal properties. seems a bit of a cop-out, but it is technically correct, the best kind of correct.
00:21:33 <shachaf> Gracenotes: Can you think of a Functor that has, say, exactly three fixed points?
00:21:37 <Gracenotes> and Wadler's paper makes fancy diagrams as such
00:21:47 <shachaf> Gracenotes: Right.
00:22:33 <Lethalman> hi, I was thinking that sql query is a monoid, what do you think about?
00:23:06 <shachaf> Anyway I don't know whether they're (co)limits in any interesting sense...
00:23:19 <Lethalman> well depends on the representation, something like a record of selected columns, joined tables, where clauses, etc.
00:23:51 <johnw> Lethalman: do you mean that you could extend a query by mappend'ing new search terms onto it?
00:23:52 <Lethalman> here's a monoid on sql query: http://hackage.haskell.org/packages/archive/postgresql-simple/0.1.2/doc/html/Database-PostgreSQL-Simple.html#t:Query but the underlying structure is a string :S
00:24:08 <Lethalman> johnw, no I can mappend another query
00:24:21 <Lethalman> johnw, which would mappend the selected columns, joined tables, etc.
00:24:28 <johnw> so, select foo from bar and select baz from bar <> to select foo, baz from bar?
00:24:34 <Lethalman> johnw, yes
00:24:40 <tomboy64> i know i can do [1..15] to get a list of 1 to 15 - how do i get a list from 15 to 1?
00:24:46 <tomboy64> except with reverse, of course
00:24:56 <johnw> so, the representations of an SQL query may form a monoid, is what you mean
00:25:10 <johnw> I say write it, give it a try
00:25:16 <Lethalman> mh
00:25:23 <Gracenotes> shachaf: I can think of functions like f(x) = x^3 + 2*x^2.
00:25:41 <johnw> try to think of a case where no proper action can be taken if two query details semantically conflict
00:25:46 <Gracenotes> these only have fixed points 0, -1-sqrt(2), and sqrt(2)-1.
00:25:50 <Lethalman> johnw, I'm very new to this stuff :-) so I was thinking about it
00:25:58 <Gracenotes> but good look finding a type representation of those
00:26:02 <Lethalman> johnw, also, I was thinking more generally about writing _part_ of sql queries
00:26:03 <shachaf> Gracenotes: No negative (or irrational) fixed points please.
00:26:15 <Gracenotes> I have both, what do I win? :)
00:26:19 <Lethalman> so rather than SqlQuery being a monoid, PartOfSqlQuery being a monoid
00:26:22 <shachaf> > map (^3) [-1,0,1] -- simpler, if you're willing to have a negative value
00:26:23 <lambdabot>   [-1,0,1]
00:26:41 <Lethalman> johnw, such as select foo <> from bar, the idea is to compose queries
00:26:50 <Lethalman> without passing the original query to functions
00:26:54 <shachaf> But Mu Triple is Void, not some negative type.
00:27:04 <elliott> Gracenotes: so uh, data Foo = A Foo Foo Foo | B Bool Foo Foo
00:27:14 <Gracenotes> shachaf: We Might need to have notion of type subtraction, though
00:27:14 <elliott> clearly that's sqrt(2)-1.
00:27:21 <elliott> there was a blog post about this stuff I read.
00:27:22 <johnw> Lethalman: best thing to do at this point is to play with the idea in code
00:27:24 <elliott> it gave a golden ratio type.
00:27:27 <Lethalman> johnw, right
00:27:32 <Lethalman> let's try :-)
00:27:47 <Gracenotes> so what is x^3 - x^2, in types?
00:27:56 <Lethalman> I've searched for existing stuff about "sql query monoid" but found nothing
00:28:05 <shachaf> Nonsense, at least with the usual definitions we use.
00:28:29 <johnw> Lethalman: let's take our conversation to #haskell-overflow, since shachaf started his first
00:28:41 <Lethalman> huh what's that
00:28:46 <johnw> it's a channel
00:28:48 <johnw> just /join it
00:28:51 <Lethalman> did it
00:28:58 <Lethalman> I mean what's the reason of that channel :P
00:28:58 <Gracenotes> that's a shame. well, so we're looking for f(x) such that f(x) - x = 0 has three distinct solutions
00:29:02 <Gracenotes> integer solutions
00:29:17 <johnw> it's for conversations that want to go further on a certain idea, that the whole #haskell doesn't really need to hear about
00:30:24 <Gracenotes> so what has 3 roots? a cubic polynomial. So then, find integer a, b, and c such that (x - a')(x - b')(x - c') - x = 0 at a, b, and c.
00:30:47 <Gracenotes> this doesn't look very fun
00:32:16 <Gracenotes> possibly this is less useful than SQL monoids
00:32:26 <Gracenotes> shachaf: so why 3?
00:32:42 <shachaf> Gracenotes: Because I want something bigger than 2 and smaller than infinity.
00:32:43 <johnw> Gracenotes: I'm always interested in the concept of type subtraction :)
00:32:48 <shachaf> 3 isn't that important.
00:34:27 <Gracenotes> it gets a lot more complex as you go on... any polynomial with positive roots (corresponding to the fixpoints) is likely to get negative coefficients (corresponding to the functor type)
00:34:38 <shachaf> Yes.
00:34:46 <shachaf> Oh well, this isn't that important.
00:35:57 <Gracenotes> so your only hope may be recursive functors.
00:36:12 <Gracenotes> recursive datatypes
00:42:38 <Gracenotes> woo. tmux.
00:44:09 <Gracenotes> I am no longer enthusiastic about tmux. I will continue using it however.
00:45:41 <pharaun> that was rather fast :)
00:46:13 <johnw> just like that movie, Gone in Sixty Seconds
00:46:35 <pharaun> haha indeed
01:14:30 <dyn> hi
01:14:36 <johnw> hi dyn
01:14:55 <dyn> I got stuck following the write yourself a scheme interpreter tutorial
01:15:12 <dyn> at http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing#Presentation I seem to get a parse error at the parseString function definition
01:15:25 <dyn> can't really figure it out why, it also looks ok to me
01:16:25 <dyn> http://paste.tryhaskell.org/90607
01:16:35 <dyn> these are the suspect lines
01:16:49 <johnw> what is the problem?
01:16:56 <dyn> ghc says  parse error on input `x'
01:17:09 <dyn> can it be an identation problem somehow?
01:17:13 <johnw> yes
01:17:21 <elliott> the problem is that all statements must align with the first in a do block
01:17:23 <johnw> x must line up with the c in char
01:17:27 <elliott> either put a newline and some indentation after the do
01:17:31 <elliott> or align the rest of the statements
01:17:35 <dyn> ohhh
01:18:03 <dyn> much better :)
01:18:05 <dyn> thanks!
01:18:16 <dyn> I wish my vim also knew that by heart..
01:23:24 <Ralith> dyn: many of us use emacs, which has very good haskell integration
01:23:26 <Ralith> :D
01:27:04 <dyn> I'm pretty sure vim is also capable of these basic tricks but the links I got here last time to set it up are still on my todo list
01:32:47 <Lethalman> :t iterate
01:32:48 <lambdabot> (a -> a) -> a -> [a]
01:32:55 <Lethalman> @hoogle (a -> Maybe a) -> a -> [a]
01:32:56 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
01:32:56 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
01:32:56 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
01:33:16 <arkeet> :t iterate . (.)
01:33:16 <lambdabot> (b -> b) -> (a -> b) -> [a -> b]
01:33:22 <FreeFull> :t unfoldr
01:33:23 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
01:34:01 <arkeet> :t flip (iterate . (.)) id
01:34:01 <lambdabot> (b -> b) -> [b -> b]
01:34:07 <arkeet> :t sequenceA . flip (iterate . (.)) id
01:34:07 <lambdabot>     Not in scope: `sequenceA'
01:34:07 <lambdabot>     Perhaps you meant one of these:
01:34:07 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
01:34:10 <arkeet> :t T.sequenceA . flip (iterate . (.)) id
01:34:11 <lambdabot> (a -> a) -> a -> [a]
01:34:23 <arkeet> > (T.sequenceA . flip (iterate . (.)) id) (+1) 0
01:34:23 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
01:36:13 <Lethalman> :t \f -> let dup a=(a,a) in unfoldr (\x -> fmap dup (f b))
01:36:14 <lambdabot> (Expr -> Maybe b) -> b -> [b]
01:36:17 <Lethalman> uhm
01:36:25 <Lethalman> :t \f -> let dup x=(x,x) in unfoldr (\x -> fmap dup (f b))
01:36:26 <lambdabot> (Expr -> Maybe b) -> b -> [b]
01:36:42 <Lethalman> :t \f -> let dup x=(x,x) in unfoldr (\x -> fmap dup (f x))
01:36:42 <lambdabot> (b -> Maybe b) -> b -> [b]
01:36:44 <Lethalman> yeah
01:37:08 <Lethalman> iterateMaybe :-)
01:37:52 <Lethalman> @hoogle a -> (a,a)
01:37:52 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
01:37:52 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
01:37:52 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
01:40:09 <FreeFull> :t \f -> map fromJust . takeWhile isJust . iterate f
01:40:09 <lambdabot> (Maybe b -> Maybe b) -> Maybe b -> [b]
01:40:20 <FreeFull> Not quite
01:40:49 <FreeFull> :t \f -> map fromJust . takeWhile isJust . iterate (f . return) . return
01:40:50 <lambdabot> Monad m => (m (Maybe b) -> Maybe b) -> b -> [b]
01:41:22 <FreeFull> Oh, of course that won't work
01:41:57 <c_wraith> that's..  one heck of a type signature.
01:42:21 <FreeFull> c_wraith: There are much worse signatures
01:42:38 <c_wraith> yeah, but the first argument of that one is...  fascinating.
01:43:29 <tnks> anyone else following Erik Meijer's Twitter account?  I'm having a hard time understanding how Tasks/Futures/Promises are comonadic and not monadic.
01:43:31 <Lethalman> is there a takeWhile that includes also the last element?
01:43:49 <Lethalman> > takeWhile (<10) [1..]
01:43:50 <lambdabot>   [1,2,3,4,5,6,7,8,9]
01:43:54 <Lethalman> that is, includes 10
01:44:22 <arkeet> :t \p l -> zipWith const l (() : void (takeWhile p l))
01:44:23 <lambdabot> (a -> Bool) -> [a] -> [a]
01:44:34 <Ralith> :t void
01:44:34 <lambdabot> Functor f => f a -> f ()
01:44:38 <Ralith> orite
01:44:58 <Gracenotes> tnks: any tweets of note?
01:45:02 <arkeet> > (\p l -> zipWith const l (() : void (takeWhile p l))) (<10) [1..]
01:45:02 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
01:45:17 <tnks> Gracenotes: let me find the link.
01:45:29 <Lethalman> :t void
01:45:30 <lambdabot> Functor f => f a -> f ()
01:45:32 <h4199> @src takeWhile
01:45:32 <lambdabot> takeWhile _ []                 =  []
01:45:32 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
01:45:32 <lambdabot>                    | otherwise =  []
01:45:34 <arkeet> void = fmap (const ())
01:45:51 <Lethalman> :t const ()
01:45:51 <lambdabot> b -> ()
01:46:17 <shachaf> covoid = contramap absurd
01:46:38 <shachaf> Or is it fmap absurd and contramap (const ())?
01:46:40 <Lethalman> yes, otherwise = [x]
01:46:46 <Lethalman> that's what I need
01:46:48 <h4199> yup
01:47:37 <Lethalman> well I'll never understand that zipWith and void thing :P
01:47:43 <Lethalman> are all able to read that thing? \o/
01:47:57 <tnks> Gracenotes: https://twitter.com/headinthebox/statuses/351087934843265024
01:49:13 <tnks> actually, I see there's a link to an InfoQ video in the stream.
01:49:18 <tnks> I'll watch that.
01:49:51 <arkeet> Lethalman: it's a silly trick, to cut one list down to the length of another.
01:49:55 <supki> > (\p l -> zipWith const l (undefined : takeWhile p l)) (<10) [1..]
01:49:56 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
01:49:59 <arkeet> > zipWith const [1..] [(),(),()]
01:50:00 <lambdabot>   [1,2,3]
01:50:09 <Lethalman> huh
01:50:11 <arkeet> supki: =(
01:50:14 <supki> > (\p l -> zipWith const l (undefined : undefined : takeWhile p l)) (<10) [1..]
01:50:15 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11]
01:50:20 <supki> arkeet: =(
01:50:28 <arkeet> @where sneaky
01:50:28 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
01:50:38 <Lethalman> what's that
01:50:43 <Lethalman> :t dropFromEnd
01:50:43 <lambdabot> Not in scope: `dropFromEnd'
01:50:45 <johnw> > void [1,2,3]
01:50:45 <lambdabot>   [(),(),()]
01:50:48 <arkeet> @@ @let @where sneaky
01:50:49 <lambdabot>  Defined.
01:50:56 <arkeet> it's exactly what it says it is.
01:50:59 <Lethalman> :t dropFromEnd
01:50:59 <lambdabot> Int -> [b] -> [b]
01:51:12 <Lethalman> > dropFromEnd 2 [1,2,3,4,5]
01:51:12 <arkeet> > dropFromEnd 3 [1..10]
01:51:16 <lambdabot>   mueval-core: Time limit exceeded
01:51:16 <lambdabot>   mueval-core: Time limit exceeded
01:51:17 <arkeet> > dropFromEnd 3 [1..10]
01:51:21 <lambdabot>   [1,2,3,4,5,6,7]
01:51:25 <Lethalman> neat
01:51:27 <arkeet> > dropFromEnd 3 [1..]
01:51:30 <lambdabot>   mueval-core: Time limit exceeded
01:51:31 <Lethalman> :t zipWith
01:51:31 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
01:51:35 <arkeet> well, it works.
01:51:48 <arkeet> > zipWith f [a,b] [c,d,e]
01:51:49 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr c0)
01:51:49 <lambdabot>    arising from a us...
01:51:49 <shachaf> arkeet: If Mu f is the limit of [‚ä•, f ‚ä•, f (f ‚ä•), ...], what's Nu f?
01:51:51 <arkeet> > zipWith f [a,b] [c,d,e] :: [Expr]
01:51:52 <lambdabot>   [f a c,f b d]
01:52:27 <arkeet> shachaf: is that a list of types?
01:52:51 <shachaf> arkeet: It's a list of things.
01:52:54 <Gracenotes> tnks: so task is somehow a comonad? can you define (w a -> b) -> w a -> w b? ...
01:53:04 <shachaf> Let's pretend it's a lattice.
01:53:11 <arkeet> I don't know .
01:55:11 <Gracenotes> and, if you're looking to model thread-y stuff with it, at what point could the RTS jump in and make magic happen
01:56:08 <Gracenotes> not sure if it's even worth it, either
01:56:34 <Gracenotes> The problem with duality is that usually one of the things is useful and the other is only co-useful
01:57:47 * Lethalman just used view patterns \o/
02:01:17 <augur> i dont like view patterns
02:01:21 <augur> proper views are better, i think.
02:01:30 <tnks> Gracenotes: I think one problem is with semantics.
02:01:52 <tnks> I'm not sure exactly what "Task" is in .NET reactive frameworks.
02:02:05 <tnks> "
02:02:07 <elliott> shachaf: the colimit!!
02:02:10 <tnks> "if you look at the way it‚Äôs defined in .NET, Task is a co monad and the implicit effect is the monad, that‚Äôs a nice duality there as well."
02:02:29 <shachaf> elliott: Is it actually a limit/colimit?
02:02:30 <tnks> I think "Task" is what I'd call the "implicit effect," perhaps.
02:02:53 <shachaf> Is an F-algebra a kind of cone or something?
02:03:27 <Gracenotes> and is Task, as a Functor, parameterizing over its return value, then?
02:07:50 <augur> Task sounds like a Tarskian Hask category
02:16:16 <Lethalman> weird, using [x] in the otherwise of takeWhile doesn't seem to add the element for which p x is false
02:17:09 <dyn> anyone here uses sytastic for vim with haskell? I'd wonder what kind of errors can it catch
02:18:27 <supki> dyn: I catches the kind of errors ghc catches
02:18:36 <supki> s/I/It/
02:18:48 <dyn> err.. so what's the point then? :)
02:19:24 <supki> It does that automatically on buffer save
02:19:55 <dyn> ah
02:20:06 <dyn> I'm not sure if it works for me then
02:20:26 <supki> also it updates locations so you can easily move between errors
02:20:36 <dyn> I made my code not compiling and buffer save did not really show any problems
02:20:52 <dyn> while :make shows my error correctly
02:21:46 <dyn> ah :SyntasticInfo shows available checkers: <none>
02:21:52 <dyn> that might explain it
02:22:04 <supki> well, yes, syntastic is just a wrapper
02:22:24 <supki> I'd recommend hdevtools as syntax checker
02:22:33 <supki> ghc-mod is unusably slow for me
02:23:20 <dyn> are you also using haskellmode-vim?
02:23:26 <supki> no
02:23:52 <dyn> hdevtools also does indentation?
02:24:04 <dyn> haskellmode-vim does not seem to do any for me
02:24:30 <supki> no, it does not
02:24:41 <supki> i use haskellFoldIndent for indentation
02:25:09 <dyn> I'll check it out
02:25:56 <dyn> yup, it indents correctly
02:25:59 <dyn> thanks
02:29:22 <shachaf> Mu f is isomorphic to f (Mu f) and similarly for Nu, right? Is there a way to write the isomorphism, or parts of it, without recursion?
02:30:39 <shachaf> OK, f (Mu f) -> Mu f is possible, at least.
02:31:31 <elliott> shachaf: the other way is \(Mu x) -> x.
02:31:39 <elliott> Mu and runMu aren't a very exciting isomorphism.
02:31:45 <elliott> or, wait, which Mu,.
02:32:45 <shachaf> elliott: ?
02:32:55 <shachaf> newtype Mu f = Mu (forall r. (f r -> r) -> r)
02:33:01 <elliott> well lambdabot has a Mu defined as newtype Mu f = Blah { foo :: f (Mu f) }.
02:33:11 <shachaf> Please rename that to Fix.
02:33:13 <elliott> right.
02:33:17 <elliott> I'll just import it from another package.
02:33:18 <shachaf> There are too many things which are called Mu.
02:33:21 <elliott> when I get around to it. package suggestions welcome.
02:33:24 <shachaf> But I worked it out, anyway.
02:33:33 <elliott> glad I could help
02:35:39 <shachaf> delMuF q = Mu $ \k -> k $ fmap (\v -> runMu v k) q
02:35:42 <shachaf> addMuF (Mu k) = k (fmap delMuF)
02:35:49 <shachaf> Gracenotes: ‚òù
02:37:02 <shachaf> delNuF q = Nu q (fmap addNuF)
02:37:23 <shachaf> Guess what addNuF looks like.
02:39:12 <shachaf> addNuF (Nu x f) = fmap (\y -> Nu y f) (f x)
02:40:02 <shachaf> whoa, dude, the two arguments to Nu are, like, dual to the two arguments to runMu and vice versa?
02:44:44 <shachaf> If only GHC had first-class existentials.
02:54:39 <absence> http://paste.tryhaskell.org/90608 <- is there a way to make it assume the c is Exo?
02:56:36 <elliott> absence: c might not be Exp c' for some c'
02:56:38 <elliott> what if it's Int?
02:56:43 <elliott> so you can't use conv.
02:57:18 <shachaf> Change the type to conv :: Arr a b -> a -> b
02:57:30 <shachaf> More general and also works.
02:58:39 <shachaf> This is a somewhat bizarre equality type, though.
03:00:10 <AleXoundOS> Hi. I'm noob in Haskell. I get data from SQL database in the form of "IO [[[Char]]]", like: data <- query conn "select * from table". How can I convert this data to [[[[Char]]]] in order to include it in html code?
03:00:47 <shachaf> AleXoundOS: See the FAQ entry on this question:
03:00:50 <shachaf> @where faq
03:00:51 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
03:00:56 <elliott> AleXoundOS: see http://www.haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
03:00:58 <elliott> hah
03:01:05 <elliott> and additionally the introduction to IO it links
03:01:12 <elliott> now, if you say
03:01:17 <elliott> do { myData <- query conn "select * from table"; ... }
03:01:21 <elliott> then in ..., myData has the type [[[Char]]]
03:01:25 <elliott> (not IO [[[Char]]])
03:01:26 <absence> elliott: it's not possible to make conv only accept expressions where c is Exp?
03:01:29 <elliott> so you should be able to pass that through.
03:01:42 <elliott> i.e., you're on the right track, but for more details see the link
03:02:03 <elliott> absence: no, because the c is existentially quantified inside.
03:02:05 <elliott> it would be weird.
03:02:11 <AleXoundOS> shachaf, elliott thx I will check the links
03:02:13 <elliott> also it'd have to be a recursive requirement.
03:02:30 <AleXoundOS> elliott, the problem is that myData is "IO [[[Char]]]" not "[[[Char]]]"
03:03:18 <inf-groupoid> AleXoundOS: No, it is not. "query conn ..." is "IO [[[Char]]]", but myData is [[[Char]]].
03:03:43 <shachaf> Well, you can make Id :: Arr (Exp a) (Exp a) etc.
03:03:52 <shachaf> But why?
03:04:29 <absence> elliott: ah right, because c isn't a parameter to Arr, only a and b?
03:04:50 <shachaf> c isn't in the return type of the constructor.
03:04:56 <shachaf> So it's existential.
03:05:56 <absence> shachaf: playing around with making a syntax tree for Arrow so that i can process it in some way
03:08:55 <AleXoundOS> inf-groupoid, I think I'm misinterpreting the error message.
03:08:57 <AleXoundOS> Couldn't match type `IO' with `[]'
03:09:01 <AleXoundOS> Expected type: [[[[Char]]]]
03:09:04 <AleXoundOS> Actual type: IO [[[Char]]]
03:09:08 <AleXoundOS> In the return type of a call of `query_'
03:09:11 <AleXoundOS>  In a stmt of a 'do' block: data_from_db <- query_ db query_string
03:09:16 <AleXoundOS> In the expression:
03:10:22 <Cale> AleXoundOS: could you use hpaste to paste the rest of the expression?
03:10:44 <absence> shachaf: so i can't make it general, as i need the Exp type for other case labels that conv will get later
03:10:56 <AleXoundOS> Cale, yea I will try it
03:11:01 <Cale> AleXoundOS: something is making GHC think that your do-block has a list type
03:11:12 <Cale> AleXoundOS: rather than being an IO action
03:11:44 <Cale> AleXoundOS: it might be the type signature of the definition you're writing, or something else.
03:13:18 <elliott> AleXoundOS: btw, for pastes longer than a couple of lines there's hpaste (linked in the topic) :)
03:13:31 <AleXoundOS> hpaste not responding for me
03:13:48 <Cale> oh, it's down for me too
03:14:10 <Cale> http://paste.tryhaskell.org/new/haskell works though
03:14:17 * hackagebot hspec 1.6.1 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.6.1 (SimonHengel)
03:15:28 <inf-groupoid> AleXoundOS: Sorry, got disconnected. Something like "do { myData <- query conn... ; doSomethingWith myData }" should succeed.
03:19:17 * hackagebot hspec-meta 1.6.1 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.6.1 (SimonHengel)
03:19:42 <robde> what are the function names called in haskell? symbols?
03:20:33 <Cale> I usually just call them names?
03:21:12 <shachaf> Nothing special about functions there, either.
03:21:35 <hpaste> AleXoundOS pasted ‚Äúquery from database into ‚Äù at http://paste.tryhaskell.org/90609
03:21:41 <hpaste> AleXoundOS pasted ‚Äúquery error‚Äù at http://paste.tryhaskell.org/90610
03:22:05 <Cale> AleXoundOS: Well, there you go
03:22:19 <Cale> AleXoundOS: There's no IO in the type that you gave getDataFromDb
03:22:44 <AleXoundOS> it should be "IO  [[Char]]" instead?
03:22:54 <Cale> try that
03:23:24 <shachaf> Given the category F-Fix(C) where an object is (X : C, f : X <-> F X) and an arrow (X, f) -> (Y, g) is an arrow h : X -> Y such that fmap h . f = g . h , is there a left adjoint to the forgetful functor F-Fix(C) -> Iso(C)?
03:23:37 <Cale> You could also have written:  getDataFromDb conn = query_ conn "select * from sensors"
03:23:55 <Cale> the do here is pretty unnecessary unless you intend to do additional stuff
03:24:49 <haasn> robde: ‚Äònames‚Äô is the catch-all term, ‚Äòidentifiers‚Äô in particular refers to names consisting of letters/numbers, and ‚Äòoperators‚Äô for ones consisting of symbols
03:24:52 <haasn> but ‚Äònames‚Äô is fine
03:25:03 <elliott> I think (+) is an identifier...
03:25:47 <haasn> elliott: this is based on the haskell report 2010 chapter ‚ÄúIdentifiers and Operators‚Äù
03:25:58 <haasn> doesn't really matter at any rate
03:26:00 <haasn> ‚Äòname‚Äô is fine
03:26:12 <inf-groupoid> elliott: So, one could say () identifier-izes an operator, and `` operator-izes an identifier! :-P
03:30:46 <haasn> oh, hrm ‚ÄúAn operator symbol starting with any other character is an ordinary identifier.‚Äù
03:34:45 <shachaf> Oh, I guess a monad in Iso(C) is pretty boring?
03:35:28 <shachaf> Oh, maybe not...
03:36:19 <shachaf> Well, I guess M X is isomorphic to X.
03:37:23 <elliott> shachaf: so join is boring.
03:37:25 <elliott> presumably.
03:37:42 <elliott> I guess monad = comonad?
03:37:49 <elliott> flipping the arrows does nothing.
03:41:55 <adimit> uuuh. I've gotten GHC to panic (7.6.2) on a yesod app i'm writing. How do I best report this bug (considering I'm working on a complex application that depends on the entire yesod scaffold?)
03:42:54 <shachaf> Ideally, narrow the bug down to a small sample.
03:43:31 <adimit> yeah, that'd be the ideal, but I don't know that I can do that. Whatever I seem to change/leave out in my current file seems to make the bug go away.
03:43:40 <bitonic> adimit: you might also want to do some searches for similar bugs, maybe somebody reported already
03:43:46 <bitonic> for similar errors
03:45:07 <adimit> bitonic: can't seem to find anything via google.
03:49:13 <adimit> most of the code that probably makes it panic isn't even really available to me, as it's TH-generated. :-\
03:55:53 <Aetherspawn> :t (getEnv >>= Just)
03:55:53 <lambdabot>     Not in scope: `getEnv'
03:55:53 <lambdabot>     Perhaps you meant `getAny' (imported from Data.Monoid)
03:58:16 <romildo> I am reading the paper "Monad Transformers Step by Step" (http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf). Near the end of page 4 it is stated that Map.lookup is defined to work within any monad. It seems not to be true, right?
03:58:46 <shachaf> Yep, the API was changed.
03:58:58 <shachaf> For the better, I think.
03:59:00 <Blkt> morning everyone
03:59:44 <elliott> huh, I don't ermember it ever being like that.
04:00:33 <shachaf> http://hackage.haskell.org/packages/archive/containers/0.1.0.0/doc/html/Data-Map.html#v:lookup
04:00:46 <shachaf> It was changed in 2008.
04:01:28 <elliott> weird.
04:03:46 <FreeFull> Definitely for the better
04:03:54 <FreeFull> fail doesn't make sense for many monads
04:04:05 <FreeFull> If you wanted something generic you could use MonadPlus though
04:04:48 <romildo> shachaf, so in this case I am rewriting the equation     eval1 env (Var n) = Map.lookup n env       as         eval1 env (Var n)      = maybe (fail "undefined variable") return (Map.lookup n env)
04:04:57 <romildo> shachaf, so that the example can compile.
04:05:29 <romildo> shachaf, is that a good fix?
04:05:51 <shachaf> It's a local fix, at least.
04:20:46 <isomorphic> ghc says the following type signature is illegal - handle (\ (e :: (TraceException s))  -> printErrorMessage e) $ do - why?
04:21:45 <shachaf> Does GHC say the words "the following type signature is illegal"?
04:22:03 <isomorphic> It says -   Illegal type signature: `TraceException s'
04:22:18 <shachaf> Does it say anything after that?
04:22:38 <shachaf> hpaste.org is down but you should go to some other paste site and paste the full error.
04:22:51 <isomorphic> Yes - it says "Perhaps you intended to use -XScopedTypeVariables"  - but I don't understand the issue with the original
04:22:55 <chrisdone> @where hpaste
04:22:56 <lambdabot> http://paste.tryhaskell.org/new/haskell
04:23:18 <mauke> signature in pattern - bad
04:23:34 <shachaf> chrisdone: What, the old domain is just gone?
04:24:23 <Guest51080> just a small question: why do I get ugly stuff like 7.1999999999999 instead of 7.2 if I do 2.4 * 3 in ghci? I know it has something to do with computer arethmitik, but other languages can give me a nice 7.2 as well, so why not haskell?
04:25:23 <chrisdone> shachaf: http://ircbrowse.net/browse/haskell?id=15974534&timestamp=1372458561#t1372458561
04:25:25 <mauke> because those other languages are rounding slightly differently for output
04:26:03 <Guest51080> okay, and how do I tell ghci that I want 7.2 instead of 7.199999999? :)
04:26:10 <erisco> ghc on windows is a pain ... for some reason, if I compile    ghc Foo.hs    and then run Foo.exe, if I try to compile again I get "permission denied" when ghc tries to open Foo.exe, even though Foo.exe has already terminated
04:26:15 <mauke> Guest51080: you don't
04:26:17 <Guest51080> I am on linux
04:26:23 <Guest51080> ohh nevermind^^
04:26:26 <erisco> I can't even delete the file with administrator priveledges because something is holding a lock =\
04:26:40 <shachaf> Perhaps Foo.exe hasn't already terminated.
04:26:53 <Entroacceptor> erisco: or maybe you have an antivirus?
04:26:55 <aristid> it seems like bos still owns hpaste.org
04:27:23 <erisco> shachaf, I get shell control back
04:28:01 <erisco> after maybe 5mins the file will unlock again
04:28:05 <aristid> chrisdone: and you shut down the old host?
04:28:29 <erisco> Entroacceptor, you think an antivirus program is locking the exe? hm
04:28:38 <shachaf> erisco: I'd tell you how to debug it but I don't use Windows so I wouldn't know. Surely there's a tool that tells you why the file is locked.
04:29:18 <Ralith> process explorer?
04:29:22 <shachaf> If you don't know a tool for that then finding one is probably a good investment of your time.
04:29:26 <erisco> shachaf, there might be some third party tools but otherwise I don't know
04:29:43 <Ralith> process explorer is generally the go-to "tell me what is going on" tool
04:30:06 <shachaf> As they say, there ain't no party like a third party.
04:30:18 <Ralith> heh
04:30:41 <chrisdone> aristid: yes
04:30:48 <shachaf> Ralith: I bet you feel like figuring out things about fixed points for me.
04:31:02 <Ralith> not at 4AM I don't
04:31:07 <Ralith> >_>
04:31:12 <aristid> chrisdone: too bad CNAME on bare domains is not possible.
04:31:21 <Ralith> objectives:
04:31:22 <Ralith> 1. sleep
04:31:23 <shachaf> I'm in the same time zone as you.
04:31:28 <aristid> chrisdone: otherwise you should ask him to set up a CNAME to a domain of yours :)
04:31:31 <Ralith> 2. do things until I--
04:31:35 <Ralith> well get to bed!
04:31:35 <shachaf> I++
04:31:43 * Ralith shove
04:31:47 <aristid> I=0
04:32:01 <Ralith> there goes all my work
04:33:48 <chrisdone> aristid: i think this way is better, anyway. a domain managed by the haskell committee makes sense
04:35:44 <aristid> chrisdone: paste.haskell.org is too much to type!!!!
04:37:00 <haasn> yeah
04:37:01 <chrisdone> aristid: when do you ever type a full domain?
04:37:01 <haasn> how about p.org
04:37:19 <aristid> chrisdone: whenever i use a computer that doesn't have it cached.
04:37:34 <chrisdone> aristid: so, once every two months?
04:37:40 <aristid> chrisdone: WAY TOO OFTEN
04:37:47 <chrisdone> didn't think so =)
04:37:57 <shachaf> We type it into #haskell quite a bit.
04:38:13 <chrisdone> then what's @paste for?
04:38:17 <haasn> @paste
04:38:17 <lambdabot> Haskell pastebin: http://hpaste.org/
04:38:17 <aristid> @paste
04:38:17 <lambdabot> Haskell pastebin: http://hpaste.org/
04:38:27 <aristid> haasn: synchronous, lol
04:38:31 <shachaf> Also hpaste isn't in my browser history and doesn't go into my browser history when I use it.
04:38:39 <aristid> chrisdone: well @paste has the wrong link
04:38:44 <aristid> shachaf: huh weird
04:38:45 <shachaf> The problem with @paste is that it's spammy and also has to go at the beginning of the line.
04:38:51 <chrisdone> aristid: i can see that. i don't have access to update that entry
04:39:08 <shachaf> aristid: On purpose.
04:39:11 <haasn> I have no idea what's going on. Why can't we continue using hpaste.org?
04:39:19 <aristid> shachaf: how come?
04:40:49 <aristid> haasn: bos didn't react to chrisdone's request to change the DNS
04:41:00 <chrisdone> that url also sucks anyway as it doesn't default to submitting to the haskell channel
04:41:21 <elliott> shachaf doesn't have that problem, he can't get announced pastes now anywy.
04:41:22 <elliott> a.
04:41:54 <shachaf> It's true.
04:42:05 <Peaker> http://www.haskell.org/haskellwiki/Introduction mentions Ericsson measured an improvement for Erlang as an argument for Haskell.. That's not confidence inducing in readers, I'm pretty sure
04:42:40 * elliott suspects a HaskellWiki page titled "Introduction" probably needs deletion or a rewrite more than anything else.
04:45:06 <hpaste> isomorphic pasted ‚ÄúCatch only certain exceptions‚Äù at http://paste.tryhaskell.org/90611
04:46:10 <isomorphic> ^--- I'd like for handle on line 19 to just catch the exceptions defined in TraceException.  How should I do that?
04:46:58 <chrisdone> @hoogle handle
04:46:58 <lambdabot> System.IO data Handle
04:46:58 <lambdabot> GHC.IO.Handle data Handle
04:46:58 <lambdabot> Control.OldException handle :: (Exception -> IO a) -> IO a -> IO a
04:47:24 <chrisdone> isomorphic: so yeah, change your type from the generic Exception class constraint to your actual type
04:48:00 <chrisdone> isomorphic: printErrorMessage :: TraceException -> IO ()
04:51:15 <isomorphic> chrisdone:  I've tried a couple of things along those lines.  I'll paste one with the error message I get
04:52:28 <chrisdone> isomorphic: paste something complete enough that could be passed to ghc
04:53:56 <hpaste> isomorphic pasted ‚ÄúCatch only certain exceptions‚Äù at http://paste.tryhaskell.org/90612
04:57:18 <chrisdone> isomorphic: hm, that's reasonable. you have to instantiate class instances from somewhere
04:58:01 <chrisdone> consider:
04:58:02 <chrisdone> class X a
04:58:02 <chrisdone> foo :: X a => Maybe a -> (); foo _ = ()
04:58:02 <chrisdone> bar = foo Nothing
04:58:21 <chrisdone> isomorphic: the call to `foo' from `bar' doesn't provide which instance of X is to be used, so it's ambiguous
04:59:04 <chrisdone> isomorphic: likewise, neither does your call to `handle'
05:01:21 <hpaste> isomorphic pasted ‚ÄúCatch only certain exceptions (3)‚Äù at http://paste.tryhaskell.org/90613
05:01:34 <tomejaguar> I have a cabal file, listing some exposed modules.  My source tree has other modules that I don't want to expose but are required to build.  cabal sdist doesn't package them.  What's going on?  Should I specify them somehow?  Why can't it pick them up automatically?
05:01:37 <isomorphic> (^-- self contained example)
05:02:10 <shachaf> tomejaguar: other-modules, or something like that.
05:02:29 <shachaf> Or extra-source-files if it's not Haskell? I don't remember the details but I know the details exist.
05:03:12 <tomejaguar> shachaf: OK I will read the cabal users' guide more thoroughly.  I was hoping cabal would just work it out automatically.
05:04:39 <erisco> bleh...   class Iterable i x | i -> x        imap :: (Iterable i a, Iterable i b) => (a -> b) -> i -> i       how do you actually say you are returning an 'i' of b? I don't even know if this makes ense
05:04:42 <chrisdone> isomorphic: if you want to use show then you'll have to provide the instance of the class. you realise you can't call `show' without some instance to provide the implementation, right? one approach can be to make TraceException not parametrized but have its constructor contain an existentially quantified variable, like data MyEx = forall a. Show a => MyExeption a. then when you make the value you also include the instance, like: (MyEx
05:04:43 <chrisdone> 123)
05:05:00 <tomejaguar> shachaf: Cabal users' guide says "Note: Every module in the package must be listed in one of other-modules, exposed-modules or main-is fields."
05:05:02 <chrisdone> isomorphic: then your printErrorMessage can just be printErrorMessage (MyEx a) = print a
05:05:07 <erisco> I know that having   (Iterable i1 a, Iterable i2 b)  doesn't make much sense because then you could have two different Iterable containers
05:05:16 <tomejaguar> shachaf: So I just needed to read more thoroughly.  Thanks.
05:06:15 <isomorphic> chrisdone:  doesn't the deriving Show on the declaration of TraceException  provide the implementation?
05:06:56 <chrisdone> isomorphic: that generates an instance for TraceException a, what you want is the instance for a, but aren't providing anywhere
05:07:14 <shachaf> tomejaguar: It isn't so simple to do it automatically, I think.
05:07:25 <shachaf> tomejaguar: E.g. cabal will do some preprocessing for .hsc files and such.
05:07:28 <chrisdone> isomorphic: the instance Show (TraceException a) isn't self-contained, it depends on the Show a, that's why it's: Show a => Show (TraceException a)
05:07:32 <erisco> for example, an issue is if I chain maps together ...    (imap (++"foo")) . (imap (show))   the left-most imap doesn't know the right-most converted to a String
05:08:13 <erisco> if my function is     (Iterable i a, Iterable i String) -> i -> i     then ... well, things just fall apart
05:08:41 <chrisdone> isomorphic: i suggest reading ‚ÄúHow to make ad-hoc polymorphism less ad hoc‚Äù by Wadler http://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html
05:08:58 <isomorphic> chrisdone:  I'd intended that s would have a show instance by providing a constraint Show s on printErrorMessage - I take it that doesn't do it?
05:09:01 <isomorphic> chrisdone:  Thanks :)
05:09:16 <erisco> basically everything is okay in parameters and messed up on return values
05:12:07 <chrisdone> isomorphic: really, all functions that have a class constraint can be thought of as functions with additional arguments. Show a => a -> String, is, underneath, like: Show a -> a -> String, and Show is like data Show a = Show { show :: a -> String }, where all the methods are now record fields. when you write instance Show Int, you're sort of writing: $f_ShowInt = Show { show 0 = "0"; _ = "dunno" } and then show 0 is actually show
05:12:08 <chrisdone> $f_ShowInt 0. the paper's elucidating on this point
05:14:31 <isomorphic> chrisdone:  I've got it now, I'll go through it.  Above, where you say "provide an instance", do you mean creating a Show instance for s?  As in, instance show s where ‚Ä¶ ?
05:14:42 <hpaste> chrisdone annotated ‚ÄúCatch only certain exceptions (3)‚Äù with ‚Äúsimple ex type‚Äù at http://paste.tryhaskell.org/90613#a90614
05:18:30 <isomorphic> chrisdone:  Thanks very much :)
05:18:38 <chrisdone> isomorphic: try this: zot = show undefined -- why does this give an ambiguous error?
05:19:42 <isomorphic> chrisdone:  Because it (undefined) doesn't provide a an implementation of show?
05:20:05 <chrisdone> isomorphic: yep
05:20:46 <chrisdone> isomorphic: similarly, zot :: IO (); zot = handle (\x -> return ()) (return ()) -- why is this ambiguous?
05:22:05 <erisco> hm, lifting the monomorphism restriction allowed it to compile
05:24:39 <FreeFull> > show (undefined :: Maybe Int)
05:24:40 <lambdabot>   "*Exception: Prelude.undefined
05:24:44 <FreeFull> > show (undefined)
05:24:45 <lambdabot>   "*Exception: Prelude.undefined
05:24:52 <chrisdone> FreeFull: the interpreter has defaulting, ignore it
05:24:54 <FreeFull> Ah, lambdabot does extended defaulting
05:25:04 <erisco> oh... that wasn't really the reason :( it just inferred a type I didn't want instead
05:25:40 <isomorphic> chrisdone:  Ok.  That one is close enough to my issue I can't solve it ;) -   I gather that there it has to do with there being no restriction on x, and being unclear which version of return to use - but I can't see why return () in that context would be ambiguous  - why?
05:26:30 <chrisdone> isomorphic: the ambiguous part is the `x' parameter. we're not telling the compiler which instance to use
05:28:42 <chrisdone> isomorphic: zot :: IO (); zot = handle (\DivideByZero -> return ()) (return ()) -- this isn't ambiguous, but in your example: zot :: IO (); zot = handle (\(TraceException x) -> return ()) (return ()) -- the `x' is ambiguous again
05:28:56 <erisco> in my quest to learn a thing or two about type classes I've hit another snag. My 'ilength' function doesn't compile: http://paste.tryhaskell.org/90615  the compiler tries to deduce (Container i Int) for ifoldr, understandably, but only sees (Container i a) as the return from imap, which isn't really true
05:29:23 <elliott> hmm, I wonder what kind of word-wrapping stuff is available on hackage...
05:29:27 <elliott> python has a nice word-wrapper in stdlib
05:29:38 <erisco> so part of the issue is my type signature (the compiler wants to have (Num a), whereas it shouldn't be contrained) and the other part is that I don't know how to actually solve the problem
05:29:40 <chrisdone> isomorphic: for the same reasons. GHC's saying "ok, but /which/ instance of Exception? TraceException Int? TraceException Char? i need more info"
05:30:25 <erisco> over and over again it seems to be that I can't truly create a relationship between 'i' and 'x' without a data type. Maybe that is how it has to be here
05:30:52 <erisco> because any function that returns an 'i' doesn't carry the information of what 'x' it has
05:31:17 <chrisdone> erisco: what are you talking about?
05:31:22 <erisco> chrisdone, my pastie
05:31:39 <elliott> (Container i a, Container i b) implies a = b with that fundep
05:31:53 <elliott> i -> x so i uniquely determines a and i uniquely determines b, therefore a and b must be the same
05:32:27 <erisco> I don't see how or why
05:33:26 <elliott> ok, well, I don't know what you expect | i -> x to mean.
05:33:36 <elliott> here it means precisely that if you have (Container i foo), once you know i, you know foo
05:33:51 <elliott> therefore, (Container i a, Container i b) implies a = b. because once you know i, you know a; and independently, once you know i, you know b
05:33:56 <elliott> same decision each time, therefore same result
05:33:58 <erisco> I can have a != b when I actually use the instance... I mean, for example, I can have [Int] and [Char] and they both use the same instance Container [a] a
05:34:10 <elliott> no beacuse in one case it is [Int] and in the other it is [Char]
05:34:14 <elliott> you have Container [Int] Int and Container [Char] Char
05:34:19 <elliott> but you have "i" both times in the constraint
05:34:24 <elliott> and [Int] is not the same as [Char]
05:34:27 <elliott> they can't both be i
05:34:33 <isomorphic> chrisdone:  Ah, okay.  So it is resolvable by just collapsing the type signature to mention a single instance - printErrorMessage :: TraceException String  -> IO () - were you saying that approach with the Ex would have allowed me to keep it polymorphic?
05:34:49 <erisco> elliott, oh. I didn't realize the type of the list was also considered
05:34:50 <chrisdone> isomorphic: precisely! =)
05:35:16 <augur> chrisdone: precisely isomorphic!
05:35:18 <isomorphic> chrisdone:  Ok thanks.  I'll have to work through that Ex example
05:35:18 <elliott> well, yeah, what "i" is is considered when you're dealing with "i" :)
05:35:33 <augur> we need someone in here named onthenose
05:35:51 <erisco> elliott, that makes my setup quite impossible then I think =\
05:35:52 <augur> or equalonthenose or something like that
05:36:09 <elliott> erisco: you will have to change something, at least
05:37:07 <chrisdone> augur: =)
05:38:00 <augur> chrisdone: obviously you need a posh british accent if you're going to have such a username
05:38:33 <chrisdone> augur: like an edinburgh accent?
05:38:34 <erisco> elliott, so if I try (Container i1 a, Container i2 b) for imap, I get an ambiguous type error when calling 'show' in my main function
05:38:38 <augur> and you have to start all your conversations with "today we're going to talk about" followed by a keyword spoken in a kind of magical fashion
05:38:59 <erisco> elliott, again this looks to me like the information that i2 is paired with b is lost, or something. I dunno =\
05:39:21 <erisco> elliott, sorry here: http://paste.tryhaskell.org/90616
05:39:25 <augur> chrisdone: no no, you need whatever eugenia cheng's accent is
05:39:31 <chrisdone> augur: you mean like: https://www.youtube.com/watch?v=9fohXBj2UEI&html5=1
05:39:32 <chrisdone> =)
05:39:35 <augur> posh southern english accent
05:39:38 <augur> chrisdone: yes :)
05:39:43 <elliott> erisco: that imap should work
05:39:53 <elliott> erisco: just you have to specify what container type you get out of it when you use it
05:39:54 <banister> chrisdone: is that a worthwhile vid to watch?
05:39:59 <erisco> maybe but the usage site in main fails to ocmpile
05:39:59 <elliott> because it has no way to tell what kind of container you want back
05:40:03 <augur> chrisdone: i want to grow up to be eugenia cheng
05:40:12 <chrisdone> lol
05:40:25 <erisco> elliott, ah duh
05:40:31 <elliott> banister: if you want to know about the category theoretic definition of monads, sure.
05:40:43 <augur> i really wish they'd make some more catsters videos. they're both entertaining and educatinal!
05:40:44 <erisco> elliott, I have a variable return type going into a variable type argument :P
05:40:45 <chrisdone> banister: depends if you're familiar with the pictures that category theorists like to draw
05:40:55 <elliott> erisco: :)
05:40:58 <banister> elliott: does it have any prequisites ? i don tknow any category theory
05:41:05 <augur> i watch them every once in a while to refresh my memory. or because im bored.
05:41:19 <elliott> banister: perhaps not then. but no harm in trying.
05:41:21 <banister> but i have a strong background in mathematics, particularly calculus and some group/graph theory
05:41:24 <erisco> elliott, thanks for the help. I'll see what I can get now
05:41:43 <elliott> banister: I think you can follow the videos without any CT background if you do it in the right order, but I haven't personally watched many myself.
05:41:54 <banister> thx
05:42:43 <erisco> elliott, kinda cool I guess... makes sense that I can map from one container type to another, since they both comply with the Container class
05:43:13 <elliott> erisco: btw, your class is equivalent to toList :: i -> [x]; fromList :: [x] -> i. well... except that you can get the tail faster
05:43:47 <erisco> elliott, I realize that it is isomorphic with lists. that isn't really my point
05:44:00 <elliott> right
05:44:17 <erisco> it seems that Haskell is setup to convert between types in order to use certain algorithms
05:44:29 <erisco> that isn't what I am used to, per se, coming from other languages with interfaces
05:44:46 <banister> elliott: btw hav eyou seen this? https://www.youtube.com/watch?v=YScIPA8RbVE   it's pretty insane, he converts haskell type signatures to polynomials and then starts differentiating them/integrating them to derive some interesting properties about the types
05:44:50 <erisco> so I am exploring what it looks like in Haskell so I can see the contrast better
05:45:05 <banister> the algebra of algebraic types
05:45:55 <elliott> banister: haven't watched that talk but know the things being done
05:46:15 <augur> elliott, chrisdone: is it just me or is mathematics getting kind of popular in britain?
05:46:20 <erisco> elliott, if you were working in a decent OOP language, for example, converting your data structure to an array and then writing the algorithm to work with arrays isn't as common
05:46:41 <erisco> elliott, rather than having some interface which exposes what the algorithm needs to work
05:46:53 <erisco> seems to be two looks at the same problem of generalization
05:47:00 <chrisdone> augur: i've no idea. what are you basing that on?
05:47:07 <augur> marcus du sautoy had that docu on some maths topic, he's also cohosting school of hard sums with dara √≥ briain, and eugenia cheng's been in the media a bit lately
05:47:21 <elliott> erisco: eh, something like Monad is heavily on the side of interface not conversion IMO
05:47:24 <elliott> it depends
05:47:38 <chrisdone> augur: well dara has a degree in astrophysics or something
05:47:56 <augur> nonesense what
05:47:57 <erisco> elliott, and given that your data structure can have hidden information, if you implement the interface you can persist that, whereas converting to an array you have to somehow, then, convert back to your original data structure (depends on situation, but could easily be the case)
05:48:06 <augur> maybe an undergraduate degree but those dont count
05:48:47 <erisco> elliott, I kind of see that situation similiar to data types in Haskell where, if you look at my Segment example, you can't keep track of the size of the list if you convert to a list and pass it off somewhere else
05:48:57 <augur> chrisdone: sheesh, he studied math and theoretical physics
05:48:58 <augur> 0_0;
05:49:16 <luite> augur: it's cool that there's more attention for these topics in mainstream media :) i didn't terribly like du sautoy's books though, for some reason
05:50:06 <augur> luite: i havent read his books. i find popular writing to be unbearable most of the time. i think lightness is better suited to documentary format
05:50:12 <chrisdone> augur: yeah, doing maths and theoretical physics at university level is quite irregular for a comedian
05:50:18 <hvr> Attention all Emacs haskell-mode users: http://projects.haskell.org/pipermail/haskellmode-emacs/2013-June/000188.html
05:50:27 <hvr> & https://docs.google.com/forms/d/1FzWbzGm6odYWxJZcU3GFHlS3lVFTBOI1-M1c87CjOFg/viewform
05:50:52 <luite> augur: hmm, in general i do like popular math (or science) books
05:50:54 <erisco> elliott, I was trying to make this distinction clear yesterday without luck. Does this example make any sense to you?
05:51:03 <chrisdone> augur: i think there's more popularization for science than maths in the uk, particularly physics
05:51:08 <robde> is any data a constructor in haskell?
05:51:19 <luite> chrisdone: everywhere i think
05:51:40 <augur> chrisdone: i think both are there tho.
05:51:47 <elliott> erisco: it sounds like you're getting at something reasonable. I can't really comment in the general case -- have established my own intuitions that don't carry over to others :)
05:51:49 <augur> luite: anything you'd recommend?
05:52:14 <augur> also i dont really think there's much of a science/math popularization in the US right now, but then, i dont watch american TV so i have no idea >_>
05:52:17 <chrisdone> i listen to the Infinite Monkey Cage. it's not a detailed set of lectures, it's more of a 'popular science' comedy show
05:52:47 <chrisdone> hvr: \o/
05:52:52 <luite> augur: uh i'd have to check my collection
05:53:27 <luite> augur: discovery channel has some cosmology things?
05:53:44 <luite> uk has brian cox :)
05:53:45 <chrisdone> although i did learn something on the astrology episode, that when you're born does actually make a difference
05:53:48 <epta> Where can I find list of packages delivered with 2013.2.0.0 platform?
05:53:54 <chrisdone> luite: =)
05:53:54 <S_J> So. Are the openGL bindings any good for haskell?7
05:54:27 <NihilistDandy> epta: http://www.haskell.org/platform/changelog.html
05:54:47 <startling> S_J, they're about as good as you can expect a C API to be
05:54:58 <erisco> elliott, the ability to just choose which container I want my result in makes me giggle a bit... have never had that capability in anything I've used before
05:55:20 <elliott> yeah, return-type overloading is what separates haskell typeclasses from OOP interfaces :)
05:56:07 <augur> luite: im surprised discovery has anything worth watching these days
05:56:46 <chrisdone> and it's the reason aeson works. a capability which i've not seen in another (non-esoteric) language
05:57:23 <chrisdone> augur: the BBC seems the only place to get quality science/nature broadcasting
05:57:47 <CODEtaku> I think modern science/math popularization is centered around the Internet rather than TV... loads of fantastic content online and its pretty popular
05:58:17 <startling> chrisdone: discovery sometimes coproduces bbc things and sometimes runs them
05:58:20 <startling> e.g. planet earth
05:58:25 <hvr> chrisdone: we got already one
05:58:32 <chrisdone> hvr: fast =)
05:58:37 <hvr> chrisdone: ...response
05:58:48 <luite> chrisdone: well he's a cool guy, that really helps. we had in the '80s a pop science/technology tv program in the netherlands, but presented by a weird/nerdy guy. while it was a popular program, it has been said that he scared away many people from doing science or engineering in university :)
05:59:05 <hvr> chrisdone: and I just hot-added a new question: 'which OS'
05:59:09 <augur> chrisdone: school of hard sums is on Dave!
05:59:43 <chrisdone> luite: heh. yeah, i think Brian Cox is the new Carl Sagan for the UK
06:00:50 <chrisdone> hvr: i'm expecting 54% linux, 45% os x, 1% windows
06:00:58 <CODEtaku> that's a big pair of shoes to fill... but Cox is great, I've seen him on QI a couple times as well as in some other stuff
06:01:08 <luite> chrisdone: hm, what are the results?
06:01:18 <CODEtaku> for educational stuff on US TV, PBS has some good stuff, like NOVA is usually good
06:01:34 <luite> chrisdone: oh wait, sorry i didn't read
06:01:40 <chrisdone> CODEtaku: he makes a lot of programs about science, similar to sagan, talking about the universe and all that
06:02:05 <augur> we should take this convo to blah
06:02:11 <CODEtaku> I've seen a few of those too
06:02:13 <augur> its deffo not on topic here :x
06:02:19 <CODEtaku> sorry augur
06:02:21 <luite> ys
06:02:22 <luite> yes
06:02:28 <augur> CODEtaku: i started it! its all my fault!
06:02:47 <chrisdone> <sagan> if you wish to make an apple pie from scratch, you must first
06:02:48 <chrisdone> <cox> throw particles of sugar, egg, milk and apple at eachother at tremendous speeds in the Large Hadron Collider
06:03:10 <augur> chrisdone: lol
06:05:15 <luite> chrisdone: http://www.youtube.com/watch?v=HBuqAdgoXaA#t=0m48s
06:05:18 <hvr> chrisdone: what would make support easy... as linux and OSX are almost the same w.r.t. to process-handling... :)
06:06:40 <isomorphic> chrisdone:  I think a purist would travel to the beginning of time.
06:06:53 <chrisdone> luite: haha, the boring world of the 80's: huge boxes with three buttons
06:07:23 <luite> chrisdone: even for the 80s this was not the best way to popularize technology :p
06:07:24 <chrisdone> hvr: indeed
06:07:57 <chrisdone> luite: right, not many people watching thought "i wanna be that guy"
06:09:26 <chrisdone> isomorphic: sagan's original says "you must first invent the universe" =)
06:10:10 <chrisdone> luite: you use emacs right?
06:10:15 <luite> chrisdone: yes
06:10:21 <chrisdone> luite: fill in the survey!! http://projects.haskell.org/pipermail/haskellmode-emacs/2013-June/000188.html
06:10:32 <isomorphic> chrisdone:  I'd have accepted doing it on Jan 1 1970
06:10:40 <luite> chrisdone: i'm just setting up ghc-mod to work on a remote server
06:11:42 <luite> chrisdone: http://parenz.wordpress.com/2013/06/29/vado/
06:13:16 <chrisdone> luite: sounds similar to http://chrisdone.com/ghc-server.ogv =p
06:14:31 <luite> ah fun :)
06:14:42 <shachaf> Is there a name for an F-algebra which is an isomorphism?
06:15:00 <shachaf> I guess that's pretty much "fixed point".
06:15:14 <luite> chrisdone: nodan's gsoc project requires a lot of work with virtual machines so having it work is really convenient
06:16:00 <luite> chrisdone: vado is not just emacs though, it just runs any command remotely in the correct dir
06:16:55 <luite> chrisdone: really useful for compiling/testing your program in a vagrant vm
06:17:14 <hvr> chrisdone: fyi, a few reasons for not using haskell-interactive mode have been entered
06:17:34 <chrisdone> hvr: let me guess, no getLine support
06:17:35 <vlatkoB> I came across this definition. What does "default" means here?
06:17:35 <vlatkoB> import qualified Data.Text as T
06:17:35 <vlatkoB> default (T.Text)
06:17:40 <chrisdone> hvr: and completion
06:18:00 <hvr> chrisdone: ...what's 'getLine' support?
06:18:15 <hvr> chrisdone: ah, getLine :: IO String ?
06:18:33 <chrisdone> yes
06:18:52 <Lethalman> so I've somehow implemented the moore algorithm for finding the contour of an image: http://en.wikipedia.org/wiki/Moore_neighborhood
06:19:06 <Lethalman> mh hpaste down
06:19:06 <hvr> chrisdone: but no, that's not been mentioned as reason so far
06:19:40 <Lethalman> this is the relevant code: http://paste.debian.net/13424/
06:19:57 <Lethalman> didn't implement yet PolylineContour
06:20:01 <mauke> vlatkoB: http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4
06:20:06 <Lethalman> how does it look overall? :-)
06:20:21 <Lethalman> everything starts from contourFromBitmap
06:21:25 <vlatkoB> Thanks mauke. Hard to search web for word default :-)
06:21:36 <mauke> vlatkoB: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#overloaded-strings
06:36:33 <LordBrain> Anyone know how to write a function which takes a Sink and returns a Conduit ?  So that i can send outputs to two sinks at once?
06:38:31 <LordBrain> I see Data.Conduit.Binary has a function conduitFile which outputs to a handle and then yields, that's almost like what i want, but i don't want to deal with a handle but rather another Sink
06:48:13 <S_J>  OK, some good properties of linked list? (length $ insert (Node 5) xs) > (length xs ) ; what can more be said about properties for insert?
06:48:23 <S_J> (is my text orange to you too?
06:48:41 <shachaf> S_J: That's not true in Haskell, at least.
06:48:51 <shachaf> Your text is not orange to me.
06:49:28 <S_J> (good, so i can keep posting my text in ornag ewithout annoying anyone. just pain in the ass when you cant find your old posts)
06:50:03 <S_J> shachaf: how is that not true in haskell?
06:50:42 <S_J> > let xs = [1..10] in (length $ 5 : xs) > (length xs)
06:50:43 <lambdabot>   True
06:50:55 <S_J> > let xs = [1..10] in (length $ 5 : xs) == (1+(length xs))
06:50:56 <lambdabot>   True
06:51:01 <S_J> maybe better
06:51:09 <S_J> > let xs = [] in (length $ 5 : xs) == (1+(length xs))
06:51:10 <lambdabot>   True
06:51:25 <chrisdone> LordBrain: your nickname tickles me
06:51:28 <shachaf> It is not true for infinite lists.
06:51:41 <sipa> it's not false either :)
06:54:18 <pxqr> that's the difference between cabal 'ghc-options' and 'ghc-prof-options'?
06:55:19 <sipa> the latter is only used when building with profiling enaboed, i think
06:55:21 <shachaf> One of them is for profiling.
06:55:33 <shachaf> I can't remember which.
06:55:45 <pxqr> shachaf: :)
06:56:01 <pxqr> Well, but where should i specify -prof?
06:56:29 <pxqr> or maybe it cabal flag like --enable-benchmarks?
06:56:34 <geekosaur> --enable-{executable,library}-profiling command line option
06:56:48 <elliott> IIRC --enable-foo-profiling is useless because you don't get -auto-all or something
06:56:51 <elliott> maybe that was fixed
06:57:13 <geekosaur> also note that ghc-prof-options is *appended* to ghc-options when profiling
06:58:17 <pxqr> ok, I try
07:00:39 <isomorphic> chrisdone:  I've been tryout out the existential types‚Ä¶ I also found the section on exceptions in http://www.haskell.org/haskellwiki/Existential_type - is there a good reason that I cannot have a type like data TraceException s = forall a. (Show a,Typeable a) => OpenException s | SetoptException s ?
07:05:07 <LordBrain> anyone here familiar with conduits?
07:07:22 <pxqr> I'm familiar a bit
07:08:32 <LordBrain> well, i want to create a sort of conduit T function, so in otherwords, say i have two sinks, i want to make a new one which sends to both of them.
07:09:22 * hackagebot smallcheck 1.0.4 - A property-based testing library  http://hackage.haskell.org/package/smallcheck-1.0.4 (RomanCheplyaka)
07:10:21 <S_J> shachaf: would quickcheck generate an infinite list?
07:10:25 <LordBrain> in Data.Conduit.Binary there is a conduitFile function which sort of does it, but it's not what i want because it is using a handle and outputing to a file before yielding... i basically want to sort of yield to a different conduit, and then yield again
07:11:01 <LordBrain> can you help me figure out how to do that?
07:11:10 <bad_alloc_> Hi, I'm trying to understand monads. I've got a stack implemented in term of a monad and I need a function that pops N items of this stack and returns them as a list. I've got this: http://cxg.de/_8257f8.htm How do I get the popped elements? How do I bind them so I can get them later?
07:11:20 <ofan> LordBrain: use a broadcast Chan
07:11:43 <pxqr> LordBrain: that's interisting question, but I don't know how to do this using only conduit machinery.
07:12:31 <b52> anyone having acccess to fpcomplete's haskell center beta yet?
07:12:33 <LordBrain> ofan, point me to the right package, hackage url
07:12:52 <pxqr> LordBrain: base, stm packages
07:12:58 <ofan> LordBrain: check out stm-conduits
07:15:06 <LordBrain> ok, thanks
07:16:55 <banister> what's an elegant way to reverse a string in haskell?
07:17:13 <shachaf> reverse
07:17:31 <banister> shachaf: hehe, from first principles i mean :) for learning purposes :)
07:17:32 <rlp10> banister: reverse string
07:18:22 <nabilhassein> banister: reverse' = foldl (flip (:)) []
07:18:59 <shachaf> banister: For learning purposes, I'd recommend writing it yourself...
07:19:17 <shachaf> You could ask if you're stuck on something spe -- oh, wait, never mind.
07:19:35 <isomorphic> banister:  have you looked at the pattern matching syntax?
07:19:51 <mauke> reverse = flep [] where flep a [] = a; flep a (x : xs) = flep (x : a) xs
07:21:21 <isomorphic> banister:   You could make a reverse function out of things you find on this page: http://www.haskell.org/tutorial/patterns.html
07:21:37 <banister> isomorphic: thanks
07:21:48 <bhuemer> Hello, this might be a slightly silly question, but is there some built-in function that allows me to build a Just if some condition holds and returns nothing instead if it doesn't?
07:22:01 <bhuemer> I mean, I could easily write it myself, but I was just wondering ..
07:22:49 <LordBrain> return . guard  in the maybe monad
07:22:50 <shachaf> The easiest way to ask this question is to specify the type of what you want (and possibly its definition).
07:23:32 <shachaf> LordBrain: Uh, "return . guard"?
07:23:36 <LordBrain> no actually
07:23:40 <LordBrain> sorry
07:25:03 <absence> are f-algebras useful for compilers, or does the f a -> a type imply interpretation?
07:28:39 <mauke> > when False (Just ())
07:28:40 <lambdabot>   Just ()
07:30:59 <isomorphic> bhuemer:  What would be the value in the Just?
07:31:09 <bhuemer> some constant
07:31:36 <bhuemer> I mean, it's now literally just "if p == something then Just E else Nothing"
07:31:59 <bhuemer> I am probably just being pedantic here .. not wanting to have this if-then-else
07:32:18 <isomorphic> So, it's type would be Bool -> a -> Maybe a
07:32:37 <shachaf> :set -XMonadComprehensions
07:32:43 <bhuemer> yes
07:32:59 <shachaf> [E | p == something]
07:33:33 <supki> E <$ guard (p == something)
07:33:41 <LordBrain> i think the if then else is best
07:34:05 <supki> I guess monad comprehensions desugar to guard anyway
07:34:47 <LordBrain> if then else is very readable
07:36:09 <bad_alloc_> (Sorry for repeating:) I'm trying to understand monads. I've got a stack implemented in term of a monad and I need a function that pops N items of this stack and returns them as a list. I've got this code so far: http://cxg.de/_8257f8.htm How do I get the popped elements? How do I bind them so I can get them later? How do actually implement the scetched popn function?
07:36:15 <bad_alloc_> *sketched
07:36:59 <mauke> StackT is a misleading name
07:38:31 <bhuemer> yeah, I'll go for if-then-else
07:39:03 <mauke> bad_alloc_: your base case should be popn 0, not popn 1
07:39:04 * shachaf thinks [E | p == something] is pretty nice.
07:39:08 <bhuemer> on a different note though, I am about to write a function called doMaybe :: Maybe a -> (a -> b) -> Maybe b now
07:39:16 <bhuemer> I am sure that exists already
07:39:21 <shachaf> bhuemer: fmap :: (a -> b) -> Maybe a -> Maybe b
07:39:26 <mauke> bhuemer: fmap, liftM, <$>
07:39:35 <mauke> liftA
07:39:38 <bhuemer> ah, okay. :)
07:39:40 <bhuemer> thanks
07:40:12 <osa1> what happened to comonad/reader?
07:40:52 <mauke> bad_alloc_: reasoning looks ok, but line 39 can't be right because you're not using y anywhere
07:42:11 <bad_alloc_> mauke: Yes, I know. I'm generating N y s, which should all cover each other up. I don't know how to get these later on. Would a helper function help, that also gets a list with previous results?
07:42:21 <bad_alloc_> i.e. is it possible?
07:42:37 <mauke> bad_alloc_: you already have that helper function: popn
07:42:42 <mauke> you just need to use its results
07:44:44 <bad_alloc_> mauke: popn returns/is/...? a monad. how can I get the stuff it retruns as a list? (As you see I don't understand this stuff yet. sorry.)
07:45:17 <mauke> bad_alloc_: pop returns/is/...? a monad. how did you get the stuff it returns? :-)
07:46:11 <LordBrain> guard cond >> Just a
07:46:59 <bad_alloc_> Referring to this code with an obvious type error aorund (:) http://cxg.de/_887874.htm -> I used return which gives me a StateT t1 -> [t1] Monad again. The [t1] bit looks promising but how do I get it out of State?
07:47:02 <bad_alloc_> *StateT
07:47:21 <LordBrain> if it's in the middle of a pipe of composed functions, i'd use the guard
07:47:45 <mauke> bad_alloc_: how did you get y out of pop?
07:50:16 <bad_alloc_> mauke: Now I get it. I can use bind on the recursive call to get some x and since y is still accessible I can return y:x. Like so: http://cxg.de/_1b67a6.htm
07:50:35 <bad_alloc_> mauke: Now this makes much more sense, thank you :)
07:50:37 <mauke> yep
07:50:47 <mauke> but you should still define popn 0, not popn 1
07:53:02 <bad_alloc_> done :)
07:53:09 <mauke> @src replicateM
07:53:10 <lambdabot> replicateM n x = sequence (replicate n x)
07:53:13 <mauke> @src sequence
07:53:13 <lambdabot> sequence []     = return []
07:53:13 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:53:13 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
07:59:10 <S_J> trying to move quickcheck to see seems to still mean a lot of plumbing.
07:59:24 <chrisdone> Peaker: dude
07:59:28 <S_J> when creating a LinkedList, would you need to write an Arbitrary for it?
07:59:33 <S_J> and how much work is that?
07:59:35 <banister> is ther a way to pattern match on the last elemetn in a list? e.g (x:xs) gives me head and tail, but how do i get head and last item?
07:59:53 <Peaker> chrisdone, what?
07:59:56 <chrisdone> banister: there's no built-in support for that
08:00:05 <chrisdone> Peaker: i just learned that you can re-bind self-insert command in emacs o_o
08:00:23 <Peaker> chrisdone, what mischief is on your mind? :)
08:00:25 <chrisdone> Peaker: this changes EVERYTHING lol
08:01:16 <chrisdone> Peaker: well, a big problem with structured editing in a text buffer is that it's trivial to break things. with control over every key entered by the user, it's possible to manage that! and also do the whole "re-indent-as-you-type" thing
08:01:53 <chrisdone> Peaker: i mean, (1) make it read-only, (2) rebind to structured-haskell-mode-key and off you go!
08:02:40 <LordBrain> S_J: There is a last function, but the reason it's not built in pattern matching is because it would be order n on the length of the list.
08:03:08 <Peaker> chrisdone, great, would love to get nice emacs goodies with your name on them :)
08:03:50 <thoughtpolice> chrisdone: heh, you sound like you're surprised, as if you thought there was something emacs could not do :P
08:04:08 <chrisdone> Peaker: e.g. the classic:
08:04:09 <chrisdone> Peaker: foo = do bar
08:04:09 <chrisdone> Peaker:          mu
08:04:09 <chrisdone> Peaker: insert chars at "foo" and it breaks everything. with this i could bring everything along. maybe even do things like: foo `bar` zot ‚Üê kill "foo" but the mode would know that i was killed, and consider that area just "blank"
08:05:03 <LordBrain> Yeah, i remember Yi had that by default
08:08:41 <chrisdone> thoughtpolice: i thought this was one of the few things. but apparently not =p
08:14:23 * hackagebot acid-state 0.11.2 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.11.2 (DavidHimmelstrup)
08:21:56 <randomlogin> Is there any way to compile a file in unix with output .exe for windows?
08:22:28 <monochrom> no
08:22:55 <burp> wine ghc.exe
08:24:16 <ChongLi> just use a VM
08:24:25 <pxqr> is it possible to attach an SCC to a body of function like `f Foo = ...; f Bar = ...' using only one SCC pragma? or we are forced to introduce local function? (like worker/wrapper)
08:25:05 <tdammers> randomlogin: LLVM might be able to pull of such cross-compilation, but it's probably much much easier to just run a Windows port of the compiler in either Wine or a VM
08:25:34 <monochrom> pxqr: is it ok to attach to f instead?
08:25:48 <pxqr> monochrom: on caller side?
08:26:54 <monochrom> oops, nevermind, SCC are attached to expressions
08:27:04 <pxqr> yep
08:27:38 <monochrom> f x = {-# SCC "try_this" #-} case x of Foo ... Bar ...
08:27:57 <randomlogin> thanks for the answers
08:27:58 <monochrom> but if you don't want to rewrite like that, then I don't know
08:28:01 <pxqr> monochrom: yes, but if we have existing code...
08:29:02 <pxqr> also I don't completely understand difference between {-# SCC name #-} and {-# SCC "name" #-}
08:29:25 <pxqr> that the purpose of the first version?
08:29:31 <pxqr> * that's
08:29:53 <monochrom> double quotes can be omitted under suitable conditions. that's all.
08:30:16 <ofan> randomlogin: use gcc-mingw perhaps? it's a bit old though
08:30:53 <pxqr> I guess it only can be usefull when we change function of caf name;
08:30:59 <pxqr> *function or caf
08:33:02 <banister> where can i find the source for ghci ?
08:33:15 <banister> also does haskell have anything akin to 'eval' in other languages?
08:34:13 <inf-groupoid> banister: What is the point to making a complex type system if you are going to punch a huge hole through it?
08:34:24 <inf-groupoid> banister: Also, the source for ghci comes with ghc's sources.
08:34:27 <S_J> I'm thinking of changing my approach. Instead of writing quickcheck in C do you think it is possible to write a parser in Haskell that goes through the C files and look for thins like @property where some language to generate property based tests is defined? Makign a DSL for doing property based tests of C code? Am I spacing out here completely?
08:34:30 <banister> inf-groupoid: i was really just curious how REPLs and other live code editing/modification is possible
08:34:45 <ChongLi> banister: you might try looking in the GHC API
08:34:55 <sclv> there are wrappers like hint around it too
08:34:57 <ChongLi> if you want to compile/interpret haskell code at runtime
08:35:01 <geekosaur> you may be interested in the hint library. note that that embeds a copy of ghc (as a library) in your program
08:35:10 <ChongLi> ah there you go
08:35:36 <banister> can someone point to the ghc sources on github?
08:35:47 <banister> oh nm https://github.com/ghc/ghc
08:38:35 <geekosaur> ghci itself is in driver/ghci but I don't know how useful that will be to you
08:39:12 <banister> geekosaur: does ghci have any syntax highlighted (for example) variations?
08:39:23 * hackagebot fixedprec 0.2 - A fixed-precision real number type  http://hackage.haskell.org/package/fixedprec-0.2 (PeterSelinger)
08:39:56 <chrisdone> banisterread this source http://hackage.haskell.org/package/repl
08:40:42 <banister> thanks
08:40:50 <chrisdone> banister: i'm working on a ghci replacement presently
08:40:57 <banister> chrisdone: very cool, what features will it have?
08:41:10 <banister> chrisdone: it woudl be great if you could write somethign like show-source
08:41:16 <banister> to pull the source on a function
08:41:30 <banister> not sure how viable that would be
08:43:47 <chrisdone> banister: if it's in an external library it's hard
08:44:15 <chrisdone> banister: in the current project it's easy
08:44:27 <banister> chrisdone: interesting, how would oyu get it for the current project?
08:44:34 <ChongLi> with tags!
08:45:19 <chrisdone> banister: provided you've loaded your modules in, the interpreter has a list of names and their module and location and such
08:45:44 <banister> cool
08:46:13 <chrisdone> http://www.haskell.org/ghc/docs/7.4.2/html/libraries/ghc-7.4.2/Name.html
08:46:18 <banister> chrisdone: you should write your REPL as a webapp ;) ace/codemirror editors make it very easy
08:47:28 <luite> i suspect chrisdone already knows that
08:49:07 <roconnor> what are some examples of asycronous exceptions?
08:50:07 <S_J>  I'm thinking of changing my approach. Instead of writing quickcheck in C do you think it is possible to write a parser in Haskell that goes through the C files and look for thins like @property where some language to generate property based tests is written? Makign a DSL for doing property based tests of C code? Am I spacing out here completely?
08:51:51 <jmcarthur> S_J: seems possible to me, although you are going to have to work hard for it
08:52:09 <taylorgb> What kind of properties would you want to test in idiomatic C?
08:52:20 <S_J> yeah it seems maybe impossible.
08:52:29 <monochrom> roconnor: the type called AsyncException is an example
08:52:45 <S_J> Like anything should be possible. Chekc that the length of a lsit has increased by 1 when inserting
08:53:06 <S_J> so types and ways to generate random data has to be possible to generate
08:54:09 <applicative> S_J: I'm pretty sure J. Hughes and co. use their Erlang quickcheck in C
09:03:12 <banister> chrisdone: you are writing it as a webapp?
09:03:22 <banister> chrisdone: got any links to the git repo?
09:05:02 <S_J> Does anyone here think Scala actually offers something over Haskell when it comes to the language(not libraries or being able to use the JVM)?
09:07:23 <adimit> S_J: scala is lispy and dynamic. Haskell is strongly typed and ML-y. It's comparing apples and wird boars.
09:07:51 <b52> adimit: in how far is scala dynamic?
09:08:15 <adimit> b52: did I mix it up with scheme again? I always do that...
09:08:53 <applicative> scala isn't too lispy
09:08:55 <adimit> right, it's actually static.
09:09:03 <b52> adimit: i assume so, because it's not scala you're talking about
09:09:09 <adimit> yeah, it is.
09:09:20 <chrisdone> banister: no, it's a backend that you connect to over sockets. i'm using it for emacs
09:09:32 <banister> oh ok
09:10:03 <adimit> i'm horrible with names. I think *Scala* is better compared to OCaml than to Haskell though.
09:11:37 <KingofFerrets> Yeah, scheme is the lispy one.
09:12:26 <b52> S_J: i did the course at coursera moderated by the creator of scala and it felt like stepping down on the evolutionary ladder
09:37:57 <bhuemer> hello! is there something like mzero without having to restrict types to MonadPlus? I'm building a returnIf :: (MonadPlus m) => Bool -> a -> m a at the moment, but I am not quite sure whether it's okay to have this MonadPlus constraint in there
09:40:04 <geekosaur> what would it do?
09:40:30 <geekosaur> the whole point of MonadPlus is it says "this monad *has* an mzero"
09:40:34 <bhuemer> adimit: just read your earlier posts and I think you mixed up Scala with Clojure - that's the one with dynamic typing and all those lispy brackets running on the JVM
09:40:47 <bhuemer> oh, okay
09:41:57 <geekosaur> (unless you want fail, but that has its own problems. like throwing an exception in any monad that doesn't have the concept of an mzero-like value)
09:42:11 <geekosaur> (and many that do, because nobody redefined it)
09:42:31 <adimit> bhuemer: might have been that, true. So many lisps to keep apart.
09:46:34 <tac> @type on
09:46:35 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
09:46:41 <tac> @src on
09:46:41 <lambdabot> (*) `on` f = \x y -> f x * f y
09:47:01 <tac> Where is on defined?
09:47:08 <b52> Data.Function
09:47:41 <tac> > (+) `on` (+1) 0 2
09:47:42 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> a -> c))
09:47:42 <lambdabot>    aris...
09:48:18 <tac> > ((+) `on` (+1)) 0 2
09:48:19 <lambdabot>   4
09:48:45 <tac> What is the intended use case for on?
09:48:49 <Philippa_> bhuemer: being a foul-minded pundit, I tend to comment that fail is in fact made of fail. It's worryingly true
09:49:26 <Philippa_> (I /can/ think of occasions where one might want fail to only be catchable from the perspective of whatever's running the computation but not within the computation's language, sure)
09:49:47 <b52> > (compare `on` snd) ('a', 2) ('b', 3)
09:49:47 <lambdabot>   LT
09:50:09 <monochrom> tac: I think its intended use case, and its origin, is exactly as simple as f x * f y
09:50:18 <tac> b52: that makes sense
09:50:46 <banister> can someone xplain how this can output a result? take 5 $ foldr (\x acc -> x:acc) [] [1..]
09:50:51 <banister> i thought that foldr started at the end of the list
09:51:03 <banister> but how can it start at the end of the list when it's infinte?
09:51:25 <tac> Profunctors in Haskell would be modeled in category theory as Hask^op x Hask -> Hask, right?
09:53:09 <b52> banister: look at the definition: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:foldr
09:54:14 <monochrom> banister: foldr does not start at the end of the list. see my http://www.vex.net/~trebla/haskell/lazy.xhtml
09:54:32 <chrisdone> monochrom: what's trebla?
09:54:41 <tac> banister: foldr is the exact same as doing recursion with a [] case and a (x:xs) case.
09:54:42 <b52> so basically foldr (:) [] [1..] == 1 : (2 : (3 : (4 : ....
09:55:42 <monochrom> "trebla" = reverse "albert". that is all.
09:56:03 <S_J>  I think doing what I said before with a DSL to do quickckechk like sutf fi s really really hard... or im confusing myself and it is not even practically impossible
09:56:09 <tac> > (reverse . reverse) [1,2,3,4,5]
09:56:09 <chrisdone> monochrom: i like it
09:56:09 <lambdabot>   [1,2,3,4,5]
09:56:14 <tac> > (reverse . reverse) [1..]
09:56:18 <S_J> How is Erlan used to quickcheck c code and why is not haskell used?
09:56:20 <lambdabot>   mueval-core: Time limit exceeded
09:56:29 <tac> (Remember kids, reverse . reverse /= id)
09:56:42 <chrisdone> monochrom: albert lai, kid moved from china to english speaking country?
09:57:44 <yitz> tac: the original motivating case was for things like groupBy ((==) `on` foo), kind of a generalization of comparing for sortBy. but your use case is also fine.
09:58:09 <monochrom> legally, I have always been in english speaking places, from Hong Kong (when under British) to Canada
09:58:20 <chrisdone> monochrom: ahhh. cool
09:58:22 <banister> tac: given: foldr (\x acc -> x:acc) [] [1..5]    doesn't the '5' get passed in first, then the '4', then the '3', etc, so it appears like it's iterating from the RHS
09:58:31 <yitz> tac: in fact, maybe it happened the other way - comparing was added as a common special case of on
09:59:00 <tac> > foldr (\x acc -> x:acc) [] [1..5]
09:59:03 <lambdabot>   [1,2,3,4,5]
09:59:19 <b52> > foldr (:) [] [1..5]
09:59:20 <lacop> hey guys
09:59:20 <lambdabot>   [1,2,3,4,5]
09:59:27 <lacop> quick noob question
09:59:38 <lacop> I've a list of about ~1mil numbers on one line
09:59:40 <tac> > let f [] = []; f (x:acc) = x:acc in f [1..5] -- banister
09:59:40 <lambdabot>   [1,2,3,4,5]
09:59:46 <lacop> and I need to do some mappping on them
10:00:04 <lacop> however it's quite slow, I wonder if there is some way to speed this up?
10:00:04 <b52> f is actually id, isnt it?
10:00:07 <lacop> so far I got this
10:00:12 <tac> b52: extensionaly, yes
10:00:20 <lacop> l2 <- getLine
10:00:25 <yitz> lacop: use Data.Text
10:00:27 <tac> I was showing how foldr is just (primitive) recursion for lists.
10:00:30 <lacop> let ai = map read (words l2) :: [Int]
10:00:45 <lacop> print $ sum (map (min (k-1)) ai) + 1
10:01:12 <lacop> yitz: hmm, I will take a look at that, thanks
10:01:19 <yitz> lacop: or Data.Text.Lazy if you think memory might be a problem (shouldn't be nowadays for a million)
10:01:32 <Mon_Ouie> Wouldn't the foldr version be more similar to let f = []; f (x:xs) = x:(f xs) ? (of course you'd get the same result here)
10:01:39 <yitz> @hackage text
10:01:40 <lambdabot> http://hackage.haskell.org/package/text
10:02:03 <tac> oops, Mon_Ouie, I think I messed that up >_>
10:02:20 <tac> > let f [] = []; f (x:acc) = x: (f acc) in f [1..5] -- banister
10:02:21 <lambdabot>   [1,2,3,4,5]
10:03:18 <banister> thx
10:05:14 <lacop> yitz: is it not a standard package? I can't import Data.Text
10:06:17 <yitz> lacop: it's in the text library. are you using the Haskell Platform? it's included.
10:06:36 <yitz> lacop: are you using cabal to compile your program?
10:07:18 <lacop> just trying it in ghci
10:08:03 <lacop> I'm downloading haskell platform, but this is for a coding challenge website and it might not be available there
10:08:08 <lacop> I'll give it a try
10:08:15 <yitz> lacop: if you have the Haskell Platform, importing Data.Text ought to work in ghci. otherwise, run: cabal install text
10:08:16 <joeyh> anyone know what the cabal os() is for the Hurd? Someone told me os(gnu) was right, but hackage rejects uploads with that (and also rejects uploads with os(hurd)!)
10:08:22 <yitz> lacop: ah.
10:08:25 <yitz> lacop
10:08:32 <lacop> basically the code I have works, but on large inputs I get Time Limit Exceeded
10:08:42 <lacop> roughly 1mil integers is max
10:08:56 <lacop> I guess reading, spliting and parsing that line takes forever
10:09:24 <yitz> lacop: if text is not available, see if Data.ByteString is available.
10:09:29 <lacop> it runs in about 1.5 sec on my machine, time limit is 1sec and the speed should be comparable
10:09:38 <yitz> lacop: so you may need to use lazy text (or bytestrings)
10:09:56 <lacop> ok, thanks, I'll hack around for a while
10:10:08 <yitz> lacop: also it depends how you're parsing them.
10:10:44 <lacop> as above ^, let ai = map read (words l2) :: [Int]
10:10:46 <yitz> lacop: i've got to run. but people usually have fun here helping with this kind of thing if you paste your code
10:10:52 <yitz> @hpaste
10:10:52 <lambdabot> Haskell pastebin: http://hpaste.org/
10:11:02 <yitz> wait is hpaste working again now?
10:11:17 <lacop> not loading for me...
10:11:38 <yitz> urgh. ok, you're favorite paste site then. sigh.
10:11:41 <lacop> https://gist.github.com/lacop/94b99598692f2a7c37ad
10:11:42 <Taneb> If it's not loading, hastebin is good?
10:11:42 <yitz> *your
10:11:59 <yitz> Taneb: gists are fine too :)
10:12:02 <lacop> basically for ~1mil integers it takes about 1.2 secs to get to line 10
10:12:12 <lacop> just finding the max of that list
10:12:51 <lacop> oh and I'm using ghc --make if that makes any difference, although I can't change the compilation settings on the testing machine and have no idea what they use
10:13:26 <Taneb> Lines 4 and 5 would be better as "let (n:k:_) = l1i" (although that's just a style point)
10:14:25 * hackagebot git-annex 4.20130627 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20130627 (JoeyHess)
10:14:28 * hackagebot xss-sanitize 0.3.4 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.3.4 (GregWeber)
10:15:32 <monochrom> lacop: when long are the input lines?
10:16:10 <lacop> it's a list of integers, max about 1 million of them, each smaller than 1000
10:16:20 <lacop> so about 10e9 characters
10:16:53 <lacop> Taneb: thanks, I was sure there was a better way but couldn't find it
10:20:54 <jmcarthur> lacop: i'm going to guess that most of that time is spent parsing
10:21:10 <lacop> jmcarthur: yeah I think so too
10:22:20 <jmcarthur> lacop: also, you are using a two-pass algorithm, which means all of that is going to be allocated and reused. if you can convert your algorithm into one pass i bet you will fare a lot better overall
10:22:42 <lacop> well unfortunately the test machine gives me compilation error
10:22:43 <lacop> Could not find module `Data.Text.IO'
10:22:50 <lacop> so this won't work :/
10:23:35 <jmcarthur> you will need to install the text package
10:23:44 <jmcarthur> oh
10:23:47 <jmcarthur> this is not your machine
10:24:07 <lacop> yup, remote tester, you upload source, not binary
10:24:21 <jmcarthur> you could just use bytestring. for a string of numbers i don't see much advantage in text anyway
10:24:34 <lacop> I mean I can solve this with C/Python easy, but I'm using this as exercise to learn haskell
10:24:47 <lacop> ok, I'll have a look at bytestring, thanks
10:25:02 <b52> lacop: what kind of challenge are you doing?
10:25:03 <lacop> also, the twopass shouldn't matter, the parsing is like 90% of the time
10:25:33 <lacop> b52: not sure if you can access it without login but it's my university's ACM site and also a kind of programming challenge cource
10:25:39 <lacop> http://people.ksp.sk/~acm/problem.php?contest=Trening%20z%2020.%20februara%202009&problem=largebag
10:25:41 <jmcarthur> lacop: those allocations and the extra GCs are also going to cost you a lot.
10:25:52 <lacop> (most problem statements aren't in english, this one is)
10:26:21 <lacop> ok, well let me rewrite it with bytestrings and see if it helps
10:26:25 <jmcarthur> lacop: doing it in one pass will take less space. it will allow ghc to optimize away more intermediate values, or at least allow the GC to keep up with you
10:26:39 <jmcarthur> but yeah, the parsing is still going to be the bigger deal
10:26:45 <b52> lacop: nope, doesn't work, but thanks anyway
10:27:32 <bhuemer> is there something I can use to pattern match on an empty monad?
10:27:35 <lacop> b52: http://clip2net.com/s/5jwZnr, it's reaaly easy
10:28:09 <jmcarthur> bhuemer: what is an empty monad?
10:28:15 <bhuemer> mzero
10:28:26 <jmcarthur> bhuemer: whether you can pattern match on it depends on the monad
10:28:49 <jmcarthur> if its constructors are available you can, if not, you can't (although maybe there could still be some sort of view you can pattern match on)
10:29:03 <jmcarthur> but in the general case, you can't. there is no polymorphic way to do it
10:29:14 <mapreduce> How can the constructors be unavailable?
10:29:28 <jmcarthur> mapreduce: by not being exported from the module that defines the type
10:29:37 <mapreduce> Ah.
10:29:44 <jmcarthur> mapreduce: for example, the Prelude doesn't expose the implementation of IO
10:29:57 <bhuemer> jmcarthur: okay, thanks!
10:30:03 <mapreduce> Thanks.
10:31:00 <joeyh> hGetContents: user error (Pattern match failure in do expression at libraries/base/GHC/Event/Thread.hs:90:3-10)
10:31:08 <joeyh> now there's an error message you don't see every day!
10:32:03 <bhuemer> jmcarthur: sorry, once again, I was trying (Eq (m a), MonadPlus m) => now with if (monad == mzero) and that seems to work - at least it compiles already
10:32:20 <banister> which is the best websockets library in haskell?
10:32:27 <joeyh>   Just mgr <- getSystemEventManager -- the GHC code
10:32:28 <bhuemer> is there something radically wrong in that?
10:32:45 <jmcarthur> bhuemer: that sounds like something that should be compilable, sure. but it's not quite the same as what you asked for
10:32:57 <joeyh> ah, I think I found it in ghc trac
10:34:19 <jmcarthur> bhuemer: i interpreted your question as whether you can always discover whether some value is mzero, and the answer is 'no'. however, you can compare a value to mzero if there is an appropriate Eq instance. it's just not general enough to cover all MonadPlus instances, since not all type with MonadPlus instances will also have Eq instances
10:34:55 <bhuemer> oh, okay, thanks!
10:34:56 <jmcarthur> bhuemer: for that matter, there is no reasonable way to say that a MonadPlus is also an Eq, since they have different kinds
10:35:45 <jmcarthur> bhuemer: for example, unless your monad has an instance Eq (M a)   (note that there is no (Eq a) constraint),  you can't always do this for any type (a)
10:35:50 <jmcarthur> bhuemer: so it's not even a property of M
10:36:15 <jmcarthur> bhuemer: and if it does have such an instance, it never contains an (a) anyway, or it's a weird Eq instance
10:36:46 <bhuemer> yeah, I mean that's why I was wondering if there's a general way without Eq constraints
10:37:24 <bhuemer> for M a, a doesn't have to be an instance of Eq if all I am trying to do is to compare empty Ms - as far as I understand intuitively
10:37:36 <jmcarthur> bhuemer: no, it's the type that determines that, not the value
10:37:45 <jmcarthur> bhuemer: e.g.:
10:37:52 <jmcarthur> hmm
10:38:00 <jmcarthur> oh, got an example
10:38:15 <jmcarthur> > [] == ([] :: [Int -> Int])
10:38:16 <lambdabot>   No instance for (GHC.Classes.Eq (GHC.Types.Int -> GHC.Types.Int))
10:38:16 <lambdabot>    arisin...
10:38:33 <jmcarthur> bhuemer: ^^ that fails because there is no Eq instance for functions, even though the lists are actually empty here
10:38:46 <jmcarthur> bhuemer: the compiler can't tell they would be empty statically
10:38:57 <jmcarthur> bhuemer: and if it could then there would be no point in doing the comparison in the first place :)
10:39:26 * hackagebot buildwrapper 0.7.2 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.7.2 (JeanPhilippeMoresmau)
10:41:16 <banister> how do i convert an .lhs file to a .hs file?
10:41:29 <tac> You should just write an Eq instance for functions then ;P
10:41:43 <jmcarthur> banister: ghc should already support .lhs without extra work from you
10:41:48 <banister> jmcarthur: cool
10:41:49 <banister> thanks
10:42:02 <tac> > null ([] :: [Int -> Int])
10:42:02 <lambdabot>   True
10:42:35 <jmcarthur> :t null . Data.Foldable.toList
10:42:37 <lambdabot> Foldable t => t a -> Bool
10:42:53 <jmcarthur> bhuemer: that foldable thing i just typed might be a reasonable way to go
10:43:10 <jmcarthur> bhuemer: would work for any monad that is also foldable
10:43:11 <bhuemer> jmcarthur: but I can do: equal :: [a] -> [a] -> Bool, equal [] [] = True
10:43:23 <jmcarthur> bhuemer: sure, but try writing the rest of that function
10:43:42 <tac> Why does Foldable need to exist?
10:43:44 <jmcarthur> bhuemer: you have to be able to compare elements at some point
10:43:49 <tac> that is something I never understood.
10:43:53 <jmcarthur> tac: because it's super awesome!
10:44:04 <bhuemer> if all I want to see whether it's an empty list, then no
10:44:05 <tac> jmcarthur: What advantages does it provide over recursion?
10:44:07 <bhuemer> ?
10:44:25 <jmcarthur> tac: for one, it means you don't have to know the structure/representation of the data type at all
10:44:28 <jmcarthur> tac:
10:44:36 <banister> jmcarthur: still just out of curiosity, is there a way to go from a .lhs -> .hs ?
10:44:39 <jmcarthur> bhuemer: but that isn't what Eq does
10:44:42 <bhuemer> I mean, the other bit would be equal _ _ = False .. and the name would be misleading
10:44:46 <banister> i want to use someone elses code in my project, but it's all in a .lhs style
10:44:55 <jmcarthur> banister: automatically? maybe ghc has a flag to convert for you. i don't know
10:45:08 <jmcarthur> bhuemer: right. that's just not what Eq is supposed to do
10:45:17 <bhuemer> yeah, but that's what I was asking: is there a generic way to see if a monad is empty (without using Eq)
10:45:40 <jmcarthur> bhuemer: if you want something fairly general, my (null . Data.Foldable.toList) suggestion might work well for you
10:45:45 <tac> jmcarthur: Is it anything more than an initial algebra for a functor?
10:45:48 <jmcarthur> bhuemer: since it doesn't care about the type parameter
10:45:57 <bhuemer> I mean, to be fair, I didn't realise that that was my question when I asked it :D
10:46:22 <bhuemer> okay, I'll give that a go!
10:46:35 <bhuemer> thanks!
10:46:49 <jmcarthur> tac: it's a certain class of initial algebras. foldMap is probably the most informative function in the class
10:47:26 <tac> jmcarthur: reading the docs.... I don't see the answer here, but are there any coherence laws for the class?
10:48:39 <jmcarthur> tac: could you define your usage of "coherence" here?
10:49:07 <tac> Functors must satisfy fmap id = id and fmap (f.g) = fmap f . fmap g
10:49:15 <tac> Monads must satisfy the monad laws
10:49:21 <tac> etcetc
10:49:42 <jmcarthur> i understand what laws are. i just wasn't sure if "coherence" was meant to change my interpretation of your question
10:49:51 <tac> Is any arbitrary Monoid m => (a -> m) -> t a -> m automatically good enough to be a Foldable?
10:50:17 <jmcarthur> i think it might be
10:50:26 <jmcarthur> hmm
10:50:29 <jmcarthur> hold that thought
10:50:55 <tac> I guess nLab wants me to believe "coherence" is usually only used with higher categorical things. So ignore that word :P
10:51:45 <roconnor> tac: I'm not aware of any laws for foldable beyond any free theorems.
10:51:47 <jmcarthur> yeah, i think Foldable needs to laws
10:51:51 <jmcarthur> *no laws
10:51:55 <tac> hmm
10:52:17 <roconnor> @free fold
10:52:18 <lambdabot> Extra stuff at end of line in retrieved type "(Foldable t, Monoid m) => t m -> m"
10:52:34 <roconnor> @type fold
10:52:35 <lambdabot> (Foldable t, Monoid m) => t m -> m
10:53:12 <roconnor> anyhow, there are free theorems such as foldable must commute with monoid transformations.
10:53:17 <tac> so... foldMap is something like.... it maps a monoid-valued function, then concatenates it?
10:53:32 <jmcarthur> that's basically it
10:53:57 <tac> ah, I see what you mean about free theorems, I think.... maybe
10:54:10 <tac> You can always just return mzero though.... no concatenation required
10:54:58 <tac> Confounded "practical minded" Haskellers....
10:55:01 <tac> :P
10:55:22 <roconnor> tac: foldMap (alpha . f)  = alpha . foldmap f  where alpha :: (Monoid a, Monoid b) => a -> b  is a monoid homomorphism
10:55:57 <jmcarthur> i felt like Foldable and Traversable seemed kind of arbitrary at first, but actually they have tons of nice properties
10:55:58 <roconnor> but this is free
10:56:16 <jmcarthur> :t foldMap
10:56:18 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
10:56:19 <jmcarthur> :t foldMap.foldMap
10:56:19 <lambdabot> (Foldable t, Foldable t1, Monoid m) => (a -> m) -> t (t1 a) -> m
10:56:23 <jmcarthur> :t foldMap.foldMap.foldMap
10:56:23 <lambdabot> (Foldable t, Foldable t1, Foldable t2, Monoid m) => (a -> m) -> t (t1 (t2 a)) -> m
10:56:27 <jmcarthur> :t traverse
10:56:27 <lambdabot>     Not in scope: `traverse'
10:56:28 <lambdabot>     Perhaps you meant one of these:
10:56:28 <lambdabot>       `T.traverse' (imported from Data.Traversable),
10:56:35 <jmcarthur> :t T.traverse
10:56:36 <lambdabot> (Applicative f, T.Traversable t) => (a -> f b) -> t a -> f (t b)
10:56:38 <jmcarthur> :t T.traverse . T.traverse
10:56:39 <lambdabot> (Applicative f, T.Traversable t, T.Traversable t1) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
10:56:41 <jmcarthur> etc.
10:57:20 <jmcarthur> the fact that you can do that forms the basis of lenses in the style of the lens package
10:59:13 * tac has no idea what lens is.
10:59:49 <jmcarthur> tac: https://github.com/ekmett/lens/wiki/Overview
10:59:59 <tac> roconnor: Can you really get "alpha is a monoid-hom" for free?
11:00:15 <tac> jmcarthur: I've made attempts at lenses... I just don't see the purpose or motivation for them.
11:00:50 <tac> It could have something to do with the fact I never really quite understood Foldable and Traversible though
11:01:20 <tac> Personally, I'd like to either know what a lens is good for, or I'd like to know its underlying theoretical interpretation.
11:01:37 <jmcarthur> tac: the original motivation for lenses is nothing more than something like composable references. the lens library is more of a swiss army knife, though.
11:01:38 <roconnor> tac: modulo non-termination issues, yes.
11:01:46 <barrucadu> tac: Watch the very long video on http://lens.github.io/, it does a fairly good job at explaining why they're good
11:02:09 <tac> Maybe I will try them again some time.
11:02:29 <tac> Thanks for taking the time guys
11:02:31 <tac> I gotta run real quick
11:02:36 <roconnor> lenses are used to access and update deeply nested record (and record-like) structures.
11:02:58 <roconnor> tac: I didn't understand the point of lenses either untill I was working on a program with deeply nested record structures.
11:04:11 <Philippa_> I'm pretty damn sure I'd have to learn them if I planned on doing 'serious' gamedev in haskell
11:04:30 <Philippa_> (bonus points: if you can get the inliner to be suitably aggressive, they give you a whole new world of cheap indirection)
11:04:38 <roconnor> said program was a game I was trying to implement. :)
11:04:51 <Philippa_> funny how that works, isn't it? :-)
11:05:22 <Philippa_> gamedev throws up a lot more 'interesting' engineering problems than people like to talk about, even if it's not the 'cutting edge' that a lot of people liked to insist in the late 90s and early 00s
11:07:28 <roconnor> fortunately lenes are not that hard to learn.  The trick is to not read the implementation. :D
11:08:42 <Philippa_> Figured that much :-) Honestly, the only reason I'm not learning a pile more than I am is that the amount of code I'm writing is tiny
11:09:04 <roconnor> There is no rush to learn lenses :D
11:15:13 <mapreduce> A Scala-centric but otherwise good explanation of lenses: http://www.youtube.com/watch?v=BiHH3LzKV04
11:15:19 <adimit> does lens-y code take a performance hit over non-lensy code? I remember the instantiation of Typeable might not be very beneficial (but I just read that somewhere, so maybe it's not correct.)
11:16:34 <roconnor> adimit: Typeable?
11:19:01 <jmcarthur> adimit: lenses don't have anything to do with Typeable, really
11:19:09 <adimit> roconnor: hm. I'm trying to find what I had read, but I don't think I'm remembering correctly. Doesn't seem like  lens implementations derive Typeable.
11:19:22 <Philippa_> roconnor: yeah, it's more that having had an especially dire couple of years for writing code I'd like to get more done. Pretty sure I'll have a use for them sooner rather than later
11:20:11 <jmcarthur> adimit: lens might make it easier to write inefficient code (e.g. needlessely reaching into and reconstructing deeply nested records in a loop instead of just doing it all in one traversal), but there is nothing *fundamentally* slower about lenses that i know of
11:20:41 <adimit> jmcarthur: great to hear :-) I really need to get into lenses more, but there's no game dev on the horizon for me.
11:20:55 <adimit> (I'm sure I could use them for a lot of other things too.)
11:21:04 <jmcarthur> contrary to other claims made here, i don't think game dev is any more amenable to lenses than any other kind of application
11:23:06 <adimit> might be the right time to ask: I know of vinyl, which kind of combines extensible records and lenses (I *do* have a use for extensible records in a project of mine.) Are there any other approaches out there?
11:23:32 <jmcarthur> the lens library is probably the favorite of the bunch these days
11:23:42 <jmcarthur> it's also the most different
11:24:34 <pxqr> I get confused by the choice "binary vs cereal" again. :<
11:25:02 <pxqr> + "binary-conduit vs cereal-conduit" :<
11:25:20 <roconnor> cereal is like binary but better.
11:25:29 <pxqr> why?
11:25:30 <roconnor> Well, I may have heard that binary got better
11:25:39 <b52> pepsi is like coce, just better.
11:25:48 <pxqr> one thing I want is NO copying in both encode and decode;
11:25:52 <roconnor> cereal has the ability to catch deserialization failures
11:26:07 <pxqr> + reliable streaming from/to sockets  using conduits
11:26:39 <hpaste> monochrom pasted ‚Äúlarge bag‚Äù at http://paste.tryhaskell.org/90621
11:26:58 <pxqr> roconnor: did you mean 'fail'?
11:27:19 <monochrom> lacop: see the paste above, http://paste.tryhaskell.org/90621 , jmcarthur is right, bytestring is like more than 10x faster
11:27:35 <roconnor> as when a byte stream is not a valid encoding of anything
11:27:58 <roconnor> decode :: Serialize a => ByteString -> Either String a
11:28:17 <roconnor> in cereal, decode has an Either output
11:28:37 <roconnor> decode :: Binary a => ByteString -> a
11:28:39 <monochrom> bytestring and its readInt, to be exact
11:28:51 <roconnor> in binary, there is none
11:29:09 <monochrom> I don't actually know whether it's [Char] or it's read that's slow :)
11:29:56 <monochrom> [Char] is, of course, a lot of memory and may hurt cache to begin with
11:29:57 <pxqr> roconnor: well, I don't use decode at all. I use {conduit,cereal}-conduits which should handle error stuff.
11:30:15 <monochrom> followed by a lot of pointer deferencing :)
11:30:34 <FreeFull> Apparently ByteString is bad if you have some ByteStrings stay around for a long time
11:31:04 <roconnor> ByteStrings are pinned
11:31:12 <monochrom> yes, use copy if you run into that
11:31:19 <pxqr> does getByteString from binary always copy?
11:32:18 <monochrom> but I'm using: 1. lazy bytestring; 2. unfoldr over it to [Int]; 3. foldl' over that [Int]. so I'm fine, it's come fast go fast.
11:32:30 <pxqr> there are a lot of CPS in binary sources, I do not understand;
11:33:24 <Philippa_> jmcarthur: I think it's more that we think gamedev in Haskell is /really painful/ without something like lenses
11:34:27 * hackagebot acid-state 0.11.3 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.11.3 (DavidHimmelstrup)
11:35:39 <monochrom> the badness criterion is a bit more detailed than just "stay for a long time". it has to be: the original bytestring is big, and you only use a small piece of it in the long run.
11:35:40 <jmcarthur> Philippa_: i don't feel like lenses buy much for games, to be honest. i think this tendency to use lots of nested records in games is often a mistake.
11:36:38 <Philippa_> well, it's not just the nesting: it's the referencing. But I'm all ears for an actually practical, scalable alternative
11:37:10 <mauke> >SCALAble
11:37:12 <Philippa_> ("scalable" - if I start getting annoyed with it by the time I'm writing something the complexity of, say, UT's deathmatch mode, it doesn't scale and sure as hell belongs nowhere near anything bigger)
11:37:30 <pxqr> If I didn't specify -auto-all but get this: http://dpaste.com/1276437/
11:37:39 <pxqr> how to omit this?
11:38:01 <Philippa_> (similarly, if I'm expected to know the entire game design up front, the implementation technique is useless)
11:38:30 <Philippa_> jmcarthur: now, if we want to talk about data-oriented design in games, I figure lenses are a good enabling technique for doing that under the hood :-)
11:38:44 <jmcarthur> ah you preempted me
11:38:52 <jmcarthur> i don't see the applicability of lenses to this
11:38:53 <Taneb> lenses + StateT + zoom is pretty good
11:38:58 <jmcarthur> i have to go though
11:39:07 <Philippa_> lenses are /abstractable/ first-class record access
11:39:25 <Philippa_> the abstraction bit being important if your in-memory layout is something else entirely
11:39:45 <Philippa_> make enough sense before you run? :-)
11:40:51 <travisb> hmm... just got an idea for my next project after my strict lists... wrapping unicode (probably internally UTF-8) around ByteString to create something with the properties of ByteString but natively supporting Unicode characters (unlike ByteString.Char8)
11:41:34 <travisb> so one can get the properties of ByteString without having to worry about lazy of Unicode support
11:41:55 <travisb> *lack of*
11:42:00 * geekosaur wonders what's wrong with Data.Text
11:42:10 <travisb> isn't Data.Text slow?
11:42:46 <travisb> (at least in the test I saw testing Haskell string performance with different kinds of stringy types. Text made normal Strings look fast)
11:43:12 <geekosaur> that is nerws to me
11:43:49 <travisb> http://honza.ca/2012/10/haskell-strings
11:44:59 <applicative> that was about Data.Char, really, in the end
11:45:19 <geekosaur> I think if text were that fundamentally bad, it would not be standard
11:46:16 <startling> can I construct data Tree k a = Tree [(k, Either a (Tree k a))] in some clever way using Free or something?
11:46:18 <travisb> in that test, from looking down, they did manage to get an okayish version that used lazy Text and lazy IO, but the fastest one was still definitely the one that used ByteString
11:46:47 <geekosaur> well, yes, ByteString will generally be fastest.. specifically *because* it doesn't do Unicode
11:46:52 <applicative> yes but things turned crucially on unicode
11:46:56 <geekosaur> guess what happes if you add Unicode on top of it?
11:47:18 <applicative> the its Text, sort of
11:47:21 <startling> well, specifically utf-8, right?
11:48:28 * travisb wonders what the difference between parsing UTF-8 on-the-go and expanding UTF-8 once to, well, UCS-4, and then converting that back to UTF-8 once upon output would be
11:48:46 <fluffynukeit> hi all.  I'm looking for a function like words, but that also groups by quotes.  For example, fxn "here is a \"test quote\" string" would return ["here", "is", "a", "test quote", "string"].  Does this function exist?
11:48:55 <supki> I thought that thing was about concatenating a bunch of small Texts without Builder
11:49:29 <supki> awful perfomance is kinda as expected then
11:49:38 <travisb> supki: I just notice that from looking back at the code
11:49:58 <applicative> fluffynukeit: import Datal.List.Split
11:50:50 <applicative> fluffynukeit: I think the split package comes with the Haskell Platform now by the way
11:50:59 <fluffynukeit> applicative: I have that module imported but it's not obvious how to construct what I want from the combinators
11:51:16 * travisb wonders what performance one would get with that test if using, say, Python with *Unicode* strings or Java with its strings
11:51:41 <travisb> (because that would eliminate Unicode support (or not) as a factor in the test)
11:51:42 <monochrom> don't wonder, do your test, and blog it
11:51:55 <yitz> applicative, fluffynukeit: i think you can even use the functions in Data.Text for that quite easily
11:52:04 <applicative> for that,yes
11:52:15 <startling> travisb, I think that's Data.Text.Lazy
11:52:21 <S_J> Does someone have an interesting idea on how you could analyze C code and check for errors? (I ask here because I'd write the parser in haskell).
11:52:23 <startling> oh
11:52:40 <startling> travisb, your first wondering, I mean
11:53:10 <yitz> applicative: split is nice, but it is kind of an in-between case between just Data.Text and a parser. i end up rarely using it i find.
11:53:21 <applicative> fluffynukeit: splitOn "\""
11:53:29 <applicative> yitz of course I agree
11:53:52 <travisb> applicative: first that would require me to start a blog
11:54:15 <applicative> yitz I used it a lot when I was first learning haskell
11:54:32 <applicative> travisb: i think that was monochrom's advice
11:54:36 <yitz> actually this case is a little bit subtle. you only want to split on spaces in the second round on parts that were not between quotes. maybe use a parser for this one...
11:54:54 <yitz> applicative: i would have too if it had existed then :)
11:54:56 <travisb> applicative: yeah, I know
11:54:58 <applicative> S_J there is a C parser already
11:55:09 <fluffynukeit> applicative, yitz: yes, yitz identified the subtlety
11:55:40 <monochrom> nooo! start a blog lazily. do the test first. if the result is not worth blogging, then there is no need to force "start a blog".
11:55:54 <applicative> S_J: http://hackage.haskell.org/packages/archive/language-c/0.4.2/doc/html/Language-C-Parser.html
11:55:58 <monochrom> unsafeInterleaveIO (start_blog)
11:56:16 <yitz> fluffynukeit: you could check to see whether the original starts with " and then split only the odd or even components in the second round. bit of a hack though.
11:56:21 <applicative> S_J: I dimly remember something about the linux kernel code being parsed with it
11:56:33 <travisb> so I should avoid starting a blog *imperatively* then
11:56:58 <lelf`> what do you call function if f^2 ‚â° id?
11:57:09 <monochrom> you should avoid doing anything eagerly :)
11:57:27 <mauke> self inverse
11:57:32 <yitz> travisb: no problem with that, monochrom already issued the command to start a blog
11:57:36 <fluffynukeit> yitz: and it would get pretty complicated if quotes don't come in pairs
11:57:49 <supki> lelf`: involution
11:58:23 <tomboy64> for debug purposes i would like to map over a lambda that looks like that: (\n -> putStrLn (expression involving n))
11:58:31 <tomboy64> but when i compile it i get: Couldn't match expected type `IO t0' with actual type `[IO ()]'
11:58:39 <monochrom> (assuming f not‚â° id)
11:58:49 <yitz> fluffynukeit: well using splitOn by definition pairs them up. you might end up with a dangling quoted component with no closing quote. the proposed algorithm treats that component as quoted.
11:59:10 <edvardkk> tomboy64: mapM ?
11:59:12 <lelf`> mauke, supki: thx
11:59:14 <tomboy64> how do i get couple of putStrLn over different arguments running?
11:59:17 <mauke> edvardkk: mapM_
11:59:35 <tomboy64> gonna look at that. thanks.
11:59:51 <mauke> putStr (unlines (map (\n -> ...) things))
11:59:56 <fluffynukeit> applicative, yitz: I will attempt to develop something usable using the split combinators.  Thanks.
11:59:59 <edvardkk> mauke: yeah, course. point being, vanilla "map" is not what he wants :p
12:00:01 <yitz> tomboy64: Debug.Trace.trace
12:00:11 <mauke> edvardkk: it is if you pull the putStr out
12:00:25 <fwappy> How can we know that in "class Functor f where", f is not a concrete type? Can you only understand that by looking at the type signature for fmap, which includes "f a" and "f b"?
12:00:31 <fwappy> :t fmap
12:00:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:00:33 <mauke> fwappy: yes
12:00:59 <fwappy> mauke: got it, thanks.
12:01:04 <mauke> and I'd say "has kind * -> *" instead of "is not a concrete type"
12:01:20 <travisb> okay little implementation question:
12:01:28 <edvardkk> mauke: yeah. I assumed the IO action was the essence
12:01:42 <travisb> if I'm implementing group so as to be identical in semantics to Data.List.group
12:01:47 <yitz> edvardkk: learning a new language?
12:02:11 <edvardkk> yitz: yeah, how?
12:02:20 <yitz> the nick
12:02:33 <edvardkk> haha. once again :-)
12:02:33 <travisb> should I swap each sublist made, just in case (==) does not actually make sure that values are identical (due to possible implementations of Eq not following what (==) should do)?
12:02:53 <mauke> travisb: huh?
12:02:57 <travisb> or should I just assume that everyone makes a sane implementation of (==), and save processor time by not flipping the intermediate lists
12:03:15 <mauke> what do you mean by "swap"?
12:03:16 <mauke> what do you mean by "flip"?
12:03:35 <travisb> mauke: reverse
12:03:39 <startling> are there any nice functional scripting languages for haskell?
12:03:40 <mauke> ‡≤†_‡≤†
12:03:51 <ion> startling: How about Haskell?
12:03:53 <mauke> travisb: why are your sublists reversed in the first place?
12:03:56 <travisb> startling: why would one want one, when one has Haskell
12:04:04 <yitz> travisb: that's actually a good question. sometimes people complain about the standard library implementation for a reason like that.
12:04:09 <edvardkk> yitz: On average, I get one "edwardk"-comment per hour :p
12:04:09 <startling> ion, travisb: god damn it
12:04:19 <travisb> mauke: I'm working with strict lists, so I am building each sublist in reverse order
12:04:46 <int-e> travisb: "reverse" may be a better word then
12:04:57 <yitz> edvardkk: i guess it's a good nick then. or a bad one, depending on whether you want to attract attention.
12:05:13 <tomboy64> yitz: thanks, but i want something without extra modules
12:05:24 <ion> edvardkk: You picked that nick without knowing about edwardk?
12:05:36 <yitz> @src group
12:05:36 <lambdabot> group = groupBy (==)
12:05:44 <yitz> @src groupBy
12:05:44 <lambdabot> groupBy _  []       =  []
12:05:44 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
12:05:44 <lambdabot>     where (ys,zs) = span (eq x) xs
12:05:55 <edvardkk> ion: yes. I was assigned this username at uni long before I knew much about haskell, and definitely before I knew about edwardk
12:06:01 <yitz> @src span
12:06:01 <lambdabot> span _ xs@[]                     =  (xs, xs)
12:06:01 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
12:06:01 <lambdabot>                   | otherwise    =  ([],xs)
12:06:04 <ion> edvardkk: That is awesome.
12:06:11 <edvardkk> haha :-) I don't know
12:06:13 <travisb> okay I just remembered how I'm implementing span
12:06:27 <edvardkk> my parents actually considered "edward" for my first name. would be even better
12:06:49 <travisb> I could just basically use that implementation using my span, and just building my *outer* list in reverse order and then reversing that
12:07:07 <travisb> but my internal span basically builds its lists in reverse order itself and then reverses that
12:07:22 <FreeFull> My grandfather is called Edward
12:07:47 <yitz> travisb: or don't bother if you don't think it will be a problem for your users. up to you, really.
12:07:58 <travisb> so if I made, say, revGroupBy use my revSpan I could make it non-negligibly faster than groupBY
12:08:09 <edvardkk> FreeFull: you should get him on #haskell
12:08:39 <travisb> (as revSpan returns the first list it produces in reverse order, by not reversing it once it's built it)
12:09:02 <yitz> edvardkk: for a while there were something like four people named ivanX where X varied among lower-case letters
12:09:10 <mauke> we could use more Simons
12:09:16 <yitz> haha
12:09:18 <travisb> I'm probably going to implement groupBy so it produces the most "correct" ordering, while revGroupBy (which one would want for faster performance) doesn't
12:09:26 <edvardkk> haha :)
12:09:33 <yitz> mauke: yeah an important one has become far less visible lately
12:10:11 <leftblank> 178.79.162.10
12:10:36 <klrr> sry if this is a really stupid question, but if you compile a haskell program, can you distribute that as a binary and the people installing it doesnt need to download any extra libraries?
12:10:43 <yitz> travisb: sounds like a nice compromise. although you would have to group a *huge* amount of data before the difference would become significant in practice.
12:10:46 <FreeFull> edvardkk: He doesn't even use mobile phones =P
12:10:55 <monochrom> klrr: yes by default
12:11:10 <monochrom> if GHC.
12:11:18 <ion> klrr: They may need libgmp with GHC-compiled binaries.
12:11:28 <klrr> okey thats good
12:11:28 <FreeFull> Can libgmp be statically linked?
12:11:44 <yitz> monochrom: didn't they say that default might change soon? or did they change their minds?
12:11:45 <monochrom> but libgmp is from user's linux repo, not from GHC
12:11:54 <klrr> i got a very limited VPS and i dont want to install the whole haskell-platform :P
12:11:56 <travisb> yitz: especially since the two would actually scale in time, stack space, and heap space identically, but have a constant factor difference in time used; but then, I've made these kinds of versions for *lots* of functions I've written for this
12:12:04 <FreeFull> I'm just Filip
12:12:08 <FreeFull> Any other Filip here?
12:12:10 <monochrom> ah, they said that, but not observed in 7.6.3
12:12:23 <monochrom> (and they already said that during the days of 7.4)
12:12:27 <daannyy> hello guys, i would have a question for you
12:12:32 <akegalj> is there "lines" function which splits over \r\n?
12:12:38 <yitz> FreeFull: felipe_
12:12:45 <monochrom> yes, it's called "lines" exactly
12:13:00 <akegalj> hm...
12:13:09 <applicative> klrr there are complexities, but see https://code.google.com/p/pandoc/downloads/list
12:13:13 <mauke> monochrom: no
12:13:35 <lelf> > lines "a\r\nb"
12:13:36 <lambdabot>   ["a\r","b"]
12:13:42 <mauke> akegalj: why do you have \r\n?
12:13:48 <applicative> klrr: the scripts he uses are in the repository https://github.com/jgm/pandoc
12:14:13 <monochrom> oh, I see, \r. but getLine, getContents etc already filter out \r
12:15:05 <monochrom> you have to explicitly openBinary to see \r
12:15:22 <travisb> what about text internet protocols that use
12:15:24 <travisb> \r\n
12:15:37 <yitz> klrr: that might help a little if your VPS is limited in disk space. but if it's very limited in memory, you're not going to get very far trying to compile on the VPS.
12:15:52 <aristid> travisb: they rarely use getContents or openBinary ;)
12:16:31 <yitz> klrr: make yourself a VM on your local machine that matches the architechture of your VPS but has lots of RAM
12:16:44 * travisb just thought of HTTP, where one has the text part of a connection as text with \r\n, but the data portion as binary data where one cannot filter out any \rs
12:16:45 <akegalj> mauke: data is saved that way on filesystem
12:16:58 <yitz> klrr: in which case, might as well give it lots of disk space, too, and then you can install whatever libraries you'd like
12:17:00 <mauke> akegalj: why?
12:17:21 <monochrom> ok, for internet protocols, you have to be talking about socket and then Handle from a socket. yes it defaults to binary mode by then, but you can always hSetBinaryMode h False
12:17:23 <akegalj> i suppose couse it comes from windows users
12:17:33 <akegalj> it's some buissiness data
12:17:54 <travisb> monochrom: my point was that for, say, HTTP you can't do that, as there's the binary portion which would be corrupted if you did that
12:18:06 <applicative> the important thing is for every file to being with a 'byte order mark'
12:18:12 <applicative> begin with
12:18:31 <monochrom> akegalj, if you use getContents or openFile or readFile etc, on Windows, repeat: on Windows, it already converts \r\n to just \n for you. on Windows.
12:19:13 <yitz> i hate BOMs. there is a lot of broke software that leaves them in UTF-8 and makes all kinds of messes
12:19:29 <akegalj> monochrom: yes i know. Product will be for win users but i am developing it under linux. But i'll preprocess
12:19:37 <travisb> we can largely blame Microsoft for BOMs in UTF-8 text
12:19:59 <monochrom> then my bad. look up hSetNewlineMode in System.IO. in fact, read the whole doc.
12:20:15 <akegalj> monochrom: will do. thnx all
12:20:23 <monochrom> how many people have not read the doc of System.IO from top to bottom?
12:20:33 <mauke> o/
12:20:53 <monochrom> if the last time you read it was 2005, read it again, totally changed.
12:21:01 * applicative has not read  the doc of System.IO from top to bottom
12:21:15 <travisb> neither have I
12:21:41 * yitz tried reading it again after it changed but it came up in the wrong encoding
12:22:00 <mauke> I just assume it works more or less like Perl
12:22:34 <yitz> it used to work like Perl. now it works a little more like Python. but not quite.
12:24:33 <FreeFull> I haven't
12:25:12 <chrisdone> yeahhh
12:25:20 <chrisdone> got xmonad back on
12:25:25 <chrisdone> enough of that buggy-ass unity
12:25:32 <tac> @src fixIO
12:25:32 <lambdabot> Source not found. I am sorry.
12:26:23 <tac> God bless the average Haddock docs
12:26:31 <tac> Gives you the type, not a word on what a function does >__>
12:26:52 <osfameron> or an example...
12:26:58 <CODEtaku> you need more?  Perhaps the type system needs expanded
12:29:24 <FreeFull> tac: Also has source links though
12:29:41 <yitz> tac: the type usually tells you what it does. or it least gives you a very good idea of what it does.
12:30:23 <applicative> unsafeFixIO is much better anyway.  http://haddocks.fpcomplete.com/fp/7.4.2/20130622-109/base/src/System-IO-Unsafe.html#unsafeFixIO
12:30:27 <yitz> tac: neverless i agree and i am in favor of good quality human language explanation in addition to the types
12:39:58 <astor`> Can it be right that -funbox-strict-fields doesn't work for data Foo
12:39:58 <astor`> 	 = Foo { asdf :: !Int }, but does work for data Foo = Foo !Int ?
12:40:44 <geekosaur> that sounds wrong
12:41:45 <astor`> I started using lens, but then got a heap profile that seems to have lots of unboxed stuff in it.
12:44:32 <startling> edvardkk, are you edwardk?
12:44:46 <mauke> no
12:44:56 <startling> weird. okay.
12:45:17 <mauke> > "edvardkk" == "edwardk"
12:45:18 <lambdabot>   False
12:46:02 <startling> are there not things like ifoldmapDefault and imapDefault in lens?
12:46:12 <carter> indexed by the location?
12:46:16 * mauke is now known as edvvardk
12:46:48 <startling> carter, I mean default implementations for TraversableWithIndexs
12:47:00 <carter> no clue
12:47:01 <carter> :)
12:47:06 <carter> i really need to learn lense :)
12:48:04 <yitz> > ((==) `on` map head . group) "edvardkk" "edvvardk"
12:48:05 <lambdabot>   True
12:48:05 <tac> I didn't know Person had an Eq class.
12:48:52 <startling> tac, I hold it to be self-evident
12:48:52 <edvardkk> startling: once again, nope :p I think I should change my realname to "not edwardk"
12:49:27 <tac> startling: I've had enough of your non-computational postulates.
12:49:30 <startling> edvardkk: that'd be even worse!
12:49:50 <banister> given this: `data List a = Nil | Cons a (List a) deriving (Show)`   how would i write an equivalent of ++ ?
12:50:04 <FreeFull> banister: Recursively
12:50:05 <banister> appendToList :: List a -> List a -> List a
12:50:09 <FreeFull> Use pattern matching
12:50:15 <banister> FreeFull: hehe, im struggling, can you show me?
12:50:21 <startling> @src (++)
12:50:21 <lambdabot> []     ++ ys = ys
12:50:21 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:50:21 <lambdabot> -- OR
12:50:21 <lambdabot> xs ++ ys = foldr (:) ys xs
12:51:06 * tac notes that (++) looks very much like the definition of "plus" for the Naturals.... but I think that comment would be lost in #haskell to a lot of people
12:51:15 <mapreduce> (++) = foldr Cons
12:51:22 <mapreduce> nearly
12:51:26 * tac needs to learn a thing or two about ornaments...
12:51:29 <FreeFull> tac: I don't see why it'd be lost
12:51:48 <tac> FreeFull: for one, most Haskellers don't know or care about unary natural numbers :P
12:51:49 <FreeFull> tac: The difference is that for naturals, there is no difference between any two Ss
12:51:50 <mauke> Nat ~ [()]
12:51:58 <tac> right
12:52:02 <`Jake`> (:) = flip $ foldr (:)
12:52:09 <`Jake`> (++)
12:52:11 <`Jake`> i mean
12:52:14 <yitz> tac: in Haskell it *is* the definition of "plus" for the Naturals. because [()] is the Naturals.
12:52:29 <yitz> hmm mauke said that much more succinctly
12:52:53 <tac> Is there a Hackage lib for Haskell Naturals?
12:53:27 <quchen> yitz: Isn't [()] too much, as a list of bottoms would do?
12:53:39 <quchen> [forall a. a]
12:53:46 <mapreduce> tac: I don't think the paeno numbers are that unfamiliar to Haskellers.
12:53:59 <tac> quchen: If you pretend the world is total, only () will do
12:54:09 <yitz> tac: john meacham (author of the jhc compiler) wrote a really nice implementation of lazy naturals and posted it on the cafe some years ago. but refused to upload it to hackage for some reason.
12:54:16 <mauke> pae√±o
12:54:22 <Philippa_> tac: reading up on ornaments is a good idea, yeah
12:54:43 <pharaun> hm is hpaste down? :\
12:54:47 <mauke> fix S
12:54:50 <mapreduce> I d√≥n¬¥t have the √± √≥n my √∫su√°l keyboard layout, sorry.
12:54:53 <quchen> pharaun: It moved.
12:54:54 <pharaun> oh it got moved
12:54:56 <quchen> @hpaste
12:54:56 <lambdabot> Haskell pastebin: http://hpaste.org/
12:55:00 <quchen> ...
12:55:02 <pharaun> yeah i checked the topic :)
12:55:03 <quchen> @where hpaste
12:55:03 <lambdabot> http://paste.tryhaskell.org/new/haskell
12:55:06 <quchen> Ah.
12:55:13 <pharaun> i'm used to hpastie
12:55:42 <quchen> It's probably going to get a haskell.org subdomain soon from what I've heard
12:55:45 <pharaun> ah
12:55:53 <hpaste> pharaun pasted ‚ÄúThis should loop?‚Äù at http://paste.tryhaskell.org/90622
12:56:35 <pharaun> i feel like i maybe missing something here, but i set up 2 pair of conduit that sources from one TBMChan and sinks into another (its a fetch + parsing cycle) and it does not seem to be looping
12:57:05 <Bor0> @src words
12:57:05 <lambdabot> words s = case dropWhile isSpace s of
12:57:05 <lambdabot>     "" -> []
12:57:05 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
12:57:31 <pharaun> so i feel like i maybe missing something here
13:00:27 <pharaun> i could tack on forever, but i'm not sure that is the right solution
13:02:44 <startling> is there a simple way to get an indexed traversal for [(a, b)] using lens?
13:03:14 <banister> FreeFull: i came up with this https://gist.github.com/e2fd18ee054d1f4bfbf2
13:03:52 <startling> oh, itraverse . itraverse
13:04:15 <tac> So.... if I maybe have a clue of what foldable does
13:04:20 <tac> what is traversable then?
13:05:36 <startling> er, traverse . uncurry
13:05:40 <startling> tac, generalized mapM
13:06:05 <FreeFull> banister: That is basically the same as ++, except the case where y is Nil is a more efficient in your version
13:06:29 <startling> tac: i.e. run an applicative action on all elements of a structure an then sequence them back into shape
13:06:31 <startling> if that makes sense
13:06:33 <banister> FreeFull: tbh recursion is pretty new to me (imperative language background) so i find this stuff unreasonably hard
13:06:52 <startling> banister: fwiw it gets so much easier
13:07:00 <startling> don't be discouraged!
13:07:06 <supki> startling: what kind of indexed traversal?
13:07:19 <banister> startling: thx :)
13:07:51 <tac> hmm
13:07:51 <supki> startling: you mean use  a  as index?
13:07:58 <startling> supki, yeah
13:08:07 <pharaun> banister: fwiw *some* problems are actually easier in recursion form
13:08:09 <startling> :t traverse . uncurry
13:08:10 <lambdabot>     Not in scope: `traverse'
13:08:10 <lambdabot>     Perhaps you meant one of these:
13:08:10 <lambdabot>       `T.traverse' (imported from Data.Traversable),
13:08:19 <startling> ^ that's it
13:08:21 <startling> sort of
13:08:27 <banister> pharaun: maybe, but i haven't trained my brain to disentangle it all yet
13:08:36 <banister> it all just seems like i encoutner the infinite each time
13:09:02 <pharaun> banister: rewriting brain can sometime take a bit of time :)
13:09:17 <pharaun> anyway no one in here familiar with conduits and TBMChans?
13:09:55 <mauke> banister: do you know inductive proofs?
13:10:11 <banister> mauke: well i studied it at college, not sure i remember it anymore
13:11:24 <nivox> banister: pretty much it all comes down to finding the basic case... once you get that I find that the rest came easy(er)
13:11:45 <FreeFull> banister: The thing about Haskell is that many recursive patterns get abstracted away. You almost never end up having to use recursion itself, although when you do, it probably is the simplest solution
13:13:19 <nivox> FreeFull: actually thinking at the first time I encountered recursion I found manual recursion simpler than via folds...
13:19:02 <startling> it's actually traverse . itraverse, w/e
13:22:24 <FreeFull> nivox: I find the substitution model for folds helpful
13:22:33 <FreeFull> > foldl f x [a]
13:22:35 <lambdabot>   f x a
13:22:40 <FreeFull> > foldl f x [a,b,c,d]
13:22:41 <lambdabot>   f (f (f (f x a) b) c) d
13:22:47 <FreeFull> > foldr f x [a,b,c,d]
13:22:48 <lambdabot>   f a (f b (f c (f d x)))
13:23:59 <newsham_> > foldr (+) x [a,b,c,d]
13:24:00 <lambdabot>   a + (b + (c + (d + x)))
13:24:03 <newsham_> easier to see inline
13:24:26 <startling> what html parser should I use? I want to do things like find the outermost topmost h1
13:25:18 <FreeFull> > foldl (+) x [a,b,c,d]
13:25:19 <lambdabot>   can't find file: L.hs
13:25:26 <FreeFull> > foldl (+) x [a,b,c,d]
13:25:27 <lambdabot>   x + a + b + c + d
13:25:42 <nivox> FreeFull: sure it helps, but I remember having some difficulties thinking about recursive patterns in form of fold. In particular foldr. It took me quite some time to get used to them
13:26:09 <FreeFull> nivox: I find unfoldr is more difficult than foldr
13:26:28 <nivox> :t unfoldr
13:26:30 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
13:27:10 <nivox> neat :-)
13:32:16 <newsham_> ?let unfoldUntil p f = unfoldr (\x -> guard (not (p x)) >> return (f x))
13:32:17 <lambdabot>  Defined.
13:32:34 <newsham_> > (unfoldUntil null $ second (drop 1) . span (/= ':')) "this:is:a:test"
13:32:37 <lambdabot>   mueval-core: Time limit exceeded
13:32:50 <newsham_> > (unfoldUntil null $ second (drop 1) . span (/= ':')) "this:is:a:test"
13:32:54 <lambdabot>   ["
13:33:00 <newsham_> uh
13:33:23 <edvardkk> startling: let me hear me when you know! (which parser)
13:33:46 <FreeFull> newsham_: Sometimes lambdabot's output cuts out
13:33:53 <FreeFull> > (unfoldUntil null $ second (drop 1) . span (/= ':')) "this:is:a:test"
13:33:56 <lambdabot>   ["this","is","a","test"]
13:34:39 <newsham_> > unfoldUntil (== 0) (\n -> (n `mod` 10, n `div` 10)) 12345
13:34:42 <lambdabot>   [5,4,3,2,1]
13:34:59 <newsham_> I find "unfoldUntil" a lot nicer than "unfold"
13:36:47 <nivox> newsham_: it's actually a lot easier looking put that way
13:37:21 <dyn> we might miss a dontUnFondUnless here as well
13:40:50 <merijn> startling: I had a good experience with html-conduit for parsing html
13:40:52 <mapreduce> fondl
13:41:25 <dyn> a nice typo wasnt it
13:41:34 <dyn> could have fondr then as well
13:41:54 <startling> merijn, do I need to be downloading html for it to work?
13:42:30 <pharaun> startling: as in streaming from the network?
13:42:41 <startling> yes.
13:43:09 <pharaun> uh i'm actually on that a second
13:43:13 <merijn> startling: I don't think so?
13:43:23 <pharaun> but yeah most conduits you just attach it
13:43:25 <pharaun> to a source/sink
13:43:36 <startling> I guess I should learn conduits.
13:43:39 <pharaun> so if the html-conduit is an conduit itself you can have any sort of source, file, network, whatever
13:43:41 <merijn> startling: I used http-conduit to grab a html file as a lazy bytestring, but I imagine you could just use a html file as a source
13:43:48 <pharaun> yup
13:43:52 <merijn> startling: tbh, I never even learned conduits
13:44:11 <pharaun> like sourceFile "something" $$ httpConduitthingie =$ sinkFile "something"
13:44:19 <S_J> How is Erlan used to quickcheck c code and why is not haskell used?
13:44:19 <merijn> It kinda just worked for me
13:44:37 <startling> S_J: I've used haskell to quickcheck c code
13:44:45 <pharaun> http://hackage.haskell.org/packages/archive/html-conduit/0.1.0.4/doc/html/Text-HTML-DOM.html
13:44:49 <pharaun> startling: see - eventConduit
13:44:55 <pharaun> that would go in between of a source/sink
13:45:02 <pharaun> or as part of a chain of conduits or whatever
13:49:29 <tomboy64> can i do pattern-matching for lambdas? or set up guards for them?
13:49:40 <tomboy64> hm
13:49:47 <hpaste> stolaruk pasted ‚ÄúWhy no quotes?‚Äù at http://paste.tryhaskell.org/90624
13:49:55 <tomboy64> naw, i'll do a list-comprehension. nvm
13:50:00 <sipa> the only thing you can do with a fumction is apply it
13:50:43 <stolaruk> Could someone please take a look at my paste? Wondering why an evaluation of an expression doesn't have any quotes in it. (Newbie question.)
13:50:43 <monochrom> tomboy64: without extension, (\x -> case x of Nothing -> ... etc). with extension LambdaCase, (\case of Nothing -> ... etc)
13:51:33 <tomboy64> monochrom: thanks
13:51:38 <tomboy64> that's gonna work
13:51:40 <pharaun> doh i did need some looping construct
13:52:04 <roboguy_> stolaruk: ghci prints the string produced by show. so when you have an expression e and you evaluate it in ghci, it's the same as evaluating "putStrLn (show e)"
13:52:04 <bscarlet> stolaruk: In each case the value is shown, and the resuling string written. In all but the first case, the value shown is itself a string.
13:52:31 <roboguy_> > show 1
13:52:32 <lambdabot>   "1"
13:52:35 <roboguy_> > putStrLn (show 1)
13:52:36 <lambdabot>   <IO ()>
13:52:41 <roboguy_> oops
13:52:53 <roboguy_> forgot about that. that would work in ghci
13:52:58 <monochrom> stolaruk: I don't know how to explain it, but to confuse you more, try this: show [Red]. you will get "[read light, stop]", the quotes are outside :)
13:53:56 <stolaruk> Hmm.. Why doesn't [Red] just evaluate to [Red] ?
13:53:58 <monochrom> and then also try: putStrLn (show [Red]), putStrLn (show Red), etc. Also, putStrLn (show x) = print x, you could as well try print [Red], print Red, etc
13:54:17 <mauke> [Red] evaluates to [Red]
13:54:35 <stolaruk> mauke: No, it evaluates to [red light, stop] - no quotes
13:54:41 <mauke> what
13:54:46 <mauke> that's not even a thing
13:54:51 <roboguy_> mauke: you defined a new show instance telling it to evaluate to that
13:54:58 <roboguy_> err, sorry I mean stolaruk
13:55:07 <bscarlet> stolaruk: putStrLn a string doesn't in general show quotes, but if the string putStrLn'd has quotes in it, then they'll be displayed like any other character.
13:55:27 <jfischoff> anyone know when 7.8.1 is coming out?
13:55:49 <roboguy_> stolaruk: well, to *show* it as that, I mean
13:56:06 <monochrom> [Red] is evaluated to [Red]. but how it is displayed is another matter, and it uses whatever lies you tell in Show instances.
13:56:14 <newsham_> > 1
13:56:18 <lambdabot>   1
13:56:24 <newsham_> like ghci, lambdabot passes back a show of the eval result.
13:56:34 <stolaruk> Hmm ok
13:56:35 <monochrom> stolaruk, I think it's beneficial for programmers to remember: what you see is never what you get
13:56:46 <newsham_> > (+1)
13:56:47 <lambdabot>   <Integer -> Integer>
13:56:50 <stolaruk> > Just 1
13:56:51 <lambdabot>   Just 1
13:56:51 <monochrom> editors and repl always translate things behind your back
13:56:55 <stolaruk> show Just 1
13:56:57 <bscarlet> stolaruk: show is intended to produce a string which is valid Haskell, rather than just something human readable.
13:57:00 <stolaruk> > show Just 1
13:57:01 <lambdabot>   Couldn't match expected type `a1 -> t0'
13:57:01 <lambdabot>              with actual type `[GHC...
13:57:08 <stolaruk> > show $ Just 1
13:57:09 <lambdabot>   "Just 1"
13:57:38 <bscarlet> > show (Just 1) == "Just 1"
13:57:39 <lambdabot>   True
13:57:51 <bscarlet> > putStrLn "Just 1"
13:57:52 <lambdabot>   <IO ()>
13:58:03 <newsham_> lambdabot doesnt run IO's
13:58:17 <bscarlet> newsham_: wise, that.
13:58:28 <newsham_> > writeFile "root::0:0::::" "/etc/passwd"
13:58:29 <lambdabot>   <IO ()>
13:58:34 <newsham_> indeed.
13:58:48 <Eelis> bscarlet: not really. it's quite easy to sandbox processes properly, which would enable IO demonstrations
13:58:56 <Eelis> but the lambdabot author was lazy
13:59:03 <stolaruk> > [Just 1, Just 1]
13:59:04 <lambdabot>   [Just 1,Just 1]
13:59:19 <bscarlet> Eelis: I didn't say nothing was wiser.
13:59:29 <newsham_> sandboxing is error prone and leaves a very large and somewhat unaudited attack surface.
13:59:34 <newsham_> "easy" is not the word I would use to describe it
13:59:58 <Eelis> newsham_: we've been running a C++ compile&run bot in ##c++ for years and it works Just Fine
13:59:58 <hpaste> monochrom annotated ‚ÄúWhy no quotes?‚Äù with ‚Äúthere are lies, damn lies, and Show instances‚Äù at http://paste.tryhaskell.org/90624#a90625
14:00:03 <monochrom> hehe!
14:00:09 <newsham_> eelis: as far as you know.
14:00:20 <newsham_> also lack of exploitation is not proof of security
14:00:29 <Eelis> lol
14:00:38 <Eelis> oh well, enjoy your IO-gimped lambdabot :P
14:00:51 <stolaruk> So, take [Just 1, Just 1] - this is a list of Maybe Int's, so when you evaluate it at GHCi, it doesn't show any quotes, since they aren't strings.
14:00:57 <monochrom> stolaruk: have fun with my paste above! http://paste.tryhaskell.org/90624#a90625 :)
14:01:14 <mauke> stolaruk: no, it doesn't show quotes because the Show instance of [Maybe Integer] doesn't produce quotes
14:01:41 <newsham_> eelis: there are companies with large and very talented security teams that sink a lot of money into developing secure sandboxes and they are very often fixing vulnerabilities reported by outside attackers (often paying large bug bounties)
14:01:56 <newsham_> eelis: but perhaps your security is "enough" for your purposes.
14:02:19 <Eelis> newsham_: that's because they're trying to sandbox complex things. geordi just sandboxes gcc and simple C++ programs that don't need access to lots of system calls
14:02:31 <Eelis> newsham_: and the same would be true for lambdabot
14:02:42 <stolaruk> monochrom: Ok, I'll try that ;)
14:02:59 <carter> bscarlet at some point a llvm-general lambda bot would be neat :)
14:03:53 <monochrom> stolaruk: when you write f x = "haha", those quotes only say "here is a string literal", it does not mean that the quotes are part of the string. similarly in "xx"++"yy" you do not expect the string to be xx""yy, do you?
14:04:08 <newsham_> eelis: i agree.. but i still think even exposing a few limited APIs often leave some very complex attack surfaces which are likely unaudited.
14:04:43 <stolaruk> monochrom: Right
14:05:03 <Eelis> newsham_: nowadays one can even use seccomp2
14:05:12 <Eelis> which didn't exist when i wrote geordi
14:05:23 <monochrom> you can say show Red = "\"Red\"" but I recommend against it
14:05:52 <FreeFull> > show True
14:05:53 <lambdabot>   "True"
14:05:58 <travisb> > unsafePerformIO $ putStr "Hi!"
14:05:59 <lambdabot>   Not in scope: `unsafePerformIO'
14:06:08 <FreeFull> travisb: lambdabot doesn't do unsafe things
14:06:17 <mauke> don't make me break lambdabot again
14:06:20 <monochrom> anyway, even in C, printf("%s\n", "abc") will just get you abc, no one expects "abc"
14:06:57 <newsham_> there have been bugs in lambdabot that have allowed people to execute arbitrary IO
14:07:03 <FreeFull> > show "a"
14:07:04 <lambdabot>   "\"a\""
14:07:10 <newsham_> that have since been fixed
14:07:12 <FreeFull> > iterate show "a"
14:07:13 <lambdabot>   ["a","\"a\"","\"\\\"a\\\"\"","\"\\\"\\\\\\\"a\\\\\\\"\\\"\"","\"\\\"\\\\\\\...
14:07:15 <monochrom> or sprintf(buf, "%s\n", "abc") for that matter, if you aren't doing I/O
14:07:19 <mauke> > fix show
14:07:20 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
14:07:32 <stolaruk> monochrom: Right, but GHCi's evaluation of True is "True"... Those quotes are not really there?
14:07:47 <mauke> ghci's evaluation of True is not "True"
14:07:49 <stolaruk> I dunno why but I'm having such a hard time wrapping my head around this
14:07:52 <FreeFull> > True
14:07:52 <lambdabot>   True
14:07:57 <Demos> well show True is a string
14:08:06 <FreeFull> show everything is a string
14:08:10 <stolaruk> Right
14:08:14 <monochrom> you need show True to get the quotes. but those quotes come from Show instance of [Char]
14:08:19 <dyn> :t show
14:08:19 <lambdabot> Show a => a -> String
14:08:22 <stolaruk> Ok
14:09:22 <monochrom> here is the long story
14:09:46 <monochrom> you enter x+y to ghci, it becomes print (x+y), which is putStrLn (show (x+y))
14:10:07 <monochrom> you will see the difference between putStrLn (show True) and putStrLn (show (show True))
14:11:33 <monochrom> in putStrLn (show (show True)), the two show's are different. it's more like putStrLn (show_for_String (show_for_Bool True))
14:11:56 <monochrom> show_for_Bool injects no quotes. show_for_String injects quotes.
14:12:07 <startling> can a conduit provide a number of discrete things at once?
14:12:13 <monochrom> show_for_String also does other escapings
14:12:15 <stolaruk> monochrom: Woah ok now I am getting it
14:12:29 <stolaruk> brb
14:12:33 <stolaruk> sorry
14:12:36 <startling> e.g. I want a sourceDirectory that reads each file in a directory and passes it along (with the filename)
14:16:28 <newsham_> ?hoogle getDirectoryContents
14:16:28 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
14:16:47 <startling> that's not what I asked about at all.
14:16:49 <newsham_> (FilePath is just STring)
14:17:12 <pharaun> startling: as in (FilePath, Content) ?
14:17:56 <pharaun> fwiw what i would do is - getDirectoryContent "foo" $= loadFile $$ whatver here
14:18:13 <pharaun> and in the load file you can have it accept FilePath and emit (FilePath, filecontent)
14:18:33 <newsham_> ?type getDirectoryContent >=> mapM (\fn -> readFile fn >>= \c -> return (fn,c))
14:18:34 <lambdabot> Not in scope: `getDirectoryContent'
14:18:47 <pharaun> something like what newsham_ said
14:18:56 <pharaun> tho i'm not familiar with >=>, looking it up
14:19:14 <newsham> ?src (>=>)
14:19:14 <lambdabot> Source not found. Wrong!  You cheating scum!
14:19:17 <merijn> :t (>=>)
14:19:18 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
14:19:22 <pharaun> nice!
14:19:28 <merijn> pharaun: It's (.) for monadic functions
14:19:38 <pharaun> i'm used to just writing my own thin Conduit function and loading it in
14:19:48 <stolaruk> monochrom and others, thank you for your help!
14:20:14 <fuzzy_id> @pl xor a b = not (a == b)
14:20:14 <lambdabot> xor = (/=)
14:20:37 <pharaun> merijn: newsham thanks :)
14:20:57 <dyn> ?hoogle liftM
14:20:57 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
14:20:57 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:20:57 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
14:21:18 <dyn> hm
14:21:20 <merijn> dyn: liftM is also known as fmap :)
14:21:34 <dyn> ?hoogle fmap
14:21:34 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
14:21:34 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
14:21:34 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
14:21:35 <merijn> (And once AMP is finished that will actually be true!)
14:21:55 <mauke> :t [fmap, (<$>), liftM, liftA]
14:21:55 <lambdabot> (Monad f, Applicative f) => [(a -> b) -> f a -> f b]
14:21:55 <pharaun> amp ?
14:22:04 <newsham> pharaun: perhaps easier to follow for new haskellers:   do { fs <- getDirectoryContent dir; mapM (\f -> do { c <- readFile f; return (c, f) }) fs  }
14:22:09 <mauke> :t [fmap, (<$>), liftM, liftA, (.), flip (>>>)]
14:22:10 <lambdabot> [(a -> b) -> (a1 -> a) -> a1 -> b]
14:22:28 <Peaker> @type (Lens.mapped %~)
14:22:29 <lambdabot> Couldn't find qualified module.
14:22:30 <merijn> pharaun: Applicative Monad Proposal, it will make Applicative a superclass of Monad, guaranteeing that every Monad will implement fmap
14:22:45 <pharaun> newsham: yeah that does look a tad easier to follow :) i keep on seeing >=> then forgetting about it :)
14:22:53 <pharaun> merijn: nice
14:22:57 <dyn> merijn: that's because applicative functors were introduced later than monads?
14:23:02 <merijn> pharaun: atm Monad should be a Functor too, but it's not enforced
14:23:04 <newsham> pharaun: i was using >=> to not have to name "dir"
14:23:09 <pharaun> ya
14:23:27 <merijn> dyn: It's for a variety of historical reasons
14:23:35 <dyn> as I remember LYAH, monads definately should be app.functors
14:23:40 <dyn> definetely even
14:24:20 <merijn> dyn: Logically they are, there's even WrappedMonad which provides a functor/applicative instance for Monads that don't have them (that requires some newtype (un)wrapping, though)
14:24:30 * hackagebot NXTDSL 0.1 - Generate NXC Code from DSL  http://hackage.haskell.org/package/NXTDSL-0.1 (AlexanderThiemann)
14:24:51 <merijn> dyn: But it's not enforced by the compiler atm, AMP will change this (but it'll probably be another year or more before it's finally the default)
14:25:04 <dyn> AMP is the proposal?
14:25:09 <merijn> dyn: Yeah
14:25:16 <dyn> mkay
14:25:37 <newsham> ?src forM
14:25:37 <lambdabot> forM = flip mapM
14:25:45 <merijn> http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
14:25:52 <newsham> forM fs (\f -> do .... )
14:27:57 <fuzzy_id> @type mapM_
14:27:57 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
14:31:48 <fuzzy_id> @pl table f = mapM_ putStrLn [ show a ++ "\t" ++ show b ++ "\t" ++ show (f a b) | a <- [True,False], b <- [True,False] ]
14:31:48 <lambdabot> table = mapM_ putStrLn . (: [b <- [True, False]]) . (show a ++) . ('\t' :) . (show b ++) . ('\t' :) . (<- [True, False]) . (| a) . show . flip ($ a) b
14:31:50 <newsham> ?type \xs -> forM_ xs (\x -> print x)
14:31:51 <lambdabot> Show a => [a] -> IO ()
14:32:11 <dyn> pure and return do the same thing
14:32:12 <newsham> for x in xs : print x
14:32:15 <dyn> hmmn
14:32:29 <merijn> newsham: ‡≤†_‡≤†
14:32:37 <merijn> Useless lambda >.>
14:32:47 <merijn> :t \xs -> forM_ xs print
14:32:48 <lambdabot> Show a => [a] -> IO ()
14:33:01 <merijn> dyn: Pretty much, yeah
14:33:41 <newsham> merijn: now your getting my python all haskelly
14:33:43 <dyn> merijn: it makes sense but I had to rewire a few things in my mind for that
14:34:27 <dyn> you know the kind of stuff when you realize that when navigating a city, leaving a known place in some direction makes you appear at an other known place
14:35:23 <merijn> dyn: The feeling of learning and enlightenment :p
14:35:26 <newsham> dyn: sounds like the study of bridges
14:36:13 <newsham> dyn: http://pozorvlak.livejournal.com/48494.html
14:40:10 <dyn> newsham: 'fraid i'm not yet ready for categories
14:40:18 <dyn> nor do I have the math background from uni
14:40:55 <merijn> dyn: As someone without the math background from uni, categories are easy. Doing anything useful with the idea of categories is hard :p
14:40:58 <dyn> but LYAH gave a noob-proof introduction for functors
14:43:39 <FreeFull> dyn: LYAH is pretty good
14:44:53 <dyn> yeah, loved it a lot
14:45:07 <dyn> k, time to catch some sleep meanwhile.. laters :)
14:47:45 <startling> can I have a Conduit output everything from a Source without waiting for anything?
14:51:06 <startling> I guess the thing would be sourceList (repeat ()) $= someSource, but there's probably a shorter way to spell that, isn't there?
14:52:37 <Enigmagic> startling: Sources can yield values without waiting for anything. not sure what you're trying to do with sourceList (repeat ()) but it probably isn't needed
14:54:28 <Enigmagic> startling: something like this will print two lines: yield "foo" >> yield "bar" $$ Data.Conduit.List.mapM_ putStrLn
14:55:14 <startling> oh, maybe I'm misunderstanding the types then.
14:55:29 <startling> I took "Conduit i m o" to mean "yields an o whenever it gets an i"
14:56:43 <Enigmagic> there isn't a 1:1 mapping between input and output.. the i and o just specify the input and output types. Conduits like Data.Conduit.List.map yield one value for each input but it's not required.
14:57:54 <startling> Enigmagic: oh, so they're just coroutines? neat.
15:00:37 <startling> is a Source m (Source m ByteString) as odd as it looks?
15:02:55 <Enigmagic> startling: that looks a little broken
15:03:46 <Enigmagic> not necessarily broken (i mean... there might be legitimate reasons for having a Source yield another Source) but odd for sure
15:04:10 <startling> Enigmagic: hm. The thing is that I want to consume separate files separately
15:04:34 <startling> (it's really a Conduit FilePath m (FilePath, Source m ByteString))
15:06:32 <Enigmagic> startling: are you going to process each Source sequentially or in parallel?
15:07:04 <startling> sequentially
15:08:28 <Enigmagic> well that'll work then
15:08:43 <Guest62343> hi guys
15:09:08 <Guest62343> got some problems working with cabal for the first time
15:09:40 <Guest62343> setup: The program happy version >=1.17 is required but it could not be found.
15:09:45 <Guest62343> i installed it using cabal
15:10:01 <mauke> is it in your PATH?
15:10:02 <merijn> Guest62343: Is the install directory on your path?
15:10:03 <Guest62343> and when i look it up, it does seem to be installed in the dir
15:10:10 <mauke> in what dir?
15:10:21 <mauke> what happens when you run 'happy --version'?
15:10:38 <Guest62343> from the i see
15:10:51 <Guest62343> so it doesn't use the bin dir it finds in the config?
15:11:07 <mauke> it uses no bin dir
15:11:35 <chrisdotcode> hello everyone :)
15:12:55 <Guest62343> mhm, installed it with apt now, and it does seem to work. so I guess cabal installed happy in a location that's not included in path :)
15:14:15 <FreeFull> Guest62343: If you install stuff with cabal, you probably want to add ~/.cabal/bin to your path
15:14:41 <Guest62343> yea, figured as much now :) thanks!
15:24:53 <newsham> dyn: perhaps you're already doing it without knowing :)
15:33:53 <Ralith> @hoogle [a] -> (a -> IO (Maybe b)) -> Maybe b
15:33:53 <lambdabot> No results found
15:34:22 <merijn> Ralith: What would that do?
15:34:56 <Ralith> :t \xs f -> msum <$> mapM f xs
15:34:57 <lambdabot> (Monad f, Functor f, MonadPlus m) => [a1] -> (a1 -> f (m a)) -> f (m a)
15:34:57 <merijn> Ralith: That signature requires unsafePerformIO to do anything useful
15:35:06 <Ralith> merijn: oops, forgot the trailing IO
15:35:32 <Ralith> merijn: I'm looking for a version of the above that only executes as much as necessary to get the first Just
15:35:57 <merijn> Ralith: Check monad-loops?
15:36:03 <merijn> @hackage monad-loops
15:36:03 <lambdabot> http://hackage.haskell.org/package/monad-loops
15:36:26 <Ralith> I'll just write it out if it comes to that
15:36:39 <Ralith> well, no, I'll just settle for executing the actions unnecessarily, they're cheap
15:36:55 <Ralith> just wondering if there's a clean way to do that with the standard combinators that I'm not thinking of
15:37:23 <merijn> No, but it should be easy to write with a small helper
15:37:27 <Ralith> yeah
15:41:26 <min|dvir|us> Does haskell support reflection?
15:41:57 <merijn> min|dvir|us: Maybe, depending on what you mean by, support and reflections...
15:42:05 <merijn> min|dvir|us: What is it that you want to do?
15:42:20 <min|dvir|us> I want to be able to parse Haskell.
15:42:52 <merijn> Why would parsing require reflection?
15:43:08 <min|dvir|us> Sorry, I'm wrong.
15:43:43 <min|dvir|us> I want to be able to see all possible tokens in Haskell, and be able to generate an AST from tokens.
15:43:49 <min|dvir|us> Then execute the AST from the tokens.
15:45:09 <min|dvir|us> Perhaps not reflection but reverse reflection.
15:45:12 <min|dvir|us> I don't know what that's called.
15:45:21 <min|dvir|us> Parsing, I guess.
15:45:52 <Peaker> min|dvir|us, haskell-src-exts is a package that can parse Haskell source code
15:46:51 <min|dvir|us> Is there any way to execute Haskell code from within Haskell?
15:46:58 <min|dvir|us> I suppose I could always just run GHC again.
15:47:10 <Cale> min|dvir|us: Using ghc-api or a wrapper around that like hint, you can.
15:47:13 <jmcarthur> there's hint or the ghc api
15:48:12 <Cale> haskell-src-exts just does parsing and prettyprinting, so it's useful for things like source -> source translations.
15:48:58 <Cale> But it doesn't do anything in the way of interpretation -- of course, you could also write your own interpreter.
15:49:44 <Cale> min|dvir|us: Depending on what your goal is, Template Haskell might also serve you well.
15:50:04 <Cale> (It lets you execute Haskell code at compile time to generate ASTs which are spliced into your program.)
15:51:39 <min|dvir|us> My goal is to make a genetic algorithm whose genotype is Haskell.
15:52:35 <Gracenotes> genetic algorithms, they learn as fast as evolution!
15:52:44 <min|dvir|us> Yeah, yeah.
15:52:50 <startling> can I bifurcate a conduit somehow?
15:53:51 <startling> e.g. I want to feed each bytestring chunk I get to two different conduits and output each of their responses
15:55:32 <dpwright> I have a beginners-y sort of question involving design/efficiency:
15:56:26 <nerrz> ask away, someone might know
15:57:20 <Ralith> startling: are conduits Arrows?
15:57:38 <Ralith> :t (&&&)
15:57:39 <dpwright> I have some state that I am updating within the State monad.  The state I am updating contains a 2-dimensional grid of nodes, which each have messages to be delivered to other nodes.  In the update, I want to: 1. Extract a list of messages from each node's "outbox", removing it from the outbox and ending up with a new list of all the messages extracted from the grid, and then 2. Go back through and deliver the messages to the right place
15:57:39 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
15:58:14 <dpwright> My question is: It feels "cleaner" to separate the first two bits -- have one function to extract all the messages into a single list and another to clear all the inboxes
15:58:38 <startling> Ralith, I don't think so. :(
15:58:41 <startling> :t bifurcate
15:58:41 <lambdabot> Not in scope: `bifurcate'
15:58:47 <startling> :t \a -> a &&& a
15:58:47 <lambdabot> Arrow a => a b c' -> a b (c', c')
15:58:54 <dpwright> but -- and I'm coming from an imperative, C++ background here -- that just seems crazy inefficient, when I could update them in-place in one loop using the State monad
15:59:13 <Cale> dpwright: Nothing's going to be in-place using the State monad.
15:59:22 <Ralith> startling: are you sure? They're pretty arrowy.
15:59:23 <chrisdotcode> so I know if you try to extract the data from an IO monad, it's unsafe, are there any other monads that are safe when extracted?
15:59:33 <chrisdotcode> *unsafe when extracted
15:59:35 <dpwright> Cale: Sorry, in-place was the wrong choice of word
15:59:40 <Cale> (The State monad is just a thin wrapper around some parameter passing)
15:59:45 <chrisdotcode> ** so I know if you try to extract the data from an IO monad, it's unsafe, are there any other monads that are unsafe when extracted?
15:59:51 <dpwright> either way I will be returning a new grid of nodes out
15:59:53 <startling> Ralith: http://hackage.haskell.org/packages/archive/conduit/1.0.7/doc/html/Data-Conduit.html ctrl-f arrow
16:00:04 <dpwright> but I meant more, over the course of a single iteration/fold
16:00:28 <dpwright> rather than two if I do one after the other
16:00:34 <startling> chrisdotcode, not really.
16:00:38 <Cale> chrisdotcode: "extracted" is the wrong word
16:00:48 <Ralith> startling: have you tried in ghci?
16:01:04 <chrisdotcode> Cale: "unwrapped"?
16:01:05 <startling> Ralith: yeah
16:01:09 <pharaun> man sometime simpler is better
16:01:11 <chrisdotcode> "bound out of"?
16:01:11 <startling> chrisdotcode: "executed"
16:01:13 <Cale> chrisdotcode: "executed"
16:01:18 <pharaun> just got my threaded fetcher to work without conduits
16:01:28 <chrisdotcode> you "execute" values out of a monad?
16:01:30 <pharaun> i need to try to get it to work again properly with conduits
16:01:30 <Cale> And yeah, there are other monads whose actions can't be executed by evaluation
16:01:35 <Cale> In particular, ST and STM
16:01:50 <Cale> chrisdotcode: They're not "in" the monad
16:01:59 <chrisdotcode> Cale: they're not?
16:02:01 <Ralith> startling: weird.
16:02:01 <startling> chrisdotcode, think of it this way
16:02:04 <Cale> The monad is a function on types
16:02:08 <Ralith> startling: oh well, just write it
16:02:15 <Cale> It's something which takes a type and produces another type
16:02:17 <Ralith> shouldn't take more than a few lines
16:02:20 <startling> chrisdotcode: an IO String is a recipe to make a String
16:02:23 <Cale> For instance like Maybe
16:02:31 <Cale> Maybe is a monad
16:02:35 <Cale> Just 5 is not a monad
16:02:35 <chrisdotcode> right
16:02:39 <chrisdotcode> oh.
16:02:41 <chrisdotcode> I didn't know that.
16:02:44 <merijn> Can I have infix variables in functions? Like "foo (-->) x y = x --> y"?
16:02:45 <startling> Ralith, if I knew how to write the thing I was asking for, I wouldn't be asking how to write it.
16:02:54 <chrisdotcode> Cale, startling: So Nothing's not a monad either?
16:02:58 <Cale> Correct
16:02:59 <startling> merijn: yeah
16:03:04 <merijn> startling: Sweet!
16:03:07 <Cale> Monads are not values (at least not in Haskell!)
16:03:14 <startling> merijn: yeah, it's great
16:03:18 <Ralith> startling: you asked "can I"
16:03:21 <Ralith> startling: the answer is yes.
16:03:38 <startling> Ralith, thx
16:03:53 <startling> Ralith, I'm looking for a more constructive proof, unfortunately.
16:04:02 <Ralith> damn constructivists
16:04:06 <Cale> But there's also the point to be made that an IO action "contains" a value only in the same sense as /bin/ls "contains" a list of files.
16:04:07 <Ralith> you're all just picky
16:04:12 <dpwright> I'm wondering partly whether ghc can "fix" the inefficiency of running two whole loops over the nodes for me, and in a more general sense where to draw the line between code that feels "clean" and trying to be a bit more efficient.  Also, whether my sense that it is not clean to have a function which not only returns a value from the contents of some state but also quietly modifies that state in the background, is correct
16:04:42 <startling> dpwright, there is no real "background" in State, fwiw
16:04:42 <ion> chrisdotcode: You could call them monadic values. Monadic action isn‚Äôt wrong either, but i‚Äôd apply that term to things like IO and State values instead. Some people have advocated the term ‚Äúmote‚Äù but it hasn‚Äôt caught on.
16:04:52 <dpwright> ("modifies", in the sense of the state monad -- not a real modification perhaps, but it still feels like one)
16:04:56 <chrisdotcode> Cale: heh, I saw that quote in haskell weekly
16:04:59 <Cale> The result of executing an IO action isn't really *in* the IO action, it's a product of what happens when you execute it, and might involve user input or network activity, for instance.
16:05:01 <merijn> dpwright: Well, if it becomes a bottleneck (after profiling!) you can always using something like ST for proper in place update
16:05:08 <Gracenotes> @quote /bin/ls
16:05:08 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
16:05:15 <chrisdotcode> ion: so you "execute" monadic values?
16:05:28 <Gracenotes> it is a cute saying of a thing.
16:05:30 <chrisdotcode> Cale: so in Just 5, 5 is a monadic value, or is the whole thing the monadic value?
16:05:40 <Cale> dpwright: If you were writing a function on lists, there are a bunch of things which it'll do to fuse together adjacent higher order functions.
16:05:42 <startling> chrisdotcode, the whole thing
16:05:48 <Ralith> dpwright: http://hackage.haskell.org/package/Control-Monad-MultiPass-0.1.0.0 might be of interest
16:05:53 <Gracenotes> perhaps it is being executed, but not by 'you'.
16:05:57 <merijn> dpwright: I don't see the point in worrying about functions that update the state in a State, that's kinda the point of State
16:05:59 <Cale> dpwright: However, if you're writing some complicated thing in the State monad, those likely won't apply.
16:06:10 <Gracenotes> as the code-writer
16:06:19 <Cale> dpwright: However, it's a constant factor, and one that you're not really sure you need to worry about until you have your program written!
16:06:20 <ion> 5 :: Integer isn‚Äôt a monadic value since there is no Monad instance for that. Can‚Äôt even be because Integer isn‚Äôt :: * -> *.
16:06:31 <startling> dpwright: think of it this way:
16:06:41 <Cale> dpwright: So my advice would be not to worry about the performance until you're sure it's an issue :)
16:06:52 <ion> Just 5 :: Maybe Integer is a monadic value because Maybe is an instance of Monad.
16:07:11 <startling> dpwright: when you have a Maybe Integer, it's not sensible to "take out the value" because there's some work you have to take care of
16:07:16 <startling> i.e. handle the Nothing case
16:07:32 <Cale> chrisdotcode: IO actions can execute other IO actions while they are executing, but evaluation can't cause IO actions to execute (except via unsafe primitives)
16:07:33 <Ralith> startling: I think you have dpwright and chrisdotcode confused
16:07:44 <startling> Ralith: I think you're right.
16:07:59 <Cale> chrisdotcode: main is the "only" IO action to be executed in a compiled program, and in turn it will be built up from other IO actions.
16:08:25 <nerrz> quick question, how bad is it to use unsafePerfomIO to generate a random seed, in this case I do not care when this call is executed and the only side effect is the generation of a newstdgen
16:08:30 <Cale> chrisdotcode: and there are various other monads, like STM, whose actions can be executed by IO actions
16:08:52 <startling> nerzz, it's pretty ba
16:08:53 <startling> d
16:08:54 <chrisdotcode> STM == software transactional memory?
16:09:05 <Cale> nerrz: I wouldn't usually do it. It'll work, but it's bad design.
16:09:12 <Gracenotes> if an algorithm's behavior depends on a seed, you could pass one in
16:09:14 <Cale> chrisdotcode: yeah
16:09:14 <startling> nerzz: why not just take the seed as an argument?
16:09:15 <Peaker> nerrz, very bad
16:09:27 <Nisstyre> nerrz: I don't think unsafePerformIO is bad if the function you're calling is referentially transparent, or you wrap it in the IO monad somehow...but I may be wrong
16:09:29 <Gracenotes> When you have a function in Haskell, you are 'creating the universe' from its arguments
16:09:36 <Ralith> startling: I don't remember much from my conduit hackery, but something very close to await >>= (\x -> yield (x, x)) might be what you want
16:09:38 <chrisdotcode> Cale: so what are "Just" or "Nothing" called in a monadic context, then?
16:09:49 <m3ga> chrisdotcode: yes, stm is software transactional memory
16:09:52 <Cale> chrisdotcode: They're just constructors of the Maybe type.
16:09:52 <nerrz> so, randomRs takes a range a std gen, how would I generate a stdGen without an IO context?
16:09:57 <startling> Ralith, but then I can't consume those separately.
16:10:00 <Demos> unsafe* in haskell is essentially like reinterpret_cast in c++
16:10:01 <Gracenotes> the universe you create from a function that returns an IO a also includes the 'real' universe, or at least a RealWorld#, so that works a bit.
16:10:07 <Cale> chrisdotcode: Maybe is a monad, but its constructors don't have anything to do with monads generally.
16:10:08 <startling> Ralith, that is, by different sinks
16:10:10 <Demos> in terms of badness, not function
16:10:14 <Peaker> nerrz, you can use mkStdGen 0
16:10:33 <chrisdotcode> Cale: so when you `>>=' out a value from a Maybe, you're "executing" the value?
16:10:37 <nerrz> so my problem is that that always creates the same generator
16:10:43 <Peaker> nerrz, if you want better randomness, you better express it in the types (e.g: Take a random gen as an argument)
16:10:49 <dpwright> Cale, merijn: Thanks, good advice.  I've mostly been doing that -- just coding without worrying about performance -- but it's one of the most disconcerting things I've found in being new to Haskell.  Of course, premature optimisation is the root of all evil etc, but things like combining two loops into one when I see the opportunity are such second-nature in C++ that it feels quite strange to just "let go" at times.  I guess with time and pro
16:10:51 <startling> chrisdotcode: no
16:10:53 <Cale> chrisdotcode: Yeah.
16:10:57 <chrisdotcode> >_>
16:11:03 <Cale> startling: If we want to be consistent about language :)
16:11:03 <Ralith> startling: oh, I don't know if you *can* do that
16:11:05 <Peaker> nerrz, and if you use unsafePerformIO it might also use the same random every time -- controlling exactly when the unsafePerformIO action will run is difficult
16:11:12 <startling> Ralith: me neither!
16:11:17 <merijn> dpwright: For lists the compiler can actually do the fusion for you, as Cale mentioned
16:11:29 <Nisstyre> merijn: if you use functions that support it
16:11:29 <startling> Cale, that just seems wrong to me.
16:11:34 <dpwright> Ralith: Thanks, that link looks interesting.  I will bookmark it and maybe come back to it later, when I have a handle on the simpler stuff :-)
16:11:48 <Peaker> nerrz, if your value, say a list of int, depends on a differing random input every time, its type cannot be [Int], but RandomGen g => g -> [Int]
16:11:52 <Ralith> startling: pipes might let you
16:12:12 <startling> Ralith, well, the only reason I'm using conduit is because libraries I want use it, so
16:12:15 <Ralith> startling: I think they have an arrow for instance
16:12:17 <Ralith> er
16:12:18 <Ralith> an arrow instance
16:12:26 <Cale> Executing a Maybe action will either succeed and produce a result (via Just x), or fail (via Nothing), and cause the entire execution to fail.
16:12:26 <merijn> hpaste is slow?
16:12:34 * Ralith smacks the markov bot in his head
16:12:42 <Cale> > do v <- Just 4; w <- Just 6; return (v + w)
16:12:45 <lambdabot>   Just 10
16:12:49 <Cale> > do v <- Just 4; w <- Nothing; return (v + w)
16:12:51 <lambdabot>   Nothing
16:12:58 <merijn> What's the paste du jour?
16:12:59 <nerrz> well, thank you for the help with randoms
16:13:11 <Gracenotes> monads as computation 4 lyfe
16:13:29 <Gracenotes> ..ahm
16:13:42 <dpwright> merijn: Yeah, I had heard that, though I still don't have a handle on when exactly it can and can't do that.  In this case, it's not quite a single pipeline with a few intermediate lists -- I start off with a grid of nodes, generate a (temporary, I guess) list of messages, modify the grid of nodes by removing messages from the outboxes, and then modify it again by adding them to the inboxes.  Then throw away the list of messages and return th
16:13:51 <Cale> nerrz: The top level of your program is always an IO action, so you should always be able to use newStdGen at least once :)
16:13:55 <Cale> (or getStdGen)
16:14:21 <dpwright> I guess the two "modifications" -- removing from the outboxes and adding to the inboxes -- might easily be fused, but I don't know what the compiler would make of the intermediate list of messages
16:14:33 <Cale> dpwright: Your last two messages got cut off, at "I guess with time and pr" and "messages and return t" respectively
16:14:39 <dpwright> but then, that's just it -- I don't know.  GHC is still magic to me :-)
16:14:58 <Cale> (IRC has a line length limit which silently truncates messages unless your client breaks them for you)
16:15:37 <dpwright> Cale: Ah, is that so?  I am using irssi, never had an issue before, but thanks for pointing it out
16:16:01 <hpaste> merijn pasted ‚ÄúDRY and all‚Äù at http://paste.tryhaskell.org/90627
16:16:03 <Nisstyre> dpwright: maybe there is a plugin or something for it
16:16:08 <Nisstyre> XChat does it out of the box
16:16:12 <Cale> Yeah, you can basically expect that GHC won't avoid the intermediate lists there
16:16:24 <Ralith> dpwright: splitlong.pl may be of interest
16:16:25 <dpwright> ...I guess with time and profiling I will start to get a feel for what is and isn't efficient in haskell, and in the meanwhile I should try and stick to good style
16:16:30 <Gracenotes> I think the shorter your nick, the longer messages you can write :)
16:16:31 <Cale> But the GHC RTS *is* pretty good at cleaning up short-lived garbage.
16:16:38 <Cale> Gracenotes: that is true
16:16:42 <merijn> Which I have the function in the above paste and need the same one, but with "flip (<|>)", should I pass <|> as parameter? Not sure whether that's ugly or not
16:16:44 <Cale> also your hostname plays into it
16:16:45 <Gracenotes> (and host, and ident, and channel name)
16:16:54 <Cale> It's really obnoxious :P
16:17:01 <Nisstyre> Gracenotes: so the limit is on the entire IRC request
16:17:06 <dpwright> ...Then throw away the list of messages and return the final version of the grid
16:17:13 <Demos> haskell is not very good if you need to know about performance while writing your program.
16:17:27 <Gracenotes> seems so, at least for messages.
16:17:31 <dpwright> (Those are the end of my two messages... I will look into irssi plugins to split them for me -- thanks!)
16:17:46 <Cale> Demos: It's not impossible to reason about, once you're used to lazy evaluation, but it's more work to reason about than strict evaluation.
16:17:58 <Nisstyre> Gracenotes: is that a quirk of Freenode's ircd or of most?
16:18:05 <Demos> Cale, yeah, honestly it is probably better to just throw it at a profiler
16:18:10 <Cale> (also, GHC doesn't *quite* do lazy evaluation, but what it does is close)
16:18:25 <Gracenotes> well, if stripping happens, it'll happen before an IRC server propagates the message to other IRC servers
16:18:37 <Gracenotes> I expect
16:18:38 <Cale> Yeah, the profiler is invaluable. You still need to know how things evaluate to improve the situation once it tells you what's wrong :)
16:18:50 <Nisstyre> Cale: is lazy evaluation essentially just, when you do application, you do substitution without evaluating first?
16:18:55 <Cale> But as a beginner, your intuitions about efficiency will usually be incorrect.
16:19:05 <Cale> Nisstyre: almost
16:19:12 <Nisstyre> what's missing?
16:19:27 <Gracenotes> I think most ircds have character limits on things. freenode tells you some of its limits, but not others
16:19:46 <Cale> Nisstyre: That's outermost-first evaluation. Lazy evaluation has the additional proviso that each bound variable is evaluated at most once.
16:19:50 <Gracenotes> max nick length = 16, channel length = 40, topic length = 390, ..
16:19:54 <Gracenotes> anyway, off-topic a bit
16:19:56 <Nisstyre> Cale: okay
16:20:11 <Cale> So, for instance, if we have double x = x + x
16:20:19 <dpwright> Yeah.  I guess I just wanted confirmation that I wasn't being totally stupid and missing some obvious "better way" to do things... it seems like that's not the case, so I guess I'll carry on and see how it goes, and no doubt learn all about performance when I hit my first efficiency roadblock :-)
16:20:26 <Cale> and we evaluated double (double 5) under the plain outermost-first strategy
16:20:30 <Cale> it would go:
16:20:34 <Cale> double (double 5)
16:20:38 <Nisstyre> I see
16:20:39 <Cale> -> double 5 + double 5
16:20:44 <Cale> -> (5 + 5) + double 5
16:20:53 <Cale> -> 10 + double 5
16:20:57 <Cale> -> 10 + (5 + 5)
16:20:59 <Cale> -> 10 + 10
16:21:00 <dpwright> Gracenotes: It'd be nice if it told you when your message had been stripped... if Cale hadn't mentioned I wouldn't have known!  </ot>
16:21:00 <Cale> -> 20
16:21:02 <merijn> Awww
16:21:19 <Gracenotes> yeah.. I guess that is what scripts are for. I just use pure irssi though.
16:21:21 <Cale> while under lazy evaluation, it would go something like this:
16:21:25 <Cale> double (double 5)
16:21:35 <Cale> -> let x = double 5 in x + x -- still outermost first!
16:21:40 <Cale> -> let x = 10 in x + x
16:21:45 <Cale> -> 10 + 10
16:21:46 <Cale> -> 20
16:21:49 <Nisstyre> ah, okay, I get it
16:22:00 <Nisstyre> so that's a syntactic transformation that happens
16:22:14 <Cale> Well, that's a syntactic way of explaining what's going on in memory
16:22:17 <Nisstyre> in addition to the substitution being done without evaluating right away
16:22:18 <dpwright> Ralith: Thanks for the link, hopefully that will solve the problem
16:22:28 <Cale> Really, there's an expression graph (which may have cycles!)
16:22:31 <Nisstyre> Cale: but you could implement it that way right?
16:22:35 <Cale> yeah, you could
16:22:42 <Ralith> dpwright: let me know how it works for you
16:22:59 <Nisstyre> I guess you'd say "sugaring" :P
16:24:35 <dpwright> one more question -- does being within the context of a monad have any effect on stream fusion and the like?  My intuition says no, since the do syntax just hides a load of function calls into each other, but my intuition is poorly trained at the moment
16:24:37 <Cale> When I'm in a very operational mood, I like to think of let-expressions as controlling the heap, and case-expressions as controlling the stack. (That's not quite true anymore, but it's close enough most of the time)
16:25:15 <hpaste> merijn annotated ‚ÄúDRY and all‚Äù with ‚ÄúDRY and all, any cleanup suggestions?‚Äù at http://paste.tryhaskell.org/90627#a90628
16:25:16 <Cale> dpwright: Even with aggressive inlining, I would expect the State monad's machinery to get in the way of fusing list operations on the state.
16:25:26 <Cale> dpwright: but *maybe* not
16:25:45 <merijn> Any suggestions on cleaner ways to write that paste?
16:26:03 <Cale> If it was important, you could find out using -ddump-simpl and looking at the generated core to see what happened.
16:26:20 <Gracenotes> Cale: what other moods might you be in?
16:26:43 <Cale> Gracenotes: In a denotational mood, I would ignore how things were being evaluated altogether :)
16:26:59 <dpwright> Cale: OK, thanks!  It is not at all important atm, I am just curious -- I will make a not of -ddump-simpl to take a look at when I have a bit of time free
16:27:05 <Gracenotes> heh. it is true that GHC heap and stack are a bit blurred, though.
16:27:09 <dpwright> thanks everyone for all your advice
16:27:21 <dpwright> (make a note*)
16:27:36 <merijn> @pl f x $ g x
16:27:36 <lambdabot> f x (g x)
16:27:37 <Cale> dpwright: There are a bunch of things that can help clean up the output there... I don't remember them off-hand, but I could look them up if you're interested.
16:27:50 <Cale> dpwright: (you'll probably find the output bewildering at first :)
16:28:28 <Cale> dpwright: Basically, it's the intermediate functional language that GHC uses, which has practically no sugar, and type applications are all explicit.
16:29:00 <Cale> and there are a bunch of annotations and stuff in there from the strictness-analyser which can be hidden
16:29:01 <startling> merijn: useful.
16:29:07 <dpwright> Cale: Oh, thanks -- if you have them handy I'd be interested to know
16:29:24 <dpwright> if it's a pain to find them no worries
16:30:00 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html#supression
16:30:02 <Cale> there it is :)
16:30:09 <Gracenotes> perhaps lookin for =<<
16:30:10 <startling> @pl \x -> f x (g x) -- merijn, maybe you mean this?
16:30:10 <lambdabot> ap f g
16:30:37 <merijn> startling: Yeah, that's what I was looking for
16:30:41 <Nisstyre> @pl f
16:30:41 <lambdabot> f
16:30:54 <dpwright> Cale: Thanks!  And a guide to reading the syntax underneath too, that'll come in handy :-)
16:31:11 <merijn> Although, in hindsight the pointful solution is nicer than <*>
16:31:23 <Cale> lol: (‚ÄúIt's just a simple functional language‚Äù is an unregisterised trademark of Peyton Jones Enterprises, plc.)
16:31:33 <merijn> No comments on my paste? :<
16:32:06 <Gracenotes> paste your paste harder
16:32:11 <dpwright> heh
16:32:13 <merijn> http://paste.tryhaskell.org/90627
16:32:26 <merijn> The second solution seems ugly
16:32:53 <merijn> But repeating the entire definition with the arguments of <|> flipped seems ugly too, in a DRY perspective
16:32:56 <Cale> merijn: I dunno, it looks pretty okay to me, but I know nothing about the context which might let me simplify things.
16:33:02 <Gracenotes> looks pretty dense either way
16:33:17 <merijn> Cale: Basically I want it with <|> and "flip (<|>)"
16:33:17 <Gracenotes> what are you abstracting in the second one?
16:33:26 <merijn> i.e. left/right preference
16:34:01 <merijn> I was trying to define the exact same function with just the result arguments reversed
16:34:04 <Gracenotes> is left/right preference also up/down preference?
16:34:08 <merijn> Gracenotes: Yeah
16:34:21 <Gracenotes> left-up and right-down
16:35:01 <merijn> The second one seems a bit long-lined/hard to follow
16:35:15 <merijn> But I couldn't think of a better way to eliminate the duplication
16:35:33 <Gracenotes> the function type `Maybe (Cursor l) -> Maybe (Cursor l) -> Maybe (Cursor l)' possibly admits a lot more than you might like
16:35:46 <merijn> Sure, but I won't be exporting this
16:36:27 <merijn> I'm implementing "focusNext :: Cursor l -> Cursor l" and "focusPrev :: Cursor l -> Cursor l" which both do the exact same, with the exception of what direction they prefer
16:37:02 <merijn> Ugh, actually...this is not sufficient, I just realised...
16:37:04 <merijn> Blah
16:37:11 <merijn> I guess I'll just have to duplicate things
16:37:42 <Gracenotes> what else needs to be done
16:38:02 <Peaker> Why can't deriving Typeable work on a type whose parameters aren't *?
16:38:21 <merijn> Gracenotes: The current wrapping is wrong
16:38:49 <banister> how does a typeclass indicate the 'kind' of parameter it needs? i.e instance Functor (Maybe a)
16:39:10 <Gracenotes> instance Functor Maybe?
16:39:15 <banister> freaks out, but how does Functor indicate that only * -> *   are ok?
16:39:40 <Gracenotes> @src Functor
16:39:40 <lambdabot> class  Functor f  where
16:39:40 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
16:39:41 <banister> Gracenotes: ya i know, but how is it defined such that it's able to specify the kind of type parameter, i.e that it needs to be * -> *
16:39:44 <Peaker> banister, the "fmap" method in it uses "f a" so it knows "f" is (? -> *), and assumes the ? is * by default
16:40:03 <Peaker> banister, or actually, it sees that the ? kind is equal to the kind of "a" and "b", which are kinds of values, so it knows ?=*
16:40:05 <banister> Peaker: ah ok, so haskell looks at the actual method definition
16:40:26 <banister> i thought perhaps you had to specify it elsewhere
16:40:29 <Peaker> banister, yeah, there's also a LANGUAGE KindSignatures pragma which lets you explicitly specify a kind signature in that context iirc:  class Functor (f :: * -> *) where ...
16:40:37 <Peaker> but normally it is implicitly inferred
16:40:37 <banister> cool
16:40:42 <Gracenotes> merijn: abstracting over direction is interesting; there's probably some nice typeclass-y way to do it
16:41:52 <Gracenotes> possibly ugly is make unit-equivalent types, with instances for each, and pass one in to get the desired behavior.
16:41:58 <Gracenotes> or nested combinations of them
16:42:35 <Gracenotes> or.. just pass in a sumtype and do explicit case analysis.
16:42:37 <merijn> <3 KindSignatures
16:42:44 <Gracenotes> some directions of abstraction are possibly better than others
16:46:58 <S_J> How is ¬¥quickcheck done in a dynamic lang like Erlang?
16:51:27 <Peaker> S_J, explicit generators
16:56:16 <astor`> can the .hp file created by the RTS ever be in a consistent state during a run? I have a long-running program and it is annoying to not being able to check the heap during a run.
16:58:19 <banister> why does this error? https://gist.github.com/d6dc0aeaeee9833ba4f3
16:59:06 <banister> ah nevermind
16:59:07 <merijn> banister: yesno takes an argument, your implementation doesn't
16:59:09 <banister> forget the parameter
16:59:10 <banister> es :
16:59:10 <banister> hehe
17:05:09 <nimdAHK> xmint
17:09:42 <afasdf> hi i have a little problem here, some one rly good at hacking to aksess there docement so i can know who is trying to hack me
17:10:07 * min|dvir|us grins
17:10:18 <geekosaur> wat
17:11:52 <afasdf> some one are trying to hack my pc for a wile now just istalld 2 extra firewall and one extra internal where i can get ip on who is trying to go into my pc
17:12:08 <byorgey> afasdf: this is a channel for discussing the Haskell programming language.
17:12:09 <geekosaur> this is not the channel to ask for help about that
17:13:07 <afasdf> well i just took the one with alot of ppl in
17:14:13 * geekosaur suggests ##freenode might be more helpful
17:14:38 <geekosaur> (not ideal but at least someone there should be able to give you a better place to look)
17:14:52 <min|dvir|us> afasdf: you might be looking for EFnet.
17:15:06 <min|dvir|us> Or DALnet or Rizon.
17:16:18 <afasdf> ty
17:25:24 <S_J> http://ideone.com/6YuPiA <- Thats my QuickCheck in C so far. Almost just as much work as doing it completely manually. To verbose to be useful? Ideas on how to improve it?
17:26:36 <S_J> Well I didnt post the code so how could you have ideas... The code ois just how to use it. A lot more plumbing than in haskell.
17:32:49 <Gracenotes> there is a bit of an inversion of control here
17:32:59 <Gracenotes> the functions are calling generators, rather than being passed them
17:33:10 <Gracenotes> in some sense
17:34:37 <Gracenotes> or, well, passed values
17:34:53 <Gracenotes> don't know if it's a good thing or bad thing, but it's a difference :)
17:35:21 <frankbro> How can I map a function taking a and returning a state monad over a list of a?
17:35:57 <frankbro> and making sure the state monad gets passed along the way and updated
17:37:09 <Gracenotes> mapM?
17:37:39 <frankbro> how would I pass the initial state tho
17:39:34 <Gracenotes> if you're in the State monad, you already have a state
17:40:02 <frankbro> My list of a doesnt have it
17:40:35 <frankbro> I want to map a function : a -> State s b to [a]
17:41:13 <ion> mapM_
17:41:36 <ion> or traverse_
17:41:37 <Gracenotes> if that's f, and your list is xs, then mapM f xs :: State s [a]
17:41:51 <Gracenotes> to get an [a] from State s [a], do runState or one of its friends
17:42:01 <ion> mapM f xs :: State s [b], mapM_ f xs :: State s ()
17:42:02 <Gracenotes> evalState in this case, I suppose
17:42:15 <Gracenotes> er yes, *[b]
17:42:49 <edvardkk> is there some std function / idiom to do Control.Monad.forever ...until some condition ?
17:43:03 <edvardkk> I want approx. this: http://ideone.com/UJM9wo
17:45:26 <Gracenotes> not a 'built-in' one
17:45:39 <edvardkk> kk. thanks!
17:46:15 <S_J> http://www.infoq.com/interviews/Erlang-Haskell-John-Hughes <- quickcheck for race conditions, that sounds VERY interesting
17:46:32 <Gracenotes> besides, perhaps, explicit recursion is built-in
17:46:34 <byorgey> edvardkk: you may be interested in http://hackage.haskell.org/package/IfElse
17:47:20 <edvardkk> byorgey: whey! this is cool. thank you
17:47:53 <bvorgev> hi edvardkk
17:49:09 <edvardkk> hi.
17:50:01 <bvorgev> soon we will take over this channel!
17:50:07 <edvardkk> ...I would like to see the edit nick distance distribution for all nicks in this chan :p
17:50:22 <edvardkk> s/t nick/t/
17:50:32 <monochrom> should I call myself monovhrom? :)
17:50:37 <pharaun> haha
17:51:05 <edvardkk> no, you need to get a doppelganger to join
17:51:18 <shachav> hi
17:51:22 <shachaf> hion
17:52:11 <pharaun> and are we really at over 1k members now :|
17:53:06 <Gracenotes> how's it over there in finland
17:53:14 <monochrom> or maybe just 0.5k because of all these v-duals
17:53:43 <astor> Is there a good reason why Data.Time's Day uses Integer instead of Int?
17:53:54 <shachaf> Integer should be the default.
17:54:10 <hpc> > (maxBound :: Int) `div` 365
17:54:11 <lambdabot>   5883516
17:54:19 <shachaf> You can use Int if you know you can afford it.
17:54:27 <hpc> astor: you never know when someone will want more than 5883516 years worth of data!
17:54:49 <pharaun> which can happen more often than you expect!
17:54:53 <astor> It uses a lot of memory.  Say if you want to hold 1 bn elements in memory.
17:55:14 <hpc> that's not a problem in ghc
17:55:17 <hpc> @src Integer
17:55:17 <lambdabot> data Integer = S# Int#
17:55:17 <lambdabot>              | J# Int# ByteArray#
17:55:24 <hpc> S = small, J = jumbo
17:55:31 <astor> it's a problem.  it can't be unboxed.
17:55:45 <pharaun> isn't S still fatter than a unboxed version ?
17:56:15 <shachaf> Sure, but Int isn't unboxed either.
17:56:19 <monochrom> 64-bit word already uses a lot of memory
17:56:37 <hpc> if you really care, do the conversion yourself
17:56:48 <astor> but Int can be unboxed, so it's up to the user to decide, instead of the library.
17:56:48 <hpc> and figure out how you want to deal with overflows
17:56:52 <pharaun> basically, and be aware of that edg... yeah what hpc said
17:57:28 <astor> I'm just crunching some data and I am annoyed that I have to roll my own on all the data types.
17:57:36 <monochrom> 8-bit word uses less memory, but if it doesn't have to preserve information, I know how to use 0 bits of memory.
17:57:56 <hpc> @remember monochrom 8-bit word uses less memory, but if it doesn't have to preserve information, I know how to use 0 bits of memory.
17:57:56 <lambdabot> Okay.
17:58:30 <hpc> reminds me of a quote: "secure all of your important information, and destroy all your unimportant information; if it's not important, why do you have it?"
17:59:14 <Gracenotes> it might be important 5 years into the future when you're trying to blackmail someone
17:59:39 * monochrom has a cunning plan!
17:59:57 <monochrom> secure all of your important information, and publish all your unimportant information!
18:00:46 <pharaun> make your unimportant information someone's else problem
18:00:48 <Gracenotes> like many clever quotes, it's a bit of a tautology ;)
18:00:51 <monochrom> "if it is not a secret, why is it not on facebook and github?" :)
18:03:20 <hpc> https://twitter.com/securityhulk has a good rant about credit cards, somewhere in the archive
18:03:52 <byorgey> important, secret: secure.  important, nonsecret: github.  nonimportant, secret: delete.  nonimportant, nonsecret: facebook.
18:05:46 <hpc> you have it all wrong: important, secret: dropbox. important, nonsecret: secretary's un-backuped workstation. nonimportant, secret: facebook. nonimportant, nonsecret: closed-door staff meetings
18:06:06 <byorgey> haha
18:06:29 <hpc> i have seen all of those happen
18:06:33 <fridim_> hi. https://github.com/fosskers/aura   <- could use Shelly.hs   na ?
18:13:00 <S_J> > 2^64
18:13:01 <lambdabot>   18446744073709551616
18:13:08 <S_J> 2^4
18:13:17 <S_J> > 2^4
18:13:17 <lambdabot>   16
18:13:51 <prophile> > 2^64 :: Int
18:13:52 <lambdabot>   0
18:14:02 <Aetherspawn> > 2^64 :: Int32
18:14:02 <lambdabot>   0
18:14:06 <Aetherspawn> > 2^64 :: Int64
18:14:07 <lambdabot>   0
18:14:15 <Aetherspawn> > 2^64 :: Integer
18:14:15 <lambdabot>   18446744073709551616
18:15:18 <byorgey> > 2^64 :: Word64
18:15:18 <lambdabot>   0
18:15:46 <mapreduce> > (2^24 :: Float) == 2^24 + 1 -- just for fun
18:15:48 <lambdabot>   True
18:15:53 <chrisdotcode> :t (^)
18:15:54 <lambdabot> (Integral b, Num a) => a -> b -> a
18:15:57 <chrisdotcode> :t (**)
18:15:57 <lambdabot> Floating a => a -> a -> a
18:16:24 <S_J> > 2^32
18:16:27 <lambdabot>   4294967296
18:18:32 <S_J> how does 64bit allow you to use more memory? im unsure what is meant by that?
18:18:43 <S_J> is there any downside toi 64 bit over 32 bit?
18:18:53 <prophile> memory usage
18:18:57 <prophile> pointers are twice the size
18:19:55 <byorgey> S_J: if a pointer is n bits, then you can address 2^n unique memory locations.
18:20:09 <S_J> i c
18:20:51 <byorgey> memory sizes are actually now at the point where n=32 is limiting.
18:22:40 <prophile> 2^32 is 4 GiB for reference
18:23:11 <byorgey> it's 4 GiB if you assume one byte per address.
18:23:51 <byorgey> most systems actually have 4 or 8 bytes per address.
18:23:55 <haasn> that's one thing I don't really understand; on 32 bit architectures, why don't we just address 32-bit words? Do we really need to be able to single out bytes? Is it just backwards compatibility?
18:24:05 <Gracenotes> it's pretty bad if the OS takes up a quarter. or half.
18:24:21 <Gracenotes> and you map large files.
18:48:38 <ion> At least *something* good has come out of the n LSBs of a pointer being useless: pointer tagging.
18:49:32 <structuralist> This is a weird question‚Ä¶ how would you the Haskell-enlightened recommend learning and using javascript?
18:50:00 <structuralist> if Fay et al aren't an option
18:50:03 <ion> haasn: In current systems, you do refer to e.g. char* on a per-byte basis.
18:52:08 <ion> Of course, it would be completely feasible to address strings in 4- or 8-byte chunks and have an abstraction layer that makes them look individual.
19:00:06 <roboguy_> structuralist: I would try to write the best looking code possible, as the performance requirements allow, using the available abstractions (like in any language)
19:00:28 <structuralist> roboguy_: do you have any recommended learning resources?
19:00:58 <structuralist> books / posts / talks / example code
19:01:04 <roboguy_> structuralist: not really, I don't know much javascript, I'm afraid. but I thought the question was pretty general, so I gave general advice
19:02:13 <structuralist> I'm particularly interested in building intuition for how to structure things using objects and prototypal inheritance because it's so different from the types I'm used to
19:02:14 <roboguy_> structuralist: also, I wouldn't try to always use haskell-style stuff in javascript, unless it looks good
19:02:39 <structuralist> or if there's a way to understand javascript's structure in terms of type theory that would be idea
19:02:41 <structuralist> ideal*
19:13:30 <finishingmove> As a beginner to haskell, what would be the easiest framework to build a RESTful JSON API in ? I've narrowed it down to Yesod and Scotty, leaning towards Scotty because I fear Yesod might be a bit too bulky for what I need...
19:17:51 <blackdog> finishingmove: scotty is great for small apps and getting your feet wet
19:18:11 <blackdog> to be perfectly honest, most of my json apis end up so small i never outgrow scotty *shrug*
19:18:54 <mm_freak_> finishingmove: happstack-server, snap-server or something WAI-based
19:19:23 <finishingmove> I'm really looking for something simple to use most of all
19:19:30 <finishingmove> performance is not an issue at all right now
19:19:33 <finishingmove> just want to get into it
19:19:34 <mm_freak_> all of them are simple
19:19:55 <mm_freak_> although WAI's "simple" is really not much related to "easy" =)
19:20:16 <mm_freak_> my personal recommendation is happstack-server together with web-routes-boomerang for the RESTful part
19:20:38 <Luke1> something's wrong with my flymake for haskell. It always complains it can't find the last import in my import list. anyone know how to fix this?
19:21:52 <finishingmove> ok, thanks blackdog and mm_freak_, I'll check it out.
19:22:13 <jfischoff> preflex: seen goldfire
19:22:14 <preflex>  Sorry, I haven't seen goldfire
19:22:18 <jfischoff> drats
19:23:08 <mm_freak_> i should point out that happstack-server does not really support push/pull, because it uses lazy I/O‚Ä¶  if you're after that, you should probably go with snap-server/scotty/WAI, but then you have to use stringy routing or get a routing framework like web-routes on top of them
19:23:14 <jfischoff> byorgey: you need to get goldfire on here! ;)
19:23:25 <byorgey> jfischoff: he's not on IRC much.  Besides, it's 3:30am where he is!
19:23:37 <jfischoff> :O
19:23:42 <jfischoff> where is he?
19:23:47 <byorgey> Cambridge
19:23:50 <jfischoff> aye
19:23:53 <byorgey> doing an internship at MSR
19:24:04 * jfischoff nods
19:24:12 <copumpkin> goldfire?
19:24:17 <mm_freak_> so what, it's 4:23 AM here‚Ä¶  programmers don't synchronize with the earth's rotation
19:24:24 <byorgey> copumpkin: Richard Eisenberg
19:24:30 <copumpkin> oh :)
19:24:36 <byorgey> mm_freak_: he also has a 2-year old. =)
19:24:45 <mm_freak_> ok, that's different =)
19:25:49 <jfischoff> I'm trying to get singletons to compile with HEAD again ‚Ä¶ probably just wasting my time :(
19:27:33 <byorgey> heh, perhaps
19:27:55 <carter> jfischoff yeah‚Ä¶ theres a LOT changing in type famlies right now
19:28:00 <wallmani> what is msr?
19:28:06 <byorgey> probably Richard could have it fixed before you even understand what the problem is =)
19:28:17 <byorgey> wallmani: Microsoft Research
19:28:21 <jfischoff> byorgey, carter: exactly
19:28:23 <wallmani> ah
19:28:46 <carter> jfischoff byorgey i'm following the commit + ticket feed on this stuff,  theres a lot of changes going on there
19:29:09 <carter> he found some gnarly corners recently and i think they're getting fixed up really nicely
19:29:09 <jfischoff> TypeLits is also in flux
19:29:40 <carter> jfischoff not surprised
19:29:44 <carter> what changes are going on there?
19:30:44 <jfischoff> Since 7.6 they have moved more in the direction of richards approach to singletongs ‚Ä¶ which has also changed slightly
19:30:57 <carter> jfischoff eh? i know they were merging them together
19:31:10 <carter> + some ways of making propositional equality sane
19:31:19 <jfischoff> sort of on the wiki it seemed like they were debating things
19:31:20 <byorgey> wallmani: the MSR in Cambridge, England is (among many other things) GHC central -- they employ Simon Peyton Jones, Dmitrios Vytiniotis, and currently Geoff Mainland
19:31:41 <byorgey> and they have a steady stream of students coming to do internships hacking on GHC
19:31:44 <geekosaur> spj left, I think?
19:31:51 <byorgey> geekosaur: no, Simon Marlow left
19:31:56 <carter> geekosaur nooooo, simon marlow
19:32:00 <wallmani> wow, impressive
19:32:11 <jfischoff> I wrote this interesting prototype for building REST api's but I can of need this stuff to work to finish it up :(
19:32:19 <jfischoff> might have to wait a while ..
19:32:23 <wallmani> are they doing haskell dev there?
19:32:30 <byorgey> and your prototype only works with GHC HEAD??
19:32:54 <carter> jfischoff should first make it work on 7.6
19:33:00 <carter> oor at least a weaker version thereof
19:33:04 <carter> so more people can use it
19:33:05 <byorgey> wallmani: no, Microsoft Research just funds a lot of really smart people to do basic research
19:33:20 <byorgey> wallmani: it doesn't necessarily have anything to do with stuff Microsoft the company is doing
19:33:20 <carter> microsoft research supports a LOT of great science
19:33:38 <byorgey> though a lot of the ideas coming out of Haskell research have made their way into F# and C#
19:33:41 <wallmani> oh
19:33:50 <byorgey> etc.
19:33:53 <jfischoff> well no it did doesn't work at all, but in ghc HEAD the typelits implement the same Sing type family that richard uses and I can use the snazzy singleton stuff ‚Ä¶ in theory.
19:34:00 <jfischoff> I mean it compiles in 7.6
19:34:04 <byorgey> ah, I see
19:34:09 <wallmani> i have this prejudice that anything microsoft does is to squeeze more money out for the shareholders
19:34:13 <jfischoff> the interface, but you can't actually make anything with it
19:34:18 <carter> wallmani not science
19:35:13 <byorgey> wallmani: that's only MOST of what they do.  but they have SO MUCH MONEY that they can throw a bunch at basic research and not care what happens to it.
19:35:16 <wallmani> i thought it was especially science
19:35:57 <wallmani> that is good news then, microsoft does have a lot good meaning peoppe there
19:36:06 <carter> yes
19:36:11 <geekosaur> MSR is good people
19:36:38 <carter> its a weird ginormous mega corp
19:36:40 <carter> but yes
19:36:48 <carter> they do have benign albeit profitable goals
19:36:58 <carter> which area enabled by supporting science
19:40:39 <wallmani> yeah
19:41:23 <wallmani> i wonder if what they fund resembles google x labs
19:41:29 <carter> wallmani nope
19:41:32 <carter> they're a lot more open
19:41:47 <carter> people at google never tell you about what they're doing until its public
19:41:54 <carter> MSR people do open research LOTS of the time
19:42:26 <carter> i get the sense that with google, the papers that come out are of "things we did last year that are cool, but no longer what we do because theres something even cooler"
19:42:29 <wallmani> i see
19:42:50 <carter> with the MSR research, its stuff that goes into supporting OS dev, software reliability, better dev tools
19:42:58 <wallmani> well both approaches seem valid and as long as thry work for both companies
19:43:04 <carter> yeah
19:43:16 <wallmani> is it all for the windoes ecosystem tough?
19:43:28 <carter> wallmani MSR? nope:)
19:43:48 <carter> lots of cool MSR stuff makes it into MS products
19:44:38 <wallmani> ah
19:44:40 <wallmani> n
19:44:50 <Ghoul_> :t Iterator
19:44:51 <lambdabot> Not in scope: data constructor `Iterator'
19:44:54 <carter> but lots of MSR stuff ins't strictly MS
19:44:55 <wallmani> grr, this wifi is terrible
19:45:32 <Ghoul_> Is there an iterator typeclass thats intended for public consumption
19:45:37 <wallmani> ms should develop their own language
19:45:43 <Ghoul_> C#
19:45:45 <Ghoul_> F#
19:45:46 <Ghoul_> J#
19:45:47 <wallmani> just because
19:45:48 <Ghoul_> etc
19:45:59 <carter> eg: vowpal-wabbit is a BSD licensed
19:46:03 <wallmani> but something that is like IE
19:46:03 <carter> as is the GHC work :)
19:46:26 <wallmani> actually VBA is that
19:54:19 <Ghoul_> is there a way to say that "if something is a member of these three typeclasses, then it's automatically this" ?
19:55:01 <Ghoul_> like, say I have the classes Forward and Bounded
19:55:09 <Ghoul_> where Forward has next and Bounded has start, end
19:55:54 <Ghoul_> if I wanted to make a typeclass ForwardBounded which satisfies anything which is Forward and Bounded at the same time, is that possible?
19:57:16 <shachaf> Some types are never satisfied.
19:57:38 <shachaf> Just like some people in IRC.
19:57:46 <Ghoul_> lol
19:58:10 <Ghoul_> It'd just be nice to do fn :: ForwardBounded x => ... instead of (Forward x, Bounded x) =>
19:58:29 <shachaf> type ForwardBounded x = (Forward x, Bounded x)
19:58:51 <shachaf> (If you want to do X, you should ask about how to do X, rather than how to do Y.)
19:59:10 <Ghoul_> That looks kind of like a tuple
19:59:12 <Ghoul_> why isn't a tuple?
20:00:09 <shachaf> (Forward x, Bounded x) also looks kind of like a tuple.
20:00:21 <shachaf> I mean, when you wrote it, rather than when I wrote it.
20:00:38 <shachaf> It is kind of like a tuple.
20:01:18 <Ghoul_> mmk.
20:01:37 <shachaf> (You need an extension, ConstraintKinds.)
20:01:57 <Ghoul_> ah! thats useful :)
20:02:53 <shachaf> GHC would've told you that, of course.
20:02:55 <shachaf> @let type Blah a = (Show a, Eq a)
20:02:56 <lambdabot>  .L.hs:132:1:
20:02:56 <lambdabot>      Illegal constraint synonym of kind: `Constraint'
20:02:56 <lambdabot>        (U...
20:03:10 <shachaf> Right after that ellipsis...
20:14:17 <roboguy_> does GHC do stream fusion automatically or do you need to use a library?
20:16:18 <c_wraith> roboguy_: it doesn't do it automatically at all.  It has to be built into libraries.
20:16:38 <shachaf> The standard library does foldr/build fusion.
20:16:38 <c_wraith> roboguy_: and furthermore, you have to compile the code that does it with optimizations
20:17:20 <roboguy_> shachaf: so functions like foldr and map do fusion?
20:17:34 <shachaf> Yes.
20:17:38 <c_wraith> foldr is part of the fusion definition, so it's automatic there.
20:17:48 <shachaf> You can ask GHC to dump rule firings and such to see what's going on.
20:18:01 <c_wraith> unfortunately, foldl doesn't fuse
20:18:15 <roboguy_> hmm
20:18:15 <c_wraith> that's the big weakness of foldr/build fusion
20:20:08 <roboguy_> shachaf: that's kind of cool. it doesn't tell you where though?
20:21:27 <c_wraith> line numbers kind of don't make sense at that point.  foldr/build fusion also depends on heavy inlining, so things are nowhere near their definition location anyway
20:21:42 <shachaf> There are GHC options to tell you a lot more.
20:21:50 <roboguy_> yeah that makes sense
20:22:07 <c_wraith> you can always get the ghc core to see what all it's done
20:22:15 <shachaf> dump-rule-rewrites, dump-simpl-phases, etc.
20:22:27 <shachaf> Lots and lots of options.
20:23:27 <roboguy_> c_wraith: yeah, that's true. I've never done that, but I'm aware of the feature. maybe I should try it out
20:23:41 <c_wraith> there are some good tutorials for reading core online
20:24:01 <c_wraith> it's not actually that hard to get into, if you follow some of them
21:07:36 <shachaf> Why does the limit of the diagram 0 -> F0 -> F¬≤0 -> ... exist for any Functor in Haskell?
21:30:02 <Cale> shachaf: because recursion
21:30:46 <Cale> shachaf: You're allowed to make a newtype which refers to itself which can provide such a limit
21:31:19 <shachaf> Cale: OK. But even without recursion you have Mu and Nu.
21:31:37 * shachaf is sort of pretending recursion doesn't exist for the moment.
21:31:52 <Cale> You can't really define Mu without recursion...
21:32:53 <Cale> shachaf: I'm thinking of   newtype Mu f = In { out :: f (Mu f) }
21:33:09 <shachaf> I prefer to call that Fix, by analogy to the value-level fix.
21:33:14 <Cale> okay
21:33:20 <shachaf> I mean newtype Mu f = Mu { runMu :: forall r. (f r -> r) -> r }
21:33:25 <shachaf> And data Nu f = forall x. Nu x (x -> f x)
21:33:59 <shachaf> Which are least and greatest fixed points of a functor, and always exist. But I'm not sure why.
21:34:09 <Cale> hm
21:35:05 <copumpkin> @let type Nat = forall r. (Maybe r -> r) -> r
21:35:06 <lambdabot>  Parse failed: TypeOperators is not enabled
21:35:15 <copumpkin> wat
21:35:16 <Cale> What are the isomorphisms f (Mu f) -> Mu f and Mu f -> f (Mu f)?
21:35:26 <shachaf> copumpkin: No forall. :-(
21:35:38 <shachaf> delMuF q = Mu $ \k -> k $ fmap (\v -> runMu v k) q
21:35:40 <Cale> If it's really a fixpoint, we should be able to provide maps of those types which compose to the identity
21:35:42 <shachaf> addMuF m = runMu m (fmap delMuF)
21:37:00 <shachaf> If Hask was a complete category then something along the lines of Knaster-Tarski would probably be an explanation. But it's not (and its requirements are probably too strong).
21:37:15 <shachaf> The same thing with Nu, by the way:
21:37:17 <shachaf> addNuF (Nu x f) = fmap (\y -> Nu y f) (f x)
21:37:21 <shachaf> delNuF q = Nu q (fmap addNuF)
21:38:48 <shachaf> copumpkin: By the way, Mu is the obvious "church"/boehm-berarducci encoding of Fix. What sort of encoding process can we use for codata in general to end up with Nu?
21:41:10 <shachaf> I guess a slightly different question is why every Functor has an initial algebra and a terminal coalgebra.
21:41:42 <shachaf> Since that's not true in every category.
21:41:43 <copumpkin> does it? I haven't proved that
21:42:14 <shachaf> Oh, wait, looks like nlab has the answer.
21:42:38 <shachaf> "Theorem. Let C be a category with an initial object 0 and colimits of Œ∫-directed diagrams for some regular cardinal kapa, and suppose F:C‚ÜíC preserves Œ∫-directed colimits. Then F has an initial algebra"
21:42:46 * shachaf looks those things up.
21:43:02 <tabemann> opinion question: I'm implementing group and groupBy for strict lists, but I can produce any combination of strict (strict), strict (lazy), lazy (strict), and lazy (lazy) lists as output - should I bother covering all the possibilities (especially since there ought to be a "reversed" version of each of the strict possibilities), or should I only implement some of them, and then which?
21:44:12 <johnw> until you know how much of a need there is for this generally, I wouldn't expend too much effort trying to be exhaustive in your interface; implement the modes you actually need right now.  just a thought
21:44:18 <shachaf> Is it the case Hask has colimits of Œ∫-directed diagrams for some regular cardinal kapa, and does every Functor preserve Œ∫-directed colimits?
21:44:32 <tabemann> in theory I could implement up to 4 + 2 + 2 + 1 possibilities, which seems unreasonably large
21:45:12 <tabemann> johnw: I'm trying to implement all of GHC.List and Data.List, with all operations that produce strict lists also having a reversed counterpart (as the reversed counterpart is faster)
21:46:03 <tabemann> (there's no need to produce a reversed version of an operation that produces a lazy list, as that would be slower than the operations that produce in-order lazy lists)
21:47:20 <tabemann> hmm... I'll probably limit myself to at least strict (strict), lazy (strict), and lazy (lazy), but then whether I should keep all the possible combinations of all of those stricts having a reversed version...
21:47:50 <tabemann> e.g. I might do a strict (strict) and a rev. strict (rev. strict), but not a rev. strict (strict) or strict (rev. strict)
21:48:48 <tabemann> so that still results in five possibilities, strict (strict), rev. strict (rev. strict), lazy (strict), lazy (rev. strict), and lazy (lazy)...
21:50:24 <tabemann> (most of what I'm implementing has one, two, or three versions, not five)
21:52:05 <shachaf> I don't know whether that's "the answer"...
22:06:03 <jfischoff_> preflex: seen paulcc
22:06:03 <preflex>  Sorry, I haven't seen paulcc
22:06:08 <jfischoff_> oh well
22:40:34 <codesoup> how do i drop n elements from the end of a list without traversing it twice
22:41:17 <shachaf> @where sneaky
22:41:17 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
22:41:47 <copumpkin> I love that one
22:43:36 <dimday> hi. anybody familiar with digestive-functors?  I was wondering if there is a way to implement a list of checkboxes. Something like on this page on stackoverflow (http://stackoverflow.com/questions/6436238/list-of-checkboxes-with-digestive-functors) but for the new api.
22:45:11 <dimday> I've been trying to do it using listOf. can't wrap my head around it yet
22:46:10 <Cale> shachaf: Do you have a proof that delMuF and addMuF compose to the identity?
22:46:31 <Cale> shachaf: I thought I'd give it a shot in Coq, and it's... kinda tricky.
22:48:00 <shachaf> Cale: No, I wrote them as an afterthought earlier and didn't think beyond making them type-check without recursion.
22:49:39 <shachaf> elliott: Can we have forall in lambdabot?
22:50:02 <codesoup> oh, that dropFromEnd is pretty sneaky. i wonder why it's not in Data.List (as dropEnd) even though it has a dropWhileEnd
22:50:32 <shachaf> Cale: It seems like they would be an isomorphism, though?
22:53:05 <Cale> shachaf: hehe, I drill down a bit in this proof and end up with something that looks like
22:53:27 <Cale> fmap (\v -> mkMu (\k -> k (fmap (\v0 -> runMu v0 k) (runMu v (fmap (\q0 -> mkMu (\k0 -> k0 (fmap (\v0 -> runMu v0 k0) q0)))))))) q = q
22:53:50 <Cale> and I can't apply any of my laws to that
22:54:07 <shachaf> Maybe if you just unroll the type a few more steps!
22:54:22 <Cale> (in particular, I can't apply functoriality there...)
22:54:25 <copumpkin> Cale: I'd imagine you'd need some naturality maybe
22:54:32 * shachaf should probably learn Coq.
22:54:54 <sordina1> Heya dudes.
22:55:00 <Cale> shachaf: You probably already know it
22:55:11 <Cale> (I found out that I did)
22:55:15 <sordina1> I'm having the weirdest issue with some unix utils I'm writing in Haskell.
22:55:16 <shachaf> Unknown knowns, eh?
22:55:49 <copumpkin> there's a lot of interesting stuff in dependent land that has to do with good dependent type design, that doesn't really come magically
22:56:14 <copumpkin> devising interesting types is fascinating and I'd be surprised if you already knew it
22:56:21 <sordina1> I'm using getContents to relaunch a process on input, and it works find with input piped from another process.... unless I have an intermediate process, such as grep.
22:56:35 <copumpkin> anyway, I'm going to bed
22:56:36 <sordina1> Then it behaves as if it recieves no input at all.
22:56:53 <Cale> copumpkin: Well, okay... Coq lets me write the types I would have liked to write in Haskell, but couldn't because of limitations.
22:56:54 <shachaf> copumpkin: Hey! You still owe me some proofs!
22:57:43 <copumpkin> Cale: yeah, the basic idea is very simple and elegant. I urge you not to stop there though :)
22:57:49 <copumpkin> shachaf: I owe you many things :P
22:57:53 <sordina1> This is the file in question: https://github.com/sordina/Conscript/blob/master/Conscript.hs
22:57:53 * copumpkin zzzZzZzZ
22:57:55 <shachaf> copumpkin: I've noticed.
22:57:56 <shachaf> Cale: Did the same thing happen with addNuF and delNuF?
22:58:04 <Cale> shachaf: haven't tried those
22:58:08 <sordina1> Anyway, it's stumped me...
22:58:13 <Cale> sordina1: looking...
22:58:18 <sordina1> Thanks Cale.
22:58:50 <shachaf> Cale: Given that the definitions are pretty much dual to each other I'd expect something similar, but maybe the existential is easier to work with.
22:59:04 <shachaf> (Than the continuation.)
23:01:01 <shachaf> Cale: If you can prove that delMuF is initial later that would be nice too. :-)
23:02:44 <shachaf> (An initial F-algebra, I mean.)
23:03:30 <hpaste> Cale pasted ‚ÄúAttempted proofs‚Äù at http://paste.tryhaskell.org/90629
23:03:47 <Cale> shachaf: You can have a look there at my clumsy attempts.
23:03:55 <shachaf> Coq has type classes?
23:03:59 <Cale> yep
23:04:08 <Cale> Its implementation of type classes sucks though
23:04:25 <Cale> It basically picks the last defined instance which fits
23:04:42 <Cale> Rather than doing anything to warn/worry about overlaps.
23:04:46 <shachaf> That works well enough for this kind of proof.
23:04:55 <shachaf> I guess.
23:05:05 <Cale> Yeah, we don't have to care about instances at all :P
23:05:54 <shachaf> Then again, if records could contain laws, I'd probably feel less bad about passing a record directly instead of using an instance.
23:07:36 <Cale> Yeah, in fact, that's pretty much all that's going on, only it tries to fill parameters of the class type with things it has handy automatically, and the Class is just being defined as this record type.
23:07:50 <Cale> If your class only has one method, you can even skip the record.
23:40:27 <Walther> Hello folks! I remember someone mentioned something about a haskell-based HTML-generator slash simple cms slash "have content in plaintext, generate html via make-esque command" thing
23:40:41 <MasseR> Walther: Hakyll?
23:40:52 <MasseR> http://jaspervdj.be/hakyll/
23:41:10 <Walther> could've been that, though i recall the name being a bit different... I'll look into that as well though, thanks
23:42:05 <Walther> Ah, Hamlet
23:42:16 <Walther> What are the core differences between Hakyll and Hamlet?
23:42:23 <MasseR> Hamlet is a templating language
23:42:32 <MasseR> Hakyll is a DSL for creating websites
23:42:32 <Walther> At least on the first peek, Hakyll seems more documented and developed :P
23:42:35 <Walther> Nod.
23:42:50 <Walther> How well does Hakyll take in templates or utilize ready-made ones?
23:43:11 <pharaun> pretty easy to hook in imho
23:43:14 <MasseR> It can use a multitude of different templating engines, like hamlet and blaze-html
23:43:17 <Walther> or ...uh, how difficult it is to re-bake an existing tiny site mainly built as a prototype, into a hakyll template
23:43:21 <MasseR> And true, easy to add your own
23:43:57 <Walther> the site in particular I've been punching together this time is a personal blog with responsive design, http://walther.kapsi.fi/
23:43:59 <MasseR> Walther: Depends. Basically the idea is that you have a master-template (with hamlet or bare html for example) with some keys
23:44:03 <Walther> doesn't have much content yet though
23:44:23 <MasseR> Walther: Hakyll is nowadays focused to blogs
23:44:58 <Walther> Basically what I'd love to have is a folder called "content" or "articles" with the actual content in pretty much plaintext
23:45:09 <MasseR> Walther: A master template, then pages with more specific layouts. For every page in directory x, a blog page is generated.
23:45:22 <MasseR> Walther: What you are describing is hakyll :)
23:45:23 <Walther> with a couple "tags" for stuff like code in <pre> and citations in <blockquote>
23:45:42 <Walther> Nod. I'll look more into this, thanks!
23:45:50 <MasseR> http://jaspervdj.be/ is written with hakyll
23:45:59 <MasseR> https://github.com/jaspervdj/jaspervdj and here's the source for it
23:46:05 <pharaun> fwiw
23:46:07 <Walther> I like the idea of static sites, I've had enough of PHP, Wordpress, Joomla, etc
23:46:18 <pharaun> i modified my hakyll to bem ore about articles and etc
23:46:20 <MasseR> You can see that he has 'posts' directory with markdown files
23:46:22 <pharaun> than a blog and it wasn't too bad
23:46:27 <sipa> let's write wikipedia as a static html
23:46:36 <pharaun> but if you follow the blog termology its a bit... easier :)
23:46:57 <Walther> there's nothing really wrong with any of those, but for a design-oriented person like me who wants to have the theme look exactly like my vision/thoughts, fighting against wp/joomla themes overriding anything and everything can be a pain
23:49:12 <arcatan> Walther: the default templating system of Hakyll isn't very powerful and often irks me, but then again, I haven't put in the work to add another one :P
23:50:14 <sordina1> So..... here is a shell output with a minimal example:
23:50:16 <sordina1> http://codepad.org/3c2NDbDF
23:50:26 <sordina1> I'm totally stumped by this behaviour
23:50:40 <Walther> arcatan: well, how does the "templating engine" work? If it allows me to just punch in a single .css file, I'm fine with it - the separate page layouts will just have different class=""'s and id=""'s in elements
23:53:56 <Walther> ...looking more into the examples and source at github for the hakyll homepage, ...damn, this is pretty much everything I wanted and more
23:54:01 <Walther> no need to write my own, it seems
23:54:09 <arcatan> Walther: the templating language only supports replacing strings. no loops or ifs. but for your case it's probably enough.
23:54:24 <Walther> (I had already been thinking about making my own sipmlistic CMS)
23:54:39 <arcatan> as long as your pages are pretty static, it's fine, but if they become more dynamic, it soons becames a PITA
23:54:47 <Walther> arcatan: And if I need those some day, I can probably stir up a pull request
23:55:04 <arcatan> Walther: if you try it out and need more guidance, #hakyll is a good place to ask more
23:55:09 <Walther> Nod.
