00:07:43 * hackagebot hen 0.1.0 - Haskell bindings to Xen hypervisor interface  http://hackage.haskell.org/package/hen-0.1.0 (FedorGogolev)
00:07:45 * hackagebot hen 0.1.0.1 - Haskell bindings to Xen hypervisor interface  http://hackage.haskell.org/package/hen-0.1.0.1 (FedorGogolev)
00:08:36 <Taneb> That feeling you get when you send a pull request adding an Applicative instance for a Monad
00:12:03 <shachaf> Hmm, you should be able to send pull request requests.
00:13:40 <Spockz> Has anyone of you been approached by a company called "Packt Publishing" for authoring a (yet another) book on Monads?
00:15:41 <adnap> Is there a function f [1, 5, 6, 2] [2, 3] = [(1, 2), (5, 3), (6, 6), (2, 2)] ?
00:16:09 <adnap> zip just makes a list with the length of the smaller list...
00:16:25 <johnw> \xs ys = zip xs (ys ++ xs)
00:16:40 <johnw> oh, you want overlap
00:16:41 <shachaf> johnw: ?
00:17:14 <adnap> f (x:xs) [] = (x, x) : f xs []
00:17:32 <adnap> f [] (x:xs) = (x, x) : f [] xs
00:18:42 <adnap> > let x = 2; y = 3 in x + y
00:18:43 <lambdabot>   5
00:19:58 <adnap> > let f (x:xs) [] = (x, x) : f xs []; f [] (y:ys) = (y, y) : f [] ys; f (x:xs) (y:ys) = (x, y) : f xs ys in f [1..10] [2..5]
00:19:59 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)*Exception: <...
00:20:23 <adnap> > let f [] [] = []; f (x:xs) [] = (x, x) : f xs []; f [] (y:ys) = (y, y) : f [] ys; f (x:xs) (y:ys) = (x, y) : f xs ys in f [1..10] [2..5]
00:20:25 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
00:22:02 <adnap> > (,) <$> [1..10] <*> [2..5]
00:22:03 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(2,2),(2,3),(2,4),(2,5),(3,2),(3,3),(3,4),(3,5),(4...
01:00:35 <Sonarpulse> https://github.com/Ericson2314/henet/blob/manual/src/Network/ENet/Bindings/Callbacks.hsc
01:00:39 <Sonarpulse> does this look legit?
01:02:21 <aleator_> Sonarpulse: Casually yes. But I'd recommend letting bindings-dsl take care of the storable instance. Those are horrible if they go wrong.
01:03:23 <Sonarpulse> bindings-dsl
01:03:29 <Sonarpulse> that is the thing from bitbucket?
01:03:53 <Sonarpulse> do you know johnw's toold to generate bindings-dsl from headers?
01:03:53 <aleator_> https://bitbucket.org/mauricio/bindings-dsl/wiki/Home, this one.
01:03:57 <Sonarpulse> yeah
01:04:19 <aleator_> Sonarpulse: Which tool is that?
01:05:41 <Sonarpulse> c2hsc
01:05:51 <Sonarpulse> *not* c->hs
01:06:15 <Sonarpulse> https://github.com/jwiegley/c2hsc
01:06:27 <Sonarpulse> if you could get that to work with this Enet, that would be great!
01:09:09 <Aetherspawn> Can somebody help me with this type issue: http://hpaste.org/90125 . I'm trying to get strapSessionState working as a drive-thru state type thing to make spawning new clients easier.
01:09:46 <johnw> Aetherspawn: the line number in the error message doesn't match up with that source
01:09:50 <johnw> did you delete some code?
01:09:58 <Aetherspawn> Just the huge copyright thing at the top
01:10:05 <johnw> what's the new line 46?
01:10:12 <Aetherspawn> It's the runStateT line
01:10:54 <johnw> I believe it should be: flip runStateT strapSessionState $ handleClient a
01:11:29 <Aetherspawn> Ohh forgot to use defaultSessionState
01:12:18 <aleator_> Sonarpulse: Seems neat.
01:16:36 <yitz> @pl \x -> f <$> g x <*> h x
01:16:39 <lambdabot> (f <$>) . liftM2 (<*>) g h
01:16:39 <lambdabot> optimization suspended, use @pl-resume to continue.
01:16:53 <yitz> @pl-resume
01:16:59 <lambdabot> (f <$>) . liftM2 (<*>) g h
01:16:59 <lambdabot> optimization suspended, use @pl-resume to continue.
01:17:16 <Aetherspawn> Is there a way to disregard the result of runStateT because when I do something like _ <- runStateT... ; return () I get a type error but when I don't I get expected: m0 (), actual: m0 (a0, s0)
01:17:51 <yitz> @pl \x -> f <$> g x <*> h x <*> k x
01:17:51 <lambdabot> (f <$>) . ap ((<*>) . liftM2 (<*>) g h) k
01:18:19 <Aetherspawn> :t void
01:18:20 <lambdabot> Functor f => f a -> f ()
01:23:06 <rtb> i cannot get vim and shim to work. Anybody can help?
01:23:31 <johnw> Aetherspawn: right, void is what I use in those cases
01:25:22 <Aetherspawn> johnw, I get can't construct infinite type trying to work around it with void. http://hpaste.org/90125
01:28:30 <amalloy> i have a silly question about notation/verbiage. suppose i foldr f (True, False) [0..10], and i want to describe this computation aloud to a friend. how do i do it? do i "fold over" a pair of booleans, or over a list of integers? or perhaps i "fold a sequence of integers into a pair of booleans"?
01:28:30 <amalloy> (related: what is the name for f? i've taken to calling it the "reductor", since i come from a language that calls it reduce rather than fold)
01:29:57 <johnw> Aetherspawn: hmm... i don't know offhand
01:30:11 <Aetherspawn> ok
01:31:57 <b6> http://hpaste.org/90128  TH problem
01:34:30 <Andrea_> does someone know a tutorial for backtracking in haskell ?
01:35:08 <johnw> Aetherspawn: you can also drop the void and just put "return ()" after
01:36:01 <Aetherspawn> johnw, its some wierd side effect of using a lambda there
01:36:40 <shachaf> yitz: liftA3 . liftA3, maybe?
01:36:55 <Lethalman> I'm doing find predicate list, how can I get both the found element and the previous element?
01:37:41 <Lethalman> like findWithPrev ((==) 4) [1,2,3,4,5] to return (3,4)
01:38:15 <Lethalman> I mean, is there an existing function for that already, or some particular idiom instead of writing the function myself
01:38:16 <eikke> Lethalman: zip
01:38:25 <Andrea_> has someone programmed a backtracking algorithm in haskell ?
01:38:26 <Lethalman> eikke, ah, right
01:38:46 <Lethalman> eikke, that way I can even have it circularly
01:38:56 <Lethalman> :t cycle
01:38:58 <lambdabot> [a] -> [a]
01:39:03 <Lethalman> thanks
01:39:29 <johnw> Andrea_: does logict count?
01:39:40 <johnw> I don't know enough about backtracking to say
01:40:33 <amalloy> Andrea_: since haskell values are immutable, backtracking is pretty trivial: just save the state of the computation somewhere, start doing some speculative calculations, and then if you don't like the result just go back to the saved state
01:40:47 <Andrea_> a backtracking algorithm calulate one solution of a problem and calculates the next depth recursively
01:41:09 <Andrea_> e.g. 8 queens problem , or solve pentominoes
01:42:03 <Andrea_> amalloy,  save the state ?
01:43:11 <Andrea_> there are many backtracking algorithms e.g. dlx by donald knuth,  is it adaptable to haskell ?
01:44:00 <b6> i'm sure people have done a billion queens.hs.
01:44:09 <b6> just google.
01:46:21 <Andrea_> amalloy, how do you restore a saved state ? do you use monads ?
01:46:43 <Lethalman> Andrea_, or recursion
01:47:08 <johnw> Andrea_: http://damienradtke.org/solving-queens-with-haskell/
01:47:11 <Lethalman> Andrea_, depends on the search type
01:47:18 <Lethalman> for a depth first search recursion is enough
01:47:23 <Andrea_> Lethalman, backtracking uses loops in imperative programming languages
01:47:30 <Lethalman> Andrea_, or recursion
01:47:56 <Lethalman> it's written nowhere that you have to do it iteratively
01:48:05 <mauke> Andrea_: no, it doesn't
01:48:16 <Andrea_> i wrote a own program for solving the 8 queens, but i cannot say if its backtracking
01:48:43 <Lethalman> mauke, it can
01:49:58 <hpaste> Andrea pasted “8 queens” at http://hpaste.org/90130
01:50:38 <Andrea_> this is my 8 queens solution : http://hpaste.org/90130
01:50:57 <Andrea_> but it is not backtracking, i think
01:51:08 <johnw> Andrea_: did you see the link I pasted?
01:51:24 <Andrea_> other problems, e.g. pentomino is not solveable in this way
01:52:07 <Andrea_> johnw, thx, i will watch to this
01:54:05 <Andrea_> thx for help, bye
01:54:59 <Aetherspawn> johnw, my problem comes down to the fact that \a is given IO a but runTCPServer has to abide by conduit nonsense so it has to be an AppData m where m is StateT.. when it gets put through handleClient
01:56:09 <Aetherspawn> Which is understandably designed, but really undesirable because the only way I can think to get around that is to have runTCPServer inside a function carrying a useless state
02:01:06 <johanneslippmann> > [1..]
02:01:07 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
02:01:52 <johanneslippmann> > 3+4
02:01:53 <lambdabot>   7
02:03:33 <nooodl> heh, from that 8 queens article: "case args of [] -> 8; (a:rgs) -> read a :: Int"
02:03:38 <nooodl> (a:rgs), seriously?
02:03:42 <Lethalman> lol
02:03:51 <johnw> heh
02:03:56 <frerich> :-)
02:04:01 <Taneb> I am somewhat annoyed at GHC and the binary package
02:04:13 <johnw> maybe he put that in there to see if anyone was really reading it
02:11:54 <bitonic> nooodl: you should read pigworker’s code
02:11:58 <bitonic> it’s all like that
02:18:27 <yitz> Taneb: what happened?
02:18:48 <Taneb> yitz, mainly that GHC is installed with an old version of the binary package
02:18:54 <yitz> aha
02:20:51 <yitz> Taneb: what changed in binary that you need, and in what version of GHC can you not get it?
02:21:07 <Taneb> yitz, I don't know, I'm just installing things
02:21:40 <yitz> ah ok. because afaik the binary package has been very stable for quite a while, so it shouldn't matter.
02:22:01 <b6> in TH, is there some way to introspect a type to figure out the appropriate constructor of Pat to use to match it? e.g., Bool needs ConP, but Int needs LitP.
02:22:30 <yitz> unless someone was lazy about the lower bound for a binary dependency, and gratuitously required a newer version than the one you have. that could be annoying.
02:23:57 <yitz> b6: well, only numeric types and String use LitP. umm... unless you have OverloadedStrings enabled...
02:24:08 <Taneb> ghc-7.6 comes with binary-0.5.1.1, and JuicyPixels requires >= 0.6.4.0
02:24:33 <yitz> b6: a user-defined type with a Num instance could match either ConP or LitP.
02:25:04 <yitz> b6: sounds like figuring out those kinds of things at compile time would be hard.
02:25:35 <yitz> b6: when TH is processed, do we know yet all of the class instances of every type?
02:26:16 <b6> yitz: not sure. http://hpaste.org/90128  do you think i can generate the needed clauses?
02:26:30 <b6> i am really having problems coding the Pat i need.
02:26:39 <yitz> Taneb: that doesn't sound right. it only works with GHC HEAD?
02:27:14 <Taneb> yitz, I haven't tried messing with dependencies
02:27:30 <mr-> Is it not possible to install another version of binary?
02:29:07 <Taneb> mr-, it is, it's just annoying
02:29:27 <eikke> having such an old version of binary shoujld be annoying ;-)
02:29:51 <mr-> Taneb: how did you notice anything? My cabal automatically installs a new binary
02:30:10 <Taneb> mr-, I've got in the habit of --dry-run'ing before any cabal install
02:31:10 <yitz> b6: i see. well, what do you want that function declaration you are trying to generate to look like? don't you just want a pattern that is just a single variable?
02:31:28 <yitz> b6: or do you really need to dig down into matching constructors?
02:31:56 <b6> yitz: the patterns just look like foo 0 = '0' (for an instance of C Int Char.
02:32:00 <b6> )
02:33:16 <b6> it's just, if type c happens to be Int, the Pat needs to be LitP. but if c was Bool, it would need Pat ConP.
02:33:29 <b6> i don't know how to discover that from the type.
02:34:16 <yitz> b6: i don't know what you want - aside from the special cases of Int and Bool you just mentioned. so i certainly don't know how to discover it from the type.
02:34:41 <b6> yitz: ok. thanks for looking, i appreciate it.
02:35:05 <yitz> b6: if Int and Bool are special cases, handle them separately, don't use TH for them.
02:36:47 <t7> im writing php today :(
02:37:02 <tomejaguar> t7: write a Haskell to PHP compiler :)
02:37:19 <yitz> mr-: it can often be a bad idea to install a different version of a package that comes with GHC. things break.
02:39:29 <mr-> yitz: because when it comes with GHC, chances are high a lot of other stuff has been built against it?
02:41:13 <eikke> mr-: that, but then you can recompile those as well. problems really arise when something uses ghc-as-a-library
02:41:17 <yitz> Taneb: now wait a second. now i'm confused. according to the HP page, binary is *not* one of the libraries that is bundled with GHC.
02:41:26 <yitz> http://www.haskell.org/platform/changelog.html
02:41:44 <hpaste> bitonic pasted “GADTs and pattern matching” at http://hpaste.org/90131
02:41:57 <bitonic> why does this happen: <http://hpaste.org/90131>?
02:42:19 <yitz> Taneb: could be it's needed when you *build* GHC, but that's not important. you can install whatever version of binary you want.
02:42:26 <mr-> eikke: I see
02:42:26 <Taneb> Huh
02:42:30 <hpaste> bitonic annotated “GADTs and pattern matching” with “GADTs and pattern matching (annotation)” at http://hpaste.org/90131#a90132
02:42:33 <Taneb> I must have built GHC long ago
02:42:41 <bitonic> it can definitely derive the right type, since the auxiliary call works
02:42:46 <bitonic> but I can’t pattern match
02:42:52 <Taneb> Well, that explains that
02:42:58 <yitz> Taneb: in fact, neither binary nor cereal is even included with Haskell platform. I think that has been a topic of discussion there for a long time.
02:43:20 <yitz> Taneb: ok i hope that solves the problem for you :)
02:43:38 <Taneb> yitz, it's convinced me there was never a problem in the first place, which is better :)
02:43:44 <Taneb> Also, does anyone know what would be the appropriate channel to discuss the free-game package?
02:44:47 <yitz> mr-: yeah, i think that's was causes the problems. for example, other libraries that already came with GHC, or with HP, were built against the GHC version.
02:45:47 <eikke> yitz: you sure about binary not coming with ghc? ]$ ls ~/Projects/ghc/src/ghc/libraries/binary indicates it's part of the tree
02:50:45 <yitz> eikke: it's not present in any of my installations of several versions of GHC from the binary installation tarballs
02:52:47 <yitz> eikke: the binary package on hackage is maintained by Lennart Kolmodin, and the source repo link points to a github project owned by him personally, not the ghc trac
02:53:12 <yitz> eikke: it could be that the ghc source code has its own version of binary that it uses when you build ghc from source
02:53:56 <merijn> bitonic: Casual inspection leads me to think the type of the first foo is clearly wrong
02:54:49 <eikke> yitz: yup, seems to be pulled in from http://darcs.haskell.org/libraries/binary.git/
02:54:54 <merijn> bitonic: How could foo1 ever have type a as initial thing?! It pattern matches on maybe...
02:56:37 <merijn> bitonic: It can infer that a must be "Maybe v" in the case of the constructor Foo, but if you'd add another constructor Foo that type would be invalid
02:57:16 <hpaste> merijn annotated “GADTs and pattern matching” with “GADTs and pattern matching (annotation)” at http://hpaste.org/90131#a90133
02:57:46 <yitz> bitonic: i'm wondering why foo2 works. perhaps because GHC notices that result of foo2' is always bottom?
02:58:03 <merijn> yitz: It works because foo2 only calls foo' in the case of the Foo constructor
02:58:13 <merijn> GHC can proof that a must be Maybe v in that case
02:58:18 <merijn> s/proof/prove
02:58:59 <merijn> GHC can't infer that Foo is the only way to construct "Foo a", afaik
02:59:22 <yitz> the call to foo2' is independent of Foo
02:59:43 <merijn> yitz: How so?
03:00:05 <yitz> ah i see
03:00:41 <merijn> That fact that foo2' is called after the pattern match on Foo is enough to infer a = Maybe a
03:01:04 <merijn> If you had another constructor (like my example) then you'd have code that *doesn't* assume a = Maybe v for the other constructors
03:01:26 <bitonic> yitz: because GHC proves that equality
03:01:41 <bitonic> that is, ‘v ~ Var v1’
03:02:07 <bitonic> and then it uses to coerce ‘x’
03:02:15 <yitz> so the two v's in the GADT declaration are unrelated?
03:02:23 <merijn> Mind you, I'm not hardcore GHC enough to guarantee my analysis is correct
03:02:25 <merijn> yitz: Yes
03:02:26 <bitonic> yitz: no, they’re the same
03:02:29 <merijn> bitonic: No
03:02:44 <bitonic> well
03:03:05 <bitonic> right, OK
03:03:24 <yitz> what you really meant was data Foo :: * -> * where ...
03:03:39 <bitonic> yes, it is explicitly quantified, sorry
03:03:40 <bitonic> but anyway
03:03:46 <bitonic> the thing is that what you get out is that type equality
03:04:00 <bitonic> I don’t understand why it can’t use it with the pattern match
03:04:23 <Zariel> Are there any real differences between a TQueue and a TChan? Looks like they can both be used to send jobs to worker threads?
03:04:40 <merijn> bitonic: Like I said, I think GHC doesn't attempt to prove that Foo is the only way to construct a value of Foo a
03:04:58 <yitz> bitonic: just for fun - if you switch the order of the parameters in foo1, does it still not work?
03:05:11 <bitonic> merijn: but that’s not the problem, is it?  in *that* match, you have the right equality
03:05:25 <supki> Zariel: yes, you can't dup/clone TQueue
03:05:42 <bitonic> yitz: oh damn, if I switch them it works!
03:05:54 <bitonic> then I guest it just goes forward, but not backwards
03:06:05 <Zariel> supki: ok so a Chan can also be used for broadcasts whereas a Queue cant?
03:06:12 <supki> correct
03:06:13 <merijn> I actually think that's weirder than if it was wrong both ways
03:06:24 <bitonic> yeah, agreed
03:06:38 <yitz> bitonic: this sounds like spj ought to hear about this
03:06:43 <merijn> Yeah
03:06:51 <bitonic> I posted to the mailing list, going to reply with the forward version
03:07:08 <merijn> Although tbh that's a pretty vile type signature to write for that function
03:07:09 <bitonic> but maybe this is more for the GHC mailing list
03:07:18 <bitonic> merijn: I have a legitimate use
03:07:20 <bitonic> that’s a contrived case
03:07:26 <yitz> bitonic: yes sounds like a ghc issue
03:07:52 <bitonic> actually the legitimate use is pretty neat :)
03:08:29 * bitonic is writing Agda programs and backporting them to GHC
03:08:30 <merijn> bitonic: Oh sure, just thought I'd mention it :p
03:09:15 <mjrosenb> @hoogle (a -> m (n a)) -> n a -> m (n a)
03:09:16 <lambdabot> Language.Haskell.TH.Quote dataToExpQ :: Data a => (forall b. Data b => b -> Maybe (Q Exp)) -> a -> Q Exp
03:09:16 <lambdabot> Language.Haskell.TH.Quote dataToPatQ :: Data a => (forall b. Data b => b -> Maybe (Q Pat)) -> a -> Q Pat
03:09:31 <mjrosenb> not quite
03:09:35 <merijn> mjrosenb: What would that do?
03:10:11 <merijn> I don't think that function makes sense without a Applicative m, Comonad n
03:10:27 <merijn> Or maybe Monad + Transformer m
03:10:31 <mjrosenb> merijn: I have tagFileOpen :: ByteString -> IO Maybe Tag and tagFileGetTag :: Tag -> IO Maybe TagFile
03:10:44 <mjrosenb> and I wish to chain them together.
03:10:56 <merijn> :t lift (>>=)
03:10:57 <lambdabot> (Monad m, MonadTrans t) => t ((->) (m a)) ((a -> m b) -> m b)
03:11:00 <merijn> oh, wait
03:11:01 <merijn> wrong one
03:11:06 <merijn> :t liftM2 (>>=)
03:11:07 <lambdabot> (Monad m, Monad m1) => m (m1 a) -> m (a -> m1 b) -> m (m1 b)
03:11:21 <merijn> :t liftM2 (>=>)
03:11:22 <lambdabot> (Monad m, Monad m1) => m (a -> m1 b) -> m (b -> m1 c) -> m (a -> m1 c)
03:11:23 <bitonic> yitz: thanks for the good guess anyway :P
03:11:31 <merijn> hmm, not quite
03:11:33 <supki> @unmtl MaybeT IO a
03:11:34 <lambdabot> IO (Maybe a)
03:13:18 <bitonic> yitz, merijn: aha, in my code, the forward version doesn’t work either!
03:13:42 <mjrosenb> merijn: I guess I can always use join?
03:13:48 <bitonic> I suspect that the logic behind this might be very messy.  the answer is probably in OutsideIn(X)
03:14:12 <ramses_> anyone knows how to change the "continuation prompt" in ghci when you enable multiline statements? I'd like it not to show a gazillion loaded modules
03:14:45 <bitonic> ah no, it does.  it was another problem related to equalities
03:14:46 <bitonic> well, cool
03:20:00 <mjrosenb> merijn: actually, I can't of how to get this into a form where join would help.
03:20:20 <merijn> mjrosenb: Join would only work if both monads were the same
03:20:41 <merijn> You could either lift it to be MaybeT IO a, or just write a custom combinator for this specific case
03:21:47 <mjrosenb> merijn: well, I was thinking of doing something that would end up with IO (Maybe (Maybe foo))
03:22:58 <merijn> You could join that with fmap join
03:25:11 <mjrosenb> merijn: right, but I first need to figure out how to get IO (M (M foo))
03:25:43 <mjrosenb> with fmap tagFileGetTag, I can get Maybe (IO (Maybe foo))
03:25:54 <mjrosenb> but then I need to swap the outer two
03:25:58 <ramses_> mjrosenb: use MaybeT then
03:26:02 <ramses_> :t let m = MaybeT $ (undefined :: IO (Maybe Int)) in runMaybeT $ m >> m
03:26:03 <lambdabot> Not in scope: data constructor `MaybeT'
03:26:03 <lambdabot> Not in scope: `runMaybeT'
03:26:09 <ramses_> err
03:27:01 <ramses_> that would give an IO (Maybe Int)
03:30:00 <mjrosenb> ramses_: would I want MaybeT . liftM tagFileGetTag ?
03:30:29 <mjrosenb> err
03:30:30 <mjrosenb> no
03:30:39 <mjrosenb> MaybeT is backwards from what I want.
03:31:05 <ramses_> mjrosenb: no it isn't, but its tempting to be mislead into thinking it's backwards :)
03:31:59 <mjrosenb> ramses_: I have |Maybe IO foo|, MaybeT takes in |m Maybe a|
03:32:24 <ramses_> the easiest is to make your tagFileGetTag return a MaybeT IO TageFile, and then you do "\bs -> MaybeT (tagFileOpen bs) >>= tagFileGetTag"
03:33:20 <ramses_> mjrosenb: before you had "IO Maybe Tag", didn;t you?
03:33:21 <mjrosenb> ramses_: it isn't mine.
03:33:35 <ramses_> mjrosenb: then put a wrapper of your own around it
03:33:49 <mjrosenb> ramses_: I was trying (and asking about) liftM tagFileGetTag
03:34:18 <ramses_> I'm not sure what you're after anymore, sorry :)
03:34:25 <Kingofferrets> Does anyone know of a tutorial for Control.Monad.Random, by any chance?
03:35:21 <mjrosenb> :t (MaybeT $ tagFileOpen (pack "")) >>= (MaybeT . tagFileGetTag)
03:35:21 <mjrosenb> (MaybeT $ tagFileOpen (pack "")) >>= (MaybeT . tagFileGetTag) :: MaybeT IO Tag
03:35:22 <lambdabot> Not in scope: data constructor `MaybeT'
03:35:22 <lambdabot> Not in scope: `tagFileOpen'
03:35:22 <lambdabot>     Not in scope: `pack'
03:35:25 <mjrosenb> evidently
03:35:43 <mauke> :t ?I
03:35:44 <lambdabot> parse error on input `?'
03:36:20 <lhk> which gui toolkit would you recommend for haskell ?
03:36:46 <Kneiva> Kingofferrets: http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State
03:37:02 <typoclass> Kingofferrets: not sure about a tutorial, but here is some short examples http://hpaste.org/88591
03:39:43 <shachaf> preflex: seen fmazzoli
03:39:43 <preflex>  Sorry, I haven't seen fmazzoli
03:40:23 <bitonic> shachaf: that’s me
03:40:30 <bitonic> well, my name is francesco mazzoli...
03:41:15 <mauke> preflex: ? who:bitonic
03:41:15 <preflex>  factoid not found
03:41:17 <Kingofferrets> Examples are good too. Thanks!
03:41:26 <mauke> preflex: + who:bitonic Francesco Mazzoli
03:41:37 <mauke> preflex: + who:FrancescoMazzoli bitonic
03:41:41 <bitonic> preflex is tracking ussss
03:41:55 <bitonic> (btw, I’ve never used the nick fmazzoli)
03:42:05 <shachaf> I thought you were rostayob.
03:42:10 <bitonic> shachaf: that too.
03:42:27 <shachaf> Perhaps that was someone else.
03:42:34 <bitonic> that’d be an interesting coincidence :P
03:43:22 <shachaf> Anyway, pattern matching working left-to-right seems reasonable to me.
03:43:36 <bitonic> why?
03:43:45 <bitonic> In Agda/Epigram it works both ways
03:44:08 <shachaf> It gets more complicated with ⊥.
03:44:24 <shachaf> Since you have to force the GADT to learn things about the regular argument.
03:44:37 <shachaf> (Otherwise you might pass it undefined and get evil unsafeCoercey things out of it.)
03:44:45 <tomejaguar> Isn't it a consequence of what pattern matching desugars to?
03:44:50 <shachaf> Yes.
03:44:55 <bitonic> oh, right.
03:44:57 <shachaf> Some of the subtleties are discussed in http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/PAGES/057.HTM
03:45:09 <bitonic> right, I didn’t think about that
03:45:17 <Kingofferrets> Hm. those examples/tutorials seem to be for use of System.Random, rather than for http://hackage.haskell.org/packages/archive/MonadRandom/0.1.3/doc/html/Control-Monad-Random.html
03:45:20 <shachaf> You could make an argument for your specific case that it should work.
03:45:28 <shachaf> But I don't think it'd be a very strong one.
03:45:42 <bitonic> yes, for definitions.  but considering those complications I’d say it’s not worth it
03:45:51 <shachaf> definitions?
03:45:57 <supki> Kingofferrets: do you have any specific questions?
03:46:44 <bitonic> shachaf: I’m not sure what you meant regarding _|_, but I can see how the fact that it desugars into cascading ‘case’s causes problems, since you gain type equalities as you match
03:47:39 <Kingofferrets> Not yet. If there's no general overview available, I'll start trying to parse through it just using the documentation, and then I'll end up having questions while I'm trying to do that.
03:47:43 <shachaf> bitonic: Well, the reason it matters is ⊥.
03:47:45 <Kingofferrets> @supki
03:47:46 <lambdabot> Unknown command, try @list
03:48:08 <bitonic> shachaf: the reason the desugaring is like that?
03:48:16 <shachaf> bitonic: You can pass in (undefined :: Foo).
03:48:21 <Kingofferrets> ...oh, @ does bot things. <.<
03:48:39 <shachaf> bitonic: Then the thing on the left doesn't actually have to be a Maybe.
03:48:47 <shachaf> bitonic: So matching on it for Just and Nothing is invalid.
03:49:34 <bitonic> shachaf: well, I’d say pattern matching like that has a point regardless of bottom, but yes
03:49:42 <typoclass> Kingofferrets: urgh, sorry :-) it is indeed for System.Random. i mixed it up
03:49:49 <shachaf> bitonic: ?
03:50:17 <Kingofferrets> Typoclass: Not a problem. Mistakes happen.
03:50:49 <bitonic> shachaf: the fact that you cascade the matches makes it simpler
03:53:37 <shachaf> bitonic: How would you desugar your code?
03:56:05 <bitonic> shachaf: if there was a notion of top-level, matching definition (like in Agda/Idris/Epigram), you could treat all the matches and change its semantics, so that if you need the equality you force the argument.  again I’m not sure you’d want that, as you said
03:56:14 <bitonic> *treat all the matches at once
03:58:30 <bitonic> in fact in those languages it’s the other way around, every match gets desugared to a top-level definition
03:58:55 <bitonic> for this reason—you want to be able to constraint things as you match others
04:01:00 <bitonic> this also makes me realise why it’d be hard to add dependent pattern matching to Coq...
04:13:04 <shachaf> This is an error: let foo :: Is a (Int -> Int) -> Int -> a; foo Refl x y = x + y
04:13:46 <shachaf> Actually, it has to be one, I think...
04:13:48 <bitonic> well that would be an error in Agda too, wouldn’t it?
04:14:00 <bitonic> ah, the second argument
04:15:49 <bitonic> shachaf: well yes that would be an error
04:16:19 <bitonic> foo : {A : Set} → A ≡ (ℕ -> ℕ) -> ℕ -> A; foo refl n = λ m → n + m
04:16:21 <shachaf> Not an error if you eta-move the argument to the other side.
04:16:23 <bitonic> this is fine
04:16:24 <bitonic> yes
04:17:23 <supki> why does that make a difference?
04:18:10 <bitonic> supki: if you want to have nice pattern matching with GADTs/inductive families or stuff like this, you need a notion of top-level definition with arguments
04:18:21 <bitonic> and that top-level definition has two arguments
04:20:56 <jmcarthur> i still don't understand why that's an error
04:21:14 <jmcarthur> oh wait, now i'm realizing
04:21:25 <jmcarthur> hmm
04:21:37 <bitonic> jmcarthur: you generate equalities as you match the arguments
04:21:56 <jmcarthur> right
04:25:22 <jmcarthur> trying to write it in ocaml with its locally abstract type syntax proved to be a failure. i think it is inexpressible that way without moving the last argument to the right side. interesting.
04:25:46 <bitonic> jmcarthur: OCaml has type equalities and coercions?
04:25:49 <jmcarthur> let foo (type a) (Refl : (a, int -> int) equal) (x : int) : a = fun y -> x + y
04:25:54 <jmcarthur> bitonic: as of ocaml 4
04:26:15 <jmcarthur> it has GADTs
04:26:35 <bitonic> well, if you have equalities you can express GADTs.  cool
04:26:41 <jmcarthur> right
04:26:45 <bitonic> does it have explicit coercions?
04:26:46 <jmcarthur> well, equalities and existentials
04:26:54 <bitonic> right
04:26:59 <jmcarthur> what is it that you mean by explicit coercions?
04:27:25 <bitonic> jmcarthur: can the user like take a constraint as an argument and explicitly coerce another?  or is it all automagic like in GHC?
04:27:41 <bitonic> well I guess in GHC you can just write a function that does that
04:27:58 <bitonic> but the proof of equality will be automatically chosen
04:28:10 <jmcarthur> you mean like GHC's (~) but with explicit application?
04:28:12 <bitonic> I was wondering if in OCaml equalities and coercions were more first class
04:28:24 <bitonic> jmcarthur: yeah
04:28:31 <jmcarthur> i wouldn't say it's quite like that
04:28:43 <jmcarthur> however, locally abstract types make *some* of it more explicit
04:30:16 <bitonic> jmcarthur: so it’s this <http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual021.html#toc80> right?
04:30:59 <jmcarthur> yeah, combined with http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual021.html#toc85
04:31:29 <neutrino> jmcarthur: is ocaml more similar to haskell or scalaz?
04:32:02 <jmcarthur> neutrino: i don't really know scala enough to say
04:32:32 <jmcarthur> neutrino: ocaml does feel quite different from haskell to me after having used it for a while now
04:33:07 <jmcarthur> mostly i feel kind of crippled in it, but then i go to haskell and realize now i'm missing a lot of features i got used to in ocaml
04:33:27 <typoclass> jmcarthur: interesting! which ones are missing in haskell?
04:34:00 <jmcarthur> typoclass: the big one is a decent module system
04:34:16 <bitonic> yeah
04:34:21 <typoclass> jmcarthur: hm ... ok
04:34:25 <bitonic> that’s something of SML that I envy
04:34:30 <jmcarthur> typoclass: polymorphic variants, labelled arguments, "row types" (ocaml calls them objects and adds a bunch of extra crap) follow
04:34:42 <bitonic> although typeclasses *and* modules would be weird probably
04:35:06 <jmcarthur> bitonic: i still hold out hope that there could be some way of unifying them
04:35:09 <typoclass> jmcarthur: ok i can see how labelled arguments are occasionally useful. and row types sound neat
04:35:15 * typoclass googles polymorphic variants
04:35:35 <jmcarthur> bitonic: for example, it would be nice to be able to put local definitions in an instance that are hidden by the type class's "signature" (class declaration)
04:36:04 <jmcarthur> not the same as real modules though
04:36:14 <jmcarthur> the whole ByteString situation, for example... :(
04:37:27 <jmcarthur> i actually *don't* miss ocaml's record syntax, even though it is a bit more traditional than haskell's
04:37:44 <jmcarthur> something tends to feel wrong about it
04:37:46 <jmcarthur> oh!
04:38:03 <jmcarthur> another thing ocaml has that i wish haskell had is mutable fields
04:38:10 <jmcarthur> as opposed to a field that contains an IORef
04:38:31 <Kingofferrets> ...huh.
04:38:33 <bitonic> jmcarthur: that probably wouldn’t fit Haskell nicely
04:38:35 <jmcarthur> in haskell there would be the extra complexity of having to use IO to access it
04:38:52 <jmcarthur> and i guess pattern matching would be weird
04:38:52 <neutrino> jmcarthur: what are variants? and polymorphic ones?
04:38:57 <Kingofferrets> So. I defined a function that just basically removes the first instance of an element from a list.
04:39:08 <jmcarthur> neutrino: in ocaml a "variant" type is just a sum type
04:39:30 <jmcarthur> neutrino: and a polymorphic variant is essentially an anonymous sum type. you can define the constructors locally and they appear in the type
04:39:42 <neutrino> so a sum is e.g. a tuple? or is it an either?
04:39:43 <jmcarthur> neutrino: they even have subtype relationships, although i think that is less important
04:39:51 <typoclass> neutrino: yes, Either
04:39:53 <jmcarthur> a sum is like an either
04:39:59 <neutrino> and a product like a tuple
04:39:59 <Kingofferrets> I plug stuff into ghci, and...
04:40:00 <neutrino> ok
04:40:00 <Kingofferrets> *Main> rem 3 [1,2,3,4,5,6,7]  <interactive>:46:1:     No instance for (Integral [t0])       arising from a use of `rem'     Possible fix: add an instance declaration for (Integral [t0])     In the expression: rem 3 [1, 2, 3, 4, ....]     In an equation for `it': it = rem 3 [1, 2, 3, ....]  <interactive>:46:5:     No instance for (Num [t0])       arising from the literal `3'     Possible fix: add an instance declaration for (Nu
04:40:03 <Kingofferrets> ...whoops.
04:40:08 <Kingofferrets> that was supposed to be a pastebin link
04:40:17 <Kingofferrets> http://pastebin.com/4d6g4MNm
04:40:26 <mauke> The paste 4d6g4MNm has been copied to http://sprunge.us/PDbg?haskell
04:40:31 <typoclass> Kingofferrets: hm ... the dmr maybe?
04:40:31 <neutrino> jmcarthur: scala has modules
04:40:33 <typoclass> @where dmr
04:40:33 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
04:40:36 <neutrino> and something they call "cake pattern"
04:41:31 <neutrino> which is used for swapping out implementations of stuff
04:41:36 <jmcarthur> neutrino: let foo = function `Foo x -> x | `Bar y -> string_of_int y
04:41:43 <jmcarthur> neutrino: val foo : [< `Bar of int | `Foo of string ] -> string
04:41:47 <neutrino> today you're using mysql tomorrow pg, etc
04:41:48 <Kingofferrets> aha
04:42:22 <jmcarthur> neutrino: the "<" means that the function expects some subtype of that polymorphic variant (it would happily unify that with just [ `Bar of int ] or [ `Foo of string ]
04:42:24 <jmcarthur> )
04:42:26 <Kingofferrets> I remember reading about the monomorphism restriction in Real World Haskell. Specifically, I remember reading "you shouldn't come across this, but remember it if you do". <.<
04:42:33 <Kingofferrets> Yay for coming across it. x.x
04:45:43 <typoclass> Kingofferrets: you mean, that was the solution? :set -XNoMonomorphismRestriction solved it?
04:46:13 <Kingofferrets> Trying it now.
04:46:35 <Kingofferrets> Had some trouble getting it to go. Apparently I forgot the X at the front of the flag, thanks for inadvertantly reminding me. >.>
04:46:59 <typoclass> Kingofferrets: it's all tab-completable
04:47:12 <Kingofferrets> Well, if I forget the very first character... :P
04:47:22 <typoclass> Kingofferrets: that's true :-)
04:48:28 <Kingofferrets> I got one fewer errors!
04:48:55 <byorgey> uh, that's not the MR
04:49:00 <byorgey> @type rem
04:49:01 <lambdabot> Integral a => a -> a -> a
04:49:09 <byorgey> Kingofferrets: rem has to take two arguments of the same type.
04:49:22 <Kingofferrets> ...oh! I was overloading a function without knowing it. <.<
04:49:45 <neutrino> jmcarthur: `Foo and `Bar are constructors, and they were defined before, right?
04:49:59 <jmcarthur> neutrino: no
04:50:12 <Kingofferrets> renaming my function to "removal" fixed things
04:50:16 <jmcarthur> neutrino: well, they are constructors, but they don't have to be declared first
04:50:24 <neutrino> so you can declare them like that?
04:50:33 <hpaste> “http://jonnesseo.blogspot.com/” pasted “Jasa SEO Murah Terbaik” at http://hpaste.org/90135
04:50:35 <jmcarthur> neutrino: there is no declaration. they are just used
04:50:37 <neutrino> is this part of the feature we were talking about, or is it a separate feature?
04:50:46 <jmcarthur> neutrino: this is the "big idea"
04:51:12 <elliott> @tell chrisdone <hpaste> “http://jonnesseo.blogspot.com/” pasted “Jasa SEO Murah Terbaik” at http://hpaste.org/90135
04:51:12 <lambdabot> Consider it noted.
04:51:53 <jmcarthur> neutrino: you can just use them without defining them, which is nice when you just want to return some choice of multiple types and don't find it worth defining a whole type just for that
04:52:03 <jmcarthur> neutrino: also, you don't have to export them in order for other modules to use them
04:52:09 <typoclass> elliott: i'm deleting it, i assume chrisdone can see stuff even when deleted
04:52:15 <jmcarthur> neutrino: they just propagate as types
04:52:56 <elliott> typoclass: hmm, pastes can be deleted by a single person?
04:53:37 <typoclass> elliott: i dunno :-) but whenever i click "report/delete", it goes away within minutes
04:53:47 <illissius> jmcarthur: oh, so the constructor names you choose are basically irrelevant? and it's closer to Typeable/Dynamic than to open sum types?
04:53:52 <alpounet> neutrino, these polymorphic variants are really sweet, you pretty much declare them when you use them (you can directly pattern match against them, that "declares them")
04:54:41 <jmcarthur> illissius: they are relevant in that they must agree at construction and pattern matching, due to the types
04:55:01 <illissius> hm
04:55:01 <jmcarthur> illissius: they are not like Typeable/Dynamic. those don't give you anonymous sum types like that
04:56:00 <alpounet> neutrino, see http://caml.inria.fr/pub/docs/manual-ocaml/manual006.html#toc36 for more
04:56:31 <illissius> how does that square with "you don't have to export them in order for other modules to use them"?
04:56:47 <illissius> what does a function that constructs/returns one look like?
04:57:11 <jmcarthur> let x = `Foo "foo"
04:57:24 <jmcarthur> val x : [> `Foo of string ]
04:57:49 <jmcarthur> that's just a value rather than a function, but same principle applies
04:58:41 <illissius> the constructor names are in some kind of global namespace? (hence not having to ex/import them)
04:58:58 <chrisdone_> seems like those last two spam pastes (thanks for reporting, whoever that was) were manually pasted. seems we will need the nick-must-be-in-irc-for-announce after all
04:58:59 <jmcarthur> you could say that, although there isn't really any one place that collects them
04:59:19 <mauke> the constructor names are arbitrary strings
04:59:22 <jmcarthur> also, they get different types
04:59:35 <jmcarthur> depending on how they are used
05:00:14 <jmcarthur> let x = (`Foo "foo", `Foo 5)
05:00:23 <jmcarthur> val x : [> `Foo of string ] * [> `Foo of int ]
05:01:12 <illissius> that would've been my next question
05:01:16 <illissius> think I'm starting to grok it :)
05:01:42 <jmcarthur> at compile time the constructors are symbols. at runtime they are hash codes of the original symbols
05:02:28 <jmcarthur> i am not sure if there is some compile time check for collisions, but i've never heard of a collision happening anyway
05:02:30 <typoclass> chrisdone_: hm ... i dunno. without the announce, the spam would still be on hpaste :-) wouldn't have notice it so quickly
05:02:44 <jmcarthur> oh, actually, there is such a check, i take it back
05:02:59 <jmcarthur> unfortunate for there to be such implementation details in the type checker, but it is what it is
05:03:13 <typoclass> chrisdone_: btw, how is the mechanism when i click "report/delete"? i've noticed that the paste goes away extremely fast (within 1 minute or faster)
05:03:33 <illissius> yeah, that makes sense. I've read that polymorphic variants use hashing before, but not how they actually work
05:03:56 <illissius> jmcarthur: you mean the compiler checks that different names don't accidentally hash to the same code?
05:04:08 <jmcarthur> illissius: yeah, at least when they are going to be used in the same type
05:04:11 <chrisdone_> typoclass: report/delete hides it from public view and adds it to a list of reported pastes. i get an email about the report and i go in and delete it
05:04:21 <jmcarthur> illissius: if they are never used together it makes no difference, of course
05:04:48 <jmcarthur> anyway, i gotta go
05:06:44 <chrisdone_> typoclass: some people got all serious business 'legal action' about some defamatory pastes so i made it remove immediately. most are spam but there's always some by students saying "this is homework can you please remove or i'll get in trouble" or "i am a professor and this is homework please remove"
05:06:46 <typoclass> chrisdone_: i see. well it's very efficient :-)
05:08:43 <elliott> chrisdone_: how about forbidding pastes that are just a url?
05:09:23 <mauke> s/a url/one line/
05:10:09 <typoclass> elliott: i dunno. we've had only one paste so far
05:10:31 <elliott> there is no chance it's the last one
05:12:30 * ksf thinks scc is very nice
05:12:37 <ksf> any reason why it hasn't caught on yet?
05:12:52 <ksf> is it because there's no web framework written in it?
05:14:19 <eikke> what's scc?
05:14:28 <ksf> @hackage scc
05:14:28 <lambdabot> http://hackage.haskell.org/package/scc
05:14:51 <ksf> yet another library targeting that iteratee/coroutine/pipe/conduits stuff
05:16:17 <sopvop> ksf: How is it different?
05:16:36 <ksf> it's very principled when it comes to composition. and there's only one composition operator.
05:16:47 <supki> I don't think it has any chance being gpl
05:16:54 <ksf> hmm
05:17:17 <ksf> fair point
05:17:37 <sopvop> gpl makes people eat stuff stuck to their feet. Like RMS does.
05:18:03 <ksf> gpl is fine for applications and the odd library
05:18:30 <ksf> ...not such basic ones, though.
05:18:46 <Lethalman> gpl is the reason why linux is still alive nowadays
05:19:07 <ksf> and for operating systems.
05:19:30 <ksf> when it comes to bootstrapping haskell, though, it's counter-productive.
05:20:28 <illissius> linux is more like an application than a library
05:20:51 <ksf> yep, it runs applications like plugins.
05:20:52 <illissius> (..which wouldn't be true if it didn't have the exception that applications written for it aren't derived works)
05:21:44 <ksf> they aren't one way or the other. a judge would laugh in your face if you tried to claim that using the C stdlib or syscall interface constitutes a derived work.
05:21:59 <ksf> that's like saying a trailer is a derived work of a car.
05:22:07 <eikke> a judge would most likely not have a clue what a stdlib or syscall is
05:22:10 <ksf> sure, there's fittings so they can work together, but come on.
05:22:14 <chrisdone_> elliott: done
05:22:16 <gal_bolle> with the 'chart' library, how can I associate a label (a String) with each value on the x-axis? (the x-axis represents time, and I want to label it with event descriptions rather than just dates)
05:22:47 <ksf> it's their job to learn it.
05:23:35 <ksf> this thing -- that "derivative work" is a case-by-case issue -- is also the reason why the EUPL isn't split like GPL and LGPL.
05:24:35 <elliott> chrisdone_: great :)
05:25:20 <ksf> I mean... readline is GPL. that's fine. what's not fine is the FSF claiming that just being compatible to that interface is an infringement. there's BSD implementations with the exact same interface.
05:26:16 <illissius> ksf: hm, not clear on the low-level details... with a GPL library the part that turns you into a derived work is when you link with it. for your application to run as a linux process, nothing similar has to happen?
05:26:50 <ksf> in the apple gcc (I think) case, the judge didn't give a rat's ass about linkage.
05:27:06 <ksf> apple tried to get around the GPL by linking punk.
05:27:38 <ksf> the court ruled that apple's code is *functionally* dependent on parts of gcc, and thus is a derivative work.
05:28:25 <ksf> where that line is is a case by case thing. if you can easily replace the component, it's probably not a derivative work, especially when it's a industry-standard interface.
05:29:30 <ksf> ...or minor or tangential functionality.
05:30:25 <ksf> ...or just one option among many. If e.g. apple's frontend could work with llvm, gcc and a home-brew one, the case would probably have looked different.
05:31:40 <illissius> interesting, hadn't heard of that
05:32:24 <ksf> the thing with the GPL is, though, that companies shy away from it like it's infected.
05:32:36 <ksf> well, companies that want to keep stuff closed source.
05:33:37 <ksf> judges might also consider whether you advertise with functionality provided by the gpl part and suchlike.
05:36:02 <yitz> ksf: scc looks almost exactly like what conduits and pipes looked liked in their early rough and unpolished days
05:37:15 <yitz> ksf: if it had been pushed forward in 2006 at the same speed that conduits/pipes were after they reached that stage, the world would be a very different place today
05:38:16 <typoclass> yitz: you mean, the mature scc would be essentially identical to conduit/pipes?
05:38:58 <ksf> conduit has  three fusing combinators.
05:39:15 <mauke> did you mean: confusing
05:39:26 <ksf> I did, indeed :)
05:40:19 <ksf> scc also comes with inbuilt paralellism
05:41:40 <yitz> typoclass: probably. pipes and conduits were developed independently and ended being pretty much the same. the features that scc is missing are what pushed them both to where they are now.
05:41:53 <hpaste> cutsea110 pasted “safe head/tail” at http://hpaste.org/90139
05:41:57 <typoclass> yitz: i see, thanks
05:42:15 <ksf> which features would those be?
05:43:18 <yitz> ksf: conduit has basically one combining combinator: $$. the others just make the two pieces always close at the same time.
05:44:04 * elliott wonders what scc is
05:44:15 <ksf> @hackage scc
05:44:16 <lambdabot> http://hackage.haskell.org/package/scc
05:44:38 <elliott> nice type signatures
05:44:41 <yitz> ksf: error handling and dealing with leftover streams, resumable streams, resource management (e.g. the ability to free handles at exactly the right moment)
05:45:23 <ksf> right.
05:46:44 <yitz> ksf: without the need for any special handling of any of those, pipes and conduits both boil down basically to scc.
05:47:03 <neutrino> yitz: do pipes and conduits actually use them?
05:47:15 <neutrino> use scc
05:47:21 <yitz> ksf: except with apis that are polished by a few years of extensive real-world use, and a lot of optimization
05:47:39 <eikke> a (...) operator, that's evil
05:47:54 <yitz> neutrino: no. i'm pretty sure that none of oleg, snoyberg, or Tekmo were aware of them at the time.
05:48:44 <typoclass> *snoyman
05:48:51 <neutrino> yitz: what's the new one that snap ported to just recently?
05:49:01 <yitz> typoclass: his irc nick is snoyberg :)
05:49:06 <eikke> yitz: blasphemy. Of course Oleg was aware.
05:49:19 <eikke> neutrino: io-streams?
05:49:23 <neutrino> right
05:49:25 <yitz> eikke: he never mentioned anything about scc during conversations at that time
05:49:32 <neutrino> is that similar to pipes or conduits?
05:49:35 <neutrino> or scc?
05:49:46 <typoclass> yitz: oh you're right. also his github name. never noticed that before :-)
05:50:00 <eikke> yitz: it was a joke
05:50:31 <yitz> io-streams re-invents something that simon marlow was working on a few years earlier as a replacement for the current IO handles
05:50:57 <neutrino> how is it different from pipes/streams/scc?
05:51:17 <yitz> but it's hard to define exactly what the semantics should be in many cases. so he abandonned that approach. i'm not sure if io-streams has solved any of those problems.
05:51:25 <yitz> eikke: ok :)
05:52:16 <yitz> eikke: but in reality he could have known about them - and if he had, a lot would have happened years earlier.
05:53:00 <yitz> eikke: of course he also could of thought of them :) however, they don't involve CPS, or mind-bending type system extensions, so...
05:53:13 <eikke> too much engineering
05:54:24 <typoclass> i thought oleg came up with iteratees? being the precursor for the packages iteratee, enumerator, conduit, pipes
05:54:53 <yitz> typoclass: yes iteratees/enumerators were the predecessor of conduits and pipes
05:55:33 <typoclass> yitz: and, and weren't they in turn spawned by that one article on okmij.org? /me has no clue
05:55:58 <typoclass> i.e. http://okmij.org/ftp/Streams.html
05:56:05 <yitz> typoclass: well, that's where oleg published the basic ideas, yes.
05:56:26 <typoclass> right
05:56:34 <eikke> there's quite some difference between the original iteratee stuff & conduits/pipes nowadays
05:57:14 <yitz> eikke: the motivation was to make it more practical by getting rid of the CPS (which turned out not to be necessary) and simplify the types
05:57:39 <yitz> eikke: that got them to what we now see was pretty much what scc was years early, but no one noticed that.
05:58:38 <yitz> eikke: then came all the resource management/error handling stuff to make it practical. all that could be done manually in iteratees, but it was a pain in the neck.
05:59:29 <eikke> yitz: I'm aware, been following the field since the beginning ;)
05:59:59 <yitz> ok. yeah, it's a very important maturing process for haskell, imho.
06:00:01 <eikke> the Oleg stuff had some support for random access IO, conduits aren''t very suitable there (dunno about pipes, maybe the 'upstream' channels could be used there)
06:00:16 * typoclass mumbles soviet russia, fields follow oleg
06:01:58 <yitz> eikke: ResourceT is also great for random access. conduits, whose whole purpose is streams, is built on top of ResourceT.
06:02:07 <yitz> for example
06:02:15 <elliott> yitz: I remember, when pipes first came out, recognising it as precisely a design I had come up with when fiddling about with this stuff, and rejected because it couldn't handle putting back input
06:02:30 <eikke> yitz: huh? why would resourcet help with random IO?
06:05:27 <yitz> eikke: oh. which problem are you trying to solve then? you can do random access with just IO too.
06:06:41 <yitz> elliott: yes putting back input was one of the early problems with pipes. Tekmo never gives up.
06:06:50 <eikke> yitz: say you got a Source which reads data out of some file (Fd), then in a Conduit or Sink connected to that Source you want to say "now jump to offset N and next time I request some data, read from there"
06:07:09 <eikke> yitz: you could run seek on the Fd within the Sink if it has access to it, but that feels ugly
06:07:37 <yitz> eikke: oh you mean repositionable streams? i see.
06:09:38 <eikke> yes
06:09:57 <eikke> I think there might be some possibility with pipes to get that done
06:17:57 <yitz> eikke: i very much doubt that between conduits and pipes there is anything that one can do and the other can't. it's just a question of what features have been worked on and polished.
06:18:48 <hamid> :t (,,,,,,,)
06:18:50 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> (a, b, c, d, e, f, g, h)
06:19:17 <hamid> it seems to me that there is generator behind this tuples
06:19:23 <hamid> these*
06:19:29 <hamid> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,)
06:19:32 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r,
06:19:32 <lambdabot> s, t, u, v, w, x, y, z, t28, t29)
06:21:13 <merijn> hamid: I think they're generated by template haskell, they're hard coded, though
06:21:24 <yitz> hamid: they used to be all hard-coded, believe it or not. never heard of that changing.
06:21:25 <merijn> hamid: I believe GHC goes up to a maximum of 63 entries?
06:22:05 <hamid> hmm guessed right
06:22:14 <elliott> err, no TH involved at all AFAIK
06:22:22 <elliott> seriously doubt TH would even work without tuples :P
06:22:36 <elliott> yitz: they're not... strcitly hard-coded
06:22:39 <elliott> :t works with any number of ,s
06:22:40 <lambdabot> parse error on input `of'
06:22:49 <elliott> but you can't actually use ones bigger than 60-whatever
06:23:04 <acube> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
06:23:05 <lambdabot>     A 181-tuple is too large for GHC
06:23:05 <lambdabot>       (max size is 62)
06:23:05 <lambdabot>       Workaround: use nested tuples or define a data type
06:23:06 <quicksilver> elliott: can't use them in what way?
06:23:51 * hackagebot hint-server 1.2.2 - A server process that runs hint.  http://hackage.haskell.org/package/hint-server-1.2.2 (CorentinDupont)
06:24:03 <quicksilver> oh yes
06:24:05 * quicksilver tried it :)
06:24:08 <yitz> @. type run text $ concat ["(", replicate 61 ',', ")"]
06:24:10 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 ->
06:24:10 <lambdabot>  t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> (a, b, c, d, e,
06:24:10 <lambdabot> f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54,
06:24:10 <lambdabot> t55, t56, t57, t58, t59, t60, t61, t62, t63)
06:24:15 <yitz> @. type run text $ concat ["(", replicate 62 ',', ")"]
06:24:16 <lambdabot>     A 63-tuple is too large for GHC
06:24:17 <lambdabot>       (max size is 62)
06:24:17 <lambdabot>       Workaround: use nested tuples or define a data type
06:24:23 <quicksilver> weird that :t permits it though.
06:24:28 <elliott> hm
06:24:38 <elliott> I guess someone added an error recently then
06:24:43 <elliott> because :t (a billion ,s) used to work
06:24:50 <quicksilver> elliott: in GHCi it does
06:24:52 <hamid> should I just use pattern matching for getting an element of a tuple? nothing like getN n t ?
06:24:59 <elliott> quicksilver: lambdabot's :t uses ghci
06:25:02 <elliott> 7.6.3
06:25:09 <quicksilver> elliott: oh, must be version then
06:25:30 <quicksilver> I guess they thought there was no point :t working for expressions you couldn't use in code.
06:25:33 <quicksilver> which is a fair point.
06:25:51 <elliott> quicksilver: I'm just baffled that apparently the type of a tuple constructor is special-cased in this way
06:25:54 <quicksilver> hamid: if you even have to ask that question you probably shouldn't be using tuples.
06:25:59 <yitz> well, the good news for all of you who want >62 tuples is that tuples can be nested
06:25:59 <elliott> despite the constructor itself being defined in "haskell" code
06:26:13 <quicksilver> hamid: what type would you expect 'getN' to have?
06:26:19 <elliott> yitz: what if you want a 1024-tuple for a super efficient lookup table?!
06:26:22 <quicksilver> in answering that question you may find a better way.
06:26:25 <saml> "Lift a computation from the argument monad to the constructed monad. "  what does this mean?
06:26:27 <saml> http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Class.html#v:lift
06:26:28 <elliott> hamid: lens gives something fairly like "getN n t".
06:26:31 <elliott> but yes, consider not using tuples
06:26:35 <elliott> > (1,2,3,4) ^. _2
06:26:36 <lambdabot>   Not in scope: `^.'
06:26:36 <lambdabot>  Perhaps you meant one of these:
06:26:36 <lambdabot>    `.' (imported from D...
06:26:40 <elliott> ugh
06:26:44 <elliott> someone @undefined I guess
06:27:34 <eikke> saml: if you have a transformer T which you 'apply' to some underlying monad M to T(M), then 'lift' takes some action within M into T(M)
06:27:52 <saml> so lift is "convert" ?
06:27:53 <yitz> elliott: how about 32 32-tuples nested in a 32-tuple?
06:28:01 <hamid> quicksilver, I have this (e1,e2,...,e9) I don't want to go with lists
06:28:06 <neutrino> saml: "argument" is on the left (m a), "constructed" is on the right (t m a)
06:28:06 <elliott> yitz: but, but, the runtime indirection!
06:28:08 <saml> lift is different from "lift" in liftM right?
06:28:10 <elliott> hamid: define a data type
06:28:12 <eikke> saml: lift is 'lift an action from an underlying monad to the monad instance higher in the stack'
06:28:16 <merijn> hamid: Why not use an Array?
06:28:23 <merijn> hamid: Those can go to arbitrary size
06:28:23 <elliott> hamid: you'll thank me and thank yourself later
06:28:34 <quicksilver> hamid: why don't you want to go with lists? I need to understand *why* you're making the wrong decision so I can help you make the right one.
06:28:34 <eikke> saml: liftM takes a pure function 'into the monad'
06:28:36 <hamid> elliott, I did :P
06:28:40 <eikke> (with lots of hand-waving)
06:28:49 <merijn> elliott: Well, I could imagine Array being a valid alternative, depending on what he's doing
06:28:52 <saml> so taht lift is differnt from transformer lift
06:29:01 <eikke> saml: so where liftM takes a pure function into monad M, lift takes a monadic action from monad M into monad T(M)
06:29:11 <merijn> saml: liftM == fmap (assuming your Monad is a Functor, like it should)
06:29:14 <saml> you lift the outer skin and do something inside (in liftM)
06:29:33 <saml> transformer lift is conversion
06:29:34 <neutrino> is there something like fmap that corresponds to lift?
06:29:46 <merijn> neutrino: fmap!
06:29:50 <hamid> quicksilver, hmm I didn't want to use recursive or pattern matching cause it gets bloated :/ so I guess merijn is right. Array is the right choice.
06:29:57 <eikke> saml: there's no conversion. liftM and lift are pretty close in a way
06:29:58 <neutrino> merijn: fmap corresponds to liftm.
06:29:59 <merijn> neutrino: If your transformer is a monad, then it must also be a functor ;)
06:30:03 <neutrino> or is it ok still?
06:30:05 <neutrino> i guess.
06:30:17 <elliott> merijn: fixed element arrays are a bit of a shame what with the partiality. 9 is a pretty small size
06:30:40 <merijn> elliott: I wished upon a fairy for non-partial array functions
06:30:46 <merijn> The fairy told me to use Agda :(
06:30:50 <yitz> hamid: almost every use of Array I have ever seen has been in my opinion a premature optimization
06:30:52 <neutrino> <bad joke> lift is like taking the ground meat out of the taco, putting it on a piece of salad, and wrapping it around the meat again </>
06:31:03 <hamid> quicksilver, data E = ... ; data G = ( E1,..,E9)
06:31:09 <merijn> yitz: How so? If you need random access...
06:31:15 <neutrino> er, putting the taco. wow i killed it.
06:31:23 <quicksilver> I would use a list and see how it goes
06:31:26 <yitz> merijn: Data.Sequence, or Data.IntMap, for example
06:31:31 <eikke> neutrino: you shouldn't kill tacos
06:31:31 <saml> lift :: Monad m => m a -> t m a      looks like wrapping up with t.        liftM :: Monad m => (a1 -> r) -> m a1 -> m r    looks like operating under the wrap
06:31:36 <quicksilver> and replace it with something else when you've identified it as a bottleneck.
06:31:50 <merijn> yitz: I frequently use Array with (Int, Int) to model game boards
06:32:01 <yitz> merijn: even those are often premature. !! is faster than you think for most things. very fast in fact.
06:32:04 <saml> t m a  is  (t m) a ,  not t (m a) ?
06:32:18 <sipa> (t m) a
06:32:22 <yitz> merijn: i use [[a]] for that
06:32:23 <merijn> yitz: !! might be fast, but updating based on !! repeatedly is not
06:32:25 <saml> ah then it's not wrapping up
06:32:27 <eikke> saml: liftM is 'bring pure computation inside the monadic context to run against a monadic value' (sorta)
06:32:40 <yitz> merijn: quite fast actually
06:32:40 <hamid> yitz, this can be but I really need accessing the elements of container :P
06:33:02 <yitz> @type (!!) -- hamid
06:33:03 <lambdabot> [a] -> Int -> a
06:33:23 <merijn> yitz: I still think the Array (Int, Int) approach is better, it removes the possibility of accidentally have the wrong size/shape board and is conceptually clearer
06:33:25 <eikke> > [] !! 2
06:33:27 <lambdabot>   *Exception: Prelude.(!!): index too large
06:33:31 <hamid> yitz, yes and replacing one with another
06:33:38 <yitz> except !! is a partial function, of course, so most often i actually use something equivalent but safer
06:33:50 <merijn> yitz: Like?
06:33:51 * hackagebot eprocess 1.5.2 - *Very* basic Erlang-like process support for Haskell  http://hackage.haskell.org/package/eprocess-1.5.2 (CorentinDupont)
06:34:13 <eikke> Erlang-like process support... like distributed-process?
06:34:25 <yitz> merijn: i think Array is conceptually muddled. it's modeling physical computer memory, rather than just representing the concept you need.
06:34:40 <merijn> yitz: How is it moddeling physical computer memory?
06:35:20 <merijn> Multidimensial arrays are a pretty good way of modeling...well...multidimensional arrays, like chess boards
06:35:44 <yitz> merijn: Array (Int, Int) does not prevent you from having the wrong size board. What you really want is fixed-length vectors with type-level natural number bounds.
06:35:55 <merijn> yitz: Sure, hence my earlier remark
06:35:57 <eikke> newtype Chessboard = CB Piece Piece Piece Piece Piece Piece (etc...)
06:36:08 <merijn> About the Fairy telling me to use Agda
06:36:16 <saml> so, can I say,    "Convert" computation from argument monad to the constructed monad?
06:36:22 <saml> instead of "Lift"
06:36:27 <yitz> merijn: yes and while loops are a pretty good way of processing them. but in a functional language, there are more natural options.
06:36:30 <merijn> Until we get a better DT language Array seems significantly better than [[a]] for a board
06:36:43 <eikke> saml: it's not really a conversion because the underlying thing isn't changed a bit :)
06:36:59 <saml> maybe it's my english. lift has meaning of carrying something up to me
06:37:25 <eikke> saml: that's exactly what happens
06:37:45 <yitz> saml: yes it means that. it is a metaphor that was already massively abused in mathematics before it made its way into haskell.
06:37:59 <merijn> [[a]] is something very different from Array (Int, Int) and I disagree with your fundamental premises that 1) [[a]] is conceptually clearer (lists can be ragged, a basic array initialised as empty squares won't have that issue) 2) nicer, I don't see why [[a]] is better than Array (Int, Int)
06:38:02 <fizbin> What about Vector (Vector Piece)
06:38:06 <saml> ah i see. i'll search about lift in math context
06:38:17 <eikke> saml: e.g. 'putStrLn' works in IO. If you want to use it inside some transformer on top of IO, say ReaderT IO, then you 'lift' the 'IO' putStrLn into 'ReaderT IO'
06:38:45 <eikke> saml: so you take putStrLn from the 'base' monad and 'lift' it inside a 'higher on the stack' monad ReaderT IO
06:38:51 <merijn> You keep saying there's more natural options, but you haven't named one yet, [[a]] is just a susceptible to out of bound issues as Array (Int, Int), infact, I would argue [[a]] is *more* prone to boundary bugs
06:39:11 <neutrino> does either yesod or snap allow to define several services which can be either talked to via http or they can talk to eachother via normal function calls when they're inside the same binary?
06:39:13 <yitz> merijn: to get a fixed-size rotation-invariant board, sometimes i build a graph representing the board using tying the knot
06:39:25 <neutrino> somethin akin to actors
06:39:33 <merijn> yitz: And you would say that's *simpler* than Array? You're joking...
06:39:48 <yitz> merijn: no i wouldn't say that :)
06:39:52 <yitz> merijn: but it's cool
06:40:16 <yitz> merijn: the problem is that for mutable state, you then need to label the nodes and use a map
06:40:52 <merijn> yitz: Maybe, but telling me Array (Int, Int) is premature because there's cleaner options and then mentioning a "graph fixed by tying the knot" is ridiculous
06:41:11 <saml> http://upload.wikimedia.org/wikipedia/en/2/2f/Lifting_diagram.png   lifting f to Z is h where   f = (g . h)
06:41:19 <yitz> merijn: (or an array, but no, that's a last resort, only if deep optimization issues force me to hard-code the physical hardware of the computer in my program like that)
06:41:44 <saml> f = putStrLn. X = IO.  ReaderT = Z. h = lift.
06:42:00 <merijn> How do arrays "hardcode the physical hardware of the computer in my program"?
06:42:08 <saml> i'm more confused
06:42:12 <yitz> merijn: the simplest is [[a]], followed by Sequence and Map.
06:42:21 <merijn> There's absolutely *nothing* tying arrays to physical hardware
06:42:33 <saml> is there a good practice work book that lets me grow intuition about all this?
06:42:55 <saml> thinking through terse definitions in my head doesn't help
06:42:56 <yitz> merijn: an array is a representation of physical memory locations. containing pointers, or for a UArray, containing other primitive types.
06:43:08 <merijn> saml: "lifting" is just a general word used to describe "moving something from one level to another", it has no specific technical meaning
06:43:42 <merijn> yitz: How so? How does anything but a one dimensional array represent real memory? And even 1 dimensional arrays represent real memory in a trivial sense
06:44:03 <merijn> Nothing in Array mentions pointers or even specifically represent pointers
06:44:17 <merijn> How are arrays at all different from a minimalist matrix implementation?
06:44:30 <yitz> merijn: it seems natural if you are accustomed to that hardware-influenced data representation in other languages. but if you step back, it looks pretty awkward as a pure data representation for most things.
06:44:36 <eikke> saml: one moment, will look for a link
06:44:47 <merijn> yitz: Did you never work with matrices are anything?
06:45:03 <eikke> saml: http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
06:45:04 <hodapp> Isn't "a representation of physical memory locations containing pointers" a definition of pretty much any data structure, at an implementation level?
06:45:04 <merijn> s/are/or
06:45:07 <yitz> merijn: anyway, that's my own opinion. i'll still enjoy reading your code if you use them :)
06:45:19 <saml> so lift in liftM is different lift. what's etymology of liftM?  it looks to me   lift + M where M is monad.  + can mean "of" as in "lift of Monad"
06:45:35 <merijn> saml: That's exactly the etymology of liftM
06:45:38 <eikke> saml: no, liftM is 'lift pure computation inside a monad'
06:46:05 <saml> ah that now makes sense
06:46:17 <saml> object of being lifted is pure function!
06:46:28 <eikke> saml: see that link I sent. It explains transformers pretty well, and that should make 'lift' more obvious
06:46:30 <yitz> merijn: for real matrix work, you're anyway going to use LAPACK or whatever.
06:46:58 <saml> oh i read that tutorial a long time ago..and I thought lift was lifting inside values up one layer
06:47:01 <yitz> merijn: by the way, if you are anyway going to use an Array, then why not Vector?
06:47:23 <saml> but now i get you can lift functions into one layer down
06:47:46 <yitz> merijn: for simple matrix work, i see no advantage to arrays (or vectors). unless, as i said, you need that for optimization reasons.
06:48:27 <yitz> > transpose [[1,2,3],[4,5,6],[7,8,9]]
06:48:28 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
06:49:03 <merijn> > transpose [[1,2,3],[4,5,6],[7,8]] -- whoops
06:49:04 <lambdabot>   [[1,4,7],[2,5,8],[3,6]]
06:49:20 <yitz> see? it still works, even with uneven row sizes
06:49:24 <elliott> Array i a is just a function i -> a defined over a limited range of i.
06:49:30 <eikke> saml: it's the other way around, lift lifts an action from a layer down to the current layer
06:49:45 <eikke> :t lift putStrLn
06:49:46 <lambdabot> MonadTrans t => t ((->) String) (IO ())
06:49:51 <eikke> err
06:49:51 <merijn> Anyway, the rest of this discussion is boring and I need to go back to wrestling with, ironically, matrices >.>
06:49:56 <eikke> :t lift (putStrLn "abc")
06:49:57 <lambdabot> MonadTrans t => t IO ()
06:50:04 <yitz> elliott: so is (xs !!)
06:50:06 <eikke> :t putStrLn "abc"
06:50:07 <lambdabot> IO ()
06:50:16 <yitz> hehe
06:50:54 <elliott> yitz: ok, but say i want i to be (Int,Int). because i am working with two-dimensional data. because i want to represent the semantic domain more accurately
06:50:55 <merijn> yitz: Except you need to nest that to deal with multiple indices
06:50:57 <eikke> saml: see? 'lift' takes 'putStrLn "abc"' (with type IO ()) into 't' (which is some transformer) so 'lift $ putStrLn "abc"' has type 't (IO ())'
06:51:13 <eikke> err, 't IO ()' :P
06:51:14 <Cale> uh
06:51:16 <Cale> yeah
06:51:23 <elliott> yitz: so i use Array (Int,Int) Int and think about it as a partial function (Int,Int) -> Int only defined on a certain range.
06:51:25 <Cale> It's (t IO) () really :)
06:51:26 <yitz> @pl \i j -> xs !! i !! j
06:51:26 <lambdabot> (!!) . (xs !!)
06:51:32 <eikke> Cale: yup, my bad
06:53:07 <yitz> elliott: Map (Int,Int) a
06:54:15 <elliott> yitz: ah, but Array (Int,Int) a is even better than Map (Int,Int) a, semantically.
06:54:20 <yitz> elliott: i don't think Array (or Vector) are a better semantic match. they are faster and use less memory though, when that is needed.
06:54:26 <elliott> yitz: it tells me that the function it models is defined on a *contiguous* range of (Int,Int)s.
06:54:41 <elliott> Map (Int,Int) a can be sparse; it can have holes in it. this matches what I am modelling less accurately
06:55:06 <yitz> elliott: no, it tells you that the *memory* they are stored in is a contiguous range.
06:55:15 <elliott> no. no no no. not thinking about the memory at all
06:55:30 <saml> oh lift is a higher order function.  it gives me h  (when applied to f)  in this diagram http://upload.wikimedia.org/wikipedia/en/2/2f/Lifting_diagram.png
06:55:35 <elliott> yitz: I know that if my array has values at (0,0) and (100,100), then it also has a value at (50,50).
06:55:40 <elliott> this is not the case for Map
06:55:46 <elliott> ^ not a statement about memory in the slightest
06:55:59 <elliott> IIRC the Report defines a reference implementation of Array in terms of functions?
06:57:05 <yitz> no, in either case, you are defining a partial function, and will need run-time checks to avoid errors. neither type semantically represents what you want
06:57:52 <gspr> yitz: I think what he's saying is that the run-time checks for Array involve checking bounds, while the run-time checks for Map also need to check for existence even when in the given range
06:57:59 <elliott> huh? that's like saying Integer doesn't represent anything because it might be 3 or -123 at runtime. how do you know I'm not working with dynamically-sized data?
06:58:11 <elliott> gspr: I am not making any statement about operational behaviour
06:58:45 <gspr> elliott: OK, sorry.
06:58:45 <elliott> quite deliberately. my claim is that though you may pick Map vs. Array based on operational concerns, Array has a perfectly fine semantics unrelated to computer memory, and that it's as valid as Map
06:59:11 <yitz> gspr: in any case, it is not a good semantic representation.
06:59:54 <elliott> (I usually go for (Hash)Map first myself, because Array's API has some annoying flaws, in fact)
07:00:22 <yitz> elliott: Integer does represent something if what you want is Integer. If you want a limited version, you need to construct a different type. right now, those kinds of things are still awkward in Haskell.
07:00:55 <elliott> yitz: sure Array is not "semantically perfect" for representing a fixed-size chess board. neither is Map. that does not mean Array is never semantically perfect
07:01:12 <elliott> or that somehow Map is semantically better for a fixed-size chessboard when it is in fact less precise in basically every way
07:02:55 <prophile> there are 6 different chess pieces and 2 sides, so 13 different states for a square including empty
07:02:57 <nooodl> elliott: what's wrong with Array for a fixed-size chess board?
07:03:01 <prophile> that fits in 4 bits
07:03:12 <prophile> clearly, an Integer is the ideal storage mechanism :D
07:03:32 <elliott> nooodl: doesn't enforce the bounds
07:04:23 <prophile> or for an actually sensible semantic mapping, an 8-tuple of files, each of which is an 8-tuple of cells
07:04:53 <tromp_> 12 Word64 is perfect (bitboards)
07:05:02 <nooodl> elliott: what if you define your own row/column data types instead of using (Int,Int)
07:06:00 <yitz> instance Bits Chessboard where ...
07:06:06 <Sculptor> yo
07:06:29 <elliott> nooodl: well, you can still give too small bounds at creation time. but yes that works better
07:11:11 <nooodl> best solution: 64-tuple of Squares
07:11:44 <elliott> unfortunately tuples stop at 63!
07:15:47 <nexx> elliott is that defined by Haskell or is it just the (GHC) implementation?
07:15:58 <nooodl> > (1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)
07:16:00 <lambdabot>   A 63-tuple is too large for GHC
07:16:00 <lambdabot>    (max size is 62)
07:16:00 <lambdabot>    Workaround: use nest...
07:16:04 <elliott> I think the Report guarantees some number of tuples. maybe 62.
07:16:33 <nooodl> the workaround mentioned is "use nested tuples or define a data type"
07:16:47 <nooodl> i really love how it recommends using nested tuples to solve your "63-tuple" issue
07:25:08 <zuserm> Does anyone know why (<|>) from Control.Applicative is infixl rather than infixr?
07:27:08 <Taneb> Does it make a difference? It has to be associative
07:28:17 <byorgey> it could make an operational difference, but it is not supposed to make a semantic difference.
07:32:42 <t7> how do people do version control with databases?
07:32:46 <t7> snapshots?
07:34:05 <Botje> version control the schema and dump everything periodically, yes
07:34:37 <Botje> if you need to switch between schemas, supply migrations
07:34:38 <ksf> ok, I agree, pipes is nicer.
07:35:10 <zuserm> infixr seams more natural, because it will take the leftmost non-empty value, so if the first value is non-empty you have to resolve an entire chain of them if it's infixl, but you could short-circuit if it was infixr
07:35:19 <zuserm> right?
07:35:56 <ksf> that's not what infix is about.
07:36:06 <byorgey> zuserm: well, that depends entirely on the implementation of <|>.
07:36:09 <bor0> @src foldl
07:36:10 <lambdabot> foldl f z []     = z
07:36:10 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:36:12 <ksf> it's only about how operators are parsed into parenthesis.
07:36:15 <byorgey> zuserm: also, the left-biasedness is not required.
07:36:37 <elliott> there are lots of things that are infixl for seemingly no good reason. I think infixr goes better with Haskell
07:36:47 <byorgey> though many common instances of <|> do have some sort of left bias.
07:36:59 <ksf> oh. *that*'s one thing one can take away from the scc framework: distinguish between biased and unbiased choice with a newtype wrapper.
07:37:09 <ksf> phantom type, actually.
07:37:48 <byorgey> zuserm: however, I don't know why <|> is infixl.  You may in fact have a good point.  But you'd really have to study existing instances of Alternative and see how the fixity of <|> would affect things.
07:37:48 <ksf> leftbiased :: Parser LeftBiased a -> Parser t a
07:38:11 <byorgey> ah, cool idea
07:38:35 <zuserm> mm
07:38:44 <ksf> the whole factorial monoid stuff for parsing is also nice
07:39:17 <zuserm> factorial monoid?
07:39:29 <ksf> monoids that can be taken apart into their factors.
07:39:42 <ksf> singleton lists for lists, prime factors for products, etc.
07:40:22 <ksf> http://hackage.haskell.org/package/monoid-subclasses-0.2
07:40:58 <zuserm> a factorial monoid for parsing would let you inspect the structure of the parser after you construct it?
07:41:55 <ksf> nah, the point is that it's the only restriction on the input type.
07:42:21 <zuserm> ah
07:51:11 <Breadmonster> Is it possible to extend Haskell's grammar?
07:51:22 <Breadmonster> Like to insert my own syntactic sugar?
07:52:09 <ksf> Breadmonster, kindof.
07:52:38 <bor0> @src $
07:52:38 <lambdabot> f $ x = f x
07:52:48 <nimish> Breadmonster: you can use Template Haskell but there be monsters
07:52:49 <ksf> there's three possibilities: type and value-level hackery (haskell is *flexible*), quasiquotations and CPP macros.
07:52:52 <ion> If TH isn’t enough, you have some choices. Modify GHC, (add a GHC plugin? i don’t know anything about them), use a source code preprocessor of your own. Something else, too?
07:53:13 <ksf> DO NOT UNDER ANY CIRCUMSTANCE USE CPP
07:53:14 <Breadmonster> nimish: Monsters?
07:53:19 <bor0> why doesn't this compile: (q) :: (a -> b) -> a -> b ; f q x = f x but if I change q with $ it will compile
07:53:38 <ion> ksf: It’s appropriate for some (not many) things.
07:53:42 <Breadmonster> bor0: f `q` x = f x
07:53:44 <ksf> bor0, because $ is a symbol and thus an operator and thus works infix.
07:53:48 <nimish> Breadmonster: TH is not particularly well documented, only GHC supports it and you can't cross compile with it
07:53:57 <bor0> I also tried f `q` x, doesn't work
07:54:00 <Breadmonster> nimish: Alright.
07:54:13 <ion> bor0: Post your complete code and the complete error message.
07:54:28 <Breadmonster> bor0: Try q f x, and then later on use f `q` x
07:54:49 <Breadmonster> ksf: What's type and value-level hackery?
07:54:54 <hpaste> bor0 pasted “test” at http://hpaste.org/90143
07:54:56 <bor0> http://hpaste.org/90143
07:55:01 <ion> ($) a b = a $ b; q a b = a `q` b
07:55:12 <byorgey> bor0: you have to write   q ::   not  (q) ::
07:55:15 <ion> bor0: q :: …
07:55:35 <ion> bor0: Just like the error message suggests.
07:55:41 <bor0> oh, right. what is the difference if I put parentheses there? i.e. in LYAH it's defined as ($) :: ...
07:56:03 <Breadmonster> bor0: Parens around an operators.
07:56:09 <Breadmonster> *operator
07:56:15 <Breadmonster> No parens around functions.
07:56:37 <bor0> okay, so () defines an operator. what operators are free to define for ourselves in haskell?
07:56:37 <byorgey> operators are made of punctuation.  non-operators are made of alphanumerics.
07:56:43 <Breadmonster> ion: So let's say I want to rename [] to something like [:]
07:56:56 <Breadmonster> ion: How would I do that?
07:57:00 <byorgey> bor0: http://stackoverflow.com/questions/10548170/what-characters-are-permitted-for-haskell-operators
07:57:07 <Breadmonster> nimish ksf: You too.
07:57:15 <ion> bor0: You can use ($) whereever you can use q syntactically and vice versa. You can use `q` whereever you can use $ syntactically and vice versa.
07:58:14 <bor0> okay, thanks :)
07:58:16 <nimish> Breadmonster: I think [] is handled specially in the grammar but i could be wrong
07:58:41 <byorgey> Breadmonster: the only way to do that would be to do something like hack GHC or write a preprocessor.
07:59:27 <Breadmonster> DAMN.
07:59:28 <Breadmonster> WHY.
07:59:38 <Breadmonster> Is there ANY way I can do something?
07:59:44 <Breadmonster> Perhaps use TH?
07:59:52 <Breadmonster> Or whatever ksf was suggesting?
07:59:56 <byorgey> why would you want to change [] ?
08:00:01 <ion> breadmonster: What are you trying to achieve?
08:00:19 <Breadmonster> Nothing really, I was just wondering what to do.
08:00:20 <byorgey> yes, if you tell us on a higher level what you want to do perhaps we can suggest some better alternatives.
08:00:23 <nimish> yeah you could define a quasiquoter for whatever flavor of grammar you want
08:00:26 <Breadmonster> *what can be done in Haskell.
08:00:48 <Breadmonster> byorgey: I wasn't doing this for a practical purpose.
08:01:00 <Breadmonster> byorgey: Just trying to stretch the language as far as I can.
08:01:13 <byorgey> yes, a quasiquoter might be a good option.  You can use arbitrary syntax as long as you put it in side some [foo| ...  |]  brackets, and then define foo to translate your made-up syntax into Haskell.
08:01:23 <Breadmonster> What's a quasiquoter?
08:02:01 <byorgey> what I just said.  It allows you to embed arbitrary syntax into Haskell programs and specify how that syntax gets translated into Haskell code.
08:02:07 <ion> @google haskell wiki quasiquotes
08:02:09 <lambdabot> http://www.haskell.org/haskellwiki/Quasiquotation
08:02:09 <lambdabot> Title: Quasiquotation - HaskellWiki
08:02:17 <Breadmonster> How do you use one?
08:02:21 <Breadmonster> Plugin? Extension?
08:02:24 <ion> See above.
08:02:24 <Breadmonster> Built into code?
08:02:32 <osfameron> what if you want to change the syntax for using quasiquoters? ;-)
08:02:34 <nabilhassein> Hello all, I'm having a problem with type inference in Attoparsec. I'm about to hpaste the code
08:02:38 <ksf> Breadmonster, http://augustss.blogspot.de/2009/02/more-basic-not-that-anybody-should-care.html
08:02:40 <hpaste> nabilhassein pasted “Bencode” at http://hpaste.org/90144
08:02:52 <ksf> yes that's haskell :)
08:03:11 <nabilhassein> I'm trying to complete parseDictionary and for that I want to use parseHash as a helper function
08:03:16 <Breadmonster> ksf: okay, Haskell is FLEXIBLE>
08:03:20 <Breadmonster> That's more than LISP can do.
08:03:22 <Breadmonster> Wow.
08:03:36 <nabilhassein> I have warnings enabled so GHC complains that parseHash has no type annotation
08:03:47 <nabilhassein> but this is the type it infers:
08:04:09 <nabilhassein> Warning: Top-level binding with no type signature:
08:04:09 <nabilhassein>                parseHash :: Map.Map Bencode Bencode
08:04:09 <nabilhassein>                             -> attoparsec-0.10.4.0:Data.Attoparsec.Internal.Types.Parser
08:04:09 <nabilhassein>                                  BS.ByteString (Map.Map Bencode Bencode)
08:04:14 <Breadmonster> ksf: How on earth did he implement that?
08:04:27 <nabilhassein> if I try to insert that type into my program, then it won't compile
08:04:39 <elliott> nabilhassein: please use hpaste.org for pastes longer than a couple of lines :)
08:04:42 <nabilhassein> so my question is: how can I annotate the type?
08:04:47 <ion> breadmonster: Through some nasty hacks. :-P For instance, a “pretty” Num instance.
08:04:58 <ksf> Breadmonster, here's the source: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/BASIC-0.1.5.0
08:04:58 <nabilhassein> elliott: will do. Can I paste compiler errors there as well?
08:05:01 <Breadmonster> ion: Have you seen the code?
08:05:06 <elliott> nabilhassein: yep
08:05:09 <Botje> nabilhassein: it's just Map Bencode Bencode -> Parser (Map Bencode Bencode)
08:05:11 <ion> breadmonster: Haven’t looked at it.
08:05:16 <elliott> nabilhassein: I can guess what the problem is: you have multiple versions of attoparsec installed
08:05:19 <elliott> this is a big problem
08:05:29 <elliott> whenever you see GHC mention a package version you should cry :)
08:05:40 <Breadmonster> elliott: Is it that bad?
08:06:03 <nabilhassein> elliott: how can I fix that?
08:06:34 <ksf> nabilhassein, that's not an error that's a warning
08:07:01 <ksf> either provided a type signature or tell ghc not to warn you about them (which is the default)
08:07:07 <ksf> and disable -Werror
08:07:26 <ksf> anyone who releases code with -Werror should be shot.
08:08:04 <elliott> it's good practice to give a type signature to every top-level binding.
08:09:10 <ion> Yeah. Not for the benefit of the compiler, but for the benefit of any human who reads the code. The type signatures serve as very informative documentation (that happens to be checked for correctness by the compiler, too).
08:10:21 <roconnor> @botsnack
08:10:21 <lambdabot> :)
08:11:17 <nabilhassein> elliott, ion: I agree. That's why I wanted to make sure I had the type signature. But, how can I resolve the issue of having multiple versions of attoparsec installed?
08:11:36 <elliott> nabilhassein: generally the solution is to wipe your packages and start over :(
08:11:50 <elliott> there are some things you can do to mitigate the likelihood you'll run into the same problem in the future
08:12:28 <nabilhassein> elliott: like using cabal-dev or virthualenv or something along those lines?
08:13:06 <ion> nabilhassein: You might try this: ghc-pkg list | less, pick the version you want to get rid of, ghc-pkg hide attoparsec-theversion. It might help with the immediate problem.
08:13:20 <ion> YMMV
08:13:53 <nabilhassein> ion: thanks, i'll try that
08:14:00 <nabilhassein> thanks very much all, I appreciate it
08:18:42 <elliott> nabilhassein: or constraints in ~/.cabal/config
08:18:43 <neutrino> does either yesod or snap allow to define several services which can be either talked to via http or they can talk to eachother via normal function calls when they're inside the same binary? somethin akin to actors
08:19:22 <zuserm> In Haddock is there some way to link to a qualified name and also mention the qualified name in the docs without having do to write the qualification twice like: A.B.'A.B.c'
08:25:57 <t7> @check \x -> ((1 /) $ (1 /) x) == x
08:26:01 <lambdabot>   mueval-core: Time limit exceeded
08:27:52 <t7> @check \b -> b == not (not b)
08:27:56 <lambdabot>   mueval-core: Time limit exceeded
08:28:01 <t7> u wot m7
08:28:19 <dgpratt> m7?
08:31:06 <acube> @check \x -> x == x
08:31:11 <lambdabot>   mueval-core: Time limit exceeded
08:36:22 <dolio> @check \_ -> True
08:36:27 <lambdabot>   mueval-core: Time limit exceeded
08:39:44 <chrisdotcode_> hello everyone
08:40:23 <rtb> hi :)
08:40:39 <chrisdotcode_> hi, rtb
08:41:39 <alexander__b> any vim plugins that vertically align things like let?
08:41:55 <alexander__b> actually whatever setup I have now does that... except it goes bananas on things like putStrLn
08:42:22 <chrisdotcode_> :t unlines
08:42:23 <lambdabot> [String] -> String
08:42:26 <chrisdotcode_> :t lines
08:42:28 <lambdabot> String -> [String]
08:42:37 <alexander__b> and I'd like to be able to do [ (foo, bar), (fu, baz) ], with the ()s being aligned.
08:42:38 <chrisdotcode_> :t lines . unlines
08:42:40 <lambdabot> [String] -> [String]
08:43:59 * hackagebot lua-bytecode 0.1.0.0 - Library for loading Lua bytecode.  http://hackage.haskell.org/package/lua-bytecode-0.1.0.0 (JeffShaw)
08:44:36 <enigmuriatic> say you have a 5.1 GB CSV file. what's the fast logic to use to get that into a database?
08:44:47 <neutrino> alexander__b: there was some tab aligner thing but i don't think i ever used it.
08:45:02 <Botje> enigmuriatic: both mysql and postgresql have built-in csv import.
08:45:24 <Clint> and sqlite3
08:46:57 <Aetherspawn> Hmm, using Lens consider: broadcastChan %= \x -> atomically $ dupTChan x -- broadcastChan %= expects a TChan X whereas I give it a IO (TChan X). Is there a more appropriate lens for this, or a way to fix my problem?
08:49:05 <supki> Aetherspawn: (<~) ?
08:49:11 <supki> oh, no
08:49:28 <Aetherspawn> Well, just a way to modify broadcastChan by duping it is fine too if you know another way
08:51:47 <Aetherspawn> broadcastChan <~ use broadcastChan typechecks, so I'll work from there. Thanks!
08:52:09 <jeff_s1> j2hs looks very interesting. I need to investigate it.
08:53:08 <Aetherspawn> @pl (use broadcastChan >>= (\x -> liftIO $ atomically $ dupTChan x))
08:53:12 <lambdabot> use broadcastChan >>= (liftIO $) . (atomically $) . dupTChan
08:53:12 <lambdabot> optimization suspended, use @pl-resume to continue.
08:53:52 <Aetherspawn> (anything $) looks very wrong. Is lambdabot not working today?
08:53:59 * hackagebot hemokit 0.4.0 - Haskell port of the Emokit EEG project  http://hackage.haskell.org/package/hemokit-0.4.0 (NiklasHambuechen)
08:54:32 <fragamus> What's this? A new IDE and deployment environment for haskell?  I'll take two!
08:54:34 <supki> not sure why there's no (<~)-like for (a -> m b)
08:54:41 <supki> probably nobody cared enough
08:56:06 <Aetherspawn> an annoying problem I always have is <~ is lower than $
08:56:20 <Aetherspawn> so it doesn't work like the regular <- and always requires outermost braces
08:56:22 <Aetherspawn> :(
08:57:10 <supki> I don't see how <~ helps you anyway
08:57:13 <chrisdotcode_> fragamus: link please?
08:57:42 <supki> you want something like do m <- use l; m' <- f m; l .= m'
08:57:44 <fragamus> https://www.fpcomplete.com/business/designer-ide
08:57:53 <fragamus> i got an email today
08:58:02 <fragamus> I want this to be well done
08:58:10 <fragamus> I want it to not suck
08:58:23 <hpaste> ClaudiusMaximus pasted “compiler from high level C-alike to C with low level libraries?” at http://hpaste.org/90146
08:58:26 <jfischoff> holy shit 1100+
08:58:50 <Aetherspawn> supki, this typechecks:
08:58:52 <Aetherspawn> broadcastChan <~ (use broadcastChan >>= liftIO . atomically . dupTChan)
08:58:55 <Aetherspawn> is it wrong?
08:59:24 <ClaudiusMaximus> hi, wondering whether I'm insane for thinking of writing a compiler from C plus high level syntax additions to C + MPFR low level library calls..
08:59:40 <chrisdotcode_> fragamus: a cloud-only deployment tool seems cool, but I would like a non-commercial IDE...
08:59:59 <fragamus> then you want leksah
09:00:12 <fragamus> but no one uses leksah
09:00:27 <fragamus> well maybe someone does
09:00:56 <Aetherspawn> Leksah feels wierd
09:01:19 <Aetherspawn> I'm sure its nice, but it doesn't feel windowsey on windows
09:01:44 <luite_> yeah it's gtk2hs based
09:02:33 <supki> Aetherspawn: if you inline (<~) you'll see it's equivalent to what I proposed :)
09:02:35 <luite_> but fpcomplete's IDE won't feel windowsy either
09:03:17 <Aetherspawn> thanks
09:07:43 <Aetherspawn> luite_, are there any screenshots of it released
09:11:38 <Aetherspawn> I really wish <~ had higher infix than $
09:12:14 <supki> it is higher
09:13:39 <Aetherspawn> currently f <~ a >>= b $ c is different to f <~ (a >>= b $ c)
09:13:53 <Aetherspawn> or did I mean lower
09:15:21 <chrisdotcode_> guys, what are the "options" in a type called? data Color = Red | Blue. What are Red and Blue called? Value constructors, right?
09:15:45 <merijn> chrisdotcode_: value constructors or just constructors
09:16:21 <chrisdotcode_> merijn: so you would say "Color has multiple (value) constructors"?
09:16:33 <merijn> chrisdotcode_: Yes
09:16:33 <FreeFull> Yes
09:16:41 <chrisdotcode_> and Color is the type constructor?
09:16:47 <FreeFull> Yes
09:16:50 <chrisdotcode_> okay, got it.
09:16:52 <chrisdotcode_> thanks.
09:16:54 <merijn> chrisdotcode_: Color is a type and/or type constructor
09:16:59 <FreeFull> Value constructors can also be called data constructors
09:17:19 <alexander__b> err I have done this before but I forgot how
09:17:22 <merijn> (Normally you'd use the term "type constructor" for things like Maybe, which have kind * -> *)
09:17:33 <alexander__b> how do I find the index of foo in ["foo", "bar"]?
09:17:39 <merijn> :t find
09:17:40 <lambdabot> (a -> Bool) -> [a] -> Maybe a
09:17:46 <merijn> oh, whoops
09:17:50 <merijn> That's not the right one :p
09:17:55 <alexander__b> which find?
09:18:18 <Botje> :t findIndex
09:18:19 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
09:18:27 <alexander__b> where is that?
09:18:36 <supki> @ty elemIndex
09:18:36 <lambdabot> Eq a => a -> [a] -> Maybe Int
09:18:42 <FreeFull> :t genericFindIndex
09:18:43 <lambdabot>     Not in scope: `genericFindIndex'
09:18:43 <lambdabot>     Perhaps you meant `genericIndex' (imported from Data.List)
09:18:45 <alexander__b> g2g, please highlight me when you find the answer
09:18:55 <Botje> @hoogle findIndex
09:18:55 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
09:18:56 <lambdabot> Data.ByteString.Char8 findIndex :: (Char -> Bool) -> ByteString -> Maybe Int
09:18:56 <lambdabot> Data.ByteString.Lazy.Char8 findIndex :: (Char -> Bool) -> ByteString -> Maybe Int64
09:19:00 <Botje> Data.List it is!
09:19:30 <FreeFull> > elemIndex "foo" ["foo","bar"]
09:19:31 <lambdabot>   Just 0
09:19:45 <chrisdotcode_> :i elemIndex
09:19:57 <Botje> or that.
09:19:58 <FreeFull> lambdabot doesn't do :i
09:20:00 <Botje> FreeFull++
09:20:07 <chrisdotcode_> what a shame...
09:20:09 <FreeFull> Botje: supki suggested it
09:20:18 <FreeFull> @hoogle elemIndex
09:20:18 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
09:20:18 <lambdabot> Data.ByteString.Char8 elemIndex :: Char -> ByteString -> Maybe Int
09:20:18 <lambdabot> Data.ByteString.Lazy.Char8 elemIndex :: Char -> ByteString -> Maybe Int64
09:20:19 <xico> how can i define a type looking like "[a,b] -> (a -> b -> c) -> c"
09:20:34 <Botje> the type [a,b] cannot exist
09:20:35 <merijn> xico: What is "[a,b]"?
09:20:42 <merijn> xico: Do you mean "[(a,b)]"?
09:20:42 <xico> yep thats my question :)
09:20:46 <FreeFull> Maybe (a,b)
09:21:29 <xico> i want a function taking a specific pattern as argument
09:21:35 <FreeFull> :t \(x,y) f -> f x y
09:21:37 <lambdabot> (t1, t2) -> (t1 -> t2 -> t) -> t
09:21:50 <Botje> xico: you can't encode that in the type
09:21:58 <Botje> not in haskell, at least
09:22:05 <xico> well i have seen it done for fixed arrays like vectors
09:22:18 <xico> i wondered if it was easy to use for list as well
09:22:31 <FreeFull> :t \[x,y] f -> f x y
09:22:32 <lambdabot> [t1] -> (t1 -> t1 -> t) -> t
09:22:42 <chrisdotcode_> ..why are <$> and <*> so ugly?
09:22:50 <chrisdotcode_> (IMO)
09:23:00 <Botje> because you find them ugly :)
09:23:03 <byorgey> probably because of your font
09:23:07 <merijn> Because $ and * were already taken?
09:23:14 <byorgey> in my font they look like a flower and a rainbow, respectively
09:23:18 <chrisdotcode_> even $ looks ugly for function application
09:23:21 <chrisdotcode_> byorgey: haha
09:23:39 <chrisdotcode_> what's wrong with: `half . half <| 8`?
09:23:47 <byorgey> it's ugly
09:23:47 <FreeFull> :t half
09:23:48 <lambdabot> Not in scope: `half'
09:23:53 <chrisdotcode_> as opposed to half . half $ 8
09:24:10 <supki> <| is 2 characters
09:24:15 <supki> unacceptable!
09:24:24 <FreeFull> <| exists in lens but is something else
09:24:26 <byorgey> chrisdotcode_: OK, seriously, nothing is wrong with it. Just define (<|) = ($) at the top of your file and off you go!
09:24:54 <FreeFull> > 3 <| [4]
09:24:55 <lambdabot>   Not in scope: `<|'
09:24:56 <lambdabot>  Perhaps you meant one of these:
09:24:56 <lambdabot>    `Seq.<|' (imported f...
09:25:10 <chrisdotcode_> byorgey: I'd *love* to do that, but sadly it's not convention, which means it will only add another layer of abstraction for the guy who has to maintain my code
09:25:10 <FreeFull> @let import Control.Lens.Operators
09:25:11 <lambdabot>  .L.hs:39:1:
09:25:11 <lambdabot>      Control.Lens.Operators: Can't be safely imported!
09:25:11 <lambdabot>      The ...
09:25:15 <FreeFull> Damn
09:25:19 <chrisdotcode_> > (<|) = ($)
09:25:20 <lambdabot>   <hint>:1:6: parse error on input `='
09:25:40 <merijn> > let (<|) = ($) in (+2) <| 3
09:25:41 <lambdabot>   5
09:25:47 <Aetherspawn> who is the maintainer of lens
09:25:50 <merijn> chrisdotcode_: Lambdabot doesn't do assignments
09:25:55 <FreeFull> byorgey: You have to take fixity into account too
09:25:56 <ramses_> lens has so many typeclasses.. I can't seem to find an entry point into the library
09:25:58 <merijn> Aetherspawn: I think it's a group effort
09:26:00 <byorgey> FreeFull: sure, sure.
09:26:05 <chrisdotcode_> merijn: I think that looks nice
09:26:13 <merijn> ramses_: Have you seen edwardk's lens talk?
09:26:16 <byorgey> ramses_: try the tutorial.
09:26:23 <merijn> ramses_: It's very good and interesting, but also very long :p
09:26:27 <Aetherspawn> some of these lens operators look like little people
09:26:36 <merijn> @where lens
09:26:36 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
09:26:37 <Aetherspawn> sunglasses operator: (**~)
09:26:42 <chrisdotcode_> a lot of haskell's operators are crazy looking ._.
09:26:44 <merijn> That youtube link
09:26:51 <ramses_> merijn: I started once, but didn't have the time to sit through it, maybe I should watch it again
09:26:54 <FreeFull> I don't see any lens tutorial explain indexed stuff or prisms or other things
09:26:58 <Aetherspawn> rave hug operator: (<&&~)
09:27:00 <merijn> chrisdotcode_: Most of those are lens operators, which you could safely ignore for now :p
09:27:01 <byorgey> chrisdotcode_: ._. is not a valid operator
09:27:04 <FreeFull> Only the basic lenses, traversals and folds
09:27:08 <ramses_> byorgey: where is it?
09:27:11 <chrisdotcode_> byorgey: hahaha
09:27:15 <ramses_> the one on github?
09:27:22 <byorgey> ramses_: yes
09:27:27 <chrisdotcode_> merijn: yeah, but then, there's also <$> and <*>, which I was complaining about earlier
09:27:41 <chrisdotcode_> I'm getting used to "\" for lamdbas, if I squint hard enough.
09:27:56 <FreeFull> chrisdotcode_: If you want you can write your haskell code as unicode
09:28:16 <chrisdotcode_> But <$> and <*> look like nothing common, and don't really have any visual clues as to what they are at all...
09:28:22 <FreeFull> > let (☺) = (+) in 3 ☺ 4
09:28:24 <lambdabot>   7
09:28:34 <chrisdotcode_> okay, that's pretty awesome.
09:28:56 <FreeFull> http://www.haskell.org/haskellwiki/Unicode-symbols
09:29:06 <joelteon> > let (ಠ_ಠ) = (-) in ಠ_ಠ3
09:29:09 <lambdabot>   Not in scope: `ಠ_ಠ3'
09:29:09 <lambdabot>  Perhaps you meant `ಠ_ಠ' (line 1)
09:29:13 <joelteon> oh, right
09:29:18 <joelteon> unary minus is a special case
09:29:20 <chrisdotcode_> heh
09:29:25 <byorgey> chrisdotcode_: I am not sure what you want us to do about it.
09:29:31 <byorgey> complaining does not really accomplish anything.
09:29:37 <bscarlet> let (🌈) = (<$>)
09:29:52 <chrisdotcode_> byorgey: I was just trying to get your guys' opinions on what you think about it.
09:30:28 <byorgey> chrisdotcode_: I think $, <$> and <*> look nice enough.  I am so used to them that I don't really think about it.
09:30:30 <chrisdotcode_> like, I wouldn't have decided on something looking that crazy in the first place. since I"m still a newbie, I don't know if I have a legitimate complaint, or if I"ll get over it like I did with "\"
09:30:38 <geekosaur> joelteon, also the "eyeball" is a Kannada letter, so not a valid operator character (and the let is parsingt hat differently than you think)
09:30:46 <joelteon> oh, it isn't?
09:30:51 <joelteon> huh. ok
09:31:05 <bscarlet> >let (⚘) = (<$>)
09:31:17 <bscarlet> >let (🌈) = (<*>)
09:31:20 <joelteon> > generalCategory 'ಠ'
09:31:21 <lambdabot>   OtherLetter
09:31:23 <bscarlet> There you go. Flowers and rainbows.
09:31:25 <joelteon> no kidding!
09:31:43 <tunixman> Brilliant.
09:32:02 <chrisdotcode_> bscarlet: I think I'd prefer ⚘ to <$> anyday. At least it's memorable.
09:32:10 <eikke> :t (⚘)
09:32:11 <lambdabot> lexical error at character '\154'
09:32:19 <Philippa> chrisdotcode_: they're partly historical accidents - the <> are there to mark them out, but <$> is a variant of $ the way <|> is a variant of |
09:32:44 <FreeFull> <$> isn't really a variant of $ though
09:33:00 <FreeFull> It's more like a general variant of .
09:33:03 <chrisdotcode_> Philippa: right. so the same stuff as length returning Num and the applicative and monad thing?
09:33:12 <Philippa> sure is. It marks out the start of an n-ary (Applicative) function application
09:33:26 <FreeFull> > (+3) <$> (+4) $ 7
09:33:27 <lambdabot>   14
09:33:32 <chrisdotcode_> what a shame. legacy stuff hardly ever gets changed...
09:33:35 <acube> > (+3) <$> Identity 4
09:33:39 <lambdabot>   mueval-core: Time limit exceeded
09:33:42 <bscarlet> chrisdotcode_: Me too, actually.
09:33:43 <acube> Wha?
09:33:44 <acube> > (+3) <$> Identity 4
09:33:48 <lambdabot>   mueval-core: Time limit exceeded
09:33:52 <acube> > (+3) <$> Identity 4
09:33:56 <lambdabot>   Identity {runIde
09:34:00 <acube> :O ?
09:34:01 <FreeFull> > (+3) <$> Just 4
09:34:02 <lambdabot>   Just 7
09:34:06 <FreeFull> acube: lambdabot is being glitchy
09:34:10 <merijn> > runIdentity $ (+3) <$> Just 4
09:34:11 <lambdabot>   Couldn't match type `Data.Maybe.Maybe'
09:34:11 <lambdabot>                with `Data.Functor.Id...
09:34:21 <merijn> uh...
09:34:24 <merijn> I'm dumb
09:34:28 <merijn> > runIdentity $ (+3) <$> Identity 4
09:34:30 <lambdabot>   7
09:34:35 <chrisdotcode_> let (⚘) = ($) in (+3) ⚘ (+4) $ 7
09:34:45 <chrisdotcode_> > let (⚘) = (<$>) in (+3) ⚘ (+4) $ 7
09:34:46 <acube> Looks more like $ than like (.) to me :P
09:34:46 <lambdabot>   14
09:34:54 <FreeFull> > (+3) <*> Identity 4
09:34:56 <lambdabot>   Couldn't match expected type `Data.Functor.Identity.Identity
09:34:56 <lambdabot>               ...
09:35:00 <FreeFull> Oh, right
09:35:04 <FreeFull> They have to be of the same type
09:35:06 <chrisdotcode_> > let (⚘) = (<$>), (<|) = ($) in (+3) ⚘ (+4) <| 7
09:35:07 <lambdabot>   <hint>:1:16: parse error on input `,'
09:35:09 <FreeFull> > Identity (+3) <*> Identity 4
09:35:13 <lambdabot>   Identity {runIdentity = 7}
09:35:21 <acube> > generalCategory '\''
09:35:22 <lambdabot>   OtherPunctuation
09:35:32 <acube> What categories can be used as operators?
09:35:42 <acube> let (') = const in 1 ' 2
09:35:43 <Philippa> chrisdotcode_: they're a somewhat particular kind of historical accident, though. Like, IIRC <*> comes from one of the papers that built a parsing library that, later on, happened to meet the Applicative signature. It was an already-extant use, in other words
09:36:02 <acube> > let (') = const in 1 ' 2
09:36:03 <lambdabot>   <hint>:1:7: parse error on input `)'
09:36:18 <acube> > let (€) = const in 1 € 2
09:36:18 <chrisdotcode_> Philippa: that's unfortunate...
09:36:19 <lambdabot>   1
09:36:20 <Philippa> I mean, personally I'd be happy if we had to mark out ordinary arithmetic as 'weird' compared to all the useful algebraic stuff :p
09:36:22 <bscarlet> > let ((⚘),(🌈)) = ((<$>),(<*>)) in (+) ⚘ Just 3 🌈 Just 4
09:36:24 <lambdabot>   Could not deduce (Control.Applicative.Applicative f0)
09:36:24 <lambdabot>    arising from the a...
09:36:42 <acube> What categories can be used as operators?
09:36:58 <geekosaur> acube, ' isn't valid for an operator, not because of its category but because it's already taken for syntax (Char literals, identifiers, Template Haskell)
09:37:15 <Philippa> chrisdotcode_: moderately. They're genuinely rooted in a sense-making set of traditions, the <> are just a little fugly. But at a point when sticking to ASCII was the done thing, what else were we supposed to do?
09:37:18 <bscarlet> > (+) <$> Just 3 <*> Just 4
09:37:19 <lambdabot>   Just 7
09:37:32 <acube> geekosaur: But it's valid in a function name?
09:37:44 <Philippa> acube: just not as the first character
09:37:46 <geekosaur> see "identifiers"
09:37:55 <acube> > (+') = const in 1 +' 2
09:37:55 <chrisdotcode_> Philippa: I don't know, use (<|) and (|>) maybe? ;_;
09:37:56 <lambdabot>   <hint>:1:4: parse error on input `)'
09:38:01 <acube> > (+'+) = const in 1 +'+ 2
09:38:02 <lambdabot>   <hint>:1:4: parse error on input `+'
09:38:02 <Philippa> and identifiers and operators have a disjoint character set for good reason
09:38:22 <chrisdotcode_> > let ((⚘), (<|) = ((<$>), ($)) in (+3) ⚘ (+4) <| 7
09:38:23 <lambdabot>   <hint>:1:16: parse error on input `='
09:38:27 <ramses_> chrisdotcode_: there are *> and <* as well, which complement <*> very nicely
09:38:30 <chrisdotcode_> > let ((⚘), (<|)) = ((<$>), ($)) in (+3) ⚘ (+4) <| 7
09:38:32 <lambdabot>   No instance for (GHC.Base.Functor f0)
09:38:32 <lambdabot>    arising from the ambiguity check f...
09:38:37 <Philippa> chrisdotcode_: those were already going to remind people of | and <|> though
09:38:39 <FreeFull> > liftA2 (+) (Just 3) (Just 4)
09:38:40 <acube> ramses_: and <$
09:38:40 <lambdabot>   Just 7
09:38:41 <geekosaur> anyway it is special cased. ther identifier bit means that, when it's inside an identifier, it is parsed as a "letter"
09:38:45 <Aetherspawn> What's the best way to repeatedly accumulate the result of a monadic action until the result is Nothing
09:38:46 <chrisdotcode_> :t *>
09:38:48 <lambdabot> parse error on input `*>'
09:38:51 <chrisdotcode_> :t (*>)
09:38:52 <lambdabot> Applicative f => f a -> f b -> f b
09:39:07 <Aetherspawn> so, takeWhile isJust (maybe?) for monads...
09:39:17 <FreeFull> *> is like >> but Applicative instead of Monad
09:39:28 <chrisdotcode_> ramses_: it turns a functor of as into a functor of bs?
09:39:35 <Philippa> FreeFull: yep. And that's a more genuine historical accident but one that had to happen at the time
09:39:43 <Philippa> now, <$ is one I'm a little too fond of
09:39:46 <ramses_> chrisdotcode_: it discards the result of one of the two functors
09:39:58 <FreeFull> "discards"
09:39:58 <chrisdotcode_> ramses_: is that actually ever useful?
09:39:59 <acube> > 3 <$ Just 4
09:40:00 <lambdabot>   Just 3
09:40:07 <Philippa> (because it actually crops up in my code all the damn time)
09:40:11 <ramses_> chrisdotcode_: very, especially for parsers
09:40:14 <FreeFull> > [1,2,3] *> [4,5,6]
09:40:16 <lambdabot>   [4,5,6,4,5,6,4,5,6]
09:40:23 * acube would like a non-infix <$
09:40:40 <geekosaur> and when not internal to an identifier it is parsed as the start of a Char literal (or, only if Template Haskell is enabled, a sequence starting with '')
09:40:41 <FreeFull> chrisdotcode_: As you can see, it doesn't just get rid of the first argument
09:40:43 <geekosaur> let myThing = (<$)
09:40:46 <chrisdotcode_> speaking of non-infix, is there any particular reason haskell doesn't support mixfix?
09:40:54 <Philippa> chrisdotcode_: it lets you do something "for effect", which is indeed useful
09:41:13 <Philippa> because retrofitting mixfix is much harder work
09:41:14 <Philippa> FFTSAProposal and all that
09:41:42 * chrisdotcode_ googles FFTSAProposal
09:41:51 <Philippa> Feel Free To Submit A (usually Patch)
09:41:54 <ramses_> FreeFull: I said "discard the result of ...", implying it still takes the "context" in consideration
09:42:09 <geekosaur> how does mixfix interact with sections? with partial application in general?
09:42:10 <chrisdotcode_> right, right
09:42:19 <chrisdotcode_> geekosaur: that's true...
09:42:38 <Philippa> chrisdotcode_: Just to ask - are you aware of how old Haskell is as a language?
09:42:51 <chrisdotcode_> Philippa: 1997, right?
09:42:54 <Philippa> 1990
09:43:06 <Philippa> the '98 standard was not the first
09:43:09 <chrisdotcode_> I knew it was about 5-15 years old.
09:43:21 <Philippa> yeah, it's more like 23
09:43:24 <chrisdotcode_> yikes
09:43:34 <chrisdotcode_> I remember Carmack tweeting that Haskell is older than Java...
09:44:36 <Philippa> yeah. I imagine you can see why no mixfix, then
09:45:11 <Philippa> given the sheer amount of research stuff that's passed through the language, it's done pretty well for itself
09:45:12 <chrisdotcode_> so is mixfix stuck in design-by-committee hell, or are there just really hard problems to solve?
09:45:25 <Philippa> there are really hard problems to solve in not breaking backwards compatibility
09:45:27 <chrisdotcode_> s/are there/is it
09:45:46 <geekosaur> afaik nobody has proposed it. because someone needs to answer the question I asked before it can even be proposed
09:45:48 <Philippa> we also don't know for sure what /good/ mixfix looks like, so younger languages can go experiment :p
09:46:16 <chrisdotcode_> iirc, maude has mixfix, right?
09:46:21 <chrisdotcode_> and wasn't haskell inspired by maude?
09:46:23 <Philippa> geekosaur: there's one 'obvious' but painful answer, admittedly
09:46:24 <geekosaur> there might well be a Ph.D thesis in working out how mixfix would fit into Haskell
09:46:42 <Philippa> chrisdotcode_: Miranda would be Haskell's most obviously direct ancestor
09:47:01 <Philippa> geekosaur: or you take the lazy answer of "you don't get those things, write it out long-hand with a lambda" :p
09:47:05 <Philippa> but yes
09:47:34 <Philippa> especially not helped by the fact we've already made our choices about how things like keywords behave - to really make nice use the way something like agda does, you'd want a total syntax overhaul
09:47:48 <Philippa> (and can we have a better combined modules-and-typeclasses story while we're at it, now we know that's obviously a thing?...)
09:49:29 <chrisdotcode_> Philippa: what's the deal with modules in haskell?
09:49:37 <chrisdotcode_> I keep hearing complaints, but I"ve only done basic stuff so far.
09:49:46 <chrisdotcode_> (basic module work, that is)
09:50:02 <sclv_> mixfix scares me
09:51:26 <bitonic> mixfix is awesome
09:53:19 <alexander__b> how do I move index n to m?
09:53:27 <alexander__b> I mean move element at index n to index m
09:53:47 <FreeFull> chrisdotcode_: Python is older than Java too
09:53:56 <chrisdotcode_> fragamus: really? >_>
09:53:57 <Philippa> chrisdotcode_: the deal is that they're not ML's modules :-)
09:54:07 <chrisdotcode_> Philippa: what's so great about ML's modules?
09:54:07 <sclv_> bitonic: both may well be true
09:54:21 <Philippa> ML basically has an entire second language for talking about them
09:54:50 <Philippa> what we think of as a module is a "structure" with a "signature" (which is effectively its type). There are "functors" that operate on modules and generate new ones.
09:54:56 <FreeFull> chrisdotcode_: Yeah, it is
09:55:17 <chrisdotcode_> Philippa: ...dynamic module creation?
09:55:19 <Philippa> basically: ML lets you /program/ at module level
09:55:35 <Philippa> not inherently: most ML flavours have a strictly static module system
09:55:35 <Aetherspawn> :t maybeM
09:55:37 <lambdabot>     Not in scope: `maybeM'
09:55:37 <lambdabot>     Perhaps you meant `maybe' (imported from Data.Maybe)
09:55:41 <Philippa> (some have first-class modules, in which case yes)
09:56:09 <chrisdotcode_> Philippa: am I missing something here? doesn't seem that much different from a Pythonic namespace.
09:56:28 <Philippa> Python's a dynamic language
09:56:36 <Philippa> ML is strongly statically typed
09:56:45 <bitonic> chrisdotcode_: you can defined signatures which define types and functions over them.  then you can instantiate them with actual code.  you can also do that anonymously
09:56:46 <Philippa> ML does this stuff *safely*
09:57:07 <bitonic> even apart from the types, I’m not sure Python lets you do something similar to that
09:57:20 <FreeFull> Python is a pain
09:57:23 <bitonic> but yeah it’s mostly about types
09:57:55 <chrisdotcode_> bitonic: can't you also do that in haskell too? make type signatures, and then write the code that goes along with it?
09:58:04 <chrisdotcode_> I have a feeling I'm missing a great deal here haha
09:58:15 <bitonic> chrisdotcode_: you write bundles of type signatures, which might contain types and signatures over those types
09:58:20 <chrisdotcode_> FreeFull: that's the first time I'ver ever heard that...
09:58:29 <bitonic> then you can instantiate the whole bundle with the bodies of the signatures
09:58:34 <bitonic> you cannot do that in Haskell
09:58:37 <alexander__b> errr how do I use a Maybe Int with a function that expects an Int?
09:58:37 <josephle> chrisdotcode_: but you can't organize your type signatures into one bigger signature, which is one of the draws of the ML module system
09:58:44 <alexander__b> e.g. splitAt with findIndex
09:58:52 <josephle> bitonic: well, if you hack away at records hard enough you can get close...
09:59:11 <chrisdotcode_> :t splitAt . findIndex
09:59:12 <lambdabot>     Couldn't match type `[a0] -> Maybe Int' with `Int'
09:59:12 <lambdabot>     Expected type: (a0 -> Bool) -> Int
09:59:12 <lambdabot>       Actual type: (a0 -> Bool) -> [a0] -> Maybe Int
09:59:16 <FreeFull> alexander__b: You could use fmap or make the Maybe Int into an Int
09:59:20 <chrisdotcode_> :t findIndex . splitAt
09:59:20 <lambdabot>     Couldn't match type `([a0], [a0])' with `Bool'
09:59:21 <josephle> disclaimer - I don't buy into SPJ's argument that modules are just named records
09:59:21 <lambdabot>     Expected type: Int -> [a0] -> Bool
09:59:21 <lambdabot>       Actual type: Int -> [a0] -> ([a0], [a0])
09:59:23 <FreeFull> :t splitAt
09:59:24 <lambdabot> Int -> [a] -> ([a], [a])
09:59:24 <bitonic> josephle: yes, records and existentials are basically modules
09:59:26 <FreeFull> :t findIndex
09:59:27 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
09:59:33 <Philippa> josephle: except then you have to encode all your /actual/ modules into those too. Woo. Frickin'. Hoo.
09:59:36 <alexander__b> FreeFull: how do I do the latter, and how frowned upon is that?
09:59:39 <chrisdotcode_> josephle: so your modules can have a type signature?
09:59:51 <FreeFull> :t fromMaybe
09:59:52 <Philippa> (which is to say: if that's what you have to do, you have to do it, but it's not a /satisfactory/ solution and we both know that!)
09:59:52 <lambdabot> a -> Maybe a -> a
09:59:54 <alexander__b> BRB pls highlight me with replies
09:59:57 <alexander__b> FreeFull: thanks
10:00:01 <josephle> chrisdotcode_: yes, they're called module signatures
10:00:10 <Philippa> chrisdotcode_: it's no good handing me a screwdriver if I'm looking for a lightbulb
10:00:19 <FreeFull> alexander__b: It's not frowned upon at all if you do it safely. fromMaybe is a safe way
10:00:25 <joelteon> :t (#)
10:00:29 <lambdabot> AReview s t a b -> b -> t
10:00:34 <Philippa> that's /exactly/ what the ML module system is about: realising that modular construction (of programs) is just yet more programming
10:00:39 <joelteon> god I love lens type sigs
10:00:44 <Philippa> complete with more of the same ways to get it wrong
10:01:00 <chrisdotcode_> I think I"m going to need to read a paper on this.
10:01:06 <FreeFull> joelteon: Because they tell you nothing unless you know what AReview/etc is?
10:01:18 <bitonic> chrisdotcode_: you don’t need a paper, there is extensive documentation
10:01:18 <Philippa> there's a decent chapter on them in Advanced Topics in Types and Programming Languages
10:01:23 <joelteon> FreeFull: And even then, they don't help a lot
10:01:30 <Philippa> I forget if it's one of the ones that's also available legit for free
10:01:31 <chrisdotcode_> bitonic: or the doc :-)
10:01:34 <Philippa> (the ML(X) one is, IIRC)
10:01:40 <Philippa> ML isn't just one language
10:01:43 <joelteon> But I did figure out how to write a Prism that operates on a JSON-serialized value yesterday, and it only took 45 minutes
10:01:48 <Philippa> it's a family of the damn things
10:02:34 <chrisdotcode_> I know that ML has a ton of dialects
10:02:42 <bitonic> I’d go for SML
10:03:37 <bitonic> it’s small and understandable.  I guess that OCaml is the ‘useful’ relative :)
10:05:58 <josephle> bitonic: there's always the fact that SML was successfully proved safe formally
10:06:10 <bitonic> which is correlated to the ‘small and understandable’
10:06:12 <josephle> where safety = progress + preservation
10:07:05 <dmwit> (side note of no real relevance: progress + preservation is just one way to prove safety, so that "=" is not warranted)
10:07:08 <chrisdotcode_> josephle: is haskell also safely proved formally?
10:07:21 <josephle> the only gripe i have with modules is that Phase Distinction/Splitting is a really hairy process
10:07:24 <oio_> mapM_ with copyFile ?
10:07:54 <josephle> dmwit: I'm just trying to specify which instance of the safety definition I'm talking about :)
10:08:19 <dmwit> I see. =)
10:08:44 <josephle> chrisdotcode_: I heard there has been attempts, but I don't know about them
10:08:50 <dmwit> chrisdotcode_: It's a tricky question, because there's so many things that people call Haskell. =)
10:09:11 <josephle> how many ghc extensions does it take to make a Haskell?
10:09:12 <chrisdotcode_> dmwit: is haskell98 formally proved to be safe?
10:09:18 <luite_> Aetherspawn: dunno, but it's web based
10:09:34 <bitonic> chrisdotcode_: no
10:09:43 <Aetherspawn> aww web based
10:09:57 <dmwit> Oh, formally.
10:10:07 <chrisdotcode_> what about informally?
10:10:10 <dmwit> No, I don't think there's any dialect of Haskell with a formalized proof attached.
10:11:04 <oio_> mapM_ with copyFile ?
10:11:15 <josephle> bitonic: the real question is, applicative or generative functors? :P
10:11:23 <josephle> (ML functors that is)
10:11:31 <dmwit> oio_: Your question sucks. (Sorry.)
10:11:55 <bitonic> josephle: don’t know what that is
10:11:56 <dmwit> oio_: Nobody knows what you're asking. Flesh it out to a full sentence, at least; include some code and a description of how it doesn't work, at best.
10:11:57 <chrisdotcode_> that's interesting. so haskell's safe, and you can make proofs with it. ...but the language itself hasn't been proven to be safe. huh.
10:12:43 <sclv_> progress + preservation is about the type system
10:12:44 <dmwit> chrisdotcode_: Hm, I'm not sure. I was under the impression that the early GHC papers gave a compilation strategy into a core calculus that was (paper-and-pencil) proved safe.
10:12:56 <dmwit> ...which would imply that Haskell98 is proved safe.
10:12:58 <Philippa> josephle: the answer is "yes"
10:13:16 <josephle> Philippa: :)
10:13:16 <bitonic> @faq is Haskell informally safe?
10:13:16 <lambdabot> The answer is: Yes! Haskell can do that.
10:13:17 <sclv_> there are many definitions of 'safety'
10:13:30 <oio_> dmwit: mapM over functions with multiple arguments
10:13:37 <Philippa> josephle: there's even a nice account using monads or other effect typing to keep track of when you're doing what
10:13:41 <Hafydd> @faq Can Haskell prove P?
10:13:41 <chrisdotcode_> I know that the HM-type system is safe, and the typed lambda calculus is by definition safe.
10:13:41 <lambdabot> The answer is: Yes! Haskell can do that.
10:13:46 <dmwit> oio_: What about it?
10:13:46 <Hafydd> @faq Can Haskell prove ~P?
10:13:46 <lambdabot> The answer is: Yes! Haskell can do that.
10:14:22 <jeff_s1> If Haskell can't do it, try Agda. If Agda can't do it, try Prolog.
10:14:45 <dmwit> chrisdotcode_: ..."by definition"?
10:14:57 <sclv_> many various extensions, in the sense that they desugar into system f, are also safe
10:14:58 <oio_> i want to join mapM and coyfiles
10:15:06 <bitonic> the ‘safe STLC’, ofc
10:15:07 <oio_> *copyFile
10:15:08 <sclv_> ?hoogle copyFile
10:15:09 <lambdabot> System.Directory copyFile :: FilePath -> FilePath -> IO ()
10:15:09 <chrisdotcode_> dmwit: well since it's typed, isn't it safe by the definition of the word "typed"?
10:15:15 <dmwit> No.
10:15:17 <sclv_> ?hoogle mapM
10:15:18 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
10:15:18 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
10:15:18 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
10:15:22 * chrisdotcode_ is assuming that typed always means safe
10:15:25 <sclv_> ?ty uncurry
10:15:26 <chrisdotcode_> is that a bad assumption?
10:15:27 <lambdabot> (a -> b -> c) -> (a, b) -> c
10:15:32 <bitonic> chrisdotcode_: C is typed
10:15:34 <dmwit> chrisdotcode_: Yes. It is easy to design a type system that is unsafe.
10:15:36 <sclv_> ?ty uncurry copyFile
10:15:38 <lambdabot> Not in scope: `copyFile'
10:15:41 <dmwit> chrisdotcode_: That's why people prove safety.
10:15:45 <sclv_> ah, right
10:15:49 <dmwit> chrisdotcode_: It's... like a sanity check that you did things right.
10:15:55 <bitonic> chrisdotcode_: in C you can typefully seg fault
10:16:05 <josephle> chrisdotcode_: python is typed. Dyn is the one type to rule them all.
10:16:05 <Philippa> dmwit: subtyping without a notion of variance is always good for a laugh
10:16:09 <sclv_> anyway, oio_ look at uncurry :-)
10:16:16 <chrisdotcode_> bitonic: haha, yes that's true.
10:16:36 <chrisdotcode_> so then how is "safe" defined?
10:16:51 <Philippa> on a per-language basis: it's the absence of various "unsafe" behaviours
10:17:00 <bitonic> chrisdotcode_: <https://en.wikipedia.org/wiki/Type_safety#Definitions> usually
10:17:02 <chrisdotcode_> and wrt to haskell, that's side-effects?
10:17:14 <josephle> in fact, python is "safe" according to a modified progress theorem (programs are allowed to throw runtime error)
10:17:17 <bitonic> the subject reduction and progress stuff
10:17:21 <Philippa> the classic, semi-humourous description re ML was that "well-typed code never goes wrong". Wrong was a state in their formal semantics of ML
10:17:37 <dmwit> chrisdotcode_: One common way to define "safe" is to give a small-step semantics, identify a set of "finished" terms, and prove that any well-typed term eventually reduces to a finished one.
10:18:00 <dmwit> (or, in some languages, it's okay to keep reducing indefinitely, too)
10:18:01 <Philippa> josephle: which is a notion that has some use, at least. Compare and contrast with a FORTH-and-machine-code system!
10:18:47 <dmwit> chrisdotcode_: In particular, nonsense like applying a number to a string is neither finished nor reduces, so "safety" in part means you never treat a number as a function.
10:18:52 <chrisdotcode_> dmwit: yeah, because I was going to say, that sounds like any safe language defined like that, you'd be able to solve the halting problem in.
10:19:09 <dmwit> Yes, some type-safe languages have trivial halting problems.
10:19:35 <dmwit> For example, STLC. =)
10:19:40 <alexander__b> FreeFull: thanks!
10:19:52 <Philippa> dmwit: we can quickly fix that, though...
10:19:57 <bitonic> safe languages are not turing complete
10:20:03 <dmwit> Philippa: cute =)
10:20:14 <Philippa> bitonic: Not true
10:20:32 <FreeFull> alexander__b: I'm guessing it worked?
10:20:38 <josephle> bitonic: SML is safe, and it's turing complete... :(
10:20:40 <Philippa> in fact, that's one of the myths that people like Conor McBride are getting really fed up of
10:20:47 <bitonic> Philippa: I was half joking, but if you consider ‘partiality’ unsafe :P...
10:20:50 <alexander__b> FreeFull: IDK yet. but I assume it will. :-)
10:21:02 <chrisdotcode_> subset turing_complete_languages union halting_problem_solved = empty set?
10:21:11 <chrisdotcode_> *turing_complete_languages union halting_problem_solved = empty set?
10:21:16 <sclv_> i coulda sworn we had a paper on a verified stg somewhere
10:21:19 <sclv_> but i can't find it
10:21:28 <Philippa> chrisdotcode_: so one of the fun things is that a language can describe something that isn't /just/ a program
10:21:31 <Hafydd> Do you mean "intersect"?
10:21:50 <FreeFull> Philippa: As in?
10:21:53 <chrisdotcode_> Hafydd: er, yes. my mistake.
10:22:04 <Philippa> as soon as you're holding more than just a computable function in your hands, all those theorems stop applying in quite the way you expect
10:22:17 <chrisdotcode_> Philippa: which is why I love type signatures in haskell.
10:22:45 <Philippa> program+proof? Yeah, you can solve the problem for that. Then it's some other poor bastard's job to write the proof and, admittedly, they're potentially dealing with the full turing-complete version. Only, it's rare to see code that needs to
10:23:02 <sclv_> aha here we are: a derivation of the stg machine verified in coq: http://www.cs.ox.ac.uk/files/3858/pirog-biernacki-hs10.pdf
10:23:07 <Philippa> I mean, I can at least squint at how I'd well-type something as reflective as a "typed smalltalk". Without type-in-type.
10:23:09 <sclv_> it was a symopsium paper, not icfp proper
10:23:39 <Philippa> it does, admittedly, involve accepting that each clock tick gives you a new universe :p
10:24:17 <chrisdotcode_> if you only give each program in a language an execution timeout of t, then I guess the halting problem is solved for that language...
10:24:36 <sclv_> so if you buy that you're producing correct stg, you can verify that your execution engine for it does what you say
10:24:36 <chrisdotcode_> "the program will be stopped when execution time has reached t"
10:24:38 <Philippa> that's old news, yeah. Of course, sometimes you're more interested in productivity than termination anyway
10:24:45 <Philippa> Will that server keep responding?
10:25:01 <chrisdotcode_> how can you solve the halting problem for a language with either loops or recursion?
10:25:10 <chrisdotcode_> without imposing a depth limit, or a timeout?
10:25:15 <chrisdotcode_> ...or is that the million dollar question?
10:25:33 <Philippa> chrisdotcode_: you ask them to provide their own depth limit
10:25:40 <Philippa> (or other measure of progress)
10:25:43 <bitonic> chrisdotcode_: you can quite effectively isolate productive loops and ‘good’ recursion
10:25:47 <chrisdotcode_> huh.
10:25:56 <chrisdotcode_> if a function provides it's own depth limit...
10:26:01 <chrisdotcode_> that sound like a clever solution
10:26:24 <Philippa> chrisdotcode_: 'show proof by induction works! The structure you're inducting on provides the depth limit
10:26:27 <bitonic> chrisdotcode_: if the data you are working with is not infinite, and the recursion recurses on smaller data each time, it’s going to terminate
10:26:49 <sclv_> but 'smaller data each time' is a pain
10:26:56 <sclv_> much better to have a broader notion of terminaition
10:27:25 <bitonic> chrisdotcode_: for stuff like servers and user interaction, you can force your ‘loop’ to be productive = it must produce some output each time you demand it
10:27:30 <alexander__b> FreeFull: while I realise this is probably not idiomatic to say the least, what's wrong with " splitAt (fromMaybe $ findIndex (=="bar") ["foo", "bar"]) ["foo", "bar"]"?
10:27:52 <alexander__b> shouldn't this do splitAt 1 ["foo", "bar"]?
10:27:53 <chrisdotcode_> bitonic: that seems circumventive to me - what if "productive" is generating random numbers?
10:28:01 <sclv_> we'd like easy terminiation proofs for e.g. a naive implementation of ackerman
10:28:02 <chrisdotcode_> (that will be discarded)
10:29:01 <bitonic> sclv_: well a ‘smart’ termination checker will accept ackerman, still on the grounds of size
10:29:07 <bitonic> even if it’s not always on the same argument
10:29:19 <bitonic> chrisdotcode_: I’m not sure what you mean
10:30:03 <chrisdotcode_> bitonic: "if the server is always doing something- whatever it is- then it's not yet halted". what if the server is in an infinite loop, and it's producing random numbers as an output?
10:30:30 <bitonic> chrisdotcode_: if it produces each random number in a finite time you can encode that nicely
10:30:35 <bitonic> as an infinite stream of random numbers
10:31:10 <josephle> bitonic: the grand prize of termination checkers: collatz conjecture :P
10:31:43 <bitonic> yeah that must be a smart checker
10:31:57 <chrisdotcode_> bitonic: so there's depth limit and and getting "smaller" values each time...
10:32:13 <bitonic> chrisdotcode_: ?  I didn’t say anything about the size of each element of the stream
10:32:21 <chrisdotcode_> can you do anything useful in a language without loops/recursion?
10:32:28 <chrisdotcode_> <bitonic> chrisdotcode_: if the data you are working with is not infinite, and the recursion recurses on smaller data each time, it’s going to terminate
10:32:40 <Philippa> chrisdotcode_: an RNG server is a perfectly sensible notion?
10:32:43 <bitonic> chrisdotcode_: well that’s structural recursion, yes
10:33:02 <bitonic> chrisdotcode_: but the ‘infinite stream’ is captured nicely by corecursion :)
10:33:11 <bitonic> actually for the infinite stream all you need is ‘Nat -> a’
10:33:15 <Philippa> chrisdotcode_: the lambda calculus has neither loops nor recursion. Per se. It is turing complete.
10:33:15 <chrisdotcode_> corecursion? is that the same thing as mutual recursion?
10:33:46 <chrisdotcode_> Philippa: I thought the lamda calculus was *all* recursion, functions, values and variables?
10:34:25 <Philippa> chrisdotcode_: No recursion whatsoever. Lambdas, variables and function applications, that's all you've got
10:34:35 <Philippa> it so happens that you can encode recursion in it via a 'fixpoint operator'
10:34:42 <FreeFull> alexander__b: fromMaybe takes two arguments
10:34:47 <Cale> (If it's untyped)
10:34:49 <Philippa> (hence my pun to dmwit earlier, as fixpoint operators are commonly named "fix")
10:34:52 <illissius> am I right to suspect that without also adding higher-rank and/or existential types, GADTs (in a general sense, not the specific GHC extension, IOW the ability to store type equality evidence in data and recover it by pattern matching) are fairly pointless? i.e. give you nothing you couldn't achieve with a phantom type, implementation hiding and smart constructors+eliminators
10:34:54 <alexander__b> FreeFull: ohhh
10:34:55 <bitonic> chrisdotcode_: no, it’s when instead of taking apart a type and recursing on the smaller arguments to produce some data, you take some seed data and you ‘unfold’ it to produce some data and another seed that you can unfold, and so on.  if that makes any sense...
10:34:57 <FreeFull> alexander__b: The first argument is the default value, in case that you get Nothing
10:35:06 <Philippa> Cale: there are typed lambda calculi that admit fix
10:35:09 <FreeFull> > fromMaybe 1 Nothing
10:35:09 <alexander__b> FreeFull: yeh just saw on hoogle. IDK how I missed that. sorry. :-)
10:35:10 <lambdabot>   1
10:35:26 <Cale> Well, sure :)
10:35:33 <Philippa> illissius: GADTs give you existential types
10:35:34 <bitonic> chrisdotcode_: but anyway, the short version is that it lets you reason about infinite things, or things that run forever—for a server you’ll have a starting state and a step bringing it to some new state and maybe some output
10:35:43 <Philippa> they also give you equality constraints
10:35:46 <FreeFull> What you do with a Maybe value really depends on what your goal is
10:35:49 <illissius> Philippa: which is why I said "in a general sense, not the specific GHC extension".
10:35:57 <Philippa> "implementation hiding" is, er, another hidden existential
10:36:08 <Philippa> illissius: in a general sense, they give you an encoding of existentials
10:36:17 <bitonic> and of type equality
10:36:29 <bitonic> you can write functions to coerce stuff
10:36:34 <Philippa> now, "smart constructors+eliminators"? What flavour of smart are we talking about, and are you planning on hiding coercions in there?
10:36:57 <Philippa> because if you are, that's exactly how GHC's back end /used/ to encode them
10:37:01 <illissius> Philippa: ok, then interpret it as "GADTs with only the ability to store/recover equalities, but not to introduce existentials" if that's easier
10:37:11 <illissius> ok, i'll write an example
10:37:38 <Philippa> illissius: you're not going to get interesting examples without existentials encoded somehow, no
10:37:57 <dolio> What about TypeRep?
10:38:10 <Philippa> in that you need to have a "something, I don't know what" for type equalities to have any business telling you something you didn't already know
10:38:18 <elliott> illissius: you cannot do this simple example in H98 without using a trick like finally tagless:
10:38:30 <illissius> Philippa: yeah, that's what I was thinking
10:39:04 <elliott> illissius: data Expr a where { Const :: a -> Expr a; Pair :: Expr a -> Expr b -> Expr (a,b); Fst :: Expr (a,b) -> Expr a; Snd :: Expr (a,b) -> Expr b; Add :: Expr Int -> Expr Int -> Expr Int; Equal :: Expr Int -> Expr Int -> Expr Int; If :: Expr Bool -> Expr a -> Expr a }; eval :: Expr a -> a; ...
10:39:08 <Philippa> you sorta have to go out of your way to 'remove' that from GADTs, though
10:39:16 <Philippa> like, most of us would tell you that's not a proper GADT any more
10:39:18 <elliott> and that involves no existential or rank-2
10:39:21 <elliott> but perhaps I misunderstand your question?
10:40:05 <illissius> I think I should type up something in an hpaste :)
10:40:42 <dolio> Equal returns an Int? Is that a DSL for C?
10:41:00 <illissius> Philippa: yeah fwiw I got to this line of thinking while thinking about encoding GADTs in C++ and realizing "this gains me nothing"
10:41:11 <Philippa> illissius: that's because C++ is fucked :p
10:42:36 <elliott> dolio: haha, whoops
10:43:03 <illissius> it's because C++ doesn't have existentials :) except for subtype-polymorphism and void*
10:45:15 <dolio> If the question is: how useful are the GADTs you can encode using just normal ADTs without existential quantification together with type equality, then maybe the answer is 'not very.'
10:46:23 <dolio> But that is asking a question about one implementation strategy for GADTs.
10:47:01 <dolio> It's a rather odd restriction to put on GADTs implemented directly, for instance.
10:47:59 <dolio> Because it rules out GADTs that don't really look like they have existential quantification, because all variables occur in the result type.
10:48:51 <dolio> Like elliott's Expr type.
10:49:55 <alexander__b> randoms' gen = let (value, newGen) = random gen in value:randoms' newGen -- WTF. anyone care to explain this a bit more in-depth than learn you a haskell does?
10:50:05 <elliott> if you drop Fst/Snd from my type (should have omitted them) you can encode it with equality and no existentials I think
10:50:13 <elliott> oh, I guess Pair isn't doable
10:50:27 <dolio> Right.
10:50:31 <illissius> hmhm
10:50:54 <alexander__b> oh right now I get it
10:51:24 <alexander__b> because random returns a tuple. I shouldn't be learning haskell when I'm sick. too much for my head. :-)
10:51:48 <illissius> elliott: "without using a trick like finally tagless" is a pretty big caveat though isn't it?
10:52:13 <elliott> illissius: well, I don't actually know how you'd do "eval" there with finally tagless, actually.
10:52:40 <dolio> Implement the class with Identity.
10:52:41 <elliott> dolio: anyway if you replace the Pair stuff with some Double functions or something then you still can't do eval without the GADT and it has no existentials :)
10:52:51 <elliott> well, right
10:52:57 <elliott> but then "eval" would get a rank-2 type.
10:52:58 <chrisdotcode_> :t id
10:53:08 <elliott> or... I guess you could define eval :: Identity a -> a; eval = runIdentity
10:53:11 <chrisdotcode_> > id 3
10:53:13 <elliott> but anyway it's not the same thing as doing it with a data type.
10:53:21 <chrisdotcode_> :t repeat
10:53:28 <dolio> The tagless stuff just hides higher-rank types via a type class.
10:53:32 <chrisdotcode_> guys, does lambdabot hate me?
10:53:42 <ion> yes
10:53:47 <chrisdotcode_> figures.
10:53:49 <dolio> If you implemented the dictionary explicitly, it'd be a type with polymorphic components.
10:54:31 <elliott> chrisdotcode_: uh, weird
10:54:34 <elliott> > 123
10:54:44 <chrisdotcode_> elliott: did I break her?
10:54:46 <dolio> Just like 'Functor f => ...' turns into '(forall a b. (a -> b) -> f a -> f b) -> ...' if you pass the dictionary explicitly.
10:55:03 <ion> Break her? I hardly knew her.
10:55:13 <chrisdotcode_> heh.
10:55:17 <elliott> @ping
10:55:31 <elliott> well.
10:55:32 <elliott> @quit
10:55:43 <elliott> what did you doooo.
10:55:56 <chrisdotcode_> elliott: I only asked her about `id`! I swear!
10:56:00 <ion> What did you do { }?
10:56:02 <illissius> one thing that might be making matters murkier for me is that C++ has type classes-ish implicitly (via overloading and so forth)
10:56:06 <illissius> anyway
10:56:30 <illissius> I guess I should try implementing that Expr example without {-# LANGUAGE GADTs #-} and maybe that'll clarify things
10:57:21 <elliott> chrisdotcode_: I have no idea what happened. right now I am waiting for lambdabot to ping out so I can restart it.
10:57:41 <c_wraith> elliott: you're running \bot now?
10:57:46 <chrisdotcode_> elliott: is there a problem with the new host?
10:57:52 <chrisdotcode_> hi, typoclass :)
10:58:09 * typoclass purrs in the general direction of chrisdotcode_
10:58:10 <dolio> In fact, the tagless stuff is exactly using the Church-like encoding of GADTs, and using classes to avoid higher-rank types.
10:58:18 <elliott> c_wraith: yep
10:58:34 <elliott> chrisdotcode_: no, the machine is working perfectly, lambdabot just wasn't doing anything
10:58:40 <elliott> oh, I can just ghost lambdabot
10:59:03 <elliott> wasn't anything weird in the log or anything either
10:59:11 <elliott> > 2
10:59:20 <lambdabot>   2
10:59:36 <chrisdotcode_> :t id
10:59:42 <lambdabot> a -> a
10:59:49 <chrisdotcode_> :t repeat
10:59:56 <lambdabot> a -> [a]
11:00:03 <chrisdotcode_> she's better!
11:00:56 <dolio> imu F a ~ forall r. (forall z. F z -> r z) -> r a, then write the latter as: C r => r a
11:02:07 <functorfun> g'day, wonderfully stupid question.. when one imports Data.Char and uses putStr . show $ chr 32 I get ' '. Good but how do I get ride of the '' marks?
11:02:19 <chrisdotcode_> elliott: what will lambdabot do if you give her something like `repeat 2'?
11:02:30 <ion> @type putChar
11:02:36 <lambdabot> Char -> IO ()
11:02:43 <elliott> > repeat 2
11:02:50 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
11:03:00 <chrisdotcode_> huh, that's clever.
11:03:05 <chrisdotcode_> how is it implemented?
11:03:27 <ion> > take 30 . show $ repeat 2
11:03:32 <lambdabot>   "[2,2,2,2,2,2,2,2,2,2,2,2,2,2,2"
11:03:36 <ion> > text . (++ "...") . take 30 . show $ repeat 2
11:03:42 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
11:04:27 <chrisdotcode_> so each time code is executed, it's composed into take, to give an upper bounds?
11:04:44 <ion> Something like that, i guess.
11:04:44 <elliott> no, the limiting of output is done at a higher level
11:04:55 <elliott> well
11:04:56 <elliott> sort of
11:05:00 <ekipan> > cycle "lo"
11:05:04 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
11:05:07 <elliott> if you do it in /msg that's the string it's working on
11:05:12 <elliott> take 80 is done when you do it in channel
11:05:14 <elliott> but there's limits even in /msg
11:05:23 <chrisdotcode_> elliott: how does it "detect" infinite computations?
11:05:33 <joelteon> it doesn't
11:05:35 <joelteon> it just limits output
11:05:42 <chrisdotcode_> oh, and laziness does the rest
11:05:45 <chrisdotcode_> right?
11:05:45 <Philippa> not true, it also times out
11:05:55 <ion> > fix id
11:05:59 <lambdabot>   mueval-core: Time limit exceeded
11:06:00 <jnerula> :ty mapM_
11:06:01 <Philippa> (and for the black-holeable class, that happens)
11:06:04 <elliott> chrisdotcode_: think of it like this: it reads N bytes from the program. and then it kills it. it also kills it after a few seconds
11:06:05 <joelteon> > replicate 3000 'a'
11:06:06 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
11:06:12 <elliott> there's no haskell-specific magic to how @run works
11:06:17 <elliott> the evaluation is done in a separate process, etc.
11:06:32 <ekipan> please don't refer to lambdabot as an "it", it makes her feel bad
11:06:35 <fizbin> > replicate 3000 "hjkl"
11:06:36 <lambdabot>   ["hjkl","hjkl","hjkl","hjkl","hjkl","hjkl","hjkl","hjkl","hjkl","hjkl","hjk...
11:06:42 <elliott> well, the "magic" is that it can rely on there not being side-effects :)
11:06:46 <chrisdotcode_> elliott: oh, okay. so it just passes the source code into ghc, or does it make a new file, and then chmod that and run it?
11:06:47 <functorfun> does my question make sense? :/
11:06:57 <chrisdone_> haha, someone spammed a big irc log of a serious business argument between them and someone else and ended it with "you're now on public record", and hpaste rejected it as spam. yeahhh
11:07:00 <joelteon> functorfun: don't show
11:07:02 <elliott> chrisdotcode_: it uses mueval
11:07:05 <elliott> @hackage mueval
11:07:05 <lambdabot> http://hackage.haskell.org/package/mueval
11:07:12 <ion> functorfun: Sure, my answer to your question should make sense as well.
11:07:13 <elliott> chrisdotcode_: though I am working on a better eval plugin that uses the GHC API directly to be faster.
11:07:28 <functorfun> ion: where
11:07:34 <functorfun> joelteon: ok
11:07:40 <chrisdone_> mueval uses a hint interpeter and lambdabot loads in an L.hs file for definitions/imports
11:07:49 <ion> functorfun: About two lines after your question.
11:08:29 <chrisdone_> elliott: for tryhaskell i speed it up by keeping the interpreter open
11:08:30 <chrisdotcode_> so lamdabot is running on a... debian box - I'm going to guess?
11:08:34 <joelteon> :t putChar -- functorfun
11:08:35 <lambdabot> Char -> IO ()
11:08:35 <typoclass> functorfun: hello, sorry, missed the question :-) the 'show' function is what adds the '' in this case. you can convert a Char to a String by doing [c], which will not add ''. or you could try putChar
11:08:42 <chrisdone_> elliott: assuming lambdabot still launches a fresh mueval for each @run?
11:08:51 <elliott> chrisdone_: yeah that's the basic idea. i'm basing it on mikeplus64's repl package
11:08:54 <elliott> yeah
11:08:58 <chrisdone_> gotcha
11:09:00 <joelteon> guideline: mention people when showing type signatures
11:09:01 <elliott> it also pipes to ghci for @type :x
11:09:18 <chrisdone_> what syntax is that?
11:09:19 <functorfun> Ah
11:09:21 <ion> repl package, huh? Hadn’t noticed that one.
11:09:29 <bel3atar> no loops in Haskell?
11:09:30 <functorfun> thanks for explaining typoclass
11:09:34 <joelteon> bel3atar: nope, recursion
11:09:37 <ion> @faq Can Haskell do loops?
11:09:37 <lambdabot> The answer is: Yes! Haskell can do that.
11:09:46 <joelteon> but they are equivalent
11:09:55 <elliott> chrisdone_: that :x was a smiley
11:09:58 <chrisdone_> ah, heh
11:10:01 <functorfun> yes sorry ion I missed it because all I saw was the type sig and just entered the channel
11:10:05 <functorfun> thanks though
11:10:27 <chrisdone_> with mueval-interactive (fork of mueval used in tryhaskell) i have:
11:10:27 <chrisdone_> $ mueval-core
11:10:27 <chrisdone_> 3 -> ("3","Num a => a","3")
11:10:27 <chrisdone_> :l x.hs -> "can't find file: x.hs"
11:10:30 <chrisdone_> :t 4 -> (":t 4","Num a => a","")
11:10:31 <lambdabot> parse error on input `->'
11:10:35 <ion> I guess i should have highlighted you.
11:10:37 <chrisdotcode_> @hoogle (a -> b) -> Int
11:10:37 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
11:10:37 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
11:10:37 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
11:10:47 <chrisdotcode_> @hoogle Int -> (a -> b)
11:10:48 <lambdabot> Prelude const :: a -> b -> a
11:10:48 <lambdabot> Data.Function const :: a -> b -> a
11:10:48 <lambdabot> Prelude seq :: a -> b -> b
11:10:49 <chrisdone_> i probably should've merged it upstream, but it was years ago and i was a horrible person
11:11:04 <chrisdotcode_> what's the name of the function that runs a function N times?
11:11:08 <josephle> In the wonderful world of compiling with continuations, everything is just a long jump away. (that's basically a loop, right?)
11:11:25 <functorfun> night all
11:11:40 <chrisdone_> :t iterate
11:11:40 <lambdabot> (a -> a) -> a -> [a]
11:11:47 <chrisdotcode_> chrisdone_: gotcha. thanks
11:11:49 <chrisdone_> nah, not iterate. umm
11:11:54 <chrisdotcode_> no?
11:11:56 <typoclass> elliott: could you turn off the @faq command? i think it's only ever used for confusing beginners or for repetitive jokes. (or even better: it could output "http://www.haskell.org/haskellwiki/FAQ" instead of the current text)
11:12:05 <chrisdone_> you mean the successive one, right? i needed it the other day, can never recall it
11:12:14 <elliott> typoclass: in my development version it already points to the wiki faq :)
11:12:16 <ion> @type \n f -> (!!n) . iterate f
11:12:17 <lambdabot> Int -> (c -> c) -> c -> c
11:12:23 <typoclass> elliott: excellent
11:12:26 <elliott> typoclass: am finishing off @run before putting it on the server and recompiling it all etc. though
11:12:30 <chrisdotcode_> chrisdone_: I've never actually used it, but I'm 1000% sure haskell has one, and I need it.
11:12:36 <typoclass> elliott: sure, no worries :-)
11:12:42 <chrisdone_> chrisdotcode_: what's the type it should be?
11:13:10 <chrisdotcode_> something like: (a -> b) -> Int -> [a], but but it's not quite map
11:13:20 <chrisdone_> :t foldr ($)  -- possible
11:13:21 <lambdabot> b -> [b -> b] -> b
11:13:41 <chrisdotcode_> "run this function x times, and return the results of each time run"
11:13:42 <chrisdone_> > foldr ($) (replicate 3 (*3)) 5
11:13:43 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
11:13:44 <lambdabot>    arising from a use ...
11:13:53 <chrisdone_> > foldr ($) 5 (replicate 3 (*3))
11:13:54 <lambdabot>   135
11:13:59 <elliott> chrisdone_: that's pretty cool
11:14:08 * hackagebot ajhc 0.8.0.6 - Haskell compiler that produce binary through C language  http://hackage.haskell.org/package/ajhc-0.8.0.6 (KiwamuOkabe)
11:14:12 <chrisdone_> yeah i'm not sure there is one for that specifically
11:14:17 <chrisdotcode_> oh, wait... I guess I could just map over a range, huh?
11:14:23 <chrisdotcode_> map [1..x] func
11:14:31 <chrisdotcode_> er, otherway around, but yeah
11:14:42 <ion> > (!!3) . iterate (*3) $ 5
11:14:43 <lambdabot>   135
11:14:57 <ion> > 5 * 3^3
11:14:58 <lambdabot>   135
11:16:02 <chrisdone_> elliott: if you're making a fast replacement that's secure i'll be a guinea pig for you with tryhaskell. need to rewrite the server anyway
11:16:39 <elliott> chrisdone_: I'm mainly just tweaking repl for lambdabot's purposes (and fixing one or two bugs), maybe it can be merged upstream afterwards. repl itself is already on hackage
11:16:49 <ion> Comic Sans D-: https://raw.github.com/ajhc/ajhc/arafura/docs/jhc_compile_flow.png
11:17:12 <elliott> pfft, spj uses comic sans too
11:17:20 <FreeFull> ion: Comic Sans is a fine Haskell tradition
11:17:24 <chrisdone_> ah, i'll check it out
11:17:52 <ion> The ajhc developer should have used yellow-on-blue, yes.
11:22:12 <ion> Fixed http://i.imgur.com/UCKUSA8.png
11:22:15 <pavonia> Hi! Could anyone please check if this bug already has been fixed in gtk2hs 0.12? http://trac.haskell.org/gtk2hs/ticket/1205
11:22:28 <dgpratt> the recent video FP Complete published gave me another excuse to proselytize Haskell amongst my team
11:23:00 <ion> dgpratt: Which one is that?
11:23:28 <dgpratt> ion: https://www.youtube.com/watch?v=Fqi0Xu2Enaw
11:23:31 <ion> thanks
11:23:47 <dgpratt> it was very well received, of course
11:24:20 <dgpratt> although I was not sure what to make of the feedback of one team member: "Best thing about Haskell is its logo. You can always tell how a good a language is by its logo."
11:24:38 <dgpratt> kudos to whomever designed the Haskell logo, I guess
11:25:15 <ion> http://xahlee.info/UnixResource_dir/gki/lambda/HaskellLogo.jpg was so much better.
11:25:33 <dgpratt> ion: gah!
11:26:19 <dgpratt> I appreciate that the logo you linked eschews the current predominant logo style, but it's a bit busy
11:26:52 <dgpratt> btw, I'm referring to the style of modern logos in general, not Haskell specifically
11:27:32 <chrisdone_> the old logo is a stage 2 of the "let's design a logo" meeting
11:27:41 <ion> There are some brilliant ideas in the wiki, too. http://www.haskell.org/wikiupload/7/75/Pure_Devil_Haskell.png
11:28:06 <chrisdone_> stage 1: collect all the concepts related to haskell, stage 2: throw them onto a picture, stage 3: synthesize into a simple iconic graphic
11:28:09 <dgpratt> chrisdone_: that format worked well for designing Haskell itself :)
11:28:13 <chrisdone_> it simply got stuck on stage 2 =p
11:28:28 <dgpratt> ion: oh, goodness
11:28:41 <ion> http://www.haskell.org/wikiupload/7/7b/Haskell.png
11:28:47 <chrisdone_> i liked the 'freedom from state' one
11:29:09 <dgpratt> ion: wat?
11:29:17 <dgpratt> file corruption, perhaps?
11:29:21 <ion> http://www.haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
11:29:24 <typoclass> chrisdone_: bonus points if the "design a logo" meeting does not include a designer?
11:29:35 <chrisdone_> dpwright: it's deviantarty. the squiggly stuff was intentional
11:29:43 <ion> I like how “Haskell.png” in the wiki has been reserved to that one.
11:29:49 <chrisdone_> typoclass :D
11:30:30 <ion> In all seriousness, the current logo is very nice indeed.
11:32:07 <chrisdone_> http://www.haskell.org/wikiupload/e/e0/Haskell_3qhalfinfinitylambda.png was pretty slickk
11:32:17 <ion> “Haskell is a new programming language.” –FP Complete
11:32:34 <chrisdone_> yeah, there were some nice ones but when i saw the chosen one in the line-up i just said "yeah. that's it."
11:32:37 <dgpratt> ion: yeah, I thought that was a strange thing to say, too
11:32:54 <dgpratt> ion: new relative to what? C?
11:33:09 <chrisdone_> haskell's new to the general public of programmers
11:33:26 <dolio> Relative to lots of stuff. :)
11:33:35 <dgpratt> chrisdone_, no argument there
11:34:02 <chrisdone_> whereas ruby and python are 'old'. ruby, omg, that's, like, so five minutes ago
11:34:04 <ion> “was able to get to market in less than half the time by using Haskell” – Compared to what? Measured how?
11:34:36 <ion> “Less than half” is meaningless by itself.
11:35:07 <dgpratt> ion: I think this video has a certain audience in mind and it is not us
11:35:09 <sm> dgpratt: nice video, thanks
11:35:56 <sm> NO ROOM FOR BUGS! :)
11:35:57 <chrisdone_> dgpratt: yeah that's an important qualification, this video isn't aimed at haskellers. it's aimed at managers of java or c++ companies
11:36:42 <chrisdone_> i find the description of haskell to sound a bit too much like prolog, but it gets the point across
11:37:49 <Hafydd> Hahah: http://www.haskell.org/wikiupload/f/f3/UnsafeHaskell.png
11:37:58 <dgpratt> chrisdone_, yes, I think I know what you mean...although I didn't think it or know it when I watched the video
11:38:18 <dgpratt> Hafydd: :)
11:39:56 <dgpratt> I think it's very hard to get certain points across in a way that is both meaningful and accurate
11:42:04 <chrisdone_> elliott: hmm does the repl package handle let r = r in r and length [1..]? there were some other tests in the past where having mueval-core a separate process is important for ulimits. i'd be a bit suspicious that it's as well sandboxed as mueval
11:42:27 <chrisdone_> ah it seems to not actually be a sandbox itself
11:43:19 <tazjin> I've been trying to find info about what is blocking Hackage2 from really going live, is there a project status page somewhere that I'm just unable to find?
11:43:21 <chrisdone_> so i guess you'll be launching as a separate process like mueval and apply ulimits and such
11:44:01 <pavonia> No one here with gtk2hs 0.12.* installed?
11:44:10 <dmwit> ?where justask
11:44:10 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
11:44:11 <chrisdone_> tazjin: information is generally scant on that
11:44:48 <tazjin> chrisdone_: Hmm, wonder why :(
11:44:55 <elliott> chrisdone_: it handles timeouts
11:45:17 <elliott> chrisdone_: heap exhaustion currently will require setting limits on the actual server process and restarting it, afaik, yes
11:45:25 <dmwit> pavonia: Okay, I scrolled up to find your question.
11:45:25 <byorgey> tazjin: http://hackage.haskell.org/trac/hackage/wiki/HackageDB/2.0
11:45:31 <elliott> "let r = r in r" timeouts correctly I think
11:45:35 <dmwit> pavonia: If the bug is still on the tracker, it is almost certainly not fixed yet.
11:45:41 <byorgey> tazjin: no idea how current it is
11:45:50 <tazjin> byorgey: Yes I saw that site, it actually says "This section is all out of date!" on the TODO part
11:45:51 <pavonia> dmwit: Okay, too bad
11:45:54 <elliott> chrisdone_: does your mueval-interactive handle this stuff?
11:45:56 <byorgey> tazjin: hehe, good point
11:46:03 <chrisdone_> elliott: sure. yeah, i found that different times of exprs would trigger different limits
11:46:05 <dmwit> pavonia: (I've tried to close all the bugs that are already fixed.)
11:46:11 <byorgey> tazjin: well, probably dcoutts or Igloo would know more
11:46:17 <byorgey> or maybe Gracenotes
11:46:22 <pavonia> dmwit: Are you one of the developers?
11:46:35 <dmwit> I am.
11:47:08 <elliott> chrisdone_: but yeah, i'd definitely be interested in seeing your code
11:47:34 <chrisdone_> elliott: yeah it's just mueval that doesn't end when you complete a command, but it's not a complete solution. tryhaskell's server has some code to launch the subprocess and kill it when it's not responding and such. at the time when many people were hitting it i was discovering many ways in which it could fail, and patching it a lot
11:47:48 <chrisdone_> elliott: ah, it's not so clean, but hold up
11:47:53 <chrisdone_> https://github.com/chrisdone/mueval-interactive
11:48:22 <chrisdone_> https://github.com/chrisdone/haskell-json/blob/master/haskell-json.hs#L266
11:49:00 <pavonia> dmwit: Do you know any workaround by chance? :)
11:49:05 <elliott> chrisdone_: cool
11:49:13 <dmwit> I haven't really looked at the bug yet.
11:49:42 <elliott> chrisdone_: I hear GHC 7.8 might be getting per-thread memory limits
11:49:50 <chrisdone_> elliott: i don't really remember the "why"s of this code, much. i'm sure you've got it covered, was just sharing that i was regularly surprised by how tryhaskell would die
11:49:53 <chrisdone_> oh that's cool
11:49:54 <elliott> chrisdone_: so with any luck, it can be done without a separate server that gets restarted
11:49:59 <chrisdotcode_> guys, let's say I have a data type: Person = Name Age. should I make type aliases for Name = String and Age = Int, or should I use record syntax for the data type?
11:50:20 <chrisdotcode_> what's more idiomatic?
11:51:03 <Cale> chrisdotcode_: It depends on whether you want to control which string values are used as names, for instance.
11:52:06 <chrisdotcode_> Cale: names generally all sorts of weird things, so in this case, assuming it could be any string that didn't have a number in it. is it better to type alias (after sanitizing)?
11:52:58 <elliott> chrisdone_: another thing lambdabot has to deal with is persistence of definitions etc.
11:54:02 <Cale> Using 'type' doesn't matter so much, and usually I'd just avoid it unless I was sick of typing the original name of a type -- it tends to just make it more confusing what operations can be applied to things rather than really being helpful.
11:54:32 <Cale> But 'newtype' can be good for type safety in that regard if you want to control things and make sure that data is sanitized.
11:54:43 <chrisdone_> elliott: right. tryhaskell's api has a load command to load in a file either statefully or as an argument to eval in a more referentially transparent way. but i don't support definitions like in ghci. that would be nice although i guess it's easily doable with lambdabot because there's only one user
11:55:03 <chrisdotcode_> Cale: I agree, but at the same time, data Person = String Int needs comments, as opposed to Person = Name Age
11:55:10 <chrisdotcode_> but nevertheless, the former is better?
11:55:17 <elliott> chrisdone_: well, I'd like to give local definition support actually
11:55:22 <elliott> but not an immediate plan
11:55:43 <elliott> chrisdotcode_: uh... neither of those probably does what you want
11:55:48 <Cale> data Person = String Int  would define a type Person with a single constructor called String which takes a single parameter of type Int
11:55:53 <chrisdone_> so @let in lambdabot adds to L.hs right?
11:56:19 <chrisdone_> elliott: 'local'?
11:56:29 <elliott> chrisdone_: as in per-user
11:56:39 <chrisdone_> on irc? that'd be nice =)
11:56:39 <chrisdotcode_> elliott, Cale: er, right. okay, so is data Person = Person String Int or data Person = Person Name Age better
11:56:41 <chrisdotcode_> ?
11:56:41 <elliott> yeah @let just does some parsing checks and puts it in L.hs
11:56:46 <chrisdone_> right. how does @undef work?
11:56:53 <elliott> chrisdone_: it copies Pristine.hs to L.hs
11:56:59 <Bor0> what's a good haskell t-shirt merchandise site that ships to Macedonia? most sites I checked do not :(
11:57:11 <chrisdone_> elliott: hmm but you can undef specific names right?
11:57:20 <elliott> chrisdotcode_: data Person = Person { name :: String, age :: Int } is a middle ground
11:57:20 <Cale> chrisdotcode_: They're equivalent...
11:57:33 <elliott> chrisdone_: nope.
11:57:36 <elliott> but you will be able to.
11:57:45 <Cale> But yeah, I would usually define a type like that one using record syntax
11:58:10 <chrisdotcode_> record syntax was what it was going to be initially, but it seemed too verbose at first, where as two type aliases are much clearer, IMO.
11:58:40 <chrisdotcode_> but I have no idea, that's why I"m asking you guys :)
12:00:00 <chrisdone_> elliott: ahhh... yeah that's why i never added defs to tryhaskell. i wanted to parse "let x = 1" as "do let x = 1; return ()" with hse and then add that to the file, so it would be like ghci. but i couldn't figure out how to rebind x afterwards
12:00:00 <chrisdone_> elliott: one approach i implemented was every let x = .. would become part of a context so that let y = ..; let z = ..; and then 1 would really be let y = .. in let z = .. in 1, but i must've done a bad implementation because it didn't work well
12:00:56 <chrisdone_> (and that also sucked as it would re-eval every binding time..)
12:01:13 <chrisdone_> elliott: how will you do it?
12:01:30 <chrisdone_> or does repl support it out of the box..
12:01:38 <chrisdone_> hmmm i'm gonna install it
12:02:07 <elliott> chrisdone_: well, repl just runs it as a statement
12:02:13 <elliott> it basically has a "running GHCi"
12:02:46 <elliott> note that repl doesn't quite handle exceptions very well out of the box. that's one of the things I've fiddled with when hacking it up
12:04:22 <chrisdone_> yeah
12:05:18 <chrisdone_> what's wrong with its exception handling?
12:06:30 <johnw> until it comes back, I have a mirror of comonad.com up here: http://comonad.newartisans.com
12:06:33 <chrisdone_> installing it now. this coincides nicely, i was just recently thinking about replacing ghci with a haskell program that would do ghci-ish stuff + more
12:06:58 <elliott> chrisdone_: uh, it basically doesn't work
12:07:00 <johnw> it's a touch old
12:07:06 <elliott> chrisdone_: heh, I was thinking about that too
12:07:11 <chrisdone_> elliott: =D
12:07:19 <elliott> chrisdone_: I was going to base it on lambdabot, since it's growing better command-line support
12:07:28 <elliott> and is installable without pulling your hair out these days
12:08:17 <chrisdone_> really i want something scion-ish, so that emacs can talk to the repl more 'directly' rather than doing regex matching on the prompt and nonsense like that
12:09:08 <chrisdone_> if you do forkIO $ print "hello". it might sometimes reply with "hello\n> " or it might reply with "hell\n >o", that's just naaaasty
12:10:18 <chrisdone_> elliott: you mean it'll have lambdabot plugins?
12:11:04 <elliott> chrisdone_: well, it'd be cool to have @djinn and @pl, so I figure why not :)
12:11:21 <elliott> and @free
12:11:32 <chrisdone_> =)
12:12:14 <elliott> mainly I wanted (a) fancy colours (b) better handling of definitions (c) better integration with the "file + ghci" workflow and (d) automatic reloading
12:14:02 <chrisdone_> whats' the file + ghci workflow?
12:15:26 <elliott> chrisdone_: as in the "edit a file a bunch and :r a lot" thing
12:15:35 <elliott> something more lisp-style, as opposed to working mainly in the repl
12:15:42 <phulin> I have a long computation that runs inside a state monad. Is there any way to use laziness or similar to display progress? Or do I have to use trace?
12:15:59 <phulin> Other than putting the hwole thing inside IO
12:16:03 <phulin> which I'd rather not do.
12:16:18 <c_wraith> displaying progress depends on being able to observe progress
12:16:36 <chrisdone_> elliott: yeah, given a "REPLPrint" class or Data/Typeable-derived function or something like that, from emacs i'll be able to receive a sexpr of the value you just evaluated and print that as a tree that can be expanded-collapsed. i kinda have that, similar, already, but i do it by parsing show's output, which sucks/is unreliable
12:16:36 <phulin> sure
12:16:40 <acube> @ty _1
12:16:40 <c_wraith> being able to observe progress depends on constructors being produced
12:16:40 <lambdabot>     Not in scope: `_1'
12:16:41 <lambdabot>     Perhaps you meant `_2' (line 137)
12:16:44 <chrisdone_> elliott: ah, sure
12:16:50 <phulin> c_wraith, I currently just trace something every 10,000 data points
12:16:57 <xico> @src _2
12:16:57 <lambdabot> Source not found. My mind is going. I can feel it.
12:17:05 <xico> @ty _2
12:17:06 <lambdabot> Functor f => (a -> f b) -> (e, a) -> f (e, b)
12:17:09 <tazjin> So how do you actually contribute to a darcs repo hosted on code.haskell.org? (Specifically Hackage 2 in this case). I've never really used darcs before due to its speed.
12:17:13 <chrisdone_> elliott: i do that from emacs (of course). i'm guessing you're on vim so you want that the repl will refresh without having to do anything other than save in vim?
12:17:16 <phulin> i tried just adding a field inside IO to my state, but that was not actually a good idea
12:17:20 <c_wraith> Can you structure your computation such that it periodically produces a data constructor that says "still working, estimating some % complete, here's the remainder of the computation"?
12:17:35 <elliott> chrisdone_: right. even in emacs C-x C-s C-c C-l is too much :P
12:17:57 <chrisdone_> elliott: i just hit F5 which is the equivalent =p
12:18:21 <phulin> Maybe.
12:18:52 <c_wraith> that's the only pure approach to getting progress reports out of an ongoing calculation
12:19:09 <elliott> chrisdone_: pfft, visual studio user
12:19:14 <c_wraith> Everything else relies on IO or, even worse, unsafePerformIO
12:19:42 <phulin> Okay, I think I see what you mean.
12:19:55 <phulin> I think that's possible, yeah.
12:20:40 <phulin> define a new StateProgress = Lift (State S) | Progress Float (State S), something like that?
12:20:40 <chrisdone_> elliott: haha, takes one to know one!
12:21:51 <Botje> how about State S [Float] ?
12:21:56 <c_wraith> phulin: well, it needs to be recursive
12:22:02 <phulin> oh right
12:22:08 <phulin> yeah Progress Float StateProgress
12:22:17 <c_wraith> Yeah, that looks right
12:22:39 <phulin> and then the Progress constructors would build up on the outside as they accumulated
12:22:51 <c_wraith> No, the other way around
12:22:57 <c_wraith> The first one is the outermost
12:23:07 <c_wraith> They build up *inside*, coinductively
12:23:22 <c_wraith> That's taking advantage of lazy evaluation
12:23:26 <phulin> right that's what i meant
12:24:15 <phulin> Hopefully that won't be much of a performance penalty
12:24:24 <c_wraith> Depends on how you structure things
12:24:40 <c_wraith> one important note is that computation will actually halt when you produce one of these constructors
12:24:52 <c_wraith> so if you don't consume it immediately, it will slow things down a lot
12:25:12 <phulin> Right, I"m not planning on producing many of them
12:25:19 <phulin> maybe like one every 1% of computation
12:25:30 <phulin> and then the output inside main will go directly into the pattern-match
12:25:35 <phulin> that prints out the stuff
12:25:47 <c_wraith> That sounds good.
12:26:15 <phulin> awesome, thanks.
12:26:16 <c_wraith> The last trick is making sure that you can actually produce these incrementally.  It might require working in Lazy state, rather than strict
12:26:45 <sepp2k> Does anybody know when and where the term "functional programming" was coined?
12:27:07 <phulin> I'm already working in lazy state
12:27:10 <phulin> maybe i shouldn't be
12:27:40 <c_wraith> sepp2k: That's a great question. My guess is it's got something to do with the ACM presentation "Can programming be liberated from the von neumann modal?", or so.
12:28:31 <c_wraith> *model
12:28:44 <c_wraith> totally different from modal.  I'm not even doing UI programming!
12:28:54 <Sonarpulse> anyway to do an "opaque" type via ffi
12:29:06 <Sonarpulse> can only pass it to other C, and copy it?
12:29:22 <c_wraith> Sonarpulse: copy?
12:29:28 <Sonarpulse> well at least pss
12:29:30 <Sonarpulse> *pass
12:29:38 <Sonarpulse> certainly not deconstruct it
12:29:40 <sepp2k> c_wraith: Thank you.
12:29:42 <c_wraith> If you just want a type you can pass around, it's quite common to make an empty data type
12:29:45 <Sonarpulse> ok
12:29:58 <Sonarpulse> newtype thing = thing ()
12:30:12 <c_wraith> data Foo ; newtype CThing = CThing (Ptr Foo)
12:30:24 <mauke> newtype Wtf = Wtf (Ptr Wtf)
12:30:40 <c_wraith> I guess that does compress it to one line, but ouch my brain
12:31:43 <c_wraith> Actually, the more I think about it, the more that seems like a fine idiom.  If...  uh...  bizarre.
12:31:54 <c_wraith> (on the first read)
12:34:45 <Sonarpulse> ah ok
12:37:48 <agocorona>  /join #haskell-web
12:39:56 <JoeyA> Why doesn't Storable have tuple instances?
12:40:07 <JoeyA> e.g. instance (Storable a, Storable b) => Storable (a, b) where
12:40:38 <c_wraith> Storable is generally for things there is a sane C representation of.
12:41:03 <c_wraith> Tuples would map to anonymous structs, which don't really exist in C
12:41:07 <johnw> c_wraith: well, you could think of it like a struct { type x; type y }
12:41:13 <JoeyA> Right
12:41:32 <JoeyA> Note: adding such an instance to base would cause compatibility problems at the moment
12:41:50 <JoeyA> the network package currently has instance Storable (Word32, Word32, Word32, Word32) (for HostAddress6)
12:43:17 <edwardk> JoeyA: because of alignment
12:43:31 <edwardk> JoeyA: if Storable didn't bundle alignment it'd be tuplable
12:43:58 <JoeyA> Can't the alignment of the whole be inferred, though?
12:44:19 <johnw> you mean, by picking the largest?
12:44:28 <edwardk> JoeyA: if you have something that needs 4 byte alignment followed by something with 8 byte alignment, do you need 8 byte alignment and then waste 4 bytes in the middle?
12:44:56 <edwardk> that sort of thing starts happening with no type to witness the alignment, so you need a lot more information and the instances become rather convoluted
12:45:06 <Andrea_> what does mapm with a list ?
12:45:18 <edwardk> Andrea_: ?
12:45:53 <JoeyA> :t mapM (\x -> [x+10, x+20])
12:45:53 <lambdabot> Num b => [b] -> [[b]]
12:45:54 <Andrea_> i know what map does with a list
12:46:06 <JoeyA> > mapM (\x -> [x+10, x+20]) [1,2,3]
12:46:07 <lambdabot>   [[11,12,13],[11,12,23],[11,22,13],[11,22,23],[21,12,13],[21,12,23],[21,22,1...
12:46:24 <edwardk> > mapM (\x -> Just (x + 1)) [1..10]
12:46:26 <lambdabot>   Just [2,3,4,5,6,7,8,9,10,11]
12:47:57 <Andrea_> thx
12:49:21 <Andrea_> > map \x -> x+1 [1..5]
12:49:23 <lambdabot>   <hint>:1:5: parse error on input `\'
12:49:34 <Andrea_> > map (\x -> x+1) [1..5]
12:49:35 <lambdabot>   [2,3,4,5,6]
12:50:05 <Andrea_> mapm (\x -> x+1) [1..5]
12:50:14 <Andrea_> >mapm (\x -> x+1) [1..5]
12:50:24 <Hafydd> > mapm (+1) [1..5]
12:50:27 <lambdabot>   Not in scope: `mapm'
12:50:27 <lambdabot>  Perhaps you meant one of these:
12:50:27 <lambdabot>    `mapM' (imported f...
12:50:32 <Andrea_> >mapM (\x -> x+1) [1..5]
12:50:38 <Hafydd> You need a space.
12:50:39 <chokotsis> I want somebody to shit in my mouth
12:50:46 <chokotsis> namely to tie somebody up to a chair with a hole in the bottom
12:50:47 <JoeyA> Need a leading space after the >
12:50:51 <chokotsis> forcefeed him corn, peanuts, and laxatives
12:50:58 <JoeyA> !scaryadmincommand chokotsis
12:51:01 <chokotsis> then stick my head underneath to wait for the liquid yummies
12:51:05 <chokotsis> oh yeah
12:51:14 <chokotsis> then after consuming the yummy diarrhea
12:51:14 --- mode: ChanServ set +o elliott
12:51:16 --- mode: elliott set +b *!*bb93a254@*.187.147.162.84
12:51:16 --- kick: chokotsis was kicked by elliott (chokotsis)
12:51:18 --- mode: elliott set -o elliott
12:51:21 <kartlos> why is a functor called a functor? wouldn't a name like container be a bit less intimidating? :-)
12:51:23 <JoeyA> Sweet, it worked
12:51:26 <JoeyA> thanks, elliott
12:51:28 <Botje> protontorpedo was much funnier.
12:51:29 <elliott> JoeyA: try @where ops in future :)
12:51:35 <JoeyA> Thanks
12:51:46 <Taneb> kartlos, not all Functors are containers
12:51:58 <Taneb> (eg, IO, State, Proxy)
12:52:00 <JoeyA> !quote IO
12:52:03 <Taneb> But all Functors are Functors
12:52:07 <JoeyA> @quote IO
12:52:07 <lambdabot> dmwit says: "Functional programming" is a technical term that means more than just what the two words mean separately.
12:52:07 <mauke> (e ->)
12:52:19 <JoeyA> @quote contains
12:52:19 <lambdabot> astrolabe says: I put my thing in inverted commas because it isn't a really stalactite, but it looks like one, and contains nitrates from urea.
12:52:22 <JoeyA> nvm, sorry
12:52:22 <kartlos> Taneb: guess I my understanding of Functor is lacking then
12:52:38 <Andrea_> >mapM  (\x -> x + 1) [1..5]
12:52:53 <JoeyA> put a space after the > and m
12:52:53 <typoclass> Andrea_: try it with a space after ">"
12:52:54 <phulin> c_wraith, I'm having trouble writing the Lift half of bind
12:52:55 <tazjin> "The password file could not be updated. Trac requires read and write access to both the password file and its parent directory.
12:53:07 <tazjin> http://hackage.haskell.org/trac/hackage/register <- this is broken
12:53:09 <tazjin> Who is responsible?
12:53:22 <c_wraith> phulin: can you put what you've got, or maybe some representative example, on hpaste?
12:53:30 <Andrea_> > mapM  (\x -> x + 1) [1..5]
12:53:32 <lambdabot>   No instance for (GHC.Show.Show (m0 [b0]))
12:53:32 <lambdabot>    arising from a use of `M107194...
12:53:34 <phulin> i think i can try to explain
12:53:55 <phulin> I have x :: State S a, and f :: a -> Progress b
12:53:57 <Andrea_> :t mapM
12:53:58 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
12:54:03 <JoeyA> Andrea_: not a helpful error message in this case.
12:54:20 <typoclass> quchen: ohai. are you on the haskell-infrastructure list? trac is borked ^^
12:54:23 <JoeyA> Andrea_: The problem is that x + 1 is not an "action" in any monad.
12:54:30 <xico> i am configuring my code with "cabal configure --enable-executable-profiling", building with "cabal build", but when running it with "+RTS -p" it complains that it is not compiled with profiling enabled. passing ghc-options directly in the .cabal file works though (although with a warning that i should use --enable-executable-profiling). any idea on what might go wrong?
12:54:44 <Andrea_> i saw an example mapM with lists but i don't understand this
12:54:45 <phulin> I'm not sure how to get to Progress b
12:54:47 <SaBer> I'm trying to make a rational with "%" but I'm getting "Not in scope: `%'"  (and that error is impossible to goole)
12:54:51 <JoeyA> if you said mapM (\x -> readFile (show x)) [1..5], it would be well-typed
12:55:04 <elliott> SaBer: import Data.Ratio (I suggest using / instead of %)
12:55:06 <JoeyA> Andrea_: do you understand what that would do?
12:55:07 <elliott> 1/2 :: Rational works fine
12:55:13 <JoeyA> :t mapM (\x -> readFile (show x)) [1..5]
12:55:13 <lambdabot> IO [String]
12:55:41 <quchen> typoclass: Hm? No I'm not
12:55:53 <phulin> c_wraith, I need to pattern-match on the output of f, but I can only do that inside the State monad, not inside the Progress monad.
12:55:56 <Andrea_> JoeyA: no
12:55:58 <typoclass> quchen: alright. i thought you were
12:56:14 <JoeyA> Andrea_: it would read files whose names are "1", "2", "3", "4", "5"
12:56:17 <c_wraith> phulin: oh, for this to work, you would need the expression you run to be like State S (Progress b)
12:56:19 <JoeyA> and return the content of each in a list
12:56:30 <quchen> typoclass: Nope, only on ghc-devs and libraries. Mainly for the AMP. And to look for what's coming up :-)
12:56:37 <JoeyA> The show is needed to convert from integer to String
12:56:41 <c_wraith> phulin: and then you need to be very careful to not look at the state return of runState until after the Progress portion has completed
12:56:47 <typoclass> sclv: ping
12:56:58 <SaBer> elliott: thanks
12:57:01 <JoeyA> In IO, mapM is like "foreach"
12:57:14 <JoeyA> It does something for each item in the list, and returns a list of the results.
12:57:48 <Andrea_> JoeyA: ok, i saw an exapmple without actions , only with lists
12:58:03 <nooodl> > mapM (\c -> [toLower c, toUpper c]) "abc"
12:58:04 <typoclass> tazjin: thank you for the heads-up. that is clearly wrong. could you report the problem to this mailing list? i *think* it's the right place, or if not, they can forward it http://community.galois.com/mailman/listinfo/haskell-infrastructure
12:58:04 <lambdabot>   ["abc","abC","aBc","aBC","Abc","AbC","ABc","ABC"]
12:58:07 <Andrea_> http://en.literateprograms.org/Eight_Queens_puzzle_%28Haskell%29
12:58:18 <JoeyA> In the list case, the list can be thought of (if you bend your brain just enough) as an "action".
12:58:23 <Andrea_> on this page
12:58:41 <JoeyA> > do a <- [1,2]; b <- [3,4]; return (a,b)
12:58:42 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
12:58:44 <tazjin> typoclass: I like how nobody is really sure how things are organized! I can do that in a few minutes
12:59:17 <JoeyA> @src sequence
12:59:17 <lambdabot> sequence []     = return []
12:59:17 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:59:17 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
12:59:21 <JoeyA> @src mapM
12:59:21 <lambdabot> mapM f as = sequence (map f as)
12:59:29 <sclv_> tazjin: missing context -- what the issue is?
12:59:33 <sclv_> typoclass: pong
12:59:36 <Andrea_> is a list of list a monad ?
12:59:36 <typoclass> tazjin: yeah ... there's tons of that stuff. trac here, mediawiki there, various people running various websites ... :-)
12:59:56 <JoeyA> List is a monad.
13:00:07 <sclv_> aha, broken hackage trac
13:00:11 <typoclass> sclv: ohai! do you know about haskell-infrastructure? apparently people can't register users on a hackage trac. see above
13:00:22 <JoeyA> [a] is a monadic "action" that "returns" a of type a
13:00:56 <JoeyA> Though what really happens is, it walks through the list, and for each item, runs the remainder of the computation with that item.
13:01:19 <sclv_> haha the hackage trac is on abbot. i've been largely worried about our other two servers.
13:01:32 <sclv_> i'll forward this one on for now to -infrastructure as well
13:01:49 <typoclass> sclv_: thanks for doing the work! we all appreciate it
13:01:51 <JoeyA> > mapM (\c -> [toLower c, toUpper c]) "abc" == sequence (map (\c -> [toLower c, toUpper c])) "abc"
13:01:52 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]
13:01:53 <lambdabot>                            ...
13:02:04 <typoclass> (not just this trac issue, obviously)
13:02:52 <nooodl> the list monad essentially does what list comprehensions do
13:03:01 <JoeyA> > mapM (\c -> [toLower c, toUpper c]) "abc" == sequence (map (\c -> [toLower c, toUpper c]) "abc")
13:03:02 <lambdabot>   True
13:03:14 <JoeyA> > map (\c -> [toLower c, toUpper c]) "abc"
13:03:15 <lambdabot>   ["aA","bB","cC"]
13:03:35 <JoeyA> > sequence ["aA","bB","cC"]
13:03:36 <lambdabot>   ["abc","abC","aBc","aBC","Abc","AbC","ABc","ABC"]
13:03:37 <tazjin> sclv_: So you've mailed -infrastructure now? Then I won't do it again.
13:04:15 <JoeyA> > [[x,y,z] | x <- "aA", y <- "bB", z <- "cC"]
13:04:16 <lambdabot>   ["abc","abC","aBc","aBC","Abc","AbC","ABc","ABC"]
13:04:18 <sclv_> tazjin: investigating a bit more to see if it affects the other tracs on hackage
13:04:21 <sclv_> then going to fire off an email
13:04:28 <sclv_> they've been notoriously irritating
13:04:31 <sclv_> and undermaintained
13:04:33 <JoeyA> > do x <- "aA"; y <- "bB"; z <- "cC"; return [x,y,z]
13:04:34 <lambdabot>   ["abc","abC","aBc","aBC","Abc","AbC","ABc","ABC"]
13:04:39 <sclv_> i think guest/guest works on the ghc trac at least
13:04:48 <sclv_> you might be able to use it for cabal too at the moment -- not sure
13:05:06 * typoclass . o O ( let's just rewrite trac in haskell ;-)   )
13:05:18 <sclv_> ah, guess not
13:06:04 <JoeyA> Andrea_: sequence for lists does combinations
13:06:14 <JoeyA> > sequence [[0,1], [0,1], [0,1]]
13:06:15 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
13:06:45 <Andrea_> >sequence [1,2,3]
13:06:52 <Andrea_> > sequence [1,2,3]
13:06:53 <lambdabot>   No instance for (GHC.Show.Show (m0 [a0]))
13:06:53 <lambdabot>    arising from a use of `M115403...
13:06:57 <JoeyA> The items themselves have to be lists
13:07:11 <JoeyA> > sequence [readFile "foo", readFile "bar"]
13:07:12 <lambdabot>   <IO [[Char]]>
13:07:16 <Andrea_> > sequence [1,2],[1,3]]
13:07:17 <lambdabot>   <hint>:1:15: parse error on input `,'
13:07:24 <Andrea_> > sequence [[1,2],[1,3]]
13:07:25 <lambdabot>   [[1,1],[1,3],[2,1],[2,3]]
13:08:27 <Andrea_> i read this in an example "queens n = foldM f [] [1..n] where"
13:08:28 <JoeyA> mapM f xs = sequence (map f xs), so mapM just applies a function to the list items, then does combinations on the resulting list of lists.
13:08:35 <typoclass> > sequence ["ab", "xy"] -- Andrea_: maybe this is a little clearer
13:08:36 <lambdabot>   ["ax","ay","bx","by"]
13:09:48 <Andrea_> typoclass, yes , now i understand sequences
13:10:18 <Andrea_> but i asked about mapM and lists
13:10:41 <nooodl> @src mapM
13:10:42 <lambdabot> mapM f as = sequence (map f as)
13:11:15 <dmwit> mapM takes a nondeterministic function and returns a the result of applying that function to each of the elements in the list (nondeterministically).
13:11:18 <typoclass> Andrea_: well done :-) though that's not really 'sequences', it's the list monad, i.e. the instance of typeclass Monad that handles []. 'sequence' is a simple helper function that works on any monad
13:11:21 <typoclass> @type sequence
13:11:22 <lambdabot> Monad m => [m a] -> m [a]
13:11:32 <JoeyA> Andrea_: Do you understand what mapM and foldM do in IO?
13:11:48 <typoclass> Andrea_: sorry, what was your original question about mapM?
13:11:56 <JoeyA> Learning what they do in IO can help you use analogy to understand list monad code.
13:12:21 <Andrea_> typoclass, my first question was "wat does mapM with lists"
13:12:22 <JoeyA> :t mapM
13:12:22 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
13:12:44 <sclv_> typoclass, tazjin : reported. i imagine it will be fixed over the next couple days.
13:12:46 <sclv_> thx.
13:12:51 <JoeyA> Substituting IO for m: (a -> IO b) -> [a] -> IO [b]
13:12:54 <typoclass> sclv_: thank you
13:13:14 <JoeyA> Substituting [] for m: (a -> [] b) -> [a] -> [] [b]
13:13:21 <JoeyA> Yes, that's valid Haskell, believe it or not.
13:13:28 <JoeyA> [] a is the same as [a]
13:13:29 * dmwit believes it!
13:13:43 <JoeyA> (a -> [b]) -> [a] -> [[b]]
13:13:47 <JoeyA> That's mapM for lists
13:14:30 <Luke> I made a new Haskell YASnippet collection if anyone is interested: http://www.reddit.com/r/haskell/comments/1gof00/extensive_new_haskell_yasnippet_emacs_collection/
13:16:26 <byorgey> Luke: nice
13:16:31 <Andrea_> oh, i made a big mistake, sorry, in the program was not mapM , there was foldM :(
13:16:45 <johnw> Luke: thank you
13:16:48 <JoeyA> Andrea_: do you know what foldM does in IO?
13:16:53 <JoeyA> :t foldM
13:16:53 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
13:17:05 <JoeyA> (a -> b -> IO a) -> a -> [b] -> IO a
13:17:35 <JoeyA> Here's the documentation: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#v:foldM
13:17:37 <Andrea_> i know what foldl and foldr makes with lists
13:17:53 <JoeyA> I recommend bookmarking Hoogle: http://www.haskell.org/hoogle/
13:18:04 <JoeyA> so you can look up documentation easily
13:18:40 <JoeyA> @src foldM
13:18:40 <lambdabot> foldM _ a []     = return a
13:18:40 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
13:18:41 <ion> luke: Neat. I should get around to learning emacs one day. :-P
13:18:52 <johnw> Luke: installed, and working great :)
13:19:17 <Andrea_> foldM with lists
13:19:19 <Luke> awesome. i tested them a ton
13:19:29 <Luke> I was never really happy with what was out there before
13:19:33 <johnw> Luke: I'm not sure I really see the purpose of the non-qualified import, though
13:19:39 <Luke> I use that one all the time
13:19:39 <johnw> if I've already type import, I'm "there" so to speak
13:19:58 <Luke> nah I like to space it out and optionally put the (function)
13:20:03 <JoeyA> Andrea_: understanding what it does for IO first will help you think about what it does for list, IMO.
13:20:04 <Luke> i explicitly import all my functions is why
13:20:04 <johnw> I think I'll make it so that "imp" expands to import, and import is qualified
13:20:09 <johnw> ah
13:20:34 <Luke> it should allow you to pick between the import types
13:20:38 <Luke> yasnippt should that is
13:20:46 <johnw> it does, but that's really not fun with my workflow
13:21:04 <Luke> i use ido mode integration so it's fast for me
13:21:07 <Andrea_> JoeyA, ok, I thought fold is only for lists
13:21:17 <johnw> yeah, right now yasnippet is popping up a graphical menu
13:21:19 <JoeyA> foldl is.
13:21:29 <Luke> johnw: oh yeah definitely change that
13:21:33 <johnw> what's the config var?
13:21:41 <Luke> lemme check
13:21:44 <JoeyA> foldM lets you traverse a list from left to right with an accumulator.
13:21:46 <Andrea_> :t foldM
13:21:47 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
13:22:11 <JoeyA> :t foldM (a x -> return (a+x)) [1..10]
13:22:12 <lambdabot>     Pattern syntax in expression context: a x -> return (a + x)
13:22:19 <JoeyA> :t foldM (\a x -> return (a+x)) [1..10]
13:22:19 <johnw> Luke: I wonder if yasnippet can allow you to ido-select from all the possible LANGUAGE pragmas
13:22:19 <lambdabot> (Enum t, Monad m, Num [t], Num t) => [[t]] -> m [t]
13:22:22 <Andrea_> like reverse ?
13:22:26 <JoeyA> lol, so much context
13:22:34 <Luke> johnw: (setq-default yas-prompt-functions '(yas-ido-prompt yas-dropdown-prompt)) ; use ido for multiple snippets
13:22:36 <JoeyA> @src reverse
13:22:37 <lambdabot> reverse = foldl (flip (:)) []
13:22:48 <JoeyA> > foldM (\a x -> return (a+x)) [1..10]
13:22:49 <Luke> johnw: that's a great idea!
13:22:50 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable1 m0)
13:22:50 <lambdabot>    arising from a use...
13:22:58 <JoeyA> > foldM (\a x -> return (a+x)) [1..10] :: [Int]
13:22:59 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
13:22:59 <lambdabot>              with actual typ...
13:23:03 <JoeyA> pfft, I quit
13:23:11 <acowley> Did cabal-install pick up any kind of "run" command yet?
13:23:23 <acowley> I think I remember somebody talking about something like that a while ago
13:23:38 <FreeFull> :t foldM
13:23:39 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
13:23:51 <JoeyA> Oh, forgot the base value
13:23:52 <FreeFull> JoeyA: You need to provide an initial a value
13:23:53 <FreeFull> Yeah
13:23:58 <JoeyA> > foldM (\a x -> return (a+x)) 0 [1..10] :: [Int]
13:23:59 <lambdabot>   [55]
13:24:06 <Luke> johnw: or at least the main pragmas
13:24:17 <JoeyA> > foldM (\a x -> [a+x]) 0 [1..10] :: [Int]
13:24:18 <lambdabot>   [55]
13:24:19 <johnw> or a customizable list :)
13:24:26 <JoeyA> > foldM (\a x -> [a+x, 0]) 0 [1..3] :: [Int]
13:24:27 <lambdabot>   [6,0,3,0,5,0,3,0]
13:24:31 <pavonia> dmwit: re the gtk2hs bug (if you're interested): the problem seems to be cellLayoutSetAttributes when used with sorting models because it uses the wrong iterator internally
13:24:43 <johnw> Luke: or whatever pragmas are mentioned in the current *compilation* buffer :)
13:24:44 <Luke> johnw: hmm yeah but I wouldn't know how to do it dynamically... it'd have to be generated or something
13:24:53 <pavonia> dmwit: using cellLayoutSetAttributeFunc works fine for me, see http://hpaste.org/90149
13:24:54 <Luke> yeah hmm
13:25:06 <johnw> Luke: I'm pretty sure you can use `` in the default side of a snippet
13:25:10 <johnw> i just don't know if it can be a list or not
13:25:30 <dmwit> pavonia: awesome
13:25:35 <Luke> johnw: you definitely can but I don't know how to make that interactive
13:25:42 <Luke> johnw: exactly... its not a list
13:25:47 <johnw> Luke: I may give it a try
13:26:03 <johnw> at the very least I can do it with a regular ido-completing-read at the time that yasnippet attempts to determine a value for that insert
13:26:17 <Luke> johnw: so you think i should use "imp" and "mod" instead of "import" and "module"?
13:26:28 <Luke> i can easily change that
13:26:47 <johnw> Luke: I do, actually.  The more typing saved, the better.  Use the longer forms of words, like import, for the more involved expansions.  Just my preference, though
13:26:58 <Luke> i'm going to change it
13:27:02 <Luke> i was mixed before
13:27:07 <johnw> much appreciated!
13:27:18 <Luke> thanks for all the input!
13:27:26 <johnw> I'd been meaning to do something like this for haskell-mode for a long time, I'm glad you've charged ahead
13:28:22 <kartlos> is there an UML alternative for functional languages? some way of (visually) expressing abstractions like higher order functions, functions composition, etc.?
13:29:47 <Andrea_> > foldM (\x y -> Just (x + y) ) 0 [1..2]
13:29:49 <lambdabot>   Just 3
13:29:51 <companion_cube> kartlos: I think it's called "types" ;)
13:29:53 <Luke> johnw: what about "newtype" vs "new" or something?
13:30:09 <johnw> yeah, on that one I think newtype is better
13:30:27 <Luke> johnw: if they get too crazy i forget them and don't get the benefit =D
13:30:31 <johnw> right
13:30:54 <kartlos> companion_cube: actually I'm looking for something visually to express designs to less technical people
13:31:08 <Andrea_> this works , but i'm as stupid as before
13:31:48 <johnw> Luke: this works just fine: https://gist.github.com/5817780
13:31:59 <Cale> kartlos: Well designed types?
13:32:02 <johnw> or, instead of ${``}, use $0``
13:32:05 <johnw> I think that's actually better
13:32:12 <Luke> nice!
13:32:27 <acowley> kartlos: I'm not aware of a UML for FP, but what's wrong with just drawing boxes and arrows annotated with types?
13:32:34 <Luke> i think i'm just going to make this depend on IDO... it's insane not to
13:32:46 <FreeFull> > foldM (\x y -> Just (x,y)) 0 [1..3]
13:32:47 <johnw> i agree
13:32:48 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = (t0, t1)
13:33:01 <bscarlet> What's the GHC specific library for floating point conversions? {g,h}oogle aren't helping.
13:33:11 <johnw> i mean, we could add a haskell-yasnippet mode to haskell-mode, with some configuration variables for you to depend on
13:33:14 <FreeFull> > foldM (\x y -> Just [x,y]) 0 [1..3]
13:33:15 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = [t0]
13:33:19 <johnw> not mode, I meant just module
13:33:44 <kartlos> acowley: probably the best way to go, I was just wondering whether there is some standard way of making diagrams, foolish me :-)
13:33:46 <FreeFull> > foldM (\x y -> Just (y:x)) [] [1..3]
13:33:47 <lambdabot>   Just [3,2,1]
13:34:05 <Luke> johnw: or just an example .emacs for now
13:34:05 <acowley> kartlos: Not foolish at all!
13:34:10 <johnw> Luke: I'm doing it now
13:34:19 <johnw> adding haskell-yas.el
13:34:19 <Luke> johnw: awesome. want to just submit a patch?
13:34:40 <Luke> this way we can explicitly depend on ido-mode =)
13:34:40 <johnw> I have a commit bit for haskell-mode :)
13:34:57 <Luke> oh you're adding it to haskell-mode
13:36:08 <chrisdone_> some people believe it or not do not use ido-mode
13:36:17 <chrisdone_> so when i used it in haskell-mode some people complained D:
13:36:21 <johnw> in your snippets, you'll just need to `(require haskell-yas)` in order to be safe
13:36:42 <Luke> johnw: I'll just make an ido and non-ido version. simple enough
13:36:56 <johnw> Luke: even better, I'll provide you a generalized completing-read to use
13:37:05 <Luke> nice!
13:37:26 <Luke> you know what's funny is that all these only took me an hour to code up.... I've been wanting them for so long I knew exactly what to make
13:37:37 <byorgey> ooh, are we getting this YASnippet stuff included in haskell-mode automatically?
13:37:51 <acowley> I tried to use ido a while ago and it bugged me as I've gotten so used to normal name completion
13:38:12 <Luke> byorgey: yeah johnw had some great ideas about how to nicely integrate them
13:38:18 <byorgey> sweet
13:38:30 <byorgey> anything which makes it super easy for me to install is great
13:38:30 <Luke> acowley: should be easy enough to make optional
13:38:59 <acowley> Luke: I should probably get used to it since it's so popular. I'm sure I'm missing out on goodness.
13:39:14 <Luke> johnw: https://github.com/LukeHoersten/shnippet/commit/9c29a18b8fe6820e60d28cdc6d1ce595b2192f8d
13:39:17 <byorgey> the ratio of the amount I use emacs to the amount I am comfortable configuring it is very high
13:39:27 <Luke> haha
13:40:34 <chrisdone_> Luke: there's probably some overlap with haskell-mode-contextual-space for import: typing 'import ' prompts with an ido-mode completion list of all modules in the project and in packages installed
13:40:56 <johnw> is there a way to get the installed GHC to dump all the LANGUAGE pragmas it supports?
13:41:45 <johnw> ah, --supported-extensions, beautiful
13:42:04 <Luke> chrisdone_: to what extent?
13:42:09 <Luke> bad overlap?
13:42:29 <typoclass> johnw: yeah. (don't you want to thank the kind answerer of your question?)
13:43:05 <johnw> :)
13:43:17 <chrisdone_> Luke: nah, i suppose not, no one uses my stuff
13:43:18 <Luke> chrisdone_: I'm not sure I know how to use (haskell-mode-contextual-space)
13:43:39 <Luke> you should write an updated guide... the last I've read about your stuff was when it was a separate mode
13:43:52 <chrisdone_> there is a guide in the README of haskell-mode
13:43:54 * byorgey uses it
13:44:14 <byorgey> the contextual space after "import" is super useful
13:44:24 <Luke> chrisdone_: is it a recent addition? I think i need to update
13:44:34 <kaw> What's the simplest way to do unordered equality comparison of lists (or something I convert lists to)?
13:44:42 <chrisdone_> Luke: https://github.com/haskell/haskell-mode/#setup-for-haskell-interactive-mode
13:44:43 <kaw> Performance doesn't really matter for me, I just need it to write tests
13:44:52 <dmwit> kaw: (==) `on` Set.fromList
13:44:57 <elliott> kaw: sort xs == sort ys
13:44:58 <shachaf> What is unordered equality comparison?
13:45:04 <dmwit> or Bag.fromList
13:45:10 <dmwit> ...or sort, yes =)
13:45:43 <byorgey> (==) on Set.fromList and on sort are two different operations!  choose carefully which one you want.
13:45:56 <byorgey> hmm, do we have a standard Bag type somewhere?
13:45:57 <chrisdone_> Luke: might want to also ping tibbe to tell him he's out of a job =p https://github.com/tibbe/yasnippet-haskell
13:46:54 <Luke> chrisdone_: yeah there's actually not much overlap believe it or not. speaks to the different types of haskell coding johan and I do
13:46:56 <bscarlet> How can I convert a CDouble to a Double?
13:47:09 <dmwit> realToFrac
13:47:18 <kaw> Hm, both require Ord, right? But not a problem in practice
13:47:29 <dmwit> Now ask me how to convert a Double to a CDouble.
13:47:42 <bscarlet> dmwit: How do you convert a Double to a CDouble?
13:47:46 <dmwit> realToFrac =)
13:47:50 <Botje> unique up on it!
13:47:54 <Botje> ah, no. wrong joke.
13:48:11 <shachaf> dmwit: What if I want uncomputable Doubles?
13:48:32 <bscarlet> > realToFrac (1/0)
13:48:34 <lambdabot>   Infinity
13:48:42 <shachaf> Well, the idea of combining maths and floating point values sounds scary.
13:49:06 <Andrea_> > 1.0 / 0.0
13:49:07 <lambdabot>   Infinity
13:49:17 <Andrea_> > 0.0 / 0.0
13:49:20 <dmwit> Uncomputable Doubles? In *my* computation?
13:49:23 <lambdabot>   NaN
13:49:31 <bscarlet> > realToFrac (0/0 :: Double) :: CDouble
13:49:33 <lambdabot>   Not in scope: type constructor or class `CDouble'
13:49:35 <lambdabot>  Perhaps you meant `Doubl...
13:49:36 <Luke> chrisdone_: I don't see anything about contextual-space in the readme either
13:49:41 <joelteon> > show $ 1.0 / 0.0
13:49:45 <lambdabot>   "Infinity"
13:49:57 <chrisdone_> Luke: hold up
13:49:57 <dmwit> > 1 / -0
13:49:58 <lambdabot>   Precedence parsing error
13:49:59 <lambdabot>      cannot mix `GHC.Real./' [infixl 7] and prefix...
13:50:06 <dmwit> > 1 / (-0)
13:50:07 <lambdabot>   -Infinity
13:50:08 <bscarlet> > realToFrac (-1/0 :: Float) :: Double
13:50:09 <lambdabot>   -3.402823669209385e38
13:50:25 <Luke> johnw: are you working on a patch for my snippets as well or should I get to it?
13:50:28 <Andrea_> 3 * (1 / 0)
13:50:28 <johnw> Luke: pull request incoming
13:50:33 <Luke> cool
13:50:39 <johnw> it's up in haskell-mode now
13:50:39 <Andrea_> > 3 * (1 / 0)
13:50:42 <lambdabot>   Infinity
13:50:49 <johnw> will take a little bit until the next official release, that's up to chrisdone_
13:50:56 <johnw> I'm just his little elf
13:51:04 <bscarlet> I don't like trusting realToFrac for double conversions, as it's sometimes wrong.
13:51:12 <Andrea_> > (1 / 0) - (1/0)
13:51:14 <lambdabot>   NaN
13:51:33 <Luke> johnw: ha np
13:51:36 <chrisdone_> yeah let's get that in git
13:51:53 <johnw> I wouldn't mind if haskell-mode had a submodule reference to Luke's snippet repo
13:52:06 <johnw> so we could update what we officially support at intervals
13:53:11 <chrisdone_> why not include it directly in haskell-mode?
13:53:37 <johnw> I didn't know how volatile he planned to be, but that works too
13:53:46 <Luke> i think i'm done =)
13:53:51 <Luke> lets do it =)
13:53:54 <johnw> a snippets/ subdirectory in haskell-mode would please byorgey to no end
13:54:06 <Luke> totally - i didn' tknow that was an option
13:54:15 <chrisdone_> 'officially' haskell-mode /should/ be reliable for each monthly version, and if you're using git you can expect breakage
13:54:27 <Luke> i use git
13:54:28 <chrisdone_> sounds good to me
13:54:48 <Luke> this way we can more tightly integrate haskell-mode and the snippets as well which is nice
13:55:12 <bgamari> for any pipes experts in the room, any idea how to fix this proxy transformer usage? https://gist.github.com/bgamari/5817943
13:55:24 <hidenori> i am wondering how to edit text files by using IO action. can someone give any advice?
13:55:58 <johnw> hidenori: read the data in, apply your edits, write the new data
13:56:16 <elliott> (and don't use readFile/writeFile)
13:56:23 <elliott> well, you can use writeFile
13:56:31 <elliott> just not in conjunction with readFile. unless you force all the string.
13:56:44 <hidenori> i used writeFile and it shows error
13:57:02 <hidenori> which functions should I use?
13:58:43 <Luke> chrisdone_: man it looks like haskell-mode has added a lot of functionality since i've last pulled =) i'm quite excited to try some of this out
13:59:10 <chrisdone_> \o/
13:59:12 <Luke> haha
13:59:25 <dmwit> hidenori: You can either manually open the file in ReadWrite mode and manage the handle yourself, or you can learn how to coerce the runtime into doing what you want with the handle when you use readFile/writeFile.
13:59:26 <chrisdone_> Luke: i'm adding you to the repo as contributor if you want to push your snippets
13:59:31 <dmwit> hidenori: Which would you prefer advice on?
13:59:38 <Luke> chrisdone_: sounds good
14:00:02 <elliott> you can also use the strict package or whatever
14:00:05 <elliott> or was it strict-io?
14:00:41 <dmwit> I would classify that as "learn how to coerce the runtime into doing what you want". =)
14:00:58 <hidenori> dmwit: I prefer easier one.
14:01:07 <dmwit> They have incomparable ease.
14:01:10 <chrisdone_> Luke: okies, added!
14:01:54 <Luke> ty
14:02:00 <hidenori> dmwit: Hmm.. I actually cannot tell the difference so...
14:03:59 <phulin> what's the canonical way to divide two Ints and get a Float or Double?
14:04:08 <chrisdone_> Luke: please make a pull request for the initial version so we can do a quick code review/check, when you decide to do it =) later updates/tweaks don't need a pull request, just this particular new thing
14:04:10 <dmwit> hidenori: Okay. Perhaps you could start by reading the documentation for openFile and hClose. Most of the functions you use for reading and writing stdin and stdout have h* versions, e.g. hGetLine, hGetChar, hPrint, etc.
14:04:10 <johnw> > 2/ 3
14:04:11 <lambdabot>   0.6666666666666666
14:04:19 <phulin> not literals
14:04:20 <luite> phulin: fromIntegral them
14:04:24 <Luke> chrisdone_: no problem
14:04:25 <johnw> you've been canonized
14:04:46 <dmwit> > ((/) `on` fromIntegral) (2 :: Int) (3 :: Int) :: Float
14:04:47 <chrisdone_> :t let x = 2; y = in 2 / 3 in x
14:04:47 <lambdabot>   0.6666667
14:04:48 <lambdabot> parse error on input `in'
14:04:54 <chrisdone_> :t let x = 2; y = 2 / 3 in x
14:04:55 <lambdabot> Num a => a
14:05:06 <chrisdone_> oh, i suck
14:05:09 <chrisdone_> :t let x = 2; y = x / 3 in x
14:05:09 <lambdabot> Fractional a => a
14:05:27 <johnw> chrisdone_: but only fractionally
14:05:32 <dmwit> phulin: (My last > was aimed at you.)
14:05:34 <hidenori> dmwit: Okay thanks
14:05:48 <chrisdone_> johnw: lol
14:07:30 <phulin> thanks, guys
14:09:30 <nicf> If I type "let x = get >>= return . show :: State Integer String" into GHCi, then it seems to think (x >> x) is a StateT Integer Data.Functor.Identity.Identity String. Can anyone tell me why this happens?
14:09:58 <nicf> That is, why is the type of x>>x wrapped up in StateT when the type of x itself isn't?
14:10:03 <elliott> because State s a = StateT s Identity a
14:10:09 <elliott> because GHCi doesn't expand unless it "has" to
14:10:19 <nicf> Oh, I see, that makes sense.
14:10:20 <elliott> where "has" to includes using pretty much any function on it, etc.
14:10:31 <elliott> I wish GHCi tried to keep synonyms unexpanded more, personally
14:10:39 <chrisdone_> me too
14:10:45 <nicf> So it remembers that I told it x's type, but that knowledge doesn't transfer to x>>x.
14:10:47 <elliott> it's especially bad with lens :)
14:10:56 <elliott> nicf: more or less, sure
14:11:23 <nicf> Okay, great, thanks.
14:14:26 <akegalj> im trying to get work with utf8 support, but with no luck. So i'm using Data.Text package, and everithing works fine with "T.putStr
14:15:48 <akegalj> simple values... but when i have [Data.Text.Text] i cant figure out how to print this out on stdout with utf8 support
14:16:48 <typoclass> akegalj: hello, have you tried mapM T.putStr [...] ?
14:17:21 <elliott> mapM_
14:17:36 <dmwit> Have you tried T.putStr . mconcat
14:18:53 <typoclass> i wonder if mapM_ and its ilk shouldn't be deprecated, now that we have void 8-)
14:18:59 * typoclass whistles innocently
14:19:17 <elliott> huh?
14:19:20 <dmwit> mapM_ is more efficient than void $ mapM ...
14:19:34 <dmwit> ...and can be so in a very meaningful way.
14:19:46 <tazjin> Why?
14:19:57 <dmwit> Because it throws away references to potentially large objects sooner.
14:19:57 <typoclass> efficiency shmeshmiciency
14:19:58 <c_wraith> it doesn't hold on to intermediate results to build a list
14:20:03 <phulin> why doesn't GHC just do that optimization?
14:20:06 <c_wraith> sometimes that really matters
14:20:14 <phulin> i guess it can't do everything.
14:20:29 <akegalj> typoclass, elliott: mapM_ T.putStr ["č"] returns  Couldn't match expected type `Text' with actual type `[Char]'
14:20:53 <c_wraith> It could do that optimization if you could rules for detecting when it's safe to do so, and prove they're correct.
14:20:54 <dmwit> Perhaps you would like [T.pack " ... "] or -XOverloadedStrings.
14:20:57 <akegalj> dmwit: mconcat, where is that?
14:21:04 <typoclass> akegalj: right, that's because the list contains an actual String, not a Text. try T.pack as dmwit suggested
14:21:11 <typoclass> akegalj: in Data.Monoid
14:21:13 <dmwit> mconcat is in Data.Monoid, but is unrelated to yoru current problem.
14:22:36 <dmwit> c_wraith: I guess a rule for mapM foo bar >> baz -> mapM_ foo bar >> baz would be fine. Possibly one for void (mapM foo bar) -> mapM_ foo bar, too.
14:22:42 <typoclass> akegalj: just as a double-check, for just simple unicode support, you don't even need Text, you can use String. putStrLn "ä" should work correctly, unless there's a problem with your system's settings
14:22:49 <akegalj> typoclass: tnx, with overloaded strings     "mapM_ T.putStr ["č"]" works fine
14:22:50 <dmwit> ...but this doesn't eliminate the need for mapM_, which was the original motivation.
14:23:17 <c_wraith> dmwit: that would depend on the monad instance being valid.
14:23:29 <c_wraith> dmwit: you can't prove that's correct.
14:23:34 <dmwit> bah
14:23:45 <dmwit> People that write invalid monad instances can deal with the consequences.
14:23:51 <dmwit> >:-)
14:23:52 <akegalj> dwwit: il try your solution now
14:25:39 <c_wraith> dmwit: actually, you may be able to prove that transformation is valid by parametricity
14:25:48 <c_wraith> dmwit: rather than needing the monad properties
14:25:54 <akegalj> typoclass: hm, how is then non ascii characters encoded by \234 stuff, how should i fix it to support unicode string?
14:25:58 <xico> i am trying to write something like this: "f :: Shape sh => A sh -> b ; f x = g x :: A sh" but the compiler complains that "Could not deduce (sh ~ sh1)". any idea on how to solve that?
14:26:27 <xico> ouch nope, there are more lines after "g x"
14:26:30 <dmwit> akegalj: Perhaps you used "print" before, and would like to try "putStr" instead.
14:27:30 <dmwit> xico: You can use ScopedTypeVariables. Remember to add a "forall" at the beginning of "f"s type.
14:28:03 <Luke> chrisdone_: I'll work on this a bit later tonight/tomorrow so don't wait up for me (if you were)
14:28:24 <Luke> johnw: thanks for the patch. will test tonight/tomorrow
14:28:30 <typoclass> akegalj: are you using 'show' or 'print'? those will produce a "safe" version of the String. for example, putStrLn "ä" outputs 1 character "ä", while print "ä" outputs 6 characters "\228"
14:28:35 <xico> dmwit: thanks! i will read about that :)
14:28:36 <Luke> afk
14:28:49 <chrisdone_> Luke: cool, no rush. nice work anwyay =)
14:30:29 <akegalj> typoclass: yes, putStr works as you expected..but thats all fine with only "putStr "æ"" . If i want nice print with [a] then i must use mapM_ ?
14:31:04 <akegalj> * with [String]
14:31:44 <akegalj> what if i have Data.Map.Map String String, how should i prity print this with "show", and "putStr" ?
14:32:02 <typoclass> akegalj: yes, if you have a list (i.e. something with [ ]), then you need mapM_ or similar. you could also use the 'unlines' function, e.g. putStrLn (unlines ["...", "..."])
14:34:10 <akegalj> typoclass: ok, thnks :)
14:39:34 <dmwit> Is there a module somewhere on Hackage for functions with finite support?
14:40:04 <dmwit> e.g. with some handy operations for a type like (v, Map k v)?
14:40:30 <hpc> i wonder if you can make a Zipper out of (v, Map k v)
14:40:50 <hpc> er, zipper-like comonad
14:41:24 <dmwit> Well, I mean, I want to use (v, Map k v) as if it were k -> v with some extra introspection power.
14:44:03 <shachaf> @hackage total-map exists but isn't really what you want.
14:44:03 <lambdabot> http://hackage.haskell.org/package/total-map exists but isn't really what you want.
14:44:32 <jfischoff> dmwit: total map?
14:45:00 <dmwit> shachaf: Looks pretty much like what I want. Thanks!
14:45:06 <dmwit> (Why do you say it's not what I want?)
14:45:24 <shachaf> Maybe I misunderstood what you want.
14:45:49 <jfischoff> heh just saw that
14:46:03 <dmwit> The only thing I miss is something like Map's insert.
14:46:15 <dmwit> But I feel confident I can hack that in. =)
14:46:53 <bgamari> Why is it that many functions in Control.Proxy.Prelude are polymorphic in the return value (e.g. r) while others return ()
14:47:53 <phulin> c_wraith, thanks for the help earlier. got the progress transformer working
14:48:03 <c_wraith> phulin: awesome.
14:48:41 <hpaste> “Patrick Hulin” pasted “Progress monad transformer” at http://hpaste.org/90155
14:48:53 <phulin> if you're curious.
14:49:27 <chrisdone_> elliott: 1
14:49:27 <chrisdone_> OK ["1"]
14:49:27 <chrisdone_> head [] :: ()
14:49:27 <chrisdone_> Exception [] "Prelude.head: empty list"
14:49:30 <chrisdone_> elliott: exceptions seem to work?
14:49:44 <c_wraith> phulin: any particular reason you picked Float?
14:49:50 <phulin> percentages
14:49:56 <phulin> obviously you could parameterize that
14:49:58 <c_wraith> I mean as opposed to Double
14:50:01 <chrisdone_> elliott: the prompt_ command yields this, but promtp doesn't show anything
14:50:02 <phulin> oh idk
14:50:07 <phulin> "no
14:50:20 <c_wraith> ok.  It doesn't really matter for this purpose anyway.  It's just the less-common choice, so I was curious.
14:50:43 <c_wraith> Double is the default Floating instance, for example.
14:52:39 <c_wraith> phulin: oh, one thing to note..  line 35 there?  Whenever you have x >>= return . f, it can be changed to fmap f x
14:52:57 <mapreduce> Hi.  In http://www.haskell.org/haskellwiki/Cookbook/Lists_and_strings I see that to convert a Char to lower case I can import Char then use toLower 'A' to get 'a'.
14:53:10 <mapreduce> I'm doing that in ghci and it gives me Not in scope: toLower
14:53:19 <mapreduce> Is there a magic incantation?
14:53:22 <josephle> mapreduce: import Data.Char?
14:53:24 <dmwit> In modern Haskell, you should import Data.Char.
14:53:35 <c_wraith> phulin: I guess that also applies a few other times
14:54:23 <Botje> also, printf can generate a String *or* an IO () depending on its context.
14:54:32 <Botje> so no need for putStr $ printf ..
14:55:56 <phulin> thanks, guys
14:56:32 <phulin> i'm currently the only one who knows haskell in my group, so no one ever looks over my code :D
14:57:04 <c_wraith> phulin: teach someone else in your group to haskell. :)
14:57:13 <phulin> yeah, maybe a good idea
14:57:31 <phulin> they're all ocaml addicts, is the problem
14:57:46 <mischov> Been playing around with Criterion and was wondering if somebody would explain this error
14:57:48 <hpaste> mischov pasted “Why Does this happen?” at http://hpaste.org/90159
14:57:51 <c_wraith> Hmm.  closer, but ideologically further...
14:58:43 <c_wraith> mischov: that would happen because you're using a version of ghc that came with bytestring < 0.10
14:59:02 <josephle> phulin: getting them off the module system is going to be hard...
14:59:30 <phulin> josephle, I think they'd be ready to accept typeclasses, but it's just a matter of inertia, mostly
14:59:57 * josephle wishes there is a language with both a module system *and* typeclasses
15:00:17 <josephle> ocaml and sml already have equality types. They just need to make that system generic.
15:02:05 <phulin> I took a class on Coq a couple years ago and it was amazing
15:02:46 <BitPuffin> one thing that confuses me about haskell
15:02:54 <BitPuffin> when you say that you return [a] for example
15:03:02 <BitPuffin> why can you return []
15:03:11 <Botje> :t []
15:03:11 <lambdabot> [a]
15:03:23 <BitPuffin> weird
15:03:54 <Fuuzetsu> Think that data List a = Nil | Cons a (List a)
15:04:09 <Fuuzetsu> Nil :: List a
15:04:47 <mapreduce> josephle: dmwit: Thanks.  I've also asked for an account to be able to fix the page I linked to.
15:04:57 <FreeFull> BitPuffin: see http://www.haskell.org/haskellwiki/Syntactic_sugar/Cons#Lists
15:05:10 <FreeFull> BitPuffin: Also, [] is the empty list
15:05:20 <FreeFull> :t 3:[]
15:05:21 <lambdabot> Num a => [a]
15:05:28 <FreeFull> :t (:)
15:05:29 <lambdabot> a -> [a] -> [a]
15:06:27 <danbst> Hello o/. I know there is syntax 0xHEX_NUMBER in Haskell, and there is not 0bBINARY. What is the best method to mimic that syntax? Currently I'm stuck with fB :: String -> Word, which converts string of ones and zeros to a number, maybe there is better way?
15:06:30 <FreeFull> BitPuffin: The definition of a list is roughly   data List a = Cons a (List a) | Empty
15:07:20 <mapreduce> BitPuffin: You might also like non-empty lists, implemented in various places.
15:07:47 <typoclass> danbst: you can take 4 bits and group them into one hex digit. there's also 0o755 syntax for octal (= groups of 3 bits)
15:08:03 <monochrom> danbst: there is also QuasiQuote, if you don't mind
15:08:06 <typoclass> danbst: other than that, i think there's converter functions in module Numeric
15:08:13 <ekipan> s/roughly/exactly/, modulo names and constructor order
15:09:02 <ekipan> data [a] = [] | a : [a]
15:09:10 <monochrom> if you're already doing String->Word, may we also suggest: OverloadedString hehehehe <duck>
15:09:11 * hackagebot pipes-vector 0.3.0.0 - Various proxies for streaming data into and out of vectors  http://hackage.haskell.org/package/pipes-vector-0.3.0.0 (BenGamari)
15:09:42 <FreeFull> ekipan: That's why I said roughly
15:10:03 <FreeFull> BitPuffin: http://www.haskell.org/haskellwiki/Syntactic_sugar/Cons#Lists
15:10:21 <Fuuzetsu> monochrom: messing with fire
15:10:37 <danbst> typoclass, hex numbers is too easy =)
15:10:41 <BitPuffin> FreeFull: looking
15:11:14 <ekipan> names are for the programmer, Haskell doesn't care about them
15:11:18 <BitPuffin> FreeFull: oh riiiight, a is the TYPE
15:11:27 <danbst> monochrom, will the syntax with quasiquotes be concise?
15:11:38 <BitPuffin> [a] means a list of a's
15:11:43 <BitPuffin> which might be nil
15:11:44 <FreeFull> BitPuffin: Yeah
15:11:58 <BitPuffin> tricky haskell
15:11:59 <FreeFull> You've got it :3
15:12:04 <ekipan> you can also spell that prefix: ([] a)
15:12:36 <phulin> :t ([] a)
15:12:37 <lambdabot>     Couldn't match expected type `Expr -> t0' with actual type `[a0]'
15:12:37 <lambdabot>     The function `[]' is applied to one argument,
15:12:37 <lambdabot>     but its type `[a0]' has none
15:12:43 <BitPuffin> ekipan?
15:12:44 <FreeFull> Tuples do a similar thing
15:12:51 <phulin> oh, for the type
15:13:04 <FreeFull> :t (,) 3 4
15:13:05 <lambdabot> (Num a, Num b) => (a, b)
15:13:10 <ekipan> to look more like other type constructors
15:13:16 <monochrom> danbst: it will be like [b|10010011]. the "b" part is up to you, choose a function name you like
15:13:24 <ekipan> > (3, 'a') :: (,) Int Char
15:13:25 <BitPuffin> what's ghci written in?
15:13:25 <lambdabot>   (3,'a')
15:13:32 <monochrom> err, [b|10110011|]
15:13:33 <FreeFull> monochrom: There is already a library that does that
15:13:38 <monochrom> oh, neato!
15:13:48 <FreeFull> http://hackage.haskell.org/packages/archive/binary-literal-qq/1.0/doc/html/Language-Literals-Binary.html
15:13:55 <monochrom> good good
15:13:57 <ekipan> GHC is written in Haskell
15:13:58 <FreeFull> http://hackage.haskell.org/package/binary-literal-qq-1.0
15:14:21 <monochrom> isn't Haskell exciting!
15:14:27 <monochrom> "there is a lib for that" :)
15:14:37 <danbst> thanks!
15:14:43 <FreeFull> monochrom: I have found things lacking
15:15:04 <monochrom> "there is a #haskell for that" :)
15:15:44 <FreeFull> The only websocket library that does client-side stuff still doesn't support hybi13
15:16:19 <FreeFull> Which leaves me unable to write the program I wanted to write
15:16:29 <FreeFull> At least, without doing hybi13 myself
15:27:28 <danbst> can I rename imported quasiquoter from `b` to `bin`?
15:28:15 <danbst> it conflicts with local variables
15:28:41 <ekipan> you could qualify it and define bin = Language.Literals.Binary.b
15:29:48 <nabilhassein> hello all, I have a question about an apparent problem with emacs
15:30:04 <nabilhassein> when I try to use C-c C-l to load a file, I get an error that ghci cannot find a module
15:30:16 <nabilhassein> however, from the command line, it finds it just fine
15:30:44 <nabilhassein> does anyone know why emacs's inferior ghci should find a different set of packages from the terminal?
15:32:34 <danbst> ekipan,     GHC stage restriction: `bin` is used in a quasiquote, and must be imported, not defined locally. Pity, but I have to created one more module for simple rename
15:33:26 <nabilhassein> i think it's related to virthualenv, which I just began using
15:35:33 <nabilhassein> that was it, found a fix. nevermind!
15:37:11 <enthropy> danbst: probably you could also go with    $(quoteExp Language.Literals.Binary.b "0b101010") -- or whatever the input string is
15:43:10 <hpaste> tippenein pasted “map fold” at http://hpaste.org/90165
15:44:08 <dmwit> This is silly.
15:44:20 <dmwit> ! should be lower precedence than type-level application.
15:44:34 <dmwit> ...or maybe even just part of the record syntax.
15:44:56 <tippenein> Anyone help with that paste of implementing map with foldr ?
15:45:07 <dmwit> Like record ::= fieldList "::" type | fieldList "::" "!" type
15:45:52 <dmwit> tippenein: Looks like you got your base case and the list you want to iterate over mixed up.
15:47:15 <acowley> dmwit: While I don't like all the extra parens, having the ! up against the type constructor looks wrong, too
15:47:45 <dmwit> Does it?
15:47:56 <acowley> But I suppose your syntax would allow using ::! Foo Bar
15:47:59 <dmwit> I feel like you're only saying that because you've trained your eye to expect a parenthesis. =P
15:47:59 <acowley> which I like
15:48:58 <dmwit> data Record = Record { field :: Map k v (!) }
15:49:08 <acowley> dmwit: To an extent, yes, but don't you put spaces around operators most of the type? For instance, with vector indexing, I might write "v ! foo x", but I wouldn't write "v !foo x"
15:49:20 <BitPuffin> how come: repeat' x = x:repeat' x  works?
15:49:22 <dmwit> acowley: I bet you write "-3".
15:49:24 <acowley> well, !foo wouldn't even be legal, would it?
15:49:26 <BitPuffin> there isn't any :[]
15:49:31 <BitPuffin> so how does it even compile
15:49:36 <acowley> Ugh, - is the worst
15:49:47 <acowley> I actually write out negate and subtract fairly often :(
15:50:17 <dmwit> BitPuffin: (:)'s second argument must be a list. [] is just one of many possible choices for this list.
15:50:18 <acowley> BitPuffin: Because you can observe that codata!
15:51:09 <acowley> dmwit: I actually do like the "field ::! Map k v" syntax
15:51:13 <dmwit> acowley: How do you like my proposed "excited sentence" syntax? =)
15:51:23 <dmwit> "field :: Map k v!"
15:51:34 <acowley> That looks biased towards the v
15:51:53 <BitPuffin> hmm I guess if you combine it with take the final arg will eventually be []
15:51:56 <acowley> If I came across such syntax, I'd guess the ! modified the v.
15:51:57 <dmwit> Yeah, it's a joke.
15:52:06 <dmwit> BitPuffin: Nope, repeat never reaches [].
15:52:07 <BitPuffin> still though
15:52:15 <acowley> BitPuffin: Yes, but note that take provides the []
15:52:32 <BitPuffin> don't feel like it should compile if it actually doesn't return a list like it claims to
15:52:35 <BitPuffin> in the signature
15:52:41 <dmwit> Oh, I see: "take" was a reference to the Prelude function, not a strange grammar error. OK =)
15:52:48 <dmwit> BitPuffin: It does return a list.
15:52:52 <dmwit> Why do you think it doesn't?
15:53:02 <acowley> A list is anything formed by the (:) constructor or the [] constructor
15:53:19 <BitPuffin> dmwit: 1:1:1:1 isn't a list is it?
15:53:24 <acowley> BitPuffin: no
15:53:38 <dmwit> BitPuffin: No it's not. It's also not what repeat 1 expands to.
15:53:56 <tromp_> it's a type error
15:54:03 <acowley> BitPuffin: rewrite (:) in prefix notation to see what you wrote, "cons 1 (cons 1 (cons 1 (cons 1)))"
15:54:03 <sepp2k1> BitPuffin: 1:1:1:1 isn't anything - it does not compile.
15:54:17 <acowley> BitPuffin: That last cons is partially applied
15:54:19 <BitPuffin> exactly
15:54:25 <dmwit> ...noooo
15:54:35 <acowley> BitPuffin: But your example is very different!
15:54:42 <dmwit> cons 1 (cons 1 (cons 1 1)) -- is what 1:1:1:1 really is
15:54:44 <BitPuffin> so why is this valid
15:54:45 <BitPuffin> repeat' :: a -> [a]
15:54:45 <BitPuffin> repeat' x = x:repeat' x
15:54:47 <dmwit> count the cons's if you don't believe me
15:54:53 <acowley> sorry!
15:55:00 <acowley> oy
15:55:00 <dmwit> BitPuffin: Because repeat 1 isn't 1:1:1:1!
15:55:07 <dmwit> BitPuffin: repeat 1 is 1:1:1:1:repeat 1.
15:55:11 <dmwit> Which is very different.
15:55:19 <tromp_> :t (1:)
15:55:20 <lambdabot> Num a => [a] -> [a]
15:55:24 <tromp_> :t (1:1:)
15:55:25 <lambdabot>     The operator `:' [infixr 5] of a section
15:55:25 <lambdabot>         must have lower precedence than that of the operand,
15:55:25 <lambdabot>           namely `:' [infixr 5]
15:55:29 <FreeFull> 1:1:1:1  could be something if you make a Num instance for [a]
15:55:31 <joelteon> :D
15:55:46 <dmwit> FreeFull: (True, but probably not helpful at the moment.)
15:56:02 <FreeFull> :t (1:1:[] ++)
15:56:03 <lambdabot>     The operator `++' [infixr 5] of a section
15:56:03 <lambdabot>         must have lower precedence than that of the operand,
15:56:03 <lambdabot>           namely `:' [infixr 5]
15:56:12 <FreeFull> :t ((1:1:[]) ++)
15:56:12 <lambdabot> Num a => [a] -> [a]
15:56:21 <BitPuffin> whaat
15:56:34 <FreeFull> BitPuffin: Non-infinite lists must end in []
15:56:37 <eikke> :t []:
15:56:37 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:56:46 <FreeFull> :t ([]:)
15:56:47 <lambdabot> [[a]] -> [[a]]
15:57:07 <dmwit> BitPuffin: Why shouldn't "repeat' x = x : repeat' x" be valid?
15:57:22 <BitPuffin> dmwit: because it doesn't return a list
15:57:30 <dmwit> BitPuffin: What is the type of "(:)"?
15:57:31 <geekosaur> it doesn't?
15:57:38 <BitPuffin> :t (:)
15:57:38 <lambdabot> a -> [a] -> [a]
15:57:44 <BitPuffin> but wtf
15:57:46 <BitPuffin> why
15:57:47 <BitPuffin> ;_;
15:57:52 <dmwit> BitPuffin: Okay, so, do you believe that (:) returns a list?
15:57:59 <BitPuffin> I guess I have to
15:58:14 <BitPuffin> but what kind of list is that really
15:58:20 <FreeFull> The right side of : must be a list
15:58:31 <elliott> dmwit: this feels very "What the Tortoise said to Achilles" :)
15:58:32 <geekosaur> BitPuffin, remember that haskell is non-strict. it's not so much returning a list as returning a *promis* to make a list
15:58:32 <FreeFull> BitPuffin: You can substitute any type for a
15:58:40 <dmwit> BitPuffin: "x : y" is the list that starts with "x" as the first element and ends with "y" as the remaining elements.
15:58:58 <geekosaur> in case you're being confused because it's reinvoking itself to generate the tail of the list
15:59:02 <josephle> yay, call-by-need!
15:59:05 <FreeFull> It's called a cons list
15:59:26 <dmwit> BitPuffin: So, we expect "x" to be a single element (an "a") and "y" to be a list (an "[a]"); and the whole thing "x : y" will be a list (an "[a]").
15:59:28 <FreeFull> In lisp you could do something like    (cons 3 (cons 4 nil))
15:59:35 <FreeFull> Although you'd be more likely to do '(3 4)
15:59:36 <BitPuffin> but (:) isn't valid if you type it in ghci for example
15:59:42 <dmwit> BitPuffin: Sure it is.
15:59:48 <josephle> introducing undefined since 1990
15:59:49 <dmwit> > (:) 3 [4]
15:59:50 <lambdabot>   [3,4]
16:00:15 <BitPuffin> dmwit: ooooooooh right you have to give params
16:00:24 <dmwit> Well, you don't have to. =)
16:00:26 <newsham> > (:)
16:00:30 <lambdabot>   mueval-core: Time limit exceeded
16:00:31 <acowley> Only if you want to print out the value
16:00:32 <dmwit> But ghci can't print functions out. =)
16:00:43 <geekosaur> it's valid even without parameters. it's not show-able, which is something different
16:00:44 <acowley> > let f = (:) in f 3 [4]
16:00:45 <lambdabot>   [3,4]
16:01:29 <geekosaur> (functions are not, in general, showable --- although there are various dummy Show instances for functions running around)
16:01:44 <dmwit> (and some non-dummy ones!)
16:01:49 <BitPuffin> hm well I guess since the type of : is a list then the repeat should work
16:01:53 <dmwit> (written by YT)
16:01:58 <newsham> ?let instance Show (a -> b) where { show f = "evilShowImplForFuncAToB" }
16:01:59 <lambdabot>  .L.hs:138:10:
16:01:59 <lambdabot>      Duplicate instance declarations:
16:01:59 <lambdabot>        instance [safe] S...
16:02:23 <BitPuffin> and since haskell is lazy it doesn't evaluate it until it's actually run? like with take
16:02:33 <jmcarthur_mobile> dmwit: what is the behavior of a non-dummy show for functions?
16:02:37 <dmwit> BitPuffin: Right!
16:02:47 <dmwit> jmcarthur_mobile: Run the function on all possible inputs.
16:02:56 <dmwit> ?hackage universe
16:02:57 <lambdabot> http://hackage.haskell.org/package/universe
16:02:57 <jmcarthur_mobile> Ah. Fair.
16:03:09 <newsham> > show (:)
16:03:09 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
16:03:10 <lambdabot>    arising from a use ...
16:03:14 <BitPuffin> haskell you weird but cool
16:03:19 <jmcarthur_mobile> Does it show it in a format that is valid Haskell code?
16:03:41 <dmwit> Yes... but not in a format that is a valid Haskell function.
16:03:43 <dmwit> Patches welcome.
16:04:20 <dmwit> (However, read . show is id, at least.)
16:04:24 <elliott> BitPuffin: well, "the type of repeat is a list" is not quite right.
16:04:25 <jmcarthur_mobile> I guess that can only work on domains whose show instances show their constructors
16:04:35 <FreeFull> repeat is a function
16:04:42 <FreeFull> repeat 3    is a list
16:04:50 <FreeFull> > repeat 3
16:04:51 <lambdabot>   [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
16:05:22 <dmwit> jmcarthur_mobile: Well, the usual trick is to put "fromList" at the beginning of the show instance. =)
16:05:33 <dmwit> Which could certainly be done here.
16:05:50 <dmwit> It just means writing a real Read instance instead of cheating, and I'm too lazy not to cheat. =P
16:06:18 <eikke> :t repeat . repeat
16:06:18 <lambdabot> a -> [[a]]
16:08:26 <ekipan> > (:) :: Int -> [Int] -> [Int]
16:08:28 <lambdabot>   <Int -> [Int] -> [Int]>
16:09:02 <BitPuffin> elliott: well according to the signature it is
16:09:05 <jmcarthur_mobile> dmwit: fromList :: (Read a, Read b, Eq a) => [(a, b)] -> a -> b has more constraints, but works I guess
16:09:36 <jmcarthur_mobile> I stink. I meant string of course
16:09:41 <ekipan> repeat 1 --> 1 : (repeat 1) --> 1 : (1 : (repeat 1)) --> 1 : (1 : (1 : (repeat 1))) --> 1 : (1 : (1 : (1 : (repeat 1)))) --> 1 : (1 : (1 : (1 : (1 : (repeat 1)))))
16:09:44 <elliott> BitPuffin: nope
16:09:50 <acowley> I'm trying ido mode again, and when I go to open a file, it sometimes doesn't list any files in directories that aren't empty
16:09:57 <BitPuffin> elliott: well it returns a list according to the signature
16:10:01 <elliott> BitPuffin: its type signature says that it's a function taking an "a" and returning a list of "a"s
16:10:04 <BitPuffin> elliott: in the implementation I showed
16:10:04 <elliott> right
16:10:08 <elliott> but that's not the same as being a list :)
16:10:14 <BitPuffin> picky
16:10:38 <eikke> BitPuffin: if you think elliott is picky, wait till you met GHC :P
16:11:08 <BitPuffin> well I'd say it's less picky
16:12:16 <oio> any idea why i get this /Users/xxxx/Downloads/About Downloads.lpdf: copyFile: inappropriate type (is a directory) ?
16:12:39 <elliott> perhaps it is a directory
16:13:19 <oio> is the default mac download pdf file
16:13:32 <geekosaur> yes, and it's an OS X bundle, which is a directory
16:13:52 <elliott> apple likes files that are directories
16:14:22 <oio> any idea how to detect them
16:14:33 <elliott> @hoogle isDirectory
16:14:34 <lambdabot> System.Posix.Files.ByteString isDirectory :: FileStatus -> Bool
16:14:34 <lambdabot> System.Posix.Files isDirectory :: FileStatus -> Bool
16:14:35 <elliott> (race conditions etc. etc.)
16:16:16 <oio> k thn
16:25:22 <acowley> I wish ghc-mod could show me shadowing warnings even when there's an error.
16:26:31 <adit123> Here's a script I wrote to open package documentation from vim: https://gist.github.com/egonSchiele/5819008
16:27:13 <adit123> go to an import line, hit <leader>h, and ta-da!
16:28:09 <xico> crap. i spend a couple of hours reimplementing a slow (numerical intensive) part of my haskell program in c, used -O3 -march of gcc, and its 4 times slower!
16:29:42 <josephle> xico: is the c code cache friendly?
16:29:48 <c_wraith> xico: it's easy to accidentally write slow numerical code.  There are so many ways to go wrong.
16:29:55 <c_wraith> (in any language)
16:30:25 <xico> nope. its straightforward. processes arrays of several megabytes though.
16:30:37 <enthropy> acowley: gfortran (and probably the rest of gcc) try to give you lots of errors after the first one... it's not always clear that such behavior helps you get code that parses properly
16:30:51 <josephle> xico: cache awareness goes a long way...
16:31:55 <hpaste> xico pasted “rec filter” at http://hpaste.org/90167
16:32:09 <xico> thats how the code look
16:32:19 <xico> my haskell code is the simple translation of it
16:32:22 <acowley> enthropy: Yeah, a bunch of errors after a parse error is always annoying. But ghc-mod's emacs integration helpfully highlights cases of variable shadowing. A precursor to this is often a differently colored highlight where the type checker bombed out.
16:32:22 <xico> but its way faster
16:33:22 <acowley> enthropy: That is to say, the highlighting of identifier shadowing that still type checks is nice, but when I have a type error in the vicinity of some shadowing, I want the shadowing highlighted as well as the error.
16:35:36 <xico> http://codereview.stackexchange.com/questions/27249/implementing-recursive-filters-with-haskell-repa
16:35:41 <xico> thats just the haskell translation
16:35:47 <xico> works way... faster
16:35:52 <xico> even without multithreading
16:38:58 <xico> i'm wondering why the haskell code is so much faster. but still, i need at least code 10x faster, so i will probably keep using my gpu implementation for now
16:39:04 <xico> or try accelerate
16:40:49 <josephle> xico: well I'd like to think that repa was designed to be cache-friendly :)
16:41:08 <xico> well my code does not use repa
16:41:15 <xico> just as input and output
16:41:30 <xico> then i cast everything into a mvector and process it element by element
16:41:33 <xico> just like in c
16:43:30 <Ralith> xico: idk about perf, but you could probably move all this into ST and have it be nice and pure without *losing* efficiency
16:44:01 <akegalj> I have to count word frequency in ~100,000 files and store it in Map. Becaouse of lazy file reading i get "openFile: resource exhausted (Too many open files)". How should i resolve this?
16:44:43 <joelteon> is evaluate the right thing to use there
16:44:49 <xico> Ralith: i dont think so. i am multithreading it with the gangIO from repa, and there is no st equivalent.
16:45:19 <akegalj> joelteon: i tryed evaluate but with no luck, i realy dont understand how it works
16:45:20 <Ralith> oh, I thought you said you weren't using multithreading
16:45:29 <xico> yeas, to compare with c
16:45:34 <xico> since i do not in c
16:45:42 <xico> it just a parameter in the haskell function
16:45:55 <Ralith> might still be a way to purify it, but idk
16:46:02 <joelteon> dunno, akegalj, I'd have to play around with it
16:46:38 <FreeFull> akegalj: You could try strict IO
16:46:48 <josephle> akegalj: or stream-based IO
16:47:10 <josephle> although strict is probably easier to transition to
16:50:09 <newsham> akegalj: cat *files* |haskwordfreqprog ?  ;-)
16:50:41 <newsham> how are you reading the files?  are you fully reading the entire file?
16:56:23 <akegalj> newsham: catting files wont work because of the problem (specific file structure). Yes, i'm fully reading, but laizy reading is kicking in. trying strict-io now
17:07:29 <akegalj> josephle: strict-io works, thnx
17:12:59 <agocorona> #join #haskell-web
17:13:06 <Fuuzetsu> @pl f x y = x [y]
17:13:07 <lambdabot> f = (. return)
17:13:26 <Fuuzetsu> …I can't believe I didn't think about this myself
17:20:39 <ion> fuuzetsu: Perhaps because the original form is better?
17:21:16 <shachaf> ion++
17:21:16 <Fuuzetsu> ion: Well, I'm not going to be using the pl form but it still should have occurred to me how it might be created…
17:26:25 <badzavrza> http://www.california-roleplay.org/
17:31:18 <fwe>  i was in project that was failing and as a result got my probation period extended. they said my programming skills were not that good. however an expert programmer was brought in and the project is still failing. the project manager and i had had an argument and that is why he tried to sabotage me. do you feel the boss knows the truth now?
17:31:36 <elliott> fwe: this channel is about the haskell programming language.
17:31:51 <fwe> is that like matlab?
17:31:58 <elliott> are you mrBG?
17:32:05 <fwe> no
17:33:20 <fwe>  i was in project that was failing and as a result got my probation period extended. they said my programming skills were not that good. however an expert programmer was brought in and the project is still failing. the project manager and i had had an argument and that is why he tried to sabotage me. do you feel the boss knows the truth now?
17:33:24 --- mode: ChanServ set +o shachaf
17:33:26 --- mode: ChanServ set +o elliott
17:33:28 --- mode: elliott set +b *!*ssjsj@31.205.67.*
17:33:29 --- kick: fwe was kicked by elliott (fwe)
17:33:34 --- mode: elliott set -o shachaf
17:33:35 --- mode: elliott set -o elliott
17:33:44 <Ralith> that was weird
17:34:40 <elliott> probably just the persistent off-topic troll. he said he was going to get a new IP.
17:52:32 <Aetherspawn> is Janek here?
17:52:39 <oio> filter a list with IO Bool?
17:52:50 <dmwit> :t filterM
17:52:50 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
17:53:12 <dmwit> In fact:
17:53:18 <dmwit> ?hoogle (a -> IO Bool) -> [a] -> IO [a]
17:53:19 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
17:53:19 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
17:53:19 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
17:53:41 <dmwit> So learn to phrase your questions a bit better and you can get an automated answer. =)
17:53:57 <oio> Ok thnx
17:54:33 <shachaf> Learning to phrase your questions a bit better helps with #haskell, too.
17:54:44 <joelteon> Monoid is probably the greatest typeclass ever created
17:56:42 <josephle> mappend all the things!
18:08:41 <ion> joelteon: Except that it doesn’t depend on Semigroup.
18:10:02 <elliott> ion: it wouldn't be as easy if it did.
18:10:36 <ion> elliott: I’m sure it could still be loved.
18:11:17 <Aetherspawn> is there an unsafeHead function
18:11:27 <ion> Yes, it’s called head.
18:11:29 <thoughtpolice> head is already unsafe :P
18:11:32 <Aetherspawn> Oh okay
18:15:46 <dmwit> Aetherspawn: head is a code smell
18:17:01 <ion> > map (map (head &&& length) . group) cake
18:17:02 <lambdabot>   Not in scope: `cake'
18:17:02 <lambdabot>  Perhaps you meant one of these:
18:17:02 <lambdabot>    `take' (imported f...
18:17:34 <dmwit> group :: Eq a => [a] -> [(a, [a])] -- ;-)
18:17:53 <ion> :-)
18:18:04 * tabemann celebrates having gotten a pure red-black tree *with removal* working, having worked off rather inadequate info about red-black trees with at most unhelpful code examples in imperative languages
18:18:19 * dmwit high fives tabemann
18:19:14 <tabemann> now I just have to get rid of all those traces I added to my code...
18:20:31 <elliott> dmwit: group :: Eq a => [a] -> [NonEmpty a]
18:20:54 <dmwit> type NonEmpty a = (a, [a]) -- and the circle is complete
18:23:14 <dmwit> (and then you realize that "NonEmpty a" is actually more characters than "(a, [a])" and the circle is really complete)
18:23:26 <elliott> dmwit. I want a sphere.
18:23:41 <shachaf> dmwit: I don't care about characters, I care about the mental burden of it.
18:23:44 <dmwit> a circle is a 2-sphere, hth
18:23:53 <shachaf> And two extra levels of nesting is a lot worse than one extra identifier.
18:24:40 <shachaf> [((a, [a]), [a])]
18:25:19 <Aetherspawn> when I try and put in # for unboxing I always get a syntax error
18:25:23 <Aetherspawn> do I need to enable an extension?
18:25:31 <geekosaur> MagicHash
18:25:32 <Ralith> magichash
18:25:44 <Aetherspawn> thanks
18:25:47 <dmwit> SecretHashshashin
18:26:00 <c_wraith> that's a lot of shshs
18:26:32 <geekosaur> hard to type properly when you're on that much magic hash :p
18:26:38 <dmwit> Wait til you see how many s's "assassin" has.
18:26:58 <shachaf> Not as many as "assassins".
18:27:08 <c_wraith> Seems similar to the Mississippi count
18:27:22 <elliott> TechnologyHash -- GHC is sufficiently advanced
18:27:35 <byorgey> there are yet more in "sassassins".
18:27:35 <Aetherspawn> aww unboxing everything doesn't make a difference
18:27:45 <byorgey> they kill you with sass.
18:27:53 <c_wraith> Aetherspawn: did you check to see if the compiler was already doing it for you?
18:27:58 <dmwit> Which word possesses more esses than possesses possesses?
18:28:06 <Aetherspawn> I have the core output but its huge and confusing
18:28:33 <dmwit> Apparently the "hashish" etymology of "assassin" is just a flat lie.
18:28:39 <dmwit> Thanks a lot, Marco Polo!
18:28:43 <byorgey> dispossessionsise
18:43:30 <Aetherspawn> Turns out the compiler already unboxed and strictified everything
18:45:19 <ion> buttbuttin
18:47:22 <sclv> X magic hash would be a good band name
18:58:30 <iKillCypher> hello this few days I have been hearing about Haskell I dont really know what is it about, Im a java programmer not really a good one.. just a quick questions if I chose to learn Haskell what are the benefits is it better the C/C++ will I be able to write dll ? or winapi etc
18:59:20 <dmwit> There are some very basic bindings to the win32 API.
18:59:42 <dmwit> Not a lot of Haskell programmers use Windows, though.
19:00:29 <dmwit> As for benefits, Haskell has a delightful type system; is functional; and the most common implementation strategy uses lazy evaluation.
19:00:40 <josephle> today I sat on a tech talk named "Typeclasses and Java". The whole talk was on Scala. I was so disappointed.
19:00:41 <dmwit> There are several fine essays out there about why each of these matter.
19:01:34 <latermuse> when I use T.readFile on a file with an "\" in it, it escapes the "\" by doing "\\". is there any way to unescape this or prevent it from happening?
19:01:36 <iKillCypher> well what will you say about someone who wants to learn haskell ?
19:01:40 <sclv> you can use the win api or write dlls if you so desidre
19:01:44 <iKillCypher> given the choice Im not really good at programming?
19:01:56 <sclv> learning haskell will make you better at programming!
19:01:57 <iKillCypher> I know the neat basic of Java and etc
19:02:00 <sclv> it did for me
19:02:17 <dmwit> iKillCypher: No problem. I encourage even non-programmers to learn Haskell.
19:02:29 <sclv> it also makes lots of math and logic more accessible
19:02:32 <shachaf> latermuse: I suspect that your premise is wrong.
19:02:38 <sclv> because it relates to them quite well
19:02:48 <iKillCypher> so chances of them to become awesome at haskell if they pick up it as first langanges ?
19:02:53 <sclv> sure
19:02:53 <iKillCypher> it is oop right?
19:02:56 <sclv> no
19:02:58 <sclv> no oop
19:02:59 <latermuse> shachaf: perhaps. could you enlighten me? :)
19:03:01 <sclv> it is functional
19:03:06 <shachaf> latermuse: As usual, the questions are: What did you do? What did you expect? What actually happened?
19:03:44 <sclv> it is good at most things, but particularly strong if you care about parallelism, concurrency, distributed systems, or building embedded languages or tools to target CUDA, GPU code in general, etc
19:03:57 <dmwit> ?where tutorials
19:03:57 <lambdabot> http://haskell.org/haskellwiki/Tutorials
19:03:59 <elliott> also networking
19:04:01 <latermuse> i have a few lines in a text file, and they have "\" in them
19:04:03 <elliott> compilers
19:04:26 <ekipan> I've been walking through GoogleTechTalks lately. This one was fun and is maybe good for a beginner (?): http://youtu.be/b9FagOVqxmI >iKillCypher
19:04:28 <latermuse> but when i open the file with T.readFile, it shows up at "\\", which i know means it is being escaped
19:04:34 <latermuse> but I would rather it not be escaped. is that possible?
19:04:39 <sclv> latermuse: the escaping is when you print it, not when you read it!
19:04:41 <dmwit> latermuse: Be precise.
19:04:48 <dmwit> latermuse: What does "it shows up as" mean?
19:04:54 <iKillCypher> ok so for a newbie or someone who dont know anything about computer science is able to learn Haskell just as well
19:04:55 <sclv> > show "\\hi"
19:04:56 <lambdabot>   "\"\\\\hi\""
19:05:05 <sclv> > show "\hi"
19:05:06 <lambdabot>   <hint>:1:8:
19:05:06 <lambdabot>      lexical error in string/character literal at character 'h'
19:05:08 <sclv> whoops
19:05:11 <iKillCypher> is pretty high?
19:05:29 <sclv> > "\\hi"
19:05:31 <lambdabot>   "\\hi"
19:05:36 <latermuse> T.replace "\\" "\" "\\130\\141"
19:05:40 <latermuse> i want to do that, haha
19:05:47 <sclv> i promise you it is just showing it escaped.
19:05:49 <shachaf> latermuse: No, you don't want to do that.
19:05:56 <sclv> i can't do putStrLn from \bot because it is IO
19:06:06 <iKillCypher> ok so for a newbie or someone who dont know anything about computer science is able to learn Haskell just as well? is pretty high
19:06:09 <sclv> but if you did, it would print the real string rather than the escaped one you "show"
19:06:13 <sclv> and it would only have the one slash
19:06:15 <latermuse> basically im getting a bunch of shift_jis stuff, and i want to parse it without first converting it to unicode or something
19:06:17 <shachaf> latermuse: You still haven't answered my question. You should be precise, like dmwit said.
19:06:38 <shachaf> latermuse: In particular a good way to ask the question is: Here's my full code; here's the full output I get from GHC; here's the full output I'd expect.
19:06:40 <sclv> the problem is data.text expects to read utf8
19:06:53 <sclv> latermuse: paste the code in hpaste.org
19:06:54 <ekipan> most programming in most languages requires you to become accustomed to the von Neumann model of a stateful RAM that varies across time as your program executes
19:07:01 <latermuse> hpaste incoming, give me a few moments
19:07:02 <shachaf> Otherwise it's hard to tell what's actually going on and what you're assuming.
19:07:19 <sclv> if you have an encoding that is not utf8 you need a different library to read it than just text
19:07:26 <ekipan> Haskell is less burdened with that for everyday computation, at least to begin with
19:07:38 <iKillCypher> uh can someone answer me :(
19:07:59 <dmwit> iKillCypher: Ask a real question.
19:08:29 <dmwit> Knowing less makes things harder. That's probably true of basically all endeavors.
19:08:30 <iKillCypher> well is it okay for a newbie to learn haskell ?
19:08:41 <dmwit> But with hard work and perseverance, YES, you can learn Haskell.
19:08:55 <dmwit> "okay"?
19:08:59 <dmwit> Sure, it's "okay".
19:09:22 <sclv> ?where lyah
19:09:22 <lambdabot> http://www.learnyouahaskell.com/
19:09:31 <sclv> iKillCypher: this is a good easy tutorial ^^
19:09:56 <elliott> note: "easy" doesn't mean "unchallenging" :)
19:09:57 <ekipan> dive in, download the Haskell Platform and follow along with LYAH or whatever
19:11:42 <timemage> iKillCypher, you may find that at least an attempt to learn haskell will improve your other code (even java code).  if you stop anywhere along the way you'll probably be better off than if you hadn't tried it.
19:11:54 <Aetherspawn> @where lyah
19:11:54 <lambdabot> http://www.learnyouahaskell.com/
19:12:01 <Aetherspawn> @where exercises
19:12:01 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
19:12:07 <Aetherspawn> iKillCypher, ^
19:12:13 <iKillCypher> thanks ^^
19:12:19 <Aetherspawn> sincerely, ghoul.
19:12:22 <iKillCypher> nick seems familar
19:12:23 <iKillCypher> lol
19:12:24 <Aetherspawn> You could have asked that on the other irc.
19:16:25 <sclv> latermuse: http://stackoverflow.com/q/5450394/371753
19:17:07 <AsgardBSD> Hi
19:17:25 <AsgardBSD> Summer, a great time to finally get to haskell...
19:17:39 <monochrom> welcome
19:17:59 <neutrino> don't google for "This FTP Site"
19:18:29 <AsgardBSD> neutrino: ?
19:18:43 <monochrom> for some other students who were forced to learn haskell, "summer, a great time to finally leave haskell" :)
19:19:34 <byorgey> AsgardBSD: welcome =)
19:19:36 <neutrino> "summer, a great time to stop using scala"
19:19:49 <shachaf> No language bashing in here, please.
19:20:30 <AsgardBSD> I like scala :(
19:20:44 <dmwit> AsgardBSD: Oleg's website; Oleg is a type theory expert, and does some absolutely mind-boggling things with Haskell and Haskell's type system.
19:20:56 <dmwit> AsgardBSD: It's great fun, but probably not a helpful way to start with haskell.
19:21:22 <dmwit> AsgardBSD: (re: neutrino's comment about "This FTP Site")
19:21:36 <AsgardBSD> dmwit: that site: http://okmij.org/ftp/?
19:21:41 <dmwit> the very one
19:21:54 <shachaf> There's absolutely no reason to mention it in this context.
19:22:22 <AsgardBSD> Its written nowhere that its Oleg website...
19:23:54 <AsgardBSD> Why would somone want to leave haskell...
19:25:24 <AsgardBSD> The only thing i fear about haskell is finding no real use for it (but i like using thing i even dont find real use, as long as its fun and challenging, and i can learn thing)
19:27:35 <dolio> You can use Haskell for lots of real things.
19:27:41 <dolio> Like compiling Haskell.
19:27:55 <dolio> And helping your editor suggest indentation for your Haskell.
19:27:57 <byorgey> AsgardBSD: of course I think that fear is quite unfounded.  But then, we're all pretty biased.  So you should just try it and see for yourself. =)
19:28:03 <byorgey> hehehe
19:28:03 <monochrom> I use it for my own small programs.
19:30:14 <monochrom> my irc clients and eggdrop bots accumulate a lot of log files like haskell-20130617.log. every night, a cron job runs my haskell program to merge them into haskell-201306.log, so that I don't have a million files
19:30:24 <AsgardBSD>   i doubt learning haskell couldnt be worse than what i learned at school (or what they forced us to learn...)
19:30:30 <Aetherspawn> When I call processBroadcast normally on a broadcast it's the right type, but when I use mapM_ for some reason it gets unwrapped from the state I need it in since processBroadcast needs to use the state. Code & example & error: http://hpaste.org/90169 advice is appreciated.
19:30:47 <monochrom> and also, to merge haskell-201201.log through haskell-201212.log into haskell-2012.log
19:31:10 <Ralith> and compress them simultaneously, I hope
19:31:15 <monochrom> it is a small simple program, but you can't say it's unreal. it's a very real application.
19:31:33 <monochrom> I don't want them compressed. and a 500GB disk is coming.
19:31:43 <Ralith> why, when gzcat is a thing?
19:31:44 <monochrom> I want to grep them trivially
19:31:59 <Ralith> zcat, rather
19:32:14 <monochrom> how about: whenever I enter a grep command, I'm too lazy to type in "zcat"?
19:32:25 <Ralith> that is pretty lazy!
19:32:37 <Ralith> whatever works I suppose
19:32:52 <monochrom> if 500GB of disk space spares me typing 4 letters, why not
19:32:55 <AsgardBSD> At school, they forced us to use VB.net to create some form, and when we click on button, it does some useless thing... the worst course ever...
19:33:16 <AsgardBSD> the prof even had difficulty to compile without error
19:33:38 <AsgardBSD> Haskell will be so fun compared to that...
19:33:59 <elliott> monochrom: there is "zgrep" too. but yes, laziness wins against any obstacle
19:35:36 <monochrom> also, premature compression etc etc :)
19:36:46 <u_> in ghci
19:36:53 <u_> when i'm trying to write something small
19:37:00 <u_> often when i change one definition
19:37:12 <u_> i'll have to press up arrow dozens of times and change 3 other definitions that depend on it
19:37:31 <u_> is there an easier way to do this or should i just not use ghci for anything bigger than a 1 liner?
19:37:35 <AsgardBSD> I wish they could have a haskell course on coursera or EDX (or maybe even udacity)
19:38:25 <monochrom> the easier way is to edit a file and then :load it, or even :reload
19:38:44 <Ralith> u_: you should not use ghci for authoring.
19:38:52 <u_> :(
19:38:52 <u_> fine
19:39:05 <monochrom> alternatively it is possible to merge N lines into 1 for ghci
19:39:17 <u_> its either that or leksah and leksah is bloated and ugly
19:39:33 <u_> sometimes i put it in a text editor and hit :r over and over in ghci
19:39:47 <monochrom> try this: let {x=True; y=False}
19:39:54 <sclv> u_: that's what most of us do
19:39:55 <monochrom> generalize to your use case
19:40:30 <u_> yeah i do that sometimes but when the line gets too big you still have to press the arrow keys a lot
19:40:37 <u_> good to know sclv
19:40:47 <monochrom> when the code is too big, you need an editor
19:41:08 <Ralith> u_: emacs has a 'load in ghci' key
19:41:36 <monochrom> exactly like when you want to show me 100 lines of code, you don't type them into IRC, you use a pastebin and just tell me the url
19:57:14 <AsgardBSD> :( Haskell platform not available on slackware
19:57:38 <Ralith> AsgardBSD: all you need is ghc and cabal
19:57:59 <Aetherspawn> I tried to install cabal on an amazon aws but had a chicken egg problem
20:01:35 <AsgardBSD> Does haskell has the concept of "Standard library"?
20:02:30 <sclv> yes, we have a minimal base, with some libs. and the rest is platform
20:03:16 <sclv> Aetherspawn: I don't have a chicken egg problem. I just boil 'em up and eat em.
20:03:22 <monochrom> you have two options:
20:03:23 <sclv> and i can stop anytime i want.
20:03:36 <Aetherspawn> :P
20:04:03 <monochrom> if just ghc and cabal-install: http://hackage.haskell.org/packages/archive/cabal-install/1.16.0.2/cabal-install-1.16.0.2.tar.gz , then use its bootstrap.sh
20:04:25 <monochrom> if haskell platform: see my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
20:06:02 <Aetherspawn> in regards Don's answer here: http://stackoverflow.com/a/3077912/1220423
20:06:21 <Aetherspawn> was he talking about avoiding the state monad and using argument passing where possible or just states in general?
20:08:25 <monochrom> I solve the chicken-egg problem by preferring egg in the morning, chicken for lunch and dinner
20:08:56 <monochrom> sometimes the whole problem is sidestepped by peanut butter in the morning, lamb chops for dinner
20:09:07 <monochrom> and haskell for lunch
20:09:12 <AsgardBSD> Anyone already heard of coq?
20:09:18 * hackagebot watcher 0.0.1 - Opinionated filesystem watcher.  http://hackage.haskell.org/package/watcher-0.0.1 (NateSoares)
20:09:21 <monochrom> yes
20:09:26 <AsgardBSD> http://en.wikipedia.org/wiki/Coq
20:09:33 <AsgardBSD> it look like interesting
20:10:33 <mapreduce> AsgardBSD: Idris and Agda would be worth a look too.
20:11:31 <byorgey> AsgardBSD: http://www.cis.upenn.edu/~bcpierce/sf/
20:11:33 <thoughtpolice> shachaf: on an unrelated topic, i'm also wondering what's ever going to happen with the whole newtype wrapper story that Simon floated around a few months ago.
20:11:40 <thoughtpolice> (since this is off topic in -blah)
20:11:47 <monochrom> I am not thrilled by proof rules based on natural deduction, except for curiosity and baby logic
20:11:49 <shachaf> thoughtpolice: Oh, I should reply to him about it.
20:11:58 <elliott> that story was quite bad. :(
20:11:58 <shachaf> thoughtpolice: Since his solution is almost completely irrelevant to us.
20:12:28 <thoughtpolice> i was just reading through the wiki the other day and got reminded of it.
20:12:44 <shachaf> I need to reply to him.
20:12:47 <shachaf> It's been a long time.
20:12:56 <shachaf> I bet he hates me now. :-(
20:13:21 <AsgardBSD> Nice, agda written in haskell
20:14:06 <thoughtpolice> shachaf: make a proposal, then you can implement it!
20:14:18 * hackagebot watcher 0.0.2 - Opinionated filesystem watcher.  http://hackage.haskell.org/package/watcher-0.0.2 (NateSoares)
20:14:39 <thoughtpolice> i promise i'll merge your patch quickly When It's Ready
20:14:53 <shachaf> I don't even know what the right solution is.
20:15:01 <shachaf> SPJ solved the immediate issue, I *think*.
20:15:09 <shachaf> I haven't gotten around to getting HEAD building and testing it yet.
20:16:21 <shachaf> thoughtpolice: OK, I'll get HEAD building now, just for you.
20:19:41 <MitchellSalad> hi, can someone give me an idea how to remove block comments from a source file read in (trying to count lines of code). something that transforms ["line", "line with /* comment", "still in a comment", "ending */ foo = bar"] to ["line", "line with", " foo = bar"]
20:19:57 <MitchellSalad> it seems like a very stateful operation, knowing if you're inside a comment
20:20:17 <shachaf> What about nested comments?
20:20:25 <ekipan> treat comments as whitespace
20:20:40 <MitchellSalad> nested block comments....? can those exist?
20:20:47 <arkeet> they do in haskell
20:20:55 <MitchellSalad> well, let's start simple :P
20:21:09 <elliott> I suggest working on a flat string, not a list of lines
20:21:36 <arkeet> sounds like you have to determine whether a comment contains a newline.
20:21:39 <MitchellSalad> yeah, good suggestion
20:26:29 <dmwit> MitchellSalad: Has haskell-src-exts been suggested yet?
20:26:33 <dmwit> If not, I suggest it.
20:26:45 <elliott> er. for /* ... */ coments?
20:27:02 <dmwit> He'll come around to Haskell syntax shortly, I'm sure. ;-)
20:27:20 <dmwit> Okay, I generalize my advice: have you considered using an already battle-tested parser for your language of choice?
20:27:45 <dmwit> There is one for C on Hackage, too.
20:30:03 * tabemann is frustrated that his pure red-black tree implementation is producing very unbalanced, if *valid*, trees in certain use cases...
20:32:15 <dmwit> Valid red-black trees can't be very unbalanced.
20:32:28 <dmwit> (For a pretty good definition of "very unbalanced".)
20:33:02 <tabemann> what it's doing is that if you put items in the tree in order, it will make one side of the tree fill up with black nodes, and put all the red nodes in the other side
20:33:21 <tabemann> and thus the side with the red nodes will become notably deeper than the side that has only black nodes
20:33:59 * AsgardBSD wish had time to learn more thing, like red black tree
20:34:14 <tabemann> yet the tree is valid, because the *black* depth is the same everywhere, and no two red nodes come after one another
20:34:26 * AsgardBSD but with summerschool and work and driving school, he has almost no free time
20:35:33 <tabemann> I implemented red-black trees just as an experiment as to how to create such as *pure* data structure, already knowing that similar trees are used a lot in Haskell
20:37:23 <tabemann> the hard part was that most of the descriptions sucked and assumed that one would be modifying a tree in an imperative fashion, and that removal turns out to be complex
20:38:35 <dmwit> The "red" side should still be no more than twice as deep as the "black" side.
20:38:55 <AsgardBSD> Hey guy, was wondering, what other language should i learn with haskell to have a good background
20:39:16 <tabemann> dmwit: okay, it's not *that* unbalanced
20:39:22 <elliott> AsgardBSD: haskell
20:39:31 <elliott> you will find it more than enough work
20:39:32 <m3ga> AsgardBSD: C for an understanding of how the low level machine works, haskell for how to think about programming.
20:39:34 <mapreduce> Greek.
20:39:39 <mapreduce> It'll help you read the papers.
20:39:40 <AsgardBSD> a programmer shouldnt know only 1 language
20:39:51 <dolio> Good background for what?
20:40:22 <elliott> AsgardBSD: one step at a time.
20:40:26 <AsgardBSD> a programmer background
20:40:29 <AsgardBSD> already know C
20:40:39 * tabemann came to Haskell knowing OCaml, which helped a lot, but even then, there's still a wide gulf between the two
20:40:49 <ekipan> if you want to know how the machine works, learn an assembly language, any will do
20:40:54 <Sgeo> Ah, so you want a lot of variety in the languages you learn?
20:41:02 <dolio> Learn Lambda Prolog.
20:41:18 <Sgeo> Possibly a Lisp would be good too, in addition to the others being mentioned
20:41:51 <shachaf> ekipan: x86 is pretty different from how any modern x86 CPU "works"
20:41:51 <AsgardBSD> Scala would be good?
20:42:23 <Sgeo> Probably wouldn't suggest Scala. With Haskell, you get the things you'd learn from Scala, and more, in a much nicer way
20:42:25 <tabemann> OCaml seems like it'd be better than a Lisp, having a Hindley-Milner type system, algebraic data types, pattern matching, and many other similar things
20:42:31 <elliott> if you try to learn two wildly different languages to C simultaneously you're probably going to find it frustrating.
20:42:41 <tabemann> the big difference being that OCaml is strict and supports imperative code
20:42:48 <mapreduce> Scala if you already know Java.
20:42:52 <Sgeo> tabemann, if AsgardBSD is looking for a language similar to Haskell, sure
20:42:53 <AsgardBSD> elliott: i have the whole summer to learn those
20:42:56 <tabemann> and has its class system which is different from type classes in Haskell
20:43:13 <elliott> AsgardBSD: I've been using Haskell for 6 years and I'm still learning.
20:43:16 <Sgeo> But for a broad variety of ideas, a language good with metaprogramming might be a good idea
20:43:49 <arkeet> I should learn scheme at some point.
20:44:04 <AsgardBSD> one week of haskell... one week of "insert something"... another week of haske...
20:44:17 <dolio> If you're going to learn a lisp, it should be Racket.
20:44:20 <arkeet> that might not be a bad idea.
20:44:20 <mapreduce> Python.
20:44:23 <elliott> well, you sound like you've made up your mind already, so okay.
20:44:32 <tabemann> Scheme is a cute language, but I'm not sure if it's a language I'd do work in, due to having too small a core and too fragmented a periphery
20:44:33 <arkeet> except for me it was more like
20:44:44 <arkeet> one week of haskell, a few years of ???, and then back to haskell.
20:44:47 <arkeet> everything made more sense the second time.
20:45:12 <arkeet> tabemann: that's why I don't have much motivation for learning it.
20:45:15 <Sgeo> dolio, I like Racket, but still have a hard time wrapping my mind around its macros... which isn't necessarily bad, but
20:45:59 <dmwit> A Lisp, a Prolog, a dependently typed language, an OOP language, an imperative language... and assembly, just because.
20:46:30 <amosr> "walk into a bar"?
20:46:31 <dmwit> Then learn a few domain-specific languages for good measure.
20:46:43 <shachaf> JavaScript is the best example of a domain-specific language.
20:46:57 <shachaf> Because of the same-origin policy.
20:47:00 <dmwit> What the hell, if you want a really crazy language base, why not add something like Boomerang or System F-pop to your list?
20:47:02 <arkeet> shachaf: haha
20:47:31 <dmwit> Try on Guru if you're into dependent typing for embedded systems.
20:47:38 <dmwit> There's SO MANY AWESOME CHOICES
20:48:02 <arkeet> I think lua is worth learning and/or knowing.
20:48:13 <dmwit> But yeah, spend a few months in Haskell first. Branch out when you get bored, not before.
20:48:30 <AsgardBSD> what about clojure?
20:48:31 <dolio> Sgeo: I feel like Racket is the language most people should be using unless they have a better reason; and most languages don't. :)
20:48:32 <arkeet> @remember shachaf JavaScript is the best example of a domain-specific language. Because of the same-origin policy.
20:48:32 <lambdabot> Done.
20:48:38 <AsgardBSD> lisp on JVM
20:48:43 <dmwit> Oh, yes, learn a language designed for scripting like Lua or... what's that other one? tcl
20:48:51 <AsgardBSD> python ruby
20:49:06 <dmwit> Python and Ruby are not sufficiently different from the status quo to be interesting to learn.
20:49:34 <Sgeo> dmwit, I find Tcl interesting mostly from a metaprogramming perspective
20:49:34 <AsgardBSD> Go, D, rust?
20:49:35 <dolio> Like, don't ever use Python or Ruby, for instance. Racket is just better. :)
20:49:56 <Sgeo> dmwit, a 'status quo' language might be good to put on the list, to learn what the status quo is
20:49:58 <tunixman> yeah, racket.
20:50:04 <dmwit> AsgardBSD: boring, lots of stuff bolted onto a boring language, don't know
20:50:07 <ekipan> there was some online course that I peeked through that went from gates and flip-flops to adders to ALU to RAM modules to CPU with instruction set to assembler to a basic OS
20:50:12 <mapreduce> I recommend Python for newbies because they will be able to do stuff and hopefully not worry so much about type errors or boilerplate.
20:50:21 <elliott> this is silly. this is #haskell, not #judgements-of-other-random-languages :)
20:50:30 <shachaf> ==elliott
20:50:35 <dmwit> oooo, a hardware language would be good to put on the list, good idea ekipan
20:50:42 <arkeet> AsgardBSD: I've heard good things about rust. but it's probably something to leave until later
20:50:42 <arkeet> maybe.
20:50:59 <elliott> and it's just going to incite a silly argument or flamewar.
20:51:01 <shachaf> This is off-topic and language bashing is in particular not allowed.
20:51:26 <arkeet> what about some numerical computing language?
20:52:33 <dmwit> shachaf: Tough to avoid it, though, isn't it!
20:52:36 <ekipan> oh here it is! http://nand2tetris.org/
20:52:37 <sclv> here's a new stress test of ghc: http://stackoverflow.com/questions/16924106/is-there-a-maximum-number-of-modules-that-can-be-compiled-via-cabal
20:52:59 <josephle> shachaf: to clarify, does talking about other languages type-systems not count as bashing?
20:53:05 <sclv> ~6800 modules
20:53:11 <josephle> like the discussion I had earlier todaay about ML module systems
20:53:14 <ekipan> I only did a little nosing through some of the coursework PDFs, but it seems like golden stuff
20:53:59 <Sonarpulse> anybody here used http://enet.bespin.org/ before?
20:54:22 <Sonarpulse> I'm making bindings, but I've never used it so I have some qualitative questions, so to speak.
20:54:28 <Ralith> ekipan: with magic manufacturing tech, CE could be a profession where you your time in spend school building the tools of your profession
20:54:32 <Ralith> that'd be pretty neat
20:54:37 <Sonarpulse> posted in #haskell-game, but as that's quieter, asking here too
20:55:17 <AsgardBSD> ekipan: what was that course?
20:55:24 <ekipan> it litterally goes step-by-step from nothing to a tetris, having you build everything along the way
20:55:33 <AsgardBSD> interesting
20:55:39 <ekipan>  http://nand2tetris.org/
20:59:31 <flebron> is there a way to have an unboxed Int Array be computed at compile time, and inserted straight into the binary, as opposed to computing it at runtime?
20:59:53 <flebron> (the C analogue of a "int foo[10] = {...}" at file scope)
21:01:28 <AsgardBSD> Thanks for sharing ekipan
21:12:18 <AsgardBSD> does haskell run on arm architecture?
21:13:33 <flebron> @faq Can Haskell run on ARM?
21:13:33 <lambdabot> The answer is: Yes! Haskell can do that.
21:13:51 <Sonarpulse> some haskell rasberry pi thing if I remember
21:14:08 <AsgardBSD> NIce, planned to run haskell on raspeberry pi
21:14:31 <AsgardBSD> i am currently studying in embeded electronics (im a low level programmer...)
21:14:49 <ion> I have ran GHC on a Beagle Bone. The Debian packaging worked.
21:14:54 <amosr> flebron: -XMagicHash, I think
21:15:04 <AsgardBSD> I also planned to buy beagle bone
21:15:17 <ion> The new Beagle Bone Black looks cool.
21:15:21 <AsgardBSD> ion: studying in electronics? (or having electronics in hoby?)
21:15:29 <ion> asgardbsd: Hobby
21:15:42 <AsgardBSD> at university, i will continue in CS or Ce
21:15:47 <flebron> amosr: How would I use that to get a compile time unboxed array?
21:16:25 <sclv> i've heard of it running on raspberry pi
21:16:43 <sclv> but not heard of anyone doing anything really neat with it on one
21:16:45 <AsgardBSD> I planend on buying beaglebone black, raspppberry B and cubie board
21:16:54 <amosr> flebron: hmm, I thought there was a syntax like [# 3#, 4# #] but maybe I'm imagining it
21:16:59 <AsgardBSD> I am wondering if haskell could be useful in embeded...
21:17:09 <flebron> I think I have to use template haskell
21:17:24 <sclv> embedded often has hard real time constraints
21:17:29 <sclv> which rules out haskell directly
21:17:37 <AsgardBSD> i live in quebec... here at quebec, we must do college before university
21:17:54 <AsgardBSD> at college, we can do either a pre-university or a tech
21:17:59 <amosr> flebron: here's an example that uses an unboxed string. argh!
21:18:00 <sclv> but there are dsls like atom and copilot that generate very code for embedded systems
21:18:05 <amosr> flebron: http://hackage.haskell.org/packages/archive/warp/1.2.0/doc/html/src/ReadInt.html
21:18:05 <geekosaur> nhc98 used to target embedded platforms; jhc compiles to ANSI C and may have some ability to constrain the garbage collector; aside from that, I think there's ... that
21:18:07 <AsgardBSD> pre university is 2 year while tech is 3 year
21:18:25 <AsgardBSD> i choosed tech to explore electronics and then i will continue in CS or CE at university
21:18:59 <AsgardBSD> In my tech, we have to do a final project... wanted to include some haskell in that final project
21:19:15 <AsgardBSD> This will make the teacher go like WTF when they will check my project
21:20:42 <Sonarpulse> well rasburry pi isn't an embedded system
21:20:50 <AsgardBSD> yes it is
21:21:14 <Sonarpulse> well you can run normal desktop linux distros right?
21:21:22 <Sonarpulse> or fairly normal
21:21:26 <Sonarpulse> so constrain wise
21:21:49 <Sonarpulse> it's not like you are modding a wifi router or something
21:21:52 <AsgardBSD> embeded dont mean we cant run a full OS
21:22:01 <Sonarpulse> ok
21:22:16 <Sonarpulse> my point is that haskell is certainly valid on rasberry pi
21:22:25 <AsgardBSD> it mean singleboard, low power, lower ressource than full computer...
21:22:51 <Sonarpulse> 1 gig ram? 1 ghz?
21:23:04 <Sonarpulse> that's more than my old desktop which I have stock lubuntu on :D
21:23:30 <AsgardBSD> well, embeded of today is more powerful than computer that are 12 year old
21:23:47 <Sonarpulse> exactly, so I am glad you are interested in haskell
21:24:01 <Sonarpulse> I was mainly countering sclv's point
21:24:28 <Sonarpulse> (btw, there is also a haskell library for generating C for embed)
21:25:06 <Sonarpulse> the rasberry pi thing I herad of was demonstrating cloud haskell
21:25:18 <Sonarpulse> doing a ping-pong thing with multiple rasberry pis
21:26:21 <sclv> Sonarpulse: i wasn't talking about haskell on raspberry pi, i was just noting that some embedded systems have constraints that don't map directly to haskell
21:26:29 <amosr> flebron: but I imagine a quasiquoter to convert a constant ints to an unboxed string would be useful?
21:26:32 <sclv> but that we do things like atom and copilot to target them
21:27:47 <AsgardBSD> Sonarpulse: library for generating C for embed??
21:28:16 <Sonarpulse> sclv: I would agree with
21:28:24 <Sonarpulse> Asgard: atom and copilot
21:28:26 <Sonarpulse> yeah that is it
21:28:32 <Sonarpulse> * I would agree with that
21:28:33 <AsgardBSD> sclv: its sure that microcontroller are not suitable for functionnal programming
21:28:45 <AsgardBSD> microcontroller have not enough ram for recursion
21:28:57 <Sonarpulse> tail call optomization :)
21:29:02 <AsgardBSD> but in my case, i use micro processor, not micro controller
21:29:26 <AsgardBSD> so small arm processor with 1 gig of ram
21:29:30 <Sonarpulse> immutable data structures, well GHC does amazing things but it may not be enough
21:29:39 <Sonarpulse> that is a big issue
21:30:01 <Sonarpulse> and then with the 100,000+ LoC run time system
21:30:11 <AsgardBSD> LoC?
21:30:16 <Sonarpulse> lines of code
21:30:19 <AsgardBSD> oh
21:30:30 <Sonarpulse> maybe its not normally capitalized that way
21:30:50 <Sonarpulse> well i think a bunch of old school embedded types wouldn't like that much code out of their control
21:30:55 <Sonarpulse> I mean its well written
21:31:17 <AsgardBSD> well, in my tech, we use micro controller exclusively, but in my final project, i plan to use a arm micro processor (beaglebone or PI or cubieboard)
21:31:31 <Sonarpulse> but if you really want fine tuning you could be working against it more than with it
21:31:36 <Sonarpulse> have you heard of ATS?
21:31:42 <AsgardBSD> ?
21:31:48 <Sonarpulse> you might like that for all sorts of embeded systems
21:31:54 <Sonarpulse> basically C + dependant types
21:32:07 <Sonarpulse> "safe as haskell, fast as C", but you gotta do a lot of work
21:32:27 <Sonarpulse> also, the tools are older and AFIAK not actively developed
21:33:00 <Sonarpulse> but if you want to go super hardcore with any programming project, ATS an interesting option
21:34:59 <yrlnry> How can I ask GHCi if Maybe is an instance of MonadPlus, or what the known instances of MonadPlus are, or what classes Maybe is known to be an instance of?
21:35:19 <shachaf> The answer is :i to the latter two questions.
21:35:30 <shachaf> :i is also the best you can do for the first one.
21:35:57 <AsgardBSD> tomorrow, i will play with haskell
21:36:03 <AsgardBSD> my final project is in 2 year
21:36:04 <yrlnry> thanks
21:36:24 <AsgardBSD> so have to get familiar with haskell if i want ot have some of it in my project
21:36:37 <Sonarpulse> yeah haskell is really educational, the community as much as the language almost
21:37:21 <Sonarpulse> who knows if you will end up doing embedded or something higher-level in the long run
21:37:32 <Sonarpulse> so definitely worth learning
21:37:48 <AsgardBSD> im still unsure if i will go in CE or CS (or both)
21:38:11 <AsgardBSD> I love to have control of my computer, knowing how it work... doing OS, Driver, firmware and kernel
21:38:17 <AsgardBSD> But i also like the theory
21:38:34 <AsgardBSD> Like algorithm, data structure, special thing, other paradigm...
21:39:07 <AsgardBSD> algoirthm : not just the result, but also love it mathematicelly, like finding execution time and other thing
21:39:15 <Sonarpulse> people that know systems and the math, it's rare!
21:39:17 <Sonarpulse> embrace it!
21:39:29 <Sonarpulse> I personally want to make an operating system in haskell
21:39:35 <AsgardBSD> already done
21:39:37 <Sonarpulse> or more realistically resurrect House
21:39:42 <AsgardBSD> we shall inspire from it
21:39:56 <Sonarpulse> I've been on linux for a while now
21:39:59 <Sonarpulse> but I am sick of unix
21:40:10 <AsgardBSD> But i think im more CE than CS
21:40:15 <Sonarpulse> everything is text ==> every program is a shitty parser
21:40:25 <Sonarpulse> I like both
21:40:32 <AsgardBSD> like 60% of me want CE and 40% want CS
21:40:39 <Sonarpulse> but yeah, rather do embed than webapps
21:41:19 <Sonarpulse> or whatever is the latest big destination of CS students
21:41:20 <AsgardBSD> CS != webapps
21:41:26 <Sonarpulse> for sure
21:41:40 <AsgardBSD> CS even has its place in robotics... AI
21:41:48 <Sonarpulse> yeah
21:41:50 <Sonarpulse> I am just saying
21:42:07 <Sonarpulse> while I have no special affinity for small/light/weak computers
21:42:16 <Sonarpulse> i understand the drive to work on something... fundamental
21:43:07 <AsgardBSD> i love *nix
21:43:28 <Sonarpulse> I like it better than windows
21:43:57 <Sonarpulse> but its just old and unsafe IMO
21:43:59 <Sonarpulse> C is crusty
21:44:06 <AsgardBSD> I also want that my work will be useful for the society
21:44:17 <AsgardBSD> So i dont want to make video game...
21:44:26 <Sonarpulse> My dream would be to replace *nix,
21:44:33 <Sonarpulse> with a haskell os
21:44:38 <Sonarpulse> but actually see the thing used
21:44:48 <Sonarpulse> and nix, and C, and the whole lot out the door
21:45:08 <Sonarpulse> video games, I sort of like that its software normal people directly interact with
21:45:22 <Sonarpulse> like if you are doing some back end server at large data-miner
21:45:34 <AsgardBSD> By making OS, driver, kernel, peacemaker, "other embeded system"...
21:45:43 <AsgardBSD> i feel i do my part for the society
21:45:46 <Sonarpulse> you are neither helping the world nor doing something the ever person will be in touch with
21:46:07 <Sonarpulse> *average person
21:46:20 <AsgardBSD> yep, doing thing for large server also help the society
21:46:31 <Sonarpulse> other types of large server yes
21:46:33 <AsgardBSD> since everyone use those server will benefice it
21:46:57 <Sonarpulse> I mean like lets say making in-house software for some large company
21:47:23 <AsgardBSD> making simulator for nasa...
21:47:29 <Sonarpulse> better
21:48:00 <Sonarpulse> making an OS + language ("languaged based system") that is both efficient and powerful
21:48:19 <Sonarpulse> a lot of software is now big monolithic applications
21:48:26 <Sonarpulse> I rather see lots of librarie
21:48:47 <Sonarpulse> and the end user, even novice programmer, can solve their problems just like banging things into ghci
21:48:54 <Sonarpulse> a lot of people say haskell is so good
21:49:19 <Sonarpulse> the easiest way to do something is often the "Right Way"
21:49:30 <Sonarpulse> vs like python where its easiest to just right absolute crap
21:50:57 <dmwit> ?src mplus Maybe
21:50:57 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
21:51:00 <dmwit> ?src Maybe mplus
21:51:00 <lambdabot> Nothing `mplus` ys = ys
21:51:00 <lambdabot> xs      `mplus` ys = xs
21:51:01 <Sonarpulse> but yeah, and OS like that that just makes scripting a joy, and lets anybody learn to program much quicker, as opposed to rely on this software or that website
21:51:08 <dmwit> yrlnry: This way, too. =)
21:51:10 <Sonarpulse> that I see as the best "gift to society"
21:51:22 <dmwit> yrlnry: (But it's not reliable for other instantiations of Maybe and MonadPlus.)
21:52:01 <shachaf> That is a terribly unreliable way.
21:53:15 <dmwit> Yes. Presumably one wants to know more than just "is it an instance", though; namely, "how is it an instance".
21:53:23 <dmwit> And for that ghci won't help.
21:53:51 <shachaf> Well, just "is it an instance?" is quite useful information all on its own.
21:54:00 <shachaf> But ghci will certainly help with the rest, because it'll tell you where the instance is defined.
21:54:06 <shachaf> Then you can read the code yourself.
21:59:20 * hackagebot watcher 0.0.3.0 - Opinionated filesystem watcher  http://hackage.haskell.org/package/watcher-0.0.3.0 (NateSoares)
22:00:15 <AsgardBSD> have to go sleep
22:04:34 <bakibour> Moin
22:05:43 <bakibour> When i have two parallel folders with modules in Haskell is there any way to import one module into the other, and if not what would be the proper setup? In my special case i have a Parser module and one Generator, the Generator depends on the Parser
22:17:40 <dmwit> bakibour: I'm not sure I understood. What goes wrong when you put "import Parser" in the Generator module?
22:18:01 <Sonarpulse> for opaque types (ie C type where you have no idea how its implemented, just pass it around to functions in library), do I need a Storable instance for FFI
22:18:11 <bakibour> dmwit: When i compile the Main.hs it works, i have two subfolders
22:18:12 <Sonarpulse> or is "data mystery" sufficient
22:18:20 <dmwit> Sonarpulse: You shouldn't need one, no.
22:18:26 <Sonarpulse> ok, great
22:18:45 <bakibour> And i want to include one file from one folder in the other folder, i read that you can do that with -i but it works when i compile the Main.hs
22:19:41 <dmwit> I'm having a really tough time following the question. Could you maybe make an hpaste with enough information to recreate your file system here, and a command that doesn't work that you wish would work?
22:19:54 <dmwit> Or some other precise description of the problem that we can reproduce ourselves locally?
22:20:40 <dmwit> e.g. "put this text in file foo/Bar.hs; put this text in baz/Quux.hs; run this command"
22:20:51 <bakibour> I have a folder Program/ and two subfolders Program/Parser and Program/Generator
22:21:06 <bakibour> with the Files Enum.hs in Parser and CPP.hs in Generator
22:21:28 <bakibour> Generator.CPP is supposed to generate an Enum parsed and thus needs a type from Enum.hs
22:22:04 <bakibour> Now i use Sublime as an editor which tries to compile the file when i save but it fails since it can not out of the box find the file.
22:22:19 <bakibour> I guess it does so by descending from the current file location.
22:22:41 <bakibour> Thus searching in Program/Generator/Parser/Enum.hs
22:23:08 <bakibour> But it should consider searching in folders from the parent directory Program/
22:23:13 <dmwit> Is this a question about Sublime Text or about GHC? If it's about Sublime Text, I certainly can't help you.
22:23:21 <bakibour> When i now compile Main.hs in Program/ it works though
22:23:46 <bakibour> I thought it was a GHC problem at first but i think its just an inconveiniance with Sublime
22:24:01 <bakibour> Since i have no way to tell it to search for other folders like in the -i option
22:24:08 <bakibour> To provide different paths
22:24:12 <dmwit> If it's about GHC, then you'll need to say exactly what's in the two files (specifically: what is the "module" line and what is the "import" line?).
22:27:46 <bakibour> dmwit: I think its a problem of the editor not GHC, thanks for listening anyway though. :)
22:31:59 <Ghoul_> is do { x <- something; something3 $ something2 x } any different from let something' = something >>= something2 in something3 something
22:32:16 <Ghoul_> the last something should be something'
22:35:08 <arkeet> @undo do { x <- something; something3 $ something2 x }
22:35:09 <lambdabot> something >>= \ x -> something3 $ something2 x
22:35:54 <arkeet> anyway, yes.
22:35:54 <arkeet> the types wouldn't even work.
22:38:57 <startling> Ghoul_, (something <* something2) >>= something3
22:39:06 <startling> (<*) is from Control.Applicative
22:39:33 <Ghoul_> ah, so I'm actually repeating my something >>=
22:39:37 <Ghoul_> which is probably bad for performance
22:39:48 <startling> Ghoul_: not at all
22:39:52 <dmwit> :t (<*)
22:39:54 <lambdabot> Applicative f => f a -> f b -> f a
22:40:02 <startling> Ghoul_: the problem is that your types don't work
22:40:07 <dmwit> startling: I don't really think that's right...?
22:40:18 <startling> dmwit: oh, I misread
22:40:42 <startling> something >>= something3 . something2 is what you want
22:40:51 <dmwit> (...maybe)
22:40:54 <Ghoul_> the actual code in question is here: http://puu.sh/3jRUB/8ca55874ac.png :) so I take it no performance hit?
22:41:13 <shachaf> What you want is shorter identifiers. Or, at least, identifiers that are different from each other.
22:41:17 <Ghoul_> the alternative was ch <- lift $ use .... then liftIO . atomically . tryReadTChan ch
22:41:22 <startling> Ghoul_, you're missing the point
22:41:24 <dmwit> You took a screenshot of code?
22:41:31 <startling> haha
22:41:38 <Ghoul_> uh, pun?
22:42:01 <Fuuzetsu> > [1] <> [2]
22:42:03 <lambdabot>   [1,2]
22:42:38 <shachaf> dmwit: It's a tradition.
22:42:48 <dmwit> ?check \xs ys -> xs <> ys == xs ++ ys
22:42:52 <lambdabot>   mueval-core: Time limit exceeded
22:43:13 <dmwit> ?check \xs ys -> xs <> ys == xs ++ (ys :: [Int])
22:43:17 <lambdabot>   mueval-core: Time limit exceeded
22:43:20 <dmwit> bah
22:43:35 <shachaf> λ> QC.quickCheck $ \xs ys -> xs <> ys == ys ++ xs
22:43:35 <shachaf> +++ OK, passed 100 tests.
22:43:37 <Fuuzetsu> mueval says no
22:45:19 <dmwit> I trust mueval over shachaf. shachaf isn't even a bot
22:48:08 <shachaf> dmwit: I certainly am!
22:49:33 <Aetherspawn> aww hayoo is down. Is there a maybe for monad actions?
22:49:56 <Fuuzetsu> What do you mean by that?
22:50:26 <Fuuzetsu> You could try https://www.fpcomplete.com/hoogle?q=
22:50:32 <dmwit> If you mean what I think you mean, the answer is no.
22:50:44 <startling> Aetherspawn: I use ">>= maybe (return ()) x" often
22:50:52 <dmwit> However, you might like
22:50:55 <dmwit> :t (<|>)
22:50:57 <lambdabot> Alternative f => f a -> f a -> f a
22:51:08 <startling> or ">>= maybe empty x"
22:51:23 <dmwit> startling: You may like the MaybeT transformer.
22:51:36 <Aetherspawn> I'll try startling's one
22:52:08 <startling> dmwit: eh
22:52:13 <Fuuzetsu> I'm sick of looking at <|>
22:53:21 <startling> (<!>) = (<|>)
22:53:24 <startling> problem solved
22:53:40 <Fuuzetsu> Ha!
22:55:29 <Fuuzetsu> I'm meant to write a 100% compatible parser with the Haddock's current one… Replicating all this weird behaviour is taking its toll and writing additional tests to ensure this is more of a ‘I bet this is a bug’ than anything ;;
23:18:38 <danbst> Hello. Is it possible to pattern match against several constructors with different number of type parameters?
23:21:03 <Heffalump> danbst: can you give an example of what you mean?
23:21:13 <enthropy> danbst: as in you want a pattern that might match    C1 x _ _ y  or  C2 _ x y _ ?
23:22:32 <danbst> http://hpaste.org/90171
23:22:51 <danbst> I have some complex type, and not so complex function
23:23:45 <danbst> I'd like to pattern match there for all constructors, that have last parameter Int32 or Int8
23:24:08 <Fuuzetsu> You can't I believe.
23:24:19 <danbst> that is, to make this function a three-liner
23:24:34 <hpaste> enthropy annotated “Registers4” with “Registers4 (annotation)” at http://hpaste.org/90171#a90172
23:24:54 <enthropy> that's one way to make it slightly nicer
23:25:23 <shachaf> Or slightly less nice, dependning on your taste...
23:25:42 <shachaf> danbst: There is a way to do it with lens and TH but it's kind of complicated.
23:25:55 <enthropy> if you add to the end of the data:      deriving (Data)
23:26:12 <shachaf> You would use record syntax -- i.e. data Foo = Foo { ..., disp :: Int32 } | Bar { ..., dist :: Int32 } | SomethingElse
23:26:16 <enthropy> shachaf: what has lens got to do with that?
23:26:21 <shachaf> And then you'd use makeLenses.
23:26:54 <shachaf> And then preview disp :: Foo -> Maybe Int32
23:27:04 <shachaf> (By the way, "Address" has two 'd's.)
23:27:26 <shachaf> You have to use something like makeLenses, unfortunately -- GHC generates a partial function for disp.
23:28:15 <enthropy> something (mkQ Nothing (\x -> Just (x::Int))) :: Data a => a -> Maybe Int -- if you have the Data instance
23:28:38 <enthropy> might work if those other parameters are not Int32
23:29:03 <shachaf> Going by type is pretty ugly, and using Data is kind of inefficient. :-(
23:30:27 <danbst> hm. I thought there is some way to tag constructor declarations, so you can pattern match then on that tags... pity...
23:31:03 <enthropy> the normal record syntax can kind of do that for you
23:31:08 * enthropy makes another annotation
23:32:17 <bakibour> Is there anything like <*> that applies every function on the left list to just the element on the right list when its matches the index?
23:32:34 <mauke> zipWith id
23:32:36 <startling> :t zipWith id
23:32:37 <lambdabot> [b -> c] -> [b] -> [c]
23:32:44 <bakibour> Ah thanks :)
23:33:17 <startling> wow, usually people get all outraged and insist that that's not what they want
23:33:22 <startling> good job bakibour
23:33:25 <Fuuzetsu> :t map
23:33:26 <lambdabot> (a -> b) -> [a] -> [b]
23:33:42 <bakibour> Heh no why should i ?
23:33:58 <Fuuzetsu> :t [id] <*> undefined
23:33:59 <lambdabot> [b]
23:34:43 <startling> > [(+ 1), (+ 2)] <*> [0]
23:34:44 <lambdabot>   [1,2]
23:35:15 <arkeet> startling: why do they?
23:35:15 <arkeet> or would
23:35:46 <startling> because it's not obvious that "id" does that.
23:36:00 <arkeet> ??
23:36:25 <bakibour> <*> is like the outer product what i was searching for is the inner product so zipWith id did the right job, thanks again
23:36:37 <arkeet> ???
23:36:45 <enthropy> danbst: http://hpaste.org/90173 is pretty bad
23:37:23 <arkeet> that's an awful use of teaspoon
23:37:25 <shachaf> enthropy: Ew.
23:37:31 <startling> I guess the outrage is more common with "flip id"
23:37:47 <shachaf> I don't like TH, but I'd much rather use it here than these other things.
23:38:09 <arkeet> I'd rather use prisms
23:38:13 <startling> http://www.ikea.com/us/en/catalog/products/40091767/
23:38:34 <arkeet> lol
23:38:42 <shachaf> arkeet: Not just affine traversals?
23:38:55 <arkeet> well, something
23:39:54 <startling> oh, it's actually Control.Spoon. no wonder I couldn't findit.
23:40:20 <enthropy> sorry about that
23:40:50 <danbst> enthropy, well, good. But in this case it will be better to wait for `normal record syntax` )
23:41:19 <enthropy> danbst: how do you mean wait for it?
23:42:07 * danbst assumes that in GHC 9 there will be some kind of row polymorphism
23:42:14 <enthropy> to my knowledge you can't write       case x of  anyConstructorWithTheRightField { disp32 = y } -> y
23:43:18 <shachaf> Indeed.
23:43:22 <shachaf> But with makeLenses you can.
23:46:40 <startling> In this case it'll be better to wait for lenses in base?
23:47:01 <startling> Syntax-level lenses, rather
23:47:25 <arkeet> why wait? you can start working on that right now!
23:47:27 <shachaf> You'll have to wait a long time. I'm not sure what the thing you're thinking of would be like.
23:47:39 <startling> Haskell 2030
23:47:41 <shachaf> See, why can't I be an optimist like arkeet?
23:47:53 <arkeet> shachaf: you're usually the optimist.
23:50:34 <Aetherspawn> is there something which is equivalent to return ();
23:50:41 <hpaste> “Anonymous Coward” pasted “RoboTeddy” at http://hpaste.org/90174
23:50:54 <RoboTeddy> Is there anything in the standard library that does that ^ ?
23:51:54 <shachaf> I hope not. That function is partial.
23:52:21 <RoboTeddy> partial in that it'll fail if the list doesn't have an even number of elements?
23:52:32 <shachaf> Yep.
23:52:46 <shachaf> "fail" in that it'll crash your entire program.
23:52:55 <RoboTeddy> does "partial" in this context mean that it only partially covers the domain of possible inputs given the types?
23:53:08 <shachaf> Yep.
23:53:10 <shachaf> https://en.wikipedia.org/wiki/Partial_function
23:53:21 <RoboTeddy> thanks for the link
23:53:48 <dmwit> There is chunk :: Int -> [a] -> [[a]] in the "split" package.
23:53:54 <arkeet> chunksOf.
23:54:10 <shachaf> thanks, chunks. thunks.
23:54:13 <arkeet> hmm
23:54:16 <RoboTeddy> oh sweet, thanks
23:54:17 <dmwit> chunk exists, too.
23:54:20 <arkeet> shachaf: =(
23:54:23 <arkeet> I smiled.
23:54:40 <shachaf> arkeet: Hmm, is it just that you don't know how to use smileys?
23:54:47 <shachaf> That one indicates the opposite of smiling.
23:54:48 <arkeet> quite possibly.
23:55:31 <shachaf> thoughtpolice: I gave up on building GHC, by the way. My git pull is being messed and everything.
23:57:21 <thoughtpolice> shachaf: D:
23:57:40 <Aetherspawn> @pl (return ())
23:57:40 <lambdabot> return ()
23:58:02 <thoughtpolice> i should probably finish getting clang working on that note
23:58:05 <Aetherspawn> :t void
23:58:06 <lambdabot> Functor f => f a -> f ()
23:59:04 * shachaf considers mentioning the lambdabot's /msg abilities.
