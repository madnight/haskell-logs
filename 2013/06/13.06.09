00:00:02 <TravisD> :D
00:00:04 <Nisstyre> lol
00:01:29 <johnw> TravisD: I prefer the "type safety" of newtype, unless it's not gaining me anything at all
00:01:32 <TravisD> That automatically derives instances of any type class you want? (As long as the original type was an instance)
00:02:02 <johnw> no
00:02:12 <johnw> the newtype is its own type, it needs its own instances
00:02:22 <johnw> hence, the name "newtype" :)
00:03:29 <TravisD> johnw: I was referring to the GeneralizedNewtypeDeriving extension :)
00:03:37 <johnw> type synonyms just save you some typing (no pun intended), and they obscure from the reader the fact that the type they're seeing isn't a type at all but just a name for another type
00:04:59 <TravisD> but that's a nice description
00:05:53 <johnw> GeneralizedNewtypeDeriving lets you bring in the base type's instances pretty easily, yes
00:06:15 <johnw> newtype Foo a = Foo (Blah a) deriving Monad
00:08:16 <zRecursive> johnw: it seems useless since Foo should has its own Monad implementation
00:08:49 <zRecursive> i mean the "deriving"
00:08:53 <johnw> sometimes it's implementation would be entirely in terms of Blah's implementation
00:08:59 <johnw> in which case, deriving Monad saves you time
00:09:45 <johnw> there's a fairly common pattern for derived types like this of instance Class Foo where method (Foo a) = method a.  GeneralizedNewtypeDeriving lets you get away with just deriving Class.
00:10:33 <shachaf> There's a fairly common pattern where you just insert unsafeCoerce into your code until it typechecks.
00:10:37 <johnw> lol
00:10:39 <shachaf> GeneralizedNewtypeDeriving can help with that too.
00:10:49 <dolio> Also where clauses.
00:10:55 <johnw> yes, we are yet discussing the *merits* of various patterns :)
00:10:59 <johnw> s/are/aren't
00:11:03 <zRecursive> then why do we need Foo ? we just need to use Blah ...
00:11:13 <johnw> Foo might have *other* instances of its own
00:11:22 <shachaf> Why do we need types? We can just use Int.
00:11:41 <zRecursive> *other* instances, that is ok
00:11:45 <dolio> Because Blah might be StateT s (ContT r (ReaderT e (Writer w)))
00:13:05 <johnw> dolio: I have yet to ever use a transformer stack that didn't end in IO :)
00:13:19 <zRecursive> @unmtl StateT s (ContT r (ReaderT e (Writer w)))
00:13:19 <lambdabot> Plugin `unmtl' failed with: `StateT s (ContT r (ReaderT e (Writer w)))' is not applied to enough arguments, giving `/\A. s -> (A -> s -> e -> (r, w)) -> e -> (r, w)'
00:13:24 <dolio> Sometimes they end in ST.
00:13:32 <johnw> I haven't used ST yet
00:13:35 <dolio> Oh.
00:13:38 <shachaf> Sometimes they end in Identity.
00:13:46 <shachaf> Popular monad, that one.
00:14:02 <johnw> Identity is somewhat magical
00:14:09 <johnw> it seems like it would be so useless, and yet is so useful...
00:15:25 <dolio> Same thing happens with the identity function.
00:15:40 <dolio> The lens people like it so much they have like 30 names for it.
00:16:22 <shachaf> dolio: You're, like, totally one of the lens people, man.
00:16:59 <dolio> I don't know.
00:17:11 <dolio> It took me a while today to figure out that ^~ wasn't assignment.
00:17:44 <shachaf> ^~ is kind of an annoying operator.
00:18:09 <dolio> When my indent suggester was suggesting 9^7 spaces.
00:19:00 <shachaf> Well, just don't use an indent suggester. You gotta show your editor who's boss.
00:19:02 <johnw> is there a package with a Diff Monoid, for turning any monoid into a difference monoid?
00:19:19 <shachaf> There is base.
00:19:34 <shachaf> In particular Endo in Data.Monoid has the right instance.
00:19:52 <shachaf> Admittedly it doesn't have a "smart constructor" to guarantee that all your Endo values are valid.
00:21:19 <shachaf> > (("a" <>) <> ("b" <>) <> ("c" <>)) "" -- Isn't it great how misleading this is?
00:21:21 <lambdabot>   "abc"
00:21:25 <dolio> I see we haven't nipped the "difference list" thing in the bud yet?
00:21:51 <shachaf> ?
00:22:11 <johnw> > (appEndo $ mconcat [Endo ("foo" <>), Endo ("bar" <>)]) mempty
00:22:12 <lambdabot>   "foobar"
00:22:13 <johnw> I see
00:22:27 <johnw> I suppose I would want a more type-safe on than that, but I see that it could be implemented in terms of Endo
00:23:31 <shachaf> > foldr (.) id [("foo" <>), ("bar" <>)] ""
00:23:32 <lambdabot>   "foobar"
00:23:32 <zRecursive> how to translate Endo into Chinese ?
00:23:44 <shachaf> > foldr ($) mempty [("foo" <>), ("bar" <>)]
00:23:46 <lambdabot>   "foobar"
00:23:53 <shachaf> @ty foldr ($) mempty
00:23:54 <lambdabot> Monoid b => [b -> b] -> b
00:25:38 <zRecursive> @wn endo
00:25:38 <lambdabot> No match for "endo".
00:29:21 <shachaf> Endonote: Figure out what "endo" means.
00:30:17 <johnw> shachaf: http://hpaste.org/89591
00:30:57 <shachaf> Might as well write your own Monoid instance at that point...
00:31:26 <johnw> i had it before, I just adding GND in honor of our earlier discussion :)
00:31:26 <shachaf> Note that you can use this same trick for Category, not just Monoid.
00:31:37 <johnw> oh?
00:31:57 <johnw> and it seems that "this same trick" is just Yoneda in another guise
00:32:29 <shachaf> I don't think this thing should really exist as a package, though.
00:32:35 <johnw> no, I agree
00:32:54 <johnw> It just seemed like something that would already be a footnote in one of edwardk's packages, I thought
00:33:49 <johnw> how does this work with category, though?  the operator there is already composition
00:34:07 <shachaf> What, names for the functions (Endo . (<>)) and ($ mempty) . appEndo?
00:34:14 <johnw> yes
00:34:20 <shachaf> Eh.
00:34:40 <johnw> i mean, the DList package makes it seems like difference lists take some work
00:34:45 <johnw> when in fact they are incredibly trivial
00:34:48 <shachaf> Exercise: Figure out what I mean by you can do it for Category.
00:35:11 <shachaf> DList has a bunch of list-specific helper functions... But it is a slightly dubious package. Oh well.
00:35:37 <johnw> DList "unwraps" your difference list on-demand, and then repackages it as a new difference list composed of that combined list
00:35:40 <johnw> I can see some utility in that
00:35:46 <johnw> why is it dubious?
00:36:10 <shachaf> I don't understand that sentence.
00:38:41 <dolio> shachaf: Basically, difference lists come from Prolog, if I recall correctly, and they are a list with an unground unification variable as a tail, paired together with said variable.
00:39:21 <dolio> Which let you do similar things to embedding a monoid into its transformation monoid, but isn't exactly the same thing.
00:39:27 <shachaf> dolio: Ah, that difference list.
00:39:40 <shachaf> Right, it's not really the same thing.
00:39:45 <shachaf> What would be a good name for this thing?
00:40:02 <johnw> I'd like to find a name for the pattern in general
00:40:27 <dolio> Transformation monoid or semigroup is apparently the technical term.
00:40:34 <dolio> Similar to symmetric group.
00:42:53 <johnw> f g = ψ g (f ε) is how elliot phrased it yesterday; Yoneda fits this pattern, "difference monoids" fit it, shachaf states that Category can be fit into it too.  I wonder if Codensity is related also.
00:44:39 <johnw> I guess it's just "distribution"
00:49:08 <dolio> Yoneda might be the most general characterization of it.
00:50:56 <dmj> in Network.Socket is there no call for getpeername()
00:58:05 <shachaf> If you use a "difference category" with Kleisli do you get the same effect as Codensity?
01:02:08 <johnw> that's just what I was wondering last night
01:02:15 <johnw> haven't worked it out yet
01:02:30 <nh2> Data.Vector.modify: "Apply a destructive operation to a vector. The operation will be performed in place if it is safe to do so and will modify a copy of the vector otherwise." <- What does that mean? I can't see a situation where the vector will not be copied.
01:02:52 <nh2> johnw: hi!
01:02:58 <johnw> nh2: hi!
01:04:40 <shachaf> nh2: If it is not used anywhere else, it might be safe.
01:04:45 <shachaf> I imagine they're talking about fusion.
01:05:09 <shachaf> E.g. if you (modify f . modify g) you can only copy once.
01:07:43 <johnw> Codensity really is just Yoneda with Kleisli arrows, so instead of f g = fmap g (f id), you have f g = f return >>= g
01:08:00 <nh2> shachaf: How can I know to what extent that goes? If I do replicateM 1000 (modify [write one element]), then it's copied every time and I get O(n) write access
01:08:08 <nh2> also, doesn't it's code always do the clone?
01:08:48 <nh2> shachaf: I mean http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/src/Data-Vector-Generic.html#modify
01:08:50 <shachaf> nh2: I don't much about vector's fusion. I've never used vector.
01:09:18 <nh2> I wish I knew more about it ...
01:09:25 <shachaf> Did you check for RULES?
01:09:49 <nh2> oh, you are right, I forgot those
01:09:53 <nh2> I will check
01:11:32 <nh2> there is a RULE for clone indeed, "clone (new p) = p". Do you know why the rule is not fired for my replicateM? I don't know much about rules, at what stage are they run?
01:11:50 <darkf> Apparently I have no idea how to use MVectors. I wonder why it can't deduce the type constraint, but I'm not sure how to solve it: http://hpaste.org/89595
01:13:51 <nh2> darkf: what are the actual types?
01:13:59 <shachaf> nh2: I suspect your replicateM won't work easily. But I have no idea.
01:14:19 <darkf> nh2: I would like cells to be an MVector of Int that uses ST
01:15:09 <nh2> darkf: If you type the (10 :: Int) in the write, does that fix the Int?
01:16:03 <nh2> shachaf: I currently suspect it is because rules trigger on what is known at compile time, e.g. (clone . clone . clone), while my replicateM does the cloning at run time (or not at all depending on the n in replicateM)
01:16:26 <darkf> nh2: Yes, but then it throws: "No instance for (GM.MVector v0 Int) arising from a use of `eval'"
01:17:07 <nh2> darkf: ah ok. How do you think it should be able to deduce the monad (ST)? I don't think it has information to do that
01:17:08 <shachaf> nh2: Yep.
01:17:48 <nh2> darkf: You could use "STVector" from http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Mutable.html to type it
01:18:28 <nh2> oh wait will that work? Probably not
01:19:00 <nh2> since it is just a type alias without extra info
01:19:22 <darkf> nope -  Expecting one more argument to `M.STVector Int'
01:19:52 <nh2> yes, it is just STVector s = MVector s, that doesn't help us
01:21:17 <nh2> you might have to write an (forall s. ... ST s ()) like in http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector.html#g:18 on the line with the runST
01:21:24 <johnw> shachaf: http://hpaste.org/89596
01:21:59 <johnw> I'm sure you know these definitions backwards and forwards, but looks how exactly the two parallel each other, with the exception of the kleisli arrow in Codensity
01:22:26 <johnw> so, Codensity is just Yoneda in another category?
01:22:51 <shachaf> http://hackage.haskell.org/packages/archive/kan-extensions/3.1.1/doc/html/Data-Functor-KanExtension.html#t:Ran
01:23:31 <shachaf> Anyway, I was talking about something like: newtype D k a b = D { runD :: forall x. k x a -> k x b }
01:23:46 <shachaf> With the same Category instance as Endo's Monoid instance.
01:24:00 <johnw> ah
01:24:24 <johnw> well, if f g = fmap g (f id), and dx y = mappend y (dx mempty), and here f g = f return >>= g, what you said before makes sense
01:24:27 <shachaf> If you do that you get the reässociating behavior of Codensity with Kleisli, for instance.
01:25:13 <johnw> then Yoneda is Ran where g is identity, and Codensity is Ran where Monad g, h => g ~ h
01:25:44 <johnw> and DMonoids are Ran when g and h are both identity?
01:26:06 <shachaf> (forall r. (a -> r) -> r) = a
01:26:09 <nh2> darkf: oh, m isn't ST, it's the vector type!
01:26:15 <johnw> ah, right
01:26:58 <johnw> where a is a -> a and g and h are identity?
01:27:03 <darkf> nh2: Heh, Haskell breaks my mind
01:27:22 <Aetherspawn> :t permute
01:27:24 <lambdabot> Not in scope: `permute'
01:28:36 <c_wraith> :t permutations
01:28:37 <lambdabot> [a] -> [[a]]
01:29:26 <c_wraith> > map (take 3) $ permutations [1..]
01:29:27 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2],[4,3,2],[3,4,2],[3,2,4],[4...
01:30:39 <darkf> nh2: Is there an easier way to get a mutable array to pass around?
01:31:02 <nh2> darkf: one moment, I'm figuring around with it
01:31:14 <nh2> (by the way, I came here with exactly the same question :D)
01:31:18 <Aetherspawn> > take 2 $ map (+) $ permutations [1..3]
01:31:19 <lambdabot>   No instance for (GHC.Num.Num [a0])
01:31:20 <lambdabot>    arising from a use of `e_1213'
01:31:20 <lambdabot>  Possi...
01:31:35 <Aetherspawn> > take 2 $ permutations [1..3]
01:31:36 <lambdabot>   [[1,2,3],[2,1,3]]
01:31:56 <Aetherspawn> > map (+) $ permutations [1,2]
01:31:58 <lambdabot>   No instance for (GHC.Num.Num [a0])
01:31:58 <lambdabot>    arising from a use of `e_112'
01:31:58 <lambdabot>  Possib...
01:32:01 <Aetherspawn> coolstuff :|
01:32:44 <darkf> nh2: Heh, nice, we should really have better docs for this
01:34:17 <johnw> how is regex-applicative different from just using parsec?
01:34:21 <johnw> https://github.com/feuerbach/regex-applicative/wiki/Examples
01:34:30 <johnw> from the examples, they look like they're solving the same thing
01:34:33 <johnw> (in the same way)
01:35:42 <nh2> darkf: yes
01:35:51 <nh2> darkf: ah, just try Data.Vector.Mutable instead of the generic one
01:35:54 <nh2> that works for me
01:44:44 <darkf> nh2: huh, so it does. thanks :D
01:44:56 <nh2> darkf: :)
01:45:53 <nh2> the problem was that more things than just "MVector" from Mutable are instance of the MVector (same name) type class
01:46:30 <nh2> and you know you want Mutable.MVector, so you can just use it
01:47:42 <darkf> hm
01:47:58 <Aetherspawn> map sum $ permutations [1,2,3]
01:47:59 <darkf> nh2: do you know if `new` automatically initializes all of the members?
01:48:05 <Aetherspawn> > map sum $ permutations [1,2,3]
01:48:06 <lambdabot>   [6,6,6,6,6,6]
01:48:33 <darkf> I should probably `set` it just in case
01:48:47 <nh2> darkf: you can just use `replicate`
01:49:03 <nh2> that's intialized creation
01:49:06 <darkf> nh2: ah! sweet :)
02:07:16 <darkf> nh2: great, now my evaluator works (although it's incredibly ugly)
02:07:25 <nh2> what does it do?
02:08:33 <darkf> nh2: well, first I take a brainfuck string, then convert it to (Plus | Left | Loop [Instruction] | ...), then condense it into (Modify Int | Move Int | ...), then evaluate that. :D It is pretty silly.
02:09:28 <nh2> ah, brainfuck
02:10:25 <darkf> nh2: yeah, it is basically a horrible and convoluted way to evaluate Brainfuck programs. but the intermediate forms are slightly more readable :p
02:10:41 <darkf> nh2: anywho, thanks for your help!
02:11:01 <nh2> darkf: welcome!
02:22:27 <neutrino> darkf: sounds like fun.
02:22:40 <darkf> neutrino: indeed.
02:22:55 <joelteon> rats
02:22:59 <joelteon> how do I figure out where the cabal executable is?
02:23:11 <joelteon> I just took the generic binary distribution of 7.6.3 and installed it on centos
02:23:19 <earthy> `which cabal` ?
02:23:31 <joelteon> yeah, it's not in my $PATH...or I would've tried that
02:23:31 <earthy> or, locate cabal ?
02:23:45 <Cale> joelteon: It won't be installed
02:23:45 <earthy> (assuming updatedb has already run)
02:23:56 <joelteon> oh
02:24:03 <joelteon> oh, right
02:24:05 <Cale> joelteon: You can grab the tarball from hackage
02:24:07 <joelteon> I have to do the bootstrap thing
02:24:09 <Cale> yeah
02:24:10 <joelteon> ok
02:25:26 <joelteon> ld keeps getting kill9ed
02:25:58 <joelteon> must be triggering memory exhaustion
02:26:07 <Cale> yeah, that's the usual reason
02:30:24 <joelteon> so I guess I *was* using burst RAM on my old VPS after all
02:30:36 <joelteon> is it normal for ld to take 512MB+ to link a haskell library? that seems like a lot
02:38:46 <yitz> joelteon: no i think that's normal
02:39:23 <yitz> joelteon: a year or two ago, when vps's were typically smaller, you would almost never compile directly on a vps
02:39:36 <joelteon> makes sense
02:40:12 <joelteon> still seems like a lot, but then again I have absolutely no idea what linking is
02:40:17 <joelteon> not on a practical level
02:40:36 <yitz> joelteon: now it's not as uncommon anymore to have that much memory on a vps, and if not, it takes minutes to set up a local virtualbox vm with plenty of memory and the exact same platform as your vps
02:40:59 <joelteon> maybe I should try that
02:42:50 <yitz> joelteon: your code compiles to a zillion named asm memory locations and functions. linking wire those into an executable or library that can be loaded into memory.
02:43:00 <yitz> s/wire/wires/
02:43:53 <joelteon> and 1GB is not enough either
02:43:58 <joelteon> guess I'll need to set up a virtualbox
02:45:21 <yitz> joelteon: that a lot. but not inconceivable. what are you compiling?
02:45:29 <yitz> *that's
02:45:36 <joelteon> running cabal-install's bootstrap.sh
02:45:47 <joelteon> whatever the first dependency is, Distribution . something
02:45:50 <joelteon> might just be cabal-install
02:45:56 <yitz> oh really? hmm.
02:46:55 <yitz> so maybe try just using the ghc binary tarball on your vm? that comes with a ready-made usable cabal.
02:47:28 <yitz> this is a linux vps right?
02:49:14 <joelteon> yeah
02:49:19 <joelteon> but I'll need to compile other stuff
02:49:30 <joelteon> and the end result is just gonna be a few binaries
02:49:42 <joelteon> so I might as well compile them locally and upload them
02:49:48 <Aetherspawn> if i have (MonadIO m) => Thing m a -> Thing m b
02:49:53 <Aetherspawn> can m be different in each Thing?
02:49:58 <Aetherspawn> or must it be the same type of monad
02:50:00 <yitz> but yeah, even if that works, if you don't have a local machine whose platform is close to the one on your vps, it's probably still worth it to have a matching virtualbox vm. it will come in handy.
02:50:10 <johnw> how could it be different?  m is m in that type
02:50:15 <joelteon> i could get a netbook build slave
02:50:18 <Aetherspawn> Ah, so I'd have to do m1, m2
02:50:25 <johnw> You'd need (MonadIO m, MonadIO n) => Thing m a -> Thing n b
02:52:14 <Aetherspawn> > 2^200 - 2^201
02:52:15 <lambdabot>   -1606938044258990275541962092341162602522202993782792835301376
02:52:35 <FreeFull> > -2^200
02:52:37 <lambdabot>   -1606938044258990275541962092341162602522202993782792835301376
03:11:40 <Sizur> Does haskell have immutable maps and vecs like clojure?
03:11:54 <johnw> Data.Map and Data.Vector
03:12:18 <yitz> Sizur: yes those are the default
03:12:41 <Sizur> was implementation of data.map changed somet ime ago? several years ago map was not immutable
03:12:58 <yitz> Sizur: in haskell it has always been immutable
03:13:21 <shachaf> Perhaps you are thinking of Data.HashTable or one of those things.
03:13:33 <Sizur> so i can use it freely in concurrent code?
03:13:35 <shachaf> (If so, don't. It won't do you any good.)
03:15:35 <yitz> Sizur: just about anything the types let you do in concurrent code should be ok. most haskell data structures are fine.
03:16:45 <Sizur> should i care if a map is hash or tree in practice? given our current mem limits seems to me like logn ~= n
03:17:52 <shachaf> You should probably care. But a hash table is certainly not better than a tree.
03:18:05 <Sizur> umm, why should i care?
03:18:32 <shachaf> Well, if you care enough to ask if you should care, you should probably care.
03:18:59 <Sizur> :/ circular
03:19:26 <shachaf> OK.
03:19:42 <Sizur> and why you say hash is not better than tree? i though a good hash impl should in theory be faster
03:20:12 <shachaf> OK.
03:20:27 <Sizur> just trying to understand
03:20:31 <lillian_baxter> http://pastebin.com/X4kLwJ11 -- when I use this through prelude, "doubleSmallNumber 100" returns 200! Why?
03:20:33 <aristid> Sizur: all the standard haskell data structures are immutable. hash tables are slow in an immutable setting.
03:20:40 <mauke> The paste X4kLwJ11 has been copied to http://hpaste.org/89603
03:20:51 <aristid> you can use hash tables in a mutable way in haskell, but few people desire doing that.
03:21:16 <Sizur> aristid: thanks. so haskell locks a hash in "immutable setting" when it needs to?
03:21:17 <shachaf> lillian_baxter: Because 100 is not > 100
03:21:31 <lillian_baxter> shachaf: oh I'm retarded I read that backward wow
03:21:43 <lillian_baxter> schachaf: sorry for wasting your time
03:21:47 <nooodl> well it's not < 100 either!
03:21:52 <aristid> Sizur: if you use a hash table. almost nobody uses hash tables. if you want an hash-based container, we got other data structures for that.
03:23:12 <Sizur> aristid: i dont care what's the implementation of map. i know that clojure's map has good performance guarantees even in concurrent setting and i wonder if we have that too
03:23:38 <aristid> Sizur: Data.Map should be reasonably fast in many cases
03:23:51 <aristid> there are other containers too, however
03:23:59 <Sizur> is it in any way slower if you use concurrency that if you dont?
03:24:09 <Sizur> than*
03:24:10 <aristid> i don't think it would make a difference
03:24:22 <aristid> other than the overhead you get from using a threaded runtime anyways
03:24:25 <Sizur> great :) that answers
03:24:42 <aristid> well i can't say for sure
03:24:52 <shachaf> No one can. The questions are too vague to answer for sure.
03:25:30 <aristid> shachaf: communication between humans sadly tends to be ambiguous. we should use agda to talk to each other.
03:26:22 <Sizur> shachaf: if i modify in one thread and read in another at the same time (really same time as in 2 cores), how is inconsistent state avoided?
03:26:46 <shachaf> What does "modify" mean?
03:27:13 <aristid> Sizur: remember that haskell data structures are usually immutable. "modify" is impossible.
03:28:32 <Sizur> that's a nice theory. was just wondering if the reading state in reality has the snapshot of the structure before the value changed
03:28:36 <Sizur> so that means it does
03:29:19 <shachaf> What?
03:29:21 <aristid> what? theory?
03:29:24 <aristid> that's how it is
03:29:40 <shachaf> "the value changed"?
03:29:52 <shachaf> I'm not sure what you're getting at.
03:30:40 <Sizur> processors and memory are not math. was just trying to confirm that we have a purely functional map :) did not remember since looked at haskell like 4 years ago
03:31:11 <aristid> Sizur: how often do we have to repeat it: Data.Map.Map is immutable (unless you use dangerous unsafe* functions, but just don't do that)
03:31:19 <shachaf> I still don't know what it means to change a value.
03:32:01 <Sizur> sorry, let me correct myself, instead of "value changes" i meant  "the state of the machine changed to contain a different value"
03:32:13 <Aetherspawn> @pl (\x -> liftIO . atomically $ writeTChan ch x)
03:32:13 <lambdabot> liftIO . atomically . writeTChan ch
03:32:27 <aristid> Sizur: how would that happen?
03:32:36 <aristid> why would it change?
03:32:43 <shachaf> I still don't really understand what you're after...
03:32:51 <shachaf> As far as I know this is similar to how Clojure works.
03:33:23 <aristid> shachaf: clojure might have some kind of weird backdoor to get mutability back into the "immutable" data structures *wild guess*
03:33:27 <Sizur> i got my answer already
03:33:41 <shachaf> OK.
03:35:24 <Sizur> the misunderstanding as to what i mean by state of the machine (as in computer process) changed, should i pretend that it's not what's happening? thanks to ghc we can think purely, but it still boils down to processor commands
03:36:09 <aristid> Sizur: other things change. but not the internal structure of the existing Data.Map.Map
03:36:25 <aristid> it can be deleted wholesale by the garbage collector.
03:36:27 <shachaf> I think the confusing part was talking values changing.
03:36:32 <neutrino> say i have an api web server. i would like to call the api exposed by server 2 from server 1. would it be feasible to create a monad such that depending on the instance it's either a call over http, or the sources get pulled in and the api call happens within my binary?
03:36:51 <shachaf> I don't know what it means, say, for the value 1 to change into the value 2.
03:37:20 <Sizur> when a function evaluates to a new map from old (by for example adding and/or deleting a node) how is that represented on the hardware?
03:37:23 <aristid> shachaf: then you can prove anything, going from 1 = 2 \o/
03:37:52 <aristid> Sizur: it generates a new map, reusing bits and pieces of the old map (without changing them)
03:38:35 <c_wraith> the old map is unchanged.  This is important
03:38:42 <Aetherspawn> @pl (\a b -> allocate ?? (\t -> killThread t) (resourceForkIO $ helper a b)
03:38:42 <lambdabot> (line 1, column 72):
03:38:42 <lambdabot> unexpected end of input
03:38:43 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
03:38:47 <Aetherspawn> @pl (\a b -> allocate ?? (\t -> killThread t) (resourceForkIO $ helper a b))
03:38:47 <lambdabot> (((allocate ??) . killThread . resourceForkIO) .) . helper
03:39:11 <Aetherspawn> The hell.
03:39:12 <shachaf> Aetherspawn: You know you can /msg lambdabot, right?
03:39:20 <Aetherspawn> Oh, had no idea
03:39:43 <Aetherspawn> Neat, thanks.
03:39:46 <pozorvlak> hi everyone
03:39:54 <aristid> Aetherspawn: lambdabot is now your personal servant
03:40:09 <Aetherspawn> I couldn't install the darn thing locally
03:40:11 <pozorvlak> I'm trying to profile some code using +RTS -p -RTS
03:40:17 <Sizur> i understand that and that's great. but making it actually work on the hardware is a lot more work than it sounds like in a math paper
03:40:30 <shachaf> OK.
03:40:57 <Sizur> and it's super great that we have that :)
03:41:01 <aristid> if you ignore garbage collection metadata, it isn't necessarily.
03:41:09 <pozorvlak> when I try to compile with ghc -prof, I get told Could not find module `Prelude'
03:41:09 <pozorvlak>     Perhaps you haven't installed the profiling libraries for package `base'?
03:41:32 <pozorvlak> So I do cabal install -p base, and get this error: https://github.com/haskell/cabal/issues/275#issuecomment-6046398
03:41:39 <aristid> i mean i honestly don't know how exactly ghc implements it. maybe it doesn't even need garbage collection metadata.
03:41:41 <c_wraith> It's not really that much work.  Bump the allocation pointer in the appropriately-sized slab.  Write a couple values to it.  Return a pointer to it.
03:41:43 <shachaf> pozorvlak: Don't cabal install base.
03:41:48 <shachaf> How did you install GHC?
03:42:02 <shachaf> (In particular how did you install the non-profiling base?)
03:42:05 <pozorvlak> shachaf, I think it's the version from apt-get
03:42:08 <shachaf> OK.
03:42:11 <aristid> but either way, the Map's actual data in the actual memory never needs to change.
03:42:12 <shachaf> Then install base from apt-get
03:43:05 <c_wraith> debian, for some reason, doesn't package the profiling libs
03:43:09 <c_wraith> with GHC, that is
03:43:13 <c_wraith> it's part of a separate package
03:43:16 <aristid> Sizur: or were you maybe getting at laziness?
03:43:18 <shachaf> Yes, you'll need to install a separate package.
03:43:27 <aristid> Sizur: laziness is indeed implemented using mutation.
03:43:29 <pozorvlak> c_wraith, shachaf, thanks!
03:43:39 <Sizur> nah, my question is fully answered :)
03:44:17 <pozorvlak> I'll add a comment to that GitHub issue once I get this working.
03:44:35 <aristid> Sizur: i'm curious, what is the "answer" you have derived?
03:44:37 <c_wraith> Sizur: you sure? 'cause the way GHC does laziness actually quite complicated, when you look at all the special cases.
03:44:39 <Sizur> next silly questio is about clojure's actor model. can it in any way be better than current haskell's concurrency? par or multiheaded agent stuff
03:44:41 <Sizur> ?
03:45:01 <aristid> why would you assume that we know how clojure's actor model works?
03:46:12 <Sizur> the answer to my map question that i got is that we have a purely functional map with preformance guarantees close to a traditional map
03:46:33 <Sizur> i dont, i hope somebody where does :)
03:46:42 <Sizur> here*
03:51:34 <Aetherspawn> I can't get lambdabot to respond to :t's
03:51:38 <Aetherspawn> :t forever
03:51:39 <lambdabot> Monad m => m a -> m b
03:51:40 <Sizur> i am interested in diving into clojure, but if there's nothing in clojure thats better in any way than what we have in haskell (except the sexp issue and obviously jvm interop) then there would be no reason to learn clojure at all
03:52:24 <shachaf> Aetherspawn: Use @type
03:52:41 <Aetherspawn> Works a charm :)
03:52:51 <shachaf> You may have noticed that's all I ever use, if you've looked.
03:54:26 <aristid> Sizur: well don't let things stop you from learning clojure. it's never a bad thing to know more languages.
03:58:43 <Sizur> well, need to prioritize :) i still have not internalized arrows. arrows of function are simple to understand, but i have no idea for example how to think about arrows of monads
03:58:53 <Sizur> functions*
03:59:14 <aristid> arrows are not the most important concept *shrug*
03:59:31 <monoidal> anyone knows how much does it take to compile the entirety of hackage via hackager?
03:59:39 <pozorvlak> OK, ghc-prof installed and comment added to anyone else who hits that page: https://github.com/haskell/cabal/issues/275#issuecomment-19164348
03:59:42 <pozorvlak> thanks again!
04:00:51 <Sizur> aristid: that's the highest abstraction i know if in coding.  functors, monoids, monads, appricative, etc all seem easy vs arrows to me
04:01:51 <shachaf> Being difficult is not, in fact, an indicator of a good abstraction.
04:02:33 <Sizur> at some level it is to me. just the act of understanding higher abstraction expands my mind and makes me a better coder
04:02:35 <aristid> @quote monoid
04:02:35 <lambdabot> shachaf says: edwardk will try to get you addicted to monoids. The first one is always free.
04:02:50 <aristid> *giggle*
04:02:54 <aristid> @quote free
04:02:54 <lambdabot> monochrom says: Oh I see. If you have been programming pointful all your life (basing yourself on function application), you will understand monads easier, since >>= is glorified function application.
04:02:54 <lambdabot>  If you have been programming pointfree all your life (basing yourself on function composition), you understand arrows easier, since >>> is glorified composition.
04:03:47 <Sizur> yeah, but what does it mean to have an arrow of monad?
04:03:49 <Sizur> :)
04:03:50 <shachaf> Sizur: Well, you're wrong. Sorry. :-(
04:04:03 <aristid> Sizur: most real arrows are just monads in disguise. some aren't, but for those arrows are still a rather clumsy abstraction. arrows are convoluted, not highly abstract.</typical arrows diss>
04:04:18 <shachaf> >>> belongs to Category, not Arrow
04:04:24 <shachaf> Category is a good abstraction.
04:05:10 <Sizur> shachaf: based on empirical evidense of statistics of one (me), i came to haskell from perl and learning haskell absolutely made me a better coder in general. learning haskell was a bigger stretch than getting to oo from noob
04:06:07 <aristid> which doesn't imply that arrows are a good abstraction in any way.
04:06:08 <shachaf> OK. So Haskell was difficult and good.
04:06:28 <shachaf> Let's say, Monad was difficult and good.
04:06:34 <aristid> Intercal would perhaps be an example of something difficult and bad. :D
04:06:38 <shachaf> Arrow is difficult. Therefore Arrow is good?
04:07:11 <Sizur> aristid: arrows look very much to me like electronic engineering for some reason. makes me intrigued that highest level is resembling lowest
04:07:34 <shachaf> OK, this is not worth the trouble.
04:07:40 <shachaf> I'm going to sleep.
04:07:51 <Sizur> good night and thank you :)
04:08:15 <aristid> Sizur: you can use monads as if they were arrows, if you like that style.
04:08:19 <aristid> :t (>=>)
04:08:20 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
04:08:29 <aristid> :t arr
04:08:31 <lambdabot> Arrow a => (b -> c) -> a b c
04:08:58 <aristid> :t (.) return
04:08:59 <lambdabot> Monad m => (a -> b) -> a -> m b
04:09:30 <aristid> in fact, every monad forms an arrow in precisely this way.
04:10:01 <aristid> the so-called Kleisli arrow. but i fear this may have the unintended effect of making you _more_ interested in arrows :D
04:10:19 <Sizur> that's only if arrows are of functions though, no?
04:10:58 <notdan> I the documentation for base-4.7 somewhere online?
04:11:50 <aristid> Sizur: no, that's arrows of monadic functions.
04:12:03 <mami> heyho
04:12:11 <mami> got a newb problem with the type checker
04:12:20 <aristid> Sizur: arr's type makes sure that EVERY arrow has a function-like character.
04:12:20 <mami> if i try to load this function:
04:12:21 <mami> hash keys = [floor(9*(k*(5/11) `mod'` 1))| k <- keys]
04:12:38 <mami> it tells me to add an instance declaration of RealFrac
04:12:58 <mami> tried out different approaches but couldnt make sense of what i found in the documentation
04:13:18 <mami> do i have to decompose it into different functions and then give the types for all of those?
04:13:38 <johnw> 5/11 yields a Fractional, mod requires an Integral
04:13:42 <supki> @ty \keys -> [floor(9*(k*(5/11) `mod'` 1))| k <- keys]
04:13:43 <lambdabot> (Integral t, RealFrac a) => [a] -> [t]
04:13:51 <aristid> :t mod'
04:13:52 <lambdabot> Real a => a -> a -> a
04:13:57 <aristid> :)
04:14:01 <johnw> oh, didn't see the apostrophe
04:14:05 <supki> @ty floor
04:14:06 <lambdabot> (Integral b, RealFrac a) => a -> b
04:14:15 <aristid> johnw: mod' is a cool function
04:14:19 <aristid> @index mod'
04:14:19 <lambdabot> bzzt
04:14:21 <johnw> how does Real relate to RealFrac?
04:14:25 <aristid> @hoogle mod'
04:14:25 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
04:14:25 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
04:15:39 <Sizur> aristid: trying to grok, so how can (>==>) evaluate to m c when b is totally free?
04:16:04 <Sizur> i mean (>=>)
04:16:18 <aristid> it doesn't evaluate to m c
04:16:22 <aristid> :t (>=>)
04:16:23 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
04:16:29 <aristid> it evaluates to (a -> m c)
04:16:39 <aristid> the equivalent of MArrow a c
04:16:53 <mami> johnw: yeah, seen that
04:17:01 <aristid> or, in fact: Kleisli m a c
04:17:05 <mami> but i dont know how to tell the type checker how to handle that
04:17:38 <Sizur> ok, that's way over my head. i dont get how we can get a -> m c when b is totally free
04:17:40 <johnw> it's not something you need to tell the type-checker; the code as it stands is invalid.  You must fix the code
04:18:07 <aristid> Sizur: there is no free b oO
04:18:25 <yitz> mami: mod' is not the usual way to get the fractional part of a floating point number. is that what you're trying to do?
04:18:29 <aristid> Sizur: you have an (a -> m b) and a (b -> m c). and then you just compose them...
04:18:33 <Sizur> obviously i am on a much lower abstraction level
04:19:02 <mami> yitz: yep
04:19:10 <Sizur> so (m c)  so to speak expects b?
04:19:26 <mami> what should i use instead
04:19:46 <johnw> Sizur: the function b -> m c expects a b
04:20:00 <johnw> m c will be result of that function
04:20:15 <Sizur> i have a function of a and another of b that both give me a box of c, i compose the function to get a function that takes a and gives me box of c
04:20:25 <Sizur> where did b go?
04:20:35 <johnw> ?
04:20:35 <aristid> Sizur: you misread.
04:20:46 <aristid> Sizur: the first function gives you a box of b, not a box of c.
04:20:50 <johnw> you're better off not thinking of it as a box
04:21:11 <Sizur> oh duh! sorry :(
04:21:14 <yitz> @type properFraction
04:21:15 <lambdabot> (Integral b, RealFrac a) => a -> (b, a)
04:21:23 <aristid> > properFraction 4.5
04:21:24 <lambdabot>   (4,0.5)
04:21:29 <Sizur> aristid: thanks, i did misread it
04:21:39 <aristid> Sizur: does it make more sense now?
04:21:43 <mami> yitz: k ill try
04:21:44 <Sizur> yeah
04:21:49 <aristid> cool.
04:22:09 <Sizur> now i need to go back and reread it "not think of it as a box" :)
04:22:26 <johnw> IO a is a "box containing a" as much as the command "ls" is a box containing files
04:23:24 <johnw> (or rather, file names)
04:23:32 <mami> yitz: the typechecker still tells me to add instance declarations like so:
04:23:41 <aristid> but ls IS a box of file names</troll> :D
04:23:54 <mami>     No instance for (RealFrac Int)
04:23:54 <mami>       arising from a use of `floor'
04:23:54 <mami>     Possible fix: add an instance declaration for (RealFrac Int)
04:23:54 <mami>     In the expression: floor (9 * (k * snd (properFraction (5 / 11))))
04:23:54 <mami>     In the expression:
04:23:56 <mami>       [floor (9 * (k * snd (properFraction (5 / 11)))) | k <- keys]
04:23:59 <mami>     In an equation for `hash':
04:24:01 <aristid> :t floor
04:24:02 <mami>         hash keys
04:24:03 <lambdabot> (Integral b, RealFrac a) => a -> b
04:24:04 <mami>           = [floor (9 * (k * snd (properFraction (5 / 11)))) | k <- keys]
04:24:14 <mami> i thought i only have to tell the type checker what goes in and what goes out
04:24:15 <aristid> :t round
04:24:16 <lambdabot> (Integral b, RealFrac a) => a -> b
04:24:21 <mami> not what happens in between
04:24:25 <shachaf> mami: Please don't paste more than a couple of lines in the channel.
04:24:28 <Sizur> the way i see it, our brain needs a few concretes to construct an abstraction
04:24:42 <aristid> mami: the result of your function should be a list of floating point values?
04:24:43 <mami> shachaf: ok, sorry
04:24:56 <mami> aristid: it should be a list of ints
04:25:03 <mami> thats why im using floor
04:25:20 <mami> hash keys = [floor(9*(k*snd(properFraction(5/11))))| k <- keys]
04:25:41 <aristid> :t snd (properFraction (5/11))
04:25:42 <lambdabot> RealFrac b => b
04:25:51 <shachaf> "box" is just a lie, though. It's concrete, but it's the wrong thing.
04:25:53 <shachaf> It only confuses people -- and sometimes it confuses them for months or years. They think they understand but they don't.
04:25:56 <aristid> mami: what's the type of k?
04:26:02 <aristid> shachaf: i thought you're already asleep.
04:26:05 <mami> int
04:26:17 <mami> keys = [Int]
04:26:22 <mami> aristid
04:26:24 <aristid> mami: perhaps you need to convert k to a floating point value first then...
04:27:03 <Sizur> shachaf: what if i think of a box as a value continuum?
04:27:04 <mami> ah ok
04:28:05 <shachaf> Sizur: What?
04:28:23 <aristid> mami: i also suspect you really want a better hash function that doesn't involve floating point at all ;)
04:28:37 <Sizur> shachaf: the box changes with every compositoin, like a monoid
04:29:22 <shachaf> Are you just trolling at me or what?
04:29:50 <aristid> such a shame that the famous beaky quote is not in lambdabot
04:29:55 <aristid> so we just get this instead
04:29:58 <aristid> @quote beaky
04:29:58 <lambdabot> beaky says: why did they settle on bitshiftrightassign (>>=) for monadic bind?
04:30:22 <yitz> aristid: so put the famous one in
04:30:34 <aristid> yitz: i would have to make sure to get the words exactly right
04:30:48 <shachaf> Don't put it in. It's way overdone.
04:30:54 <yitz> aristid: can you find it in the channel logs
04:31:01 <mami> aristid: yes i dont want it
04:31:07 <aristid> yitz: no, but shachaf has it in a file on his server somewhere.
04:31:10 <mami> its just some exercise
04:31:13 <yitz> shachaf: oh. well, i don't know the quote.
04:31:20 <aristid> mami: ah ok
04:31:23 <mami> not the implementation, we are supposed to analyse it
04:31:42 <mami> but i noticed it often helps to understand it if you can play around with it
04:31:52 <aristid> yitz: you don't know "I love monoids. They are so easy." ?
04:31:57 <mami> so i try to implement as many data structures and algos as i have time for
04:31:58 <Sizur> shachaf: no i dont troll, just trying to understaing (all the time). so obviously i'm throwing terms i think i know but i have no clue.
04:32:21 <mami> just started learning haskell, so i often trip over the types ;)
04:32:54 <Sizur> i thought that i have monoid in the bag. it's like the simpliest thing possible
04:33:22 <mami> aristid: it works now, thank you
04:34:14 <yitz> aristid: no. maybe pm it to me - i think shachaf doesn't want it in the channel logs :)
04:34:28 <aristid> yitz: i already showed it here ;) that was the whole thing.
04:34:28 <shachaf> The quote is <beaky> i love monoids <beaky> they are so easy
04:34:52 <johnw> Sizur: When contemplating abstractions, always be on guard against specious examples.  Their danger lies in that, until you really know the abstraction, you simply can't judge an example.  How right it sounds is not a reliable indicator.  Even if it's right in a sense, that's usually just one aspect of the abstraction; thinking it covers the whole might be worse than nothing.
04:34:54 <shachaf> It's pretty pointless on its own. There is a greater context.
04:35:01 <aristid> for a while shachaf adapted this quote to everything under the sun.
04:35:11 <aristid> he seems to have grown tired of it
04:35:16 <yitz> shachaf: sounds like it
04:35:27 <shachaf> yitz: It's actually pretty pointless even with the context.
04:37:14 <Sizur> johnw: how can you understand abstraction without abstracting a set of concretes?  should we have a set of conretes published for each abstraction and let the brain do its work?
04:37:32 <johnw> Sizur: I just said to be on guard
04:37:55 <Sizur> i mean think i understand a collection of objects and an operation that follows some rules
04:38:09 <johnw> if ever I find myself saying, "Yes, that's what X is/means", I try to raise a red flag because a deeper understanding might be eluding me
04:38:49 * hackagebot binding-core 0.2.2 - Data Binding  http://hackage.haskell.org/package/binding-core-0.2.2 (GideonSireling)
04:38:49 <Sizur> thanks
04:38:51 * hackagebot binding-gtk 0.2.1 - Data Binding in Gtk2Hs  http://hackage.haskell.org/package/binding-gtk-0.2.1 (GideonSireling)
04:38:52 <shachaf> The problem is not concrete instances of the abstraction. Those are good.
04:38:53 * hackagebot binding-wx 0.2.1 - Data Binding in WxHaskell  http://hackage.haskell.org/package/binding-wx-0.2.1 (GideonSireling)
04:44:16 <Aetherspawn> Anyone know how to fix this type checking error: http://hpaste.org/89604 ?
04:47:06 <Cale> What's the type of  allocate ?? killThread
04:50:07 <Aetherspawn> Cale, sec
04:50:39 <Cale> Aetherspawn: I'm not too familiar with the Conduit libraries -- not sure where ?? is even defined :)
04:50:55 <Aetherspawn> I was able to fix the issue I had before with conduits :)
04:51:02 <m3ga> Aetherspawn: i think you need a liftIO on resourceForkIO
04:51:11 <Aetherspawn> oh, let me try that
04:51:11 <Cale> resourceForkIO :: MonadBaseControl IO m => ResourceT m () -> ResourceT m ThreadId
04:51:15 <Aetherspawn> I got arund it by using runResourceT
04:51:26 <ryant50001> is there any conceivable way to import two different versions of the same library?
04:51:31 <Cale> actually, yeah, you probably want the opposite
04:51:54 <Cale> ryant50001: There's some syntax for that, iirc... let me find the documentation
04:52:07 <ryant50001> Cale: i'm specifically worried about multiple instance declarations
04:52:15 <Aetherspawn> I can't make it check with liftIO, so for now I think runResourceT is the one I want.
04:52:23 <ryant50001> i know about PackageImports, but i'm not sure that'll cut it
04:52:28 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#package-imports
04:52:30 <Cale> oh
04:52:31 <Cale> hmm
04:52:46 <Cale> Well, if that doesn't work, I don't know what will :)
04:52:49 <ryant50001> i'm thinking it might be necessary to import two copies of every *dependency*, too
04:53:02 <Cale> That sounds rough. What's going on?
04:53:04 <ryant50001> which might be ok... until you get to base
04:53:14 <ryant50001> oh, just an idea i'm kicking around
04:54:46 <Cale> Aetherspawn: Yeah, liftIO is for turning IO actions into actions of monads built on top of IO.
04:55:41 <Cale> Aetherspawn: resourceForkIO already produces an action in ResourceT, so you won't be able to apply liftIO to it, but you can run the action it gives to get yourself an IO action, which for whatever reason seems to be what (allocate ?? killThread) wants as its parameter.
04:56:20 <Aetherspawn> ?? is lens flip
04:56:20 <lambdabot>  is lens flip
04:56:30 <Aetherspawn> Thanks lambda...
04:56:35 <Cale> What is ??
04:56:47 <Aetherspawn> (??) = flip
04:56:58 <ryant50001> hmm
04:57:01 <Cale> I mean... which lambdabot command is that triggering, I wonder.
04:57:09 <ryant50001> is it necessary to instance soundness that we not allow duplicate instances *at all*?
04:57:09 <Aetherspawn> allocate takes a finalizer and a thing to bind to the resource
04:57:16 <shachaf> Cale: composition
04:57:24 <Cale> shachaf: ah
04:57:30 <ryant50001> or would it be sufficient to disallow any kind of instance *resolution* on duplicate instances
04:57:39 <Aetherspawn> ?? a . b . c . (\x -> b f g x)
04:57:40 <lambdabot>  a . b . c . (\x -> b f g x)
04:57:42 <shachaf> Well, @@. Not quite composition.
04:57:53 <monoidal> ?? /me hello
04:57:53 <lambdabot>  /me hello
04:57:58 <shachaf> ?? (?where test) (?where test)
04:57:58 <lambdabot>  AACTION hiA AACTION hiA
04:58:12 <Bor0> ?? hello
04:58:12 <lambdabot>  hello
04:58:41 <Bor0> ?? ?? hello
04:58:42 <lambdabot>  hello
04:58:46 <magicman> ?? @elite @quote shachaf
04:58:46 <lambdabot>  zhaC|-|4F SAY$: typ3 c1Ass3s AR3 a $Cary z+oRy tHA7 u TEl1 NEW hASk3l|Er5 zo 7Hey cAN go +o zLE3P 47 NIgHt.
04:58:54 <magicman> (I'll never do that again, promise)
04:59:05 <Aetherspawn> :t writer
04:59:07 <lambdabot> MonadWriter w m => (a, w) -> m a
04:59:12 <Cale> ryant50001: Hmm...
04:59:40 <Cale> ryant50001: What would the difference be, apart from reporting an error slightly later?
05:00:04 <Cale> ryant50001: You could build a program in which there were duplicate instances that were never used, I suppose.
05:00:42 <ryant50001> oh, actually, it just works
05:00:52 <Cale> Or do you mean, you're allowed to compile code that closes over each of those instances separately, and then when they're both imported, things are okay?
05:00:58 <ryant50001> Cale: i just made two identical modules that each create instances for Monoid Int
05:00:59 <Cale> (so long as you don't need to use either)
05:01:02 <ryant50001> import both of them
05:01:10 <ryant50001> use something that *uses* those monoid instances
05:01:20 <ryant50001> works perfectly
05:01:46 <ryant50001> (but the Main module doesn't *itself* use the instances - i.e.: it never actually passes a dictionary)
05:02:00 <Cale> Yeah, as long as you don't need to do instance resolution, it should be okay -- though obviously not ideal, as anyone who imports your module won't be able to use either instance.
05:02:05 <shachaf> This sounds like a bad idea.
05:02:15 <ryant50001> shachaf: oh, it is :P
05:02:29 <ryant50001> shachaf: but it's less bad than the other crazy hacks i was contemplating
05:03:42 <ryant50001> i was mostly just curious about whether it was possible
05:09:15 <elliott> johnw: pong
05:17:36 <oo_miguel> Hi everybody. I am just taking a look on haskell for the first time, and I do not understand why foldl can not work with infinite lists, while foldr *can*. For me it would make sense the other way round. Does it have to do with the underlying implementation?
05:17:51 <shachaf> It has to do with how lists work.
05:17:54 <shachaf> Look:
05:17:58 <shachaf> > foldr f z [a,b,c,d]
05:17:59 <lambdabot>   f a (f b (f c (f d z)))
05:18:01 <shachaf> > foldl f z [a,b,c,d]
05:18:02 <lambdabot>   f (f (f (f z a) b) c) d
05:18:38 <oo_miguel> hmm
05:18:50 <elliott> @src foldl
05:18:50 <lambdabot> foldl f z []     = z
05:18:50 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:19:04 <elliott> you can see from ^ that if a list has no [] in it, foldl will never do anything other than call itself
05:19:09 <elliott> @src foldr
05:19:09 <lambdabot> foldr f z []     = z
05:19:09 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:19:16 <elliott> whereas foldr will give you the result of f instead
05:20:01 <oo_miguel> I am so slow , sorry. Have to think about it. but I guess with your hints, it will soon make sense to me. thanks a lot
05:20:07 <shachaf> Listen to elliott.
05:20:08 <oo_miguel> otherwise I will ask ;)
05:23:28 <Bor0> @src findIndex
05:23:28 <lambdabot> findIndex p     = listToMaybe . findIndices p
05:24:13 <Cale> oo_miguel: One thing you should know about lazy evaluation is that it's outermost first
05:24:34 <Cale> oo_miguel: So, you can see in the definition of foldr f z (x:xs), the first thing it does is to pass control to f
05:24:54 <oo_miguel> Can you give me some examples with infinite lists, where foldr makes sense and foldl does not
05:24:59 <Cale> oo_miguel: which gets to decide whether or not to proceed with the rest of the list by pattern matching on its second argument or not
05:25:19 <Cale> While foldl just immediately calls itself with new parameters until it reaches the end of the list
05:25:20 <oo_miguel> ah
05:25:27 <oo_miguel> I got it
05:25:43 <oo_miguel> foldl will call itself until the end of time, before it evaluates anything right?
05:25:47 <Cale> yeah
05:26:11 <oo_miguel> thank you very much everybody
05:26:13 <Cale> It just builds up a large expression in its second parameter without producing any data constructors
05:27:07 <Cale> While in the foldr case, f might be able to produce a data constructor (and may or may not put the foldr over the rest of the list inside the data structure it produces)
05:27:22 <Cale> > foldr (\x xs -> 2*x : xs) [] [1..]
05:27:23 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
05:27:40 <Cale> So this gets evaluated like:
05:27:43 <Cale> foldr (\x xs -> 2*x : xs) [] [1..]
05:28:01 <Cale> --> (\x xs -> 2*x : xs) 1 (foldr (\x xs -> 2*x : xs) [] [2..])
05:28:20 <Cale> --> (2*1) : (foldr (\x xs -> 2*x : xs) [] [2..])
05:28:56 <Cale> and now if some case expression is pattern matching on this with the pattern (v:vs), the match succeeds at this point, binding v to 2*1, and vs to (foldr (\x xs -> 2*x : xs) [] [2..])
05:29:10 <Cale> and so if we're asking only for the head of the list, we're done
05:29:32 <Cale> oo_miguel: make sense?
05:29:45 <oo_miguel> sorry im so slow :P
05:29:50 <Cale> It's no problem :)
05:30:01 <oo_miguel> but
05:30:06 <oo_miguel> it makes perfect sense
05:30:08 <oo_miguel> :)
05:30:19 <Cale> cool
05:30:41 <oo_miguel> thank you very very much
05:32:27 <fruitFly> Despite haskell not being used so much in industry, I've heard it's very performant; but would it excel at making an application like this? https://bitmessage.org/wiki/Main_Page
05:33:14 <eikke> fruitFly: sure, why not
05:33:36 <fruitFly> :)
05:34:22 <RichyB> I would say that anything where you're routing TCP traffic around (e.g. webservers, torrenters) is going to be pretty easy to get to block on available network bandwidth rather than CPU, especially in Haskell.
05:34:35 <bitonic> @faq would Haskell excel at an application like that?
05:34:35 <lambdabot> The answer is: Yes! Haskell can do that.
05:34:38 <eikke> fruitFly: there's even some interesting research on using type systems like Haskell's to enforce security, e.g. http://www.cis.upenn.edu/~stevez/papers/LZ06a.pdf
05:35:42 <fruitFly> eikke: aah... interesting, I really want a job, but I guess I really can't go wrong learning haskell in the longrun
05:38:51 * hackagebot accelerate 0.13.0.4 - An embedded language for accelerated array processing  http://hackage.haskell.org/package/accelerate-0.13.0.4 (TrevorMcDonell)
05:39:16 <Aetherspawn> Wow, uh, what: http://hpaste.org/89606
05:39:20 <Cale> fruitFly: Yeah, in my experience, the people who I've seen learn Haskell as their first language usually don't have such a hard time picking up imperative or OO languages anyway. (But it's trickier going the other way around, since you learn bad habits.)
05:39:26 <Aetherspawn> I checked all my type signatures and nothing uses Maybe
05:39:30 <Aetherspawn> Why do I get this error?
05:39:54 <Cale> Aetherspawn: What's the type of allocator?
05:40:01 <Aetherspawn> its under the let
05:40:12 <Cale> Yeah, I don't know what libraries you're using...
05:40:13 <Aetherspawn> uh, its
05:40:23 <Aetherspawn> let me check quickly
05:40:28 <Cale> Aetherspawn: write  allocator :: Int  and see what error you get
05:40:42 <Cale> (It'll tell you the correct signature in the error :)
05:41:23 <Cale> Aetherspawn: In fact, it would be good to know what type ?? has
05:41:31 <Aetherspawn> (a0 -> b0) -> Source (ResourceT IO) (f0 a0) -> m0 (ReleaseKey, ThreadId)
05:41:50 <Aetherspawn> (??) = flip
05:41:52 <Aetherspawn> :t flip
05:41:53 <Cale> oh
05:41:53 <lambdabot> (a -> b -> c) -> b -> a -> c
05:42:00 <Cale> okay
05:42:59 <elliott> :t (??)
05:43:00 <Aetherspawn> Ideally it should be (a0 -> b0) -> Source m a0 -> ...
05:43:00 <lambdabot> Functor f => f (a -> b) -> a -> f b
05:43:03 <elliott> it's actually Cale's flip :p
05:43:15 <Cale> Not mine, ski's
05:43:28 <elliott> it's all your fault, Cale. all of it!
05:43:30 <Aetherspawn> its from Control.Lens
05:43:35 <Cale> ah, okay
05:44:22 <k0ral_> has anyone already got the GHC error "internal error: PAP object entered!"
05:44:25 <k0ral_> ?
05:44:33 <Cale> One of Ed's infix menagerie.
05:44:46 <Cale> k0ral_: I've seen that before, a long time ago
05:44:52 <Aetherspawn> I hate transformers
05:44:59 <Aetherspawn> They give me hell typing /all/ the time
05:45:02 <monoidal> k0ral_: browse http://hackage.haskell.org/trac/ghc/search?q=PAP+object+entered
05:45:52 <Cale> Aetherspawn: Conduit's situation with types is particularly bad.
05:46:01 <monoidal> k0ral_: one way to get it is unsafeCoerce casting functions to integers or conversely (I don't remember)
05:46:24 <Cale> But yeah, using raw monad transformers without newtyping them kinda sucks, imo.
05:46:54 <Aetherspawn> OK maybe I should wrap the entire everything in ResourceT
05:47:22 <k0ral_> monoidal: I didn't do that, the error pops up at runtime, it appeared after I did some change in the monad transformers stack I'm using
05:47:26 <Cale> Aetherspawn: What's the actual goal here? I don't really know Conduit all that well, but perhaps I could help look for a solution.
05:47:44 <Aetherspawn> I'm taking 2 sources of types a and b respectively
05:47:47 <Cale> (I usually avoid it because I think its types are a mess that I'd rather not deal with)
05:47:53 <Aetherspawn> and spawning 2 threads which write to a shared tchan
05:47:56 <eikke> yeah, non-newtype'd transformer stacks should be forbidden by law
05:48:00 <Aetherspawn> and then pulling a source out of that tchan
05:48:12 <Aetherspawn> So I get 1 source which gives me Either a b as an output
05:48:22 <Aetherspawn> and then I just guard to figure out what it has given me
05:48:29 <Aetherspawn> (in this case, the difference is Packet or Broadcast)
05:48:39 <Aetherspawn> where Packet comes from the network and Broadcast comes from other threads in the server
05:49:10 <Cale> monoidal: It would probably be casting functions (partially applied ones) to some type which has data constructors and then pattern matching. (Int would do, if you do pretty much anything with it)
05:49:57 <Cale> er, wait, what?
05:50:02 <monoidal> k0ral_: if you can reliably reproduce, and are using 7.6, I would file a bug report
05:50:07 <Cale> ghci> :m + Unsafe.Coerce
05:50:07 <Cale> ghci> unsafeCoerce (map (*2)) :: Int
05:50:07 <Cale> 16777481
05:50:08 <Cale> lol
05:50:13 <monoidal> k0ral_: you might hpaste, I'll check head
05:50:48 <shachaf> Cale: ?
05:50:49 <Cale> Aetherspawn: hmm...
05:51:11 <Cale> shachaf: I expected that it would try to enter the partial application
05:52:55 <k0ral_> monoidal: depends on what you mean by "reliably"; my current code systematically triggers the error, however I'm not able to tell which part of the code is responsible
05:53:26 <Cale> Aetherspawn: I'm actually surprised that there isn't something similar to that in conduit already...
05:53:52 <Aetherspawn> well, there is a package that provides a mergeSources currently
05:54:00 <Aetherspawn> but it doesn't /quite/ do what I want
05:54:28 <Aetherspawn> (and, it doesn't terminate when either of the sources die which is ideal)
05:54:40 <Aetherspawn> /s/ideal/not ideal/
05:57:29 <Cale> Aetherspawn: Well, one thing which might simplify your life a little would be to just work on merging two sources of the same type
05:57:42 <Aetherspawn> Oh, I had that working
05:57:51 <Aetherspawn> using some stuff courtesy of Enigmagic
05:58:21 <Cale> Aetherspawn: you can use mapOutput Left and mapOutput Right to inject them into a Source on the Either type
05:59:08 <Bor0> @src zip
05:59:08 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
05:59:08 <lambdabot> zip _      _      = []
06:00:57 <Aetherspawn> Cale, as a replacement for the s $$ Cl.mapM_ stuff?
06:01:22 <Aetherspawn> Wait, nevermind.
06:01:48 <Cale> Aetherspawn: Well, suppose you have some   merge :: Source m o -> Source m o -> Source m o
06:02:01 <Aetherspawn> Yeah, I just understood what you mean :)
06:04:07 * Cale installs conduit for no practical reason other than to play with this :)
06:04:14 <Aetherspawn> Oh, hey, it actually works a charm
06:04:34 <Aetherspawn> My code is really heavyweight for what it does though...
06:04:39 <Aetherspawn> lots of frankensteining from everywhere
06:04:41 <Cale> http://hackage.haskell.org/packages/archive/conduit/1.0.6/doc/html/src/Data-Conduit-Util.html#zip -- there's some code here which could probably be tailored into the operation you want
06:04:56 <Cale> (it does zip instead of merging)
06:05:23 <Aetherspawn> Oh, those won't work for sources which block
06:05:33 <Aetherspawn> er, that was worded badly
06:05:36 <Aetherspawn> but I hope you get what I mean.
06:20:40 <gienah> hi: is there some way to remove the blank lines in tables using pandoc with pdflatex output?
06:35:12 <linduxed> did Data.List.Split stop being called that or something?
06:35:42 <linduxed> because i get "Could not find module `Data.List.Split'
06:36:31 <elliott> do you not have the split package installed?
06:36:50 <linduxed> i think so
06:36:53 <linduxed> lemme see
06:37:48 <linduxed> aaah, no
06:37:50 <linduxed> thx
06:37:52 <qwerty1793> Hi, I've started doing some work with haskell and wondered why, if !! takes O(n) time on a list I shouldn't just do something like "fnFromList is = (!) (array (0, n-1) (zip [0..n-1] is)) where n = length is" ?
06:39:10 <parcs> qwerty1793: that would be even less efficient than !!
06:40:05 <shachaf> Is the question why you would use a list and not an array?
06:40:06 <qwerty1793> parcs: why? surely this builds an array and then i get to do lookups in constant time, right?
06:41:52 <qwerty1793> shachaf: actually that's probably the question i wanted to ask
06:48:08 * gienah answering my pandoc q: added this to my.sty to squash the tables: \renewcommand{\arraystretch}{0.05} 
06:48:09 <geekosaur> qwerty1793, you're traversing the list multiple times, plus I think creating the array has a fairly high overhead. and you haven't done it in a way that can be memoized, so you pay that cost on every lookup
06:49:19 <shachaf> geekosaur: I think qwerty1793's actualy question was why use lists in the first place if they don't have constant-time indexing.
06:49:43 <shachaf> The answer is that they have a bunch of other advantages. The next question is probably what those advantages are.
06:50:12 <qwerty1793> so I guess they work really well with recurssion
06:50:23 <geekosaur> yes, a list is more or less recursion encoded as data
06:51:07 <elliott> (a specific kind of recursion, mind)
06:51:07 <geekosaur> see for example how foldr can be seen as replacing the [] and (:) in a list
06:51:22 <elliott> (e.g., trees encode a different recursive "shape")
06:51:39 <elliott> (the kind that lists encode corresponds to iteration -- your standard, "linear" loop)
06:57:07 <notdan> Does anybody know whether GHC uses mtl or transformers under the hood?
06:58:00 <elliott> mtl is based on transformers
06:59:04 <notdan> Yes, but I am wondering if GHC is using mtl at all
06:59:25 <w0rm-_x> what does mtl stand for
06:59:38 <Cale> Monad Transformer Library
06:59:39 <notdan> Because I can't guess that just by looking at import files since the namespaces for mtl and transformers clash
06:59:40 <geekosaur> ghc predates transformers so it uses mtl. but modern mtl is transformers under the hood
07:00:18 <geekosaur> rewiring ghc to use transformers directly would be a huge and thankless (and largely pointless) task
07:00:30 <notdan> Ok, I am just trying to figure out whether I need ghc-mtl for compiling hint for GHC 7.8 or not
07:01:50 <w0rm-_x> Cale, thanks.
07:03:54 <qwerty1793> sorry but could someone explain why (+3) :: Num a => a -> a but (-3) :: Num a => a? And so how do i get the function which subtracts 3?
07:04:51 <notdan> @ty ((-)3)
07:04:52 <lambdabot> Num a => a -> a
07:04:53 <geekosaur> (subtract 3) or add more parentheses
07:05:16 <qwerty1793> geekosaur: awesome, thanks
07:05:32 <elliott> er.
07:05:36 <elliott> ((-)3) is not the same thing.
07:05:52 <geekosaur> and, it's because haskell's grammar doesn't really support operators that are either unary or binary depending on context (because of the conflict with section syntax), so negative numbers are a bit of a parser hack
07:06:26 <notdan> elliott: yeah, it's flipped
07:06:34 <hpc> an elegant solution would be to require whitespace separating operators
07:06:42 <hpc> then (- 3) is a section and (-3) is a number
07:06:56 <notdan> I think it would be easier just to have ~ like in ML
07:07:00 <hpc> but that would break a lot of not-great code
07:09:47 <hpc> well, whitespace around operators is something you should do anyway
07:12:39 <Gracenotes> that seems non-elegant
07:13:21 <hpc> many other languages do it that way
07:13:25 <Gracenotes> nobody expects significant whitespace there
07:13:34 <jmcarthur> i wouldn't say "nobody"
07:13:37 <Gracenotes> and I write all my sections without whitespace, actually :)
07:13:42 <hodapp> let's instead just write everything directly as an AST expressed as sexprs!
07:13:43 <Gracenotes> (for arithmetic operators)
07:14:01 <jmcarthur> for what it's worth, this is why we have the subtract function
07:14:02 <hpc> find me any other language where -3 is not negative three
07:14:03 <jmcarthur> :t subtract
07:14:05 <lambdabot> Num a => a -> a -> a
07:14:13 <Gracenotes> Haskell
07:14:18 <hpc> in fact, i know of a few languages where +3 is three
07:14:34 <hpc> Gracenotes: other language
07:14:43 <Gracenotes> languages with infix operators?
07:15:12 <Gracenotes> ...which likely don't have user-definable infix ops, though, I'm guessing...
07:15:42 <RichyB> Oh, 2013.2 is out? Sweet.
07:15:48 <hodapp> Scala has user-defininable infix ops, I believe
07:16:38 <geekosaur> hpc, there are a couple of languages which use _ for negative literals
07:16:40 <hpc> agda requires significant whitespace around operators
07:16:48 <hodapp> geekosaur: doesn't J?
07:17:00 <geekosaur> specifically to avoid tryingt o determine if - is infix or prefix
07:17:04 <Gracenotes> mm. as does factor, largely because both allow arbitrarily weird names for em
07:17:10 <geekosaur> that's one of them, yes
07:18:12 <RichyB> geekosaur: I thought ML used tilde ~?
07:18:23 <RichyB> That seems like a pretty reasonable compromise.
07:18:29 <geekosaur> yacc-based parsers provide a specific hack to make prefix - work (%prec)
07:18:56 <geekosaur> because it's something of a general issue when an operator can be prefix or infix
07:19:01 <hpc> in any event, consider the simplification that my proposal would add to the language
07:19:03 <linduxed> hey guys
07:19:11 <linduxed> for this code https://github.com/linduxed/nordea-homebank-csv-converter
07:19:15 <linduxed> i'm getting this error
07:19:23 <linduxed> nordea-homebank: <stdin>: hGetContents: invalid argument (invalid byte sequence)
07:19:29 <Gracenotes> in any case, this 'simplification' sounds way too ad hoc for my liking
07:19:32 <hpc> a negative literal parse is currently the token sequence "( minus number )"
07:19:34 <linduxed> for input like this:
07:19:45 <hpc> with significant whitespace, a negative literal becomes its own token
07:20:24 <linduxed> https://gist.github.com/5743739
07:20:31 <Gracenotes> in any case, this may sound weird, but you rarely need negative numbers.
07:20:37 <geekosaur> linduxed, that error means you have an encoding conflict; usually means you are trying to use utf8 when iso8859-1 is expected or vice versa. modern ghc checks $LANG to see if it should do utf8 or iso8859 and defaults to iso8859-1
07:20:37 <Gracenotes> just standalone ones
07:20:41 <linduxed> i've tried adding utf8-strings but it doens't seem to work
07:21:11 <Gracenotes> a lot of people dislike significant whitespace which is already present in Haskell, and appreciate the fact that it's optional
07:21:15 <hpc> the token for "-" as an operator is no longer special in the parser
07:21:27 <geekosaur> (if this is windows, I don't know how you check for/set locale)
07:21:42 <jmcarthur> well, except for "--"
07:22:05 <hpc> Gracenotes: that's a false dichotomy; whitespace between operators is more analogous to converting "map succ [1..]" to "mapsucc[1..]"
07:22:30 <jmcarthur> which has its own interesting whitespace sensitive behavior, since " -->" is an operator, but " -- " is a comment
07:22:30 <linduxed> geekosaur: oh wait! this file is latin1
07:22:33 <hpc> which is decidedly not optional
07:22:53 <linduxed> geekosaur: maybe i won't even need the utf8-strings if i convert the file to utf8
07:23:08 <geekosaur> so you'll need to set the encoding, either at the OS level or http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/GHC-IO-Encoding.html
07:23:24 <geekosaur> utf8-strings hasn't been needed since (IIRC) ghc 6.12
07:23:26 <Gracenotes> The lexer's assumption is that no token can contain both symbols and letters, so no, those are not the same.
07:23:51 <Gracenotes> it is an assumption that makes for a pretty clear-looking lexer.
07:23:51 <geekosaur> when ghc got encoding support
07:24:11 <linduxed> geekosaur: i'll just run iconv on it
07:25:55 <Gracenotes> (well, for a language that's as complicated as Haskell...)
07:26:09 <hodapp> complicated? I find a lot of it quite simple.
07:27:06 <Gracenotes> syntactically, though especially with an extensible parser and fun like that
07:27:18 <geekosaur> hodapp, there is a lot that is simple from the human point of view but a nightmare to parse
07:27:53 <hodapp> geekosaur: I code C++ regularly. Anytime someone tells me something is a nightmare to parse, and they're not talking about Perl, it rings kind of hollow.
07:28:35 <geekosaur> C++ does not have a monopoly on weird syntax
07:29:01 <hodapp> geekosaur: Just about the only language that competes with C++ for "really shitty to parse" is Perl.
07:32:30 <Fuuzetsu> hodapp: it's not possible to parse Perl without solving the halting problem
07:32:46 <hodapp> Fuuzetsu: And it's much the same for C++ since templates are Turing-complete.
07:32:49 <Fuuzetsu> http://www.perlmonks.org/?node_id=663393
07:33:08 <yrlnry> The non-parsability of Perl is not a problem in practice, however.
07:33:09 <hpc> in perl, the trouble is an interaction between prototypes and BEGIN blocks
07:33:24 <hpc> so long as you aren't programatically setting the prototype of a function, you should be fine
07:33:39 <hodapp> yrlnry: The non-parsability of C++, however, is, since it leads to inconsistency in interpretation and to astronomically long compile times.
07:34:10 <hpc> if you wanted to be a dick, you could say lisp is unparseable
07:34:18 <yrlnry> There you go.
07:34:30 <hpc> because macros are expanded before you have a final AST for your program
07:34:51 <elliott> I don't think C++ compile times are down to parsing.
07:34:54 <yrlnry> And read macros.
07:34:59 <hpc> and happens incrementally, so you don't really finish parsing until you terminate
07:35:10 <hodapp> elliott: Templates cause some big big problems here, and in large part due to being Turing complete.
07:35:16 <elliott> yes, templates
07:35:21 <elliott> I wouldn't lump template expansion under parsing.
07:35:33 <elliott> it's true that you need to know what is a template or not to parse though IIRC. but that's a different issue
07:35:56 <hodapp> elliott: I've never clearly seen how any of it is not a parse-time activity
07:36:29 <hodapp> hpc: er, yeah, *is* there a meaningful AST here?
07:37:39 <hpc> hodapp: not really; it's dependently parsed, if that is even a term
07:37:49 <hodapp> hpc: it is now!
07:43:19 <eikke> pipes, conduits & co lack sample 'design patterns'. They might be great libraries, but they lack examples on how to actually use them in different scenarios
07:43:30 <FreeFull> > (>>= id) (+) 3
07:43:31 <lambdabot>   6
07:44:00 <hodapp> design patterns...
07:44:02 * hodapp shudders
07:44:05 <Fuuzetsu> ^
07:44:10 <eikke> or howevver you want to call it :)
07:44:18 <Fuuzetsu> ‘examples’ sounds less horrible
07:44:54 <FreeFull> > ((>>= id) :: [[a]] -> [a]) (+) 3
07:44:55 <lambdabot>   The function `(GHC.Base.>>= GHC.Base.id) :: [[a]] -> [a]'
07:44:55 <lambdabot>  is applied to tw...
07:45:01 <Fuuzetsu> Looking at packages that use the libraries you want to learn about is usually a good starting point
07:45:07 <hodapp> I once had a developer try to explain to me that the whole of functional programming was not of any interest to him, because he already had a book on design patterns and that covered everything important.
07:45:19 <hodapp> Said dev was old enough to know better.
07:45:43 <eikke> Fuuzetsu: yes-and-no. most of those packages are libraries (eg client lib for some protocol) themself
07:45:45 <Fuuzetsu> I think that you need a more expressive/extensible language if you have patterns in your programs…
07:45:46 <jmcarthur> :(
07:46:07 <hodapp> Fuuzetsu: .........Well, yes.
07:46:22 <FreeFull> What's the specialised type of  (>>= id)  in   (>>= id) (+)
07:46:34 <Fuuzetsu> :t (>>= id)
07:46:35 <lambdabot> Monad m => m (m b) -> m b
07:46:44 <Fuuzetsu> :t (>>= id) (+)
07:46:45 <lambdabot> Num b => b -> b
07:46:46 <jmcarthur> :t ((>>= id) `asTypeOf` ?foo) (+)
07:46:47 <lambdabot> (?foo::(b -> b -> b) -> b -> b, Num b) => b -> b
07:46:51 <jmcarthur> ^^
07:46:56 <Fuuzetsu> :t asTypeOf
07:46:57 <lambdabot> a -> a -> a
07:47:24 <hodapp> Fuuzetsu: I can't recall where I've seen it mentioned, but I did start to agree with the opinion that design patterns are evidence of lack in the language itself.
07:48:02 <Fuuzetsu> Possibly on Paul Graham's site.
07:48:12 <geekosaur> a design pattern is a library function that the language can't phrase as a library function
07:49:01 <Gracenotes> which isn't necessarily a bad thing, if you get to just the right level of abstraction to be programming on
07:49:02 <hodapp> geekosaur: and that's why for instance when people tell me that it's just as good to use functional design principles in a non-functional language, as to use a functional language, I really can't agree.
07:49:20 <Gracenotes> if you stop short of that level of abstraction, well, that is unfortunate.
07:49:27 <hodapp> Gracenotes: the nature of a design pattern is that it *can't* be at that level of abstraction, or it wouldn't be a "pattern".
07:50:02 <FreeFull> Is there a monad instance for functions or something?
07:50:06 <geekosaur> yes
07:50:09 <Gracenotes> I mean, when you are coding things, you are coding on top of the highest level of abstraction the language can offer you, which can constitute a design pattern when done consistently
07:50:27 <geekosaur> FreeFull, the Reader monad is essentially the function monad
07:50:34 <jmcarthur> FreeFull: it's Monad ((->) r)
07:50:53 <FreeFull> Oh, right, Reader
07:50:58 <FreeFull> I think I asked about this before too
07:51:02 <geekosaur> (actually a newetype around the function monad, which is also available by itself as jmcarthur showed)
07:51:05 <hodapp> Gracenotes: And if you want it to be reusable, having it be reusable as a 'pattern' is still stopping short.
07:51:15 <Gracenotes> of course, Haskell has a lot of 'highest levels' depending on what extra functions you define, but the point is, you can choose one of those levels to program on.
07:51:52 <Gracenotes> and the idioms available to you may change.
07:51:59 <geekosaur> the very fact that something is a recognizeable pattern is an indication that the human mind can see an abstraction that the language cannot (or, sometimes, that the library author did not; this version can at least be remedied)
07:52:14 <Fuuzetsu> Lisp
07:52:28 <hodapp> geekosaur: that's a good way to put it.
07:52:47 <Gracenotes> geekosaur: I think I mostly agree with you, but I am talking about this in terms of Haskell. So what are design patterns in Haskell?
07:52:53 <Gracenotes> in your view
07:53:09 <jmcarthur> Gracenotes: MonadFoo type classes
07:53:14 <jmcarthur> is one example
07:53:59 <geekosaur> yes, haskell does have design patterns. many of them are openly acknowledged shortcomings in the language; see for example how records are used
07:54:00 <Gracenotes> sounds right. could the language be extended to abstract over them?
07:54:06 <jmcarthur> Gracenotes: unsafePerformIO + NOINLINE for "safe" global ref tricks
07:54:16 <Gracenotes> okay, we don't speak of /that/ >_>
07:54:19 <hodapp> geekosaur: what do you mean about records?
07:54:25 <jmcarthur> but it's there, and there's a real need for it
07:55:08 <geekosaur> hodapp, a concrete example is that record updates are not first class syntax: you cannot, in the expression aRecord {aField = newValue}, use a variable for aField
07:55:14 <Gracenotes> I guess it is impressive that Haskell has a "global variable pattern", when you consider how abused they can be in other languages
07:55:30 <yrlnry> Haskell has a whole constellation of design patterns around the abuse of typeclasses to get something like dependent typing.
07:55:42 <jmcarthur> yrlnry: yes!
07:55:43 <FreeFull> geekosaur: Which is probably one of the reasons lenses exist
07:56:04 <geekosaur> so you often see a lot of boilerplate (or, alternately, use of libraries involving Template Haskell or things like lenses) in record-heavy code
07:56:24 <Gracenotes> it's also hard to say what is 'part of the language' since so much of the functions used in the standard library can be defined independently and used.
07:56:36 <Gracenotes> or you could define Bool if you like
07:57:03 <jmcarthur> one design pattern i implement a lot is newtype wrapping/unwrapping helpers. the newtype library could help (never got into it), but you still have to write the boilerplate
07:57:14 <jmcarthur> pretty much anything requiring TH is going to fit into this category, i guess
07:57:15 <elliott> jmcarthur: lens usurps newtype :p
07:57:25 <geekosaur> you could argue that the existence of Template Haskell is an admission that there are patterns that cannot be captured in Haskell...
07:57:29 <Gracenotes> So you could take a kernel view, that Haskell is whatever kernel is sufficient to produce the entire standard library.
07:58:27 <jmcarthur> elliott: in what way?
07:58:34 <Gracenotes> syntactic patterns? well... there is no such thing as a free lunch; you need a coherent grammar to say anything meaningful.
07:59:01 <jmcarthur> another reason i don't like the newtype library is that i have to instantiate a type class, which is bad if i don't actually want the representation visible outside the library i'm working in
07:59:05 <elliott> jmcarthur: it has all the functions newtype does for the same purpose
07:59:08 <elliott> but in a more general form.
07:59:11 <jmcarthur> so i really do have to reimplement all that stuff every time
07:59:18 <elliott> you can avoid giving an instance with lens' form
07:59:21 <Gracenotes> is reflection a pattern in Java?
07:59:29 <jmcarthur> yeah, this is something i like about lens
07:59:32 <jmcarthur> it isn't viral
07:59:41 <jmcarthur> (mostly)
07:59:44 <ciaranm> "pattern" is a term thrown about by "software engineers" to make themselves look "professional"
07:59:53 <ciaranm> it doesn't really mean anything any more
08:00:37 <Gracenotes> I mean, a lot of terms fall into that category, it's called the enterprise pattern
08:01:06 <jmcarthur> ciaranm: i disagree. i would have agreed if you had said that software engineers tend to highlight patterns in order to make themselves look more competent, but patterns themselves are quite meaningful. they are just vocabulary
08:01:40 <ciaranm> jmcarthur: historically, yes. but the term is no longer used that way
08:01:41 <jmcarthur> i do dislike it when people repeatedly highlight various things as fitting into the Foo Design Pattern
08:01:44 <darkf> jmcarthur: it is a problem when they name things like `AbstractSingletonFactoryProxyBean` instead of naming them after what they actually do
08:01:52 <eikke> that's a sad thing, since IMHO patterns are an-sich 'a good thing': they provide a shared vocabulary
08:02:04 <Gracenotes> darkf: maybe that's an attempt to encode patterns in the language
08:02:05 <jmcarthur> darkf: actually, the bigger problem is that that *is* all those classes do :(
08:02:24 <ciaranm> AbstractSingletonFactoryProxyBean isn't really worse than ZygoHistoMorphicPreProMorphism, other than it being less useful
08:02:29 <jmcarthur> darkf: when half of your project is design pattern boilerplate, something is wrong
08:02:34 <darkf> jmcarthur: *shrug* - perhaps the language should have more useful (i.e. non-class) abstractions then :(
08:02:49 <geekosaur> exactly
08:02:52 <Gracenotes> it's saying that, with a bit of scaffolding, you can abstract over common relationships between objects in Java
08:03:14 <FreeFull> ciaranm: I never saw any Haskell source with a ZygoHistoMorphicPreProMorphism though that wasn't a joke
08:03:17 <Gracenotes> which is not possible in the language itself
08:03:17 <elliott> jmcarthur: -- in essence, a Newtype instance corresponds to an Iso in lens
08:03:25 <elliott> jmcarthur: and Wrapped supplants the class entirely
08:03:28 <jmcarthur> elliott: ah! yeah, that makes sense
08:04:05 <jmcarthur> yeah, Wrapped is the thing i'm not likely to use often, but Iso probably captures what i want
08:04:17 <jmcarthur> hmm
08:04:24 <jmcarthur> a pattern i do often:
08:04:31 <elliott> jmcarthur: personally, I dislike Wrapped because it restricts type-changing and doesn't compose
08:04:41 <elliott> but we're stuck with it.
08:04:57 <jmcarthur> inFoo = (Foo .) . (. unFoo); inFoo2 = (inFoo .) . (. unFoo); {- etc -}
08:05:01 <elliott> it used to be the case that we just had a bunch of explicit Isos instead and all the functions used those
08:05:05 * jmcarthur wonders how easy that is to abstract using Iso
08:05:10 <elliott> jmcarthur: inFoo = over _Foo
08:05:24 <jmcarthur> the inFoo2 is the thing i'm more curious about
08:05:30 <elliott> I can't parse what inFoo2 does from the definition, sorry. what is the type?
08:06:07 <jmcarthur> elliott: (FooInternals a -> FooInternals b -> FooInternals c) -> (Foo a -> Foo b -> Foo c)
08:06:19 <FreeFull> :t (Just .) . (. fromJust)
08:06:20 <lambdabot> (b1 -> b) -> Maybe b1 -> Maybe b
08:06:26 <elliott> jmcarthur: ah.
08:06:30 <Gracenotes> sounds very uplifting
08:06:32 <FreeFull> Isn't inFoo just fmap
08:06:36 <elliott> jmcarthur: that's tricky to do with a single Iso because of Haskell's annoying restrictions
08:06:40 <jmcarthur> FreeFull: only when we're talking about functors
08:06:44 <elliott> jmcarthur: you have to pass it twice
08:06:56 <elliott> if we had an "Iso o i" type thing instead of "Iso s t a b" it would work fine
08:07:04 <elliott> oh, I guess you could take a rank-2 input instead
08:07:07 <elliott> but we never do that.
08:07:10 <elliott> it composes badly
08:07:10 <jmcarthur> ew
08:07:19 <elliott> sorry :)
08:07:50 <Gracenotes> I don't really expect to read "but we're stuck with it" in the context of lens, but c'est la vie, I suppose
08:09:17 <jmcarthur> anyway, this newtype wrapping stuff gets annoying sometimes :)
08:09:25 <hpc> sometimes? ;)
08:09:31 <jmcarthur> i could TH it i guess
08:09:46 <elliott> Gracenotes: well, it's Haskell's fault.
08:09:58 <elliott> we have not yet infiltrated edwardk into the GHC core team yet
08:10:38 <Gracenotes> for the greater good
08:13:16 <jmcarthur> i wonder if this inFoo2 pattern is related to the idea of generalizing liftA2 in a lensy fashion
08:13:30 <elliott> what you essentially want is some kind of applicative notation for lifting, yes
08:13:31 <jmcarthur> i suppose it is
08:14:07 <jmcarthur> i've wanted that generalization for other purposes, too
08:14:58 <noteventime> Does there exist some kind of overview of the changes that will be made in Repa 4?
08:15:24 <jmcarthur> noteventime: the commit log? ;)
08:15:37 <noteventime> jmcarthur: I'm not sure I'd consider the commit log an overview
08:15:43 <jmcarthur> why not?
08:16:00 <jmcarthur> it's probably not even that many commit messages
08:16:00 <noteventime> To fine granularity?
08:16:14 <jmcarthur> i read commit logs in place of changelogs a lot. it is generally pleasant
08:16:38 <Gracenotes> is there some kind of rebasing involved?
08:16:58 <Gracenotes> or, summing together minute commits
08:17:15 <Gracenotes> I guess it depends on how many people are on a given project
08:17:19 <noteventime> jmcarthur: I guess it's worth a try at least, thanks for the suggestion
08:39:55 <elliott> omg, GHC binaries still require old GMP?
08:40:13 <eikke> elliott: yeah, pre-built GHC needs some rather old gmp
08:40:26 <eikke> libgmp.so.3.5.2
08:40:37 <elliott> sigh
08:40:47 <eikke> had to retrieve that from some old RPM on my F18 system
08:41:06 <eikke> due to legacy debian stuff
08:41:57 <monochrom> it is why I built 7.6.3 from ubuntu's 7.6.2
08:42:22 <hpc> i bootstrapped 7.4.1 that way
08:42:34 <monochrom> then I wanted to build 7.4.2 from 7.6.3, but it says, "your base is too new!"
08:42:34 <elliott> someone should run a Debian/Ubuntu repository with latest GHC and Haskell Platform binary packages
08:42:39 <elliott> I might even donate.
08:42:59 <monochrom> then I just gave up and symlinked gmp3 -> gmp10 :)
08:43:08 <eikke> elliott: that would *rock* (also to use on TravisCI etc)
08:43:16 <monochrom> then you could question my whole point of building 7.6.3 :)
08:43:18 <elliott> for now, I guess I will DoS my own IRC client by compiling GHC on my server
08:43:34 <Clint> elliott: like debian, for instance?
08:43:53 <elliott> Clint: sid doesn't have latest HP
08:43:57 <elliott> it has an RC version
08:44:19 <Clint> well, yes, but that's pretty close
08:44:27 <monochrom> IIRC there is no change between RC and released, source-wise
08:44:44 <Bor0> @src (3+)
08:44:44 <lambdabot> Source not found. Maybe you made a typo?
08:44:50 <Bor0> :t (3+)
08:44:51 <lambdabot> Num a => a -> a
08:44:57 <monochrom> there were maybe changes in mac installers, sure
08:45:48 <elliott> how many hours does compiling GHC take this century?
08:46:05 <monochrom> it was 1.5-2 hours recently for me
08:46:07 <hpc> it's not that bad
08:46:24 <monochrom> or 1-1.5, I forgot
08:46:25 <eikke> depends on the machine. 3h on my laptop, <1.5 when doing it on tmpfs on some server at work
08:48:11 <elliott> eikke: hm, doing it in tmpfs is clever
08:48:20 <typoclass> monochrom: would you be happy with "1.5 hours +/- 0.5"? ;-)
08:48:27 <monochrom> yes :)
08:48:28 <elliott> eikke: did you unpack the source to tmpfs or just run the build there?
08:48:31 <hpc> for compiling a compiler?
08:48:39 <hpc> how long does it take to build gcc?
08:48:47 <eikke> elliott: unpack to it, sadly enough. Didnt figure out how to do out-of-tree builds
08:48:57 <elliott> oh, I guess GHC might not support out of tree builds
08:49:15 <eikke> some people seem to use hardlinks for that kind of thing, but that wont work cross-FS
08:51:25 <elliott> eikke: http://hackage.haskell.org/trac/ghc/wiki/Building/Using seems to describe out of tree builds
08:51:44 <elliott> by way of symlinks :/
08:51:45 <Fuuzetsu> Is there a way to use ‘cabal fetch’ to just get the package I specify and don't even look at dependencies?
08:52:08 <typoclass> Fuuzetsu: you mean like "cabal unpack"?
08:52:56 <Fuuzetsu> typoclass: oh, that's actually exactly what I needed
08:52:59 <Fuuzetsu> thanks
08:53:03 * typoclass purrs
08:53:53 <elliott> wow, make -j8 and my IRC client still works
08:54:00 <elliott> the wonders of modern technology
08:54:02 <HugoDaniel> hi
08:54:16 <eikke> elliott: is it actually doing things in parallel?
08:55:10 <elliott> eikke: yes, that's the bit I'm not so sure of.
08:55:18 <elliott> eikke: in fact, are parallel builds even supported? perhaps I will break something
08:55:58 <eikke> I remember having issues with -j4
08:56:23 <elliott> The GHC build system works with make's -j flag, which spawns multiple compile processes in parallel. Even on a single processor machine it's usually worthwhile using at least make -j2, because the I/O will be overlapped with compute-intensive compilation. On a multicore machine, higher -j values will speed up the build even more.
08:56:31 <elliott> so, if it breaks, I can blame spj, not myself
08:56:43 <eikke> heh
08:57:26 <eikke> I thought autotools projects support out-of-tree builds by default, but I tried the traditional approach with ghc, and that failed
08:58:56 <elliott> I think GHC's build system does not use automake
08:59:21 <jmcarthur> i have in the past had issues with -j*, but those have since been fixed i guess, because i never ran into them again
08:59:29 <eikke> elliott: uses autoconf at least
08:59:34 <elliott> eikke: right.
08:59:41 <elliott> but automake is what you'd care about for make options
08:59:44 <eikke> but not automake appareantly
08:59:44 <typoclass> what does "out of tree" mean here? putting the intermediate files to some custom location, instead of /tmp or whatever the default is? i've heard the term for git repositories and stuff, but that's clearly not it
09:00:17 <Clint> typoclass: i think he means VPATH
09:00:22 <eikke> typoclass: have a build-dir outside a source-dir, so after configure/build nothing changed (or was added) in the source dir
09:00:24 <elliott> typoclass: tar xf src.tar.gz; mkdir build; cd build; ../src/configure && make
09:00:29 <eikke> indeed, VPATH
09:00:51 <eikke> it's pretty useful when having multiple configurations around
09:01:07 <typoclass> i see, thanks
09:01:13 <eikke> but requires some special care when creating build infra
09:06:44 <bonobo123> Hi all, some lens magic needed
09:07:19 <Fuuzetsu> We all need a little lens magic in our lives.
09:07:45 <bonobo123> I have a (p :: Prism' a b) and would like to have a (r :: Prism' c d). Fortunatelly I have functions (f :: a -> c) and (g :: b -> d). How to get from (Prism' a b) to (Prism' c d)?
09:08:01 <bonobo123> If Prisms were Isos I could use withIso and get it done. How to have something like withIso but for prism?
09:08:36 <bonobo123> Fuuzetsu: that is the magic that is currently needed :)
09:08:42 <elliott> bonobo123: you should not use withIso for that case
09:08:49 <elliott> or uh, hm
09:09:02 <elliott> I don't think your functions are enough...
09:11:37 <bonobo123> I'm trying to rewrite stack from here: http://hackage.haskell.org/packages/archive/JsonGrammar/0.3.4/doc/html/src/Data-Iso-Core.html#stack
09:11:47 <bonobo123> to use lens package
09:12:06 <elliott> I nominate edwardk to think about the {co,contra}variance here instead of me
09:12:23 <elliott> but I really don't think you can write the function given just what you stated you have
09:12:46 <bonobo123> the Iso there are partial in both ways, I need partiality in one way only
09:12:59 <bonobo123> so I thought about using prisms instead of isos
09:14:18 <edwardk> :t iso (undefined :: a -> c) (undefined :: b -> d)
09:14:19 <lambdabot> (Functor f, Profunctor p) => p a (f b) -> p s (f t)
09:14:29 <edwardk> compose that with your Prism
09:15:03 <bonobo123> hmm
09:16:43 <elliott> :t (undefined :: Prism a b) . iso (undefined :: a -> c) (undefined :: b -> d)
09:16:44 <lambdabot>     Expecting two more arguments to `Prism a b'
09:16:45 <lambdabot>     In an expression type signature: Prism a b
09:16:45 <lambdabot>     In the first argument of `(.)', namely `(undefined :: Prism a b)'
09:16:51 <elliott> :t (undefined :: Prism' a b) . iso (undefined :: a -> c) (undefined :: b -> d)
09:16:52 <lambdabot> (Applicative f, Choice p) => p a1 (f b) -> p a (f a)
09:17:03 <elliott> hmm
09:17:19 <Fuuzetsu> :t maybeToList
09:17:20 <lambdabot> Maybe a -> [a]
09:19:04 <bonobo123> so far I have this:
09:19:06 <bonobo123> stack is = withIso is (\f g -> iso (lift f) (lift g))
09:19:06 <bonobo123>   where
09:19:07 <bonobo123>     lift k (x :- t) = (:- t) <$> k x
09:19:24 <bonobo123> basically I'd like this to work not only on Iso but also on Prism
09:22:52 <elliott> bonobo123: generally, you shouldn't ever need to use withIso.
09:22:58 <elliott> it's an internal kinda thing.
09:23:29 <bonobo123> yes, I kind of felt that, but I have no idea how to do my thing without it
09:26:12 <bonobo123> now I have this:
09:26:23 <bonobo123> stack is = is . (iso lift lift)
09:26:23 <bonobo123>   where
09:26:24 <bonobo123>     lift k (x :- t) = (:- t) <$> k x
09:26:40 <bonobo123> stack
09:26:40 <bonobo123>   :: (Functor f, Functor f1, Functor f2, Profunctor p) =>
09:26:41 <bonobo123>      (p (t -> f1 a) (f ((t2 :- t3) -> f2 (a1 :- t3))) -> c)
09:26:42 <bonobo123>      -> p ((t :- t1) -> f1 (a :- t1)) (f (t2 -> f2 a1)) -> c
09:26:57 <bonobo123> How do I parse such types into something that has a name?
09:28:02 <elliott> (Functor f, Profunctor p) => p a (f b) -> p s (f t) is an Iso s t a b
09:29:02 <bonobo123> now I switched order of composition and go this:
09:29:17 <bonobo123> stack
09:29:18 <bonobo123>   :: (Functor f, Functor f1) =>
09:29:19 <bonobo123>      t
09:29:21 <bonobo123>      -> (t3 -> a1)
09:29:22 <bonobo123>      -> (t1 -> f a)
09:29:24 <bonobo123>      -> (a1 -> f1 (t1 :- t2))
09:29:25 <bonobo123>      -> (t3 :- t4)
09:29:25 <bonobo123>      -> f1 (f (a :- t2) :- t4)
09:29:37 <bonobo123> double-functor?
09:30:27 <elliott> I have no idea what's going on there. it looks wrong.
09:30:33 <elliott> btw, consider using
09:30:34 <elliott> @hpaste
09:30:34 <lambdabot> Haskell pastebin: http://hpaste.org/
09:30:35 <elliott> for long pastes
10:04:16 <Fuuzetsu> Does anyone have any deeper knowledge on why do Haddock module headers go in order? There's an in-source reason (which I can probably remove in a bit) but I'm wondering on what the initial decision for it might have been.
10:04:43 <Fuuzetsu> It was probably just easier at the time considering it hasn't been touched since 2008…
10:05:37 <elliott> Fuuzetsu: http://stackoverflow.com/questions/9012640/how-are-the-haddock-module-fields-portability-stability-and-maintainer-used
10:06:05 <elliott> tl;dr nobody knows
10:09:23 <Fuuzetsu> Right. It does contain such quality code like http://hpaste.org/89615 ;)
10:10:15 <monochrom> someone needs a monad for that :)
10:12:29 <Fuuzetsu> I just like to think that such convenient things didn't exist back in 2008 so it couldn't be helped. Yeah.
10:15:30 <byorgey> ziman: yes, I think diagrams should work very nicely for that
10:15:57 <byorgey> ziman: diagrams even has explicit support for constructing animations
10:16:32 <byorgey> though right now the only backend support is by generating a bunch of frames as separate files
10:16:40 <byorgey> but at least you get to think about it at a higher level when constructing it.
10:20:11 <Ein_Leo> Hi. It is about regular expressions in Haskell. Do you know whether there is "splitRegex" or something similar in Text.Regex.Posix or Text.Regex.Base?
10:25:08 <ziman> yes, it's cool
10:29:50 <ziman> maybe it could use some canned high-level primitives like arrows and other stuff often occurring in diagrams so that users can use them right away without tinkering with the arrowheads -- if *some* arrows is all they need
10:30:36 <geekosaur> Ein_Leo, http://hackage.haskell.org/package/regexpr maybe? we don't normally use regexes because parsers are easy to write in Haskell
10:34:10 * hackagebot bencoding 0.1.0.0 - A library for encoding and decoding of BEncode data.  http://hackage.haskell.org/package/bencoding-0.1.0.0 (SamTruzjan)
10:37:34 <byorgey> ziman: yes, I am currently working on adding arrows
10:37:50 <byorgey> I completely agree =)
10:39:34 <Ein_Leo> geekosaur, thank you for your answer. I didnt thought about Parsers. ( Trying Parsec now. )
10:43:30 <typoclass> Ein_Leo: i usually end up doing a bunch of 'lines', 'words', 'split' and so on. (see 'split' package. it's in the platform.) i have some kind of rare parsec blindness =)
10:44:19 <ziman> oh cool, I expected the (completely reasonable) "patches are welcome" :)
10:51:00 <Ein_Leo> typoclass, Never used split package before. Thank you.
10:53:20 <byorgey> ziman: =)
10:54:11 * hackagebot rainbow 0.4.0.0 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.4.0.0 (OmariNorman)
10:56:27 <savask> Hello. I have written a Karatsuba algorithm to multiply numbers, which are represented as lists of Word32. But it turned out "fast" Karatsuba algo is A LOT slower than straightforward school multiplication, what can be a reason? Here is my code: http://hpaste.org/89617
10:58:30 <yrlnry> Karatsuba multiplication is only faster than regular algorithm in the limit as the size of the input numbers becomes large.
10:58:42 <yrlnry> That is why we do not use Karatsuba algorithm.
11:00:15 <savask> yrlnry: Yes, but it's so much slower that I doubt it will multiply anything in a day -_-
11:00:27 <et09> is there a decent workable haskell web browser
11:00:30 <savask> For example I could wait till it will multiply two 300-digit numbers.
11:00:37 <savask> *couldn't
11:01:00 <Clint> et09: depends what you mean by those words
11:01:35 <et09> ready for most sites
11:02:25 <Clint> et09: then hbro
11:03:43 <et09> trying
11:04:11 * hackagebot inject 0.1.0 - A minimalistic template engine  http://hackage.haskell.org/package/inject-0.1.0 (SimonHengel)
11:04:16 <applicatiative> et09: I browse with pandoc -r html -w markdown --columns=50 http://whatever.org
11:04:42 <applicatiative> the there's no images or anything! awesome.
11:05:42 <applicatiative> sometimes: pandoc -r html -w markdown --columns=50 http://whatever.org | myeditor
11:06:20 <et09> is that better than links and w3m
11:07:52 <Fuuzetsu> applicatiative: that's genius
11:08:27 * et09 installs
11:09:07 <savask> appliciative: Can you, please, past an example of what is a result of that command?
11:09:18 <applicatiative> i'm just kidding, it doesn't count as 'browsing' really, but I do it all the time.
11:09:24 <et09> does it work with css
11:09:26 <et09> at all
11:09:49 <applicatiative> of course not, it cuts out everthing but the thoughts.
11:11:37 <et09> heh
11:12:04 <applicatiative> savask:  http://hpaste.org/89618
11:12:33 <et09> but the links don't work, do they?
11:12:48 <applicatiative> right no.
11:12:50 <et09> seems like links -G does the same thing better then?
11:13:03 <applicatiative> i think if i used --reference-links, they would appear at the end at least.
11:13:11 <applicatiative> not sure what the flags are these days.
11:13:18 <savask> applicatiative: Thanks. Not that bad as I thought :O
11:13:26 <et09> totally unsatisfied with all the browsers out there ... hbro looks promising
11:15:00 <applicatiative> savask: it would be pretty simple to make an executable that improves on it; it would still be more like 'readability' than like a browser
11:15:49 <et09> can't believe how many web devs use flash and images for everything
11:16:08 <et09> not to mention a pound and a half of javascript on each page...firefox bloating up to 500mb ram
11:17:29 <savask> appliciative: Well, it would be a browser in the sense that you can only jump from one web page to another :-P
11:19:31 <augur> well, thats interesting. im hitting stackspace limits at 8.3 megs. i should figure out where this is coming from. D:
11:21:12 <applicatiative> savask if you have pandoc try something like pandoc -r html -w plain --columns=60 http://www.haskellforall.com/2013/06/pipes-parse-100-pushback-delimited.html | less  I do that frequently with an alias p50 http://www...
11:21:34 <augur> oh, probably this foldl that should be a foldl'
11:22:05 <savask> applicatiative: No, I don't have it that's why I have asked you to paste the ouput.
11:22:19 <augur> nope, still overflowing :(
11:24:56 <applicatiative> savask: what a haskeller without a copy of pandoc?!  It only takes all afternoon to build ...
11:24:59 <applicatiative> not true that last
11:25:27 <et09> ugh hbro won't build
11:25:46 <savask> applicatiative: But I'm not a web haskeller... Or pandoc has other uses?
11:26:25 <simukis_> savask: Pandoc is for all your document conversion needs.
11:26:38 <hpc> just noticed i don't have pandoc
11:26:39 <applicatiative> oh yeah, its not particularly web oriented. its a writing tool, I guess; that's my principal use for it
11:26:43 * hpc installs
11:26:45 <savask> simukis_: Anything to anything o_O
11:26:58 <applicatiative> i write markdown, for example, and print pdfs via latex
11:27:20 <applicatiative> or write markdown and send docx files to my friends
11:27:29 <savask> Oh, fancy. Does it transfer files to a kind of intermediate language?
11:27:37 <applicatiative> or write markdown and make the cretinous html
11:27:40 <applicatiative> savask: language??
11:27:48 <applicatiative> it parses them into a Haskell type, yes
11:28:04 <applicatiative> there is an internal representation of the type Document
11:28:13 <savask> Yes, I have meant a "system of expressing something" by language :-P
11:28:24 <applicatiative> built from the elements Block and Line if I remember
11:28:44 <applicatiative> savask: yes, i wasnt seriously rejecting your formulation
11:29:37 <applicatiative> here is the definition of a document (Pandoc) and ancillary types https://raw.github.com/jgm/pandoc-types/master/Text/Pandoc/Definition.hs
11:30:16 <savask> Ah, it's like with those pretty-printer things.
11:30:17 <applicatiative> the idea is that it only registers 'semantic' content, which turns out to be a rather contentious matter, judging from the controversies on the mailing list
11:30:50 <applicatiative> savask: right, there is a bunch of parsers of formats and a bunch of writers, each if you like a separate 'pretty printer' for the Pandoc type.
11:31:06 <savask> applicatiative: Does that mean my converted document won't look exactly like original one?
11:31:19 <applicatiative> savask: indeed it does
11:31:51 <applicatiative> you have to style the document if its html say, by adding css and so on
11:32:06 <applicatiative> look at the 'conversions' in the image on http://johnmacfarlane.net/pandoc/
11:32:35 <applicatiative> the standard purpose is that you write in the ones on the left and output epub or whatever
11:32:54 <savask> Ah
11:32:57 <applicatiative> the conversion I make most frequently is markdown->markdown since I use it to tidy inside my editor...
11:33:02 <savask> Like a latex-compiler (or how is it called)
11:33:38 <applicatiative> latex as an 'input' format is a little restricted. latex math can be written inside markdown files, or rst or whatever
11:34:13 * hackagebot krpc 0.1.0.0 - KRPC remote procedure call protocol implementation.  http://hackage.haskell.org/package/krpc-0.1.0.0 (SamTruzjan)
11:35:21 <savask> Well, all that is pretty fancy, but (un)fortunately I don't need to convert things really much.
11:35:50 <savask> Maybe I should find something like on-line pandoc or even install it for a rare case...
11:36:06 <applicatiative> it isn't a question of 'converting things'. it's basically a writer's tool.  you write in a sensible method like markdown or rst and end up with html/latex/pdf/epub
11:36:16 <applicatiative> oh and the dread docx
11:36:19 <savask> "Swiss-army knife" analogy on their site is pretty attractive ;-P
11:36:20 <applicatiative> and slides
11:36:29 <applicatiative> of various types.
11:37:10 <savask> I see. You don't need to use many programs or learn different formats, that's a good idea.
11:37:27 <applicatiative> its really for writing; you devote yourself to one of the input formats as your preferred method of writing; the fancy extended markdown is the characteristic one; then you are writing in a file-format-independent way
11:38:13 <applicatiative> there is a special syntax for slides, which can then give you beamer or one of these html slide things
11:38:56 <applicatiative> it isn't to every taste, this sort of procedure
11:40:25 <applicatiative> there is a flag now for the moronic github markdown, so your readme.md will be legible
11:40:33 <savask> applicatiative: Wait a minute, you have said that you're supposed to write with languages on the left and convert them to things on the right. But can you do the opposite?
11:41:18 <applicatiative> everything on the left is on the right, but if it's only on the right, you can't 'read it' , no one has written a reader for that format
11:41:31 <applicatiative> which may after all not make sense, if its eg pdf or docx
11:41:40 <savask> Ah, html is on the left
11:42:02 <applicatiative> savask: right that reader I was using to get webpages and make them plain text
11:42:03 <savask> So that's how your converter works.
11:42:19 <applicatiative> -r html -w markdown , or -f html -t markdown
11:42:25 <applicatiative> yes
11:42:48 <Fuuzetsu> What's the best way to dump out a data structure at runtime without having to write Show for any type it's composed of, ever?
11:43:01 <Fuuzetsu> I don't care much if it crashes afterwards but it would be nice if it wouldn't
11:43:15 <applicatiative> write Binary for all types its composed of?
11:44:13 * hackagebot contravariant 0.4.1 - Contravariant functors  http://hackage.haskell.org/package/contravariant-0.4.1 (EdwardKmett)
11:44:17 <Fuuzetsu> I don't think that's what I'm looking for.
11:44:22 <Fuuzetsu> This is for debugging.
11:44:52 <savask> But if you want to output something, you have to make show instances for that -_-
11:45:02 <JoeyA> Fuuzetsu: what's so hard about putting "deriving Show" on all your datatypes?
11:45:03 <applicatiative> hm the debugger in ghci has a representation
11:45:05 <solirc> Fuuzetsu: I usually just standalone derive show for everything..
11:46:01 <Fuuzetsu> JoeyA: There might be a lot of them~
11:46:30 <savask> Fuuzetsu: Maybe you can just skip them? Or you need to print them for debugging too?
11:48:31 <JoeyA> solirc: cool, didn't know about StandaloneDeriving, thanks!
11:48:36 <Fuuzetsu> I can't ‘deriving instance Show Name’ because it doesn't export all its data constructors. Further ideas?
11:49:35 <savask> But you can't print it then.
11:49:43 <jnerula> Can anyone tell me why http://hpaste.org/89620 is still showing me NUL chars?
11:51:09 <shachaf> I bet BLC stands for Data.ByteString.Lazy.Char8. :-(
11:51:11 <jnerula> :t getLazyByteStringNul
11:51:12 <lambdabot> Not in scope: `getLazyByteStringNul'
11:51:21 <jnerula> I am an idiot never mind
11:52:04 <jnerula> shachaf: Does that mean I can't compare like that? Why not?
11:52:04 <shachaf> Hm?
11:52:23 <shachaf> jnerula: .Char8 is an evil module that breaks for almost all characters.
11:52:34 <shachaf> (In particular there are just 128 characters is doesn't break on.)
11:52:54 <jnerula> shachaf: Oh. Well that kinda sucks.
11:53:00 <shachaf> Yep.
11:53:08 <shachaf> You should use something with a name like encodeUtf8
11:54:43 <shachaf> Alternatively you should use a type likE Data.Text.
11:54:47 <aristid> shachaf: Char8 also works for latin-1 encoded text
11:55:01 <aristid> which is quite the important encoding if you're from western europe! :)
11:55:04 <shachaf> No, it breaks.
11:55:13 <aristid> shachaf: how so?
11:55:38 <shachaf> For example it encodes the codepoint 225 as the byte 225.
11:57:08 <aristid> shachaf: which is correct for latin-1.
11:57:26 <aristid> the first 256 codepoints of unicode coincide with latin-1.
11:57:41 <Clint> that is demonstrably false
11:57:44 <shachaf> Latin-1 is not a correct encoding.
11:57:57 <aristid> Clint: ?
11:59:36 <jmcarthur> roconnor: question about colour: in the documentation, it says that if you are using sRGB surfaces with OpenGL then you should use Data.Colour.SRGB.Linear, but if i understand what Data.Colour.SRGB.Linear.toRGB does, it outputs *linear* color data, which is not what glTexImage expects. am i misunderstanding something?
12:00:05 <aristid> Clint: how is it demonstrably false?
12:00:44 <jmcarthur> in any case, it doesn't directly affect me, since i'm using colour to generate texture data, but it may still indicate that i misunderstand something about colour
12:00:55 <jmcarthur> *since i'm *not* using it generate texture data
12:01:23 <aristid> shachaf: ISO 8859-1, or as i colloquially like to call it, "Latin-1" is very much a valid encoding.
12:01:25 <Clint> aristid: latin-1 c0 is À
12:02:15 <aristid> Clint: unicode U+00C0 is also À
12:02:15 <shachaf> aristid: Not very.
12:02:24 <aristid> shachaf: what makes it not one?
12:02:48 <shachaf> Well, it's certainly not an encoding of Char in Haskell.
12:02:58 <shachaf> It is also not morally valid. It's worse than ASCII.
12:03:18 <Clint> aristid: er, yes, nevermind
12:03:23 <aristid> it's a character encoding. just because it can't encode all of unicode doesn't make it a non-encoding
12:03:38 <pikhq> shachaf: ISO 8859-1 is quite a valid encoding.
12:03:48 <pikhq> Though I prefer to call it UCS-1.
12:04:14 * hackagebot jmacro 0.6.8 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.6.8 (GershomBazerman)
12:04:23 <aristid> Clint: because i expected you or shachaf to be right on some weird technicality i double-checked.
12:04:26 <aristid> you weren't
12:04:39 <aristid> yet i don't expect that shachaf will accept this.
12:05:10 <applicatiative> most of the unicode 'codepoints' are garbage; i approve of inducing uncaught exceptions, eg for the beer-mug
12:05:45 <aristid> applicatiative: i sure hope you don't have such dangerous feelings for the important snowman codepoint.
12:06:20 <applicatiative> oh the snowman is difficult...
12:06:30 <shanse> what about the pile of poop?
12:06:39 <applicatiative> god no shanse
12:06:44 <applicatiative> what next
12:07:22 <shanse> Apple has all kinds of weird »emoji«
12:07:44 <applicatiative> oh theres and html 'entity' for the PILE OF POO
12:08:03 <applicatiative> lets get rid of the html people and the unicode people together
12:08:20 <hpc> what would we replace them with? pdf people?
12:08:21 <hpc> :P
12:08:25 <applicatiative> ha
12:08:34 <Botje_> buffer overflows for all!
12:08:58 <hpc> or markdown
12:09:02 <hpc> ambiguous grammar for all!
12:09:16 <applicatiative> well, it can be made unambiguous.
12:09:26 <nooodl> 1F365	FISH CAKE WITH SWIRL DESIGN
12:09:28 <applicatiative> there are grammars
12:09:41 <applicatiative> of course, FISH CAKE WITH SWIRL DESIGN
12:09:48 <applicatiative> never mind that ancient greek doesnt work...
12:09:50 <Hafydd> Hahah.
12:10:00 <mauke> don't make me paste the CAT FACE ones
12:10:09 <jwa> I'm facing issues trying to install haskell platform 2013.2, anyone hint me in the right direction? Configuring the HUnit-1.2.5.2 package failed
12:10:18 <jwa> make output here: http://hpaste.org/89622
12:10:37 <arkeet> > filter (\x -> "fish" `isInfixOf` (map toLower x)) cake
12:10:38 <lambdabot>   ["Fish shaped crackers.","Fish shaped candies.","Fish shaped solid waste.",...
12:10:58 <nooodl> i also like HAPPY PERSON RAISING ONE HAND
12:12:06 <applicatiative> hm, jwa maybe you should get rid of the (platform) libraries you installed before attempting to install them in the platform , still studying
12:12:40 <yrlnry> > cake
12:12:42 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
12:12:45 <yrlnry> excellent.
12:12:56 <hpc> lambdabot needs the fact sphere lines, too
12:13:17 <Hafydd> > length cake
12:13:19 <lambdabot>   42
12:14:01 <mauke> > map head cake
12:14:04 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
12:14:05 <lillian_baxter> My BF is really good with Blender. I like programming in Haskell. We want to make a simple cell-shaded space-combat game. What should I start researching/what would be a good engine/library to use?
12:14:26 <Hafydd> Hahaah.
12:14:57 <applicatiative> hah
12:15:11 <Hafydd> > map last cake
12:15:12 <lambdabot>   "........:................'................"
12:15:26 <eikke> is there any sensible way to know which exceptions some IO action might throw?
12:15:30 <Hafydd> > map (last . init) cake
12:15:32 <lambdabot>   "xglsserrssseteethesnssssr.dbbbebberrrrnsse"
12:15:40 <nooodl> > [x | x <- cake, last x /= '.']
12:15:42 <lambdabot>   ["Don't forget garnishes such as:","An entry called 'how to kill someone wi...
12:15:53 <jwa> applicatiative: I removed all packages that have been installed by the system, still the same output (apart from Found: None. for existing packages)
12:16:13 <applicatiative> does ghc-pkg check look good jwa
12:16:17 <jwa> by system i mean package manager, archlinux' pacman in this case
12:16:38 <jwa> applicatiative: returns with status 2, no output
12:16:58 <applicatiative> ghc-pkg list ... does that show anything?
12:17:39 <Taneb> lillian_baxter, Blender's game engine connects to Python, doesn't it? Maybe have a look at MissingPy?
12:17:40 <applicatiative> jwa: you've seen monochroms' fairly well vetted http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
12:17:47 <Taneb> @hackage MissingPy lillian_baxter
12:17:47 <lambdabot> http://hackage.haskell.org/package/MissingPy lillian_baxter
12:18:06 <Taneb> No, that won't work, never mind
12:18:13 <JoeyA> eikke: IO actions aren't the only things that throw exceptions.
12:18:20 <eikke> JoeyA: I know
12:18:21 <JoeyA> Evaluating any value can result in an exception.
12:18:59 <lillian_baxter> What should I use for the actual game engine?
12:19:01 <JoeyA> I don't know the answer, other than to look at the source code of the modules you're using.
12:19:26 <eikke> JoeyA: that kinda sucks if the actions you're calling call lots of things themselves :)
12:19:29 <JoeyA> It would be nice if there were a tool to find what exceptions an action might throw.
12:19:42 <mauke> not evaluating any value can result in an exception
12:20:01 <JoeyA> Ah, true.  Async exceptions.
12:20:03 <applicatiative> jwa this is a little heretical, but I prefer just locallying installing ghc & co rather than using pacman & co
12:20:06 <JoeyA> Stack overflows
12:20:14 <mauke> SIGINT
12:20:33 * applicatiative cant remember how to make a stack overflow
12:20:34 <eikke> well, yes, that's the thing
12:20:46 <JoeyA> applicatiative: sum [1..1000000]
12:20:46 <eikke> in some code, I want to catch socket connection failures, but not sigint etc
12:20:50 <jwa> applicatiative: I only installed GHC via pacman in this case
12:20:57 <JoeyA> Or foldl (+) [1..1000000] for older versions of GHC
12:21:07 <JoeyA> May need more zeros.
12:21:11 <applicatiative> jwa, ghc-pkg is in path too?
12:21:14 <JoeyA> And won't crash in GHCi, I don't think.
12:21:26 <applicatiative> does ghc-pkg show some base libraries, like bytestring-0.10
12:21:33 <JoeyA> eikke: what OS?
12:21:40 <eikke> linux, in this case
12:21:40 <applicatiative> jwa, just reflecting on your ghc as a preliminary
12:22:00 <jwa> applicatiative: yes it is, configure output shows that all every dependency is met
12:22:04 <eikke> I know how to do these things at C & syscall level, but kinda new to Haskell when it comes to exceptions
12:22:13 <applicatiative> jwa rather, does ' ghc-pkg list ' show them
12:22:15 <applicatiative> oh ok
12:22:25 <jwa> http://hpaste.org/89624
12:22:36 <JoeyA> eikke: I believe you want to catch an IOError.
12:22:43 <JoeyA> And check its status with http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO-Error.html
12:22:59 <mauke> @hoogle catchIOError
12:22:59 <lambdabot> No results found
12:23:00 <JoeyA> Though I'm not seeing anything there about connection errors.
12:23:04 <mauke> lambdabot: ಠ_ಠ
12:23:28 <applicatiative> jwa yes that looks promising.
12:24:12 <JoeyA> eikke: what errno value would you be looking for in C?
12:24:21 <applicatiative> jwa could it be relevant if the default prefix for ./configure is /usr/local but ghc & co are in /usr/ ?
12:24:45 <eikke> ECONNREFUSED
12:24:45 <applicatiative> maybe ./configure --prefix=/usr
12:24:59 * applicatiative steers clear of /usr but ARCH KNOWS
12:25:09 <JoeyA> And not ENETUNREACH?
12:25:12 <jwa> applicatiative: they moved all binaries to /usr/bin now
12:25:23 <mauke> eikke: that's a "does not exist" error
12:25:26 <eikke> JoeyA: I guess there's a couple of them
12:25:37 <jmcarthur> lillian_baxter: the truth is haskell's game libs are kind of embarassing right now
12:25:41 <mauke> so is ENETUNREACH
12:25:42 <JoeyA> eikke: You could just blanket catch all IOError exceptions.
12:25:53 <jmcarthur> lillian_baxter: but if you feel adventurous anyway, feel free to join #haskell-game
12:25:58 <eikke> mauke: how am I supposed to know?
12:26:09 <applicatiative> jwa, oh that idea is looking promising; make is trying to put the platform libs in /usr/local
12:26:14 <eikke> JoeyA: wouldn't that also catch sigint ?
12:26:20 <applicatiative> but the ghc boot libs are in /usr
12:26:33 <jmcarthur> lillian_baxter: but we don't really have any super nice engines right now. some engines exist in various states
12:26:38 <mauke> eikke: I imported Foreign.C.Error and ran 'errnoToIOError "ohai" eNETUNREACH Nothing Nothing' in ghci
12:26:47 <JoeyA> eikke: No, that's UserInterrupt, which is an AsyncException
12:26:54 <applicatiative> jwa thus the error : Setup: Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with
12:26:57 <applicatiative> Cabal. Use the flag --package-db to specify a package database (it can be used
12:26:59 <applicatiative> multiple times).
12:27:18 <eikke> mauke: nifty, though that doesnt seem a very obvious/productive approach :)
12:27:39 <yitz> i'll agree with applicatiative here.
12:27:41 <mauke> eikke: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Foreign-C-Error.html#errnoToIOError
12:27:57 <JoeyA> For the sake of portability, you might not want to look at the precise error code when handling IOErrors in networking code.
12:28:16 <jmcarthur> lillian_baxter: this is... okay :) http://hackage.haskell.org/package/FunGEn
12:28:28 <JoeyA> On Windows, the network package's send and recv don't translate Winsock exceptions properly at the moment.
12:28:40 <jmcarthur> terrible documentation though
12:28:45 <JoeyA> They throw IOError with some garbage error value.
12:28:49 <yitz> it's nice that thanks to joachim's great work, any newcomer who sees haskell in the package mgr on an apt platform can install it and it will work. but...
12:28:59 <jwa> applicatiative: now I'm confused, I have multiple ghc directories on my system...
12:29:03 <eikke> mauke: ow, thanks
12:29:04 <jmcarthur> lillian_baxter: see http://hackage.haskell.org/packages/archive/pkg-list.html#cat:game for some stuff others have done
12:29:12 <yitz> for serious haskell users, it's hard to imagine not installing what you need directly and using cabal.
12:29:30 <lillian_baxter> jmcarthur: I'm just wanting to know which of these will work with models Blender can export.
12:29:36 <jmcarthur> ah
12:29:46 <lillian_baxter> I'm having trouble Googling that.
12:29:47 <jmcarthur> i have no good answer
12:29:54 <applicatiative> jwa, where?
12:30:08 <jmcarthur> you might have to write a binding or something yourself
12:30:19 <applicatiative> in usr you have the main ghc ghc-pkg etc. in bin; is anything in /usr/local yet jwa ?
12:30:31 <jwa> applicatiative: /usr/lib/{ghc-7.4.2,ghc-7.6.3}
12:30:39 <applicatiative> and in /usr/lib you have the ghc boot libraries or whateer they're called
12:30:55 <applicatiative> jwa: oh , can you get pacman to scrap ghc-7.4
12:31:20 <jwa> it wasn't registered with pacman, I just removed it
12:31:52 <applicatiative> ghc -V and ghc-pkg -V show version 7.6?
12:31:55 <jwa> I'm still not sure if you mean the binary `which ghc` or the lib directory
12:32:00 <jwa> applicatiative: affirmative
12:32:53 <applicatiative> ok, this may not be the best idea, but i think there will be no problem with ./configure --prefix=/usr inside the platform tarball thingy
12:32:56 <applicatiative> ex-tarball
12:34:00 <jwa> applicatiative: tried it with /usr, /usr/lib to no avail
12:34:17 <applicatiative> in general the haskell platform installers for the os's of the hoi polloi put the platform libs in with the boot libs, so I have one local ~/.cabal and a superordinate other package directory
12:34:26 <applicatiative> damn
12:34:55 <applicatiative> i don't know what to say, except I always have good luck following something like monochrom's plan
12:35:39 <applicatiative> I put ghc in a special ~/h directory, and would direct the platform source to the same. then cabal install for standard things goes in ~/.cabal
12:35:52 <applicatiative> and i can delete everything instantly and never use sudo
12:36:11 <applicatiative> permissions cant be a part of this can they, by the way? doesn't look like it
12:36:39 <CODEtaku> So I want to work on Project Rosalind (bioinformatics) problems to learn Haskell.  My first thought was make a DNAbase data type which was A | C | G | T, but I need an RNA type as well which uses A|C|G|U... declaring both nets me an error about re-defining A,C,G... what would be a better way to structure it?
12:37:00 <applicatiative> the generic-linux bindists on http://www.haskell.org/ghc/download_ghc_7_6_3 are really a picnic
12:37:05 <jwa> applicatiative: no, main failure is still the GHC_PACKAGE_PATH mystery
12:37:34 <CODEtaku> if I make a nucleotide type that can be all 5, how could I limit DNA to only be legal with 4 of the 5 bases?
12:37:55 <applicatiative> jwa there are people who would see immediately what is wrong, alas
12:38:07 <roconnor> jmcarthur: they way openGL handles colour values is largely inconsistent.  What I was writing about was setting vertex colours for shading rather than for texture mapping.  I think you are right regarding texture mapping expecting sRGB.
12:38:17 <jmcarthur> roconnor: ah!
12:38:25 <jmcarthur> roconnor: that makes sense
12:38:42 <jmcarthur> roconnor: and in fact, so much sense that that is what i was going to do without even thinking about it
12:38:47 <roconnor> maybe no one does plain shading anymore
12:38:48 <applicatiative> i think yitz was concurring that scrapping arch and doing some local install of ghc and haskell platform and so on, is not so bad
12:38:51 <jmcarthur> or realizing that's what you were talking about
12:39:03 <applicatiative> jwa^^
12:39:29 <jwa> applicatiative: right, I'll try that
12:39:41 <jmcarthur> roconnor: thanks
12:40:17 <roconnor> maxBound :: Word64 is big
12:40:33 <hpc> CODEtaku: i would do something like
12:40:37 <hpc> data DNA
12:40:43 <hpc> data RNA
12:41:11 <hpc> data BasePair a where G :: BasePair a; ... U :: BasePair RNA; T :: BasePair DNA
12:41:21 <hpc> i think i got that right
12:41:40 <bobry> Can somebody explain this Integer-Int behaviour to me? http://paste.in.ua/8351/
12:41:52 <jwa> applicatiative: guess he's right: "You must install GHC yourself to build Haskell Platform from source."
12:42:02 <CODEtaku> thanks hpc, that is some syntax I entirely do not understand, but now at least I know what to look for ;)
12:42:29 <hpc> CODEtaku: the first two are EmptyDataDecl and the third is GADT
12:42:34 <harrison> if {c,c++,d,haskell,....} is as good as oberon, where then is the realtime fractal-voxel raytracer coded in that language?
12:42:34 <hpc> turn on both those extensions
12:42:37 <harrison> QED
12:43:07 <jmcarthur> wow, i only just now realized that plusPtr allows the resulting pointer to have a different type from the original. that's awesome
12:43:11 <mauke> harrison: you seem to be in the wrong channel
12:43:25 <jmcarthur> my Storable instances are going to be so much simpler now!
12:44:06 <mauke> castPtr = (`plusPtr` 0) ?
12:44:06 <harrison> No, I am right and everyone else is wrong. But thank you for your concern.
12:44:20 --- mode: ChanServ set +o mauke
12:44:20 --- mode: mauke set +b $a:harrisonpartch
12:44:39 <jmcarthur> mauke: indeed
12:44:48 <hodapp> WTF is a "fractal-voxel raytracer"?
12:45:04 <hodapp> this sounds something like what is described in the Gigavoxels paper
12:45:36 <jmcarthur> heh, now i want an indexed monad for tracking the pointer
12:46:11 <jmcarthur> then i can just say peek a few times and be done, and likewise for poke
12:46:20 --- mode: mauke set -o mauke
12:47:33 <schoppenhauer> are there functions equivalent to take and drop, which return a maybe-object if the list is not long enough?
12:47:51 <hpc> > drop 5000 [1..10]
12:47:52 <lambdabot>   []
12:48:07 <schoppenhauer> > take 1000 [1]
12:48:08 <lambdabot>   [1]
12:48:24 <schoppenhauer> hpc: see my problem?
12:48:42 <jmcarthur> you could just check the length after
12:48:42 <hpc> schoppenhauer: drop doesn't need it, the empty list is its own Nothing
12:48:54 <hpc> for take, just do length
12:49:04 <hpc> it should fuse into a fast single traversal
12:49:14 <schoppenhauer> "length" makes the code linearly worse, hpc, jmcarthur
12:49:18 <jmcarthur> hpc: not if the resulting list is used after
12:49:36 <jmcarthur> schoppenhauer: you can't get out of it
12:49:56 <jmcarthur> schoppenhauer: the resulting function is no longer lazy. it has to store a result and traverse it once before i can return anything
12:49:59 <schoppenhauer> jmcarthur: well, I can write my own function. but having one predefined woould be better.
12:50:28 <schoppenhauer> jmcarthur: the problem is that I have to do something *very* fast.
12:50:28 <JoeyA> Now for drop, if it returns an empty list, you don't know how many items were dropped, so there's an argument there.
12:50:57 <schoppenhauer> jmcarthur: using such a function is my "last resort" befor using an array.
12:51:08 <JoeyA> schoppenhauer: Could you use Vector instead?
12:51:13 <jmcarthur> JoeyA: yeah, for drop this can be done without hurting anything
12:51:32 <jmcarthur> schoppenhauer: as JoeyA suggests, if you use arrays then you don't have to do any walking at all
12:51:48 <schoppenhauer> jmcarthur: but they are not ... functional.
12:52:03 <schoppenhauer> jmcarthur: I need a limited backbuffer in a sequence I build uo
12:52:17 <schoppenhauer> jmcarthur: *up. so it would be a ringbuffer or something, probably.
12:52:43 <schoppenhauer> jmcarthur: which is ... inherently imperative. I could squeeze it into haskell, but I do not really want to.
12:54:31 <jmcarthur> schoppenhauer: you can use vectors and such in a functional way
12:54:54 <jmcarthur> schoppenhauer: if you are doing something that you truly believe is inherently imperative then there is no better way to go than to write imperative code in haskell. this is not so bad
12:55:12 <jmcarthur> haskell is very good at dealing with imperative code, actually
12:55:35 <schoppenhauer> the problem is, I would have to wrap all my nice functions in monads.
12:56:00 <JoeyA> As long as you don't struggle with an imperative problem trying to make it functional, rather than just getting the job done.
12:56:43 <schoppenhauer> JoeyA: well, i do not have the aim of "getting something done", at least not in the way usual software developers would use that term.
12:57:04 <JoeyA> So, research?
12:57:08 <schoppenhauer> yesp
12:57:36 <schoppenhauer> I actually do not even like haskell :3
12:57:47 <schoppenhauer> but it has some properties I need.
12:58:23 <schoppenhauer> (No offence, it is a matter of taste, and I come from the lisp world)
13:00:25 <sal23> I will appreciate some help with resolving the type checking issue in this code: http://hpaste.org/89625
13:02:00 <schoppenhauer> oh god.
13:02:01 <hodapp> we got ourselves a LISPER!
13:02:23 <schoppenhauer> con grats
13:02:28 <jmcarthur> schoppenhauer: monads are a means to an end. you have to make some judgement calls about whether they are really the best means to that end, sometimes
13:02:54 <hpc> if edwardk is to be believed, comonads are the means to that end :P
13:03:03 <hodapp> jmcarthur: in Haskell, what besides a monad would be used for imperative operations?
13:03:11 <schoppenhauer> if you can't make it good, make it co
13:03:21 <jmcarthur> hodapp: monads are just a common language for talking about effects, which imperative code happens to fit into
13:03:28 <jmcarthur> hodapp: IO happens to be a monad
13:03:44 <applicatiative> we love lispers
13:04:03 <jmcarthur> hodapp: but that doesn't mean every imperative thing in the world has to be thought of in terms of monads. if that were true, we wouldn't be using declarative languages at all, because we wouldn't be able to write compilers for them or something
13:04:20 <schoppenhauer> jmcarthur: actually, monads are usable for many things, and are a nice abstraction of "real" things into formal mathematics. but ... at least in my opinions, for side-effects, they suck, and I prefer uniqueness types.
13:04:22 <hodapp> jmcarthur: I don't yet understand them, but I was under the impression that monads were a specific construct in the language for dealing with effects
13:04:38 <jmcarthur> hodapp: they are not specific to the language at all
13:04:51 <jmcarthur> hodapp: it's really nothing more than an interface that a lot of other things have, too
13:04:52 <hodapp> jmcarthur: I didn't mean "specific" as in "specific to the language".
13:04:53 <schoppenhauer> hodapp: monads also occur in other languages. even in c++ there is stuff that is "monadic" (even though not completely)
13:05:05 <shachaf> schoppenhauer: Are you disagreeing with jmcarthur or just saying the word "actually"?
13:05:05 <jmcarthur> schoppenhauer: yes, thay are very useful, but again, they are not an end, just a means
13:05:16 <mauke> hodapp: monads aren't built in, Monad is just a class in the standard library
13:05:31 <schoppenhauer> shachaf: more like "actually"
13:05:38 <hodapp> mauke: What primitives are used to implement said class?
13:05:45 <mauke> hodapp: none/depends
13:05:55 <jmcarthur> hodapp: what mauke said except that we do provide some syntax sugar, but everything you can say with the syntax sugar you can say with library code
13:05:57 <schoppenhauer> the maybe-monad is an example for a monad i consider useful.
13:06:02 <SingingBoyo> mauke: well sure, but with the do-syntax I'd argue they're semi-built-in
13:06:03 <jmcarthur> *with code that just uses normal library functions
13:06:27 <jmcarthur> schoppenhauer: i don't see what you said as contrary to what i said at all
13:06:38 <schoppenhauer> jmcarthur: dito
13:06:43 <jmcarthur> alright :)
13:08:03 <shachaf> jmcarthur: Actually, you're entirely right.
13:11:55 <FreeFull> Syntax sugar and the IO monad are the only two things that make monads special at all in Haskell
13:12:11 <FreeFull> Haskell didn't start out with monads built in
13:12:15 <JoeyA> sal23: I think you need an explicit type signature on the go function.
13:12:18 <mauke> IO is special without monads
13:12:33 <mauke> its monadicity is incidental
13:12:42 <JoeyA> The inferred type won't be the rank-2 type you need.
13:12:43 <mel-> shalom
13:12:59 <hpc> "i know how to use the IO Functor, but what is it /really/?"
13:13:23 <FreeFull> mauke: You can't do any reasonable IO in Haskell without >>=
13:13:45 <hpc> FreeFull: you can manage surprisingly well with (<*>)
13:13:53 <mauke> FreeFull: yes, but it wouldn't have to be Monad's >>=
13:14:11 <mauke> it could be (System.IO.>>=) :: IO a -> (a -> IO b) -> IO b
13:14:33 <shachaf> Or it could be IO done with a type which isn't monadic at all.
13:14:34 <FreeFull> mauke: I am talking about how things are right now
13:14:38 <FreeFull> Rather than how they could be
13:14:38 <mauke> or a Functor instance plus iojoin :: IO (IO a) -> IO a
13:14:55 * jmcarthur made an indexed monad for reading and writing Ptrs that automatically advance, and it's awesome
13:15:04 <FreeFull> I know you could use uniqueness types
13:15:09 <elliott> nothing about uniqueness types
13:15:13 <elliott> mauke is right
13:15:37 <elliott> it's true that the Monad IO instance is abstract/primitive, though
13:15:41 <elliott> but everything about IO is abstract/primitive
13:15:42 <FreeFull> mauke: You need return too
13:15:46 <elliott> including e.g. putStrLn
13:15:50 <mauke> FreeFull: true
13:16:00 <shachaf> Not to write (>>=)!
13:16:21 <FreeFull> Anyway, join is defined in the standard library using >>=
13:16:26 <FreeFull> So you'd need to use some other standard library
13:16:37 * shachaf tries to figure out whether there's a point being made here.22
13:16:43 <mauke> shachaf: probably not
13:16:56 <mauke> I didn't even mention join
13:16:58 <jmcarthur> FreeFull: it's just the case that IO has a function whose type matches that of (>>=)
13:17:04 <jmcarthur> and similarly for return
13:17:11 <jmcarthur> therefore, we made it an instance of Monad
13:17:22 <jmcarthur> and now "monads are required to interact with the real world, omg"
13:17:46 <FreeFull> I was just saying that the only thing that makes moands special at all in haskell is: 1) Do notation 2) IO monad 3) They are in the standard library
13:17:51 <schoppenhauer> ok, additional question: is there a function for periodically repeating a list? that is, [1,2,3] -> [1,2,3,1,2,3,1,2,3,...]? I can write one with list comprehension, but as "repeat" and "replicate" are defined, maybe this is also defined.
13:17:56 <jmcarthur> the IO monad does not make monads special
13:17:58 <jmcarthur> that's the point
13:17:59 <mauke> schoppenhauer: cycle
13:18:02 <schoppenhauer> mauke: thx
13:18:09 * shachaf also feels like linking http://stackoverflow.com/a/13538351/712548
13:18:30 <FreeFull> jmcarthur: It's special because you can't make one yourself without accessing compiler internals
13:18:40 <jmcarthur> FreeFull: that means IO is special
13:18:42 <jmcarthur> FreeFull: not monads
13:18:43 <FreeFull> While all other monads are defined in a library
13:18:48 <jmcarthur> exactly
13:18:52 <jmcarthur> therefore it's IO
13:18:56 <mauke> FreeFull: IO is defined in a library
13:19:10 <mauke> ST is magic too, btw
13:19:13 <FreeFull> mauke: Using things that access compiler internals
13:19:31 <kryft> Are there other magic monads than IO and ST_
13:19:32 <kryft> ?
13:19:34 <mauke> FreeFull: true but not essential
13:19:37 <FreeFull> I wonder if ST would be implementable given an IO implementation
13:19:46 <jmcarthur> FreeFull: only with unsafePerformIO
13:19:47 <FreeFull> Without access to primops
13:20:07 <FreeFull> jmcarthur: unsafePerformIO isn't part of the language
13:20:11 <jmcarthur> it is
13:20:15 <jmcarthur> part of the FFI
13:20:23 <jmcarthur> (or so it was at some point)
13:20:32 <FreeFull> Ok, I have to admit I didn't read the FFI section of the report
13:21:02 <shachaf> unsafePerformIO isn't in the Report
13:21:18 <shachaf> It's in the FFI Addendum to Haskell 98 but not in Haskell 2010. At least I didn't find it in this form.
13:21:38 <shachaf> (There's another function with the same type but it's even more restricted in what it can do.)
13:22:15 <jmcarthur> ah
13:22:38 <jwa> applicatiative: I managed to install haskell-platform now by remoing a line that set GHC_PACKAGE_PATH in build.sh which was really not needed there
13:23:21 <mgsloan>  /msg lambdabot >unsafeCoerce 5 :: IO Int
13:23:27 <mgsloan> hrmphh
13:23:45 <mgsloan> In normal ghci it gives "-4611686018427387904" :D
13:24:21 <hpc> -939524096
13:24:25 <hpc> you must be 64-bit
13:24:53 <mgsloan> Yup.  Either way I imagine it isn't consistent
13:26:04 <CODEtaku> crazy question: Has anyone played with using implication in functional compilers?  So something like p = [x|x<-[1..],x<400] would result in a finite list?
13:27:15 <johnw> I think we'd just use takeWhile...
13:28:10 <elliott> @free undefined :: a
13:28:11 <lambdabot> f undefined = undefined
13:28:14 <elliott> lambdabot proves Haskell is strict.
13:28:16 <CODEtaku> yeah, I know that's how it would be done if you wanted that functionality, I was just using that as a super simple example, I expect it would have more significant consequences
13:28:19 <mauke> zomg
13:29:20 <Algorith> that's more of a constraint logic programming kind of thing
13:29:50 <mgsloan> CODEtaku: I think that "Liquid Haskell" can do stuff like that
13:29:58 <CODEtaku> yeah, it would be like bringing the solving power of something like Coq in, I just wondered if it's been done or if it's clearly stupid (because I don't know enough to know yet)
13:30:06 <hpc> elliott: that's amazing
13:30:31 <applicatiative> jwa, oh awesome
13:30:33 <elliott> I don't see the relation to Coq
13:31:13 <byorgey> CODEtaku: people have explored using automated theorem provers to help with typechecking.  I've never heard of anyone using that technology to do something like what you're saying.
13:31:36 <byorgey> the problem with that example is that the semantics become really unclear
13:31:47 <CODEtaku> how so byorgey?
13:31:58 <byorgey> what happens when the theorem prover can't prove that a list like that is finite?
13:32:15 <CODEtaku> what happens when a compiler can't optimize a piece of code more?  It just doesn't
13:32:32 <byorgey> CODEtaku: that's different though: optimizations don't change the semantics of a program
13:32:37 <byorgey> just the efficiency
13:32:51 <byorgey> but in your example, a non-terminating computation gets changed to a terminating one
13:33:02 <monochrom> PVS has dependent types and uses automated theorem proving (decision procedures) to check dependent types as much as possible. (falls back to asking humans for the rest.)
13:33:40 <CODEtaku> I'm not sure what you mean by 'change the semantics'.... the declarative statements that make up the code are exactly the same, the compiler simply understands necessary limits that would otherwise have to be spelled out
13:34:10 <CODEtaku> ahh, I see what you mean
13:35:31 <byorgey> CODEtaku: however, I could see doing something like using a special "finite list" type; if the compiler can't prove that some comprehension results in something finite then it is a type error
13:35:38 <byorgey> that wouldn't run into problems with semantics
13:35:51 <CODEtaku> that diverges a bit from the mathematical correspondence of declarative programming though... if I were writing a proof and I said x was a list of all numbers drawn from the integers less than 400, I would not intend the reader to evaluate it for every other number
13:36:29 <byorgey> CODEtaku: sure, but the difference is that proofs are usually not intended to be executed
13:36:40 <byorgey> if a proof type checks, then it is a valid proof
13:36:51 <byorgey> so it doesn't matter if you use infinite structures in a proof
13:37:04 <byorgey> well, to a first approximation at least =)
13:37:08 <CODEtaku> yeah, that's why I would expect it would be a factor handled by the compiler, not the syntax of the language
13:37:29 <CODEtaku> the compiler handles the execution part, the code handles the declarative part... that might just be my naivete
13:38:25 <Algorith> another difference is that in this case you tell it to draw all integers less than 400 from a given list. That the given list is is monotonically increasing is non-obvious
13:39:00 <CODEtaku> Algorith: How is it non-obvious?  It could be shown with an extremely simple implication
13:39:33 <monochrom> definition. a statement is non-obvious iff it is not one of the axioms. :)
13:40:02 <monochrom> example. the twin prime theorem is obvious. it's one of my axioms. :)
13:40:18 <CODEtaku> I'm confused then, what could the importance of 'non-obvious' mean if the entirety of everything except the axioms qualifies?
13:40:29 <monochrom> I'm joking :)
13:40:52 <CODEtaku> heh, sorry
13:41:41 <byorgey> CODEtaku: I agree with you in this case that it is obvious, btw (both to humans and to any sufficiently sophisticated automatic theorem prover)
13:41:44 <CODEtaku> but proving that a sequence would be monotonically increasing would be one of the things I would expect a compiler to be able to make use of were it reasoning about the code with implication
13:41:52 <Algorith> you know it's monotonically increasing because of the way you constructed it. If you pass on the result, without this 'meta-information', you can't expect the receiver to know it's going to have that property
13:42:09 <CODEtaku> the compiler knows exactly how it was constructed as well
13:42:32 <CODEtaku> and it knows the implications of the operations it uses to implement it
13:42:35 <byorgey> Algorith: I think CODEtaku is talking about doing this analysis at compile time, when the information about monotonicity etc. is all available by inspection
13:42:58 <monochrom> by today's standard, linear inequalities are "obvious", as in most theorem provers already come with decision procedures for that, it's a solved problem.
13:43:18 <companion_cube> most SMT solvers, that is
13:43:20 <CODEtaku> yes, that was my intent... I expected maybe someone would say that the amount of code which could be reasoned about would probably be negligible at best or something
13:43:29 <monochrom> not just SMT solvers
13:43:34 <companion_cube> monochrom: it's not a  solved problem when it comes to non propositional provers
13:44:02 <companion_cube> (namely, first order or higher order automated provers)
13:49:19 * hackagebot mongodb-queue 0.2.0.1 - a queue using MongoDB  http://hackage.haskell.org/package/mongodb-queue-0.2.0.1 (GregWeber)
13:52:10 <Fuuzetsu> IIRC there's a way to see what packages rely on the package I specify. Does anyone know how to achieve such a feat?
13:53:01 <monochrom> http://hdiff.luite.com/ has reverse dependency lookup
13:53:53 <monochrom> "ghc-pkg dot" also shows the complete graph (one line of text per edge), and then you can use grep to narrow down
13:54:05 <byorgey> http://packdeps.haskellers.com/reverse
13:54:19 <luite> hdiff doesn't have reverse dep lookup
13:54:30 <byorgey> right, packdeps does
13:54:33 <luite> unless someone added it without me knowing :p
13:54:39 <byorgey> surprise!
13:54:42 <monochrom> yikes
13:54:59 <byorgey> luite: for hac phi we decided to hack into your server and add features
13:55:05 <byorgey> that Hetzner exploit was us
13:55:28 <luite> hehe, pretty impressive
13:57:10 <aristid> i always thought byorgey was peaceful
13:58:10 <byorgey> peaceful, and makes silly jokes
13:59:59 <elliott> you can't trust someone with that many "y"s in their name.
14:00:35 <aristid> the mark of trust comes from double letters
14:00:37 <aristid> like ll and tt
14:00:39 <neutrino> . o O (This FTP Server)
14:00:40 <monochrom> why distrust y? :)
14:00:50 <neutrino> s/Server/site/
14:05:03 <byorgey> My freshman roommate had a last name which also contained two y's
14:05:29 <Brongue> Any experts on literate haskell online?
14:06:05 <byorgey> Brongue: if you have questions about literate Haskell, just ask =)
14:08:10 <c_wraith> byorgey: you think they did that on purpose?
14:08:47 <monochrom> I think the school chooses students with many y's in their names on purpose :)
14:10:27 <Brongue> I'm trying to generate a .tex file from an .lhs file with lhs2TeX --poly, but i get "polytable error: Illegal preamble (no columns)"
14:18:47 <kosmikus> Brongue: that's insufficient information.
14:20:48 <tabemann> Brogue: put the .lhs file and the error message up on hpaste.org
14:28:25 <Brongue> the .lhs http://hpaste.org/89626
14:28:34 <Brongue> the error http://hpaste.org/89626
14:28:52 <Brongue> sorry
14:28:56 <Brongue> this is the error http://hpaste.org/89627
14:30:53 <Brongue> also, I am mistaken, it is pdflatex that gives an error.
14:32:45 <kosmikus> Brongue: it's an interaction with arydshln.sty
14:33:06 <kosmikus> Brongue: that redefines some tabular/array commands in ways that are conflicting with polytable.sty
14:33:43 <kosmikus> Brongue: I have no time right now to look into this in more detail, i.e., whether this apparent conflict is easily fixable; I've never seen that package before
14:35:56 <Brongue> Deleting that package works. Thanks! :)
14:36:16 <Brongue> Didn't use it anyway, and I can't remember what it's for.
14:38:05 <roconnor> jmcarthur: let me know if you find any #SPECIALIZE pragrams that improve your performance.
14:39:23 <jmcarthur> roconnor: oh, right now i'm only using it to tint sprites, and i've arranged it to do all the conversions at the time that it creates the sprite, so this isn't going to appear in the main rendering loop anyway
14:39:43 <jmcarthur> hmm, it's possible, i guess
14:39:57 <jmcarthur> there is nothing preventing somebody from creating the sprites on the fly (it's mostly a fast operation)
14:41:29 <jmcarthur> roconnor: in any case, i expect that INLINE would trump SPECIALIZE anyway, in most cases
14:41:48 <Xaseron> if i have type signature with a variable a. how can i express in a type signature in the where block, that this should be the same a?
14:41:58 <jmcarthur> Xaseron: ScopedTypeVariables (google it)
14:42:05 <Xaseron> thx
14:44:22 <shachaf> Haskell 98 has scoped type variables in a couple of places.
14:45:52 <monochrom> do you mean for example "data D a = X a | Y a a"?
14:46:25 <shachaf> That and type classes.
14:46:34 <jmcarthur> roconnor: would it be crazy to add a Num instance for Colour? it would be nice to be able to scale and add constants and such
14:47:23 <shachaf> Hmm!
14:47:35 <shachaf> class Hmm a where { foo :: a -> a; foo x = y where y :: a; y = x } behaves differently with and without ScopedTypeVariables on.
14:47:41 <shachaf> Despite not having a forall.
14:49:16 <monochrom> that's a surprise
14:49:35 <shachaf> Well, "a" is a scoped type variable regardless.
14:49:39 <shachaf> A forall wouldn't be correct.
14:49:56 <shachaf> The question is about nested type signatures.
14:50:00 <monochrom> perhaps the GHC people agree with you afterall! type class declarations imply scoped type variables :)
14:50:15 <geekosaur> a is scoped within a class definition anyway
14:50:26 <geekosaur> I think that's even h'98
14:51:01 <shachaf> Right, that's what I meant. But it's only scoped for signatures directly in the class.
14:54:22 * hackagebot monad-loops-stm 0.4 - Monadic loops for STM  http://hackage.haskell.org/package/monad-loops-stm-0.4 (JamesCook)
14:54:25 * hackagebot rwlock 0.0.0.3 - Multiple-read / single-write locks  http://hackage.haskell.org/package/rwlock-0.0.0.3 (JamesCook)
14:54:25 <roconnor> jmcarthur: I sort of expect SPECAILZE and INLINE to work together, but  I don't really understand this optimization stuff.
14:54:34 <roconnor> jmcarthur: which is why I want someone else to do it for me :P
14:54:57 <roconnor> jmcarthur: Colour is an instance of Monoid (so is AlphaColour but it is a totally different monoid).
14:54:58 <jmcarthur> roconnor: heh
14:55:36 <roconnor> jmcarthur: there is also a darken? function for scaling.  It can be used infix with backquotes.
14:55:52 <jmcarthur> roconnor: sure, but say i just want to increase the intensity of a colour by some factor. i could just scale it. or say i want to just change the shade of the color. that's just adding or subtracting a constant.
14:56:12 <jmcarthur> also nice things like 0 for black, 1 for white, 0.5 for grey
14:56:15 <jmcarthur> etc.
14:56:27 <roconnor> jmcarthur: darken will let you increase the intensity of a colour
14:56:52 <jmcarthur> i understand that the functionality is there. i'm thinking more in terms of just being able to write nice looking code
14:57:06 <jmcarthur> i'm writing a library that will be exposing Colour to the user
14:57:35 <roconnor> jmcarthur: I think it is pretty nice ^_^
14:58:12 <jmcarthur> it is indeed a nice API
14:58:21 <roconnor> jmcarthur: anyhow, a Num instance is too big a compromise IMHO.  But you are welcome to wrap my type an expose your type to your users with a Num instance ...
14:58:25 <roconnor> if you hate your users :P
14:59:06 <byorgey> It seems to me colour has the nicest possible API without starting to sacrifice semantics.
14:59:48 <jmcarthur> rgb 3 3 3 <> color is just a kind of annoying way to intensify a color, is all
15:00:07 <jmcarthur> to me the only weird thing about a Num instance would be choosing the color space
15:00:42 <jmcarthur> some people might expect 0.5 to be perceptual grey, for example, whereas i think i would prefer that it be more of just a scalar i can use for other operations
15:00:51 <byorgey> jmcarthur: you can make a function  grey x = rgb x x x,  intensify x = (grey x <>), and so on
15:00:56 <jmcarthur> yeah
15:01:04 <jmcarthur> it's just not as obvious as  color*3
15:01:12 <byorgey> I don't think color*3 is obvious at all.
15:01:19 <byorgey> I would have no idea what it should do.
15:01:19 <roconnor> jmcarthur: to intensify a colour you should use darken 3
15:01:26 <jmcarthur> maybe i've been using too much glsl
15:01:42 <jmcarthur> byorgey: the only sensible semantics, to me, is componentwise scaling
15:02:05 <byorgey> jmcarthur: with clipping?
15:02:09 <jmcarthur> no
15:02:18 <byorgey> so what do I get if I do  white*3 ?
15:02:27 <jmcarthur> you get rgb 3 3 3
15:02:33 <jmcarthur> that is a meaningful color
15:02:45 <jmcarthur> "white" is the unmeaningful thing there
15:03:08 <jmcarthur> i just happen to be guessing that white is rgb 1 1 1
15:03:16 <byorgey> yes, that's what I intended.
15:03:19 <roconnor> darken 3 colour is quite a bit different from (darken 3 white) <> colour
15:04:12 <jmcarthur> clipping is something that happens at render time
15:04:32 <jmcarthur> anyway, i don't mean to be argumentative
15:04:37 <jmcarthur> not my library ^_^
15:05:18 <roconnor> oh I'm not taking you as being argumentative.  I'm just pointing out the darken operation
15:05:52 <roconnor> which has the unusual property of being able to lighten colours. :D
15:06:03 <jmcarthur> yeah, that's pretty unclear to me :\
15:06:26 <jmcarthur> "darken 3" reads like "make 3 times darker" or "make 1/3 as light"
15:06:28 <augur> how can i write a shell in haskell so that i have a prompt?
15:06:40 <augur> doing putStr then getLine doesnt seem to work properly
15:07:00 <roconnor> ya darken 3 will make the colour 3 times a bright
15:07:20 <roconnor> normal use of darken expect a value between 0 and 1.  But it works outside this range too.
15:07:52 <jmcarthur> it feels like i'm about to use some unsupported behavior
15:10:41 <roconnor> jmcarthur: darken 3 can take you out of gamut and your colour coordinates may be clipped depending on how you extract it
15:11:05 <roconnor> but nothing too bad will happens so long as you stay in the Colour type.
15:12:40 <tij> in Graphics.Gloss, is there a way to capture when the user is holding down the button? - the event only registers if you press -> release -> press ...
15:12:47 <tij> http://hackage.haskell.org/packages/archive/gloss/1.1.0.0/doc/html/Graphics-Gloss-Game.html#t:Event
15:18:05 <ClaudiusMaximus> tij: type World = Set Key {- which keys are currently pressed -} ; input :: Event -> World -> World ; input (EventKey k Down _ _) world = Set.insert k world ; input (EventKey k Up _ _) = Set.delete k world ; input _ world = world
15:18:30 <ClaudiusMaximus> tij: unless the problem is actually at a lower level inside gloss?
15:19:24 * hackagebot ghc-vis 0.7.1 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.7.1 (DennisFelsing)
15:19:34 <tij> ClaudiusMaximus: if the user is holding the key down, won't the Up event never trigger?
15:20:20 <ClaudiusMaximus> tij: maybe it's key-repeat messing things up?
15:21:13 <tij> ClaudiusMaximus: yeah, i don't know if it's an internal problem or if there is a way around it
15:22:36 <ClaudiusMaximus> should be an option in your window manager settings (xkbset for x11) - not sure if there is a way to adjust it inside GLUT (which Gloss seems to use)
15:25:17 <tij> ClaudiusMaximus: i'm on windows 8
15:27:42 <ClaudiusMaximus> tij: you need to do something like    perWindowKeyRepeat $= PerWindowKeyRepeatOff :: IO ()  after the GLUT window is created
15:28:07 <ClaudiusMaximus> tij: http://hackage.haskell.org/packages/archive/GLUT/latest/doc/html/Graphics-UI-GLUT-DeviceControl.html
15:28:54 <tij> ClaudiusMaximus: wait, I just realized your original solution would work
15:29:44 <ClaudiusMaximus> tij: heh, ok - but you might get autokeyrepeat giving you lots of repeated on/off/on/off
15:31:24 <tij> ClaudiusMaximus: alright lemme try this - thanks a bunch for your help!
15:33:38 <ClaudiusMaximus> tij: you might need unsafePerformIO to do the glut key repeat suppression i suggested, or have your world type be something like   IO (Wrap world)  where  newtype Wrap x = Wrap (IO (Wrap x))   (not sure which is less evil)
15:34:16 <ClaudiusMaximus> oops, more like Wrap x = Wrap (x, IO (Wrap x))
15:34:37 <ClaudiusMaximus> or something, i'm totally confused now
15:34:38 <ClaudiusMaximus> :)
15:34:51 <frankbro> Why does foldl works but foldr doesnt in this example? http://hastebin.com/bewepipata.tex
15:35:34 <ClaudiusMaximus> frankbro: types of the to-be-folded function have swapped arguments
15:35:41 <elisa87> I followed http://askubuntu.com/questions/137655/boot-up-fails-drops-to-initramfs-prompt-12-04 and https://help.ubuntu.com/community/Boot-Repair#A2nd_option_:_install_Boot-Repair_in_Ubuntu yet no success and I see busybox initramfs prompt when I reboot !!! I Linux is in /dev/sda5 and here's some more info  http://paste.ubuntu.com/5749948/
15:36:09 <geekosaur> channel?
15:36:15 <geekosaur> ah
15:36:59 <Fuuzetsu> :t foldr
15:37:00 <lambdabot> (a -> b -> b) -> b -> [a] -> b
15:37:01 <Fuuzetsu> :t foldl
15:37:02 <lambdabot> (a -> b -> a) -> a -> [b] -> a
15:38:30 <ClaudiusMaximus> :t let f = undefined ; g = foldr f (0 :: Integer) ([] :: [(Integer, Integer)]) in f
15:38:32 <lambdabot> a
15:55:33 <bz> !xor
15:55:40 <bz> how to make good xor zomg
15:56:05 <timemage> bz, hmm?
15:56:24 <bz> how do i xor integers in haskell
15:56:26 <bz> timemage: ^
15:56:28 <c_wraith> with xor
15:56:43 <geekosaur> :t xor
15:56:43 <bz> Prelude> :t xor
15:56:43 <bz> <interactive>:1:1: Not in scope: `xor' Perhaps you meant `or' (imported from Prelude)
15:56:44 <lambdabot> Bits a => a -> a -> a
15:56:45 <c_wraith> > 1 `xor` 2 :: Integer
15:56:47 <lambdabot>   3
15:56:52 <bz> see above
15:56:52 <c_wraith> looks like it works to me
15:56:58 <c_wraith> import Data.Bits
15:57:01 <geekosaur> @index xor
15:57:02 <lambdabot> Data.Bits, Foreign
15:57:02 <Fuuzetsu> ?hoogle xor
15:57:02 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
15:57:02 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment Xor :: LogicOp
15:57:02 <lambdabot> package xorshift
15:57:15 <Fuuzetsu> …I always forget the syntax for this
15:57:15 <bz> seriously? i have to import before using a basic binary op?
15:57:21 <c_wraith> it's not basic
15:57:36 <c_wraith> It's barely used outside of low-level bit twiddling, which few people have a reason to ever do
15:57:50 <geekosaur> (note that xor on Bool values is just (/=)
15:57:55 <bz> I JUST WANT TO XOR TWO INTEGERS
15:57:56 <bz> OR CHARS
15:58:00 <bz> sorry ,caps*
15:58:04 <shachaf> monochrom: Oh, this is documented: 7.12.7.5 at http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/other-type-extensions.html#scoped-type-variables
15:58:13 <c_wraith> xoring two Char values doesn't even make sense
15:58:14 <Fuuzetsu> 'a' `xor` 'b'
15:58:17 <Fuuzetsu> > 'a' `xor` 'b'
15:58:19 <lambdabot>   No instance for (Data.Bits.Bits GHC.Types.Char)
15:58:19 <lambdabot>    arising from a use of `D...
15:58:23 <Fuuzetsu> heh
15:58:24 <c_wraith> Char values aren't sequences of bits
15:58:30 <c_wraith> They're unicode values
15:58:31 <bz> c_wraith: char::Int?
15:58:39 <c_wraith> maybe you mean Word8
15:58:39 <Fuuzetsu> :t ord 'a'
15:58:40 <lambdabot> Int
16:00:17 <bz> > read 'a' :: Word8
16:00:18 <lambdabot>   Couldn't match expected type `GHC.Base.String'
16:00:19 <lambdabot>              with actual typ...
16:00:58 <geekosaur> ...
16:01:44 <bz> oh ord
16:01:51 <bz> oh hey like python
16:01:56 <FreeFull> bz: Try " instead of '
16:02:05 <elliott> don't try that.
16:02:07 <elliott> it won't help
16:02:19 <FreeFull> I'm just saying, read takes strings, not chars
16:02:29 <geekosaur> (a) it'd have to be "'a'" (b) and it would be Char not Word8
16:02:48 <bz> but it can cast and stuff with ::
16:02:58 <FreeFull> :: isn't casting
16:03:17 <FreeFull> It can make types more specific, but it can't make a type into another type
16:03:19 <geekosaur> :: is specifying a type, which in the case of read specifies which parser to use
16:03:36 <geekosaur> the parser for Word8 does not accept character literals, only numeric
16:04:00 <FreeFull> Chars can have any unicode value anyway
16:04:13 <geekosaur> > maxBound :: Char
16:04:14 <lambdabot>   '\1114111'
16:04:26 <geekosaur> > maxBound ::Word8
16:04:27 <shachaf> And even some non-Unicode values!
16:04:28 <lambdabot>   255
16:04:35 <geekosaur> going to have trouble making that fit :p
16:04:53 <shachaf> geekosaur clearly doesn't have real-world pigeon-handling experience.
16:05:03 <FreeFull> > ord maxBound
16:05:04 <lambdabot>   1114111
16:05:27 <geekosaur> haskell \nnn is decimal, not octal like C/perl/python
16:07:34 <FreeFull> > encode . (:[]) $ 'a'
16:07:36 <lambdabot>   Not in scope: `encode'
16:08:28 <FreeFull> > fromString . (:[]) $ 'a'
16:08:29 <lambdabot>   Not in scope: `fromString'
16:08:29 <lambdabot>  Perhaps you meant `showString' (imported from P...
16:08:35 <FreeFull> > B.fromString . (:[]) $ 'a'
16:08:36 <lambdabot>   Not in scope: `B.fromString'
16:08:51 <FreeFull> > Data.ByteString.UTF8.fromString . (:[]) $ 'a'
16:08:52 <lambdabot>   Not in scope: `Data.ByteString.UTF8.fromString'
16:08:56 <FreeFull> ):
16:23:00 <bz> um
16:23:33 <bz> is it possible to construct a map :: (a -> b -> c -> ...) -> a -> b -> ...?
16:24:15 <bz> viz., a map that takes a series of lists as arguments
16:28:00 <Fuuzetsu> List of lists?
16:28:11 <bz> hm
16:28:23 <bz> given f :: (a -> b -> c)
16:28:33 <Peaker> bz, you mean:  map :: (a -> b -> c) -> [a] -> [b] -> [c] ?
16:28:36 <Peaker> That's called zipWith
16:28:43 <bz> hoog
16:28:47 <bz> Peaker: thanks
16:29:04 <Peaker> bz, http://code.haskell.org/~wren/wren-extras/dist/doc/html/wren-extras/Data-List-ZipWithN.html
16:29:12 <Peaker> if you want one possible generalization to any number of variables
16:29:19 <yepyep> Hi, I've been looking around Hackage and GitHub lately and have to inquire
16:29:51 <yepyep> are there any reasonably active, recently updated geospatial libraries for haskell?
16:29:58 <Peaker> bz, another possibility is to use the ZipList applicative like:  func <$> zipList1 <*> zipList2 <*> zipList3 <*> zipList4 ....
16:30:17 <yepyep> I saw one for handling shapefiles, but it seemed to be incomplete
16:31:09 <yepyep> I'd love to use Haskell, but I just feel like other langs have more robust tools for handling geospatial stuff, and I don't really feel up to snuff for writing my own libraries presently
16:31:49 <Bor0> to a person that has no experience with programming at all, would you recommend functional over imperative languages?
16:32:25 <yepyep> any other search for "x" geospatial libraries turns up results, where "x" is one of Java, Python, Ruby, etc, etc
16:32:48 <yepyep> Haskell seems to have a real dearth in terms of code in this particular area
16:33:33 <monochrom> shachaf: thanks, I see now.
16:33:46 <Adeon> maybe haskellers don't leave their homes
16:34:21 <monochrom> Bor0: yes, I recommend functional over imperative
16:34:56 <monochrom> functional reuses the most important highschool algebra skill: substitute equal for equal
16:35:18 <Bor0> before starting with functional, I had a little difficulty with the paradigm shift from imperative to functional. I'm interested what would the case be if a complete newbie started programming directly with functional languages
16:35:37 <yepyep> :(   I think geospatial could be a big win for functional programming, especially for stuff like raster processing.  Scala already has a distributed geoprocessing library called GeoTrellis which I've been looking at.
16:35:39 <monochrom> suppose a program contains "f x = x+x". then f 5 equals x+x. equals. as simple as that.
16:35:52 <monochrom> imperative programming is designed to violate that.
16:36:05 <monochrom> sorry, f 5 equals 5+5.
16:36:08 <Bor0> monochrom, I guess. but lambdas and recursion are not much taught in high schools
16:36:48 <monochrom> sure, but lambdas and recursion are so much easier to learn if you can substitute equal for equal
16:37:30 <monochrom> also, lambdas and recursion are present in imperative programming too. it is not like they make a difference.
16:37:43 <yepyep> Bor0: you could try some of the problems at project euler
16:37:59 <yepyep> some of them lend themselves to recursion very well
16:38:07 <yepyep> quite a few in fact
16:38:10 <monochrom> substitute equal for equal is the distinction between functional and imperative. functional has it, imperative breaks it.
16:38:43 <Bor0> I don't have troubles with recursion personally. I'm just interested in what would things be if I had started programming functional first instead of imperative, what would be easier
16:39:27 <Bor0> monochrom, I don't think that the distinction between assignment equal and equal equal is that huge of a problem
16:39:36 <yepyep> curious.  if you did choose imperative, what language would you be considering
16:39:43 <monochrom> suppose you define "g = (\x -> x+x)". then g 5 = (\x -> x+x) 5. equals. as simple as that. one more law says (\x -> x+x) = 5+5. this is the only new law you haven't learned in highschool.
16:40:10 <Bor0> yepyep, I tried some haskell and erlang. I stick to haskell for now, playing mostly with ghci and going by the book lyah (currently chapter 6)
16:41:05 <yepyep> lyah is good.  i'm no expert haskeller by any means though.  I myself am looking for intermediate material on haskell
16:41:30 <yepyep> I'd say learn both
16:41:40 <yepyep> functional and imperative
16:41:43 <monochrom> I am not even talking about "assignment equal". I don't even call that "equal". if I had my way, I wouldn't even use the notation "=". I am not talking about the notation anyway.
16:41:54 <Bor0> I do functional for hobby. I work with C/C++ and some PHP at work
16:42:15 <Bor0> monochrom, if not the notation, then what were you talking about?
16:42:32 <yepyep> have you considered Python on the imperative side of things?
16:43:07 <monochrom> suppose you define in imperative programming "h x = x+x", and you use it in imperative programming as h(read_int()). this is not equal to read_int() + read_int(). you cannot substitute equal for equal. as simple as that.
16:43:09 <Bor0> I played with some python, but not professionally, just making some scripts (e.g. web crawler was the last "useful" thing I did)
16:44:21 <monochrom> I seldom criticize notation. I usually criticize semantics and/or how to reason about a program. (same thing)
16:44:28 <bz> read_int isn't pure
16:44:39 <monochrom> well yeah, that's imperative for you.
16:45:10 <yepyep> ok, so I'm a bit of a different boat
16:45:19 <yepyep> i really like haskell's notation in many respects
16:45:39 <yepyep> but I don't really have a clue about going about creating a non-trivial program
16:46:03 <monochrom> you are free to say, this distinction is unimportant to you. you are also free to say, you prefer in fact the imperative way, where you can't substitute equal for equal, you really like it that way. I'm fine with that.
16:46:25 <Bor0> monochrom, there are ways to achieve that in C, but it probably is intermediate C level
16:46:30 <Bor0> but I get your point
16:46:33 <yepyep> I've considered writing something up with parsec to parse formats for instruments and the like, but I can't really see the advantage of haskell vs imperative languages
16:46:42 <monochrom> I am asked what I recommend, and so I answer what I recommend and why, what distinction I focus on. you are free to choose your poison.
16:46:53 <yepyep> especially when the imperative libraries often have more robust libraries
16:47:33 <yepyep> actually, parsec is pretty nice.  I'll grant that
16:48:28 <elliott> Bor0: huh?
16:49:05 <Bor0> ?
16:49:13 <yepyep> I know I've probably asked this before, but does anyone have personal recommendations for intermediate haskell stuff?  I looked at Real World Haskell and it's OK, but it still doesn't really address for me the process of designing a program in a functional style
16:49:35 <Fuuzetsu> yepyep: Writing some code is probably the way to head on from here.
16:49:44 <elliott> Bor0: I don't know what you mean by "ways to achieve that in C"
16:50:11 <Bor0> there are tricks in some imperative languages (especially C), that can achieve what monochrom suggested
16:50:27 <Bor0> i.e. passing a function as a parameter
16:50:44 <Bor0> but he just gave an example, I got his point
16:50:44 <elliott> monochrom didn't say anything about that, AFAICT...
16:51:06 <Bor0> the h(read_int()) example
16:51:31 <elliott> no function was passed as a parameter there... read_int() has type int, presumably
16:51:36 <hpc> yepyep: to address the question of the advantage of imperative haskell, one big strength is in writing non-linear control structures
16:52:05 <hpc> yepyep: you can for instance, write do {x; y; z}
16:52:30 <hpc> yepyep: and the actual flow of execution can be x; y; z, or z; y; x, or just x or z, or just y, or whatever
16:52:55 <yepyep> what kind of monad would that be?
16:52:56 <Bor0> elliott, he said that for f x = x + x it is not equal to read_int() + read_int() in imperative languages, which in contrast it is equal to read_int() + read_int() in functional languages
16:53:01 <yepyep> errr
16:53:07 <yepyep> for example
16:53:22 <elliott> Bor0: ok... but still no function passing, so I'm confused
16:53:31 <yepyep> but couldn't you still do that in imperative langs?
16:53:55 <monochrom> in Haskell, read_int()+read_int() is not allowed
16:54:17 <hpc> yepyep: some imperative languages, sometimes
16:55:14 <Bor0> how do you mean monochrom
16:55:37 <monochrom> it is not allowed. it is a type error. the computer will reject it.
16:55:43 <yepyep> can we declare the type of read_int?
16:55:58 <monochrom> depends on which language. but I'll do both.
16:56:08 <yepyep> Say      String -> IO Int
16:56:13 <monochrom> imperative: read_int :: () -> Int
16:56:25 <monochrom> functional (Haskell): read_int :: IO Int
16:56:43 <monochrom> there is no String. it gets stuff from user.
16:57:07 <shachaf> It is not only a type error, it is a value error.
16:57:27 <shachaf> I.e., if you had dynamic types, it would still make no sense to do it. IO Int and Int are different things.
16:57:45 <monochrom> SML goes the imperative way. just with different notation. read_int : unit -> int
16:57:47 <yepyep> couldn't we do fmap (+) read_int read_int
16:58:05 <monochrom> yes, that's one valid thing in Haskell
16:58:21 <monochrom> another valid thing is fmap (\x -> x+x) read_int
16:58:43 <monochrom> the two are not equal. and you get to choose, explicitly, which one you want.
16:58:58 <Peaker> yepyep, you can't use fmap to fuse two actions together into one
16:59:16 <yepyep> oops. yeah. my oversight
16:59:28 <Peaker> yepyep, fmap/Functor only lets you modify the result of a single action without changing its "effects" in any way
16:59:43 <Fuuzetsu> consider ‘data Foo = A String | B String | C String | D String | X Integer Integer’. Is it possible to have a function that will pattern match like ‘f (_ x) = x; f (_ x y) = show (x, y)’?
16:59:48 <monochrom> well, we already know the two are unequal. the more important point is, using algebra laws, you will still not accidentally prove them equal. therefore, you can trust the algebra laws.
16:59:55 <Peaker> <*>/Applicative lets you fuse multiple actions to combine the "effects" of all of them, and combine the results too
17:00:20 <monochrom> liftM2 (+) read_int read_int. also, (+) <$> read_int <*> read_int
17:00:41 <yepyep> yeah.  thanks for the refresher
17:00:48 <magicman> Fuuzetsu: Nope.
17:00:53 <Fuuzetsu> Didn't think so.
17:02:00 <Peaker> Fuuzetsu, why not restructure it to be like:  data ABCD = A | B | C | D ; data Foo = FooABCD ABCD String | FooX Integer Integer?
17:02:28 <yepyep> any recommendations for libraries for command line interfaces?   ncurses any good?
17:02:41 <Peaker> Fuuzetsu, case foo of FooABCD _ x -> x ; FooX x y = show (x, y)
17:03:03 <Peaker> yepyep, I recommend vty
17:03:16 <Peaker> yepyep, curses is terrible from my experience. vty is somewhat nice
17:04:21 <yepyep> ok thanks.  I'd like to write some kind of metadata parser/writer perhaps.  i looked at hxt for xml parsing, but iirc it doesn't do writing for xml?
17:04:42 <Fuuzetsu> Peaker: Because it was only a theoretical question ;)
17:05:00 <Fuuzetsu> I thought HXT does XML writing.
17:05:06 <Fuuzetsu> (pretty sure even)
17:05:20 <JoeyA> I had a problem with killThread: it wasn't succeeding, even though the target thread was obviously dying.  Guess what the problem was.
17:05:28 <Fuuzetsu> The only complaint I have about HXT is the unacceptable memory usage for any file beyond 20MB
17:05:38 <magicman> Fuuzetsu: There is some theory behind that style of pattern matching, although it's not for Haskell. If you're academically inclined, check out the references on http://en.wikipedia.org/wiki/Pattern_calculus .
17:05:41 <Peaker> JoeyA, it was already dead/dying before the killThread?
17:05:58 <JoeyA> Peaker: no, killThread succeeds if the thread is already finished.
17:05:59 <Peaker> Fuuzetsu, I think HXT is overengineered and unnecessarily difficult to use
17:06:10 <Peaker> Fuuzetsu, the simple xml package is so much simpler/nicer
17:06:19 <monochrom> the target thread blocks exceptions
17:06:31 <JoeyA> Hint: it was a stupid mistake of mine, not an exotic flaw in the scheduler.
17:06:40 <Fuuzetsu> magicman: That sounds cool, I'll check it out.
17:06:41 <JoeyA> monochrom: ruled that out.  The thread finished to completion.
17:06:51 <Fuuzetsu> Peaker: Each to their own.
17:06:57 <monochrom> you use the wrong threadID
17:07:02 <Peaker> Fuuzetsu, also, I hate Control.Arrow
17:07:05 <JoeyA> monochrom: warmer
17:07:10 <JoeyA> I did use the right thread ID.
17:08:26 <magicman> (grah, if you have access to those sites. I forget that those limits exist when I'm on university internet >_<)
17:08:55 <JoeyA> Answer: turned out the thread I wanted to kill was the same thread doing the killing.
17:09:25 <monochrom> I see. haha
17:09:26 <JoeyA> I sent a job to a worker thread to kill itself, then tell me when it finished doing so.
17:10:55 <hpc> clearly you should have told it to report the kill before actually killing
17:11:04 <SingingBoyo> Sounds like something out of an xkcd comic
17:12:07 <yepyep> I actually kinda liked HXT
17:12:15 <yepyep> granted, I don't fully grasp arrows
17:12:31 <yepyep> in fact, i think i've forgotten them entirely now
17:13:30 <hpc> yepyep: just as well :P
17:13:47 <yepyep> why do you say that?
17:14:05 <JoeyA> hpc: I forgot that the thread I was killing was the same as the thread doing the killing.
17:14:29 * hackagebot mongodb-queue 0.2.0.2 - a queue using MongoDB  http://hackage.haskell.org/package/mongodb-queue-0.2.0.2 (GregWeber)
17:16:35 <SexyGirlG> my skype am a hot girl add em guys  : rose.mourad
17:16:46 --- mode: ChanServ set +o monochrom
17:16:52 --- mode: monochrom set +b *!*@Nac-1.lynx.net.lb
17:16:52 --- kick: SexyGirlG was kicked by monochrom (SexyGirlG)
17:17:36 <yepyep> I'm confused about how arrows differ from functions
17:18:06 <yepyep> on the surface they look the same in some respects, with regard to operations such as composition
17:18:48 <JoeyA> yepyep: newtype Auto = Auto { runAuto :: (a -> (b, Auto a b)) -> Auto a b }
17:18:59 <JoeyA> Err, newtype Auto a b = ...
17:19:17 <JoeyA> err, copy-paste mistake
17:19:34 <JoeyA> newtype Auto a b = Auto { runAuto :: a -> (b, Auto a b) }
17:19:57 <JoeyA> It's a state machine.  You feed it a value of type a, and it spits out a result of type b, and the new state of the machine.
17:20:31 <JoeyA> Thanks to edwardk (I think) for telling me about it.  It's called a Mealy machine.
17:21:04 <monochrom> a Moore machine omits the b
17:21:28 <JoeyA> yepyep: It's not a function because it's state can change.  However, it is an Arrow.
17:21:43 <JoeyA> See if you can write the Category and Arrow instances for Auto.
17:22:23 <yepyep> sorry, i don't think i'm at that point yet.
17:22:38 <yepyep> ok, so we have a result and a state
17:22:39 <JoeyA> :t (>>>)
17:22:40 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
17:22:56 <yepyep> how does an arrow differ from the State Monad?
17:23:07 <JoeyA> See if you can write this function: (>>>) :: Auto a b -> Auto b c -> Auto a c
17:23:33 <JoeyA> It creates an automaton that works by feeding the input through two input automatons.
17:23:51 <Peaker> yepyep, Arrow is a type-class. State monad is a concrete type
17:24:06 <JoeyA> :t state
17:24:07 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
17:24:14 <JoeyA> pfft
17:24:30 * hackagebot Clean 0.6 - A light, clean and powerful utility library  http://hackage.haskell.org/package/Clean-0.6 (MarcCoiffier)
17:25:24 <JoeyA> yepyep: type State s a = s -> (a, s)
17:25:39 <geekosaur> well, not any more
17:25:41 <JoeyA> That's the state monad, though I omitted the use of a newtype.
17:27:22 <JoeyA> To turn it into an arrow (with an input and output), you can do this: type Auto s a b = a -> s -> (b, s)
17:28:14 <JoeyA> This is a lot like the Auto I described above, but here the state is an explicit value, rather than closed over by the machine.
17:28:34 <JoeyA> But for this Auto, you can't compose machines of two different state types.
17:31:45 <yepyep> so
17:32:09 <yepyep> (Auto a b) >>> (Auto b c)
17:32:13 <yepyep> does not work?
17:32:35 <yepyep> assuming a, b and c are not all the same type
17:32:48 --- mode: monochrom set -b *!*@Nac-1.lynx.net.lb
17:32:54 --- mode: monochrom set -o monochrom
17:42:37 * Peaker just used:  case () of () | ... ->  | ... -> ....
17:42:46 <Peaker> just to avoid the new "if | | | " thing
17:44:02 <Fuuzetsu> new ‘if | | |’ thing?
17:46:45 <elliott> Peaker: case () of _ -- a char shorter!
17:47:02 <Peaker> :)
17:47:49 <shachaf> With TypeHoles: case _ of _
17:48:04 <monochrom> hahaha, improvements!
17:48:39 * monochrom wants to see the core code generated from case () of _ | guard -> ...
17:49:00 <shachaf> I would assume that it's good.
17:50:25 <ion> case of | … -> …  whoops, it became multiwayif.
17:52:23 <monochrom> yeah, it eliminates the (), goes ahead to branching on just the guards.
17:53:04 <elliott> I wonder if gets worse if you do "of ()"
17:53:05 <elliott> I assume not
17:53:08 <monochrom> my English may be suboptimal
17:53:09 <Peaker> hmm.. I want something like:  map f $ zip xs (tail xs)    except I want to keep the last element as is, without an ugly:  ++ [last xs] after that, or a manual recursion
17:54:00 <monochrom> "case () of ()" still eliminates the (), goes straight to the guards
17:54:02 <Peaker> hmm, that's zipWith for a curried f
17:54:22 <monochrom> I mean, recall my adventure with even predicates and selectors!
17:54:33 * monochrom has to find that post again!
17:54:47 <sclv> Peaker: i wonder if there's a lens for that?
17:55:00 <ion> i wonder if it uses unsafeCoerce?
17:55:16 <Peaker> zipWith :: (a -> a -> a) -> [a] -> [a] -> [a]    that doesn't truncate, but keeps existing elements
17:55:36 <monochrom> elliott: http://article.gmane.org/gmane.comp.lang.haskell.cafe/104783/ is how bloody smart GHC is :)
17:56:00 <elliott> monochrom: yeah, I've seen that before, it's great :)
17:56:36 <sclv> Peaker: what's the function you're zipping?
17:57:47 <geekosaur> ghc 8.0 will be skynet
17:58:11 <Crockeo> Quick question before I start watching Game of Thrones: Anyone know how to represent the ASCII character 0 in Haskell?
17:58:22 <monochrom> that quickly? :)
17:58:23 <byorgey> Crockeo: '0'
17:58:30 <Crockeo> Thank you!
17:58:31 <troydm> '\0' maybe?
17:58:34 <Peaker> sclv, one that sets a "next" attribute on each item to its neighbor
17:58:41 <Peaker> sclv, (linking their identities)
17:58:51 <ion> > minBound :: Char
17:58:56 <Peaker> but doesn't set any such attribute on the last element
17:58:59 <lambdabot>   '\NUL'
17:59:03 <sclv> so what _should_ it be set to on last?
17:59:15 <byorgey> troydm: good point, Crockeo's question was a bit ambiguous =)
17:59:15 <Peaker> sclv, untouched
17:59:20 <Crockeo> Yeah, sorry
17:59:25 <Crockeo> I meant to say representing the (null) character
17:59:30 <sclv> ah i was wondering if there was an "identity" next value
17:59:37 <byorgey> Crockeo: ok, then you want '\NUL'
17:59:42 <Crockeo> Thank you!
17:59:45 <sclv> bc then at least you could do ++ [identityVal] instead of ++ [last xs]
17:59:47 <ion> or '\0' as troydm said
17:59:57 <troydm> '\0' is same as '\NUL'
18:00:00 <byorgey> > '\0'
18:00:01 <lambdabot>   '\NUL'
18:00:06 <byorgey> it works, what do you know
18:00:08 <ion> > '\x0'
18:00:10 <lambdabot>   '\NUL'
18:00:16 <ion> > '\o0'
18:00:16 <monochrom> human civilization has really advanced. 6000 years ago: there was no zero. 1000 years ago or something: there was a zero. today: there are so many zeros, 0::Int, '0', '\0', ... :)
18:00:17 <lambdabot>   '\NUL'
18:00:20 <Peaker> sclv, it might make sense to have some next given in context, but we tried to avoid having a big context, and instead, we return the result and our caller may add that attribute within our result
18:01:05 <sclv> oh wait cmccann has something that generalizes zipwith
18:01:07 <shachaf> monochrom: I think zero zeros was the most advanced state.
18:01:32 <sclv> Peaker: http://hackage.haskell.org/packages/archive/these/0.3/doc/html/Data-Align.html
18:03:09 <sclv> lpadZipWith should do the trick
18:03:37 <elliott> most of that module is my fault, cmccann should be spared :P
18:04:14 <Peaker> sclv, cool, would use that if it hadn't incurred an extra dependency just for 2 lines of code :)
18:05:47 <cmccann> wait what's this is it bicrosswalk time
18:05:52 <cmccann> please tell me it is bicrosswalk time
18:06:16 <byorgey> iiiiiiiiiiit's bicrosswalk time!!
18:06:27 <cmccann> also please note that "malign" remains one of my best function names ever
18:06:56 <byorgey> @remember cmccann also please note that "malign" remains one of my best function names ever
18:06:56 <lambdabot> It is forever etched in my memory.
18:07:04 <cmccann> :D
18:07:17 <byorgey> noted =)
18:08:07 <cmccann> anyway I overslept a bit and ended up going straight to the station today, oh well
18:08:43 <byorgey> ah, too bad
18:08:48 <cmccann> there's exactly one train between Pittsburgh and Philadelphia every day so my scheduling options were a bit limited :[
18:08:55 <byorgey> hehe
18:09:00 <byorgey> well it was great to meet you, thanks for coming!
18:09:04 <sclv> ditto
18:09:04 <elliott> cmccann: you know, one bicrosswalk law is missing.
18:09:06 <cmccann> it was fun!
18:09:09 <elliott> it should have one corresponding to composition.
18:09:19 <elliott> Traversal's expression of it involves a hideous Compose type. I bet Bicrosswalk's will be even worse.
18:09:24 <cmccann> elliott: ok you should add that
18:09:31 <elliott> I was thinking: you.
18:09:34 <sclv> this was the hacphi where i got the least coding done out of all of them, and probably had the most fun
18:09:37 <cmccann> no, making bicrosswalk worse is your department.
18:09:51 <cmccann> yeah I basically got zero coding done but I expected that
18:10:02 <zRecursive> Pittsburgh and Philadelphia are in same country ?
18:10:15 <dmwit> Yes; they are even in the same state, I think.
18:10:28 <sclv> at some point i had an intuition for bicrosswalk but i forgot it
18:10:29 <zRecursive> then not far
18:10:33 <sclv> i'd love to see it used in anger
18:10:39 <elliott> sclv: you're kidding.
18:10:44 <elliott> you realise I added it as a joke right :P
18:10:44 <sclv> our states are big
18:10:48 <cmccann> sclv: I think you'd have to be pretty damn angry for that
18:11:18 <cmccann> @quote too.perfect
18:11:18 <lambdabot> elliott says: cmccann: unfortunately it is too perfect an abstraction to be useful.
18:11:23 <sclv> i feel like i went thru a rite of passage this weekend, taking this interesting structure, discovering it had lots of nice properties
18:11:30 <sclv> and then discovering that it was isomorphic to (,)
18:11:34 <cmccann> anyway I gotta run, need to finish unpacking
18:11:43 <sclv> whoops
18:11:45 <byorgey> zRecursive: it is about 450km.
18:11:59 <sclv> you hear the stories about people doing it, but its fun to go through it yourself at least once
18:12:07 <elliott> sclv: haha, what was the structure?
18:12:20 <sclv> the interpretation of Day Convolution in haskell
18:12:25 <zRecursive> byorgey: what a big state !
18:12:31 <elliott> is this why edwardk added it to contravariant?
18:12:33 <sclv> we started with a categorical formula involving like a coend and stuff
18:12:34 <sclv> haha yes
18:12:49 <sclv> and then after he uploaded we realized it was coyoneda (,)
18:13:02 <elliott> sclv: as I said, you must have had a very convoluted day.
18:13:33 <sclv> we were like "wow, look at all these ways it preserves naturality!"
18:14:07 <byorgey> zRecursive: http://maps.google.com/?q=pennsylvania
18:14:26 <dmwit> American state ~= European country
18:14:34 <zRecursive> byorgey: thx
18:15:27 <sclv> dmwit: i guess rhode island = luxemourg ?
18:15:33 <sclv> bourg even
18:16:03 <sclv> or like california = half of europe
18:16:54 <dmwit> sclv: Not bad! Luxembourg is 2.6 km^2, RI is 3.1 km^2
18:17:11 <dmwit> um
18:17:20 <dmwit> 2.6 kkm^2, 3.1 kkm^2, respectively
18:17:55 <sclv> on the whole, i'd rather be in Luxembourg
18:18:18 <dmwit> 2.6 G(m^2), 3.1 G(m^2)
18:22:29 <byorgey> dmwit: it's OK, the SI prefix k binds more tightly than ^2
18:23:17 <byorgey> oh, but you actually meant k(km^2), I see =)
18:23:41 <dmwit> yeah, I really bumbled around before working out what I wanted to say =P
18:23:42 <byorgey> yes, I guess 3 square kilometers is a bit on the small side
18:23:46 <byorgey> =)
18:25:33 * sclv wonders if our new type/kind toys have finally given us sufficient tools for a good units of measure system in haskell
18:29:26 <monochrom> the holy grail is to convert between 2 millioleg and 0.002 oleg
18:30:58 <shachaf> I heard Oleg can do that in O(leg log leg) time in the type system.
18:36:44 * hodapp looks at shachaf
18:39:16 <et09> hbro: Gtk.Builder.builderGetObject: no object named "webViewParent" in the builder.
18:39:23 <et09> not sure what to make of this...
18:44:45 <enthropy> sclv: aren't the old (existing) dimensional numbers packages usable?
18:45:28 <sclv> depends on your definition of usable
18:46:19 <enthropy> dimensional doesn't help you write code that's dimensionally consistent, but it stops giving horrible error messages once you work your units out
18:54:53 * DarkFox is getting really tempted to hack at pandoc and get yaml highlighting and decent colourschemes with correctly configured languages…
18:54:58 <DarkFox> The highlighting is crap
18:55:16 <DarkFox> yaml highlighting config files * (not xml)
18:59:40 * hackagebot var 0.2.0.0 - Mutable variables and tuples  http://hackage.haskell.org/package/var-0.2.0.0 (AndySonnenburg)
19:07:34 <dmwit> shachaf++ because I like wordplay
19:11:25 <b2coutts> is there some sort of consensus on whether to line up all definitions for a function via tabs, or to simply leave a single space after the pattern match? I ask because LYAH seems to do the latter, but a lot of other code I see does the former
19:13:12 <arkeet> it's just personal preference, I think.
19:13:29 <arkeet> usually I like to see '='s lined up
19:13:44 <b2coutts> yeah, I'm kind of conflicted about it
19:14:08 <b2coutts> on the one hand function definitions look really nice when ='s are lined up, but on the other hand this often makes it annoying to limit to 80 columns
19:14:40 <arkeet> well, you don't have to do it *all* the time
19:14:57 <b2coutts> yeah, it just seemed like it might be a weird thing to be inconsistent about
19:15:14 <sclv> 80 col limit is silly
19:15:22 <zRecursive> b2coutts: it is better to replace <TAB> by <SPACE> automatically by your <EDITOR>
19:15:24 <b2coutts> but if there's no rigid canon about which way to do it I'll probably just change based on the situation
19:16:08 <b2coutts> sclv: I used to think so too, but I find I'm often annoyed by >80col code when I want to split terminals on my laptop
19:19:27 <applicatiative> i like it with the =
19:19:38 <applicatiative> lined up but tabs proper are out of the question of course
19:23:40 <dmwit> Yes, I like lining up my = signs, and sometimes even lining up patterns in corresponding positions. Also, yes, tabs are not for alignment.
19:39:32 <sclv> someone should release an anti-hlint for next april fools
19:40:01 <sclv> like turning spaces into tabs, replacing . by parens, eta expanding everything, etc.
19:40:41 <sclv> name it something like hlint-strict
19:41:03 <bonsu> what is meant by lexicographical order, for example I am trying to understand why [3,2,1] > [2,10,100] == True. Is it because only the first comparison matters? (3>2)
19:41:32 <sclv> yeah think of it like 'alphabetical order' generalized
19:41:51 <sclv> compare by the first, unless they're equal, in which case compare by the second, etc.
19:43:01 <bonsu> 3>2 but 2 < 10
19:46:31 <elliott> but as sclv says, it stops on the first
19:50:07 <bonsu> right
19:54:01 <genisage> This might be a silly question but when I use a data constuctor, is there a way to pass the thing being created to a function that's calculating one of the fields?
19:54:51 <genisage> For example, if I wanted to convert a list to a doubly linked list of nodes, with something like data Node = Node a Node Nod
19:55:38 <genisage> | Head a Node | Tail a Node
19:56:24 <latermuse> is there anyway to use simpleHTTP and get results back in the Data.Text format instead of a String?
19:56:38 <latermuse> without using Data.Text.pack
19:58:03 <genisage> Sorry, I'm having trouble concisely explaining what I want to do.
19:58:08 <latermuse> its okay
19:58:14 <sohum> what's the actual name of the (>>=) operator? and does it have a symbol I can use in latex's math mode?
19:58:38 <genisage> It's the bind operator
19:58:53 <latermuse> there is a symbol, but its ugly imo
20:04:44 <sohum> genisage, latermuse: thanks!
20:05:12 <sohum> latermuse: what's the symbol you're thinking of?
20:05:40 <sohum> searching 'latex bind symbol' isn't helping
20:07:04 <latermuse> i dont know the name, but ive seen it in a few papers before
20:07:14 <latermuse> sorry i cant be much help
20:07:24 <sohum> does it look anything like >>= ?
20:07:34 <latermuse> yeah, but stylized
20:07:39 <sohum> huh
20:07:50 <latermuse> its strange
20:08:01 <sohum> if you don't mind, could you try drawing it in http://detexify.kirelabs.org/classify.html ?
20:08:51 <latermuse> yeah let me try
20:19:23 <dmwit> sohum, latermuse: It's not like there's a special command to produce it.
20:19:32 <dmwit> It's just a >, a >, and a = with some negative space in between each.
20:19:44 * hackagebot saltine 0.0.0.2 - Cryptography that's easy to digest (NaCl/libsodium bindings).  http://hackage.haskell.org/package/saltine-0.0.0.2 (JosephAbrahamson)
20:20:03 <dmwit> You can ask lhs2tex or whatever tool that is to produce it for you wherever you have a real >>=.
20:22:10 <latermuse> thats probably the best way
20:24:55 <sohum> dmwit: aw. so there's no symbol that semantically _means_ monadic bind that I could use in its place either?
20:28:06 <applicatiative> i wonder if its lhs2tex-specific. it's pretty ugly really the froofy bind symbol
20:29:35 <kennycason> For anyone interested, i've been learning haskell for the last week and programmed a BEP neural network (it's not 100% finished but works), I'd be happy if some people more oriented to the FP world than myself could look over it and give advice: it's hosted here: https://github.com/kennycason/haskell_nn
20:29:58 <kennycason> i can only imagine how the code looks to someone experienced in Haskell haha
20:31:23 <dmwit> sohum: I think category theorists typically use \eta for return and \mu for join.
20:32:07 <dmwit> (>>=) isn't really the right way to specify things for the semantic object... but it's definitely the right way for programming.
20:34:11 <frankbro> can I call iterate on a function with a state monad and expect it to be updated all along the process?
20:35:53 <dmwit> No. You might like the monad-loops package, though.
20:37:19 <applicatiative> sohum here's the monadic bind and other lhs2tex symbols used in Huttons primer http://michaelt.github.io/images/bind.png
20:43:03 <tij> can someone explain to me how these two solutions are equivalent: http://www.haskell.org/haskellwiki/Solution2.html
20:43:07 <sohum> applicatiative: yea, that is pretty ugly! but okay, so he was using the negative space thing
20:43:26 <tij> it seems that the latter solution is biased towards the father (if the father has no parents then it will return Nothing)
20:43:49 <sohum> dmwit: so it's... \mu .. T, I guess?
20:44:02 <sohum> something like that, anyway
20:45:38 <Clint> tij: do you understand mplus and >>= for Maybe?
20:45:53 <tij> Clint: i believe so
20:46:58 <tij> if the sheep has the father, the mother portion will be ignored due to mplus right?
20:48:22 <dmwit> tij: They are probably not equivalent.
20:48:29 <applicatiative> sohum ah yeah i see it is just a matter of 'adding' negative space
20:48:48 <tij> if the father has no parent, but the mother has a parent, then the second function will return Nothing right?
20:49:17 <dmwit> tij: Right.
20:49:41 <dmwit> tij: (This is why you should use [] for such a thing, not Maybe!)
20:49:55 <elliott> dmwit loves [] so much.
20:50:05 <dmwit> [] is great.
20:50:08 <elliott> maybe it's because it's the free monoid.
20:50:20 <dmwit> That's cool and all, but it's definitely not why.
20:50:24 <elliott> and hence the easiest type.
20:50:40 <elliott> sorry dmwit, it was all an elaborate monoids joke
20:50:41 <shachaf> [] is no good, though.
20:50:42 <tij> dmwit: ok, I thought I was crazy... shouldnt they change it?
20:50:49 <shachaf> As they say: "free, easy, good: pick any two"
20:50:58 <elliott> haha
20:51:16 <dmwit> tij: It's a wiki...
20:51:32 <dmwit> (They is you!H)
20:52:27 <shachaf> We have met the wiki editors, and they are us.
20:52:37 <tij> ah, right, forgot... lemme create an account and I'll change it (should I delete or just put a disclaimer?)
20:53:32 <tij> well i cant create an account now... i have to email someone apparently
20:54:42 <elliott> lambdabot: @quit
20:56:03 <elliott> meet the new lambdabot, same as the old lambdabot
20:56:19 <shachaf> hi lambdabot
20:56:37 <elliott> > 'λ'
20:57:07 <johnw> elliott: I had another yoneda question for you
20:57:15 <dmwit> tij: I trust you to make a good decision about how best to edit it.
20:57:37 * elliott wonders why lambdabot waits to join all the channels before responding. totally ruining my intro.
20:57:47 <johnw> elliott: I kind of seems like Yoneda is just a higher-ordered variant of the free theorem for fmap.  Compare: f . g = fmap g . f with f g = fmap g (f id).  Those seems awfully close
20:57:55 <Clint> how many channels is that?
20:58:21 <elliott> Clint: a lot.
20:58:43 <elliott> Clint: about 70.
20:58:47 <Clint> wow
20:59:24 <elliott> johnw: I think the closeness might just be because free theorems are all about parametricity (polymorphic functions being natural transformations), and the Yoneda lemma is all about natural transformations (and is linked to parametricity itself)
20:59:30 <elliott> hmm
20:59:31 <elliott> lambdabot: @run 2
20:59:38 <lambdabot>   2
20:59:46 <elliott> > 'λ'
20:59:51 <dmwit> elliott: Are you the new lambdabot dude, then?
20:59:56 <Guest55594> Can someone help me? I can't figure out why there's a memory leak. I've removed just about every bit of code I can
21:00:03 <elliott> dmwit: yep
21:00:04 <Guest55594> http://pastebin.com/aaWkhpke
21:00:05 <dmwit> ?hpaste your code
21:00:05 <lambdabot> Haskell pastebin: http://hpaste.org/
21:00:06 <elliott> I appear to have broken it already.
21:00:08 <elliott> > 123
21:00:09 <lambdabot>   123
21:00:09 <mauke> The paste aaWkhpke has been copied to http://hpaste.org/89645
21:00:10 <dmwit> pastebin is okay, too
21:00:19 <elliott> > 'λ'
21:00:31 <elliott> hm. at least it only happens on Unicode. though that was meant to be fixed.
21:00:44 <Guest55594> wow that's rather useful
21:00:48 <Guest55594> I already had a pastebin
21:00:55 <shachaf> elliott: "123" is Unicode!
21:00:57 <shachaf> I say we go back to kappabot.
21:01:13 <elliott> Guest55594: yeah, but we don't like pastebin's interface, so mauke copies them automatically :P
21:01:43 <dmwit> Guest55594: I'm guessing you're building up an enormous thunk in your IORef.
21:01:52 <dmwit> Also, don't use unsafePerformIO.
21:01:55 <elliott> dmwit: I will plug my favourite new feature: :t works in /msg
21:01:57 <Guest55594> I know but I can't find a way around it
21:02:00 <Guest55594> I want to fix that too
21:02:10 <Guest55594> there's an apology in the import
21:02:15 <dmwit> elliott: Hah! That's been a long time coming.
21:02:29 <dmwit> Guest55594: Perhaps you would like modifyIORef'.
21:02:40 <Guest55594> That doesn't stop it
21:02:45 <Guest55594> the problem I have is this:
21:02:49 <Guest55594> glut's callbacks don't have arguments
21:03:08 <Guest55594> therefore I must find a way to reference a state that is held between calls of it
21:03:09 <elliott> dmwit: lambdabot moves slowly :)
21:03:18 <sclv> i never knew that :t didn't work in msg as such. i just thought it worked inconsistently in general.
21:03:23 <Guest55594> So it needs to be global since that's the only way I can pass it
21:03:31 <Guest55594> so for it to be global it must be evaluated imediately
21:03:43 <elliott> 99.9% of the credit goes to mokus_ for actually maintaining lambdabot's codebase, btw; I just run the thing (patched a little)
21:03:52 <sclv> i also see \bot now messages me in private to tell me i have new messages
21:04:38 <elliott> also, caveat: it's running a stock L.hs; lens and stuff aren't there yet, b/c of some changes in the handling (Safe Haskell-related stuff) the old L.hs won't work directly. I figure I'll add stuff back piece by piece, if you miss something sorely ping me and I'll add it... also while I'm at it, @check should work now
21:05:00 <elliott> (er, L.hs is the file that contains all of the imports and definitions for > evaluation)
21:05:03 <Saizan> @check (==)
21:05:07 <lambdabot>   mueval-core: Time limit exceeded
21:05:22 <elliott> sclv: yeah, that's an upstream change... can probably be tweaked
21:05:23 <shachaf> @let mate = True
21:05:23 <lambdabot>  Defined.
21:05:24 <shachaf> @check mate
21:05:27 <lambdabot>   +++ OK, passed 1 tests.
21:05:33 <Guest55594> so how should I force strictness on the IORef
21:05:35 <sclv> oh i like it
21:05:37 <Cale> elliott: Maybe you do need my change to mueval
21:05:37 <Guest55594> ohwait
21:05:39 <elliott> hm, that timeout looks like the problem Cale was experiencing
21:05:44 <Guest55594> you answered that I just didn't see the ' and was confused
21:05:48 <elliott> Cale: yeah, do you have a patch?
21:05:52 <elliott> should submit it to gwern ideally I guess
21:06:26 <elliott> alternatively just tell me what part needs changing, I haven't looked at the mueval code :)
21:06:39 <Cale> elliott: Just look in watchdog.hs, there's a derpy threadDelay in there which isn't based on anything at all and kills things after an annoyingly short period of time.
21:06:44 <shachaf> I patched mueval to work with UTF-8 properly!
21:06:50 <shachaf> But it looks like you don't need that patch.
21:06:57 <shachaf> Oh, and that threadDelay is just ridiculous.
21:07:20 <Cale> elliott: I just changed it to something large instead, like a minute or so.
21:07:30 <elliott> alright
21:07:42 <elliott> shachaf: well, UTF-8 is broken right now!
21:08:10 <Cale> I was never certain why utf-8 wasn't working in the first place
21:08:13 <sclv> @check \x -> map (+1) x == (reverse . map (+1) . reverse) x
21:08:16 <lambdabot>   +++ OK, passed 100 tests.
21:08:21 <shachaf> elliott: Yes, but is $ mueval --no-import -e 'let λ = 5 in λ' # broken?
21:08:26 <Cale> iirc, it was working back when dons was running the bot
21:08:36 <elliott> Cale: your LC_ALL was C or something, probably
21:08:42 <elliott> I had to set it to C.UTF-8 to get it to work when testing
21:09:00 <elliott> Cale: hm, it's 4.9 seconds, looks like
21:09:05 <Cale> yeah, lol
21:09:13 <elliott> at least that's what wolfram alpha tells me 7 * 700000 microseconds is :)
21:09:22 <elliott> 5 seconds seems like it should be enough, but I'll up it to 30 seconds
21:09:24 <Cale> I don't think whoever wrote that code understood the units that threadDelay was in
21:09:46 <ethoma> Has anyone written a chess engine in Haskell?
21:09:48 <shachaf> Cale: I don't think multiplying by 700000 comes from misunderstanding the units...
21:10:12 <sclv> threadDelay has irritating units
21:10:21 <sclv> plus it therefore has a v. short upper bound
21:10:23 <Claudius1aximus> Guest55594: sure, glut's callbacks don't have extra arguments - but you don't need arguments when you can partially apply your callback functions ; something like  main = do { r <- newIORef initialState ; ... ; displayCallback $= display r ; ... }
21:10:35 <sclv> i've wrapped it every time I needed it more than once in a project
21:10:40 <Cale> shachaf: Well, why wouldn't you write something like 5 * 10^6? (or 4.9 * 10^6)
21:11:12 <elliott> @check (==)
21:11:15 <shachaf> Why wouldn't you write 5e6? Because http://hackage.haskell.org/trac/ghc/ticket/7266 isn't merged yet!
21:11:15 <lambdabot>   +++ OK, passed 100 tests.
21:11:18 <elliott> yay
21:11:19 <Guest55594> yeah I had asked somewhere else
21:11:28 <Guest55594> I forgot that you could pass the same value and it would actually change
21:11:39 <Cale> elliott: That timeout is completely unrelated to the actual timeout which is set on the commandline, and supercedes it -- it's like a maximum possible timeout value.
21:11:40 <Guest55594> so all is well with the world
21:11:42 <shachaf> Cale: Anyway it looks like some sort of confusion but I doubt whoever wrote it thought threadDelay used 1/700000th of a second units.
21:11:48 <arkeet> elliott: huh? why does that pass?
21:11:54 <elliott> arkeet: because it defaults to () -> () -> Bool
21:11:57 <shachaf> Cale: 4.9 * 10^6 isn't an Int.
21:11:58 <elliott> > print
21:11:59 <lambdabot>   <() -> IO ()>
21:12:01 <elliott> > (==)
21:12:01 <lambdabot>   <() -> () -> Bool>
21:12:02 <arkeet> oh. I'm dumb.
21:12:04 <shachaf> But 4.9e6 is, with my extension!
21:12:08 <Cale> shachaf: good point :)
21:12:09 * arkeet thought Bool -> Bool -> Bool
21:12:16 <arkeet> @check (==) `asAppliedTo` False
21:12:17 <lambdabot>   Not in scope: `asAppliedTo'
21:12:21 <Claudius1aximus> Guest55594: not quite - the value doesn't change, but an ioref is a (fixed) value that references another value (which you can replace)
21:12:23 <Cale> shachaf: Well, I'm imagining someone experimenting randomly with it
21:12:33 <Guest55594> yeah I know
21:12:34 <arkeet> @check (==) : :Bool -> Bool -> Bool
21:12:34 <lambdabot>  <unknown>.hs: 1: 8:Parse error in expression: (==) :
21:12:35 <Guest55594> that's what I meant
21:12:37 <Claudius1aximus> :)
21:12:37 <arkeet> @check (==) :: Bool -> Bool -> Bool
21:12:40 <lambdabot>   *** Failed! Falsifiable (after 1 test):
21:12:40 <lambdabot>  True
21:12:40 <lambdabot>  False
21:13:31 <elliott> also, I guess there's new commands? like, uh, I dunno
21:13:45 <arkeet> > 1 2
21:13:45 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
21:13:45 <lambdabot>    arising f...
21:13:49 <arkeet> sweet.
21:14:07 <elliott> @yow works again, at least.
21:14:07 <lambdabot> YOW!!  What should the entire human race DO??  Consume a fifth of
21:14:08 <lambdabot> CHIVAS REGAL, ski NUDE down MT. EVEREST, and have a wild SEX WEEKEND!
21:14:14 <elliott> thanks.
21:14:27 <Guest55594> @yow?
21:14:27 <lambdabot> I'm having a tax-deductible experience!  I need an energy crunch!!
21:14:31 <elliott> arkeet: as I said, the L.hs is completely stock right now, going to add things piece by piece since the old one would be incompatible
21:14:36 <arkeet> I see.
21:14:36 <johnw> elliott: that makes a lot of sense
21:14:45 <arkeet> which ghc is it on now?
21:14:48 <elliott> 7.6.3!
21:14:51 <arkeet> cool
21:14:58 <arkeet> now let us add custom data declarations
21:14:59 <elliott> I had to compile it. from source. inside a chroot. because the binary wants an older GMP.
21:15:05 <arkeet> gross
21:15:21 <arkeet> or,
21:15:24 <arkeet> I've had that problem before
21:15:25 <elliott> arkeet: yeah, I would like to. I would also like @type to do something other than run your input through some text replacements and then pipe it into `ghci`
21:15:29 <arkeet> I just installed an older gmp.
21:15:58 <elliott> Guest55594: btw, you don't need unsafePerformIO in that paste
21:16:10 <elliott> you can do: idleCallback $= doUpdateGame myRef
21:16:41 <Guest55594> I know, I don't have it now
21:16:47 <elliott> ah, ok
21:16:55 <elliott> sorry, got backlogged in all this lambdabot talk :)
21:16:57 <Guest55594> you're the third person
21:17:51 <elliott> arkeet: I should talk to mikeplus64 about his evaluation server thing. I understand it's a lot faster than @run, maybe that would be a good path forward to clean up the Haskell evaluation stuff and add functionality.
21:20:04 <arkeet> elliott: sounds vaguely similar to what hdevtools does
21:21:01 <shachaf> hdevtools is more of a typechecking server.
21:21:47 <johnw> elliott: that sounds extremely close to what fpcomplete is doing
21:22:47 <elliott> johnw: with a focus on security?
21:22:56 <elliott> it's a pretty simple task in theory, at least.
21:23:00 <johnw> we provide security by sandboxing the code we execute, yes
21:23:03 <arkeet> shachaf: I know.
21:23:18 <elliott> you basically just write a GHCi that takes network requests and puts limits on the individual lines it runs.
21:23:29 <elliott> and have the whole thing appropriately Safe Haskell-y sandboxed.
21:23:51 <johnw> well, we have a GHC API service running in the sandbox
21:24:02 <johnw> like hdevtools, except we compile too
21:25:41 <johnw> we don't use safe haskell, though
21:27:05 <johnw> you know... engineering wise, it would be almost trivial to rig a mubot that does @type, hoogle queries, and code execution, by having it talk to a session on our servers...  that might even be fun.  Don't think it would make it into the schedule, but maybe it's trivial enough to do...
21:27:12 <mikeplus64> @hackage repl
21:27:12 <lambdabot> http://hackage.haskell.org/package/repl
21:27:17 <mikeplus64> arkeet:
21:27:41 <mikeplus64> that's my thing, it does no memory limiting and the server isn't there yet, because i don't have much time to work on it atm
21:28:02 <elliott> mikeplus64: yeah, that's what I was talking about, shachaf told me about it a while ago
21:28:22 <arkeet> cool
21:28:26 <shachaf> hikeplus64
21:28:31 <elliott> I was thinking a version of it (or at least something along the same lines) would work well to replace lambdabot's current evaluation stuff, which is crufty in a bunch of ways
21:28:44 <shachaf> johnw: On your servers? Isn't that a bit much?
21:28:45 <johnw> actually, now that I think about it, I do have this code already -- I've been writing it for our unit tests.  All that it lacks is an IRC frontend
21:28:45 <mikeplus64> yeah, that was the intention originally
21:28:59 <elliott> the replacing Unicode stuff with "x" worries me a little :P
21:28:59 <johnw> shachaf: not really, every time you click the "run" button in one of our tutorials, the same thing is happening
21:29:13 <johnw> and lambdabot queries are very likely <10k a day
21:29:21 <shachaf> I'm talking about latency.
21:29:49 <johnw> the first query after a long lull would be a bit pokey (though it's faster than you might think)
21:29:51 <mikeplus64> elliott: yeah that's to get around haskell-src-exts's parser not understanding unicode :(
21:30:00 <johnw> like, if you go to a tutorial right now and click "Run", the answer comes back to you pretty fast
21:30:13 <mikeplus64> but the actual thing sent to ghc still has its unicode
21:30:16 <johnw> and we're not spinning up the machinery for the evaluation until the moment you first click the button
21:30:29 <elliott> mikeplus64: oh, so different Unicode definitions aren't all merged into one "x"? ok
21:30:34 <elliott> that was what it looked like which was worrying :)
21:31:33 <elliott> mikeplus64: do you know how @type works in lambdabot right now? it's mildly horrifying
21:31:38 <mikeplus64> haskell-src-exts is used to verify that something is actually a statement or expression or something before sending it to ghc, so it's kinda safe to mangle the input given to it, but for e.g. unicode operators it might break :(
21:31:43 <mikeplus64> elliott: nope
21:32:00 <shachaf> Are you sure it's safe?
21:32:06 <elliott> mikeplus64: https://raw.github.com/mokus0/lambdabot/master/lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/Type.hs
21:32:24 <shachaf> I,I infiλl
21:32:45 <elliott> mikeplus64: tl;dr: it takes your input, sanitises it a little (with a function instead of a regex because the regex wouldn't work in versions older than 6.4), and pipes it to ghci with ":t" stuck in front of it
21:32:49 <elliott> and then mangles the output
21:33:04 <mikeplus64> scary stuff
21:33:28 <mikeplus64> elliott: http://hackage.haskell.org/packages/archive/repl/1.1/doc/html/src/Language-Haskell-Repl.html ctrl f "parseStmt"
21:33:52 <elliott> mikeplus64: right
21:33:58 <johnw> with our server, you wouldn't need to worry about whether the evaluation was safe or not.  We fully allow you to do callProcess "run" ["-fr", "/"], if you want to.  When the sandbox stops working, we just kill it and spin up a new one
21:34:00 <elliott> so after it figures out what it's going to do it sends the original string unmangled
21:34:05 <mikeplus64> yeah
21:34:07 <johnw> s/run/rm
21:34:24 <mikeplus64> so the infi<lambda>l won't work
21:35:09 <mikeplus64> elliott: what is *really* gross is how i handle something like fix error
21:35:17 <mikeplus64> it catches 2 exceptions and gives up
21:35:37 <arkeet> > fix error
21:35:38 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
21:35:43 <arkeet> my favourite.
21:36:21 <mikeplus64> mueval doesn't care about exceptions because it has a seperate process
21:36:45 <elliott> mikeplus64: mueval just reads off 1024 characters of exception and then kills it, I think :)
21:36:55 <shachaf> > fix show
21:36:56 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
21:37:09 <mikeplus64> elliott: yeah pretty much
21:37:23 <mikeplus64> if only there was a "fix catch", lol
21:37:38 <shachaf> @yhjulwwiefzojcbxybbruweejw
21:37:38 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
21:38:06 <elliott> here's another horrific lambdabot thing: https://github.com/mokus0/lambdabot/issues/63
21:38:27 <elliott> (this made me very confused when testing my test bot in a channel named after it)
21:38:33 <mos_basik> is there a equivalent "empty character" just like "" is the empty string?
21:39:22 <mikeplus64> mos_basik: no
21:41:06 <mos_basik> oh, i just realized I think I can use the empty list instead []
21:41:17 <elliott> [] is also ""
21:43:32 <dmwit> Guest55594: Allocate an IORef in main and let your GL callbacks close over it.
21:46:53 <arkeet> Guest55594: also, write doUpdateGame :: IO () and then idleCallback $= Just doUpdateGame
21:47:46 <shachaf> For Satan finds some mischief still / For idle callbacks to do.
21:51:26 <genisage> How could I go about having a data type like data Link = Link { val :: Int, a :: Link} and two links that each point to the other?
21:52:10 <genisage> I sort of asked this earlier, but I think this is a much clearer question.
21:52:47 <shachaf> let x = Link 1 y; y = Link 2 x
21:52:48 <shachaf> in ...
21:53:22 <genisage> Will that work?
21:53:36 <genisage> It seems like y wouldn't be defined there.
21:53:43 <shachaf> Try it.
21:54:42 <arkeet> let bindings are recursive.
21:54:54 <latro`a> corecursive, even
21:55:02 <arkeet> all the same in haskell. =(
21:55:18 <genisage> That's neat, thanks.
21:55:20 <latro`a> (lispy folks might appreciate the distinction)
21:55:39 <johnw> hey latro`a, ltns
21:55:49 <latro`a> ...?
21:55:55 <johnw> haven't see you in a while
21:56:01 * tabemann had to get used to let bindings being recursive, coming from OCaml, where they are only recursive if you explicitly state let rec
21:56:04 <latro`a> I lurk in here mostly
22:03:05 <shachaf> @ty id %~ id
22:03:06 <lambdabot>     Not in scope: `%~'
22:03:06 <lambdabot>     Perhaps you meant `%' (imported from Data.Ratio)
22:03:09 <shachaf> "whoopse"
22:03:38 <arkeet> aw
22:03:48 <mikeplus64> :t (<<%@~)
22:03:49 <lambdabot> Not in scope: `<<%@~'
22:04:34 <mikeplus64> @t (<<%@~)
22:04:34 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
22:04:38 <mikeplus64> @ty (<<%@~)
22:04:39 <lambdabot> Not in scope: `<<%@~'
22:05:02 <mikeplus64> oh well we miss out on the exploding fish operator
22:05:11 <elliott> mikeplus64: it's not there, am adding stuff to L.hs incrementally
22:05:31 <shachaf> elliott hates lens
22:05:51 <elliott> it's true. I was always the number three committer. I could never be like shachaf and edwardk and for that I resent them
22:05:59 <mikeplus64> lol
22:06:02 <elliott> tomorrow, lambdabot will have... fclabels!!!
22:07:11 <mikeplus64> i find myself disliking the kitchen sink and mass production line approach of lens. then adding more utensils to it
22:08:25 <shachaf> elliott is going to publish a new library that uses symmetric lenses
22:08:33 <shachaf> "his favourite"
22:08:40 <sclv> yes i like my lenses handcrafted
22:08:43 <sclv> artisinal even
22:08:52 <dolio> I heard elliott never does any work.
22:09:08 <dolio> And it's a WONTFIX.
22:09:13 <sclv> i buy them from only the most skilled lens craftsmen
22:09:44 <sclv> each invocation of a lens is unique, an unreproducable experience.
22:09:47 <elliott> sclv: well, shachaf certainly has the anal part of artisanal down.
22:09:55 <sclv> needless to say, this violates referential transparency
22:10:45 <sclv> but who can place a judgement on art
22:11:02 * tabemann just accidentally managed to use up *all* the RAM on his machine by inputting "foldl (+) [1..]" into GHCI
22:11:26 <tabemann> foldl (+) 0 [1..] I mean
22:11:35 <elliott> > foldl (+) 0 [1..]
22:11:39 <lambdabot>   mueval-core: Time limit exceeded
22:11:42 <mikeplus64> sclv: the question is whether you're ready to break the rules, to live across the edge
22:12:06 <dolio> I have heap limits set, because it annoys me whenever I do that kind of thing.
22:12:26 <dolio> Also from repeatedly freezing my computer testing out that stack bug.
22:12:50 <elliott> computers are for crashing, dolio
22:12:56 <Cale> tabemann: Yeah, that's to be expected. It will accumulate a large expression tree which it'll never get around to producing as the result, because the list has no end.
22:13:05 <tabemann> Cale: yeah, I know
22:13:07 <dolio> I also have custom limits that let me use hundreds of thousands of file descriptors if I want.
22:13:15 <mikeplus64> _head = if unsafePerformIO randomIO then Control.Lens._head else Control.Lens._last
22:14:01 <shachaf> dolio: File descriptors are a non-renewable resource!
22:14:14 <dolio> Peak file descriptors is a myth.
22:14:19 <tabemann> are heap limits a GHC thing or an OS thing?
22:14:22 <shachaf> It's because of people like you that we'll run out well before 2038.
22:14:39 <dolio> GHC has a setting for it, too, but I use the OS limits.
22:14:55 <dolio> Because the bug I mentioned was circumventing GHC's heap limits.
22:15:08 <tabemann> I can't use the OS limits, as I tend to use up *lots* of RAM on my machine due to Iceweasel
22:15:22 <tabemann> unless I can have different OS limits for different processes...
22:15:34 <dolio> I'm talking like an 8 GB limit per process. Do you use more than that?
22:16:01 <tabemann> considering I've got 8 GB of actual RAM on here... and yes, I can without difficulty get Iceweasel to use all of that
22:16:04 <dolio> Just enough to keep a rogue haskell program from swap thrashing my machine.
22:17:04 <tabemann> usually if Iceweasel reaches the 8 GB mark I exit it and restart it (can we say garbage collection?)
22:17:17 <tabemann> thank you for saving tabs
22:22:52 <sclv> @remember dolio Peak file descriptors is a myth.
22:22:53 <lambdabot> I will remember.
22:30:57 <Ralith> I'm building some C bindings on Windows, and I need to link with the system mingw's libstdc++, not the haskell platform mingw. Any way to sort out the search paths so that this Just Works?
22:31:16 <Ralith> in general I'd like the haskell platform mingw to be ignored entirely
22:42:17 <lispy> Ralith: If you're not using Haskell then it should be a simple matter of setting your PATH
22:43:01 <lispy> Ralith: If you're invoking ghc and letting it invoke mingw, then I think the path might still influence it, but I'm not sure.
22:44:29 <Ralith> lispy: I'm invoking cabal from within system mingw, and I have stdc++ in extra-libraries
22:52:00 <Ralith> lispy: any tips?
22:53:10 <Ralith> lispy: I speculate that ghc defaults to searching the haskell platform mingw for libs first
22:53:46 <johnw> lispy: do you know why one would use Orc when we have async?  They seem to overlap quite a bit
22:54:13 <Sonarpulse> well asked this stuff in #haskell-game, but it seems pretty quite there: I am using the FFI fro the first time, making bindings for enet, a networking library I forked here: https://github.com/Ericson2314/enet-haskell-bindings
22:54:52 <Sonarpulse> it has a *.c src in the root, headers in ./src, and a autoconf (yuck!) build system
22:55:10 <Sonarpulse> where would be most "proper" to put the cabal project file?
22:55:20 <Sonarpulse> or haskell src?
22:55:37 <johnw> I've run into this issue before, Sonarpulse
22:55:50 <johnw> my answer was to reverse-engineer the autoconf system, and rewrite it in Cabal
22:55:56 <Walther> Btw, how are Haskell's capabilities in audiovisual stuff
22:56:10 <Sonarpulse> ah ok. Makefile.in seems pretty basic
22:56:12 <johnw> (that particular autoconf setup, I mean, not autoconf itself)
22:56:12 <Walther> Think demoscene
22:56:17 <Sonarpulse> gotcha
22:56:33 <johnw> yeah, in my case (hlibgit2), I just had to add a few configuration flags, pass some defines down, etc.
22:56:48 <johnw> pain in, I have to update it with each new version that comes out
22:56:50 <Sonarpulse> ok
22:56:57 <Sonarpulse> what about haskell source files?
22:56:58 <johnw> but then it just "works" for every Haskeller
22:57:04 <Walther> I kinda want to learn a bit about computer generated graphics and audio, and on the other hand I'd love to learn Haskell - but would it make any sense to try combine those goals
22:57:04 <johnw> Haskell source files are seamless
22:57:11 <johnw> download the hlibgit2 tarball and see what I did
22:57:17 <Sonarpulse> ok
22:57:22 <johnw> actually, I ported it from CMake, not autoconf
22:58:07 <Sonarpulse> https://github.com/fpco/gitlib/tree/master/hlibgit2
22:58:12 <Sonarpulse> ah, so you used submodule
22:58:29 <Sonarpulse> that seems better
22:58:46 <johnw> yes, so I can track the exact version of the remote project that I'm supporting
22:59:23 <Sonarpulse> I think i will adapt that approach
22:59:39 <johnw> have you started writing your FFI bindings yet?
22:59:47 <Ralith> Walther: haskell is great for experimenting with graphics, though other options may be easier if you're after realtime 3D
22:59:58 <Ralith> there's probably some audio libs for haskell out there too
23:00:03 <Sonarpulse> no
23:00:06 <Sonarpulse> divin' in
23:00:08 <Walther> Ralith: Yeah, definitely won't be "import pygame" :P
23:00:13 <johnw> Sonarpulse: you might be interested in my c2hsc utility
23:00:18 <Sonarpulse> should i call it henet?
23:00:19 <johnw> it helps you get a "head start"
23:00:22 <Sonarpulse> ah ok
23:00:27 <johnw> henet is a fine name
23:00:32 <Sonarpulse> soudns good!
23:00:40 <Sonarpulse> there actually are out of date bindings
23:00:40 <Ralith> Walther: pygame is certainly not an easier option for 3D graphics
23:00:42 <Walther> Just wondering if it is actually *doable* or *reasonable* at all to try learn computer-generated audiovisuals in Haskell, or would I be way better off with something else
23:00:48 <Sonarpulse> made with some abandoned tool like c2hsc
23:00:58 <Sonarpulse> actually no
23:00:59 <Ralith> Walther: it is doable and reasonable.
23:01:00 <Sonarpulse> it is that
23:01:04 <Sonarpulse> or sorry
23:01:08 <Sonarpulse> maybe it made .chs files?
23:01:10 <johnw> c2hsc takes a bunch of header files and spits out FFI bindings files based on Bindings-DSL
23:01:16 <johnw> it's not the same tool as c2hs
23:01:23 <Sonarpulse> does that make chs files?
23:01:28 <Sonarpulse> or use those?
23:01:34 <johnw> it makes .hsc files
23:01:45 <johnw> if you look in the hlibgit2 tarball, you'll see an examlpe
23:01:51 <johnw> check out repo.h vs Repo.hsc
23:03:17 <johnw> err, repository.h vs. Repository.hsc
23:04:10 <Sonarpulse> ok
23:06:36 <lispy> Ralith: I'd use --verbose=3 and try playing with PATH
23:07:23 <lispy> johnw: I'm not sure. I thought they were a fair bit different in how you think about them.
23:07:39 <lispy> johnw: Orc is basically a concurrent list monad, right?
23:07:43 <johnw> right
23:07:58 <Ralith> lispy: PATH only contains bin/ and libs/extralibs/bin/, neither of which contain gcc or stdc++
23:08:08 <Ralith> (as far as HP paths are concerned)
23:09:12 <Sonarpulse> johnw: http://hackage.haskell.org/package/HGamer3D-Enet-Binding-0.2.0
23:09:28 <Sonarpulse> http://hackage.haskell.org/packages/archive/HGamer3D-Enet-Binding/0.2.0/doc/html/src/HGamer3D-Bindings-Enet-ClassEnet.html
23:09:42 <Sonarpulse> using "C->Haskell Compiler"
23:10:31 <Sonarpulse> I dunno, whoever did this HGamer3D stuff put in a ton of work, but it's WAY too monolithic
23:10:41 <Sonarpulse> and it passed completely under the radar
23:11:10 * lispy saw HGamer but couldn't really figure out how to get started
23:11:29 <Sonarpulse> they got a home page, demo on youtube...
23:11:50 <Sonarpulse> i dunno
23:11:53 <Sonarpulse> tragedy
23:12:01 <Sonarpulse> so much effort gone to waste
23:12:34 <qwerty1793> hi, is there a way to specify a type / data that is, for example, a list of integers which must have even length?
23:13:00 <Sonarpulse> ^ list of 2-int tuples? :D
23:13:14 <Sonarpulse> otherwise I _think_ you need dependant types
23:13:31 <Ralith> lispy: --verbose=3 confirms that ghc is calling the haskell platform gcc
23:13:59 <lispy> Ralith: and it sounds like picking that gcc is wired in
23:14:07 <neworder> I wonder why are there so many people on the haskell channel
23:14:08 <qwerty1793> Sonarpulse: so I want that [1,2,3,4] and [] are valid, [5] is not
23:14:09 <neworder> Lol
23:14:24 <Ralith> lispy: oh?
23:14:33 <neworder> Do you all use it for your work?
23:14:59 <lispy> Ralith: if it's not in PATH and ghc found it, then I think it's likely ghc has a config file or script that points to it.
23:15:00 <Sonarpulse> qwerty1793: with normal ADTs you cannot control depth
23:15:07 <neworder> Any motivation for me to learn haskell? =)
23:15:18 <Ralith> lispy: ahah: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/options-phases.html#replacing-phases
23:15:25 <lispy> neworder: so you'll understand what we're talking about better? ;)
23:15:27 <Sonarpulse> but [(1,2),(3,4)] will get you a collection of even numbered Integers
23:15:37 <elliott> neworder: you should learn Haskell because you find it interesting.
23:15:37 <Sonarpulse> in any order
23:15:41 <Sonarpulse> not as clean
23:15:43 <elliott> if you don't, then no loss
23:15:46 <Sonarpulse> for using standard library stuff
23:15:53 <Ralith> lispy: ...but I'm already passing -pgml g++ and it's still using the haskell package gcc
23:15:57 <neworder> hahaha
23:16:19 <neworder> Can I earn through it? That's the real question! =D
23:16:30 <qwerty1793> Sonarpulse: are there any other properties that I can control - like perhaps the second entry must be even or the list must just be a permutation of the numbers 0..n?
23:16:41 <lispy> Ralith: if you try 'which gcc' which does it find it and which one is it?
23:16:52 <elliott> neworder: there are Haskell jobs. they are not numerous, but I understand they have a tendency to pay well
23:16:53 <Sonarpulse> ^ qwerty, read about dependant types
23:17:04 <qwerty1793> ok thanks
23:17:08 <Sonarpulse> which haskell DOESN'T really have
23:17:15 <elliott> I suggest not learning Haskell with the sole goal of getting paid to write it, though.
23:17:28 <Sonarpulse> IRCC, but there extensions, libraries, etc to fake it
23:18:10 <neworder> elliott: Haha, I see. I rather learn laravel and earn some money :P
23:18:12 <lispy> Ralith: it's late here. I need to crash. Good luck.
23:18:37 <Ralith> lispy: it seems like -pgml should be overriding the search entirely...
23:18:58 <Ralith> the gcc in path is the system gcc
23:19:21 <elliott> neworder: go for it
23:19:34 <neworder> haha sure =)
23:20:19 <neworder> http://laravel.com/
23:20:27 <neworder> just advertizing :P
23:20:40 <elliott> please don't :P
23:21:00 <elliott> though I doubt advertising a PHP framework here is a very effective strategy anyway...
23:21:04 <neworder> haha okayy
23:21:20 <neworder> hehe
23:21:28 <neworder> Functional vs Oop
23:21:36 <neworder> oop gets job done faster, maybe?
23:21:49 <elliott> are you just trolling? :/
23:21:57 <neworder> nope nope
23:22:05 <neworder> Have fun with haskell
23:22:10 <neworder> got to go
23:24:14 <Ralith> lispy: ah, it looks like the ghc-options: bit from the binding library wasn't propogating
23:25:26 <Ralith> Is there any way I can, in a cabal package definition, specify that a certain option must be passed to GHC when a program is linked with this library's extra-libraries?
23:26:44 <elliott> mikeplus64: so, repl doesn't have any kind of persistence of definitions to disk as it stands, right?
23:29:13 <mikeplus64> elliott: no, not to disk
23:29:25 <mikeplus64> elliott: but since statements are recognised as such it shouldn't be too hard to add
23:31:29 <elliott> mikeplus64: right
23:47:55 <elliott> mikeplus64: I guess selective @undefine would be pretty easy to add on to that too, given that it's already parsing things
23:48:02 <elliott> (though I suppose the Unicode mangling would be problematic)
23:50:26 <mikeplus64> elliott: you can selectively undefine things
23:50:47 <elliott> oh, that functionality is already in?
23:50:59 <mikeplus64> yeah
23:51:07 <elliott> cool
23:51:08 <mikeplus64> unless i haven't updated the package on hackage with that yet
23:51:20 <elliott> does it handle data types and stuff? (e.g. when they have instances)
23:51:29 <mikeplus64> yeah
23:51:35 <elliott> nice
23:52:02 <elliott> what about... removing a single instance of a type?? /me aims for the sky :P
23:52:19 <mikeplus64> actually i'm not sure how it'll handle e.g. class A ...; instance A ...; :undef A; class A
23:52:34 <mikeplus64> it should remove the instance and class
23:52:52 <mikeplus64> elliott: nope, can't do that, it just undefines names
23:53:21 <mikeplus64> elliott: http://hackage.haskell.org/packages/archive/repl/1.1/doc/html/src/Language-Haskell-Repl.html ctrl f Undefine
23:54:29 <elliott> heh, clever implementation
23:55:03 <elliott> I'll probably try fiddling with the code and seeing how much work it'd be to get it into something lambdabot could use directly
23:55:23 <elliott> seems like all it really needs to beat out the current stuff is persistence of definitions
23:56:32 <mikeplus64> yeah it should be pretty simple
23:59:01 <elliott> hm, I guess buildExpr is relying on the expression being pre-parsed so you can't do silly things like ()) ++ "abc" ++ (""?
23:59:06 <elliott> I guess it would be harmless anyway
