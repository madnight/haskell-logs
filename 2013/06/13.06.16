00:16:03 <elliott> mikeplus64: do you know what version of haskell-src-exts you observed failing on unicode in lets? i'm curious since googling shows that it at least claims to support unicode identifiers properly, so i'm wondering if it might be a build issue or such
00:17:00 <elliott> though it does seem to be true for my installed version :/
00:22:21 <analog> hy everyone , is the *.prof file format documented? and if so where can i find the documentation ?
00:23:16 * hackagebot hack2-contrib 2013.6.16 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2013.6.16 (JinjingWang)
00:23:18 * hackagebot hack2-contrib-extra 2013.6.16 - Hack2 contrib extra  http://hackage.haskell.org/package/hack2-contrib-extra-2013.6.16 (JinjingWang)
00:38:47 <Lethalman> is izbicki blogger about hlearn here?
00:38:59 * Lethalman wants to rant about gray text in blog posts :-(
00:41:32 <olalonde> :(
01:37:56 <adnap> I have two imports for the same module. One is qualified, and the other is unqualified, but only imports a single function, which is an infix operator. GHC complains that the unqualified import is redundant with -Wall, but I don't think it is, since it allows me to call the operator without qualifying it. How can I make this warning go away without qualifying the operator?
01:38:48 <shachaf> In the battle of GHC vs. adnap, I'm going to bet on GHC.
01:38:58 <shachaf> Have you tried taking out that import and seeing whether it still compiles?
01:42:06 <nanothief> adnap: I am not getting that behaviour you describe. See http://hpaste.org/89995 - no warnings with -Wall
01:56:32 <tomjack> what, if anything, should be Future's Eq instance? (type Future = (,) Time) `(==) = liftA (==)`?
01:58:21 <tomjack> oh, I found Reactive's. makes sense it shouldn't be liftA (==)
02:00:06 <tomjack> oh, obviosuly liftA (==) makes no sense..
02:00:39 <tomjack> even if I had liftA2 like I wanted
02:01:14 <FreeFull> == has to return a Bool
02:01:41 <tomjack> yeah
02:03:22 * hackagebot nemesis 2013.6.16 - a task management tool for Haskell  http://hackage.haskell.org/package/nemesis-2013.6.16 (JinjingWang)
02:03:24 <tomjack> ?pl \x y -> extract $ liftA2 (==) x y
02:03:27 <lambdabot> ((extract $) .) . liftA2 (==)
02:03:27 <lambdabot> optimization suspended, use @pl-resume to continue.
02:04:02 <shachaf> What are you trying to do?
02:05:45 <tomjack> not trying to do anything, that was just the strange Eq instance I'd imagined
02:06:44 <shachaf> Perhaps you mean ((==) `on` snd)?
02:07:54 <tomjack> oh, yes, (,) Time is really the meaning though
02:08:16 <tomjack> well, yes
02:08:55 <nanothief> tomjack: That type is equivalent to data Future a = Future a Time. The obvious Eq instance then is instance (Eq a) => Eq (Future a) where (Future a1 t1) == (Future a2 t2) = (a1 == a2) && (t1 == t2)
02:09:46 <shachaf> Which is already the Eq instance for tuples. I assume tomjack knows that.
02:10:06 <tomjack> I would have if I'd thought about it
02:10:14 <tomjack> thanks :)
02:20:10 <adnap> shachaf: I took out the unqualified import and it compiles. I don't really know why the code still words when calling the operator unqualified
02:20:20 <adnap> (compiles with no warnings)
02:20:44 <Ralith> adnap: if you pasted it, someone might be able to tell you.
02:20:49 <FreeFull> What operator?
02:25:57 <shachaf> I win by betting on GHC yet again.
02:26:37 <Taneb> is there anything that is an Alternative and a Monad, but not a MonadPlus?
02:28:50 <shachaf> Taneb: That depends.
02:28:54 <shachaf> What are the Alternative laws?
02:29:17 <Taneb> I think they're just the Monoid laws
02:29:31 <shachaf> What, no laws relating Alternative to Applicative?
02:29:38 <shachaf> Distribution or anything like that?
02:29:55 <Taneb> None documented in Control.Applicative
02:30:06 <shachaf> Right.
02:30:10 <shachaf> So I can't really tell you.
02:30:45 <Taneb> I'd assume fmap f (a <|> b) == fmapf a <|> fmap f b is a free theorem
02:31:19 <Taneb> s/pf/p f/
02:32:58 <Taneb> f <*> (a <|> b) == (f <*> a) <|> (f <*> b) seems to be true for []
02:33:48 <shachaf> That's getting better.
02:34:20 <shachaf> Is it an actual law? Who knows?
02:34:54 <shachaf> Does <*>/<|> give you a semiring or something like that? It probably ought to.
02:38:32 <Taneb> > [(+1), (*2)] <*> [0] <|> [(+ 1), (* 2)] <*> [0]
02:38:33 <lambdabot>   [1,0,1,0]
02:38:45 <Taneb> > [(+ 1), (* 2)] <*> [0, 0]
02:38:47 <lambdabot>   [1,1,0,0]
02:38:49 <Taneb> Damn
02:40:12 <Taneb> How does (<*>) form a monoid?
02:41:52 <shachaf> I would not phrase it in those terms.
02:42:08 <Taneb> Okay
02:42:15 <shachaf> But anyway you have two operations: liftA2 (,) :: F a -> F b -> F (a,b), and unit :: F ()
02:42:53 <shachaf> With a little bit of tuple juggling you can make it fit the regular monoid laws more or less.
02:43:07 <shachaf> Look at the original Applicative paper, I guess.
02:52:45 <Zariel> I want to mix my readerT with some STM to do a loop, something like this http://hpaste.org/89996
02:53:00 <Zariel> how can i get the types to work out? Using both the readerT with the stm? Do I need to add another monad transformer ontop of it?
02:55:25 <Taneb> shachaf, I am forced to conclude that (<|>) and liftA2 (,) do not form a semiring
02:55:45 <shachaf> Why?
02:55:53 <Taneb> > liftA2 (,) [0,0] [0,1]
02:55:54 <lambdabot>   [(0,0),(0,1),(0,0),(0,1)]
02:56:05 <Taneb> > liftA2 (,) [0,0] [0] <|> liftA2 (,) [1]
02:56:06 <lambdabot>   Couldn't match expected type `[(a0, b0)]'
02:56:06 <lambdabot>              with actual type `[b...
02:56:12 <Taneb> > liftA2 (,) [0,0] [0] <|> liftA2 (,) [0,0] [1]
02:56:13 <lambdabot>   [(0,0),(0,0),(0,1),(0,1)]
02:56:14 <shachaf> Maybe the law is good but []'s instance is broken.
02:56:56 <shachaf> Maybe it should be foo :: F a -> F b -> F (Either a b) or something?
02:57:02 * shachaf is just making things up, as you may have noticed.
02:57:50 <Taneb> It is a semiring for Maybe, though
02:58:39 <shachaf> Well, Maybe is a commutative monad.
02:58:50 <shachaf> Well, it's not being used as a monad here. But anyway that doesn't tell us much.
03:28:45 <merijn> Where can I get the source for 7.7? Do I need to grab it from github?
03:29:08 <merijn> I don't see any snapshots/source downloads on the GHC site anymore
03:29:27 <shachaf> 7.7 isn't a real version, just a name for released between 7.6 and 7.8
03:29:40 <merijn> shachaf: I know
03:29:44 <shachaf> git would be the place to get it, yes.
03:29:48 <shachaf> github is just a mirror, though.
03:29:59 <tunixman> t blackdog hello!
03:30:01 <shachaf> There are instructions at, uh...
03:30:02 <shachaf> @google ghc getting the source
03:30:05 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources
03:30:05 <lambdabot> Title: Building/GettingTheSources – GHC
03:30:14 <merijn> I just remember grabbing a .tar.gz of 7.7 sources from the GHC site, but those seem to have evaporated
03:30:31 <shachaf> Ah. Yes.
03:30:41 <shachaf> You're better off with the git repository anyway. :-)
03:30:44 <merijn> btw
03:31:03 <merijn> The last three links in the 3rd paragraph of the wiki seem to be spam?
03:31:18 <merijn> "  perlengkapan bayi |  hipnoterapi surabaya |  selai kacang"
03:31:28 <merijn> Pointing to odd domains...
03:31:41 <shachaf> Yep. I saw something in the mailing list about that...
03:32:03 <iamtakingiteasy> hello, i have a data type which can sonsist of booleans, strings and recursive arrays of this data type. also i have a typeclass which is desired to be a converter from built-in data types to this brand new data type. but here is the problem: instances of my data type for String and for [a] are overlapping each other. here is the illustration: http://paste.eientei.org/show/251/ . how to
03:32:09 <iamtakingiteasy> work-around this issue?
03:32:12 <iamtakingiteasy> s/sonsist/consist/
03:35:30 <shachaf> You could do what Show does.
03:36:09 <iamtakingiteasy> what Show is doing to address this issue?
03:36:21 <mauke> shachaf: that would require a Char instance
03:37:21 <merijn> iamtakingiteasy: The way Show does it is by having "instance Foo a" provided a function for [a] as well, then [a] defaults to using that
03:38:10 <shachaf> mauke: Ah, true, it isn't exactly parallel.
03:39:58 <merijn> I guess I just want master for a recent 7.7 snapshot?
03:40:54 <shachaf> Unless you want one of the other branches.
03:41:46 <merijn> I just want to replace my current 7.7 which doesn't build tagged et al. with a more recent one, according to byorgey's comments on tagged (and by extension lens, etc.) do build with a more recent 7.7
03:42:05 <iamtakingiteasy> hmm... then what could be done without introducing a JChar value constructor?
03:46:14 <k0ral_> Hello guys, I was wondering: are pure computations automatically parallelized by GHC, or am I supposed to tell it (e.g. via par/pseq) each time ?
03:46:35 <merijn> k0ral_: They are not automatically parallelised
03:47:02 <merijn> k0ral_: However, there is the Strategy monad (I think, at least?) which lets you do things more conveniently than manually sprinkling par/pseq
03:47:40 <k0ral_> merijn: which naturally leads me to the next question: why ? Isn't that sometimes obvious that a pure computation may be parallelized ?
03:47:42 <merijn> k0ral_: See Control.Parallel.Strategies
03:48:14 <merijn> k0ral_: Yes, but how do you decide what to parallelise?
03:48:40 <k0ral_> e.g. most "filter myPurePredicate myPureList" seem rather obvious to parallelize
03:48:41 <merijn> k0ral_: For example, I could compute a matrix in parallel, but why bother if I will only inspect three elements that I can compute lazily?
03:49:01 <merijn> Only if you actually need the entire list to be filtered
03:49:06 <shachaf> k0ral_: The answer is that no, it's not so easy.
03:49:10 <merijn> what if I only use the head of the filtered list?
03:49:15 <k0ral_> right, I see the yourp oint
03:49:16 <shachaf> Even if you do filter the entire list it's not so easy.
03:49:36 <shachaf> There is overhead to splitting things up.
03:49:36 <merijn> Also, the list case is not that simple, because you don't know how long the list is
03:49:47 <merijn> Hell, it might be infinite, then what?
03:49:59 <shachaf> But even with a strict array it's not easy.
03:50:08 <merijn> Agreed
03:50:28 <merijn> k0ral_: Anyway, as we've hopefully succesfully conveyed, it's just not that trivial for a compiler to know what to do :p
03:50:39 <k0ral_> I get the conflict with laziness, but why isn't that so easy for strict lists ?
03:51:00 <k0ral_> because of the overhead ?
03:51:01 <Ralith> k0ral_: because splitting the work up can increase runtime in many cases.
03:51:04 <merijn> k0ral_: There's overhead for splitting, you probably don't wanna compute a 5 element array in parallel
03:51:11 <k0ral_> all right
03:51:21 <shachaf> merijn: Or maybe you do, if the computation is expensive and independent.
03:51:22 <k0ral_> thank you for explaining
03:51:39 <k0ral_> I may now inhibit my parallelization frenzy
03:51:41 <merijn> k0ral_: Anyway, from what I remember seeing about Strategies in the past they're nicely high level and certainly much nicer than doing things directly
03:53:32 <gds>  iamtakingiteasy: Potentially stupid suggestion: Use ByteStrings instead of strings?
03:53:35 <gds> They're not lists...
03:55:13 <iamtakingiteasy> gds: could i use it then in a `toJValue "somestring"` notion?
03:55:34 <gds> There's a pragma that lets you write literal bytestrings...
03:55:41 <iamtakingiteasy> whoa
03:55:57 <gds> {-# LANGUAGE OverloadedStrings #-}
03:55:57 <gds>  
03:56:53 <gds> I don't know if this is considered good style, but it might possibly work :S
04:05:44 <merijn> whooo, time freeze my machine for an hour or two!
04:06:12 <merijn> errr, I mean, build ghc
04:12:59 <nanothief> I don't see why OverloadedStrings would be considered bad style. It is just generalizing what haskell does with numbers, but with strings. The default string format is pretty bad...
04:14:43 <cYmen> Greetings!
04:15:59 <yitz> iamtakingiteasy: yes the problem is that String overlaps with list. Why not use Text? (not sure why gds suggested bytestring, that's really for binary bytes, not text)
04:16:48 <shachaf> gds: Yes, please be careful not to mix ByteString up with text, especially when you're giving advice to others.
04:17:14 <yitz> iamtakingiteasy: yes, the other way would be to replace JString with JChar
04:17:16 <shachaf> There's an instance in Char8 but it's hopelessly broken and should not be encouraged.
04:17:26 <cYmen> I may be totally off but somehow I associate the haskell community with being generally knowledgeable on programming languages. That is why I am asking the following question here: Does anybody know of books or articles on how different aspects of programming languages affect aspects like extensibility and maintainability. I realize that these are not really technical issues but psychological or neurological ones.
04:17:59 <merijn> cYmen: I have seen a few studies on this, but most are hopelessly bad in terms of experiment design/analysis
04:18:15 <merijn> cYmen: I don't think there's any real "proper" scientific studies on this atm
04:19:02 <yitz> cYmen: yes, your application will definitely be more maintainable if you use a programming language.
04:19:07 <cYmen> Well, it would be pretty difficult....
04:19:24 <cYmen> Does assembler count?
04:19:27 <merijn> the ones I have seen suffer from critically flawed test subject groups (i.e. to small, to biased, to unrepresentative), flawed studies (i.e. ridiculous definitions of extensibility/maintainability, trivial code bases and very artificial issues)
04:20:02 <cYmen> Yes, that applies to everything I have been able to find so far, as well.
04:20:19 <elliott> yitz++
04:20:57 <k0ral_> I don't know if such a thing can decently be asked, but is there any chance some people would accept to review my whole code (~1000 lines) ? I'd like to have experts point of view on my design choice
04:21:53 <yitz> nanothief: imho OverloadedStrings is an ugly hack, but right now it's the only way to use string literals for Data.Text.
04:22:52 <Igloo> yitz: What would a non-ugly-hack be?
04:22:54 <yitz> nanothief: the reason is that it's too general, and it moves error from compile time to run time, which partially negating one of the most important motivations for using haskell in the first place.
04:23:11 <Igloo> Ah, OK
04:23:14 <merijn> Semi-related there was a paper/post-mortem analysing how formal methods benefited and/or harmed the process of implementing the software for the Maeslantkering in Rotterdam
04:23:20 <nanothief> yitz: I was unaware of this, can you give an example of this?
04:23:38 <yitz> Igloo: a way to specify at *compile* time that string literals should be typed as Text rather than String. there are many ways that could be done.
04:23:55 <shachaf> yitz: For types that are (almost) isomorphic to String it doesn't matter so much about errors.
04:24:03 <merijn> nanothief: If the IsString instance doesn't return a valid data type for every possible string it can result in runtime errors
04:24:16 <shachaf> But of course it's abused a lot.
04:24:49 <nanothief> but isn't that the same for Num, eg if there is a num instance that fromInteger isn't complete, the same issue will occur. How is OverloadedStrings worse than this?
04:24:56 <yitz> nanothief: sure. the xml-types library defines an IsString instance for XML names that will cause you program to fail at *runtime* if there is a syntax error in the XML namespace in the string.
04:25:09 <merijn> nanothief: There's less temptation to implement a partial fromIntegral
04:25:25 <shachaf> merijn: I am very tempted to have natural numbers. :-(
04:25:37 <elliott> within haskell, there is all temptation
04:25:40 <merijn> shachaf: Let the evil flow through you!
04:25:57 <merijn> nooooooooooo :(
04:26:09 <merijn> ghc compile failed :(
04:26:17 <yitz> Igloo: it could be anywhere from making Data.Text magical with its own pragma, to a very general IsString-like mechanism that works like a quasiquoter but uses string literal syntax.
04:26:26 <merijn> Oh goddammit
04:26:29 <nanothief> fair enough, I think that is more a problem with the library than the extension though
04:26:36 <merijn> Who the (%(@%& wrote the autoconf scripts for ghc?!
04:26:44 <merijn> They've got the same freaking stupid bug that cabal does
04:26:52 <merijn> Incompetent idiots
04:27:05 <quchen> merijn: GHC compiles pretty fast with -jX for me
04:27:29 <merijn> Christ...
04:27:35 <nanothief> A possible solution though would be to have a staticToString and staticFromInteger that returns a Either Error a. The compiler uses this with constants in the code, and causes a compile error if Left error is returned
04:27:38 <quchen> Well, "fast" is relative, but it's around 10-20 minutes, not like hours (as I believe you mentioned)
04:27:48 <shachaf> merijn: Calling people here incompetent idiots is a bit excessive, even if you're annoyed.
04:27:49 <yitz> Igloo: nicest would be just like IsString now except the compiler rejects programs where the concrete type of a string literal cannot be resolved and run at compile time. but that would be hardest to implement.
04:27:52 <merijn> Or maybe I should be hating on the autoconfigure guys I don't know who if the worst criminal here
04:28:37 <merijn> shachaf: Yeah, I should probably be hating the autconf guys instead of the ghc people anyway
04:29:18 <yitz> nanothief: i disagree. once you have an extension like that, you certain to get libraries with that problem.
04:29:35 <merijn> For some ridiculous reason autoconf decides to scan your path *first* to find it's location if it's not invoked with a slash in its name
04:29:50 <shachaf> merijn: If you're running into problems that other people haven't run into and you know how to fix them, I'm sure a patch or bug report would be appreciated.
04:29:51 <yitz> nanothief: the author of the library i mentioned, for example, is aware of the problem and for his own reasons simply doesn't care.
04:30:13 <merijn> shachaf: I don't know *where* in the build system it is, but it's trivial to fix
04:30:49 <yitz> shachaf: yes, right, but those are a subset of the types that could just as easily be resolved at compile time anyway.
04:31:49 <merijn> The issue is that for some ridiculous reason autoconf decides to first scan your path to find the location of the running configure script if the script was invoked without a slash in the path, rather than trying the CWD first. So if you run configure without a slash in the name *and* have a configure file somewhere in your path it will decide it's running from a different directory then it actually is, breaking the buil
04:32:34 <merijn> Normally you don't run into this as you'll run "./configure" in the shell, but cabal (before I fixed it) and ghc are using system/exec to call configure and are doing so without the ./, resulting in configure barfing on the configure script elsewhere in my path
04:32:50 <merijn> (Don't ask how enraged I got by trying to debug this issue)
04:32:59 <nanothief> yitz: there isn't much you can do about a library author that doesn't care about incomplete functions though. Any function can suffer from the same problem, not just fromString. It isn't helped that head and tail exist in the standard library...
04:34:23 <shachaf> merijn: OK, then file a bug.
04:34:38 <yitz> nanothief: true, but somehow it seems worse to me that haskell is in this sense one of the most unsafe languages in existence. in how many languages will a string literal syntax error be detected only at runtime?
04:35:19 <merijn> shachaf: Yeah, I'm trying to determine where ghc is calling configure
04:35:30 <merijn> But grep is turning up a lot unrelated nonsense
04:35:42 <yitz> merijn: it sounds like you've found an interesting security vulnerability
04:36:48 <nanothief> yitz: none, but then again I don't know of any languages which allow literal numbers and strings to have different types. This is a great feature, and while it could be made better (by using an Either type for the result, and causing a compile error if Left error happens, it is still a net win for me
04:36:54 <gds> shachaf: Thanks - I didn't know about Text :)
04:38:49 <yitz> nanothief: it should be compile time polymorphism, not runtime. in the case of numeric literals, though, as merijn says, it is far less common for literals to cause runtime errors, so it's less of a problem.
04:40:04 <gds> yitz: Thanks to you too.
05:18:33 * hackagebot cassandra-cql 0.2.0.2 - Haskell client for Cassandra's CQL protocol  http://hackage.haskell.org/package/cassandra-cql-0.2.0.2 (StephenBlackheath)
05:25:24 <Zariel> is it possible to overwrite the instance of type synonym?
05:26:14 <yitz> Zariel: no.
05:28:36 * hackagebot cassandra-cql 0.2.0.3 - Haskell client for Cassandra's CQL protocol  http://hackage.haskell.org/package/cassandra-cql-0.2.0.3 (StephenBlackheath)
05:57:31 <magicman> whois Zariel
05:57:36 <magicman> No. With /
06:08:40 * hackagebot http-streams 0.6.0.2 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.6.0.2 (AndrewCowie)
06:14:02 <Zariel> magicman: boo
06:16:08 <magicman> I thought I had seen your nick on another network, but you're not the same person.
06:17:32 <iamtakingiteasy> oh lol
06:17:34 <iamtakingiteasy> i am an idiot
06:17:41 <iamtakingiteasy> all i need was to read RWH a little further
06:17:47 <iamtakingiteasy> and notice the OverlappingInstances pragma
06:18:43 <iamtakingiteasy> which forces haskell to choose most specific instance amoung overlapping ones
06:20:58 <gds> I have a friend on another channel asking if it's possible to ask cabal to install (and hide?) an old version of a package, so one can work on and test legacy code.. Does this work if I just do cabal install libname-oldversion ?
06:25:58 <BitPuffin> hmm
06:26:02 <elliott> iamtakingiteasy: you probably shouldn't use that.
06:26:06 <geekosaur> gds: you can install the old version that way, then use ghc-pkg hide
06:26:12 <BitPuffin> I'm trying to install cypher with cabal
06:26:28 <gds> geekosaur: awesome - thanks!
06:27:04 <BitPuffin> but it isn't working
06:27:05 <geekosaur> note that you can still get into trouble with (somewhat ironically) cabalized packages because cabal manages hiding differently
06:27:13 <BitPuffin> http://hpaste.org/89999
06:27:17 <BitPuffin> that's the output
06:27:27 <luite_> gds: if you install a new package but use some old version of dependencies, use cabal install --constraint=library==version
06:27:43 <luite_> gds: doing this with cabal-dev might be better
06:27:47 <BitPuffin> not sure why it's installing 0.7 when there is a 0.8.1
06:27:48 <iamtakingiteasy> elliott: why? It keeps code much clearer and simplier, allowing you to utilize mere String's rather then some special types like Data.Text, Bytestrings or likes
06:27:55 <efie> how would you indent the following code? http://hpaste.org/90000
06:28:10 <iamtakingiteasy> than*
06:28:13 <geekosaur> BitPuffin, did you do "cabal update"?
06:28:21 <BitPuffin> geekosaur: yes
06:28:41 <elliott> iamtakingiteasy: well, OverlappingInstances is not quite what you'd call safe.
06:28:48 <geekosaur> then 0.8.1 probably has a dependency on base (meaning a dependency on the compiler version)
06:29:04 <gds> luite_: Thanks - I'll go read up on cabal-dev
06:29:06 <iamtakingiteasy> elliott: how it may blow right in my face?
06:29:41 <elliott> well, it breaks the open world assumption, for one. and the resolution doesn't always behave as you'd expect.
06:29:57 <BitPuffin> feels like cabal always has trouble installing things
06:31:17 <daniel-s> Hi, does "type variable" just mean variable?
06:31:38 <geekosaur> no
06:32:31 <geekosaur> :t 5
06:32:32 <lambdabot> Num a => a
06:32:38 <geekosaur> ^^ a is a type variable
06:32:52 <mauke> :t id
06:32:53 <lambdabot> a -> a
06:33:59 <BitPuffin> it might be that whoever made haskell-cypher has abandoned it :(
06:34:04 <typoclass> daniel-s: type variables are inside of type signatures (roughly: on the right side of "::"). they start with a lower-case letter and often are just 'a', 'b', and so on. if it starts with an upper-case letter (Int, String, ...) it's not a type variable, it a concrete type
06:35:03 <daniel-s> typoclass: Is it analogous to "T" that often appears in Java generics. Like CollectionOfSomeSort<T> (T is the type variable)?
06:35:17 <typoclass> daniel-s: roughly, yes
06:35:45 <daniel-s> OK. Thanks.
06:36:21 <b2coutts> daniel-s: my knowledge of java isn't very good, but it looks to me that T would be a concrete type, rather than a type variable
06:36:51 <b2coutts> :t length
06:36:51 <lambdabot> [a] -> Int
06:37:13 <b2coutts> if that contract were "[Int] -> Int", it would mean that length can only be applied to lists of Ints
06:37:58 <b2coutts> however, since it's "[a] -> Int", the a acts as a placeholder for any concrete type; so length can be applied to [Int], [Char], [String], etc
06:38:06 <typoclass> in the signature for length, 'a' just stands for 'the function places no restrictions on the element type of the list. it could be any type at all'
06:39:45 <nimish> the way to read it is something like: "for any type a, the function length takes a list of a  to Int"
06:43:42 * hackagebot sys-auth-smbclient 2.0.0.0 - Auth with smbclient command  http://hackage.haskell.org/package/sys-auth-smbclient-2.0.0.0 (KazuoKoga)
07:24:40 <LowPotential> Hi everybody. I'm actually writing in F#, but I believe this question is relevent for Haskell as well (which I'm somewhat familiar with). I've defined an AST for an assembly language with cases such as "data Statement = InstructionStatement Instruction | DirectiveStatement Directive | ..." and "Data Instruction = UnaryInstruction Opcode Address | BinaryInstruction Opcode Address Address", etc.
07:24:50 <LowPotential> Now suppose that I'm writing a function to encode the AST as binary data.
07:25:04 <LowPotential> So I want to walk through the tree and recursivley apply the function.
07:25:23 <LowPotential> So I have "encodeStatement" which calls "encodeInstruction" and "encodeDirective" which call "encode*" down the tree.
07:25:27 <LowPotential> But this gets repetitive.
07:26:02 <LowPotential> I'm aware of the "Visitor" pattern for OOP languages, but is there an alternative for functional languages like Haskell?
07:26:18 <elliott> I would tell you to look at Scrap Your Boilerplate generics as embodied in Data.Data and the syb package.
07:26:19 <lolcathost> LowPotential: pattern matching!
07:26:24 <elliott> I don't know F#. this may or may not apply.
07:26:32 <elliott> if it does, you'd better hope someone wrote it already
07:26:46 <isomorphic> Does anybody know a good way to find packages that depend on a particular package on hackage?
07:27:33 <elliott> isomorphic: http://packdeps.haskellers.com/reverse
07:28:06 <isomorphic> Thanks elliott
07:29:55 <b2coutts> in LYAH, at the bottom of the types and typeclasses tutorial, they define a sample class, class Tofu t where tofu :: j a -> t a j. They deduce that a :: *, and so j :: * -> *. But why would a have to have kind *? Couldn't a :: * -> *, and j :: (* -> *) -> *?
07:30:35 <elliott> b2coutts: true. you can think of it as simply kinds defaulting to * where ambiguous.
07:30:47 <LowPotential> The "encode*" functions are fine to write once, the problem is that if I want to recursively walk down the tree and do something ELSE, I have to re-write all the pattern-matching stuff that I wrote before. It's gets redudant.
07:31:28 <b2coutts> elliott: so their example isn't trying to say that a _has_ to be *, but that it could be, and then going on to say what you can infer from the assumption a :: *?
07:31:40 <elliott> b2coutts: well, a is definitely * there.
07:31:53 <elliott> something has to force it to not be * for haskell to start considering the possibility that it might not be.
07:32:07 <elliott> basically, the kind of a type variable you quantify over is determined by how much you actually apply it.
07:32:14 <elliott> if you don't apply it at all, it'll be *.
07:32:21 <elliott> PolyKinds makes things more generic as you reasoned
07:32:23 <elliott> (new extension
07:32:24 <elliott> )
07:34:44 <b2coutts> elliott: but couldn't j, for example, be a type constructor which takes a unary type constructor, and applies it to Int? So if j Arg = Arg Int, and a = [], j a = [Int]?
07:35:21 <elliott> b2coutts: no, because the rules of the language do not allow that given the quoted declration.
07:35:26 <elliott> it is true they could be extended to permit this.
07:35:44 <elliott> like I said: you never apply "a" to a type in the declaration of Tofu, therefore it gets kind *. that's how it works
07:38:45 * hackagebot yesod-auth-smbclient 1.0.0.0 - Authentication plugin for Yesod using smbclient  http://hackage.haskell.org/package/yesod-auth-smbclient-1.0.0.0 (KazuoKoga)
07:42:01 <ethoma> Can someone help me out on a beginner's question?
07:42:18 <kaw> Say I want to have something similar to an enumeration like this: "data X = Foo | Bar | Baz", but I want to impose an arbitrary ordering so the X type will satisfy Ord -- is there a simple way to do that? (e.g. impose the order they were enumerated in)
07:42:29 <nooodl> ethoma: sure
07:42:45 <kaw> The reason I want an ordering is to be able to use X as a key in a Data.Map.Map
07:43:31 <kaw> So a better way to accomplish that would be even nicer, if there is one
07:43:35 <Cale> ethoma: Ask away :)
07:43:45 * hackagebot yesod-auth-smbclient 2.0.0.0 - Authentication plugin for Yesod using smbclient  http://hackage.haskell.org/package/yesod-auth-smbclient-2.0.0.0 (KazuoKoga)
07:43:57 <Cale> kaw: Add "deriving (Ord)" to the end of the data declaration
07:43:57 <ethoma> okay, thanks. I have an error I don't understand how to fix really: http://pastebin.com/X1u6bXhh
07:44:03 <mauke> The paste X1u6bXhh has been copied to http://sprunge.us/KMIG?haskell
07:44:12 <kaw> Oh, thanks, didn't realize it was that simple
07:44:27 <Cale> ethoma: It looks like you'
07:44:34 <Cale> you're mixing tabs and spaces
07:44:48 <Cale> ethoma: I recommend configuring your text editor to convert tabs to spaces automatically
07:45:17 <ethoma> I am, but is that why writeArray is getting that error? It is properly aligned but pasting it misaligned it
07:45:21 <Cale> ethoma: The problem here is that the line with continue 1 on it is actually indented more
07:45:36 <Cale> and becomes part of the parameters to writeArray on the previous line
07:45:49 <Cale> The compiler will treat tab stops as being every 8 spaces
07:46:01 <Cale> So if you don't have your editor set up like that, things can be really confusing.
07:46:22 <Cale> (It's best just to avoid tabs altogether)
07:47:31 <ethoma> You are right, thanks! It compiles now. Usually when I mess up indent I get a parse error but I guess this time I got a weirder one.
07:47:46 <ethoma> I'm switched the text editor to spaces now
07:47:54 <Cale> http://hpaste.org/90002 -- here's how it looked to the compiler (hpaste does it right)
07:48:13 <Cale> mauke: You could probably switch your script back to hpaste now.
07:51:25 <hpc> ethoma: improper spacing makes ghc misinterpret line endings
07:51:39 <hpc> ethoma: usually forgetting a semicolon in other languages yields a syntax error, but sometimes it's something else
07:51:55 <hpc> sometimes, forgetting a semicolon leads to no errors, and an incorrect program
07:52:06 <hpc> (or in perl, forgetting a semicolon turns an invalid program into a valid one)
07:53:46 <ethoma> hpc: good point; I haven't learned the haskell error message nuances yet
07:56:51 <hpc> ethoma: like most languages, the most valuable piece of information in a ghc error message is the line number ;)
07:57:27 <Cale> Well, once you learn to read them, they're usually pretty informative too
08:14:30 <acube> @hoogle
08:14:30 <lambdabot> No query entered
08:14:31 <lambdabot> Try --help for command line options
08:14:33 <acube> ----------------------
08:15:01 <acube> @hoogle (Functor m, Applicative f, Alternative f) => m Bool -> a -> m (f a)
08:15:02 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
08:15:02 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
08:15:02 <lambdabot> Data.Generics.Aliases unGM :: GenericM' m -> forall a. Data a => a -> m a
08:15:25 <acube> @hoogle (Functor m, Applicative f, Alternative f) => Bool -> a -> (f a)
08:15:26 <lambdabot> Did you mean: (Applicative f, Alternative f) => Bool -> a -> f a
08:15:26 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
08:15:26 <lambdabot> Control.Exception assert :: Bool -> a -> a
08:17:29 <acube> @ty \a x -> pure x <$ guard a
08:17:30 <lambdabot> (Functor f, MonadPlus f, Applicative f1) => Bool -> a -> f (f1 a)
08:17:47 <acube> @pl \a x -> pure x <$ guard a
08:17:50 <lambdabot> flip ((<$) . pure) . guard
08:17:50 <lambdabot> optimization suspended, use @pl-resume to continue.
08:17:55 <acube> @pl-resume
08:18:02 <lambdabot> flip ((<$) . pure) . guard
08:18:02 <lambdabot> optimization suspended, use @pl-resume to continue.
08:27:08 <applikativ> i hadn't noticed mauke's bot is using sprunge.us
08:28:04 <acube> What does mauke's bot do=
08:28:05 <acube> ?
08:28:59 <acube> What does mauke's bot do=
08:29:07 <acube> oops, sry for double post
08:29:43 <b2coutts> acube: it does pastebin -> sprunge
08:40:22 <Itkovian> > 1d6
08:40:23 <lambdabot>   Not in scope: `d6'
08:40:24 <lambdabot>  Perhaps you meant one of these:
08:40:24 <lambdabot>    `d' (imported from D...
08:40:32 <Itkovian> @dice 1d6
08:40:33 <lambdabot> Itkovian: 5
08:40:47 <Itkovian> thx lambdabot
08:44:11 <FreeFull> > 1 1
08:44:13 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
08:44:13 <lambdabot>    arising f...
08:44:25 <FreeFull> Ok, it doesn't have that weird num instance anymore
08:51:40 <supki> > 1 + (2, 3)
08:51:41 <lambdabot>   No instance for (GHC.Show.Show t1)
08:51:41 <lambdabot>    arising from a use of `M1160118851.sh...
08:52:13 <Taneb> ...?
08:52:21 <Taneb> > 1 :: (Int, Int)
08:52:24 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Int, GHC.Types.Int))
08:52:24 <lambdabot>    arising fro...
09:00:28 <merijn> I need a new machine with SSD and more cores if I'm gonna be building GHC and associated libraries more frequently >.<
09:03:15 <eikke> merijn: use tmpfs
09:05:45 <merijn> eikke: I only have like 4GB of RAM
09:05:49 <merijn> and 2 cores
09:06:50 <eikke> merijn: parallel build happens to be flacky, so cores won't help :)
09:08:03 <merijn> I noticed
09:08:12 <merijn> It finished and broke on -j3
09:08:17 <merijn> Reran normally
09:08:26 <merijn> The GHC readme still says to use -j, though...
09:08:53 <merijn> building lens + dependencies is making my machine sounds like a vacuum :p
09:09:47 <eikke> merijn: my machine sounds like a vacuum cleaner 24/24 :-( can't use catalyst-legacy anymore, so steady temperaturs is >= 60dC
09:12:54 <yitz> eikke: doesn't that hurt your leg when it's in your pocket?
09:13:31 <eikke> yitz: my pockets aren't that large, guess I should become a Haskell consultant ;-)
09:13:45 <yitz> ;)
09:14:09 <merijn> bah
09:14:38 <merijn> Where's edwardk when you need him? :p
09:15:58 <enigmuriatic1> if i'm doing a manual installation of GHC on Debian, what directory should i install it into?
09:16:01 <merijn> Typeable1 has disappeared in ghc7.7?
09:19:18 <merijn> Apparently it has, and now lens won't work until the entire poly kinds mess is cleaned up >.>
09:20:04 <eikke> merijn: yeah, lots of things are broken by that
09:20:08 <merijn> blah
09:20:39 <merijn> Apparently all the stuff I need depends on contravariant which is broken :(
09:21:41 <merijn> So that's why edwardk's hiding away from IRC...
09:28:15 <ethoma> Quick question: I want to get a tuple of STArrays in my main function that has type IO, but I keep getting a compiler error. How would I do this? See code and error message: http://hpaste.org/90003 .
09:29:49 <Botje> ethoma: ST is not IO
09:30:15 <Botje> ethoma: you can either use runST, or use stToIO
09:30:22 <ethoma> Botje: I am new - is there a way then to work with STArrays in my main function?
09:30:39 <merijn> ethoma: Looks like you want runST
09:30:43 <Botje> it depends on how much you want to avoid the IO monad.
09:30:45 <eikke> ethoma: if you're new, you better don't dig into ST yet
09:30:56 <Botje> otherwise you can use IOArrays directly.
09:31:15 <ethoma> What is the benefit of ST over IO? Isn't ST just more general?
09:31:26 <Botje> you can runST from pure code
09:31:32 <Botje> you can't do so with IO
09:32:09 <merijn> ethoma: Basically, main is do-block in the IO monad, but initPieceArrays is in the ST monad, you're not allowed to mix arbitrary monads in a single do-block
09:32:45 <merijn> ethoma: If you don't know why you would want ST instead of IO you're better off not using ST for now, tbh
09:33:09 <merijn> ethoma: There's nothing wrong with stuffing a bunch of code into the IO monad if that happens to be what you're writing
09:36:07 <ethoma> Okay - I will switch to IOArrays for now. Thanks.
10:04:48 <ksf_> type-level literals (and numerals) are lacking syntactic sugar. there should be some way to promote constant values to the type level, that is.
10:05:54 <ksf_> the best I can think of is something like [lab|foobar]
10:06:19 <merijn> ksf_: What do yu mean?
10:06:29 <merijn> What's lacking about type level literals?
10:06:46 <ksf_> well, you have to write things like 'undefined :: FooBar "baz"'
10:07:03 <merijn> right
10:07:19 <merijn> I don't think that's much less awful then [lab|foobar], though
10:07:31 <ksf_> no, it's more awful.
10:09:10 <ksf_> doing something like 'foobar "baz"' would require Haskell to know constants from stuff reqiring actual dependent types, of course.
10:09:20 <ksf_> but it'd still be nice to have.
10:10:19 <ksf_> (I'm, yet again, deciding what to do about record labels, and, yet again, investigating alternatives to excessive typeclassing)
10:11:15 <merijn> oh, to get over my annoyance that everything I need is broken in 7.7, can I actualy use kind variables in 7.7?
10:11:19 <ksf_> type-level labels have the distinct advantage that they don't pollute the function namespace.
10:16:48 <merijn> Anyone?
10:18:03 <acube> What is GHC 7.7? :O
10:18:09 * acube only knows GHC 7.8
10:18:17 <tgeeky> acube: development versions are odd numbered
10:18:24 <merijn> acube: 7.8 doesn't exist yet
10:18:25 <acube> ah ok
10:18:25 <tgeeky> acube: so, GHC HEAD might be called 7.7
10:18:29 <merijn> does it?
10:19:16 <merijn> acube: yeah, odd numbered releases are for wacky people like me, doing silly stuff :p
10:19:35 <merijn> and then finding out that all their dependencies don't compile so they still can't test their idea
10:20:54 <acube> Fix the deps! :P
10:21:22 <merijn> acube: I can't
10:21:43 <merijn> How to fix them is still up for discussion on libraries@, I think
10:22:08 <merijn> They're casualties of the PolyKinds change
10:22:56 <Botje> s/change/carnage/
10:24:57 <merijn> yeah
10:25:12 <merijn> On the upsid, I can generalise the type family I was working on using PolyKinds!
10:25:39 <merijn> I'm not smart enough to fix edwardk's stuff to work with PolyKinds, tbh
10:27:47 <applikativ> oh it's the new Typeable that is breaking everything merijn ?
10:27:58 <acube> yes
10:28:07 <merijn> applikativ: Yeah
10:28:08 <acube> (at least it was when I once tried to compile lens)
10:28:26 <acube> I think already comonad or comonad-extras fails to compile
10:28:27 <mauke> where can I read more about that?
10:28:44 <applikativ> but has -XPolyKinds changed much? as opposed to Data.Typeable using it?
10:29:48 <merijn> applikativ: 7.7 doesn't have Typeable1 anymore
10:29:57 <merijn> contravariant breaks for me
10:30:03 <applikativ> right, I knew that was the the objective
10:30:19 <applikativ> it was one of the selling points of -XPolyKinds from the beginning
10:30:22 <merijn> contravariant uses Typeable1, so it broke
10:30:36 <merijn> And all stuff depending on it and lens by extension broke too
10:30:48 <merijn> applikativ: Sure, but people haven't decided how to proceed
10:30:48 <applikativ> nice
10:31:22 <acube> merijn: You should be able to fix it by ... deriving Typeable, no?
10:32:26 <merijn> acube: I have no clue whether that's good enough?
10:32:45 <merijn> Wait...
10:32:53 <merijn> Shouldn't this require FlexibleInstances? "instance Show (Foo a) where"
10:33:11 <merijn> Or am I confused
10:33:24 <acube> I don't think this requires flexible instances
10:33:47 <acube> but maybe Foo a a would (idk)
10:34:47 <acube> merijn: There are #ifdef's around the Typeable1 instance in the hackage version of contravariant
10:34:53 <acube> http://hackage.haskell.org/packages/archive/contravariant/0.4.1/doc/html/src/Data-Functor-Contravariant-Day.html
10:35:36 <applikativ> no, instance Show (Foo Int) requires FlexibleInstances
10:36:34 <Jookia> Hello!
10:36:44 <applikativ> oh interesting, it looks like it has been taken account of then?
10:36:48 <applikativ> hello Jookia
10:37:35 <merijn> acube: I saw, but they don't check for 7.7, else it wouldn't be breaking
10:37:56 <acube> Well, what is __GLASGLOW_HASKELL__ defined as in GHC 7.7?
10:38:18 <acube> Should be 707, shouldn't it?
10:38:28 <applikativ> you mean ghc-7.7 doesn't know that it's 707
10:38:36 <acube> ah right, the check > 707
10:38:39 <acube> not >= 707
10:38:43 <applikativ> hah
10:38:46 <merijn> >.>
10:38:49 <merijn> Lemme try that
10:38:52 <merijn> Unrelated
10:38:54 * hackagebot lio 0.10.0.0 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.10.0.0 (AmitLevy)
10:39:09 <merijn> argh! "Illegal polymorphic or qualified type: forall (a :: Type). Foo a"
10:39:19 <merijn> Why do I keep needing ImpredicativeTypes :(
10:39:29 <merijn> Or rather
10:39:50 <merijn> Why is the extension I need so badly maintained and likely to die :(
10:40:15 <applikativ> what do you need it for? you can add it to the complaints on the trak.
10:40:32 <merijn> I'm playing with mm_freak's netwire stuff
10:40:47 <merijn> And I want to have a wire "Wire e m (forall a . Foo a) b"
10:41:00 <merijn> Because Foo has a phantom type and my Wire works for all Foo's
10:41:14 <sclv> you can always trivially rewrite impredicative stuff to not need it, as i recall
10:41:20 <merijn> sclv: Oh?
10:41:25 <applikativ> that can't be true
10:41:26 <sclv> just guard it by a newtype
10:41:28 <merijn> sclv: I'd love to know how
10:41:40 <merijn> sclv: No, then I'd have to reimplement the entire netwire library
10:41:45 <applikativ> with a newtype yes, if you call that trivial rewriting
10:41:57 <sclv> newtype HiddenFoo = Foo a
10:41:59 <acube> merijn: Make Foo an instance of Contravariant and Functor, and then use coerce from lens?
10:42:05 <sclv> Wire e m HiddenFoo b
10:42:21 <merijn> netwire has: "Wire e m a b = (Time -> a -> m (Either e b, Wire e m a b)"
10:42:34 <merijn> Now I have a GADT Foo with a phantom type
10:42:42 <sclv> yea
10:42:43 <merijn> My code works for any value of said phantom type
10:42:47 <acube> coerce :: (Functor f, Contravariant f) => f a -> f b
10:42:50 <merijn> But I can't write a wire like that
10:43:08 <sclv> you can't write Time -> HiddenFoo -> m (Either e b, Wire e m HiddenFoo b) ?
10:43:11 <merijn> Because "Wire e m (Foo a) b" will fix a when applied to a specific "Foo a"
10:43:19 <applikativ> Wire is the newtype correpsonding to the above?
10:43:25 <sclv> aha
10:43:37 <sclv> so you want the two as to be the same
10:43:39 <merijn> sclv: That defeats the entire purpose of wanting the phantom type as *some* wires *will* be restricted in what they accept
10:43:44 <merijn> sclv: No
10:43:50 <merijn> I want the a's to be different
10:44:20 * byorgey still doesn't understand why  newtype HiddenFoo = Foo a  wouldn't work
10:44:24 <sclv> nor do i
10:44:26 <byorgey> sounds right to me
10:44:35 <merijn> byorgey: I *want* the a visible in the type in some wires
10:44:45 <sclv> then use Foo a for those cases
10:44:56 <sclv> (forall a. Foo a) as an impredicative type
10:44:59 <merijn> Then I would have to coerce between HiddenFoo and Foo all the time
10:45:04 <sclv> is _precisely_ what HiddenFoo gives you
10:45:06 <merijn> Which is exactly what I wanted to avoid
10:45:07 <sclv> modulo constraints
10:45:14 <sclv> "coerce" is wrap and unwrap
10:45:25 <sclv> so you need some HF and unHF calls
10:45:28 <merijn> sclv: Yes, but I'd have to write the code to do it for every single wire
10:45:36 <sclv> sure, its a bit noisy
10:45:44 <sclv> but i claim it is also "trivial"
10:45:50 <arkeet> understatement of the day
10:46:11 <merijn> Not just that, it also makes it impossible to propagate constraints
10:46:34 <merijn> i.e. a polymorpic wire followed by a wire that only allows "Foo Bar" should only admit Foo Bar
10:46:35 <sclv> i think you want something impredicative types doesn't give
10:46:40 <merijn> Which can't be done if Foo A hides it
10:46:45 <merijn> sclv: Maybe
10:46:47 <monochrom> if you don't want to write a lot of HF and unHF, the alternative is to patch GHC to support impredicative types properly :)
10:47:19 <monochrom> (it explains why most people have settled for a lot of HF and unHF! :) )
10:47:21 <acube> Or just use coerce on the caller side? (If it's a phantom type argument, have a functon Foo a -> Foo b) ?
10:47:45 <merijn> acube: That means I actively break any type safety I'm trying to create
10:47:49 <sclv> can't you get that "followed by a ware that only allows…" behavior with universal quantification?
10:48:19 <sclv> forall a. Wire e m (Foo a) b
10:48:30 <merijn> sclv: Yes, but I can't have wires that accept both "Foo Bar" and "Foo Baz" with universal quantification
10:48:40 <efie> how can I specify where haddock should put the documentatioN? I tried haddock myfile.hs --odir=doc
10:48:47 <merijn> Once they accept "Foo Bar" once the a is fixed
10:48:59 <acube> merijn: When does the a get fixed
10:49:02 <acube> ?
10:49:11 <merijn> acube: It shouldn't for wires that don't care about it
10:49:27 <sclv> myPolyWire :: forall a. Wire e m (Foo a) b
10:49:32 <sclv> that will never be "fixed"
10:49:42 <merijn> sclv: oh?
10:49:45 <sclv> you can use it many times each time with a difft a
10:50:05 <acube> And you can also have functions of type f :: (forall a. Wire e m (Foo a) b) -> X
10:50:08 <acube> ?
10:50:22 <efie> I got it, thanks
10:50:24 <merijn> sclv: No
10:50:28 <merijn> sclv: That's not true
10:50:33 <sclv> ?ty id
10:50:47 <merijn> sclv: If it was then just "Wire e m (Foo a) b" would work too
10:50:47 <applikativ> merijn wants to apply the wire to a Foo Int, and then extract a still general Foo a wire
10:50:57 <merijn> Yes
10:51:30 <sclv> well its either universally quantified or existentially
10:51:35 <sclv> there is no in between
10:51:48 <applikativ> for most a . F a
10:51:49 <sclv> no amount of "impredicative types" will fix that
10:52:04 <merijn> sclv: Ok, so what do I hack to add something in between? :p
10:52:20 <merijn> Agda or Idriss most likely >.>
10:52:40 <applikativ> Idris is the name of the prophet
10:52:45 <sclv> so you want to pass it multiple things, but if its followed by something that only accepts one thing, only pass it one thing?
10:52:52 <merijn> sclv: Yes
10:53:08 <sclv> write a special compose operator then
10:53:18 <sclv> that specializes the first based on the second
10:53:26 <merijn> sclv: That leads me back to "reimplement all of netwire"
10:53:29 <sclv> no
10:53:56 <merijn> hmm
10:54:00 <merijn> I need to think about this
10:54:15 <sclv> alternately write an operator "instantiate" that takes a wire on HiddenFoo and "lowers" it to a universally quantified one.
10:54:53 <sclv> that's more general than "compose"
10:55:06 * acube doesn't really get where the forall a. Wire e m (Foo a) b fails
10:58:05 <applikativ> he does runWire merijnWire now (x::Foo Int) he will get back a wire that requires Foo Int
10:58:14 <applikativ> if he does that
10:58:49 <merijn> applikativ++
10:58:49 <applikativ> (e, w) <- runWire merijnWire now (x::Foo Int)
10:59:17 <applikativ> w is a Wire for Foo Int unlike merijnWire
10:59:52 <merijn> I guess it could be possible to coerce the wire back to Foo a?
11:00:12 <merijn> Considering a is only a phantom type
11:01:45 <merijn> i.e. runWire (unsafeCoerce w :: Wire e m (Foo a) b) now (x :: Foo Char)
11:11:03 <merijn> sclv: Actually, even a special compose would still lead to problems. It'd solve one of my issues, but not the other
11:11:15 <merijn> So I need to go back to the drawing board...
11:14:45 <trevize> hello haskellers. If I have a type variable in an instance definition: instance C a where... How do I reference that variable in the function? i.e. f g = other_func g :: a ?
11:15:20 <enigmuriatic1> http://hpaste.org/90016    can someone help me figure out the blockLoop function? the errors are at the bottom.
11:18:37 <Botje> enigmuriatic1: did you mean (getBlock (prevHash block)) on line 97?
11:19:18 <Botje> enigmuriatic1: that has type IO (Maybe Block), so you still need to fmap maybe over it, or assign to a temporary variable and use that.
11:20:02 <enigmuriatic1> Botje, prevHash has type IO (Maybe Block)?
11:20:07 <enigmuriatic1> or the whole expression
11:20:22 <Botje> prevHash block has that type.
11:20:35 <Botje> and maybe wants a regular Maybe, not an IO (Maybe ...)
11:20:56 <enigmuriatic1> Botje, i don't think field calls have an IO in their type, do they?
11:21:06 <Botje> oh, blah
11:21:08 <Botje> misread.
11:21:26 <Botje> prevHash block :: Maybe BS, yes.
11:21:50 <Botje> but then why is it complaining, mrr.
11:22:10 <enigmuriatic1> Botje, i know, the function looks pretty sensible
11:22:18 <enigmuriatic1> I don'e see what the problem could be
11:23:10 <efie> It says that Data.Vector.Unboxed is "specialized for every element typ" and that "Implementing unboxed vectors for new data types can be very easy.". So can every data type be made an isntance of Data.Vector.Unboxed? Is it better to make it an instance and use the unboxed variants, or is there then no differnece to using a normal Data.Vector?
11:23:23 <enigmuriatic1> one error is just a type error, i can fix that
11:23:41 <Cale> efie: Not every data type can be
11:24:07 <Botje> enigmuriatic1: durrr
11:24:12 <Botje> enigmuriatic1: your type for blockLoop is wrong
11:24:12 <Botje> needs to be IO as well
11:24:12 <Botje> you cannot execute stuff in the IO monad and not return something in the IO monad.
11:24:26 <efie> Cale: I would like to store  LogFloat  from Data.Number.LogFloat
11:25:04 <enigmuriatic1> Botje, does it have to be IO?
11:25:15 <Botje> enigmuriatic1: yes.
11:25:27 <enigmuriatic1> but doesn't the do block bind that off?
11:25:28 <Botje> line 97 is executing an IO action, so the entire do block needs to be IO
11:25:50 <Botje> enigmuriatic1: your type says blockLoop :: ... -> (Maybe Block, [Maybe Tx])
11:25:53 <Botje> not an IO action.
11:25:57 <enigmuriatic1> so that's just a rule rather than something that actually propagates in the code itself, Botje?
11:26:00 <LadyAurora> IO is an infectious disease in Haskell
11:26:20 <Botje> enigmuriatic1: the only thing 'do' enforces is that all statements must be in the same monad.
11:26:40 <enigmuriatic1> Botje, for example, when you have  a block type like "do print "hello world"" its return type is String, not IO String, right?
11:26:41 <Cale> LadyAurora: Not really.
11:26:47 <Botje> enigmuriatic1: what?
11:26:58 <Botje> enigmuriatic1: print :: String -> IO (), so do print "foo" :: IO ()
11:27:07 <Cale> LadyAurora: You really only need to write things in IO when they actually do input and output.
11:27:10 <mauke> enigmuriatic1: do { X } == X
11:27:15 <Botje> (actually, print takes a Show a, so it's even worse.)
11:27:25 <enigmuriatic1> oh i see
11:27:39 <enigmuriatic1> i thought that the do block bound off the IO when it returned the last line
11:27:46 <Botje> "bound off the IO" ?
11:27:55 <mauke> no, 'do' is just syntactic sugar for combining multiple IOs
11:28:01 <mauke> it doesn't actually run anything
11:28:24 <LadyAurora> Cale: yes, that's my point: if you do I/O, you have to be in IO and all code that calls it has to be in IO
11:28:36 <Cale> Well, yes :)
11:29:03 <Cale> (but you often don't have to be doing I/O throughout your entire program!)
11:29:20 <LadyAurora> Cale: I don't
11:29:57 <enigmuriatic1> one last question: how do i pattern match when it takes an IO?
11:30:07 <mauke> enigmuriatic1: ?
11:30:17 <mauke> what is "it"?
11:30:24 <enigmuriatic1> the function, mauke
11:30:32 <Botje> enigmuriatic1: there are very few reasons to take an IO action as an argument.
11:30:36 <enigmuriatic1> how do i pattern match IO (Nothing, _) for example
11:30:38 <Cale> enigmuriatic1: You can only match an IO action against a variable, if your function is taking an IO action as a parameter (like if you're writing some sort of control structure)
11:30:48 <mauke> enigmuriatic1: IO is not a data constructor
11:30:48 <enigmuriatic1> Botje, it recurses on itself, so it has to
11:30:49 <Botje> enigmuriatic1: you bind it to a variable and pattern match on that.
11:31:00 <Cale> enigmuriatic1: If you want to pattern match against the result of an IO action, you have to run that IO action first.
11:31:01 <mauke> enigmuriatic1: IO is not a wrapper
11:31:04 <Botje> enigmuriatic1: even so, you will not be taking an IO action as argument.
11:31:26 <Cale> res <- myIOAction; case res of (Nothing, _) -> ...; ...
11:31:34 <Cale> (inside a do-block)
11:31:49 <Botje> (typed as an IO <something>)
11:32:19 <Cale> enigmuriatic1: Inside of a do-block, v <- x means "run the action x, and call its result v"
11:33:10 <Cale> enigmuriatic1: If x :: IO t, then v :: t
11:33:57 <Cale> If you're running IO actions inside a do-block (as opposed to actions of another monad), then the resulting do-block as a whole will be an IO action.
11:34:40 <Cale> enigmuriatic1: Make sense?
11:34:53 <enigmuriatic1> i think so, trying it now
11:35:05 <enigmuriatic1> o
11:35:13 <enigmuriatic1> i'm just trying to pattern match with recursion though
11:35:22 <enigmuriatic1> i don't see how that related honestly
11:35:58 <ksf_> there's nothing special to pattern matching with recursion, it's just pattern matching.
11:36:14 <Botje> enigmuriatic1: one thing that helped me a lot is to make everything explicit.
11:36:20 <ksf_> ...but you can't match on IO. and that's good the way it is.
11:36:32 <Botje> don't use fmap/liftM, just do everything explicitly with do or >>=/return.
11:36:55 <mauke> s/do or //
11:37:00 <Botje> until you get to the point where you know /why/ you get type errors involving monads and know how to fix them
11:37:26 <Botje> so the big chain on line 96 of your paste, write that out.
11:37:38 <LadyAurora> mauke: no need to make neophyte's life harder
11:37:45 <mauke> s/harder/easier/
11:37:52 <Botje> hashes <- mapM getTx txHashes; let blockTxs = catMaybes hashes
11:38:44 <LadyAurora> What is the code in question anyway?
11:39:32 <ksf_> inb4 #haskell golfing a newbie to death
11:40:27 <enigmuriatic1> hold on
11:40:33 <enigmuriatic1> i'm trying to get this case thing to work
11:40:38 <LadyAurora> ksf_: I know, nothing new
11:40:48 <Botje> ksf_: reverse  golfing, rather :]
11:41:24 <mauke> flogging?
11:41:32 <ksf_> #haskell, by definition, will exhaust the search space of equivalent, faster as well as more elegant programs.
11:41:56 <enigmuriatic1> yeah i'm lost
11:42:08 <ksf_> enigmuriatic1, hpaste.org
11:42:25 <ksf_> show us your code and we shall both show you the light and the darkness.
11:43:12 <enigmuriatic1> http://hpaste.org/90018
11:43:35 <LadyAurora> ksf_: it's easy, programs that have bugs can be optimized to id because they don't work anyway
11:43:59 <ksf_> ...the beautiful, the mindboggling and the absolutely terrifying.
11:44:30 <ksf_> LadyAurora, your transformation isn't type-error preserving.
11:44:47 <ksf_> error preserving in general, actually.
11:45:31 <mauke> enigmuriatic1: missing 'do'
11:46:11 <Jookia> I swear I've asked this before, then done it, then forgotten it, but is there a way to split up a type that's a few functions that return things
11:46:12 <enigmuriatic1> mauke, where?
11:46:30 <arkeet> on the line where it says the parse error is
11:46:46 <ksf_> blockLoop
11:46:53 <ksf_> ...the lines are messed up due to the error in front.
11:47:08 <Jookia> or rather, if I have 'T = a -> b', and then 'f :: T -> c', how would i get a and b?
11:47:09 <enigmuriatic1> i get a bunch more errors
11:47:24 <enigmuriatic1> i should probably just stop or rewrite the whole function or something
11:47:25 <arkeet> Jookia: what do you mean by "get"?
11:47:44 <Jookia> arkeet: When defining the body of f
11:47:49 <enigmuriatic1> i've spent a minimum of 2.5 hours on  an 11 line haskell function
11:48:03 <arkeet> Jookia: can you describe a bit more?
11:48:15 <ksf_> Jookia, f a b c = ...
11:48:16 <arkeet> you don't mention types in the body of a function.
11:48:34 <Jookia> ksf_: f a b c = causes a 'too many arguments' error
11:48:34 <arkeet> unless you are using type annotations, I guess.
11:48:44 <ksf_> Jookia, type synonyms are exactly that, synonyms.
11:48:58 <arkeet> type T = a -> b  doesn't really work, anyway.
11:49:07 <ksf_> yes.
11:49:18 <ksf_> forall'ing them would work but that's not what you want, I bet.
11:49:24 <FreeFull> > imap const [4..10]
11:49:26 <lambdabot>   [0,1,2,3,4,5,6]
11:49:33 <Jookia> Is there another way to pass around a group of arguments or should I use data
11:49:34 <ksf_> type T a b = a -> b , but that's rather pointless.
11:49:45 <arkeet> Jookia: use a tuple or a record or something.
11:49:56 <arkeet> btw, if T was a -> b, then T -> c is (a -> b) -> c, which is not a -> b -> c
11:50:10 <FreeFull> > let a ☺ b = a + b in 3 ☺ 4
11:50:12 <lambdabot>   7
11:50:14 <merijn> Jookia: "T = (a -> b); f :: T -> c" == "f :: (a -> b) -> c", except with a and b out of scope, so weird things
11:50:31 <merijn> Jookia: Data/tuples are probably the best way to go
11:50:37 <Jookia> I didn't realize there was scoping there, I assumed it was kind of 'flattened'
11:50:53 <FreeFull> If I saw someone actually using ☺ in production code I'd kill them
11:51:04 <arkeet> FreeFull: I'd laugh and then kill them.
11:51:31 <Jookia> FreeFull: what if you were writing a DSL for animal behaviours
11:51:53 <merijn> Jookia: Type variables are scoped too, but the default is (if you don't explicitly scope them otherwise) to have a scope equal to the entire type
11:51:55 <mauke> ☹
11:52:13 <Jookia> merijn: Ah, thanks.
11:52:22 <Jookia> Back to trying to program this thing then. :P
11:52:34 <arkeet> > let (☃) = (*) in 5 ☃ 7
11:52:35 <lambdabot>   35
11:52:36 <merijn> Jookia: i.e. "a -> b -> c" the variables a, b and c scope over the entire type, but it *is* possible (albeit maybe a bit intimidating/confusing for newbies :p) to scope them over less than the entire thing
11:53:01 <mauke> or more
11:53:08 <arkeet> @let (☃) = (*)
11:53:08 <lambdabot>  Parse failed: Illegal character ''\152''
11:53:12 <arkeet> ..? :(
11:53:18 <arkeet> elliott: you should fix this. totally.
11:53:21 <merijn> You can scope them over more than the entire type? How?
11:53:36 <merijn> arkeet: He can't
11:53:43 <merijn> arkeet: How would he fix that?
11:53:44 <arkeet> why not?
11:53:56 <merijn> arkeet: IRC doesn't have an encoding, so how can lambdabot decode unicode?
11:54:05 <mauke> merijn: by using utf-8
11:54:08 <ksf_> freenode has a standard encoding.
11:54:10 <arkeet> lambdabot can pretend everything is utf-8, just like it
11:54:13 <arkeet> > let (☃) = (*) in 5 ☃ 7
11:54:13 <ksf_> which is latin1/unicode.
11:54:14 <monochrom> we just assume utf-8 on both sides
11:54:14 <lambdabot>   35
11:54:31 <ksf_> if it's not valid unicode, it's latin1, that is.
11:54:40 <arkeet> I don't know what "unicode" is.
11:54:43 * merijn is going to set his client to some obscure encoding to confuse everyone
11:54:46 <ksf_> utf8
11:54:56 <frankbro> Is there a way to convert a double to a string with a specific formating? Ala %.2f.
11:54:58 <mauke> s/everyone/yourself/
11:55:02 <arkeet> merijn: I think you'd be on the losing end there.
11:55:05 <mauke> frankbro: printf
11:55:06 <merijn> arkeet: Shush!
11:55:10 <arkeet> > printf "%.2f" 1.2345
11:55:11 <lambdabot>   Could not deduce (Text.Printf.PrintfType t)
11:55:12 <lambdabot>    arising from the ambiguity c...
11:55:13 <ksf_> :t showFFloat
11:55:14 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
11:55:20 <arkeet> > printf "%.2f" 1.2345 :: String
11:55:21 <lambdabot>   "1.23"
11:55:32 <merijn> showFFloat is nicer than printf
11:55:39 <arkeet> probably.
11:55:41 <mauke> merijn: no
11:55:45 <ksf_> > showFFloat (Just 2) 1.2345 ""
11:55:46 <arkeet> probably not.
11:55:46 <lambdabot>   "1.23"
11:55:50 <frankbro> mauke, printf doesnt return a string tho .. or at least all my attempt at keeping the value were unsuccessful. Maybe Im doing something bad?
11:55:56 <arkeet> > printf "%06.2f" 1.2345 :: String
11:55:57 <lambdabot>   "001.23"
11:55:58 <mauke> frankbro: printf returns a string
11:56:04 <FreeFull> :t printf
11:56:05 <lambdabot> PrintfType r => String -> r
11:56:17 <merijn> It returns a string or a runtime exception :p
11:56:23 <arkeet> printf returns a string if it tells you to.
11:56:25 <mauke> or IO a
11:56:25 <arkeet> sometimes it returns a IO ()
11:56:29 <arkeet> or IO a
11:56:40 <frankbro> PrintfType it seems
11:56:40 <arkeet> er...if you tell it to.
11:56:43 <merijn> FreeFull: printf uses typeclass voodoo to fake a variable number of arguments
11:56:52 <arkeet> :t printf :: String -> Int -> Double -> String
11:56:54 <lambdabot> String -> Int -> Double -> String
11:57:04 <arkeet> :t printf :: String -> Char -> IO ()
11:57:05 <lambdabot> String -> Char -> IO ()
11:57:18 <merijn> FreeFull: It's a neat trick to learn and then never ever use in real code :p
11:57:33 <FreeFull> merijn: I know
11:57:51 <arkeet> clearly the solution is to encode the format string in the type level.
11:57:58 <merijn> arkeet: Yes!
11:58:07 <FreeFull> I think there was a way to do that without typeclasses too
11:58:11 <merijn> oooh!
11:58:20 <merijn> Ridiculously convoluted idea!
11:58:22 <arkeet> :D
11:58:42 <merijn> Oh, wait, no
11:59:00 <arkeet> I can't think of a better way to do that than with TH thogh.
11:59:07 <merijn> I was thinking of having an IsString instance to generate the type level format string, but that only works if you already specify the type level format string :p
11:59:18 <arkeet> lol
11:59:33 <arkeet> well, I suppose we don't have to give it a string.
11:59:42 <arkeet> why should the format string be a string?
11:59:46 <arkeet> it should be some nice data kind thing.
11:59:57 <ksf_> I vaguely remember some olegery involving cps that ended up implementing varargs, but I can't find it.
11:59:57 <merijn> That nice data will probably be awful to type
12:00:11 <arkeet> but we have TypeOperators.
12:00:18 <merijn> arkeet: Case in point, I had records that encoded types in them to do exactly that
12:00:22 <arkeet> and type level nats
12:00:23 <merijn> It worked, but looked terrible
12:00:31 <arkeet> and type level strings
12:00:33 <mauke> arkeet: operators are terrible
12:00:35 <arkeet> well, Symbol
12:01:10 <arkeet> fortunately the values of the nats/strings would only need to be used at runtime.
12:01:27 <FreeFull> Most functions don't need to be variable arity anyway
12:01:50 <FreeFull> printf-type functions are a big exception
12:01:58 <arkeet> you don't necessarily have to write the type at the call site either.
12:02:30 <arkeet> just pass around witnesses.
12:02:40 <arkeet> to take advantage of type inference.
12:02:57 <arkeet> and then get fantastic error messages when you mess it up.
12:07:42 <efie> is it possible to use  LogFloat from Data.Number.LogFloat in a Data.Vector.Unboxed Vector?
12:10:29 <luite_> efie: if you can make an Unbox instance for it then yes
12:13:03 <luite_> efie: looks like you can implement it with a Double unboxed vector and some unsafeCoerce to read it
12:13:28 <efie> luite_: "class (Vector Vector a, MVector MVector a) => Unbox a " ... to make it an instance of Unbox I don't have to define functions (like for other clases), I have to make it an instance of the Vector Vector and MVector MVector classes?
12:13:34 <FreeFull> I wonder, could you use lenses to make variadic functions?
12:14:53 <lightquake> do we have any idea when ghc 7.8 will come out?
12:16:49 <efie> luite_: hm I don't understand, I can make it an instance of Unbox by using a Double unboxed vector and unsafeCoerce (I haven't used this yet)? Could you explain this more detailed?
12:16:58 <quchen> lightquake: No. It'll be a couple of months at least, according to the mailing lists.
12:17:02 * arkeet is getting bitten by non-injectivity of type families again.
12:17:10 <arkeet> I started doing something and then ended up doing something else.
12:17:38 <luite_> efie: lemme check, you have to add the newtype instances for MVector and Vector
12:18:36 <arkeet> let's go back to the original plan.
12:18:37 <luite_> efie: hm, right, Unbox doesn't have any methods
12:18:53 <luite_> efie: so it's the other things that you have to do
12:24:37 <efie> newtype instance, data family... :/
12:31:03 <luite_> efie: you can probably copy the pattern from Double, what you probably want is what you get from primVector(LogFloat, V_Double, MV_Double)
12:31:21 <luite_> efie: with unsafeCoerce added
12:34:53 <efie> luite_: what does primVector do? I only find "#define primVector(ty,con,mcon)"
12:35:53 <simukis_> how can one tell ghci which specific version of package to load?
12:36:32 <ksf_> -XPackageImports
12:36:40 <ksf_> import "foobar-1.2" Foo.Bar
12:38:05 <efie> luite_: I don't understand what to do with unsafeCoerce / where to add it
12:38:16 <luite_> efie: it's a macro that generates the instance
12:38:45 <simukis_> ksf_: Complains about the module being hidden in that specific package..
12:39:11 <ksf_> then you're not supposed to import it
12:39:36 <simukis_> It's `import "network-2.4.0.0" Network.URI`
12:39:43 <ksf_> ...or the package is hidden
12:41:56 <simukis_> neither of these are true, sadly. Well, but idea with hiding is passable as well. I'll do that.
12:42:19 <luite_> efie: run # cpp -Iinclude Data/Vector/Unboxed/Base.hs to see the result
12:42:24 <luite_> efie: after you do cabal unpack vector
12:44:49 <luite_> efie: oh hmm, that fails because it looks like it requires a generated file
12:51:37 <efie> luite_: To make it an instance of Unbox, I have to make it an instance of "Vector Vector a", therefor I have to make it an instance of "MVector (Mutable v) a" from Data.Vector.Generic which requires a lot of complicated looking functions; is it this difficult?
12:52:57 <Vendethiel> how's the "backpipe" `<-` called?
12:53:29 <ksf_> "bind" if you ask me.
12:54:17 <Jookia> Hello again!
12:54:25 <ksf_> "assign" could work well if you want to distinguish it from >>=
12:54:27 <luite_> efie: perhaps there's an easier way, but i don't know it
12:55:06 <efie> luite_: thank you! do you think I could ask this kind of questions on SO or does this not fit?
12:55:34 <Vendethiel> ksf_: I take you're answering me : )?
12:55:36 <luite_> efie: sure
12:55:44 <ksf_> yep
12:56:01 <Vendethiel> I'll go with "bind" then, ty
12:56:09 <Vendethiel> I don't know >>= yet however
12:56:20 <ksf_> that's the one that's actually called bind.
12:56:24 <byorgey> Vendethiel: <- just gets translated to >>= .
12:56:27 <ksf_> but it's also the same thing. at least almost.
12:56:33 <Vendethiel> oh.
12:56:43 <Vendethiel> is that, backwards or something ?
12:56:48 <Vendethiel> or is it just replaced for clarity ?
12:57:00 <ksf_> so it depends on whether you want to read out code aloud e.g. in pair programming or just want a name for the concept.
12:57:02 <byorgey> it's just syntax sugar.  It can be nicer to write things with <-  sometimes.
12:57:10 <Vendethiel> definitely :)
12:57:14 <byorgey> x <- m; foo  gets translated to   m >>= \x -> foo
12:57:37 <ksf_> also see http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
12:57:38 <Vendethiel> so that's a kind of "callback flattening" syntax
12:57:43 <luite_> efie: a better example might be to look at the instance for Complex
12:58:23 <byorgey> Vendethiel: sure, that's one way to think of it.  When you have  x <- m  in a do block, everything after it is really a "callback" which is passed as the second argument to >>=
12:58:34 <luite_> efie: newtype instance MVector s LogFloat = MV_LogFloat s Double
12:59:04 <arkeet> > [1,2] + [3,4]
12:59:08 <lambdabot>   [4,5,5,6]
12:59:14 <luite_> efie: then instance M.MVector MVector LogFloat where ....
12:59:26 <Jookia> I have a bit of a question about how to accomplish a task that sounds simple but I can't figure out how to do it besides recursion and I have a feeling there's a better way to do it
12:59:40 <arkeet> ask away
12:59:46 <luite_> efie: the methods where the Complex instance pattern matches on (:+) are where you need the unsafeCoerce
13:00:11 <Jookia> I have some records, and I want to find one from a list that has one of its fields matching a string
13:00:25 <arkeet> :t find
13:00:26 <lambdabot> (a -> Bool) -> [a] -> Maybe a
13:00:27 <Vendethiel> ksf_: thanks for the link.
13:00:43 <Vendethiel> readFile "foo" >>= writeFile "bar" indeed does not look like what'd be obvious to me
13:00:52 <Vendethiel> but I've already used <- in other languages as callback-flattening
13:03:15 <Jookia> I'm finding it difficult to do things with loops in general. The other day I've wanted to loop through a list of functions that I've wanted to execute as long as they kept returning True
13:04:30 <Botje> if the functions are pure, that's just all (\f -> f x) functions
13:04:57 <Jookia> the functions are IO
13:05:06 <ksf_> that's probably the first mistake.
13:05:07 <orangerobot> is there a paper or some web page that outlines the benefits of coding with less side effects? i'm a relative newb at this at it hasn't sunk in for me yet
13:05:13 <Jookia> ksf_: Hmm?
13:05:31 <Jookia> ksf_: I kind of need to write to the disk, make sure the writes happened, and if they fail, bail
13:05:33 <ksf_> [IO Bool] sounds highly suspicious.
13:06:01 <ksf_> Jookia, we have, among other things, IO exceptions for that.
13:06:14 <ksf_> you could also use ErrorT IO
13:06:35 <Jookia> if the IO fails however i want to clean up and reverse any things I've already done
13:06:38 <Botje> orangerobot: have you read "why functional programming matters" yet?
13:06:51 <Botje> it's not exactly focused on freedom of side effects, but it's a start
13:07:14 <FreeFull> > find (>3) [1,4,5,6,2]
13:07:15 <lambdabot>   Just 4
13:08:02 <orangerobot> Botje: I haven't. a google search should bring it up, right?
13:08:06 <ksf_> Jookia, that's a bad idea. because you've got no idea whether you'll be able to actually reverse things. a *lot* of stuff can happen in IO.
13:08:38 <ksf_> if you want ACID semantics, there's packages for that.
13:08:47 <Jookia> Oh I know about that, but by IO I mean 'calling other commands to get output'
13:08:57 <Jookia> Not just filesystem stuff
13:09:01 <Botje> orangerobot: yes, it's a pretty popular article
13:09:25 <orangerobot> Botje: thanks.
13:09:25 <merijn> orangerobot: It's not specifically about coding with *less* side effects, and more about coding with explicitly tracked sideeffcts
13:09:38 <ksf_> Jookia, in any case, you'll need a transaction log. you can't extract that out of a [IO ()]
13:10:05 <ksf_> http://hackage.haskell.org/package/acid-state-0.10.0
13:10:07 <merijn> orangerobot: I've written quite a bit of haskell which is almost 80-90% in the IO monad, because the code was just very sideeffecty, but I still thought haskell helped quite a bit with that code
13:10:27 <Jookia> ksf_: I'm doing my own kind of log by having pure functions take a filesystem tree, and returning a list of commands they want to accomplish
13:11:11 <efie> luite_: There just came something differen to my mind... looking at http://stackoverflow.com/a/10866718/1219728, is this not similiar to LogFloat? LogFloat is defined as "newtype LogFloat = LogFloat Double     deriving     ( Eq [...])"? shouldn't this work in a smiliar way compare to "Score"?
13:11:25 <efie> compared*
13:11:27 <Jookia> this isn't meant to be a mission critical or 'real' application, just more fault tolerant than the previous version (written in bash with no error checking)
13:11:33 <ksf_> Jookia, and those are going to throw IOErrors should they fail.
13:12:12 <merijn> Vendethiel: It gets translated as follows "do { x <- foo; bar x; return x }" becomes "foo >>= \x -> do { bar x; return x }" which translates to "foo >>= \x -> bar x >> return x"
13:12:12 <ksf_> ...if you have a log and inverse actions you can then roll back everything.
13:12:16 <Jookia> ksf_: Well yeah, but I'd like to at least try and roll back as much on my command stack I can BEFORE throwing the towel in
13:12:22 <nomeata> Hi. What haskell libraries allows me to create a graph like http://blog.stephenwolfram.com/data/uploads/2012/03/outgoing-mail-diurnal-image.png very quickly? :-)
13:12:49 <merijn> Vendethiel: There's some other details for let, etc. but that + the type signature of >>= should get you quite far
13:13:00 <Vendethiel> yep thanks
13:13:09 <ksf_> Jookia, if you don't catch those exceptions anywhere there's going to be no rollback, as uncatched exceptions kill the whole program.
13:13:16 <luite_> efie: ah that might work, you can do a standalone deriving (deriving instance (Vector U.Vector) LogFloat) with the StandaloneDeriving extension
13:13:25 <ksf_> the thread, actually.
13:13:30 <merijn> Vendethiel: fyi, lambdabot has an @undo command that will desugar do notation for you in privmsg
13:14:08 <luite_> efie: but i thought that a deconstructor needed to be in scope for that
13:14:39 <Vendethiel> merijn: for example ?
13:15:06 <ksf_> nomeata, http://hackage.haskell.org/package/fft-0.1.7.2 should be a start
13:15:26 <ksf_> ...at least if I'm squinting correctly and that's a spectrogram.
13:15:32 <Jookia> ksf_: Ah. Well I'll keep note of that. I kind of want to reinvent the wheel a little (even if poorly) so I can learn how to use Haskell and split up a program in to pure and impure functions, by myself. So I want to have some basic error checking, that's all.
13:15:49 <Jookia> ksf_: it's a typical programmer's sleep pattern :V
13:16:36 <nomeata> ksf_: no, just a bunch of points in the plane, and the library should do the scaling of the values and interpolate and add axes and so on
13:17:07 <nomeata> I would have hoped to find such a thing at https://github.com/timbod7/haskell-chart/wiki
13:17:58 <merijn> @undo do { x <- foo; bar x; let y = baz x; return y }
13:17:59 <lambdabot> <unknown>.hs: 1: 47:Parse error: }
13:18:07 <merijn> ...
13:18:22 <merijn> oh, lambdabot doesn't do let notation in undo?
13:18:34 <merijn> @undo do { x <- foo; bar x; return (baz x) }
13:18:34 <lambdabot> foo >>= \ x -> bar x >> return (baz x)
13:18:34 <shachaf> merijn: @undo works with let notation. But that's a syntax error.
13:18:50 <shachaf> @undo do { x <- foo; bar x; let { y = baz x }; return y }
13:18:50 <lambdabot> foo >>= \ x -> bar x >> let { y = baz x} in return y
13:18:55 <merijn> oh, duh
13:19:17 <merijn> I forgot that let'd need braces to
13:23:40 <efie> luite_: Vector is from Data.Vector.Generic.Base, isn't it? this gives me "Illegal instance declaration for `Vector V.Vector LogFloat'       (Only one type can be given in an instance head."
13:24:46 <ksf_> nomeata, http://hackage.haskell.org/packages/archive/Chart/0.17/doc/html/Graphics-Rendering-Chart-Plot-Points.html ?
13:30:58 <efie> luite_: probably the syntax for stand-alone deriving declarations is a bit different?
13:32:33 <efie> luite_: when I add MultiParamTypeClasses, I get "Can't make a derived instance of `Vector V.Vector LogFloat':       The data constructors of `LogFloat' are not all in scope"
13:32:52 <luite_> efie: ah that's the one i expected :)
13:34:20 <efie> luite_: so the problem is that the data constructor LogFloat is not exported? What is the best way to solve this?
13:35:38 <nomeata> ksf_: if I’d do the pre-processing, then that would work
13:37:37 <BitPuffin> why won't haskell know that read "5" should evaluate to an int? writing 5 results in an int so why wouldn't we get an int by default with read "5"?
13:38:14 <mauke> 5 is a number, though
13:38:19 <mauke> read "..." could be anything
13:38:34 <nooodl> > 5 :: Float
13:38:36 <lambdabot>   5.0
13:38:54 <nooodl> writing 5 doesn't always result in an Int
13:39:15 <mauke> > read "5" :: Double
13:39:16 <lambdabot>   5.0
13:40:00 <BitPuffin> well by default it results in an int
13:40:05 <BitPuffin> > 5
13:40:07 <lambdabot>   5
13:40:13 <mauke> that's an Integer, not an int
13:40:13 <merijn> BitPuffin: Nope
13:40:15 <BitPuffin> if I don't annotate
13:40:19 <b2coutts> BitPuffin: 5 results to an Int, but "5" does not
13:40:26 <merijn> By default it's "Num a => a" if you don't annotate
13:40:27 <BitPuffin> no that's a String
13:40:50 <b2coutts> because 5 is already explicitly an int, but read "5" is not
13:40:58 <merijn> b2coutts: It is not
13:41:01 <nooodl> :t 5
13:41:02 <lambdabot> Num a => a
13:41:06 <nooodl> :t 5 :: Int
13:41:07 <lambdabot> Int
13:41:18 <monochrom> are you saying this? computer should deduce read "5" :: Int, read "True" :: Bool?
13:41:21 <companion_cube> :t 5 :: (Int -> Int)
13:41:22 <lambdabot>     No instance for (Num (Int -> Int)) arising from the literal `5'
13:41:22 <lambdabot>     Possible fix: add an instance declaration for (Num (Int -> Int))
13:41:22 <lambdabot>     In the expression: 5 :: Int -> Int
13:41:32 <b2coutts> oh, right
13:41:33 <merijn> companion_cube: That was removed
13:41:37 <companion_cube> aww
13:41:39 <BitPuffin> yeah I get that, but the explanation in learn you a haskell says that it can't evaluate read "5" because it wouldn't know if it should be int or float
13:41:51 <merijn> BitPuffin: Well, it doesn't
13:42:03 <merijn> BitPuffin: It decides which parse function to use based on the type
13:42:08 <merijn> Not based on the string
13:42:14 <mauke> BitPuffin: no, it wouldn't know if it should be an Int or a Float or a String or a Char or a (Complex Double, [Bool]) or a () or ...
13:42:14 <BitPuffin> merijn: no but it shouldn't really know that it
13:42:14 <BitPuffin> will be a number type
13:42:19 <merijn> BitPuffin: How?
13:42:24 <FreeFull> :t 5
13:42:25 <lambdabot> Num a => a
13:42:33 <FreeFull> :t fromInteger
13:42:35 <lambdabot> Num a => Integer -> a
13:42:44 <merijn> BitPuffin: Should it call "parseInt", "parseFloat", "parseDouble", "parseBool" or...?
13:42:55 <BitPuffin> okay well then it would be the way I thought
13:43:07 <BitPuffin> it doesn't know jack
13:43:09 <FreeFull> :t read "3"
13:43:10 <lambdabot> Read a => a
13:43:19 <BitPuffin> not just if it is a number
13:43:52 <b2coutts> BitPuffin: read "5" is ambiguous. While some may find it useful to make read have defaults, and make assumptions of what value you want, it's better for the purposes of error messages and clarity to force you to specify
13:44:08 <BitPuffin> "Most expressions are such that the compiler can infer what their type is by itself. But sometimes, the compiler doesn't know whether to return a value of type Int or Float for an expression like read "5". To see what the type is, Haskell would have to actually evaluate read "5""
13:44:29 <IanMc> i'll go if you want, but wanted to ask advice
13:44:42 <IanMc> on haskell-blah
13:48:12 <IanMc> incidentally, I expect you know this but most people use MIRC ?
13:48:25 <IanMc> there's a much better client
13:49:06 * hackagebot simplex 0.3.8 - A simple markup language that translates to LaTeX  http://hackage.haskell.org/package/simplex-0.3.8 (JulianFleischer)
13:50:02 <BitPuffin> IanMc: Quassel and Weechat and irrsi?
13:50:28 <ion> They all suck in different ways.
13:51:40 <IanMc> yeah see you're doing it again, I have no idea what that means
13:51:55 <IanMc> oh, IRC clients
13:51:58 <IanMc> nope
13:52:14 <FreeFull> I like irssi myself
13:52:21 <b2coutts> ^
13:52:23 <FreeFull> I tend to recommend hexchat to most people
13:52:24 <IanMc> but you're not using windows are you?
13:52:33 <FreeFull> I use irssi when I happen to be booted into windows too
13:52:38 <FreeFull> With cygwn
13:52:41 <FreeFull> cygwin*
13:52:43 <b2coutts> the best irc client for windows is putty
13:53:07 <IanMc> you are the point 1 percent that communicate using weird operating systems that we've never heard of, like unix :)
13:53:27 <IanMc> are we allowed to chat like this on this channel? just that I got told off once
13:53:27 <mauke> IanMc: do you realize you're on freenode?
13:53:31 <FreeFull> Well, I never force it upon anybody
13:53:44 <FreeFull> Hence my recommendation of hexchat
13:53:50 <IanMc> yeah, but don't actually to be honest really realise what that actually means :)
13:54:34 <IanMc> did write an irc client once in C=
13:54:38 <IanMc> #
13:54:48 <FreeFull> Commodore!
13:54:57 <mauke> preflex: seen ManateeLazyCat
13:54:58 <preflex>  ManateeLazyCat was last seen on #go-nuts 89 days, 6 hours, 29 minutes and 36 seconds ago, saying: After i read all package descriptions in https://code.google.com/p/go-wiki/wiki/Projects , i have to say "you guys are really nuts!".
13:55:13 <IanMc> what a memory!
13:55:31 <IanMc> you'd be cursed really with a memory like that
13:55:50 <mauke> IanMc: you seem to be completely off topic
13:55:54 <IanMc> sorry
13:56:35 <Peaker> I find it weird that Golang would attract Haskellers.. seems to appeal to a very different crowd
13:57:01 <FreeFull> I thought most haskellers were bigger on rust than go
13:57:15 <BitPuffin> Quassel is excellent if you want a GUI
13:57:16 <IanMc> I am drawn here, the sheer awsomeness of your intellects, and I'm not kidding, hoping it'll rub off
13:57:37 <SingingBoyo> rust is great, but I find it too unfinished
13:57:39 <FreeFull> You don't actually need to be that smart to do haskell
13:57:58 <FreeFull> I am proof of that :)
13:58:02 <BitPuffin> FreeFull: yes I'm big on Rust, not Go, point proven? :)
13:59:10 <IanMc> I think you have something very special here
13:59:11 <Peaker> Rust seems distasteful (from a superficial perspective)
13:59:27 <Peaker> class Monoid { ... Self ... } <-- why??
13:59:28 <IanMc> just forgot to say it
13:59:32 <Peaker> s/class/trait
14:05:19 <testingok> has anyone every used monad transformers before (MaybeT, EitherT, etc)?
14:07:47 <Peaker> testingok, of course
14:08:39 <testingok> i have heard mixed things about them, like they make code not as maintainable
14:08:50 <testingok> is that true or someone just doesnt know what they are doing
14:10:44 <Peaker> testingok, they have some disadvantages.. they are somewhat hard to learn to use (similarly to Monads themselves, I'd say) and composition can become hard. But I believe they're very much worth it in many many scenarios
14:11:03 <IanMc> thanks for letting me watch you chat guys and girls :) see you later
14:11:34 --- mode: ChanServ set +o mauke
14:11:34 --- mode: mauke set +q *!*@90.218.87.227
14:11:49 <FreeFull> A good effect system seems to be a better solution than monad transformers, but I don't think Haskell has one yet
14:13:34 --- mode: mauke set -o mauke
14:13:53 <testingok> i like the idea of transformers, because i often find myself doing some io monad, then checking to see if it passed/failed, then abort if things are going bad
14:14:21 <testingok> and rather than having to have if statements everywhere, i can just sequence everything together and let the monad take care of that stuff for me
14:15:19 <testingok> freefull, what do you mean by "a good effect system"?
14:15:57 <FreeFull> Something like the effects Idris has
14:16:10 <Peaker> FreeFull, I disagree
14:16:25 <Peaker> FreeFull, Effect systems cannot express things like non-commutative transformers
14:16:46 <Peaker> FreeFull, ContT r (t m)   vs:  t (ContT r m)
14:16:55 <Peaker> AFAIK
14:17:12 <trevize> What is the reason that 'f: a -> b' does not allow a and b to be of the same type? Those are type variables, so I would think that a and b could be of the same type.
14:17:32 <mauke> trevize: no
14:17:51 <merijn> trevize: It does allow that
14:18:09 <monochrom> it does. if you give me f:a->b, I can use it as f (True :: Bool) :: Bool, i.e. a=Bool, b=Bool
14:18:09 <merijn> :t (undefined :: a -> b)
14:18:10 <lambdabot> a -> b
14:18:18 <merijn> :t (undefined :: a -> b) :: Int -> Int
14:18:19 <lambdabot> Int -> Int
14:18:38 <trevize> hmm, then I must be doing something else wrong :-/
14:18:51 <monochrom> 99% of errors are in information not given.
14:18:53 <merijn> trevize: Hpaste code + error?
14:19:41 <Ralith> Peaker: there are times when effects are useful and times when they aren't
14:19:51 <FreeFull> Peaker: I think you're right
14:19:59 <FreeFull> But you can compose effects with monad transformers
14:21:29 <Peaker> Ralith, not sure what you're addressing
14:21:29 <trevize> merijn: I want to try to understand the code before I do that. Helps me learn if I dig through the hard parts :). I'm using classes with 2 type parameters but for some reason it's not finding my right functions when using the same type for both parameters
14:21:54 <Ralith> 14:19:36 < Peaker> FreeFull, Effect systems cannot express things like non-commutative transformers
14:22:04 <Ralith> Peaker: I'm saying that you're right, but that that doesn't mean effect systems aren't useful.
14:22:11 <merijn> Well, do you actually have an instance for that combination of parameters?
14:22:27 <merijn> trevize: Also, there's not a lot of useful help people can give you without code
14:23:04 <Peaker> Ralith, IIUC, effect systems make a particular kind of effects easier/less cumbersome to track, and transformers are more cumbersome but more powerful/general
14:23:17 <FreeFull> Ralith: I said effects systems are better, but his example demonstrates they are not as powerful and therefore not a full replacement
14:23:21 <Ralith> that sounds right to me
14:23:26 <Ralith> we are all in agreement \o/
14:23:56 <Peaker> well, I'm perfectly fine with the cumbersome nature of transformers :)  I find it a superficial limitation -- and always prefer superficial drawbacks over deeper ones
14:24:09 <Peaker> (well, I guess almost always :)
14:24:16 <trevize> merijn: I think I have an instance. Ok, if you stick around for a bit I'll carve out the code and paste it in.
14:26:34 <merijn> trevize: Clearly GHC is disagreeing with you :p
14:29:34 <trevize> merijn: GHC and I still don't think the same way
14:30:58 <trevize> merijn: here is it http://hpaste.org/90022
14:31:26 <trevize> merijn: hang on.. I missed a parameter
14:32:27 <trevize> merijn: http://hpaste.org/90023
14:33:45 <dmwit> trevize: Perhaps you should write (transform :: CompoundUnit a b -> CompoundUnit a b) instead of just transform.
14:34:01 <dmwit> trevize: Alternately, use associated types or fundeps to clarify what return type you wanted.
14:34:08 * hackagebot pipes-network 0.5.1.0 - Use network sockets together with the pipes library.  http://hackage.haskell.org/package/pipes-network-0.5.1.0 (RenzoCarbonara)
14:35:31 <merijn> trevize: 2 is not a CompoundUnit in that code
14:35:50 <trevize> dmwit: what's a fundeps? I wanted to use the class instances because I have a whole bunch of types that I want to use this function for
14:36:22 <dmwit> trevize: A functional dependency tells GHC that you expect a relation (expressed as a multi-parameter type class) to actually be a function.
14:36:27 <dmwit> There are wiki pages about it.
14:36:31 <dmwit> I've got to run now.
14:36:45 <trevize> merijn: 2 is the first parameter, second is the compound unit
14:37:45 <merijn> trevize: You only have an instance for CompoundUnit to CompoundUnit
14:37:51 <merijn> oh, wait
14:37:58 <merijn> I wasn't paying attention :p
14:38:40 <trevize> merijn: basically in this example I would expect trans_test to be same as test because transform is an identify function
14:39:27 <monochrom> trans_test needs human type annotation for reasons said by others
14:39:46 <merijn> trevize: If you add type signatures to test and trans_test it works
14:40:04 <trevize> I'll try that
14:40:28 <merijn> test, trans_test :: CompoundUnit Int Int
14:40:40 <monochrom> with multiple parameter type classes, the computer usually goes "I don't know what you want", unless you add fundeps
14:41:30 <Peaker> unless all of the type variables appear in inferrable positions in every method
14:41:30 <monochrom> or, it goes "I guess you want maximal polymorphism, but if I do that, I can't find a matching instance"
14:41:39 <trevize> no change, same error :-/
14:42:20 <trevize> i c, first time I hear of fundeps. will go read up on that
14:42:27 <merijn> trevize: Really? I literally copied that type signature line from my file and it works for me
14:42:57 <trevize> test :: CompoundUnit Int Int ?
14:43:09 <merijn> trevize: You're missing the ", trans_test"
14:44:02 <trevize> merijn: Didn't know I could declare as a list :)
14:44:12 <trevize> trying the other binding as well
14:44:42 <trevize> doh, that works for me too
14:45:48 <merijn> trevize: It can't decide whether both CompoundUnits are of the same type
14:45:51 <trevize> any way of avoiding this declaration? in my real program 'a' and 'b' are quite nested and I can't type it out
14:45:54 <merijn> Adding the type signature shows they are
14:46:07 <trevize> i c
14:46:10 <merijn> trevize: It only needs to be able to infer a and b from context
14:46:19 <merijn> In your case that's not possible
14:46:52 <Peaker> TH doesn't support constraint kinds? e.g: type Foo a = (Show a, Read a)
14:47:07 <Peaker> GHC says: "Can't represent tuple predicates in Template Haskell: Cache.Key a"
14:47:17 <shachaf> Peaker: I think that it does not.
14:47:17 <merijn> trevize: If you had a function "foo :: CompoundUnit Int Int -> Bool" and wrote "foo . transform 2 $ test" it should have worked
14:47:33 <merijn> trevize: Or rather, then you would only have needed the "test" type signature
14:51:38 <trevize> merijn: I have to say, it's still rather confusing. The 3 :+ 5 is concrete so, why doesn't it derive the type info from there?
14:55:13 <trevize> merijn: Actually, never mind I think I see what's going on here. It can't figure out the return type just by inference alone
14:58:18 <merijn> :t 3
14:58:19 <lambdabot> Num a => a
14:58:29 <franco00> Hello, I have a little problem with Text.Regex.Posix ( (=~) ). Using =~ with the expression "[^<]+" on a string like "test<foo" works (output: test), but it does not on a string like "tàst<" (so with unicode chars in it, I think). Is it a problem of the library, a problem of regular expressions or I that don't get the whole thing?
14:58:31 <merijn> trevize: 3 and 5 are not concrete in Haskell
14:58:40 <merijn> trevize: They are of type "Num a => a"
14:59:48 <franco00> (I am pretty puzzled since that was an 'exlude' pattern)
15:00:14 <merijn> trevize: Additionally, it has no way of knowing that there is no "Transform (CompoundUnit Int Int) Char" instance
15:01:41 <merijn> trevize: If you use "'c' :+ 'a'" as value for test then it only requires a type signature on trans_test
15:02:08 <trevize> merijn: so it can't decide because 3 and 5 are not concrete?
15:02:41 <jmcarthur> huh, why does Data.Vector.copy require that the mutable and immutable vectors have exactly the same length? wouldn't it be sufficient to require that the mutable vector be at least as long as the immutable vector?
15:04:09 * hackagebot Win32-services-wrapper 0.1.0.0 - Wrapper code for making a Win32 service  http://hackage.haskell.org/package/Win32-services-wrapper-0.1.0.0 (GaneshSittampalam)
15:04:44 <shergill> i'm trying to install lambdabot using cabal. i get an error for one of the modules (misfortune) complaining about not being able to find -lpcre. i am on ubuntu and have libpcre3-dev installed. do i need anything else (eg. libghc-regex-pcre-dev?)
15:05:35 <shergill> (i have ghc 7.6.3)
15:06:03 <trevize> merijn: thank you for your help, type classes are quite difficult the more I dig into it.
15:06:06 <merijn> trevize: Also because it doesn't know the return type of transform
15:06:17 <merijn> trevize: How does it know which type Transform should return?
15:06:20 <merijn> eh
15:06:24 <merijn> *transform
15:06:53 <monochrom> franco00: heh, in fact, "tàst<" =~ ".*" :: String has a problem too :)
15:07:01 <merijn> trevize: Someone could add "instance Transform (CompoundUnit Int Int) Char where ..." and the "transform 2 test" could have type Char
15:07:31 <trevize> merijn: well I was initially thinking that because I reused a,b in the instance then the input type would determine the output type. they are supposed to be the same for this instance
15:08:07 <dmwit> The way to declare that the input type determines the output type is to use functional dependencies.
15:08:21 <dmwit> That is: you are asking for the output type to depend functionally on the input type.
15:08:29 <merijn> trevize: It determines that for *that* specific instance
15:08:41 <trevize> dmwit: what's the syntax for that?
15:08:57 <dmwit> class Transform a b | a -> b where
15:09:12 <dmwit> and add {-# LANGUAGE FunDeps #-} at the top of the file
15:09:16 <dmwit> or maybe FunctionalDependencies
15:09:23 <dmwit> I can never remember. (But GHC will tell you which.)
15:09:26 <merijn> trevize: The thing you're forgetting is that you can have multiple Transform instances with the same first argument to transform
15:09:29 <franco00> monochrom: thanks, do you think it is a locale problem?
15:09:49 <monochrom> I think no, but I can't test it
15:10:20 <monochrom> ".*" should not be susceptible to locale
15:10:31 <franco00> mhhhhh
15:10:49 <merijn> Anyone with a spare machine/CPU power to waste that is willing to help me test something?
15:11:20 <merijn> You'll get the warm fuzzy feeling of helping with fixing a bug in GHC :p
15:12:32 <olalonde> noob question
15:12:37 <olalonde> is GHC written in haskell?
15:12:52 <bitonic> olalonde: yes
15:12:57 <olalonde> and what does the G stand for?
15:13:01 <nooodl> glasgow
15:13:07 <olalonde> thanks
15:13:17 <franco00> ("","un","\236c foo<end") -- this is "unìc foo<end" ~= "[^<] :: (String, String, String) monochrom . I will try to open a bug report
15:14:12 <merijn> nooodl: And/or Glorious
15:14:52 <franco00> monochrom, want to smile? http://www.haskell.org/haskellwiki/Regex_Posix#regex-posix_Bugs
15:18:02 <merijn> ok, I need some design help, as I keep getting stuck
15:19:53 <merijn> I have event types A, B and C. My event sources generate either A & B events, A & C events or A, B & C events. I have event consumers that consume A & B events, A & C events or A, B & C events. I want to have a little duplication between the event agnostic bits, but I just can't figure out how to do this sanely
15:22:52 <franco00> merijn: would it be a pain to provide datatypes/type sigs?
15:24:10 <olalonde> there's a nomadish monad sleeping on my porch what should I do? will a functor scare him away?
15:26:20 <merijn> franco00: I haven't settled yet what the datatypes should be, that's part of the question
15:26:23 <FreeFull> olalonde: You might need to break its monoid laws
15:27:09 <merijn> franco00: All my attempts to define a useful event datatype have failed, because I couldn't see how to do things without needing to define 3 versions of everything
15:28:08 <olalonde> :D
15:29:19 <byorgey> olalonde: it IS a functor, so I doubt it.  Try some Java.
15:29:32 <Aetherspawn> It'd be a great time to improve haskells llvm backend so that it becomes compatible with the new heterogenous memory architecture stuff coming out: http://hsafoundation.com/hsa-developer-tools/
15:30:24 <franco00> merijn: I know this is naive, but have you thought of data Coll = Coll (Maybe EvA) (Maybe EvB) (Maybe EvC) ?
15:30:44 <olalonde> byorgey: that worked thanks. he ran for his life
15:31:11 <franco00> you sequenced it, so to speak, olalonde
15:32:58 <merijn> franco00: The problem is, how do I prevent hooking an event source the produces B up to a consumer that doesn't accept B
15:33:16 <franco00> oh, I see
15:34:37 <Fuuzetsu> How can I load a module that imports a hidden package into GHCi? Using ‘:set -package <whatever>’ and then loading the module doesn't work.
15:34:50 <franco00> it seems there is little choice, if you want that to be checked at compile time
15:36:16 * franco00 shakes his head at a "ExitFailure 9"
15:36:28 <merijn> franco00: I doubt that, I just haven't figured out how to do it yet :p
15:36:59 <franco00> merijn: it seems an Q interesting enough to be posted on the mailing list
15:37:05 <franco00> (if you do, warn me!)
15:37:27 <merijn> I just realised that maybe I just need to use data families instead of type families
15:37:32 <merijn> I keep forgetting they exist
15:38:01 <monochrom> oh, is that why you wished for injective type families yesterday? :)
15:38:46 <merijn> monochrom: Maybe? I don't recall wishing for injective type families, but that might be because I forgot what the definition of injective was :p
15:39:44 <monochrom> or I misremember who wished for it
15:40:50 <merijn> I was saying I was a big fun of TypeFamilies ability to have lexical ordering for definitions
15:41:49 <merijn> Are there any complex data family examples somewhere? I need some inspiration beyond the really simple stuff in the GHC manual
15:47:16 <dmwit> merijn: re: A, B, C events
15:47:21 <dmwit> merijn: Sounds like a job for STM to me.
15:47:50 <dmwit> Have an A chan, a B chan, and a C chan.
15:47:56 <dmwit> Writers write to whichever chan.
15:48:08 <dmwit> Readers use orElse to read from all the chans they're interested in.
15:48:09 <dmwit> done
15:48:38 <troydm> A-chan <- that is so anime-like
15:48:47 <troydm> well nvm
15:49:17 <monochrom> I like that way too
15:49:20 <merijn> There's only a single event source, I just want to make sure that people are stopped from hooking up consumers for non-existent events
15:49:58 <merijn> Bah, github doesn't let you search the source of repo's on someones profile :\
15:51:56 <dmwit> Then I don't understand the problem description.
15:54:11 <Fuuzetsu> How can I only import instances from a module?
15:54:20 <monochrom> import Whee()
15:54:23 <merijn> I need some way to wrap the events up in a single datatype while still being able to check that I don't accidentally hook an event feed up to a consumer that doesn't accept it's events
15:54:34 <Fuuzetsu> ta
15:56:25 <dmwit> Hm. The "single datatype" requirement seems at odds with the "statically check" requirement.
15:57:08 <merijn> dmwit: I'm playing with mm_freak's netwire and wires can have only one input
15:57:18 <monochrom> there is a source SRC. it sometimes produces A, sometimes produces B, sometimes produces C.
15:57:35 <Fuuzetsu> Is there a way to _not_ export an instance then?
15:57:40 <merijn> Fuuzetsu: No
15:57:49 <Fuuzetsu> the-
15:58:20 <dmwit> Instances are global and infective.
15:58:24 <monochrom> define "data All = CaseA A | CaseB | CaseC C". make SRC produce All.
16:00:21 <monochrom> create a transducer "t :: Transducer All (Either A B)". t consumes All from SRC, discards CaseC, translates CaseA and CaseB to Left A and Right B.
16:00:35 <dmwit> monochrom: Then all consumers are doing a dynamic check that they got the type they expected. Hence my comment re: "single datatype" vs "statically check".
16:00:46 <monochrom> now a consumer that just wants to see A,B can subscribe to t instead of the original SRC
16:01:12 <monochrom> no, we statically know that a subscriber of t does not see C
16:02:02 <merijn> I should just start learning Agda >.>
16:02:47 <merijn> On that note, does anyone actually write software they use for real work in Agda?
16:04:00 <monochrom> no one likes my ideas. why should I spend time writing them up
16:05:01 <merijn> monochrom: Yeah, that's one approach I've been considering, but somehow it doesn't feel right
16:05:16 <merijn> Which, I'll admit is not a very solid argument against it, but still :p
16:05:25 <monochrom> it is lensy. it is a form of "put a lens in front of SRC"
16:05:41 <monochrom> it may even be true that the lens library already has it
16:06:51 <monochrom> when all you know is Agda, every nail looks like a dependent type.
16:07:44 <merijn> I actually had a friend that start uni with me argue that people's first programming language should be Coq and their second assembler :p
16:08:05 <Ralith> I'd be down for that
16:08:12 <roconnor> I've been thinking that Coq would make a good first language at University
16:09:01 <roconnor> Maybe Agda.
16:09:18 <roconnor> Maybe even Epigram
16:09:27 <monochrom> that is exactly the kind of people who, if gone through a math degree, opine that "K-12 should be category theory, universal algebra, rings and fields, natural number arithmetic, in that order"
16:09:30 <roconnor> not that I've used Epigram
16:09:39 <merijn> roconnor: heh, join the club
16:09:48 <merijn> I keep talking about it, but actually using it :p
16:10:17 <merijn> monochrom: He's actually the opposite of a theory guy
16:10:55 <roconnor> monochrom: Ya, I worry that I've become that.  That said I think that abstract algebra would be bad for introductory math.  It's hard to teach abstract concepts for things you haven't even learned yet.
16:11:45 <monochrom> perhaps that is true of one aspect of him. but definitely not when it comes to CS education or programming education
16:11:49 <roconnor> But for programming, I think the mindset that programs should be refined from specifications is a good attitude.
16:11:58 <roconnor> clearly there is room for disagreement.
16:12:07 <monochrom> "first language should be Coq" is clearly a theory kind of opinion
16:12:53 <roconnor> The problem is that Coq, Agda, and maybe Epigram aren't necessairly that great as teaching languages.  We need a Helium for dependent typed programming.
16:13:21 <Ralith> how 'bout idris :D
16:13:22 <roconnor> Epigram has that nice type refinement editor that I like so much.  Perhaps Agda does to to some limited extend.
16:13:58 <roconnor> Maybe idris would be good.  I don't know much about Idris or where it fits in the world of dependently typed languages
16:14:17 <Ralith> it's like agda, but with less unicode and more executing your programs
16:14:33 <merijn> :p
16:14:58 <merijn> As long as my programs compile, who cares about execution?
16:15:40 <roconnor> merijn: you must have read my blog :P
16:15:48 <augur> any good recommendations for sorting ~20-50 million item lists?
16:16:49 <troydm> augur: parallel sorting
16:17:29 <augur> troydm: i just mean like, i need to do it, i'd rather not code stuff because im sure someone has a decent library, any suggestions
16:17:30 <augur> :p
16:19:10 <augur> i just need to sort a bunch of sentences in a corpus
16:20:02 <troydm> augur: http://antimatroid.wordpress.com/2012/12/01/parallel-merge-sort-in-java/
16:20:15 <troydm> augur: http://rma350.scripts.mit.edu/home/?p=64
16:20:35 <augur> troydm: :|
16:20:38 <troydm> i don't know any ready to use libraries for that thou
16:20:48 <augur> this is #haskell not #programming
16:21:31 <troydm> augur: ups sorry, somebody was asking me something on #java so i thought your question was too Java related
16:21:33 <troydm> )
16:21:35 <troydm> :)
16:21:40 <augur> :P
16:22:15 <troydm> augur: the simplest method for haskell is described in Real World Haskell book chapter about parallel computations
16:22:42 <troydm> iirc it's using par function and quick-sort algorithm
16:22:56 <augur> ok
16:27:08 <merijn> troydm: quicksort? sounds unlikely
16:27:19 <merijn> troydm: You probably mean insert or merge sort
16:27:43 <troydm> merijn: no, quicksort
16:27:52 <troydm> merijn: algorithm is
16:27:56 <merijn> quicksort is horribly inefficient in haskell
16:27:58 <troydm> 1. get pivot point
16:28:09 <troydm> sort to left and right according to pivot
16:28:22 <troydm> and then sort right and left parts in parallel
16:28:50 <merijn> I know what quicksort is, I also know it's terribly inefficient in haskell. Meanwhile merge and insertion sort are more efficient and at least merge sort is just as easily parallelisable
16:28:56 <merijn> eh
16:32:02 <franco00> I am getting a bloody "ExitFailure 9" on cabal install regex-tdfa. Even though I only have 512Mb RAM, I don't think that's the problem (added 1Gb swap). How do I ask cabal to be more detailed on what killed the compile?
16:34:47 <merijn> franco00: -v3?
16:35:19 <franco00> thanks merijn , will try
16:39:50 <monochrom> yeah it seems to push GHC to use much memory, like 400MB
16:48:11 <afshar> hi, a stupid question :D I want to define the function "third" but then I have to do third x = x / 3; is there a way to factor x out of this definition?
16:48:27 <copumpkin> third = (/3)
16:48:28 <geekosaur> third = (/ 3)
16:48:51 <geekosaur> (this is called an operator section)
16:49:08 <afshar> wow, ok thanks
16:49:22 <geekosaur> ...be warned that removing the variable may make it subject to the monomorphism restriction
16:49:42 <afshar> ok, that :)
16:49:55 <geekosaur> so you may want to specify an appropriate type, or it will only work for Double
16:50:23 <afshar> ahh, ok I see, thanks, yes that makes sense
16:57:19 <franco00> monochrom http://paste.debian.net/10780/ <-- last 60 lines of -v3. Does anything in particular strike you as odd (becuase I have no idea on where to start)
16:59:16 <monochrom> those lines about "*** Simplifier:", "Result size of" etc are GHC's code optimization messages.
16:59:58 <monochrom> and then suddenly it's "/usr/bin/ghc returned ExitFailure 9". so I think GHC suddenly dies while optimizing code. it is very likely out of memory
17:00:20 <monochrom> perhaps try even more swap space, but it will be very slow
17:00:33 <franco00> swapon -s doesn't think that way... I will retry
17:00:51 <franco00> thanks
17:01:49 <monochrom> is it on a virtual machine provided by a greedy capitalist? it may also just kill your GHC because "it uses my CPU too much"
17:02:38 <monochrom> because another aspect of building regex-tdfa is that it takes a long time even on large physical memory
17:03:35 <franco00> mhh, machine is mine, but it is very low specced (an efika smartbook)
17:05:40 <monochrom> a wild idea: overheat, some mechanism kicks in to kill processes
17:06:39 <monochrom> a less wild idea: overheat, the hardware misbehaves, and the misbehaviour just happens to kill GHC like normal kill
17:06:57 <franco00> mhhhhhhhhhh, arm processor, that could be possible. I will try to run the compile from linux-console, so to see warning messages
17:07:17 <monochrom> anyway, it's certainly abrupt death of GHC
17:08:25 <franco00> poor ghc :P
17:09:16 * hackagebot dom-selector 0.2.0.1 - DOM traversal by CSS selectors for xml-conduit package  http://hackage.haskell.org/package/dom-selector-0.2.0.1 (nebuta)
17:17:58 <geekosaur> might be worth noting that ld.so raises SIGKILL when a delayed symbol lookup fails, which could hapen because overheating caused memory corruption
17:18:41 <franco00> oh, geekosaur , we meet again
17:19:05 <geekosaur> there's an environment variable you can set to force all symbols to be prebound before running, but that will probably just cause it to segfault or something instead
17:20:12 <franco00> I am all ears, geekosaur
17:20:20 <geekosaur> alternately it could indicate that somehow there's a shared object mismatch (or corruption on disk), in which case the prebind might get you more information, especially in conjunction with LD_DEBUG
17:21:26 <geekosaur> LD_BIND_NOW=1 LD_DEBUG=all ...
17:22:24 <NerrZ> I am having a weird error, can anyone help me out
17:22:28 <geekosaur> (where ... is the command that you're running)
17:22:37 <NerrZ> GHCi runtime linker: fatal error: I found a duplicate definition for symbol    _fps_reverse whilst processing object file    C:\Users\JoeJev\AppData\Roaming\cabal\bytestring-0.10.0.2\ghc-7.4.2\HSbytestring-0.10.0.2.o This could be caused by:    * Loading two different object files which export the same symbol    * Specifying the same object file twice on the GHCi command line    * An incorrect `package.conf' entry, causing some object
17:22:39 <geekosaur> @where justask
17:22:39 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
17:23:28 <geekosaur> very probably you have two different versions of bytestring installed and the modules you're trying to use from ghci aren't both using the same one
17:24:19 <enigmuriatic1> hpaste.org/90025     why is there a parse error on the first "<-" ?
17:24:24 <NerrZ> how would I fix that?
17:24:40 <geekosaur> see http://www.vex.net/~trebla/haskell/sicp.xhtml about cabal pulling in multiple versions of packages, why it's bad, and what you can do about it
17:25:12 <geekosaur> wht is that $ doing there?
17:25:32 <geekosaur> enigmuriatic1, what is the $ supposed to be doing( what it *is* doing is causing that error)
17:25:33 <enigmuriatic1> geekosaur: i'm not entirely sure, i guess i wanted to tie everything together to be safe
17:25:38 <geekosaur> wat
17:25:53 <geekosaur> $ is not some random magic you sprinkle in random places
17:26:29 <enigmuriatic1> geekosaur, i believe you're incorrect to begin with because there's a parse error on "case" when you remove it
17:26:56 <Fuuzetsu> f $ w x $ y z = f $ w x (y z) = f (w x (y z))
17:26:57 <geekosaur> did you reindent stuff (or at least replace the $ with a space so the indentation still works)?
17:27:15 <Fuuzetsu> (or rather, f (w x $ y z) = f (w x (y z)))
17:27:36 <geekosaur> if you simply removed the $ and left stuff indented then the `case` would be taken as a continuation of the preceding expression, and as such would be an error
17:28:54 <enigmuriatic1> it was just the indentation
17:33:26 <NerrZ> so, how do I unregister a package?
17:35:00 <Fuuzetsu> ghc-pkg unregister
17:37:01 <NerrZ> thanks
17:38:48 <NerrZ> and what is the flag to install a specific version of a package/
17:39:09 <Fuuzetsu> There is no flag. Just pass the full package name including the version in.
17:39:26 <Fuuzetsu> cabal install somepackage-1.2.3.4
17:39:56 <NerrZ> thanks
17:41:02 <NerrZ> ugh, can someone explain how to fix this to a beginner? I wasn't getting this issue on my laptop: http://hpaste.org/90026
17:43:52 <Fuuzetsu> Looks like you messed up your setup. You could probably try rebuilding bytestring or something but it's not too safe. They easiest thing to do here would be to just move onto a newer GHC version which would ignore the problem all together (separate libs for each GHC version)
17:44:00 <Fuuzetsu> The*
17:44:42 <NerrZ> what version do you reccomend, and wont that break even more things?
17:53:55 <Cale> NerrZ: It's safest to stay with whatever version of bytestring comes with your GHC.
17:54:25 <NerrZ> I don't know how to fix what I did though
17:54:36 <Fuuzetsu> NerrZ: Get GHC 7.6.3 and don't mess with bytestring
17:55:16 <NerrZ> how would that error have occured btw?
17:55:26 <NerrZ> I didnt explicitly update bytestring
17:55:50 <Cale> ghc-pkg check
17:56:33 <NerrZ> gave me a bunch of warnings
17:56:50 <NerrZ> how do I remedy them?
17:56:57 <Fuuzetsu> You're not letting us help you. Were are not psychic~
17:56:59 <Fuuzetsu> We're*
17:57:05 <Cale> Are there broken packages?
17:58:06 <NerrZ> it is giving me a bunch of things that say, haddock-interfaces, then the path, then "doesn't exsist or isn't a directory"
18:01:23 <enigmuriatic1> it's more efficient to put recursive call on the right side of ++, correct?
18:09:04 <Cale> enigmuriatic1: Yeah, xs ++ ys takes O(length xs) steps to fully evaluate
18:09:34 <arkeet> depends on what you mean by "fully evaluate"
18:09:44 <Cale> (I mean reduce to normal form)
18:09:57 <copumpkin> does it?
18:09:58 <arkeet> surely that depends on ys
18:10:06 <Cale> It does not
18:10:21 <copumpkin> so rnf (xs ++ ys) takes as long as rnf xs ?
18:10:35 <Cale> Oh, well, heh
18:11:13 <Cale> I guess that's true
18:11:35 <Cale> I'm neglecting the cost of evaluating xs or ys in the first place.
18:11:53 <copumpkin> yeah, so it adds the cost of another traversal of xs
18:18:13 <enferex> I have a function: readProcess' cmd = <- readProcess cmd [] ""  However, I get a "parse error on input '<-'"  "cmd" is a string and the normal readProcess works fine
18:18:35 <blackdog> enferex: i think you're trying to use do-notation
18:18:39 <blackdog> but you haven't started a do-block.
18:18:44 <NerrZ> Thank you for all the help cale, but I just reinstalled the platform to fix all my issues
18:18:50 <enferex> blackdog: yep!
18:19:22 <blackdog> so, is there a best-effort, heuristic mode sort of utf8 decoding i can do?
18:19:30 <Cale> NerrZ: Yeah, that's probably the easiest thing to do. Another thing I recommend is not installing any additional packages globally past that point.
18:19:37 <blackdog> i am discovering there are many sites on the web that aren't as utf8-y as they claim.
18:19:48 <blackdog> enferex: so, don't do that? :)
18:19:48 <Cale> NerrZ: This way, you can just blow away your ~/.ghc if things get too messed up
18:19:51 <shachaf> blackdog: What kind of best-effort?
18:20:05 <Cale> (and at least not have to reinstall GHC)
18:20:22 <enferex> blackdog: hmm, I tried:  readProcess' cmd = do <- (readProcess cmd [] "")   Still getting a parse error on input '<-'
18:20:23 <blackdog> shachaf: could be lossy. dump any undecipherable codepoints, perhaps?
18:20:30 <Cale> enferex: What are you trying to accomplish?
18:20:42 <Cale> (it's not clear what you intend this syntax to mean)
18:21:02 <Cale> maybe you just want   readProcess' cmd = readProcess cmd [] ""
18:21:04 <Cale> ?
18:21:08 <shachaf> blackdog: Data.Text.Encoding's lenientDecode mode will replace UTF-8 errors with replacement characters.
18:21:20 <blackdog> shachaf: brilliant. thanks.
18:21:29 <enferex> Cale: nope, since my readProcess' :: String -> String
18:21:30 <shachaf> blackdog: You can also provide your own OnDecodeError.
18:21:34 <shachaf> blackdog: See http://hackage.haskell.org/packages/archive/text/0.11.3.1/doc/html/Data-Text-Encoding-Error.html
18:21:35 <Cale> enferex: No it's not.
18:21:53 <Cale> enferex: There's no String -> String function which involves starting another process.
18:22:15 <Cale> enferex: Every function String -> String has the property that when you give it the same string, it always produces the same result.
18:23:23 <seliopou> Does anybody have a live link to the HList paper? This one's dead: http://homepages.cwi.nl/~ralf/HList/paper.pdf
18:23:29 <enferex> Cale: basically I just want to call map with the following:   map myParser (readProcess cmd)
18:23:58 <Cale> enferex: maybe you want fmap?
18:24:08 * enferex searches, thanks
18:24:13 <dmwit> Cale: You will need to lift your pure function into IO if you want to run it on some action that does IO.
18:24:16 <dmwit> h
18:24:20 <dmwit> enferex: That was at you, not Cale.
18:25:11 <enferex> Yep
18:25:29 <enferex> dmwit: I thought <- would remove the IO monad
18:25:41 <dmwit> Sorry, nope.
18:25:48 <dmwit> Once you've done IO, there's no going back.
18:25:54 <enferex> dmwit: Ok thanks
18:26:04 <Cale> enferex: Supposing that myParser :: String -> t for some type t, then you can write  do x <- readProcess cmd [] ""; let { y = myParser x }; ... use y here and it has type t ...
18:26:18 <Cale> enferex: and the entire do-block has type IO s for some type s.
18:26:25 <enferex> yep
18:32:16 <fizbin> Is there a simple name for "\pred lst -
18:33:13 <fizbin> Ugh. I mean: \pred lst -> case dropWhile pred lst {[] -> []; x -> tail x}
18:33:14 <enigmuriatic1> http://hpaste.org/90027
18:33:21 <enigmuriatic1> can someone help me out with line 112?
18:33:25 <enigmuriatic1> i'm almost there
18:34:08 <shachaf> fizbin: drop 1 . dropWhile pred?
18:34:21 * geekosaur has no idea what that fmap is supposed to be doing, but agrees with the error message
18:34:25 <fizbin> > drop 1 []
18:34:26 <lambdabot>   []
18:34:34 <fizbin> Hrm. ok.
18:34:42 <enigmuriatic1> ignore the double dashes in the lambda
18:35:34 <enferex> Cale: mind if i post my code for a bit of help?
18:36:01 <enigmuriatic1> geekosaur, i changed "blockTxs" to "(return blockTxs)" to fix that
18:36:38 <geekosaur> not in the one in the list passed to sequence
18:36:54 <enigmuriatic1> yeah, geekosaur
18:37:11 <geekosaur> fmap (++) blockTxs (blockLoop x)
18:37:28 <enigmuriatic1> is now: fmap (++) (return blockTxs) (blockLoop x)
18:37:32 <enigmuriatic1> geekosaur
18:37:34 <geekosaur> that is not a fix
18:37:43 <enigmuriatic1> but it was one of the errors, geekosaur
18:37:48 <shachaf> enigmuriatic1: Are you just trying random combinations until something passes the type checker?
18:37:49 <seliopou> what is up with the double slash in the lambda?
18:37:52 <enthropy> fmap (++) blockTxs `ap` (blockLoop x) -- might be closer to what you're after
18:37:54 <geekosaur> your paste. see line 33
18:37:59 <enigmuriatic1> shachaf no, i think that should work
18:38:13 <shachaf> enigmuriatic1: Do you know what fmap does?
18:38:17 <shachaf> :t fmap
18:38:17 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:38:25 <enigmuriatic1> yes i do shachaf
18:38:36 <shachaf> Look at the arguments you passed to fmap. Which of them has which type there?
18:38:45 <geekosaur> and as far as I can tell ewverything enigmuriatic1 does is random combinations until something passes the typechecker. see earlier $ issue
18:39:14 <enferex> Here is my code, simple monad problem, but my google foo, and lack of understanding of monads entirely has left me a bit perplexed
18:39:17 <enferex> http://hpaste.org/90028
18:39:17 <b2coutts> the brute force approach to programming
18:39:19 <geekosaur> maybe this kind of "programming" works for php. it's not going to go anywhere with haskell
18:39:42 <shachaf> geekosaur: On the contrary, the type checker is really help here.
18:39:46 <shachaf> ing
18:39:53 <enigmuriatic1> i appreciate the snark, geekosaur. does anyone have an actual answer to my question?
18:40:03 <shachaf> enigmuriatic1: Do you have an answer to my question?
18:40:07 * geekosaur doesn't feel like rephrasing that in a way pedantry can parse, so drops the subject
18:40:54 <geekosaur> enigmuriatic1, if you actually learned what you were doing, you would have the answer to your questions. not the endless stream of bizarre combinations that you seem to think ought to work for some reason, that you always bring here
18:41:16 <geekosaur> I do not get the impression that you are even trying to learn, just randomly stringing stuff otgether
18:41:41 <seliopou> geekosaur: that's what learning looks like
18:41:42 <yrlnry> I wanted to make a "Scale "type class for types that can be scaled.  I tried  « class Num s => Scale s a where scale :: s -> a -> a ».  A typical example would be «  instance Num a => Scale a a where scale = (*) »
18:41:47 <enigmuriatic1> geekosaur, i appreciate the trolling. it's because i'm on a deadline.
18:42:02 <yrlnry> I ran into all kinds of problems; the details are at https://gist.github.com/mjdominus/5794190
18:42:02 <b2coutts> spoiler: enigmuriatic1 is actually a machine learning program
18:42:14 <yrlnry> Is there a way to do this, or am I chasing a wild goose?
18:42:15 <shachaf> yrlnry: That sounds pretty overlapping.
18:42:32 <monochrom> geekosaur is not trolling
18:42:43 <shachaf> yrlnry: Remember, instance resolution is done first, and then constraints are checked.
18:43:04 <yrlnry> I don't understand what that means or why it's relevant.  Can you elaborate?
18:44:00 <yrlnry> The instance Num a => Scale a  thing is only an example.  What I really want to do is « instance Num c => Scale c (Polynomial c) »
18:44:26 <shachaf> Ah, OK. Let me look at your paste.
18:45:09 <shachaf> Maybe you want a functional dependency? E.g. Scale s a | a -> s?
18:45:20 <geekosaur> enferex, you need to learn how the IO monad works. have you worked your way through LYAH yet?
18:45:24 <geekosaur> @where lyah
18:45:24 <lambdabot> http://www.learnyouahaskell.com/
18:46:04 <yrlnry> shachaf:  I think that might be right.  I'll go eat, then read about functional dependency, then come back if I have more questions.
18:46:28 <yrlnry> Just realized I'm being stupid by trying to deal with this on an empty stomach.
18:46:32 <yrlnry> Thanks for your help.
18:47:02 <shachaf> yrlnry: Also I'm not sure that you want the Num constraint on the class. But never mind that now, I guess.
18:47:05 <shachaf> eating++
18:47:32 <yrlnry> I'm not sure I want it either, and I think in any case it will be implied by Polynomial, so is superfluous.
18:48:06 <enferex> geekosaur: Looked at it a ton, I know <- getLine would unbox the IO String and give me a String.  I figured the same would work here
18:48:39 <shachaf> yrlnry: Your issue here is an inference issue, I think. I.e. if you specify all the types explicitly, your code works?
18:49:31 <shachaf> And the fundep will probably help.
18:49:44 <geekosaur> enferex, you don't seem to have a <- in your paste? nor do you have a function which is in IO, so you can't use readProcess
18:50:08 * shachaf gets an odd sense of déjà vu.
18:50:55 <geekosaur> indeed
18:51:32 <enferex> geekosaur: i changed it, sorry
18:52:21 <geekosaur> <- is not a piece of magic that turns a random IO thingy intoa thingy that you can use without caring about IO any more
18:52:34 <geekosaur> in particular you cannot use it the way you did in the updated paste
18:52:43 <enferex> thats what I thought it was, excuse my misunderstanding, and I do appreciate you dealing with me
18:52:52 <geekosaur> and getName still claims to be pure, so it still can't use IO
18:52:58 <enferex> yep, ok
18:54:57 <arkeet> <- is only syntactically valid inside a do block.
18:55:02 <enferex> ok
18:56:05 <enferex> thanks again
18:56:18 <applikativ> what does readProcess return, just IO String?
18:56:25 <geekosaur> oh, bot turned off again? sigh
18:56:35 <arkeet> @hoogle readProcess
18:56:36 <lambdabot> System.Process readProcess :: FilePath -> [String] -> String -> IO String
18:56:36 <lambdabot> System.Process readProcessWithExitCode :: FilePath -> [String] -> String -> IO (ExitCode, String, String)
18:56:43 <applikativ> sure enough
18:56:55 <applikativ> I was thinking of the latter
18:57:08 <dmwit> yrlnry: You might take some inspiration from http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace
18:57:09 <enigmuriatic1> > let test = fmap ((++) ["hey", "does this work"])
18:57:10 <lambdabot>   not an expression: `let test = fmap ((++) ["hey", "does this work"])'
18:57:14 <geekosaur> enferex: http://hpaste.org/90030
18:57:59 <geekosaur> there are other ways to say that too but I'll spare you the fmap version for now :)
18:58:04 <arkeet> (>>= return . f) = liftM f
18:58:08 <arkeet> ... = fmap f
18:58:08 <arkeet> :(
18:58:12 <applikativ> map parsePeerName cant be right either, since map f some_string, means f :: Char -> ...
18:58:27 <arkeet> fine
18:58:29 <enigmuriatic1> > let test = fmap ((++) ["hey", "does this work"]) in test (return "probably not")
18:58:31 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
18:58:31 <lambdabot>  Expected type...
18:58:33 <geekosaur> yeh, I was wondering if they intended a use of lines in there
18:58:44 <geekosaur> or something
18:58:53 <applikativ> thats what i was wondering too.
18:58:54 <enigmuriatic1> > let test = fmap ((++) ["hey", "does this work"]) in test (return ["probably not", "meh"])
18:58:58 <lambdabot>   mueval-core: Time limit exceeded
18:59:00 <shachaf> arkeet: Where is Yoneda useful where CoYoneda is not?
18:59:17 <shachaf> People who aren't arkeet can answer too, I guess.
18:59:21 <dmwit> :t fmap (["hey", "does this work"]++)
18:59:22 <lambdabot> Functor f => f [[Char]] -> f [[Char]]
18:59:34 <arkeet> I don't know.
19:00:18 <dmwit> > fmap ((++) ["hey", "does this work"]) (return ["sure it does", "lol"]) :: [[String]]
19:00:19 <lambdabot>   [["hey","does this work","sure it does","lol"]]
19:00:36 <applikativ> yet another, enferex http://hpaste.org/90031
19:01:42 <dmwit> map parsePeerName <$> readProcess ...
19:01:56 <arkeet> I wonder why the argument to getNames isn't used.
19:02:11 <applikativ> map parsePeerName . lines <$> readProcess ...
19:02:35 <enthropy> > case () of _ | x <- 5, x == 5 -> "arkeet"
19:02:37 <lambdabot>   "arkeet"
19:02:41 <geekosaur> the code is evidently incomplete
19:02:58 <applikativ> every do-block begins with a first line
19:03:32 <monochrom> 99% of errors are in information not shown
19:04:21 <applikativ> are you saying, most errors of the mind are never expressed in speech or writing?
19:04:30 <applikativ> seems likely
19:09:15 <b2coutts> well, I went with the less deep interpretation, that 99% of errors are in code that wasn't shown on #haskell
19:26:59 <enigmuriatic1> is there a widely accepted best way to get the time a program took to run?
19:27:11 <shachaf> time ./program
19:29:19 <Fuuzetsu> @pl f g = g . g
19:29:19 <lambdabot> f = join (.)
19:29:43 <Fuuzetsu> @src join
19:29:44 <lambdabot> join x =  x >>= id
19:33:42 <Fuuzetsu> Where is the monad instance for functions defined?
19:33:52 <shachaf> ghci can tell you
19:33:59 <shachaf> With :i
19:34:32 <Tekmo> join f = \r -> f r r, I think
19:34:38 <Fuuzetsu> Ah, so it can. I was asking it the wrong thing (I was asking :i ((->) a) which is apparently a type error). Thanks.
19:34:46 <Tekmo> So join (.) = \r -> r . r
19:34:51 <Fuuzetsu> I mean, a parse error
19:34:52 <shachaf> Yep.
19:35:19 <Tekmo> Just think about the type of join
19:35:27 <Tekmo> join :: (a -> (a -> b)) -> (a -> b)
19:35:30 <shachaf> @@ @djinn @type join `asTypeIn` (\join f x -> join f x)
19:35:31 <lambdabot>  f a b = a b b
19:35:41 <shachaf> thanks, djinn. thinn.
19:36:11 <applikativ> @type asTypeIn
19:36:12 <lambdabot> a -> (a -> b) -> a
19:36:19 <applikativ> @type asTypeOf
19:36:20 <lambdabot> a -> a -> a
19:36:45 <shachaf> :t asAppliedTo
19:36:46 <lambdabot> (a -> b) -> a -> a -> b
19:37:37 <copumpkin> :t (+) `asAppliedTo` 5.0
19:37:38 <lambdabot> Fractional a => a -> a -> a
19:37:51 <Fuuzetsu> Tekmo: I'm just trying to grok how does ‘(.) >>= id’ work
19:38:11 <copumpkin> (>>= id) = join
19:38:19 <applikativ> > join ((+) `asAppliedTo` 5.0) 1
19:38:22 <lambdabot>   2.0
19:38:23 <Tekmo> It's easier to just understand 'join'
19:38:29 <shachaf> Fuuzetsu: Look at the types! There's only one reasonable implementation for these things, so it's easy.
19:38:39 <shachaf> @src (->) (>>=)
19:38:39 <lambdabot> f >>= k = \ r -> k (f r) r
19:38:45 <Tekmo> > join (,) 1
19:38:47 <Fuuzetsu> ^ is what I was looking for
19:38:49 <lambdabot>   mueval-core: Time limit exceeded
19:38:49 <shachaf> You can go through that but it'll just make your life complicated.
19:39:02 <shachaf> Fuuzetsu: Well, you shouldn't have been looking for it. You should've been figuring it out yourself!
19:39:08 <shachaf> It's a good exercise.
19:39:35 <Tekmo> (.) >>= id = \r -> id (f r) r
19:39:39 <Tekmo> = \r -> f r r
19:39:48 <Tekmo> Sorry, the `f` should be (.)
19:39:52 <Tekmo> = \r -> r . r
19:40:49 <shachaf> @@ @djinn @type (>>=) `asTypeIn` (\bind -> (.) `bind` id)
19:40:50 <lambdabot>  f a b c d =
19:40:50 <lambdabot>     a (\ e -> e) (\ f -> f) (b (\ g -> g) (b (\ h -> h) (\ _ ->
19:40:50 <lambdabot>                                                          c d)) (c d))
19:40:59 <shachaf> Uh...
19:41:02 <Tekmo> If the purpose is to learn Haskell, then I'd stay away from puzzling code
19:41:10 <Tekmo> You want your code to be easy for others to read
19:41:44 <arkeet> @type (>>=) `asTypeIn` (\bind -> (.) `bind` id)
19:41:46 <lambdabot> ((c -> c) -> (c -> c) -> c -> c) -> (((c -> c) -> c -> c) -> (c -> c) -> c -> c) -> (c -> c) -> c -> c
19:41:48 <arkeet> uh
19:41:48 <Fuuzetsu> The purpose was to figure out how it worked and that's it.
19:42:03 <shachaf> That doesn't mean you should stay away from code that puzzles *you*. Maybe it means you should stay away from writing it.
19:42:39 <arkeet> :t join (.)
19:42:40 <lambdabot> (c -> c) -> c -> c
19:42:50 <arkeet> right.
19:44:04 <applikativ> > join (.) succ 1
19:44:05 <lambdabot>   3
19:44:22 <Tekmo> :t join (.) 1
19:44:23 <lambdabot> Num (c -> c) => c -> c
19:44:28 <Tekmo> Haha
19:44:33 <Tekmo> > join (.) 1
19:44:33 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable c0)
19:44:34 <lambdabot>    arising from a use ...
19:44:45 <Tekmo> > join (,) 1
19:44:46 <lambdabot>   (1,1)
19:45:11 <Tekmo> join (,,) 1 2
19:45:15 <Tekmo> > join (,,) 1 2
19:45:16 <lambdabot>   (1,1,2)
19:45:17 <shachaf> :t join (Control.Category..)
19:45:18 <lambdabot> Category cat => cat c c -> cat c c
19:46:12 <Tekmo> Does lambdabot have `transformers` functions?
19:46:20 <shachaf> Maybe.
19:46:26 <Tekmo> > :t MaybeT
19:46:27 <lambdabot>   <hint>:1:1: parse error on input `:'
19:46:33 <Tekmo> :t MaybeT
19:46:34 <lambdabot> Not in scope: data constructor `MaybeT'
19:46:35 <Fuuzetsu> Is the monomorphism restriction removed in GHC HEAD? Some simple code compiles without the NoMonomorphismRestriction just fine on 7.7 but complains on 7.6.3
19:46:46 <shachaf> :t Control.Monad.Trans.Maybe.MaybeT
19:46:47 <lambdabot> m (Maybe a) -> Control.Monad.Trans.Maybe.MaybeT m a
19:46:52 <shachaf> I guess not imported.
19:47:19 <dolio> Fuuzetsu: I'd be surprised if so.
19:52:51 <shachaf> GHC HEAD is partial anyway. You should be using GHC LISTTOMAYBE.
19:53:20 <monochrom> haha
19:53:23 <Fuuzetsu> safeHead discussion imminent
19:54:34 * applikativ hasn't been paying attention; the new pandoc seems to have a lua interpreter built in somehow
19:54:48 <Nisstyre> oh no! partial code! the world is ending! run for your lives!
19:54:53 <Nisstyre> a possible runtime error!
19:55:18 <Fuuzetsu> applikativ: Did you finally decide that you were getting highlighted far too much with ‘applicative’ as your name?
19:55:37 <applikativ> no, just making chaos, as usual
19:55:43 <Fuuzetsu> Nisstyre: Should have been using a total language!
19:56:02 <dmwit> applikativ is applicative's Russian cousin
19:56:22 <shachaf> аппликатив
19:58:53 <flebron> Hi. Is the following piece of code possibly valid? "forever . do . foo". do isn't a function, so what's happening here?
19:59:03 <Fuuzetsu> :t do
19:59:06 <lambdabot> Empty 'do' block
19:59:19 <Tekmo> Are you the guy who posted on reddit?
19:59:55 <Tekmo> The one that had "forever . do . trade"
20:00:00 <shachaf> flebron: What's happening where?
20:00:13 <geekosaur> :t do {}
20:00:14 <lambdabot> Empty 'do' block
20:00:35 <flebron> shachaf: In that expression. How can that be valid, if do isn't a function?
20:00:47 <shachaf> Is it valid?
20:00:51 <flebron> Tekmo: No, I did see it on a reddit linked post however. http://hyperq.github.io/blog/trading-a-hacker-approach.html
20:00:58 <Tekmo> Yeah, that's the one I'm referring to
20:01:02 <Tekmo> His code example was invalid
20:01:04 <shachaf> :t undefined . do . undefined
20:01:05 <lambdabot> Empty 'do' block
20:01:08 <Tekmo> forever . do . trade is illegal
20:01:24 <flebron> Ah, OK, so it's not valid Haskell. OK, thought my parser had failed for a moment. Thanks.
20:01:34 <Fuuzetsu> > let do = 5 in do
20:01:35 <lambdabot>   <hint>:1:5: Parse error in pattern: do { }
20:01:41 <Fuuzetsu> didn't think so~
20:01:43 <shachaf> "forever . do trade" is valid, though!
20:01:52 <geekosaur> (if pointless)
20:01:53 <Nisstyre> :t undefined . (do {return 1}) . undefined
20:01:54 <lambdabot> a -> c
20:02:01 <shachaf> What does it mean when people end their sentences with a ~?
20:02:23 <Tekmo> It's the tone of voice
20:02:24 <geekosaur> their keyboard puts ~ near the return key?
20:02:48 <Tekmo> Unfortuantely, I do not know how to convey the tone of voice without reusing ~
20:03:21 <Fuuzetsu> I just think of it as slightly extending the voicing of last syllable.
20:03:28 <Tekmo> Maybe something like "didn't THINK SOoooOOO"
20:07:02 <chrisdotcode> hello everyone! :)
20:07:13 <Tekmo> Hi!
20:08:28 <chrisdotcode> if I have data Color = Red | Blue | Green | Yellow, how can I implement the changeColor function, which changes the color of the passed in value, but just doesn't create a new one?
20:08:43 <dmwit> can't
20:08:45 <dmwit> NEXT
20:08:54 <Sonarpulse> haha
20:08:59 <chrisdotcode> dmwit: ;_;
20:08:59 * geekosaur doesn't quite get the question
20:09:10 <Tekmo> What do you mean?
20:09:13 <chrisdotcode> basically, I have a color data type and some context attached to it:
20:09:16 <Tekmo> In Haskell you never mutate things
20:09:21 <chrisdotcode> well, yes
20:09:22 <dmwit> However, we have many wonderful reference types.
20:09:26 <chrisdotcode> I didn't "mutate" as in mutate
20:09:28 <dmwit> IORef, MVar, TVar to start with.
20:09:35 <chrisdotcode> data Color = Red Int | Blue Int | Green Int | Yellow Int
20:09:44 <chrisdotcode> and let's say I want to change the color without disrupting the int value
20:09:45 <shachaf> @ask elliott for ImplicitParams in lambdabot
20:09:46 <lambdabot> Consider it noted.
20:09:48 <Fuuzetsu> f (Red x) = Blue x
20:09:49 <geekosaur> nope
20:10:04 <geekosaur> aside from what Fuuzetsu suggested
20:10:06 <Tekmo> changeColor c = case c of Red n -> Blue n; Blue n -> Green n; ...
20:10:27 <chrisdotcode> Fuuzetsu: I was thinking about pattern matching, but what if there were ten Ints in that object? doesn't it become unfeasable then?
20:10:43 <dmwit> chrisdotcode: Consider data Color = Red | Blue | Green | Yellow; data ColorWithABitExtra = Color Color Int
20:10:55 <Tekmo> What is infeasible about a case statement with 10 branches?
20:10:56 <dmwit> This is nice because it extends nicely to ten Ints. =)
20:11:07 <Tekmo> Does your editor not support files longer than 10 lines?
20:11:27 <Fuuzetsu> chrisdotcode: There's no magic way to do it in general.
20:11:27 <Tekmo> More seriously, you should change the way you represent the data
20:11:36 <chrisdotcode> dmwit: so composition?
20:11:41 <Tekmo> Refactor it to (Color, Int), where data Color = Red | Blue | Green | Yellow
20:11:41 <Sonarpulse> crisdotcode: decodeColor :: (Int -> Color) -> Int -> Color
20:11:49 <Sonarpulse> decodeColor = $
20:11:53 <Sonarpulse> * ==
20:11:54 <dmwit> composition is a funny word for what I suggested.
20:11:54 <Tekmo> Then you can easily change the Color without touching the Int
20:12:10 <dmwit> (Tekmo is suggesting essentially the same thing I did.)
20:12:13 <Tekmo> Right
20:12:16 <Tekmo> *high five*
20:12:26 <shachaf> :t \f -> (. (. f))
20:12:27 <lambdabot> (a -> b) -> ((a -> c1) -> c) -> (b -> c1) -> c
20:12:33 <shachaf> That's an ugly type. There's no name for that, is there?
20:12:35 <chrisdotcode> okay, here's the truth: I'm trying to represent Pikmin, and each Pikmin has a color, but also an data Age = Leaf | Bud | Flower. So data Pikmin = Pikmin Color Age. I want to change the color of the Pikmin, without changing the age.
20:12:46 <chrisdotcode> (not sure if you guys have played Pikmin, so I didn't mention it...)
20:13:02 <Tekmo> First write the change color function for just Color
20:13:07 <Tekmo> Then you can easily modify the Pikmin using:
20:13:22 <Tekmo> changePikminColor (Pikmin c n) = Pikmin (changeColor c) n
20:13:23 <Fuuzetsu> changeColor :: Pikmin -> Color -> Pikmin
20:13:41 <Tekmo> It's even easier using lenses
20:13:48 <Tekmo> Then it would just be:
20:13:57 <Tekmo> (color %~ changeColor) myPikmin
20:14:16 <chrisdotcode> woah, that's totally awesome
20:14:28 <chrisdotcode> okay, so #1: I have to learn about lenses.
20:14:50 <Fuuzetsu> rip
20:15:13 <Tekmo> The main thing you need to do is define lenses for your Pikmin data type
20:15:24 <Tekmo> There are two ways to do this: either manually or using Template Haskell
20:15:25 <dmwit> It's probably good for your soul to do it the hard way a few times first.
20:15:29 <shachaf> lens lenses are just a generalization of "SECs", which are just functions to do this exact thing.
20:15:35 <Tekmo> I also recommend the hard way, too
20:15:38 <Tekmo> I hate Template Haskell
20:15:39 <chrisdotcode> Tekmo, the way you suggested it *might* be unfeasible if the Pikmin had too many values to pattern match against. Like:
20:15:39 <chrisdotcode> changePikminColor (Pikmin x y z a b c d) = Pikmin (changeColor x) y z a b c d
20:15:46 <shachaf> I.e. a function foo :: (Color -> Color) -> Pikmin -> Pikmin
20:15:53 <Tekmo> chrisdotcode: That's what the lenses are for
20:16:01 <dmwit> ...and when I said "hard way", I meant "not using lenses", not "not using Template Haskell".
20:16:04 <Tekmo> chrisdotcode: They allow you to easily modify sub-fields of data types with a large number of fields
20:16:12 <Tekmo> However, even without lenses you can do this
20:16:17 <Tekmo> YOu can use record syntax to do this
20:16:25 <chrisdotcode> so does using lense involve TH?
20:16:28 <Tekmo> data Pikmin = Pikmin { color :: Color, age :: Int }
20:16:32 <Tekmo> Then you can write:
20:16:57 <enferex> geekosaur: applikativ: Thanks!
20:16:57 <Tekmo> changePikminColor pikmin = pikmin { color = changeColor (color pikmin) }
20:17:05 <Tekmo> It's ugly, but it works
20:17:13 <Tekmo> That will work no matter how many fields your Pikmin type has
20:17:38 <chrisdotcode> Tekmo: and the other fields will be unaltered using that method?
20:17:45 <Tekmo> chrisdotcode: Correct
20:17:55 <chrisdotcode> the Best Way (tm) is with lenses, though, right?
20:18:02 <Tekmo> Yes
20:18:13 <Tekmo> But you don't need template Haskell for lenses
20:18:14 <dmwit> um
20:18:24 <Tekmo> It's only a convenience
20:18:36 <Fuuzetsu> I really don't think you want to push him into using lenses whet he's asking such basic level questions… Maybe doing it the usual way would be better at first.
20:18:42 <Fuuzetsu> when*
20:18:51 * dmwit == Fuuzetsu
20:18:53 <shachaf> If you generalize changePikminColor to take a function argument, you get an SEC. Then if you generalize it to use a Functor, you get a lens!
20:18:55 <Tekmo> Well, I just taught him the usual way
20:19:04 <shachaf> But ==dmwit
20:19:26 <Fuuzetsu> Tekmo: Sure but you also just seem to have convinced him to not use the usual way.
20:19:37 <Tekmo> Because the usual way is terrible
20:19:54 <dmwit> Additionally, I believe with low confidence that chrisdotcode is no longer even following the discussion.
20:20:04 <copumpkin> I think terrible is overstating it
20:20:05 <chrisdotcode> dmwit: no, I'm here xD
20:20:12 <chrisdotcode> I'm trying to wrap my head around the different solutions.
20:20:13 <copumpkin> it's certainly not ideal
20:20:15 <Fuuzetsu> Tekmo: The usual way is easy to understand and won't cause ‘this is way too hard’ type of thoughts.
20:20:25 <chrisdotcode> I'd rather have things be a bit more difficult now, and then struggle now, then to have to relearn stuff later.
20:20:44 <Tekmo> So, I'll continue the line that shachaf was talking about, except without the Functors
20:20:46 <applikativ> that the usual way is terrible is only slightly overstating it
20:20:55 <copumpkin> meh
20:20:57 <Tekmo> You can define a function of type: (Color -> Color) -> Pikmin -> Pikmin
20:20:59 <applikativ> have you considered lenses chrisdotcode ?  :)
20:21:07 <chrisdotcode> applikativ: yeah, that's what they were saying :)
20:21:07 <Fuuzetsu> …
20:21:18 <Tekmo> onColor f pikmin = pikmin { color = f (color pikmin) }
20:21:24 <arkeet> <Tekmo> changePikminColor pikmin = pikmin { color = changeColor (color pikmin) }
20:21:27 <Tekmo> onColor :: (Color -> Color) -> Pikmin -> Pikmin
20:21:27 <arkeet> with lens, this becomes
20:21:39 <arkeet> changePikminColor = color %~ changeColor
20:21:41 <Aetherspawn> I love pikmin
20:21:56 <applikativ> chrisdotcode: i was just saying it to rile copumpkin, but in fact, the elementary use of them is pretty idiot simple, as long as you can survive meaningless error messages
20:22:06 <copumpkin> :)
20:22:21 <Fuuzetsu> Meaningless error messages are probably not something you want to push a beginner into.
20:22:26 <Tekmo> I wish somebody would make a beginner-friendly `lens` package
20:22:50 <Fuuzetsu> Call it ‘not-lens’.
20:22:54 <Tekmo> Haha
20:23:00 <Tekmo> Maybe just `lens-tutorial`
20:23:11 <chrisdotcode> okay, so the easiest solution is to use what Tekmo told me: changePikminColor pikmin = pikmin { color = changeColor (color pikmin) }
20:23:17 <chrisdotcode> but the right solution is using lenses?
20:23:32 <shachaf> There is no Right Solution.
20:23:33 <Tekmo> Yes, the right solution is lenses
20:23:40 <shachaf> I would probably use lenses, though.
20:24:03 <Tekmo> Let me qualify my praise of lenses
20:24:22 <Tekmo> The `lens` package is really poorly documented, and not beginner friendly, and abuses type classes like crazy, giving bad error messages
20:24:43 <Tekmo> And the package is really large, has way too many dependencies, and it is very difficult to find the function you are looking for
20:24:44 <chrisdotcode> there's a good stackoverflow question I saw on them
20:24:52 <arkeet> Tekmo: wanna fight? D:
20:24:54 <shachaf> I would not say that it abuses type classes -- at least not the core classes.
20:24:55 <Tekmo> BUT, the basic idea behind lenses is very elegant
20:25:07 <Tekmo> So I still highly recommend them
20:25:27 <arkeet> wasn't someone going to write a lenstorial?
20:25:30 <dmwit> chrisdotcode: Lenses are the industrial-strength solution. Record syntax now, lenses in two months is the pedagogically sound solution.
20:25:39 <Tekmo> I think I've written the only lens tutorial
20:25:41 <arkeet> if you're new, I agree with dmwit.
20:26:18 <Tekmo> Can I still fight you, arkeet? :)
20:26:33 <chrisdotcode> dmwit: sounds good :D and record syntax in the form of: "<Tekmo> changePikminColor pikmin = pikmin { color = changeColor (color pikmin) }"?
20:26:38 <dmwit> right
20:26:43 <chrisdotcode> how does that work, though?
20:26:46 <Fuuzetsu> Lenses are cool but are simply not necessary in this situation and are simply overkill.
20:27:00 <arkeet> pikmin { ... }  takes your pikmin and changes some of its fields
20:27:01 <Tekmo> You know how you said that it would be a pain in the butt to write a function that changes one field in a large type?
20:27:06 <dmwit> chrisdotcode: It is shorthand for changePikminColor (Pikmin color n) = Pikmin (changeColor color) n
20:27:10 <Tekmo> Record syntax is just syntactic sugar for doing that
20:27:13 <arkeet> or rather, returns a new thing with the fields changed.
20:27:31 <shachaf> Now that arkeet lives here, y'all can have a proper duel with pistols at dawn and everything!
20:27:33 <chrisdotcode> well I know how record syntax is, but what confuses me is that using a record there and just changing one field magically seems to leave all of the rest of them the same.
20:27:47 <dmwit> It's not magic. It just copies all the other fields.
20:27:54 <dmwit> The compiler inserts the code to do this for you.
20:28:40 <Tekmo> When you write: pikmin { color = c}, it's just sugar for:
20:28:42 <dmwit> This may sound expensive, but remember that because everything is pure you can just copy each pointer. So in practice it's not too bad.
20:28:54 <Tekmo> (\(Pikmin _ age) -> Pikmin c age)) pikmin
20:29:54 <Tekmo> Or maybe more simply:
20:30:05 <Tekmo> let Pikmin _ age = pikmin in Pikmin c age
20:30:49 <dmwit> I'm sure your favorite tutorial has a section on record syntax; or else the Haskell Report is quite readable and gives the desugaring, which is very simple.
20:32:30 <chrisdotcode> so if you're creating a new Pikmin, and you're passing one it, when you create that new one, the new fields are automatically infered? like:
20:32:30 <chrisdotcode> changetoPurple Pikmin = Pikmin { color = Purple} ?
20:32:51 <chrisdotcode> so the new purple pikmin will take the Age field of the passed in Pikmin?
20:33:02 <arkeet> yes.
20:33:17 <arkeet> all the fields that aren't mentioned are simply copied.
20:33:50 <arkeet> no no.
20:33:50 <chrisdotcode> ...Oh.
20:33:53 <arkeet> no.
20:33:56 <chrisdotcode> no?
20:33:57 <arkeet> Pikmin { color = Purple}  <-
20:34:13 <geekosaur> uppercase?
20:34:14 <arkeet> variable names must begin with lowercase
20:34:21 <arkeet> Pikmin is a constructor, not a variable.
20:34:25 <chrisdotcode> er, typo aside, they are copied yes?
20:34:28 <arkeet> yes.
20:34:53 <arkeet> try it yourself.
20:35:23 <arkeet> @let data Pikmin = Pikmin { color :: String, age :: Int }
20:35:24 <lambdabot>  Defined.
20:35:36 <dmwit> Wait, that worked?
20:35:37 <arkeet> @let mypikmin = Pikmin "green" 5
20:35:38 <lambdabot>  Defined.
20:35:41 <dmwit> new lambdabot is great!
20:35:45 <arkeet> > mypikmin { color = "yellow" }
20:35:47 <lambdabot>   No instance for (GHC.Show.Show L.Pikmin)
20:35:47 <lambdabot>    arising from a use of `M7885022...
20:35:51 <arkeet> ah crap.
20:35:54 <arkeet> @let deriving instance Show Pikmin
20:35:54 <lambdabot>  Parse failed: StandaloneDeriving is not enabled
20:35:58 <arkeet> more cvrap.
20:35:59 <dmwit> awww
20:36:02 <dmwit> ?undefine
20:36:03 <lambdabot> Undefined.
20:36:09 <arkeet> @let data Pikmin = Pikmin { color :: String, age :: Int } deriving Show
20:36:09 <shachaf> @let _color f (Pikmin c a) = (\c' -> Pikmin c' a) <$> f c
20:36:10 <lambdabot>  Defined.
20:36:10 <lambdabot>  Defined.
20:36:17 <arkeet> @let mypikmin = Pikmin "green" 5
20:36:18 <lambdabot>  Defined.
20:36:19 <arkeet> > mypikmin { color = "yellow" }
20:36:21 <copumpkin> elliott: all the extensions please
20:36:22 <lambdabot>   Pikmin {color = "yellow", age = 5}
20:36:22 <shachaf> @let _age f (Pikmin c a) = (\a' -> Pikmin c a') <$> f a
20:36:23 <lambdabot>  Defined.
20:36:34 <arkeet> @let import Control.Lens.Operators
20:36:35 <lambdabot>  .L.hs:38:1:
20:36:35 <lambdabot>      Control.Lens.Operators: Can't be safely imported!
20:36:35 <lambdabot>      The ...
20:36:40 <arkeet> aw.
20:36:47 <chrisdotcode> > changeToPurple Pikmin = Pikmin { color = "purple"}
20:36:49 <lambdabot>   <hint>:1:23: parse error on input `='
20:37:04 <arkeet> again, variable names in lowercase.
20:37:12 <arkeet> and @let
20:37:17 <chrisdotcode> @let changeToPurple pikmin = pikmin { color = "purple"}
20:37:18 <lambdabot>  Defined.
20:37:31 <arkeet> > changeToPurple mypikmin
20:37:34 <lambdabot>   Pikmin {color = "purple", age = 5}
20:37:41 <chrisdotcode> ...ah
20:38:13 <arkeet> > let enlighten pikmin = pikmin { color = "light " ++ color pikmin } in enlighten mypikmin
20:38:16 <lambdabot>   Pikmin {color = "light green", age = 5}
20:38:28 <arkeet> @let import Control.Lens.Setter
20:38:29 <lambdabot>  Defined.
20:38:32 <chrisdotcode> arkeet: thank you, that *was* very enlightening :D
20:38:43 <arkeet> > pikmin & _color %~ ("light " ++)
20:38:44 <lambdabot>   Not in scope: `pikmin'
20:38:44 <lambdabot>  Perhaps you meant `mypikmin' (line 123)Not in scope...
20:38:47 <arkeet> > mypikmin & _color %~ ("light " ++)
20:38:51 <lambdabot>   mueval-core: Time limit exceeded
20:38:53 <arkeet> > mypikmin & _color %~ ("light " ++)
20:38:57 <lambdabot>   Not in scope: `&'
20:38:59 <arkeet> right.
20:39:05 <arkeet> > _color %~ ("light " ++) $ mypikmin
20:39:08 <lambdabot>   Pikmin {color = "light green", age = 5}
20:39:15 <arkeet> lens
20:39:30 * chrisdotcode quickly copies chat log
20:39:45 <chrisdotcode> and if I were to do something like:
20:39:45 <chrisdotcode> changeAlltoPurple pikmins = [ pikmin { color = "purple"} | pikmin <- pikmins],
20:39:45 <chrisdotcode> each one would also get the other fields infered, right?
20:39:55 <arkeet> should work.
20:40:11 <chrisdotcode> thanks a lot guys :)
20:40:30 <dmwit> ...inference is a strange word to use for that.
20:40:43 <dmwit> But maybe you have the idea right and just the terminology wrong, I'm not sure.
20:40:54 <dmwit> Anyway, there's no guesswork involved.
20:41:02 <chrisdotcode> dmwit: automatically being filled in, is what I meant
20:41:06 <dmwit> right, okay
20:41:19 <chrisdotcode> is there a more haskellian term for that? :-)
20:41:42 <dmwit> I use "copied". But since you have the idea right, I'm happy with whatever word you want to use for it. =)
20:42:13 <chrisdotcode> @let copied = "automatically filled in"
20:42:14 <lambdabot>  Defined.
20:42:38 <chrisdotcode> @undefine copied
20:42:39 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
20:43:01 <shachaf> elliott++
20:43:04 <shachaf> Or is it mokus++ ?
20:43:23 <shachaf> everyone++
20:43:45 <applikativ> is there a Constant functor in one of the central packages?
20:43:47 <dmwit> ?karma xs
20:43:48 <lambdabot> xs has a karma of 0
20:43:59 <applikativ> as there is Identity in mtl
20:44:18 <copumpkin> ?karma i
20:44:19 <lambdabot> i has a karma of 32
20:44:21 <dmwit> Control.Applicative.Const?
20:44:29 <copumpkin> ?karma c
20:44:29 <lambdabot> c has a karma of 1
20:44:32 <copumpkin> ?karma C
20:44:32 <lambdabot> C has a karma of 1
20:44:41 <dmwit> ?karma c/c
20:44:41 <lambdabot> c/c has a karma of 496
20:44:45 <shachaf> Ross is refusing to add Foldable/Traversable instances for Control.Applicative.Const. :-(
20:44:46 <copumpkin> lol
20:44:47 <applikativ> not there it is in transformers
20:44:48 <chrisdotcode> dmwit++
20:44:52 <chrisdotcode> arkeet++
20:44:54 <chrisdotcode> Tekmo++
20:44:57 <shachaf> Not me!
20:45:13 <copumpkin> shachaf++++++ would buy again
20:45:16 * shachaf is trying to stay karma-neutral.
20:45:24 <shachaf> If you ++ me I'll have to troll a bit to offset it.
20:45:25 <applikativ> why is Ross refusing this?  too silly?
20:45:27 <chrisdotcode> ?karma shachaf
20:45:27 <lambdabot> shachaf has a karma of 56
20:45:33 <shachaf> @karma shachaf++++
20:45:33 <lambdabot> shachaf++++ has a karma of 1
20:45:44 <shachaf> @karma+ java
20:45:45 <lambdabot> shachaf's karma lowered to 55.
20:46:06 <dmwit> funny
20:46:09 <shachaf> @ask elliott Could you take out the @karma+ java behavior on the grounds that it encourages language bashing?
20:46:09 <lambdabot> Consider it noted.
20:47:12 <applikativ> I was thinking a lens-micro package could practically find everything in base/boot packages. Just add get and set to Data.Functor.Identity and Data.Functor.Constant ...
20:48:31 <applikativ> who needs 'Mutator' and whatever 'Accessor' anyway
20:48:46 <shachaf> Mutator is another name for Identity and Accessor is another name for Const.
20:48:57 <shachaf> Oh, you just said that.
20:49:03 <applikativ> yeah, thats my point
20:49:22 <applikativ> i'm scheming to get rid of Control.Lens by secreting it in base
20:49:26 <shachaf> It's reasonably nice for the error messages you get.
20:49:43 <shachaf> And the classes are useful too.
20:49:46 <applikativ> I think Constant and Identity might actually be better
20:49:49 <applikativ> yes
20:50:00 <applikativ> #. is even better, I'm sure
20:51:04 <applikativ> I was just thinking, as Tekmo said, it would be nice to have a simpler less powerful version of the idea, maybe on condition that it was somehow compatible
20:51:23 <shachaf> @hackage lens-family exists
20:51:23 <lambdabot> http://hackage.haskell.org/package/lens-family exists
20:51:24 <applikativ> with just get set and a few other things, lens iso etc
20:51:38 <applikativ> hm
20:51:40 <shachaf> Iso isn't as easy as you might think.
20:51:46 <applikativ> maybe
20:51:52 <shachaf> The way we do it in lens uses Profunctor and all that.
20:52:36 <applikativ> the main problem with lens from my feeble point of view, is finding the definitions of things.
20:53:36 <applikativ> oh the update operations associated with State are pretty essential, I think maybe that makes it even less likely
21:04:36 * hackagebot aterm-utils 0.2.0.0 - Utility functions for working with aterms as generated by Minitermite  http://hackage.haskell.org/package/aterm-utils-0.2.0.0 (JasonDagit)
21:07:12 <Tekmo> I'd define `lens-tutorial` myself if I weren't currently busy with `pipes`
21:08:24 <shachaf> I started writing a sensible introduction to how lens works. But then I stopped. Maybe I should start again.
21:09:16 <shachaf> Or maybe I should get arkeet to do it for me.
21:09:27 <arkeet> I've thought about doing it.
21:09:37 <Tekmo> Do you have a blog, shachaf?
21:09:50 <shachaf> No.
21:09:54 <arkeet> I don't know if I have a blog.
21:09:55 <arkeet> let me check.
21:10:15 <arkeet> nope, I guess it disappeared at some point
21:10:24 <arkeet> not that there was anything on it
21:10:29 <roadfish> if I want the last 10 of a list, I can do:
21:10:32 <roadfish>    reverse $ take 10 $ reverse myList
21:10:36 <arkeet> please don't.
21:10:37 <roadfish> is there a better way?
21:10:46 <shachaf> But you have a Twitter account!
21:10:47 <Tekmo> Yes, there is
21:10:51 <arkeet> yes there is.
21:11:18 <shachaf> You can write a clever takeFromEnd with with optimal laziness.
21:11:38 <shachaf> Hmm, is the laziness actually different?
21:11:44 <arkeet> I don't think so.
21:11:52 <Tekmo> The idea is that you would start with the first 10 elements (assuming the list was 10 or more elements long)
21:12:10 <Tekmo> Then as you add each element you pop an old one off
21:12:21 <Tekmo> Then when you hit the end of the list you just return your current sequence of 10 element
21:12:30 <shachaf> In that case the double-reverse solution isn't so awful...
21:12:35 <arkeet> sounds no worse than reversing twice.
21:12:41 <arkeet> er... no better.
21:12:43 <Tekmo> The problem with double reverse is that you load the entire list into memory
21:13:15 <roadfish> unless the super-duper Haskell compiler is already optimizing this
21:13:22 <Tekmo> Give me a second to write up the algorithm I described
21:13:51 <shachaf> I guess.
21:13:59 <roadfish> (in my imagination, I ascribe mystical powers to all the pure-code optimizing that ghc does.)
21:15:55 <roadfish> I've been doing some Haskell with SQLite. I'm amazed at the powerful code that can be written so succinctly.
21:16:03 <arkeet> @let blah [] ys = ys; blah (_:xs) (_:ys) = blah xs ys; blah _ [] = []
21:16:04 <lambdabot>  Defined.
21:16:13 <arkeet> @let takeFromEnd n xs = blah (drop n xs) xs
21:16:14 <lambdabot>  Defined.
21:16:16 <arkeet> > takeFromEnd 10 [1..100]
21:16:21 <lambdabot>   [91,92,93,94,95,96,97,98,99,100]
21:16:44 <shachaf> blah = drop on Nats?
21:16:44 <Moggle_> @src foldl
21:16:45 <lambdabot> foldl f z []     = z
21:16:45 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:16:50 <Moggle_> @src foldr
21:16:51 <lambdabot> foldr f z []     = z
21:16:51 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:16:55 <arkeet> shachaf: yeah
21:17:11 <shachaf> Yep, that's a reasonable way to do it.
21:17:14 <shachaf> :t blah
21:17:15 <lambdabot> [t] -> [t1] -> [t1]
21:17:17 <Tekmo> Yeah, I like that
21:17:23 <Tekmo> More elegant than what I was trying to do
21:17:45 <shachaf> @where sneaky
21:17:45 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
21:18:10 <arkeet> @where sneaky2
21:18:10 <shachaf> @ty zipWith const
21:18:10 <lambdabot> lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = []
21:18:11 <lambdabot> [c] -> [b] -> [c]
21:18:20 <shachaf> zipWith const = flip take', I guess
21:18:26 <arkeet> yeah
21:18:57 <shachaf> I remember writing these once upon a time.
21:18:59 <arkeet> :t partitionEithers
21:19:00 <lambdabot> [Either a b] -> ([a], [b])
21:19:01 <shachaf> @where sneaky3
21:19:02 <lambdabot> I know nothing about sneaky3.
21:19:07 <shachaf> :☹(
21:19:33 <arkeet> :t \n xs -> partitionEithers (zipWith ($) (zipWith (const Left) xs ++ repeat Right) xs)
21:19:34 <lambdabot>     Couldn't match expected type `[b0 -> Either a0 b0]'
21:19:34 <lambdabot>                 with actual type `[b1] -> [Either b1 b2]'
21:19:34 <lambdabot>     In the return type of a call of `zipWith'
21:19:36 <arkeet> hmm
21:19:46 <arkeet> :t \n xs -> partitionEithers (zipWith ($) (map (const Left) xs ++ repeat Right) xs)
21:19:47 <lambdabot> t -> [b] -> ([b], [b])
21:19:54 <arkeet> oops.
21:20:05 <arkeet> :t \n xs -> partitionEithers (zipWith ($) (map (const Left) (drop n xs) ++ repeat Right) xs)
21:20:06 <lambdabot> Int -> [b] -> ([b], [b])
21:20:08 <arkeet> this is pretty awful anyway.
21:20:18 <roadfish> I have been doing Java programming on Android lately. Must say that I prefer Haskell over the massive Java boilerplate.
21:20:27 <arkeet> @let puke n xs = partitionEithers (zipWith ($) (map (const Left) (drop n xs) ++ repeat Right) xs)
21:20:28 <lambdabot>  Defined.
21:20:30 <shachaf> > (\n xs -> partitionEithers (zipWith ($) (map (const Left) (drop n xs) ++ repeat Right) xs)) 5 "hello there"
21:20:30 <arkeet> > puke 3 [1..10]
21:20:31 <lambdabot>   ("hello ","there")
21:20:34 <lambdabot>   ([1,2,3,4,5,6,7],[8,9,10])
21:20:35 <arkeet> ok
21:20:45 <shachaf> > puke 5 [1..]
21:20:49 <lambdabot>   mueval-core: Time limit exceeded
21:20:50 <arkeet> it's not lazy enough, I know.
21:20:50 <shachaf> > snd $ puke 5 [1..]
21:20:55 <lambdabot>   mueval-core: Time limit exceeded
21:20:56 <Tekmo> Well, Haskell still has it share of import boilerplate, but it's still a big improvement
21:21:09 <arkeet> well.
21:21:11 <arkeet> actually.
21:21:20 <arkeet> it can't be any less lazy.
21:21:28 <arkeet> you don't know where to start the snd until you see the end.
21:21:32 <arkeet> > fst $ puke 5 [1..]
21:21:33 <Tekmo> What do you expect that to return?
21:21:36 <lambdabot>   mueval-core: Time limit exceeded
21:21:36 <hodapp> I work with devs who treat that boilerplate as if it's the pinnacle of clarity.
21:21:40 <arkeet> hmm
21:21:41 <arkeet> > fst $ puke 5 [1..]
21:21:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
21:21:51 <shachaf> Oh, I mixed up fst and snd.
21:21:51 <arkeet> I guess that's as good as it will get.
21:21:54 <shachaf> Yep.
21:22:36 <arkeet> > partitionEithers (zipWith id (cycle [Left,Right]) [1..])
21:22:37 <lambdabot>   ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,...
21:22:41 <arkeet> > snd $ partitionEithers (zipWith id (cycle [Left,Right]) [1..])
21:22:42 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
21:23:10 <arkeet> :t liftA2 id
21:23:11 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
21:23:13 <shachaf> @let drop' :: [a] -> [z] -> [a]; drop' [] xs = xs; drop' (_:zs) (_:xs) = drop' zs xs; drop' _ [] = []
21:23:14 <lambdabot>  .L.hs:136:15:
21:23:14 <lambdabot>      Couldn't match type `z' with `a'
21:23:14 <lambdabot>        `z' is a rigid ty...
21:23:21 <roadfish> I've heard that some people are trying to get Haskell on Android. But I thing it'll be a while before you can do Haskell FRP on Android.
21:23:23 <shachaf> @let drop' :: [z] -> [a] -> [a]; drop' [] xs = xs; drop' (_:zs) (_:xs) = drop' zs xs; drop' _ [] = []
21:23:24 <lambdabot>  Defined.
21:23:36 <shachaf> @let length' = id
21:23:37 <lambdabot>  Defined.
21:23:40 <arkeet> heh.
21:23:41 <applikativ> > let dropEnd n xs = [a | b <- drop n xs | a <- xs] in dropEnd 3 "california"
21:23:42 <lambdabot>   Unexpected parallel statement in a list comprehension
21:23:42 <lambdabot>  Use -XParallelListComp
21:23:46 <applikativ> haha
21:24:10 <arkeet> @let length'' = map (const ())
21:24:11 <lambdabot>  Defined.
21:24:12 <shachaf> @let take' :: [z] -> [a] -> [a]; take' n xs = zipWith const xs n
21:24:13 <lambdabot>  Defined.
21:24:15 <arkeet> :t void
21:24:16 <lambdabot> Functor f => f a -> f ()
21:24:26 <shachaf> arkeet: Eh. Might as well keep it polymorphic.
21:24:37 * hackagebot spoon 0.3.1 - Catch errors thrown from pure computations.  http://hackage.haskell.org/package/spoon-0.3.1 (LiyangHu)
21:24:39 <arkeet> why?
21:24:46 <shachaf> @let fromInteger' n = replicate n ()
21:24:47 <lambdabot>  Defined.
21:24:53 * applikativ declares victory for ParallelListComp in the dropEnd competition
21:24:57 <shachaf> Why not?
21:25:22 <Moggle_> I'm trying to import two files I've written into GHCI with :l, but one of them imports the other. How do I tell ghci to look at all the files in the current directory?
21:25:31 <shachaf> applikativ: That's exactly the same as zipWith except longer?
21:25:39 <arkeet> @let instance Num [()] where fromInteger = flip replicate (); (+) = (++); (-) = (\\); (*) = liftA2 (const (const ())); abs = id; signum = const 1
21:25:40 <lambdabot>  .L.hs:133:28:
21:25:40 <lambdabot>      Couldn't match type `Int' with `Integer'
21:25:40 <lambdabot>      Expected ty...
21:25:47 <applikativ> it wins by intelligibility
21:25:48 <arkeet> @let instance Num [()] where fromInteger = flip replicate () . fromInteger; (+) = (++); (-) = (\\); (*) = liftA2 (const (const ())); abs = id; signum = const 1
21:25:50 <lambdabot>  Defined.
21:25:55 <applikativ> not using const
21:25:55 <blaenk> Moggle_: should import it if there's an import statement in the one you :l
21:25:56 <applikativ> and so on
21:25:57 <shachaf> @slap arkeet
21:25:57 * lambdabot decomposes arkeet into several parts using the Banach-Tarski theorem and reassembles them to get two copies of arkeet!
21:25:59 <arkeet> > 2 * 3 :: [()]
21:26:00 <Tekmo> Do you need to use functions from both files?
21:26:01 <shachaf> oh no
21:26:03 <lambdabot>   [(),(),(),(),(),()]
21:26:06 <shachaf> Moggle_: By running ghci.
21:26:13 <arkeet> > 5 - 2 :: [()]
21:26:16 <lambdabot>   [(),(),()]
21:26:25 <arkeet> > drop' 5 [1..20]
21:26:27 <lambdabot>   Could not deduce (GHC.Num.Num [z0]) arising from the literal `5'
21:26:27 <lambdabot>  from the ...
21:26:29 <arkeet> crap.
21:26:39 <arkeet> defaulting doesn't work that well, I suppose.
21:26:47 <shachaf> @let length''' xs = take' xs (repeat ())
21:26:48 <lambdabot>  Defined.
21:26:54 <arkeet> heh
21:27:03 <arkeet> @let drop'' = drop' :: [()] -> [a] -> [a]
21:27:04 <lambdabot>  Defined.
21:27:06 <arkeet> > drop'' 5 [1..20]
21:27:06 <liyang> copumpkin: shiny new spoon.
21:27:09 <lambdabot>   [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
21:27:23 <Tekmo> Moggle_: When you load files they will automatically load any other files they depend on if they have the right names and locations
21:27:30 <copumpkin> ooh
21:27:34 <copumpkin> silver spoon?
21:27:46 <Moggle_> Tekmo: uh let me give you the error
21:27:50 <shachaf> > (\xs -> drop' (length' xs - 3) xs) "hello there"
21:27:52 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
21:27:52 <lambdabot>    arising from a use of `GH...
21:27:52 <applikativ> will the functions of the imported file be in scope?
21:27:56 <shachaf> > (\xs -> drop' (length'' xs - 3) xs) "hello there"
21:28:00 <lambdabot>   "ere"
21:28:06 <shachaf> > (\xs -> take' (length'' xs - 3) xs) "hello there"
21:28:09 <lambdabot>   "hello th"
21:28:12 <Tekmo> Yes, if the file you load imports that other file
21:28:13 <shachaf> > (\xs -> take' (length'' xs - 3) xs) [1..]
21:28:14 <liyang> copumpkin: no… if you have any ideas on how to get a silver spoon in there… send a pull request. :)
21:28:17 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
21:28:21 <Moggle_> Tekmo: http://hpaste.org/90033
21:28:23 <arkeet> shachaf: nice.
21:28:30 <copumpkin> will ponder :D
21:28:46 <shachaf> Moggle_: The file names have to match the module names or GHC won't know where to look.
21:28:48 <applikativ> Moggle_: this is because of heirarchical module names
21:29:10 <Tekmo> Moggle_: You need to move your `zipperlist.hs` file to `Moggle/ZipperList.hs`
21:29:11 <shachaf> So make a directory called Moogle in your current directory, and put the files in that.
21:29:12 <Moggle_> So, zipperlist.hs should be renamed to ZipperList.hs and I should have it in the dir Moogle/
21:29:13 <Moggle_> ?
21:29:15 <Tekmo> Then `ghci` will be able to find it
21:29:17 <applikativ> Moggle_: is it in a directory Moggle/ZipperList.hs
21:29:18 <Tekmo> That's right
21:29:20 <Moggle_> thanks.
21:29:21 <liyang> copumpkin: you have commit bit now. :)
21:29:27 <copumpkin> :D thanks
21:29:35 <shachaf> (Also, it's not very standard to name modules after yourself, unlike in Java.)
21:29:35 <applikativ> oh see, Moggle_ gets it
21:29:43 <applikativ> oh I see
21:30:10 <Moggle_> shachaf: What would be the standard, then? I despise the global namespace of Haskell. Text.SomethingCombinators.Parsec is horrible :P
21:30:23 <Tekmo> Well, what are you building?
21:30:35 <applikativ> Moggle is an excellent namespace.
21:30:40 <Moggle_> Just a simple game of life application. Then I realized I should be saving my code in case I want to use some of my data structures later...
21:30:40 <shachaf> Well, you can do it if you want.
21:30:46 <applikativ> like Snap
21:30:49 <Moggle_> shachaf: But I want to do it proper :(
21:31:00 <Tekmo> If you're not going to release it publically, then use any namespace you like
21:31:11 <applikativ> Moggle_: then you have to decide is it Control, or is it Data???
21:31:16 <shachaf> applikativ: Snap is named after a project, not a person. Not so bad.
21:31:18 <applikativ> and other meaningless questions
21:31:22 <applikativ> bah
21:31:57 <Moggle_> applikativ: I was really hoping for something along the lines of python, what with "import 'pygame'" being so nice. I shall have to look into figuring out hackage's organization I suppose
21:31:59 <applikativ> if the package is named Moggle too, I'm for it; think how little typing to import it.
21:32:44 <Moggle_> again, thanks for all the help everyone :P
21:32:49 <Tekmo> You're welcome!
21:33:46 <applikativ> see the snap and heist packages.  they are following a very sensible scheme
21:34:24 <applikativ> Moggle_: ^^^ but I recommend against Moggle as shachaf says
21:34:40 <Moggle_> Out of curiosity, since module names don't correspond exactly to their package names, if I put my code on github and had my other code in a library somewhere, is there a standard way to signify that?
21:34:41 <shachaf> Perfectly fine for a library to have its own namespace.
21:34:55 <Tekmo> Then why not rename `lens` to use just `Lens` top level?
21:34:58 <yrlnry> shachaf:  the functional dependency seems to have done what I wanted.  Thanks very much.
21:35:00 <Moggle_> Like, if I put import Moogle.ZipperList --from package mooglelibs
21:35:08 <Moggle_> somewhere, is that like how it's normally done?
21:35:10 <shachaf> Hoorayrlnry!
21:35:16 <applikativ> Tekmo: ssssh, that's my secret plan for lens-micro
21:35:20 <Moggle_> seems awkward, there should be a nice way to install ALL of the dependencies.
21:35:20 <Tekmo> applikativ: Haha
21:35:29 <shachaf> @quote rwbarton Lens
21:35:30 <lambdabot> rwbarton says: edwardk now has Lens under Control
21:35:40 <arkeet> not Control.Lens.Micro?
21:35:41 <arkeet> :c
21:35:51 <Tekmo> Lens.Simple
21:35:55 <arkeet> Microscope?
21:36:00 <applikativ> why import Control.Lens.Micro when you can import Lens
21:36:13 <applikativ> Lens.Simple okay
21:36:23 <arkeet> but that might get confused with Control.Lens.Simple
21:36:25 <shachaf> Control.Lens.Internal.Bazaar.Die.Die.Die
21:36:30 <arkeet> lol
21:36:47 <shachaf> Bazaar > /me / 3, though.
21:36:57 <applikativ> i was thinking of a package simple or classique or something with e.g. the old State monad, the old Parser type and so on
21:37:21 <Tekmo> Yeah, I'm surprised there isn't a teaching package for the old monads
21:37:37 <blaenk> old monads what?
21:37:43 <Tekmo> i.e. non-monad-transformers
21:37:53 <blaenk> I'm currently learning, just wanted to know if what I'm learning is already out-dated lol
21:37:58 <Tekmo> No
21:37:59 <arkeet> blackdog: one has type State s a = StateT s Identity a, these days
21:38:00 <blaenk> ok
21:38:01 <applikativ> StateT s Identity a is a bit much
21:38:03 <martint> why did url style module hierarchy never catch on in haskell?
21:38:04 <arkeet> instead of State being its own thing
21:38:10 <blaenk> oh that
21:38:12 <arkeet> martint: becuase it's awful
21:38:13 <shachaf> blaenk: It doesn't matter because what you're learning is a way of thinking much more than particular concrete types.
21:38:27 <blaenk> yep
21:38:31 <shachaf> Anyway, writing the code for the standard monads is a good exercise.
21:38:47 <arkeet> is it a standard exercise?
21:38:58 <arkeet> (I would hope so)
21:39:12 <applikativ> yes, but you have to know what it is that you're writing the code for by hand, so to speak
21:39:13 <martint> arkeet, well it may or may not be awful, but it cuts down on name collisions or taking up common/simple names
21:39:15 <shachaf> I would hope so too. It's at the right difficulty to be an exercise.
21:39:27 <applikativ> the state monad isn't the first idea that comes into a newborn's mind
21:39:40 <arkeet> martint: I think the gain is minimal.
21:39:40 <applikativ> what is it, that would make a good exercise?
21:39:48 <shachaf> Yes. Which is why you approach things from the perspective of *first* understanding (s -> (s,a)) on its own, and only then worrying about the monad business.
21:40:10 <applikativ> Simple.State.Tutorial Simple.Reader.Tutorial Simple.Parser.Tutorial
21:40:11 <blaenk> I like the way LYAH taught that, how normally you'd pass around the 'state'
21:40:14 <shachaf> (Or (s,a) -> (s,b) if you're into that.)
21:40:17 <blaenk> and the state monad helps streamline that
21:40:18 <Tekmo> I'm into that
21:40:25 <shachaf> I know.
21:41:06 <shachaf> Anyway, obviously the only monad worth learning is Codensity.
21:41:23 <applikativ> shachaf: why would anyone be interested in the type s -> (s,a) just on its face
21:41:29 <Tekmo> Random number generators
21:41:35 <Tekmo> gen -> (Int, gen)
21:41:42 <shachaf> applikativ: Because they write some stateful code and notice the pattern coming up.
21:41:48 <shachaf> (You can nudge them along that path if you like.)
21:42:24 <applikativ> that a 'stateful pattern' is emerging, doesn't mean s-> (s,a) will dawn, and the combinators to glue such things together
21:42:38 <shachaf> That's why these exercises don't exist in a vacuüm.
21:43:02 <blaenk> ü
21:43:03 <Tekmo> You β stop using unicode
21:43:19 <liyang> He's being archaic…
21:43:33 <shachaf> Either that or Dutch.
21:43:36 <shachaf> It's hard to tell...
21:44:23 <applikativ> shachaf is unusually coöperative
21:44:25 <Tekmo> You probably won't derive the state monad yourself by accident
21:44:43 <Tekmo> But after struggling with some stateful code in a functional language, you will get why the State monad is useful and elegant
21:45:00 <Tekmo> Also, you will see the pattern to what you were doing in your own code
21:45:38 <arkeet> D
21:45:58 <shachaf> (s -> (s, s -> (s, a))) -> s -> (s, a)
21:45:59 <liyang> applikativ: bit naïve of you to think that, non?
21:46:10 <shachaf> Clearly the solution is indexed State.
21:46:24 <Tekmo> Gosh, I wish Haskell had built-in support for indexed monads
21:46:36 <Tekmo> Especially indexed state
21:46:40 <arkeet> @quote indexed.monad
21:46:40 <lambdabot> ky3 says: Indexed monads are just categories in the category of endofunctors, what's the problem?
21:47:16 <copumpkin> xplat: isn't that something you found wasn't quite true?
21:47:22 <Tekmo> No, it's true
21:47:26 <Tekmo> I verified the laws
21:47:27 <Moggle_> Tekmo: I recall a fairly simple template haskell solution for that
21:47:41 <Moggle_> Tekmo: it rebinds do notation to work with them? I think I saw it in the pipes tutorial
21:47:42 <Tekmo> I remember you asked me about it a while ago, copumpkin
21:47:49 <shachaf> copumpkin: Wasn't it dolio?
21:47:51 <Moggle_> Tekmo: I may be insane and not understanding what you're talking about though?
21:48:00 <Tekmo> Moggle_: Yeah, but it's impractical because it conflicts with ordinary `do` notation
21:48:00 <copumpkin> for a while xplat was trying to figure out what indexed monads were
21:48:09 <shachaf> It wasn't as simple as "categories in the category of endofunctors".
21:48:11 <copumpkin> Tekmo: yes, but I remember that xplat had an objection
21:48:17 <copumpkin> and I don't remember what it was
21:48:23 <arkeet> they're categories enriched over the monoidal category of endofunctors.
21:49:03 <dolio> Yes.
21:49:10 <copumpkin> okay, so not category objects?
21:49:13 <dolio> And that is not an internal category in the category of endofunctors.
21:49:15 <arkeet> indeed.
21:49:17 <copumpkin> okay
21:49:30 <copumpkin> how about the two different meanings of indexed
21:50:33 <dolio> The other meaning is monad on an indexed category.
21:50:52 <copumpkin> ah, fair enough
21:52:39 <shachaf> So I guess it's not Codensity but Ran which is the only thing worth learning.
21:53:48 <blaenk> was reading a bit about parsec, RWH's chapter on it, and out of nowhere it threw in applicative functors, it uses *> for example, which it describes as 'applies the first argument, discards the result, then applies the second and returns the result'
21:54:02 <blaenk> and it's really confusing me as to what the use of this is outside of a monad
21:54:07 <blaenk> if you just 'throw away the result'
21:54:24 <applikativ> well, what if it's e.g. whitespace?
21:54:26 <arkeet> you keep the effect.
21:54:30 <Tekmo> To answer that you need to first ask: "What is an Applicative but not a Monad?"
21:54:38 <applikativ> whitespace *> realStuff
21:54:40 <arkeet> in the context of parsing, the effect is to consume some input and possibly fail.
21:54:52 <blaenk> I think I understood the use of it in a monad, in parsec for example
21:55:03 <blaenk> what I'm having trouble with, which I think tekmo understands, is what the point of it is outside of a monad
21:55:11 <blaenk> but I guess an applicative is a monad? didn't know that
21:55:14 <Tekmo> No
21:55:19 <applikativ> @type (*>)
21:55:19 <arkeet> it's the other way.
21:55:19 <lambdabot> Applicative f => f a -> f b -> f b
21:55:20 <Tekmo> Not all Applicatives are Monad
21:55:20 <blaenk> ohhh
21:55:22 <arkeet> every monad is applicative
21:55:24 <blaenk> I misread what you said
21:55:26 <applikativ> @type (>>)
21:55:27 <lambdabot> Monad m => m a -> m b -> m b
21:55:32 <arkeet> so applicative things work with monads.
21:55:33 <blaenk> I thought you said "what is an applicative if not a monad" hahaha
21:55:37 <Tekmo> An example of a non-Monad applicative is ZipList
21:55:41 <blaenk> okay
21:55:44 <Tekmo> where pure a = repeat a
21:55:59 <arkeet> and <*> = zipWith ($)
21:56:00 <Tekmo> and fs <*> xs = zipWith ($>)
21:56:09 <applikativ> you can define a perfectly good monad instance for zipList ;)
21:56:09 <Tekmo> zipWith ($) fs xs
21:56:17 <arkeet> applikativ: are you sure?
21:56:26 <applikativ> a real example of an applicative that is not a monad is the Free Applicative on a functor
21:56:30 <shachaf> There are perhaps simpler examples, like (Const w).
21:56:37 <applikativ> arkeet: return /= pure
21:56:44 <arkeet> applikativ: that doesn't sound perfectly good to me.
21:56:58 <shachaf> Ugh, this again.
21:57:01 <blaenk> :t $>
21:57:02 <lambdabot> parse error on input `$>'
21:57:07 <blaenk> :t ($>)
21:57:08 <lambdabot>     Not in scope: `$>'
21:57:08 <lambdabot>     Perhaps you meant one of these:
21:57:08 <lambdabot>       `$' (imported from Data.Function),
21:57:09 <Tekmo> Haha, yeah, that was a typo
21:57:12 <blaenk> oh okay
21:57:14 <applikativ> shachaf: yes, but you see, the disinformation is everywhere
21:57:21 <Tekmo> fs <*> xs = zipWith ($) fs xs
21:57:26 <blaenk> got it
21:57:31 <shachaf> applikativ: Yes, especially when you're spreading it. :-(
21:57:40 <applikativ> the difference between e.g. the Free Applicative and ZipList
21:57:48 <applikativ> is totally unrecognized
21:58:01 <applikativ> people reason about the second as if it were the first
21:58:02 <Tekmo> I recognize it
21:58:14 <copumpkin> applikativ knows about Applicative
21:58:41 <blaenk> anywhere I rean read up on that "return /= pure" because that's what I learned, well not that it ==, but that usually you can just implement it in terms of return
21:58:53 <Tekmo> return = pure
21:59:13 <blaenk> oh okay so it is
21:59:14 <blaenk> cool
21:59:15 <arkeet> if you see a type that has Applicative and Monad instances that disagree, you should shoot the author.
21:59:16 <Tekmo> Yeah
21:59:21 <Tekmo> return should always be the same a spure
21:59:26 <applikativ> pure is repeat; return is singleton  both are excellent ideas
21:59:27 <Tekmo> *as pure
21:59:38 <blaenk> cool then that's how I learned it, thought someone earlier said it wasn't the case
21:59:40 <copumpkin> I want pure = replicate 5
21:59:46 <Tekmo> applikativ: You are confusing ZipList with the list monad
21:59:58 <shachaf> Tekmo: No, that's just the way applikativ is.
22:00:00 <arkeet> blaenk: ghc won't enforce it. but it's just expected.
22:00:09 <applikativ> ziplist is list
22:00:11 <shachaf> They want Applicative and Monad instances to disagree.
22:00:14 <blaenk> got it
22:00:27 <arkeet> if we had class Applicative f => Monad f
22:00:29 <Tekmo> Applicative and Monad instances should always agree
22:00:36 <arkeet> then we wouldn't need return, because return should be pure.
22:00:54 <copumpkin> @let class Applicativ f where pur :: a -> f a; app :: f (a -> b) -> f a -> f b
22:00:56 <shachaf> applikativ is also against Applicative f => Monad f
22:00:56 <lambdabot>  Defined.
22:00:57 <Tekmo> The basic idea is that if something is both an Applicative and Monad, then the following should be true:
22:01:00 <applikativ> Tekmo, as far as possible they should never agree ;)
22:01:00 <Tekmo> pure = return
22:01:03 <Tekmo> (<*>) = ap
22:01:07 <shachaf> copumpkin: Functor f => :-(
22:01:13 <copumpkin> shit, and I misspelled it
22:01:19 <copumpkin> @undef
22:01:20 <lambdabot> Undefined.
22:01:24 <applikativ> Tekmo: yeah, then why not use return and ap
22:01:26 <copumpkin> @let class Functor f => Applikativ f where pur :: a -> f a; app :: f (a -> b) -> f a -> f b
22:01:26 <lambdabot>  Defined.
22:01:27 <arkeet> Applikativ, anyway.
22:01:28 <arkeet> there.
22:01:29 <blaenk> got it, yeah that was my understanding
22:01:39 <Tekmo> applikativ: The same reason we still use Strings
22:01:55 * shachaf thinks this argument won't be productive.
22:02:03 <copumpkin> @let instance Applikativ [] where pur = repeat; app = zipWith id
22:02:04 <lambdabot>  Defined.
22:02:15 <copumpkin> applikativ: there you go :)
22:02:43 <applikativ> the correct Applicative instance for IO is concurrently from async; the best alternative is race
22:02:51 <blaenk> ohhh I remember why pure = repeat in ziplists
22:03:05 <Tekmo> applikativ: YOu are free to newtype them if you prefer a different Applicative instance
22:03:15 <copumpkin> if you have type-lengthed lists, you can make a monad out of them too
22:03:15 <applikativ> wll yes, that's right, there should be another module Idiom or Zip
22:03:20 <copumpkin> it's just the reader monad in disguise though
22:03:21 <Tekmo> applikativ: But defining a different Applicative instance is a disaster waiting to happen
22:03:41 <applikativ> call it Zip then
22:04:09 <Tekmo> applikativ: Think of it this way, if you define a distinct Applicative instance then you must duplicate every Applicative function to create a Monad equivalent
22:04:30 <Tekmo> applikativ: I don't like duplication
22:04:44 <applikativ> so just use return and ap
22:04:48 <applikativ> and fmap
22:04:52 <Tekmo> applikativ: Those aren't the only two applicative functions
22:04:57 <applikativ> or liftM preferably
22:05:06 <applikativ> we can keep going, most of them are in Control.Monad
22:05:13 <Tekmo> Oh really?
22:05:30 <Tekmo> :t Data.Sequence.replicateA
22:05:30 <lambdabot> Applicative f => Int -> f a -> f (Seq.Seq a)
22:06:13 <Tekmo> While we're at it, what about every single Traversable Lens?
22:06:52 <applikativ> This is fine, as long as it doesn't rest on the absurd argument 'ZipList is not a monad'
22:07:18 <Tekmo> applikativ: You can correctly say "There is not a monad instance for ZipList that agrees with the Applicative instance"
22:07:30 <applikativ> right, pure isn't return
22:07:32 <shachaf> This is sounding like a pretty useless discussion, and one that's been had in here before several times.
22:08:01 <blaenk> whats the relation between pure and fmap and <$> again? <$> is infix fmap, and fmap f x is like pure f <*> x?
22:08:03 <Tekmo> Like I said, having differing instances is a huge design mistake
22:08:08 <shachaf> Maybe carry on in #haskell-overflow?
22:08:20 <arkeet> blaenk: (<$>) = fmap  (by definition)
22:08:29 <Tekmo> I'll abandon the discussion when you guys come up with something more interesting to talk about
22:08:30 <arkeet> liftA f x = pure f <*> x,  and liftA should agree with fmap
22:08:49 <arkeet> (it's the law!)
22:08:52 <applikativ> Tekmo: this is pure dogma, in fact.  The suggestion that it is good practice was part of the scheme for secreting Control.Applicative into base
22:08:53 <blaenk> oh okay
22:09:36 <blaenk> liftA should agree with fmap, that means they're the same right
22:09:38 <shachaf> arkeet: "it's the theorem" doesn't have the same ring to it, does it.
22:09:39 <blaenk> " "
22:09:40 <Tekmo> Right
22:09:45 <blaenk> ok
22:09:52 <arkeet> :t liftA2
22:09:53 <arkeet> er
22:09:54 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
22:10:04 <arkeet> my finger automatically went to the 2 key :(
22:10:07 <arkeet> :t liftA
22:10:08 <lambdabot> Applicative f => (a -> b) -> f a -> f b
22:10:09 <arkeet> :t fmap
22:10:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:10:24 <Tekmo> :t liftM
22:10:24 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
22:10:28 <Tekmo> What?
22:10:32 <Tekmo> Where is that 1 coming from?
22:10:38 <shachaf> It's in the type.
22:10:47 <shachaf> I don't know why they switched to this weird type variable naming scheme.
22:10:50 <applikativ> its not in the source1
22:10:50 <shachaf> :t liftM4
22:10:50 <Tekmo> Oh my god
22:10:51 <lambdabot> Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
22:10:52 <Tekmo> That is so ridiculous
22:10:54 <shachaf> It's in the source.
22:10:54 <arkeet> it is in the source.
22:10:58 <applikativ> oh my god
22:11:05 <shachaf> :t liftM5
22:11:05 <Tekmo> It is in the source
22:11:05 <lambdabot> Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
22:11:11 <Tekmo> I had to do a double-take
22:11:18 <applikativ> I was convinced very quickly, yes
22:11:24 <shachaf> Type variables with numbers in them are the devil.
22:11:56 <applikativ> usually i get them from ghc when i commit egregious offenses
22:12:08 <m3ga> what version of cabal understands -j for parallel builds?
22:12:44 <byorgey> m3ga: the most recently released version does, i.e. 1.16
22:12:49 <shachaf> m3ga: I think the first releast of cabal-install that had it was 1.16
22:12:50 <byorgey> not earlier than that IIRC
22:12:59 <shachaf> What byorgey said.
22:13:03 <Tekmo> It's definitely not in 1.14
22:13:15 <m3ga> so its 'cabal build -j' right?
22:13:16 <AfC> m3ga: 1.16
22:13:25 <shachaf> m3ga: No, it's cabal install -j
22:13:26 <Tekmo> cabal install
22:13:27 <AfC> m3ga: cabal install -jN
22:13:35 <shachaf> m3ga: It's only across packages, not across modules in the same package.
22:13:45 <byorgey> m3ga: cabal build -j will not help very much, because it only does package-level parallelism, and cabal build just builds a single package
22:14:07 <byorgey> hopefully after this year's GSoC we will get module-level parallelism...
22:14:08 <shachaf> There are two GSoC projects this year to do the latter.
22:14:10 * byorgey crosses his fingers
22:14:31 <mgsloan> Just in time to buy a mactube pro!
22:14:45 <shachaf> GSoC coding starts tomorrow!
22:14:48 <byorgey> eh? a what?
22:15:01 <shachaf> A #haskell-blah thing.
22:15:10 <mgsloan> (seriously, when ghc gets module-level parallelism, I'm going to get a workstation computer)
22:15:10 <m3ga> shachaf: ah, of course. when build a single package it gives a rather confusing error message (cabal: unrecognized option `-j6')
22:15:20 <m3ga> if you're expecting something else that is.
22:15:30 <mgsloan> byorgey: Oh, the next mac pro is a cylinder - it's actually pretty neat
22:15:41 <arkeet> it looks like a trash can
22:15:45 <byorgey> crazy
22:15:55 <byorgey> why would I want a cylindrical computer?
22:16:13 <Tekmo> Well, then you dno't have to buy a trash can
22:16:19 <mgsloan> Because it's revolutionary!  I think the excuse is a clever cooling system
22:16:31 <byorgey> both good reasons.
22:17:15 <shachaf> It sure is hard to transplant conversations across channels.
22:17:37 <shachaf> Is there ever a good reason to use Yoneda instead of CoYoneda?
22:17:59 <shachaf> There are many cases where CoYoneda is better than Yoneda in various ways.
22:18:03 <Tekmo> I feel like Edward has blogged about this
22:18:23 <arkeet> comonad.com is still gone :(
22:18:42 <shachaf> And monad.m doesn't even resolve.
22:18:48 <Tekmo> I think the new one is http://www.kmett.com/reader/
22:18:49 <arkeet> :(
22:18:51 <Tekmo> But it won't load
22:19:00 <Tekmo> No wait, it barely did
22:19:05 <arkeet> I get a <title> at least
22:19:24 <blaenk> can someone give me a non-monadic use of *> or <*, like in a ziplist like Tekmo was talking about
22:19:35 <shachaf> Oh, hmm, that has the old content.
22:19:48 <shachaf> blaenk: The simplest example I know is Const.
22:19:56 <shachaf> It's like Writer, except without the value.
22:19:58 <blaenk> will check that out
22:20:04 <shachaf> newtype Const w a = Const w
22:20:10 <arkeet> instance Monioid w => Applicative (Const w)
22:20:15 <oxryly> i think i've been on this channel for a couple weeks. that can't be normal.
22:20:16 <arkeet> but Const w is only a Monad if w is ()
22:20:17 <shachaf> instance Monoid w => Applicative (Const w) where exercise
22:20:26 <arkeet> (or isomorphic to it)
22:20:47 <arkeet> I mean monad, not Monad.
22:20:52 <arkeet> and can be, not is.
22:21:05 <shachaf> instance (w ~ ()) => Monad (Const w)
22:21:05 <Tekmo> Here's a useless example:
22:21:05 <Tekmo> getZipList (ZipList (replicate 3 ()) *> ZipList [1..])
22:21:11 <Tekmo> > getZipList (ZipList (replicate 3 ()) *> ZipList [1..])
22:21:12 <lambdabot>   [1,2,3]
22:21:20 <blaenk> oh okay thanks
22:21:43 <Tekmo> There are supposed to be Applicative-only parsers, too
22:21:47 <Tekmo> Those would be more practical examples
22:21:48 <arkeet> > getZipList (ZipList 3 *> ZipList [1..])
22:21:49 <lambdabot>   Could not deduce (GHC.Num.Num [a0]) arising from the literal `3'
22:21:50 <lambdabot>  from the ...
22:21:51 <blaenk> oh okay
22:21:53 <arkeet> oh right.
22:22:14 <shachaf> Const w is pretty practical!
22:22:47 <shachaf> Anyway, the important difference between the Applicative API and the Monad API is that in "f a", the "f" part can't depend on the "a" part.
22:22:58 <shachaf> Whereas with Monad it can.
22:23:06 <arkeet> you should make that more precise.
22:23:09 <shachaf> Yes.
22:23:11 <shachaf> No, you should.
22:23:21 <Tekmo> Well, the more precise way is to just copy and paste the definition of the Applicative class
22:23:28 <arkeet> no, you can't change your answer like that.
22:23:47 <Tekmo> I want to correct one thing about shachaf's answer
22:23:53 <shachaf> blah blah context-free blah blah context-sensitive blah blah spoons blah blah swordfish blah blah blah
22:23:54 <Tekmo> Applicative doesn't tell you what you cannot do
22:24:14 <Tekmo> All type class interfaces in Haskell are positive.  They tell you what you are allowed to do, but do not forbid anything
22:24:15 <arkeet> whereas Monad can?
22:24:23 <arkeet> :p
22:24:30 <Tekmo> No, not even monad
22:24:37 <shachaf> Yes, the difference between the Applicative API and the Monad API.
22:24:52 <Tekmo> It's more correct to say that the Applicative alone does not let you do such and such
22:25:07 <shachaf> Right. That's why I specified that it's the difference between the APIs.
22:25:10 <Tekmo> Right
22:25:38 <arkeet> well, the intuition is that a monad lets effects depend on values.
22:26:01 <shachaf> The "f"ect can depend on "a" value.
22:26:05 <arkeet> ok.
22:26:12 <shachaf> hth
22:26:18 <Tekmo> That still sounds a bit weird to me
22:26:22 <Tekmo> What would you call pure, then?
22:26:24 <shachaf> OK, that was just an anti-arkeet remark.
22:26:25 <Tekmo> pure :: a -> f a
22:26:32 <arkeet> pure x doesn't have any effects.
22:26:35 <shachaf> pure is a primitive that gives you a nothing-effect.
22:26:41 <arkeet> sure.
22:26:42 <Tekmo> Alright, I'll buy that
22:26:53 <blaenk> sold
22:26:55 <shachaf> There can be other primitives too. Each particular Applicative instance gives you other primitives.
22:27:09 <shachaf> Just like Monad.
22:27:10 <arkeet> but e.g. if you only use the applicative interface for a parser, you can't use values you've seen to determine what to consume next.
22:27:50 <arkeet> corollary: a program that only uses the applicative interface for IO is useless.
22:27:56 <Tekmo> For example, you can't do this with an Applicative: do { n <- parseInt; xs <- replicateM n parseDouble; ... }
22:28:00 <arkeet> well, not entirely.
22:28:06 <Tekmo> That's not true
22:28:06 <arkeet> but it will do the same thing each time it's run.
22:28:09 <copumpkin> you could still build parsers that have that as primitive
22:28:17 <copumpkin> that chunk of logic :)
22:28:22 <arkeet> sure.
22:28:33 <shachaf> unit :: f () and liftA2 (,) ::  f a -> f b -> f (a,b) is another way to present Applicative.
22:28:45 <copumpkin> that's the categorical way!
22:28:54 <shachaf> lift0 :: a -> f a; lift2 :: (a -> b -> c) -> f a -> f b -> f c is another way!
22:28:55 <Tekmo> Another common feature of Applicative-only types is that their control flow can be statically analyzed
22:29:15 <shachaf> Both of these ways seem much clearer than pure/(<*>).
22:29:33 <Tekmo> For example, the optparse-applicative library uses an applicative option parser so that it can statically compute command line completion behavior
22:31:04 <shachaf> A lot of the things you might read about Arrow apply to Applicative too except not horrible.
22:31:48 <boothead> hi folks. Is there a way to ignore unmapped fields in Aeson? I have a data declaration with 12 fields but I'm trying to convert an object with 16 (I don't care about the ones that aren't mapped)
22:32:43 <Tekmo> I haven't used it yet, but I thought it already worked that way
22:33:14 <Tekmo> Does the "MyDataType <$> v.: "fieldA" <*> v .: "fieldB" ..." trick not work?
22:34:07 <boothead> The problem is that I've use deriveJSON and it seems to hardcode a length check in there...
22:34:20 <Tekmo> How large is your data type?  Can you avoid using deriveJSON?
22:35:23 <Tekmo> The other option is modifying deriveJSON to remove the length check
22:36:43 <boothead> Tekmo: the applicative trick would probably work. I'm generating my data types from json embedded in the documentation for a web service so I already know what the fields are... It would be nice if the docs mathched what's sent over the wire though!
22:37:23 <shachaf> Now you're just being ridiculous.
22:38:13 <Tekmo> So the JSON values you are decoding have more fields than the docs declare?
22:38:37 <enferex> I have another monad issue.  http://hpaste.org/90035.  I need to convert a String to an IO String
22:38:50 <enferex> I could write a helper routine, but didnt want to do that
22:39:06 <Tekmo> Do you want this function:
22:39:10 <Tekmo> sequence :: [IO a] -> IO [a]?
22:39:40 * hackagebot aterm-utils 0.2.0.1 - Utility functions for working with aterms as generated by Minitermite  http://hackage.haskell.org/package/aterm-utils-0.2.0.1 (JasonDagit)
22:39:43 <shachaf> enferex: I think perhaps you just want to get rid of that second "return".
22:39:47 <Tekmo> Also, your type signature does not match
22:39:50 <Fuuzetsu> Without reading the paste, return (x :: String)
22:39:54 <shachaf> And fix the type.
22:40:17 <boothead> Tekmo: yes... FAIL
22:40:27 <enferex> sorry i suck :-(
22:40:56 <Tekmo> It's ok
22:40:57 <shachaf> Also you're not using the "word" argument at all.
22:41:20 <Tekmo> I wish I could have lambda bot use getLine
22:41:22 <enferex> i tried to simplify my problem, i have failed
22:41:39 <Tekmo> You need to explain what you want `countdown` to do first
22:41:42 <shachaf> Well -- the first step is udnerstanding what your problem is.
22:42:11 <enferex> shachaf: yes
22:42:18 <Tekmo> boothead: I think you should take a stab at fixing the `makeJSON` function
22:42:27 <Tekmo> boothead: Unfortunately, I'm not very experienced with GHC generics
22:42:36 <lispy> and if this is your first time in #haskell, you have to understand what your problem is
22:42:44 <lispy> (that's the third rule of #haskell)
22:42:45 <boothead> Tekmo: I just had a look at deriveJSON...Not sure if you've read Snow Crash, but I feel like someone just Namshubbed me!
22:42:56 <Tekmo> boothead: I haven't, but I get the gist :)
22:43:15 <enferex> Fixed it!
22:43:17 <enferex> I feel awesome
22:43:18 <enferex> thanks
22:43:21 <lispy> Has anyone here use language-java?
22:43:34 <lispy> I just discovered, there is a lot of java code that it does not grok
22:44:01 <Tekmo> boothead: The closest I can figure out is that the last two functions use `length`.  Maybe those are the culprits?
22:44:08 <boothead> Tekmo: like a baseball bat to the back of the head
22:45:26 <lispy> I think java generics are beyond it
22:45:37 <boothead> Tekmo: yes there's an import of HashMap.size that is the culprit. As I'm generating the code anyway I think I can output an instance declaration for FromJSON and ToJSON instead of the lazy deriveJSON.
22:45:46 <boothead> more work though :-(
22:46:10 <Tekmo> boothead: Yeah :(
22:46:32 <boothead> actually I can still deriveToJSON I suppose
23:19:51 <[mth]> Can anyone tell me the best XMPP library around? Specifically would like good MUC support.
23:20:32 <shachaf> When you find out which one is the best, make sure to email the authors of all the other ones and tell them they might as well give up.
23:21:42 <[mth]> shachaf: ?
23:21:53 <shachaf> Never mind.
23:26:01 <Ralith> is there a win64 haskell platform available?
23:26:57 <shachaf> There is GHC>
23:27:23 <Ralith> why no platform?
23:28:06 <shachaf> Who knows.
23:28:15 <shachaf> I think Win64 GHC is relatively new.
23:28:56 <Heffalump> it is quite new, and IME not everything works yet (I tried to build darcs for it a while ago and ran into problems, haven't had time to investigate them in detail yet)
23:36:28 <efie> Hi, I want to modify and use this modified version of a package. In folder X I do "cabal unpack Y". I then modify the .hs file, go back tofolder X and say "cabal unstall Y --reinstall". However, the orginial package is downloaded and installed again, not my modified version
23:37:03 <efie> I'm sure it worked when I did it a few days ago but now it doesn't...
23:37:36 <luite_> efie: cabal install --reinstall
23:37:39 <luite_> don't need the package name
23:38:41 <efie> luite_: ah! thanks :)
23:40:15 <brainproxy> in context of Maybe, trying to understanding if there is any difference with regard to Just and return
23:40:28 <brainproxy> i mean in a do context
23:41:25 <shachaf> brainproxy: return = Just
23:41:57 <Kneiva> what about Just Nothing vs. return Nothing?
23:42:29 <shachaf> return = Just, which means that anywhere you see return, you can replace it with Just.
23:42:43 <shachaf> (Assuming that it's being used with m = Maybe.)
23:43:17 <brainproxy> sorry for being newb, is `return` just for the last part of a do ?
23:43:29 <brainproxy> or you can use it anywhere you are doing something with <-
23:44:03 <shachaf> return is just a regular function (in a type class).
23:44:06 <blackdog> brainproxy: return is just a function
23:44:07 <shachaf> :t return
23:44:08 <lambdabot> Monad m => a -> m a
23:44:11 <shachaf> > return 5 :: Maybe Int
23:44:12 <lambdabot>   Just 5
23:44:31 <brainproxy> okay, I feel I'm on the right track
23:44:50 <brainproxy> thanks
