00:00:02 <adinapoli> it's the estimate date for Simon's book on concurrency to be released
00:01:21 <pharaun> on haskell?
00:01:23 <adinapoli> http://www.amazon.co.uk/Parallel-Concurrent-Programming-Haskell-Multithreaded/dp/1449335942/ref=wl_it_dp_o_pC_nS_nC?ie=UTF8&colid=1KBZ3VN4J42S4&coliid=I16S4NKPXG6QNF
00:01:38 <pharaun> ah nice
00:02:03 <frelux> from then on, everyone can just respond to questions like mine with that link : ))
00:02:19 <pharaun> bookmarked
00:02:19 <adinapoli> definitely nice :D I mean, it's nothing you can't find searching for the multitude of slides/videos Simon Marlow published on the topic, but nevertheless is fantastic to have those on a book
00:02:54 <adinapoli> (at least this is my impression, maybe there is some new unreleased content as well :=) )
00:05:56 <aleator_> Geez. What do I have to do to get ghc import Data.Text with -XSafe on? Hackage says that text is trustworthy, but -trust doesn't seem to help.
00:08:12 * hackagebot ideas 1.1 - Feedback services for intelligent tutoring systems  http://hackage.haskell.org/package/ideas-1.1 (BastiaanHeeren)
00:21:03 <alpounet> adinapoli, frelux, you can read what's already published online though
00:21:51 <frelux> yeah, I have! it is excellent
00:21:53 <adinapoli> alpounet: I know, but I'm a book-fetish for this kind of things.. reading in front of a screen is not as appealing as having a paperback book in my hands :D
00:22:12 <johnw> adinapoli: I am almost the exact opposite
00:22:32 <adinapoli> johnw: fair enough :P
00:23:00 <alpounet> right, i prefer books too! and i'll certainly want to pay for the content when it's out, but I will still read most of it online (read a lot of it already)
00:23:20 <Mortomes> I've grown to prefer reading on a screen too, laptop is easier to keep in place than a book, imo :P
00:23:32 <alpounet> because… july 22nd is so far in the future, and the content is just right there, waiting for me to look at it
00:24:03 <johnw> the video presentation on async was quite good
00:24:44 <dmwit> For my money, e-ink is superior to LCD for reading. Longer battery life, enormous contrast, and not staring at a fluorescent light the whole time.
00:25:30 <dmwit> Refresh rate and color are not so important for text (though can be for figures).
00:25:46 <aleator_> dmwit: Do you know if the newer einks are fast enough to browse through pdfs?
00:26:09 <aleator_> dmwit: I rarely read in consecutive manner anything that is not prose.
00:26:20 <johnw> this conversation is better taken off channel at this point, though
00:27:17 <dmwit> aleator_: My Kindle's UI sucks for random access. For further discussion, ask me more in #-blah or PM.
00:32:16 <aleator_> Migrating to a newer version of text is a bit painful experience.
00:33:11 <aleator_> But still, not worth blowing away the whole .cabal.
00:52:51 <johnw> hi
00:52:57 <johnw> wrong channel
00:53:06 <arcatan> so no hi to you
01:02:33 <Wavewash> Hi guys
01:03:32 <Wavewash> I'm trying to pick up haskell and I've got some super simple/stupid questions
01:04:07 <Wavewash> In the line :m System.Random what does the :m represent?
01:04:54 <Botje> "load this module"
01:05:03 <Wavewash> Does it load into m?
01:05:21 <Botje> no, it's just short for :module
01:05:26 <Wavewash> Ah.
01:07:23 <Wavewash> I'm sorry if I'm asking something that's foolish... googling for ":m haskell" doesn't seem to bring up a syntax or information for :m
01:07:29 <arkeet> try :help
01:09:28 <Botje> it's a GHCi feature, more than a haskell feature
01:09:49 <Botje> Wavewash: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/ghci.html
01:10:34 <Wavewash> Ah... I see. :m and :help bring up stuff in GHC just fine.
01:13:27 <arkeet> "in GHC"?
01:13:37 <arkeet> (surely you mean ghci)
01:14:47 <Wavewash> Arkeet: sorry- GHCi
01:18:18 <Wavewash> Botji: Thank you for the help!
01:26:30 <Aetherspawn_> :t fromMaybe
01:26:31 <lambdabot> a -> Maybe a -> a
01:42:36 <m_hyperbolic> Hello people. Is the infix operation in haskell 'cooked into' the language, or implemented in the languge ?
01:42:56 <Botje> you mean the infix keyword?
01:43:05 <Botje> or the fact that you can do 5 `div` 2?
01:43:22 <m_hyperbolic> The latter.
01:43:51 <Botje> that's a property of the parser.
01:44:08 <Botje> (and specified in the haskell report, of course)
01:45:39 <m_hyperbolic> Ah ok. I will take look there :)
01:50:18 <chord> anyone alive here?
01:50:27 <Taneb> No
01:50:35 <Taneb> There are no living Haskell programmers
01:50:42 <Taneb> Not since the fire.
01:50:46 <johnw> we have transcended
01:51:00 <augur> @faq can Haskell help you ascend to a higher plane of being?
01:51:00 <lambdabot> The answer is: Yes! Haskell can do that.
01:51:01 <shachaf> There is only silence and some second-hand clothes.
01:51:01 <johnw> you may now refer to us as the Collective
01:51:23 <shachaf> @ask elliott Could you replace @faq with a link to the FAQ?
01:51:23 <lambdabot> Consider it noted.
01:51:31 <chord> what would you guys think If I said Lisp > Haskell
01:51:41 <KoF_> But can Haskell tell us why kids love cinnamon toast crunch?
01:51:45 <augur> chord: i would say you need to define your measure function!
01:51:50 <johnw> we'd think you were trolling
01:51:58 <augur> @faq can Haskell tell us why kids love cinnamon toast crunch?
01:51:58 <lambdabot> The answer is: Yes! Haskell can do that.
01:52:08 <KoF_> I do like using Scheme more than I like using Haskell.
01:52:11 <Taneb> Lisp does functional program somewhat half-heartedly
01:52:14 <shachaf> I'd think "oh, wait, I remember you".
01:52:27 <johnw> shachaf has a good troll memory
01:52:51 <shachaf> Either that or logs.
01:53:09 --- mode: ChanServ set +o shachaf
01:53:11 <KoF_> But that's mostly just because I tend to find solutions that feel more "satisfying" in Scheme than I do in Haskell.
01:53:15 --- mode: shachaf set +b *!*322f5788@*.50.47.87.136
01:53:15 --- kick: chord was kicked by shachaf (ban evasion)
01:53:18 --- mode: shachaf set -o shachaf
01:53:31 <augur> shachaf: :o
01:54:12 <pharaun> heh
01:55:49 <watermind> My only problem with haskell is that I'm not convinced "pure" is the way to go
01:55:55 <shachaf> johnw: It is because of chord's trolling that I'm an op in here.
01:56:00 <watermind> effects should be reflected on the type system
01:56:21 <johnw> shachaf: it's appreciated
01:56:22 <shachaf> Effects are reflected in the type system.
01:56:41 <watermind> yes they are, and I am saying I agree that they should
01:56:53 <johnw> huh?
01:56:58 <watermind> but not necessarily in such an intrusive manner
01:57:00 <johnw> is this the tautology club?
01:57:24 <johnw> the first rule of tautology club is the first rule of tautology club
01:57:26 <watermind> nah... e.g. effect systems are another way of reflecting effects on the type system
01:57:48 <watermind> my point is, I agree effects should be reflected on the type system, but not necessarily the "haskell way"
01:58:15 <augur> johnw: the second rule of tautology club is that for all relations R such that ...
01:58:50 <augur> it'd be nice if haskell could slip into silent monads when necessary
01:59:19 <watermind> and haskell design somehow aknowledges that when it comes to exceptions... I get the semantic justification, exceptions semantically are bottom
01:59:22 <watermind> but no
01:59:25 <watermind> bullshit
01:59:26 <augur> like, since we all know that IO is a monad, and that we can have a nice monadic semantics for languages like ML, why not have some monad regions of code
01:59:32 <watermind> we are throwing an exception
01:59:45 <augur> where you can just write ML-looking code that is automatically lifted into the IO monad
01:59:55 <augur> sort of like idiom brackets
01:59:55 <watermind> it's just a semantic hack to justify staying faithful to our pure principles
01:59:58 <johnw> i like things being explicit, it keeps me mindful
02:00:05 <johnw> i was just thinking about idiom brackets when you said that
02:00:34 <augur> johnw: what i find difficult about haskell's stance on purity is that lots of things that should be relatively nice, syntactically, become a pain, because the monads clash
02:00:47 <augur> for instance, do x <- [0...1] ; putStr (show x)
02:00:53 <augur> obviously doesnt work because the monads dont like up
02:01:25 <watermind> monads make for a nice meta language on which you can translate some more user friendly language
02:01:42 <watermind> sure we can use it directly, but sometimes it is a pain
02:01:44 <augur> you can of course do things like mapM_ (putStr.show) [0...10] but now you have juggle this stuff in your head in all sorts of weird ways
02:02:00 <johnw> nor should that line up
02:02:05 <johnw> you can't do IO in the list monad
02:02:05 <augur> johnw: i know it shouldnt
02:02:08 <adnap> print = putStr . show
02:03:05 <augur> johnw: the point is that there are lots of cases where i find myself wanting to write stuff like that but i cant and the "right" solution ends up being a lot harder to understand
02:04:23 <watermind> there are already things that "shouldn't" in haskell... semantics do not define order of evaluation, and you can throw exceptions, therefore we have "imprecise exceptions"
02:06:31 <augur> you can define a semantics that does define order of evaluation, but that's a different issue.
02:07:32 <watermind> it's not that different, the way I see it the real problem with having side effects in haskell, is not so much that we really want to stay pure, but that even if we wish to do so we can't because we lack knowledge about evaluation order
02:08:51 <watermind> for instance if semantics did specify evaluation order, we could do with references the same we do with exceptions
02:08:57 <watermind> could be interesting
02:09:13 <watermind> but using references in a non deterministic manner doesn't work
02:09:32 <watermind> while for exceptions, it still doesn't but it's good enough kinda... so we do it
02:10:57 <watermind> by doing the same for state I mean, e.g.,  take write to have type ()  andmake references only readable in IO()
02:11:20 <watermind> similar to throwing an exception which is pure and catching it which is not
02:11:52 <watermind> in a context where all the code is pure, you can ignore all the "writes"
02:12:14 <watermind> much like if you never catch exceptions all the throws are just bottom
02:12:56 <watermind> it's pretty much the same philosophy, difference between both is, regardless whether it's a good idea or not we can't do it because there no defined order of eval
02:13:04 <srhb> regarding the example given, I find it easy to understand the juggling as long as you remember that you've just made a recipe for IO, say, and you can then choose to "execute it"
02:13:18 <srhb> ie sequence_ $ [ print x | x <- [1..10] ]
02:13:49 <srhb> I don't think that's painful at all, it helps me reason about my code more.
02:14:00 <srhb> re augur
02:14:55 <augur> srhb: ymmv
02:15:41 <srhb> Sure..
02:15:51 <watermind> srhb: that's fine, but now instead of print it's read and it can throw an exception (as in the exception monad) bit more complex no?
02:16:21 <srhb> Of course, but you're adding complexity to the problem as well.
02:16:28 <srhb> Is that strange?
02:16:49 <watermind> sure it does reflect the inherent complexity of having mixed side effects, but if possible languages should offer way of dealing with such complexity
02:16:55 <srhb> I don't think a lot of implicit lifting would help anyway.
02:17:55 <watermind> I don't know... I don't think explicitelly propagating exceptions in coproducts is the way to go either...
02:22:55 <augur> srhb: it probably wouldnt. im just not used to writing IO in the haskell style, so i end up confused a lot, even tho i get monads
02:26:53 <akamaus> can anyone suggest a decent command line parsing library?
02:29:05 <augur> akamaus: i think there's a library for parsing cl arguments
02:29:37 <augur> akamaus: http://leiffrenzel.de/papers/commandline-options-in-haskell.html maybe?
02:29:38 <akamaus> augur, there are a whole dozen of them, I'm afraid
02:31:58 <danil> cmdtheline and optparse-applicative are both fairly reasonable
02:32:48 <donri> i like optparse-applicative other than the name :p
02:32:58 <donri> and you get bash completions for free
02:35:32 <Aetherspawn_> @src return
02:35:32 <lambdabot> Source not found. Are you on drugs?
02:35:38 <Aetherspawn_> rude.
02:36:05 <Taneb> @src return []
02:36:05 <lambdabot> Source not found. :(
02:36:10 <Taneb> @src [] return
02:36:10 <lambdabot> return x    = [x]
02:36:44 <donri> @src Maybe return
02:36:45 <lambdabot> return              = Just
02:38:17 <akamaus> danil, thanks, applicatives are nice :)
02:38:19 * hackagebot compdata 0.7 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.7 (PatrickBahr)
02:57:24 <johnw> compdata looks nice
03:13:23 * hackagebot hakyll 4.3.0.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.3.0.0 (JasperVanDerJeugt)
03:41:26 <schoppenhauer> hello. I want to have a record with a few references and an array which must be modified destructively. is it possible to do this inside Control.Monad.ST?
03:42:12 <schoppenhauer> the main problem I have is that I can destructively change an IORef to such a record, but can I destructively change an array *inside* this record as well?
03:42:53 <shachaf> ST has mutable arrays. They are not compatible with IORef.
03:43:07 <schoppenhauer> shachaf: sorry, I meant STRef
03:43:31 <schoppenhauer> shachaf: the problem: I want a mutable array inside a record I hold an STRef to
03:43:34 <schoppenhauer> *onto
03:43:40 <schoppenhauer> shachaf: is this possible?
03:44:01 <shachaf> Sounds possible? What's the problem?
03:45:17 <johnw> schoppenhauer: you can have an STRef within an STRef, but better to describe your problem in greater detail
03:45:50 <shachaf> schoppenhauer asked about an array, not an STRef. But yes. Ask as complete a question as you can.
03:46:03 <schoppenhauer> shachaf: after I read the STRef, I would have to access the array inside this STRef, and then modify it, and then modify the STRef to the new thing.
03:46:03 <schoppenhauer> shachaf: it somehow sounds like a problem to modify the inner thing wihout having multiple layers of "runST"s
03:46:19 <shachaf> Why would you modify the STRef?
03:46:23 <shachaf> You said it was a mutable array.
03:46:50 <schoppenhauer> shachaf: yes.
03:47:07 <schoppenhauer> shachaf: ah ok, I see the flaw in my thoughts, thx.
03:47:17 <shachaf> If you have "multiple layersof runSTs" you're probably doing something wrong.
03:48:14 <schoppenhauer> ok. hm, another question: Is there something like StateT for ST?
03:48:24 <schoppenhauer> I need to be able to throw errors.
03:48:42 <schoppenhauer> (and catch them)
03:50:53 <johnw> schoppenhauer: why are you not just using IO then?
03:51:13 <johnw> there is this, however: http://hackage.haskell.org/packages/archive/STMonadTrans/0.3.1/doc/html/Control-Monad-ST-Trans.html
03:51:52 <shachaf> johnw: I suspect answering schoppenhauer's question won't help them.
03:52:07 <johnw> I'm starting to get that feeling
03:52:10 <johnw> XY
03:52:15 <shachaf> A better pursuit is probably helping them figure out the right question to ask.
03:53:25 * hackagebot haskell-reflect 0.1 - Reflect Haskell types.  http://hackage.haskell.org/package/haskell-reflect-0.1 (JulianFleischer)
03:55:36 <schoppenhauer> johnw: I can use IO as well, actually I do not care ... is there IO-Trans?
03:56:07 <typoclass> schoppenhauer: could you tell us what you're planning? when you need too many of the heavier guns (IORefs, ST, mutable arrays), it's sometimes an indication that you're approaching something from the wrong angle
03:56:26 <shachaf> There is not an IO transformer. There is also not an ST transformer. It's very likely that it's not what you want.
03:59:36 <schoppenhauer> I *need* an array with a backbuffer (as I needed it yesterday, and the day before yesterday, and the day before)
03:59:36 <schoppenhauer> (and as nobody could provide me ...)
04:00:14 <schoppenhauer> I tried out several possibilities, but haskell's resistency against optimization is overwhelming.
04:00:51 <schoppenhauer> it's like they built in an AI that notices optimization efforts and then tries to circumvent them in some strange way.
04:01:08 <schoppenhauer> so I give up and will try to recode everything in the ST or IO monad.
04:01:12 <typoclass> schoppenhauer: well, they didn't do that
04:01:53 <schoppenhauer> the problem now is that I need to combine ST and Error/Either.
04:02:06 <Taneb> EitherT (ST s)
04:02:12 <Taneb> Might work
04:02:31 <Taneb> Would not recommend the path you tread, though
04:02:47 <typoclass> schoppenhauer: hm, i should look at the logs for the last few days. were you the person who a few days ago asked if unsafePerformIO was atomic?
04:02:49 <schoppenhauer> Taneb: what path would you then recommend?
04:03:45 <schoppenhauer> typoclass: yes. apparently, it is. and apparently, haskell evaluates stuff it is not supposed to (and I mean _really_ not supposed to, as in, things that make no sense, because they can never occur anywhere)
04:04:03 <schoppenhauer> typoclass: I implemented some sort of diffarray, and the program runs correctly, but much too slow.
04:04:38 <schoppenhauer> typoclass: and tracing shows that ... a lot of stuff is done with my array which just makes no sense.
04:04:57 <schoppenhauer> typoclass: that is what I mean with "AI trying to mock me"
04:06:03 <typoclass> schoppenhauer: ok i can understand that you're frustrated, but what you're describing still sounds to me like there's a wrong approach in there somewhere. (regarding haskell evaluating "stuff it's not supposed to" and such)
04:06:26 <typoclass> schoppenhauer: anyway, i think it'd help if you could post your code to hpaste.org
04:06:46 <Taneb> What's the consensus on "rules-only" classes
04:06:58 <merijn> Wouldn't it an array with backbuffer not be easily done by having two TVar's with an array and then atomically swapping the TVar's when done?
04:07:57 <merijn> Or something similar using MVars or whatever
04:08:30 <merijn> It doesn't seem that overwhelmingly hard?
04:08:49 <Taneb> I want to add a "class Group g => Abelian g" to Data.Group
04:09:55 <merijn> schoppenhauer: As far as I can see you just need two mutable arrays for your operations and then a swap which can be implemented in a ton of different ways?
04:09:56 <typoclass> schoppenhauer: if you could show the code and the results (trace logs, etc.), i bet folks can explain to you why things are being evaluated that shouldn't be evaluated. (i personally probably can't, but people on #haskell and/or -cafe can)
04:10:17 <merijn> Unless I'm missing something
04:10:24 <int-e> Taneb: FWIW, to me that would be "laws", not "rules" (rules having to do with {-# RULES #-} pragmas)
04:10:56 <merijn> int-e: Well, those might enable some rules
04:11:19 <typoclass> Taneb: sounds sensible to me, as long as you clearly document it
04:11:29 <merijn> int-e: i.e. rules that abuse the fact that some associativity holds can only be implemented for a class guaranteeing said associativity laws
04:11:32 <int-e> Taneb: And I don't feel strongly about such classes either way.
04:11:40 <int-e> merijn: sure.
04:12:01 <Taneb> Unfortunately, all the classes that have Group instances so far there are Abelian
04:16:17 <watermind> Taneb: add one that isn't :P
04:23:16 <watermind> schoppenhauer's comments do raise an interesting question though... wouldn't it be useful to have an ST monad with local exceptions?
04:24:19 <watermind> semantically it seems easy, it just has to come equipped with a defaul reference for errors and an operation to throw errors (which would set that reference)
04:25:31 <hpc> what would you do with uncaught exceptions?
04:25:54 <watermind> hpc: you wouldn't catch exceptions in the monad, just raise them
04:26:17 <watermind> hpc: when running the monad you'd get an Either
04:26:28 <watermind> depending on whether an exception was ever raised
04:26:44 <hpc> then you should use EitherT
04:26:53 <hpc> or ErrorT or whatever it is
04:27:24 <watermind> sure, would avoid the lifting and simplify the types though
04:27:38 <hpc> it wouldn't make ST any simpler
04:28:07 <hpc> now we need a new type for "ST without that frustrating exception handling"
04:28:50 <watermind> I didn't mean ST should be changed, there could be an STEx
04:30:08 <watermind> state already forces you to sequence computations, you might as well be able to interrupt them
04:30:45 <aleator_> is unpacking a lazy bytestring lazy also?
04:31:01 <hpc> aleator_: unpacking to String? should be
04:31:08 <aleator_> hpc: Thanks!
04:31:16 <hpc> a lazy bytestring is a linked list of strict bytestrings
04:31:20 <Cale> Wow, looks like hpaste's machine is having some trouble
04:31:25 <Cale> A web handler threw an exception. Details:
04:31:25 <Cale> /tmp/hpaste-cache/paste-89817.html: hClose: resource exhausted (No space left on device)
04:31:30 <hpc> so unpack = foldr unpack "" or something like that
04:31:31 <eikke> > Data.ByteString.Lazy.unpack undefined
04:31:32 <lambdabot>   Not in scope: `Data.ByteString.Lazy.unpack'
04:31:42 <typoclass> Cale: oh wow
04:32:10 <hpc> eikke: i assumed lazy in the sense of "doesn't evaluate the full bytestring to whnf the result"
04:32:43 <aleator_> I meant 'lazy-by-the-chunk'. :)
04:33:09 <hpc> but yeah, when you evaluate the head of the unpack, it evaluates the entire first chunk :P
04:33:11 <eikke> oh, right
04:33:55 <Cale> That's what happens when you have porn spammers flooding it constantly, I guess?
04:34:08 <hpc> haha
04:34:14 <shachaf> Sounds right.
04:34:56 <typoclass> Cale: i deleted maybe 20 spam messages yesterday. maybe they got angry
04:35:17 <typoclass> preflex: seen chrisdone
04:35:17 <preflex>  chrisdone was last seen on #haskell 14 days, 14 hours, 11 minutes and 25 seconds ago, saying: (ski: or maybe ski_`)
04:35:18 <Cale> It really ought to do something to limit the number of posts made from a given address which contain URLs or something.
04:35:37 <Cale> (in a given time period)
04:35:59 <typoclass> hm, 14 days ... i guess it's a bit unreliable if i keep using @tell chrisdone =) should use email or something
04:36:27 <schoppenhauer> typoclass: I will do so soon, but not now (@hpaste), I have to clean it up first.
04:36:41 <typoclass> schoppenhauer: ok, fair enough
04:36:47 <schoppenhauer> thx anyway
04:54:44 <merijn> heh
04:55:19 <merijn> hpaste is down?
04:55:50 <typoclass> merijn: yes, cale talked about it a few minutes ago
04:55:58 <merijn> bah
04:56:09 <Cale> merijn: Apparently the machine it's running on is out of disk space
04:56:33 <Cale> (It's technically still up, but broken)
04:56:55 <merijn> Any good alternative pastebins?
04:57:09 <Cale> I don't know what's good, I just used pastebin.com
04:57:41 <typoclass> Cale: "the paste has been copied to hpaste.org" ... :)
04:57:58 <merijn> Why is this not a layout error: http://pastebin.com/EbfiFSRv ?
04:58:20 <Cale> merijn: Good question :)
04:58:27 <typoclass> merijn: gist seems clean
04:58:29 <merijn> Or does that only happen in do blocks?
04:58:40 <Cale> merijn: But seriously, it's because the only layout keywords are do, let, of, and where
04:58:41 <mauke> merijn: because there is no layout involved
04:59:01 <merijn> hmm
04:59:03 <Cale> The first non-whitespace character after a layout keyword sets the column for the block
04:59:07 <typoclass> merijn: 'if' or defining functions doesn't trigger layout, only the four that cale mentioned
04:59:50 <Cale> and any line starting in the same column continues the block (a semicolon is inserted), and any line starting in a shallower column closes the block (a closing brace is inserted)
05:11:50 <Peaker> What's a nice way to pretty-print Haskell source files programmatically?
05:12:00 <Peaker> haskell-src-exts? or is that only a parser?
05:12:27 <Peaker> apparently it has a pretty printer.. will try with that
05:13:29 * hackagebot incremental-parser 0.2.3 - Generic parser library capable of providing partial results from partial input.  http://hackage.haskell.org/package/incremental-parser-0.2.3 (MarioBlazevic)
05:28:59 <Peaker> is there a good length-type-indexed list on hackage?
05:32:24 * Peaker is going to try tagged-list
05:33:41 <blackdog> so, the libevent backend for ghc - is that just completely standard now?
05:34:04 <blackdog> i had a look at one of my binaries and it didn't have libevent as a dep, which makes me worried.
05:35:31 <merijn> libevent backend?
05:35:50 <blackdog> the runtime manager bos worked on
05:36:05 <typoclass> blackdog: a new IO manager was released with ghc quite a while ago. see http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/release-7-0-1.html "On POSIX platforms, there is a new I/O manager based on epoll/kqueue/poll, which allows multithreaded I/O code to scale to a much larger number (100k+) of threads."
05:36:16 <typoclass> blackdog: slightly more information http://blog.johantibell.com/2010/08/new-io-manager-merged-into-main-ghc.html
05:36:28 <merijn> blackdog: I don't think the GHC IO manager uses libevent?
05:37:00 <blackdog> merijn: no, you're right. it was epoll/kqueue and my shitty tired brain :)
05:37:01 <typoclass> blackdog: not sure what libevent is, i always thought poll, epoll, and variants were the key word
05:37:59 <merijn> typoclass: libevent is a "portable" framework for using kqueue/poll/epoll
05:38:13 <blackdog> i have this odd situation where i've spawned 10k threads, but only ~5000 seem to be active.
05:38:26 <typoclass> merijn: i see, thanks
05:38:38 <Aetherspawn> 10k threads... my whole system has... 900.
05:38:47 <Aetherspawn> Praise the haskell RTS
05:39:05 <Aetherspawn> I'm really interested blackdog; do you notice a performance decrease with that many?
05:39:36 <blackdog> Aetherspawn: i'm writing a webscraper, so my problem is embarrassingly concurrent
05:39:37 <typoclass> blackdog: so, half of them are waiting for the network/disks/etc.? or just waiting for cpu?
05:40:26 <blackdog> typoclass: this is the surprising bit - i'm using 300% cpu
05:40:49 <blackdog> and it still uses about 10% cpu even when it should be completely blocked :/
05:40:51 <typoclass> blackdog: i guess that means that 3 cores are each at full capacity
05:41:14 <blackdog> yeah. but it's only pulling about 1.5mb a second
05:41:30 <blackdog> admittedly it's around 1500 conns open at any one time
05:42:38 <blackdog> and the bugger of a thing won't quit on ^C within any reasonable length of time :/
05:42:41 <blackdog> oh well
05:43:20 <typoclass> blackdog: depending on what you're doing, increasing the number of threads will just increase contention (= increase overhead). just for testing, try reducing the -N number
05:43:45 <blackdog> there isn't really anything else happening on the machine
05:44:35 <Aetherspawn> anyone know if there is a way to tweak nagles algorithm
05:44:40 <Aetherspawn> so that it has a threshold
05:44:47 <Aetherspawn> ie: 20ms
05:44:52 <typoclass> blackdog: no i mean, threads might be so busy fighting each other for the cpu that very little work gets done in the end
05:45:15 <fruitFly> I have a map [(Char, Double)] and a [Char], I want to determine which chars in the map are not in the [Char], will the easiest way to go about this be converting to sets?
05:46:27 <Aetherspawn> is it an actual map, or a list of tuples like shown
05:47:00 <blackdog> typoclass: righto, i'll try with only three cores
05:48:04 <fruitFly> Aetherspawn: an actual map
05:48:19 <typoclass> blackdog: suppose you have a traditional spinning hard drive. contention is this: one process wants to read large file A, and another process wants to read large file B. suppose each process is naively scheduled to get 10 ms alternatingly. one guy commands the drive to move to file A. the overhead of physically getting ready to read will take ~10 ms. by the time anything is actually read, it's time for the other process, which commands 
05:48:27 <fruitFly> Aetherspawn: but I could make it a list, my code is highly malleable
05:48:30 <Botje> filter (M.contains yourMap) keys
05:48:58 <Botje> oh, no
05:49:07 <Botje> filter (`M.member` yourMap) keys
05:49:15 <typoclass> blackdog: in the end, the drive will have moved the read head back and forth a great deal, but not much will have been read. it'll be orders of magnitude faster for process A reading his stuff all in one go, then process B reading his stuff
05:49:31 <Aetherspawn> the bane of hdd's
05:49:36 <typoclass> (very naively)
05:50:18 <Cale> Botje: That's backwards from what he wants, I think.
05:50:58 <blackdog> typoclass: so similarly for blowing the cache, i suppose
05:50:59 <Botje> oh, grr. missed the 'not'
05:51:35 <Cale> fruitFly: You may want something like: [x | (x,_) <- M.toList myMap, S.notMember x (S.fromList myString)]
05:52:05 <fruitFly> Cale: oh my god Cale is a god
05:52:18 <Cale> heh
05:52:35 <fruitFly> Cale: jk lol, I just need more experience :)
05:52:46 <Cale> (It would be very upsetting if I couldn't do something like that after 12 years of programming in Haskell)
05:53:45 <blackdog> typoclass: still - there's not a great deal of computation involved here - mostly sending http calls and reading from the network
05:54:24 <fruitFly> Botje: thanks I'll take a look at yours too
05:55:36 <typoclass> blackdog: who knows. if you really have 10k tcp connections open, maybe you're beginning to see the kernel struggling to manage all that
05:55:50 <typoclass> blackdog: just for testing, try something reasonable :-) 50 or 100 or something
05:56:02 <blackdog> typoclass: i've got 10k haskell threads, but only about 1700 tcp conns open at any one time.
05:56:03 <Aetherspawn> my god 12 years
05:56:22 <Aetherspawn> Oh wait, you weren't even around for hask '98 release
05:56:36 * blackdog counts back, feels bad that he's not as good a haskell hacker as Cale
05:56:57 <blackdog> pretty sure i first saw haskell in 2001.
05:57:43 <Aetherspawn> I can't even imagine how well you could master a language in 12 years ;__;
05:57:58 <Aetherspawn> Cale, do you dream in haskell?
05:58:15 <Taneb> I once dreamt in lambda calculus
05:58:31 * hackagebot groups 0.3.0.0 - Haskell 98 groups  http://hackage.haskell.org/package/groups-0.3.0.0 (NathanVanDoorn)
05:58:44 <Cale> Aetherspawn: heh, I don't recall ever having done so
05:59:02 <bartavelle> Cale, that is because you wouldn't find it unusual
05:59:12 <Aetherspawn> ^
05:59:40 <Taneb> ...I actually once had a dream that someone was distributing a virus via Hackage that killed people, and it was up to me and edwardk to save the world
05:59:42 <typoclass> true haskell hackers sleep for ~35 minutes, then wake up momentarily and go back to sleep
05:59:47 <fruitFly> serious question, what advantages are there really going to school when there's you guys and a plethora of other online resources?
06:00:03 <typoclass> (indirect obscure threadDelay jokes. groooan)
06:00:04 <Taneb> fruitFly, schools sometimes give you a certificate
06:00:16 <bartavelle> fruitFly, salary
06:00:18 <Taneb> Some people like certificates
06:00:22 <Aetherspawn> real companies bar like 5 don't use haskell
06:00:31 <Aetherspawn> and working for those 5 must be awesome.
06:00:36 <aleator_> Any particular reason Data.ByteString.Builder is not 'Trustworthy'?
06:00:55 <fruitFly> Aetherspawn: bar like 5?
06:00:56 <blackdog> Aetherspawn: you can always start your own company and use haskell.
06:01:05 <typoclass> fruitFly: school will expose you (even force you) to experience stuff you wouldn't yourself have thought of trying. there's some value in that
06:01:32 <Aetherspawn> fruitFly, from what I've observed you dont see that many software consultants which use haskell
06:01:40 <Aetherspawn> but please correct me!
06:02:33 <eikke> if only all the companies for which recruiters contact me for Scala jobs could be converted into Haskell...
06:02:37 <Adeon> I suspect there may be haskell hidden in all sorts of places
06:02:59 <fruitFly> but regardless of oppurtunities, I think ones skills could develop just as well from online resources, am I wrong?
06:03:02 <Aetherspawn> australian battleships are running pure C on windows 2000 at the moment ;_;
06:03:09 <t7> yeah, university
06:03:16 <t7> ( @ Adeon )
06:03:43 <t7> no one uses haskell for _real_ stuff
06:04:15 <t7> its all javascript now, brah
06:04:21 <Adeon> oh, I don't know
06:04:33 <blackdog> t7: big trolololol? :)
06:05:04 <merijn> blackdog: He's serious, that's why we tasked luite with the secret mission of implementing ghcjs :p
06:05:05 <t7> blackdog: i bet more javascript gets written everyday than any other programming language
06:05:10 <fruitFly> what's it gonna take for haskell's adoption in industry to tip? and what timeline? or do you think that's just not happening
06:05:24 <blackdog> oh, i meant about haskell not being used for real stuff.
06:05:33 <merijn> fruitFly: It's already tipping, but not everywhere :p
06:05:47 <fruitFly> merijn: :)
06:05:50 <merijn> fruitFly: "The future is already here, it's just not equally distributed yet."
06:06:03 <Aetherspawn> Offtopic, but on the discussion of industry platforms, you should all feel very unsafe: http://www.theregister.co.uk/2007/02/26/windows_boxes_at_sea/
06:06:12 <eikke> t7: I'd say more C# and Java is written every day than JS
06:06:15 <t7> fruitFly: a new hackage and some big business backing
06:06:20 <Cale> Avoid success at all costs!
06:06:26 <typoclass> fruitFly: i think skill develops by you doing something, being aware, reflecting about how it went, discussing it, feeding back into how you do things. cycle through this for X years, and you're an expert. whether you do this in the context of university or elsewhere
06:06:53 <Aetherspawn> Decentralized from a single hackage maybe
06:07:05 <Aetherspawn> so that businesses can run their own dependancy servers
06:07:19 <fruitFly> merijn: if I understand what you're saying, haskell's position in the future is certain, it just hasn't spread across the domains yet
06:07:46 <merijn> fruitFly: People who write haskell aren't writing blogposts about the newest startup HTML5 webapp they're doing
06:07:55 <t7> "haskell's position in the future is certain" yeah but its not gonna be popular
06:08:15 <merijn> They're busying getting paid big bucks writing ActionScript3 compilers for companies :p
06:08:20 <Cale> merijn: Some of them are however, writing web applications.
06:08:40 <eikke> one of the problems of haskell: tons of libraries are created, but not many applications are being created (in open source at least)
06:08:42 <merijn> Yeah, I don't think haskell will be mainstream like C#/Java/JavaScript, but it doesn't have to be
06:09:01 <merijn> It just has to be used by enough people to be able to get paid for writing it :p
06:09:02 <Aetherspawn> lack of a good editor that doesn't feel unix'ey to use on windows is a big downside
06:09:14 <typoclass> merijn: hm actionscript3 compilers?
06:09:15 <Cale> eikke: Yeah, a lot of the applications are closed source.
06:09:23 <eikke> Cale: well, yes
06:09:28 <Cale> (and behind closed doors)
06:09:46 <Aetherspawn> Anyone /actually/ know where the visual haskell thing on haskell.org went?
06:10:16 <fruitFly> typoclass: reddit.com/r/haskell I write compilers for a living now
06:10:17 <merijn> typoclass: I saw a blog post on reddit.com by a guy who got hired to compile legacy actionscript3 to some new framework
06:10:27 <Cale> tbh, most of the ideas in Haskell at present I believe are inevitably going to be popular, even if Haskell isn't.
06:10:30 <eikke> designing an application for Haskell is somewhat different than other languages, so as long as there are no good examples out there, barrier to entry will remain high
06:10:36 <typoclass> fruitFly: merijn: oh i see
06:11:26 <typoclass> Cale: yes, absolutely. anonymous functions are slowly filtering into most major languages. c# is very cautiously trying some inference. etc.
06:11:55 <typoclass> "haskell -- preview of programming in 2050" ;-)
06:11:58 <Cale> It's just very very slow
06:12:04 <eikke> that's where things like Django, RoR, even Swing or whatever, though you can dislike them, have an edge: they're frameworks who relatively clearly define how to build an application
06:12:38 <eikke> not saying I advocate the use of frameworks and whatnot, but they do help to allow people to 'get things done', apparently
06:12:41 <Cale> In order to program multicore machines, I believe referential transparency by default will be an inevitable thing though.
06:12:59 <Peaker> I think what will bring Haskell or a Haskell-like language to the mainstream is a really good IDE.  Richer type information and types -> better IDE features
06:13:06 <Cale> So eventually most languages will look a lot more like Haskell than most of the really popular ones right now.
06:13:09 <Peaker> Purity of evaluation -> Easier to execute as you edit
06:13:41 <eikke> Peaker: checked out Scala's Worksheet already?
06:14:23 <eikke> https://github.com/scala-ide/scala-worksheet/wiki/images/multi-line.png
06:15:30 <Cale> Peaker: One of the things I actually like about Haskell is that it gets rid of the need for a lot of the things which IDEs usually do, but yes, there are a lot of cool things that you could make an IDE for Haskell do.
06:16:08 <hodapp> I have noticed that most languages with a functioning REPL have far less of a need for an IDE.
06:16:33 <Cale> (It also really bugs me when a language is so bad that it's nigh-impossible to program in it without an IDE)
06:17:47 <acube> Yeah, the REPL is what I miss in C++ :/
06:20:00 <merijn> acube: A friend of mine is working on a C REPL in gdb! :)
06:20:07 <Peaker> eikke, haven't heard of Scala's worksheet
06:20:08 <merijn> I need to bug him how far along that is :p
06:20:24 <Peaker> eikke, seems nice. what does it do when code says: launchTheMissiles() ?
06:20:37 <eikke> Peaker: I guess it launches the missiles :)
06:20:51 <Peaker> Cale, I really hate doing so much type inference in my head as I change existing code and get some type error
06:21:11 <Peaker> Cale, Also, managing package dependencies, imports and exports manually is annoying
06:21:25 <Peaker> Cale, and a lot of existing IDE features like offering relevant operations for the type at hand are very useful in Haskell too, are sorely missing
06:21:42 <Peaker> eikke, well, that's a nice feature of purity that's not taken advantage of by any IDE to date
06:21:44 <Aetherspawn> ^ this
06:21:53 <Aetherspawn> I wanna hit ctrl+space and see my transformers are /wrong/
06:21:59 <eikke> Peaker: unsafePerformIO
06:22:05 <Cale> There are tricks for avoiding having to do much type inference in your head (mainly, giving explicit type signatures which are intentionally wrong), but yeah.
06:22:29 <Peaker> eikke, if you have launchMissiles behind unsafePerformIO, you deserve what you get :) It's officially considered a bug to have visible impurity in unsafePerformIO
06:22:45 <eikke> sure
06:22:52 <Peaker> Cale, I use those tricks, but it's still much more mentally draining to do some tasks than it would be with a good IDE
06:23:15 <Aetherspawn> given how heavily we tend to document our stuff because of haddock
06:23:30 <Aetherspawn> the amount of information that an IDE can give to a programmer is /quite a lot/
06:24:10 <fruitFly> wut r the benefits of purchasing sublime text? is emacs worth trying out?
06:24:19 <fruitFly> or something else?
06:24:21 <acube> An IDE suggesting possible implementations or free theorems would be nice :P
06:24:46 <Aetherspawn> that reads my mind when I mash tab
06:24:55 <Cale> Peaker: btw, RyanT5000 has a little proof of concept tool which you can run on some source code and it opens a window where you can click on things and it'll tell you the type of them.
06:25:26 <Peaker> Cale, I'm working on an IDE for a Haskell-like language, and we have something really nice w.r.t type debugging
06:25:53 <acube> I'd also like to see something like a hyper-linked code browser, where you just click on functions to go to the definition
06:26:30 <Cale> acube: Haddock is halfway there.
06:26:45 <acube> Cale: Yeah, but the source code is not hyperlinked :(
06:27:00 <Aetherspawn> an actual stepping debugger would be cool
06:27:22 <acube> Aetherspawn: there is the ghci debugger
06:27:31 <Cale> I want a stepping debugger which displays the expression graph visually.
06:27:41 <Cale> Like HOPS :)
06:27:54 <Aetherspawn> ^ cool stuff that would make imperitive land jelly
06:27:54 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
06:28:04 <Peaker> Cale, we're going to have an evaluation mode that displays each subexpression value, given some example inputs
06:28:33 <Peaker> Cale, implementation of fibs: http://i.imgur.com/eW20MBf.png   with type debugging enabled: http://i.imgur.com/GJK6Kps.png
06:28:36 <Cale> Having something like that ^^ is really useful for debugging space performance
06:28:38 <Peaker> (in our experimental IDE)
06:29:23 <acube> Doesn't ghc-vis or vacuum(-grapviz) do something like you want?
06:29:40 <Peaker> Cale, so in our editor you press f7 and all subexpressions get a type displayed under them
06:30:07 <mapreduce> Does that work out ok for longer types?
06:30:14 <Aetherspawn> Wow, that's... interesting
06:30:21 <Aetherspawn> OpenGL IDE?
06:30:23 <Peaker> mapreduce, Could make the text smaller
06:30:26 <Peaker> Aetherspawn, yeah
06:30:38 <t7> Peaker: sharpen up those stretched {s :D
06:30:38 <Aetherspawn> Reminds me of that IDE designed for coding for xbox on xbox
06:30:41 <Peaker> Aetherspawn, we believe smooth animations are really important for a good user experience
06:30:52 <Peaker> t7, sure, after about 3 thousand more important things to do :)
06:30:55 <Aetherspawn> It certainly looks cool
06:31:14 <acube> Peaker: are you taling about that lamdu thing?
06:31:17 <Peaker> acube, yeah
06:31:28 <Aetherspawn> did you use html/css
06:31:40 <Peaker> Aetherspawn, no, direct OpenGL rendering of our own GUI framework
06:31:46 <Aetherspawn> ;__; that sounds painful
06:31:49 <Aetherspawn> nice result though, grats.
06:31:50 <typoclass> acube: i wish that vim's haskell-mode stuff made "gd" work reliably (for the function name under cursor, open the file where it's defined and jump to definition). it seems to work only occasionally, when the module is in the same directory or something
06:32:02 <Peaker> Aetherspawn, hah, you say that after mentioning html/css :)
06:32:19 <Aetherspawn> well, in that sense, I was thinking lighttable
06:32:25 <Aetherspawn> where the whole IDE was built around it :P
06:32:27 <Aetherspawn> I thought that was cool.
06:32:37 <acube> Peaker: how is the lamdu language going to be different from Haskell?
06:32:45 <Peaker> Aetherspawn, I find html/css pretty painful.  we went the OpenGL path because we couldn't get smooth animations in browsers a couple of years ago
06:32:51 <Peaker> (smooth = 60fps)
06:32:55 <fruitFly> I imported bot Map and Set as qualified but it thinks the S.functions should be Maps?
06:32:55 <Cale> Peaker: Do you recall a tool called Programmatica?
06:33:17 <fruitFly> should be Map's functions*
06:33:24 <gspr> Since you guys seem to be on the topic anyway, does Emacs' haskell-mode have a way of showing the constructors of a data type under the cursor in a signature?
06:33:36 <Peaker> acube, anonymous records/variants anywhere you'd like them. Semi-explicit type variables (explicit at type system level, hidden by UI).  No special need/support for currying
06:33:43 <Peaker> Cale, nope, haven't heard of it
06:33:48 <merijn> Ok, #haskell, I have another bikeshed poll for you
06:33:56 <mentis> In parsec, makeTokenParser does not specify the underlying monad while makeTokenParser emptyDef runs in the Data.Functor.Identity.Identity monad. Could someone explain why?
06:34:30 <Cale> Peaker: I can't seem to find it online anymore, except some references in papers, but it was a visual frontend for Haskell 98 way back when.
06:34:40 <merijn> GADTs + record syntax, is there a different way you'd like to see this indented? https://gist.github.com/merijn/5765317
06:34:49 <Peaker> acube, one thing I really dislike in Haskell is having a whole ceremony whenever I want to name a couple of product fields.. defining a new type & a new data constructor for every such case, and then inability to share the fields, so I can't have precise types for intermediate computation states without cumbersome parameterization
06:34:54 <eikke> "Most people who'll be programming in Scala in 5y aren't using it today & the Java community is 52x that of Haskell" - @springrod #scaladays
06:34:55 <mentis> I want to set IO as the underlying monad but I get type errors if I do
06:36:01 <acube> Peaker: yeah, those "intermediate" states also annoyed me sometimes (although I'm still pretty new to haskell)
06:36:22 <Peaker> acube, if you look at the lamdu screenshots, you see that we have parameter names everywhere
06:36:52 <Peaker> acube, to do this, we have multi-param functions use an input record, rather than currying.. this changes trade-offs and the language somewhat, too
06:37:05 <Cale> merijn: I'd probably do something like this, http://pastebin.com/Qbppn929
06:37:08 <Peaker> then we'll have nice UI sugaring of lambdas that do partial applications
06:38:09 <merijn> Cale: Oh, yeah, that looks reasonable too. Though I dislike having the closing brace on the last line end like that if all others are at the line start
06:38:38 <Peaker> merijn, I like the way you indented it
06:38:42 <Aetherspawn> It's kind of awkward a thing to indent
06:38:50 <merijn> typoclass: Should it indent to the :: or should it just indent by 1 indent level?
06:39:03 <Aetherspawn> merijn, I like yours the best
06:39:23 <merijn> Aetherspawn: Should the :: and { line up, or should that just be "1 indent"?
06:39:31 <Cale> merijn: What you have is certainly fine. I also often put commas at the end, but I'll tend to go with whatever style already exists in the code.
06:39:52 <merijn> Cale: Yeah, I'm just trying to define sensible defaults for auto indentation
06:40:01 <ThatOtherPerson> Does Char have to be a specific Unicode encoding?
06:40:11 <Cale> ThatOtherPerson: It's not encoded
06:40:12 <merijn> ThatOtherPerson: Char is a unicode codepoint
06:40:27 <merijn> ThatOtherPerson: So there's no such thing as "being a specific encoding"
06:40:30 <ThatOtherPerson> Okay, what size should it be?
06:40:33 <Aetherspawn> They look lined up to me
06:40:51 <merijn> Aetherspawn: Yes, but what if foo was "ReallyLongConstructorName ::"?
06:41:03 <Aetherspawn> Oh, yeah I have that problem all the time
06:41:06 <typoclass> merijn: oh, just 1 level, (4 spaces), definitely. i almost never indent based on the previous line, always just one more level. (my two cents)
06:41:25 <Saizan> > maxBound :: Char
06:41:29 <kappabot>   '\1114111'
06:41:29 <Aetherspawn> especially on the end of `where`, where the stuff following is longer than the function above it -- looks really ugly
06:41:33 <merijn> typoclass: I indent data definitions to line up with = and type signatures to line up with ::
06:41:36 <Cale> I usually indent based on the previous line, unless it's annoying.
06:41:43 <Aetherspawn> I started using 2 spaces for tabs
06:41:48 <Cale> (at which point I just wish my editor were a little better)
06:41:55 <Aetherspawn> and breaking lines more often.
06:42:03 <merijn> Others I indent by 1 indent, except for line continuations, which I indent by half an indent
06:42:06 <typoclass> ThatOtherPerson: there are various conversion functions which you can use to turn a Char into a sequence of (e.g.) utf-8-encoded bytes. this is important when you pass a String (which is a list of Char) out of haskell, printing it to the console or a file, etc.
06:42:43 <merijn> ThatOtherPerson: Can you explain what you want to do, because you seem to be conflating several different things
06:42:45 <typoclass> merijn: right, i do that too. after 'data', i align = and all the |'s
06:42:57 <mentis> Has someone used Parsec with IO?
06:43:01 <Aetherspawn> merijn, you could move Foo :: to the end of line 2
06:43:08 <Aetherspawn> and just do a 1-tab indentation on the other stuff below it
06:43:12 <Saizan> mentis: it's because of the type signature for emptyDef
06:43:14 <ThatOtherPerson> merijn: I just wanted to know what number of bits Char should be
06:43:26 <ThatOtherPerson> merijn: I'll just go with 32 bits, thanks!
06:43:27 <merijn> ThatOtherPerson: Char is an unspecified number of bits
06:43:42 <Cale> ThatOtherPerson: In practice, it's 32, yes, though you can't actually fit 32 bits in a Char value.
06:43:54 <Cale> (though it will consume that much memory)
06:43:58 <geekosaur> > ord (maxBound :: Char)
06:43:59 <kappabot>   1114111
06:44:02 <Saizan> mentis: the definition of emptyDef is pretty simple though http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/src/Text-Parsec-Language.html#emptyDef you could copy/paste it in your source and give it a ifferent signature
06:44:24 <Aetherspawn> merijn, it's not that bad
06:44:26 <Aetherspawn> and its robust http://puu.sh/3e2Co/e5eb3ec606.png
06:44:29 <mentis> Sa
06:44:54 <merijn> Aetherspawn: Breaks for multiple record constructors in your GADT, though :p
06:45:10 * Aetherspawn throws in the towel
06:45:18 <mentis> Saizan: Thanks. So in order to use IO with Parsec one must avoid emptyDef
06:45:26 <fruitFly> I did "import qualified Data.Set as S" and it's sayign 'S.fromList' not in scope, did you mean M.fromList? ... from Data.Map... what gives?
06:45:42 <typoclass> ThatOtherPerson: well, Char is already defined in one of the modules that ghc offers to you. you don't have to define it yourself, or specify the number of bits or something
06:45:58 <ThatOtherPerson> typoclass: Yeah, I'm playing around with writing an interpreter
06:46:48 <Cale> fruitFly: weird -- are you sure you saved the file?
06:46:57 <Saizan> mentis: if you want the base monad to be IO, yeah, see the definition of the LanguageDef type synonym
06:47:13 <Aetherspawn> rename the file, save the file in editor, ghc the new file gets me /every time/
06:47:24 <Aetherspawn> (the editor re-saves as the old filename)
06:48:01 <Peaker> Aetherspawn, I use rename inside emacs
06:48:05 <Saizan> mentis: that's only needed when you want the parser itself to include IO actions
06:48:10 <Peaker> Aetherspawn, so it doesn't hold on to the old file name
06:49:26 <merijn> ThatOtherPerson: Have you looked at the Haskell98 and Haskell2010 reports?
06:49:37 <merijn> ThatOtherPerson: Those should specify all kinds of details like this
06:49:49 <Cale> mentis: I would be a *little* bit suspicious of any need to do I/O inside of a parser, though I guess it's convenient if you have #include-like functionality.
06:51:08 <ThatOtherPerson> merijn: I've been reading the Haskell 2010 report, but it just says that Char should be able to hold any Unicode character
06:51:20 <ThatOtherPerson> So I guess it's implementation-dependant
06:51:23 <fruitFly> Cale: Yes!
06:51:26 <fruitFly> omg
06:51:38 <merijn> ThatOtherPerson: That just means you get to pick anything that lets you conform to the unicode standard
06:51:41 <fruitFly> Cale: oh shit I got the problem :)
06:51:47 <fruitFly> figured it out
06:51:49 <merijn> ThatOtherPerson: i.e. it's most of a unicode question than a haskell issue ;)
06:51:55 <mentis> Yes, this i what I need to do
06:52:01 <ThatOtherPerson> merijn: Yeah, thanks :D
06:54:18 <yitz> > maxBound :: Char
06:54:19 <kappabot>   '\1114111'
06:54:30 <yitz> > ord maxBound :: Char
06:54:31 <kappabot>   Couldn't match expected type `GHC.Types.Char'
06:54:31 <kappabot>              with actual type...
06:54:37 <yitz> > ord (maxBound :: Char)
06:54:38 <kappabot>   1114111
06:54:47 <yitz> > 2^16
06:54:48 <kappabot>   65536
06:55:04 <Fuuzetsu> is hpaste main page not loading for anyone else?
06:55:26 <Cale> Fuuzetsu: The machine is out of disk space
06:55:39 <Cale> If you go to /new and try to post something, you'll see :)
06:56:08 <yitz> time to delete some spam
06:56:32 <Cale> Time to add some spam-prevention features
06:56:36 <typoclass> yitz: i did, yesterday. maybe the spammers got angry and flooded the machine :)
06:56:58 <typoclass> anyway, so far we can't rule out a simple oversight. it doesn't have to be spam
06:58:34 * hackagebot som 5.0 - Self-Organising Maps  http://hackage.haskell.org/package/som-5.0 (AmyDeBuitleir)
07:05:28 <acube> > ord maxBound
07:05:30 <kappabot>   1114111
07:11:25 <Botje> does anyone know why it's 1114111 specifically?
07:12:02 <Fuuzetsu> IIRC that's the highest printable Unicode codepoint or something
07:12:04 <mauke> > 0x10ffff
07:12:06 <kappabot>   1114111
07:12:17 <Botje> ah.
07:12:22 <Botje> I tried -1 but not +1
07:12:24 <Botje> thanks
07:12:25 <bitonic> kosmikus: is it possible to have lhs2TeX output simply a .tex file, so that can include it in some other file importing the lhs2TeX prelude there?
07:13:22 <Fuuzetsu> bitonic: Wouldn't just renaming the .lhs to .tex do exactly that if your literal parts are in TeX already?
07:13:38 <bitonic> Fuuzetsu: no, lhs2TeX processes the haskell part
07:13:43 <bitonic> to typeset it
07:13:56 <Fuuzetsu> Ok.
07:14:27 <kosmikus> bitonic: in theory, that's possible, though slightly tricky. why do you have to do it?
07:14:52 <bitonic> kosmikus: well, I have this big latex thing, and there is a section where I present an Haskell program
07:14:53 <bitonic> BUT
07:14:59 <bitonic> the paper is already a literate Agda file, lol
07:15:04 <blackdog> anyone seen  epollControl: invalid argument (Bad file descriptor)
07:15:14 <blackdog> from GHC before?
07:15:22 <kosmikus> bitonic: ah, mixing Haskell and Agda is one good reason I accept
07:15:24 <blackdog> (or rather, ghc-produced code)
07:15:26 <bitonic> I think it’d actually be convenient to do the reverse, and produce the Agda part separatedly
07:15:39 <bitonic> since that should be fine
07:16:04 <Eduard_Munteanu> Aren't there language-agnostic Literate * preprocessors?
07:16:28 <kosmikus> bitonic: you can try the technique described in the FAQ "Yes, but the master file should be pure LaTeX" (in Guide2.pdf)
07:16:39 <kosmikus> bitonic: but with mixing agda/haskell, there might still be problems
07:16:55 <kosmikus> bitonic: I know I've managed for at least one paper, but possibly by simply using --agda for all code
07:16:55 <typoclass> elliott: cale: ohai. is lambdabot in the park lying in a hammock again?
07:17:05 <elliott> ugh, it died?
07:17:06 <elliott> will look into it
07:17:16 <typoclass> elliott: thanks
07:17:20 <bitonic> kosmikus: I think you misunderstood.  I’m using ‘agda --latex’ to process the .lagda
07:17:28 <bitonic> not lhs2TeX itself
07:17:30 <kosmikus> oh
07:17:47 <kosmikus> I have never used agda --latex
07:17:53 <kosmikus> so I have no idea in how far that'd clash
07:17:56 <kosmikus> hopefully it won't
07:18:13 <bitonic> kosmikus: I’ll later, agda --latex is nice because I get all the colors ehe
07:18:43 <kosmikus> bitonic: I'm not claiming it's bad, just that I haven't used it
07:18:51 <Eduard_Munteanu> I suspect plain Latex rarely, if ever, calls external programs such as the compiler to colorize / typeset?
07:19:12 <bitonic> kosmikus: that was more me explaining my reasoning for using it instead of going full lhs2TeX :)
07:19:43 <Aetherspawn> sigh
07:19:44 <bitonic> OK going to try lhs2TeX first, agda later
07:19:47 <Aetherspawn> do-notation looks so uglyu
07:19:50 <Aetherspawn> in so many cases
07:20:14 <blackdog> whee, that's a neat trick. i'm getting an mvar exception in a thread that's not using mvars
07:20:27 <Aetherspawn> (hpaste.org dead?)
07:20:27 * blackdog thinks ghc is trying to tell him to go to bed
07:20:30 <typoclass> > 42
07:20:30 <merijn> blackdog: Using Chan's or anything else?
07:20:31 <kappabot>   42
07:20:36 <lambdabot>   42
07:20:40 <merijn> Aetherspawn: Disk is full, so effectively, yes
07:20:45 <typoclass> elliott: thanks
07:20:51 <Aetherspawn> lol, disk is full.
07:20:53 <elliott> kappabot: @part #haskell
07:21:14 <geekosaur> the spammers figured out that nobody was going to stop them, so they ran it into the ground with spam :/
07:21:37 <elliott> wow, disk full with pastes
07:21:42 <elliott> impressive
07:21:45 <Aetherspawn> Yeah haha
07:21:49 <elliott> typoclass: it seems like it just pinged out
07:21:55 <Peaker> it could delete all pastes that don't type-check
07:21:55 <Aetherspawn> Consider something like this: https://gist.github.com/anonymous/5765740 . How do I make it not ugly.
07:21:57 <elliott> typoclass: I blame freenode's unreliability
07:22:15 <Aetherspawn> Peaker, it would be left with no pastes
07:22:35 <Aetherspawn> 99% porn ads, 0.5% typecheck issues, 0.4% non haskell code, 0.1% code that works
07:22:41 <Peaker> Aetherspawn, what is ugly about that paste?
07:22:52 <merijn> Aetherspawn: I prefer 4 space indents, but other than that it looks ok?
07:22:54 <Aetherspawn> Peaker, I find it raelly ugly.
07:22:59 <merijn> Aetherspawn: Add some blank lines
07:23:08 <Peaker> I find it reasonable/ordinary imperative code
07:23:32 <Peaker> you could use: parseOptions <$> getProgName <*> getArgs
07:23:39 <blackdog> merijn: two iorefs and a threadDelay
07:23:53 <elliott> is chrisdone working on reviving hpaste?
07:23:54 <Peaker> withSocketsDo . startServer =<< (parseOptions <$> getProgName <*> getArgs)
07:24:06 <merijn> How do I annotate github Gists?
07:24:18 <Peaker> fork them?
07:24:27 <eikke> I'd move the 'withSocketsDo' all the way up, main = withSocketsDo $ do ...
07:24:44 <Aetherspawn> I like Peaker's suggestion for main
07:24:53 <Aetherspawn> but I'm going to shuffle it so its left-to-right
07:25:11 <Peaker> Aetherspawn, I like it in function application order..  consider f >>= g . h    has to be read:  f, h, g :(
07:25:28 <Aetherspawn> is there something like the <$> stuff that has lower infix than >>=
07:25:34 <mauke> f >>= h >>> g
07:25:39 <Aetherspawn> so I can kill some clunky brackets
07:25:49 <Peaker> mauke, >>> is so noisy
07:26:10 <Peaker> Aetherspawn, <&> maybe?
07:26:25 <merijn> :t (<&>)
07:26:26 <lambdabot>     Not in scope: `<&>'
07:26:26 <lambdabot>     Perhaps you meant one of these:
07:26:26 <lambdabot>       `<>' (imported from Data.Monoid),
07:26:38 <Peaker> Aetherspawn, I think you want <$> and <*> both to have higher precedence than >>=, not lower
07:26:43 <acube> Looking at pastes on hpaste (editing the number in the url), I can't find many spam pastes ...
07:27:36 <typoclass> elliott: no idea. he was last seen here 2 weeks ago. do you have his email address or something? we should alert him
07:28:50 <elliott> http://chrisdone.com does
07:30:18 <Aetherspawn> What do we think: https://gist.github.com/anonymous/5765828
07:31:02 <Aetherspawn> (woops, embarassing, type check error)
07:31:30 <sam4> when doing matrix operations in haskell, is list usually used or arrays?
07:31:41 <merijn> sam4: Arrays or one of the vector packages
07:32:12 <byorgey> sam4: neither.  You use a library for doing matrix operations. =)
07:32:20 <byorgey> but those libraries all use arrays.
07:32:47 <Cale> You could also in some cases usefully use a Data.Map
07:32:58 <sam4> I looked into linear algebra librarys, but they require types to be Double
07:33:06 <Cale> (if your matrices were sparse, particularly)
07:33:28 <sam4> I am making my own types that instantitate numeric types
07:33:30 <eikke> Cale: IntMap
07:33:46 <sam4> is there a library for matrix operations for general types?
07:33:54 <merijn> sam4: Multiple, I believe
07:34:51 <dmwit_> What does "general types" mean?
07:34:59 <nooodl> Num i guess
07:35:35 <sam4> I am using numeric-prelude to define my own types
07:35:42 <dmwit> elliott: Oh, have you changed lambdabot to privmsg ?tell reminders?
07:35:45 <sam4> I am new to haskell so sorry for my terms...
07:35:52 <dmwit> elliott: If so, why not change it a tad further to just send the messages? =P
07:36:17 <sam4> It seems that linear algebra / matrix libraries in haskell all require Double or for specific types
07:36:23 <elliott> dmwit: it was an upstream change
07:36:28 <dmwit> dmwit: (Also, how did your copy of lambdabot get a test message I sent when my copy of lambdabot was the reigning champion...?)
07:36:28 <elliott> I had nuthin to do with it :)
07:37:01 <elliott> dmwit: wat
07:37:12 <Cale> sam4: The state that numeric-prelude is in makes me sad. It would be quite a good library if it didn't name all its types T and all its classes C.
07:37:13 <elliott> btw, you can technically still read messages in public
07:37:16 <elliott> @help tell
07:37:17 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
07:37:20 <elliott> uh hm
07:37:21 <elliott> @list messages
07:37:21 <lambdabot> tell provides: tell ask messages messages-loud messages? clear-messages
07:37:25 <typoclass> dmwit: something called kappabot was in here today. not sure
07:37:27 <elliott> "@messages-loud" does it
07:37:34 <elliott> kappabot is shachaf's lambdabot
07:37:43 <Aetherspawn> Peaker, I get a type check error I can't rid using <$> and <*>
07:37:48 <Aetherspawn> It's confusing me -- it just keeps shifting the type it wants
07:38:10 <Cale> Aetherspawn: Try giving some explicit type signatures
07:38:25 <Peaker> Aetherspawn, it's OK to have a single () in your line :P
07:38:27 <Cale> Aetherspawn: You'll usually find that they cause error messages to improve
07:38:32 <dmwit> typoclass: I sent the test message days ago.
07:38:45 <Peaker> Aetherspawn, foo =<< (f <$> x <*> y)   is fine
07:38:57 <elliott> dmwit: note that I got the state file from cale
07:39:01 <elliott> so anything that lambdabot saw, mine did too
07:39:12 <dmwit> elliott: Oh! Maybe lambdabot was just quieted the whole time.
07:39:19 <elliott> seems likely
07:39:35 <elliott> this is why +q'ing lambdabots is risky :P
07:39:55 <quchen> Lambdabot was gone for some time this afternoon.
07:40:04 <elliott> yeah it pinged out
07:40:13 <elliott> I guess lambdabot doesn't even bother to try reconnecting to servers
07:40:15 <dmwit> It still seems a bit weird. Wouldn't lambdabot's fire-once have gone off silently if it was just +q?
07:40:45 <elliott> dmwit: it seems to have forgotten about the fire-once thing
07:40:48 <elliott> I think that might just be stored in memory
07:40:52 <dmwit> huh
07:40:58 <elliott> someone else got a notification for like a month old messages
07:41:00 <elliott> *message
07:42:01 <Aetherspawn> Peaker, a <$> b <*> c is giving off IO Options instead of Options
07:42:42 <eikke> Aetherspawn: of course
07:43:18 <nooodl> that's why you =<< it
07:43:33 <Aetherspawn> I tried >>='ing it, but I get this error
07:44:00 <Aetherspawn> https://gist.github.com/anonymous/5765936
07:45:27 <Cale> Aetherspawn: When in doubt, just use do-notation.
07:45:36 <Aetherspawn> ;_;
07:45:40 <Aetherspawn> ;_;
07:45:43 <Aetherspawn> woops.
07:45:45 <Cale> Aetherspawn: What is the type of setLevel DEBUG?
07:46:06 <mauke> @where faq
07:46:07 <Peaker> Aetherspawn, oh, parseOptions isn't pure
07:46:07 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
07:47:02 <Peaker> Aetherspawn, you need to add an extra join there, or use the previous notation
07:47:20 <Cale> Aetherspawn: actually, it would be a good idea to write out the types of all the things you're working with. The things which are IO actions you'll usually want to run in order to get their results.
07:47:20 <Aetherspawn> What about just 'pure' ?
07:57:47 <Cale> Aetherspawn: In general, if you have to think hard about what incantation of infix operators will do what you want, just using do-notation will probably be helpful for whoever reads the code as well. If you write it in do-notation, you might also realise that it simplifies to something nice anyway.
07:58:16 <Aetherspawn> yeah, I ended up going back to do
07:58:25 <Aetherspawn> and aligning the ->'s so it looks /kind of/ uniform
07:59:02 <typoclass> Aetherspawn: (note that 'whoever reads the code' may well include yourself in a few months)
08:00:29 <Cale> That said, you ought to know how to mechanically translate do-notation into uses of >>=
08:02:12 <Aetherspawn> I need to read up the do section of LYAH again. I know it decomposes into certain mixtures of \x -> lambdas and \_ -> lambdas just forgot exactly how. (I'm off to bed now, bye #haskell).
08:02:37 <Cale> do { x ; ... } = x >> do { ... }
08:02:44 <Cale> do { v <- x ; ... } = x >>= \v -> do { ... }
08:03:02 <Cale> do { let { ... } ; ... } = let { ... } in do { ... }
08:03:10 <Cale> do { x } = x
08:03:44 <Aetherspawn> do x = x is handy to know
08:03:48 <Aetherspawn> I didn't think that was the case.
08:04:03 <elliott> ugh, an arguably-broken hashable is part of the platform
08:04:12 <elliott> oh, I guess it has that actual definite brokenness
08:04:16 <elliott> so it's doubly arguably broken
08:04:22 <geekosaur> or see @undo which will translate do notation (and IIRC @redo translates bind notation to do notation, although perhaps sloppily)
08:05:04 <elliott> Aetherspawn: for completeness: do { p <- x; ... } = x >>= \v -> case v of { p -> ...; _ -> fail "..." }
08:05:27 <Cale> yeah, I half-deliberately left that out ;)
08:05:28 <Aetherspawn> fail, what.
08:05:31 <Aetherspawn> Whaaat.
08:05:57 <Cale> That's the case where p is a pattern which can fail to match
08:06:02 <geekosaur> p <- x is a pattern match. (consider:  Just x <- somethingThatReturnsMaybe)
08:06:14 <Aetherspawn> Oh, gotcha.
08:06:19 <geekosaur> so what happens if it returned Nothing instead of Just something? the translation invokes fail
08:06:29 <elliott> it works even when p is a variable though
08:06:31 <elliott> since then the _ case never matched
08:06:41 <elliott> i.e., you don't need the v <- x rule if you have the pattern one
08:06:48 <Cale> (According to the standard, it's always the case, according to GHC and Haskell 1.4, it's only when p is a pattern which matches against a constructor of a type with more than one)
08:07:20 <geekosaur> I'd expect the compiler to optimize away the case if it's an irrefutable pattern anyway
08:07:29 <Aetherspawn> thanks, night
08:08:12 <Cale> geekosaur: It can't optimise away the dependency on fail though, which matters if you're using a custom Prelude.
08:08:28 <geekosaur> true
08:08:37 <geekosaur> but, well, that's an ongoing issue
08:09:05 <Cale> It's actually nice that GHC really does use the Haskell 1.4 translation there.
08:09:37 <Cale> Because it means that if fail were moved out to its own class, things would actually work reasonably well :)
08:10:45 * elliott keeps forgetting what H98 actually improved over 1.4
08:11:07 <typoclass> Cale: how about making that today's proposal! we had Semigroups yesterday :-)
08:11:51 <Cale> I'm a little surprised that people actually care about semigroups which aren't monoids.
08:12:31 <typoclass> Cale: well, johnw cares :-) i have no opinion on the whole thing. i couldn't even figure out the difference between the Maybe Monoid and the Option Semigroup
08:12:35 <joshc> so, is bad practice to rely on the implicit 'fail' in the failing pattern match case? or should haskell programmers always explicitly handle all patterns?
08:12:55 <joshc> err.. probably could have worded my second question better
08:13:01 <dmwit> Cale: sclv pointed out to me that fail breaks equational reasoning in a pretty funny way.
08:13:12 <Fuuzetsu> :t (<$>)
08:13:13 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:13:16 <dmwit> Cale: (Even if you move it out to its own type class.)
08:13:31 <Cale> joshc: Some ways of relying on it are better than others.
08:13:57 <Cale> joshc: Try to only rely on it when you're writing code in a specific monad, and you know what the fail for that monad does.
08:14:06 <dmwit> Cale: Because presumably you will want fail :: String -> Either String a (among other types), and incomplete pattern matches which have identical syntax in two different places in the file will have different (pure!) results.
08:14:16 <Cale> Code which is abstracted over the choice of monad and which relies on fail is bad.
08:14:26 <dmwit> (because they mention which line of code the incomplete pattern happened at)
08:15:04 <joshc> Cale: that makes quite a bit of since, thanks;  so, monads like Maybe or (Either e) which are well suited to the use of 'fail'
08:15:18 <Cale> dmwit: Yes... though sometimes that's desirable as well.
08:15:19 <byorgey> and []
08:15:34 <byorgey> (that was for joshc)
08:15:39 <dmwit> Cale: I know. It's an annoying problem.
08:16:13 <Cale> In fact, our web application at skedge.me makes a fair amount of use of IO's fail to make sure that line numbers are reported in cases we don't want to handle nicely yet.
08:16:29 <Cale> (or which we think shouldn't be able to happen)
08:17:53 <elliott> dmwit: well, that just means do is not RT, rather than fail, really
08:17:55 <Cale> (or similar for our app's various monads)
08:19:06 <dmwit> elliott: I'm fine with that restatement of the problem.
08:19:33 <merijn> What is fail for STM? retry?
08:19:46 <elliott> dmwit: maybe we need notation like:
08:19:53 <Cale> merijn: haha, I think it just throws an exception.
08:20:01 <Cale> That's an interesting question though.
08:20:15 <elliott> dmwit: do { p <- m; ... } -> m >>= \x -> case x of { p -> do { ... }; _ -> error "line number" }
08:20:19 <merijn> That might actually be nice, though. Retrying on a pattern that shouldn't happen
08:20:40 <elliott> dmwit: do { p <? m; ... } -> m >>= \x -> case x of { p -> do { ... }; _ -> mzero }
08:20:58 <elliott> seems like you'd rarely want the "custom fail" behaviour along with the line number
08:21:57 <Cale> It turns out that the instance of Monad for STM doesn't even bother defining fail
08:22:02 <Cale> So yeah, it just errors out
08:23:31 <dmwit> elliott: Oh, well, using error instead of fail changes everything, of course.
08:23:35 <Cale> Oh, btw, lambda is also not RT if we're saying that do isn't.
08:23:50 <Cale> well...
08:23:56 <bartavelle> I suppose there are no libraries in cabal to patch a dynamic library function (from the importing program) ?
08:24:07 <Cale> Heh, it mostly is semantically, I suppose.
08:24:08 <dmwit> Cale: Bottoms are indistinguishable.
08:24:10 <Cale> right
08:24:33 <Cale> and we can always say that if you catch the exception that's just the execution of IO being non-RT
08:24:40 <elliott> they are not
08:24:45 <elliott> you can distinguish them in IO
08:24:57 <elliott> "execution of IO is non-RT" doesn't quite cut it
08:25:02 <elliott> IO isn't meant to violate the semantics of the language
08:25:08 <elliott> and without exceptions and some other stuff it doesn't
08:25:11 <Cale> oh?
08:25:21 <elliott> well, imagine if you just had file IO
08:25:24 <Cale> You can examine arbitrary locations in memory with IO
08:25:35 <elliott> well, ok
08:25:39 <elliott> but that's in a whole nother universe
08:25:44 <Cale> and somewhere in there, all your pure stuff is going to be there, and its evaluation will be observable
08:25:46 <elliott> and you can't exploit *that* portably at least.
08:25:58 <elliott> and I think everyone would agree that kind of pointer stuff is very much a back door and not really "part of the language"
08:26:06 <elliott> unlike exceptions
08:27:14 <Cale> But it's definitely a good thing that pattern match failures report a line number
08:27:30 <Cale> You can also just think of it as part of the desugaring of the syntax
08:27:47 <Cale> (the inclusion of specific line numbers)
08:27:53 <elliott> I agree it's good, but I think restricting it to "error" would be OK
08:28:03 <elliott> that way you can't observe it outside IO and we have accepted that IO breaks the language now
08:28:08 <elliott> so the damage is limited
08:28:28 <Cale> You mean restricting pattern match failures in do?
08:28:41 <elliott> 16:24:13 <elliott> dmwit: maybe we need notation like:
08:28:43 <elliott> 16:24:42 <elliott> dmwit: do { p <- m; ... } -> m >>= \x -> case x of { p -> do { ... }; _ -> error "line number" }
08:28:46 <elliott> 16:25:06 <elliott> dmwit: do { p <? m; ... } -> m >>= \x -> case x of { p -> do { ... }; _ -> mzero }
08:28:49 <elliott> 16:25:25 <elliott> seems like you'd rarely want the "custom fail" behaviour along with the line number
08:29:27 <Cale> Well, that's true
08:29:48 <elliott> btw, it would be cool to see a language whose type system and semantics is advanced enough that the write-to-pointer operation accounts for the effect it can have on the program
08:29:52 <elliott> :)
08:33:43 <sepia> @pl \a b -> sum $ enumFromTo a b
08:33:47 <lambdabot> ((sum $) .) . enumFromTo
08:33:47 <lambdabot> optimization suspended, use @pl-resume to continue.
08:34:08 <sepia> @pl-resume
08:34:14 <lambdabot> ((sum $) .) . enumFromTo
08:34:14 <lambdabot> optimization suspended, use @pl-resume to continue.
08:34:26 <Cale> hah
08:34:33 <rovar> Hey all,  I am trying to build a typed programming language,  I am also working through  Modern Compiler Implementation in ML, but it is very sparse in explanations, so I'm looking for some accessible background material.  Does anyone have any suggestions?
08:35:06 <elliott> I wonder why that's happening
08:35:36 <sepia> is there a better way to write that in pointfree?
08:37:01 <elliott> @unpl sum `on` enumFromTo
08:37:01 <lambdabot> (on sum enumFromTo)
08:37:04 <merijn> rovar: Are you looking for compiler writing material or more something related to typing/type inference?
08:37:06 <elliott> @src on
08:37:06 <lambdabot> (*) `on` f = \x y -> f x * f y
08:37:10 <elliott> oh
08:37:17 <int-e> (sum $) is a bit silly (it reduces to just  sum)
08:37:26 <int-e> @pl (sum $)
08:37:26 <lambdabot> sum
08:37:40 <elliott> sepia: you could say (sum .: enumFromTo) with that (.:) everyone seems to love. I recommend using the points instead
08:38:09 <rovar> merijn: More on the typing/type inference.   I went through a lambda calculus book and wrote a weakly typed interpreter.    Maybe now I should go through the simply typed lambda calculus, but I can't find any good resources..
08:38:31 <leroux> elliott: Where is that (.:) from?
08:38:32 <merijn> rovar: TaPL is the standard book
08:38:36 <merijn> @where tapl
08:38:36 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
08:38:54 <rovar> ah
08:39:02 <rovar> right.. I knew about that book.
08:39:19 <elliott> leroux: it's in a few packages strewn about hackage, it's just f .: g = (f .) . g
08:39:23 <rovar> back when I wasn't interested in building programming languages :)
08:39:25 <elliott> I wouldn't recommend depending on a package just for that operator
08:39:30 <elliott> and generally I wouldn't recommend that operator at all
08:39:52 <Sculptor> yo
08:39:54 <rovar> merijn: thanks.
08:39:59 <merijn> rovar: np
08:40:03 <sepia> kind of a haskell noob, what's (.:)?
08:40:14 <merijn> sepia: Just a custom operator
08:40:24 <merijn> @type (.:)
08:40:24 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
08:40:25 <leroux> Thanks.
08:40:30 <elliott> sepia: f .: g = (f .) . g
08:40:33 <elliott> so
08:40:37 <elliott> (f .: g) x y = f (g x y)
08:40:47 <elliott> it is not standard
08:41:20 <sepia> oh interesting
08:41:43 <sepia> elliott: thanks
08:42:02 <eacameron> Can I tell runhaskell to run something besides main?
08:43:17 <geekosaur> I would expect to accept -main-is
08:44:33 <merijn> eacameron: What would you want it to run?
08:45:44 <eacameron> I want to time my IO function with "time runhaskell ..."
08:46:09 <eacameron> merijn: see above
08:47:14 <enthropy> there are examples of doing the timing from inside the program
08:47:18 <enthropy> @hackage criterion
08:47:18 <lambdabot> http://hackage.haskell.org/package/criterion
08:47:50 <enigmuriatic1> say i have a JSON feed with the following format: { "status": "success", "transactions": {"id": 2, "value": 10.3}} how would i grab just the id and value using Aeson?
08:48:21 <Cale> eacameron: it's kind of silly to time things if you're not compiling with optimisations
08:48:45 <Cale> eacameron: but you could use  ghc -e
08:49:18 <eacameron> It's mostly network latency that I'm timing
08:49:29 <eacameron> cool thank you
08:50:00 <midfield> hey folks any mac homebrew haskell-platform users?
08:50:15 <elliott> midfield: me (as of a few days ago)
08:50:19 <elliott> but,
08:50:21 <elliott> @where justask
08:50:21 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
08:53:56 <Clint> enigmuriatic1: do you have a matching data type?
08:54:18 <enigmuriatic1> Clint, not matching perfectly because there's a bunch of cruft that I don't want
08:54:25 <enigmuriatic1> i'll paste the exact JSON
08:56:00 <enigmuriatic1> Clint, http://pastebin.com/0Ks48MGF
08:56:37 <enigmuriatic1> i'm making a list of outputs from a list formatted like that, and I only want the value, the n, and the addresses
08:56:48 <Clint> enigmuriatic1: just create a FromJSON instance for your type that only grabs the pairs you care about
08:57:26 <enigmuriatic1> Clint, i'm trying to. my question is how to reach into the scriptPubKey subfield to get the addresses
08:57:56 <Clint> enigmuriatic1: look at the constructors and accessors section at http://hackage.haskell.org/packages/archive/aeson/0.6.1.0/doc/html/Data-Aeson.html
08:59:12 <enigmuriatic1> ah right, thanks
09:05:47 <chrisdotcode_> hello everyone :)
09:10:42 <applicativ> hpaste.org is looking a little odd here
09:10:48 <yitz> hi chrisdotcode_
09:10:54 <applicativ> hello chrisdotcode_
09:10:57 <geekosaur> applicativ, it's out of disk space
09:11:27 <yitz> applicativ: typoclass deleted a lot of spam yesterday. then if filled up again today.
09:11:59 <applicativ> oh really, I had been deleting spam a while back.
09:12:16 <applicativ> maybe deleted spam takes up more space, not that that would explain much
09:12:40 <yitz> applicativ: some suspect it may be some other problem - such as an errant script, or a problem on the server itself
09:12:55 <yitz> applicativ: could be
09:13:48 <applicativ> i see. it could do with some anti-spam system, whereby e.g #haskell ops could ban some users or something
09:14:20 <applicativ> the neverending sequence of exotic european ick porn was pretty revolting
09:16:05 <midfield> elliott : do you have html docs for the non-base libraries installed with homebrew haskell-platform?  i can't seem to find mine.
09:16:37 <applicativ> midfield: try 'locate Text.html' ;)
09:16:55 <applicativ> if locate is keeping track of things
09:17:01 <yitz> midfield: try cabal haddock and watch the output. might give you a clue.
09:17:21 <elliott> midfield: no, and I think I know why
09:17:34 <applicativ> will local cabal maneuvers put them where haskell platform does?
09:17:35 <elliott> midfield: well, or at least, monochrom told me why and it seems plausible :P
09:17:38 <yitz> midfield: or it could just be that the default setting in .cabal/config is not to generate haddocks
09:17:44 <elliott> if you had hscolour, they would have been built
09:17:55 <monochrom> err, what did I say? :)
09:17:57 <elliott> yitz: well, HP installation doesn't go through the totally same "cabal install" process
09:18:00 <elliott> they get profiling etc.
09:18:07 <elliott> monochrom: I think that was your guess at the time at least?
09:18:23 <elliott> and having run the GHC build system since I think it said something about skipping docs because of no hscolour
09:18:26 <monochrom> oh, that, yeah, but that's only when you build it from source yourself. Mac people enjoy binary installers.
09:18:28 <elliott> though that was on another machine
09:18:34 <elliott> monochrom: yeah, but homebrew builds it from source.
09:18:46 * hackagebot persistent-mongoDB 1.2.0.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.2.0.1 (GregWeber)
09:18:53 <yitz> elliott: yeah. so running cabal haddock for something manually will reveal what is happening for everything else, and the appropriate fix can then be made in .cabal/config
09:18:54 <monochrom> then it depends on whether the default build script is used
09:18:57 <elliott> I find it weird that it would skip docs entirely because of the lack of hscolour rather than just building source-link-free docs
09:19:09 <applicativ> its not clear to me that the homebrew haskell-platform.rb thing builds the haddocks
09:19:15 <monochrom> it's just scripter laziness :)
09:19:41 <yitz> or even colour-free source links
09:19:55 <monochrom> I have a cunning plan
09:19:59 <applicativ> i really think using homebrew for this stuff is just a layer of unneeded nonsense
09:20:08 <monochrom> add hscolour to haskell platform :)
09:20:18 <yitz> monochrom: that is a good plan
09:20:24 <applicativ> +1
09:20:34 <yitz> monochrom++
09:20:39 * applicativ is pretending to be a 'voter' on one of our dubious lists
09:20:40 <elliott> hey, a cabal question. if I have ~/foo with subdirectories foo-bar, foo-baz, foo-quux, each containing a respective .cabal file, and another subdirectory foo-main, and I want to be making modifications to all of these and then recompiling/reinstalling all the foos (they have dependencies on one another), is there a nice way to do this with cabal?
09:20:52 <elliott> beyond doing cd foo-x; cabal install --force-reinstalls for each x
09:20:53 <elliott> in dependency order
09:20:56 <elliott> which gets old very quickly
09:21:47 <yitz> elliott: use cabal-dev and make symlinks from all of them to the same cabal-dev directory
09:21:48 <applicativ> not just cabal configure ./foo ./bar
09:21:56 <merijn> elliott: I don't think so, if there was I would've used it
09:23:02 <elliott> yitz: yes, I have considered cabal-dev. unfortunately it will be a little awkward to use here, but it might be the best solution
09:23:07 <applicativ> i'm certain it is possible by an expendient something like the one I just gae
09:23:09 <applicativ> gave
09:23:10 <elliott> yitz: can you explain what you mean by the symlinks here?
09:23:19 <elliott> I know about cabal-dev add-source, but that requires doing sdist manually on the other packages first IIRC
09:23:35 <midfield> thanks everyone, i'll look into reinstalling
09:23:57 <yitz> elliott: by default each package will have its own cabal-dev subdirectory, and all common dependencies will be rebuilt from scratch each time for each of your packages
09:24:29 <yitz> elliott: (that is when you rm -r cabal-dev, which is what you often do to get a fresh build of a new version)
09:24:55 <monochrom> elliott: you can set up your own package repo. then you enjoy dependency chasing. http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#local-repo
09:25:47 <yitz> elliott: if before the first time you run cabal-dev in each subdir, you just run it in one of the subdirs and then create a cabal-dev symlink in each of the subdirs to that one cabal-dev dir, they will all share the same package database
09:26:09 <yitz> elliott: that way, each of your packages plus any shared deps all get built only once each.
09:26:49 <elliott> yitz: ah, I see
09:27:12 <elliott> monochrom: right, that seems undesirable when I am actively modifying all components simultaneously though
09:27:15 <elliott> because of the packaging need
09:27:18 <yitz> elliott: to empty the garbage and start fresh, you can then just rm that one actual cabal-dev dir and recreate it by running cabal-dev once in its parent dir
09:27:58 <sm> elliott: in that situation, I find it's much quicker just building all packages at once with ghc
09:28:21 <elliott> yitz: so sad that our packaging situation involves notions like "clean builds" and "emptying garbage".
09:28:28 <yitz> elliott: this is a cool trick i learned from - i think - chrisdone
09:28:55 <yitz> elliott: well, this is a hard problem, and serious progress is being made.
09:29:41 <yitz> elliott: sandboxing support (better than cabal-dev) is built into the latest cabal, and will now gradually filter down into stable ghc installs
09:29:52 <yitz> elliott: and people are working on improving the SAT solver
09:30:13 <elliott> the annoying thing with a cabal-dev type thing is that it has mixed library and runtime dependencies on haskell packages (and I think it even requires both library and program of some packages), so I am going to have to install stuff globally as well as in a cabal-dev sandbox to run it properly
09:30:42 <yitz> elliott: nope i install nothing globally except cabal-dev itself
09:30:46 <elliott> maybe something as simple as applicativ's solution would work but ISTR having problems with that the last time I tried something like this...
09:31:04 <elliott> yitz: how do you handle runtime dependency on executables that happen to come from haskell packages?
09:31:07 <yitz> elliott: well, and xmonad dependencies on my linux box so that meta-q will work ;)
09:31:09 <elliott> (a la happy/alex, but runtime dependencies)
09:32:00 <yitz> elliott: make sure the exes end up in your path. various ways of doing that. not common enough for it to be worth investing a lot of effort, i found.
09:32:33 <elliott> well, they aren't even all dependencies of the packages in question (because some of them are executable-only packages)
09:32:54 <yitz> elliott: usually when it comes up, i manually cabal-dev install the program, and cp the resulting exe from cabal-dev/bin to someplace reachable. happens once in a blue moon.
09:33:17 <FreeFull> latest cabal meaning latest in git/whatever or latest stable?
09:33:56 <yitz> FreeFull: git head version of the cabal and cabal-install libraries
09:34:16 <applicativ> elliott: try the new cabal-1.17 with 'cabal sandbox' just to impress your friends
09:34:20 <yitz> FreeFull: it will take some time until it makes it into a default HP install
09:35:03 <elliott> yitz: well, in this case the blue moon is one of the main development environment problems :)
09:35:21 <yitz> applicativ: it's fun to try, but i have an old fear of using anything except the exact Cabal that came with GHC for real work. perhaps that fear is irrational nowadays.
09:35:44 <yitz> elliott: heh. murphey's blue moon.
09:35:53 <applicativ> yitz: yes, i had this fear too, duncan c talked me out of it ... or I think that's what he was talking me out of ...
09:36:07 <yitz> elliott: how many exes do you think you need?
09:37:25 <elliott> yitz: well, about five, all from different haskell packages. I can probably build them in the sandbox and do the manual copying them out, but I know that at least two of them require manual patching to build, whether to make them build or make them work with the code using them
09:37:34 <FreeFull> yitz: I don't use the HP though
09:37:40 <elliott> and some of them are dependencies of the packages (the ones that have library parts), some are not
09:37:47 <FreeFull> My distro ships with whatever is needed to compile the latest xmonad
09:37:50 <yitz> applicativ: i suppose it's probably safe to cabal-dev compile cabal-install and then use that exe. although i just hope its modern concept of a ghc pkg db doesn't clash in some way with the ancient concept in the mind of the ghc i am using...
09:39:02 <yitz> i imagine the new cabal will make it into stackage much much sooner than into HP.
09:39:19 <enigmuriatic1> if you have to specify a type of an IO variable being bound, do you include the IO?
09:39:35 <yitz> enigmuriatic1: yes
09:40:02 <yitz> enigmuriatic1: it's the type of the expression, not the variable.
09:40:36 <enigmuriatic1> the thing is, yitz, every time i specify one type it tells me that it expected something else
09:40:51 <enigmuriatic1> and then when i change the type to that it tells me it expected what i had before
09:41:02 <enigmuriatic1> it should be IO (Maybe Tx)
09:41:34 <yitz> enigmuriatic1: yes that is a common experience. it is ghc trying to help you write your program and make it bug free. once you get used to getting the message, you'll find those errors really really helpful.
09:41:49 <enigmuriatic1> yitz, i don't see my logic error though
09:42:10 <yitz> enigmuriatic1: who says it should be that type? you, or ghc?
09:42:16 <elliott> is there any tutorial on the new cabal sandboxing stuff?
09:42:23 <enigmuriatic1> maybeTx <- decode . BL.fromString $ txData :: IO (Maybe Tx)           txData is of type String, and the decode function returns a Maybe a
09:42:33 <enigmuriatic1> yitz
09:42:58 <enigmuriatic1> technically it could decode to any custom type so i have to specify that i want a Tx, yitz
09:43:10 <yitz> enigmuriatic1: the type after :: applies to the entire expression, not just what comes after the $
09:43:11 <applicativ> elliott: I wouldnt think so since they're still working on it; I cant remember which #haskell user knows most
09:43:34 <enigmuriatic1> yitz, i know
09:43:36 <c_wraith> enigmuriatic1: I don't think that will compile, without at least changing $ to <$>
09:43:38 <yitz> enigmuriatic1: unless you enclode the :: suffix inside parens together with what you want it to apply to
09:43:41 <yitz> oh ok
09:43:48 <enigmuriatic1> i want to whole thing to be IO (Maybe Tx)
09:44:12 <enigmuriatic1> it's telling me that it thinks it's a Maybe (Maybe Tx)
09:44:23 <enigmuriatic1> but that doesn't make sense because it's being passed a String
09:44:30 <yitz> enigmuriatic1: let maybeTx = decode . BL.fromString $ txData
09:45:14 <applicativ> well anyway, it's clear i don't know how to realize elliott 's desideratum with this gussied up cabal-install
09:45:39 <enigmuriatic1> http://pastebin.com/GTDxYMyh yitz
09:46:11 <enigmuriatic1> OH damn, i forgot that that isn't an io action
09:46:22 <dmwit> elliott: just cabal install ./foo-bar ./foo-baz ./foo-quux
09:46:30 <dmwit> elliott: (responding to a half-hour old question of yours)
09:46:42 <sam4> how do I mute entries in a 2 dimensional array?
09:47:00 <enigmuriatic1> i understand that that's completely my fault, but at the same time, are they ever planning on making GHC compile errors clearer?
09:47:14 <sam4> pastebin.com/mrrLVRBz
09:47:57 <dmwit> :t (//)
09:48:00 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
09:48:04 <dmwit> sam4:
09:48:14 <yitz> enigmuriatic1: what is the type of decode?
09:48:16 <FreeFull> enigmuriatic1: I think you could just do   let maybeTx = join . decode . BL.fromString $ txData;
09:48:22 <enigmuriatic1> i fixed it, yitz
09:48:25 <tdammers> enigmuriatic1: idk, they're usually perfectly clear IMO, just a bit verbose
09:48:32 <yitz> enigmuriatic1: compiles?
09:48:42 <enigmuriatic1> i was an idiot and forgot that it wasn't an IO action
09:48:44 <enigmuriatic1> yeah, yitz
09:48:48 <yitz> yay!
09:49:02 <enigmuriatic1> tdammers, it could potentially have just said "decode is not an IO action"
09:49:26 <elliott> dmwit: does that handle dependencies correctly when some of them change etc.?
09:49:28 <elliott> I suppose I should try it and see
09:49:30 <dmwit> sam4: (If you want the "not-copying-on-write" bit of mutable arrays, you can't be constantly thawing and freezing them. Those operations copy.)
09:49:34 <monochrom> "clearer" is subjective in this context
09:49:35 <dmwit> elliott: should do, yes
09:50:34 <elliott> it is true that cluttering my package db with its multitude of dependencies is arguably not desirable though, so I may still try the cabal-dev approach
09:50:34 <yitz> enigmuriatic1: there is logic to the way the message is worded. sometimes we say "IO action", but realy IO is just a type like any other
09:50:39 <dmwit> enigmuriatic1: GHC error messages probably won't change much any time soon. But you will change much some time soon.
09:50:39 <sam4> I see
09:50:46 <sam4> thanks
09:51:56 <yitz> elliott: i spend a few minutes here and there with extra compiles with the cabal-dev approach. but i feel completely in control of my deps.
09:52:12 <FreeFull> I actually like GHC's error messages
09:52:19 <FreeFull> Is it just me?
09:52:34 <monochrom> me too
09:52:43 <elliott> yitz: for me, I gave up on cabal-dev because I often simply want to play with a single file in GHCi, importing all the advanced libraries I know to try stuff out
09:53:08 <FreeFull> They say the line number, what was expected, and what the compiler actually got from you
09:53:12 <elliott> yitz: and with cabal-dev, I had to set up a directory, write a .cabal file, painstakingly enumerate all the packages I import from (ongoing timesink as I import more stuff), my ghci had to know about it, ...
09:53:24 <elliott> all for a single file experiment that I will not care about once it's done
09:53:49 <yitz> elliott: yeah. you need to build up a re-usable collection of those.
09:54:20 <elliott> right. and I decided I was happier just doing rm -r ~/.cabal ~/.ghc every few months
09:54:35 <elliott> when I want new stuff
09:54:37 <applicativ> cabal init enumerates the imports
09:55:22 <yitz> elliott: yes that also works. in the end it's pretty much equivalent though, and overall less flexible.
09:55:58 <yitz> elliott: i had to do it not just when i wanted new stuff. also when it got borked. which was pretty often.
09:56:43 <elliott> well, breakage tends to be related to new stuff getting installed, in my experience.
09:56:55 <elliott> which is why e.g. pinning your package versions as monochrom suggests greatly mitigates the problems
09:56:58 <elliott> (but stops you getting new stuff)
09:57:45 <monochrom> it takes pro's knowledge to get new stuff piecemeal
09:57:56 <elliott> dmwit: do you know if cabal build dir1 dir2 dir3 will also work as I expect? in case I don't trust my work enough :)
09:57:58 <FreeFull> I wish someone would take frag and make it work with newer GHC
09:58:53 <monochrom> I think "cabal build" simply doesn't honour those parameters
09:59:03 <enigmuriatic1> what's the Aeson expression used to get a value from a nested field?
09:59:14 <enigmuriatic1> i'm trying to get it from the documentation but cant figure it out
10:00:06 <jfischoff> I am noticing some unexpected behavior when using conduits. Running the same sink twice with $$ is giving different results?
10:00:11 <jfischoff> what gives?
10:00:22 <yitz> elliott: dunno. yesod builds, with zillions of deps, lots of recursive deps... tend to break the package db pretty often.
10:01:04 <elliott> yitz: I have a great solution to that involving not using Yesod ;)
10:01:08 <yitz> elliott: "something new" can be some version bump in a deeply nested recursive dep.
10:01:21 <elliott> (yes, I am sure Snap or whatever would likely break just as much.)
10:01:53 <yitz> elliott: we use yesod at work. it has a lot of very big advantages for getting real work done. this is a disadvantage though.
10:02:17 <elliott> I don't have that problem -- I never get anything done :)
10:02:36 <FreeFull> What are yesod's advantages?
10:03:20 <yitz> elliott: yeah web apps have a lot of deps. various libs pull in all kinds of crypto stuff, you have db bindings, parsing libs, rendering libs, network libs, etc...
10:03:38 <elliott> in fact, lambdabot depends on warp :)
10:03:42 <elliott> because of hoogle
10:03:57 <sm> elliot: I happily reset my db to install yesod, or if I'm not ready for that I'll cabal-dev install it. It's not a big problem these days, unless I'm missing something
10:05:56 <yitz> FreeFull: separtes all the many aspects of web programming in neat ways, powerful templating, all kinds of real-life things like speed, resource management and error handling are carefully thought out and handled consistently all over, the whole thing is battle tested by a lot of pros who use it.
10:06:24 <FreeFull> yitz: Sounds good
10:07:09 <yitz> FreeFull: integration with keter hot-swap deployment is also very valuable
10:07:59 <sm> yitz: what do you use for templating - separate hamlet files, embedded hamlet, ... ?
10:08:02 <yitz> FreeFull: a lot of - most of? all of? - that stuff exists with snap and happstack too. haskell web frameworks are very cool.
10:08:10 <sm> +1
10:08:59 <yitz> sm: some of both, depending on for what. actual configuration/customizable things all go in separate templates, so the people who work on them don't need to know a word of haskell.
10:09:59 <sm> nod
10:10:23 <sm> I was thinking of trying heist, for the runtime reloading
10:10:52 <yitz> sm: yep heist is also cool.
10:11:54 <yitz> sm: in the yesod approach, you say "yesod keter", that creates a new complete app bundle, uploads, and hot swaps it in without disturbing existing user connections.
10:12:21 <merijn> FreeFull: The major downside of Yesod is that it's heavy use of Template Haskell leads to sometimes confusing error messages when some of your code combined with voodoo generated Yesod code results in a type error
10:12:31 <sm> without breaking requests in progress ? wow I didn't know that
10:13:13 <yitz> sm: but it means that people working on the templates, though they don't need to know haskell, do need some kind of access to a machine with a haskell toolchain.
10:13:24 <sm> merijn: I think they're not that bad - large, but they do include a template error at the end
10:13:42 <merijn> sm: I'm completely unable to debug them, last time I used Yesod
10:13:50 <merijn> And I consider myself rather Haskell fluent
10:13:58 <merijn> I can imagine newbies being even more lost
10:14:04 <sm> I haven't had any trouble with them for a while
10:14:06 <olalonde> hi all, i am a haskell noob
10:14:13 <applicativ> hi olalonde
10:14:14 <Fuuzetsu> aren't we all~
10:14:35 <olalonde> no I mean, I just finished my first tutorial :)
10:14:45 <applicativ> olalonde: please ask anything you need to know here
10:14:49 <applicativ> which tutorial olalonde
10:14:56 <olalonde> I have been trying to wrap my head around how haskell relates to category theory
10:14:56 <enigmuriatic1> can anyone help me with this nested JSON using Aeson thing? it's really confusing me. i'm trying to parse vouts from this: http://pastebin.com/0Ks48MGF and i want to get the addresses from scriptPubKey
10:15:13 <olalonde> they seem like quite related from what i've read
10:15:29 <yitz> merijn: you need to get used to the error messages, yes, kind of like getting used to GHC error messages for the first time.
10:15:46 <applicativ> olalonde: the relation to category theory isn't very important. it is an organizing tool for some things -- a rather superficial use of it in fact
10:15:57 <enigmuriatic1> it takes an Object and Text and returns a Parser, so I can't apply it recursively or apply a function to it
10:16:03 <applicativ> it's surprisingly powerful, but one might have said most of the same without it, olalonde
10:16:44 <applicativ> if you do learn the relevant chunks of category theory a number of cool things turn up
10:16:44 <yitz> merijn: but it's actually nice to get type errors from your templates. that's the intended advantage of that approach.
10:16:47 <olalonde> cool, I actually find it quite interesting as I've been trying to wrap my head around category theory as well
10:17:02 <olalonde> applicativ: would it be correct to say that category theory concepts easily map to haskell?
10:17:03 <FreeFull> merijn: Do you think typed TH will help things out? Assuming Yesod will switch to using it
10:17:10 <applicativ> ah, are you studying math olalonde
10:17:12 <merijn> FreeFull: It might
10:17:31 <olalonde> applicativ: just for fun yes. i studied soft engineering but I find it interesting
10:17:51 <applicativ> olalonde: I think that it makes a very good example of the application of elementary category theory.  for example the idea of a natural transformation we use these everywhere
10:17:52 <Adeon> I think there's a page in the haskellwiki that tries to explain haskell types and functions as a category
10:17:56 <applicativ> @type listToMaybe
10:18:01 <lambdabot> [a] -> Maybe a
10:18:04 <olalonde> cool
10:18:35 <yitz> FreeFull: interesting thought. but i think the main purpose of typed TH is to generate *more* error messages, to catch more bugs
10:18:37 <applicativ> this is a general operation which moves you from a [] functored thing to a Maybe functored thing
10:18:49 <applicativ> @type snd
10:18:50 <lambdabot> (a, b) -> b
10:19:02 <applicativ> what tutorial were you reading olalonde
10:19:30 <yitz> let me guess - a gentle introduction...
10:19:35 <olalonde> applicativ: well, it's been a while. now I'm reading learnyouahaskell
10:20:05 <olalonde> applicativ: I was actually reading up on category theory and remembered that haskell used similar terminology and found the connection interesting
10:20:17 <olalonde> applicativ: so I will likely try to learn haskell for good this time :)
10:20:30 <yitz> for great good
10:20:35 <applicativ> olalonde: yes the latter chapters are not bad on Functor, Monad etc
10:21:21 <applicativ> I wonder if this new F-algebra tutorial on fpcomplete is any good. Many cool simple uses of category theory arise in connection with the idea of an F algebra
10:21:32 <olalonde> I'm still not quite comfortable with functional thinking. I'm used to OO thinking
10:21:35 <applicativ> https://www.fpcomplete.com/user/bartosz/understanding-algebras might be terrible, haven't read it
10:22:25 <yitz> applicativ: people seem to like it. it's pretty clear.
10:22:37 <yitz> on reddit anyway
10:22:37 <olalonde> I'm wondering why functional paradigm is not more prevalent. is it more a historical reason or is functional less well equipped to model business domains
10:22:49 <applicativ> the famous blogposts of sigfpe make out various haskell-category connections, it might be worth looking throught them.
10:23:11 <olalonde> I don't want to start a flamewar, I'm genuinely curious
10:23:16 <applicativ> olalonde: learning languages is hard, an immense herd of people employed using one kind, dont want to change
10:23:17 <sm> olalonde: me too
10:23:40 <FreeFull> Functional is a different way of thinking. People are too used to thinking imperatively
10:23:45 <olalonde> right
10:23:59 <applicativ> i don't think there's anything deep about it, just conservatism; the programmers themselves are a more important factor in this than 'management'
10:24:01 <yitz> applicativ: learning languages that are all pretty similar to each other isn't very hard. learning a completely new kind is harder.
10:24:03 <olalonde> so in your opinion it is more of a historical reason
10:24:10 <applicativ> yitz: yes
10:24:10 <olalonde> applicativ: cool
10:24:25 <sm> maybe it's because you don't get or see the full benefit until you "wear the hair shirt", which has been rare
10:24:36 <applicativ> maybe there's a better account, but it seems kind of obvious. they hated lisp even.
10:24:40 <olalonde> sm: I think that's definitely true
10:25:04 <olalonde> sm: I can see haskell looks very elegant conceptually but I'm not 100% sure it would make me more productive
10:25:05 <applicativ> the 'purity' of haskell is completely uncanny to people
10:25:14 <watermind> I'm not so sure functional is *that* different from imperative, much of it is relatively easy
10:25:35 <yitz> olalonde: turing and vonneumann implemented the first physical computers a certain way, and things carried on from there. if they had asked curry and church to do it instead, things might have turned out differently.
10:25:37 <watermind> higher order is not that difficult
10:25:43 <applicativ> it's easy unless you are really trapped in imperative, oo and curly bracket thinking
10:25:43 <watermind> recursion neither
10:25:51 <watermind> lazyness... ouch
10:25:54 <sm> but, "objects" are sort of intuitive for modelling. Also Smalltalk was/is insanely good and inspired a lot of people
10:25:57 <olalonde> my day job is with Javascript and I'm trying as much as possible to write in a functional style but sometimes I just don't know the proper way to do some stuff
10:26:08 <olalonde> yitz: eheh right
10:26:29 <olalonde> is there any concept of objects in haskell? as in composite data structures (not OO objects)
10:26:37 <applicativ> NO NO NO
10:26:38 <chrisdotcode_> is yesod's site down for anymore? http://www.yesodweb.com/page/five-minutes and pretty much most other things aren't working for me.
10:26:58 <applicativ> we have composite structures of many many kinds
10:26:58 <sm> olalonde: of course.. algebraic data types
10:26:59 <watermind> olalonde: yes
10:27:05 <applicativ> but comparing them with objects is trouble
10:27:07 <merijn> olalonde: ghcjs is in beta now :)
10:27:12 <watermind> olalonde: ADT's and GADT's
10:27:19 <merijn> olalonde: Soon you can compile haskell directly to JS!
10:27:22 <olalonde> merijn: nice. might be a good excuse to start using haskell
10:27:43 <olalonde> merijn: I write server side JS so I guess I could already start using haskell for some stuff anyways
10:27:57 <applicativ> does the fay js-compiler make good js?
10:28:17 * applicativ doesn't know much fay, nothing about ghcjs 
10:28:21 <merijn> olalonde: You'd have to ask luite, he is the gcjs wizard
10:28:26 <yitz> chrisdotcode_: works for me
10:28:44 <olalonde> :)
10:28:52 <yitz> chrisdotcode_: they changed the name of that page to quickstart. it's quick, but not five minutes :)
10:28:58 <chrisdotcode_> yitz: huh. I was having problems with it before, too. is it doing some sort of user-agent/ip content restricting?
10:29:11 <elliott> applicativ: it seems like "cabal configure ./foo*" doesn't work
10:29:12 <yitz> chrisdotcode_: don't know. i doubt it.
10:29:14 <elliott> where i have foo, foo-core, etc.
10:29:19 <elliott> cabal: No cabal file found.
10:29:19 <elliott> Please create a package description file <pkgname>.cabal
10:29:32 <chrisdotcode_> cause yesodweb.com/page/quickstart gives me a file not found.
10:29:34 <chrisdotcode_> gah
10:29:35 <applicativ> olalonde: have you seen fay and the rather different elm language, which uses haskell syntax, both write js
10:29:48 <enigmuriatic1> is there any elegant way to convert an Int to a Lazy ByteString in Haskell? I can't seem to find one using Google
10:29:56 <olalonde> applicativ: ok I will have a look
10:30:00 <elliott> fay is the one that uses haskell syntax isn't it?
10:30:13 <applicativ> elliott: fay uses actual haskell, but restricted
10:30:30 <applicativ> it preserves what are called semantics
10:30:38 <yitz> chrisdotcode_: weird. it all seems to work from here.
10:30:40 <elliott> right
10:30:43 <olalonde> if I understand correctly, "polymorphism" is possible in haskell right?
10:30:47 <applicativ> elm is an ml in haskell clothing, which is not a bad idea in itself
10:30:59 <elliott> it seems like "cabal install ./foo*" works, but not "cabal configure ./foo*"
10:31:06 <applicativ> a polymorphic function is a natural transformation olalonde
10:31:09 <elliott> which is annoying, i'd rather not install these globally just now...
10:31:13 <c_wraith> olalonde: what does "polymorphism" in quotes mean?
10:31:21 <applicativ> @type listToMaybe
10:31:22 <lambdabot> [a] -> Maybe a
10:31:25 <yitz> enigmuriatic1: what do you want the lbs to look like? ascii text? binary network-order integer?
10:31:26 <olalonde> well I know it's not polymorphism in OO sense
10:31:31 <olalonde> thats why i quoted
10:31:48 <applicativ> olalonde: 'a' can be an Int, and IO action, an infinite Stream, a function....
10:31:53 <c_wraith> olalonde: in many ways, it's more useful than subtyping polymorphism
10:31:56 <applicativ> in listToMaybe
10:32:12 <enigmuriatic1> yitz, i want to take an int and produce a standard lazy bytestring, Data.ByteString.Lazy.UTF8.ByteString
10:32:31 <c_wraith> olalonde: which is why C++ templates and java generics provide related functionality.
10:32:45 <c_wraith> olalonde: the terminology is "parametric polymorphism".
10:32:46 <yitz> enigmuriatic1: yes but what bytes do you want in your byte string? let's say the integer is 42. what bytes do you want?
10:32:55 <olalonde> c_wraith: ok thanks
10:33:24 <olalonde> I just wish I had a cool project I could do in Haskell haha
10:33:31 <olalonde> best way to learn for me
10:33:32 <applicativ> enigmuriatic1: I think it should be Data.ByteString.Lazy.Char8.pack "42"
10:33:55 <Tene> applicativ: that's a string, not an integer
10:34:08 <Fuuzetsu> olalonde: Just about any existing project requires developer hands. Look around.
10:34:23 <applicativ> enigmuriatic1: I think it should be Data.ByteString.Lazy.Char8.pack $ read 42
10:34:25 <applicativ> okay Tene
10:34:38 <applicativ> enigmuriatic1: I think it should be Data.ByteString.Lazy.Char8.pack $ show 42
10:34:39 <applicativ> bah
10:34:50 <olalonde> I don't think I'd be advanced enough to contribute to a project though. would be easier to start my own
10:35:21 <yitz> enigmuriatic1: if you want, say, the four binary bytes that represent the 32-bit integer 42, use the binary or cereal package.
10:36:05 <olalonde> maybe a simple template engine. that might be cool
10:36:08 <yitz> enigmuriatic1: if you want the bytes for ASCII characters '4' and '2', then do what applicativ is saying
10:36:42 <yitz> enigmuriatic1: although in that case you probably don't really want a bytestring, you want Data.Text.
10:36:45 <applicativ> enigmuriatic1: intHost :: Int -> BuilderSource
10:36:46 <applicativ> Encode a single native machine Int. The Int is encoded in host order, host endian form, for the machine you're on. On a 64 bit machine the Int is an 8 byte value, on a 32 bit machine, 4 bytes. Values encoded this way are not portable to different endian or int sized machines, without conversion.
10:37:15 <applicativ> that should read intHost :: Int -> Builder
10:38:02 <FreeFull> I don't know how you'd check what the host order is from within a haskell program
10:38:26 <applicativ> enigmuriatic1: have you used Data.ByteString.Builder before. t's really simple http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString-Builder.html
10:38:29 <Peaker> Compiling a module that only defines a single record type with many dozens of fields takes GHC forever :(
10:38:40 <enigmuriatic1> thanks applicativ
10:38:54 <applicativ> enigmuriatic1: you glue 'builders' together with the monoid <> or mappend
10:39:20 <applicativ> enigmuriatic1: then when you do hPutBuilder and so on, the writing is optimized massively
10:39:37 <applicativ> enigmuriatic1: basically they are 'difference list' bytestrings with fancy writing machinery
10:39:48 <applicativ> it's now included in bytestring 0.10
10:40:26 <applicativ> there's a lot of nice helper machinery in the new bytestring, which comes with the new haskell platform
10:40:29 <jfischoff> does anyway know anything about conduit?
10:40:31 <applicativ> its much more humane
10:40:54 <yitz> jfischoff: a little
10:41:23 <jfischoff> yitz: the conduit that is used for the request body of wai by warp seems impure
10:41:32 <jfischoff> are there impure and pure conduits?
10:41:50 <yitz> jfischoff: they're all impure i thought
10:42:00 <jfischoff> oh
10:42:08 <jfischoff> I know very little about them
10:42:19 <jfischoff> can you explain in what ways they are impure?
10:43:01 <jfischoff> I'm trying to understand if it is possible for me to fold over the conduit in the request body twice
10:43:33 <Peaker> I thought I remembered conduit had special case for purity for performance reasons
10:43:39 <Peaker> maybe that is very old
10:43:52 <jfischoff> it appears that if I fold over the it, something impure behind the scences happens and I can't do it again
10:43:58 <yitz> jfischoff: no i don't think so. conduits are IO streams, so you can only read them once.
10:44:06 <jfischoff> okay
10:44:10 <yitz> jfischoff: read it, bind it to a variable and pass that.
10:44:24 <applicativ> the type itself is monad-general
10:44:33 <jfischoff> okay
10:44:37 <jfischoff> thanks
10:44:48 <jfischoff> I thought that is what I had to do, I just wanted to make sure
10:45:46 <yitz> applicativ: a lot of the combinators have a MonadIO constraint, directly or indirectly
10:45:58 <applicativ> elliott: oh i forgot to say, I never figured out what I though i saw duncan doing to build several dirs at once
10:46:28 <jfischoff> the conduits you can make with sourceList are basically pure
10:46:28 <applicativ> yitz: yeah, thats why I restricted what I was saying. he agrees that he basically is always thinking of a MonadIO monad
10:46:33 <jfischoff> as far as I can tell
10:46:44 <jfischoff> but the warp one is pulling from a socket I think
10:46:51 <jfischoff> so ...
10:47:09 <jfischoff> yeah I wouldn't expect you can run it twice
10:47:10 <elliott> applicativ: mmm
10:47:12 <yitz> FreeFull: according to applicativ, you can just call intHost on any know integer and see what order the bytes come out in
10:47:14 <dcoutts> applicativ: like elliott said earlier, "cabal install ./foo*" works, but not "cabal configure ./foo*"
10:47:26 <elliott> dcoutts: right... that is a shame
10:47:36 <elliott> I was hoping I could build them (with their interdependencies) without necessarily doing a global install
10:47:53 <Hermit> for i in ./foo*; cabal configure "$i"
10:47:57 <dcoutts> elliott: can install them into a local db and location of course
10:48:02 <applicativ> oh configure I knew was silliness, yess
10:48:17 <yitz> dcoutts: how do you tell cabal to build only the package itself, and fail if there are any missing deps?
10:48:19 <dcoutts> elliott: but configure has always been "this package" in mode, and install is mulit-target
10:48:32 <applicativ> dcoutts: it was further expectations about cabal install ./foo ./bar
10:48:32 <Reite> How can I compose Aesons (.:) functions before I apply them? So that I can do this point free: myfunc a = a .: "foo" >>= (.: "bar")
10:48:38 <dcoutts> yitz: cabal configure; cabal build; cabal copy; cabal register
10:48:47 <yitz> copy?
10:49:07 <dcoutts> yitz: or if you like, cabal install --only, rather than copy;register, but it's the same thing.
10:49:16 <elliott> dcoutts: yeah I was just hoping to avoid fiddling with package dbs and stuff :) if I go down that route I might as well use cabal-dev.
10:49:37 <applicativ> dcoutts: the actual information content i meant to impart was only using the local description of the directories
10:49:43 <trace30m> what means x : xs
10:49:44 <yitz> dcoutts: ok thanks!
10:49:50 <trace30m> and what means xs ++ [x]
10:50:10 <Peaker> compiling a single module with one very large record with lots of fields takes ~15 seconds (?!)
10:50:13 <nooodl> 1 : [2,3,4] == [1,2,3,4]
10:50:21 <roconnor> x : xs means  [x] ++ xs
10:50:24 <nooodl> [2,3,4] ++ [1] == [2,3,4,1]
10:50:32 <trace30m> thx
10:50:32 <applicativ> but if I have two directories one depending on the other, what do I do?
10:50:54 <elliott> trace30m: are you reading a haskell tutorial like LYAH? it should explain simple functions on lists etc. well
10:50:57 <elliott> @where lyah
10:50:57 <lambdabot> http://www.learnyouahaskell.com/
10:51:00 <Fuuzetsu> Does anyone know what <0, 1> means in Alex files? <0> is just the startcode (state) we have to be in before the rules will match but I'm unsure what it means to have two startcodes.
10:51:13 <dcoutts> applicativ: I may have missed some context, but "cabal install ./foo ./bar" will work when those depend on each other
10:52:31 <applicativ> yes thats what I thought, but it wasn't working; on the other hand this is complicated by the fact that i was trying the new sandbox machinery at the same time.  i may not have understood elliott 's initial difficulty
10:53:05 <applicativ> dcoutts: ^^^
10:53:12 <elliott> it seems like the best options are either just go for "cabal install"ing all the broken dev versions, or cabal-dev + symlink
10:53:15 <elliott> s
10:53:15 <dcoutts> applicativ: maybe so, since it does work, I use it all the time
10:53:57 <applicativ> dcoutts: I don't doubt it, my use has not progressed beyond the first system of hacks hit upon.  i was thinking i might change....
10:54:08 <yitz> dcoutts: nowadays is it totally safe to use a new cabal-install with an older GHC? (let's say I compile it in cabal-dev to avoid the old cabal messing up the package database with the new cabal lib)
10:54:51 <dcoutts> yitz: has it ever not been safe?
10:55:00 <dcoutts> am I forgetting something?
10:55:32 <applicativ> dcoutts: like me yitz formerly thought it wasn't, this was due to applying the apriori that it's dangerous to update boot and platform libraries
10:55:39 <elliott> hm, it seems like cabal-meta is addressed at this use case too
10:55:48 <applicativ> in the case of Cabal though, there's only one principal consumer.
10:56:06 <yitz> dcoutts: well several times i tried cabal install cabal-install and ended up with a broken package db. but having been burned, i haven't even tried it in a few years.
10:56:35 <applicativ> it certainly is a disaster to have bytestring-0.9 in global but bytestring-o.10 locally
10:56:36 <olalonde> can I get a list of the most "depended upon" packages? or the packages with most downloads?
10:57:03 <yitz> applicativ: it was a belief acquired through negative psychological conditioning
10:57:04 <applicativ> olalonde: various information can be derived here http://packdeps.haskellers.com/reverse
10:57:12 <applicativ> yitz yes
10:57:14 <olalonde> applicativ: thanks
10:57:33 <dcoutts> yitz: oh ok so you mean building cabal-install with an older ghc+cabal combo, rather than using it with an older ghc. Well that's a similar issue to using any latest thing that needs later libs, though in this case it should only be a later Cabal lib.
10:57:46 <yitz> right
10:58:08 <applicativ> yitz are we on the same page, that the thought was, you dont want a new extra Cabal lib?
10:58:10 <yitz> dcoutts: so do i need to install ghc head and compile it there :)
10:58:21 <yitz> yes
10:58:58 <olalonde> applicativ: I'm on this page http://hackage.haskell.org/package/directory . where can I see some documentation about this package?
10:58:59 <applicativ> i haven't had any trouble with my cabal-install-head.
10:59:12 <dcoutts> yitz: so as long as you look at what it's installing, then I wouldn't expect any special problems. Just installing the Cabal lib itself is fine. Though if you have other things that then depend on the Cabal lib, you might want to remove it again after to avoid accidentally using it or something, but I've never run into problems with having several Cabal libs regsitered.
10:59:20 <applicativ> olalonde: it comes with ghc, the documentation is likely on your computer.
10:59:29 <olalonde> applicativ: haha ok
10:59:30 <trace30m> I know about foldr and foldl, but I understand only partly what foldb does
10:59:38 <applicativ> olalonde: http://hackage.haskell.org/package/directory
10:59:39 <dcoutts> yitz: i'd say using ghc head is quite unnecessary
10:59:54 <yitz> dcoutts: ok. well i have, but that was a long time ago. anyway, if i do it in a sandbox anyway there shouldn't be any trouble.
11:00:33 <yitz> dcoutts: in particular, can you confirm that cabal's new concept of what a ghc pkg db looks like won't conflict with an old ghc's concept?
11:00:39 <applicativ> yitz, just try it, i cabal installed the contents of the github Cabal/cabal-install and everything is fine in my dubious world
11:00:49 <elliott> yitz: it seems like you can just pass --sandbox instead of doing the symlink dance?
11:01:09 <dcoutts> yitz: "new concept"?
11:01:09 <yitz> elliott: with the new cabal? or with cabal-dev?
11:01:37 <applicativ> surely ghc decides what its pkg dbs look like?
11:01:41 <dcoutts> yitz: each ghc version has its own package db / set of libs
11:01:48 <yitz> dcoutts: haven't thing changed at some point? like allowing multiple versions of the same package, or things like that?
11:01:51 <eacameron> is there a library that provides a object-oriented-like dispatch (i.e. instead of sendRequest conn req .... something like conn.sendRequest req)??
11:01:58 <dcoutts> yitz: not yet
11:02:04 <Peaker> eacameron, why would you want that?
11:02:32 <eacameron> Peaker: more intuitive
11:02:33 <elliott> yitz: cabal-dev
11:02:37 <Peaker> eacameron, no it's not
11:02:39 <applicativ> eacameron: let (.) = flip ($) ?
11:02:40 <yitz> ok. so as long as i make sure my cabal versions are cleaned up after building, using the new cabal should be ok. good to know.
11:02:59 <yitz> elliott: ah. didn't know it had such an option. cool.
11:03:11 <dcoutts> yitz: and when that happens, it'll only affect the newer ghc's that can cope with it, we'll not gratuitously break using older ghc versions (or non-ghc compilers)
11:03:39 <yitz> dcoutts: great! i feel much better already.
11:03:55 <dcoutts> yitz: yes the only effects should be that you've got an extra Cabal lib version installed. For me that doesn't cause problems, but perhaps I don't have much that depends on Cabal lib.
11:04:37 <Peaker> dcoutts, when is that butterfly problem going away?
11:04:53 <monochrom> sometimes it is not just an extra Cabal.
11:04:54 <Peaker> dcoutts, (i.e: same package, same version, different dependency versions coexisting)
11:04:59 <applicativ> when people stop thinking they can update code on hackage, Peaker
11:05:18 <eacameron> applicativ: hmmm that might work
11:05:18 <elliott> monochrom: I claim your Haskell Platform "constraint: foo installed" list lies
11:05:24 <Peaker> applicativ, that, or when we 2 installs of same package version can coexist
11:05:27 <yitz> dcoutts: iirc the build of cabal-install itself already failed with ominous grumblings about corruption in the pkg db. but truth is i'm much better equipped to recover from that sort of thing now.
11:05:38 <monochrom> what does it lie?
11:05:39 <elliott> monochrom: in particular, it contains extensible-exceptions for the latest HP which I installed, but ghc-pkg list | grep exten gives nothing
11:05:54 <elliott> giving me a very confusing error when I tried to install something depending on it :)
11:06:15 <monochrom> darn
11:06:24 <applicativ> yitz: were you building cabal-install locally?  maybe that wouldn't matter.
11:06:36 <yitz> elliott: maybe they're talking to two different pkg dbs?
11:06:43 <applicativ> yitz: the cabal install executable has a pile of dependencies, so an ordinary mess can be producted by it
11:06:55 <elliott> monochrom: I demand a full refund :)
11:07:07 <elliott> no harm done, will just remove the line and see...
11:07:09 <yitz> applicativ: yes something like that is what was happening. i don't recall the full details.
11:07:16 <elliott> yitz: I don't think so, this is with the global ghc-pkg list
11:07:20 <elliott> and it contains all the packages I know I have
11:07:40 <dcoutts> Peaker: well sandboxing is coming in the next release, and then going further than that is still future work, there's more to it than meets the eye
11:07:50 <yitz> elliott: you have only one ghc on your machine?
11:07:52 <monochrom> interesting
11:08:00 <applicativ> yitz: anyway, like i said, dcoutts' predicted 'no problem' has materialized for me , building cabal- head
11:08:02 <eacameron> applicativ: that works! I just need to make it higher priority
11:08:27 <elliott> yitz: yes. I am simple
11:08:28 <applicativ> eacameron: yes, you probably want very high priority,
11:08:38 <monochrom> GHC 7.6 eliminated extensible-exceptions or merged it into base. GHC 7.4 had it
11:08:42 <elliott> yitz: also, I'm not getting paid enough to care about old compilers :)
11:08:51 * hackagebot groundhog 0.3.1.1 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-0.3.1.1 (BorisLykah)
11:08:59 <applicativ> wait how hight do fixity numbers go?
11:09:13 <yitz> applicativ: sounds good. will try it out. but i have to make sure that my whole team is doing the same thing, so it'll probably be some time before i move in production.
11:09:24 <applicativ> oh eacameron i know what it is when you redefined . , it gave it a default fixity, maybe 4 o4 5
11:10:03 <applicativ> so write infixr 9 -- or is left association better in this use case
11:10:05 <yitz> elliott: if i don't support old versions of things we delivered to customers, i won't be paid at all.
11:10:35 <monochrom> elliott: fixed in HEAD :)
11:10:42 <elliott> yitz: aye, but I only have to worry about myself, and I conveniently like using just the compiler version I use :)
11:10:50 <eacameron> applicativ: Im not sure about infixr or infixl?
11:10:50 <monochrom> more seriously, fixed in released version too. reload.
11:11:05 <elliott> monochrom: thanks! any change other than removing that line (which I've already done locally)?
11:11:08 <yitz> monochrom: fixed in CACHE
11:11:16 <applicativ> eacameron: i think you will find by experiment which is best
11:11:17 <monochrom> no other change
11:12:01 <applicativ> eacameron: I remember an eccentric library used to do somethign like this, what was it called....
11:13:06 <WarzoneCommand> question: I'm fiddling with the FFI to some C-code. The C function has as input argumet a pointer to a struct. Let say that this struct is of type S, and just contains pointers to other c data structures. The only thing I want to be able to do in haskell, is allocate memory for a struct of type S. How would I represent this struct S in haskell?
11:13:21 <applicativ> eacameron: http://hackage.haskell.org/package/mps  it might be interesting to look at it, just to see the plasticity latent in the language
11:13:42 <fruitFly> No instance for fractional int arising from literal '0.130000' in letterFrequencies = M.fromList [(' ', 0.13000), ....
11:13:44 <fruitFly> ?
11:13:54 <WarzoneCommand> what I preferably don't want to do, is declare data types for everything refered to in S
11:14:03 <applicativ> eacameron: http://hackage.haskell.org/packages/archive/mps/2010.11.28/doc/html/MPS-Light.html is more the module i meant
11:17:00 <applicativ> eacameron: oh, it seems he has a more modern version and is still using it in his empire of libraries http://hackage.haskell.org/package/air and http://hackage.haskell.org/package/air-extras, also on github
11:17:44 <Cale> fruitFly: apparently letterFrequencies :: Map Char Int
11:17:52 <elliott> oh nice, http://hackage.haskell.org/packages/archive/dependent-map/0.1.1.1/doc/html/Data-Dependent-Map.html has just what I was looking for recently
11:17:54 <Cale> fruitFly: for some reason
11:18:22 <Cale> fruitFly: You might try giving it an explicit type which is more in line with what you intend, and get a better error message
11:18:26 <fruitFly> Cale: what? it's a function already or something?
11:18:41 <Cale> Map Char Int isn't a function type
11:18:50 <merijn> WarzoneCommand: I have to run, so no long explanations, unfortunately. But I personally use c2hsc to generate a Storable instance of a C struct, once you have that the functions in Foreign.Marshal can allocate/manipulate things
11:18:51 <Cale> (it doesn't even have an -> in it)
11:19:19 <fruitFly> Cale: I'm making a Map from a list of pairs. and it's giving me that bs... wasn't befor
11:19:22 <fruitFly> before*
11:19:45 <merijn> WarzoneCommand: The repo is https://github.com/merijn/snet2.0 it has a cabal hook to call c2hsc, you'll have to take a look and see if you can figure things out, 'cause I need to run
11:19:48 <Cale> fruitFly: Give the Map an explicit type signature
11:19:52 <WarzoneCommand> ok ty
11:19:56 <Cale> fruitFly: and the compiler will give you a better error message
11:20:04 <fruitFly> Cale: how?
11:20:07 <WarzoneCommand> I'm currently using c2hs, so let me also see if that has something similar
11:20:16 <Cale> letterFrequencies :: Map Char Double
11:20:21 <Cale> or whatever you wanted it to be
11:20:39 <fruitFly> ok
11:20:42 <Cale> just on the line before the declaration
11:22:06 <applicativ> eacameron: here is a tutorial for the old version of air called MPS, again I don't recommend using, it but it is instructive about how haskell operators work https://raw.github.com/nfjinjing/mps/master/test/MPSexamples.lhs
11:24:50 <k0ral_> why isn't MaybeT part of mtl ?
11:27:06 <Cale> k0ral_: There are certain libraries which only change very slowly and deliberately, and mtl is one of them. Well, it has seen some changes with the whole transformers thing, but those were also quite conservative from the perspective that they didn't really affect what it exported.
11:27:37 <elliott> k0ral_: uh...
11:27:45 <elliott> oh hmm
11:27:49 <elliott> it actually isn't part of mtl, only transformers
11:27:54 <elliott> but mtl depends on transformers, so :)
11:27:56 <applicativ> is MaybeT in transformers ..
11:27:57 <applicativ> oh
11:28:03 <elliott> http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Maybe.html
11:28:58 <k0ral_> so depending on both mtl and transformers (which I'm using only for MaybeT) shouldn't make me feel bad, right ?
11:29:09 <applicativ> what would break if e.g. trasnformers had FreeT and mtl had MonadFree ?
11:29:39 <applicativ> k0ral_: mtl already depends on transformers
11:29:48 <applicativ> or am I hallucinating
11:30:02 <Cale> No, that's correct, it does now.
11:30:28 <Cale> So relying on both mtl and transformers is okay, because if someone has mtl, they surely have transformers too.
11:31:15 <applicativ> oooh the new cabal uses 'cabal get' in place of 'cabal unpack' but surely it should give 'cabal clone' as an option ....
11:31:45 <dcoutts> applicativ: oh the bikeshedding about the naming of that, you should have seen it...
11:32:01 <Cale> What was wrong with "unpack"?
11:32:10 <Cale> I suppose get is less typing
11:32:16 <applicativ> dcoutts: somehow, i had already imagined all of it
11:32:34 <applicativ> Cale: face it, its sexier
11:32:35 <dcoutts> Cale: it can fetch source repos, it's more general now
11:32:58 <dcoutts> Cale: but thanks for reminding me, I want to not deprecate unpack
11:33:13 <applicativ> unpack would mean: the hackage stuff
11:33:26 <applicativ> with get can I give a darcs or git address?
11:33:49 <Cale> Yeah, I kind of want to be able to rely on unpack to give me the source code of what it is that would be installed if I did cabal install.
11:33:52 * hackagebot haddock 2.13.2.1 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.13.2.1 (SimonHengel)
11:35:01 <dcoutts> Cale: 'get' still does that, the extra thing is that it has a flag --source-repository
11:35:03 <dcoutts> or -s
11:35:37 <applicativ> oh so it goes to the place listed in the .cabal file?
11:35:39 <applicativ> very sensible
11:37:06 <asante> i'm not shure, if one can exploit this, but is it ok that you can start a ghci at fpcomplete? https://www.fpcomplete.com/user/mgsloan/ghci a simple import System.Cmd let you execute commands via rawSystem
11:37:40 <applicativ> i'll be darned 'cabal get lens --source-repository' calls git
11:37:50 <dcoutts> of course
11:37:59 <dcoutts> how else is it going to get the source repo?
11:38:10 <dcoutts> currently supports git and darcs
11:38:34 <applicativ> likewise 'cabal get  transformers --source-repository'
11:38:37 <applicativ> ah yes
11:38:57 <elliott> hm
11:38:59 <c_wraith> now that bos has joined, he should be complaining it doesn't support hg
11:39:04 <applicativ> dcoutts: no, i was assuming i would just give the repo address, till you mentioned --source-repository
11:39:10 <elliott> it seems like after the first "cabal-dev install --sandbox=foo foo bar baz", doing it again says e.g.
11:39:16 <elliott> foo-1.0 (reinstall)
11:39:23 <applicativ> which of course would be a bit otiose since git and darcs are shorter than 'cabal
11:39:24 <elliott> er, --sandbox=not-foo, no clash :)
11:39:32 <elliott> but the intention is that it only reinstalls it if there's actually any change
11:39:47 <elliott> maybe it is okay to simply allow the reinstalls here, since all packages that could depend on it are going to be reinstalled too
11:40:07 <elliott> but... it would be nice if packages with no change, and that do not depend on anything that got reinstalled, were not reinstalled...
11:40:10 <applicativ> this 'cabal-install' is getting too sexy and industrial-strength. i'm going to try building cabal-0.0.1
11:40:53 <monochrom> cabal get cabal-0.0.1 --source-repository  :)
11:41:41 <trace30m> is "++" only for list ++ element or also for element ++ element ?
11:41:55 <monochrom> neither. it's list ++ list
11:42:02 <trace30m> thx+
11:42:16 <arkeet> thx ++ thx
11:42:52 <elliott> this is a shame, it seems I still have to explicitly manage the dependency graph
11:42:58 <elliott> or else recompile the entire project every single time
11:43:15 <applicativ> i notice cabal head somehow abbreviates 'cabal update' too
11:44:13 <applicativ> trace30m: list ++ [element] , unfortunately
11:44:34 <applicativ> element:list and [element1,element2]
11:44:36 <monochrom> [element] is a list. so it's list ++ List
11:44:43 <enigmuriatic1> is there any reason why two fields in an Aeson FromJSON definition would cause the whole thing not to be parsed even if i used the .:? constructor and made their corresponding type fields optional?
11:44:48 <applicativ> monochrom: yeah, I was just saying what had to be done
11:44:51 <Cale> cabal sdist should be renamed to cabal ball ;)
11:45:20 <monochrom> sdist seems a rather standard name for that
11:45:38 <Clint> what else uses sdist?
11:45:42 <monochrom> but of course "cabalball" is more fun
11:45:58 <elliott> dcoutts: so, when doing "cabal install foo bar baz quux", it would also try and reinstall foo and baz even if only bar and quux were changed, right?
11:45:58 <applicativ> enigmuriatic1: aeson doesn't give partial results does it?
11:46:10 <elliott> dcoutts: er, ./foo ./bar ./baz ./quux
11:46:10 <enigmuriatic1> http://pastebin.com/dREZYSXn    if i remove vin and vout from Tx entirely it works fine
11:46:13 <enigmuriatic1> applicativ
11:46:22 <applicativ> that's the character of 'install' generally elliot
11:46:25 <enigmuriatic1> but even with them optional like that i get nothing
11:46:44 <enigmuriatic1> http://pastebin.com/0Ks48MGF that's what the data looks like applicativ
11:46:47 <elliott> dcoutts: I was hoping that I could get it to only reinstall a listed package if either (a) there is anything to do (i.e., I changed the code), or (b) one of the packages it depends on got reinstalled (i.e., if foo changed but not quux, but quux depends on foo, then both foo and quux get reinstalled)
11:46:54 <enigmuriatic1> actually never mind
11:46:56 <dcoutts> elliott: yes, when you specify a local dir like that you're saying "really, install these source versions, don't rely on any existing installed instances of these"
11:47:08 <elliott> dcoutts: since usually I will only change one or two packages, but that can easily entail reinstalling several of them (because of the dependencies)
11:47:27 <elliott> (and working out which ones I had to reinstall and doing it manually is getting annoying)
11:47:28 <dcoutts> elliott: which isn't quite what one wants in a sandbox context, so the new cabal sandboxing has a slightly different approach there
11:47:45 <enigmuriatic1> applicativ http://pastebin.com/MveRbTJK
11:47:50 <enigmuriatic1> that's what i'm parsing
11:47:59 <dcoutts> elliott: right, so the new sandboxing will just do what you want here
11:48:17 <dcoutts> elliott: assuming you add all those packages as source packages into the sandbox
11:49:11 <elliott> dcoutts: I see, so I should try the development cabal-install? is it stable enough for an experienced user to use it without incident? :)
11:49:18 <elliott> I have HP installed, don't really know how that interacts with upgrading cabal-install...
11:49:40 <elliott> though I could go back to just installing GHC and getting my own cabal-install, of course...
11:50:01 <dcoutts> elliott: worth a go
11:51:29 <elliott> dcoutts: alright. I'll uninstall HP, install GHC, and give it a try :)
11:51:35 <luite_> elliott: it's been working ok here for a while :)
11:51:37 <fruitFly> error: No instance for (Integral ([a1] -> Int))
11:51:38 <fruitFly>       arising from a use of `fromIntegral'
11:51:38 <fruitFly>     Possible fix:
11:51:38 <fruitFly>       add an instance declaration for (Integral ([a1] -> Int))
11:51:38 <fruitFly>     In the second argument of `(/)', namely
11:51:38 <fruitFly>       `fromIntegral length string'
11:51:39 <fruitFly>     In the second argument of `(-)', namely
11:51:41 <dcoutts> elliott: oh I didn't mean that's necessary
11:51:41 <fruitFly>       `(fromIntegral length subString / fromIntegral length string)'
11:51:42 <enigmuriatic1> i think i found out why, applicativ
11:51:43 <fruitFly>     In the first argument of `abs', namely
11:51:45 <fruitFly>       `((letterFrequencies M.! (head subString))
11:51:47 <fruitFly>         - (fromIntegral length subString / fromIntegral length string))'
11:51:50 <enigmuriatic1> old transactions have a really strange format
11:51:51 <fruitFly> Failed, modules loaded: none
11:51:53 --- mode: ChanServ set +o elliott
11:52:04 <elliott> use a pastebin
11:52:14 <fruitFly> ^^^ error in: letterFrequencies = M.fromList [(' ', 0.13), ('e', 0.12702), ('t', 0.09056), ('a', 0.08167), ('o', 0.07507), ('i', 0.06966), ('n', 0.06749), ('s', 0.06327), ('h', 0.06094), ('r', 0.05987), ('d', 0.04253), ('l', 0.04025), ('c', 0.02782), ('u', 0.02758), ('m', 0.02406), ('w', 0.02360), ('f', 0.02228), ('g', 0.02015), ('y', 0.01974), ('p', 0.01929), ('b', 0.01492), ('v', 0.00978), ('k', 0.00772), ('j', 0.00153), ('x', 0.00150), ('q', 0.00095
11:52:15 <fruitFly> ), ('z', 0.00074)]
11:52:15 <fruitFly> --plainTextScore :: String -> Double
11:52:15 <fruitFly> --plainTextScore string =  ratePlainText (filter (\ s -> head s `elem` " " ++ ['A' .. 'Z'] ++ ['a' .. 'z']) (group $ sort (map toLower string)))
11:52:16 <dcoutts> fruitFly: there's hpaste
11:52:16 <fruitFly> --ratePlainText :: [String] -> Double
11:52:17 --- mode: elliott set +q fruitFly!*@*
11:52:21 <luite_> I'm still not satisfied with how GHCJS is added as a compiler flavour in my patch :(
11:52:23 <elliott> unfortunately hpaste is down
11:52:27 <dcoutts> oh
11:52:29 <elliott> but there is e.g. http://paste.lisp.org/
11:52:37 <elliott> oh lol. that is down too.
11:52:40 <elliott> ok, there is http://pastie.org/
11:52:51 <luite_> or http://gist.github.com
11:52:52 --- mode: elliott set -q fruitFly!*@*
11:52:55 <mauke> or ideone.com
11:52:59 <trace30m> can the datatype a also be a function?
11:53:02 <fruitFly> please... it's simple and has to do with fromIntegral in the last definition
11:53:15 <elliott> your definitions were not received, please put them on a pastebin if you want people to see
11:53:17 <Lethalman> so I want to read an image, threshold it and have a read-only bitarray data structure
11:53:30 <Lethalman> I use JuicyPixels to read the image
11:53:40 <elliott> dcoutts: so it is really okay to install over the existing cabal-install? I am just conditioned to extreme paranoia with upgrading Cabal packages :)
11:53:45 <elliott> it is hard to get over
11:53:48 <Lethalman> do you think it's better to keep staying with the pixelAt method and decide whether the pixel is 1 or 0
11:53:57 <dcoutts> elliott: I usually use an old stable ghc and the latest cabal
11:54:02 <ekipan> fruitFly: you're applying fromIntegral to the function length, use parentheses over fromIntegral's argument
11:54:12 <Lethalman> or transform to a bit map maybe
11:54:14 <monochrom> hpaste is down. but there are other paste bins
11:54:17 <fruitFly> ekipan: ok thanks
11:54:18 <Lethalman> anyway, in general, what data structure for a bit array?
11:54:29 <fruitFly> ekipan: I swear it worked before though lol... ok :)
11:54:48 <elliott> dcoutts: ok. I guess the fact that the old cabal-install will be lying around in the package DB isn't a problem, because nothing depends on it? and my ~/.cabal/bin/cabal will simply shadow the /usr/local/bin/cabal from the Platform?
11:54:52 --- mode: elliott set -o elliott
11:55:06 <carter> alpounet thanks for helping repro that bug
11:55:13 <fruitFly> ekipan: now parse error on else?
11:55:25 <carter> dcoutts thanks for the help / patience yesterday, i'll get around to testing it out later this afternoon
11:55:28 <Lethalman> found Data.BitArray so far, mh maybe I just have to stick with the image data directly
11:55:31 <carter> dcoutts you've SAVES ME SO MUCH TIME :)
11:55:33 <dcoutts> elliott: yes, if you have your $PATH set up like that, and yes initially nothing will depend on the new Cabal lib you install
11:55:47 <elliott> oh right, I will have to upgrade the library too
11:55:48 <dcoutts> carter: heh, wait until it works ;-)
11:55:48 <carter> dcoutts are n't you in NYC for running a training course or is that someone else?
11:55:53 <elliott> well, I'll try...
11:55:58 <ekipan> I'm not clairvoyant, use a pastebin
11:56:18 <elliott> nothing more advanced than $ cabal install ./Cabal ./cabal-install in the repo checkout required?
11:56:23 <dcoutts> elliott: right
11:56:29 <fruitFly> I'm learning haskell while doing the matasano challenges, when should I make a github? All the cool kids have one and I know I'll eventually have one, but when? When is that time?
11:56:30 <elliott> ok. here goes nothin'
11:56:53 <dcoutts> carter: oh, we're postponing, we organised it a little early, didn't give people enough notice and so didn't get enough signing up
11:57:11 <carter> dcoutts just to double check, i'm changing by lying and saying the ghc path is  currentGHCpath ++" -pgmc clang -pgma clang" r
11:57:17 <carter> rather than doing the overriding flags appraoch?
11:57:23 <carter> or should i test both approaches?
11:57:46 <carter> dcoutts ah, well, means when it happens i'm more likely to have free time (i'm in nyc)
11:57:56 <dcoutts> carter: changing the path will not work, there is no such program as "/usr/bin/ghc -pgmc clang -pgma clang" :-)
11:58:00 <elliott> fruitFly: that's not on-topic for this channel
11:58:02 <ClaudiusMaximus> Lethalman: i wrote this some time ago, depending what you need it to do with your bitmaps it might be good   http://hackage.haskell.org/package/bitwise
11:58:29 <Lethalman> ClaudiusMaximus, I'd like to implement this algorithm: http://en.wikipedia.org/wiki/Moore_neighborhood
11:58:39 <dcoutts> carter: it's not going via a shell, it's using the program binary path, and the list of flags, so you can't go adding flags into the binary name.
11:58:43 <carter> ok
11:58:52 <carter> so overrriding flags or go home
11:58:53 <carter> got ti
11:59:05 <Lethalman> so my first thought signature is: (Int -> Int -> Bool) -> Bitmap -> Polygon
11:59:16 <carter> dcoutts you should coord with sclv (gershom) also giving a nyc haskell users group talk when you're around
11:59:21 <Lethalman> errrr sorry
11:59:22 <dcoutts> right, it means we don't have so many escaping problems, can have embedded spaces etc
11:59:28 <dcoutts> carter: yes, that's a good idea
11:59:32 <Lethalman> so my first thought signature is: (X -> Y -> Bool) -> Width -> Height -> Polygon
11:59:39 <Lethalman> read Int on X, Y, Width and Height
11:59:48 <Lethalman> therefore, it's pretty general
12:00:03 <Lethalman> I only need to choose the right function to pass there
12:00:26 <Lethalman> I need it fast though, so probably a bitarray is not right now that I think of it
12:00:59 <applicativ> oh i see enigmuriatic1 , by the way why weren't you using the template haskell deriver, not that anyone would insist on it
12:01:04 <Lethalman> in C I'd use a simple 2d matrix of char or int
12:01:18 <enigmuriatic1> applicativ, what do you mean by that?
12:02:08 <applicativ> elliott: fruitFly was asking if haskell people have a norm that only good stuff goes on github.
12:02:32 <enigmuriatic1> applicativ, i've found the root of my problem. for most early transactions, vin has a different format. however, i don't know how to get aeson to recognize this different format and and return Nothing instead of trying to parse it and then throwing out the whole transaction when it can't
12:03:46 <enigmuriatic1> applicativ, is there any way to conditionally parse based on whether a specific field exists?
12:04:42 <applicativ> enigmuriatic1: i just meant this, http://sprunge.us/hNUi?haskell but I see it doesn't speak to the thing about conditions
12:05:01 <flebron> hey guys. what's the best way you've seen to display insets of haskell on a blog post?
12:05:03 <applicativ> enigmuriatic1: with the incantation  30 $(deriveJSON id ''Block)
12:05:49 <applicativ> you get toJSON and fromJSON instances.  these go by the fields of the record so, they would need adjusting (or changing from 'id' to something else)
12:05:50 <enigmuriatic1> applicativ, sorry, i don't understand
12:05:53 <monochrom> the best way I have seen is to write my own html file. I do this all the time. this is subjective.
12:06:09 <applicativ> enigmuriatic1: line 30 http://sprunge.us/hNUi?haskell
12:06:16 <Fuuzetsu> What happened to the ‘State’ constructor? Control.Monad.State only seems to have StateT…
12:06:31 <elliott> dcoutts: nice, it seems to have worked :) are there any preliminary docs on this? I've managed to set up a sandbox with my sources, but I don't know how to go from there to actually installing the things in the sandbox
12:06:38 <applicativ> enigmuriatic1: it does the boilerplate for instance ToJSON and instance FromJSON
12:06:56 <enigmuriatic1> applicativ, what i had before worked, so reformatting isn't my first priority. i'm still trying to fix the vin problm
12:07:33 <applicativ> enigmuriatic1: I was just making the point.  It is nice to have both to and from JSON since then you can test in ghci more readily, but it's a nightmare to write them both
12:07:48 <dcoutts> elliott: you mean you've added the sources into the sandbox, after that you can just build and the source deps will be built/rebuilt automatically
12:08:05 <enigmuriatic1> applicativ, any idea how i can intelligently parse vin?
12:08:34 <enigmuriatic1> it sometimes looks like this instead of what i showed you previously: "vin" : [
12:08:34 <enigmuriatic1>         {
12:08:34 <enigmuriatic1>             "coinbase" : "04ffff001d010b",
12:08:34 <enigmuriatic1>             "sequence" : 4294967295
12:08:34 <enigmuriatic1>         }
12:08:35 <enigmuriatic1>     ]
12:08:38 <applicativ> enigmuriatic1: Stackoverflow has a lot of nice aeson questions by now, by the way http://stackoverflow.com/questions/tagged/aeson
12:08:49 <elliott> dcoutts: build as in "cabal install" in the directory with .cabal-sandbox, or "cabal install ./foo ./bar ./baz" or even "cabal build" or...? sorry :)
12:09:33 <midfield> elliott : btw i had hscolour in my path, cabal haddock --hyperlink-source works, so i think it's a homebrew problem.  i'm going to install haskell-platform via cabal.
12:10:00 <dcoutts> elliott: cabal build should work
12:10:29 <dcoutts> elliott: or install
12:10:45 <elliott> dcoutts: ok, thanks
12:10:55 <elliott> midfield: ah, shame that it's homebrew's fault :/
12:11:22 * applicativ again suggests that homebrew is ok for ghc maybe, but forget haskell platform
12:11:39 <applicativ> homebrew has had the craziest schemes
12:11:51 <elliott> dcoutts: hm, you mean in the "topmost" package I want I suppose? i.e. the main package that depends on all the others? since "cabal build" in the .cabal-sandbox directory just complains about no cabal file like normal
12:12:03 <dcoutts> elliott: right
12:12:18 <dcoutts> elliott: so you just build/install things as normal
12:12:26 <dcoutts> elliott: but it now knows where the deps are
12:12:30 <elliott> ...and "cabal build" in that package's directory complains that it cannot find the dependencies at configure time (that I added as sources to the sandbox). so I must be doing something wrong :)
12:13:08 <applicativ> elliot, can you write a tutorial on what dcoutts is imparting to you? i can't follow this :)
12:13:14 <dcoutts> elliott: oh perhaps currently you need to install them once directly
12:13:31 * dcoutts has only been reviewing the code, not writing it
12:13:34 <elliott> hm, ok
12:13:37 <elliott> I'll paly around with it and see
12:14:05 <elliott> Notice: installing into a sandbox located at
12:14:05 <elliott> /Users/elliott/Code/lambdabot/.cabal-sandbox
12:14:08 <elliott> looks good
12:14:09 <dcoutts> elliott: you can try installing the top one, rather than just configure
12:14:25 <elliott> ok
12:14:29 <applicativ> this 23Skidoo seems like he knows what he's doing ...
12:14:32 <elliott> thanks for your help :)
12:14:56 <elliott> I worry though, if I do "cabal install top-package", will it reinstall top-package's-dependency if I changed it? I don't have a model for how it is working things out
12:15:16 <dcoutts> elliott: it will rebuild the deps if they change
12:15:21 <dcoutts> but not if they don't
12:15:43 <applicativ> by looking at the .hs files?
12:15:49 <elliott> dcoutts: ok, sounds great
12:16:08 <carter> dcoutts to make this code simple to fiddle with, im going to write a mini lens machinery
12:16:23 <carter> that i can embed in setup.hs
12:16:24 <carter> mwahahah
12:16:36 <dcoutts> um :-)
12:16:43 <dcoutts> it should only be about 5 lines of code :-)
12:17:30 <carter> dcoutts yes :)
12:17:43 <carter> i've also i never have a use case of lens
12:18:33 <carter> all i need is Lens a b = Lens (a->b) (b->a->a)
12:18:36 <carter> and get and set
12:18:38 <carter> and pow
12:18:49 <carter> well, kapow
12:20:34 <acube> You'd also need a compose operation, Lens a b -> Lens b c -> Lens a c
12:21:42 <carter> acube oh yeah, because its nicer to write   get (Lens1 `compose` Lens2)
12:21:52 <carter> than get Lens1 $ get Lens2
12:21:53 <carter> woooo
12:21:53 <ekipan> and at that point, you might as well implement Arrow
12:21:58 <carter> ekipan stop
12:21:59 <carter> go home
12:22:13 <ekipan> but I am home
12:22:14 <carter> ekipan unless that a 2 line thing too
12:22:18 <ekipan> it is
12:22:30 <carter> i'm triying to avoid being too nerd sniped
12:22:40 <carter> i'm justexcited i actually have a use case for trying out lens
12:22:55 <carter> most of my code / problem domain currently doens't have deeply nested data types (yet)
12:23:05 <carter> so having an example that is within the scope of my work is nice
12:23:05 <ekipan> @src Arrow
12:23:06 <lambdabot> class Arrow a where
12:23:06 <lambdabot>     arr, pure   :: (b -> c) -> a b c
12:23:06 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
12:23:06 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
12:23:07 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
12:23:09 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
12:23:11 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
12:23:23 <elliott> you can't do Arrow for lenses
12:23:26 <carter> yeah
12:23:31 <ekipan> I see that now
12:23:36 <carter> looks like it'd work for a GArrow
12:23:38 <ekipan> pardon the dust
12:23:38 <carter> but not for arrow
12:23:47 <acube> carter: And you might as well just use the lens package :P
12:23:51 <carter> ekipan elliott  it'd work for GArrow
12:24:00 <carter> acube nope: this is in my setup.hs file
12:24:45 <carter> needs to not have external deps
12:25:02 <carter> ok
12:25:24 <carter> now then: whats the fixity of . ?
12:25:35 <carter> because my own compose operation should have the same fixity right?
12:25:49 <carter> @src Category
12:25:49 <lambdabot> Source not found. There are some things that I just don't know.
12:26:01 <carter> @hoogle (.)
12:26:01 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
12:26:02 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
12:26:02 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
12:26:11 <edwardk> carter: GArrow for lenses doesn't work either iirc
12:26:18 <carter> edwardk ah
12:26:23 <shergill> and that's why i prefer prefix notation. not having to worry about fixity is nice
12:26:29 <ekipan> Category is what I was thinking
12:26:38 <edwardk> infixr 9 .
12:26:39 <carter> @hoogle Category
12:26:40 <lambdabot> Control.Category class Category cat
12:26:40 <lambdabot> Control.Category module Control.Category
12:26:40 <lambdabot> package category-extras
12:26:56 <carter> edwardk thanks!
12:27:04 <elliott> > (0$0.)
12:27:05 <lambdabot>   The operator `GHC.Base..' [infixr 9] of a section
12:27:05 <lambdabot>      must have lower prec...
12:27:07 <edwardk> note you can :info (.) in ghci to find out ;)
12:27:11 <elliott> easy way to tell fixity of any operator
12:27:13 <elliott> without ghci
12:27:33 <structuralist> what's the corecursion scheme that's like an anamorphism but that lets you build multiple layers at once?
12:27:44 <carter> edwardk thanks!
12:27:56 <edwardk> structuralist: apomorphism
12:27:58 <carter> edwardk who do I pester to find out whats needed to get AD v4 ready?
12:28:05 <carter> edwardk thanks on the ghci trick
12:28:08 <edwardk> carter: you start fixing it until its ready
12:28:12 <structuralist> edwardk: ah, thanks
12:28:16 <carter> edwardk good answer
12:28:24 <carter> i'll start mucking around with it soonish
12:28:31 <carter> once i've stabilized some of my currently hackery
12:28:38 <rck> question about currying: can I partially apply the parameters to a function that is itself a parameter of a function, then apply the missing parameter inside the parent function?
12:28:50 <edwardk> alang is probably as up on it as anyone
12:29:26 <alang> hi?
12:29:41 <carter> alang : what sort of help / fixing up can i help with to get ad ready for v4?
12:31:14 <alang> ah give me a sec
12:31:23 <carter> ya :)
12:31:25 <carter> *yay
12:33:23 <carter> edwardk do you know Wavewave's email?
12:33:33 <carter> want to CC him on an email i'm firing off to ofan :)
12:35:34 <shergill> is this the version where you guys were thinking of adding support for lbfgs etc?
12:35:46 <shergill> or was that going to be a separate package? i forget
12:37:04 <carter> shergill that first requires someone (cough cough, *me*) to finish getting a decent lin alg lib out :)
12:37:16 <ipuustin> Anyone tried the haskell websockets library (Network.WebSockets)? I don't get even the simple web page 'meow' example to run (complains: "No instance for (Protocol p0) arising from a use of `runServer'")
12:37:49 <edwardk> carter: check /msg
12:39:27 <eacameron> recommendations on a configuration file lib?
12:39:28 <carter> shergill i'll be done
12:39:59 <carter> shergill i've figured out a sane way of also writing a portable blas/lapack binding that should require no autoconf / code gen crazies
12:40:14 <carter> namely: "use openblas, install it on your machine, then my lib will build"
12:40:29 <shergill> carter: oh have you? that's awesome
12:41:00 <carter> shergill yeah, basically i'll be using it in my own stuff whenever i dont as yet have a faster alternative
12:41:17 <notdan> Is there a way to load GHC module in ghci?
12:41:35 <shergill> carter: doesn't hmatrix already do that? i've never worked with it, but i do remember someone complaining about getting it to work
12:41:40 <carter> shergill nope
12:41:47 <carter> Alberto is really unresponsibe
12:41:57 <carter> and no one will build tools on top of a gpl lib
12:42:01 <monochrom> notdan: could you elaborate? not sure what you mean
12:42:09 <carter> *unresponsive
12:42:13 <carter> nice guy though
12:42:15 <monochrom> perhaps, do you mean the GHC API?
12:42:22 <notdan> monochrom: well, I am getting the following error: import GHC
12:42:23 <notdan> <no location info>: Could not find module `GHC' It is a member of the hidden package `ghc-7.6.3'.
12:42:27 <notdan> yeah
12:42:28 <carter> shergill also will make it easy to benchmark various codes of my own
12:42:30 <alang> carter, edwardk: so if you look at https://github.com/alang9/ad, in Numeric.AD, the doctests for jacobian and hessianF don't pass
12:42:35 <monochrom> ghci -package ghc
12:42:51 <Clint> "no one"
12:42:57 <alang> they'll pass if you give it a type signature
12:43:09 <notdan> thanks monochrom
12:43:22 <notdan> monochrom: I wonder why it works this way. Usually I don't need to specify the package
12:43:23 <elliott> hey, look what lambdabot can do already that I had no idea about!
12:43:23 <carter> alang so they need a type signature, or whats the problem?
12:43:28 <elliott> @let data Foo = A | B deriving Show
12:43:29 <lambdabot>  Defined.
12:43:31 <elliott> > [A,B]
12:43:34 <lambdabot>   mueval-core: Time limit exceeded
12:43:38 <elliott> gah
12:43:38 <elliott> > [A,B]
12:43:42 <lambdabot>   mueval-core: Time limit exceeded
12:43:46 <elliott> oh, come on.
12:43:48 <alang> carter: no ideally the user shouldn't have to provide a type signature for that term
12:43:49 <elliott> I wonder what is up with that.
12:43:51 <monochrom> it is a hidden package. this means not enabled normally. to avoid polluting name space.
12:43:52 <elliott> > [A,B]
12:43:56 <lambdabot>   mueval-core: Time limit exceeded
12:44:02 <johnw> > A
12:44:05 <lambdabot>   A
12:44:06 <elliott> maybe I patched mueval wrongly...
12:44:13 <alang> carter: in the hessianF test, it should default to [[[Double]]], for example.
12:44:16 <elliott> @let instance Num Foo where fromInteger _ = A
12:44:17 <lambdabot>  .L.hs:123:10: Warning:
12:44:17 <lambdabot>      No explicit method or default declaration for `+...
12:44:20 <elliott> > 1 :: Foo
12:44:21 <lambdabot>   No instance for (GHC.Num.Num L.Foo) arising from the literal `1'
12:44:22 <lambdabot>  Possible ...
12:44:28 <elliott> > 1 :: Foo
12:44:29 <lambdabot>   No instance for (GHC.Num.Num L.Foo) arising from the literal `1'
12:44:30 <monochrom> or to stipulate that few people use it
12:44:30 <lambdabot>  Possible ...
12:44:32 <elliott> hm, that's odd.
12:44:37 <elliott> oh well, at least you can define data types.
12:45:11 <carter> alang did they need to in 3.4?
12:45:20 <alang> no
12:45:34 <alang> carter: this is related: http://haskell.1045720.n5.nabble.com/A-type-not-inferred-with-RankNTypes-td5730111.html
12:45:46 <carter> alang oh, is this because head uses type families rather than fundep type classes?
12:46:24 <carter> ok, reading that now
12:47:44 <carter> alang why should it default to double?
12:48:06 <alang> because it did before =P
12:48:55 <carter> huh?
12:48:57 <elliott> dcoutts: I think "cabal install ./lambdabot" was the wrong way to go about it, now when trying to build again (after one of the external dependencies failed) it gives me "cabal: src/Lambdabot/Plugin/Free/Test.hs: does not exist" -- but the actual path is ./lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/Free/Test.hs (and I have no idea why it'd care about the existence of that file anyway)...
12:48:57 <carter> really?
12:49:37 <carter> how'd it default to double before?
12:50:09 <dcoutts> elliott: it checks timestamps to see if a package needs rebuilding
12:50:16 <dcoutts> elliott: you can file a ticket
12:50:44 <elliott> dcoutts: ah, perhaps it's sensitive to the directory I'm running it from...
12:50:44 <carter> alang aside from  annotating :: [Double] and :: [[Double]] respectively,  what else ?
12:50:55 <elliott> I'll try to remember to file a ticket when I'm not in the middle of getting this working :)
12:51:02 <dcoutts> elliott: thanks
12:51:30 <socumbersome> Hi. Is it true that  (>>=g . >>= f)  =  >>=(\x -> f x >>= g) ? I wrote bind in an infix form.
12:51:55 <shachaf> socumbersome: No, because the thing on the left is a syntax error.
12:52:07 <shachaf> socumbersome: Also, the thing on the left has two (>>=s), and the thing on the right only has one.
12:52:29 <alang> carter: that's the only thing
12:53:26 <socumbersome> Hmm... ok. Well, I reached this equation while trying to prove associativity of bind for some monad. I must have screwed sth up
12:54:20 <structuralist> aahhh apomorphisms are not what I am looking for. what's a corecursion scheme that's like something that takes in S -> F*S where F* X = X + F X + F F X + F F F X + … and gives back \nu F ?
12:54:28 <structuralist> where I can return zero or more "layers" at a time
12:54:54 <edwardk> carter: the issue is that with the 3.4 approach they didn't need a signature
12:54:59 <carter> ok
12:55:03 <carter> huh
12:55:06 <edwardk> carter: and we haven't concocted a solution that sidesteps it
12:55:09 <carter> ahhhh
12:55:15 <edwardk> because it is indicative of a larger problem
12:55:18 <carter> ahhh
12:55:20 <carter> ok
12:55:21 <structuralist> unless I'm misunderstanding apomorphisms
12:55:32 <carter> oh, because things will need *lots of * annotations
12:56:01 <carter> because we should be getting the defaulting for the numerical literally inducing the right type?
12:56:36 <edwardk> structuralist: the apomorphism is that x + f (x + f (x + …)) is actually better than x + f x + f (f x) + f (f (f x))  because the latter can be derived from the former
12:56:51 <edwardk> by factoring
12:56:59 <alang> i have to go for a bit, bbl
12:57:14 <carter> ok
12:57:51 <edwardk> you mark where you want to stop in the tree by using the Pure constructor of the free monad.
12:58:09 <nooodl> hmm that reminds me of horner's method
12:58:12 <edwardk> structuralist: what you requested requires all the holes to be at the same level, the free monad doesn't
12:58:47 <carter> edwardk ok good point
12:59:02 <edwardk> oh and yeah i mentioned the wrong thing =)
12:59:10 <carter> so some design bits need to be fixed up to get better defaulting / user experience
12:59:50 <edwardk> you want futu, not apo http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Morphism-Futu.html
13:00:01 <monochrom> Y = X + F Y? newtype Star f x = Star (Either x (Star f x))?
13:00:05 <edwardk> apo is built around mu, not free
13:00:25 <edwardk> monochrom: thats 'Free f'
13:00:29 <structuralist> edwardk: aah yes that one ok thank you
13:00:57 <nooodl> shachaf, i count two >>=s on the right side...
13:01:02 <monochrom> true
13:01:09 <edwardk> apo lets you give one layer or the 'whole thing'. that has the benefit that you can build up prefixes, etc. and then just give back something you have lying around replete with full sharing.
13:01:20 <structuralist> right that was what I thought
13:01:25 <edwardk> the anamorphism on the other hand would always 'be in the way' when you went to access the leaves later.
13:01:35 <structuralist> btw have you looked at Ralf Hinze's unified recursion schemes?
13:01:39 <edwardk> futu on the other hand lets you return multiple levels (even raggedly)
13:01:41 <orzo> i tried and failed to convert a ByteString (interpretted as a zero-terminated c string) to a String
13:01:42 <edwardk> yes
13:01:49 <structuralist> is it as cool as it sounds?
13:01:55 <orzo> isn't there a ready function for that conversion?
13:01:56 <shachaf> nooodl: Oh, that's true. I didn't see the other one.
13:02:32 <shachaf> Perhaps I don't notice syntax errors.
13:02:36 <edwardk> structuralist: i'm rather bored by recursion schemes. even tarmo uustalu, the father of most of the more interesting ones thinks they were a bad idea. once you get past the basic fact that a generalized catamorphism and generalized anamorphism are just a common pattern given a distributive law the rest is boilerplate
13:03:29 <structuralist> edwardk: the selling point I heard was that using explicit recursion is like using "goto"… is there a better solution to that than recursion schemes then?
13:03:38 <shachaf> Then yes, they're the same.
13:03:55 <edwardk> structuralist: my issue is that you don't get much value out of them beyond the basic cata/ana and maybe para.
13:04:04 <edwardk> once you have hylo you're _already_ turing complete.
13:04:18 <edwardk> so they are too big to be useful for reasoning too early
13:04:35 <edwardk> thats why all the efforts to work with hylo fusion fell flat on their face
13:05:01 <structuralist> is the history of this documented somewhere?
13:05:15 <edwardk> now, foldr/build fusion is still useful, and unfoldr/destroy fusion makes fast code, but hylo fusion just doesn't really help out much in practice
13:05:33 <edwardk> not really. you have to piece it together from talking to everyone involved like i did ;)
13:05:52 <monochrom> goto and handwritten recursion are bad iff you don't write specifications
13:06:01 <edwardk> some day maybe i'll write the 'why recursion schemes aren't the future' post
13:06:41 <monochrom> a loop is just as bad iff you don't write loop invariants
13:06:46 <edwardk> in category-extras i went out of my way to show that _all_ of these recursion schemes fit a general pattern and show that you could abstract over them making all of them into (co)monad transformers and distribution laws for the same
13:07:12 <edwardk> then i held up zygohistomorphic prepromorphisms as an example of how little utility you get from that composition
13:07:31 <structuralist> I see
13:07:40 <johnw> edwardk: and yet, it's become such a popular meme :)
13:07:58 <shergill> is that a real thing? zygohistomorphic prepromorphisms?
13:08:07 <edwardk> my general view is that while you can view all of these as an instance of a larger pattern it isn't very useful to do so. all those distributive laws fmap a second time with _something_.
13:08:18 <Saizan> a related field is termination checking and/or handling of (co)recursive definitions in type theory, that's still not as nice as it could be
13:08:52 <edwardk> shergill: zygo- provides a notion of semimutual recursion. histo- provides access to the context you've given before, prepro- lets you modify each layer with an extra natural transformation. the category-extras machinery showed that all of these concepts can be combined
13:08:52 <monochrom> you can mechanically convert goto, call/cc, and recursion into structured programming. just write an interpreter. this shows that control flow structures do not help you.
13:08:57 * hackagebot network-simple 0.2.1.0 - Simple network sockets usage patterns.  http://hackage.haskell.org/package/network-simple-0.2.1.0 (RenzoCarbonara)
13:09:51 <edwardk> Saizan: i thought the recursion scheme for the cofree recursive comonad was an interesting proof theoretic tool, but it also serves as kind of the 'last word' on the comonad side, as you can embed any other one into comrec.
13:10:13 <shergill> edwardk: thanks, that helps
13:10:59 * roconnor gives up on structured programming and grabs FORTRAN
13:11:07 <edwardk> monochrom: the problem is you aren't really factoring out the recursion, because all those distributive laws dip back into the Functor you just or are about to fmap over a second time.
13:11:17 <Saizan> edwardk: got a link for that? i don't remember if i've seen that
13:11:21 <edwardk> monochrom: so they are dreadfully inefficient
13:11:34 <Hermit> roconnor: you should try forth before going fortran
13:11:49 <edwardk> Saizan: look for a copy of the conference proceedings from MSPF 2008. Tarmo Uustalu gave a talk on it there.
13:11:51 <monochrom> however, I'm still happy for Hinze's adjoint folds and unfolds. there are all these easy recursions that look like folds but you didn't know how to write the fold cleanly. aha, now you know you're missing an adjoint.
13:11:53 <roconnor> Hermit: interesting idea
13:11:54 <edwardk> er MSFP
13:12:01 <edwardk> mathematically structured functional programming
13:12:15 <edwardk> at last check the paper wasn't available online, but it may be by now
13:13:14 <Saizan> found it, thanks
13:13:33 <structuralist> are they not even helpful as thinking tools? I guess it makes sense that you can use them to do arbitrarily complicated stuff, but my subjective experience was that writing cata/ana stuff felt a lot *nicer*.
13:14:20 <structuralist> and then I started feeling limited by having to do bookkeeping and was naturally led to generalized stuff (futu, etc.)
13:14:43 <johnw> http://ac.els-cdn.com/S1571066111000570/1-s2.0-S1571066111000570-main.pdf?_tid=4ba78906-d39d-11e2-8c59-00000aab0f02&acdnat=1371068511_5dccf59e822aa18c4b98cc3ee4836962
13:14:54 <johnw> ^-- Uustalu's presentation on cofree recursive comonad
13:15:15 <edwardk_> http://www.ioc.ee/~tarmo/papers/msfp08.pdf
13:15:17 <edwardk_> that has the paper
13:15:18 <edwardk_> thats the one
13:15:18 <structuralist> I guess you can use while loops to write spaghetti code as well but they're still nicer than goto
13:15:20 <edwardk_> in the end of the paper IIRC he puts it in Mendler style
13:15:56 <edwardk> structuralist: i buy that reasoning for cata/ana/apo/futu and to some extent histo. start mixing them and i just don't buy that it is clearer code
13:16:21 <edwardk> this is a value judgment, but at that point in time you're spotting less and less 'fundamental' distributive laws
13:17:09 <edwardk> and you're taking the code to a much more rarified place where someone like myself, gibbons, roconnor, hinze, and a couple dozen other people can easily follow it and nobody else will bother.
13:17:14 <structuralist> I (naively) wonder if linear textual notation is limiting their utility… I wonder if we had something like bob coeke's kindergarten quantum mechanics but for functional programming
13:17:34 <structuralist> maybe it could be *more* intuitive
13:17:42 <tener_> this is weird: is there any way to pass a complex value in FFI by a value rather than a pointer? Specifically I mean this one: http://www.haskell.org/ghc/docs/7.0.4/html/libraries/Win32-2.2.0.1/System-Win32-Time.html#t:SYSTEMTIME
13:18:11 <structuralist> I want to set Bret Victor on this problem
13:18:14 <edwardk> tener_: you can pass every field as an argument to a function
13:18:18 <structuralist> (worrydream.com)
13:20:16 <edwardk> personally i dislike the complex recursion schemes because I invested a couple of years of time in playing around with them and have very very little to show for all that time.
13:20:20 <monochrom> tener_: pass by pointer, but immediately read the data and create Haskell values. since this is read-only, you can legally use unsafePerformIO or unsafeDupablePerformIO (better)
13:20:43 <edwardk> the basic ones pay their way
13:20:50 <edwardk> the other ones not as much
13:21:53 <johnw> edwardk: that's a good summary, thanks
13:21:56 <edwardk> he secret of mathematics isn't 'naming all the things' but rather providing good names for useful things. I don't find the names to be good nor the named things to be particularly useful.
13:22:05 <carter> http://hpaste.org/89830  behold my mini lens!
13:22:22 <structuralist> that I agree with… the menagerie of named schemes is ridiculous
13:22:24 <carter> hopefully it'll make it slightly less crazy for me to muck around with cabal configuring
13:23:27 <elliott> hey hey, hpaste.org works again
13:23:32 <byorgey> carter: you can eta-reduce those.
13:23:41 <carter> byorgey eta reduce whic?
13:23:47 <byorgey> carter: get and set.
13:24:19 <carter> but then i'd have to give them record names
13:24:22 <carter> well
13:24:25 <carter> i guess that would work too
13:24:25 <carter> ok
13:24:28 <carter> you win an internet
13:24:40 <carter> i'll change my type to
13:24:49 <byorgey> what? you don't have to change any types.
13:24:52 <carter> data Lens a b = Lens  { get::(b->a), set:: (a ->b  -> b)}
13:24:55 <carter> or what do you mean
13:25:04 <carter> ohhh
13:25:06 <roconnor> carter: the kerning on line 2 is terrible. ;)
13:25:06 <carter> ahhh
13:25:07 <carter> point free
13:25:09 <byorgey> sure, you can do that too
13:25:15 <structuralist> lol
13:25:15 <carter> roconnor eh?
13:25:19 <carter> byorgey ahhh
13:25:21 <carter> pointfree
13:25:22 <carter> got ti
13:25:25 <carter> i'll do that instead
13:25:28 <roconnor> (b->a) (a ->b  -> b)
13:25:46 <byorgey> roconnor: carter is usually in too much of a hurry to bother about the precise order in which he hits keys ;-)
13:26:05 <carter> byorgey it type checks and seems to work
13:26:15 <carter> hehe
13:26:47 <carter> byorgey also its nonsignificant white space anyways :)
13:27:10 <byorgey> it's significant to roconnor!
13:27:11 <carter> i think i'll leave it eta'd as is
13:27:16 <tener_> edward: this is iridolous but i'll try it
13:27:22 <tener_> ridicolous*
13:27:50 <byorgey> aww, for a second I thought iridolous was some cool new word I didn't know
13:28:27 <tener_> monochrom: i'm calling third party dll and it seems to expect a value, not a pointer
13:28:34 <carter> byorgey tener_  we should make it one
13:28:37 <tener_> monochrom: IO isn't problem
13:28:53 <carter> iridolous : so ridiculous we don't even have a word for it
13:29:08 <byorgey> hahaha, I like it =)
13:29:41 <ipuustin> hi, a newbie question. how do I fix the type of a "variable" inside a do block? for example, how do I tell the compiler that I want x be of type A here:  do { x <- foo; return () }
13:30:12 <elliott> x <- foo :: M A (given that your monad is M)
13:30:14 <tener_> carter: good one :-) ssh -X is eating my keystrokes for some reason
13:30:23 <elliott> I think x :: A <- foo works if you enable some extension
13:30:24 <carter> tener_ write your own shh :)
13:30:29 <carter> i mean ssh
13:30:30 <carter> or not
13:30:32 <Ralith> carter: hey, did you get my message?
13:30:35 <Ralith> well, lispy's
13:30:36 <carter> Ralith nope
13:30:38 <carter> well
13:30:48 <ipuustin> elliott: ok, thanks!
13:30:54 <elliott> :)
13:31:01 <carter> in my case, I have to hack Cabal to get it to pass those flags in
13:31:02 <enthropy> ipuustin: foo `asTypeOf` return (undefined :: A) -- another option
13:31:10 <Ralith> lispy mentioned you were trying to override the assembler used by ghc when building via cabal
13:31:23 <Ralith> that should be doable via cabal build --ghc-options=-pgma=clang
13:31:35 <carter> Ralith the problem is EVERY mac user would have to do that
13:31:39 <carter> and consider that untenable
13:31:50 <Ralith> you can set the ghc-options: field in the .cabal file
13:32:02 <carter> Ralith that isn't passed to ghc when its used on C code
13:32:04 <Ralith> I think you can conditionalize that on target
13:32:25 <carter> Ralith yes, but its not passed to ghc when its used to build C codes
13:32:38 <Ralith> carter: did you try -pgmc?
13:32:43 <carter> Ralith i tried BOTH
13:32:49 <carter> Ralith i did all this :)
13:32:50 <carter> it doesn't work
13:32:52 <Ralith> kay
13:32:59 <carter> i can link you to a long ass thread :)
13:33:01 <carter> or two
13:33:10 <Ralith> no worries; I just solved a similar thing with idris on windows so I wanted to make sure you were aware of the options just in case
13:33:10 <carter> Ralith i'll link you to the setup.hs work aroudn i'm testing in a few
13:33:18 <carter> Ralith what was the context in your case ?
13:33:32 <carter> was it for building the haskell code
13:33:35 <carter> or for buildign the c code?
13:33:38 <Ralith> it was for linking
13:33:38 <carter> or other?
13:33:41 <carter> oh?
13:33:43 <carter> explain
13:33:44 <carter> more
13:34:00 <Ralith> the haskell platform on windows ships with a gcc, including libc and libstdc++
13:34:20 <Ralith> when you compile llvm with the system mingw/msys, it gets built against the system libstdc++
13:34:33 <Ralith> which is generally not binary compatible with whatever's in the haskell platform
13:34:56 <Ralith> so when you finally link a program that uses the llvm bindings, you need to get ghc to use the system mingw gcc instead of the haskell platform gcc
13:35:04 <Ralith> or else a binary-incompatible libstdc++ is linked, causing a failure
13:35:22 <Ralith> this is accomplished via --ghc-options=-pgma=gcc
13:35:38 <Ralith> which replaces <hardcoded gcc path> with 'gcc' which resolves via PATH as per usual and Just Works
13:35:45 <carter> Ralith yeah
13:36:06 <Ralith> this should probably be noted in the llvm bindings docs somewhere
13:36:14 <carter> so ghc-options are passed by cabal when building hs code
13:36:18 <carter> but not when using it to build c codes
13:36:45 <Ralith> idris doesn't use cabal to build its C code, so I don't know anything about that infrastructure
13:37:17 <carter> Ralith i have to work around the gcc / as on mac being crap
13:37:39 <carter> i may have a way courtesy of dcoutts  that lets me set pgma and pgmc sanely
13:37:40 <carter> i hope
13:37:46 <Ralith> nice
13:37:47 <carter> testing it in a moment
13:38:17 <carter> also wrote a mini lens lib in my setup.hs to make  all the nested constructor stuff more redable
13:38:18 <carter> http://hpaste.org/89830
13:38:30 <carter> now I understand why people like using them
13:38:30 <edwardk> minier-lens: http://hpaste.org/89830
13:38:40 <edwardk> that version is lens compatible
13:38:51 <edwardk> _2 f (a,b) = (,) a <$> f b
13:38:58 <edwardk> then you can use it with those combinators
13:39:13 <edwardk> (1,2)^._2; (1,2) & _2 .~ "hello", etc
13:39:17 <johnw> why not type Lens' s a = Lens s s a a?
13:39:29 <carter> edwardk so how would i write an instance
13:39:32 <edwardk> johnw: mostly because i was just being explicit. i don't use those types
13:39:39 <edwardk> carter: _2 f (a,b) = (,) a <$> f b
13:39:43 <edwardk> that was one
13:39:57 <edwardk> pretend you are writing a traverse instance for the part you want to get to
13:40:24 <edwardk> both f (a,b) = (,) <$> f a <*> f b
13:40:33 <carter> how would i write
13:40:34 <carter> lensProgramConfig2LocBuildInfo :: Lens (ProgramConfiguration) (LocalBuildInfo)
13:40:35 <carter> lensProgramConfig2LocBuildInfo = Lens (\LocalBuildInfo{withPrograms}-> withPrograms)
13:40:35 <carter>                                     (\wprog lbi -> lbi{withPrograms= wprog})
13:40:48 <carter> tunixman has a question for us now I hear
13:40:58 <carter> as an aside
13:41:12 <tunixman> I do!
13:41:19 <tunixman> I have this code: http://hpaste.org/89833
13:41:27 <carter> and ? :)
13:41:36 <tunixman> And I'm trying basically to get the A records for the NS records.
13:41:42 <edwardk> lensProgramConfig2LocBuildInfo f pc = (\wp -> pc { withPrograms = wp }) <$> f (withPrograms pc)
13:41:59 <tunixman> Only I'm failing to handle the Maybe and the IO, unsurprisingly.
13:42:34 <Fuuzetsu> Does there exist ‘sequence’ equivalent for (Applicative) functors?
13:42:41 <edwardk> :t sequenceA
13:42:42 <lambdabot>     Not in scope: `sequenceA'
13:42:42 <lambdabot>     Perhaps you meant one of these:
13:42:42 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
13:42:45 <edwardk> :t T.sequenceA
13:42:46 <lambdabot> (Applicative f, T.Traversable t) => t (f a) -> f (t a)
13:43:06 <byorgey> Fuuzetsu: yes, in Data.Traversable
13:43:15 <Fuuzetsu> Thanks~
13:43:47 <byorgey> it generalizes not only Monad => Applicative but also list => any Traversable thing, which is perhaps why you could not find it =)
13:44:36 <edwardk> :t traverse id
13:44:36 <lambdabot>     Not in scope: `traverse'
13:44:37 <lambdabot>     Perhaps you meant one of these:
13:44:37 <lambdabot>       `T.traverse' (imported from Data.Traversable),
13:44:41 <edwardk> :t T.traverse id
13:44:42 <lambdabot> (Applicative f, T.Traversable t) => t (f b) -> f (t b)
13:44:48 <edwardk> interesting that traverse isn't in scope
13:44:51 <edwardk> did lens go out of scope?
13:44:58 <edwardk> :t (1,2)^._2
13:44:59 <lambdabot>     Not in scope: `^.'
13:44:59 <lambdabot>     Perhaps you meant one of these:
13:44:59 <lambdabot>       `.' (imported from Data.Function),
13:45:06 <edwardk> ah the Safe Haskell issue
13:45:09 <elliott> edwardk: yes because of - yeah
13:45:14 <tunixman> This does work, but just gets the NS records: http://hpaste.org/89835
13:45:20 <elliott> i could patch hashable manually but i'd really rather just wait until it's fixed
13:45:28 <elliott> unless you're really desperate for it :P
13:45:43 <carter> tunixman whats the goal again?
13:45:45 <tunixman> I think it's Maybe [RRSet], which I can get RRSets from and turn them into strings to do lookups.
13:45:55 <Fuuzetsu> What issue is this?
13:45:57 <tunixman> I'm trying to look up the A records for the NS records from a domain.
13:46:04 <carter> using which lib again :)
13:46:06 <carter> ?
13:46:18 <carter> edwardk thanks! i'll stare at your fancier slicker version later
13:46:22 <tunixman> So 1. look up the NS records. 2. for each NS record look up the corresponding A records
13:46:33 <tunixman> It's dns, but let me get the version info too.
13:46:42 <edwardk> carter: note in there i'm using '() ->'   as a placeholder for Identity because Identity isn't in base ;)
13:46:46 <tunixman> dns-0.3.6
13:47:02 <tunixman> http://hackage.haskell.org/package/dns-0.3.6
13:48:09 <fruitFly> how do I open .txt and parse lines?
13:48:22 <fruitFly> lemme rephrase:
13:48:25 <Peaker> fruitFly, lines <$> readFile "file.txt" ?
13:48:48 <fruitFly> how do I import .txt into my program and parse it, do I need to import anything special?
13:48:55 <Fuuzetsu> or more newbie friendly, in the IO monad: do content <- readFile "file.txt"
13:49:08 <Fuuzetsu> fruitFly: No such thing as importing a .txt file
13:49:31 <Fuuzetsu> Just pass the FilePath to readFile
13:49:45 <fruitFly> I have a function and I wanna apply it to each line of a 300 line text file
13:50:31 <Hermit> fruitFly: fmap (yourfunction . lines) $ readFile "filepath.txt"
13:50:46 <fruitFly> Peaker: is readFile in prelude? how do I reference the .txt, does it have to be in my application folder?
13:51:02 <carter> tunixman have you tried doing this code interactively in ghci?
13:51:14 <carter> Maybe and IO are different monads
13:51:15 <Hermit> fruitFly: or  s/yourfunction/map yourfunction/
13:51:17 <tunixman> yes, basically...
13:51:25 <Fuuzetsu> fruitFly: http://learnyouahaskell.com/input-and-output is where you should have learned about this tuff
13:51:27 <carter> so you either use monad transfomers to do something that combines the two
13:51:30 <Fuuzetsu> stuff*
13:51:31 <carter> or
13:51:47 <fruitFly> Fuuzetsu: ok, that's like my next chapter :)... think I'll give it a read now.
13:52:17 <carter> or
13:52:18 <carter> umm
13:52:19 <carter> yeah
13:52:20 <carter> :)
13:52:21 <tunixman> Monad Transformers...
13:52:26 <carter> MaybeT IO a?
13:52:31 <tunixman> I'll read up! Thanks
13:52:39 <tunixman> Hmmm.... of course!
13:52:41 <carter> that or nesteded do notation + some lifts/returns
13:52:43 <tunixman> Let me see what I come up with.
13:53:10 <Peaker> fruitFly, yes, it's in Prelude
13:53:23 <carter> tunixman http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Maybe.html
13:53:27 <Peaker> fruitFly, you refer using a FilePath using ordinary OS path rules (Haskell isn't special here)
13:53:34 <edwardk> @remember johnw lens makes one into a mutating ninja
13:53:34 <lambdabot> It is forever etched in my memory.
13:54:20 <Peaker> tunixman, http://www.haskell.org/haskellwiki/Monad_Transformers_Tutorial  explains MaybeT
13:55:47 <tunixman> t Peaker thanks, I'm reading it now too
13:56:33 <FreeFull> I never remember the order of parameters to set/(.~)
13:58:00 <FreeFull> Oh, got it
13:58:30 <xico> hi
13:58:37 <FreeFull> lens -> value -> structure -> structure
13:59:38 <Peaker> FreeFull, there's .= which is supposed to look like :=  and then all the = operators have the ~ variants which all return the (s->t) thing at their end
13:59:49 <Peaker> (s -> t) is the polymorphic structure -> structure
14:01:15 <edwardk> l .~ value $ structure = structure
14:01:35 <xico> im building a minimalistic animation canvas library for my very specific use. i managed to get simple elements with simple motions. however, i need to have certain element follow random trajectories. what would be a good way to handle that without breaking the purity too much? for now my code looks like: http://hpaste.org/89837
14:01:48 <[swift]> hmm, so it _appears_ that LiberalTypeSynonyms lets me hide the ST monad's phantom type parameter by writing "type MyST a = forall s. ST s a" or something along these lines. is there any problem with this technique?
14:02:26 <Peaker> [swift], the "s"s in different type contexts need to be equal
14:02:56 <Peaker> [swift], if you use:  type MyST = forall s. ST s        you won't need the LiberalTypeSynonyms
14:03:20 <Peaker> [swift], but then if you have:  MyST (STRef s Int)   you have two s's involved here, and that won't work
14:03:49 <[swift]> Peaker: yeah, i know. ghc didn't like "type MyST a = ST s a", which is really what i wanted to do
14:04:00 * hackagebot imm 0.6.0.1 - Retrieve RSS/Atom feeds and write one mail per new item in a maildir.  http://hackage.haskell.org/package/imm-0.6.0.1 (koral)
14:04:03 <FreeFull> Peaker: Isn't .= for the state monad
14:04:07 <[swift]> i'm not sure why that doesn't work
14:04:14 <Peaker> FreeFull, yeah, all the = operators are for State, and ~ operators are for pure modifiers
14:04:34 <Peaker> [swift], in type synonyms, it is usually better to eta reduce as much as possible -- because type synonyms need to be fully applied everywhere, or you need LiberalTypeSynonyms
14:05:01 <Peaker> [swift], so remove the "a" from both sides to avoid the need for LiberalTypeSynonyms, but it still won't work because the "s" is all about marking that your mutable data and computations are the same thread
14:05:17 <Peaker> [swift], and you are trying to say that each "s" is its own unknown thread
14:05:55 <[swift]> Peaker: i understand the purpose of the s, but i don't know how to express the idea "replace 'MyST' with 'ST s' just as if I had written the latter in the type signature originally"
14:06:21 <[swift]> Peaker: that's what i was hoping LiberalTypeSynonyms might give me, but apparently it doesn't?
14:06:58 <[swift]> i was hoping it would substitute first and only then check the types
14:07:15 <qzr> Which mutable container should one use? Array Vector or Repa?
14:07:20 <rck> if I have a data type that I want to share between modules, should I define it in both? or put it in a separate module and import it into the rest of my modules?
14:07:23 <qzr> especially for 2d arrays
14:08:03 <xico> qzr: are repa arrays mutable?
14:08:05 <qzr> rck: define it seperately and import it in both
14:08:18 <rck> qzr: thanks
14:08:59 <xico> qzr: i mean they are not
14:09:44 <qzr> xico: oups, I thought they were. Then the contest is between array and vector :)
14:09:53 <xico> use vector definitively
14:10:04 <xico> then you can freeze into repa if you need it
14:10:58 <qzr> xico: Thanks! Additionally: Should one use ST or IO?
14:11:12 <Peaker> [swift], you can't replace "MyST" with "ST s" because you need to explicitly pass "s" to a different scope
14:11:14 <qzr> xico: I'm never quite sure what to use
14:11:44 <xico> qzr: dunno. repa use io though to manage the gang of threads.
14:11:56 <Peaker> doh, Read instance of records requires fixed order of fields :(
14:12:27 <elliott> Peaker: and doesn't allow omitting the record syntax either
14:12:30 <elliott> it's kind of bad
14:13:03 <Peaker> gonna try aeson's TH
14:13:34 <qzr> And more general: Why is it possible to do all kinds of IO-related stuff inside an ST-Monad and the freeze the vector back to an immutable version? This seems kind of 'cheating".
14:14:40 <Peaker> qzr, what IO related stuff?
14:14:53 <Peaker> qzr, unsafeFreeze/unsafeThaw are cheating, that's why they are "unsafe"
14:15:04 <Peaker> qzr, they can be used to build safe primitives like runSTArray which is safe
14:15:28 <[swift]> Peaker: i'm not entirely sure i understand that objection. it seems to me that the real problem is that type synonyms must define a valid type or type function in isolation. i was hoping LiberalTypeSynonyms would allow them to remain "uninterpreted" until they were substituted
14:15:57 <qzr> Peaker: Well updating single elements in place. I just never got why this is 'safe' inside an ST monad and unsafe if done by unsafePerformIO
14:16:07 <[swift]> clearly i just misunderstood FP Complete's description of what LiberalTypeSynonyms allows
14:16:38 <Peaker> [swift], you seem to expect:  type MyST = ST s   to get that "s" from outer scope?   or once you add the "forall" in there, to have that forall get the same "s" from outer scope?  It's a different "s" unless you explicitly pass it
14:16:50 <Peaker> [swift], I don't think LiberalTypeSynonyms is related here
14:17:06 <Peaker> [swift], can you show where you have an error without LiberalTypeSynonyms?
14:18:03 <[swift]> Peaker: i was hoping for more of a syntactic substitution, i suppose
14:18:40 <[swift]> i don't have an error at all.
14:18:48 <Peaker> [swift], that would break all kinds of useful assumptions about dependencies
14:19:00 <Peaker> [swift], if you could use variables from non-lexical scope
14:20:13 <tunixman> Also taking carter's advice to unravel the code in ghci.
14:20:20 <carter> tunixman woot
14:20:30 <[swift]> Peaker: doubtless. it would also complicate error reporting. it would be nonetheless useful, though
14:21:15 <Peaker> [swift], well, that's why Lisp was designed with dynamic scoping in the 1960's.  We've discovered since that it's a bad idea :)
14:21:38 <shachaf> Dynamically scoped type variables sound like a great idea.
14:22:07 <shachaf> Or ImplicitParams, at least.
14:22:11 <shachaf> type MyST = ST ?s
14:22:36 <[swift]> Peaker: i feel less concerned about it at the type level, though maybe that's just hubris
14:22:56 <[swift]> hmm.. implicit params, interesting..
14:36:59 <shachaf> Tekmo sure hates semigroups.
14:38:11 <jfischoff> really?
14:39:41 <elliott> I'm not convinced he understands anything about them from his arguments...
14:39:59 <jfischoff> where are the arguments?
14:40:11 <elliott> libraries@
14:41:31 <carter> dcoutts YOU ARE MY FAVORITE PERSON
14:41:33 <carter> seems to work
14:44:40 <enigmuriatic1> is there an intercalate function for lazy bytestrings?
14:46:06 <shachaf> Did you look in the lazy ByteString documentation?
14:46:50 <Reite> http://www.haskell.org/hoogle/?hoogle=intercalate
14:46:54 <Reite> hoogle is your friend
14:47:10 <shachaf> I mean, I can answer "yes". The answer is yes. But I'm not sure that will that change your actions.
14:48:09 <dmwit> elliott: I do not believe build/configure/register and friends work the same way install do in that regard.
14:48:21 * elliott nod
14:48:33 <elliott> with any luck I can get this sandbox stuff working with git cabal-install
14:58:37 <carter> dcoutts thanksssss
14:59:09 <monochrom> "install" is recursive over missing dependencies. but suppose you have all dependencies already installed. then "install" is just "configure, build, Maybe haddock, copy, register"
14:59:30 <monochrom> and Maybe run the test suite
15:00:31 <carter> whats the right ghc CPP pragma for OS X?
15:00:47 <carter> ive tried DARWIN_HOST_OS
15:00:56 <carter> and OSX_HOST_OS
15:01:56 <carter> ohh
15:04:03 * hackagebot cassandra-cql 0.2.0.1 - Haskell client for Cassandra's CQL protocol  http://hackage.haskell.org/package/cassandra-cql-0.2.0.1 (StephenBlackheath)
15:05:50 <carter> its darwin_HOST_OS
15:05:51 <carter> yay
15:10:32 <Guest6358> hey
15:17:04 <johnw> thoughtpolice: ping
15:19:04 * hackagebot nitro 0.1.0.0 - Haskell bindings for Nitro  http://hackage.haskell.org/package/nitro-0.1.0.0 (ErinDahlgren)
15:20:03 <johnw> carter: can you see https://www.dropbox.com/sh/m22k8uv45sdkl1f/gFIoCb-FWc/ghc/dist?
15:21:20 <applicativ> how do I get the size of a file in the sense that the os uses, or du uses?
15:22:02 <hpc> applicativ: likely OS-specific
15:22:33 <applicativ> places like System.Directory Filepath are no use. hm
15:24:04 * hackagebot network-simple-tls 0.1.1.0 - Simple interface to TLS secured network sockets.  http://hackage.haskell.org/package/network-simple-tls-0.1.1.0 (RenzoCarbonara)
15:24:24 <Fuuzetsu> what's wrong with hFileSize?
15:24:30 <applicativ> oh i see openFile xxx >>= hFileSize h
15:24:36 <applicativ> Fuuzetsu: yes, just found it.
15:25:37 <applicativ> it didn't occur that I had to open the file
15:26:14 <hpc> oh, just the regular file size
15:26:29 <hpc> applicativ: i thought you meant physical size, as in "this takes up X disk blocks"
15:26:37 <Fuuzetsu> I just found it by looking for ‘fileSize’
15:27:01 <applicativ> Fuuzetsu: youre to clever, I try to think up possible module names first
15:27:18 * Fuuzetsu basks
15:27:29 <applicativ> hpc i was thinking about ye olde puzzle 'how to write du in haskell'
15:27:45 <applicativ> having come upon yet another 'directory recurse' function
15:28:19 <applicativ> in terms of 'pipes'
15:34:12 <DiegoNolan> how do you write an instance fro Show if it depends on another type class that uses show
15:34:13 <DiegoNolan> eg
15:34:21 <DiegoNolan> instance Show [a] where
15:34:39 <DiegoNolan> show xs = concatmap shaw xs
15:34:44 <DiegoNolan> show*
15:34:52 <DiegoNolan> but the second show is for a
15:34:58 <DiegoNolan> and the first is for a list of a
15:35:40 <koala_man> Show a => Show [a]
15:35:59 <DiegoNolan> but this is just an example
15:36:12 <DiegoNolan> ohhh
15:36:13 <DiegoNolan> ic
15:36:23 <DiegoNolan> wait actually
15:36:42 <DiegoNolan> i don't think i can do that because i want a mroe elaborate show
15:36:55 <DiegoNolan> for the type i am writing the instance for
15:39:15 <johnw> http://newartisans.com/2013/06/nightly-builds-of-ghc-head-for-os-x-10-8/
15:39:26 <johnw> in case anyone wants to try HEAD builds for Mac
15:40:01 <Fuuzetsu> Still waiting for the return of HEAD binaries on the GHC site.
15:40:04 <koala_man> DiegoNolan: what? you can make your instance as elaborate as you want that way, and when you want to show the nested elements, you can delegate it to their instance (and possibly transform the result)
15:41:50 <DiegoNolan> list me gist it
15:41:57 <DiegoNolan> then i'll post so its more clear
15:49:18 <Bor0> which one is essentially faster? http://hpaste.org/89839
15:49:57 <Bor0> by intuition I'd guess maptry, but I'm not sure
15:50:05 <weebl> couldn't say - i'd imagine they might get optimized to the same stuff
15:53:31 <applicativ> maptry is certainly in a better position to be optimized
15:53:34 <mauke> maprec
15:53:41 <mauke> because it's not recursive
15:54:18 <Bor0> how is maprec not recursive?
15:54:21 <applicativ> hm map is recursive
15:54:36 <mauke> Bor0: it doesn't call itself
15:54:37 <applicativ> its a pretty odd definition
15:54:46 <Bor0> oh, I have a mistake in it
15:54:50 <applicativ> did you mean  f x : map f xs
15:54:51 <Bor0> it should call maprec instead of map
15:54:53 <applicativ> did you mean  f x : maprec f xs
15:55:24 <Bor0> updated the paste, please refresh http://hpaste.org/89839
15:56:51 <applicativ> maprec is the def of 'map', restricted to functions a -> a
15:57:01 <Bor0> :t map
15:57:02 <lambdabot> (a -> b) -> [a] -> [b]
15:57:20 <Bor0> okay, so map is exactly implemented as maprec in my sample?
15:57:23 <Bor0> @src map
15:57:23 <lambdabot> map _ []     = []
15:57:23 <lambdabot> map f (x:xs) = f x : map f xs
15:57:25 <mauke> no
15:57:44 <Bor0> how do you mean?
15:57:46 <mauke> ok, yes
15:57:52 <applicativ> mauke: that's whats in GHC-Base.html#map
15:58:00 <mauke> yeah, I just checked
15:58:03 <applicativ> however, there is a RULE associated with it
15:58:17 <Bor0> I don't know what RULE is. still at chapter 5 of lyah
15:58:31 <mauke> Bor0: ghc extension for custom optimization rules
15:58:34 <applicativ> Bor0: it part of an optimization apparatus
15:58:39 <mauke> it's used heavily in the standard library
15:58:43 <applicativ> a 'rewrite rule'
15:58:45 <Bor0> cool
15:58:52 <mauke> map"       [~1] forall f xs.   map f xs                = build (\c n -> foldr (mapFB c f) n xs)
16:01:04 <applicativ> mapFB is a little opaque, hm
16:04:59 <applicativ> It's amazing that all this list optimization stuff is basically at the library level with the RULES pragma
16:06:16 <applicativ> but basically the list optimizations in Base look like the ones in vector or, better, Data.List.Stream
16:13:18 <fetter_oml> good evening to you. im holding a tutorium on haskell tomorrow, and this week we talk a bit about monads (not much, just a little view into it, proving that the monad List fulfilles the monad rules etc)
16:13:47 <fetter_oml> so im wondering: how are the operators >>=, >> etc called?
16:14:09 <ion> >>= is bind, >> might be called “and then” or something.
16:14:17 <fetter_oml> if you want to talk in real languge
16:14:41 <fetter_oml> mhm, ok, bind makes sense
16:15:08 <fetter_oml> im usually writing about this stuff, ive always used just >>= then :)
16:15:26 <fetter_oml> thank you very much, an good night if that applies to you. bye :)
16:24:36 <blackdog> shachaf: hey, you around? i'm hitting a "sendWakeup: invalid argument (Bad file descriptor)" and noticed you hit it in january-  did you ever solve the problem?
16:26:15 <bel3atar> what's the executable name of the haskell interpreter?
16:26:23 <joelteon> ghci
16:26:27 <ciaranm> hugs
16:26:33 <joelteon> ghc
16:26:36 <geekosaur> ghci is actually a wrapper script, it's ghc
16:26:55 <luite_> and not the ghc in your path, that's also a wrapper schript
16:28:07 <bel3atar> XD
16:28:29 <joelteon> oh wow, it is
16:28:47 <shachaf> blackdog: What was the context?
16:28:50 <joelteon> it's ghc-stage2
16:29:34 <shachaf> blackdog: Oh, oh, I know.
16:29:39 <shachaf> blackdog: http://hackage.haskell.org/trac/ghc/ticket/7653
16:29:43 <ion> mueval
16:29:51 <bel3atar> so basically it's ghc --interactive?
16:30:16 <ion> cat $(which ghci)
16:30:37 <blackdog> shachaf: gracias. so i'd need to grab head to see if that's my problem, basically?
16:31:10 <bel3atar> /usr/bin/ghc -> ghc-7.6.3*
16:31:27 <shachaf> blackdog: That would work.
16:32:07 <ion> Hmm, interesting. The ghci script uses ${1+"$@"}. I take it there are some variants of sh in whom just "$@" without parameters expands to "" instead of no parameter?
16:32:45 <blackdog> shachaf: looks plausible, too - i have tens of thousands of threads, and they're all reasonably busy
16:33:09 <geekosaur> ion, that's the default behavior of traditional /bin/sh
16:33:32 <geekosaur> some people, oddly enough, actually care that x11 works on solaris and such
16:33:52 <blackdog> shachaf: thanks :)
16:34:08 <bel3atar> what's the 1+ for?
16:34:26 <ion> bel3atar: It checks if $1 is set and only expands to "$@" if it is.
16:36:36 <bel3atar> why the + ?
16:37:14 <ion> That’s the syntax.
16:37:29 <geekosaur> `+` is the syntax for "expand to the following string if the preceding variable is set"
16:38:19 <Tene> There's a lot of useful things you can learn reading through /^EXPANSION/ in bash(1)
16:39:09 <Fuuzetsu> How disappointing, this weeks Haskell Weekly News uses an old quote…
16:39:10 <ion> Actually, if the ${foo+bar} isn’t in quotes itself, it expands to bar not as a string but a parameter list.
16:40:51 <ion> Hmm, interesting. That’s what dash does here, but not zsh.
16:41:18 <geekosaur> zsh does a number of things differently
16:44:46 <frerich> Hi, I wrote a small engine for a turn based game. The main function driving everything is 'run :: [PlayerName] -> (Game -> IO ValidMove) -> IO Game', the second argument being a function which is supposed to ask the player for a move. Now, as it is this function enforces IO, which is not so nice (the function itself has no dependency on IO at all and I imagine this is not optimal for testing either.
16:45:07 <ion> The behavior of dash, zsh and bash: https://gist.github.com/ion1/5770133
16:45:09 <frerich> Hence, I changed it to be 'run :: Monad m => [PlayerName] …', but now I wonder - is there maybe an even better name to do this "inversion of control" in Haskell?
16:45:18 <Fuuzetsu> :t fromMaybe
16:45:18 <frerich> Other than passing "callbacks"?
16:45:19 <lambdabot> a -> Maybe a -> a
16:45:20 <ciaranm> frerich: why monad it at all?
16:45:59 <fruitFly> can I have a haskell bed time story, I'm off to be :)
16:46:05 <fruitFly> bed*
16:46:21 <ciaranm> frerich: is your problem how to turn a -> b into a -> m b ?
16:46:30 <ciaranm> :t (return .)
16:46:31 <lambdabot> Monad m => (a -> b) -> a -> m b
16:47:25 <frerich> ciaranm: I would like to allow that the "move getter" function (Game -> m ValidMove) to do IO, e.g. ask a player which is connected via TCP/IP for a move. However, the 'run' function itself has no requirement on IO.
16:48:45 <ciaranm> frerich: can't you just move the IO into whatever function it is that glues together run and move getter?
16:49:31 <frerich> ciaranm: Before I cause even more confusion, let me whip up a tiny example to illustrate my scenario… code is less ambiguous than my english :)
16:50:12 <Fuuzetsu> What do you guys use for long expressions with recurring operators? Operator trailing on the same line or at the beginning of a new line?
16:50:39 <Ralith> frerich: making some guesses about our types, the usual approach is have 'step :: Game -> ValidMove -> Game', 'getMove :: IO ValidMove' and possibly 'display : Game -> IO ()'
16:50:43 <Tene> Fuuzetsu: beginning
16:50:50 <Ralith> your types*
16:52:29 <frerich> Ralith: Interesting, that looks a lot like what I have: http://hpaste.org/89841
16:52:50 <Ralith> frerich: the point is to separate them out
16:55:11 <Fuuzetsu> > '"'
16:55:12 <lambdabot>   '"'
16:55:18 <Fuuzetsu> > '\"'
16:55:19 <lambdabot>   '"'
16:55:31 <Fuuzetsu> > '"' == '\"'
16:55:33 <lambdabot>   True
17:03:14 <[swift]> how can i convince cabal to link an existing static library into the static library cabal is building? do i have to manually combine the archives?
17:05:14 <elliott> dcoutts: ok, I opened an issue. have been unable to get it working, unfortunately
17:12:03 <frerich> ciaranm, Ralith : In principle, my game structure is as in http://hpaste.org/89842 -- this is just a silly number guessing game. The point is that there's some UI-agnostic part, the "engine" and then there's the UI on top of that (in this case a simple text mode interface). Note how 'runGame' runs the show. It by itself has no dependency on IO or any other monad, but I'd like the 'getMove' function it's given to do IO if needed.
17:12:35 <frerich> ciaranm, Ralith : I thought it might be a good idea to not explicitly write '(Game -> IO Move)' so that I *could* write unit tests in pure code, without any IO involved.
17:12:47 <frerich> …and to express that in principle the enginee itself has no IO dependency.
17:13:36 <frerich> So my questions are: a) does this 'Use 'Monad m' instead of hardcoding IO' idea make any sense and b) are there maybe even nicer ways to write programs like this little game, which have a single function running the show and then that function uses callbacks specified by the programmer to fetch data.
17:14:09 <slack1256> Is there any way (now) to calculate reverse dependencies of a package?
17:14:40 <ion> http://packdeps.haskellers.com/reverse
17:14:57 <byorgey> @where revdeps
17:14:58 <lambdabot> http://packdeps.haskellers.com/reverse
17:15:28 <slack1256> Cool
17:15:35 <slack1256> thanks byorgey ion.
17:16:59 <luminous> hello! anyone know of a double-lock encrypted vault, similar to crypton.io, but more like an API/service and written in haskell?
17:17:07 * luminous is looking for one
17:17:18 <luminous> (or someone interesting in creating one)
17:31:13 <blackdog> so, noticed that MonadCatchIO-transformers won't build with GHC HEAd
17:31:33 <blackdog> because Control.Exception.{block,unblock} are gone - is there a workaround?
17:32:19 <tabemann> blackdog: use mask
17:33:34 <blackdog> tabemann: that would be a fairly sweeping change to MonadCatchIO-transformers, right?
17:33:44 <blackdog> or can you use mask to implement block/unblock directly?
17:34:33 <tabemann> you can't directly *implement* them with it, but it can be used to replace them
17:34:53 <tabemann> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html < this explains how to use mask
17:36:01 <tabemann> mask is like block, except for it blocks for only a passed-in function, and it passes that function another function, restore, which may or may not unmask interrupts within the function passed to it depending on the masking depth
17:36:07 <blackdog> tabemann: yeah, it makes sense.
17:36:26 <blackdog> i am indirectly dependent on the package, though, and it looks like it exports the block/unblock stuff
17:36:29 <blackdog> so i might be SOL.
17:36:52 <tabemann> you'll probably need to contact the maintainer for that package
18:04:14 <shachaf> kfish++
18:04:38 <shachaf> I wonder whether I should mention on libraries@ that Semigroup : Monoid = Apply : Applicative...
18:04:44 <shachaf> Probably not.
18:05:16 <Aetherspawn> :t (:)
18:05:16 <lambdabot> a -> [a] -> [a]
18:05:25 <Aetherspawn> :t Apply
18:05:26 <lambdabot> Not in scope: data constructor `Apply'
18:06:54 <Hafydd> sudo shutdown_-h_now
18:07:03 <Hafydd> I'm sorry.
18:11:06 <kfish> shachaf :)
18:40:59 <monochrom> building 32-bit GHC seems to be faster than 64-bit GHC. 32-bit 1 hour, 64-bit 1.5 hours. both linux and "make -j2"
18:43:19 <byorgey> well, considering that it has twice as many bits to generate, I'd say it's faster!
18:44:01 <byorgey> er, too many pronouns.
18:44:14 * hackagebot HLearn-classification 1.0.1 -   http://hackage.haskell.org/package/HLearn-classification-1.0.1 (MikeIzbicki)
18:46:10 <Aetherspawn_> anyone here know much about Cloud Haskell ?
18:48:05 <monochrom> w00t haskell weekly news
18:48:19 <monochrom> um, old quote!
19:11:07 <Hafydd> I was laughing so much at the third quote that I disturbed a neighbour.
19:14:57 <dmwit> What was the third quote?
19:14:58 <dolio> shachaf: I don't think so. Semigroup is a way better name than Apply.
19:17:52 <dolio> @yow
19:17:52 <lambdabot> Pardon me, but do you know what it means to be TRULY ONE with your BOOTH!
19:19:57 <[swift]> will hackage be able to build my package if i invoke git from Setup.hs?
19:20:20 <[swift]> i'm not sure how else to ensure that git submodules are available
19:20:41 <Ralith> you should upload the complete package to hackage
19:20:54 <Aetherspawn_> @yow
19:20:54 <lambdabot> Maybe we could paint GOLDIE HAWN a rich PRUSSIAN BLUE --
19:20:55 <Ralith> no need for dynamic checks
19:21:09 <Aetherspawn_> @yow
19:21:09 <lambdabot> This PIZZA symbolizes my COMPLETE EMOTIONAL RECOVERY!!
19:23:57 <[swift]> Ralith: so i guess i can figure out how to make sdist bake the submodules into the .tar.gz
19:24:19 <Ralith> that would be an improvement, certainly
19:24:55 <[swift]> along the same lines, can i also get away with building a fairly large C++ project as part of my build process?
19:25:15 <[swift]> i.e., can i could on a C++ compiler being available and hackage not killing the build if it takes 5 minutes?
19:25:36 <[swift]> *count
19:26:24 <Hafydd> sb e
19:26:30 <Hafydd> dmwit: "samlee (via reddit): haha those ghc options are longer than actual program"
19:26:55 <monochrom> haha
19:30:03 <pxqr> why does QSem is deprecated?
19:30:44 <shachaf> dolio: What is the Applicative equivalent of Group?
19:31:19 <pxqr> ah I see.
19:31:36 <pxqr> old semaphores are not exception safe.
19:31:43 <geekosaur> yep
19:32:12 * geekosaur was about to say that and point you to the new one
19:32:53 <dolio> shachaf: Don't know.
19:33:10 <pxqr> geekosaur: there are _bunch_ of semaphores!
19:35:27 <enthropy> [swift]: it's not required that your package be able to build on hackage
19:35:43 <[swift]> enthropy: won't the docs not show up if it doesn't, though?
19:35:47 <[swift]> enthropy: that's mainly what i care about
19:36:17 <enthropy> yes docs will be missing, but you could put a link to them somewhere else from the package description
19:36:19 <dolio> I guess it's basically applicative with 'negate :: m a -> m a' that annihilates actions?
19:39:43 <copumpkin> what would support that?
19:40:36 <dolio> Writer with a group.
19:41:01 <copumpkin> lol
19:43:09 <Saizan> the law would be that liftA2 const x (negate x) = x ?
19:43:23 <Saizan> no
19:43:27 <shachaf> Perhaps it is negate :: m a -> m (a^-1)!
19:43:53 <monochrom> The Theory of Groupoid Applicative and Undoable Effects
19:44:05 <Saizan> it should be liftA2 (\_ _ -> ()) x (negate x) = pure ()
19:44:12 <Nisstyre-laptop> monochrom: you forgot the "Grand" part
19:44:22 <copumpkin> Saizan: how about the value?
19:44:25 <dolio> Saizan: Something like that, I guess.
19:44:38 <Fuuzetsu> Is there a dark hackage CSS theme of some sort? I'm tired of getting my eyes blasted at 4am by how white it all is…
19:45:19 <Saizan> copumpkin: that's what i wonder too
19:45:23 <monochrom> * { background: black; foreground: black }
19:46:02 <Nisstyre-laptop> monochrom: wouldn't that make it unreadable?
19:46:22 <monochrom> haddock into darkness
19:46:23 <elliott> Saizan: liftA2 f x (negate x) = f 0 0, clearly.
19:46:52 <copumpkin> pure foo
19:47:32 <monochrom> w00t hpaste is back
19:55:46 <augur> copumpkin: you're pure foo :|
19:55:52 <Aetherspawn_> :t length
19:55:53 <lambdabot> [a] -> Int
19:56:01 <Aetherspawn_> :t (length :: Integer)
19:56:05 <lambdabot>     Couldn't match expected type `Integer'
19:56:05 <lambdabot>                 with actual type `[a0] -> Int'
19:56:05 <lambdabot>     In the expression: (length :: Integer)
19:56:31 <geekosaur> length isn't polymorphic in its return type
19:56:35 <geekosaur> :t genericLength
19:56:36 <lambdabot> Num i => [b] -> i
19:56:58 <monochrom> the fabled grad student who learned a great deal of category theory to only write a program with no effects can be said to have great pure-fu
19:57:01 <geekosaur> also you'd want to specify the type as (length :: [a] -> Integer) or something
19:57:06 <Aetherspawn_> > genericLength [1..((maxBound :: Int) + 5)]
19:57:07 <lambdabot>   0
19:57:08 <geekosaur> it's a function
19:57:44 <Aetherspawn_> > (genericLength :: [a] -> Integer) [1..((maxBound :: Int) + 5)]
19:57:45 <lambdabot>   0
19:57:58 <geekosaur> not gonna work
19:58:11 <geekosaur> > (maxBound :: Int) + 5
19:58:12 <lambdabot>   -2147483644
19:58:15 <monochrom> to me, it works perfectly
19:58:25 <Aetherspawn_> I'm confused.
19:58:25 <carlo5m> What type would haskell assume it is for: let x = 3.0 * 5? A double?
19:58:27 <geekosaur> think about it
19:58:38 <geekosaur> :t let x = 3.0 * 5 in x
19:58:39 <lambdabot> Fractional a => a
19:58:43 <shachaf> carlo5m: That would be the default default.
19:58:45 <monochrom> defaults to Double
19:58:48 <geekosaur> with defaulting, it should become Double
19:58:57 <carlo5m> thanks
19:58:57 <shachaf> (You can change defaulting behavior so it'll be something else by default.)
19:59:29 <Aetherspawn_> > tail [1..((maxBound :: Int) + 5)]
19:59:30 <lambdabot>   *Exception: Prelude.tail: empty list
19:59:31 <geekosaur> Aetherspawn_, the problem is that, by definition, you can't sensibly add anything to maxBound
19:59:48 <carlo5m> what is the default for Let x = “hurray”? Char or string?
19:59:50 <Aetherspawn_> > (genericLength :: [a] -> Integer) [1..99999999999]
19:59:52 <lambdabot>   *Exception: stack overflow
19:59:57 <Aetherspawn_> sigh. lol.
19:59:57 <geekosaur> because it's still type Int
20:00:06 <monochrom> "hurray?" is String
20:00:14 <carlo5m> k
20:00:21 <applicativ> carlo5m: it couldn't be a Char
20:00:30 <monochrom> double-quote is String. not going to be Char
20:00:32 <carlo5m> 'h' // sould be char
20:00:34 <carlo5m> would*
20:00:37 <monochrom> yes
20:00:45 <applicativ> the question of a default would only arise if you have -XOverloadedStrings on
20:00:49 <geekosaur> > genericLength [1..fromIntegral (maxBound :: Int) + 5::Integer]
20:00:50 <lambdabot>   *Exception: stack overflow
20:01:00 <geekosaur> and yes, it's kinda hard to do that right
20:01:04 <monochrom> instance IsString Char where ...
20:01:15 <monochrom> perl people may love that
20:01:23 <geekosaur> speak for yourself :p
20:01:31 <Aetherspawn_> > len [1..99999999999] where len :: Integer; len = genericLength
20:01:32 <lambdabot>   <hint>:1:22: parse error on input `where'
20:01:40 <Aetherspawn_> > len [1..99999999999] where {len :: Integer; len = genericLength}
20:01:41 <lambdabot>   <hint>:1:22: parse error on input `where'
20:01:47 <geekosaur> where is not expression syntax
20:01:52 <geekosaur> it's declaration syntax
20:01:53 <monochrom> don't they love writing "x" for both string and char?
20:01:54 <applicativ> fromString [] = '\DEL'; fromString (x:xs) = x
20:02:08 <applicativ> fromString [] = '\BEL'; fromString (x:xs) = x
20:02:26 <geekosaur> when I write Perl, I write Perl. Perl doesn't even distinguish numbers from strings, much less strings from characters....
20:02:51 <monochrom> they may love OverloadedEverything
20:02:51 <applicativ> everything is a string
20:07:10 * tabemann is trying to wrap his brain around Agda, and just realized that what he was wanting for "having vectors/matrices having sizes as parts of their type" is precisely an example of a dependent type
20:07:47 <shachaf> It's an example of a thing you can do with dependent types. You can also do (some forms of) it without dependent types.
20:10:00 <[swift]> do dependent types allow you to make all tuples an instance of a typeclass?
20:10:24 <[swift]> it bums me out that you can't do that in haskell
20:10:26 * tabemann swears he's seen someone try to essentially implement a dependent type, using type families and types without constructors (as well as a Nat type implemented with Zero and Succ) in Haskell
20:11:23 <shachaf> By "dependent" do you mean "not actually dependent"?
20:11:24 <dolio> All tuples an instance of what type class?
20:11:28 <tabemann> https://github.com/yairchu/red-black-tree/blob/master/RedBlackTree.hs#L27 < it really looks like they're doing dependent types in Haskell here
20:11:29 <mapreduce> I'm looking forward to finding out how to make a compile-time checked balanced binary tree.
20:11:34 <mapreduce> using dependent types
20:12:38 <[swift]> dolio: any typeclass. i frequently see libraries making tuples an instance of some typeclass they define, and they define it up to N-tuples for some reasonably high N, but there's no way to define it for all N afaik
20:12:48 <shachaf> mapreduce: I'd suggest looking backward at the link just posted, instead!
20:13:00 <[swift]> dolio: for one concrete example, i believe Serialize in cereal does this
20:13:10 <dolio> Well, that's more because tuples in Haskell are an infinity (or, 60-something) of auto-generated, different types.
20:13:24 <tabemann> yeah, that's not a dependent type
20:13:56 <dolio> You could define them more uniformly, but the obvious way to do that is slower.
20:14:02 <shachaf> 60-something is pretty much infinity.
20:14:36 <[swift]> dolio: do dependent types help define them uniformly without a runtime cost? or are they just not applicable to this problem?
20:14:41 <kennyd> why is there a limit? whether it's 60 or some other number
20:14:53 <dolio> They don't have anything to do with this problem.
20:15:02 <copumpkin> > count
20:15:05 <lambdabot>   ["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17...
20:15:07 <copumpkin> hmm
20:15:14 <copumpkin> > last count
20:15:17 <lambdabot>   "\226\136\158"
20:15:58 <dolio> kennyd: GHC freaks out at some large number. I don't really remember why.
20:16:10 <[swift]> i see. it'd be really nice if there were a clean solution to this problem. (ironically there is in C++ of all languages. though i suppose i wouldn't call template metaprogramming clean)
20:16:16 <dolio> 60 is already way beyond the point at which you should be using tuples.
20:16:39 <tabemann> one part about dependent types is that the /indices/ for them, like for a vector type, can be logically acted upon by code, in pattern matching and like, in a way that is checkable at compile-time
20:16:54 <tabemann> logically acted upon at compile type*
20:17:09 <carter_> johnw i see you're hosting stuff via dropbox
20:17:18 <kennyd> dolio yeah, it's not a practical issue I was just curious
20:17:43 <[swift]> to me the problem is less about the limit and more about the inelegance of defining 60 instances for your typeclasses
20:17:57 <tabemann> it's not just having an infinite number of sized vector types, e.g., but ones where you can, say, make a function that appends two vectors into a new vector, and has the sizes of all the vectors checked as part of type-checking
20:34:09 <hrookie> anybody have experience with the following in cabal? "dist/setup-config5813.tmp: resource busy"
20:35:32 <geekosaur> hrookie, that usually means someting is trying to modify it while it's running (or, on Windows, open in another process)
20:36:30 <hrookie> geekosaur: thanks! i am (for the first time ever) sharing some stuff across linux and windows right now. i bet that is the culprit >.<
20:36:47 <geekosaur> it will certainly complicate matters
20:37:04 <hrookie> yeah. i mean, it makes sense for a lot of things. for this? probably not =D
20:37:31 <hrookie> whatever, i'll just github it and keep it exclusive to one side
20:41:56 <Sixmsj> hi, im going through lyah right now and came across this error, not sure what's wrong with it http://pastebin.com/FWcEvyif
20:42:01 <mauke> The paste FWcEvyif has been copied to http://hpaste.org/89844
20:42:23 <Sixmsj> error is parse error on input `normal'
20:42:30 <Sixmsj> skinny*
20:46:48 <tabemann> hmm... looking at it, same error
20:48:17 <tabemann> figured it out
20:48:48 <tabemann> after the "where", "skinny" and the things below it should be indented to match the "bmi" right after the where
20:49:11 <tabemann> as because something comes right after the where on the same line, it defines where things after it should be indented to
20:49:51 <Sixmsj> ah i just noticed, in the example, the indentation is the same
20:50:04 <Sixmsj> is there a standard practice on indent level?
20:50:33 <Sixmsj> putting the skinny,etc underneath bmi would put it at 10 spaces
20:50:33 <tabemann> I generally just go by whatever Haskell mode in GNU EMACS does, with a few exceptions
20:50:58 <tabemann> there is generally no single indent that is used, but rather it depends on circumstances
20:51:21 <tabemann> for instance, when putting something under something else where I am not lining it up with anything, I generally indent two spaces (never tabs)
20:52:01 <tabemann> however, after something like a let or a where clause, and something is on the same line after the let or the where, following lines in the clause are lined up with what comes after the let or where
20:53:25 <Sixmsj> tabemann, thanks, i just realized emacs automatically puts the cursor at the right spot when going to a new line whereas vim does the regular indent level
20:56:33 <adnap> What is the term for a value of type "(forall t. C t => T t a)"?
21:00:12 <copumpkin> adnap: you've been henning'd
21:01:47 <Saizan> adnap: t, i'd say
21:02:06 <Saizan> e, if you want an expression
21:02:20 <adnap> Uh, okay
21:02:24 <adnap> I don't understand
21:02:38 <adnap> Anyhow, is it possible to interpret a value of this type?
21:02:46 <Saizan> we're joking, sorry
21:02:57 <mgsloan> adnap: "term" is another term for expression :)
21:03:33 <Saizan> adnap: what are you asking exactly? without the definitions of C and T it's hard to tell
21:04:21 * hackagebot HLearn-classification 1.0.1.1 -   http://hackage.haskell.org/package/HLearn-classification-1.0.1.1 (MikeIzbicki)
21:04:33 <adnap> e.g. http://hpaste.org/89845
21:06:09 <Saizan> ah, i see
21:06:25 <adnap> And f must have the type it has
21:06:37 <Saizan> well, something of type (forall t. C t => T t a) must be polymorphic in t
21:08:07 <Saizan> while the result of "runInterpreter i" is only going to be usable for a single fixed t
21:08:07 <adnap> Yeah, so, is it impossible to interpet something like that?
21:08:39 <Saizan> i think you need a newtype wrapper, because (forall t. C t => T t a) is not an instance of Typeable
21:09:05 <Saizan> but if you do "newtype Foo a = Foo (forall t. C t => T t a)"
21:09:30 <Saizan> and unwrap it after interpreting it should work
21:10:03 <Saizan> or just make f take the wrapped version
21:10:13 <adnap> Hm, I will try that...
21:11:45 <DiegoNolan> is there a way to do this without the lambda?
21:11:55 <DiegoNolan> (\n -> not $ flip elem [1,2,3] n)
21:12:22 <shachaf> not . (`elem` [1,2,3])
21:12:28 <DiegoNolan> son of a
21:12:29 <shachaf> Or: (`notElem` [1,2,3])
21:12:44 <Saizan> with is the same as "not . flip elem [1,2,3]" btw
21:12:49 <shachaf> Sure.
21:12:59 <shachaf> My advice: Don't use flip. flip makes for unreadable code (sections don't, necessarily).
21:13:16 <shachaf> If you feel like the only thing you can do without a lambda is use flip, just use a lambda. Lambdas are not the devil.
21:14:02 <DiegoNolan> you're telling me (flip (flip (flip (flip (+))))) 3 2 isn't good code?
21:14:10 <blackdog> flipping hell
21:15:51 <arkeet> > (flip (flip (flip (flip (+))))) x y
21:15:52 <lambdabot>   x + y
21:15:56 <arkeet> right.
21:15:59 <arkeet> flip.flip = id
21:16:02 <DiegoNolan> yeah it was a joke
21:16:13 <DiegoNolan> i'm not that bad, i don't think
21:16:39 <shachaf> > flip flip 5 (+) 3
21:16:41 <lambdabot>   8
21:16:42 <shachaf> Infix without infix!
21:17:02 <shachaf> @let hi = flip flip
21:17:04 <lambdabot>  Defined.
21:17:21 <shachaf> > hi 5 (+) (hi 3 (*) 8)
21:17:25 <lambdabot>   29
21:17:53 <DiegoNolan> what have i started
21:18:04 <adnap> Whoa
21:18:58 <adnap> > flip flip (+2) (<$>) Just 40
21:18:59 <lambdabot>   Just 42
21:28:21 <trace30m> for which purposes is haskell for ?
21:28:43 <tabemann> haskell is a general-purpose programming language
21:29:53 <applicativ> > 1 + 1
21:29:54 <lambdabot>   2
21:30:01 <applicativ> it's very good with arithmetic, for starters
21:30:23 <Cale> trace30m: What's any programming language for?
21:30:28 <Clint> programming
21:30:51 <trace30m> php is for web
21:31:01 <Clint> php is for security hole
21:31:07 <studybot_> haskell is for fun
21:31:07 <XexonixXexillion> well, it's not that stupid of a question. I mean I wouldn't recommend COBOL for general programming
21:31:08 <trace30m> ^^
21:31:31 <applicativ> hey, we have a php *compiler* in haskell; just think of the uses!
21:31:46 <Cale> trace30m: Well, Haskell is general purpose, you can do most things with it.
21:32:31 <DiegoNolan> It's sole purpose is for this: (flip (flip (flip (flip (+))))) 3 2
21:32:56 <tabemann> and if one thinks it can't do something because it doesn't have APIs for it, one can easily write bindings for whatever one feels like in it
21:33:34 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html -- you might like to have a look through this package repository to get some idea
21:33:44 <trace30m> ahm I would say for paralellism Haskell is good
21:34:05 <tabemann> Haskell is good for programming, to put it simply
21:35:06 <tabemann> it does have some neat things which are not as feasible elsewhere, such as lazy evaluation, pure functions, and some more specific capabilities like STM (yes, there exist STM libraries elsewhere, but Haskell is particularly well-suited to it)
21:35:26 <applicativ> > (((((+) ??) ??) ??) ??) 3 2
21:35:27 <lambdabot>   Not in scope: `??'Not in scope: `??'Not in scope: `??'Not in scope: `??'
21:35:30 <applicativ> bah
21:35:47 <Cale> There are really few things which Haskell is actually all that bad at. Programming machines which have very small amounts of memory would be tricky to do directly in Haskell (but there are Haskell libraries which are designed to help with that, like atom)
21:35:55 <applicativ> haskell is beautiful
21:36:41 <trace30m> STM is cool
21:36:52 <tabemann> the only things I can really think of that haskell would be bad at are hard realtime and very small embedded systems
21:36:53 <Cale> For certain kinds of applications, you might not just be able to pull something off the shelf. There's no equivalent of the Source engine written in Haskell yet, for instance.
21:36:58 <applicativ> we get away with murder; we write what we mean in a beautiful symbolism, and the compiler somehow makes it inexplicably fast
21:37:17 <lispy> Cale: and Ivory https://github.com/GaloisInc/ivory
21:37:31 <Cale> Indeed
21:37:38 <applicativ> ivory?
21:37:43 <Cale> tabemann: yeah, and for those kinds of systems, you can use it really effectively as a metalanguage
21:38:34 <applicativ> trace30m: what sort of thing are you interested in?
21:39:04 <Cale> heh, github's Haskell source code highlighter apparently isn't aware of template haskell
21:39:15 <trace30m> regarding to haskell , how to make parallel programs
21:39:15 <applicativ> neither is my editor's
21:39:28 <trace30m> applicativ: ...
21:39:40 <applicativ> oh have you seen the manuscript of simon m.'s OReilly book
21:39:51 <blackdog> trace30m: just checking - do you mean parallel, or concurrent?
21:40:07 <applicativ> http://ofps.oreilly.com/titles/9781449335946/part_parallel.html trace30m
21:40:12 <trace30m> blackdog: I  guess concurrent
21:40:12 <lispy> Cale: yeah, pygments probably doesn't know about fancy GHC-isms
21:40:13 <blackdog> (ie, scientific calcs vs webservers)
21:40:51 <applicativ> trace30m: the examples for marlows book are here https://github.com/simonmar/parconc-examples
21:40:59 <tabemann> http://ofps.oreilly.com/titles/9781449335946/part_concurrent.html
21:41:03 <Cale> lispy: yeah, https://github.com/GaloisInc/ivory/blob/master/ivory-examples/examples/PID.hs -- that's one hell of a character literal ;)
21:41:42 <lispy> Cale: hehe
21:42:40 <applicativ> trace30m: the book, which is incomplete of course, presupposes you know haskell but not all that much; he steers clear of some of our preferred forms of obscurity.  people here can explain curiosities.
21:43:53 <trace30m> one of my exams is language concepts of concurrent ...
21:44:03 <trace30m> should i buy this book?
21:45:15 <trace30m> my professor is a Fan of Haskell
21:45:53 <applicativ> it's not finished, you're supposed to comment on the online version.
21:45:55 <tabemann> that's cool - when I was in school, I had to deal with Java, C, and MIPS assembly; had no fun languages there
21:46:55 <trace30m> ahh
21:47:05 <applicativ> i like the idea of a form of scientific training oriented around learning Java and C
21:47:23 * applicativ invents php science
21:50:01 <applicativ> where are you studying, trace30m ?
21:50:32 <trace30m> htwk leipzig (a university of applied sciences)
21:51:08 <trace30m> in east germany
21:51:48 <applicativ> yes a magnificent city
21:52:31 <trace30m> 3,5 years ago I could have learned functional programming in a elective subject
21:52:59 <trace30m> now I have to lern haskell in a subject in which I need it
21:53:08 <trace30m> Leipzig  is ok
21:53:11 <applicativ> in any event, there is a standard tutorial people praise, 'learn you a haskell' online; i think it contains enough to make marlow's manuscript intelligible
21:53:30 <tabemann> @where lyah
21:53:30 <lambdabot> http://www.learnyouahaskell.com/
21:53:45 <trace30m> I have read most of it
21:54:04 <applicativ> has the class assigned some work related to haskell?
21:54:39 <trace30m> what kind of work
21:55:17 <trace30m> ahm we should have had translated a concurrent mergesort from haskell to go
21:55:29 <NemesisD> where does one announce update releases to hackage? i thought it was the haskell mailing list but i haven't seen any package release announcements, just big, more important stuff
21:55:52 <pxqr> trace30m: heh
21:55:56 <NemesisD> seems poorly scoped for haskell reddit as well
21:57:41 <elliott> i think people do announcements on -cafe often
21:57:44 <elliott> and /r/haskell too
21:58:22 <trace30m> because comanies dont use functional programs, there must be special use for functional programming language, and I know its good for programming an AI and concurrent programs
21:58:46 <NemesisD> /r/haskell seems somewhat hostile to it unless the library is really interesting
21:59:06 <NemesisD> kind of afraid to subscribe to the firehose that is cafe
21:59:17 <NemesisD> but i suppose i can filter it
22:00:17 <trace30m> does someone knows about Homomorphism in concurrent programs?
22:01:04 <johnw> trace30m: can you rephrase that as a more specific question?
22:01:18 <trace30m> ^^ sry
22:01:26 <frerich> johnw: Thanks a lot for making those ghc builds available, much appreciated!
22:02:04 <trace30m> I would like to know which functions can used as a homomorphism ... not in general, but examples like (nat,+,0)
22:02:14 <johnw> frerich: sure thing!  It never occurred to me that others would want access to it actually
22:03:14 <johnw> trace30m: (nat,+,0) is not a function
22:03:20 <johnw> trace30m: I'm not sure what you're asking
22:03:22 <trace30m> its a monid
22:03:25 <trace30m> monoid
22:03:31 <applicativ> yipe https://code.google.com/p/simdoop/ "This homomorphism-based framework provides higher level programming interfaces ..."
22:03:34 <johnw> yes, so what do monoid homomorphisms have to do with concurrency?
22:03:58 <trace30m> operations like 1+1 can be made concurrent
22:04:09 <johnw> i think you mean parallel
22:04:27 <trace30m> as well as functions
22:04:34 <trace30m> ok
22:05:01 <trace30m> because "+" can be understood as a function
22:05:11 <johnw> it definitely is a function
22:06:46 <trace30m> haskell foldr and foldl can be done so it can be made parallel
22:07:01 <johnw> so what is the question?
22:07:11 <trace30m> I search for examples
22:07:18 <trace30m> monoids
22:07:51 <adnap> How do I write a stand-alone deriving instance of Typeable for data Foo a = Foo a?
22:09:25 <adnap> Nevermind. I got it
22:09:32 <adnap> "deriving instance Typeable 1 F"
22:09:41 <adnap> *"deriving instance Typeable1 F"
22:14:24 * hackagebot angel 0.4.1 - Process management and supervision daemon  http://hackage.haskell.org/package/angel-0.4.1 (MichaelXavier)
22:17:14 <adnap> Saizan: Cool! It worked.
22:19:25 * hackagebot angel 0.4.2 - Process management and supervision daemon  http://hackage.haskell.org/package/angel-0.4.2 (MichaelXavier)
22:25:46 <trace30m> is it possible to use different datastructures for lists?
22:25:55 <trace30m> like b-trees?
22:28:20 <johnw> trace30m: these aren't really Haskell questions, trace30m.  You may want to just do some googling rather than ask here
22:29:10 <trace30m> I mean [...] is Haskell Syntax
22:29:58 <trace30m> mhh maybe "[]" is done by a libraray
22:30:46 <mgsloan> trace30m: It's not.  OverloadedLists has been suggested for allowing list syntax to create other datatypes
22:31:51 <trace30m> so this haskell lists "[...]" can not have differnt types ....
22:32:07 <mgsloan> trace30m: Actually, nevermind, the HEAD version of GHC does have this extension
22:32:20 <shachaf> HEAD is getting OverloadedLists? :-(
22:32:41 <mgsloan> shachaf: I'm not sure http://www.reddit.com/r/haskell/comments/18ncub/ghc_head_now_has_overloadedlists_as_an_extension/
22:33:13 <shachaf> This is going to be horribly abused by certain people.
22:33:26 * shachaf may just be a pessimist.
22:33:31 <johnw> maybe just a little
22:33:32 <mgsloan> well, at least it's an extension
22:33:55 <shachaf> johnw: I'm not actually a pessimist, you know.
22:33:58 <shachaf> I just have good taste.
22:34:35 <mgsloan> shachaf: You don't like the idea of using [] to build HLists? ;)
22:35:00 <shachaf> mgsloan: Will it work?
22:35:08 <shachaf> (By the way, the last thing I said was a joke. In case that wasn't clear.)
22:35:37 <mgsloan> shachaf: Only if you change the meaning of (:)
22:36:20 <shachaf> It looks like you do it using fromList, which means you can't do any better type-wise than a list can.
22:36:32 <shachaf> Which is a shame. That would be the main advantage of this extension.
22:37:07 <johnw> i think it's just a little bit of sugar, so that you don't always have to use fromList, in the same way that OverloadedStrings saves you from always using pack or unpack
22:37:25 <applicativ> type-wise?
22:37:40 <shachaf> Yes, and then it gets an instance like fromList = Data.ByteString.Char8.pack
22:38:08 <applicativ> no 'enumFromWhatever' is needed?
22:38:37 <kvda> I have a list [("key1", "val1), ("key2", "val2")], what would be the best way of accessing the values by key? Is it possible to convert it a data type?
22:38:51 <applicativ> oh ick, you use list enumFromTo and then fromList ...
22:39:06 <shachaf> kvda: You can use Data.Map to get an efficient lookup data structure.
22:39:15 <shachaf> Or you can look it up in the list directly (linearly) with Data.List.lookup.
22:39:20 <mgsloan> Ah, yeah, looks like OverloadedLists doesn't allow you to overload cons.  tubad! :(
22:39:53 <mgsloan> The comment on the wiki post is puzzling - "This is a bit disappointing. However, I'm not really sure how you could make this extension support this use case, even if you added some hacks to the IsList class."
22:40:05 <johnw> if the key is hashable (like, a string), is HashMap significantly faster?
22:40:16 <shachaf> Maybe.
22:40:34 <shachaf> In some cases it is better, and in some cases it's not.
22:40:37 <applicativ> kvda: all of these libraries have something like fromAscList :: Eq k => [(k, a)] -> Map k a
22:40:44 <mgsloan> I'm not sure why this wouldn't be resolved by exporting a function for cons from the prelude.  Kinda evil, I suppose
22:40:52 <shachaf> fromAscList is an experts-only function.
22:40:56 <shachaf> fromList should be your default.
22:41:22 <applicativ> hey, i'm an expert um um
22:41:26 <applicativ> something
22:41:42 <kvda> thanks shachaf, applicativ. I'm looking up these modules now
22:42:08 <applicativ> they all have fromList and toList or whatever; of course you should probably be building without the intervention of a list.
22:43:26 <kvda> so lookup seems to be in Prelude
22:44:25 <kvda> Data.List doesn't have fromList
22:45:18 <kvda> all functions in Data.Map are depreceated
22:45:29 <kvda> ah Data.Map.Strict
22:45:41 <applicativ> kvda: no, all the other modules have their own fromList's
22:46:26 <applicativ> lookup in the prelude uses [(1,"hello"), (2,"goodbye")] -- the sort of thing you started with, which isn't ideal for many things
22:47:11 <applicativ> @type lookup
22:47:13 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
22:47:29 <applicativ> Data.Map.lookup :: Ord k => k -> Map k a -> Maybe a
22:49:12 <applicativ> "A HashMap is often faster than other tree-based set types, especially when key comparison is expensive, as in the case of strings."
22:49:49 <applicativ> kvda: this has the same interface I think as Data.Map http://hackage.haskell.org/packages/archive/unordered-containers/0.2.3.1/doc/html/Data-HashMap-Strict.html
22:50:40 <kvda> ah thanks applicativ , this is looking good
23:04:27 <kvda> applicativ, works nicely -__- thanks again
23:05:31 <NemesisD> quit
23:12:01 <hrookie> Anyone have experience with the GLUT library? I've got a long problem description but the fix probably isn't too bad
23:12:19 <hrookie> I want to add a workaround for an issue with the VirtualBox guest extensions
23:13:11 <hrookie> in C and C++ OpenGL + GLUT code, it's a matter of a single if statement, but I'm having issues tracking down the corresponding way to do it in the haskell GLUT bindings
23:34:28 * hackagebot xing-api 0.1.3 - Wrapper for the XING API, v1.  http://hackage.haskell.org/package/xing-api-0.1.3 (JanAhrens)
