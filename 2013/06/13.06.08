00:00:58 <DarkFox> I just found what I find to be a bug in Data.List -> all _ []        =  True  --  all (=="test") [], none equal "test"
00:01:03 <fractalsea> Possibly, but it's not me doing the work, it's the library
00:01:12 <DarkFox> Should I report this ?
00:01:45 <fractalsea> Just one function call for me rather than building a parser and the data types that go along with it
00:02:32 <Ghoul_> F# is so shit compared to Haskell
00:02:39 <shachaf> DarkFox: No. It's not a bug.
00:03:00 <shachaf> Ghoul_: Please keep language bashing somewhere else. Thanks. :-)
00:03:01 <DarkFox> shachaf: None match the expression
00:03:13 <Ghoul_> Lolk
00:03:23 <shachaf> And?
00:03:35 <DarkFox> shachaf: The function is for all :P not none.
00:03:43 <Mortomes> All elements in the list match the expression
00:03:47 <Mortomes> All 0 of them
00:03:53 <DarkFox> But again whoever is dealing with runnning all should check that it's not empty themselves
00:03:58 <elliott> DarkFox: it is an accepted principle of logic that all predicates hold of elements of the empty set
00:04:02 <shachaf> ##logic might be a better place for this particular question...
00:04:18 <elliott> DarkFox: see http://en.wikipedia.org/wiki/Vacuous_truth
00:04:55 <nan`> lol
00:05:26 <nan`> yes report the bug in #logic
00:05:44 * DarkFox goes back to his exploitation framework in javascript (for pentesting obviously)
00:05:49 <Mortomes> File a bug report to God.
00:06:39 <DarkFox> Bug in physics -> report to who?
00:07:08 <Heffalump> darkfox: I think Jesus handles the implementation details
00:07:33 <DarkFox> Heffalump: age jesus < age physics
00:08:20 * DarkFox goes with Mortomes 's answer
00:24:21 <nejucomo> Is there no equivalent of join for Applicative precisely because it lacks the "bind-iness" of Monad?
00:25:48 <johnw> if you had join, you'd have a monad
00:25:50 <elliott> nejucomo: it's more like there's no equivalent of (>>=) precisely because it lacks the join-iness :P
00:27:36 <nejucomo> hehe…  Ok.  I see.
00:28:03 <fractalsea> I tried to run: do result <- runInterpreter (setImports ["Prelude"] >> eval eqString); case result of Left err -> 0; Right v -> v but I'm getting a bunch of error starting with: No instance for (Control.Monad.CatchIO.MonadCatchIO []) arising from a use of `runInterpreter'
00:28:17 <fractalsea> Does anyone know why that is?
00:28:40 <johnw> i think you need return $ case ...
00:38:08 <fractalsea> ah thanks, will give that a go
00:38:22 <johnw> do you see why it's needed?
00:38:37 <zRecursive> fractalsea: i never run XMonad.Actions.Eval successfully :(
00:39:12 <fractalsea> Not right away, I need to understand return and case more. I assumed that it would automatically return what is to the right of ->
00:39:38 <johnw> by using do, you are in a monad
00:39:49 <zRecursive> hint is hard to use
00:40:03 <johnw> your case is not using return, which cases type inference to think that the monad involved is determined by the type of "v" (presumably, a list)
00:40:42 <johnw> therefore, it thinks runInterpreter or eval returns a list (not sure exactly which)
00:40:49 <johnw> well, one of those has a MonadCatchIO constraint
00:40:54 <johnw> and so you come to your error
00:41:37 <johnw> by using return $ case, you are returning v "in the monad", and so the type of monad being used will be determined by the type of runInterpreter and eval, and not v
00:42:09 <johnw> this exact same kind of error can happen if you use "x <- foo" when you meant to say "let x = foo", you will get used to it
00:42:26 <Ghoul_> Hmm
00:42:33 <Ghoul_> I had an idea, but I can't make it work
00:42:38 <zRecursive> johnw: you make it clear, thx
00:42:44 <Ghoul_> Consider: [x | x <- getLine]
00:43:16 <Ghoul_> I know getLine isn't a list. That's what is tripping me up. Is this comprehension how I /mean/ it to work possible?
00:43:26 <johnw> Ghoul_: you need to enable MonadComprehensions
00:44:11 <johnw> then it will work, but it will only call getLine once
00:44:21 <Ghoul_> Couldn't match expected type `[t0]' with actual type `IO String'
00:44:21 <Ghoul_> In a stmt of a monad comprehension: x <- getLine -- ideas?
00:44:43 <johnw> in what context are you evaluating this thing?
00:44:53 <johnw> you can try: do y <- [x| x <-getLine]
00:45:00 <johnw> and then, print y
00:45:05 <Ghoul_> m <- fromJust $ find (\b -> (fromJust b) == "end") [x | x <- getLine]
00:45:18 <Ghoul_> lol just "playing"
00:45:18 <johnw> ah, yes, a monad comprehension is not a list
00:45:21 <johnw> unless you are using the list monad
00:45:34 <johnw> [ x | x <- getLine ] == getLine
00:45:41 <Ghoul_> aw
00:46:01 <Ghoul_> :t replicate getLine
00:46:03 <lambdabot>     Couldn't match expected type `Int' with actual type `IO String'
00:46:03 <lambdabot>     In the first argument of `replicate', namely `getLine'
00:46:03 <lambdabot>     In the expression: replicate getLine
00:46:14 <johnw> you would need replicateM
00:46:14 <Ghoul_> :t repeat getLine
00:46:16 <lambdabot> [IO String]
00:46:25 <Ghoul_> is repeat fine?
00:46:26 <johnw> sequence $ repeat getLine :)
00:46:46 <johnw> but that will never return a value
00:47:27 <Ghoul_> :t find
00:47:28 <lambdabot> (a -> Bool) -> [a] -> Maybe a
00:47:30 <wattaman> hi, why product [ ]  returns 1?
00:47:35 <johnw> Ghoul_: what are you wanting to do?
00:47:48 <Ghoul_> take in lines until the user enters "end"
00:48:13 <Ghoul_> prefferably using a lazy list bound to getLine so I can experiment with how monads in lists work
00:48:19 <Ghoul_> err, IO.
00:48:51 <mikeplus64> are there generalisations of scanr/scanl like foldr/foldl?
00:48:57 <Mortomes> wattaman: Because 1 is the identity element for multiplication
00:49:02 <mikeplus64> i mean, like there is Foldable, is there Scanable, or something
00:49:15 <mikeplus64> or should you just make scanr/scanl from folds
00:49:16 <johnw> Ghoul_: you can achieve that pretty easily with a recursive function
00:49:35 <Ghoul_> I know, but it's less cool :\
00:49:46 <johnw> fix $ \loop -> do x <- getLine; print x; if x == "end" then return () else loop
00:50:05 <Ghoul_> :t fix
00:50:07 <lambdabot> (a -> a) -> a
00:50:17 <mikeplus64> wattaman: what should it return?
00:50:20 <johnw> or if you want even more baroque: flip runContT return $ callCC $ \exit -> forever $ do x < - getLine; when (x == "end") (exit ())
00:50:23 <fractalsea> thanks for the explaination johnw
00:50:25 <mikeplus64> @src product
00:50:25 <lambdabot> product = foldl (*) 1
00:50:30 <wattaman> i don't understand logic beyond this, why product of empty list returns a value?
00:50:55 <Ghoul_> ContT ooks interesting
00:50:57 <johnw> @src product
00:50:58 <lambdabot> product = foldl (*) 1
00:51:01 <johnw> that's why
00:51:35 <johnw> ah, didn't see mikeplus64 had done that
00:51:41 <rofer> Question: If I did something like "let letters = ['a'..'z'] ++ ['A'..'Z']" and then only accessed the first couple indices would the second bit never be evaluated?
00:51:50 <johnw> correct
00:52:18 <johnw> fractalsea: anytimE!
00:52:25 <rofer> cool
00:53:53 <wattaman> i know that 1 is initial value of accumulator, but why return anything when list is empty? I expected something like nil/null or similar
00:54:09 <johnw> foldl f z xs returns z if xs is []
00:54:15 <johnw> otherwise, what would it return?
00:54:33 <johnw> in order for it to return something equivalent to nil/null, the return type would have to be Maybe
00:54:39 <johnw> Maybe a
00:54:42 <wattaman> not a number
00:54:52 <johnw> that wouldn't type check
00:55:06 <johnw> a fold using a binary operator that returns a number must itself return a number
00:55:20 <johnw> even if that binary operator is never evaluated
00:55:30 <johnw> :t foldl
00:55:32 <lambdabot> (a -> b -> a) -> a -> [b] -> a
00:55:38 <johnw> the a's must match
00:55:39 <wattaman> so why 1 , not for ex. 666?
00:55:48 <johnw> 1 is the "unit" for multiplication
00:55:57 <wattaman> no
00:56:05 <johnw> 1 * x = x, x * 1 = x
00:56:08 <wattaman> multiplication is chained addition
00:57:42 <arkeet> > foldr (*) 1 [a,b,c]
00:57:43 <lambdabot>   a * (b * (c * 1))
00:57:53 <arkeet> > product [a,b,c]
00:57:54 <lambdabot>   1 * a * b * c
00:58:27 <johnw> if we used 0 instead of 1 there, the answer would always be 0
00:59:23 <johnw> further, what do you think of this: product [] * product [1,2,3]
00:59:34 <johnw> sure that should be equivalent to product [1,2,3]
00:59:46 <johnw> so * distributes over product, but only if it returns 1 for the empty list
01:00:06 <johnw> > product [1,2] * product [3,4]
01:00:07 <lambdabot>   24
01:00:09 <johnw> > product [1,2,3,4]
01:00:10 <lambdabot>   24
01:00:21 <arkeet> product is a ~monoid homomorphism~
01:00:25 <wattaman> a * b = b + ... (a-1)b + (a)b     , where (a + x) is index, there is no 1 here,
01:00:42 <arkeet> what is 2.3 * (-5) then?
01:00:50 <elliott> arkeet: I've never before heard the words "monoid homomorphism" be so sparkly
01:00:53 <johnw> arkeet: from the free monoid to the monoid of multiplication?
01:00:56 <elliott> in fact, I still haven't heard them
01:01:05 <arkeet> johnw: sure.
01:01:15 <johnw> makes sense, I hadn't thought of it that way
01:01:29 <johnw> [] -> Product
01:01:40 <arkeet> in plain language, product (x ++ y) = product x * product y
01:02:01 <johnw> is that anything similar to a Galois connection?
01:02:08 <arkeet> not really
01:02:16 <arkeet> it's just a homomorphism.
01:02:38 <wattaman> 2.3 *  -5 is (2 * 5) * (-1) + (0.3 * 5)(-1)
01:02:52 <arkeet> I should have made -5 a noninteger too.
01:03:31 <wattaman> this is one of those WAT moments in this language
01:03:34 <elliott> arkeet: did you know the law for difference lists is just naturality? this seems so obvious as to be boring but only in retrospect.
01:03:36 <arkeet> but the point is that "multiplication is repeated addition" only makes sense when one of the things is a natural number. to multiply other things you have to generalize that definition.
01:03:49 <johnw> elliott: how do you mean?
01:04:08 <arkeet> well, that point is missing the point about product [] = 1
01:04:24 <arkeet> that's the way it is because you want equations like  product (x ++ y) = product x * product y  to hold
01:04:30 <wattaman> and getting 1 out of nothing
01:04:50 <arkeet> you could have made it what you want, but making it 1 gives you the nicest properties.
01:05:16 <supki> [] is not really "nothing"
01:05:19 <arkeet> you are free to make your own definitions for things. but some definitions are more useful than others.
01:05:29 <elliott> johnw: well, first generalise it to a difference-M for any monoid M. then the law for a difference-M dx :: M -> M is forall y z, dx (y <> z) = dx y <> z. (by the monoid laws, this gives us: forall y, dx y = dx 1 <> y, i.e. dx = (dx 1 <>), hence exists x. dx = (x <>), which is what we want: all difference-Ms to be prefixing)
01:05:57 <elliott> johnw: which is just the naturality law for a natural transformation Hom_C(-,X) -> Hom_C(-,X), where C is the category corresponding to M and X is its sole object.
01:06:08 <johnw> nice!
01:06:11 <johnw> i will have to chew on that
01:06:13 <elliott> and then the Yoneda lemma tells you it's equivalent to the original M.
01:06:25 <johnw> i've been pondering difference monoids and Yoneda all day
01:06:31 <elliott> but in retrospect this is obvious, because saying that f is "the same" as pre-applying composition to f is sort of the point
01:06:41 <johnw> right
01:06:46 <elliott> johnw: er, really? is there something in the water? :P
01:06:59 <johnw> shachaf was talking about it last night or the night before
01:07:00 <wattaman> are there any papers for that?
01:08:01 <johnw> how Yoneda is a functor that wraps a functor such that repeated fmaps on the Yoneda functor result in only a single call to fmap when you "lower".  That parallel the behavior difference lists so closely (except that with difference lists, you're dealing with values instead of functions), so that I was wondering if there is a further generalization which encompasses both Yoneda and any difference monoid
01:09:39 <zRecursive> @ty (&&&)
01:09:40 <arkeet> elliott: cool observation.
01:09:41 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
01:10:27 <johnw> it seemed that the principle behind Yoneda could be expressed as op f . op g -> op (f . g), or distributivity of composition over op (where op is fmap in the specific case of Yoneda); and difference monoids are (x op y) op z -> x op (y op z), or forcing right-association by delaying op
01:10:44 <johnw> Codensity sort of then looking like a melding of the concepts
01:11:58 <johnw> is this heading into the territory of "kan extensions"?
01:12:02 <johnw> (about which I know nothing yet)
01:12:57 <arkeet> I should learn about kan extensions.
01:13:16 <arkeet> I should learn how to go to bed at a reasonable time.
01:13:55 <elliott> arkeet: it came out of realising that f g = fmap g (f id) and dx y = dx mempty <> y look kind of similar. (ok, they were more similar when I got it backwards: dx y = mappend y (dx mempty)). but it took going over it with a friend to realise it was as simple as that.
01:13:59 <Rembane> That's a hard skill to master.
01:14:30 <johnw> elliott: nice formulation!
01:14:38 <johnw> that expressing the connection I was grasping for quite neatly
01:15:30 <johnw> f g = ψ g (f ε)
01:16:03 <johnw> where ψ ε x = x
01:16:46 <johnw> that has the feel of a universal property of some kind...
01:18:32 <joelteon> f g = const g (f ?)
01:18:53 <joelteon> oh
01:18:55 <joelteon> that's id
01:19:37 <johnw> it's like mapping function application into some kind of monoid
01:22:26 <joelteon> :t \f g -> fmap g (f id)
01:22:27 <lambdabot> Functor f => ((a1 -> a1) -> f a) -> (a -> b) -> f b
01:22:43 <shachaf> hi arkeet
01:22:45 <joelteon> yeah, I don't get it
01:22:52 <arkeet> hi shachaf
01:23:34 <johnw> :t \f g -> fmap g f
01:23:35 <lambdabot> Functor f => f a -> (a -> b) -> f b
01:23:53 <arkeet> I don't know what "f" is in f g = fmap g (f id)
01:23:58 <joelteon> me neither
01:23:59 <arkeet> nor what the space after f is
01:24:02 <joelteon> but fmap for (->) is .
01:24:22 <joelteon> f g = f id . g?
01:24:35 <arkeet> I don't think it was meant literally.
01:24:36 <joelteon> but that's left recursive
01:24:39 <joelteon> oh
01:24:55 <shachaf> It was probably meant to be literally equal?
01:25:12 <shachaf> That's what people normally mean when they write =
01:25:17 <joelteon> :t let f g = fmap g (f id) in f
01:25:18 <arkeet> the = is fine.
01:25:18 <lambdabot> Functor f => (a -> a) -> f a
01:25:21 <arkeet> it's the other stuff I'm not sure about.
01:25:22 <joelteon> Oh, I get it
01:25:30 <joelteon> I was making it too complicated
01:25:54 <shachaf> arkeet: Note that I just came here so I'm probably not sure about anything.
01:26:00 <shachaf> This is about Yoneda, right?
01:26:02 <johnw> arkeet: (a -> a) -> f a is just a specialization of forall x. (a -> x) -> f x
01:26:09 <joelteon> mappend y (dx mempty) makes more sense now
01:26:20 <joelteon> it's some kind of derivative-y monoid
01:26:21 <elliott> johnw: the universal property is just the yoneda lemma.
01:26:26 <elliott> that's exactly what it says.
01:26:26 <johnw> shachaf: yoneda and difference monoids
01:26:38 <johnw> elliott: that's... wonderful, thank you so much!
01:26:59 * hackagebot java-bridge 0.20130602 - Bindings to the JNI and a high level interface generator.  http://hackage.haskell.org/package/java-bridge-0.20130602 (JulianFleischer)
01:27:00 <arkeet> but the yoneda lemma there wasn't applied to Hask.
01:29:41 <elliott> the relation between parametricity and the yoneda lemma is suspicious.
01:29:59 <elliott> feels like you could sneak a bunch of secrets into it and nobody would notice.
01:30:15 <arkeet> parametricity just says that a bunch of things are natural.
01:30:23 <elliott> yes.
01:30:38 <elliott> by "the relation" I mean more why the polymorphic things we can define are inherently natural.
01:31:06 <elliott> it's one of those optical illusions where it oscillates between deep and very obvious the more I look at it
01:33:50 <johnw> night everyone
02:13:19 <fruitFly> we first created a hex to base 64 converter and vice-versa, now they want us to http://pastie.org/8022337 what do you think they mean a single char?
02:27:13 <supki> a byte
02:27:42 <supki> also I think they explicitly say not to share challenges anywhere?
02:27:50 <supki> also that's offtopic
02:56:54 <fruitFly> what's wrong here line 110? http://ideone.com/ySykD7
03:02:36 <genisage> replicate $ length byte $ char is incorrect.
03:02:48 <genisage> it ought to be replicate (length byte) char
03:04:43 <genisage> As it is, it's equivalent to replicate ((length byte) char)
03:05:06 <Lethalman_> oh nice ideone, it links to docs
03:06:30 <kennycason> how do you use lambdabot to test code?
03:10:45 <fruitFly> genisage: I thought $ was like surrounding in ()... or can one only use 1 a line?
03:11:06 <kennycason> :t f x = x + 4
03:11:07 <lambdabot> parse error on input `='
03:11:13 <genisage> The $ is like surrounding everything that comes after it in parens.
03:11:42 <kennycason> :t \x -> x + 4
03:11:43 <lambdabot> Num a => a -> a
03:11:47 <Cale> fruitFly: $ is (strangely) right associative
03:12:08 <genisage> so replicate $ length byte $ char  --> replicate (lenght byte $ char)
03:12:15 <Cale> fruitFly: So f $ g $ x means f $ (g $ x)
03:12:22 <Cale> which is equal to f (g x)
03:12:26 <Cale> because f $ x = f x
03:12:30 <kennycason> lambdabot: exp 1
03:12:40 <Cale> > exp 1
03:12:41 <fruitFly> genisage: Cale crud lol
03:12:41 <lambdabot>   2.718281828459045
03:12:53 <kennycason> >exp 1
03:13:00 <kennycason> > exp 1
03:13:02 <lambdabot>   2.718281828459045
03:13:09 <kennycason> Cale: thanks
03:13:17 <Cale> > log (exp 1)
03:13:19 <lambdabot>   1.0
03:13:27 <genisage> kennycason: the first step is to start a private message with lambdabot
03:13:38 <genisage> So that you don't spam your code at everybody else.
03:14:15 <Sculptor> you can do that?
03:14:22 <kennycason> genisage: thanks, makes sense. I am running on my local machine, was just curious how to communicate small blurbs to people :)
03:14:25 <Sculptor> who will read the logs
03:15:04 <kennycason> Sculptor: log = logarithmic function
03:15:32 <kennycason> log_e (e) = 1
03:16:01 <mikeplus64> > logBase (exp 1) (exp 2)
03:16:02 <lambdabot>   2.0
03:16:17 <Sculptor> deus ex machina
03:16:18 <kennycason> nice, didn't know about the logBase function :)
03:16:30 <mikeplus64> @src logBase
03:16:30 <lambdabot> Source not found. The more you drive -- the dumber you get.
03:18:04 <genisage> logBase x y = (log x) / (log y)
03:18:21 <genisage> I think that's actually upside-down
03:18:22 <Sculptor> for y !=1
03:18:28 <genisage> Yes.
03:18:44 <genisage> Or x, depending on which is the base.
03:19:08 <Sculptor> no, log 1 is 0 and you can't divide by 0
03:19:43 <genisage> Yes, but I don't know if what I wrote up there is right. It's probably the inverse of the correct function.
03:20:03 <mikeplus64> yeah logBase is just
03:20:05 <genisage> Just ignore me, I'm tired and probably crazy.
03:20:07 <mikeplus64>     logBase x y         =  log y / log x
03:20:20 <mikeplus64> for Float and Double and by default
03:20:44 <Sculptor> ok
03:21:01 <mikeplus64> no scary floating point stuff/prim op
03:22:52 <mikeplus64> (is there some tricky stuff that could be used instead of that? i wonder why logBase is in Floating at all if it's always log a / log base
03:22:54 <mikeplus64> )
03:35:43 <hskl992> hello. how can I extract the number from a MyInteger with newtype MyInteger = MyInteger Integer deriving (Show)?
03:36:41 <hskl992> so I have a MyInteger 5 and I want to get the Integer number from it
03:36:49 <shachaf> case foo of MyInteger x -> ...x...
03:36:59 <shachaf> Or some other form of pattern matching.
03:37:00 <genisage> f :: MyInteger -> Int; f (MyInteger x) = x
03:38:01 <hskl992> shachaf, genisage: thanks.
03:40:59 <Scabe> Why is it that when I put this into GHCi 3.1 - 4.2 - 5.2 + 6.3 I get -8.881784197001252e-16 instead of zero?
03:41:23 <shachaf> Because that's how floating point values work.
03:41:23 <bitonic> hskl992: you can also define the destructor directly—‘newtype MyInteger = MyInteger {getInteger :: Integer}’
03:41:32 <shachaf> "destructor"?
03:41:54 <bitonic> shachaf: destructor
03:42:27 <Rembane> Scabe: Well, you get almost zero.
03:42:40 <Scabe> ha yeah, still kinda annoying...
03:43:17 <shachaf> > 0.1 + 0.2
03:43:17 <bitonic> Scabe: complain to the IEEE
03:43:18 <lambdabot>   0.30000000000000004
03:45:04 <Scabe> So in the mean time, I guess that's just how the way things are
03:53:32 <burp> use rationals
03:54:21 <burp> > 3.1 - 4.2 - 5.2 + 6.3 :: Rational
03:54:22 <lambdabot>   0 % 1
03:57:06 * hackagebot chesshs 0.1 - Simple library for validating chess moves and parsing PGN files  http://hackage.haskell.org/package/chesshs-0.1 (ArnoVanLumig)
04:00:03 <hskl992> odd, I’m trying to derive Eq, but ghci says: "Duplicate instance declarations", the first one at "deriving (Eq)" the second one at "instance Eq MyNumber where" ...
04:00:37 <shachaf> Yes. Those are both definitions of Eq.
04:00:53 <shachaf> Well, of Eq instances.
04:00:59 <hskl992> shachaf: how can I implement my own Eq?
04:01:01 <shachaf> One of them is derived for you by GHC. The other one you are writing out by yourself.
04:01:15 <shachaf> By writing "instance Eq MyNumber where"
04:02:03 <hskl992> shachaf: but then ghci says: Duplicate instance declarations
04:02:07 * hackagebot azurify 0.2.0.0 - A simple library for accessing Azure blob storage  http://hackage.haskell.org/package/azurify-0.2.0.0 (ArnoVanLumig)
04:02:50 <hskl992> I have a "instance Num MyNumber where" and a "instance Eq MyNumber where"
04:02:58 <shachaf> It says that because you also wrote "deriving (Eq)".
04:03:08 <shachaf> Each of those is a complete Eq instance all on its own.
04:03:20 <hskl992> thats actually deriving (Num, Eq)
04:04:03 <burp> by using "driving (Eq)" you are automatically creating an Eq instance of MyNumber
04:04:17 <hskl992> oh, so I would have to remove that?
04:04:20 <burp> yes
04:04:39 <burp> or just use it, if it works as you want
04:04:39 <hskl992> ah, :) thanks
04:48:31 <fwappy> I'd like to ask a newbie question about the implementation of "flip" given in Learn You AH4GG. Been staring at this for a couple hours and I just don't see how this can work. I can't understand the relationship between the function signature and function body; I probably don't understand currying well enough yet? Please see http://hpaste.org/89535
04:50:01 <Cale> fwappy: Do you know about lambdas?
04:50:10 <Peaker> fwappy, flip' f = \x y -> ..          is desugared to:  flip = \f -> \x -> \y -> ...
04:50:18 <Peaker> (flip' there)
04:50:25 <Cale> (\x -> x + 1) is the function which adds 1 to its argument
04:50:42 <fwappy> Cale: yes I cancunderstand that
04:51:02 <Cale> Similarly, (\x y -> f y x) is the function which given arguments x and y, produces f y x as its result
04:52:08 <fwappy> Ok, so "f y x" is produced. How does this match up with the function signature?
04:52:13 <Cale> In this case, f has type (a -> b -> c), and so because f is applied to y and then x, we know that y has type a, and x has type b
04:52:29 <Cale> and f y x has type c
04:52:50 <Cale> So, this function takes a parameter x of type b, and then a parameter y of type a, and produces a result of type c
04:52:57 <Cale> So its type is (b -> a -> c)
04:53:19 <Cale> So, flip' takes a function f of type (a -> b -> c), and produces a function of type (b -> a -> c)
04:53:52 <fwappy> Ok let me think about that for a sec. ;) For some reason I'm really struggling with this.
04:53:54 <Cale> Is that much okay?
04:54:00 <Cale> ah, all right :)
04:56:37 <Cale> fwappy: As Peaker points out, whenever you have a definition like f x y z = w, you can move parameters to the other side of the = sign, turning the result into a function by using a lambda: f x y = \z -> w,  f x =
04:56:41 <Cale> oops
04:56:48 <Cale> f x = \y z -> w
04:56:54 <Cale> f = \x y z -> w
04:57:14 <Peaker> fwappy, do you understand functions that return other functions as results? (currying)
04:57:43 <Cale> In Haskell, when we write f x y z, it really means ((f x) y) z
04:57:54 <Cale> (function application associates to the left)
04:58:12 <fwappy> I'm starting to understand.
04:58:17 <Cale> f is first applied to x, which produces some function, which is then applied to y, which produces another function which is finally applied to z
04:58:45 <Cale> Well, for some value of "first", heh.
04:59:00 <fwappy> Peaker: yeah, but this flip is giving me a hard time. I can understand how a partially applied function can be passed as the first parameter to map, for example.
04:59:31 <Cale> fwappy: So the idea is that flip f will be a function which takes a couple of parameters and supplies them to f in the opposite order
04:59:59 <Cale> So that say, you'd be able to write  flip map [1,2,3] (*10)
05:00:16 <Cale> > flip map [1,2,3] (*10)
05:00:18 <lambdabot>   [10,20,30]
05:00:40 <Cale> > map (*10) [1,2,3]
05:00:41 <lambdabot>   [10,20,30]
05:01:18 <hskl992> hello, can I somehow constraints to an class instance like "instance MyClass (x,y) where" so that the contents of the tuple are instance of MyClass too?
05:01:28 <hskl992> *add constraints
05:02:10 <hskl992> something like "instance MyClass (MyClass x,y) => (x,y) where" ?
05:03:23 <Cale> instance (MyClass x, MyClass y) => MyClass (x,y) where
05:03:47 <fwappy> Cale: you walking me through the type of each variable in the function body helped a lot; I guess what was tripping me up beyond that was having the parameters appear on the right side of the =, inside the lambda
05:04:10 <Cale> fwappy: Yeah, you can certainly write it as  flip f x y = f y x
05:04:14 <hskl992> Cale: ah ok. thanks. gosh, there are so many little syntactic things you got to learn :(
05:05:02 <fwappy> Cale: that very definition also appears in the book, and makes sense to me.
05:05:03 <Cale> hskl992: You might like http://www.cs.utep.edu/cheon/cs3360/pages/haskell-syntax.html as a kind of extended cheat sheet
05:05:20 <Cale> oh, lol
05:05:26 <Cale> That doesn't talk about classes and instances
05:06:43 <Cale> (but you still might like it :P)
05:09:34 <fwappy> So "f x y = z" being equivalent to "f x = \y -> z" is possible thanks to currying?
05:09:51 <Cale> yeah
05:10:07 <fwappy> Ok I can see that now.
05:11:49 <fwappy> Thanks for the help. That was hard, but it's cool. :)
05:12:12 <Lethalman_> is there a common way of translating RGB to an Int without using bitwise operations by hand?
05:12:22 <Lethalman_> or even better, a Pixel (of JuicyPixels) to an Int value
05:12:37 <merijn> There's also http://cheatsheet.codeslower.com/
05:17:15 <Lethalman_> that is, how do I serialize an RGB color to a number?
05:18:36 <Zariel> how does the connect function acess the "Bot" record to get the socket without having it as an argument? Ie the "socket" call has no argument? http://hpaste.org/89536
05:20:12 <Lethalman_> Zariel, connect returns a Bot
05:21:44 <Zariel> Lethalman_: ah the interesting bit i was after was "asks"
05:22:10 * hackagebot java-bridge 0.20130606 - Bindings to the JNI and a high level interface generator.  http://hackage.haskell.org/package/java-bridge-0.20130606 (JulianFleischer)
06:06:11 <Philonous> Heh, I didn't know you could use an empty record pattern even when the data type wasn't a record to begin with
06:42:14 * hackagebot xml-picklers 0.3.3 - XML picklers based on xml-types, ported from hexpat-pickle  http://hackage.haskell.org/package/xml-picklers-0.3.3 (PhilippBalzarek)
06:51:57 <Aetherspawn> Say I have the function listen :: IO ()
06:52:07 <Aetherspawn> is there a better way I should set that out if I'm using mtl?
06:52:38 <mm_freak> Aetherspawn: could you rephrase the question?
06:52:45 <Aetherspawn> Should i be utilizing MonadIO and trying to use a generic
06:53:11 <Aetherspawn> will that make it easier to call my function without lifting (or something like that)?
06:53:53 <Aetherspawn> (I guess that's kind of a rephrase)
06:55:41 <FreeFull> Aetherspawn: You'll be able to call your function without having to add a liftIO before it
06:55:48 <FreeFull> But otherwise I don't see much of a difference
06:56:00 <Aetherspawn> ok
06:58:06 <yrlnry> target `/home/mjd/src/haskell/min-poly/Relator.t' is not a module name or a source file
06:58:21 <yrlnry> That's in response to :load "/home/mjd/src/haskell/min-poly/Relator.t"
06:58:35 <yrlnry> Does that mean that GHCi enforces some sort of formatting convention on filenames?
06:58:56 <monoidal> yrlnry: I believe so, for example, .hs behaves differently from .lhs
06:59:35 <yrlnry> Thanks.
07:00:44 <monoidal> Should GHCi display "Leaving GHCi" on quitting? I think no, and want to create a patch that removes it, unless someone gives me a reason
07:01:37 <yrlnry> It should display something much more offensive.
07:02:05 <yrlnry> "GHCi is glad you are leaving because you smell."
07:02:38 <yrlnry> (My more offensive suggestions are too offensive for this channel.)
07:04:09 <FreeFull> monoidal: If you see leaving ghci, you know it didn't crash or something, but the quit was intentional
07:04:39 <monoidal> FreeFull: but if the quit is intentional, you don't need feedback to see it, right?
07:04:57 <FreeFull> monoidal: What if the quit was triggered by a ghci script?
07:05:09 <yrlnry> Yeah, you should patch GHCi to only emit a message when it crashes.
07:05:28 <yrlnry> "GHCi catastrophic failure, crashing!"
07:05:44 <monoidal> hm, I don't remember seeing silent ghc crash for a long time
07:05:56 <josephle> yrlnry: "GHCi catamorphic failure, crashing!" :)
07:05:59 <yrlnry> Also an error message if it can't emit the crash warning "GHCi crashing, but can't print error messages!"
07:08:00 <monoidal> FreeFull: what kind of ghci script? run by user? ghci.conf?
07:08:12 <monoidal> if run by user, I still do not see the need for message
07:08:51 <monoidal> I understand if someone malicious put :quit in ghci.conf, it might cause headscratches, but that seems unlikely, and worse things could be put there
07:08:58 <FreeFull> monoidal: Could be something bound with  :set stop  in a script that autoloaded
07:11:36 <elliott> yrlnry: reminds me of:
07:11:38 <elliott> > fix error
07:11:39 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
07:11:55 <monoidal> FreeFull: ok, but do you - or anyone - do this? It seems to me using :quit in a script is malicious
07:12:49 <FreeFull> > fix fail :: [Int]
07:12:50 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:12:50 <lambdabot>              with actual type ...
07:12:55 <FreeFull> :t fix fail
07:12:56 <lambdabot> String
07:13:15 <FreeFull> > fix fail
07:13:16 <lambdabot>   ""
07:13:24 <FreeFull> Defaulting rules?
07:13:31 <elliott> no
07:13:34 <elliott> fail :: String -> ...
07:13:40 <FreeFull> Oh, I see
07:13:43 <elliott> therefore fix fail :: String
07:13:47 <monoidal> the message will be available with ghci -v2, if that should help with malicious scripts
07:13:52 <elliott> (given that ... can be unified with String)
07:14:06 <FreeFull> monoidal: I don't see what's wrong with having that message there though
07:14:26 <monoidal> FreeFull: clutter. Like the banner GHC had a long time ago.
07:15:03 <monoidal> I see it's not completely useless, but IMO it serves its purpose less than 1% of the time
07:16:06 <ion> > (:fix fail) "hello"
07:16:07 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
07:16:07 <lambdabot>              with actual type...
07:16:12 <ion> err
07:16:16 <ion> > (:fix fail) 'x'
07:16:17 <lambdabot>   "x"
07:16:49 <monoidal> > fix show
07:16:50 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
07:18:26 <FreeFull> :t read
07:18:27 <lambdabot> Read a => String -> a
07:18:35 <FreeFull> > (fix read) "3"
07:18:36 <lambdabot>   Couldn't match expected type `t0 -> t1'
07:18:37 <lambdabot>              with actual type `GHC....
07:18:49 <FreeFull> > fix read
07:19:04 <lambdabot>   thread killed
07:19:10 <FreeFull> Right, fix read is bottom
07:19:12 <FreeFull> Makes sense
07:19:17 <monoidal> No.
07:19:24 <monoidal> '"':bottom
07:19:49 <FreeFull> monoidal: I don't see why
07:20:06 <FreeFull> > read "3" :: String
07:20:07 <lambdabot>   mueval-core: L.hs: removeLink: does not exist (No such file or directory)
07:20:12 <monoidal> FreeFull: ah, right it's bottom
07:20:38 <FreeFull> > read "\"3\"" :: String
07:20:39 <lambdabot>   "3"
07:21:15 <parcs> > take 15 $ filter (/= 1) $ map length $ group $ show $ fix show
07:21:16 <lambdabot>   [3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535]
07:23:02 <monoidal> > take 15 $ filter (/= 1) $ map length $ group $ fix show
07:23:03 <lambdabot>   [3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535]
07:25:12 <monoidal> > let f 'a' = "ab"; f 'b' = "bb" in take 15 $ filter (/= 1) $ map length $ group $ fix ((>>= f) . ('a':))
07:25:13 <lambdabot>   [3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535]
07:26:09 <FreeFull> > map (subtract 1 . (2^)) [1..]
07:26:11 <lambdabot>   [1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,26...
07:29:30 <jmcarthur> > map ((2^)-1) [1..]
07:29:32 <lambdabot>   [1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,26...
07:31:40 <Aetherspawn> oooh, maybe I found a bug in GHC
07:31:51 <Aetherspawn> or maybe not.
07:31:55 <ab9rf> heh
07:32:09 <Aetherspawn> --<<-- was intended to be a comment but it was parsed as an operator
07:32:20 <ab9rf> interest
07:32:22 <ab9rf> ing
07:32:31 <Aetherspawn> giving me an error until I added a space "-- <<--"
07:32:32 <Aetherspawn> heh.
07:33:00 <ab9rf> --+ also parses as an operator
07:33:02 <monoidal> Aetherspawn: indeed, this is how the language is defined
07:33:39 * jchild is confused
07:34:17 <ab9rf> i imagine --> would be an operator too
07:34:56 <ab9rf> :t (-->)
07:34:58 <lambdabot> parse error (possibly incorrect indentation)
07:35:19 <jchild> :t (-- >)
07:35:20 <lambdabot> parse error (possibly incorrect indentation)
07:35:26 <ab9rf> intriguing, that is not the message ghci gives
07:35:47 <ab9rf> ghci gives "Not in scope: `-->'"
07:36:36 <jchild> same for me; I get "Not in scope: `-->'"
07:37:59 <jmcarthur> maybe it's a mueval bug
07:38:22 <monoidal> :t (==>)
07:38:23 <lambdabot>     Not in scope: `==>'
07:38:24 <lambdabot>     Perhaps you meant one of these:
07:38:24 <lambdabot>       `==' (imported from Data.Eq),
07:39:48 <ab9rf> jmcarthur: one of them is wrong :)
07:40:43 <ion> > let (-->) = 42 in (-->)
07:40:45 <lambdabot>   42
07:40:48 <ion> :t let (-->) = 42 in (-->)
07:40:49 <lambdabot> parse error (possibly incorrect indentation)
07:47:17 * hackagebot pipes-binary 0.1.0.0 - Encode and decode binary streams using the pipes and binary libraries.  http://hackage.haskell.org/package/pipes-binary-0.1.0.0 (RenzoCarbonara)
07:51:25 <yrlnry> :t (-->) where (-->) = 42
07:51:27 <lambdabot> parse error (possibly incorrect indentation)
07:51:30 <yrlnry> Oh well
07:56:39 <Fuuzetsu> :t let (-->) = 42 in (-->)
07:56:41 <lambdabot> parse error (possibly incorrect indentation)
07:56:55 <Fuuzetsu> oh, you can't use --
07:57:48 <Fuuzetsu> well, it works in a regular file…
07:59:54 <meretrix> Is it generally considered a bad practice to use "undefined" for some fields when constructing default record types?
08:00:46 <byorgey> meretrix: yes
08:01:10 <byorgey> meretrix: if those fields can start out with no value, give them a Maybe type
08:01:18 <Fuuzetsu> ‘undefined’ screams ‘No!’ in 99.9% of the situations
08:02:18 * hackagebot java-bridge 0.20130606.1 - Bindings to the JNI and a high level interface generator.  http://hackage.haskell.org/package/java-bridge-0.20130606.1 (JulianFleischer)
08:02:29 <meretrix> Ok, I guess I could just create "default functions" which have arguments for a subset of the fields and define the rest.
08:02:57 <byorgey> sure, that works too
08:06:14 <jmcarthur> meretrix: basically the only time i ever commit code with "undefined" is when i need an argument to a function that i know doesn't ever use it, such as sizeOf
08:06:42 <jmcarthur> meretrix: and even then i'd rather use a proxy value, but those functions just aren't designed for that
08:07:08 <meretrix> Ok, thanks.
08:42:20 * hackagebot java-bridge 0.20130606.2 - Bindings to the JNI and a high level interface generator.  http://hackage.haskell.org/package/java-bridge-0.20130606.2 (JulianFleischer)
08:47:53 <askalski> hi
08:48:00 <Fuuzetsu> o/
08:48:01 <askalski> can someone tell me what's wrong with this code?
08:48:24 <askalski> getRelaxedSubGraph (ti, tj) = case (ti, tj) of
08:48:24 <askalski>                 (i, i) -> relaxedPivot
08:48:24 <askalski>                 (i, _) -> relaxedPivotRow !! tj
08:48:24 <askalski>                 (_, i) -> relaxedPivotCol !! ti
08:48:24 <askalski>                 (_, _)
08:48:34 <askalski> ti, tj and i are explicitly declared as Int
08:48:43 <askalski> and I get
08:48:44 <askalski> Conflicting definitions for `i'
08:48:46 <askalski> error
08:48:48 <Fuuzetsu> In the future, use hpaste for code
08:48:53 <askalski> ok
08:49:10 <askalski> there obviously is a -> ... after (_, _)
08:49:17 <askalski> but it's long so I cut it
08:49:17 <Fuuzetsu> askalski: I don't believe you can do (i, i)
08:49:31 <askalski> Fuuzetsu, ok, but how to walk around?
08:49:48 <Fuuzetsu> askalski: use a guard where you check equality
08:50:14 <Taneb> Can someone link me some Haskell code suitable for testing a lexer?
08:50:16 <askalski> Fuuzetsu, can you gvie em an example?
08:50:30 <monoidal> askalski: (i,j) | i == j -> ...
08:50:40 <Fuuzetsu> what monoidal said
08:50:41 <askalski> ok, thanks
08:50:43 <Fuuzetsu> get rid of the case
08:51:21 <askalski> Fuuzetsu, remove the case? so 4 lines like that?
08:51:24 * atamagawarui wonders how (i, _) and (_, i) are supposed to match different things.
08:51:47 <askalski> atamagawarui, well, I understand that "first match wins", so in this context they will.
08:51:56 <Fuuzetsu> getRelaxedSubGraph (ti, tj) | ti == tj = …
08:52:14 <askalski> ok, let me try
08:52:17 <atamagawarui> askalski: Think. Is there anything that (i, _) does not match, bar bottom?
08:52:32 <Fuuzetsu> askalski: (_, i) will never be reached
08:53:22 <askalski> Fuuzetsu, well "i" is declared above as an int, so I expected this to create a solid case, like in Scala
08:53:27 * atamagawarui wonders if "i" is the name of some closed-over variable in that environment, and askalski actually intends to match against that variable.
08:53:39 <atamagawarui> askalski: Ah-ha! I caught you!
08:53:52 <askalski> atamagawarui, what?
08:54:00 <askalski> I was expecting it is like
08:54:04 <askalski> say i = 2
08:54:05 <atamagawarui> askalski: You can only pattern match against data constructors or new variables you are introducing.
08:54:16 <askalski> so (2,2), (2,_), (_,2), (_,_)
08:54:24 <monoidal> > let i = 2; j = 3 in case 3 of j -> 0; i -> 1
08:54:25 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
08:54:27 <atamagawarui> askalski: I am afraid that is not how it works.
08:54:39 <askalski> atamagawarui, that explanins a lot :D
08:54:47 <Fuuzetsu> You can't do it like in Prolog ;P
08:55:00 * atamagawarui knew there was something fishy!
08:55:25 <fruitFly> how do I get haskell 2013.2 on linux mint 14?
08:55:33 <fruitFly> I am a NOOOB
08:55:33 <monoidal> > let i = 2; j = 3 in case 2 of j -> 0; i -> 1
08:55:34 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
08:55:40 <Fuuzetsu> fruitFly: doesn't your package manager have it?
08:56:00 <Fuuzetsu> > 1
08:56:02 <lambdabot>   1
08:56:04 <fruitFly> Fuuzetsu: I dn't see it!
08:56:43 <Fuuzetsu> Well, a very brief look on the platform page gets me this: http://community.linuxmint.com/software/view/haskell-platform
08:57:03 <Fuuzetsu> I'm not sure whether that's up to date at all though.
08:57:13 <atamagawarui> askalski: (ti, tj) -> case (i == ti, j == tj) of { (True, True) -> ... ; (True, False) -> ... ; ... }
08:57:16 <fruitFly> it says 2011!
08:57:19 <fruitFly> Fuuzetsu:  ^
08:57:35 <atamagawarui> askalski: Sorry, (i == ti, i == tj) :-P
08:57:41 <Fuuzetsu> fruitFly: I don't think that's the release date of the package itself although that's just a wild guess.
08:58:02 <askalski> atamagawarui, thanks, now I learned something
08:58:18 <Fuuzetsu> ‘sudo apt-get install haskell-platform’ should have it.
08:58:19 <askalski> and the code works now
08:58:33 <atamagawarui> yay
08:58:48 <askalski> Fuuzetsu, right, I remember the (True, False)... hack from Scala as well
08:59:25 <Fuuzetsu> askalski: I wish we had Agda's cool pattern matching where you can actually say things like f i .i = …
08:59:26 <askalski> btw, I am writing a parallel version of Floyd-Warshall alg
08:59:31 <askalski> I can probably share it
09:00:06 <wavewave> cmccann: working .hoodle file for bamboo tablet for me is posted on hpaste
09:02:16 <askalski> thanks everyone!
09:02:17 <askalski> bye!
09:02:23 <fruitFly> askalski: byee!!
09:02:45 <fruitFly> Fuuzetsu: that command isn't working, I'm not sure what version is on the mint website
09:03:08 <fruitFly> does mint suck to learn linux on? what about arch, gentoo or nixos?
09:04:33 <Fuuzetsu> I use Gentoo and I like it. I think Mint is aimed more at the casual spectrum of users albeit that's a topic for haskell-blah if you want to discuss it further.
09:04:35 <geekosaur> mint's not terrible, it's ubuntu (so at root debian) with a saner user interface
09:04:41 <geekosaur> (IMO)
09:22:22 * hackagebot intset 0.1.0.0 - Pure, fast and memory efficient integer sets.  http://hackage.haskell.org/package/intset-0.1.0.0 (SamTruzjan)
09:25:26 <askalski> hi, now I have a different problem
09:25:47 <askalski> I have a very uninformant error, that is Exception: Prelude.(!!): index too large
09:25:51 <askalski> in a very long code
09:26:00 <askalski> how to get at least the line from which the error is thrown?
09:26:08 <askalski> or most prefferably some kind of call stack?
09:26:18 <Fuuzetsu> look into debugging with GHCi
09:26:23 <jmcarthur> askalski: eliminate all uses of (!!)
09:26:26 <Fuuzetsu> ideally, you shouldn't be using (!!)
09:26:31 <jmcarthur> askalski: it's generally a bad idea to use (!!) anyway
09:26:39 <askalski> OK, will do later
09:26:50 <askalski> now I need to get the code working
09:26:51 <jmcarthur> askalski: except for specific circumstances, it's usually going to be slow and error prone
09:27:12 <askalski> I understand, OK, it's linear and gives errors
09:27:18 <askalski> but now I just want to see if alg is working
09:27:27 <Fuuzetsu> http://www.haskell.org/haskellwiki/Debugging
09:27:28 <askalski> before spending on it's more time lifting the implementation
09:27:33 <jmcarthur> the easiest way to fix your bug is to eliminate (!!), really
09:27:35 <gfredericks> do cabal packages normally declare what version of ghc they depend on?
09:28:04 <jmcarthur> gfredericks: only indirectly by declaring what versions of base they work with
09:28:23 <gfredericks> `cabal install hedn` fails for me with a compile error and I'm not sure how to begin investigating
09:28:32 * Fuuzetsu had beef with people relying on GHC features removed in HEAD recently
09:28:49 <Fuuzetsu> gfredericks: Can you put your error on hpaste?
09:29:07 <askalski> ok, so will Haskell auto cache results ?
09:29:20 <askalski> I can replace these arrays with their declarations
09:29:23 <jmcarthur> gfredericks: it looks like that package doesn't put any version constraints on its dependencies at all
09:29:30 <gfredericks> brilliant
09:29:38 <askalski> but I wanted to prevent Haskell from recalculating it every call
09:29:44 <jmcarthur> askalski: the problem is that haskell lists aren't arrays at all
09:29:45 <XexonixXexillion> askalski: that depends on the implementation
09:29:47 <gfredericks> Fuuzetsu: http://hpaste.org/89549
09:29:59 <jmcarthur> askalski: also, yeah, there is no promise of memoization or anything
09:30:14 <Fuuzetsu> I hate this error.
09:30:14 <askalski> jmcarthur, ok, so if I replace them with one dimension arrays
09:30:17 <askalski> will that help?
09:30:19 <jmcarthur> askalski: or are you trying to use lists as a memoization implementation or something?
09:30:32 <gfredericks> Fuuzetsu: yes I hate it too
09:30:37 * gfredericks hates
09:30:39 <askalski> jmcarthur, yes, it's a dynamic algorithm, without memorization it ets super compex
09:30:41 <jmcarthur> askalski: it will help with performance but not with your bug, unless you use safe indexing functions (that return a Maybe) and throw more informative errors there
09:30:58 <jmcarthur> askalski: for that matter, surely there is at least a safe indexing function for lists...
09:31:06 <jmcarthur> @hoogle Int -> [a] -> Maybe a
09:31:07 <lambdabot> Prelude (!!) :: [a] -> Int -> a
09:31:07 <lambdabot> Data.List (!!) :: [a] -> Int -> a
09:31:07 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
09:31:11 <jmcarthur> grr
09:31:18 <jmcarthur> s/safe/total/
09:31:26 <askalski> jmcarthur, ok, so can I declare a fixed-size array?
09:31:40 <askalski> jmcarthur, and is that gonna be more infomant once it fail?
09:31:48 <jmcarthur> not automatically, as i just said
09:31:54 <gfredericks> jmcarthur: I did dynamic algorithms with the state monad once
09:31:55 <askalski> ok
09:31:57 <jmcarthur> switching to arrays will not help your find the bug
09:32:11 <jmcarthur> using an indexing function that forces you to handle the error will
09:32:20 <Fuuzetsu> ‘safeIndex idx xs = if length xs > idx then Just (xs !! idx) else Nothing’ but this is bad and shouldn't be used
09:33:09 <monoidal> Fuuzetsu: furthermore, it should be length xs >= idx
09:33:20 <monoidal> whoops disregard this
09:33:24 <Fuuzetsu> ;)
09:33:45 <jmcarthur> Fuuzetsu: only bad for performance, but still better than (!!)
09:33:52 <jmcarthur> for bug prevention
09:33:59 <jmcarthur> and debugging....
09:34:10 <FreeFull> Fuuzetsu: It won't work for infinite lists
09:34:15 <jmcarthur> ah that's bad
09:34:18 <Fuuzetsu> jmcarthur: no, it's bad in the same way that catching NullPointerException is in Java. It's just evil.
09:34:27 <XexonixXexillion> askalski: If you want line numbers for errors, consider using assert
09:34:30 <jmcarthur> Fuuzetsu: what?
09:34:32 <Fuuzetsu> FreeFull: Meh, recursive solution is also trivial
09:34:42 <jmcarthur> Fuuzetsu: Maybe is evil?
09:34:52 <FreeFull> I don't see what's wring with a safe index lookup though
09:34:54 <Fuuzetsu> jmcarthur: It is if used in this manner.
09:34:58 <jmcarthur> why?
09:35:07 <quchen> @ty \n -> listToMaybe . drop n
09:35:08 <lambdabot> Int -> [a] -> Maybe a
09:35:17 <jmcarthur> it's just to force you to handle your bug, even if only to throw a meaningful, context-sensitive error message
09:35:26 <Fuuzetsu> You're suppressing the error instead of finding out what's wrong to begin with.
09:35:28 <FreeFull> quchen: That's good
09:35:34 <jmcarthur> Fuuzetsu: how is that surppressing the error?
09:36:00 <jmcarthur> Fuuzetsu: it would be surpressing it if it had some default value instead or something, but the type inherently doesn't allow you to just suppress it
09:36:16 <jmcarthur> *surpressing
09:36:37 <Fuuzetsu> jmcarthur: Replacing all uses of (!!) and then getting ‘Nothing’ there gives you 0 information about what went wrong which is how questions like ‘How can I debug this?’ happen.
09:36:53 <Fuuzetsu> It's kind of like the safeHead argument.
09:37:11 <XexonixXexillion> safeHead is listToMaybe isn't it?
09:37:15 <Fuuzetsu> yeah
09:37:21 <jmcarthur> Fuuzetsu: (!!) gives you zero information. Nothing forces you to handle it. you can handle it by using error with a *more* useful message
09:37:38 <FreeFull> You could use Either String a  if you really care
09:38:01 <XexonixXexillion> Fuuzetsu: I find that to be a very useful function
09:38:15 <quchen> We're not trying to make a function that suppresses errors. We want a function that doesn't possibly produce one.
09:38:23 <Fuuzetsu> jmcarthur: Sure but I'm keeping in mind the fact that something that clearly should never happen just happened in the askalski's program and suggesting that it's handled using Maybe is hardly a solution.
09:38:30 <quchen> It's the difference between gagging it and designing it well.
09:38:35 <jmcarthur> Fuuzetsu: i never once said that
09:38:51 <jmcarthur> Fuuzetsu: i said that if it returned a Maybe then he would be able to throw a more useful error message
09:39:06 <jmcarthur> Fuuzetsu: as it stands, he just gets an out of bounds error with no explanation at all
09:39:37 <Fuuzetsu> k
09:40:02 <jmcarthur> > [1,2,3] !! 10
09:40:04 <lambdabot>   *Exception: Prelude.(!!): index too large
09:40:04 <XexonixXexillion> jmcarthur: Why not just use assert? It'll even give the line number...
09:40:24 <Fuuzetsu> :t assert
09:40:25 <lambdabot>     Not in scope: `assert'
09:40:25 <lambdabot>     Perhaps you meant one of these:
09:40:26 <lambdabot>       `insert' (imported from Data.List),
09:40:41 <XexonixXexillion> It's in Control.Exception from memory
09:40:54 <jmcarthur> > let index n = listToMaybe . drop n in fromMaybe (error "the foo index was too large for the bar list") $ index 10 [1,2,3]
09:40:55 <lambdabot>   *Exception: the foo index was too large for the bar list
09:41:05 <quchen> (!!) is a non-IO function, and supposed to be used in non-IO code. Throwing an exception from it cannot be handled until it bubbles up all the way to the next IO, which is a very awful way of handling exception(al cases).
09:41:09 <jmcarthur> > let index n = listToMaybe . drop n in fromMaybe (error "the foo index was *out of bounds* for the bar list") $ index 10 [1,2,3]
09:41:11 <lambdabot>   *Exception: the foo index was *out of bounds* for the bar list
09:41:18 <Fuuzetsu> Cool, I wish I knew about assert earlier.
09:41:26 <jmcarthur> i guess you lose whether it's too large or too small unless the error message includes some extra stuff from context
09:41:42 <jmcarthur> yeah, you could use assert instead of error
09:42:23 * hackagebot ig 0.1 - Bindings to Instagram's API.  http://hackage.haskell.org/package/ig-0.1 (JeanPhilippeMoresmau)
09:42:25 * hackagebot mongodb-queue 0.2.0.0 - a queue using MongoDB  http://hackage.haskell.org/package/mongodb-queue-0.2.0.0 (GregWeber)
09:44:35 <Gracenotes> "My final thing, which is in some sense aimed at Haskell, is that state matters. So, mostly computer programs are about managing state. And, although I am very sympathetic with the desire to keep most of your program immutable, because it's much easier to reason about correctness if you aren't doing modifications, a major part of your program is going to be concerned with state, and it has to be done in a simple way. It can't be complicated, it ca
09:44:46 <Gracenotes> " -- Liskov, at a recent talk
09:45:20 <Gracenotes> in the context of tradeoffs in programming languages
09:45:22 <Fuuzetsu> Your quote got snipped by the IRC limit.
09:45:30 <Gracenotes> at which phrase?
09:45:36 <quchen> It can't be complicated, it c
09:45:42 <quchen> ^ That.
09:45:48 <jmcarthur> that is rather disappointing. i feel like handling state in other languages is much more complicated than in haskell
09:45:49 <Gracenotes> oh, not by much. "It can't be complicated, it can't be hard to understand."
09:45:59 <Gracenotes> eof
09:46:15 <quchen> So the short version if "Haskell is stupid because it has no state"?
09:46:27 <Adeon> isn't that the long vesion
09:46:31 <Adeon> version*
09:46:37 <jmcarthur> i doubt it was intended to be taken so offensively
09:46:41 <Gracenotes> well, it does raise a somewhat valid point, that often Haskell programs are structured around how to modify state
09:46:47 <Fuuzetsu> I don't think it's complicated in Haskell. I have to worry every single time in other languages about whether this function mutates what I pass in. Whether it only mutates it under specific circumstances. It's horrible.
09:46:49 <jmcarthur> Gracenotes: which is *good*!
09:46:49 <Gracenotes> as far as central control flow
09:47:14 <jmcarthur> or maybe i misunderstand what you mean
09:47:17 <geekosaur> haskell forces you to think about the most important thing your program does
09:47:28 <Gracenotes> I think Liskov prefers data abstraction, with encapsulation the means to control state
09:47:34 <jmcarthur> geekosaur: yeah. and sometimes that happens to be a state
09:47:35 <Fuuzetsu> Adeon: I think it actually says ‘Haskell is not cool because it takes longer than 2 hours to understand some of the concepts’
09:47:43 <jmcarthur> geekosaur: which is fine
09:47:46 <geekosaur> not in the sense of "the computer should be doing this for me" but in the sense of "if I don't do this right, my program is broken"
09:48:12 <Gracenotes> I do not think Liskov would make statements about software engineering in Haskell without understanding some of the tradeoffs
09:48:20 <monochrom> yeah I think Liskov misunderstood Haskell's states
09:49:05 <quchen> It's kind of hard to throw stuff in a state bucket and expect the program to work, I give him that.
09:49:07 <cmccann> mostly haskell makes it harder to sweep state changes under the rug
09:49:16 <monochrom> she is probably right on the surface syntax front. Haskell state surface syntax is less simple than imperative programming state surface syntax.
09:49:20 <Fuuzetsu> That's a Good Thing™.
09:49:22 <Gracenotes> on the other hand, there are different flavors of intuition, the ones you have intuition for and the ones you don't.
09:49:25 <jmcarthur> quchen: she
09:49:30 <jmcarthur> *her
09:49:37 <quchen> ... the speaker ...
09:49:53 <jmcarthur> quchen: it's liskov. she is a very influential computer scientist
09:49:54 <monochrom> it's Barbara Liskov
09:50:06 <quchen> Ah. I don't know her.
09:50:25 <monochrom> but semantics, Haskell state semantics is simpler than imperative programming state semantics
09:50:33 <rzh> Infoq has her talk session.. quite a good talk
09:50:38 <Gracenotes> she is part of the reason OOP hierarchies are slightly less insane. and her focus is not so much semantics as programming methodology.
09:50:42 <monochrom> heard of the Liskov substitutability principle
09:50:45 <cmccann> as in "liskov substitutability principle" or whatever, a.k.a. the most popular OOP design principle that's never actually followed in practice
09:50:48 <LambdaDusk> erm, which would be the most simple yet robust way to stream a file to a port?
09:50:50 <jmcarthur> quchen: anything she says is going to be widely regarded by many people as profoundly important
09:50:51 <Gracenotes> (/slightly/ less insane nowadays)
09:50:58 <Gracenotes> LambdaDusk: netcat
09:51:19 <quchen> Is that the old woman that got a Turing award and the speech was recently put online?
09:51:24 <Fuuzetsu> yes
09:51:26 <quchen> Ah, I see.
09:51:53 <gfredericks> this compiler error suggests I use -XTypeSynonymInstances to bypass it
09:51:54 <Fuuzetsu> I don't think that such a small phrase is much to go by in an argument without further input from her.
09:51:57 <Gracenotes> it is true that just because a program has clear semantics doesn't make it super for general-purpose software engineering
09:51:58 <gfredericks> but cabal will not take that option
09:51:59 <monochrom> interesting to note that the substitutability principle implies that "a square is not a special case of a rectangle" because of stateful squares and stateful rectangles
09:52:01 <gfredericks> where do I pass it?
09:52:06 <quchen> jmcarthur: The same reasoning leads to people still quoting Einstein's "I don't think the old guy plays with dice".
09:52:17 <LambdaDusk> Gracenotes: does it allow me to turn the file into chunks and perform actions on those?
09:52:21 <monochrom> whereas immutable square is clearly a special case of immutable rectangle
09:52:26 <Fuuzetsu> gfredericks: Consider diving into the source code of the package and fixing it properly.
09:52:40 <Gracenotes> LambdaDusk: that sounds like rather a separate task
09:52:51 <Gracenotes> what kinds of actions now?
09:53:37 <gfredericks> Fuuzetsu: I am considering that
09:53:41 <gereeter> Hey, does anyone know where I can download GHC HEAD? When I follow the link on the GHC download page, it points me to an empty directory.
09:53:42 <monochrom> anyway Haskell STM is the best state story of all languages so far.
09:53:45 <gfredericks> this will take a lot of learning about cabal I imagine
09:54:01 <Fuuzetsu> gereeter: Known issue. You will have to compile it yourself.
09:54:28 <Fuuzetsu> I've been nagging ghc-devs about it for a while but no word on the reason nor any ETA
09:54:29 <monoidal> gereeter: git clone http://darcs.haskell.org/ghc.git/ to get source
09:54:36 <Gracenotes> general-purpose STM is very different from Haskell STM
09:54:42 <Gracenotes> Haskell is kind of a degenerate case
09:54:48 <gereeter> Ok, thanks.
09:54:51 <Gracenotes> although arguably the good kind of degenerate
09:55:12 <quchen> greeny: If that doesn't work I think there's a Github mirror https://github.com/ghc/ghc
09:55:25 <Fuuzetsu> quchen: He left.
09:55:28 <quchen> Oh.
09:55:42 <LambdaDusk> Gracenotes: Basically, read a number of the bytes from the file, wrap it in a packet and send it - then read the next n bytes and wrap them too
09:56:20 <monochrom> it is also not like I really avoid state
09:57:11 <monochrom> "f x a | x>0 = f (x-1) (a+1)" I am clearly using states without state syntax
09:58:15 <k0ral_> Why does "g :: (MyClass m) => MyType -> m (); f (h:t) = (g h) `par` (f t) `pseq` (g h >> f t)" give the error "Cound not deduce (MyClass m0) arising from a use of g" ?
09:58:23 <ion> “darcs.haskell.org/ghc.git”
09:58:50 <k0ral_> works fine without using par/pseq (that is: f = mapM g
09:59:27 <Gracenotes> I think, in the context of the talk/quote, state might be referring to something which is 'global' and persistent. so not how to use it, but how to lug it around with you.
09:59:30 <monochrom> http://www.vex.net/~trebla/haskell/calculator/Calculator.hs  scroll down or search for "euclid". I even use stateful formal method (loop invariant!) to prove correctness of a pure function --- pure function in syntax only
09:59:34 <ion> Btw, i don’t think that would do what you think it would do (if it worked).
09:59:57 <enthropy> k0ral_: the first  g h  doesn't have to have the same `m' as the second one
10:00:28 <Gracenotes> LambdaDusk: I think basic wrappers around Posix functions, in the Haskell base libraries, might be reasonable. As a step up, maybe, there are things like iteratees and iostreams
10:00:28 <ion> Each “g h” is a separate computation. Use explicit sharing.
10:00:44 <enthropy> you probably have to write it as:      f (h:t) = let x = g h; y = f t in x `par` y `pseq` (x >> y)
10:00:44 <monochrom> ok, but Haskell STM is the best global state story of all languages so far
10:00:52 <LambdaDusk> Gracenotes: What about pipes or conduits? Are they suitible?
10:00:56 <k0ral_> could you be more specific please ? I don't get it
10:01:08 <ion> Also, i’m pretty sure a function like that already exists.
10:02:06 <Gracenotes> I haven't had much experience with them. As long as they can all work with (I assume) raw sockets, should be fine...
10:02:26 <monochrom> and it is ironic because to achieve such a good story you have to begin by limiting state and STM
10:03:04 <Gracenotes> the best way to do IO depends on how much you need to do with it, I suppose
10:03:10 <Gracenotes> *stream IO
10:03:13 <Fuuzetsu> @pl f a b c d = (f a, f b, f c, f d)
10:03:14 <lambdabot> f = fix (flip =<< ((flip . ((flip . ((.) .)) .)) .) . (flip =<< ((flip . ((.) .)) .) . (flip =<< (((.) . (,,,)) .))))
10:03:17 <Fuuzetsu> hue
10:04:25 <LambdaDusk> Gracenotes: The files are big and I heard lazy IO might blow up the memory consumption on big files - especially if you don't need all of it loaded at once
10:04:50 <Fuuzetsu> @pl f x x' x'' x''' = do {(a, b, c, d) <- unzip4 <$> mapM g x'''; return (f a, f b, f c, f d)}
10:04:51 <lambdabot> (line 1, column 22):
10:04:51 <lambdabot> unexpected '{'
10:04:51 <lambdabot> expecting variable, "(", operator or end of input
10:04:52 <Gracenotes> if done properly, I'd think lazy IO might do the opposite, if properly implemented
10:05:08 <latro`a> Fuuzetsu, you have to @undo
10:05:14 <latro`a> and then @pl the output of that
10:05:30 <Fuuzetsu> @undo f x x' x'' x''' = do {(a, b, c, d) <- unzip4 <$> mapM g x'''; return (f a, f b, f c, f d)}
10:05:31 <lambdabot> f x x' x'' x''' = unzip4 <$> mapM g x''' >>= \ (a, b, c, d) -> return (f a, f b, f c, f d)
10:05:35 <k0ral_> ion: parMap ?
10:05:42 <Fuuzetsu> @pl f x x' x'' x''' = unzip4 <$> mapM g x''' >>= \ (a, b, c, d) -> return (f a, f b, f c, f d)
10:05:42 <lambdabot> (line 1, column 18):
10:05:43 <lambdabot> unexpected " "
10:05:43 <lambdabot> expecting operator
10:06:14 <Gracenotes> LambdaDusk: the key point of many of these frameworks is efficiency and safety with high-throughput tasks, so the descriptions of some of these packages should be sufficient to determine whether you should use them or not
10:06:37 <LambdaDusk> Gracenotes: Well, thanks
10:06:42 <Fuuzetsu> @pl f x x' x'' z = unzip4 <$> mapM g z >>= \ (a, b, c, d) -> return (f a, f b, f c, f d)
10:06:42 <lambdabot> (line 1, column 15):
10:06:42 <lambdabot> unexpected " "
10:06:42 <lambdabot> expecting operator
10:07:09 <FreeFull> @pl \f x x' x'' z -> unzip4 <$> mapM g z >>= \ (a, b, c, d) -> return (f a, f b, f c, f d)
10:07:09 <lambdabot> (line 1, column 51):
10:07:09 <lambdabot> unexpected "c"
10:07:09 <lambdabot> ambiguous use of a non associative operator
10:07:12 <Fuuzetsu> @pl f _ _ _ z = unzip4 <$> mapM g z >>= \ (a, b, c, d) -> return (f a, f b, f c, f d)
10:07:12 <lambdabot> (line 1, column 3):
10:07:12 <lambdabot> unexpected '_'
10:07:12 <lambdabot> expecting variable, "(", operator or end of input
10:07:18 <Fuuzetsu> *shrug*
10:07:25 <LambdaDusk> and how would I read an exact number of bytes from a Handle/Socket?
10:08:07 <Fuuzetsu> > let x''' = 3 in x'''
10:08:09 <lambdabot>   3
10:08:14 <FreeFull> LambdaDusk: Which library are you using? Network.BSD ?
10:08:27 <LambdaDusk> just Network
10:09:49 <jmcarthur> Gracenotes: "I think, in the context of the talk/quote, state might be referring to something which is 'global' and persistent. so not how to use it, but how to lug it around with you."  <-- yes, i and i think i would even agree that this could be less awkward
10:10:04 <jmcarthur> although i still feel like out current solutions in haskell are preferable to truely global state
10:10:11 <jmcarthur> *our
10:12:42 <FreeFull> LambdaDusk: I think you want Network.Socket.ByteString
10:13:37 <FreeFull> LambdaDusk: It has a function  recv   which takes a socket and a number of bytes, reads that many bytes from the socket and returns it as a ByteString
10:14:05 <LambdaDusk> how can I use that with forkIO ?
10:14:37 <FreeFull> LambdaDusk: What exactly are you trying to do?
10:14:44 <quchen> do { h <- connectTo ...; forkIO (readStuff h); ... }
10:14:46 <ion> k0ral: Perhaps something like \st f -> sequence . parMap st f
10:14:56 <LambdaDusk> FreeFull: No, wait, I see it, thanks
10:15:16 <ion> k0ral: What are you trying to achieve? That may not do what you’re after either.
10:15:45 <ion> Perhaps you want something like mapConcurrently from async.
10:22:33 <qfwfq> Hi friends! Would you mind looking over http://sprunge.us/NeKJ and tell me what you'd do differently?
10:24:11 <hpc> you have a few lines that start with "> -- "
10:25:08 <qfwfq> hpc: I wasn't certain how to separate 'comments which I read from the online documentation', and 'comments I wrote to clarify the code'.
10:25:20 <qfwfq> Read in, i.e. :r! curl -s http://snowball.tartarus.org/algorithms/english/stemmer.html | html2markdown
10:25:31 <linduxed> can someone who's using vim tell me what the ConId syntax match is for?
10:25:40 <linduxed> i can't find any of it in the xmonad code
10:25:54 <qfwfq> hpc: Is that a bad practice? How would you separate them?
10:25:56 <linduxed> (i've set it to red background and nothing's red)
10:26:45 <linduxed> here's a link to the haskell.vim file https://github.com/MasseR/dotvim/blob/master/syntax/haskell.vim
10:26:52 <linduxed> it's defined on line 20
10:27:52 <geekosaur> constructors, looks like?
10:28:21 <hpc> the comment says qualified constructors
10:28:22 <geekosaur> zero or more module qualifiers followed by an identifier with an initial uppercase
10:29:46 <linduxed> hpc: well i'm still confused, do you think you know what code would qualify as a ConId?
10:31:20 <Fuuzetsu> http://i.imgur.com/rmQ4SlW.png
10:31:36 <Fuuzetsu> “No documentation available.” is the bane of my existence.
10:31:59 <qfwfq> Composition: it's a hell of a drug.
10:32:13 * geekosaur isn't very familiar with vim syntax highlighting
10:32:45 <ion> fuuzetsu: :-D
10:32:53 <geekosaur> but it should match any constructor name (e.g. False, XConfig, ...)
10:35:22 <joelteon> http://hpaste.org/89550
10:35:24 <joelteon> parse error in pattern?
10:35:28 <joelteon> on line 4
10:35:50 <Fuuzetsu> I recommend smaller spaces…
10:36:45 <joelteon> is that what's causing the problem?
10:36:56 <Fuuzetsu> No, probably not.
10:36:59 <ion> joelteon: The alignment isn’t correct.
10:37:25 <joelteon> which part is incorrect?
10:37:33 <ion> Look at “cur” and “isSpamming”.
10:37:33 <Fuuzetsu> line 5 needs to be aligned to the left
10:37:39 <joelteon> whoops
10:43:12 <johnw> joelteon: it's also common to have a newline after ->, if the body is large
10:43:37 <johnw> you can do it after "do" as well
10:45:06 <Fuuzetsu> Any idea what the huge binary blobs in front of an Alex generated lexer are?
10:46:05 <johnw> joelteon: I annotated your paste with the way I would have formatted that code
10:46:56 <johnw> err, http://hpaste.org/89551
10:57:11 <tabemann> little question
10:57:16 <Gracenotes> how little
10:57:27 * hackagebot Nomyx-Language 0.2.1 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.2.1 (CorentinDupont)
10:57:32 <Gracenotes> please, to 3 significant digits
10:57:46 <Gracenotes> of littleness
10:58:06 <tabemann> if you want to define a type with all type constructors exposed in one module, meant to be internal, and then expose those types but *without* the data constructors in another, public, module, do you import the internal module in the public module and then reexport just the individual type constructors in the public module
10:59:08 <Adeon> sounds about right
10:59:28 <tabemann> *all data constructors exposed
10:59:46 <tabemann> (for some reason I tend to mix up "data" and "type" constructors in writing...)
11:01:21 <Gracenotes> if you really want no one to use your constructors, don't expose the module in cabal, as well
11:01:59 <tabemann> this is some code that is kind of meant for just the project I'm working on, but which I'm likely to reuse for future projects
11:02:26 <tabemann> if I'm feeling *really* ambitious I could turn it into a full-scale OpenGL API wrapping OpenGLRaw, and put *that* in cabal
11:03:05 <tabemann> to make something that fully covers what OpenGLRaw does but which is nicer to work with than the current (incomplete) OpenGL bindings
11:03:44 <tabemann> I'm not feeling quite that ambitious quite yet, though
11:07:51 <tabemann> agh now I want to pull apart this one module into a number of separate modules, so now I have to figure out which functions and types are used by which individual functions I do not just want to copy-and-paste the imports into each new module
11:08:51 <ClaudiusMaximus> tabemann: copy+paste, use -Wall output to prune unused imports?
11:09:05 <tabemann> ClaudiusMaximums: that might work
11:09:13 <Gracenotes> <clippy> It sounds like you're trying to software engineer. Would you like some help? </clippy>
11:10:03 <tabemann> I'm just trying to avoid having gratuitous imports all over the place (having seen too much code in C and C++ full of gratuitous #includes)
11:11:01 <tabemann> and I don't necessarily know off the top of my head just which module which function or type came from
11:11:12 <tabemann> another little question
11:11:18 <tabemann> when using hierarchial modules
11:11:33 <tabemann> when you import a module from the same level in the hierarchy as the importing module
11:11:34 <Gracenotes> if you can afford to, either qualify the module or explicit import what you need
11:11:53 <tabemann> do you do, say, import Bar or import Foo.Bar
11:12:37 <Gracenotes> personally I would say the latter, preferably
11:13:11 <Gracenotes> otherwise you might end up like some of the crazy schemes in C or C++
11:13:28 <Taneb> tabemann, always Foo.Bar
11:13:36 <Gracenotes> by qualification, though, I mean only ever use "import qualified Foo.Bar as Bar" or "import Foo.Bar (baz, quux)"
11:14:10 <tabemann> another question
11:14:19 <Gracenotes> if possible and convenient.. sometimes it is not convenient. (e.g. for internal modules)
11:14:47 <tabemann> when you do import Foo (Bar), do you get just type constructor Bar or do you automatically get all its data constructors (if they are exported)?
11:16:58 <monoidal> tabemann: only the type constructor
11:17:37 <Gracenotes> use ellipses for data constructors
11:17:40 <Gracenotes> for all
11:18:50 <tabemann> okay, I knew that applied to exporting but wasn't sure about importing
11:19:09 <Gracenotes> what is this? PHP?!
11:19:14 <CHIKO> !chk 4569632659823 0215 369
11:19:53 <tabemann> I just like checking to make sure things I think I know actually are so before using them
11:19:54 <Gracenotes> someone's stealing credit card info
11:20:06 <Gracenotes> bad chiko
11:22:07 <tabemann> what is the purpose of doing !chk in this channel, though? is there some bot in here listening for that?
11:22:25 <tabemann> and why would you put that bot in here, rather than in some more private channel devoted to the purpose?
11:22:37 <Gracenotes> I expect there is a more private channel devoted to that purpose.
11:22:38 <tabemann> well maybe because no one would know who is the bot
11:22:40 <geekosaur> not legitimately, but I'd not be surprised if people like that hide bots in random channels
11:23:20 <Gracenotes> It is great to see Haskell interest from many different walks of life, but that does include idiots who can't use mIRC properly.
11:23:52 <geekosaur> easier to hide the bot, less risk of someone shutting the channel down on them
11:24:24 <Gracenotes> not like that's a bad thing either, unless you're determining the validity of stolen credit card info.
11:24:30 <efie> 'data Foo a b = ... ' - is it correct to say that "type Foo is polymorphic in a and b", or how is this said correctly?
11:24:55 <geekosaur> which is probably what they were doing; I can't imagine a legitimate check would require hiding it in a random channel
11:25:08 <Gracenotes> you could say Foo is a type constructor with two type arguments, a and b
11:25:20 <geekosaur> sadly the /whowas info for that user is probably not useful for tracking them down
11:25:47 <Gracenotes> though if you say polymorphic, people will know what you mean, if you say Foo is a type constructor (rather than a type).
11:27:00 <efie> Gracenotes: so "type Foo a b is polymorphic in a and b" would be better?
11:27:28 * hackagebot fingertree 0.1.0.0 - Generic finger-tree structure, with example instances  http://hackage.haskell.org/package/fingertree-0.1.0.0 (RossPaterson)
11:27:31 * hackagebot hath 0.0.1 - Hath manipulates network blocks in CIDR notation.  http://hackage.haskell.org/package/hath-0.0.1 (MichaelOrlitzky)
11:28:12 <Gracenotes> hm, sounds good to me. polymorphism is a pretty flexible word :)
11:28:33 <tabemann> I'm used to in, say, the OO world the term "polymorphism" having a *very* different meaning
11:34:07 <eikke> has anyone ever written a conduit sink with reconnecting capabilities?
11:34:28 <Fuuzetsu> ‘polymorphic’ is pretty polymorphic~
11:37:29 * hackagebot http-attoparsec 0.1.0 - Attoparsec parsers for http-types.  http://hackage.haskell.org/package/http-attoparsec-0.1.0 (TeroLaitinen)
11:51:14 <harrison> what was the name of beethoven's favorite dog?
11:52:48 <askalski> why
11:52:57 <askalski> do stuff <- [1..3] does not work?
11:53:18 <geekosaur> under what circumstances?
11:53:22 <sipa> you're likely not inside the list monad
11:53:27 <geekosaur> ^^
11:53:33 <tabemann> my thought there too
11:54:00 <monoidal> askalski: do stuff <- [1..3] only? the last statement of "do" must be an expression, that follows from translation to >>=
11:54:33 <geekosaur> you can't arbitrarily switch monads in mid-expression (a do "block" is really a single expression), if you are in an expression with (say) an IO type you can't expect things that require the list monad to work
11:54:47 <geekosaur> or that, yes
11:55:24 <sipa> if the above explanations don't help, please paste the actual full code you're trying to conpile/run on hpaste.org
11:56:20 <arcatan> 1
11:56:20 <askalski> http://hpaste.org/89557
11:56:21 <askalski> ok, so
11:56:29 <askalski> without line stuff
11:56:31 <askalski> works
11:56:32 <askalski> with it
11:56:34 <askalski> no work
11:56:57 <askalski> I am dying to try to force some order of execution
11:56:59 <askalski> so I can debug
11:57:14 <geekosaur> GraphStruct doesn't appear to be a monad?
11:57:21 <tabemann> what is a GraphStruct?
11:57:25 <askalski> nope
11:57:28 <askalski> it's just a struct
11:57:39 <askalski> data SubGraphStruct = SubGraph (Int, Int) (Array (Int, Int) Int)
11:57:39 <askalski>         deriving (Show)
11:57:39 <askalski>         
11:57:39 <askalski> data GraphStruct = Graph Int Int (Array (Int, Int) SubGraphStruct)
11:57:39 <askalski>         deriving (Show)
11:57:52 <geekosaur> then why would you expect a monadic action to work with it?
11:58:29 <askalski> you mean that every single data type that will be used in monad must be somehow enchanted?
11:58:52 <geekosaur> no
11:58:59 <tabemann> if you want to bind a value to a name inside a monad which isn't taking a value out of another monad, you use let x = ...
11:59:07 <geekosaur> but the *result* type must have a monad, if you're going to use monadic actions
11:59:31 <tabemann> and if you want to put a non-monadic value inside a monad there, you have to use return
11:59:40 <askalski> I don't know what I want. initial version was without "Do " at all
11:59:48 <tabemann> then take out the do
12:00:00 <monoidal> askalski: you can force some order of evaluation using seq
12:00:03 <askalski> tabemann, well' then it's impossible to debug
12:00:13 <askalski> it's a quite complicated code
12:00:16 <geekosaur> not completely; see Debug.Trace
12:00:24 <askalski> been tehre, done tat
12:00:25 * tabemann was about to suggest that
12:00:43 <askalski> lazy evaluation kills the idea
12:00:44 <geekosaur> if you want to be able to use IO actions, you need to use Debug.Trace or you need to put the function in the IO monad
12:01:04 <geekosaur> you cant just suddenly start using do notation or IO actions in a random pure function
12:01:10 <askalski> so the "trace" killed it?
12:01:11 <monoidal> trace("relaxing " ++ show (ti, tj, i)) (!) relaxedPivotCol ti
12:01:14 <monoidal> may I suggest
12:01:17 <monoidal> trace("relaxing " ++ show (ti, tj, i)) ((!) relaxedPivotCol ti)
12:01:57 <askalski> I removed "trace(..." at all, still the same error
12:02:18 <tij_> So I created a quick Rock Paper Scissors program to test my skills, and I'm trying to refactor it
12:02:52 <monoidal> askalski: you cannot write "stuff <- [1..3]" if the return type is not a list
12:03:11 <monoidal> do stuff <- [1,2,3]; return stuff
12:03:16 <monoidal> > do stuff <- [1,2,3]; return stuff
12:03:18 <lambdabot>   [1,2,3]
12:03:20 <tij_> I'm coming across one and a half problems: IO everywhere, and the Ord instance seems to be quadratic in terms of defining compare (is there a better way?)
12:03:27 <tij_> code is here: http://hpaste.org/89560
12:03:28 <tabemann> you want let there, even though that still doesn't really make sense
12:03:54 <monoidal> tij_: Ord is for linear orderings, RPS is not one
12:04:02 <byorgey> tij_: you can just derive Ord
12:04:03 <askalski> you see commented out lines?
12:04:04 <Gracenotes> monads are orthogonal to enforcing order of evaluation
12:04:18 <tij_> monoidal: is there a better way?
12:04:20 <Gracenotes> some monads do that, but it's not what they're for
12:04:21 <jmcarthur> tij_: that's a weird Ord instance because it's not transitive
12:04:23 <Gracenotes> if that's the confusion
12:04:34 <askalski> the stuff is pointless, I really need these temporary results to be stored
12:04:35 <byorgey> oh!  I didn't notice you were using the RPS ordering, hehe
12:04:36 <tij_> byorgey: i cant derive because the orderings loop around
12:04:37 <askalski> in the fisrt place
12:04:44 <byorgey> tij_: right, you shouldn't use Ord for that =)
12:04:55 <geekosaur> Ord won't work for that kind of thing, it's explicitly a total ordering
12:05:02 <byorgey> tij_: also, O(n^2) is O(1) when n = 3  =)
12:05:14 <jmcarthur> but okay, to your questions...
12:05:27 <tij_> byorgey: haha i know, i was just wondering if there is a better way in case i run across something similar in the future
12:05:35 <Gracenotes> askalski: I would advise using strictness annotations in the datatypes and forcing the array operations
12:05:50 <simukis_> I am not a number -- I am a free variable functional pearl is not available for free anymore (was it ever?). Is it expected?
12:06:18 <jmcarthur> tij_: you could use wildcard patterns to cut some of those down (and in this case it should be fine to do that), but in general this can be risky because when you add constructor you might not get compiler warnings for missed cases
12:06:29 <monoidal> simukis_: www.strictlypositive.org/notanum.ps.gz‎
12:06:34 <Gracenotes> askalski: as was mentioned, you can force an evaluation with seq
12:06:47 <askalski> Gracenotes, ok, I will look it up then.
12:06:49 <jmcarthur> tij_: you could remove all the EQ cases and replace them all with  compare _ _ = EQ  at the end
12:07:06 <simukis_> monoidal: thanks 😊
12:07:15 <askalski> oh
12:07:21 <askalski> is there a way to force ghci
12:07:27 <monoidal> simukis_: (not to be snarky, but that was 1st result in google search)
12:07:28 <askalski> to use a file as input?
12:07:35 <jmcarthur> tij_: you could do something clever like define a cyclic list, find the left argument in it, then see what comes next
12:07:37 * hackagebot hath 0.0.2 - Hath manipulates network blocks in CIDR notation.  http://hackage.haskell.org/package/hath-0.0.2 (MichaelOrlitzky)
12:07:45 <jmcarthur> tij_: but really, what you wrote is perfectly straightforward
12:08:08 <Gracenotes> like, using ':load'?
12:08:28 <askalski> so :l stuff.hs
12:08:29 <jmcarthur> tij_: i'm also not really bothered by the IO in your code. it's doing IO, so it needs IO.
12:08:31 <tij_> jmcarthur: yea, a cyclic list would make sense if I was dealing with tons of input types
12:08:37 <askalski> ah
12:08:40 <askalski> I mean the input to program
12:08:56 <askalski> instead of runhaskell prog.hs < data.txt
12:09:05 <tij_> jmcarthur: what about the random part - is it unnecessary IO?
12:09:06 <Gracenotes> :set args
12:09:08 <askalski> I would like to be able to pass data.txt to prog.hs while in interpreter
12:09:11 <askalski> tried, didn't work
12:09:13 <Gracenotes> oh, for piped stuff
12:09:14 <jmcarthur> tij_: maybe
12:09:23 <jmcarthur> tij_: you could use a pure generator instead of randomIO if you wanted
12:09:38 <jmcarthur> tij_: you then would only need IO to create the initial state of the generator
12:09:49 <Gracenotes> askalski: that might be tricky, because you're already using stdin to type commands to the program you're running
12:09:50 <jmcarthur> tij_: but here it doesn't look so invasive, i think
12:09:53 <monoidal> tij: parseInput ('S':_) = Just Scissor explicitly allows longer strings. Maybe you want parseInput "S" = Just Scissor?
12:10:20 <tij_> jmcarthur: how would I keep updating it? - i assume State monad, but isn't Main's "do" of IO type
12:10:44 <jmcarthur> tij_: you could either manage the generator yourself (which wouldn't be too bothersome, as it's just one value) or use MonadRandom or something
12:10:46 <igstan> Gracenotes: you said "monads are orthogonal to enforcing order of evaluation". While I agree their purpose is enforcing evaluation order, they still impose one in a do block, right?
12:10:56 <jmcarthur> tij_: but for this i think that's all overengineering
12:11:06 <igstan> Gracenotes: their purpose *isn't*. sorry
12:11:11 <monoidal> tij_: you can factor out "return $ case x of 1 -> Rock; 2 -> ..." and "putStrLn $ case ... of LT -> "You Lose!"
12:11:41 <cmccann_> monads don't enforce evaluation order in any way that plain function application doesn't also enforce
12:11:41 <jmcarthur> tij_: really, apart from the Ord instance, this doesn't look bad to me
12:11:43 <tij_> jmcarthur: oh yeah, its definitely overengineering -i was just wondering for future cases
12:11:54 <askalski> Gracenotes, ok, if there is no easy way than let's leave it
12:11:58 <tij_> jmcarthur: thanks!
12:12:03 <jmcarthur> tij_: the best thing to do in the future is context dependent
12:12:37 * hackagebot hath 0.0.3 - Hath manipulates network blocks in CIDR notation.  http://hackage.haskell.org/package/hath-0.0.3 (MichaelOrlitzky)
12:13:29 <qfwfq> What would enforcement of monoid laws look like in the typeclass definition?
12:13:34 <Gracenotes> igstan: hm, usually they require enough evaluation to get an a out of an (m a), but the a itself might be a thunk built up from previous monadic computation
12:14:59 <Gracenotes> i.e. it's a recipe for getting an a, not an actual value. and, with Haskell, recipes can get arbitrarily long...
12:14:59 <jmcarthur> qfwfq: not that it can be done in haskell, but in a more powerful language you could require some sort of proof objects along with the other methods of the type class
12:15:26 <qfwfq> jmcarthur: Hah, pretty!
12:15:34 <igstan> Gracenotes: right. the last sentence makes most sense.
12:16:04 <jmcarthur> qfwfq: the nice thing about that would be that other code could also use those proof objects in other proofs
12:18:30 <Gracenotes> some monads do enforce some degree of strictness in their internal state, like strict state monad or IO.
12:21:57 <fruitFly> what is the job market like for haskell?
12:24:08 <simukis_> fruitFly: There's not very much job compared with something like Java, but it tends to be more interesting in my opinion. (Person who knows nothing about it says with a lot of confidence 😃)
12:26:17 <jmcarthur> fruitFly: there is a tiny but attractive job market
12:26:34 <fruitFly> jmcarthur: is it possible to work remotely?
12:26:36 * tabemann gathers that Haskell isn't the kind of language one typically works in for the sake of a job
12:26:56 <FreeFull> It is good to have experience with multiple languages anyway
12:27:04 <fruitFly> tabemann: I'm not, but I'm really interested in developing these and am poo
12:27:06 <fruitFly> poor*
12:27:15 <jmcarthur> fruitFly: the haskell community is so small that perks like that are almost a requirement just to get applicants
12:27:44 <fruitFly> jmcarthur: perks like what?
12:27:46 <jmcarthur> fruitFly: which leads to a positive, which is that, despite the small number of jobs, there are also a small number of applicants
12:27:51 <jmcarthur> fruitFly: like working remotely
12:27:51 <askalski> how to make a custom "show" method to data?
12:28:17 <jmcarthur> fruitFly: the small number of applicants is a positive in the sense that you don't have much competition as an applicant, that is
12:28:26 <fruitFly> I love haskell for how it makes me elegantly think, and I think it's a useful skill I'll apply more in time, but it's an investment and I'm poor :(
12:28:33 <mauke> askalski: instance Show Foo where ...
12:28:44 <tabemann> askalski: instance Show Foo where show foo = ...
12:28:44 <askalski> mauke, to "data" it works as well?
12:28:53 <fruitFly> jmcarthur: aah, I get you , at least that's nice :)
12:28:54 <jmcarthur> fruitFly: also, most really good haskellers are good enough that they probably already have jobs they are happy with, which means if you want to hire a good haskeller you have to go out of your way to make the position attractive
12:28:56 <mauke> askalski: as opposed to what?
12:29:16 <askalski> newtype
12:29:24 <monoidal> askalski: works for both data and newtype
12:29:33 * tabemann has kind of accepted that he is going to have jobs working in languages not as neat as, say, Haskell or OCaml
12:29:38 <jmcarthur> fruitFly: but all this is a positive spin on a negative thing, that the market is very small
12:29:42 <fruitFly> jmcarthur: aah, makes sense, so then if I work my skills up maybe I could find somehting online?
12:29:51 <qfwfq> jmcarthur: I mis-read position as 'positron', and thought to myself 'surely, identity isn't all that difficult'
12:29:51 <fruitFly> jmcarthur: yeaa, I guess
12:29:54 * tabemann has a job that is in Java and is jumping ship for a (better paying) job that is in Java
12:30:19 <jmcarthur> tabemann: you could always... apply for a Haskell or OCaml job? :)
12:30:21 <mauke> are they paying you in java
12:30:22 <askalski> thanks
12:30:36 <tabemann> jmcarthur: yes, but I don't know how many of those are in the Milwaukee area
12:30:42 <tabemann> which is pretty C# heavy to begin with
12:30:45 <jmcarthur> ah, probably not many. not able to move?
12:31:01 <tabemann> I moved here from a job at NASA for family reasons...
12:31:09 <jmcarthur> ah
12:31:29 <jmcarthur> where were you before? huntsville al is my home town
12:31:31 <mauke> Haskell: it's not rocket science
12:31:38 <tabemann> Greenbelt, MD
12:31:52 <jmcarthur> (for those who don't realize, i say that because huntsville has a bunch of nasa stuff too)
12:31:57 <jmcarthur> cool
12:32:11 <fruitFly> tabemann: oh my god, I think I'm moving to Milwaukee at the end of July. I want to learn haskell while there and make some money, but there's no way I could get a haskell job there. I was thinking about trying to be a cashier or something so I could do haskell under the table. Idk maan. I'm in a rough spot
12:32:54 <tabemann> you can still program at your day job, just in something other than Haskell (as that doesn't stop you from working in Haskell on your own)
12:33:26 <jmcarthur> depending on the flexibility of the job, you may even be able to write haskell there (for example, maybe you're the only programmer there and they don't care what you use as long as you get it done)
12:33:29 <sequence> Hi, anyone have experience with signed and unsigned integer operations? I'm trying to replicate some crypto and I'm not seeing correct values.
12:34:02 <roconnor> yes
12:34:12 <mauke> sequence: yes, I have used all of the following types: char, signed char, unsigned char, int, unsigned int, long, unsigned long, size_t, unsigned long long, ptrdiff_t, ssize_t
12:34:24 <jmcarthur> ha
12:34:27 <sequence> http://hpaste.org/89562
12:34:30 <fruitFly> tabemann: thing is, I came from mech engineering and I've language hopped all my life, and now that I'm getting into haskell picking up a new language right now might make me burn out. I only really wanna make like 5-10k more to by a couple acres to start my little farm.
12:34:40 <sequence> this is what I'm doing so far, with the idea that the unsigned function will perform the "conversion"
12:35:01 <jmcarthur> sequence: i note that Int and Word32 are not necessarily the same size
12:35:13 <roconnor> sequence: are you on a 64 bit or 32 bit machine?
12:35:23 <roconnor> sequence: perhaps you might like Int32
12:35:24 <sequence> jmcarthur: noted, but the C source also "states that
12:35:36 <mauke> Int is not int
12:35:39 <sequence>   unsigned int  random;
12:35:40 <sequence>   int32_t       seed=123;
12:35:55 <FreeFull> sequence: int32_t is signed
12:35:56 <tabemann> back
12:36:09 <sequence> FreeFull: I'm aware haha
12:36:22 <jmcarthur> if you want C-like types, you could always reach for Foreign.C.Types, but that may be cheating ;)
12:36:25 <tabemann> fruitFly: what else do you know other than Haskell?
12:36:53 <sequence> jmcarthur: reaching for those types was on the list of things to try, but I thought to come here and ask first
12:37:14 <jmcarthur> so i don't really know what expectations are being violated here, first of all
12:37:32 <fruitFly> a little networking (CCENT) and A+ ... :( ... I'd take any job I can get (the lower stress the better), but I would really like to be able to learn haskell or other relevant technologies while doing it
12:37:36 <jmcarthur> Int has a loose guarantee on the number of bits it has. you can use the sized types for something tighter
12:37:37 <mauke> sequence: what's your question?
12:37:47 <fruitFly> tabemann: and actually doing a utilitarian job if possible
12:38:18 <sequence> sequence: as someone who started writing haskell two weeks ago, I'm wondering if I'm doing things right, this time w.r.t. signed and unsigned operations
12:38:26 <sequence> (yes, talking to myself was a mistake)
12:38:38 <jmcarthur> sequence: so what is this code supposed to do?
12:38:53 <sequence> take the signed seed value, convert it to unsigned, and take the modulus
12:39:08 <tabemann> I'm just used to being the sort myself that cannot see themselves doing *anything* other than programming, and which has taken other jobs in the past only due to not being able to take a programming job
12:39:09 <jmcarthur> sequence: and how is it not meeting your expectations?
12:39:23 <sequence> "test  6 fail! 122 != 12154"
12:39:26 <FreeFull> sequence: There are two modulus functions for integers though
12:39:29 <FreeFull> sequence: mod and rem
12:39:33 <jmcarthur> sequence: that doesn't tell me anything
12:39:37 <jmcarthur> sequence: what is the test?
12:39:42 <FreeFull> > (-3) `mod` 5
12:39:43 <lambdabot>   2
12:39:47 <FreeFull> > (-3) `rem` 5
12:39:48 <lambdabot>   -3
12:39:52 <jmcarthur> sequence: and why does it expect what it expects?
12:40:01 <jmcarthur> sequence: and which of those numbers is the actual and which is the expectation?
12:40:03 <sequence> FreeFull: I need the equivalent of the '%' operator
12:40:13 <FreeFull> sequence: That'd be rem then
12:40:14 <jmcarthur> sequence: rem
12:40:26 <yrlnry> Is there an operator that I can use in place of (||) that will transparently do the same thing, but execute the two arguments in parallel?
12:40:53 <mauke> where are my parallel strategies
12:40:53 * jmcarthur notes that neither mod nor rem really does what most people want most of the time. rem is the one with the fast hardware instruction on most machines, though
12:40:54 <sequence> jmcarthur: you could be right, and it could be that I'm using the unsized "Int" instead of something sized
12:41:13 <FreeFull> Int is signed, Word is unsigned
12:41:17 <fruitFly> tabemann: I'm 21, never had a programming job, only some little workstation repair ATM networking job. But I'm interested in computing and programming, hence why I'm learning haskell. But I need to make a little more money, I'd just like to be able to study haskell at the same time.... a cashier and read under the table? idk
12:41:25 <sequence> FreeFull: right, I'm aware
12:42:06 <tabemann> fruitFly: I remember at that age doing stuff like food service and, in one case, a factory job, that was before I managed to get in the Industry through taking a software verification job
12:42:14 <fruitFly> how to get haskell 7.6 on linux mint, their support page installed 7.4 ... any differences really? should I struggle to get the latest
12:42:16 <FreeFull> jmcarthur: What would be something that would be what people want, and neither mod nor rem?
12:42:28 <jmcarthur> FreeFull: when you're just learning, the differences won't matter much to you, i think
12:42:39 * tabemann has GHC 7.4.1 installed himself thanks to Debian, which doesn't have 7.6 even in testing
12:42:51 <tabemann> stupid debian, always behind on the versions...
12:43:08 <sequence> jmcarthur: the test compares what haskell computes to what the C code that I want to implement in haskell computes. the c code computes 122, the haskell computes 12154
12:43:19 <jmcarthur> fruitFly: that was meant for you, not FreeFull
12:43:30 <fruitFly> tabemann: I had a nice IT job before this managing some simple ATM networking infrastructure, but man did the office environment suck... and I DON'T like fiat :\
12:43:47 <fruitFly> jmcarthur: thanks :)
12:43:49 <jmcarthur> FreeFull: http://cdsmith.wordpress.com/2007/06/02/learning-number-theory-and-haskell-the-division-algorithm/  and see also my old and naive blog post on making this fast in haskell  http://creativelad.wordpress.com/2011/04/28/euclidean-division/
12:44:30 <FreeFull> sequence: Can you show the full C and Haskell code?
12:44:43 <jmcarthur> sequence: so is unsigned int going to be 32 bits for your C compiler?
12:44:57 <jmcarthur> sequence: if so, then you should be using Int32 and Word32
12:45:01 <sequence> probably, let me edit the hpaste
12:45:07 <FreeFull> With C, int tends to be 32-bit for x86 and x86_64
12:45:14 <jmcarthur> right
12:45:21 <tabemann> back
12:45:22 <monochrom> you can use CInt
12:45:37 <tabemann> fruitFly: by fiat, do you mean working as a contractor?
12:45:40 <jmcarthur> yeah CInt would be good if that whole goal is to just match what C would do
12:46:16 <monochrom> also CUInt for unsigned
12:46:24 <mauke> yrlnry: http://hackage.haskell.org/packages/archive/parallel/3.2.0.3/doc/html/Control-Parallel.html looks like it should be the answer
12:46:34 <mauke> but I'm not sure how to use it. x ||' y = par y x || y ?
12:46:37 <sequence> http://hpaste.org/89562
12:46:38 <sequence> brb
12:46:54 <fruitFly> tabemann: no, I mean I don't like that the majority of our businesses profit came from surcharges that propogate violent statist currency when there's more efficient means of transfering wealth
12:47:17 <monochrom> pseq (par x y) (x || y)
12:47:18 <jmcarthur> FreeFull: there's some paper somewhere that gives some reasons why euclidean division is what you usually want, but i don't remember its name
12:47:46 <monochrom> hmm, that may be wrong
12:48:12 <jmcarthur> FreeFull: ah, it's this http://biblio.ugent.be/input/download?func=downloadFile&fileOId=452146
12:48:38 <shachaf> x `par` y `pseq` (||) x y
12:49:07 <shachaf> Those operators are infix so that's parsed as "par x (pseq y (x || y))"
12:49:11 <sequence> back
12:49:23 <shachaf> But I think it would actually work with either associativity.
12:50:07 <monochrom> par x (pseq y (x || y)) agrees with the example in GHC user's guide
12:50:22 <tabemann> okay, I've got a bit of a question - is there any efficiency between, say, having a function Ptr GLfloat -> Int -> V4 Float -> IO () which does a realToFrac internally and a function Ptr b -> Int -> V4 a -> (a -> b) which you pass a conversion function, like realToFrac or fromIntegral, to?
12:50:22 <tabemann> *efficiency difference
12:50:24 <tabemann> there should be a -> IO () at the end of the last
12:51:16 <fruitFly> tabemann: thanks for listening :)
12:52:40 <shachaf> Note that both of these are a different matter from e.g. lub.
12:53:07 <jmcarthur> tabemann: it depends, but due to inlining and specialization it will often be basically the same in terms of efficiency
12:53:58 <jmcarthur> tabemann: what is the Int parameter for? a number of vertices to write to the Ptr?
12:54:03 <FreeFull> jmcarthur: What's the difference between the euclidean mod and the mod Haskell has?
12:54:58 <jmcarthur> FreeFull: the links i gave you explain it
12:56:02 <jmcarthur> FreeFull: in particular, here is euclidean remainder http://hpaste.org/89564
12:56:11 <jmcarthur> in terms of rem
12:59:49 <FreeFull> jmcarthur: Ah, it seems eucRem is always positive
13:00:04 <FreeFull> I see why you say it's what people always want now
13:04:49 <tabemann> is someone DDOSing FreeNode again?
13:07:13 <FreeFull> tabemann: Possibly
13:07:59 <simukis_> ech… I thought it was only me.
13:08:12 <tabemann> things got suddenly very unresponsive to me, and when I tried reconnecting it was *very* slow (and unresponsive)
13:08:22 <tabemann> and sometimes reconnecting failed and it has to try again
13:08:41 <jmcarthur> FreeFull: yeah. very useful when dealing with things like indices
13:09:00 <simukis_> for me it was just saying I was already connected. As I usualy not identify that was very scary 😃
13:09:15 <tabemann> did anyone see my question about the efficiency of in-place realToFrac versus one passed in as a function?
13:09:17 <simukis_> so… why (!!) is not a part of some class like Subscriptable?
13:09:26 <jmcarthur> tabemann: it depends, but due to inlining and specialization it will often be basically the same in terms of efficiency
13:09:30 <jmcarthur> tabemann: what is the Int parameter for? a number of vertices to write to the Ptr?
13:09:38 <tabemann> it's an index into an array
13:10:07 <jmcarthur> ah a ptr offset
13:10:42 <jmcarthur> tabemann: does you function differ from pokeElemOff at all?
13:10:45 <jmcarthur> *your
13:10:53 <jmcarthur> or perhaps pokeByteOff
13:11:47 <tabemann> jmcarthur: the difference is because I'm writing whole vectors or matrices at a time
13:12:20 <tabemann> and I can't just peek or poke them, even though they're Storable, because I need to convert each entry into GL types in the process
13:12:54 <tabemann> for instance, I'm writing M44 Float into a Ptr GLfloat
13:13:32 <jmcarthur> tabemann: so it's    \ptr off -> pokeElemOff ptr off . fmap realToFrac   ?
13:14:58 <tabemann> I have one other problem, which is because M44 is row-first, but I need to write it in columns-first order for OpenGL
13:15:20 <tabemann> I'd forgotten that the linear types are functors, which would simplify my code quite a bit, but there's still that
13:15:36 <tabemann> I could at least simplify my vector code that way
13:18:20 <supki_> simukis_: does not look very useful
13:18:31 <supki_> simukis_: there are generalizations of !! though
13:19:17 <jmcarthur> tabemann: can't you just switch the argument positions of your vector-matrix multiplies in the shader?
13:19:29 <simukis_> supki_: well it could be used for maps, sets and bunch of other containers.
13:19:48 <jmcarthur> tabemann: that way you can just use row major everywhere
13:20:46 <tabemann> okay, just checked
13:21:22 <tabemann> the glUniformMatrixNfv where N is one of 2, 3, 4 four take an argument that allows you to transpose your matrix automatically
13:21:30 <supki_> > [1..10] ^? ix 5
13:21:30 <jmcarthur> or that
13:21:32 <lambdabot>   Just 6
13:21:35 <supki_> > Seq.fromList [1..10] ^? ix 5
13:21:37 <lambdabot>   Just 6
13:21:37 <jmcarthur> didn't know about that
13:21:49 <supki_> simukis_: take a look at Control.Lens.At
13:21:50 <jmcarthur> i think i may have at one time
13:22:15 <tabemann> s/four//
13:22:22 <FreeFull> Lenses are magic
13:23:36 <simukis_> supki_: can't seem to find a package of this module.
13:23:46 <supki_> lens =)
13:24:25 --- mode: cameron.freenode.net set +o ChanServ
13:25:16 <simukis_> I should stop looking for packages with hoogle one day…
13:26:20 <tabemann> another question I should know the answer of:
13:26:30 <tabemann> does this type make sense
13:26:40 <tabemann> convertPoke :: (Functor f, Storable f) => Ptr b -> IO -> f a -> (a -> b) -> IO ()
13:27:17 <tabemann> whoops
13:27:22 <simukis_> supki_: So yeah, it's something in that direction. It still would be better off in Prelude though. And as a relative beginner I think there a lot of other places where usefulness of typeclasses are not exploited.
13:27:23 <tabemann> that should be Int not the first IO
13:28:20 <shachaf> Type classes are overrated and when people learn Haskell they tend to want to use them everywhere, including generally inappropriate places.
13:28:28 <tabemann> or should that be Storable (f a)?
13:30:01 <tabemann> at least in what I've written so far in Haskell, the only place I've felt a need to add a type class was when I had a whole bunch of types I wanted to convert to a GLenum and I wanted just one function to do this, rather than having a separate function for each type
13:30:47 <jmcarthur> tabemann: that would need to be Storable (f a), since Storable applies to types and not type constructors
13:31:03 <tabemann> jmcarthur: that's what I was thinking
13:31:17 <jmcarthur> err
13:31:25 <jmcarthur> tabemann: actually, it would need to be Storable (f b)
13:31:33 <tabemann> right
13:32:23 <neutrino1> hi
13:32:33 <tabemann> I just couldn't remember seeing a case of a type constructor being applied to the left of => to a type constructor variable itself applied to a different type variable
13:32:44 <tabemann> whoops
13:32:51 <tabemann> *a case of a type class being
13:33:42 <neutrino1> say i have an api web server. i would like to call the api exposed by server 2 from server 1. would it be feasible to create a monad such that depending on the instance it's either a call over http, or the sources get pulled in and the api call happens within my binary?
13:33:49 <jmcarthur> tabemann: it happens occasionally, although it always feels ugly to me
13:33:55 <neutrino1> hi jmcarthur
13:34:22 <mauke> data II a = I (a (II Maybe)) | I' (a Int)
13:34:52 <jmcarthur> mauke: ?
13:35:09 <mauke> it means nothing
13:35:23 <neutrino1> the goggles
13:41:45 <tabemann> aagh just realized my convertPoke only works on vectors, and not on matrices anyways
13:42:11 <tabemann> because say type M44 a = V4 (V4 a)
13:42:29 <tabemann> M44 isn't a newtype and thus doesn't have its own instances of Functor or Storable
13:43:15 <tabemann> I'll need to create a separate function for converting and poking matrices
13:44:10 <shachaf> It sounds to me like the right thing to do is your own type.
13:46:00 <tabemann> I did figure out how to create a function that'll handle matrices while still being as abstract as possible
13:46:35 <tabemann> I wouldn't want to use my own type as I don't want to have to convert away from the types used by Data.Linear or end up reimplementing what is in it
13:48:21 <tabemann> convertPokeNested :: (Functor f, Functor g, Storable (f (g b))) -> (a -> b) ->
13:48:21 <tabemann>                      Ptr b -> Int -> f (g a) -> IO ()
13:48:22 <tabemann> convertPokeNested convert valuesPtr index =
13:48:22 <tabemann>   pokeElemOff valuesPtr index . fmap (fmap convert)
13:48:27 <tabemann> this seems ugly somehow
13:50:18 <tabemann> whoops
13:50:24 <tabemann> that first -> should be =>
13:57:44 * hackagebot standalone-haddock 1.1 - Generate standalone haddock documentation for a set of packages  http://hackage.haskell.org/package/standalone-haddock-1.1 (RomanCheplyaka)
13:57:46 * hackagebot standalone-haddock 1.1.1 - Generate standalone haddock documentation for a set of packages  http://hackage.haskell.org/package/standalone-haddock-1.1.1 (RomanCheplyaka)
13:59:09 <FreeFull> 1.1.1.1.1
13:59:49 <osa1> I can't run hdevtools, it fails with "resource busy: address in use" error. any ideas?
14:00:45 <tabemann> that sounds like something else might be binding to the same port on your machine
14:21:08 <tabemann> http://rwmj.wordpress.com/2011/09/21/which-foreign-function-interface-is-the-best/ << This article claims that the Haskell FFI is hard to understand, but I for one have had no trouble wrapping my brain around it
14:22:19 <tabemann> also I don't see what's bad about his example except that he chose to stuff all that code on one line, and use the $ \p -> form with withForeignPtr
14:23:06 <aristid> FreeFull: there's no reason to ever deviate from that numbering scheme
14:23:26 <FreeFull> aristid: Unless you believe in ultrafinitism
14:23:51 <aristid> FreeFull: ultrafinitism is bizarre :)
14:24:09 <FreeFull> aristid: Well, how about this: unary numbers are really inefficient to store as unary
14:24:29 <aristid> FreeFull: meh, mere practical details
14:24:41 <aristid> this is art in the form of software version numbers!
14:25:28 <FreeFull> n for unary vs floor(log_2(n)) for binary
14:25:33 * tabemann googles ultrafinitism, and cannot help but agree on the bizarre point
14:30:54 <external-reality> (defun haskell-log-tail ()
14:30:55 <external-reality>        (with-current-buffer "*haskell-process-log*"
14:30:55 <external-reality>        (goto-char (point-max))
14:30:55 <external-reality>        (walk-windows (lambda (window)
14:30:58 <external-reality>                     (if (string-equal (buffer-name (window-buffer window)) "*haskell-process-log*")
14:31:02 <external-reality>                         (set-window-point window (point-max))))
14:31:05 <external-reality>                         nil
14:31:08 <external-reality>                      t)))
14:31:11 <external-reality> ugg
14:31:39 <external-reality> anyway just thought I share the way I tail the *haskell-process-log* in haskell-mode emacs
14:36:32 <jmcarthur> tabemann: yeah, i am especially surprised that in his eyes haskell lost to all those languages that require you to write awkward C code
14:37:27 <tabemann> jmcarthur: I'm used to in practically all other languages I've written FFI code in having to drop down into C to write binding code; Haskell's the first language I've seen that allows you to write binding code in the language itself
14:38:52 <tabemann> what was also weird was that his example of "bad things one has to do to bind code in Haskell" was not bad at all
14:39:05 <tabemann> aside from his own choice of syntax
14:39:40 <koala_man> C# allows the same thing
14:40:09 <harrison> https://code.google.com/p/opengloberon/source/browse/
14:40:20 <fizbin> @type let f x y = fromInteger (((toInteger x)*(toInteger (y `asTypeOf` x))) `div` (maxBound `asTypeOf` x)) `asTypeOf` x in f
14:40:21 <lambdabot>     No instance for (Bounded Integer)
14:40:21 <lambdabot>       arising from a use of `maxBound'
14:40:22 <lambdabot>     Possible fix: add an instance declaration for (Bounded Integer)
14:40:30 <harrison> oberon FFI in oberon
14:41:35 <merijn> tabemann: The more FFI code I write in haskell, the more I love the person who designed haskell's FFI
14:41:46 <tabemann> the only bad thing I can personally think about the Haskell FFI is just *how* does one interface with things that require one to pass in (or pass pointers to) arbitrary structs, other than manually poking these structs together by hand
14:41:55 <merijn> tabemann: Most system/standard library calls don't even require writing wrapping code :)
14:42:25 <hpc> tabemann: on a theoretical level? the FFI provides the glue
14:42:33 <merijn> tabemann: hsc2hs, c2hsc and a bunch of other tools can (mostly) auto-generate the peek/poke wrappers for you if you have to work with arbitrary structs
14:42:46 * hackagebot fficxx 0.1 - automatic C++ binding generation  http://hackage.haskell.org/package/fficxx-0.1 (IanWooKim)
14:42:48 * hackagebot fficxx 0.1.0 - automatic C++ binding generation  http://hackage.haskell.org/package/fficxx-0.1.0 (IanWooKim)
14:42:49 <tabemann> merijn: oh okay
14:42:50 * hackagebot fficxx-runtime 0.1 - Runtime for fficxx-generated library  http://hackage.haskell.org/package/fficxx-runtime-0.1 (IanWooKim)
14:42:57 <hpc> oh, arbitrary structs...
14:43:45 <merijn> tabemann: For really simple things you an use c2hsc to generate the boilerplate hsc code and then use hsc2hs to generate the Storable instance that converts your arbitrary struct to a haskell datatype
14:44:18 <merijn> tabemann: It is signifcantly more annoying that just importing and using, but that's not saying much, as that is pretty easy and un-annoying :p
14:44:29 <ion> bindings-dsl is a great set of macros for FFI, too.
14:45:06 <merijn> ion: c2hsc takes header files/C code and uses bindings-dsl to generate hsc for you :p
14:46:17 <tabemann> I'll have to remember that next time I actually have to bind any C code
14:46:42 <tabemann> at least at this point I'm main just marshaling OpenGLRaw stuff, which is like writing bindings with the lower-level C binding already done
14:53:08 <augur> whats an efficient way to build a hashmap progressively by scanning files?
14:53:52 <k0ral_> are 'par' and 'pseq' effective with IO expressions ?
14:53:59 <Eridius> is something wrong on my end, or is GHC 7.6.3 (which is what the current Haskell Platform provides) not compatible with existing popular software?
14:54:10 <k0ral_> all examples I found are about pure computations
14:54:15 <Eridius> for example, it can't build utf8-string-0.3.7, which means I can't install pandoc
14:54:39 <ion> k0ral: Look at the async package for IO concurrency.
14:55:10 <ion> I’m not sure if you’re looking for concurrency or parallelism, though.
14:55:16 <wavewave>  I just uploaded my fficxx library (which is automatic haskell- C++ binding generator) on hackage now.
14:55:39 <ion> cool
14:55:58 <Michae___> is there a way to check thee equality of a construcotr for an ADT, but not the value contained? For example, if I have data Foo = Foo Int | Bar Int | Baz Int, (Foo 1) == (Foo 2) would return true?
14:56:08 <k0ral_> I think I'm looking for parallelism
14:56:37 <k0ral_> I have a list of IO computations to perform that are all independent
14:56:51 <k0ral_> order doesn't matter
14:57:02 <k0ral_> I just need them to be all performed
14:57:39 <mauke> async++
14:57:50 <thoughtpolice> k0ral_: use async
14:58:21 <k0ral_> I'll look at async, but still, is that feasible with par/pseq ?
14:58:33 <k0ral_> out of curiosity
14:59:00 <ion> par/pseq only affect the evaluation of Haskell values, not the execution of IO actions.
14:59:21 <genisage> Michae___: sure, just do something like (==) (Foo _) (Foo _) = True; (==) (Bar _) (Bar _) = True; (==) _ _ = False
14:59:42 <ion> Foo _ == Foo _ = True; Bar _ == Bar _ = True; _ == _ = False
14:59:46 <Michae___> gensisage: Is it possible to do it without defining them manually?
15:00:07 <genisage> Not that I know of.
15:00:19 <ion> That Eq instance is a bit evil, though.
15:04:00 <roconnor> ion: that Eq instance is pretty good compared to many equality definitions in popular programming languages.
15:04:39 <FreeFull> Obviously two things are only equal if the pointers are equal
15:07:05 <yrlnry> Is there an emacs package that will detect when the GHCi single-step debugger prints something like "[Polynomial.hs:36:17-70]" and highlight the appropriate range of the code automatically?
15:07:09 <yrlnry> I searched but did not find.
15:08:15 <roconnor> if an Eq instance is symmetric and transitive, I'm happy.
15:08:25 <roconnor> I have low standards
15:08:44 <roconnor> it would seem most untyped languages do not have transitive equality.
15:09:41 <shachaf> You mathematicians and your fancy "equivalence relations".
15:09:47 <sipa> roconnor: sqrt(-1) != sqrt(-1) FTW
15:09:51 <sipa> (C)
15:10:00 <roconnor> shachaf: I'm willing to drop reflexivity.
15:10:04 <roconnor> I'm looking at you NaN.
15:10:09 <shachaf> let x = 0/0 in x == x -- Yep.
15:10:54 <roconnor> I'm a big fan of partial equivalence relations.
15:11:06 <roconnor> I was surprised how long you can live without reflexivity.
15:11:40 <roconnor> I'd like to find a book that works out everything about PERs
15:11:46 <roconnor> so I don't have to reinvent it all
15:12:52 <johnw> roconnor: have you seen http://jupiter.math.nctu.edu.tw/~weng/courses/2011_topic_discrete/9_poset.pdf?
15:14:09 <shachaf> johnw: Does that actually talk about partial equivalence relations?
15:14:28 <johnw> maybe not
15:14:31 <shachaf> It seems to talk about equivalence relations and partial orders (both of which have reflexivity).
15:14:35 <johnw> ah
15:15:09 <shachaf> Anyway, we're trying to get real-world work done here. We don't need this ivory-tower "transitivity" nonsense.
15:15:23 <johnw> what real-world work are you doing?  lens?? :)
15:15:35 <FreeFull> Let's all get down to machine code
15:15:39 <FreeFull> That's the only way to do real work
15:15:50 <FreeFull> You can't trust all those assemblers and compilers and interpreters
15:16:05 * hodapp hits FreeFull with a chair
15:16:25 * FreeFull explodes into a thousand tiny lambdas
15:16:47 <hodapp> errr...
15:17:52 <BMeph_> You are in a cave, with lots of little twisty lambdas, all alike.
15:17:53 <augur> whats a good regex lib?
15:18:00 <hpc> parsec
15:18:01 <hpc> ;)
15:18:14 <roconnor> using regex is a mistake.  Unless you are doing graph theory.
15:18:23 <FreeFull> perl
15:18:27 <johnw> augur: have you seen rex?
15:18:43 <augur> johnw: nup
15:18:56 <augur> roconnor: as it happens, what im doing is related to graph theory :)
15:19:07 <roconnor> carry on then.
15:19:25 <mauke> there's nothing wrong with regex
15:19:35 <augur> roconnor: but really, all i need to do is let the user specify a pattern and then read in a whole bunch of files, extracting portions given the pattern
15:19:42 <roconnor> regular expressions should only be used to denote sets of paths through labeled graphs.
15:19:57 <mauke> regexes aren't regular expressions
15:20:07 <roconnor> heh
15:20:18 <augur> roconnor: thats a weird position to take
15:20:37 <roconnor> I like taking weird positions;  I'm a constructivist
15:20:50 <augur> yeah but thats an especially weird position to take
15:21:06 <augur> i mean, regular expressions are a convenient notation for regular languages
15:21:11 <int-e> not really, a (edge-)labelled graph is a finite automaton
15:21:26 <augur> int-e: so are regular expressions
15:22:20 <roconnor> augur: a regular language is just a language interpreted by a labeled graph.
15:22:51 <hodapp> in b4 "now you have two problems"
15:22:53 <joelteon> would you guys recommend attoparsec or parsec for parsing a programming language?
15:22:53 * hodapp runs away
15:23:11 <augur> roconnor: yes
15:23:21 <roconnor> or maybe more to the point the "language" accepted by a regular language is really just a series of paths through a labled graph
15:23:58 <int-e> And then there are "regexes" that don't describe regular languages (I blame Perl, but that may be unjustified.).
15:23:58 <augur> the language accepted by a finite state machine can be seen as the set of paths through the machines state space
15:24:00 <augur> sure.
15:24:23 <int-e> which I think is what mauke was getting at.
15:24:42 <tabemann> okay random question: what does a *double bang* in a type definition indicate?
15:24:44 <roconnor> I guess my point is that these "languages" are not particularly suitable for searching through documents or whatnot.
15:25:10 <augur> roconnor: they can be pretty suitable
15:25:14 <tabemann> (I just saw this in Data.ByteString.Internal)
15:25:27 <joelteon> parsec it is!
15:25:33 <augur> roconnor: im using them to process irc logs
15:32:45 <joelteon> I hate when examples don't typecheck, that's why I never use parsec
15:32:48 * hackagebot java-bridge 0.20130606.3 - Bindings to the JNI and a high level interface generator.  http://hackage.haskell.org/package/java-bridge-0.20130606.3 (JulianFleischer)
15:32:50 * hackagebot imm 0.6.0.0 - Retrieve RSS/Atom feeds and write one mail per new item in a maildir.  http://hackage.haskell.org/package/imm-0.6.0.0 (koral)
15:34:40 <hpc> joelteon: i hate when examples aren't updated with the API, that's why i learned parsec from haddock ;)
15:35:35 <joelteon> heh
15:37:54 <mauke> int-e: backreferences are much older than perl
15:38:33 <gertc> http://hpaste.org/89565
15:38:45 <augur> is there a database-like datastructure?
15:39:17 <gertc> what does the error mean? i was trying to replace liftIO with lift
15:39:41 <augur> i dont need an actual DB but i need something that lets me have data in a DB-like fashion
15:40:12 <gertc> did you try acid-state?
15:41:06 <augur> gertc: is it for efficient DB-like systems? with tables and indexed lookups etc?
15:41:24 <gertc> yes
15:41:46 <gertc> but uses haskell data types
15:41:51 <mauke> I thought that was something else
15:42:09 <augur> it looks like its not for that, gertc
15:42:46 <mauke> http://hackage.haskell.org/package/ixset-1.0.5
15:43:51 <augur> mauke: that seems about right
15:45:56 <aristid> augur: there's also a package called "tables".
15:46:19 <augur> oh god tables
15:46:31 <augur> thats edwardk's big data thing isnt it!
15:46:33 <augur> D:
15:46:34 <aristid> no
15:46:37 <aristid> that's analytics
15:46:52 <augur> oh ok
15:46:53 <augur> phew
15:46:58 <aristid> it's also from edwardk though, and recently Taneb it seems
15:47:06 <tabemann> I have yet another question: how do you finalize a value in Haskell, for instance, I have an ID for a shader, and I want to call glDeleteShader when I am doing with it
15:47:47 <merijn> tabemann: implement something like bracket?
15:48:39 <tabemann> merijn: not that kind of finalization
15:48:44 <tabemann> I mean, when something goes out of scope
15:49:12 <merijn> Yes, you can't really do that. Unless you check the scope and the only way to do that is something bracket like
15:49:42 <timp_> Can I dump the definitions I have typed in at ghci prompt to a file?
15:49:43 <merijn> "withGlShader :: (ShaderId -> IO ()) -> IO ()" or something
15:50:15 <hpc> perhaps http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-Mem-Weak.html#v:addFinalizer
15:50:39 <hpc> i havent read enough docs to know if it actually does what you want, but it has the right name
15:51:23 <gertc> http://hpaste.org/89565 why does only liftIO works?
15:51:34 <tabemann> merijn: hmm... I'm not sure if I want to do that
15:52:04 <tabemann> especially because I realized that if a Shader was added to a Program but then went out of scope while still in use by the program, it may have unintended effects
15:52:05 <augur> man this thing uses lens
15:52:09 <augur> aristid: im so confused D:
15:52:13 <int-e> timp_: I don't think so, though you might be able to salvage them from ~/.ghc/ghci_history after quitting ghci
15:52:59 <aristid> augur: of course it uses lens.
15:53:12 <augur> i think tables is probably overkill to be honest. i bet Map and Set will be fine
15:53:13 <augur> we'll see
15:53:20 <aristid> Data.Map
15:53:27 <aristid> or Data.HashMap ?
15:53:38 <FreeFull> tabemann: I wonder if you could do something like the ST monad to prevent the shader from being accessed outside of your monad
15:53:40 <augur> map
15:53:52 <augur> actually map and list, i dont need set really
15:54:00 <timp_> int-e: thanks
15:54:03 <aristid> ok, so Data.Map.Map
15:54:13 <tabemann> FreeFull: except that would result in even more layering of monad transformers (it'd have to be a monad transformer)
15:54:26 <tabemann> as I am already likely to end up using at least a StateT monad transformer
15:54:44 <hpc> tabemann: clearly you need decepticons
15:55:16 <geekosaur> gertc, liftIO lifts as many levels as necessary to find the IO; I'd imagine that lift isn't lifting far enough
15:55:34 <geekosaur> but I don't know what you're working with, nowhere near enough information there
15:56:39 <gertc> ok but can i do stuff like this then lift $ lift $ ... until it compiles?
15:56:48 <int-e> geekosaur: WebSockets has a MonadIO instance but is not a monad transformer. (assuming it's this one: http://hackage.haskell.org/packages/archive/websockets/0.7.3.0/doc/html/Network-WebSockets.html )
15:56:54 <int-e> hmpf
15:56:57 <int-e> gertc:
15:57:01 <gertc> yes
15:57:11 <int-e> so no, you can't.
15:57:50 * hackagebot entropy 0.2.2.1 - A platform independent entropy source  http://hackage.haskell.org/package/entropy-0.2.2.1 (ThomasDuBuisson)
15:57:53 <gertc> a ok so when using MonadIO lift does not work anyway
15:58:47 <int-e> gertc: there are cases where both work. Most monad transformers have a MonadIO instance of the shape  MonadIO m => MonadIO (TheTransformer m)
15:59:27 <int-e> so that for TheTransformer IO  lift and liftIO become interchangable.
16:00:27 <int-e> but WebSockets is not a monad transformer; its kind (* -> *) is wrong for the MonadTrans class (a monad transformer has kind (* -> *) -> * -> *). That's the error you get.
16:02:04 <int-e> (One last note: In the  TheTransformer IO  case, while lift and liftIO are interchangable, the  lift  is tied to  TheTransformer transformer,  while the liftIO is tied to the whole TheTransformer IO monad.)
16:02:50 * hackagebot cipher-aes128 0.3.2.1 - AES128 using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.3.2.1 (ThomasDuBuisson)
16:07:21 <gertc> is it possible to write every monad transformer into a monadIO so we only have one lift thing?
16:07:59 <johnw> gertc: the layers library has a polymorphic lift
16:08:17 <johnw> plus, MonadIO gives you liftIO
16:10:03 <gertc> somehow i would find it nice if there was a rule that before it can be a MonadIO it has to be a monda transdormer first so you can always use lift?
16:10:19 <hpc> that would be unhelpful
16:10:34 <hpc> MonadTrans and MonadIO have different kinds
16:10:34 <johnw> IO is an instance of MonadIO, but is not a transformer
16:10:48 <hpc> and i have used MonadIO instances before that do not have the right kind for MonadTrans
16:10:54 <hpc> and have even written one or two
16:11:17 <gertc> ok
16:11:19 <Toxaris> gertc: I think that MonadIO is more like MonadReader than like MonadTrans
16:11:44 <gertc> ok
16:12:00 <gertc> thx
16:13:34 <cjhanks1> Do any of the Haskell web frameworks actually work?
16:13:57 <hpc> nope; haskell programmers have a fetish for uploading broken code :P
16:14:10 <hpc> we're even worse than wordpress
16:14:20 <mauke> worstpress
16:14:49 <cjhanks1> Is it sarcasm?  Some of the libraries I have used in the past worked fine.
16:15:01 <hpc> that was sarcasm, yes
16:15:11 <cjhanks1> It really came through.
16:15:15 <hpc> i am working on a project with happstack and it works amazingly
16:15:22 <cjhanks1> Then just say that.
16:15:36 <gertc> you also have yesod
16:15:41 <mauke> cjhanks1: your attitude is weird
16:15:41 <hpc> and snap
16:16:12 <cjhanks1> gertc: I am convinced Yesod dependency chain has a conflict at this point.
16:16:32 <johnw> our company's website is based on Yesod
16:16:52 <johnw> if you think there is a dependency chain conflict, I would be interested to hear about it
16:16:53 <gertc> pleas post it on github he will fix it
16:17:10 <johnw> however, just today I wiped my .ghc and .cabal/lib, and built git-annex from scratch (which depends on yesod), and there were no conflicts or issues
16:17:29 <hpc> i am testing a cabal-dev install yesod with ghc-7.4.1
16:24:07 <aristid> hpc: debian? :P
16:24:25 <hpc> aristid: yes, but built from source and just an old install
16:24:32 <aristid> hpc: oO
16:24:50 <hpc> this was my "hmm, i should learn to build ghc" install
16:26:38 <aristid> and the head programming czar succeeded \o/
16:28:09 <hpc> yesod takes a long time to build on my craptop...
16:30:23 <monochrom> I built from source recently too. just because of gmp3 vs gmp10. I'm using ubuntu
16:31:08 <hpc> yay, finally made it to building yesod modules
16:31:26 <monochrom> yesod and dependency is pretty large, yes
16:31:40 <monochrom> did you try "cabal install -j2"?
16:31:51 <aristid> monochrom: you probably didn't built ghc 7.4.1 from source?
16:31:53 <johnw> or just -j
16:32:02 <hpc> monochrom: you really don't appreciate how crappy my craptop is
16:32:08 <monochrom> I used ubuntu's 7.6.2 to build 7.6.3
16:32:14 <hpc> -j2 is my entire cpu
16:32:24 <aristid> monochrom: excellent
16:32:27 <aristid> hpc: then do that
16:32:34 <hpc> too late, it's done
16:32:39 <monochrom> hehe
16:32:42 <aristid> hpc: revert it!
16:32:50 <hpc> nope :P
16:33:03 <hpc> well, that only took 15 minutes
16:33:38 <monochrom> then I attempted using 7.6.3 to build 7.4.2, but 7.4.2 complained: "your base is too new!" and so I gave up, and just symlinked gmp3 -> gmp10
16:34:04 <monochrom> and so, one could question the point of building 7.6.3 :)
16:34:37 <hpc> if my computer wasn't such a tragedy, i might consider using a nightly ghc as my primary compiler
16:35:05 <monochrom> anyway, during the previous Haskell Platform, I was on ubuntu 12.04 (not even 12.10), it had gmp3, so I didn't need to build from source
16:35:37 <monochrom> 15 minutes is "a short time" :)
16:36:55 <monochrom> Haskell Platform (sans GHC) build time is about that, too
16:38:43 <joelteon> so why is my parser outputting this? https://github.com/joelteon/hphp/blob/master/Language/HPHP.hs#L8-L11
16:39:01 <joelteon> most of the parsing is https://github.com/joelteon/hphp/blob/master/Language/HPHP/Parser.hs
16:42:56 <Zenol> hi
16:43:15 <monochrom> is it because "$a" fulfills expression, ".$b" is not end of input?
16:43:23 <joelteon> yeah
16:43:32 <joelteon> so I guess I'd have to force expression to fail
16:43:34 <monochrom> so, you have a bug
16:43:37 <joelteon> attoparsec can't handle left-recursion
16:43:54 <joelteon> yeah, I dunno how to do this now
16:44:28 <mauke> left factor your grammar
16:44:46 <mauke> besides, your grammar is ambiguous anyway
16:44:50 <joelteon> yeah
16:45:04 <joelteon> guess i should learn how to grammars
16:46:06 <joelteon> how would I left factor it?
16:47:23 <mauke> like a set of functions
16:49:12 <joelteon> I don't follow
16:49:14 <joelteon> it's a set of functions already
16:49:18 <monochrom> "$a.$b.$c" can be handled by var `sepBy` char '.'
16:49:37 <mauke> no, it's a set of Parser actions
16:50:15 <joelteon> monochrom: but not "foo".$bar
16:51:07 <monochrom> sure, then replace var by something more general
16:51:30 <joelteon> well, expressions can be concatenated together
16:51:42 <joelteon> expressions including concatenated expressions
16:53:23 <Zenol> Have you any idea about why using ByteString.Encode.decodeUtf8 might crash ?
16:53:25 <monochrom> replace var by something more general, but not as general as to accept "something . something". reserve that for sepBy
16:53:50 <mauke> expression = concatenation; concatenation = term >>= concat_tail; concat_tail x = do { char '.';  y <- term; concat_tail (Concat x y) } <|> return x
16:54:12 <joelteon> hmm
16:54:12 <mauke> term = var <|> stringLiteral <|> groupedExpr
16:54:23 <joelteon> oh, I see
16:55:00 <joelteon> so basically concatenation recurses, but using a version of expression that doesn't contain concatenation
16:55:41 <Zenol> I use hdbc inside a snap application, and if I use Text.pack (fromSql value) it works (althought the data is wrong), and ByteString.Encode.decodeUtf (fromSql value) simply make the application crash (no exception, just a crash...)
16:55:51 <monochrom> use precedence to stratify your parser
16:56:33 <monochrom> another example: for things like "a*b+c*d*e+f", (var `sepBy` char '*') `sepBy` char '+'
16:57:42 <joelteon> oh
16:59:04 <monochrom> sepBy gives me a list. if I don't want a list, I add some foldl or foldr
16:59:57 <monochrom> foldl1 Times ((foldl1 Plus (var `sepBy` char '*')) `sepBy` char '+')
17:00:19 <Sonarpulse> where does ghc-package keep --global packages registerd?
17:00:21 <monochrom> I guess it's sepBy1 if I want non-empty
17:00:44 <monochrom> enter "ghc-pkg list", then look for directory names
17:01:06 <monochrom> perhaps "ghc-pkg list --global" so only the global one is shown
17:01:19 <Sonarpulse> I'll try
17:01:50 <Sonarpulse> ghc-package list (with or without --global)
17:01:54 <Sonarpulse> does not give me directories
17:02:05 <Sonarpulse> I am trying to strip everything back to only what apt installs
17:02:59 <monochrom> do you understand that I said "ghc-pkg list" not "ghc-package list"?
17:03:06 <Sonarpulse> yeah
17:03:23 <monochrom> so why do you still speak of "ghc-package"?
17:03:25 <Sonarpulse> i meant "ghc-pkg list", sorry
17:03:49 <monochrom> ok, then it works on my computer, I don't know what's wrong with your computer
17:04:03 <monochrom> upload your whole hard disk for a full analysis?
17:04:26 <skyflash_> Has anyone here ever trying building distributed-process-platform (cloud haskell project)?
17:05:18 <Sonarpulse> it lists the package names but that is it
17:05:18 <skyflash_> ...or alternatively, does anyone have strong cabal-fu?
17:05:22 <Sonarpulse> very weird
17:05:35 <monochrom> it shows the directory name at the very beginning
17:05:50 <Sonarpulse> oh
17:06:19 <monochrom> it is very hard to communicate with you. see you later.
17:06:26 <skyflash_> I'm getting a warning about cabal dependencies needing different versions of the binary package
17:06:36 <ab9rf> skyflash_: ugh, cabal hell
17:06:47 <Sonarpulse> ah
17:06:59 <Sonarpulse> I thought it was supposed to list a directory with each package
17:07:00 <Sonarpulse> /var/lib/ghc/package.conf.d
17:07:03 <Sonarpulse> that must be it
17:07:05 <Sonarpulse> I am sorry
17:07:07 <Sonarpulse> thanks so much
17:07:20 <skyflash_> I've tried using --constraint to assert the latest binary version and reconfiguring, building and installing some dependent packages
17:07:35 <monochrom> you used --contraint too late
17:07:38 <skyflash_> ...but it still complains about the different constraints on these packages
17:07:53 <skyflash_> monochrom: OK, when should I use it?
17:08:41 <monochrom> I'll tell you by a long way
17:09:17 <monochrom> if you have X built against P-1, Y built against P-2, and then want to use both X and Y, that is a contradiction
17:09:17 <skyflash_> I have 3 distributed-process packages that declare an interest in binary-0.5.1.1 and one that wants binary-0.7.1.0
17:10:03 <skyflash_> I have set the constraint for the later version on the configure line of each of the 3 packages that want 0.5.1.1
17:10:04 <monochrom> this means you need --constraint='P == 2' or a similar inequality before you build X and Y
17:10:28 <skyflash_> Maybe I'm missing it from build, only did it on configure
17:11:33 <skyflash_> no, build doesn't take --constraint
17:11:59 <monochrom> I am not talking about the command "cabal build"
17:12:11 <monochrom> I am talking about the English word "build"
17:13:12 <skyflash_> I'm trying again to see if I missed --reinstall --force_reinstalls on any
17:17:40 <Zenol> Hum, ho can I reproduce the same bhavior as show called on a ByteString object without the " at begin/end ?
17:17:40 <Sonarpulse> anyway to automatically de-register broken packages
17:18:00 <Zenol> (And anyway, callind decodeUtf8 is still crashing and I can't find why :( )
17:18:06 <skyflash_> Well, I'm doing a cabal configure/build/install for network-transport, network-transport-tcp, distributed-process and then (hopefully) distributed-process-platform
17:18:22 <skyflash_> These are all from a cloned git repo
17:18:32 <mauke> Zenol: init . tail . show
17:18:35 <skyflash_> So I'm doing the cabal commands from within their project dirs
17:19:10 <Zenol> mauke> Yes, it remove the first and last char, but can't we call the function used by show?
17:19:15 <skyflash_> When I get to distributed-process-platform it always complains about the inconsistent dependences and then fails to build
17:19:27 <mauke> Zenol: what function used by show?
17:20:04 <Zenol> mauke> ByteString should give an implementation of the Show class, and it might probably be using an exported function .. i hope
17:20:04 <skyflash_> It seems like the constraint does actually get applied or doesn't get installed, so the dependent packages just see the old version
17:20:56 <jmcarthur> what? still no instance for Traversable (Either a)  :(
17:27:16 <Zenol> arg... decodeUtf8, read string :: ByteString ... they all crash the same way ...
17:27:40 <mauke> what do you mean by "crash"?
17:28:21 <ab9rf> crash?
17:29:07 <Zenol> mauke> I mean that there is not exception, nothing. I'm using snap so, in this case, my browser just says me that the comunication was prematurely broken, although I SHOULD show an exception if something wen't wrong.
17:29:36 <mauke> anything in the error log?
17:30:00 <ab9rf> Zenol: that 'connection prematurely broken' means the HTTP server at the other end failed to return a proper HTTP response (that is, not even headers appropriate for a no-content response)
17:30:32 <ab9rf> there is probably an exception occurring, with no handler to produce a user-friendly error message for the other end of the connection.  check the server's error log.
17:30:46 <Zenol> mauke> :o I'v completely forgoten those files. I'll have a check.
17:32:18 <Zenol> Ok, strange that the error wasn't displayed by snap, but there is something in the error file. And it doesn't says a lot of thing. It just says that it's an exception x)
17:32:38 <mauke> what does it actually say?
17:32:47 <Zenol> A web handler threw an exception. Details:
17:32:56 <Zenol> and then the big string I'm trying to read.
17:33:03 <tgeeky> @hpaste
17:33:03 <lambdabot> Haskell pastebin: http://hpaste.org/
17:33:54 <Zenol> oops, it's not the good error.
17:34:25 <Zenol> This one is the one launched with "error $ stringtodebug". Sorry.
17:35:45 <Zenol> Ok, it's a Prelude.read: no parse.
17:38:35 <Zenol> Maybe it would be simpliest if I just say what I'm trying to do...
17:41:06 <Zenol> I wan't to implement a login/regsitering system that use a Sqlite db and need to encrypt the password with a salt stored in the db. But I'm also using Snap.Auth, and it seams that the only way to implement my own password hashing is to add the salt inside a metaUser field that can only store jSON values ...
17:41:33 <w0rm-_x> Zenol, cool story
17:41:50 <Zenol> I would like to do something else, but the IAuthBackend class do not alow to do anything else thant "lookupByXXX" and "save/destroy" a user.
17:42:09 <Zenol> Si what I want is a way to store  ByteString as a Text, then get it back as a ByteString,
17:42:29 <Zenol> without loosing/corrupting the data during the conversion.
17:42:48 <mauke> show/read?
17:43:11 <Zenol> mauke > Prelude.read: no parse :/
17:43:29 <mauke> what's the string you're trying to parse?
17:44:03 <Zenol> Hum, wait 1s :)
17:46:09 <Zenol> Ohw :o It's working with T.pack . show and read . T.unpack (T = Data.Text) :)
17:46:16 <Zenol> Thanks
18:52:48 <dacDave> Which is preferred: using if/then/else in function body or using guards?
18:54:00 <Cale> If you can use guards, they're often nicer.
18:56:50 <dacDave> factorial n = if n > 0 then n * (factorial (n - 1)) else error "Invalid argument" -- or...
18:57:11 <mauke> no need to check at each step
18:59:38 <dacDave> factorial n | n < 0 = error "Invalid argument"  \n\t | otherwise n * ( factorial (n - 1))
19:00:45 <dacDave> Yes, I left out thr n == 0 case in the guards example.
19:01:19 <dacDave> Which is better Haskell?
19:01:47 <mauke> factorial n = product [1 .. n]
19:02:41 <dacDave> Nice,but I am learning syntax not standard libraries.
19:05:25 <dacDave> I'm having trouble getting the guards example to compile, although i feel that it is the more elegant solution.
19:09:11 <dacDave> Also if/then/else can't handle all three possibilities (n < 0, n == 0, n > 0)
19:10:53 <tabemann> this compiles:
19:10:57 <tabemann> module Factorial (factorial) where
19:10:58 <tabemann> factorial :: Integer -> Integer
19:10:58 <tabemann> factorial n | n > 0 = n * factorial (n - 1)
19:10:58 <tabemann>             | n == 0 = 1
19:10:58 <tabemann>             | otherwise = error "Invalid argument"
19:17:02 <dacDave> Maybe my problem was mixing pattern matching with guards:
19:18:08 <tabemann> how so, you can do that
19:18:26 <tabemann> each different instance of pattern matching gets its own set of guards
19:19:17 <dacDave> Just a second, BRB
19:21:15 * tabemann just noticed that the higher factorials have long strings of zeros at their ends
19:22:03 * tabemann just tried entering: factorial 10000
19:24:15 <dacDave> HUH! Just tried again and it worked. Don't remember the compile error I was getting earlier. Thanks.
19:27:16 <MouseTheLuckyDog> Hello. I studied Haskell a long time ago. At the time "practical haskell" was hard but it seems now that maybe with the publishing of "Real World Haskell" it might practical haskell might be more doable.  So I thought if there was a OSS project that could use some help but something not Haskell specific, something more mainline like say a scanner program for android.
19:28:57 <tabemann> too bad Android is Java-centric
19:33:20 <MouseTheLuckyDog> tabeman, that was just an example I pulled out of my ass.
19:33:46 <MouseTheLuckyDog> BTW is there a Haskell for android?
19:34:32 <tabemann> hmm... the problem I see in compiling Haskell into JVM is lack of tail recursion... but then they manage to compile Haskell into *JavaScript* these days
19:35:02 <tabemann> (technically Android doesn't use the JVM but a different virtual machine, though)
19:35:50 <MouseTheLuckyDog> BTW I believe most Android apps are actually native code. AFAIS a lot of people are pushing NDK now.
19:36:12 <tabemann> oh - didn't know that (am not that familiar with the details of Android myself)
19:36:32 <tabemann> well then we might just need GHC to support Linux on ARM
19:38:50 <meretrix> I am trying to create a pipe's Producer.  Everything works fine with "return $ respond x", but when I change that to "forever $ return $ respond x", I get an error that the return type of respond is ambiguous.
19:38:58 <meretrix> Can anyone explain what's going on here?
19:39:30 <meretrix> Shouldn't "forever" keep the type information intact?
19:39:40 <mauke> :t forever
19:39:41 <lambdabot> Monad m => m a -> m b
19:39:43 <mauke> no
19:40:20 <meretrix> Ah
19:41:35 <tabemann> hmm... why m b and not m ()?
19:41:51 <joelteon> why is parsec's documentation so out of date?
19:42:56 <meretrix> Is the type of b defined?
19:44:28 <tij> im using the Graphics.Gloss library, but when I close the window, my command prompt (on Windows) seems to keep running the program
19:44:33 <shachaf> Why m () and not m Void?
19:44:40 <tij> so i have to kill cmd
19:44:53 <tij> is there a way around this?
19:45:06 <tij> Control-C or Control-D doesnt work
19:46:33 <monochrom> why is the world so full of mysteries? :)
19:47:32 <monochrom> but I think you have to register a window event handler that says: when window closes, exit Gloss's event loop
19:48:01 <frerich> tabemann: The only reason I can think of is that 'forever a' is just 'a >> forever a', and '>>' is 'm a -> m b -> m b'. However, I also don't understand how that is useful - meretrix just shows how it can actually be annoying.
19:48:02 <lambdabot> frerich: You have 1 new message. '/msg lambdabot @messages' to read it.
19:50:28 <meretrix> frerich: So, do I just have to specify the type of b manually?
19:55:59 <frerich> meretrix: You could probably specify a type, but I'd first try to see why ghc cannot decide what type to use in the first place.
20:20:56 <chord> what is new in Haskell world?
20:30:26 <Gracenotes> needs more tumbleweed
20:36:18 <applicatiative> joelton, when you figure it all out, you should update the parsec manual; its been a dire community need for some time.
20:37:28 <applicatiative> if I remember, the other extended tutorial, in RWH, uses parsec-2 and doesn't compile either
20:42:36 <joelteon> hahaha
20:42:41 <joelteon> stop changing the API!!
20:54:08 <monochrom> they really only changed it once
20:54:16 <applicatiative> I think it had to happen, at one point Parsec only handled string, I think
20:56:47 <joelteon> well it's easier to write code than documentation
20:56:52 <joelteon> especially if you don't want anyone to use your stuff
20:57:00 <joelteon> maybe I'll fork it and update everything
20:57:19 <hodapp> whether it's easier to write code than documentation kinda depends on the language and whether you want the code to itself form meaningful documentation >_>
20:57:37 <joelteon> well, by easier I mean more fun
21:03:27 <johnw> joelteon: I hear you
21:06:33 <augur> anyone know why using (=~) with [String] as the target type fails? i get an error that there's no instance for it but ive seen examples of this usage all over the place
21:06:54 <augur> maybe i just shouldnt use this library
21:07:11 <johnw> i don't remember anymore
21:07:19 <johnw> it's been forever since I used a regexp in Haskell
21:07:35 <johnw> parsec is easier to think about and is type safe
21:08:29 <applicatiative> jkk
21:09:06 <augur> johnw:  yes but is it as fast? i just need to pull out two easily defined substrings
21:09:28 <johnw> ah
21:09:45 <johnw> i'm not sure about it's latency, although I know the throughput of Attoparsec is great
21:09:55 <johnw> did you try rex?
21:10:13 <latermuse> augur: i know why
21:10:17 <johnw> i like the way it models matching after view patterns
21:10:34 <latermuse> augur: you need to use matchRegexAll
21:10:59 <latermuse> augur: those tutorials online are outdated
21:10:59 <augur> latermuse: hows that then?
21:11:07 <latermuse> show me the current like of code you are using
21:11:11 <augur> uh
21:11:12 <augur> its just
21:11:22 <augur> x =~ y :: [String]
21:11:42 <latermuse> try this: getAllMatches $ x =~ y :: [String]
21:12:12 <augur> very similar error
21:12:19 <augur> No instance for (RegexContext Regex [Char] (AllMatches [] String))
21:12:58 <latermuse> getAllTextMatches $ "foo foo foo" =~ "foo" :: [String]
21:13:10 <Aetherspawn> > 3 :: Double
21:13:10 <augur> ahh there we go
21:13:12 <lambdabot>   3.0
21:13:12 <latermuse> this one works for me
21:14:09 <latermuse> its not very intuitive imo, but it works once you know how to do it
21:20:17 <Aetherspawn> @pl flyForce s / shoeMass s * delta * vmid
21:20:17 <lambdabot> flyForce s / shoeMass s * delta * vmid
21:20:23 <Aetherspawn> @pl (\s -> flyForce s / shoeMass s * delta * vmid)
21:20:23 <lambdabot> ((vmid * delta) *) . liftM2 (/) flyForce shoeMass
21:21:40 <Aetherspawn> :t min
21:21:41 <lambdabot> Ord a => a -> a -> a
21:21:58 <Aetherspawn> :t minimum
21:21:59 <lambdabot> Ord a => [a] -> a
21:29:17 <johnw> there sure are a lot of regexp libraries
21:32:16 <augur> latermuse: do you know how to get capture groups?
21:33:45 <iKillCypher> Hi is it recommanded to learn Haskell if someone here who can write in basic java?
21:34:15 <johnw> I don't see why not
21:34:21 <shachaf> Being able to write basic Java will be a slight disadvantage but I'm sure you can overcome it.
21:34:49 <iKillCypher> care to explain why?!
21:34:55 <iKillCypher> it is a fast learning lang?
21:35:07 <johnw> that depends on you, but in general, no
21:35:26 <johnw> you have to come at it with an appreciate that a steep learning curve can pay dividends later
21:35:45 <augur> latermuse: aha! getAllTextSubmatches!
21:35:45 <augur> :D
21:35:46 <iKillCypher> oh
21:35:52 <applicatiative> getAllMatches ("foo foo foo" =~ "foo" :: (AllMatches [] (MatchOffset, MatchLength)))
21:36:06 <iKillCypher> nvm then :)
21:36:06 <johnw> elliott: ping
21:36:15 <applicatiative> ^^^ this works, augur , it could maybe be adjusted?
21:36:27 <augur> applicatiative: nah i got it :)
21:36:29 <augur> thank you tho :D
21:36:30 <applicatiative> ah
21:37:07 <Gracenotes> man, I just really like the way Haskell types look.
21:37:12 <applicatiative> ah I missed it, fiddling with bos's old tutorial
21:37:17 <augur> Gracenotes: lol
21:37:27 <augur> Gracenotes: how about agda types, ey
21:37:28 <applicatiative> getAllTextMatches
21:38:31 <Gracenotes> the CamelCase, the aesthetic use of whitespace, the occasional symbols, the significance of every term
21:38:31 <augur> applicatiative: for all matches including groups, you need ...Submatches
21:38:45 <augur> Gracenotes: agda types > all
21:38:48 <Gracenotes> agda is a bit uglier.
21:39:02 <augur> shut up no its not :|
21:39:09 <augur> its no uglier than haskell
21:39:13 <johnw> I like the way Idris looks
21:39:14 <augur> all haskell types are agda types
21:39:16 <augur> modulo =>
21:39:33 <augur> and modulo polymorphism where you need a little noise
21:39:35 <applicatiative> augur: yeah i'm getting it slowly; i wonder why the types changed .. besides maybe egregious overlapping instance and other class horrors
21:39:37 <Gracenotes> there is beauty in restriction, especially when that restriction is to decidable types that represent results of computations.
21:39:59 <Aetherspawn> @pl tes 1 1
21:39:59 <lambdabot> tes 1 1
21:40:06 <applicatiative> Idris is really something
21:40:12 <Aetherspawn> What's that thing that applies the same thing twice
21:40:17 <zRecursive> @ty  (*>)
21:40:18 <lambdabot> Applicative f => f a -> f b -> f b
21:40:19 <Aetherspawn> f x = f x x
21:40:20 <augur> Gracenotes: agda types are decidable.
21:40:26 <Gracenotes> join for (->) r
21:40:38 <Aetherspawn> :t join
21:40:39 <lambdabot> Monad m => m (m a) -> m a
21:40:42 <johnw> :t join (*)
21:40:43 <lambdabot> Num a => a -> a
21:40:46 <zRecursive> @ty callCC
21:40:47 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
21:41:00 <johnw> zRecursive: playing with callCC?
21:41:11 <zRecursive> johnw: stundying
21:41:14 <applicatiative> > [1,2,3] *> "hello"
21:41:16 <lambdabot>   "hellohellohello"
21:41:19 <johnw> zRecursive: https://www.fpcomplete.com/user/jwiegley/understanding-continuations
21:41:26 <Gracenotes> > join (++) "bunny"
21:41:27 <lambdabot>   "bunnybunny"
21:41:32 <zRecursive> johnw: good
21:41:41 <applicatiative> > [(),(),()] *> "hello"
21:41:43 <lambdabot>   "hellohellohello"
21:42:37 <augur> is there something like readFile but that produces a stream of files for a dir?
21:42:41 <applicatiative> oh god the hpaste german porn crank is back
21:42:51 <johnw> augur: a stream of file names, or contents?
21:43:02 <Aetherspawn> > add 3 4
21:43:03 <shachaf> So are "((a -> Void) -> a) -> a" and "((a -> Void) -> Void) -> a" both equivalent axioms?
21:43:04 <lambdabot>   Not in scope: `add'
21:43:04 <lambdabot>  Perhaps you meant one of these:
21:43:04 <lambdabot>    `odd' (imported fro...
21:43:09 * hackagebot accelerate 0.13.0.3 - An embedded language for accelerated array processing  http://hackage.haskell.org/package/accelerate-0.13.0.3 (TrevorMcDonell)
21:43:10 <augur> johnw: either, really, i dont care. i just need to read all the files in a dir
21:43:12 <Gracenotes> Agda names are not always the most descriptive either
21:43:14 <Aetherspawn> > plus 3 4
21:43:15 <lambdabot>   Not in scope: `plus'
21:43:16 <lambdabot>  Perhaps you meant `mplus' (imported from Control.Mona...
21:43:20 <augur> well, all the files with a specific name format
21:43:21 <johnw> augur: filesystem-conduit can generate a stream of filenames
21:43:23 <Gracenotes> they are focused more on writeability than readability
21:43:24 <augur> Gracenotes: nonsense, ofcourse they are
21:43:29 <johnw> I bet it wouldn't take much to turn that into a stream of contents
21:43:37 <augur> Gracenotes: agda types are HIGHLY readable
21:43:42 <augur> i would say more so than haskell by far
21:43:58 <Gracenotes> more than Haskell? adding more features makes things more comprehensible?
21:44:09 <Gracenotes> hm... or are you talking about conventions?
21:44:24 <augur> all haskell types are agda types, like i said
21:44:36 <applicatiative> getDirectoryContents x >>= fmap concat . mapM readFile
21:45:01 <applicatiative> cant be quite right
21:45:08 <augur> applicatiative: aha, getDirectoryContents!
21:45:10 <Gracenotes> Then how are Agda types more readable?
21:45:35 <augur> Gracenotes: because agda syntax allows you to write better names
21:45:36 <Gracenotes> I can be convinced here, especially given my lack of actual in-depth programming in Agda.
21:45:36 <hodapp> all Haskell types are Agda types?
21:45:39 * hodapp jots this down
21:45:46 <augur> hodapp: more or less.
21:45:51 <hodapp> I had been told that Agda was based on Haskell.
21:45:52 <Gracenotes> better names? like unholy mixes of symbols and letters?
21:45:53 <applicatiative> getDirectoryContents x >>= fmap concat . mapM readFile . filter ("hs" `isSuffixOf) or whatever
21:45:58 <shachaf> johnw: What does "really" mean in "you are really invoking callCC"?
21:46:07 <augur> Gracenotes: i think you mean eminently readable mix of symbols and letters, yes
21:46:28 <applicatiative> hodapp: the syntax is Miranda-Haskell insofar as that applies
21:46:33 <augur> but if you want to write boring haskellian names, you're more than welcome to
21:46:40 <Gracenotes> on the other hand, I do think you can get more from reading a Haskell type signature than an Agda one, as far as conventions go
21:46:43 <augur> certainly conor does
21:46:49 <augur> Gracenotes: nonsense
21:46:50 <Gracenotes> an arbitrary one
21:46:59 <hodapp> I need to learn me some Haskell first, then maybe I'll try to figure out these 'dependent types' you all keep talking about
21:47:15 <dolio> shachaf: I'm not sure they're equivalent operationally.
21:47:17 <applicatiative> boy augur is a little out of control.  we can manage this better.
21:47:41 <applicatiative> Gracenotes: the going Idris conventions might be more to your taste
21:47:41 <johnw> shachaf: not much meaning, more like "this is what is really happening"
21:48:06 <shachaf> What does "really" mean in "this is what is really happening"?
21:48:10 <Gracenotes> hm, okay, I was going to say that in Haskell you have caps conventions for types and lowercase for parameters, but in Agda you do have explicit forall.
21:48:12 <shachaf> dolio: What do you mean?
21:48:21 <johnw> i'm not sure exactly what you're asking
21:48:34 <johnw> really, actually...
21:48:34 <Gracenotes> does require a bit more scanning
21:48:53 <augur> Gracenotes: you can use whatever naming conventions you want, if you so desire
21:48:58 <applicatiative> you can more frequently drop quantifiers in Idris, upper and lower case dont work the same way
21:49:09 <hodapp> What do you folks use Agda for?
21:49:23 <augur> Gracenotes: tho there's no real scanning required if you just read
21:49:25 <Gracenotes> I'm saying that having arbitrary naming conventions is great for expressiveness, bad (by definition) for universally recognizable conventions.
21:49:35 <applicatiative> type inquiry hodapp ...
21:49:51 <hodapp> applicatiative: I'm not sure what that means.
21:49:51 <dolio> shachaf: The first one is call/cc, and it ensures that the continuation is always called at least once.
21:50:00 <Gracenotes> but... this seems almost tautological... I dunno, I do like the latter, whereas I can see how some domains might easily yield a preference towards the former.
21:50:03 <applicatiative> the agda conventions are good for much of what is done
21:50:31 <dolio> shachaf: The latter is called 'control' or 'C', and it's up to the function passed in how many times the continuation is called. 0 or more.
21:51:11 <shachaf> dolio: Isn't it the second one that requires the continuation to be called at least once?
21:51:12 <applicatiative> hodapp: i think people are mostly studying the typesystem, seeing what they can make it do, what they can express, etc
21:51:20 <Gracenotes> I've done a fair bit of CPS stuff but never needed to use call/cc. Not 'real world CPS', I suppose.
21:51:23 <shachaf> Or maybe I'm not understanding what you mean.
21:51:52 <augur> Gracenotes: syntax highlighting sort of obviates the need for hard-coded conventions, fwiw
21:52:08 <dolio> It's not really that simple, because to call it 0 times in the latter case, you need to conjure up a Void.
21:52:41 <augur> Gracenotes: if you have some type `Foo' defined, then in this   ∀ {X : Set} → X → Foo   X will be a different color that Foo
21:52:45 <applicatiative> hodapp: Idris is I guess hoping to be more directly practical, or more practical in the near term.
21:53:13 <dolio> shachaf: call/cc both hands you the current continuation, and leaves it as the continuation of the function it's passed.
21:53:20 <johnw> applicatiative: it will need more libraries for that, definitely
21:53:27 <Gracenotes> sure, that seems reasonable.
21:53:28 <applicatiative> Idris?
21:53:31 <johnw> yeah
21:53:34 <dolio> So just returning an a calls the same continuation that was passed in.
21:53:38 <hodapp> hmm, interesting
21:53:41 <hodapp> I'll read about this tomorrow
21:54:02 <applicatiative> oh yes, there's really no rational way of dealing with text, for example
21:54:18 <shachaf> dolio: Ah, I see what you mean.
21:54:22 <applicatiative> which is a bit short of practical
21:55:17 <augur> Gracenotes: but in general, we tend to use single-letter names for type vars
21:55:27 <applicatiative> edwin b said something about introducing a sort of bytestringish type which would spare one thinking what the devil a C string is
21:55:38 <dolio> shachaf: If you look at the implementation in Cont or something, callCC f k = k (f $ \x _ -> k x) ; control f k = f $ \x _ -> k x
21:55:41 <dolio> Or something like that.
21:56:35 <dolio> So callCC f = control (\k -> f k >>= k)
21:56:35 <johnw> i remember seeing an example of when control is needed in one of oleg's papers, I think
21:57:05 <shachaf> @quote under.Control
21:57:05 <lambdabot> rwbarton says: edwardk now has Lens under Control
21:57:20 <joelteon> @quote otters
21:57:21 <lambdabot> otters says: heh, F# is just the unboxed version of F
21:57:21 <dolio> In a less typed setting you can do stuff like 'abort = control (\_ -> ())'
21:57:44 <Aetherspawn> I like the delphi way of dealing with strings
21:57:49 <shachaf> Hm.
21:57:51 <dolio> It's harder to realize that with the Haskell versions.
21:57:53 <augur> Gracenotes: i think you should just try to use agda a bit. its really quite readable
21:58:05 <Aetherspawn> [Length][String Data...]
21:58:15 <Aetherspawn> I dislike C's way because you have to loop to find the null terminator
21:58:20 <Aetherspawn> I think that's ineffecient.
21:58:25 <Gracenotes> augur: I do tend to do more computation than proving :p
21:58:35 <Gracenotes> but yes, there are a lot of cool ideas that carry over back into Haskell
21:58:52 <augur> Gracenotes: so do computation with dependent types!
21:59:20 <dolio> shachaf: I have no idea what 'control (\_ -> ())' does in languages that allow it, of course. :)
21:59:43 <Gracenotes> if I do take some serious time with Agda, I'd also want to get familiar with Charity
22:00:02 <Gracenotes> I've tinkered a bit, rather cool completely total language
22:00:11 <augur> why charity
22:00:32 <applicatiative> charity is extremely cool. cpl even cooler
22:00:49 <applicatiative> they are the most advanced languages in my eccentric opinion
22:00:49 <Gracenotes> It's category-theory based and is structured in a neat way to be 'general purpose' while still not producing bottom values.
22:01:19 <Gracenotes> the old CPL?
22:01:28 <augur> im not sure how charity is CT based. ive never understood this claim
22:01:31 <augur> tho ive heard it!
22:02:00 <applicatiative> yes, the designer is a wrongly forgotten master with 10000x the brains of the going magi
22:02:31 <Gracenotes> in the same way that Haskell is CT-based, but moreso
22:03:03 <augur> that doesnt help me understand x3
22:03:14 <augur> by that same token, agda is CT based!
22:03:29 <dolio> Charity is quite a bit closer to looking like the category theory versions of things.
22:03:33 <dolio> Together with some squiggol.
22:03:37 <applicatiative> thats an extremely strange claim
22:03:42 <augur> i dont know what that would even mean, dolio
22:04:09 * tabemann just looked at Charity's website, and it says that programs in it (up to user input) always terminate, and is now wondering how that is insured (wouldn't that mean that it's not Turing-complete?)
22:04:20 <applicatiative> it does indeed tabemann
22:04:23 <Gracenotes> through cool means
22:04:24 <Sonarpulse> I have a cabal package the provides both an library and a executable that depends on the library
22:04:29 <dolio> Yes, it means that.
22:04:47 <Sonarpulse> can i make the exutable depend on the library and avoid repeating dependancies?
22:04:52 <johnw> Sonarpulse: yes
22:04:59 <Aetherspawn> Is there a better way to explicitly pull fields out of a record
22:05:00 <johnw> Sonarpulse: but you'll need to require a recent version of cabal
22:05:04 <Sonarpulse> ok
22:05:12 <Aetherspawn> when it's passed as an argument
22:05:16 <johnw> one sec, I think there is a stack overflow Q about this
22:05:21 <Sonarpulse> awesome
22:05:33 <applicatiative> oh i was going to say No, Sonarpulse.  hadnt known about this improvement
22:05:49 <augur> tabemann: agda is total too
22:06:11 <Sonarpulse> well, glad to indirectly teach you something :D
22:06:11 <applicatiative> idris is total unless you turn it off
22:06:14 <augur> there's a recursion checking doodad that checks to see if your recursion is on a smaller subterm
22:06:27 <Aetherspawn> I heard agda is easy to write
22:06:31 <Aetherspawn> because it can suggest lots of stuff
22:06:43 <augur> this is true, to some extent
22:06:46 <augur> it can suggest lots of stuff
22:06:47 <Aetherspawn> I wish I could mash tab and have haskell write the stuff for me ;_;
22:06:52 <augur> that doesnt mean what it suggests is what you want
22:06:59 <applicatiative> it tells you the type of the missing bits, god willing
22:07:08 <dolio> Well, you can't do that. You have to mash C-a or something.
22:07:12 <Sonarpulse> do agda or epigram do calculus of constructions like coq? or anything as 'general'
22:07:13 <josephle> augur: but it does tell you what *doesn't* belong in the black :)
22:07:23 <josephle> *blank
22:07:36 <augur> Sonarpulse: agda is something related to CoC afaik. epigram2 is something way cooler
22:07:42 * tabemann wonders what set of terminating programs are excluded by insuring that programs terminate
22:07:43 <augur> unfortunately, epigram2 is also vaporware for now :)
22:07:56 <Sonarpulse> wow!
22:07:58 <applicatiative> Sonarpulse they have their own cranky theories just as grandiose
22:08:00 <dolio> Agda is similar to Martin-Löf type theory. Somewhat extended.
22:08:01 <johnw> Sonarpulse: I can't seem to find it
22:08:07 <Sonarpulse> oh well
22:08:10 <Sonarpulse> johnw
22:08:13 <Sonarpulse> thanks for the heads up
22:08:16 <augur> dolio: so is CoC :)
22:08:17 <Sonarpulse> I'll probably dig around
22:08:21 <Sonarpulse> maybe get lucky
22:08:27 <applicatiative> in agdo you dont need to use ap to apply a function
22:08:33 <applicatiative> agda too...
22:08:37 <Sonarpulse> CoC is 'far side' of the lambda cube, right?
22:08:43 <josephle> the real question is whether or not people have fixed the ability to prove bottom in agda
22:08:47 <dolio> CoC is a fair bit different from Martin-Löf TT.
22:08:48 * josephle goes to check #agda
22:09:02 <dolio> Coq adds a lot of stuff to CoC that makes it closer.
22:09:06 <augur> :t mapM readFile xs
22:09:07 <lambdabot>     Not in scope: `xs'
22:09:07 <lambdabot>     Perhaps you meant one of these:
22:09:07 <lambdabot>       `x' (imported from Debug.SimpleReflect),
22:09:10 <augur> :|
22:09:11 <Aetherspawn> is there a way I can see what ASM is produced by a small amount of haskell code
22:09:18 <bz> Aetherspawn: you can pattern match on records, i think
22:09:19 <augur> :t mapM readFile []
22:09:20 <lambdabot> IO [String]
22:09:28 <applicatiative> josephle: if you can't prove False somehow, they're not experimenting hard enough, and Im withdrawing funding
22:09:34 <Aetherspawn> bz, yes I considered that
22:09:38 <dolio> Aetherspawn: -ddump-asm?
22:09:51 <Aetherspawn> dolio, that dumps a lot of asm.
22:10:00 <augur> blegh. i suck at the IO monad
22:10:01 <bz> Aetherspawn: does that not work for you?
22:10:04 <Aetherspawn> I think it's the entire binary including the runtime?
22:10:06 <Gracenotes> unless you're doing something that you expect to be very heavily optimized, the ASM output may not make as much sense as other intermediate forms.
22:10:10 <shachaf> No, it's just your module.
22:10:15 <Gracenotes> but, you likely know that
22:10:15 <applicatiative> asm tends to come in immense waves
22:10:18 <Aetherspawn> oh dear okay
22:10:18 <josephle> applicatiative: you could always use without-k. I hear that's a surefire way to get False :)
22:10:20 <shachaf> And you can search it for the relevant symbols.
22:10:33 <augur> Epigram2's type system is totally awesome
22:10:37 <augur> its like super minimalist
22:11:02 <applicatiative> josephle: oh, is there a new 'false' in agda, not the one from a couple years ago?
22:11:45 <applicatiative> frankly, it seems to me childish in the extreme to go on about it. the last false in agda had a coq equivalent
22:11:57 <josephle> unfortunately applicatiative: there's this flag called --without-K that makes agda unsound.
22:12:14 <dolio> augur: Anyow, nothing in the lambda cube has strong inductive types, or universes, for instance.
22:12:24 <applicatiative> i know all about without-K, not that there was a new proof of unsoundness
22:12:32 <josephle> ah
22:12:35 <dolio> And they're impredicative.
22:12:37 <josephle> I don't think they ever fixed the old one
22:12:44 <dolio> Lambda cube languages, that is.
22:13:11 <dolio> At least, the ones that include quantification over types.
22:13:19 <augur> dolio: is CoC even in the cube? i thought it was an extension
22:13:46 <dolio> Nah, you're thinking CiC, I think, which is something like 'a bunch of stuff we put in Coq.'
22:13:56 <dolio> Calculus of Inductive Constructions.
22:14:08 <augur> ah ok
22:14:10 <dolio> Which also includes coinduction.
22:14:17 <augur> MLTT and CoC are pretty similar tho surely
22:14:22 <augur> i mean
22:14:31 <Aetherspawn> bz, it's just my record has heaps and heaps of entries
22:14:35 <Aetherspawn> and I'm adding new ones all the time
22:14:37 <augur> well, all type theories are pretty similar i guess
22:14:43 <dolio> Yeah, you have to be interested to spot the differences.
22:15:12 <augur> i wish i knew what the CiC was actually defined to be
22:15:17 <augur> i can never find a nice good little explanation
22:15:18 <augur> :\
22:15:26 <Aetherspawn> shachaf, where does the asm dump?
22:15:29 <dolio> I don't know what it's defined to be, off hand.
22:15:55 <applicatiative> josephle: i'm not seeing anything but the usual tide of bugs
22:15:58 * tabemann is reading about Agda and Charity and trying to wrap his brain around those at least a little bit
22:15:59 <shachaf> Aetherspawn: In your terminal, when the module is actually compiled.
22:16:17 <josephle> applicatiative, hmm maybe my memory is wrong
22:16:28 <Aetherspawn> oh, wierd. I don't get anything
22:16:42 <Aetherspawn> using "ghc -ddump-asm nls.hs"
22:17:07 <dolio> I seriously doubt --without-K makes Agda unsound.
22:17:07 <Gracenotes> you might not if there's already an output file or interface file
22:17:22 <applicatiative> --without-k would seem in principle to be 'more correct', k is a sensible simplification
22:17:22 <dolio> It just lets you do fewer things than are allowed without it.
22:17:23 <Aetherspawn> Oh, yes, oops
22:17:24 <shachaf> Aetherspawn: Please see the second half of my sentence.
22:17:47 * shachaf hides answers in plain sight.
22:18:39 <applicatiative> k can be viewed as a postulate, so youd think a contradiction you could get without it, you could get with it; but that's no doubt simpleminded
22:19:15 <dolio> Well, it's possible they screwed up the implementation somehow.
22:19:24 <applicatiative> yes of course
22:19:32 <bz> Aetherspawn: you can match on whichever attributes you want
22:19:37 <bz> Aetherspawn: and out of order, too
22:19:38 <applicatiative> agda was without k before it was with k if i remember
22:19:39 <dolio> Because Agda doesn't implement J or K directly, they implement something entirely different that can in principle be desugared to J and K and such.
22:19:47 <applicatiative> ah
22:19:58 <dolio> So --without-K just makes the rules for that other thing more restrictive.
22:20:37 <dolio> No one's actually proved that it doesn't allow you to write K, though.
22:21:01 <josephle> interesting
22:21:05 <dolio> So what would be problematic is if it still did, because people want to use it together with postulates that contradict K.
22:21:08 <applicatiative> yes, i've seen attempts to make K with --without-K
22:22:17 <applicatiative> the possiblility of doing without k was brought back on account of its necessity for the voevodsky business
22:22:20 <applicatiative> if i remember
22:22:23 <dolio> josephle: You might also be thinking of some other stuff that people working on that are doing.
22:22:33 <applicatiative> it seemed a bit of a rushed job at the time
22:22:49 <josephle> dolio: possibly, it's been a while since i've done any HoTT related agda work
22:23:21 <dolio> They tried to simulate 'higher inductive types' by adding some unsound postulates and hiding it behind an abstraction barrier. But it leaked enough out to observe the inconsistency.
22:23:47 <applicatiative> those people are a bit coqophilic, this is hopeless
22:24:18 <applicatiative> does anyone have a good scheme for permitting 'higher inductive types'
22:24:28 <dolio> Not that I've seen.
22:24:36 <dolio> They have the same problem as the univalence axiom.
22:24:37 <applicatiative> i mean a theoretical plan for getting them into the system
22:24:37 <augur> :t forM_ []
22:24:39 <applicatiative> oh
22:24:39 <lambdabot> Monad m => (a -> m b) -> m ()
22:24:45 <augur> hm
22:24:45 <dolio> No one knows how the extra equalities are supposed to compute.
22:24:53 <applicatiative> yes
22:25:07 <dolio> And it's mostly mathematicians working on it, so they don't care. :)
22:25:11 <josephle> I just remember my experience in coq ending up with me getting angry that map ((\x -> x) y) p != map y p at the type level
22:25:52 <applicatiative> well they're spelled differently what would make you think they were the same ...
22:25:54 <augur> so
22:26:05 <applicatiative> this is *intentional* type theory!
22:26:14 * tabemann is looking at a paper introducing Agda is wondering just how in hell are people supposed to *type* this? bring out the character chart and pick out characters?
22:26:14 <josephle> ugh
22:26:29 <johnw> tabemann: agda-mode in Emacs makes it pretty easy
22:26:33 <dolio> tabemann: Latex input mode.
22:26:53 <applicatiative> tabemann: a character chart drops down if you hit the right emacs control-blob-x-etc
22:26:54 <josephle> in agda, map ((\x -> x) y) p gets beta-reduced to map y p iirc
22:27:02 <augur> i have a [FileName] and i want to turn it into [String], where basically its   concat $ map readFile fileNames :: [String]
22:27:05 <augur> but obviously this dosnt work
22:27:08 <augur> what should i do? D:
22:27:19 <dolio> josephle: Are you sure it wasn't 'map f p' vs 'map (\x -> f x) p'?
22:27:29 <dolio> Coq didn't do that until recently.
22:27:30 <applicatiative> you use a backslash \ and it starts resticting what latexy name you might look for
22:28:03 * monochrom wonders if augur is joking
22:28:10 <dolio> I think the latest version has eta, though.
22:28:15 * monochrom assumes joking
22:28:25 <augur> monochrom: im not. i never use the IO monad
22:28:27 <applicatiative> augur, FileName = String
22:28:33 <applicatiative> despite the different spellings
22:28:33 <augur> applicatiative: yes, i know
22:28:37 <josephle> dolio: I hazily remember that coq didn't beta reduce types
22:28:42 <monochrom> augur: [FileName] is already [String], there is no need to convert :)
22:28:45 <tabemann> augur: liftM concat $ mapM readFile fileNames
22:28:46 <augur> applicatiative: read what i wrote :P
22:28:46 <dolio> That'd be pretty extreme.
22:29:14 <augur> tabemann: aha, that makes sense i think
22:29:59 <monochrom> concat <$> mapM readFile filenames
22:30:03 <applicatiative> in my post-coq modern, the types are so intensional that no equalities can be proven. each type is what it is and not another type.
22:30:36 <augur> hmm. i might not even need to do that now that i think about it
22:30:41 <augur> gah. io is crazy in haskell. lol
22:30:45 <Aetherspawn> For the actual asm is it updatePlayer_closure or updatePlayer_closure_struct that I'm interested in?
22:31:01 <applicatiative> augur you need sequence or mapM
22:31:06 <applicatiative> oh monochrom said that
22:31:09 <augur> applicatiative: yeah i know
22:31:13 <applicatiative> io is awesome in haskell
22:31:30 <josephle> applicatiative: but, but how will we ever work with univalence?
22:31:33 <applicatiative> its unbelievable really
22:31:43 <applicatiative> josephle: ask dolio!
22:31:51 <applicatiative> oic
22:31:56 <applicatiative> my mad theory
22:33:44 <applicatiative> it is only in the context of an IO() that type distinctions mean anything
22:34:01 <bobajett> noob question: how can I join these three lists together? [1,2,3] [4,5,6], [7,8,9]  (without using Data.List.concat or folds). Basically Im trying to figure out whats the most ... primitive? ... method of joining a bunch of lists together?
22:34:11 <applicatiative> ++
22:34:23 <bobajett> map (++) ?
22:34:31 <applicatiative> > [1,2,3] ++ [4,5,6] ++ [7,8,9]
22:34:33 <augur> the tricky bit is knowing how to put these IO doodads together
22:34:33 <lambdabot>   [1,2,3,4,5,6,7,8,9]
22:35:03 <applicatiative> bobajett: i'm not understanding, mabye?
22:35:30 <bobajett> applicatiative: sorry,... how do I join a list of lists is my question
22:35:31 <Aetherspawn> > let useless = foldl (:) [1..10] in useless
22:35:32 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = [t0]
22:35:44 <Aetherspawn> > let useless = foldl (:) [] [1..10] in useless
22:35:46 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
22:35:46 <bobajett> [[1,2,3], [4,5,6], [7,8,9] ]
22:35:54 <applicatiative> > join [[1,2,3],[4,5,6]]
22:35:55 <lambdabot>   [1,2,3,4,5,6]
22:36:02 <dolio> applicatiative: If I knew, I'd be small-time famous.
22:36:04 <shachaf> Aetherspawn: That is useless indeed.
22:36:12 <josephle> :t join
22:36:14 <lambdabot> Monad m => m (m a) -> m a
22:36:24 <josephle> oh yeah, d'oh
22:36:25 <bobajett> applicatiative: I looked up join and join's source says it uses concat underneath
22:36:37 <applicatiative> yes, for lists join = concat
22:37:01 <shachaf> dolio: You're already small-time famous to me!
22:37:05 <bobajett> and concat uses foldr
22:37:06 <applicatiative> bobajett: but you seem to be resisting concat as unfundamental?
22:37:20 <dolio> Okay. I'd be more famous than I currently am.
22:37:30 <dolio> But still not very famous.
22:38:05 <bobajett> applicatiative: hah, Im even treating foldr as unfundamental :-) ... I guess Im asking this question as if I've only read the first 2 chapters of LYAH, Im not even at folds yet.
22:38:11 <applicatiative> bobajett: yes, list operations often reduce to foldr, which is just to say, theyre recursvely defined -- not to put too fine a point on it
22:38:25 <applicatiative> foldr is rock bottom
22:38:55 <bobajett> applicatiative: I think I got it. that helped connect it for me, thanks.
22:39:29 <applicatiative> its the general form of a recursive definition foo [] = z; foo (x:xs) = op x (foo xs)
22:39:36 <tabemann> to get any lower level, you'd basically have to manually implement what's implemented with a fold through *manual* recursion
22:40:48 <applicatiative> instead of that we say foo = foldr op z
22:41:02 <applicatiative> unless i'm getting something upside down or backward, as usual
22:41:18 <bobajett> tabemann: yep makes sense now. I just couldn't make that connection in my head between foldr to what applicative very succincly answered up above.
22:42:29 <tabemann> for some reason I wish Haskell came with functions like OCaml's rev_map, i.e. ones designed specifically to be tail recursive, and thus to be able to operate on lists of arbitrary length
22:43:01 <dolio> > map (+1) [0..]
22:43:02 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
22:43:09 <dolio> Is infinite arbitrary length enough?
22:43:36 <tabemann> dolio: isn't map not tail recursive?
22:43:42 <dolio> Doesn't matter.
22:43:55 <bobajett> myJoin [] = []; myJoin (x:xs) = x ++ myJoin xs; -- yay!
22:44:27 <dolio> It is not tail recursive, but that's okay.
22:44:28 <tabemann> so how do you not crash due to running out of stack space? because you are constructing everything as thunks on the heap instead?
22:45:07 <shachaf> It would be a good exercise to figure that out yourself, if you can manage it.
22:45:29 <shachaf> Think about how Haskell code is evaluated, evaluate map by hand. Remember laziness etc.
22:45:53 <Gracenotes> one useful perspective is that the code that produces those list values isn't run until the values actually need to be printed, here
22:46:31 <Gracenotes> at least in this case, those list values aren't really needed after printing occurs. ... doesn't explain how it works, but frames it, at least.
22:47:04 <zRecursive> dolio: take 10^80 $ map (+1) [0..]
22:47:10 <shachaf> "actually need" makes it sound like some magic is going on, rather than a simple evaluation strategy.
22:47:13 <tabemann> I must be just too used to thinking in terms of strict evaluation, where indeed trying to do a map of any major length would result in crashing
22:47:22 <shachaf> zRecursive: type error.
22:47:39 <Saizan> here you can even say map runs in constant space
22:47:53 <shachaf> tabemann: Correct. Which is why I recommended working through the evaluation yourself. :-)
22:48:18 <Sonarpulse> johnw: http://stackoverflow.com/questions/12305970/how-to-make-a-haskell-cabal-project-with-libraryexecutables-that-still-run-with
22:48:42 <Sonarpulse> applicative ^^ I guess that's it, if you are wondering too
22:48:51 <Gracenotes> I mean, the top-level function that does evaluation isn't happy until you print out a certain number of characters, or stop printing. The character-printing function isn't happy until you give it either a cell in a list of numbers or the end. ... etc.
22:48:54 <Sonarpulse> * applicatiative
22:49:04 <tabemann> I remember when coding in OCaml taking pains to make sure my code was tail recursive, where here lazy evaluation seems to make tail recursion essentially unnecessary for many things
22:49:22 <zRecursive> shachaf: take (10^80) $ map (+1) [0..]  ?
22:49:38 <dolio> What about it?
22:49:40 <Gracenotes> But it's probably the case that vague approximations like mine are okay as explanations, but not okay for acquiring understanding...
22:49:45 <shachaf> zRecursive: OK. Why should a huge finite list be more problematic than an infinite list?
22:49:47 <dolio> > take (10^80) $ map (+1) [0..]
22:49:48 <lambdabot>   []
22:49:49 <XexonixXexillion> :t (10^80) :: Int
22:49:50 <lambdabot> Int
22:50:02 <shachaf> Hah.
22:50:04 <XexonixXexillion> > (10^80) :: Int
22:50:05 <lambdabot>   0
22:50:12 <Gracenotes> more importantly..
22:50:14 <Gracenotes> :t take
22:50:15 <lambdabot> Int -> [a] -> [a]
22:50:15 <bobajett> tabemann: why did you have take pains to be tail-recursive? For memory reasons or performance reasons?
22:50:23 <zRecursive> dolio: i want to know why haskell doesnot care tail recursion ?
22:50:29 <tabemann> bobajett: to avoid running out of stack space
22:50:47 <augur> hmm
22:50:57 <augur> is there something like getDirectoryContents but recursive?
22:51:08 <zRecursive> shachaf: since lazy ?
22:51:11 <johnw> augur: no, that question has been asked on stackoverflow a few times too :)
22:51:20 <augur> johnw: hah. :)
22:51:29 <johnw> we need something simple like Python's os.walk
22:51:43 <dolio> zRecursive: One way to think about it is that almost everything in Haskell gets to be a tail call, because of lazy evaluation.
22:52:14 <dolio> take n (x:xs) = (:) x (take (n-1) xs)
22:52:22 <dolio> That's a tail call to (:) with two thunks.
22:52:29 <dolio> And (:) returns immediately.
22:52:41 <dolio> No stack usage.
22:53:00 <tabemann> foldr, on the other hand, IIRC can still easily overflow the stack
22:53:07 <Gracenotes> what more often can take up lots of space is the thunks themselves, in particular all of the free variables in the thunk expressions.
22:53:17 <Gracenotes> and just the sheer number
22:53:17 <applicatiative> people have written recurseDirectories a million times, none seems to catch on
22:53:22 <zRecursive> dolio: seems clear
22:53:28 <shachaf> tabemann: You're mixing things up. foldr does not "overflow the stack", you do.
22:53:37 <shachaf> foldr is also a tail call, in almost exactly the way dolio described.
22:53:50 <dolio> Yes, it just tail calls f, instead of (:).
22:54:03 <dolio> Depending on what f does, you might use 'stack'.
22:54:06 <dolio> And overflow it.
22:54:26 <dolio> "Stack" is used to evaluate things like case.
22:55:33 <shachaf> My recommendation is to do some manual evaluation for a while until you get the general hang of how things work.
22:55:36 <zRecursive> are thunks always in heap ?
22:55:44 <dolio> Yes.
22:55:49 * tabemann forgot that it was just passing thunks of x and (f ...) to f
22:56:24 <dolio> GHC's stack lives on the heap, too. It just tracks frames so it can complain if you use too much.
22:56:25 * zRecursive worry about VERY big thunks ...
22:56:42 <applicatiative> zRecursive: dont worry about them.
22:56:55 <applicatiative> zRecursive: just stop using lists; use a sensible library
22:57:02 <dolio> I think you can actually turn off stack overflows.
22:57:11 <Gracenotes> well. lists are nice for plenty of control flowings.
22:57:13 <zRecursive> applicatiative: ok
22:57:15 <tabemann> isn't that why they recommend you always use foldl' instead of foldl, to avoid thunk build-up?
22:57:16 <applicatiative> -fno-stack-overflows
22:57:23 <augur> hmm
22:57:28 <augur> im getting an error   openFile: resource exhausted (Too many open files)
22:57:31 <shachaf> dolio: I think ghci does that by default now.
22:57:38 <dolio> And you can turn on heap overflows.
22:57:40 <augur> when using readFile on a loooot of files
22:57:52 <applicatiative> tabemann: it wont stop disaster if you are foldl'ing a lazy operation
22:58:02 <Gracenotes> augur: ..use more FDs?
22:58:07 <augur> Gracenotes: ?
22:58:11 <Gracenotes> file descriptors
22:58:15 <dolio> augur: Yes. If you open all your files at once, it will exhaust your 256 or so file descriptors.
22:58:18 <augur> Gracenotes: i dont follow
22:58:23 <applicatiative> augur: yes, dont do that, use a sensible IO library if you are reading zillions of files
22:58:32 <augur> dolio: im not opening them all at once tho :(
22:58:50 <ziman> what's the best lib to produce animated vector diagrams, is it still byorgey's diagrams? I'd like to visualize how an algorithm shuffles some values in a tree. I don't mind producing 300 still frames and using an external tool to put them in a gif.
22:58:51 <shachaf> @yarr, me loot o' files!
22:58:51 <lambdabot> Prepare to be boarded!
22:58:54 <augur> at least i dont think i am. im just reading their contents and leaving them
22:58:55 <applicatiative> augur: they dont come back till they are garbage collected
22:58:56 <Gracenotes> and you're definitely closing all of them, and not reloading a module and forgetting, for instance?
22:59:00 <tabemann> augur: are you actually evaluating the Strings returned by each readFile?
22:59:01 <dolio> You are. They don't get closed until the String you readFiled gets garbage collected, or you reach the end of string.
22:59:08 <augur> tabemann: yeah
22:59:11 <Gracenotes> oh, lazy IO.
22:59:16 <augur> i see i see
22:59:53 <augur> i need to read a whole bunch of files in, filter out some lines and then save the results to disk
22:59:57 <applicatiative> it's a typical oleg complaint about lazy io. file handles are precious and must not be left to ... blah blah
23:00:17 <augur> but theres a looot of files. 6 years worth of IRC records, specifically!
23:00:31 <tabemann> augur: are you actually evaluating the files' contents to their ends?
23:00:36 <applicatiative> augur: will you need to read the whole of each file?
23:00:43 <applicatiative> as tabemann is asking
23:00:55 <tabemann> if you're just searching for a particular string and stopping there, you're not evaluating the whole file's contents
23:00:59 <Gracenotes> tabemann: yeah, as an overly general rule of thumb, use foldl' rather than foldl when the final result of your computation can't have thunks in it anyway.
23:01:04 <augur> tabemann: yeah, i need to filter lines matching a regex, and extract substrings
23:01:14 <dolio> Go into /etc/security/limits.conf, and set a rule to allow yourself a million file descriptors. :)
23:01:23 <Gracenotes> and in other cases, but not in some of the cases I just described. easy as rhubarb pie.
23:01:25 <shachaf> "As an antícheirocracy..."
23:01:27 <johnw> augur: if you use withFile, you can make sure the file descriptors close after you're done finding the lines you want
23:01:31 <applicatiative> you might use one of the simple 'srtict io' expedient like length filecontents `seq` f filecontents
23:01:32 <tabemann> augur: one idea to force a String is to apply length to it
23:01:34 <shachaf> Gracenotes: Is rhubarb pie monoidal?
23:01:44 <tabemann> what applicatiative said
23:01:47 <applicatiative> whats the unit of rhubarb pie
23:01:49 <Gracenotes> they are looking for the empty rhubarb pie
23:01:51 <augur> johnw: ill try withFile
23:02:12 <dolio> You probably shouldn't use withFile.
23:02:23 <Gracenotes> but it is known that rhubarb pies commute.
23:02:32 <johnw> withFile "foo" ReadMode $ \handle -> do str <- hGetContents handle; ...
23:02:32 <Gracenotes> (and associate, I think?)
23:02:50 <shachaf> johnw: That is something you should pretty much never do.
23:02:53 <applicatiative> here there is another lazy io 'danger' waiting.
23:02:59 <johnw> what is the better alternative?
23:03:08 <johnw> i never actually used withFile yet, I prefer to use conduit
23:03:16 <shachaf> If you're using lazy I/O, you don't want to close the file handle, which is what withFile does.
23:03:28 <johnw> oh, I thought he wanted to close the handles
23:03:34 <applicatiative> he does
23:03:49 <applicatiative> but he wants to make sure hes gotten what he needs before he does
23:03:55 <shachaf> I don't know what he wants. But the two things are mostly incompatible.
23:03:58 <applicatiative> so to speak
23:04:00 <tabemann> but he needs to read from the file with something other than hGetContents, so that the file can be closed explicitly
23:04:01 <johnw> ah, true
23:04:03 <shachaf> The file will be automatically closed when you reach the end.
23:04:14 <johnw> then use conduit with sourceFile, problem solved
23:04:24 * shachaf sighs.
23:04:27 <shachaf> I have no reason to help with that anyway.
23:05:07 <applicatiative> augur: it does sound like the length contents `seq` blah contents hack might fit your case
23:05:15 <applicatiative> if like me you are unprofessional
23:05:22 * zRecursive seems haskell lazy is NOT ordinary lazy but not strict ?
23:05:39 <dolio> The most likely thing is that not everything with a single file is being done before the next file is opened.
23:05:40 <johnw> zRecursive: huh?
23:05:43 <Gracenotes> what is ordinary lazy?
23:05:44 <augur> shachaf: i need to take a bunch of files, for each one, filter its lines, map the result to something else, then concat all the files lines together
23:06:01 <dolio> Which means that withFile will just truncate the strings.
23:06:10 <Gracenotes> it can be non-strict in function arguments and lazy in function return values, to abuse terminology
23:06:12 <zRecursive> Gracenotes: such as lazy man
23:06:21 <Gracenotes> ...hm?
23:06:21 <augur> dolio: will it?
23:06:47 <applicatiative> johnw: is there a 'directory recurse' function in conduit-land?
23:06:53 <dolio> Closing the handle will cut off the string, yes.
23:06:55 <johnw> filesystem-conduit has one
23:06:56 <zRecursive> i like non-strict
23:06:57 <applicatiative> maybe augur could take the occasion
23:07:10 <applicatiative> filesystem-conduit augur !
23:07:19 <augur> applicatiative: :(
23:07:23 <augur> but
23:07:24 <dolio> augur: If you're building a giant list of all the lines of all the files, then yes, that will open all the files at the same time.
23:07:58 <applicatiative> http://hackage.haskell.org/packages/archive/filesystem-conduit/1.0.0/doc/html/Data-Conduit-Filesystem.html
23:08:07 <augur> applicatiative: why is filesystem-conduit so awesome
23:08:10 <dolio> One thing you can do is delay even opening the files until you need them.
23:08:13 <Gracenotes> non-strict is usually used to referred to arguments, though. something like ([0..] !! 10) may diverge if you only have non-strictness.
23:08:13 <applicatiative> augur there are filter conduits, you name it
23:08:19 <applicatiative> augur ask johnw
23:08:20 <dolio> By using 'unsafeInterleaveIO readFile'.
23:08:29 <augur> x.x
23:08:39 <applicatiative> augur: you wont have any of these problems, just um, a few fancy types
23:08:46 <augur> this is such a pain in the ass :(
23:08:58 <augur> this is why people think haskell is hard. :(
23:09:14 <applicatiative> augur: it's pretty simple to add length contents `seq` augurfiler contents
23:09:22 <applicatiative> augurfilter
23:09:26 <Gracenotes> how else could you reason about the semantic correctness of reading from files?
23:09:37 <augur> Gracenotes: who knows!
23:10:07 <augur> all i know is, im really tempted to just use something else. this should be a handfull of lines in relatively simple code
23:10:07 <zRecursive> Gracenotes: non-strict means just do what really needed ?!
23:10:21 <augur> but instead its turning into an obnoxious library fest
23:10:22 <applicatiative> augur it's really simple to do this in haskell; the 'standard model' does require care for zillions of files, since operating systems dont hand them out like candy
23:10:47 <augur> applicatiative: yeah but i dont see why i cant just open the file, grab contents, close file
23:10:56 <applicatiative> augur it will be one or two lines with the conduit lib
23:10:56 <augur> i mean, thats the imperative part of my brain talking
23:11:16 <applicatiative> augur, if it werent for the zillions of files itd be one or two lines in haskell
23:11:16 <Gracenotes> zRecursive: in the context of thunks, it can refer to whether calling a function with that thunk will force it, in any sense, or not.
23:11:48 <applicatiative> and in fact it still is if you force the files to be read completely with typical expedients
23:11:52 <augur> applicatiative: yeah but thats the thing right, the zillions, in principle, shouldnt add much overhead at all. its all this junk thats getting in the way
23:12:04 <dolio> Even with the zillions of files it's one extra line.
23:12:42 <tabemann> augur: just do mapM (\filename -> let contents = readFile filename in length contents `seq` contents) filenames
23:12:43 <augur> im so confused :(
23:12:48 <dolio> What are you doing with the list of all lines?
23:12:51 <augur> ok, ill try this seq thing
23:12:54 <zRecursive> Gracenotes: reasonable
23:12:54 <augur> dolio: >_>
23:13:26 <Gracenotes> laziness is iller-defined, but I think of it as fitting well with corecursion, mostly. This is clearest to me when thinking about return values of functions
23:13:30 <johnw> tabemann: that's going to read the contents of every file into memory all at once, wont' it?
23:13:33 <augur> dolio: again, im reading a bunch of files, filtering their lines, mapping the filtered lines, concating everything together into one big list, then storing it to disk
23:13:39 <tabemann> johnw: yes it will
23:13:43 <applicatiative> augur http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/System-IO-Strict.html will add the trivial thing you need for you
23:14:00 <johnw> then he should apply his filter within the lambda passed to mapM at least
23:14:13 <augur> dolio:   write out . unlines . map f . filter p . read
23:14:16 <dolio> augur: If you just do that file-by-file in a mapM, you shouldn't have any problems.
23:14:32 <augur> well, lines . read
23:14:37 <dolio> Instead of building one giant list of all files.
23:14:46 <tabemann> yeah, that's probably a better idea than reading them all into memory at once
23:14:50 <augur> well, plus the thing for the zillions of files :)
23:14:52 <tabemann> (disregard my suggestion)
23:14:53 <augur> but you get the idea
23:15:02 <applicatiative> yes, we just want to accumulate the lines augur wants
23:15:14 <augur> dolio: the reading-and-mapping thing is fine afaict
23:15:38 <applicatiative> augur also, if you use Data.Text (strict) this will go away
23:15:40 <tabemann> so then: do mapM (\filename -> let contents = readFile filename in length contents `seq` doFilter contents) filenames
23:15:47 <dolio> augur: I just mean, dump out everything from one file to disk before moving on to the next file.
23:16:00 <applicatiative> the representation of your lines in memory will be more compact
23:16:10 <augur> dolio: but i need to put them all together into one big file :(
23:16:24 <applicatiative> you can append them to the file
23:16:25 <dolio> So open the big file once outside the loop.
23:16:35 <augur> hm
23:16:54 <applicatiative> augur: the problem is the excess of options.
23:16:55 <augur> ill see if that helps
23:17:03 <augur> but i dont think the error im getting is going to go away
23:17:12 <applicatiative> theres only thirty seven ways to do it!
23:17:29 <augur> applicatiative: 37 ways that are all completely opaque to me :(
23:17:43 <augur> IO was so much simpler when i didnt care about type safety
23:18:19 <applicatiative> io is so much simpler when everything is io?
23:18:28 <augur> that too
23:19:17 <tabemann> but monads help ensure that your code is safe and you know exactly what operations are side-effecting (so to speak)
23:20:27 <augur> tabemann: at this point i dont care about safety
23:20:34 <augur> since im just processing some files
23:21:01 <augur> i wouldve just done this in bash but im having problems with bash's recursive file thing
23:30:51 <johnw> augur: I have some code that works
23:31:08 <augur> >_>
23:31:23 <johnw> http://hpaste.org/89587
23:31:30 <augur> so do i, courtousy of #bash >_>
23:31:47 <johnw> heh
23:32:01 <johnw> so, that code needs to exit if mfname is ever Nothing
23:32:17 <johnw> so it needs a little work; but you can see that it's rather simple to write resource-conservative code that operates efficiently using conduit
23:33:32 <dolio> I bet the lazy I/O version that works is simpler. :)
23:33:42 <johnw> likely
23:33:42 <Gracenotes> right tool for the right job
23:33:53 <Gracenotes> or for the wrong job
23:33:56 <Gracenotes> any kind of job
23:33:59 <johnw> it is a bit easier to scale conduit code; but for simple scripts, lazy I/O is often preferable
23:39:37 <augur> johnw: ALAS
23:39:42 <augur> i will have to use haskell
23:40:12 <johnw> i improved the hpaste
23:40:47 <johnw> i'm getting a strange exception that I don't quite understand yet though
23:41:36 <johnw> ok, http://hpaste.org/89587 is working like a champ now
23:41:44 <johnw> you just have to parameterize it on the directory and your filter function
23:43:49 <augur> johnw: i wish i understood any of that
23:44:36 <soko> t::=fK::= f | S S ::=  f_u(K1,…,Kn)   according this grammer f_u(f1,f'_u(f2,f3),f_u(f4),f5) is a term. I need to have grammar where such terms are not generated. So, what I need is each entrance of f_u in a term has to be unique…
23:46:06 <johnw> augur: refresh the pastie
23:46:12 <soko> K::= f | S and  S ::=  f_u(K1,…,Kn)   according this grammer f_u(f1,f'_u(f2,f3),f_u(f4),f5) is a term. I need to have grammar where such terms are not generated. So, what I need is each entrance of f_u in a term has to be unique…
23:46:15 <johnw> I simplified it, at the cost of loading the whole file list into memory first
23:46:25 <johnw> the previous version scanned the files as they were read in
23:46:29 <augur> johnw: >_>
23:46:35 <augur> doesnt mean i understand any of this
23:46:43 <augur> ill try to understand it tho
23:46:46 <johnw> augur: start here: http://www.yesodweb.com/blog/2011/12/conduits
23:46:57 <augur> meanwhile, the bash script works fine >_>
23:47:12 <johnw> but you just said it has to be in Haskell
23:47:19 <augur> i thought it did
23:47:21 <augur> turns out it didnt!
23:47:27 <soko> can someone help me?
23:47:30 <johnw> are you familiar with iterators and generators in Python?
23:47:40 <augur> johnw: not really no
23:47:48 <johnw> ah, n/mthen
23:47:53 <augur> i know they exist but ive never properly understood them
23:49:22 <johnw> so the code to the left of a $$ calls "yield" for every value it produces, and the code to the right $$ calls "await" for every value it wishes to consume, until the producer or the consumer just "ends", at which points any open resources are finalized
23:49:39 <augur> johnw: not right now x.x
23:49:42 <johnw> ah, ok
23:52:34 <augur> i really should find a good bash intro that explains how bash does its magic
23:56:54 <TravisD> When using monad transformers is it common to use a type synonym to name the monad stack?
23:58:15 <johnw> I can't speak to what's "common", but I do that
23:59:03 <TravisD> johnw: Do you use a "newtype" or just a "type"?
23:59:19 <shachaf> As monochrom said: "type synonym means failing to make up your mind whether you want an abstraction or not"
23:59:39 <TravisD> yeah, shachaf, I agree with that. But it feels like a pain to use newtypes
23:59:51 <shachaf> I wish newtypes were more convenient. But for monad transformers they are not so bad.
23:59:56 <shachaf> You can use GeneralizedNewtypeDeriving! Everyone's favourite extension.
