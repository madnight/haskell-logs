00:01:29 <wagle> i'm getting something similar
00:03:01 <palmje> ah, so it's something with the build then...
00:06:46 <wagle> maybe..  i'm uninstalling everything and trying again, but that shouldnt work
00:06:54 <snoyberg> hi all, i'm wondering if anyone else has seen this problem, when trying to use regex-pcre-builtin, i get the error message: unknown symbol `utf8_table4'
00:07:09 <snoyberg> this only started once i installed ubuntu 13.04 i believe, on 12.04 everything seemed to be ok
00:07:26 <wagle> i'm currently dealing with that problem on macosx
00:07:55 <wagle> sounds like someone bumped the version gratituitously
00:14:03 <wagle> sha1 matches
00:28:36 <lispy> roboguy_: yeah, you should use what feels right. I just wanted to say that, hey, vim is not so bad and tmux is nice too (in my opinion :)
00:39:40 <wagle> snoyberg: you using gitit?
00:41:22 <snoyberg> wagle: no
00:42:37 <wagle> snoyberg: hmm..  well, i'm rebuilding gitit from complete scratch..  will see if I make it through, else, i'd go back to previous version of haskell-platform
00:57:11 <ksf_> http://hpaste.org/90291
00:57:47 * ksf_ is lost on how to implement either for TDB. The lambdas just don't match up, making the type checker barf.
01:01:07 <ksf_> goddamnit.
01:01:29 <ksf_> am I making a fool out of myself for using you people as rubber ducks?
01:02:26 <chrisdone> don't worry, it'll all be forever preserved on ircbrowse
01:02:37 <ksf_> hmm. nope that won't work either.
01:03:39 <ksf_> it typechecks, that is, but it only works for one side of the either.
01:03:48 <wagle> discovered that i was trying to run old binaries compiled by previous versions of ghc, but that wasnt it
01:03:50 <wagle> trying now to retro to 2012.4.0.0
01:15:34 <wagle> ksf_: you using 8 space tabs?
01:16:38 <wagle> i think ghc does (or did at some point) equate TAB to 8 spaces, so if you have lineup problems, that might be it, else I dunno
01:17:32 <ksf_> wagle, nope
01:17:44 <ksf_> and no it's not related to that.
01:19:06 <wagle> yeesh (started looking at it)..  what options are you using to get it to be so completely picky?
01:19:33 <wagle> error to not eta reduce?
01:19:43 <Saizan> ksf_: is TDB coming from the paper?
01:20:02 <ksf_> yep
01:20:08 <ksf_> well it's gotten a bit bigger by now
01:20:21 <ksf_> but the general lambda stuff is the same.
01:20:55 <ksf_> wagle, those are hlint warnings
01:21:19 <sordina1> Heya. Is there some generalization of (Maybe a -> MaybeT m a)  that works on all transformers?
01:21:24 <wagle> ok..  only errors I saw
01:22:46 <startling> sordinal, lift?
01:23:01 <startling> sordina1, well, depends what you want
01:23:12 <ksf_> ...error is in the annotation, just pasted it.
01:23:31 <startling> do you mean a general  Whatever a -> WhateverT m a?
01:23:39 <sordina1> startling: yep
01:23:40 <ksf_> http://hpaste.org/90291
01:24:24 <Saizan> ksf_: i think you need to "map" tshift on l
01:24:41 <Saizan> or something similar
01:25:02 <Saizan> you can't just ignore the inner context like you do with const
01:25:31 <ksf_> yeah those aren't bools, they're not terminal.
01:26:40 <ksf_> oooh.
01:26:43 <kqr> if i intend to have a Map String [Int] but it might get quite big and run into performance problems, what are the suggested implementations? data.map.strict? data.hashmap.strict?
01:28:38 <startling> sordinal, I don't know if a general version of that makes sense
01:29:21 <Saizan> kqr: something more compact than [Int] would be better too
01:29:38 <zvrba> why isn't it possible to compare functions with == ? as in, function pointers?
01:29:54 <zvrba> like, (+) == (+)
01:30:08 <Saizan> it'd kill nice properties of the language
01:30:12 <kqr> Saizan, Vector Int?
01:30:14 <sordina1> startling: Neither do I. It seems weird that I have to define something to do if for maybe though.
01:30:14 <zvrba> such as?
01:30:15 <Saizan> and it's unreliable
01:30:24 <ksf_> zvrba, referential transparency.
01:30:33 <Saizan> zvrba: functional extensionality
01:30:41 <shachaf> kqr: It depends on what you do with it.
01:30:45 <zvrba> Saizan: what is f.e. ?
01:31:12 <ksf_> as solving the halting problem is impossible you'd need some other way to compare, and that means being able to distinguish \x-> x+x and \x -> x*2
01:31:15 <startling> zvrba, map f (x : xs) = if f == (+ 1) then [] else f x : map f xs
01:31:18 <Saizan> zvrba: but if you really want there's StableName or even reallyUnsafePtrEquality for stuff like that
01:31:23 <sordina1> It's just (MaybeT . return), but I think the issue is that transformers have no knowledge of their extended monand.
01:31:41 <kqr> shachaf, i intend to create faster lookups of particular words in a big pile of Text by chunking the Text up and mapping words to indices where the words are located
01:31:44 <sordina1> Correct me if I'm worng.
01:31:44 <kqr> shachaf, if that is of any help
01:32:08 <zvrba> ksf_: yeah, like its compiled address...?
01:32:12 <shachaf> kqr: So what you have is actually more like Map String (Set Int)?
01:32:16 <Saizan> zvrba: functional extensionality is when only which arguments are mapped with which results matter for the identity of a function
01:32:30 <Saizan> *mapped to
01:32:43 <zvrba> Saizan: no, i don't need it for anything in particular. i'm just annoyed that ghci cannot print out functional values, showing an error message instead.
01:32:58 <zvrba> whereas a sane show for a function would be its type+identity (=address)
01:33:17 <Saizan> i don't think that'd make a sane Show instance
01:33:23 <FreeFull> startling: But there is no Eq instance for functions
01:33:35 <startling> FreeFull, thats what zvrba is asking about
01:33:40 <Saizan> but it could be fine in ghci as a debugging mechanism
01:34:02 <zvrba> Saizan: is it not true that every function in haskell has a stable address?
01:34:12 <kqr> shachaf, i was hoping i'd be able to store the same index multiple times if the word occurs multiple times in the chunk, but a Set might work too
01:34:24 <ksf_> zvrba, StableName etc.
01:34:34 <zvrba> (in the end, given a function name, you HAVE to somehow find a unique 'address', or equivalent, else you wouldn't be able to execute it)
01:34:35 <Saizan> zvrba: some are allocated on the heap as closures
01:35:00 <Saizan> zvrba: but still, we don't want to be able to tell (\x -> x+x) and (\x -> 2*x) apart
01:35:00 <ksf_> zvrba, you need the closure environment, too.
01:35:05 <zvrba> hence, == would be indentity (address) comparison, not operational equality.
01:35:20 <ksf_> yeah but that's of no interest.
01:35:21 <zvrba> Saizan: why not?
01:35:22 <shachaf> kqr: OK. So you want the behavior of Map String (Bag Int) or something like that? The order doesn't matter, anyway?
01:35:29 <kqr> shachaf, yeah, right
01:35:38 <Saizan> zvrba: because then reasoning about our programs gets harder
01:35:47 <zvrba> aha
01:36:05 <zvrba> sorry, I misread that statement as "we want to be able.."
01:36:16 <zvrba> nvm
01:36:46 <zvrba> ksf_: so you compare addresses of the corresponding closures.
01:36:52 <zvrba> nvm
01:37:00 <zvrba> where does StableName reside?
01:37:19 <zvrba> I just want to test it on some built-in functions
01:37:49 <shachaf> StableName is not going to do what you want.
01:38:05 <ksf_> Saizan, on second thought, the type level should take care of everything as I'm not introducing any new bindings, so nothing moves.
01:38:16 <ksf_> I shouldn't have to touch ctx, that is.
01:39:44 <Saizan> ksf_: inl might be calling the argument under a lambda
01:40:03 <Saizan> ksf_: so you'll have to shift the indices accordingly
01:40:46 <NerrZ> how do I install the platform in ubuntu?
01:42:58 * ksf_ thinks he should do the untyped case first
01:43:08 <shachaf> NerrZ: The same way you install anything else?
01:43:23 <ksf_> choose your battles wisely etc.
01:43:38 <Saizan> ksf_: but the typed one is easier!
01:43:39 <NerrZ> haskell-platform isnt a package for apt-get
01:43:54 <NerrZ> and I am really new to ubuntu, sorry if this is easy
01:43:58 <ksf_> yeah but with the typed one I have to argue with ghc, instead myself.
01:44:24 <shachaf> NerrZ: Ah. How do you know?
01:44:29 <Saizan> that's the point
01:45:06 <ksf_> in particular, ghc *not* letting me make mistakes is nasty, here.
01:45:15 <NerrZ> I typed sudo apt-get install haskell-platform and got nothing, ghc worked but it was just the compiler
01:45:48 <shachaf> "nothing"? No text was printed out?
01:46:10 <shachaf> (This is perhaps more of a question for #ubuntu than this channel, but even then you'll need to ask your question in such a way that people can help you.)
01:46:12 <zvrba> NerrZ: apt-get search haskell and look for something appropriate
01:46:29 <shachaf> I looked it up on ubuntu.com and found http://packages.ubuntu.com/quantal/haskell-platform
01:46:46 <shachaf> So apparently something exists. So something is going wrong somewhere and you don't know where.
01:47:00 <NerrZ> yes
01:47:01 <shachaf> So the problem isn't where you think it is. :-)
01:47:31 <Saizan> http://askubuntu.com/questions/286764/how-to-install-haskell-platform-for-ubuntu-13-04 <- something like this?
01:48:00 <ksf_> worse, I might want to throw unsafeCoerce at the proof, so I want to be sure that it's actually right. or necessary. or at least convinient.
01:55:36 <NerrZ> so I downloaded the tar, but what do I do with it
01:57:37 <Saizan> NerrZ: see build from source here http://www.haskell.org/platform/linux.html
01:58:14 <Saizan> (if that's the tar you're referring to)
02:01:17 <NerrZ> thanks, real newbie here
02:15:28 * hackagebot hx 0.3 - Haskell extras (missing utility functions).  http://hackage.haskell.org/package/hx-0.3 (JulianFleischer)
02:16:00 <zvrba> is tail-recursion something to worry about in haskell? i.e., try to make functions tail-recursive through an auxiliary accumulator?
02:16:39 <zvrba> (I'm reading the definition of filter)
02:16:41 <Saizan> only when you are writing strict functions
02:17:07 <johnw> zvrba: I was just reading an article about that last night
02:17:46 <Saizan> filter can produce its result lazily, so it's better to do so, it won't consume stack
02:18:02 <zvrba> ok
02:18:28 <ksf_> Saizan, why am I trying to put a case switch into a data structure that should be fully serialisable?
02:18:43 <johnw> zvrba: http://scienceblogs.com/goodmath/2006/12/20/tail-recursion-iteration-in-ha-1/
02:19:02 <Saizan> actually, filter is strict too, what matters is the strictness of the function in tail position
02:19:02 <ksf_> It's not like I'm trying to evaluate the thing, after all.
02:19:28 <zvrba> what makes filter strict?
02:19:48 <Saizan> filter f _|_ = _|_
02:20:01 <zvrba> because it evaluates the head of the list?
02:20:05 <Saizan> yeah
02:20:13 <shachaf> Well, the first cons cell.
02:20:14 <Saizan> well, the outermost constructor
02:20:21 <shachaf> Not head as in "head".
02:20:38 <zvrba> yeah, i meant the first cell
02:21:18 <zvrba> hm
02:21:23 <zvrba> so what makes a function strict or lazy?
02:21:24 <Saizan> ksf_: heh, i assumed you wanted to remove redexes
02:21:34 <ksf_> !
02:21:35 <zvrba> i mean, everybody says that haskell is lazy by default
02:21:43 <zvrba> yet Saizan said that filter is strict.
02:21:46 <zvrba> which makes..?
02:21:57 <Saizan> haskell allows you to write lazy functions
02:22:04 <notdan> Hm, I am a little bit confused. If I have a Monad m (and it's trans version mt) which transformer stack corresponds to (s -> (m a, s))?
02:22:12 <Saizan> but not all of them will be
02:22:15 <zvrba> johnw: thanks for the link.
02:22:32 <zvrba> what forces evaluation?
02:22:36 <Saizan> we should say non-strict when talking semantics though
02:22:41 <shachaf> Strictly speaking, filter isn't strict, but it returns a strict function. :-)
02:23:00 <notdan> 'StateT s m' is s -> m (a, s), and 'mt (State s)' is m (s -> (a, s))
02:23:10 <zvrba> shachaf: hmm, i get it.
02:23:36 <Saizan> zvrba: pattern matching is the main source of strictness, also some built-in functions like (+) for Int
02:23:36 <zvrba> so filter _|_ [] should not end up in infinite loop?
02:23:44 <johnw> zvrba: haskell is lazy by default; whether a given function is strict is one or more of its arguments is up to that function
02:23:45 <notdan> And I basically want (State s (m a))
02:23:58 <arkeet> zvrba: indeed.
02:23:59 <Saizan> zvrba: filter _|_ [] = []
02:24:01 <arkeet> @src filter
02:24:02 <lambdabot> filter _ []     = []
02:24:02 <lambdabot> filter p (x:xs)
02:24:02 <lambdabot>     | p x       = x : filter p xs
02:24:02 <lambdabot>     | otherwise = filter p xs
02:24:03 <notdan> Wait, that's not possible I guess
02:24:17 <zvrba> arkeet: yeah, reading the source in LYAH
02:24:24 <zvrba> how does one produce bottom value in haskell?
02:24:34 <Saizan> > undefined
02:24:36 <lambdabot>   *Exception: Prelude.undefined
02:24:36 <arkeet> a bunch of ways.
02:24:43 <arkeet> undefined, or error, or an infinite loop...
02:24:49 <johnw> > let x = x in x
02:24:52 <lambdabot>   mueval-core: Time limit exceeded
02:24:55 <zvrba> but a signature of a -> Bool, having bottom as "result"
02:25:04 <zvrba> i want to test filter :P
02:25:05 <arkeet> same thing
02:25:06 <ksf_> > undefined :: a -> Bool
02:25:07 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
02:25:08 <lambdabot>    arising from a use ...
02:25:08 <arkeet> > filter undefined []
02:25:09 <johnw> const undefined
02:25:09 <lambdabot>   []
02:25:16 <arkeet> johnw: no, const undefined isn't bottom
02:25:20 <arkeet> seq knows :p
02:25:28 <johnw> good point, thanks
02:25:32 <zvrba> ok!
02:25:42 <arkeet> :t undefined -- this has any type.
02:25:43 <lambdabot> a
02:25:59 <arkeet> :t let x = x in x -- this has any type too.
02:26:00 <lambdabot> t
02:26:11 <arkeet> :t fix id
02:26:12 <lambdabot> a
02:26:28 <zvrba> hmm
02:26:29 <johnw> arkeet: I was answering the "how do I write a -> Bool that returns bottom"
02:26:52 <arkeet> I wasn't sure what exactly was asked.
02:26:55 <zvrba> given let x = x in x ... does the 2nd x refer to the 1st x or to the x found in the enclosing environment?
02:26:55 <wagle> do hackages have blame assignment in the source code, like who changed what, when?
02:27:02 <arkeet> zvrba: let is recursive
02:27:06 <zvrba> oh
02:27:17 <arkeet> > let x = 1:x in x
02:27:18 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:27:22 <ksf_> wagle, hackage doesn't care about version control.
02:27:28 <ksf_> it records uploaders, though.
02:27:39 <wagle> eww
02:27:46 <ksf_> version control is out of scope.
02:27:50 <ksf_> use what you want.
02:28:10 <ksf_> abandon the project and repo, have someone clone it and continue maintaining the hackage thing.
02:28:12 <wagle> regex-pcre-builtin has a new bug
02:28:18 <ksf_> it's a package, not a source repository.
02:28:51 <zvrba> hm
02:28:53 <johnw> zvrba: undefined really means "undefined".  The behavior could be a crash, hang, exception, etc.; there is just no answer.  that's why head on an empty list is undefined; what could it possibly mean?
02:29:00 <ksf_> Maintainer	TextRegexLazy@personal.mightyreason.com
02:29:28 <wagle> yeah, ok..  thought i'd at east try to figure out the problem
02:29:30 <zvrba> hm, i'm skeptical about that good math blog
02:29:34 <wagle> least
02:29:34 <arkeet> well, there's undefined in the sense of UB, and there's the value called undefined
02:29:46 <ksf_> wagle, cabal unpack regex-pcre-builtin
02:29:53 <ksf_> then debug. make a diff, send it via email.
02:29:54 <zvrba> he's talking about stack space, whereas, as far as i've understood it, haskell builds calls on the heap
02:29:59 <johnw> arkeet: isn't evaluating undefined in the realm of UB?
02:30:02 <wagle> ksf_ i did..  its a tricky bug
02:30:03 <ksf_> or something like that.
02:30:05 <zvrba> it's wasteful of space, but it won't overflow the "stack"
02:30:12 <arkeet> johnw: depends on what behaviour you're looking at.
02:30:12 <johnw> although, I suppose the exception that it throws is well defined?
02:30:26 <arkeet> > undefined
02:30:28 <lambdabot>   *Exception: Prelude.undefined
02:30:33 <zvrba> it seems more like that laziness is data-structure builder, where alloc+link (in C) corresponds to haskell function call
02:30:41 <ksf_> oh. auhrey actually maintains -bultin, not christopher
02:31:22 <johnw> zvrba: you can blow stack in Haskell as well
02:31:25 <arkeet> johnw: I think we just trust that undefined will crash the program without launching missiles or the like in the process.
02:31:42 <johnw> launchZeMissiles!
02:31:55 <zvrba> johnw: thinking operationally kinda defeats the point of FP and Haskell
02:32:10 <johnw> zvrba: yes, thinking operationally causes no end of troubles
02:32:30 <arkeet> sometimes it matters though.
02:32:32 <johnw> unless you are digging into Core to analyze performance or something
02:32:36 <arkeet> like that.
02:32:41 <arkeet> or not even core
02:33:32 <johnw> i kind of now view operational thinking the same way in C++ I viewed reading assembly code
02:33:46 <johnw> it's something you should be able to do, but only when it's truly called for
02:34:46 <shachaf> "operational thinking" can mean a lot of things and at least some of them you should probably be keeping in mind when you write code.
02:35:16 <johnw> shachaf: what kinds of things should always be in mind?
02:35:55 <arkeet> even stuff like asymptotics counts.
02:35:58 <arkeet> as operational.
02:36:05 <johnw> when I say operational here, I mean "thinking in terms of how the code is actually going to be executed by the Haskell runtime"
02:36:28 <arkeet> the denotational semantics doesn't care whether your list algorithm runs in linear or n^20000 time.
02:36:34 <johnw> so, thinking in terms of function calls and stacks, rather than just evaluation of lambdas, for example
02:36:50 <arkeet> evaluation is operational.
02:36:56 <johnw> ooh
02:37:11 <johnw> point to arkeet
02:37:30 <arkeet> if you're talking about doing stuff, it's operational.
02:37:38 <arkeet> if you're talking about what stuff is, it's denotational.
02:37:54 <Saizan> tbf, a denotational semantics is an evaluator :)
02:38:01 <Peaker> my profiling analysis thingie is already helping me figure out what's going on, yay!
02:38:07 <arkeet> I'm being really loose with what I say.
02:38:46 <johnw> I guess I'm being imprecise too
02:38:47 <Saizan> but yeah, you want to keep in mind call-by-need for example, and that's quite firmly in the operational camp
02:38:57 <Peaker> I print top 1000 CCs inherited-time-wise, which is useful separately form the top self-time consumers already printed by +RTS -p and gave me useful insight.. also let you dig into the printed tree with a wx tree view in a sorted-by-inherited-time order, which is very useful
02:39:07 <shachaf> Saizan: Right.
02:39:35 <shachaf> Yes, I don't really need to say things when arkeet and Saizan are here to say them for me.
02:40:46 <johnw> Saizon: good point
02:41:03 <ksf_> Haskell isn't lazy but non-strict, though.
02:41:08 <johnw> i should avoid any statements containing "should" and "always" anyway, they always get me into trouble here
02:41:17 <johnw> doh!
02:41:17 <ksf_> ghc is free to pass by value as long that's not strict.
02:44:38 <Peaker> is there anything like Data.Binary that recovers sharing according to serialized equality?
02:44:53 <Peaker> (same type, same binary repr --> deserialize to same value ref)
02:51:43 <merijn> Peaker: Oh...that'd be neat, you could serialise knot-tied infinite lists in finite space...
02:51:54 <merijn> Peaker: Seems like it'd be tricky to implement, though...
02:52:05 <merijn> iow most likely not :p
02:59:40 <FreeFull> What does the ~ in  instance i ~ j => Indexable i (Indexed j)  mean?
03:00:22 <shachaf> Type equality constraint.
03:01:18 <shachaf> It means something like instance Indexable i (Indexed i) except it helps inference since it matches immediately, without any possibility of overlapping instances or anything like that.
03:02:48 <merijn> Bah
03:03:06 <FreeFull> shachaf: I see
03:03:11 <merijn> No one has supported by idea for having a Vacuous constraint in GHC :(
03:03:18 <merijn> s/by/my
03:04:21 <shachaf> Vacuüs
03:05:43 <Kinnison> :-)
03:06:08 <merijn> Seems like it shouldn't be hard to add, and it make a lot of my ugly type hacks nicer
03:07:41 <merijn> "Vacuous :: Constraint", or even better "Vacuous :: Symbol -> Constraint" <- type level error message!
03:08:17 <shachaf> What's wrong with () ~ Bool?
03:08:50 <shachaf> "oops" ~ "your message"
03:08:57 <merijn> Oh!
03:09:05 <merijn> Actually, that nice one might work
03:09:15 <merijn> s/nice/last <- brainfart
03:10:10 <shachaf> type Oops a = "oops" ~ a
03:15:51 <merijn> And suddenly I feel like I want "type Show :: * -> Symbol" or even "type Show :: k -> Symbol" >.>
03:16:33 <merijn> I really should learn a DT language one of these days...
03:21:22 <ggg> hello. I'm new to haskell. Is there an operator with the type (m a -> (a -> b) -> m b). I want to do something like ((Just 3) ? ((+) 2)) and get (Just 5).
03:21:40 <ggg> seems like it would be a pretty essential function but google isn't helping me.
03:22:58 <apples`> :t flip liftM
03:22:59 <lambdabot> Monad m => m a1 -> (a1 -> r) -> m r
03:23:57 <merijn> ggg: liftM or fmap
03:24:26 <merijn> ggg: Most Monads (soon it will be ALL monads! Go AMP proposal!), are Functors too
03:24:40 <merijn> For example, Maybe is a functor
03:24:42 <merijn> :t fmap
03:24:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:25:07 <shachaf> ggg: Some people call this operator (<&>).
03:25:21 <shachaf> > (+2) <$> Just 3
03:25:22 <lambdabot>   Just 5
03:25:35 <merijn> Which you can read as "(a -> b) -> Maybe a -> Maybe b", then it's just a small matter of flip'ing the fmap
03:25:38 <shachaf> merijn: They never specified that m was a monad, anyway!
03:25:46 <merijn> Oh, true!
03:26:12 <merijn> ggg: Unrelatedly, you can write "((+) 2)" as "(+2)"
03:26:30 <shachaf> Well -- you can write it as (2 +).
03:26:53 <shachaf> (+ 2) means (\x -> (+) x 2), which is the same if (+) is commutative.
03:32:49 <Tomsik> Hello
03:33:44 <Tomsik> Is there a way to perform action when GC detects that something is no longer visible?
03:33:50 <aristid> shachaf: which of course there is indeed no law in Num for, because Num has no laws.
03:34:18 <Tomsik> e.g. I have a file handle, but it's replicated in a few threads and I would want to release it when all of threads release it
03:34:43 <Tomsik> kind of like shared_ptr in c++
03:34:56 <startling> Tomsik, I'd be surprised if there were
03:35:09 <startling> you can refcount yourself though
03:35:16 <aristid> Tomsik: GC is not the right way to handle that
03:35:40 <Tomsik> Well, I'm not saying I want GC exactly, but I don't think there's a way to replicate RAII in Haskell, is there?
03:35:46 <Tomsik> otherwise I might mess refcount somewhere
03:36:08 <Tomsik> e.g. lose a handle without noticing it
03:37:08 <merijn> Tomsik: Maybe you wanna mimick the approach of bracket?
03:37:32 <Tomsik> Maaybe, but I'd like it to be tied to data, not function
03:37:51 <merijn> Tomsik: A common approach is to have things like "withPtr :: Ptr a -> (a -> IO b) -> IO b"
03:37:53 <startling> Tomsik, there's a thing but I can't remember the name
03:38:19 <merijn> Tomsik: There's a Ptr type that lets you write a special destructor, maybe look into how that's done?
03:38:47 <startling> Tomsik: aha, "regions" might be a productive search word
03:39:13 <merijn> Tomsik: FinalizerPtr in Foreign.ForeignPtr lets you attach finalizers to them, so that might be the best way to go
03:39:40 <merijn> Tomsik: Although those still might result in the finalizer not running if you run into an exception terminating your program
03:39:48 <aristid> startling: i wonder if there's a reference-counted equivalent to that
03:40:02 <shachaf> GC gives you no guarantees about the release code ever being run, of course.
03:40:08 <Tomsik> Well, I'm not worried what happens when program terminates, I want to avoid resource-leak
03:40:48 <aristid> Tomsik: closing handles is not just about resource leaks
03:41:06 <aristid> Tomsik: closing the handle can force the last few bytes to be written to the file and stuff like that
03:41:26 <Tomsik> Well, that was just an example, my actual resources are kind of unique ids
03:42:05 <Tomsik> and I want to associate some information with them and need to get rid of them when they are no longer needed
03:42:27 <aristid> Tomsik: i think what might work is writing a little reference-counting wrapper around your not-Handle, and using bracket (or if you want to get fancy, a region-package) to manage those
03:43:05 <startling> aristid: yeah. I can see how it would work at least.
03:43:08 <aristid> :t bracket
03:43:09 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
03:43:43 <aristid> hum named arguments might help there :D
03:43:57 <Tomsik> That's what I thought first, but if I try to add these to a datatype then they'll leak out of bracket
03:44:15 <startling> then don't add them to a datatype that you plan on returning
03:44:29 <Tomsik> I mean, I don't know how long these will live
03:45:01 <aristid> Tomsik: do you want to use those not-Handles in a pure data structure?
03:45:13 <Tomsik> That'd be ideal
03:45:54 <aristid> sounds impure :/
03:46:03 <aristid> but maybe something like this can help: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-Weak.html
03:46:09 <startling> I feel like you could do some magic with Applicative
03:46:29 <quchen> aristid: bracket :: IO alrightLet'sTryThis -> (alrightLet'sTryThis -> IO bullshit) -> (alrightLet'sTryThis -> IO choice) -> IO choice
03:46:40 <aristid> quchen: :)
03:47:01 <Tomsik> Oh, weak looks like what I need
03:47:22 <ggg> thanks guys!
03:47:29 <startling> quchen, wow, I didn't know apostrophes could be in arbitrary places in identifiers
03:47:51 <aristid> Tomsik: there might even be a ready-made caching package somewhere on hackage :)
03:47:53 <quchen> startling: Haven't seen them in type signatures myself so far, I just assumed it works
03:48:07 <Tomsik> Sssh, I might not reinvent the wheel then.
03:48:08 <Tomsik> :P
03:48:17 <aristid> :t let quchen'likes'kuchen = 4 in 5
03:48:18 <lambdabot> Num a => a
03:48:19 <quchen> startling: Tried it, works. :-)
03:48:21 <Tomsik> Thanks for help
03:48:33 <startling> :t let don't _ = do { return (); } in don't
03:48:34 <lambdabot> Monad m => t -> m ()
03:49:01 <aristid> startling: i could even see that being useful in some cases :D
03:49:04 <quchen> aristid: Well it works in identifiers, I just wasn't sure whether it's legal in type signatures. In normal Haskell, ' is considered a letter if it's not at the beginning of an identifier.
03:49:15 <startling> aristid, I'm surprised lens hasn't moved in on it yet
03:49:19 <aristid> startling: although i disapprove of your unnecessary do {}
03:49:19 <merijn> startling: That's why I have a grammatically correct value named "can'tHappen" in my code :p
03:49:35 <aristid> don't _ = return () -- much better
03:49:37 <startling> aristid: it makes the joke better. >:(
03:49:43 <quchen> startling: You're not the first one to invent this. http://new-hackage.haskell.org/package/acme-dont
03:50:04 <aristid> startling: jokes are verboten
03:50:09 <startling> quchen, wow, they even used the apostrophe
03:51:08 <merijn> Man...I should develop some acme modules
03:51:17 <startling> aristid, anyway, all do notation is unnecessary
03:51:27 <startling> why stop there?
03:51:28 <aristid> startling: yes but sometimes it makes the code nicer
03:51:31 <merijn> If I'm not writing useful shit, I might as well write funny unuseful stuff
03:51:43 <aristid> merijn: that's the spirit
03:52:11 <quchen> What does "acme" stand for anyway?
03:52:31 <startling> quchen, it's a joke from american cartoons I guess
03:52:35 <Tomsik> Is Data.Unique thread-safe?
03:53:34 <startling> quchen, the company that makes all the weird shit (portable holes, camoflauge paint, flying capes) is given the most generic name possible ("acme")
03:53:53 <luite> Tomsik: yes, it uses atomicModifyIORef
03:54:00 <Tomsik> thanks
03:54:10 <quchen> startling: "acme" is the most generic name possible?
03:54:35 <chrisdone> it comes from the old road runner cartoons for a generic company name
03:54:44 <startling> quchen, supposedly a lot of companies started using it to get in the front of the phonebook
03:54:52 <startling> I guess "AAA" was considered tacky
03:55:09 <chrisdone> (at least, the humourous use)
03:55:21 <quchen> Good to know, thanks.
03:55:42 <startling> chrisdone: it was used in a lot of old Warner Bros cartoons iirc
03:56:12 <Taneb> acme was actually a company that made animation cels originally
03:56:25 <Taneb> Warner Bros adopted the name for a fictional company in looney tunes etc
03:56:34 <merijn> quchen: https://en.wikipedia.org/wiki/Acme_Corporation
03:57:04 <merijn> "The company name in the Road Runner cartoons is ironic, since the word acme is derived from Greek (αιχμή / ακμή ; English transliteration: acmē) meaning the peak, zenith or prime, and products from the fictional Acme Corporation are both generic and failure-prone."
03:57:46 <merijn> quchen: The whole ACME hierarchy of modules seems to focus on funny and failure-prone ;)
03:58:10 <merijn> See also
03:58:12 <quchen> merijn: Yes, acme-php gave me a pretty good hint about that.
03:58:14 <merijn> @hackage acme-php
03:58:14 <lambdabot> http://hackage.haskell.org/package/acme-php
03:59:20 <startling> sort :: [()] -> [()]
04:00:09 <startling> oh man, "instance Floating String where"
04:00:54 <quchen> startling: It's a flexibility tradeoff
04:02:02 <startling> quchen, looks really useful for getting real work done
04:02:59 <startling> notElem x ys = elem (not x) ys
04:15:31 * hackagebot weather-api 0.4.3 - Weather api implemented in haskell  http://hackage.haskell.org/package/weather-api-0.4.3 (PeterGoncharov)
04:50:12 <osa1> base package is coming with GHC right? is installing newer GHC only way to get a newer base package?
04:51:17 <elliott> basically yes
04:53:01 <osa1> elliott: are there more complex answers too?
04:53:15 <elliott> not really :)
04:53:19 <osa1> :-) ok
04:53:28 <elliott> you could probably install a new base but your computer would explode
04:54:17 <merijn> osa1: There are, but they all end in tears and wishing you hadn't tried
04:54:18 <osa1> not that I'll try but how can I do that?
04:54:24 <chrisdone> elliott: maybe that's what mmorrow did
04:54:35 <merijn> osa1: Why not just install a newer ghc?
04:54:57 <elliott> merijn: there are?
04:54:59 <osa1> merijn: see this question as a learning exercise, I already have 7.6.3
04:55:04 <elliott> I'm not aware of any way to upgrade base successfully at all.
04:56:05 <merijn> elliott: I didn't say those complex answers resulted in an upgraded GHC
04:56:24 <merijn> elliott: I said there were more complex answers that ended in tears and wishing you hadn't tried :p
04:56:53 <merijn> osa1: You could install 7.7! And play with overlapping type families!
04:58:37 <osa1> merijn: uh, sounds scary
04:59:08 <merijn> What, the 7.7 or overlapping type families?
05:03:32 <osa1> yeah
05:05:42 <b52> Could someone tell me what the type error in ceiling (length [2,3] / 3) * 4 want to tell me?
05:06:39 <supki> > (2 :: Int) / 3
05:06:40 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
05:06:40 <lambdabot>    arising from a use o...
05:06:53 <supki> > fromIntegral (2 :: Int) / 3
05:06:54 <lambdabot>   0.6666666666666666
05:06:59 <ion> b52: Try genericLength
05:07:53 <merijn> :t (/)
05:07:54 <lambdabot> Fractional a => a -> a -> a
05:08:35 <elliott> johnw: hey, you use a local Hoogle setup, right?
05:08:35 <merijn> b52: Basically, (/) only works on Fractional types, and Int is not a Fractional type. length returns an Int, so you're trying to divide an Int using /, hence it complains
05:09:00 <CaptainK> is it best to declare your type in this case?
05:09:15 <merijn> b52: Two possible solutions are genericLength (as ion mentioned) which returns a Num a, the other option is to use fromIntegral
05:09:35 <merijn> CaptainK: Type annotations won't help here
05:09:51 <CaptainK> ah ok
05:10:06 <merijn> CaptainK: Because type annotations can't turn length's Int into a Fractional
05:10:09 <merijn> :t genericLength
05:10:10 <lambdabot> Num i => [b] -> i
05:10:34 <merijn> You need to change the return type of length, or a conversion function.
05:11:03 <b52> merijn: ion thanks
05:12:45 <FreeFull> > genericLength [4,5,6] :: Float
05:12:46 <lambdabot>   3.0
05:14:33 <merijn> b52: Most haskell numeric operations require their arguments to have the same type as their return value, so if it complains with messages like these about No instance for Fractional/Floating/Real/whatever for Int/Double/etc check the argument types and sprinkle fromIntegral/realToFrac through the code
05:15:05 <randomclown> @pl \x y -> sum . zipWith (*) x y
05:15:05 <lambdabot> ((sum .) .) . zipWith (*)
05:15:27 <randomclown> why does 2 parameters make it so terrible
05:15:30 <zvrba> why did this end up in infinite loop: sum [sq | i <- [1..], let sq = i*i, sq < 10000]
05:15:31 <FreeFull> randomclown: I don't think that does what you want it to do
05:15:40 <randomclown> @pl \x y -> sum $ zipWith (*) x y
05:15:40 <lambdabot> (sum .) . zipWith (*)
05:16:19 <randomclown> FreeFull: I thought function application bindest the tightest
05:16:25 <ion> randomclown: That’s what @pl does. Makes code terrible.
05:16:41 <randomclown> binding to the wrong subexpression probably
05:17:15 <FreeFull> randomclown: Function application does bind tightest
05:17:25 <FreeFull> But . takes two functions
05:17:32 <shachaf> zvrba: What did you expect it to do?
05:17:37 <FreeFull> and zipWith (*) x y  isn't a function, just a list
05:17:55 <zvrba> shachaf: to stop generating the leist when sq >= 10000
05:17:59 <zvrba> *list
05:18:13 <shachaf> zvrba: How should it know to stop generating the list?
05:18:29 <merijn> zvrba: How would it know to stop?
05:18:32 <FreeFull> zvrba: Guards are basically like filters
05:18:33 <ion> zvrba: i <- xs, let sq = i*i, sq < 10000. How do you know you have reached the very last i whose sq is < 10000?
05:18:43 <ion> zvrba: See takeWhile.
05:19:01 <zvrba> shachaf: how does takeWhile know?
05:19:19 <merijn> zvrba: It doesn't, takeWhile just stop on the first false element
05:19:23 <ion> @src takeWhile
05:19:23 <lambdabot> takeWhile _ []                 =  []
05:19:23 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
05:19:23 <lambdabot>                    | otherwise =  []
05:19:26 <shachaf> takeWhile is defined to stop taking when it sees an element that doesn't match the predicate.
05:19:26 <zvrba> shachaf: eventually sq becomes >= 10000 why does it continue generating the list?
05:19:42 <shachaf> zvrba: Because what if sq will become < 10000 again?
05:19:43 <merijn> zvrba: Guards are not an until
05:19:53 <zvrba> shachaf: ahhh!
05:20:06 <shachaf> Yes, a guard is filter.
05:20:13 <shachaf> > [x | x <- [1..], even x]
05:20:15 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
05:21:05 <merijn> Hell, if you define a Num instance for calculation in Z mod p, future values might even be less than 10000 again!
05:21:30 <zvrba> merijn: ok, got it.
05:21:32 <merijn> Anyway, this should work
05:21:46 <zvrba> LYAH gives a working version.
05:22:17 <merijn> :t sum $ takeWhile (<1000) [sq | i <- [1..], let sq = i*i]
05:22:18 <lambdabot> (Enum a, Num a, Ord a) => a
05:22:41 <merijn> > takeWhile (<100) [sq | i <- [1..], let sq = i*i]
05:22:42 <lambdabot>   [1,4,9,16,25,36,49,64,81]
05:22:43 <shachaf> sum . takeWhile (<1000) . map (^2) $ [1..]
05:22:50 <merijn> FYI
05:23:03 <merijn> > takeWhile (<100) [i*i| i <- [1..]]
05:23:04 <lambdabot>   [1,4,9,16,25,36,49,64,81]
05:23:22 <merijn> zvrba: You can have arbitrary expresions left of |
05:23:53 <merijn> Although I guess the let was need for the "sq < 10000"
05:24:03 <zvrba> yeah, I've figured that out.
05:24:16 <zvrba> right, I don't like repeating the same expression
05:27:44 <zvrba> parse error on the first guard: http://hpaste.org/90296
05:27:49 <zvrba> any explanation?
05:27:52 <zvrba> as to why?
05:28:02 <zvrba> I've just typed in the code as it is in the book
05:28:45 <supki> does the book really have = on the first line?
05:28:46 <zvrba> bah, extraneous =
05:28:49 <zvrba> no
05:28:50 <zvrba> :S
05:29:09 <zvrba> ghc has as friendly error messages as C++ templates
05:29:35 <zvrba> except that kilobytes of vomit enabling you to *find* the error is replaced by 3 words.
05:29:39 <zvrba> :p
05:30:02 <merijn> zvrba: If you remove the = on the first line it should work
05:30:03 <kryft> If I want to do some I/O (in this case run a shell command) once every N seconds, what's the best way to do that?
05:30:08 <zvrba> merijn: yeah, it does.
05:30:09 <randomclown> zvrba: when you use guards you don't need the =
05:30:27 <merijn> kryft: How accurate do you want it to be?
05:30:49 <merijn> kryft: i.e. "once approximately every N seconds with some drift is ok" or "exactly every N seconds, no deviation!"
05:30:51 <elliott> kryft: fork a thread, loop
05:30:59 <elliott> kryft: http://stackoverflow.com/questions/8575118/sleeping-until-the-start-of-the-next-minute may interest
05:31:06 <merijn> kryft: If the former, take elliott's approach, yes
05:31:15 <kryft> Ok, thanks; it's the former yes
05:31:23 <elliott> well, that SO answer helps against drift.
05:31:32 <elliott> if you want "exactly" then you'll need a realtime OS :)
05:31:36 <kryft> haha
05:31:37 <elliott> s/answer/question/
05:31:44 <zvrba> what is the state of hugs these days? I've heard it has better error messages..
05:31:55 <merijn> kryft: The simplest case would be "forkIO . forever $ threadDelay myTimeUnit >> myAction
05:32:07 <merijn> zvrba: Completely unmaintained and bitrotting
05:32:12 <zvrba> ok :S
05:32:27 <merijn> zvrba: I heard the Helium guys are working on better type errors
05:32:34 <zvrba> what is helium?
05:32:39 <aristid> so helium is NOT bitrotting? interesting.
05:32:51 <merijn> aristid: I thought helium was still being worked on?
05:33:01 <merijn> I might be completely out of the loop and wrong
05:33:07 <zvrba> nvm
05:33:10 <zvrba> found it on wikipedia
05:33:25 <zvrba> it says preview release in april 2009
05:33:32 <merijn> zvrba: You get used to parsing ghc errors, though
05:33:50 <kryft> I'm planning to write a little tool for submitting and tracking jobs on a cluster. I often have one experiment (as, say, matlab code) that I want to run with a lot of different parameter combinations, and they can last quite a while and some of them can fail etc
05:33:57 <zvrba> merijn: the problems is when the message needs no parsing, as in "parse error"
05:34:09 <kryft> So it's probably more like check every N minutes or something and drift doesn't matter
05:34:12 <zvrba> nothing to parse as it's utterly uninformative
05:34:18 <merijn> zvrba: Ah, yeah
05:34:28 <elliott> I find parse errors by far the easiest to fix in Haskell.
05:34:35 <merijn> zvrba: The problem with haskell parse errors is that it's very hard for the compiler to guess what you meant
05:34:37 <elliott> perhaps you should try using layout ;)
05:34:39 <palmje> does anyone know what would be causing this problem? comes from the linker step: relocation R_X86_64_32S against `stg_CAF_BLACKHOLE_info' can not be used when making a shared object; recompile with -fPIC
05:34:47 <zvrba> elliott: i did use layout there :P
05:34:51 <merijn> zvrba: otoh, I don't really run into parse errors?
05:34:55 <palmje> this is using ghc 7.6.3 (generic amd64 build) - I can get it to work, but I have to use -dynamic and -fPIC
05:35:11 <elliott> now, type errors, those can be exciting.
05:35:15 <zvrba> merijn: I do, rather often, by accident. still learning the syntax.
05:35:21 <merijn> zvrba: Well, the problem with the parse error there is, what would you expect it to say?
05:35:26 <zvrba> I see why people appreciate LISP :P
05:35:30 <merijn> Missing function body?
05:35:41 <zvrba> merijn: give a list of production rules that were expected instead.
05:35:42 <merijn> Extraneous = before guards?
05:35:43 <zvrba> that would be ideal.
05:36:10 <zvrba> + a reference to the specification where the relevant grammar is described
05:36:20 <elliott> lisp has syntax errors too
05:36:23 <`Jake`> I'm using gtk2hs; if I put some stuff in a HBox and I want there to be a scrollbar if the window is too small, do I have to put it in a ScrolledWindow?
05:36:27 <elliott> you just get them inside special forms and macros
05:36:31 <merijn> zvrba: FWIW, if you're learning syntax there's a decent Haskell syntax cheat sheet
05:36:45 <zvrba> merijn: oh, link please?
05:36:53 <merijn> http://cheatsheet.codeslower.com/CheatSheet.pdf
05:38:52 <merijn> zvrba: Also, if you use vim, I'm trying to get a decent haskell layout-aware vim indenter going. It's very usable already! </self-pimping>
05:39:13 <arnsholt> elliott: My fave is Common Lisp's loop(), where the documentation is essentially a massive chunk of BNF (and a full chapter of the language spec)
05:39:22 <zvrba> oh, that was cool, will print it out tomorrow at work
05:39:58 <zvrba> merijn: using eclipse. + non-layout syntax, which I'll abandon when/if it becomes painful.
05:40:09 <zvrba> I hate counting whitespace :P
05:40:37 <elliott> I don't count the whitespace. I just indent my program as I would anyway.
05:40:41 <merijn> zvrba: You don't need to count whitespace in haskell, the rules are fairly simple
05:40:43 <elliott> I don't even do any alignment. just indentation.
05:40:48 <elliott> no mashing the space key
05:41:20 <FreeFull> You can always use the {;} syntax if you want
05:41:21 <merijn> https://en.wikibooks.org/wiki/Haskell/Indentation
05:41:39 <FreeFull> All Haskell code is writeable as a one-liner
05:41:44 <merijn> FreeFull: "if you want to get stabbed by the rest of the community" <- FTFY
05:41:58 <FreeFull> merijn: I'm thinking GHC-style
05:42:57 <merijn> The community in general dislikes GHC-style, GHC is mostly left that way because of SPJ's preference and historical reasons
05:43:28 <FreeFull> BigPixel uses GHC-style do blocks, and looks fine to me
05:43:59 <FreeFull> Although not fully like usual Haskell code you'd see around
05:44:23 <kryft> Apparently forkIO etc is covered in RWH chapter 24
05:45:20 <merijn> kryft: You could also just read the Control.Concurrent docs, they're fairly self-explanatory
05:45:49 <merijn> argh!
05:45:53 <kryft> merijn: All right, thanks
05:46:01 <FreeFull> kryft: also look at STM
05:46:04 <kryft> merijn: (Oh, and I do use vim :P)
05:46:10 <merijn> Lack of type level lambda's are why I can't have nice things...
05:46:19 <mauke> which language extensions can turn valid code into different valid code (apart from TemplateHaskell, BangPatterns, MagicHash, RebindableSyntax)?
05:46:45 <merijn> kryft: https://github.com/merijn/haskellFoldIndent
05:46:58 <elliott> mauke: at least a few more than that, let me see if I can dig up the detection program I am thinking of
05:47:03 <merijn> kryft: Feedback/bug reports welcome, I haven't gotten around to folding yet
05:47:51 <merijn> kryft: The behaviour while reindenting using = could use some more work (before it used to clobber your indent, now it doesn't, even when it should). Most normal cases should work nicely, though
05:48:03 <elliott> mauke: ok I can't so you'll just have to believe me. but at least CPP IIRC
05:48:12 <elliott> mauke: and uh maybe UnboxedTuples?
05:48:16 <elliott> not sure
05:48:17 <kryft> elliott: The latest commit references you
05:48:31 <elliott> no it references some "elliot" person
05:48:41 <kryft> elliott: Well yes, I assumed that was you
05:48:50 <elliott> I would never have such a terrible name
05:48:51 <merijn> elliott: To be fair it specifies elliot (sic) from #haskell :p
05:49:14 <kryft> clearly git commit --amend
05:49:15 <mauke> I can't use CPP because it chokes on <stdio.h>
05:49:37 <merijn> kryft: He was complaining that he didn't like the fact that the | from lining up with = in data declarations
05:49:51 <elliott> well, it's not the |
05:49:53 <elliott> it's when I write records
05:49:54 <chrisdone> ForeignFunctionInterface steals the 'foreign' identifer, but that's on by default in haskell2010
05:50:00 <merijn> kryft: Except I don't use git and the effort of undoing the commit and then redoing it was too much work for a silly typo
05:50:01 <elliott> when I do sum types I put the = on a new line
05:50:30 <merijn> chrisdone: That doesn't change valid code into valid but different code, though
05:50:38 <merijn> chrisdone: That changes valid code into syntax error
05:50:48 <chrisdone> merijn: obviously
05:51:18 <merijn> chrisdone: He was asking specifically about extensions that can turn valid code into different valid code
05:51:43 <zvrba> hm. reading LYAH it's evident that 0-ary functions act like constants. question being: if the "contstant" is doing non-trivial computation, will it get evaluated each time it is needed, or just once and remembered?
05:51:44 <chrisdone> yeah, i know, i read it
05:51:44 <b52> got someone a little code snippet how i can use QuickCheck and HUnit tests in a simple manner, using TH to combine prop_ and test_ into one large testset?
05:51:54 <merijn> zvrba: There are no 0ary functions
05:52:09 <mauke> zvrba: constants don't do computation
05:52:12 <zvrba> merijn: what does the signature something :: Int represent?
05:52:18 <elliott> it means it's an integer
05:52:18 <mauke> zvrba: an Int
05:52:19 <zvrba> if not 0-ary function?
05:52:19 <merijn> zvrba: An Int
05:52:23 <elliott> ok, an Int
05:52:27 <chrisdone> zvrba: don't i know you from #scheme?
05:52:29 <merijn> @hoogle conal everything is a function in haskell
05:52:29 <lambdabot> No results found
05:52:35 <elliott> lol, hoogle
05:52:35 <merijn> eh
05:52:38 <merijn> @google conal everything is a function in haskell
05:52:40 <merijn> Typo
05:52:41 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
05:52:41 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
05:52:45 <zvrba> chrisdone: dunno.. i've been there for a short time.
05:52:47 <merijn> zvrba: See that post
05:52:54 <chrisdone> zvrba: ah, it was ##c
05:52:58 <chrisdone> years ago
05:52:59 <merijn> Reflex to type hoogle in here :p
05:53:03 <zvrba> yeah
05:53:09 <zvrba> I used to hang in ##c alot
05:55:56 <merijn> zvrba: To actually answer the question, if you have "something :: Int" and it's used in multiple places, any computation that needs to happen to compute the value of something only happens once and is remembered.
05:56:49 <chrisdone> in ghc, with -O2
05:57:09 <merijn> zvrba: With one exception "something :: Foo a => a" won't be remembered as each mention of something might be using a different type, which means there's no meaningful way to keep the data around (see also the Dreaded MonoMorphism Restriction)
05:58:01 <zvrba> ok, so it's an Int
05:58:07 <zvrba> that was an informative post.
05:58:23 <mauke> http://i.imgur.com/eLNCvoC.gif
05:58:24 <chrisdone> zvrba: that specifically means something named from a let/where/case. fib 10 :: Int won't necessarily be remembered
05:58:31 <ij> Is it really hard to wrap your head around monads?
05:58:36 <merijn> ij: No
05:58:49 <ij> Then why is there so much dense text about it?
05:58:50 <mauke> ij: is it really necessary to wrap your head around monads?
05:59:15 <merijn> zvrba: Anyway if foo is a function that takes a lot of time, you an (in ghc) enforce sharing using let/where clauses
05:59:40 <ij> mauke, It feels like I've gotten my head around everything except that.
05:59:50 <acube> What configs do you use for haskell with vim?
05:59:52 <mauke> ij: so you understand Functor?
05:59:55 <merijn> zvrba: If foo is an expensive function then "let x = foo 1000 in (x, x)" will only evaluate it once
06:00:09 <elliott> ij: are you reading a haskell book?
06:00:19 <elliott> it will almost certainly cover monads. I also highly recommend the Typeclassopedia
06:00:28 <elliott> the main obstacle to understanding monads is thinking they're difficult or special.
06:00:32 <merijn> zvrba: While in theory the compiler could be smart enough to see that it only needs to evaluate it once in "(foo 1000, foo 1000)" GHC currently doesn't perform that analysis
06:00:34 <zvrba> merijn: I lost you at "different types". what is preventing automatic memoization of, let's say, fib?
06:00:44 <chrisdone> merijn: it does, with -O2
06:00:53 <mauke> zvrba: the fact that the compiler does no automatic memoization
06:00:53 <merijn> chrisdone: Oh?
06:00:55 <zvrba> while something :: Int _is_ automatically memoized.
06:01:02 <mauke> chrisdone: since when?
06:01:10 <mauke> zvrba: that's just variables
06:01:10 <merijn> zvrba: It's not memoised
06:01:38 <zvrba> oh. it's a value whose "thunk" is evaluated when you use it for the first time?
06:01:46 <merijn> zvrba: Yes
06:01:48 <zvrba> and then remains permanently evaluated.
06:01:57 <merijn> Yup
06:02:19 <merijn> zvrba: The reason for the exception is, imagine "foo :: Num a => [a]; foo = [1..]"
06:03:10 <zvrba> hmm, what about this?
06:03:11 <chrisdone> mauke: merijn: http://hpaste.org/90275
06:03:14 <ij> elliott, haskell.org/tutorial
06:03:17 <merijn> zvrba: Suppose I evaluate that up to 1 million Ints, then up to 1 million Doubles, 1 million Whatevers, you probably didn't want to keep all of those around
06:03:24 <zvrba> true.
06:03:29 <merijn> zvrba: Because obviously foo can be any of those
06:03:47 <zvrba> why is everybody saying "dreaded" monomorphism restriction?
06:03:57 <chrisdone> mauke: merijn: i don't think it can generally assumed, but it does happen. check the core output
06:04:04 <elliott> ij: yikes
06:04:19 <merijn> zvrba: If you write foo without the type signature, haskell will force the type to be monomorphic (i.e. Int, Double, whatever)
06:04:22 <elliott> ij: the Gentle Introduction has its fans. it's rather outdated and not very popular these days though. but if it works for you, great
06:04:38 <elliott> you may wish to consult another tutorial for help here, e.g. Learn You a Haskell's chapters on (applicative) functors and monads
06:04:41 <merijn> zvrba: The result is that the value can be kept once you evaluate it, but you lose the polymorphism
06:04:55 <merijn> zvrba: If you want polymorphism of foo you lose the ability to store the computed value
06:05:02 <elliott> zvrba: because it's not a very nice restriction
06:05:13 <mauke> chrisdone: wtf am I looking at?
06:05:49 <zvrba> merijn: oh, ok.
06:05:51 <merijn> zvrba: It's called "dreaded" because newbies will write code like "foo = [1..]" without a type signature and then get really confused when they pass foo to function expecting [Int] and one expecting [Double] and getting a type error (because the compiler made foo monomorphic to one of those)
06:07:13 <merijn> zvrba: Anyway, according to chrisdone ghc does do limited optimisation of sharing, but in general it's just simpler to introduce a let/where if you want to be sure ghc shares the result of a computation
06:07:15 <zvrba> ahh, ok.
06:07:32 <elliott> GHC does do common subexpression elimination
06:07:35 <elliott> just conservatively
06:07:46 <zvrba> merijn: how do you share it across recursive calls? as in, recursive fibonacci implementation?
06:07:56 <zvrba> but not in exponential time
06:07:57 <elliott> using a memo table of some description
06:08:08 <merijn> zvrba: By being cool and not computing fibonacci like the normal recursive call
06:08:12 <zvrba> :)
06:08:18 <chrisdone> map (foo bar) […] sometimes works, too, e.g. it will compile to core of: map foobar […] where foobar = foo bar
06:08:23 <elliott> there's a rather famous technique using a simple lazy array/list/tree
06:08:28 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs -- Let your mind be blown
06:08:30 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:08:34 <elliott> and a faster but uglier technique that just wraps a mutable memo table in a pure interface
06:08:39 <zvrba> merijn: ok, but there's that that dynamic programming stuff which fib is the simplest example of.
06:08:46 <elliott> right, fibs is particularly good at this version
06:09:18 <merijn> zvrba: Anyway, the usual approach is to use laziness to generate something as you go
06:09:20 <zvrba> merijn: hm, almost purely algebraic translation of the recursive equation
06:09:27 <zvrba> tail fibs -> x_n-1
06:09:41 <zvrba> er, x_n+1 in this case
06:09:42 <merijn> zvrba: I'll show you some code that will really blow your mind in a sec (I need to write it first)
06:09:51 <zvrba> ok
06:09:55 <zvrba> ah
06:10:02 <quchen> merijn: You've got my attention now too :-D
06:10:36 <zvrba> laziness+forward-recursion instead of memoization+backward-recursion. judging by the fibs stuff.
06:10:41 <zvrba> hmm
06:10:48 * zvrba waits for the example :)
06:10:58 <elliott> merijn gave the example!
06:11:04 <elliott> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
06:11:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:11:14 <zvrba> elliott: nono, i have to wait for the next one!
06:11:14 <elliott> oh
06:11:22 <elliott> right, misread, never mind me :)
06:12:06 <quchen> My go-to Haskell WTF is MemoCombinators.
06:12:21 <quchen> http://hackage.haskell.org/package/data-memocombinators
06:14:54 <merijn> elliott: No, a better one
06:15:05 <zvrba> ah, so there's monomorphism restriction on values, but not on functions?
06:15:10 <merijn> I'm writing a sample to show how you do time travel in haskell
06:15:20 <quchen> merijn: Cont goto?
06:15:23 <elliott> zvrba: the monomorphism restriction is disabled when you have an explicit parameter on the left, basically
06:15:28 <elliott> maybe if you put a lambda on the right too... not sure
06:15:31 <elliott> it's silly
06:15:35 <zvrba> ok
06:16:02 <quchen> show' = \x -> show x   <--  I think this one fails due to the DMR
06:17:42 <quchen> elliott: Is there any reason the DMR is still there? It doesn't seem to be discussed a lot except the occasional complaints here, but it kind of bites everyone every once in a while
06:18:00 <elliott> well, it not being there can be unintuitive too
06:18:13 <hpaste> chrisdone annotated “fib and core (robde)” with “core compare for merijn” at http://hpaste.org/90275#a90297
06:18:15 <elliott> like people asking why "foo = big_numeric_computation" gets recomputed all the time.
06:18:17 <hpaste> chrisdone annotated “fib and core (robde)” with “second core compare for merijn” at http://hpaste.org/90275#a90298
06:19:52 <chrisdone> mauke: merijn: i encourage you to look at the core output yourself
06:19:53 <zvrba> another confusing thing: when to use let, and when to use where?
06:20:02 <chrisdone> zvrba: that's a point of taste
06:20:13 <ksf_> hmm. writing my first fold over this beast, I realise I should have done it a la carte.
06:20:19 <elliott> zvrba: I use where whenever possible. let is ugly.
06:20:29 <chrisdone> personally, i use where in a top-down style where description happens later, like this sentence.
06:20:39 <zvrba> elliott: is it possible to have nested wheres?
06:20:45 <elliott> sure
06:20:50 <quchen> zvrba: "let ... in ..." is an expression like "1+1". "where" is its own special block at the end of code.
06:20:52 <elliott> but you probably don't want them :P
06:21:33 <zvrba> are definitions in a single where-clause mutually recursive?
06:22:21 <chrisdone> yep
06:23:19 <quchen> @let foo = x where x = 1:y; y = 0:x
06:23:20 <lambdabot>  .L.hs:148:1:
06:23:20 <lambdabot>      Multiple declarations of `foo'
06:23:20 <lambdabot>      Declared at: .L.hs:145...
06:23:24 <quchen> @undef
06:23:24 <lambdabot> Undefined.
06:23:26 <quchen> @let foo = x where x = 1:y; y = 0:x
06:23:26 <lambdabot>  Defined.
06:23:32 <quchen> > take 10 foo
06:23:35 <lambdabot>   [1,0,1,0,1,0,1,0,1,0]
06:23:40 <quchen> ^ zvrba
06:23:48 <quchen> @undef
06:23:48 <lambdabot> Undefined.
06:24:37 <quchen> zvrba: "@let" is special Lambdabot syntax, it basically defines top-level names.
06:25:07 <quchen> So what I meant to illustrate here was "yes, 'where' things can be mutually recursive".
06:26:14 <zvrba> ok
06:26:49 <zvrba> is there much use for lambdas given that where-definitions are so convenient?
06:27:06 <zvrba> ok, it spares you of thinking up a name :P
06:27:15 <c_wraith> really, the big threat to lambdas is point-free expressions :)
06:27:21 <elliott> foo = map (\x -> f x / g x + 2) . computey . blah
06:27:29 <elliott> not always a good reason to use a where clause definition
06:28:08 <quchen> "where" is more for giving things names for readability I think
06:28:15 <quchen> (And for efficiency sometimes)
06:28:50 <quchen> Having 180 chars in one expression because you enter everything as anonymous functions is quite hard to decypher.
06:28:56 <chrisdone> elliott: hm, how come lambdabot doesn't have an implicit definition so we can use where?
06:29:12 <chrisdone> elliott: like `let it = … in it'
06:29:29 <chrisdone> i think someone asked for that like 3 years ago =p
06:29:47 <elliott> @yhjulwwiefzojcbxybbruweejw
06:29:47 <lambdabot> "\""
06:29:50 <chrisdone> is there a fundamental problem with it?
06:29:57 <elliott> well, I think it should match GHCi.
06:30:19 <applikativ> zvrba: i there are certain contexts where its standard to use a lambda, eg. withFile x mode $ \h -> do
06:30:34 * hackagebot Nomyx 0.2.3 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.2.3 (CorentinDupont)
06:30:35 <applikativ> but there is huge variation
06:31:11 * applikativ thinks lambdas should be banned; in his mental compiler they desugar to where
06:31:16 <chrisdone> elliott: btw did you notice repl does handle errors? i mentioned in here a couple times but i think you didn't see it
06:31:47 <elliott> chrisdone: it has error-handling code but my experience was that it didn't work a lot of the time
06:31:53 <elliott> like it only seemed to work if there was some output before the error
06:31:56 <elliott> so it'd work for String but not ()
06:32:23 <chrisdone> chris@retina:~/Projects/repl$ ./X
06:32:24 <chrisdone> error "foo" :: ()
06:32:24 <chrisdone> Exception [] "foo"
06:32:24 <chrisdone> seems ok?
06:33:06 <chrisdone> are you using the explicit api or the one that returns a string? i noticed the latter doesn't seem to output anything
06:33:36 <hpaste> chrisdone pasted “by "explicit" i mean…” at http://hpaste.org/90299
06:33:41 <elliott> well, I was also dealing with nested exceptions and stuff
06:33:55 <elliott> I forget what I was using but I just rewrote that part of the code anyway
06:34:01 <elliott> since I wanted fix error to work properly :)
06:34:19 <chrisdone> hm?
06:34:32 <elliott> > fix error
06:34:33 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
06:34:43 <elliott> repl's handling of it isn't nearly as cool :)
06:34:56 <chrisdone> @src fix
06:34:56 <lambdabot> fix f = let x = f x in x
06:35:09 <elliott> there's also weirdo things like
06:35:14 <elliott> > error [error "q"]
06:35:15 <lambdabot>   *Exception: *Exception: q
06:35:21 <chrisdone> hm, i can't seem to define that  in the repl, get a weird parse error
06:36:14 <chrisdone> ah, i need to send a specific decl. n/m
06:36:46 <luminous> hello! I've been finding myself a bit frustrated trying to learn haskell and am beginning to believe it is related to my crappy ability to process and follow mathematical terminology and concepts. funny enough, I'm not terrible at math, I made it through various high level courses in uni/etc... but navigating the world of math has not been my strong point. so my question - any tips haskellers can provide towards learning haskell as a layman or me
06:37:17 <chrisdone> @where lyah
06:37:17 <lambdabot> http://www.learnyouahaskell.com/
06:37:27 <applikativ> luminous: what are you reading?
06:37:49 <chrisdone> this book is fine. you don't have to know any maths beyond what barbie knows
06:37:53 <applikativ> high school algebra is adequate mathematical experience
06:38:07 <chrisdone> barbie could learn haskell
06:38:15 <applikativ> (x + y) ^ 2 = ...
06:39:34 <luminous> applikativ: I started with learn you some haskell, but got pulled into other things. this is a good reminder to go back there
06:39:42 <applikativ> luminous: some terms from fancy pants math are used at crucial points, but it is best to think of them as helpfully illustrated by Haskell's use
06:40:05 <luminous> I've been reading everything I find through reddit/hn/fpcomplete/etc
06:40:12 <luminous> and code... github
06:40:18 <applikativ> which is abstract but completely selfstanding and haskell-internal, eg. Functor
06:41:09 <luminous> should I spend more time trying to do stuff in ghc?
06:41:21 <applikativ> inside ghci you mean
06:41:28 <chrisdone> luminous: i'd estimate that most take a few months to get comfortable with haskell
06:41:58 <luminous> I can do so much in python, I almost don't know where to start... I keep wantinmg to use haskell for real-world stuff and then quickly find myself in over my head
06:42:08 <hpaste> merijn pasted “What sorcery is this?!?!” at http://hpaste.org/90300
06:42:09 <zvrba> LYAH says that right folds work with infinite lists, but not left folds. i can't wrap my head around that operationally.
06:42:26 <merijn> zvrba: Not the most useful example, but the easiest I could type up
06:42:26 <applikativ> luminous: maybe its just you need some more experience with IO and the basic libraries for dealing with stuff
06:42:26 <zvrba> could anybody explain why?
06:42:34 <zvrba> merijn: ok, reading it now..
06:42:43 <chrisdone> luminous: it's not a language you can just pick up, it's too different, you have to read the book, do the exercises, go through a bit of pain writing a program or two
06:42:49 <elliott> > foldl f z [a,b,c,d]
06:42:50 <lambdabot>   f (f (f (f z a) b) c) d
06:42:51 <elliott> > foldr f z [a,b,c,d]
06:42:52 <lambdabot>   f a (f b (f c (f d z)))
06:42:54 <elliott> zvrba: perhaps ^ helps
06:43:09 <luminous> applikativ: that's a good suggestion. thanks
06:43:11 <merijn> quchen: See that paste
06:43:22 <luminous> chrisdone: yea, I'm finding that to be true
06:43:42 <luminous> ok! thanks for helping to orient me again :D
06:44:13 <applikativ> luminous: it is a problem that most tutorials and text concentrate on what is distinctive and wonderful about haskell and not reading and writing files, grabbing webpages and serving them and so on
06:44:28 <luminous> yea
06:44:38 <luminous> I would agree
06:44:40 <chrisdone> there are tutorials like that on the school of haskell
06:44:57 <applikativ> yes, I think school of haskell will change this
06:45:01 <quchen> merijn: Oh, well that's a lot for a WTF.
06:45:09 <merijn> quchen: :)
06:45:16 <merijn> I told you it'd blow your mind :p
06:45:21 <chrisdone> luminous: fwiw if you've not already seen: https://www.fpcomplete.com/school you can run many of the examples inline in the tutorial page
06:45:31 <quchen> merijn: I'm going to hold you accountable for that. :-D
06:45:34 * hackagebot Nomyx-Language 0.2.3 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.2.3 (CorentinDupont)
06:45:45 <quchen> merijn: So I'm guessing it swaps the minimum and maximum elements of a tree?
06:45:54 <luminous> I'll have to dig deeper there, only scratched the surface on fpcomplete
06:45:55 <merijn> @faq Can Haskell do time travel?
06:45:55 <lambdabot> The answer is: Yes! Haskell can do that.
06:46:05 <merijn> quchen: Well, it swaps the left most and right most, but yeah
06:46:14 <zvrba> elliott: not at all. left fold ends at prefix, whereas right fold has to start at the non-existant last element.
06:46:19 <merijn> quchen: I didn't really waste too much time building the tree properly, etc
06:46:20 <quchen> merijn: And it does time traveling to do so
06:46:24 <acube> is it possible to get checking on idle time with syntastic for vim?
06:46:33 <merijn> zvrba: It only has to start there if the fold function looks at it!
06:46:34 <chrisdone> @src foldl
06:46:35 <lambdabot> foldl f z []     = z
06:46:35 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:46:45 <chrisdone> what
06:46:56 <chrisdone> oh, just a rendering error on screen. heh, it showed both lines the same
06:46:57 <merijn> > foldr f z [a,b,c,d]
06:46:58 <lambdabot>   f a (f b (f c (f d z)))
06:47:04 * chrisdone gotta install xmonad
06:47:13 <merijn> > foldr f z [True,False,True,False]
06:47:14 <lambdabot>   f True (f False (f True (f False z)))
06:47:18 <osa1> isn't foldl a tail-recursive process?
06:47:22 <merijn> > foldr (&&) z [True,False,True,False]
06:47:23 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
06:47:23 <lambdabot>              with actual type...
06:47:26 <merijn> hmm
06:47:57 <merijn> zvrba: Imagine if f was &&, if the first argument is False, then you don't need to look at the second argument
06:48:09 <quchen> merijn: I'm guessing the "tree" in line  11 should be "t"?
06:48:09 <zvrba> ok
06:48:10 <merijn> zvrba: So you don't need to traverse the rest of the list
06:48:25 <merijn> quchen: No
06:48:25 <quchen> merijn: Oh, nevermind.
06:48:35 <quchen> merijn: Shadowing etc.
06:49:03 <zvrba> ahh
06:49:04 <zvrba> got it
06:49:13 <merijn> Now if you look at foldl
06:49:20 <merijn> > foldl f z [True,False,True,False]
06:49:21 <lambdabot>   f (f (f (f z True) False) True) False
06:49:23 <osa1> "right folds work with infinite lists, but not left folds" I don't understand this argument, isn't left folds are tail-recursive?
06:49:43 <osa1> aren't left-folds tail-recursive*
06:49:50 <quchen> merijn: Well I don't get what it does so it doesn't blow my mind.
06:49:51 <merijn> zvrba: The first argument of the first f requires you to evaluate the result of the second f, etc.
06:50:02 <zvrba> yeah, got it
06:50:04 <merijn> osa1: It has nothing to do with the type of recursion
06:50:18 <merijn> quchen: It simultaneously finds *and* changes the left and right most
06:50:28 <osa1> merijn: why? it means it can work on infinite lists without problems ..
06:50:40 <merijn> quchen: magic updates the tree with the values returned by magic!
06:50:44 <osa1> merijn: on the other hand, a right fold would fail with stack overflow in that case
06:50:45 <zvrba> somebody has swapped left&right in haskell's folds :P
06:51:23 <zvrba> or they've been swapped in my head
06:51:29 <zvrba> what does left/right refer to?
06:51:47 <supki> associativity
06:51:48 <quchen> zvrba: left/right associative, *not* "from left" and "from right".
06:52:07 <merijn> osa1: I recommend taking a pen and paper and manually unfolding/substituting the definitions of "foldr (&&) True [False, True, False]" and "foldl (&&) True [False, True, False]"
06:52:20 <zvrba> ahh, right-associative operators have to be evaluated "backwards"
06:52:20 <AeroNotix> picking up haskell, how far from "idiomatic" Haskell is this? https://github.com/AeroNotix/haskell_learning/blob/master/fizzbuzz.hs
06:52:24 <merijn> osa1: When I did that, things finally became clear
06:52:41 <Lamen> > @src &&
06:52:42 <lambdabot>   <hint>:1:1: parse error on input `@'
06:52:48 <Lamen> @src &&
06:52:48 <lambdabot> True  && x = x
06:52:48 <lambdabot> False && _ = False
06:53:02 <hpaste> quchen pasted “folds for zvrba” at http://hpaste.org/90301
06:53:13 <merijn> quchen: Magic is returning the left and right most values inside the Tree t, but is simultaneously returning a Tree in which it has swapped the values that it returns.
06:53:25 <Lamen> > foldr (&&) False (repeat True)
06:53:28 <lambdabot>   mueval-core: Time limit exceeded
06:53:31 <Lamen> :-P
06:53:43 <zvrba> quchen: thanks!
06:54:08 <quchen> zvrba: The easiest way of understanding what foldr does is that it replaces ":" with "f" and "[]" with "z".
06:54:27 <quchen> The easiest way of understanding what foldl does is by getting used to it. :>
06:54:34 <merijn> AeroNotix: I'd personally replace the x on line 6 with _, but other than that it looks fine
06:54:38 <chrisdone> hm, this would've been a good use for stepeval
06:55:03 <FreeFull> > foldl (&&) False (repeat True)
06:55:04 <AeroNotix> merijn: ok thanks, the requirement of the comprehension due to line 6 is what weirded me out but I guess everything needs a value
06:55:07 <lambdabot>   mueval-core: Time limit exceeded
06:55:45 <FreeFull> > foldl (&&) True (False : repeat True)
06:55:49 <lambdabot>   mueval-core: Time limit exceeded
06:55:50 <merijn> AeroNotix: Isn't FizzBuzz supposed to return the number if it's not divisable by either 3 or 5?
06:55:50 <FreeFull> > foldr (&&) True (False : repeat True)
06:55:51 <lambdabot>   False
06:56:00 <FreeFull> merijn: yes
06:56:02 <AeroNotix> merijn: eh, possibly
06:56:03 <Lamen> > foldr (||) False (repeat True)
06:56:04 <lambdabot>   True
06:56:18 <merijn> AeroNotix: In which case you probably want to have "show x" instead of "" on line 6
06:56:36 <AeroNotix> Whichever
06:57:05 <quchen> merijn: I don't get what's "magic" about `magic`.
06:57:17 <quchen> Why is it so strange that you change and return something at the same time?
06:57:39 <merijn> quchen: Magic was a bad name, I guess that swapMinMax should've been called magic
06:57:51 <quchen> Is the crucial thing the odd recursion the "let" binding introduces?
06:57:54 <merijn> quchen: Because that's where the freaky bit happens
06:57:58 <merijn> quchen: Yeah
06:58:05 <quchen> Ah.
06:58:14 <quchen> Then I found the part that I don't understand.
06:58:17 <quchen> Progress!
06:58:43 <zvrba> merijn: how the hell does this work? let (left, right, tree) = magic right left t in tree
06:59:18 <merijn> zvrba: Magic! :)
06:59:26 <zvrba> hah!
06:59:33 <merijn> zvrba: And/or time travel!
06:59:42 <merijn> zvrba: It's abusing laziness
07:00:03 <zvrba> "abusing"?
07:00:05 <merijn> zvrba: Since we're not checking what right and left are, their value doesn't need to be forced
07:00:28 <merijn> zvrba: So it's basically inserting the thunks for right and left into the tree, before it can actually compute what values those thunks evaluate too
07:00:56 <chrisdone> let is essentially implementable in terms of case and fix
07:00:57 <zvrba> oh. mice :)
07:01:06 <zvrba> *nice
07:01:17 <hpaste> merijn annotated “What sorcery is this?!?!” with “What sorcery is this?!?! (less confusing function names)” at http://hpaste.org/90300#a90302
07:02:16 <quchen> "doWork" is clearly less confusing.
07:02:17 <zvrba> merijn: kind of delayed recursion
07:02:22 <zvrba> ?
07:02:29 <quchen> unmaintain.html called, it wants its naming back ;-)
07:02:40 <merijn> quchen: returnLeftMostRightMostAndSetThemToNewValues seemed a bit long
07:03:13 <chrisdone> :t fix
07:03:15 <lambdabot> (a -> a) -> a
07:04:09 <chrisdone> :t fix (\a -> a)
07:04:09 <lambdabot> a
07:04:13 <chrisdone> :t fix (\f -> f 'a')
07:04:14 <lambdabot>     Occurs check: cannot construct the infinite type: t0 = Char -> t0
07:04:14 <lambdabot>     In the return type of a call of `f'
07:04:14 <lambdabot>     Probable cause: `f' is applied to too many arguments
07:04:29 <chrisdone> damn it, ruined my demo =p
07:04:40 <merijn> zvrba: Well, if you imagine Tree as consisting of three points (to a value and the two children) then we're essentially inserting two value pointers, but the thing they're pointing at hasn't been filled in
07:04:57 <zvrba> mm
07:05:16 <zvrba> but what is the relation between right and left on both sides of the let?
07:05:21 <chrisdone> :t fix (\recur char -> recur 'a')
07:05:21 <lambdabot> Char -> t
07:05:24 <merijn> zvrba: Then, once magic has returned we have figured out what the values of leftMost and rightMost are, so we can fill those values in at the address of our inserted pointers
07:05:26 <zvrba> does let just generate a thunk that gets filled in later?
07:06:05 <merijn> zvrba: right and left on both sides are the same thing, an Int (in operational reality they're thunks the can be evaluated to an Int)
07:06:05 <chrisdone> :t fix (\recur char -> if char == 'b' then 'c' else recur 'b')
07:06:06 <lambdabot> Char -> Char
07:06:15 <chrisdone> > fix (\recur char -> if char == 'b' then 'c' else recur 'b') 'a'
07:06:16 <lambdabot>   'c'
07:06:21 <notdan> http://hackage.haskell.org/packages/archive/unix/latest/doc/html/System-Posix-Resource.html  does anybody know if setResourceLimits sets ulimits for the user or for the process?
07:06:59 <zvrba> merijn: ok, thanks!
07:07:09 <zvrba> gotta got out now. bbl.
07:07:12 <zvrba> *go
07:09:30 <merijn> I'm so sad that it's not possible to have type level composition without newtype wrapping :(
07:11:13 <osa1> why we don't have foldrM?
07:12:35 <merijn> There's no way to have like (excuse the invented syntax) "instance Applicative f => Applicative (\a -> Foo (f a)) where", right? :\
07:12:39 <elliott> merijn: no
07:12:51 <merijn> bah
07:13:10 <merijn> Now I need to implement my own versions of all Applicative operators and find non-colliding names for them...
07:17:44 <quchen> osa1: There is such a function in Foldable.
07:18:06 <quchen> osa1: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Foldable.html#v:foldrM
07:18:12 <osa1> quchen: yeah, I was wondering about the reason why there isn't in Control.Monad
07:19:17 <quchen> osa1: "Historically unrecognized function that now has a more polymorphic counterpart in the standard libraries" would be my guess.
07:20:03 <osa1> ah
07:21:27 <osa1> I was thinking maybe it's some kind of bad-practice or something that normally users should avoid ...
07:22:36 <Skola> Is it possible to repeat a Get n amount of times, collecting the results in a list?
07:22:54 <elliott> :t replicateM
07:22:55 <lambdabot> Monad m => Int -> m a -> m [a]
07:23:01 <Shou> Is there a way to keep the sockets/network handles when restarting a process somehow in Haskell?
07:23:10 <Skola> how stupid of me, thanks elliott
07:23:47 <Guest96156> Hello I  would like to learn haskell using  shim.vim  is there a manaul I can read about it shim? I did not found one :(
07:27:26 <merijn> Shou: Are you okay with unix/posix only solutions?
07:28:29 <merijn> Shou: If so, then yes it is possible, but it won't be pretty and require a fair bit of hacking
07:28:31 <Shou> merijn, sure!
07:29:17 <Shou> I don't mind :)
07:29:24 <Shou> Do you know any resources for it?
07:30:47 <applikativ> Guest96156: I'm not sure if shim is widely used? There is tons of tutorial material http://projects.haskell.org/haskellmode-vim/
07:31:00 <applikativ> Guest96156: I mean ^^
07:32:26 <merijn> Shou: Ok, the basic approach is that fork() (the C call) doesn't close file descriptors. If you turn all the Handles into System.Posix.Types.Fd then you can fork a new instance of your program (using new code), exec the new binary of your program, open up a unix socket in the old parent and in the newly exec'ed binary, write all the values of the Fd's to the socket, and then convert the Fd's back into Handles in your new
07:32:56 <merijn> Shou: I'm not sure whether it'd be easier to do this in Haskell or a mix of C and Haskell, but it should be possible like that
07:34:01 <merijn> Shou: Lots of old school MUDs (Multi User Dungeon, basically text-based multiplayer RPGS) had "hot copy-over" where they'd run an updated version of their server by using tricks like these to prevent the connection from dropping
07:34:36 <merijn> Shou: googling for mud and "copy-over" should find some relevant results
07:35:21 <merijn> Some familiarity with C and exec/fork would go a long way in helping you do this
07:36:10 <aristid> merijn: weechat also has that.
07:36:18 <sipa> irssi too
07:36:33 <aristid> people really hate stopping their irc :D
07:36:39 <applikativ> irssi is forever coming back from the dead.
07:36:42 <Guest96156> applikativ: I hoped  shim could be an good all inclusive solution ... but so I look for another plugin
07:36:46 <sipa> applikativ: it died?
07:37:01 <aristid> applikativ: are you applicative?
07:37:15 <applikativ> no, I just mean,  I think its gone, then suddenly text begins spilling out
07:37:19 <applikativ> aristid: yes,
07:37:21 <merijn> applikativ, Guest96156: Personally I thought haskellmode for vim came with a bunch of useless and hard to set up features
07:37:37 <applikativ> Guest96156: oh, merijn knows
07:37:51 <merijn> Guest96156: I just use syntastic + hdevtools and I'm writing my own auto-indent/folding plugin for vim
07:37:54 <applikativ> what are vim users using
07:37:56 <Shou> merijn, alright, thanks a lot! :)
07:37:56 <applikativ> oh
07:38:20 <merijn> syntastic highlights type errors and hdevtools lets you ask for the type of expressions in your code
07:39:20 <applikativ> I see merijn but that seems a little idiosyncratic I was hoping there was a standard vim approach
07:39:37 <merijn> It depends on what you want
07:40:30 <merijn> I personally never bothered with any of these "smart copying between vim and REPL" plugins
07:40:45 <merijn> They tend to be very brittle and just typing ":r" isn't that hard
07:41:12 <Philonous> Why do people opt to write IsString instances with partial fromString rather than using quasi quoters?
07:42:20 <applikativ> IsString is 'jolly convenient' as spj would say
07:44:06 <merijn> Word!
07:44:41 <Philonous> Jolly convenient to write or to use?
07:44:47 <merijn> Philonous: It's more convenient than typing "read myString" all the time when you frequently type literals in your code
07:44:56 <merijn> Philonous: To use
07:46:01 <applikativ> I think we are supposed to use it in the spirit of 'this isn't exactly the safest thing..."
07:46:02 <Philonous> merijn:  Yeah, well, except that you don't notice errors until the code explodes in your face and often it's not even clear what a particular string literal will end up being.
07:46:23 <Guest96156> I would like to get a little bit more comfrot wehn I use vim to learn haskell. I am not a vim pro ( so I did never write vim scripts, only editing the .vimrc a little bit)  but for me vim is more comfortable than a "regular" editor. So I am looking for an vim plugin, that supports me  alittle bit more to learn haskell than plain vim would do.
07:46:23 <Philonous> I think [xml|<blablabla>|] is easier to read (and you know it will parse when it compiles)
07:46:24 <merijn> Philonous: People don't care
07:47:00 <merijn> Philonous: A lot of work to implement though, if you already have a Read instance lying around that's much faster to write
07:47:57 <merijn> Guest96156: I'd go with syntastic, hdevtools and have ghci in a separate window, using ":r" to reload files
07:48:44 <elliott> more I think about it, more I wish we had good repl-free workflow tools...
07:49:01 <applikativ> Philonous: maybe you're right though that OverloadedStrings has been more successful than it was supposed to be...
07:50:28 <Philonous> applikativ:  The only reason I used it was because I was afraid to implement quasi quoters because the general opinion seems to be that TH stinks.
07:50:51 <hpaste> merijn pasted “Widget datatype” at http://hpaste.org/90303
07:51:08 <applikativ> Philonous: but they don't mind IsString. I see your point.
07:51:39 <merijn> mm_freak: Right, I scrapped a whole lot of stuff I had and simplified and right now I have something like http://hpaste.org/90303 which seems the least sucky implementation I've come up with so far
07:55:01 <jmcarthur> i very much dislike partial fromString implementations, myself
07:55:20 <jmcarthur> i haven't seen many
07:56:09 <burp_> !freshname
07:57:36 <applikativ> I suppose the one for Text is the most commonly used
07:58:29 <Philonous> applikativ:  But that one isn't partial
07:58:49 <applikativ> Philonous: right, i was agreeing with jmcarthur
07:58:54 <applikativ> or thinking about it
07:59:30 <Philonous> I see
08:00:45 * hackagebot vector-clock 0.2.2 - Vector clocks for versioning message flows  http://hackage.haskell.org/package/vector-clock-0.2.2 (AlexandruScvortov)
08:03:28 --- mode: ChanServ set +o elliott
08:03:33 --- mode: elliott set -b yezariaely!*@*$##fixyourconnection
08:03:34 --- mode: elliott set -o elliott
08:04:19 <ksf> half-baked idea of the second: did anyone ever try to combine diagram chasing and graphical programming?
08:05:04 <merijn> ksf: What do you mean by diagram chasing?
08:05:29 <ksf> I mean the diagrams abstract nonsensists use.
08:06:01 <AeroNotix> can I not have functions with different arity of the same name?
08:06:16 <ksf> AeroNotix, yes, yes you can!
08:06:21 <AeroNotix> hm ok
08:06:21 <ksf> but that needs a bit of twiddling.
08:06:47 <AeroNotix> I was trying like this: https://gist.github.com/AeroNotix/5845349
08:07:24 <ksf> AeroNotix, http://research.microsoft.com/~simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
08:07:32 <aristid> :t printf
08:07:32 <lambdabot> PrintfType r => String -> r
08:07:47 <ksf> there's another way to do it using classes. it's somewhere on olegs site.
08:08:01 <AeroNotix> so there's no built-in way to do it?
08:08:03 <ksf> AeroNotix, well, that'd be overkill
08:08:27 <ksf> AeroNotix, the common idiom is to rename the 2-argument collatz to "go" and put it in a where clause.
08:08:39 <AeroNotix> oh ok
08:09:04 <AeroNotix> in Erlang, it's common to do it in the two function way. I thought it'd be similar.
08:09:22 <merijn> ksf: I don't think linking a newcomer to typefuns is very helpful :p
08:09:32 <FreeFull> > printf "%d" 1.4 :: String
08:09:33 <lambdabot>   "*Exception: Printf.printf: bad argument
08:09:37 <FreeFull> > printf "%f" 1.4 :: String
08:09:38 <lambdabot>   "1.4"
08:09:43 <FreeFull> > printf "%10f" 1.4 :: String
08:09:44 <lambdabot>   "       1.4"
08:10:13 <aristid> FreeFull: type unsafety in haskell, isn't it amazing :P
08:10:35 <FreeFull> aristid: =P
08:10:52 <FreeFull> If you'd want type safety you wouldn't use printf
08:11:40 <jmcarthur> printf could be type safe
08:11:58 <jmcarthur> in a more expressive type system, or using some sort of quasiquoted format string or something
08:13:19 <chreekat> installing packages with cabal on Ubuntu, I always get a warning that documentation for rts-1.0 won't be linked because it doesn't exist. I installed haskell-platform-doc; what else might I need?
08:14:02 <aristid> chreekat: i wouldn't worry about that package's documentation too much, i don't think you'll need it a lot ;)
08:14:30 <elliott> this is an expected warning
08:14:42 <chreekat> aristid: Yeah, I was about to say. :)
08:15:06 <chreekat> Ok, won't worry about it
08:17:26 <acube> Is there better syntax highlighting than the default one for vim for haskell?
08:17:44 <merijn> acube: What do you feel is missing?
08:18:01 <hpc> the only thing i can think that the default needs is a slight bugfix for multiline strings
08:18:31 <hpc> it sometimes doesn't properly match beginning and end, and the red bleeds into other code
08:18:37 <acube> Custom function names are not highlighted
08:18:51 <acube> Typeclass names are not highlighted (in constraints)
08:19:14 <acube> Typenames are not highlighted
08:19:20 <merijn> Why would you want to highlight those? And also, how do you determine if something is a typeclass in a constraint?
08:19:36 <acube> I know that emacs does this, and I think it looks much more nice
08:20:01 <hpc> are you referring to mod-ghc?
08:20:04 <merijn> The one highlighting I swear by is
08:20:23 <merijn> https://github.com/kien/rainbow_parentheses.vim
08:20:25 <merijn> <3
08:20:41 <hpc> haha
08:21:40 <merijn> hpc: You laugh, but that thing is amazing
08:22:09 <hpc> i laugh because it's the only syntax highlighting you need to write lisp
08:22:33 <merijn> It works great for nested expressions in haskell and C too
08:22:59 <hpc> haskell and C get extremely uncomfortable when you nest parens
08:26:59 <merijn> Nesting pattern matches and nesting function calls respectively are things I end up doing quite frequently in either
08:29:43 <ksf> merijn, if you have nested parens in haskell you're doing it wrong.
08:29:58 <elliott> no, you're not
08:30:21 <ksf> ...well at least if they're nested deeply enough so that you need rainbow highlighting
08:31:11 <merijn> rainbow highlighting is great once you have more than 2 layers of parens
08:31:40 <merijn> Who says anything about "need"?
08:32:06 <merijn> I could write code in ed, but why do so if there's more convenient alternatives?
08:32:33 <ttuegel> merijn: does rainbow_parentheses also color {} ?
08:32:41 <ksf> I could write my code only with vi commands, but in the end I *do* use ex rather extensively.
08:33:29 <ksf> people really should learn to use a line editor. it's the connected up handwriting of code editing.
08:34:26 <merijn> ttuegel: It can
08:34:43 <merijn> ttuegel: There's options for each of ({[<
08:35:47 <ttuegel> excellent! that's the second new must-have vim plugin I've found today, just by lurking in #haskell!
08:36:35 <acube> Is it also aware of things like std::cout << "Hello" << std::endl; for highlighting <?
08:36:41 <dmwit> merijn: does rainbow_parentheses also color <div></div>?
08:36:52 <merijn> dmwit: No clue, tbh
08:36:59 <merijn> I only use it for () atm
08:37:07 <dmwit> (It was just a joke anyway.)
08:37:20 <dmwit> There is a plugin for making % work with those, if people care, though.
08:37:39 <acube> Highlighting <> in C++ would be really nice for templates ... Maybe I could read my C++ code again with that plugin
08:42:19 <dolio> acube: I think the highlighting in vim2hs is better than the default one.
08:42:38 <dolio> But it gets kind of slow in some circumstances.
08:43:47 <dolio> I played around with a haskell-like highlighting mode that didn't have that problem a while back, but haven't really finished it.
08:45:20 <banister`sleep> hello men
08:46:35 <osa1> where can I find GHC 7.7 API documentation? it's not here http://www.haskell.org/ghc/docs/
08:47:24 <Aetherspawn> is it possible for lambdabot to ignore people
08:47:28 <applikativ> ghc 7.7 ?
08:47:34 <Aetherspawn> how can I do that?
08:48:25 <osa1> applikativ: um, yeah. ghcjs uses it
08:48:41 <osa1> vagrant@precise32:~/ghc/share/doc/ghc/html/libraries/ghc-7.7.20130606$ ghc --version \n The Glorious Glasgow Haskell Compilation System, version 7.7.20130606
08:48:54 <merijn> applikativ: Releases always have an even version number, the odd version numbers are used to refer to the current development version
08:48:58 <applikativ> osa1: if you built it with whatever doc flags you should have it somewhere. I think it needs a few things
08:49:01 <elliott> Aetherspawn: @ignore command
08:49:03 <applikativ> merijn: yes i know
08:49:16 <Aetherspawn> elliott, I got invalid usage when I did @ignore person
08:49:43 <Andrea_> what does foldM ( with lists)
08:49:55 <elliott> Aetherspawn: @help ignore
08:50:05 <applikativ> @type foldM
08:50:06 <chreekat> I'd like to use my distro package for haskell-platform, but how tenable is that? I wanted to install reactive-banana-wx, and cabal wants to force-reinstall packages installed with the platform. I assume that is a common occurrence.
08:50:06 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
08:50:41 <merijn> chreekat: Are you installing with --global or sudo?
08:50:49 <Andrea_> the definition of foldM doesn't help me
08:51:23 <chreekat> merijn: No, I was installing locally
08:51:57 <merijn> chreekat: Oh, you installed other packages with your package manager?
08:52:44 <applikativ> Andrea_: it's the abstracted form of a certain  handwritten recursion, though
08:52:46 <Andrea_> can someone put a little line with foldM to lambdabot
08:52:46 <chreekat> merijn: Correct, I installed haskell-platform via apt
08:52:49 <merijn> chreekat: That's a road filled with pain and suffering, as most distro package managers install haskell packages globally, which means you're probably already scewed
08:53:15 <dav> ttuegel: "excellent! that's the second new must-have vim plugin I've found today" => what was the first?
08:53:25 <Andrea_> i didn't found understandable explanations with google
08:53:28 <chreekat> merijn: How about ghc itself?
08:53:28 <merijn> chreekat: hmm, I don't understand why reactive-banana-wx would upgrade something from platform
08:54:19 <hpaste> chreekat pasted “Installing reactive-banana-wx” at http://hpaste.org/90304
08:54:21 <Andrea_> i read an example with foldM and lists , but i don't understand foldM
08:54:23 <merijn> chreekat: Well, the usual approach is install platform via package manager and then only use cabal to install haskell stuff. Which should work, so if that's what you did, then I'm not sure why a package would want to reinstall something from platform
08:54:33 <merijn> chreekat: Unless you have a really old platform install?
08:54:38 <mm_freak> merijn: i'd have to see that in action
08:54:54 <mm_freak> merijn: the custom operator names make it look very weird
08:55:19 <AeroNotix> I have no idea what I am doing
08:55:33 <merijn> mm_freak: Well, I was used to something like <--> and <||> from vty for horizontal/vertical stuff, so I just stuffed the * in there to make it Applicativey
08:56:43 <chreekat> merijn: Well, I know old can be a relative term. I'm on Ubuntu 12.04 and the package version is 2012.1.0.0~debian1
08:57:22 <merijn> chreekat: Right, that platform is almost a year and a half old, so recent packages might not be compatible with it
08:57:43 <Guest96156> now I have installed the vim  plugins. But I have another question: when i define a function in a file and load it it works. But when i Would like to define it the same way with ghci it refuses to wrk with<interactive>:6:15: parse error on input `=' How can i define a function directly in the interactive mod?
08:57:49 <mm_freak> > foldM (\x y -> do guard (y /= 0); Just (lcm x y)) (Just 1) [2,3,5]
08:57:50 <lambdabot>   No instance for (GHC.Show.Show a0)
08:57:50 <lambdabot>    arising from a use of `M1582240467.sh...
08:57:54 <merijn> I dunno what other Ubuntu users are using
08:58:16 <mm_freak> > foldM (\x y -> do guard (y /= 0); fmap (lcm y) x) (Just 1) [2,3,5]
08:58:16 <chreekat> Perhaps there's a ppa with a more recent version? I admit I don't actually know much about ppas, but they seem to be a panacea for this sort of thing :)
08:58:17 <lambdabot>   Occurs check: cannot construct the infinite type:
08:58:17 <lambdabot>    a0 = Data.Maybe.Maybe ...
08:58:24 <monochrom> Andrea_: I seldom use foldM, it may be unnecessary to care in the first place. having said that, its doc already has a good visualization. foldM f a1 [x1, x2, x3] = do { a2 <- f a1 x1; a3 <- f a2 x2; f a3 x3 }. etc etc.
08:58:27 * chreekat goes googling
08:58:32 <Andrea_> thx mm_freak
08:58:43 <mm_freak> Andrea_: don't…  it didn't typecheck yet =)
08:59:04 <merijn> AeroNotix: You get used to that feeling ;)
08:59:12 <AeroNotix> It just seems needlessly complex
08:59:21 <mm_freak> Andrea_: stupid example:  you want to sum a list of numbers, but want it to error when there is a negative number
08:59:27 <mm_freak> then you can use foldM over Maybe
08:59:36 <merijn> chreekat: You could just grab a binary release of GHC 7.6.3 and install everything via cabal
08:59:47 <Andrea_> i read an example with foldM and lists ( without monads or monadic operators)
08:59:56 <merijn> chreekat: You'll waste a bunch of time building the platform libraries, but that's only a one time thing anyway
09:00:22 <chreekat> merijn: Yeah, that is becoming the most attractive option
09:00:24 <mm_freak> > foldM (\s x -> guard (x >= 0) >> fmap (+ x) s) (Just 0) [2,3,4,5]
09:00:25 <lambdabot>   Occurs check: cannot construct the infinite type:
09:00:26 <lambdabot>    a0 = Data.Maybe.Maybe ...
09:00:26 <Andrea_> i read this : "queens n = foldM f [] [1..n] where ..."
09:00:35 <mm_freak> i must be stupid today…
09:00:57 <mm_freak> > foldM (\s x -> guard (x >= 0) >> Just (s + x)) (Just 0) [2,3,4,5]
09:00:59 <lambdabot>   No instance for (GHC.Show.Show a0)
09:00:59 <lambdabot>    arising from a use of `M2123480316.sh...
09:01:14 <monochrom> f determines which monad is used
09:01:19 <mm_freak> > foldM (\s x -> guard (x >= 0) >> Just (s + x)) 0 [2,3,4,5]
09:01:20 <lambdabot>   Just 14
09:01:25 <mm_freak> d'oh, of course!
09:01:42 <monochrom> also, N-queens is most likely an advanced example, not an introductory example
09:02:09 <mm_freak> Andrea_: foldM over Maybe is an abortable fold, over lists it's a fold with multiple possible directions
09:02:25 <monochrom> google can only tell you which pages to read, but it will never tell you in which order
09:02:30 <mm_freak> > foldM (\s x -> [s + x, s - x]) 0 [1,2,3]
09:02:31 <lambdabot>   [6,0,2,-4,4,-2,0,-6]
09:02:46 <Andrea_> here the example : http://en.literateprograms.org/Eight_Queens_puzzle_%28Haskell%29
09:02:55 <banister`sleep> are lambdas closures in haskell, and if so does that mean they're not pure functions?
09:03:10 <monochrom> ok, I see that you're write-only.
09:03:32 <mm_freak> Andrea_: that's actually a very good example…  see the example i just wrote
09:03:43 <mm_freak> you can sum in two directions at the same time
09:03:56 <mm_freak> you start with 0 and get [0 + 1, 0 - 1]
09:04:05 <FreeFull> :t foldM
09:04:06 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
09:04:15 <FreeFull> > foldM ((Just .) . const) 0 [1,2,3]
09:04:16 <lambdabot>   Just 0
09:04:34 <Andrea_> mm_freak, your example is to much difficult for me, becaus i don't know "guard"
09:04:37 <applikativ> Andrea_: try foldM ing goo n m = print n >> return (n+m); it prints the numbers, accumulating the sum
09:04:47 <mm_freak> Andrea_: no, the list example
09:04:49 <AeroNotix> I'm not seeing why getCollatz is a compilation error? https://gist.github.com/AeroNotix/5845516
09:04:51 <mm_freak> > foldM (\s x -> [s + x, s - x]) 0 [1,2,3]
09:04:51 <lambdabot>   [6,0,2,-4,4,-2,0,-6]
09:05:07 <dEPy> Can anyone explain this a bit more (I'm not sure I get it):    applyLog (x,log) f = let (y,newLog) = f x in (y,log ++ newLog)
09:05:10 <applikativ> that is an excellent example
09:05:33 <merijn> AeroNotix: You are passing a tuple to collatz, but collatz takes to Ints
09:05:36 <mm_freak> you start with a single s = [0] and get an x = 1:  [s + x, s - x] = [0 + 1, 0 - 1] = [1, -1]
09:06:04 <AeroNotix> merijn: so what's the right function call sytax there?
09:06:15 <Andrea_> >  foldM (\s x -> [s + x, s - x]) 0 [1,2,3]
09:06:16 <lambdabot>   [6,0,2,-4,4,-2,0,-6]
09:06:17 <merijn> AeroNotix: You want "[[n, collatz n 0] | n <- [1..x]]"
09:06:21 <AeroNotix> oh ok
09:06:31 <applikativ> AeroNotix: collatz(n, 0)
09:06:33 <mm_freak> then you get s = [1, -1] and get another x = 2:  [s + 2, s - 2] = [1 + 2, 1 - 2, -1 + 2, -1 - 2] = [3, -1, 1, -3]
09:06:37 <applikativ> oh merijn saw it
09:06:44 <AeroNotix> merijn: applikativ thanks
09:06:45 <acube> @src foldM
09:06:45 <lambdabot> foldM _ a []     = return a
09:06:45 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
09:06:47 <bakibour> Hey
09:06:56 <mm_freak> that's your new s, then finally you get x = 3 and do the same again
09:07:00 <applikativ> AeroNotix: you could uncurry the definition of collatz, but dont
09:07:05 <quchen> dEPy: f is a function that takes a value and produces a pair (new_value, log_entry) from it. `applyLog` now takes a tuple (value, log), and creates a new value using f, while also appending a new log message.
09:07:13 <AeroNotix> applikativ: I'll do it like this for now
09:07:15 <quchen> dEPy: It's basically what Writer does.
09:07:17 <merijn> AeroNotix: It takes some getting used to write function application without parens, but it doesn't take very long
09:07:18 <Andrea_> ok mm_freak, the example is good, now i try to understand it
09:07:30 <bakibour> Is there any ready to use Haskell linux/bsd distro? That included xmonad + emacs 24 and haskell platfrom?
09:07:51 <Guest96156> Is it possible to define a function interactive in ghci?
09:08:04 <applikativ> Guest96156: yes, let f x = x + 1
09:08:06 <AeroNotix> merijn: yeah, I was thinking that [n, collatz n, 0] would partially apply the collatz call, so I put the parens thinking it would be the function call. Turns out like you said, just don't use the comma.
09:08:12 <mm_freak> Andrea_: one interesting use case for foldM is over IO:  foldM (\s x -> do let s' = s + x; putStrLn ("sum so far: " ++ show s'); return s') 0 [1..100]
09:08:15 <dEPy> quchen: Don't undestand this part right:  let (y,newLog) = f x in (y,log ++ newLog)
09:08:33 <Guest96156> applikativ: thx
09:08:41 <quchen> dEPy: Do you understand  (y,newLog) = f x
09:08:43 <quchen> ?
09:09:04 <applikativ> Guest96156: the definition will disappear if you reload a module, or if you over write it, so to say
09:09:06 <dEPy> quchen: it return (y, newLog) right? and that is the result of aplying f to x? not sure how we get the newLog in
09:09:08 <dEPy> quchen: yes
09:09:23 <dEPy> quchen: wait, not sur
09:09:27 <merijn> AeroNotix: Commas are only used for tuples and list syntax like [1,2,3]
09:09:34 <AeroNotix> merijn: ok
09:09:51 <merijn> (I'm hoping I'm not forgetting some obscure edge case...)
09:09:52 <dEPy> quchen: I just means we take apart (pattern match) what ever  f x  returns right?
09:09:56 <AeroNotix> ahh shit, now I'm totally lost. I know what I want to say but not how to say it
09:09:58 <quchen> f applied to something (here called "x") creates a tuple of a new value, here called "y", and a log entry, here called "newLog".
09:10:01 <quchen> dEPy: Right.
09:10:27 <Guest96156> applikativ: ok is it bossilbe to  write (all) defined functions  in a textfile, so that I can test them interavitve and then save them in a file with an comand?
09:10:28 <dEPy> quchen: then,  (y, log ++ newLog) where does newLog come from?
09:10:31 <AeroNotix> I have a list of lists, each with [n, collatz(n)] and I want to basically fold that down to the maximum collatz n where n < 1M
09:10:36 <dEPy> oh,
09:10:45 <quchen> dEPy: That's the same newLog as before
09:10:48 <dEPy> from the pattern matching against  f x ?
09:10:49 * hackagebot hmidi 0.2.0.0 - Binding to the OS level MIDI services  http://hackage.haskell.org/package/hmidi-0.2.0.0 (BalazsKomuves)
09:10:53 <applikativ> Guest96156: you mean, you want to write the out in ghci?
09:11:01 <exFalso> Hi, i have a question about DefaultSignatures: if i have a class say:
09:11:01 <exFalso> class (Monad m) => GMonadReader r m where
09:11:01 <exFalso>     gask :: m r
09:11:01 <exFalso>     default gask :: (MonadTrans t) => t m r
09:11:01 <exFalso>     -- default gask :: (MonadTrans t, GMonadReader r m1, m ~ t m1) => t m1 r
09:11:01 <exFalso>     gask = lift gask
09:11:01 <exFalso> The commented out signature compiles as well (needs -XTypeFamilies) and seems to do exactly the same thing. Can anyone explain what's going on?
09:11:07 <geekosaur> right, (f x returns a tuple which we pattern-match and break apart into y and newLopgf
09:11:10 <applikativ> Guest96156: there is a history file somewhere but I think by default it isn't much
09:11:11 <geekosaur> newLog*
09:11:19 <merijn> AeroNotix: What do you mean by "fold"?
09:11:20 <geekosaur> then we can use those names after `in`
09:11:25 <dEPy> oh ye, I undestand now, I thought (y, newLog) was return value not  (y, log ++ newLog)  :D  tnx
09:11:27 <quchen> dEPy: First, "f x" is calculated, and the result is assigned to 'y' and 'newLog'. This happens in the "let" part. The "in" part then uses the new names "y" and "newLog".
09:11:35 <AeroNotix> merijn: the usual meaning of fold
09:11:51 <quchen> exFalso: Paste longer code to HPaste and not in the channel please.
09:11:54 <quchen> @where hpaste
09:11:54 <lambdabot> http://hpaste.org/
09:12:33 <merijn> AeroNotix: Could you give a pseudocode version of what you want? I'm not sure I understand
09:12:40 <dEPy> quchen: I get it now. Tnx.  Haven't done much haskell lately. :S
09:12:44 <mm_freak> AeroNotix: give a precise non-syntax-error type of the list you currently have
09:12:47 <AeroNotix> merijn: in haskell or will some other language be ok?
09:13:15 <mm_freak> something like [(Double, Double)]?
09:13:15 <Guest96156> ok thanks that had ben nice if there would be a more comfortable way than just using c & p
09:13:16 <merijn> AeroNotix: Whatever mix is easiest, although if you pick something obscure like forth I probably won't be able to understand it :p
09:13:20 <AeroNotix> ok
09:13:35 <exFalso> http://hpaste.org/90305
09:13:37 <quchen> dEPy: The Writer monad abstracts this pattern, maybe have a look at LYAH for that section
09:13:53 <applikativ> Guest96156: but of course the usual thing is to have a .hs text open in your editor at the same time
09:13:55 <exFalso> can anyone explain why the above code works with both default signatures?
09:14:03 <applikativ> Guest96156: then :r will reload the module
09:14:17 <dEPy> quchen: yes I'm reading trough LYAH, and I got stuck there. :D
09:14:19 <ksf> @quote elegant
09:14:20 <lambdabot> quicksilver says: I have an extraordinarily short and elegant explanation of monads but it won't fit in the margin of this IRC channel.
09:14:24 <banister`sleep> are haskell closures pure functions?
09:14:27 <quchen> dEPy: Ah, ok :-)
09:14:32 <AeroNotix> merijn: https://gist.github.com/AeroNotix/5845542
09:14:39 <ksf> banister`sleep, everything in haskell is pure. that's the point.
09:14:39 <d01r> Hi everyone :) I got a question about type renaming in Haskell. I got something like this:
09:14:41 <d01r> data BasicType = TBool | TInt
09:14:42 <d01r> data TypeSpec = BasicType BasicType
09:14:44 <d01r> And I wanted to achieve something like this (basically defining a shortcut which works in pattern matching):
09:14:45 <d01r> type B = BasicType TBool
09:14:46 <exFalso> banister`sleep: what do you mean by closures?
09:14:47 <d01r> How can i do this in Haskell? Thanks in advance :)
09:15:01 <exFalso> by default everything is a "closure" in haskell
09:15:10 <ksf> unless it's a value
09:15:13 <ksf> or a type
09:15:20 <banister`sleep> exFalso: a = 20 \x -> a
09:15:30 <Andrea_> > foldM (\s x -> [s-x, s+x]) 0 [1]
09:15:32 <lambdabot>   [-1,1]
09:15:33 <AeroNotix> merijn: I would do this in say, Erlang, with a fold
09:15:37 <Andrea_> > foldM (\s x -> [s-x, s+x]) 0 [1,2]
09:15:38 <lambdabot>   [-3,1,-1,3]
09:15:41 <quchen> exFalso: Why shouldn't both instances work?
09:15:52 <AeroNotix> and the accumulator would be changed when the pair satisfies my conditions
09:15:57 <quchen> exFalso: You can't use ask with State though
09:16:22 <exFalso> quchen: you can, if the underlying monad is a monadreader
09:16:23 <banister`sleep> exFalso: pardon me for being ignorant, but i read this on wikipedia: "closures can thus be used to implement paradigms for state representation and information hiding, since the closure's upvalues (its closed-over variables) are of indefinite extent, so a value established in one invocation remains available in the next. Closures used in this way no longer have referential transparency, and are thus no longer
09:16:23 <banister`sleep> pure functions"
09:16:24 <mgsloan> ksf: values are closures too.  Also, functions are just values
09:16:37 <AeroNotix> or, do a list comprehension for all numbers <1M then do a max somehow on the 2nd element
09:16:51 <exFalso> quchen: what i dont understand is how the type parameters m and r are related to the default signature's type
09:17:08 <merijn> AeroNotix: Oh, you'd do something like "maximumBy (compare `on` snd) . takeWhile (<1000000)"
09:17:12 <ksf> "closures" is an operational term, anyway.
09:17:14 <exFalso> quchen: in the first signature m denotes the underlying monad, in the second it's the lifted monad
09:17:21 <AeroNotix> merijn: I'll look that stuff up, thanks
09:17:40 <merijn> AeroNotix: Eh... wait, not entirely that
09:17:53 <quchen> exFalso: Ah, I see, the defaulting.
09:17:56 <geekosaur> d01r: does that not work for you? what happens when you try it?
09:18:03 <quchen> exFalso: I skipped that because it looked like noise ;-)
09:18:24 <merijn> AeroNotix: Anyway "takeWhile" returns values until the function you give it returns False, so just compare the n value with 1000000 with it and you get a list of all values up where n <1000000
09:18:24 <Guest96156> applikativ: thx
09:18:36 <AeroNotix> merijn: familiar with takewhile
09:18:38 <exFalso> banister`sleep: not sure why it's saying it's not referentially transparent anymore
09:18:44 <merijn> AeroNotix: maximumBy takes a comparison function and returns the maximum element of a list using that function
09:18:49 <AeroNotix> ok
09:19:00 <merijn> :t on
09:19:01 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
09:19:05 <dav> d01r: you sure this is even balid? TBool and TInt are type constructors. BasicType TBool is a value, not a type, right?
09:19:15 <Andrea_> lambdabot, I don't understand your results, my ballpenwriter on the paper gave different results
09:19:21 <merijn> :t compare `on` snd
09:19:22 <lambdabot> Ord b => (a, b) -> (a, b) -> Ordering
09:19:26 <FreeFull> :t flip on
09:19:27 <lambdabot> (a -> b) -> (b -> b -> c) -> a -> a -> c
09:19:28 <banister`sleep> exFalso: i think it's because the closure's return value is not completely determined by the parameters that are passed in, it could depend on state that was closed over (and was not explicitly passed in to the lambda)
09:19:31 <FreeFull> :t (:.)
09:19:32 <lambdabot>     Not in scope: data constructor `:.'
09:19:32 <lambdabot>     Perhaps you meant one of these:
09:19:32 <lambdabot>       `:+' (imported from Data.Complex),
09:19:33 <dav> @src on
09:19:33 <lambdabot> (*) `on` f = \x y -> f x * f y
09:19:39 <FreeFull> :t (.:)
09:19:40 <lambdabot>     Not in scope: `.:'
09:19:40 <lambdabot>     Perhaps you meant one of these:
09:19:40 <lambdabot>       `.' (imported from Data.Function),
09:19:49 <merijn> AeroNotix: Basically, "compare `on` snd" compares elements by comparing the second part of a tuple
09:19:54 <FreeFull> @let (.:) = (.).(.)
09:19:55 <lambdabot>  Defined.
09:19:58 <FreeFull> :t (.:)
09:19:59 <exFalso> banister`sleep: ah ok, so in non-pure languages yes, closures are not referentially transparent
09:19:59 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
09:20:06 <geekosaur> d01r: yes, TBool is not a type, you can't use it to define a type or type alias
09:20:18 <applikativ> d01r: the problem is  data TypeSpec = BasicType BasicType
09:20:18 <exFalso> banister`sleep: this is because in impure languages you can capture a *variable* the state of which you can change
09:20:19 <AeroNotix> merijn: I can see that, but not how it does it.. I'll read some more, you've given me a lot of pointers. Thanks.
09:20:20 <geekosaur> if you want to use a type there, you need to do things differently
09:20:21 <merijn> AeroNotix: So "maximumBy (compare `on` snd)" returns the tuple whose snd element is biggest (which is the f n element)
09:20:24 <exFalso> banister`sleep: you cannot do this in haskell
09:20:39 <applikativ> oh ignore my nonsense
09:20:50 <merijn> AeroNotix: You can use hoogle to look up those functions and look at their source and types
09:20:57 <AeroNotix> ok
09:20:58 <Andrea_> > foldm (\x s -> [x-s, x+s] ) 0 [1]
09:20:59 <lambdabot>   Not in scope: `foldm'
09:20:59 <lambdabot>  Perhaps you meant one of these:
09:20:59 <lambdabot>    `foldr' (imported...
09:21:05 <Andrea_> > foldM (\x s -> [x-s, x+s] ) 0 [1]
09:21:06 <lambdabot>   [-1,1]
09:21:09 <Andrea_> ok
09:21:16 <Andrea_> > foldM (\x s -> [x-s, x+s] ) 0 [1,2]
09:21:17 <lambdabot>   [-3,1,-1,3]
09:21:21 <Andrea_> hmmmm ???
09:21:57 <Andrea_> what makes lambdabot in his magic box
09:22:10 <merijn> AeroNotix: internally maximumBy just uses fold, but haskellers are lazy and can't be arsed to write out the fold using foldl or foldr
09:22:12 <d01r> geekosaur, dav, applikativ: yes it doesn't work, it isn't valid like that, I know, but I don't know how to make it valid, like defining a new type constructor as a shortcut
09:22:20 <AeroNotix> merijn: sounds good :)
09:22:28 <exFalso> banister`sleep: for example in impure languages you might have a closure to have a global unique id generator, you capture the state of the id counter and then each call will return a new one
09:22:50 <exFalso> banister`sleep: you cannot do this in haskell, the state must be explicitly taken care of
09:23:11 <dav> d01r: how about tb = BasicType Tbool without "type" in front? then use tb...
09:23:13 <AeroNotix> merijn: I'm going to need to import some of these functions, right?
09:23:24 <exFalso> quchen: so any ideas? i couldnt find any deeper documentation on defaultsignatures to explain this
09:23:33 <dav> d01r: but tb is just a value, just like BasicType Tbool. Keep that in mind..
09:23:45 <applikativ> data TypeSpec where B :: TypeSpec Bool; I :: TypeSpec Int
09:24:04 <merijn> AeroNotix: Yeah, on is from Data.Function, the rest I'm not sure, but that's what Hoogle's for
09:24:04 <banister`sleep> exFalso: ok thx
09:24:11 <geekosaur> dav: they said they wanted to use it as a shorthand in a pattern match. that won't work
09:24:15 <applikativ> data TypeSpec a where B :: TypeSpec Bool; I :: TypeSpec Int
09:24:16 <AeroNotix> merijn: awesome, found them. Data.List||Data.Function
09:24:17 <applikativ> rather
09:24:19 <quchen> exFalso: Not really, sorry :-\
09:24:24 <geekosaur> the pattern match would create a new `tb` binding
09:24:36 <dav> d01r: I don't know what you're trying to do, but don't you mean: data BasicType = TBool Bool | TInt Int ?
09:25:11 <dav> geekosaur: it would have to be a guard at this point, not a pattern match? (I'm a noob..)
09:25:37 <oio_> copyfolders ?
09:25:44 <d01r> dav: without "type" it works, however I can't use that in pattern matching :(
09:25:47 <geekosaur> guyard wouldn't work there either, and in any case would not be a "shorthand"
09:26:22 <dav> d01r: do you mean to be carrying around integer or boolean values, or just "atoms" such as TBool and TInt ?
09:26:24 <d01r> dav: i'm sure that the type is right though, i meant BasicType = TBool | TInt
09:26:24 <geekosaur> oio_: one context-free word does not a question make
09:26:43 <d01r> dav: no no, just atoms
09:27:55 <dav> geekosaur: f x | x == tb = blah ; | otherwise = blah ?
09:28:06 <applikativ> d01r: but then when you write data TypeSpec = BasicType BasicType  what do you mean
09:28:09 <merijn> d01r: What exactly are you trying to accomplish?
09:28:09 <oio_> geekosaur: like copyFiles.. from system.directory
09:28:47 <d01r> dav, applikativ, merijn: (we are trying to writing a toy compiler for a university project)
09:28:58 <oio_> geekosaur: it could be implemented but come it is nowhere on hackage
09:29:28 <merijn> d01r: Yes, but more concretely, what exactly is the type of code you're trying to write?
09:29:37 <merijn> d01r: Do you have a pseudo code example?
09:29:48 <d01r> applikativ: the first BasicType is a data constructor, the other one is a type constructor
09:30:21 <dav> d01r: but BasicType just seems like a container that does nothing..
09:30:30 <dav> d01r: like a Maybe without a Nothing..
09:30:33 <merijn> oh!
09:30:42 <applikativ> it is just another wrapper
09:31:00 <geekosaur> oio_: yes, that's something of a shortcoming, the closest thing to it is a function used by Cabal (but it does what Cabal wants, not necessarily what you want)
09:31:10 <merijn> d01r: Are you trying to get a type where you know that the value inside the BasicType is TBool??
09:32:09 <dav> d01r: What's wrong with f t | t == tb = ... ; | otherwise = ... ?
09:32:10 <applikativ> data BT :: BasicType -> * where B :: Bool -> BT TBool; I :: Int -> BT TInt
09:32:34 <merijn> applikativ: All problems need moar DataKinds and GADTs :)
09:32:35 <d01r> merijn, dav, applikativ: we want to build a data structure (an abstract syntax tree) in which we want to know when an integer or boolean or other types are used in the concrete syntax
09:32:51 <merijn> d01r: I think you want GADTs
09:33:11 <merijn> d01r: Read this: https://en.wikibooks.org/wiki/Haskell/GADT
09:33:26 <applikativ> it is a typical GADT type problem area, but i'm still not seeing the desideratum
09:33:32 <merijn> The example they use is an AST, so that should help
09:33:33 <dav> d01r: I think you want to carry the value around along with the type, no?
09:33:48 <merijn> applikativ: Me neither, but maybe he'll realise what he wants when reading the GADT bit
09:33:51 <dav> d01r: in that case, use GADT as they say..
09:34:14 <merijn> At the very least, learning GADTs can't hurt :p
09:35:53 <exFalso> does anyone know a good resource on how haskell compilers figure out when to copy a data structure and when not to? e.g. if i have a large (arr :: Array) and an (f :: Array -> Array) how does it figure out when to keep around the original arr and when it can just do f in place?
09:36:24 <merijn> exFalso: The answer is, they mostly don't
09:36:42 <d01r> merijn, dav, applikativ: thanks :) i'm going to read the GADT page then :)
09:36:47 <exFalso> merijn: oh, ouch
09:36:56 <jmcarthur> exFalso: it isn't as bad as it sounds
09:37:04 <merijn> exFalso: If you're interested in doing pure mutable update, you might wanna read the ST paper
09:37:37 <exFalso> merijn: well i know how ST works, but this seemed like a more fundamental question about purity to me
09:37:40 <merijn> exFalso: "Lazy Functional State Threads" by SPJ & Launchbury
09:37:43 <merijn> ah
09:37:45 <d01r> (dav: we carry the value in an another annotated tree node, this is only to define the type of an expression)
09:37:56 <jmcarthur> exFalso: there are some libraries that provide pure interfaces for arrays that under the hood will reduce copying and use mutation. the compiler itself doesn't do anything special for this, though
09:37:58 <merijn> exFalso: The answer is, compilers could do that, but it's *hard*
09:38:31 <merijn> exFalso: Are you interested in how to do this in general in functional languages? Or in haskell specifically
09:38:38 <exFalso> merijn, jmcarthur: i see, thank you
09:38:40 <hpc> if haskell had linear types, that'd be a good way to denote in-place modification
09:38:42 <exFalso> well in general or haskell
09:38:54 <exFalso> it seems like an interesting question in general
09:38:58 <hpc> but i am fairly sure that's beyond the reach of libraries
09:39:01 <jmcarthur> exFalso: if you want to learn about these libraries, a good place to start might be to google "stream fusion" and then "array recycling"
09:39:02 <dav> hpc: what's a linear type?
09:39:16 <merijn> exFalso: My colleagues work on functional language based on matrices, they do do this sort of analysis to do in place updates
09:39:23 <jmcarthur> exFalso: an example of a library that uses these techniques is vector
09:39:26 <exFalso> oh no linear types are a mind****
09:39:45 <exFalso> jmcarthur: thanks, i'll have a look
09:39:47 <dav> quadratic types are simpler? :)
09:39:53 <jmcarthur> exFalso: they aren't perfect (improving this stuff is an active area of research), but it works pretty well
09:39:55 <merijn> exFalso: So if you're interested you could look into their publications (although the compiler is not open source)
09:39:57 <hpc> dav: suppose in haskell, instead of using the IO type we threw around RealWorld# directly
09:39:58 <dmwit> dav: There is the idea that some resources should be used exactly once. Linear types track this.
09:40:13 <hpc> dav: and if RealWorld# was a linear type, then you could only use a value of that type exactly once
09:40:18 <exFalso> linear logic is basically intuitionistic logic without weakening and contraction, meaning each resource can only be used once and must be used once
09:40:28 <dmwit> dav: e.g. file handles should be closed exactly once; allocations should be freed exactly once; etc.
09:40:31 <hpc> IO actions would all have to produce a new RealWorld# value that we could use for the next operation
09:40:39 <hpc> it has other applications
09:40:48 <hpc> @quote majestic.stereo
09:40:48 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
09:40:49 <exFalso> merijn: do you have links please?
09:41:02 <merijn> What's the relation between linear types and uniqueness types?
09:41:04 <dav> hpc/dmwit: I see, interesting
09:41:06 <merijn> Are they the same thing?
09:41:07 <monochrom> hpc, you want "fugue"
09:41:22 <merijn> exFalso: Project homepage is at: http://www.sac-home.org/
09:41:25 <xplat> @remember fugue
09:41:25 <lambdabot> Incorrect arguments to quote
09:41:25 <dmwit> merijn: I think uniqueness types are essentially affine?
09:41:28 <applikativ> @quote fugue -- why not
09:41:28 <lambdabot> No quotes for this person. Are you on drugs?
09:41:35 <xplat> @quote fugue
09:41:35 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
09:41:37 <dmwit> merijn: (meaning things should be used at most once)
09:41:38 <exFalso> merijn: i think uniqueness types can have weakening
09:41:45 <applikativ> bah
09:41:56 <monochrom> fugue > stereo
09:42:25 <xplat> @quote quadraphonic
09:42:26 <lambdabot> No quotes match. I've seen penguins that can type better than that.
09:42:27 <merijn> exFalso: They're basically doing a purely functional (using uniqueness types for IO) language disguised to look very C like
09:42:50 <dmwit> Disguising yourself to look like C is a pretty good strategy.
09:43:21 <exFalso> merijn: looks interesting:)
09:43:21 <dav> hpc / dmwit / exFalso - so have linear types been considered for inclusion in Haskell?
09:43:38 <dmwit> dav: You can have linear types in Haskell.
09:43:49 <dmwit> dav: Just write your linear type checker as a GADT.
09:43:51 <exFalso> dav: there is an oleg paper on how to imitate them
09:44:02 <exFalso> without GADTs ofc
09:44:08 <exFalso> haskell98
09:44:09 <dmwit> dav: There's a good paper from UPenn folks on how to do it in half a dozen ways with various tradeoffs.
09:44:31 <dav> so they have a way to forbit sharing?
09:44:34 <dav> forbid
09:45:04 <applikativ> ah the old oleg 'haskell98' routine
09:45:17 <applikativ> with one hand tied behind my back ...
09:45:48 <dav> f realWorld = (g realWorld, h realWorld) is an invalid expression?
09:45:48 <exFalso> http://okmij.org/ftp/Haskell/regions.html#light-weight
09:46:09 <dmwit> dav: right
09:46:26 <dav> dmwit: how can that be invalid in Haskell?
09:46:27 <dmwit> dav: Well, to be clear:
09:46:42 <dmwit> dav: (g realWorld, h realWorld) is fine, so long as you only consume one side of the tuple. =)
09:46:51 <dav> hehe try
09:46:53 <dav> true
09:47:23 <dmwit> dav: The way things work is you embed a linear language in Haskell and ask GHC's type-checker to type-check it for you.
09:47:54 <dav> dmwit: so kind of like monads?
09:48:09 <dmwit> dav: So f realWorld = (g realWorld, h realWorld) wouldn't even be a term in the embedded language; it would instead be like f = Lambda (\realWorld -> Apply tuple (Apply g realWorld) (Apply h realWorld)).
09:48:18 <dmwit> or similar
09:48:23 <dmwit> I don't recall the details.
09:48:27 <dmwit> I'm trying to find the paper.
09:49:06 <dav> seems like linear data types should just be a typeclass and Arrays and what not could just instantiate it? :)
09:49:12 <dmwit> http://www.monoidal.net/papers/qhaskell.pdf
09:49:48 <Ebony> Do you guys have a bot that evaluates Haskell code? If so, is the source code available to the public? If so, how do I obtain it?
09:50:01 <dmwit> dav: I am suspicious of "just" in that sentence.
09:50:06 <hiptobecubic> > "yes"
09:50:07 <lambdabot>   "yes"
09:50:11 <dav> dmwit: hehe :)
09:50:12 <exFalso> dav: well linearity is detached from the actual types you use it on
09:50:15 <dav> dmwit: will read the paper
09:50:20 <hiptobecubic> Ebony, it's called lambdabot.
09:50:22 <Ebony> Well, that's one question of three answered.
09:50:26 <dav> dmwit: hopefully I can understand the gist..
09:50:28 <dmwit> ?hackage lambdabot -- the source is here
09:50:28 <lambdabot> http://hackage.haskell.org/package/lambdabot -- the source is here
09:50:35 <Ebony> Thanks :)
09:51:08 <elliott> you should use the git version though.
09:51:29 <dmwit> What's new in git compared to the release?
09:51:55 <Ebony> I now wonder if there's a package to translate applications to VirtualBox boot images, without the need for an OS.
09:52:20 <elliott> dmwit: bugfixes. and the packages are split up
09:52:22 * Ebony is off to learn!
09:53:10 <dav> Ebony: why would you want to do this? I've heard of kernels written in Haskell but why not ship put linux kernel in with your haskell program in your vbox image?
09:53:39 <elliott> dmwit: also because I'm more likely to be able to help since it's what I'm running :P
09:54:18 <Ebony> dav: If I'm going to be running only one program inside a virtualbox vm, then why do I need multitasking?
09:54:49 <dav> Ebony: the OS provides a lot more than multitasking: network layers, file system, etc.
09:54:50 <Ebony> I would think a microkernel would be sufficient.
09:55:09 <dmwit> elliott: =)
09:55:20 <Ebony> dav: Yes, and much of that's excessive.
09:55:34 <elliott> Ebony: look into HaLVM.
09:55:34 <merijn> Ebony: Might wanna lookup HaLVM
09:55:40 <elliott> merijn: hmph
09:55:43 <merijn> elliott: Jinx!
09:55:52 <merijn> Ebony: It's a lightweight haskell runtime for Xen
09:56:06 <dav> merijn / elliott: nice.
09:56:11 <dmwit> Huh. Ask and ye shall receive.
09:56:40 <Ebony> Haskell has it all?
09:57:18 <exFalso> Haskell has it all.
09:59:24 <hiptobecubic> @quote stereo
09:59:24 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
09:59:35 <hiptobecubic> oh well
09:59:45 <merijn> Shouldn't that be Tarski?
10:00:22 <hiptobecubic> should it? I don't know anything about it, but I'm not sure it even belongs in latin characters.
10:00:55 * hackagebot wai-test 1.3.1.1 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-1.3.1.1 (GregWeber)
10:01:08 <elliott> the stereo quote is not there
10:04:52 <koning_robot> when I do "import Parsec" in ghci, i don't get an error, whereas if I put it in a file and :load it, I do (Could not find module `Parsec'). can anyone give me a hint?
10:06:24 <exFalso> koning_robot:how about ":l Text.Parsec?"
10:06:36 <exFalso> "?
10:07:32 <exFalso> ah sry misunderstood question
10:08:17 <exFalso> so this file you want to load does import Parsec?
10:08:45 <enigmuriatic> what's the generally accepted package to use with mysql? all the one's i'm trying seem to depend on older versions of standard library packages
10:08:58 <koning_robot> uhm yeah but it's just a file containing "import Parsec" right now
10:09:08 <enigmuriatic> (I'm using HDBC)
10:09:18 <exFalso> try doing import Text.Parsec instead
10:09:24 <exFalso> in the file
10:10:03 <exFalso> if "import Parsec" works in ghci it either means you have a weird installation of Parsec, or you are in a directory that has Parsec.hs in it
10:10:17 <koning_robot> ah yes, that works
10:10:30 <koning_robot> hm. i guess i have a weird installation (it's ubuntu's)
10:14:56 <exFalso> maybe someone knows the answer now: http://hpaste.org/90305 the commented out default signature seems to work exactly the same as the uncommented one, even though 'm' denotes the lifted monad in the former and the underlying monad in the latter case. Can anyone explain what's going on? In perticular *can* i assume that they behave the same way?
10:18:30 <lilred> hey guys, I'm new to Parsec and I haven't yet got the gist of it
10:19:32 <lilred> as an example, could someone help me figure out how to write a parser to match the following pattern: any string that begins and finishes with a ", but the final " cannot be preceded by a backslash
10:21:28 <Ebony> How much does Java suck?
10:21:51 <monochrom> no bashing of other languages here
10:21:56 <merijn> Ebony: Seems a bit off-topic
10:21:58 <exFalso> lilred: well think about what you'd do as a machine
10:22:13 <applikativ> we love Java
10:22:23 <jmcarthur> ha
10:22:35 <applikativ> it's off topic to say how much we love Java though.
10:22:36 <quchen> lilred: between (char '"') (char '"') contentChar -- now figure out what a content char is.
10:23:06 <quchen> (It's either a special char, that is something preceeded by a backslash, or an ordinary char.)
10:23:24 <lilred> quchen: thanks for the primer, I should be good now :D
10:23:33 <Ebony> applikativ: Right. Where should I go for a fair answer to my question?
10:23:39 <quchen> Ebony: Try #java.
10:23:44 <Ebony> Okay.
10:23:54 <exFalso>  :join #java
10:23:56 <exFalso> heeh
10:25:18 <exFalso> Ebony: you may want to rephrase your question to: how does java compare to haskell?;)
10:25:58 <elliott> that question would be inappropriate here too
10:26:04 <elliott> it's just a language war in disguise.
10:26:06 <quchen> exFalso: That's also sort of OT here because it's a troll question with a fake mustache on.
10:26:15 <monochrom> answer: "try comparing apple and orange instead"
10:26:48 * monochrom doesn't like comparing
10:26:54 <exFalso> ah cmon everyone enjoys a bit of language war once in a while
10:27:15 <monochrom> I don't. tired of them
10:27:16 <Demos> yes but I wonder who would win here "D (hint: haskell)
10:27:30 <exFalso> especially when you are on the winning side hehe
10:27:44 <Demos> if you can get something done it does not really matter in the end
10:27:45 <monochrom> I still don't, even on the winning side
10:28:10 <AeroNotix> Hmm, merijn couldn't really get a comprehensive grasp on using maximumBy, so I tried implementing it all myself: https://gist.github.com/AeroNotix/5845796
10:28:20 <quchen> Not having a language war here is not an invitation to discuss who would win the discussion if we had it.
10:28:40 <jmcarthur> that is a quite different question though
10:28:43 <elliott> the answer is me. I would win the discussion.
10:28:49 <elliott> next question!
10:28:59 <jmcarthur> winner /= best
10:30:01 <Ebony> I suppose one valid usecase for Java might be showing someone how useful regular expressions can be.
10:30:09 <monochrom> AeroNotix: you may be polluted by bad prolog syntax? it's (x:xs), not [x,xs]
10:30:32 <monochrom> but what is "xs<ys" supposed to mean?
10:30:50 <AeroNotix> monochrom: I want to compare the 2nd element of a list passed to the function
10:31:15 <AeroNotix> I know xs is supposed to be the tail of a list, but this should work, right?
10:31:19 <AeroNotix> works in the repl
10:31:52 <AeroNotix> your syntax isn't working, which I believe is the syntax for (head:rest), right?
10:31:55 <exFalso> AeroNotix replacing those lists with pairs would funcitonally  be the same, only your functions wont be partial
10:31:57 <merijn> monochrom: xs and ys aren't lists, which is confusing
10:32:05 <monochrom> ok, I have go back to the beginning. why [n, collatz n 0]? it's better off (n, collatz n 0)
10:32:11 <merijn> At least, I think?
10:32:23 <AeroNotix> monochrom: what's the difference?
10:32:23 <merijn> oh...they are :\
10:32:38 <merijn> That explains why my maximumBy (compare `on` snd) didn't work
10:32:52 <exFalso> a list can have any number of elements, a pair can only have two
10:33:04 <monochrom> list may be 3, 4, 5... elements. tuple (x,y) must have 2 elements, no more no less
10:33:25 <fridim_> Hi. Any suggestion for a rest client library ?
10:33:47 <monochrom> snd is for (x,y) tuple, not for list
10:34:52 <AeroNotix> meh
10:34:53 <monochrom> "every datum is a list" is hardly better than "every datum is a string"
10:35:12 <monochrom> Haskell has rich data types. please use them. please.
10:36:31 <AeroNotix> I must say that's the quite unhelpful
10:36:40 <AeroNotix> s/the//
10:36:56 <monochrom> fine.
10:37:10 <AeroNotix> For someone learning it means pretty much nothing
10:37:19 <jmcarthur> AeroNotix: you say that, but you are the one with the error
10:37:23 <hpc> monochrom: the most insidious of those is "every datum is a function"
10:37:23 <AeroNotix> I am
10:37:26 <exFalso> AeroNotix: you might want to try http://hpaste.org/90306
10:37:41 <jmcarthur> AeroNotix: the error would be less likely or at least clearer if you were using appropriate types
10:38:06 <AeroNotix> jmcarthur: and I don't know what the appropriate types are. Telling me "use haskells super wow awesome rich data types" leads me nowhere
10:38:15 <exFalso> there were two issues: one you used lists when you meant to use pairs, two your fold didn't have a starting element
10:38:20 <jmcarthur> AeroNotix: monochrom is being helpful in that he is trying to show you how to avoid such confusion later
10:38:25 <AeroNotix> ok
10:38:30 <aristid> AeroNotix: the general guideline is to use the most restrictive data type that will work.
10:38:39 <monochrom> did I not say "it's better off (n, collatz n 0)"? did I not say "tuple"?
10:38:57 <aristid> AeroNotix: so (Int, Int) is better than [Int] because the latter also allows lists with sizes other than 2.
10:39:07 <monochrom> were I not extremely specific right at the beginning?
10:39:09 <AeroNotix> ok
10:39:12 <AeroNotix> monochrom: not really.
10:39:29 <jmcarthur> AeroNotix: <monochrom> ok, I have go back to the beginning. why [n, collatz n 0]? it's better off (n, collatz n 0)
10:39:37 <AeroNotix> whichever
10:39:40 <monochrom> what is not specific about "it's better off (n, collatz n 0)" and "tuple"? answer me.
10:40:57 * hackagebot http-reverse-proxy 0.2.0 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.2.0 (MichaelSnoyman)
10:40:59 * hackagebot mime-mail 0.4.2 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.2 (MichaelSnoyman)
10:41:02 * hackagebot conduit 1.0.7 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.7 (MichaelSnoyman)
10:41:04 * hackagebot imagesize-conduit 1.0.0.1 - Determine the size of some common image formats.  http://hackage.haskell.org/package/imagesize-conduit-1.0.0.1 (MichaelSnoyman)
10:41:06 * hackagebot keter 0.4.0 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.4.0 (MichaelSnoyman)
10:44:21 <aristid> nice to see what snoyman is up to :D
10:45:57 * hackagebot persistent 1.2.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.2.1 (MichaelSnoyman)
10:45:59 * hackagebot persistent-mongoDB 1.2.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.2.1 (MichaelSnoyman)
10:46:01 * hackagebot persistent-postgresql 1.2.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.2.1 (MichaelSnoyman)
10:46:03 * hackagebot persistent-sqlite 1.2.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-1.2.1 (MichaelSnoyman)
10:47:22 <h4199> I wonder if he just hits a big red button labelled HACKAGE when he does that.
10:47:56 <lilred> quchen: I did it! Thanks, you were really helpful
10:47:58 <Gracenotes> it uses an RSS feed
10:47:59 <aristid> i think he has scripts for deploying many packages at once.
10:48:10 <Gracenotes> it will shut down when Google Reader shuts down. RIP
10:48:11 <AeroNotix> monochrom: there's no reasoning behind what you said, it sounds like a bikeshed comment to be honest.
10:48:45 <elliott> what monochrom says is completely right
10:48:56 <elliott> tuples are better in every way here: safer, more efficient, more semantically correct
10:49:11 <AeroNotix> Probably it is, but there's no reasoning to allow me to see why he said that
10:49:13 <elliott> it's not bikeshedding; tuples and lists are not almost-interchangable (as in e.g. Python), they're very different
10:49:16 <AeroNotix> "red is better than blue"
10:49:34 <monochrom> then pursue what exFalso said. he named another issue
10:49:36 <quchen> lilred: :-) Here's some implementation I wrote some time ago, it should be similar to yours: http://hpaste.org/90307
10:50:43 <h4199> AeroNotix: are you trying to imply that the difference between a tuple and a list is a bikeshed issue?
10:50:48 <elliott> well, like I said: it's better because it minimises the possibility of errors when using the data, is more semantically correct, will likely make error messages clearer, and is potentially more efficient
10:50:54 <elliott> I don't really see what more reasoning you could ask for
10:50:58 <AeroNotix> h4199: for someone coming from other languages, yes.
10:51:20 <monochrom> I came from other languages, too.
10:51:21 <h4199> They are different data structures, and they behave differently
10:51:31 <flebron> Hi. I'm using Data.ByteString, and I'd like to read n Ints, newline separated, from a ByteString. I have readInt :: ByteString -> Maybe (Int, ByteString). Two problems: readInt can't unfoldr in something like "1\n2\n3", it won't be able to read "\n2\n3" and will return Nothing. Also, I'd like to read n ints, not however many until the stream is exhausted. Can this be done with standard functions, or should I roll my own?
10:51:52 <quchen> A list has arbitrary length, and all elements have the same type. A tuple has a fixed length, and each element can have a different type. They are very different and not bikesheddy.
10:52:08 <elliott> ok, well, perhaps the issue is assuming that reasoning about other languages transfers cleanly to Haskell
10:52:16 <elliott> it is not always the case, perhaps even usually not the case
10:52:19 <AeroNotix> indeed
10:52:37 <elliott> the issue might seem trivial, but issues about fundamentals often do; that's why they're important to get a solid grasp on first off
10:53:10 <AeroNotix> Indeed, I will be purchasing a couple of books to really get to grips with Haskell.
10:53:50 <quchen> AeroNotix: The two biggest ones are available for free online, LYAH and RWH.
10:53:52 <flebron> Though, "using the most restrictive type you can manage" is good advice not just in Haskell, but in any statically typed language.
10:54:02 <AeroNotix> quchen: yeah I'll be getting LYAH
10:54:05 <h4199> @where LYAH
10:54:05 <lambdabot> http://www.learnyouahaskell.com/
10:54:11 <AeroNotix> I know it,
10:54:25 <AeroNotix> I just find reading on the computer mildly irritating to my eyes
10:54:33 <h4199> understood
10:55:26 <lilred> quchen: to be fair I'm doing this in F# and FParsec, so it basically looks nothing like it :)
10:55:56 <supki> flebron: any particular reason you are not using e.g. attoparsec for that?
10:56:13 <monochrom> flebron: you don't have to use unfoldr, but if you do, (ByteString,Int) -> (Int, (ByteString,Int)), the extra Int is for counting your n
10:56:14 <flebron> supki: Programming contest site, old ghc version :(
10:56:24 <supki> I see
10:56:52 <monochrom> also, modify your readInt to consume \n
10:57:08 <flebron> readInt comes standard with Data.ByteString :p
10:57:37 <monochrom> alright, then you have to write something that uses readInt but also does the extra counting and \n
10:57:43 <Ebony> @where RWH
10:57:43 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:58:29 <FreeFull> flebron: I'd do something among the lines of    map read . lines . toString
10:58:31 <flebron> Eh, seems at that point I'd be eschewing most standard functions :p But OK, I'll do it.
10:58:44 <FreeFull> Although it's not very flexible
10:58:57 <flebron> Yeah, was trying to avoid lines on the whole input, but that also works.
10:59:08 <monochrom> as long as you still use Prelude and Data.ByteString, you are not eschewing most standard functions
10:59:10 <flebron> (I suppose lines will stream its results, not consume everything)
10:59:33 <monochrom> those people who say "I'm writing an alternative Prelude" are the ones eschewing standard functions :)
10:59:46 <monochrom> yeah, lines is streaming
11:01:41 <monochrom> oh! you don't have to code up your own counting
11:02:12 <monochrom> take n (unfoldr whatever) should be just as good
11:03:35 <flebron> That works :)
11:05:32 <u_> http://hackage.haskell.org/packages/archive/websockets/0.7.3.0/doc/html/Network-WebSockets.html
11:05:44 <u_> why is there a separate WebSockets monad?
11:05:56 <u_> "for safety reasons"
11:06:06 <u_> it means i have to use monad transformers
11:06:10 <u_> and i hate those so much :(
11:07:04 <merijn> u_: What's wrong with them?
11:07:07 <monochrom> if that library makes your life harder, use another library
11:07:34 * monochrom does not believe in: every library makes everyone's life easier
11:08:21 <u_> monochrom it's the only one
11:09:19 <u_> merijn they're bloaty and confusing
11:09:36 <merijn> What do you mean by bloaty?
11:09:38 * u_ is holding out for some kind of effect system
11:09:50 <u_> all those lifting functions
11:09:57 <u_> performance penalties
11:10:21 <monochrom> I am sorry to hear that. you have to wait for your desired library to appear, or pay me enough to make one soon.
11:10:34 <flebron> Who is this function? (b -> c) -> (a -> f b) -> a -> f c
11:10:36 <u_> im thinking about just gutting this one
11:10:43 * monochrom believes, instead, in laws of demand and supply
11:10:58 * hackagebot cabal-meta 0.4.0.1 - build multiple packages at once  http://hackage.haskell.org/package/cabal-meta-0.4.0.1 (GregWeber)
11:11:03 <elliott> u_: you have benchmarks, right?
11:11:04 <flebron> (Specifically, my f is Maybe.)
11:11:10 <jmcarthur> flebron: fmap.fmap
11:11:17 <flebron> Cool :)
11:11:18 <u_> elliott for what?
11:11:18 * monochrom is over 40 and is better off not be a communist! :)
11:11:28 <u_> oh you mean proof transformers are bloaty?
11:11:35 <jmcarthur> flebron: one fmap to get under the function. the other to get under the Maybe
11:11:36 <elliott> u_: for your use-case, yes
11:11:37 <u_> i think theres a case where they can actually change the complexity
11:11:52 <u_> eh its just the principle of the thing mostly. liftIO is just ugly
11:12:01 <elliott> that's why io = liftIO exists :)
11:12:09 <u_> its not the name thats ugly
11:12:15 <u_> its the *ideeeaaaaa*****
11:13:38 <u_> *wavy hand motion*
11:13:46 * geekosaur hates the idea of having to lift . lift . lift . lift . lift . putStrLn
11:13:47 <u_> it looks like stripping the monad bs out is gonna be hard
11:13:56 <u_> there was an older library without a monad
11:14:01 <u_> but it doesn't work anymore
11:15:51 <jonkri> How can I see which package tries to pull a certain dependency when doing a "cabal install"?
11:15:58 * hackagebot cabal-meta 0.4.1 - build multiple packages at once  http://hackage.haskell.org/package/cabal-meta-0.4.1 (GregWeber)
11:18:24 <supki> jonkri: -v3 should tell that, I think
11:18:42 <hpaste> Luke pasted “Postgresql Simple ZonedTime” at http://hpaste.org/90308
11:19:28 <Luke1> hey guys. I need some help here: http://hpaste.org/90308
11:20:01 <Luke1> I'm trying to make a Maybe ZonedTime instance FromRow but I'm not sure how to handle the Maybe monad on top of the RowParser monad
11:20:13 <monochrom> jonkri: "cabal install --dry-run" gives you a preview and does no harm
11:20:19 <Luke1> the error is at the bottom
11:20:55 <monochrom> oh, but it doesn't tell you who causes whom
11:20:58 * hackagebot wai-static-pages 0.2.1 - generate static html pages from a WAI application  http://hackage.haskell.org/package/wai-static-pages-0.2.1 (GregWeber)
11:21:11 <monochrom> combine the two then. "cabal install --dry-run -v3"
11:21:52 <jonkri> supki, monochrom: thanks!
11:22:08 <flebron> Suppose I have a [ByteString] foo, and I _know_ each bytestring is just an int. What's clearer, "map fst . catMaybes $ map C.readInt foo", or "map (fst . fromJust . C.readInt) foo"?
11:22:19 <byorgey> Luke1: why do you want to make an instance for  (Maybe ZonedTime)  instead of for  ZonedTime?
11:22:30 <byorgey> Luke1: because what you've written appears to be an instance for  ZonedTime.
11:22:40 <Luke1> because it's optional. should write DB nulls in that case
11:22:55 <Luke1> byorgey: good eye... I just copied and pasted from my ZonedTime instance =)
11:23:02 <Luke1> now I need to make the Maybe version
11:23:08 <byorgey> Luke1: I just read the error message.
11:23:29 <byorgey> "Expected type: RowParser (Maybe ZonedTime); Actual type: RowParser ZonedTime"
11:23:39 <Luke1> yeah I know it's wrong... i just don't know how to do what it's telling me to do
11:23:57 <byorgey> Luke1: change  'return . utc ...'  to  'return . Just . utc ...'
11:24:03 <monochrom> flebron: I may go with "map (fst . fromJust . C.readInt) foo", but I will write in comments "this is because I know foo won't disappoint me" several times
11:24:25 <Luke1> byorgey: that'd be semantically wrong. if any of the fields return Nothing, it needs to return Nothing
11:24:51 <Luke1> uh actually maybe it's that simple =)
11:25:26 <Luke1> byorgey: I could wrap everything in maybe calls but I suspect there's a functor way to handle the maybes
11:25:51 <byorgey> OK, sorry, I don't understand what you are trying to do.
11:26:21 <Luke1> np np it's me explaining poorly
11:26:27 <byorgey> Luke1: what type should 'zonedTime' have?
11:26:28 <Luke1> http://hackage.haskell.org/packages/archive/postgresql-simple/0.3.3.2/doc/html/src/Database-PostgreSQL-Simple-FromField.html#FromField
11:26:39 <Luke1> Maybe ZonedTime
11:26:51 <Luke1> check out how psql-simple does it
11:27:21 <Luke1> i need to leverage the "instance (FromField a) => FromField (Maybe a) where"
11:27:38 <byorgey> ok, and what type should timeZone have?
11:28:56 <Luke1> Maybe TimeZone
11:30:05 <byorgey> ok.  So you probably want something like   return $ utcToZonedTime <$> timeZone <*> (zonedTimeToUTC <$> zonedTime)
11:30:47 <Luke1> shoot i cleared my irc buffer by accident
11:30:48 <byorgey> which will apply the utcToZonedTime and zonedTimeToUTC functions, but all in the context of the Applicative Maybe instance, which means the whole thing will be Nothing if either timeZone or zonedTime is Nothing
11:30:54 <byorgey> (14:29) <   byorgey> ok.  So you probably want something like   return $ utcToZonedTime <$> timeZone <*> (zonedTimeToUTC <$> zonedTime)
11:30:54 <Luke1> can you paste that again?
11:30:57 <Luke1> ty
11:31:00 <Luke1> haha
11:31:02 <Luke1> sorry
11:31:06 <byorgey> np =)
11:31:29 <Luke1> yeah perfect
11:31:32 <Luke1> that's exactly what I wanted
11:31:35 <Luke1> thanks
11:31:46 <byorgey> great, you're welcome =)
11:31:47 <Luke1> I was trying to do that myself but I was missing the final <$>
11:32:31 <chrisdone> Luke1: what are you trying to achieve here? i'm a user of postgresql-simple and i wrote pgsql-simple, this code makes me wonder what the bigger aim is
11:32:41 <thoughtpolice> shachaf: Program f a = Free (CoYoneda f) a is pretty interesting. last night i kept playing with it and tried to write an operational equivalent, although 'view' alluded me but i was really, really tired
11:33:10 <Luke1> chrisdone: it's complicated =) basically PG doesn't store timezones
11:33:12 <elliott> thoughtpolice: the Free constructor unfolds immediately to be equivalent to (:>>=)
11:33:18 <elliott> if you just lift the existential up
11:33:27 <chrisdone> Luke1: timestamp with time zone stores time zones
11:33:37 <Luke1> chrisdone: that doesn't store the timezone
11:33:39 <Luke1> that converts to UTC internally
11:33:44 <Luke1> so the TZ is lost
11:33:57 <chrisdone> hm, i don't think so. that's what timestamp by itself does
11:34:02 <Luke1> nope
11:34:10 <thoughtpolice> elliott: ta! give me a second. i have to actually wake up and look at my code
11:34:11 <Luke1> look at the sizes
11:34:14 <Luke1> of the types
11:34:16 <elliott> thoughtpolice: hehe :)
11:35:21 <Luke1> chrisdone: here's lpsmith's example: https://github.com/lpsmith/postgresql-simple/issues/69#issuecomment-19173678
11:35:55 <Luke1> chrisdone: pg's "timestamptz" type is really just a "utc timestamp" type.
11:35:59 * hackagebot wai-static-pages 0.2.1.1 - generate static html pages from a WAI application  http://hackage.haskell.org/package/wai-static-pages-0.2.1.1 (GregWeber)
11:37:56 <Luke1> chrisdone: the pg people insist these semantics are correct but there's no PG type that maps cleanly to a haskell ZonedTime then
11:39:41 <chrisdone> Luke1: hmm. i'm using ZonedTime with hpaste, and hpaste's database has been moved across servers all over the world. it was in the UK, now it's in germany. i have these timestamps:
11:39:47 <chrisdone>  2011-01-12 02:46:28.006206+01
11:39:48 <chrisdone> 2013-06-23 20:37:39.249514+02
11:40:01 <chrisdone> so how is it that time zones are not stored?
11:40:08 <Luke1> chrisdone: that's leveraging the local time of the server
11:40:20 <chrisdone> then why are they different?
11:40:27 <Luke1> DST
11:41:06 <Luke1> remember offsets are not enough to dictate timezone or dst uniquely
11:41:58 <Gracenotes> you still get the exact time, at least
11:42:21 <Luke1> Gracenotes: right
11:42:24 <Luke1> the absolute time isn't lost
11:42:34 <Luke1> just the original TZ it was specified in is lost
11:43:08 <Gracenotes> if the timezone was only specified as say 'ET', you would not have the exact time
11:43:19 <Gracenotes> perhaps not without a big lookup table
11:43:34 <Luke1> no, ET is not unique
11:43:54 <Luke1> posix/Jamaica               | EST    | -05:00:00  | f
11:43:55 <Luke1>  posix/Australia/Victoria    | EST    | 10:00:00   | f
11:44:00 <Luke1> that's from PG's lookup table
11:44:07 <Gracenotes> well, okay, even if you add S/D :)
11:44:17 <Luke1> no
11:44:24 <Luke1> still not unique
11:44:29 <Gracenotes> if wouldn't be, as per the example you just game
11:44:31 <Gracenotes> gave
11:44:32 <Luke1> there are overlap in the abbrevs between tzs
11:45:04 <Luke1> you need to use the full name to be precise about the timezone... and also keep the DST status
11:47:03 <Luke1> Gracenotes: run this query to see what I mean: select * from pg_timezone_names where abbrev = 'EST';
11:47:22 <Gracenotes> yes. I don't actually have postgres installed here.
11:47:24 <Luke1> also, the pg_timezone_names table/function is dependent on current time/zone
11:47:32 <Luke1> so it changes depending on your location
11:48:34 <byorgey> representing time: more complicated than you think, even after taking this statement into account.
11:48:54 <Luke1> http://www.postgresql.org/docs/9.1/static/view-pg-timezone-names.html "many of these names imply a set of daylight-savings transition date rules. Therefore, the associated information changes across local DST boundaries. The displayed information is computed based on the current value of CURRENT_TIMESTAMP."
11:49:18 <Luke1> i think this could be simpler if PG's main goal wasn't to save space
11:49:34 <Luke1> that's where the design mismatch happens between PG and Haskell
11:49:43 <NihilistDandy> Anyone else reading the homotopy type theory book?
11:49:58 <FreeFull> NihilistDandy: I started on it but didn't get far yet
11:50:15 <FreeFull> Seems pretty non-difficult so far though
11:50:21 <NihilistDandy> Yeah, I've just started reading recently. It's a neat book, so far.
11:50:36 <Gracenotes> byorgey: how can I determine that it's actually after taking the statement into account?
11:51:00 <ksf_> are standard typeclasses that define e.g. Functor to f where fmap :: (a `to` b) -> f a `to` f b ?
11:51:20 <byorgey> Gracenotes: to determine the semantics of my statement you have to take a least fixed point.
11:51:30 <ksf_> that is, functors over arbitrary subcategories, not only in the constraintkind sense but actually different categories than hask?
11:52:10 <FreeFull> ksf_: Would to be an Arrow then?
11:52:34 <ksf_> erm, no.
11:52:45 <ksf_> wait, Control.Categorical.Functor has what I want.
11:52:45 <byorgey> ksf_: http://hackage.haskell.org/packages/archive/categories/1.0.6/doc/html/Control-Categorical-Functor.html
11:52:51 <ksf_> the thing is, I want both at the same time :)
11:52:56 <chrisdone> Luke1: hmm, yeah, the storage is the same
11:53:18 <ksf_> I always wanted to do this.
11:53:36 <b52> could someone tell my why the point-free style version result in the shown type error? http://hpaste.org/90310
11:53:36 <ksf_> @tell edwardk Control.Categorical.Functor is insufficiently general
11:53:37 <lambdabot> Consider it noted.
11:53:57 <Luke1> chrisdone: check out lpsmith's explanation i sent you.
11:54:06 <Luke1> er... posted earlier
11:54:17 <elliott> ksf_: howso?
11:54:19 <byorgey> b52: f $ g $ h x y  is not the same as  f . g . h
11:54:31 <ksf_> elliott, you can't put things with e.g. ord constraints into them.
11:54:39 <byorgey> b52: f . g . h  is equivalent to   \x -> f $ g $ h x, i.e. it only takes a single argument
11:54:48 <elliott> ksf_: sure, you can
11:54:51 <FreeFull> f $ g $ h x y  is the same as   f . g . h x
11:54:57 <elliott> ksf_: r becomes a GADT bundling Ord evidence
11:54:59 <elliott> job done
11:55:10 <byorgey> b52: if I were you I would just write  hammingDistance a b = sum . map fromIntegral . concatMap bits $ fixedXor a b
11:55:21 <ksf_> that's not what I want to do, though.
11:55:31 <aristid> :t fixedXor
11:55:32 <lambdabot> Not in scope: `fixedXor'
11:55:33 <hpaste> koning_robot pasted “how to use Parsec.Token.natural” at http://hpaste.org/90311
11:55:37 <b52> byorgey: im pretty sure thats incorrect
11:55:38 <aristid> @hoogle fixedXor
11:55:38 <lambdabot> No results found
11:55:40 <chrisdone> Luke1: so you're using a composite field and fromrow'ing both into one ZonedTime?
11:55:45 <aristid> *scratch head*
11:55:50 <b52> aristid: custom function
11:56:03 <Gracenotes> xors bitstrings
11:56:04 <Luke1> chrisdone: exactly.. just storing the TZ information after the timestamptz
11:56:05 <b52> applying bitwise xor between two bytestreams
11:56:12 <Gracenotes> or those
11:56:13 <koning_robot> can someone have a look at that paste please?
11:56:38 <byorgey> b52: which part are you sure is incorrect?
11:57:01 <b52> byorgey: nevermind, works, thanks :)
11:57:26 <b52> im still not sure why f $ g $ h != f . g . h is
11:58:00 <chrisdone> Luke1: oh well. it would be cool if that could be included in the library, but i suppose it would be non-obvious to new users
11:58:38 <chrisdone> Luke1: maybe a newtype wrapper?
11:58:39 <Luke1> yeah actually I didn't realize pgsql-simple was a library. I'm using postgresql-simple and was just abbreviating
11:58:53 <Luke1> but I suppose the same method could be used in both libraries
11:58:54 <byorgey> b52: f $ g $ h $ x == f . g . h $ x
11:59:09 <ksf_> elliott, to be precise, if I have an newtype EDSL a b , there are constraints on a and b, not just on the underlying term type.
11:59:25 <Luke1> chrisdone: unfortunately the only way to store a tz in PG is a string... not the best space usage
11:59:27 <chrisdone> Luke1: i'm not really using/maintaining psql-simple, i moved to postgresql-simple as the interfaces are similar (both based off of mysql-simple) and it's faster
11:59:35 <elliott> ksf_: yes.
11:59:38 <Luke1> ah yeah
11:59:45 <elliott> ksf_: data EDSL a b where Foo :: (Ord a, Ord b) => ...
11:59:53 <elliott> that's just like RFunctor constraints.
11:59:57 <ksf_> and I don't even want to hide them, as otherwise the interface would let me construct things that I later can't interpret, because the EDSL doesn't have the necessary ground types.
11:59:58 <chrisdone> Luke1: why a string? not an enum type?
12:00:06 <chrisdone> iirc enums are like 4 bytes or something
12:00:07 <elliott> huh?
12:00:13 <Luke1> chrisdone: They said it changes too much (the PG people)
12:00:19 <ksf_> s/ground types/primitive types
12:00:21 <chrisdone> time zones change too much? fair
12:00:26 <ksf_> yep.
12:00:29 <ksf_> didn't think of GADTs.
12:00:32 <Luke1> chrisdone: pg_timezone_abbrevs is not a table I guess, it's a function
12:00:33 <byorgey> b52: just take the definition   (f . g) x = f (g x), and substitute that into   (sum . map fromIntegral . concatMap bits . fixedXor) a b   and see what you get
12:00:50 <Luke1> chrisdone: so you can't just reference that with an index unfortunately
12:00:55 <b52> byorgey: ill do that, thanks
12:01:07 <flebron> Is there a more idiomatic way of writing "(\b -> if b then y else n)"?
12:01:25 <byorgey> flebron: to my great distress, no
12:01:27 <elliott> (bool y n). if you define bool.
12:01:35 <elliott> or (bool n y) strictly.
12:01:37 <chrisdone> Luke1: hm, \d+ says it's a view:  SELECT pg_timezone_abbrevs.abbrev, pg_timezone_abbrevs.utc_offset, pg_timezone_abbrevs.is_dst FROM pg_timezone_abbrevs() pg_timezone_abbrevs(abbrev, utc_offset, is_dst);
12:01:52 <chrisdone> Luke1: ah, it's a view of itself =)
12:01:53 <flebron> Thanks :)
12:01:57 <Luke1> yeah
12:02:23 <Luke1> and it's big and changing =/
12:02:29 <chrisdone> the interesting thing there is the time zones presumably change when postgresq is upgraded
12:02:36 <Luke1> they keep it up to date with the Olsen data
12:02:45 <chrisdone> is that on a cron job or per release?
12:02:49 <Luke1> not sure
12:02:49 <ksf_> elliott, but then I might want to define the whole thing on a type synonym so that I don't lose composability.
12:02:53 <Luke1> must be per-release
12:03:05 <elliott> ksf_: you won't be able to give an instance of the typeclass if it is a type synonym anywy
12:03:08 <elliott> *anyway
12:03:13 <elliott> no matter if it had special support for constraints or not
12:04:31 <chrisdone> Luke1: what does that mean for all your entries that use one of the time zones that changed?
12:04:40 <Luke1> chrisdone: my plan is basically to store the 3 columns in abbrev per timestamp to start
12:04:55 <ksf_> darn I can't partially apply synonyms, can I?
12:05:03 <ksf_> let's try typefams...
12:05:12 <Luke1> chrisdone: well if they're future times, they change. past times stay the same
12:05:22 <Luke1> usually it's a political event or something
12:05:27 <dmwit> > (\b | b -> True | not b -> False) True
12:05:28 <lambdabot>   <hint>:1:5: parse error on input `|'
12:05:28 <elliott> not type families either
12:05:30 <elliott> data families yes
12:05:38 <Luke1> indiana, for example, switched to DST in 2006
12:05:46 <elliott> dmwit: (\case True -> True; False -> False)?
12:06:04 <dmwit> > (\case True -> True; False -> False) True
12:06:05 <lambdabot>   <hint>:1:3: parse error on input `case'
12:06:33 <dmwit> ?let {-# LANGUAGE LambdaCase #-
12:06:33 <lambdabot>  Parse failed: Parse error: #-
12:06:35 <dmwit> ?let {-# LANGUAGE LambdaCase #-}
12:06:35 <lambdabot>  Parse failed: Parse error: EOF
12:06:48 <ksf_> *I just want to reorder those variables*
12:07:03 <Luke1> chrisdone: lpsmith was talking about making a PG extension to store timezones the way haskell people think of storing them
12:07:04 <elliott> dmwit: nice try :)
12:07:06 <chrisdone> Luke1: ah, storing all the info in the table seems a nice solution. well, it sucks, bit it solves the suck
12:07:22 <Luke1> yeah exactly
12:07:27 <dmwit> ksf_: Not being able to reorder type arguments is part of what makes type inference tractable. =)
12:07:30 <Luke1> i'm just trying to do ANYTHING to get it working at this point =)
12:09:04 <ksf_> elliott, I need to make a Category instance, that requires me to call the EDSL constructor, and that propagates constraints.
12:09:31 <elliott> ksf_: you can get around that by adding an additional Id :: Cat a a constructor
12:09:39 <elliott> or using semigroupoids if that's not enough
12:09:49 <chrisdone> Luke1: oh shit, i just remembered! postgresql has composite types!
12:09:52 <elliott> we did the former in lens for a while
12:09:58 <ksf_> ...and one for dot.
12:10:03 <elliott> no
12:10:11 <Luke1> chrisdone: that sounds promising
12:10:15 <elliott> shouldn't need that usually
12:10:17 <chrisdone> Luke1: my only concern would be whether indexes/ordering work properly: http://www.postgresql.org/docs/8.1/static/rowtypes.html
12:10:18 <tom39291> Text.JSON uses 'Result a' as the result of decoding JSON. Why wouldn't they use 'Either String a'?
12:10:24 <tom39291> I am aware of the existence of resultToEither.
12:10:56 <elliott> ksf_: e.g. data Foo a b where Id :: Foo a a; NotId :: (Ord a, Ord b) => (a -> b) -> Foo a b; instance Category Foo where id = Id; Id . f = f; f . Id = f; NotId f . NotId g = NotId (f . g)
12:11:00 * hackagebot hgal 2.0.0.2 - library for computation automorphism group and canonical labelling of a graph  http://hackage.haskell.org/package/hgal-2.0.0.2 (JeanPhilippeBernardy)
12:11:08 <elliott> and then given a (Foo a b), you either know that it's trivial or that you have Ord instances for a and b
12:11:31 <elliott> ...so all you need to do is add an (Ord a, Ord b) constraint to your top-level (Foo a b) consumer, if that
12:12:17 <Luke1> chrisdone: yeah that's basically what I'm doing, composite types, without the official logic for it
12:13:15 <jonkri> i have a test environment with different GHC versions. GHC 7.0.1 comes with template-haskell built against containers-0.4.0.0. however, when i want to build template-haskell against a newer version of containers, i get an error saying that the reinstall of template-haskell will break ghc-7.0.1. is there any way that i can get around this?
12:13:17 <chrisdone> Luke1: it seems like the difference would be that you can just have a FromField instance rather than the more error-prone FromRow
12:13:32 <Luke1> exactly. move the logic into the DB
12:13:46 <Luke1> this would better represent nulls too
12:13:51 <Luke1> the whole thing would be null together then
12:13:57 <chrisdone> true
12:14:09 <elliott> ksf_: -- and then you should be able to use the Categorical.Functor class
12:15:07 <KingofFerrets> Hmm.
12:15:25 <ksf_> now the typedness of my terms is biting me
12:15:47 <KingofFerrets> So, I have a bunch of different functions that return a custom type called Automata.
12:15:58 <ksf_> I generally don't like the idea of wrapping the thing up in a GADT
12:15:59 <Luke1> chrisdone: it almost does the same thing as the haskell FromRow: Look how you insert: ROW(1,2,3)
12:16:11 <KingofFerrets> From a few parameters.
12:16:30 <ksf_> ...I just need a collection of classes that my terms *and* (->) can use. nothing more.
12:17:56 <elliott> ksf_: well, the type-family-with-ConstraintKinds RFunctor style approach is going to be much more heavyweight, is all I can say
12:18:29 <KingofFerrets> Would it work if I condensed the parameters on them into tuples, so that they were some tuple -> Automata, then made a function automataGenerator :: Int -> (a -> Automata) -> [a] -> [[Automata]] that takes one of the automata-generating functions and generates a number of automata equal to the int for each set of parameters in the list?
12:19:46 <ksf_> elliott, (.) has type exp (a -> b) -> exp (a1 -> a) -> exp a1 -> exp b    (plus constraints) for all I'm concerned.
12:20:44 <elliott> uh, that's a pretty weird type.
12:21:01 <ksf_> It's the type the unembedding paper uses, and I like it.
12:21:21 <hpaste> nbouscal pasted “Knapsack DP” at http://hpaste.org/90312
12:21:46 <flebron> Suppose I have an [Int] x of length k, positive ints. Is there a reasonably simple way of obtaining a list of lists, each of the form [a_1, ..., a_k], where a_i <= x_i? Reasoning: I want to list (in order, preferably, but otherwise I can just sort) the divisors of a number, and I'm using its prime factorization.
12:22:34 <elliott> ksf_: well, I'm not sure that any premade Functor class could work well for you then...
12:23:07 <flebron> Oh I'm stupid, there obviously is. I find all a_1, then concatenate it to every possible f [x_2, ..., x_k] :)
12:23:12 <nbouscal> I'm trying to use dynamic programming on knapsack problem, running into way too much memory allocation and spending 90%+ of time on garbage collection. I'm very inexperienced at this type of code and also at Haskell, so I'm a bit out of my depth. Any help would be much appreciated :)
12:23:37 <Adeolos> do you know what's going on with hayoo
12:24:17 <ksf_> elliott, or, if you prefer, exp ((a -> b) -> (a1 -> a) -> a1 -> b)
12:24:35 <ksf_> I should actually do that, but that's scary.
12:24:37 <elliott> sure, that one makes more sense.
12:24:46 <elliott> and so would exp (a -> b) -> exp (c -> a) -> exp (c -> b)
12:25:54 <supki> nbouscal: how big is the array?
12:26:07 <chrisdone> flebron: map?
12:26:20 <ksf_> elliott, I can give you exp (a -> b) -> exp ((a1 -> a) -> a1 -> b), too :)
12:26:21 <Ebony> > [1%2..10%3]
12:26:22 <lambdabot>   [1 % 2,3 % 2,5 % 2,7 % 2]
12:26:23 <flebron> chrisdone: lowerPowers (x:xs) = [y:ys | y <- [0..x], ys <- lowerPowers xs], lowerPowers [] = [[]]
12:26:31 <b52> is there a safe !! ?
12:26:39 <nbouscal> supki: Very big. I have an assortment of test cases, my code works great up to about 200 items but dies after that
12:26:41 <elliott> b52: listToMaybe . drop n
12:27:11 <nbouscal> Some others have recommended using a bitset to store all but the last two columns of the array, but I have no idea how I would implement that
12:27:32 <nbouscal> I'm also going to implement a branch and bound strategy and am sure that will work much more efficiently, but I want to learn as much as I can from optimizing the DP approach first
12:29:02 <Botje> nbouscal: don't use lists of lists to mimic arrays.
12:29:14 <supki> nbouscal: I don't think Array is appropriate structure then because it allocates all (n * k) elements on initialization IIRC
12:29:16 <Botje> use Data.Array or Data.Map
12:30:31 <flebron> The DP approach usually uses a matrix, yes.
12:31:06 <flebron> The bottom-up approach, in general, will use a table to store values, although sometimes you can save space by noticing you don't need _all_ of the previous entries (typical case is with Fibonacci, you only need the last two results).
12:31:41 <flebron> The top-down approach can use a sparse data structure, like Data.Map, but it incurs in access time factors, in Map's case this is O(log n).
12:31:59 <Botje> oh, err
12:32:18 <Botje> you *are* using an array..
12:32:29 <flebron> (In general, I dislike using knapsack to show dynamic programming, since you don't really get any benefit from DP in that case, it was an intractable problem before, and it is still after DP :p)
12:32:49 <nbouscal> flebron: Yes, I think the prof is just being efficient trying to show us both DP and B&B with one example
12:33:37 <chrisdone> i hear thunder, but there's no rain… i'm living a Prodigy song right now
12:34:53 <ksf_> elliott, I admit, I've been dense all the time. I've wrote a gazillion of those semantic classes before.
12:34:58 <ksf_> *written
12:36:20 * elliott hopes to never have to write a gazillion classes...
12:37:19 * flebron had to write a brazilian classes once..
12:39:25 <chrisdone> elliott: i haven't written a line of code on my ghci replacement all day because i can't think of a name
12:39:33 <ksf_> elliott, easy as that: http://hpaste.org/90313
12:39:46 <elliott> chrisdone: haha
12:40:04 <elliott> chrisdone: chrisdones-great-ghci-replacement-copyright-chrisdone
12:40:12 <elliott> cggrcc for short
12:40:15 <chrisdone> elliott: i was thinking "ghc-server" because it'll work over duplex pipes like sockets or pipe or w/e
12:40:35 <elliott> ksf_: looks workable
12:40:36 <ksf_> chrisdone, look up synonyms for "glorious" starting with a different letter than "g"
12:40:42 <elliott> ksf_: the infix name of (.) is silly
12:40:46 <elliott> since you can never use it infix
12:41:00 <chrisdone> ksf_: but g is glasgow D:
12:41:05 <chrisdone> maybe another scottish city?
12:41:24 <elliott> excellent edinburgh ...
12:41:25 <chrisdone> edinburgh/glasgow. what's the difference? /me runs
12:42:21 <ksf_> that's true.
12:44:28 <chrisdone> i thought "dimi" was nice. "dimmi" (two m's) in italian is like "tell me", seems appropriate for a repl
12:47:19 <structuralist> is the (!) operator widely used for anything?
12:47:41 <chrisdone> it's often used for array lookup
12:47:47 <structuralist> isn't that (!!)?
12:47:49 <chrisdone> and in blaze-html it's used for specifying properties
12:47:54 <chrisdone> no, (!!) is only for lists
12:47:57 <structuralist> oh
12:48:08 <structuralist> hmm are all the single character ones taken?
12:48:24 <chrisdone> ? and # % & are generally free
12:48:46 <structuralist> or is there one for "x ! f = f x" that's used a lot
12:48:47 <chrisdone> lens has probably taken most of them, but it's probably taken the whole operator namespace
12:49:09 <elliott> structuralist: lens calls that one &
12:49:20 <structuralist> ok thanks :)
12:49:29 <chrisdone> see =p
12:49:55 <NihilistDandy> By then end of next year, one of the Ls in Haskell will stand for lens
12:50:05 <structuralist> & makes a lot of sense
12:50:24 <chrisdone> why does & make a lot of sense?
12:50:39 <structuralist> 1 & add(2) & add(3)
12:50:48 <structuralist> "take one and add 2 and add 3"
12:51:44 <chrisdone> mm, kinda, yeah
12:51:49 <chrisdone> there's also (<<<), iirc
12:51:53 <chrisdone> :t (<<<)
12:51:54 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
12:52:06 <chrisdone> ah, nah
12:53:54 <structuralist> > (const 1 >>> (+2) >>> (+3)) ()
12:53:55 <lambdabot>   6
12:54:04 <ksf_> this is *nice*. I only need one constraint class for all classes as it seems.
12:54:05 <chrisdone> right
12:54:15 <ksf_> er constraint family.
12:59:52 <FreeFull> On functions, >>> is like flip (.)
13:01:20 <b52> What#s that about? Challenge1.hs:304:38:
13:01:22 <b52>     Couldn't match expected type `Data.ByteString.Internal.ByteString'
13:01:24 <b52>                 with actual type `B.ByteString'
13:01:58 <elliott> probably it expects a strict bytestring and B is Data.ByteString.Lazy
13:02:13 <b52> its exactly the inverse
13:03:46 <b52> But I imported the lazy variant and the function expects a lazy bytestring
13:05:15 <FreeFull> b52: Nope, the error message says it expects a strict ByteString
13:05:41 <dEPy> ???  ->   Not in scope: data constructor `Writer'     Perhaps you meant `WriterT' (imported from Control.Monad.Writer)
13:05:57 <dEPy> I do have:   import Control.Monad.Writer
13:06:04 <b52> FreeFull: the docs for crypt state it expects lazy ones: http://hackage.haskell.org/packages/archive/AES/0.2.8/doc/html/Codec-Crypto-AES.html
13:06:32 <ksf_> dEPy, the type synonym changed a bit around during the mtl/transformers transition.
13:06:38 <ksf_> Writer is WriterT Identity
13:06:56 <dEPy> so I should use WriterT ?
13:07:15 <ksf_> dEPy, http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Writer-Lazy.html#t:Writer
13:07:29 <b52> FreeFull: ok, it seems key and IV are strict, the lazy is related only to the text
13:08:17 <ksf_> or http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Writer-Lazy.html
13:08:19 <ksf_> take your pick
13:08:39 <ksf_> dEPy, using the synonym or not makes no difference but in character count.
13:09:19 <dEPy> ksf_: I actually have no idea what that means. I just started with this. :)
13:09:19 <ksf_> dEPy, wait, *data constructor*?
13:09:31 <ksf_> there's no data canstructor Writer, only WriterT
13:09:45 <dEPy> I'm follwoing this: http://learnyouahaskell.com/for-a-few-monads-more#writer
13:09:50 <ksf_> this one: http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Writer-Lazy.html#t:WriterT
13:10:24 <ksf_> dEPy, yep, that's outdated.
13:10:33 <dEPy> ksf_: oh...
13:10:45 <ksf_> the constructor is called differently, otherwise you can just treat everything the same.
13:11:20 <ksf_> the new library makes no distinction between the plain version and the one you can wrap around arbitrary monads, any more.
13:12:21 <ksf_> dEPy, maybe shoot bonus a quick email about it.
13:15:01 <dEPy> ksf_: to who? There's no contact info... :S
13:15:04 <merijn> dEPy: Fortunately the solution should be simple!
13:15:19 <ksf_> dEPy, http://learnyouahaskell.com/faq
13:15:27 <merijn> dEPy: use the "writer" function instead of the (no longer existing) Writer constructor
13:15:28 <ksf_>  bonus at learnyouahaskell dot com
13:15:28 <NihilistDandy> Are there any good talks about ekmett's machines?
13:15:30 <elliott> does bonus even respond to emails?
13:15:35 <ksf_> dunno.
13:15:41 <NihilistDandy> I'm trying to get a feel for them, but looking at slides is kinda meh
13:15:43 <ksf_> preflex, seen bonus
13:15:43 <preflex>  bonus was last seen on #haskell 2 years, 55 days, 47 minutes and 43 seconds ago, saying: yeah i think that's better as well
13:15:47 <ksf_> preflex, seen BONUS
13:15:47 <preflex>  BONUS was last seen on #haskell 2 years, 55 days, 47 minutes and 47 seconds ago, saying: yeah i think that's better as well
13:15:48 <elliott> dEPy: anyway just use "writer"
13:15:50 <elliott> instead of Writer
13:15:54 <elliott> and "state" instead of State
13:16:07 <merijn> And "reader" instead of Reader :p
13:16:14 <merijn> (you might notice a pattern!)
13:18:45 <Ebony> Would you guys hate me if I said "I don't like LYAH"?
13:18:54 <Fuuzetsu> Not really.
13:19:21 <Fuuzetsu> On an unrelated note, it somehow feels extremely satisfying to get shouted down by the type checker today.
13:20:43 <hpc> in any other language, a compile error elicits "fuck you gcc, i know what i am doing"
13:20:58 <hpc> but with ghc, you know that you are wrong and it knows better
13:20:59 <Fuuzetsu> Sounds about right
13:22:18 <Demos> yeah GHC is pretty smart, hehe I like Go's "seriously, that is an error!"
13:22:52 <Gurgeh> How can I specify that a function takes a "Monoid Word8"?
13:23:11 <arkeet> Gurgeh: I don't know what a "Monoid Word8" is.
13:23:28 <shachaf> thoughtpolice: The isomorphism is very surface-level... It should be almost the same definition.
13:23:30 <Gurgeh> It is a Monoid over Word8
13:23:32 <Fuuzetsu> There's no Monoid datatype
13:23:32 <gspr> Gurgeh: You mean an  m Word8  where m is an instance of Monoid?
13:23:34 <ekipan> Monoid is a typeclass, Word8s are Monoidal
13:23:37 <shachaf> thoughtpolice: Which I guess elliott pointed out.
13:23:38 <arkeet> gspr: that doesn't make sense.
13:23:38 <Gurgeh> yes
13:23:41 <ekipan> or ought to be
13:23:44 <Fuuzetsu> glorious stereo
13:23:54 <Gurgeh> for example [Word8]
13:23:59 <Gurgeh> or Builder Word8
13:24:14 <arkeet> why?
13:24:30 <arkeet> you could write Monoid (m Word8) => ... m ...
13:24:30 <NihilistDandy> instance Monoid Word8 where...?
13:24:35 <arkeet> but that won't let you use anything to do with Word8
13:24:39 <ekipan> probably for Writer
13:24:44 <gspr> arkeet: No, I'm sorry. I have no idea what I just wrote :)
13:24:48 <arkeet> me either.
13:24:48 <ekipan> do you want the Sum or Product?
13:25:00 <gspr> arkeet: Please excuse my brainfart :)
13:25:05 <arkeet> :)
13:25:15 <arkeet> Gurgeh: what is it that you actually want to do?
13:25:31 <merijn> @tell conal The pdf link for the Tangible Functional Programming paper at http://conal.net/papers/Eros/ seems to be dead
13:25:31 <lambdabot> Consider it noted.
13:25:48 <thoughtpolice> shachaf: right. i actually just got it. i assume ProgramT in operational is actually Free (CoYoneda f) fused? i can't write view :: Program f a -> ProgramView f a without lowering CoYoneda and implying a functor constraint, but otherwise the definition does roll off the keyboard
13:25:52 <thoughtpolice> like i said i was quite tired
13:26:07 <Gurgeh> I would like my function to mappend Word8 to a container
13:26:15 <Gurgeh> but I don't want to decide which one
13:26:30 <thoughtpolice> maybe i should just try proving it or something
13:26:33 <Gurgeh> perhaps I can just take the append function as an argumen instead?
13:26:38 <arkeet> Gurgeh: it doesn't make sense to "mappend Word8"
13:26:47 <arkeet> maybe. it depends on what you're trying to accomplish.
13:27:14 <shachaf> thoughtpolice: data Free f a where { Pure :: a -> Free f a; Free :: f (Free f a) -> Free f a }
13:27:28 <shachaf> thoughtpolice: data Free f a where { Pure :: a -> Free f a; Free :: CoYoneda f (Free f a) -> Free f a } -- add CoYoneda
13:27:36 <ekipan> mappend over lists is (++) concat
13:27:47 <Gurgeh> yes, not exactly mappend
13:27:52 <Gurgeh> I want to add one element
13:27:57 <shachaf> thoughtpolice: data Free f a where { Pure :: a -> Free f a; Free :: (exists x. (f x, x -> Free f a)) -> Free f a } -- inline CoYoneda
13:28:09 <ekipan> @src mappend Maybe
13:28:09 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:28:15 <Gurgeh> to a container
13:28:34 <shachaf> thoughtpolice: data Free f a where { Pure :: a -> Free f a; Free :: (f x, x -> Free f a) -> Free f a } -- turn exists into forall ("curry")
13:28:48 <shachaf> thoughtpolice: data Free f a where { Pure :: a -> Free f a; Free :: f x -> (x -> Free f a) -> Free f a } -- curry again
13:28:57 <ekipan> by "container" do you mean "list"? or more general?
13:28:59 <Gurgeh> Monoid is probably not what I want
13:29:19 <Gurgeh> I mean something more general than a list
13:29:23 <shachaf> thoughtpolice: The first step is only a valid isomorphism if f is a Functor, of course.
13:29:30 <arkeet> how much more general?
13:30:03 <ksf_> fmap :: (Constr r a, Constr r b, t (f a -> t b)) =>  r (a -> b) -> t ((f a) ->  (f b))
13:30:03 <ksf_> fmap ::(Constr TDB a1, Constr TDB b) => TDB (Either a a1 -> TDB b) -> TDB (a1 -> b) -> TDB (Either a a1 -> Either a b)
13:30:18 <ksf_> I know it's a typo, but *should* ghc expand the signature like that?
13:30:22 <arkeet> Gurgeh: maybe you just want to make your own typeclass or something.
13:30:31 <ksf_> first is the class definition, second the inferred instance sig.
13:34:12 <Gurgeh> sorry, I think I was disconnected
13:34:39 <Gurgeh> Is there a typeclass for a container that can have elements appended to it?
13:35:51 <ksf_> how does one spell an empty constraint tuple?
13:35:59 <elliott> ()
13:36:17 <ksf_> doesn't work.
13:36:22 <byorgey> Gurgeh: not anything standard.
13:36:33 <arkeet> ksf_: works for me.
13:36:35 <ksf_>  Kind mis-match The second argument of `Cat' should have kind `* -> Constraint', but `()' has kind `*' In the instance declaration for `Cat Hask ()'
13:36:43 <hpc> :t undefined :: () => a
13:36:43 <lambdabot> a
13:36:45 <hpc> hmm
13:36:50 <arkeet> ksf_: paste code.
13:37:09 <byorgey> ksf_: you can have  () :: *  or  () :: Constraint, but not  () :: * -> Constraint
13:37:23 <ksf_> http://hpaste.org/90314
13:37:49 <arkeet> the second argument to Cat has kind * -> Constraint, not Constraint
13:38:05 <arkeet> as the message says.
13:38:21 <arkeet> :k Monoid
13:38:22 <lambdabot> * -> Constraint
13:38:25 <arkeet> for example.
13:38:34 <ksf_> :k (Monoid, Ord)
13:38:35 <lambdabot>     Expecting one more argument to `Monoid'
13:38:35 <lambdabot>     In a type in a GHCi command: (Monoid, Ord)
13:38:39 <ksf_> argh.
13:38:44 <arkeet> Monoid is a class.
13:38:47 <ksf_> there goes my plan.
13:38:50 <arkeet> you need to give it an argument before it becomes a constraint.
13:38:59 <NemesisD> anyone use cabal HEAD? was wondering if sandboxing "just works" in a dir with a cabal sandbox
13:39:03 <byorgey> class Anything a; instance Anything a;   Cat Hask Anything  ?
13:39:04 <arkeet> you can write  type Foo m = (Monoid m, Ord m), but you can't use Foo on its own.
13:39:05 <shachaf> ksf_: There was a post on SO about that the other day...
13:39:07 <ksf_> :k \x -> (Monoid x , Ord x)
13:39:07 <lambdabot> parse error on input `\'
13:39:13 <ksf_> that's it. I'm switching to idris
13:39:17 <arkeet> haha
13:39:38 <supki> NemesisD: you do cabal sandbox init and then use the usual cabal commands
13:39:42 <supki> worked for me
13:40:06 <NemesisD> supki: should the ghc stuff work properly too: ghci, ghc?
13:42:08 <supki> NemesisD: you mean if they automatically use package db from cabal sandbox?
13:42:11 <supki> I don't think so
13:43:06 <AeroNoti1> Which haskell-mode.el should I be using?
13:47:40 <merijn> ksf_: "type x = (Monoid x, Ord x)" is allowed
13:47:45 <trace30m> what means .... -> (a b c) -> b
13:47:52 <merijn> ksf_: You might need ConstraintKinds turned on, though
13:48:03 <merijn> eh
13:48:07 <ksf_> merijn, yeah but I can't pass that as a function
13:48:14 <merijn> "type MyConstraint x = (Monoid x, Ord x)"
13:48:20 <AeroNoti1> No-one using Emacs for editing Haskell?
13:48:51 <shachaf> No one among these 1000 people. It's tragic.
13:49:07 <AeroNoti1> Probably sarcasm. Well done.
13:49:11 <Fuuzetsu> Except a lot of us.
13:49:17 <ksf_> AeroNoti1, they've all seen the light and now use vim
13:49:20 <Fuuzetsu> AeroNoti1: cabal install haskell-mode?
13:49:21 <AeroNoti1> I'm sure
13:49:23 <arkeet> shachaf: we are people?
13:49:28 <Fuuzetsu> or fetch it from GitHub
13:49:33 <AeroNoti1> So that's the only one?
13:49:35 <AeroNoti1> I'm already using it
13:49:39 <NemesisD> supki: so how do you use ghci and have it figure out your installed packages?
13:49:40 <Fuuzetsu> Well then.
13:49:45 <Fuuzetsu> You might be interested in ghc-mod
13:49:51 <AeroNoti1> I'll check that out
13:49:54 <DolphR> you can use vim-commands in emacs with the right setup. Not that i use emacs, but i know one that does, and like it very much
13:50:05 <AeroNoti1> I'm not interested in that.
13:50:18 <AeroNoti1> It's just the indentation doesn't seem very clever in haskell-mode
13:50:40 <AeroNoti1> It allows me to insert random tabs when there's a clear indentation level the code should be at, usually modes don't do that.
13:50:41 <elliott> there are multiple indentation modes it comes with IIRC, check the documentation
13:50:50 <supki> NemesisD: I'm using -package-db option
13:52:47 <AeroNoti1> Aha, that's far superior
13:53:07 <trace30m> what means ...... -> ( Map k1 v1 ) -> ( Map k2 v3 )
13:58:15 <SrPx> So you're telling me a C++ > Haskell compiler is AI complete
14:00:00 <Fuuzetsu> I'm not sure whether this is an arrow or what. C++ → Haskell? I don't see that much use in that.
14:00:40 <trace30m> mapReduce :: ( (k1,v1) -> [(k2,v2)] )
14:00:41 <trace30m> -> ( k2 -> [v2] -> v3 )
14:00:41 <trace30m> -> ( Map k1 v1 ) -> ( Map k2 v3 )
14:00:47 <trace30m> its haskell
14:00:49 <elliott> SrPx: what?
14:00:59 <elliott> you just joined and nobody has said anything about that...
14:01:33 <SrPx> elliott: wops.
14:02:35 <SrPx> Fuuzetsu: no way. If it existed and produced good results I would be compiling a huge legacy C++ project into Haskell. I dream with that day...
14:03:01 <Fuuzetsu> It'd be the ugliest Haskell ever.
14:03:05 <flebron> Possibly dumb question. If I use "ghc foo.hs -prof -auto-all -o foo", and then ./foo +RTS -p, I get "Most RTS options are disabled. Link with -rtsopts to enable them.". Adding -rtsopts to the ghc command line (just before -o) does not change this. What am I doing wrong?
14:03:27 <SrPx> Fuuzetsu: "good results", as in, actually understanding what the C++ is doing and producing linguistic  Haskell.
14:03:32 <arkeet> flebron: force recompile it.
14:03:32 <xplat> SrPx: these things always come with pluses and minuses.  if it was so easy to port code like that to haskell, people would be writing code like that in haskell
14:03:34 <SrPx> this would be AI complete, I guess
14:03:38 <arkeet> with say -fforce-recomp
14:04:09 <flebron> Ah, that did it. I removed the .hi and .o :)
14:04:14 <arkeet> :)
14:04:15 <flebron> Thanks!
14:04:15 <NihilistDandy> AeroNotix: I
14:04:22 <AeroNotix> NihilistDandy: you what
14:04:30 <NihilistDandy> *I am working on a fork of Emacs Prelude that uses evil throughout
14:04:34 <xplat> SrPx: oh, yeah, figuring out what code is doing and writing code to do the same thing in a completely different style ... not sure if it's AI-complete but it's too far from existing to tell either way
14:04:41 <NihilistDandy> So you can use the clever Emacs haskell-mode but get all the vim goodness
14:04:44 <AeroNotix> meh
14:04:55 <Demos> in general the way to use X language From Y language is to use X form C and C from y
14:05:50 <AeroNotix> Using variables like that with the language you're talking about as a single-letter is less-than-obvious.
14:06:05 <SrPx> xplat: uh huh
14:06:28 <Demos> X and Y are any language , and C is C
14:06:54 <SrPx> I know!
14:06:58 <Fuuzetsu> But then X and Y could also be C
14:07:07 <hpc> i prefer R
14:07:08 <arkeet> and using C from C is a no-op.
14:07:19 <arkeet> so it still works out.
14:07:26 <Demos> oh honestly!
14:07:41 <AeroNotix> What about F?
14:07:47 <hpc> F#?
14:07:58 <AeroNotix> And D?
14:08:07 <arkeet> good point. I'm pretty sure that if X and Y are both languages that run on say jvm
14:08:09 <arkeet> or .net
14:08:11 <NihilistDandy> I'm going to build languages X and Y just to retroactively muck up your pipeline
14:08:12 <Fuuzetsu> Pretty sure ‘A’ exists.
14:08:15 <arkeet> then they don't go through C to interact
14:08:23 <Demos> true
14:08:37 <Demos> and with C++ --> .net you can make glue with C++/CLI
14:08:43 <Demos> note I said in general
14:08:46 <NihilistDandy> Isn't the JVM written in C?
14:09:02 <Demos> also the nitpicker's corner is ----> that way
14:09:15 <lpsmith> Luke1, you don't need a instance specifically for (Maybe ZonedTime)
14:09:36 <lpsmith> postgresql-simple already has a generic instance that works for all types
14:09:38 <NihilistDandy> Demos: Upper right or lower right?
14:09:42 <Luke1> lpsmith: i had to specify one
14:09:48 <lpsmith> ?
14:09:50 <lpsmith> why?
14:09:52 <Luke1> not sure
14:09:55 <Luke1> it complained
14:09:59 <Luke1> let me undo the code and see what the error was
14:10:13 <lpsmith> I don't think the complaint was quite the one you thought it was
14:10:20 <Luke1> oh because mine's a FromRow instance... doesn't that only work for FromField?
14:10:28 <lpsmith> Oh
14:10:30 <lpsmith> yeah
14:10:32 <lpsmith> ok
14:10:33 <lpsmith> right
14:10:45 <lpsmith> I'd like a generic Maybe instance for FromRow
14:10:48 <lpsmith> but that doesn't work
14:10:55 <Luke1> i'm using constraints as chrisdone suggested. it actually doesn't work that bad
14:10:58 <Luke1> yeah that'd be nice.
14:10:58 <lpsmith> can't work with the current interface
14:11:08 <Luke1> i did have to duplicate a little more code than i'd like to
14:11:30 <Luke1> thanks for reading through the previous discussion btw
14:11:48 <lpsmith> Luke1, do you have a recent hpaste of your current code?
14:11:56 <Luke1> i can make one
14:11:58 <Luke1> one sec
14:12:28 <hpaste> Luke pasted “PG TZ Hacking” at http://hpaste.org/90316
14:12:36 <Luke1> that's it
14:13:24 <lpsmith> ChrisDone's suggestion that you create a composite type is a good one,  it would avoid this FromRow stuff,  but you'd have to newtype ZonedTime as there is already a FromField instance
14:13:46 <Luke1> before I go too far down the composite type path, does the code support it?
14:13:56 <lpsmith> yeah
14:14:00 <Luke1> nice!
14:14:21 <lpsmith> for typechecking just use the typename
14:14:25 <Luke1> i still need the custom FromRow stuff for ZonedTime because i have to convert back into the origin timezone
14:14:31 <absence> is anyone using sublime edit with the haskell package? i'm having trouble getting things like "show symbol info" working
14:14:37 <lpsmith> typename operator because the composite type won't have a stable OID
14:15:06 <Luke1> is there something special with newtypes and the pgsimple code?
14:15:07 <lpsmith> well, but you shouldn't need that if you decide to go with composite types
14:15:10 <NihilistDandy> absence: Did you install ghc-mod?
14:15:11 <Luke1> typename*
14:15:21 <lpsmith> no,  just that ZonedType already has a FromField instance
14:15:36 <Luke1> i'm calling it's fromRow though
14:15:48 <Luke1> i guess I don't understand what you mean
14:16:02 * hackagebot diagrams-haddock 0.1.1.0 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.1.1.0 (BrentYorgey)
14:16:03 <lpsmith> right, which is why you don't need a newtype
14:16:19 <Luke1> can you make a simple mockup about how I would use the method you're describing?
14:16:19 <absence> NihilistDandy: yes. it doesn't complain that it's missing, it just says "symbol not found"
14:16:20 <lpsmith> using composites would allow you to avoid FromRow and use FromField instead
14:16:50 <lpsmith> I dunno if it's really all that much better,  but it's a thought
14:16:58 <Luke1> i see
14:17:35 <NihilistDandy> absence: Does it give any other information about what it's choking on? Do you have module Whatever where at the top?
14:17:44 <NihilistDandy> I don't really use Sublime, anymore, I'm just spitballing
14:18:00 <Luke1> i understand. right now i just have a timestamptz and a separate composite type for timezone. perhaps I should make a composite type for a "zonedtime" which wraps both
14:18:12 <braincracker> yo
14:18:12 <Luke1> since mine are separate I need the FromRow
14:18:27 <braincracker> lold on this "LAMBDA Gay / Lesbian / Bisexual / Transgender Community …" http://lambda.org/
14:18:33 --- mode: ChanServ set +o elliott
14:18:40 --- mode: elliott set +b *!*magic@2a01:270:dd00:77ca:fadd:4ec6:ab67:*
14:18:40 --- kick: braincracker was kicked by elliott (braincracker)
14:18:46 --- mode: elliott set -o elliott
14:19:05 <Gracenotes> I mean, lambda is used be a lot of people
14:19:10 <Gracenotes> it is a letter
14:19:10 <lpsmith> Luke1, looks pretty good actually
14:19:27 <lpsmith> Luke1, just one thought,  and I don't know if you really want to do this,  but:  https://github.com/lpsmith/postgresql-simple/issues/64
14:19:48 <lpsmith> The thing is that  your instance for Maybe TimeZone returns nothing if any one of the timezone fields are null
14:19:55 <absence> NihilistDandy: no, it just says "symbol not found" on the status line. i was hoping for some kind of verbose error output, but i haven't found anything. i have module etc on top, the code compiles and runs fine
14:20:34 <lpsmith> if you want to ensure that they are either all null or all have values,  that link suggests how you can at the moment
14:20:46 <lpsmith> of course if it's a mixture,  your conversion code would fail
14:21:02 <lpsmith> so it's a weak sense of the word "ensure"
14:21:08 <lpsmith> very weak =)
14:21:43 <Luke1> yeah hmm
14:21:55 <Luke1> I have other issues like that in my DB as well
14:22:09 <NihilistDandy> absence: Weird. Possibly related? https://github.com/SublimeHaskell/SublimeHaskell/issues/37
14:24:03 <AeroNotix> I must say that once you get around the weirdness, Haskell's syntax is in fact quite clean
14:24:57 <chrisdone> has anyone used atto-lisp?
14:25:01 <chrisdone> nominolo: ping
14:26:33 <ipuustin> I'm doing a game that is full of things happening with a certain probability. Like "a" happens with 25 % probability, "b" with 15 % probability, and "c" otherwise.
14:26:49 <ipuustin> I was thinking in building an abstraction for this so that a function would be given a random number [0..1] and a list of tuples with outcomes and their probabilities.
14:27:10 <ipuustin> Does anyone know if there is already a library or function that does this or something similar?
14:29:26 <flebron> So I'm profiling my code, and I get that the cost centre "main" is 92.8% of the time. What does this mean? Is it some trivial thing about "Everything except actual IO is 92.8% of your time", or what?
14:29:41 <lpsmith> Luke1, well that conversion ambiguity when you have a mixture of null and not null values is far more important when dealing with left outer joins,  because if there is a not null value then you definitely want to use the regular conversion process.
14:30:15 <lpsmith> For your ZonedTime purposes it's probably not all that important
14:30:39 <Luke1> gotcha
14:31:08 <absence> NihilistDandy: i'm not sure.. ghc-mod info works on the command line at least
14:32:59 <lpsmith> Luke1, although I definitely try to make most of my columns not null
14:33:28 <jmcarthur> ipuustin: http://hackage.haskell.org/packages/archive/MonadRandom/0.1.9/doc/html/Control-Monad-Random.html#v:fromList
14:33:30 <Luke1> yeah it's not possible with composite types unfortunately
14:33:42 <lpsmith> nope,  that is indeed unfortunate
14:35:38 <hpaste> Luke pasted “Composite TZ Types” at http://hpaste.org/90317
14:36:00 <Luke1> that's what I'm basing my haskell on
14:36:08 <Luke1> basically building up a haskell ZonedTime in PG
14:36:50 <chrisdone> nice
14:37:09 <hpaste> flebron pasted “Profiling output” at http://hpaste.org/90318
14:37:12 <ipuustin> jmcarthur: thanks!
14:37:31 <flebron> ^-- output of profiling with -pa. What does main having 95% time mean?
14:37:58 <AeroNotix> Hmm, how does one 'do' state? In other functional languages I would abuse actors to achieve state
14:38:14 <flebron> AeroNotix: You may be interested in the State monad.
14:38:17 <NihilistDandy> State monad
14:38:20 <AeroNotix> already reading about it
14:39:28 <c_wraith> flebron: incredibly hard to say without seeing your code.
14:39:45 <flebron> c_wraith: http://codepad.org/LIdqVukr
14:39:49 <c_wraith> flebron: it might mean "you defined a function in main that's where 95% of the execution time is"
14:39:56 <flebron> (It computes the period of the Fibonacci sequence, modulo a given number.)
14:40:10 <Luke1> chrisdone: that cleans up my sql and code quite a bit. great suggestion.
14:40:15 <flebron> main itself is pretty simple, that's why it's surprising that it's taking 95% of the time.
14:40:42 <geekosaur> often that means main is what's foring other calculations (typically by doing I/O)
14:40:46 <geekosaur> *forcing
14:40:51 <Peaker> is the whole point of Dynamic doing the existential wrapper for you?
14:41:20 <shachaf> Peaker: Dynamic implements it with Any and unsafeCoerce instead of an existential, but it's more or less the same thing.
14:41:27 <jmcarthur> AeroNotix: note that the State monad gives you something one might call state from some point of view but is actually still not the same as mutable state. you rarely need real mutable state in haskell
14:41:38 <arkeet> ugh, Any.
14:41:54 <Peaker> shachaf, any advantages to that approach?
14:42:07 <shachaf> arkeet: The type Any, not the kind Any!
14:42:41 <shachaf> Peaker: Maybe storing a TypeRep is more efficient than storing a dictionary? I don't know.
14:42:44 <c_wraith> flebron: I strongly suspect the time being taken is in print, especially if you're testing it with printing to the console
14:42:50 <arkeet> I thought Any was a type, that inhabited every kind.
14:43:01 <flebron> I am printing to console, yes. So it's an IO bottleneck, c_wraith?
14:43:21 <flebron> (Each number being printed is at most 6 digits long, so that's surprising)
14:43:39 <c_wraith> flebron: how many numbers are being printed?
14:43:43 <flebron> 10,000
14:43:50 <jmcarthur> arkeet: Any is just a type that ghc guarantees is safe to use unsafeCoerce with, with some obvious restrictions
14:43:56 <flebron> Takes about 1.2 seconds
14:44:27 <flebron> (The numbers themselves are just [1..10000]. The program's input is just n, followed by n numbers.)
14:44:45 <jmcarthur> arkeet: e.g. if you do  unsafeCoerce (unsafeCoerce (x :: A) :: Any) :: B,  you have to make sure A is the same as B
14:44:47 <chrisdone> Luke1: awesome!
14:44:48 <c_wraith> flebron: I can't say if that's an IO bottleneck or not. try printing just the sum of the numbers or something
14:45:03 <c_wraith> flebron: just to get a data point where IO is definitely not the problem
14:45:09 <jmcarthur> arkeet: the guarantee is just that the intermediate type, Any, isn't going to cause problems for you
14:45:13 <c_wraith> flebron: and to see where the time gets attributed to in that case
14:45:29 <flebron> Printing just the sum actually increases the time, haha, to 1.4s.
14:45:31 <NerrZ> sorry, I am trying to install ghc on ubuntu and when I went to run the configure I got this error: checking for path to top of build tree... utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory
14:45:34 <c_wraith> flebron: whoops.  I just remembered what going on.
14:45:37 <arkeet> jmcarthur: I don't see the advantage over an existential.
14:45:44 <NerrZ> and I checked and I have gmp installed, can someone help me with this?
14:45:44 <flebron> Oh, good idea, I'll profile it with the sum.
14:45:54 <c_wraith> flebron: it's crediting the time to main because the values aren't being forced until the print.
14:46:09 <jmcarthur> arkeet: nor i. maybe, as shachaf guessed, the TypeRep is more efficient that the Typeable dictionary
14:46:13 <jmcarthur> *than the
14:46:17 <Saizan> NerrZ: you've to install libgmp3
14:46:19 <flebron> Ah, so I should judiciously sprinkle some seq powder around the code?
14:46:23 <Luke1> lpsmith: I'm in a jam type-wise. Can I use your type suggestion to write a ZonedTime to my zonedtime pg type instead of the timestamptz?
14:46:25 <c_wraith> flebron: so everything else is just creating and returning closures.  main is actually being credited the time for evaluating them
14:46:42 <c_wraith> flebron: not judiciously - just where it makes sense. :)
14:46:48 <shachaf> jmcarthur: Or possibly it's less efficient.
14:46:55 <jmcarthur> maybe ^_^
14:46:58 <shachaf> jmcarthur: Since the dictionary can be shared and the TypeRep probably can't.
14:47:08 <shachaf> Did GHC even have existentials in 2001?
14:47:09 <jmcarthur> why not?
14:47:16 <Peaker> given my own existential wrapper: I can do: foo (Wrapper w) = ... work with existentially quantified w here ...    if I use Dynamic instead:  foo dyn = ... I can't really use the existentially typed value inside unless I know exactly what type to coerce it to?
14:47:27 <jmcarthur> i would think the TypeRep would be shared
14:47:45 <flebron> c_wraith: Should I define something like \x -> seq x x, and use that at the result of my functions?
14:47:45 <Saizan> NerrZ: oh, missed the second line, what files do you have for libgmp?
14:47:56 <Peaker> fromDynamic needs a particular type to be known, but I may not know what type it is
14:47:58 <arkeet> flebron: that won't do you anything at all.
14:48:08 * flebron fails at seq :(
14:48:20 <shachaf> jmcarthur: Why would it be shared?
14:48:31 <jmcarthur> Peaker: data Dynamic = forall e. Typeable e => Dynamic e  -- it wouldn't *just* be an existential
14:48:34 <shachaf> jmcarthur: If I say (typeOf x) and (typeOf y) where x and y are the same type, those are two different values.
14:48:42 <Peaker> jmcarthur, of course, same as my Wrapper
14:48:44 <shachaf> Assuming they're not forced anyway.
14:48:56 <NerrZ> hmm, it seems I am missing just that one, I have libgmp.so.10
14:49:00 <jmcarthur> shachaf: how would one generate the TypeRep at runtime in the first place? it's probably just a single value in practice
14:49:05 * Peaker avoids Dynamic since it doesn't seem to make the code any nicer
14:49:15 <arkeet> Dynamic seems inflexible.
14:49:21 <shachaf> jmcarthur: Assuming it's forced, I guess.
14:49:23 * shachaf vaguely hopes Typeable gets foo :: (Typeable a, Typeable b) => Maybe (Is a b), but it looks like it won't happen.
14:49:25 <Saizan> NerrZ: if you have /usr/lib/libgmp.so you could add a symlink like "sudo ln -s /usr/lib/libgmp.so /usr/lib/libgmp.so.3"
14:49:32 <Saizan> NerrZ: it should work fine
14:49:36 <jmcarthur> shachaf: yeah that'd be nice
14:49:39 <shachaf> But anyway that's implementable as gcast Refl
14:51:17 <NerrZ> let me reinstall it, then ill link it, thanks
14:53:51 <flebron> c_wraith: Any ideas where to put seqs to better distribute the costs?
14:54:07 <NerrZ> it says it failed to create the link since it already exsists, yet the configure still says it cant find it
14:56:03 * hackagebot zeromq3-haskell 0.4 - Bindings to ZeroMQ 3.x  http://hackage.haskell.org/package/zeromq3-haskell-0.4 (ToralfWittner)
15:06:25 <lpsmith> Luke1, and postgresql-simple was based to a small degree in pgsql-simple as well ;-)
15:06:41 <Luke1> ah i didn't know the background
15:30:30 <Luke1> lpsmith: is there a way to compose two ToRow instances?
15:31:07 <lpsmith> Luke1, sure,  you can just call the toRow method yourself
15:31:16 <Luke1> cool
15:31:20 <lpsmith> although that doesn't necessarily work for every use case
15:31:49 <lpsmith> given that,  e.g.  the toRow method requires values to be put in quotes
15:32:40 <lpsmith> And, for example,  range types need a single pair of quotes around the whole value
15:32:46 <lpsmith> IIRC
15:33:50 <Luke1> ah yeah
15:33:53 <Luke1> good point
15:34:13 <Luke1> my FromField and FromRows are all really clean but my ToRows... well I don't have any
15:34:22 <Luke1> I just build up the tuples
15:34:26 <lpsmith> The ToRow/ToField FromRow/FromField interfaces could definitely be improved,  but I haven't given it a lot of thought
15:35:06 <lpsmith> It seems to me that key bits of compositionality are still lacking, for example
15:35:07 <Luke1> it's pretty straight forward in the from direction but the "to" direction is weird because the query needs to know what the result structure of the toRow is
15:35:16 <Luke1> yeah
15:35:49 <lpsmith> They are still on the whole a step up from mysql-simple and a big step up from HDBC,  in my opinion
15:36:06 <Luke1> yeah totally agreed
15:36:21 <Luke1> best i've seen especially with the new lazy conversion update you did
15:36:50 <Luke1> i think the real issue is you need a way to fmap over all of the fields in a record and call toField on it. is that possible?
15:38:57 <lpsmith> Luke1:  I'm honestly not sure
15:39:33 <lpsmith> protocol-level parameters might get rid of some of this complexity
15:39:41 <lpsmith> and introduce other issues
15:40:53 <Luke1> let me mess around with migrating some more logic to ToRows. I'll have a better idea then
15:40:58 <Luke1> but I'm happy with everything else
15:50:13 <Luke1> lpsmith: does pgsql-simple help me out at all for ToRow of composite types?
15:50:30 <Luke1> does it call a sub-toRow or anything?
16:03:38 <OxGOOSE> Is anyone here good at networking?
16:04:09 <sipa> http://www.phdcomics.com/comics/archive.php?comicid=877
16:04:23 <elliott> OxGOOSE: this channel is about the haskell programming language
16:04:28 <elliott> OxGOOSE: are you mrBG?
16:05:02 <lpsmith> Luke1, I haven't really studied the problem,  but probably not,  I'm afraid
16:05:05 <AeroNotix> is it really that weird to not have facebook?
16:05:24 <slack1256> aren't closed type families analogous to GADT?
16:05:28 <OxGOOSE> elliot: mrBG?  I know that, I just need someone who is good with sockets and thought I might try here.
16:05:48 <slack1256> I always tought about type families as gadts with an open world asumption about instances
16:06:52 <elliott> OxGOOSE: ok, well this is not the channel for it, sorry, perhaps try ##networking?
16:07:12 <OxGOOSE> It's overflown :|
16:07:15 <merijn> slack1256: How are they like GADTs? GADTs force you into a specific data type, type families don't
16:07:18 <OxGOOSE> Thanks anyway
16:09:48 <slack1256> merijn: Isn't just me who thinks that even the haskell wiki page about type-families has a commentary on it
16:10:01 <slack1256> http://www.haskell.org/haskellwiki/GHC/Type_families first ocurrence of the word GADT
16:10:37 <slack1256> infact, the example about [()] can be done as a GADT which reinforce my vision
16:11:13 <merijn> Which example is that?
16:11:41 <merijn> oh, the XList
16:11:47 <slack1256> exactly
16:11:56 <slack1256> maybe is simple enought to be done on both
16:11:59 <merijn> slack1256: That's a data family, though, not a type family
16:12:31 <slack1256> isn't that just semantics?
16:12:35 <merijn> slack1256: To show you something you can do with type families, but not GADTs
16:12:36 <merijn> no
16:12:46 <merijn> Type families don't need a data type associated with them at all
16:12:48 <hpaste> merijn pasted “type family stuff” at http://hpaste.org/90320
16:12:56 * slack1256 cheking
16:13:00 <merijn> slack1256: Take that example, no data types
16:13:04 * slack1256 checking sorry
16:16:10 * hackagebot pipes-network-tls 0.1.1.0 - TLS-secured network connections support for pipes.  http://hackage.haskell.org/package/pipes-network-tls-0.1.1.0 (RenzoCarbonara)
16:17:36 <slack1256> merijn: to check my understanding of this. foo is the identity for all types except Unit, in which case the code won't even compile.
16:17:58 <merijn> slack1256: Correct
16:18:13 <slack1256> this is done forming the family of instances beloging to Restrict which is a Contraint as defined by the ConstraintKinds extension
16:18:41 <slack1256> this is cool, I've never used that extension but this indeed is a aplication of type families
16:18:56 <banister`sleep> what's the name of teh function that's the opposite of return?
16:19:02 <banister`sleep> i.e where you unwrap the monad and get the value
16:19:07 <merijn> slack1256: It helps to think of type families as type level functions. i.e. "Restrict" is a function that takes a type and a list of types and returns a Constraint
16:19:16 <Guest55594> there isn't one for monads that's general
16:19:18 <merijn> banister`sleep: That function doesn't exist
16:19:21 <Guest55594> unless you're thinking of comonads?
16:19:33 <Guest55594> btw one reason it's not IO a -> a
16:19:43 <slack1256> merijn: that was I thinkin, a kind of type level function.
16:19:52 <slack1256> cool
16:19:53 <banister`sleep> what's a good name for that function though?
16:19:53 <arkeet> banister`sleep: probably, if you think you want that, you really want >>=
16:20:03 <arkeet> there isn't a name for it because it doesn't exist.
16:20:03 <merijn> slack1256: (Actually, it's slightly more generic, it take a value of any kind, not necessarily * and a list of that kind and returns a constraint)
16:20:13 <Guest55594> well comonad calls it extract, but you don't want exactly that
16:20:20 <slack1256> unless for the DataKind extension right?
16:20:21 <Guest55594> retrieve?
16:20:23 <merijn> slack1256: So if you have DataKinds you could also check equality on different kinds than *
16:20:28 <Guest55594> of course you'd want a specific name to your monad
16:20:32 <Guest55594> because you can't have a general form
16:21:14 <slack1256> merijn: Oh, cool, right that what the DataKind extension does.
16:21:25 <merijn> slack1256: i.e. you could have "Restrict a [1,2,3,4,5]" which would only allow type level integers other than those in the list
16:21:41 <slack1256> then the difference between closed and (default) open type families
16:21:53 <slack1256> we truly are moving on the dependent types direction, eh?
16:22:02 <NihilistDandy> merijn: How long can that list be? I don't know much about DataKinds
16:22:15 <merijn> NihilistDandy: As long as you're willing to type out by hand :p
16:22:23 <slack1256> heh.
16:22:24 <merijn> NihilistDandy: And/or generate using TemplateHaskell
16:22:32 <NihilistDandy> Aww, I was hoping for Restrict a [1..50] or something
16:22:52 <slack1256> you can always do that with a trick with vim or emacs
16:22:52 <merijn> NihilistDandy: You could probably do that using TH, I haven't looked into it
16:23:16 <merijn> NihilistDandy: Actually, you could probably do that without TH
16:23:38 <NihilistDandy> Hmm
16:23:55 <merijn> Write a type family that generates a list until the selected value :p
16:24:08 <slack1256> that just know
16:24:11 <Luke1> lpsmith: can you direct me to the code that handles de/serializing composite tyeps?
16:24:14 <merijn> I'll leave that as an exercise for the reader, as you need type level comparison
16:24:28 <slack1256> if type-families allow me to write a sort of type level function, it should be possible do that right?
16:24:50 <lpsmith> Luke1, the closest thing I've done myself is implementing FromField/ToField for the period type
16:25:07 <Luke1> lpsmith: thanks
16:25:08 <merijn> slack1256: Yes, I know you can do it, but I'm to tired to research whether type level <=, <, >=, > have been implemented yet
16:25:18 <lpsmith> which is basically the prototype for the new range types
16:25:30 <Luke1> is that in the hackage code yet?
16:25:35 <Luke1> or just github?
16:25:38 <slack1256> merijn: I will look into it, no you don't have to look, that way I wouldn't learn
16:25:47 <NihilistDandy> slack1256: http://hackage.haskell.org/package/type-level
16:25:52 <lpsmith> Luke1, no,  just inside a proprietary app
16:26:01 <Luke1> ah
16:26:06 <lpsmith> I could hpaste it though if you really want
16:26:07 <NihilistDandy> Looks pretty unmaintained, but it's something to look at
16:26:15 <Luke1> sure-  anything would help
16:26:17 <banister`sleep> arkeet: ah you're right
16:26:20 <banister`sleep> arkeet: my mistake
16:26:37 <NihilistDandy> Also this: http://hackage.haskell.org/package/type-level-numbers-0.1.0.2
16:26:55 <arkeet> don't forget about safePerformIO :: IO a -> IO a
16:27:12 <ion> safePerformIO :: IO a -> IO a; safePerformIO = unsafeCoerce
16:27:17 <arkeet> haha
16:27:25 <merijn> slack1256, NihilistDandy: The place to look is singletons
16:27:28 <merijn> @hackage singletons
16:27:28 <lambdabot> http://hackage.haskell.org/package/singletons
16:27:51 <arkeet> why is 0.8 the oldest version?
16:28:00 <NihilistDandy> Neat
16:28:24 <Fuco> can anyone give me an example of a data type over which defining a catamorphism is impossible?
16:28:30 <merijn> arkeet: Why not?
16:28:36 <arkeet> I don't konw.
16:28:40 * slack1256 looking at the readme
16:29:06 * arkeet looking at the presentation
16:29:06 <merijn> slack1256: Have you read the "Fun with Type Functions" paper?
16:29:30 <slack1256> no, maybe there will explain what are singleton types?
16:29:34 <slack1256> let me search
16:29:45 <slack1256> @find Fun with Type Functions
16:29:46 <lambdabot> Not in scope: type constructor or class `Fun'
16:29:46 <lambdabot> Not in scope: type variable `with'
16:29:46 <lambdabot> Not in scope: type constructor or class `Type'
16:29:48 <lpsmith> Luke1, http://hpaste.org/90321
16:29:56 <Luke1> thank you so much
16:29:58 <merijn> slack1256: It doesn't cover singleton types, but it does explain all the ideas behind data and type families
16:30:00 <NihilistDandy> @google Fun With Type Functions
16:30:03 <lambdabot> http://research.microsoft.com/~simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
16:30:03 <lambdabot> Title: Fun with type functions
16:30:05 <lpsmith> It turns out I never implemented ToField,  just a json-builder instance for it
16:30:36 <lpsmith> though it should be easily adaptable to ToField
16:31:31 <Luke1> yeah
16:31:34 <lpsmith> The attoparsec parsers I used are exported from the Time.Internal
16:31:53 <lpsmith> which isn't exactly internal,  but I'd like to have some freedom
16:33:48 <Luke1> i think with composite types it's not possible to write a ToField. only ToRow
16:33:59 <lpsmith> but honestly,  in order to get a sane, generic FromField instance for composite types,  it might well make sense to have instances provide attoparsec parsers instead of just of (conceptually)  RawData -> Maybe value
16:34:00 <Luke1> since it's basically an embedded row as far as the query is concerned
16:34:11 <prophile> if Hask is the category of haskell types and functions are morphisms in that category, how can a function be from or to another function?
16:34:17 <Luke1> yeah good point
16:35:22 <NihilistDandy> prophile: (->) r is a type
16:36:20 <prophile> so a -> b is a morphism from (->) a to b?
16:37:56 <arkeet> no, from a to b
16:37:59 <arkeet> well.
16:38:05 <arkeet> a value of type a -> b is a morphism from a to b.
16:38:16 <Luke1> lpsmith: yeah exposing the attoparsec parser would make the ROW(,,,) syntax easer to build up
16:38:24 <arkeet> hom(a,b) = the set of values(functions) of type a -> b
16:38:43 <lpsmith> I haven't studied the composite syntax closely enough, I'm afraid
16:44:32 <Peaker> could be nice if phantom type params required an underscore, and GHC warned about unused type params. Also about unused type class constraints
16:44:58 <Peaker> (though there ought to be a way to say you want the constraint not for its methods)
16:46:06 <arkeet> good talk. http://www.youtube.com/watch?v=rLJ_YyVRKzs
16:48:48 <arkeet> shame about Any.
16:49:37 <arkeet> hey wait.
16:49:42 <arkeet> do we have some kind-level Proxy?
16:49:47 <arkeet> because that could be used instead of Any.
16:50:40 <arkeet> (or do I mean type-level? regardless, one level above what we have.)
16:53:10 <arkeet> `Proxy' of kind `forall (k :: BOX). k -> *' is not promotable
16:53:11 <arkeet> =(
16:53:21 <arkeet> wait.
16:53:37 <arkeet> huaaah.
16:53:39 <arkeet> I win
16:56:11 * hackagebot hledger-lib 0.21.3 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.21.3 (SimonMichael)
16:56:13 * hackagebot hledger 0.21.3 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.21.3 (SimonMichael)
17:06:48 <arkeet> hmm.
17:06:53 <arkeet> haddock blows up when faced with singletons.
17:08:23 <NihilistDandy> Yeah, thy mention that on the hackage page. Not sure why it does that
17:08:26 <NihilistDandy> *they
17:08:39 <arkeet> heh.
17:10:05 <arkeet> so why do we have Any, again?
17:10:17 <arkeet> someone said something about Dynamic.
17:10:58 <shachaf> Are you talking about the kind Any or the type Any?
17:11:15 <arkeet> the type Any :: k
17:11:21 <arkeet> I didn't know there was a kind Any
17:11:35 <shachaf> Wait, no, I mixed up what I said.
17:11:57 <arkeet> I mean the thing that inhabits every kind.
17:11:58 <shachaf> Hmm, what do I mean?
17:12:22 <shachaf> I mean the type (of kind *) that you can unsafeCoerce to and from safely.
17:12:36 <arkeet> is that any different?
17:12:54 <elliott> shachaf: that type is actually of every kind.
17:13:14 <shachaf> Ah.
17:13:19 <shachaf> OK, so they're the same thing.
17:13:27 <shachaf> But those seem like two unrelated purposes?
17:13:28 <arkeet> in any case it's the one we don't like.
17:17:35 <Aetherspawn> What's more prefferable; Word8 and Int8 for unsigned and signed respectively
17:17:44 <Aetherspawn> or UInt8 and Int8
17:18:24 <troydm> i think Word8 and UInt8 are one and the same
17:18:28 <troydm> but i'm not sure
17:18:40 <troydm> there might be some difference i'm not aware of
17:18:49 <Aetherspawn> Oh, I wasn't talking about existing types
17:19:02 <elliott> Word8 and Int8 already exist
17:19:02 <Aetherspawn> I was talking about naming new types :) do you prefer consistency of UInt/Int or Word/Int
17:19:52 <troydm> UInt/Int obv
17:20:10 <troydm> coming from a C background
17:21:09 <monochrom> Nat and Int
17:21:17 <NihilistDandy> ^
17:22:46 <arkeet> you mean
17:22:48 <arkeet> Nat and Integer
17:23:30 <monochrom> "unsigned integer" is like "unendianed computer". clearly, every integer is signed (plus or minus), every computer is endianed (big or small)
17:26:55 <geekosaur> ...because "unsigned" for "does not have a sign bit" is totally not standard terminology
17:32:40 <Aetherspawn> What do you call a signed Byte
17:32:57 <monochrom> if it's going to be a standard pissing game, "natural number" is even more standard, and longer
17:33:08 <monochrom> s/longer/earlier/
17:34:36 <monochrom> but I'm not interested in standard pissing games. a suggestion for naming is requested, and I said my perspective. it is not clear to me the only metric is "docile to standards"
17:36:23 <arkeet> clearly it should be called ℕ
17:36:49 <arkeet> it's even more standard and interlingual, and harder to type.
17:37:17 * geekosaur isn't interested in them either, especially when they involve trying to use the wrong class of terminology (since of course theoretical math is the only valid class, so we must call it a natural number mod-256 because it's improper to bring the facts of actual implementation into description of a value specifically targeting an actual implementation)
17:37:19 * ion adds orphan instances for Arbitrary a => Arbitrary (Tagged t a) and Arbitrary DiffTime to his code and feels sad.
17:37:35 <geekosaur> or whatever the proper abstract terminology is obligated to be
17:37:44 <arkeet> the only difference between Word8 and Int8 is in the ordering, really.
17:37:59 <ion> arkeet: And the Show and Read instances. :-P
17:38:11 <arkeet> yes, and the stuff that can be exposed with UnsafeCoerce, and ...
17:38:15 <arkeet> unsafeCoerce
17:38:35 <monochrom> why so hostile?
17:39:04 <Aetherspawn> ;__;
17:39:19 <arkeet> unsafeCoerce (-1 :: Word8) :: Word32 → 255
17:39:19 <arkeet> unsafeCoerce (-1 :: Int8) :: Word32 → -1
17:39:22 <monochrom> and why be the first one to bring up standards and then say not interested in standard pissing games?
17:39:41 <arkeet> hmm, should have used Word64.
17:40:40 * Aetherspawn wasn't really asking anything specifically related to Haskell at all, but computer science terminology in general.
17:40:51 <Aetherspawn> sorry if it sounded like I was having a go at the standards D:
17:41:46 <arkeet> I can't really answer the original question because I don't know what the names are supposed to be for.
17:42:41 <arkeet> but more people are probably comfortable with "uint" than "word"
17:43:29 <finishingmove> i just created a simple one-liner program, but it seems calling the function "main" is not allowed. why is that?
17:43:47 <arkeet> finishingmove: can you explain more what you are doing?
17:43:54 <arkeet> show the code, and how you are running it. etc
17:44:01 <monochrom> show actual code. "main" works for me all the time
17:44:09 <arkeet> (main isn't a function, btw.)
17:44:14 <finishingmove> arkeet: so, i have a *.hs file
17:44:35 <arkeet> @hpaste is useful.
17:44:35 <lambdabot> Haskell pastebin: http://hpaste.org/
17:45:23 <hpaste> “Anonymous Coward” pasted “asd” at http://hpaste.org/90322
17:45:32 <finishingmove> ^
17:45:34 <arkeet> well, main has to be an IO action.
17:45:38 <finishingmove> i try to do
17:45:42 <arkeet> what you wrote is a number, not an IO action.
17:45:44 <finishingmove> :l myfile.hs
17:45:55 <arkeet> ok, do that, and then try :t main
17:45:57 <finishingmove> yea so main is reserved or what?
17:46:17 <arkeet> oh.
17:46:18 <finishingmove> if it's named "main", :l myfile.hs will fail with error
17:46:19 <arkeet> I guess so.
17:46:35 <finishingmove> what i was trying to achieve was
17:46:36 <arkeet> but your main problem is that main is supposed to be an IO action.
17:46:47 <monochrom> main has to be an IO action, such as main = putStrLn "hello"
17:46:49 <finishingmove> that it executes immediately after i :l it
17:46:56 <arkeet> well, you can't do that.
17:47:08 <monochrom> ghci does not do that
17:47:20 <arkeet> you can runghc it if you just want to run the program without compiling separately.
17:47:20 <finishingmove> oh well then
17:47:38 <arkeet> if you want the program to print a number, use something like the print function.
17:47:52 <NihilistDandy> It won't execute at all. The type of main is just wrong
17:47:59 <arkeet> if you just want to see the number in ghci, just call it something other than main.
17:48:03 <NihilistDandy> main = print $ (that thing you wrote)
17:48:35 <arkeet> (I did not know, btw, that ghci didn't like non-IO things called main.)
17:48:55 <NihilistDandy> I don't think it cares if it's in a module called something other than Main
17:48:56 <monochrom> well, Haskell 98 and Haskell 2010 don't like it
17:48:57 <NihilistDandy> I'm not sure
17:49:12 <NihilistDandy> But files without a module name are module Main by default
17:49:14 <arkeet> oh.
17:49:20 <monochrom> yes, if the module name isn't Main, it is happy
17:49:22 <arkeet> you're right
17:49:40 <finishingmove> good to know
17:50:20 <NihilistDandy> finishingmove: If you stick something like "module Test where" at the top of your file, it should load, I think
17:50:34 <NihilistDandy> Or just change main to another name
17:50:49 <arkeet> I recommend the latter.
17:51:15 <NihilistDandy> Yeah, getting into the habit of having anything other than main :: IO () can't be a good idea
17:51:21 <finishingmove> yeah i just changed it
17:51:32 <finishingmove> i didn't know it was reserved like that
17:51:39 <arkeet> me either.
17:51:51 <NihilistDandy> It's not really reserved, it just looks for a function called main in the module Main
17:52:09 <arkeet> I don't know why it would do that.
17:52:26 <NihilistDandy> Historical reasons?
17:52:30 <NihilistDandy> Hysterical reasons?
17:54:27 <ion> Opinions, please. timeAdd :: RelTime -> AbsTime -> AbsTime or timeAdd :: AbsTime -> RelTime -> AbsTime?
17:55:20 <NihilistDandy> ion: AbsTime -> RelTime -> AbsTime, I guess? I dunno, neither quite feels good.
17:55:49 <elliott> ion: use vector-space or whatever instead.
17:55:53 <elliott> or linear or something?
17:55:59 <ion> elliott: Thanks, i’ll take a look.
17:56:10 <elliott> like http://hackage.haskell.org/packages/archive/linear/1.1.4/doc/html/Linear-Affine.html.
17:56:15 <elliott> linear is probably better since edwardk.
17:59:31 <ion> elliott: Looks good, thanks.
18:00:17 <elliott> ion: great. my usual fee applies. also the royalties
18:00:25 <ion> elliott: Naturally.
18:00:31 <shachaf> elliott *is* royalty
18:03:30 <jmcarthur> elliott: Linear.Affine is actually my doing, and edwardk just merged it in. i say that not for credit but to defend edwardk when it is discovered that it is not up to par :)
18:04:02 <shachaf> Linear.Affine sounds like a contradiction.
18:04:06 <elliott> jmcarthur: and lens is actually the work of a highly-trained team of gnomes.
18:04:19 <elliott> such are edwardk's cost-cutting measures these days
18:04:31 <jmcarthur> elliott: i am a mere cog!
18:04:43 <shachaf> I hain't a gnome! I'm a gnu!
18:05:05 <monochrom> and I am a unity
18:05:39 <hpc> you are all wrong
18:05:53 <hpc> shachaf is shachaf, monochrom is a lack of color, and i am a testing library
18:07:11 <monochrom> hahaha, we must be in a mad house
18:07:13 <hpc> and elliott is conal
18:07:26 <carter> WOAH
18:07:29 <carter> MIND BLOWN
18:08:01 * jmcarthur is still a cog
18:08:14 <carter> jmcarthur a proprietary cog!
18:09:24 <Hafydd> The world is so monochrome, isn't it?
18:30:38 <finishingmove> does anyone know what a *.hs~ file means?
18:31:12 <Hafydd> finishingmove: it's probably a temporary file created by your text editor.
18:31:29 <finishingmove> ok
18:43:31 <geekosaur> emacs names its backup files like that
18:44:09 <Fuuzetsu> Silly defaults.
18:45:46 <NihilistDandy> Except for the ones that it names #whatever#, for some reason that I can't imagine
18:46:08 <shachaf> unboxed
18:46:23 <shachaf> It really messes with your filesystem.
18:46:34 <geekosaur> those are its autosave files
18:46:39 <NihilistDandy> Unboxed backups are just so much closer to the metal, man
18:51:19 * hackagebot shelly 1.1.0.0 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.1.0.0 (GregWeber)
19:12:53 <ksf>  (TypedLambda exp, Repr a, Repr b) =>(exp a -> exp b) -> exp (a -> b)
19:12:58 <ksf> what should I call that function?
19:13:30 <ksf> \f -> lam "x" $ \x -> f x
19:21:54 <b2coutts> I find myself at an impasse going through LYAH; I want to go through the tutorial before doing anything significant so I don't teach myself to do things the wrong way, but I find myself forgetting material from past chapters, since I don't have the chance to apply them in an actual program
19:22:25 <carter> b2coutts its ok to start off slightly wrong
19:22:32 <carter> thats what the type checker is for
19:23:24 <b2coutts> carter: yeah, but I worry about writing correct code that is still horrible in terms of style, and creating bad habits
19:23:27 <ksf> b2coutts, you'll remember then when they come up, again.
19:23:28 <Raynos> Could someone explain what `>>` desugars to?
19:23:36 <elliott> m >> n = m >>= \_ -> n
19:23:39 <ksf> b2coutts, that's going to happen no matter what you try...
19:23:44 <elliott> but it can be overriden for a given monad more efficiently.
19:24:10 <Raynos> so for example if a given monad was not order specific it could do both m and n in arbitrary order?
19:24:13 <b2coutts> ksf: I find this is an issue, though; for example, while learning about newtype right now I find that I've forgotten a lot of the finer points about types in general
19:24:18 <b2coutts> also some of the less fine points
19:24:19 <carter> b2coutts style changes
19:24:34 <carter> you'll learn and occasionally go "OHHHHH," and then change your habits
19:24:42 <b2coutts> I suppose
19:24:43 <carter> haskell style a fluid living thing
19:24:45 <ksf> you haven't even scratched the surface of types, yet.
19:24:46 <carter> with multiple good styles
19:25:02 <carter> theres MANY good yet very different styles for writing haskell code
19:25:17 <ksf> learnyouahaskell is supposed to get you started, there's way more to learn.
19:25:23 <b2coutts> right now I'm just thinking "I don't know what monoids, monads, or several other things are, but these are probably essential tools"
19:25:24 <carter> that make vSO MUCH MORE
19:25:30 <carter> b2coutts you can punt for now
19:25:34 <carter> youll learn by using
19:25:36 <ksf> b2coutts, that's what the typeclassopedia is for
19:25:36 <b2coutts> and writing a non-trivial program without them may be silly
19:25:39 <carter> not by dictionary definitions
19:25:50 <carter> b2coutts nope, you can write lots of stuff thats not general
19:25:58 <carter> you'll learn to out of laziness :)
19:26:06 <ksf> b2coutts, on the contrary, writing it without is the best way to re-invent them.
19:26:11 <carter> yes
19:26:14 <ksf> and re-inventing is the best way to learn.
19:26:16 <carter> fact
19:26:21 <carter> sad but awesome fact
19:26:46 <b2coutts> hmm, that may be true
19:26:48 <ksf> @quote premature
19:26:48 <lambdabot> ksf says: ...premature generalisation is the root of all procrastination.
19:27:08 <carter> I'm a master premature procrastinator
19:27:35 <b2coutts> the project I was sort of thinking of doing once I learned enoug haskell was implementing an irc client; would this be reasonable to do without having learned monoids/monads? (just finished applicatives in lyah)
19:27:52 <ksf> you'll need to do lots of IO
19:28:07 <b2coutts> (also, I'd accept better suggestions for learning haskell projects)
19:28:17 <ksf> in the end, do anything you want because you're going to throw that code away, anyway.
19:28:21 <Demos> honestly everything needs lots of IO
19:28:30 <ksf> do something you're familiar with.
19:28:32 <carter> b2coutts yes
19:28:39 <carter> you'll jsut want to rewrite it later :)
19:28:53 <ksf> that's either limited in scope or well chuckable into small components that you can tackle.
19:29:00 <b2coutts> yeah, that makes a lot of sense, actually
19:29:16 <ksf> combinatorrent was written that way
19:29:19 <b2coutts> I shouldn't care that the code I write will be bad, as long as I'm tackling something sufficiently large that it forces me to use what I've learned
19:29:25 <ksf> (and proves that you can write erlang in haskell)
19:29:26 <carter> yes
19:29:44 <carter> it wont be as fast or extensible or awesome as you'd like, but it'll work
19:29:52 <carter> and you'll have learned along the way
19:29:54 <orzo> I have an amd64 machine, and it's occcured to me i need to build a 32bit binary of one of my haskell programs.  Well i had a 32bit chroot laying around anyway, so i installed ghc there, but my home directory is shared even though i changed root.
19:29:59 <orzo> Will it be a problem for cabal?
19:30:17 <orzo> i use cabal to install haskell libraries and i think it makes use of my home directory for all its state
19:30:32 <ksf> gah. pretty-printing my de bruijn indices by carrying along name,s and now everything is named "x".
19:30:38 <orzo> (man does ghc make this inconvenient)
19:30:41 <shachaf> orzo: No.
19:31:02 <orzo> shachaf: it wont be a problem? how not?  arent there 64 bit binaries in my home that it will try to link?
19:31:03 <shachaf> Well, at least, things go in places like ~/.ghc/x86_64-linux-7.6.3
19:31:10 <orzo> i see
19:31:42 <Saizan> orzo: you want $arch in your install-dirs though, for libraries
19:31:53 <Saizan> orzo: in ~/.cabal/config
19:32:06 * Saizan doesn't know if that's the default
19:32:31 <orzo> i don't see $arch anywhere in my .cabal/config
19:33:16 <orzo> a lot of lines in my config start with --
19:33:22 <orzo> are those being ignored?
19:33:36 <Saizan> yes, those are the defaults
19:33:48 <Saizan>   libsubdir: $pkgid/$compiler/$arch
19:33:56 <Saizan> that's my custom libsubdir
19:34:01 <orzo>  libsubdir: $pkgid/$compile
19:34:34 <orzo> well i already have been doing a lot of amd64 compiling and i dont want to goof up my libraries
19:34:38 <orzo> paths
19:34:57 <Saizan> it won't break old builds
19:35:09 <Saizan> because ghc-pkg will remember where they are
19:35:33 <Saizan> it'll make sure your 32bit ones don't overwrite the 64bit and vice-versa in the future though
19:36:16 <orzo> so i change this file and i dont have to rename any directories to match it?
19:36:27 <Saizan> the thing is that cabal decides where to put the files, then tell that to ghc-pkg and in the future asks ghc-pkg for the info
19:36:30 <Saizan> orzo: right
19:37:30 <orzo> i feel some trepidation heh
19:40:35 <orzo> maybe the 32bit system should use .cabal32 or something as it's an entirely different system with only the kernel shared and version mismatches are not unlikely
19:41:27 <Saizan> i'm using this same setup with no problems
19:44:01 <orzo> is libsubdir the only one i need to change?
19:44:39 <orzo> where else do you put $arch?
19:47:07 <Saizan> only there
19:50:03 <Saizan> i assume that what can be shared between compilers can be shared between archs too, worked fine for now
19:52:39 <n_b> I'm currently following the Write Yourself a Scheme tutorial and having a bit of trouble grasping the function of liftM. I've looked at the type signature and take it as it pulls out the wrapped value, operates on it, and then rewraps and returns the value?
19:53:22 <byorgey> n_b: that's actually not a good way to think about it.  there may not be a "wrapped value" (there may be none, or multiple, depending on the monad)
19:53:33 <byorgey> n_b: it takes a function and 'lifts' it so it operates in the context of the monad
19:53:44 <ion> n_b: If liftM operates on something that happens to be a container or a wrapper for a single value, that’s accurate.
19:54:01 <byorgey> n_b: e.g. consider   liftM :: (Int -> Int) -> (Maybe Int -> Maybe Int)
19:54:04 <n_b> byorgey: e.g. if ti was Maybe
19:54:17 <n_b> byorgey: Ah, yea, you beat me to it.
19:54:30 <byorgey> n_b: in fact, most monads do not just have a single wrapped value.
19:55:19 <byorgey> n_b: in the case I pasted above, the way you should think of it is that liftM takes a 'normal' (Int -> Int) function, and 'lifts' it to operate in a Maybe context, that is, in a context with possible failure
19:55:49 <byorgey> the new function  (Maybe Int -> Maybe Int)  works by propagating failure and performing the Int -> Int operation in the case of success.
19:56:02 <byorgey> (because that's how the Maybe monad works.)
19:57:10 <byorgey> n_b: as in this case, liftM is often some sort of 'mapping' operation.
19:57:19 <byorgey> in fact, for the list monad,  liftM = map
19:57:59 <arkeet> fmap = liftM
19:58:00 <n_b> byorgey: OK, I believe I follow; still having a bit of trouble parsing type signatures and just going back and forth between your explanation and my reference - but it is at least moderately clearer now
19:58:18 <ion> > liftM (+50) Nothing
19:58:20 <lambdabot>   Nothing
19:58:23 <ion> > liftM (+50) (Just 100)
19:58:25 <lambdabot>   Just 150
19:58:29 <shachaf> Any explanation of Monad/Functor/etc. that talks about "wrapping" is a misleading one.
19:58:56 <arkeet> how about "producing"
19:59:14 <n_b> byorgey: I think I'm going to just forge ahead and see how it operates in the context of other monads.
19:59:34 <Gracenotes> probably 'augment' isn't bad.. 'wrap' otoh implies 'unwrap'
19:59:47 <arkeet> what about "producing"
19:59:59 <shachaf> Gracenotes: id :: Int -> Int is an "augmented" Int?
20:00:06 <shachaf> arkeet: In a vague sort of sense, yes.
20:00:11 <arkeet> yes
20:00:23 <shachaf> arkeet: The sort of sense that you have when "producing" means "covariant". :-)
20:00:27 <arkeet> yes.
20:00:33 <n_b> The exact phrasing is "operate on the value inside the monad", which implies the application of a function to a value within the context of something else - I'm more at fault than the tutorial here I think
20:00:37 <arkeet> otoh comonads are also covariant.
20:00:48 <shachaf> n_b: That phrasing is misleading. :-(
20:00:51 <shachaf> In multiple ways.
20:01:07 <Gracenotes> shachaf: Int -> Int is a bit of an augmentation of Int, sure
20:01:18 <aoshi> yikes
20:01:24 <shachaf> One is that it suggests that a monad is a value -- e.g. (Just 5) is "a monad" -- when it's really a type constructor -- e.g. Maybe is a monad.
20:02:33 <arkeet> is there something universal about the State monad, I wonder.
20:02:47 <Gracenotes> Int is a type argument to (Int->). Only in that sense.
20:03:28 <shachaf> Right.
20:03:48 <shachaf> OK, the type is "augmented", sure. I'm not sure how much intuition that word really gives you.
20:05:15 <Gracenotes> I'm not sure what anything is anymore
20:05:20 <orzo> Something is amiss; requested module  template-haskell-2.7.0.0:Language.Haskell.TH.Ppr differs from name found in the interface file template-haskell:Language.Haskell.TH.Ppr
20:05:21 <Aetherspawn> > tail [1..5]
20:05:22 <lambdabot>   [2,3,4,5]
20:05:27 <orzo> i'm screwed
20:05:39 <shachaf> orzo: You have multiple versions of template-haskell. Don't.
20:05:40 <Gracenotes> can you verb types? is there anything other than 0s and 1s in the CPU?
20:05:57 <orzo> i didnt on purpose, obviously
20:05:59 <orzo> cabal did it to me
20:06:07 <orzo> i just requested HList
20:06:09 <shachaf> Yes. Tell cabal not to do it.
20:06:29 <orzo> well tell cabal what exactly
20:06:37 <orzo> which template haskell do i want?
20:06:44 <S11001001> shachaf: "a Monad is an object whose methods return monads"
20:06:49 <arkeet> S11001001: no.
20:07:19 <Gracenotes> what's an object
20:07:29 <S11001001> something in javascript, I think
20:08:02 <shachaf> S11001001: a monad is a monad whose monads monad monads
20:08:09 <shachaf> There, now we're done.
20:08:12 <ion> Buffalo buffalo monad
20:08:27 <Demos> I quite liked eric lippert's monad tutorial
20:09:58 <Gracenotes> eh, objects
20:10:07 <Gracenotes> if only I had a dime for every time I were given a dime
20:10:14 <S11001001> am pretty sure this is edwardk's preferred definition
20:11:42 <Demos> I suppose they are like really smart continuations
20:12:35 <Demos> but as a general rule listening to me is a bad idea
20:12:56 <exFalso1> a monad is just a toroid in the allegory of kendo-hunters
20:13:04 <shachaf> What?
20:13:27 * shachaf suggests that monad jokes are off-topic in here.
20:13:47 <Demos> I thought haskell was a monad for writing monad tutorials?
20:13:48 <S11001001> aww
20:14:04 <Gracenotes> oic
20:14:04 <shachaf> S11001001: There are other channels.
20:14:13 <S11001001> I suppose, shachaf.
20:26:51 <b6> hspec shouldReturn seems really awkward. what i'd like to do is more like x <- foo and do several assertions on x.
20:29:38 <ion> I take it QuickCheck isn’t what you want?
20:30:20 <b6> ion: no, i'm testing C bindings. lots of IO.
20:30:48 <ion> QuickCheck works fine for testing IO (in case you want the random input).
20:31:03 <b6> yeah, i just mean it's not appropriate to generate arbitrary cases.
20:31:17 <ion> alright
20:46:21 * hackagebot time 1.4.1 - A time library  http://hackage.haskell.org/package/time-1.4.1 (AshleyYakeley)
20:55:40 <joelteon> is it possible to document function arguments inside record fields?
20:56:18 <Gracenotes> type synonyms?
20:56:37 <joelteon> ?
20:56:40 <joelteon> no
20:56:43 <Gracenotes> though you probably mean more literally. I dunno
20:56:48 <joelteon> data Foo = Foo { unFoo :: a -> b }
20:56:50 <Gracenotes> ignore me
20:56:54 <joelteon> i'll put something on hpaste
20:57:59 <hpaste> joelteon pasted “lots of haddocks” at http://hpaste.org/90325
20:58:05 <joelteon> haddock fails parsing on line 4
20:58:07 <joelteon> at ->
20:58:09 <monochrom> I don't think haddock gets that far
20:58:46 <joelteon> "parse error on input '->'"
20:58:53 <joelteon> well, `->'
20:59:39 <monochrom> I don't think it is supported
20:59:44 <joelteon> rats
20:59:57 <shachaf> Giving bad answers to vague questions trains people to ask better questions! It is not wasted effort.
21:00:06 <shachaf> But, yes, I don't think this is supported either.
21:00:55 <ryant5000> is there a version of Data.Map where the key is a type constructor whose argument is the value type? i.e.: Map :: (* -> *) -> *, with lookup :: Ord1 k => k v -> Map1 k -> Maybe v
21:01:08 <ryant5000> (or something similar)
21:01:19 <shachaf> ryant5000: There is Vault...
21:01:27 <shachaf> @hackage vault
21:01:27 <lambdabot> http://hackage.haskell.org/package/vault
21:02:21 <ryant5000> shachaf: hm; is there something i'm missing about why this needs to be in IO?
21:02:32 <monochrom> also, I don't think HTML is supported either
21:02:58 <ryant5000> i mean, the type safety of the map would depend on differently-typed keys not being equal, but aside from that, it seems like a reasonable thing to me...
21:03:03 <ryant5000> being pure, that is
21:03:23 <shachaf> ryant5000: IO or something like it is needed to make keys.
21:03:54 <shachaf> Which is exactly to avoid the thing you said.
21:04:04 <shachaf> Nothing else needs IO. Only newKey.
21:05:02 <ryant5000> shachaf: hm; unfortunately, for my use case, i don't have IO,  but i do know how to tell differently-typed keys apart reliably. maybe i'll just write something
21:05:33 <shachaf> ryant5000: You can use ST with Vault too.
21:05:43 <shachaf> There are also other Vault-like things.
21:06:05 <shachaf> elliott had some sort of relevant primitives, I think.
21:07:37 <ryant5000> shachaf: looks like this may get the job done: http://hackage.haskell.org/packages/archive/dependent-map/0.1.1.1/doc/html/Data-Dependent-Map.html
21:09:43 <NemesisD> is there something i need to do to get ghci to make available my cabal project's modules? tried using cabal-ghci and ghci -isrc and it doesn't seem to find my modules
21:10:04 <NemesisD> does it matter that my cabal file only specifies executables?
21:10:27 <b6> NemesisD: yeah, that's important. what could ghci do? there are no modules.
21:10:45 <b6> i guess you could make a library section in your cabal and expose them there.
21:11:02 <NemesisD> b6: is there some way to specify exposed modules in an executable?
21:11:20 <b6> NemesisD: i'm not sure, but i don't think you can.
21:11:21 * hackagebot gloss 1.7.8.4 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.8.4 (BenLippmeier)
21:11:30 <augur> opine plox: http://purelytheoretical.com/Programming/RegularExpressionsAnd(Bi)Zippers.pdf
21:11:45 <b6> NemesisD: i mean, if it's a library, there should be exposed modules. if it's an executable .. what are the modules for?
21:11:57 <monochrom> for the executable
21:12:12 <b6> monochrom: no, that'd be an executable that uses some library.
21:12:20 <b6> maybe you should split it up like that.
21:12:32 <b6> if part of your project could stand alone as a library, make it a library.
21:13:11 <NemesisD> hmm, maybe other modules
21:13:39 <NemesisD> b6: none of the project could stand alone as a library but it would still be nice to experiment with the internals while develping it
21:14:36 <b6> NemesisD: i think you could ghci the sources directly, but if there are dependencies, i think you have to specify them somehow. it wouldn't be super nice.
21:14:59 <NemesisD> i kinda thought that's how ghci worked as long as you specified -isrc, it would just be able to load the files in the directory tree
21:15:16 <NemesisD> b6: yeah i ran into that, choked on the first dependency when i loaded the file
21:16:04 <dmwit> NemesisD: You should only need to follow GHC's module -> file mapping.
21:16:23 <dmwit> e.g. with -isrc, module Foo.Bar.Baz should go in src/Foo/Bar/Baz.hs
21:16:34 <dmwit> and should have "module Foo.Bar.Baz" at the top.
21:16:53 <NemesisD> dmwit: yep, following that convention. what about dependencies though?
21:16:59 <dmwit> What about them?
21:17:20 <augur> dmwit: opine plox!
21:17:21 <augur> http://purelytheoretical.com/Programming/RegularExpressionsAnd(Bi)Zippers.pdf
21:17:21 <augur> :D
21:17:44 <NemesisD> dmwit: could i explicitly specify an explicit package db? i'm using cabal sandbox
21:17:55 <dmwit> I don't see why not.
21:18:18 <JoeyA> In a program compiled without -threaded, is it reasonable to assume that all Haskell code in the program will run in the same OS thread?
21:18:31 <JoeyA> as if main was run from a forkOS
21:18:35 <monochrom> yes
21:18:41 <JoeyA> Goody
21:18:46 <shachaf> JoeyA: forkOS is not about Haskell code, it's about FFI code.
21:18:50 <monochrom> well, forkOS is somewhat different
21:19:06 <dmwit> JoeyA: main is always run from a forkOS, -threaded or no
21:19:06 <JoeyA> Indeed, I am pondering something FFI related
21:19:11 <monochrom> I mean somewhat unrelated
21:19:56 <monochrom> ok, without -threaded, the story is very simple. every C call stops the Haskell world. end of story.
21:20:07 <dmwit> (To be specific, main is always a bound thread. It's an implementation detail whether this is actually achieved with forkOS or not, of course. But forkOS doesn't promise anything more than handing you a bound thread.)
21:21:22 * hackagebot io-choice 0.0.5 - Choice for IO and lifted IO  http://hackage.haskell.org/package/io-choice-0.0.5 (KazuYamamoto)
21:21:47 <monochrom> actually, maybe not end of story. what if C side decides to fork an OS thread, and inside that OS thread calls Haskell? I don't know. you aren't supposed to do that without -threaded anyway
21:22:07 <Fuuzetsu> Does there not exist a ‘map’ that exists for structures more general than lists?
21:22:41 <dmwit> augur: What is the problem that this solves?
21:22:41 <tabemann> fmap does that
21:22:42 <Demos> yes there does! it is called fmap
21:22:46 <Demos> and it works for all functors
21:22:51 <NemesisD> dmwit: eureka! it worked!. its a little bit clunky. i suppose i could add a makefile with a ghci task, i'd have to figure out a way to reliably detect the package db dir
21:22:57 <Demos> actually until haskell98 it was just called map
21:23:18 <augur> dmwit: its just an example of how to use a regex directly to do matching, in the more-or-less same way as a transition-table version
21:23:31 <Fuuzetsu> fmap was refusing co-operation… I'll try again I guess
21:23:49 <JoeyA> monochrom: I think you're right.  atomicModifyIORef skips the barrier thingy for non-threaded RTS, IIRC.
21:23:50 <Demos> you need to have a functor
21:23:52 <dmwit> augur: You should figure out what problem you are trying to solve.
21:24:08 <Demos> if you hav esomething that is a monad but not a functor you can either make it a functor or use mapM
21:24:11 <augur> dmwit: er.. "recognizing regexes"?
21:24:12 <dmwit> augur: (But note that "nobody has observed this elegant description of an old solution" is a perfectly good problem to solve.)
21:24:21 <NemesisD> i might just make a Rakefile instead, make to me is as torturous as shell scripting when you have to do anything remotely interesting
21:24:24 <dmwit> augur: Nah. Recognizing regexes is a solved problem.
21:24:42 <augur> dmwit: yes well, ok, but so what
21:24:47 <augur> new takes on old problems
21:24:57 <Demos> hm I prefer shell scripting for many tasks, also, I dont want to need ruby just to compile my program!
21:25:05 <dmwit> Are perfectly good, yes. But you should still figure out why your new take is a good idea.
21:25:08 <dmwit> That's all I'm saying.
21:25:38 <dmwit> Suppose I had never read your paper. What would you say to convince me it was a good use of my time to read it?
21:26:11 <augur> dmwit: i should write an intro, you're saying. :P
21:26:15 <dmwit> (Other than the obvious thing that worked here, which was a social reason to read it.)
21:26:23 <dmwit> augur: I'm saying, yes. =)
21:26:43 <augur> dmwit: thats the intention! im more worried about the 90 other paragraphs right now tho :P
21:26:55 <dmwit> augur: But that's not all. When you figure out what problem you are solving, it can really guide *how* the rest of the paper is written.
21:27:37 <Fuuzetsu> Is there a technical reason for why Haskell doesn't allow something like ‘foo (A b) = bar’ and on the next line ‘foo = id’, assuming that the types match up?
21:27:50 <dmwit> Yes, there is.
21:27:55 <dmwit> ...but it's hard to remember.
21:28:09 <Demos> haskell does not really have the notion of evaluation order does it?
21:28:15 <dmwit> The short version being that it's not obvious that there's the same number of arrows in some of the inferred types when the equations have different numbers of variables.
21:28:37 <dmwit> I think there's a good Stack Overflow question with a crisp answer. Let me see if I can find it.
21:29:27 <tabemann> Fuuzetsu: I remember running into that when writing my red-black tree code
21:29:33 <monochrom> the Haskell reports don't specify evaluation orders. each compiler has to decide on one. usually it's lazy evaluation.
21:30:01 <dmwit> Fuuzetsu: http://stackoverflow.com/q/8745597/791604
21:30:11 <Fuuzetsu> ta
21:30:25 <dmwit> Demos: Well, there are some constraints on what orders can be used.
21:30:40 <dmwit> e.g. you can't use strict evaluation everywhere and be a Haskell
21:30:47 <dmwit> (though you can be another, similar language =)
21:31:10 <Demos> is that just because infinate structures?
21:31:13 <Gracenotes> https://xkcd.com/541/
21:31:50 <monochrom> also because "const True undefined" should give you True instead of bomb
21:32:09 <monochrom> this one is pretty uninfinite
21:32:18 <Fuuzetsu> Meh, hardly a satisfying answer. In the end it's just because how it's implemented under the hood.
21:32:23 <Gracenotes> Haskell's evaluation order is any that fits in its denotational semantics
21:32:45 <dmwit> Fuuzetsu: ...not really?
21:32:55 <dmwit> \x y -> undefined and undefined are different
21:32:59 <dmwit> and you want them to be different
21:33:05 <Gracenotes> Fuuzetsu: if you want a language that allows everything but still doesn't let you say much, look at C++ :)
21:33:19 <dmwit> have to run
21:33:30 <dolio> You don't actually want those to be different.
21:33:43 <dolio> If they both have the same type.
21:34:22 <Fuuzetsu> I could make a dirty hack in TH but at that point I might as well be using C++
21:34:31 <Gracenotes> Haskell is hesitant about allowing things that make sense, but muck up the semantics for no good reason
21:34:33 <Demos> well to be fair saying: well such and such is lazy because a || undefined is a little pointless, since pretty much everyone allows that
21:35:17 <Demos> c++ has a lot on its hands to be a """"modern"""" language that can still compile most valid C code
21:35:30 <Gracenotes> likewise, if you want a language totally free from caring about efficient implementation details or evaluation models, I would recommend Prolog
21:35:35 <Demos> but it is a little like trying to start a fire with a square wheel
21:35:51 <ksf> hmm is it even possible to type the reduction of simply typed lambda calculus in haskell?
21:35:59 <ksf> without UndecidableInstances or such, I mean.
21:37:48 <joelteon> i think the clang update involved with xcode5 introduced some breaking changes in cpp
21:37:50 <Gracenotes> (see also n+k patterns)
21:37:55 <monochrom> for the record: I was not talking about "a || undefined". at all.
21:38:03 <ksf> I can imagine how to code up say a type family to check whether a bound variable is free in a term, but getting the right return type out of that is going to be at least tricky.
21:38:55 <tabemann> n+k patterns was a bad idea to begin with considering how, in theory, + for a given type could have arbitrary semantics
21:39:09 <Demos> yeah I know but I was saying that lazy evaluation is in most languages, at lease a bit
21:39:49 <Gracenotes> though you have to work harder to split up the work if you want laziness in many other languages
21:40:16 <monochrom> I am not going to argue over that. I only care about this:
21:40:50 <monochrom> (\ x _ -> x) True undefined. does this give True or does it bomb?
21:40:56 <Gracenotes> (that's just a software engineering concern, not a specification concern)
21:41:50 <monochrom> in particular I am very carefully using user-defined (\x _ -> x). user-defined function. not built-in. "||" is built-in in most languages. I don't care about built-ins. I care about user-defined functions.
21:42:21 <dolio> The user-defined part is the whole thing.
21:42:23 <monochrom> built-ins can of course do all kinds of magics and niceties. what about user-defined functions?
21:42:33 <dolio> Ask the ML people why they're always writing their recursion explicitly all over the place.
21:42:50 <dolio> Instead of factoring it out into combinators.
21:42:57 <monochrom> if a language says that my user-defined functions are castrated, then I'm castrated, end of story.
21:43:26 <tabemann> (\x _ -> x) True undefined evaluates to True according to GHCi
21:44:26 <monochrom> yes tabemann. the context is "what about other languages?"
21:45:28 <tabemann> most other languages I've found usually have "special" stuff hacked in that you cannot really implement with your own functions (e.g. how numbers work in Standard ML, or how comparison works in OCaml)
21:46:28 <Gracenotes> dolio: well, ML people do use a lot of foldr and map, I've found
21:46:36 <Demos> yeah I like haskell's support for really doing whatever you like, even if nobody thought of it when they wrote the spec. I mean sure you can do the same in C but then you get GObject
21:46:39 <Gracenotes> but it might just be for things they were going to evaluate anyway
21:47:51 <tabemann> Demos: but then there's things that the Haskell 98 spec simply doesn't allow, without extensions, e.g. the space of functions not allowed without ScopedTypeVariables
21:48:06 <dolio> Not for anything that wants to stop early, for instance.
21:48:41 <dolio> Unless they're using a lot of () -> t or something.
21:48:44 <ksf> Demos, I know one without.
21:48:53 <ksf> No lazy evaluation, at all.
21:49:22 <ksf> Io. The one out of the finkel book
21:50:14 <Demos> well I was going to extend that with "if you cant then you can write a GHC extension"
21:50:55 <Gracenotes> dolio: and continuations, for that matter
21:51:22 * hackagebot unix-time 0.1.9 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.1.9 (KazuYamamoto)
21:52:40 <dolio> I can only think of one class of functions that absolutely require scoped type variables, and they're pretty bizarre.
21:53:12 <ksf> "require" is one thing, "be convinient" is another.
21:53:30 <shachaf> dolio: What class?
21:53:37 <solrize> hey if i want to bone up on enough topology to understand what the hell homotopy type theory is about, 1) where do i look, 2) is the whole plan worth pursuing?
21:54:00 <dolio> shachaf: You need to write a local polymorphic recursive function, which requires a type signature, but that type signature references variables in an outer scope.
21:54:23 <tabemann> I don't see what's bizarre about that
21:54:35 <NemesisD> anyone know if its intended behavior that cabal configure --enable-tests; cabal install --only-dependencies doesn't install test dependencies?
21:54:35 <dolio> Of course, you never _need_ to write a local function.
21:54:37 <shachaf> dolio: Hmm, do you have a particular example of a function that can't be written without the extension?
21:55:13 <dolio> No, but it should be easy to contrive one.
21:55:14 <tabemann> dolio: but when you write such a function, you're usually referencing a value in the outer scope; to break it out you'd have to pass that in as a separate parameter
21:56:01 <monochrom> the GHC user's guide probably has an example
21:56:06 <dolio> Polymorphic recursion is relatively rare, and it's even rarer that you'd need a custom locally defined function that uses it.
21:57:08 <tabemann> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#scoped-type-variables
21:57:49 <monochrom> hrm, its examples are of the convenience kind
21:57:53 <tabemann> hmm I've seen better examples for it than that
21:58:01 <solrize> i remember some slightly concocted ocaml example used it
21:58:18 <Gracenotes> polymorphic recursion, like you might see in e.g. map?
21:58:40 <Gracenotes> not sure how polymorphic is meant here
21:58:44 <dolio> No.
21:58:47 <shachaf> Gracenotes: No, recursion where a polymorphic function uses itself at a different type than the one it was called with.
21:58:55 <tabemann> the key thing is that the examples that scoped type variables makes possible shouldn't be forbidden, i.e. they are a space of functions that are impossible in Haskell 98 when they really shouldn't be
21:59:15 <shachaf> Does "space" mean something here?
21:59:55 <Gracenotes> I was thinking of a function bound in a where clause that you want to specify a specialized type for some of its arguments
22:00:00 <monochrom> the Haskell reports have an example of polymorphic recursion
22:00:06 <dolio> Does OCaml even have polymorphic recursion?
22:00:20 <tabemann> shachaf: should I have used a different word?
22:00:24 <dolio> I don't think SML does.
22:00:32 <Gracenotes> is a reasonable use, if you choose to do so using a type signature for that function
22:00:42 <Gracenotes> but obviously not a necessary one
22:01:22 <shachaf> dolio: Can you actually contrive an example of a function that you can't write without the extension?
22:01:23 <dolio> I know it didn't at the time Okasaki wrote his book.
22:02:45 <dolio> Give me a few minutes.
22:02:49 * tabemann is pretty sure he's seen an example of something requiring scoped type variables, but now he can't remember where he saw it
22:03:07 <solrize> > let ntuple n x = (iterate (\a -> (a,a)) x !! n) in ntuple 3 1
22:03:08 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = (t0, t1)Occurs check...
22:03:18 <dolio> I doubt you saw one that really couldn't be written any other way.
22:04:58 <Gracenotes> having type signatures for where clauses taking function-type-signature-declared polymorphic variables is more useful for other programmers than for the compiler, likely
22:05:19 <dmwit> dolio: Hm, I thought I really did want (\x y -> undefined) and (undefined) to be different (even if they have the same type), because that means I get to have some control over things like memoization.
22:05:26 <dmwit> Can you say why you don't want them to be different?
22:05:30 <Gracenotes> ST is an example where these things get complicated...
22:05:42 <dolio> Because eta laws are better.
22:05:44 <Gracenotes> and expressive power isn't all that it's cracked up to be; sometimes you want expressive limits
22:05:48 <shachaf> dmwit: I suspect the things dolio wants are much less operational than that. :-)
22:06:02 <dmwit> eta laws are complicated. What makes them good?
22:06:30 <dmwit> shachaf: That's fine. But I'd like to hear what those things are.
22:06:44 <dolio> Ask shachaf why lens jumps through a bunch of dumb hoops because GHC can't eta reduce things in the optimizer.
22:07:05 <dolio> Because it's a semantics breaking optimization.
22:07:16 <dolio> That saves asymptotic amounts of work.
22:07:23 <shachaf> dolio: I hear that's fixed in HEAD!
22:07:35 <shachaf> Well, by "fixed" I mean that you can just use strict composition instead of (.) and GHC will optimize it.
22:07:38 <shachaf> I haven't tested it yet.
22:07:44 <dolio> That still sucks.
22:07:54 <shachaf> Yep.
22:08:05 <shachaf> Much better than 124 unsafeCoerces, though.
22:08:07 <monochrom> strict composition! I haven't heard of that. :)
22:08:34 <shachaf> monochrom: Strict composition is required if you want (.) to have an identity.
22:08:48 <shachaf> Otherwise (f . id) is not the same as f when f is ⊥.
22:09:43 <Gracenotes> putting the weak in WHNF, eh
22:10:06 <dmwit> shachaf: Why does lens jump through a bunch of dumb hoops?
22:10:14 <shachaf> dmwit: Ask dolio.
22:10:18 <dmwit> =(
22:10:24 <monochrom> <<loop>>
22:10:33 <dolio> shachaf: http://hpaste.org/90326
22:11:06 <dolio> Every time you compose with a newtype (un)wrapper, you get something that looks like \x -> f x
22:11:40 <dolio> And lens does a lot of stuff where that kind of thing happens O(n) times. Or at least a lot of times.
22:11:48 <mjrosenb> shachaf: can you give an example of that?
22:11:52 <dolio> And GHC doesn't get to optimize any of that.
22:12:05 <dolio> So instead they unsafeCoerce, I think.
22:12:43 <shachaf> mjrosenb: Functions with one of those types like data Tree a = Leaf a | Branch (Tree (a,a)), I guess?
22:12:47 <shachaf> mjrosenb: Unless I'm mixed up.
22:12:50 <dolio> And in HEAD, maybe they'll just write the equvalent of 'f `seq` \x -> f x'. Which is using seq to paper over the fact that seq breaks the optimization in the first place.
22:12:54 <Gracenotes> that's the issue where 'map runFoo' or 'map Foo' aren't identity to GHC at any stage, yes
22:13:13 <shachaf> Gracenotes: That's a different (but related) issue.
22:13:16 <Gracenotes> despite evaluation being the same if they were just skipped
22:13:30 <shachaf> It's not true for e.g. Data.Set.map Foo.
22:13:50 <mjrosenb> shachaf: right, but can you write a function that generates a Tree with 2^n a's in it without using typeclasses?
22:13:59 <dmwit> dolio: Hm, interesting.
22:14:09 <dolio> shachaf: If you remove the signature on bar you get an occurs check.
22:14:29 <shachaf> dolio: Right. The trick I was hoping to use wouldn't work here.
22:14:34 <Gracenotes> shachaf: in what way is it different?
22:14:48 <Gracenotes> you worried about the Ord dictionary there? ...hum
22:14:58 <dolio> shachaf: If we had partial signatures, you could use that instead.
22:15:04 <dmwit> dolio: I see, the problem is that it's \x -> f x in the version of the code where newtype wrappers/unwrappers don't exist, but not in source Haskell. Is that right?
22:15:06 <Gracenotes> @hoogle Data.Set.map
22:15:07 <lambdabot> Data.Set map :: Ord b => (a -> b) -> Set a -> Set b
22:15:07 <lambdabot> Data.Set mapMonotonic :: (a -> b) -> Set a -> Set b
22:15:07 <lambdabot> package bimap
22:15:31 <dmwit> dolio: e.g. in source Haskell it's still \x -> (un)Wrapper (f x), which can't be eta-reduced.
22:15:44 <dolio> dmwit: In one class of examples, at least.
22:15:46 <shachaf> mjrosenb: Yes, I think. But anyway almost any function that you would write for that type would use polymorphic recursion?
22:16:00 <dmwit> That's pretty subtle.
22:16:17 <shachaf> @google ghc strict composition with id
22:16:21 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/7542
22:16:21 <lambdabot> Title: #7542 (GHC doesn't optimize (strict) composition with id) – GHC
22:16:39 <dolio> dmwit: There was another bug a while back where all derived instances of Functor and Traversable and such would eta expand their arguments on every iteration, too.
22:16:49 <shachaf> dolio: That bug is still in 7.6.3. :-(
22:16:58 <dolio> That wouldn't have been a problem if the optimizer could just reduce it.
22:17:01 <shachaf> Fixed in HEAD, thankfully.
22:17:20 <dmwit> Still, it seems like a tradeoff to me.
22:17:23 <mjrosenb> shachaf: well, there are trivial functions, but i've heard that you can't do it without typeclasses, so you can return a single type.
22:17:25 <shachaf> That bug is really annoying because it turns the derived fmap from linear to quadratic.
22:17:29 <dmwit> You get to choose between two bad choices.
22:17:51 <mjrosenb> shachaf: I may be misinformed, but until I see a function, I won't believe it
22:18:59 <shachaf> mjrosenb: yap :: (a -> b) -> Tree a -> Tree b; yap f (Leaf x) = Leaf (f x); yap f (Branch t) = Branch $ yap (\(x,y) -> (f x, f y)) t
22:19:17 <dolio> dmwit: Maybe you didn't mean the same thing I did by those things being different.
22:19:20 <shachaf> mjrosenb: Or are we talking about different things here?
22:19:42 <dolio> dmwit: I meant observably distinguishable. Right now they're only distinguishable via seq.
22:19:54 <dolio> Semantics-wise.
22:20:02 <shachaf> @google ghc trac traversable inefficient
22:20:04 <dolio> That's what makes the optimization invalid.
22:20:04 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/7436
22:20:04 <lambdabot> Title: #7436 (Derived Foldable and Traversable instances become extremely inefficien...
22:20:14 <dmwit> Is seq not an observation?
22:20:27 <dolio> It is.
22:20:36 <dolio> Why do you want to seq functions?
22:21:41 <dmwit> For example, to precompute a lookup table...?
22:23:34 <monochrom> if you have the bad luck of choosing to implement a lookup table by a huge function, seq won't help you precompute it
22:24:06 <dolio> I mean, I can think of examples where it'd precompute some things.
22:24:25 <mjrosenb> shachaf: I feel like I should be able to run yap (:[]) (Leaf 1)
22:24:49 <shachaf> mjrosenb: Sure.
22:25:01 <mjrosenb> oh, it is complaining about missing show
22:25:04 <mjrosenb> derp.
22:25:06 <mjrosenb> I think?
22:25:11 <shachaf> Yes, you can add deriving Show to test it.
22:25:14 <shachaf> But yap is an example of polymorphic recursion.
22:25:19 <dolio> Like, you do something like 'let expensive = ... in expensive `seq` \x -> ... expensive ...' where you can only subsequently precompute 'expensive' by seqing the function.
22:25:22 <mjrosenb> indeed.
22:25:43 <mjrosenb> shachaf: I was thinking of something like gen :: Int -> a -> Tree a
22:25:53 <dolio> I don't know that I've ever seen someone do that.
22:26:37 <dmwit> I guess that's fair. Almost everywhere I can think of that uses memoization tables critically uses the fact that the memoization is lazy.
22:27:24 <dolio> Well, actually, I've seen one example of someone doing that, and it was in a paper Ed pointed me to when I brought this up with him.
22:27:45 <mjrosenb> isn't non-lazy memoization basically dynamic programming?
22:27:48 <dolio> I think the time savings there was probably pretty small in practice, though.
22:28:13 <shachaf> mjrosenb: What's the issue?
22:28:35 <dolio> Because you don't need seq to share work, just to get it to happen earlier than first invocation, and maybe to get GHC to optimize the function calls slightly better.
22:28:39 <shachaf> gen n makes a tree with 2^n values in the leaf, right?
22:28:51 <shachaf> Like this? gen :: Int -> a -> Tree a; gen 0 x = Leaf x; gen n x = Branch $ gen (n - 1) (x,x)
22:29:42 <dmwit> shachaf: (I'm guessing he means 2^n different values? Not really sure.)
22:29:52 <shachaf> dmwit: gen :: Int -> a -> Tree a ?
22:29:53 <dolio> I suspect eta expansion is a far more ubiquitous performance sink, though.
22:30:06 <mjrosenb> nope,
22:30:06 <dmwit> shachaf: Well, his claim was that you needed a typeclass and couldn't do it without.
22:30:15 <mjrosenb> it would appear as if I am just full of shit.
22:30:27 <shachaf> dmwit: Anyway I think that's possible too.
22:30:42 <shachaf> mjrosenb: Trickier functions for this tree type are things like taking the "left subtree".
22:30:43 <dmwit> shachaf: I will admit I haven't been following very closely, though.
22:30:45 <dolio> Like, if you ever have a function like '\f ... -> ... (f . g) ...' that gets inlined to a site with f = id.
22:31:10 <shachaf> dolio: Should (.) be strict composition, assuming seq continues to exist?
22:31:40 <shachaf> (Or maybe just strict in the first argument or something?)
22:31:56 <shachaf> That really shouldn't affect anyone except pedants.
22:31:57 <dolio> Maybe, although I don't really like blessing it.
22:32:24 * luminous kicks pootler_1 
22:32:34 <Gracenotes> no pootling allowed
22:33:02 <Gracenotes> also, in the olden days I might be concerned about a massive /names flood or something...
22:33:22 <Gracenotes> if there were different source ips, anyway
22:33:57 <dmwit> If pedestrian should obstacle your way, pootle melodiously.
22:36:54 <dolio> People also tend not to even think about the cost of f vs \x -> f x.
22:37:24 <dolio> It's the kind of thing you almost expect to be costless.
22:37:39 <OxGOOSE_> What's the cost?
22:37:54 <shachaf> As exemplified by 7436, which puzzled SPJ for a while until spelled out.
22:38:13 <dolio> It was kind of a surprise to me when they realized the derived functor instances were like O(n^2).
22:38:34 <shachaf> Yep.
22:39:58 <Gracenotes> assuming f is unknown, here, yeah
22:40:36 <Gracenotes> ...it's a kind of meta-syntactic variable like that though... yeah
23:02:05 <mikeplus64> i tried adding instances for the typeclasses in Linear for Data.Vector.Storable but to do so i'd have to either pass around the type's Storable definition manually (e.g data StorableVector a = SV { st :: Data.Vector.Storable.Vector a, sizeOf :: Int, peek, poke, ... }) or add a constraint to everything which is impossible since a lot of linear stuff depends on base's Functor/Foldable/Traversable :(
23:05:26 <KSkrzet> how do I draw some text in Gloss?
23:05:54 <Breadmonster> Where do I find a good tutorial on Parsec?
23:05:58 <Breadmonster> For a total n00b?
23:06:43 <shachaf> So what do people mean when they say rank-2 types are inferrable?
23:08:04 <dolio> They mean there's some hairy algorithm for it that no one uses.
23:08:18 <shachaf> OK, but what does that mean?
23:08:27 <shachaf> Does it infer a type for (\x -> x x)?
23:08:38 <dolio> Dunno.
23:08:41 <shachaf> You can encode existentials with rank-2 types. Does it infer a type for those?
23:09:16 <dolio> xplat mentioned once that there's a connection with intersection types.
23:09:48 <Breadmonster> shachaf: That fails.
23:09:51 <shachaf> Is there a paper or something about this hairy algorithm?
23:09:53 <Breadmonster> Occurs check: cannot construct the infinite type: t1 = t1 -> t0
23:10:07 <dolio> And all 'ranks' of intersection types can be inferred, but things go off the rails for polymorphism.
23:10:08 <shachaf> It doesn't fail when you give it a particular rank-2 type signature.
23:10:13 <dolio> I might have the paper somewhere.
23:10:21 <Breadmonster> Also, how is it that Haskell can infer recursive types, but Scala can't?
23:11:24 * hackagebot lio 0.11.0.0 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.11.0.0 (DeianStefan)
23:11:42 <dolio> shachaf: Look for: A Direct Algorithm for Type Inference in the Rank 2 Fragment of the Second-Order Lambda Calculus.
23:13:50 <c_wraith> Breadmonster: type inference is basically impossible in the presence of subtyping.  Because of that, scala just sort of gives up on all but the easiest cases.
23:14:16 <zvrba> whye does subtyping make inference impossible?
23:15:22 <c_wraith> same reason typeclasses break it sometimes - insufficient information to determine which type something actually is, but needing the specific type to implement it.
23:18:57 <Breadmonster> c_wraith: What's subtyping?
23:20:14 <c_wraith> https://en.wikipedia.org/wiki/Subtyping
23:20:16 <Breadmonster> c_wraith: After googling, I don't get what the actual difference between subtypes and typeclasses is.
23:20:55 <c_wraith> The difference is that a typeclass is a property of a type, but it doesn't imply any relationship between different types that implement it.
23:21:06 <Xunie> Anyone ever done algorithmic composition in Haskell?
23:21:21 <c_wraith> Whereas with subtypes, you claim that the subtypes are in some sense the same type as the thing they're a subtype of
23:21:57 <c_wraith> Or at least you can use a subtype where the parent type is expected.
23:28:09 <Breadmonster> But does Scala use the same type inferrence system?
23:31:57 <c_wraith> I couldn't say what it actually uses. It's certainly *way* more limited than hindley-milner
23:34:10 <Breadmonster> Hmm.
23:34:33 <Breadmonster> Implementing HM type inference for Scala might seem like a fun undertaking.
23:34:39 <Breadmonster> Perhaps for Google Summer of Code.
23:39:05 <isomorphic> if I do newtype Foo = mkFoo Int , I can create a new Foo with Foo 3 - but I cannot use a type annotation to say ( 3 :: Foo) unless I also have a Num instance.    Why do I need a Num instance in the second case?
23:39:39 <isomorphic> (err.  that should read "mkFoo 3")
23:41:19 <Gracenotes> (3 :: Foo) is just (fromInteger (3 :: Integer) :: Foo)
23:41:38 <shachaf> newtype Foo = mkFoo Int is a syntax error.
23:41:41 <Gracenotes> mkFoo also isn't a good constructor name, it having a lowercase letter
23:41:45 <Gracenotes> at start
23:41:55 <shachaf> newtype Foo = MkFoo Int is probably what you meant.
23:42:07 <shachaf> Why do you expect (3 :: Foo) to work?
23:42:12 <shachaf> I recommend not using numbers.
23:42:23 <shachaf> Use something else, like characters.
23:42:27 <shachaf> newtype Bar = MkBar Char
23:42:32 <shachaf> Do you expect ('a' :: Bar) to work?
23:43:01 <Gracenotes> numbers are also a bit weird, because of fromInteger (and fromRational)
23:43:29 <isomorphic> Gracenotes:  That makes sense
23:43:46 <Gracenotes> still, it can be better to be explicit than implicit here
23:44:06 <isomorphic> shachaf:  Yes, I expected 'a' :: Bar might work
23:44:39 <isomorphic> Gracenotes:  So, really what I'm seeing, I gather, is fromInteger's requirement for Num
23:44:39 <Gracenotes> if you're looking to annotate a type without changing its behavior with Num, etc., 'type' rather than 'newtype' might be better. they are different.
23:44:41 <dmwit> If you do type Baz = Char, then 'a' :: Baz will work.
23:45:00 <shachaf> isomorphic: Then Num is a red herring.
23:45:21 <shachaf> isomorphic: The only way to make a Bar will involve the constructor MkBar, somehow.
23:45:25 <shachaf> MkBar :: Char -> Bar
23:45:46 <shachaf> Char and Bar aren't the same type, so you can's use 'a' (which has type Char) with the type Bar.
23:46:48 <dmwit> The question is: given "blah TypeA = TypeB", do you want the typechecker to tell you when you have mixed up a "TypeA" for a "TypeB" or vice versa? If so, s/blah/newtype/; otherwise, s/blah/type/.
23:47:29 <Gracenotes> third option, add blah as Haskell keyword and write a heuristic to give you what you want.
23:47:41 <Gracenotes> em... yes... right.
23:48:26 <dmwit> ...oh yeah, and add a constructor for newtypes. =P
23:48:41 <isomorphic> dmwit:  Is blah a type constructor?
23:49:01 <dmwit> isomorphic: I was using "blah" to stand in for either "type" or "newtype".
23:49:07 <isomorphic> dmwit: Oh, wait, i see
23:49:14 <isomorphic> thanks: Got it now
23:49:23 <Hafydd> Then #haskell-blah would become an on-topic channel.
23:49:41 <Gracenotes> what is the difference between Foo and Int
23:49:48 <Gracenotes> then, is the idea
23:49:57 <dmwit> relevant to your name: "newtype" is used for declaring a new type which is isomorphic (but not equal) to an old one
23:49:59 <isomorphic> Hafydd:  Is there some way we can get the set of sets that don't contain themselves into it?
23:51:40 <Hafydd> "In #haskell-blah, you may talk about all channels in which meta-channel discussion is not allowed."
23:52:47 <isomorphic> Hafydd++
23:53:26 <isomorphic> Thanks very much for the explanations everybody :)
23:53:32 <Gracenotes> it is true
23:57:36 <akegalj> hi all. I have maybe not haskell related question. I have 51Mb data file on filesystem. Now, that data can be read into haskell via readFile (String, Text, ByteString) under 10 seconds. If i split same data on 100,000 files on my filesystem data is 400Mb big (i suppose some filesystem file overhead) but problem is reading this data takes 20m (when not cached) which is 120x slower then reading the same data in one file. I would guess becaus
23:58:10 <shachaf> Cut off: same data in one file. I would guess becaus
23:59:00 <isomorphic> akegalj:  Repaste your text after 'becaus'
23:59:00 <akegalj> shachaf: yes, some data in one file
23:59:09 <akegalj> ok...
23:59:38 <akegalj>  the same data in one file. I would guess because of filesystem overhead reading would
23:59:41 <akegalj>                  take 400Mb/50Mb = 8x slower + maybe more couse data on disk may not be fragmanted but taking that long seems odd. Is this
23:59:44 <akegalj>                  expected behaviour?
