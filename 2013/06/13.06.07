00:35:00 <hrookie> is there a nifty way for "cabal init" to automatically generate dependencies i have in my project for me?
00:39:31 <johnw> I think that's a bit more complicated of a task than you might be thinking
00:39:41 <johnw> multiple packages can define the same module, even the same functions
00:40:42 <johnw> now, I suppose could build a tool that runs cabal configure/build multiple times, and every time GHC says that you are using a hidden package, auto-inserts that package into the dependency list and tries again
00:40:47 <johnw> i've been meaning to write something like that for a while
00:40:55 <startling> doesn't cabal init already guess?
00:41:03 <johnw> does it?
00:41:07 <mikeplus64> yeah
00:41:07 <startling> I thought it did.
00:41:10 <johnw> i've never used it on existing code
00:41:11 <johnw> cool!
00:41:30 <hrookie> Ooo okay. Yeah. Something is fishy with my mint install.
00:43:13 <hrookie> thanks~
00:51:14 <alpounet> i've created most likely something like 50 or 60 cabal packages
00:51:36 <alpounet> but have never run "cabal init" on existing code
00:51:45 <alpounet> either
00:52:00 <johnw> the thought never occurred to me, actually
00:52:11 <johnw> since "init" doesn't seem to imply "convert to cabal"
00:52:53 <startling> yeah, I was very surprised when I cabalized some uncabalized code
00:56:11 <bz> argh
00:57:18 <bz> "show (+) 4 3"
00:57:26 <bz> vs. "show $ (+) 4 3"
00:57:50 <bz> i know oeprator precedence is at play here, but what does the first even mean?
00:58:08 <Walther> > show (+) 4 3
00:58:09 <kappabot>   The function `GHC.Show.show' is applied to three arguments,
00:58:09 <kappabot>  but its type `...
00:58:35 <bz> oh oh
00:58:56 <bz> so it passes (+) as the first arg to show, 4 as the second, 3 as the third
00:59:50 <shachaf> Something like that.
00:59:59 <shachaf> (Except in fact all functions take just one argument, of course.)
01:00:58 <bz> right, currying
01:07:30 <startling> bz, so it passes 3 as the argument to "show (+) 4"
01:07:51 <startling> (or it would if there were not a type error there)
01:08:19 <TravisD> when I run the tests that come with hmatrix I get a segfault during the unit tests. How might I go about finding the problem? (I'm on Mac OS and I use homebrew, if that makes a difference)
01:08:56 <bz> startling: and strings aren't callable
01:28:40 <Ndit> hi dont ban me i hope someone moved the records being modules forward 0.0001% in their mind and thoughts
01:29:26 <startling> "records being modules"?
01:30:03 <Ndit> yes the module system should be more abstracted to not just work on the file level
01:30:39 <startling> um, alright.
01:30:53 <Ndit> what problems do you see with records being modules?
01:32:32 <sopvop> Why not "modules are records"?
01:33:12 <Ndit> sopvop, sure that's different, and is nice for reflection
01:33:34 <Cale> Why not "modules are modules"? We already have modules, damn it.
01:33:54 <Ndit> but records are modules is for keeping names in modules
01:34:47 <Ndit> Cale, well, modules are modules, is fine, if you can make N modules per file, except that just causes the programmer to write doublesyntax if they are moduling a record
01:34:59 <Cale> The main difference between records and modules is that there are sorts of declarations that you can put into modules which you cannot put into records.
01:35:19 <Cale> If Haskell were dependently typed, maybe that would be a different thing.
01:35:41 <startling> oh, that's a good point.
01:35:44 <Cale> We could just say records = modules and introduce some syntax for opening a bunch of records in a given scope.
01:35:52 <startling> in any case, it wouldn't make sense for classes.
01:36:16 <sopvop> I thought classes are not needed in dependently typed languages
01:36:28 <Cale> Also, records in Haskell are typed, and modules are not.
01:36:45 <Cale> (modules in Haskell aren't values)
01:37:05 <Cale> sopvop: They are, but they tend to be implemented poorly imo.
01:37:14 <startling> sopvop: correct, but afaict there's usually a "get the class instance for this class for this type" magic function/macro
01:37:20 <Ndit> being unable to put things into records that you can put into modules -- i don't mean a 1:1 definition of module, but rather the parent of module. a module is a moduleunit, a record is a moduleunit
01:37:50 <startling> Ndit: it's really hard to get what you're saying.
01:38:08 <sopvop> I think he says ML
01:38:38 <Ndit> startling: merging the hierarchy of all things that "contain" something into 1 system
01:38:51 <Cale> At least, in both Coq and Idris, the instance resolution mechanism will make different decisions based on the syntactic order in which you define instances, which sucks.
01:39:45 <Cale> It just uses the solver that gets used for implicit arguments, which tends to be much more aggressive than one would want for type classes' open world assumptions.
01:41:09 <Cale> Ndit: Anyway, purely from a concrete syntax standpoint, I already hate explicitly qualifying identifiers as it is, and adding another reason to need to would basically suck.
01:41:30 <Cale> (at least, from my personal taste)
01:41:47 <Ndit> that's fixed in 1 minor word of syntax or a single operator or something
01:42:03 <sopvop> If only there was a way to specify which instance to use. newtyping everything sucks.
01:42:12 <Cale> I would much rather that modules simply try not to step on each others' toes as far as naming identifiers goes, and only use explicit qualified names as a last resort.
01:42:14 <Ndit> anonymous records vs moduled records
01:42:20 <Ndit> anonymous ones splat their stuff into the outer module
01:42:35 <Ndit> you could have a single operator make the distinction
01:42:47 <startling> Ndit, that makes no sense.
01:43:01 <Ndit> and then it would not hurt you Cale if you chose to not write that character
01:43:07 <Ndit> startling: Which part?
01:43:29 <startling> "splat their stuff into the outer module"
01:43:34 <Ndit> As they do currently.
01:44:06 <Cale> Ndit: You should write some code in the language that you're suggesting, in order to make it clear what you're really after.
01:44:12 <Ndit> its easy to describe: haskell supports N modules per file. they can be nesting. If you prefix a certain operator before a record, it creates a module of the same name as recordtype surrounding the record
01:44:16 <Ndit> otherwise they splat out as usual
01:44:18 <Cale> Ndit: and maybe try implementing it
01:44:56 <Cale> Ndit: It's not *so* hard to write a small interpreter for a Haskell-like language, and you could experiment with these ideas you have and see if you can find others who like them.
01:46:11 <Cale> Ndit: In practice, the problems with Haskell's record types are not problems with namespacing at all though.
01:46:25 <Cale> Ndit: (and I say this as someone who writes Haskell code professionally)
01:46:47 <Ndit> yah when you write  foo_x foo_y  you made a module in identifiers
01:46:57 <Ndit> theres no real difference except a bunch of lines of code
01:47:04 <Ndit> in the type system of ideas it is the same
01:47:16 <Cale> Ndit: The main thing I would fix with records, is that the field names currently refer to field extractor functions, rather than to lenses.
01:48:04 <Ndit> Cale the thing you'd fix and that i'd fix can work together
01:48:05 <Cale> Any namespacing concern you have with records is easily solved by prepending the name you would be qualifying the field names with to the field names themselves.
01:48:16 <fruitFly> how to fix main method? I'm trying to convert the hex to Base64 and back http://ideone.com/b3Xmht
01:48:22 <Ndit> Cale: that was foo_
01:48:26 <Ndit> foo_ is a module.
01:48:33 <Ndit> I don't care about implementation
01:48:41 <Ndit> and language design saying they are different
01:48:41 <Cale> Ndit: Why does it even have to be? You can already do that.
01:48:56 <Ndit> Cale: foo_ is a manual effort
01:49:09 <vlatkoB> I'm looking at a monad parser example from YAHT and saw this signature that I can't understand.
01:49:09 <vlatkoB> It looks like the function signature is curried:
01:49:09 <vlatkoB> char :: Char -> Parser Char
01:49:09 <vlatkoB> char c = Parser char'
01:49:09 <vlatkoB>   where char' [] = ...
01:49:10 <vlatkoB>   
01:49:11 <Cale> fruitFly: looking
01:49:11 <vlatkoB> Shouldn't the signature be
01:49:13 <vlatkoB> char :: Char -> String -> Parser Char
01:49:23 <sopvop> fruitFly: in just case "base" would be String, in Nothing case it's a (). You need them to match
01:49:28 <Cale> vlatkoB: Nope
01:49:57 <nooodl> "return (bytesToBase64 bytes)" should probably be "print", not "return"
01:50:21 <Cale> fruitFly: returning stuff from main is kind of pointless
01:50:23 <vlatkoB> Cale: "Nope" means signatures can be curried
01:50:41 <Cale> vlatkoB: How is Parser defined?
01:51:05 <vlatkoB> It is a Monad and MonadPlus
01:51:12 <fruitFly> Cale: I'm still a noob, I'm just trying to pass input through the four function defined at the top. Not sure the easiest way to do that.
01:51:13 <Cale> nono, its data declaration
01:51:38 <Cale> fruitFly: Maybe you want to do some output, like instead of return, you could use print there
01:51:51 <Cale> (in main)
01:51:51 <vlatkoB> newtype Parser a = { runParser :: String -> Either String (String,a)}
01:51:53 <sopvop> fruitFly: base <- case ....  what type should base be?
01:52:16 <fruitFly> sopvop: a string
01:52:29 <Cale> fruitFly: print "Invalid hex, sorry!" :: IO ()
01:52:33 <Cale> fruitFly: and () is not String
01:52:40 <sopvop> Right
01:52:47 <Cale> you could use error for that error as well
01:52:59 <sopvop> :t error
01:53:00 <kappabot> forall a. [Char] -> a
01:53:24 <fruitFly> Cale: print "Invalid hex, sorry!" :: IO () ? what does that do
01:53:27 <Cale> vlatkoB: More likely  newtype Parser a = Parser { runParser :: String -> Either String (String, a) }
01:53:35 <Cale> fruitFly: I'm just telling you what the type is
01:53:52 <fruitFly> Cale: ok
01:53:56 <Cale> fruitFly: So the result of that action has type (), an empty tuple, rather than a String
01:54:04 <sopvop> fruitFly: You should really read Learn You a Haskell
01:54:08 <Cale> fruitFly: But that result is what would be bound to base
01:54:33 <_vlatkoB> Cale: Yep, missed it while looking at source
01:54:37 <flebron> Hi. Knowing that the input format is going to be about 40MB of very long Integers, separated by whitespace, what can I do to improve the runtime of http://hpaste.org/89471 ? I can't use Data.ByteString.Lazy.Builder, unfortunately, since the platform does not support it.
01:54:48 <Cale> _vlatkoB: So, this defines two things for you:
01:55:15 <Cale> _vlatkoB: A data constructor   Parser :: (String -> Either String (String, a)) -> Parser a
01:55:21 <fruitFly> Cale: I don't get it, what is the relationship between the Just and Nothing clause when returning, they have to be the same type?
01:55:32 <Cale> _vlatkoB: And a field extractor  runParser :: Parser a -> (String -> Either String (String, a))
01:55:55 <Cale> fruitFly: All the branches of a case have to be the same type
01:56:15 <_vlatkoB> Cale: Yes, I know that, but I do not understand how can a signature be curried. Haven't seen that before
01:56:20 <Cale> :t (\x -> case x of Nothing -> (4,7); Just v -> "hi there")
01:56:21 <kappabot>     Couldn't match expected type `(t0, t1)' with actual type `[Char]'
01:56:21 <kappabot>     In the expression: "hi there"
01:56:21 <kappabot>     In a case alternative: Just v -> "hi there"
01:56:53 <Cale> fruitFly: ^^ see? That doesn't work, because the case expression as a whole has to have one type.
01:57:30 <_vlatkoB> Cale: char :: Char -> Parser Char means 1 input Char and 1 output Parser Char
01:57:42 <Cale> _vlatkoB: That's right
01:57:47 <_vlatkoB> But there are tow inputs
01:57:48 <fruitFly> Cale: I just changed print "Invalid hex" to error "Invalid hex" and it's working. Can I string be returned alongside an error like this? http://ideone.com/b3Xmht
01:58:01 <Cale> _vlatkoB: So this function takes a character, and produces a parser which parses a character from its input
01:59:10 <_vlatkoB> Oh, I see. It is a definition of the function that returns parser that is curried, and that parser will receive its arguments later. Correct?
01:59:19 <Cale> _vlatkoB: That is, given the character c, the parser  char c  will look to see if the first character in its input is c, and if so, will accept the string and produce c as its result, and the rest of the string as the depleted input.
01:59:27 <Cale> and if not, then it will fail
01:59:46 <Cale> The parser itself will contain a function for eating a String
01:59:59 <Cale> (in fact, it pretty much consists of just that)
02:00:13 <nooodl> @hoogle String -> Maybe a -> Either String a
02:00:20 <lambdabot> No results found
02:00:26 <_vlatkoB> Yes, I understand now. Thanks for leading me. :-)
02:00:41 <fruitFly> Cale, it seems I can return that string when the nothing clause is an error. That's normal and allowed, correct?
02:02:01 <tdammers> flebron: have you tried splitting the `f` function into separate functions? one for parsing the integers, one for doing the summing, and one for printing the result?
02:02:28 <flebron> I tried a pass of map (fst . fromJust . C.readInteger) before calling f on a [Integer], but it was still too slow :(
02:03:07 <tdammers> see if you can eliminate the `reverse`
02:03:30 <Cale> fruitFly: yes
02:03:36 <Cale> fruitFly: error :: String -> a
02:03:50 <tdammers> I'm not entirely sure, but I have a feeling that it causes the entire list to be evaluated at once, which would mean that you're allocating a multiple of 40MB at once
02:03:53 <tdammers> and then process that
02:04:03 <fruitFly> hey.. I think I've finished the implementation of challenge #1, it may not be the prettiest and most efficient solution but I think it's logically sound:t error
02:04:07 <flebron> Well, I can do that, but only by calling putStr many times.
02:04:08 <Cale> fruitFly: Evaluating an expression (error x) is like going into an infinite loop, except that it ends more quickly.
02:04:14 <fruitFly> woop.. didn't mean to type that
02:04:28 <tdammers> flebron: are you sure?
02:04:40 <fruitFly> :t error
02:04:48 <lambdabot> [Char] -> a
02:05:23 <tdammers> I mean, you have a list of words, then you map it to a list of Integers, from there you rearrange it into a list of pairs of Integers, then you map \(x,y)->x+y over that, and then you print the result line-by-line
02:06:06 <flebron> I can skip the pairs though, right?
02:06:13 <flebron> By just matching on (x:y:z).
02:06:16 <tdammers> sur
02:06:18 <tdammers> sure
02:06:41 <tdammers> but you want to eliminate the reverse, because it requires evaluating the entire list spine at once
02:06:58 <tdammers> this means that if you have a million integers, you'll be reversing a million thunks
02:07:12 <tdammers> (or rather, a list containing a million thunks)
02:07:56 <tdammers> so if you can do the take-two-and-add with a map instead, you'll be able to skip the reverse
02:08:11 <tdammers> it'll all be streaming, so it should then run in constant space
02:08:16 <flebron> http://hpaste.org/89471
02:08:24 <flebron> That is what I was using, and it's too slow :(
02:09:41 <Ndit> If you had to implement Haskell (and it is going to be Haskell) but you were not allowed to have it be any slower than C: How much of the language would you have to remove?
02:10:05 <kryft> fruitFly: What challenge are you talking about?
02:10:41 <fruitFly> kryft: matasano security challenge
02:11:02 <fruitFly> kryft: http://www.matasano.com/articles/crypto-challenges/
02:11:06 <flebron> tdammers: Maybe some BangPatterns somewhere?
02:12:10 <tdammers> flebron: that last version uses an individual `print` for each value
02:12:16 <flebron> Right.
02:12:17 <tdammers> not sure if that makes any difference
02:12:33 <kryft> fruitFly: Thanks, looks interesting
02:12:38 <tdammers> it's hard to decide where to go here, though, without knowing where the bottleneck is
02:12:50 <flebron> Definitely IO, there's not much else going on :p
02:12:54 <johnw> Ndit: Haskell is a language, not an implementation, it doesn't make sense to ask whether parts of Haskell are fast or slow; that's up to the compiler and its optimization passes
02:13:24 <t7> @check ((a * b) + c) == ((a * c) + b)
02:13:25 <lambdabot>   Not in scope: `myquickcheck'
02:13:29 <t7> bums
02:14:45 <t7> why is agda asking my to prove that
02:14:55 <t7> i am doing something very wrong
02:15:02 <fruitFly> kryft: ya, it's fun so far. The first challenge was to create a hex to base64 converter and back--not operating on encoded strings but on raw byte values (i.e. Word8), and the next challenge is to implement the xor function ... it's been fun, especially while learning haskell :)
02:15:19 <tdammers> johnw: I think it's fair to assume GHC here
02:15:42 <johnw> tdammers: GHC is always improving, so if he's asking about GHC 7.6.3, then that's another story
02:16:02 <tdammers> sure. Still, the language semantics do suggest certain performance pitfalls.
02:16:11 <johnw> such as?
02:16:20 <tdammers> building up excessive thunks
02:16:45 <johnw> that's an operational detail; I don't believe the Haskell report says how you have to implement non-strictness
02:17:12 <tdammers> I was under the impression that strictness/laziness requirements were rather well-defined
02:17:59 <tdammers> e.g., you can expect take 10 [1..] to not crash
02:18:12 <tdammers> (or go into an infinite recursion)
02:18:39 <simon> does anyone know how I automatically enable haskell-indentation-mode when haskell-mode is enabled?
02:19:06 <johnw> tdammers: the words "lazy" and "laziness" occur in the Haskell 2010 report exactly once each
02:19:09 <simon> (I'm in Emacs, sorry. it appears that (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation) doesn't do it.)
02:19:14 <johnw> the word "strict", however, is everywhere
02:19:34 <johnw> non-strictness is an aspect of the language, laziness is an implementation of it
02:19:45 <tdammers> hmm, ok
02:20:09 <johnw> and GHC implements laziness with thunks; I'm not aware offhand of other ways to do it, but I'm sure there probably are some
02:20:47 <tdammers> the only one I can think of is some kind of JIT code analysis that can toss out thunks that it knows will never be evaluated anyway
02:20:55 <johnw> right
02:20:58 <Cale> Ndit: That's sort of an ill-posed question. Haskell code rarely, but occasionally runs faster than comparable C code.
02:21:09 <johnw> sort of like analysis-guided optimizations
02:21:09 <Cale> (As compiled by GHC)
02:21:28 <Cale> So, by that measure "nothing"
02:21:28 <tdammers> or maybe evaluate thunks when it detects that it is semantically equivalent
02:22:23 <halfie> hi, a silly question but is haskell newbie friendly?
02:22:34 <halfie> (as compared to say Scala?)
02:22:41 <johnw> tdammers: "Imperative languages are tightly tied to operational semantics which describes their way of execution on a machine. It is possible to define a denotational semantics for imperative programs and to use it to reason about such programs, but the semantics often has operational nature and sometimes must be extended in comparison to the denotational semantics for functional languages.[2] In contrast, the meaning of purely
02:22:42 <johnw> functional languages is by default completely independent from their way of execution. The Haskell98 standard even goes as far as to specify only Haskell's non-strict denotational semantics, leaving open how to implement them."
02:22:46 <johnw> from http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
02:23:30 <tdammers> well, simply put, either you evaluate something or you don't. If you don't, you need to remember how to evaluate it when the need arises
02:23:34 <Cale> halfie: Depends a bit on the newbie. If you don't know any other functional programming languages already, you can expect it to be about as hard to learn as your first programming language.
02:23:42 <tdammers> or you have to be able to decide that you won't need it
02:23:56 <DigitalKiwi> Ndit got tired of trolling #lua and moved to #haskell I see...
02:24:00 <Cale> halfie: (maybe a little harder if you have to spend a lot of time unlearning things :)
02:24:26 <halfie> Cale, I have done a bit of programming in Erlang, nothing serious though. I write code in C and Python mostly.
02:25:30 <Cale> halfie: It's pretty average as far as language complexity goes. It's several times less complicated in absolute terms than C++, for instance. (Even after accounting for extensions, lol.)
02:26:05 <halfie> Cale, I absolutely hate C++ ;).
02:26:24 <halfie> I am deciding between Scala (which has become popular in web space) and Haskell
02:26:26 <Cale> (At least, based on the size of the language spec or the grammar.)
02:26:46 <Cale> From what I understand, most of the Scala people are thinking in Haskell anyway.
02:27:21 <Cale> So if you want to understand Scala code, you might end up learning both languages in the end :)
02:28:17 <halfie> Cale, is Haskell as productive as say Python once you get the hang of it?
02:28:27 <Cale> Moreso, I'd say.
02:28:33 <XexonixXexillion> There's a lot of very non-functional Scala code out there. It's a pretty flexible language
02:28:47 <tdammers> wouldn't one also need a fairly solid understanding of the Java ecosystem for Scala?
02:28:54 <Cale> tdammers: Probably
02:29:09 <Cale> I don't really know, I'm just going on what I've heard various people say about it.
02:29:10 <halfie> tdammers, yes, if you plan on using existing Java libraries.
02:29:43 <tdammers> heh
02:29:52 <tdammers> so you'd have to learn three languages, really
02:30:03 <halfie> I know that Twitter uses Scala. Who uses haskell?
02:30:09 <adinapoli> I do Scala in my everyday job, if you have questions ping me
02:30:13 <Cale> skedge.me! :)
02:30:14 <halfie> are there any big guys using it?
02:30:15 <adinapoli> more than happy to help
02:30:21 <Cale> (the company I'm working for)
02:30:25 <DigitalKiwi> I had very little problems learning scala by itself
02:30:28 <tdammers> halfie: none of the super-big ones AFAIK
02:30:36 <Cale> http://www.haskell.org/haskellwiki/Haskell_in_industry
02:30:40 <XexonixXexillion> you can learn java (the language, not the libraries) in an afternoon
02:30:56 <Cale> Facebook uses Haskell internally for tools
02:30:58 <DigitalKiwi> I only had problems when it came to that I was learning scala for android development...and all the examples are java (and I didn't yet know any java)
02:31:08 <halfie> XexonixXexillion, I have done a bit of Java. Its allright, I am trying to learn something functional now :)
02:31:17 <Cale> A lot of banks use Haskell
02:32:22 <XexonixXexillion> Galois ( http://corp.galois.com/ ) use Haskell
02:32:23 <halfie> well everything I try will be better than Ocaml ;) . I hate that one.
02:32:26 <DigitalKiwi> I still haven't learned enough haskell to be useful with it at all...
02:33:24 <DigitalKiwi> is that where glguy is at?
02:34:18 <johnw> lispy is at Galois
02:35:30 <DigitalKiwi> maybe he works with glguy cause i'm pretty sure he was there too! :P
02:35:42 * hackagebot azurify 0.1.0.0 - A simple library for accessing Azure blob storage  http://hackage.haskell.org/package/azurify-0.1.0.0 (ArnoVanLumig)
02:35:43 <Cale> I heard from a friend that scribd is using Haskell internally
02:35:55 <Cale> I'm not sure whether they've said anything about their use of it publically.
02:36:06 <DigitalKiwi> http://corp.galois.com/eric-mertens/ boom
02:37:09 <DigitalKiwi> i miss glguy :<
02:37:22 <halfie> Cale, thanks! it seem haskell is quite popular in financial industry
02:37:31 <Cale> halfie: Yeah
02:37:42 <Cale> halfie: Every bank has a "secret" functional programming team
02:38:39 <halfie> heh
02:39:20 <Cale> edwardk isn't around right now, but he could probably tell you a bit more about that
02:39:47 <Cale> He's working on financial software in Haskell and in an in-house Haskell-like language, from what I understand.
02:40:20 <flebron> Hrm. How could "unsafePerformIO (print (x + y)) `seq` f bs" be much slower than (print (x+y)) >> f bs?
02:40:40 <Cale> flebron: lol, that's interesting
02:40:50 <Cale> flebron: What does the core look like?
02:41:07 <flebron> I've never looked at Core, how do I check that out?
02:41:13 <Cale> -ddump-simpl
02:42:08 <flebron> http://hpaste.org/89477
02:42:11 * flebron understands nothing
02:42:37 <Cale> oh, right... there was a way to clean this up in the new versions...
02:43:15 <supki> -dsuppress-all I think
02:43:38 <flebron> Hrm. Well, I'm only ay 7.0.4 :s
02:43:40 <flebron> *at
02:43:52 <Cale> try -dsuppress-idinfo -dsuppress-module-prefixes
02:44:09 <Cale> Yeah, it was back in 6.x that I last spent any time staring at core :P
02:45:19 <Cale> could also -dsuppress-type-applications
02:45:38 <tdammers> I think the reason Haskell is secretly popular in banking is that it combines a rigid type system, excellent concurrency features and rock-solid performance
02:45:40 <Cale> (which would get rid of all the @ things)
02:45:45 <tdammers> most other languages can only give you two of those
02:45:50 <flebron> Looks similar to me :p http://hpaste.org/89477
02:46:22 <flebron> What I'm trying to accomplish may just be impossible though.
02:46:25 <Cale> yeah, suppress the type applications too :)
02:46:36 <flebron> Given a large (40MB) file, read pairs of Integers, and print their sum.
02:47:08 <flebron> There are no solutions in Haskell so far :p http://www.spoj.com/problems/CRYPTO/
02:47:17 <Cale> flebron: That sounds like it should be doable.
02:47:47 <flebron> The things I've tried (all too slow) are at http://hpaste.org/89471
02:48:05 <flebron> I think the third one's the fastest so far.
02:48:46 <Cale> What if you use Int?
02:49:05 <flebron> (And unfortunately, I've no access to ByteString.Builder, due to the very old (6.10) compiler.)
02:49:07 <bz> > infixr 9 :::
02:49:09 <lambdabot>   <hint>:1:1: parse error on input `infixr'
02:49:14 <flebron> The integers are specifically very large.
02:49:18 <Cale> ah
02:49:25 <bz> > :t infixr
02:49:26 <lambdabot>   <hint>:1:1: parse error on input `:'
02:49:30 <bz> :t infixr
02:49:30 <flebron> (That's essentially the only difficulty in the problem :p)(
02:49:31 <lambdabot> parse error on input `infixr'
02:49:53 <typoclass> bz: infixr and infixl are keywords that the compiler understands, not ordinary functions
02:50:15 <bz> typoclass: how does one use it? copying vertbatim from the haskell wiki does not work
02:50:21 <Cale> flebron: wait, why aren't you using the ByteString part of the result of readInteger?
02:50:49 <flebron> In which paste?
02:50:51 <typoclass> bz: i'm not sure they'll work in ghci, but they do work in ghc
02:50:59 <bz> > infixr 2 |||
02:51:01 <lambdabot>   <hint>:1:1: parse error on input `infixr'
02:51:04 <Cale> all of them?
02:51:11 <bz> typoclass: thanks
02:51:17 <flebron> In the third one I'm not using readInteger, I made my own :p
02:51:40 <flebron> In the first one I've separated things by C.words, so there's nothing after the Integer.
02:51:52 <Cale> well, that's definitely not going to beat the one in the library... if it does, then wow.
02:51:56 <flebron> In the second one I'm doing the same, map C.readInteger over a list of words.
02:52:27 <flebron> So I have a [C.ByteString], where each one is guaranteed to be an Integer (as ByteString), so there's nothing to consume after I've read the Integer.
02:53:24 <Cale> flebron: are you sure you linked me to the right problem on SPOJ?
02:53:32 <flebron> Yep ;)
02:53:42 <flebron> The decrypted text says the problem description.
02:53:53 <Cale> oh,
02:53:56 <flebron> I already have an accepted C++ solution, using a custom BigInt class.
02:53:59 <Cale> that's obnoxious
02:54:03 <flebron> Yeah :s
02:54:11 <flebron> It's the only problem like that I think
02:54:23 <Cale> So what kind of stuff is in this file they give you?
02:54:32 <flebron> Integers, separated by whitespace.
02:54:45 <Cale> Okay, and they have minus signs occasionally?
02:54:56 <Cale> well, that doesn't matter
02:54:59 <flebron> If the Integer is positive, it's less than 2^31. If it's negative, there's no bound.
02:55:05 <flebron> (Hence the need for BigInt.)
02:55:07 <Cale> lol
02:55:34 <flebron> But yeah, for each consecutive pair of Integers, I should output its sum.
02:55:48 <Cale> So you're guaranteed there are an even number of integers
02:55:52 <flebron> Yep.
02:59:12 <Cale> flebron: can there be whitespace before the first one?
02:59:47 <flebron> I haven't checked, but I wouldn't assume the contrary (or that there's no trailing spaces). The decrypted text says "all the numbers are separated by some white spaces".
03:02:34 <tdammers> "white spaces", hehe... I'm still waiting for unicode space glyphs in other colors
03:04:32 <Cale> flebron: How does this compare? http://hpaste.org/89480
03:05:11 <pjdelport> racist spaces
03:05:25 <Cale> isSpace is possibly expensive
03:05:35 <Cale> Though we really ought to profile
03:06:37 <flebron> Slower than the 3rd hpaste, unfortunately.
03:06:41 <Cale> hm!
03:07:11 <Cale> and with isSpace instead of the elem?
03:07:24 <Cale> worse or better?
03:08:18 <flebron> Running
03:08:45 <flebron> Better, but still time limit exceeded
03:09:07 <Cale> Well, that's interesting to know, okay
03:09:35 <flebron> (You can see the attempts, although not really how "well" they did, here: http://www.spoj.com/status/CRYPTO/ )
03:10:14 <Cale> How is the module compiled?
03:10:24 <flebron> So far there's only C/C++ solutions, one Pascal, and one Java
03:10:30 <flebron> Let's see if I can find that out
03:11:29 <Cale> Like, if they're not compiling with -O2, (or at least -O), then you're going to get horrible performance all the time, and should probably give up.
03:11:29 <flebron> Apparently "ghc tested.hs -O --make "
03:11:43 <Cale> hrm just -O
03:12:01 <Cale> Well, at least the RULES pragmas should run :P
03:12:17 <flebron> I suppose I could OPTIONS?
03:13:15 <Cale> I don't think you can -O2 from OPTIONS_GHC, but I might be wrong
03:13:28 <typoclass> flebron: i'd try to fix the "-O2", and then try to start profiling
03:13:44 <flebron> typoclass: What do you mean by "fix the "-O2""?
03:14:12 <typoclass> flebron: well, try to get the contest people to compile with -O2
03:14:19 <flebron> No chance :p
03:14:24 <flebron> The compiler is 6.10.4
03:14:27 <flebron> That's how much they care haha
03:14:33 <typoclass> flebron: erm. oh
03:14:43 <Cale> oh, it's dynamic, at least in new GHC
03:14:54 <kryft> flebron: I wonder if they could be convinced to change the options/compiler?
03:14:55 <Cale> so you can supply {-# OPTIONS_GHC -O2 #-}
03:15:22 <Cale> Wow, not even 6.12.x
03:16:32 <flebron> Neither OPTIONS nor OPTIONS_GHC make it pass, I didn't notice a change in speed. It may really be just not doable haha
03:16:36 <kryft> tdammers: Speaking of excellent concurrency features, what's the best introduction to those? Apparently at least The awkward squad discusses them, although I don't know if it's still up-to-date
03:17:00 <int-e> even debian squeeze (oldstable now) has 6.12 :/
03:17:09 <flebron> BangPatterns is supported, maybe that could help? Though I've no idea how it could be useful here.
03:17:35 <flebron> int-e: To give you an idea, this is the hardware: Intel Pentium III 733 MHz
03:18:05 <Cale> flebron: Back when I tried a couple of the problems, like back in 2003 or something, I got *way* worse time results on their machine than any reasonable machine I could find, and just gave up.
03:18:16 <flebron> Haha, yeah
03:18:16 <int-e> flebron: so what's the gcc version ;-)
03:18:30 <flebron> 4.3.2 :p
03:19:10 <ClaudiusMaximus> perhaps bytestring's 'interact' would be better than lots of 'print'?
03:19:12 <flebron> They've said they do that to measure timings better, so that they can distinguish between an O(n) and O(n log n) solution, things like that.
03:19:22 <Cale> I guess they're pretty consistently lax in updating compilers.
03:19:29 <Cale> lol
03:19:29 <int-e> flebron: almost 5 years old, too; seems fair :)
03:20:34 <Cale> flebron: Nevermind that most O(n) solutions are really O(n log n) solutions where we're ignoring various logarithmic factors of the problem size :P
03:23:17 <Cale> (Memory access has a worst case of at least O(log n) time where n is the available amount of memory -- probably worse if you wanted to build real computers.)
03:24:20 <Cale> If you want to build real computers, then memory accesses are O(n^(1/3)) or O(n^(1/2)) depending on what you think about certain physical principles.
03:25:31 <tdammers> Cale: wouldn't n be the amount of *addressable* memory, rather?
03:25:42 <int-e> Cale: of course once you reach a certain distance you'll bundle the memory with more CPUs. And then the analysis becomes tricky.
03:25:43 <Cale> yes
03:27:07 <Cale> int-e: Provided that you can actually take advantage of that parallelism in any way at all...
03:28:01 <int-e> Cale: tricky :P
03:31:47 <Cale> Anyhow, it's a seemingly often overlooked point that any function which has a range of size n takes at least O(log n) time, because it has to examine at least log n bits of its input.
03:33:56 <pjdelport> it does also depend whether the O() is measuring time, or a primitive like operations
03:34:23 <pjdelport> (where operations are approximated to O(1), even though that's not necessarily quite true)
03:34:55 <efie> when I try "SourceGraph myfile.hs" I get "Could not parse source file ./myfilel.hs; SourceGraph: Map.findMin: empty map has no minimal element". do you have any ideas what went wrong? the file compiles and works fine
03:36:36 <Cale> pjdelport: Yeah, it's just that to actually *solve* the problem once the size gets large enough, sometimes operations you considered primitive are going to have to start costing more, and people ignore those costs all the time, but are inconsistent about it.
03:36:53 <ClaudiusMaximus> efie: are you sure you didn't mistype "SourceGraph myfilel.hs" ?
03:37:53 <Cale> (and you have to be able to discuss the problem at arbitrarily large sizes in order for the asymptotic analysis to not be trivialised)
03:39:20 <efie> Cale: yes I'm sure, if I replace all my function definitions with undefined it works
03:39:44 <efie> ups, I meant ClaudiusMaximus
03:40:06 <ClaudiusMaximus> it's just that the error message mentioned a different file name...
03:40:08 <Cale> efie: Your error message has an l in it
03:40:43 <efie> my file actually has a different name, I just replaced this with myfile, therefore the typo
03:44:41 <Cale> efie: Well, if the parse fails, I think I can see where the findMin will...
03:45:03 <Cale> efie: Are you using any extensions?
03:45:22 <Cale> SourceGraph uses language-haskell-exts to parse the code.
03:45:56 <Cale> It's really pretty silly that it doesn't seem to percolate the actual parse error to the top level where it prints the message
03:46:32 <efie> Cale: I use the {-# LANGUAGE BangPatterns #-} extension
03:46:43 <Cale> parseFile (p,f) = case (parseFileContentsWithMode mode f) of
03:46:43 <Cale>                     (ParseOk hs) -> Right hs
03:46:43 <Cale>                     _            -> Left p
03:47:22 <Cale> ^^ the _ in this code is why you don't get a better error message -- it destroys the information about the error here :P
03:48:55 <efie> Cale: ok.. so, what can I do? bit by bit deleting part from the code to determine where the error comes from?
03:49:28 <Cale> efie: That might work, or you could hack on SourceGraph a little to produce a better error message
03:50:21 <efie> um I don't have the time or experience for the latter
03:50:36 <efie> I think I will try the first one
03:50:54 <Cale> You could just stick in   ParseFailed loc msg -> error (show loc ++ ": " ++ show msg)
03:51:08 <Cale> and you'd be farther ahead than with what it gives you :P
03:56:38 <Peaker> when i have a single exception crash my program, with +RTS -xc, why am I getting a whole bunch of dumps?
03:57:18 <efie> Cale:  sorry for this questions.. I think I have to insert your line into Parsing.hs from SourceGraph, where do I found this Parsing.hs file on my computer? at /.cabal/packages/hackage.haskell.org/SourceGraph/0.7.0.3 there is SourceGraph-0.7.0.3.tar.gz, am I at the right place there?
03:57:39 <Cale> efie: cabal unpack SourceGraph
03:58:49 <Cale> efie: then cd into the directory it makes, change Parsing.hs, and then "cabal install" with no additional arguments to reinstall it.
03:58:59 <typoclass> Peaker: one stacktrace for each thread? i have no idea
03:59:04 <Cale> If it complains, you can --force-reinstall
03:59:57 <pjdelport> Cale: right, and caching is something that's almost as often ignored
04:00:01 <Peaker> I don't think I have any threads besides the main thread
04:00:44 <pjdelport> but fascinating, with things like cache-oblivious algorithms
04:09:06 <klrr> morning
04:09:11 <klrr> mornin
04:09:13 <klrr> morning*
04:09:18 <klrr> how are all haskellers today?
04:09:25 <Botje> (you wrote it right the first time)
04:09:45 <Botje> also, hi
04:09:58 * typoclass purrs
04:10:47 * hackagebot modulo 1.1 - Modular C code generator  http://hackage.haskell.org/package/modulo-1.1 (HansHoglund)
04:10:49 * hackagebot modulo 1.2 - Modular C code generator  http://hackage.haskell.org/package/modulo-1.2 (HansHoglund)
04:12:26 <ClaudiusMaximus> Peaker: +RTS -xc prints a stack trace for every excpetion that's thrown, no matter if it's caught or otherwise  http://hpaste.org/89486
04:13:14 <Peaker> ClaudiusMaximus, well, only one of those exceptions is really caught, the rest all seem to be the same exceptions or multiple uncaught exceptions somehow
04:13:56 <ClaudiusMaximus> Peaker: maybe worth checking a simple case - i suspect something like 'bracket' would rethrow the exception?
04:14:20 <Peaker> ClaudiusMaximus, ah, maybe I have some brackets or such
04:14:39 <klrr> i got a problem with working with ReaderT monad, i got a Config record, and now try to work with that and get all content out of it, but it doesn t work since i get all kinds of wacky errors when i use "asks", https://gist.github.com/klrr/5728619 anyh ideas?
04:14:42 <Peaker> ClaudiusMaximus, yep, I do, that does seem like it might explain it, thanks!
04:15:47 * hackagebot modulo 1.3 - Modular C code generator  http://hackage.haskell.org/package/modulo-1.3 (HansHoglund)
04:16:54 <supki> klrr:  asks config >>= owner  is not a String
04:17:11 <supki> klrr: also you probably meant   asks (owner . config)  or something
04:17:16 <klrr> supki: it's not?, but i used >>= to unmonad it?
04:17:18 <supki> otherwise it does not make sense
04:17:32 <supki> you can't "unmonad" anything
04:17:40 <klrr> supki: with asks i get the config and pass it to the function owner
04:17:50 <supki> Monad does not support "unmonading"
04:17:53 <exFalso1> hi, is there a way to inspect type level strings? is there something like a lifted Char and lifted cons?
04:17:54 <klrr> okey
04:17:56 <byorgey> @type (>>=)
04:17:57 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:18:06 <Botje> klrr: write this down somewhere. >>= expects an m a on the left side, and a function a -> m b on the right side.
04:18:08 <byorgey> as you can see from the type, the result of (>>=) is a monadic action
04:18:10 <klrr> so it returns Foobar String?
04:18:14 <Botje> klrr: the a's must match and the m's must match.
04:18:17 <plhk> this modulo thing development is really fast, it seems
04:18:21 <klrr> how do i extract the string then?
04:18:38 <Botje> klrr: owner :: Config -> String
04:18:50 <Botje> klrr: the bind gives you a Config, and expects an m String back.
04:19:03 <Botje> plhk: we are witnessing the bootstrap of skynet.
04:19:06 <klrr> Botje: yes , i get the config with asks config, then i get the string with the partially applied owner
04:19:16 <klrr> how do i solve this? :x
04:19:59 <Botje> klrr: that's a type error.
04:20:13 <klrr> how do i solve that type error? i dont even uynderstand the error
04:20:17 <Botje> owner :: Config -> String. >>= expects (Config -> m b) on the right hand side.
04:20:29 <supki> klrr: you can bind the result of  asks (owner . config)  to something and then pass it to  clean
04:20:37 <Botje> additionally, you cannot perform such a monadic computation in a guard.
04:21:14 <supki> klrr: like you do with result of  liftIO $ hGetLine h
04:21:19 <klrr> supki: how can i even call asks (owner . config) , since i dont have that config, i need to ask the environment for the config THEN pass it to owner
04:21:33 <klrr> i need to lift ask or owner?
04:21:57 <klrr> i hate haskell it's too difficult -.-
04:22:03 <Botje> asks already gets the environment and applies a function to it.
04:22:09 <exFalso1> :t (<$>)
04:22:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:22:11 <klrr> Botje: that's what i want
04:22:21 <klrr> i dont want any monad shit, i want my string
04:22:36 <Botje> and you need to perform a monadic computation to get it.
04:22:55 <Botje> asks (config . owner) :: Net String.
04:23:07 <klrr> sry that i said monad shit, it's klrr shit since he's too dumb for this ...
04:23:29 <Botje> you know how to execute a Net action and get the value back. do that.
04:23:36 <exFalso1> klrr: read a monad tutorial, there are literally too many of those out there
04:23:41 <Peaker> klrr, http://hpaste.org/89489  has a few useful ways to do function application
04:23:58 <klrr> asks doesnt work
04:24:18 <klrr> "Applicative" is that the same as strict evaluation?=
04:24:28 <klrr> eval the arguments before passing?
04:24:28 <Peaker> klrr, nope, has nothing to do with strict/lazy
04:24:37 <klrr> what does it mean? =o
04:24:40 <Peaker> klrr, it's all about where you have "effects"
04:24:59 <Peaker> klrr, (a -> b) means you have a pure function with no effects.  f (a -> b)   means you have an effectful computation that generates a pure function
04:25:12 <Peaker> klrr, (a -> f b)   means you have a function that generates some effects and then a result b
04:25:13 <klrr> haskell makes it too hard for stupid idiot people, i  need to learn boring imperative stupid language and then go and k.,..
04:25:33 <klrr> Peaker: i know that
04:25:33 <Peaker> klrr, so depending on what kind of computation/function/effectfulness you have, you use a different sort of function application
04:25:37 <klrr> the problem is i dont get how
04:25:45 <klrr> (asks config >>= owner) can be wrong
04:25:52 <klrr> how can i translate that into correct?
04:25:58 <klrr> if it's even possible
04:26:07 <Peaker> klrr, what is the type of "owner" ?
04:26:11 <klrr> i dont understand (asks (owner. config)) since i dont have config
04:26:12 <Peaker> klrr, and of "config"?
04:26:15 <klrr> Config -> String
04:26:16 <Botje> klrr: I've tried to get you to see it three times already.
04:26:20 <klrr> config :: Config
04:26:22 <efie> Cale: thanks a lot !! gave me the exact line and column at which the error occured
04:26:31 <Botje> asks config :: Net Config
04:26:34 <klrr> Botje: i dont see it im not smart
04:26:35 <Botje> owner :: Config -> String
04:26:49 <klrr> Botje: which do i have to lift into something monad?
04:26:53 <Botje> >>= requires that the LEFT side is m a
04:26:58 <Peaker> klrr, you might just be trying to jump right into more advanced things than you've learned
04:26:59 <Botje> and the RIGHT side is a -> m b
04:27:13 <Botje> you are trying to stuff Config -> String into a place that expects Config -> m String.
04:27:14 <klrr> Peaker: i dont care, i wanna write a irc bot with a configuration file
04:27:18 <exFalso1> klrr: doesnt matter what you say, #haskell always makes everyone feel dumb lol
04:27:18 <Peaker> klrr, Haskell isn't easy to learn, people expect it to be easy like other languages which are almost the same to one another
04:27:33 <klrr> this is my first language -.-
04:27:38 <klrr> i dont excpect anything
04:27:50 <Peaker> klrr, that might be a good thing for learning Haskell :)
04:27:52 <typoclass> efie: there you go then =) congratulations, first time you've modified and recompiled a haskell program
04:28:15 <Peaker> klrr, so basically you need to think about what types the functions you apply take, and what types the values you pass them have, and whether they match
04:28:17 <typoclass> efie: and huge bonus points if you make your change a patch and send it to the maintainer of sourcegraph
04:28:19 <klrr> i will learn a dynamic language, and then all i get is runtime errors instead -.- i will never learn programming
04:28:31 <Peaker> klrr, if "config :: Config", it isn't a function, so you can't pass it to "asks" which expects a function as an argument
04:28:38 <kryft> I don't know if Haskell is that much harder to learn as such, but 1) it's very different from most other languages and 2) there are many layers of abstraction because of the flexibility of both the language and the minds of its users :)
04:28:47 <klrr> Peaker: how can i pass socket to asks then?'
04:28:58 <Peaker> klrr, you can't, you can only pass functions to asks
04:29:01 <klrr> Peaker: socket :: Handle, that can i pass to it why?
04:29:08 <klrr> Peaker: i can look here
04:29:13 <klrr>  h <- asks socket
04:29:22 <Botje> klrr: socket :: Bot -> Handle.
04:29:23 <efie> typoclass: thanks :D I will notify the maintainer
04:29:30 <supki> config :: Bot -> Config
04:29:32 <klrr> Botje: then config has Bot -> Handle too
04:29:33 <dEPy> hi all :)
04:29:38 <Botje> klrr: yes, it does.
04:29:44 <Peaker> klrr, "socket" isn't a socket, but a function from Bot to Handle
04:29:55 <klrr> i know
04:29:55 <kryft> It took me a while to realize that I don't need to understand all the layers of abstraction immediately to start using the language
04:30:04 <Peaker> klrr, so I am not sure what your question is?
04:30:15 <Botje> you're in a ReaderT Bot IO context, so asks :: (Bot -> a) -> ReaderT Bot IO a
04:30:29 <Botje> or, with the type synonyms, asks :: (Bot -> a) -> Net a
04:30:33 <klrr> Peaker: how do i write (asks config >>= owner) correctly, should i use a super long do statement, or can i write a oneliner?
04:30:45 <kryft> For instance, I have no idea what lenses are and I don't plan to find out for a while :)
04:30:58 <Botje> klrr: think for yourself. it's better in the long run. what is the type of asks config?
04:31:05 <Botje> you know config :: Bot -> Config.
04:31:15 <Botje> and I gave you the type of asks above.
04:31:44 <Peaker> klrr, maybe you're looking for something like: asks (owner . config)  ?
04:31:49 <Peaker> klrr, I don't have all the types handy
04:32:45 <klrr> Peaker: can you explain how asks (owner . config) works? i thought i used asks to extract the Config out of config, and then passing THAT to owner function, how do you want me to intepret that expression?
04:33:09 <Botje> klrr seems to be focused on Peaker. oh well.
04:33:10 <Peaker> klrr, you use asks to combine "ask" (get the Reader value) with a pure function that transforms it
04:33:31 <klrr> Botje: will read your messages too, but i had to punch myself first
04:33:33 <Peaker> klrr, it might be better for learning to use "ask" directly and avoid asks
04:33:45 <Peaker> klrr, Do you know what (<$>) does?
04:33:51 <klrr> yes
04:33:53 <klrr> it's like fmapå
04:33:55 <klrr> fmap*
04:34:06 <Peaker> klrr, so what is   asks f    in terms of ask and <$> ?
04:34:47 <klrr> no idea, i thought asks took the state called Net, adding a Bot to its env
04:35:17 <Peaker> klrr, asks just does an "ask" followed by a pure function application on "ask"s result.   "ask" reads whatever is your Reader value
04:35:30 <Peaker> klrr, what's your monad type? What kind of Reader do you have?
04:35:52 <klrr> what's a function application?
04:35:52 <Botje> Peaker: https://gist.github.com/klrr/5728619 is klrr's source code.
04:35:54 <eikke> :t asks
04:35:55 <lambdabot> MonadReader r m => (r -> a) -> m a
04:36:37 <Peaker> more concrete example:  asks :: (r -> a) -> ReaderT r m a
04:36:48 <Peaker> well, it's going to need a Functor or Monad constraint on the "m"
04:37:06 <klrr> o need to drink some coffee, i feel im almost in suicide mood
04:37:16 <exFalso1> klrr: my advice is read a tutorial on monads, and specifically the Reader monad. i think you jumped into trying to use monads before learning them, which isnt going to work
04:37:48 <klrr> exFalso1: i dont like monads so i skipped them, i wanna use them not understand them, but i may follow your advidce, bbl
04:37:57 <Peaker> klrr, you sound overly frustrated.. you seem to be doing intermediate stuff with beginner knowledge
04:38:11 <klrr> thanks for trying to help me everybody too, sry that im too slow to get it :/
04:38:13 <exFalso1> klrr: and it doesnt mean you're dumb! all of us have been there!
04:38:17 <eikke> you "don't like monads", that's an interesting thing to say
04:38:18 <klrr> beginner knowledge? i dont have any knowdleg
04:38:23 <eikke> especially when writing haskell
04:39:06 <kayloos> Problem is that it's hard to learn Haskell just by writing programs and learning stuff on the way, you have to read up on stuff before using it
04:39:29 <kayloos> at least that's my experience, hence why i just ordered a book about it
04:40:48 * hackagebot transf 0.5 - Text transformer and interpreter.  http://hackage.haskell.org/package/transf-0.5 (HansHoglund)
04:42:43 <Peaker> kayloos, I think you can learn Haskell without reading a lot of beforehand, but you do have to make sure you're thorough with your research to really undertand
04:42:53 <Peaker> and not just get a fuzzy understanding
04:42:58 <exFalso1> i'll reask my earlier question: is there a way to inspect type level strings(Symbols) on the type level? there seem to be a lot of ways to destruct and query type level Nats in GHC.TypeLits but there are none for Symbols
04:44:02 <eikke> exFalso1: what would you 'inspect'?
04:44:09 <exFalso1> characters
04:44:26 <exFalso1> was thinking of writing a type safe printf where the format string is in the type
04:44:41 <Peaker> exFalso1, mauke wrote a TH safe-printf
04:44:49 <exFalso1> TH is cheating
04:44:59 <Peaker> doing type-level analysis on a format string doesn't sound like fun
04:45:23 <mauke> exFalso1: oh, like (printf :: "Hello, %s!") "world"?
04:45:49 * hackagebot transf 0.6 - Text transformer and interpreter.  http://hackage.haskell.org/package/transf-0.6 (HansHoglund)
04:45:54 <exFalso1> mauke: exactly, although you probably need a type family application before the string
04:46:22 <mauke> will that still be usable?
04:46:27 <exFalso1> (print :: F "Hello, %s!") hehe
04:46:38 <exFalso1> i think so
04:46:42 * eikke considers "Hello, %s" to be something at value-level
04:46:48 <kayloos> Peaker: I also think it's possible to do it that way, but in my experience every time I hit a bump when developing, it's either 1: Syntax i don't understand yet or 2: How to use monadic functions, analyze monad types, transformers etc.
04:46:52 <mauke> eikke: do you even lift, bro?
04:47:01 <mauke> to the type level?
04:47:07 <exFalso1> eikke: look into TypeLits
04:47:11 <eikke> mauke: yes
04:47:17 <eikke> exFalso1: I use TypeLits
04:48:07 <kayloos> For example, how do I learn about transformers, without reading a book about it.. There is no `natural' next step, and it isn't transparent what these things mean when looking at example code by somebody more experienced.
04:48:08 <exFalso1> so it seems there is no lifted Char and cons then>?
04:50:49 * hackagebot transf 0.7 - Text transformer and interpreter.  http://hackage.haskell.org/package/transf-0.7 (HansHoglund)
04:51:17 <kayloos> Bumping around hackage.haskell.org is great, but most information is compacted into types, and if you don't understand everything about types, it is really hard to get information
04:51:32 <pjdelport> the universal natural next step is asking #haskell
04:53:03 <kayloos> pjdelport: indeed, i actually think this channel is one of the big strengths of the language, people are really helpful+smart compared to other channels
04:53:50 <eikke> this channel, & haskell-cafe & SO :-)
04:54:05 <exFalso1> SO?
04:54:16 <eikke> StackOverflow
04:54:19 <exFalso1> ah
04:55:22 <kayloos> Didn't know about haskell-cafe, just signed up, thanks
04:55:38 * pjdelport wonders what a more appropriate name than "stack overflow" would be for Haskell
04:55:50 <eikke> IIRC there's a haskell-beginners list as well, but I'm not subscibed to it so can't tell how it is :)
04:56:55 <mr-> questions toe the haskell-beginners list are being asked and usually answered quickly :-P
04:57:24 <klrr> i gonna use IORef for my state instead
04:57:30 <klrr> i know how to use that
04:57:48 <eikke> klrr: what are you writing?
04:58:01 <kmels> hey, what's normally a good name for a value that can be either WHNF or a thunk? Looking for good a type synonym for `Either Value Thunk`
04:58:32 <mr-> ValueOrThunk :-P
04:59:40 <mauke> Lazy
04:59:42 <eikke> MaybeValueOrMaybeNotYetAValue
05:00:04 <kmels> hehe
05:00:17 <mr-> Foo
05:00:49 * hackagebot classy-prelude 0.5.8 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.5.8 (MichaelSnoyman)
05:01:05 <klrr> eikke: an IRC bot, i already got one very simple and sucking one working, but it's almost just a copy paste of the IRC bot tutorial on the wiki, my goal is to have some special features, i wanna have a config file, i want to have it really extensible in forms of plugins, basically so a friend of mine can develop new commands for it without needing to learn anything about the IO monad and Network module yet (he's learning haskell but is even worse than me :x), a
05:01:56 <alpounet> klrr, may i suggest the SimpleIRC library?
05:02:01 <alpounet> the name says it all
05:02:26 <eikke> klrr: I'd use a stack of Reader (for the config) and Writer (for actions to execute)
05:02:50 <klrr> eikke: i dont know Reader or Writer
05:03:16 <klrr> alpounet: my goal is too learn, and by the way i think the Network module is enough abtraction to work with
05:03:20 <klrr> to*
05:03:40 <klrr> i need to find good docs on IRC protocol first
05:03:41 <eikke> klrr: then you shouldn't work on something as complicated as an IRC bot with plugins etc yet (friendly advise)
05:04:44 <alpounet> klrr, well, you'll go through the annoying route of writing the parsing code for the IRC protocol and whatnot. if that's what you want to learn, no problem. if you want to get used to writing haskell code, you may as well want to use a library that uses typical haskell software designs, that'll get you used to it and make you focus on the fun aspects of your bot :-)
05:05:50 * hackagebot standalone-haddock 1.0 - Generate standalone haddock documentation for a set of packages  http://hackage.haskell.org/package/standalone-haddock-1.0 (RomanCheplyaka)
05:05:53 <klrr> alpounet: well i learned how to use parsec when i wrote a lisp, that's why i wanna use it again so i learn it more deeply
05:06:29 <typoclass> klrr: irc is fairly easy to parse, it's nearly plaintext. i think it can be a good way to get comfortable basic functions like lines, words, the split package, etc.
05:06:40 <typoclass> klrr: ... yes, or parsec :-)
05:09:07 <klrr> sry if im talking rubbish
05:09:55 <klrr> also, using parsec might be a bit overkill, i got a friend who has a irc paring lib in just 50 lines or sth only using standard functions and some stuff from Data.Char...
05:10:31 <alpounet> klrr, alright, that's a good enough reason for me too. you can get some inspiration for the higher level constructs from SimpleIRC nonetheless
05:13:21 <klrr> \r is newline in Windows?
05:13:36 <klrr> if you write \r\n, doesnt that become two newlines?
05:13:44 <exFalso1> no
05:13:45 <FUZxxl> klrr: no,
05:13:54 <FUZxxl> In Windows, \r\n is a nweline
05:13:56 <exFalso1> \r is carriage return
05:14:03 <FUZxxl> A newline under windows is composed of two character
05:14:04 <klrr> okey
05:14:05 <FUZxxl> s
05:14:20 <exFalso1> on Windows \n just means next line, but dont put the cursor to the beginning of it
05:14:22 <klrr> so if i exclude \r\n, my irc bot wont work when talking to windows machines?
05:14:49 <klrr> exclude aka only using \n to terminate my messages
05:14:54 <hodapp> and if you exclude \r it may not work on some pre-OS X Macs!
05:15:02 <klrr> ok
05:15:30 <klrr> withSocketsDo is also such tings right? so it works on some all systems, but is not really needed for Unix-like oses
05:15:50 * hackagebot standalone-haddock 1.0.1 - Generate standalone haddock documentation for a set of packages  http://hackage.haskell.org/package/standalone-haddock-1.0.1 (RomanCheplyaka)
05:16:14 <exFalso1> withSocketsDo doesnt do anything on non-windows machines
05:16:23 <exFalso1> you need some initialisation on windows to use sockets
05:16:27 <exFalso1> thats what its for
05:16:31 <klrr> okey
05:21:50 <typoclass> klrr: i'm pretty sure the line-ending is standardized in the irc specification. the irc rfc will tell you "the line ending is \r\n, period". i don't think that the usual linux clients deviate from the spec and send only \n
05:22:45 <mantovani> typoclass: if this is about the protocol doesn't matter.
05:24:54 <typoclass> mantovani: sorry, i'm not sure what you mean
05:25:54 <klrr> what is Reader for?
05:26:31 <klrr> "Maintaining variable bindings, or other shared environment."
05:26:45 <klrr> so it's for having a kind of environment?
05:26:49 <mantovani> typoclass: is complete different the specification than what is show in the screen.
05:26:50 <Botje> passing around a value so you don't have to.
05:26:57 <mantovani> s/tran/and/
05:27:06 <Botje> it's also called the environment monad sometimes
05:27:38 <klrr> Botje: okey, so it's basically what you want if you need a value in a lot of functions without having to pass it around?
05:27:49 <Ghoul_> :t find
05:27:50 <lambdabot> (a -> Bool) -> [a] -> Maybe a
05:27:56 <eikke> klrr: yeah
05:28:01 <eikke> :t runReader
05:28:02 <lambdabot> Reader r a -> r -> a
05:28:06 <eikke> :i Reader
05:28:12 <eikke> oh :(
05:28:39 <klrr> also, when something is called "run*" it's some kind of extracting funciton to get a value out of a some type? (am i allowed to call it unmonading?)
05:29:29 <typoclass> klrr: 'environment' is a good name. you can have a value (can be a tuple or a record) which can be fetched and used in all the functions in the Reader. they can't change it, however. so this is an advantage compared to passing something around into all kinds of functions, because they could (accidentally) change the value
05:29:33 <eikke> klrr: Reader r a (an action which takes an environment of type r and yields a result of type a) is basically 'r -> a', not much more
05:31:07 <kryft> typoclass: So it's a bit like State with a constant state?
05:31:33 <typoclass> kryft: yes, like State but without the ability to modify it
05:31:53 <eikke> klrr: yes, since State s a is 's -> (a, s)'
05:32:03 <eikke> notice how it's similar to reader for the 'retrieve state' part
05:32:51 <Ghoul_> @pl (\b -> (fromJust b) == "end")
05:32:51 <lambdabot> ("end" ==) . fromJust
05:33:51 <thorsten`> i'm looking for some fmap where the helper function gets the entire original object and not only the 'annotation'. i.e. i'm looking for:  (Functor m) => (m a) -> (m a -> b) -> (m b)
05:34:13 <prophile> thorsten`: that looks quite a lot like a comonad
05:35:11 <eikke> like foo a f = pure (f a) ?
05:35:24 <prophile> http://hackage.haskell.org/packages/archive/category-extras/0.53.1/doc/html/Control-Comonad.html
05:35:25 <typoclass> mantovani: maybe. but it seems easier to me to stick to the specification, and then deal with the problems that existing software causes. it seems more difficult to ignore the spec, and start by reverse-engineering a number of clients
05:35:39 <supki> category-extras :-(
05:35:56 <adinapoli> wasn't category-extras deprecated?
05:35:58 <supki> http://hackage.haskell.org/packages/archive/comonad/3.0.2/doc/html/Control-Comonad.html
05:36:03 <supki> yeah, it was
05:36:12 <typoclass> adinapoli: yes, it was split up into eleventy smaller packages
05:36:59 <typoclass> thorsten`: just as a double-check, did you mean (m a) -> (m a -> m b) -> (m b) ?
05:37:09 <thorsten`> typoclass: no
05:37:27 <typoclass> thorsten`: ok =)
05:38:01 <thorsten`> prophile: the comonad-laws exactly look like what i'm searching
05:38:23 <typoclass> thorsten`: then i guess you're outside of the base package's territory. (m a -> b) isn't normally possible. you're in comonad territory
05:39:24 <thorsten`> okey, and is there some DeriveComonad-option for ghc?
05:40:01 <supki> no
05:41:35 <thorsten`> hm :/ because the implementation of extend looks nearly like the implementation of fmap..
05:53:36 <Ghoul_> >withSocketsDo doesnt do anything on non-windows machines
05:53:53 <Ghoul_> I thought it was required on all except linux?
05:54:49 <irene-knapp> not required on Mac either
06:03:26 <magicman> Huh.
06:03:35 <magicman> @type \f a -> f a <$ a
06:03:36 <lambdabot> Functor f => (f b -> a) -> f b -> f a
06:04:09 <magicman> That definition actually satisfies "extend f . extend g === extend (f . extend g)".
06:07:03 <magicman> Finding a decent "extract" may be tricky, though.
06:12:32 <eikke> PiepScuim: hi there :-P
06:20:30 <PiepScuim> eikke: hello :-)
06:21:09 <klrr> what program should i write?
06:22:31 --- mode: ChanServ set +o mauke
06:22:31 --- mode: mauke set +b $a:Ndit
06:22:59 <thorsten`> klrr: implement DeriveComonad in ghc
06:23:19 <klrr> thorsten`: sounds boring
06:23:29 <klrr> i wanna write something useful
06:23:31 <klrr> to me
06:23:39 <prophile> how would DeriveComonad work
06:24:16 <thorsten`> generate this kind of boilerplate code: http://wwwcip.cs.fau.de/~re06huxa/p/01dcb28632a2a9682e5877fc23af4a1c
06:24:31 --- mode: mauke set -o mauke
06:24:41 <prophile> Copointed might be saner
06:24:43 <thorsten`> (more precisely: implement the instance-thing from the data definition)
06:25:23 <thorsten`> prophile: is the only difference, that Comonad instances have to fullfill stricter laws?
06:25:40 <prophile> Copointed gives you extract
06:25:42 <prophile> and that's it
06:26:13 <prophile> comonad adds extend/duplicate
06:26:31 <typoclass> mauke: what's going on with "ndit"?
06:29:32 <mauke> typoclass: they got banned again
06:29:46 <hodapp> wait, wait
06:29:51 <hodapp> Ndit was here too?
06:30:02 <typoclass> mauke: yes i can see that you banned ndit, but why?
06:30:03 <Taneb> preflex: seen shapr
06:30:03 <preflex>  shapr was last seen on #haskell-lens 9 days, 12 hours, 59 minutes and 8 seconds ago, saying: yup
06:30:10 <typoclass> hodapp: yes about 4 hours ago, apparently
06:30:13 <mauke> typoclass: inanity
06:30:41 <hodapp> Ndit was in #dataflow the other day talking a bunch of shit. He was personally blaming the entire channel for not rewriting something like Pd on a different codebase
06:30:58 <elliott> typoclass: repeated admitted trolling
06:31:06 <elliott> not the first time they have been banned (also not the place to discuss it)
06:31:09 <hodapp> calling everyone stupid for not helping him rewrite it
06:31:21 <Taneb> Remember the time there was a troll in here and he ended up learning Haskell?
06:31:25 <hodapp> guy sounded like he was about 15
06:33:05 <armlesshobo> I'm 15 and que es este?
06:33:22 <hodapp> Hrm?
06:36:13 <eikke> Taneb: yeah, that was funny
06:36:35 <hodapp> Taneb: what's this?
06:38:56 <neutrino_> Taneb: you mean kmc?
06:39:13 <neutrino_> *rimshot*
06:39:27 <armlesshobo> ewww. gross
06:39:40 <hodapp> armlesshobo: what?
06:47:46 <pjdelport> Taneb: What happened?
06:47:57 <pjdelport> (if it's not a long story)
06:48:30 <Taneb> Someone joined #haskell and sad something along the lines of "haskell sucks and you all suck"
06:48:34 <neutrino_> pjdelport: i guess watch the first part of 2001 by kubrick
06:48:45 <Taneb> There weren't any ops around or something
06:48:53 <pjdelport> neutrino_: haha
06:48:58 <Taneb> So people just started telling him why Haskell doesn't suck
06:49:25 <Taneb> And eventually he said something like "okay, maybe I should learn Haskell?"
06:49:34 <Taneb> And disappeared, never to return again
06:49:34 <neutrino_> haha.
06:49:38 <Mortomes|Bus> Just he should learn Haskell
06:49:40 <neutrino_> into the mist?
06:52:05 <Taneb> Of course, he probably was just looking for an excuse to get out of the channel without looking like a wimp
06:53:14 <Taneb> And it would have been a lot less disruptive if someone had just kickbanned him at the off
06:56:17 <typoclass> Taneb: i dunno. i don't think #haskell has a problem with frequent disruptions
06:56:40 <pjdelport> heh
06:56:44 <pjdelport> #haskell :: Troll -> Newbie
06:56:46 <Taneb> Well, we've just gone on a wild tangent
07:01:48 <hodapp> #haskell seems to attract its share of trolls
07:01:59 <hodapp> but I suppose it's better than #c and #java and #c++ where the trolls are the ops
07:08:55 <typoclass> hodapp: well we have some people who are experts in the art of the grumpy useless answer. -- in my opinion trolls are not a big problem for #haskell. it's all pretty infrequent and manageable
07:10:38 <hodapp> typoclass: #java and #c++ can be curious beasts in that to ask a legitimate question, the first thing you have to do is verbally harass the shit out of whoever is trying to dismiss your question, and keep doing this until they back off and people pay attention.
07:11:25 <hodapp> and I have still never managed to make this work for any sort of conceptual question. They refuse to touch a conceptual question because it has no test case.
07:11:26 <typoclass> hodapp: sounds like a place which no reasonable person would enjoy
07:12:28 <hodapp> #java once tried to chase me out over the question: is there a programmatic way to get the current class name from inside a static function of that class
07:13:50 <pjdelport> hodapp: obligatory http://stackoverflow.com/a/6962779/444705
07:15:12 <hodapp> that is awful
07:15:14 <mauke> hodapp: what is that good for?
07:15:43 <hodapp> mauke: I was trying to save time in some boilerplate code for error logging by having it be aware of what class was producing it
07:15:47 <pjdelport> scaring small children
07:16:01 <hodapp> it's trivial in Python
07:16:31 <mauke> why not hardcode it?
07:17:06 <hodapp> I was aiming to make it something that could just be copied-and-pasted between files and not require manual changes from me
07:17:38 <mauke> ew
07:18:02 <eikke> you want macros? :p
07:19:05 <Mortomes|Bus> I got banned from ##c++ once for changing my nick.
07:19:40 <simukis_> well, people tend to be rather hot-headed there.
07:19:46 <hodapp> I got banned from #java for asking a question about Ant instead of switching the entire build to Maven.
07:19:55 <johanbev> i'd get angry too, if i did c++ all day
07:19:56 <Mortomes|Bus> Because a nickchange was just too annoying amidst the flood of join/parts :P
07:20:16 <hodapp> johanbev: you either get angry, or you get Stockholm Syndrome.
07:20:22 <mauke> Mortomes|Bus: do you use [away] nicks or something silly like that?
07:20:29 <johanbev> :)
07:20:30 <simukis_> because haskell comunity is too gentle.
07:20:42 <hodapp> too gentle, yet somehow lots of people can't handle Haskell :)
07:20:52 <hodapp> ...says the guy who's still learning it. Slowly.
07:21:04 <johanbev> c++ is the only language i know that i dont have on my CV / refuse to work with
07:21:14 <johanbev> i guess i got angry then :)
07:21:30 <simukis_> hodapp: it works like a filter for people who can't handle some tension 😃
07:21:36 <hodapp> I'm with Linus Torvalds on C++.
07:21:59 <mauke> I'm with the people in #c++ by default
07:22:00 <hodapp> in part because his response on that mailing list is one of the epic smackdowns of all times.
07:22:18 <mauke> and probably also #java
07:22:27 <simukis_> Can I see that one?
07:22:30 <hodapp> I'm not, because they're complete and utter dicks.
07:22:59 <typoclass> simukis_: i think it works towards filtering out reasonable, mature people
07:23:04 <mauke> .oO( no, john. you are the dicks. )
07:23:43 <mauke> simukis_: http://thread.gmane.org/gmane.comp.version-control.git/57643/focus=57918
07:24:09 <simukis_> typoclass: you're saying most of academia working with haskell is not reasonable and/or mature?
07:24:32 <hodapp> mauke: No, the dicks are in the channel, and they are dicks for the incredibly dismissive, condescending approach they take to basically everyone, not just me; an approach that I simply do not see in a lot of other language channels.
07:25:12 <hodapp> mauke: I actually *know* C++, Java, and C, and they treat me that way. In other language channels where I don't even know the language, I don't get responses like that.
07:25:18 <simukis_> well I myself not am academia or mature person, so I can't say anything about that though :(
07:25:21 <elliott> (maybe take this to -blah?)
07:25:31 <mauke> hodapp: I am one of the dicks
07:25:38 <hodapp> I'm Haskell-tarded, and I don't get treatment of that sort in here.
07:26:34 <mauke> hodapp: do you actually know C or do you only think you know C?
07:26:44 <typoclass> simukis_: erm, i may have misunderstood you. i meant that in other irc channels, the irritating impolite tone will cause reasonable people to stop using that channel. you can guess what kind of people remain there, over time. #haskell is a pleasant exception
07:27:22 <hodapp> mauke: I know it well enough to not justify the treatment received in that channel.
07:27:32 <mauke> meh
07:28:13 <hodapp> which usually came either from that old fart PoppaVic who was not even sober half the time, or that pseudo-intellectual prick Zhivago.
07:28:28 <quchen_> (maybe take this to -blah?)
07:28:32 <elliott> can we not do off-topic personal insults?
07:28:43 <mauke> yes
07:28:56 <simukis_> typoclass: oh. We agree with each other then.
07:29:08 <hodapp> ...what is a typoclass?
07:31:36 <tromp_> a class of typos
07:31:52 <typoclass> hodapp: nothing in particular :-) a pun on typeclass *shrug*
07:32:24 <Taneb> What's a Taneb? Nobody knows
07:32:31 <Taneb> Sometimes he comes, sometimes he goes
07:33:00 <tromp_> sometimes he pulls a fast norah
07:33:04 <Taneb> What's a Taneb? I've no idea
07:33:12 <Taneb> Is he far away, or is he near?
07:34:45 <Taneb> Do the definitions of Monad and Comonad in terms of Free and Cofree enforce the Monad and Comonad laws?
07:35:25 <Taneb> ...no, I don't think they do
07:38:34 <elliott> Taneb: I think you end up with just one law for both
07:38:38 <elliott> but I don't know exactly what it is
07:40:56 <simon> @pl \_ x -> x+1
07:40:56 <lambdabot> const (1 +)
07:41:31 <satc> Is there a way to make let bindings strict ??
07:41:37 <satc> an easy way
07:42:00 <Fuuzetsu> BangPatterns with a type signature?
07:42:41 <satc> example let a = b `xor` c `xor d in something ??
07:43:00 <typoclass> satc: have a look at this http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/bang-patterns.html
07:43:01 <satc> Fuuzetsu: What to do in the above ^^
07:43:29 <simon> satc, why do you need them to be strict if there are no side-effects? performance
07:43:32 <simon> ?
07:44:31 <magicman> @pl \_ x -> x-1
07:44:31 <lambdabot> const (subtract 1)
07:44:54 <magicman> Huh. It assumes commutativity of (+). Not sure if like.
07:45:30 <elliott> howso?
07:45:35 <elliott> subtract m n = n - m
07:45:37 <magicman> @pl \_ x -> x+1
07:45:37 <lambdabot> const (1 +)
07:45:41 <elliott> oh, sure
07:45:48 <magicman> Instead of, what I expected, const (+ 1).
07:46:02 <satc> simon:  yes. I know that the let binding I am assigning is surely to be evaluated so I don't want a thunk to be created for that
07:46:19 <elliott> forcing evaluation doesn't avoid thunks
07:46:55 <elliott> i mean, not necessarily
07:47:27 <satc> elliott: Can you elaborate ??
07:47:31 <typoclass> satc: strictness may or may not be what's needed in your case. it's hard to tell. do you have some code to put on hpaste.org?
07:47:53 <elliott> satc: generally you want a strictness annotation when you're *not* about to evaluate something
07:48:00 <elliott> e.g. when you are instead going to stuff it into a data structure or such
07:48:09 <elliott> why do you think you need one?
07:49:21 <simon> elliott, ah. because thunks are a sort of data structure, and you explicitly want it stored differently.
07:49:39 <elliott> I'm not quite sure what you mean by that
07:49:54 <simon> elliott, never mind. :)
07:50:37 <simon> elliott, I just imagine that the tree of thunks is one way to store a computation, and the strict computation of it, that ends up in whatever data structure you intended, is probably a more efficient way.
07:50:41 <supki> I can't make sense of that xor example
07:50:47 <supki> is there a type with lazy xor
07:50:48 <supki> ?
07:51:04 <simon> supki, what do you mean?
07:51:53 <supki> ok, if xor is strict, what does it mean to "make let a = b rc r d in something" strict?
07:52:14 <supki> uh, paste issues
07:52:20 <elliott> supki: presumably, replacing something with a `seq` something or equivalent
07:52:21 <supki> pretend there are `xor` there
07:52:25 <elliott> but this is probably pointless
08:15:30 <beaky> hello
08:15:59 * hackagebot rdioh 0.2.0 - A Haskell wrapper for Rdio's API.  http://hackage.haskell.org/package/rdioh-0.2.0 (AdityaBhargava)
08:16:04 <appliciative> hello
08:16:04 <beaky> what is the difference between a functional programming language like Haskell and a procedural programming language like C?
08:16:32 <appliciative> in Haskell you don't write like Betty Crocker
08:16:40 <beaky> betty crocker? :D
08:16:53 <appliciative> hah, an old cookbook writer
08:17:35 <beaky> ah
08:17:58 <beaky> that fictional woman in those american cake mixes?
08:17:59 <mauke> beaky: if you knew the answer, what would you do with it?
08:18:25 <appliciative> increment x; while the onions boil, stir y gently
08:18:30 <beaky> knowing the answer would improve my understanding of programming
08:18:37 <beaky> and I will be empowered to write elegant programs
08:18:39 <appliciative> beaky: yes fictional
08:19:07 <mauke> beaky: I doubt it
08:19:16 <beaky> ah :(
08:19:21 <mauke> what does this have to do with writing elegant programs?
08:19:58 <beaky> most of my code is imperative and hard to understand
08:20:12 <typoclass> beaky: it's hard to nail down what exactly makes a language 'functional'. i don't think there's a strict definition. it's basically a rough grouping of languages.
08:20:19 <beaky> because it carries a lot of state around that is passed through structs or hidden in global variables and arrays
08:20:28 <beaky> in non-haskell languages*
08:20:31 <beaky> ah
08:21:08 <pjdelport> beaky: There are *many* differences. The most salient one is probably that Haskell uses non-strict evaluation, while C uses strict. (This has many implications on each language's style.)
08:21:12 <sclv> functional languages have first class functions
08:21:15 <appliciative> that an extended IO action 'carries a lot of state around' is ok
08:21:25 <beaky> ah
08:21:40 <sclv> that's really all you need, i think
08:21:40 <typoclass> beaky: ... and there's cross-references. languages that aren't normally called functional are regularly adopting functional features (obj-c getting something similar to anonymous functions, c# getting a little bit of type inference, etc.)
08:22:05 <sclv> ML-family functional languages have algebraic data types, etc. as well. but i don't think that's necessary to the definition
08:22:16 <sclv> otherwise we can't say we're treating, e.g., scheme, as a functional language.
08:22:44 <pjdelport> After that, the biggest difference is probably that Haskell uses relatively strong typing (in the sense that Haskell's type system is very powerful, and drives a lot of its style), while C's typing is relatively weak.
08:22:48 <appliciative> but it's not clear beaky is interested in what 'functional' means , really
08:23:01 <beaky> I wanna know what functional really means :(
08:23:12 <appliciative> it really means: lisplike
08:23:15 <beaky> I always keep hearing it defined as "programming in terms of math"
08:23:19 <typoclass> sclv: roger, got it, if it has "\" it's a functional language ;-)
08:23:23 <appliciative> so it's not too interesting, really
08:23:30 <elliott> it means whatever the writer wants it to mean
08:23:50 <beaky> so it actually means "programming with first-class functions and pure functions"?
08:23:56 <sclv> typoclass: basically, yeah. its pretty broad imho. i prefer more specific terms to capture other elements of what we take for granted in the "FP" community
08:24:00 <elliott> if that is what you want it to mean
08:24:06 <appliciative> purity is the thing you are interested in
08:24:07 <sclv> beaky: not necessarily pure. haskell is. but ML isn't, and scheme isn't
08:24:17 <pjdelport> beaky: "Functional" doesn't have just one specific definition. It's like how "object oriented" can mean anything from C++ to Smalltalk to C
08:24:32 <beaky> right
08:24:34 <appliciative> functional-ness doesn't mean anything; purity is something worth thinking about
08:24:41 <pjdelport> s/C/Python, etc./
08:24:49 <beaky> if I wrote my functions in C to be pure, maybe I will have a better life
08:25:04 <sclv> well, functional-ness doesn't mean anything except for those languages that can't even do basic first class functions and then you miss it like crazy
08:25:14 <appliciative> ha, good luck.  they do give you + * -
08:25:22 <beaky> in OOP languages I try to emulate first-class functions with objects
08:25:30 <sclv> you can make them observationally pure
08:25:45 <appliciative> in haskell beaky, every function is like + * - etc
08:26:30 <appliciative> 'everything is an expression'
08:26:31 <beaky> even functions with an IO value?
08:26:43 <appliciative> you mean the return one? yeah
08:27:11 <appliciative> [putChar 'a', putChar 'b'] what does that do, its just another item like ['a','b']
08:27:20 <typoclass> beaky: sclv's definition is probably the main part. "it has closures". that in turn leads to a number of other things, for example representing loops typically as "map toUpper ...", because an extra construct like for (...; ...; ...) { ... } isn't needed
08:28:43 * Kinnison wonders if there's any parsec gurus here.  I have an "I was wondering" type question about building a parser when I already have a lexer
08:29:51 * Kinnison is trying to work out how to take a (lexer :: [Token]) where Token carries both the content of the token and its source position in some form. and produce something which can be used in a Parsec parser
08:29:54 <beaky> ah
08:30:03 <beaky> how does one do nested for loops in haskell?
08:30:09 <beaky> or something to that effect
08:30:27 <mm_freak> lens:  when both mapped and traverse are possible, which one is preferable?
08:30:29 <beaky> e.g. to print the multiplication table
08:30:59 <mm_freak> beaky: something like…
08:31:09 <mm_freak> > liftA2 (*) [2,3,5] [10, 100, 1000]
08:31:10 <lambdabot>   [20,200,2000,30,300,3000,50,500,5000]
08:31:11 <mm_freak> ?
08:31:35 <appliciative> @type forM
08:31:37 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
08:31:46 <beaky> ah
08:31:48 <beaky> wow that is awesome
08:32:27 <beaky> so a for-loop becomes just an ordiary function :D
08:32:38 <mm_freak> map may be a better approach, if you want an actual matrix
08:32:56 <pjdelport> beaky: with non-strict evaluation, many control structures become plain functions
08:33:15 <mm_freak> > map (\x -> map (x*) [2, 3, 5]) [10, 100, 1000]
08:33:16 <lambdabot>   [[20,30,50],[200,300,500],[2000,3000,5000]]
08:33:34 <mm_freak> beaky: in haskell all control structures are regular functions
08:33:50 <mm_freak> including exception handling, goto if you will, …
08:34:04 <beaky> if haskell wasn't non-strict (like majority of functional programming languages out there), can it still emulate things like conditional branching or for loops as functions?
08:34:20 <mm_freak> beaky: non-strict haskell doesn't really work
08:34:25 <beaky> ah :(
08:34:28 <mm_freak> strict haskell
08:34:32 <pjdelport> > [print "zero!", print "one!"] !! 0
08:34:32 <beaky> non strictness is awesome
08:34:33 <Fuuzetsu> it's called ML
08:34:34 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
08:34:34 <lambdabot>    arising from a use of ...
08:34:47 <pjdelport> phooey
08:34:47 <mm_freak> IO relies heavily on non-strict semantics to work the way it does
08:34:50 <appliciative> > forM [2,3,5] $ \n -> forM [10,100,1000] $ \m -> [m*n]
08:34:52 <lambdabot>   [[[20,200,2000],[30,300,3000],[50,500,5000]]]
08:35:07 <mm_freak> also other monads
08:35:15 <pjdelport> why doesn't that work in lambdabot?
08:35:18 <mm_freak> > execWriter (forever $ tell "abc")
08:35:19 <lambdabot>   "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
08:35:32 <appliciative> pjdelport: print doesn't work. it's IO
08:35:44 <typoclass> pjdelport: IO is disabled, otherwise you could do all kinds of stuff on the server that lambdabot is running on
08:35:45 <appliciative> print is what lambdabot or ghci itself does, as you might say
08:36:12 <pjdelport> okay :)
08:36:33 <elliott> monochrom: re your cabal-cabal.xhtml, do you know of a nice way to get source links in documentation without annoying bootstrapping? ...when installing cabal-install, it builds packages without documentation. in the past I've installed hscolour manually and edited bootstrap.sh to use it every time, but this is very annoying
08:36:41 <elliott> monochrom: and I guess the docs that come with GHC still won't have it :/
08:36:42 <pjdelport> beaky: well, in ghci, or your own code, you can do stuff like: [print "zero!", print "one!"] !! 0 -- prints zero!
08:36:44 <mm_freak> > let x = forkIO x >> forkIO x in x
08:36:45 <lambdabot>   Not in scope: `forkIO'Not in scope: `forkIO'
08:36:48 <mm_freak> (do not try this at home)
08:36:54 <pjdelport> or [print "zero!", print "one!"] !! 1 -- prints one!
08:38:08 <appliciative> pjdelport in [print "zero!", ([print "zero!", print "one!"] !! 1)] !! 0
08:38:17 <appliciative> it prints zero
08:39:00 <appliciative> which is the same point of course
08:40:05 <appliciative> imperatives don't compose, except in the ways discovered by cookbook writers; so to heck with them
08:41:15 <mm_freak>     censoring (cssProps . mapped . mapped . propSelector . selectorStr)
08:41:20 <mm_freak> 'traverse' is also possible
08:41:20 * elliott wonders the significance of appliciative's additinoal i
08:41:25 <mm_freak> should i prefer traverse over mapped?
08:41:57 * appliciative thinks elliott should be more appliciative 
08:42:22 <beaky> The C++ programming language inspired my interest in functional programming
08:42:37 <mm_freak> appliciative: i think your example is a type error
08:42:42 <appliciative> I figure since the many are folding class Applicative into class Monad, I need a new class
08:43:10 <appliciative> type error, me?
08:43:16 <mm_freak> <appliciative> pjdelport in [print "zero!", ([print "zero!", print "one!"] !! 1)] !! 0
08:43:32 <mm_freak> oh
08:43:33 <appliciative> oh yeah, need [] around the first one
08:43:39 <appliciative> wait no
08:43:41 <mm_freak> no, i misread…  it's not a tuple
08:43:49 <elliott> appliciative: how about "idiomatic"?
08:44:01 <appliciative> yeah the parens are unneeded
08:44:05 <mm_freak> i'll go with 'mapped'
08:44:10 <mm_freak> i love functors a lot more than lenses =)
08:45:13 <appliciative> elliott: yes, then we add in the documentation the rule "if the type f is also a monad, then <#*#> must not be `ap`"
08:45:26 <elliott> I meant as a nick :p
08:45:59 <elliott> the nice thing about "idiomatic" is that it sounds like a machine which produces idiots
08:46:11 <typoclass> elliott: =)
08:46:14 <quchen> Oh, it's this time of the day again.
08:49:01 <applicative> I have a new theory, quchen we add class Appliciative with liftAppliciative2 and so on; then we  make it a constraint of MonadZip, same as we make Alternative a constraint on MonadPlus
08:49:06 <applicative> it makes so much sense!
08:49:47 <quchen> Great, write up a proposal and send it to the list. I'm done discussing this.
08:50:26 <applicative> then we get idiom brackets for free when we realize that parallellistcomp is idiom brackets, or rather applicative do.
08:50:40 <applicative> only of course, you can't use the new deranged applicative class
08:51:09 <applicative> quchen: well, we wont be tired of suffering it for some years
08:58:22 <enthropy> applicative: there are quasiquoters for those things
08:59:04 <applicative> me has a new plan, we keep applicative as it is,but make the IO instance what it ought to be, `(($).). concurrently`
08:59:28 <applicative> then we make the alternative instance `race` from async too.
08:59:55 <applicative> then the Prelude contains the most advanced concurrent language in the world.
09:00:25 <applicative> it even has special notation for async actions, once we give a MonadZip instance for IO
09:02:43 <applicative> but it would probably confuse people if you could do things asynchronously like so http://hpaste.org/89495
09:03:09 <applicative> note that each | ... can support a do block
09:03:20 <applicative> flipped the >>= damn
09:04:18 <applicative> there thats better
09:05:24 <applicative> parallel and concurrent applicative instances must be banned!
09:06:02 * hackagebot husk-scheme 3.10 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.10 (JustinEthier)
09:06:18 <applicative> monadic sequentiality must pervade everything!
09:06:45 <applicative> otherwise we have to write things twice!
09:09:50 <applicative> why we were writing sequential 'code' in parallel style, God knows, but we like it
09:14:34 <joelteon> this is what I get when running ghci (with cabal-ghci) in my project: https://gist.github.com/anonymous/14035bef9a596b564b29
09:14:51 <joelteon> the cabal file in question: https://github.com/joelteon/lexie/blob/master/lexie.cabal
09:15:30 <applicative> is base in your cabal file
09:15:31 <applicative> oh
09:16:27 <applicative> hm, I wonder if it's that there's just an executable not a library?
09:16:49 * applicative speculates wildly
09:25:39 <elliott> monochrom: hm, and also, isn't turning profiling on in ~/.cabal/config not enough? because the libraries it installed as part of the bootstrap do not have profiling
09:25:42 <merijn> applicative: You argued the same thing yesterday and I still think it's a bad idea :p
09:26:18 <merijn> applicative: I'll give you an example that breaks: "login <$> promptUserName <*> promptPassword"
09:27:12 <beaky> I like that ability of Haskell to elegantly compose I/O actions
09:27:23 <applicative> liftM2 login promptUserName promptPassword
09:27:38 <beaky> whereas in less sophisticated programming languages you would use semicolons
09:27:49 <merijn> applicative: liftM2 is the same unless you break the monad laws
09:27:55 <applicative> login <$> promptUserName `ap` promptPassword is what you actually meant
09:28:08 <merijn> That's awful
09:28:20 <elliott> omg, are we going to do this every day?
09:28:41 <elliott> can we schedule it at a predetermined time? :)
09:28:47 <joelteon> applicative: maybe it's that :<
09:29:09 <joelteon> but it used to work...
09:29:18 <simon> beaky, my department's student revue had a chance to interview Bjarne Stroustrup, and one of the questions we asked became "Why didn't you overload the ; operator?"
09:29:31 <beaky> haha
09:29:33 <applicative> oh maybe that's not it then joelteon I was going to say try this http://hpaste.org/89497
09:29:51 <applicative> i was going to test it but i dont' have enough libs
09:29:57 <joelteon> i do!
09:30:03 <beaky> they permit overloadig commas and parentheses
09:30:30 <joelteon> :set "-package=readline-*** Exception: Prelude.head: empty list
09:30:32 <joelteon> ...oh god
09:30:33 <simon> beaky, I don't think imperatists usually regard ; as an operator. :P
09:30:37 <merijn> applicative: What's wrong with just newtyping IO and writing that instance yourself? I don't see the problem with that
09:30:52 <merijn> applicative: Why break all existing Haskell code for something you think would be neat?
09:31:20 <merijn> Especially since it's only like 10 lines of code to do it that way
09:31:27 <applicative> whats wrong with the applicative and alternative -- and implicitly monadplus -- instances for IO in the async library?
09:32:09 <elliott> obviously changing the Applicative instance for IO at this point is a non-starter, given that it already exists
09:32:13 <elliott> and is in use
09:32:39 <applicative> oh, we me mustn't break any libraries
09:32:56 <merijn> applicative: Not gratuitously for no good reason, no
09:33:06 <applicative> there is a curious combination of practicality and theoretically-challenged purism about this
09:33:16 <merijn> applicative: There is absolutely no good reason for your instance, considering you could already do it in almost no effort
09:33:24 <elliott> "theoretically-challenged purism"...
09:33:42 <applicative> the aync instances of applicative, alternative and monadplus are obviously the correct ones
09:34:39 <merijn> applicative: You're in the minority and you can already do what you want, why make the majority change for you?
09:34:43 <applicative> an alternative and monad plus instance for io is impossible under the new scheme, in the sense that it's ruled out by the classes
09:34:47 <elliott> so obvious we need to argue about it daily :)
09:35:04 <merijn> Ok, I'm out this discussion is boring and has no progress
09:35:07 <quchen> This isn't an argument, this is feeding.
09:35:11 <quchen> Don't feed.
09:35:21 <applicative> hilarious
09:36:39 <applicative> if the scheme was accompanied by a new class for applicative and alternative, without this monad connection, it wouldn't be bad
09:37:37 <applicative> but even then monadplus would have to be detached from the going alternative, which is tied to the wrong applicative
09:41:03 * hackagebot transf 0.8 - Text transformer and interpreter.  http://hackage.haskell.org/package/transf-0.8 (HansHoglund)
09:42:31 <applicative> "I am excited about this proposal, and I really hopes it will be performed. I have been following the discussion for a long time, always perceiving
09:42:34 <applicative> that Applicative as a superclass of Monad is the right thing to do. As a consequence, Functor will also be a superclass of Monad. This changes may affect my code, but I will be glad to make any changes."
09:42:45 <applicative> its like all in a sequence, it makes so much sense!
09:43:01 <elliott> come on.
09:43:31 <applicative> applicative, it's kind of half-way to monad from functor
09:43:59 <applicative> since after all <*> = ap, as we always write
09:44:13 <elliott> you've made your point
09:45:23 <monochrom> elliott: you're right. this is going to be bad.
09:47:42 <elliott> monochrom: it feels like the GHC binary docs should come with source code links, and cabal's bootstrap process should be flexible enough to tell it to do profiling and source links (without doing it manually by editing bootstrap.sh and messing with environment variables), but oh well
09:48:21 <elliott> monochrom: for now, I have decided to install the platform instead. since it just came out it isn't behind on GHC like usual, and if I remember correctly it has good documentation and comes with profiling libraries without tweaking anything
09:50:47 <enigmuriatic1> what's the best way to ignore System.Cmd.rawSystem's "ExitSuccess" response when i'm trying to use the result in another command?
09:51:48 <efie> could someone help me with this? http://hpaste.org/89498
09:52:06 <josephle> is the ExitSuccess just a unix signal?
09:53:21 <tromp_> efie, what type do you want logFloat x to be?
09:54:38 <applicative> efie: you have a multi-parameter typeclass governing logfloat?
09:54:51 <tromp_> why don't you try without the fromLogFloat?
09:55:48 <joelteon> applicative: listing a library didn't help :<
09:55:49 <elliott> monochrom: actually, I may be mistaken. my installed HP has docs for GHC and profiling libraries, but no docs for the additional libraries
09:56:01 <elliott> now I am very confused
09:56:28 <efie> tromp_: I thought the type is  LogFloat  and I don't have to specify it further
09:57:45 <applicative> oh i thought logFloat was a method of (Real a, Transfinite a, Fractional b, Transfinite b) => RealToFrac a b  ; (Real a, Fractional a) => RealToFrac a a
09:57:56 <applicative> sorry, of of RealToFrac
09:58:12 <applicative> which has those two overlapping instances.
09:58:45 <applicative> oh so there is a type 'LogFloat'
09:59:23 <applicative> in any case, it seems Data.Number.LogFloat is where the real problems are coming from
10:00:05 <tromp_> oh, the problem is in what type 3 should be
10:00:30 <applicative> that's one thing. if you mark it does the error go away?
10:00:30 <tromp_> try (3::Double) ?!
10:00:53 <applicative> theres still the question what the type of the next expressions composed is
10:01:24 <efie> yes, with (3::Double) the error goes away, and I have do delete "{-# IncoherentInstances #-}" from the top of the file
10:01:37 <efie> thank you
10:02:03 <enigmuriatic1> sorry, i lost power briefly. can someone copy and paste the answer to my previous question?
10:02:14 <applicative> this can't get rid of the fact that you have overlapping instances
10:03:19 <applicative> isn't ExitSuccess just an element of a tuple enigmuriatic1 ? let me see
10:03:31 <enigmuriatic1> applicative, i dont think so
10:04:19 <enigmuriatic1> System.Cmd.rawSystem :: String -> [String] -> IO GHC.IO.Exception.ExitCode
10:04:29 <enigmuriatic1> applicative
10:04:37 <applicative> oh i was thinking of the ones in System.Process.
10:04:48 <applicative> to ignore it, don't you just ignore it?
10:04:48 <enigmuriatic1> are those preferable?
10:05:06 <enigmuriatic1> maybe, actually, i'll check
10:05:40 <applicative> it's not like you have to do anything with the exitcode, anymore than with the thread id when you forkIO
10:05:45 <enigmuriatic1> applicative, what kind of data structure is GHC.IO.Exception.ExitCode? i don't understand how it holds the response as well
10:05:53 <enigmuriatic1> i don't know what forkIO is :P
10:06:42 <applicative> by response do you mean something like a string resulting from the action you told the system to do?
10:07:10 <enigmuriatic1> yes, applicative
10:07:42 <applicative> oh then you do want System.Process, this is a sort of quick and dirty interface to System.Process
10:08:09 <applicative> you just issue commands get the exit code if you like; you never get actual data back
10:08:25 <applicative> but i haven't tried this for a while, so maybe i'm hallucinating
10:09:09 <applicative> enigmuriatic1: the expressions defined in System.Process have all sorts of Handles connected with them. If you want something from one of them, you use it
10:09:50 <enigmuriatic1> applicative, is there any reason why Real Wold Haskell used System.Cmd instead? is there any kind of community consensus between the two?
10:11:40 <monoidal> System.Cmd is deprecated in favor of System.Process
10:12:01 <enigmuriatic1> oh nice, thanks monoidal
10:12:05 <geekosaur> RWH is somewhat dated at this point. The Process stuff was refactored and rearranged after RWH was published
10:12:09 <josephle> enigmuriatic1: note the date when real world haskell was published. A lot has been done to improve the haskell codebase since then :)
10:12:09 <enigmuriatic1> is there any central source of those kinds of things?
10:12:45 <applicative> enigmuriatic1: here's a simple use of System.Process from the typeof package http://hpaste.org/89499
10:12:50 <geekosaur> btw, the online version of the book includes annotations with this kind of thing
10:13:06 <applicative> it goes to ghci and gets the type of an expression
10:13:06 <enigmuriatic1> as a side note, i still don't understand how the ExitCode data type stores the response. it's defined here: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/GHC-IO-Exception.html
10:13:10 <geekosaur> so even if you own the book you may want to have the online one open
10:13:24 <enigmuriatic1> but i don't see where it has the String stored
10:13:40 <geekosaur> what string?
10:13:46 <applicative> It doesn't store a string, it's just the ExitCode
10:13:47 <geekosaur> it's a unix wait status
10:14:09 <geekosaur> more precisely, the thing you pass to the libc exit() function
10:15:11 <applicative> enigmuriatic1: the system.cmd things are for telling the system to do IO () things, so to speak
10:15:16 <elliott> ugh. Agda won't install with latest Platform.
10:15:19 <elliott> wants a too old QuickCheck
10:15:41 <c_wraith> ...  it really shouldn't depend on quickcheck anyway
10:15:45 <applicative> well if agda were included in the Haskell Platform this wouldn't be a problem
10:16:02 <elliott> c_wraith: yes, well... tell them that...
10:16:18 <elliott> perhaps I will fetch it from darcs
10:16:34 <c_wraith> elliott: cabal unpack
10:17:05 <applicat1ve> this proof is water-tight in 1000 cases!
10:17:09 <elliott> c_wraith: well, the bounds are right in the darcs version, looks like. patching .cabal files makes me nervous
10:17:29 <c_wraith> applicat1ve: sounds good enough
10:17:39 <enigmuriatic1> geekosaur, the variable you bind the rawSystem function to does indeed store the response of the shell command
10:18:35 <geekosaur> um, no?
10:19:04 <geekosaur> rawSystem behaves like system functions in most languages, the executed program's stdin and stdout are those of the invoking program
10:19:53 <monoidal> rawSystem returns the exit code
10:19:59 <enigmuriatic1> Oh, i see geekosaur
10:20:20 <enigmuriatic1> it just printed to stdout, but looked like it came from my print call
10:21:05 * hackagebot ajhc 0.8.0.5 - Haskell compiler that produce binary through C language  http://hackage.haskell.org/package/ajhc-0.8.0.5 (KiwamuOkabe)
10:22:44 <monoidal> elliott: https://code.google.com/p/agda/issues/detail?id=864
10:25:12 <spots> hi, i'm trying a haskell tutorial and get the following error "Failed to load interface for `Char'". Can anyone help here?
10:25:42 <monoidal> spots: Use Data.Char instead. But that means the tutorial is very old
10:26:03 <elliott> monoidal: thank you for the link. sounds like I should wait for a release
10:26:39 <spots> thanks, that works, but why does the tutorial miss the leading Data.?
10:26:51 <monoidal> spots: in the very very old times, the module was called Char
10:26:53 <elliott> because it used to be Char
10:26:59 <elliott> you should likely read another tutorial
10:27:27 <spots> ok, thanks for the info :)
10:27:49 <NinjaPenguin> Why did it change from Char to Data.Char?
10:28:46 <elliott> because modules grew dots
10:29:28 <seliopou> anybody know if the 64 bit version of ghc on os x is still a mess?
10:29:44 <enigmuriatic1> what is the purpose of the type System.Command.ProcessHandle?
10:34:17 <enthropy> is it possible to write a monadic version of Data.Generics.Schemes.everythingBut  (possibly everythingM with Cont?)
10:39:38 <Athas> Does GHCi use a different parser than GHC?
10:39:50 <Athas> I have a program that works fine in GHCi, but fails in GHC.
10:40:08 <zomg> It's the same but there are some syntactical differences due to how GHCi works
10:40:13 <enigmuriatic1> what's the most readable way to remove the last two chars from a String?
10:40:28 <enigmuriatic1> *(also efficient)
10:40:36 <joelteon> take (length xs - 2) xs
10:40:38 <Athas> The problem seems to be a do-statement going 'foo $ \x -> do', followed by a linebreak, with the next line having the same indentation as 'foo'.
10:40:45 <Athas> The strange thing is that I'm using :load in GHCi.
10:41:03 <joelteon> @pl \xs -> take (length xs - 2) xs
10:41:03 <lambdabot> take =<< subtract 2 . length
10:41:12 <joelteon> huh, I kind of like that
10:41:20 <joelteon> it's obvious what subtract 2 . length does
10:41:26 <joelteon> and take =<< is aesthetically pleasing
10:41:45 <int-e> @type ap (zipWith const) (drop 2)
10:41:46 <lambdabot> [b] -> [b]
10:42:16 <int-e> > ap (zipWith const) (drop 2) [1..]
10:42:17 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:42:20 <Athas> enigmuriatic1: the real solution is to not use Strings if performance is important.
10:42:31 <int-e> > ap (zipWith const) (drop 2) [1..5]
10:42:33 <lambdabot>   [1,2,3]
10:43:16 <enthropy> Athas: that could work if foo isn't itself inside something (say another do block) that has layout
10:43:46 <Athas> enthropy: well, it is.  I'm not wondering why it doesn't work, but why it works when :loaded by GHCi.
10:44:17 <int-e> Athas: are your ghc and ghci the same version?
10:44:30 <Athas> int-e: yes.
10:44:52 <enthropy> there are some extensions related to layout (-XDoAndIfThenElse), but probably those don't apply if you set them in your .ghci
10:45:32 <adnap> I just build GHC and it installed to /usr/local/bin. I have an older version of GHC installed to /usr/bin. I want to install a package with cabal-dev install. How can I get it to use the newer GHC in /usr/local/bin?
10:45:34 <enigmuriatic1> int-e, i'm having a hard time understanding why that works
10:45:36 <int-e> it could be NondecreasingIndentation
10:45:41 <adnap> *built
10:46:05 <monoidal> -XDoAndIfThenElse and -XNondecreasingIndentation are default in GHC
10:46:13 <adnap> I'm not sure if I could just remove /usr/bin from my path because perhaps other programs are needed
10:46:13 <int-e> enigmuriatic1: dropLast2 xs = zipWith const xs (drop 2 xs).
10:46:19 <joelteon> oh, right, int-e's idea works with infinite lists
10:46:22 <joelteon> not that you'd have an infinite stright
10:46:24 <joelteon> string
10:47:11 <enigmuriatic1> int-e, maybe i haven't learned enought to understand what's happening
10:47:23 <joelteon> @unpl ap (zipWith const) (drop 2)
10:47:24 <lambdabot> ((zipWith (\ a _ -> a)) >>= \ c -> (drop 2) >>= \ b -> return (c b))
10:47:31 <int-e> enigmuriatic1: the point is that zipWith stops when either list is exhausted. It will produce elements of the first list (xs) until the second one, (drop 2 xs) is exhausted, and that one is 2 elements shorter.
10:47:32 <enigmuriatic1> i would expect that to give an error because ...
10:47:33 <joelteon> ok, that's garbage
10:47:37 <adnap> Oh, cabal has --with-compiler=<ghc-dir>
10:47:46 <enigmuriatic1> ah yes, i have no idea what >>= is
10:47:58 <spots> re
10:48:11 <enigmuriatic1> int-e, oh right
10:48:14 <spots> why does "square x = x*x" output "parse error on input `='"
10:48:25 <joelteon> spots: in ghci?
10:48:31 <joelteon> let square x = x * x
10:48:42 <joelteon> don't forget the let
10:48:46 <spots> ah ok
10:48:49 <joelteon> if I recall correctly, everything you enter in ghci is actually in the IO monad
10:48:55 <joelteon> and you can't do top-level declarations in a do block
10:48:57 <int-e> spots: or put that line (without the let) into a .hs file and :load it in ghci.
10:49:13 <geekosaur> not everything, but its emulation of top-level-ish stuff is incomplete
10:49:28 <geekosaur> you can do things like import and data (7.4+)
10:49:38 <spots> how can i enter multiline functions in ghci?
10:49:44 <int-e> joelteon: you can also enter non-IO expressions. It's really a different beast.
10:49:47 <geekosaur> see :{
10:49:50 <joelteon> spots: :{ ... :}
10:49:55 <geekosaur> in the ghci help (:help)
10:50:03 <monoidal> spots: either :{ or a semicolon: let f True = 0; f False = 0
10:50:07 <joelteon> yeah, ghci is probably the most complete REPL i've ever used
10:50:50 <adnap> Does cabal have a man page?
10:51:14 <TravisD> I remember reading about a debugging tool called type holes or something, where you could get ghc to tell you the type of expression expected in some place. Is that implemented in ghc 7.6.3?
10:51:42 <monoidal> TravisD: No, will be 7.8
10:51:45 <shachaf> No, -XTypeHoles is only in HEAD.
10:51:50 <shachaf> But you can use -XImplicitParams to similar effect.
10:51:53 <enigmuriatic1> can this be simplified? if so, how? let test xs = (zipWith const) xs (drop 2 xs)
10:52:10 <shachaf> (Why is it called TypeHoles when it's value-level holes? :-( )
10:52:12 <TravisD> Ah, alright. That sounds like a good feature for learning
10:52:17 <monochrom> elliott: the Haskell Platform build script hardcodes "Setup haddock --hyperlink-source". this is a runtime error if it can't find hscolour, causing docs to be not built.
10:52:22 <shachaf> enigmuriatic1: Yes, you can drop the first pair of parentheses.
10:52:25 <monoidal> enigmuriatic1: take (length xs - 2) xs?
10:52:28 <shachaf> enigmuriatic1: Also you can generalize the function.
10:52:29 <adnap> > (zipWith const) xs (drop  2 xs)
10:52:30 <lambdabot>   Not in scope: `xs'
10:52:30 <lambdabot>  Perhaps you meant one of these:
10:52:30 <lambdabot>    `x' (imported from D...
10:52:35 <elliott> monochrom: right
10:52:35 <shachaf> @where dropFromEnd
10:52:36 <lambdabot> see `sneaky'
10:52:40 <shachaf> @where sneaky
10:52:40 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
10:52:41 <int-e> monoidal: but that's less lazy.
10:52:43 <shachaf> monoidal: Not the same.
10:52:46 <c_wraith> monoidal: that's not a simplification, that's a worse algorithm
10:52:50 <adnap> > let x = [1..10] in zipWith const xs $ drop 2 xs
10:52:51 <lambdabot>   Not in scope: `xs'
10:52:51 <lambdabot>  Perhaps you meant one of these:
10:52:51 <lambdabot>    `x' (line 1), `x' (i...
10:52:55 <elliott> monochrom: so um, the right thing is to have an hscolour binary from somewhere and then install HP???
10:52:56 <adnap> > let xs = [1..10] in zipWith const xs $ drop 2 xs
10:52:57 <lambdabot>   [1,2,3,4,5,6,7,8]
10:53:16 <monochrom> or edit the build script to omit --hyperlink-source haha
10:53:19 <adnap> > let xs = [1..10] in zip xs $ drop 2 xs
10:53:20 <lambdabot>   [(1,3),(2,4),(3,5),(4,6),(5,7),(6,8),(7,9),(8,10)]
10:53:29 <enigmuriatic1> adnap, so there's no way to remove the xs?
10:53:29 <monochrom> it depends on whether you want links to source
10:53:36 <shachaf> zipWith /msg lamdabot (drop 20 lambdabot)
10:53:37 <adnap> > let xs = [1..10] in drop 2 xs
10:53:39 <lambdabot>   [3,4,5,6,7,8,9,10]
10:53:51 <shachaf> enigmuriatic1: Other ways to simplify it: test = zipWith const <*> drop 2
10:53:58 <enigmuriatic1> i'm trying to figure out how int-e's first one worked. if it used monads or monoids, though, i won't (haven't learned those yet)
10:54:00 <adnap> > let xs = [1..10] in init . init $ xs
10:54:01 <lambdabot>   [1,2,3,4,5,6,7,8]
10:54:07 <shachaf> But I don't recommend that. Just make a function called dropFromEnd, add the explicit argument, and leave it at that.
10:54:25 <c_wraith> enigmuriatic1: making something point-free doesn't necessarily make it simpler.
10:54:38 <shachaf> This is a good function and it's complicated enough without the extra complexity.
10:54:52 <adnap> So, is init . init slower?
10:55:08 <shachaf> It is wronger.
10:55:16 <adnap> Why?
10:55:25 <elliott> did you look at lambdabot's response?
10:55:33 <spots> hmm, how to write a fibonacci in ghci?
10:55:34 <arkeet> it calculates the wrong thing.
10:55:43 <monochrom> if it gives a wrong answer, don't worry about its speed.
10:56:00 <shachaf> adnap: That's left as an exercise for the reader. Think about edge cases etc.
10:56:01 <arkeet> unless you want to drop from end.
10:56:07 * hackagebot rdioh 0.2.1 - A Haskell wrapper for Rdio's API.  http://hackage.haskell.org/package/rdioh-0.2.1 (AdityaBhargava)
10:56:12 <shachaf> And think in /msg with lambdabot, not in #haskell. :-)
10:56:13 <arkeet> and then it blows up sometimes.
10:56:27 <enigmuriatic1> yeah, i'm just using this as a way to play with functions at this point
10:56:29 <adnap> > let xs = [1..10] in zipWith const xs (drop 2 xs)
10:56:31 <lambdabot>   [1,2,3,4,5,6,7,8]
10:56:35 <adnap> That's what was originally posted
10:56:46 <enigmuriatic1> it irritates me that int-e's first example worked but that i can't understand it
10:56:53 <adnap> > init . init $ [1..10]
10:56:54 <lambdabot>   [1,2,3,4,5,6,7,8]
10:56:59 <monoidal> init . init seems correct to me (note it crashes on lists <2)
10:57:23 <adnap> > let xs = [] in zipWith const xs (drop 2 xs)
10:57:24 <lambdabot>   []
10:57:24 <quchen> monoidal: That's precisely the issue. It's correct, except in the case where it's not. :-)
10:57:27 <shachaf> So it is not correct.
10:58:47 <dgpratt> when you're browsing the code for a large Haskell project, and you see a term like 'Expression' and you want to find it's definition, what procedure do you follow?
10:59:04 <adnap> grep -r Expression .
10:59:06 <monoidal> :info Expression
10:59:06 <quchen> dgpratt: grep?
10:59:10 <arkeet> ack is better
10:59:12 <monoidal> :list Expression
10:59:18 <enthropy> hothasktags
10:59:26 <dgpratt> what if grep returns ~1000 results?
10:59:28 <enigmuriatic1> what's the best way to pattern match for a list of length <= 2 ?
10:59:37 <shachaf> All of the above.
10:59:37 <adnap> I just find the definition and then open it in vim
10:59:42 <arkeet> enigmuriatic1: pattern match on longer lists first.
10:59:48 <adnap> It has ::
11:00:00 <adnap> If it's a function definition
11:00:07 <enigmuriatic1> arkeet, like x:x:xs@xs ?
11:00:21 <monoidal> enigmuriatic1: you can't repeat variables in patterns
11:00:26 <dgpratt> well, 'Expression' wouldn't be a function ;-)
11:00:34 <monochrom> build doc, use its index
11:00:34 <monoidal> dgpratt: It can be.
11:00:36 <enigmuriatic1> y:ys@xs?
11:00:38 <arkeet> enigmuriatic1: that's lists of length lat east 2.
11:00:40 <arkeet> no that's even worse.
11:00:47 <arkeet> (_:_:_:_) if you don't care about the contents
11:00:50 <enigmuriatic1> i do
11:00:55 <enigmuriatic1> i need to use the contents
11:00:55 <arkeet> (_:_:_:_)@xs then
11:01:05 <enigmuriatic1> so the fourth is just []?
11:01:26 <arkeet> there are three :s, so there are at least 3 elements in that list.
11:01:32 <dgpratt> monoidal: am I crazy, I thought all this time that functions began in lower case
11:01:34 <arkeet> the fourth _ might be [] or a nonempty list.
11:02:00 <arkeet> hmm, how did "at least" become "lat east", I wonder?
11:02:02 <adnap> Seems like GHCI is a better way, but I don't know how to load all modules in a directory in GHCI
11:02:19 <monoidal> dgpratt: "Just", for example, is a function. but looking at the context, the method with :: will not work.
11:02:36 <arkeet> dgpratt: how about building the haddock docs?
11:02:42 <dgpratt> monoidal: I think of Just as a constructor, but I think I understand what you mean
11:02:42 <arkeet> with source links perhaps
11:02:51 <dgpratt> arkeet: interesting idea
11:03:05 <adnap> But they you still have to search through the Haddock docs
11:03:07 <arkeet> although for data types or constructors or whatever, ghci is enough.
11:03:11 <arkeet> adnap: that's what an index is for
11:03:18 <monochrom> there is an index
11:03:24 <adnap> Yeah...
11:03:29 <monochrom> <monochrom> build doc, use its index
11:03:51 <monochrom> 5 words that was ahead of its time
11:03:57 <adnap> How do you load a directory of Haskell modules in GHCI if their is no single module that imports the others?
11:03:59 <arkeet> not conspicuous enough.
11:04:00 <dgpratt> monochrom: I like arkeet's idea better :)
11:04:03 <adnap> *there
11:04:06 <arkeet> dgpratt: we had the same idea.
11:04:07 <monoidal> shachaf: http://hackage.haskell.org/trac/ghc/ticket/7266 <- do you want to mark this as 'patch'?
11:04:22 <dgpratt> arkeet: my poor attempt at humor
11:04:26 <arkeet> :)
11:04:29 <TravisD> Hmm, ghc-mod in emacs is telling me that it "could not find module `Control.Monad.State'", but ghci has no problem. Does anyone know what could cause that?
11:04:29 <monochrom> "ghci *.hs" may work
11:04:37 <shachaf> monoidal: Oh, I'm supposed to do that, amn't I.
11:04:43 <adnap> What about for nested directories?
11:04:43 <TravisD> (I recently updated my haskell platform)
11:04:52 <monoidal> shachaf: a patch for documentation would be useful
11:05:17 <shachaf> Oh, right. Documentation.
11:05:18 <monoidal> shachaf: but modulo that, I think it's good to mark it, so it will get committed faster
11:05:23 <adnap> With the haddock index, you have to ctrl+f, click the link, then click the source link
11:05:29 <shachaf> Is there anything other than documentation?
11:06:10 <adnap> Or I guess you could use ', then enter, then click the source link
11:06:18 <monoidal> shachaf: Tests
11:06:29 <monoidal> shachaf: and I don't think anything more
11:06:29 <adnap> Oh, nevermind
11:06:49 <adnap> SO
11:06:57 <adnap> How do I get a man page for cabal?
11:07:42 <elliott> "cabal help"
11:07:51 <monoidal> cabal help <command>
11:09:06 <adnap> cabal: unrecognised command: --with-compiler (try --help)
11:09:30 <elliott> I suggest not passing --with-compiler
11:09:58 <adnap> cabal: unrecognised command: --with-ghc (try --help)
11:10:13 <monoidal> elliott: I believe adnap wants help on --with-compiler
11:10:22 <applicative> what do you want to know about --with-compiler
11:10:29 <adnap> I have built GHC from source and I want to use it to compile a package with cabal-dev instead of the older version I have installed on my system as well
11:10:40 <applicative> use --with-compiler
11:11:02 <adnap> The build from source version is in /usr/local/bin, and the older version (installed by my package manager) is in /usr/bin
11:12:18 <adnap> Can I use cabal-dev install --with-compiler=[directory] --sandbox=[other directory] ?
11:12:46 <applicative> doesn't cabal-dev have a .cabal/config sort of file?
11:13:12 <adnap> No idea
11:13:45 <adnap> applicative: YEs
11:14:13 <applicative> I was thinking, if in the sandbox directory there is a config file, you can specify the compiler same as with your uh user .cabal/config
11:14:31 <applicative> then when you call cabal dev in the sandbox it will look at that config
11:14:44 <applicative> but I am totally making this up
11:14:51 <adnap> applicative: But I am not calling cabal-dev in the sandbox
11:15:05 <adnap> applicative: I am using cabal-dev to build a package for the sandbox
11:16:36 <applicative> hm, yes, I don't know if cabal-dev would use the config file that's so to say closest to the .cabal file
11:17:16 * applicative remembers hsenv was somehow specially oriented to testing with several different compilers
11:17:34 <applicative> or hsvirthualenv-h
11:20:14 <kqr> why is lambdabot kappabot by the way?
11:20:24 <monochrom> lambdabot is away
11:20:37 <applicative> a much deserved vacation
11:21:05 <adnap> "cabal: Cannot find the program 'ghc' at '/usr/local/bin' or on the path
11:21:07 <kqr> fair enough
11:21:40 <adnap> Even though /usr/local/bin/ghc --version succeeds
11:24:08 <applicative> well, the libraries list doesn't seem to be adding the wrong Foldable instance for Either a ..
11:24:39 <applicative> I hadn't thought cabal had its own idea of path but cabal-dev...
11:26:11 <elliott> wrong instance for Either a?
11:26:19 <elliott> seems like there is a single obvious instance
11:26:38 <applicative> yes, there is; that was my point ;)
11:32:49 <tij> what is the difference between `ap` and applicative functors - they seem like they do the same thing
11:33:20 <tij> `ap` and <*>
11:33:27 <applicative> the argument, Pointed is no good since the only law governing `point` is provided by parametricity, also holds of fmap
11:33:30 <applicative> oh
11:33:45 <elliott> I don't think it does.
11:33:54 <elliott> tij: return/ap make any Monad into an applictive functor
11:33:54 <applicative> tij there is now officially no difference on condition that `ap` is defined
11:34:04 <elliott> but not all Applicatives are monads
11:34:12 <TravisD> I just updated to the most recent Haskell platform. Is there anything to be aware of regarding cabal-installed packages?
11:34:15 <elliott> that is to say, ap is a valid implementation of (<*>) for any monad M
11:34:20 <elliott> but it may not be the most efficient implementation
11:34:32 <applicative> not all monads are applicative in only one way, is the way to say it
11:34:54 <tij> ah i see
11:34:56 <monoidal> ap is to applicatives as liftM is to functors
11:34:57 <tij> thanks guys
11:35:48 <applicative> when TA'ing logic you have to go through this a lot...
11:36:21 <applicative> TravisD: cabal update?
11:37:08 <applicative> TravisD: all the old things are irrelevant now, you can get rid of the stuff in .cabal if you arent using the old compiler.  where cabal puts things is platform dependent ...
11:37:51 <TravisD> applicative: ghc and ghci seem to be working proberly, but my emacs mod keeps telling me that it cant' find Control.Monad.State
11:38:22 <applicative> monoidal: there's only ever one liftM/fmap not so <*> or whatever you want to call it
11:38:50 <TravisD> applicative: I can delete the files "config" and "config.platform" in ~/.cabal?
11:40:07 <monoidal> applicative: what I meant in the analogy is that they're replacement functions working only for monads (liftM=fmap like ap=(<*>))
11:40:23 <josephle> applicative: but the same case can be said for Ord. Int doesn't *have* to follow natural orderings.
11:40:28 <TravisD> This is the error I get: http://hpaste.org/89502
11:42:05 <tij> say you did something like this: lookupVar var stack = msum $ map (lookup var) stack
11:42:27 <tij> will the function map through the entire stack before returning a value, or will it return immediately once it finds a valid value (laziness)?
11:42:46 <tij> because it seems the map executes before msum
11:43:09 <monoidal> > msum (map Just [2,  undefined])
11:43:10 <lambdabot>   Just 2
11:43:30 <tij> ah i see
11:43:38 <tij> shouldve tried that by myself
11:43:47 <mm_freak> > msum (repeat (Just 2))
11:43:48 <lambdabot>   Just 2
11:53:12 <klrr> anyone know something fun to write that you learn a lot doing?
11:57:44 <FreeFull> klrr: a Scheme interpreter maybe?
12:00:18 <quchen> klrr: A decentralized botnet? Think of how the networking of Bitcoin or Bittorrent works. It's basically a lot about concurrent programming and using Network.
12:01:01 <quchen> Send messages to the entire network, find new neighbouring nodes, maintain the network integrity
12:07:12 <enigmuriatic1> what should i read if i want to get a deeper understanding of what a do block is?
12:07:33 <elliott> uh, probably the Report
12:07:33 <shachaf> The definition of a do block.
12:07:49 <mauke> @where report
12:07:49 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
12:08:02 <elliott> do { x } = x;    do { x; y } = x >> y;    do { v <- x; y } = x >>= \v -> y    and you're done.
12:08:07 <elliott> ok, except for "let ... = ...".
12:08:13 <elliott> and the case where v is a more complex pattern.
12:08:18 <elliott> but close enough.
12:08:23 <mauke> not recursive enough
12:08:29 <elliott> er, yes, right.
12:08:30 <mauke> do { X } ==> X
12:08:37 <mauke> do { X; ... } ==> X >> do { ... }
12:08:47 <mauke> do { v <- X; ... } ==> X >>= \v -> do { ... }
12:09:05 <elliott> you should have corrected the <- part while you're at it :P
12:09:52 <mauke> you mean the fail case?
12:10:05 <elliott> right.
12:10:15 <mauke> meh
12:10:16 <elliott> hm, are guards valid in <-?
12:10:22 <elliott> like p | q <- r; ...
12:10:29 <shachaf> No.
12:10:33 <elliott> lame
12:10:38 <mauke> > do { _ | True <- ""; "" }
12:10:39 <lambdabot>   <hint>:1:8: parse error on input `|'
12:10:48 <elliott> wouldn't it be great if you could do that?!
12:10:48 <shachaf> View patterns are valid.
12:10:53 <klrr> FreeFull: yes, ive done that
12:10:55 <elliott> I bet it'd be fun in the list monad.
12:11:05 <klrr> quchen: sounds interesting, what is it really?
12:11:22 <FreeFull> klrr: Does it support macros and such?
12:11:44 <mauke> > do { (toUpper -> x) <- "abc"; [x, x] }
12:11:45 <lambdabot>   "AABBCC"
12:11:49 <klrr> FreeFull: nah i cant implement macros that's too hard :/
12:12:28 <nooodl_> mauke: whoa how does that work
12:12:39 <quchen> klrr: That's all it is. If you want a more concise outline of the project: Write a program that when started, connects to a network as a single node. Each node has the same rights and the same source code, and is able to send messages to other nodes.
12:12:41 <mauke> terrible
12:12:56 <mauke> <shachaf> View patterns are valid.
12:13:30 <klrr> quchen: sounds very unuseful, what would it be good for?
12:13:52 <FreeFull> Sounds like a simple P2P messaging system
12:14:00 <quchen> FreeFull: Yes, sort of
12:14:05 <nooodl_> i'm guessing do { (f -> x) <- a } is like do { x' <- a; let x = f x' }?
12:14:16 <klrr> p2p, basically serverless communications
12:14:43 <shachaf> > let only False = const Nothing; only True = Just in do { x <- [1,2,3,4]; (only (even x) -> Just y) <- "abc"; return (x,y) }
12:14:44 <lambdabot>   [(2,'a'),(2,'b'),(2,'c'),(4,'a'),(4,'b'),(4,'c')]
12:15:02 <quchen> Once the basic functionality is implemented you can go wild with it and start researching how your network looks like, visualize it with GraphViz, see how many connections each node needs to maintain network integrity, make the network resistant to DDoS etc
12:15:07 <shachaf> Of course that won't let you guard on y.
12:15:26 <elliott> shachaf: sure it does
12:15:31 <FreeFull> Wait
12:15:32 <elliott> oh, I guess not
12:15:34 <FreeFull> I never knew about this syntax
12:15:46 <nooodl_> help this is all too magical
12:15:48 <elliott> it's not standard I think
12:15:48 <FreeFull> Is it part of an extension?
12:15:52 <elliott> ViewPatterns
12:15:55 <FreeFull> I see
12:16:22 <elliott> the semantics are f (view -> pat) = ... === f x | pat <- view x = ...
12:16:33 <elliott> of course you need to know pattern guards to understand this translation, but they are at least Haskell 2010
12:16:59 <FreeFull> You could probably use fail and return instead of Nothing and Just
12:17:10 <FreeFull> To make it monad-independent
12:17:25 <FreeFull> Wait
12:17:26 <shachaf> fail is hardly monad-independent
12:17:29 <shachaf> Maybe you mean mzero
12:18:03 <FreeFull> mzero is in MonadPlus though
12:18:07 <FreeFull> fail is part of Monad
12:18:09 <jasperr> hello
12:18:23 <FreeFull> Although I guess it isn't necessarily implemented for every monad
12:18:40 <arkeet> fail doesn't deserve to be part of Monad.
12:18:48 <FreeFull> Probably
12:19:13 <quchen> You should treat fail as part of Monad as much as you treat mzero being in it.
12:19:42 <arkeet> I disagre.
12:19:44 <arkeet> e
12:19:50 <arkeet> you should treat fail as not existing.
12:20:20 <quchen> Or that.
12:20:27 <jasperr> is there something that does the same things like error, but also exits with a nonzero status? like exitFailure
12:20:46 <arkeet> what for?
12:21:15 <mauke> doesn't error exit with a non-zero status?
12:21:20 <jasperr> for me not
12:21:28 <jasperr> I would expect...
12:21:43 <mauke> ghc -e 'error "hi"'
12:21:48 <mauke> echo $?  ==>  1
12:22:02 <quchen> jasperr: Don't use error. If you're using it as an elaborate "TODO" in your code, I would recommend some CPP macro. In a binary that's supposed to work, there should not be 'error's. (... fail sends its regards again ...)
12:22:07 <elliott> I wouldn't recommend trusting "ghc -e" for this kind of stuff ingeneral
12:22:19 <shachaf> shachaf@carbon:~$ ghc -e 'blah'
12:22:21 <shachaf> <interactive>:1:1: Not in scope: `blah'
12:22:36 <shachaf> shachaf@carbon:~$ echo $?  ==>  0
12:22:37 <shachaf> :(
12:22:44 <shachaf> s/./:-/
12:22:57 <geekosaur> well that's craptacular
12:23:07 <mauke> shachaf: is there a bug for that?
12:23:10 <monoidal> shachaf: there's already bug for that
12:23:12 <monoidal> mauke: ^
12:23:30 <shachaf> mauke: Yes: http://hackage.haskell.org/trac/ghc/ticket/7962
12:24:02 <shachaf> monoidal: I know, I encouraged him to open the bug.
12:24:13 <jasperr> hmm... I will try with ghc, thanks :)
12:27:15 <enigmuriatic1> can you just ignore some fields when using Data.Aeson?
12:31:12 <supki> enigmuriatic1: more context?
12:31:38 <enigmuriatic1> just looking for a more holistic description of what it is, i guess
12:31:52 <enigmuriatic1> maybe i just forget what i read in Learn You a Haskell
12:32:04 <Clint> you're asking what aeson is?
12:33:18 <enigmuriatic1> oh right, that question
12:33:44 <enigmuriatic1> i was wondering if i have to bind all of the fields for a given JSON format, or whether i can just ignore some
12:35:54 <Philonous> I have a design problem. I'm developing a pickler library (basically prisms, but with error backtraces). They obviously form a category. Now my problem is that for f,g :: (a -> Either [Error] b) I can't append the trace of f when g fails in (f <<< g)
12:40:10 <Philonous> I was thinking of adding a record field (hints :: [Error]) to the picklers, so the backtrace can be statically extracted. But that is awkward because the hint have to be added by hand to the trace. I wonder whether there's a more elegant way of solving this
12:41:17 <josephle> enigmuriatic1: you can ignore some
12:41:24 <enigmuriatic1> thanks
12:41:55 <josephle> be careful you get the right types. otherwise aeson is just going spit out a whole lot of Nothings
12:43:03 <Lethalman> :t Data.ByteString.Lazy.index
12:43:04 <lambdabot> BSLC.ByteString -> Int64 -> Word8
12:43:10 <Lethalman> oh it's Int64
12:43:20 <geekosaur> much Nothing about ado
12:50:54 <johnw> thoughtpolice: ping
12:52:24 <johnw> @tell thoughtpolice Building GHC HEAD on my Mac with make -j22 + full tests + nofib takes around 8h25m.  Do you want me to keep my regular logs in a public place for you?
12:52:40 <lambdabot> Consider it noted.
12:54:46 <rck> learning data types. I am trying to model in haskell what I would use an array (vector in C++, List C#, etc) of data types in other languages. I need to mutate the completed field of my data type to track state (uri :: String, completed :: Bool)
12:54:52 <rck> how should I model this in haskell?
12:55:31 <Lethalman> so, is there a way to read an image in haskell?
12:55:34 <Lethalman> hsimagick crashes
12:56:42 <rck> Lethalman: Real World Haskell has a section on reading image data
12:56:55 <Lethalman> rck, pbm iirc, but I'd like a png or such
12:57:17 <Philonous> rck:  Sounds like you want an IOArray
12:58:22 <arkeet> Philonous: does it?
12:58:24 <rck> Philonous: I assume that will let me mutate the array itself (add, remove members) but will it allow me to mutate the Bool field of a particular member? I don't think so right?
12:58:44 <arkeet> mutate the member by a function that modifies that field.
12:58:47 <Lethalman> ah! pngload
12:59:11 <rck> arkeet: how do I mutate a Bool after it's created?
12:59:18 <arkeet> ??
12:59:25 <arkeet> make a new one.
12:59:34 <rck> oh
12:59:37 <Philonous> rck:  With an IOArray you can change each individual field
13:00:00 <rck> so I'd remove the old record, create a new one with identical fields but a true Bool and readd to the array?
13:00:07 <arkeet> no.
13:00:26 <Lethalman> mh no partial support for png
13:00:32 <Lethalman> looks like a pure implementation
13:00:50 <rck> Philonous: okay thanks I'll keep reading
13:01:33 <luite> Lethalman: see JuicyPixels
13:01:34 <arkeet> IOArray doesn't let you change the size of the array.
13:01:39 <arkeet> you can only read and write elements.
13:01:42 <Lethalman> luite, ah right
13:01:50 <Lethalman> luite, thanks
13:02:00 <thoughtpolice> johnw: yes please. can you also tell me what your mk/build.mk says?
13:02:00 <lambdabot> thoughtpolice: You have 1 new message. '/msg lambdabot @messages' to read it.
13:02:03 <rck> I don't need to change the size, just contents of the elements so that sounds good
13:02:07 <thoughtpolice> johnw: or do you simply use the default build.mk?
13:02:26 <arkeet> Lethalman: see http://www.google.com/search?q=png%20site%3Ahackage.haskell.org%2Fpackage
13:03:21 <rck> is there a more idiomatic way to think about state in haskell? I have a list of files to be served in a scotty/WAI/Warp application and I need to check them off as served when someone requests one
13:03:52 <Philonous> rck:  say you want to change the element at position i, so you'd (readArray myArray i >>= \x -> writeArray myArray i x{completed = True} )
13:03:53 <rck> my brain goes to an array of datatypes (uri :: string, completed :: bool) but maybe that's the wrong approach in haskell?
13:04:13 <arkeet> why not actually use a map, then?
13:04:16 <arkeet> or something
13:04:30 <arkeet> you probably don't actually need a mutable array.
13:04:36 <rck> hash would be fine arkeet yep
13:04:43 <arkeet> start with Data.Map
13:05:05 <rck> okay I'll check it out. thanks!
13:05:14 <rck> Philonous: thank you for the example
13:05:26 <Philonous> rck:  You can use a mutable data structure and keep in an IORef (or even just a State monad). But that can be expensive when you do a lot of small updates
13:05:39 <Philonous> rck:  immutable, I mean
13:05:50 <arkeet> if performance becomes a concern, then you can consider switching to something like HashMap or whatever.
13:06:18 <rck> Philonous: immutable data structure stored in an IORef (pointer) allows me to mutate the data?
13:06:44 <Philonous> rck:  Kind of. You don't mutate the data, rather, you create a new version and store that instead.
13:06:56 <mm_freak> rck: keep a Set/Map of URLs
13:07:00 <mm_freak> remove when visited
13:07:17 <benj__> Hi, I have a parallel program written in Haskell, and I was wondering if I have included the optimal runtime flags. currently my runtime statement is as follows.... ./Estimation +RTS -K1500m -H3000m -N4 -qb -RTS
13:07:46 <rck> mm_freak: I want to keep auditing data about who requested it, when they requested, etc so I don't want to use a chan and just throw it away
13:08:12 <mm_freak> rck: keep two Map/Set of URLs, move when visited
13:08:32 <rck> mm_freak: okay thanks
13:09:02 <benj__> Can anybody help me with parallel runtime flags?
13:09:12 <rck> benj__: how many physical cores does your machine have?
13:09:26 <benj__> I know about -N
13:09:39 <benj__> and we will be scalig up to 40
13:10:08 <benj__> but things related to garbage collection, and other stuff.
13:10:58 <benj__> currently my runtime statement is this : ./Estimation +RTS -K1500m -H3000m -N4 -qb -RTS
13:11:26 <benj__> kind of a memory hog, but we are calculating pi.
13:12:00 <Taneb> Didn't someone write a really weird pi calculation program in one line?
13:12:09 <Taneb> It's in the @where's somewhere
13:12:12 <Taneb> @help where
13:12:12 <lambdabot> where <key>. Return element associated with key
13:12:23 <Taneb> @help @where
13:12:23 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:12:30 <rck> benj__: probably already know but you can see some GC profiling stats with -s included in the +RTS line
13:12:35 <Adeon> @source pi
13:12:36 <lambdabot> pi not available
13:12:55 <benj__> well, yeah the program isn't the most effiencient way of geting pi, we are doing reimann sum of the upper half of the unit circle.
13:14:32 <benj__> yeah I know about -s.. I was wondering if there is anything else that might help speedup a parallel program..
13:16:13 <monoidal> @src Double pi
13:16:14 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:18:40 <Taneb> In implantations that don't support pragmas, would {-# FOO #-} be parsed as a comment?
13:20:46 <opqdonut> Taneb: yeah, that's the idea
13:24:50 <mm_freak> > let x = [0,0.0009765625..1] in (4 *) . genericLength . filter (<= 1) $ liftA2 (\x y -> x^2 + y^2) x x
13:24:52 <lambdabot>   *Exception: stack overflow
13:25:16 <mm_freak> > let x = [0, 1/128 .. 1] in (4 *) . genericLength . filter (<= 1) $ liftA2 (\x y -> x^2 + y^2) x x
13:25:17 <lambdabot>   51948
13:25:43 <mm_freak> > let x = [0, 1/128 .. 1] in (\x -> 4 * x / 129^2) . genericLength . filter (<= 1) $ liftA2 (\x y -> x^2 + y^2) x x
13:25:44 <lambdabot>   3.1216873985938345
13:27:44 <mm_freak> > 8 * sum [ 1/10000 | (x:ys) <- tails [0..99], y <- ys, x^2 + y^2 < 1 ]
13:27:46 <lambdabot>   0.0
13:28:09 <mm_freak> > 8 * sum [ 1/10000 | (x:ys) <- tails [0..99], y <- ys, (x/99)^2 + (y/99)^2 < 1 ]
13:28:11 <lambdabot>   3.0863999999997906
13:28:38 <mm_freak> > 8 * sum [ 1/10000 | ys@(x:_) <- tails [0..99], y <- ys, (x/99)^2 + (y/99)^2 < 1 ]
13:28:39 <lambdabot>   3.1431999999997844
13:42:12 <enigmuriatic1> say you have a value, and you need to make a system call based on it, parse the system call as JSON using Aeson, take a value from that parsed data, and repeat until you get a certain value. how would you structure your code?
13:44:28 <mm_freak> enigmuriatic1: regular recursion
13:45:10 <mm_freak> f v | p v = return v | otherwise = doSyscallAndAesonStuff
13:45:36 <enigmuriatic1> mm_freak, i'm having trouble doing that in a do block
13:45:39 <supki> I have hard time imagining parsing system call as JSON
13:46:01 <enigmuriatic1> supki, it can be done. it's proving to be a pain, though
13:46:01 <mm_freak> the whole parse-and-interpret cycle doesn't make sense to me
13:46:13 <enigmuriatic1> haskell is really painful to write useful things in
13:46:19 <mm_freak> that's not true
13:46:34 <mm_freak> enigmuriatic1: perhaps be more specific about your application
13:46:37 <enigmuriatic1> basically the only way i have of accessing the data is to parse the last set
13:47:02 <enigmuriatic1> i need to take a system call,which is JSON, get a value out of it, and make another system call with that data
13:47:05 <enigmuriatic1> indefinitely
13:47:28 <enigmuriatic1> and ideally store other data present in the JSON info somewhere while i'm doing it
13:48:22 <mm_freak> are you sure about the "syscall" part?  i'm not aware of a syscall that uses JSON
13:48:30 <DanBurton> What about Haskell makes that hard? Or what about other languages makes that easier?
13:48:58 <mm_freak> enigmuriatic1: to help you we really need more information
13:49:17 <enigmuriatic1> mm_freak, yes. it's bitcoind and it uses JSON for easy parsing
13:49:28 <mm_freak> ah, so not a syscall
13:50:02 <mm_freak> you are talking to bitcoind and waiting for a certain response?
13:51:22 <enigmuriatic1> DanBurton, it makes things too safe when you want to live on the edge a little. It's like insisting that you build a jackhammer from scratch when all you want to do is put a nail into a board
13:51:37 <enigmuriatic1> mm_freak, no. i make the call and use the response
13:51:41 <enigmuriatic1> not talking
13:51:58 <enigmuriatic1> it's a simple command line call that gets a response
13:53:24 <mm_freak> terminology aside, the structure looks similar to this:  loop v | p v = return v | otherwise = callBitcoind v >>= loop
13:53:25 <DanBurton> so, step 1, you want something of type String -> IO String, where the string you input is the program to invoke, and the IO String is the response
13:53:32 <enigmuriatic1> i don't know what the >>=
13:53:33 <enigmuriatic1> is
13:53:46 <enigmuriatic1> i guess i'll just read more and figure this out
13:54:04 <mm_freak> enigmuriatic1: you claim that haskell makes things hard…  C++ makes things hard, too, until you become somewhat fluent ;)
13:54:12 <enigmuriatic1> Python makes things easy
13:54:14 <DanBurton> "m >>= f" is the golf-y way of writing "do x <- m; f m"
13:54:38 <Cale> enigmuriatic1: How would you write it in Python?
13:54:46 <tromp_> you mean ,,, f x"
13:55:03 <nexx> That is something I wonder often @Cale
13:55:08 <DanBurton> yes, tromp_ is right
13:55:14 <mm_freak> enigmuriatic1: the haskell code likely doesn't look much different from the python code…  this seems like a highly imperative application
13:55:15 <enigmuriatic1> Cale, a while loop, using a JSON parser that doesn't look like mandarin chinese
13:55:41 <DanBurton> which Haskell JSON parser looks like mandarin chinese?
13:55:50 <josephle> I'm guessing Aeson
13:55:51 <mm_freak> DanBurton: aeson apparently
13:56:05 <kartlos> hey guys, I'm reading "the craft of functional programming", I'm at the part where curried and uncurried functions are explained, the author doesn't mention in what situations uncurried functions are usefull, I don't see where f(x,y) could be preferred over f x y...
13:56:16 <mm_freak> i don't use it, so i can't judge, but i recall that it takes a data type and TH-JSONizes it
13:56:28 <elliott> kartlos: when mapping over a list of pairs, say. but in that case you'd usually write map (uncurry f)
13:56:36 <elliott> (where uncurry takes an curried function to an uncurried one)
13:56:56 <elliott> so, generally you'd only write f (x,y) = ... when f is an operation on pairs in some sense
13:56:57 <mm_freak> kartlos: normally you would write all functions curried and apply 'uncurry' where necessary
13:57:02 <elliott> e.g. when (x,y) is a coordinate pair, a first-class value unto itself
13:57:07 <DanBurton> yeah, if you set up your data type correctly, it should just be "deriveJSON ''MyType ... parseJSON someString"
13:57:21 <Cale> enigmuriatic1: It's easy enough to write a while loop in Haskell, despite the absence of a while keyword, you can even make one yourself if you don't like to write the recursion directly.
13:58:22 <Cale> enigmuriatic1: while cond body = do b <- cond; if b then (do body; while cond body) else return ()
13:58:23 <kartlos> elliott: so it's only practical when the input is a pair?
13:58:46 <FreeFull> Cale: Why would cond be wrapped in a monad though?
13:58:55 <Cale> Wrapped in?
13:59:05 <FreeFull> I mean, you do b <- cond
13:59:14 <FreeFull> But wouldn't just   cond :: Boolean   do
13:59:23 <FreeFull> I mean, Bool
13:59:27 <Cale> The conditional is likely an action itself, because it probably has to read from some mutable state.
13:59:28 <Sonarpulse> https://github.com/Ericson2314/cncmix I had a project here
13:59:41 <monoidal> FreeFull: if the condition does not change, the loop either executes 0 times, or indefinitely
13:59:42 <mm_freak> FreeFull: while True …
13:59:44 <Sonarpulse> since I upgrade my version of haskell (with upgrade of ubuntu)
13:59:50 <shafox> hinst, just joined. I want to learn Haskell. I have knowledge in php only. How should I start ??
13:59:55 <Sonarpulse> it won't build because my dependancies have fixed version
13:59:56 <DanBurton> the condition is presumably effectful. Otherwise it is an unchanging Bool, True or False, and you have an infinite or a 0-times loop, respectively
14:00:01 <FreeFull> Hmm
14:00:03 <Cale> shafox: lyah is a good starting point
14:00:04 <monoidal> shafox: http://learnyouahaskell.com/
14:00:16 <Sonarpulse> but when i tried changing the fixed version numbers to minimum versions
14:00:17 <mm_freak> but i question the usefulness of a while loop in haskell
14:00:22 <Sonarpulse> it still wouldn't build
14:00:32 <mm_freak> for it to be marginally useful its type would have to be very weird
14:00:38 <Cale> shafox: and feel free to ask lots of questions
14:00:43 <DanBurton> mm_freak: it's useful when you want to write imperative-style code :P
14:00:48 <Sonarpulse> leading me to beleive my cabal stuff might be screwed up (with the mix of cabal and apt packages)
14:00:53 <Taneb> @where lyah
14:00:53 <lambdabot> http://www.learnyouahaskell.com/
14:00:58 <mm_freak> while :: (Monad m) => (a -> Bool) -> (a -> m a) -> m a
14:01:03 <Cale> FreeFull: We could write this though:
14:01:05 <shafox> Cale & monoidal: thanks. I mentioned that I am coming from a php background . is that going to be a obstacle for me to learn haskell ?
14:01:05 <Sonarpulse> what is the most orthodox thing for me to do with the version numbers in the cabal build files?
14:01:08 <mm_freak> DanBurton: recursion is better for imperative code
14:01:13 <Sonarpulse> could somebody else try building it?
14:01:25 <mm_freak> Cale's 'while' example isn't very useful
14:01:51 <Cale> shafox: It likely won't help very much to be honest.
14:02:13 <shafox> Cale: regarding learning or the php language ?
14:02:19 <Cale> shafox: PHP
14:02:41 <shafox> Cale: so I should move forward with my learning of Haskell .
14:02:47 <DanBurton> Sonarpulse: looking into it
14:02:56 <mm_freak> shafox: i came from a C++/PHP background
14:02:56 <Sonarpulse> DanBurton: thanks so much
14:03:01 <mm_freak> i had to unlearn PHP and relearn C++
14:03:04 <Cale> There is a certain extent to which imperative programming knowledge transfers over eventually, but it's not immediate or direct.
14:03:06 <FreeFull> You know, I think Cale's while could be pretty useful
14:03:16 <FreeFull> But only if you really want a while loop for some reason
14:03:23 <Sonarpulse> known C++11 and haskell is really powerful
14:03:34 <Cale> It could be used, it's just not likely to be very much better than writing a while loop recursively.
14:03:37 <FreeFull> You'd probably want to use lenses with it
14:03:48 <mm_freak> FreeFull: in imperative style you want while loops all the time
14:03:51 <Cale> Usually in any specific case, you could do better
14:03:53 <shafox> mm_freak: hows that working for you till now ?
14:03:55 <mm_freak> even replicateM uses a kind of while-loop
14:03:59 <Sonarpulse> but incorrect notions about C or php will be confusing
14:04:10 <mm_freak> shafox: very well
14:04:11 <Sonarpulse> I learned haskell, C, just about everything about the same time
14:04:19 <Sonarpulse> so no mucky legacy to get in the way
14:04:34 <FreeFull> C++'s templates take ages to compile
14:04:41 <shafox> I was considering learning python as it is easy to learn and all. then i found haskell
14:04:51 <Sonarpulse> python is broke, as is php
14:04:57 <Sonarpulse> so you came to the right place
14:05:01 <FreeFull> I'd rather have something with a good type system
14:05:06 <mm_freak> arguably PHP is a lot more broken than python
14:05:15 <Sonarpulse> ^ true
14:05:24 <FreeFull> PHP was designed to be broken
14:05:34 <Sonarpulse> I know pythons scoping causes some serious issues, not sure if php has that too
14:05:41 <shafox> PHP is broken but laravel framework is doing so well so far
14:05:43 <nexx> PHP was designed?
14:05:53 <FreeFull> nexx: "designed"
14:05:57 <monoidal> shafox: do you have ghc already? http://www.haskell.org/platform/
14:05:57 <mm_freak> but then PHP has actual classes, so it fails when there is a class mismatch…  python only fails when methods don't exist
14:05:57 <cmccann> the real question is whether PHP is more or less broken than Brainfuck.
14:06:00 <DanBurton> Sonarpulse: which version of ghc do you have now? 7.6.3?
14:06:14 <Sonarpulse> 7.6.2
14:06:14 <shafox> monoidal: i have installed haskel-platform i am on ubuntu
14:06:23 <mm_freak> so parts of PHP are more well-defined than python
14:06:25 <int-e> cmccann: brainfuck is good for everything it was designed for
14:06:28 <monoidal> shafox: OK, that's a good start.
14:06:31 <FreeFull> Brainfuck is rudimentary turing assembly
14:06:35 <FreeFull> Wait, no
14:06:39 <FreeFull> Rudimentary turing machine code
14:06:52 <FreeFull> It isn't broken at all
14:06:52 <cmccann> int-e: good point, so that puts it ahead of PHP it seems
14:07:02 <shafox> monoidal: i am looking into the learnyouhaskell.com site to start .
14:07:08 <nexx> shachaf than you shouldn't update to 13.04
14:07:13 <nexx> then
14:07:27 <Sonarpulse> shafox: Learn You a Haskell for Great Good, is an excellent resource
14:07:28 <FreeFull> The problem with brainfuck is that each implementation seems to have some incompability with others
14:07:49 <Sonarpulse> The problem with C is that each implementation seems to have some incompability with others
14:07:53 <FreeFull> Although most "print stuff to the screen" programs should work fine in most implementations
14:07:57 <Taneb> iirc brainfuck was designed solely to be turing-complete and have a small compiler on the Amiga
14:08:11 <mm_freak> haskell solves this by having only one canonical implementation and all others don't matter =)
14:08:20 <Sonarpulse> brainfuck was also no inspired by Perl, a huge plus
14:08:34 <int-e> FreeFull: it depends, there is the overflow problem. (does +[+] terminate?)
14:08:35 <Sonarpulse> *not
14:08:47 <FreeFull> int-e: That's implementation specific
14:09:00 <josephle> Sonarpulse, iirc perl was designed to be expressive, which it is. At the expense of readability.
14:09:12 <shafox> One more question though if I am not bothering you all, some web framework that is well maintained and all so that I can look into the source code. like yesod would be a good start ?
14:09:34 <mm_freak> shafox: happstack, snap and yesod
14:09:41 <FreeFull> shafox: You could look at https://github.com/mchakravarty/BigPixel
14:09:43 <cmccann> yesod may not be a good learning example for some purposes
14:09:46 <cmccann> given all the TH magic involved
14:09:53 <Sonarpulse> perl is roughtly the hash of program in normal language
14:10:06 <Sonarpulse> * hash of program's soure written in normal language
14:10:08 <mm_freak> shafox: yesod is easy to use for a haskeller, but probably not easy to understand for a haskell newcomer
14:10:11 <int-e> FreeFull: I've written code like +[+++>+<]> to get a cell with value 85 mod 256, capital U, useful for printing :)
14:10:27 <ParahSailin> anyone have an idea of the storage size of IntMaps?
14:10:45 <shafox> cmccann: which one do you recommend ?
14:10:58 <FreeFull> Brainfuck is really something you should compile/assemble a higher-level language down to
14:11:00 <mm_freak> ParahSailin: in bytes or asymptotically?
14:11:01 <cmccann> shafox: I'm not familiar enough with them to say
14:11:08 <ParahSailin> bytes
14:11:09 <int-e> FreeFull: and I have written code that works with small integers (range -2..2) and relies on [-] to reset them to 0 eventually. All firmly in the "small programs that just print stuff" category.
14:11:38 <mm_freak> shafox: happstack is very easy for beginners and powerful/scalable enough for professionals
14:11:43 <FreeFull> Well, technically all brainfuck programs are ones that just print stuff or don't print anything at all
14:11:58 <mm_freak> shafox: snap, too, but it's a bit more involved
14:12:02 <shafox> mm_freak : thank you very much . for all these . :)
14:12:13 <shafox> involved as in mm_freak ?
14:12:35 <DanBurton> Sonarpulse: well here's what I'm trying right now. Changed all of the ==a.b.* constraints into >=a.b, now running a cabal-dev install to see if any compile errors show up
14:12:58 <FreeFull> shafox: Note BigPixel isn't a web framework at all
14:13:04 <mm_freak> shafox: you would normally use snap with its snaplets, which requires some knowledge of the type system
14:13:05 <FreeFull> But the code is simple and well-commented
14:13:31 <mm_freak> shafox: yesod is currently the most powerful, but also the most opaque and hardest to understand
14:13:48 <shafox> FreeFull: yes i will go through those once i finish the book
14:13:55 <tij> what is this: (a :| as) as part of sconcat (a :| as) = ...
14:14:09 <tij> :|
14:14:19 <cmccann> a constructor
14:14:21 <shafox> mm_freak as of now i am not considering using anything just want to see how those frameworks are written
14:14:24 <FreeFull> A data constructor
14:14:31 <cmccann> tij: for a non-empty list type I expect
14:14:58 <monoidal> tij: A list like [2,3,4] is sugar for 2:3:4:[]
14:15:04 <mm_freak> shafox: well, all of them assume familiarity with monads and to some extent monad transformers
14:15:05 <monoidal> > 2:3:4:[]
14:15:06 <lambdabot>   [2,3,4]
14:15:14 <monoidal> > 2:[3,4]
14:15:16 <lambdabot>   [2,3,4]
14:15:16 <mm_freak> shafox: so their implementations may be a bit opaque to you right now
14:15:23 <mm_freak> /using/ them is a different story
14:15:30 <mm_freak> you can get going with any of them pretty quickly
14:15:32 <Sonarpulse> DanBurton: sounds good!
14:15:34 <Sonarpulse> thanks again
14:15:45 <FreeFull> :t (:)
14:15:46 <lambdabot> a -> [a] -> [a]
14:15:50 <shafox> will do once i get a hand of haskell mm_freak
14:15:51 <FreeFull> :t []
14:15:52 <lambdabot> [a]
14:15:57 <Sonarpulse> if you have a github account feel free to fork it and do whatever ends up working
14:16:06 <Sonarpulse> or just send me a paste or difff
14:16:09 <mm_freak> shafox: i recommend happstack as your first web framework
14:16:11 <Sonarpulse> whatever is easiest for you
14:16:39 <shafox> thanks man mm_freak
14:16:42 <Sonarpulse> shafox: never used it, but there is a happstack-lite that is supposed to help you learn the framework
14:16:54 <Sonarpulse> without dumping it's full complexity and power on you
14:17:02 <alpounet> and there's a happstack crash course
14:17:26 <shafox> Sonarpulse: as i said i dont want to learn the framework or anything i just want to see how the code is implemented to get a more understanding
14:17:40 <DanBurton> Sonarpulse: looks like one of the tests fails, though. *shrug* yeah generally the easy thing to do is just disable upper bounds and only put them back if you *know* the library has made a breaking change that messes with your code
14:18:36 <Sonarpulse> danBurton: thanks so much
14:18:48 <Sonarpulse> that sounds like a good plan
14:19:06 <Sonarpulse> backwards compatability is pretty good with the libraries I use I think
14:19:17 <Sonarpulse> shafox: sorry, I missed that bit
14:19:35 <DanBurton> Sonarpulse: yeah your dependencies are pretty standard stuff
14:19:50 <mm_freak> shafox: snap and yesod use advanced stream processing techniques, while happstack uses lazy I/O
14:19:52 <shafox> Sonarpulse: its ok. the more i get to know the more beneficial for me
14:20:00 <mm_freak> that makes reading the happstack source code a lot easier for a haskell beginner
14:20:15 <Sonarpulse> I don't have much in my .cabal and .ghc folders, so I'll probably just delete and start from apt agin
14:21:33 <Sonarpulse> shafox: its fun to dive in, so go for it if you want. But 'real world' stuff web frameworks that have to koutou lots of existing systems and protocols are going to be harder to understand
14:22:05 <shafox> Sonarpulse: that sounds hard
14:22:09 <Sonarpulse> you can still right usefull stuff that lives solidly in "haskell land" and therefore looks a lot nicer
14:23:06 <DanBurton> I heard whispers that happstack is switching to a pipes-based solution, though
14:23:25 <Sonarpulse> that would make sense, as nobody upholds lazy IO too much now
14:24:15 <Sonarpulse> but yeah, someday I want to work on and use House, the haskell os, to just free myself from a lot of c/unix legacy bullshit, and code in blissful ignorance
14:26:18 <josephle> Sonarpulse: House? Is that like Plan9? :P
14:27:32 <DanBurton> @google house haskell operating system
14:27:33 <lambdabot> http://programatica.cs.pdx.edu/House/
14:27:33 <lambdabot> Title: House
14:28:14 <DanBurton> woo, a "newer version of house" has been ported to GHC 6.8.2, how exciting.
14:28:50 <mm_freak> DanBurton: that's true
14:29:14 <mm_freak> it's funny how all web frameworks use a different stream abstraction =)
14:29:26 <mm_freak> happstack8+pipes, snap+enumerator, yesod+conduit
14:29:36 <mm_freak> or rather WAI+conduit
14:29:41 <Sonarpulse> I used to be in to plan9, but then I decided it felt like the *nix aanlog of dymamic types
14:30:09 <Sonarpulse> danBurton: the newer version is also 404'd. Uses something still in the works though to do more concurrency in haskell than C
14:30:38 <Sonarpulse> http://hackage.haskell.org/trac/ghc/wiki/LightweightConcurrency
14:31:44 <Sonarpulse> ^^ If this becomes the default in ghc, and the 'lighthouse' (for GHC 6.8.2) version source can be tracked down, it may be a good time to start developement again
14:32:42 <Sonarpulse> unix's obsession with text means that everything is a ad-hoc parser, and those type safety out the door
14:33:08 <shafox> any virtualenvironment type package for haskell to try out things without breaking anything globally ?
14:33:35 <Sonarpulse> shafox what do you mean?
14:33:36 <Sonarpulse> cabal?
14:33:39 <Sonarpulse> platform?
14:33:43 <mm_freak> shafox: something like cabal-dev?
14:33:57 <shafox> Sonarpulse: something like virtualenv for python
14:33:58 <mm_freak> there is also virthualenv, but that one doesn't build for me (GHC 7.6)
14:34:03 <shafox> mm_freak: ^^
14:34:07 <Shamar> I'm having a few problem with cabal: when building the package, it tries to copy a glade xml file into itself (and fails with a permission denied)
14:34:07 <Sonarpulse> there is that website that gives you a tutorial with ghc
14:34:10 <petantik> hsenv?
14:34:10 <mm_freak> shafox: note the H
14:34:14 <mm_freak> virtHualenv
14:34:36 <mm_freak> shafox: which OS?
14:34:39 <Shamar> well... not a few... just one... the others are with gtk... :-)
14:34:45 <shafox> mm_freak: ubuntu 12.04
14:34:51 <mm_freak> sorry
14:34:53 <Sonarpulse> also with unix: also text -> files -> dynamically sized bytebuffers -> WAY more complex IO, memory management, etc AND type safty
14:34:54 <mm_freak> Shamar: which OS?
14:35:15 <Shamar> windows7
14:35:33 <Shamar> (now I'm tring on Debian Wheeze...)
14:35:35 <mm_freak> Shamar: i recall that you should use the --user flag explicitly on windows
14:35:44 <mm_freak> cabal install --user …
14:36:13 <mm_freak> Shamar: you're probably working on an admin account…
14:37:05 <mm_freak> Sonarpulse: one interesting thing to note about unix shells is that they form a monoid with certain commands
14:37:08 <Shamar> mm_freak, I don't think so, with -v cabal log that it's tring to copy the glade xml into itself
14:37:17 <mm_freak> Sonarpulse: composition is |, identity is cat
14:37:29 <mm_freak> and of course a monoid is a single-object category =)
14:37:31 <shafox> petantik: hsenv is build for latest ghc ?
14:38:06 <shafox> i am on 7.4.1
14:38:10 <mm_freak> Shamar: not sure…  i did have permission issues with cabal-install on windows
14:38:18 <mm_freak> using --user fixed them
14:38:50 <mm_freak> shafox: cabal-dev is what i use for installation space virtualization
14:39:00 <Shamar> ok... thanks... I'll try asap
14:39:18 <petantik> shafox: Tested-with:         GHC == 6.12.3, GHC == 7.0.4
14:39:40 <shafox> thanks petantik
14:39:58 <nanothief> I have a data SomeType (a :: EnumA) (b :: EnumB) = SomeType Int. I would like to convert that into a data DifferentRep = DifferentRep EnumA EnumB Int. Is there any way to do this without having a class with an instance for each permutation of EnumA and EnumB?
14:39:58 <shafox> mm_freak: will be using that one
14:40:58 <Sonarpulse> how do I uninstall all stuff installed via cabal?
14:41:12 <Sonarpulse> I installed a lot of stuff --globablly
14:41:24 <Sonarpulse> want to remove that but no idea how to pick it out
14:41:54 <Sonarpulse> besies sudo rm -rf; cross-fingers;
14:42:00 <Sonarpulse> *besides
14:42:46 <monoidal> nanothief: probably you can have an instance for each element of EnumA, each element of ElemB and use both classes (n+m instances instead of n*m)
14:43:49 <quchen> I just discovered pipes-concurrency, and from skimming the docs it looks like it's a nice abstraction over the explicit message passing I'm doing right now using TChans. Is that right?
14:44:09 <mm_freak> shafox: i'm not familiar with the others, so don't let me stop you from trying them
14:44:26 <mm_freak> shafox: please share your experience with the others, because i'm not entirely happy with cabal-dev =)
14:45:03 <shafox> mm_freak i just only one not 100. well the installation was fine. but cabal-dev command not found when i try to run cabal-dev install
14:45:10 <Shamar> what a strange thing on my Debian 7 I'm getting this error "Cannot find gtk2hsC2hs Please install `gtk2hs-buildtools` first and check that the install directory is in your PATH (e.g. HOME/.cabal/bin)." but gtk2hs-buildtools has been installed
14:45:29 <mm_freak> shafox: you need ~/.cabal/bin in your PATH
14:45:36 <Shamar> mm_freak, it is
14:45:43 <mm_freak> @ shafox
14:45:47 <mm_freak> your nicknames are confusing =)
14:45:56 <shafox> mm_freak:  well i can run cabal command but not cabal-dev
14:46:09 <mm_freak> shafox: cabal is more likely somewhere else
14:46:24 <mm_freak> if you installed cabal-dev through cabal, it's installed to ~/.cabal/bin
14:46:40 <nanothief> monoidal: I just tried to do that. However if I do the obvious class ToEnumA c where toEnumA a :: EnumA; instance ToEnumA EnumAValue where toEnumA _ = EnumAValue, I get a kind error (EnumAValue should be *, but is EnumA)
14:47:23 <nanothief> (still getting used to the new kinds functionality in ghc)
14:47:42 <monoidal> nanothief: "where toEnumA a :: EnumA"??
14:47:56 <shafox> mm_freak: yes the cabal-dev is in the .cabal/bin
14:48:01 <nanothief> I'll pastbin it in a sec
14:48:04 <monoidal> nanothief: shouldn't that be toEnum :: a -> EnumA?
14:48:25 <nanothief> year sorry that is right
14:50:11 <mm_freak> shafox: my approach is that i have ~/bin in PATH via my .zshrc and symlink into ~/.cabal/bin from there
14:50:54 <nanothief> monoidal: http://hpaste.org/89511
14:51:52 <monoidal> nanothief: GHC is right; LHS of -> must be *. Use a proxy.
14:52:03 <monoidal> nanothief: I'm doing that right now, but somehow get ambiguity errors
14:52:03 <Shamar> quite strange...
14:52:35 <Shamar> I have been able to cabal install gtk only after apt-get install gtk2hs-buildtools
14:52:56 <Shamar> installing gtk2hs-buildtools via cabal was not enough
14:53:36 <monoidal> nanothief: http://hpaste.org/89512 - doesn't work, I'm figuring out why
14:54:11 <shafox> how to uninstall a package that has been installed through cabal
14:55:15 <Shamar> guys, I'm finding quite complex to code a (GTK) GUI in haskell... Am I just too noob?
14:57:46 <nanothief> monoidal: it was just missing a forall a b. at the front of the convert type sig. Thanks!
14:57:55 <nomeata> Shamar: no, gtk is not particularly easy to code in, and the gtk bindings are not idiomatic, so you will not get much of the language benefits of Haskell (but it won’t be worse than other programming languages either)
14:57:55 <lambdabot> nomeata: You have 1 new message. '/msg lambdabot @messages' to read it.
14:58:17 <nomeata> unfortunately, I’m not aware of a productin-ready idiomatic GUI library
14:58:25 <Shamar> mmm
14:58:31 <enthropy> Shamar: maybe when you did apt-get, it installed a bunch of c-libraries that are needed
14:58:38 <enthropy> which cabal install doesn't do
14:58:49 <Shamar> enthropy, no library
14:58:59 <Shamar> the package had no dependency missing
14:59:11 <quchen> Shamar: Unregister it using "ghc-pkg unregister <package>", then manually delete it from .cabal/..., I think. I haven't done this very often, so maybe keep asking around.
14:59:15 <enthropy> Shamar: is ~/.cabal/bin in your $PATH?
14:59:24 <Shamar> sure
14:59:27 <quchen> shafox: Above message was directed at you.
14:59:45 <quchen> Your nicknames really are confusing, but I'm not the first one to mention it :-)
14:59:59 <shafox> quchen: hehe
15:01:07 <elliott> shafox/shachaf is more confusing
15:01:11 <shafox> quchen: i installed cabal-dev now its showing no packages that name
15:01:25 <Sonarpulse> where is ghc-pkg registration for global packages?
15:01:30 <Sonarpulse> I need to nuke everything
15:01:45 <shachaf> i was here before all the other sha-s
15:01:46 <shachaf> even shapr
15:01:47 <Raydiation> whats the most popular web framework?
15:02:13 <shafox> shachaf: no hard feelings bro. just couldnt find shadowfox so registered shafox
15:02:38 <monoidal> nanothief: I see, thanks. Of course proxy can be kind polymorphic, annotation at http://hpaste.org/89512, I removed kind polymorphism because somehow I thought that was the culpirit
15:03:18 <quchen> elliott: I think a lot of how confusing nicknames are is how your IRC client chooses to color them :-)
15:03:33 <elliott> mine doesn't
15:04:17 <Raydiation> i mean for python theres django, for ruby rails
15:04:35 <Shamar> as for GUI programming, looks that reactive-banana complement GTK in some way... but I can't see what's the advantage
15:05:56 <TravisD> On mac OS, the symlinks in "~/Library/Haskell/bin" are for an old version of the haskell platform. Is there a good way to replace them?
15:07:13 <nanothief> monoidal: cheers that works perfectly with what I need.
15:09:32 <dubsg> TravisD: why not just install the latest version of haskell-platform and then ensure that /usr/bin (where ghc will be installed) comes first in your PATH?
15:10:21 <TravisD> dubsg: Oh, the problem is that some executables from packages installed via cabal are old versions
15:10:25 <TravisD> ghc-mod, in particular
15:10:58 <TravisD> which doesn't seem to be linked into /usr/bin
15:14:37 <Shamar> what's the common approach to GUI development among haskellers? Do you use another language when you have to code a GUI?
15:16:44 <Shamar> or haskell is generally used where no GUI is needed...
15:16:53 <Shamar> (web GUI apart)
15:17:19 <yrlnry> Is there a Hac Phi channel?
15:18:38 * Shamar wonders if he chose the proper tool for the task, this time...
15:19:29 <shachaf> yrlnry: #haskell-hacphi
15:19:39 <yrlnry> Thanks.
15:20:41 <Shamar> nomeata, how an idiomatic GUI library should be?
15:23:11 <kennyd> glade builder + gtk2hs is fairly usable, in my experience.
15:23:27 <Adeon> @pl \(x,y) -> [x,y]
15:23:27 <lambdabot> uncurry ((. return) . (:))
15:23:36 <Adeon> right
15:23:56 <Shamar> kennyd, that's what I'm using now...
15:25:00 <Sonarpulse> where does ghc-pkg register globally installed packages?
15:25:56 <Sonarpulse> b2b but message me answer and I'll see it
15:26:02 <Shamar> but I'm not entirely satisfied... mainly because it's quite imperative
15:26:14 <Shamar> and boring
15:26:17 <Shamar> :-)
15:27:30 <yohan> Hey guys, started coding Haskell after I saw that Carmack started experimenting
15:27:31 <kennyd> Shamar yes it's far from ideal
15:27:34 <FreeFull> @pl \x -> x
15:27:34 <lambdabot> id
15:27:37 <FreeFull> @pl \x -> x x
15:27:37 <lambdabot> join id
15:27:59 <yohan> I'm trying out some syntax things, and I'm managed to write a program that sorts integers
15:28:17 <FreeFull> yohan: What kind of sort?
15:28:19 <kylcarte> yohan: welcome!
15:28:29 <yohan> However, it's really slow and takes several seconds with 1000000 integers
15:28:41 <yohan> I need to do this for a texture thing
15:28:45 <yohan> Just as a test
15:29:00 <yohan> Anyways, how do I make this faster?
15:29:07 <shachaf> By changing it.
15:29:17 <shachaf> (If you post your code you might get more detailed advice. :-) )
15:29:38 <shachaf> @paste
15:29:38 <lambdabot> Haskell pastebin: http://hpaste.org/
15:30:03 <yohan> shachaf: But I'm running import qualified Data.Vector.Unboxed as V
15:30:03 <yohan> import qualified Data.Vector.Algorithms.Intro as I
15:30:03 <yohan> sort :: [Int] -> [Int]
15:30:03 <yohan> sort = V.toList . V.modify I.sort . V.fromList
15:30:35 <yohan> wow nice
15:30:35 <shachaf> @paste for more than a few lines of code.
15:30:35 <lambdabot> Haskell pastebin: http://hpaste.org/
15:31:00 <yohan> http://hpaste.org/new
15:31:12 <yohan> http://hpaste.org/89514
15:31:24 <shachaf> Can you paste your entire program along with how you're testing it?
15:32:11 <monoidal> yohan: you are converting a vector to a linked list and then sorting; it is going to be slow
15:32:41 <shachaf> monoidal: The other way around. But yes.
15:32:43 <yohan> monoidal: ah
15:32:55 <yohan> How do I create a fixed size array?
15:33:01 <yohan> and do the sorting in-place?
15:33:05 <yohan> with qsort?
15:33:07 <monoidal> ah, sorry. shachaf is right
15:33:18 <yohan> That's really what I want
15:33:28 <yohan> It should benefit the cache etc
15:33:43 <shachaf> To do the sorting in place you'll have to use a mutable vector.
15:33:52 <elliott> forget about in-place, most likely
15:34:14 <yohan> But in-place does not violate immutability
15:34:23 <yohan> of elements
15:34:41 <shachaf> But it does "violate immutability" of the vector.
15:34:48 <shachaf> Therefore you have to use a mutable vector.
15:34:57 <yohan> But it does not change the size of the vector
15:35:13 <yohan> or change any of the elements except the ones I am swapping
15:36:02 <yohan> You might write that off as being retarded but I don't see why it's not true
15:36:35 <shachaf> But it changes the vector itself.
15:36:52 <shachaf> Values in Haskell are not mutable. They never change.
15:37:06 <c_wraith> changing the elements you are swapping is... changing something.
15:37:10 <yohan> It changes the CPU as well, but it doesn't change the vector - only the values inside of the vector
15:37:27 <shachaf> The vector itself is a value, though.
15:37:31 <magicman> (v ! 0) (or whatever the indexing operator is) will be different depending on if the sorting operation has been evaluated.
15:37:36 <shachaf> If I have the vector v, I expect v ! 0 to stay the same thing always.
15:37:58 <shachaf> If you could "mutate" v, then suddenly *my* v ! 0 is different.
15:38:02 <yohan> What does v ! 0 mean?
15:38:08 <kylcarte> yohan: v indexed at 0
15:38:10 <TravisD> yohan, are the vectors [1,2] and [2,1] equal?
15:38:12 <yohan> ah
15:38:13 <yohan> yeah
15:38:29 <yohan> TravisD: I see the vector as [] with size 2
15:38:54 <TravisD> yohan: Certainly they have the same type, but they are not equal
15:39:08 <c_wraith> yohan: then it's not a very useful data type is it?
15:39:13 <ab9rf> [1,2] and [1] have the same type
15:39:17 <c_wraith> yohan: doesn't it need to *contain* something to be useful?
15:39:29 <ab9rf> unless you're not talking about haskell types
15:39:42 <yohan> A datatype that has to copy the entire program every time I change something seems not very useful
15:40:06 <josephle> what do you mean copy the entire program?
15:40:08 <TravisD> yohan: for small vectors and arrays, you might be surprised at how low the overhead is
15:40:13 <shachaf> You are free to use a mutable vector if you want to.
15:40:24 <shachaf> You're also free to learn about all sorts of exciting persistent data structures.
15:40:48 <shachaf> But this is the way things are in Haskell. *Values* always stay the same.
15:40:53 <elliott> "copy the entire program" makes no sense.
15:40:56 <yohan> If I have a vector of very expensive elements that I want to sort by id, then I have to recreate those textures every time I swap an elements?
15:41:04 <dmwit> HEEELLL no
15:41:06 <yohan> Let's say OpenGL textures
15:41:09 <dmwit> That's the whole point of immutability.
15:41:12 <elliott> it seems you are making a lot of assumptions
15:41:12 <FreeFull> If you use a mutable vector, you are stuck in IO
15:41:18 <elliott> perhaps you should be as open minded as Carmack? :)
15:41:44 <kennyd> yohan if you want a mutable vector haskell has it.
15:42:06 <ab9rf> yohan: why would you have to recreate them?  they're immutable, so you can make an indefinite number of references to them
15:42:08 <yohan> kennyd: it does?
15:42:17 <c_wraith> yohan: you also seem to believe that copying pointers requires copying the things they point to
15:42:23 <elliott> 23:41:28 <shachaf> To do the sorting in place you'll have to use a mutable vector.
15:42:36 <kennyd> @where mutable vector
15:42:37 <lambdabot> I know nothing about mutable.
15:42:45 <kennyd> @where Data.Vector.Mutable
15:42:46 <lambdabot> I know nothing about data.vector.mutable.
15:42:53 <monoidal> http://hackage.haskell.org/package/vector
15:42:56 <ab9rf> yohan: all you do is create another vector containing (pointers to) the same expensive objects
15:43:00 <monoidal> and http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Mutable.html
15:43:10 <yohan> ah
15:43:16 <shachaf> yohan: I recommend learning some more Haskell before you go to mutable vectors, though.
15:43:16 <yohan> So haskell has a concept of pointers?
15:43:24 <ab9rf> yohan: inherently
15:43:31 <elliott> you don't need a notion of pointers to have mutable vectors.
15:43:32 <ab9rf> and you don't have to do anything to get it
15:43:34 <yrlnry> I want a T-short that says “<lambdabot> I know nothing about mutable.”
15:43:39 <yohan> I thought everything was immutable values
15:43:49 <ab9rf> yohan: which are reused
15:43:49 <elliott> you can manipulate C-style unsafe pointers in Haskell if you want. it's rarely useful except when interfacing with C code
15:43:56 <elliott> and you do not need it to use the mutable vector API
15:44:08 <ab9rf> if i have x = [1,2,3] and i do tail x, i don't create new instances of 2 or 3
15:44:25 <ab9rf> or even of the spine of that list
15:44:55 <yohan> So the best solution would be to use a vector containing values, then an immutable vector that points to my expensive values which is sorted?
15:45:13 <ab9rf> i don't knw if that's "best"
15:45:24 <monoidal> Haskell is referentially transparent and pure, yet allows IO and mutability.
15:46:13 <yohan> How about when I create the expensive vector of values? Is there a way to preallocate it so I do not have to invalidate all elements whenever I add elements?
15:46:26 <josephle> yohan: please let the deep/shallow copy distinction be made by the "sufficiently smart compiler".
15:46:37 <ab9rf> yohan: why would you invalidate _any_ elements by adding another one?
15:46:39 <ab9rf> that makes no sense
15:47:18 <FreeFull> ab9rf: What about with an unboxed vector?
15:48:04 <yohan> Ah k...
15:48:39 <ab9rf> yohan: you seem to be treating a vector as if it was a giant blob of data with no internal structure
15:50:47 <enthropy> is it possible to use 'ad' on Data.Vector.Storable? It doesn't seem to work since Storable vectors can't be Traversable
15:52:08 <enthropy> or alternatively, is it reasonable to expect alignment to be ok for passing the pointers that make up Data.Vector to the FFI?
15:52:51 <enthropy> the idea here being to improve http://hackage.haskell.org/package/ipopt-hs
15:55:04 <yohan> ab9rf: yes
16:00:32 <Sonarpulse> yohan: rules of programming 1) write in Haskell 2) write beautiful code, without regard to efficiency 3) optomize ONLY as needed
16:03:01 <yrlnry> Isn't there a lexical syntax for rational number constants?  I thought it was 1%2 for 1/2 or something like that.
16:03:29 <shachaf> import Data.Ratio and then 1 % 2
16:03:31 <elliott> yrlnry: 0.5 :P
16:03:34 <shachaf> It's just an operator.
16:03:38 <yrlnry> Thanks.
16:03:39 <elliott> 1/2 works too
16:03:43 <shachaf> Also (1/2 :: Ratio) will work too.
16:03:45 <elliott> I think (%) is a bit harmful
16:03:49 <elliott> since it likes to default its arguments to Integer
16:03:51 <mauke> > 0.5 :: Rational
16:03:52 <lambdabot>   1 % 2
16:03:59 <elliott> er, that's not what I meant.
16:04:01 <elliott> I forgot what I meant.
16:04:29 <shachaf> @ty (R.%)
16:04:30 <lambdabot> Integral a => a -> a -> Ratio a
16:04:32 <yrlnry> I'm puzzled.  What is happening in (1/2) ?
16:04:43 <yrlnry> (/) :: Fractional a => a -> a -> a
16:04:48 <yrlnry> How does 1 become a Fractional?
16:04:50 <shachaf> 1 and 2 are Rationals
16:04:55 <mauke> :t 1
16:04:57 <lambdabot> Num a => a
16:04:58 <shachaf> How does 1 become a Double or an Int?
16:05:08 <mauke> how is nummy formed?
16:05:23 <mauke> :t fromInteger
16:05:24 <lambdabot> Num a => Integer -> a
16:28:51 --- mode: ChanServ set +o elliott
16:29:03 --- mode: elliott set +b *!*@cpe-108-185-218-246.socal.res.rr.com
16:29:06 --- kick: Ndit was kicked by elliott (ban evasion)
16:29:08 --- mode: elliott set -o elliott
16:34:39 <joelteon> anybody know how to takeTill a string with attoparsec?
16:36:51 <joelteon> like a failing version of scan
16:41:04 <ion> hodapp: #dataflow, huh? You might find it interesting that the audio restoration of edwardk’s lens video was done using pd. :-)
16:44:41 <Fuuzetsu> The original audio was horrible.
16:45:08 <yrlnry> I have « sqrt n = Rel (Poly [-n, 0/1, 1/1]) » which has type Relator.sqrt :: Fractional p => p -> Relator p  as I expect.
16:45:37 <yrlnry> But I also have « s2 = sqrt 2 »  and instead of type Fractional p => Relator p, it has type Relator Double.
16:45:39 <yrlnry> Why Double?
16:45:46 <yrlnry> Is this the !@@! monomorphism restriction again?
16:45:55 <shachaf> Yep.
16:46:06 <yrlnry> Why does it do that?
16:46:17 <shachaf> Why what?
16:46:28 <shachaf> Why does the monomorphism restriction exist?
16:46:28 <yrlnry> What it did that I just described.
16:46:30 <yrlnry> Yes.
16:46:37 <arkeet> @where dmr
16:46:37 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
16:46:46 <shachaf> Because otherwise you might have x :: Num a => a; x = sum [1..100000000000]
16:46:53 <shachaf> And it won't be shared even if you use it as Integer every time.
16:47:01 <shachaf> Er, without the signature.
16:47:47 <arkeet> would it be shared with a SPECIALIZE ?
16:48:16 <shachaf> Hmm, I don't know.
16:48:33 <shachaf> Anyway that's the reasoning behind the MR.
16:49:45 <shachaf> goodbyrlnry
17:17:27 <joelteon> is there any way to takeTill a string in attoparsec?
17:17:31 <joelteon> a way that doesn't break inside many?
17:17:39 <joelteon> and by break, I mean loop infinitely
17:19:42 <joelteon> well, ok, so takeTill fails inside many too
17:19:48 <joelteon> I'm doing this wrong, aren't I
17:21:43 <Bor0> why is it that (== 3) 4 is OK, but 3 `==` 4 is not OK? however, 3 == 4 works
17:22:02 <Bor0> going by the analogy that (x 3) 4 <=> 3 `x` 4
17:22:31 <joelteon> because == is already infix
17:22:36 <Gracenotes> (==3) 4 is not the same as (==) 3 4
17:22:55 <Bor0> isn't everything by default prefix?
17:22:59 <joelteon> no
17:23:02 <Gracenotes> (==3) implicitly means (\x -> x == 3)
17:23:03 <joelteon> well, not exactly
17:23:16 <joelteon> operators are infix, (operator)s are prefix
17:23:18 <Bor0> how do you mean Gracenotes ?
17:23:23 <joelteon> and you can't force-infix a prefix operator because that would be pointless
17:23:54 <elliott> a name made out of symbols is infix
17:23:59 <koala_man> joelteon: takeTill already repeats. how are you combining it with many?
17:23:59 <elliott> therefore (a == b)
17:24:18 <elliott> putting symbols in parentheses makes it prefix, therefore (==) a b is the same as a == b
17:24:26 <Bor0> thanks joelteon
17:24:29 <elliott> and you have sectioning, (a ==) is \b -> a == b
17:24:31 <Bor0> Gracenotes, so what does (==) 3 4 mean implicitly?
17:24:33 <elliott> and (== b) is \a -> a == b
17:24:48 <elliott> oppositely, putting letters in backquotes make them infix: foo `bar` baz is bar foo baz
17:24:49 <TravisD> Is there much danger in using Lens without fully understanding how it works?
17:24:52 <Bor0> :t shows that they are both equal
17:24:53 <lambdabot> Not in scope: `that'
17:24:53 <lambdabot> Not in scope: `they'
17:24:53 <lambdabot>     Not in scope: `are'
17:25:02 <Bor0> :t (== 3)
17:25:03 <lambdabot> (Eq a, Num a) => a -> Bool
17:25:04 <Bor0> :t (==) 3
17:25:05 <lambdabot> (Eq a, Num a) => a -> Bool
17:25:05 <Gracenotes> Bor0: for an infix symbol, (== 3) is a special syntax that applies 3 as the *second* argument of (==). whereas, (==) will take a first then second argument
17:25:08 <apples> b/fufer 5
17:25:11 <apples> sorry
17:25:21 <Gracenotes> > (/5) 10
17:25:23 <lambdabot>   2.0
17:25:26 <Gracenotes> > (/) 5 10
17:25:27 <lambdabot>   0.5
17:26:09 <Bor0> hmm, interesting
17:26:41 <Gracenotes> if Eq a is symmetric for a, yes, by definition they will have the same behavior for (==). (/) has the same type, not the same behavior.
17:27:26 <Bor0> what's the intuition behind (== 3) applying 3 as the _second_ argument instead of first?
17:27:40 <Bor0> s/intuition/reasoning/
17:27:52 <joelteon> koala_man: I'm trying to takeTill a string, not a char
17:28:00 <joelteon> not takeTill literally, but do what takeTill does
17:28:11 <Gracenotes> (3 ==) applies it as the first.
17:28:22 <Gracenotes> because you're "leaving out" the second argument
17:28:22 <FreeFull> Bor0: http://www.haskell.org/haskellwiki/Section_of_an_infix_operator
17:28:35 <shachaf> Bor0: Take a function that isn't commutative.
17:28:35 <Bor0> ahhh, I see it now
17:28:35 <FreeFull> It's basically special syntax for all infix operators
17:28:41 <shachaf> Bor0: (/ 5) 3  --->  3 / 5
17:28:44 <Bor0> thank you!
17:29:18 <Bor0> okay, it makes perfect sense
17:30:47 <Bor0> FreeFull, thanks for the link. especially nice one with the - and subtract thing :)
17:31:18 <koala_man> joelteon: same question, though. you should make sure that whatever you pass to 'many' will consume at least one character or  fail.
17:31:52 <joelteon> meh
17:32:18 <joelteon> the problem is that "&a\t" is a special thing and "&a[anything not a tab]" is just a string
17:32:38 <joelteon> here, I'll make an hpaste
17:34:26 <johnw> koala_man: I think "some" will fail if there is not at least one
17:35:08 <joelteon> http://hpaste.org/89520
17:35:39 <joelteon> before this, I didn't have a Str parser, the last alternative in the list would just be a single char
17:35:54 <joelteon> and that worked because it would try to parse each tag pair before falling back to a single character
17:36:15 <joelteon> and I feel like splitting a text into single characters and putting them back together for output is really inefficient, but I don't think there's any way to do it
17:39:05 <joelteon> it's a lot more complicated than that, but that example is a good baseline, I guess
17:41:34 <koala_man> joelteon: I would do many (readTagGroup <|> readSingleCharacter), where readTagGroup = try "&a\t" >> whatever
17:41:34 <joelteon> the problem being that many is a greedy combinator
17:42:07 <joelteon> koala_man: https://github.com/joelteon/lexie/blob/master/Lexie/Tablumps.hs#L117-#L141
17:42:09 <koala_man> try (string "&a\t"), I mean. and sorry about the non-atto parsec, it's all I know
17:42:12 <joelteon> that's pretty much what I'm doing at the moment
17:42:49 <joelteon> the problem is that Char <$> anyChar will find "&b\t" and then match "hello&/b\t" and the input will end
17:43:11 <joelteon> and Char <$> notChar '&' will fail on "&b\thell&o&/b\t"
17:43:51 <TravisD> are there any Lenses for the hmatrix library?
17:43:58 <Hafydd> bthellobt
17:44:47 <joelteon> this format just sucks
17:45:25 <joelteon> maybe I could make &b\t and &/b\t their own entities
17:45:31 <koala_man> joelteon: your readTagGroup would similarly do many (readTagEnd c <|> anySingleCharacter). this would work because readTagEnd will read the end tag if any, otherwise it will consumed as a single regular character. then it tries again
17:45:41 <joelteon> oh, that might be a great idea
17:46:22 <joelteon> but they have to be recursive too
17:46:40 <joelteon> so readTagEnd c <|> tablumps
17:46:40 <koala_man> that's fine, it works the same way
17:46:45 <joelteon> right...
17:47:17 <koala_man> readTagEnd c <|> readTagGroup <|> anySingleCharacter
17:47:20 <joelteon> but then wouldn't it continue trying to match more single characters after the end tag?
17:48:01 <koala_man> you mean in the case of "&b\tfoo&/b\t", when input ends, wouldn't it try to match single characters?
17:48:11 <joelteon> yeah, but if the input doesn't end
17:48:53 <joelteon> manyTill (readTagEnd c) (readTagGroup <|> anyChar) maybe
17:48:54 <koala_man> it would first try to match a new tag end or a new tag group
17:48:58 <joelteon> right
17:49:05 <joelteon> but it would have to stop once it encountered an end tag
17:50:17 <koala_man> it doesn't have to stop, because it only reads one character at the time
17:50:32 <joelteon> okay
17:50:39 <joelteon> many (readTagEnd c <|> anySingleCharacter)
17:50:48 <joelteon> when does that parser stop matching?
17:51:07 <joelteon> sorry I'm just not following you
17:51:09 <johnw> joelteon: parseTest (some ((char '&' *> anyChar *> char '\t' *> some (notChar '&') <* char '&') <|> some (notChar '&'))) (Data.Text.Encoding.encodeUtf8 (Data.Text.pack "Hello &x\t world& this &t is"))
17:51:13 <johnw> that works with Attoparsec
17:51:20 <johnw> yields: Done "&t is" ["Hello "," world"," this "]
17:51:46 <johnw> oh, tack on a <|> char '&' parser too, for consuming isolation &'s
17:51:55 <johnw> isolated
17:52:26 <koala_man> johnw: oh yeah, I see what you mean. yes, you'd use your manyTill
17:52:52 <johnw> I think manyTill can probably replace some (notChar '&') <* char '&', but it wasn't working fro me
17:52:58 <zRecursive> @ty (<|>)
17:52:59 <lambdabot> Alternative f => f a -> f a -> f a
17:53:12 <johnw> zRecursive: a <|> b says: do a, if it fails, do b
17:53:17 <zRecursive> @ty many
17:53:18 <lambdabot> Alternative f => f a -> f [a]
17:53:22 <johnw> where failure is indicated by "mzero" from the MonadPlus type class
17:53:41 <zRecursive> johnw: yeah
17:53:44 <johnw> it's not just for parsers either
17:53:51 <johnw> > Nothing <|> Just 20
17:53:53 <lambdabot>   Just 20
17:54:00 <johnw> > Just 10 <|> Just 20
17:54:02 <lambdabot>   Just 10
17:54:23 <zRecursive> similar with logical
17:54:26 <zRecursive> or
17:54:32 <johnw> in some sense, yes
17:54:34 <johnw> but:
17:54:38 <johnw> > [1] <|> [2]
17:54:39 <lambdabot>   [1,2]
17:54:53 <johnw> for other monads, it's similar to union
17:54:58 <zRecursive> it is in list instance
17:55:12 <zRecursive> i see
17:55:58 <zRecursive> @ty choice
17:55:59 <lambdabot> Not in scope: `choice'
17:57:14 <hpc> funny thought
17:57:27 <hpc> for lists, (<|>) over length = (+)
17:57:36 <hpc> and (>>) over length = (*)
17:58:11 <johnw> >>?
17:58:13 <joelteon> @pl \x -> manyTill x <* x
17:58:13 <lambdabot> (<*) =<< manyTill
17:58:16 <johnw> > [1,2] >> [3,4]
17:58:16 <hpc> :t (>>)
17:58:18 <lambdabot>   [3,4,3,4]
17:58:18 <lambdabot> Monad m => m a -> m b -> m b
17:58:20 <johnw> ah
17:58:28 <joelteon> @pl \y x -> manyTill y x <* x
17:58:28 <lambdabot> join . ((<*) .) . manyTill
17:58:58 <johnw> joelteon: that's the same as many (try y) <* x
17:59:12 <johnw> (I believe)
17:59:46 <zRecursive> odd,  [1,2] >> [3,4] => [3,4,3,4]
18:00:04 <johnw> > [1,2] >>= \ -> [x,3,4]
18:00:06 <lambdabot>   <hint>:1:13: parse error on input `->'
18:00:08 <johnw> > [1,2] >>= \x -> [x,3,4]
18:00:10 <lambdabot>   [1,3,4,2,3,4]
18:00:29 <johnw> >> is just throwing away the fed value
18:01:21 <zRecursive> i see
18:05:41 <joelteon> johnw: I believe many is greedy and manyTill is lazy
18:05:57 <johnw> that makes sense
18:06:17 <joelteon> otherwise we wouldn't need them both lol
18:06:36 <TravisD> Is there an operator that lets me get the target of a Lens in a monadic state? (Kind of the opposite of .=)?
18:07:14 <johnw> what is the "target of a lens"?  You mean the value it's applied to?
18:09:45 <TravisD> johnw: I'm not sure. I want to use a getter to get a value out of the s in a State s a. Sorry for not knowing what words to use
18:10:06 <johnw> and you don't just want "get"?
18:11:37 <TravisD> Just a sec. I'll try to write some code that does what I want and then maybe we can talk about it
18:20:48 <TravisD> johnw: http://hpaste.org/89524
18:20:56 <TravisD> kind of a goofy example
18:21:43 <shachaf> _2 %~ (++ str) -- ?
18:21:54 <shachaf> Er, %=
18:23:02 <TravisD> What's a profunctor?
18:23:57 <TravisD> Ah, functions are instances of Profunctor, it looks like
18:24:02 <shachaf> An instance of Profunctor in Haskell is contravariant in the first argument and covariant in the second.
18:24:06 <shachaf> Yep. Functions for example.
18:24:43 <TravisD> so %= lets you update things by applying a function to them?
18:25:43 <shachaf> "l %= f" means "modify (l %~ f)"
18:26:12 <elliott> shachaf: isn't there a ++~?
18:26:38 * hackagebot fay 0.15.0.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.15.0.0 (AdamBergmark)
18:26:40 <shachaf> elliott: There is <>~ and even <>=
18:26:48 <TravisD> elliott: I don't specifically want to append strings. I was just wanting to avoid += and stuff
18:26:55 <shachaf> But knowing that is less important than understanding the general pattern.
18:27:09 <shachaf> Also I don't like ++= because it encourages you to left-associate.
18:27:25 <TravisD> <>= and <>~ do mappend for monoids?
18:27:38 <shachaf> I recommend looking at the code.
18:27:44 <TravisD> sure
18:27:44 <shachaf> (Or documentation, if you're into that sort of thing.)
18:28:07 <shachaf> http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/src/Control-Lens-Setter.html
18:28:43 <shachaf> I think that's the most direct answer to what things mean.
18:28:51 <shachaf> Assuming you know how lens works in general, at least. :-)
18:29:05 <TravisD> I dont :)
18:29:40 <mm_freak> if you're using a State to build something monoidally you're probably doing it wrong
18:29:44 <mm_freak> Writer is a better option there
18:30:34 <TravisD> mm_freak: yeah, it was just an example of the type of thing I was trying to avoid
18:30:53 <TravisD> mm_freak: I actually want to update some arrays
18:31:23 <TravisD> Does anyone know of an introduction to lens other than the derivation? I was having a bit of a hard time following that
18:31:35 <johnw> have you seen edwardk's presentation?
18:31:51 <TravisD> johnw: I've watched about an hour of it, but I don't remember much
18:31:52 <shachaf> I started writing one once but then I stopped.
18:32:28 <TravisD> johnw: I'm not very comfortable with a lot of  Haskell, so sometimes things in his talk feel very fast
18:32:38 <johnw> the intro I started writing is very basic so far, I think you're already beyond it
18:32:41 <shachaf> Mine would be the best introduction because it matches the way I think exactly (which happens to be the correct way to think).
18:32:58 <TravisD> heh
18:33:01 <johnw> http://newartisans.com/2012/11/getting-started-with-lenses/
18:33:07 <TravisD> johnw: So far i've mostly been pattern matching with the examples
18:33:35 <johnw> now that lens development has slowed due to edwardk's fascination with analytics, maybe the dust has settled enough to write the next in that series
18:35:39 <TravisD> "In this example, _1 is a lens, which means it represents both a getter and setter focused on a single element of a data structure." -- something I thought I knew, but wasn't very confident about :)
18:40:07 <TravisD> johnw: Thanks for the post. It was very gentle
18:40:24 <johnw> I think I originally was going to call it "A Gentle Introduction to Lens" :)
18:41:21 <applicatiative> you write the Gentle Introduction, then I'll write Yet Another ...
18:42:27 <applicatiative> YALT
18:42:36 <augur> YAGT
18:42:44 <augur> er
18:42:46 <augur> YAGI :|
18:42:58 <TravisD> YAGLT
18:43:25 <augur> yet another gentle introduction
18:43:41 <TravisD> or, more ridiculously, yet another gentle lens tutorial
18:43:42 <applicatiative> LYAL-FGG will the the lens tutorial with pictures
18:43:54 <TravisD> heh
18:44:26 <augur> yet another gentle introduction to learning you a ...
18:45:14 <applicatiative> this fpcomplete $1000US prize; it's a little opaque what it will be like
18:45:49 <jmcarthur> yeah i wish they had just waited to announce it until they actually had the rules
18:46:43 <TravisD> is it a prize for writing the best article or something?
18:47:12 <jmcarthur> TravisD: https://www.fpcomplete.com/blog/2013/06/call-for-submissions
18:47:47 <applicat1ative> are they saying that each month they will state some problem or task
18:48:28 <applicat1ative> are they saying, send us your cool solution to some real problem,
18:48:43 <applicat1ative> or that they will set some problem or task each month
18:49:05 <TravisD> Hmm, yeah. The distinction between "applied problem" and "problem" also seems a bit blurry
18:49:47 <applicat1ative> I wasnt worried about that, that they are looking for 'real world' haskell stands to reason
18:50:15 <applicat1ative> but a monthly competition sounds like they will announce the task or whatever
18:50:46 <applicat1ative> it must be the latter, since they envisage constituting a 'cookbook'
18:50:47 <TravisD> does 'real world' include academia?
18:51:34 <applicat1ative> no, its defined as 'not academic'
18:52:16 <TravisD> heh, I guess. There could be interesting applications to non-programming-language academic things
18:52:36 <applicat1ative> paper-grading, a purely functional approach
19:02:34 <voxpopuli> Question: inside of a where clause, can I define a function using pattern guards?
19:03:12 <shachaf> Did it not work when you tried it?
19:04:54 <voxpopuli> no, it gave me a parse error
19:05:10 <geekosaur> @paste your code?
19:05:10 <lambdabot> Haskell pastebin: http://hpaste.org/
19:07:30 <voxpopuli> http://hpaste.org/89525
19:09:21 <geekosaur> I think the inner guards need to be indented past the start of the definition? (like 3 more spaces)
19:10:17 <voxpopuli> doh
19:10:19 <voxpopuli> thanks
19:10:27 <voxpopuli> should have been able to figure that out
19:40:09 <wavewave> hi.
19:40:31 <shachaf> hi wavewave
19:40:34 <wavewave> I arrived in phila.
19:40:39 <tgeeky> wavewave: at hacphi, so I hear! cool!
19:40:53 <shachaf> #haskell-hacphi
19:41:45 <TravisD> Is this appropriate usage of rank2 types: http://hpaste.org/89526? I want to make sure that anything of type Bandit cannot alter the state s of a RandState s a.
19:51:54 <monochrom> TravisD: it is not really rank-2
19:53:36 <TravisD> ah. because the forall is in the front?
19:54:02 <TravisD> actually, never mind. Why not?
19:54:11 <monochrom> but! your "run" function will be like run :: (forall s. RandState s a) -> a, and that is rank-2, and that provides the protection you want
19:55:55 <monochrom> on a tangent, I repeat my dislike of type synonyms. type synonym means failing to make up your mind whether you want an abstraction or not
19:56:15 <shachaf> Yes.
19:56:21 <shachaf> If only newtypes were more convenient!
19:57:42 <monochrom> I am actually not sure of the utility of forall s. StateT s stuff stuff
19:58:04 <TravisD> yeah, maybe it's not what I want
19:58:26 <monochrom> when I call "get", what do I get? I can't even choose its type. what can I do with it?
19:58:37 <TravisD> So I want some (RandState s) actions that are guaranteed not to modify the state
19:59:27 <TravisD> but others will
19:59:55 <TravisD> It's actually not a big deal. The main thing is that I dont want the Bandit type to be parameterized on s, since that's tedious to write all over the place
20:07:02 <dmwit> TravisD: Assuming for the moment RandState is equal to State, why not let your "actions that can't modify the state" just be pure values/functions?
20:07:40 <TravisD> dmwit: that makes sense
20:07:55 <dmwit> Letting that moment pass, and assuming in the new moment that RandState is actually RandT (State s), why not let your "actions that can't modify the state" be of type RandT m for polymorphic m?
20:08:30 <TravisD> that also makes sense
20:08:49 <dmwit> hm
20:08:59 <dmwit> If both of those makes sense... what is RandState? O_o
20:09:33 <applicat1ative> hm, I didn't notice this 'hack phi' is happening.
20:10:09 <dmwit> We sent emails to the major lists and posted on reddit and (I think?) Hacker news.
20:10:33 <dmwit> What additional medium should we have used to attract you? =)
20:10:36 <TravisD> dmwit: I don't understand the last question. I think RandState is isomoprhic to RandT (State s)
20:10:37 <applicat1ative> yes, but dates are just numbers so i don't notice
20:10:39 <applicat1ative> ha
20:11:23 <applicat1ative> are people doing anything interesting dmwit?
20:11:37 <dmwit> for sure
20:11:38 <monochrom> also, "hac phi" is just a string... :)
20:11:58 <shachaf> > "hac φ"
20:11:58 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
20:12:03 <dmwit> I was only there for a little bit today, and I was sort of absorbed in my own little project.
20:12:04 <shachaf> @slap lambdabot
20:12:04 * lambdabot slaps lambdabot
20:12:20 <dmwit> But you could poke some of the folks on the Hac Phi channel if you want to hear more. =)
20:12:23 <shachaf> kappabot: @run "hac φ"
20:12:25 <kappabot>   "hac \966"
20:12:28 <shachaf> kappabot: @run text "hac φ"
20:12:29 <kappabot>   hac φ
20:12:41 <monochrom> kappabot++
20:12:57 <applicat1ative> nice command
20:12:58 <monochrom> kappabot is the role model of all bots
20:13:05 <applicat1ative> kappabot: @run 1
20:13:06 <kappabot>   1
20:13:27 <applicat1ative> kappabot++
20:13:32 <applicat1ative> @botsnack
20:13:32 <lambdabot> :)
20:13:32 <kappabot> :)
20:13:34 <applicat1ative> haha
20:13:38 <monochrom> kappabot: @run text "a\nb"
20:13:39 <kappabot>   a
20:13:40 <kappabot>  b
20:14:37 * applicat1ative wonders if the car would break down before he got to philadelphia anyway
20:17:57 * zRecursive time to lunch
20:23:15 <applicat1ative> hm, edwardk on 'big data in haskell' ...
20:23:49 <Gracenotes> whar?
20:24:15 <applicat1ative> dunno just looking at the hackphi page http://www.haskell.org/haskellwiki/Hac_%CF%86/Talks
20:24:26 <Gracenotes> oh, hacphi, yeah
20:24:33 <arkeet> when is hac phi?
20:24:37 <applicat1ative> are you there Gracenotes ?
20:24:40 <monochrom> now
20:24:42 <arkeet> doh
20:24:44 <Gracenotes> this weekend
20:24:56 <Gracenotes> not there, have a bunch going on really
20:25:03 <arkeet> oh, and location wouldn't work for me anyway
20:25:07 <applicat1ative> arkeet doesnt distinguish dates either I see
20:25:42 <arkeet> ??
20:26:01 <applicat1ative> oh, arkeet it was just that you were wondering when it was
20:26:17 <Gracenotes> big data seems to be just as much about abstracting away details as it is about scale.
20:26:34 <Gracenotes> at least as far as the data-level algorithms ago
20:26:36 <Gracenotes> *go
20:26:52 <arkeet> applicat1ative: I'm sure someone told me once, and I also could have just looked it up.
20:27:26 <Gracenotes> at least going by companies which advertise their APIs as big-data friendly
20:28:11 <applicat1ative> bos has a less kind theory http://www.serpentine.com/blog/
20:28:35 <applicat1ative> Big fucking deal[1][2] is a collection of deals so fucking large and complex that it becomes difficult to process using on-hand fuck giving tools or traditional shit giving techniques. The challenges include capture, curation, storage,[3] search, sharing, transfer, analysis,[4]
20:28:52 <Gracenotes> yeah really, maybe 0.001% of companies which have data have big data
20:29:09 <Gracenotes> in the sense of even requiring multiple machines to run learning on
20:29:39 <applicat1ative> what interested me most was that edwardk attached any definite sense to the words 'big data'.
20:29:41 <Gracenotes> or doing learning in constant space and distributed
20:30:09 <DiegoNolan> If i have a function that is a -> b -> IO Maybe c how can i write pass it Maybe a Maybe b in an applicative style
20:30:38 <Gracenotes> IO Maybe c isn't really a type... though IO (Maybe c) is :p
20:30:40 <arkeet> you mean IO (Maybe c), and you can't.
20:30:46 <DiegoNolan> yeah IO (Maybe c)
20:30:49 <josephle> so I'm trying to wrap my head around GADTs, and I'm trying to write up a simply typed lambda calculus interpreter
20:30:55 <arkeet> you need some monadic stuff to do that.
20:31:00 <DiegoNolan> ahh
20:31:02 <DiegoNolan> hmm
20:31:09 <DiegoNolan> okay let me think about it then
20:31:12 <josephle> I'm trying to add recursive types, but I can't grok the type for Fold or Unfold
20:31:20 <arkeet> compare (a -> Maybe b) -> Maybe a -> Maybe b
20:31:22 <arkeet> that's (=<<)
20:31:23 <applicat1ative> liftM2 diego m1 m2 would be a Maybe (IO (Maybe c))
20:31:53 <DiegoNolan> i tried lift liftA2
20:32:04 <DiegoNolan> but i didn't reall want another monad around
20:32:06 <DiegoNolan> the return
20:32:15 <DiegoNolan> i just wanted to consider them all failures
20:37:07 <Gracenotes> I'm trying to think of a nice way to do Maybe (IO (Maybe c)) -> IO (Maybe c), or even just Maybe (IO a) -> IO (Maybe a)
20:37:20 <Gracenotes> it's been a while since I've done transformers
20:37:34 <knrafto> fmap join . sequenceA $ liftA2 f m1 m2
20:38:15 <applicat1ative> hah I was about to write \op m n ->  liftM join $ T.sequence $ liftM2 op (Just m) (Just n) :: Monad m => (a1 -> a2 -> m (Maybe a)) -> a1 -> a2 -> m (Maybe a)
20:38:28 <Gracenotes> ah, yeah. traversable sequence.
20:38:34 <DiegoNolan> hmm
20:38:48 <applicat1ative> somehow I think pattern matching is just as well here DiegoNolan
20:38:48 <DiegoNolan> i thought there would be a more elegant way to do this
20:39:04 <DiegoNolan> yeah
20:39:09 <DiegoNolan> i'm kind of surprised
20:39:10 <latermuse> what is the correct regex library to use with a big data set? (i need best average complexity)
20:39:11 <Gracenotes> foo (Just a) (Just b) = ...
20:39:13 <applicat1ative> yeah i wonder if we're missing it
20:39:19 <wavewave> Gracenotes: try MaybeT
20:39:28 <DiegoNolan> yeah i guess
20:39:30 <DiegoNolan> but like
20:39:44 <DiegoNolan> its easy to do a -> b -> Maybe c
20:39:56 <DiegoNolan> but just having the function be IO makes it a pain
20:40:10 <Gracenotes> hm... not sure if MaybeT would help...
20:40:13 <wavewave> runMaybeT $ do {  a <- MaybeT . act ;  ...  }
20:40:32 <wavewave> MaybeT is quite helpful. I am using it quite often.
20:41:07 <wavewave> ehh. "MaybeT . act"  should be "MaybeT act"
20:41:53 <Gracenotes> hm, yeah, under wraps, that is somewhat similar to the case analysis we're suggesting.
20:41:55 <wavewave> If one has a series of frequent Maybe operation, MaybeT is useful.
20:41:57 <Gracenotes> x >>= f = MaybeT (runMaybeT x >>= maybe (return Nothing) (runMaybeT . f))
20:42:12 <wavewave> yeah
20:42:25 <DiegoNolan> yeah tha does look nice
20:42:30 <wavewave> also look at EitherT
20:42:40 <wavewave> if you have more error handling.
20:42:50 <Gracenotes> given that we've unwrapped Maybe and Maybe b, run the IO action, then put Maybe into the monadic context of IO
20:42:55 <Gracenotes> *Maybe a and Maybe b
20:44:03 <applicat1ative> if two things are given as Maybe a, how best to get them into MaybeT IO a?
20:44:25 <applicat1ative> MaybeT $ return ma?
20:44:29 <wavewave> Maybe . return
20:44:36 <wavewave> MaybeT . return $ .. yeha
20:45:00 <wavewave> make a utility function for it
20:45:09 <applicat1ative> do {a <- MaybeT $ return ma; b <- MaybeT $ return mb; MaybeT $ op a b}
20:45:23 <applicat1ative> then runMaybeT on that will be an IO (Maybe c)
20:45:42 <wavewave> if it's just pure series of Maybe, then just use Maybe monad first ;-)
20:45:53 <applicat1ative> we're typing more, but in the context it might be worth it.
20:46:02 <wavewave> do { a <- maybeact1 ; b <- maybeact2 ... }
20:46:15 <applicat1ative> DiegoNolan was working with an a -> b -> IO (Maybe c) and two maybes
20:46:52 <wavewave> once pattern is well recognized, then make some utility functions and reuse them. it can be quite handy.
20:47:33 <wavewave> upMT = MaybeT . return   .. or something like that.
20:48:13 <wavewave> anyway. Maybe and MaybeT are close friends ;-) like all other monads and monad transformers.
20:49:21 <DiegoNolan> yeah i ended up wrting a pattern matching function because i had to liftIO at the end of all that because i'm in snap monad
20:54:04 <applicat1ative> newtype Snap a = Snap {unSnap :: StateT SnapState (Iteratee ByteString IO) (Maybe (Either Response a))
20:54:43 <applicat1ative> (Maybe (Either Response a)) seems a bit of overkill
20:55:18 <Gracenotes> maybe you do want three possibly types
20:55:20 <Gracenotes> *possible
20:56:22 <Gracenotes> a proper response, an error response, and an error with no response
20:57:25 <Gracenotes> the error-which-shall-not-be-named
20:58:17 <applicat1ative> yes it makes sense I was thinking it best to bury the Nothing in Request, but its a proper record
20:59:45 <applicat1ative> oh actually they changed it sort of like I was thinking,       unSnap :: StateT SnapState (Iteratee ByteString IO) (SnapResult a)
21:00:13 <DiegoNolan> besides the templating engines what are the other differences between yesod and snap
21:00:25 <applicat1ative> where snapresult is SnapValue a | PassOnProcessing String  | EarlyTermination Response
21:01:13 <applicat1ative> they use different io machineries, yesod conduit, snap I dont understand, it is moving from enumerator to iostreams
21:01:51 <applicat1ative> but i don't understand whats up with iostreams myself
21:02:29 <DiegoNolan> ic
21:04:15 <applicat1ative> there seem to be other basic differences in attitude, yesod aspiring to be something more like a 'framework' in the conventional sense.
21:04:33 <applicat1ative> rather than an assemblage of libraries.
21:04:38 <latermuse> > "foo foo foo" =~ "foo" :: [String]
21:04:39 <lambdabot>   Not in scope: `=~'
21:04:39 <lambdabot>  Perhaps you meant one of these:
21:04:39 <lambdabot>    `==' (imported from ...
21:05:02 <latermuse> > "foo foo foo" Text.Regix.Posix.=~ "foo" :: [String]
21:05:03 <lambdabot>   Not in scope: `Text.Regix.Posix.=~'
21:05:53 <DiegoNolan> well it seems fpcomplete supports yesod
21:06:13 <fwappy> What is the best place for Haskell chat in Japanese?
21:06:33 <shachaf> fwappy: #haskell.jp has 9 people
21:07:07 <Adeon> that's 100 times less than here
21:07:30 <fwappy> Now it has 10 :)
21:07:56 <shachaf> Adeon: Let's see this channel gain >10% users so quickly!
21:07:58 <Gracenotes> it's not necessarily the best place, but it is the best place on freenode
21:08:10 <shachaf> I hear the best place is Twitter or something.
21:08:19 <applicat1ative> DiegoNolan: oh yes, that's obviously a plus.  In general there seems more of a community and a community mentality, but this is said totally from the outside, so dunno
21:08:37 <fwappy> I was trying to fins a good room on ircnet, but couldn't find one with anyone in it
21:09:14 <Gracenotes> not just supports yesod, basically wrote it
21:09:54 <Gracenotes> well, before FP Complete existed
21:13:01 <Gracenotes> hm. Haskell's wikipedia page says: "As a functional programming language, the primary control construct is the function."
21:13:06 <Gracenotes> this isn't really true, though
21:13:13 <Gracenotes> if it were, it would be easy to make a stack trace.
21:13:37 <shachaf> "functional programming language" is a great term because it can mean whatever you want.
21:14:17 * tabemann hears OCaml being called a "functional programming language", when very much of the programming he's done in it has been very imperative
21:14:30 <Gracenotes> and despite that lenience, the statement is still incorrect
21:15:00 <Gracenotes> tabemann: OCaml makes it very difficult to do some things purely
21:15:08 <Gracenotes> and efficiently
21:17:14 <josephle> @pl (\x -> Just x >>= (\y -> return (y,2))) :: Int -> Maybe (Int,Int)
21:17:14 <lambdabot> (line 1, column 50):
21:17:15 <lambdabot> unexpected '>'
21:17:15 <lambdabot> expecting operator
21:17:25 <tabemann> and the standard APIs that come with it are definitely designed with imperative code in mind
21:17:49 <Gracenotes> The sentence has also been around since January 30, 2010
21:17:59 <josephle> !pl (\x -> return x >>= (\y -> return (y,2))
21:18:08 <Gracenotes> it reached due for its 3.5 year anniversary soon
21:18:08 <josephle> @pl (\x -> return x >>= (\y -> return (y,2))
21:18:09 <lambdabot> (line 1, column 41):
21:18:09 <lambdabot> unexpected end of input
21:18:09 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or ")"
21:18:14 <Gracenotes> *it's due
21:18:18 <josephle> @pl (\x -> return x >>= (\y -> return (y,2)))
21:18:18 <lambdabot> return . flip (,) 2
21:31:37 <latermuse> do i need to uninstall or remove an old version of the haskell platform before installing a new one? (on mac 64bit)
21:36:20 <DiegoNolan> has anyone hosted a published a haskell website and what web host did you use?
21:43:56 <latermuse> diegoNolan, I have
21:45:40 <zRecursive> latermuse: in detail ?
21:46:46 <latermuse> zRecursive: what in detail?
21:49:50 <zRecursive> web framework used, and so on.
21:50:32 <latermuse> i built my own framework
21:50:49 * zRecursive oh, maybe i misunderstand it
21:51:34 <zRecursive> latermuse: u havenot used yesod, snap ... ?
21:51:45 <latermuse> i dont use the usual web frameworks (yesod, snap, etc)
21:52:20 <zRecursive> then you program directly on Warp ?
21:52:50 <latermuse> i dont use warp
21:53:06 <latermuse> like i said, i built my own framework
21:53:34 <joelteon> you wrote your own server?
21:53:41 <zRecursive> ok, i see. Is your framework public ?
21:53:47 <leroux> latermuse: warp is a server.
21:53:55 <latermuse> i dont use warp
21:54:04 <leroux> So, you wrote your own web server?
21:54:14 <latermuse> no, my framework compiles to javascript/html
21:54:20 <latermuse> kind of like fay, but different
21:54:36 <latermuse> *shrug*, i guess it isnt normal to do it this way, but it works well for me
21:55:00 <zRecursive> latermuse: how to visit your host ?
21:55:09 <tgeeky> he probably uses apache or something :o
21:55:13 <latermuse> i write my code in haskell, compile it to html/php/javascript, then upload it to a server running apache
21:55:33 <joelteon> A haskell to php compiler, nice.
21:55:35 <joelteon> You should put it on reddit
21:56:11 <zomg> compile haskell to php
21:56:16 <zomg> what.
21:56:18 <latermuse> the code isnt nice. its just designed to be used by myself
21:56:20 <rofer> Wow, I love that the standard library source is so readable
21:56:38 <zomg> it's starting to sound unbelievable tbh
21:56:40 <latermuse> i would basically need to rewrite everything before i could open source it, and i dont have time for that at the moment
21:56:48 <zomg> at the point where it was just html/js it still was something that sounded reasonable
21:56:51 <zomg> but now.. it's not
21:56:51 <zomg> :D
21:57:00 <latermuse> the php is basic stuff
21:57:07 <rofer> I'm trying to write a readBin function and looking at stuff like readOct makes it really easy
21:57:15 <zomg> Why would you want to compile anything into php
21:57:26 <levi> php runs everywhere. :P
21:57:33 <latermuse> because php works natively on the servers im using
21:57:51 <zomg> if you're the only person using it why don't you just get a server that runs the haskell code =)
21:57:52 <joelteon> you could compile it to a binary
21:58:05 <tgeeky> latermuse: I don't think it sounds unresonable, but I implore you not to share your code :)
21:58:19 <zomg> I wrote a php parser / evaluator in Haskell
21:58:24 <zomg> but this still sounds wrong
21:58:24 <zomg> :D
21:58:37 <tgeeky> hehe, well that sounds guaranteed not to be used
21:58:50 <joelteon> zomg: can it handle a()[0]; ?
21:59:02 <zomg> joelteon: I doubt that since it's not exactly feature-complete =)
21:59:12 <joelteon> does it parse PHP?
21:59:25 <latermuse> zomg: i dont setup the servers to just run haskell code because im worried about the security and speed of it
21:59:27 <zomg> I wrote it mostly just as an exercise in using parsec and seeing how implementing a parser/evaluator would work in haskell
21:59:36 <latermuse> i understand the problems in apache better than warp
21:59:40 <joelteon> concerned about speed...uses PHP over haskell.
21:59:42 <joelteon> interesting
21:59:49 <latermuse> the php is just for simple things
22:00:16 <joelteon> zomg: I'm just asking because in most versions of PHP's parser array access was defined as <variable> '[' <expr> ']'
22:00:18 <latermuse> *shrug* this setup works for me and my workload
22:00:24 <joelteon> instead of <expr> '[' <expr> ']'
22:00:41 <joelteon> that's why anything that isn't on the LHS of [index] was a parse error
22:00:42 <zomg> joelteon: Yeah 5.4 adds array dereferencing iirc
22:00:44 <joelteon> yeah
22:12:00 <mzero> there was a blog post circulating this week or perhaps last along the lines of "don't even ask me to use your programming language unless it has these traits...."   anyone remember what it was?
22:12:29 <shachaf> http://sebastiansylvan.com/2013/05/25/language-design-deal-breakers/ ?
22:12:51 <mzero> that was it!
22:12:54 <mzero> thanks!
23:05:12 <mikeplus64> > fail "aa" :: Either () ()
23:05:13 <lambdabot>   *Exception: aa
23:05:55 <mikeplus64> annoying that it doesn't return maybe Left (error "Exception: aa")
23:06:27 <johnw> > fail "aa" :: Maybe ()
23:06:28 <lambdabot>   Nothing
23:06:33 <johnw> agreed
23:06:47 <shachaf> That sounds like a nasty hidden error sort of thing.
23:07:43 <mikeplus64> maybe
23:16:25 <mm_freak> mikeplus64: there is no well-typed 'fail' for Either ()
23:17:12 <mm_freak> i consider the current run-time exception variant far cleaner than what you just proposed
23:21:07 <mikeplus64> mm_freak: yeah. it's just a nuisance, but beats the alternative
23:54:57 <fractalsea> I've hit something that is way beyong my understanding: I using runInterpreter from Language.Haskell.Interpreter which has the signature runInterpreter :: (MonadCatchIO m, Functor m) => InterpreterT m a -> m (Either InterpreterError a) My question is how do I actually extract the value of "a" from Either?
23:55:33 <shachaf> A value of type (Either InterpreterError a) might not contain a value of type a.
23:55:43 <shachaf> In fact, it's either an InterpreterError or an a.
23:56:11 <shachaf> The usual thing you would do is pattern-match on it.
23:56:18 <fractalsea> OK
23:56:29 <shachaf> case something of Left e -> ...; Right x -> ...
23:56:42 <fractalsea> And how would I extract it out of the m (...); that's where I'm fairly lost
23:56:55 <shachaf> You can't.
23:57:01 <Cale> do result <- runInterpreter (...); case result of Left err -> ...; Right v -> ...
23:57:10 <Cale> Well, you run the action
23:57:27 <fractalsea> OK
23:57:29 <Cale> Which in a sense "extracts" it
23:57:34 <shachaf> You should get rid of this idea of "extracting" sometime. :-) A value of type "m a" doesn't usually "contain" a value of type "a".
23:57:46 <Cale> In the same sense as executing /bin/ls extracts a list of files ;)
23:57:48 <shachaf> (It depends on m. But in almost all cases it doesn't.)
23:57:48 <Mortomes> How do you extract the Int from [Int]?
23:58:14 <fractalsea> hmm yes I guess I'm reading it wrong. Just a complete lack of understanding!
23:58:34 <shachaf> Why are you using Language.Haskell.Interpreter?
23:58:47 <fractalsea> To interpret simple arithmatic equations
23:58:49 <shachaf> You probably should be using less complicated libraries to figure these things out.
23:58:53 <shachaf> ?
23:59:14 <fractalsea> well in theory it didn't seem too hard, jusut put in the expression, and out comes the result
23:59:38 <shachaf> Evaluating arbitrary Haskell expressions is a very complicated way of doing arithmetic.
