00:00:01 <prophile> :k Kleisli
00:00:01 <zvrba> why are type constructors called "TYPE constructors" when they construct values? (e.g. Just 3)
00:00:02 <lambdabot> (* -> *) -> * -> * -> *
00:00:03 <Aetherspawn> this works: http://hpaste.org/90391 however if I change it to (getWord64le >>= fromIntegral) it no longer works
00:00:12 <arkeet> zvrba: Just isn't a type constructor.
00:00:14 <ekipan> Just is a value constructor
00:00:14 <arkeet> Maybe is a type constructor
00:00:36 <ekipan> usually we just say "constructor" for "value constructor"
00:00:41 <arkeet> Aetherspawn: because you want fmap, not >>=
00:00:49 <Aetherspawn> ah, thanks
00:00:52 <zvrba> but what else can you do with Maybe than use its value constructors and use it in function signatures?
00:01:01 <arkeet> ??
00:01:06 <Aetherspawn> :t fmap
00:01:07 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:02:05 <zvrba> arkeet: what I wanted to say is that type constructors don't make sense on their own.
00:02:14 <zvrba> there's no Maybe type
00:02:14 <arkeet> sure they do.
00:02:20 <arkeet> they just don't contain any values.
00:02:25 <ekipan> you can pass Maybe to WriterT for instance
00:02:33 <ekipan> @unmtl WriterT Int Maybe Char
00:02:34 <lambdabot> Maybe (Char, Int)
00:02:51 <klrr> HAHAHHAHH
00:02:51 <zvrba> :k WriterT
00:02:52 <lambdabot> * -> (* -> *) -> * -> *
00:03:09 <arkeet> notice that Maybe has the right kind to be a second argument to WriterT
00:03:11 <ekipan> it takes a *type constructor* as an *argument*
00:03:17 <zvrba> arkeet: ohh.
00:03:18 <arkeet> :k WriterT Int String Char
00:03:19 <lambdabot>     Kind mis-match
00:03:19 <lambdabot>     The second argument of `WriterT' should have kind `* -> *',
00:03:19 <lambdabot>     but `String' has kind `*'
00:03:21 <arkeet> ^
00:03:49 <Aetherspawn> I would have expected something like (fmap fromIntegral getWord64le) to work from your advice, but I think I misunderstood.
00:03:56 <arkeet> it should.
00:04:03 <arkeet> unless Get doesn't have a Functor instance, for some reason.
00:04:11 <arkeet> or if you're actually getting a different error.
00:04:17 <Aetherspawn> ""Couldn't match expected type `Int64' with actual type `f0 b0'" is what I get.
00:04:22 <arkeet> possibly ambiguous type.
00:04:34 <arkeet> wait.
00:04:37 <zvrba> ok, enough haskell for this morning. gotta do some real work.
00:04:39 <arkeet> you already have fromIntegral one line 7.
00:04:40 <zvrba> later.
00:04:40 <arkeet> on.
00:05:14 <arkeet> well I better go
00:05:23 <Aetherspawn> oh, okay.
00:05:29 <Aetherspawn> http://hpaste.org/90391
00:06:02 <arkeet> that looks just wrong.
00:06:08 <arkeet> bye
00:07:08 <Aetherspawn> bye
00:07:09 <Aetherspawn> lol
00:07:11 <isomorphic> Aetherspawn:   What's the type of getWord641e?
00:07:19 <Aetherspawn> Get Word64
00:08:28 <isomorphic> What's the definition for Get?
00:09:01 <Aetherspawn> uh,
00:10:06 <Aetherspawn> Monad, Functor, MonadFix, Applicative Get a
00:11:19 <isomorphic> Are you able post a more complete (almost compilable) example?
00:12:37 <Aetherspawn> uh, yes.
00:14:57 <Aetherspawn> isomorphic, http://hpaste.org/90393
00:16:18 <Gracenotes> hm. with APM, should we now have DeriveApplicative?
00:16:38 <jfischoff> hey Gracenotes
00:16:46 <Gracenotes> hm. though, pure might not be the hard bit
00:16:51 <Gracenotes> hallo
00:17:02 <jfischoff> and hey Enigmagic I have a question for you
00:17:34 <jfischoff> what is the function that you call to setup the global fallback exception handler?
00:17:55 <Gracenotes> s/might not be/might be/
00:23:31 <isomorphic> Aetherspawn:  :t fmap fromIntegral getWord64le    ---> fmap fromIntegral getWord64le :: Num b => Get b
00:23:52 <isomorphic> whereas, NXInt64 expects an Int64
00:24:33 <Aetherspawn> and Int64 isn't part of Num?
00:25:32 <kurak0t> OMG compiled haskell hello world was 1 Mbytes in size...
00:25:49 <elliott> you can make it smaller with dynamic linking and stuff.
00:25:57 <elliott> but 1 megabyte really is not a big deal.
00:25:59 <erisco> how do you constrain a type variable to a type class when defining a data type?
00:26:08 <elliott> you can also use another compiler like jhc
00:26:31 <elliott> erisco: use a GADT. there was a standard syntax for doing so but it was useless: it constrained the constructor but did not let you omit the constraint in functions operating on the type
00:26:47 <elliott> erisco: however, usually you should consider simply putting the constraints on your definitions rather than the data type itself
00:27:24 <erisco> fair enough
00:29:07 <klrr> im writing a simple web app, it's shows a log of a irc channel im part of, i got a problem though, how should i store the log while also running the web server providing it as html? my current solution that i might use is that i use forkIO to create a new thread for the irc logger, then the irc logger appends the latest messages in that irc channel to a file every 10 min or so, then someone request the website the webserver reads the file , convert it to html an
00:30:10 <kurak0t> elliott: yeah, that was really not an issue. i was just shocked about that.
00:35:14 <Aetherspawn> I memory mapped a lazy bytestring and I get a segfault when reading anything past 2^18 bytes exactly even though the file is 471mb and the length of the bytestring reports 471053056 bytes
00:35:21 <Aetherspawn> *memory mapped a file to a lazy bytestring
00:51:26 <isomorphic> Aetherspawn: Sorry for the delay - do mtype <- getWord16le ;  case mtype of ;    1 -> fmap (NXInt64 . fromIntegral) getWord64le ;    _ -> return NXNil
00:51:49 <Aetherspawn> Ohh, I get it. Thanks!
00:52:25 <isomorphic> np
01:16:54 <bartavelle> is it recommended to use uu-parsinglib ? having all possible parses for ambiguous parsers seemed nice, but it has been horrible to use so far ...
01:18:13 <Taneb> bartavelle, I'd just use parsec or something for parsing
01:18:48 <bartavelle> I already have a "parsec" parser working, but I suspect there are cases where I forgot a "try", that's why I was interested in uu-parsinglib
01:19:04 <bartavelle> I agree that using parser seems to be much more obvious
01:19:12 <bartavelle> erm, parsec
01:20:13 <supki> if you think you may forget a "try", try attoparsec
01:20:30 <bartavelle> I really need the position in error messages ...
01:20:37 <bartavelle> (and during parsing)
01:21:39 <Aetherspawn> Why not test until you get unwanted behaviour and then track down places you forgot try
01:22:01 <Aetherspawn> if you structure your parser like the example ones, it's not that hard to see where try should be
01:22:21 <bartavelle> it entirely depends on what you are parsing
01:22:38 <bartavelle> in my case it is a poorly define language, and I sometimes find very surprising syntax in the wild
01:24:22 <bartavelle> but the "test till it breaks" approach is what I have been doing for a while, I just wondered if there were cases where a non eager parser would find ambiguous stuff
01:24:45 <Aetherspawn> is it an imperitive language?
01:24:56 <Aetherspawn> Im sure I spelt that wrong.
01:25:41 <bartavelle> it's the puppet language : http://docs.puppetlabs.com/puppet/latest/reference/lang_summary.html
01:25:44 <jfischoff> I have a real brain teaser http://hpaste.org/90395
01:25:47 <bartavelle> not really a programming language
01:26:12 <jfischoff> if I write `forkIO $ print`
01:26:20 <jfischoff> I can't catch an exception
01:26:39 <jfischoff> but with `forkIO . print` I do ‚Ä¶ wtf?
01:27:02 <jfischoff> inlining?
01:27:10 <quicksilver> no, precedence
01:27:18 <quicksilver> those are quite different expressions aren't they?
01:27:38 <Aetherspawn> bartavelle, I think you should be fine with parsec
01:27:49 <quicksilver> isn't the first one ( (void' . forkIO . print) <=< (void' . test) ) manager
01:27:55 <bartavelle> Aetherspawn, well, I already have it working, but I am not sure I am fine :)
01:28:01 <Aetherspawn> to put it in comparison, I wrote a parser for the GML language used in GameMaker :P
01:28:11 <quicksilver> and the second one (void' . forkIO) (print <=< void' . test) manager
01:28:11 <quicksilver> ?
01:28:19 <jfischoff> oh shit probably
01:28:32 <jfischoff> well that would make more sense
01:28:39 <Aetherspawn> not well written one of my first haskell programs ever; http://hpaste.org/90396
01:29:18 <jfischoff> so is there reasonable way to catch exceptions from other threads?
01:29:37 <Aetherspawn> but that langauge was pretty retarder. if (a = 3) and b then { x = 3 do_something(); ;; } else {} for example, is a valid program
01:30:04 <mjrosenb> Aetherspawn: most of it doesn't look that bad
01:30:13 <mjrosenb> x = 3 do_something seems questionable.
01:30:43 <Aetherspawn> It's not "bad", it's just loose and hard to predict where stuff starts and ends
01:31:03 <bartavelle> oh puppet is pretty retarded too, "include a include b" should be understood as "include(a) include(b)", but only because you must know that the include function only takes one argument. You can have user defined functions obviously :)
01:31:13 * mjrosenb has a mini-language that he should extend some more
01:31:28 <Aetherspawn> :S people need to put more effort into defining specs strictly
01:31:53 <Aetherspawn> so that writing parsers for them isn't so painful and it indirectly improves the performance of the compilers/readers written for them too
01:32:03 <mjrosenb> mine was plenty strict
01:32:06 <bartavelle> actually my previous sentence is wrong, include a,b,c does work, so it's about the commas
01:32:32 <bartavelle> why did you parse this gamemaker language ? writing an independent interpreter ?
01:33:06 <bartavelle> (I don't know how the parser should behave with functions that take no arguments)
01:33:10 <Aetherspawn> I was writing a project which uses the ENIGMA C++ libraries which are equivalents for GameMaker functions + runtime written in C++
01:33:23 <Aetherspawn> ie: convert a game maker project into C++ then feed it through g++ :P
01:33:38 <Aetherspawn> GM is interpreted so its performance is absolutely terrible.
01:34:31 <bartavelle> ahh
01:34:33 <Aetherspawn> I want to give it another shot when my haskell gets better and I read some books on parsing and compiler theory or something
01:35:38 <jfischoff> I find myself writing code where I want to catch all exceptions except Asynchronous exceptions.
01:36:10 <jfischoff> Is there a common function for catching every thing except explicit kill messages?
01:36:21 <bartavelle> I also took a glance at http://hackage.haskell.org/package/trifecta-1.1, but couldn't figure the underlying rationale (not sure what the Caret, Span, etc. are for)
01:36:42 <Aetherspawn> colored errors! cool
01:38:00 <mjrosenb> oh man, trifecta
01:38:10 <mjrosenb> I really wanted to look at that before my add kicked in
01:38:14 <mjrosenb> like 9 months ago.
01:38:34 * hpaste bops
01:42:10 <dmwit> * hpaste bops?
01:42:24 <elliott> * hpaste bops, dmwit.
01:42:30 * Ralith wops
01:42:30 <elliott> do not question it.
01:42:39 * Aetherspawn flops
01:42:58 <t7> mmm bop
01:43:19 <mjrosenb> twist it.
01:43:46 <Aetherspawn> is there a very fast bytestring parser
01:47:51 <bartavelle> Aetherspawn, attoparsec is supposed to be a fast combinator parser
01:47:53 <dmwit> Aetherspawn: binary, attoparsec
01:48:09 * dmwit high-fives bartavelle
01:48:13 <bartavelle> but you sacrifice the position bookkeeping
01:48:17 <bartavelle> :)
01:48:56 <bartavelle> and even though it claims you can achieve speeds twice as slow as a hand rolled C parser, I have never been able to achieve this
01:49:30 <dmwit> I like this wording, it sounds funny. =)
01:49:44 <c_wraith> it means the C parser must have a particular slowness value
01:49:59 <bartavelle> heh :)
01:49:59 <c_wraith> and the attoparsec parser has double that slowness
01:51:14 <Aetherspawn> lol
01:51:50 <Aetherspawn> has anyone written a parser /as fast/ as a C parser?
01:52:00 <Aetherspawn> *language parser
01:52:03 <Aetherspawn> in haskell.
01:52:40 <Taneb> Possibly something with Happy or Alex?
02:06:11 <klrr> "pong = send h "PONG" . ':' : drop 6" Couldn't match expected type `a0 -> String' with actual type `Char' In the second argument of `(.)', namely ':' In the first argument of `(:)', namely send h "PONG" . ':' In the expression: send h "PONG" . ':' : drop 6
02:06:15 <klrr> Failed, modules loaded: none.
02:06:18 <klrr> any ideas what's wrong? :x
02:06:51 <quicksilver> what do you expect that to do?
02:06:56 <quicksilver> ':' is a character
02:07:03 <quicksilver> . is function composition
02:07:13 <quicksilver> how were you going to compose a character as a function?
02:09:41 <klrr> quicksilver: i want pong to return a function that takes a string, applies drop 6 to it, then cons ':' to it and then pass the result to the send function
02:11:41 <klrr> quicksilver: rewrote it to this : "pong = send h "PONG" . (:) ':' . drop 6"
02:12:15 <Lethalman> how can you use . with a string?
02:12:35 <quicksilver> klrr: yes, so the function "cons : to it" is ((:) ':')
02:12:35 <Lethalman> ah it's due to send maybe
02:12:40 <quicksilver> klrr: not just ':'
02:12:43 <quicksilver> that's the key observation.
02:12:54 <quicksilver> or you might write it (':' :)
02:13:15 <klrr> the problem must be with precedence of functions
02:13:40 <quicksilver> partly it was, yes
02:13:57 <quicksilver> but what you wrote didn't make sense even with the precedence you expected
02:14:03 <quicksilver> ':' : drop 6
02:14:12 <quicksilver> does not cons the colon onto the result of drop 6
02:14:25 <quicksilver> it conses the colon onto 'drop 6' itself
02:14:35 <quicksilver> (Which is a function, which would therefore be a type error)
02:17:59 <m_hyperbolic> Hello people. Can anybody see a way to speed this up? (http://hpaste.org/90401) That is, do I use a slow function where a more speedy one could be used ? (I know there exist more effiencent methods then this, but want to know if I can speed this one up)
02:19:57 <quicksilver> m_hyperbolic: building up lists in reverse is slow
02:20:03 <quicksilver> no idea if that's your bottleneck
02:21:47 <adnap> In instance Functor Stream where fmap f ~(Cons x xs) = Cons (f x) (fmap f xs)
02:21:55 <adnap> What is "~"?
02:22:36 <supki> lazy pattern
02:22:48 <alpounet> adnap, http://www.haskell.org/haskellwiki/Lazy_pattern_match
02:22:54 <adnap> Reading now
02:23:04 <adnap> supki: Thank you
02:23:10 <amalloy> what does -XFunctionalDependencies mean? i'm trying to understand http://stackoverflow.com/questions/731832/interview-question-ffn-n#comment21866337_732049 - the definitions make sense for me, except for the "| a->b" bit, which seems to require -XFunctionalDependencies in order to compile
02:23:55 <shachaf> amalloy: http://www.haskell.org/haskellwiki/Functional_dependencies
02:24:15 <shachaf> adnap: Hoogle can tell you about things like that, by the way.
02:27:46 <mbuf> is there a way to write unit tests, or tests using QuickCheck for IO ()?
02:28:30 <Lethalman> @hoogle quickcheck monadic
02:28:30 <lambdabot> No results found
02:28:50 <Lethalman> mbuf, a search should give you something for sure
02:29:26 <mbuf> Lethalman: was just wanting to know what people here use or recommend
02:29:33 <mbuf> Lethalman: thanks
02:30:08 <supki> I like the way .Monadic is documented
02:30:10 <supki> sort of
02:30:49 <supki> although I can't say the paper is not interesting
02:34:01 <adnap> Can you use lazy pattern matching on any data constructor?
02:34:28 <adnap> I read the Haskell Wiki page, and it focuses entirely on lazily pattern matching tuples
02:34:37 <shachaf> No, there are some exceptions.
02:34:46 <shachaf> But for the most part yes. Certainly it has nothing to do with tuples.
02:34:56 <klrr> adnap: i remember your name
02:35:03 <adnap> I'm not sure when I would use lazy pattern matching
02:35:39 <adnap> In the example on the wiki page, it was essential for getting immediate results from splitAt
02:36:09 <adnap> The version with strict pattern matching has to generate the entire expression before it computes any values
02:37:06 <Shapeshifter> Hi. I would like to install timepiece via cabal but I get an error "fatal error: SDL.h: No such file or directory" while "Preprocessing executable 'TimePiece' for TimePiece-0.0.3. sdl is installed on this Archlinux x86_64 machine and SDL.h is present in /usr/include/SDL/SDL.h. What could be the problem?
02:37:56 <amalloy> thanks, shachaf, i see now. and now i also see why i can't extend that SO comment to work for any Num a: someone might later define a Num instance for (()->a), in which case it would be undecidable which instance of C to use
02:39:15 <shachaf> I didn't read the SO comment but that sounds about right. :-)
02:44:06 <tomejaguar> adnap: if your function *can* start yielding results before matching a certain pattern then you're best implementing it that way.
02:44:43 <tomejaguar> Actually that's too general, sometimes you want to force in order to free memory, but I think that's probably best done explicitly.
02:45:36 <Aetherspawn> "glitch" in laziness confirmed here, maybe someone knows if theres a ticket about it? http://stackoverflow.com/questions/17292048/haskell-segfault-reading-lazy-bytestring-past-218-bytes
02:46:11 <Shapeshifter> this is annoying. Whatever SDL packages I try to install using cabal, they all fail at some point or another. I've seen "can't find SDL.h", "Ambigous module name `Prelude`", "Not in scope: `parArr`"... It seems like many, many packages are simply broken one way or another. I'm not sure why so many people keep praising the Haskell ecosystem. Sure, hoogle is very nice, but cabal is pretty terrible and there seems to be a lot of ...
02:46:17 <Shapeshifter> ... version fragmentation going on.
02:47:18 <Ralith> maybe they have had different experiences than you
02:47:38 <tomejaguar> Shapeshifter: is it only with packages which depend on SDL?
02:47:43 <m3ga> Shapeshifter: any SDL haskell package needs the underlying C SDL library. what OS are you on?
02:47:56 <typoclass> Shapeshifter: hmm ... 'cannot find SDL.h' sounds like the c part of the library is not installed. this needs to be done via your system's package manager, then cabal can install the haskell part
02:48:19 <Shapeshifter> m3ga: archlinux x86_64. sdl is installed. SDL.h exists at /usr/include/SDL/SDL.h
02:48:21 <adnap> I'm reading "For instance, the meaning of (i.e., the domain corresponding to) the Haskell type (Bool,Integer) contains five different kinds of values, as shown in the figure." in http://conal.net/blog/posts/merging-partial-values and I don't see a figure.
02:48:53 <adnap> Will someone check this page out so I can tell if there is a problem with my web browser?
02:49:18 <typoclass> Shapeshifter: and yes, i can understand your frustration :-/ if it helps, the cabal situation is being worked on and they're close to releasing an update that is expected to clear up a lot of problems
02:49:35 <m3ga> Shapeshifter: what haskell package are you trying to install?
02:50:14 <typoclass> Shapeshifter: could you paste the complete error message around 'cannot find SDL.h'? ideally with -v3 to make it verbose. please use hpaste.org
02:50:21 <Shapeshifter> m3ga: I tried installing timepiece, which gives me "fatal error: SDL.h: No such file or directory". Installing "breakout" fails while installing haskgame with "Ambiguous module name `Prelude': it was found in multiple packages: base haskell98-2.0.0.2". Trying to install brians-brain I get "BriansBrain.hs:24:35: Not in scope: `parArr'".
02:51:31 <tomejaguar> adnap: I don't see a figure either.
02:51:31 <m3ga> Shapeshifter: on debian i had to install libsdl-1.3-dev. you need a program called sdl-config.
02:51:40 <shachaf> Aetherspawn: When you say "confirmed" do you mean that anyone else reproduced it, or what?
02:51:46 <klrr> anyone got an idea how to solve this type error? https://gist.github.com/klrr/5857298
02:51:49 <Shapeshifter> typoclass: full log at http://login.icu.uzh.ch/~archer/hs.log (it's rather large for a pastebin)
02:52:13 <Shapeshifter> m3ga: sdl-config is installed (as part of the archlinux sdl package)
02:52:14 <Aetherspawn> shachaf, the glitch goes away when it is strict
02:52:17 <adnap> tomejaguar: Do you have any knowledge of the topic in this post (about "bottom")? Could you perhaps describe the missing figure?
02:52:32 <Aetherspawn> I don't suppose this is defined behaviour for memory mapped files into bytestrings to segfault when lazy
02:52:45 <Zouppen> adnap: I can't see any figure either. the server seems very slow, too.
02:52:58 <shachaf> It sounds more likely to be an mmap bug than a GHC bug.
02:53:05 <Aetherspawn> shachaf, see the discussion in the comments of the question for more context.
02:53:08 <shachaf> I mean the library "mmap".
02:53:25 <Aetherspawn> It probably is
02:53:32 <Aetherspawn> a mmap bug, that is.
02:53:40 <supki> klrr: import Data.Text.Lazy instead of Data.Text
02:54:24 <supki> klrr: also Data.Text.Lazy.IO has a version of readFile that reads file as Text directly without roundtrips through String
02:54:29 <shachaf> OK, then track it down, I suppose.
02:54:36 <Aetherspawn> Should I email the maintainer for advice, or are they in this channel? please advise.
02:55:04 <typoclass> Shapeshifter: hm ... package timepiece is fairly old (last updated in 2008, breakout in 2009). that doesn't automatically mean it won't work, but it's surely a bad sign
02:55:20 <xunie-laptop> Am I being a 'help vampire' if I ask for a function I need in here? (I don't want to be a dishonorable p'taQ)
02:55:25 <Aetherspawn> (Gracjan Polak, if that sounds familiar)
02:55:41 <RichyB> xunie-laptop: you'll prolly be fine. :)
02:55:52 <elliott> xunie-laptop: if you're asking whether a certain behaviour is help vampirism, there's a good chance you're aware enough to avoid such behaviours in the first place :)
02:55:53 <Shapeshifter> typoclass: basically, I simply wanted to try out a few packages that use SDL to see how they handle and then look at the source to determine if I could maybe try my hands on some haskell/sdl coding...
02:55:58 <shachaf> Aetherspawn: In your position I would probably try to track it down myself.
02:56:26 <Shapeshifter> typoclass: I picked a few from this list and for now I haven't found one that worked http://www.haskell.org/haskellwiki/SDL#Applications_using_SDL
02:56:27 <xunie-laptop> I need a function that takes a function f and iterates that function over list x and returns a list with every result...
02:56:37 <shachaf> However, most likely no one in the channel can help you track it down, since no one has a file to test it with, and most people aren't using Windows.
02:56:43 <elliott> xunie-laptop: as simple as map?
02:56:47 <elliott> > map f [a,b,c,d]
02:56:48 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
02:56:48 <lambdabot>    arising from a us...
02:56:51 <elliott> uh.
02:56:56 <elliott> > map f [a,b,c,d]                   :: [Expr]
02:56:57 <lambdabot>   [f a,f b,f c,f d]
02:57:00 <elliott> :t map
02:57:01 <lambdabot> (a -> b) -> [a] -> [b]
02:57:06 <xunie-laptop> Yes! :3
02:57:23 <elliott> :)
02:57:32 <adnap> @hoogle amb
02:57:32 <lambdabot> Graphics.Rendering.OpenGL.GL.Colors Ambient :: ColorMaterialParameter
02:57:32 <lambdabot> Graphics.Rendering.OpenGL.GL.Colors ambient :: Light -> StateVar (Color4 GLfloat)
02:57:32 <lambdabot> Graphics.Rendering.OpenGL.GL.Colors AmbientAndDiffuse :: ColorMaterialParameter
02:57:36 <Aetherspawn> I'll test it on Linux.
02:57:36 <shachaf> You could start by simplifying your Haskell code as much as you can. Probably most of it is extraneous.
02:57:54 <Aetherspawn> if it's a problem on Linux I'll make a simplified error case
02:57:57 <xunie-laptop> God, is Haskell powerful...
02:58:15 <Shapeshifter> typoclass: well I found that HTicTacToe works. Not exactly exciting but it'll do ;-)
02:59:38 <typoclass> Shapeshifter: in summary, there's a number of packages on hackage that once worked, then were abandoned and not updated anymore for years. (while the compiler and dependencies kept progressing and changing.) so yes, your initial assessment was correct on that point. that can be confusing
02:59:43 <klrr> supki: thanks!
02:59:57 <adnap> @hoogle por
02:59:58 <lambdabot> Network.HTTP.Base port :: URIAuthority -> Maybe Int
02:59:58 <lambdabot> package portable-lines
02:59:58 <lambdabot> package portaudio
03:00:15 <Shapeshifter> typoclass: indeed. It's a pity, but I can surely understand the problem. Who's supposed to maintain all those packages over time with such a small community...
03:00:19 <adnap> > True `por` undefined
03:00:20 <lambdabot>   Not in scope: `por'
03:00:20 <lambdabot>  Perhaps you meant one of these:
03:00:20 <lambdabot>    `or' (imported from...
03:00:21 <typoclass> Shapeshifter: i recommend when you install something, look for the date of last upload http://hackage.haskell.org/package/TimePiece and also, the page often lists "built on: ghc 6.8, build failure: ghc 6.10" etc.
03:00:47 <adnap> @hoogle unamb
03:00:47 <lambdabot> package unamb
03:00:47 <lambdabot> package unamb-custom
03:01:09 <Shapeshifter> typoclass: I see, the build failure warning is useful. Thanks.
03:01:16 <adnap> > True `unamb` undefined
03:01:17 <lambdabot>   Not in scope: `unamb'
03:03:01 <tomejaguar> adnap: the five possible kinds of values are _|_, (_|_, _|_), (Bool, _|_), (_|_, Integer), (Bool, Integer) [with the fairly obvious partial order on them]
03:03:05 <tomejaguar> adnap: Does that make sense to you?
03:03:23 <adnap> tomejaguar: Yes
03:03:40 <adnap> ‚ä•
03:03:46 <adnap> How do I make this symbol?
03:04:04 <Shapeshifter> It's also a pity that Haskell stuff integrates rather badly with distro packaging. Not sure why, but most distros recommend using only the haskell package or not even that, simply using the haskell distribution and cabal.
03:04:27 <tomejaguar> adnap: What do you mean make it?
03:04:32 <adnap> tomejaguar: Type it
03:04:52 <tomejaguar> adnap: Well, I use _|_ in ascii
03:05:01 <Shapeshifter> Maybe it's because apparently, an unusually large portion of Haskell coders use mac and windows... or so it seems.
03:05:16 <typoclass> adnap: if you're on something unixish, the compose key is a pretty good thing to have. here's some information http://mainisusuallyafunction.blogspot.de/2010/10/typing-mathematical-characters-in-x.html
03:06:57 <typoclass> @where+ compose http://mainisusuallyafunction.blogspot.de/2010/10/typing-mathematical-characters-in-x.html
03:06:57 <lambdabot> Okay.
03:09:47 <Breadmonster> Can someone please show me how to use the when construct?
03:09:51 <Breadmonster> In the IO monad?
03:10:04 <elliott> when condition $ do ...
03:10:26 <mauke> when condition body
03:10:29 <typoclass> Breadmonster: "when (x == 3) (print 123)"
03:10:46 <mjrosenb> mmm, ƒç√∂m·πï≈ç√ü…ô
03:10:55 <Breadmonster> Isn't it defined with four parameters?
03:11:01 <Breadmonster> Sorry three?
03:11:11 <elliott> :t when
03:11:12 <lambdabot> Monad m => Bool -> m () -> m ()
03:11:26 <Breadmonster> elliott: Where is it defined?
03:11:46 <merijn> Breadmonster: "when b act = if b then act else return ()"
03:11:48 <typoclass> Breadmonster: with IO, the signature will be when :: Bool -> IO () -> IO ()
03:11:59 <shachaf> Aetherspawn: #ghc is really only for GHC development, not for user questions.
03:11:59 <typoclass> Breadmonster: Control.Monad, if i remember correctly
03:12:21 <adnap> :t race
03:12:22 <lambdabot> Not in scope: `race'
03:12:26 <adnap> :t evaluate
03:12:28 <lambdabot> a -> IO a
03:12:34 <elliott> @hoogle when
03:12:34 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
03:12:35 <lambdabot> System.Posix.Terminal WhenDrained :: TerminalState
03:12:35 <lambdabot> System.Posix.Terminal.ByteString WhenDrained :: TerminalState
03:13:26 <merijn> adnap: I believe race is from the async package (btw, reading Conal's unamb stuff, by any chance? :p)
03:14:02 <typoclass> Breadmonster: and yeah, this ^^ is the way to find out that kind of thing :-) use the hoogle website, the hoogle command line tool, or lambdabot's @hoogle command. also see hayoo, it covers a little more than hoogle
03:14:05 <typoclass> @where hayoo
03:14:05 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
03:14:37 <Breadmonster> typoclass, what's hoogle?
03:14:41 <adnap> merijn: Yes
03:14:44 <xunie-laptop> Honestly, shouldn't  drop (-3) [1, 2, 3]  yield something like an error?
03:15:17 <typoclass> Breadmonster: a search engine that finds haskell functions and modules and stuff. you can search by name or by type signature
03:15:25 <Breadmonster> Hmm, that's awesome.
03:15:26 <typoclass> @hoogle String -> Int
03:15:26 <merijn> @where hoogle
03:15:26 <lambdabot> Test.HUnit.Base Label :: String -> Node
03:15:26 <lambdabot> Prelude error :: [Char] -> a
03:15:26 <lambdabot> Prelude length :: [a] -> Int
03:15:26 <lambdabot> http://haskell.org/hoogle
03:15:57 <typoclass> ('length' is what i wanted)
03:16:37 <mjrosenb> typoclass: sure you didn't want error? it'll typecheck as well :-p
03:17:02 <alpounet> xunie-laptop, no, that's what head does and that causes quite a few mysterious bugs because you don't have much details with such an error
03:17:04 <typoclass> mjrosenb: heh, sure =)
03:17:26 * typoclass . o O ( wondering a little why it found Label :: String -> Node )
03:17:33 <alpounet> xunie-laptop, with head on an empty list, you get: *** Exception: Prelude.head: empty list
03:17:47 <elliott> xunie-laptop: I think so.
03:18:02 <elliott> silent breakage is worse than an error.
03:18:12 <elliott> however, drop 100 [1, 2, 3] should be []. that's well-defined.
03:18:28 <elliott> but really drop takes a natural number. so it accepting negative numbers silently is bad, IMO.
03:18:55 <typoclass> > drop (-3) [1..10]
03:18:55 <adnap> :t seq
03:18:56 <lambdabot> a -> b -> b
03:18:56 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
03:18:59 <elliott> maybe there is some argument for it in terms of writing drop (m - n) with reasonable semantics even if n > m...
03:19:02 <adnap> seq 3 4
03:19:06 <adnap> > seq 3 4
03:19:07 <lambdabot>   4
03:19:09 <mjrosenb> elliott: I like how drop 1 [] is fine, but last [] isn't
03:19:12 <adnap> > seq undefined 4
03:19:13 <lambdabot>   *Exception: Prelude.undefined
03:19:15 <Breadmonster> So I'm implementing an interpreter in Haskell.
03:19:18 <mjrosenb> err
03:19:25 <mjrosenb> no, I did not mean to type in last
03:19:28 <mjrosenb> that is something else.
03:19:35 <Breadmonster> How do I implement something like python's print?
03:19:38 <elliott> I assume you mean tail -- I think that's the right thing for it to do
03:19:39 <mjrosenb> tail
03:19:43 <mjrosenb> that is what I meant.
03:20:05 <elliott> drop n = map snd . dropWhile ((< n) . fst) . zip [0..] :)
03:20:29 <elliott> @check \n (xs::[Bool]) -> drop n xs == map snd . dropWhile ((< n) . fst) . zip [0..] $ xs
03:20:30 <lambdabot>  <unknown>.hs: 1: 17:ScopedTypeVariables is not enabled
03:20:37 <elliott> @check \n xs -> drop n (xs::[Bool]) == map snd . dropWhile ((< n) . fst) . zip [0..] $ xs
03:20:40 <lambdabot>   Couldn't match expected type `[GHC.Types.Bool]'
03:20:40 <lambdabot>              with actual ty...
03:20:46 <elliott> hmph.
03:21:14 <mjrosenb> elliott: please tell me that isn't how it is implemented.
03:21:17 <mjrosenb> @src drop
03:21:18 <lambdabot> drop n xs     | n <= 0 =  xs
03:21:18 <lambdabot> drop _ []              =  []
03:21:18 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
03:21:20 <mjrosenb> good
03:21:30 <shachaf> mjrosenb: What @src says is probably not how it's implemented either.
03:21:50 <shachaf> But that's some sort of justification for its behavior. I don't know whether it's a good one.
03:22:15 <shachaf> It would be nice if GHC inlined "drop 1 xs" into something nonrecursive.
03:22:17 <elliott> mjrosenb: I speak of denotation, not opertaion
03:22:26 <elliott> *operation
03:22:27 <shachaf> GHC doesn't even optimize "reverse []" into "[]"!
03:22:29 <shachaf> Did you know that?
03:22:43 <elliott> hm, my definition defends drop (-123) working.
03:22:44 <typoclass> elliott: so, given a negative number, drop should throw an exception?
03:22:49 <elliott> so I guess I believe it's okay after all.
03:22:58 <elliott> typoclass: well, ideally, drop :: Nat -> [a] -> [a].
03:23:12 <shachaf> drop :: [z] -> [a] -> [a]
03:23:15 <mjrosenb> elliott: victory! (I think?)
03:23:16 <typoclass> elliott: right
03:23:27 <elliott> failing that, well... let's do what dropWhile does :P
03:23:31 <t7> (drop (-1)) should use pattern matting to guess the next element
03:23:38 <elliott> > take (-123) [1,2,3]
03:23:39 <lambdabot>   []
03:23:47 <elliott> ok. I have a mental model for this now.
03:23:48 <shachaf> > splitAt (-123) [1,2,3]
03:23:49 <typoclass> safeDrop :: PositiveNumber -> [a] -> [a] , drop :: NonNegativeNumber -> [a] -> [a]   =)
03:23:49 <lambdabot>   ([],[1,2,3])
03:24:04 <elliott> you can do splitAt in terms of zip + span or something right?
03:24:16 <elliott> > span (== 2) . zip [0..] $ [1,2,3,4]
03:24:17 <lambdabot>   No instance for (GHC.Show.Show b0)
03:24:17 <lambdabot>    arising from a use of `M84596177.show...
03:24:23 <elliott> what
03:26:52 <elliott> oh
03:27:09 <elliott> > (map snd *** map snd) . span ((== 2) . fst) . zip [0..] $ [1,2,3,4]
03:27:10 <lambdabot>   ([],[1,2,3,4])
03:27:17 <elliott> > (map snd *** map snd) . break ((== 2) . fst) . zip [0..] $ [1,2,3,4]
03:27:18 <lambdabot>   ([1,2],[3,4])
03:27:25 <elliott> > splitAt 2 [1,2,3,4]
03:27:27 <lambdabot>   ([1,2],[3,4])
03:27:30 <elliott> > (map snd *** map snd) . break ((== (-123)) . fst) . zip [0..] $ [1,2,3,4]
03:27:32 <lambdabot>   ([1,2,3,4],[])
03:27:35 <elliott> shachaf: splitAt is wrong!
03:28:32 <shachaf> elliott: Your mental model is wrong.
03:29:08 <elliott> > (map snd *** map snd) . break ((< (-123)) . fst) . zip [0..] $ [1,2,3,4]
03:29:09 <lambdabot>   ([1,2,3,4],[])
03:29:17 <elliott> > (map snd *** map snd) . break ((< 2) . fst) . zip [0..] $ [1,2,3,4]
03:29:18 <lambdabot>   ([],[1,2,3,4])
03:29:24 <elliott> > (map snd *** map snd) . span ((< 2) . fst) . zip [0..] $ [1,2,3,4]
03:29:27 <lambdabot>   ([1,2],[3,4])
03:29:30 <elliott> hm.
03:30:16 <typoclass> elliott: i lost track of what the question is
03:31:09 <elliott> I was trying to come up with a nice definition of splitAt in terms of break or span and zips with indices.
03:31:43 <elliott> my conjecture is that every function which deals with list indices should be equivalent to one that zips [0..] on at the start, uses a "generalised" function that works on functions over elements ratherthan indices, and then erases the indices
03:32:04 <elliott> and then these definitions will define the correct way to handle things like negative inputs.
03:32:37 <typoclass> elliott: right! interesting
03:35:49 <typoclass> elliott: presumably a negative index should be treated the same way a positive, too big index is treated? "omg dis index not in teh fst of teh tuple"
03:36:27 <elliott> well, consider when you're using < or such.
03:36:41 <elliott> -123 < 0, so take (-123) xs = [] for all xs
03:37:04 <elliott> but n > -123, so drop (-123) xs = xs for all xs. or something.
03:37:39 <typoclass> > drop (-123) [1..10] -- seems good so far
03:37:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
03:38:18 <elliott> right. drop satisfies my implementation, I think.
03:38:22 <Walther> > [-10..10]
03:38:23 <lambdabot>   [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10]
03:38:29 <Walther> neat, works ._.
03:38:40 <elliott> @check \n xs -> drop n (xs::[Bool]) == map snd . dropWhile ((< n) . fst) . zip [0..] $ xs
03:38:40 <Twey> Surely a negative index should be disallowed by the type >.>
03:38:41 <lambdabot>   Couldn't match expected type `[GHC.Types.Bool]'
03:38:42 <lambdabot>              with actual ty...
03:38:46 <elliott> I don't understand this type error.
03:38:50 * Twey thinks Word is tragically underused
03:39:07 <shachaf> Word is not natural numbers.
03:39:16 <elliott> Twey: well, it occured to me that it makes sense to be able to do (drop (m - n) xs) when n may be > m.
03:39:19 <Twey> shachaf: And Int isn't integers
03:39:37 <elliott> > -1 :: Word
03:39:39 <lambdabot>   4294967295
03:39:40 <shachaf> Twey: Yes. But overflow on Word is trouble.
03:39:41 <elliott> not a good solution here.
03:39:43 <Twey> elliott: Hm, okay
03:39:44 <shachaf> Or underflow.
03:39:45 <Twey> Yes, true
03:40:09 <Twey> Do we have a proper Nat type now?  I thought I heard something about that
03:40:11 <typoclass> btw, is there something arbitrary-size like Integer, but non-negative like Word?
03:40:20 <elliott> the semantics of drop's argument going negative are "continuous"
03:40:21 <typoclass> (or is that Nat?)
03:40:27 <elliott> so it's not much of a special case after all
03:40:40 <shachaf> There is Nat but it is much less efficient.
03:40:42 <elliott> similarly for the argument exceeding the length of the list
03:40:44 <Twey> typoclass: That's Nat
03:40:50 <Twey> Modulo efficiency
03:42:06 <xunie-laptop> let f x y = show x ++ show y    map (f 5) [1, 2, 3, 4]    How should I go about map passing x=5 and y = mapped in f here?
03:42:58 <Twey> xunie-laptop: What's wrong with that?
03:43:04 <Twey> > let f x y = show x ++ show y in map (f 5) [1 .. 4]
03:43:05 <lambdabot>   ["51","52","53","54"]
03:43:08 <xunie-laptop> ^
03:43:19 <xunie-laptop> It should be ["15", "25", "35", "45"]...
03:43:23 <Twey> Ah
03:43:27 <Twey> > let f x y = show x ++ show y in map (flip f 5) [1 .. 4]
03:43:29 <lambdabot>   ["15","25","35","45"]
03:43:38 <elliott> > let f x y = show x ++ show y in map (\x -> f x 5) [1..4]
03:43:40 <lambdabot>   ["15","25","35","45"]
03:43:57 <Twey> ‚Äòflip‚Äô reverses the order of a function's first two arguments
03:44:02 <elliott> best acquaint yourself with the lambda syntax, if you haven't, before using flip
03:44:12 <elliott> it will come in handy :)
03:44:29 <Twey> It's always good to be able to use lambdas, too :√æ
03:44:31 <xunie-laptop> elliott, thanks for that answer. Will google Lambda syntax now.
03:44:55 <shachaf> Before using flip, I recommend deciding not to use flip.
03:45:06 <Twey> =(
03:45:08 <typoclass> xunie-laptop: elliott's suggestion is the basic one (an anonymous function, also called lambda, which looks like "\... -> ..."). twey's suggestion is for when you're bored of writing that kind of lambdas all the time
03:45:47 <xunie-laptop> typoclass, better take the hard route and learn lambda expressions before I develop bad habits.... Learning Haskell is FUN!
03:46:08 <Twey> ‚Äòflip‚Äô isn't a bad habit
03:46:13 <Twey> Maybe when taken to excess
03:46:22 <typoclass> xunie-laptop: yes, you need to know lambdas in any case :-) they're pretty basic
03:46:38 <RichyB> Twey: please don't write "flip flip" in code that I'll have to read later. ;)
03:46:57 <shachaf> Twey: Any use of flip is excess.
03:47:14 <xunie-laptop> inb4 'flip considered dangerous'
03:47:31 <RichyB> The joke is "harmful". :)
03:47:53 <shachaf> RichyB: Are people not allowed to make a joke unless it's "*the* joke"?
03:48:15 <shachaf> There's room enough in the world for more than one joke.
03:48:41 <Twey> shachaf: What's wrong with it here?
03:48:43 <xunie-laptop> shachaf, what about meta jokes?
03:49:15 <Twey> shachaf: I think a lambda is gross overkill in this situation; it's exactly what I'd use a flip for (or perhaps a backtick-section)
03:49:19 <quicksilver> > let f x y = show x ++ show y in map (`f` 5) [1 .. 4]
03:49:20 <lambdabot>   ["15","25","35","45"]
03:49:22 <shachaf> Twey: It makes the code hard to read.
03:49:27 <mauke> @tell elliott http://hpaste.org/90405 - and now in readable
03:49:27 <lambdabot> Consider it noted.
03:49:37 <shachaf> Twey: A backtick section is fine.
03:49:42 <quicksilver> I really can't see why anyone would consider the lambda either 'gross' or 'overkill'
03:49:44 * Twey scratches his head.
03:49:54 <banister`sleep> shachaf: what is flip
03:49:55 <quicksilver> lambda notation is a really lightweight and easy to read notation
03:50:12 <quicksilver> the downside is having to choose a name for the parameter
03:50:23 <quicksilver> but it's a very tightly delimited one.
03:50:42 <elliott> mauke: pfft, in overrated.
03:50:56 <Twey> shachaf: When talking about the flip of a function, I think using ‚Äòflip‚Äô is perfectly legitimate, and more readable than using the lambda because it tells you what it's doing without having to parse the content of the lambda
03:51:16 <xunie-laptop> > show [1 .. 4] -- testing
03:51:17 <lambdabot>   "[1,2,3,4]"
03:51:34 <shachaf> flip is overly clever for no benefit. It's a big mental burden when reading code, way bigger than a lambda.
03:51:39 <Twey> quicksilver: It stands out a lot, though, and it's syntactically weird (often requires an extra set of parens or a $).
03:51:43 <shachaf> Especially when you partially apply it straight away.
03:52:08 <quicksilver> flip is a mental burden neither 'bigger' nor 'smaller' than a lambda.
03:52:11 <Lethalman> :t flip flip
03:52:12 <lambdabot> b -> (a -> b -> c) -> a -> c
03:52:15 <quicksilver> they are both merely things you have to learn
03:52:20 <Lethalman> :t map . flip flip
03:52:20 <lambdabot> a -> [a1 -> a -> c] -> [a1 -> c]
03:52:22 <xunie-laptop> You people really hate parens, don't you?
03:52:25 <quicksilver> and once you're learnt them, they're immediately obvious.
03:52:25 <Lethalman> :t fmap . map . map . flip flip
03:52:26 <lambdabot> Functor f => a -> f [[a1 -> a -> c]] -> f [[a1 -> c]]
03:52:32 <Lethalman> :t fmap . map . map . flip flip . flip . map flip
03:52:32 <quicksilver> however, learning lambda is more useful than flip
03:52:33 <lambdabot>     Couldn't match type `[b1 -> a1 -> c1]' with `a0 -> b0 -> c0'
03:52:33 <lambdabot>     Expected type: [a1 -> b1 -> c1] -> a0 -> b0 -> c0
03:52:33 <lambdabot>       Actual type: [a1 -> b1 -> c1] -> [b1 -> a1 -> c1]
03:52:37 <Lethalman> noooo :P
03:52:44 <quicksilver> and the lambda syntax is more applicable to lots of other slightly different situations
03:52:58 <quicksilver> s/and/because, for example/
03:53:06 <Lethalman> xunie-laptop, I personally find parens making code readable, as long it's only one level of parens
03:53:14 <Lethalman> e.g. myfunc (foo) (bar)
03:53:34 <Lethalman> but when it starts being myfunc ((foo (bar (baz))) (....etc) it's not readable anymore
03:53:43 <Twey> shachaf: I strongly disagree.  ‚Äòflip f x‚Äô tells me immediately that I'm talking about the function f with its arguments flipped.  ‚Äò\y -> f y x‚Äô requires me to actually read the lambda.  It's not exactly rocket science, but it does take a little more thought than the flip.
03:54:06 <Aetherspawn> I love the lens flip ??
03:54:07 <quicksilver> neither more thought nor less fault.
03:54:12 <Aetherspawn> I think its easier to read than flip . whatever
03:54:21 <quicksilver> just something to learn and once you learn it you know it.
03:54:30 <quicksilver> IMO.
03:54:42 <Aetherspawn> :t (??)
03:54:43 <lambdabot> Not in scope: `??'
03:54:51 <Twey> quicksilver: That's true for the flip, but not quite for the lambda due to the arbitrary extra identifier
03:54:58 <Twey> It'll appear in many different forms
03:55:24 <Twey> And the fact that it's more generally applicable, so something similar-looking can actually be quite different.
03:55:41 * typoclass thinks, as one of his infamous half-baked pet ideas, that we should have a syntax extension that produced (\x y -> f x y 42) from (\f ‚ê£ ‚ê£ 42). or maybe from (\f _ _ 42)
03:55:52 <Aetherspawn> shachaf, the lazy mmap thing affects linux too
03:55:52 <Twey> typoclass: Clojure does that
03:55:57 <Aetherspawn> Just tested it
03:56:12 <Aetherspawn> So now I'll compose a small test case.
03:56:20 <shachaf> Aetherspawn: OK. Now simplify it and then track it down.
03:56:53 <Aetherspawn> OK :)
03:57:37 <quicksilver> typoclass: been discussed more than once
03:57:42 <typoclass> Twey: right, something with "#3" isn't it
03:58:34 <typoclass> quicksilver: yes! each time the discussion was me saying "guys guys, i have this great idea", and everyone else saying "urgh, dude, i dunno ..."
03:58:59 <Twey> typoclass: Yours would be #(f % % 42)
03:59:04 <quicksilver> typoclass: http://www.haskell.org/pipermail/haskell-cafe/2007-July/027848.html
03:59:08 <Twey> typoclass: You can use %n to refer to argument n
03:59:12 <quicksilver> typoclass: http://www.haskell.org/pipermail/haskell-cafe/2007-July/027896.html
03:59:22 <quicksilver> typoclass: (and other messages in that thread)
03:59:25 <Twey> (i.e. #(f %1 %2 42) is the same)
03:59:43 <typoclass> quicksilver: thanks for the links, hadn't known about that thread. i was thinking only about the discussions we had in #haskell
03:59:45 <Aetherspawn> unsafeInterleaveIO is so error prone
03:59:57 <quicksilver> unsafeInterleaveIO is an error.
04:00:24 <Aetherspawn> *unsafePerformIO
04:01:24 <mauke> are you reinventing perl now?
04:01:35 <mauke> sub { f $_[0], $_[1], 42 }
04:02:00 <typoclass> Twey: right, that's what i was dimly remembering. thanks
04:03:34 <xunie-laptop> Wait wait, reinventing Perl in Haskell? 'Yo dawg, I herd you like programming' </offtopic>
04:06:36 * nicoo herds xunie towards #haskell-blah 
04:07:30 <elliott> @tell merijin bug: "deriving instance Foo Bar\n" gives an indent, shouldn't
04:07:30 <lambdabot> Consider it noted.
04:07:40 <elliott> @tell merijn bug: I sent a message to merijin instead of merijn
04:07:40 <lambdabot> Consider it noted.
04:08:30 <quicksilver> I'm not sure merijn is in a position to fix bugs in you, elliott.
04:09:29 <zett_zelett> I use debian/testing and have installed alex3.05 using cabal, which gave me `Installing executable(s) in /home/myname/.cabal/bin'.
04:10:03 <zett_zelett> Now, cabal still complains about alex3.01 in /usr/bin, can I tell cabal to look in /home/myname/.cabal/bin as well?
04:10:15 <elliott> @tell merijn ...also, "foo = bar baz quux where\n" should give indent, doesn't :)
04:10:15 <lambdabot> Consider it noted.
04:10:18 <mauke> zett_zelett: echo $PATH
04:10:27 <zett_zelett> Ah, of course, thanks.
04:10:28 <elliott> quicksilver: clearly it is a lambdabot bug. should autocorrect nicks
04:10:30 <typoclass> @tell merijn original message from elliott -- bug: "deriving instance Foo Bar\n" gives an indent, shouldn't
04:10:30 <lambdabot> Consider it noted.
04:10:58 <elliott> oh no! now merijn won't clear merijin's messages and in thirty years some poor innocent person called merijin will join #haskell and be baffled.
04:11:02 <yitz> elliott: i hate "helpful" software that autocorrects things i intentionally type
04:11:23 <elliott> also, the storage cost of the additional bytes it takes to store that message indefinitely will bankrupt me.
04:11:33 <elliott> truly, an apocalyptic scenario
04:12:12 <mauke> preflex: tell elliott now you have two bots
04:12:13 <preflex>  Consider it noted.
04:12:25 <merijin> @bots
04:12:25 <lambdabot> :)
04:12:35 <typoclass> yitz: i think auto-correcting is a bit much, but what lambdabot plausibly could do is check the logs and say "Did you really mean merijin? No one with that nick was ever in #haskell"
04:13:13 <typoclass> ... and it could even print a message "@tell received. Recipient 'doodleman' was last seen in #haskell 6 years 8 months ago."
04:13:23 <merijin> elliott: that message appears to be gone already
04:13:24 <typoclass> that gives you another clue
04:13:39 <elliott> yitz: you've saved us all!
04:13:40 <preflex>  elliott: you have 1 new message. '/msg preflex messages' to read it.
04:13:45 <elliott> preflex: messages
04:13:46 <preflex>  mauke said 1 minute and 33 seconds ago: now you have two bots
04:13:48 <Aetherspawn> even with -fno-cse theres like a race condition in mmap or something
04:13:58 <Aetherspawn> -fno-cse causes it to succeed sometimes and fail sometimes
04:14:13 <zett_zelett> Hm, mauke. It still complains after I added the path in my ~/.zshrc.
04:14:14 <Aetherspawn> suspect is unsafePerformIO in mmap.
04:14:20 <zett_zelett> Do I need to add it somewhere else?
04:15:39 <elliott> @tell merijn "data Foo = Bar deriving (A, B, C)" shouldn't indent next line either :)
04:15:39 <lambdabot> Consider it noted.
04:15:46 <yitz> typoclass: those are great ideas. elliott?
04:16:02 <mauke> that would require lambdabot to keep logs
04:16:06 <mauke> and track state
04:16:19 <yitz> mauke: lambdabot could query preflex :)
04:16:31 <mauke> (preflex doesn't track state either)
04:16:40 * typoclass is an expert at coming up with bold new interesting ideas, as long as typoclass is not the one who has to implement them
04:17:02 <xunie-laptop> Is there a function out there that concatenates a list of Strings?
04:17:03 <typoclass> and yes, it would require lambdabot to track a list of nicknames and timestamps
04:17:10 <alpounet> zett_zelett, ~/.cabal/bin must be before /usr/bin in PATH
04:17:14 <mauke> xunie-laptop: yes
04:17:37 <mauke> zett_zelett: echo $PATH
04:17:48 <typoclass> xunie-laptop: yes, it's concat from Prelude
04:17:55 <typoclass> > concat ["lol", "cat"]
04:17:56 <lambdabot>   "lolcat"
04:18:38 <isomorphic> > unlines ["lol", "cat"]
04:18:39 <lambdabot>   "lol\ncat\n"
04:18:49 <zett_zelett> Yeah, I suspected that. echo $Path gives `/usr/local/bin:/usr/bin:/bin:/usr/games:/home/myname/scp:/usr/local/texlive/2011/bin/i386-linux:/home/myname/scp:/usr/local/texlive/2011/bin/i386-linux:/home/myname/.cabal/bin'
04:19:07 <mauke> > show ["lol", "cat"]
04:19:08 <lambdabot>   "[\"lol\",\"cat\"]"
04:19:08 <zett_zelett> How can I change that?
04:19:15 <yitz> > ["lol", "cat"] >>= id
04:19:16 <mauke> zett_zelett: edit your .zshrc
04:19:16 <lambdabot>   "lolcat"
04:19:25 <mauke> yitz: did you mean: join
04:19:44 * typoclass . o O ( ... "answers sorted in descending order of readability" )
04:19:49 <yitz> > join ["lol", "cat"]
04:19:50 <lambdabot>   "lolcat"
04:20:03 <yitz> mauke: i guess i did, didn't i?
04:21:17 <mauke> I don't know; did you guess?
04:23:50 <alpounet> zett_zelett, make /home/you/.cabal.bin the first in $PATH and you'll be fine
04:24:30 <yitz> > execWriter . mapM_ tell $ ["lol", "cat"]
04:24:33 <lambdabot>   "lolcat"
04:24:33 <zett_zelett> alpounet, mauke: This seems to require me editing my /etc/profile.
04:24:39 <mauke> zett_zelett: why?
04:25:09 <alpounet> no, just your shell config in your user dir
04:25:13 <shachaf> yitz: did you mean: mconcat
04:25:33 <zett_zelett> I only have three paths in my shell config.
04:25:46 <yitz> shachaf: no, that one's next. actually, we skipped it already according to typoclass's ordering
04:25:48 <typoclass> zett_zelett: it is possible to do "PATH=~/.cabal/bin:$PATH", i.e. you're setting PATH to [the addition], then a colon, then the previous old value of PATH
04:25:49 <zett_zelett> Even if I put the cabal path first, my shell seems to load other paths first.
04:26:05 <zett_zelett> Ah!
04:26:10 <zett_zelett> Great, thanks.
04:26:14 <zett_zelett> I‚Äôll try that.
04:26:40 <yitz> now shachaf steps in with mystical lens incantations...
04:26:46 <zett_zelett> I‚Äôm pretty new to shell/zsh syntax as well.
04:26:46 <isomorphic> yitz:  How do the types work on ["lol", "cat"] >>= id  - id not being (a -> m b)
04:27:23 <shachaf> isomorphic: It doesn't work, with that premise.
04:27:25 <zett_zelett> Yes, it works. Thank you, typoclass, alpounet and mauke.
04:27:26 <mauke> isomorphic: but id is a -> m b
04:27:50 <klrr> anyone got an idea of a library i can write?
04:28:03 <mauke> isomorphic: id :: c -> c where c = a and c = m b
04:28:08 <typoclass> isomorphic: it uses the monad instance for lists. it's setting m to []
04:28:43 <isomorphic> mauke:   Why is that different from a = m b ?
04:28:58 <isomorphic> mauke:  or, I guess a ~ m b
04:29:07 <shachaf> isomorphic: Because it introduces a variable called c.
04:29:14 <shachaf> But it does mean that a = m b, yes.
04:29:59 <yitz> isomorphic: another way to look at it: for the list monad (>>=) = concatMap
04:30:27 <yitz> um maybe flip concatMap
04:30:27 <mauke> @src join
04:30:28 <lambdabot> join x =  x >>= id
04:30:30 <mauke> :t join
04:30:32 <lambdabot> Monad m => m (m a) -> m a
04:30:41 <mauke> it's all legit
04:30:53 <typoclass> isomorphic: maybe this makes sense:
04:30:54 <typoclass> :t (["lol"] >>=)
04:30:56 <lambdabot> ([Char] -> [b]) -> [b]
04:30:57 <typoclass> :t (["lol"] >>= id)
04:30:59 <lambdabot> [Char]
04:31:31 <mauke> > ["a", "bc"] >>= show
04:31:34 <lambdabot>   "\"a\"\"bc\""
04:32:39 <klrr> is there a list of good programs that medium programmers can write for practicing?
04:33:07 <typoclass> klrr: possibly the "99 problems"?
04:33:11 <typoclass> @google haskell 99 problems
04:33:12 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
04:33:13 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
04:33:13 <yitz> klrr: project euler is fun, but it is a very specific kind of programming
04:36:48 <klrr> okey, i mean maybe simething more "real" that can be applied to real projects later, maybe i should go thourgh realworld haskell
04:44:20 <typoclass> klrr: my very first haskell program (15 lines or so) was a command line tool that was like "where", but listed all the matches in the path, not just the first. (i later discovered that something equivalent already existed, but still, it taught me something)
04:45:02 <typoclass> klrr: so i guess, look for something that you yourself could use, and try to write that? doesn't matter if it's small
04:45:27 <supki> typoclass: I think "where" is exactly what you wrote
04:45:40 <supki> but you probably meant "which" then :)
04:45:50 <typoclass> supki: there's also which, and it has a switch that does what i wrote
04:46:21 <typoclass> supki: something like that :-) i'd have to look it up. anyway, it taught me about </> and getting an env variable and splitting on ':', etc.
04:46:46 <typoclass> oh, it also taught me about unfoldr :)
04:47:54 <typoclass> klrr: even the smallest project has teaching value. particularly if you put it on hpaste.org and ask #haskell for what folks would improve :)
04:49:12 <alpounet> maybe that kind of simple but kinda useful program ideas for beginners could be gathered somewhere
04:49:26 <typoclass> alpounet: yes absolutely!
04:49:46 <klrr> i cant figure out something i need though
04:49:49 * typoclass . o O ( apparently bash doesn't have 'where' at all. although zsh does )
04:49:54 <alpounet> it gets asked so often
04:50:20 <alpounet> klrr, gloss can be cool to play with, even for beginners. a simple 2D game could do the trick?
04:50:52 <alpounet> @where gloss -- klrr
04:50:52 <lambdabot> I know nothing about gloss.
04:50:53 <klrr> currently working on a irc logger, but it's for no need since everybodyt in the channel i will write the logger for use bouncers and got all messages anyway
04:50:55 <alpounet> meh.
04:50:59 <alpounet> @hackage gloss
04:50:59 <lambdabot> http://hackage.haskell.org/package/gloss
04:50:59 <klrr> alpounet: hmm, sounds interesting
04:51:04 <alpounet> klrr, visit that link
04:51:06 <nobb> how can i define a data type with type class restrictions?
04:51:13 <klrr> alpounet: will do
04:52:05 <supki> nobb: you don't because that will not save you from writing constraints in function signatures
04:52:24 <nobb> there is no way to do that?
04:52:52 <shachaf> There are ways but they're probably not a good idea.
04:52:55 <nobb> i want to avoid a huge list of constraint in front of every function
04:53:07 <elliott> you can use a gadt. but really it's not great practice.
04:53:19 <elliott> perhaps define a class that encapsulates all your constraints or such
04:53:26 <elliott> but usually not every definition will need all the constraints
04:53:52 <nobb> i want to get rid of my  type class approach
04:53:54 <adnap> :t (***)
04:53:54 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
04:54:11 <nobb> which combines two type classes
04:54:12 <klrr> alpounet: is gloss similar to https://love2d.org/ ?
04:54:18 <nobb> and uses functional dependencies
04:54:34 <typoclass> nobb: a poor man's solution could be to write no type signatures, then compile with ghc -Wall. it'll tell you the type signatures you left out, ready to copy-paste
04:55:03 <typoclass> > (pred *** succ) (42,37) -- adnap, this is how it works
04:55:04 <lambdabot>   (41,38)
04:55:18 <klrr> maybe i can write a love2d but for haskell? unless it's way too difficult
04:55:27 <typoclass> > (pred &&& succ) 42 -- adnap: here's a companion function from the same module
04:55:30 <lambdabot>   (41,43)
04:55:42 <klrr> https://www.love2d.org/wiki/love it is very simple and i could basically copy it :D
04:56:12 <nobb> hm, maybe it's not as bad as i thought
04:56:45 <nobb> that way the constraint are always visible for every function
04:56:59 <nobb> thanks everyone! :)
04:57:48 <elliott> :)
04:58:39 <alpounet> klrr, it's the same spirit: simple, for 2D games
04:58:40 <srhb> In "free" monads, it's free as in "gratis" - not liberty, right?
04:58:54 <typoclass> srhb: i think it has to do with beer
04:59:04 <srhb> Right, free as in beer. :-)
04:59:11 <klrr> alpounet: well, implementing a game dev framework is probably too difficult for me xD i will play around with gloss
04:59:17 <elliott> it's free as in functors.
04:59:31 <srhb> Now I'm confused. :(
04:59:38 <Adeon> they just want to be free
04:59:47 <klrr> what's free monads?
05:00:16 <typoclass> srhb: also, it has to do with speech. at least that's what i keep hearing "free as in free speech". not sure if it makes sense, because beer (especially free beer) tends to inffflunce speetchhhh
05:00:53 <srhb> Now it's even worse. :P
05:01:20 <shachaf> srhb: Wait until you hear about cofree comonads.
05:01:34 <srhb> shachaf: >:/
05:01:40 <ij> Is there a way to do two functions and disregard the first one's value?
05:01:50 <ij> in a lambda
05:01:56 <srhb> ij: Depends what you mean by "do"
05:02:17 <quicksilver> if they're functions, you should just ignore the first one
05:02:23 <ij> That what would be done in other languages by a semicolon.
05:02:25 <quicksilver> if you're ignoring its value, no point running it at all.
05:02:26 <srhb> ij: If you're disregarding the first value, it makes no sense to even "do" it.
05:02:32 <quicksilver> I suspect you don't actually mean functions though :)
05:02:38 <srhb> If we're talking effects, you can use a do block or >> for sequencing
05:02:42 <quicksilver> you probably want >> or do
05:02:57 <quicksilver> putStr "hello" >> return (f 5)
05:03:45 <typoclass> srhb: more srsly, i think "free theorems" are about "if you have the type signatures so-and-so, and it compiles, then you automatically have proven the theorem so-and-so". i guess free monads are something analogous, but i have no clue
05:04:19 <srhb> typoclass: Yes, that's why I thought "gratis" as in free (of cost) theorems.
05:04:45 <ij> http://sprunge.us/OUVe
05:04:46 <srhb> I need a math dictionary with translations, clearly. :-)
05:05:08 <klrr> the problem must be with precedence of functions
05:05:10 <typoclass> srhb: right. you don't need to do extra work proving something, because given this and that derivation process, you can mechanically derive the proof from the types
05:05:21 <ij> where a & b are of type maybe
05:05:32 <srhb> ij: Maybe what?
05:05:33 <shachaf> I don't think "free theorem" is "free" in the same sense as the usual sense.
05:05:43 <shachaf> (By "usual" I mean free monads, monoids, groups, etc.)
05:05:45 <srhb> ij: Also, putStrLn . show = print
05:06:01 <srhb> ij: And you're working in two different monads now, IO and Maybe.
05:06:05 <xunie-laptop> I can't map putStrLn ["hello", "world"], so how can I print a list of strings?
05:06:11 <srhb> xunie-laptop: mapM_
05:06:14 <xplat> 'free theorem' is more like 'free beer'
05:06:26 <typoclass> shachaf: yes, perfectly possible. i was telling srhb my best guess, since no one else seemed to be taking the question
05:06:39 <xplat> xunie-laptop: mapM_ putStrLn ["hello", "world"]
05:06:41 <typoclass> (my best guess does not amount to much at all)
05:06:53 <srhb> xunie-laptop: But actually, you CAN map putStrLn onto a list of strings. You just end up with a list of IO actions, that you can then sequence.
05:07:02 <srhb> xunie-laptop: (Which is exactly what mapM_ does)
05:07:22 <xunie-laptop> Oh nice! I get it now.
05:07:22 <xplat> srhb: well, sequence_
05:07:39 <srhb> xplat: How do you know I meant the function sequence and not the concept sequence? :-)
05:09:10 <xplat> srhb: the psychic friends network told me
05:09:55 <ij> srhb, Maybe Int(s). And can't I work with two monads?
05:09:56 <typoclass> ij: how about removing your ">>="? you could use e.g. (\x -> print x >> return x) (add a b)
05:10:06 <ij> ah
05:10:31 <ij> Hmm, I haven't fully understood >>= then.
05:11:00 <xplat> anyway, these things like x_ are just 'x and throw away the result'.  but it's only a naming convention so you can't apply it everywhere.
05:11:04 <tulcod> if i have "data Item = Item String deriving (Show)", where can I find the implementation of "show"?
05:11:07 <typoclass> @type (>>=)
05:11:07 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:12:07 <typoclass> ij: (>>=) works on all sorts of Monad, but it needs to be the same m. it would be different if signature was something like "m a -> (a -> n b) -> ...", but it isn't
05:12:08 <ij> typoclass, Yes, so why was the example with >>= incorrect?
05:12:22 <ij> Because I returned m a.
05:12:29 <typoclass> ij: in other words, you can't have the Maybe monad on the left side of (>>=), and the IO monad on the right side
05:13:05 <srhb> Not without a transformer, at least.
05:13:12 <ij> But the lambda returned Maybe, after doing IO stuff.
05:13:14 <srhb> (well, same difference.)
05:13:16 <ij> Didn't it?
05:13:17 <typoclass> srhb: right
05:13:50 <supki> tulcod: ghc -ddump-deriv will show derived implementations
05:14:15 <tulcod> supki: but where does ghc get it from? is it haskell code in Prelude, or is it C code?
05:14:33 <tulcod> i mean, in some way the name of the Item type needs to be converted into a String
05:15:07 <srhb> ij: Look at the body of the lambda. \x -> putStrLn "foo" >> return x -- type checks if and only if return X yields IO something
05:16:02 <srhb> :t (>>)
05:16:03 <lambdabot> Monad m => m a -> m b -> m b
05:16:10 <srhb> Same m om both sides, right?
05:16:28 <Breadmonster> :t (>>=)
05:16:31 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:16:35 <typoclass> ij: yeah well ... inside the lambda, putStrLn fixes m to be IO. so (>>)'s type is IO a -> IO b -> IO b here (also fixing the type of 'return x'). the entire lambda (right side of (>>=)) is IO b, and that clashes with the left side of (>>=)
05:16:40 <srhb> So if the lambda yields an IO something, then clearly the left-hand side must also yeld an IO something
05:16:43 <srhb> Because
05:16:44 <Breadmonster> @src Maybe.(>>=)
05:16:44 <lambdabot> Source not found. Are you typing with your feet?
05:16:48 <srhb> :t (>>=)
05:16:49 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:16:50 <Breadmonster> @src Maybe.>>=
05:16:50 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
05:16:55 <srhb> Same m on both sides.
05:17:03 <srhb> ij: Right?
05:17:07 <supki> tulcod: so really you want to know how to convert type names to strings? :)
05:17:14 <ij> srhb, yes
05:17:34 <srhb> Only the left-hand side is not an IO-something
05:17:37 <srhb> It's a Maybe something.
05:17:44 <srhb> Therefore you have a type error.
05:17:59 <tulcod> supki: well that's not possible in pure haskell, is it? so i want to see the real implementation of "show" for arbitrary data types
05:18:21 <tulcod> i mean - i can only imagine that that's just some C code
05:18:31 <xplat> right, >>= can be Maybe a -> (a -> Maybe b) -> Maybe b.  it can also be IO a -> (a -> IO b) -> IO b.  it can't be something like Maybe a -> (a -> IO b) -> IO b.  that's the difference between parametric polymorphism and subtyping -- parametric polymorphism can make constraints like that
05:18:33 <ij> >>= and >> are infix opers, correct?
05:18:39 <srhb> yes
05:18:59 <srhb> All symbolic operators are infix, unless surrounded by ()
05:19:06 <xplat> (well, it's not 'the' difference, but it's a difference)
05:19:08 <typoclass> tulcod: no, 'show' is a perfectly good haskell function. it's defined in typeclass Show, which has various instances
05:19:39 <tulcod> typoclass: so where is the instance for "data Item = Item String deriving(Show)", which I just wrote?
05:20:16 <ij> But here: (\x -> print x >> return x) (add a b) -- The print is of IO, return x is of Maybe Int.
05:20:27 <ij> Why does that type-check?
05:20:34 <srhb> No, it is not
05:20:40 <srhb> The return is of IO (Maybe Int)
05:20:50 <srhb> (The right hand side of >>, that is)
05:21:06 <srhb> Because you took a Maybe Int and you used return on it. And return :: a -> m a
05:21:24 <ij> Where does the return get it's m from?
05:21:30 <xplat> the Maybe in that case is part of the a, rather than appearing as the m
05:21:40 <srhb> The only possible value for m is IO, since otherwise both sides of >> does not have the same m
05:22:00 <ij> Is return a regular function? Or is it special in some way?
05:22:03 <typoclass> tulcod: before the 'deriving' thing was introduced, you had to write your own instance. it'd have looked like ¬´instance Show Item where show (Item str) = "Item " ++ show str¬ª. (or something like that. i hope i got that right)
05:22:03 <xplat> and the return gets its m because >> constrains both its sides to have the same m, and print x :: IO ()
05:22:04 <srhb> It's a regular function
05:22:20 <srhb> Consider return for Maybe, which is defined as return = Just
05:22:29 <tulcod> typoclass: that makes sense. so what happens nowadays?
05:22:48 <typoclass> tulcod: it's fairly repetitive and boring, so the compiler has the 'deriving' facility that can generate that code for you. but it's regular haskell code, just involving a typeclass instance. no c is involved
05:22:55 <xplat> return is a typeclass method (for Monad), there's nothing else special about it whatsoever
05:23:21 <typoclass> tulcod: you can display the code that ghc generated by passing a switch to ghc (see supki's commen above)
05:23:21 <tulcod> typoclass: so the "deriving" keyword is the magic bit, then?
05:23:53 <merijn> tulcod: Define "magic"
05:23:58 <tulcod>  i mean, you cannot get a String of the type name in pure haskell, can you?
05:24:08 <merijn> tulcod: Data.Typeable
05:24:13 <merijn> tulcod: (iow, yes you can)
05:24:13 <typoclass> tulcod: well the compiler obviously needs to understand it. but what it does is a fairly mechanical, boring thing
05:24:27 <tulcod> typoclass: i love the mechanical boring stuff.
05:24:31 <xplat> merijn: but that uses deriving to make the Typeable instances too ...
05:24:37 <merijn> xplat: Sure
05:25:07 <typoclass> tulcod: oh that's what you mean. yes you can't do that in plain haskell (except Data.Typeable). that's why it was solved at the compiler level with the 'deriving' keyword. it couldn't be solved simply at the library level
05:25:15 <supki> merijn: I don't think Typeable is "pure haskell"?
05:25:22 <merijn> supki: Why not?
05:25:31 <merijn> supki: Typeable is no different from Show
05:25:32 <supki> is it in the report?
05:25:44 <tulcod> typoclass: so what does the "deriving" keyword do exactly?
05:25:47 <merijn> supki: No, but you could implement it in pure haskell as a library
05:25:54 <quicksilver> no your couldn't merijn
05:25:59 <typoclass> tulcod: compile with the switch and see :-)
05:26:07 <tulcod> typoclass: well i know what it generates for Show
05:26:09 <quicksilver> not safely.
05:26:13 <merijn> tulcod: It just tells GHC "mechanically fill in the default representation of Show/Ord/Whatever"
05:26:16 <tulcod> but it must be more generic than that
05:26:26 <quicksilver> it's not very generic, tulcod
05:26:28 <merijn> quicksilver: Oh, sure, not safely. But assuming you made no errors it would work fine in a library
05:26:33 <typoclass> tulcod: it has a fixed list of typeclasses that it supports
05:26:33 <quicksilver> it's just a bunch of special cases
05:26:35 <xplat> the only extension needed for Typeable is one to allow Typeable to appear in 'deriving' clauses and get derived, but technically that's not 'necessary' either, just extremely useful
05:26:42 <tulcod> typoclass, quicksilver: okay, that's interesting :)
05:27:19 <merijn> quicksilver: I don't think "it's not very safe because you can make errors" equals "you can't do it in a library"
05:27:37 <merijn> It's not even particularly hard to do it in a library, afaict
05:27:44 <xplat> quicksilver: Typeable isn't implemented safely as it is
05:28:05 <quicksilver> xplat: well, that's true :)
05:28:09 <quicksilver> xplat: but I like to pretend it is.
05:28:31 <quicksilver> xplat: the derived one does at least give distinct types distinct IDs always.
05:28:52 <typoclass> as i understood it, the claim was "given a haskell compiler that doesn't support the 'deriving' keyword, you can't come up with a library that automatically does something like 'deriving Show'"
05:28:52 <merijn> supki: Typeable just ships a dictionary of functions with the value, so even though the type is erased at runtime, the dictionary (encoding said type) is still there
05:29:56 <quicksilver> and that claim is certainly true.
05:30:12 <quicksilver> without some metaprogramming mechanism to jumpstart you, there is no way to get access to constructor names
05:30:24 <quicksilver> no way a library can do that, I mean.
05:30:32 <luite> it's safe in ghc 7.8 isn't it?
05:30:34 <quicksilver> obviously the author of a type can just write them all down by hand if htey want to.
05:30:58 <quicksilver> don't trust the metaprograms! they break alpha-conversion!
05:31:09 <tulcod> typoclass, quicksilver: thanks, that's pretty much what i wanted to know :)
05:32:12 <typoclass> quicksilver: exactly. there's no way for the library to generate ¬´show (Item i) = "Item " ++ show i¬ª, because it can't programmatically get at Item or "Item"
05:34:16 <tulcod> thanks guys!
05:54:36 <honza> Given "data A = A (Map String String)", what's the idiomatic way of making a "lookup" function for A?
05:57:42 <typoclass> honza: hm ... "look key (A m) = Map.lookup key m"?
06:00:32 <honza> typoclass: thanks, that works
06:03:38 <elliott> honza: minor point, but you probably want newtype there.
06:05:14 <honza> elliott: right, of course
06:09:07 <isomorphic> If I have a .cabal with a Library and Test-Suite stanzas, should I have to install the Library to run the tests?
06:09:44 <supki> no, only build it
06:16:35 <isomorphic> Ah - just found a bug that makes sense - https://github.com/haskell/cabal/issues/1087
07:30:59 <Sculptor> yo
07:50:17 <Botje> what's wit hthe name changes? O_o
07:59:33 <geekosaur> bah. hayoo still down
08:02:44 <Taneb> :( geekosaur
08:05:24 <minopret> ( (A \/ B) /\ (B -> C) -> A \/ C ) Y'all are brilliant, so can one of you name that logic fact, and ideally tell me where to get hold of it in Coq, or else help me find a better forum?
08:05:34 <typoclass> Botje: netsplit or something?
08:07:17 <Botje> i guess
08:08:44 <applicative> constructive dilemma, sort of, minopret (with an unexpressed (A -> A)
08:09:05 <applicative> minopret: in other words
08:09:09 <applicative> @type either id
08:09:09 <lambdabot> (b -> c) -> Either c b -> c
08:09:24 <applicative> @type flip (either id)
08:09:27 <minopret> awesome! thanks @applicative !
08:09:28 <lambdabot> Either c b -> (b -> c) -> c
08:10:08 <minopret> I sort of remembered "dilemma" but didn't make the connection A -> A. Cool.
08:10:09 <applicative> forget that Haskell, it doesn't have an either as result type
08:12:41 <minopret> It's so hard to search the web for stuff like (A \/ B) /\ (B -> C) -> A \/ C ha ha
08:15:56 <geekosaur> symbolhound?
08:16:37 <applicative> @type let dilemma e f = Left undefined `asTypeOf` fmap f e
08:16:39 <lambdabot> <no location info>:
08:16:39 <lambdabot>     not an expression: `let dilemma e f = Left undefined `asTypeOf` fmap f e'
08:16:47 <applicative> @type let dilemma e f = Left undefined `asTypeOf` fmap f e in dilemma
08:16:48 <lambdabot> Either a a1 -> (a1 -> b) -> Either a b
08:17:24 <applicative> there minopret ... its flip (fmap _conditional_)
08:23:57 <Reite> Anyone got some tips on how to debug "Exception: Error_EOF" when using http-conduit? Any way to figure out where the error is occurring?
08:25:30 <fsckd> hi, to help me learn haskell i've been writing an irc bot. i'm stuck at a spot i didn't think i'd be stuck at. for whatever reason, Data.ByteString.Char8.hPutStrLn is not sending the bytestring given to it to the handle. there is no error output from the function. i do not think any exception is raised. the function appears in https://archwomen.org/~fsckd/bot/src/Network/Socat.hs line 28 col. 44. it is used
08:25:35 <fsckd> in https://archwomen.org/~fsckd/bot/src/Core/BotCore.hs  tarball to full code is https://archwomen.org/~fsckd/bot/bot.tar.xz
08:25:38 <fsckd> i made a much simpler version of my code where hPutStrLn does work, https://archwomen.org/~fsckd/bot/Main.hs (same everything else, different Main). i'm completely stumped and nay direction to getting hPutStrLn to is appreciated. thanks
08:26:46 <fsckd> any*
08:27:47 <acube> fsckd: /url 4
08:27:50 <acube> oops
08:28:21 <acube> fsckd: You return the IO *action
08:28:32 <acube> to send something, do you actually eval it at some point in your code?
08:28:39 <fsckd> yes
08:29:09 <fsckd> i've wrapped it in print statements to test if it was getting called and they worked
08:29:43 <fsckd> (i'm not yet comfortable with the ghci debugger which is why i used print statements)
08:30:02 <typoclass> fsckd: sure :) nothing wrong with print statements
08:30:03 <acube> I'm also using trace/print :P
08:30:20 <supki> fsckd: could you show the code where you call that hPutStrLn?
08:30:48 <fsckd> yes, it's in the link to BotCore
08:30:58 <merijn> No
08:31:01 <fsckd> it gets passed around a bit
08:31:12 <merijn> I just tried searching for hPutStrLn and I don't find it in the code
08:31:41 <fsckd> the main function where it is ultimately called https://archwomen.org/~fsckd/bot/src/Main.hs
08:32:10 <fsckd> merijn: it's in https://archwomen.org/~fsckd/bot/src/Network/Socat.hs
08:33:52 <supki> okay, I don't see it in BotCore.hs either
08:33:53 <typoclass> fsckd: there seems to be a lot of stm, threading, forking going on. what's the plan behind this? as opposed to (say) just reading all the lines the server sends, and occasionally sending a line to the server
08:34:33 <typoclass> fsckd: another question :-) have you run wireshark or an equivalent and watched your program talk to the server?
08:34:42 <fsckd> hehe the code is rather convoluted isn't it
08:35:57 <fsckd> typoclass: i haven't run wireshark, mainly because i don't know how. i made a simpler version which did work. https://archwomen.org/~fsckd/bot/Main.hs
08:44:25 <supki> oh, I see, it could be called in spawnSender I guess
08:44:33 <merijn> It's not
08:44:40 <merijn> afaict that code should be a type error
08:44:40 <fsckd> typoclass: for your other question, partly for performance, mainly to learn about stm
08:44:41 <typoclass> fsckd: wireshark is handy for doing any network programming. it's not difficult to use, you start it and click the "capture" button, then you get a list of what's going on in real-time, then you can interactively filter
08:44:42 <fsckd> typoclass: i will try it
08:44:42 <merijn> fsckd: connectLoop gets the hPutStrLn out the triple and put it in ircSend
08:44:43 <fsckd> merijn: yes
08:44:43 <merijn> fsckd: Then you pass ircSend to spawnSender
08:44:44 <fsckd> yes
08:44:44 <merijn> Which gets the sender out of LoopState
08:44:45 <fsckd> yup
08:44:46 <merijn> Then you pass sendIrc to the sender, which afaict is a type error
08:44:48 <merijn> oh, no
08:44:48 <merijn> Didn't read all of it
08:44:49 <merijn> So where is sender coming from?
08:44:54 <fsckd> merijn: sender is in the state
08:44:55 <fsckd> merijn: it's set in initCore
08:44:56 <mjrosenb> does anyone know if vector actually needs annotations in order to work?
08:44:56 <merijn> This code seems ridiculously complicated for something simple
08:44:57 <mjrosenb> it is very annoying that I cannot build it.
08:44:59 <typoclass> fsckd: ok there's nothing wrong with using stm just to learn about it, but regarding performance, you first should demonstrate that it runs too slowly without it, and that it runs faster with it. otherwise you'll end up using complicated stuff to fix bottlenecks which aren't any. too often it ends up being a solution in search of a problem
08:45:03 <merijn> I'm having to jump all over the place to find what you are trying to do, that doesn't seem very helpful in debugging
08:45:19 <merijn> For example, why does "spawnSender" have to return something of type "LoopIO"?
08:45:20 <fsckd> typoclass: another thing, i guess since i'm here, i read that if a function that blocks on reading from a handle, it'll block the whole thread. it was suggested that the function be run in its own thread.
08:46:11 <fsckd> merijn: it's only called in one function
08:46:11 <typoclass> fsckd: yes that's true, i estimate you'll need 2 threads total (one for receiving and displaying, one for sending)
08:46:11 <merijn> Why not just "spawnSender :: IO () -> IO ThreadId" and do "sender <- gets sender; senderID <- spawnSender (sender ircSend)" in connectLoop?
08:46:12 <merijn> hell
08:46:14 <merijn> Why does spawnSender exist at all?
08:47:21 <mjrosenb> secondary question: why do annotations require ghci?
08:48:00 <merijn> What's wrong with http://hpaste.org/90409 ?
08:48:28 <merijn> (also, qualified State and Concurrent looks really ugly, imo)
08:48:35 <fsckd> typoclass: there are other things which will be added to the code, such as a thing for controling the bot with a unix domain socket. so may be 4 or 5 threads
08:48:48 <fsckd> merijn: one sec, i'll take a look
08:49:13 <fsckd> thank you everyone for your patience with my code and help so far :)
08:49:26 * typoclass purrs
08:49:31 <merijn> fsckd: "4 or 5 threads", I routinely consider haskell programs with >20 threads and that's still nothing. You can easily have >100k threads if they keep blocking on IO
08:50:10 <fsckd> cool
08:50:34 <mjrosenb> merijn: native threads?
08:50:36 <typoclass> merijn: yes, but will the irc bot need thousands of threads?
08:50:45 <merijn> I personally find the getter type functions like connect2irc very confusing, they don't really do anything but I can't see what happens in there immediately
08:50:50 <dmwit> mjrosenb: No, GHC threads.
08:50:51 <merijn> typoclass: No, that was kinda my point
08:51:10 <merijn> typoclass: If you can do that without worrying, why worry about the performance of 4-5 threads
08:51:37 <mjrosenb> dmwit: ok, that makes much more sense.
08:51:50 <dmwit> mjrosenb: I would say it's pretty unusual to have more than, let's say, twice as many OS threads as CPUs.
08:51:51 <mjrosenb> uhh
08:52:04 <dmwit> 100k is still a lot
08:52:07 <mjrosenb> can I comment out a ghc directive
08:52:26 <mjrosenb> e.g. "-- {-# ANN type SPEC ForceSpecConstr #-}"
08:52:39 <dmwit> You'll need like... 100MB of memory just for the thread data (assuming 1K overhead per thread? seems about right).
08:52:54 <typoclass> merijn: i had asked fsckd why there was things like "C.forkIO . ircSend ... NICK ; C.forkIO . ircSend . USER", suggesting that that's too much threading for not much reason, and saying there'll be only two threads needed on the irc tcp socket
08:53:04 <dmwit> mjrosenb: Sure you can.
08:53:06 <merijn> oh, right
08:53:10 <typoclass> (that was the context of the "we need 4-5 threads")
08:53:39 <merijn> dmwit: 100 MB of memory for threading data doesn't sound like a lot
08:53:42 <mjrosenb> dmwit: excellent. since it was already in a comment, I wasn't entirely sure if ghc would actually ignore it, or just meh, nested comments, I can deal with that
08:54:00 <fsckd> you guys have given me a lot of food for thought :)
08:54:01 <merijn> mjrosenb: You could just delete the # at the start
08:54:30 <dmwit> mjrosenb: hehe, I like your attitude
08:54:45 <dmwit> "comments? SCREW IT, PARSE 'EM ANYWAY"
08:55:19 <fsckd> if i may may ask, in the contecxt of my irc bot, how would you do events? like some modules may need to run functions when connection happens. others may need to intercept the message just before it's sent out or just after it comes and is parsed
08:55:45 <dmwit> I guess that's sort of what happens after all. Still pretty funny. =)
08:56:02 <dmwit> fsckd: Spawn a thread and block on waiting for a connection.
08:56:14 <dmwit> Or maybe I misunderstood the question.
08:56:35 <typoclass> fsckd: bunch o' functions!
08:56:36 <merijn> fsckd: Use a Chan
08:57:03 <merijn> fsckd: Create a data type for events, write them to the Chan, have different things listen for events on that Chan
08:57:10 <dmwit> fsckd: The variety of answers you have received should be a clue that your question isn't specific enough yet.
08:57:13 <merijn> Or callbacks
08:57:37 <fsckd> dmwit: hehe
08:58:17 <fsckd> yes, i've been using callbacks and the occasional TChan and as some of you have noticed, threads :P
08:59:37 <typoclass> fsckd: it would help if you had an example :-) "when we're connected to the irc server, line 123 in file X, at that moment module such-and-such needs to do Y, how do i do this nicely"
08:59:54 <fsckd> ok, one sec
09:01:18 <banister`sleep> can haskell spit out standalone binaries?
09:01:19 <banister`sleep> or does the haskell runtime need to be installed on the target system
09:01:19 <typoclass> banister`sleep: yes, by default it does (i think)
09:01:29 <banister`sleep> cool
09:01:39 <typoclass> i thought it's linked statically by default? not sure
09:02:29 <dmwit> typoclass: correct
09:03:06 <dmwit> You will still need to install whatever C libraries you've linked against, of course.
09:03:07 <byorgey> by default the Haskell runtime is linked statically, but there are a few things which are linked dynamically including libgmp
09:03:24 <dmwit> ...for example, libgmp, liblinux, etc.
09:03:27 <dmwit> You can check with objdump.
09:04:03 <byorgey> ooh, didn't know about objdump
09:04:19 <fsckd> sorry, i have to go for a while. thanks for all the help so far :)
09:04:35 <Botje> ldd will tell you what libraries a binary needs
09:05:12 <dmwit> Oh, yes, I meant ldd. objdump is something else
09:06:30 <typoclass> fsckd: you're welcome :-)
09:06:44 <typoclass> byorgey: you on a mac? i think you need otool instead
09:06:59 * byorgey is insulted
09:07:06 <byorgey> ;-)
09:07:37 <typoclass> byorgey: erm, sorry :-) i think i mixed you up with merijn then
09:07:45 <byorgey> hehe
09:08:10 <byorgey> you will have to pry my open-source operating system from my cold, dead fingers
09:08:41 <typoclass> (i have the same feeling about the apple shiny glitzy stuff. it's terrible)
09:09:16 <merijn> At least my OS has dtrace...
09:09:20 <merijn> Your move!
09:09:46 <mjrosenb> HAHAHAH TAKE THAT, vector-0.10.0.1...
09:10:35 <typoclass> merijn: when i tried to use it once, the console interface seemed as incomprehensible as the gui *shrug*
09:10:58 <Taneb> Wow, you can use free-game with monad transformers
09:12:42 <banister`sleep> Taneb: what is a monad
09:12:52 <Taneb> Shush, you
09:12:59 <banister`sleep> ;)
09:19:58 <hiptobecubic> Oooo, a monad discussion?
09:22:40 <typoclass> hiptobecubic: that comment is a very surprising thing to say in #haskell. we have monad discussions about 11 times per day
09:22:40 <typoclass> =)
09:22:51 <joelteon> where are the dyads
09:22:54 <tdammers> instance Monad Discussion where (>>=) = argueBack; return = argueInCircles; fail = Hitler
09:22:55 <joelteon> i don't think that typechecks
09:24:39 <saml> hey,   f . f = g      ;  what is f ?
09:24:54 <joelteon> a function
09:24:54 <saml> for example,  a * b = c;   then a = c/b
09:25:02 <saml> is there something like that for function composition?
09:25:11 <saml> where b > 0
09:25:18 <Botje> you cannot extract f out of g.
09:25:21 <saml> f . f = g;   f = f / g
09:25:25 <saml> why not?
09:25:26 <tdammers> > let f = show; g = f . f in g "Hello!"
09:25:29 <lambdabot>   mueval-core: Time limit exceeded
09:25:45 <tdammers> eh... what?
09:25:45 <saml> do i need dependent type?
09:25:50 <tdammers> > let f = show; g = f . f in g "Hello!"
09:25:50 <Botje> you cannot ask g from which functions it's composed.
09:25:50 <lambdabot>   "\"\\\"Hello!\\\"\""
09:25:50 <tdammers> ah, right.
09:26:15 <saml> functions don't form some category where . is something?
09:26:21 <tdammers> they do
09:26:27 <tdammers> but the . operation isn't reversible
09:26:34 <saml> so what's inverse of . ?
09:26:44 <tdammers> there isn't any
09:26:46 <Botje> there is none.
09:26:49 <merijn> saml: Why would there be an inverse?
09:26:52 <saml> is there some group or category where . is bijective?
09:26:57 <typoclass> Botje: yes in haskell you can't do that. but i thought it was more of a theoretical question independent of haskell. (ghc doesn't change a * b = c into a = c/b either)
09:27:23 <tdammers> the thing is, there are infinitely many possible solutions to the question "given g in g = f . f, find f"
09:27:25 <typoclass> right, ok
09:28:55 * applicative has always thought of (+1) as kind of 'the square root of (+2)'
09:29:42 <tdammers> although I'm wondering how one would prove that...
09:33:26 <mjrosenb_> applicative: that is starting to sound like a physicist's level of abuse of notation
09:43:23 * hackagebot z3 0.3.1 - Bindings for the Z3 Theorem Prover  http://hackage.haskell.org/package/z3-0.3.1 (IagoAbal)
09:43:25 * hackagebot esqueleto 1.2.2.1 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.2.2.1 (FelipeLessa)
09:44:38 <ion> Aww, it still only supports SELECT.
09:44:53 <acube> How do you name your State-record if you're using the State monad? Can't name it State, because that's already taken by the monad name
09:45:15 <ion> Import State qualified or use some other name. I‚Äôd suggest the latter to avoid confusion.
09:49:41 <dmwit> acube: Name it after what kind of state it is. Game, Person, etc.
09:49:42 <Cale> saml: Depends on what you mean by "bijective"
09:50:48 <dmwit> saml: The CT term for finding two arrows which compose to a given third arrow is "factoring".
09:50:58 <applicative> people do have trouble with this, they write GameState, but then StateT GameState ... looks kinda stupid.
09:51:04 <dmwit> So for "f . f = g" you could say "f is a factor of g"; but it's much stronger, too.
09:51:15 <dmwit> applicative: That's why I suggested Game rather than GameState, of course.
09:51:39 <dmwit> or rather, "f factors g"
09:51:50 <dmwit> you also sometimes see "g factors through f"
09:51:54 <applicative> ah, back to f . f = g , I was thinking about factoring in the monoid (Nat , * ) or the category with the *n actions
09:52:23 <applicative> dmwit: yes, I was agreeing with you about Game
09:53:47 <applicative> what do we call s when s . s = s , I can't remember suddenly
09:53:55 <xplat> dmwit: 'f is a square root of g'
09:54:13 <geekosaur> applicative, idempotent?
09:54:16 <xplat> applicative: and yours is 'idempotent'
09:54:26 <applicative> it is idempotent yes
09:57:20 <applicative> it was s . s = id that I was really thinking of ... an involution
09:57:51 <chrisdotcode_> hola all
09:58:09 <applicative> hullo chrisdotcode_
09:58:19 <chrisdotcode_> hey, applicative
09:58:23 <joelteon> let id x = let !_ = unsafePerformIO (print x) in x
09:58:40 <joelteon> idempotent!
10:00:12 <flebron> Hi. When I install a package with cabal, are its sources discarded?
10:00:16 <applicative> let idd x = unsafePerformIO (print x) `seq` x
10:00:27 <applicative> flebron: no, they are somewhere in ~/.cabal
10:00:55 <merijn> flebron: Do you just want to look at the source of a package?
10:00:56 <applicative> you can do cabal get blah, which youi just installed and it will unzip it in the directory
10:01:25 <applicative> cabal unpack blah, I should say
10:01:44 <merijn> No
10:01:45 <merijn> unpack is deprecated
10:01:45 <merijn> You should use get
10:01:46 <merijn> (according to my cabal)
10:01:48 <applicative> yes, but only in cabal - head
10:02:04 <applicative> I was assuming flebron wasn't as avant garde as we are ;)
10:02:30 <flebron> merijn: Nah, I was wanting to trace the execution of a function in a package.
10:02:37 <applicative> flebron, also do you have cabal config set to 'haddock' the documentation.
10:02:47 <OffsetGoose> In Ix.html (http://www.haskell.org/ghc/docs/latest/html/libraries/haskell98-2.0.0.2/Ix.html), is there one too many parentheses here:
10:02:47 <OffsetGoose> map (index (l,u)) (range (l,u))) == [0..rangeSize (l,u)-1]
10:02:58 <flebron> Not sure I do, how would I check that?
10:03:19 <applicative> open ~/.cabal/config  -- if thats where your local cabal file is
10:03:20 <geekosaur> doesn't look like too many parens to me
10:03:23 * hackagebot risc386 0.0.20130624 - Reduced instruction set i386 simulator  http://hackage.haskell.org/package/risc386-0.0.20130624 (AndreasAbel)
10:03:29 <banister`sleep> applicative: what is an applicative functor
10:03:40 <flebron> (I copied a function off a library, since in my situation I can't import external libs, and it behaves different from if I import the library function and call it, so I wanted to trace the execution of the library one with Debug.Trace.)
10:03:48 <applicative> banister`sleep: an idiom
10:03:59 <OffsetGoose> geekosaur: the last one after (range (l,u))
10:04:39 <applicative> how can it behave differently if it has the same definition ...
10:04:40 <geekosaur> oh, hm, that does look unmatched
10:05:09 <flebron> applicative: That's what I'm wondering :)
10:06:06 <OffsetGoose> Yea, that's what I thought.  It's not coded, those are just laws that Ix has to follow.  I know it's not that big a deal, but is there an editor?
10:06:16 <applicative> flebron: in any case, if youre low tech like me you can unpack foo-0.2 , do your damage, then do cabal configure ; cabal build then
10:06:16 <flebron> applicative: Is there a reasonable way of doing what I want?
10:06:45 <NemesisD> hi guys. trying to install cabal/cabal-install HEAD. which should i be doing first
10:06:54 <flebron> Hrm, can I import a library from the current directory, instead of the cabal package directory?
10:07:25 <applicative> flebron then make a directory tmp or test, put your test module in it, then do ghci  -package-db ../dist/package.conf.inplace mytest.hs
10:07:45 <applicative> or ghci-dist as my idiotic alias has it.
10:08:20 <applicative> if the test file exports the offending module it will be in scope in ghci
10:09:04 <banister`sleep> applicative: you look like the kind of man who could give a hearty and robust explanation of applicative functors
10:09:33 <applicative> flebron: you can just write a Test.hs that is in the same directory as Control or whatever the highest level is, then call ghci without compiling
10:10:17 <flebron> applicative: How can I ask cabal to preserve the .hs of packages? I only find .hi and .o and stuff.
10:10:19 <applicative> flebron: in that case it will use the local Control.Madness.Destruction, not the registered package
10:11:16 <applicative> flebron: they are in a zipfile in $HOME/.cabal/packages/hackage.haskell.org/
10:11:24 <flebron> Ah, cool.
10:11:32 <NemesisD> ok for some reason cabal-install's bootstrap.sh requires root to check currently installed packages, yet if i run it in root it can't find Cabal 1.17, which is installed with --user on my non-root user. what should i do?
10:11:38 <applicative> cabal unpack blah will unzip them in the current directory
10:12:52 <applicative> are you sure it requires root. does it take a prefix?
10:13:25 <supki> NemesisD: it should be ok to do cabal install in Cabal the library directory and then cabal install in cabal-install directory
10:13:28 <ion> nemesisd: FWIW, i always do this and it certainly doesn‚Äôt require root. https://gist.github.com/ion1/2815423
10:13:36 <supki> NemesisD: I don't think you need bootstrap.sh at all
10:13:40 <applicative> NemesisD: options:    --user    Install for the local user (default)
10:13:50 <NemesisD> applicative: i run it with --user, but it still runs ghc-pkg list ... > ghc-pkg.list
10:13:56 <applicative> hmmm
10:13:58 <NemesisD> with global*
10:14:46 <applicative> NemesisD: do you have a pre-existing cabal-install?
10:15:12 <NemesisD> supki: so that requires an older version of cabal-install?
10:15:18 <applicative> I think I installed the HEAD version with cabal install , having cleverly renamed cabal
10:15:26 <NemesisD> applicative: i removed the one from my package manager in preparation, probably foolishly
10:15:41 <supki> NemesisD: yeah, I assumed you have one already if you try to install from HEAD
10:15:42 <applicative> oh, i'm agreeing with supki; i've done jjust that
10:16:13 <OffsetGoose> I have a n00b question: why doesn't (fmap return [1,2,3]) work?
10:16:21 <NemesisD> ok i can install old cabal again. should i install it from source or from my package mgr
10:16:27 <applicative> > fmap return [1,2,3]
10:16:29 <lambdabot>   No instance for (GHC.Show.Show (m0 a0))
10:16:29 <lambdabot>    arising from a use of `M18948158...
10:16:39 <applicative> > fmap return [1,2,3] :: [[Int]]
10:16:40 <lambdabot>   [[1],[2],[3]]
10:17:23 <applicative> OffsetGoose: it can figure out that fmap is using the [] functor; but what monad?
10:17:33 <applicative> what monad for return , I mean
10:17:39 <supki> NemesisD: package manager one should be okay
10:17:47 <applicative> > fmap return [1,2,3] :: [Just Int]
10:17:48 <supki> unless you use debian stable or worse of course
10:17:48 <lambdabot>   Not in scope: type constructor or class `Just'
10:17:49 <lambdabot>  A data constructor of that ...
10:17:55 <applicative> > fmap return [1,2,3] :: [Maybe Int]
10:17:56 <lambdabot>   [Just 1,Just 2,Just 3]
10:18:11 <OffsetGoose> applicative: That clears it upl thanks
10:18:18 <NemesisD> supki: the bootstrap bit still requires root
10:18:24 * hackagebot HaTeX 3.6 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.6 (DanielDiaz)
10:18:32 <nobb> what are free monads?
10:18:43 <supki> NemesisD: probably, but you should not need it
10:19:00 <ion> > fmap return [1,2,3] <*> ["hello"]
10:19:01 <lambdabot>   [1,2,3]
10:19:05 <applicative> > fmap return [1,2,3] :: [Either String Int]
10:19:06 <lambdabot>   [Right 1,Right 2,Right 3]
10:19:12 <NemesisD> supki: how am i going to install the new cabal without running bootstrap?
10:19:40 <applicative> by getting it back from the package manager>
10:19:42 <applicative> >
10:19:44 <applicative> ?
10:19:45 <applicative> bah
10:20:07 <NemesisD> applicative: my package manager has cabal-install 1.16, i'm trying to install 1.17
10:20:15 <applicative> I wonder if the permissions nonsense is somehow coming from the way the package manage installed this stuff
10:20:46 <NemesisD> it looks like it fails on ${GHC_PKG} list --global ${SCOPE_OF_INSTALLATION} > ghc-pkg.list
10:20:54 <applicative> NemesisD: yes, like supki I wonder if it is best to have cabal install it from inside the source dirs, not use bootstrap.hs
10:21:16 <applicative> why bootstrap when you can do whatever it is we do when we don't bootstrap ?
10:21:24 <NemesisD> applicative: i can have cabal install cabal-install?
10:21:52 <applicative> NemesisD: oh yes, but that wont help you with the unreleased version or is 1.17 released
10:22:30 <NemesisD> applicative: it is unreleased, hence all these shennanigans ;)
10:22:51 <applicative> how long will it to take to tell pacman to install cabal-install or whatever
10:23:05 <supki> NemesisD: to install from HEAD version you run  cabal install  from Cabal directory and then run  cabal install  from cabal-install directory
10:23:12 <NemesisD> OHHHH hold up. i think something screwed up a permission in the *current* directory
10:23:13 <supki> at least it was simple as that for me
10:23:21 <NemesisD> chown -R michael:michael . seemed to smooth things over
10:23:25 * applicative reiterates agreement with supki
10:24:08 <applicative> ah, wait that may be another curiousity, if other things were wrongly installed with sudo
10:24:56 <applicative> i remember i couldn't install things with c bindings without sudo cabal install a while back, so I was forever chowning ~/.cabal which was ridiculous
10:24:58 <mizu_no__> What do you need to do to give a CUFP experience report?  Is it just a 25 minute talk, or do you need to submit a short paper as well?
10:26:37 <applicative> NemesisD: in the git repo, you had hs files with superior permissions? ...
10:27:11 <applicative> god knows mizu_no__ i'm sure the organizers are approachable types
10:28:26 <applicative> nobb: did you figure out free monads?
10:29:43 <nobb> i'm reading stack overflow answers, including one by edward kmett
10:29:44 <applicative> nobb you can define it as a type directly, Free f a = Done a | Free (f (Free f a))
10:30:24 <nobb> someone compared it to lists
10:30:28 <applicative> it's clearer for some purposes as Expr f a = Lit a | Expr (f (Expr f a))
10:31:12 <applicative> here the specific functor f determines how you build an expression.
10:31:36 <absence> http://hpaste.org/90412 <- this is very confusing. main' works as it should, but main doesn't even execute the print action. why is that?
10:32:10 <nobb> interesting
10:32:18 <absence> am i missing some basic property of applicatives?
10:32:55 <applicative> nobb: so if I define data Math a = Plus a a | Times a a , then Expr Math Int will be all the expressions with Plus Times  ending in Lit int
10:33:18 <applicative> or similarly , Free Math Int will be
10:34:52 <hashcat> how to install hint?
10:35:29 <hashcat> i used "cabal install hint" and get errors
10:35:36 <byorgey> absence: the type of main is  IO (IO [Int])
10:36:06 <applicative> absence: if Control.Monad is in scope, then join $ print <*> count 3 will work
10:36:27 <byorgey> absence: it is an IO action which does nothing and returns an IO action which, if executed, would print some stuff
10:36:27 <applicative> or (print <*> count 3) >>= id
10:36:39 <byorgey> absence: but main is allowed to have type   IO a  for an a, and the a is simply ignored
10:36:43 <typoclass> hashcat: could you rerun cabal with the -v3 switch and put the output on hpaste.org?
10:37:07 <byorgey> arguably this should be a type error.  I don't see why it is useful to have anything other than  IO ()  (or possibly  IO Int) as the type of main
10:37:16 * applicative agrees
10:37:18 <byorgey> it is just confusing.
10:37:34 * geekosaur never really understood why it was changed from IO ()
10:37:36 <absence> i agree too, i had no idea main wasn't implicitly IO ()
10:37:43 <hashcat> typoclass: wait a moment.
10:37:43 <geekosaur> aside from that ghc happened to allow IO a
10:37:45 <Cale> geekosaur: "Changed from"?
10:37:46 <applicative> everything in the type system is so many ways of partioning the () in IO ()
10:37:48 <absence> thanks :)
10:37:52 <Cale> When was it ever not IO a?
10:38:01 <byorgey> absence: it would help a lot if you gave type signatures to your functions
10:38:03 <applicative> i thought it always was
10:38:08 <geekosaur> wasn't the official standard IO () and then changed to match ghc?
10:38:09 <byorgey> absence: if you actually wrote  main :: IO ()  then it *would* be a type error.
10:38:10 <Cale> I don't think it's helpful to make things require arguments of type IO ()
10:38:51 <absence> byorgey: yes, i did have one for count earlier, but i never thought of haveing one for main
10:38:59 <byorgey> Cale: we're talking about the type of  main.  when would main ever be an argument to something?
10:39:22 <hashcat> typoclass: it just can't find ghc package
10:39:34 <Cale> byorgey: Well, you can think of main as effectively being an argument to the runtime system :)
10:39:46 <applicative> hugs accepts main = print 3 >> return 4
10:39:46 <hashcat> typoclass: [__7] fail (unknown package: ghc)
10:39:57 <chrisdotcode_> flirtWith :: Girl -> Compliment -> Maybe Attraction
10:40:04 <OffsetGoose> Another noob question: why is it that you can have a type signature like: Num a => a -> a -> a, where
10:40:04 <OffsetGoose> a is diectly referenced, but with moads you have to do something like: Monad m => a -> m b; why can't you
10:40:04 <OffsetGoose> just say: Monad m => a -> m ?
10:40:18 <chrisdotcode_> haskell is great for representing my life problems :)
10:40:20 <supki> hashcat: how did you install ghc?
10:40:57 <hashcat> typoclass: i installed it by yum on fedora
10:41:16 <applicative> OffsetGoose: m is not itself a type, a thing of kind *, so a -> m makes no sense
10:41:25 <Cale> OffsetGoose: A monad is a function on types
10:41:37 <Cale> OffsetGoose: It takes some type as a parameter and produces another type
10:41:48 <hashcat> supki: i installed it from rpm package by yum on fedora
10:41:51 <Cale> For instance like with Maybe
10:41:57 <supki> hashcat: ghc package should come with ghc, so I guess fedora guys splitted packages a bit too much
10:41:59 <Cale> You can't write  x :: Maybe
10:42:00 <applicative> m Int , m Char , m Bool  -- these are types proper, things of kind *.   m is a thing of kind * -> * a function in the typesystem
10:42:49 <OffsetGoose> Alright, thanks for clearing that up
10:43:08 <typoclass> OffsetGoose: Maybe and Monad are not types, they're of kind * -> * (they take one type as an argument, for example Int, and then produce a complete type). other things are of kind *, i.e. they are types themselves (for example String or Int)
10:43:34 <OffsetGoose> Is Num not a function on types?
10:43:45 <applicative> no, its a class, a constraint on types
10:43:50 <applicative> @kind Num
10:43:50 <lambdabot> * -> Constraint
10:43:56 <Cale> hashcat: I no longer trust any distribution to give me a reasonable ghc package, and instead just download the generic linux binary from the GHC website, and then grab the cabal-install tarball from Hackage and run the bootstrap from that, and it gives me a reasonable starting point.
10:44:36 <applicative> Constraint is kind of a strange choice for that, it might have been TRUE
10:44:38 <absence> byorgey: if i remove the n<10 condition it hangs instead of starting to print an infinite list. is it impossible for an applicative expression like that to be lazy?
10:45:37 * applicative says to hashcat , Cale is right, but for a simpler reason , if you install it all locally in ~/ghc ...  then you can just delete it all
10:45:37 <chrisdotcode_> Cale: the haskell platform worked well for me...
10:45:51 <chrisdotcode_> from the linux mint repos
10:46:07 <Cale> chrisdotcode_: It's usually out of date.
10:46:23 <typoclass> Cale: wait, distros are installing stuff such that you end up with a working ghc and cabal, but "ghc-pkg list ghc" will give nothing? how does that even ...
10:46:34 <OffsetGoose> Is there any way to tell whether it's a constraint or a function on types from the class delcaration? class Num a where ... looks very similar to class Monad m where ...
10:46:46 <Cale> (but at the moment it might be okay)
10:47:00 <applicative> hint might be a little trouble in any case hashcat
10:47:06 <chrisdotcode_> yeah, at the moment, I was blessed enough to get the latest version of ghc
10:47:21 <Cale> OffsetGoose: Monad m is a constraint too!
10:47:23 <hashcat> thanks a lot. I just find "ghc" and "ghc-ghc-devel" rpms could solve my problem.
10:47:29 <Cale> :k Monad
10:47:30 <lambdabot> (* -> *) -> Constraint
10:47:39 <Cale> ^^ it's just that its parameter has a different kind
10:47:55 <Cale> And you can tell that by looking at the rest of the definition of the class
10:48:03 <Cale> You'll see:  return :: a -> m a
10:48:15 <applicative> youi can only satisfy the Monad constraint if youre a (* -> *) type morpher
10:48:23 <Cale> So m must be kind * -> *
10:48:43 <Cale> a :: * because it's a parameter to (->)
10:48:49 <Cale> m a :: * because it is too
10:48:56 <Cale> and so m :: * -> *
10:49:45 <hashcat> with "ghc-ghc-devel" rpm, hint can be installed without any problem on fedora. =D
10:49:46 <SideEffffECt> hello, could somebody pls help me with these Emacs/StylishHaskell/Tags-on-save bugs?
10:49:49 <SideEffffECt> when I have in .emacs '(haskell-stylish-on-save t), whenever I try to save the file, it's just reloaded again from disk -- effectively deleting all the changes I do
10:49:51 <SideEffffECt> when I have in .emacs '(haskell-tags-on-save t), on every save, I get a message "haskell-session-from-buffer: Symbol's function definition is void: remove-if-not"
10:49:53 <SideEffffECt> thank you so much!
10:49:54 <ATuin> does anyone run an snap web app on linode?
10:49:57 <OffsetGoose> Cale: Thanks a lot, mate
10:50:38 <applicative> hashcat: oh good. I'm not seeing why there's trouble.  Hint installs here fine.    Remember not to go back to fedora after cabal installing, according to the wise
10:50:45 <mightybyte> ATuin: I do
10:51:16 <ATuin> mightybyte: so its possible, thanks, im completely new to VPS and haskell web development
10:51:30 <absence> http://hpaste.org/90413 <- is there a way to have this work lazily, or does <*> need to run all side effects before anything can happen?
10:51:39 <mightybyte> You can't build Haskell web apps on small VPSs.
10:51:44 <mightybyte> The linker takes too much memory.
10:52:02 <Rarrikins> What are the naming rules for modules?
10:52:02 <ATuin> how to do then?
10:52:03 <mightybyte> So if you have a small linode, you'll need to build your app elsewhere.
10:52:14 <Rarrikins> It looks like you can have an underscore but not a hyphen.
10:52:35 <applicative> absence: mapM_ print =<< count 3 ?
10:53:11 <applicative> absence: extract the list from count 3 then do mapM_ on it
10:53:15 <mightybyte> ATuin: If I was starting from scratch now, I think I'd get a hetzner server.
10:53:16 <mightybyte> http://www.hetzner.de/en/hosting/produkte_rootserver/ex4
10:53:39 <absence> applicative: still hangs
10:54:04 <dpanth3r> Hello, does anyone know why there is a compilation error on network-2.4.0? :D
10:54:22 <Rarrikins> What is the error?
10:54:27 <dpanth3r> Network/URI.hs:596:25: Couldn't match expected type `Char' with actual type `String'
10:54:32 <applicative> absence: yes it's something with count, I thought it was an infinite list...
10:55:09 <dpanth3r> Expected type: GenParser Char () Char / Actual type: URIParser String
10:55:36 <applicative> oh it is an infinite list, starting with 3 absense
10:55:42 <applicative> absence:
10:56:00 <absence> applicative: yes :)
10:56:46 <applicative> absence: i wonder if because the construction of the list is happening in IO theres strictness, let me think
10:57:30 <absence> applicative: i'm wondering if <*> implies strictness?
10:58:00 <absence> applicative: i know applicatives can't be used to implement an if-then-else function
10:58:36 <absence> applicative: as it will execute both side effects regardless of condition
11:00:14 <dpanth3r> Rarrikins: any idea ? ^^"
11:00:24 <ATuin> mightybyte: i will think about it, thanks
11:00:29 <Rarrikins> dpanth3r: Found something: https://github.com/haskell/network/issues/60
11:00:56 <dpanth3r> Rarrikins: ah thanks, didn't know they were on github
11:00:56 <mjrosenb>     Could not deduce (Num a) arising from the literal `255'
11:00:59 <mjrosenb> uhhh...
11:01:32 <chrisdotcode_> > (,) 1 2
11:01:34 <lambdabot>   (1,2)
11:01:47 <chrisdotcode_> :t (,)
11:01:48 <lambdabot> a -> b -> (a, b)
11:01:54 <chrisdotcode_> :t (,,)
11:01:55 <lambdabot> a -> b -> c -> (a, b, c)
11:02:02 <chrisdotcode_> :t (,,,,,,,,)
11:02:03 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> (a, b, c, d, e, f, g, h, i)
11:02:08 <chrisdotcode_> how many of them are there?
11:02:18 <supki> 62
11:02:25 <chrisdotcode_> really? >_>
11:02:28 <mjrosenb> chrisdotcode_: i vaguely remember that they are magic, and auto generated as you use them.
11:02:33 <geekosaur> > "" ++ 5
11:02:35 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
11:02:35 <lambdabot>    arising from the literal ...
11:02:40 <chrisdotcode_> mjrosenb: I would hope that that would be the answer
11:02:43 <geekosaur> same kind of thing
11:02:53 <applicative> absence: its the same with countq n = fmap (n:) $ countq (n+1)
11:03:10 <geekosaur> numeric literals will cause a (Num a) constraint to spring into existence, then if that gets applied to something without a Num instance ghc outputs an ofte confusing error message
11:03:44 <chrisdotcode_> > (,3)  2
11:03:45 <lambdabot>   Illegal tuple section: use -XTupleSections
11:03:48 <mjrosenb> geekosaur: right, but this is on:
11:03:48 <mjrosenb> bytemask = 255
11:03:55 <chrisdotcode_> > (3,) 2
11:03:56 <lambdabot>   Illegal tuple section: use -XTupleSections
11:04:04 <chrisdotcode_> why is that an illegal tuple section?
11:04:10 <supki> @ty (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
11:04:11 <lambdabot>     A 63-tuple is too large for GHC
11:04:12 <lambdabot>       (max size is 62)
11:04:12 <lambdabot>       Workaround: use nested tuples or define a data type
11:04:23 <supki> so actually 61
11:04:29 <geekosaur> chrisdone, as the error says, lambdabot doesn't have the tuplesections extension enabled so it is illegal
11:04:33 <mjrosenb> chrisdotcode_: it isn't, just they aren't turned on by default.
11:04:37 <geekosaur> standard haskell does not have tuple sections
11:04:52 <geekosaur> erp. "chrisdotcode"
11:04:58 <chrisdotcode_> is there any particular reason for that?
11:05:02 <mjrosenb> > (3`(,)`) 2
11:05:03 <lambdabot>   <hint>:1:4: parse error on input `('
11:05:10 <mjrosenb> just trying :-p
11:05:20 <SideEffffECt> hello, could somebody pls help me with these Emacs/StylishHaskell/Tags-on-save bugs?
11:05:23 <SideEffffECt> when I have in .emacs '(haskell-stylish-on-save t), whenever I try to save the file, it's just reloaded again from disk -- effectively deleting all the changes I do
11:05:25 <SideEffffECt> when I have in .emacs '(haskell-tags-on-save t), on every save, I get a message "haskell-session-from-buffer: Symbol's function definition is void: remove-if-not"
11:05:27 <SideEffffECt> is this easily debugable, or is it too complicated and I should just disable those features; and should I even care, are those any good, do you guys use those often?
11:05:31 <SideEffffECt> thank you so much!
11:05:52 <Rarrikins> chrisdotcode_: By default, that's not an acceptable syntax. Probably just to catch errors where someone forgets to fill in a part of a literal tuple or to make it easier to parse things.
11:05:58 <mjrosenb> SideEffffECt: #emacs is likely a better place to ask.
11:06:13 <chrisdotcode_> Rarrikins: right. that makes sense, I suppose.
11:06:25 <absence> applicative: i guess IO forces sequencing, which makes sense
11:06:27 <chrisdotcode_> oh, by the way.
11:06:28 <mjrosenb> i'm kind of sad you can't make arbitrary expressions infix with ``
11:06:33 <mjrosenb> but on the other hand
11:06:34 <chrisdotcode_> a partially applied infix function is called a section, right?
11:06:36 <mjrosenb> that would be insane.
11:06:48 <applicative> absence: no, the same happens if I read count 3 as Maybe [Int]
11:07:20 <chrisdotcode_> supki: is that an implementation detail, or is that just true for lambdabot
11:07:40 <chrisdotcode_> ?
11:07:55 <applicative> it cant get to the constructor, Just ... since who knows one of the count n's maybe Nothing
11:08:09 <SideEffffECt> mjrosenb: ok, I'll try there, thanks
11:08:15 <supki> chrisdotcode_: it's ghc implementation detail
11:08:29 <applicative> > liftM2 (:) (Just 3) Nothing
11:08:31 <lambdabot>   Nothing
11:08:45 <absence> applicative: hmm, works with Identity
11:08:49 <chrisdotcode_> supki: that's kind of unfortunate... tuples with only 62 elements?
11:09:00 <supki> huh?
11:09:04 <mjrosenb> bytemask :: (Bits a) => a
11:09:07 <mjrosenb> bytemask = 255
11:09:12 <applicative> yes i knows the constructor -- its a newtype anyway
11:09:16 <mjrosenb> why does that not work?
11:09:34 <mjrosenb> > bytemask :: (Bits a) => a; bytemask = 255
11:09:34 <absence> applicative: but yeah, not Maybe :s
11:09:35 <lambdabot>   <hint>:1:26: parse error on input `;'
11:09:45 <applicative> is there a Num constraint of Bits
11:09:47 <magicman> mjrosenb: Num is no longer a superclass of Bits
11:09:59 <mjrosenb> ugh
11:10:09 <mjrosenb> so HashedStorage is just doa on ppc
11:10:38 <absence> applicative: oh right, it's Maybe [Int], not [Maybe Int], so it needs to evaluate the whole list to see if there's a Nothing
11:12:09 <applicative> absence: yes that was my thought
11:13:45 <mjrosenb> does hashed-storage have a bugtracker?
11:14:03 <mjrosenb> I don't see on the hackage page for it.
11:19:31 <applicative> mjrosenb: the solution is clear compile for #ifdef LITTLEENDIAN
11:19:46 <applicative> mjrosenb: it doesn't use a numeric literal ;)
11:21:39 <mjrosenb> applicative: i'll let you know how that goes.
11:23:24 <applicative> is that a variable ghc is getting from your os I wonder
11:24:00 <daedalus> I'm trying to create my own version of a function that finds the nth element of a string, my code is the following: nth [] _ = "error, list too short" nth xs 1 = head xs nth (x:xs) k = nth xs (k-1)
11:24:57 <daedalus> I'm trying to create my own version of a function that finds the nth element of a string, my code is the following: nth [] _ = "error, list too short" nth xs 1 = head xs nth (x:xs) k = nth xs (k-1)
11:25:39 <yogert> quick question: Im using parsec to parse a grammar and part of this grammar has been specified in regexp. . . Using parsec, how would I match the following: "[^\0-\237]"?
11:25:49 <daedalus> it compiles, but doesn't actually work when running
11:27:11 <yogert> or, put more simply, how can i generate a string of escaped character from 0 to 237?
11:27:12 <bz> what's the recommended way of obtaining the latest haskell?
11:27:37 <applicative> bz: the new haskell platform is new;
11:28:04 <geekosaur> yogert, if that's the right regex, the ^ means you want a character *not* in the range 0 - 237 (octal?)
11:28:06 <applicative> bz you can install the latest released ghc in a bindist thingy from the ghc site
11:28:34 <yogert> geekosaur: yeah. I was gonna try noneOf string
11:28:35 <applicative> bz what operating system are you going to install on?
11:28:36 <bz> applicative: those binaries require libgmp.so.3, which isn't available
11:28:45 <applicative> oooh
11:28:47 <bz> applicative: debian something recent
11:28:57 <bz> applicative: and apparently compiling from source requires haskell already
11:28:58 <yogert> but Im not sure how to generate such a string
11:29:07 <geekosaur> > ['\0' .. '\159']
11:29:08 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
11:29:14 <yogert> ooo
11:29:35 <yogert> huh, I wouldn't have guessed that would work
11:31:01 <yogert> thanks!
11:33:20 <applicative> bz theres not a version of something like this> http://packages.debian.org/sid/libgmp3c2
11:34:09 <bz> applicative: not for x86-64, no
11:35:27 <Clint> there is; it's just ancient
11:35:49 <applicative> bz, dunno, maybe brazenly ask on #ghc ?
11:36:17 <applicative> oh Clint knows about it
11:36:30 <Clint> bz: what are you on and what do you want?
11:38:14 <bz> Clint: on some recent debian and want the latest ghc (7.6.3?)
11:39:05 <Clint> bz: put unstable in your sources.list, pin to whatever release you actually want, then apt-get install ghc/unstable
11:47:07 <Rarrikins> Is there a StringLike class in cabal or the standard library that can be used outside of TagSoup?
11:47:46 <johnw> Rarrikins: I think there are even several
11:47:54 <byorgey> @package ListLike
11:47:54 <lambdabot> http://hackage.haskell.org/package/ListLike
11:48:04 <byorgey> is one
11:48:15 <applicative> do you really want it Rarrikins ?  there might be more rational solutuions
11:48:28 * hackagebot llvm-general 3.2.0.4 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.0.4 (BenjaminScarlet)
11:50:51 <Rarrikins> Well, I'm trying to convert to ByteString internally and convert to String for show and so on, and I also want to take as arguments anything that's commonly used to hold text.
11:50:59 <johnw> @package stringable
11:50:59 <lambdabot> http://hackage.haskell.org/package/stringable
11:51:02 <johnw> I wrote stringable for that use case
11:51:05 <Rarrikins> Ahh, thanks :)
11:51:16 <applicative> hm, instance StringLike (V.Vector Char) where fromString, toString , unwords unlines ...
11:51:34 <johnw> byorgey: do you recommend ListLike?
11:52:08 <byorgey> johnw: I neither recommend nor disrecommend it, having never used it or anything like it
11:52:13 <applicative> there are also classes in the lens package Rarrikans, e.g. a ByteString class with String etc members, if I remember
11:52:26 <osa1> do `data Fix f = Fix (f (Fix f))` and `fix f = let x = f x in x` have anything in common?
11:53:00 <johnw> osa1: I believe it's that one models recursive types, the other models recursive functions
11:53:28 * hackagebot llvm-general 3.3.0.2 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.0.2 (BenjaminScarlet)
11:53:52 <osa1> how are recursive types useful?
11:54:07 <johnw> osa1: trees, lists, ASTs, etc.
11:54:27 <osa1> johnw: I'm using that structures all the time, none of them has recursive type
11:54:49 <johnw> data List a = Leaf a | Cons a (List a)
11:54:53 <johnw> lists are recursive
11:55:16 <osa1> hm
11:55:43 <osa1> johnw: so can we define that same List type using Fix ?
11:55:50 <johnw> osa1: try this: https://github.com/willtim/recursion-schemes/raw/master/slides-final.pdf
11:56:22 <johnw> there are actually several papers and presentations about using least fixed points of functors to abstract recursion patterns
11:56:37 <byorgey> osa1: any recursive type can be defined using Fix.
11:57:07 <johnw> the idea is that you write your code in terms of the prototypical case, and then use Fix to "recursify it", so to speak
11:57:13 <byorgey> data ListF a l = Leaf a | Cons a l;   type List a = Fix (LeafF a)
11:57:27 <johnw> byorgey: ListF
11:57:28 <osa1> byorgey: johnw: I thought List a is not recursive because it's not something like List a (List a (List a ...))
11:57:31 <byorgey> er, s/LeafF/ListF/
11:57:40 <dolio> Except the fancy ones.
11:57:43 <johnw> osa1: Cons a (Cons a (Const a (Leaf a)))
11:57:51 <dolio> All the regular types.
11:57:55 <byorgey> osa1: List is recursive because List shows up on both the left and right-hand sides of the definition.
11:57:57 <johnw> since you can have any number of Cons', it's recursive
11:58:05 <johnw> yeah, what byorgey said
11:58:06 <byorgey> osa1:   data List a = Leaf a | Cons a ***(List a)***
11:58:21 <byorgey> osa1: just like a function is recursive when it is called in its own definition.
11:58:39 <osa1> ok, so what's a type like List a (List a (List a ...)) called?
11:58:56 <johnw> osa1: the type is just List a
11:58:58 <applicative> a list of lists of lists
11:59:25 <applicative> Cons a (Cons b (Cons c ...)))) would just be a list of something
12:00:14 <applicative> List a is basically PreList a (PreList a (Prelist a (....
12:00:20 <Moggle_> Is there a version of fmap that applies to all elements of a tuple?
12:00:21 <applicative> or ListF as byorgey called it
12:00:26 <Moggle_> Because this is kind of annoying:
12:00:29 <applicative> Moggle_: well it's not fmap
12:00:33 <Moggle_> > fmap (+2) (5, 12)
12:00:48 <lambdabot>   mueval-core: Time limit exceeded
12:00:55 <byorgey> Moggle_: what would be the type?  fmap :: (a -> b) -> (?, ?) -> (?, ?) ?
12:01:07 <Moggle_> byorgey: something that works on (a, a)
12:01:13 <byorgey> Moggle_: right.
12:01:15 <byorgey> Moggle_: but fmap must be defined for *all* types
12:01:17 <applicative> make a type D a = D a a ...
12:01:27 <Moggle_> byorgey: yes, this is why i was asking for a version of fmap not fmap itself :P
12:01:32 <Rarrikins> Moggle_: It wouldn't be too hard to generate some code for that.
12:01:35 <byorgey> Moggle_: ok, fair eonugh =)
12:01:53 <byorgey> Moggle_: you can either (1) make a type   data Pair a = Pair a a   and make a Functor instance for it
12:02:04 <Moggle_> Rarrikins: this is true, i was just wondering if there was a function in prelude
12:02:18 <byorgey> Moggle_: or (2) you can use the fact that (,) is a bifunctor: http://hackage.haskell.org/packages/archive/bifunctors/3.2.0.1/doc/html/Data-Bifunctor.html
12:02:24 <supki> Moggle_: over each  (from lens) would work for tuples up to 9
12:02:25 <applicative> lens has one for pairs (a,a), both i think
12:02:36 <byorgey> Moggle_: or (3) you can use  (***) from Control.Arrow like    f *** f
12:02:38 <Moggle_> what problem doesn't lens solve? :D
12:02:47 <Moggle_> i'll look into lenses and bifunctors
12:02:49 <supki> yes, both is degenerate version of each
12:02:49 <byorgey> or (4) you can use 'both' from lens, as applicative mentioned
12:02:50 <Moggle_> oh god so many options
12:02:58 <osa1> I always thought `data List a = Nil | Cons a (Lista)` is a recursive data type, but it's type is not recursive. but then what would be a recursive type??
12:03:06 <Moggle_> thanks for the help everyone!
12:03:29 <byorgey> osa1: it is a recursive data type.
12:03:37 <byorgey> I don't know what you mean by "its type is not recursive".
12:04:03 <Rarrikins> What are the types that require newtype or something like that?
12:04:19 <c_wraith> infinite types?
12:04:35 <byorgey> recursive types.
12:04:45 <c_wraith> They require some sort of structure to break up the infinite part.
12:04:47 <byorgey> you may be specifically thinking of the error message GHC has about infinite types.
12:05:01 <c_wraith> Not all recursive types are infinite, though
12:05:19 <byorgey> but all recursive types require data or newtype.
12:05:22 <applicative> > (2,4) & both %~ (+3)
12:05:22 <c_wraith> yes
12:05:23 <lambdabot>   Not in scope: `both'Not in scope: `&'Not in scope: `%~'
12:05:23 <lambdabot>  Perhaps you meant ...
12:05:34 <applicative> :(
12:05:47 <c_wraith> lenslessbot
12:07:31 <applicative> @type even *** even
12:07:33 <lambdabot> (Integral a, Integral a1) => (a, a1) -> (Bool, Bool)
12:07:46 <applicative> @type join (***)
12:07:47 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
12:08:08 <applicative> > join (***) (+3) (2,3)
12:08:09 <lambdabot>   (5,6)
12:09:23 <banister`sleep> how do i get the value out of a Just ?
12:09:52 <Dinh> fromJust
12:10:29 <Dinh> or pattern match, e.g. Just x = foo
12:11:15 <c_wraith> : maybe id (error "you lied! it wasn't Just at all!") (Just 5)
12:11:19 <c_wraith> > maybe id (error "you lied! it wasn't Just at all!") (Just 5)
12:11:20 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
12:11:20 <lambdabot>    arising from a use ...
12:11:27 <c_wraith> ... what?
12:11:43 <c_wraith> I really hope that was a transient error
12:11:45 <c_wraith> > maybe id (error "you lied! it wasn't Just at all!") (Just 5)
12:11:46 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
12:11:46 <lambdabot>    arising from a use ...
12:11:55 <banister`sleep> Dinh: fromJust doesn't appaer to exist in ghci prelude
12:12:03 <c_wraith> nope.  Huh.  Where's the typeable constraint coming from?
12:12:24 <acube>  > maybe (error "you lied! it wasn't Just at all!") id (Just 5)
12:12:36 <acube> > maybe (error "you lied! it wasn't Just at all!") id (Just 5)
12:12:37 <lambdabot>   5
12:12:47 <c_wraith> well now I'm extra confused
12:12:48 <acube> :t maybe
12:12:49 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:12:58 <acube> :t error
12:12:59 <lambdabot> [Char] -> a
12:13:05 <acube> Eh, typeable? :O
12:13:08 <c_wraith> :t id
12:13:08 <lambdabot> a -> a
12:13:17 <c_wraith> It has to have been coming from Hint
12:13:19 <c_wraith> interesting
12:13:43 <acube> Maybe it wants to make the a of error to be a function
12:13:54 <c_wraith> I haven't seen hint errors leak into lambdabot output before
12:14:21 <c_wraith> Did mueval change recently?
12:14:28 <byorgey> banister`sleep: you have to import fromJust from Data.Maybe.  But you probably shouldn't use it.
12:14:32 <byorgey> > fromJust Nothing
12:14:34 <lambdabot>   *Exception: Maybe.fromJust: Nothing
12:14:54 <banister`sleep> byorgey: hmm, so what's an idiomatic way to get the value out of a Just ?
12:15:09 <byorgey> banister`sleep: how do you know that you have a Just and not Nothing?
12:15:30 <b2coutts> :t fromJust
12:15:32 <lambdabot> Maybe a -> a
12:15:37 <byorgey> lies!
12:15:42 <banister`sleep> byorgey: im just playing in ghci, and just curious how i can get the value out of a Just ;)
12:15:47 <b2coutts> :t isJust
12:15:48 <lambdabot> Maybe a -> Bool
12:15:48 <banister`sleep> byorgey: but what's the idiomatic way to do it?
12:15:59 <c_wraith> the idiomatic way is a case statement
12:16:07 <c_wraith> or the maybe function, which is equivalent
12:16:16 <byorgey> banister`sleep: then the idiomatic way is to use fromJust.  But the idiomatic thing is to pattern-match on a value of type Maybe a, and do one thing in case it is Nothing and another in case it is Just.
12:16:29 <b2coutts> banister`sleep: I'm not sure what's idiomatic, I tend to have `isJust thing' in a pattern guard, leading to a `fromJust thing'
12:16:44 <c_wraith> err.  case *expression*
12:16:54 <byorgey> b2coutts: the idiomatic thing in that case would be to pattern-match on the Just instead of calling 'isJust' and then 'fromJust'
12:16:57 <c_wraith> b2coutts: that's exactly what't not idiomatic
12:17:19 <b2coutts> oh, I suppose that probably makes more sense
12:17:20 <byorgey> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
12:17:39 <banister`sleep> thx guys
12:17:59 <c_wraith> b2coutts: regardless of the semantic issues, it does the work twice! Determining what constructor is being used and extracting the arguments from it are the same operation
12:18:45 <b2coutts> I'm not sure how I feel about doing all checking in pattern matches
12:18:58 <b2coutts> it gets ugly if you have a long pattern, and need to retype it each time, and wrap to 80 characters
12:19:15 <c_wraith> If you need to retype it every time, you're probably doing something wrong.
12:19:42 <b2coutts> well, if you have a function that takes 3 arguments, each of which you're matching structurally
12:19:54 <b2coutts> the pattern gets fairly long
12:20:03 <Cale> b2coutts: Well, you're saving yourself three isJust/fromJust pairs...
12:20:08 <byorgey> b2coutts: you can then split it into two functions, one which does the common part of the pattern-matching, and the other which does the rest
12:20:11 <b2coutts> and if you had a maybe as one of the things in the pattern, you'd have to have the pattern twice, wouldn't you?
12:20:25 <c_wraith> b2coutts: but either you have different cases for each set of patterns, or you're doing things the hard way
12:20:44 <Cale> b2coutts: While there might be 8 different cases, say, usually there are many fewer than that.
12:22:14 <b2coutts> I mean, if you have one Maybe in these arguments, it's more concise to have a single pattern, and the simple line `  | isNothing m = error "maybe was nothing!"', than to write the entire pattern just for that case
12:22:21 <b2coutts> (same goes for booleans in the pattern)
12:23:05 <b2coutts> imo pattern matching is a thing that makes code better when used appropriately, not universally
12:23:37 <byorgey> I don't agree.  But I would have to see a specific example to suggest a better way.
12:23:45 <c_wraith> b2coutts: the thing is, what you're saying to do is exactly the same thing pattern matching does - except slower and more error-prone
12:24:35 <b2coutts> c_wraith: I mean, it's the same in terms of what it does
12:24:45 <b2coutts> but I'd argue it's better (in some cases) for readability
12:24:56 <c_wraith> I've never seen such a case.
12:25:05 <c_wraith> Though I have seen some cases where pattern guards make sense.
12:25:22 <c_wraith> But those are almost all when you're applying functions to the arguments.
12:35:54 <acowley> Has anyone else ever wished that an unused binding in do-notation could be used by the type checker to infer a ()? It's an awfully picky thing, but I'd find it useful.
12:37:07 <Cale> acowley: Could you give an example?
12:37:42 <acowley> Cale: I have a printf-like construction, and if the type checker can't figure out what I'm pulling out of the monad then it won't type check.
12:38:09 <acowley> Cale: In do notation, I'd like a sequence of these operations that do not bind their results to be inferred as returning m ()
12:38:24 <sellout-> acowley: Maybe I‚Äôm misunderstanding, but why not remove the binding?
12:38:42 <acowley> sellout-> If there is no binding, then the inferred type is m a
12:39:10 <acowley> So, say I have a block "do {fun1; fun2; fun3}"
12:39:29 <acowley> fun1 and fun2 are being used just for their side effects, and fun3's return type is usually inferable from context
12:39:47 <acowley> I end up having to write "do { () <- fun1; () <- fun2; fun3}"
12:40:16 <acowley> I know it's a peculiar use, which is why I'm curious if anyone else has run into such a situation‚Ä¶ in which case maybe it's not that peculiar!
12:40:23 <Cale> acowley: Perhaps you want ExtendedDefaultRules?
12:40:53 <acowley> Cale: That sounds promising
12:41:44 <Cale> I actually really dislike your concrete proposal though. It should be possible to ignore the result of an IO action that produces something.
12:42:10 <Cale> (there's a warning which agrees with you though)
12:42:53 <osa1> how can I implement functor instance of List here: http://hpaste.org/90417 ?
12:43:01 <acowley> Cale: Yeah it's the warning which encouraged me to ask.
12:43:26 <acowley> Cale: I figure my case is a logical extension of the thinking behind the warning
12:44:39 <acowley> I am failing to find more information on ExtendedDefaultRules for a recent GHC
12:46:32 <byorgey> osa1: you could make one but then it would overlap with Functor instances for other things constructed with Fix.
12:47:00 <byorgey> osa1: you might like to try implementing a Bifunctor instance for ListF, and then a generic instance Bifunctor f => Functor (Fix (f a))
12:47:21 <byorgey> using http://hackage.haskell.org/packages/archive/bifunctors/3.2.0.1/doc/html/Data-Bifunctor.html
12:48:11 <osa1> "bifunctor from Hask -> Hask. " omg more category theory stuff ;-(
12:48:56 <osa1> byorgey: I'm just experimenting here, how could I make it a functor instance?
12:49:04 <osa1> I mean List in my link
12:49:16 <byorgey> osa1: instance Functor (Fix (ListF a)) where ...
12:49:23 <byorgey> you mean you need help writing the ... part?
12:49:43 <osa1> yes, but let me paste my try first
12:49:44 <Cale> acowley: That is odd... it used to be documented, and it still appears in the --supported-languages list
12:49:53 <Cale> acowley: But I don't see it in the GHC documentation either.
12:50:30 <Ralith> so, GHC is giving me a very strange error:
12:50:31 <Ralith> http://sprunge.us/PBTA
12:50:53 <Ralith> in short, it's saying that a certain symbol is not in scope, and suggesting that I might mean that same symbol instead.
12:50:55 <osa1> byorgey: it's a kind-mismatch?
12:50:58 <acowley> Cale: The link to http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal-1.16.0/Language-Haskell-Extension.html shows the definition, but very little description
12:51:05 <Ralith> also the error message is slightly malformed (missing ` on line 3)
12:51:10 <byorgey> osa1: ohhhh, right, sorry
12:51:20 <Ralith> what could I possibly be doing to cause that?
12:51:22 <byorgey> osa1: you have to make it a newtype
12:51:29 <osa1> why?
12:51:53 <asymble> Hello. Will there ever be a Haskell binding to Wayland?
12:51:59 <byorgey> osa1: because (for various technical reasons) Haskell does not permit type synonyms which are not fully applied
12:52:02 <asymble> or GTK+3 for that matter?
12:52:08 <byorgey> osa1: so if you have  type List a = ...   you cannot just write  'List' by itself
12:52:17 <asymble> or even just cairo on top of a wayland surface
12:52:18 <geekosaur> the gtk2hs folks are working on gtk3 bindings
12:52:23 <byorgey> osa1: and you would need to say   instance Functor List where ...  but that is not allowed
12:52:38 <geekosaur> as for wayland, I think the only thing that can be said currently is "contributions gladly accepted"
12:53:27 <asymble> hmm...hmmm...well, I guess I need to learn ruby first
12:53:50 <asymble> I don't know how to program and I've never written a line of code, except for the simplest hello world stuff
12:54:13 <asymble> maybe I need to learn math first
12:55:09 <orzo> is there a way to generate a dead or invalid ThreadId I can safely pass to threadStatus ?
12:55:25 <byorgey> asymble: why would you need to learn ruby first?
12:55:26 <osa1> byorgey: this is where I stuck http://hpaste.org/90418
12:55:53 <orzo> apart from spawing a thread and waiting for it to die
12:56:38 <bz> how do i get the cabal binary to work after building 7.6.3 from source?
12:57:26 <Cale> Does anyone actually use Wayland yet?
12:57:56 <byorgey> osa1: the problem is the final 'fmap' which is over something of type  Fix (ListF a),  but there is no Functor instance for that
12:58:14 <klrr> Cale: what's wrong with X11?
12:58:16 <byorgey> osa1: one solution would be to first write  mapFixList :: (a -> b) -> Fix (ListF a) -> Fix (ListF b)
12:58:22 <Cale> klrr: beats me
12:58:31 <byorgey> osa1: then use mapFixList to trivially implement the Functor instance for List
12:58:33 <Cale> bz: If you don't have cabal-install on your system at all yet, just grab the tarball from Hackage and run bootstrap.sh from that
12:58:57 <Cale> bz: Otherwise, it should just work, and if you want, you can update cabal using cabal install cabal-install
12:59:03 <byorgey> osa1: the point is that  Fix (ListF a)  *is* a functor, we just can't make it an instance of Functor because of restrictions in Haskell's type system
12:59:59 <Cale> asymble: anyway, I don't think you should have to worry about Wayland support just yet :P
13:00:25 <Cale> asymble: If the project you want to write really requires it, you can always write the FFI imports yourself.
13:00:51 <osa1> byorgey: hmm .. my point of doing all this is to understand fix better. we can easily define functor instance for some simple recursive types, but when implemented in terms of Fix, it's much harder ..
13:01:26 <byorgey> osa1: I wouldn't say it's *much* harder.  You just have to struggle with Haskell's type system a bit.
13:01:41 <byorgey> osa1: in any case, making Functor easier to implement is not the reason for using Fix.
13:02:11 <osa1> byorgey: what is the reason for using Fix ?
13:03:17 <byorgey> osa1: (1) it makes it possible to generically implement a fold operation once and for all (instead of reimplementing it for each recurisve type).  (2) It makes it possible to "mix in" other features on top of the base functor before tying the knot with Fix, e.g. adding annotations to every node
13:03:49 <byorgey> abstractly, it also helps us understand the fundamental nature of recursion
13:03:57 <osa1> byorgey: second point is related with Free ?
13:04:08 <byorgey> which is a good enough reason for trying to understand it even if you never end up using it in anger.
13:04:51 <byorgey> osa1: yes, it is certainly related.  Off the top of my head I'm not sure exactly what the relationship is.
13:07:18 <osa1> byorgey: would a Functor (ListF a) instace be useful?
13:08:03 <byorgey> osa1: yes, definitely. Though note it is not useful for implementing the Functor List  instance.
13:08:33 <byorgey> Functor (ListF a)  is what lets you implement a generic fold for List.
13:08:55 <byorgey> that is, you should try writing something of type   fold :: Functor f => (f a -> a) -> Fix f -> a
13:09:25 <byorgey> (that function is also often called 'cata' instead of 'fold')
13:09:46 <osa1> byorgey: this fold is different that foldl/foldr, right?
13:09:53 <byorgey> osa1: it is the same as foldr
13:09:58 <osa1> oh
13:10:02 <byorgey> foldl is something entirely different.
13:10:08 <byorgey> because lists are special.
13:10:23 <shachaf> Because foldr is special.
13:10:30 <osa1> foldr and foldl is different?
13:10:52 <trace30m> how r objects called in haskell?
13:10:59 <byorgey> I mean lists have a foldl because they are special.  Most other recursive types have something that corresponds to foldr but not to foldl.
13:11:19 <osa1> byorgey: what special property of lists allows foldl?
13:11:27 <shachaf> Almost every simple data structure type has foldr and foldl in Data.Foldable. :-)
13:11:38 <byorgey> shachaf: those are different!
13:11:46 <byorgey> argh
13:11:48 <shachaf> byorgey: Not for lists!
13:11:52 <byorgey> I know =)
13:11:53 <shachaf> OK, fine, it's lists that are special.
13:12:02 <byorgey> trace30m: values.
13:12:15 <roconnor> trace30m: comonads
13:12:21 <byorgey> hehe
13:12:30 <shachaf> osa1: foldr and lists have a special relationship because foldr (:) [] xs = xs
13:12:43 <byorgey> shachaf++
13:12:46 <byorgey> that's a good way to explain it.
13:14:44 <osa1> byorgey: I think `f a -> a` in first parameter of `cata` is called `unfold`, right?
13:14:54 <trace30m> roconnor: or simply monad?
13:15:02 <roconnor> trace30m: nope
13:15:07 <byorgey> osa1: no, it is called an "algebra"
13:15:30 <byorgey> osa1: unfold is dual to fold, it has type   unfold :: (a -> f a) -> a -> Fix f
13:15:35 <byorgey> osa1: you might like to try implementing that one too
13:15:51 <osa1> byorgey: is that have another name too? like fold ~ cata
13:15:59 <byorgey> osa1: yes, 'ana'
13:16:19 <byorgey> of course  cata and ana are short for 'catamorphism' and 'anamorphism'
13:17:06 <roconnor> trace30m: I've been answering in jest.  The real answer is that Haskell doesn't have objects a la OOP.  There is some cutting edge research that suggests that maybe comonads might let you have something vaguely resembling OOP in Haskell.
13:17:31 <trace30m> roconnor: ^^
13:17:47 <bz> caba upd
13:17:50 <Peaker> but just manually implementing OOP is not too bad
13:17:52 <osa1> byorgey: thanks very much. now I'll go try implement ana/cata. can anyone recommend me some resources to learn more about stuff I've been asking?
13:17:54 <bz> Cale: thanks, also
13:18:23 <shachaf> @google type-level fix and generic folds
13:18:24 <lambdabot> http://mainisusuallyafunction.blogspot.com/2010/12/type-level-fix-and-generic-folds.html
13:18:25 <lambdabot> Title: main is usually a function: Type-level Fix and generic folds
13:18:27 <shachaf> That has a bit.
13:18:36 <osa1> thanks
13:18:49 <Peaker> The common OOP theme of records of functions is trivial.. the hard part is the inheritance with 2-way calling between base and subclass, which I never found too useful, but even if you need that, you can do it with manual recursion not too difficultly
13:18:50 <shachaf> (It also has spoilers so watch out.)
13:19:21 <byorgey> osa1: http://www.cs.ox.ac.uk/jeremy.gibbons/publications/acmmpc-calcfp.pdf  goes into quite a bit of depth but it's well done and not too hard to follow (IMO)
13:19:22 <osa1> yeah I won't read it before implementing ana/Cata
13:19:23 <osa1> thanks
13:19:32 <johnw> shachaf: do you think there'd be any merit to adding (>>>>) :: p a b -> p b c -> p a c to the Profunctor type class?  (and likewise, <<<<)
13:19:53 <johnw> right now, you can't generically combine two profunctors into a bigger one, to my knowledge
13:20:12 <roconnor> johnw: I've seen that operation somewhere
13:20:22 <shachaf> johnw: If you wanted to make it not be Profunctor anymore, sure.
13:20:23 <roconnor> johnw: I think profunctor-extras or something like that
13:20:34 <roconnor> johnw: it requires existential types and whatnot
13:20:51 <johnw> ah, Procompose
13:20:54 <johnw> thanks, roconnor
13:21:17 <johnw> shachaf: how does that violate Profunctorality?
13:21:55 <dolio> Why do you think all profunctors have that operation?
13:22:06 <johnw> I suppose that's a fair question
13:22:14 <byorgey> johnw: it's just that the profunctor abstraction does not require a notion of composition
13:22:19 <shachaf> Why not add return and join to Functor while we're at it?
13:22:38 <shachaf> It's just unrelated to the class.
13:22:49 <johnw> byorgey: thanks
13:26:21 <shachaf> I wonder whether ByteString's Show instance should be more like [Word8]'s and less like String's.
13:26:46 <Ralith> I'd go for a hexadecimal string, myself
13:26:48 <Peaker> Maybe a hexdump?
13:26:52 <johnw> yeah, me too
13:27:19 <ciferkey> What library(s) should I look at to take a timestamp in one timezone and get a datatime in my (different) timezone?
13:27:28 <byorgey> ciferkey: time
13:27:30 <shachaf> Ralith: I don't want the ""s because they mislead people into thinking it's a String.
13:27:46 <shachaf> Hexadecimal in general sounds good.
13:27:46 <Ralith> shachaf: not a literal String :P
13:27:50 <byorgey> ciferkey: unfortunately it can be a bit difficult to figure out how to use
13:27:57 <Ralith> wrap it in <> or something
13:28:44 <Peaker> people are repeatedly asking: "Which string type to use?  ByteString or Text?"   I think the difference is documented and reiterated so much it's weird so many still miss it.  Maybe s/ByteString/ByteBuffer or such
13:29:35 <Peaker> I wonder if instead of Text.Lazy and ByteString.Lazy, some sort of abstraction over both can be shared
13:29:38 <ciferkey> byorgey: thanks I'll look into it
13:29:46 <roconnor> ciferkey: either time or timezone-series/timezone-olson
13:29:48 <Peaker> perhaps pipes/conduit is that
13:30:55 <roconnor> ciferkey: by timezone do you mean specific offset from UTC, or a zone that may encounter DST?
13:31:24 <roconnor> ciferkey: time can handle the first but cannot handle the second in full generality.
13:33:06 <ciferkey> roconnor: I have timestamps like 1372131148 that are IST and I would like to use them as EST dates‚Ä¶ so would that be both then?
13:33:45 <banister`sleep> roconnor:  can u teach me about monads
13:34:52 <johnw> banister`sleep: you should ask your question of the group
13:35:00 <banister`sleep> sorry :)
13:35:06 <banister`sleep> can you guys teach me about monads?
13:35:08 <hiptobecubic> Ooo, a monad discussion!
13:35:14 <Tene> johnw: Should I also ask my questions of the group in general?
13:35:17 <roconnor> ciferkey: if you only want to convert from IST, then time can do what you want, but only because India doesn't observer DST.
13:35:23 <johnw> Tene: everyone should ask their questions of the group!
13:35:45 <johnw> Tene: I see what you did there
13:35:45 <Tene> ;)
13:35:58 <banister`sleep> Imagine someone just knows OO programming in say ruby or python, how would monads help him in his day to day and more importantly, what are they? :)
13:35:58 <hiptobecubic> banister`sleep, the general consensus is mostly "no". We can just tell what they are at face value and then you have to go use them until you realize that emperor had no clothes all along.
13:36:54 <byorgey> banister`sleep: do you already know about Functors?
13:36:58 <banister`sleep> byorgey: i read a part of LYAH that described a functor as an object that can be mapped over, is that right?
13:37:07 <roconnor> ciferkey: unless you mean isreal standard time, in which case time won't cut it in general because isreal does observe DST.
13:37:07 <hiptobecubic> banister`sleep, it's an interface that various types can be made an instance of that obeys the monad laws.
13:37:13 <byorgey> banister`sleep: right.
13:37:15 <johnw> what is a "skolem" type variable?
13:37:18 <hiptobecubic> banister`sleep, you should continue reading lyah until it gets to monads them.
13:37:20 <hiptobecubic> then*
13:37:51 <c_wraith> johnw: the kind you don't want to escape.  Err, wait, those are golem type variables.  eh, more or less the same thing.
13:38:09 <c_wraith> johnw: more usefully, they're artificial type variables introduced by the type checking process.
13:38:14 <johnw> am I going to have to steal a ring from this thing to get out of the type error?
13:38:48 <c_wraith> johnw: if you're getting an error about a skolem escaping, it generally means you're returning a value of a type that's been existentially quantified somehow
13:38:49 <byorgey> johnw: when you are typechecking under an existential quantifier, you make up a new variable for it which doesn't unify with anything else.  That is a skolem variable.
13:38:52 <roconnor> johnw: -fglasgow-exts ?
13:39:06 <johnw> I just need a type signature on my "where" function
13:39:08 <roconnor> oh right
13:39:21 <johnw> byorgey: thanks!  that's exactly what's happening
13:39:36 <byorgey> named for https://en.wikipedia.org/wiki/Thoralf_Skolem.  See also http://planetmath.org/skolemization .
13:41:48 <osa1> byorgey: do I need any helper definitions or can I write fold :: Functor f => (f a -> a) -> Fix f -> a with knowing only data Fix f = Fix (f (Fix f)) definition?
13:42:15 <byorgey> osa1: you will probably want a helper function  unFix :: Fix f -> f (Fix f)
13:42:43 <byorgey> but that's all you need
13:42:50 <byorgey> follow the types! =)
13:42:56 <osa1> byorgey: unFix (Fix a) = a ?
13:43:08 <byorgey> right =)
13:43:17 <osa1> ok so that should be used with fmap, I think
13:46:45 <jfischoff> does anyone know a good way to get better stacktrace from a CAF?
13:55:29 <b52> whats the difference between rem and mod?
13:57:01 <Cale> b52: The convention regarding negative values.
13:57:12 <Cale> > (-2) `rem` 5
13:57:13 <lambdabot>   -2
13:57:19 <Cale> > (-2) `mod` 5
13:57:20 <lambdabot>   3
13:57:51 <Breadmonster> Okay, I'm getting four really odd errors in my code.
13:57:57 <Cale> b52: You almost always really want mod, but rem is ever-so-slightly cheaper to implement in hardware.
13:58:08 <byorgey> Breadmonster: congratulations!
13:58:13 <thetallguy2> question from a student:  how do you pronounce the <- in do syntax?
13:58:29 <byorgey> thetallguy2: you don't.  But if you must, you can say "bind"
13:58:29 <Cale> thetallguy2: "is the result of executing"?
13:58:30 <thetallguy2> for example, do x <- foo
13:58:32 <Breadmonster> byorgey, could you give me a hand?
13:58:46 <srhb> dnib seems more logical.
13:58:54 <srhb> I vote we name it dnib for Haskell 2014.
13:58:55 <thetallguy2> byorgey: Indeed, I don't, that's why I'm asking you guys who teach...
13:58:55 <Cale> or "comes from"
13:59:05 <byorgey> Breadmonster: at this point I have insufficient information to know whether I can give you a hand.
13:59:16 <thetallguy2> Cale: I like that, thanks
13:59:18 <Cale> thetallguy2: It's just an arrow, you don't really pronounce it
13:59:24 <byorgey> Breadmonster: why don't you paste your code along with the error messages on hpaste.org, and if someone can give you a hand, they will?
13:59:30 <Breadmonster> http://hpaste.org/90420
14:00:23 <Cale> Breadmonster: what are the errors?
14:00:30 <Breadmonster> http://hpaste.org/90421
14:00:34 <Breadmonster> Those are the errors.
14:00:54 <Breadmonster> It's a Scheme interpreter.
14:01:14 <Breadmonster> Three of them are errors with helixLet, which I can't seem to fix.
14:01:16 <byorgey> Breadmonster: the first error is because you are missing an argument to 'parse'.
14:01:28 <Breadmonster> byorgey: Oh, okay, fine thank you.
14:01:35 <Breadmonster> Now I feel really stupid...
14:02:23 <byorgey> don't, it's counterproductive =)
14:02:27 <byorgey> also, you aren't.
14:02:27 <Breadmonster> Alright.
14:02:32 <Breadmonster> Fine.
14:02:38 <Breadmonster> What about the other three?
14:03:02 <byorgey> Breadmonster: have you already tried carefully reading and understanding the error messages?
14:03:05 <Breadmonster> Okay, this is good.
14:03:47 <byorgey> they already give you a lot of information.  For example, the first one tells you that 'es' has type (Environment, [HelixObject]), but you are passing it to a function which expects  EvalType.
14:03:55 <PwnyCode_> is this a gay channel im looking for horny guys and girls with vane dick bb
14:03:56 <Cale> Breadmonster: display :: EvalType -> EvalType, and es :: EvalList
14:04:01 --- mode: ChanServ set +o Cale
14:04:04 --- mode: Cale set +b *!*@109.255.44.234
14:04:05 --- kick: PwnyCode_ was kicked by Cale (PwnyCode_)
14:04:07 --- mode: Cale set -o Cale
14:04:34 <Breadmonster> Cale, okay, fine I got that.
14:04:35 <Breadmonster> Thank you.
14:05:05 <Breadmonster> byorgey: Resolved the first two, it's the other two that are worrying me.
14:05:13 <Breadmonster> Wait, let me have a look at it again.
14:05:33 <Breadmonster> btw, in the meanwhile, can someone explain to me why parse would have another argument?
14:05:47 <Breadmonster> I just looked it up and passed it []
14:06:08 <byorgey> Breadmonster: yes, "" or []  is fine
14:06:24 <Breadmonster> byorgey, but what does that parameter do?
14:06:28 <byorgey> Breadmonster: the purpose of that argument is to give it the name of the file that is being parsed (if any)
14:06:35 <byorgey> so that it can give better error messages if the parse fails
14:06:38 <Breadmonster> Oh, right.
14:06:51 <Cale> Breadmonster: ds must be a list, because you're foldl'ing over it
14:07:05 <Cale> and b must have the same type as ds
14:07:32 <Cale> (on line 240)
14:08:10 <Cale> (I don't know what the intention of this code is in order to be able to decide how to fix it though)
14:08:21 <Breadmonster> Cale: It's a Scheme interpreter.
14:08:30 <Breadmonster> b does have the same type as ds.
14:08:36 <Cale> Yeah, I'm referring to helixLet specifically
14:09:07 <Cale> You're doing  eval (e', b)  and the type signature of eval says it's  EvalType -> EvalType
14:09:24 <Breadmonster> Oh, right.
14:09:25 <Breadmonster> Okay.
14:09:26 <Cale> where EvalType = (Environment, HelixObject) and HelixObject is not a type of lists
14:09:41 <Breadmonster> So it's supposed to be snd $ eval (e', b)
14:09:44 <Breadmonster> Alright, thank you.
14:09:47 <Cale> uh
14:09:54 <Cale> That shouldn't work either
14:10:15 <Cale> The problem is that eval is being applied to a pair whose second part is a list
14:10:20 <Breadmonster> HelixObject is a compound type.
14:10:29 <Cale> (b is a list)
14:11:10 <Cale> helixLet :: (Environment, [[HelixObject]]) -> ...
14:11:24 <Cale> or something, as it stands
14:11:57 <Cale> I see that you have a commented out type signature, I would recommend putting that back in :)
14:11:58 <Breadmonster> Cale: No, helixLet :: (Environment, [HelixObject]) -> ...
14:12:10 <Cale> It'll result in better error messages
14:12:38 <Cale> If that were the case, then ds would not be a list
14:12:38 <thelopa> Hey everyone, I think I may have found a bug in POSIXTime's Enum instance. Here's my GHCI session. Hopefully I'm just doing something wrong.
14:12:47 <Cale> and you wouldn't be able to apply foldl' f e to it
14:13:48 <Cale> thelopa: It's hard to say what laws Enum is meant to obey anyway -- instances basically just define the behaviour of the list sequence syntax.
14:14:25 <Cale> thelopa: (but let's see it, stick your session on hpaste :)
14:14:29 <thelopa> http://hpaste.org/90422
14:14:50 <Breadmonster> Cale: Alright, I fixed the problem with helixLet.
14:15:02 <Breadmonster> ...interestingly, it did NOT infer [[HelixObject]]
14:15:20 <Breadmonster> Because HelixObject is a recursive type that can represent a list of itself.
14:15:34 <Peaker> thelopa, probably the time is larger than an Int? And thus there should be no Enum instance
14:15:44 <thelopa> I checked, it isn't
14:15:47 <thelopa> at least on my system
14:15:59 <Cale> oh, that does look like a bug
14:16:13 <Cale> Well...
14:16:17 <Cale> hmm
14:16:32 <Breadmonster> Cale:http://hpaste.org/90423
14:16:56 <Cale> Right, that looks better
14:17:07 <Peaker> oh, it's a Double: utcTimeToPOSIXSeconds t => 1372194943.258037s
14:17:31 <thelopa> yeah, but fromEnum converts it to an Int
14:17:54 <shachaf> Peaker: No, it's a "Fixed E12"
14:18:07 <Peaker> ah, well, it probably doesn't fit in an Int
14:18:07 <shachaf> Going by what ghci is telling me in :i, anyway.
14:18:25 <typoclass> shachaf: yeah that's correct, synonym for Pico from Data.Fixed
14:18:46 <shachaf> There's also a newtype and such.
14:19:26 <byorgey> the bug is probably that there shouldn't be an Enum instance at all.
14:19:38 <typoclass> > fromEnum (0.5 :: Pico) -- hm ...
14:19:40 <lambdabot>   1783793664
14:19:45 <byorgey> but but perhaps it was too tempting
14:20:24 <thelopa> Is there somewhere I can file a bug report?
14:21:19 <typoclass> thelopa: how big is the difference -- less than 1 second? because then i guess it's just the part after the decimal being cut off
14:21:19 <Cale> It'd probably be okay to have most of an Enum instance and just lose the toEnum/fromEnum/succ/pred
14:21:37 <Peaker> Enum class is pretty horrible
14:21:40 <Cale> (none of which probably belong in the class in the first place)
14:21:44 <thelopa> typoclass: 43 years. Today gets converted to March of 1970
14:21:47 <typoclass> ... but given what lambdabot just said, i'm guessing it's trying to convert random bits into an integer
14:21:55 <typoclass> thelopa: excellent :-)
14:22:36 <typoclass> > fromEnum (1 :: Pico) -- this looks bad, right?
14:22:37 <lambdabot>   -727379968
14:25:20 <FreeFull> @src Pico
14:25:20 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
14:25:37 <FreeFull> :t 1 :: Pico
14:25:38 <lambdabot> Pico
14:25:53 <byorgey> > succ (1 :: Pico)
14:25:54 <lambdabot>   1.000000000001
14:25:55 <typoclass> FreeFull: see Data.Fixed. it's a number with 12 decimal places
14:26:09 <FreeFull> :t fromEnum
14:26:10 <lambdabot> Enum a => a -> Int
14:26:18 <FreeFull> That's the problem
14:26:22 <FreeFull> fromEnum returns an Int
14:27:07 <typoclass> FreeFull: well, i think 1 would be a more plausible Int to return when converting (1 :: Pico). -727379968 is not so plausible
14:27:50 <byorgey> typoclass: there is not required to be any meaning to the Int returned.
14:28:23 <byorgey> that said, -727379968  is pretty odd.
14:28:53 <FreeFull> > fromEnum (0.000000000001 :: Pico)
14:28:54 <lambdabot>   1
14:29:01 <FreeFull> typoclass: ^
14:29:26 <thelopa> It is starting to look like the problem is overflowing the Int
14:29:32 <typoclass> byorgey: i dunno ... 'required' as far as the type checker is concerned?
14:29:50 <typoclass> FreeFull: right, good thinking
14:29:56 <byorgey> typoclass: 'required' as far as the semantics of Enum is concerned.
14:30:05 <byorgey> yes, the problem is certainly overflowing the Int.
14:30:10 <hpc> > floor (0/0)
14:30:11 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
14:30:17 <hpc> > floor (0/0) :: Integer -- :(
14:30:18 <byorgey> the only way to fix the bug would be to delete the Enum instance.
14:30:18 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
14:30:57 <tac> hpc: Where's your math now!?
14:30:57 <FreeFull> @hoogle (Enum a, Num b) => a -> b
14:30:58 <thelopa> since Pico is converted to an Int with 1 as 0.000000000001, I can believe that any modern date in picoseconds exceeds maxBound :: Int
14:30:58 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
14:30:58 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:30:58 <lambdabot> Data.List genericLength :: Num i => [b] -> i
14:30:58 <typoclass> hpc: that's another thing which in my opinion is a bug. but that's a Float problem, not Fixed (right?)
14:30:59 <FreeFull> @hoogle (Enum a, Integral b) => a -> b
14:30:59 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
14:30:59 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
14:30:59 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
14:31:00 <byorgey> thelopa: indeed.
14:31:15 <FreeFull> fromEnum (1 :: Float)
14:31:16 <typoclass> > (toEnum $ fromEnum (1 :: Pico)) :: Pico
14:31:17 <lambdabot>   -0.000727379968
14:31:24 <FreeFull> > fromEnum (1 :: Float)
14:31:25 <lambdabot>   1
14:31:30 <FreeFull> > fromEnum (0.9 :: Float)
14:31:31 <Breadmonster> byorgey, How do I get length to return an Integer?
14:31:31 <lambdabot>   0
14:31:34 <typoclass> should this hold? toEnum (fromEnum x) == x?
14:31:37 <FreeFull> > fromEnum (10000000000000000 :: Float)
14:31:38 <lambdabot>   -2147483648
14:31:46 <FreeFull> > (10000000000000000 :: Float)
14:31:47 <lambdabot>   1.0e16
14:31:59 <thelopa> not necessarily, fromEnum isn't well defined in the event of overflow
14:32:00 <byorgey> Breadmonster: you can't, length always returns an Int.  you can either (1) call fromIntegral on the result, or (2) use genericLength instead of length
14:32:03 <Taneb> Breadmonster, Data.List.genericLength
14:32:20 <Breadmonster> byorgey, ah, yes, genericLength.
14:32:33 <Peaker> why does "cabal build" (or maybe it's ghc --make?) copy the sources before building?
14:32:40 <FreeFull> I don't see any fromEnum alternative that doesn't return an Int
14:32:44 <byorgey> typoclass: yes.
14:32:48 <Breadmonster> Is unwords defined in Predule?
14:32:51 <Breadmonster> *Prelude
14:32:53 <typoclass> Breadmonster: that said, genericLength only becomes relevant if you have a list of elephantine size (4 billion elements ...?)
14:32:54 <FreeFull> Breadmonster: Yes
14:32:58 <geekosaur> @index unwords
14:32:58 <lambdabot> Data.List, Prelude
14:33:14 <Breadmonster> @src genericLength
14:33:14 <lambdabot> genericLength []    = 0
14:33:14 <lambdabot> genericLength (_:l) = 1 + genericLength l
14:33:21 <thelopa> it seems rather silly that the Enum instance for POSIXTime is only well defined for dates near 1970
14:33:27 <FreeFull> @src length
14:33:27 <lambdabot> Source not found. Are you on drugs?
14:33:44 <Peaker> > fromEnum (1234 :: Integer)
14:33:45 <lambdabot>   1234
14:33:49 <Peaker> this is silly too
14:33:59 <byorgey> thelopa: I completely agree.  Enum is silly.
14:34:01 <hpc> thelopa: 68 years is enough for everyone
14:34:06 <FreeFull> > toEnum 1 :: Bool
14:34:07 <lambdabot>   True
14:34:40 <typoclass> byorgey: well some instances are more silly than others. Pico seems to be very silly
14:34:48 <byorgey> indeed.
14:35:34 <Peaker> Pico indirectly newtypes an Integer, and seems like a nonsensical Enum instance for Integer has survived all the newtypes up to Pico
14:36:00 <typoclass> thelopa: anyway, in my opinion it's a bug. thanks for catching it. could you report it on the bug tracker for the base package? link is here
14:36:04 <typoclass> @hackage base
14:36:04 <lambdabot> http://hackage.haskell.org/package/base
14:36:13 <FreeFull> Woops, wrong channel for that
14:36:15 <FreeFull> > [(0.9 :: Pico) ..]
14:36:16 <lambdabot>   [0.900000000000,0.900000000001,0.900000000002,0.900000000003,0.900000000004...
14:36:19 <typoclass> Peaker: how do you mean? converting 1234 to 1234 is silly ...?
14:36:21 <FreeFull> > [(1 :: Pico) ..]
14:36:22 <lambdabot>   [1.000000000000,1.000000000001,1.000000000002,1.000000000003,1.000000000004...
14:36:25 <FreeFull> Huh
14:36:26 <Peaker> typoclass, Integer >> Int
14:36:30 <FreeFull> It actually works
14:36:35 <typoclass> Peaker: right, that's a problem
14:36:39 <Peaker> > fromEnum (2^200 :: Integer)
14:36:39 <thelopa> For those who are wondering, the current Enum instance only appears to be able to Intify dates up to...
14:36:40 <lambdabot>   0
14:36:42 <thelopa> > posixSecondsToUTCTime $ (toEnum (maxBound:: Int) :: POSIXTime)
14:36:44 <lambdabot>   Not in scope: `posixSecondsToUTCTime'Not in scope: type constructor or clas...
14:36:49 <FreeFull> Seems like [..] syntax in GHC isn't implemented using enumFromTowhatever
14:36:59 <byorgey> FreeFull: sure it is.
14:37:08 <FreeFull> Why is that working then?
14:37:10 <thelopa> bah, anyway, on my system at least, it goes up to 1970-04-17 18:02:52.036854775807 UTC
14:37:19 <FreeFull> Oh
14:37:29 <FreeFull> Maybe Pico is providing its own functions for that
14:37:35 <FreeFull> To make it work
14:37:36 <byorgey> > [(10^19 :: Pico) ..]
14:37:37 <lambdabot>   [10000000000000000000.000000000000,10000000000000000000.000000000001,100000...
14:37:50 <Aetherspawn> Cool experiment: using electronic systems NAND for simplifying boolean expressions https://gist.github.com/kvanberendonck/5862432 :)
14:37:51 <byorgey> > [(10^22 :: Pico) ..]
14:37:52 <typoclass> thelopa: that must be the UTC time when the Int first overflows (32 bits i guess)
14:37:52 <lambdabot>   [10000000000000000000000.000000000000,10000000000000000000000.000000000001,...
14:37:55 <byorgey> huh
14:38:31 <Peaker> byorgey, it's an Integer that represents a fixed-point fraction, it can grow indefinitely
14:38:37 <thelopa> typoclass: indeed
14:38:41 <FreeFull> Aetherspawn: I'm sure that code could be simpler
14:38:55 <FreeFull> Although it's pretty good as is
14:39:07 <byorgey> Peaker: oh, I guess 'succ' for Integer doesn't go through Int
14:39:20 <Aetherspawn> expl can be removed if you don't want to explode the expression to Nand's first
14:39:24 <Peaker> it's probably GeneralizedNewtypeDeriving of Integer's Enum instance
14:39:42 <Peaker> The Data.Fixed module uses base 10?
14:39:45 <Aetherspawn> but I tried my best. I'm still kinda new to this recursive thinking thing :S
14:40:30 <byorgey> right, as I suspected.  there is a default implementation   succ = toEnum . (+1) . fromEnum, but the Integer instance overrides it.
14:41:00 <byorgey> so calling enumFromTo and friends on Pico works fine; it's fromEnum and toEnum which are the problem.
14:41:30 <FreeFull> byorgey: Pico probably overrides enumFromTo and such
14:42:11 <typoclass> teh codes, if anyone is interested http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Fixed.html#line-99
14:42:26 <byorgey> FreeFull: no, it just uses the instances for Integer
14:42:44 <CaptainK> acme-missiles-0.3: Cause serious international side effects
14:42:58 <byorgey> but Integer does override those methods, that was my point
14:43:19 <byorgey> which is why you can do things like
14:43:25 <byorgey> > [28374593874598374598374598374987430598345 ..]
14:43:26 <lambdabot>   [28374593874598374598374598374987430598345,28374593874598374598374598374987...
14:43:51 <CaptainK> creatur-2.0.12: Framework for artificial life experiments.
14:44:16 <byorgey> CaptainK: why are you pasting the names and descriptions of Hackage packages?
14:44:20 <CaptainK> trying to merge creature and acme-missles to create SkyNet
14:44:44 <typoclass> CaptainK: maybe download the two packages and extract them to the same directory? =)
14:44:47 <byorgey> ok, have fun =)
14:45:44 <typoclass> fromEnum and toEnum are the main problem, aren't they. the other functions seem alright (enumFromTo and such)
14:45:49 <JoeyA> CaptainK: acme-missiles doesn't have much networking support at the moment, so you might run into trouble.
14:46:45 <hpc> JoeyA: you just need to have all the launchers controlled from the same computer
14:47:03 <acowley> thoughtpolice: Are you hosting ARM GHC binaries anywhere?
14:48:31 <thoughtpolice> acowley: not at the moment, no. i'm immediately working on getting Clang working and recovering some performance on OS X
14:48:54 <acowley> thoughtpolice: What's my best bet for getting a GHC on an ODROID-U2?
14:48:56 <thoughtpolice> i'm going to get my ARM builder back up soon though, i think some of the tree instability has ironed out (there was some confusion around dynamic linking)
14:49:25 <thoughtpolice> acowley: HARDKERNEL provides an Ubuntu/Linaro 12.10 derivative that I installed on my board. after that, just an 'apt-get install ghc' away
14:49:26 <byorgey> edwardk: ping
14:49:31 <edwardk> %pong
14:49:41 <byorgey> edwardk: is there a reason you don't export 'midpoint' from Data.Interval (in the intervals package)?
14:49:44 <thoughtpolice> acowley: they probably provide a more up to date build now, i need to update my system
14:49:46 <edwardk> no
14:49:58 <byorgey> edwardk: OK, I'll shoot you a pull request
14:50:00 <thoughtpolice> acowley: i think you have to look in the forums for the link/instructions to getting Linux on it. also, did you get eMMC?
14:50:46 <edwardk> byorgey: already fixed and pushed and hackaged
14:50:57 <sclv_> ahaha
14:51:06 <byorgey> fastest Hackage in the west!
14:51:20 <edwardk> its a survival trait when you have as many packages as i do =)
14:51:36 <edwardk> the slow get buried
14:51:44 <acowley> thoughtpolice: It's not mine, and I'm not sure what exactly was ordered.
14:51:49 <byorgey> edwardk: fair =)
14:52:14 <acowley> thoughtpolice: I figured that would be an old GHC, though
14:52:19 <acowley> thoughtpolice: (the one in apt)
14:52:23 <fetter_oml> good evening. i had the task for a course to programm quicksort and mergesort and count the comparisons. easy as pie with global variables, but I wonderd if I could elegantly haskell it, I thought it might be a good place to build my first own monad / use the state monad.
14:52:35 <thoughtpolice> acowley: 7.4.2 is good enough for bootstrapping
14:52:38 <fetter_oml> well, my current code is this, it works with tupels: http://pastie.org/private/i0hbptdhuxvejz7lg7l8ba
14:52:47 <thoughtpolice> it might actually be 7.6.1
14:52:51 <acowley> thoughtpolice: How long does a build take on that platform?
14:53:11 <thoughtpolice> acowley: depends on the eMMC probably. for me, like 4ish hours to get through a quick-llvm build, no testsuite?
14:53:23 <thoughtpolice> assuming LLVM is compiled in optimized mode
14:53:35 * hackagebot intervals 0.2.2 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.2.2 (EdwardKmett)
14:53:44 <thoughtpolice> acowley: unfortunately you'll need to use like, LLVM 3.1 or something to bootstrap. the reasons for this are variously stupid and complicated. you can't use HEAD
14:53:48 <acowley> thoughtpolice: Okay, thanks. I'm not sure if I'm going to have the chance to smear Haskell on that project, but I'd like to be poised to seize the opportunity should it arise :)
14:53:54 <fetter_oml> but I really cant find a way to monad it elegantly. therefore my question is: would you make it with a monad or do you think the tupel-way is a reasonable fine way for the task?
14:53:56 <acowley> thoughtpolice: 3.3 is no go?
14:54:32 <thoughtpolice> acowley: no. :( the TL;DR is that they changed the LLVM Bitcode verifier to be more strict, and only HEAD is appropriately fixed to deal with this. that means that older compilers - like the bootstrap compiler - will generate IR that is technically compatible
14:54:38 <thoughtpolice> but the verifier fails on it
14:54:45 <thoughtpolice> which is fucking awful, to say the least
14:54:49 <b52> is there something like a mixture of map and foldl? like applying a function element-wise while keeping an accumulator around until its done?
14:55:18 <byorgey> b52: mapAccumL ?
14:55:29 <byorgey> @type mapAccumL
14:55:30 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
14:55:47 <thoughtpolice> acowley: it may be worth a shot though. it's possible the distributed GHC can be linked against a specific version of LLVM, so for the bootstrap compiler, it would be unambiguous...
14:55:49 <acowley> thoughtpolice: I appreciate you soaking up all the pain from that direction for the community
14:55:50 <thoughtpolice> but that depends on how GHC was built, i think
14:56:19 <b52> byorgey: You sir, are a genius :D
14:56:43 <thoughtpolice> acowley: thanks, although Geoffrey definitely deserves credit for rooting out the two nastiest issues, coincidentally (the verifier failure, and llvm is currently incompatible with dynamic linking)
14:57:07 <thoughtpolice> i'm thinking though that HEAD has settled down enough wrt all that now, so I need to plug my ODROID back in
14:57:21 <acowley> I don't know how you guys have the patience for that stuff. It drives me to drink.
14:57:25 <FreeFull> > mapAccumL (,) 0 []
14:57:26 <lambdabot>   (0,[])
14:57:34 <FreeFull> > mapAccumL (,) 0 [3]
14:57:35 <lambdabot>   (0,[3])
14:57:46 * thoughtpolice was building 4 copies of GHC at once this morning
14:57:56 <acowley> I built llvm 3 times yesterday
14:58:02 <thoughtpolice> i'm sure Igloo has beaten that by a large margin :)
14:58:09 <FreeFull> > mapAccumL (\a x -> (a, x+1)) 0 [3,4,5]
14:58:10 <lambdabot>   (0,[4,5,6])
14:58:12 <acowley> actually, maybe you could answer this one, thoughtpolice
14:58:18 <acowley> err, off topic
14:58:26 <FreeFull> > mapAccumL (\a x -> (a, a+x)) 0 [3,4,5]
14:58:27 <lambdabot>   (0,[3,4,5])
14:58:40 <FreeFull> What is the purpose of mapAccumL?
14:59:23 <FreeFull> Oh, wait, I see
14:59:26 <johnw> sort of exactly what b52 asked :)
14:59:27 <FreeFull> > mapAccumL (\a x -> (a+1, a+x)) 0 [3,4,5]
14:59:28 <lambdabot>   (3,[3,5,7])
14:59:47 <FreeFull> > fst $ mapAccumL (\a x -> (a+1, a+x)) 0 [3,4,5]
14:59:48 <lambdabot>   3
14:59:57 <FreeFull> I think I just found an alternative to length
15:10:20 <nabilhassein> hello, i have a question about imports
15:10:37 <nabilhassein> i have a git repo with subdirectories called src and test
15:10:58 <nabilhassein> i'd like to be able to import modules that live in src from files that live in test
15:11:18 <nabilhassein> the only way i've been able to figure it out is with something like `ghci -i`, `runhaskell -i`, etc.
15:11:44 <nabilhassein> but i'd like to configure everything such that someone who `git clone`s my repo will have everything compile or load in ghci or whatever, and just work, without needing to deal with such settings themselves
15:11:57 <nabilhassein> how can i accomplish this?
15:12:38 <blub> I'm trying to make a tic tac toe :D game (new 2 haskell)  Can anyone help me?
15:12:43 <jfischoff> you can have a .ghci file in the root of the project that adds the src directories
15:12:44 <acowley> For ghci, a .ghci file can be used to issue ":set -isrc" etc.
15:14:13 <acowley> nabilhassein: For compiling, a .cabal file is helpful as it can sort out path issues and dependencies
15:14:43 <nabilhassein> acowley: i was doing some reading online and i found reference to something called hs-source-dirs. however, adding
15:14:47 <nabilhassein> hs-source-dirs: src
15:14:53 <nabilhassein> in my .cabal file did nothing useful
15:15:13 <acowley> nabilhassein: It should!
15:15:29 <Cale> If you were to put test inside src, and rename it to Test, then you could just name those modules Test.Whatever and avoid the hassle of setting include paths.
15:17:13 <nabilhassein> acowley: perhaps it's because i'm just loading the files in ghci? i haven't actually compiled anything at this point
15:17:19 <nabilhassein> i'm still quite early in my program's development
15:17:33 <nabilhassein> this is the first substantial haskell program i've written and i'm trying to take my time to follow good practices
15:17:37 <nabilhassein> Cale: is that a common practice?
15:17:41 <acowley> nabilhassein: Yes, the .cabal setting won't have an effect on ghci
15:17:53 <acowley> nabilhassein: fwiw, I use src and test directories, too
15:19:40 <nabilhassein> jfischoff, acowley: when I added a .ghci file with ":set -isrc", it didn't work when I tried to load up my test file, and additionally I got the following error message:
15:19:49 <nabilhassein> *** WARNING: /home/nabil/Dropbox/repos/bitcurry is writable by someone else, IGNORING!
15:20:35 <nabilhassein> 'bitcurry' is the name of the project I'm working on, and of the directory it lives in on my machine. I've seen a similar error with .ghci files before, but what does it mean for ghci to ignore the entire directory 'bitcurry'?
15:22:03 <acowley> nabilhassein: I don't know
15:22:30 <acowley> nabilhassein: I think there was a security problem with .ghci files
15:22:55 <acowley> nabilhassein: So I suppose this is a check to prevent abuses of that nature
15:23:35 <acowley> nabilhassein: FIrst thing I'd do is try to get it working in a directory with simpler permissions
15:23:37 <nabilhassein> blub: I wrote a tic-tac-toe program recently
15:23:55 <nabilhassein> blub: this version has neither an AI nor networking, so it's just for two people sitting at the same keyboard, but it works
15:24:48 <CaptainK> JoeyA: is it a serious package?
15:25:24 <nabilhassein> blub: I just hpasted it here: http://hpaste.org/90424
15:25:39 <c_wraith> acowley: by "a security issue" you mean "it can perform any arbitrary action at all", right?
15:25:41 <joelteon> what is it called when you refactor a >>= return into a?
15:25:50 <joelteon> I know f a = g a -> f = g is eta reduction
15:25:57 <acowley> c_wraith: Yes, something inconsequential like that
15:25:59 <Peaker> "remove redundant bind"?
15:26:08 <joelteon> so it doesn't have a fancy category theory-ish name :(
15:26:14 <c_wraith> nope.
15:26:16 <joelteon> how can I get a job with a commit message like that
15:26:26 <Peaker> you could say: "Apply monadic right-identity law"
15:26:34 <joelteon> There's an idea
15:26:50 <Peaker> is your job applying hlint suggestions?
15:27:02 <joelteon> But I'll shorten it to "right identity law" because I'm assuming people reading my commits are smart enough to know all the context.
15:27:06 <joelteon> Yeah, that would be a neat job.
15:27:12 <nabilhassein> alright, i think i'm going to take a break for now, but I appreciate the help. perhaps to be continued
15:27:20 <nabilhassein> thanks all
15:27:31 <Peaker> joelteon, a neat job where you can be replaced by a shell script? :)
15:27:49 <joelteon> my current job could conceivably be replaced with a sufficiently tested shell script
15:27:54 <c_wraith> Speaking of..  People are working on HaRe again?
15:35:46 <Guest47079> www.avsanplastik.com
15:36:09 <Peaker> Does using Control.DeepSeq.rnf + GHC.Vacuum sound like a sane way to measure the space costs of a value?
15:38:00 <Cale> Only if you're intending to keep all of that value in memory at once...
15:38:10 <Cale> But it does seem like a cool idea
15:43:18 <Guest47079> www.avsanplastik.com
15:43:23 --- mode: ChanServ set +o geekosaur
15:43:34 --- mode: geekosaur set -o geekosaur
15:51:01 <mray27> How long does it take to learn hasketl?
15:51:15 <merijn> ezyang is a first year phd student?!? Now I feel inadequate :(
15:51:22 <merijn> mray27: To what level of proficiency?
15:51:32 <c_wraith> mray27: 1 day or 20 years.
15:51:48 <mray27> to be on your level
15:51:48 <josephle> merijn: what if mray27 wants to be the next edwardk? :P
15:51:51 <typoclass> mray27: you can do something useful fairly quickly. a few weeks i would say
15:51:57 <mray27> that's the plan
15:52:10 <mray27> I want to program a design that i made with autocad, put it into works
15:52:37 <merijn> mray27: It took me 6 months to feel like I could write an actual real life program, maybe longer. Nowadays I even write half of my throwaway shell scripts in haskell
15:52:55 <mray27> Do you use linux? I'm currently on a single osx macbook pro
15:53:01 <merijn> (nowadays being approximately a year and a half after *really* starting with haskell
15:53:04 <mray27> single, not dual boot on windows
15:53:10 <joelteon> I use osx, mray27
15:53:13 <mray27> ok good
15:53:20 <joelteon> it's quite haskell-friendly
15:53:21 <merijn> mray27: I use OSX only for development, works fine
15:53:26 <c_wraith> I was doing real work in haskell within a week of starting it - but it was very primitive maintenance work on an existing codebase.
15:53:26 <mray27> i dont plan to dual boot i hope i can accomplish things using just osx
15:54:04 <Nisstyre> c_wraith: what kind of codebase was it?
15:54:06 <joelteon> and if you have any weird library errors I can probably help
15:54:12 <merijn> mray27: I only run OSX, no problem whatsoever. I just install the Haskell Platform for OSX and then install any other packages using "cabal install"
15:54:22 <mray27> thanks for the information
15:54:28 <mray27> I will be working on this
15:54:30 <joelteon> I actually recommend using the homebrew ghc package
15:54:37 <joelteon> it's very nice
15:54:37 <merijn> joelteon: Why?
15:54:56 <joelteon> because it means one less place through which I have to track updates
15:55:03 <merijn> Platform is only released twice a year...
15:55:12 * brendan just packaged it all up for fink too
15:55:14 <joelteon> yeah, and that's twice I don't have to worry about
15:55:21 <joelteon> anyway, homebrew has haskell-platform too
15:55:22 <c_wraith> Nisstyre: a highly-concurrent http fetching service
15:55:29 <joelteon> I just use the ghc one
15:55:35 <Nisstyre> c_wraith: neat
15:55:44 <Nisstyre> c_wraith: Haskell is awesome for massively concurrent programs
15:55:54 <Nisstyre> I'm working on a massively concurrent emailing system in it
15:55:55 <joelteon> yeah I like that part
15:55:59 <c_wraith> Nisstyre: yeah, that's why it was written in haskell in the first place :)
15:56:00 <merijn> And shell scripts! :p
15:56:48 <merijn> I'm not even joking, in the past 2 days I've written 4 haskell programs just to do some data processing in the middle of 2 bash shell scripts doing data mangling
15:56:50 <Nisstyre> c_wraith: crap like nodejs makes me laugh
15:57:08 <c_wraith> Nisstyre: well, this was long before nodejs.
15:57:09 <merijn> Nisstyre: I like to think of that as my competitive advantage ;)
15:57:37 <Nisstyre> c_wraith: yeah, but people are all trumpeting node's supposed concurrency advantage
15:57:43 <Nisstyre> when they did it completely wrong
15:58:02 <Nisstyre> lightweiht threads + static guarantees = the best approach
15:58:05 <Nisstyre> *lightweight
15:58:10 <merijn> Nisstyre: I was gonna say something, but then I realised this conversation branch is -blah fodder
15:58:19 <Nisstyre> yeah, I'll stfu now
15:58:33 <Nisstyre> but there is a good post by Simon Marlow on stackoverflow about this
16:27:11 <edeast> hello, can I use ghci to solve some economic model?    I don't know how but it's only 2 eqn's.
16:27:33 <dolio> Probably.
16:28:05 <sclv> absolutely!
16:28:17 <sclv> it depends what you mean solve of course
16:28:23 <edeast> its more like, i don't know how, but we'll see,  the blogpost, model i'd like to help solve is http://worthwhile.typepad.com/worthwhile_canadian_initi/2013/06/rates-rents-and-shares.html
16:29:11 <sclv> there's nothing to solve
16:29:20 <sclv> they're just two equations in multiple variables
16:29:30 <sclv> you can plot them and see what they look like as you tweak different variables
16:29:43 <sclv> you can do this in ghci + a charting library
16:29:45 <edeast> later on down at the appenxis
16:30:20 <edeast> ok,  i'm no econ,
16:30:28 <sclv> that's not solving mathematically
16:30:50 <sclv> that's just tweaking the equation so it looks more natural
16:30:50 <sclv> according to some arbitrary assumptions
16:30:50 <sclv> that's what econ is !
16:31:17 <edeast> ya, econ, is fascinating/ enfuriating
16:32:09 <edeast> i thought R would be easier, but I've invested a bit of time into Haskell
16:33:29 <Luke1> anyone know a good resource for looking up ghci flags? There's a few I can't find in the man pages like -s and -r
16:36:33 <hpc> Luke1: the ghc manpage is indeed missing at least several flags
16:36:43 <hpc> you can try going through the ghc manual to find them
16:37:01 <hpc> and for what it's worth, this package is a good way to help find stuff that is in the manpage: http://hackage.haskell.org/package/ghc-man-completion
16:37:02 <Demos> does ghc have an info page (I hope not)
16:37:13 <dolio> It has a user guide on the website.
16:37:33 <Luke1> man ghc doesn't have them either
16:38:44 <Luke1> is -s the same as +s?
16:38:53 <Luke1> ghci user guide online has +s
16:38:59 <Luke1> and +r
16:39:18 <hpc> those smell like RTS flags
16:42:52 <Luke1> snap has :set -isrc in it's .ghci and i'm just trying to figure out what that does
16:43:16 <sm> adds ./src to the source file include path
16:43:17 <merijn> Luke1: Oh, that's easy
16:43:31 <merijn> Luke1: -i specifies additional directories to look for modules
16:43:45 <merijn> Luke1: So "-isrc" just tells ghci to also look in the src directory for modules
16:43:45 <Luke1> in this case nothing is specified so it clears it out right?
16:43:51 <Luke1> ooooh
16:43:53 <Luke1> hahaha
16:43:55 <Luke1> thanks!
16:44:09 <Luke1> it's not -i -s -r -c it's -i"src"
16:44:11 <Luke1> thanks
16:52:05 <trace30m> I can not search in google for ">>=" haskell
16:52:12 <trace30m> so what is ">>="
16:52:19 <AProperNoun> It's often called bind
16:52:47 <AProperNoun> Could also try symbolhound.com
16:52:59 <AProperNoun> Hmm, doesn't seem to work that well
16:53:10 <AProperNoun> Look up monads
16:53:10 <shachaf> trace30m: Hoogle is the way to search for things.
16:53:11 <shachaf> #where hoogle
16:53:14 <shachaf> @where hoogle
16:53:14 <lambdabot> http://haskell.org/hoogle ‚Äì See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
16:53:40 <Cale> trace30m: If you're not familiar with that yet, it may help to know what sort of context it's appearing in
16:54:14 <Cale> trace30m: It's a symbol which is defined in different ways for different type constructors M, but which always has a type of the shape  M a -> (a -> M b) -> M b
16:54:43 <Cale> trace30m: Usually "M a" will be some type of computations whose result is of type a
16:55:17 <Cale> and then >>= will take one of those, and a function from possible results of the first computation to further computations to be done, and will glue those together in some natural way
16:55:47 <Cale> For instance,  getLine >>= \line -> putStrLn line
16:56:26 <Cale> will be an IO action which gets a line of text from the user, binding the result to the variable 'line' which is the parameter to that function, and then prints that line of text back out
16:57:41 <trace30m> ah
16:58:00 <trace30m> ^^
16:59:49 <trace30m> lambdabot: r u german?
17:00:10 <josephle> trace30m: lambdabot is, truthfully speaking, a bot.
17:01:28 <Aetherspawn> I have a wierd problem that doesn't make sense
17:01:37 <Aetherspawn> this code prints out its invocation! https://gist.github.com/kvanberendonck/5862432
17:02:09 <Aetherspawn> I don't retrieve the invocation anywhere... it looks like an ignored stack overflow or something?
17:05:55 <Raydiation> i was reading about monoids lately, whats their exact usage?
17:06:27 <tabemann> a monoid is any pair of an identity value and an associative function for which that value is an identity
17:06:37 <Cale> Raydiation: They show up all over the place...
17:06:43 <Raydiation> some meant because theyre associative you can split the calculation on more machines
17:06:51 <tabemann> a given underlying type may have more than one monoids (for instance integers have two monoids)
17:07:21 <tabemann> associative means that f (f a b) c == f a (f b c)
17:07:48 <Raydiation> sure, i dont really get the fuss about it
17:07:57 <merijn> Raydiation: There isn't much fuss
17:08:02 <Cale> Raydiation: Throughout computer science, all our best algorithms usually rely on being able to balance binary trees. The information which you put in the branch nodes that summarises the stuff at the leaves has to be monoidal (or at least associative) in order for tree rebalancing to not have to recompute it.
17:08:08 <trace30m> when I dont write "do ....." then I write at the same position only function call after function call ?
17:08:11 <merijn> Raydiation: They're a very basic concept from algebra, and as such appear *everywhere*
17:08:21 <Cale> (this being the case even if we're not explicitly building a tree)
17:08:27 <merijn> Raydiation: Also, they have some neat and useful properties that make them nice for modelling some interactions
17:08:53 <Cale> If there's a 'log' in the time complexity of some operation, there's usually a monoid hanging around somewhere, even if implicitly :)
17:09:10 <Raydiation> Cale: merijn: i see thanks
17:09:16 <merijn> Raydiation: In that, if you can prove that what you're doing is a monoid, you can from that point on assume all the nice things we already know how to do with monoids
17:09:33 <merijn> Raydiation: But, if you're thinking "well, this seems really simple", then you're pretty much right, yes
17:09:39 <Raydiation> there were some videos on markana tech tv about monoids
17:09:45 <Luke1> http://hpaste.org/90427 does this look like it will cause an infinite loop?
17:09:58 <merijn> Raydiation: Not all useful concepts have to be hard :) (fortunately!)
17:10:00 <Raydiation> and usual mathematical "speak" complicates very easy concepts
17:10:15 <Raydiation> language*
17:10:52 <c_wraith> Luke1: that will absolutely cause an infinite loop.
17:10:56 <Luke1> nice
17:11:03 <Luke1> no need to debug then =)
17:11:08 <Luke1> ty
17:11:17 * tabemann isn't sure how toRow (Just x) would even typecheck
17:11:38 <c_wraith> tabemann: it's an infinite loop. the type checker infers its result type will unify with anything
17:11:54 <c_wraith> oh, you mean the other case
17:11:58 <c_wraith> It looks fine
17:13:22 <tabemann> the first case makes it look like it could only take infinitely nested Maybe (Maybe (Maybe (Maybe ...)))
17:13:27 <Aetherspawn> this code prints out its invocation! https://gist.github.com/kvanberendonck/5862432
17:13:30 <Aetherspawn> I don't retrieve the invocation anywhere... it looks like an ignored stack overflow or something?
17:13:38 <Aetherspawn> (repost, sorry)
17:13:41 <tabemann> unless someone else is implementing ToRow
17:14:07 <tabemann> (the first case looks much more sane if other instances of ToRow were included)
17:14:10 <c_wraith> tabemann: the whole point of an instance like that is that it delegates to the ToRow implementation for the type that's an argument to Maybe
17:14:23 <Luke1> there are other instances of ToRow
17:14:26 <c_wraith> tabemann: it's really very common to write instances like that for types like Maybe
17:14:30 <Luke1> this is for postgresql-simple
17:14:40 <shachaf> Aetherspawn: Rather than reposting the same question, try explaining what the problem is.
17:14:42 <tabemann> c_wraith: I know - I just didn't look at that it was an instance when I said that
17:14:50 <c_wraith> But yeah, the case for Nothing is totally broken.
17:15:32 <Luke1> c_wraith: do you know how i can fix it?
17:16:03 <c_wraith> Luke1: I suspect it isn't possible, and the whole instance is a mistake.  But let me look at the docs for a second
17:16:25 <Raydiation> what is just? a monad?
17:16:34 <Aetherspawn> This is the output for my question above: http://hpaste.org/90428
17:16:36 <c_wraith> Just is a data constructor
17:16:37 <tabemann> random question: if I implement a module implementing strict lists and doing just about anything one can do in the prelude to lists that is sane to do to a strict list, does it make sense to reimplement each of the functions that is in the prelude that could be implemented in terms of Functor, Foldable, and Tranversable to those, or should I implement them anyways
17:16:45 <Aetherspawn> the problem is that After: simpl.exe makes ZERO sense.
17:16:52 <Raydiation> when would i use Just?
17:17:25 <tabemann> Just creates a Maybe a with a value of type a
17:17:32 <Luke1> Just is a data contructor to Maybe
17:17:41 <c_wraith> Luke1: what module is that class defined in?
17:17:50 <Luke1> looking
17:18:16 <Luke1> http://hackage.haskell.org/packages/archive/postgresql-simple/0.3.3.2/doc/html/Database-PostgreSQL-Simple-ToRow.html
17:18:22 <Cale> tabemann: Well, there might be performance benefits to implementing some things directly in some cases.
17:18:37 <FreeFull> :t Just
17:18:38 <lambdabot> a -> Maybe a
17:18:39 <merijn> Raydiation: There's a type "Maybe a", which is a value that *might* have an "a", it might also not have an "a"
17:18:53 <tabemann> Cale: that's what I was thinking, as I was looking at some of the code in Foldable, and it seemed not nearly as direct as just implementing those by hand
17:18:59 <FreeFull> Raydiation: Just is a function that you use when you have an  "a" and want a "Maybe a"
17:19:11 <Raydiation> FreeFull: i see thanks :)
17:19:14 <FreeFull> Raydiation: Nothing is what you use when you don't have an "a" and want a "Maybe a"
17:19:18 <merijn> Raydiation: This is represented by having two constructors "Nothing" (which doesn't have an "a") and "Just" which is a constructor that takes an "a" and returns a "Maybe a"
17:19:38 <Cale> tabemann: Might be worth trying -- of course, if you have the instances in the first place, you can just add stuff wherever it seems to help.
17:19:57 <merijn> Raydiation: Imagine a function parseInt, which parses a number. Clearly it's input type is a String, but what should its output be?
17:20:14 <merijn> Raydiation: If the output is Int, then what if the String I give it is not a number?
17:20:28 <Raydiation> no exceptions in haskell right?
17:20:39 <tabemann> Cale: I'm thinking of implementing *both*, so I can have faster functions that fit the usual map, foldr, foldl', and like, and instances to allow the type to be used anywhere one would use a Functor, Foldable, or Tranversable
17:20:41 <merijn> Raydiation: The solution is to have "parseInt :: String -> Maybe Int" and if String is not a number, you return Nothing
17:20:44 <merijn> Raydiation: There are
17:20:58 <merijn> Raydiation: The Control.Exception module has many different kinds
17:21:04 <c_wraith> Luke1: the only plausible implementation for the Nothing case is something like [Plain $ fromString "NULL"]
17:21:23 <FreeFull> parseInt :: String -> Either String Int    would probably be better
17:21:24 <Luke1> yeah I was thinking even just "toField" which would resolve to that same thing
17:21:28 <c_wraith> Luke1: And that's if you want Maybe a to represent a nullable argument, and Nothing to be the nullcase
17:21:29 <FreeFull> Because then you can provide an error message
17:21:37 <Luke1> yup
17:21:50 <Luke1> i think I want "toField" actually
17:21:52 <Luke1> thanks
17:22:03 <tabemann> I'm also going to implement special functions that aren't present for lazy lists like a revMap, because, e.g., map isn't tail-recursive, which is fine for lazy lists, but is a problem for strict lists
17:22:25 <c_wraith> Luke1: oh, yeah.  that would work.
17:23:46 <Luke1> c_wraith: thanks
17:27:02 * tabemann checks to make sure Data.List.Strict doesn't already exist
17:27:29 <c_wraith> if you need a strict structure, odds are something like Vector is more appropriate
17:28:31 <tabemann> c_wraith: I'm mainly doing it because it is an area where really nothing's been implemented for it, e.g. if you want a list, but you want to, say, pass it through an MVar without leaking computation into the receiving thread
17:28:49 <c_wraith> The exception is if you are using it as a stack and O(1) push and pop are really important
17:29:34 <c_wraith> tabemann: oh.  there's a strict concurrency package which may be what you want, then
17:30:05 <tabemann> but doesn't strict-concurrency just evaluate values to weak head normal form, not *deep* evaluate them?
17:30:09 <c_wraith> no
17:30:13 <thoughtpolice> nope, it uses deepseq
17:30:22 <c_wraith> all those NFData instances should give it away
17:30:34 <c_wraith> if it was just going to WHNF, it wouldn't need them
17:31:03 <thoughtpolice> but yeah, you really just want a deeply strict MVar, not a strict list really
17:31:09 <tabemann> now that has the problem that you need to make everything you put in the list an instance of NFData, rather than simply adding bangs to it
17:31:26 <c_wraith> that's implicit in the problem statement
17:31:26 <thoughtpolice> that package could probably use a touch-up though, i think there are a few new functions these days that don't have analogs there perhaps
17:31:39 <shachaf> There are many problems with deepseq other than requiring an instance of NFData.
17:32:02 <c_wraith> if you really don't want the receiving end to receive something unevaluated, you need to do the equivalent of deepseq anyway. (though you might be able to do it more efficiently yourself)
17:32:12 <tabemann> there's no strict-concurrency version of TVar or TChan...
17:32:35 <c_wraith> ack, those would be *massively* inefficient
17:32:42 <c_wraith> in the case of transaction rollbacks
17:34:11 <c_wraith> the biggest problem with deepseq is that it's a giant hammer, forcing every thunk, even those you know are already evaluated.  Applying it repeatedly is especially bad.
17:34:55 <tabemann> wouldn't simply strict data structures be a better solution then, as it forces thunks once, when you put them in the data structure?
17:35:07 <c_wraith> that may still be too often
17:35:17 <c_wraith> If you know things are already forced before that.
17:36:19 <tabemann> well they preclude things like creating infinite lists or producing lists while consuming them, obviously
17:36:49 <tabemann> but simply forcing everything put in the data structure is no less efficient than what strict languages do
17:37:34 <c_wraith> No, it can end up forcing everything twice
17:39:05 <tabemann> hmm, this is what I'm wondering about
17:39:05 <c_wraith> if your typical operation is 1) take the current value out of the mutable cell.  2) prepend a single element.  3) force it to be evaluated.  4) put the new value into the mutable cell.
17:39:18 <c_wraith> In the case of a tail-strict list, that would cause the head and the second element to be evaluated each time
17:39:36 <c_wraith> which means forcing every element twice
17:39:58 <c_wraith> Whereas if you use a standard list, you will only force each element once
17:40:12 <tabemann> how is, with data List a = Nil | Cons !a !(List a), Cons foo (Cons bar Nil) evaluating bar twice?
17:40:41 <c_wraith> It's not evaluating bar twice
17:40:42 <c_wraith> it's evaluating Cons bar Nil twice
17:41:37 <c_wraith> assuming you're following the pattern I very clearly specified
17:41:45 <tabemann> so taking a value that's already evaluated and placing it into a strict cell evaluates it again?
17:42:02 <c_wraith> well, it causes the runtime to make sure it's evaluated
17:42:09 <c_wraith> Which is less work than evaluating it all again
17:42:23 <c_wraith> but it's more work than using the fact that you know it's already evaluated
17:43:33 <tabemann> so the added expense is that it has to check whether the value it's been given is a thunk or not, not an extra evaluation per se?
17:44:00 <c_wraith> it's a thunk either way. The question is if it's been evaluated or not. But yes.
17:45:43 <Moggle_> I'm curious, is the 'plugins' package uh... safe? If I eval a given source file or something, and demand it return some kind of TotallySafeMonad a, is it possible to abuse unsafePerformIO and other sorts of things?
17:45:50 <Moggle_> Are there any packages made to prevent that sort of thing?
17:46:15 <tabemann> note that there are perfectly legitimate reasons to use unsafePerformIO
17:46:31 <tabemann> and I doubt there is any way to programmatically distinguish between those and abuses of it
17:46:45 <Moggle_> say I was fine with restricting all uses of unsafePerformIO.
17:47:09 <tabemann> I highly suspect that there's no way to implement what you're looking for
17:47:30 <c_wraith> You could hook into safe haskell, but that's environment-dependent
17:47:44 <tabemann> as what you're asking for implies that you should be able to solve the halting problem, when taken to its final conclusion
17:48:16 <c_wraith> Since you can mark any module in an installed package as trustworthy in safe haskell
17:48:23 <Moggle_> tabemann: actually I'm more or less just asking for some way to allow people to write a plugin which can only use certain functions I've explicitly whitelisted.
17:48:34 <c_wraith> look at mueval
17:48:37 <c_wraith> it does exactly that
17:48:41 <Moggle_> thanks, c_wraith!
17:48:56 <c_wraith> (It's what lambdabot uses)
17:50:53 <c_wraith> tabemann: you don't need to solve the halting problem unless you want to allow *all* safe programs.  defaulting to "deny" unless you can prove it's safe with simple heuristics is good enough.
17:51:55 <tabemann> you *can* get around the halting problem issue by combining the whitelist with a timer, which is what lambdabot does
17:52:29 <tabemann> that doesn't turn the code being run into a total function, though, but it guarantees that an exception will be raised instead of waiting forever
17:53:49 <Moggle_> Looking at it, mueval isn't quite what I wanted but safe haskell seems pretty ideal.
17:54:04 <FreeFull> I thought lambdabot used timer only
17:54:15 <c_wraith> safe haskell isn't enough on its own
17:54:20 <c_wraith> since it doesn't prevent infinite loops
17:54:26 <c_wraith> or other hostile silliness
17:57:15 <Moggle_> c_wraith: that's fine for the most part, just run it in a separate thread.
17:57:25 <c_wraith> well, no
17:57:27 <Moggle_> c_wraith: yes there's resource allocation issues and stuff but thtat's okay
17:57:38 <c_wraith> I can easily write an infinite loop that will block the whole GHC runtime forever
17:57:55 <c_wraith> (due to know details of how the GHC garbage collector works)
17:58:00 <c_wraith> *knowing
17:58:05 <Moggle_> c_wraith: crashing is fine, allowing a malicious program to access the internet and upload your /etc/passwd file is not.
17:58:13 <Moggle_> safe haskell is perfectly fine for this.
17:58:31 <shachaf> FSVO "perfectly fine"
17:58:37 <FreeFull> What about allocating all memory until the machine almost grinds down to a halt?
17:58:45 <Moggle_> freefull: also fine
17:58:47 * shachaf is not all that confident in Safe Haskell on its own.
17:58:49 <tabemann> can't you tell the runtime to only allocate so much memory?
17:58:51 <Moggle_> freefull: in my intended use case anyways.
18:00:28 <c_wraith> the thing about Safe Haskell is that you need to vet every single package you install
18:00:55 <shachaf> You also need to trust e.g. the type checker and RTS.
18:01:09 <c_wraith> If any of them accidentally mark a module trustworthy that happens to have a bug that allows unsafePerformIO or unsafeCoerce, the whole system is broken
18:01:19 <c_wraith> accidentally *or* happens to have a bug
18:01:21 <c_wraith> either way
18:01:28 <tabemann> and note that many C bindings use unsafePerformIO
18:01:42 <tabemann> and use other stuff that you really shouldn't allow
18:01:57 <Moggle_> tabemann: safe haskell prevents use of FII i do believe
18:02:01 <Moggle_> FFI*
18:02:29 <tabemann> and that is very restrictive, as there are many libraries we know are perfectly safe that use those things
18:02:35 <c_wraith> unless things are marked trustworthy
18:02:50 <Moggle_> tabemann: so mark them as trustworthy!
18:02:51 <c_wraith> Once again - safe haskell allows *anything*, if the module says "it's cool, trust me"
18:03:43 <c_wraith> So you have to be very careful with what you allow to be installed
18:06:33 <dolio> Safe haskell seems to have a locality problem, too.
18:07:18 <dolio> The status of a module depends on what the modules it depends on do, which may change between versions and such.
18:08:42 <dolio> I know edwardk is writing a bunch of CPP macros that declare some modules either trustworthy or safe depending on which version of other stuff he's compiling with.
18:09:03 <dolio> Which is pretty much nonsense.
18:11:51 <sclv> yeah it would be better to capture that directly
18:12:07 <sclv> maybe a good proposal could be banged out of edwardk explained the problem
18:12:42 <sclv> like {-# LANGUAGE SafeAsPossible #-}
18:45:09 <japage> HI
18:46:14 <japage> <haskell noob here, with a noob question. I have a function
18:46:33 <japage> double_small_number x = if x > 100 then x else x*2
18:46:41 <japage> i load it in the interpreter
18:47:00 <japage> double_small_number 100 returns 200
18:47:24 <shachaf> What is the question?
18:47:29 <japage> but, 100 < 100 returns false
18:47:44 <shachaf> What about 100 > 100?
18:47:55 * japage palmface
18:48:13 <japage> shachaf: thanks so much
18:48:29 <shachaf> (For future reference: We say that 100 < 100 *is* False, not "returns" False. It's not a function so it doesn't return anything.)
18:48:51 <japage> but > is a function?
18:49:09 <shachaf> Yes.
18:49:15 <japage> an infix function?
18:49:20 <shachaf> Similarly, (double_small_number 100) *is* 200.
18:49:24 <shachaf> It doesn't return anything.
18:49:30 <japage> ok
18:49:32 <shachaf> double_small_number returns 200.
18:49:41 <japage> hmmm
18:49:42 <shachaf> But (double_small_number 100) is just a number.
18:50:06 <japage> ok, i am sure this symantic will make more sense to me as I go along
18:50:17 <harryflin> What the buck ya sayin'
18:50:24 <stevejb> hello, I am fairly new to haskell, and trying to get a module going which uses the accelerate library. http://hpaste.org/90431
18:50:27 <stevejb> what do I need to get started?
18:50:55 <shachaf> It looks like you already got started.
18:51:17 <harryflin> Partinks spee spaga speel scrap.  Ruda Trooda.  Ejection request.  Heffy the jello wup.  Juffo-wup!  rab locid rebbasmoth.  The Proteus Animal Plannable.  Poo da Boo!  need 10-15 people straight  Groaning my grurch nords.  Ruh ninna knaw knife
18:51:20 <harryflin> agrillio mellish.  Blakes my bog.  kedda mah go go mageezik  Renna manuck to the ruthafied sneffal  The Rump Shaking Rider Crew - Fuck You!  Wren a men a menna menna moo, filling my jolts and filling my shoe, plenk a  peek a pokie zal nawl knife
18:51:22 <harryflin> Shaar nag lililly linomp nip.  Many mini minotaur taurs, hate tar tar sauce.  I am a robibbob meme.  Have you ever thought about where the bird goes?  Squirnish Mernish.  Jelly jolaggalan joo!  Chuh lap lap rillip.  Oh I grew three years.  I'm old now.
18:51:24 <harryflin> Does anyone heck teck the rooga beega bagga?  Hebber master hoon a ferr fee.  Hilly a mackhole.  The shiny dot in the middle of a liddle light, of the middle of a lep lep lains!  Gotta get that schit ass shcrap  biteoad.  Ruproudj a malef loo
18:51:25 --- mode: ChanServ set +o shachaf
18:51:26 <harryflin> Moistie bather.  riberian schmecklef  Mulla Malee loo lup the new flood wars.  Chuddy dip, chuddy dip, chuddy microchip.  Bucka lucka loo, bucky lucky blay.  Bucka lucky blay lee.
18:51:28 <harryflin> Burpaline: The wonder world.  Salmy magoo goal greggats  Rump duh duh duh dump, duh duh duh demp doop dump, runna nuh nah  Riggity ass gaggags  i nick  Roddan raldwell  Roady carewell reggal mahole  Rup tup shmelly smelly shmebb ub.  Roady farewell rose bose mahaggal.  A pocahontas watch
18:51:29 <harryflin> Blubbity ash hoosh her mellopath.  a Maticake for my buddy andy  Oh we-heh-heh-hell I'm thinking about the greg nargs, I'm thinkin about you!  End midal too walkin' with a dolphin.  I went up that street, you went up another street, we all up the presidio.  I'm goin out with arsenio!
18:51:30 --- mode: shachaf set +b *!*reggal@112.145.53.*
18:51:30 --- kick: harryflin was kicked by shachaf (harryflin)
18:51:35 --- mode: shachaf set -o shachaf
18:51:54 <stevejb> shachaf: I am getting a few import errors
18:52:07 <stevejb>     Not in scope: type constructor or class `Vector'
18:52:07 <stevejb>     Perhaps you meant `Acc.Vector' (imported from Data.Array.Accelerate)
18:52:09 <shachaf> stevejb: No one can help you with your errors if you don't say what they are. :-)
18:52:15 <stevejb> :)
18:52:24 <stevejb> shachaf: fair enough
18:52:37 <stevejb> I am trying to :l this from ghci
18:52:38 <shachaf> OK, you probably need to import a module that has Vector.
18:52:51 <shachaf> There are several different ones, so you should probably figure out which one you want.
18:53:00 <stevejb> Yeah, I probably want the Acc.Vector
18:53:17 <shachaf> Oh, it has its own Vector?
18:53:28 <shachaf> Then just write Acc.Vector, like you said.
18:53:58 <hashcat> or just make "type Vector = Acc.Vector"
18:54:23 <shachaf> hashcat: ...Or just import Vector unqualified. No need to make a type synonym either way.
18:54:50 <stevejb> shachaf: you mean import Data.Array.Accelerate unqualified?
18:54:54 <hashcat> yes, it's just my lazy way
18:55:38 <shachaf> stevejb: Or at least "import Data.Array.Accelerate (Vector)".
18:55:55 <shachaf> stevejb: You should read about how imports and modules work in Haskell. Then you'll understand.
18:56:22 <stevejb> shachaf: I think I will do that. This is my first Haskell project. Before this I have just been playing with ghci
18:56:44 <bergey> Accelerate is a tricky import, because it has some things (:. Z) that are a pain to type qualified.  But it also has a lot of names that are shared with the Prelude.
18:56:53 <shachaf> Did you see Simon Marlow's slides on Accelerate?
18:57:15 <stevejb> yes, I have seen those. Perhaps I should just work through those step by step
18:57:28 <shachaf> http://community.haskell.org/~simonmar/slides/cadarache2012/
18:57:30 <shachaf> Ah, OK.
18:57:45 <stevejb> shachaf: thanks.
18:57:57 <stevejb> I have pre-ordered his book as well
18:58:35 <stevejb> anyway, thank you for the help
19:10:42 <vegberg> gen <- newStdGen
19:10:45 <vegberg> Why does this give me a parse error?
19:10:52 <Demos> where is it
19:11:18 <ion> vegberg: Too little information. Pastebin the code and the error message.
19:11:37 <vegberg> http://pastie.org/8080831
19:11:47 <Demos> for example if you have a case in a do you need like x > 2 -> do gen <- stdGen
19:12:20 <ion> You can only use the <- syntax in a do block, and you can only use a do block where expressions are allowed.
19:12:32 <vegberg> Ah.
19:13:29 <japage> if i let a = [[1,2],[3,4]], why does haskell not like [[]]:b? im appending a list, but it seems to be checking the contents of the list,
19:13:55 <Demos> vegberg, the <- operator is specific to do notation
19:14:06 <ion> > let b = [] in [[]]:b
19:14:07 <lambdabot>   [[[]]]
19:14:27 <ion> > let b = [[["hello"]]] in [[]]:b
19:14:28 <lambdabot>   [[[]],[["hello"]]]
19:14:56 <japage> lambdabot: botsnack
19:15:02 <YakiObon> Sup People.
19:17:02 <japage> ion: im feeling more broken, but your examples are very interesting for me to consider
19:17:51 <ion> @type (:) `asAppliedTo` [[]]
19:17:52 <lambdabot> [[a]] -> [[[a]]] -> [[[a]]]
19:18:18 <ion> japage: The second argument needs to have the type [[[a]]] if the first one has the type [[a]].
19:19:19 <japage> ion: thanks, im catching on now.
19:20:41 <japage> let a = []
19:20:57 <japage> nvmd, sorry
19:24:58 * tabemann decided to try implementing Data.List.Strict anyways, and is finding that many things in it have to be implemented non-obviously if they are to operate in O(1) stack space
19:26:11 <tabemann> (and many things that have only one function in Data.List will have multiple functions depending on exactly how one wants them to operate and what trade-offs one is willing to make)
19:29:58 <tabemann> (why must map involve converting a strict list to a lazy list while *reversing* it, and then simultaneously taking that lazy list and converting that back to a strict list, reversing it again, just to fit in O(1) stack space...)
19:32:57 <CaptainK> anyone know of Haskell on TinyCore?
19:33:14 <tabemann> (hmm... using a strict list for the intermediate *would* work, but then the list would actually have to be built, whereas using a lazy list would allow GHC to optimize it away...)
19:33:35 <jmcarthur> tabemann: no, laziness doesn't allow it to optimize it away here
19:34:42 <jmcarthur> tabemann: the reversed accumulator in a tail recursive map is constructed in one pass and deconstructed in another. there is just no way around it
19:35:41 <jmcarthur> tabemann: evidence of this is that the first element of the result is the *last* element you put on the reversed list, so you have to have at least constructed the entire thing just to get to that point
19:35:56 <tabemann> tis true
19:36:28 <jmcarthur> tabemann: you are really just emulating the stack
19:37:21 <tabemann> I know I am, but the problem is the runtime will complain if you run over the limit defined for the stack, whereas I have 8 gigs of heap available on my machine, at least minus the amount taken up by firefox
19:38:09 <tabemann> 8 gigs of RAM, that is; but swap isn't worth considering as when that gets used it's time to start killing processes
19:38:13 <jmcarthur> yeah
19:39:08 <jmcarthur> but the stack will still generally be faster
19:39:23 <japage> one day the speed of persistent storage will be just as fast as what we know as ram
19:39:30 * tabemann is used to trading heap for stack
19:39:57 <tabemann> s/heap for stack/stack for heap
19:40:13 <tabemann> japage: I highly doubt it
19:40:13 <dolio> You can increase the stack size.
19:40:14 <jmcarthur> tabemann: the Core library in ocaml does the first 1000 or so elements non tail recursively for speed then switches to a tail recursive version after that to avoid overflowing the stack
19:40:21 <dolio> Or put limits on the heap size.
19:40:54 <tabemann> japage: even RAM is a limiting factor on performance, when compared to cache
19:41:08 <jmcarthur> s/in ocaml/(alternative to the ocaml standard lib)/
19:41:11 <tabemann> ocaml-extlib?
19:41:12 <japage> tabemann: true, true
19:41:14 <dmp1ce> I'm playing around with Scotty and I'm not sure why I'm getting errors on the last line of this program: http://hpaste.org/90434
19:42:00 <jmcarthur> tabemann: https://github.com/janestreet
19:42:05 * japage back to learnin' me a haskell
19:42:11 <tabemann> trying to implement strict lists is making it so obvious how nice laziness really is
19:42:47 <jmcarthur> tabemann: in particular, https://github.com/janestreet/core_kernel/blob/master/lib/core_list.ml#L413
19:43:28 <jmcarthur> tabemann: so i guess it does the first 5000 elements non tail recursively
19:43:39 <jmcarthur> tabemann: since it's 1000 iterations of an unrolled loop
19:43:45 <dmp1ce> I added a '$' and now I'm getting this error "Couldn't match expected type `Text' with actual type `[a0]'"
19:44:05 * tabemann is looking at janestreet's code, and is noting that they *really* optimized their map
19:44:32 <jmcarthur> it's an important function :)
19:44:44 <johnw> dmp1ce: I believe you need to use <> instead of ++ there
19:44:54 <johnw> ++ is for lists, but you want to append Texts
19:45:42 <tabemann> I never used janestreet's library, but always used just the standard libs and extlib, and simply put up with using rev_map whenever he mapped something and didn't care about order, and rev (rev_map ...) when he did
19:45:50 <tabemann> s/he/I
19:46:31 <jmcarthur> i have never really used the ocaml standard library seriously
19:47:26 <dmp1ce> johnw: <> is not in scope.  Where do I get <>?
19:48:00 <tabemann> coming to Haskell I get the impression that the libraries that come as part of the Haskell platform are much more... complete than the OCaml standard libraries
19:48:06 <mm_freak> dmp1ce: Data.Monoid
19:48:28 <tabemann> no wonder Jane Street created their own
19:48:50 <jmcarthur> i feel like OCaml and its libraries are perpetually incomplete
19:49:49 <tabemann> there's a lot of things that seem like they *could* have been done in OCaml but weren't
19:50:41 <tabemann> there's no reason why OCaml couldn't've used monads and monadic IO despite being a impure, strict language (note that someone actually created an extension to OCaml that added do syntax)
19:51:33 <Demos> but what is the point....
19:51:35 <jmcarthur> tabemann: Async is faux monadic, at least
19:51:53 <jmcarthur> tabemann: Jane Street uses a lot of monads
19:51:55 <dmp1ce> <> worked.  Thank you.
19:52:07 <tabemann> Demos: that you can treat side effects as first class values
19:52:10 <jmcarthur> not as many as one would use regularly in haskell, though
19:52:57 <tabemann> I probably should've looked more at Jane Street's work than I did
19:53:32 <Demos> well at that point you may as well use haskell!
19:53:43 <jmcarthur> some people like strictness
19:53:46 <jmcarthur> some people even like impurity
19:54:26 <Demos> I like perl!
19:54:36 <tabemann> the big advantage I've heard people say that strictness has over laziness is that one can much better predict the behavior of one's code, both in time and in space
19:54:50 <jmcarthur> tabemann: i disagree with that claim, personally
19:54:55 <tabemann> so there's people who specifically like strictness better because of that, not because they don't know better
19:55:03 <jmcarthur> tabemann: the people who say such things are people who are not used to thinking about anything but strict code
19:55:11 <jmcarthur> *are usually
19:55:24 <vegberg> How can I compare a char from a list of chars?
19:55:43 <tabemann> do you want to search for a char in a list of chars?
19:55:43 <vegberg> Or, to a list of chars
19:55:45 <Demos> I think that you want lazy 50% of the time
19:55:50 <jmcarthur> vegberg: i don't know how to interpret that question. you have a char and a list of chars. what are you trying to compare?
19:55:51 <Demos> and strict the other 50%
19:55:52 <applicative> vegberg: you want to find if it is in the list?
19:56:03 <tabemann> Demos: that's the impression I get from looking at Haskell myself
19:56:04 <jmcarthur> Demos: i don't think it is so clear cut
19:56:13 <vegberg> Yes, applicative and tabemann.
19:56:17 <applicative> vegberg: or if it comes before after or among them
19:56:20 <tabemann> use Data.List.find
19:56:28 <applicative> @type find
19:56:30 <lambdabot> (a -> Bool) -> [a] -> Maybe a
19:56:39 <Demos> isnt there an elm function someplace
19:56:53 <applicative> @type elem
19:56:53 <lambdabot> Eq a => a -> [a] -> Bool
19:57:06 <applicative> > elem 'a' "California"
19:57:07 <lambdabot>   True
19:57:30 <applicative> > find (== 'a') "California"
19:57:30 <lambdabot>   Just 'a'
19:57:40 <vegberg> Ah, thank you.
19:57:43 <Demos> >'a' `elem` ['a','b','v']
19:57:48 <tabemann> jmcarthur: I get the impression that in many places laziness is really useful, but also opens the possibility for classes of maddening bugs that didn't exist before
19:58:05 <jmcarthur> tabemann: i feel the same way about strictness
19:58:06 <applicative> vegberg: elem is usually used infix like Demos demoed
19:58:41 <jmcarthur> tabemann: e.g. you can't just port lazy code to a strict language, as you are currently discovering
19:58:47 <Demos> well like I failed at demoing
19:58:54 <tabemann> jmcarthur: I must be just so used to the strict style of coding, hence things like my obsession with tail recursion
19:58:54 <jmcarthur> tabemann: and if you aren't used to thinking about strictness, it's not going to be clear why
19:59:04 <applicative> > 'a' `elem` ['a','b','v']
19:59:05 <lambdabot>   True
19:59:07 <Demos> porting strict to lazy is nontrivial as well!
19:59:13 <jmcarthur> Demos: sure!
19:59:42 <jmcarthur> Demos: my point is just that i don't think one is inherently harder to understand than the other
19:59:52 <Demos> I specificly decided to learn haskell because it was the most different, I tried F# but it was too easy to write imparative code
20:00:17 <Demos> jmcarthur, well in terms of how you go about translateing code to ops I think strict is way eaiser
20:00:19 <jmcarthur> Demos: strict is actually pretty useless without some sort of non-strictness, and vice versa
20:00:24 <Demos> but in reasoning about you are right
20:00:24 <applicative> haskell would be easier if things like newSTRef and readSTRef werent so long..
20:00:46 <Demos> jmcarthur, you mean things like short circuit eval?
20:00:52 <applicative> i mean, imperative nonsense would be easier in haskell
20:00:57 <jmcarthur> Demos: that is an example, sure
20:01:02 <tabemann> I chose Haskell as my latest thing to learn specifically because it wasn't going to bore me like working in yet another imperative (or even "functional with imperative features") language (usually with something OOish going on)
20:01:39 <jmcarthur> Demos: in a completely strict language, (if True then blah else undefined) would just fail. useless!
20:01:46 <Demos> the most recent language I have learned is actually perl, because I needed to build some glue scripts, and I really liked it
20:02:00 <Demos> yeah
20:02:08 <tabemann> jmcarthur: but because such languages typically have at least "imperative features", they need the short-circuiting if
20:02:11 <dwcook> Strict languages usually give "if" as a special case
20:02:50 <tabemann> I still wonder why they special-cased "if" in Haskell, when they could have just defined a function ifThenElse :: Bool -> a -> a -> a
20:02:52 <applicative> it's a little strange to say its easier to 'predict the behavior' of imperative code, since Haskell code is basically a description of the behavior, of what is calculated
20:02:54 <jmcarthur> tabemann: that is my point. you can't have a strict language without at least some non-strict operations or some sort of control flow that could only otherwise be implemented with non-strict operations
20:03:14 <dwcook> tabemann, make it look nice I guess
20:03:59 <dwcook> Haskell seems to be big on that
20:04:01 <applicative> Robert Harper has a bizarre argument against the claim that 'if' is lazy; its something else, like exception handling
20:04:03 <tabemann> a lot of strict languages make && and || non-strict too
20:04:06 <dwcook> Infix operators are a pain to implement but they often look better
20:04:54 <tabemann> I read they did that because they wanted Haskell to "look like math"
20:05:00 <jmcarthur> tabemann: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#rebindable-syntax
20:06:09 * tabemann hasn't seen any language with anything like *that* before
20:06:44 * tabemann just noticed the rebinding if then else
20:07:21 <dwcook> Besides Haskell and the only ML variant I've played with (OCaml), I've not seen a language that allows defining your own infix operators either ‚Äì usually that's part of the language syntax
20:07:24 <jmcarthur> it makes sense. it's all syntax sugar anyway. why not be able to redefine it?
20:07:37 <jmcarthur> dwcook: agda, too
20:07:42 <dwcook> Ah yeah
20:07:43 * tabemann just thought of Agda
20:07:48 <tabemann> Agda allows insane operators
20:07:52 <jmcarthur> dwcook: also, unlike ocaml, haskell lets you define fixity
20:07:54 <Demos> ther eis a proposal to make if a function
20:07:54 <dwcook> Agda doesn't even need a special if then else
20:07:57 <jmcarthur> dwcook: and agda has mixfix craziness
20:08:12 <Demos> also is there an extension to let you use agda's _askfjd_ mixfix syntax?
20:08:20 <jmcarthur> in haskell? no
20:08:36 <tabemann> agda requires crap like extra whitespace everywhere to pull that off
20:08:42 <dwcook> Does mixfix have ambiguity issues? Seems to me it might
20:08:49 <dwcook> But they might do something clever I haven't thought of
20:08:50 <jmcarthur> i don't think the mandatory whitespace in agda is so bad
20:09:04 <jmcarthur> dwcook: one can always just use parens
20:09:09 * tabemann actually codes in Haskell with lots of whitespace, but just the idea of *requiring* it...
20:11:19 * tabemann wonders what people would do with it if they added extension(s) to Haskell allowing mixfixes (I know they already added one to allow Unicode everywhere, and even making Unicode versions of built-in syntax)
20:13:08 <tabemann> about fixity, that was something I never liked about OCaml (I know that Standard ML supports defining fixity, but its handling of numbers is unforgivable)
20:13:27 <dwcook> How does SML handle numbers?
20:13:50 <tabemann> dwcook: it has overloading of int versus float for built-in functions, but for your own code you can't do it
20:13:56 <dwcook> Oh, like OCaml
20:13:59 <tabemann> no
20:14:11 <dwcook> I might be thinking of the comparison operators actually
20:14:12 <tabemann> OCaml doesn't overload numbers for anything but comparison operators
20:14:31 <dwcook> Either way it does something magic and such magic is lame
20:15:19 <tabemann> OCaml and Standard ML in this department make a good argument why type classes are essentially a necessary feature in Haskell
20:15:26 <dwcook> Indeed!
20:15:35 <dwcook> That's one of the arguments I gave for why we should be studying Haskell instead of OCaml
20:15:44 <dolio> Just use modules amirite?
20:15:45 <dwcook> in our PL class
20:16:28 <dwcook> The gist of the argument they had against Haskell was something about its purity, I think
20:16:41 <applicative> i think modules are an excellent plan for Float v Int v Integer etc
20:16:52 <dwcook> and how that's weird to the imperative programmers they had been teaching
20:17:01 <tabemann> one could make an impure, strict language with type classes if one really wanted
20:17:38 <dolio> It was going to be called C++ '11, but then they decided against it.
20:17:44 <tabemann> hah
20:17:51 <dwcook> Haha
20:19:46 <Demos> lol@concepts
20:20:22 <Demos> I dont mind C++ actually, it is the lingua franca of game programming
20:20:28 <tabemann> having to add => here and there is much nicer than all the characters hanging off of numeric operators in OCaml and its magical comparison operators...
20:22:02 * tabemann dislikes C++ for making him use copy constructors, overloaded assignment operators, and passing around const references in lieu of actually being able to pass around arbitrary objects as first-class values (without undue copying expense)
20:23:02 * tabemann also dislikes it for making him implement abstract classes all over the place in lieu of first-class lexical closures
20:23:42 <shachaf> Sounds like the kind of thing that you want to do and the kind of thing that C++ is for aren't the same.
20:24:03 <Demos> it has both of those now, with && and [](){} syntax
20:24:15 <Demos> it is not very nice to use ofc
20:24:19 * tabemann doesn't trust C++11's closures
20:24:28 <Demos> and closures interact with manual memory management in funny ways
20:24:30 <shachaf> Anyway this channel isn't really for language bashing.
20:25:04 <tabemann> at least C++ doesn't have a stop-the-world garbage collector...
20:25:13 <edvardkk> haha :) more or less the same conversation as 24 hours ago
20:25:13 <tabemann> (I do miss OCaml's incremental garbage collector)
20:25:16 <Demos> no kidding
20:25:39 <Demos> unity3D is still using a really old and shitty version of mono with a bad GC, not stop the world I think but not very good
20:25:45 <Demos> and they do GAMES
20:25:56 <Demos> .net has a sweet GC
20:26:27 <Demos> could one do a lazy language with manual memory management?
20:26:32 <tabemann> lol
20:26:52 <tabemann> how would one manage one's thunks then?
20:26:52 <Demos> I am thinking no, unless you hate yourself
20:26:54 <c_wraith> Demos: it seems *really* hard
20:27:16 <Demos> mayyyybe with ref counting aggressively applied....
20:27:38 <Demos> but then cycles
20:27:52 <tabemann> reference counting gives you determistic memory management behavior at the expense of forbidding cycles
20:28:33 <Demos> yeah, I actually like it, writing a program and then being like well crap I have a memory leak in the GC.....
20:28:43 * Demos writes javascirpt
20:28:57 * Demos does not like it though
20:29:05 <edvardkk> but you, more or less, have to break it to do real work? (weakrefs, etc..)
20:29:09 <tabemann> the problem is that lazy languages *need* recursion, which would in itself be untenable with reference counting
20:29:55 <Demos> yeah it would be hell on earth, I mean using lasyness for performence reasons in a language like c++ is trivial
20:30:09 <Demos> *sometimes trivial
20:31:06 <tabemann> the main thing is that for many things, with what you're typically doing in C++, one probably wants the determinism that strictness gives
20:31:23 <tabemann> even if there are some areas in one's code that could be optimized away through laziness
20:31:25 <Demos> yeah
20:32:22 <Demos> yeah, I mean you still use lazyness to like avoid initializing large structures and whatnot, but it is lazyness in the form of like if(!p){p = new q}
20:32:53 <tabemann> I *could* for such a language see adding *explicit* laziness, but that's a different matter from being a generally lazy language
20:33:17 <dolio> Laziness is not non-deterministic.
20:33:17 <tabemann> there's languages that are mostly strict that still allow explicit laziness in places, such as Scheme
20:33:30 <Demos> may not be worth it though, just do what c# did and have a lazy<T> data type
20:33:40 <Demos> *ahem* class
20:34:40 <tabemann> dolio: strictly speaking no, but it does separate where you specify something from where it is actually evaluated to make figuring out just how things are evaluated non-obvious
20:36:08 <Demos> as far as seeing like this line has this performence it may as well be
20:40:45 * tabemann cannot imagine Haskell being used for realtime applications...
20:42:35 <Demos> that is kinda erlang's areas right?
20:43:23 <tabemann> yeah
20:43:37 <mray27> .
20:43:57 <carter> tabemann theres actually folks who use haskell for real time things
20:44:04 <carter> the trick is they use a DSL they compile :)
20:44:14 <Clint> real time things
20:44:43 <carter> though if its human time scale real time haskell is pretty good eoverall
20:44:53 <Demos> by real time we mean like missle control and whatnot right?
20:45:09 <carter> Demos unsafeFireTheMissilesIO
20:45:14 <tabemann> carter: does using Haskell as a compiler really count?
20:45:20 <carter> tabemann yup
20:45:23 <Demos> yes import Acme.Missles
20:45:42 <Demos> well if you are not linking in the runtime....
20:46:07 <carter> tabemann also (hopefully soonish) it'll be possible to runtime compile things and hook them in as normal haskell functions
20:46:15 <carter> well, its possible now
20:46:19 <carter> jsut less neat
20:46:55 <dolio> Missiles are pretty big. I bet you could fit a pretty powerful computer in there.
20:47:03 <carter> that too
20:47:11 <Demos> may as well jsut put 5 pidgens in there
20:47:16 <dolio> Well, depends on the type of missile, I guess.
20:47:38 <mm_freak> tabemann: at least not GHC haskell
20:47:52 <mm_freak> but then what carter said
20:48:05 <Demos> I have used hint to load haskell on the fly
20:48:10 <carter> i'm not talking about hint
20:48:14 <Demos> the produced executable was like 100MB though
20:48:31 <mm_freak> tabemann: using haskell as a compiler counts as long as you're using an EDSL
20:48:39 <mm_freak> it's actually a common pattern
20:49:03 <mm_freak> see 'accelerate', 'atom', ‚Ä¶
20:49:14 <Demos> but then you have the runtime in your emmited exe
20:49:29 <carter> mm_freak with the right wrapper hooks, and a bit of work, possible to use llvm to runtime Generate haskell calling convention  function pointers ;)
20:49:41 <carter> haven't started working on it yet
20:49:45 <carter> but its high up in my list
20:50:05 <mm_freak> carter: yeah, but if you compile haskell directly to the target, then it's probably not real-time
20:50:26 <carter> mm_freak not quite
20:50:55 <carter> one thing you could do is have GHC and the RTS be sort of your "OS"
20:51:05 <carter> and when you have latency sensitive things
20:51:10 <carter> block the scheduler on a core
20:51:22 <mm_freak> carter: even then it's not real-time, because haskell relies heavily on garbage collection and it's difficult to deliver any guarantees
20:51:28 <mm_freak> especially in a concurrent setting
20:51:35 <carter> mm_freak block the scheduler and static allocate
20:51:40 <carter> on a core
20:51:43 <carter> tis easy if you want to
20:51:48 <mm_freak> carter: static allocate?
20:51:51 <carter> yes
20:51:54 <carter> if you're doing "real time things"
20:52:00 <mm_freak> what does that mean?
20:52:02 <carter> you are also working on a fixed buffer
20:52:05 <carter> usually
20:52:19 <carter> mm_freak which things are you referring to?
20:52:36 <carter> :)
20:55:04 <monochrom> what does static allocate mean
20:55:35 <mm_freak> carter: i don't really know what you mean by "static allocate"
20:55:39 <Breadmonster> Guys?
20:55:43 <Breadmonster> I'm having a slight issue.
20:55:47 <Breadmonster> http://hpaste.org/
20:55:57 <Breadmonster> http://hpaste.org/90435
20:56:06 <mm_freak> carter: allocation and garbage collection is to haskell what stack frame allocation and calling is to C
20:56:13 <mm_freak> you can't really get rid of it
20:56:23 <Breadmonster> Results in a non-exhaustive pattern matching exceptopn.
20:56:58 <mm_freak> Breadmonster: you're not handling bal a []
20:57:09 <mm_freak> Breadmonster: if you use GHC, compile with -W
20:57:23 <Breadmonster> mm_freak, Yeah, just spotted that.
20:57:24 <mm_freak> it shows you the cases you missed
20:57:25 <Breadmonster> Thanks :)
20:57:29 <mm_freak> you're welcome
20:57:30 <Breadmonster> Oh, and that's awesome :D
20:57:53 <mm_freak> compiling with -W is a good idea in general
20:58:02 <mm_freak> carter: allocation and garbage collection is to haskell what stack frame allocation and calling is to C
20:58:18 <mm_freak> so i don't really know what you mean by "static allocate"
20:58:27 <mm_freak> hmm‚Ä¶
20:58:29 <monochrom> disconnected again
20:59:03 <mm_freak> IRC clients suck =)
21:00:41 <tabemann> <mm_freak> so i don't really know what you mean by "static allocate"
21:00:41 <tabemann> <mm_freak> hmmÖ
21:00:41 <tabemann> <monochrom> disconnected again
21:00:46 <tabemann> <mm_freak> IRC clients suck =)
21:00:59 <carter> mm_freak only for normally compiled haskell
21:01:41 <carter> sorry
21:01:47 <carter> "heres a fixed sized array"
21:01:47 <carter> "do stuff in this Fixed array / Region of memory"
21:01:53 <carter> tabemann thanks
21:01:53 <carter> this is what i get for turning off flood contorl earlier today :)
21:02:02 <mm_freak> carter: allocation and garbage collection is to haskell what stack frame allocation and calling is to C
21:02:11 <carter> mm_freak false
21:02:25 <carter> mm_freak i gave a talk on this last month :)
21:02:50 <mm_freak> well, i should clarify that i share a disease with many haskellers
21:02:52 <mm_freak> i assume GHC =)
21:03:02 <carter> https://vimeo.com/69025829
21:03:36 <carter> mm_freak strictly speaking, possible to write haskell code that doesn't yield to scheduler and doesn't allocate
21:04:03 <mm_freak> i see
21:04:14 <mm_freak> so it's actually a subset of haskell?
21:04:20 <carter> mm_freak not sure, haven't tried it
21:04:44 <carter> but theres examples of tight looped code which because it doesn't trigger the allocation counter, wont' yield to scheduler
21:04:57 <carter> hence why theres a compute counter thingy too thats now in head
21:04:59 <mm_freak> well, agda gets rid of the halting problem by only allowing total functions‚Ä¶  maybe by a similar restriction you could get real-time guarantees
21:05:33 <carter> mm_freak per se
21:05:38 <carter> simpler to have an EDSL that you compile
21:05:47 <carter> and run
21:05:49 <carter> either as its own thing
21:05:56 <carter> or as something you run via hooking into ghc
21:06:18 <mm_freak> ok, but then it's not really haskell itself‚Ä¶  that approach is already known and implemented (accelerate, atom and i think some special-architecture compilers like for FPGAs)
21:06:30 <carter> mm_freak read my words
21:06:37 <carter> i'm not saying "have ghc run from the shell"
21:06:37 <mm_freak> let me watch the video first =)
21:06:41 <carter> i mean "heres a function"
21:06:43 <carter> "call it"
21:06:55 <carter> haven't done that work yet
21:07:06 <carter> but its totally doable with the current ghc RTS design
21:07:45 <mm_freak> unfortunately i'm not that familiar with the RTS‚Ä¶  all i know is that it's based on STG and uses eval/apply
21:07:58 <carter> mm_freak wrong
21:08:02 <carter> it uses CMM
21:08:09 <carter> which is like a lower level version of C
21:08:15 <carter> STG gets turned into C--
21:08:30 <mm_freak> so it's STG, isn't it?
21:08:35 <carter> no
21:08:40 <carter> STG is an intermediate rep
21:08:57 <carter> C-- is the rep before code gen
21:09:05 <mm_freak> as far as i understand it, STG gets compiled to C-- and the RTS is basically a library that evaluates the C--
21:09:10 <mm_freak> high-levelly speaking
21:09:13 <carter> not really
21:09:23 <carter> the RTS is written in a mix of C and C--
21:09:32 <mm_freak> not "evaluates" in the sense of "interprets", but rather "calls"
21:09:46 <carter> again, not qtuie
21:09:51 <carter> the RTS IS
21:09:53 <carter> C and C--
21:10:53 <carter> it and normal code are mutually recursive friends :)
21:11:03 <mm_freak> yeah, that's what i mean
21:11:06 <carter> ok
21:11:14 <mm_freak> coroutines, basically
21:11:21 <carter> mm_freak not quite
21:11:40 <carter> or at least, depends on your definition of coroutines
21:11:59 <mm_freak> i know‚Ä¶  the STG scheme i used was:  the code gets compiled to a bunch of code chunks, which may call back into the RTS
21:12:18 <carter> ok, thats roughly true
21:12:26 <carter> the calling back to the RTS happens in certain primops
21:12:32 <carter> or when an allocation happens
21:12:59 <mm_freak> yeah, and then (at least in the threaded runtime) it's basically a back and forth
21:13:02 <mm_freak> just like coroutines
21:13:23 <mm_freak> right?
21:13:29 <carter> not quite
21:14:00 <mm_freak> rather like a library?
21:14:08 <carter> now i'm confusede :)
21:14:20 <mm_freak> does the RTS act as a library?
21:14:59 <carter> i mean, in a sense it is a library
21:15:08 <carter> but one that runs in parallel to your code
21:15:22 <carter> well, can run in parallel to your code
21:15:26 <mm_freak> well, it has to be a library, strictly speaking
21:15:46 <carter> depends on the definitons of words
21:15:47 <carter> also i'm tired :)
21:15:47 <mm_freak> as it gets compiled only once and then just linked into every executable =)
21:15:48 <Clint> if it ends in .a, it's a library
21:16:29 <carter> if thats a defn of a lib, sure
21:16:40 <Clint> i didn't say "iff"
21:16:56 <carter> sure
21:17:07 <carter> mm_freak i do make a mistake in the talk which i corrected in the notes
21:17:11 <mm_freak> anyway, when you write "f(); g();", then in general f gets called, returns, g gets called, returns‚Ä¶  the most intriguing part of STG is that in an equivalent code f would jump to g directly
21:17:23 <carter> i said the safe c ffi uses a process rather than a thread
21:17:25 <mm_freak> and that's not even an optimization =)
21:17:33 <carter> mm_freak well, yeah, CPS is nice
21:17:58 <carter> the first half of my talk was sort of doing a sketched out derive CPS from a stack machine interpeter
21:18:45 <mm_freak> i really wonder why most languages are still compiled to a call-stacked scheme
21:19:17 <carter> mm_freak ghc is too
21:19:21 <carter> its just we can optmize away mroe
21:19:29 <carter> beause its CPS
21:19:54 <mm_freak> haskell code uses a call stack?  i thought only the FFI does
21:20:02 <carter> mm_freak ghc uses the stack
21:20:13 <mm_freak> yes, but not as a call stack, AFAIK
21:20:18 <carter> mm_freak it does
21:20:24 <mm_freak> when?
21:20:25 <carter> i can assure you of that
21:20:31 <carter> when you do a fun call
21:20:39 <carter> it puts the return pointer  in the return slot
21:20:47 <carter> saves registers
21:20:54 <carter> well, saves register
21:21:13 <carter> then puts the return location in the return  slot, then puts args in registers
21:21:25 <carter> then spills any extra args on the stack
21:21:30 <carter> and jumps
21:21:30 <mm_freak> say you write f (g x) and compile without optimizations‚Ä¶  does g actually return to the caller?
21:21:43 <carter> mm_freak whatever happens when you CPS
21:21:52 <mm_freak> in CPS it definitely doesn't
21:22:12 <mm_freak> because then it looks more like g x f
21:22:25 <carter> mm_freak its very easy to have a Klambda and KClosure in addution to lambda and closure
21:23:02 <mm_freak> i should probably revisit GHC some time, but it's huge
21:23:04 <carter> mm_freak i'm talking about how C-- works
21:23:09 <carter> if you want ot see how fun calls work
21:23:11 <carter> look there
21:23:38 <mm_freak> but wait‚Ä¶  haskell functions are not in direct correspondence to C-- functions, right?
21:23:54 <carter> mm_freak they are bye version of compilation
21:23:58 <carter> injectively
21:24:01 <carter> not bijectively
21:24:22 <carter> every haskell function
21:24:26 <carter> that isn't inlined away
21:24:36 <carter> is reprsented by 1 or more c-- functions
21:25:10 <carter> always
21:25:17 <carter> else they wouldn't be compilable :)
21:25:26 <mm_freak> ok, let me watch your video‚Ä¶  i might get the GHC source code again at some point =)
21:25:34 <mm_freak> right now it's too overwhelming for me
21:25:51 <carter> mm_freak its ok
21:28:21 <Aetherspawn> I wonder if it'll be easier to build ghc w/ clang on windows since it can use the native toolchain
21:28:22 <carter> the video link also has a link to the slide deck and demo code
21:28:29 <carter> Aetherspawn ask Ralith
21:28:41 <thoughtpolice> mm_freak: the STG machine conceptually has a stack, when you evaluate a closure you push the continuation on the stack and evaluate to WHNF. that's an easy way to think of it
21:29:20 <thoughtpolice> if you want a decent overview of the whole execution model, Max Bolingbroke wrote an amazing page about the whole pipeline: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode
21:29:25 <Aetherspawn> be thankful that currying is a language feature
21:29:37 <mm_freak> Aetherspawn: it's not
21:29:39 <Ralith> Aetherspawn: ghc likely assumes a GNU platform, and certainly assumes GNU build tools for bootstrapping
21:29:42 <mm_freak> it's a feature of the base library
21:29:50 <mm_freak> and most other haskell libraries
21:30:08 <mm_freak> thoughtpolice: thanks, that's really helpful
21:30:12 <Aetherspawn> Uh, are you sure.
21:30:27 <thoughtpolice> Aetherspawn: are you referring to Clang compiled by Visual Studio?
21:30:30 <Aetherspawn> Oh, actually, what I meant was partial evaluation
21:30:32 <mm_freak> thoughtpolice: anyway, the STG as originally proposed by SPJ is actually (call-) stackless
21:30:34 <Aetherspawn> thoughtpolice, yes
21:31:04 <thoughtpolice> mm_freak: yeah, STG today is a bit different. there's not really an updated categorical description unfortunately
21:31:05 <carter_> sorry, missed what was just said
21:31:25 <Aetherspawn> and the whole "be thankful" thing was leading up to me posting a C++ implementation of currying which I had lying around :P http://hpaste.org/90437
21:32:00 <mm_freak> Aetherspawn: an "implementation" of currying?
21:32:17 <mm_freak> Aetherspawn: do you mean closures?
21:32:26 <Aetherspawn> uh, currying/partial evaluation
21:32:33 <Aetherspawn> Im probably calling it wrong when I say currying
21:32:34 <mm_freak> because currying is just a style =)
21:32:36 <thoughtpolice> Aetherspawn: tldr - no. it won't be easier. i don't even know if GHC will even build on Windows using Clang at the moment. i base this on the fact i'm doing the work to fix it for Clang right now, and Clang there is still somewhat experimental :)
21:32:45 <Aetherspawn> thoughtpolice, :)
21:32:50 <Ralith> Aetherspawn: haskell doesn't have partial evaluation
21:32:51 <Aetherspawn> and dang
21:32:51 <thoughtpolice> Aetherspawn: regardless, the easiest way to build GHC on windows is just to use GCC, i promise :P
21:33:06 <thoughtpolice> it's surprisingly simple to get a Windows build up and running, actually
21:33:16 <Aetherspawn> it fails about half way each time for me
21:33:19 <Ralith> Aetherspawn: partial evaluation, currying, and partial application are all completely different things.
21:33:20 <Aetherspawn> even w/ a clean system
21:33:27 <thoughtpolice> Aetherspawn: in libgmp?
21:33:38 <Aetherspawn> maybe, actually.
21:33:40 <thoughtpolice> if so, just rerun 'make' :P that's some weirdo bug i never got a chance to track down
21:33:47 <thoughtpolice> the build will pick up appropriately
21:33:52 <mm_freak> although WHNF is pretty much "partial evaluation"
21:33:54 <thoughtpolice> it's something to do with the parallel build, i think
21:34:03 <Aetherspawn> oh and when I use -j4
21:34:03 <mm_freak> so haskell has that one
21:34:08 <Aetherspawn> I dont get console output sometimes
21:34:32 <thoughtpolice> Aetherspawn: yeah, same thing i saw. just rerunning 'make' should work. i don't know what's going on there, I just happen to coincidentally have windows machines to build with
21:34:36 <carter> mm_freak partial evaluation is very different...
21:34:38 <thoughtpolice> i mostly use Linux, and i've never seen that behavior
21:34:46 <carter> its kinda like whnf
21:34:50 <carter> but‚Ä¶. not really
21:34:55 <thoughtpolice> Aetherspawn: sorry that's such a dumb answer :P
21:34:59 <Aetherspawn> lol
21:35:03 <mm_freak> carter: i don't know if there is a formally defined term "partial evaluation"‚Ä¶  if yes, i'm not familiar with it
21:35:18 <carter> whnf isn't a good optimzier at least :)
21:35:21 <carter> ish
21:35:23 <carter> well
21:35:26 <mm_freak> carter: but i love your "not quite" answers =P
21:35:39 <carter> mm_freak then you'll love my talk
21:35:47 <carter> i somehow watched 30min of it yesterday
21:35:52 <thoughtpolice> Aetherspawn: but anyway, i eventually have plans to get Clang/MinGW building GHC on Windows, but not right now
21:36:02 <Ralith> mm_freak: partial evaluation is a well-defined thing with little connection to evaluation to WHNF
21:36:11 <thoughtpolice> Aetherspawn: and due to some bugs I filed with the LLVM guys, it won't work until LLVM 3.4 (or unless you use the SVN version)
21:36:12 <mm_freak> i see
21:36:12 <Ralith> mm_freak: https://en.wikipedia.org/wiki/Partial_evaluation
21:36:28 <Aetherspawn> Is there any plans for getting the native toolchain working eventually
21:36:34 <Aetherspawn> using windows link.exe from the VS terminal?
21:36:44 <mm_freak> i see
21:36:45 <thoughtpolice> honestly? i don't really think so.
21:36:46 <Aetherspawn> (through clang ofc)
21:36:49 <mm_freak> so it's basically an optimization
21:36:50 <thoughtpolice> oh, well, maybe
21:36:50 <carter> Aetherspawn if you volunteer, yes
21:36:51 <thoughtpolice> i dunno
21:37:18 <thoughtpolice> i could probably make up a million reasons why it might not work, but i honestly don't know. it's likely not a trivial amount of work in the slightest however
21:37:30 <mm_freak> carter: reminds me of myself when i try to communicate the virtues of abstract algebra for programming =)
21:37:43 <carter> mm_freak : write faster bug free code
21:37:47 <carter> next question :)
21:37:51 <thoughtpolice> i haven't regularly developed anything other than exploits on windows for years now, so i can only imagine there's *something* that would turn up :P
21:37:51 <Ralith> mm_freak: it's a very powerful optimization, yes
21:38:28 <mm_freak> Ralith: applied to haskell, would you call CAF pre-evaluation and type-class specialization instances of partial evaluation?
21:38:43 <thoughtpolice> Aetherspawn: we do require various linking toolchain features, but i think most of those are pretty reasonable, things like 'undefined symbol will be resolved at dynamic-link time, so don't cry about it' etc
21:38:55 <thoughtpolice> stuff like that
21:39:03 <Aetherspawn> gotcha.
21:39:18 <mm_freak> carter: but you get questions like, "what's so great about associativity?", which aren't as straightforward to answer
21:39:23 <Ralith> mm_freak: I'm not familiar with CAF pre-evaluation, but type-class specialization (and constant propogation and specialization in general) is a subset of what a real partial evaluator will do.
21:39:35 <carter> mm_freak faster bulk matrix multiply
21:39:43 <Ralith> mm_freak: a partial evaluator will specifically handle *arbitrary* static data for *arbitrary* programs.
21:39:53 <Ralith> not just, say, typeclass instances.
21:40:30 <mm_freak> carter: the big picture‚Ä¶  i'm actually writing an introduction to abstract algebra for programmers, in which i go into general associativity a bit
21:40:32 <Ralith> the classic example would be to partially evaluatate an interpreter against source code to produce an efficient native program
21:40:40 <carter> mm_freak linear algebra for computer graphics
21:40:47 <thoughtpolice> all that, and only for the low, low cost of 10,000,000x slower compile times and all your RAM being eaten :P
21:40:52 <Ralith> this is something Idris has exciting potential to leverage for zero-overhead EDSLs
21:41:06 <Ralith> mm_freak: see http://www.cs.st-andrews.ac.uk/~eb/writings/icfp10.pdf
21:41:08 <mm_freak> carter: i could upload the current draft, if you wish
21:41:23 <carter> cool
21:41:26 <carter> not right now :)
21:42:06 <mm_freak> it's in its infancy‚Ä¶  i covered the motivation (which is a funny anecdote), an introduction into algebraic design patterns and then one of the most important structures: monoids =)
21:42:22 <mm_freak> Ralith: thanks
21:43:08 <thoughtpolice> i should actually take a look at Idris one of these days
21:43:39 <mm_freak> idris is great, but not quite ready for application development yet
21:44:22 <thoughtpolice> it has a java backend right? practically enterprise dependently typed programming, right there
21:44:45 <carter> it could totally replace scala !
21:44:52 <carter> fewer null values too
21:44:55 <Ralith> \o/
21:44:58 <mm_freak> Ralith is working on an LLVM backend, which i hope will be ready soon
21:45:08 <Ralith> I'm hoping to get it merged within the week
21:45:12 <carter> mm_freak you can already use it
21:45:18 <carter> just needs like a few mroe primops
21:45:26 <carter> Ralith did switching to llvm-general speed up the dev?
21:45:36 <carter> or was that just a weekend of work?
21:46:03 <mm_freak> yes, i know it's usable‚Ä¶  as soon as i get to work on another simple project i will give it a shot
21:46:04 <Ralith> it's the third time I've written it so I've hashed out most of the things that might get me tangled up
21:46:51 <Ralith> llvm-general also makes things easy, but most of it's just that I've (hopefully) worked out all the basic issues
21:46:58 <thoughtpolice> when i read about the MPS i thought of giving it a shot for integrating into the Idris runtime
21:47:13 <thoughtpolice> for a better GC. but it's probably not really that important at the moment
21:47:27 <carter> MPS = the thing that was open soruced recently?
21:47:28 <Ralith> thoughtpolice: to the contrary
21:47:31 <Ralith> good GC would be wonderful
21:47:44 <thoughtpolice> carter: yes
21:47:58 <thoughtpolice> Ralith: i spent some time looking at the GC when Edwin did the major rewrite, but never looked since then
21:48:05 <thoughtpolice> i assume your backend just links with the same RTS?
21:48:06 <Ralith> carter: the previous iteration was actually more functionally complete, but also somewhat messier and less maintainable, and at this point I'm pretty sure it had some latent bugs
21:48:27 <Ralith> thoughtpolice: no, the C backend RTS is very non-general
21:48:41 <thoughtpolice> oh, how do you handle GC in the LLVM backend? shadow stacks?
21:48:48 <Ralith> right now, boehm
21:48:55 <thoughtpolice> ah
21:48:56 <Ralith> I haven't had the time/energy to write my own GC
21:49:08 <Ralith> which is part of why I'm excited to hear someone else interested
21:49:17 <thoughtpolice> i played with the LLVM shadow stack mechanism once, it's actually not that difficult to get working
21:49:24 <Ralith> my main interest is attacking the lower-hanging fruit of unboxing and efficient codegen
21:49:42 <Ralith> ultimately I want a real type-directed tagless precise GC
21:49:50 <Ralith> but LLVM lacks the infrastructure to do that efficiently
21:50:01 <Ralith> so some extensive work will be necessary there
21:50:11 <thoughtpolice> yes, its suitability for more advanced GC is rather poor unfortunately
21:50:23 <Ralith> I have a plan worked out to address that
21:50:24 <thoughtpolice> an MPS tie in would be pretty difficult. maybe less difficult with the C backend. i'm not entirely sure
21:50:30 <Ralith> but, again, lack of time
21:50:34 <thoughtpolice> i should spend some time looking at how OpenDylan does this
21:50:41 <Ralith> even with boehm the LLVM backend has tested out at almost twice as fast as the C backend
21:50:55 <Ralith> or was it slightly more than?
21:51:09 <thoughtpolice> it should also be possible to use Boehm to get a precise GC too
21:51:20 <thoughtpolice> using its typed_array interface.
21:51:32 <Ralith> and I plan to do some escape analysis soon to reduce allocation dramatically
21:51:32 <thoughtpolice> that may actually not be a lot of work, but you've probably explored it
21:51:38 <Ralith> I haven't
21:51:50 <thoughtpolice> Ralith: just a sec
21:51:55 <Ralith> so far my approach to GC has just been 'make it work'
21:52:10 <Ralith> as you inferred, it's not *necessary* to have a state of the art GC at present
21:52:25 <Ralith> but it's certainly highly desirable
21:53:28 <carter> Ralith your'e using C calling convention currently?
21:54:03 <Ralith> carter: llvm's fast convention
21:54:15 <Ralith> dropping out to C when necessary for libc and such
21:55:18 <carter> Ralith any reason not to use the ghc one?
21:55:50 <Ralith> because I don't expect it to be remotely appropriate
21:56:01 <carter> explain?
21:57:07 <carter> Ralith granted, you'd have to do stack spilling...
21:58:19 <Ralith> carter: see http://llvm.org/docs/LangRef.html#calling-conventions
21:58:55 <carter> Ralith yeah, you have to do your own stack spilling
21:58:59 <thoughtpolice> hah, nice, they have a HiPE calling convention now
21:59:35 <Ralith> a specialized calling convention may be worth exploring in the future, but wading around in ill-defined ghc-specific stuff is only going to make my job harder for now
22:00:03 <Ralith> right now my first optimization priority is to get things to actually use registers for more than just pointers in the first place
22:00:09 <thoughtpolice> i'd agree. LLVM supporting GHC's calling convention is nice if you know exactly what that means, but it also comes with a lot of complexity to juggle
22:01:26 <carter> Ralith https://github.com/llvm-mirror/llvm/blob/master/lib/Target/X86/X86CallingConv.td doesn't have 64 bit fast...
22:02:08 <Ralith> carter: I'm pretty sure fastcc on x86_64 is just C
22:02:44 <carter> C can do tail calls on 64 with the standard calling convention?
22:02:56 <carter> i swore It had its own ...
22:04:09 <Ralith> carter: just C for most purposes, that is.
22:04:35 <Ralith> fastcc is a general 'LLVM has permission to mess with this' flag
22:04:44 <carter> ok
22:04:51 <Ralith> I expect it has effects beyond the definitions you see there
22:04:57 <Ralith> such as enabling TCO transforms
22:05:06 <p0a> Hello euclid x y = floor (x / y) : euclid y (mod x y)
22:05:06 <p0a> ^ This does not work, what is wrong?
22:05:15 <p0a> (I Also have a case euclid x 0 : [])
22:05:27 <p0a> <- haskel beginner
22:05:40 <dmwit> You can't divide integers with (/); or you can't get remainders or non-integers with mod.
22:05:43 <dmwit> Your choice.
22:05:56 <dmwit> s/remainders or/remainders of/
22:06:05 <p0a> How can I divide integers?
22:06:09 <dmwit> div
22:06:19 <dmwit> However, since you are using both div and mod, you might like divMod.
22:06:34 <Ralith> carter: you can think of 'fastcc' as 'unspecified'; it's theoretically always the best choice when you don't need to conform to anything else
22:06:45 <carter> ok
22:07:03 <dmwit> Depending on how positive you're feeling, you may also like quot, rem, and quotRem.
22:07:08 <carter> Ralith  i think that part of the ghc convention is giving the right hooks for messing with the stack
22:07:17 <carter> or at least the way its used
22:07:38 <p0a> thanks dmpwit. Will look into divMod too (guess it returns both values)
22:07:57 <dmwit> Your guess is correct. =)
22:11:39 <p0a> Can a function take optional parameters?
22:12:18 <p0a> ah nvm I have googled it and it's not what I am looking for
22:14:08 <carter> Ralith looks like unless you're doing Floating point heavy codes using AVX2, not a big difference between the ghc 7.8 version of ghc calling convention and the c one
22:14:40 <mjrosenb> \o/ hashed-storage installed!
22:14:49 <mjrosenb> also, this is not #gentoo-haskell
22:16:23 <Ralith> carter: interesting
22:17:53 <p0a> I need to seperate a list from its last element
22:18:17 <p0a> anything other than reverse (drop 1 (reverse xs)) ?
22:19:14 <tabemann> you could do less allocation if you did take (length x - 1) x
22:19:21 <carter> Ralith compare https://github.com/llvm-mirror/llvm/blob/release_32/lib/Target/X86/X86CallingConv.td#L285 vs  https://github.com/llvm-mirror/llvm/blob/release_32/lib/Target/X86/X86CallingConv.td#L170
22:19:29 <carter> and the analogous bits for floats
22:19:46 <carter> Ralith is the idris windows problem related maybe to not using the Windows friendly C convention?
22:20:06 <Ralith> the windows problem is a segfault during code generation
22:20:30 <carter> ok
22:20:39 <MasseR_> tabemann: 'last'
22:20:43 <MasseR_> > last [1,2,3]
22:20:44 <lambdabot>   3
22:20:55 <Ralith> no generated code is being executed
22:20:58 <p0a> ah ha :D
22:21:01 <carter> how do we add lambdabot to a new haskell channel?
22:21:18 <carter> Ralith but when you call c code on windows,are you using the Windows calling convention?
22:21:28 <carter> https://github.com/llvm-mirror/llvm/blob/release_32/lib/Target/X86/X86CallingConv.td#L210
22:21:32 <tabemann> MasseR_: umm, that is kind of the opposite there
22:21:33 <p0a> MasseR_: Though I need the list without the last element, not the last element :)
22:21:41 <carter> or maybe i'm missing the point :)
22:21:54 <p0a> tabemann: I understood your reply. thanks
22:21:54 <tabemann> > let xs = [1, 2, 3] in take (length xs - 1) xs
22:21:55 <lambdabot>   [1,2]
22:21:59 <MasseR_> tabemann: Pfft, reading fail
22:22:13 <MasseR_> Too early in the morning
22:22:39 <MasseR> Especially since I even highlighted the wrong person
22:23:00 <Ralith> carter: the FFI bindings make no special effort to specify a calling convention. I assume that a mingw llvm uses the correct convention, because windows stdcall involves name mangling so the symbols probably wouldn't resolve properly otherwise.
22:23:19 <carter> ok
22:23:25 <Ralith> and in general the haskell platform seems to assume that mingw-gcc uses a compatible abi
22:23:28 <carter> ok
22:23:40 <carter> and the seg fault happens before running llvm to do anything?
22:24:06 <tabemann> night
22:24:58 <p0a> I want to map a list into a number
22:25:01 <Ralith> carter: the segfault happens while running LLVM.
22:25:15 <p0a> but the function that maps must have 2 numbers memory
22:25:22 <Ralith> given that we're not doing anything unsafe other than FFI, if it happened before running LLVM, it would certainly be a ghc bug.
22:25:28 <p0a> That is, the algorithm to make the list into a number depends on A, B, C and it starts with A = B = 1
22:25:28 <carter> ok
22:25:41 <p0a> C is the first element of the list, then the second et cetera
22:25:50 <Ralith> calling convention hijinks are plausible because the bug appears to involve staack corruption
22:25:59 <Ralith> but they don't make sense to me given the toolchain
22:26:27 <carter> Ralith ok
22:30:07 <p0a> Anything wrong with
22:30:15 <p0a> bezout Integer a => [a] -> (a, a)
22:30:16 <p0a> ?
22:30:34 <p0a> It's a function that takes a list and returns a tuple? :S
22:30:40 <Ralith> you forgot the ::
22:30:59 <p0a> But not in my original code... The error is 'Integer is applied to too many arguments'
22:31:07 <NemesisD> any of you guys familiar with the logic monad?
22:31:28 <Ralith> Integer isn't a typeclass
22:31:30 <NemesisD> i'm reading a paper on it and i'm curious if its a good choice for something i previously did the hard way
22:31:46 <martint> you might be thinking of Integral a => [a] -> (a, a)
22:32:15 <Ralith> or [Integer] -> (Integer, Integer)
22:32:36 <p0a> okay I thought it was just a shorthand
22:33:42 <p0a> Now it works, thanks. What of my previous question? I'd like to map a function to a list, but the function must have 'memory'. (In C for example that is achieved with the static keyword)
22:34:17 <p0a> What this means is that f(x) = a + b*x, and a, b should change accordingly to the value of x for the next element that is to be mapped...
22:34:33 <p0a> er, foldl probably.
22:34:49 <p0a> aha
22:34:54 <p0a> nevermind I figured it out :)
22:38:27 <bz> any idea how to install the llvm with a local llvm install?
22:40:28 <lpsmith> hmm, with stm,  if you are attempting a big transaction and it fails,  but you know you only have to roll the transaction back a little bit,  is there a way to do that?
22:40:48 <shachaf> Transaction as in STM?
22:40:58 <lpsmith> right
22:41:31 <p0a> Hmmm, not yet. Okay the algorithm is simple, I will describe it in pseudolanguage. f(x:xs) = { a = 1, b = 1; c = a + b*x; swap(a, b); b = c f(a, b, xs); }
22:41:50 <lpsmith> or is retry necessarily starting again from the beginning of the atomically block?
22:41:55 <p0a> As you see the problem is that f is first called with a list, but needs to call itself updating the a and b variables
22:42:03 <shachaf> lpsmith: I really doubt there would be anything.
22:42:19 <kurak0t> codes in this section does not work well in ghc http://learnyouahaskell.com/input-and-output
22:42:56 <arkeet> kurak0t: are you sure?
22:43:14 <lpsmith> It's not that important at the moment,  but I'm implementing split-tchan because as it turns out I kind of need tchans instead of chans,  and I'm wondering how to write sendMany
22:43:22 <arkeet> kurak0t: could you describe how you're trying to run the code?
22:43:26 <p0a> I have another idea, nevermind me
22:43:43 <lpsmith> http://hackage.haskell.org/packages/archive/split-channel/0.2.0.1/doc/html/src/Control-Concurrent-Chan-Split-Implementation.html#sendMany
22:44:19 <quicksilver> well, STM has nested transactions doesn't it?
22:44:55 <lpsmith> basically there is two steps,  forcing the spine of the list and turning it into and MVar stream,   and then inserting the chunk of stream into the channel
22:44:57 <quicksilver> you can have an orElse inside your transction
22:45:17 <lpsmith> basically the first step is guaranteed to succeed
22:45:23 <quicksilver> ( (small bit) `orElse` (what to do when that bit rolls back) ) >> (the rest of the transaction)
22:45:45 <quicksilver> so you can just roll back the (small bit)
22:45:59 <quicksilver> but you need to explicit delimit the parts with the combinators.
22:46:45 <lpsmith> in the STM world,  forcing the spine and turning it into a TVar list is guaranteed to succeed
22:47:02 <lpsmith> and it would be kinda preferable to do that first,  instead of second, IMO
22:47:27 <lpsmith> but if on off chance the send fails,  I don't really want to allocate a second TVar list
22:48:43 <lpsmith> oh well, I don't really need sendMany at the moment,  it's just that I haven't used STM much and I'm thinking about it
22:49:11 <kurak0t> arkeet: http://codepad.org/JcZzEedK
22:49:44 <kurak0t> arkeet: the program asks input first instead of printing a string to ask some input
22:50:07 <arkeet> windows?
22:50:12 <arkeet> I wonder if it's some buffering problem.
22:50:15 <lpsmith> Actually,  maybe in the STM world maybe there really isn't much advantage to forcing the spine of the list and converting it to a TVar list
22:50:17 <kurak0t> arkeet: yeah. cygwin
22:50:20 <arkeet> cygwin!?
22:50:27 <lpsmith> I mean, doing that first
22:50:32 <arkeet> since when did ghc work in cygwin
22:50:59 <p0a> How can I have a case where the list I pass to a function is of length two?
22:51:00 <arkeet> or do you mean you used win32 ghc and are just using the cygwin terminal.
22:51:08 <p0a> f [a, b] = a for isntance?
22:51:11 <arkeet> p0a: yes
22:51:21 <kurak0t> arkeet: yes. that's what I mean.
22:51:24 <arkeet> equivalently, f (a:b:[]) = a
22:51:32 <arkeet> kurak0t: well, maybe it's some buffering thing.
22:51:34 <arkeet> try stuff like
22:51:45 <arkeet> hSetBuffering stdout LineBuffering
22:51:48 <arkeet> (import System.IO)
22:51:52 <arkeet> and same for stdin
22:52:04 <p0a> arkeet: I think that works even if the list has 1 or zero elements? (in which case a = b = [] etc?)
22:52:07 <arkeet> well, I suppose stdin is working fine.
22:52:09 <arkeet> p0a: no.
22:52:14 <p0a> Too bad
22:52:23 <arkeet> that doesn't even typecheck.
22:52:24 <kurak0t> arkeet: thanks. i'll check that out
22:52:36 <p0a> arkeet: still new, give me time :)
22:52:36 <arkeet> kurak0t: that's odd though, because it shouldn't be necessary.
22:53:48 <no-n> hi. I did 'sudo apt-get install ghc' in linux mint and when I try to load System.Random I get this http://pastebin.com/VnarPafy
22:54:13 <arkeet> no-n: you need more than ghc.
22:54:19 <kurak0t> arkeet: I'm using version 7.0.2 btw. i'll try the latest ghc now.
22:54:26 <no-n> arkeet: what do I need?
22:54:26 <arkeet> no-n: is there a package for the haskell platform?
22:54:28 <mauke> The paste VnarPafy has been copied to http://hpaste.org/90439
22:54:32 <arkeet> haskell-platform something maybe
22:54:34 <Taneb> "cabal install random --enable-documentation --haddock-hyperlink-source" no-n
22:54:37 <arkeet> kurak0t: that's ancient!
22:54:39 <arkeet> ;)
22:55:01 <arkeet> no-n: because that is the recommended way to get start with haskell.
22:55:18 <arkeet> started.
22:55:23 <no-n> arkeet: ah, yes. haskell-platform, cheers
22:55:50 <arkeet> no-n: System.Random is from the 'random' package, which is in the platform but not included in ghc.
22:55:59 <no-n> thanks :]
22:56:00 <arkeet> indeed, ghc includes very little.
22:56:11 <adas> Say I have a type 'Q' and a Data constructor with type "R :: a -> b -> c -> Q". Now do i have to give all parameters a b c at the time of creating value of type 'Q'? Or can I give 'a' first and then give 'b' when I have it?
22:56:33 <arkeet> adas: are you talking about partial application?
22:56:38 <adas> maybe that question didn't make sense sorry
22:57:00 <arkeet> you can partially apply constructors. (just like any other function.)
22:57:13 <arkeet> so if you have some a :: a
22:57:18 <arkeet> you can have R a :: b -> c -> Q
22:57:43 <arkeet> (which internally ends up being a lambda: \b c -> R a b c)
22:58:57 <adas> thanks for the clarification
22:59:27 <mauke> let x = R{ a = 1 } in x{ b = 2 }
22:59:53 <arkeet> wouldn't that give you at least a warning?
23:00:07 <arkeet> I wouldn't do it.
23:01:15 <p0a> Hello why doesn't this code work? http://hpaste.org/90440
23:04:16 <mauke> p0a: infinite recursion
23:04:41 <mauke> (x - 2) + 1 + (x - 3) is still x
23:04:54 <mauke> er
23:04:56 <p0a> mauke: f must return [] in some case. Can I do this?
23:04:59 <mauke> the first one should be just 2
23:05:06 <mauke> p0a: do what?
23:05:12 <p0a> Can this be done?
23:05:19 <mauke> what?
23:05:28 <p0a> I noticed you are correct about infinite recursion. I can solve that problem if f returns [] in some case
23:05:40 <p0a> but f's type is to return numbers?
23:05:43 <mauke> 1) I don't see how
23:05:58 <mauke> 2) f's type says nothing about numbers
23:06:04 <mauke> 3) what the fuck is this code supposed to do?
23:06:13 <p0a> You are right, [f] could never equal []
23:06:29 <p0a> This stupid code is supposed to calculate a and b such that ax + by = gcd(x, y)
23:06:40 <p0a> (But the critical part of the algorithm is not shown)
23:07:18 <mauke> isn't gcd(x, y) <= min(x, y)?
23:07:32 <arkeet> mauke: not if x or y is 0
23:07:33 <p0a> oh a and b are not positive necessarily
23:07:51 <mauke> > gcd 3 0
23:07:52 <lambdabot>   3
23:08:16 <p0a> yeah that's because every number divides 0
23:09:22 <p0a> mauke: I wanted to reduce a list to a number. The problem is I can not do this with a lambda function because the function must have 'memory'
23:09:31 <p0a> In C that means I would have two internal variables defined with the static keyword
23:09:36 <p0a> if you are familiar with C, I believe you are
23:13:03 * p0a hoped that mauke would reply
23:16:29 <Moggle_> I'm curious, does GHC pre-evaluate some expressions in code? For example, if I had something like "let x = 3 * 3 * 3", would it be compiled down to x = 27 at some point?
23:16:44 <Moggle_> ... I could probably test that, but I can't recall the GHC flag to output the C-- code. Darn.
23:17:12 <lpsmith> Moggle_,  try ghc-core
23:17:18 <lpsmith> theoretically yes
23:17:55 <Moggle_> lpsmith: what about a pure function like fib n = fib (n - 1) + fib (n - 2)? I'm pretty sure GHC doesn't pre-evaluate fib 30 when you use it in code
23:17:56 <lpsmith> but in practice many people have complained that constant folding isn't too reliable and/or broken,  I haven't really checked myself
23:17:57 <Moggle_> what are the rules behind it?
23:18:13 <arkeet> recursive things aren't inlined.
23:18:16 <lpsmith> Moggle_, IDK
23:18:29 <lpsmith> I'm not even sure let x = 3 * 3 * 3 works
23:18:34 <Moggle_> arkeet: is there any way to inline them?
23:18:48 <arkeet> well, think about what would happen if you did.
23:19:30 <lpsmith> Moggle_, you can always consider template haskell if you want to be sure.
23:19:49 <Moggle_> lpsmith: ooh, now that's a very good idea
23:19:55 <Moggle_> lpsmith: then it'd be more like a lisp macro
23:20:20 <lpsmith> Moggle_, http://hackage.haskell.org/package/ghc-core
23:20:38 <arkeet> anyway, 3 * 3 * 3 is optimized to 27 if it's some concrete type.
23:20:38 <arkeet> it isn't if it's polymorphic.
23:20:43 <arkeet> ghc-core will tell you this
23:21:02 <Moggle_> lpsmith: oh now this is nice
23:22:07 <dmwit> pootle
23:22:35 <Moggle_> lpsmith: this isn't directed at you but god damnit windows i'm going to install ghc-core on my linux VM this is ridiculous
23:22:41 <Moggle_> stupid ghc-core.
23:23:05 <arkeet> well, ghc-core is just a frontend to ghc -ddump-simpl
23:23:28 <lpsmith> actually I liked some of the earlier versions of ghc-core better
23:23:37 <lpsmith> IDK if it ever worked on windows
23:23:46 <shachaf> Oh, that reminds me, someone submitted a patch to make ghc-core work on Windows.
23:23:48 <arkeet> if it doesn't, blame shachaf
23:23:52 <arkeet> heh.
23:24:13 <shachaf> Yep, blame me.
23:24:24 * shachaf will look at it tomorrow hopefully.
23:24:56 <lpsmith> but TBH,   Windows is a second-class citizen in the GHC world,  especially if you want to do IO.
23:25:10 <Moggle_> lpsmith: or GUI programming
23:25:30 <Moggle_> (i must have spent close to four or five hours trying to compile various gui libraries on windows now, it's not worth it)
23:26:16 <dmwit> Moggle_: Which libraries?
23:26:50 <lpsmith> GHC is fine on Windows if you mostly just want to do computation though
23:26:58 <Moggle_> dmwit: gtk2hs, wxHaskell (which I did get working after a lot of tinkering), ncurses, and two others I can't recall
23:27:21 <Moggle_> i also got ncurses to compile, but wide character issues abounded
23:27:23 <arkeet> if gtk2hs doesn't work, blame dmwit.
23:27:37 <Moggle_> hello world was printed like h(square square square) e (square square square) l (square square square)...
23:27:58 <Moggle_> I'm going to give gtk2hs another try, I'm almost at the chapter in Real World Haskell where it's used
23:28:13 <Moggle_> but it would be _really_ nice if windows had something like apt-get.
23:28:21 <Moggle_> of course it's windows so it's not going to :P
23:29:28 <dmwit> Moggle_: Out of curiosity, did you follow the instructions on the tin?
23:29:45 <lpsmith> It'd be nice if somebody would step up and get GHC working better on Windows,  perhaps even as going as far as avoiding cygwin/msys,  but it's not a platform I use much and I know next to nothing about windows programming,  other than the IO model is very different.
23:30:08 <dmwit> Moggle_: I tested them on several different Windows setups...
23:30:44 <lpsmith> Windows IO seems rather convoluted to me,  whereas I was immediately comfortable with the concepts behind epoll.
23:31:29 <Moggle_> dmwit: these ones? http://www.haskell.org/haskellwiki/Gtk2Hs/Windows
23:31:56 <dmwit> no
23:32:27 <dmwit> There's literally a bright red "DON'T READ THIS" message at the top of that page. -_-
23:32:58 <arkeet> maybe that page should be a redirect then.
23:33:06 <arkeet> or at least mostly blanked.
23:34:00 * hackagebot byteable 0.1.0 - Type class for sequence of bytes  http://hackage.haskell.org/package/byteable-0.1.0 (VincentHanquez)
23:34:02 <Moggle_> ah, right
23:34:11 <Moggle_> that would be a very good warning to follow :P
23:35:17 <lpsmith> Here's a bit of code I wrote recently to have connection timeouts on Windows that actually work:  http://hpaste.org/90441
23:35:26 <lpsmith> Very hackish
23:35:36 <Moggle_> in any case i did try it a few different ways, it was pain, but i'll try it again
23:35:51 <lpsmith> Especially considering on unix you can avoid all the cruft of forkIO and MVars.
23:37:43 <lpsmith> Otherwise connect takes about 21 seconds to timeout.   And be sure to link that code with the -threaded runtime.
23:37:50 <Moggle_> one thing I think cabal could perhaps do better
23:37:52 <lpsmith> And there doesn't seem to be any way to change that.
23:38:03 <Moggle_> is maybe allow for binaries to be distributed for windows
23:38:12 <Moggle_> rubygems does it, it's nice
23:38:21 <Moggle_> but yeah, let's see how this compile of gtk works out!
23:39:06 <kurak0t> arkeet: i tried using version 7.6.3. the same thing happened.
23:39:19 <arkeet> I didn't expect anything differen't, really.
23:39:32 <arkeet> it's just generally good to use something that's not ancient
23:39:47 <joeyh> Moggle_: there's a pretty nice Nullsoft installer DSL in hackage, though no cabal integration.
23:40:37 <dmwit> Moggle_: Yeah, cabal doesn't do a good job of tracking executables.
23:40:44 <dmwit> It's a bit trickier to imagine what I would want it to do, though.
23:41:18 <dmwit> Connect to my package manager...? But there's so many package managers out there (including Windows' braindead no-manager situation)... seems hopeless.
23:41:23 <LambdaDusk> can anyone help me on this: http://hackage.haskell.org/packages/archive/yesod-eventsource/1.1/doc/html/Yesod-EventSource.html
23:41:23 <LambdaDusk> The function repEventSource requires a function that returns a Source and I have no idea how to write such a function that would produce something on an internal event
23:41:34 <Moggle_> Aha! Haskell DOES pre-evaluate 3 * 3 * 3
23:41:44 <Moggle_> let's see if it pre-evaluates tail-recursive things.
23:41:46 <dmwit> Moggle_: Anyway, I'll be up for a little bit longer, let me know if you run into trouble with gtk and I'll try to help.
23:41:55 <Moggle_> dmwit: thanks for the offer! you're great.
23:41:56 <dmwit> Or if you do it later, just ?ask me.
23:42:07 <Moggle_> dmwit: just waiting on the all-in-one package now.
23:42:16 <LambdaDusk> like using TChan/TMVar
23:44:01 * hackagebot securemem 0.1.0 - abstraction to an auto scrubbing and const time eq, memory chunk.  http://hackage.haskell.org/package/securemem-0.1.0 (VincentHanquez)
23:45:48 <u_> what alternatives are there to leksah for haskell development
23:45:53 <u_> i like leksah but it keeps breaking on me
23:46:25 <Moggle_> u_: uh, a normal text editor? :P if you want a lightweight IDE, geanie's pretty good
23:46:37 <Moggle_> geany*
23:46:38 <Moggle_> whatever it is.
23:47:38 <u_> i like the autocompletion and automatic compiling
23:48:34 <Twey> u_: Most people just use emacs; a couple use vim
23:48:45 <LambdaDusk> or perhaps someone can point me to some conduit examples using Source
23:48:54 <u_> yeah i was looking at emacs
23:49:00 <u_> was hoping there were other options though
23:49:04 <u_> emacs is scary
23:49:08 <lpsmith> LambdaDusk, you may have better luck in #yesod
23:49:43 <lpsmith> But hopefully somebody around would answer here too =)
23:49:45 <Twey> u_: emacs is awesome; it requires a small investment of time, but it'll pay you back a hundred times
23:49:50 <Moggle_> u_: yeah, emacs/vi have that huge learning curve
23:50:03 <Moggle_> learning one of the two is on my to-do list this summer
23:50:12 <Twey> emacs doesn't really have a steep learning curve
23:50:39 <Twey> You can pretend it's MS Notepad if you really want to, you just won't get many of the benefits of it not being MS Notepad :√æ
23:50:54 <u_> is it just me or do lots of haskell projects have this hebrew sound to them
23:50:55 <Twey> (well, you get syntax highlighting and indenting for free)
23:51:00 <u_> yesod haddock hakyll
23:51:06 <u_> (pretend the spelling is different)
23:51:07 <Twey> u_: Hehe
23:51:16 <u_> scion...
23:51:31 <Twey> Yesod is the only one that's intentionally that way, I think
23:51:57 <LambdaDusk> snoyberg is a very productive haskeller
23:53:19 <kurak0t> arkeet: i tried running ghc in cmd.exe and it goes well
23:53:27 <luite> even more so if he gets credit for all hebrew sounding projects :)
23:53:29 <arkeet> there you go.
23:53:35 <kurak0t> i wonder why it does not works well in cygwin
23:54:25 <arkeet> well, cygwin is cygwin.
23:55:17 <Moggle_> ghc and cygwin do not mix i have found
23:55:25 <Moggle_> because ghc uses mingw on windows
23:55:32 <Moggle_> and making it use cygwin by default is pain.
23:55:40 <Moggle_> really most haskell development on windows is pain :D
23:56:29 <kurak0t> it sounds like haskell is not for windows
23:56:32 <kurak0t> XD
23:57:05 <u_> its not for osx either
23:57:09 <u_> :/
23:57:12 <johnw> u_: ?
23:57:22 * johnw mainly uses Haskell on OS X
23:57:28 <luite> kurak0t: it certainly is the hardest platform to get things working on, linux is easiest in general
23:57:36 <u_> leksah breaks, cairo breaks
23:57:50 <u_> buncha other stuff i can't remember cause i had to give up on it breaks
23:58:09 <luite> kurak0t: but as long as you don't need too many non-haskell libs it should be ok
23:58:25 <Ralith> haskell's working fine on windows for me
23:58:33 <u_> ohai ralith
23:58:37 <Ralith> \o
23:58:52 <Reite> for me too
23:58:54 <Reite> mostly :p
23:59:18 <kurak0t> luite: what CLI tool are you using?
23:59:32 <Moggle_> linux is the easiest for all programming thanks to the whole having a package manager thing.
23:59:44 <Moggle_> (seriously windows why you no have one)
23:59:55 <luite> kurak0t: i isually use linux and OS X for development, just ghci from the terminal or loaded into emacs
