00:07:06 <augur_> hmm
00:07:30 <augur_> i think zippers can probably represent state machine states
00:07:59 <augur_> or something zipper-like, anyway
00:08:13 <dmwit> I've seen it used for tapes, but states is a new one.
00:09:25 <augur_> dmwit: at least for regular expressions.
00:10:14 <augur_> dmwit: something like.. instead of one kind of context, you have two -- before and after
00:10:25 <dmwit> "context"?
00:10:31 <augur_> zipper contexts
00:10:51 <dmwit> I'm not following.
00:11:16 <augur_> a zipper is a separation of a type into values and contexts, right
00:11:31 <augur_> contexts being values with a hole in them where the focused value was plucked out
00:13:08 <dmwit> Okay, I'm with you so far.
00:13:35 <dmwit> But why is that useful for the states of an automaton?
00:13:40 <augur_> well so
00:13:57 <augur_> an FSM can be represented as a regular expression right
00:14:25 <augur_> and the sort of ideal recognizer for a regular expression is an NFA
00:14:57 <augur_> but the states in the NFA essentially correspond to positions within the regular expression
00:15:15 <augur_> but not positions of subexpressions, positions before/after subexpressions
00:15:34 <augur_> or on the left/right edges, so to speak
00:16:28 <dmwit> Okay, I have a hazy idea about what you're thinking now. Do you think you'll pursue it and try to solidify the ideas?
00:19:11 <augur_> yeah, im working on it now :P
00:19:48 <Moggle_> Anyone here have a favorite ncurses Haskell binding? the ncurses one seems to have wide-character issues, so I'm getting http://i.imgur.com/auexsUq.png
00:21:25 <Moggle_> i mean unless anyone has ideas on how to make haskell use utf-32 text or something I doubt this isn't about to work :P
00:22:40 <shachaf> I don't know what a wide character is, but Haskell strings are Unicode strings.
00:25:21 <Moggle_> utf-8, I assume?
00:25:56 <Moggle_> my problem seems like the haskell ncurses binding is converting test to 4-bytes and ncurses only wants 1-byte, so i'm getting my (desired) text and then 3 bytes of nonsense (represented as squares)
00:26:26 <shachaf> Haskell strings are Unicode strings.
00:26:37 <shachaf> Are Haskell Ints big-endian or little-endian?
00:27:03 <Moggle_> your point is well made
00:27:07 <Moggle_> i am an idiot :D
00:27:30 <Moggle_> however the problem remains irritating because ncurses has such a nice api
00:28:40 <shachaf> Based on the information that you've provided so far, I recommend changing your code so that it does what you want.
00:28:50 <frerich> :-p
00:29:34 <Moggle_> I don't suppose there's a special $TERM environment variable I have to set on windows?
00:29:50 <Moggle_> I had to delete one called dumb because why the hell was that there
00:38:28 <Walther> Hmm. How suitable would haskell be to make a script akin to a makefile, grabbing input files from folder(s) x, processing the files, spitting output to folder(s) y
00:39:04 <Lethalman> Walther, look for Shake
00:39:37 <Lethalman> it is a dsl for a build system like makefile and it's rather easy to use
00:39:50 <Walther> Hm, thanks, i'll look into that
00:40:07 <mr-> Walther: https://www.youtube.com/user/jekor seems to explain how to build redo
00:40:08 <Walther> Basically I'm designing a new CMS with the focus of dead simple
00:40:58 <Lethalman> Walther, in which case also look at http://www.haskell.org/haskellwiki/Web/Content_Management for existing cms
00:41:13 * hackagebot postgresql-simple 0.3.3.2 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.3.3.2 (LeonSmith)
00:41:15 <Walther> I want to have a folder called "content" that has 'articles' in plaintext, a template css + html structure, and have it generate plain static html files that look and feel like a php-based page? thingy but actually is damn static
00:41:41 <Walther> without having to manually paste headers, navs, footers to each and every page
00:41:50 <blackdog> Walther: maybe look at hakyll?
00:41:56 <Breadmonster> Guys, how do you do large scale projects?
00:42:03 <Breadmonster> With a text editor and a build system?
00:42:03 <Walther> well i'll be damned, thanks a bunch blackdog
00:42:07 <Walther> and Lethalman
00:42:18 <Breadmonster> Or is there an IDE?
00:42:21 <blackdog> Breadmonster: cabal + emacs :)
00:42:38 <Breadmonster> blackdog: I prefer Sublime Text, but yeah.
00:42:40 <Breadmonster> No IDE?
00:42:43 <Walther> I do everything I can in Sublime
00:42:49 <mr-> Breadmonster: cabal + sublime
00:43:02 <Walther> a couple features still missing i'd love, namely, full-fetched shell/terminal plugin
00:43:06 <mr-> + a bunch of terminals ;-9
00:43:12 <Walther> even if it internally used the one available on system
00:43:19 <Breadmonster> Alright, fine, I thought there was something for Haskell like Eclipse for Java.
00:43:19 <blackdog> Breadmonster: a few people are building IDEs
00:43:24 <blackdog> leksah
00:43:29 <Breadmonster> Is it any good?\
00:43:32 <blackdog> most people tend to use an old-school editor, i think
00:43:37 <blackdog> ... i still use emacs :)
00:43:38 <Breadmonster> I think Haskell is a really powerful language.
00:43:49 <Walther> yeah, most people use emacs, vim, or Sublime
00:43:53 <Breadmonster> btw, what parser do you use for Haskell?
00:44:01 <blackdog> also, emacs & vim can use ghc-mod, which gives you in-editor typechecking and access to hoogle etc
00:44:04 <Breadmonster> LALR?
00:44:14 * Lethalman uses emacs
00:46:15 <blackdog> Breadmonster: usually parsec or attoparsec
00:46:18 <Breadmonster> btw, I know this isn't the place, but anyone knows OCaml as well as they know Haskell?
00:46:33 * companion_cube knows OCaml better
00:46:35 <blackdog> parsec if you care about error messages, attoparsec if you care about speed (so network protocols vs languages, basically)
00:46:54 <shachaf> trifecta gives better error messages than Parsec!
00:46:58 <Breadmonster> companion_cube, How did you learn it?
00:47:12 <companion_cube> Breadmonster: a bit at school, a bit in internships
00:47:14 <shachaf> If you know it isn't the place, why are you asking?
00:47:36 <Breadmonster> shachaf: because until three seconds ago, #Ocaml was dead.
00:48:22 * shachaf isn't sure what that has to do with #haskell...
00:48:52 <Breadmonster> shachaf: I had nowhere else to ask, save for #scala perhaps.
00:48:59 <dmwit> ##c has an automated response about this along the lines of "but there's nobody at the Subaru dealership! Why won't you Ford folks just sell me a Subaru?".
00:49:50 <mauke> Breadmonster: you could ask in ##javascript
00:51:39 <dmwit> (On the other hand, I've always felt that off-topic talk was okay so long as there was no on-topic discussion going on. So I'm pretty ambivalent here.)
00:52:25 <dmwit> So "I had nowhere else to ask" doesn't carry a lot of weight with me, but "nothing else was happening here anyway" does. =P
00:52:41 <elliott> .@where+ offtopic This channel is for discussion of the Haskell programming language. Even if you can't find another active channel to answer your question, that doesn't mean it's appropriate here; remember that you're potentially talking to around 1000 people. #haskell-blah is available for general chit-chat.
00:52:46 <elliott> ^ anyone think that would be good/have wording suggestions?
00:53:00 <shachaf> I don't think you should mention #-blah.
00:53:15 <elliott> this kind of thing comes up a lot and I find it usually takes five lines of back and forth to get the point across, which can be pretty tedious (and noisier than the off-topicness itself)...
00:53:44 <mauke> shachaf: why not?
00:54:09 <dmwit> This particular infraction was certainly on-topic for #-blah.
00:54:25 <dmwit> But are all of them?
00:55:27 <shachaf> The point of #-blah seems to be mostly talking with #haskell folks about non-Haskell things. If you want a general-purpose off-topic channel there are several on Freenode.
00:55:47 <shachaf> So if you're not a Haskell person and you joined in order to ask a non-Haskell question, I don't see any reason to direct you there.
00:58:41 <elliott> I guess as written it looks like it's banning all off-topic chat ever, which wasn't my intention
01:36:16 * hackagebot karver 0.0.1 - A simple template engine, inspired by jinja2  http://hackage.haskell.org/package/karver-0.0.1 (JeremyHull)
01:43:16 <vhs> Looking at some code involving IntMap. Don't get this snippet:
01:43:52 <hpaste> “Anonymous Coward” pasted “!g1” at http://hpaste.org/90091
01:44:03 <shachaf> Whew, you hpasted it.
01:44:30 <vhs> How do you say "let !g1...." then call the var simply "g1"?
01:44:44 <apples> that means g1 is strictly evaluated, i believe
01:44:45 <shachaf> It is a bang pattern.
01:44:53 <augur_> dmwit: done!
01:44:59 <vhs> bang pattern?
01:45:09 <shachaf> @where hoogle can tell you how it behaves, if you search for !
01:45:10 <lambdabot> http://haskell.org/hoogle
01:45:35 <shachaf> > let x = undefined in "hi"
01:45:37 <lambdabot>   "hi"
01:45:38 <shachaf> > let !x = undefined in "hi"
01:45:39 <lambdabot>   <hint>:1:5:
01:45:39 <lambdabot>      Illegal bang-pattern (use -XBangPatterns):
01:45:39 <lambdabot>      ! x
01:45:43 <vhs> I found "!" on hoogle, I just couldn't wrap my mind how that could possibly do anything in a var NAME
01:45:44 <shachaf> Er, well.
01:45:48 <supki> heh
01:46:01 <shachaf> In what context can you wrap your mind around it?
01:46:41 <vhs> I dunno...maybe after the equals in a statement like "let x ="
01:46:57 <vhs> I wasn't aware you could do something programmatic before you actually hit the =
01:47:01 <shachaf> Then I'm afraid your mind isn't wrapped at all yet.
01:47:11 <vhs> ok
01:47:12 <mauke> there is no before/after
01:47:13 <shachaf> Which Hoogle result did you look at? You want the keyword.
01:48:39 <vhs> Okay, that's what I needed. To look at the keyword. It involved IntMap, so my eyes lighted on the IntMap "!".
01:48:48 <shachaf> OK.
01:49:03 <shachaf> Fortunately, we told you that the syntax is called a bang pattern, so now you don't even need Hoogle.
01:50:06 <vhs> keyword would imply this has to be "baked in"? Or does keyword have a different connotation in haskell?
01:50:06 <shachaf> (Note that "let !x = ..." is a syntax error with !-the-operator. So you can already figure out that something isn't right just by thinking about operator syntax.)
01:50:44 <shachaf> I don't think I can describe it any better than the Hoogle link: http://www.haskell.org/haskellwiki/Keywords#.21
01:50:51 <vhs> alright
01:50:53 <shachaf> Or the bang pattern documentation: http://www.haskell.org/ghc/docs/latest/html/users_guide/bang-patterns.html
01:51:10 <vhs> I'll look into it. Thanks.
01:51:26 <augur_> dmwit: yeah, so, the contexts for any particular regular expression are the states of a non-minimal NFA for that regular expression
01:51:27 <augur_> how fun!
01:53:28 <kryft> So bang batterns are a language extension; is there in general any reason not to use language extensions if you see something you like?
01:53:56 <shachaf> That depends on how good your taste is.
01:54:25 <kryft> :)
01:54:48 <shachaf> Some language extensions are widely considered a bad idea to use.
01:54:55 <merijn> kryft: Portability to other compilers/older GHC versions is the only real issue, some extensions are...not as nice as others
01:54:57 <shachaf> (Many of them end in the word "Instances"...)
01:55:08 <shachaf> And then there's what merijn said.
01:55:23 <kryft> Ok, so they're a mixed bag
01:55:25 <merijn> kryft: A reasonable list is mentioned at http://stackoverflow.com/questions/10845179/which-haskell-ghc-extensions-should-users-use-avoid
01:55:49 <kryft> merijn: Thanks
01:56:01 <kryft> 'SQL comprehensions' sounds .. interesting
01:56:16 <merijn> kryft: The ones in the "good" list are almost universally accepted as, well, good if you don't mind the portability issues
01:56:29 <merijn> Generalized new type deriving has some safety issues, but should be fine in most cases
01:56:37 <kryft> merijn: Right, I guess some of them will be in the next standard?
01:56:43 <shachaf> Yes.
01:57:26 <merijn> kryft: As shachaf said most of the extensions that are considered bad end in Undecidable-/Incoherent-/OverlappingInstances
01:57:33 <quicksilver> yuck, RecordWildCards
01:57:36 <merijn> kryft: Some, yes, but in general the standard is very conservative
01:58:07 <kryft> merijn: Ok, so there's good stuff that won't make it.
01:58:49 <merijn> kryft: oh, an ExistentialQuantification has a tendency to trick newcomers into the "existential anti-pattern", so while the extension itself is fine, you should always second guess any impulse to use it ;)
01:58:53 <merijn> kryft: Yes
01:59:03 <elliott> quicksilver++
01:59:08 <elliott> RecordWildCards--
01:59:19 <elliott> WhateverThePunExtensionIsCalled--
01:59:19 <shachaf> ==elliott
01:59:26 <merijn> kryft: https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
01:59:29 <shachaf> Aw, you ruined it.
01:59:37 <mr-> (_,_,_,_,_,_,_,_,_,_,installFlags,_) = args  <- Fun..
02:00:07 <supki> elliott: what's wrong with pun extension?
02:00:19 <elliott> supki: it is fundamentally based on shadowing
02:00:21 <shachaf> Shadowing is the devil.
02:00:51 <kryft> merijn: Thanks, I'll read that before I start using ExistentialQuantification ;)
02:01:00 <kryft> pun extension?
02:01:16 <shachaf> @google haskell pun extension
02:01:16 <merijn> kryft: If in doubt, you could always ask here, people would be more than happy to comment on what extensions are good
02:01:17 <lambdabot> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/syntax-extns.html
02:01:17 <lambdabot> Title: 7.3.�Syntactic extensions
02:02:00 <supki> elliott: well, yes, also it saves a variable (which would have some obtuse name otherwise)
02:02:47 <shachaf> Not as obtuse as a name you were already using for something else.
02:02:48 <kryft> merijn: Right. This is probably enough for now, as I haven't actually written any real code yet :)
02:02:59 <mauke> shadowing is not the devil
02:03:06 <elliott> supki: nothing is more obtuse as a name that also stops you accessing fields of other records and causes confusing type errors and -- in the case of wildcards -- isn't even present where you shadow it
02:04:11 <kryft> merijn: (I hope that will change soon, though, as I have an idea for a small program that I would actually have use for and that I might as well write in Haskell)
02:04:32 <kryft> Well, maybe not even small, depending on how ambitious I get, but I can start very simple. :P
02:04:33 <supki> I don't know why you would use record accessors in the lens age anyway
02:04:45 <supki> (I agree that wildcards are awful though)
02:06:07 <merijn> I just realised that SO post doesn't even mention some of my favorite extensions
02:06:30 <merijn> DataKinds, ConstraintKinds and KindSignatures!
02:06:34 <Ralith> supki: because records are built in and easy to get at, while lense accessors require installing a package and using some template haskell?
02:14:58 <merijn> Quick poll!
02:15:21 <frerich> Hi, I'm well aware of the discussions about the flaws of record syntax. I think there's one which I hit particularly often though, triggered by me compiling with -Wall. The paste at http://hpaste.org/90093 illustrates the dilemma. Is anybody here aware of a nice technique to make implementing both 'render' as well as 'getsDiscount' elegant and convenient?
02:15:47 <merijn> Should Travis-CI start providing multiple GHC/platform setups for testing, how many and which versions would we like? I'm thinking the last 2 platforms + maybe a development snapshot?
02:16:54 <eikke> merijn: last and one-but-last full platform, & GHC head (without platform) updated every couple of days
02:17:22 <merijn> eikke: Updated every couple of days might be tricky, I dunno how frequently they update their builds
02:18:08 <eikke> merijn: true. although having a PPA which provides those packages (without Travis integration) would be helpful already (since then it can be set up 'manually' from travis.yml)
02:18:23 <boothead> frerich: looks like a job for the lens package I reckon
02:20:33 <merijn> eikke: What does PPA stand for?
02:20:50 <eikke> personal package archive or something, it's an ubuntu thing
02:23:58 <frerich> boothead: Hmm, how so?
02:30:08 <merijn> johnw: You were doing snapshot builds of HEAD, right?
02:30:20 <quicksilver> frerich: in 'render' don't patternmatch. Just use the selectors?
02:30:46 <quicksilver> render p = ... function body uses (firstName p), (lastName p) etc where required ...
02:30:56 <frerich> quicksilver: That would be possible, yes - it's longer though (especially if the variable is not called 'p' but something longer).
02:31:07 <frerich> And you might have to use parentheses.
02:31:12 <quicksilver> indeed
02:31:27 <quicksilver> well you can use recordWildCards
02:31:33 <boothead> frerich: I'm far from the expert, but I think lens should give you a nicer syntax for just picking out one field
02:31:36 <merijn> Semi-related, who is involved in building/testing Platform? I have some questions about Platform I'd like to ask some Platform knowledgeable people
02:31:37 <quicksilver> but we've just explained why we don't like it :)
02:31:43 <frerich> quicksilver: So yeah, there are plenty of workarounds, but nothing which is really neat. To be honest, I also considered disabling the 'shadowing' warning...
02:31:45 <quicksilver> not sure if you read that part
02:38:56 <Darkproger> hi guys; what's the nicest way to find the bindings that contain the type i want among the packages installed on my machine?
02:39:09 <Darkproger> i.e. i want to find all conduit Consumers
02:39:19 <Ralith> a local hoogle install
02:39:29 <Darkproger> hoogle doesn't help much
02:39:31 <Darkproger> :
02:39:32 <Darkproger> :(
02:39:59 <Darkproger> it seems to simply show some possible packages that contain the name i want
02:40:26 <merijn> Darkproger: A local hoogle install will search your locally installed bindings too, instead of just those indexed on hackage
02:41:53 <Darkproger> hoogle ':: Consumer' | head                                                                                                ~
02:42:05 <Darkproger> shows stuff like Warning: Unknown type Consumer
02:42:19 <merijn> You will need to index your locally installed packages too
02:42:31 <merijn> I forgot how, but "hoogle -h" or "hoogle --help" should tell you
02:55:13 <keith_> Hi, in GHCI if I type: "let a b = 2" I don't get syntax error but neither a or b is bound to the value 2. Could someone tell me what is happening please or tell me where to look. The usual documentation for "let" expressions only deals with "let a = 2".
02:56:44 <Kinnison> keith_: you defined a function 'a' which takes a parameter 'b' (and ignores it) returning 2
02:57:11 <Mortomes|Uni> let a = const 2
02:59:13 <keith_> Okay thank you.
03:03:20 <merijn> > let a b = 2 in a "hello!"
03:03:21 <lambdabot>   2
03:05:28 <canta> would it be worthwhile to get a haswell cpu with that hardware transactional memory for haskell?
03:07:00 <merijn> canta: Hardware transactional memory like haswell is completely unrelated to haskell's software transactional memory
03:07:10 <Aetherspawn> I did mention it on here a few days ago
03:07:11 <merijn> As such, there's no real answer to that question
03:07:20 <Aetherspawn> and I think someone said it wouldn't take much llvm love to make HSIL work
03:08:51 <canta> merijn: I just thought haskell might be able to make use of it, because it already uses STM, if those things are unrelated I can save some money :p
03:09:18 <Aetherspawn> haswell has 2x faster simd
03:09:54 <Ralith> that sounds like a nonsense claim
03:10:18 <frerich> "But the brochure said so!"
03:10:47 <merijn> canta: It might, but it doesn't happen yet, and if it did I'm still not sure it'd be worth it
03:14:26 <augur_> anyone know if there's a way to compactify a regular expression to avoid the problem of nested *'s?
03:15:47 <mauke> is this a "real" (mathy) regular expression or something you want to use?
03:16:11 <augur_> real regular expressions
03:16:40 <mauke> what is the problem with nested *'s?
03:17:04 <augur_> i think its a theorem of flt that any starred disjunct of a started disjunction can be destarted -- (... | R* | ...)* = (... | R | ...)*
03:17:06 <augur_> mauke: well
03:17:11 <ij> So variable "changing" happens through the function stack?
03:17:58 <augur_> the problem is that on the naive translations of regexps into NFAs/recognizers, expressions like a** hang when matched on things like "b"
03:18:19 <Saizan> there's an algorithm to get the minimal equivalent regex, it probably simplifies that too
03:18:21 <typoclass> ij: yes if you call a function ("apply" is the preferred word), then the arguments and variables inside are fixed. after that they don't change anymore
03:18:29 <augur_> similarly, (a*|b*)* hangs on "c", etc.
03:18:57 <augur_> Saizan: i think its more just a problem with the naive implementation of the NFA
03:18:59 <typoclass> ij: variables don't change inside of one application of a function. they can change between different applications of the function
03:33:58 <augur_> Saizan: the trouble is that these NFAs halt on success, but not failure
03:33:58 <supki> typoclass: they don't change, they bind to different things
03:36:19 <typoclass> supki: i meant, in "do let f x = x + 3 ; print (f 42) ; print (f 37)", f will see the number 42, and at another time, f will see the number 37. (if you'd use Debug.Trace or some such.)
03:45:43 <Saizan> augur_: use DFA?
03:46:07 <augur_> Saizan: yeah but there isn't a beautiful relationship to the NFA then!
03:46:14 <augur_> er to the regex
03:46:18 <adnap> @hoogle mapAccum
03:46:19 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
03:46:19 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
03:46:19 <lambdabot> Data.List mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
03:46:42 <Tinned_Tuna> augur_: isn't there a simple equivalence ?
03:47:39 <arj1> How can I map on a single element in a list using lenses? I know I can do [1,2,3] & element 1 .~ 4 == [1,4,3] but I want to apply a function on the 2.
03:47:42 <augur_> Saizan: basically, (Bool, RegExZipper) is type of NFAs, and the navigation for the navigation for this combined type is the transition function for the NFA, more or less
03:48:01 <augur_> Tinned_Tuna: yeah there's a translation. i dont know if it loops in the same situations tho
03:48:26 <augur_> i should check
03:48:50 <adnap> Show me some cool lens stuff
03:48:56 <adnap> please
03:49:33 <hamid> :t takeCarriageRet
03:49:35 <lambdabot> Not in scope: `takeCarriageRet'
03:50:16 <hamid> :t Data.ByteString.takeCarriageRet
03:50:20 <lambdabot> Not in scope: `Data.ByteString.takeCarriageRet'
03:51:05 <hamid> oops!
03:51:22 * hackagebot som 5.1 - Self-Organising Maps  http://hackage.haskell.org/package/som-5.1 (AmyDeBuitleir)
04:00:09 <augur_> Tinned_Tuna: it does indeed loop
04:00:23 <augur_> its because of these self-loops for reading the empty string, ultimately
04:08:49 <merijn> Who is organising the Platform releases and maintaining the platform infrastructure?
04:09:12 <shachaf> merijn: mzero?
04:09:41 <merijn> shachaf: Any clue how/where I can get in contact with him?
04:09:44 <byorgey> Mark Lentczner, aka mzero
04:10:16 <merijn> (really anyone with an intimate understanding of how/where platform gets installed would work)
04:10:48 <shachaf> Sometimes he's in #haskell. Other times you can email him, presumably.
04:11:14 <timbod> jbracker:  What's the gsoc channel name?
04:11:15 <merijn> shachaf: I'd need to know his email, though. I was kinda hoping someone in here knows what it is?
04:11:19 <byorgey> there is also a haskell-platform mailing list.
04:11:39 <jbracker> timbod: haskell-gsoc
04:11:42 <shachaf> merijn: http://www.haskell.org/pipermail/libraries/2013-May/020107.html
04:11:56 <merijn> shachaf: Thanks
04:13:30 * LargePizz  Picture of my whore ex-girlfriend naked for your enjoyment: http://imagetwist.com/9x3zece21oyg
04:14:02 <Mortomes|Uni> ...
04:22:27 <b52> Oo
04:46:47 <yitz> yezariaely: maybe try #haskell-lens?
05:06:26 * hackagebot hslua 0.3.6.1 - A Lua language interpreter embedding in Haskell  http://hackage.haskell.org/package/hslua-0.3.6.1 (OmerAgacan)
05:06:28 * hackagebot xml-lens 0.1 - Lenses, traversals, prisms for xml-conduit  http://hackage.haskell.org/package/xml-lens-0.1 (FumiakiKinoshita)
05:06:34 <Aetherspawn> should i bother newtyping something like ResourceT IO ()
05:06:40 <Aetherspawn> or even ReaderT ResourceT IO () ?
05:07:42 <acube> Since what version does GHC support context aliases?
05:08:41 <merijn> acube: What do you mean by context alias?
05:08:55 <merijn> Aetherspawn: Why would you newtype that? Why not just use type?
05:08:58 <Walther> I'm kinda coming to a conclusion that haskell supports everything and is powered by magic
05:09:06 <typoclass> acube: this stuff? http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/constraint-kind.html
05:09:12 <merijn> Walther: You're not wrong
05:09:20 <Aetherspawn> merijn, performance
05:09:27 <Aetherspawn> unless I misunderstood the benefits
05:09:53 <merijn> Aetherspawn: Adding a newtype would at best have 0 performance impact, at worst it'll be negative, compared to just using a type alias
05:10:09 <hamid> :t fromJust
05:10:11 <lambdabot> Maybe a -> a
05:10:17 <hamid> :i fromJust
05:10:28 <typoclass> acube: ConstraintKinds seem to be 7.4ish. if i replace "7.4.1" in that url with "7.2.1", i get nothing
05:10:32 <Aetherspawn> merijn, I was told that for large transformer monad stacks im supposed to roll my own
05:10:32 <merijn> hamid: lambdabot doesn't support ":i"
05:10:38 <mreh> Aetherspawn, if it's just an alias you want, then use Type
05:10:48 <Aetherspawn> does that mean making a whole new monad?
05:10:51 <mreh> sorry "type", the keyword
05:10:54 <merijn> Aetherspawn: Yes
05:11:09 <mauke> Aetherspawn: you should newtype it
05:11:20 <merijn> Aetherspawn: When they say that the mean write your own monad that does everything your transformer stack does
05:11:28 <boothead_> hi guys, can anyone tell me the operator magic to extract certain fields from a list of lensed objects?
05:11:29 <Aetherspawn> mixed messages from many people starting with "m"
05:11:30 <Aetherspawn> :S
05:11:35 <mauke> Aetherspawn: ignore merijn
05:11:38 <mauke> problem solved \o/
05:11:43 <boothead_> so I want to go from [Type] -> [(Type.a, Type.b, Type.c)] if that makes any sense at all..?
05:11:51 <merijn> Ignore me, I have no clue what I'm talking about ;)
05:12:08 <Aetherspawn> ;__;
05:12:13 <merijn> mauke: How does the newtype help?
05:12:18 <Aetherspawn> So, do I get a performance benefit from newtyping a transformer stack or not
05:12:21 <Aetherspawn> I was told that its huge.
05:12:44 <typoclass> hamid: fromJust is somewhat useless (and dangerous). by the time you can safely use it, you're likely inside of a "case ... of Just j ->" or equivalent, which means you might just as well use the value at "j" and not bother with fromJust
05:13:09 <mauke> merijn: keeps you honest and makes it trivial to swap the implementation later, if needed
05:13:13 <merijn> mauke: I don't understand how "newtype MyType = HugeTransformerStackHere" will perform better than just using HugeTransformerStackHere directly?
05:13:20 <merijn> mauke: That works for "type" too
05:13:22 <mauke> it won't perform better
05:13:31 <mauke> merijn: no, type lets you access internals directly
05:13:35 <merijn> true
05:13:43 <eikke> merijn: performance will be the same, your sanity will remain saner when using MyType
05:13:46 <elliott> newtype is much better for transformer stacks.
05:13:52 <merijn> IOW, I was right about there being zero performance benefit
05:13:54 <merijn> ok
05:13:54 <elliott> you get to expose the API you want (e.g. "lift" goes down one level)
05:13:59 <elliott> which is impossible with "type"
05:14:00 <Aetherspawn> ok got it
05:14:07 <elliott> and then selectively give instances of transformer classes etc. for the parts you want to expose
05:14:24 <mreh> I want to start a digital agency using clckwrks
05:14:26 <mauke> oh yes, that too
05:14:28 <elliott> if the stack is really small and you don't care about encapsulation and stuff then you can use type though.
05:14:29 <mreh> who's in?
05:14:33 <mauke> a cleanly defined interface
05:14:33 <elliott> but futureproofing and all that
05:14:39 <hamid> typoclass, ow! got it. thanks
05:15:51 <merijn> hamid: Relatedly, you might be interested in
05:15:53 <merijn> :t maybe
05:15:54 <lambdabot> b -> (a -> b) -> Maybe a -> b
05:16:48 <typoclass> hamid: you're welcome. oh, and don't mix up fromMaybe and fromJust. fromMaybe is perfectly fine, fromJust should be avoided. (the naming is kinda unfortunate)
05:17:02 <eikke> :t fromMaybe
05:17:03 <lambdabot> a -> Maybe a -> a
05:17:48 * eikke now feels dumb using 'maybe d id m' sometimes
05:17:51 <merijn> fromMaybe is just "flip maybe id"
05:17:52 <augur_> hm
05:18:22 <augur_> i feel like a regex should be able to capture more than just the most recent values for a capture group
05:28:41 <aleator_> Has anyone here ever used miracalc?
05:30:24 <tdammers> I want fromNothing
05:30:35 <tdammers> :t fromNothing
05:30:36 <lambdabot> Not in scope: `fromNothing'
05:30:47 <tdammers> fromNothing :: Maybe a -> a
05:30:48 <typoclass> tdammers: exists already. is called Prelude.undefined
05:30:49 <typoclass> =)
05:31:15 <tdammers> fromNothing Nothing :: Int should give me a random integer
05:31:27 * hackagebot xml-lens 0.1.1 - Lenses, traversals, prisms for xml-conduit  http://hackage.haskell.org/package/xml-lens-0.1.1 (FumiakiKinoshita)
05:31:33 <tdammers> whereas fromNothing (Just 23) should crash
05:31:33 <richo> I'm trying to implement cond, in a scheme runtime. Which means mapping over a set of conditions, and then either executing some code and returning or returning to the next iteration. How does that work in haskell? I'm pretty sure map will want to evaluate everything.
05:31:39 <tdammers> (or reach bottom, or whatever)
05:32:32 <elliott> lens has fromNothing
05:32:36 <elliott> :t (^?! _Nothing)
05:32:37 <lambdabot> Not in scope: `^?!'
05:32:40 <elliott> meh. I suck.
05:32:44 <elliott> @let import Control.Lens.Fold
05:32:46 <lambdabot>  Defined.
05:32:47 <elliott> :t (^?! _Nothing)
05:32:49 <lambdabot> Maybe a -> ()
05:33:49 <Kinnison> ^?! sounds quite rude :-)
05:34:19 <jmcarthur_mobile> richo: map is lazy
05:35:08 <richo> so if I call return, it should bail out of subsequent iterations? It'll still want to return everything.. I feel like I could use tail to get at whatever happened last, but this is also sounding like square peg round hole.
05:35:09 <jmcarthur_mobile> richo: at least if we are talking about lists
05:35:11 <richo> Is map actually what I want?
05:35:28 <akamaus> hi. I need a detailed error reporting. I'm thinking about something like ET m a ~ StateT [Error] (ErrorT Error m) a,  with  track :: Error -> ET m a -> ET m a, where track is  track e m = do {modify (e:); x <-m; modify tail; return x}
05:35:41 <jmcarthur_mobile> No I don't think you actually want map. Even it's type doesn't look like what you want.
05:35:43 <akamaus> is it a known pattern?
05:36:41 <jmcarthur_mobile> richo: there is a fairly rich set of functions in Data.List you should probably look at
05:36:53 <richo> Awesome, thankyou
05:37:16 * Walther ^5's richo 
05:39:04 <richo> It looks like I can butcher find to do what I want.
05:39:26 <jmcarthur_mobile> That does sound reasonable
05:41:24 <yitz> richo: to get the imperative semantics of cond, you are going to need something richer than just find
05:41:59 <richo> yitz: you're probably right. I've been at haskell for.. 2 days now. So I'm going down this rabbit hole and when/if I get stuck I'll be in a better position to ask questions
05:42:28 <richo> because of the indirectness, and the fact that I'm calling into eval which is monadic and fairly impure, I reckon I might just get away with this using find
05:43:23 <yitz> richo: if you assume that none of the conditions have side effect when you evaluate them, you could use dropWhile to get the first pair whose condition is true, then return the result
05:43:42 <boothead_> is there a nicer way to do this with lenses? map (\e -> (e^.field1, e^.field2)) ex
05:43:55 <elliott> i think so but i've forgotten it.
05:44:02 <Moggle__> @src negate
05:44:03 <lambdabot> negate x = 0 - x
05:44:39 <yitz> richo: but if there will be side effects to the conditions, as is allowed in scheme, you need a short-circuiting monad that gives you all the side effects until you encounter a true condition, then return the corresponding result
05:45:18 <yitz> richo: actually, in this case, you don't really need a monad - and Alternative (from Control.Applicative) is good enough.
05:45:43 <yitz> richo: but in general, to mimic stuff that happens in an imperative language, you need a monad.
05:45:44 <richo> yitz: I have a working implementation of if, so I'm working on the assumption that side effects Just Work as a result of the current wrapping
05:46:09 <richo> I somewhat grok monads, as far as functions that return more functions, but internalise state.
05:53:21 <Philippa> richo: I find the best way to grok them, if you can, is as a particular kind of embedded language. That tends to imply a kind of internalised state to help evaluate actions/computations in them, yeah
05:54:28 <richo> Yeah, I get the general stuff about them, as far as encapsulation. Now it's just working out how to apply that to real problems.
05:55:43 <boothead_> Is there a function that will extract a Text to a number (Double or Float) or will I have to use read via String or attoparsec?
06:01:55 <Philippa> richo: pretty much you go "I wish I was programming in a language that had state/exceptions/logging/propagated an environment/did logic programming/whatever" and next thing you know, you are :-)
06:02:18 <yitz> boothead_: http://hackage.haskell.org/packages/archive/text/0.11.3.1/doc/html/Data-Text-Read.html
06:02:21 <Philippa> (if you're unlucky you have to implement the language first, but there are sure worse places to do that than Haskell too)
06:03:00 <Philippa> richo: but yeah, getting the pattern-matching down does take a while
06:03:34 <richo> So far I'm enjoying it. I've tried to learn before, but without a problem domain that was interesting I lost interest pretty fast
06:03:35 <marco91> WHOIS zomg
06:03:41 <hamid> I don't get this :
06:03:42 <hamid> Prelude> import Network.Socketddd
06:03:43 <hamid> Prelude>
06:03:57 <richo> compared to schame and the like that I was more or less immediately productive in
06:04:04 <richo> haskell has a pretty steep productivity curve
06:04:09 <hamid> why it accepts every Network* ?
06:04:11 <richo> scheme *
06:05:20 <typoclass> hamid: hm, that gives an error for me ... "could not find, perhaps you meant Network.Socket"
06:05:52 <Philippa> richo: yeah, fair enough. If you have to, you can just code in IO and you'll be moderately productive fairly quick, but it's sure not the best use
06:07:10 <yitz> richo: it's worse than that. once you learn haskell, you'll realize that you actually aren't very productive in those languages, and they will begin to feel painful.
06:07:21 <hamid> typoclass, It's 7.4.1 here! maybe an old bug?
06:07:31 <hamid> lambdabot, -v
06:07:34 <hamid> lambdabot, -V
06:07:45 <richo> I dunno if I'd go that far. Admittedly, for *this* problem domain it's been super fast, even without considering that I'm learning the implementation language as I go
06:07:45 <typoclass> hamid: i've got 7.4.2
06:08:08 <hamid> hmm :/
06:10:03 <richo> There are lots of problems I'd generally tackle with a certain language or idiom to get it done fast, but this "$language will make you realise all other languages are terrible" thing is kinda silly, imho.
06:10:27 <sclv> well you'll start adopting idioms more like
06:10:40 <sclv> my js code for example is now sort of weird
06:10:54 <sclv> because i'm writing as though i had adts with strong types
06:11:36 <eikke> sclv: you should use Fay or ghcjs, then your js code will even look weirder
06:11:38 <eikke> ;-)
06:11:50 <richo> I often get antsy when I'm working in a language without first class continuations
06:11:59 <richo> (or piss off my coworkers by using them in ruby)
06:12:10 <merijn> richo: As someone who only started considering himself fluent in haskell a year ago, and spend 6 months not being able to write anything useful and another year or so of not feeling like I could write a big real world project in haskell, I have to say that I now consider haskell my most productive first choice language
06:12:13 <sclv> i assume you just mean first class functons?
06:12:37 <richo> No, I mean first class continuations
06:12:39 <merijn> richo: I even write my quick throw-away data munging scripts in haskell nowadays
06:12:53 <elliott> haskell doesn't even really have "first-class continuations", depending on your definition
06:13:06 <richo> elliott: I know, scheme does though
06:13:14 <yitz> hmm. hamid left. but yeah, it's an old bug. support for import in ghci was still a little rough-edged in 7.4.1.
06:13:18 <richo> and now I don't know how to reason about functions that can't return twice :)
06:13:22 <elliott> it has 1.5-class delimited continuations which are far better, though :)
06:13:43 * sclv has never actually needed delconts for anything serious
06:14:09 <richo> merijn: I didn't mean to start a flamewar. I often think that argument is silly, but if haskell turns out to be more productive than anything else I've used... that sounds good!
06:14:13 <sclv> actually I've never even really used callCC in haskell
06:14:16 <Philippa> they're only interesting when you're doing something 'stateful' anyway
06:14:20 <yitz> richo: it's not that there's anything really wrong with other languages. it's just that you'll acquire a whole new way of thinking.
06:14:25 <merijn> richo: I feel a big problem is that not only do you have to learn haskell, but also the ecosystem of frequently used libraries, like transformers, etc.
06:14:30 <sclv> I've used "convert into cps style" pervasively though
06:14:32 <Philippa> you can sure as hell write usefully in CPS
06:14:34 <sclv> + the cont monad as such
06:14:48 <Philippa> but we tend to end up re-abstracting when we catch ourselves doing that
06:14:56 <yitz> richo: in some languages, you'll just use it there, too. in other languages... well... you'll want to, but it won't be so easy.
06:15:10 <richo> Yeah, that's part of why I'm learning haskell. Less so much to necessarily start using it for everything, but because I want the context of such a strict language
06:15:20 <mauke> >strict
06:15:45 <mauke> Haskell is simultaneously non-strict and very strict
06:16:38 <yitz> richo: i find that i can still write idiomatic python. but i use generators, iterators, and comprehensions a *lot* more than i used to, and structure things differently.
06:16:45 <b2coutts> does haskell have a built-in "functional if", which wo/win 3
06:16:48 <b2coutts> er
06:16:51 <elliott> b2coutts: no
06:16:58 <Philippa> richo: so personally (and I'm not the only one to make this argument) I'd say the only thing Haskell is really strict about is insisting that you do your paperwork on what weirdness you're doing
06:16:58 <richo> python's decorators are my goto simile for monads
06:17:08 <yitz> richo: in java i just kind of wince and push on
06:17:14 <richo> obviously they're not the same, but they're the easiest way I've found to explain them in 2 minutes.
06:17:16 <Philippa> where paperwork = typing, but you're free to let most of it be inferred
06:17:18 <merijn> richo: It's not an "all other languages suck" type of thing (well, they do, but let's ignore that) it's just, that I have reached the point that I don't feel there's a compelling argument to use another language, if given the choice
06:17:39 <Philippa> richo: it, er, turns out decoration is more closely related to /co/monads. Long story, ask someone else when you're ready? :-)
06:17:56 <sclv> but decoraters aren't exactly decoration
06:17:58 <richo> yeah, it's not a perfect explaination
06:18:14 <richo> but smugly announcing that monads are just monoids in the space of endofunctors doesn't really help
06:18:17 <merijn> richo: The only other language I frequently end up using besides haskell is C, because you know, sometimes you just need C. And even then I end up calling it from haskell often, because <3 FFI
06:18:20 <Philippa> merijn: I should be learning Agda. I certainly know there are better languages to be had in the design space around Haskell. But yeah
06:18:31 <merijn> richo: We're trying hard to squash that stupid joke
06:18:32 <sclv> 'programmable semicolon' is pretty good
06:18:33 <elliott> richo: fwiw, that's usually intended as a (somewhat tired) joke
06:18:37 <Philippa> richo: Context matters. If you're a mathematician, that /is/ all they are
06:18:45 <Philippa> (and that's the context it was originally uttered in)
06:19:01 <Philippa> merijn: we have a lot of those that we're a bit careless with :-( Oh well
06:19:01 <elliott> richo: anyone who says that in seriousness *to a haskell beginner* (in the context of learning the language from a programming pov) is pretentious and missed the joke :)
06:19:05 <sclv> eh that's not how any of the classic category theory stuff describes them -- at least at first
06:19:11 <richo> It was a funny joke, imho. Anyway, my point is that flawed analogy that sinks in is better than strictly accurate analogy that doesn't help
06:19:20 <merijn> Philippa: Oh, sure, but haskell is a local optimum in the language design + usable libraries space :)
06:19:37 <elliott> I think Philippa said that re: the joke line?
06:19:46 <richo> I'm talking about people who don't know haskell, or particularly care about FP, but want to know what the fuss is all about
06:19:58 <richo> I can't type that fast.. lots of people are hilighting me
06:20:04 <sclv> monads in the general cat-theory sense are sort of way more amazing and general than the limited sense we treat them in haskell
06:20:06 <intoverflow> I love the combo of 'not particularing carly' but 'want to know what fuss is about'
06:20:07 <Philippa> richo: FWIW, for monads /in Haskell/, what I'm saying about embedded languages is strictly accurate. I can define the class of language for you some other time if you like, gtg shortly though
06:20:24 <yitz> richo: q: how many haskell programmers does it take to change a light bulb? a: it's just a monoid in the category of endofunctors. q: wat?
06:20:46 <richo> I agree. Parsec is /amazing/ compared to most of the parser generators I've used.
06:20:48 <AlexT> What are n plus k patterns?
06:20:51 <AlexT> and why are they banned?
06:20:52 <sclv> yitz: you can't _change_ a lightbulb. you just build a new lamp!
06:20:57 <mauke> AlexT: terrible!
06:21:02 <richo> sclv: snrk.
06:21:04 <merijn> Philippa: I still need to start playing with Agda, Idriss or Epigram, but I figure I should focus on throwing out a bunch of haskell code to build a portfolio first
06:21:07 <merijn> AlexT: Awful
06:21:16 <quchen> AlexT: Evil
06:21:17 <yitz> sclv: here we go... weeee
06:21:21 <sclv> not banned, removed from the language
06:21:25 <mauke> AlexT: foo (n + 1) = n
06:21:25 <AlexT> mauke: fac 0 = 1; fac n = n * fac (n-1)
06:21:27 <typoclass> AlexT: it's an odd piece of syntax that caused more confusion than good. they were turned off by default in h'2010
06:21:39 <richo> fwiw though, I think a lot of this is why people don't take it up
06:21:41 <mauke> AlexT: fac (n + 1) = (n + 1) * fac n
06:21:46 <elliott> AlexT: a good, futuristic idea dreamt of before its time.
06:21:46 <AlexT> mauke: What's so bad in that?
06:21:52 <sclv> it seems appealing
06:21:55 <elliott> AlexT: unfortunately the result is unworkable and too limited to be of much use.
06:21:57 <richo> most of your suggestions about explaining monads are accurate, but if you're not that hellbent on learning haskell they're not relevant
06:22:02 <sclv> but then it relies on num typeclasses
06:22:14 <elliott> AlexT: the bad thing is it only works for (+)
06:22:17 <AlexT> mauke: Oh, it's not fac n = n * fac (n-1)
06:22:24 <elliott> and can have some unusual results
06:22:26 <merijn> richo: Sure, but if people don't want to learn, you can't teach 'em anyway
06:22:27 <richo> in all liklihood I still would be unwilling to actually inest enough time to learn it if it weren't for this specific book I'm reading
06:22:28 <sclv> and certain things holding true abstractly for all instances of num such that the equations hold
06:22:41 <sclv> so its not semantically sound but a syntax-hack to make certain things look cuet
06:22:46 <richo> merijn: not true, I would wager more people have accidentally learned ruby than haskell
06:22:56 <AlexT> Oh, I get it now.
06:22:58 <richo> even if you accounted for adoption %
06:22:58 <AlexT> Thanks guys :)
06:23:20 <typoclass> richo: my 2 cents are -- some years ago my opinion was "i'mma write something in python, because i don't know python; i'mma write something in javascript, because i've never done that, and so on". i said that it's silly to limit yourself to one language, then claim "this is the best one"
06:24:07 <sclv> if i recall we briefly had an extension to some compiler (hugs?) that gave us n*m + k patterns
06:24:14 <merijn> typoclass: Now your opnion is "i'mma write something in Agda, because I didn't wanna run my program anyway"?
06:24:18 <typoclass> richo: long story short, after learning a bit of haskell, i tried some python again, but couldn't manage. it just felt all awkward. it may sound cultish, but i'm not saying stuff anymore like "any language is roughly as good as any other"
06:24:21 <sclv> s/compiler/compiler or interpreter/
06:24:51 <typoclass> merijn: not sure :-) haven't looked at it. i got disappointed when learning that i no can has type inference
06:25:21 <merijn> richo: If you ask here, almost everyone will agree that haskell is not the best possible/most ideal/whatever programming language. It's just that everyone considers it the best one *that is currently realistically usable in the real world*
06:25:52 <merijn> A lot of people here have an active interest in creating languages better than haskell
06:26:04 <richo> can I pose a hypothetical though?
06:26:08 <Ke> we already have Rust
06:26:09 <typoclass> richo: regarding the quote about 'an endofunctor, what's the problem', that was originally written as a joke. i hope nobody uses that as a sincere explanation
06:26:10 <merijn> Sure
06:26:11 <typoclass> @google brief mostly wrong history
06:26:12 <Ke> !!
06:26:12 <lambdabot> http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
06:26:12 <lambdabot> Title: One Div Zero: A Brief, Incomplete, and Mostly Wrong History of Programming La...
06:26:13 <quchen> merijn: For example Haskell 2014 :-)
06:26:18 <merijn> Ke: Rust doesn't strike me as better
06:26:32 <typoclass> source of the quote ^^ very well written
06:26:40 <richo> the other day I needed to write a server tha recieves http-ish requests from some hosts, and also accepts longpolling requests from other hosts, which subscribe to meta channels.
06:26:42 <merijn> typoclass: People do, or repeat it in contexts where the listener won't know it's a joke, at least
06:26:53 <richo> Would you have necessarily written that in haskell because it's easiest?
06:27:15 <merijn> richo: Yeah, in haskell I'd use one threat per connection and write nice synchronous code
06:27:39 <richo> well, ignoring how hilariously expensive that would get
06:27:42 <merijn> richo: In C it'd be a pain, in python I'd have to use something like Twisted and get convoluted callbacks, ruby...I don't know what they support
06:27:44 <elliott> no
06:27:46 <richo> given that this thing multiplexes LOTS of connections
06:27:46 <elliott> not expensive
06:27:53 <elliott> haskell has very efficient threads
06:27:56 <merijn> richo: Haskell threads scale up to >100k
06:27:58 <elliott> they don't map directly to OS threads
06:27:59 <richo> merijn: erm, my pytho implementation is like 20 lines
06:28:11 <richo> ok, I didn't know haskell had it's own green thread, disregard
06:28:16 <elliott> erlang is the closest reference point for haskell threading's efficiency
06:28:19 <yitz> richo: makes you think of erlang.
06:28:21 <typoclass> richo: i'd assume the haskell version is really not expensive in terms of runtime
06:28:25 <merijn> richo: The GHC runtime use kqueue/epoll to multiplex haskell threads onto multiple OS threads
06:28:37 <richo> Eep! point taken
06:28:41 <richo> I read thread == OS thread
06:28:45 <elliott> ...and also, you can write synchronous IO code in these threads and it gets turned into efficient epoll async code under the hood :)
06:28:53 <elliott> (node.js without all the continuation-passing style, effectively)
06:29:05 <typoclass> richo: yes, haskell uses green threads now since several compiler versions (2-3 years or so)
06:29:05 <richo> but needing an "Event framework" to do async is a fallacy, I just did it with select(2)
06:29:18 <merijn> In haskell world thread usually means "forkIO :: IO a -> IO ThreadId" which is a green thread
06:29:23 <merijn> richo: Sure, I've done that too
06:29:25 <sclv> off topic but i just remembered this apropos of light bulbs
06:29:31 <richo> ok, I lie. 103 lines of python, including all setup and teardown.
06:29:35 <sclv> q: how many prolog programmers does it take to change a lightbulb.
06:29:37 <merijn> richo: And it's a right pain compared to just writing synchronous threaded code ;)
06:29:40 <sclv> a: no.
06:29:43 <richo> but my point was more that for this quick and dirty, realworld problem
06:29:49 <richo> is haskell actually any easier?
06:30:02 <yitz> sclv: :)
06:30:03 <richo> (not trolling, I'm actually really curious)
06:30:22 <b2coutts> richo: in my limited experience: for some things
06:30:24 <merijn> richo: Well, like I said. A year or so ago I probably would've said no. Now, I say yes
06:30:48 <b2coutts> a lot of really basic quick and dirty things turn into one-liners in haskell
06:30:49 <mreh> depends if you want to refactor your solution
06:30:51 <richo> can you link me to an example of how the message passing would work?
06:31:00 <mreh> and stay sane
06:31:09 <b2coutts> that said, a lot of the time, just hacking together a few ugly lines of perl without having to think is easier/faster
06:31:11 <elliott> for networking code I don't think you can beat Haskell in terms of clarity while maintaining efficiency
06:31:13 <merijn> richo: My data munging shell script (used to splice experimental output into other files) includes two ad hoc haskell scripts written for that purpose
06:31:13 <typoclass> richo: given someone who is familiar with some libraries (http-conduit or some such), i'd expect your http server to come out at about the same line-count (or lower). i'd expect it to be faster in haskell than python
06:31:15 <mreh> and continue to develop it later
06:31:19 <b2coutts> this may not be the case for people who are more familiar with haskell
06:31:19 <mauke> typoclass: wait, are you saying ghc used to map forkIO stuff directly onto OS threads?
06:31:22 <elliott> the threading/network stuff is just fantastic.
06:31:24 <merijn> richo: You'll want to look at Control.Concurrent
06:31:32 <richo> merijn: thanks
06:31:39 <merijn> richo: Which includes MVar, Chan, etc.
06:31:42 <elliott> also, STM!
06:31:45 <merijn> Yes
06:31:47 <merijn> STM!
06:31:49 <elliott> STM is great. and nobody else does it well.
06:31:52 <merijn> Glorious STM!
06:31:57 <merijn> elliott: I heard Clojure did ok
06:32:02 <yitz> @google beautiful concurrency --richo
06:32:04 <typoclass> mauke: i don't know what they did, but the io manager thingy that makes the stuff so efficient appeared in 7.0 or thereabouts
06:32:05 <lambdabot> http://research.microsoft.com/pubs/74063/beautiful.pdf
06:32:05 <lambdabot> Title: Beautiful concurrency
06:32:10 <richo> typoclass: ignore speed, although I'd be really interested to see if the haskell solution is faster than the C solution, which is only about 2x the size of python
06:32:16 <elliott> merijn: I understand you still get runtime errors if you're impure within transactions. rigged test, I know :)
06:32:24 <mauke> typoclass: that's definitely not true. maybe it got an overhaul in 7
06:32:33 <mauke> but the IO manager was there in 6.8
06:32:44 <mauke> and probably forever
06:32:48 <sclv> clojure stm has different semantics than haskell
06:32:53 <sclv> optimistic concurrency
06:32:57 <sclv> so you get write skew
06:33:12 <sclv> not sure if we've seen the two policies go head to head in real world code
06:33:19 <Ke> merijn: I'm still dreaming of future with no forced IO management
06:33:20 <eikke> mauke: iomanager was changed quite a bit
06:33:29 <Ke> or forced rt
06:33:36 <merijn> SPJ with his silly brace style
06:33:42 <eikke> (and more changes upcoming)
06:33:44 <sclv> its not forced on us
06:33:55 <sclv> we can always patch ghc :-)
06:34:00 <richo> yitz: this paper looks really good, thanks.
06:34:33 <mauke> ooh, and I remember 7.0.1 breaking preflex
06:34:35 <typoclass> richo: btw, which benchmark is that? did someone blog about it or post the code etc.? the python http server that was ported to c for comparison
06:35:17 <augur_> does anyone know if anyones noticed a relationship between regular expressions and zippers before?
06:35:45 <richo> typoclass: it doesn't actually implement http, it benchmarks the really narrow subset it needs
06:35:54 <richo> https://github.com/richo/choon-server
06:36:04 <richo> s/benchmark/parse/
06:36:08 <richo> I can't brain tonight
06:36:30 <richo> it just needs to pull enough context out of the response in order to know who it needs to notify
06:37:05 <typoclass> richo: right, sure. thanks for the link; will look
06:37:28 <richo> it's a super nasty hack. I just wanted to make it work.
06:37:39 <typoclass> richo: please refer to http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg#!i=960526257&k=MHs3MKC&lb=1&s=O
06:38:10 <richo> Amazing, thankyou.
06:42:31 <sclv> augur_: cf this stuff http://lambda-the-ultimate.org/node/2293
06:42:53 <sclv> basically they're both forms of derivatives, but you need to do a little juggling to make the two presentations match up
06:43:04 <zebr> hey all. is there a notion in pattern matching of a pattern's 'footprint'? say we have { Take Zero xs -> []; Take (Succ n) [] -> []; Take (Succ n) (x:xs) -> x : Take n xs }, then the 'footprint' would be (1 * (0 + 2)). that is, we must check argument 1, and then maybe argument 2 as well. obviously this tells us what might happen if any of the args are _|_ during the match.
06:43:24 <augur_> sclv: so maybe i've discovered something new! :D
06:43:30 <augur_> or maybe not! we'll see!
06:43:42 <sclv> read sigfpe's stuff in particular first
06:44:45 <zebr> to clarify, the combined 'footprint' would be that. individually they'd be 1, 1, and 1*2, respectively.
06:45:28 <byorgey> zebr: GHC certainly uses something like that internally to check pattern coverage
06:45:41 <byorgey> i.e. that's how it decides to issue warnings like "patterns not matched: ..."
06:45:44 <augur_> sclv: it seems i discovered something new
06:46:32 <byorgey> zebr: but I don't know if there's an accepted formal definition of the sort of thing you are describing
06:46:35 <zebr> byorgey: hmm, do you know where i should look to find anything about it? all i have is spj's old book on miranda :p
06:46:45 <byorgey> I'm not sure, sorry
06:46:49 <zebr> ok, thanks
06:47:05 <byorgey> maybe google for "coverage checking"
06:48:13 <dbaupp> zebr: http://moscova.inria.fr/~maranget/papers/warn/index.html maybe
07:08:54 <Sculptor> yo
07:15:53 <richo> Err, can someone explain http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html#g:2 in terms I might understand?
07:16:00 <richo> this documentation is pretty amazingly impenetrable
07:16:22 <mauke> that's because it makes no sense
07:16:35 <elliott> most likely the answer is "no". I recommend reading the Typeclassopedia or the original idioms paper
07:16:56 <typoclass> richo: yes, better docs are something that we're working on (sorry for that)
07:16:58 <elliott> even more likely is you have no reason to care about Applicative just yet and would do best to delay trying to figure it out until it'll seem a lot simpler
07:17:09 <byorgey> richo: Applicative is for things that support some notion of 'failure' and 'choice'.
07:17:10 <elliott> oh, that's even Alternative not Applicative
07:17:16 <typoclass> richo: which part are you interested in?
07:17:19 <richo> that sounds like what I'm trying to do?
07:17:29 <richo> Someone suggested that specific thing, which is why I'm reading it
07:17:42 <richo> I hit a wall with find, I could have made it work.. if I didn't mind silently swallowing errors
07:17:57 <byorgey> richo: 'empty' denotes "failure".  f <|> g  means a choice of f or g.  If f fails then g will be tried instead.
07:18:11 <byorgey> richo: do you already understand Functor and Applicative?
07:18:29 <elliott> is this re: "<yitz> richo: actually, in this case, you don't really need a monad - and Alternative (from Control.Applicative) is good enough."?
07:18:36 <richo> I want to make some calls to eval :: LispVal -> ThrowsError LispVal, but then conditionally bailout of some iteration over a List
07:18:43 <richo> elliott: that's the one
07:18:50 <elliott> I'm sure yitz has the best intentions there, but my not-so-professional opinion is that it's unlikely to help you accomplish your current task
07:19:03 <byorgey> that is pretty terrible documentation, by the way
07:19:08 <richo> byorgey: Erm, kinda? I dunno. My notion of understand has been pummelled rather violently in the last few days.
07:19:13 <elliott> it's a true statement, but I don't think learning about the Functor/Applicative/Alternative hierarchy is the right next step here :)
07:19:20 <byorgey> richo: hehe, ok =)
07:19:32 <byorgey> kinda is good enough for now.
07:19:45 <elliott> I would suggest just writing your "cond" function as a recursive function using your existing monad, if that's what you have.
07:19:52 <byorgey> mostly I was just thinking that if you had not even heard of them then you should go back and learn those first before tackling Applicative.
07:20:11 <richo> elliott: I can do that, but it'll evaluate all the predicates
07:20:19 <richo> and since they can have side effects that would be bad
07:20:19 <elliott> (we should rename Alternative, apparently it's impossible to type it instead of Applicative...)
07:20:33 <fizbin> I think I agree with emmetk that "Alternative" is just as screwed up as MonadPlus for similar reasons.
07:20:39 <merijn> richo: Why would it eventually evaluate all the predicates?
07:20:42 <elliott> richo: I assure you, if you write your recursive function correctly by hand it won't execute the side-effects of all the predicates
07:20:48 <merijn> richo: You could just stop the recursion?
07:20:52 <elliott> and perhaps seeing why will be enlightening
07:20:59 <richo> merijn: right, how do I do that?
07:21:03 <elliott> richo: note - it's important to distinguish "evaluate" and "execute"
07:21:14 <merijn> richo: Similar to, for example
07:21:21 <richo> elliott: I get that because it's lazily evaluated it "shouldn't", but then I lose all my internal gaurantees of correctness
07:21:34 <richo> (internal, as in my internal representation of what I'm building, not the code or runtime)
07:21:53 <elliott> ("evaluation" never has side-effects in Haskell. "execution" depends on contextual information: it's "local" to the monad (or similar structure) you're working in. i.e., evaluating a state action is always harmless, it's *executing* it inside your state monad action that can be harmful.)
07:22:03 <merijn> > let { drop _ [] = []; drop 0 xs = xs; drop n (x:xs) = drop (n-1) xs} in drop 5 [1..10]
07:22:04 <lambdabot>   [6,7,8,9,10]
07:22:07 <elliott> (this might seem a pedantic distinction -- but if you mix them up, you'll find it very hard to reason about how your effects are happening.)
07:22:08 <typoclass> richo: is this still part of implementing 'cond' from scheme?
07:22:14 <richo> typoclass: yup
07:22:17 <merijn> richo: There you go, recursion that stops early
07:22:20 <elliott> (and in particular, lazy evaluation doesn't have anything to do with how your effects get executed)
07:22:26 * typoclass looks up what 'cond' is
07:22:39 <richo> http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_idx_106
07:22:59 <typoclass> richo: thanks
07:23:00 <richo> basically, given a list of (predicate action) pairs, evaluate the first action for which predicate evaluates true
07:23:21 <richo> (and return it's value)
07:23:35 <richo> and also the else stuff, but I've made peace with that being broken in my implementation for now.
07:24:21 <elliott> richo: ...so, given what I said, you can write a manually recursive function working inside your Scheme evaluation monad
07:24:30 <elliott> richo: and its correctness won't depend on details of evaluation order or anything of the sort
07:24:35 <hpaste> merijn pasted “stop early” at http://hpaste.org/90098
07:24:39 <augur_> hmm very interesting indeed
07:24:45 <merijn> richo: See that paste?
07:24:48 <elliott> richo: the side-effects caused by executing the conditions will be *explicit* in the code you write -- that's how using monads works
07:25:27 <richo> ooooooh
07:25:34 * richo is not a clever man
07:25:53 <richo> thanks merijn, I evidently needed a harder whack with the clue stick :)
07:25:58 <merijn> richo: :)
07:26:00 <augur_> there's a whole family of regular expression like things. hmm.
07:26:12 <richo> for some reason I'd decided to implement this iteratively, which was causing me all kinds of headache.
07:26:18 <elliott> richo: don't worry. other languages promote the punning of the concepts of "evaluation" and "execution", "expression" and "(side-effectful) action", that a large part of learning this stuff is forgetting that they could be confused...
07:26:28 <elliott> er, that sentence needed an adjective and stuff.
07:26:35 <elliott> *so heavily
07:26:42 <richo> I know what you meant
07:26:43 <typoclass> richo: so, just to step back for a moment, what went wrong with 'find'? it sounds to me as if find or a similar function would be ok
07:26:53 <elliott> :t find
07:26:55 <lambdabot> (a -> Bool) -> [a] -> Maybe a
07:27:00 <richo> basically that find wanted Bool
07:27:09 <elliott> no way to do -> Bool when deciding whether it "matches" requires executing in a monad m.
07:27:10 <typoclass> merijn: wait, the recursion ends with 'error'?
07:27:12 <richo> and implicitly I use ThrowsError Bool
07:27:25 <richo> so I'd need to deal with errors inside the predicate passed to find, and in doing so swallow errors
07:27:26 <merijn> typoclass: Only if no condition matches
07:27:37 <richo> so basically, what elliott said.
07:27:41 <merijn> typoclass: I forgot the exact semantics of cond
07:27:46 <typoclass> merijn: :-D
07:28:17 <merijn> Changing the stop condition should be simple
07:28:29 <typoclass> elliott: oh, so the Bool is produced by a monadic action? because the example code had stuff like (3 < 4)
07:28:44 <elliott> well, it's lisp code.
07:28:48 <elliott> it has side-effects
07:29:04 <richo> merijn: what you send is perfect, I already implemented evalCond, which is poorly named but deals sanely with the clauses and bargs appropriately if they're malformed.
07:30:20 <danil> the "similar function" to find that would have worked would be called findM if it existed in some standard library, which unfortunately (afaik) it doesn't
07:30:50 <richo> it's ok, this is better
07:30:55 <richo> and is also easier for me to reason about
07:31:39 <Guest89774> I am trying to use ghci.conf on Ubuntu 13.04, but when ghci starts it shows error "*** WARNING: ~/.ghc is writable by someone else, IGNORING!"
07:31:44 <Guest89774> how do i fix this?
07:32:21 <typoclass> > let cond = fmap snd . find fst in cond [(3 < 3, "lol"),   (5 < 4, "cat"),   (otherwise, "meow")] -- richo: here is a simpler example using pure conditions (i.e. they can't have side-effects, they can't read from files/the network/etc.)
07:32:22 <lambdabot>   Just "meow"
07:32:31 <quchen> Guest89774: Check permissions of ~/.ghc. It should only be writable by the owner.
07:32:50 <richo> typoclass: yeah, I had it working if I could somehow magically make eval pure
07:32:57 <typoclass> richo: an error (none of the conditions matching) is signalled to the caller by using Nothing
07:32:59 <richo> which I did, but it swallowed errors
07:33:12 <typoclass> richo: ok
07:33:15 <quchen> Guest89774: ghci.conf is loaded and executed when you start GHCi. If someone injects malicious code, it is executed with your user rights. Not a good thing.
07:33:25 <richo> typoclass: errors already work, in that they basically bubble up to the entrance of the ThrowsErrors monad and explode in the repl
07:33:29 <quchen> (And it can contain arbitrary Haskell.)
07:33:59 <hamid> Guest89774, use "chmod"
07:34:01 <Guest89774> quchen -> got it. thanks for the help.
07:34:25 <hiji> What is the Haskell equivalent of Python's type(a) ?
07:34:35 <mauke> hiji: no
07:34:39 <elliott> hiji: does not really exist, what are you trying to achieve?
07:34:43 <typoclass> hiji: not sure, what does type(a) do?
07:34:58 <hiji> in python: a = []
07:35:00 <elliott> there are things that are superficially similar, but (a) different in important ways and (b) very unlikely to be what you want
07:35:03 <hiji> type(a)
07:35:04 <danil> :t expression at the repl; outside of the repl, the answer is "that doesn't really make sense"
07:35:05 <lambdabot> parse error on input `;'
07:35:16 <hiji> >> <type 'list'>
07:35:17 <elliott> so we need to know the higher level of what problem you're trying to solve to help
07:35:22 <eikke> :t typeOf
07:35:23 <lambdabot> Typeable a => a -> TypeRep
07:35:28 <eikke> *grin*
07:36:19 <hiji> well I did: doc <- getResponseBody =<< simpleHTTP (getRequest "http://rate-exchange.appspot.com/currency?from=USD&to=JPY")
07:36:21 <typoclass> eikke: that's not going to be helpful, with 99% chance
07:36:30 <hiji> and I want to know the return type of doc
07:36:58 <typoclass> hiji: ah :-) if you've done "doc <- getRespose..." in ghci, you can do ":t doc" now
07:36:58 <hiji> I guess the logical way to go about it is to write down the type signatures for each of those functions
07:36:59 <eikke> typoclass: hence the grin
07:37:07 <sipa> hiji: you want to know this at runtime, or for debugging?
07:37:20 <hiji> I'd like to know both answers
07:37:23 <elliott> hiji: you can write
07:37:24 <elliott> doc <- getResponseBody =<< simpleHTTP (getRequest "http://rate-exchange.appspot.com/currency?from=USD&to=JPY")15
07:37:24 <hiji> but right now just for debugging
07:37:27 <elliott> in GHCi
07:37:27 <elliott> and then type :t doc
07:37:33 <mauke> <typoclass> hiji: ah :-) if you've done "doc <- getRespose..." in ghci, you can do ":t doc" now
07:38:01 <elliott> in general, types don't really exist at runtime. Typeable/typeOf/etc. let you recover it to some degree, but it's usually not something you want to be doing, given that you know what all the types are statically anyway
07:38:25 <hiji> I'm going to do this in ghci now, but so far I've been writing this in a file and compiling with ghc
07:38:52 <mauke> hiji: if you had that information at runtime, what would you do with it?
07:39:25 <hiji> Let's say the URL can be passed as an argument
07:39:29 <typoclass> hiji: regarding inside of a program: the short story is, don't do that. there are some possibilities, but they are somewhat advanced and only useful in some very specific cases
07:39:32 <hiji> and some URLs return json
07:39:36 <hiji> and some return HTML
07:39:39 <elliott> that won't happen
07:39:43 <hiji> both require different parsers
07:39:47 <elliott> the types will always be the same
07:40:04 <elliott> you can model this either-or but it won't involve something dynamically deciding to have a different type at runtime
07:40:11 <elliott> (so recovering such a type wouldn't help)
07:40:43 <hiji> ok that makes sense (I assume both json and html would just get returned as a string)
07:41:18 <hiji> but how does one find out types for debugging? i.e. I would like to know what functions I can use on the returned value
07:41:36 <typoclass> hiji: have you tried ":t"? (see messages above)
07:41:39 <elliott> well, generally the answer is to break stuff up into small, composable pieces
07:41:40 <hiji> how do I do that without knowing the type of the return value
07:41:42 <elliott> and then you can use :t on the pieces directly
07:41:44 <hiji> yes, I know of :t
07:41:49 <hiji> but it works only in GHCi
07:41:50 <elliott> and generally interact with things in GHCi to develop
07:41:54 <elliott> sure
07:41:57 <elliott> GHCi is how we debug :)
07:42:01 <hiji> :D
07:42:15 <Cale> If you don't have GHCi, then just thinking about it will suffice
07:42:18 <elliott> it takes some getting used to, but it's far nicer than sprinkling printfs everywhere
07:42:19 <hiji> small, composable pieces and debug with ghci. got it :)
07:42:24 <Cale> (and reading the documentation)
07:42:54 <hiji> thanks for that
07:44:03 <hiji> one more question: Can someone explain the difference between doc <- getResponseBody .................  and let doc = "aaaa"
07:44:21 <hiji> aren't they both essentially doing the same thing of assigning a value to a "variable"
07:44:45 <Philonous> Is there a fundamental difference between [foo|bar|] and $(quoteExp foo $ "bar") ?
07:46:35 <boothead_> hiji: doc <- SomeMonad is pulling out whatever lives in the Monad whereas let doc = "something" more like assigning a value to a variable.
07:47:15 <boothead_> hiji: the first one is just sugar for SomeMonad >>= \doc -> <further actions>
07:47:17 <enthropy> Philonous: I think quasiquotes get run at an earlier stage than $( )
07:47:38 <richo> elliott, merijn thank you both so much for your help
07:47:48 <hiji> boothead_, where >>= means pass the results of SomeMonad into the next lambda
07:47:49 <elliott> :)
07:47:50 <hiji> right?
07:47:59 <richo> both with the cond thing, and about arguing about haskell in general. It's totally invaluable and I really appreciate it
07:48:00 <elliott> hiji: sure, close enough
07:48:13 <elliott> richo: if there's one thing IRC is great at it's arguing
07:48:21 <richo> Right?
07:48:23 <hiji> boothead_, elliott thanks :)
07:48:44 <boothead_> no probs hiji
07:48:55 <sclv_> augur_: I look forward to reading about it
07:49:03 <enthropy> Philonous: but maybe that only matters that you can put quasiquotes in patterns like    \ [foo|bar|] -> ... can use variables bound by quotePat foo "bar"
07:49:13 <augur_> sclv_: :)
07:53:02 <yitz> enthropy: and i think it's pretty rare to find quasiquoters in the wild that actually use that pattern-matching capability
07:56:08 <yitz> hi hamid, youre back :) about accepting non-existent modules for import in ghci: yeah, it's an old bug. support for import in ghci was still a little rough-edged in 7.4.1. fixed in 7.4.2.
08:02:00 <hamid> yitz, ow! That's odd how 7.4.1 is used in Debian Wheezy (the current stable release). anyway thanks for informing me. :)
08:02:29 <richo> ok, I will admit this is hilariously powerful and quite pleasing to write
08:03:06 <tippenein> cabal-install says I'm likely to break network, hslogger, MissingH, ConfigFile, json and irc if I install yesod
08:03:40 <luite_> tippenein: you can install yesod with cabal-dev or hsenv to avoid breaking any existing thing
08:04:08 <tippenein> ah, I have cabal-dev. didn't know you could set up a virtaual environment with that
08:04:54 <yitz> hamid: oh, 7.4.1. is a pretty good release. i used it for a long time.
08:05:20 <yitz> hamid: before that, import in ghci wasn't available at all; only the :m command, which you can still use.
08:07:28 <yitz> tippenein: the yesod depenency tree is very complex, so whichever way you do it, expect to re-do your package DB from time to time.
08:08:45 <yitz> tippenein: e.g. with cabal-dev: you'll often do rm -r cabal-dev
08:09:32 <yitz> tippenein: with regular cabal i re-install ghc/haskell-platform, but that's probably overkill.
08:10:13 <yitz> tippenein: not sure what to do with hsenv or the new built-in sandboxing in cabal
08:11:33 * elliott notes that new cabal sandboxing is fantastic!
08:12:18 <quchen> elliott: Is it released yet? I remember hearing about "future cabal versions will support sandboxing" and nothing since then
08:12:42 <monochrom> it is not released yet
08:12:43 <yitz> quchen: no but you can get it from the github HEAD version
08:12:43 <typoclass> quchen: the sand is already here, it's just not evenly distributed?
08:13:18 <elliott> I installed HEAD cabal-install. it works fine
08:13:26 <yitz> elliott: yeah now that dcoutts has convinced me that it can be safely used even with older ghcs, i'm going to learn it and probably move my team over to it.
08:13:44 <quchen> Thanks for the info!
08:14:10 <elliott> there are some minor output issues i'd like to be resolved, but the functionality itself is great
08:15:29 <quchen> I assume this is the repo you're taling about? https://github.com/haskell/cabal
08:17:32 <elliott> yes
08:27:44 <parcs> :t lazy
08:27:46 <lambdabot> Not in scope: `lazy'
08:28:33 <Hafydd> @let lazy = lazy
08:28:34 <lambdabot>  Defined.
08:28:38 <Hafydd> :t lazy
08:28:39 <lambdabot> t
08:29:31 <parcs> hmmmm
08:29:42 <monochrom> are you looking for GHC.Exts.lazy ?
08:30:01 <hamid> which Web framework do you suggest for rapid prototyping?
08:30:40 <parcs> monochrom: yeah, what's it for?
08:39:43 <monochrom> in my words, it blocks the strictness analyser. it is marked as "strict", so when the strictness analyser sees "lazy blah", it doesn't go on analysing "blah". but after that, "lazy" is compiled away, it's "blah" alone, it is now under lazy evaluation because no strictness analysis has been done on it to change it
08:40:27 <monochrom> GHC.Prim.lazy has an example
08:42:59 <tippenein> yitz: hsenv seems to work intuitively. I'm coming from python so anything similar to virtualenv is nice
08:44:32 <HugoDaniel> hi, im trying to compile ghc 7.6 on dragonflybsd (it has 7.4 on the ports) and i currently get a "Unknown vendor portbld" on the configure script
08:44:40 <HugoDaniel> any hints how i can solve this ?
08:46:23 <monochrom> or maybe it is marked as "non-strict". anyway the strictness analyser doesn't go on looking into "blah". I just can't think straight what marking accomplishes it
08:46:42 <Taneb> I sometimes wish there was a sort of {-# COMPILE_AWAY #-} pragma
08:47:09 <Taneb> Actually, that's sort of what RULEs are for, aren't they?
08:50:32 <koala_man> can I include unit tests in my main source file and have cabal run them?
08:51:44 <tippenein> hmm, installed yesod with hsenv activated and when I try to run the website it can't find yesod
08:52:01 <tippenein> I feel weird asking yesod questions in here.. is there a channel for it?
08:52:54 <danil> koala_man: yes, http://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites
08:52:56 <tippenein> I see that there is. n/m
08:56:37 <koala_man> danil: if my module exports tests, does that mean that the tests won't be compiled out?
08:59:40 <tippenein> any reason hsenv wouldn't find yesod even though I've installed it with cabal within an active hsenv?
09:02:10 <parcs> monochrom: that makes sense, thanks
09:02:47 <yitz> tippenein: in cabal-dev, binaries are installed in cabal-dev/bin, not the usual place. maybe something like that in hsenv, don't know.
09:02:48 <danil> There's no way to put the tests in the main source file and expose them to the test harness without exposing them to other users of the module, so they'll be in the compiled version of the library.  I think the linker shouldn't link them into any executable that doesn't use them, though.
09:03:26 <yitz> tippenein: also look in the dist subdirectory, i think you'll find it there too
09:03:37 <yitz> dist/build/<app-name>
09:04:50 <byorgey> yitz, tippenein: yes, hsenv installs stuff under  dist_<hsenv-name>/
09:05:12 <byorgey> <hsenv-name> defaults to "hsenv" unless you gave an explicit --name argument to hsenv
09:05:17 <tippenein> I see no dist_dir
09:05:48 <byorgey> tippenein: did you install any executables or documentation? Or just libraries?
09:06:09 <yitz> ahh right
09:06:18 <yitz> well
09:06:18 <tippenein> basically just: hsenv; source .hsenv/bin/activate; cabal install yesod
09:06:37 <yitz> ok that should get you the exe yes
09:07:00 <tippenein> but when I try yesod --dev devel it doesn't find yesod exec
09:07:14 <yitz> tippenein: you'll have to give the path to yesod
09:07:32 <byorgey> tippenein: oh, sorry, I was confused, look in  .hsenv/bin/
09:07:50 <byorgey> that's where top-level stuff goes
09:07:58 <tippenein> hmm, yah. no yesod in there
09:07:58 <byorgey> dist_hsenv is where it puts intermediate build stuff
09:08:05 <byorgey> the stuff which would usually go in dist/
09:08:37 <byorgey> agh, I am wrong again =)
09:08:46 <byorgey> look in  .hsenv/cabal/bin
09:08:50 <yitz> are you sure the build succeeded?
09:09:11 <byorgey> stuff which would normally go in .cabal instead goes in .hsenv/cabal
09:09:15 <yitz> actually, cabal tells you where it put the binary in its message, near the end, when it links
09:09:16 <tippenein> yitz: ahhhhh, you're right
09:09:30 <tippenein> language-javascript failed
09:09:40 <byorgey> aha
09:09:48 <tippenein> sorry, didn't see that
09:10:55 <tippenein> and language-javascript fails because happy isn't version >=1.18.5
09:12:56 <tippenein> ok, got it to compile
09:13:04 <tippenein> worked after I installed happy manually
09:13:16 <tippenein> then did cabal install yesod --reinstall
09:21:40 <tippenein> http://imgur.com/mV9g7N1 :/
09:36:37 <Dennis> Hi
09:37:30 <hsn> @faq JVM backend
09:37:30 <lambdabot> The answer is: Yes! Haskell can do that.
09:37:56 <byorgey> hi Dennis
09:38:19 <Dennis> Is anyone using a contract lib like http://www.cs.kent.ac.uk/people/staff/oc/contracts.html?
09:44:48 <yitz> tippenein: yesod --dev uses cabal-dev, but you are using hsenv
09:58:47 <hvr> byorgey: ping
09:59:18 <byorgey> hi hvr
09:59:41 <hvr> byorgey: ... did you have time to check if the latest HEAD of haskell-mode exhibits the Emacs23 issue?
10:00:32 <byorgey> hvr: haven't had a chance yet, sorry, but it's on my list
10:00:32 <hvr> byorgey: or rather, do you know which version exactly triggered the error you reported?
10:01:00 <hvr> as the fix was pushed only a few days before you reported the issue
10:01:03 <byorgey> I don't know exactly, but I did a "git pull" right before reporting just to make sure that it hadn't been fixed in HEAD
10:01:13 <hvr> i see
10:01:21 <byorgey> it's possible I did it wrong though
10:01:31 <hvr> I tried to reproduce it, but maybe I did something different from what you did
10:01:49 <hvr> btw, when you try again, try pinging me on irc, maybe we can sort it out interactively :-)
10:01:58 <byorgey> right, when I get a chance I will try to reproduce it for you
10:02:01 <byorgey> will do, thanks =)
10:09:28 <nob> i have a question about Maps
10:10:13 <nob> what is the best way to delete a set of keys from a Map?
10:10:13 <Philonous> nob:  Just ask
10:10:28 <nob> i could use a fold with delete
10:10:55 <nob> i would like to use difference, but that needs a Map and not a Set
10:11:41 <nob> so should i use difference and construct a Map with fromSet undefined mySet
10:12:20 <S11001001> nob: how about filterWithKey
10:14:24 <byorgey> that is odd that 'difference' takes a Map as the second argument and not a Set
10:14:43 <byorgey> or at least there ought to be a version that takes a Set.
10:14:53 <Philonous> nob:  deleting n elements from a Map of m would have complexity (n*log m) (when m >> n), while going the difference route only has O(n+m)
10:15:47 <byorgey> nob: instead of fromSet undefined mySet, use  fromSet (const ()) mySet
10:16:14 <Philonous> Oh, the element types don't have to agree
10:16:19 <byorgey> nope
10:16:24 <Philonous> Didn't realize that.
10:17:08 <nob> Ah, i didn't see that too
10:17:59 <nob> seems to be the best way
10:18:37 <dolio> I guess it has that type just due to differenceWith(Key)?
10:18:48 <nob> thanks Philonous and byorgey ! :)
10:18:57 <dolio> Still an odd decision.
10:21:43 <hpaste> tomejaguar pasted “Skolem type variable problem (Rank2Types)” at http://hpaste.org/90103
10:21:56 <tomejaguar> Can anyone explain why I get the skolem type variable error ^^
10:22:49 <tomejaguar> I want to write this function f where the type a can depend on the type s
10:22:58 <tomejaguar> It seems GHC does not allow this
10:22:59 <tomejaguar> Any ideas?
10:23:17 <byorgey> tomejaguar: can you paste the error message?
10:24:20 <hpaste> tomejaguar annotated “Skolem type variable problem (Rank2Types)” with “Skolem type variable problem (Rank2Types) (annotation)” at http://hpaste.org/90103#a90104
10:24:30 <tomejaguar> byorgey: ^^
10:27:14 <byorgey> tomejaguar: ah, I see.  Anyone who calls f gets to pick the types a, s', and a'.  But they must provide something that works for any type s (i.e. the implementation of f gets to choose s).
10:27:33 <byorgey> tomejaguar: however, you are trying to pass something to f in which the type s is not unconstrained
10:28:05 <byorgey> the implementation of f is not free to choose any type s it wants because s is constrained by the user's choice of a
10:29:13 <byorgey> I see what you are trying to do, that you would like the caller of f's choice of a to be able to depend on the implementation of f's choice for s
10:29:17 <augur_> is there a standard derivatives package?
10:29:26 <augur_> derivatives of types, i mean
10:29:33 <byorgey> but it's not possible to delay the choice of a like that
10:29:37 <tomejaguar> hmm
10:29:41 <tomejaguar> That unfortunate
10:29:57 <tomejaguar> I am trying to use something ST-like type trickery
10:30:01 <tomejaguar> for safety purposes
10:30:09 <byorgey> there is probably a way to encode what you want, but off the top of my head I am not sure
10:30:17 <byorgey> it might involve some existential types
10:30:33 <tomejaguar> Any idea of the best place to ask?
10:30:54 <byorgey> probably StackOverflow
10:31:10 <tomejaguar> OK thanks byorgey
10:50:57 <merijn> Is there a data structure like Map, but which guarantees the presence of all keys in a range?
10:51:07 <FreeFull> Array?
10:51:26 <merijn> hmm, maybe...
10:53:00 <FreeFull> I know Haskell arrays only allow for all cells in range to be filled
10:53:03 <FreeFull> Can't have an empty
10:53:20 <FreeFull> Although you could just use Maybe or something if you do want empty cells
10:55:04 <wandernauta> Hi all! Noob question here: doesn't Haskell's pattern matching syntax combined with its type declaration syntax make it tedious to add stuff to types? I'm from an OOP background, and I'm used to extending classes all the time. I believe a class would be most likely a type in Haskell, i.e. 'data Ingredient = Ingredient String Int', right? Then one would write for example 'cook (Ingredient name amount) = "Cooking " ++ name'. But doesn't
10:55:04 <wandernauta> this mean you have to change the signature for every single function every time you change what Ingredient is? For example, if you also want to keep track of the unit? Thanks in advance
10:56:41 <S11001001> wandernauta: what do you call this function: ??? (Ingredient name amount) = name
10:56:48 <monochrom> I have to modify "data Ingredient = ...", I have to modify patterns, but I will not have to modify types, they still say "Ingredient".
10:57:18 <jnerula> Record syntax would vastly simplify this problem, right?
10:57:21 <monochrom> also, look up "the expression problem". OOP makes some other extensions tedious.
10:58:09 <wandernauta> monochrom, Yeah, the type would still be Ingredient I guess... I'm not really looking forward to changing the patterns all the time.
10:58:17 <S11001001> wandernauta: well?
10:58:40 <jnerula> wandernauta: You wouldn't need to do that if your type signature just matches and ingredient type
10:58:49 <jnerula> You can then use record syntax functions to access data
10:59:08 <wandernauta> jnerula, I looked up record syntax, that looks neat, thanks :)
10:59:12 <dolio> Just don't change what Ingredient is all the time.
10:59:20 <Fuuzetsu> Alternatively just design your object first.
10:59:21 <wandernauta> S11001001, I'm not sure I understand the question... :|
10:59:25 <monochrom> in practice, I seldom have to extend.
10:59:43 <S11001001> wandernauta: I have a function ??? (Ingredient name amount) = name.  What do you put where I have ???
11:00:15 <wandernauta> S11001001, I would call such a function 'name' I guess, that's what record syntax does right?
11:00:16 <Fuuzetsu> S11001001: The function name I would guess.
11:01:02 <wandernauta> dolio Fuuzetsu : Hmm, I wish I could design my programs exactly right the first try... But I'm not that good just yet :)
11:01:15 <S11001001> wandernauta: Fine.  I have two functions, its ing = "It's " ++ name ing, and prits ing = putStrLn ("It's " ++ name ing).  I add a unit to Ingredient.  I have three functions.  How many patterns do I have to fix?
11:02:09 <monochrom> in OOP, there are only two situations I have to subclass. one is I use someone else's framework, e.g., Swing, Eclipse. the other is I emulate "data X = Case1 blahblah | Case 2 blahblah".
11:02:15 <wandernauta> S11001001, Ah, I get it. Only a few because you kinda abstracted the idea of 'accessing' the 'members' away
11:03:04 <monochrom> now, in Haskell and generally FP, frameworks are not based on subclassing at all, when I use someone else
11:03:16 <S11001001> wandernauta: Yes.  However, keep in mind that for some types and functions, it's desirable to fail on a data structure change, to remind you that you have to account for the new data in whichever function.  But you get to choose on a case-by-case basis how you get the data.  You don't need special haskell extensions to do this.
11:03:17 <monochrom> 's framework I don't subclass.
11:04:00 <monochrom> and I don't have to emulate "data X = Case1 blahblah | Case2 blahblah". it's already available directly.
11:04:29 <FreeFull> Missing cases for pattern matching are only a warning
11:04:39 <monochrom> therefore, all reasons for subclassing disappear. the question "how to extend in Haskell, it's tedious" is a psuedoquestion.
11:04:40 <FreeFull> And I think you only get the warning if you enable it first
11:04:43 <S11001001> FreeFull: not cases, product members
11:04:47 <wandernauta> S11001001, So you would pass an Ingredient around and not 'split it up' with patterns, then write functions for pulling the parts out of an Ingredient?
11:05:05 <FreeFull> S11001001: That's not a product, that's a sum
11:05:23 <wandernauta> monochrom, I wasn't really thinking about subclassing, more about forgetting that you also need to keep something else
11:05:26 <S11001001> FreeFull: that's not the situation wandernauta described.
11:05:36 <FreeFull> S11001001: I am talking about what monochrom wrote
11:05:42 <S11001001> FreeFull: oh, I see.
11:06:11 <monochrom> isn't pattern matching tedious in Java? see my http://www.vex.net/~trebla/humour/Nightmare.java
11:06:25 <S11001001> wandernauta: It entirely depends on the function.  Some functions I would still want to fail compile if I forgot to take into account some new piece of data I added
11:06:50 <FreeFull> monochrom: Everything is tedious in java
11:07:09 <wandernauta> FreeFull, Well put :)
11:07:38 <ment> FreeFull: it's supposed to be
11:07:39 <wandernauta> S11001001, So you'd write 'lower-level' functions with patterns and 'higher-level' functions to use those lower-level ones?
11:07:56 <Vendethiel> I never see anybody complain about the indentation-as-block in haskell ... Tell me the truth, what's your secret?
11:08:11 <FreeFull> Vendethiel: Indentation isn't forced on you
11:08:17 <FreeFull> You can always use the {;} syntax
11:08:32 <monochrom> what secret do you want to hear?
11:08:36 <dolio> monochrom: Wow.
11:08:42 <Vendethiel> I never saw it used, actually
11:08:48 <S11001001> wandernauta: yes, but really, that is always true, isn't it?  Higher-level functions don't look at the data directly, but more commonly use the functions you've written for dealing with that data
11:08:55 <FreeFull> Vendethiel: It's used a lot in GHC's source code
11:09:09 <Vendethiel> FreeFull: was that "the old way"?
11:09:18 <Vendethiel> before indentation-as-block was added
11:09:18 <FreeFull> I think it's just a style
11:09:21 <Vendethiel> oke
11:09:27 <monochrom> dolio: you haven't seen it? :)
11:09:38 <wandernauta> S11001001, Hmm, that makes sense, thanks :)
11:09:42 <dolio> No, I hadn't. And I hadn't thought of using exceptions to simulate pattern matching.
11:09:51 <monochrom> \∩/
11:10:12 <danil> Vendethiel: it's mostly for generated code, but some people prefer to write it that way too (notably, much of GHC)
11:10:35 <FreeFull> https://github.com/mchakravarty/BigPixel/blob/master/src/BigPixel.hs   This is relatively recent code by one of the developers of GHC, it uses the same style as GHC
11:11:05 <Vendethiel> still seems to use indent to me
11:11:16 <FreeFull> Although it doesn't seem to use the braces everywhere
11:11:24 <Vendethiel> well some part do not
11:11:25 <FreeFull> The where blocks don't use them
11:11:33 <FreeFull> But the do blocks do
11:11:35 <Vendethiel> yes this was what I noticed first
11:13:53 <chrisdotcode_> hola everyone!
11:14:24 <Vendethiel> what's $! ?
11:14:31 <Vendethiel> the problem with sigils is that they're not very searchable haha
11:14:42 <merijn> Vendethiel: They are!
11:14:44 <FreeFull> Vendethiel: You can look them up on hoogle
11:14:46 <merijn> @hoogle ($!)
11:14:46 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
11:14:46 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
11:14:56 <Vendethiel> OH
11:14:57 <FreeFull> $! is strict application
11:15:03 <merijn> @where hoogle
11:15:03 <monochrom> it is not sigil
11:15:03 <lambdabot> http://haskell.org/hoogle
11:15:10 <chrisdotcode_> when did lambdabot get so responsive?
11:15:18 <chrisdotcode_> (in terms of response speed)
11:15:20 <Vendethiel> yeah I didn't mean "sigil"
11:15:53 <merijn> Vendethiel: Most common operators are indexed by hoogle, so that's a great way to look them up
11:16:00 <FreeFull> f $! x  = x `seq` f x
11:16:28 <Dennis> Hey, have to ask again: Is anyone actually using "lazy contracts" ?
11:16:40 <Vendethiel> thanks
11:16:44 <monochrom> lambdabot changed from 64-bit to 32-bit
11:17:16 <chrisdotcode_> monochrom: did she really? >_>
11:17:33 <monochrom> I guess that's less important. more important is she changed virtual machine provider too
11:17:34 <typoclass> > maxBound::Int
11:17:41 <lambdabot>   2147483647
11:18:34 <monochrom> anyway, the whole story: she was transferred to elliott's custody. so, this includes changing VM provider. along the way, somehow 32-bit linux and GHC were also chosen
11:18:34 <chrisdotcode_> > log 2 maxBound
11:18:36 <lambdabot>   Could not deduce (GHC.Float.Floating (a0 -> t))
11:18:36 <lambdabot>    arising from the ambigui...
11:18:54 <chrisdotcode_> monochrom: and so switching to 32 bit made her *faster*?
11:18:59 <chrisdotcode_> that's interesting.
11:19:02 <merijn> chrisdotcode_: That's very common
11:19:04 <monochrom> I think 32-bit is better off for now, the VM provides only 1GB memory
11:19:07 <chrisdotcode_> merijn: is it?
11:19:10 <chrisdotcode_> :t log
11:19:11 <lambdabot> Floating a => a -> a
11:19:12 <merijn> chrisdotcode_: 64 is actually a slow down for pointer heavy code
11:19:14 <wandernauta> Makes sense, right? Smaller ints, smaller pointers
11:19:25 <chrisdotcode_> oh, yeah, that's right, wandernauta.
11:19:26 <merijn> chrisdotcode_: Yes, 64bit has bigger points trashing your caches
11:19:29 <chrisdotcode_> right
11:19:36 <monochrom> well, it could just be that linode sucked :)
11:19:41 <chrisdotcode_> heh
11:19:52 <monochrom> linode was previous VM provider
11:19:58 <chrisdotcode_> > maxBound :: Float
11:20:01 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
11:20:01 <lambdabot>    arising from a use of...
11:20:05 <wandernauta> Who's the current provider? I'm curious
11:20:18 <monochrom> I don't know. it has a numeric IPv6 address
11:20:37 <chrisdotcode_> :t maxBound
11:20:38 <lambdabot> Bounded a => a
11:20:42 <chrisdotcode_> huh.
11:20:46 <monochrom> therefore, it may be linode again and I can't tell :)
11:21:08 <chrisdotcode_> is something like `maxBound :: Int :: Float` legal?
11:21:17 <monochrom> have to wait for elliott to tell us about the VM
11:21:24 <merijn> chrisdotcode_: No
11:21:32 <merijn> chrisdotcode_: That's syntax error
11:21:57 <chrisdotcode_> merijn: so how would one convert maxBound to a Float?
11:22:10 <merijn> Float is not an instance of Bounded
11:22:23 <merijn> Neither is Double, afaik
11:22:40 <merijn> So it depends on what you mean by "convert"
11:22:42 <chrisdotcode_> but if you can convert a Bounded instance to an Int, and you cant convert an Int to a Float, then can't you compose some function to be it to a float?
11:22:52 <merijn> > fromIntegral (maxBound :: Int) :: Float
11:22:54 <lambdabot>   2.1474836e9
11:23:09 <merijn> chrisdotcode_: There's always fromIntegral and friends
11:23:18 <merijn> But what if maxBound is not a number?
11:23:23 <chrisdotcode_> > maxBound :: Float
11:23:24 <merijn> > maxBound :: Char
11:23:26 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
11:23:31 <lambdabot>    arising from a use of...
11:23:31 <lambdabot>   '\1114111'
11:23:32 <chrisdotcode_> > maxBound :: Int
11:23:35 <lambdabot>   2147483647
11:24:03 <merijn> > maxBound :: Bool
11:24:04 <lambdabot>   True
11:24:07 <monochrom> what is "convert a Bounded instant to an Int"? that is, without saying which instance.
11:24:18 <chrisdotcode_> oh, okay.
11:24:39 <chrisdotcode_> so what I wanted was "a way to find the maxBound of Int, and then convert that value into a Float"
11:24:41 <monochrom> methods of Bounded do not even talk about converting to anything
11:24:47 <chrisdotcode_> and you said fromIntergral is the way
11:24:50 <merijn> chrisdotcode_: There's non numerical Bounded data types, they can't be converted to Float at all. But any of the normal numerical conversions (like fromIntegral) will work on the Int instance of maxBound
11:25:10 <wandernauta> lambdabot is still Linode BTW :)
11:25:15 <chrisdotcode_> merijn: yeah, I didn't understand what maxBound was for a second.
11:25:19 <chrisdotcode_> typeclasses are cool.
11:25:25 <chrisdotcode_> much cooler than objects, IMO
11:25:39 <monochrom> then it's really 32-bit making a difference
11:25:59 <monochrom> also, was it 512MB memory previously?
11:26:13 <wandernauta> monochrom, Or maybe location? It's now in London, I don't know where it was previously
11:26:28 <wandernauta> monochrom, Doubling the memory tends to do the trick too, heh :)
11:28:11 <chrisdotcode_> but that hoogle query was ridiculously fast, so maybe she also changed location, too.
11:28:21 <chrisdotcode_> s/./?/
11:30:20 <merijn> Coincidence?
11:32:40 <augur_> is there an idiomatic way of doing else if?
11:33:35 <merijn> augur_: You probably want MultiWayIf
11:33:38 <merijn> And or guards
11:33:51 <augur_> merijn: multiwayif?
11:33:57 <merijn> Also depends on how much you care about portability
11:33:58 <johnw> merijn: that's correct
11:34:04 <merijn> johnw: For which platforms?
11:34:10 <johnw> just OS X 10.8.x 64-bit
11:35:53 <edwardk> augur_: by using guards instead
11:36:00 <hpaste> merijn pasted “multiwayif” at http://hpaste.org/90109
11:36:31 <merijn> augur_: That's a fairly recent (7.6?) extension though, if you care about portability you probably want guard of empty case + guards
11:36:33 <edwardk> case () of _ | … ->   ….  \n | … -> …   is a common idiom if you can't bring yourself to use a needless extension or to write a where clause
11:37:06 <augur_> edwardk: ahh ok.
11:37:18 <hpaste> merijn annotated “multiwayif” with “empty case” at http://hpaste.org/90109#a90110
11:37:38 <augur_> merijn: thats pretty nice
11:38:15 <merijn> johnw: Hmm, I don't suppose you'd have the CPU power to build Ubuntu next to that? :p
11:38:34 <johnw> actually, i have a whole other machine here with 12.04.1 LTS on it; would that suffice?
11:39:20 <johnw> actually, it's time to upgrade that to .2 anyway
11:39:35 <merijn> johnw: Probably! I'm trying to convince the Travis-CI people to expand the haskell versions they support (my goal is 7.0, 7.2, 7.4, 7.6, a recent head and latest 2 platforms), having a place to obtain recent snapshots from would make getting a way to use HEAD on travis-ci much more likely
11:40:02 <merijn> They're using Ubuntu 12.04 too, so that's excellent :)
11:40:28 <byorgey> merijn: oooooh, yes please!!!
11:40:43 <augur_> sclv_: http://hpaste.org/90111
11:41:00 <merijn> Actually, convincing them is not the problem, one of the guys already was willing to do it, provide I help him out on how to configure things
11:41:14 <byorgey> merijn: good luck, I filed a bug about the Haskell support a long time ago (it didn't even match what they said it was), but no one ever responded to it
11:41:20 <byorgey> ah, cool
11:41:30 <merijn> Biggest open question is how to deal with parallel platform installs, as the compilers from platform might overlap with the other versions
11:41:58 <merijn> And I'm not sure how to best work around that, I send a mail to the platfrm mailing list, so we'll wait what they say
11:42:24 <byorgey> so is the idea that it will be possible to specify a "matrix" of environments/versions to test under, like you can for ruby etc.?
11:42:28 <merijn> in the mean time my goal is to get 7.0, 7.2, and 7.6 (while they use the 7.4 platform)
11:42:35 <hpaste> edwardk revised “empty case”: “guards!” at http://hpaste.org/90110
11:42:43 <merijn> byorgey: That'd be my goal, yes
11:42:48 <byorgey> very cool
11:42:50 <byorgey> merijn++
11:43:09 <byorgey> that would make me sooooo happy
11:43:19 <merijn> byorgey: I need a new job come september, better start raising my profile now ;)
11:43:36 <edwardk> merijn: they've been talking about adding support for more haskell versions
11:43:38 <augur_> really just anyone: http://hpaste.org/90111
11:43:48 <augur_> if you're into zippers, lemme know what you think! :x
11:43:54 <edwardk> merijn: or at least they were when i was more actively connected to their community
11:44:05 <byorgey> less talk, more doing!
11:44:16 <merijn> edwardk: Yes, I was talking to one of their project guys, but he was unfamiliar with the haskell ecosystem, so they didn't really know what to do
11:44:36 <edwardk> yeah carter was talking to them more at one point, but i lost track of if that was going anywhere
11:44:49 <carter> wait wahat?
11:44:55 <carter> oh yeah
11:45:26 <carter> merijn what sort of new job?
11:45:26 <merijn> I wanna get those versions I just mentioned installed somewhere and get a way to config the relevant PATH adjustments to at least build without platform, once that's in place we can figure out how to deal with platform and HEAD
11:46:07 <carter> merijn if you promise the done io people money, i think they'd be happy to figure out supporting all the platforms
11:46:22 <carter> of the CI as a service places, they were the most eager to please
11:46:33 <merijn> carter: Of the well-paid, freedom to keep building skills and programming kind :p
11:47:24 <carter> merijn finishing grad school or undergrad?
11:47:26 <merijn> Promising money is easy, as long as they don't actually expect me to actually give it ;)
11:47:52 <alanz> augur_: There are ways of using zippers without handcoding the boilerplate stuff
11:48:06 <carter> heh, yeah
11:48:16 <merijn> carter: I finished my masters a year ago, currently working as research assistant at Uni, but since I haven't found a good phd spot yet I'm also looking for options in industry
11:48:17 <augur_> alanz: im sure. i just havent figured them out yet :p
11:48:40 <carter> what  would be your "fantasy"  industrial role?
11:49:17 <carter> edwardk congrats on being on more committees :)
11:49:24 <edwardk> heh
11:49:37 <edwardk> just what i wanted, less time to code! =)
11:49:56 <alanz> augur_: Have a look at http://hackage.haskell.org/package/syz-0.2.0.0, or if you are strong on lenses Control.Lens.Zipper in lens package
11:50:00 <djahandarie> We'll have to put you on a few more committees to get your code output to normal levels.
11:50:12 <carter> did lambda bot remembeber to pass along the @tell's ?
11:50:27 <edwardk> alanz: we're going to factor the zippers from lens into a separate package for the next major release
11:50:31 <merijn> carter: The wish list would be: Working with people smarter than me, enough freedom to allow the occasional experimentation with tools/studying things not directyl applicable to the job (learning new languages, studying whatever math, etc), preferably in non-sucky language :p
11:50:38 <augur_> alanz: its not quite a zipper tho, right
11:50:47 <carter> merijn theres so many of those!
11:50:50 <augur_> alanz: rather than being "at" a subtree, you're either "before" or "after"
11:51:01 <alanz> augur_: both of those are proper zippers.
11:51:02 <carter> what sort of work authorizations do you have / would need to have depending on the location?
11:51:10 <edwardk> djahandarie: that seems to be the net effect of all of this ;)
11:51:17 <alanz> edwardk: will the interface change? Or can I code against it so long?
11:51:54 <augur_> alanz: actually yeah you're right that the context type is the same, so i could pull that out and SYZ it
11:52:14 <edwardk> alanz: the current intent is that the 'zippers' package will expose the current lens zipper API (with some minor tweaks, taking the better names that we were tentative about when it was in lens, because names like 'up' 'down' 'left' and 'right' are rather controversial for lens to take, but okay for a narrower scoped package
11:52:40 <edwardk> we may expose both the lens 3.9 and 3.8 zippers in the package though
11:52:43 <jnerula> Hey, does anyone know if you can use record syntax with Existential Types?
11:52:56 <edwardk> because some folks have expressed a preference for the simpler older API despite the reduced utility
11:53:13 <augur_> edwardk: check out my link! :D
11:53:15 <augur_> >_>
11:53:17 <edwardk> jnerula: you can construct with it, but the accessors don't generally work if the field type is existential
11:53:22 <edwardk> augur_: i did. ;)
11:53:26 <augur_> :(
11:53:28 <jnerula> edwardk: Hmm, thanks.
11:53:32 <augur_> edwardk: it's interesting, no?
11:53:44 <alanz> ok
11:53:49 <edwardk> augur_: i prefer the lens ones. ;)
11:53:59 <augur_> 2*RegExZipper = Non-deterministic Finite Automata
11:53:59 <edwardk> augur_; you can zip down into the bits of an Int, etc. ;)
11:54:07 <augur_> edwardk: yeah yeah thats not the point tho :P
11:54:20 <augur_> the point is that 2*RegExZipper = NFA!
11:54:23 <carter> edwardk did you see this paper that might relate to semi parsing? http://www.cse.chalmers.se/~bernardy/PP.pdf
11:54:30 <edwardk> note, you can also use the biplate, etc. traversals with the lens zippers
11:54:31 <carter> via https://github.com/gasche/icfp2013-papers#readme
11:54:59 <edwardk> augur_: hrmm
11:55:41 <edwardk> carter: someone sent me that before. was it you?
11:55:46 <carter> yes
11:55:51 <carter> just making sure
11:55:57 <napping> hmm, didn't notice the zipper. I tried a bit to find an elegant way to use Plated to write a Tree a -> Tree (a,[a]) that annotates nodes with paths back up to the root
11:56:03 <carter> fault tolerance sometimes means redundant messaging  :)
11:56:25 <augur_> edwardk: zipper values for any given regex, plus a "before"/"after" flag, correspond directly to the states of (one of) the canonical RegEx->NFA construction(s)
11:56:27 <nabilhassein> i have a question about Data.Word8
11:56:34 <nabilhassein> I'm trying to use isNumber from here: http://hackage.haskell.org/packages/archive/word8/latest/doc/html/Data-Word8.html
11:56:50 <nabilhassein> but I can't import isNumber from Data.Word
11:56:55 <nabilhassein> and I can't import Data.Word8 at all
11:57:08 <napping> what's the error?
11:57:12 <edwardk> augur_: makes sense
11:57:25 <nabilhassein> napping: i can't figure out how to get isNumber in scope
11:57:30 <nabilhassein> even though I know it's in the Data.Word8 package
11:57:39 <augur_> edwardk: the transition function for the NFA is just a funny kind of traversal of the regular expression
11:57:42 <napping> what's the error from "import Data.Word8"?
11:57:49 <typoclass> nabilhassein: do you have the package word8 installed correctly? (the module's documentation page lists the package that contains the module. see top of the page)
11:58:10 <edwardk> napping: i think 'each' for Tree actually is indexed by the list of the path taken
11:58:21 <edwardk> napping: (or maybe it was a Seq)
11:58:27 <edwardk> napping: so you can just convert back from that
11:58:42 <nabilhassein> typoclass: ah, i think that's it. i'm going to try that
11:59:18 <edwardk> napping: upon is indexed by the path in terms of biplate/uniplate steps as well
11:59:30 <augur_> edwardk: but more generally, all tree types can be viewed as a generalized regular expression, provided that the transitions are given for each node. it's relatively trivial to define what counts as a valid transition, too, so that it's possible to define, for example, "all" possible RegEx languages with binary operators, etc. in one fell swoop
11:59:32 <napping> each appears to be indexed by [Int[
12:00:31 <nabilhassein> typoclass: i did `cabal install word8` and it installed the package (can't believe i forgot!), but i'm still getting the same error
12:00:47 <nabilhassein> the import statement is:
12:00:48 <nabilhassein> import           Data.Word8 (isNumber)
12:00:54 <typoclass> nabilhassein: you may need to restart ghci
12:01:52 <edwardk> napping: those describe the path in terms of which child was taken to get there
12:01:55 <edwardk> :t Node
12:01:57 <lambdabot> a -> Forest a -> Tree a
12:02:00 <nabilhassein> typoclass: yes, exactly. thanks very much!
12:02:00 <augur_> edwardk: but even MORE generally, if we generalize the action of the machine, so that instead of reading a char, its just some generic function a -> Maybe a, then it turns out we can do some other interesting things. for instance, an in-order traversal of a tree, with some state variable a, provided we use the right transition gadget
12:02:01 <edwardk> :t (^.)
12:02:02 <lambdabot>     Not in scope: `^.'
12:02:02 <lambdabot>     Perhaps you meant one of these:
12:02:02 <lambdabot>       `.' (imported from Data.Function),
12:02:13 <typoclass> nabilhassein: you're welcome
12:03:09 <edwardk> augur_: not terribly surprising
12:03:18 <augur_> edwardk: :P
12:03:52 <augur_> its not hugely surprising, but it's still cool to think that there's a nice little connection from zippers directly to NFAs, and then some kind of generalization
12:04:34 <magneticduck> just ran into a silly bug because the sequence [0, 0 .. 0
12:04:39 <magneticduck> ] is infinite
12:04:44 <magneticduck> > [0, 0 .. 0
12:04:45 <lambdabot>   <hint>:1:11:
12:04:45 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
12:04:52 <magneticduck> > [0, 0 .. 0]
12:04:53 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
12:05:11 <magneticduck> that don't seem right
12:05:12 <Bor0> repeat 1
12:05:14 <Bor0> > repeat 1
12:05:16 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:05:18 <magneticduck> > [1, 1 .. 1]
12:05:19 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:05:23 <magneticduck> hm
12:05:29 <magneticduck> alright, that works as expected then
12:05:39 <magneticduck> yes Bor0?
12:05:42 <Bor0> why doesn't it seem right?
12:05:46 <magneticduck> well
12:06:02 <magneticduck> you'd think a sequence would keep incrementing by the delta until it hits the top limit
12:06:09 <magneticduck> at least, that's what I thought when I wrote the method
12:06:12 <edwardk> augur_: sure.
12:06:22 <byorgey> it keeps incrementing by the delta until it *goes over* the top limit.
12:06:26 <magneticduck> oh
12:06:43 <magneticduck> that would explain my problem ofc, but I still think they shouldn't make it like that
12:06:46 <RichyB> > [1,2..10] -- includes the upper limit
12:06:46 <byorgey> the semantics is a bit fuzzy though.
12:06:47 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:06:58 <Bor0> > [1,2..-1]
12:06:59 <lambdabot>   Not in scope: `..-'
12:07:04 <Bor0> > [1,2..0]
12:07:04 <byorgey> magneticduck: yeah, Enum is somewhat broken.
12:07:05 <lambdabot>   []
12:07:09 <magneticduck> > [1, 2 .. (-1)]
12:07:10 <lambdabot>   []
12:07:12 <magneticduck> yeah
12:07:14 <magneticduck> I see now
12:07:16 <sclv_> augur_: it looks interesting but i don't know what it does :-)
12:07:21 <sclv_> i assume evaluate a regex
12:07:26 <augur_> sclv_: yeah
12:07:32 <magneticduck> byorgey: heh
12:07:33 <augur_> by walking the regex itself
12:07:58 <augur_> sclv_: but most importantly, it does this by using the regex's zipper as states in a state machine
12:08:17 <sclv_> aha so it captures explicit backtracking as literally walking up and over the tree
12:09:23 <augur_> sclv_: yes and no. it turns out that there is a canonical construction that maps regex's to NFAs
12:09:39 <sclv_> yes
12:09:47 <augur_> and in that construction, the nodes of the resultant NFA correspond 2-to-1 with the subexpressions of the regex
12:10:03 <sclv_> so you produce your list of transitions intead
12:10:51 <augur_> sort of. basically, instead of inventing some new indices or whatever to use as state identifiers, why not use the nodes of the regex themselves?
12:11:39 <augur_> if they correspond 2-to-1, then 2*RegExZipper corresponds one to one, so you just inspect the bi-zipper and you know exactly what state you're in
12:22:33 <arnsholt> I keep having to remind me that Haskell's pattern matching isn't Prolog's unification ^_^
12:23:06 <sclv_> augur_: ok, i think i get it. cute!
12:23:28 <DanielDiaz> I keep having to remind me that Prolog's unification isn't Haskell's patter matching
12:23:30 <sclv_> that correspondence indeed makes things work out nicely
12:24:35 <augur_> sclv_: yeah. and by being parametric over the action type, you can actually do lots more than just parse
12:25:19 <augur_> sclv_: as i said to edwardk, you can use it as a traverser with some state, for example
12:25:53 <augur_> you can also beef-up the action type and do things like store capture groups
12:27:05 <augur_> i think there's probably a nice way to make it especially generic, so that all you have to do is define some instances of some classes, and then parse with the right type, and itll be an NFA-with-extra-stuff
12:29:09 <augur_> sclv_: but because you can beef up the action type with captures, you could also in principle add non-regular things like back refs, with almost no effort at all
12:30:00 <sclv_> so should we expect a regex-zipper package on hackage anytime soon? :-P
12:30:13 <augur_> sclv_: depends on whether i can make it nice or not ;p
12:30:49 <sclv_> i do think there's a connection to the brzozowski derivative btw
12:30:59 <augur_> sclv_: ideally i want to make it just a sort of bare-bones thing where you give me a zipper-ish type, and the right transition functions, and everything else goes for free
12:31:03 <sclv_> have you see matt might's stuff on parser combinators?
12:31:22 <augur_> sclv_: no, but the inspiration was from a parser combinator i wrote on reddit
12:31:34 <sclv_> related work (but your construction seems more straightforward): http://matt.might.net/articles/parsing-with-derivatives/
12:31:59 <augur_> i think the connection to parser combinators is that the combinator is what you get when you factor out the zipper by pre-computing its effects
12:32:54 <orzo> I'd like to run a select on Chan objects so that I can react to any one of them in the same thread.  Otherwise, its hard to see how shut down my threads cleanly
12:33:21 <merijn> orzo: Not really possible, you can do it using TChan's, though
12:34:04 <orzo> well i should switch to TChans then
12:34:05 <merijn> orzo: Since reading a TChan is a transactional operation you can use the Alternative instance of STM to "select"
12:34:42 <merijn> "readTChan chan1 <|> readTChan chan2" will return the result of the first completing readTChan
12:35:22 <merijn> You can write a poll function using "foldl1 (<|>) . map readTChan" or something similar
12:36:45 <xico> hi
12:36:48 <orzo> thanks, merijn
12:38:11 <xplat> brzozowski derivatives produce DFAs rather than NFAs
12:39:55 <orzo> hm, i just realized i might be able to use throwto to cleanly shutdown my threads without TChan
12:40:24 <xico> i have a "f : a -> a -> a -> b", and would like to apply three arguments "x,y,z :: [Either b (c,a)]" to it. i am thinking of handling Left possibilities by returning a Maybe for the whole computation. my question is: how to make it nice? (i mean without cases)
12:40:31 <augur_> xplat: did you see the general sketch i gave of the relationship to NFAs?
12:40:58 <xico> (oups the two b's are not the same)
12:41:00 <augur_> xplat: the crucial point is that the relationship is basically one of identity, which should be kind of obvious but..
12:41:30 <xico> (and x,y,z are not lists...)
12:41:37 <orzo> merijn: waiting on a TChan isnt something ugly like a busy wait loop is it?
12:42:05 <xico> (i guess this server need a #haskell-wanabees)
12:42:35 <Cale> xico: Write a function  Either b (c,a) -> Maybe a
12:42:41 <Cale> xico: and then use the Maybe monad.
12:42:44 <merijn> orzo: No
12:43:02 <xico> Cale: thanks!
12:43:21 <merijn> orzo: STM operations support "retry", when a transaction runs and retries it won't get run again until at least one of the transactional variables it uses has changed
12:43:32 <merijn> i.e. a value has been written to a Chan, for example
12:43:43 <merijn> *TChan
12:44:15 <Cale> xico: You can just write  do u <- getA x; v <- getA y; w <- getA z; return ...  where getA :: Either b (c,a) -> Maybe a
12:44:28 <Cale> (you'll probably want to give it a better name)
12:44:29 <augur_> sclv_: i think that  ultimately it'll be useful to be able to specify the action on the whole parse state, as done with the transition function more or less
12:44:48 <johnw> merijn: if you have any machines you can give me an SSH account login to, I can set you up as a build slave
12:45:06 <johnw> i now have a "multi-config" Jenkins build running on OS X and Ubuntu nightly
12:45:06 <xico> Cale: i called it f :p
12:45:09 <augur_> sclv_: because then you can do things like add a connective & so that (a&b) matches only if both a and b match, etc.
12:45:18 <xico> Cale: but thanks a lot, nice idea :)
12:46:18 <merijn> johnw: I only have a small cheapo VPS box in the US, else I would've had to ask around and beg for people with build machines ;)
12:46:56 <johnw> well, we now have a pretty easy way to add new platforms, just saying
12:59:14 <quchen> johnw: I just tuned in, did you mean we can target new platforms with GHC easily now?
12:59:28 <johnw> no
12:59:28 <quchen> johnw: Half a year ago I was puzzled how to compile it for my Raspi
12:59:36 <quchen> Argh, dammit :-(
12:59:39 <johnw> i meant that anyone who can give me an SSH account can contribute nightly builds
13:00:01 <merijn> Is it possible to make instances of a class whose functions are not exported?
13:00:55 <quchen> merijn: I don't think so. I remember trying to import Control.Applicative (Applicative), which gave me errors. Had to use (Applicative(..))
13:01:54 <merijn> bah
13:02:58 <merijn> The easiest way to let someone implement the typeclass I want is to expose the way it functions internally, but I don't want to allow people acutally *using* that knowledge
13:12:34 <earthy> damned if you do, damned if you don't
13:18:50 <merijn> I want the typeclass function return "newtype Thingy a = Thingy (Foo -> Bar -> a)", without exposing that Thingy is a newtype. But of course, without a way to construct a Thingy, people can't implement said typeclass...
13:19:18 <Botje> makeThingy = Thingy ?
13:20:03 <joelteon> @src sequence
13:20:03 <lambdabot> sequence []     = return []
13:20:04 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:20:04 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
13:20:46 <merijn> oh, actually, I guess that'd work
13:25:31 <Vendethiel> I think I'm missing something here. `map (putStrLn . show) [1..5]` would return me some waht? (I know there's sequence and mapM)
13:25:54 <merijn> :t map (putStrLn . show) [1..5]
13:25:55 <lambdabot> [IO ()]
13:26:09 <merijn> Incidentally "print = putStrLn . show"
13:26:14 <merijn> :t map print [1..5]
13:26:15 <lambdabot> [IO ()]
13:29:24 <typoclass> Vendethiel: so as the signature shows, it gives a list with a bunch of IO () actions. in themselves not very useful, but you could e.g. use sequence, as you mentioned
13:29:26 <typoclass> @type sequence
13:29:27 <lambdabot> Monad m => [m a] -> m [a]
13:29:48 <typoclass> (here: [IO ()] -> IO [()])
13:32:38 <merijn> Vendethiel: Compare "mapM_ print [1..5]" with "map print [1..5] !! 3"
13:32:47 <merijn> :t mapM_ print [1..5]
13:32:47 <lambdabot> IO ()
13:32:54 <merijn> :t map print [1..5] !! 3
13:32:55 <lambdabot> IO ()
13:33:13 <orzo> do recommend defaulting to STM over MChar/Chan when in doubt?
13:33:28 <merijn> orzo: It depends
13:33:36 <orzo> im making a jabber server
13:33:51 <merijn> orzo: If you only do small/infrequent transactions, STM has very little overhead
13:34:08 <ksf> does anyone have experience with streaming component combinators?
13:34:16 <ksf> http://hackage.haskell.org/package/scc/
13:34:18 <merijn> The more contention (simultaenous use) and longer the transaction, the more overhead (but OTOH getting those right without STM would be more difficult too)
13:35:12 <orzo> well, suppose i'm not worried about performance (yet)
13:36:41 <`^_^v> do you play tf2 orzo
13:36:41 <orzo> no i dont think so, as i dont know what it is
13:36:41 <`^_^v> oh
13:36:41 <merijn> Team Fortress 2, first person shooter by Valve
13:36:51 <orzo> i see, well no then
13:39:19 * hackagebot websockets 0.7.4.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.7.4.0 (JasperVanDerJeugt)
13:39:19 <Jaxan> Question about monad transformers. Mathematically monads (M and N) dont compose because there is no reason for MNMN->MN to exist. Does a monad transformer provide the map MNM -> MMN to make this possible?
13:39:19 <orzo> i guess the choice between STM and MVars should be decided by how easy it is to adapt your code once you decide you chose wrong
13:39:19 <orzo> heh
13:39:19 <ksf> Jaxan, there's a paper full of abstract nonsense somewhere that shows that monad transformer stacks are monads.
13:39:59 --- topic: '["Haskell Platform 2013.2: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down, try: http://hdiff.luite.com "]'
13:39:59 --- topic: set by shachaf!~shachaf@unaffiliated/shachaf on [Tue May 28 01:16:22 2013]
13:39:59 --- names: list (clog cablehead williamhc bos preflex ksf mauke taterbase Jeanne-Kamikaze mike4_ flowsnake_ lelf` Icewing gabor [swift] hiato Fubar^ pgiarrusso qzr edwardk pantsman asQuirreL stevej plucas jpol k00mi Apocalisp pootler_ sellout- mizu_no_oto xico eldariof dubsg sepp2k1 OlegYch0 startling litherum kartlos hughfdjackson nexx j-wang breck7 aoshi alszar DanielDiaz brainwash jchild ulfdoz simukis_ flebron Mon_Ouie CaptainK emmanuelux neutrino lhk ormaaj Itkovian)
13:39:59 --- names: list (dawe Okasu tanakh sbowman fsvehla kylcarte MercurialAlchemi bashyal dju mawuli carter martint sunfun natechan Maerten junsuijin macron jbauman dwcook hsn dschoepe tg betawaffle dyreshark brainproxy guymann noam_ Guest4015 maoe Kuraitou ssbr tudalex prototrout Astro- stelleg dropdrive weebl bgamari epta valdyn FUZxxl robbert Gibheer mephx `bps frontendloader gentleben sleepynate chrisdotcode_ path[l] troydm apples` hallski marr yogurt_truck jasonkuhrt jibi)
13:39:59 --- names: list (io2 Taneb killy9999 nilsi erkin jlamothe skchrko josephle dmac osa1 merijn jacobw refried_ mrsolo sbahra_ Eduard_Munteanu c_wraith quchen mangoman silasm resnik_ jvaneenwyk bananagram nob jve dolio Palmik tomboy64 ericmath1son execut3 hwiersma trism c_14 ozgura bergey conehead frerich_ guampa konundra phyrex1an bamboo aess rzh FreeFull d_arcy Dennis mjs2600 ljhms Starfire tommd ParadoxMuffin2 nabilhassein tiffany jknick Mortomes tac solancile KoF)
13:39:59 --- names: list (whaletechno gautamc thetallguy xunatai alanz perlite S11001001 cads Reite netrino comak agumonkey QinGW``` BeardedCoder fxr DexterLB nbouscal dgvncsz0f cmsmcq araujo row csakatoku sclv_ scriptor nilg shreesh agjacome enthropy EvilPenguin chatsiri_ safinaskar fetter_oml bowmanb cvandyck armlesshobo gpampara_off MrFenix kryptiskt shergill Paprikachu brianloveswords amathew paddymahoney pairing86 phienone ketil thunderrd scrollback Sculptor cfricke kobain)
13:39:59 --- names: list (bytbox jmcarthur_mobile danil MindlessDrone Nik_89 RageOfThou phillip mjo pmade yacks saml tuxit morazow_ uniquenick mgile agp augustss_ Desheng machisuji wchun whoops tridactyla niklasb seneca frelux jnerula PaulVisschers jobstijl bben lebastr ryant5000 silver pikhq vijaykiran Noldorin lunarjar RichyB Brando753 Natch elliott ts33kr boothead_ DolphR nominolo Alice3 `0660 timbod ousado kuribas ndngvr Kabaka isomorphic DrCode lpvb kazimir42 joneshf-work)
13:39:59 --- names: list (_justjust alang smarter SethHaskell thalassarche hamishmack Y_Less axis_ Raynos typoclass Heero tippenein jesyspa Rarrikins Darkproger kludge` m3ga BigTom weie hinst donri [[zzz]] jonkri Der_Dackel ramses_ scalable jorick crdueck gthorslund ChongLi djcoin milessabin chuzz supersym apples nooodl burp uu1101 EvilTownCat q66 Ralith saurik shintah Botje potatogim adnap sShintah kushal Endeg juhp shanse otto_s_ bogner mattrepl tavelram__ cow-orker dmarker SoupE)
13:39:59 --- names: list (fijimunkii hiratara vili anonlsdljsdflsdn apaku Sgeo tunixman rgrinberg Blkt mrpantoufle akiress wto gfarfl hattusili_III jlaire julmac predator117 mlh ELLIOTTCABLE Swizec Guest15932 anders^^ coeus_ tgeeky ijp idnar dario tomh---- Saizan prophile pyykkis xorox90 mux_NYC hungryblank Ghoul_ arnihr noddy mkrull jodaro_ lopex charlesofarrell PrO_OkI______ akraut etrepum timemage ecube UziMonkey___ rickeyski-k simon fikusz LAMMJohnson hsc ccasin yano mapreduce)
13:39:59 --- names: list (schoppenhauer ggherdov haasn IbnFirnas blackdog wilfredh bobry mtlatif__ liori machisuji_ swistak35 puzza007 lenstr Hardolaf strax Gothmog_ cYmen mandu tero- jaspervdj kaol akahn int-e Razz|at_work Will| cognominal nitrodex orzo iteratee EarlGray^^ Axord fizbin jaimef gbarboza augur_ DigitalKiwi kryft setmeaway ttuegel ment Tarential tensorpudding fling Luke abumirqaan aib Baughn __main__ a- kloeri torkjak cross bd_ hiroyuki3 aninhumer Cryovat k0ral_)
13:39:59 --- names: list (asante leifw Kuba hpaste lattenwald aford lambdabot mmaruseacph2 ipuustin frerich Nahra lulf arkx tdammers Mayzie wunki intoverflow jonke Sebastien-L mixi Darkflux bqp tessier lusory [mth] isenmann newsham MoALTz Draconx sclv morolin Sizur Hafydd latro`a bbloom ceti331 dcoutts Khisanth gwern shepheb doomlord__ dreixel_ hiredman skuggi edwtjo DT` __class__ joar Philippa birkenfeld Cerise heath Ycros slobo dysinger Nickeeh Jaxan pfoetchen fireglow vehk)
13:39:59 --- names: list (walter johanbev ninegrid tinyghost sunnavy jmcarthur foobarbaz walter_ parcs Tehnix Tamae kaw h_chiro jml daniel-s endojelly Eliel iamtakingiteasy Vendethiel shelf andares netj caligula__ teiresias A1kmm albel727 SirChurchill osfameron pr agundry ktosiek Dtgr schlumpi_ bcoppens peltchu_ rainmaker killy_bo1 vhz_ Xorlev popx_ mavam mnbernstein geoffh so joelteon ivan\ confound fall_ scottj qz tomejaguar mietek Phlogistique bakingbread mceier Megant cdidd hpd)
13:39:59 --- names: list (threedaymonk Cale xymox Draggor neurocyte n00dle ve zoktar obcode Dodek electrogeek sjl Valodim tsinnema s00pcan mgsloan RylaiC kniu trevize dsantiago dogmaT satshaba1 mlinksva ps-auxw Tesseraction kaictl monochrom AntiSpamMeta ClaudiusMaximus zxq9 plhk b52 Zouppen BrianHV Zekka farn liszt waterlaz ajhager ortmage jang obiwanko mikecaruso geekosaur Bigcheese sipa arkeet canvon suiside bezik cmears Maxdamantus sohum Kinnison tkr_ tobiassjosten WzC acfoltzer)
13:39:59 --- names: list (KaneTW milli bartavelle kini vobi nh23 stomp fxrh bgeek Walther pettter copton hyko ryanakca gaqwas byorgey dmwit ernst iulian ciaranm Gilly Morgawr solirc DrSyzygy kav shachaf sdx23 satshabad Igloo KitB Axman6 quaestor1 gbluma `^_^v Boney vmeson stass rfw hpc enigmuriatic1 SHODAN kakos necroyeti drbean nathanic srh Athas janinge thorsten1 ericmj Excureo niko unlink ninwa crs_ xplat alexander__b shutdown_-h_now copumpkin luminous ft epsylon Zzompp)
13:39:59 --- names: list (yiannis_t trystero seantallen lispy sordina1 domingo theorbtwo LeaChim PHO_ Belgarion0 wagle ninzine Eelis nxorg8_ ByronJohnson JoshuaA_ aforemny s_quark Eridius brett bens ab9rf jroesch Velpoman cschneid mokus flux args[0] eyck tmiw andrewsw lokydor purefn levi yan_ JPohlmann koninkje1away Yawgmoth xnyhps tomprince volitek KitB_ mortberg MK_FG b_jonas tahu inr TML doshitan quuxman drmegahertz colah csg__ Flint barrucadu ski joshc joogi arun fryguybob)
13:39:59 --- names: list (mirsal Ornedan liyang destiny vvein stvc frankbro _janne opqdonut Guest36882 jrib ccxCZ Th0mas nwf Reisen othiym23 Elision knz DustyDingo tvaalen ggreg taruti companion_cube rmunroe absence Kneiva HalfWayMan taylorgb Urchin Lemmih noctux profmakx mimico__ demolithion Blazeix greeny Proteumus Sagi zebr Laney Watcher7 vivekrai sykora fionnan prh yeltzooo amiller_ Fuuzetsu qwandor|quassel kosmikus oax_ Mowah_ mike2 tamiko mrd hanDerPeder luite_ gemelen Eiam)
13:39:59 --- names: list (Tene notdan tixxit Internet13 genisage myme1 supki CODEtaku johnw inarru_ sirspazzolot alang__ ghorn \rs anachron mjrosenb ejls thorsten` JoeHazzers Xaseron td123 hiyakashi Debaser zvrba Boreeas sajith mantovan1 Jonte rhodesd zaphar_p1 Jaak finnrobi elgot_ jayne M-ou-se deavidsedice jzelinskie sg mike_pizza maxorator @ChanServ Riussi em frio dixie Sunhay Adios zerokarmaleft quicksilver averell maksbotan pnielsen thirsteh raid mimi_vx mikee petantik)
13:39:59 --- names: list (fergusnoble peddie zaiste mikeplus64 noplamodo chrra mrshoe ahihi sevvie deggis krig_ s4msung_ alios_ magicman Guest34243 ofan rs0 eL_Bart0 pellsson jrslepak xrq arcatan dabradley CosmicRay jix BlastHardcheese brixen mononofu gdsx ion Innominate davorak Martty thoughtpolice Chousuke SuperNoeMan zenzike mgregson Twey cods lpsmith canar wollw Licenser cajla bonsu theDon mr- Bwild hive-mind mollerstrand kshannon_ hc tomaw bstrie solarus fry pyrtsa jliikka)
13:39:59 --- names: list (davd hvr Tinned_Tuna wtw cmsd2 def- helgikrs1 mgaare mattp__ ehd nlogax sbahra hodapp Heffalump mami oldmanstan ivan` Nik05 Deewiant Khady nikola dlundy vermeille adlan FireFly The_third_man pcapriotti MetaCosm gdeest blz37 ahf mornfall b2coutts chirpsalot Liskni_si Rutger`_ dilinger WhereIsMySpoon sm SegFaultAX majoh canta ibid thetallguy2 Minos cjay oyvindio mechairo` matzo aristid knyppeldynan divarvel AStorm duairc ChewieBeardy alcz jyyou statusfailed)
13:39:59 --- names: list (rofer mendez adimit lightquake _flow_ nicoo Ulrar jamwt gseitz dmp1ce hackagebot tswett Dashkal earthy flori verrens Spockz Soft davean joachifm_ drewr scgilardi TheSpect1e cynick aleator_ klugez ziman blakesmith pqmodn tromp_ vvv_ EvanR dpwright pdxleif_away alpounet trybeca stew linduxed lahwran greymalkin zeiris_ Plex_ Dybber McManiaC Enigmagic arbn jlewis bxc_ sully kqr saiam SaBer DarkFox ixian joeyh dumbhat froztbyte Gracenotes Derander CindyLinz jcp)
13:39:59 --- names: list (thorkilnaur_ marienz pi8028 ehamberg ethercrow idoru Adeon yam otterdam gds ido bbee2 MasseR Raynes danr XMunkki_ |-{0}-| Nimatek warpy strmpnk gridaphobe wting numberten pharaun SquidTamer Rembane natte jlouis zomg tew88- horlicks integral Ptival Ke aszlig koala_man Clint bholst_ wereHamster voyd_ def-lkb_ ique djahandarie petanqk Amadiro dqd Zariel guerrilla banjiewen)
13:40:00 <fizbin> Correct me if I'm wrong, but there's no reason to ever use ( seq x x ) , correct?
13:40:00 <Jaxan> ksf: that doesn't answer my question ;?
13:40:00 <supki> fizbin: yes, that's id
13:40:05 <Vendethiel> merijn: I admit I don't see the difference
13:40:33 <Jaxan> ;)
13:40:33 <supki> fizbin: well, \x -> seg x x is id
13:40:33 <ksf> Jaxan, nope. it doesn't permute the stack.
14:11:38 --- topic: '["Haskell Platform 2013.2: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down, try: http://hdiff.luite.com "]'
14:11:38 --- topic: set by shachaf!~shachaf@unaffiliated/shachaf on [Tue May 28 01:16:22 2013]
14:11:38 --- names: list (clog hughfdjackson Hrumph conal flowsnake_ Philonous taterbase bashyal pmade anRch ksf_ Siod c-rog ketil qzr JoeyA tharper ericmj refried_ piotr_ hiroaki Jambato araujo wole kstuart fragamus lelf` akiress threesome rachit7 tsaraestr amyers quux bowmanb benprew williamhc cablehead bos preflex mauke Jeanne-Kamikaze mike4_ Icewing [swift] hiato Fubar^ pgiarrusso edwardk pantsman asQuirreL stevej plucas jpol k00mi Apocalisp pootler_ sellout- mizu_no_oto xico)
14:11:38 --- names: list (eldariof dubsg sepp2k1 OlegYch0 startling litherum kartlos nexx j-wang breck7 aoshi alszar DanielDiaz brainwash ulfdoz flebron Mon_Ouie CaptainK emmanuelux neutrino lhk ormaaj Itkovian dawe tanakh sbowman fsvehla kylcarte MercurialAlchemi dju mawuli carter martint sunfun natechan Maerten junsuijin macron jbauman dwcook hsn dschoepe tg betawaffle dyreshark brainproxy guymann noam_ Guest4015 maoe Kuraitou ssbr tudalex prototrout Astro- stelleg dropdrive weebl)
14:11:38 --- names: list (bgamari epta valdyn FUZxxl robbert Gibheer mephx `bps frontendloader sleepynate chrisdotcode_ path[l] troydm apples` hallski marr yogurt_truck jasonkuhrt jibi io2 Taneb nilsi erkin jlamothe skchrko josephle dmac osa1 merijn jacobw mrsolo sbahra_ Eduard_Munteanu c_wraith quchen mangoman silasm resnik_ jvaneenwyk bananagram nob jve dolio tomboy64 ericmath1son hwiersma trism c_14 ozgura bergey conehead frerich_ guampa bamboo aess FreeFull d_arcy Dennis ljhms)
14:11:38 --- names: list (Starfire tommd ParadoxMuffin2 nabilhassein tiffany jknick Mortomes tac solancile KoF whaletechno gautamc thetallguy xunatai alanz perlite S11001001 cads Reite netrino comak agumonkey QinGW``` BeardedCoder fxr DexterLB nbouscal dgvncsz0f cmsmcq row csakatoku sclv_ scriptor nilg agjacome enthropy EvilPenguin chatsiri_ safinaskar fetter_oml cvandyck armlesshobo gpampara_off MrFenix kryptiskt shergill Paprikachu brianloveswords amathew paddymahoney pairing86)
14:11:38 --- names: list (phienone thunderrd scrollback Sculptor cfricke kobain bytbox jmcarthur_mobile danil Nik_89 RageOfThou phillip mjo yacks saml tuxit morazow_ uniquenick mgile agp augustss_ Desheng machisuji wchun whoops tridactyla niklasb seneca frelux jnerula PaulVisschers jobstijl bben lebastr ryant5000 silver pikhq vijaykiran Noldorin lunarjar RichyB Brando753 Natch elliott ts33kr boothead_ DolphR nominolo `0660 timbod ousado kuribas ndngvr Kabaka isomorphic DrCode lpvb)
14:11:38 --- names: list (kazimir42 joneshf-work _justjust alang smarter SethHaskell thalassarche hamishmack Y_Less axis_ Raynos typoclass Heero tippenein jesyspa Rarrikins Darkproger kludge` m3ga BigTom weie hinst donri [[zzz]] jonkri Der_Dackel ramses_ scalable jorick crdueck gthorslund ChongLi milessabin chuzz supersym apples nooodl burp uu1101 EvilTownCat q66 Ralith saurik shintah Botje potatogim adnap sShintah kushal Endeg juhp shanse otto_s_ bogner mattrepl tavelram__ cow-orker)
14:11:38 --- names: list (dmarker SoupE fijimunkii hiratara vili anonlsdljsdflsdn apaku Sgeo tunixman rgrinberg Blkt mrpantoufle wto gfarfl hattusili_III jlaire julmac predator117 mlh ELLIOTTCABLE Swizec Guest15932 anders^^ coeus_ tgeeky ijp idnar dario tomh---- Saizan prophile pyykkis xorox90 mux_NYC hungryblank Ghoul_ arnihr noddy mkrull jodaro_ lopex charlesofarrell PrO_OkI______ akraut etrepum timemage ecube UziMonkey___ rickeyski-k simon fikusz LAMMJohnson hsc ccasin yano)
14:11:38 --- names: list (mapreduce schoppenhauer ggherdov haasn IbnFirnas blackdog wilfredh bobry mtlatif__ liori machisuji_ swistak35 puzza007 lenstr Hardolaf strax Gothmog_ cYmen mandu tero- jaspervdj kaol akahn int-e Razz|at_work Will| cognominal nitrodex orzo iteratee EarlGray^^ Axord jaimef gbarboza augur_ DigitalKiwi kryft setmeaway ttuegel ment Tarential tensorpudding fling Luke abumirqaan aib Baughn __main__ a- kloeri torkjak cross bd_ hiroyuki3 aninhumer Cryovat k0ral_)
14:11:38 --- names: list (asante leifw Kuba hpaste lattenwald aford lambdabot mmaruseacph2 ipuustin frerich Nahra lulf arkx tdammers Mayzie wunki intoverflow jonke Sebastien-L mixi Darkflux bqp tessier lusory [mth] isenmann newsham MoALTz Draconx sclv morolin Sizur Hafydd latro`a bbloom ceti331 dcoutts Khisanth gwern shepheb doomlord__ dreixel_ hiredman skuggi edwtjo DT` __class__ joar Philippa birkenfeld Cerise heath Ycros slobo dysinger Nickeeh Jaxan pfoetchen fireglow vehk walter)
14:11:38 --- names: list (johanbev ninegrid tinyghost sunnavy jmcarthur foobarbaz walter_ parcs Tehnix Tamae kaw h_chiro jml daniel-s endojelly Eliel iamtakingiteasy Vendethiel shelf andares netj caligula__ teiresias A1kmm albel727 SirChurchill osfameron pr agundry ktosiek Dtgr schlumpi_ bcoppens peltchu_ rainmaker killy_bo1 vhz_ Xorlev popx_ mavam mnbernstein geoffh so joelteon ivan\ confound fall_ scottj qz tomejaguar mietek Phlogistique bakingbread mceier Megant cdidd hpd)
14:11:38 --- names: list (threedaymonk Cale xymox Draggor neurocyte n00dle ve zoktar obcode Dodek electrogeek sjl Valodim tsinnema s00pcan mgsloan RylaiC kniu trevize dsantiago dogmaT satshaba1 mlinksva ps-auxw Tesseraction kaictl monochrom AntiSpamMeta ClaudiusMaximus zxq9 plhk b52 Zouppen BrianHV Zekka farn liszt waterlaz ortmage jang obiwanko mikecaruso geekosaur Bigcheese sipa arkeet canvon suiside bezik cmears Maxdamantus sohum Kinnison tkr_ tobiassjosten WzC acfoltzer KaneTW)
14:11:38 --- names: list (milli bartavelle kini vobi nh23 stomp fxrh bgeek Walther pettter copton hyko ryanakca gaqwas byorgey dmwit ernst iulian ciaranm Gilly Morgawr solirc DrSyzygy kav shachaf sdx23 satshabad Igloo KitB Axman6 quaestor1 gbluma `^_^v Boney vmeson stass rfw hpc enigmuriatic1 SHODAN kakos necroyeti drbean nathanic srh Athas janinge thorsten1 Excureo niko unlink ninwa crs_ xplat alexander__b shutdown_-h_now copumpkin luminous ft epsylon Zzompp yiannis_t trystero)
14:11:38 --- names: list (seantallen lispy sordina1 domingo theorbtwo LeaChim PHO_ Belgarion0 wagle ninzine Eelis nxorg8_ ByronJohnson JoshuaA_ aforemny s_quark Eridius brett bens ab9rf jroesch Velpoman cschneid mokus flux args[0] eyck tmiw andrewsw lokydor purefn levi yan_ JPohlmann koninkje1away Yawgmoth xnyhps tomprince volitek KitB_ mortberg MK_FG b_jonas tahu inr TML doshitan quuxman drmegahertz colah csg__ Flint barrucadu ski joshc joogi arun fryguybob mirsal Ornedan liyang)
14:11:38 --- names: list (destiny vvein stvc frankbro _janne opqdonut Guest36882 jrib ccxCZ Th0mas nwf Reisen othiym23 Elision knz DustyDingo tvaalen ggreg taruti companion_cube rmunroe absence Kneiva HalfWayMan taylorgb Urchin Lemmih noctux profmakx mimico__ demolithion Blazeix greeny Proteumus Sagi zebr Laney Watcher7 vivekrai sykora fionnan prh yeltzooo amiller_ Fuuzetsu qwandor|quassel kosmikus oax_ Mowah_ mike2 tamiko mrd hanDerPeder luite_ gemelen Eiam Tene notdan tixxit)
14:11:38 --- names: list (Internet13 genisage myme1 supki CODEtaku johnw inarru_ sirspazzolot alang__ ghorn \rs anachron mjrosenb ejls thorsten` JoeHazzers Xaseron td123 hiyakashi Debaser zvrba Boreeas sajith mantovan1 Jonte rhodesd zaphar_p1 Jaak finnrobi elgot_ jayne M-ou-se deavidsedice jzelinskie sg mike_pizza maxorator @ChanServ Riussi em frio dixie Sunhay Adios zerokarmaleft quicksilver averell maksbotan pnielsen thirsteh raid mimi_vx mikee petantik fergusnoble peddie zaiste)
14:11:38 --- names: list (mikeplus64 noplamodo chrra mrshoe ahihi sevvie deggis krig_ s4msung_ alios_ magicman Guest34243 ofan rs0 eL_Bart0 pellsson jrslepak xrq arcatan dabradley CosmicRay jix BlastHardcheese brixen mononofu gdsx ion Innominate davorak Martty thoughtpolice Chousuke SuperNoeMan zenzike mgregson Twey cods lpsmith canar wollw Licenser cajla bonsu theDon mr- Bwild hive-mind mollerstrand kshannon_ hc tomaw bstrie solarus fry pyrtsa jliikka davd hvr Tinned_Tuna wtw cmsd2)
14:11:38 --- names: list (def- helgikrs1 mgaare mattp__ ehd nlogax sbahra hodapp Heffalump mami oldmanstan ivan` Nik05 Deewiant Khady nikola dlundy vermeille adlan FireFly The_third_man pcapriotti MetaCosm gdeest blz37 ahf mornfall b2coutts chirpsalot Liskni_si Rutger`_ dilinger WhereIsMySpoon sm SegFaultAX majoh canta ibid thetallguy2 Minos cjay oyvindio mechairo` matzo aristid knyppeldynan divarvel AStorm duairc ChewieBeardy alcz jyyou statusfailed rofer mendez adimit lightquake)
14:11:38 --- names: list (_flow_ nicoo Ulrar jamwt gseitz dmp1ce hackagebot tswett Dashkal earthy flori verrens Spockz Soft davean joachifm_ drewr scgilardi TheSpect1e cynick aleator_ klugez ziman blakesmith pqmodn tromp_ vvv_ EvanR dpwright pdxleif_away alpounet trybeca stew linduxed lahwran greymalkin zeiris_ Plex_ Dybber McManiaC Enigmagic arbn jlewis bxc_ sully kqr saiam SaBer DarkFox ixian joeyh dumbhat banjiewen guerrilla Zariel dqd Amadiro petanqk djahandarie ique def-lkb_)
14:11:38 --- names: list (voyd_ wereHamster bholst_ Clint koala_man aszlig Ke Ptival integral horlicks tew88- zomg jlouis natte Rembane SquidTamer pharaun numberten wting gridaphobe strmpnk warpy Nimatek |-{0}-| XMunkki_ danr Raynes MasseR bbee2 ido gds otterdam yam Adeon idoru ethercrow ehamberg pi8028 marienz thorkilnaur_ jcp CindyLinz Derander froztbyte Gracenotes)
14:11:53 <xplat> augur_: it seems your construction is more syntactic while brzozowski's is more semantic
14:12:09 <augur_> xplat: i guess!
14:12:15 <Hrumph> can anyone suggest a function that takes two lists of identical lengtg, does and element by element comparison and returns the elements from the second list that are different
14:12:18 <merijn> typoclass: That won't work for widgets with different types, which will be the common case
14:12:42 <typoclass> merijn: k
14:12:58 <xplat> augur_: you get an NFA because you have operators with an existential meaning, if you added things like & or (?=) you would have an AFA
14:13:02 <mauke> :t map snd . filter fst . zipWith (\x y -> (x /= y, y))
14:13:03 <lambdabot>     Couldn't match type `[t0] -> [(Bool, t0)]' with `[(Bool, b0)]'
14:13:03 <lambdabot>     Expected type: [t0] -> [(Bool, b0)]
14:13:03 <lambdabot>       Actual type: [t0] -> [t0] -> [(Bool, t0)]
14:13:08 <mauke> yes, yes
14:13:13 <augur_> xplat: afa?
14:13:15 <typoclass> merijn: that's another thing i was wondering about. you have 'Widget a', not '(Widget w) => w'
14:13:22 <mauke> :t \xs -> map snd . filter fst . zipWith (\x y -> (x /= y, y)) xs
14:13:23 <lambdabot> Eq b => [b] -> [b] -> [b]
14:13:51 <mauke> :t \xs ys -> [ y | x <- xs | y <- ys, x /= y ]
14:13:52 <lambdabot>     Unexpected parallel statement in a list comprehension
14:13:52 <lambdabot>     Use -XParallelListComp
14:14:10 <typoclass> Hrumph: hello, i recommend as a first step that you look at the zip and zipWith functions
14:14:17 <nabilhassein> hello all, another simple question
14:14:24 <typoclass> > zip [1..3] [7..100]
14:14:25 <lambdabot>   [(1,7),(2,8),(3,9)]
14:14:34 <nabilhassein> my google-fu is failing me: how can i parse an Int using attoparsec?
14:14:40 <Hrumph> typoclass: yes that's what i was going to do but i like mauke's function better than whaat i was going to do
14:14:42 <typoclass> > zipWith (*) [1..3] [7..100]
14:14:43 <lambdabot>   [7,16,27]
14:14:55 <Hrumph> i was going to use zip and and some other things but zipwith is neater
14:15:15 <xplat> augur_: it's really less 'regex = zipper' and more 'interpreter of tree-shaped programs = zipper × interpreter state'
14:15:25 <Hrumph> this function might be used in part of another function in a pull reqquest so i was trying to maximise elegance
14:15:30 <EvanR> nabilhassein: number
14:15:30 <Ralith> now I want to see someone name something MonoidFactory
14:15:47 <augur_> xplat: no no its not that i was saying 'regex = zipper'
14:15:54 <augur_> thats definitely not true
14:16:01 <nabilhassein> EvanR: in which package can I find it?
14:16:02 <EvanR> nabilhassein: http://hackage.haskell.org/packages/archive/attoparsec/0.10.4.0/doc/html/Data-Attoparsec-ByteString-Char8.html
14:16:34 <augur_> rather, it's that 2 * RegExpZipper = NFA States
14:16:50 <augur_> for certain canonical NFA constructions, anyway
14:17:00 <EvanR> nabilhassein: actually decimal on the same page might be more appropriate for integers
14:17:10 <EvanR> non negative
14:17:12 <sclv_> afa = any freaking automaton
14:17:15 <sclv_> :-P
14:17:26 <xplat> augur_: AFA = alternating finite automaton
14:17:56 <merijn> typoclass: Yeah
14:18:00 <sclv_> my definition is better
14:18:04 <augur_> xplat: also, importantly, the transition function just becomes a (non-deterministic) tree traversing function
14:18:27 <nabilhassein> EvanR: thanks very much, that's exactly what I needed
14:19:07 <xplat> yes, it's basically the observation that if your program is given as a tree and PC transitions are local in the tree structure you can use a zipper as your program + PC
14:19:29 <augur_> xplat: PC?
14:19:34 <xplat> program counter
14:19:40 <augur_> ah, yes
14:20:05 <augur_> xplat: is there anything i can read on this?
14:20:16 <xplat> not that i know of
14:20:19 <augur_> :(
14:21:45 <johnw> merijn: ping
14:23:55 <typoclass> > let f = zipWith (\x y -> if x /= y then [y] else []) in concat (f [1,2,3] [1,7,3]) -- Hrumph: here is another simpler variant
14:23:56 <lambdabot>   [7]
14:24:08 <typoclass> > let f = zipWith (\x y -> guard (x /= y) >> [y]) in concat (f [1,2,3] [1,7,3]) -- Hrumph: ... and a more complicated variant
14:24:09 <lambdabot>   [7]
14:25:06 <Taneb> Other than AMP, what's the haps with Haskell '14?
14:25:21 <johnw> Foldable/Traversable
14:25:22 <typoclass> Taneb: 'haps'?
14:25:32 <Taneb> typoclass, "happenings"
14:25:32 <johnw> typoclass: "what's happening"
14:26:01 <Taneb> johnw, Foldable/Traversable is going ahead? Great :)
14:26:53 <johnw> looks like it from all accounts
14:27:27 <merijn> johnw: pong
14:27:47 <typoclass> 'haps' sounds like something a loud corpulent aunt would say
14:27:57 <merijn> preflex: seen mm_freak
14:27:57 <preflex>  mm_freak was last seen on #haskell 8 days, 1 hour, 9 minutes and 26 seconds ago, saying: or pretty much enforces
14:28:01 <merijn> :(
14:28:03 <typoclass> possibly also a loud corpulent hipster aunt
14:28:05 <typoclass> =)
14:29:17 <johnw> merijn: n/m, I found my issue
14:29:36 <johnw> my configure wasn't finding docbook-xsl, but when I switched to bash it did
14:34:02 <johnw> typoclass: I prefer my aunts cromulent, thank you
14:36:20 <typoclass> johnw: =)
14:37:06 <Taneb> preflex: seen shapr
14:37:06 <preflex>  shapr was last seen on #haskell-lens 20 days, 20 hours, 58 minutes and 13 seconds ago, saying: yup
14:59:45 <pmade> Does anyone know of or is working on an XML parser compatible with io-streams?
15:12:35 <romanandreg> is there a way to pass a Type with a Type parameter to a TH function say: templateFn ''Maybe Int
15:12:36 <romanandreg> ?
15:12:57 <c_wraith> try putting the whole type in quotes?
15:13:03 <c_wraith> err, parens
15:13:12 <c_wraith> ''(Maybe Int) should work, iirc
15:13:26 <romanandreg> uhmm
15:13:48 <romanandreg> I'm trying a tuple, doesn't seem to work
15:13:51 <romanandreg> templateFn ''(Int, Int)
15:14:12 <romanandreg> nor templateFn ''(Maybe UTCTime)
15:14:17 <romanandreg> if I do
15:14:22 <romanandreg> type MUTCTime = Maybe UTCTime
15:14:29 <romanandreg> templateFn ''MUTCTime
15:14:30 <c_wraith> huh.
15:14:31 <romanandreg> I can do it
15:14:32 <romanandreg> but
15:14:33 <romanandreg> yeah
15:14:37 <romanandreg> boilerplate hell
15:16:44 <stelleg> @djinn [a] -> [a]
15:16:45 <lambdabot> Error: Undefined type []
15:17:28 <stelleg> @djinn (a,b) -> a
15:17:29 <lambdabot> f (a, _) = a
15:17:56 <joelteon> @djinn (a -> b) -> (b -> a)
15:17:57 <lambdabot> -- f cannot be realized.
15:18:29 <stelleg> @djinn (a -> b) -> (c -> b) -> Either a c -> b
15:18:29 <lambdabot> f a b c =
15:18:30 <lambdabot>     case c of
15:18:30 <lambdabot>     Left d -> a d
15:18:30 <lambdabot>     Right e -> b e
15:24:28 <thirsteh> is there a helper method like aeson's "object" which leaves out values that are Nothing (instead of serializing key: null in the JSON)?
15:25:13 <c_wraith> Seems like that should be a property of the JSON instance
15:27:05 <thirsteh> c_wraith: the ToJSON instance for Maybe would be the best place, but I can't really change that without a really ugly newtype
15:27:20 <thirsteh> I guess that wouldn't change the behavior of writing the keys, either
15:27:31 <c_wraith> it doesn't work in Maybe
15:27:36 <c_wraith> it's got to be at the next scope up
15:28:40 <thirsteh> basically, I just want to do object [ a:mfoo, b:mbar ] and have b left out if it is Nothing. I was planning on doing some kind of mconcat, just wondering if anybody else already did this
15:28:52 <thirsteh> it being mbar
15:29:21 <thirsteh> and : being !=. Sorry, tired
15:29:46 <thirsteh> argh. : being .= :)
15:31:09 <rribeiro> Hello all! I'm with a little trouble in the definition of a parsec parser for the following grammar: T ::= Bool^t | (T -> T)^t, where t is a annotation
15:31:50 <rribeiro> Hello all! I'm with a little trouble in the definition of a parsec parser for the following grammar: T ::= Bool^t | (T -> T)^t, where t is a annotation. Can someone help me with this issue?
15:33:46 <aoshi> you should try pasting your query again, I hear that gets results
15:35:54 <alpounet> rribeiro, you should paste your code, explain the issue you're having. will be easier for people to help you out :-)
15:36:01 <alpounet> @where hpaste
15:36:01 <lambdabot> http://hpaste.org/
15:39:05 <merijn> I swear, FRP is doomed if netwire is the state of the art in it >.>
15:39:59 <alpounet> merijn, netwire seem to fulfill quite a few people's need, although i haven't been convinced personally
15:41:14 <Peaker> merijn, take a look at peakachu+defend the king (old stuff, but it might still work and it's a nice demo)
15:41:32 <zeiris_> Is netwire just the only working FRP project, while the rest are broken/do not actually work?
15:41:32 <merijn> alpounet: I've had over 10 in depth discussions about mm_freak about it's use, after our last one, I finally thought I'd seen the light
15:41:50 <merijn> To *once again* get stuck on something that should be trivially simple
15:42:02 <alpounet> what's that "thing"?
15:42:06 * hackagebot aterm-utils 0.2.0.2 - Utility functions for working with aterms as generated by Minitermite  http://hackage.haskell.org/package/aterm-utils-0.2.0.2 (JasonDagit)
15:42:22 <hpaste> rribeiro pasted “Problem with a parsec expression parser” at http://hpaste.org/90114
15:42:32 <c_wraith> zeiris_: banana is also working
15:42:47 <rribeiro> alpounet: I've pasted the problematic code
15:42:53 <luite_> sodium should also work, but not on GHC HEAD yet
15:43:09 <merijn> We had discussed some ideas about a Wire based gui approach, after a few discussions and him sketching an approach I finally saw the light. Only to fail on something as simple as "change which Widget has the focus (receives input)"
15:43:16 <rribeiro> alpounet: my issue is how to define the expression parser for this simple type language...
15:45:41 <alpounet> merijn, fail to write elegant code or just to handle the situation decently?
15:45:52 <typoclass> "I finally thought I'd seen the light, to *once again* get stuck on something that should be trivially simple" <- sounds like a haskeller learning frp is vaguely like a javascripter learning haskell
15:46:32 <merijn> alpounet: Fail to handle the situation at all
15:47:29 <alpounet> oh, maybe mm_freak will figure something out
15:48:29 <merijn> alpounet: i.e. the idea was to have a UI be a Wire from Input to Layout (Layout being the screen to render), our last discussion ended with something like having a Wire that takes an input and produces a Widget, then you compose the Widget together and produce a layout from that
15:49:29 <merijn> Except, if you have two Widgets, how do you decide where to feed input too? Not feeding input will mean you don't produce at all, so then what do you pass to the layout?
15:49:55 <typoclass> rribeiro: so, what is your question? :-) is line 25 the problem? ("arr = undefined")
15:50:00 <merijn> And if you solve that, then how do you write code that switches the input over from a Wire to another?
15:50:05 <alpounet> merijn, two widgets can't just be there alone if you compose them
15:50:07 <merijn> Without repeating yourself a billion times
15:50:08 <alpounet> right?
15:50:25 <rribeiro> typoclass: Yes... I need to define the arr function that will generate the operator Arrow for the parser
15:50:30 <alpounet> i know quite well how Qt does that, used it extensively for a while (basically until I switched to Haskell)
15:50:31 <merijn> alpounet: I don't understand the question?
15:50:57 <rribeiro> typoclass: The problem is that the Arrow constructor has an extra parameter, that corresponds to the result of parser sec
15:51:38 <rribeiro> typoclass: and I don't know how to build this expression parser with this aditional annotation on type expressions
15:52:16 <alpounet> merijn, why not have a UI be a Wire from Input to Widget?
15:52:54 <jmcarthur> arrow frp has never made much sense to me
15:53:20 <jmcarthur> i much prefer to think of a behavior as a value than as some type i use to unify a couple of arrow thingies
15:53:20 <merijn> alpounet: And then?
15:53:38 <merijn> alpounet: That's what I had
15:53:49 <alpounet> merijn, what was the issue with that approach?
15:53:49 <merijn> But then how do you combine the results?
15:54:02 <jmcarthur> also, netwire in particular isn't really FRP-like to me at all. it's just automata, isn't it?
15:54:22 <alpounet> merijn, like, having a "group of two widgets" that listens to the same Input?
15:54:42 <merijn> alpounet: Imagine you have a text input and a button, both being a Wire from Input to Widget, where do you send the Input?
15:55:10 <alpounet> merijn, to the thing that contains them
15:55:10 <merijn> alpounet: Or even two text inputs, clearly key events should only be going to one of them
15:55:12 <typoclass> anyone know about rribeiro's question and paste? ^^
15:55:23 <typoclass> rribeiro: i don't know much about Arrows, sorry
15:55:34 <conal> jmcarthur: almost nothing i see described as "FRP" satisfied either of the two properties fundamental for me (denotative and temporally continuous).
15:55:36 <merijn> alpounet: And how does the thing that contains them send input to only one of them?
15:55:59 <rribeiro> Ow typoclass, the Arrow is just a constructor of a data type, no arrows knowledge needed :)
15:56:34 <jmcarthur> conal: same here
15:56:36 <typoclass> rribeiro: urgh :-) i see, it's your own. data Ty = ... | Arrow Ty Ty Sec
15:57:06 <rribeiro> typoclass: yes! The problem is to build the expression parser for Ty
15:57:20 <brendan> hello. I am not really a haskell user but a series of yaks led me from pandoc to trying to build the "text" module for fink/ghc 7.6.3. It errors out wiht a lot of "error: invalid preprocessing directive #-}" here. any clues would be appreciated
15:57:24 <merijn> jmcarthur: Maybe, but I don't think I understand things well enough to implement it myself
15:57:51 <jmcarthur> merijn: the implementation of FRP libraries has proven to be a difficult undertaking :(
15:57:51 <merijn> The FRP and tangible values stuff looks so close to what I would want, but not quite
15:58:10 <jmcarthur> yeah, i also feel like something is missing, even from the (what i consider to be) "done right" libraries
15:58:29 <merijn> Although I should probably read the tangible values papers, so far I only saw conal's talk
15:59:27 <alpounet> hah, saw that talk too, i also have that "sexy but not the best we can do" feeling
15:59:45 <alpounet> merijn, let me check out net wire's doc again
15:59:54 <typoclass> rribeiro: hm. http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/Text-Parsec-Expr.html indicates that the buildExpressionParser function as its first argument requires an OperatorTable
16:00:02 <merijn> The problem I have with the tangible values thing is, what if what I want is not really describable as a pipeline
16:00:45 <typoclass> brendan: hi, i think someone a few days ago had a problem which may be similar. it had to do with the mac using clang instead of gcc. hang on ...
16:01:11 <jmcarthur> merijn: i don't feel like that should be a problem. after all, every function in haskell takes only one argument
16:01:29 <brendan> typoclass: ah! that probably applies
16:01:30 <merijn> jmcarthur: I don't get how that's related?
16:01:31 <jmcarthur> maybe that's a bad analogy
16:01:49 <jmcarthur> i choose to abandon it
16:02:00 <jmcarthur> rather than explain it
16:02:06 <hpaste> rribeiro pasted “Problem with a parsec expression parser” at http://hpaste.org/90115
16:02:44 <rribeiro> typoclass: And this is the problem... to build the operator table for the operator "->" that takes two Ty's and one Sec value
16:03:11 <rribeiro> this simply doesn't work! I'd like to know if there's a better way of doing that...
16:08:29 <int-e> brendan: the text library assumes that the C preprocessor ignores lines not starting with '#'. So ' #-}' should be fine. This works fine for gcc -E, which is what ghc uses for gcc.
16:08:52 <brendan> it is probably clang
16:08:57 <alpounet> merijn, well i don't know how that would go with netwire, but wouldn't it be possible to have the parent widget be aware of who has the focus and forward key events there?
16:09:07 <brendan> I guess I have to rebuild ghc
16:09:36 <niteria> RunT m >>= f = RunT $ liftM (>>= f) m, can I write it without liftM (with just >>=) somehow?
16:10:15 <niteria> if I understand correctly the >>= I want to use is shadowed by one I'm defining
16:10:18 <merijn> alpounet: But if we have a Wire Input to Widget, then if we forward te input to one of them, the other won't output a Widget?
16:10:58 <sclv> conal, jmcarthur: skimming through the new "frp" papers from icfp2013 i was curious if you felt progress was being made
16:11:16 <conal> sclv: i haven't looked.
16:11:19 <sclv> (i've corrected 2 or 3 people at least from "frp" to simply "reactive" in describing their libs btw :-))
16:11:36 <alpounet> merijn, the other would output the same Widget, you just want some events to go to only one widget
16:11:45 <typoclass> brendan: hm, i think that discussion didn't reach a real resolution :-) basically, someone had a mysterious build failure, and it was tracked down to ghc using clang as the preprocessor (not gcc -E), and that caused a tab character to be turned into spaces (which gcc doesn't do), and that caused a build failure due to wrong indentation
16:11:58 <typoclass> brendan: here is a message near the end of the hunt http://ircbrowse.net/browse/haskell?id=15825350&timestamp=1370440220&http://ircbrowse.net/browse/haskell?id=15825432&timestamp=1370441283&events_per_page=100#t1370440220
16:12:00 <alpounet> not all
16:12:16 <brendan> typoclass: thanks, very helpful
16:12:32 <brendan> I think I can figure out how to get ghc to use gcc instead of clang now that I know that's the problem
16:12:37 <alpounet> like, if you resize your window, you may want all your UI elements to get resized as well, which means they have to get that event too
16:12:39 <typoclass> brendan: i don't know what the person ended up doing. maybe some extra switch when building, maybe also rebuilding ghc :-/
16:13:02 <merijn> alpounet: How does it produce output with no input?
16:13:10 <typoclass> brendan: well it's a guess :-) but "preprocessor failure" and "#-}" sounds like it
16:13:40 <brendan> yes, I didn't even know ghc used cpp underneath :)
16:13:52 <sclv> conal: neelk's stuff remains, i believe, entirely discrete
16:14:01 <sclv> this one, however, relates to your push-pull stuff http://ect.bell-labs.com/who/ajeffrey/papers/icfp13.pdf
16:14:01 <int-e> brendan: it may be possible to use another preprocessor. http://pastebin.com/F2RwuGV4 may be related.
16:14:07 <mauke> The paste F2RwuGV4 has been copied to http://sprunge.us/gZhg?haskell
16:14:10 <int-e> brendan: there's a CPP language extension.
16:14:18 <typoclass> brendan: presumably it's a file that does {-# LANGUAGE CPP #-} or some such
16:14:21 <int-e> brendan: normally it doesn't.
16:14:32 <sclv> they note they 'haven't focused on continuous time behavior'
16:14:37 <conal> sclv: thanks.
16:14:43 <sclv> but it seems interesting
16:14:55 <alpounet> merijn, well, if the other isn't concerned by that event, maybe it just shouldn't output anything new, nothing has changed for it.
16:15:04 <thoughtpolice> you can force the preprocessor to gcc with a '-pgm' flag but I can't remember which, -pgmF perhaps. anyway, the situation with clang building GHC is a bit erm, weird, but i do now have a building up to stage1 at least. i've been working on it since monday or so
16:15:09 <int-e> (that's not completely true, but true for haskell sources at least.)
16:15:12 <brendan> yep, Data/Text.hs has LANGUAGE CPP at the top
16:15:27 <alpounet> maybe the wire for these events shouldn't be "activated" at that moment
16:16:15 <typoclass> brendan: oh wait. here's the person who had the problem http://ircbrowse.net/browse/haskell?q=juxovec there's a link to a bug ticket in there, which supposedly solves it (though i don't see how ...)
16:16:53 <merijn> alpounet: But if it's outputting the Widget then if it doesn't output anything, you have no Widget to render
16:17:00 <merijn> alpounet: Anyway, it's bed time
16:17:08 <merijn> I'll continue smashing my head some other time
16:17:24 <alpounet> merijn, you have the widget as it was rendered before the key event (for example) came in
16:18:11 <merijn> alpounet: Storing that result without writing horribly convoluted code is not as trivial as you make it sound, afaict
16:18:17 <merijn> Anyhoo, good night!
16:18:18 <thoughtpolice> typoclass: fwiw i think some of the tabbing character stuff is fixed. the '#-}' thing is also fixable by putting clang in 'assembler-with-cpp' mode
16:18:25 <alpounet> i mean for every widget, one wire that brings all the events that any widget can receive, and then a wire (sub wire?) for the focus, that would be switched dynamically?
16:18:34 <typoclass> thoughtpolice: oh, thanks
16:18:36 <typoclass> brendan: ^^
16:18:40 <thoughtpolice> we really violate C99 macro rules pretty badly in some cases, but in practice the preprocessor kinda needs to be a pretty full blown compiler i think
16:19:01 <alpounet> i'm conscious it can end up pretty complicated yeah, but that's similar to how GUI frameworks do it usually, in other languages
16:19:08 <thoughtpolice> the TL;DR is that I hope GHC 7.8 will be buildable by Clang 3.4svn+ by the time its released. this is really important for mac users more than anything, really
16:19:12 <brendan> typoclass: thanks
16:19:28 <thoughtpolice> it's actually already pretty close, i may be able to get GHC HEAD building on Linux/Clang by tonight
16:19:30 <brendan> thanks very much. I'll just force gcc :)
16:19:34 <thoughtpolice> which of course will now never happen since I said that
16:22:27 <int-e> brendan: you could also try this after unpacking text: perl -pi -0 -e 's/\n #-}/ #-}/g' Data/Text.hs Data/Text/Lazy.hs  Data/Text/Lazy/Builder/Internal.hs Data/Text/Fusion/Common.hs
16:23:06 <typoclass> @tell chrisdone hiya :-) if i could bug you again -- on ircbrowse.net, could you set the default page size to (say) 200? the current 35 seems awfully small, especially seeing how there's a great deal of joins, parts, and other overhead messages. currently a default-sized page may well contain only 5 actual messages before you need to click "next"
16:23:06 <lambdabot> Consider it noted.
16:23:50 <brendan> int-e: thanks. I'm actually trying to get things packaged nicely for fink, so setting the compiler seems like the best solution
16:24:33 <danil> Does the (trivial) instance Traversable (Either b) exist somewhere?
16:24:40 <typoclass> @tell chrisdone alternatively, there could of course be a checkbox defaulting to on which hides all the white messages, showing only the grey ones. but that may be more work to implement :-) anyway, if you could think about these suggestions, it'd be much appreciated.
16:24:40 <lambdabot> Consider it noted.
16:25:37 <thoughtpolice> danil: it lens has an orphan instance for it, but the instances will come with 'base' in 7.8, they were committed a week or two ago
16:26:01 <thoughtpolice> https://github.com/ghc/packages-base/commit/a9a9ce679e0c57437a17824cd6366d085248d217
16:27:03 <brendan> excellent, that did the trick
16:27:10 <brendan> thanks typoclass and int-e
16:27:16 * typoclass purrs
16:34:38 <jmcarthur> sclv: i, too, have not been following the latest in "frp"
16:47:13 * hackagebot nitro 0.2.2.0 - Haskell bindings for Nitro  http://hackage.haskell.org/package/nitro-0.2.2.0 (ErinDahlgren)
17:11:41 <koninkje> augur_: why not just use arxiv itself?
17:12:33 <koninkje> augur_: e.g., there's already http://arxiv.org/list/cs.CL/recent
17:12:50 <koninkje> augur_: that's more CL than pure linguistics, but...
17:30:45 <Hrumph> > msum [True,False]
17:30:46 <lambdabot>   Couldn't match expected type `m0 a0'
17:30:46 <lambdabot>              with actual type `GHC.Typ...
17:32:48 <johnw> Hrumph: Bool is not a MonadPlus, it doesn't even have the right kind
17:33:32 <Hrumph> johnw yep i realise
17:33:56 <Hrumph> i was wondering if it might be defined as one
17:33:58 <mike4_> does it take long to implement something in haskell
17:34:33 <Hrumph> mike4_ takes longer at the start and faster at the end and the payoff is nicer
17:34:48 <johnw> mike4_: all depends on what you're implementing, and who's doing the implementing of it
17:35:18 <Hrumph> mike4_: its longer at the start stage because its harder just to cobble something together the way you would with a declarative language
17:35:57 <Hrumph> mike4_: its faster at the end because once you've developped enough infrastructure you can combine it rapidly in ways you never could (or not so easily) in a declarative language
17:35:57 <johnw> Hrumph: that's not necessarily true at all
17:36:11 <johnw> I can belt out system scripts in Haskell now at pretty much the same speed as I used to in Python
17:36:39 <typoclass> mike4_: i would say it's hard to get something to compile in haskell, but once it does, you don't have much debugging work left anymore
17:36:44 <c_wraith> johnw: do you use something like the errors package for quick and dirty environments?
17:36:46 <johnw> it's more a matter of (a) familiarity with the language, (b) familiarity with the libraries involved, (c) have templates on hand that already sort of match the problem you want to solve.  This is true for any langauge
17:36:54 <johnw> c_wraith: I do use errors, yes
17:37:14 <c_wraith> heh. Now, take that line out of context...
17:37:24 <johnw> I make great use of errors! :)
17:38:11 <johnw> but more I use shelly and rely on its awesome behavior of telling me what it was doing when it encountered an exception
17:38:12 <mike4_> hmm so you must make a scripting environment to use afterwards to simplify your code with haskell?
17:38:32 <johnw> mike4_: once you do one, the next one gets easier, and so on
17:38:42 <c_wraith> johnw: has shelly fixed the broken monad instances it had a while ago?
17:38:46 <johnw> this isn't a phenomenon specific to Haskell
17:38:58 <johnw> c_wraith: dunno, I never ran into anything like that
17:39:47 <typoclass> mike4_: no you don't have to, haskell is a general-purpose language. there is a growing number of people now who use haskell for "shell-script-ish" things, many of them using the "shelly" library
17:40:12 <Hrumph> does shelly work on windows?
17:40:28 <johnw> i haven't tried it, but I can't see why it wouldn't
17:40:42 <johnw> underneath it's probably just using System.Process
17:41:09 <Sonarpulse> shelly is for scripts, not interactive right?
17:41:27 <typoclass> Sonarpulse: yep
17:41:28 <c_wraith> Sonarpulse: who says scripts aren't interactive?
17:41:47 <Sonarpulse> dash vs zsh
17:42:10 <mike4_> I see.
17:42:30 <lispy> johnw: I think something like shelly would be useful, but there are some things I really dislike about the current implementation. I've been meaning to write my objections down so I can start on an improved version.
17:42:50 <lispy> johnw: I need a better way to deal with all the FilePath vs. FilePath vs. Text vs. ByteString vs. String madness.
17:42:54 <typoclass> mike4_: anyway, give it a whirl :-) it's a great language http://tryhaskell.org
17:43:21 <lispy> johnw: and -|- is not a good replacement for unix pipes :(
17:43:30 <lispy> I've gotten burned by (-|-) a few times
17:44:10 <johnw> I use FilePath everywhere
17:44:13 <johnw> and I don't use -|-
17:44:24 <johnw> so, probably we don't intersect in our experience of shelly much
17:44:39 <Sonarpulse> arguabably >>= is about as close to pipe as you can get
17:44:49 <lispy> But when you query the filesystem or construct anything from scratch, it get String or Text
17:44:57 <johnw> i wouldn't mind if shelly just used conduit instead of its own piping scheme
17:45:09 <johnw> i bet greg would accept that patch, actually
17:45:16 <typoclass> lispy: how did you get burned? (buffering issues? i reserve a special kind of hatred for pipe buffering)
17:45:17 <johnw> lispy: huh?
17:45:21 <johnw> lispy: like when?
17:45:52 <lispy> typoclass: heh. If one end of (-|-) doesn't terminate the other end never gets to run
17:46:07 <lispy> typoclass: yes | ... is fine at the shell
17:46:12 <lispy> but the equivalent in shelly is not fine
17:46:17 <Sonarpulse> stdout = heftInvoke executable [args] stdin
17:46:36 <typoclass> lispy: oh i see
17:46:36 <Sonarpulse> wouldn't mind that
17:47:04 <c_wraith> Yeah, the Monad instance for Shelly.Pipes.Sh appears to be broken.  I might be misreading it, it's really complicated..
17:47:09 <typoclass> hm ... i'm trying to think of cases where that's needed. "yes |" is one
17:47:19 <lispy> johnw: also, I don't get why the filepath package (or whatever its called, system-filepath?) uses ByteString for everything. I only glanced at it, but it seemed like it should provide more Text.
17:47:21 <c_wraith> But it looks like >> is not the same as >>= \_ ->
17:47:31 <johnw> (yes, system-filepath)
17:48:02 * lispy has other things to tend to
17:48:08 <johnw> well, there's the encoded form of the filepath, specific to your OS, which is a ByteString.  You can decode this representation to a Text
17:48:44 <johnw> this way, it doesn't have to keep encoding it everytime you pass it to any method that actually makes use of the filepath
17:48:49 <typoclass> lispy: i think in linux file paths at some level don't have an encoding (= are a bunch of bytes). i guess that reasonably, everyone will use utf8 though
17:48:56 <johnw> you only decode it at the times when you want to use the Unicode representation
17:49:03 <c_wraith> Yeah, to be correct, the filepath has to be binary
17:49:44 <hcaulfield57> Is there an up to date tutorial on the State monad and others, I'm trying to learn them, but all examples use old versions
17:50:01 <johnw> typoclass: on zfs, I can choose a different file path encoding per-filesystem
17:50:19 <johnw> so, no assumptions of utf8, please!
17:50:23 <hpc> hcaulfield57: you can replace "State" with "state" at the value level and an old tutorial will work just fine
17:50:26 <c_wraith> hcaulfield57: about the only difference between old versions and new ones is that you change State to state, and StateT to stateT
17:50:48 <c_wraith> Right, at the value level.  Not the type level.
17:52:58 <hcaulfield57> Okay, thanks, I'll give it a go, and stop by again if I have any problems.
18:07:43 <draf> hello... question about eta-rule
18:08:18 <draf> eta-rule states that    \a -> f a   =  f
18:08:27 <draf> that is clear
18:08:58 <draf> so I'd expect to be able to use it to simplify also curried binary functions with two lambdas
18:09:00 <draf> as in
18:09:16 <draf> f' = \a -> (\b -> f a b)
18:09:28 <monochrom> yes
18:09:31 <c_wraith> that's valid
18:09:41 <draf> but how do you simplify that term using the eta rule
18:09:53 <c_wraith> two steps
18:09:54 <shachaf> Note that that rule isn't actually true.
18:09:59 <draf> that is, the eta rule as state above
18:10:01 <shachaf> But it's nearly true.
18:10:04 <monochrom> (\b -> (f a) b) = (f a)
18:10:10 <draf> shachaf: yes I know that it isn't true in the presence of seq
18:10:17 <c_wraith> seq isn't the problem
18:10:20 <draf> oh
18:10:24 <draf> monochrom: hmmm
18:10:31 <shachaf> c_wraith: ?
18:10:31 <c_wraith> the problem is that you need to specify that a is not part of f
18:10:37 <dibblego> when I use prop> with doctest I find no other way than to have build-depends: QuickCheck, but this is ick — is there any other way?
18:10:50 <shachaf> Oh, I meant seq.
18:11:02 <draf> monochrom: oh of course
18:11:04 <johnw> dibblego: if your test uses QuickCheck, then it depends on QuickCheck
18:11:15 <draf> monochrom: from the inside out... I was trying from the outside in :/
18:11:21 <dibblego> johnw: boo
18:11:29 <johnw> i'm not sure what you're expecting
18:11:35 <johnw> you can't use a package without importing it somehow
18:11:51 <tabemann> aren't there differences between m = f a and m x = f a x where if is a -> b -> c with regard to memoization (or not) behaviour?
18:12:01 <tabemann> where f is*
18:12:03 <dibblego> johnw: I am expecting to specify QuickCheck as a dependency for tests only, even though those tests appear in source (the whole point of doctest)
18:12:15 <draf> monochrom: thanks!
18:12:22 <c_wraith> tabemann: there are differences in terms of how GHC applies optimizations, sadly
18:12:35 <johnw> dibblego: show me your current cabal file for this project?
18:12:35 <shachaf> "memoization (or not) behaviour" is not specified by the report.
18:12:44 <Sonarpulse> dibblego: you mean for a "release" build you wish you could hide your quick check stuff?
18:12:50 <Moggle_> is there a standard library map with the arguments flipped? there's forM when you're in a monad, but I'm not and for some reason I'm hesitant to write a line like "for = flip map"
18:13:06 <c_wraith> Moggle_: not in a standard library.
18:13:11 <Moggle_> c_wraith: thanks
18:13:18 <johnw> plus, there is actually a "for", in Traversable
18:13:25 <Moggle_> :(
18:13:26 <johnw> it's just not what you're thinking
18:13:30 <tabemann> shachaf: I know it's not specified in Haskell 98; I was talking more about behavior under GHC
18:13:34 <dibblego> johnw: https://gist.github.com/anonymous/5810966
18:14:06 <johnw> dibblego: you mean, you need the build-depends on the library, but not on the test-suite?
18:14:07 <draf> c_wraith: I still didn't quite understand what you mean by a being a part of f needing to be specified
18:14:15 <dibblego> johnw: currently I do yes
18:14:17 <draf> c_wraith: a is bound by the first lambda
18:14:19 <lispy> typoclass: yeah, it's hard to interpret unix filepath unless you assume some convention (like using the LOCALE settings). Windows doesn't have that issue and I'm not sure what you do on osx.
18:14:24 <johnw> that's the opposite of what I expected
18:14:24 <draf> c_wraith: so that a is never in f
18:14:30 * lispy leaves
18:14:33 <shachaf> GHC behavior is "complicated"
18:14:40 <johnw> can you move it to the test-suite, and do the build so that I can see the error?
18:14:46 <dibblego> ok
18:14:51 <c_wraith> draf: well, in the rule for eta contraction, "f" is actually an entire expression, not just a single symbol.
18:14:51 <shachaf> But I think inlining matters more than sharing for most cases where people talk about the difference between those two.
18:15:08 <monochrom> draf: (\a -> (g a) a) ≠ g a
18:15:10 <c_wraith> draf: in order for eta contraction to be valid, the expression which makes up f must not refer to a
18:15:24 <dibblego> johnw: er it just worked, I have no idea why it wasn't earlier
18:15:26 <draf> oh oh
18:15:35 <draf> c_wraith: monochrom: got it
18:15:57 <johnw> dibblego: obviously, because I hadn't asked you yet
18:16:04 <dibblego> johnw: clearly, thanks
18:16:32 <erisco> how do you output llvm bitcode using ghc? I would have thought ghc -fllvm -E would have done so
18:16:59 <shachaf> Why? -E is for cpp
18:17:08 <shachaf> I mean, for stopping after running cpp.
18:17:42 <shachaf> The man page suggests -ddump-llvm and/or -keep-llvm-files, depending on what you're doing.
18:17:49 <erisco> sorry I meant -c
18:18:32 <shachaf> -c means "Do not link
18:18:33 <shachaf> "
18:18:40 <draf> seq can also distinguish both expressions though, right? as in   seq undefined b = undefined    and   seq (\a -> undefined a) b = b
18:18:55 <erisco> yeah, it just stops after making the object file
18:19:25 <c_wraith> draf: yes, that's also correct
18:19:32 <draf> c_wraith: thanks!
18:24:31 <johnw> @tell merijn Checkout http://ghc.newartisans.com, Ubuntu 12.04 binaries, build logs, fulltest results, and nofib results, are all there now, will be building daily in tandem with OS X
18:24:31 <lambdabot> Consider it noted.
18:26:11 <monochrom> oooh GHC 7.7
18:27:17 <hpc> monochrom: you have such a pavlovian reaction to ghc releases ;)
18:27:25 <johnw> there is no release here
18:27:29 <johnw> this is just a HEAD build
18:27:45 <johnw> caveat installor
18:28:44 <johnw> although, hsenv makes it quite easy to play around with HEAD builds
18:30:34 <meretrix> Anyone familiar with the pipes library?  I'm trying to connect two pipes with different return types: "()" and "Maybe ()". Is there some way to modify them?
18:30:41 <meretrix> The error I get is "Expected type: () -> ProxyFast () Int () C IO (Maybe ())    Actual type: () -> Consumer ProxyFast Int IO ()".
18:32:09 <meretrix> In the past I've gotten around this by using polymorphic return values, but I can't change the pipes in this case.
18:32:31 <c_wraith> The biggest issue is ProxyFast vs Consumer
18:32:45 <c_wraith> those type signatures are really entirely different
18:32:50 <c_wraith> not just Maybe () vs ()
18:32:59 <meretrix> c_wraith: Well Consumer is a synonym for ProxyFast.
18:34:28 <c_wraith> oh, that's a strange type synonym
18:34:56 <c_wraith> ok, yeah, the type difference is just what you said.
18:35:54 <c_wraith> meretrix: looks like you should be able to use the MFunctor class to convert
18:36:20 <c_wraith> meretrix: though it's got several moving pieces, and I haven't learned enough about pipe to see the right answer immediately
18:37:26 <pharaun> is dyn broken on ghc 7.6.3 ? i found a bug ticket but it seems like its for 7.8 that it was fixed
18:39:34 <c_wraith> meretrix: whoops, nevermind.  you can do it with just Functor.
18:40:21 <c_wraith> meretrix: fmap (const ()) :: ProxyFast () Int () C IO (Maybe ()) -> ProxyFast () Int () C IO ()
18:40:55 <c_wraith> meretrix: and conversely, fmap (const $ Just ())  :: ProxyFast () Int () C IO () -> ProxyFast () Int () C IO (Maybe ())
18:41:57 <meretrix> c_wraith: Ah that is quite easy. Thanks!
18:43:46 <adnap> Is there a way to accomplish dynamic software updating at the function level in Haskell?
18:43:53 <adnap> (Like with Lisp)
18:44:05 <c_wraith> in the sense of replacing what function a name refers to?
18:44:16 <adnap> Yeah
18:44:23 <johnw> what some languages call "hot code loading"
18:44:26 <monochrom> very difficult
18:44:26 <adnap> With a running compiled program
18:44:43 <c_wraith> Not without changing functions to be proxies to real functions
18:45:09 <monochrom> some choices are: use the GHC API; use an IORef (your function type)
18:45:14 <c_wraith> and the GHC api isn't great for code loading as it stands, anyway
18:45:17 <adnap> It sounds like a useful project
18:45:33 <johnw> but useful to whom...
18:45:34 <c_wraith> Since there's no support for unloading code
18:45:45 <c_wraith> which means any repeated code loading is a memory leak
18:45:48 <adnap> Useful to anyone writing software in Haskell
18:46:05 <monochrom> it has still somewhat not useful to me
18:46:14 <johnw> would you just swap the function body?  can it affect RULES?  what about references to that function in existing thunks?
18:46:29 <johnw> what if the function was INLINE'd everywhere?
18:46:33 <johnw> I see many problems down this road
18:46:37 <startling> c_wraith, ugh what
18:46:41 <typoclass> adnap: you could look at ghci's code, but who knows what you'll find there ...
18:46:49 <c_wraith> startling: that's a current limitation of the ghc api
18:46:54 <adnap> I don't know. How are these problems avoided in Lisp?
18:47:04 <startling> c_wraith, that's terrible
18:47:08 <c_wraith> adnap: function names don't even exist in haskell at runtime.
18:47:11 <startling> adnap: dynamic name lookup
18:47:31 <adnap> Why is there Hint and GHCI? Do they duplicate each other in some ways, or does one use the other?
18:47:43 <c_wraith> Hint is a wrapper around the ghc api
18:47:43 <monochrom> they use the GHC API
18:47:54 <c_wraith> it hides a lot of the most complicated things
18:48:04 <c_wraith> the GHC api is really not a good api.
18:48:05 <hpc> adnap: in some sense, hint is ghci as a function call, and ghci is hint as a command-line utility
18:48:06 <adnap> Why is there no GHCI api?
18:48:09 <c_wraith> there is
18:48:12 <c_wraith> it's the ghc api
18:49:11 <adnap> I guess GHCI and Hint duplicate each other in some ways
18:49:22 <adnap> both using the GHC API
18:49:32 <c_wraith> that's about all they have in common
18:49:33 <monochrom> in fact, I recently did this: I write a libHaskell.so in GHC's Haskell, it uses GHC API. I then have a C program dlopen my libHaskell.so
18:50:08 <adnap> ldopen?
18:50:20 <monochrom> dlopen. no typo
18:50:26 <c_wraith> monochrom: just so you can destroy all the objects it creates?
18:50:58 <hpc> also, let it be known that GhcMonad is the silliest typeclass ever
18:51:12 <adnap> Okay. Somebody in #lisp mentioned "ldopen". I guess they meant "dlopen"
18:51:18 <monochrom> well, it gets to load (interpret) a *.hs file and evaluate an expression and print the answer, before it dies
18:51:25 <typoclass> hpc: GhcMonadClass
18:52:21 <monochrom> always trust monochrom after you have asked him to double-check and he has confirmed
18:52:39 <shachaf> monochrom: Always? Are you sure about that?
18:52:51 <monochrom> haha
18:53:00 <c_wraith> He hasn't double-checked that assertion yet.
18:56:47 <adnap> With C, I can imagine how a program runs with a runtime stack and a heap, but I have a hard time imagining how a Haskell program runs. Can I think of it as just evaluating one long expression a bit at a time?
18:57:06 <adnap> I can't imagine how code unloading would work
18:57:57 <monochrom> yes
18:58:25 <adnap> I imagine if there is a lookup table for every function, then when a new definition of a function is inserted, the old one is removed from memory and the entry in the table is replaced with the new definition, and the evaluation carries on
18:58:59 <adnap> The expression might be partially evaluated with the old function definition, and then new parts are evaluated with the new definition
18:59:16 <monochrom> there is no lookup table for that, unless you use GHC API
18:59:24 <adnap> But all type safety seems to go out the window
18:59:35 <monochrom> and even then, the table is only good for things you tell GHC API to load
18:59:37 <adnap> Unless the new definition has the exact same type
19:00:15 <adnap> monochrom: Yeah, this is a hypothetical lookup table
19:00:22 <adnap> ... that I am describing
19:07:22 * hackagebot testloop 0.1.0.1 - Quick feedback loop for test suites  http://hackage.haskell.org/package/testloop-0.1.0.1 (RomanGonzalez)
19:12:22 * hackagebot papillon 0.0.1 - packrat parser  http://hackage.haskell.org/package/papillon-0.0.1 (YoshikuniJujo)
19:46:47 <parcs> why should `_ <- atomicModifyIORef ref (\_ -> undefined)` do?
19:46:50 <parcs> what
19:47:21 <pharaun> how come is ghc api not a good api?
19:48:48 <johnw> pharaun: that's not a very worthwhile question
19:49:09 <pharaun> johnw: how so? cos i was just pondering if its terrible can't it be improved etc?
19:49:22 <parcs> pharaun: the main problem is that it's not well documented
19:49:24 <johnw> pharaun: if you are serious, ask in #ghc
19:49:53 <pharaun> johnw: its just that it was called terrible :p
19:49:57 <johnw> a better way to phrase your question, however, is: what can I do to help improve the GHC API?
19:50:14 <pharaun> parcs: ah i can see that, i've tried to tangle with the ghc api a few time before on that recent topic ^
19:50:27 <johnw> asking us why it's not good is hardly going to garner an enthusiastic response
19:50:43 <pharaun> just saying its "terrible" isn't informative tho :\
19:51:32 <enthropy> parcs: put undefined into the IORef
19:52:43 <enthropy> there's a strict version atomicModifyIORef' if you want it to throw an exception for just doing the io
19:53:10 <parcs> enthropy: but the function passed to atomicModifyIORef should return a tuple
19:54:48 <enthropy> > let (a,b) = undefined in 4
19:54:49 <lambdabot>   4
19:55:15 <parcs> what should 'atomicModifyIORef ref undefined' do?
19:56:42 <enthropy> parcs: you think it should be stricter than it is?
19:56:57 <parcs> ah, never mind. i should've read the documentation
19:57:07 <parcs> the key is that atomicModifyIORef doesn't apply the function strictly
19:57:38 <enthropy> the matching on the result isn't strict either
19:59:03 <parcs> yeah, i just got hung up that atomicModifyIORef is implemented as a primop, the strictness of which is obviously opaque
20:05:41 <fizbin> [0]="\
20:05:53 <fizbin> oops - wrong window.
20:13:39 <nabilhassein> does attoparsec have "<|>" or something like it?
20:14:00 <c_wraith> well, is it an instance of Alternative?
20:14:35 <c_wraith> operators don't just come out of nowhere. They'd be in the docs.  And <|> comes from having an Alternative instance
20:14:41 <shachaf> c_wraith: That's a whole lot like (<|>).
20:15:31 <c_wraith> hey, look.  the attoparsec docs say "(Applicative (Parser t), Monoid t) => Alternative (Parser t)	"
20:15:35 <nabilhassein> I found this in the docs: (Applicative (Parser t), Monoid t) => Alternative (Parser t)
20:15:44 <c_wraith> That would mean <|> works
20:15:48 <enigmuriatic> when you recurse on a function, are all the variables in the body of the function stored the whole time? or does the compiler intelligently determine which ones it can get rid of before it goes to the next layer of recursion?
20:16:20 <c_wraith> enigmuriatic: that has many different levels of answer. The truest ones are the most complicated with tons of special cases.
20:16:25 <nabilhassein> c_wraith: how can i bring it into scope? do I have to import Data.Attoparsec.Types?
20:16:36 <c_wraith> nabilhassein: nah, import Control.Applicative
20:17:08 <c_wraith> nabilhassein: if you click on the class name in the docs, it'll take you to the documentation for where it's defined, which is where you need to import it from
20:17:20 <enigmuriatic> c_wraith, so the GHC does in some cases get rid of no-longer-used memory during recursion?
20:17:31 <nabilhassein> c_wraith: perfect. thanks!
20:17:55 <c_wraith> enigmuriatic: GHC supports full tail-call optimization, which gets rid of all local variables when it applies
20:18:37 <c_wraith> enigmuriatic: though you need to be careful of combining that with lazy evaluation, which will in some cases keep the expression in memory unevaluated.
20:20:45 <c_wraith> enigmuriatic: so a simple function like....  fac n = fac' 0 n where fac' acc 0 = acc ; fac' acc n = fac' (acc * n) (n - 1)
20:21:28 <c_wraith> enigmuriatic: the definition of fac' is tail-recursive, so it will be tail-call optimized.  But that doesn't help with memory use, because the accumulator is never evaluated
20:22:08 <c_wraith> hmm.  That definition is also wrong, but nevermind that.
20:22:30 <c_wraith> (the starting point in the call to the helper should be 1, not 0)
20:23:22 <enigmuriatic> i see (somewhat)
20:38:25 * lispy is back
20:38:50 <lispy> johnw: ping
20:42:05 <johnw> hi there mr. lispy
20:45:04 <lispy> johnw: did anyone get back to you about haskell-infrastructure?
20:45:16 <lispy> johnw: we have someone who is actually following up with people now.
20:45:27 <johnw> yes, sclv contacted me
20:45:44 <lispy> excellent
20:51:48 <johnw> thanks for following up
20:53:42 <lispy> johnw: np
20:53:54 <lispy> johnw: it's literally the least I could do :)
20:54:03 <johnw> haha
20:54:51 <shachaf> Uh, what are all these nicks?
20:55:08 <shachaf> Who's sbtester?
20:55:21 <lispy> and why are all these kids on my lawn??
20:55:35 <copumpkin> you expect to recognize all the nicks in a channel of a 1000 people?
20:56:15 <shachaf> copumpkin: When you have a dozen different nicks IRCing from the same host with the same username, it's a little suspicious.
20:57:56 <Ralith> shachaf: more suspicious when they're klined en masse.
20:58:11 <shachaf> Ralith: Oh, I didn't notice that.
20:58:12 <Ralith> also, running on AWS
20:58:21 <shachaf> I thought it was part of the netsplit.
20:58:30 <Ralith> I wonder if you could get amazon to close his account if you wrote down the timestamp and IP
20:58:35 <Ralith> and had whatever reason he got klined
20:58:58 <johnw> what's kilning?
20:59:16 <shachaf> Anyway lots of similar users joining together makes me think they're about to all spam together or something.
20:59:36 <johnw> it's like Saruman making orcs in his basement
21:02:15 <Ralith> johnw: klining.
21:02:30 <Ralith> johnw: it's a network-wide ban.
21:03:24 <Clint> they didn't get all of them
21:17:28 * hackagebot persistent-template 1.2.0.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.2.0.2 (MichaelSnoyman)
21:18:55 <dmwit> sbtester = spambottester? =P
21:19:20 <dmwit> The huge list of k-lines is pretty impressive.
21:20:58 <Sonarpulse> with storable
21:21:07 <Botito> hola
21:21:13 <Sonarpulse> can haskell use the binary representation you give it on the haskell side of things?
21:21:34 <Sonarpulse> also for function pointers
21:21:36 <Sonarpulse> should i do
21:21:39 <Sonarpulse> a -> b
21:21:43 <Sonarpulse> or Ptr (a -> b)
21:21:59 <Sonarpulse> in lets say a stuct/product-type of function pointers
21:22:02 <pharaun> \o/ finally on 7.6.3 :)
21:22:16 <copumpkin> look at FunPtr if you want that
21:22:26 <copumpkin> there's a special construct to call them
21:22:32 * copumpkin runs off to sleep
21:22:51 <copumpkin> (foreign call dynamic)
21:23:40 <Sonarpulse> oh ok
21:27:33 <pharaun> i'm looking into doing some image stuff, and as far as i can tell the array/library i want to play with is repa?
21:27:37 <pharaun> been reading up on it
21:29:13 <johnw> pharaun: let me know how it goes
21:30:05 <pharaun> will do :)
21:30:18 <pharaun> it looks like it might be nice to use :)
21:32:45 <pharaun> johnw: oh yeah hows your git binding coming along?
21:33:39 <johnw> oh, quite nicely
21:33:48 <johnw> i work on it fairly constantly
21:34:16 <pharaun> sweet :)
21:34:22 <johnw> someday I'll consider it solid enough for a new release
21:34:36 <johnw> it's so different from what's on Hackage now, you wouldn't recognize it
21:36:17 <pharaun> oh man
21:36:48 <pharaun> last time i was here you seemed to be working mostly on the lower level interface and trying to figure out how to make the higher interface nicer, i take it you've made good progress there?
21:37:04 <johnw> yes, the higher-level interface is pretty much done
21:48:36 <lispy> :t liftA2 (>>)
21:48:37 <lambdabot> (Monad m, Applicative f) => f (m a) -> f (m b) -> f (m b)
21:48:42 <lispy> is there already something like that?
21:49:01 <shachaf> Yes, liftA2 (>>).
21:49:09 <shachaf> (Or, better yet, liftA2 (*>).)
21:51:00 <lispy> Hmm..
21:51:32 <lispy> It seems like it's kind of awkward to sequence behaviors in reactive-banana because I have to liftA2 (*>) the actions. No do-notation :(
21:52:58 <lispy> I can always make a new infix combinator, but I'm surprised it doesn't exist
21:56:38 <johnw> @type sequenceA
21:56:39 <lambdabot>     Not in scope: `sequenceA'
21:56:39 <lambdabot>     Perhaps you meant one of these:
21:56:39 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
21:56:42 <johnw> @type T.sequenceA
21:56:43 <lambdabot> (Applicative f, T.Traversable t) => t (f a) -> f (t a)
21:57:03 <fosskers> afternoon, fine gents
21:57:14 <augur_> @tell koninkje_away: mainly because it's not going to be *exactly* like arxiv, in that the intention is to let it act as a substitute for journals, with all the attendant functionality they have
21:57:14 <lambdabot> Consider it noted.
21:57:18 <bos> @pl \_ v -> g v
21:57:19 <lambdabot> const g
21:58:21 <fosskers> what was the syntax for anonymous case expressions? i looked around but couldn't dig anything up
21:58:39 <johnw> \case Left -> ...
21:58:44 <johnw> \case Left _ -> ...
21:58:46 <johnw> etc.
21:58:47 <fosskers> johnw: that's what i thought
21:58:54 <fosskers> compiler didn
21:59:01 <fosskers> 't seem to like it. let me try again
21:59:02 <johnw> enable LambdaCase
21:59:07 <fosskers> yeah
21:59:08 <johnw> and be using GHC 7.6
21:59:23 <Aetherspawn> is there an easy way to ensure that threads stay bundled together
21:59:40 <shachaf> There's no such thing as thread bundling in GHC.
21:59:53 <Aetherspawn> like, if I have a thread that spawns 3 threads, they all must die when the master one dies but if any of the children die the master dies too
22:00:09 <fosskers> 7.6.3 :)
22:00:22 <shachaf> No such thing. Threads don't have children or parents, either.
22:00:45 <shachaf> You'll have to make it yourself if you really want it. But perhaps it's not the right answer.
22:00:59 <shachaf> (Or, rather, not the right question.)
22:01:45 <johnw> Aetherspawn: I think the async library (especially `link`) may have some combinators to make that easier to express
22:02:14 <Aetherspawn> forkFinally actually makes it quite easy
22:06:42 <Chat7941> Hi
22:07:05 <shachaf> !list
22:07:05 <monochrom> shachaf: http://okmij.org/ftp
22:07:19 <shachaf> monochrom: Thanks!
22:07:35 <shachaf> I think I won !list-roulette.
22:07:41 <martint> !list
22:28:35 <Guest55594> pl \ f g x -> g (f x) x
22:28:47 <Guest55594> hm, I'm trying to get Lambdabot to use @pl
22:28:58 <mauke> have you tried @pl
22:29:02 <Guest55594> nope
22:29:30 <Guest55594> thanks
22:30:15 <Guest55594> though what it got my was horrible I mean beautiful
22:30:52 <Guest55594> but it's just cause the order I used
22:34:51 <blackdog> so, i think i'm doing something silly. i have an SCC which is about 85% of my allocation, but everything under it is basically trivial (1% or less)
22:35:19 <blackdog> it's not showing functions from cassy i'm sure it's calling. What colud be going on?
22:35:52 <blackdog> my immediate thought was that cassy might not be built with library-profiling, but then the compile wouldn't work at all, right?
22:47:34 <blackdog> ah, i think i worked it out. if you don't go and put "ghc-prof-options: -prof -auto-all" in the cabal files of the libraries you care about, they don't seem to get listed.
22:47:39 <blackdog> is that really the best way to do it?
22:51:29 <cmears> blackdog, you can say "cabal install --enable-library-profiling" (if I've understood what you want)
22:55:06 <xico> (or put library-profiling: True in your .cabal/config to build both for every lib)
22:56:54 <blackdog> cmears: that isn't enough.
22:57:07 <blackdog> i already had that: it doesn't apply -auto-all.
23:02:55 <blackdog> cmears, xico: http://hackage.haskell.org/trac/hackage/ticket/200 has a bit more about it.
23:03:42 <zRecursive> After putting `xterm -e gdb --quiet -nx $HOME/test/dwm-dbg/dwm -ex cont` into ~/.xinitrc, i can debug DWM.    I am curious how to debug haskell app such as xmonad ?
23:12:06 <Guest55594> Okay I'm annnoyed that nobody noticed that I was essentially making arrows a while back
23:13:10 <hpaste> sopvop pasted “Type familiy constraints are not required?” at http://hpaste.org/90122
23:13:52 <sopvop> ^ Why ghc does not require me to explicitly say I need an instance if I use type families?
23:14:10 <Guest55594> I think cause the type families are already constraints
23:14:51 <shachaf> sopvop: Because you gave a default.
23:14:53 <shachaf> Same as values.
23:15:33 <sopvop> Oh, It's an instance not a class I pasted there. You can guess the class from it :)
23:16:29 <hpaste> sopvop revised “Type familiy constraints are not required?”: “with class” at http://hpaste.org/90122
23:16:31 <Sonarpulse> how to i make FunPtr from haskell function?
23:16:57 <drbean> Is there something like [0..] !! index, but which takes a list of indices and returns a list?
23:17:19 <drbean> map ( [1..] !! ) [1,3,5] is a little wordy.
23:19:30 <enthropy> if you're only using lists like [0  .. ] and [1 .. ], you have    map (1 + ) [1,3,5] == map ( [1..] !! ) [1,3,5]
23:19:55 <enthropy> though maybe you need a fromIntegral there
23:20:27 <Sonarpulse> in general, if you need !!, list is the wrong datastructure
23:24:06 <fling> What to read first?
23:24:45 <enthropy> Sonarpulse: foreign import ccall "wrapper" mkFun :: (CInt -> CInt) -> IO (FunPtr (CInt -> CInt))
23:32:54 <joelteon> @pl \k -> _Object . at k . non (_Object # mempty)
23:32:54 <lambdabot> (line 1, column 7):
23:32:54 <lambdabot> unexpected "_"
23:32:54 <lambdabot> expecting lambda abstraction or expression
23:33:00 <joelteon> you suck, lambdabot
23:33:20 <joelteon> @pl \k -> f . at k . non (f # mempty)
23:33:24 <lambdabot> (f .) . flip ((.) . at) (non (f # mempty))
23:33:24 <lambdabot> optimization suspended, use @pl-resume to continue.
23:33:30 <joelteon> @pl-resume
23:33:36 <lambdabot> (f .) . flip ((.) . at) (non (f # mempty))
23:33:36 <lambdabot> optimization suspended, use @pl-resume to continue.
23:35:28 <Aetherspawn> I guess there is no way to get the name of the calling module from a function
23:36:48 <Sonarpulse> entrypy: what about foreign import ccall "wrapper" mkFun :: a -> b
23:36:48 <Sonarpulse> 	   -> IO (FunPtr a -> b)
23:36:48 <Sonarpulse>  
23:36:55 <Sonarpulse> polymorphism with ffi ok?
23:37:09 <Sonarpulse> enthropy
23:43:33 <b6> i'm confused about classes. i define an internal utility class in one module just to help me get my work done, but it really has nothing to do with the library. i don't intend to export its functionality. but is it exported somehow anyway?
23:48:40 <sopvop> b6: does your module has export list?
23:49:07 <b6> sopvop: yes. and i don't export anything related to the class. but i was under the impression it was somewhat uncontrollable?
23:49:26 <sopvop> b6 class instances are always exported, classes are not
23:49:56 <b6> sopvop: but if i don't export the class, are exported instances meaningful somehow?
23:50:00 <sopvop> No
23:51:03 <b6> i intend to generate instances of my utility class with TH. so i'm moving the class definition into its own module. but then i get warnings about orphan instances. i'm thinking about just silencing those warnings.
23:51:13 <supki> b6: define "meaningful"
23:51:36 <supki> instances still can be used, class imports/exports do not change anything really
23:51:38 <b6> supki: like, no one outside my module knows what class X is about, but some exported data constructor is an instance of it.
23:51:56 <sopvop> Orphan instances are either instances which are not defined in same module as data, or class.
23:52:06 <supki> well, that just makes inconvenient for somebody to provide another X instance
23:52:45 <b6> so if i don't export this utility class at all, does it seem fine to silence the orphan warnings?
23:52:49 <sopvop> my english bad, no potato :(
23:52:58 <b6> your english is awesome, don't worry.
23:53:51 <sopvop> If you move class to separate module, them make instances in same module as data.
23:54:00 <supki> if these instances are not really orphan, i.e. user cannot import class module alone, that's totally fine to silence warning
23:54:33 <supki> otherwise it depends
23:54:40 <b6> supki: yeah, this stuff is not really part of the library. should be invisible. it's in the "other-modules" section.
