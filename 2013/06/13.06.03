00:09:55 <Nisstyre-laptop> Anyone want to code golf the function Functor f => a -> f b -> f a -> f b ?
00:11:03 <Ralith> Nisstyre-laptop: f _ x _ = x
00:11:04 <Peaker> Is there some module with all the Control.Monad combinators' Applicative versions when appropriate? e.g: filterM
00:11:25 <Nisstyre-laptop> Ralith: withou requiring explicit type annotations?
00:11:28 <Nisstyre-laptop> *without
00:11:40 <Ralith> Nisstyre-laptop: that does not require an explicit type annotation
00:11:53 <Nisstyre-laptop> @type f _ x _ = x
00:11:54 <lambdabot> parse error on input `='
00:12:04 <Nisstyre-laptop> @type \f _ x _ -> x
00:12:05 <lambdabot> t -> t1 -> t2 -> t3 -> t2
00:12:07 <johnw> @djinn a -> f b -> f a -> f b
00:12:07 <lambdabot> f _ a _ = a
00:16:15 <Nisstyre-laptop> Ralith: I want "\f x -> join $ f <$> x" but without the Monad instance
00:17:05 <shachaf> Nisstyre-laptop: ?
00:17:14 <shachaf> That's (=<<). You need Monad.
00:17:45 <Ralith> Nisstyre-laptop: join is not defined on functors.
00:18:08 <Nisstyre-laptop> Ralith: ok
00:21:08 <Aetherspawn> :t ask
00:21:09 <lambdabot> MonadReader r m => m r
00:21:36 <Aetherspawn> :t runReaderT
00:21:37 <lambdabot> ReaderT r m a -> r -> m a
00:22:08 <Aetherspawn> How do I get rid of the m from MonadReader r m => m r so I just have r?
00:23:51 <yitz> Aetherspawn: what do you mean "get rid of"?
00:24:23 <Aetherspawn> I want to get just the thing in the ReaderT
00:24:32 <Aetherspawn> without whatever monad I might be in attached
00:24:35 <Aetherspawn> is that possible?
00:24:39 * BMeph_ now wants to get rid of that pesky String in those IO String types...
00:25:13 <yitz> Aetherspawn: you write a function that does a calculation "inside the monad", i.e., returns a value whose type is in the monad
00:25:46 <shachaf> First of all, forget about ReaderT. Just think about Reader.
00:26:06 <shachaf> You're after a function :: Reader r r -> r?
00:26:11 <Peaker> @type let filterM p [] = pure [] ; filterM p (x:xs) = (\pr rxs -> if pr then x:rxs else rxs) <$> p x <*> filterM p xs in filterM
00:26:13 <lambdabot> Applicative f => (a -> f Bool) -> [a] -> f [a]
00:26:27 <yitz> Aetherspawn: then, somewhere else, you pass your calculation to the function "runReader" together with the read-only state you want (in the case of the Reader monad) and the result is a non-monadic value.
00:26:58 <Aetherspawn> Hmm
00:27:15 <Aetherspawn> :t (ask >>= runReaderT)
00:27:16 <lambdabot>     Occurs check: cannot construct the infinite type:
00:27:16 <lambdabot>       r0 = ReaderT r0 m0 a0
00:27:16 <lambdabot>     When using functional dependencies to combine
00:27:39 <yitz> Aetherspawn: if you are asking about how you access the value of an intermediate calculation whose result is in the monad, and use it for something else; then use "do" notation, and bind the value of the intermediate calculation to a variable.
00:30:04 <Aetherspawn> shachaf, sorry for not answering that, I didn't think the 2 r's was correct in the type
00:30:21 <shachaf> Forget about ReaderT. Understand Reader first.
00:30:29 <shachaf> Reader means a function.
00:30:40 <shachaf> The type of ask is "Reader r r".
00:30:52 <shachaf> That's like the function id, :: r -> r
00:32:11 <isomorphic> c_wraith: I don't think I'm after  (String -> String) -> Sample String -> Sample String --   the idea is to be able to map a single function - in the example toUpper - to each of the members of a data type
00:33:43 <shachaf> Do you understand that? If not you should focus on figuring out Reader.
00:35:05 <Aetherspawn> I know that Reader is immutable and I think I know how to use it but I don't really think I understand what you were talking aobut up there
00:37:07 <Peaker> Aetherspawn, data Reader r a = Reader { runReader :: r -> a }    instance Monad (Reader r) where return x = Reader $ \_ -> x   Reader action >>= f = Reader $ \r -> runReader (f (action r)) r
00:37:33 <Peaker> Aetherspawn, ask :: Reader r r    ask = Reader id
00:37:49 <Peaker> Aetherspawn, It's important to understand that before using Reader or going on to understand ReaderT
00:38:05 <unlink> I'm getting this error when indenting after a line starting with a symbol with a recent version of haskell-mode: haskell-trim: Wrong type argument: arrayp, nil
00:41:48 <isomorphic> How can I make ghci print the fixity for function application?
00:42:13 <shachaf> "fixity for function application"?
00:43:24 <isomorphic> shachaf: I am trying to figure out the order of operations for a . b c  - So I'm trying to figure out whether (.) or the function application of b on c apply first
00:43:34 <isomorphic> :i (.) gives me infixr 9
00:44:14 <Nisstyre-laptop> isomorphic: associativity and precedence
00:44:32 <shachaf> isomorphic: Function application is "stickier" than any operator.
00:45:00 <elliott> except record syntax.
00:45:10 <Peaker> isomorphic, function application is infixl 10
00:45:18 <Peaker> (sort of)
00:49:23 * hackagebot warp-tls 1.4.1.1 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.4.1.1 (MichaelSnoyman)
00:49:50 <Grae> I'm compiling an old haskell program and it seems function getArgs is in hidden module haskell98-2.0.0.1. anyone know how to get getArgs working?
00:50:04 <shachaf> haskell98 is a package, not a module
00:50:30 <shachaf> The hidden module is probably called something like "System". You should show the full error message!
00:50:47 <shachaf> Anyway, Hoogle (http://haskell.org/hoogle/) is a good way to find these sorts of things.
00:50:52 <shachaf> @hoogle getArgs
00:50:52 <lambdabot> System.Environment getArgs :: IO [String]
00:50:52 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
00:51:08 <Grae> Error message is: cnf1.hs:656:13: Not in scope: `getArgs'
00:52:24 <Grae> I found System, but it seems it is hidden in a deprecated package - haskell98-2.0.0.1
00:52:38 <shachaf> Correct. The module getArgs is in has a new name.
00:52:56 <Aetherspawn> :t lift
00:52:57 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
00:52:58 <Grae> What name would that be?
00:53:03 <isomorphic> Nisstyre-laptop, elliott, Peaker: thanks :)
00:53:15 <shachaf> Hoogle can tell you what it is (in fact lambdabot already said the name in this channel).
00:54:08 <Grae> I think I see it. Trying it out now.
00:56:43 <Grae> It seems to work. Last time I got this thing going I had trouble with big inputs. Let's hope it can be fixed. Thankyou all.
00:59:42 <dhun> I am looking for a regular expression library that takes functions as arguments for regex substituions
01:00:37 <dhun> like this: newtext = subsitute regex replacerfunction text
01:00:54 <dhun> where repalcerfunction needs to do IO
01:01:20 <dhun> and modify state
01:02:18 <nan`> is there a prelude func for compose2 g f x y = f x (g y)
01:03:33 <Ralith> :t (.).(.)
01:03:34 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
01:03:49 <nan`> also is there a generalized way to compose out like that, not applicative since applicative results only take 1 arg
01:04:00 <nan`> (.).(.) is different right
01:05:04 <nan`> (.).(.) transforms the result of binary function
01:08:42 <Jaxan> @pl \g f x y -> f x (g y)
01:08:42 <lambdabot> flip (flip . ((.) .))
01:08:54 <isomorphic> I'm trying to transform elements in a data type Sample (http://hpaste.org/89212) using a function (map . toUpper).  Is there a cleaner way to do this?
01:09:39 <shachaf> isomorphic: Weren't you making Sample parameterized earlier?
01:10:29 <isomorphic> shachaf:  No.  Same problem - I'd thought making a functor instance was the right solution, but it's not that kind of problem.  I know Sample will have a heap of members that are strings
01:10:51 <isomorphic> Is there a better way of writing applyToEach?
01:11:21 <shachaf> Not especially, if you're after that one function.
01:11:51 <shachaf> If you wanted you could make a "traversal" -- Applicative f => (String -> f String) -> Sample -> f Sample
01:12:12 <shachaf> That's a more general function -- when f=Identity you get applyToEach, but you can also have monadic effects etc.
01:12:40 <shachaf> @ty both
01:12:41 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
01:12:54 <shachaf> > over both (map toUpper) ("hello","hi")
01:12:55 <isomorphic> I'm not sure we're solving the same problem.  What I'm aiming to do is not rewrite applyToEach if I added cn, dn, en to sample
01:12:56 <lambdabot>   ("HELLO","HI")
01:13:00 <shachaf> Ah.
01:13:22 <shachaf> Well, you could do it with some TH. But that's not nice.
01:13:30 <shachaf> Making it parameterized would let GHC do it.
01:13:32 <dhun> ok I came to the concultion that I will try to apply the ParsecT monad transform to IO
01:13:32 <nan`> Jaxan: what is @pl
01:13:40 <shachaf> Are you quite sure you don't want to parameterize it? String is such an ugly type.
01:13:45 <Jaxan> nan`: pointless
01:13:46 <nan`> @pl \x -> 2
01:13:46 <lambdabot> const 2
01:14:01 <nan`> oh
01:14:14 <nan`> nice
01:14:21 <no-n> @pl \x -> const 2
01:14:21 <lambdabot> const (const 2)
01:14:46 <isomorphic> shachaf:  Actually, I'm not sure ;)   How would I write applyToEach for a parameterized version of Sample?
01:14:53 <shachaf> fmap
01:15:04 <shachaf> (And GHC can derive Functor instances.)
01:15:43 <isomorphic> shachaf:  Hahaha.   ^^^^ somewhere up there i thought that then thought I had the wrong approach because of the need for a parameter
01:16:19 <shachaf> It might be wrong, it might be right. Who knows.
01:18:26 <isomorphic> shachaf:  Oddly enough, that compiles.
01:18:37 <isomorphic> shachaf:  Thanks :)
01:22:21 <nan`> Applicative over functions is composition of the results of composition, hehe
01:23:59 <nan`> where the first composition with pure is just normal composition, since the arg is thrown away
01:24:34 <nan`> what an odd thing
01:25:24 <agocorona> I invented a new operator:  |=>>>==**>>
01:25:34 <agocorona> Just kidding
01:25:44 <osfameron> sometimes I do think unicode for haskell isn't such a bad idea
01:25:47 <elliott> is that you, edwardk?
01:26:13 <quchen> agocorona: It's less than 20 characters, hence it's on Hackage already. Import it qualified?
01:26:47 <agocorona> quchen: hehe
01:36:55 <isomorphic> Is there a function that does (Text -> Text) -> (String -> String)  to avoid doing pack/unpack ?
01:40:22 <tdammers> isomorphic: don't know, but it'd be a one-liner
01:40:27 <shachaf> It's hard to avoid doing the pack/unpack in general, because functions might do all sorts of Array-y things on the Text.
01:40:35 <shachaf> Oh, you just mean for convenience, not for performance?
01:40:54 <isomorphic> shachaf:  Yup, convenience
01:41:13 <shachaf> lens has "over packed"
01:41:29 <shachaf> @ty over Data.Text.Lens.packed
01:41:31 <lambdabot> Data.Text.Lens.IsText b => (b -> b) -> String -> String
01:41:35 <shachaf> @ty over Data.Text.Strict.Lens.packed
01:41:36 <lambdabot> (Data.Text.Internal.Text -> Data.Text.Internal.Text) -> String -> String
01:42:02 <isomorphic> That looks about right :)
02:04:44 <agocorona> someone has an example of why the overhyped lens concept is so useful? Is it something more than fashion?
02:05:39 <shachaf> You don't seem to be in a receptive frame of mind.
02:05:40 <agocorona> let provoke= True
02:06:03 <elliott> please don't do that.
02:06:05 <shachaf> agocorona: Please don't troll in here.
02:06:19 <agocorona> No, sorry. It is a serious question
02:06:30 <agocorona> formulated in a amusing way
02:07:30 <elliott> it's useful for more or less what it's hyped for. you might like to read the stuff on http://lens.github.com/ or watch the video of edwardk's talk.
02:07:55 <elliott> (and "lens" is misleading; it is a family of concepts, of which lenses are just one, and probably traversals are closer to being a core concept than lenses are.)
02:07:58 <agocorona> I read both. but i don´t find it compelling
02:08:08 <elliott> ok. that's fine
02:08:23 <elliott> the expressivity is compelling enough reason for me
02:11:46 <merijn> Lenses are good for what lenses are good for. If you don't write code that benefits from lenses, don't use them? :>
02:12:08 <agocorona> elliott: right, it is expressive but I had the impression that I missed something.
02:12:42 <Kinnison> For me, every time I look at lenses I think "oooh I want this shiny" and then I forget to use them in code.
02:12:53 <Kinnison> :-(
02:12:57 <Kinnison> Then I wish I had.
02:13:13 <elliott> well, lenses themselves are fairly boring. combined with prisms they're a clear win in terms of concision and boilerplate removal, but it's when you add traversals and folds to the mix that they do more than that, by letting you express complex computations, reductions, modifications and so on just by composing them al.
02:13:18 <elliott> *all
02:13:39 <elliott> they're essentially a very general form of what you'd write as a loop with mutation in an imperative language.
02:14:17 <elliott> and you also get a unified, efficient API for many of the (de facto) standard container types, etc.
02:18:34 <agocorona> I have seen the zipper concept come an go. It is basically intended for the same purpose. Let´s see in the future what happens
02:18:54 <elliott> agocorona: lens has a zipper.
02:18:57 <elliott> or, well.
02:19:10 <elliott> it did. I guess it's split out into another package now, but it's a generic one based on the lens machinery.
02:19:22 <elliott> they're not really comparable, though.
02:19:38 <merijn> Also, what do you mean come and go? Zippers are still great...
02:21:20 <agocorona> They are not used as much as was expected
02:24:07 <merijn> What do you mean "as expected"?
02:25:00 <merijn> Just because they're great doesn't mean they're used a lot
02:25:16 <merijn> Vice versa, just because things are used a lot doesn;t mean they're great
02:27:22 <DigitalKiwi> look at php ;p
02:27:30 <DigitalKiwi> no don't you might claw your eyes out
02:27:39 <DigitalKiwi> but you know what i mean
02:29:02 <agocorona> may be. many great things have small niches.
02:29:24 <agocorona>  I just wanted to know if I missed something about lenses
02:29:34 <alexander__b> woah wtf. just compiled my first haskell program (hello, world) and it's 1.1MiB. o_O
02:29:46 <merijn> alexander__b: GHC using static linking by default
02:29:56 <merijn> s/using/uses
02:30:38 <alexander__b> merijn: ugh.
02:31:10 <merijn> alexander__b: http://stackoverflow.com/questions/6115459/small-haskell-program-compiled-with-ghc-into-huge-binary
02:31:18 <merijn> You say ugh
02:31:38 <merijn> Wait until you spend 2 weeks of the past 2 months debugging shared library/linking issues like me.
02:31:44 <merijn> <3 static linking
02:31:58 <elliott> I have lots of megabytes on my hard drive
02:32:33 <alexander__b> merijn: static linking is something I have grown to hate just as much as software like pip, gems and cabal.
02:32:46 <merijn> elliott++
02:32:54 <merijn> Static linking is best linking!
02:32:59 * DigitalKiwi uses tinyghc for all his haskell packages so that they are faster~
02:33:05 <bitonic> alexander__b: it’s not rare for Haskell executables to be 50+MBs.  linking takes a lot on my little server :P
02:33:05 <DigitalKiwi> and smaller
02:33:10 <DigitalKiwi> :|
02:33:18 <elliott> you can use dynamic linking with GHC.
02:33:23 <elliott> note: static linking in GHC is only with haskell libraries
02:33:24 <merijn> alexander__b: I keep running into the cabal hate and I never understand why...I never run into issues
02:33:29 <elliott> the C libraries are linked dynamically
02:33:50 <alexander__b> merijn: my environment already has a package manager. it doesn't need 1 per language as well...
02:34:05 <DigitalKiwi> http://www.reddit.com/r/archlinux/comments/1ddb14/compiling_without_gcc/ to get the joke i just made read that
02:34:22 <merijn> alexander__b: Don't blame cabal if your package manager doesn't play nice with other tools...
02:34:51 <merijn> DigitalKiwi: Is the punchline "archlinux"? :)
02:34:52 <alexander__b> merijn: the point is that it does package management. I don't need more package managers. I already have one.
02:35:02 <bitonic> alexander__b: you know, I’d tend to agree with you, but it would be pointless to try have a distro package manager to keep up with cabal
02:35:09 <merijn> cabal doesn't do package management
02:35:17 <merijn> It does dependency resolution
02:35:25 <alexander__b> which a package manager does.
02:36:03 <DigitalKiwi> no the punchline is the guy wanted to compile everything on his system with tcc so that he would have smaller binaries
02:36:42 <alexander__b> why not just -Os? works well enough for embedded systems afaik.
02:36:43 <merijn> So just insall everything with your package manager and blame them if things break?
02:37:02 <alexander__b> merijn: it doesn't break. ;-)
02:37:17 <merijn> Then what's causing you to hate cabal? :P
02:37:32 <DigitalKiwi> archlinux used to do really well with haskell packages
02:37:34 <merijn> DigitalKiwi: Oh, I never take the Arch fanatics to serious anyway
02:37:35 <DigitalKiwi> i wonder if it still does
02:37:54 <DigitalKiwi> they had a lot of them in repos
02:38:08 <alexander__b> merijn: I think the whole idea is stupid. hey I hurd u liek package managers so I maded u a package manager to put in ur package manager...
02:38:10 <merijn> I (optimistically) hope they're trolling, but I can never really be sure whether they're not serious
02:38:26 <merijn> alexander__b: You do realise not everyone uses your OS, right?
02:38:33 <DigitalKiwi> i think there are even some tools to make packages for pacman with cabal
02:39:02 <elliott> this discussion is pointless.
02:39:09 <merijn> Yeah, I need to go back to work
02:39:49 <alexander__b> merijn: what does that have to do with anything? Linux isn't what's doing the package management. Portage is. or, Ports or Synaptics or whatever. IDK of any systems (that people actually use) that can't use either of those. of course Windows people tend to not use them, though they could...
02:40:43 <osfameron> so then haskell module authors have to maintain their module for X different package management toolchains?
02:40:46 <DigitalKiwi> wait what
02:40:53 <merijn> alexander__b: I use OSX, I don't use any of those systems, nor do I care to. Anyway this is pointless discussion as elliott points out, so I'm going back to work
02:40:54 <alexander__b> osfameron: downstream does that
02:41:05 <alexander__b> merijn: OSX has Ports.
02:41:07 <DigitalKiwi> a linux package manager on windows i think would not work very well
02:41:14 <DigitalKiwi> standard*
02:41:15 <merijn> alexander__b: So? I don't use it
02:41:21 <alexander__b> DigitalKiwi: Portage works well enough with Gentoo Prefix.
02:41:24 <shachaf> alexander__b: What is your goal in this dicussion?
02:41:27 <elliott> merijn: you're not working :P
02:41:29 * DigitalKiwi realizes cygwin has a package manager
02:41:34 <osfameron> alexander__b: "downstream"?
02:41:35 <alexander__b> shachaf: merijn asked. I answer...
02:41:39 <DigitalKiwi> what is gentoo prefix?
02:41:41 <alexander__b> osfameron: package maintainers.
02:41:44 <shachaf> merijn was going back to work.
02:41:57 <merijn> shachaf: I wish >.>
02:42:05 <osfameron> alexander__b: that sounds slow and inconvenient.
02:42:06 <DigitalKiwi> merijn: you had an out
02:42:07 <alexander__b> DigitalKiwi: a method of installing Gentoo to any system.
02:42:09 <shachaf> alexander__b: If you want to use your system's package manager for managing Haskell packages, you are welcome to do so. Debian packages Haskell libraries, no problem.
02:42:12 <DigitalKiwi> you could have dodged this discussion
02:42:13 <alexander__b> osfameron: has worked for quite a few years.
02:42:14 <DigitalKiwi> you ruined it
02:42:19 <DigitalKiwi> good job
02:42:20 <DigitalKiwi> ;p
02:42:30 <shachaf> If you want to get everyone to stop using cabal because you have Portage, and talk about how the whole idea is stupid, this channel is not really the place for it.
02:42:35 <alexander__b> shachaf: I have no problems not using cabal. merijn asked why I didn't like it. I said why.
02:42:45 <DigitalKiwi> alexander__b: but then it's no longer windows...
02:42:48 <shachaf> OK.
02:43:19 <alexander__b> DigitalKiwi: yes, you just have Gentoo inside of it. it works well, afaik. I don't use windows though.
02:44:25 <alexander__b> wow. the difference between -dynamic and not -dynamic was... not small.
02:45:08 <DigitalKiwi> alexander__b: is it like a chroot or a vm?
02:45:53 <alexander__b> DigitalKiwi: it's the same as installing any software using PREFIX=/some/directory make install.
02:46:48 <alexander__b> on Windows you need to use Interix though since Windows is... different.
02:47:12 <alexander__b> (or rather, *it* uses interix, I don't think you have to do anything too daunting manually)
03:08:50 <latermuse> why doesnt this code print the "Hi"?
03:08:57 <latermuse> > (\_ -> putStrLn "Hi") <$> putStrLn "world"
03:08:58 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO (GHC.Types.IO ())))
03:08:58 <lambdabot>    arising...
03:09:29 <shachaf> Because lambdabot doesn't do IO. Also because values and effects are two separate things.
03:09:47 <latermuse> well in my GHCI, it just prints "world"
03:09:48 <Cale> latermuse: First of all, do you know what type that action has?
03:10:01 <Cale> (think about it a moment before asking ghci)
03:10:21 <latermuse> shouldnt that first part: "(\_ -> putStrLn "hi")" print "hi" regardless of whatever is input to it?
03:10:44 <Cale> We'll get to that
03:10:54 <latermuse> ok
03:11:04 <latermuse> that action should have IO () type
03:11:07 <Cale> nope
03:11:17 <latermuse> t -> IO ()
03:11:38 <Cale> (<$>) :: (Functor f) => (a -> b) -> f a -> f b
03:11:44 <Cale> in this case, f = IO
03:11:44 <alexander__b> I'm a bit confused; why do I need to use '$' when using a function with putStrLn?
03:11:53 <alexander__b> > putStrLn "lo" ++ " bob"
03:11:54 <lambdabot>   Couldn't match expected type `[a0]'
03:11:54 <lambdabot>              with actual type `GHC.Type...
03:11:59 <alexander__b> > putStrLn $ "lo" ++ " bob"
03:12:00 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
03:12:00 <lambdabot>    arising from a use of ...
03:12:05 <latermuse> (\_ -> putStrLn "Hi") <$> putStrLn "world" :: IO (IO ())
03:12:07 <alexander__b> err oh. but you get the point.
03:12:09 <Cale> alexander__b: function application binds more tightly than any infix operator
03:12:16 <elliott> alexander__b: that's (putStrLn "lo") ++ " bob".
03:12:18 <Cale> latermuse: That's right
03:12:23 <alexander__b> aha.
03:12:24 <elliott> :t putStrLn ("lo" ++ " bob")
03:12:25 <lambdabot> IO ()
03:12:32 <latermuse> I think i understand
03:12:36 <Cale> latermuse: So the *result* of executing this action is another action.
03:12:41 <latermuse> the first part is an action, but isnt being run
03:12:53 <Cale> latermuse: you could bind that action at the GHCi prompt and later run it:
03:13:02 <Cale> ghci> x <- (\_ -> putStrLn "Hi") <$> putStrLn "world"
03:13:02 <Cale> world
03:13:03 <Cale> ghci> x
03:13:03 <Cale> Hi
03:13:36 <latermuse> oh
03:13:39 <shachaf> do { _ <- putStrLn "world"; return (putStrLn "Hi") } -- another way to write the thing you wrote
03:13:48 <shachaf> do { _ <- putStrLn "world"; putStrLn "Hi" } -- compare to this
03:13:49 <latermuse> so the "world" is just a sideeffect, but doesnt get saved into the action to be called later
03:14:23 <latermuse> I understand now
03:14:25 <Cale> If you want to call it a side effect... it's an effect of executing your action anyway
03:14:45 <Cale> and the result is another action whose effect is to print Hi
03:15:14 <latermuse> thank you cale, that makes sense
03:15:22 <shachaf> So you can always float joins outside and then turn (join . fmap join) into (join . join) to right-reässociate things
03:15:23 <Cale> Another thing which is worth noting is the type of the parameter to the lambda
03:15:30 <Cale> which in this case is ()
03:15:53 <latermuse> what does the lambda do with that?
03:15:54 <Cale> Because that lambda is taking the result of  putStrLn "world"  as its argument.
03:16:14 <Cale> (which in this case is uninteresting, but in general need not be)
03:16:41 <Cale> ghci> x <- (\s -> putStrLn s) <$> getLine
03:16:42 <Cale> hello
03:16:42 <Cale> ghci> x
03:16:42 <Cale> hello
03:16:42 <jdnavarro> is there any function ready to use function in the Haskell platform to get the size in bits of a number? i.e: (12345 :: Integer) = 14
03:17:03 <elliott> @hoogle bitSize
03:17:03 <lambdabot> Data.Bits bitSize :: Bits a => a -> Int
03:17:04 <jdnavarro> bitSize from Data.Bits raises an exception when I try it
03:17:12 <elliott> oh, I guess for Integer it will.
03:17:19 <Cale> That's because Integer is unbounded in size
03:17:24 <luite> jdnavarro: perhaps you want a base 2 logarithm
03:17:31 <Cale> > logBase 2 12345
03:17:32 <lambdabot>   13.591639216030146
03:17:38 <Cale> > ceiling (logBase 2 12345)
03:17:39 <lambdabot>   14
03:17:52 <latermuse> thanks cale!
03:17:54 <Cale> > ceiling (logBase 2 (fromIntegral (12345 :: Integer)))
03:17:55 <lambdabot>   14
03:18:04 <shachaf> No, Floating logBase is almost certainly not what you want.
03:18:10 <jdnavarro> Cale, great! thanks!
03:18:20 <luite> there's an integer-specific log
03:18:30 <t7> Int or Integer?
03:18:30 <Cale> Well, yeah, you'd probably be better off with a proper rounding base 2 log for integers.
03:18:33 <shachaf> This code is going via Double.
03:18:35 <Cale> Or ceiling-ing
03:18:52 <Cale> It won't work for very large numbers
03:19:13 <Cale> > logBase 2 (fromIntegral (product [1..1000] :: Integer))
03:19:14 <lambdabot>   Infinity
03:19:22 <shachaf> @hackage bits might have code for you
03:19:23 <lambdabot> http://hackage.haskell.org/package/bits might have code for you
03:19:35 <luite> hmm, integerLog2# in GHC.Integer.Logarithms would work, but it has the scary-hash
03:19:37 <shachaf> But maybe it won't work on Integers either.
03:19:55 <jdnavarro> I'm dealing with Integer only in this case
03:20:14 <shachaf> You could always write it yourself, especially if efficiency isn't crucial.
03:20:20 <Cale> > length . takeWhile (/= 0) . iterate (`div` 2) $ (product [1..1000])
03:20:21 <lambdabot>   8530
03:20:27 <Cale> > length . takeWhile (/= 0) . iterate (`div` 2) $ 12345
03:20:28 <lambdabot>   14
03:20:36 <shachaf> Something like that, yes.
03:21:47 <shachaf> > let hb = go 0 where { go !a 0 = a; go !a n = go (a+1) (n `shiftR` 1) } in hb 12345
03:21:48 <lambdabot>   14
03:22:51 <t7> > let log2 x = fromJust $ find (>= x) [1..] in log2 1337
03:22:53 <lambdabot>   1337
03:23:01 <t7> hang on a minute
03:23:32 <t7> > let log2 x = fromJust $ find ((>= x) . (/ x)) [1..] in log2 1337
03:23:34 <lambdabot>   1787569.0
03:23:40 <t7> nope hang on
03:24:03 <merijn> 3 hours later...
03:24:12 <t7> > let log2 x = fromJust $ find ((>= x) . (^ 2)) [1..] in log2 1337
03:24:14 <lambdabot>   37
03:24:23 <pavid> lambdabot: 42
03:24:41 <alexander__b> what would be a way to do the equivalent for(;;) printf("blah\n"); in haskell?
03:25:08 <Cale> alexander__b: forever $ putStrLn "blah"
03:25:09 <typoclass> alexander__b: i'd use 'forever'
03:25:10 <merijn> :t forever
03:25:11 <lambdabot> Monad m => m a -> m b
03:25:15 <alexander__b> forever haha. that's great.
03:25:24 <t7> > let log2 x = fromJust $ find ((>= x) . (2 ^)) [1..] in log2 1337
03:25:25 <Cale> #define ever (;;)
03:25:25 <lambdabot>   11
03:25:26 <pavid> LOL
03:25:28 <t7> yey :D
03:25:32 <jdnavarro> I already have a converter from Integer to a string of '1' and '0' using functions from Numeric, I was thinking about just getting the length of the resulting string, will that be much less efficient?
03:25:55 <pavid> I'm working with a framework for software-defined radios
03:25:55 <merijn> jdnavarro: Provided you don't get ridiculously large numbers that should be fine
03:25:57 <pavid> and I was thinking
03:26:00 <Cale> jdnavarro: Shouldn't be too bad
03:26:07 <latermuse> pavid: what kind of radio?
03:26:08 <pavid> how well would Haskell work in such an application?
03:26:18 <merijn> jdnavarro: It kinda depends on how big you expect the numbers to get and how frequently you compute it?
03:26:23 <pavid> I feel like, if applied correctly, it would be great.
03:26:27 <pavid> USRPs
03:26:33 <pavid> I'm using GNU Radio
03:26:33 <shachaf> Haskell is a general-purpose language.
03:26:47 <pavid> which glues together Python and C++ signal blocks.
03:26:49 <jdnavarro> I guess no more than 1000 bits
03:27:31 <jdnavarro> wait, actually no longer than 300 bits
03:27:42 <shachaf> jdnavarro: Write the function, profile your code later.
03:27:45 <pavid> Actually, I'm not sure what advantage haskell would give you in such a system.
03:27:50 <typoclass> pavid: you should give it a try! here is a good introduction to haskell, available for free
03:27:52 <typoclass> @where lyah
03:27:53 <lambdabot> http://www.learnyouahaskell.com/
03:28:05 <jdnavarro> shachaf, yeah, I'll do that
03:28:24 <latermuse> I wrote a radio in haskell, currently using it to broadcast a few music stations
03:28:37 <shachaf> luite's # function would probably be the fastest that you could easily come up with.
03:29:00 <latermuse> maybe not the kind of radio you are looking for though
03:31:36 <gspr> pavid: You mean like the stuff librtlsdr does?
03:33:19 <merijn> Any vim users that have a good code folding plugin for haskell? I'm not happy with my current one, and before I invest the time to write a better one I thought I'd check what you guys are using
03:35:34 <finnrobi> I am getting a little frustrated by a compilation error I'm getting - couldn't match "`Data.ByteString.Internal.ByteString` with actual type bytestring-0.9.2.1:Data.ByteString.Internal.ByteString`". What's the typical cause of this? Is my cabal installation broken, do I depend on two different versions of bytestring or something else entirely?
03:36:16 <elliott> finnrobi: your packages are broken. two different versions of bytestring are being used. chaos in the streets
03:36:32 <elliott> I get royalties if I link to monochrom's article now.
03:36:33 <elliott> @where sicp
03:36:34 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml | "Storage and Identification of Cabalized Packages"
03:36:39 <elliott> the third one.
03:36:45 <finnrobi> thank you
03:36:46 <elliott> but the short term solution is probably just to uninstall all the packages.
03:36:54 <shachaf> @where+ sicp.xhtml http://www.vex.net/~trebla/haskell/sicp.xhtml
03:36:55 <lambdabot> Done.
03:37:21 <typoclass> finnrobi: have you tried 'ghc-pkg check'?
03:39:06 <bitonic> we should add ‘ghc-pkg nuke’, which deletes .ghc and .cabal
03:39:12 <shachaf> @where+ sicp.xhtml /me . o O ( "Storage and Identification of Cabalized Packages" by Albert Y. C. Lai at <http://www.vex.net/~trebla/haskell/sicp.xhtml> )
03:39:13 <lambdabot> It is forever etched in my memory.
03:39:20 <shachaf> There we go.
03:39:42 <bitonic> or ‘ghc-pkg repair’, which also deletes .ghc and .cabal
03:40:18 <finnrobi> does there exist something like virtualenv for haskell? as in, could I have a completely isolated set of packages / cabal installation that go together so I don't muck up my user packages?
03:40:42 <bitonic> finnrobi: cabal-env, or ‘cabal sandbox’
03:40:47 <bitonic> is cabal sandbox out yet?
03:42:29 <supki> finnrobi: cabal-dev or hsenv
03:42:43 <supki> (not sure what cabal-env is)
03:43:40 <charliesome> hi #haskell! I have a Money type with a constructor 'Money Int'. I want to implement the Read typeclass, but when I write 'deriving Read', it expects something like "(Money 123)". Is there a way I can have Money's read just use Int's read?
03:46:39 <bitonic> charliesome: yes, you can write the Read instance explicitely
03:47:03 <charliesome> bitonic: can you give me an example
03:47:04 <charliesome> ?
03:47:33 <bitonic> charliesome: do you know how to write type classes instances?  or are you having problems with this instance specifically?
03:47:44 <charliesome> bitonic: just this one specifically
03:48:01 <charliesome> i see i have to implement readsPrec but it seems overly complex for what i'd like
03:48:10 <bitonic> charliesome: OK.  so what you want to do is to use Int’s ‘readsPrec’, and then just wrap the result in ‘Money’
03:48:12 <merijn> bitonic: Except that .cabal is empty on some platforms :p
03:48:20 <m3ga> writing a read instance is a bit tricky for a beginner. maybe you should just use a function : readMoney = Money . read
03:48:47 <Six> hey there, is there any way in haskell to use something like a variable in any form?
03:49:18 <merijn> Hell, I think writing manual read instances is tricky and I no longer consider myself a beginner :p
03:49:27 <Taneb> Six, by what you mean by variable, the answer is "Yes, but you don't need to and probably don't want to"
03:49:31 <Six> i have a function with 2 recursive calls which depend on a value, so the value of the first recursion should be used in the second call
03:49:38 <bitonic> m3ga: it’s really not that tricky
03:49:48 <charliesome> m3ga: yeah i'm thinking i might go that way, but i'd like to do it 'properly'
03:50:03 <m3ga> bitonic: i've done it a couple of times now, but the first time was painful
03:50:22 <Taneb> Six, make the value they depend an an argument to the function
03:50:24 <merijn> Six: "foo x = foo (foo x)"?
03:50:46 <Six> it looks like that "rec (REPEAT i rprg) prest n = let b = (drop 1 prest) in repeat_beg i n  ++ rec (rprg!!0) rprg (n+500) ++ repeat_end n ++ rec (b!!0) b (n+2)"
03:51:02 <bitonic> charliesome: if you ask more specific question here I’ll help—you heave a ‘Int -> String -> [(Int, String)]’ (Int’s ‘readsPrec’) and you want a ‘Int -> String -> [(Money, String)]’
03:51:09 <Six> the n which results in the first rec call should be used at the second call
03:51:42 <Six> my idea was to change the type of my function from [] to ([], Int)
03:51:46 <Six> but that got kinda messy
03:51:56 <merijn> It's kinda messy already, tbh
03:51:58 <charliesome> bitonic: i'll have a crack, thanks
03:52:00 <Six> :/
03:52:22 <merijn> Six: Maybe split it into multiple lines with some helpers and paste the result on hpaste?
03:52:31 <bitonic> charliesome: so you can start with ‘readsPrec n s = let ns = readsPrec n s in ...’, where ‘ns :: [(Int, String)]’
03:53:15 <merijn> Six: The answer to any convoluted function is always "add more helpers" :>
03:53:22 <charliesome> bitonic: i have: readsPrec someInt str = map (\(i, s) -> (Money i, s)) (readsPrec someInt str :: [(Int,String)])
03:53:41 <bitonic> charliesome: that looks good—you don’t even need the type annotation
03:53:53 <charliesome> aw cool
03:54:21 <Six> what do you mean by "helpers"?
03:54:35 <weebl> can haskell be used for using monotone frameworks
03:54:38 <weebl> can haskell do that
03:54:54 <merijn> Six: Small functions that do part of the work
03:54:57 <bitonic> @faq can Haskell be used for monotone frameworks?
03:54:57 <lambdabot> The answer is: Yes! Haskell can do that.
03:55:09 <weebl> bitonic: that was the function i was looking for
03:55:10 <weebl> ;-)
03:55:12 <supki> @faq can haskell do that?
03:55:12 <lambdabot> The answer is: Yes! Haskell can do that.
03:55:16 <bitonic> weebl: do you mean for static analysis?  e.g. with a lattice?
03:55:28 <weebl> bitonic: yes but i was just trying to get the bot to respond ;x
03:55:44 <Cale> lol
03:56:03 <bitonic> anyway the book I was using for monotone framewors pretty was written in a very functional style, so Haskell can definitely do that :P
03:56:47 <bitonic> I don’t know where the ‘pretty’ came from.
03:57:04 <merijn> bitonic: "pretty much" ?
03:57:10 <merijn> bitonic: Or just a brain fart
03:57:15 <bitonic> oh.  maybe yeah
03:57:31 <bitonic> I get this stuff all the time lol
03:59:05 <Bor0> why won't this compile? http://pastebin.com/juWNHzED
03:59:15 <mauke> The paste juWNHzED has been copied to http://hpaste.org/89225
04:00:51 <typoclass> Bor0: hello. in haskell, function application is written as "f 123". in other languages, it might be "f(123)"
04:01:03 <typoclass> Bor0: here is an introduction to haskell:
04:01:06 <typoclass> @where lyah
04:01:06 <lambdabot> http://www.learnyouahaskell.com/
04:01:54 <gspr> Does anybody know if there have been renewed efforts towards new Qt bindings (high or low level) lately?
04:02:06 <merijn> typoclass: Oh god, the prof teaching the ocaml class I was TA'ing insisted on using tuples for multiple arguments at first so people could write "foo(1,2,3)" when starting out "because it'd make things easier for them" >.>
04:02:11 <bitonic> gspr: there’s a GSOC project about that
04:02:14 <merijn> typoclass: So much confusion later on...
04:02:17 <gspr> bitonic: Nice!
04:02:47 <supki> merijn: ML people like tuples for some reason
04:02:59 <Cale> Bor0: Firstly, the parameters you're supplying to max are (x !! (length x - 1)),   maxlist,   and (init x)
04:03:01 <typoclass> merijn: erm =) that "making things easy" seems very superficial
04:03:01 <Bor0> typoclass: I don't get it, init([1,2,3]) is the same as init [1,2,3]
04:03:07 <alexander__b> in this:
04:03:08 <gspr> bitonic: Ah, a binding generator. Nice.
04:03:09 <alexander__b>   contents <- getContents
04:03:12 <alexander__b>   putStr (map toUpper contents)
04:03:24 <alexander__b> why/how/when/what/the/fsck? how does putStr happen?
04:03:36 <bitonic> supki: because when they first wrote SML code tuples were much more efficient
04:03:42 <bitonic> supki: and it stuck
04:03:43 <alexander__b> according to the explanation contents happens when putStr happens becaues putStr needs contents. well, how does it get to putStr?
04:03:44 <typoclass> Bor0: true. those parens are superfluous
04:03:55 <gspr> bitonic: The student is one Zhengliang Feng. Do you know if he/she is also known under a different handle?
04:03:57 <Cale> alexander__b: getContents is magical
04:04:03 <bitonic> gspr: nope, sorry.
04:04:06 <alexander__b> Cale: I figured.
04:04:26 <merijn> alexander__b: By magical he means "uses lots of "unsafe" voodoo inside" ;)
04:04:46 <gspr> bitonic: OK, thanks for the info though. Is there usually some webpage/mailing list/wiki for the various GSoC projects when they get going?
04:04:49 <Cale> alexander__b: When executed, getContents finishes immediately, and produces a magical String whose evaluation reads from stdin.
04:05:02 <bitonic> gspr: usually students keep a log of some sort
04:05:07 <gspr> ok
04:05:12 <bitonic> but not everybody does that
04:05:27 <gspr> Alright. So it's usually a somewhat closed process while it goes on?
04:05:39 <bitonic> gspr: well there is some sort of report too fairly early on
04:05:41 <bitonic> I think mid july
04:05:48 <merijn> gspr: I think it's as closed as the student and mentor want, I guess?
04:05:49 <gspr> OK. Interesting. I'll keep my eyes open then
04:05:51 <alexander__b> Cale: so uh ^J is some sort of magic command to make the program jump to putStr that whines about not having contents and so getContents uh performs a magic trick and then it's printed?
04:06:12 <Cale> alexander__b: Wait, what?
04:06:13 <Cale> ^J?
04:06:18 <merijn> alexander__b: No, the magic is that getContents pretends to have finished giving you a String while it hasn't
04:06:21 <bitonic> gspr: but I don’t know how public that is either.  you could ask cartazio who sometimes hangs out here and is the supervisor ow that, iirc
04:06:27 <bitonic> mentor, whatever it’s called :P
04:06:35 <alexander__b> merijn: so why does it give me a string when I ^J?
04:06:39 <gspr> Alright. Thanks.
04:06:45 <merijn> alexander__b: stdin is line buffered
04:06:54 <merijn> And so is stdout
04:07:13 <alexander__b> OK so that jumps to the putStr line
04:07:25 <merijn> alexander__b: Try doing "hSetBuffering stdin NoBuffering; hSetBuffering stdout NoBuffering" before running the getContents bit
04:07:37 <Cale> alexander__b: The putStr is already executing by the time you'll have a chance to type any characters
04:07:46 <alexander__b> Cale: oh
04:07:55 <alexander__b> merijn: wat? are those ghci things? because I'm running a compiled program, heh
04:08:08 <merijn> alexander__b: No, they are *nix file IO things
04:08:22 <alexander__b> merijn: which you set where?
04:08:29 <charliesome> is someone able to give me a bit of feedback on this short little program, maybe suggest any ways i could make it more idiomatic? http://eval.in/32578 cheers
04:08:35 <Cale> alexander__b: However, the string which it's trying to print is magic, and when putStr (or map) tries to evaluate it, the evaluation will wait for you to press a key.
04:08:48 <shachaf> gspr: "ofan", I think.
04:09:01 <merijn> alexander__b: By default the stdin/stdout of a process are linebuffered, which means when you do "getChar" you won't actually get a Char until the OS sees you type a '\n' into stdin (or until you exceed some magical buffer size)
04:09:07 <alexander__b> Cale: aha.
04:09:25 <merijn> alexander__b: They're just haskell functions that change the line buffering of stdin/stdout, you run them inside your program
04:09:31 <gspr> shachaf: Thanks! haskellers.com also refers to that handle, so it sounds right.
04:09:48 <alexander__b> merijn: right. I was beginning to think you wanted me to change BASH behaviour.
04:09:53 <shachaf> gspr: See also #haskell-gsoc
04:10:01 <merijn> i.e. "main = do { hSetBuffering stdin NoBuffering; contents <- getContents; putStr (map toUpper contents) }"
04:10:17 <Bor0> wow, maxlist was so simple I overcomplicated it
04:10:21 <merijn> plus the stdout one of course
04:10:57 <Cale> (You'll have to import System.IO)
04:11:18 <merijn> alexander__b: It's just that many people apparently aren't aware of line buffering and how it works, even though Haskell just mimics the buffering behaviour that C/C++/python and pretty much every other language has :p
04:11:33 <merijn> And then they blame haskell for "odd" behaviour
04:12:53 <elliott> IIRC Haskell differs in terms of what happens when you request input
04:13:05 <elliott> by Haskell I mean GHC.
04:13:37 <Cale> If you really get into details, GHC's I/O stuff is all implemented with non-blocking stuff.
04:14:23 <Cale> (so that threads behave sensibly)
04:14:49 <EnglishGent> hi all :)
04:14:55 <Cale> hello
04:15:03 <EnglishGent> hi Cale :)
04:15:44 <EnglishGent> quick question (for anyone!) - is there a way to have a module export an algebraic data type so that code using the module can pattern match against values of that type, but not construct new values of it? :)
04:15:53 <elliott> alas, no
04:16:00 <elliott> but you can maybe use view patterns
04:16:02 <EnglishGent> damn :/
04:16:10 <EnglishGent> what are view patterns? I don't know those
04:16:19 <elliott> well, if you define an abstract data type where you don't export the constructors
04:16:24 <EnglishGent> and hi elliott :)
04:16:28 <elliott> and a concrete data type with the representation you want it to be pattern matched as
04:16:34 <elliott> and then define a function view :: Abstract -> Concrete
04:16:38 <elliott> then view patterns let you say:
04:16:50 <elliott> f :: Abstract -> ...; f (view -> Constr1) = ...; f (view -> Constr2 a b c) = ...
04:16:56 <elliott> where Constr1, Constr2 are constructors of Concrete
04:17:15 <elliott> it's just sugar for f x = case view x of Constr1 -> ...; Constr2 a b c -> ..., but it can lessen the pain of doing this a bit
04:17:22 * EnglishGent nods nods
04:17:31 <EnglishGent> thanks :)
04:18:04 <elliott> :)
04:18:18 <EnglishGent> I confess I'm a little surprised there's no language extension for doing what I asked... is there some fundamental reason why it doesn't exist? or is it just happenstance?
04:19:19 <EnglishGent> (I know various things would make type inference impossible for example... is that one of them?)
04:19:20 <EnglishGent> :)
04:19:55 <elliott> well, it would break symmetry a bit to have patterns you could only use on the left hand side
04:20:01 <elliott> but there's no fundamental reason to disallow it, AFAIK
04:20:49 <EnglishGent> just curious... the world of Haskell's type system is a very deep rabbit hole indeed
04:20:58 <EnglishGent> (at least, it is from my point of view!) :)
04:24:52 <kartlos> sometimes, when I have an if-then-else condition in a do block I don't need the else part, I just want to skip over the then part if the predicate is false, simply leaving out the then part leads to a parse error, are we forced to have an else part always? or are there alternatives?
04:25:11 <hpc> :t when
04:25:11 <Cale> kartlos: when
04:25:12 <lambdabot> Monad m => Bool -> m () -> m ()
04:25:24 <hpc> @src when
04:25:24 <lambdabot> when p s = if p then s else return ()
04:25:32 <Bor0> can I somehow modify the > (or <) operator, to not return Bool but to return some other type?
04:25:36 <kartlos> awesome, thanks!
04:25:43 <hpc> Bor0: no
04:25:48 <Cale> kartlos: You are always required to have an else part in an if-expression, because that expression needs to evaluate to *something* when the condition fails.
04:25:57 <typoclass> kartlos: you can use the 'when' function from Control.Monad. it'll basically do "else return ()". in if-then-else, you always need both branches
04:26:21 <Cale> (there's nothing special about if-then-else when used inside a do-block, unlike the special treatment that 'let' gets)
04:26:48 <hpc> (importantly, this unspecialness includes how if-then-else gets indented)
04:26:50 <kartlos> Cale, typoclass, hpc: thanks :-)
04:29:18 <Bor0> is it possible to redefine this http://hpaste.org/new using church numerals as definition for true and false (instead of using the built-in Bool type)?
04:30:09 <Bor0> http://hpaste.org/89227, sorry
04:31:57 <XexonixXexillion> Bor0: as in true = const and false = flip const ?
04:31:59 <Bor0> that is, instead of having Bool in if', I'd like to have a function (\xy.x or \xy.y), but then the operator > will cause trouble in max', since it returns True
04:32:24 <Bor0> or False, instead of \xy.x or \xy.y
04:34:28 <Bor0> I guess my question is how deep can you go with lambda calculus in haskell regarding definitions
04:34:56 <XexonixXexillion> Bor0: Try defining Y, you'll realise it isn't very far
04:35:59 <Six> so this is how it looks like now: http://hpaste.org/89229
04:38:10 <Six> the REPEAT part in codeGenerierung is making me trouble
04:39:26 <Six> (n+500) is just a small hotfix, but for larger programs with 250+ repetitions this won't work anymore
04:41:12 <quchen> What's the correct way of reading Binary data from a handle? When using ByteString.hGet, I have to specify the length of the input, which is not known prior to (partially) reading it. ByteString.hGetContents closes the handle after reading, but I'd like to keep it open.
04:42:16 <quchen> So what I want is "foo <- Binary.decode <$> ByteString.getEnough h" which reads enough data for one full decoding while leaving the handle open.
04:44:53 <quchen> (Background: It's a server application, and I'm using Binary with a custom type as sort of a protocol to send orders over the network.)
04:45:01 <supki> quchen: why not prepend data with its length?
04:45:32 <supki> I mean, while serializing
04:45:51 <quchen> supki: You mean I shouldn't send over data but (length data, data)?
04:47:00 <quchen> Or first the length, then the Binary encoding? That introduces a couple of possible errors, e.g. if a silly client sends two sizes and then two datas
04:47:01 <supki> I don't know about "shouldness", but that's how I would do it, if I wanted to know how much bytes to read
04:48:12 <sopvop> quchen: hGetNonBlocking
04:48:44 <sopvop> http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Lazy.html#v:hGetNonBlocking
04:49:54 <quchen> sopvop: I've seen that one, but I'm not sure it's the right function for my problem. I still have to specify the length to be read.
04:50:17 <sopvop> It's sort of maximum length.
04:50:18 <typoclass> quchen: how about calling hGet repeatedly? suppose you first need 4 bytes, then 10, then 100-200 depending. why not make this three calls to hGet?
04:50:20 <quchen> It's essentially a version of hPut which works if the data source takes a break halfway through sending.
04:51:20 <quchen> sopvop: Oh, you mean set the length parameter to "lots", and when the handle stops giving me data my read is done
04:51:39 <merijn> quchen: How would hGet know when to stop if you don't specify a length?
04:51:48 <sopvop> I mean set it to "enough" if it's not enough - read again
04:51:56 <typoclass> quchen: erm ... or is your question about what hGet will do if right now, not enough data is available from the network (or wherever)?
04:52:08 <merijn> quchen: hGetSome returns as soon as there's *any* data, not as late as possible
04:52:31 <merijn> quchen: I don't understand the problem you're having?
04:52:56 <sopvop> He needs to glue together socket handle and Binary decoder
04:53:21 <merijn> Yeah, I get that
04:53:36 <merijn> I just don't understand how there's a problem that ByteString can solve
04:53:40 <quchen> merijn: Data.Binary decodes ByteStrings. However, when I write "decode <$> BS.hGet", hGet will read an entire BS chunk, and not just enough for my decoding.
04:54:00 <merijn> The simple answer is "know the data size in advance" or "implement a wire protocol for network transmission"
04:54:10 <merijn> There's is no "magically decide what to do" option
04:54:19 <sopvop> quchen: http://hackage.haskell.org/packages/archive/binary/0.7.1.0/doc/html/Data-Binary-Get.html#v:runGetIncremental
04:54:30 <Bor0> XexonixXexillion: did you mean the Y combinator by Y?
04:55:01 <quchen> merijn: Dammit, where's lazy IO when I need it ;-)
04:55:02 <sopvop> While not Done - hGetNonBlocking for some (say 512) and feed anything to
04:55:23 <merijn> quchen: Where is that data coming from? Your own code on another machine?
04:55:28 <quchen> merijn: Yes.
04:55:40 <quchen> merijn: I'm sending over some algebraic data type, encoded as Binary.
04:56:09 <merijn> quchen: Implement a wire protocol, i.e. instead of the remote type just doing "hPut socket . encode" you should wrap the encoded data with a header
04:56:21 <sopvop> Partial f -> do { someMore <- hGetWhatnot 512; let rez = f someMore; loop rez }
04:56:23 <sopvop> or something
04:56:34 <merijn> Do "hPut socket . prefixWithHeader . encode" on the remote
04:56:36 <merijn> Then do
04:57:21 <merijn> "do { header <- hGet socket headersize; content <- hGet socket (size header); return (decode content) }"
04:57:23 <t7> surely there must be an abstraction you can use rather than raw sockets?
04:57:44 <merijn> t7: Nothing wrong with raw sockets, heathen!
04:58:15 <sopvop> merijn: why do all the plumbing yourself when you have io-streams?
04:58:33 <merijn> sopvop: Because I'm to lazy to look up another API!
04:59:00 <merijn> Anyway, that's a different issue
04:59:04 <quchen> merijn: Yeah that will work. Feels a bit hacky though. I'm surprised there's nothing in Binary to deal with this already
04:59:15 <merijn> quchen: There are billion things to deal with that
04:59:16 <sopvop> merijn: It's only 3 functions api, and unlike pipes it does not have 7 parameters
04:59:22 <merijn> ZMQ, io-streams, lord knows what
04:59:47 <merijn> quchen: The point is just that you need a network protocol, just "hPut bytestring" isn't good enough :p
05:00:03 <merijn> Implementing a trivial protocol is easy, but you have to actually do it :p
05:00:22 <Bor0> XexonixXexillion: did you mean the Y combinator by Y?
05:00:23 <sopvop> quchen. Either send size of message before message, or use partial parsing.
05:01:32 <XexonixXexillion> Bor0: yeah
05:01:54 <quchen> merijn: Okok, I give up, you convinced me
05:02:16 <quchen> (and sopvop too)
05:02:26 <Bor0> XexonixXexillion: do you have an idea how would I implement \pab.p a b in haskell (I tried something like ifthenelse' :: p -> a -> b; ifthenelse' p a b = p a b but it doesn't work like that I guess)
05:13:09 <Botje> Bor0: \p a b -> p a b is just id
05:13:33 <Botje> if you want to define your own ifthenelse, you can use pattern matching
05:13:45 <Botje> ifthenelse' True a b = a; ifthenelse' False a b = b
05:13:45 <t7> how many haskellers does it take to plug in a lightbulb?
05:13:47 <Rhainur> very new to haskell here. how would I achieve the same result as "filter even [1..20]" without using the even function
05:13:58 <Botje> Rhainur: reimplement even in terms of `mod`
05:13:59 <Rhainur> my predicate is basically along the lines of "mod x 2 == 0"
05:14:10 <elliott> filter (\x -> x `mod` 2 == 0)
05:14:28 <Botje> Rhainur: or you do something more exotic like zip [1..20] (cycle [False, True])
05:14:35 <Botje> and then filter on the second element
05:14:36 * hackagebot kontrakcja-templates 0.1 - Utilities for working with many HStringTemplate templates from files  http://hackage.haskell.org/package/kontrakcja-templates-0.1 (MariuszRak)
05:14:42 <Rhainur> elliott seems to have got the right answer
05:14:49 <Rhainur> now I just have to figure out wtf \x means
05:14:52 <Rhainur> @_@
05:14:55 <elliott> it's a lambda
05:14:56 <typoclass> Rhainur: what elliott showed is an anonymous function (also called lambda). it looks like "\ ... -> ..."
05:15:38 <Rhainur> ty
05:15:56 <typoclass> Rhainur: it's equivalent to a function "foo x   =   x `mod` 2 == 0", only that you write "->" instead of "=" and you leave out the function name "foo"
05:20:49 <McManiaC>  sup Rhainur
05:21:05 <Rhainur> McManiaC: h...hi
05:21:36 <merijn> Rhainur: Are you familiar with lambdas from another language? (Python, JS, or whatever?)
05:21:47 <Bor0> Botje: I successfully implemented most, but I'm having trouble with this, or = (\p q -> p p q)
05:22:12 <Rhainur> merijn: yup, I just didn't know what the syntax was
05:22:34 <merijn> Multi parameters would be like
05:22:37 <Botje> Bor0: it looks weird to apply p to itself.
05:22:42 <merijn> > (\x y -> x + y) 2 3
05:22:43 <lambdabot>   5
05:22:57 <Bor0> Botje: but or is defined as such, \pq. p p q
05:22:58 <Rhainur> merijn: the main problem I'm having with learning Haskell is that for years and years I'm used to commas and parentheses defining function calls
05:22:58 <Botje> Bor0: can you show what other functions you wrote? I'm guessing this is some kind of weird homework problem.
05:23:04 <Rhainur> so my brain stumbles as I read Haskell code
05:23:06 <Bor0> not a homework, no
05:23:15 <Rhainur> I'll get used to it eventually though, just gotta keep practicing and coding moar
05:23:36 <merijn> Rhainur: You get used to it fairly quickly
05:23:43 <typoclass> Rhainur: you'll get through it :) spaces vs. parens-and-commas is a fairly superficial thing
05:23:49 <merijn> Rhainur: Also, might wanna check out the haskell syntax cheat sheet: http://cheatsheet.codeslower.com/
05:24:03 <Rhainur> saved, ty
05:24:07 <merijn> It's fairly complete
05:24:09 <Bor0> do they even teach haskell at school? :p
05:24:26 <Botje> Bor0: sure, I took a functional programming course on haskell
05:24:36 <Botje> and some universities teach it throughout the first years
05:24:45 <merijn> Bor0: Yes, I got taught ocaml in university (not Haskell, but close enough)
05:24:51 <yitz> t7: well?
05:24:51 <Botje> Bor0: what kind of trouble do you have with the or? GHC will probably need an explicit type
05:24:54 <McManiaC> Rhainur: you can use parenthesis and semicolons with Haskell too
05:25:08 <typoclass> Rhainur: just remember that function application (calls) bind tighter than almost anything else. "foo 123 + 42" groups as "(foo 123) + 42"
05:25:10 <merijn> Not the same way
05:25:21 <merijn> McManiaC: Also, you shouldn't and that's terrible advice
05:25:36 <Rhainur> yeah I'm using the learnyouahaskell site, and it's pretty good
05:25:43 <merijn> typoclass: The only thing that binds tigheter is record syntax, isn't it?
05:25:54 <McManiaC> merijn: just saying it's possible, and I think it's good to know
05:26:04 <Bor0> okay, I firstly spent some time on lambda calculus, and right now I'm playing a bit with haskell. I have experience with imperative languages. I don't like reading books just want to try things out. so I'm trying to implement church numerals in haskell. I implemented if-then-else, true, and false. but how could I define or? in lambda it's \p q. p p q
05:26:06 <typoclass> McManiaC: it breaks down fairly quickly :) "foo (1,2)" is different from "foo 1 2"
05:26:11 <t7> yitz: something about side effects and returning actions
05:26:17 <t7> badum tshh
05:26:22 <t7> and monad tutorials
05:26:48 <McManiaC> typoclass: oh, I was talking about do { ; } stuff
05:27:17 <merijn> McManiaC: He was talking about function applications, though
05:27:23 <yitz> t7: i was wondering if the answer not coming was actually the answer
05:27:25 <typoclass> merijn: i think record-updates and "@". not really sure :)
05:27:38 <merijn> You can only have @ in pattern matches, no?
05:27:47 <Bor0> so, for my if-then-else to work with my true' and false', I made a htoc (haskell to church) function that takes a Bool and returns true' when it's True, or false' when it's False
05:27:49 <merijn> And you can't have function calls in pattern matches
05:28:15 <typoclass> merijn: yes. i'm trying to remember what exactly i was remembering there. it's quite possible that i'm an idiot
05:28:27 <McManiaC> merijn: ok, nevermind then
05:29:04 <yitz> > let x = Identity 5 in runIdentity x {runIdentity = 6}
05:29:05 <lambdabot>   6
05:29:26 <byorgey> Bor0: sounds good
05:30:21 <byorgey> Bor0: note that embedding the untyped lambda calculus in Haskell can be a bit problematic, because Haskell has types
05:30:31 <byorgey> you have to be careful about what types you give to your church-encoded stuff
05:31:37 <byorgey> you also have to be careful how you encode stuff.  \p q -> p p q  is perfectly fine as an untyped term, but it's not typeable
05:31:47 <Rhainur> also, am I right in thinking that maps and list comprehensions are basically identical?
05:32:04 <typoclass> Rhainur: yes that's right
05:32:08 <byorgey> Rhainur: every map can be done with a list comprehension.
05:32:19 <byorgey> Rhainur: however, list comprehensions can express a lot more than just maps
05:32:32 <byorgey> well, not a lot
05:32:37 <byorgey> basically they can also express 'filter'
05:32:54 <elliott> (they can express MonadPlus, that's a lot more than Functor!)
05:33:00 <kartlos> the documentation says that threadDelay only works for GHC, maybe stupid question but, that means it doesn't work in GHCi? if so, is it wise to use threadDelay or are there better alternatives?
05:33:07 <elliott> (well, I guess not full MonadPlus)
05:33:14 <merijn> Rhainur: tbh the further you get in haskell the less you'll use list comprehensions that are more complex than [n,m..z] :p
05:33:26 <elliott> those aren't list comprehensions
05:33:29 <elliott> technically
05:33:39 <elliott> kartlos: GHC includes GHCi
05:33:45 <byorgey> kartlos: no, "GHC only" means not other compilers
05:33:48 <typoclass> merijn: dug it out. this is what i remembered, but your criticism is valid http://ircbrowse.net/browse/haskell?id=12510928&timestamp=1321653031#t1321653031 it's all "on the wrong side of the ="
05:33:52 <byorgey> it's not talking about GHC vs GHCi
05:33:59 <Nimatek> I wish GHC included GHCi on ARM.
05:33:59 <merijn> typoclass: \o/
05:34:04 <merijn> So really just record syntax
05:34:55 <kartlos> elliott: byorgey: it so happens that I'm trying to use threadDelay in a script that I load in ghci, but the delay doesn't happen...probably my mistake?
05:35:25 <merijn> kartlos: Did you read that threadDelay works in microseconds?
05:35:37 <merijn> kartlos: So any value less than 1000000 will be instant :p
05:35:39 <yitz> merijn: @ patterns are indeed very strongly binding, but they are not part of expressions
05:36:05 <typoclass> kartlos: it's millionths of a second. in many other languages it's thousandths ...
05:36:07 <kartlos> merijn: man, now I feel really stupid....I thought 1000 would amount to 1 sec :-S
05:36:14 <kartlos> merijn: thanks!
05:36:25 <elliott> kartlos: a bug due to that was even present in lambdabot.
05:36:28 <elliott> it happens to everyone
05:36:31 <typoclass> kartlos: everyone has made that particular mistake :-(
05:36:35 <elliott> when in doubt add more 0s
05:36:58 <kartlos> thank god I'm not the only one then :-)
05:37:02 <typoclass> kartlos: i wish the syntax was "delay (3 :: Second)" or "delay (300 :: Millisec)" or something
05:37:31 <kartlos> typoclass: that would resolve some confusion indeed
05:38:05 <yitz> > "threadDelay 1" ++ repeat '0'
05:38:07 <lambdabot>   "threadDelay 10000000000000000000000000000000000000000000000000000000000000...
05:38:26 <Aetherspawn> :t maybe
05:38:28 <lambdabot> b -> (a -> b) -> Maybe a -> b
05:38:39 <Aetherspawn> :t fromMaybe
05:38:41 <lambdabot> a -> Maybe a -> a
05:41:05 <dwcook> @djinn a -> Maybe a -> a
05:41:05 <lambdabot> f a b =
05:41:05 <lambdabot>     case b of
05:41:05 <lambdabot>     Nothing -> a
05:41:05 <lambdabot>     Just c -> c
05:41:19 <dwcook> \o/
05:41:27 <Nimatek> Magic.
05:41:31 <typoclass> Aetherspawn: you basically give fromMaybe the default value, and it'll give you either what was in "Just" or the default. 'maybe' is a more elaborate version which, in the "Just" case, will call a function that you supplied
05:41:49 <Aetherspawn> I know what it does, was just checking its type quickly :)
05:42:01 <typoclass> Aetherspawn: ok :)
05:42:02 <dwcook> I figured, I was just curious whether djinn could figure it out.
05:42:36 <yitz> @type flip maybe id
05:42:37 <lambdabot> a -> Maybe a -> a
05:46:33 <yitz> @type map \ f x -> x + 2
05:46:34 <lambdabot> parse error on input `\'
05:49:03 <dario> @type map (\f x -> x+2)
05:49:04 <lambdabot> Num a1 => [a] -> [a1 -> a1]
06:09:39 * hackagebot file-embed 0.0.4.8 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.4.8 (MichaelSnoyman)
06:14:55 <randomclown> What's the best way to represent a read only directed acyclic graph?
06:17:31 <Botje> there's Data.Graph and/or fgl.
06:17:51 <Botje> but with some care you can represent it as a tree, too
06:20:31 <randomclown> Botje: is Data.Graph directed?
06:20:58 <randomclown> Oh it is.
06:22:37 <srh> it depends on whether some simple things like Array Int [Int] would suffice (and make life easier by not having docs to read)
06:22:48 <fruitFly_> I just got a computer! :D ... time to set up a local dev enviornment. What do you think is nice and easy to set up? sublime text? vim?
06:23:06 <srh> a computer running windows?
06:25:00 <quchen> fruitFly_: I use Sublime and I quite like it. I spent some time configuring it though. Using vim gives you a very standardized basic editor that will probably feel more familiar out of the box.
06:25:13 <quchen> fruitFly_: In any case, I would first install GHC+Platform. :-)
06:25:18 <fruitFly_> srh: I guess for now ... I am dual booting linux mint as well
06:25:53 <fruitFly_> quchen: installed 2013..2.0.0 ... anything else?
06:26:08 <quchen> fruitFly_: Install as needed
06:26:28 <quchen> > cabal install _EVERYTHING_
06:26:29 <lambdabot>   Not in scope: `cabal'Not in scope: `install'Not in scope: `_EVERYTHING_'
06:26:37 <Bor0> why is haskell platform so large? is there any other smaller (in size) compilers?
06:27:09 <quchen> Bor0: The Platform is pretty small actually (source distribution is around 2 megs).
06:27:15 <Taneb> Bor0, the Haskell platform includes a lot of common libraries, and I would very much recommend it
06:27:18 <quchen> GHC is pretty large though.
06:28:37 <quchen> Scratch that: "GHC is large" is true for the precompiled binary, which isn't a fair argument against "Platform in source is small".
06:29:03 <fruitFly_> all I have downloaded is the Haskell Platform 2013.2.0.0 ... I don't know what cabal is or anything... should I get anything else?
06:29:13 <quchen> fruitFly_: GHC?
06:29:25 <byorgey> GHC comes with the HP on Windows and Mac.
06:29:41 <byorgey> fruitFly_: what platform are you on?
06:29:53 <tdammers> haskell-platform on debian also has ghc as a dependency
06:29:59 <tdammers> which comes down to the same thing
06:30:01 <byorgey> right
06:30:38 <fruitFly_> byorgey: windows 7 64 bit
06:30:48 <byorgey> ok.  The HP should be all you need then.
06:31:10 <byorgey> just run the installer and that will get you GHC, some standard libraries, and the 'cabal' tool which you can use to install additional libraries if/when you want them.
06:32:05 <fruitFly_> byorgey: ok thanks ... is it harder to setup on linux (I'm a linux noob) .. i have dual boot linux mint
06:32:41 <Nimatek> Installing things on Linux is usually easier by default.
06:33:11 <Clint> fruitFly_: apt-get install haskell-platform
06:33:16 <byorgey> fruitFly_: it depends on the distribution.
06:33:18 <merijn> Nimatek: You must be using a different windows than I am :p
06:33:28 <byorgey> fruitFly_: if the HP is packaged for your linux distribution then it should be easy.
06:33:35 <heilkn> it depends, wether one has root access or not
06:33:41 <byorgey> I don't know anything about the HP on linux mint
06:33:55 <heilkn> I can't install anything on my old debian machine at work
06:34:04 <Nimatek> merijn: Well, I haven't booted that VM in the last 5 months or so. So maybe :p
06:34:08 <fruitFly_> what about haskell for nixos?
06:34:09 <quchen> heilkn: Installing GHC+Platform without root is no problem.
06:34:14 <byorgey> there is this: http://community.linuxmint.com/software/view/haskell-platform  but it looks out-of-date
06:34:33 <heilkn> quchen, ghc+platform works nice, that's right
06:34:38 <quchen> heilkn: I don't think it has any obscure dependencies
06:34:44 <byorgey> fruitFly_: http://nixos.org/wiki/Haskell
06:36:05 <fruitFly_> byorgey: oh man... i dnt think i'm ready to take on linux yet... i think i'll focus on haskell for now on windows
06:36:30 <fruitFly_> sublime text 2, vim... or what? I'm not sure?
06:36:49 <byorgey> fruitFly_: both are good.  vim has a much steeper learning curve.
06:36:51 <elliott> any editor is fine. the choice has little to do with haskell
06:36:57 <quchen> fruitFly_: You don't "get ready" for Linux like you don't "get ready" for learning how to play the piano. You just start doing it.
06:37:04 <byorgey> fruitFly_: in particular I think lots of people use both of those with Haskell.
06:37:37 <fruitFly_> quchen: i dnt know which distro... nixos, arch, gentoo?
06:37:55 <quchen> byorgey: Makes me wonder why Sublime still doesn't have proper Haskell syntax highlghting. :-/
06:37:59 <heilkn> gentoo :)
06:38:04 <quchen> Get out :C
06:38:06 <heilkn> (or funtoo)
06:38:12 <byorgey> fruitFly_: of those three, gentoo would certainly be the easiest to start with.
06:38:26 <byorgey> but it doesn't really matter that much.
06:38:28 <fruitFly_> byorgey: is vim worth it in the long run though... or is it possible for sublime text to to surpass it
06:38:47 <byorgey> fruitFly_: it depends what you are looking for.
06:38:50 <elliott> gentoo easier than arch to get started with?! ...no... must... not... encourage... distro... flame... war...
06:38:51 <fruitFly_> byorgey: why should I start using linux now?
06:39:11 <elliott> none of this has basically anything to do with haskell, really.
06:39:24 <elliott> any OS works, any editor works
06:39:32 <quchen> Arch for learning Linux is like learning the piano with Beethoven. (Gentoo is Rachmaninov.) Sounds like an excellent idea.
06:40:22 <fruitFly_> quchen: what about nixos... I heard the package manager makes it the shit
06:40:47 <fruitFly_> quchen: that along with its system config... east to update, roll back etc.
06:40:59 <simukis_> some people like it, some people despise it.
06:41:05 <quchen> fruitFly_: Not sure. It's probably not better at doing Haskell than any other distro.
06:41:09 <simukis_> It's like that with everything.
06:41:39 <fruitFly_> quchen: it's on par with arch and gentoo i've hear ... but it's sysconfig is just waay smoother i've heard... like it's the future
06:41:43 <quchen> fruitFly_: I think Mint is a fine choice as a first distro.
06:41:51 * quchen leaves the Linux discussion.
06:43:11 <fruitFly_> so should I leave windows as fast as I can?
06:43:34 <byorgey> arch is like learning the piano with Beethoven, except you have to tune it yourself and also replace any broken strings.  And as soon as any new piano technology comes out your piano is automatically retrofitted with it.
06:44:01 <quchen> fruitFly_: You should try out stuff and make an educated decision based on your experience.
06:44:38 <quchen> fruitFly_: You should have a look at Haskell for the same reason. And Lisp and Python and C and C++ and what not.
06:44:44 <merijn> #-blah or #not-haskell?
06:45:12 <merijn> Or more preferable #nowhere, linux discussions are boring
06:45:16 <fruitFly_> quchen: i do haskell because it's the shit
06:45:26 <fruitFly_> quchen: not exactly sure what else is the shit though
06:45:27 <irene-knapp> I would like to note that Beethoven probably tuned his own piano and replaced his own broken strings?
06:45:44 <irene-knapp> Galileo certainly ground his own lenses :)
06:45:46 <elliott> yes, we really don't need OS or editor or anything flamewars...
07:12:09 <Sculptor> yo
07:12:59 <dmwit> w3rd
07:16:34 <heilkn> quchen, how to install haskell-platform as not root?
07:17:57 <mmaruseacph2> heilkn: https://github.com/quchen/articles/blob/master/install_haskell_platform_manually.md
07:18:04 <mmaruseacph2> it might be of use
07:18:06 <quchen> heilkn: You can set the directories to install your stuff in using --prefix
07:18:29 <heilkn> quchen, that for you would need to build it first from source
07:18:31 <mmaruseacph2> ah, it's quchen's article :)
07:18:43 <heilkn> that for you have to build all dependencies first
07:19:20 <quchen> heilkn: You can download the precompiled GHC files.
07:20:04 <quchen> I always compile the platform myself after that. Not sure how long it takes, ballpark an hour.
07:20:59 <heilkn> oh, okay. I was not aware, that there is a ghc binary package outside of haskell-platform available
07:21:39 <quchen> heilkn:  http://www.haskell.org/ghc/download
07:22:05 <quchen> Current version: http://www.haskell.org/ghc/dist/7.6.3/ghc-7.6.3-i386-unknown-linux.tar.bz2
07:23:07 <SoleSoul> Hi. The "filter f xs" function in Haskell, is there an equivalent to it in Python?
07:23:50 <monoidal> SoleSoul: yes, it's called "filter". In Python, list comprehensions are more idiomatic though.
07:25:36 <SoleSoul_> Who just answered me? I've been disconnected.
07:25:40 <SoleSoul_> thanks!
07:27:06 <mmaruseacph2> 17:34 < monoidal> SoleSoul: yes, it's called "filter". In Python, list comprehensions are more idiomatic though.
07:27:12 <mmaruseacph2> (if you didn't find it)
07:27:35 <SoleSoul_> I didn't. (I'm on webchat) Thanks
07:27:51 <fruitFly_> sublime text 2 launches with this error Error loading syntax file "Packages/Text/Plain text.tmLanguage": Error parsing plist xml: Failed to open file In file "Packages/Text/Plain text.tmLanguage"" ... I can't fidure it out
07:27:56 <fruitFly_> I can't figure it out
07:29:30 <quchen> fruitFly_: Aren't those files installed automatically?
07:30:02 <fruitFly_> quchen: I think they should be
07:30:10 <fruitFly_> I uninstalled reinstalled same shit
07:30:18 <SoleSoul_> fruitFly_: Does it happen on a clean install with no plugins?
07:30:23 <quchen> Well, ask in their forums?
07:30:55 <SoleSoul_> fruitFly_: I think plugins can persist if your config folder remained intact
07:31:03 <fruitFly_> SoleSoul_: I don't think I ever installed a plugin for it ... yes, I reinstalled same shiz ... it seems to remember what docs I had open before the uninstall though?
07:31:26 <SoleSoul_> fruitFly_: are you on linux?
07:31:54 <fruitFly_> SoleSoul_: no ... windows 7 64 bit lol
07:32:04 <quchen> fruitFly_: Go to Preferences | Browse Packages. It will open your user config directory. Move up the directory tree and delete the whole Sublime folder.
07:32:08 <quchen> Then try again.
07:32:22 <quchen> Also this isn't about Haskell. Maybe go on in #haskell-blah.
07:32:30 <SoleSoul_> fruitFly_: <snip> ... what quchen said.
07:33:48 <fruitFly_> quchen: the nav bar in sublime is blank
07:34:41 <fruitFly_> quchen: I see "Pristine packages" in the sublime folder in prog files... but it's brand new from today
07:35:30 <SoleSoul_> fruitFly_: try here: #sublimetext
07:36:12 <fruitFly_> SoleSoul_: thnaks
07:36:18 <SoleSoul_> gl
07:42:03 <merijn> Is there a nice way write long pointfree pipelines? i.e. you end up composing more than a lines worth of functions and need to linewrap
07:42:22 <bitonic`> merijn: ?  you can just put a newline
07:45:08 <merijn> hmm, I forget about that :p
07:45:22 <bitonic> that’s a strange thing to forget about
07:47:01 <merijn> I don't commonly have wrap lines like this
07:49:23 <jfhall> \quit
07:55:43 <tomberek> just noticed that http-conduit has no support for https on windows (or rather I guess it's the tls package)
08:06:31 <Aetherspawn> merijn, you can always break it up into smaller functions with where
08:07:05 <enigmuriatic1> what's the easiest way to remove duplicates from a list
08:07:27 <Botje> nub
08:07:45 <merijn> Aetherspawn: That means having to come up with names, though
08:07:51 <merijn> Aetherspawn: And I can't be arsed
08:08:22 <geekosaur> nub isnt necessarily the best, just the easiest. (the best would require an Ord instance...)
08:08:29 <Aetherspawn> :t nub
08:08:30 <lambdabot> Eq a => [a] -> [a]
08:08:38 <Aetherspawn> Haha I thought he was calling him a noob
08:08:40 <Aetherspawn> lol
08:08:52 <Botje> I did no such thing!
08:09:07 <Aetherspawn> hehe
08:10:30 <tomberek> anyone know how I can send https POST on windows.   http-conduit it complaining that the tls package does not support windows right now
08:10:34 <Cale> Or map head . group . sort, if you want something that's asymptotically faster in many cases (but less lazy)
08:11:02 <Cale> It's possible to write a version of nub which makes use of an ordering on the elements but works lazily, but that's a little more work.
08:16:59 <weebl> @faq can haskell do that
08:17:00 <lambdabot> The answer is: Yes! Haskell can do that.
08:18:27 <fruitFly> 100% vim noob... how to set up for beginner haskell?
08:18:46 <fruitFly> wrong channel sry
08:30:56 <fruitFly> anyone here use vim with tips to help vim noob setup haskell?
08:31:51 <scriptor> fruitFly: can't help you much with haskell-specific vim stuff, but if you're just starting out
08:31:59 <scriptor> when the default syntax highlighting's not bad
08:32:09 <scriptor> I could help you with vim stuff in general, though
08:32:16 <quazimodo> what does suc mean?
08:32:37 <simukis_> fruitFly: I'm myself using vanilla vim with a really small set of plugins not specific to haskell. (ctrlp only for now is worth mentioning.)
08:32:47 <solirc> quazimodo: succ?
08:33:01 <solirc> I mean do you mean succ?
08:33:01 <tomberek> anyone know how I can send https POST on windows.   http-conduit it complaining that the tls package does not support windows right now
08:33:30 <quazimodo> I'm looking at agda, the data type for natural numbers has a term for Zero : N; suc : N -> N
08:33:59 <quazimodo> is that just +1 ?
08:34:02 <simukis_> quazimodo: Successive number.
08:34:03 <monoidal> quazimodo: yes
08:34:40 <fruitFly> scriptor:  simukis_  thanks
08:34:48 <quazimodo> gotcha, still there is no definition for that in there
08:35:05 <solirc> quazimodo: https://en.wikipedia.org/wiki/Church_encoding
08:36:03 <monoidal> solirc: strictly speaking that's not Church encoding. That one is \f x -> f (f ... x)
08:36:20 <quazimodo> I'm presuing elsewhere it'l have suc N -> N; (suc N) = N + 1 ?
08:36:38 <monoidal> quazimodo: no, naturals are terms built of Zero and suc
08:36:51 <monoidal> quazimodo: for example, the number 2 is suc (suc Zero)
08:37:05 <quazimodo> monoidal: I guess I'm trying to understand how that turns into digits
08:37:20 <quazimodo> in data we don't represent that as strings of suc's do we?
08:37:20 <monoidal> quazimodo: it's more like unary system
08:38:09 <quazimodo> i guess what I'm saying is, in the background, haskell or agda surely have a way to take (suc (suc (suc (suc N)))) and return smoething meaninful, like a number
08:38:13 <monoidal> quazimodo: we do (not as character strings of course)
08:38:38 <monoidal> quazimodo: "suc (suc Z)" is a number as meaningful as "2" is.
08:39:04 <quazimodo> how does haskell take (suc (suc 2)) and return 3?
08:39:56 * hackagebot on-a-horse 0.3 - "Haskell on a Horse" - A combinatorial web framework  http://hackage.haskell.org/package/on-a-horse-0.3 (JasonPriestley)
08:40:10 <Raydiation> what is a functor? something like an object?
08:40:22 <enigmuriatic1> how do you test equality in a lambda?
08:40:53 <Raydiation> or a function that holds a value?
08:41:22 <quazimodo> monoidal: don't get me wrong, I understand this in conceptual terms, but surely *somewhere* we've told haskell that suc n = n + 1 ?
08:41:47 <latermuse> raydiation: functors are a container around data
08:41:52 <monoidal> quazimodo: No. Instead, we define a + b as taking Suc operation of a, taken b times
08:42:24 <Raydiation> so you can compare it to an object somehow?
08:42:26 <latermuse> quazimodo: I think succ is defined in GHC.Enum
08:42:31 <monoidal> quazimodo: http://en.wikipedia.org/wiki/Peano_axioms#Arithmetic
08:42:32 <Raydiation> that implements magic methods?
08:42:33 <quazimodo> monoidal: that's weird XD
08:43:17 <latermuse> raydiation: functors arent magic
08:43:19 <quazimodo> monoidal: haskell is great. Learning it makes me uncomfortable and mad, challenges the way I see things
08:43:27 <Raydiation> im having a bit trouble to understand how maybe works
08:43:30 <Raydiation> http://en.wikibooks.org/wiki/Haskell/Applicative_Functors
08:43:41 <Raydiation>  Typically, they are structures that "can be mapped over"
08:44:31 <latermuse> > mconcat [Just "hi", Just " meow"]
08:44:32 <lambdabot>   Just "hi meow"
08:44:46 <monoidal> > fmap (+2) [2,3,4] -- Raydiation
08:44:48 <lambdabot>   [4,5,6]
08:45:01 <latermuse> the Just is a functor, and the [] is also a functor
08:45:08 <monoidal> Maybe is a functor, not Just
08:45:13 <weebl> anyone know if there is a library for getting urls from a string?
08:45:28 <Raydiation>  is it a built in thing? or can you implement it with your own functions?
08:45:31 <fruitFly> simukis_ does that just help you nav files?
08:45:36 <latermuse> raydiation: both
08:45:46 <latermuse> its built in, but you could implement it yourself also
08:45:52 <Raydiation> i see
08:45:53 <monoidal> Raydiation: you can implement it with your own functions, however, GHC provides convenient deriving support.
08:45:56 <latermuse> some of them neeed to be imported
08:46:03 <supki> weebl: Network.URI from network package
08:46:06 <latermuse> import Data.Maybe
08:46:25 <Raydiation> so what my first guess was: its like an object that implements an interface for a map method
08:46:30 <monoidal> latermuse: Maybe's Functor instance need not be imported
08:46:39 <latermuse> monoidal: correct
08:46:48 <Raydiation> so if i define a functor, do i need to define a map method?
08:46:56 <Raydiation> function*
08:47:45 <dgpratt> trying to 'configure' GHC 7.6.3 on Linux (Mint), I get: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory
08:48:09 <latermuse> raydiation: functors need a map function to work
08:48:16 <monochrom> consider making a symlink
08:48:18 <latermuse> fmap
08:48:26 <dgpratt> not being very versed in the ways of Linux, I guessed that installing the libgmp3-dev package might resolve the issue -- it didn't
08:48:44 <Clint> dgpratt: libgmp3 is ancient
08:48:47 <Raydiation> latermuse: ok :) then i get it
08:48:51 <monochrom> because libgmp3-dev just brings in 10
08:48:54 <Raydiation> ty
08:49:01 <latermuse> no problem
08:49:11 <tomberek> anyone know how I can send https POST on windows.   http-conduit is complaining that the tls package does not support windows right now. Is there any other package that might help me?
08:49:23 <dgpratt> does this mean I need to dig up an ancient copy of libgmp3 somewhere?
08:49:58 <quchen> dgpratt: Try installing libgmp3c2 as well, I think I read somewhere that may help (in case nothing else does)
08:50:01 <merijn> dgpratt: Why are you building ghc from scratch?
08:50:19 * merijn kicks monochrom 
08:50:38 <merijn> monochrom: Don't tell people to solve missing library issues/library version issues with symlinks
08:50:56 <merijn> That's a good way to break things in horribly unpredictable ways
08:51:09 <monochrom> ok, you know what
08:51:28 <monochrom> I built GHC 7.6.3 from source because of libgmp10
08:51:58 <weebl> supki: do you know if there is something which will go from a String -> [URI] where it'll filter anything that is not an URI?
08:52:00 <monochrom> I hope that answers your question? it's a chicken-egg thing
08:52:06 <weebl> or would i need to write it myself
08:52:11 <dgpratt> merijn: perhaps in ignorance -- I was not able to find a non-scratch dist. of HP 2013.2
08:52:37 <merijn> What does "non-scratch" mean?
08:52:48 <merijn> Also, you can get GHC binaries separately from HP
08:52:51 <monochrom> symlink, build GHC, make merijn happy. pick one.
08:53:26 <merijn> Oh, you won't make me unhappy, you might make your future self horribly unhappy, though
08:53:30 <monochrom> merijn, did you know that the GHC binaries on GHC's website want libgmp3
08:54:12 <monochrom> as for Mint's package repo, likely it doesn't exactly have 7.6.3
08:54:44 <latermuse> weebl: maybe you want to have a look here: http://hackage.haskell.org/package/web-routes
08:54:50 <merijn> Anyhoo, time to go home
09:00:48 <monochrom> I used to build GHC from source because of lib versions. gmp 3 vs 10 recently. last time it was readline 5 vs 6, or was it 4 vs 5?
09:01:10 <enigmuriatic1> > filter (/x -> (<) 3 x) [1,2,3,4,5]
09:01:11 <lambdabot>   <hint>:1:12: parse error on input `->'
09:01:18 <enigmuriatic1> why doesn't that work?
09:01:29 <Mortomes> > filter (\x -> (<) 3 x) [1,2,3,4,5]
09:01:30 <lambdabot>   [4,5]
09:01:42 <enigmuriatic1> AH lol
09:01:45 <monochrom> anyway after I built, someone would say, just make a symlink, or even more cunning, just edit the binary to change "4" to "5".
09:01:47 <enigmuriatic1> well, that's embarressing
09:02:26 <monochrom> well, I would love to edit the binary this time, but "3" does not have enough space to be changed to "10".
09:03:31 <quchen> monochrom: You're evil.
09:04:34 <monochrom> trapped between a rock, a hard place, and moral high horse.
09:04:39 <latermuse> monochrom: ive also tried those techniques in similar predicaments; never seems to work
09:05:34 <monochrom> then they are not similar predicaments, because in the case of GHC and readline and gmp, it seems to work.
09:06:42 <monochrom> I fully agree that it doesn't generalize to other executables and other libs.
09:07:00 <latermuse> so that technique did work successfully for you?
09:07:21 <monochrom> but I fully insist that other executables and other libs don't generalize to GHC and readline, gmp
09:09:28 <monochrom> I got GHC 7.4.2 and gmp 3->10 to work. other people previously got GHC and readline 4->5 (or 5->6?) to work.
09:10:12 <monochrom> actually I also got GHC 7.6.3 gmp3->10 to work. I have only rebuilt GHC 7.6.3 on 32-bit. on 64-bit I symlink.
09:11:02 <monochrom> I did type in things like 2398439^323 to test. well, I don't know whether I got the right answer. I got no crashing.
09:11:53 <Clint> as long as ghc avoids any abi that changed, you shouldn't get crashing
09:12:31 <tomberek> monochrom: do you know of any package capable of https on windows?
09:12:43 <monochrom> I don't know.
09:23:38 <supki> weebl: no, no idea
09:28:32 <weebl> anyone ever use Text.Regex.Posix?
09:29:59 * hackagebot prettify 1.0 - Haskell2010 structured text formatting  http://hackage.haskell.org/package/prettify-1.0 (HansHoglund)
09:34:59 * hackagebot warp-tls 1.4.1.2 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.4.1.2 (MichaelSnoyman)
09:41:28 <TravisD> I'm trying to code a simulation where two different entities interact. I want them both to be able to run inside some monad so that they can maintain some state, generate pseudorandom numbers, etc. Does anyone know of any elegant ways to do this?
09:42:19 <DoctorBatmanGod> Use the pair monad?
09:42:53 <TravisD> I've never heard of it, but I'll take a look. Thanks
09:43:00 <DoctorBatmanGod> No problem
09:43:41 <Martty> can someone verify this is correct?
09:43:42 <Martty> unary(x) = (x-1) 1 . 0
09:43:42 <Martty> gamma(x) = unary(1 + [log2(x)]) . bin(x - 2^[log2(x)]){in [log2(x)] bits}
09:43:43 <Martty> delta(x) = gamma(1 + [log2(x)]) . bin(x - 2^[log2(x)]){in [log2(x)] bits}
09:43:56 <TravisD> DoctorBatmanGod: Do you have a reference anywhere? A quick google search wasn't very helpful
09:44:03 <Martty> where [log2] is floor(log2()) and "." means concatenate
09:45:58 <osfameron> Martty: what language is that in?
09:46:06 <Martty> math?
09:46:10 <Martty> xD
09:46:12 <dgpratt> monochrom: thanks for your advice (I just got back from lunch)
09:46:29 <osfameron> Martty: so not haskell.  it's probably worth mentioning that, no?
09:46:39 <Martty> right
09:46:43 <dgpratt> you responded so quickly with the symlink suggestion that I didn't realize at first that it was directed at me :)
09:48:03 <dmwit> Martty: Those... look like definitions. What does "correct" mean?
09:48:46 <Martty> if that generates the same results as the definitions found on.. say wikipedia or some other trusted source
09:49:02 <dmwit> Am I missing some context or something?
09:49:06 <monoidal> Martty: it's unclear what do you mean by gamma and delta. plus, probably offtopic
09:49:25 <dmwit> To answer your direct question: no, I don't think someone can verify that those are correct.
09:50:23 <dgpratt> one good thing that has come out of this is that, as one who usually works on Windows, I am now feeling less like the grass is greener on the Linux side :)
09:50:30 <dmwit> (The question is vague, and Wikipedia is big.)
09:52:14 <osa1> there was a tool that organizes import declarations in a haskell source(ie. sorts alphabetically,tabularizes etc.) what was that?
09:52:34 <bitonic> osa1: stylish haskell and ghc-mod do that
09:52:35 <joelteon> so you can't put conditionals in .ghci, right?
09:52:37 <Martty> ok thanks anyways
09:52:48 <osa1> thanks
09:53:08 <joelteon> I'm using cabal-ghci and it hides a bunch of packages when it's inside a directory with a .cabal file, and I have a lot of convenience definitions in my .ghci that I don't want to have activated when I'm in a cabal project directory
09:53:26 <joelteon> so I get a crapton of warnings whenever I launch ghci
09:53:38 <joelteon> anybody have any idea how I would work around that?
09:53:41 <quchen> joelteon: Add a ghci.conf in your project directory
09:53:54 <quchen> I think that will load only the local config and not the global one
09:54:14 <joelteon> no, I've tried that before
09:54:27 <joelteon> ghci loads ./.ghci, then $HOME/.ghci
09:54:39 <quchen> Hmpf, sorry then
09:59:38 <tomberek> dgpratt: have you had any luck with https on windows? http-conduit complains (or rather the tls package) that windows is not supported
10:00:22 <dgpratt> tomberek: I have no experience with that stuff, sorry
10:00:33 <tomberek> dang
10:07:42 <fruitFly> anyone know how to setup haskell for sublime text? at least add a repl in it?
10:07:49 <fruitFly> prelude in sublime?
10:09:06 <kartlos> I want to generate images on a pixel-by-pixel basis, is there a library that does this? I've tried using Graphics.GD but it won't install on OS X :-(
10:11:09 <Cale> fruitFly: You go into Preferences.sublime-settings and you set "translate_tabs_to_spaces": true
10:12:53 <Cale> (apart from that, google turns up this: https://github.com/SublimeHaskell/SublimeHaskell )
10:13:07 <fruitFly> Cale: you're the man!
10:13:17 <tomberek> Cale: i'm having problems with https in windows. http-conduit and the tls packages don't seem to support windows. Or am I missing something? is there a windows-friendly https package?
10:13:32 <Cale> I don't use windows, so I have no idea.
10:16:18 <Cale> However, I don't immediately see a reason that the tls package wouldn't work on windows.
10:16:27 <Cale> Does it really not?
10:20:02 <ctc> Any suggestions on how to write an overloaded function that swaps the elements of a pair (wrapped in Just) if their types are equal otherwise return Nothing?
10:23:34 <Cale> ctc: maybeSwap :: (Typeable a, Typeable b) => (a,b) -> Maybe (b,a); maybeSwap (x,y) | typeOf x == typeOf y = Just (y,x) | otherwise = Nothing
10:23:34 <Hafydd> ctc: what is the type of the pair?
10:24:52 <ctc> Hafydd: binary tuple works fine
10:25:19 <Cale> ctc: I think he means: are the types of the components swapped?
10:25:23 <Hafydd> ctc: I meant its type, in the literal sense, but I suppose Cale probably guessed correctly.
10:25:40 <Cale> e.g. you could also write:
10:28:23 <fruitFly> Cale: I have never reall used github ... how would I download that for windows? "clone in windows"?
10:30:09 <Cale> maybeSwap :: forall a b. (Typeable a, Typeable b) => (a,b) -> Maybe (a,b)
10:30:09 <Cale> maybeSwap (x,y) = case (cast x :: Maybe b, cast y :: Maybe a)
10:30:10 <Cale>                     of (Just x', Just y') -> Just (y',x')
10:30:10 <Cale>                        _                  -> Nothing
10:30:54 <Cale> oh, actually you can do it without the ScopedTypeVariables of course
10:30:59 <Cale> maybeSwap :: (Typeable a, Typeable b) => (a,b) -> Maybe (a,b)
10:30:59 <Cale> maybeSwap (x,y) = case (cast x, cast y)
10:30:59 <Cale>                     of (Just x', Just y') -> Just (y',x')
10:30:59 <Cale>                        _                  -> Nothing
10:31:18 <Hafydd> (That wasn't what I meant, but a GQ nonetheless)
10:31:43 <Cale> fruitFly: There's a tiny button labelled ZIP with a little cloud and a down arrow
10:32:09 <Cale> which is somewhere amongst the bewildering array of UI elements that github imposes on its users
10:32:46 <fruitFly> Cale: haha thanks!
10:32:53 <monoidal> Cale: liftM2 (curry swap)
10:33:03 <Hafydd> Oh my god.
10:33:34 <Hafydd> I thought there would be a way to do it using liftM2, but not *that* simple.
10:33:40 <fruitFly> Cale: now what do I do with this lol? copy it's content to my packages folder?
10:33:41 <monoidal> Cale: (or liftM2 (flip (,))
10:33:52 <monoidal> )
10:34:36 <Hafydd> But, wait... that doesn't account for the type condition.
10:34:42 <Cale> monoidal: Oh, actually, you don't have to download it that way at all. Read the install instructions on that page.
10:34:50 <Cale> er, fruitFly rather
10:35:06 <monoidal> Hafydd: that should be applied to (cast x) (cast y)
10:35:32 <monoidal> maybeSwap (x,y) = liftM2 (,) (cast y) (cast x)
10:35:34 <Cale> monoidal: indeed
10:35:34 <ctc> Cale: it does the comparison / casting at runtime right? is there any way to write a "static" version?
10:35:42 <Hafydd> @pl maybeSwap (x,y) = liftM2 (,) (cast y) (cast x)
10:35:42 <lambdabot> maybeSwap = uncurry (flip (liftM2 (,) . cast) . cast)
10:36:23 <Cale> ctc: It does it at runtime using a representation of the types which is passed in as hidden parameters to maybeSwap by the typeclass machinery
10:36:46 <Cale> (to ensure that the types really are equal)
10:36:59 <Cale> What are you actually trying to do?
10:37:04 <Cale> This is a very strange thing.
10:37:57 <fruitFly> Cale: should I just use http://wbond.net/sublime_packages/package_control/installation ?
10:38:14 <Cale> fruitFly: I assume so
10:38:21 <Cale> fruitFly: I don't use sublime text
10:38:30 <Cale> I just googled "sublime text haskell"
10:38:35 <Cale> and gave you the first result :P
10:38:40 <fruitFly> lol
10:40:44 <ctc> something like the following (overlapping is of course problematic):class Swap  a b where swap :: (a,b) -> Maybe (a,b); instance swap a a where swap (x,y) = Just (y,x); instance Swap a b where  swap _ = Nothing
10:41:32 <monoidal> ctc: HEAD has overlapping type families that should allow this nicely
10:42:11 <dgpratt> do any of you folks run GHC >= 7.6 on Linux? how did you configure/install it?
10:43:00 <paullik> dgpratt, 7.6.3 here, archlinux
10:43:10 <paullik> that's how
10:43:40 <simukis_> 7.6.3 here too. Arch too… well…
10:43:42 <joelteon> dgpratt: binary distribution
10:43:45 <joelteon> on debian
10:43:53 <Clint> dgpratt: apt-get install ghc
10:43:53 <joelteon> Well, debian pushed out an update that breaks all GHCs, so I haven't used it for awhile
10:43:57 <joelteon> I wouldn't recommend debian
10:44:06 <Clint> "breaks all ghcs"?
10:44:32 <joelteon> http://hackage.haskell.org/trac/ghc/ticket/7926
10:45:03 <joelteon> by "all" I mean 7.6 and 7.4 afaik
10:45:51 <Clint> and what do i need to do to experience this breakage?
10:46:22 <ctc> monoidal: I have HEAD version and I am aware of the ordered overlapping type family instances and the older approach of using fundeps to resolve overlapping issues (http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap) but I failed put them all toghether
10:46:24 <joelteon> not sure exactly
10:46:40 <dgpratt> ok, thanks for the responses
10:46:43 <Clint> bizarre
10:48:04 <supki> joelteon: nice
10:50:12 <Clint> joelteon: what version of linux is this on?
10:50:17 <joelteon> debian jessie
10:50:37 <Clint> that's a version of debian, not a version of linux
10:50:54 <joelteon> ok
10:51:15 <joelteon> 3.2.0
10:51:40 <Clint> and eglibc 2.17?
10:51:44 <Cale> dgpratt: I'm using a patched 7.6.3 which I just compiled myself. Before that I was using the generic linux binary of 7.6.2
10:51:50 <Cale> (from the GHC website)
10:53:03 <joelteon> Clint: dunno what eglibc is
10:53:10 <Clint> libc6
10:53:35 <joelteon> yeah 2.17-3
10:54:45 <Clint> joelteon: that's pretty weird
10:54:51 <joelteon> yep
10:55:24 <Clint> and cabal is from debian or somewhere else?
10:58:05 <dgpratt> I am about to 'make install' ghc 7.6.3, do I need to 'sudo' this?
10:58:39 <c_wraith> dgpratt: depends on what you used as the prefix when configuring it
10:58:46 <lispy> @tell edwardk BTW, I think committee@ may actually be a mail alias. That shouldn't affect the rest of your request though.
10:58:46 <lambdabot> Consider it noted.
10:58:48 <dgpratt> c_wraith: default
10:58:49 <geekosaur> yes if the prefix is a system directory instead of under ~ somewhere
10:59:01 <geekosaur> so that'd be /usr/local and you need sudo
10:59:09 <dgpratt> geekosaur: ok
10:59:21 <dgpratt> now I'm wondering if I should change the prefix
10:59:43 <c_wraith> I much prefer installs to somewhere in my home directory
10:59:59 <c_wraith> I'd install that one to $HOME/ghc-7.6.3
11:02:24 <dgpratt> c_wraith: I was intending to install the platform after ghc, will changing the prefix affect the HP installation procedure?
11:02:40 <dgpratt> or maybe I should not install HP?
11:02:47 <c_wraith> iirc, it doesn't change the install procedure.
11:03:12 <c_wraith> But I don't bother with installing the platform.
11:03:17 <dgpratt> c_wraith: ok, this is all an experiment at this point, so I will proceed with abandon
11:03:31 <dgpratt> (thanks)
11:07:26 <monoidal> ctc: I tried it now, and failed. I can write a function of type isEqual :: Boolish (Equal a b) => a -> b -> Bool, but if they are equal, I can't pass the fact that a ~ b to the swapping function.
11:08:48 <monoidal> ctc: It would be something like class EqualityTest a b where f :: Proxy (a,b) -> Maybe (Dict (a ~ b))
11:17:21 <warpy> path[l]: hi
11:17:24 <path[l]> hi
11:17:27 <path[l]> whats up
11:21:07 <warpy> path[l]: nothing, just idling.
11:21:41 <Li3> hi warpy, it takes 5 tabs to find you
11:24:42 <Li3> hi Pops
11:25:52 <Popsicle> Hello Li3
11:27:39 <Li3> so why are path[l] and warpy trying to disown us on another server? They ought to be doing it here
11:27:57 <path[l]> I dont have a problem. hi Li3, poppingtonic
11:27:58 <path[l]> err
11:28:02 <path[l]> Popsicle:
11:28:10 <Li3> you do have a problem. With tabs
11:28:28 <Popsicle> Hello path[l]
11:28:42 <path[l]> I just dont expect you to find haskell interesting, but you should hang around and see :)
11:29:04 <Li3> so you don't withdraw your invitation?
11:29:26 <path[l]> not me atleast
11:29:41 <path[l]> lambdabot help
11:29:55 <path[l]> @help
11:29:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:30:01 <path[l]> list
11:30:07 <path[l]> help list
11:30:10 <path[l]> @list
11:30:10 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:30:41 <Li3> that's a new, path. You, fumbling around with commands =p
11:30:54 <warpy> path[l]: it has topic-tell
11:31:04 <path[l]> @pl f x y = (\x -> x + 1) (\y -> y + x)
11:31:04 <lambdabot> f = const . (1 +) . (+)
11:31:06 <path[l]> it does?
11:31:17 <Li3> i wish you were similarly unfamiliar with the commands in the channel you own on the other server
11:31:24 <path[l]> I wonder if its similar
11:31:37 <path[l]> it has topic-tail too …
11:32:03 <warpy> lambdabot is the best bot
11:32:23 <Li3> yes, far cry from the disaster that is MISAKA
11:32:40 <Li3> if my memory serves me right, the both of you programmd it
11:32:43 <Li3> *programmed
11:32:57 <path[l]> Li3: I believe you can get lambdabot to hang out in the other channel if you want to
11:33:03 <path[l]> there is some help somewhere on it
11:33:08 <Li3> cross server invites work?
11:33:24 <path[l]> dunno, check
11:34:07 <Li3> MISAKA would become an exile if lambdabot were invited into the other channel
11:35:19 <tac> @djinn a -> (Not . Not) a
11:35:19 <lambdabot> Cannot parse command
11:35:47 <Cale> Uh, what's going on here?
11:36:22 <saml> @hoogle String -> (Int, Int)
11:36:23 <lambdabot> Graphics.Rendering.OpenGL.GL.StringQueries majorMinor :: GettableStateVar String -> GettableStateVar (Int, Int)
11:36:23 <lambdabot> Prelude floatRange :: RealFloat a => a -> (Int, Int)
11:36:23 <lambdabot> System.Random genRange :: RandomGen g => g -> (Int, Int)
11:36:32 <saml> @hoogle String -> (Double, Double)
11:36:32 <lambdabot> Control.Monad.Trans.RWS.Lazy execRWS :: RWS r w s a -> r -> s -> (s, w)
11:36:32 <lambdabot> Control.Monad.Trans.RWS.Strict execRWS :: RWS r w s a -> r -> s -> (s, w)
11:36:32 <lambdabot> Control.Monad.RWS.Lazy execRWS :: RWS r w s a -> r -> s -> (s, w)
11:36:44 <saml> given a url, I want to get longitute and latitude
11:36:48 <saml> is there monoid for that?
11:37:10 <path[l]> given a url? why would the long and lat be in the url
11:37:24 <saml> i want to plot of google search results in google map
11:37:34 <tabemann> I think saml wants a generalized IP lat and long lookup here
11:37:46 <path[l]> oh ok
11:37:48 <Cale> URLs don't contain latitude and longitude information generally
11:37:49 <saml> no.. not geoip.  any random url
11:37:57 <saml> yah.. so i want some novelty algorithm
11:38:01 <Cale> saml: Clearly impossible...
11:39:06 <path[l]> Li3: here you go http://www.haskell.org/haskellwiki/Lambdabot
11:39:11 <Cale> You could do a DNS lookup and then use geo-ip, which would give you some kind of approximation.
11:39:14 <Li3> gracias
11:39:19 <Cale> What's this about lambdabot?
11:39:39 <path[l]> is it possible to run lambdabot in another channel do you know Cale
11:39:46 <Cale> Yes
11:39:56 <Li3> on another server, Cale
11:40:06 <Cale> If you want to run it yourself, yes.
11:40:12 <path[l]> ah thanks
11:40:32 <path[l]> Li3: you'll have to run it on some other machine, but there you go.
11:40:43 <Cale> It's available on hackage
11:41:21 <path[l]> ah thanks
11:42:33 <Cale> Lambdabot hasn't had a maintainer in a long time, so you might find it takes a little bit of tweaking to get it to run just the way you'd like, but I didn't need to make so many changes.
11:43:04 <Cale> (I did however, make some changes to mueval -- it does some derpy things with timeouts)
11:43:11 <dmwit> Cale: Rumor has it that lambdabot has a maintainer now, and that they just made a release.
11:43:16 <Cale> oh, right
11:43:19 <dmwit> "just" meaning, like, this week
11:43:35 <Cale> Yeah, there were some people saying that they were going to pick it up and start working on it
11:44:11 <Cale> ah cool
11:44:17 <Cale> Perhaps I should upgrade :)
11:51:06 <Clint> damn, lots of new dependencies
11:52:23 <Botje> libxml shouldn't have that many.
11:52:53 <Botje> on my debian box it depends on four libraries.
12:16:53 <rondon> a
12:16:55 <rondon> hi
12:18:28 <rondon> Since #haskell is only academics can someone tell me where you write about your implementation ina thesis. in Method I describe how i performed the job, how i tested it etc. in results i describe the results of tests(duh). where do i write about the implementation? in its own chapter? or unde rboth method and result(disucssing in method and result in duh result)?
12:19:05 <ChongLi> #haskell isn't only academics!
12:19:18 <dgpratt> #haskell is only academics? shoot, no one told me about this requirement!
12:19:56 <dgpratt> HP 2012.2 requires the 'zlib C library'; any thoughts about what package I could install to satisfy that requirement?
12:20:17 <aristid> dgpratt: which system?
12:20:27 <dgpratt> er, 2013.2 actually, not that I think it matters
12:20:34 <dgpratt> aristid: Linux Mint
12:20:52 <aristid> dgpratt: search for libz-dev or something like that
12:20:58 <dgpratt> aristid: thanks
12:21:01 <aristid> apt-cache search libz
12:24:05 <dgpratt> aristid: libzip-dev, maybe?
12:24:41 <aristid> dgpratt: no
12:25:37 <irene-knapp> isn't it zlib
12:25:38 <irene-knapp> instead of libz?
12:25:49 <aristid> dgpratt: nevermind, it was zlib1g-dev
12:25:54 <aristid> at least on ubuntu
12:26:13 <dgpratt> aristid: ah, thanks
12:26:53 <aristid> dgpratt: why didn't you search for zlib yourself, before you asked what the package is? i actually guessed that it must be zlib because i assumed you had done so :D
12:27:07 <aristid> *guessed that it must be libz
12:28:01 <dgpratt> aristid: I found a package named 'Z lib C' and tried it, but it didn't seem to be right
12:28:05 <dgpratt> so then I asked
12:28:53 <aristid> dgpratt: zlib is the most commonly used data compression library.
12:28:55 <dgpratt> err...I guess it was named 'zlibc', but anyways
12:29:13 <aristid> http://zlib.net/ :)
12:29:54 <aristid> it's a rather bad name though, that is true
12:31:24 <canta> what is the generally recommended opengl library for trying out game-ish stuff? there is so much to choose, I'd rather just use something someone recommends.
12:31:27 <conal> Is there a variant of GHCi's :ty or another setting that shows explicit outer type forays in the case of polymorphism? I'm trying to figure out the order of quantification, for forming GHC Core type applications.
12:31:27 <lambdabot> conal: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:37:03 <byorgey> conal: I could have sworn lambdabot used to display type signatures in that format
12:37:15 <byorgey> but it doesn't seem to anymore
12:37:24 <byorgey> and I don't know how to make ghci display type signatures like that
12:37:26 <shachaf> byorgey: Yep, it used to and things changed.
12:37:29 <shachaf> There's a ghci option for it.
12:37:36 <byorgey> what's the ghci option?
12:37:40 <shachaf> :set -fprint-explicit-foralls
12:37:50 <shachaf> conal: ؝☝
12:37:52 <conal> byorgey: thankx.
12:38:03 <conal> shachaf: thanks. how did you remember/find that flag?
12:38:03 <byorgey> aha, it works!
12:38:15 <shachaf> conal: It's set in my .ghci!
12:38:26 <conal> shachaf: ah. :)
12:38:42 <shachaf> $ wc -l .ghci # 157 .ghci
12:38:54 <shachaf> Admittedly most of those are imports.
12:39:16 <byorgey> I was trying -XExplicitForAll  but that doesn't change the output format of :type, just whether it is allowed as an input format
12:39:26 <OrangeDuck> Hi all I'm writing some code to do with tree rewrite rules. Abstract Syntax Trees are the application but other trees are equally of interest. Does anyone know of a DSL type thing that uses a point free style to express these rules? Writing matches in point free style seems to be easy, but then specifying how to rewrite seems to be harder.
12:39:34 <monoidal> I'm ashamed to admit my first instinct after conal's question was to edit hsSyn/HsTypes.lhs
12:39:48 <nooodl_> shachaf: whoa. i really wanna see that .ghci
12:40:32 <dmwit> rondon: You didn't like my answer back when your nick was dontdoMDMA?
12:40:47 <FreeFull> `wc -l ~/.ghci`
12:40:47 <FreeFull> wc: /home/freefull/.ghci: No such file or directory
12:41:41 <shachaf> nooodl_: http://slbkbs.org/dotghci.txt
12:42:19 <FreeFull> lens tax?
12:42:39 <Taneb> Just realised
12:42:48 <Taneb> Free f a is a + f (Free f a)
12:42:54 <shachaf> Taneb: Yep.
12:42:57 <Taneb> Cofree f a is a * f (Cofree f a)
12:43:05 <shachaf> Yep.
12:43:08 <Taneb> They're virtually the same when you put them like that
12:43:36 <shachaf> Well, they're kind of opposite.
12:44:14 <tromp> it would be nice if Data.Ratio had a function returning a prefix and the repeating part of the decimal expansion
12:44:38 <shachaf> It would be nice only if it worked for an arbitrary base.
12:44:52 <FreeFull> Base 13 would be good
12:44:57 <FreeFull> No other bases necessary
12:45:07 <dmwit> tromp: Neat idea. I wonder how hard that is.
12:45:24 <tromp> it would sure help IBM Ponder This for this month:)
12:45:30 <Fuuzetsu> bos: Have you considered splitting attoparsec into attoparsec-text and attoparsec-bytestring? I see attoparsec-text in hackage but it's been deprecated and merged into main project.
12:46:16 <Michael__> How can I check if two instances of a data type have the same constructor, but can have different values?
12:46:21 <bos> Fuuzetsu: not really
12:46:54 <dmwit> tromp: Oh, well, it seems you need something even less stringent for the Ponder This, though.
12:46:56 <monoidal> in my never-started-doing file there's a project for a library for cyclic things in Haskell. for example, you can zipWith two eventually periodic lists, have a function iterate :: Finite a -> (a -> a) -> Cyclic a, rational number expansions, presburger arithmetic etc
12:47:18 <dmwit> tromp: You just need some halfway decent estimate of how far it goes before it starts repeating.
12:47:23 <monoidal> lots of things that are related to eventually cyclic lists, but they're not collected in one place
12:47:41 <tromp> Ponder This needs the repeating part
12:48:02 <dmwit> Yes, but it doesn't have to get the *earliest* repetition, which is what I would want if Data.Ratio supplied such a thing.
12:48:10 <dmwit> Just *an early* repetition.
12:48:16 <Fuuzetsu> monoidal: I thought someone already wrote a library for cyclic structures… Have I dreamt that up?
12:48:54 <tromp> the earlies would be what you get if you program it:)
12:49:09 <dmwit> Depends.
12:49:13 <monoidal> Fuuzetsu: there are things like observable sharing, some libraries for presburger but I don't know a library exactly for that
12:49:44 <dmwit> Like you might be able to, say, round up the denominator to the next power of ten and guarantee that things repeat after that.
12:49:50 <dmwit> (Don't actually know if that's true.)
12:50:02 <monoidal> also infinite automata often use eventually-periodic words
12:50:19 <dmwit> That would already probably be good enough for Ponder This, but it wouldn't get the *earliest* repetition for most things.
12:50:29 <byorgey> tromp, dmwit: I have some code lying around somewhere which does that...
12:50:37 <monoidal> dmwit: things repeat after denominator-1 iterations, and I believe this optimal (1/7 has 6 digits)
12:50:48 <dmwit> monoidal: That's not the question.
12:50:54 <dmwit> monoidal: The question is when they *start* repeating. =)
12:51:00 <tromp> basically,, you're computing powers of the base (e,g. 10) modulo the denominator, and seeing when the initial remainder re-appears
12:51:19 <dmwit> e.g. 1/6 never repeats its first digit
12:53:06 <tromp> right; dmwit, because the first digits is not a multiple of gcd(6,10)
12:53:06 <dmwit> byorgey: Do you have the paper that goes with it? (Or did you invent it yourself?)
12:53:38 <byorgey> dmwit: what? the algorithm for decomposing a rational into a prefix + repeating part?
12:53:50 <dmwit> yah
12:54:01 <byorgey> I wrote it myself, but it's pretty easy
12:54:09 <byorgey> (tromp just said it above)
12:54:10 <monoidal> dmwit: Given any rational, expand it to get a multiple of 99999...90..000
12:54:20 <monoidal> in the denominator
12:54:31 <byorgey> I found the code, I will paste it
12:55:03 <byorgey> https://gist.github.com/byorgey/5700933
12:55:20 <Athas> Is it a general convention that module Foo.Bar.Baz exports any module Foo.Bar.Baz.Quux beneath it?
12:55:23 <byorgey> no guarantees about the quality or fitness for any purpose, etc. etc. =)
12:55:27 <byorgey> Athas: no.
12:56:30 <Athas> byorgey: it seems rather common in the libaries I've looked at.  Will it confuse people if Foo.Bar.Baz.Quux imports Foo.Bar.Baz?
12:56:55 <Hafydd> Can't you people come up with a less embarrassing set of example names?
12:57:39 <byorgey> Athas: no one thinks much at all about which modules import which other ones in a library they are using, so no, it will not confuse people.
12:57:49 <Athas> It's a tradition.  Traditions are supposed to be embarassing!
12:58:59 <dmwit> Right, this makes sense.
12:59:34 <Fuuzetsu> bos_: are you able to build and run the tests for Attoparsec? It seems that one of the dependencies needed for tests is a package from 3 years ago that won't build (and the Makefile tries to output an .exe :P)
13:00:21 <anthezium> hey errbody
13:01:14 <anthezium> i have a newtype that's defined in module A, and I'd like to add a derived class that its base type has in another module B
13:01:21 <anthezium> is there a syntax for that?
13:01:47 <dmwit> You can use StandaloneDeriving, then write "deriving instance Class Newtype"
13:02:13 <anthezium> cool
13:02:13 <byorgey> you also need GeneralizedNewtypeDeriving
13:02:25 <dmwit> Not if it's really a derived class?
13:02:29 <dmwit> ...or maybe
13:02:30 <dmwit> yeah
13:02:38 <byorgey> ...but I guess maybe anthezium already knew that
13:03:05 <dmwit> I guess it probably depends on which class it is. You can probably derive Eq without that, for example. =)
13:03:14 <anthezium> is's not really a derived class
13:03:20 <anthezium> i'm adding Arbitrary instances in my test modules
13:03:41 <dmwit> Oh, okay, then yeah you definitely will need GND.
13:04:30 <anthezium> i have an integral type with bounded values, so i'm newtyping it, redefining the Bounded instance, then deriving an Arbitrary instance in the module that imports Test.QuickCheck
13:04:45 <byorgey> makes sense
13:04:59 <dmwit> hm
13:05:02 <byorgey> wait... no it doesn't
13:05:06 <dmwit> Perhaps you should handwrite your Arbitrary instance?
13:05:09 * hackagebot mongoDB 1.4.0 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  http://hackage.haskell.org/package/mongoDB-1.4.0 (FedorGogolev)
13:05:11 <byorgey> the derived Arbitrary instance won't do what you want, I think
13:05:21 <c_wraith> The Arbitrary instance for whatever type you're wrapping won't respect the Bounded instance
13:05:37 <tdammers> hey, what's the easiest way to get a list minus the last element?
13:05:42 <dmwit> :t init
13:05:42 <c_wraith> init
13:05:43 <lambdabot> [a] -> [a]
13:05:53 <tdammers> oh that was fast :x
13:06:05 <dmwit> :t ap (zipWith (const id)) (drop 1)
13:06:06 <lambdabot> [c] -> [c]
13:06:07 <anthezium> c_wraith: dayum u r right
13:06:34 <dmwit> > (ap (zipWith (const id)) (drop 1) [], init [])
13:06:36 <lambdabot>   ([],*Exception: Prelude.init: empty list
13:06:38 <tdammers> > init "foobar"
13:06:40 <lambdabot>   "fooba"
13:06:44 <monoidal> > init []
13:06:45 <lambdabot>   *Exception: Prelude.init: empty list
13:06:56 <tdammers> > reverse . drop 1 . reverse $ "foobar"
13:06:56 <dmwit> > ap (zipWith (const id)) (drop 1) "foobar"
13:06:57 <lambdabot>   "fooba"
13:06:57 <lambdabot>   can't find file: L.hs
13:06:59 <anthezium> c_wraith: so i can't avoid explicitly being like instance Arbitrary NewType where arbitrary = arbitraryBoundedIntegral?
13:07:03 <dmwit> > ap (zipWith (const id)) (drop 1) "foobar"
13:07:05 <lambdabot>   "oobar"
13:07:09 <dmwit> > ap (zipWith (const id)) (drop 1) [1..]
13:07:10 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
13:07:12 <anthezium> i wonder if that will even work
13:07:13 <c_wraith> anthezium: yeah, you'll need to do that one explicitly
13:07:13 <byorgey> anthezium: right
13:07:15 <dmwit> oops
13:07:25 <anthezium> that's sad
13:07:33 <dmwit> > ap (zipWith const) (drop 1) [1..]
13:07:35 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:07:36 <byorgey> anthezium: that will work if you derive Integral as well
13:07:36 <tdammers> anyway, init it is
13:07:38 <dmwit> There we go.
13:07:51 <c_wraith> Well, it needs to do something different than the wrapped type. That means you'll have to write different code for it
13:07:56 <dmwit> > reverse . drop 1 . reverse $ [1..] -- doesn't work
13:07:56 <tdammers> (\x -> take (length x) x) "foobar"
13:08:01 <lambdabot>  Terminated
13:08:05 <tdammers> > (\x -> take (length x - 1) x) "foobar"
13:08:13 <anthezium> byorgey: "that" being arbitrary = arbitraryBoundedIntegral
13:08:18 <byorgey> anthezium: yes
13:08:20 <lambdabot>   thread killed
13:08:36 <tdammers> dmwit: you broke lambdabot
13:08:39 <dmwit> didn't
13:08:40 <anthezium> haha
13:08:42 <anthezium> thanks
13:08:48 <dmwit> > "did I?"
13:08:49 <lambdabot>   "did I?"
13:09:00 <tdammers> alright alright
13:09:27 <anthezium> i guess it makes sense that derived behavior from the wrapped type would be the actual behavior for that type
13:10:20 <dmwit> But yes, ap (zipWith const) (drop 1) is lazy and total, unlike any of the other proposals so far.
13:10:52 <dmwit> Unfortunately, it is also 100% unreadable, unlike many of the other proposals.
13:10:55 <joelteon> so
13:11:04 <joelteon> that's init?
13:11:23 <dmwit> > (ap (zipWith const) (drop 1) [], init []) -- no
13:11:26 <lambdabot>   ([],*Exception: Prelude.init: empty list
13:11:29 <c_wraith> init is a custom function that takes advantage of the fact that it's bounded
13:11:39 <joelteon> so that's an init that doesn't throw an exception?
13:11:44 <dmwit> right
13:12:04 <c_wraith> init [x] = x ; init (x:xs) = x : init xs ; init _ = error "whatever empty list"
13:12:17 <anthezium> hm it still isn't respecting the bounds
13:12:25 <anthezium> maybe shrinkIntegral doesn't...?
13:12:50 <c_wraith> Oh.  for an integral type, I generally wouldn't implement shrink anyway
13:12:52 <FreeFull> :t init
13:12:53 <lambdabot> [a] -> [a]
13:13:02 <c_wraith> err, init [x] = []
13:13:07 <c_wraith> there you go
13:13:11 <c_wraith> I got a bit confused
13:14:00 <c_wraith> anthezium: shrink is used by quickCheck to attempt to generate minimal test cases. If changing the number doesn't make your test cases function differently, there's no need to implement shrink
13:14:34 <dmwit> :t ap
13:14:35 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:14:39 <dmwit> :t liftM2 ($)
13:14:40 <lambdabot> Monad m => m (a2 -> r) -> m a2 -> m r
13:14:48 <dmwit> ok
13:15:43 <anthezium> c_wraith: so when would I want to implement shrink?
13:15:57 <simon> > (1,2,3) ^. _3
13:15:59 <lambdabot>   3
13:16:11 <simon> where is ^. documented?
13:16:28 <dmwit> c_wraith: If changing the number doesn't make your test cases function differently, what's the point of the test cases?
13:16:45 <dmwit> Or rather, how do you know changing the number doesn't change the behavior if not by testing?
13:16:50 <Fuuzetsu> simon: it's from lens
13:16:57 <Fuuzetsu> @hoogle (.^)
13:16:58 <lambdabot> No results found
13:17:03 <Fuuzetsu> @hayoo (.^)
13:17:03 <lambdabot> Unknown command, try @list
13:17:06 <c_wraith> dmwit: well, structurally. If the number controls a number of iterations, shrink makes sense. If it's just a number you do some arithmetic on, shrink makes no sense.
13:17:14 <nooodl_> hey, does lens come with something like flipped (.) built-in?
13:17:18 <ChongLi> how often does hoogle update its index?
13:17:19 <nooodl_> the way it has & and <&>
13:17:24 <c_wraith> dmwit: remember, this is about *shrink*
13:17:26 <ChongLi> I noticed lens is not in hoogle at all
13:17:27 <FreeFull> http://hackage.haskell.org/package/lens
13:17:46 <Taneb> ChongLi, that particular hoogle instance is just the platform
13:17:49 <scriptor> what's the lambdabot command do it the source of something?
13:17:50 <c_wraith> dmwit: which isn't part of how quickcheck finds problems in the first place. It's just about creating reduced test cases after it finds a problem
13:17:54 <dmwit> c_wraith: shrink is about taking a failing test case and finding a more minimal failing test case. Why wouldn't you want shrink to find small numbers that make your test cases fail?
13:17:56 <simon> FreeFull, what is the difference between "lens" and "lenses"?
13:17:58 <Taneb> ChongLi, try https://www.fpcomplete.com/hoogle
13:18:02 <Fuuzetsu> Huh, apparently it's not from lens
13:18:02 <ChongLi> Taneb: ahhh
13:18:11 <simon> FreeFull, I mean, it seems that there are two packages.
13:18:12 <nooodl_> Fuuzetsu: ^. isn't .^
13:18:20 <c_wraith> dmwit: if changing the numbers doesn't *reduce* the test case, then shrink should do nothing with them.
13:18:21 <Fuuzetsu> oh, oops
13:18:23 <dmwit> I'd rather see "Foo 3 3" than "Foo 2359184 -5234875".
13:18:28 <ChongLi> Taneb: wow that's a nice hoogle
13:18:34 <Fuuzetsu> http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/Control-Lens-Getter.html#v:-94-%2E
13:18:40 * ChongLi updates his search shortcut
13:18:47 <dmwit> c_wraith: Define "reduce".
13:18:57 <Taneb> (fpcomplete's Hoogle is based on the Stackage project)
13:19:01 <dmwit> c_wraith: For me, "reduce" includes how many digits my stupid input has.
13:19:02 <Fuuzetsu> oo, that's really nice
13:19:03 <simon> Fuuzetsu, thanks. :)
13:19:04 <c_wraith> dmwit: make the structure of the computation smaller
13:19:16 <dmwit> If 0 makes things fail, that's better than basically any other input I could possibly think about.
13:19:33 <c_wraith> fortunately for you, quickcheck likes to start with small numbers, so you're fine anyway
13:19:44 <FreeFull> I often wish for the ability to search through types of functions currently in scope in ghci
13:19:49 <dmwit> c_wraith: I find your argument unconvincing. shrink is about making it easier for the programmer to understand what went wrong, and I as a programmer want to think about small numbers.
13:20:39 <dmwit> Just because it's easier for me to spot the difference between 1 and 2 than it is for me to spot the difference between 924524931 and 924524932.
13:21:23 <dmwit> FreeFull: :browse will at least list the types of functions currently in scope.
13:21:57 <FreeFull> dmwit: But no search
13:22:03 <dmwit> Well, it will list the types of functions in scope by import. And yes, no search.
13:25:12 <Fuuzetsu> can anyone see whether they can compile regex-base?
13:35:47 <tommd> I've ran into the use of {read,write}RawBufPtr from GHC.IO.FD for Windows - can someone explain what this does and why it is needed?  I'd like to understand it as it appears I must patch it.
13:38:10 <Athas> I have a module, Language.L0.Syntax, that defines the AST for my language.  Purely type definitions, for clarity.  I also have another module, currently named Language.L0.Queries, that defines various constants and handy functions for inspecting the AST.  I don't like the name "Queries", though, because it's also various construction functions.  Any suggestions for another name?
13:42:38 <ezyang> Is there a way to define polymorphic lists using only Mu :: (* -> *) -> *?
13:43:28 <Saizan> ezyang: yeah, you abstract the type parameter outside
13:44:22 <ezyang> oh, I see
13:44:32 <Eduard_Munteanu> Much like using fix, actually.
13:45:08 <ezyang> Huh, so does that mean kind polymorphic fix is unnecessary?
13:45:21 <Saizan> it's necessary for fancier stuff
13:45:41 <Saizan> like those "nested recursive" or inductive families
13:45:46 <ezyang> Why can't you just do the same trick?
13:45:51 <Eduard_Munteanu> Not sure what that is, but I guess it's some sort of equirecursive fix? :/
13:46:13 <ezyang> Oh, nested recursion?
13:46:28 <Eduard_Munteanu> With Mu you'll get the pesky Mu constructors in there.
13:47:20 <Saizan> i meant non-regular rather than nested
13:47:22 <ezyang> I can't remember what nested recursion is
13:47:25 <ezyang> Ah, there we go.
13:48:01 <Eduard_Munteanu> @src Mu
13:48:01 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
13:48:07 <Eduard_Munteanu> I assume we're talking about that.
13:48:10 <byorgey> data T a = Leaf a | Trunk (T (a,a))
13:48:10 <Saizan> e.g. data Tree a = Leaf a | Branch (Tree (a,a))
13:48:31 <tromp> thank, byorgey; I just submitted my Ponder This solution, found with help from your toDecimal:)
13:48:58 <ezyang> data T a f = L a | T f
13:49:00 <ezyang> Hmmmm
13:49:17 <byorgey> tromp: excellent, I expect to receive a cut of your winnings ;-)
13:49:18 <Eduard_Munteanu> ezyang: you probably want T f a though
13:49:25 <ezyang> data T a f = L a | T (f (a, a))
13:49:50 <Eduard_Munteanu> Such that Mu T a ~ Tree a
13:49:51 <tromp> sure, you can have half
13:49:54 <ezyang> That probably would do the trick... only needs ((* -> *) -> (* -> *)) -> * -> *
13:49:59 <ezyang> data T f a, I mean
13:54:01 <cmo> what do i do if a function is in both mtl and transformers? is it possible to cabal use whatever's installed?
13:54:28 <bitonic> cmo: if mtl is installed, transformers is installed.
13:54:44 <Eduard_Munteanu> And they're not exactly the same.
13:54:51 <bitonic> in other words, if you can depend on transformers only, depend on transformers only
13:55:05 <Eduard_Munteanu> mtl2 is nicer though
13:56:41 <bitonic> cmo: mtl defines type classes on top of transformers’ data types
13:57:23 <cmo> ok so ill use transformers
13:58:19 <fruitFly> anyone here use sublimeHaskell? I'm having an error: "SublimeHaskell: Failed to compile ModuleInspector   C:\Users\rich\AppData\Roaming\Sublime Text 2\Packages\SublimeHaskell\ModuleInspector.hs:25:18:      Could not find module `Documentation.Haddock'      Use -v to see a list of the files searched for."
13:59:27 <dmwit> Fuuzetsu: Hm, I didn't build it just now, but I have regex-base-0.93.2 in my local package database.
13:59:46 <dmwit> So the latest release on Hackage must build here. =)
14:00:25 <Fuuzetsu> dmwit: I managed to solve it. I had to rebuild my mtl with --enable-shared.
14:00:49 <Fuuzetsu> I have a different problem now… Duplicate instance declarations in test-framework package ;;
14:02:33 <Peaker> Did anyone write a nice GUI IRC client in Haskell?  I hate xchat
14:03:05 <cmo> i'm trying out weechat and i hate it
14:03:09 <Fuuzetsu> Peaker: sounds like you're volunteering!
14:03:10 <bitonic> Peaker: is the ‘GUI’ a requirement?
14:03:19 <bitonic> cmo: weechat is great!
14:03:27 <bitonic> but as an emacs person I go with eRC
14:03:29 <bitonic> *ERC
14:03:34 <Fuuzetsu> ^
14:03:36 <fruitFly> everytime is see bitonic  I think bitcoin
14:03:44 <cmo> how do i get rid of the square bracketed messages after every line
14:04:09 <cmo> what are they called so i can figure out where to look
14:04:10 <Peaker> bitonic, Yeah, I don't want it in a terminal..  Hard to use the pixels properly
14:04:22 <bitonic> Peaker: what do you mean?
14:04:43 <Eduard_Munteanu> Peaker: arguably CLI clients are considerably more space-efficient for stuff like xmonad
14:04:44 <Peaker> bitonic, For example, smaller text for the user list than for the channel text.. nice visual indicators around important things like the topic or inserted text
14:04:59 <Eduard_Munteanu> Hm.
14:05:03 <merijn> Fuuzetsu: Peaker doesn't have time to write one, he needs to go back to lamdu :p
14:05:09 <Peaker> merijn, that's true :)
14:05:10 <Eduard_Munteanu> I'd also like to try proportional fonts in IRC.
14:05:12 <bitonic> Peaker: ah.  well, you can have all those things in emacs ehe
14:05:20 <merijn> Peaker: I should start charging you for doing your PR for you!
14:05:35 <Fuuzetsu> merijn: so many projects, so little time
14:05:52 <merijn> lamdu > yet another IRC client :p
14:06:07 <merijn> I still haven't solved the "no main" issue, though
14:06:13 <Peaker> merijn, https://github.com/Peaker/lamdu/graphs/commit-activity
14:06:18 <merijn> It's odd, because I had it working before I upgraded to the new platform
14:06:41 <Peaker> had a long period of much less activity, but now back in action for a few weeks now :)
14:06:45 <Fuuzetsu> What's that cabal flag that lets me pass in the compiler options?
14:06:48 <Tinned_Tuna> Evening
14:07:22 <Peaker> merijn, can you look at the obj files with "objdump" or such to figure out whether main is in there?
14:07:29 <Peaker> Fuuzetsu, --with-ghc-options
14:07:32 <Tinned_Tuna> So, Python's "standard" dev env. is git, virtualenv, some form of unittest (i use nose), etc. Is there a similarly "standard" way of doing development in haskell?
14:07:47 <Tinned_Tuna> and where can I find documentation on it?
14:07:48 <Peaker> Fuuzetsu, or in the Library/Executable sections in .cabal file: ghc-options: ...
14:07:55 <merijn> Peaker: hmm, I'm now getting this error
14:07:56 <merijn> "bottlelib/Graphics/UI/Bottle/MainLoop.hs:44:19: No instance for (Data.StateVar.HasSetter GL.StateVar)"
14:07:59 <Fuuzetsu> Peaker: ah, that's what I was thinking of. I couldn't see it in --help
14:08:05 <Peaker> merijn, you're not on newest master..?
14:08:07 <tgeeky> Tinned_Tuna: git, hsenv (or cabal-dev), and quickcheck/smallcheck/hunit
14:08:17 <Peaker> merijn, "towards_get_field" branch died, merged to master
14:08:27 <merijn> Peaker: You told me to use towards_get_field last time :p
14:08:30 <merijn> I'll update
14:08:35 <Peaker> merijn, yes, we've progressed since :)
14:08:40 <tgeeky> merijn: well you should have listened!
14:08:50 <cmo>     /filter add joinquit * irc_join,irc_part,irc_quit *
14:08:51 <cmo>     /filter add joinquit * irc_join,irc_part,irc_quit *
14:08:54 <cmo>     /filter add joinquit * irc_join,irc_part,irc_quit *
14:08:57 <Peaker> merijn, since yesterday the branch finally has no regressions compared to master, and much much improvement, so it was merged
14:08:58 <Peaker> @ops
14:08:58 <lambdabot> Maybe you meant: docs oeis pl
14:09:00 <cmo>     /filter add joinquit * irc_join,irc_part,irc_quit *
14:09:01 <cmo>     /filter add joinquit * irc_join,irc_part,irc_quit *
14:09:03 <cmo>     /filter add joinquit * irc_join,irc_part,irc_quit *
14:09:06 <bitonic> cmo: you’re doing it wrong
14:09:10 <cmo>     /filter add joinquit * irc_join,irc_part,irc_quit *
14:09:12 <cmo>     /filter add joinquit * irc_join,irc_part,irc_quit *
14:09:14 <Tinned_Tuna> tgeeky: cool, thanks :-)
14:09:14 <cmo>     /filter add joinquit * irc_join,irc_part,irc_quit *
14:09:16 <cmo>     /filter add joinquit * irc_join,irc_part,irc_quit *
14:09:17 <Eduard_Munteanu> @where ops
14:09:17 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
14:09:17 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
14:09:19 <cmo>     /filter add joinquit * irc_join,irc_part,irc_quit *
14:09:27 --- mode: ChanServ set +o glguy
14:09:42 <glguy> seems to have stopped
14:09:42 --- mode: ChanServ set +o geekosaur
14:09:55 <tgeeky> cmo: we hope that was a mistake
14:09:58 --- mode: geekosaur set -o geekosaur
14:10:16 <tgeeky> cmo: a horrible, horrible accident caused by swamp gas and a stray kitten
14:10:48 <cmo> gah! i think im switching to a different client, sorry guys
14:11:52 <tgeeky> on behalf of #haskell, apology accepted.
14:12:11 <fruitFly> I just downloaded the newest haskell platform, what here don't I have, I know haddock, anything else? : cabal Cabal packages: base, bytestring, aeson, haskell-src-exts, haddock (cabal install aeson haskell-src-exts haddock)
14:12:32 <fruitFly> do I have cabal? and which of those packages don't I have?
14:12:43 <Eduard_Munteanu> @where platform
14:12:43 <lambdabot> http://hackage.haskell.org/platform/
14:12:43 <tgeeky> fruitFly: give us output in hpaste, not in IRC
14:12:51 <tgeeky> fruitFly: you sould have ~ 40 to 50 packages
14:13:35 <Eduard_Munteanu> http://lambda.haskell.org/platform/doc/current/frames.html   should give you a "list" of packages
14:13:48 <fruitFly> http://hpaste.org/89253
14:13:50 <Eduard_Munteanu> And yeah, cabal is surely there.
14:13:50 <monochrom> Haskell Platform comes with base, bytestring, haddock. in fact, GHC alone already does.
14:14:07 <monochrom> Haskell Platform also comes with cabal-install
14:14:22 <merijn> Peaker: ! It build!
14:14:31 <merijn> Well, it crashed but on the well known iconv issue
14:14:31 <Peaker> merijn, cool
14:14:42 <Peaker> I forget the iconv issues..
14:15:02 <tgeeky> is someone on Windows?
14:15:20 <fruitFly> monochrom: r u sure it comes with haddock? because sublimeText is telling me it could not find documentation.haddock ... just in the last post here https://github.com/SublimeHaskell/SublimeHaskell/pull/59
14:15:30 <monochrom> yes I am absolutely sure.
14:15:44 <merijn> Peaker: MacPorts links to a different iconv than GHC, so linking C libraries from macports against GHC means you have to do a precarious linker flag reordering dance to please the linker
14:16:16 <merijn> "Installed lamdu-0.1"
14:16:19 <merijn> \o/
14:16:50 <fruitFly> from where do i execute cabal commands?
14:17:02 <fruitFly> just in terminal like this: "cabal install aeson haskell-src-exts haddock"
14:17:06 <Eduard_Munteanu> So what's the state of Haskell on Android lately? Can I get a mere armhf build for a real Linux chroot?
14:17:10 <tgeeky> fruitFly: exactly like that
14:17:28 <Peaker> merijn, :)
14:17:37 <Peaker> merijn, if you had a lamdu database before, you should lamdu -deletedb
14:17:54 <Peaker> merijn, the database format keeps on changing, and we don't bother writing migrations at this point, of course :)
14:18:31 <ion> Are there lamdu demo videos somewhere?
14:19:02 <Peaker> ion, not yet, and they probably wouldn't play at 60FPS so wouldn't do it justice :)
14:19:12 <ion> heh
14:19:23 <Peaker> ion, we're still too preliminary so don't want a large audience to expect too much and be disappointed
14:21:00 <merijn> Peaker: So, when are you going to start dogfooding? ;)
14:22:11 <Peaker> merijn, when it is usable for more than little toys :)
14:22:17 <Peaker> when the language is complete enough, too
14:22:31 <Peaker> we don't have sum types/pattern matching or recursive types yet
14:23:33 <Peaker> after the type system and UI for it have all those, the language is relatively complete enough to do lamdu itself, I think. but then we have some scalability issues we'll need to solve (the smart completions are naive - and type-check all possible definitions, which won't scale)
14:23:35 <fruitFly> my sublime text cannot find Documentatio.haddock , so I'm trying to execute the command in the last requirment here https://github.com/SublimeHaskell/SublimeHaskell but I'm getting "config file path source id default config file. ... config blah blah not found....  package list does not exist.
14:24:36 <Peaker> We're going to need hoogle-style indexing/quick searching of relevant types for the smart completions.. but we want it to be less heuristic than hoogle (IIUC, hoogle has some false negatives for more general types that could fit but don't)
14:29:42 <merijn> Oh well, speaking of editors. You guys here should crowdfund my attempt to write less sucky auto-indent and code folding for haskell in vim!
14:30:01 <merijn> Maybe if paying people bug me enough I'll stop procrastinating >.>
14:30:08 <fruitFly> omg .. can any saviour help this noob .. "cabal install aeson haskell-src-exts haddock" does not work for me .. how do I copy the error from cmd? I just stated it above
14:30:53 <Eduard_Munteanu> fruitFly: select stuff in the terminal and middle-click to paste
14:31:19 <barrucadu> fruitFly: Is the error message telling you to run `cabal update`? If so, do that
14:31:23 <Eduard_Munteanu> Or do something like   cabal install aeson haskell-src-exts haddock 2>&1 | wgetpaste
14:32:24 <fruitFly> barrucadu: it is, i'll try
14:34:04 <Fuuzetsu> Can I make cabal-install ignore duplicate instance declarations?
14:34:10 <fruitFly> barrucadu: I thought I had the latest cabal stuff since I just installed haskell, guess maybe not
14:35:05 <monochrom> Fuuzetsu: that would be the job of GHC, not cabal-install. and GHC would refuse.
14:35:25 <fruitFly> what do you think is a time frame for haskell adoption rate in production to tip?
14:35:55 <monochrom> you can only do this: the source code imports fewer modules, or the *.cabal file says depends on fewer packages
14:38:05 <Fuuzetsu> monochrom: I don't think I can do that… It detects instances in System.Console.Runner an the package test-framework-quickcheck2 defines its own. I can comment out the ones in quickcheck2 and it compiles fine but anything that tries to use it complains about bad interface file (so the instances are clearly not the same, right?)
14:39:40 <fruitFly> barrucadu: I did... now should I try the original command?
14:39:45 <monochrom> bad interface file is an orthogonal problem
14:39:47 <barrucadu> fruitFly: Yes
14:40:38 <Fuuzetsu> monochrom: Well, I'm at loss with what to do in this situation then…
14:40:40 <fruitFly> barrucadu: oo myy// looks to be working :)
14:40:58 <Fuuzetsu> I filed a bug with test-framework guys but I'm not even sure if I'm barking up the right tree.
14:46:31 <vvein_> how do I calculate a log from an Integer? TIA
14:46:54 <Fuuzetsu> > log 5
14:46:56 <lambdabot>   1.6094379124341003
14:47:51 <int-e> vvein_: have a look at fromIntegral
14:47:52 <dwcook> @type log . fromInteger
14:47:53 <lambdabot> Floating c => Integer -> c
14:47:56 <int-e> @type fromIntegral
14:47:57 <lambdabot> (Integral a, Num b) => a -> b
14:47:57 <monochrom> > log (fromIntegral (5 :: Integer))
14:47:59 <lambdabot>   1.6094379124341003
14:48:07 <monochrom> @quote monochrom fromIntegral
14:48:07 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
14:48:30 <int-e> @quote realToFrac
14:48:31 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
14:48:44 <vvein_> int-e: it's just my Integral has like 10000 digits
14:49:05 <Fuuzetsu> I think this is the only channel where jokes about converting numbers are a thing.
14:49:25 <int-e> vvein_: ok, that is a bit challenging for doubles :)
14:49:27 <monochrom> I don't think Double can handle that
14:49:38 <int-e> vvein_: is the base of the logarithm an integer?
14:49:42 <vvein_> hence the question :)
14:50:02 <vvein_> well, I want to use (logBase 10)
14:50:07 <c_wraith> if the base is an integer, you can do repeated division
14:50:46 <vvein_> ok, I will look that up. Thanks ! :)
14:50:49 <monochrom> you will need your own algorithm or copy one from a book or the web
14:50:54 <int-e> but you can do better: to find the logarithm at base b, first find the logarithm at base b^2.
14:51:10 <monochrom> oh yikes, that's smart
14:51:53 <monochrom> but wait, how do I find the log at base b^2?
14:53:10 <vvein_> but the log function won't let me use this number
14:53:30 <vvein_> any function that operates on double won't let me call itself, right?
14:53:47 <monochrom> I don't understand the question
14:54:06 <scottj> In emacs haskell-mode if I import (for example) Text.HTML.TagSoup then it doesn't display the type signature for parseTags in the echo area with haskell-doc-mode like it does for Prelude functions. Anyone know how to enable that?
14:54:12 <int-e> > let il b n | n < b = (0,n); il b n = let (l,n') = il (b^2) n in if n' >= b then (2*l+1, n' `div` b) else (2*l, n'); intLog b n = fst (il b n) in intLog 10 (2^100000)
14:54:13 <lambdabot>   30102
14:54:23 <monochrom> and it does not help that I'm reading a paper with a diagonalization self-call argument!
14:54:34 <int-e> > length (show (2^1000000))
14:54:36 <lambdabot>   301030
14:54:43 <int-e> > length (show (2^100000))
14:54:44 <lambdabot>   30103
14:54:44 <int-e> oops.
14:55:13 <int-e> monochrom: see that code; just call the function recursively. :)
14:56:09 <vvein_> int-e: thanks a lot :)
14:56:13 <monochrom> scottj: that feature is based on hardcoding a suite of type sigs in haskell-doc.el
14:56:25 <scottj> monochrom: thanks
14:59:46 <int-e> (the real trick is the second return value of 'il' -- it is the topmost digit of n in base b representation, which is all you need to refine the logarithm from base b^2 to base b)
15:02:16 <scottj> monochrom: are you aware of a package that provides type sigs more generally?
15:02:37 <scottj> as you're typing in the echo area that is
15:03:40 <monochrom> ghc-mod
15:04:23 <monochrom> ghc-mod works in emacs and calls up ghc to query names and types on the fly
15:05:07 <monochrom> therefore for example it may even offer auto-complete but I am not sure, haven't tried.
15:05:14 <scottj> monochrom: cool, thanks
15:09:12 <merijn> Does anyone know if there's something like "stdinFd :: Fd" defined anywhere?
15:09:52 <int-e> @type System.Posix.stdInput
15:09:54 <lambdabot> System.Posix.Types.Fd
15:12:32 <merijn> @index System.Posix.stdInput
15:12:32 <lambdabot> bzzt
15:12:35 <merijn> hmmm
15:12:51 <geekosaur> @index stdInput
15:12:51 <lambdabot> System.Posix.IO, System.Posix
15:13:19 <merijn> Ugh, I could've sworn I looked at that >.<
15:19:09 <dmwit> ?index stdin
15:19:10 <lambdabot> System.IO
15:19:24 <dmwit> oh
15:19:26 <merijn> dmwit: That's something different, though
15:19:40 <merijn> stdin :: Handle, stdInput :: Fd
15:20:04 <merijn> And using handleToFd to obtain a file descriptor closes the handle, so that's undesirable
15:21:06 <dmwit> Hence the "oh". =)
15:23:44 <merijn> Time to quote my own code: "cantHappen = userError "Uh-oh! Something different went horribly wrong!""
15:30:48 <Fuuzetsu> @quote impossible
15:30:48 <lambdabot> shapr says: Academics are continually chewing pieces off of impossible and making them merely difficult.
15:32:29 <joelteon> cantHappen = error "invariant varied!"
15:32:44 <merijn> Well, my "can't happens" are usually of the calibre "this could happen, but if ever comes that far things are so horribly f-ed that this programming crashing is the least of our worries"
15:33:08 <joelteon> I mean, you could make it grammatically correct and call it can'tHappen
15:33:18 <monochrom> hehe
15:33:21 <merijn> I guess I could make it "cantHappen = userError "Congratulations! You have found a bug in your operating systems posix libraries!""
15:33:35 <merijn> joelteon: Oh, yeah, I forgot that's a valid identifier in Haskell :p
15:33:45 <joelteon> can'tHappen = error "eventfd: function not implemented"
15:34:09 <monochrom> @let can't_happen = error "the impossible has happened"
15:34:11 <lambdabot>  Defined.
15:34:36 <joelteon> @let can'tHappen = error "please choke on a bucket of roosters"
15:34:38 <lambdabot>  Defined.
15:34:55 <merijn> I'm going to try this question again
15:35:21 <merijn> The Haddock documentation says that partial reexports will be embedded in the generated documentation, but this is not happening for me
15:35:25 <merijn> How come? :(
15:36:21 <monochrom> I don't know, because I haven't tried.
15:37:15 <Fuuzetsu> merijn: They should be embedded fine. Ensure that you're looking at the correct module.
15:37:25 <merijn> Fuuzetsu: There is only one module
15:37:25 <Fuuzetsu> It might have been generated elsewhere
15:37:28 <Fuuzetsu> Hmm.
15:37:38 <merijn> The only thing I'm getting is a link "module System.Posix.Terminal"
15:38:42 <merijn> Oh, bah
15:39:01 <merijn> It only happens if you explicitly list everything you're reexporting
15:39:16 <Fuuzetsu> Yes. What behaviour did you expect?
15:39:16 <merijn> Well, that makes it completely useless
15:39:31 <merijn> Fuuzetsu: I'm exporting module with some functions hidden
15:39:50 <merijn> i.e. using "module Foo" export syntax
15:40:03 <merijn> I was expecting it to list everything not hidden from Foo
15:42:05 <merijn> Having to explicitly list everything kinda defeats the purpose
15:44:00 <monochrom> look at the bright side. explicit listing lets you control order of appearance in the doc, add section headers, etc :)
15:49:36 <merijn> monochrom: I'm not going to manually list 30+ functions and datatypes...
15:51:02 <monochrom> I guess there is also the false advertising problem. the doc says "module Foo", therefore you think all of Foo is re-exported, but it is not.
15:52:44 <merijn> Well, to be fair only 10 functions are not reexported, 8 of which have identically named (but differently typed) versions exported and 2 which should be obsoleted :p
15:53:22 <Fuuzetsu> Patches welcome ;)
15:53:39 <monochrom> the keeper of haddock has spoken!
15:53:57 <merijn> I'll put it in the queue
15:54:17 <merijn> Right now, after I finish this yak shaving library I need to implement proper folding and autoindenting for Haskell in vim
15:54:48 <monochrom> join emacs to skip that step
15:54:52 <Fuuzetsu> merijn: you know what would be a really cool project? Adding more ByteString stuff to Attoparsec! Think how exciting that is. You should totally do it ;)
15:55:20 <merijn> Haddock coverage: 100% ( 25 / 25) in 'System.Posix.Pty'
15:55:21 <merijn> \o/
15:56:30 <merijn> Fuuzetsu: What's stopping you? :p
15:57:06 <Fuuzetsu> Duplicate instances in test-framework-quickcheck2
15:57:17 <merijn> Fuuzetsu: So fix that first! :p
15:57:18 <Fuuzetsu> I mean, test-framework
15:57:41 <Fuuzetsu> merijn: My genius plan of ‘just comment it out’ didn't do that well.
15:58:51 <merijn> Fuuzetsu: Learning experience!
15:59:24 <Fuuzetsu> merijn: Yes, I can't say it wasn't but I'd like to write some code for Haddock some time in near future.
15:59:49 <merijn> Fuuzetsu: What makes you think it won't break the same way for me? :p
16:00:56 <Fuuzetsu> merijn: Maybe you're fearless enough to proceed without the testing suite. Also the chances are it might not break for you, I've been having all kinds of issues over the last few days with packages
16:01:07 <Fuuzetsu> I'm getting to know cabal far closer than I'd like to.
16:01:52 <Fuuzetsu> I feel as if I should document my findings seeing as there was no clear help online that I could find…
16:02:41 <merijn> Fuuzetsu: Did you see the SICP and cabal-cabal links yet?
16:03:37 <Fuuzetsu> Yes, but I can't say I studied them in great detail.
16:03:42 <Fuuzetsu> Perhaps I should.
16:05:18 * hackagebot data-interval 0.3.0 - Interval arithmetic for both open and closed intervals  http://hackage.haskell.org/package/data-interval-0.3.0 (MasahiroSakai)
16:05:36 <Fuuzetsu> :t f x (h x)
16:05:38 <lambdabot>     Ambiguous type variable `t0' in the constraints:
16:05:38 <lambdabot>       (Show t0) arising from a use of `f' at <interactive>:1:1
16:05:38 <lambdabot>       (FromExpr t0) arising from a use of `h' at <interactive>:1:6
16:06:01 <Fuuzetsu> :t f = g x (h x)
16:06:03 <lambdabot> parse error on input `='
16:06:07 <Fuuzetsu> :t let f = g x (h x)
16:06:08 <lambdabot> <no location info>: not an expression: `let f = g x (h x)'
16:06:10 <Fuuzetsu> :t let f = g x (h x) in f
16:06:11 <lambdabot>     Ambiguous type variable `t0' in the constraints:
16:06:11 <lambdabot>       (Show t0) arising from a use of `g' at <interactive>:1:9
16:06:11 <lambdabot>       (FromExpr t0) arising from a use of `h' at <interactive>:1:14
16:06:12 <merijn> Fuuzetsu: The basic rules are: only use cabal for installing, upgrade infrequently (i.e. when the new platform comes out or something) and don't install global
16:06:15 <Fuuzetsu> …
16:07:27 * merijn has yet to have anything break with that approach
16:07:57 <Fuuzetsu> merijn: Unfortunately I have to use a fairly new GHC for Haddock stuff which means that the ‘upgrade infrequently’ option is a no-no
16:08:14 <pqmodn> :t let f x = g x (h x) in f
16:08:15 <lambdabot>     Ambiguous type variable `t0' in the constraints:
16:08:15 <lambdabot>       (Show t0) arising from a use of `g' at <interactive>:1:11
16:08:15 <lambdabot>       (FromExpr t0) arising from a use of `h' at <interactive>:1:16
16:08:30 <merijn> Fuuzetsu: Why? Having a new GHC doesn't require you to update cabal frequently
16:08:49 <merijn> Fuuzetsu: I have GHC-7.7.something build installed too, works just fine
16:08:50 <Peaker> merijn, so, did you toy with it?  Made some record vals/types? Saw the named params? Param presentation modes?
16:09:29 <merijn> Peaker: Not yet, I've been busy forcing myself to finish documenting my initial version of a pty control library so I can put it on hackage
16:09:43 <merijn> Just need to spell check my documentation and I should be done
16:09:52 <Peaker> merijn, I put on hackage first, ask questions later :)
16:10:26 <Fuuzetsu> merijn: Oh, you meant upgrade cabal. Then no, I don't tend to do that much at all.
16:11:08 <merijn> Fuuzetsu: Since GHC uses a different package database for each GHC version having a bunch of different and bleedig edge GHC's installed shouldn't cause any problems
16:11:22 <Fuuzetsu> Yes.
16:11:28 <merijn> Fuuzetsu: linux package manager are a good way to break things, though
16:11:55 <Fuuzetsu> merijn: Which is why I got help here few days ago and purged everything to do with Haskell that I had installed globally.
16:12:39 <merijn> Peaker: I'm a perfectionist :\
16:20:31 <merijn> hmmm
16:20:36 <merijn> Grammar check
16:20:49 <merijn> This sentence feels clunky: "The terminal write queue contains the data that was written from the slave terminal, which was not send to the master yet."
16:21:14 <edwardk> preflex: xseen tibbe
16:21:15 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
16:22:02 <preflex>  tibbe was last seen on freenode/#haskell 13 days, 6 hours, 37 minutes and 48 seconds ago, saying: sendWith is a bit shorter
16:22:16 <edwardk> @tell lispy there is something set up that logs the committee emails. do you know how that was configured?
16:22:16 <lambdabot> Consider it noted.
16:22:24 <Peaker> merijn, not senT to the master
16:22:31 <koala_man> "The terminal write queue contains data that was input on the slave terminal, but has not yet been sent to the master" ?
16:24:11 <merijn> koala_man: "input" is ambiguous, because the data read from the slave terminal is input too
16:25:07 <koala_man> merijn: it's used as a verb
16:27:12 <merijn> koala_man: I know, but I'd like to avoid words that are ambiguous because I had to read the manual page 10 times to figure out whether I had it correct and I'd like to save people the effort :p
16:27:23 <alexander__b> is there a quicksort function that I can import?
16:27:32 <merijn> :t sort
16:27:33 <lambdabot> Ord a => [a] -> [a]
16:27:44 <alexander__b> so that's standard quicksort? neat
16:27:51 <merijn> Not sure which sort it is
16:27:59 <merijn> alexander__b: Why do you need quicksort specifically?
16:28:00 <bitonic> it’s a lazy mergesort
16:28:10 <alexander__b> merijn: just wondering if haskell has it
16:28:12 <koala_man> merijn: fair enough. "written by the user of the slave terminal"? dunno
16:28:17 <bitonic> alexander__b: quicksort doesn’t really make sense if you don’t sort in-place
16:28:29 <bitonic> and with [], you’re not going to sort in place
16:28:37 <merijn> alexander__b: You could write it, but it'd be inefficient
16:28:50 <alexander__b> merijn: I know I can write it. in 1000 different ways.
16:29:16 <merijn> alexander__b: The default sort is implemented using mergesort
16:30:04 <merijn> koala_man: Well, I was worried more about the ", which" bit, which feels a bit clunky. But that might just be the result of me staring at the formulation for like 15 minutes :p
16:30:17 <merijn> If you thought it reads ok I guess it's fine
16:30:43 <bitonic> again, quicksort doesn’t really make sense for [], for more than one reason
16:31:55 <tabemann> couldn't one implement a qujcksort that is implemented in terms of STArrays?
16:32:07 <copumpkin> I really like how the mergesort works in the prelude
16:32:15 <copumpkin> very simple, no random access into lists
16:32:18 <bitonic> tabemann: yes, one could
16:33:04 <monochrom> wait, the Prelude doesn't have sort. if you mean the report, it uses insertion sort.
16:34:11 <copumpkin> I mean the implementation we have in base
16:34:14 <copumpkin> so Data.List
16:34:26 <monochrom> alright, base's sort is awesome
16:35:37 <acowley> Whenever I think I should use ^, I run into the Integer default and get annoyed
16:37:26 <enthropy> just disable that warning
16:37:32 <tabemann> acowley: ^ is implemented through repeated multiplication, ** uses the floating point operation
16:38:21 <acowley> tabemann: I think I want it to be an Int, but the Warning sets off all my dev alarms no matter what I want it to be.
16:38:26 <monochrom> don't forget ^^ which uses repeated division ^_^
16:38:45 * tabemann didn't know about ^^
16:39:01 <acowley> I just want to write x^5 and not be made to feel inferior by GHC's warnings about my lack of precision.
16:39:31 <tabemann> as if one actually needed bignums for most things
16:40:47 <monochrom> then you need to see http://thread.gmane.org/gmane.comp.lang.haskell.cafe/105573
16:41:16 <acowley> I liked the request for proof that the change isn't warranted
16:41:50 <acowley> It's like a preemptive citation required.
16:42:23 <frankbro> Anyone knows if there is a library giving a similar implementation of the erlang actor model for haskell?
16:43:19 <nexx> I think I heard of a library to "implement erlang" in haskell. But I don't remember a name
16:43:21 <ChongLi> frankbro: cloud haskell
16:43:34 <ChongLi> http://www.haskell.org/haskellwiki/Cloud_Haskell
16:44:10 <nexx> err a library "implementing erlang"...
16:44:11 <tabemann> monochrom: well, yes, I've run into integer overflow in cases before, and at least Haskell makes it *convenient* to use Integer (much more convenient than bignums are in, say, C or C++)
16:46:05 <tabemann> but as for the proposal that numbers all be made bignums or at least have automatic bignum conversion, I'm used to being able to use sized types that behave as such when you do things like bitshift bits to the left or loop over when addition goes above the maximum value
16:46:45 <tabemann> one *could*, though, have Int32 etc. act like that and unify Int and Integer into one type that has transparent conversion
16:46:50 <monochrom> my point is more meta than that. there is no pleasing everyone.
16:48:30 <monochrom> if you make Int default, someone will be surprised and make a big fuss. if you make Integer default, someone else will be surprised and make a big fuss. if you add runtime bound checks to Int, another special interest group will be surprised and make a big fuss.
16:48:33 <merijn> Screw it, committed things
16:48:46 <merijn> Time to see if I can remember my Hackage login...
16:49:16 <Fuuzetsu> The captcha on the GHC Trac registration page is ridiculous. Hats down to any bot that can solve it.
16:49:33 <monochrom> that thread has unfolded to essentially moral high horse vs performance high horse
16:51:31 <monochrom> but I just want to say something much more mundane than both high horses. the original poster was surprised because: in Linux gcc, int is the same between i386 and x86_64; in Linux GHC, Int is different between i386 and x86_64.
16:52:10 <monochrom> the original poster's program is bound (pun!) to give wrong answers. the only real surprise is why two different wrong answers, if you came from Linux gcc.
16:52:29 <tabemann> I'm used to in OCaml an int being 31 bits on i386 and 63 bits on x86_64
16:53:51 <josephle> tabemann: so Ocaml also steals a bit for GC?
16:54:00 <tabemann> josephle: yep
16:54:00 <monochrom> but the surprise for me is that yesterday I found out that Linux gcc long is different between i386 and x86_64
16:54:35 <tabemann> monochrom: oh, that's something I'm used to, something that tends to easily break code written by people used to 32-bit C environments only
16:54:59 <tabemann> and the notorious "you can cast a pointer into an int on 32-bit but not on 64-bit" thing
16:55:52 <monochrom> well, as usual, it is saner to begin by assuming nothing, assume absolute nothing.
16:56:35 <tabemann> when I want something of a specific bit size in C, I tend to prefer to simply use things int int32_t rather than int even when I know they will be the same size on the target platform
16:57:00 <tabemann> or if I want something that is specifically supposed to be sized to the size of the address space, size_t
16:57:39 <monochrom> yeah
16:59:48 <tabemann> I only really like using things like int when I have a number that is going to be small and the operations on it need to be fast
17:00:23 <tabemann> and where the use of int itself is supposed to imply "this is not supposed to be big"
17:05:21 * hackagebot posix-pty 0.1.0 - Pseudo terminal interaction with subprocesses.  http://hackage.haskell.org/package/posix-pty-0.1.0 (MerijnVerstraaten)
17:07:03 <merijn> \o/
17:16:04 <BMeph_> <tabemann> "and where the use of int itself is supposed to imply 'this is not supposed to be big'" - that's what she said? ;þ
17:17:18 <tabemann> probably the worst case I've seen is putting sizes in ints (which I've unfortunately done at times in the past), because now of course there's no reason why something like a file should be trusted to be under 2 GiB
17:17:46 <tabemann> offsets too
17:17:57 <tabemann> even memory can't be trusted to be that small anymore
17:27:15 <Fuuzetsu> @hoogle Char -> Word8
17:27:17 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
17:27:17 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
17:27:17 <lambdabot> Prelude error :: [Char] -> a
17:28:49 <cmears> Fuuzetsu, what about Data.Char.ord ?
17:29:02 <cmears> > ord 'a'
17:29:04 <lambdabot>   97
17:31:28 <Fuuzetsu> : ord
17:31:30 <Fuuzetsu> :t ord
17:31:31 <lambdabot> Char -> Int
17:31:37 <ryant5000> is "ListT done right" anywhere on hackage?
17:32:32 <cmears> ryant5000, there's "LogicT", which might be useful
17:33:36 <ryant5000> cmears: thanks; seems like overkill, but i think it'll do the trick
17:45:34 <dolio> LogicT is the same thing as ListT done right, just Church encoded.
17:53:33 <Peaker> There's the List package, too
17:53:39 <Peaker> with a standard, non-Church-encoded ListT
17:53:50 <Peaker> and a List class for common operations that work with ListT and []
17:54:49 <Peaker> tabemann, there's intptr_t, uintptr_t too..
17:56:25 <joelteon> does currying have a significant performance impact?
17:56:52 <sclv> no
17:57:05 <joelteon> why not?
17:57:18 <geekosaur> huh?
17:57:51 <joelteon> why not
17:58:00 <geekosaur> why would it?
17:58:29 <joelteon> https://gist.github.com/anonymous/806ec0f449647fbc63f5
17:58:42 <joelteon> i guess there are some differences in GHC's IR
18:00:43 <sclv> see "how to make a fast curry"
18:00:46 <sclv> for gritty details
18:01:04 <sclv> even before then it was pretty good
18:03:51 <joelteon> hmm
18:04:05 <joelteon> well, i'm talking to someone who I think is saying that haskell is fundamentally anti-performance because it supports currying
18:04:25 <Fuuzetsu> Is there a reason why OverloadedStrings will not automatically treat 'b' as Word8?
18:04:55 <shachaf> Characters aren't bytes?
18:04:57 <geekosaur> because OverloadedStrings is not OverloadedChars
18:05:03 <cmears> joelteon, wait until they find out about laziness
18:05:09 <joelteon> haha
18:05:15 <blackdog> joelteon: it sounds like they're mixing up semantics and implementation.
18:05:26 <joelteon> but you can make things strict
18:05:29 <geekosaur> or just wishfully bashing what they don;t understand
18:05:32 <shachaf> OverloadedStrings also won't treat "abc" as [Word8]
18:06:03 <shachaf> (Sometimes it'll treat it as ByteString. But that instance is evil.)
18:06:35 <Fuuzetsu> shachaf: I thought that ByteStrings were just vectors of Word8
18:06:47 <shachaf> What does "vector" mean?
18:06:56 <Fuuzetsu> And yeah, I see why it doesn't work but I hoped for a way.
18:07:10 <Fuuzetsu> shachaf: In this context, a linear sequence I guess.
18:07:22 <joelteon> I can't think of a situation in which currying is particularly useful
18:07:30 <ryant5000> Fuuzetsu: are you looking to get a UTF-8 encoding of your string?
18:08:09 <Fuuzetsu> ryant5000: Let me think about this for a minute
18:08:20 <Fuuzetsu> I don't think so.
18:08:29 <Fuuzetsu> No, I don't.
18:09:04 <shachaf> Fuuzetsu: "linear sequence" can mean a lot of things.
18:09:34 <Fuuzetsu> shachaf: unfortunately hackage docs aren't very specific
18:09:45 <Fuuzetsu> >A space-efficient representation of a Word8 vector, supporting many efficient operations. A ByteString contains 8-bit characters only.
18:09:55 <shachaf> OK.
18:10:21 <shachaf> I'm not sure what you're responding to.
18:10:41 <shachaf> But please note that a ByteString is for bytes, not for characters.
18:11:12 <Aetherspawn> Byte/String
18:11:15 <Aetherspawn> not Bytestring :)
18:12:23 <Fuuzetsu> Seems like I'll need to more carefully think about what I'm doing then.
18:20:55 <sclv> ?ty curry
18:20:56 <lambdabot> ((a, b) -> c) -> a -> b -> c
18:21:08 <sclv> joelteon: any language with higher order functions supports currying
18:21:21 <sclv> not every language uses it as in idiom so pervasively
18:21:22 <joelteon> right
18:21:38 <sclv> partial application is useful lots of times though!
18:21:45 <joelteon> i agree
18:21:49 <joelteon> but I can't convince everyone
18:22:02 <sclv> but you just said you couldn't see a situation where its particularly useful
18:22:11 <joelteon> yeah, but I found some on the internet since I said that
18:22:16 <sclv> haha yeah
18:22:24 <sclv> ?src sum
18:22:24 <lambdabot> sum = foldl (+) 0
18:22:26 <enthropy> mgsloan: actually it seems your zeroth does work (after getting rid of some incompatible flags passed to ghc)... just that it only works for top-level Q [Dec] splices done without $( )
18:22:31 <sclv> that's a great example!
18:22:37 <sclv> ?src product
18:22:37 <lambdabot> product = foldl (*) 1
18:22:41 <joelteon> how horribly unperformant
18:22:51 <mgsloan> enthropy: No way! doh!  What version of GHC are you using?
18:23:03 <enthropy> The Glorious Glasgow Haskell Compilation System, version 7.6.2
18:23:04 <mgsloan> I was probably trying to get it to work with 7.6 or something
18:23:09 <mgsloan> huh, cool
18:23:38 <sclv> anyway you can just tell them that if they don't think its performant, they should try to compile something and benchmark it
18:23:52 <sclv> using both curried and uncurried forms
18:23:56 <sclv> and see if they see a difference
18:24:16 <mgsloan> enthropy:  Well, feel free to fork / patch / etc.  Then we can do the whole contact the maintainer / wait 2 weeks to upload to hackage thing
18:24:16 <sclv> (for simple cases, i think they'll actually get the same core)
18:24:22 <joelteon> well I think his point is that any language with GC or currying is by definition unperformant compared to like C++
18:25:26 <blackdog> joelteon: why "by definition"?
18:25:29 <enthropy> http://hpaste.org/89269
18:25:49 <joelteon> because GC is slow, I guess
18:25:52 <joelteon> and currying is slower than not currying
18:26:28 <sclv> ask him if he writes is c++ without ever using smart pointers
18:26:33 <sclv> or objects
18:26:36 <blackdog> joelteon: currying is about the semantics. it doesn't say anything about how it's implemented.
18:26:41 <sclv> because those are by definition slower than not using them
18:26:54 <joelteon> yeah but I think his point is that currying can't be implemented as fast as non-currying
18:27:06 <sclv> but it can be!
18:27:06 <mgsloan> It can if you don't use it
18:27:08 <sclv> in many cases!
18:27:11 <blackdog> he is wrong.
18:27:41 <sclv> if the compiler can "tell" you're applying things fully, it doesn't need to go through the whole rigamarole
18:27:46 <dolio> Non-currying is slow, too, man. You have to build all those tuples on the heap.
18:27:59 <joelteon> yeah
18:28:03 <blackdog> trivially. Think about a compiler that takes a program using curried functions, and uncurries them all. you now have the same code you would have written without currying.
18:28:20 <sclv> if we're applying a curried thing directly we can pass everything on registers, super nicely in fact
18:28:21 <monochrom> everything is slower than everything
18:28:24 <Aetherspawn> "ask him if he writes is c++ without ever using smart pointers or objects" >> Ask him if he wrote C++ pre-cpp-0x
18:28:31 <geekosaur> ^^ that is why I questioned performance issues
18:28:40 <joelteon> I see
18:28:41 <geekosaur> (blackdog's comment that is)
18:28:46 <joelteon> Aetherspawn: no, he doesn't
18:28:51 <joelteon> use smart pointers or objects
18:29:05 <Aetherspawn> Pure C yeahhh
18:29:07 <joelteon> yeah
18:29:14 <joelteon> C with all the syntactic glory of C++
18:29:18 <sclv> he's beyond help
18:29:31 <monochrom> I use Haskell pointers and heap objects
18:29:31 <sclv> let his fingers slip from your grasp as he plummets into the abyss
18:29:33 <Aetherspawn> I tried to implement partial application in C for a dead easy programming assignment
18:29:34 <joelteon> ok
18:29:38 <geekosaur> so he's actually just writing C? that can be hard tpo beat... although there's a slowly increasing number of cases where GHC does outperform well written C
18:29:42 <joelteon> yeah
18:29:46 <Aetherspawn> void* casting yeaahhh
18:29:49 <sclv> basically it doesn't @#$@ matter
18:30:03 <sclv> within ~2x performance, for 95% of all use cases
18:30:08 <sclv> is good enough
18:30:14 <blackdog> geekosaur: usually doing it in Haskell means you have a lot more time to optimise :)
18:30:26 <geekosaur> mostly because pure code can be optimized by the compiler in ways a C compiler can't, and if the C programmer tried to pre-optimize the resulting code would be unreadable
18:30:26 <Aetherspawn> it'd be nice if haskell got closer to C performance
18:30:34 <joelteon> yeah
18:30:35 <joelteon> it would be nice
18:30:37 <sclv> for the other use cases, GC pauses are typically bigger killers than absolute performance
18:30:38 <Aetherspawn> It certainly has the semantics to..
18:30:44 <sclv> we're really close to C performance
18:30:57 <joelteon> oh, he uses RAII
18:31:00 <sclv> i don't think anyone that wants us closer, for the most part, actually would benefit in their code from it
18:31:02 <joelteon> that's where he gets all his performance
18:31:22 <ChongLi> GC pauses seem to be pretty damn short
18:31:25 <sclv> (i just mean in general -- GC pauses are much worse for may haskell use cases than absolute performance issues)
18:31:37 <sclv> its not how short they are -- its that they're somewhat unpredicatable
18:31:43 <sclv> which means you can't make certain absolute guarantees
18:31:53 <dolio> ChongLi: Not when you're trading stocks by the microsecond. :)
18:32:07 <ChongLi> dolio: that's a pretty silly example
18:32:17 <sclv> scarily common
18:32:19 <sclv> :-(
18:32:20 <blackdog> ChongLi: whert?
18:32:29 <blackdog> finance is one of haskell's strongest areas...
18:32:37 <monochrom> currying is important for "map (map f) xss". but you won't see that kind of code in C++ because you can't write it in C++. there is a self-fulfilling prophesy.
18:32:39 <ChongLi> finance is a lot bigger than just HFT
18:32:55 <orangerobot> dolio: can life get any cooler than that? use haskell and make a sh**load of money on it
18:33:04 <ChongLi> those HFT guys do strange things like programming gamer network cards and stuff
18:33:23 <jmcarthur> ChongLi: only the most extreme
18:33:34 <dolio> I'm not really endorsing it.
18:33:54 <dolio> It'd be nice if some other areas were bigger for Haskell.
18:33:57 <monochrom> use an infinite heap for microsecond trading
18:34:17 <ChongLi> at that point, the latency across the IO bus is too long
18:34:19 <monochrom> use a fast PRNG for microsecond bitcoin trading :)
18:34:22 <jmcarthur> ChongLi: haskell does have a place in the area, although probably not with those who tend to program fpgas
18:34:36 <mgsloan> joelteon: Also, if he's got an issue with immutability, it actually turns out to make GC very efficient
18:36:36 <dolio> Luckily the defense industry likes Haskell some, too.
18:36:47 <dolio> So, you know, an assortment.
18:36:51 * jmcarthur feels safer
18:37:22 <joelteon> just as long as it's not on debian 7.0 :|
18:40:14 <Aetherspawn> :t runReaderT
18:40:15 <lambdabot> ReaderT r m a -> r -> m a
18:41:17 <Aetherspawn> :t flip . runReaderT
18:41:18 <lambdabot> ReaderT a ((->) b) c -> b -> a -> c
18:41:26 <Aetherspawn> the hell is that.
18:41:34 <Aetherspawn> @pl (\x y -> runReaderT y x)
18:41:34 <lambdabot> flip runReaderT
18:41:39 <Aetherspawn> :t flip runReaderT
18:41:41 <lambdabot> b -> ReaderT b m a -> m a
18:45:26 * hackagebot bmp 1.2.5.1 - Read and write uncompressed BMP image files.  http://hackage.haskell.org/package/bmp-1.2.5.1 (BenLippmeier)
18:59:04 <Aetherspawn> Which is probably faster for reading a file with a ton of pointers in it? mmapFileByteStringLazy or mmapFileByteString
19:00:11 <dmwit> I doubt they do anything different under the hood.
19:00:28 <dmwit> It's just whether you want to use it with the Lazy API or the Strict one.
19:00:51 <dmwit> e.g. if you were interfacing to a web server or something that demanded Strict ByteStrings, you'd use the Strict one.
19:01:10 <dmwit> ...but that's just an educated guess.
19:05:33 <jmcarthur> Aetherspawn: how does a file contain pointers?
19:05:45 <dmwit> offsets, I'm guessing
19:05:56 <dmwit> just relative to the beginning of the file or similar
19:07:46 <zRecursive> @unmtl ReaderT r m a
19:07:47 <lambdabot> r -> m a
19:08:30 <Aetherspawn> what dmwit said, sorry wrong word
20:22:46 <kennycason> i'm new to this irc channel
20:22:50 <kennycason> is it pretty active?
20:22:56 <kennycason> seems to be with 990 people
20:25:01 <applicative> only 990? omg we're going out of style again?
20:25:35 <applicative> kennycason: if you have a particular haskell problem, you are likely to trigger all kinds of discussion.
20:26:09 <djahandarie> (Wait, have we hit 1k in here before? I can never keep track...)
20:26:18 <applicative> the text for today is http://tunes.org/~nef/logs/haskell/13.06.03 kennycason
20:26:21 <applicative> djahandarie: oh yes
20:26:25 <djahandarie> (I imagine considering how close we are right now and it's the middle of the night)
20:26:47 <kennycason> awesome, sounds like i came to the right place :)
20:26:53 <applicative> i was just kidding of course, but lately its been in the low 1000s i think
20:27:21 <carter> applicative do we have a counter  or is there some irc command for tracking that?
20:27:33 <kennycason> i won't bug anyone for a bit, as i'm plowing through a bunch of tutorials and have been writing various small scripts: https://github.com/kennycason/haskell
20:27:45 <applicative>  carter I dont know how to do it, irssi shows me when i log on
20:27:51 <applicative> or /join rather
20:27:59 <kennycason> i'm working on porting a bit of my neural network code to haskell for exercise, have way there
20:28:03 <DigitalKiwi> 990 names but 30 of them are bots
20:28:03 <kennycason> half*
20:28:04 <tabemann> no, it's perfectly fine if you bug us
20:28:16 <kennycason> thanks
20:28:35 <DigitalKiwi> /names
20:28:37 <carter> kennycason COOOL
20:28:48 <carter> kennycason are you familiar with autodifferentiation?
20:28:57 * tabemann is busy reading about parallel and concurrent programming in haskell when he should really be going over java (ick) "design patterns" for his job interview tomorrow
20:29:05 <applicative> certainly seems like you've made it past the elements kennycason, good work.
20:29:17 <carter> tabemann you should order the Simon Marlow book
20:29:28 <tabemann> carter: I'm reading the online version of it
20:29:34 <carter> oh
20:29:40 <tabemann> I probably will order it once I actually do have a job
20:29:50 <carter> tabemann GOOD reason not to order one yet
20:29:54 <carter> tabemann did you just graduate?
20:30:04 <tabemann> oh no, I've been out of school for years
20:30:09 <kennycason> applicative, thanks it's been a fun two days haha
20:30:21 <applicative> ah, DigitalKiwi /names thanks
20:30:38 <tabemann> I'm just between jobs, and pretty much already have acquired one job that seems okay but am interviewing for a different job I really really want
20:30:40 <kennycason> carter, i wasn't until i just looked it up, seems interesting
20:30:51 <carter> kennycason it is
20:30:56 <tabemann> haven't started at the former job though yet
20:30:56 <carter> the AD lib on hackage is pretty nice
20:31:03 <carter> tabemann fair enough
20:32:36 <carter> kennycason the AD lib is pretty nice, i hope to be able to spend some time late summer making it magical
20:32:50 * tabemann didn't know that forkIO inherited the mask state of the parent thread; very useful that
20:33:01 <carter> tabemann depending on how the next 2 months go for me, i can either start giving myself a salary, or i'm doing some job hunting myself
20:33:05 <carter> hopefully the former
20:33:10 <carter> but could be the latter
20:33:53 <tabemann> I don't know anything about running a business myself, and actually need benefits for various reasons, so working for someone else is the only option for me
20:34:52 * tabemann just hopes he ends up working on software for MRI scanners than software for controlling remote-controlled sirens
20:35:16 <carter> tabemann i'm still on my parents insurance for now, but will transition to my own if i'm actually not job hunting
20:35:24 <carter> tabemann what sort of DSP stuff have you done before?
20:36:04 <tabemann> never worked with DSPs, the only embedded stuff I've done was some stuff on ARM (realtime OS, no memory management) at one of my jobs in the past year
20:36:47 <tabemann> it doesn't seem like I'd be working on the actual sound generation for the sirens, more the elaborate system for controlling lots of sirens remotely (the market is places like nuclear power plants)
20:36:48 <carter> MRI = DSP though right?
20:37:34 <tabemann> what I'd be working on is image processing of MRI-generated images in Java on Linux, no DSP stuff
20:37:53 <carter> ok
20:38:14 <carter> i thoguht that MRI image stuff was a sort of signal processing
20:38:54 <tabemann> well, the signal processing they're doing is in software on a consumer OS rather than on dedicated signal-processing hardware
20:39:30 <tabemann> they're not actually doing the first stage of getting the image out of the scanner, but more later processing
20:40:34 * tabemann might find working with DSPs to be more interesting than working in Java, but oh well
20:40:47 <carter> i sort of meant software based
20:40:48 <DigitalKiwi> you write the software that adds/removes the tumors to the images, depending on if they like the patient or not
20:41:31 <kennycason> lol
20:41:36 <tabemann> DigitalKiwi: in this case would be more adds/removes heart problems
20:41:48 <tabemann> as they've got a whole package for cardio stuff
20:42:26 <DigitalKiwi> tumor, tremor, same thing
20:43:17 <carter> Funny Tissue thats not an oragami kleanex
20:43:42 <dmwit> You know, for a Java job, that doesn't sound very soul-crushing at all.
20:44:00 <dmwit> Saving people's lives + learning cool math. What more could you want?
20:44:11 <carter> dmwit you are absolutely right
20:44:22 <carter> and you can bond with your coworkers over java pains!
20:44:32 <dmwit> heh
20:44:48 <carter> "hey bob, i need a hug, JVM made me sad again, XML build files are evil"
20:44:54 <tabemann> dmwit: it certainly seems less soul-crushing than working with sirens
20:45:20 <carter> tabemann sirens are way cooler than webaps
20:45:24 <carter> they can save lives
20:45:25 <carter> ish
20:45:30 <carter> or kill ear drums
20:45:49 <carter> most developers in the US are website maintainers
20:46:04 <tabemann> carter: I prefer not to work on web apps myself, and so far have never had any jobs working with them
20:46:19 <carter> well, good thing theres lots of other cool things to do if you take the time to look
20:47:30 <tabemann> the big thing in the area where I live is embedded embedded embedded, outside of business computing and everything that comes with that
20:49:17 <tabemann> and then there's some biomedical in this area, but for reasons that are a long story I can't work for the main manufacturer thereof here for about a year
20:49:55 <carter> if you're in the midwest region, the dudes at Atomic Object are big on embedded, and have some neat haskelly dudes too
20:50:22 <tabemann> I live in the Milwaukee area, and for personal reasons really cannot move from here
20:50:43 <carter> ahh
20:50:44 <carter> LIFE
20:51:17 <carter> tabemann you shoudl still check em out
20:51:19 <carter> at at least chat
20:51:42 <tabemann> oh, atomic object is in michigan
20:51:45 <carter> yeah
20:51:53 <carter> thats what i meant yeah
20:52:05 <carter> i'm bad at geography, being a new yorker
20:52:09 <carter> manhattanite
20:52:09 <carter> etc
20:52:45 <DigitalKiwi> you're bad at geography because american schools suck ;)
20:53:00 <joelteon> that's why we're a world power
20:53:01 <carter> DigitalKiwi nope, i'm terrible at memorizing
20:53:06 <tabemann> grand rapids michigan is a long way from where I live; chicago is much closer, and even then, moving to chicago would be difficult because I'd have to frequently commute back to wisconsin (long story)
20:53:17 <tabemann> and the drive between chicago and milwaukee is not fun
20:53:26 <carter> i was the only person in 2nd grade who couldn't sing the "50 states" song because i couldn't remember all the names in one go
20:53:30 <carter> fucking hate memorization
20:53:46 <DigitalKiwi> what about memoization
20:53:48 <tabemann> the capitals of the states are the worst
20:53:49 <carter> tabemann i'd imagine that if there was an awesome fit they'd be remotish ok
20:53:54 <carter> DigitalKiwi i don't have to remember that one
20:53:59 <carter> i just hav eto ask the computer to do it
20:54:20 * tabemann remembers when he was commuting between maryland and wisconsin... now that sucked up a lot of money
20:54:46 <carter> tabemann…. the business hsould be covering that
20:55:13 <carter> always
20:55:21 <tabemann> well nothing was exactly forcing me to fly back and forth, and I was not doing so for business-related reasons
20:56:41 * tabemann could see getting a job in Madison, though, as the drive between there and Milwaukee is not as bad as that from Chicago (even if on paper it is nearly as long)
20:57:20 <carter> isn't Zencoder Madison based?
20:57:54 <carter> nvm, can't find the info
20:58:05 <DigitalKiwi> the company my dad is at is finally starting to realize just how much it costs to send his team to the sites (which are all over the US and we're in nebraska) for a week at a time, 2-3 weeks out of the month. this week he's in texas
20:58:14 <tabemann> the zencoder site says they're based on San Francisco
20:58:28 <carter> tabemann true, but I know they have senior engineers who're madision based
20:58:34 <carter> i'm friends with the dude
20:59:23 <dmwit> I know a guy who KNOWS a guy.
20:59:31 <carter> you know me and i know the guy dmwit  )
20:59:32 <tabemann> I nearly got a job with a company that did weather data processing in Madison ("nearly" as in I basically got it but ended up going with a job in Milwaukee instead)
20:59:33 <carter> :)
20:59:42 <carter> that sounds cool
20:59:43 <DigitalKiwi> they could buy a car and house there and spend less than renting and hotel rooms XD
20:59:55 <carter> DigitalKiwi woah
21:00:01 <carter> but then they'd have to maintain it
21:00:19 <carter> just like their cobol code
21:00:23 <tabemann> moving to Madison would have been a pain, and trying to commute *every day* between Milwaukee and Madison would have put way too much mileage on my car
21:00:23 <DigitalKiwi> well could lease or whatever, same situation
21:00:58 <carter> tabemann fair enough
21:01:04 <DigitalKiwi> haha, cobol, actually it is/was visual foxpro, moving to like C# and some stuff is python or slt
21:01:05 <carter> theres also many remote ok places ou there
21:01:10 <tabemann> and the commute would have been very hard on snowy days in the winter
21:01:11 <carter> DigitalKiwi cool
21:01:30 <DigitalKiwi> i'm not really too privy on the development stack
21:01:47 * tabemann doesn't get why people develop in C# himself
21:02:01 <dmwit> It's not hard for owning a house to be cheaper than a hotel room.
21:02:02 <carter> tabemann clr is a better jvm,
21:02:13 <carter> dmwit yes, but you have to clean it
21:02:40 <tabemann> you'd have to pay for someone to maintain the place
21:02:49 <dmwit> Yes, I acknowledge this.
21:02:52 <carter> agreed
21:03:05 <tabemann> carter: yes, there were a number of things that were done better after seeing how java did them
21:03:18 <dmwit> But I would bet you'd only have to have somebody be in that city, say, half of each month for it to be worthwhile.
21:04:02 <dmwit> If you've got a whole team...
21:26:23 <latermuse> what does this mean exactly? thread blocked indefinitely in an MVar operation
21:26:42 <latermuse> why would the thread be blocked? isnt the point of MVar to prevent blockage?
21:27:20 <cmears> I think it means it's waiting to take the MVar, but it has figured out that it will never be able to
21:27:27 <johnw> it usually means you have a thread waiting on an MVar, but there are no longer any other threads running that could write to it
21:27:30 <tabemann> it means that takeMVar is waiting for something to be put in the MVar by putMVar, but no one is putting anything in there
21:27:40 <tabemann> and no one could
21:27:42 <lispy> edwardk: No I didn't know they were logged. Where can I see the log?
21:27:45 <latermuse> gotcha :)
21:27:46 <latermuse> thanks
21:28:24 <lispy> edwardk: [pure speculation] maybe it's configured to email a special address that does the logging
21:32:36 <blz37> I did "reverse' [] = [];  reverse' x:xs = (reverse' xs) ++ [x]"
21:32:40 <blz37> What seems to be the problem ?
21:33:12 <ski> the problem seems to be that you didn't say :  reverse' (x:xs) = ...
21:33:29 <wwt> suppose I have "[Maybe a]" and "a->b", what arcane incantation with map will give me "Maybe [b]"?
21:35:01 <cmears> wwt, why is it "Maybe [b]"?
21:35:07 <cmears> Do you just want [b] ?
21:35:21 <ski> what transformation from `[Maybe a]' to `Maybe [a]' did you had in mind ?
21:36:09 <wwt> "Maybe [b]" because it should give Nothing if any element of the [Maybe a] is nothing, and Just the mapped result otherwise
21:37:07 <blz37> ski, trying out
21:37:08 <ski> @type \f -> fmap (fmap f) . sequence
21:37:09 <lambdabot> (Monad f, Functor f) => (a -> b) -> [f a] -> f [b]
21:37:38 <ski> > (fmap (fmap (^ 2)) . sequence) [Just 0,Just 1,Just 3]
21:37:39 <lambdabot>   Just [0,1,9]
21:37:41 <ski> > (fmap (fmap (^ 2)) . sequence) [Just 0,Just 1,Nothing,Just 3]
21:37:43 <lambdabot>   Nothing
21:38:07 <ski> `fmap (map f)' would also work
21:39:56 <wwt> wow that worked
21:39:57 <boothead> morning all. Is there a nice way to go from a -> IO b to a -> IO (a, b) -- i.e. an action that also passes along its argument?
21:39:59 <wwt> so arcane
21:40:12 <boothead> been looking at arrows but can't find the right thing
21:40:38 <blz37> I did "reverse' [] = [];  reverse' (x:xs) = (reverse' xs) ++ [x]" .. I got "non-exhaustive" patterns
21:40:51 <blz37> do I need something like "rev [x] = [x]" ?
21:41:44 <ski> > let reverse' [] = [];  reverse' (x:xs) = (reverse' xs) ++ [x] in reverse' "abcd"
21:41:44 <latermuse> blz37, you can use ghc -Wall to see which patterns you forgot to match
21:41:45 <lambdabot>   "dcba"
21:41:55 <ski> seem to work here
21:43:44 <tabemann> > let reverse' = reverse'' []; reverse'' ys (x : xs) = reverse (x : ys) xs; reverse'' ys [] = ys
21:43:46 <lambdabot>   not an expression: `let reverse' = reverse'' []; reverse'' ys (x : xs) = re...
21:43:52 <tabemann> > let reverse' = reverse'' []; reverse'' ys (x : xs) = reverse (x : ys) xs; reverse'' ys [] = ys in reverse' "foobar"
21:43:53 <ski> @type liftM2 liftM (,)  -- boothead, hum
21:43:54 <lambdabot>   The function `GHC.List.reverse' is applied to two arguments,
21:43:55 <lambdabot>  but its type ...
21:43:55 <lambdabot> Monad m => (a -> m a1) -> a -> m (a, a1)
21:44:09 <randomclown> @pl \x -> x : f x
21:44:10 <lambdabot> ap (:) f
21:44:13 <tabemann> > let reverse' = reverse'' []; reverse'' ys (x : xs) = reverse (x : ys) xs; reverse'' ys [] = ys in reverse' "foobar"
21:44:14 <lambdabot>   The function `GHC.List.reverse' is applied to two arguments,
21:44:14 <lambdabot>  but its type ...
21:44:29 <tabemann> > let reverse' = reverse'' []; reverse'' ys (x : xs) = reverse'' (x : ys) xs; reverse'' ys [] = ys in reverse' "foobar"
21:44:31 <lambdabot>   "raboof"
21:44:43 <tabemann> this is probably a more efficient way of doing it
21:45:16 <ski> not that blz37 asked for efficiency ;)
21:45:20 <tabemann> takes two functions, but the use of (++) in the previous implementation is slow
21:46:06 <blz37> ok... digesting this.
21:46:31 * ski has seen this called `shunt'
21:46:33 <boothead> ski: doesn't that need two input monads?
21:46:58 <blz37> tabemann, what does ys stand for ?
21:47:03 <ski> only one input monad (aka a "reader" monad)
21:47:20 <tabemann> blz37: "ys" doesn't "stand" for anything, it is just the output list that is being constructed
21:47:22 <ski> blz37 : currently reversed elements
21:47:52 <blz37> like an accumulator  ?
21:47:56 <tabemann> yes
21:48:07 <ski> boothead : you might need to import `Control.Monad.Instances' or `Control.Monad.Reader' for this to work
21:49:03 <boothead> ski: probably should have mentioned that I'm also using io-steams so what I really want is to go from my InputSteam FileName -> IO (InputSream Val) to IO (FileName, InputSteam Val)
21:49:48 <ski> no idea how `InputStream' works
21:50:13 <boothead> anyone with pipes experience think that this kind of composition would be easier in that library?
21:50:26 <boothead> ski: apparenty neither do I :-)
21:52:16 <blz37> tabemann .. another hidden trick seems to be ommission of list from    "let reverse' list = reverse'' [] list" . Is that correct assumption ?
21:52:33 <blz37> "hidden trick" might be a strong word.
21:52:56 <ski> it's extensionality
21:53:08 <ski> if `f x = g x' for all `x', then `f = g'
21:53:12 <tabemann> blz37: that's just partial application at work
21:53:24 <blz37> ok.
21:53:59 <ski> (if two functions behave the same when applied to every possibly argument, then the two functions are equal)
21:54:54 <ski> practically, it can sometimes be a handy way to avoid having to give a name to an input at this point in the code
21:56:04 <blz37> what would be the function type signature of reverse' = reverse'' [] ?
21:56:29 <ski>   reverse' :: [a] -> [a]
21:57:28 <blz37> reverse'' :: [a] [b] -> [a] ?
21:57:44 <tabemann> reverse'' :: [a] -> [a] -> [a]
21:57:45 <ski>   reverse'' :: [a] -> [a] -> [a]  -- rather
21:58:01 <ski>   reverse'' :: [a] -> ([a] -> [a])  -- or this, if you prefer; it's the same thing, really
21:58:23 <blz37> ok.
21:58:28 <tabemann> I don't think anyone would use those parents there
21:58:30 <tabemann> *parens
21:59:01 <applicative> they're there anyway, so why bother
21:59:11 <ski> for `map'-like things, i often write them out
22:00:39 <applicative> man bos is a little hard on the pipes library, "Frankly, the current state of things feels to me like a disservice to the community..."
22:01:18 <ski>   flip . foldr :: (a -> b -> b) -> ([a] -> b -> b)  -- a simple example
22:01:19 <applicative> " I get trapped under the ice of free monads and sevenfold parametric polymorphism, which I am frankly not going to make the effort to try to escape" -- that may be forgivable :)
22:01:33 <blz37> I am thinking it will be more like "reverse'' :: ([a] -> [a]) -> [a]"
22:02:00 <ski> blz37 : that would be completely different (and not work with the given code here)
22:02:25 <blz37> ski, yes. I realize that. what is the best way to reorient my head here. Is it currying ?
22:02:39 <ski> no
22:02:51 <applicative> @type ($ [])
22:02:52 <lambdabot> ([a] -> b) -> b
22:03:35 <ski> currying is the process of turning a function which takes its arguments all-at-once (e.g. in a tuple) to a function which takes its arguments one-at-a-time (each time but the last returning a function that takes the rest of them)
22:03:43 <applicative> @type (++[]) . ($ [])
22:03:44 <lambdabot> ([a1] -> [a]) -> [a]
22:03:48 <applicative> bah
22:04:08 <ski> @type fix . (reverse .)
22:04:09 <lambdabot> ([a] -> [a]) -> [a]
22:04:11 <ski> there you go
22:04:16 <applicative> thank you
22:04:48 * applicative is unfamiliar with a process of currying 
22:05:02 <ski> blz37 : if you have a type like `(.. -> ..) -> ..', then it's the type of a higher-order function, a function whose argument is also a function
22:05:19 <ski> e.g.
22:05:23 <ski> @type filter
22:05:24 <lambdabot> (a -> Bool) -> [a] -> [a]
22:05:30 <ski> is a higher-order function
22:05:32 <ski> @type even
22:05:33 <lambdabot> Integral a => a -> Bool
22:05:58 <ski> > filter even [0,1,3,6,10,15,21,28]
22:06:00 <lambdabot>   [0,6,10,28]
22:06:49 <ski> `filter' keeps all the elements of the given list that yields `True' when passed to the argument function
22:06:56 <ski> blz37 : ok ?
22:09:48 <applicative> ski: you've killed poor blz37 with all these higher order combinators
22:10:43 <applicative> watch out everyone, ski might explain callCC to us
22:10:43 <blz37> ski, it's a lot to digest but I think I will be ok. I just have to work through this.
22:11:22 <blz37> thnx  alot.. I have copied down what you said. I will go through some tutorial and books on relevant section with this discussion as a starting point.
22:11:30 <applicative> map is another obvious 'higher order function'
22:11:35 <applicative> @type map
22:11:36 <lambdabot> (a -> b) -> [a] -> [b]
22:11:38 <blz37> that's my plan. If you have better plan, let me know.
22:12:15 * ski . o O ( Kombinator <http://web.archive.org/web/20070703001910/http://www.cs.chalmers.se/~augustss/pics/haskel.gif> )
22:12:58 <ski> > map f [a,b,c,d]                                  :: [Expr]
22:13:00 <lambdabot>   [f a,f b,f c,f d]
22:13:59 <ski> blz37 : btw, for the purposes of the above, it might simplify things to imagine that the type of `even' was `Integer -> Bool'
22:14:15 <ski> (iow, ignoring the type class `Integral a =>' stuff)
22:14:18 <applicative> > map ord "blz37"
22:14:20 <lambdabot>   [98,108,122,51,55]
22:14:26 <applicative> @type ord
22:14:28 <lambdabot> Char -> Int
22:14:48 <applicative> filter isAlpha "blz37"
22:14:57 <applicative> > filter isAlpha "blz37"
22:14:59 <lambdabot>   "blz"
22:15:48 <applicative> > map chr [98,108,122,51,55]
22:15:50 <lambdabot>   "blz37"
22:17:12 <tabemann> mapM_ (putStrLn . (: []) . chr) [98,108,122,51,55
22:17:21 <tabemann> > mapM_ (putStrLn . (: []) . chr) [98,108,122,51,55]
22:17:23 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
22:17:23 <lambdabot>    arising from a use of ...
22:18:40 <tabemann> hmm, that works in ghci when I do :m +Data.Char
22:19:21 <path[l]> hi
22:20:10 <tabemann> well maybe you wouldn't want the user being able to use the IO monad to do things like launch nuclear missiles from within lambdabot
22:20:48 <ski> @help run
22:20:48 <lambdabot> run <expr>. You have Haskell, 20 seconds and no IO. Go nuts!
22:22:14 <no-n> ?
22:22:51 <blz37> ok.. I have noted down what I have learned.
22:22:58 <blz37> ++ is slower than :
22:23:15 <blz37> partial application of argument if it applies for all   a
22:23:31 <tabemann> ++ is slower than : if what is on its left is big, and particularly if you are accumulating something on the left, where then it will progressively get bigger over time
22:23:44 <blz37> higher order function takes other functions as argument. It doesn't matter how complicated the other functions are.
22:23:46 <tabemann> : is fast, but only takes one item (not a list!) on the left
22:24:08 <tabemann> well it could take a list, but only if you're making a list of lists...
22:24:31 <blz37> tabemann.. noted.
22:25:27 <ski> `xs ++ ys' isn't much of a problem if it only occurs occasionally
22:25:30 <blz37> Need to know "type class" as in "ignoring tye type class `Integral a =>' stuff)"
22:25:51 <ski> the problem is when you *repeatedly* add things to the end of a list, using `(++)'
22:26:27 <ski> and it's a problem because there's a faster way to get the same result, and we'd prefer to do it the faster way
22:27:51 <ski> `(((as ++ bs) ++ cs) ++ ds) ++ es' will probably be slower than `as ++ (bs ++ (cs ++ (ds ++ es)))'
22:28:20 <ski> the latter has to copy the spine of `as',`bs',`cs',`ds' (not `es', it's shared)
22:28:55 <blz37> ok.
22:29:15 <ski> the former has to copy the spine of `as', then again copy that copied spine, together with the spine of `bs', then again copy the copied `as',`bs', and also `cs' -- and similarly one more time, also copying the spine of `ds'
22:29:50 <ski> the spine of `as' gets copied four times, `bs' three times, `cs' two times, `ds' one time (and `es' zero times)
22:30:21 <blz37> wow..
22:30:23 <ski> it's this *repeated* copying which is slow
22:30:32 <ski> if you write
22:30:38 <ski>   rev [    ] = []
22:30:46 <ski>   rev (x:xs) = rev xs ++ [x]
22:31:10 <ski> then if you evaluate `rev [a,b,c,d]' it will proceed as follows
22:31:21 <ski>      rev (a:b:c:d:[])
22:31:29 <ski>   =  rev (b:c:d:[]) ++ [a]
22:31:37 <ski>   =  (rev (c:d:[]) ++ [b]) ++ [a]
22:31:47 <ski>   =  ((rev (d:[]) ++ [c]) ++ [b]) ++ [a]
22:31:58 <ski>   =  (((rev [] ++ [d]) ++ [c]) ++ [b]) ++ [a]
22:32:00 <refried_> if i've got:  if i have   f x = g x || h x      is there a point free way to write it?
22:32:04 <ski>   =  ((([] ++ [d]) ++ [c]) ++ [b]) ++ [a]
22:32:07 <refried_> oops double intro
22:32:09 <ski>   =  (([d] ++ [c]) ++ [b]) ++ [a]
22:32:13 <refried_> shit, sorry ski
22:32:16 <ski>   =  ([d,c ++ [b]) ++ [a]
22:32:28 <ski>   =  ([d,c] ++ [b]) ++ [a]  -- erp
22:32:36 <ski>   =  [d,c,b] ++ [a]
22:32:39 <ski>   =  [d,c,b,a]
22:33:06 <notdan> refried_: uncurry (||) . g *** h
22:33:06 <refried_> i didn't look to see you were in the middle of something serious ;-)
22:33:08 <ski> here you can see where the `(((as ++ bs) ++ cs) ++ ds) ++ es'-thing is coming from, in terms of the definition of `rev'
22:33:09 <notdan> something like that
22:33:27 <refried_> notdan: ah, interesting, thanks
22:33:30 <h4199> @pl \x -> g x || h x
22:33:30 <lambdabot> liftM2 (||) g h
22:33:58 <notdan> hm, (->) monad, innit?
22:34:05 <ski> blz37 : so, the thing to look out for is `f (...) = f (...) ++ ...' -- this is usually bad
22:34:17 <ski> notdan : yep
22:34:26 <ski> the `(rho ->)' monad
22:38:24 <oxryly> can someone look at https://gist.github.com/Danl2620/5703855 and suggest a more idiomatic way of writing it?
22:39:09 <tabemann> turn the getItemScores line into: getItemScore = maybe 0 exScore $ List.find isScore
22:39:13 <tabemann> and then
22:39:30 <blz37> ski, thnx a lot.. I have copied down what you wrote so that I remember it better.
22:39:35 <tabemann> where isScore (Score _) = true
22:39:44 <tabemann>       isScore _ = False
22:39:47 <tabemann> s/true/True
22:40:16 <blz37> f (...) = f (...) ++ ....    will also exist for other languages like scheme and erlang ?
22:40:26 <ski> yep
22:40:31 <zedak> Hi, I have a question on the Haskell standard..
22:40:36 <tabemann> blz37: same for any language that constructs lists as pairs linked together
22:40:47 <hoqhuuep> g'day folks, newbie here. Is it possible to create the following python function in a strongly typed functional language? "lambda x: x if isinstance(x, list) else [x]" I'm pretty sure it will not work in Haskell as the type of the result depends on the type of the parameter. Is "dependant types" the right area to read up on?
22:40:48 <blz37> gotcha..
22:41:34 <tabemann> hoqhuuep: there's no such thing as something being an dynamically typed instance of something in Haskell unless you're using Typeable, which you're probably not...
22:42:17 <zedak> C++ and Common lisp are the languages which got bloated by a wave of standardisations, whereas Haskell still remains Rich and elegant. How?
22:42:49 <blz37> to start out simple  f :: [a] -> [a], f is a function that takes a list of type a and return a list.
22:42:51 <ski> hoqhuuep : typically we wouldn't want/need to use such a function in Haskell ..
22:43:16 <tabemann> the standardization efforts for Haskell were deliberately conservative in nature, with most of the efforts that weren't going into extensions under GHC and like
22:43:29 <blz37> for g :: [a] -> [a] -> [a], g is a function that takes a list and returns a function that takes a list and returns a list ?
22:43:30 <oxryly> tabemann: thanks.
22:43:56 <atamagawarui> oxryly: Actually, in the code tabemann gave you, replace "$" with ".".
22:44:55 <ski> hoqhuuep : .. perhaps you have an application where it'd be useful ?
22:45:07 <ski> blz37 : yep
22:45:19 <oxryly> atamagawarui: tabemann:  yep that works
22:46:10 <oxryly> atamagawarui: tabemann:  is that the idiomatic way to extract subexpressions from the algebraic data types?  seems verbose
22:46:41 <hoqhuuep> ski: I'm trying to mix applicatives, the bottom section of this file should give you an idea of what I'm doing: http://pastebin.com/Tv4SYiPd
22:46:49 <mauke> The paste Tv4SYiPd has been copied to http://hpaste.org/89273
22:47:21 <tabemann> oxryly: yes; remember, ADTs have more than one constructor, so you have to match against them to extract their values
22:47:51 <zedak> Scheme is one of the languages which did not got bloated after many revisions, and still embraces the principle of simplicity. I hope future standards of Haskell don't bloat the language.......
22:48:22 <ski> zedak : R6RS ?
22:48:24 <oxryly> zedak: scheme is notoriously fragmented in practice
22:48:24 <blz37> so for k :: ([a] -> [a]) -> [a], k is a function that takes a function that takes a list and return a list and k returns a list.
22:48:37 <ski> blz37 : yep
22:48:37 <blz37> @type filter
22:48:39 <lambdabot> (a -> Bool) -> [a] -> [a]
22:48:58 <tabemann> hoqhuuep: umm, that's using dynamic typing heavily, which just is not like how Haskell acts (when not using certain extensions, that is)
22:49:01 <hoqhuuep> ski: it keeps the expressions containing mixed applicatives in a data structure, then sort of bubbles one type of applicative up to the surface when you call from*
22:49:03 * atamagawarui wants -XMultiParamTypeClass in the standard already, -XOverloadedStrings (if it is good for Num, why not for strings?) too.
22:49:12 <zedak> ski: I used R5RS :)
22:49:38 <blz37> filter is a function that takes a function that takes an element and returns a Bool and returns a function that takes a list and returns a list.
22:49:47 <ski> yep
22:50:36 <zedak> What steps are taken by the people who do the reports so that Haskell the language remains what it is ??
22:50:38 <hoqhuuep> tabemann: I realise my python implementation is using dynamic typing, I think it "should" be possible statically
22:53:24 <ski> blz37 : you could try writing your own `filter', if you want to
22:55:24 <blz37> ski, I will try that. Now I am trying to get the higher-order function and partially applied function.
22:55:41 <blz37> Reading zipWith' from "Learn you a Haskell".
22:55:59 <blz37> Will be back in about 30 minutes.
22:57:12 <blz37> ski, what I learn today aside of Haskell is that you cannot stop with just the feeling of knowing. That is quite dangerous. Really need to nail it.
22:57:22 <ski> blz37 : if `g :: [a] -> [a] -> [a]' for some type `a', and `xs :: [a]' (for the same type `a'), then `g xs', of type `[a] -> [a]', is partially applied
22:57:36 <hoqhuuep> tabemann: the type of the parameter is determinable at compile time, so the implementation of the function to use (either \x.x or \x.[x]) should also be determinable at complie time. Nothing dynamic about that.
22:58:16 <blz37> ski : that is making sense.
22:59:09 <ski> blz37 : of course, "partially applied" here means just "not applied to all arguments" -- however, what is "all arguments" ?
22:59:22 <tabemann> hoqhuuep: but in Haskell you don't have C++ or Java-style overloading where you can choose what to do based on arbitrary type (as opposed to implementation of type classes, which is another story)
23:00:13 <ski> blz37 : typically, if the type looks like `a -> b -> c -> d' for some specific types `a',`b',`c',`d', and `d' is not of form `.. -> ..' itself, then one'd consider this as "taking three arguments"
23:00:31 <ski> (though, strictly speaking, every function takes exactly one argument)
23:02:33 <no-n> except for functions that take none
23:02:55 <tabemann> except in Haskell there is no such thing as a function that takes none
23:03:15 <tabemann> there are *values*, such as IO actions, which some could think of as such, but there are not really such
23:03:18 <no-n> ok
23:03:36 <no-n> ah, I thought that made more sense
23:03:52 <linduxed> i've read that "cabal is not a package manager" and that one shouldn't consider it being one, but is there some project which tries to achieve that? something that really tries to be the package manager for haskell?
23:05:45 <zRecursive> linduxed: maybe you can enhance cabal by yourself
23:06:23 <tero-> there's stackage
23:08:52 <linduxed> zRecursive: probably not atm
23:15:40 * hackagebot hledger-lib 0.21.1 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.21.1 (SimonMichael)
23:15:42 * hackagebot hledger 0.21.1 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.21.1 (SimonMichael)
23:15:45 * hackagebot hledger-web 0.21.1 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.21.1 (SimonMichael)
23:25:41 * hackagebot pipes-attoparsec 0.2.0.0 - Attoparsec and Pipes integration.  http://hackage.haskell.org/package/pipes-attoparsec-0.2.0.0 (RenzoCarbonara)
23:55:41 <Aetherspawn> @pl (\f -> NXFile <$> mmapFilePtr f Nothing)
23:55:41 <lambdabot> (NXFile <$>) . flip mmapFilePtr Nothing
23:55:58 <Aetherspawn> grr,
23:56:58 <Ralith> grr?
23:58:07 <Aetherspawn> lambdabot isn't very smart, it only pattern matches :(
23:58:27 <Aetherspawn> There was a way to do what I want really shortly using some operator, but I forget what it was
23:59:38 <ski> @type \f a b -> (f ?? a) b
23:59:39 <lambdabot> (t -> a -> b) -> a -> t -> b
