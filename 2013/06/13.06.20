00:01:06 <startling> is void just fmap (const ())? why is that useful?
00:02:49 <shachaf> For the same reason do { ...; return () } is useful.
00:03:30 <shachaf> I,I void :: Contravariant f => f a -> f Void
00:04:55 <startling> oh
00:05:11 <startling> I guess that is useful, especially for (<|>)
00:06:13 <c_wraith> or when, or...
00:06:20 <c_wraith> so many places you need m ()
00:06:56 <shachaf> Of course, there's no great reason for when to require m ().
00:07:51 <c_wraith> doesn't having when support m a require introducing bottoms?
00:08:10 <shachaf> Why?
00:08:23 <shachaf> (And: Do we really care in that kind of context?)
00:08:39 <c_wraith> what else is it going to do if its first arg evaluates to False?
00:08:49 <c_wraith> Where is it going to get an alternate value of the correct type?
00:08:56 <enthropy> @ty forever
00:08:57 <lambdabot> Monad m => m a -> m b
00:09:18 <startling> :t when
00:09:20 <lambdabot> Monad m => Bool -> m () -> m ()
00:09:24 <enthropy> you could have   forever :: m () -> m ()
00:09:34 <startling> c_wraith, return ()
00:09:41 <c_wraith> I guess when could be Bool -> m a -> m ()
00:09:50 <c_wraith> it just can't be Bool -> m a -> m a
00:09:55 <startling> yeah.
00:10:01 <shachaf> c_wraith: Yes, I meant Bool -> m a -> m ()
00:10:13 <shachaf> A strictly less restrictive type.
00:10:31 <startling> :t let when a b = if a then b else empty in when
00:10:32 <lambdabot> Alternative f => Bool -> f a -> f a
00:10:35 <c_wraith> less efficient, though
00:10:43 <shachaf> ?
00:10:56 <arkeet> forever :: m () -> m Void
00:11:04 <arkeet> or
00:11:06 <arkeet> :t forever
00:11:06 <lambdabot> Monad m => m a -> m b
00:11:08 <arkeet> actually this type is fine
00:11:10 <c_wraith> unless you're allowed to give it a different implementation for when a = ()
00:11:31 <startling> :t let when a b = if a then () <$ b else pure () in when
00:11:32 <lambdabot> Applicative f => Bool -> f b -> f ()
00:11:47 <startling> there are so many better implementations. :(
00:12:23 <c_wraith> shachaf: if it has to do some version of void when the type isn't m (), that's wasted work when the type is m ()
00:12:38 <shachaf> Well -- OK.
00:12:54 <shachaf> I think that argument was brought up before.
00:13:02 <startling> that's a silly argument.
00:13:12 <c_wraith> I do kinda wish GHC let you specify alternate implementations of a polymorphic function for specific types
00:13:21 <c_wraith> ...  It could be abused for great evil
00:13:27 <c_wraith> But it also could do some nice things
00:13:54 <shachaf> Just introduce a Typeable cosntraint everywhere.
00:14:04 <c_wraith> that's...  the opposite of solving it
00:14:05 <startling> at least the fmap id law guarantees that that optimization is legal
00:14:05 <shachaf> monochrom knew it would happen.
00:14:40 <c_wraith> adding a branch to skip a non-branch case doesn't help!
00:15:00 <shachaf> If the branch can be taken at compile time it does.
00:15:16 <shachaf> (Probably Typeable can't. But in theory it probably could.)
00:15:29 <c_wraith> Hmm.
00:15:31 <startling> which is it?
00:15:43 <c_wraith> Actually, RULES *can* let you specify a different implementation for specific types
00:15:53 <c_wraith> So ok, that issue can be solved
00:16:02 <shachaf> They can?
00:16:19 <c_wraith> yeah, there are lots of special cases of fromIntegral defined by RULES pragmas
00:17:12 <shachaf> Hmm, are those actually defined on the types?
00:17:31 <c_wraith> I thought so.
00:17:32 <shachaf> Ah, yes, I guess.
00:17:36 <c_wraith> Now you've got me doubting myself
00:17:45 <shachaf> When in doubt, doubt me.
00:18:08 <shachaf> That's the sort of thing cmccann would say.
00:18:08 <c_wraith> ok, I'm no on board with your proposed new type for when
00:18:14 <c_wraith> *now
00:25:01 <c_wraith> Wow, the RULES for this case would be really trivial. You don't even need to specify the type, since the rewriting engine only triggers when the LHS and RHS of the rewrite rule have the same type
00:25:21 <shachaf> Right.
00:25:30 * c_wraith is reading the manual
00:26:37 <shachaf> c_wraith: Are you crazy?
00:26:51 <c_wraith> I plead the 5th
00:34:28 * hackagebot ghc-heap-view 0.5.1 - Extract the heap representation of Haskell values and thunks  http://hackage.haskell.org/package/ghc-heap-view-0.5.1 (JoachimBreitner)
00:55:48 <external-reality> If someone would give me a hand with and intro to Fay -- I'd use it and I'd teach others.
00:56:43 <external-reality> Right now I just to compile a little algorithm with fay and got a bunch of JS. I didn't even know how to call my function.
01:09:29 * hackagebot mongoDB 1.4.1 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  http://hackage.haskell.org/package/mongoDB-1.4.1 (FedorGogolev)
01:40:13 <bakibour> Can anyone help me understanding what goes wrong here ? http://hpaste.org/90175
01:40:52 <bakibour> The commented out code in the main works fine, i just dont understand how the other main does not work and where the IO requirement comes from.
01:41:37 <supki_> @ty (>>=)
01:41:38 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:41:41 <yitz> bakibour: once you use unsafePerformIO, no one is going to be able to say much about what your program is going to do
01:41:53 <bakibour> Meh
01:41:54 <supki_> getOptions getArgs is not m a
01:42:24 <bakibour> Why does getOptions have to be in IO?
01:42:45 <supki_> because result of writeFile is
01:42:46 <bakibour> i first had do options <- getOptions getArgs
01:42:46 <yitz> bakibour: because it returns a different value every time. functions don't do that.
01:42:49 <bakibour> with the same error
01:42:50 <alpounet> bakibour, because it inspects the environment
01:42:53 <alpounet> this is a side-effect
01:43:05 <bakibour> Ah
01:43:27 <alpounet> getArgs obviously won't return the same list over and over again, every time you launch your program
01:43:33 <bakibour> So the proper fix to this problem is to make getOptions return IO Options?
01:43:41 <supki_> yes
01:44:02 <bakibour> This is one thing that i never grew accustomed with in Haskell :)
01:44:13 <alpounet> you will don't worry
01:45:17 <bakibour> How do i get the [String] from getArgs then? where (IO list) = args ?
01:45:31 <yitz> args <- getArgs
01:46:18 <yitz> inside an IO do block
01:48:08 <dmwit> Alternate answer: you do not get a [String] from getArgs. You turn the function you planned to write that takes a [String] into one that takes an IO [String].
01:48:42 <dmwit> (For example, by using fmap, (>>=), or their do-block equivalents.)
01:53:07 <ramses_> to clarify: you do write that function taking [String] but to use it, you use >>= or fmap to "lift" it through the IO
01:55:55 <bakibour> How i end up with having an IO () and requiring a () http://hpaste.org/90178
01:56:32 <bakibour> Er How = Now
01:56:44 <Botje> why are you fmapping over options?
01:56:54 <Botje> options is just a value with type Options.
01:57:17 <Botje> writeFile "test.xxx" =<< readFile (input options)
01:57:25 <bakibour> Now options are IO Options
01:57:32 <Botje> no they're not.
01:57:36 <Botje> you did options <- getOptions above
01:57:39 <dmwit> bakibour: do { options <- getOptions; fileContents <- readFile (input options); writeFile "test.xxx" fileContents } -- would be one fix
01:57:46 <Botje> so while getOptions :: IO Options, options :: Options.
01:57:55 <bakibour> Ah sorry
02:00:55 <bakibour> Ok thanks :)
02:04:30 * hackagebot papillon 0.0.7 - packrat parser  http://hackage.haskell.org/package/papillon-0.0.7 (YoshikuniJujo)
02:09:41 <b6> t7: we should hang out sometime <3
02:09:59 <t7> how you doin'?
02:10:13 <t7> (joey voice)
02:11:05 <b6> o/\o saving ram with short nicks club. every little bit helps.
02:11:21 * b6 doing his part for network efficiency
02:12:02 <Rembane> 2-byte-club
02:16:11 <Blkt> good day everyone
03:15:24 <asante> Hey, I'll already asked this on the beginners mailing list (but possible the wrong place) : is there a way to use RSA_PSK as a ciphersuit for a tsl connection? I didn't find something in the network.tls library..
03:16:16 <ksf__> I want a Show instance for functions, and don't give me that referential transparency crap.
03:17:08 <gspr> ksf__: What do you want for, say, show id?
03:17:12 <shachaf> kappabot: @run not
03:17:13 <kappabot>   {True->False;False->True}
03:17:23 <shachaf> kappabot: @run (\(x,y) -> (not x, y))
03:17:25 <kappabot>   {(True,())->(False,());(False,())->(True,())}
03:17:43 <ksf__> by input type is unbounded.
03:18:02 <ksf__> *my
03:18:45 <tdammers> instance Show (a -> b) where show _ = "function" -- there you go :P
03:19:00 <merijn> Is there a way to stop ghci from loading .ghci files?
03:19:23 <supki> -ignore-dot-ghci
03:19:50 <Taneb> kappabot: @run (\x->(x,not x))
03:19:51 <kappabot>   {True->(True,False);False->(False,True)}
03:20:11 <rickyroll> does anyone know how to make sure that indenting or spacing is correctly done inside textmate?
03:20:44 <rickyroll> i would write code that when pasted somewhere else have really bad indentation so when i compiled it prior to fixing the indentation i would get parse errors
03:20:52 <rickyroll> after i fix the indentation it seems to work fine
03:21:46 <ksf> can vacuum look into functions?
03:25:02 <merijn> blah, -ignore-dot-ghci and -ghci-script are mutually exclusive :(
03:25:45 <ramses_> merijn: mv ~/.ghci ~/.ghci_bak && ghci && mv ~/.ghci_bak ~/.ghci  ? :)
03:26:26 <shachaf> ramses_: Did you ever solve the GHC compilation error you had a while ago?
03:26:29 <merijn> ramses_: No, that's wrong
03:26:41 <merijn> ramses_: That starts ghci without reading .ghci from $HOME
03:26:49 <shachaf> Something about integer-gmp including some header file (I don't have the exact error anymore...).
03:26:58 <merijn> I want it to read the .ghci in $HOME, I just want it to not read any other .ghci
03:27:07 <Guest42963> I have a function f which folds over a list of objects.for each object a function g is called. in g there is the function i in a where clause defined. I use Data.MemoCombinators to save the results of i. my question: when the function g is left, is the lookup table of i discared? (I want to achieve this, since the obejcts are very different and I don't want to build a lot of memory during foling)
03:28:30 <ramses_> shachaf: I vaguely remember that, I'm trying to remember what the solution was
03:30:58 <ramses_> shachaf: I think my dev branch had a wrong remote for origin, so all submodules pulled from darcs.haskell.org but the ghc repo itself pulled from my githu fork, which hence didn't got updated either
03:31:22 <shachaf> OK.
03:31:28 <shachaf> I was having git issues so it's probably related.
03:31:29 <shachaf> Thanks!
03:31:53 <ramses_> np :)
03:31:56 <L8D> *cough cough*
03:32:40 <ramses_> shachaf: .git/config was the last place I thought of looking..
03:35:39 <Guest42963> g is defined in a where clause of f. i is defined in a where clause of g. i isn't in the scope of f, is it?
03:38:26 <supki> that sort of questions is best answered by experimenting
03:42:15 <ramses_> Guest42963: the answer might depend on the compiler options used, but I'm not sure
04:02:27 <merijn> Since #ghc isn't responding, where should I send proposals to change the behaviour of ghci?
04:02:57 <shachaf> merijn: A Trac issue is probably OK.
04:03:16 <shachaf> An email to glasgow-haskell-users or ghc-devs might be OK too... It depends, I suppose.
04:03:22 <merijn> shachaf: Is that a good medium for discussion?
04:03:51 <shachaf> Which?
04:04:06 <merijn> I'm all for unilaterally imposing my will on others (especially if it's for their own good!), but that might not be appreciated :p
04:04:09 <merijn> Trac
04:04:35 <Adeon> @pl \x -> f (-x)
04:04:36 <lambdabot> f . negate
04:04:36 <kappabot> f . negate
04:04:46 <Adeon> hmm, which bot is more correct
04:05:07 <shachaf> Well, it's (presumably) a feature request. You might suggest one thing and then have people discuss it in the comments and decide on a different thing.
04:05:26 <shachaf> E.g. what was happening in http://hackage.haskell.org/trac/ghc/ticket/7633
04:05:52 <shachaf> If it's a reasonably well-formed idea it's probably OK. If it's more vague then a mailing list post might be better.
04:06:06 <shachaf> But I'm not the person to ask. I'm just the person who answers.
04:06:47 <pete___> http://pastebin.com/uCrSb4BL -- what's wrong with this? I'm getting an Illegal instance declaration
04:06:53 <mauke> The paste uCrSb4BL has been copied to http://sprunge.us/PUWH?haskell
04:07:10 <mauke> pete___: it's an illegal instance
04:07:19 <pete___> I don't understand why
04:07:24 <merijn> shachaf: Basically I want to change the order in which ghci loads files, and allow the ability to selectively overwrite -ignore-dot-ghci
04:07:24 <mauke> doesn't it tell you?
04:07:33 <pete___> Either String has a kind of * -> *
04:07:39 <pete___> Not in language I understand :)
04:07:44 <mauke> pete___: what does it say?
04:07:45 <shachaf> merijn: Right. Well, probably one of the options I mentioned is reasonable.
04:07:53 <mm_freak> pete___: fmap f (Left x) = Left x
04:07:59 <mm_freak> the way you wrote it is a type error
04:08:04 <merijn> Because right now opening ghci in a folder can end up accidentally owning your box
04:08:07 <pete___> mauke: http://pastebin.com/DVabAxgC
04:08:09 <mauke> The paste DVabAxgC has been copied to http://sprunge.us/XYQD?haskell
04:08:19 <mauke> mm_freak: that's step 2
04:08:39 <shachaf> It's a pity you can't share l.
04:08:42 <absence> are there windows binaries for yi?
04:08:42 <mm_freak> mauke: indeed
04:08:52 <mm_freak> i assumed some extensions
04:08:53 <mauke> pete___: ok, so it says instances must have the form T a1 a2 ... an where all the 'a's are type variables
04:09:03 * pete___ thinks
04:09:05 <mauke> pete___: your T is either, but String is not a type variable
04:09:08 <mauke> erg
04:09:11 <mauke> your T is Either*
04:09:46 <mauke> i.e. you can have an instance Functor (Either foo), but not Functor (Either SomeConcreteType)
04:10:18 <pete___> Hrm, I thought I could have one of anything with a kind of *->*
04:10:46 <mauke> the *->* restriction is imposed by the Functor class
04:11:03 <mauke> the type variable thing is a general restriction that applies to instances in general
04:11:18 <pete___> ok
04:12:35 <shachaf> There are a bunch of rules on instances to make them relatively simple.
04:12:54 <shachaf> Some of the rules are less important than others. But in this case the rule is helping -- you don't *want* String there.
04:12:56 <mm_freak> minor note:  String is invalid by itself, too
04:13:16 <mm_freak> [Char] is still invalid, but for a different reason
04:13:23 <mauke> yeah, that's because String is merely an alias for [Char], not a separate type
04:13:45 <mauke> and [Char] is invalid because it's [] Char, i.e. [] applied to Char
04:13:58 <mauke> and because Char is not a type variable, we've gone full circle
04:14:16 <chrisdone_> elliott: did you see my message about repl's exception handling?
04:14:28 <shachaf> @time elliott
04:14:29 <kappabot> Local time for elliott is Thu Jun 20 12:14:06 2013
04:14:32 <lambdabot> Local time for elliott is Thu Jun 20 12:14:06 2013
04:14:55 <shachaf> @party #haskell
04:14:55 <lambdabot> Not enough privileges
04:15:11 <chrisdone_> party time? ʘ‿ʘ
04:15:36 <shachaf> lambdabot is too stuck-up to party #haskell
04:15:37 <kryft> My educated guess would be that elliott is sleeping if he ever does that
04:15:43 <chrisdone_> =p
04:15:49 <shachaf> Yes, elliott is sleeping.
04:16:04 <chrisdone_> hmm i should add that to ircbrowse, stats about when people are generally active
04:16:04 <tazjin> * charging
04:22:03 <chrisdone_> hm, there is indeed a cycle
04:23:17 <chrisdone_> http://hpaste.org/raw/90184
04:23:35 <chrisdone_> so yeah, elliott is usually in bed around this time 12-13 UTC
04:23:44 <chrisdone_> well, either in bed or just afk, anyway
04:24:07 <chrisdone_> shachaf: by your stats you should on average be going to bed soon =)
04:24:24 <chrisdone_> or afk
04:25:07 <chrisdone_> i guess the 1-2% is a good indicator of sleep as they span about 8 hours for both of you
04:28:32 <hpaste> chrisdone pasted “merijn's sleep cycle” at http://hpaste.org/90186
04:29:01 <chrisdone_> merijn's on the opposite scale, he's asleep by 0:00 utc. =p
04:30:47 <chrisdone_> hmm yeah i'm gonna make an irc profile page for each nick
04:31:45 <ocharles> Anyone here familiar with "Kleisli Arrows of Outrageous Fortune"? I'm having difficultly understanding the explanations around the 'Path' data type in Section 2
04:32:12 <ramses_> chrisdone_: are you affiliated with the NSA?
04:32:13 <ocharles> Specifically, I can't understand what McBride means by "Lists are effectively the graphs on
04:32:15 <ocharles> one
04:32:16 <ocharles> vertexoops
04:32:22 <ocharles> "Lists are effectively the graphs on one vertex"
04:37:13 <chrisdone_> ramses_: i'm trying to build a portfolio so one day i can be =p
04:47:30 <notdan> is there a way to make cabal be more verbose?
04:47:53 <notdan> I am trying to install a package with cabal-dev and I ge this: Resolving dependencies...
04:47:53 <notdan> cabal: Could not resolve dependencies:
04:48:02 <notdan> and no other output
04:48:42 <supki> -v3
04:49:47 <mami> hey folks
04:49:58 <mami> what is the dimension again of \mathbb{Z}
04:50:03 <mami> is it 0 or 1?
04:50:38 <mami> its a collection of points, but is this sufficient to be dim 1?
04:50:53 <mami> or: does anyone know of some good math channels?
04:54:51 <mmaruseacph2> mami: what do you mean by dimension?
04:55:46 <mmaruseacph2> if by dimension of A you mean the number of elements in \mathbb{R} which describe an element of A then the dimension of \mathbb{Z} is 1
04:57:12 <notdan> mmaruseacph2: hm, I don't think \mathbb{Z} is a vector space over R
04:57:24 <notdan> thanks supki
04:57:46 <sipa> the number of elements in Z is countable
04:58:01 <mauke> ℤℝℕ
04:58:17 <simon> sipa, I dare you!
04:58:32 <sipa> haha
05:00:42 <gspr> mami: If you know what properties you want "dimensionality" to have, then maybe we can figure out what kind of dimensional concept you mean
05:04:37 * hackagebot dimensional 0.12 - Statically checked physical dimensions.  http://hackage.haskell.org/package/dimensional-0.12 (BjornBuckwalter)
05:07:15 <mami> gspr: im looking for the dimension in the sense of degrees of freedom
05:07:40 <mami> e.g. \mathbb{R} = 1, \mathbb{R}^3 = 3
05:07:43 <mami> but can i
05:07:55 <mami> "move" in \mathbb{Z}
05:08:15 <mami> or is it just discrete jumping and thus does not count?
05:09:19 <quchen> Is that Haskell related?
05:10:40 <gspr> mami: Have you heard of modules?
05:10:50 <mami> gspr: nope, will investigate
05:10:50 <gspr> mami: But quchen has a point… this isn't really haskell
05:10:55 <Peaker> In: libHSrts.a libHSrts_debug.a libHSrts_l.a libHSrts_p.a  what's the "l" for?
05:11:15 <mami> quchen, gspr i know, this is why i asked for a maths channel ;) was too stupid to find one
05:11:33 <gspr> mami: Sounds to me that you're looking for the *rank* of a *free module*.
05:11:54 <quchen> mami: That's hard to believe. Maybe try #math.
05:12:14 <mami> quchen: oh
05:12:27 <mami> last time i tried i did not join ##math for some reason
05:12:34 <mami> but #math and that was empty
05:12:37 <mami> thank quchen
05:16:27 <Lethalman> is the ghc haskell parser written in bison? the one under compiler/parser
05:16:31 <Lethalman> is that the parser or there's something else?
05:18:43 <Peaker> seems like if you enable -debug and profiling, GHC fails to link because the RTS is shipped with either debug or profiling, but not both
05:36:55 <bitonic> Lethalman: the lexer/parser is written in alex/happy, which are kinda like lex and bison
05:36:58 <bitonic> but it’s messy
05:37:09 <bitonic> there is a lot of hand coded stuff
05:37:19 <bitonic> and the lexing and the parsing part interact in funny way
05:37:32 <bitonic> so if your hope is just extracting a bison grammar, it’s not going to work :P
05:40:08 <Shou> Hi, anyone here knowledgeable when it comes to Text.Regex? Apparently "[\x3041-\x309f]" matches a lot more than it's supposed to (that's the Japanese Hiragana range), but it matches against [a-zA-Z] values as well.
05:42:00 <Lethalman> bitonic, ah ok
05:42:15 <Lethalman> bitonic, thanks :-)
05:43:22 <quchen> Wasn't there some announcement a couple of weeks ago that Parsec should be added to Base?
05:43:45 <Saizan> > 'a' `elem` [\x3041 .. \x309f]
05:43:47 <lambdabot>   <hint>:1:20: parse error on input `..'
05:43:58 <Saizan> > 'a' `elem` ['\x3041' .. '\x309f']
05:43:59 <lambdabot>   False
05:44:00 <quchen> Ah, nevermind, it was only Cabal
05:44:10 <Shou> quchen, I think that was Attoparsec
05:44:47 <quchen> Shou: No, it's Cabal, I just found the message
05:44:54 <Shou> Saizan, yeah, that's why I'm baffled.
05:45:15 <mm_freak> Shou: i'm not sure, but you may want "\\" instead of "\"
05:45:32 <quchen> Shou: Eh, I meant "Parsec", not "Cabal" above.
05:46:12 <quchen> http://www.haskell.org/pipermail/cabal-devel/2013-March/009344.html
05:46:38 <Shou> quchen, oops, I confused base with Haskell Platform.
05:47:28 <tcsavage> Can anyone tell me why cycle :: [a] -> [a] from Data.List errors when applied to the empty list (rather than just producing [])?
05:47:41 <Peaker> @src cycle
05:47:41 <lambdabot> cycle [] = undefined
05:47:41 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
05:48:03 <Peaker> good question
05:48:24 <Shou> mm_freak, I tried that but then it just matches against even more unrelated things somehow
05:48:50 <quchen> tcsavage: I think it's because cycle should guarantee an infinite list.
05:49:06 <Peaker> @pl cycle xs = let xs' = xs ++ xs' in xs'
05:49:06 <lambdabot> cycle = fix . (++)
05:49:17 <tcsavage> Peaker: oh that makes sense I guess
05:49:23 <mm_freak> Shou: it was just a guess…  the matcher may not be unicode-aware
05:49:47 <Peaker> quchen, using partiality to make that guarantee is very ugly
05:49:54 <mm_freak> also it seems like a weird regex to use, unless it's part of something much more complicated
05:49:58 <Peaker> (giving one guarantee by breaking another)
05:49:58 <quchen> Peaker: Agreed
05:50:03 <merijn> Shou: I remember seeing a link called "regex bugs" which documented that one of the regex libraries just calls out (via C) to posix regexes, which not be unicode aware
05:50:25 <quchen> Peaker: But it goes well alongside head/tail/fromJust etc ;-(
05:50:39 <merijn> Clearly cycle should be "cycle :: [a] -> Maybe [a]"!
05:50:39 <aleator_> Quick query: Anyone here old enough to have been taught FP around 1995 with any ML style language?
05:50:58 <Saizan> Shou: try some other regex lib like regex-tdfa maybe
05:51:08 <merijn> aleator_: Why would you need to be old for that?
05:51:16 <Peaker> cycle :: NonEmptyList a -> Stream a
05:51:21 <merijn> aleator_: I TA'ed an ocaml course as recently as last year
05:51:46 <aleator_> merijn: Not old, but enough so to have been a CS student in mid 90's.
05:52:16 <Shou> mm_freak, merijn, ah that's probably it
05:52:31 <Shou> Saizan, I will :)
05:52:33 <aleator_> I've been reading through CS1 articles of the time period and am very curious about the actuality of that time.
05:52:36 <Shou> Thanks!
05:53:36 <quchen> merijn: Was that ironic?
05:54:00 <narens> is there already a lens to modify the ith value in a list?
05:54:08 <bartavelle> ix ?
05:54:23 <bartavelle> not sure it works on lists
05:54:31 <bor0> is there an easy way to order haskell merchandise (i.e. 1 t-shirt) that ships to Macedonia? most sites I've seen aren't shipping down here
05:54:53 <quchen> merijn: I'm not sure what cycle should be. A `Maybe` solution, well, introduces Maybe. I would say nonempty lists would be the better way to go here, but then some people argue that it shouldn't be in Base.
05:55:19 <narens> bartavelle: thanks, works
05:55:29 <supki> narens: also element
05:56:05 <supki> both aren't lenses though
05:56:27 <narens> supki: oh yeah... good point
05:57:07 <narens> hmm...
05:57:50 <tcsavage> quchen: as it stands, it could probably do with an extra note in the documentation saying that it's undefined for []
05:58:48 <quchen> tcsavage: That's a very unuhaskelly workaround though.
05:59:19 <tcsavage> and yet head and tail exist
05:59:43 <merijn> tcsavage: I like to pretend they don't
05:59:55 <Peaker> merijn, You never ever use head?
06:00:01 <quchen> Well, those make sense to a certain extent. They're direct accessors to a "Cons" list.
06:00:05 <Peaker> e.g: map head . group . ... ?
06:00:15 <Peaker> we lack some NonEmptyList type
06:00:24 <Peaker> so sometimes head is warranted :(
06:01:10 <quchen> `map head . group . sort` is a pretty cool replacement for nub.
06:01:20 <quchen> As long as there is order and it doesn't matter ;-)
06:01:32 <mm_freak> quchen: is it?  i think it's a sucky replacement
06:01:33 <aleator_> My experience is that though head seems attractive at points, it has almost never failed to give me gray hairs later on.
06:01:42 <mm_freak> with worse performance than nub, less lazy, …
06:01:54 <quchen> mm_freak: Worse performance? I think it's much faster.
06:02:31 <mm_freak> quchen: really?  compare:
06:02:38 <mm_freak> > head (nub [1..])
06:02:39 <lambdabot>   1
06:03:01 <mm_freak> quchen: your nub replacement traverses the entire list before giving you the first answer
06:03:28 <quchen> Well, when I want to filter out all unique elements of a list nub is awfully slow.
06:03:56 <quchen> It's true that it's lazier, which is good in some cases.
06:04:01 <mm_freak> quchen: then you should write a Set-based nub as a replacement, which is really just a short code snippet
06:04:15 <quchen> toList . fromList?
06:04:20 <mm_freak> no
06:04:26 <mm_freak> that's just sort
06:04:34 <mm_freak> *as bad as
06:04:38 <quchen> Oh, right.
06:04:38 * hackagebot nkjp 0.4.0 - Manipulating the National Corpus of Polish (NKJP)  http://hackage.haskell.org/package/nkjp-0.4.0 (JakubWaszczuk)
06:04:44 <quchen> I see what you mean.
06:05:53 <mm_freak> nub' = go S.empty where go s (x:xs) | S.member x s = go s xs | otherwise = x : go (S.insert x s) xs
08:01:01 --- topic: '["Haskell Platform 2013.2: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down, try: http://hdiff.luite.com "]'
08:01:01 --- topic: set by shachaf!~shachaf@unaffiliated/shachaf on [Tue May 28 01:16:22 2013]
08:04:41 * hackagebot haskell-names 0.1 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.1 (RomanCheplyaka)
08:05:51 <bergey> vector 0.10 removes support for Safe Haskell.  Is there a recommended replacement for packages which used the Vector.*.Safe modules?  Also, why?
08:06:36 <Taneb> Oh dear, this is going to be hashable all over again
08:06:50 <Taneb> And we haven't resolved hashable's safe haskell issues yet, either
08:07:07 <KingofFerrets> So... hm. If I have someone else's codebase that I'm importing that has a definition for what a State is, and I have a need to use the State monad, what the heck do I do?
08:07:52 <Taneb> qualified imports
08:08:42 <KingofFerrets> oh right that thing
08:09:01 <KingofFerrets> Haskell stop having so many neat features that I forget half of them. D:
08:09:42 <BeardedCoder> yes
08:09:54 <Gracenotes> yes?!
08:10:25 <elliott> bergey: what, really?
08:11:35 <bergey> elliot: That's what the release notes on Hackage say.  And the *.Safe modules aren't there.  I don't see any modules market Trustworthy now.
08:12:06 <bergey> It's not a feature I was using, I'm just trying to get another package to compile.
08:15:20 <elliott> bergey: seems like it was discussed on libraries@. sigh
08:15:44 <elliott> this is bad for me because it means it'll mess up lambdabot's use of safe haskell
08:19:47 <bergey> I see the thread now.  I would not have thought to look there.  Thanks!
08:30:18 <Peaker> Data.Attoparsec.Text.Lazy.takeTill :: (Char -> Bool) -> Parser Data.Text.Internal.Text
08:30:24 <Peaker> This seems like a bug (returns strict text!)
08:35:47 <monochrom> hmm, where is Haskell Weekly News!
08:47:43 <augur> sclv: https://github.com/psygnisfive/RegExWithZippers
08:48:09 <augur> not quite a full explanation yet, but a nice cleaned up version of it that uses thompson's algorithm for recognizing strings :
08:48:10 <augur> :)
08:54:37 <hpaste> “Anonymous Coward” pasted “peeking” at http://hpaste.org/90198
08:55:29 <Dtgr> is there a cleaner way to do the same? tried the one on the commented line but couldn't figure out the types quite right
08:56:06 <Botje> Dtgr: peekvalues <=< peek
08:56:28 <byorgey> Dtgr: <=< is like . but for monadic functions
08:56:34 <byorgey> @type (.)
08:56:40 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:56:40 <byorgey> @type (<=<)
08:56:40 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
08:56:56 <Dtgr> okay, thanks :) thought that there exists one but my hoogle skills suck
08:58:21 <merijn> wouldn't <<< and >>> work too?
08:58:41 <merijn> :t (>>>) `asAppliedTo` putStrLn
08:58:42 <lambdabot> (String -> IO ()) -> (IO () -> c) -> String -> c
08:58:50 <merijn> oh, no
08:59:00 <merijn> You'd need to Kleisli wrap 'em
08:59:50 <byorgey> right
09:00:07 <JoeyA> When I use MagicHash to create Addr# literals (e.g. "hello"# ), does it automatically put a trailing NUL at the end, or do I have to do that myself?
09:00:30 <JoeyA> e.g. Data.ByteString.packCString "hello\0"#
09:01:11 <joelteon> I think it does it itself
09:19:10 <Aetherspawn> @hoogle m ()
09:19:10 <lambdabot> System.Mem performGC :: IO ()
09:19:10 <lambdabot> Foreign.C.Error resetErrno :: IO ()
09:19:10 <lambdabot> Control.Concurrent yield :: IO ()
09:19:30 <Aetherspawn> is there anything that is like f = return () ?
09:19:40 <Aetherspawn> so I dont have to write (return ()) all the time
09:20:53 <Cale> Aetherspawn: Why do you find it necessary to write return () all the time?
09:20:54 <Cale> Usually it's only because something else is poorly designed that you'd need to do that.
09:21:01 <Cale> (there are some places...)
09:21:10 <Botje> (my guess, executing m a just for the side effects)
09:21:20 <Cale> :t void
09:21:21 <lambdabot> Functor f => f a -> f ()
09:21:31 <Aetherspawn> uh, for example, I use maybe (return ()) to execute something conditionally
09:21:40 <merijn> Aetherspawn: when
09:21:42 <merijn> :t when
09:21:43 <lambdabot> Monad m => Bool -> m () -> m ()
09:22:00 <merijn> :t unless
09:22:00 <lambdabot> Monad m => Bool -> m () -> m ()
09:22:18 <supki> sounds more like for_
09:22:20 <supki> @ty F.for_
09:22:21 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
09:22:27 <merijn> Aetherspawn: I usually write "whenJust" or use for_
09:22:39 <supki> whenJust :-(
09:23:05 <Aetherspawn> @hoogle whenJust
09:23:05 <lambdabot> No results found
09:23:23 <JoeyA> pure () is slightly shorter :-)
09:23:38 <JoeyA> :t pure
09:23:39 <lambdabot> Applicative f => a -> f a
09:23:58 <ClaudiusMaximus> can anyone recommend a toy compiler for a simple imperative language that i might study and extend?  didn't spot any on hackage or hayoo...
09:27:33 <Aetherspawn> oh, that's a pain. I setup a ubuntu VM and compiled lambdabot then copied all the binaries to the AWS vm (with not enough ram to build them) and now meuval-core complains about package lambdabot not found
09:28:53 <b2coutts> it looks like GHC.Num is a broken link on http://hackage.haskell.org/package/base/
09:29:04 <b2coutts> (as well as several other links near it)
09:29:39 <Spockz> ClaudiusMaximus: there is one for a java like language
09:29:44 * hackagebot Dung 0.9 - An implementation of the Dung argumentation frameworks.  http://hackage.haskell.org/package/Dung-0.9 (BasVanGijzel)
09:30:11 <Spockz> ClaudiusMaximus: http://www.staff.science.uu.nl/~dijks106/SSM/index.html
09:30:12 <typoclass> b2coutts: oh, thank you for the heads-up. please report it on the bug tracker (mentioned on the page you linked). thanks
09:32:31 <JoeyA> b2coutts: that's because the author used {-# OPTIONS_HADDOCK hide #-}
09:33:00 <JoeyA> It hides the documentation, but the link still appears on the package description page.
09:33:10 <JoeyA> It's a long-standing bug in Haddock.
09:36:14 <ClaudiusMaximus> Spockz: that looks like a sample target machine, not really what i'm after (my target/output is most likely to be C)
09:37:27 <ClaudiusMaximus> so i need more front-end/mid-end stuff (parser, type inference, register allocation)
10:08:30 * hackagebot cipher-aes128 0.4 - AES128 using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.4 (ThomasDuBuisson)
10:13:30 * hackagebot regex-pcre-builtin 0.94.4.6.8.31 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pcre-builtin-0.94.4.6.8.31 (JeffShaw)
10:19:04 <NemesisD> anyone know how to get hsenv to not use system packages? i'm getting a lot of "the following packages would be broken" errors on a fresh install of hsenv
10:19:46 <c_wraith> remove the system packages
10:20:37 <NemesisD> hmm, so i have to figure out by hand what packages i don't want and ghc-pkg unregister from within the dir?
10:20:59 <typoclass> NemesisD: not sure if this applies to your case, but monochrom recommends to tell cabal prefer the installed versions. http://www.vex.net/~trebla/haskell/haskell-platform.xhtml <- see section "rectify wrong settings"
10:21:09 <typoclass> NemesisD: the "constraint: foo installed" stuff
10:22:21 <KingofFerrets> Does anyone know of a tutorial on monads for someone who is being completely and utterly flummoxed by the damn things?
10:22:38 <c_wraith> KingofFerrets: the absolute best approach is to not care.  You'll understand them when you do.
10:22:48 <c_wraith> KingofFerrets: and until then, it's really *not* important
10:22:57 <mm_freak> KingofFerrets: the best way to understand them is to use them
10:23:14 <typoclass> KingofFerrets: i recommend you just write some code. the understanding will come
10:23:37 <byorgey> KingofFerrets: also, being completely and utterly flummoxed is a natural part of the learning process.  There is no one "right" tutorial which makes everyone unconfused.  Your confusion is uniquely your own.
10:24:04 <joelteon> there's a reason we have a monad tutorial fallacy
10:24:50 <josephle> correct approach to monads - don't use them until you *have* to
10:24:54 <byorgey> KingofFerrets: that said, have you read the typeclassopedia?
10:25:00 <byorgey> (shameless plug)
10:25:08 <mm_freak> josephle: huh?
10:25:20 <mm_freak> you can't write "hello world" without a monad
10:25:54 <KingofFerrets> I haven't.
10:25:54 <c_wraith> mm_freak: but you don't care, either
10:26:05 <KingofFerrets> And I kind of do have to.
10:26:24 <josephle> mm_freak: true, but since when was "hello world" the appropriate first haskell program? :P
10:26:28 <KingofFerrets> Because my requirement for the next stage of my project, set by my advisor, is "do the same thing you just did, but actually use the monads".
10:26:48 <mm_freak> josephle: (->) e is also a family of monads
10:27:03 <mm_freak> you can't write a useful haskell program without monads
10:27:28 <NemesisD> typoclass: crap. i don't think i have haskell-platform installed from my package manager
10:27:30 <josephle> mm_freak: rephrase: Don't use bind/return until you really have to
10:27:40 <mm_freak> =)
10:27:41 <josephle> erm (>>=)/return
10:27:53 <int-e> @type interact
10:27:54 <lambdabot> (String -> String) -> IO ()
10:28:05 <c_wraith> mm_freak: but the amount which you care about monads can be zero for a very long time
10:28:29 <typoclass> NemesisD: i meant only the part about telling cabal to prefer the stuff that is already installed, not try to replace it. but i'm not sure if that applies
10:28:30 <c_wraith> mm_freak: just because [] forms a monad doesn't mean that if you implement filter you're "using monads"
10:28:30 <byorgey> KingofFerrets: hehe, fair enough. =)
10:28:48 <NemesisD> typoclass: it was less noisy but complained that i didn't have unordered-containers
10:28:49 <josephle> c_wraith: and when it starts getting painful to thread the same argument through all your functions, *that's* when you'll learn to use the Reader monad :P
10:29:40 <supki> dcoutts: is it really necessary for cabal sandbox init to die if I have cabal-dev directory?
10:29:44 <c_wraith> mm_freak: I'd argue that until you're applying the abstraction, you're not "using monads", you're just using a particular type.
10:29:52 <NemesisD> wish it wasn't so easy to get yourself in trouble with cabal
10:30:02 <mm_freak> c_wraith: read what i wrote above…  we're agreeing
10:30:04 <mm_freak> ;)
10:30:17 <josephle> c_wraith: mm_freak was just being pedantic with me
10:30:25 <c_wraith> mm_freak: if we agreed, you wouldn't claim that writing hello world is using monads.
10:30:37 <c_wraith> It's using IO.  Nothing more.
10:31:29 <byorgey> NemesisD: the next release of cabal will have sandboxing (maybe even by default?) which will make it a hundred times easier to stay out of trouble.
10:31:39 <byorgey> (in exchange for some extra disk space.)
10:32:13 <byorgey> in fact I hear that the HEAD version is quite usable already, though I haven't actually tried it myself
10:32:24 <typoclass> KingofFerrets: i'd read typeclassopedia. the short story is: Monad is a typeclass; it has 3-4 functions; a number of functions in the standard library use monads as arguments or return types; there's a few popular instances of the typeclass. and there's a tiny bit of syntax that translates 'do' blocks into function calls of the Monad class
10:32:40 <mm_freak> c_wraith: /a/ monad
10:32:41 <NemesisD> byorgey: i made that trade a few times with cabal-dev and hsenv and i still get in situations where just trying to build my deps threatens me that (sandboxed) packages are likely to break. and i've been using haskell long enough to take those threats as promises
10:32:43 <typoclass> KingofFerrets: i hope that looked at it this way, it's really not mysterious
10:33:22 <byorgey> NemesisD: well, sure, if you keep reinstalling stuff in the same sandbox you're going to run into the same issues.  That's unavoidable.
10:33:26 <KingofFerrets> I got that much from Real World Haskell.
10:33:35 <NemesisD> byorgey: fresh sandbox created with hsenv
10:33:39 <byorgey> NemesisD: the nice thing about sandboxes is that there's zero cost to throwing them away (except the time of rebuilding).
10:33:44 <NemesisD> so maybe hsenv is being clever where it shouldn't
10:33:49 <KingofFerrets> ...I should see how much of my confusion is because of the State monad I'm using specifically, vs monads in general.
10:34:03 <NemesisD> rm -rf .hsenv, hsenv, source .hsenv/bin/activate, cabal install -j4 --only-dependencies :(
10:34:14 <KingofFerrets> Because I know the State monad is weird in the two-type-argument thing.
10:34:15 <byorgey> NemesisD: ah, well, it could just be that hsenv and cabal don't quite work together as well as they should.  Since hsenv is just a hacky wrapper in some sense that's not surprising.
10:34:26 <byorgey> NemesisD: I think having sandboxing built natively into cabal will help a lot.
10:34:34 <c_wraith> the big issue is that it's currently quite hard to tell cabal to ignore the non-sandbox stuff
10:34:45 <c_wraith> that's something the next version of cabal will handle much better
10:35:05 <NemesisD> byorgey: agreed. i stopped using cabal-dev because it is not a 1:1 matchup with the native haskell tools
10:35:11 <hodapp> whoa, I think I finally started making a little sense of AFRP in Yampa. Maybe.
10:35:15 <byorgey> right, I use hsenv myself
10:35:55 <josephle> I think monad tutorials should stop using the State monad as an implementation example. It just confuses everyone :/
10:35:57 <NemesisD> byorgey: any advice on how to start with a clean slate in this project? do i need to nuke something in my actual cabal dir?
10:35:58 <merijn> NemesisD: Out of curiosity, what are you doing that your dependencies break so often?
10:36:22 <byorgey> NemesisD: I don't know, sorry.  I've never run into problems like that with hsenv myself.
10:36:25 <NemesisD> merijn: i haven't worked on this project in 10 months. i use an OS with a rolling release package manager
10:37:14 <merijn> NemesisD: Ah, so you're installing haskell libraries from your OS package manager?
10:37:29 <NemesisD> merijn: not if i can help it. i don't like that model
10:37:46 <sm> NemesisD: http://hub.darcs.net/simon/cabal-install-tutorial/README.md#the-easy-solution-reset-your-packages
10:37:52 <NemesisD> in most languages you install the compiler/runtime from the package manager and everthing else from the lang's package manager. i'm using archlinux
10:38:00 <merijn> If you just install platform and then cabal for the rest shouldn't your pacage manager just leave things alone?
10:38:15 <NemesisD> much to my confusion, archlinux advocates installing packages from the OS package manager
10:38:22 <typoclass> NemesisD: you should rerun cabal with -v3 and hpaste the output that it gives you. include "ghc-pkg list" if relevant
10:39:21 <NemesisD> merijn: my OS doesn't provide haskell-platform directly. the user-maintained repos have haskell-platform, last version from 2012, not sure which i should do
10:40:00 <merijn> NemesisD: If you install GHC + cabal you could just install the platform packages using cabal
10:40:16 <byorgey> that's what I do (on arch linux)
10:40:21 <merijn> Might be easiest if there's not platform prebuild for your OS
10:40:47 <byorgey> actually it's not hard to install the platform from source
10:41:18 <NemesisD> byorgey: you use aur's haskell-platform?
10:41:22 <byorgey> no
10:41:59 <byorgey> I usually just grab a binary release of GHC and install it manually
10:42:41 <byorgey> but then I like being able to have a bunch of versions of GHC installed in parallel, using stow
10:42:58 <sm> why do you need stow byorgey ?
10:43:41 <byorgey> sm: http://byorgey.wordpress.com/2012/11/01/using-multiple-versions-of-ghc-in-parallel-with-gnu-stow/
10:43:51 <byorgey> I'm aware there are other solutions to the problem but this works well for me.
10:44:06 <c_wraith> I just flip symlinks to change ghc versions
10:44:16 <merijn> I just change my path :p
10:44:17 <byorgey> that's what stow does.
10:44:21 <c_wraith> well, a symlink.
10:44:22 <byorgey> but automatically.
10:44:24 <c_wraith> there's only one
10:44:43 <luite> i have my own script to make a symlink from ~/haskell/ghc to ~/haskell/ghc-version
10:45:03 <byorgey> it seems like every single person has a different home-grown solution to this problem =)
10:45:10 <c_wraith> it seems hard for something to be easier than creating a single symlink
10:45:37 <byorgey> c_wraith: but didn't you have to do a bunch of setup at the beginning, so that changing that one symlink would have the desired effect?
10:46:09 <c_wraith> No more setup than just installing ghc in the first place
10:46:24 <byorgey> which symlink do you change then?
10:46:30 <sm> I use use ghc[-pkg]-X.Y and cabal install -w ghc-X.Y . I see stow means you can switch once and no X.Y needed
10:46:30 <luite> i should probably use a script that modifies $PATH instead of doing a smylink
10:46:59 <c_wraith> same symlink luite mentions.  ~/ghc points to ~/ghc-version
10:47:26 <c_wraith> When I installed ghc, I put ~/ghc/bin in my path, instead of ~/ghc-version in my path
10:47:31 <byorgey> oh, I see
10:47:32 <luite> hmm, $PATH tricks wouldn't work from a script
10:47:33 <c_wraith> same amount of work
10:47:58 <byorgey> fair enough
10:48:14 <byorgey> in any case, I use stow for other stuff too
10:48:23 <byorgey> so it was easy enough to start using it for ghc
10:48:29 <c_wraith> I only recently realized how much work installing ghc actually does
10:48:48 <c_wraith> It actually builds all the paths into the wrappers it puts in the bin directory
10:48:55 <c_wraith> So that things just sort of work
10:49:07 <c_wraith> ... as long as you don't move the install directory post-installation
10:50:06 <sm> I don't mind typing -X.Y at all, it avoids confusion and requires no extra software
10:50:08 <hpaste> NemesisD pasted “wtf cabal” at http://hpaste.org/90200
10:50:15 <typoclass> c_wraith: does your shell cope with PATH containing a symlink that may change? i've occasionally heard of shells not picking up a new binary, meaning people have to restart their shell, or clear some internal shell cache with a mystic incantation
10:50:20 <byorgey> heh, right, I think I recall someone asking in here a while ago, who had installed ghc in their home directory and then moved their home directory!
10:51:03 <NemesisD> typoclass: typoclass ^ looks like installing haskell-platform from my OS repos is not practical. i'm kind of out of ideas
10:51:12 <byorgey> sm: I guess that just seems too magical to me, I'm not sure I trust that it will work right =)
10:51:15 <byorgey> but if you claim it does...
10:51:53 <c_wraith> typoclass: symlinks in the path haven't ever caused me problems.
10:51:58 <NemesisD> why on earth does cabal prefer the newest version?
10:52:06 <typoclass> c_wraith: interesting, good to know
10:52:08 <sm> it seems the least magical to me. GHC devs already took care of it, works great :)
10:52:42 <c_wraith> typoclass: however, I do also know that in bash, if things start working wrong, the magic command is "hash -r". :)
10:53:01 <byorgey> sm: fair enough.  But it means I have to be careful with any scripts that call ghc or any related tools, etc.
10:53:16 <aristid> c_wraith: so true
10:53:26 <byorgey> sm: since they would still be calling whatever version is called 'ghc' in the path, unless I parameterize them over the GHC version too
10:53:48 <sm> byorgey: yeah. I can see your use case especially if you're already using stow
10:54:45 <byorgey> sm: on the other hand, one nice thing about typing the version explicitly is that you can be compiling stuff with different versions of GHC in parallel, whereas with the stow solution you can't do that
10:54:55 <sm> but if GHC version matters, your scripts should probably be specifying it explicitly
10:54:55 <typoclass> c_wraith: mystical incantation!
10:55:20 <byorgey> sm: well, but what if I want to test the scripts on several different versions of GHC
10:55:43 <sm> command line argument :)
10:55:56 <byorgey> right, that's what I meant by "unless I parameterize them over the GHC version too"
10:56:25 <typoclass> NemesisD: line 315 and thereabouts indicates it's trying to downgrade bytestring and up or downgrade two other packages. try "constraint: bytestring installed"?
10:56:50 <sm> some lightweight ghc* version selection via an env var is probably doable
10:57:02 <byorgey> anyway.  Hopefully if merijn is successful in getting travis to support different versions of GHC/HP, that will get rid of one use case for this anyway =)
10:57:46 <AsgardBSD> A good day to learn haskell!
10:57:58 <c_wraith> As are all days.
10:58:18 <luite> byorgey: but should travis do the switching with a single symlink, with stow, or on the command line? this needs to be discussed!
10:58:23 <byorgey> hahaha
10:58:26 <AsgardBSD> Well, you stole me my next replic
10:58:28 <typoclass> AsgardBSD: heh :-) indeed. check this out, and its links:
10:58:28 <troydm> the funny thing is you can't stop learning haskell
10:58:30 <typoclass> @where tryhaskell
10:58:30 <lambdabot> http://tryhaskell.org/
10:58:40 <AsgardBSD> @hi
10:58:40 <lambdabot> hitchcock ... Hitchcock's Bible Names Dictionary (late 1800's)
10:58:47 <byorgey> haha, wat
10:58:54 <AsgardBSD> @how are you
10:58:55 <lambdabot> Maybe you meant: yow show
10:59:01 <byorgey> @hi Abraham
10:59:03 <lambdabot> *** "Abraham" hitchcock "Hitchcock's Bible Names Dictionary (late 1800's)"
10:59:03 <lambdabot> Abraham, father of a great multitude
10:59:03 <lambdabot>  
10:59:08 <AsgardBSD> :( haskell boot is not so cool
10:59:39 <AsgardBSD> Lets make a new haskell boot (a haskell project for me) :)
10:59:46 <byorgey> AsgardBSD: blasphemy!
11:00:09 <byorgey> > map pred "BthbseCTE"
11:00:10 <lambdabot>   "AsgardBSD"
11:00:44 <tac> > fmap succ "Hello world"
11:01:01 <AsgardBSD> why did lambdabot talked to me...
11:01:01 <AsgardBSD> map pred "BthbseCTE"
11:01:08 <lambdabot>   mueval-core: Time limit exceeded
11:01:08 <tac> > fmap succ "Hello world"
11:01:08 <lambdabot>   "Ifmmp!xpsme"
11:01:08 <byorgey> > map succ "HAL"
11:01:09 <lambdabot>   "IBM"
11:01:24 <AsgardBSD> > map succ "HAL"
11:01:25 <byorgey> AsgardBSD: if you type > followed by an expression, lambdabot will evaluate the expression and print the result
11:01:28 <lambdabot>   "IBM"
11:01:28 <byorgey> > 1 + 2
11:01:29 <lambdabot>   3
11:01:44 <troydm> > map succ [1,2,3]
11:01:45 <lambdabot>   [2,3,4]
11:01:49 <troydm> hmm
11:01:55 <AsgardBSD> > map pred "BthbseCTE"
11:01:56 <lambdabot>   "AsgardBSD"
11:02:03 <troydm> > map succ ['H','L','A']
11:02:04 <lambdabot>   "IMB"
11:02:04 <AsgardBSD> why does > map pred "BthbseCTE" == asgardBSD?
11:02:07 <troydm> oic
11:02:14 <AsgardBSD> Ho...
11:02:17 <AsgardBSD> pred
11:02:21 <AsgardBSD> preceding character
11:02:22 <byorgey> > pred 3
11:02:23 <troydm> it's ASCII feature
11:02:24 <lambdabot>   2
11:02:25 <byorgey> > pred 'x'
11:02:27 <lambdabot>   'w'
11:02:34 <troydm> > succ 'H'
11:02:36 <AsgardBSD> well, forget what i said
11:02:36 <lambdabot>   'I'
11:02:53 <AsgardBSD> that boot is wonderful (altought, not funny has the debian irc channel one...)
11:02:57 <troydm> it's interesting if this was coincidence or not
11:03:08 <troydm> i bet Kubrick did it intentionally
11:03:14 <byorgey> @slap AsgardBSD
11:03:14 * lambdabot would never hurt AsgardBSD!
11:03:21 <c_wraith> troydm: he claims it was not intentional
11:03:23 <byorgey> @botsnack
11:03:23 <lambdabot> :)
11:03:24 <c_wraith> well, claimed
11:03:36 <AsgardBSD> @pet
11:03:37 <lambdabot>  Define what?
11:03:40 <AsgardBSD> @lol
11:03:40 <lambdabot> Maybe you meant: yow url roll pl let do
11:03:46 <byorgey> @yow
11:03:46 <lambdabot> Will the third world war keep "Bosom Buddies" off the air?
11:03:53 <AsgardBSD> @joke
11:03:53 <lambdabot> Maybe you meant: vote more join
11:03:54 <NemesisD> typoclass: would running off of cabal HEAD help with this. i'm more than willing to work off of the bleeding edge of cabal if it means i can avoid wasting time
11:04:00 <byorgey> @list
11:04:00 <lambdabot> What module?  Try @listmodules for some ideas.
11:04:03 <AsgardBSD> Well, enough played with boot
11:04:14 <sm> NemesisD: what's the problem again ?
11:06:58 <AsgardBSD> what about : type inference
11:07:04 <AsgardBSD> Haskell figure out the right type
11:07:10 <AsgardBSD> But may i force the type?
11:07:16 <chrisdotcode_> in do { x <- getStrLn } what type does x have?
11:07:21 <josephle> :t (::)
11:07:23 <lambdabot> parse error on input `::'
11:07:29 <josephle> darn it!
11:07:30 <josephle> :P
11:08:18 <b2coutts> :t getStrLn
11:08:18 <josephle> AsgardBSD: just use "expr :: type"
11:08:19 <lambdabot>     Not in scope: `getStrLn'
11:08:19 <lambdabot>     Perhaps you meant one of these:
11:08:19 <lambdabot>       `putStrLn' (imported from Prelude),
11:08:33 <supki> chrisdotcode_: what type getStrLn has?
11:08:38 <josephle> it'll force the typechecker to check whether or not expr has the type after "::"
11:09:05 <b2coutts> :t getLine
11:09:06 <lambdabot> IO String
11:09:28 <typoclass> AsgardBSD: 99% of the time you don't have to write type signatures, but you can if you want. most people write signatures for top-level functions, but not for lower-level ones. this is a good compromise that gives some orientation to the programmer
11:09:41 <supki> chrisdotcode_: (your proposed do-block is not syntactically valid, btw)
11:09:49 <elliott> typoclass: definitions, not functions
11:09:59 <elliott> it's good practice to give type signatures to top-level definitions whether they're functions or not
11:10:10 <typoclass> elliott: yes. i'm trying to keep it entry-level
11:10:14 <AsgardBSD> Normally, i hate to be too much verbose, ecept when it come to type
11:10:26 <elliott> ?
11:10:34 <elliott> "definitions" is just as entry-level as "functions" and one is true rather than false...
11:12:03 <AsgardBSD> What is : x/=y ??
11:13:03 <typoclass> elliott: well "definitions" is more abstract (more general). also, i don't think the term "false" is quite the right description of what i said ("most people write signatures for top-level functions")
11:13:15 <byorgey> AsgardBSD: not equal to
11:13:24 <typoclass> AsgardBSD: it means "not equal to". it's the opposite of "=="
11:13:27 <byorgey> > (3 /= 4, 3 /= 3)
11:13:29 <lambdabot>   (True,False)
11:13:42 <typoclass> > (3 == 4, 3 == 3)
11:13:43 <lambdabot>   (False,True)
11:14:00 <elliott> typoclass: I don't think "definition" is any more abstract than "function". I suspect a newcomer to Haskell is more likely to get the right meaning for the former, in fact (since their conception of "function" likely includes side-effects beyond partiality)
11:14:01 <byorgey> it's supposed to look like an equals with a slash drawn through it, the way a mathematician would write "not equal to"
11:14:15 <typoclass> elliott: ok, fair enough
11:18:59 <akegalj> i want to strict read bunch of files in directory. Haskell complains for too many open files (laziness) so i'm trying to use strict-io package which wraps its resoults in SIO monad. I am trying to do something like "mapM System.IO.Strict.readFile $ System.Directory.getDirectoryContents "."" and result of those is IO [SIO String]. How can i unwrap those two monads in one do block?
11:23:20 <byorgey> akegalj: it looks like you want to use the 'run' function which goes from SIO to IO
11:24:46 <Gracenotes> hm... where is the Eq a => Eq [a] instance in GHC source code?
11:25:00 <akegalj> byorgey: u saved my day, thnx
11:25:18 <Gracenotes> or is it derived?
11:27:27 <Gracenotes> probably is....
11:27:41 <yogert> Hey I am running into some problems with type classes. Anyone think they could give me some tips regarding: http://hpaste.org/90203
11:27:47 <AsgardBSD> Why my function is not working ? sumList xs = (if null xs then 0 else (head xs + sumList tail xs))
11:27:56 <chrisdone_> elliott: poke
11:28:02 <geekosaur> AsgardBSD, parentheses
11:28:09 <geekosaur> sumList (tail xs)
11:28:32 <geekosaur> `sumList tail xs` invokes `sumList` with two parameters: a function and a list
11:28:39 <elliott> chrisdone_: pong!
11:29:53 <dolio> Gracenotes: ghc-prim/GHC/Classes.hs
11:30:37 <neutrino> hello, dolio,
11:30:49 <AsgardBSD> productList xs = (if null xs then 1 else (head xs * productList (tail xs)))
11:30:49 <AsgardBSD> factorial x = productList [1 .. x]
11:30:59 <AsgardBSD> I like haskell :)
11:31:01 <byorgey> yogert: that doesn't look possible.
11:31:33 <byorgey> AsgardBSD: congrats! =)  Now, write the same function using pattern-matching on xs, instead of using the functions null, head, and tail
11:31:45 <yogert> byorgey: Because it would somehow involve treating a type contructor as a concrete type?
11:31:47 <byorgey> using pattern matching is much more idiomatic
11:31:47 <AsgardBSD> byorgey: pattern matching ?
11:32:12 <byorgey> AsgardBSD: oh, you haven't gotten to pattern matching yet, sorry.  What tutorial are you following?
11:32:18 <yogert> So, for this hypothetical library, what would be a better design? Forgoing the use of classes?
11:32:21 <AsgardBSD> http://learnyouahaskell.com/chapters
11:32:42 <byorgey> AAAARGH, that's right, LYAH teaches the head and tail functions before pattern matching
11:32:45 <AsgardBSD> Altought it look a little childish
11:32:49 <byorgey> bad LYAH! bad!
11:32:55 <AsgardBSD> Well, im only at chapter 1
11:33:12 <byorgey> AsgardBSD: anyway, proceed, you need not concern yourself with my pedagogical pet peeves =)
11:33:13 <AsgardBSD> i mean chapter 2
11:33:25 <byorgey> you'll come to pattern matching soon I think
11:33:36 <AsgardBSD> does list are at the heart of FP?
11:33:49 <byorgey> no.
11:33:59 <byorgey> it's just that lists are the simplest nontrivial recursive type.
11:34:06 <tac> byorgey: that *is* bad.
11:34:10 <AsgardBSD> most of the them, when i come accross FP, i always see list
11:34:17 <tac> (I'd be happy with it never teaching head or tail)
11:34:19 <byorgey> they correspond to for loops and while loops in other languages.
11:34:30 <byorgey> tac: agreed.
11:34:44 <elliott> LYAH does lots of bad things :(
11:34:44 <tac> AsgardBSD: lists are a very basic data structure that FP handles extraordinarily well.
11:35:12 <hodapp> elliott: like what?
11:35:44 <elliott> uh, i think it misuses the word "functor" a lot and calls them containers or something.
11:36:02 <napping> AsgardBSD: algebraic data types in general are arguably pretty fundamental, and also lisp in particular makes lists a primitive
11:36:44 <AsgardBSD> Well, last time i came here (few month ago, maybe 3 month) every one recommended me LYAH
11:37:04 <AsgardBSD> I hasked if there was other good ressource to learn, and they just said to stick to LYAH
11:37:05 <hodapp> yeah, it runs quite deep in Lisp... in that your entire damn program is pretty much just a list
11:37:11 <elliott> yes, LYAH is probably the best tutorial to read.
11:37:17 <tac> AsgardBSD: It's still a good tutorial. Just from a puritan's standpoint, it's not... pure :)
11:37:18 <elliott> doesn't mean it's perfect, of course
11:37:33 <elliott> the only perfect tutorial is the one I haven't written!
11:39:10 <AsgardBSD> how to put comment?
11:39:30 <NemesisD> sm: building an old project, it is having trouble on breaking reinstalls because newer versions of bytestring/text/etc http://hpaste.org/90200
11:40:22 <AsgardBSD> Does a capital letter has special meaning? In my IDE, if i write my function with a starting capital letter, it turn out blue (anyways, function should always start with a lower case)
11:41:08 <Taneb> Yes it does
11:41:26 <Taneb> Only a particular sort of function can begin with a capital letter
11:41:57 <Taneb> You'll learn about those in a chapter or two
11:41:58 <josephle> does haskell actually force a syntatic distinction between type constructors and functions? (aside from all type constructors must begin with a capital letter)
11:42:08 <AsgardBSD> how to make comment?
11:42:20 <geekosaur> -- comment to end of line
11:42:22 <Taneb> AsgardBSD, -- is a line comment
11:42:22 <josephle> one line: --, block: {- -}
11:42:25 <Taneb> {- is a block
11:42:27 <Taneb> comment -}
11:42:33 <geekosaur> {- comment extending to a -}
11:50:03 <Gracenotes> dolio: oh, thanks... I was looking at base
11:50:26 <xplat> you know what's annoying?  you can't really make 'the first two arguments of bracket' into a monad because you would need at least a parameterized monad.
11:51:26 <xplat> prove me wrong and you earn the right to say 'i told you so' and 10,000 plaudits
11:52:33 <napping> what do you want in the monad?
11:53:36 * hackagebot hpygments 0.1.3 - Highlight source code using Pygments  http://hackage.haskell.org/package/hpygments-0.1.3 (DavidLazar)
11:54:27 <napping> (ContT .) . bracket :: IO a -> (a -> IO b) -> ContT r IO a
11:54:44 <napping> but that's probably the wrong scope
11:55:31 <AsgardBSD> productList [] = 1
11:55:31 <AsgardBSD> productList xs = head xs * productList (tail xs)
11:55:31 <AsgardBSD> factorial x = productList [1 .. x]
11:55:35 <AsgardBSD> is it better now?
11:55:59 <byorgey> AsgardBSD: better! but you can improve it still further.
11:56:04 <AsgardBSD> how?
11:56:16 <byorgey> AsgardBSD: you can match on xs too.  you should not need the head and tail functions.
11:56:24 <AsgardBSD> how?
11:56:42 <napping> this is covered in chapter 4 of your tutorial, if you just want to keep following it
11:56:51 <byorgey> you can use the pattern (x:xs)  to match a list whose head is x, and tail is xs
11:56:58 <byorgey> so  productList (x:xs) = ...
11:58:41 <AsgardBSD> productList (x:xs) = (x:_) * productList (_:xs)
11:59:04 <AsgardBSD> i saw somewhere there was underscore everywhere...
11:59:04 <byorgey> almost, but (x:_) and (_:xs) don't make sense
11:59:06 <elliott> not quite
11:59:18 <elliott> if you matched on (x:xs), then x is the head and xs is the tail
11:59:25 <byorgey> once you have pattern-matched on (x:xs) you just get to use the variables x and xs
11:59:25 <AsgardBSD> in scala and in most other FP language i see underscore in most of the thing
11:59:33 <elliott> that is to say, head (x:xs) = x, tail (x:xs) = xs, and since you replaced xs by (x:ys) (renaming to ys for clarity), head xs becomes x
11:59:36 <elliott> and tail xs becomes ys
12:00:09 <byorgey> AsgardBSD: you will see some underscores show up in Haskell too.  But don't just try sticking them in random places =)
12:01:24 <AsgardBSD> Interesting, i quite like haskell
12:01:35 <AsgardBSD> new way of thingking
12:03:36 * hackagebot nitro 0.2.2.1 - Haskell bindings for Nitro  http://hackage.haskell.org/package/nitro-0.2.2.1 (ErinDahlgren)
12:06:35 <napping> xplat: what kind of monad did you have in mind?
12:07:40 <AsgardBSD> Have to go guy
12:07:50 <AsgardBSD> Still had some tast of what is haskell
12:08:17 <AsgardBSD> (will maybe do some haskell during my philosophy course, while the teacher will be speaking... summer school at college...)
12:09:32 <xplat> napping: one where you go do { x <- lift thing; y <- lift $ blah blah another thing; userSuppliedAction x; cleanup x; moreCleanup x y }
12:10:23 <napping> which is supposed to bracket how?
12:10:29 <xplat> napping: userSuppliedAction is part of the monad
12:10:49 <napping> and cleaning up y after x ?!
12:11:35 <xplat> napping: when you 'unwrap' the monad, you would get effectively 'bracket (the stuff before userSuppliedAction) (the stuff after userSuppliedAction)'
12:12:27 <xplat> napping: when you do a single 'bracket' that sets up multiple things you don't have to clean them up in any particular order, that only happens if you nest multiple brackets
12:13:29 <napping> ah, well you clearly can't make anything like that interface a monad
12:13:36 * hackagebot warp 1.3.8.3 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.8.3 (MichaelSnoyman)
12:13:38 * hackagebot nitro 0.2.2.2 - Haskell bindings for Nitro  http://hackage.haskell.org/package/nitro-0.2.2.2 (ErinDahlgren)
12:13:57 <napping> half the point of being a monad is that what cleanup actions you want to do are allowed to depend on the result of your "userSuppliedAction"
12:16:12 <jeff_s1> Are there any garbage collectors written in Haskell that can be used for EG an interpreter?
12:16:13 <xplat> napping: userSuppliedAction could be of a type like 'Bracket a b ()'
12:16:52 <xplat> napping: er, a -> Bracket a b ()
12:17:42 <xplat> napping: that wouldn't present a problem for a monad, the place where i see a problem is preventing userSuppliedAction from appearing twice
12:23:04 <Saizan> can you have two kinds of "lift" instead? one for initializations and one for cleanups
12:23:33 <tippenein> hsenv: fd:9: hGetContents: invalid argument (invalid byte sequence)
12:23:36 <tippenein> hsenv: thread blocked indefinitely in an MVar operation
12:23:36 * hackagebot warp 1.3.8.4 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.8.4 (MichaelSnoyman)
12:23:46 <tippenein> any idea on the above hsenv error? ^
12:26:19 <hpaste> fizruk pasted “liftF and iterM” at http://hpaste.org/90205
12:28:15 <fizruk> edwardk: hi! I found these functions helpful, do you need these in Control.Monad.Free? http://hpaste.org/90205
12:29:13 <edwardk> i should switch to the more general liftF definitely
12:29:18 <fizruk> edwardk: I believe liftF should be in Control.Monad.Free.Class
12:29:28 <edwardk> likewise
12:31:42 <fizruk> edwardk: any thoughts on iterM?
12:32:51 <edwardk> i'm somewhat neutral on it. If it went in I'd like to see variants of it for the other Free monad equivalents.
12:33:41 <edwardk> iterT was added recently to control.monad.trans.free iirc
12:33:48 <edwardk> with a very similar signature
12:34:42 <edwardk> liftF is now in the repo
12:37:20 <fizruk> edwardk: thanks! iterM is different from iterT, because monad instance does not depend on Free type.
12:37:38 <edwardk> sure
12:37:51 <edwardk> hence why i was willing to add it, just indicated that a similar function existed ;)
12:37:54 <fizruk> edwardk: yet, I haven't yet convinced myself that it is necessary to place it in the library
12:38:37 * hackagebot http-conduit 1.9.4.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.9.4.1 (MichaelSnoyman)
12:41:13 <edwardk> Added iterM for Free and Church Free
12:42:28 <bakibour> Hidiliho
12:43:08 <sipa> if haskellers ever start a religon, they should call it Church Free
12:43:29 <bakibour> Earlier i asked how i do apply a list of functions to a list in that order and someone told me to use zipWith id
12:44:19 <bakibour> Works fine and the time it did not struck me really how it worked but now that i think about it i do not really get it how it works, i thought it was just simple partial application, but i cant figure it out really. Can someone help me to grasp it?
12:45:14 <Botje> zipwith id [f1,f2,f3,...] [x1,x2,x3,...] = [id f1 x1, id f2 x2, ...]
12:45:41 <Botje> id f1 x1 = (id f1) x1
12:45:48 <Botje> and, since id x = x, id f1 = f1
12:45:48 <bakibour> AH!
12:45:48 <Botje> so id f1 x1 = f1 x1
12:46:01 <bakibour> I always tried to apply id to the right...
12:46:11 <edwardk> fizruk: hackaged
12:46:25 <djahandarie> :t ($)
12:46:26 <lambdabot> (a -> b) -> a -> b
12:46:42 <djahandarie> :t id :: (a -> b) -> a -> b
12:46:42 <lambdabot> (a -> b) -> a -> b
12:47:06 <elliott> bakibour: you should write it as zipWith ($).
12:47:10 <Luke> johnw: do you know if elisp or haskell-mode has a string-replace-all function?
12:47:14 <dgpratt> @src ap
12:47:14 <lambdabot> ap = liftM2 id
12:47:20 <bakibour> elliott: Why?
12:47:36 <elliott> bakibour: because it's clearer
12:47:54 <dgpratt> oh, that brings back memories -- nearly broke my brain trying to grok "ap zip tail"
12:48:37 * hackagebot free 3.4.2 - Monads for free  http://hackage.haskell.org/package/free-3.4.2 (EdwardKmett)
12:48:37 <bakibour> I still dont quite get it how it works to pass the function with less parameters instead of the one with 2, is that simply partial application?
12:48:39 * hackagebot void 0.6.1 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.6.1 (EdwardKmett)
12:48:59 <Botje> bakibour: there are no functions with two parameters. only functions that return functions.
12:49:02 <djahandarie> bakibour, what functions are you referring to here?
12:49:10 <shachaf> I recommend that you do some unification by hand to figure it out.
12:49:12 <djahandarie> id and ($)? Because they both only have a single parameter.
12:49:15 <bakibour> zipWith id
12:49:16 <AsgardBSD> Anything interesting in haskell that could be useful for me?
12:49:24 <AsgardBSD> (i mean ressource)
12:49:31 <shachaf> zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]; id :: d -> d
12:49:33 <AsgardBSD> Actually, only have LYAH
12:49:38 <shachaf> Figure out what a, b, c, and d are.
12:50:27 <bakibour> shachaf: How does unification work again?  I need to replace a -> b with d -> d?
12:51:08 <shachaf> You don't need to replace anything... You need to make things match.
12:51:12 <napping> you need substitutions for a,b,c,d so a -> (b -> c) = d -> d
12:51:33 <shachaf> If I say: id 'a', and id :: q -> q, and 'a' :: Char, then I can figure out what q is (it's Char).
12:52:17 <bakibour> Ok
12:52:43 <AsgardBSD> is it possible to see the assembly outpout in compilation?
12:52:47 <bakibour> So ... d is (b -> c)
12:53:04 <bakibour> and a is d
12:53:09 <Botje> AsgardBSD: you won't learn much from it.
12:53:12 <bakibour> so a is (b -> c) also?
12:53:18 <hvr> Luke: replace-regexp-in-string
12:53:28 <Luke> hvr: thanks
12:53:30 <napping> yes, and the type of zipWith id is then?
12:53:34 <AsgardBSD> well, could be interesting to see how my haskell code become in machine code
12:53:56 <napping> AsgardBSD: you might start looking at core
12:54:06 <AsgardBSD> core?
12:54:56 <napping> compile with -ddump-simpl and perhaps also -dsuppress-all
12:55:43 <bakibour> So whenever i provide less in terms of partial application Haskell does unification to determine the types?
12:55:58 <elliott> it's not related to partial application
12:56:03 <napping> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html
12:56:04 <elliott> (haskell has no concept of partial application by itself)
12:56:05 <bakibour> Ok
12:56:12 <elliott> unification is how all the type checking is done
12:56:37 <bakibour> What unification algorithm does it use?
12:56:38 <fizruk> edwardk: cool! :)
12:56:57 <companion_cube> bakibour: probably the simplest one ;)
12:57:49 <bakibour> Unification just works on types right?
12:58:29 <AsgardBSD> Cool, i like how we create data type in haskell
12:58:37 <AsgardBSD> I think i will tatoo Haskell on me...
12:58:45 <AsgardBSD> (ok maybe not, i hate tatoo)
13:00:16 <byorgey> bakibour: right
13:01:01 <byorgey> AsgardBSD: data Tattoo = Mom | OtherTattoo String
13:01:12 <bakibour> I did all taht years ago i should know it :) well i did it in logics but i guess its the same ...
13:01:39 <byorgey> bakibour: it's the same at a fundamental level.  Figuring out how all the concept transfer over can take some time though.
13:02:09 <bakibour> Is there any book paper or lecture i could skim to grasp this?
13:02:31 <sclv_> preflex: seen bos
13:02:32 <preflex>  bos was last seen on #haskell 1 day, 15 hours, 5 minutes and 2 seconds ago, saying: @pl \_ v -> g v
13:02:53 <Moggle_> if you want to learn about unification, you could learn prolog
13:03:00 <Moggle_> it's pretty simple
13:03:12 <sclv_> step one in learning prolog: understand unification
13:03:23 <bakibour> Yeah well i did that in university years ago :) so its just the same?
13:03:30 <dgpratt> sclv_: :)
13:06:04 <xico> btw is there any doc on how the type inference is done in ghc?
13:06:13 <xico> does it look like hm(x)?
13:07:04 <Botje> it was HM a long time ago
13:07:09 <Botje> now it's HM with lots of tentacles
13:07:25 <sipa> HMmmmm
13:07:35 <xico> by the (x) i mean with constraints like ocaml
13:08:56 <bos> sclv_: que paso?
13:08:56 <levi> Well, it's got different extensions than ocaml does, AFAICT.
13:09:13 <elliott> xico: perhaps see http://www.haskell.org/haskellwiki/Simonpj/Talk:OutsideIn
13:09:20 <sclv_> hiya bos, just adding my voice to the grumpy parade about hashable and trustworthy
13:09:50 <sclv_> this is obviously something we care about enough to put at a low level in our stack
13:09:57 <xico> elliott: thanks! exactly what i was looking for :)
13:10:07 <sclv_> and where the authors have taken seriously various security questions
13:10:16 <elliott> xico: :)
13:10:17 <sclv_> up to the point of sacrificing a form of referential transparency (optionally)
13:10:47 <sclv_> so its designed to be used in trusted situations
13:10:58 <sclv_> i know that we might not feel everything is yet perfect and there may be things lurking
13:11:15 <sclv_> but it seems its better to mark it as trustworthy, to allow others to decide to trust it
13:11:26 <sclv_> since implicitly there's a social contract asking people to trust it in a zillion other ways
13:12:41 <bos> sclv_: i'll integrate some patch shortly
13:12:52 <sclv_> ok, cool, thanks!
13:13:27 <malorie> I'm thinking about making a simple 2D game and was wondering wether I could use a haskell typeclass to represent the game world. something that, e.g., models how a house is structured with its rooms etc, and generates actually renderable data. is there something like that?
13:13:37 * hackagebot categories 1.0.6 - Categories  http://hackage.haskell.org/package/categories-1.0.6 (EdwardKmett)
13:13:39 * hackagebot eq 3.1.1 - Leibnizian equality  http://hackage.haskell.org/package/eq-3.1.1 (EdwardKmett)
13:13:57 <edwardk> bos: thanks! i'm currently frantically patching packages trying to restore safe haskell in the presence of hashable 1.2 =(
13:14:00 <byorgey> malorie: type classes are unlikely to be the right tool for that.
13:14:15 <edwardk> its rather ridiculous how far the cancer spreads
13:14:32 <malorie> well, don't EDSL boil down to certain type classes?
13:14:45 <edwardk> e.g. categories was pushed because it uses void, and void bothered to provide a hashable instance, because if you can construct a bogus value you might as well hash it ;)
13:15:13 <byorgey> malorie: sometimes.
13:15:24 <byorgey> malorie: do you want to make an EDSL for writing games?  Or you just want to make a game?
13:15:49 <edwardk> bos: the 3 lines needed are in issue 69 in tibbe's repo. https://github.com/tibbe/hashable/issues/69
13:16:49 <malorie> byorgey: I want to make a game, but at the same time I'm wondering whether there's an EDSL for describing 2D worlds, or something akin to it. maybe one for representing graphs?
13:17:00 <levi> malorie: You might be confusing type classes with object-oriented classes. They cover a little bit of the same ground, but they're not quite used for the same things.
13:17:15 <bakibour> malorie: Something like GDL (game description language)?
13:17:21 <byorgey> malorie: ah.  I don't know of any EDSL for describing 2D worlds.  For graphs we have the fgl package.
13:17:42 <byorgey> though it might be too abstract for your purposes, I'm not sure.
13:17:42 <levi> For *graphcs* there's the Diagrams package, which is really cool.
13:17:48 <levi> Er, *graphics*
13:17:52 <byorgey> thanks levi =)
13:18:08 <levi> It's more for static graphics, though; there are probably more appropriate ones for games.
13:18:22 <xico> gloss?
13:18:45 <levi> But it's an example of an EDSL for describing 2-d abstract constructs that have a graphical representation.
13:18:45 <xico> (for game graphics, not worlds)
13:19:03 <dgpratt> malorie, not Haskell, but if you were interested in writing 2D games in a Haskell-like language, you should check out Elm
13:19:12 <malorie> byorgey, levi: I'll take a look at that
13:19:42 <levi> malorie: It relies heavily on the typeclass Monoid, which is a very useful one for creating compositional models.
13:26:34 <ethoma7329> If I have a function that uses mutable IOArrays but also should be in the State monad, how should I make the function part of both the State and IO monads?
13:26:58 <Botje> you probably can't.
13:27:15 <shachaf> You can use (StateT s IO).
13:27:22 <byorgey> sure you can.  You need  StateT s ... what shachaf said.
13:27:26 <bakibour> One more dumb question about the unification, why does zipWith id work but why doesnt zipWith (\x -> x + 1) ?
13:27:27 <shachaf> But it's possible that you just want an IORef at that point.
13:27:28 <AsgardBSD> have to go guy
13:27:33 <AsgardBSD> bye, later
13:28:00 <shachaf> bakibour: My answer is once again to do the unification by hand. :-)
13:28:18 <ethoma7329> Yes I think I do just want an IORef - thanks for bringing that to my attention
13:28:20 <byorgey> bakibour: well, what type does zipWith expect?  What type is id?  What type is (\x -> x + 1)?
13:28:49 <bakibour> Isnt id and (\x -> x + 1) of the same type?
13:28:56 <byorgey> no
13:29:10 <Ralith> ethoma7329: you might also consider ST, STArrays, and STRefs
13:29:11 <byorgey> id has a more general type than (\x -> x + 1)
13:29:18 <bakibour> Yes true
13:29:22 <Ralith> :t id
13:29:23 <lambdabot> a -> a
13:29:23 <shachaf> id has type "a -> a" and let's pretend (\x -> x + 1) has type "Int -> Int"
13:29:35 <ethoma7329> Ralith: I will later - but those are more complicated and I am still a beginner
13:29:36 <shachaf> "a -> a" is magical. Did you do the unification from before?
13:29:43 <Ralith> ethoma7329: a reasonable decision.
13:30:05 <OxGOOSE> putStrLn "hello world"
13:30:13 <bakibour> shachaf: Yes a = d and d = (b -> c) i think
13:30:25 <augur> sclv_: did the repo's readme make sense?
13:30:51 <shachaf> OK, so a = (b -> c)
13:31:02 <shachaf> Now do the same thing with (\x -> x + 1), which has type Int -> Int
13:31:36 <bakibour> Then a = (Int -> Int)
13:31:50 <sclv_> yeah, it seemed clear. but i didn't spend a whole lot of time thinking through it
13:32:07 <Taneb> Thing I would like: a version of the Endo monoid lifted to any Category
13:32:16 <sclv_> was sort of bogged down today tbh
13:33:09 <bakibour> Ah id passes the function as a value...
13:33:21 <sclv_> don't know if you need your "bizipper"
13:33:23 <bakibour> Thats why it wont work with + 1
13:33:32 <sclv_> not clear what it means to be "to the right of x but not yet at the left of y"
13:34:16 <bakibour> Anyway thanks, ill have to check on that a bit more i guess.
13:38:52 <xtalmath> is there a channel on http://en.wikipedia.org/wiki/Proof_assistant 's ?
13:41:03 <byorgey> xtalmath: there are channels for specific proof assistants, like #agda, #coq, and #idris
13:41:14 <byorgey> I don't know of a channel about proof assistants in general
13:41:37 <matheus23> hey guys, I'm having an issue with indentation: http://pastebin.com/F5WQW6Bh I like constructive critism, but a quick solution would be neat, too :)
13:41:39 <mauke> The paste F5WQW6Bh has been copied to http://sprunge.us/JKJQ?haskell
13:41:57 <josephle> I wonder if anyone has started doing HoTT proofs in idris, considering there is a considerable HoTT codebase in both agda and coq
13:42:32 <byorgey> josephle: I doubt it.  idris is nowhere near the maturity of agda and coq when it comes to being used as a proof assistant.
13:42:58 <byorgey> the focus of idris is really more on being a practical dependently-typed language than on being a proof assistant.
13:43:01 <matheus23> Error: parse error (possibly incorrect indentation or mismatched brackets)
13:43:38 * hackagebot llvm-general 0.1 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-0.1 (BenjaminScarlet)
13:43:48 <elliott> matheus23: "case ()" must be indented further than "getChar"'s start
13:43:55 <elliott> btw please don't name your definition getChar, that name is taken :)
13:43:58 <Fuuzetsu> matheus23: lay off parenthesis a bit, it's not Lisp
13:44:00 <elliott> (turn on -Wall to get warnings about that)
13:44:17 <matheus23> oh I liked the simplicity of lisp's syntax, thank you both :)
13:44:30 <chrisdone> byorgey: haskell - practical lazy pure language, idris - practical dependently-typed language?
13:44:38 <Fuuzetsu> Lisp doesn't really have syntax
13:44:39 <byorgey> chrisdone: that's the idea.
13:44:58 <chrisdone> byorgey: seemed that way to me to. it's an approach that appeals to me =)
13:44:58 <byorgey> strict pure dependently-typed language.
13:45:01 <Ralith> chrisdone: you should come help make it happen!
13:45:47 <chrisdone> dude i've already got 20 yaks lined up waiting to be shaved, don't send me a whole truck full
13:45:52 <matheus23> Fuuzetsu: that's what makes it so simple
13:46:08 <byorgey> @remember chrisdone [on being invited to help with idris development] dude i've already got 20 yaks lined up waiting to be shaved, don't send me a whole truck full
13:46:08 <lambdabot> Okay.
13:46:25 <merijn> chrisdone, byorgey: I already proposed locking edwardk in a room with only a text editor and an Idriss compiler to fix Idriss' library issues ;)
13:46:39 <Ralith> chrisdone: they're really fuzzy yaks, and they want to be your friend!
13:46:48 <Ralith> merijn: oh man, I wish
13:46:54 <byorgey> haha
13:46:57 <edwardk> merijn: more likely you'd just get a verified implementation of a Haskell compiler written in Idris
13:47:01 <chrisdone> =p
13:47:07 <merijn> edwardk: Dammit
13:47:29 <byorgey> edwardk would then proceed to type in the entire contents of Hackage from memory
13:47:29 <geekosaur> but will it support all the ghc extensions?
13:47:34 <byorgey> then he would pick up where he left off
13:47:38 <edwardk> even more likely everywhere i had to fill in a proof it'd just say 'trust me'
13:47:41 <Ralith> merijn: he's still edwardk, that'd involve writing at least ten highly general utility libraries
13:47:55 <bos> edwardk: i know the lines are there, but that's not the same as a pull request :-)
13:48:00 <edwardk> byorgey: nah, just lens. same diff
13:48:11 <edwardk> bos: i sent a pull request
13:48:20 <merijn> In the tradition of generically named libraries, edwardk's haskell compiler will just be called "compiler"
13:48:24 <byorgey> edwardk: right, sorry, I should have said, the *important* bits of Hackage
13:48:38 <edwardk> https://github.com/ekmett/hashable/commit/7d56ac193a163328be38d4c137491560058745d4
13:48:43 <joelteon> merijn: i'd call it "program"
13:48:43 <chrisdone> zing!
13:49:04 <merijn> If you fill in the right type signatures it changes from a haskell compiler into a different language compiler
13:49:18 <joelteon> compiler :: Compiler Haskell
13:49:34 <edwardk> er https://github.com/tibbe/hashable/pull/70
13:49:38 <joelteon> Compiler is parameterized on the type of language it compiles
13:49:59 <edwardk> do you have a separate hashable repo?
13:50:59 <edwardk> merijn: my toy haskell compiler is currently 'turbo haskell' ;)
13:51:32 <edwardk> joelteon: i'm waiting to write 'program' until after i've written all the libraries it can depend on.
13:51:39 <joelteon> oh
13:52:04 <edwardk> joelteon: you'll know its getting close when i release the 'library' library
13:52:11 <joelteon> right
13:52:24 <joelteon> then the "thing" library/executable
13:52:30 <joelteon> which generalizes to any task that anyone could want to complete
13:53:30 <b2coutts> thing :: a -> Thing a
13:53:54 <joelteon> no
13:54:03 <joelteon> thing :: (Thingish a, Applicative f) -> f a
13:54:19 <joelteon> thing :: Compiler Haskell -- ghc implementation
13:54:23 <joelteon> err, haskell compiler implementation lol
13:54:28 <joelteon> there goes my joke
13:54:31 <b2coutts> haha
13:54:50 <shergill> eikke: ooc, who was the palantir recruiter that got in touch with you? (i just got an email out of the blue)
13:55:54 <chrisdone> @tell typoclass yeah i thought about this problem. just hiding the non-chat would make a lot of pages very small. for different page sizes, i would have to generate separate indexes for each page size you want to support. 25m rows is not fast to do offsets on in postgres without that. so i could do 35 and 200. an alternative could be an infinite scrolling support, then you don't care about page size, you just scroll without having to
13:55:54 <lambdabot> Consider it noted.
13:55:54 <chrisdone> click next or back
13:56:24 <shachaf> @tell typoclass <chrisdone> click next or back
13:56:24 <lambdabot> Consider it noted.
13:56:26 <chrisdone> thanks
13:57:27 * sclv_ is tempted to write a 'program' library that contains utility functions for producing programs of songs and performers for classical concerts
13:58:02 <sclv_> and a 'library' library that contains utility functions for working with Library of Congress and Dewey Decimal classifications
13:58:06 <thetallguy2> is there a way in ghci to list all threads currently running?
13:58:20 * b2coutts writes a 'mutation' library for modelling DNA variation
13:58:38 * hackagebot playlists 0.1.0.0 - Library and executable for working with playlist files.  http://hackage.haskell.org/package/playlists-0.1.0.0 (PeterJones)
13:58:39 <tdammers> and a 'utility library' library that contains utilities to manage software libraries for utility companies
13:59:01 <sclv_> oh, a 'containers-api' library that binds to the web api of the container stor
13:59:14 <tdammers> yeah
13:59:32 <tdammers> a garbage collection service would probably use both the containers library and the utility library
13:59:38 <tdammers> not the library library though
13:59:56 <sclv_> b2coutts: nah, the 'mutation' library should have utility functions for drawing zombies
14:00:15 <tdammers> I think moving this to -blah will become appropriate any minute now
14:00:17 <sclv_> or mutant zombies
14:03:26 <Luke> johnw: hvr: chrisdone: I updated shnippet with better completion for your current module name and guessing at how you'll want to qualify an import https://github.com/LukeHoersten/shnippet/commit/485bd86d615cbf20de6f96b77d735b6dad36b689#L18L6
14:03:49 <johnw> Luke: cool!
14:03:55 <johnw> Luke: there is no string-replace-all
14:05:26 <Fuuzetsu> Luke: Do you hate newlines at the end of the file?
14:06:42 <chrisdone> Luke: cool =)
14:08:25 <Luke> Fuuzetsu: yes. those newlines are literal newlines in yasnippet
14:08:38 * hackagebot comonad 3.0.3 - Haskell 98 compatible comonads  http://hackage.haskell.org/package/comonad-3.0.3 (EdwardKmett)
14:09:03 <Luke> Fuuzetsu: i really wish yasnippet required 2 newlines at the end of the file to translate to a literal newline in the template but it sadly doesn't.
14:09:50 <Luke> johnw: hvr: chrisdone: I'll probably try and get a bit more real haskell coding done using these snippets to ensure churn is down before moving them into haskell-mode
14:10:03 <Luke> and hopefully collect more feedback
14:10:21 <johnw> Luke: that sounds excellent, let me know how it goes
14:10:22 <Fuuzetsu> Ah, okay. I should probably get around to using yasnippet but I don't really have much use for it in Haskell… Not enough boilerplate I guess.
14:10:28 <johnw> I'm quite eager to start putting these snippets to use myself
14:10:48 <Luke> they're usable now if you want to help give more usability feedback?
14:10:49 <johnw> yes, I will start today
14:11:12 <mm_freak> Fuuzetsu: yasnippet is great for starting a new module
14:11:50 <mm_freak> you have to write the module name only once, which leaves less room for errors
14:12:55 <merijn> hub.darcs.net is dead?
14:13:08 <sm> what what ?
14:13:09 <mm_freak> merijn: no
14:13:13 <mm_freak> works for me
14:14:06 <merijn> mm_freak: I was trying to access the link you send me, but I'm getting a bad gateway error :\
14:14:56 <mm_freak> merijn: weird…  just try again
14:15:30 <merijn> Well, it didn't work the past 20 retries, so I'm not expecting that to change :p
14:16:58 <adnap> :ne
14:17:05 <sm> merijn: which url
14:17:07 <mm_freak> merijn: http://hub.darcs.net/ertes/cascading ⇐ this one?
14:17:07 <adnap> bluebonnet flashlight points north
14:17:41 <josephle> adnap: I really hope that isn't a password
14:19:06 <merijn> mm_freak: Yeah
14:21:37 <merijn> Anyway, I had a similar idea to your Reader with an inFocus boolean (I was just gonna keep the focus state in the specific widget and send in "Focus Bool" inputs. "Then wire combinators can choose to distribute the focus to only certain"
14:21:41 <merijn> subwires.
14:22:13 <merijn> mm_freak: That's actually I have trouble with, I could come up with a few ways to implement that, but most of the ideas I had made things very unwieldy
14:22:18 <sm> merijn: I see segfaults in the darcs hub logs, but I can't reproduce - please pm me if you'd like to help track it down
14:22:27 <mm_freak> hub.darcs.net is an alias for joyful.com. joyful.com has address 173.255.219.222
14:22:35 <flebron> Silly question: If I call f (a + 1) (a + 1), will the (a + 1) necessarily be computed twice, and thus it'd be better to define b = a + 1, f b b?
14:22:56 <mm_freak> sm: oh, that's bad…  if i can help, let me know
14:23:05 <geekosaur> flebron, in general that is true
14:23:07 <sm> mm_freak: can you reproduce it ?
14:23:37 <mm_freak> sm: i've never seen it
14:23:39 * hackagebot tagged 0.6.1 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.6.1 (EdwardKmett)
14:24:00 <flebron> geekosaur: Thanks :)
14:24:16 <c_wraith> how do things in tagged keep changing?
14:24:21 <c_wraith> I was under the impression it was simple!
14:24:46 <shachaf> c_wraith: This is due to hashable and SafeHaskell, I think.
14:25:01 <merijn> mm_freak: i.e. one idea I had was to have wires "Input -> Widget", inhibit when they lose focus (while using hold_ to keep outputting their previous state), but that's messy as you'd need to wrap all your wires in a combinator for that, making the inaccessible to the rest of the code you're writing
14:25:04 <nobb> how can i trap signals?
14:25:14 <adnap> josephle: It was. I just changed it now XD
14:25:16 <flebron> geekosaur: Is this also the case if I'm calling f a i, with a static but i changing a lot, I should define g = f a, and call g i?
14:25:24 <c_wraith> shachaf: oh, that would make sense
14:25:27 <mm_freak> merijn: yes, that's messy
14:25:41 <adnap> It was my user account password for my computer
14:25:48 <mm_freak> merijn: i generally prefer the Writer approach to generating UIs/documents
14:26:03 <merijn> mm_freak: Yeah, maybe I should take that approach anyway
14:26:12 <mm_freak> if you can't explain the UI/document as a monoid, it's probably broken anyway =)
14:26:28 <geekosaur> flebron: you'd probably want to inspect the core to be certain, but that's a common pattern in various ghc implementations of standard functions so I'd guess it's still likely to be the case
14:26:36 <geekosaur> ghc does not, in general, do CSE
14:26:58 <byorgey> flebron: yes, if f can do some nontrivial computation before seeing its second argument, then that is likely to help
14:27:32 <flebron> f a b is just arr ! (a, b), so I wouldn't think so xP
14:27:45 <byorgey> ah, in that case it doesn't matter
14:27:47 <byorgey> right
14:27:53 <merijn> mm_freak: I'm unsure how else to select between multiple wires, though?
14:28:07 <mm_freak> merijn: "how else"?
14:28:45 <merijn> Well, I understand having a Wire combinator merging all inputs into a single one, but no clue how to approach things without merging all of them
14:31:08 <merijn> Maybe I just need to study the code in your CSS link more now that it works again :p
14:33:37 <merijn> Actually
14:33:39 * hackagebot semigroupoids 3.0.3 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-3.0.3 (EdwardKmett)
14:33:43 <merijn> I think I might have an idea now
14:34:00 <merijn> Maybe things will finally come together :p
14:36:40 <mm_freak> merijn: =)
14:37:36 <mm_freak> merijn: the basic idea is that you have a build configuration and a result document
14:38:11 <mm_freak> then a "widget" is of type:  forall m. (MonadReader BuildCfg m, MonadWriter Doc m) => m a
14:38:33 <mm_freak> to make user interface, wrap Wire around it
14:38:39 * hackagebot either 3.4.1 - An either monad transformer  http://hackage.haskell.org/package/either-3.4.1 (EdwardKmett)
14:39:37 <merijn> Or maybe not...I swear....
14:40:02 <merijn> mm_freak: To summarise my relation with netwire, replace "this graph" with "netwire" in the axis labels: http://abstrusegoose.com/191
14:40:44 <mm_freak> hehe
14:41:01 <mm_freak> netwire is just a tool
14:41:07 <mm_freak> you don't have to agree with me on how to use it =)
14:41:17 <mm_freak> i'm just telling you how i would do it
14:42:57 <merijn> mm_freak: No, I mean every time I have a lightbulb moment and go like "Of course! That's how I should implement it!" I run of to my editor, start typing and realise "wait...this won't work at all..."
14:43:40 * hackagebot bytes 0.8 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.8 (EdwardKmett)
14:44:45 <merijn> I guess that if you're building the UI in the Writer then the eventual return value should probably be ()
14:45:10 <levi> merijn: That's my experience with haskell programming in general.  Probably because I spend too much time staring at things and not enough writing code. ;)
14:46:02 <merijn> levi: I've reached the point where I consider most haskell coding "obvious", so I feel I must be missing something...
14:46:03 <mm_freak> merijn: UIs are highly nontrivial
14:46:23 <hvr> Luke: btw, have you considered making sure some of the snippets only expand when at the start of line?
14:46:28 <merijn> mm_freak: I've realised :p
14:46:34 <Luke> hvr: they do that
14:47:03 <Luke> hvr: anything top-level makes sure the key starts at the beginning of the line
14:47:09 <mm_freak> merijn: one of the reasons why you may find yourself in sticky situations with netwire is that i really need to fix the inhibition problem
14:47:19 <mm_freak> the current left-catch approach to inhibition is bad
14:47:41 <mm_freak> but doing that will require a new major version and break all existing code
14:47:54 <merijn> mm_freak: You mean inhibition not propagating as far as possible, you mean?
14:48:04 <merijn> Yeah, that'd be a lot more convenient
14:48:13 <Luke> hvr: for example: # condition: (= (length "mod") (current-column))
14:48:39 <mm_freak> merijn: yeah
14:48:40 * hackagebot pointed 3.0.3 - Haskell 98 pointed and copointed data  http://hackage.haskell.org/package/pointed-3.0.3 (EdwardKmett)
14:48:42 * hackagebot charset 0.3.5 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.3.5 (EdwardKmett)
14:49:03 <mm_freak> merijn: left-distribute inhibition would also be much easier to explain categorically
14:49:31 <hpaste> merijn pasted “UI” at http://hpaste.org/90206
14:50:00 <merijn> mm_freak: To get back to my "wishful thinking code", that seems like the code I'd want to write
14:50:23 <merijn> But I just realised that if I make t1/t2 Wires, then I can't really conveniently make them Comonads in a sensible way
14:50:29 <Luke> hvr: are you looking at the latest code?
14:50:35 <hvr> Luke: I am right now :-)
14:50:35 <merijn> So then extract wouldn't work...
14:50:39 <Luke> k
14:51:24 <hvr> Luke: one of the snippets I use here is for {-# (NO)INLINE ... #-}
14:51:29 <mm_freak> merijn: your main problem may be that you have a geometric interpretation of wire/widget combinators
14:52:05 <merijn> mm_freak: What do you mean by that?
14:53:04 <mm_freak> merijn: composition doesn't have to mean adjacent placement
14:53:14 <mm_freak> in fact i'd be fine with a completely separate layout description
14:53:23 <hvr> Luke: and one for {-# OPTIONS_GHC $1 #-}$0
14:53:25 <merijn> mm_freak: I was actually going for that initially, but I got lost there too
14:54:20 <merijn> mm_freak: I know what I want, and I have a rough idea of how to write it, and every time netwire seems so tantalisingly close, but so far I haven't gotten anywhere tangible.
14:54:22 <hvr> Luke: and then I have few ones for .cabal files for benchmark/test/executable
14:55:09 <mm_freak> merijn: maybe what you really need is something like netwire =)
14:55:13 <mm_freak> not netwire itself =)
14:55:18 <merijn> It feels like the things I want shouldn't be that hard
14:55:59 <mm_freak> well, they aren't hard per se, but there is a tradeoff
14:56:00 <mm_freak> flexibility vs. convenience
14:56:01 <merijn> mm_freak: Yes, I have considered this, but reimplementing all of netwire seems like such a waste of effort :\
14:57:14 <merijn> It feels like things should be fairly easy, but I'm not sure whether I'm just not able to see the right approach or whether it's just not possible in netwire, meaning I'm wasting my time
14:58:05 <mm_freak> merijn: everything is possible, but not everything is as elegant as we would like it to be
14:58:23 <mm_freak> i'm currently unhappy with the internals of netwire, but unfortunately i got no time to work in it
14:58:27 <mm_freak> s/in/on/
14:58:41 * hackagebot bits 0.2.1 - Various bit twiddling and bitwise serialization primitives  http://hackage.haskell.org/package/bits-0.2.1 (EdwardKmett)
15:00:03 <flebron> If I say something like "facs = listArray (0, 50) $ 1:[(fromIntegral i) * (facs ! (i - 1)) | i <- [1..50] :: [Int]] :: Array Int Integer", if I call facs ! 45 twice, it will only compute it once, correct? (And the second time return it from the array)
15:01:17 <phulin> I'm trying to show big arithmetic expressions (big binary tress with depth of a few hundred nodes). Will using recursive printf calls take quadratic time? Or is printf smart?
15:01:21 <phulin> (Unless I'm confused, printf will be bad, so is there a better solution?)
15:01:22 <merijn> I guess the main issue I keep running in is whether to see Widget as wires or as something else. If they're wires that makes controlling input/focus direction (just pick which wire to run), but that makes getting anything out of the Widget annoying. Vice versa, not being Wires makes getting things out easy, but make it really annoying to get them to behave
15:04:50 <mm_freak> merijn: definitely not wires
15:04:59 <mm_freak> the UI description should be a separate type
15:05:56 <mm_freak> merijn: pick one or two:  applicative, comonad, monoid
15:07:56 <edwardk> mm_freak: comonad + monoid. that sounds fun ;)
15:08:06 <edwardk> extract mempty = magic
15:08:41 * hackagebot bound 0.8.1 - Making de Bruijn Succ Less  http://hackage.haskell.org/package/bound-0.8.1 (EdwardKmett)
15:09:24 <dmwit> extract mempty = mempty -- probably
15:09:28 <mm_freak> edwardk: well, in all cases i can think of:  (Monoid a) => Monoid (X a)
15:09:34 <dmwit> right
15:09:38 <mm_freak> or sometimes even:  Monoid (X ())
15:09:52 <merijn> mm_freak: See, but then I get confused by my own code sample from just now: http://hpaste.org/90206
15:10:19 <merijn> mm_freak: Because how do I update the state of widgets t1/t2, they're just new everytime in there
15:10:24 <mm_freak> merijn: no worries…  that code confuses me, too =)
15:10:33 <merijn> I could replace () with i, but then how do I control where the input goes
15:10:40 <merijn> mm_freak: Which is ironic, as you wrote it :)
15:10:55 <mm_freak> really?
15:11:05 <merijn> mm_freak: Yes :p
15:11:40 <mm_freak> weird…  i would have used applicative style
15:11:48 <mm_freak> and likely more polymorphism there
15:12:22 <mm_freak> and yeah, you should try to explain your UI framework in terms of applicative, not arrow
15:12:27 <mm_freak> arrow is impossible to explain
15:13:06 <fizbin> I think arrow is possible to explain in terms of proc notation.
15:13:09 <merijn> Back to the drawing board
15:13:14 <fizbin> But attempting it without...
15:13:19 <mm_freak> fizbin: not explaining arrows, but explaining in terms of an arrow
15:13:41 * hackagebot compressed 3.0.2 - Compressed containers and reducers  http://hackage.haskell.org/package/compressed-3.0.2 (EdwardKmett)
15:13:43 * hackagebot compressed 3.0.3 - Compressed containers and reducers  http://hackage.haskell.org/package/compressed-3.0.3 (EdwardKmett)
15:13:44 <c_wraith> I'd just as soon never learn proc notation.  I've managed to get this far without it
15:14:06 <mm_freak> my opinion is that arrows are the monsters in abstract algebra…  huge and complicated
15:14:11 <c_wraith> wow, updates 2 seconds apart!
15:14:46 <c_wraith> (yes, yes, 3 minutes apart in reality, the bot only runs periodically)
15:15:54 <fizbin> mm_freak: Arrows are the raw stuff of category theory, and unlike Functors or Monads don't have much intrinsic structure of their own to hang understanding on.
15:16:04 <mm_freak> fizbin: what?
15:16:22 <mm_freak> all of them are just a bunch of laws
15:16:31 <mm_freak> but arrows are a bunch of more than 20 laws
15:16:31 <Saizan> the typeclass "Arrow" doesn't match what a categorist would mean by arrow, nor category
15:16:36 <Saizan> Category is closer
15:17:26 <merijn> mm_freak: See, the moment I start thinking of Widgets in terms of Applicatives/whatever I end up having UI and behaviour separate (yay!), but with no clue how to tie them together (boo!)
15:17:45 <fizbin> mm_freak: I've always found the arrow laws to feel like an ad-hoc collection, unlike Monad or Functor that had a clear conceptual basis.
15:18:02 <mm_freak> merijn: a widget would well be an Applicative+Comonad
15:18:26 <mm_freak> extract . pure = id
15:18:41 * hackagebot concurrent-supply 0.1.5 - A fast concurrent unique identifier supply with a pure API  http://hackage.haskell.org/package/concurrent-supply-0.1.5 (EdwardKmett)
15:19:01 <mm_freak> merijn: in that sense a widget is really just a UI element together with the value it represents
15:19:13 <merijn> Sure, that's easy
15:19:16 <fizbin> In that way, Arrows felt much like category theory the first dozen times I approached it where there's this whole pile of definitions for no given reason that are delivered in a seemingly adhoc fashion without much reason to it.
15:19:24 <mm_freak> if the pure UI (without the value part) is a monoid, then Widget is really not much different from (,)
15:19:47 <joelteon> yeah, like the right-tightening stuff
15:19:52 <joelteon> like what's up with that
15:21:09 <mm_freak> merijn: and (Monoid a) => (,) a is both Applicative and Comonad
15:21:20 <mm_freak> i hope this helps =)
15:21:30 <merijn> mm_freak: Yeah, but like I said, desiging a datatype is the easy part
15:21:39 <edwardk> plenty of things are both applicative and a comonad
15:21:44 <merijn> mm_freak: The part where I get stuck is connecting UI datatypes and behaviour together
15:22:06 <mm_freak> merijn: once you have a working widget type, you can focus on that
15:22:07 <merijn> mm_freak: Because a UI without behaviour or behaviour without a UI is kinda pointless
15:22:18 <mm_freak> you can have a UI without behavior
15:22:29 <merijn> Sure, it'd just be rather useless
15:22:34 <mm_freak> for now
15:23:41 * hackagebot parsers 0.8.1 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.8.1 (EdwardKmett)
15:23:43 * hackagebot profunctor-extras 3.3.1 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-3.3.1 (EdwardKmett)
15:30:48 <merijn> mm_freak: It'd just be a picture that doesn't change
15:31:08 <mm_freak> merijn: exactly
15:31:16 <mm_freak> there is nothing wrong with that
15:31:37 <mm_freak> behavior can be defined separately and independently
15:31:39 <merijn> mm_freak: Well, no, but I already know a billion ways to do that
15:31:52 <mm_freak> in fact behavior may not even need to know the internals of your widget type =)
15:32:12 <merijn> mm_freak: See, that's my point. You can't have behaviour be completely separate if you want a UI to actually do something
15:32:22 <merijn> They need to interact *somewhere*
15:32:35 <mm_freak> i'd go as far as to say that if your behaviors know the internals of your widget type, you're probably doing it wrong
15:33:07 <merijn> mm_freak: I'm not talking about behaviour knowing the internals, I have no idea how to make them interact at all
15:33:29 <mm_freak> start with static UIs
15:33:35 <mm_freak> don't worry about flexibility now
15:33:41 * hackagebot hyphenation 0.2.2 - Configurable Knuth-Liang hyphenation  http://hackage.haskell.org/package/hyphenation-0.2.2 (EdwardKmett)
15:33:52 <merijn> mm_freak: I don't mean dynamic UIs
15:33:57 <mm_freak> if you have trouble figuring that out, look into 'digestive-functors' and 'reform'
15:33:59 <akegalj> when trying compile with "-prof" flag ghc tells me "Could not find module `System.IO.Strict'. Perhaps you haven't installed the profiling libraries for package `strict-io-0.2.1'?"  How to resolve this?
15:34:02 <merijn> I mean "press a button, text field changes"
15:34:11 <merijn> (i.e. a character appears)
15:34:11 <mm_freak> yeah, that's fine
15:34:29 <merijn> No, I'm saying I'm clueless about how to achieve that
15:34:45 <merijn> Completely lost
15:34:50 <mm_freak> do you know how the two packages i just named work?
15:36:11 <merijn> I remember reading a paper on formlets, I should dig that out again
15:38:31 <mm_freak> merijn: yes =)
15:38:34 <mm_freak> that will help you a lot
15:38:44 <mm_freak> also look into digestive-functors/reform source code
15:48:42 * hackagebot hyphenation 0.3 - Configurable Knuth-Liang hyphenation  http://hackage.haskell.org/package/hyphenation-0.3 (EdwardKmett)
15:53:42 * hackagebot constraints 0.3.3 - Constraint manipulation  http://hackage.haskell.org/package/constraints-0.3.3 (EdwardKmett)
15:54:49 <ion> @remember shachaf edwardk isn't benevolent or malevolent. edwardk is more of a simple mechanical process tending toward maximal complexity.
15:54:49 <lambdabot> It is forever etched in my memory.
15:58:42 * hackagebot keys 3.0.3 - Keyed functors and containers  http://hackage.haskell.org/package/keys-3.0.3 (EdwardKmett)
16:01:15 <xplat> Saizan: if i used two kinds of 'lift', there could presumably be data dependencies that went cleanup -> setup, which can't be allowed
16:02:14 <Saizan> true, but when would you need data deps cleanup -> cleanup?
16:13:00 <flebron> Hi, I'm profiling some code and am not sure what two columns mean in the .prof output. I have a function f which calls a function li. Under "individual", f takes "%time = 80.0, %alloc = 1.6", while li takes "%time = 20.0, %alloc = 97.0". What should I interpret by this?
16:14:27 <flebron> Does this mean that li takes only 20% of the execution time to compute, while the rest of f (f just computes li and prints it, so this would be IO cost) takes 80% of the execution time?
16:18:42 * hackagebot speculation 1.5 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-1.5 (EdwardKmett)
16:23:42 * hackagebot numeric-extras 0.0.3 - Useful tools from the C standard library  http://hackage.haskell.org/package/numeric-extras-0.0.3 (EdwardKmett)
16:25:47 <elliott> > ()
16:25:48 <elliott> @quit
16:25:48 <elliott> sigh.
16:25:56 <elliott> oh.
16:25:57 <elliott> maybe that was lag.
16:26:42 <elliott> > ()
16:26:49 <lambdabot>   ()
16:28:14 <elliott> note to self: check my IRC connection is working before concluding lambdabot is dead.
16:28:30 <sdkmvx> 3
16:28:42 * hackagebot streams 3.1.1 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-3.1.1 (EdwardKmett)
16:33:42 * hackagebot log-domain 0.7.1 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.7.1 (EdwardKmett)
16:33:44 * hackagebot exceptions 0.1.1 - Extensible optionally-pure exceptions  http://hackage.haskell.org/package/exceptions-0.1.1 (EdwardKmett)
16:35:34 <greghaskell> hi can anyone help me improve my program, i just want a more idiomatic way to do it
16:35:35 <h4199> Is EdwardK a human library generator?
16:35:49 <elliott> no. he's not human
16:35:55 <h4199> @justask
16:35:55 <lambdabot> Unknown command, try @list
16:36:00 <h4199> @ask
16:36:01 <lambdabot> Who should I ask?
16:36:03 <elliott> ?
16:36:11 <h4199> greg: shoot
16:36:18 <elliott> uh...
16:36:48 <h4199> I was trying for the lambdabot blurb that tells people to ask their question
16:36:55 <elliott> ah
16:36:56 <h4199> but I must have forgotten the command
16:36:58 <elliott> @where justask
16:36:58 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
16:37:03 <h4199> ah
16:37:09 <hpaste> greg pasted “tictactoenextmove” at http://hpaste.org/90207
16:37:46 <elliott> that code doesn't look horrible. though (xs ++ [x]) is a bad sign
16:38:01 <greghaskell> yup i dont like the xs ++
16:38:08 <greghaskell> i think there a better way using reverse
16:38:21 <elliott> kind of tricky since you use it multiple times in your output though
16:38:27 <greghaskell> and i was also thinking theres probably a smarter way using the nondeterministic list monad
16:41:33 <greghaskell> still working my way through why functional programming matters ..... nearing the end
16:41:51 <greghaskell> i can hear all the cogs spinning in the haskell heads
16:43:43 * hackagebot shelly 1.0.0.0 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.0.0.0 (GregWeber)
16:48:44 * hackagebot comonad-transformers 3.0.3 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-3.0.3 (EdwardKmett)
16:48:46 * hackagebot comonads-fd 3.0.2 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-3.0.2 (EdwardKmett)
16:53:44 * hackagebot hashable-extras 0.1.1 - Higher-rank Hashable  http://hackage.haskell.org/package/hashable-extras-0.1.1 (EdwardKmett)
16:53:46 * hackagebot stable-maps 0.0.4 - Heterogeneous maps keyed by StableNames  http://hackage.haskell.org/package/stable-maps-0.0.4 (EdwardKmett)
16:55:47 <dmwit> > zip (inits [1..5]) (tails [1..5])
16:55:48 <lambdabot>   [([],[1,2,3,4,5]),([1],[2,3,4,5]),([1,2],[3,4,5]),([1,2,3],[4,5]),([1,2,3,4...
16:56:22 <elliott> cute
16:56:25 <elliott> splits?
16:56:32 <elliott> is that implementation efficient?
16:57:23 <hpaste> DanBurton pasted “Comonad in the category of monads... for free?” at http://hpaste.org/90208
16:58:44 * hackagebot compensated 0.4.1 - Compensated floating-point arithmetic  http://hackage.haskell.org/package/compensated-0.4.1 (EdwardKmett)
17:00:21 <hpaste> dmwit annotated “tictactoenextmove” with “tictactoenextmove (annotation)” at http://hpaste.org/90207#a90209
17:00:23 <DanBurton> Thoughts on my hpaste regarding comonads? ^
17:01:03 <DanBurton> it feels wrong that extend f m = lift (f m)... there's gotta be something wrong with that
17:01:26 <dmwit> Oh, bummer, greghaskell is gone.
17:01:28 <dmwit> Oh well.
17:01:38 <dmwit> elliott: It's not particularly efficient, no.
17:01:49 <dmwit> elliott: But the splits in my paste is much better. =)
17:02:02 <socratesxd> hi guys
17:02:06 <dmwit> (You just pay later, at the reverse.)
17:02:17 <socratesxd> i have a simple function that doesn't work properly
17:02:36 <dmwit> If I were worried about efficiency, I think I would just make Board be a zipper to begin with and stop worrying about reversing and all that.
17:02:44 <dmwit> ?hpaste your code, socratesxd
17:02:44 <lambdabot> Haskell pastebin: http://hpaste.org/
17:02:59 <dmwit> bonus points for including the error you get, or an input/output/expected output triple.
17:03:04 <xplat> fizbin: arrows are just strong monads in the category of profunctors, what's the problem?
17:03:09 <DanBurton> socratesxd: and if it is homework, let us know, so we don't spoil it for you
17:03:21 <socratesxd> it's not
17:03:22 <socratesxd> xD
17:03:30 <DanBurton> k just checking
17:03:42 <DanBurton> I guess school season is out, but there is that idris class going on right? must be a summer course
17:03:44 * hackagebot kan-extensions 3.1.2 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-3.1.2 (EdwardKmett)
17:04:14 <socratesxd> DanBurton, i'd wish it were homework
17:05:04 <elliott> dmwit: your splits fails to inspire me with beauty. :(
17:05:15 <elliott> @src inits
17:05:15 <lambdabot> inits []     =  [[]]
17:05:15 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
17:05:16 <elliott> @src tails
17:05:17 <lambdabot> tails []         = [[]]
17:05:17 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
17:05:24 <elliott> I bet there's a great way to write splits
17:06:17 <elliott> hmm. inits = foldr (\x r -> [] : map (x:) r) [[]]
17:06:25 <xplat> Saizan: you'd need data deps cleanup -> cleanup anytime you had a 2-step cleanup process, technically.  also, it's not like you can prevent those either!  well, i guess if the lift for cleanup also forces everything into m () ...
17:06:26 <elliott> tails is less obvious, I guess.
17:06:52 <DanBurton> @pl foldr (\x r -> [] : map (x:) r) [[]]
17:06:53 <lambdabot> foldr ((([] :) .) . map . (:)) [[]]
17:06:54 <Saizan> xplat: that's with profunctors as morphisms or as objects?
17:06:56 <xplat> Saizan: but at that point there's so much inflexibility and overhead you might as well just use bracket raw anyway
17:08:16 <hpaste> “Anonymous Coward” pasted “Palindrome” at http://hpaste.org/90210
17:08:18 <DanBurton> foldr seems less elegant to me now than it used to seem. :/ I heart pattern matching and explicit recursion sometimes.
17:08:34 <flebron> Suppose I have an [Integer] numerators, and an [Integer] denominators, both of length k. I want to compute the reduced (i.e. coprime pieces) form of \sum_{i = 0}^k (numerator_i / denominator_i). Is there a better way of doing this than sum . zipWith (%)?
17:08:53 <socratesxd> http://hpaste.org/90210
17:08:53 <xplat> Saizan: with categories as objects and profunctors as morphisms and profunctor transformations as 2-morphisms
17:09:06 <socratesxd> look... isPalindrome always return False
17:09:13 * tabemann is used to commonly explicitly using tail recursion with accumulator parameters rather than using foldr, at least when he's coded in OCaml
17:09:46 <flebron> socratesxd: You may mean "x == reverse x".
17:09:49 <xplat> Saizan: (remember i said monad, not monoid)
17:10:00 <elliott> DanBurton: I was trying to get them into common form so I could manipulate them into something nicely zippy.
17:10:02 <socratesxd> flebron, ?
17:10:13 <monochrom> tabemann: have you seen my http://www.vex.net/~trebla/haskell/lazy.xhtml to see why foldl is still inadequate? (not that foldr is any better)
17:10:17 <dmwit> socratesxd: In what situation would you expect x to be equal to x ++ y for some y?
17:10:19 <socratesxd> flebron, in line 6?
17:10:22 <flebron> socratesxd: That's what "is a palindrome" means. x == reverse x.
17:10:25 <DanBurton> socratesxd: your 'palindrome' function is weird. try giving it some inputs and see what it does
17:10:31 <flebron> I mean as your entire "isPalindrome".
17:10:44 <xplat> Saizan: mostly because 'strong' doesn't have as nice of an equivalent in the monoid world that i now of
17:10:47 <xplat> *know of
17:10:47 <tabemann> monochrom: no, I haven't read that
17:10:48 <socratesxd> DanBurton, palindrome makes a palindrome from a list
17:10:52 * dmwit decides he is the extra cook
17:10:52 <socratesxd> for example
17:10:56 <DanBurton> > let palindrome [] = []; palindrome x = x ++ tail (reverse x) in (palindrome "foo", palindrome "bar")
17:10:57 <lambdabot>   ("fooof","barab")
17:10:58 <socratesxd> palindrome [1, 2, 3]
17:11:07 <socratesxd> returns [1, 2, 3, 2, 1]
17:11:08 <DanBurton> ah I get it
17:11:21 <Saizan> xplat: oh, i was more confused because i was looking for a endofunctor over that, but i should be considering a 1-cell
17:11:25 <dmwit> DanBurton: Perhaps more to the point, try applying palindrome to something that is already a palindrome.
17:11:57 <xplat> Saizan: ah, right
17:11:58 <DanBurton> but it will never be true that `x == palindrome x`, unless x = [] or x = [c]
17:12:19 <socratesxd> DanBurton, but it is
17:12:31 <xplat> "madam, i'm adamada m'i ,madam"
17:12:33 <socratesxd> isPalindrome :: [a] -> Bool
17:12:37 <dmwit> > let mirror x = x ++ drop 1 (reverse x) in (mirror "palindromemordnilap")
17:12:38 <lambdabot>   "palindromemordnilapalindromemordnilap"
17:12:53 <dmwit> > "palindromemordnilap" == "palindromemordnilapalindromemordnilap"
17:12:54 <lambdabot>   False
17:13:25 <dmwit> socratesxd: Perhaps these two commands together will help you reach enlightenment.
17:13:29 <tabemann> monochrom: I kind of understood that foldl in Haskell doesn't work in constant space, but I'm so used to foldl in, say, OCaml operating in constant space that I have to remind myself to use foldl', and that that doesn't always help with data structures being passed around
17:13:29 <dmwit> ...then again, perhaps not.
17:13:45 * hackagebot adjunctions 3.2.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-3.2.1 (EdwardKmett)
17:13:49 <monochrom> foldl' is the one when you want the accumulator approach
17:14:08 <xplat> or simply 'po' -> "pop" -> "popop" -> "popopopop" -> ...
17:14:09 <socratesxd> dmwit, i don't get it
17:14:20 <socratesxd> isPalindrome [1, 2, 3, 2, 1] should return True
17:14:23 <monochrom> define your data structure to be deeply strict, too. data Whee = W !Int !Double !Bool
17:14:34 <tabemann> monochrom: yeah
17:14:43 <xplat> dmwit: that only works when socrates is the one *asking* the questions
17:14:50 <DanBurton> @check let palindrome [] = []; palindrome x = x ++ tail (reverse x) in \xs -> let len = length xs in (len >= 2) ==> length (palindrome xs) > len
17:14:53 <lambdabot>   +++ OK, passed 100 tests.
17:14:59 <monochrom> or write your own left-fold that calls rnf
17:15:48 <tabemann> monochrom: just read the part about "goodsum / length", and I think I've read elsewhere about how that form is a major source of space leaks
17:15:48 <monochrom> you know the upside of lazy evaluation? "map f xs" sucks in ocaml, doesn't suck in lazy haskell
17:15:49 <roboguy_> > let palindrome x = x ++ tail (reverse x) in palindrome [1,2,3,2,1]
17:15:49 <lambdabot>   [1,2,3,2,1,2,3,2,1]
17:16:26 <roboguy_> > let palindrome x = x ++ tail (reverse x) in [1,2,3,2,1] == palindrome [1,2,3,2,1]
17:16:28 <lambdabot>   False
17:16:31 <tabemann> monochrom: OCaml specifically provides a tail recursive rev_map that operates in constant space, with the expense that it reverses your list for you too
17:16:44 <roboguy_> socratesxd: yeah, that function should never return True
17:16:51 <dmwit> socratesxd: Okay, let's trace isPalindrome [1,2,3,2,1] by hand.
17:16:53 <socratesxd> > let palindrome x = x ++ tail (reverse x) in palindrome [1, 2, 3]
17:16:54 <lambdabot>   [1,2,3,2,1]
17:17:05 <dmwit> socratesxd: Does that sound like a good plan to you?
17:17:17 <tabemann> so if you want a tail-recursive, constant space map you really need to do rev (rev_map f xs) in OCaml
17:17:19 <socratesxd> > let palindrome x = x ++ tail (reverse x) in [1, 2, 3] == palindrome [1, 2, 3]
17:17:20 <lambdabot>   False
17:17:20 <xplat> > let startingwithx s = 'x':s; startswithx s = s == startingwithx s in startswiths "xyzzy"
17:17:21 <lambdabot>   Not in scope: `startswiths'
17:17:22 <lambdabot>  Perhaps you meant one of these:
17:17:22 <lambdabot>    `startswith...
17:17:34 <xplat> > let startingwithx s = 'x':s; startswithx s = s == startingwithx s in startswithx "xyzzy"
17:17:36 <lambdabot>   False
17:17:54 <Sonarpulse> anybody have any idea why https://github.com/Ericson2314/henet/tree/manual won't compile?
17:18:05 <socratesxd> > let palindrome x = x ++ tail (reverse x) in [1, 2, 3, 2, 1] == palindrome [1, 2, 3]
17:18:06 <lambdabot>   True
17:18:16 <socratesxd> that's what i want to evaluate
17:18:22 <dmwit> Ah!
17:18:25 <dmwit> But is that what you evaluate?
17:18:35 <socratesxd> yes
17:18:40 <dmwit> Surprise!
17:18:41 <socratesxd> isPalindrome does that
17:18:45 <socratesxd> or it should
17:18:45 <dmwit> It doesn't.
17:18:49 <roboguy_> socratesxd: how do you get the left hand side of the equal sign?
17:18:51 <dmwit> It asks for "x == palindrome x".
17:19:07 <dmwit> But you wrote something like "x == palindrome y" -- that is, you didn't pass the same thing on both sides of the ==!
17:19:10 <xplat> socratesxd: where does isPalindrome figure out that [1,2,3] to give to palindrome?
17:19:10 <dmwit> Do you see?
17:19:20 * tabemann is going to have to get used to writing code that doesn't make space leaks in Haskell, and get over his instinct to make everything obsessively tail-recursive that he learned from OCaml
17:19:24 <xplat> socratesxd: (hint: it doesn't)
17:19:37 <dolio> tabemann: That space leak is kind of a silly example, though, because the leak is that it doesn't use asymptotically less memory than OCaml (etc.) would.
17:19:39 <roboguy_> *right hand side
17:19:41 <socratesxd> oh wait
17:19:47 <socratesxd> i've got it :p
17:19:53 <socratesxd> well, thanks
17:19:55 <dmwit> \o/
17:20:16 <socratesxd> i didn't see it
17:20:53 <xplat> tabemann: once you get over it you'll find it rather freeing
17:22:39 <dolio> There are better examples where laziness will actually use more memory than eagerness.
17:22:46 <dolio> Although they aren't that hard to deal with.
17:23:05 <johnw> tabemann: I don't think I've ever once even considered tail recursion while coding in Haskell
17:23:24 <tabemann> random question - is it a good idea to make your data structures strict whenever you don't *need* to support laziness?
17:23:30 <johnw> tabemann: yes
17:23:39 <shachaf> johnw: Really? You probably should.
17:23:40 <monochrom> at least tibbe says that
17:23:45 * hackagebot linear 1.1.4 - Linear Algebra  http://hackage.haskell.org/package/linear-1.1.4 (EdwardKmett)
17:23:59 <johnw> shachaf: Really?  I've read in a few places (such as tibbe) that you should annotate for strictness by default.  Maybe my sources are wrong then.
17:24:08 <tabemann> e.g. I've been working on a red-black tree impl., and I made all of the tree except for the map values strict
17:24:19 <shachaf> johnw: I was talking about tail recursion.
17:24:20 <dolio> I don't think even tibbe really says that verbatim.
17:24:29 <johnw> tabemann: if you make the data type strict, you are imposing a design choice on your users as well then.
17:24:38 <shachaf> But the strictness thing is, well, just more complicated.
17:24:46 <johnw> shachaf: ah.  Can you give me an example of when I should be thinking about tail recursion?
17:24:47 <jmcarthur_mobile> It depends on what kind of semantics you are after.
17:24:55 <dolio> He says you should put bangs on all your Ints and such, I think.
17:25:27 <tabemann> I did the strictness so that unevaluated thunks would not hide out in parts of the tree, where they may never be evaluated in some use cases
17:25:41 <shachaf> It depends on what you mean, I suppose.
17:25:43 <jmcarthur_mobile> It is worth thinking about a little even if you don't think you care.
17:25:54 <jmcarthur_mobile> I do think it is unusual for me to have a strict, concrete type in a lazy field.
17:26:59 <tabemann> johnw: I tried to minimize the impact on the user by making "value" fields lazy, so lazy values could be put in a tree even though the tree's structure would be strict
17:27:04 <monochrom> exact wording: "By default, use strict data types and lazy functions." "Constructor fields should be strict, unless there's an explicit reason to make them lazy." https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
17:27:07 <dolio> I seem to recall they did a version of Data.Map with bangs on the spine structure, and it got slower.
17:27:25 <dolio> Despite the fact that Data.Map is always spine strict.
17:27:44 <elliott> it sort of makes sense to me
17:27:59 <elliott> a lot of the time a strict field is just going to add extra work at construction time and not do much else
17:28:17 <monochrom> I always have an explicit reason to prefer non-strict :)
17:29:26 <johnw> shachaf: It looks like tail recursion matters when your function is not going to return a value until the full recursive computation is finished, so if it's not tail recursive it may consume excessive stack?
17:29:37 <monochrom> in fact, some time ago, in this channel, someone seriously asked tibbe "would you recommend data X = X !String?" and he seriously said "yes"
17:29:54 <dolio> Need to evaluate that outermost cons, man.
17:29:58 <johnw> isn't !String only string in the first const?
17:30:03 <tabemann> wouldn't that not really do much except evaluate the first character?
17:30:08 <johnw> s/string/strict, s/const/cons
17:30:17 <tabemann> or not even the first character but, yeah, the first cons
17:30:24 <monochrom> yes, and he knows that, and he still recommends it
17:30:50 <johnw> well, it will evaluate any String-producing thunk, at least
17:30:54 <johnw> just not the rest of the string
17:30:57 <monochrom> I would imagine his reason would be "reduces the number of brain cycles the programmer has to spend thinking about evaluation order"
17:31:10 <shachaf> johnw: For instance.
17:31:16 <dolio> Not doing any of this also has that effect.
17:31:18 <johnw> shachaf: ok, that makes a lot of sense, thanks for pointing that out.
17:31:27 <shachaf> johnw: For example sum :: [Int] -> Int
17:31:41 <jmcarthur_mobile> I think trying not to think about strictness is the problem.
17:31:48 * johnw upgrades himself to pay attention to tail recursion when/where it matters
17:31:55 <shachaf> johnw: It helps in the same ways it helps with a strict language. It's just that with non-strictness you have more options.
17:32:08 <elliott> monochrom: that single-field thing muddies it :)
17:32:11 <elliott> monochrom: I thought you meant as opposed to newtype
17:32:23 <jmcarthur_mobile> Better is to learn to use it effectively instead of just having a default to apply or misapply.
17:32:23 <monochrom> well yeah, my ideal is "you should read my http://www.vex.net/~haskell/lazy.xhtml and make a conscious informed decision yourself"
17:32:44 <johnw> monochrom: that link doesn't work
17:32:44 <monochrom> yeah yeah pretend it has more fields or other cases etc etc
17:33:00 <monochrom> oh oops, http://www.vex.net/~trebla/haskell/lazy.xhtml
17:33:11 <johnw> ah, yes, excellent articles, I recommend it to all my friends
17:33:16 <monochrom> but you should have already memorized it last year!
17:33:44 <elliott> lambdabot has some !Strings.
17:33:57 <johnw> ¡String!
17:34:07 <dolio> Anyhow, I'm very hesitant to recommend that everyone put bangs everywhere.
17:34:20 <johnw> dolio: fair enough
17:34:21 <dolio> Because I've used languages that are strict by default with optional laziness.
17:34:28 <elliott> I think there is a certain backlash against laziness.
17:34:40 <dolio> And my experience there is that no one puts in the laziness where it should be.
17:35:01 <dolio> So I don't want to make that the recommended default in Haskell.
17:35:10 <monochrom> oh, but this may make a difference: "By default, use [...] lazy functions"
17:35:12 * tabemann gets the feeling that laziness means more potential failure modes... whereas in strict languages you only have to worry about blowing out your stack, and there is an obvious solution (tail recursion)
17:35:39 <monochrom> the whole sentence is "By default, use strict data types and lazy functions.". it has two parts. they may balance out.
17:35:42 <johnw> tabemann: strict languages also favor fusing algorithms
17:36:03 <johnw> the ability to very easily decouple parts of an algorithm due to laziness is one of its most redeeming qualities in my opinion
17:36:34 <dolio> Yeah, but what is the exception to strict data types? Should you use spine strict lists?
17:36:43 <dolio> Or is that a case where you have a better reason?
17:36:43 <hpc> and to be the pedant, strict evaluation has more trouble with bottoms than lazy evaluation
17:36:46 <monochrom> I think so far (including last time) we have only looked at the !String part and not thought how it combines with lazy functions
17:37:00 <tabemann> spine strict lists IIRC are a good idea when you are trying to avoid *computation* leaks in passing them between threads
17:37:33 <monochrom> anyway
17:37:55 <dolio> I'm of the opinion that you even want inductive (non-infinite) lists to be lazily evaluated, if possible (it's not in many languages).
17:38:16 <tabemann> spine strict lists of course are a bad idea if you are consuming the list as you create it, because then you'll create the *entire* list before you consume it
17:38:38 <monochrom> I, of course, prefer the world to have no "default", no "rule of thumb", no "style guide", no herd psychology, everyone is an independent thinker. but I guess the world doesn't want it.
17:39:57 <johnw> monochrom: you mean, one size does not fit all, basically
17:40:44 <shachaf> monochrom is not a fan of antícheirocracy
17:41:37 <Saizan> at some point you need to make choices without consciously going over all the details, that point should better come from knowing them though
17:42:58 <johnw> I wonder why so many writers on the Internet seem to favor the "strictness by default" mantra
17:43:10 <johnw> is it because they just haven't thought about laziness enough to be comfortable?
17:43:27 <johnw> "Give me back as much of my imperative paradigm as I can get!"
17:43:30 <nexx> no defaults seems tedious
17:44:15 <tabemann> I suspect it's probably due to Haskell's reputation for space leaks, and trying to preemptively avoid them by just making everything strict when laziness is not clearly needed
17:45:07 <johnw> tabemann: but in my experience you have to "pay the piper" no matter what; dropping laziness because of space leaks isn't about saving effort, it just moves that effort into other places
17:45:33 <amosr> when we're trying to get good performance, we rely on the strictness analysis a lot. it inevitably doesn't work at some point, and you end up having to add bang patterns to everything
17:45:36 <nexx> I think many like to much thinking about what the machine does
17:45:49 <johnw> granted, the author may be more comfortable with it being in those places, but I prefer the occasional space leak hunt to the recurring pains brought on by over-strictness
17:45:52 <amosr> (where "good performance" means as fast as C)
17:46:04 <johnw> nexx: agreed!
17:46:08 <carter> laziness is good glue
17:46:28 <carter> but inside the bits should be strict :)
17:47:12 <tabemann> what I would like to see is a general guide on how to code from the start without space leaks, without recommending putting bags and `seq`s everywhere to haphazardly try to stomp them out
17:47:20 <tabemann> *bangs
17:47:34 <johnw> Laziness is being asked to do the dishes, and then only cleaning one dish at a time when they're actually needed.  Doesn't always go over well.
17:47:50 <nexx> :D
17:48:20 <monochrom> did you know: there is a package on hackage for genetic bang programming!
17:48:33 * tabemann just doesn't like the idea of space leaks, being used to trying to avoid allocation whenever possible
17:48:44 <tabemann> monochrom: hah
17:48:51 <monochrom> it tries all combinations of bang-vs-nobang and measures time and finds the fastest one
17:49:06 <hpc> that's hilarious
17:49:15 <nexx> "all" doesn't sound very genetic
17:49:16 <tabemann> I wonder what that does to your code's readability
17:49:34 <johnw> tabemann: I think the only true answer to that question is just experience; the more time goes by, the more you gain intuition for GHC's operational model
17:50:15 <tabemann> the main recommendation for avoiding space leaks that I've heard so far is to avoid outstanding references to data structures that are supposed to be consumed as they're used
17:50:41 <tabemann> i.e. the sum / length example
17:50:54 <dwcook> What is a must-have feature in a parser library?
17:51:02 <johnw> having to read your code deeply to understand why a space leak is occurring is like an enforced code review; it forces you to understand your code better at the same time you are correcting its strictness semantics
17:51:05 <dwcook> I'm trying to see if I've missed any important ones
17:51:09 <dwcook> (https://github.com/dwcook/Combigreater)
17:51:24 <johnw> dwcook: that it parse input strings :)
17:51:34 <dwcook> Got you covered :D
17:51:44 <johnw> another is decent error reporting, for me
17:51:54 <johnw> I hate it when a parser says "Syntax error", and nothing else
17:51:55 <monochrom> must-have in a parser lib: sequencing two parsers, choosing from two parsers
17:51:57 <dwcook> I'm definitely getting there
17:52:05 <dwcook> Woops
17:52:07 <dwcook> I'm in the wrong channel
17:52:08 <johnw> dwcook: trifecta is my current farovite
17:52:11 <dwcook> Sorry D:
17:52:22 <dwcook> I keep accidentally tabbing over from ##javascript
17:52:23 <johnw> dwcook: what channel did you think this was?
17:52:50 <monochrom> wait, you want to talk about parser libs with javascript people? :)
17:52:57 <dwcook> I actually didn't check, and I think I need to start being more certain what channel I'm in before I ask :P
17:52:59 <nexx> dwcook I was thinking I was in #haskell when you wrote about the parsers in #inimino :D
17:53:09 <dwcook> monochrom, yes, actually
17:53:16 <tabemann> somehow I imagine Haskell people would probably be better people to talk to about parsers than Javascript people
17:53:24 <dwcook> Though, you guys did answer my questions pretty well, so thanks
17:53:25 <tabemann> even if one's parser is in Javascript
17:53:27 <monochrom> I imagine they will suggest "include regex"... :)
17:53:38 <tabemann> regex considered harmful
17:53:55 <dwcook> I'm actually proposing that thing as an alternative in some cases to regex, though its powers are different
17:54:05 <dwcook> It's closer to Parsec than JS RegExp
17:54:10 <dwcook> but it's not as good as Parsec
17:54:12 <dwcook> for one thing it's in JS :P
17:54:37 <dwcook> I'm learning how much more awkward JS is for parsers than Haskell
17:54:54 <monochrom> anyway, I imagine that other communities think first of what actual parsers you need, while I think first of what compositions you need
17:55:18 <dwcook> That's my main problem with JS REs – that they aren't composable
17:55:21 <nexx> dwcook much more awkward than JS is in generell?
17:55:24 <dwcook> You have to do string mincing just to do anything with them
17:55:53 <dwcook> anything fun with them at least
17:56:11 <dwcook> nexx, as far as the JS codebase as a whole, what I wrote is probably less awkward than average. :P
17:56:23 <dwcook> s/codebase/ecosystem/
17:56:31 <nexx> :)
17:57:03 <dwcook> Anyway sorry for the accidental off-topicness and thanks for the responses
17:57:28 <dwcook> Though I guess parsers in general aren't necessarily off-topic
17:57:36 <johnw> asking about parsers is almost always on-topic; if they are Haskell parsers :)
17:57:41 <dwcook> Haha, yep
18:00:06 <Sonarpulse> how do you get the honor of ##<chan-name> on freenode, I think  #haskell deserves it
18:00:26 <johnw> why is that an honor?
18:00:48 <tabemann> that's not an honor
18:00:49 <tabemann> ## means "not an official channel"
18:00:49 <monochrom> I think single # is the honour
18:00:54 <Sonarpulse> what what?
18:01:01 <monochrom> or at least needs to go through a process to earn
18:01:09 <tabemann> like ##OpenGL has ## because it isn't run by the Khronos Group
18:01:14 <Sonarpulse> all i know is the most popular languages have ##
18:01:27 <Sonarpulse> in their associated chanels
18:01:27 <tabemann> because they are not run by the people behind those languages
18:01:29 <monochrom> consider #math and ##math
18:01:45 <dwcook> JavaScript is owned by Oracle, so if Oracle started a Freenode JavaScript channel, they'd get #javascript
18:01:50 <Sonarpulse> oh..........
18:01:53 <monochrom> anyway, you do have the honour of creating ##haskell yourself :)
18:02:31 * tabemann for some reason sees the whole # versus ## business as rather officious of Freenode...
18:02:39 <Sonarpulse> well when you create a channel (or in join  a misspeelled chanell), you get on #
18:02:43 <Cale> Though really, I think the main guy who actually cared about the application of that rule was lilo, and he is no longer alive, so...
18:02:44 <dwcook> Though, I think many of the "official" channel names are used as forwarding channels to the unofficial ones
18:02:45 <Sonarpulse> so is it self-regulating?
18:03:00 <Sonarpulse> dwcook, that is true
18:03:04 <Cale> I have no idea whether anyone enforces it anymore
18:03:24 <dwcook> I just joined #cocacola and no one stopped me
18:03:24 <johnw> Sonarpulse: I created ##icfp, where I get to enjoy the silence with fryguybob
18:03:29 <dwcook> Maybe it's part of the registration process :P
18:03:51 <Cale> It's kind of silly to have ##math, given that there is no *official* version of mathematics.
18:04:03 <tabemann> creating # channels yourself is probably because the policy is not enforced by the ircd itself
18:04:07 <Cale> (No matter how much certain publishing companies would like people to think that)
18:04:15 <Sonarpulse> ok
18:04:18 <monochrom> #math is reserved for until Dijkstra's Mathematics Inc. to show up :)
18:04:24 <Sonarpulse> well, learn new things everyday
18:04:24 <Sonarpulse> haha
18:04:40 <johnw> clearly we should give #math to Wolfram
18:04:46 <Cale> lol
18:04:54 <tabemann> lolol
18:05:05 <Cale> I wouldn't put it past him
18:05:07 <dwcook> On the topic of parsers again, some things I really take for granted in Haskell are lazy evaluation and recursive bindings
18:05:16 <monochrom> and then, there is still #maths...
18:05:16 <dwcook> They make recursive parsers so much easier
18:05:51 <dwcook> In a strict language I think you'd have to create a combinator just to deal with those
18:05:56 <johnw> dwcook: did you just miss our big lazy vs. strict discussion?
18:06:03 <dwcook> I suppose I did.
18:06:05 <monochrom> hee hee hee
18:06:39 <monochrom> yeah "whee = char 'x' >> whee" doesn't bode well elsewhere
18:07:11 <monochrom> so, elsewhere, they encoding it as "whee () = char 'x' >>> whee ()"
18:07:17 <Cale> Probably everyone who actually cares about this already knows about it, but the homotopy type theory book is finished, and there's an interesting little note about their open source process while writing it here: http://audrey.fmf.uni-lj.si/hott.html
18:07:28 <Sonarpulse> I skimmed the article
18:07:33 <monochrom> err, probably not even that
18:07:40 <dwcook> monochrom, even that would… yeah
18:07:54 <Sonarpulse> || was a good way to show benefit of foldr when either will work
18:08:16 <dolio> Luckily I have the official constructive-math channel.
18:08:23 <dwcook> The way I encoded it strictly was to use a "lazy" combinator that accepts a function returning a parser, and runs that function every time it gets input
18:08:40 <Sonarpulse> it is possible to have constant space with fold? || ....
18:08:42 <Sonarpulse> and early exit
18:08:50 <dwcook> Sonarpulse, foldr'
18:08:54 <dwcook> foldl' *
18:09:03 <Sonarpulse> foldl' gives you early exit there?
18:09:07 <dwcook> Not early exit
18:09:17 <dwcook> Wait yeah
18:09:27 <dwcook> Actually I'm confused
18:09:34 <dwcook> It gives you constant space though
18:09:56 <Sonarpulse> fold<something> || [F, F, F, T, T, T....]
18:10:32 <monochrom> guess what, for this specific case, foldr fits both requirements
18:10:47 <Sonarpulse> so foldr does give you the constant space?
18:11:01 <dwcook> Doesn't that depend on whether you use data constructors with it?
18:11:02 <monochrom> it depends on the operator. || is a good operator
18:11:12 <monochrom> and yes that too
18:11:39 <monochrom> > foldr1 (||) (False : repeat True)
18:11:40 <lambdabot>   True
18:11:40 <dwcook> Oh, I was confused because my brain failed to parse the ||. Sonarpulse, I'm supposing you meant (||)?
18:12:20 <Sonarpulse> well, I meant Logical Or
18:12:47 <dwcook> Right, but when you use an operator as a plain value (without calling it), you surround it in parens
18:12:54 <Sonarpulse> yeah
18:13:12 <monochrom> in fact, see my http://www.vex.net/~trebla/haskell/lazy.xhtml , search for "foldr (||)", I have exactly this example
18:13:14 <dwcook> foldr || [whatever] actually does parse, but it doesn't type check
18:13:35 <mm_freak> Sonarpulse: foldl and foldr can give you early exit
18:13:36 <Sonarpulse> ah you wrote that>
18:13:38 <mm_freak> foldl' can't
18:13:55 <monochrom> > foldl1 (||) (repeat True)
18:13:56 <dwcook> In short, laziness lets you bail early
18:14:02 <lambdabot>   mueval-core: Time limit exceeded
18:14:07 <dwcook> foldl' is strict, not lazy
18:14:11 <Sonarpulse> s_>_?_
18:14:16 <mm_freak> > foldr (||) True (repeat False)
18:14:20 <lambdabot>   mueval-core: Time limit exceeded
18:14:26 <tabemann> hmmm
18:14:35 <mm_freak> > foldr (||) True (replicate 10000 False ++ [True])
18:14:36 <lambdabot>   True
18:14:50 <mm_freak> > foldr (||) True (True : repeat False)
18:14:52 <lambdabot>   True
18:15:14 <Sonarpulse> that article is what I read
18:15:18 <monochrom> foldl doesn't exit early
18:15:45 <johnw> > foldr (||) True [undefined]
18:15:46 <lambdabot>   *Exception: Prelude.undefined
18:16:14 <monochrom> in "foldr (||) True blah", the "True" does not matter until end of list is reached
18:16:18 <latro`a_> || checks the first argument first
18:16:33 <latro`a_> that is, that winds up being "undefined || True"
18:16:33 <johnw> > foldr (flip (||)) True [undefined]
18:16:34 <lambdabot>   True
18:16:41 <mm_freak> oh, and btw, you want foldr (||) False
18:16:52 <mm_freak> False is the identity of (||)
18:16:56 <latro`a_> I think he was checking the laziness properties more than using it as an identity
18:17:16 <dwcook> > foldr (||) True [a, b, c]
18:17:17 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
18:17:17 <lambdabot>              with actual type...
18:17:26 <dwcook> Oh well
18:17:37 * dwcook hoped for too much :P
18:17:40 <monochrom> that's a || (b || (c || True)
18:17:46 <dwcook> Right
18:18:21 <latro`a_> more right parens
18:19:55 <mm_freak> > let mul 0 x = 0; mul x y = x*y in foldr mul 1 [0..]
18:19:56 <lambdabot>   0
18:21:55 <orzo> hello, can anyone tell me what the Control.Concurrent equivalent to posix pthread_join is?  pthread_join simply suspends the current thread until the argument thread completes, effectively joining the threads into one
18:22:06 <dwcook> mm_freak, would that that worked with (*) itself
18:22:08 <mm_freak> orzo: there is none, you have to write it
18:22:19 <mm_freak> dwcook: depends on the instance
18:22:27 <mm_freak> dwcook: for most predefined numeric types no
18:22:37 <mm_freak> > foldr (*) 1 [0..]
18:22:38 <lambdabot>   *Exception: stack overflow
18:22:45 <dwcook> Just to clarify, I was using an archaeism, not asking a question :)
18:22:57 <johnw> orzo: in the docs for Control.Concurrent, there is an example of how to implement a "waitForChildren" function
18:23:19 <mm_freak> dwcook: sorry, i don't even know what that is =)
18:23:25 * mm_freak is not a native english speaker
18:23:46 <orzo> i see it, looks like they use an mvar to accomplish it
18:23:47 <dwcook> The sentence structure I used is basically never used in modern English
18:23:59 <johnw> orzo: maybe "async" is more what you're looking for?
18:24:04 <dwcook> It's synonymous with "If only that worked with (*) itself"
18:24:16 <mm_freak> orzo: yes, a haskell thread dies silently…  if you want some signalling, you need to `finally` write to an MVar or something
18:24:21 <Sonarpulse> last I heard the dream was optomizations taking care of all lazy/strict issues for you?
18:24:26 <latro`a_> similar to "let" as in "let's go"
18:24:39 <Sonarpulse> some fancy profile-guided optomization thing maybe
18:25:17 <mm_freak> Sonarpulse: optimizations can't destrictify (*) for you
18:25:42 <orzo> well thanks mm_freak & johnw
18:25:47 <mm_freak> so foldr (*) 1 [0..] will always run into an infinite loop for Integer
18:26:48 <Sonarpulse> no, but realistically * always needs both arguments so little practical advantages
18:27:40 <mm_freak> i mean, even if GHC were smart enough to do it, it's not allowed to
18:28:00 <mm_freak> perhaps some day we will have -fvery-unsafe-strictness-optimizations-use-with-extreme-caution
18:28:18 <dwcook> > 0 * (0 / 0)
18:28:19 <lambdabot>   NaN
18:29:05 <hpc> mm_freak: i await the day another compiler has -fheinous-ghc-extensions
18:29:08 <dwcook> If either side is NaN, the whole thing is NaN. Thus, you must check both
18:29:20 <dwcook> Wait no
18:29:25 <dwcook> You must check until you get NaN
18:29:27 <dwcook> I think
18:29:39 <dwcook> But still
18:29:43 <dwcook> > (0 / 0) * undefined
18:29:44 <lambdabot>   *Exception: Prelude.undefined
18:30:16 <mm_freak> dwcook: note that NaN does not occur for Integer
18:30:22 <mm_freak> your usage of (/) implies Double
18:30:31 <dwcook> Fair point
18:30:53 <dwcook> So you can optimize some types but not others, I guess
18:30:56 <Sonarpulse> another thing would be able to somehow perameretize over strictness
18:31:09 <mm_freak> hpc: gcc -fstg -fnonstrict-by-default -XHaskellSyntax
18:31:25 <Sonarpulse> or whatever else motivates IntMap a over Map Int a
18:31:28 <mm_freak> Sonarpulse: what do you mean?
18:31:50 <Sonarpulse> well this goes along with a larger idea of mine
18:32:01 <Sonarpulse> sorta lispy
18:32:07 <Sonarpulse> that modules should take parameters
18:32:15 <mm_freak> dwcook: this isn't really an optimization…  note that the conditionally non-strict version of (*) may actually introduce a hard to track space leak
18:32:53 <mm_freak> in fact you may want to use foldl instead of foldl' for that one
18:32:58 <dwcook> mm_freak, what leak?
18:33:01 <dwcook> Example?
18:33:03 <Sonarpulse> so like as opposed to CPP
18:33:35 <mm_freak> dwcook: when we write z = x * y :: Integer, we assume that 'z' means 'x `seq` y `seq` z'
18:33:36 <Sonarpulse> module MadLowLevelBindings[bool isWindows](exports...) where ...
18:33:42 <Sonarpulse> then do
18:34:03 <Sonarpulse> module Data.Map[bool isStrictKeys](exports...) where ...
18:34:05 <dwcook> mm_freak, what's the upshot of that?
18:34:11 <Sonarpulse> anyways g2g
18:34:57 <mm_freak> dwcook: that you may get arbitrary space behavior for what would otherwise be O(1)
18:35:17 <dwcook> Ahh, okay
18:35:31 <dwcook> But why do we have to make that assumption?
18:35:32 <hpaste> cutsea110 pasted “getFileR” at http://hpaste.org/90211
18:35:43 <mm_freak> dwcook: we don't have to
18:35:45 <dwcook> Why couldn't we have a (*) that only evaluates one side?
18:35:46 <mm_freak> but we do
18:36:01 <dwcook> So, for the sake of consistency I guess?
18:36:10 <mm_freak> dwcook: well, also i don't see a reason to have it
18:36:29 <Fuuzetsu> :t splitAt
18:36:31 <lambdabot> Int -> [a] -> ([a], [a])
18:37:05 <mm_freak> Sonarpulse: yeah, parametric modules would be lovely, but i don't see that happening any time soon
18:38:38 <mhr_> I'm trying to install Yi, maybe one of you guys could help because I'm trying to install via cabal, which is apparently some sort of package manager for Haskell.  This is the error message: http://pastebin.com/raw.php?i=Jv8rEYWQ
18:38:45 <mauke> The paste Jv8rEYWQ has been copied to http://sprunge.us/bQHM?haskell
18:39:19 <Fuuzetsu> mhr_: You need to install curses on your system.
18:39:25 <Fuuzetsu> (also Cabal is not a package manager)
18:39:31 <mm_freak> mhr_: you need the dev version of curses/ncurses, if your distribution is binary
18:39:36 <byorgey> mhr_: looks like you need to install some sort of curses development package via your OS's package manager.
18:39:43 <mhr_> okay, thanks
18:39:51 <byorgey> @quote stereo
18:39:51 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
18:40:00 <byorgey> heh
18:40:15 <mm_freak> @quote mono
18:40:16 <lambdabot> roconnor says: I mean, I could, and do, say that a lens is just a monoid natural transformation from the coalgebra functiors from haskell functors to haskell types.
18:41:04 <Fuuzetsu> Hmm, is that right?
18:41:25 <mhr_> mm_freak: there aren't parametric modules in Haskell?  I thought that Haskell is an ML language, which I thought had parametric modules?  Why didn't Haskell adopt that from ML?
18:41:37 <mm_freak> mhr_: good question
18:41:38 <elliott> we were too lazy to
18:42:22 <mm_freak> mhr_: probably because haskell, though influced by ML, is not a descendant of ML
18:42:25 <mm_freak> influenced
18:42:50 <mhr_> oh, didn't realize that
18:42:56 <mgsloan> For functions and datatypes (-XTypeFamilies), you can emulate parametric modules with typeclasses
18:43:13 <byorgey> also, parametric modules were (and in some ways still are) a very active research topic.
18:43:13 <mm_freak> mgsloan: that's ugly and noisy
18:43:33 <byorgey> when haskell was created they mostly tried to stick with well-understood features (with the exception of type classes, which worked out pretty well)
18:43:37 <mgsloan> mm_freak: True true
18:43:43 <mm_freak> i emulate parametric modules through implicit configurations
18:44:29 <mgsloan> As far as I know typeclasses / instances are what make parametric modules difficult for haskell
18:44:30 <Fuuzetsu> > init [1 .. 10]
18:44:31 <lambdabot>   [1,2,3,4,5,6,7,8,9]
18:44:38 <mgsloan> Maybe GADTS make it tough as well
18:44:50 <mm_freak> type classes are fine, but instances are a problem
18:45:02 <mgsloan> (In other words, you can't just straight up wrap your top level declarations in a datatype)
18:45:42 <mhr_> If I wanted to learn a static functional programming language, which would be more fun: an ML language, like SML or OCaml, or Haskell?
18:46:02 <mm_freak> type class instances are considered to be global, so with parametric modules you could make instance definitions dependent
18:46:22 <mm_freak> but you could disallow instances to refer to module parameters
18:46:39 <mm_freak> mhr_: probably all of them
18:46:46 <byorgey> mhr_: Haskell, for sure.  Not that we are biased or anything.
18:46:55 <mhr_> haha
18:47:18 <mm_freak> @faq does haskell fun outperform ocaml/SML fun?
18:47:18 <lambdabot> The answer is: Yes! Haskell can do that.
18:48:08 <mhr_> I guess it depends on how you define "fun", but I'm just looking for some intellectual stimulus...
18:48:12 <byorgey> > let fun = sum . map ord in  (fun "Haskell", fun "OCaml")
18:48:13 <lambdabot>   (708,460)
18:48:16 <byorgey> a clear win.
18:48:28 <mm_freak> mhr_: then haskell
18:48:35 <Fuuzetsu> This is how everything should be decided.
18:48:41 <mhr_> mm_freak: why?
18:48:48 <mhr_> haha what did you just do, byorgey?
18:48:50 <mm_freak> ocaml and SML are "easy" in the sense that you can and have to cheat
18:48:57 <mhr_> cheat?
18:48:59 <byorgey> mhr_: I computed the Fun Quotient (tm) of each language
18:49:01 <mhr_> oh, the impurity?
18:49:11 <mhr_> hahahahahahahaha oh my gosh
18:49:16 <byorgey> The Fun Quotient (tm) is defined as the sum of the ASCII values in the letters of the name
18:49:23 <Fuuzetsu> Fun Quotient™
18:49:37 <mm_freak> mhr_: yeah
18:49:39 <mhr_> that just made my day, byorgey
18:49:43 <byorgey> =)
18:49:55 <Clint> > sum . map ord $ "Fun Quotient™"
18:49:55 <lambdabot>   9668
18:50:04 <mm_freak> here is a haskell for loop:
18:50:12 <mhr_> mm_freak, okay.  I think I'm going to go with Haskell then... except... perhaps I'll go ask the OCaml freenode channel what they think I should do :P
18:50:18 <mm_freak> > fix (\r x y -> x : r y (x+y)) 0 1
18:50:19 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:50:27 <byorgey> mhr_: that seems only fair.
18:50:45 <mm_freak> you can even do PHP in haskell:
18:50:49 <mm_freak> > let 2 + 2 = 5 in 2 + 2
18:50:52 <lambdabot>   5
18:51:02 <Fuuzetsu> wut
18:51:06 <mhr_> wow
18:51:11 <Fuuzetsu> Oh, did you just shadow (+)?
18:51:16 <monochrom> yes
18:51:18 <thoughtpolice> yeah
18:51:21 <byorgey> > let 2 + 2 = 5 in 2 + 3
18:51:22 <thoughtpolice> > let 2 + 2 = 5 in 2 + 3
18:51:23 <lambdabot>   *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
18:51:24 <mhr_> how... is that possible?
18:51:25 <lambdabot>   *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
18:51:29 <thoughtpolice> argh, byorgey beat me
18:51:31 <m3ga> > let func = sum . map ord in (fun "Disciple", fun "Haskell", fun "Ocaml")
18:51:33 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr t2)
18:51:34 <lambdabot>    arising from a us...
18:51:39 <mm_freak> mhr_: i just defined a new function called (+)
18:51:45 <m3ga> > let fun = sum . map ord in (fun "Disciple", fun "Haskell", fun "Ocaml")
18:51:46 <lambdabot>   (813,708,492)
18:51:48 <monochrom> because "let x=1 in let x=2 in x" is possible and is 2
18:51:51 <amosr> m3ga: we win!
18:51:56 <mm_freak> its name happens to clash with the regular (+)
18:52:00 <mhr_> m3ga, what is "Disciple"?
18:52:21 <mm_freak> m3ga: conclusion:  the Fun Quotient must be illdefined
18:52:22 <m3ga> @google ddc
18:52:23 <mhr_> ah http://www.haskell.org/haskellwiki/DDC
18:52:23 <lambdabot> http://en.wikipedia.org/wiki/Display_Data_Channel
18:52:23 <lambdabot> Title: Display Data Channel - Wikipedia, the free encyclopedia
18:52:28 <Fuuzetsu> > let fun = sum . map ord in (fun "Disciple", fun "HASKELL", fun "Ocaml")
18:52:29 <lambdabot>   (813,516,492)
18:52:33 <mhr_> or... guess not
18:53:01 <byorgey> mhr_: you were right
18:53:05 <mhr_> I'm confused...?
18:53:06 <mhr_> oh okay
18:53:09 <m3ga> mhr_: yes DDC on haskell wiki (which probably redirects)
18:53:10 <Fuuzetsu> :t takeUntil
18:53:11 <lambdabot> Not in scope: `takeUntil'
18:53:17 <Fuuzetsu> :t takeWhile
18:53:18 <lambdabot> (a -> Bool) -> [a] -> [a]
18:53:21 <byorgey> the top google result happens to not be the thing m3ga was talking about =)
18:53:26 <mhr_> hmm.  Strict evaluation compared to Haskell's lazy.
18:53:43 <m3ga> mhr_: more than that, but yes
18:53:54 <mm_freak> disciple is commonly called a haskell dialect, because the syntax looks similar
18:54:01 <mm_freak> by that logic BASIC is an SQL dialect
18:54:52 <amosr> well, they're both purely functional and they both compile to System-Fc
18:54:59 <m3ga> disciple is a strict statically typed functional language, with HM like type inference.
18:55:31 <m3ga> i think disciple is closer to haskell than say ocaml
18:55:32 <mm_freak> amosr: are they?  i thought disciple has actual side effects
18:55:36 <Fuuzetsu> I'm looking for a function that will split a list around the elements I define. E.g. f "ab!ce@fghi" "!@;" = ["ab", "!", "ce", "@", "fghi"]
18:55:41 <Fuuzetsu> I can't seem to come up with an elegant solution
18:55:42 <thoughtpolice> they also both feature similar things like hierarchial modules whatnot, i believe
18:55:55 <m3ga> thoughtpolice: yes
18:56:19 <amosr> mm_freak: it has side effects, but they're tracked
18:56:39 <byorgey> Fuuzetsu: that's splitOneOf from Data.List.Split
18:56:39 <mm_freak> amosr: there's your difference
18:56:50 <m3ga> disciple is like haskell with an effects type system (side effects tracked by the type system)
18:56:55 <byorgey> Fuuzetsu: well, not quite I guess since you want to keep the delimiters, but you can do that too
18:56:55 <thoughtpolice> i should actually give Disciple a look one of these days, last I saw Ben rewrote most of it and it's much nicer but the new version isn't fleshed out i think
18:57:04 <amosr> well, haskell has primitive tracking of side effects (IO, State)
18:57:05 <thoughtpolice> like parts of the compiler are unimplemented, etc
18:57:22 <amosr> thoughtpolice: the new core is implemented, but not the new frontend
18:57:43 <thoughtpolice> ah, that makes things more clear
18:57:46 <byorgey> > split (oneOf "!@;") "ab!ce@fghi"
18:57:47 <lambdabot>   ["ab","!","ce","@","fghi"]
18:57:51 <byorgey> Fuuzetsu: ^^^
18:57:53 <mm_freak> > groupBy ((==) `on` (`elem` ",;")) "abc,;def,g"
18:57:54 <lambdabot>   ["abc",",;","def",",","g"]
18:58:13 <Fuuzetsu> Yeah, I'll just ignore dropDelims
18:58:42 <Fuuzetsu> Is Data.List in base?
18:58:58 <byorgey> Data.List is in base
18:58:58 <geekosaur> yes
18:59:03 <byorgey> Data.List.Split is in the split package.
18:59:19 <mm_freak> amosr: haskell doesn't track side effects…  it has a DSL for describing side effects, which critically depends on non-strict semantics and lazy evaluation to work the way it does
18:59:21 <Fuuzetsu> shooks
18:59:28 <byorgey> both are in the Haskell Platform.
18:59:51 <byorgey> oh, but you're hacking on haddock, aren't you
18:59:59 <Fuuzetsu> Yeah.
19:00:06 <amosr> mm_freak: oy vey
19:00:10 <byorgey> hmmm.
19:01:04 <mm_freak> i find that quite ironic
19:01:05 <byorgey> Fuuzetsu: mm_freak's solution seems nice.
19:01:05 <Fuuzetsu> Replicated the stupid behaviour of the current lexer/parser is a pain
19:01:05 <Fuuzetsu> Replicating.
19:01:05 <Fuuzetsu> Must have missed it…
19:01:09 <byorgey> > groupBy ((==) `on` (`elem` ",;")) "abc,;def,g"
19:01:10 <lambdabot>   ["abc",",;","def",",","g"]
19:01:13 <mm_freak> byorgey: mine was actually a joke
19:01:16 <byorgey> oh.
19:01:16 <mm_freak> but yeah, it does work
19:01:40 <monochrom> one day, you will create a mutual dependency between haddock and the rest of all Haskell Platform :)
19:01:51 <mhr_> I thought I installed alex, but it isn't recognizing my efforts: http://pastebin.com/raw.php?i=BExmJh2z
19:01:53 <mauke> The paste BExmJh2z has been copied to http://sprunge.us/IZVd?haskell
19:01:56 <Fuuzetsu> Well, I need it to split into ",", ";" instead of into ",;"
19:01:56 <amosr> mm_freak: ok, so disciple is purely functional because you are guaranteed to get the same result whether you evaluate something strictly or lazily
19:02:02 <mm_freak> Fuuzetsu: do we finally get markdown support in haddock? =)
19:02:03 <amosr> * assuming it compiles
19:02:20 <byorgey> mhr_: by default it installs stuff in ~/.cabal/bin
19:02:20 <Fuuzetsu> mm_freak: Maybe.
19:02:24 <mm_freak> amosr: wow, that's a very weird definition of "purely functional" =)
19:02:25 <amosr> because it won't compile if you try to use laziness and there are interfering effects...
19:02:28 <byorgey> mhr_: so you have to add that to your $PATH
19:02:41 <monochrom> also, order in PATH matters
19:02:44 <Fuuzetsu> There's stuff I have to do before but if nothing really unexpected comes up then support should be added.
19:03:03 <mhr_> what is the "PATH"?  Sorry, I just switched to Linux not too long ago, I don't know much.
19:03:08 <byorgey> mhr_: (you can also configure cabal to install things somewhere else, by editing ~/.cabal/config)
19:03:24 <monochrom> PATH on linux is analogous to %path% on windows
19:03:37 <b6> $PATH
19:03:54 <byorgey> mhr_: it is an environment variable that contains a list of directories the shell should search for executables
19:03:55 <mhr_> I don't know what that is either haha
19:04:03 <mhr_> how do I configure it?
19:04:10 <Fuuzetsu> @google PATH variable linux
19:04:12 <lambdabot> http://www.linfo.org/path_env_var.html
19:04:12 <lambdabot> Title: What is PATH? -- definition by The Linux Information Project (LINFO)
19:04:14 <monochrom> both mean "where to look for exe's"
19:04:27 <amosr> mm_freak: hmm maybe it is. but the same is true for haskell, but is not the case in impure languages eg ML
19:04:44 <mm_freak> amosr: it's not true in haskell either
19:04:47 <mm_freak> > undefined
19:04:48 <lambdabot>   *Exception: Prelude.undefined
19:05:45 <Fuuzetsu> :t on
19:05:45 <amosr> okay. if something eventually evaluates to a value, then lazy and strict will be the same
19:05:45 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
19:05:46 <byorgey> mhr_: that link Fuuzetsu found looks like a good explanation
19:06:09 <mm_freak> amosr: yeah, and that's a law…  it's not actually checked
19:06:17 <byorgey> mhr_: in short, you can add a line like   export PATH="~/.cabal/bin:$PATH"   to your .bash_profile  (or some other appropriate place)
19:06:56 <amosr> but it's assured by haskell being purely functional?
19:06:56 <mm_freak> amosr: and also it's only true for normal forms
19:07:07 <mm_freak> other than the usual base types you seldomly evaluate to NF in haskell
19:07:14 <mm_freak> in disciple you do it all the time
19:07:49 <mm_freak> it's assured by haskell being referentially transparent
19:08:05 <mm_freak> ("purely functional" doesn't really mean anything)
19:08:09 <mhr_> thanks... .bash_profile?  I have so much to learn...  gah.
19:08:28 <mhr_> but I'll locate that file and add that line.
19:08:31 <mm_freak> mhr_: quite a mental exercise you have ahead of you…  switch to linux and haskell =)
19:09:03 <monochrom> there are some linux textbooks
19:09:05 <Fuuzetsu> mhr_: Check in your home directory. It might not exist.
19:09:19 <mm_freak> if that's not enough, switch to NixOS in the same run =)
19:09:23 <amosr> mm okay. well maybe I should have said disciple is referentially transparent, then?
19:09:37 <mm_freak> amosr: and i'm not sure that it is
19:09:51 <mhr_> mm_freak: I guess so.  I started on a Windows laptop, gift of my mother's, and I've been living in my Linux VM for a couple months... I'm going to switch fully soon.
19:10:05 <mm_freak> amosr: the way i understood it is that in disciple the type system makes sure that your side effects are under control, not that they don't happen
19:10:18 <mm_freak> in haskell they actually don't happen and the whole coding style is different
19:10:56 <h4199> mhr_: http://www.linuxfromscratch.org/blfs/view/6.3/postlfs/profile.html skim down for the particulars of bash_profile
19:10:57 <amosr> if the program typechecks, then it will be referentially transparent
19:11:08 <mm_freak> amosr: how can that be?
19:11:29 <amosr> because it won't allow laziness where it would change the meaning/interfere with effects
19:11:32 <mm_freak> what's the disciple equivalent of main = forever (putStrLn "hello!")
19:11:33 <mm_freak> ?
19:11:51 <mhr_> Fuuzetsu: It's there!  I added that line of code... here goes...
19:12:03 <mhr_> h4199: thanks for the article
19:12:09 <amosr> "main = do putStrLn "Hello" ; main" ?
19:12:28 <mm_freak> what does "do" do in disciple?
19:12:47 <amosr> it's actually just for introducing bindings
19:13:30 <amosr> and sequencing I guess. nothing to do with laziness
19:13:32 <amosr> err
19:13:35 <mm_freak> so it's magic?
19:13:35 <amosr> nothing to do with monads
19:14:16 <amosr> well it's just syntax for let _ = putStrLn "hello" in main
19:14:16 <monochrom> if it does sequencing and binding, it's dangerously close to monad
19:14:31 <mm_freak> i see
19:14:36 <mm_freak> so side effects
19:15:01 <amosr> so putStrLn :: String -(Console)> ()
19:15:07 <mm_freak> what i really love about haskell is that side-effecting actions are first class values
19:15:22 <mm_freak> that gives a very natural way to write combinators (aka control structures, if you will)
19:15:50 <mm_freak> this kind of composable programming is the main difference between haskell and all the strict-by-default languages out there
19:16:07 <monochrom> after all, Moggi's original paper precisely maps "let-in" syntax to monad bind semantics
19:16:07 <mm_freak> that's why i wouldn't call disciple a haskell dialect
19:16:22 <mm_freak> it's rather an ML dialect with haskell syntax
19:16:32 <monochrom> so, it is no use for you to say "the syntax is let-in, therefore the semantics is not monad bind" :)
19:16:34 <amosr> ok. fair enough… but it *is* referentially transparent
19:16:44 <mm_freak> amosr: no, it's not
19:16:47 <mm_freak> you just proved it =)
19:17:06 <amosr> monochrom: yeah, I actually meant, it's not to do with a typeclass Monad
19:17:22 <monochrom> oh, I see, that works
19:17:24 <amosr> no no
19:18:01 <monochrom> ?
19:18:03 <mm_freak> amosr: you can't replace 'putStrLn "blah"' by '()' in disciple as its type suggests
19:18:27 <amosr> let i = 5 in let _ = update i 3 in i
19:18:34 <amosr> typechecks, updates i, returns 3
19:18:42 <amosr> let i = 5 in let lazy _ = update i 3 in i
19:18:44 <amosr> no type check
19:18:49 <monochrom> I haven't learned disciple, so I can't say "it must be a kind of monad bind" either. just saying the syntax doesn't matter.
19:19:39 <mm_freak> i guess in disciple do-notation is really just a convenience…  the equivalent of scheme's (begin) construct
19:19:47 <amosr> mm_freak: hmm, no, you can't replace it with () because it has a Console effect...
19:19:49 <amosr> lunch!
19:20:27 <monochrom> interesting
19:20:39 <mm_freak> amosr: then how do you get at the ()?
19:21:27 <mm_freak> let x = putStrLn "blah" in x
19:21:29 <mm_freak> is this allowed?
19:25:18 <mhr_> Alright, adding that line to my .bash_profile didn't work, I gave up and tried to copy "alex" directly to /usr/bin/, which is a bit of a frustration move, because it seemed like it didn't work.  You probably can't put a program there without sudo.
19:25:35 <monochrom> that is correct
19:25:52 <mhr_> what do I do now?
19:26:05 <shachaf> Find out why it didn't work.
19:26:14 <shachaf> (Adding the line, that is.)
19:26:28 <monochrom> that depends on a lot of details of your linux installation and setup etc etc
19:28:35 <monochrom> for short-term, at a terminal, enter "PATH=$HOME/.cabal/bin:$PATH". this has effect in that terminal only, and only until you close it.
19:29:17 <monochrom> editing .bash_profile or .profile is long-term, but likely doesn't take effect until you log in next time
19:30:11 <mhr_> I'll log out and see if that helps.
19:30:30 <mhr_> oops, didn't see your earlier message, I'll try that first haha
19:31:39 <monochrom> some people say, you have the option of putting "PATH=blahblah" in .bashrc, this is both long-term and takes effect almost immediately, i.e., all terminals you open afterwards. however, some other people say, you should just never set PATH in .bashrc
19:33:00 <b6> i think the reasoning is, shell-agnostic stuff should go in ~/.profile. less to change if you switch shells.
19:33:28 <monochrom> .profile is not shell-agnostic. csh ant tcsh ignore it
19:33:50 <b6> well, it's a huge mess.
19:33:51 <mhr_> monochrom: I think that worked
19:34:05 <monochrom> good to hear
19:35:46 <elliott> oh dear, does monochrom use csh? :)
19:35:55 <joelteon> he uses c shell by the c shore
19:35:59 <monochrom> .bashrc is good for interactive bash only, e.g., bash in terminal. therefore, most X windows and some bash scripts do not benefit from it
19:36:21 <monochrom> I use bash. but a long time ago, school accounts were on csh and tcsh
19:36:40 <monochrom> *I* am the shell-agnostic one
19:37:39 <Clint> the correct answer is: you set PATH in .zshenv
19:46:17 <cl1> how do i get lambdabot to list its commands?
19:47:02 <mhr_> I'm thinking of getting the fish shell.
19:47:58 * cl1 uses powershell
19:48:01 <mhr_> hmm.  this is strange.  Vim-mode for the Yi editor is taking longer to install than Emacs-mode, I thought Emacs had more stuff in it...
19:48:07 <elliott> cl1: @listmodules
19:48:13 <elliott> and then @list an individual module
19:48:55 <shachaf> There's another way but maybe elliott would get mad at me if I said.
19:49:01 <cl1> elliott i mean how do i get it to list stuff like @list so I know what I can do with it
19:49:08 <Ralith> mhr_: but yi is closer to emacs to start with, I think
19:49:17 <DanBurton> what is the go-to library for type-level nats that includes computations like "Plus" at the type level?
19:49:24 <Ralith> @hoogle type-level
19:49:25 <lambdabot> package type-level
19:49:25 <lambdabot> package type-level-natural-number
19:49:25 <lambdabot> package type-level-natural-number-induction
19:49:29 <Ralith> er
19:49:33 <Ralith> @hackage type-level
19:49:33 <lambdabot> http://hackage.haskell.org/package/type-level
19:49:52 <mhr_> oh, it just occurred to me.  Has anyone here tried out Yi?  Do any of you use it as your main editor...?
19:52:12 <mhr_> elliott: are you Conal Elliott?
19:52:24 <elliott> mhr_: nope, he goes by conal on irc
19:52:31 <mhr_> oh okay
19:52:34 <elliott> cl1: like I said, @listmodules
19:52:40 <elliott> and then @list one of the words it gives
19:52:43 <elliott> and that will list the commands in that module
19:52:51 <elliott> the full list of commands is very long
19:52:56 <elliott> but you can also get it if you /msg lambdabot @
19:53:01 <elliott> but it's kind of a mess
19:53:14 <cl1> thanks elliott
19:54:02 * cl1 figured out plain old :t and :k work but not :i
19:54:07 <h4199> mhr_: write haskell where you are comfortable, there are haskell plugins for vim, emacs, sublime et al...
19:54:42 * cl1 uses notepad++
19:54:55 <mhr_> I've been using Vim for the past couple months.
19:55:14 <mhr_> first real editor I've used
19:55:24 * cl1 wishes he could code haskell in Visual Studio
19:55:27 <mhr_> but I'm actually trying to make my own editor
19:56:23 <cl1> mhr_ .. you could help out with leksah instead of starting from scratch
19:58:54 <amosr> mm_freak: sure, that'll return a unit wrapped in Console effect
19:59:29 <roboguy_> I'm excited to try Haskell Center
20:04:02 <flebron> for today's "jesus christ what the hell is your problem ghc", i present to you: opening a comment with {-, having the following expression in a -- somewhere inside the commented code: \Li_{-n}(1/z) = (-1)^(n + 1) \sum_{k = 0}^n k! ..., and wondering why ghc was complaining about an extraneous -} when i closed the comment.
20:04:24 <flebron> (since that expression was inside a --, there was no problem until i enclosed it all with a {-.)
20:05:15 <dmwit> ?karma notepad
20:05:15 <lambdabot> notepad has a karma of 47
20:05:26 <dmwit> ?karma test
20:05:26 <lambdabot> test has a karma of -2
20:05:38 * dmwit test++
20:05:38 <dmwit> ?karma test
20:05:39 <lambdabot> test has a karma of -2
20:05:47 * shachaf test++ blah
20:05:50 <shachaf> @karma test
20:05:50 <lambdabot> test has a karma of -1
20:06:27 * tabemann is relieved to have fixed that goddamn infinite loop in his red-black tree code
20:07:24 <tabemann> stupid Haskell question
20:07:40 <tabemann> if no guard matches for a given pattern, will control fall down to the following patterns?
20:07:42 <shachaf> Do you really have to tell us that your questions are stupid each time before you ask them?
20:07:52 <Fuuzetsu> tabemann: no
20:07:59 <tabemann> damn
20:08:06 <shachaf> Fuuzetsu: ?
20:08:12 <tabemann> it would've made my code quite a bit nicer here
20:08:18 <Fuuzetsu> Wait, will it?
20:08:18 <Fuuzetsu>  
20:08:19 <mhr_> cl1: I wanted to try out a combination of vim/emacs, which I thought Yi was... basically, Emacs hurts my hand (no surprise there) and I had only used it for a couple hours before this happened hahaha, but I really like Org-Mode.  So!  I want to make an Org-Mode with modal Vim-like bindings, and make it with JavaScript, because I wanted a web text editor.  And I thought it'd be fun.  Leksah.  The website says it's an IDE for Haskell, bu
20:08:26 <shachaf> tabemann: This sounds like the sort of thing you can test yourself, but maybe you should clarify what you mean with some code.
20:08:38 <tabemann> shachaf: I say it because I feel I should know it already
20:08:49 <ekipan> > let f 'a' | False = 'b'; f 'a' = 'c' in f 'a'
20:08:50 <lambdabot>   'c'
20:10:02 <hpaste> tabemann pasted “Guards and (non-)fall through” at http://hpaste.org/90213
20:10:10 <shachaf> tabemann: OK, but if you say it's a stupid question, it makes me not want to help. It seems to me that if it's such a bad question that you shouldn't ask it, you shouldn't ask it. Otherwise go ahead and ask it.
20:10:20 <shachaf> (You're the only one who does this regularly, though, I think.)
20:10:21 <Fuuzetsu> f 1 | False = 3; f 2 = 3; f 1 = 5    ;   f 1 => 5
20:10:26 <shachaf> (Anyway, it's not such a big deal.)
20:11:26 <hpaste> tabemann revised “Guards and (non-)fall through”: “Guards and (non-)fall through” at http://hpaste.org/90213
20:11:58 <shachaf> tabemann: It's pretty simple to test whether guards fall through. People have given some examples above.
20:12:02 <Fuuzetsu> tabemann: I just tried and it does fall through.
20:12:09 <shachaf> In fact it seems to me like it's simpler to test it than to ask in #haskell. :-)
20:12:32 <dmwit> mnemonic: = and -> commit
20:12:32 <Fuuzetsu> You might not want to use the catch-all ‘otherwise’ if you want a fall-through…
20:12:53 <tabemann> okay, so I can merge those functions back into one function and get rid of those otherwise clauses then
20:14:11 <shachaf> The important lesson here isn't the behavior of guards and patterns, it's how to figure out this kind of thing yourself. :-)
20:15:00 <tabemann> I sometimes feel it is easier to simply ask than to put together an experiment to test something
20:15:32 <shachaf> Right. That's exactly what you would benefit from practice at.
20:16:08 <shachaf> You got three answers: A wrong one; a request for clarification; and a fully-formed experiment that tested the question.
20:16:32 <mhr_> haha I'm nervous, Yi's installation has been stuck on one JavaScript syntax highlighting mode for the last fifteen minutes or something... http://pastebin.com/raw.php?i=L7bW78PJ
20:16:37 <mauke> The paste L7bW78PJ has been copied to http://sprunge.us/LJYX?haskell
20:17:06 <startling> JavaScript /is/ hard toparse.
20:17:25 <amosr> mhr_: what version of ghc?
20:18:44 <mhr_> amosr: my entire VM is freezing :/, I'll let you know once it fixes
20:19:02 <tabemann> shachaf: tis true
20:19:48 <ekipan> lean on lambdabot, she can answer lots of such questions for you
20:20:00 <ekipan> then you don't have to feel stupid
20:20:34 <ekipan> or, well, you do have ghc right there
20:20:41 <tgeeky> side note: discuss things with lambdabot in pm, to *appear* less stupid (in addition to feeling so)
20:21:23 <ekipan> @botsnack
20:21:23 <lambdabot> :)
20:21:58 <elliott> if you talk to lambdabot in /msg, only I can tell how stupid you are! (actually, lambdabot doesn't log.)
20:22:11 <tabemann> heh
20:22:13 <newsham> and the nsa
20:23:51 <tabemann> question: as good practice goes, with patterns and guards, is it good practice to catch *all* cases even when certain cases are invalid and should be unreachable except in the case of a bug, where throwing an exception *is* desired rather than failing more quietly?
20:24:59 <enthropy> tabemann: a pattern match failure gives you the line of code involved, which doesn't happen with exceptions
20:25:26 <enthropy> so that's one reason for avoiding a catch-all case like      _ -> error "the impossible happened"
20:25:46 <tabemann> okay, so I've got a few of those in my code, so I should take them out then?
20:26:39 * tabemann is going now
20:28:27 <adnap> ?karma shachaf
20:28:28 <lambdabot> shachaf has a karma of 53
20:28:40 <adnap> Is this new?
20:28:45 <elliott> no
20:28:46 <shachaf> All that karma?
20:28:55 <shachaf> My karma is artificially inflated by a bot in another channel.
20:28:59 <adnap> The logging of karma
20:29:05 <shachaf> No, not new.
20:29:06 <shachaf> @karma blah
20:29:06 <lambdabot> blah has a karma of 31337
20:29:30 <adnap> shachaf--
20:29:36 <adnap> ?karma shachaf
20:29:36 <lambdabot> shachaf has a karma of 52
20:29:36 <mhr_> noooooooooooooooooooooooooooo!  haha gosh, all that time, and it didn't install!  darn!  http://pastebin.com/raw.php?i=wD4kDqH1  what is karma?
20:29:40 <adnap> Interesting
20:29:42 <mauke> The paste wD4kDqH1 has been copied to http://sprunge.us/heDS?haskell
20:29:48 <adnap> shachaf++
20:29:52 <ekipan> @help karma
20:29:52 <lambdabot> karma <polynick>. Return a person's karma value
20:30:00 <ekipan> @help karma+
20:30:00 <lambdabot> karma+ <nick>. Increment someone's karma
20:30:04 <adnap> I can suck peoples karma?
20:30:21 <adnap> Apparently
20:30:23 <tgeeky> it's more of increment and decrement, really
20:30:37 <adnap> Yeah, but I can do it as many times as I want
20:30:47 <shachaf> I think that's enough karma discussion...
20:31:28 <Xunie> @karma Xunie
20:31:28 <lambdabot> You have a karma of 0
20:31:36 <Xunie> Well, I'll get working on that... :3
20:31:47 <mhr_> what is karma?
20:31:49 <shachaf> Also, y'all can /msg lambdabot.
20:32:03 <tgeeky> shachaf: that's like, the number one feature of lambdabot.
20:32:50 <paintcan> speaking to lambdabot publicly also seems to be a popular feature
20:34:19 <Fuuzetsu> paintcan: It's popular because people who see what you're trying out often pitch in and offer a Better Way™ which is pretty useful.
20:34:28 <Xunie> ^+1
20:34:35 <roboguy_> hmm, if I set the ghci prompt in my ghci.conf file, emacs for OS X freezes up whenever I try to load a Haskell file with C-c C-l…
20:35:05 <applikativ> mhr_: why is yi failing to install, it seems just to be a warning.
20:35:11 <roboguy_> anyone see anything like that before?
20:35:18 <paintcan> I enjoy seeing people interact with lambdabot. speaking for myself, of course, particularly if the room is quiet. but enough of that
20:35:47 <Fuuzetsu> roboguy_: known issue, there's a workaround floating around somewhere
20:35:47 <dolio> A little is okay.
20:35:49 <mhr_> applikativ: that's what I thought, but then it just randomly stopped and printed that!
20:35:57 <applikativ> > fmap reverse (Just "savages")
20:35:57 <dolio> But sometimes people go overboard.
20:35:58 <lambdabot>   Just "segavas"
20:36:11 <tgeeky> my point is that I bet some or a lot of the people who contribute good answers, make sure they are correct first in PM if it's complicated enough
20:36:14 <Fuuzetsu> roboguy_: http://stackoverflow.com/questions/7961786/emacs-hangs-in-haskell-mode-with-inferior-haskell-load-file-call
20:36:36 <tgeeky> Since he said it doesn't log, I assume it doesn't count conversations either.
20:36:59 <elliott> @activity
20:36:59 <lambdabot> 1*total 1*#haskell
20:37:04 <elliott> there's that weird thing.
20:37:29 <roboguy_> Fuuzetsu: thanks! that's been bothering me for a while
21:10:50 <AsgardBSD> hi
21:11:06 <AsgardBSD> played a little bit with haskell
21:15:02 <applikativ> good work, AsgardBSD
21:15:11 <AsgardBSD> good work?
21:15:44 <applikativ> playing a little with Haskell; there are worse things
21:15:50 <AsgardBSD> Anyways, i recently hasked if there was other language that i shall learn...
21:15:55 <AsgardBSD> what about erlang?
21:16:24 <AsgardBSD> I heard erlang is used in industry (im sure i can apply lot of haskell concept to it)
21:17:17 <applikativ> and none of those pesky types getting in the way
21:17:33 <AsgardBSD> may you explain?
21:17:39 <AsgardBSD> Im not sure i understood your sentence
21:18:24 <roboguy_> haskell is statically typed and dynamically typed
21:18:38 <roboguy_> *and erlang is dynamically typed
21:18:48 <applikativ> I was quoting John Hughes who praised Erlang after getting mixed up in it after too many years of Haskell ...
21:19:21 <applikativ> I don't think he was being serious ...
21:20:46 <AsgardBSD> so is erlang a good language to learn?
21:21:39 <johnw> AsgardBSD: if you want a strong yes, ask in #erlang
21:21:54 <AsgardBSD> i dont ask for a strong yes
21:21:55 <applikativ> this channel is likely to be of one mind on the question
21:22:05 <johnw> then I say, learn Haskell
21:22:58 <AsgardBSD> i am asking here because most people here know a lot of theory and may help me getting learning other useful hting
21:26:29 <johnw> a better question would be to ask about a particular kind of problem you care about solving, and whether Haskell is best suited
21:26:42 <joelteon> @faq can Haskell solve his problem best?
21:26:42 <lambdabot> The answer is: Yes! Haskell can do that.
21:26:47 <johnw> if you are looking for a job at Ericsson, probably Erlang is the best bet
21:27:10 <shachaf> I vote for @faq to be removed from lambdabot.
21:27:47 <johnw> Your vote has been tallied.
21:27:54 <Saizan> AsgardBSD: erlang should be interesting for the high-concurrency/distributed domain
21:27:58 <mhr_> this cracks me up
21:28:13 <johnw> Votes for removing @faq from Haskell: 1 for, 0 against.  It's unanimous
21:28:19 <joelteon> against
21:28:23 <joelteon> boom roasted
21:29:13 <mhr_> You haskeller's have a good sense of humor and are a fine bunch, I think I might learn haskell on that alone.
21:29:27 <AsgardBSD> joelteon: i dont have a particular problem, i just search to have a good programming/knowledge background, and try to learn language that will make me learn more
21:29:35 <mhr_> *haskellers, no apostrophe necessary...
21:29:41 <johnw> mhr_: I hear edwardk started there too
21:29:43 <joelteon> well, if you've done primarily procedural/imperative language, haskell is a good functional one to learn
21:29:49 <joelteon> languages
21:29:57 <mhr_> edwardk?
21:30:00 <joelteon> because of full immutability and stuff
21:30:08 <AsgardBSD> but im sure there is more thing to learn beyond haskell and C that could benefit me
21:30:50 <joelteon> if you had to choose just two languages, that sounds good to me
21:30:54 <applikativ> oh mhr_ I tried the new yi, it built fine with -fvty
21:30:57 <joelteon> C for performance and Haskell for everything else
21:31:11 <mhr_> applikativ: what's your operating system, though?
21:31:20 <joelteon> it has great FFI, great libraries, great community
21:31:24 <AsgardBSD> joelteon: well, i heard that haskell can do code that can challenge C on speed
21:31:29 <mhr_> and did it have any problem with JavaScript...?  I don't really know why that's happening, but it is...
21:31:54 <joelteon> AsgardBSD: for most purposes, yeah
21:32:04 <johnw> mhr_: edwardk is a now famous Haskeller
21:32:05 <joelteon> if you're writing code that you need to use C for, there's really no language that can rival C in speed
21:32:15 <joelteon> but that's not a hugely common situation
21:32:16 <applikativ> mhr_: os x, I might have added that and a few other details...
21:32:19 <mhr_> johnw: what famous software has he written?
21:32:27 <joelteon> my company's production app is actually written in Ruby, and the problem isn't Ruby performance but database performance
21:32:34 <johnw> see http://github.com/ekmett
21:32:37 <johnw> he is famous to us
21:33:46 <mhr_> applikativ: so you just popped in "cabal install yi -vty" and it worked without a hitch?
21:34:08 <mhr_> johnw: looks like he built a bunch of tools for haskellers
21:34:13 <johnw> yep
21:34:13 <applikativ> i had to reinstall alex, as I guess you did
21:34:15 <johnw> libraries, mostly
21:34:16 <joelteon> yeah, he wrote lens, he's basically god
21:34:20 <mhr_> applikativ: I did that... gah.
21:34:45 <AsgardBSD> joelteon: what do you thing about ruby?
21:34:49 <mhr_> joelteon: haha no, that'd be Clapton.
21:34:50 <joelteon> I love Ruby
21:35:17 <AsgardBSD> Ruby is one of the language i consider to maybe learn
21:36:02 <joelteon> it's not a very performant language
21:36:02 <mhr_> I don't really understand what Lens is.
21:36:02 <joelteon> but it's quite pretty
21:36:03 <applikativ> mhr_: if you try it with a --verbose flag maybe youll find more about that last minute
21:36:03 <mhr_> awesome, I'll try that.
21:36:05 <joelteon> mhr_: lens is a library that provides functions for accessing and updating different types of structures
21:36:14 <applikativ> --verbose=3 I guess
21:36:29 <johnw> mhr_: not really understanding edwardk libraries is part of their charm; it encourages you to grow
21:37:06 <mhr_> nice
21:37:23 <joelteon> @quote otters
21:37:23 <lambdabot> otters says: lens law #1: the implementation must be shorter than the type
21:37:31 <joelteon> you'll hit that a lot
21:37:33 <applikativ> they are becoming more and more intelligible, these libraries; I don't think it's increasing power of comprehension on my part ...
21:38:05 <applikativ> pretty good line from otters
21:38:11 <joelteon> yeah, that's me
21:38:17 <joelteon> i dunno how to make lambdabot re-attribute quotes
21:38:37 <mhr_> Has anyone here played with OCaml (or SML)?  What do you think of that language compared to Haskell?
21:38:50 <mhr_> what exactly is lambdabot?
21:38:52 <applikativ> joelteon == otters?
21:38:54 <joelteon> yes
21:39:05 <applikativ> oh ok good
21:39:25 <joelteon> if you check my cloak, you'll see it
21:39:28 <joelteon> they won't change it yet :(
21:39:51 <applikativ> it would be nice to design a complex library where every function is actually id
21:40:01 <johnw> mhr_: lambdabot evaluates Haskell here in the channel for us, among other things
21:40:02 <joelteon> yeah
21:40:06 <johnw> > 1 + 2
21:40:06 <AsgardBSD> joelteon: well, ruby not being fast dont bohter me, as long as it can make me other thing that can make me a bether programmer
21:40:07 <lambdabot>   3
21:40:13 <joelteon> well, asAppliedTo = const
21:40:15 <joelteon> fwiw
21:40:20 <joelteon> and I think clonePrism is id
21:40:22 <AsgardBSD> >let bob = 4
21:40:30 <AsgardBSD> >bob
21:40:39 <joelteon> you need a space
21:40:40 <johnw> it has to be "> "
21:40:43 <johnw> and you should use @let
21:40:45 <joelteon> and let bob = 4 isn't an expression
21:40:46 <johnw> @let bob = 4
21:40:47 <mhr_> > let bob = 4
21:40:48 <johnw> > bob
21:40:48 <lambdabot>  Defined.
21:40:48 <mhr_> > bob
21:40:49 <lambdabot>   not an expression: `let bob = 4'
21:40:50 <lambdabot>   can't find file: L.hs
21:40:52 <lambdabot>   mueval-core: Time limit exceeded
21:40:57 <joelteon> :t bob
21:40:58 <lambdabot> Integer
21:41:00 <AsgardBSD> @let = 4
21:41:00 <lambdabot>  Parse failed: Parse error: =
21:41:05 <AsgardBSD> > let = 4
21:41:06 <lambdabot>   <hint>:1:5: parse error on input `='
21:41:11 <AsgardBSD> > let bob = 4
21:41:12 <lambdabot>   not an expression: `let bob = 4'
21:41:21 <shachaf> Also, you can /msg lambdabot to test these things out.
21:41:32 <shachaf> Generally you use lambdabot in the channel if you're demonstrating something to someone else.
21:41:58 <mhr_> I'll wait for someone to answer my OCaml/SML question, but in the meantime, assuming I'm going with Haskell, what is the most enlightening part about Haskell?
21:42:37 <mhr_> the freenode channel for ocaml is just #ocaml, and the SML is #sml, right?
21:43:21 <mhr_> yes, #ocaml is OCaml
21:43:30 <AsgardBSD> mhr_: well, most of the time, #sfml is invite only
21:43:45 <mhr_> What does "SF" stand for?
21:44:00 <AsgardBSD> i mean sml
21:44:10 <mhr_> there are way less people in #ocaml than I expected, I mean there's simply no comparison to the number of people here.
21:44:35 <mhr_> AsgardBSD: What a great way for them to get people to join their community.
21:47:12 <mhr_> wow, and SML has even less people there.  It has a fifth of the population of OCaml, which is smaller still compared to here.  Haskell's already winning with a comparison to number alone.
21:48:01 <johnw> mhr_: the ML family of languages had an influence on the way Haskell is today
21:48:19 <mhr_> yes
21:49:24 <johnw> personally, the fact that OCaml tries to add "object-oriented" constructs to a functional language, is reason enough for me to be disinterested; but other than that, I know almost nothing of it
21:49:48 <mhr_> I'm just trying to decide which one to invest a lot of time in, and so far it's Haskell.
21:50:03 <johnw> yes, I think Haskell is the best choice of those three, without a doubt
21:50:09 <mhr_> Apparently nobody uses the object part of OCaml, which I think is funny.  I don't know where I read that, but I did.
21:50:21 <elliott> generally asking #foo whether foo, bar or baz is better is always going to result in foo
21:50:39 <shachaf> It's also often going to result in a long and pointless discussion.
21:50:58 <shachaf> But maybe this should be added to the FAQ.
21:51:04 <shachaf> On that note, did you read the FAQ?
21:51:05 <shachaf> @where faq
21:51:06 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
21:51:09 <johnw> plus, if you ask "Is Haskell better than Foo", the answer is predetermined here :)
21:51:32 <mhr_> not necessarily
21:51:32 <AsgardBSD> Foo of course
21:51:36 <dolio> I think people use the features the object system is built on.
21:51:39 <dolio> If not the object system proper.
21:51:41 <mhr_> I'm sure if I asked for the fastest language, all of you would direct me to C
21:51:44 <shachaf> My answer: OCaml is better. Go learn OCaml.
21:51:54 <johnw> mhr_: you didn't say what kind of "fast" :)
21:51:54 <mhr_> haha
21:52:12 <mhr_> What other meaning can be interpreted from "fast" than "fast"?
21:52:20 <AsgardBSD> I wonder if i shall learn some Lisp dialect some day
21:52:20 <johnw> fast to market, fast to learn, fast to debug, etc.
21:52:59 <mhr_> I asked OCaml "Hey guys, I'm trying to decide whether I should invest serious time in learning Haskell or OCaml.  What do you think?", and their response is to post '"Haskell style" isn't very informative', and then posted https://www.fpcomplete.com/user/bartosz/understanding-algebras.  I... must say... that's not a great way to entice me into Haskell.
21:53:13 <mhr_> AsgardBSD: Realm of Racket just came out, Racket's a fine Lisp dialect
21:53:35 <johnw> mhr_: also, multicore or not?  vectorized math or not?  is fast with more bugs faster than slow with almost no bugs?
21:53:50 <mhr_> johnw: good answer
21:53:59 <mhr_> okay, Haskell it is, those OCamels hardly tried convincing me.
21:54:08 <mhr_> didn't even put up a fight!
21:54:13 <shachaf> mhr_: I think most people here don't care to entice you into Haskell.
21:54:24 <shachaf> Learn it if you want. I certainly don't want to entice.
21:54:38 <johnw> I seek to entice, only in the hopes that you have as much fun with it as I am
21:54:42 <shachaf> (By "you" I mean "anyone".)
21:55:07 <mhr_> I just want to have fun, that's all.
21:55:28 <mhr_> applikativ: sorry it's been a while, I'm going to install yi once more with your flags
21:55:51 <Fuuzetsu> @package download-curl
21:55:51 <lambdabot> http://hackage.haskell.org/package/download-curl
21:56:55 <lispy> so...let's talk about frp
21:57:02 <mhr_> applikativ: if that doesn't work, I'm just going to go into Yi's source, delete JavaScript, and then try to install.  If that doesn't work, haha I just give up.
21:57:20 <lispy> Anyone have a favorite frp implementation?
21:57:41 <lispy> I tried reactive-banana, but it doesn't seem to be very mature.
21:57:42 <shachaf> lispy: I hear most "frp implementations" aren't actually.
21:57:50 <lispy> shachaf: please explain
21:58:03 <mhr_> Speaking of FRP: You guys seem like a good bunch to ask, what do you guys think of dmbarbour's RDP? (https://github.com/dmbarbour/Sirea)
21:58:13 <mhr_> funny seeing "lispy" on #haskell
21:58:58 <sclv> from what i've heard reactive-banana is about as mature as they come
21:59:06 <shachaf> lispy: Lacking in continuous time or in denotational semantics or something.
21:59:21 <sclv> mhr_ rdp is a set of ideas only fully clear to dmbarbour at the moment
21:59:26 <lispy> shachaf: who told you that? Conal?
21:59:34 <sclv> after he has a working implementation others can judge
21:59:35 <shachaf> Yes.
21:59:56 <sclv> banana tries to hew close to conal's stuff as a recall
21:59:56 <lispy> sclv: unless you want dynamic event switching. Then it locks up your program after about 20 switches :(
22:00:08 <lispy> sclv: the author confirmed it as a bug on SO
22:00:10 <sclv> haha yes. that is another way it hews close to conals stuff!
22:00:27 <sclv> the semantics are very nice but it kills performance in some cases
22:01:01 <lispy> I'm hoping that yampa is more stable
22:01:08 <sclv> i dunno how actively yampa is maintained/developed
22:01:09 <mhr_> does dmbarbour ever show up here?
22:01:17 <sclv> mhr_: not that i know
22:01:35 <elliott> i think yampa is pretty much dead
22:01:40 <carter> johnw what wast the math thing you were saying to mhr_ ?
22:01:40 <lispy> sclv: not amazingly, but it does get updates: Upload dateSat Mar 31 11:53:16 UTC 2012
22:01:42 <elliott> i think it even has a dead fork meant to keep it alive?
22:01:51 <carter> "vectorized math" seems to always grab my eyes :)
22:02:12 <johnw> carter: I just meant, computations that are matrix heavy, that kind of thing
22:02:12 <hashcat> hi everybody. how to get start with ghc api?
22:02:18 <carter> what about them?
22:02:22 <mhr_> carter: was he...? I don't remember that he was.
22:02:35 <johnw> carter: libraries like repa can make fast math apps easier to write
22:02:36 <lispy> So, if Yampa is dead-ish, reactive-banana isn't ready for prime-time, reactive is dead. What do you use?
22:02:43 <lispy> what about netwire?
22:02:43 <carter> johnw repa's the wrong solution :)
22:02:51 <johnw> ah, note to self
22:02:53 <carter> has some good ideas
22:03:01 <johnw> hlearn?
22:03:03 <bakibour> Moin
22:03:17 <carter> hlearn will be using my open libs once i get them out and semi stable api wise
22:03:18 <lispy> hashcat: that's pretty advanced and it changes frequently
22:03:20 <sclv> lispy: i'd poke at sodium, maybe? and if that didn't seem suitable, elerea
22:03:43 <sclv> netwire is a whole different paradigm afaik
22:03:57 <lispy> hashcat: have you already tried this? http://www.haskell.org/haskellwiki/GHC/As_a_library
22:04:03 <sclv> honestly i'm more interested in implementing my own half-baked frp that does what i need than trusting any of the existing implementations
22:04:14 <johnw> carter: ah, yes, you were the AVX2 guy
22:04:18 <sclv> or just don't use dynamic switching in banana!
22:04:23 <sclv> if you can get away with it
22:04:27 <carter> hehe, thats only one tiny detail
22:04:36 <lispy> sclv: at some point you'll need it.
22:04:40 <johnw> in other words, you're the one to ask about fast math :)
22:04:40 <sclv> that's the classic source of bugs. so lots of research is about restricting or eliminating it
22:04:47 <sclv> s/bugs/leaks
22:05:10 <lispy> The more I learn about frp the more I think I should stay away from it :)
22:05:46 <sclv> i think its suited for some domains
22:05:50 <sclv> but not like guis
22:05:54 <sclv> yet
22:05:57 <hashcat> lispy: that seems too simple to get my job
22:06:03 <sclv> for guis normal reactive programming works quite well
22:06:16 <sclv> with fully discrete time. the typical 'inverted observer' stuff
22:06:27 <lispy> hashcat: I guess my question was more of, Can you do the basics with it yet?
22:06:33 <sclv> on frp i like ajeffery's stuff (http://ect.bell-labs.com/who/ajeffrey/) but that's all agda that generates javascript
22:06:36 <carter> johnw the issue with REPA / Fusion based approaches is that they don't work on things like matrix ult
22:06:38 <lispy> hashcat: to understand how to use it, I bet you'll have to read the source.
22:06:40 <carter> *mult
22:06:47 <carter> they only work for "local convoltuions"
22:06:50 <carter> which are important
22:06:54 <carter> but only part of numerical computing
22:07:45 <lispy> sclv: I'm not familiar with the inverted observer
22:08:00 <lispy> sclv: is this something I can just google?
22:08:11 <carter> johnw avx2 isn't that important
22:08:18 <carter> it might be an easy 2-4x perf boost
22:08:19 <carter> maybe
22:08:29 <lispy> ('cuz I'm not finding much)
22:08:59 <johnw> carter: you wanted 10x
22:09:05 <elliott> there seems to be a disappointing tendency to forget about behaviours entirely in frp lately
22:09:14 <hashcat> lispy: i'm reading haddock but it really ruined my head
22:09:25 <carter> johnw i said AVX2 isn't the coolest part of haswell
22:09:49 <sclv> lispy: http://csl.stanford.edu/~christos/pldi2010.fit/meijer.duality.pdf
22:09:55 <sclv> microsoft Rx style
22:10:13 <sclv> is really "observer is the dual to Iterator" that i was trying to say
22:10:15 <lispy> sclv: oh, the sodium docs mention using recursive do to track the state of a behavior. That might actually solve a problem I'm having now with reactive-banana...
22:10:26 <lispy> ah
22:10:27 <hashcat> Isn't there any overview or tutorials of ghc api ?
22:11:18 <sclv> hashcat: what do you want to do with it?
22:11:24 <mhr_> O
22:11:27 <mhr_> haha whoops
22:11:49 <sclv> you can do some things easily with existing wrappers
22:11:54 <sclv> and other things are not well documented
22:11:55 <sclv> it depends
22:12:12 <sclv> elliott: well that's because we can actually handle efficiency as long as we only have events
22:12:46 <hashcat> sclv: i'm not sure. maybe do something like hint
22:12:48 <sclv> and honestly for interactions that are all about clicking buttons and changing dropdowns then evented frp feels more natural to program with
22:13:30 <sclv> hashcat: the best way to learn how to do hint-like things with the ghc api is to read the hint code. :-(
22:13:46 <mhr_> I'm looking at dmbarbour's readme, and he's talking about "declarative effects".  What does that mean?  He says: Everybody knows "side-effects aren't compositional". But that statement is only true in general. There are useful subsets of side-effects that have nice properties - e.g. idempotence, commutativity, monotonicity. For a small subset of effects, one can achieve equational reasoning and refactoring on par with the very best [pr
22:14:00 <mhr_> Other than a monad, how can there be a declarative effect?
22:14:26 <sclv> you may want to look at plotkin
22:14:34 <hashcat> sclv: but how can the author write hint?
22:14:34 <sclv> plotkin's algebraic effects
22:14:45 <sclv> practice!
22:15:47 <hashcat> sclv: i guess there must be some resource?
22:15:58 <sclv> mhr_: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.143.9808
22:16:21 <hashcat> sclv: i'll try to read it. thanks for help.
22:16:23 <mhr_> sclv: okay.  Oh, I missed this: so the next paragraph, he says that it's declarative because you're only querying a resource, and that resource in turn carries out the effect.  "RDP's effect model was inspired from a symmetric observer effect in physics and psychology: one cannot observe a system without influencing its behavior. [...] Thus, only one concept is needed for query and control."
22:16:32 <lispy> hashcat: the ghc api source and programs that use it are the best we have :(
22:16:53 <mhr_> "In RDP, the only effect is observing of the active set of demands by a resource. Those demands are typically queries or control signals."
22:17:01 <mhr_> that still seems like an effect to me...
22:17:10 <mhr_> but I guess he's saying it's the "only effect"
22:17:20 <mhr_> good link, I'll check it out
22:18:05 <hashcat> lispy: alright. thanks for help.
22:22:44 <mhr_> It's really agonizing to see my VM being so slow while the rest of my computer is so fast.
22:22:53 <mhr_> just kills me.
22:28:17 <carter> sclv opinions on the hott book?
22:43:16 <mhr_> Here, apparently, is an implementation of a language using algebraic effects: http://math.andrej.com/eff/.  That's pretty awesome.
22:44:02 <mhr_> it actually looks really, really cool.
22:47:04 <hashcat> hey, i find something may be useful for getting start with ghc api
22:47:19 <hashcat> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-7.6.3/GHC.html
22:47:52 <hashcat> it seems a top-level overview of ghc.
22:54:06 <mhr_> interesting seeing all these people quit and join en masse, must be that the sun just rose in a certain time zone I guess.
22:54:34 <Taneb> I probably shouldn't have came onto IRC
22:54:46 <Taneb> I haven't had breakfast yet and I have things to do
22:55:50 <mhr_> good morning Taneb!  I'm about to go to sleep, I love the Internet, all these different people from all these different places.
22:56:26 <mhr_> different time zones, countries, religions, and yet we all like to program.
22:56:57 <Taneb> And in one awesome language, too
22:57:47 <mhr_> I don't know that I love Haskell yet, I just joined this place a coupla hours ago.  But we'll see.
22:57:49 <Heffalump> mhr_: people quitting en masse might be a general connectivity blip in some significant part of the Internet
22:57:58 <mhr_> true
23:10:06 <Fuuzetsu> I just discovered the -B RTS GHC option. I'm surprised that I haven't heard about it before…
23:10:49 <mhr_> alright guys, I'm tired, ciao
23:12:27 <shachaf> !list
23:12:27 <monochrom> shachaf: http://hackage.haskell.org/packages/archive/pkg-list.html
23:13:04 <shachaf> Its existence is hidden away where no one would ever look.
23:13:08 <shachaf> (I.e. +RTS --help)
23:16:02 <Yep> hi everyone! how would i implement fmap for the following?
23:16:09 <hpaste> Yep pasted “MyFunction fmap” at http://hpaste.org/90215
23:17:55 <Fuuzetsu> Have you considered fmap f (MyFunction a) = MyFunction (fmap f a) ?
23:19:12 <Yep>     Expected type: b -> a       Actual type: a -> a
23:21:58 <shachaf> Fuuzetsu: ?
23:22:03 <shachaf> Yep: It is impossible.
23:22:12 <Fuuzetsu> Right, it's not.
23:22:18 <Fuuzetsu> Apologies, it's past 7am here.
23:22:29 <shachaf> It always is.
23:22:34 <Fuuzetsu> ;)
23:23:08 <Yep> okay, thought as much... thanks... therefore are their any class types that allow me to combine in a similar way?
23:23:16 <johnw> Yep: Monoid
23:23:39 <johnw> would let you merge two MyFunction a's, where a is the same
23:23:48 <Fuuzetsu> :t mappend
23:23:50 <lambdabot> Monoid a => a -> a -> a
23:23:59 <elliott> Yep: it's an Invariant functor.
23:24:10 <elliott> you get (a -> b), but you also need (b -> a)
23:24:23 <elliott> class Invariant f where invmap :: (a -> b) -> (b -> a) -> f a -> f b -- it can be an instance of this
23:24:56 <Yep> ohh great!
23:25:21 <Yep> thanks everyone
23:26:08 <elliott> @hackage invariant
23:26:08 <lambdabot> http://hackage.haskell.org/package/invariant
23:26:31 <elliott> Yep: btw, your type is just Data.Monoid.Endo
23:26:41 <elliott> well, not "just". your type is Data.Monoid.Endo :)
23:28:36 <mhr> Well, I'm back, thought I'd just mention that Yi installed!  Under -fvty, nothing else worked.
23:28:58 <kryft> It's odd that I only heard about yi like two days ago
23:29:27 <kryft> An editor written in and extensible in haskell that supports vi's editing model sounds great
23:29:29 <Yep> elliott: great, thanks
23:29:32 <Fuuzetsu> It's not seeing many updates.
23:30:25 <kryft> I haven't really written any real haskell code yet, but I think I'm already becoming addicted to the type system. :(
23:31:14 <kryft> I was writing matlab/octave code at work late last night and kept thinking how much better it would be with a good type system. :P
23:31:59 <Fuuzetsu> Or with some actual features.
23:33:06 <kryft> Fuuzetsu: Well yes, my complaints about matlab certainly wouldn't end there :)
23:36:04 <carter> kryft : i will have a BLAS and Lapack layer thats BSD out very soon ™
23:36:09 <carter> aiming for the next few weeks
23:36:14 <kryft> carter: Oh wow
23:36:14 <carter> for my version zero
23:36:40 <kryft> carter: What do you mean by BSD?
23:36:49 <carter> "BSD3"
23:37:05 <carter> i'll have some commercial offerings on top of my open stuff
23:37:08 <kryft> carter: Ah, license
23:37:12 <carter> yes
23:37:26 <carter> BSD3 = you can safely use it in your business
23:37:34 <carter> commercial licenses tend to be safe too
23:37:41 <carter> :P
23:37:43 <kryft> Right. In this case it would just be research for now :)
23:37:48 <carter> np
23:38:13 <carter> hackage needs this
23:38:18 <adnap> "Safely" in the sense that you can use it in a closed-source project?
23:38:21 <carter> yes
23:38:37 <carter> granted, the other things i'll be making as commercial layers on top will be cooler
23:38:38 <adnap> 'Cause some people run companies with open-source software like Mozilla
23:38:53 <kryft> carter: Do the existing layers not work well enough, or is it just a license question?
23:38:54 <carter> adnap yes, but B2C and B2B work differently
23:39:03 <carter> kryft Hmatrix is GPL
23:39:10 <carter> and not aggressively maintained
23:39:23 <adnap> Is Lapack parallelized?
23:39:24 <carter> also overall i think Blas and Lapack aren't as awesome as people assume
23:39:26 <carter> yes
23:39:37 <carter> but theres lots of room for fancier /better tools
23:39:45 <carter> but since i'm wanting to beat the others
23:39:54 <Fuuzetsu> I'm using -fbreak-on-error and I want to trace ‘main’ while passing it some arguments. I can't use ‘:trace :main <args>’ though. Is this possible or will I have to do it differently?
23:39:55 <carter> having an open layer that i'll support is worth it
23:40:14 <adnap> carter: Have you seen http://www.cs.utexas.edu/~plapack/ ? What is the difference?
23:40:41 <kryft> carter: What's bad about blas/lapack?
23:40:48 <carter> adnap that one doesn't amtter
23:40:49 <kryft> carter: Or rather what could be improved
23:40:54 <carter> kryft lots of things
23:40:58 <adnap> 'Cause Lapack is already parallel?
23:41:06 <adnap> Did Lapack not used to be parallelized or something?
23:41:14 <carter> adnap no clue about historically
23:41:29 <carter> kryft its actually not extensible
23:41:43 <carter> and theres no story that also works for sparse
23:42:27 <carter> and a lot of the engineering is doing lots of tricks for memory locality
23:42:31 <carter> but not in an explicit way
23:42:37 <carter> LOTS of things
23:43:20 <adnap> I want a place to talk about software licensing...
23:43:25 <adnap> Anyone know a good channel?
23:43:27 <kryft> carter: Which blas are you talking about?
23:43:47 <carter> any of them
23:43:48 <kryft> carter: Ok
23:43:48 <carter> openblas is pretty fast on modern hardware
23:44:10 <carter> i've some untuned codes that are within 2x of DGEMM (dense mat mult) of Openblas
23:44:15 <carter> but are MUCH simpler
23:44:23 <carter> I think with some simple tuning i can match or beat it
23:44:27 <carter> with much simpler code
23:45:13 <carter> that wont be in my open stuff
23:45:13 <kryft> carter: Sounds good :)
23:45:41 <carter> but i kinda want that working so i can point at it to convince any biz to sign on as an early "enterprise customers"
23:45:43 <carter> adnap what about software licenses?
23:45:59 <adnap> Like, the ethics of them
23:46:15 <carter> same as IP for books
23:46:17 <carter> or mousetraps
23:46:22 <carter> well
23:46:27 <carter> lets look at this way
23:46:31 <adnap> If you license under BSD3, people can make closed source-software with your open-source software
23:46:31 <carter> if i wrote a really awesome novel
23:46:37 <carter> adnap thats ok
23:46:45 <adnap> Is closed-source software ethical?
23:46:45 <carter> they'd be shitty paying customers if they dont' talk with me after doing that
23:46:48 <carter> yes
23:47:00 <carter> adnap is having income rather than living wiht your parents ethical?
23:47:01 <adnap> What if it contains malware? The customer can't know
23:47:13 <carter> adnap they willl find out
23:47:18 <carter> and if you do that, you'll have no customers
23:47:21 <adnap> carter: Nice strawman
23:47:31 <carter> its a true one :)
23:47:48 <adnap> Actually, some people make a living on open-source software by accepting donations
23:47:59 <carter> adnap not donations
23:48:12 <carter> paying users or consulting work or being paid to do it as a day job
23:48:30 <adnap> Yes, *some* people
23:48:54 <adnap> So, your strawman is false
23:49:07 <carter> concrete examples or your claim i'm strawmaning is false :)
23:49:11 <carter> also its 2:40am
23:49:40 <adnap> http://sleepisdeath.net/
23:49:41 <carter> and i don't see how donations could cover living in NYC :)
23:49:47 <kryft> carter: If you're working in the realm of closed stuff I would expect that you need to beat intel MKL though
23:49:52 <adnap> This guy made like $60,000 off this game
23:49:56 <carter> kryft YUP
23:50:05 <carter> adnap thats onely one year of income
23:50:26 <carter> kryft Openblas DGEMM is within a tiny constant factor of MKL DGEMM :)
23:50:47 <kryft> carter: Of course that's still just for classical non-sparse matrices afaik (I don't know actually since I don't work with sparse matrices myself)
23:50:51 <adnap> carter: He's not living in his parents basement
23:50:58 <Fuuzetsu> :t const
23:50:58 <lambdabot> a -> b -> a
23:51:05 <carter> adnap he'd have to if he was living in nyc
23:51:09 <carter> kryft yeah
23:51:09 <kryft> carter: Sure, but there are other features than DGEMM too :)
23:51:15 <carter> kryft yes
23:51:26 <carter> kryft most algs are build wrt DGEMM and family
23:51:32 <adnap> And how would someone know if their software contained malware if it was closed-source>
23:51:50 <carter> adnap they'd know if they found mallwar
23:51:56 <carter> or just look at the assembly
23:52:01 <carter> you always have that
23:52:03 <adnap> Oh yeah, sure
23:52:11 <carter> adnap just becomes somethign is commercial doesn't mean you wont have source
23:52:19 <adnap> I agree with that
23:52:21 <carter> just that you''ll be very very sad if you leak it
23:52:28 <adnap> I am talking about whether closed-source software is ethical
23:52:33 <carter> it is
23:52:40 <carter> and i'm not talking abou thtat more :)
23:52:47 <carter> blog your thoughts!
23:52:52 <carter> irc isn't the right exposition on this
23:53:11 <carter> kryft youre absolutely right
23:53:16 <adnap> I asked for another channel initially. I just got carried away because you engaged me
23:53:18 <luite> but blogging is hard :(
23:53:28 <carter> sorry :)
23:53:42 <adnap> I agree that this is not the appropriate channel
23:54:03 <carter> np
23:54:33 <carter> kryft you are correct, theres some really cool things i've planned on the lin alg layer
23:54:59 <kryft> Speaking of blogging, what would you recommend for web programming in haskell? I don't know anything about web programming to begin with, but I'd like to learn that at some point and do it in haskell if possible
23:55:05 <carter> nor I!
23:55:12 <carter> snap has authors i like
23:55:16 <carter> and a simpler core
23:55:21 <carter> and less fragile build deps
23:55:24 <carter> hakyll is neat
23:55:29 <carter> good for static blogs
23:55:45 <kryft> Yeah I guess 'you' here was addressing the channel in general, including you, carter, of course :)
23:56:03 <biscarch> I'm working with snap right now
23:56:05 <carter> i really should go to sleep
23:56:09 <kryft> carter: Ok, I look forward to hearing about it :) Not that I'm an expert on BLAS in anyway
23:56:11 <biscarch> just to throw that out there for you
23:56:24 <carter> use snap if you want a dynamic site
23:56:33 <carter> use hakyll if you want a static personal site
23:56:40 <kryft> biscarch: How is it? Do you have prior experience with other frameworks in other languages?
23:57:11 <carter> kryft i did some work with snap having never done webdev before
23:57:11 <carter> took a week to get comfy, but then i really liked the core stuff
23:57:34 <carter> kryft i'm only doing my own blas stuff soon because i think theres room for better there that enables easier engineering on top of it
23:57:39 <biscarch> kryft: I like it. I've used quite a few frameworks in other languages, but I prefer the stripped down nature of snap when compared to rails/grails/Yesod
23:58:32 <carter> yesod has fragile build deps too
23:58:39 <kryft> biscarch: Stripped down sounds like it might be easier for a (web programming) beginner like myself? (Well haskell beginner too, but that's not really relevant probably)
23:58:50 <carter> i tried to do a sandboxed build with it yesod, and it conflicted with itself
23:59:03 * hackagebot hist-pl-transliter 0.1.1 - A simple EDSL for transliteration rules  http://hackage.haskell.org/package/hist-pl-transliter-0.1.1 (JakubWaszczuk)
23:59:03 <kryft> biscarch: I mean one reason why I've never gotten into it is that there's such a myriad of technologies and buzzwords
23:59:11 <carter> kryft stripped down as in "every feature" is a plugin or library you can choose to include
23:59:11 <b6> there's yesod-platform with fixed known-working versions.
23:59:13 <luite> carter: with yesod-platform?
23:59:14 <biscarch> kryft: yes. I'd recommend Snap over Yesod to a beginner.
23:59:20 <carter> wait thats a thing?
23:59:21 <kryft> biscarch: Great, thanks
23:59:27 <carter> hakyll might be even easier
23:59:29 <carter> even less!
23:59:38 <carter> just static site generation
23:59:39 <kryft> biscarch: I can always try both in the long run, but it's probably best to start with the simplest
23:59:50 <biscarch> carter: may be right. I haven't worked with hakyll.
