00:00:47 <zvrba> another newbie here. I started to read about haskell and got confused about more ways of doing the same thing. like, when to use let and when to use where?
00:00:53 <zRecursive> How to understand "orthogonal issues" ?
00:00:56 <zvrba> or, guards vs pattern matching ?
00:01:04 <zvrba> when defining functions
00:01:16 <zvrba> (I started to read haskell road to math, programming and logic)
00:01:21 <zRecursive> @wn orthogonal
00:01:23 <lambdabot> *** "orthogonal" wn "WordNet (r) 3.0 (2006)"
00:01:23 <lambdabot> orthogonal
00:01:23 <lambdabot>     adj 1: not pertinent to the matter under consideration; "an
00:01:23 <lambdabot>            issue extraneous to the debate"; "the price was
00:01:23 <lambdabot>            immaterial"; "mentioned several impertinent facts before
00:01:25 <lambdabot> [8 @more lines]
00:01:27 <Ghoul_> Pattern matching is not preffered
00:01:44 <Ghoul_> You write the name of the function may times
00:01:45 <johnw> zRecursive: they mean issues which don't depend on each other
00:01:47 <genisage> Do whatever you want as long as it works, worry about style later.
00:01:50 <mm_freak> zvrba: use whatever is most readable
00:02:07 <zvrba> ... for somebody's definition of 'readable'
00:02:13 <zebr> zvrba: yep, entirely subjective.
00:02:15 <johnw> I'm not sure it's the best use of the word orthogonal, but a lot of people use it to mean simply "unrelated"
00:02:29 <mm_freak> zvrba: unlike most other languages the coding guideline of haskell is, "write code that others can read"
00:02:30 <genisage> Actually, do what you want even if it doesn't work, that's a good way to learn too.
00:02:34 <zRecursive> johnw: thx
00:02:35 <zvrba> so things not immediatelly obvious: do both where/let clauses define mutually recursive names?
00:02:58 <zvrba> genisage: :)
00:03:10 <zebr> zvrba: yes
00:03:38 <mm_freak> zvrba: and don't expect to be able to find the most elegant definition of your algorithm right away…  even after many years i still discover more elegant ways to express certain things =)
00:03:40 <Ghoul_> Let can be put closer to what its relevant to
00:03:52 <zvrba> then there are compiler errors... I forgot to put = after 'otherwise' and got an error about possibly wrong indentation. like wtf?!
00:03:59 <zvrba> mm_freak: :)
00:04:19 <zvrba> question being: is it 'ok' to use braced syntax with semicolons?
00:04:20 <adnap> How can I use the modules from the latest source of GHC the way I would use "-package ghc" with an intalled version (via my package manager) of GHC?
00:04:40 <Ghoul_> The libraries use that syntax
00:04:47 <shachaf> I think you need to be compiling your program with the same version of GHC.
00:04:49 <zvrba> Ghoul_: which libraries?
00:04:54 <Ghoul_> Or many do, east least
00:04:59 <zvrba> ok :)
00:05:11 <adnap> shachaf: Oh, I see
00:05:31 <adnap> shachaf: So I would just build the latest GHC, and then compile my program with this GHC specifying "-package ghc"
00:05:40 <zvrba> mm_freak: so, what to do if I think that I 'need' mutation?
00:05:50 <zebr> zvrba: bear in mind let/where are not *mutually* mutually recursive, though. (let a = b in b where b = a) = error.
00:06:07 <Ghoul_> I think braces plus semi colons is kind of visually heavy when it does not need to be
00:06:50 <mm_freak> zvrba: the first step is to master recursion, the second step is to get rid of it =)
00:06:59 <zvrba> i grok recursion :P
00:07:15 <Lethalman> mm_freak, ha! that should go in the weekly report ;)
00:08:03 <zvrba> mm_freak: i have dabbled in FP before (SML, Ocaml, LISP..)
00:08:08 <Ghoul_> forever a = let b = a >> b in b
00:08:11 <Ghoul_> I think
00:08:24 <Ghoul_> Always thought that was cool
00:08:39 <mm_freak> zvrba: to master recursion you need to master it in a non-strict language like haskell
00:08:51 <Walther> mm_freak: I've kinda realized that; first you realize how much faster/simpler things are to code when utilizing recursion, and then you realize that the amount of calls increases in a worrying fashion and iterativeness starts to win
00:09:08 <mm_freak> zvrba: the easiest way to master haskell recursion is not to think of it as recursion, but as folds and unfolds of data structures
00:09:22 <zvrba> what is fold and unfold?
00:09:34 <mm_freak> Walther: no, you misunderstood "get rid of recursion"
00:09:49 <mm_freak> Walther: you get rid of explicit recursion and use well-defined combinators instead
00:10:25 <mm_freak> like foldl' (+) 0 instead of an explicitly-recursing 'sum'
00:10:40 <Walther> mm_freak: nod
00:10:44 <mm_freak> zvrba: generic constructors and destructors of data structures
00:11:03 <Walther> I still need to look more into folds, still don't quite get them
00:11:03 <zvrba> 'destructor' as in 'destructuring' (for pattern matching)?
00:11:15 <mm_freak> zvrba: yes
00:11:41 <mm_freak> zvrba: an interesting fold is 'maybe' for Maybe
00:11:43 <mm_freak> :t maybe
00:11:44 <lambdabot> b -> (a -> b) -> Maybe a -> b
00:11:49 <mm_freak> or 'either' for Either
00:11:51 <mm_freak> :t either
00:11:52 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
00:12:11 <mm_freak> you get similar combinators for (i think) all algebraic data structures
00:12:13 <johnw> Walther: how recursion is represented by a compiler operationally is not always as inefficient as you might think -- there are times it will be rendered as iteration, in fact! -- it's better to think of how best to express a problem's solution, than trying to out-think the compiler's optimizer.  This is *especially* true with a language like Haskell, and is something I've had to unlearned coming from C++
00:13:29 <zvrba> mm_freak: so how do you construct/pattern match against a data structure like a directed graph with unbounded out-degree of a node? (I know any acyclic graph can be represented as a binary tree, but...)
00:13:29 <Walther> johnw: mmh, with super-smart people making the compiler, it might be better for us only-average-smart people to "just solve the problem" instead of trying awfully hard to pre-optimize
00:13:45 <Walther> -> the solution might get to be fast
00:14:04 <johnw> a prime example: just because you see a function call being evaluated in the Haskell source, does not at all mean that an assembly-level function will be called at runtime
00:14:14 <mm_freak> zvrba: depends on what i want to do
00:14:32 <Walther> Oh hey, one thing that might be relevant to my next project - any nice graphical libraries for / to use with Haskell?
00:14:48 <mm_freak> Walther: it's not about super-smart compilers…  it's about a domain-specific compilation model
00:14:50 <Walther> Both as in making a gui (qt?) and as in drawing 2D / 3D
00:15:00 <zebr> Ghoul_: forever = fix . (>>)
00:15:00 <zebr> :)
00:15:12 <mm_freak> Walther: just to give you a very intriguing example:  tail call optimization isn't an optimization in haskell =)
00:15:19 <Walther> mm_freak: super-smart people making the compilers, but yeah.
00:15:31 <Walther> Lots to learn :)
00:15:39 <KoF> Graphical libraries for Haskell aren't great, as I recall.
00:15:49 <KoF> I had to try to get some working at the end of fall semester.
00:15:59 <mm_freak> another intriguing example:  when you write "f(); g();" in C, the caller calls f, f returns, the caller calls g, g returns
00:16:02 <taylorgb> I'm not sure that I've seen any great graphics libraries in Haskell, certainly none such that it would make so much sense over making the GUI natively rather than using the bindings.
00:16:05 <mm_freak> in haskell f jumps to g directly
00:16:15 <taylorgb> (if you're familiar with both languages)
00:16:55 <mm_freak> KoF: graphical libraries are great…  GUI libraries are about as great as their corresponding C/C++ interface
00:17:07 <mm_freak> examples of the former:  diagrams, gloss
00:18:02 <Sonarpulse> go to #haskell-game for graphical advice
00:18:13 <Sonarpulse> GUIs on the other hand... somebody needs to revolutionize that
00:18:16 <Zeev> when I use graphics libraries with c-bindings does it mean I have to include .dll of that c-library in my distribution (or that compiles to a single file?
00:18:32 <Sonarpulse> Zeev: there is always static linking...
00:18:33 <Zeev> for example sdl bindings
00:18:44 <Sonarpulse> not sure how it's done in practice
00:18:53 <johnw> Zeev: usually cabal will try to link with that library on the user's system, this is what text-icu does, for example
00:19:01 <johnw> it looks for -licuuc
00:19:13 <Zeev> johnw: ok.
00:22:01 <zvrba> mm_freak: how to cope with the size of the standard library?
00:22:10 <zvrba> the reference is intimidating.
00:22:15 <zvrba> (by its sheer size)
00:22:32 <mm_freak> zvrba: easy:  don't
00:22:37 <zvrba> ?
00:22:42 <mm_freak> you learn the base library along the way…  until then you reinvent stuff
00:22:47 <zvrba> :)
00:22:55 <zvrba> which leads me to the next question :-)
00:22:58 <mm_freak> reinventing in haskell is much more pleasant than in other languages, and you actually learn something
00:23:03 <mm_freak> so it's a valuable exercise
00:23:10 <zvrba> how do you 'pattern match' the 'reinvented wheels' against something already existing?
00:23:28 <mm_freak> mainly by recognizing or looking up types
00:23:35 <mm_freak> sometimes by hlint, if you use it
00:23:36 <zvrba> like, you notice a pattern in your code and want to 'encapsulate it' into some abstraction..
00:24:04 <mm_freak> often when you think that the functionality you want doesn't exist, it's likely because your type is too special =)
00:24:09 <zvrba> ('a pattern' occurring multiple times, just in different 'instantiations')
00:24:45 <zvrba> what is 'functionality' in Haskell? it's a weird word to use for a language where operational thinking doesn't work...
00:25:19 <mm_freak> well, a type or a value =)
00:25:24 <mm_freak> sometimes an instance
00:25:27 <mm_freak> that's pretty much it
00:25:39 <Ghoul_> If you have a monad transformer box M
00:26:03 <Ghoul_> With a reference to M2 would that make it a pointer to M2
00:26:11 <zvrba> stop there.
00:26:18 <zvrba> i don't know what's a monad transformer.
00:26:19 <mm_freak> Ghoul_: what?
00:26:29 <johnw> Ghoul_: I didn't quite understand either
00:26:41 <johnw> what do you mean by "box"?
00:26:42 <mm_freak> zvrba: don't worry about them
00:26:46 <Ghoul_> Like I had a thought
00:26:51 <zvrba> mm_freak: ok
00:26:53 <Ghoul_> MT M right
00:27:13 <Ghoul_> So MT is a data structure holding some stuff plus a type M?
00:27:21 <zvrba> mm_freak: so is 'haskell road to math,...' OK book or should I switch to 'learn you a haskell' and 'real-world HP' ?
00:27:25 <mm_freak> Ghoul_: you're mixing up type level with value level
00:27:52 <johnw> zvrba: learn you a haskell is fun to read, but if it's not doing it for you, try the others
00:27:52 <mm_freak> zvrba: i learned haskell the hard way by reading "the haskell road to logic"
00:28:03 <zvrba> mm_freak: I have two goals.. 'practice' FP on pure algorithmic problems, like for competitions, and using it in practice for 'scripting' stuff
00:28:03 <Ghoul_> Hmm is it possible to explain that?
00:28:04 <mm_freak> zvrba: LYAH and RWH are newer and probably easier to read
00:28:14 <mm_freak> Ghoul_: explain with a real example
00:28:25 <Ghoul_> StateT Reader
00:28:29 <zvrba> mm_freak: what is hard about 'haskell road to logic' ?
00:28:36 <mm_freak> Ghoul_: that's a kind error, but i get it =)
00:28:51 <mm_freak> Ghoul_: so what's your question?
00:28:55 <zvrba> i'm familiar with abstract math/logic from before, so THAT is not scary :)
00:29:01 <Ghoul_> StateT has a state, some housekeeping and a pointer to reader, no?
00:29:39 <mm_freak> Ghoul_: a value of type StateT S (Reader E) A is basically a function of type S -> E -> (A, S)
00:29:43 <mm_freak> that's it
00:30:13 <mm_freak> zvrba: the hard part is that it doesn't necessarily teach you programming =)
00:30:13 <zvrba> ok
00:30:42 <zvrba> i guess i'll continue with it
00:31:48 <mm_freak> zvrba: it's a good read, but to get into practical programming you should also look into the other two
00:32:01 <zvrba> ok
00:32:36 <zvrba> mm_freak: so, why did you start learning Haskell? and did you look into 'alternative' paradigms like rewriting logic (Maude or Pure)?
00:32:51 <mm_freak> zvrba: to get stuff done
00:33:01 <zvrba> what did you code in before?
00:33:06 <Ghoul_> So why can't everything be unpacked by default
00:33:17 <mm_freak> mainly C++ and PHP, depending on the application
00:33:26 <Ghoul_> Why box things with indirection (?)
00:33:28 <mm_freak> Ghoul_: because not everything is strict
00:33:41 <mm_freak> Ghoul_: you can unbox strict fields automatically:  -funbox-strict-fields
00:33:52 <Ghoul_> Oh that's handy
00:34:10 <mm_freak> Ghoul_: but if you now start making everything strict, you're doing it wrong =)
00:34:17 <zvrba> mm_freak: hah, I do C++ for living :)
00:35:18 <mm_freak> Ghoul_: strict fields are so seldomly necessary that it's probably a bad idea to use that compiler flag
00:35:28 <Ghoul_> Of it does not need to be lazy what is the disadvantage
00:36:11 <mm_freak> Ghoul_: nothing needs to be lazy, but in haskell we tend to make everything lazy and only certain low level data structures strict
00:36:31 <mm_freak> Ghoul_: non-strictness has so many advantages that we start non-strict by default
00:36:44 <Ghoul_> Hmm
00:36:50 <zvrba> mm_freak: hmm, another question. why not Scala? (I'm trying to decide between diving into the one or the other)
00:37:00 <mm_freak> Ghoul_: consider this list type:  data List a = Nil | Cons !a !(List a)
00:37:04 <Ghoul_> It's a careful art then to pick what should be strict
00:37:42 <mm_freak> Ghoul_: even if all your lists are finite you are giving up a major feature of haskell lists:  that they don't need to be stored in their entirety
00:38:02 <mm_freak> that way you force very list to be constructed in memory
00:38:13 <mm_freak> often when using regular haskell lists, they never make it into RAM at all
00:38:35 <mm_freak> in other words:  if you don't know whether to be strict, be non-strict
00:39:03 <mm_freak> zvrba: at the time scala wasn't on the horizon, and even today i'd never switch to scala
00:39:10 <Ghoul_> But for ints and stuff its probably better to?
00:40:04 <mm_freak> Ghoul_: why?
00:40:36 <Ghoul_> Boxing numbers sounds unnecessarily expensive given unexceptional circumstances
00:40:49 <Ghoul_> The key word being unexceptional
00:40:59 <mm_freak> Ghoul_: you're making the assumption that everything that is nonstrict is boxed =)
00:41:22 <Ralith> Ghoul_: if you never calculate something, it's not exactly boxed
00:41:45 <zvrba> mm_freak: hmm, why not?
00:42:00 <mm_freak> Ghoul_: the main point of nonstrict semantics is that you don't need a rigid memory representation at all
00:42:12 <mm_freak> chances are your nonstrict data structures never make it into RAM at all
00:42:17 <ousado> zvrba: I'd add ocaml as a candidate
00:42:40 <Ghoul_> Um ok
00:42:41 <zvrba> ousado: i have used it for a month or two and solved recreational problems with it.
00:42:55 <mm_freak> Ghoul_: consider this:
00:43:05 <zvrba> ousado: I disliked heavily the cluttered syntax (let .. in let .. in ...) and stdlib was quite unintuitive
00:43:17 <zvrba> i.e. unintuitive interface (like, the order of arguments)
00:43:30 <ousado> zvrba: yes, there are a few competing std libs
00:43:34 <mm_freak> > sum . take 1000 . iterate (\x -> mod (x^2 + 1) 65537) $ 1
00:43:35 <lambdabot>   34887954
00:43:44 <zvrba> ousado: I tried SML to and liked it much more
00:43:49 <zvrba> ousado: oh, links?
00:43:59 <mm_freak> Ghoul_: notice that i'm building an infinite list, taking the first 1000 elements and summing them
00:44:14 <ousado> zvrba: mainly janestreet core
00:44:15 <mm_freak> Ghoul_: this list is only conceptual…  when compiled you likely don't find that list in memory at all
00:44:23 <zvrba> ousado: ok, thanks.
00:44:25 <Ghoul_> O..o
00:44:26 <Ralith> mm_freak: sort is a more compelling example
00:44:28 <Ghoul_> Really
00:44:42 <mm_freak> Ghoul_: the compiled code resembles a tight C loop you would have written in C
00:44:52 <Ghoul_> I didn't think it worked to that extent at all
00:45:11 <ousado> zvrba: https://github.com/janestreet/core
00:45:15 <mm_freak> Ralith: sort needs in-memory lists, though
00:45:16 <Ghoul_> Use rem not mod BTW :)
00:45:20 <zvrba> ousado: jupp, found it.
00:45:23 <Ghoul_> Beats C
00:45:31 <mm_freak> Ghoul_: in that case i could use rem, but rem and mod are not the same thing =)
00:45:33 <Ralith> mm_freak: true, I guess save it for the cpu example
00:45:53 <Ghoul_> Yeah mod allows negatives?
00:45:58 <mm_freak> both do
00:46:06 <mm_freak> but mod always gives you the canonical representant
00:46:09 <mm_freak> > mod (-3) 5
00:46:10 <lambdabot>   2
00:46:15 <mm_freak> > rem (-3) 5
00:46:18 <lambdabot>   -3
00:46:47 <mm_freak> i.e. (`rem` 5) can have 9 different results, while (`mod` 5) only has 5
00:58:19 <eikke> say I have data T = A | B, data S (t :: T) where S :: S 'A, and s = S; is there a way to write a function f so (f s) == A ?
00:58:35 <eikke> (without writing somethign which pattern-matches on the S constructors)
00:59:27 <Fuuzetsu> What's the point of denying yourself pattern matching?
01:00:20 <eikke> Fuuzetsu: say the S constructors are hidden by some module, all I know is I get values of type S t where t is of kind T (so it's either 'A or 'B)
01:01:27 <eikke> when using type-variables of kind Nat, one can retrieve the value-level representation using sing & fromSing etc, but I'm not sure how that can be easily generalized for other kinds as well
01:03:09 <Fuuzetsu> I don't think it's easily generalisable, at least not in Haskell. Don't quote me on that though.
01:05:57 <KoF> Hm. Is there anything in particular that could be used for just doing a set of exercises to get me used to Haskell?
01:06:24 <Walther> real-life haskell was a tutorialbook like that iirc
01:06:28 <Fuuzetsu> 99 Haskell problems?
01:06:30 <KoF> ...Wait, derp, of course. I can just work on Project Euler.
01:06:31 <blackdog> KoF: euler problems are not bad
01:06:37 <Walther> and yeah, euler
01:06:39 <Fuuzetsu> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
01:06:42 <blackdog> heh. of course, it won't tell yuo anything about IO etc
01:06:46 <Fuuzetsu> Euler problems are just number theory.
01:07:08 <Zouppen> KoF: for absolute beginners i would recommend http://tryhaskell.org/
01:08:08 <KoF> Oo, that could be nice.
01:08:19 <KoF> I'm not an absolute beginner, but I don't remember most of the syntax, so that should help me.
01:09:14 <Zouppen> yeah. the platform they use on tryhaskell.org is quite good but the tutorial is a bit too short
01:13:04 <KoF> ...Gah. I forgot how much /typing/ coding is. :P
01:13:11 <KoF> I've been doing theory for weeks!
01:16:06 <Zouppen> mind the keyboard while doing strong typing
01:16:10 <Ralith> if you find yourself doing an unreasonable amount of typing, you're probably doing something wrong
01:16:58 <KoF> Oh, this is nothing. I have, in fact, written thousand-line programs before. Which isn't much itself, I know, but it's a lot compared to this.
01:17:10 <KoF> It's just me getting used to coding again. :P
01:18:33 <shachaf> Ralith: If you find yourself doing an unreasonable amount of typing, stop using Idris.
01:18:49 * Ralith places a bowl of stew on shachaf's head
01:20:06 <dario> Zouppen: :>
01:33:45 <merijn> Morning, my lambda loving friends
01:33:51 <no-n> \
01:42:06 <KoF> What's the mod operator in Haskell?
01:42:19 <shachaf> mod
01:42:21 <merijn> > 6 `mod` 2 -- surprise!
01:42:23 <lambdabot>   0
01:42:47 <shachaf> What's the mod operator in C? It doesn't have one. surprise!
01:42:52 <merijn> See also
01:42:57 <merijn> > 6 `rem` 4
01:42:59 <lambdabot>   2
01:43:19 <merijn> KoF: The difference between mod and rem is how they handle negative numbers
01:44:12 <KoF> Pretty sure C has one. Or did % get introduced in C++?
01:44:24 <pjdelport> shachaf: C's mod operator runs on optimism
01:44:28 <pjdelport> it works as long as you stay positive
01:44:32 <Ralith> haha
01:44:38 <KoF> ...oh, is mod in Haskell the kind that doesn't allow negatives?
01:44:53 <Ralith> > -6 `mod` 4
01:44:55 <lambdabot>   -2
01:45:20 <ThatOtherPerson> shachaf: %
01:45:27 <merijn> ThatOtherPerson: *bzzt*
01:45:50 <KoF> I remember having /so many problems/ with that in one thing last semester. The book's pseudocode for something we were supposed to implement was the way mod woks in math, and C++ had a different method of doing mod... screwed so many people over.
01:45:57 <merijn> ThatOtherPerson: % doesn't behave like module with negative numbers
01:46:06 <Dodek> ah i hate it when mod function returns negative values for negative numbers and positive modulus
01:46:47 <ThatOtherPerson> merijn: hm, that's interesting... there's a program I've been using that uses % for negative numbers... what should I use instead?
01:46:55 <KoF> Bleh. Is || still or?
01:46:56 <ThatOtherPerson> *working on
01:46:57 <neutrino_> how do you define negative modulus
01:47:10 <neutrino_> KoF: well, C doesn't have booleans
01:47:21 <merijn> KoF: Yes
01:47:26 <merijn> KoF: and && is still and
01:47:27 <KoF> True... I'd forgotten that. Haven't used C in a year.
01:47:31 <KoF> okay
01:47:40 <merijn> % is used for rationals, I believe
01:47:43 <merijn> > 3 % 5
01:47:44 <lambdabot>   Not in scope: `%'
01:47:45 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
01:47:48 <merijn> > 3 R.% 5
01:47:50 <lambdabot>   3 % 5
01:48:00 <neutrino_> yes
01:48:04 <merijn> > 3 R.% 5 + 2 R.% 5
01:48:05 <lambdabot>   1 % 1
01:48:49 <KoF> Gyeeh.
01:50:08 <Dodek> neutrino_: C has booleans for almost 15 years
01:50:25 <Bor0> is there a more better way to achieve this? http://hpaste.org/89386
01:50:47 <KoF> Okay. So. I have let beep x = foldr (+) 0 (filter (_ `mod` 3 == 0 || _ `mod` 5 == 0) x)
01:50:48 <KoF> To add up everything divisible by 3 or 5.
01:50:48 <KoF> What should I be using instead of _?
01:51:01 <mauke> :t findIndex
01:51:02 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
01:51:11 <mauke> :t elemIndex
01:51:13 <lambdabot> Eq a => a -> [a] -> Maybe Int
01:51:21 <merijn> KoF: "\x -> x `mod` 3 == 0 || x `mod` 5 == 0"
01:52:24 <ThatOtherPerson> Dodek: C doesn't have "real" booleans, it's just a typedef alias for int
01:52:31 <ThatOtherPerson> in most implementations, I believe
01:53:05 <mauke> _Bool is a real type
01:53:32 <Ralith> ah, but how many values does it have?
01:53:37 <pjdelport> ThatOtherPerson: something like http://stackoverflow.com/a/828238/444705
01:53:51 <pjdelport> there are probably also implementations in various C base libraries
01:54:35 <ThatOtherPerson> pjdelport: Thanks!
01:55:19 <merijn> @pl \x -> x `mod` 3 == 0 || x `mod` 5 == 0
01:55:19 <lambdabot> ap ((||) . (0 ==) . (`mod` 3)) ((0 ==) . (`mod` 5))
01:55:23 <merijn> pfft
01:55:40 <merijn> There should be a nice reader monad way to get that, shouldn't there? :\
01:56:37 <Ralith> or maybe the function monad
01:56:43 <neutrino_> Dodek: ITYM C99
01:56:49 <Ralith> wait, that's the same thing isn't it
01:57:16 <Ralith> er, no
01:57:16 * Ralith blames 2am
01:57:17 <neutrino_> mauke: when did C get real booleans?
01:57:28 <mauke> never/1999
01:57:33 <neutrino_> k
01:57:36 <mauke> :t liftA2 (||) ($ 3) ($ 5) . (\x y -> x `mod` y == 0)
01:57:37 <lambdabot> Integral a => a -> Bool
01:57:42 <mauke> @pl liftA2 (||) ($ 3) ($ 5) . (\x y -> x `mod` y == 0)
01:57:42 <lambdabot> liftA2 (||) ($ 3) ($ 5) . flip flip 0 . ((==) .) . mod
01:57:59 <neutrino_> i wish you could lift code
01:58:05 <neutrino_> something like pl/unpl
01:58:13 <neutrino_> that would be a whole new level of clusterfuck
02:00:37 <quchen> ThatOtherPerson: div/mod are the more mathematical functions, while quot/rem behave C-like.  More precisely, div rounds towards -infinity, quot towards 0; the result of mod x <positive> is always nonnegative. For positive arguments, there's no difference between the results of the two.
02:00:42 <quchen>  > map (\f -> f (-5) 2) [div, mod, quot, rem]
02:00:48 <quchen> > map (\f -> f (-5) 2) [div, mod, quot, rem]
02:00:50 <lambdabot>   [-3,1,-2,-1]
02:01:01 <ptek> Did anyone of you guys use pbkdf2 library? What I don't understand is why does it give me the same hash for a password with different salts. Doesn't this make the salt useless?
02:01:33 <ptek> I have to admit - I don't have very good understanding of this
02:01:52 <pjdelport> ptek: the hash should be different, with a different salt
02:02:45 <ptek> pjdelport, ok - let me see if I don't do something stupid
02:03:10 <pjdelport> either it's not being passed in right, or you managed to accidentally find a hash collision (extremely improbable, but possible in theory)
02:03:51 <merijn> f the latter, buy a lottery ticket, since you're defying the universe's odds anyway :p
02:04:39 <quchen> merijn: Reminds me of the joke where a statistician brings a bomb to his flight.
02:04:59 <neutrino_> quchen: what joke is that
02:05:20 <quchen> "It's for safety, what are the odds there are two bombs on the plane"
02:05:32 <no-n> heh :)
02:05:39 <alpounet> Walther, try gloss :)
02:06:02 <merijn> Right, any vim users wanna alpha test my (still horribly broken) less-sucky haskell auto-indent? :p
02:06:24 <neutrino_> quchen: not a very good statistician then!
02:06:37 <flux> quchen, well, not such a bad idea I think in principle, it is similar to the software testing technique where you inject bugs and see how many get found :)
02:06:44 <neutrino_> merijn: what was broken in haskell auto-indent before that?
02:06:59 <merijn> neutrino_: I dunno which one you were using, but the one I was using was awful
02:07:11 <quchen> flux: That's a developer testing technique.
02:07:22 <pjdelport> ptek: hpaste?
02:07:25 <ptek> pjdelport, this is my ghci session
02:07:30 <ptek> pjdelport https://gist.github.com/ptek/83ee030b87065954d174
02:07:51 <pjdelport> a tester meta-testing technique
02:07:52 <merijn> I've got it so it auto indents data declarations to line up with the = sign and if you type -> or => on a new line it will indent to line up with the :: above it
02:07:59 <Dodek> neutrino_: yes, C99 has booleans, as does C11
02:08:54 <pjdelport> ptek: oh, try with a different prefix than "salty"?
02:09:14 <neutrino_> Dodek: see above.
02:09:16 <pjdelport> i can't remember the size of the salt, but it's fixed or capped, if i'm not mistaken
02:09:23 <neutrino_> Dodek: besides, i only trust mauke with C.
02:09:27 <merijn> neutrino_: There's a bunch of things I still need to implement, but it's coming along nicely. Out of curiosity which indent are you using for Haskell? Something you installed yourself or just vim's default autoindent?
02:09:28 <Dodek> neutrino_: see what?
02:09:34 <pjdelport> (Salt (toOctets salt)) might just be taking a fixed prefix of it
02:09:41 <neutrino_> 11:01 < ThatOtherPerson> Dodek: C doesn't have "real" booleans, it's just a typedef alias for int
02:09:54 <Dodek> this is bullshit, C has real booleans.
02:10:02 <Fuuzetsu> here we go
02:10:09 <neutrino_> merijn: sorry, i was going to link you up but got distracted
02:10:13 <merijn> This topic sounds like -blah
02:10:18 <merijn> (the C stuff)
02:10:30 <supki> merijn: link?
02:10:41 <Fuuzetsu> #haskell-blah ?
02:10:54 <neutrino_> merijn: no can do, i don't visit abusive irc channels
02:10:56 <Walther> alpounet: huh?
02:11:00 <neutrino_> i'll just stop talking about it instead
02:11:08 <nan`> wait when/how is noMsg used in Control.Monad.Error
02:11:36 <ptek> pjdelport, I have updated the gist, still the same :)
02:13:27 <merijn> supki: https://bitbucket.org/merijnv/haskellfoldindent or https://github.com/merijn/haskellFoldIndent
02:13:49 <Dodek> merijn: yeah, this is stupid, but people perpetuate misinformation.
02:14:12 <merijn> supki: Things I'm working on right now: let/in, where, do that isn't followed by EOL, comments and open ({[ blocks
02:14:45 <pjdelport> ptek: hmm, ok
02:15:38 <merijn> supki: If you have feedback on style (i.e. it should indent differently) or missing things, lemme know. I'm trying to be rigorous in testing all cases, but haskell's syntax flexibility allows for a billion edge cases >.>
02:16:54 <pjdelport> ptek: library bug? i think your expectation is correct
02:24:06 <dax> @undo do { x <- getLine; print x } ==> getLine >>= \ x -> print x
02:24:06 <lambdabot> getLine >>= \ x -> print x ==> getLine >>= \ x -> print x
02:25:20 <Guest99633> @undo do {when b m; return b}
02:25:20 <lambdabot> when b m >> return b
02:26:08 <shachaf> @undo do {a; b; c}
02:26:08 <lambdabot> a >> b >> c
02:26:24 <shachaf> Should be a >> (b >> c) :-(
02:26:49 <merijn> shachaf: Word.
02:29:07 <gds> Does anyone here use cmdArgs? I'm trying to figure out how to get one of my switches to take a variable number of arguments....
02:30:04 <pjdelport> shachaf: why that associativity?
02:30:06 <gds> I'd like to be able to call my program with "progName commandName --switch1 switch1Arg --files path/*"
02:30:49 <gds> I currently only know how to make it possible to call my program with "progName commandName --switch1 switch1Arg --file path/file1 --file path/file2 ..."
02:32:30 <mauke> gds: that sounds like a bad idea
02:32:43 <mauke> gds: how do you know where the --files arguments stop?
02:33:27 <gds> mauke: I'm writing a script which populates a database with paths to files. I'd like the interface to be similar to "ls"
02:33:42 <gds> You know how you do things like "ls -l path/*"
02:33:52 <mauke> yes, but -l is a boolean flag
02:33:55 <mauke> it takes no arguments
02:34:02 <gds> Great - I'd be happy with that.
02:34:10 <mauke> well, do that then
02:34:12 <gds> How?
02:34:51 <gds> So, I know how to write a program that just takes a uniform list of arguments...
02:35:07 <gds> And I know how to use cmdArgs to write a program that has switches.
02:35:18 <gds> What I'd like now is some switches, and then "the rest".
02:35:58 <gds> It may be that cmdArgs doesn't provide this, in which case I'm happy to step back and investigate getOpts and other options....
02:36:11 <mauke> I don't know but the manual at least mentions "non-flag arguments"
02:37:27 <gds> Ah - "&= args" - thanks - I'll play with that!
02:41:55 <ptek> pjdelport, thanks! It does look like a library bug. I have opened a github issue
02:49:48 <ThatOtherPerson> What does the escape \& mean?
02:50:59 <mikeplus64> > '\&'
02:51:13 <ThatOtherPerson> Also, where's lambdabot?
02:51:13 <mikeplus64> rip lambdabot
02:51:20 <neutrino_> gds: i believe cmdargs allows you to get the args that it hasn't processed.
02:51:52 <mikeplus64> ThatOtherPerson: nothing, it seems
02:51:57 <mikeplus64> <interactive>:3:3:
02:51:59 <mikeplus64>     lexical error in string/character literal at character '&'
02:52:15 <ThatOtherPerson> mikeplus64: It's only allowed in strings, not characters
02:52:47 <mikeplus64> weird
02:52:58 <gds> neutrino_: Thanks - mauke pointed me at the "&= args" annotation, which seems to be doing the trick.
02:53:40 <mikeplus64> ThatOtherPerson: it does seem to be nothing - try length "\&\&\&"
02:54:03 <ThatOtherPerson> Weird... what's the point of that?
02:54:07 <mikeplus64> no idea
02:55:29 <mauke> > "\SO" ++ "H"
02:56:34 <Fuuzetsu> > 1
02:56:38 <Fuuzetsu> < 1
02:56:44 <Fuuzetsu> no bots whatsoever?
02:57:35 <neutrino_> gds: there you go
02:57:56 <gds> neutrino_: Yes - thanks :)
02:58:27 <neutrino_> np yw
03:06:06 <dibblego> where might I find the IdT transformer? I forget which package it is in
03:06:34 <mauke> transformers
03:07:22 <schoppenhauer> is there a way to tell haskell to only accept exhaustive pattern matches (or at least warn if some pattern match is non-exhaustive)?
03:08:46 <merijn> schoppenhauer: Warning for non-exhaustive pattern matches should be default, I think?
03:08:52 <merijn> Or maybe it's -Wall
03:09:30 <dario> -Wall
03:09:49 <aleator_> Anyone know if this is a known ghc bug? http://hpaste.org/89404
03:10:01 <schoppenhauer> dario: can I put this into my module file, too?
03:10:11 <schoppenhauer> dario: because I use the haskell emacs mode
03:10:36 <merijn> schoppenhauer: {-# OPTIONS_GHC -Wall #-}
03:11:52 <kennycason> lets say I have a record, data Node = Node { value::Double }, and later is a data Layer { nodes :: [Node] }, given a layer, and new values  [Double], where length of the values [Double] == number of nodes in a layer, what is the best way to update the layer's node's values given a [Double] input
03:12:20 <kennycason> i.e updateLayersValues :: Layer -> [Double] -> Layer
03:12:57 <schoppenhauer> merijn: thx
03:13:21 <kennycason> I feel like I want to map each Node in the layer AND each value in the [Double] to a function that returns and updated node, but i've been trying things and googling for hours heh, sorry new to haskell
03:13:40 <schoppenhauer> ok, now I get a lot of errors because of non-used variables. that is usually a good thing, but can I declare a variable as non-used, even though I declare it [like (declare (ignore ...)) in lisp]?
03:13:48 <schoppenhauer> this formally of course makes no sense
03:13:53 <merijn> schoppenhauer: _
03:14:00 <schoppenhauer> merijn: no, _ is not what I want
03:14:07 <schoppenhauer> merijn: i want the variable named.
03:14:18 <merijn> why do you want a named variable if you don't use it?
03:14:36 <kennycason> in an IP, it's like for(int i = 0; i < nodes.length; i++) {nodes[i].value(newValues[i]); }
03:14:40 <schoppenhauer> merijn: I am writing a part of a parser, which I will maybe extend later. and just for documentation, I want to name them.
03:14:51 <merijn> schoppenhauer: Maybe prefix with _ works?
03:15:01 <merijn> You'd have to try
03:15:37 <schoppenhauer> merijn: yep, worx, thx
03:27:41 <kennycason> ah nevermind
03:27:43 <kennycason> think i got it
03:28:11 <merijn> Code sample request: Different ways you write data definitions using record syntax
03:29:28 * hackagebot monadloc-pp 0.2 - A preprocessor for generating monadic call traces  http://hackage.haskell.org/package/monadloc-pp-0.2 (PepeIborra)
03:31:22 <supki> merijn: thanks, I think I'll have a chance to try to use it later today
03:33:10 <merijn> supki: Well, I just fixed the issue with nested if expressions and do blocks that aren't immediately followed by newline. I'll update it in a few mins
03:44:29 * hackagebot monadloc 0.7.1 - A class for monads which can keep a monadic call trace  http://hackage.haskell.org/package/monadloc-0.7.1 (PepeIborra)
03:44:31 * hackagebot monadloc-pp 0.2.1 - A preprocessor for generating monadic call traces  http://hackage.haskell.org/package/monadloc-pp-0.2.1 (PepeIborra)
03:46:39 <kartlos> hey guys, does anyone know of a module that can generate bitmap images? (format doesn't matter) I've tried Graphics.GD but it won't install on OS X..
03:52:27 <notdan> kartlos: what about Codec.BMP?
03:52:31 <notdan> http://hackage.haskell.org/package/bmp
03:53:12 <Darkproger> hi guys, is it possible to use haskell like perl? i.e. smth like ghc -mNetwork.HTTP.Base 'getArgs >>= return urlEncode.head' ?
03:53:14 <sopvop> kartios: You you need to do some raster image manipulation, or just encode?
03:53:38 <kartlos> notdan: thanks
03:53:50 <kartlos> sopvop: I want to generate raster images
03:54:10 <merijn> Darkproger: Maybe using runhaskell?
03:54:37 <merijn> Darkproger: I know that you can just write haskell as script using "#!/usr/bin/env runhaskell" as first line
03:55:23 <Darkproger> merijn: it would be nice to have some wrapper which automatically generates a module header and assumes string i/o etc
03:55:41 <sopvop> kartios: There are cairo bindings also diagrams can generate PNGs I think.
03:55:41 <Darkproger> i've seen eddie but it can be inconvenient sometimes (i.e. when bytestring hell happens)
03:56:46 <hpc> Darkproger: ghc -e 'putStrLn "doop"'
03:57:29 <Darkproger> hpc: try ghc -e 'import Network.HTTP.Base; putStrLn $ urlEncode "doop"'
03:57:29 <Darkproger> :)
03:59:12 <hpc> hmm
03:59:29 <supki> ghc -e 'import Network.HTTP.Base' -e 'putStrLn $ urlEncode "doop"'
04:00:11 <sopvop> that like takes quite a bit of time to execute
04:00:18 <sopvop> line
04:01:30 <supki> well, it also execute ~/.ghci
04:01:59 <Darkproger> hmm didn't know you can use multiple -e's
04:02:00 <Darkproger> cool
04:02:48 <Darkproger> although you can't pass arguments
04:02:51 <Darkproger> ghc -e 'import Network.HTTP.Base' -e 'getArgs >>= return.urlEncode.head >>= putStrLn' http://haskell.org
04:02:54 <Darkproger> like that ^^
04:04:01 <Darkproger> at least you can use stdin!
04:04:02 <Darkproger> echo http://haskell.org | ghc -e 'import Network.HTTP.Base' -e 'getLine >>= return.urlEncode >>= putStrLn'
04:04:06 <Darkproger> which is nice
04:04:23 <hpc> i would use the environment for command-line vars
04:04:30 * hackagebot postgresql-simple 0.3.3.1 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.3.3.1 (LeonSmith)
04:04:44 <hpc> site=http://haskell.org ghc -e ...
04:04:45 <Darkproger> hpc: indeed, love this one
04:06:03 <supki> ghc -ignore-dot-ghci -e 'import System.Environment' -e 'let main = getArgs >>= print' -e ":main 1 2 3"
04:06:06 <supki> should work
04:07:02 <merijn> supki: You're gonna have to restar the haskellFoldIndent repo I had, I had to nuke it after learning that hg-git apparently doesn't behave itself and pushes "secret" patches to >.>
04:07:51 <supki> sure
04:08:26 <Darkproger> supki: what is this ':main' thing ?
04:08:41 <notdan> starts the program with the arguments
04:08:46 <notdan> so getArgs work etc
04:08:50 <supki> Darkproger: that's ghci command that calls main function in scope
04:09:12 <Darkproger> cool
04:10:30 <supki> s/function/action/
04:11:29 <jpcooper> Hello, I've been trying to install the cassava library from cabal. While compiling Data/Csv/Conversion.hs, I get an error saying "Could not deduce (Data.Traversable.Traversable Vector) arising from a use of `traverse'". Has anyone come across this problem before?
04:14:51 <jpcooper> update, everything seems to magically work after I cabal installed vector
04:15:05 <DrTeggy> ghc-vis
04:45:33 <Ghoul_> I got all sad inside when shachaf got something wrong
04:45:47 <Ghoul_> I thought he was like an immortal source of knowledge
04:54:12 <Fuuzetsu> GHC documentation is abysmal ;_;
04:55:33 <merijn> Fuuzetsu: Really? How so?
04:55:39 <quchen> Love and hate for GHC's source change on a daily basis it seems.
04:55:40 <merijn> I thought the user manual was pretty good
04:56:48 <kostja> Hi! Why does Ord has Eq as superclass?
04:56:51 <Fuuzetsu> merijn: A lot of documentation (generated by Haddock) is clearly aimed at GHC devs, i.e. people that have been there with the source for a longer while. e.g. http://haddocks.fpcomplete.com/fp/7.4.2/20130508-82/ghc/SrcLoc.html#t:GenLocated
04:57:04 <kostja> I want to have a partial ordering
04:57:38 <kostja> e.g. to sort a table by a column
04:58:15 <merijn> kostja: Ord is not meant for partial orderings
04:58:18 <Fuuzetsu> Sure, you can look up SrcSpan but that has absolutely no docs about it. You need to either get lucky and scroll up to find ‘RealSrcSpan’ (not linked to or ever mentioned) to even find out partially what it does
04:58:38 <kostja> hm, ok
04:58:45 <geekosaur> "The Ord class is used for totally ordered datatypes." per haskell report
05:03:54 <fruitFly> omg haskell is soo smart
05:04:08 <kostja> why do some people want applicative/functor to be a superclass of monad?
05:04:43 <kostja> since everybody knows how to use a monad as a functor, why doesn't the compiler automatically derieves the functor instance?
05:04:57 <fruitFly> omg lol... I was thinking where's the like button for a comment on the lyah page lol
05:05:08 <Fuuzetsu> kostja: it doesn't because the Applicative => Monad is not in place
05:05:35 <Fuuzetsu> Also, it doesn't because if you don't follow the laws (which are not enforced), everything would break (even more)
05:05:44 <kostja> "not in place"? what does this mean?
05:07:03 <Fuuzetsu> Applicative => Monad is desired because every Monad is an Applicative and we can use that. The proposal is to do with that. It is not currently ‘in place’, that is, the Monad typeclass does not have the Applicative restriction.
05:08:12 <geekosaur> kostja, the superclass is what would tell the compiler to derive it automatically. (note that neither Functor nor Monad is built into the language)
05:08:26 <kostja> Fuuzetsu: yes, and I asking myself, why should anybody want to have this restriction? It would force the programmer to write an instance (boilerplate) that the compiler could automatically do
05:08:39 <geekosaur> quite a few things that would have to be primitivesd in other languages are libraries in Haskell
05:09:07 <Fuuzetsu> kostja: There would be no boiler plate. The Monad typeclass could then have return = pure and you wouldn't need to implement it yourself. See what geekosaur said.
05:09:21 <kostja> If somebody puts Applicative as superclass to Monad, than everybody would need to implement the applicative instance first and then do the monad
05:09:27 <kostja> but this isn't necessary
05:09:30 <fruitFly> are maps like a internal databasing system?
05:10:22 <geekosaur> kostja, no, the point is you write it once for Applicative and the superclass allows the compiler to derive the Monad instance automatically
05:10:33 <geekosaur> the *current* case requires boilerplate
05:10:50 <geekosaur> the superclass makes the boilerplate go awat
05:10:53 <geekosaur> *away
05:10:56 <kostja> geekosaur: maybe you mean it the other way around?
05:11:02 <geekosaur> no?
05:11:14 <kostja> monad is more specialised than applicative
05:11:27 <Fuuzetsu> hue. kostja: at the moment you have to write the full instance for Applicative and the full instance for Monad
05:14:05 <kostja> at the moment the class defintion of Monad is like: class Monad m where ..., but if you make it look like class Applicative m => Monad m where... then you have to implement first the Applicative instance and then the Monad one
05:14:13 <geekosaur> no
05:14:14 <dmwit> incorrect
05:14:24 <dmwit> You must implement them both, but not in any particular order.
05:14:41 <dmwit> And, in fact, it would be possible for GHC to automatically implement Applicative for you given a Monad instance.
05:14:42 <geekosaur> you implement the Applicative instance and it derives the derivable part of Monad. there is also a part that cannot be derived, but by definition that is not boilerplate
05:14:55 <kostja> right: monad implies applicative (that's what I mean)
05:15:00 <dmwit> (...and this would not need to be built in to the compiler: current mechanisms already exist for this. See the DefaultSignatures extension.)
05:15:33 <dmwit> And, as geekosaur says, one can also ask the compiler to derive as much of Monad as possible given an Applicative instance.
05:15:42 <dmwit> Both requests can be "in the air" at once, so to speak.
05:15:46 <geekosaur> however, you seem to be understanding the point of the superclass incorrectly. Monad is Applicative plus some stuff therefore Applicative is the superclass
05:15:53 <Fuuzetsu> kostja: If that's what you mean then what's the issue? Currently, Monad implies Applicative is not possible because Applicative => Monad is not in place and neither Applicative or Monad are language features but are in libraries.
05:16:07 <kostja> why can't one just add: instance Monad m => Applicative m where ... to the library?
05:16:17 <geekosaur> no
05:16:17 <dmwit> Because that is a lie.
05:16:20 <Fuuzetsu> that's wrong
05:16:23 <dmwit> There are Applicatives which are not Monad.
05:16:44 <dmwit> sorry
05:16:50 <dmwit> I read that wrong, saw s/instance/class/.
05:16:58 <dmwit> You can't do that, either, but for a different reason.
05:17:01 <kostja> yeah, but every monad gives an applicative, no?
05:17:11 <fruitFly> Are maps haskell's internal databasing system?
05:17:17 <dmwit> Yes, but the current typeclass mechanism tries very hard to avoid backtracking during instance resolution.
05:17:31 <Fuuzetsu> fruitFly: …no. What gives you the idea that maps are a databasing system?
05:17:38 <kostja> fruitFly: you can use a map this way, as in any language
05:17:41 <dmwit> One upshot of this is that instances match whenever the *shape* of the instance declaration matches, regardless of whether the constraints in the instance hold or not.
05:18:08 <dmwit> So this instance says: "every type is Applicative. Once you ask for a type to be Applicative, double-check that it is a Monad"
05:18:23 <fruitFly> Fuuzetsu: because they allow to efficiently operate on key value pairs, like a no sql database?
05:18:37 <dmwit> This sucks, because it means I cannot declare *any other* instance of Applicative, because then there would be overlap and the compiler would have no way to choose between the two instances.
05:18:43 * geekosaur wonders if kostja has fallen into the OO trap
05:18:48 <dmwit> (One can turn on IncoherentInstances, but this is a pretty bad idea in general.)
05:19:00 <Fuuzetsu> fruitFly: You can apply this logic to many, many things. This doesn't mean that they are meant or suitable as a database system.
05:19:08 <geekosaur> (typeclasses look like OO, but they are not OO, and trying to treat them as OO will lead you into very nasty places)
05:19:22 <kostja> ok, there must be something I am completly missing
05:19:23 <Fuuzetsu> There's more to databases than just Map k v
05:19:28 <kostja> please explain
05:19:55 <dmwit> Can you narrow down the field of discourse?
05:19:55 <sopvop> type classes dont even look like OO
05:20:07 <kostja> given a Monad m you can write an Applicative instance m, this is right, isn't it?
05:20:12 <fruitFly> Fuuzetsu: You,re right, I guess I just meant the simplest form of a database
05:20:15 <dmwit> Yes, this is right.
05:20:28 <Fuuzetsu> sopvop: Unfortunately they look like Java interfaces which is what I believe confusion comes from. I asked about the difference myself, months ago.
05:21:02 <kostja> so what is wrong with this line: instance Monad m => Applicative m where ...
05:21:05 <sopvop> Fuuzetsu: It's like java interfaces, but interfaces are not like OO either.
05:21:09 <kimochiwarui> kostja: Actually, for a type constructor to be a Monad, it should be an Applicative first, this is the best way to put it.
05:21:12 <hodapp> trying to treat even OO like it's OO will lead into nasty places.
05:21:26 <Fuuzetsu> fruitFly: Sure. You can say the same about λ-calculus. Just because you can use it to represent something, doesn't mean you should nor that it was intended to be :P
05:21:31 <dmwit> kostja: Which part of my explanation is the earliest part you didn't understand?
05:21:50 <dmwit> I typed a full paragraph, and don't really feel like trying again blindly.
05:21:58 <fruitFly> Fuuzetsu:  :)
05:22:09 <Fuuzetsu> sopvop: but then it would mean that Java is not fully OO! Have I been lied to all my life? Do primitives like int, float etc. actually exist? (I joke)
05:22:09 <kostja> dmwit: maybe I missed it? what timestamp?
05:22:18 <dmwit> 8:26-8:27
05:22:23 <dmwit> five messages
05:23:11 <fruitFly> who here uses sublime text? I installed sublimeHaskell nothing seems to be different? No errors show up or anything? I want to get the fancy lamda symbols instead of just \ ?
05:23:11 <kostja> dmwit: this one? "One upshot of this is that instances match whenever the *shape* of the instance declaration matches, regardless of whether the constraints in the instance hold or not."
05:23:24 <dmwit> That is the beginning, yes.
05:23:58 <geekosaur> let's try this more practically. you can already get "Functor" without a superclass in any Monad; we call it liftM. however it's not optimal usually. if you Applicative => Monad then you can use fmap which is usually optimal. if you Monad => Applicative then you would get a Functor instance that used liftM, which means the less optimal form.
05:24:17 <Fuuzetsu> fruitFly: From what I know about SublimeText, it's just a ‘ahh so pretty’ text-editor with $60 extensions to everything. I personally recommend emacs (simply because that's what I use. I believe there's OK Haskell support as well in vim) but if you want to argue, we could move to -blah
05:24:46 <applicative> $60 extensions??
05:25:02 <fruitFly> ^^?
05:25:05 <Fuuzetsu> applicative: Proprietary software doing the thing it can do best
05:25:48 <kostja> geekosaur: one could provide a better implementation if one so desires?
05:26:27 <fruitFly> Fuuzetsu: how good is the haskell support in emacs compared to the other to in your opinion?
05:26:28 <kostja> or is it not possible to "overwrite" an instance on concrete types
05:26:40 <applicative> Fuuzetsu: there's nothing wrong with Sublime Text; nano is the best though.
05:26:54 <fruitFly> Fuuzetsu: the other two*
05:26:56 <geekosaur> kostja, I am now certain that you have something backwards but I am not sure what
05:27:00 <quchen> kostja: "=>" in this context does not mean "implies". "Applicative m => Monad m where" means that given an Applicative m, the definitions following the "where" make m a Monad. That's very different from "Applicative implies Monad".
05:27:00 <dmwit> kostja: Right, Haskell as she is written today does not have a way to overwrite instances.
05:27:05 <fruitFly> applicative: nano?
05:27:37 <applicative> type it in the terminal fruitFly, emacs is kind of like nano with a pile of hideous lisp macros on top
05:27:52 <Fuuzetsu> applicative: I have never actually used ST. It's proprietary. One of the most taunted features seems to be the minimap though which other editors can do easily and is pretty useless.
05:28:19 <quchen> I'd love to jump in with my opinion for ST, but a) editor wars are boring and b) off topic here.
05:28:34 <Fuuzetsu> applicative: I never used vim for long. emacs support is OK thanks to Kazu's ghc-mod which does a lot of nice stuff. haskell-mode development is active.
05:28:43 * applicative was kind of saying that
05:29:04 <fruitFly> well quchen  I installed sublimeHaskell and it doesn't seemed to have changed anything for me, no errors popping up etc.? I'm not sure what's wrong
05:29:06 <Fuuzetsu> quchen: which is why I suggested -blah to begin with
05:29:10 * applicative nevertheless insists that with a nice .nanorc nano is the editor of the future!!
05:29:33 <quchen> fruitFly: I don't use sublimeHaskell, only Sublime.
05:29:47 <quchen> fruitFly: Maybe there's a #sublime-text channel?
05:29:57 <Fuuzetsu> applicative: Does nano have _any_ redeeming features? I used it a few times out of necessity (bootstrapping systems) and it always came off as extremely primitive to me.
05:29:57 <fruitFly> Fuuzetsu: is emacs easy to setup? I installed Vim but don't even know how to save my color scheme so that turned me off
05:30:31 <applicative> fruitFly: you just type emacs in the terminal
05:30:40 <Fuuzetsu> fruitFly: Both emacs and vim have a tutorial. I believe it's ‘vim-tutor’ for vim. Press ‘C-h t’ in emacs for one.
05:30:52 <quchen> ... Offtopic ...
05:30:54 <Fuuzetsu> ^
05:30:56 <applicative> then you use self-expanding macros and get stuff like indentation
05:31:02 <applicative> it makes so much sense!
05:31:28 <Fuuzetsu> applicative: I'm missing the part where you carefully explain what makes nano any good for editing.
05:31:56 <applicative> people say emacs is very configurable, but really they mean inflatable.
05:32:31 <kostja> quchen: you say writing Monad m => Applicative m gives an Applicative from any Monad. This is what one wants, isn't it?
05:32:45 <Fuuzetsu> applicative: ELisp is not great but it's far, far better than anything other editors tend to offer (FFI to such great languages like Python and Ruby)
05:32:57 <applicative> why would one want the Applicative that is definable generally for Monad instances
05:33:21 <applicative> it's sort of the haos' Applicative instance
05:33:27 <applicative> 'total chaos'
05:33:54 <kostja> applicative: to use any monad as such
05:34:03 <quchen> kostja: "class Monad m => Applicative m" would define m to be an Applicative only if it is also a Monad.
05:34:11 <geekosaur> kostja, you "could" do it but it will almost always give you a bad Applicative
05:34:13 <kostja> no!
05:34:20 <supki> applicative: do you think ap and <*> should be different?
05:34:26 <geekosaur> do it the other way and you have a good Applicative and use it to derive a good Monad
05:34:29 <kostja> quchen: I want "instance Monad m => Applicative m..."
05:34:52 <applicative> supki of course I do, when it makes sense
05:35:00 <supki> hmm
05:35:05 <applicative> for example the Applicative instance for IO should be concurrent
05:35:08 <applicative> :)
05:35:11 <quchen> kostja: It's better to read "=>" as "then you can define a provided the following".
05:35:11 <kostja> geekosaur: doing it the other way around forces me to write an applicative instance
05:35:25 <geekosaur> yes, but not to have to write it *again*
05:35:40 <geekosaur> you seem to think that the other way requires writing the same code twice but that is not the case
05:36:00 <geekosaur> you only have to write the same code twice if there is *no* relationship between the two (ie. the current situation)
05:36:17 <quchen> kostja: I'm not sure what sense what you are describing makes. Where did it come up? Do you want to define a Monad and derive an Applicative from it?
05:36:34 <applicative> it is defined for a wrapped IO in the async library. why we use `ap` when we could be using `concurrently with` for <*> is a mystery that is due to incompetence mixed with historical accident
05:38:03 <kostja> quchen: It did come up in my head. If one would require (say functor) to be a superclass of monad, then everybody would have to implement fmap first before implementing return and bind. even if one doesn't even want to use fmap
05:38:16 <geekosaur> um
05:38:27 <quchen> kostja: No! Laziness! :-D http://hpaste.org/89415
05:38:44 <geekosaur> kostja, do you realize that monad actually requires fmap in some sense?
05:39:05 <geekosaur> there are two equivalent ways to define a monad. one is return+bind. the other is fmap+join
05:39:15 <quchen> kostja: Note how my example defines the Monad instance, and then the Functor/Applicative instance in terms of the Monad instance.
05:39:22 <kostja> geekosaur: fmap is implied by any instance of monad. Nobody should be forced to provide an implementation
05:39:47 <geekosaur> sure, a crappy one is there
05:40:02 <geekosaur> it's also, y'know, crappy
05:40:56 <neutrino_> kostja: i believe there are performance reasons.
05:41:27 * applicative thought thats what geekosaur was saying
05:41:59 <kostja> quchen: this is exactly what I mean. If you would have the requirement for a monad to be a functor, then you couldn't do so
05:42:10 <quchen> kostja: Yes you could
05:42:47 <neutrino_> kostja: in scala, every monad is an applicative, and you can define applicative automatically by defining monad.
05:42:54 <geekosaur> you are backwards. that requirement makes it possible, it does not disable it
05:43:09 <geekosaur> you migth want to think on why
05:43:11 <kostja> quchen: if the definition of the class would read: class Functor m => Monad m, then you couldn't implement a monad instance without writing fmap first
05:43:22 <quchen> kostja: Yes you could
05:43:24 <quchen> http://hpaste.org/89416
05:43:30 <applicative> in haskell, return and ap come with any monad, and you define return and ap by defining a monad
05:43:31 <neutrino_> kostja: i don't think that's correct.
05:43:39 <quchen> That defines an Applicative without defining Functor first.
05:43:47 <quchen> It then uses the Applicative instance to define the Functor.
05:43:55 <quchen> (And there's Functor => Applicative already.)
05:44:21 <kostja> quchen: oh!! this is possible?
05:44:23 <applicative> that's a little scary are you sure theres not some unpleasant cycle
05:44:25 <quchen> kostja:  :-)
05:44:56 <quchen> kostja: Laziness, basically. The compiler sees "oh, there's a Functor instance for this type, alright, it can have a Monad instance". It doesn't look at fmap to see that it refers to Monad.
05:45:11 <fosskers> evening gents
05:45:12 <quchen> kostja: When it needs fmap, there's the Monad instance and it can use liftM.
05:45:27 <applicative> liftA f a = pure f <*> a
05:45:46 <quchen> That uses only Applicative functions.
05:46:11 <quchen> If someone would have defined "liftA = fmap" the whole thing would crash of course.
05:46:16 <fosskers> Got recursion working in my Lisp implementation
05:46:20 <applicative> yeah, it works, I was wondering how they defined liftA
05:46:27 <fosskers> Took me a good few days
05:46:41 <kostja> why is this not possible? instance Applicative f => Functor f where fmap = liftA
05:46:55 <mauke> kostja: overlaps with everything
05:47:18 <applicative> evening? ah fosskers is on the other side of the world
05:48:52 <kostja> mauke: what overlaps?
05:48:57 <quchen> kostja: Works for me.
05:49:10 <fosskers> applicative: japan, yeah
05:49:12 <mauke> kostja: the Functor instance
05:49:26 <kostja> please be more verbose
05:49:36 * applicative is thinking of sending a new <*> for IO to the Libraries list
05:49:47 <quchen> kostja: http://hpaste.org/89417 compiles
05:49:59 <quchen> It's probably not a good idea to use it though.
05:50:07 <applicative> ff <*> xx = runConcurrently (Concurrently ff <*> Concurrently xx)
05:50:18 <mauke> kostja: you won't be able to add a second Functor instance
05:51:17 <applicative> instance Alternative IO where a <|> b = let as = Concurrently a; bs = Concurrently b in Concurrently $ either id id <$> race as bs
05:51:55 <applicative> but alas they arent consistent with <*> = ap
05:52:07 <quchen> That means they violate some laws.
05:52:07 <fosskers> ah
05:52:12 <fosskers> looks like it
05:53:03 <applicative> who's violating laws?
05:53:10 <quchen> Your Applicative instance.
05:53:27 <applicative> not unless the async library violates them
05:53:30 <Hafydd> instance Applicative applicative where
05:54:05 <merijn> applicative: I don't think that should be the default for IO
05:54:09 <applicative> ... and it's in the *Haskell Platform* ...
05:54:17 <merijn> applicative: If you want that, you can trivially wrap it yourself
05:54:55 <applicative> if you want the other, you can use `ap`
05:55:45 <ramses_> it would be very contrintuitive if ap /= (<*>)
05:56:00 <dreixel_> anyone knows of any simple language on Hackage, hopefully complete with parser and pretty-printer? By simple I mean no more than 3/4 datatypes and maybe around 10 constructors, but also not too simple...
06:05:54 <applicat1ve> merijn: I can also define class Idiom f where sing :: a -> f a; <#> :: f (a->b) -> f a -> f b , add the same laws.  The ramses_ will still say it's counterintuitive that <#> isnt 'ap' I guess
06:07:29 <applicat1ve> maybe it's like the old words for 'morons' 'cretins' 'idiots', you have to introduce a new one every few years because the old one becomes pejorative. likewise, any class with the applicative laws will degrade to <*> = `ap`
06:08:09 <applicat1ve> so to maintain the actual idea, you have to introduce a new type class every 4 years
06:08:23 <dreixel> I'll repeat this question as I'm hoping I missed replies with the netsplit :P
06:08:27 <dreixel> anyone knows of any simple language on Hackage, hopefully complete with parser and pretty-printer? By simple I mean no more than 3/4 datatypes and maybe around 10 constructors, but also not too simple...
06:08:44 <applicat1ve> 'whitespace' of course
06:09:09 <applicat1ve> compare and contrast the divers bf implementations
06:09:09 <dreixel> applicat1ve: that falls under "too simple", I'm afraid
06:09:23 <applicat1ve> cpl is the only interesting language on hackage
06:09:47 <applicat1ve> idris is too complicated?
06:09:49 <applicat1ve> yes
06:09:50 <dreixel> even brainfuck is a bit too simple. I'd like it to have mutually recursive datatypes
06:09:59 <applicat1ve> hm
06:11:27 <applicat1ve> dreixel: i guess that means it needs datatypes
06:11:37 <neutrino_> dreixel: check the esolangs wiki. look at anything in the Acme package.
06:12:34 <dreixel> applicat1ve: not necessarily... declarations vs. expressions tends to be enough for a mutually recursive representation
06:12:48 <dreixel> applicat1ve: Idris is just a bit too big...
06:13:38 <applicat1ve> epic has too many constructors for the main type
06:14:20 <dmwit> Perhaps part of the problem is that the languages that fit in the space between "too tiny to be interesting" and "too useful to read the source" simply aren't uploaded to Hackage.
06:14:33 <quchen_> applicat1ve: Your Idiom class would lack one law: "If f is also a Monad, it should satisfy pure = return and (<*>) = ap", from Control.Applicative.
06:16:07 <quchen_> Concurrently is not a Monad, and you can define an Applicative instance for IO with it, but that Applicative will clash with that law. You could of course define a newtype wrapper around IO that is not a Monad, callit concurrentIO, and define your Applicative for that.
06:16:53 <applicat1ve> quchen_: the remark 'if f is also a monad ..' is obiter dictum and is what I oppose
06:17:21 <applicat1ve> it means: if f is also a monad, this class is irrelevant
06:17:34 <quchen_> You oppose "there are Monads that are also Applicatives"?
06:17:36 <quchen_> Wat.
06:17:40 <dmwit> no
06:17:59 <applicat1ve> no, I oppose being forced to define <*> = ap
06:18:08 <dmwit> I'm fairly sure he's just saying that law should go on the Monad class, not on the Applicative one.
06:18:13 <Scabe> Is there a way to use union on trees?
06:18:24 <Scabe> And still return a tree.
06:18:31 <Scabe> Union on two trees and stil return a tree
06:19:04 <dmwit> "Is there a way to use integer addition on cats?"
06:19:20 <dmwit> Perhaps more helpfully: what is a tree?
06:19:24 <applicat1ve> my position is the one anyone will hold if there were an additional Control.Idiom in base with sing :: a -> f a , <#> :: etc
06:19:33 <applicat1ve> and the actual applicative laws.
06:19:36 * hackagebot pipes-concurrency 1.2.0 - Concurrency for the pipes ecosystem  http://hackage.haskell.org/package/pipes-concurrency-1.2.0 (GabrielGonzalez)
06:20:13 <dreixel> I might just use this: http://www.haskell.org/haskellwiki/Parsing_a_simple_imperative_language
06:20:14 <geekosaur> oh, are we back on "the original idiom laws that were found to be too restrictive by the community are the only real laws, everyone go back to useless idioms or diaf:?
06:20:19 <applicat1ve> no one would be so stupid as to insist that every instance of Idiom for a type that has a monad instance, should be <#> = ap
06:20:23 <applicat1ve> this would simply be moronic
06:20:31 <Scabe> data Tree a = Null | Node {element :: a, left_tree, right_tree :: Tree a} is a tree
06:20:51 <applicat1ve> geekosaur: i change my argument to, I want Control.Idiom in base so I can do what I please
06:21:02 <quchen_> dmwit: Monad saying "if m is also an Applicative, m should obey <*> = ap" - isn't that the same thing?
06:21:18 <applicat1ve> yes its the same
06:21:56 <applicat1ve> similar arguments would oppose parallel list comprehensions, since they are counterintutive
06:23:24 <applicat1ve> good thing Control.Monad.Zip in base doesn't say 'and if m is a monad, as it must be, the  mzip instance must be liftM2 (,)
06:23:35 <dmwit> Scabe: If you define a new type, and you want a function that operates on that type, you will have to write it yourself.
06:24:47 <Scabe> Hmm, is it possible to do that though? Use union on what I defined was a tree.
06:25:41 <dmwit> Assuming here the question is "I have already written union for some other type, can I use it on a tree?", then I am saying, no: you must write a new function (perhaps also called union!) for your new type.
06:26:50 <dmwit> applicat1ve: Doesn't it, though? liftM (f *** g) (mzip ma mb) = mzip (liftM f ma) (liftM g mb) very nearly says it needs to behave like liftM2 (,).
06:27:43 <applicat1ve> Scabe: do you want union to eliminate duplicates and so on?
06:28:04 <applicat1ve> dmwit: yes very near :)
06:28:24 <applicat1ve> but it is what is used for parallel monad comprehensions.
06:28:54 <applicat1ve> so it isn't the same
06:28:56 <Scabe> applicatlve: Yeah I think so.
06:29:20 <applicat1ve> Scabe: then you need an Eq and maybe Ord instance on a for union
06:29:41 <applicat1ve> and some sort of cleanup, normalize function to eliminate the nonsense
06:30:26 <applicat1ve> if you just want to join two trees, its simple.
06:30:57 <kamatsu> is there a version of Network.URI for text or bytestring?
06:31:40 <applicat1ve> that parses and all? i don't think so. eveyone imports it but maybe I'm out of date
06:31:50 <Scabe> Yeah join two trees sounds like what I'd have to do.
06:32:08 <Scabe> Hmm now I gotta try slowly wrap my ahead around the process of what to do
06:32:21 <applicat1ve> Scabe: this happens in e.g. Data.Set you might look at the source for it.
06:32:31 <applicat1ve> the tree is a little fancier, to put it mildly
06:33:38 <Scabe> Yeah tree is so fancy ><
06:34:31 <Scabe> But I think you're help has gotten me onto something. So thanks!
06:37:02 <applicat1ve> https://github.com/ghc/packages-containers/blob/master/Data/Set/Base.hs -- this is the same as your type, but has a 'size' attached. note that the constructors are not exported
06:38:18 <applicat1ve> Scabe: ^^^
06:39:28 <applicat1ve> Scabe: the union definition on lines 536 ff is a little complicated; partly becuase they are trying to preserve unrelenting strictness
06:39:58 <applicat1ve> if i understand it
06:49:38 * hackagebot ListLike 4.0.0 - Generic support for list-like structures  http://hackage.haskell.org/package/ListLike-4.0.0 (JohnLato)
06:50:52 <applicat1ve> its amusing that Control.Monad.Zip doesn't say, if m has an Applicative instance, mzipWith should *not* be liftA2
06:54:04 * applicat1ve could use MonadZip to express Idiom, but unfortunately it has a pesky Monad constraint
06:55:44 * applicat1ve has a new plan, class Applicative f => Idiom f where sing:: a -> f a, (<#>) ... with the comment: obviously this class is useless unless the definition of <#> differs from <*>
06:57:18 <applicat1ve> then instance Idiom IO where io <#> io' = runConcurrently (Concurrently io <*> Concurrently io') and similarly for all the actually intersting cases
06:58:18 <quchen_> newtype ConcurrentIO a = ConcurrentIO (IO a); instance Functor ConcurrentIO where fmap f (ConcurrentIO io) = ConcurrentIO (fmap f io); instance Applicative ConcurrentIO where [your definitions]
06:58:26 <merijn> I need more test monkeys^H^H^H^H^H^H^Hfeedback providersfor vim auto-indenting!
06:58:35 <applicat1ve> quchen_: these definitions are already in base
06:58:37 <merijn> https://github.com/merijn/haskellFoldIndent
06:59:07 <merijn> If you have any comments on the indent style or find any issues that aren't already in the long list of issues at the end, let me know :p
06:59:10 <applicat1ve> sorry, in the haskell platform
06:59:27 <quchen_> Wonderful! Our work here is done.
06:59:47 <quchen_> merijn: I would like to complain about the indent style ;-P
06:59:52 <applicat1ve> quchen_: line 561 https://github.com/simonmar/async/blob/master/Control/Concurrent/Async.hs
07:00:25 <applicat1ve> quchen_: yes, we've been forced to use newtyping where none was necessary, great
07:00:27 <merijn> quchen_: I'd like to hear complaints, but there's a non-zero chance I'll tell you your preferred indent style is wrong and you should feel bad! :p
07:00:46 <quchen_> merijn: That's very likely because I'm a 6-space-weirdo :>
07:02:47 <merijn> quchen_: I actually indent by shiftwidth!
07:02:56 <merijn> So if you set shiftwidth=6 it would actually work
07:03:07 <quchen_> merijn: I'm not familiar with that
07:03:25 <merijn> quchen_: It's a vim setting that determines how many spaces a tab should indent
07:04:04 <quchen_> So you can indent with tabs and send it to your friends and it only breaks for half of them because your file has a header?
07:04:13 <merijn> quchen_: See line 36+ of my documented vimrc to learn how to properly configure vim for tabs: https://github.com/merijn/dotfiles/blob/master/vimrc
07:04:28 <merijn> quchen_: No, it doesn't insert tab characters, it inserts spaces
07:04:42 <merijn> Anyway, gotta run to get my plane
07:04:47 <quchen_> Ah, I see, it's the "how to translate tab pressing" setting.
07:04:56 <quchen_> Have a nice flight :-)
07:05:36 <mauke> vim thinks in indents, not tabs
07:06:04 <mauke> this is used by autoindenting and commands like >, <, ^T, ^D
07:07:18 <applicat1ve> it is amusing that poor Control.Monad.Zip doesn't use the monad constraint in formulating its laws; they presuppose functoriality only
07:07:57 <pjdelport> 'tabstop' is how much visual space an actual tab character stands for, 'shiftwidth' is logical indentation width to use for all the logical indent/dedent commands (and code formatting, etc.)
07:08:04 <applicat1ve> that is, they state what more a Zip thing has beyond functoriality, in terms of fmap disguised as liftM
07:08:53 <pjdelport> the tab key has nothing to do with indents, by default, but 'smarttab' makes tab/backspace act as indent/dedent at the beginning of a line
07:09:38 * applicat1ve notices now that quchen_ 's argument entials that Control.Monad.Zip should require newtyping if there is an Applicative instance, and thus that parallel monad comprehensions should need newtyping
07:09:43 <pjdelport> (like << / >>, or CTRL-T / CTRL-D in insert mode)
07:11:04 <applicat1ve> really it should be for ZipList; meanwhile ZipList needs a monad instance, namely the usual one for lists....
07:11:37 <applicat1ve> oh what a tangled web we weave when once we make one application of affirming the consequent
07:12:50 <elliott> didn't we have this argument yesterday?
07:12:58 <applicat1ve> yeah it got started again
07:13:11 <elliott> fantastic
07:13:13 <hodapp> oh gawd
07:13:16 <applicat1ve> my arguments are getting much more devastating
07:13:21 <applicat1ve> ;)
07:13:34 <applicat1ve> i didn't start it elliot
07:13:36 <Sculptor> yo
07:13:53 <applicat1ve> yo indeed mr/mme Sculptor
07:14:12 <hodapp> here, let me start a dumber argument
07:14:13 <elliott> applicat1ve: don't worry about blame. nobody will be spared!!
07:14:21 <elliott> /mode +b *!*@*
07:14:34 <hodapp> "haskell is stupid because I can just use $other_language and use functional constructs; what's the difference?"
07:15:03 <hodapp> "immutability is stupid. the world is mutable."
07:15:03 <applicat1ve> uh, isn't every line unsafeperformio in them?
07:15:30 * applicat1ve seeks a haven in a mutable world
07:15:46 <hodapp> oooh, here we go, "haskell is just a language that mediocre people use so they can pretend to be smarter"
07:15:49 <Hafydd> The world isn't a good model.
07:15:52 <applicat1ve> the world is mutable, but somehow I keep running the same damn executable, its impossible!
07:16:19 <applicat1ve> there was never a more dangerous expression than 'the world'
07:16:28 <hodapp> what about "average user"?
07:16:39 <applicat1ve> it is a theological concept; okay in that context; a disaster elsewhere
07:16:47 <pjdelport> average users and spherical cows
07:16:55 <Hafydd> "average user" is a theological concept.
07:16:58 <hodapp> who was the Comp Sci curmudgeon who had the lovely rant about this "average user" and how much crap we blame on him?
07:17:09 <hodapp> it wasn't Dijkstra I don't think but I don't know
07:17:24 <applicat1ve> me is the 'slightly adept and thus unusually dangerous' user
07:17:32 * applicat1ve too
07:17:35 <Hafydd> Average Users Considered Harmful
07:17:57 <applicat1ve> they're nothing compare to the ones that read a couple blogposts
07:17:58 <hodapp> but seriously, does anyone know the rant I'm talking about?
07:18:06 <Hafydd> Or just: Users Considered Harmful
07:18:08 <applicat1ve> its very familiar
07:18:41 <hodapp> I can't seem to find it though. Was it Dijkstra? Knuth? hmmm
07:18:56 <applicat1ve> its funny they dont argue that their source files should mutate since the world mutates
07:19:29 <hodapp> applicat1ve: clearly, the answer is object-oriented
07:19:44 <applicat1ve> hodapp: I can't believe anyone like them would say this; it's an internet meme, thus the question of origin is irrelevant; the cause of insistent repetition is what is to be sought after
07:20:16 <applicat1ve> to find it, we study a certain aspect of the rodent brain
07:20:16 <hodapp> applicat1ve: no, it is a specific quote or even short essay that I read, and I cannot seem to find it again
07:20:37 <applicat1ve> hodapp: you mean 'the world is mutable so ...'?
07:21:07 <applicat1ve> there are hundreds of uses of it, it surprises me you think a noteworthy author is needed to keep memes alive
07:21:44 <hodapp> applicat1ve: oh, no, that wasn't what I was talking about. However, Rich Hickey of Clojure fame did once apparently have a field day with a speaker who tore a teddy bear in half to show why mutability is good.
07:21:49 <applicat1ve> we always use the same letters to type our source code ... *but the world is constantly changing!*
07:22:09 <hodapp> applicat1ve: what I was talking about was a specific rant/essay I read about the 'average user'.
07:22:20 <applicat1ve> i can imagine mr hickey doing well in such scene; he is very much on our side in these matters
07:22:36 <Adeon> why would you hurt a teddy bear
07:22:39 <applicat1ve> maybe a little more 'pragmatic'
07:22:52 <hodapp> Adeon: why, to show that mutability is good
07:22:57 <applicat1ve> Adeon: that's the kind of people they are
07:23:18 <applicat1ve> these Mutators, these aptly named 'Destructive' updaters
07:23:39 <applicat1ve> the world is full of destruction; my progamming language should be too.
07:23:57 <applicat1ve> the world is full of murder and oppression, my programming language needs them too
07:24:07 <applicat1ve> after all, I want to model the world!
07:24:13 <pjdelport> sounds like movie monster names
07:25:00 <hodapp> applicat1ve: ...you say it ironically... but Object Oriented became *the* paradigm somehow
07:25:55 <applicat1ve> hadopp, surely we can think of a similar outright falsehood to propagate our point of view.
07:26:15 <applicat1ve> x = x+1 !! it doesn't make sense !!
07:26:46 <hodapp> my name is hodapp, not hadopp, not hadoop >_<
07:26:47 <applicat1ve> imperative programming is a calculation error !!
07:27:36 <applicat1ve> hey, at least i didn't write hadoop.
07:28:09 * applicat1ve imprints the 'app' part
07:28:24 <applicat1ve> hod.app
07:28:27 <Ankhers> I think OOP is easier for beginners to understand. They can liken it to the real world easier. (I am not saying it is necessarily better)
07:28:39 <hodapp> object-oriented is actually pretty fascinating if you read some of the research that Alan Kay did early on
07:28:47 <applicat1ve> this is a stone age conception of language
07:29:00 <applicat1ve> if you say 'wolf' maybe a wolf will come!!
07:29:18 <noteventime> Does anyone have a clue how powerful is the Haskell type system (with fancy extensions) is when considered as a type theory/logic (in the Curry-Howard sense)?
07:29:32 <hodapp> Ankhers: the problem is that they *are* likening it to the real world up to and past the point where it makes any sense to
07:29:35 <applicat1ve> as a logic, it leaves something to be desired...
07:29:47 <applicat1ve> @type undefined
07:29:57 <applicat1ve> undefined :: forall a . a
07:30:11 <applicat1ve> we don't want proofs of every proposition!
07:30:25 <noteventime> applicat1ve: Well, any "warts" of the IO and bottom kind left out of the equation :P
07:30:34 <Ankhers> hodapp: I completely agree with that. I was just stating why I think OOP because *the* paradigm.
07:30:49 <hodapp> Ankhers: it became 'the' paradigm because it generates a lot of what looks like work
07:30:54 <pjdelport>  "I invented the term object-oriented, and I can tell you that C++ wasn't what I had in mind."
07:30:59 <pjdelport> http://c2.com/cgi/wiki?AlanKaysDefinitionOfObjectOriented
07:31:04 <noteventime> Ankhers: Why would that be any more true for OOP than any form of structured programming?
07:31:18 <hodapp> noteventime: because "object oriented" sounds better.
07:31:59 <noteventime> I mean, it's not like other programming paradigms do not act in terms of things being operated on
07:32:19 <hodapp> noteventime: No. But "object oriented" sounds better.
07:32:34 <hodapp> it's a goddamned buzzword, mostly.
07:32:37 <applicat1ve> why would I want there to be something X such that I can say about my system that 'everything is an X'?
07:32:46 <noteventime> hodapp: So if you call FP "value oriented" you'd get all the conservative christians on board?
07:32:58 <applicat1ve> values oriented
07:33:08 <hodapp> noteventime: Uhm... Maybe. Do we want them though?
07:33:10 <applicat1ve> noteventime: I think you've found our fraudently meme!
07:33:26 <pjdelport> applicat1ve: sometimes that's a simplifying tool
07:33:36 <pjdelport> you have to choose your X wisely, though
07:33:37 <applicat1ve> imperative languages are used by porno sites, violent games; haskell is a *values oriented* language
07:33:48 <noteventime> :P
07:33:57 <pjdelport> haha
07:34:07 <applicat1ve> that should read
07:34:15 <applicat1ve> oo languages  are used by porno sites, violent
07:34:16 <applicat1ve>                      games; haskell is a *values oriented* language
07:34:31 <noteventime> applicat1ve: How does Carmack porting Wolf3D to haskell affect this image though?
07:34:55 <applicat1ve> noteventime: many of the greatest saints began as great sinners
07:35:00 <applicat1ve> read Dostoyevsky
07:35:01 <hodapp> applicat1ve: ...you, sir, are clever.
07:35:35 <hodapp> applicat1ve: but be aware that the opponents may say: "functional languages like Haskell and F# are used in such broods of sin and hubris as Wall Street."
07:35:45 <applicat1ve> Carmack, he's the Charles Colson of functional programming.
07:36:16 <applicat1ve> hodapp: you are letting your particular values intrude with my Conservative Christian Family Values meme generator
07:36:42 <hodapp> applicat1ve: I am not, but your opponents may!
07:36:52 <applicat1ve> wait, I have a better plan
07:37:09 <applicat1ve> of course, it is possible to misuse value oriented programming
07:37:22 <applicat1ve> many confuse value with Price.
07:37:29 <hodapp> I thought that was the point, to misuse it
07:37:40 <applicat1ve> but true value oriented programming doesn't make this error
07:39:40 <applicat1ve> when we say 'everything a value' they think 'everything has a price'; well they're wrong. Wrong! I say
07:40:23 <applicat1ve> thus do we exclude both violent games and haute finance from genuine values oriented programming.
07:40:29 <applicat1ve> i'm sure conal will back me up on this
07:40:53 <applicat1ve> spj seems to have a weakness for finance
07:41:15 <mauke> wait, do we have a "nal"?
07:41:25 <applicat1ve> in pure, typed, functional program, everything is something or other
07:41:34 <applicat1ve> in pure, typed, functional programming, everything is something or other
07:41:51 <applicat1ve> mauke: oooo
07:42:16 <pjdelport> applicat1ve: don't forget to mention that values oriented programming is founded firmly in the Church tradition
07:42:31 <noteventime> Haha
07:42:38 <nal> The pope of my Church is Alonzo! as my favorite teacher used to say
07:43:36 <nal> the allegedly coming multicore 'revolution' is our favorite apocalyptic scenario
07:43:49 <mauke> strictly separated from state
07:46:02 <srh> remember, because computers will become multicore, your single-core apps will suddenly stop working
07:46:04 <srh> Y2core
07:46:28 <nal> THE LIVING WILL ENVY THE DEAD; behold the day is coming!
07:46:41 <nal> I think we can do this. I wonder what Enterprise will think.
07:47:07 <Jeanne-Kamikaze> Enterprise is trapped in the java monad
07:47:13 <pjdelport> mauke++
07:49:38 <nal> values oriented programming is not so much in favor of a separation of Church and state, but the elimination of state; why needs it when we all have right values and Church to watch over us
07:49:53 <nal> who needs it, rather
07:50:08 <companion_cube> reminds me of the lambda church
07:50:38 <nal> i don't think Alonzo, pious episcopalian, would go for these propositions
07:51:47 <nal> he did work on Sunday, so maybe he was a little slack
07:53:03 * nal reflects, maybe it was only sunday nights Church worked on
07:54:23 <nal> he tended to stay in the office til 3 am or the like
08:35:07 <magicman> ... This is awesome. Just yesterday I was looking at pipes-concurrency and thought "This would be even better if it had some way of broadcasting."
08:35:21 <magicman> And today, there's 1.2.0, which has some way of broadcasting.
08:43:11 <adinapoli> unfortunately the documentation links are broken on Hackage, probably they need to be regenerated: http://hackage.haskell.org/package/pipes-concurrency
08:43:58 <magicman> Yeah, I think hackage hasn't gotten around to generating them yet. It was uploaded about 2 hours ago, or something, don't know how often hackage generates docs.
08:44:40 <magicman> But I looked at the code. The Input type has gained a Monoid instance.
08:46:06 <adinapoli> I know too little about pipes to say "cool", but it sounds like a good thing :D
08:47:41 <kostja> hi!
08:48:24 <kostja> anybody knows Gabriel Gonzalezs article about OOP and comonads?
08:49:26 <Taneb> kostja, read it a while back
08:49:29 <magicman> I remember having seen that, but not any of the details.
08:49:49 <kostja> I can't get quite where it goes... e.g. his Thermostat "object". What is the function Kelvin -> a going to represent?
08:49:55 * hodapp reads about reactive-banana
08:50:01 <kostja> I have a working implementation here
08:50:27 <kostja> http://hpaste.org/89422
08:50:37 <Taneb> http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
08:51:48 <Taneb> kostja, it's supposed to be something like data Thermostat a = Thermostat Kelvin (Kelvin -> a)
08:52:08 <kostja> Taneb: yeah, see the hpaste above
08:53:07 <kostja> what is the (Kelvin -> a) supposed to be? a member function? can one add a second one? but then extract can't work the way it does
08:53:17 <magicman> The (Kelvin -> a) is a readout function. The Thermostat has an internal temperature stored in Kelvin, but you may be more interested in a Celcius/Fahrenheit/"Cold/Hot" display.
08:54:19 <magicman> A "Thermostat Kelvin" is a thermostat with a display in Kelvin. A "Thermostat Celcius" is a thermostat with a display in Celcius. Its internal temperature is still stored as Kelvin, but it has a (Kelvin -> Celcius) function inside it for conversion.
08:55:11 <kostja> magicman: is extend up initTh then a different thermostat?
08:56:10 <kostja> so extend works like a constructor?
08:57:23 <kostja> what are functions of type Thermostat a -> b supposed to be? Thermostat transformers?
08:58:39 <magicman> I just expanded the definitions in "extend up initTh": Thermo (295.15, \d -> kToC (d+1))
09:00:12 <kostja> magicman: so this is in fact a different Thermostat
09:00:36 <magicman> Aye.
09:01:14 <kostja> extend together with functions of type w a -> b works as a kind of "object" constructor for the Thermostat "class"
09:01:20 <magicman> (oh, hey, thermostat, not thermometer. Silly me :p)
09:02:14 <glguy_> Will Cabal allow you to specify which C compiler to use without making a custom setup.hs?
09:03:13 <flebron> So, newbie question. I want to write a function f :: [a] -> IO (). Can I use monadic syntax for both the list monad and the IO monad somehow?
09:03:19 <circle> how would you build a simple databse in haskell?
09:03:29 <circle> not looking at anything advanced like modules or anything
09:03:36 <mauke> flebron: what is this function supposed to do?
09:03:53 <mauke> circle: modules aren't advanced
09:04:12 <flebron> mauke: This case? Grab two ints and print some result. I'm wondering in the general case, I know I can f [x, y] = do ...
09:04:15 <circle> this is the proscription, can anyone give a general idea of the datatype I'd use for this? "Design a type for a movie database. Your database should be able to hold a variable number of two different kinds of movies: documentaries and films. Both have a title, a director and a year. Yet a film has also actors and can belong to one or multiple genres (drama, thriller, science fiction,comedy, animation). While a documentary has no actors, yet can belon
09:04:15 <circle> g to one or multiple documentary categories (social, political, bibliographic)."
09:04:38 <mauke> flebron: I don't understand what you mean by the general case
09:04:44 * hackagebot mongodb-queue 0.1.0.0 - a queue using MongoDB  http://hackage.haskell.org/package/mongodb-queue-0.1.0.0 (GregWeber)
09:05:02 <flebron> I have two monads, one in my input type, one in my output type. Can I use monadic syntax for both of them somehow?
09:05:07 <mauke> circle: ah, I see
09:05:10 <S11001001> flebron: yes
09:05:14 <mauke> flebron: that makes no sense
09:05:14 <flebron> I think what I'm looking for is monad transformers, but I don't know.
09:05:34 <flebron> mauke: I think it makes sense, could you explain why you think it doesn't?
09:05:41 <flebron> I have f :: M a -> M' b.
09:05:59 <circle> mauke: what do you reckon?
09:06:10 <mauke> flebron: do you know how do-notation desugars?
09:06:15 <flebron> I do.
09:06:26 <mauke> well then
09:06:29 <flebron> Hence why just using do notation usually will not work.
09:06:38 <flebron> That's why I'm asking if there's a way to mix these somehow.
09:06:38 <mauke> circle: do you know about 'data'?
09:06:59 <circle> mauke: Indeed I do.
09:07:05 <kostja> flebron: you can't get of a monad, if you don't know it's internals to deconstruct it
09:07:13 <IanMc> that was weird, said my name had already been registered
09:07:30 <flebron> kostja: Hm? I don't know what you mean by "get of a monad", and I'm not trying to deconstruct it O.o
09:07:43 <byorgey> flebron: I think to be helpful we need to know a bit more about what you are trying to do.
09:07:46 <kostja> flebron: sorry, I meant get out of
09:07:58 <mauke> .oO( that's what you get for asking questions that make no sense )
09:08:06 <flebron> mauke: That's not very pleasant.
09:08:21 <flebron> byorgey: In this case, it's a simple matter of getting two Integers out of a [Integer], and doing some IO on the result of their sum.
09:08:25 <IanMc> yeah, don't be so snotty
09:08:35 <flebron> In which case, I can already say f [x, y] = do ..., where the "do" is in the IO monad.
09:09:00 <byorgey> flebron: makes sense.
09:09:07 <byorgey> but you would like to rewrite this code somehow?
09:09:25 <magicman> flebron: If you mean: f list = do { x <- list; stuff_with x;}, then no.
09:09:26 <circle> mauke: I know about data, could you suggest how I'd use it in this case?
09:09:31 <mauke> circle: looks like you can directly translate that description into type definitions
09:09:36 <flebron> I'd like to know if there's some way to do something like (and this is pseudocode): foo x = y <- x; putStrLn x, where y is a String
09:09:37 <mauke> circle: where exactly are you stuck?
09:09:50 <circle> mauke: Not quite sure where to start, to be honest. What the structure would be.
09:09:56 <IanMc> fair question
09:10:07 <circle> It doesn't look like it'd work with a plain type definition, perhaps with a data one.
09:10:24 <mauke> circle: the top level structure sounds like a pair of lists
09:10:28 <mauke> you could start there
09:10:30 <flebron> Ideally, that code would be identical to mapM_ putStrLn x.
09:10:34 <byorgey> flebron: you could perhaps do something like that if you used a combined monad like  ListT IO
09:10:48 <byorgey> it's not going to be much nicer though.
09:10:50 <kostja> flebron: you can do something silly like: f list = head [ stuff_with_x | x <- list]
09:10:51 <mauke> warning: ListT is evil
09:10:53 <byorgey> and I'm not even sure it would work.
09:10:59 <mauke> also, needs more liftIO
09:11:02 <glguy_> Or: \xs -> sequence_ $ do x <- xs; return (putStrLn x)
09:11:07 <glguy_> if the goal is just to use do
09:12:20 * IanMc started to learn haskell
09:12:47 <IanMc> Hello everyone :) how are we today?
09:12:48 <circle> mauke: One sec
09:12:49 <magicman> (I bet that with the right kind of cont-magic, ContT . forM would typecheck... Totally not a good idea, though :p)
09:13:11 <magicman> (probably needs delimited stuff, anyway <_<)
09:13:37 <IanMc> just a channel check, can anyone see my messages?
09:13:39 <flebron> Monads would not seem to compose very well, then? That is, I can manually produce an [IO ()], which would be, given f :: M a -> M' b, an M (M' b). But the language itself doesn't like to do this in the general case?
09:14:07 <flebron> Well, not the language, but this particular abstraction.
09:14:08 <mauke> the language itself doesn't even know about monads, really
09:14:11 <mauke> yeah
09:14:27 <mauke> there's no general way to turn a monad into a monad transformer
09:14:36 <S11001001> flebron: Monads do not compose.
09:14:44 <circle> mauke: still stuck on the lower level stuff
09:14:50 <kostja> mauke: i has syntactic sugar for it
09:14:56 <flebron> What's the "closest" thing to a monad that composes?
09:15:16 <mauke> do applicatives compose?
09:15:19 <kostja> mauke: or is there a way to define such things for own modules?
09:15:19 <IanMc> so actually, if I'm talking to myself, I'm not entirely sure that 'this' is what I'd like to become
09:15:20 <magicman> They do.
09:15:33 <joelteon> yeah IanMc i can see 'em
09:15:37 <joelteon> your name is yellow on my screen
09:15:42 <IanMc> oh, THANK YOU
09:15:48 <magicman> instance (Applicative m1, Applicative m2) => Applicative (m1 `O` m2) where... exists.
09:15:52 <S11001001> flebron: both mentioned by mauke, in two directions: monad transformers, and applicative
09:15:59 <IanMc> thought I was dead
09:15:59 <magicman> (with newtype O f g a = O (f (g a)))
09:16:12 <mauke> kostja: there's a ghc extension for rebindable do notation but that's it
09:16:24 <magicman> (or... "exists". "Can be defined", and it probably is, somewhere on hackage)
09:16:30 <mauke> that is, you can substitute your own >>= but you don't get your own custom syntax
09:17:31 <IanMc> do you all use mirc ?
09:17:37 <kostja> mauke: then monadic computations are a built in feature of haskell, or at least of the compiler
09:17:56 <IanMc> just askin'
09:18:19 <magicman> For m1 `O` m2 to be a Monad (assuming Monad instances for m1 and m2), you must have a function m2 (m1 a) -> m1 (m2 a).
09:18:26 <mauke> IanMc: no one uses mirc (for certain values of "no one")
09:18:42 <kostja> is there a way to implement something like the syntactic sugar of "method" for comands?
09:19:06 <mauke> kostja: only the translation from do { ... } to >>= is; the Monad typeclass/>>= method come from a library
09:21:54 <magicman> kostja: Adding syntactic sugar... short of writing a preprocessor or hacking on the compiler, no.
09:22:46 <mauke> well, there's quasi-quotes
09:23:13 <magicman> Oh, right.
09:23:32 <magicman> Which is kind of a preprocessor with restricted scope, but I'll accept that as different enough.
09:24:02 <fruitFly> let l = [1,2,3,4,5,6,7] in l
09:24:06 <fruitFly> l
09:24:08 <fruitFly> ?
09:24:12 <circle> hey mauke
09:24:13 <circle> is
09:24:13 <circle> http://hpaste.org/89423
09:24:18 <circle> an acceptable type?
09:24:22 <magicman> @botsnack
09:24:22 <circle> for the aforementioned specification
09:24:40 <magicman> No lambdabot :(
09:25:01 <mauke> circle: no
09:25:19 <circle> oh sorry I didn't fix the first part
09:25:19 <fruitFly> what is wrong with: let case xs of _:secondToLastElement:[] -> print secondToLastElement
09:25:20 <circle> one sec mauke
09:25:21 <fruitFly> ?
09:25:40 <mauke> fruitFly: doesn't contain '='
09:25:48 <fruitFly> oh shit thanks
09:25:51 <fruitFly> mauke:
09:26:28 <magicman> And I'd name the thing secondOfTwo.
09:26:51 <circle> hey mauke, how about this? http://hpaste.org/89424
09:27:23 <mauke> better
09:27:53 <mauke> but not correct
09:27:54 <circle> It would be even better if I properly fixed it by making Film [FIlm] and documentary [Documentary]. Is that proper then?
09:28:03 <mauke> circle: "MusicDB" is the wrong name
09:28:23 <mauke> circle: your DB can store either a Film or a Documentary but not both
09:28:23 <circle> http://hpaste.org/89425
09:28:32 <circle> hmm
09:28:35 <fruitFly> x = let case xs of _:secondToLastElement:[] -> print secondToLastElement ... non exhaustive pattern in case?!
09:28:37 <mauke> circle: your DB can store either a [Film] or a [Documentary] but not both
09:28:48 <circle> mauke: true, what would be the best way to fix that?
09:28:55 <mauke> circle: [Char] is not an appropriate type for actors
09:29:15 <mauke> circle: your films only support a single genre
09:29:28 <circle> one sec, let me try fix it
09:29:53 <circle> http://hpaste.org/89426
09:30:04 <mauke> you can annotate your paste, btw
09:30:10 <circle> the bot seems to have failed
09:30:12 <circle> to work
09:30:14 <circle> so I didn't bother
09:30:18 <mauke> huh?
09:30:21 <magicman> fruitFly: Your pattern is equivalent to [_,secondToLastElement].
09:30:30 <circle> when I made the paste, the bot didn't submit it to this channel
09:30:33 <circle> so I assumed it wasn't working
09:30:35 <byorgey> a movie is a collection of films or a collection of documentaries?
09:30:46 <circle> byorgey: Yes.
09:30:53 <circle> byorgey: According to the specification for this, anyway.
09:30:57 <byorgey> ok.
09:31:01 <mauke> byorgey: no
09:31:04 <mauke> that's a bug
09:31:23 <circle> mauke: I fixed it, didn't I?
09:31:28 <circle> mauke: In the last paste I made.
09:31:33 <fruitFly> magicman: mauke how do I pattern match against the second to last element of a list?
09:31:57 <circle> A movie is either a film or a documentary, and the database is a collection of movies. Is that not right mauke?
09:32:04 <byorgey> circle: data Movie = ...  says that a single movie is either a list of films, or a list of documentaries
09:32:19 <byorgey> presumably you only want it to be *one* film or *one* documentary
09:32:22 <circle> Hmm, true
09:32:24 <circle> sorry
09:32:29 <circle> you're right
09:32:44 <byorgey> also, the spec says something about documentaries having multiple genres
09:32:58 <circle> http://hpaste.org/89426
09:33:01 <magicman> fruitFly: You can't do that with a single pattern like that, so you'll have to use recursion.
09:33:11 <circle> How's that?
09:33:17 <byorgey> closer
09:33:21 <byorgey> now what about multiple genres?
09:33:39 <circle> Hmm, yes, you're right
09:33:39 <circle> one sec
09:33:49 <fruitFly> magicman: you mean you only can patter match on the front? so i'll need to manually dig in to analyze the second to last element?
09:34:05 <circle> same link, now annotated, reload it
09:34:15 <magicman> fruitFly: Indeed.
09:34:32 <fruitFly> magicman: ok :)
09:34:34 <fruitFly> thanks
09:35:22 <byorgey> circle: ok, that's better.  two things remain: (1) a film is supposed to have *multiple* actors (2) it sounds like the genre types are supposed to be separate
09:35:30 <byorgey> i.e. documentaries have different genres than films
09:35:48 <circle> yeah I was thinking about tha t
09:35:51 <byorgey> circle: also, note that   String = [Char]
09:35:57 <circle> easier to have it the same though, but if I was making this for real I'd do that
09:36:03 <byorgey> so you could equivalently use String
09:36:13 <circle> Okay, also it'd be better if I made type Actor = String etc
09:36:24 <byorgey> circle: it's easier, but it doesn't accurately model the specification
09:36:32 <byorgey> circle: yes, good idea
09:39:11 <circle> byorgey:
09:39:17 <circle> I'm trying to load th is type and I get an erorr
09:39:25 <circle> parse error in constructor in data/newtype declaration: [Movie]
09:39:47 <byorgey> circle: ah, you have declared MusicDB with 'data', but it has no constructor
09:40:00 <byorgey> either give it a constructor, or change it to a type synonym
09:40:17 <circle> what do you mean by constructor?
09:40:47 <byorgey> Film', Documentary', Drama, Thriller, ...  are all constructors
09:40:58 <IanMc> I have a haskell question
09:41:09 <circle> byorgey: how did I not give it an constructor? how would I fix it?
09:41:10 <byorgey> circle: the format is   data TypeName = Constructor1 Type1 Type2 | Constructor2 Type3 | ...
09:41:11 <josephle> IanMc: and we have haskell answers!
09:41:34 <byorgey> circle: you have   data MusicDB = [Movie].   [Movie] is a type, but there needs to be a constructor in front of it
09:41:44 <circle> ah okay
09:41:49 <circle> I''ll juse use a type
09:42:09 <circle> I can use constructors as types
09:42:16 <IanMc> my question is, you know when you were young and you started to program, maybe in Pascal from the sound of it,,, and it changed the way you think.. Does Haskell do another mind change thing?
09:42:16 <circle> like I can use Documentary' as a type a function returns
09:42:19 <circle> right?
09:42:29 <byorgey> circle: no
09:42:40 <byorgey> IanMc: yes
09:43:05 <IanMc> so it changes your mind to think in yet another way?
09:43:23 <byorgey> yes.
09:43:30 <IanMc> can anyone sum that up?
09:43:56 <byorgey> sum up the new ways it teaches you to think?
09:44:03 <IanMc> yup
09:45:15 <byorgey> inductively, declaratively, equationally, typed, functionally.
09:45:22 <circle> byorgey
09:45:41 <circle> byorgey: If I have a "Movie", how do I tell if it's a documentary or a film?
09:45:50 <circle> byorgey: I know this sounds dumb, just getting bogged down in details
09:45:51 <byorgey> circle: by pattern-matching.
09:45:59 <circle> Is it just Movie == Documentary'?
09:46:07 <byorgey> no
09:46:12 <hobson> circle: laterally :)
09:46:15 <circle> how would I do it again?
09:46:24 <hobson> wrong person sorry
09:46:33 <byorgey> foo :: Movie -> ...;  foo (Film' f) = ... do something with f ...;  foo (Documentary' d) = ... do something with d ...
09:46:58 <byorgey> i.e. you define a function with two clauses, one for the case where you have a film and one for the documentary case
09:47:02 <circle> byorgey: ah yes, that makes sense
09:47:16 <circle> byorgey: stay around, I'm trying to make a function to list the documentaries that'll inevitably have a syntax error
09:48:00 <byorgey> I will probably be around most of the day.  There are also hundreds of other people in this channel who could help you as well. =)
09:50:01 <circle> byorgey: they haven't followed the chain though
09:50:01 <joelteon> there are 1032 people in this channel and at least 3 will be able to help
09:50:09 <circle> byorgey: it'll be hard getting them up to speed
09:50:15 <byorgey> circle: I doubt that.
09:50:30 <byorgey> circle: if you just paste your code many people will be able to quickly understand it and the problem.
09:58:25 <circle> byorgey: this function to get documentaries doesn't work: http://hpaste.org/89431
09:59:00 <byorgey> circle: guards are only for evaluating Boolean expressions, not for pattern-matching
09:59:12 <circle> byorgey: How would I implement what I want here?
09:59:16 <byorgey> circle: you can nest pattern matching
09:59:28 <byorgey> e.g. instead of just   (x:xs)  you can write   (Documentary' d : xs)
09:59:47 * hackagebot grid 6.1 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-6.1 (AmyDeBuitleir)
10:00:08 <circle> byorgey: that seems better, I'll try that
10:02:21 <circle> byorgey: fixed that, still doesn't work,http://hpaste.org/89431
10:02:46 <byorgey> circle: please be more specific than "doesn't work"
10:02:50 <circle> I've annotated the error
10:02:53 <byorgey> e.g. paste the error message along with the code
10:03:22 <circle> I've donate that, all in http://hpaste.org/89431
10:03:26 <circle> done*
10:03:42 <byorgey> yes, I see it now.  do you understand what the error message is saying?
10:03:59 <byorgey> circle: also, I note there is an error in your data types, which you fixed at one point but then un-fixed
10:04:10 <byorgey> maybe you accidentally used an older version or something
10:04:31 <circle> yes indeed
10:04:32 <circle> sorry
10:04:48 * hackagebot bitset 1.4.5 - A space-efficient set data structure.  http://hackage.haskell.org/package/bitset-1.4.5 (FedorGogolev)
10:04:52 <circle> now the error is different
10:04:53 <byorgey> I think at this point you should probably spend a bit more time banging your head against it.  Think carefully about what type you expect each variable to have.
10:04:55 <circle> I'll annotate it
10:05:01 <byorgey> and carefully read the error messages.
10:05:26 <byorgey> you will learn a lot more that way than if I just tell you what is wrong.
10:06:05 <byorgey> But I emphasize again that thinking about the *types* of everything is key.
10:06:12 <elliott> luite: is ghcjs able to compile ghc itself, into something workable? e.g. a purely client side GHCi.
10:06:15 <byorgey> Don't just think about what you expect the code to *do*.
10:06:17 <elliott> workable as in not ten gigabytes
10:06:23 <circle> I sort of get what's wrong but it isn't an algorithm problem it's a syntax problem
10:06:29 <circle> I can't really figure that out
10:06:34 <byorgey> circle: sure you can.
10:06:48 <circle> not really, since I'm not clear on the details of the syntax here
10:06:53 <byorgey> circle: it's not a syntax problem.  It is a type problem.
10:07:07 <circle> If I have a Documentary' d, is that a movie?
10:07:13 <circle> is it claiming that's not a movie?
10:07:28 <byorgey> Documentary' d :: Movie, yes.
10:07:57 <circle> But it says
10:07:58 <circle>     Couldn't match type `([Char], [Char], Int, [Genre])' with `Movie'
10:07:59 <circle>     Expected type: Movie
10:07:59 <circle>       Actual type: Documentary
10:07:59 <circle>     In the first argument of `(
10:08:02 <byorgey> it is claiming that d has type Documentary, but you have used d in a place where it is expecting a Movie.
10:08:11 <Mortomes> Documentary' is not a movie, it's a function [Documentary] -> Movie
10:08:17 <sclv_> ghci isn't mainly in haskell
10:08:22 <sclv_> so that's obstacle one :-)
10:08:34 <elliott> sclv_: right
10:08:44 <elliott> luite: sclv_: I mean more the GHC API
10:08:51 <byorgey> Mortomes: actually it's Documentary -> Movie now, circle fixed that
10:08:59 <elliott> luite: and I guess the ghcjs backend itself
10:09:06 <elliott> (so you can run the output)
10:09:06 <sclv_> but without an rts or interpreter then...
10:09:11 <byorgey> Mortomes: but in any case I don't think circle was asking about  Documentary'  on its own
10:09:22 <sclv_> haha ok i see just the subset necessary to generate js
10:09:23 <circle> I replaced 'd' with (Documentary' d)
10:09:27 <elliott> sclv_: well, the idea is you could run it through ghcjs, and then call eval.
10:09:27 <circle> and it seemed to work
10:09:38 * Mortomes re-reads the discussion.
10:09:48 * hackagebot som 4.2 - Self-Organising Maps  http://hackage.haskell.org/package/som-4.2 (AmyDeBuitleir)
10:11:00 <byorgey> circle: indeed. now, can you explain why?
10:11:17 <byorgey> circle: what type is d?  And what type is  (Documentary' d)?
10:12:20 <circle> d is a Documentary
10:12:34 <circle> (Documentary' d) is a Movie
10:12:38 <nal> hah, i see that the MonadZip people had intended a class Applicative f => Zippable f where ... that would have been amusing if <*> = ap were enforced
10:12:44 <byorgey> circle: right.
10:12:56 <byorgey> circle: and what type is the output of docs supposed to be?
10:12:57 <circle> Now, I'm trying to use my function, but it says I don't have a "Show genre"
10:13:16 <circle> a list of movies
10:13:22 <byorgey> circle: ghci uses the 'show' function to convert things to String to show them to you.
10:13:23 <circle> where would I put my deriving (Show)
10:13:35 <byorgey> circle: you can put that right after the data declaration
10:13:46 <byorgey> data Genre = Drama | .....    deriving (Show)
10:13:58 <byorgey> you can put it on the next line if you like (but it has to be indented)
10:14:57 <circle> byorgey: why is it put after the Genre data?
10:15:07 <circle> oh I get it
10:15:10 <circle> makes sense, sorry
10:16:19 <circle> byorgey: now I get:    No instance for (Show Movie) arising from a use of `print'
10:16:41 <byorgey> circle: I was afraid you were going to say that.
10:16:48 <byorgey> circle: figure it out yourself.
10:17:18 <byorgey> have you seen an error like that before?  how did we fix it?
10:17:20 <circle> added a deriving (Show) after the Movie definition and it worked
10:17:30 <circle> but your explanation for why Show exists doesn't fit that
10:17:40 <byorgey> doesn't fit what?
10:18:17 <circle> You say show is used to convert names like my genres to strings to print
10:18:29 <byorgey> it is used to convert any value to a String.
10:18:34 <byorgey> not just names.
10:18:45 <circle> oh
10:18:48 <circle> that makes more sense
10:18:50 <byorgey> I said '...to convert things to String...'
10:18:53 <circle> ok it all works
10:19:07 <circle> thank you for your help
10:19:09 <byorgey> great!
10:19:13 <byorgey> you're welcome
10:19:15 <nal> did the many on the lists go against making MonadPlus inherit from Alternative?
10:19:16 <circle> I'm gonna hit the sack, it's 3:30AM
10:19:36 <sclv_> elliott: we can always use emscripten to compile ghcjs :-P
10:19:48 <elliott> sclv_: hah
10:19:51 <sclv_> although self-hosting would obv be nice
10:20:00 <sclv_> someone used emscripten to compile fay at one point
10:20:06 <sclv_> can't imagine this is much worse
10:20:07 <elliott> sclv_: well, I am just musing about an in-browser REPL.
10:20:18 <elliott> I fear that it would be too slow, but perhaps I underestimate modern javascript engines
10:20:33 <sclv_> well with asm.js it should be decent
10:20:48 <applicative> me dimly remembers chris done compiling hugs into javascript
10:20:58 <sclv_> because asm.js is basically "take emscripten generated code and attempt to reverse what emscripten did"
10:21:26 <shachaf> applicative: That sounds like exactly the opposite of the direction you'd want to go. I'd much rather turn JavaScript into hugs.
10:22:11 <shachaf> sclv_: emscripten to compile ghcjs? How would that work?
10:22:23 <applicative> would be nice
10:22:42 <applicative> it's not in c
10:22:45 <applicative> or much of it not
10:23:07 <shachaf> Doesn't GHC do way too many architecture-specific things? Perhaps I don't understand emscripten.
10:23:19 <sclv_> schachaf: it just takes llvm bytecode to javascript
10:23:20 <sclv_> so...
10:23:36 <applicative> oh is that what emscipten really does?
10:23:46 <applicative> llvm-> js
10:24:15 <sclv_> if only there were some device you could query that confirmed that
10:24:26 <applicative> oh no thats what ghcjs does to get js?
10:24:27 <hamishmack> sadly emscriptem has no tail calls (setjmp etc. are not supported)
10:24:37 <sclv_> no thats what emscripten does
10:24:42 <applicative> ah
10:24:44 <sclv_> ghcjs compiles core to js
10:24:58 <sclv_> and attempts to not be dumb about it
10:24:58 <hamishmack> sclv_: STG
10:25:03 <sclv_> oh right, sorry :-P
10:26:25 <hamishmack> luite's new code gen is really exciting!
10:26:26 <kostja> is possible to implement state as a comonad? because functions compute values dependent on the input?
10:27:23 <anony> @src !
10:27:41 <sclv_> kostja: state doesn't obey the comonad laws
10:27:43 <anony> @src data
10:27:56 <sclv_> there's a dual to state, the "store" comonad though
10:28:00 <anony> \query lambdabot
10:28:12 <sclv_> anony what are you trying to do
10:28:12 <shachaf> Co Store = State!
10:28:21 <anony> how i call lambdabot?
10:28:30 <kostja> hm, ok, thank you
10:28:33 <silver> > id 1
10:29:01 <saml>  1
10:29:18 <magicman> lambdabot seems to be dead at the moment.
10:29:46 <sclv_> kostja: here's a non-comprehensive list of various things i know of that admit both monad and comonad instances: http://stackoverflow.com/a/16552594/371753
10:29:56 <sclv_> @bot
10:30:01 <sclv_> yeah, no bot
10:30:03 <saml>  I am bot
10:30:40 <anony> @bot
10:31:22 <sclv_> lambdabot isn't even on the channel
10:32:03 <anony> thanks
10:32:32 <sclv_> i blame shachaf
10:32:34 <anony> how i use data in Haskell?
10:32:48 <simukis_> invite goodfellow
10:34:53 <applicative> i wonder whether 'information preservation' in the sense of simonpj http://hackage.haskell.org/trac/ghc/ticket/4370     --  fmap snd (zip_ as bs) == bs
10:35:01 <applicative>     --  fmap fst (zip_ as bs) == as
10:35:22 <geekosaur> anony, I'm not sure what you're asking.
10:35:28 <applicative> is supposed to entail that an IO instance of fmap fst (zip_ as bs) wouldn't yield the effects of bs
10:35:33 <applicative> perform them rather
10:35:52 <geekosaur> ghci cannot create new data types, so you can't type a data declaration into it. (At least, not yet; I think there are some plans to change this.)
10:36:21 <geekosaur> you need to put the data declarations (and other declarations such as type or newtype) in a source file and :load it
10:36:32 <applicative> what are 'data' anony?
10:37:05 <applicative> anony: you should say a little more
10:37:15 <Fuuzetsu> uh, how on Earth does this even work? http://hpaste.org/89437
10:37:22 <Fuuzetsu> That type signature just doesn't match up…
10:37:45 <qwertzuiop> greetings
10:38:35 <applicative> Fuuzetsu: what do you mean, doesn't match up?  the definition is eta reduced if thats what your wondering
10:38:38 <applicative> or so it seems
10:38:41 <geekosaur> Fuuzetsu, it's eta reduced, the unwritten parameter is passed through to `go`
10:38:44 <geekosaur> heh
10:38:51 <applicative> collectDocs xs = go Nothing [] xs
10:39:14 <applicative> or is that to the point
10:39:36 <Fuuzetsu> oh
10:39:37 <Fuuzetsu> ohhhhhh
10:39:45 <supki> ghci supports data declarations since 7.4.1
10:39:46 <Fuuzetsu> it's collectDocs = go Nothing []
10:39:52 <Fuuzetsu> and not collectDocs go Nothing [] =
10:39:56 <Fuuzetsu> My bad
10:40:55 <Fuuzetsu> Maybe I shouldn't be reading code today…
10:42:05 <applicative> it is a little harder to read this way; it's likely a good idea here, since the definition is inlinable
10:42:50 <Fuuzetsu> No no, I know what it is and have no issue with it. I just seemed to have a special moment there. I do it myself.
10:45:11 <Fuuzetsu> To be fair though, I don't think I would write that function in the same way. I think pattern matching on all arguments would be cleaner seeing as that ‘where’ seems to do precisely that (although granted, I have no idea what optimisations GHC can make in these two situations)
10:46:37 <geekosaur> IIRC, if you eta reduce like that then it knows that it never needs to clone the eta-reduced parameter for any of the calls
10:47:11 <geekosaur> something like that, so it produces better code
10:52:35 <Fuuzetsu> All types have to start with capital letters, right? I have a [(LHsDecl a, doc)] here as a type though. TupleSections are on but I can't think about them affecting type signatures in any way.
10:52:56 <applicative> a and doc are type variables
10:53:54 <Fuuzetsu> …oh, of course. I guess I'm not used to type variables named anything but a, b, c, d, t1, t2…
10:55:28 <arkeet> that threw me off when there was a type variable in Data.Reflection called proxy
10:55:53 <Gracenotes> it can be useful if you have type variable soup
10:55:54 <edwardk> arkeet: it was designed to look like Proxy with a capital p
10:56:07 <arkeet> that was the source of confusion :P
10:56:16 <edwardk> i rarely use multi character variable names ;)
10:56:21 <arkeet> indeed.
10:56:37 <shachaf> edwardk: What do you do for types like Proxy (Succ a) -> Proxy a?
10:56:47 <edwardk> that API originally took a Proxy with an upper case P, then i switched it to lower as i didn't care what type provided the type argument. that actually enabled a lot more code to just pass something to 'reflect'
10:56:53 <applicative> proxy :: Proxy proxy; proxy = proxy
10:57:22 <edwardk> shachaf: data Succ a = Succ { runSucc :: a }        so use 'fmap runSucc'
10:57:27 <applicative> blah
10:57:39 <shachaf> edwardk: I mean, with polymorphic proxy.
10:57:52 <edwardk> shachaf: i take 'proxy a' and return 'Proxy a'
10:58:01 <glguy> edwardk: it worked nicely for my foldBy code because the proxy never escaped the module and was consumed immediately. I didn't have to provide any concrete type for it at all
10:58:03 <shachaf> Fair enough, I suppose.
10:58:07 <edwardk> shachaf: negative position proxies in my code are always with the lower case
10:58:14 <shachaf> An alternative would be to put a Functor constraint on proxy.
10:59:19 <edwardk> shachaf: i'd rather not because i often use it with a phantom type parameter for things like newtype Monoid_ a s = Monoid_ a
10:59:19 <tuo> hi
10:59:28 <edwardk> i _can_ make a Functor for that, but its kinda silly
10:59:44 <tuo> list
10:59:51 <edwardk> also i don't like passing unnecessary dictionaries
11:00:08 <edwardk> and it makes it so you wind up with extra dependencies on an unused argument making it harder for ghc to shuffle stuff
11:00:10 <b2coutts> is it just me or is vim's syntax highlighting for haskell extremely slow?
11:00:55 <shachaf> Fair enough.
11:01:55 <dolio> b2coutts: Which one?
11:02:03 <dolio> The one in vim2hs is pretty slow.
11:02:42 <b2coutts> dolio: whichever is the default in vim 7.3
11:03:01 <dolio> Not sure about that one. Haven't used it in a while.
11:03:59 <Fuuzetsu> I just found undefined to being used in Haddock's source ;_;
11:04:07 <Fuuzetsu> undefined being*
11:04:16 <applicative> > undefined
11:04:23 <applicative> must be undefined
11:04:24 <Fuuzetsu> no bots
11:04:27 <applicative> hm
11:04:27 <Fuuzetsu> he
11:05:05 * applicative cant seem to find a way to fit zippy applicatives with this new scheme at all
11:05:47 <Fuuzetsu> You have to stand up to your name and find the way.
11:05:58 <edwardk> applicative: what new scheme?
11:06:02 <applicative> a new class Zippable , which makes ParallelComprehensions , distinct from MonadComprehensions, would be cool
11:06:15 <applicative> edwardk: Applicative f => Monad f
11:06:25 <applicative> i have gien up opposing it
11:06:28 <edwardk> applicative: what about it?
11:06:39 <edwardk> ZipList doesn't break
11:06:46 <applicative> of course not
11:07:02 <edwardk> re zipping my old 'keys' package has a Zip class in it
11:07:06 <applicative> by I don't see why I should have to newtype to express this
11:07:22 <monochrom> undefined is useful for Storable's methods sizeOf and alignment
11:07:30 <applicative> yes, I'm thinking a class Zippable, with laws like those in Control.Monad.Zip
11:07:39 <Fuuzetsu> monochrom: doesn't make me dislike it any less
11:07:53 <edwardk> i have more painfully thought out laws in terms of distributive and representability elswhere
11:08:03 <applicative> then a blank class Monad m, Zippable m => MonadZip m with no interesting stuff
11:08:15 <monochrom> an alternative is type application
11:08:36 <elliott> monochrom: Storable should really use a proxy
11:09:03 <monochrom> (I haven't learned proxy)
11:09:12 <edwardk> why does MonadZip need to exist?
11:09:14 <applicative> edwardk: it doesn't matter to me, this,except where there is association with syntax
11:09:35 <edwardk> instead of just being those two constraints, i can't think of laws relating the Monad structure to the zipping
11:09:35 <applicative> edwardk, it controls parallel monad comprehensions
11:09:50 <arkeet> type Proxy = (->) Void
11:09:56 <applicative> edwardk: yes, this is my present point, if i have one
11:10:04 <edwardk> arkeet: blech. negative position Void
11:10:08 <arkeet> :(
11:10:22 <edwardk> negative position voids shouldn't be passed
11:10:30 <edwardk> type Proxy a = a
11:10:33 <edwardk> =)
11:10:41 <applicative> i am thinking the Parallel [ x + y | x <- zx | y <- zy ] business should have nothing to do with monads
11:11:29 <arkeet> I don't like zip.
11:11:47 <applicative> whie the [ y + 1 | zy <- zzy , y <- zy] needs 'monadic sequencing' blah
11:12:01 <applicative> zip is irrelevant.
11:12:10 <_justjust> elliott: proxy?
11:12:23 <applicative> it is the 'parallel' in 'parallellistcomp' that needs to be the main thing
11:12:36 <arkeet> sorry for just jumping in.
11:13:32 <applicative> then e.g. there could be out of the box an instance Zip IO where zip a b = runConcurrently (Concurrently  a ....) using the async lib
11:13:48 <applicative> something wierder for the par monad business
11:13:59 <Cale> arkeet: Why not?
11:14:41 <applicative> with an IO 'parallel monad comprehension' you wouldn't need forkIO and crap like that
11:14:42 <arkeet> well I mean it's useful and everything but it just feels wrong to use it with lists of different lengths
11:14:47 <applicative> this idea will end in disaster...
11:15:02 <elliott> _justjust: foo :: proxy a -> ...
11:15:03 <arkeet> I don't know if "wrong" is the right word.
11:15:11 <elliott> _justjust: rather than foo :: a -> ...
11:15:22 <applicative> Haskell would be the most avant garde language to express concurrency
11:15:30 <elliott> edwardk: what's wrong with negative voids?
11:15:39 <elliott> I would think the objection would be to ... -> Void
11:15:41 <elliott> since it could be ... -> a
11:15:57 <Fuuzetsu> arkeet: So it comes from the fact that lists can be of different lengths and you can't tell at compile time?
11:16:04 <arkeet> no
11:16:37 <arkeet> I just mean I don't like it theoretically.
11:17:46 <Fuuzetsu> Where is the dislike coming from? I guess you could restrict yourself to forall m. Monoid m, n => zipM :: (m -> n -> o) [m] -> [n] -> [o] or something so you don't lose anything
11:17:59 <applicative> its a pretty abstract idea really.
11:18:00 <Fuuzetsu> (ignore that forall)
11:18:43 <arkeet> I don't know if I can put it in words :p
11:18:58 <applicative> lists dont have anything to do with the laws fmap (first f)  (zip_ as bs) == zip_ (fmap f as) bs  ; fmap (second f) (zip_ as bs) == zip_ as (fmap f bs) ; fmap fst (zip_ as bs) == as     ;  fmap snd (zip_ as bs) == bs
11:18:59 <Fuuzetsu> Heh.
11:20:34 <edwardk> elliott: the issue is that a proxy is actually expected to be passed ;)
11:20:51 <edwardk> oh wait
11:20:56 <edwardk> (Void -> a) -> ...
11:20:59 <edwardk> nm =)
11:21:01 <elliott> arkeet's -- yeah
11:21:08 <edwardk> i just went back and reparsed it
11:21:12 <arkeet> yeah
11:21:42 <edwardk> anyways the main issue with that is it isn't obvious that that witness function is trivial to ghc
11:21:50 <edwardk> so more code gets called in the code path
11:21:56 <_justjust> elliott: what are the advantages of a proxy?
11:21:58 <arkeet> sure
11:22:02 <edwardk> because that witness could have extra effects
11:22:07 <elliott> _justjust: you don't have to pass undefined.
11:22:21 <arkeet> more importantly, you can't accidentally use what you're passed.
11:22:22 <elliott> _justjust: & you get assurance that it can't use the value
11:24:02 <_justjust> elliott: ok thanks
11:24:40 <rovar> hey all.  I have a simple websocket server which does:      msg <- WS.receiveData;      liftIO $ T.putStrLn msg
11:24:58 <applicative> yes rovar
11:26:06 <rovar_> erg
11:26:40 <rovar_> so as I was saying.. the incoming data doesn't get printed until I kill the server.. so either putStrLn is buffering in stdout.. or its being lazy
11:26:56 <rovar_> do I need to do anything special to force processing?
11:27:10 <Fuuzetsu> IIRC it buffers by default
11:27:19 <Fuuzetsu> (I'm not sure if that's the issue here though)
11:27:27 <arkeet> or the incoming data is being buffered?
11:28:20 <rovar_> I'm not sure
11:28:24 <rovar_> it's hard to test :)
11:28:32 <arkeet> does the data get printed when the connection is closed on the other end?
11:28:42 <rovar_> good question.. will test
11:29:17 <rovar_> no it does not
11:31:10 <applicative> i guess putting forkIO after liftIO wont help ;)
11:34:23 <functorfun> g'day
11:35:23 <applicative> these websockets types are a little rough
11:36:10 <functorfun> http://hpaste.org/89438 am I going about this in the right way?
11:37:31 <applicative> functorfun: arch x is the same as getArch no?
11:38:03 <functorfun> applicative: how do you mean?
11:38:22 <applicative> functorfun: arch is the 'accessor' for the ArchType field of Triple
11:39:05 <applicative> so you don't need lines 37 -45 , unless I am not getting something
11:39:36 <functorfun> applicative: I was wondering..
11:39:54 <functorfun> applicative: where does 'arch' come from?
11:40:02 <applicative> similarly the built in syntax for records such as it is might make setArch etc unneeded
11:40:04 <functorfun> because I derive show
11:40:17 <applicative> well I guess you see that, sorry, since you're using it
11:40:40 <applicative> what does Show have to do with it?
11:40:56 <functorfun> oops I loss focus I was looking at a different version :p
11:41:12 <nooodl> when you define "data Triple = Triple { arch :: ArchType, ... }" that "arch" already does what your "getArch" does
11:41:30 <applicative> nooodl is a little clearer, functorfun
11:41:31 <functorfun> ok so these mutators
11:42:50 <applicative> if you had lenses in the style of the lens library arch could do the work of both setArch and getArch of course and much more.
11:43:04 <applicative> but that's maybe not to the point at the moment
11:43:08 <nooodl> i was considering mentioning lenses but they're... yeah
11:43:10 <functorfun> yes I heard of lenses
11:43:28 <functorfun> I don't know if its a over kill?
11:43:54 <applicative> functorfun: it would depend what happens with the rest of the source whether there was any economy in it
11:44:08 <applicative> here we basically just have the types which look fine I guess
11:44:53 <applicative> functorfun: the question is, what you thought was wrong with it, though
11:44:55 <functorfun> I really just want to make sure I write this in a well styled way
11:45:35 <functorfun> its just been a while so I thought I would check first.. prob take me a couple of days to properly get going again
11:45:48 <applicative> it's fine functorfun, just the line 37 ff are redundant, the others 'setArch' make sense, if like my you don't like record update syntax
11:46:10 <applicative> man the typing there was a new low
11:46:56 <applicative> if you want to be able to 'set' without using record syntax, you need setArch etc; getArch & co are just unneeded. other than that, good module, I'd say
11:47:41 <functorfun> thanks
11:49:42 <functorfun> applicative: when I attempt to use a mutator though though ghci it just returns what it would set it to without changing the value. Why is that
11:50:14 <functorfun> i.e let x = defaultTriple then setArch AVR x and then arch x
11:50:44 <functorfun> does let make the type immutable?
11:51:06 <functorfun> sorry for all the dumb questions at the moment :p
11:52:05 <Fuuzetsu> I don't believe ‘mutable type’ is a thing.
11:52:40 <tdammers> 'mutable' isn't even a thing in Haskell
11:52:49 <functorfun> err object I mean! O_o
11:52:55 <magicman> It's immutable. There is no way to make it mutable without going into "code smell" territory.
11:52:56 <Fuuzetsu> No objects in Haskell.
11:53:22 <tdammers> to clarify: haskell is pure, so there are no syntax constructs to support mutable state
11:53:34 <magicman> Try "arch (setArch AVR x)", though.
11:53:40 <Fuuzetsu> You can define x to be something and it will always be that (unless you do something really nasty under the bonnet).
11:53:42 <functorfun> yes I was thinking about this
11:53:44 <tdammers> you can have functions that take a record type, and return a changed version of the original record
11:53:49 <functorfun> ah magicman got it!
11:53:52 <tdammers> these are sometimes called mutators
11:54:13 <functorfun> yea that makes more sense.. I understood the concept just not what I am doing
11:54:47 <functorfun> tdammers: well explained thank you
11:55:38 <tdammers> often you'd wrap such record types and the mutators in a monad, e.g. State; when you do that, mutation inside do notation looks very much like mutable state
11:55:54 <Fuuzetsu> (and confuses newbies to no end!)
11:55:58 <tdammers> but it's really not; it's just function-that-returns-modified-version-of-argument in disguise
11:56:03 <functorfun> Hmm that maybe a good idea tdammers
11:56:13 <tdammers> I think you're not there yet
11:56:23 <tdammers> just play around with plain functions for now
11:56:26 <Fuuzetsu> functorfun: Perhaps you could tell us what your problem statement is.
11:56:35 <shachaf> lens has a type called Mutator: newtype Mutator a = Mutator {runMutator :: a}
11:56:44 <shachaf> It has nothing to do with mutation.
11:56:51 <shachaf> Perhaps that is the source of confusion.
11:57:02 <functorfun> I understand, its more the syntax sugar at the moment, its been quite awhile since I played in haskell properly
11:57:53 <functorfun> Fuuzetsu: More just feedback on my initial attempt at thinking again.. I have some ideas now
11:58:38 <Fuuzetsu> Cool.
11:59:18 <functorfun> tdammers: In regards to the monad, would we somehow bind the mutator functions and return as record values
11:59:53 <functorfun> OK, I know monads mathematically just work with me here programmatically sorry.
11:59:54 * hackagebot yesod 1.2.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.2.1 (MichaelSnoyman)
11:59:56 * hackagebot yesod-bin 1.2.0.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.0.1 (MichaelSnoyman)
11:59:58 * hackagebot yesod-core 1.2.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.2 (MichaelSnoyman)
12:00:00 * hackagebot yesod-persistent 1.2.1 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-1.2.1 (MichaelSnoyman)
12:00:02 * hackagebot yesod-routes 1.2.0.1 - Efficient routing for Yesod.  http://hackage.haskell.org/package/yesod-routes-1.2.0.1 (MichaelSnoyman)
12:01:31 <tdammers> functorfun: no, it's more like the monad hides the state variable and carries it from one action to the next behind the scenes
12:01:44 <tdammers> and you can access it through functions specific to this monad
12:01:57 <tdammers> e.g. in State, you have get and modify
12:02:02 <tdammers> :t modify
12:02:17 <Fuuzetsu> no bots
12:02:19 <tdammers> ah
12:02:21 <tdammers> right
12:02:32 <Fuuzetsu> I hope lambdabot is okay.
12:02:44 <functorfun> tdammers: yea, it acts like a kind of state machine well more a model for a computational unit or theory something like that..
12:03:09 <tdammers> well, when you add lens to the mix, stuff can look really imperative
12:03:10 <Fuuzetsu> based shachaf
12:03:16 <functorfun> I get that, how to actually do it though.. I make a new one using the monad type class or something
12:03:17 <shachaf> @admin + Cale
12:03:19 <shachaf> @admin + elliott
12:03:35 <Fuuzetsu> :t modify
12:03:36 <kappabot> forall s (m :: * -> *). MonadState s m => (s -> s) -> m ()
12:03:37 <tdammers> well, you could start out by using Control.Monad.State
12:04:22 <functorfun> tdammers: thanks i'll have a crack at it
12:04:26 <Fuuzetsu> shachaf: is kappabot a fork of lambdabot or is it a whole new code base?
12:04:36 <tdammers> > runState (modify (+1)) 23
12:04:38 <kappabot>   ((),24)
12:04:49 * eikke used lens & RWST in Kontiki to get an imperative-looking implementation
12:04:50 <tdammers> > runState (modify (+1) >> modify (+10)) 23
12:04:51 <kappabot>   ((),34)
12:05:07 <tdammers> > runState do { modify (+1); modify (+10) } 23
12:05:09 <kappabot>   <hint>:1:10: parse error on input `do'
12:05:20 <tdammers> > runState (do { modify (+1); modify (+10) }) 23
12:05:21 <kappabot>   ((),34)
12:05:22 <Fuuzetsu> eikke: I don't think that an imperative looking implementation is a virtue…
12:05:31 <eikke> Fuuzetsu: it actually is in there
12:05:48 <tdammers> well, the imperative look can be deceptive
12:05:57 <eikke> because an FSM transition (and construction of side-effects) is pretty imperative
12:06:13 <tdammers> > runState (do { return (); modify (+1); modify (+10) }) 23
12:06:14 <kappabot>   ((),34)
12:06:33 <tdammers> > runState (do { return 1; modify (+1); return 2; modify (+10) }) 23
12:06:34 <kappabot>   ((),34)
12:06:57 <tdammers> see how the imperative look can be confusion if you don't know what's *really* happening here?
12:07:17 <tdammers> > runState (do { return 1; modify (+1); return 2 }) 23
12:07:18 <kappabot>   (2,24)
12:07:50 <eikke> tdammers: real code eg @ https://github.com/NicolasT/kontiki/blob/master/src/Network/Kontiki/Raft/Candidate.hs#L32
12:19:27 <tdammers> eikke: right.
12:20:59 <efie> hi, when is Vector from Data.Vector.Unboxed in WHNF? are values inside the vector forced to be evaluated?
12:21:17 <tdammers> here's an example from my own code:
12:21:19 <tdammers> https://bitbucket.org/tdammers/brahsah/src/97bf54cf5023b497aaa1a6c711974aef912348a6/Browser.hs?at=master#cl-112
12:21:20 <applicative> efie: they'd have to be
12:21:44 <applicative> efie: by contrast Data.Vector vectors are made of pointers to things that can be in various states of developemnet, so to say
12:22:44 <applicative> efie do you have some code that seems not to be working properly
12:23:53 <eikke> tdammers: ah, you mix 'real' IO
12:24:05 <applicative> efie: but in Data.Vector.Unboxed, the values stored in the vector are unboxed
12:24:16 <tdammers> eikke: I'm that hardcore ;)
12:24:24 <eikke> tdammers: in the code I referred to, things like 'resetElectionTimeout' only result in something to be added to the writer part of the underlying RWST
12:24:29 <applicative> efie, there can be an uninitialized vector or however you put it, in Data.Vector.Unboxed.Mutable
12:24:56 <tdammers> eikke: yeah, this example is more like ErrorT BrowserError (StateT BrowserState IO)
12:25:28 <efie> applicative: in my code a vector from Data.Vector is updated over and over again; therefore the memory grew, and I added the strictness annotation ! to the vector field in my data type... now the memory is constant and the program is even faster. I didn't expect this because I thout that the Vector would be just evaluated to something like VECTOR [ ... -- not evaluated values]
12:25:37 <shachaf> kappabot is lambdabot
12:25:42 <BadRadish> what does <- do?  I'm not able to find much good information on it.  I just was wondering if anyone could give me a simple explanation.
12:25:47 <BadRadish> or a link to a tutorial?
12:25:56 * hodapp reads about reactive programming
12:25:58 <hodapp> this is... a neat concept
12:26:16 <Fuuzetsu> < let α = 1 in α
12:26:21 <applicative> efie: this maybe the to do with the succession of different vectors, not with the elements in the vector?
12:26:36 <byorgey> BadRadish: it doesn't "do" anything.  It is part of do-notation syntax, and also list comprehension syntax.
12:26:45 <Fuuzetsu> < 1
12:26:49 <Fuuzetsu> uhh
12:26:53 <Fuuzetsu> > 1
12:26:53 <tdammers> BadRadish: I assume you are referring to <- in do synta
12:26:54 <kappabot>   1
12:26:56 <byorgey> BadRadish: so if you want to understand it you have to read about those things
12:27:02 <Fuuzetsu> > let α = 1 in α
12:27:03 <applicative> efie: maybe with the source someone could say something clear
12:27:03 <kappabot>   mueval-core: Enum.toEnum{Word8}: tag (945) is outside of bounds (0,255)
12:27:21 <BadRadish> byorgey: ah yes thank you
12:27:22 <byorgey> woah, nice error message kappabot
12:27:28 <tdammers> do { x <- foo; bar x } desugars into foo >>= \x -> bar x
12:27:39 <Fuuzetsu> I'm sure it used to do Unicode before… Or was it some other bot…
12:27:56 <tdammers> (which is just foo >>= bar, but that's kind of beside the point
12:28:00 <shachaf> It used to do Unicode before.
12:28:06 <applicative> ... which then compiles to something like do {x <- foo; bar x}
12:28:20 <Fuuzetsu> Can you expand on why it doesn't anymore?
12:28:58 <BadRadish> tdammers: oh its sugar okay thanks
12:29:05 <applicative> there were always plenty of characters mueval rejected,no?
12:29:09 <shachaf> I don't know why it doesn't anymore.
12:29:15 <applicative> or maybe it woudnt send them back
12:29:33 <Fuuzetsu> > "β"
12:29:34 <kappabot>   mueval-core: Enum.toEnum{Word8}: tag (946) is outside of bounds (0,255)
12:29:39 <Fuuzetsu> pretty sure it did that, applicative
12:29:49 <Fuuzetsu> (did that fine, that is)
12:29:49 <applicative> > char 946
12:29:51 <kappabot>   No instance for (GHC.Num.Num GHC.Types.Char)
12:29:51 <kappabot>    arising from the literal `9...
12:29:59 <applicative> > chr 946
12:30:00 <kappabot>   '\946'
12:31:20 <shachaf> > text "\945"
12:31:21 <kappabot>   α
12:31:30 <applicative> yes, there you are
12:31:42 <applicative> that woudl work in the past, but other things not
12:31:50 <applicative> > text "\2945"
12:31:50 <kappabot>   mueval: Most RTS options are disabled. Link with -rtsopts to enable them.
12:32:02 <shachaf> No, input of α would work fine in the past.
12:32:09 <applicative> > text [maxBound :: Char]
12:32:09 <kappabot>   mueval: Most RTS options are disabled. Link with -rtsopts to enable them.
12:32:15 <applicative> shachaf: yes I know that
12:32:24 <elliott> I like this kappabot error
12:32:41 <Fuuzetsu> I think RTS had to be disabled in the last set of mueval issues.
12:32:52 <Fuuzetsu> At least I remember Cale mumbling something about RTS.
12:32:55 <applicative> my thought was, it didn't do unicode generally, but drew the line somewhere
12:33:44 <Fuuzetsu> :t ydws &maxBound
12:33:47 <kappabot> Not in scope: `ydws'
12:33:47 <Fuuzetsu>  oops
12:33:54 <Fuuzetsu> :t (maxBound :: Char)
12:33:55 <applicative> > text $ map chr [2000..2010]
12:33:57 <kappabot>   ߐߑߒߓߔߕߖߗߘߙߚ
12:33:57 <kappabot> Char
12:34:19 <applicative> not bad
12:35:08 <shachaf> OK, this bug is in mueval.
12:35:27 <joelteon> :i (&)
12:36:02 <shachaf> :i doesn't work with lambdabot and has never ever worked with lambdabot ever.
12:36:20 <mgsloan> :bro
12:36:48 <applicative> > text $ map chr [1000..1033]  -- not bad
12:36:52 <joelteon> oh yeah
12:36:59 <Fuuzetsu> applicative: shachaf killed it
12:37:04 <joelteon> shachaf: sorry, reflex
12:39:29 <monochrom> > text "昌“
12:39:30 <eikke> > let f x = f x in f ()
12:39:44 <monochrom> ooohhh, the bot left
12:40:09 <Clint> "the bot"
12:40:47 <applicative> the right quote was a little suspicious anyway monochrom
12:41:18 <shachaf> I know what will make shapr happy.
12:42:19 <johnw> shachaf: oh, what?
12:43:27 <Luke> anyone know Gershom's handle?
12:43:34 <edwardk> sclv
12:43:35 <luite> sclv
12:43:36 <shachaf> Luke: Bazerman? sclv
12:43:38 <Luke> yeah
12:43:41 <Luke> htanks
12:43:48 <shachaf> I guess there aren't that many Gershoms.
12:43:49 <Luke> sclv: now that you've been pinged a few times, you here?
12:43:55 <Luke> right =)
12:44:56 <Luke> sclv: ah nevermind =) sorry ;-)
12:45:07 <applicative> Scholem's nick was sabbatai
12:52:16 <sclv_> someone pinging me?
12:52:29 <Luke> sclv_ yeah me
12:52:35 <Luke> i'm messing with JMacro
12:52:40 <sclv_> ok
12:52:49 <Luke> I'm doing JS templating basically
12:52:58 <shachaf> > text "α β"
12:52:59 <kappabot>   α β
12:53:09 <sclv_> applicative: maybe is should move to sabbatai :-)
12:53:23 <sclv_> ok, go on
12:53:29 <Luke> sclv_ i want to insert a value, which I've figured out how to do with JMacro, but i'm not sure if there's a way to have a huge predefined  JS file
12:53:54 <Luke> sclv_: https://heapanalytics.com/docs
12:54:08 <Luke> that's what I'm doing
12:54:56 * hackagebot saltine 0.0.0.1 - A Haskell libsodium binding  http://hackage.haskell.org/package/saltine-0.0.0.1 (JosephAbrahamson)
12:55:10 <sclv_> ok i'm not sure the question still
12:55:32 <Luke> sclv_ yeah that's my fault =) basically I want to open a JS file and use it as a template with JMacro. can I do that?
12:56:05 <sclv_> erm, not out of the box.
12:56:24 <Luke> ok that's ok. just wanted to know if that was a sane thing to try and do with it
12:56:28 <sclv_> you can open it, parse it, traverse the tree to substitute
12:56:34 <sclv_> then write it out again
12:56:35 <Luke> yeah ok that's what I thought
12:56:48 <sclv_> shouldn't be hard, actually
12:57:00 <Luke> I'll ping you again if I need help going that route. I may try something else
12:57:07 <sclv_> but if you just want pure templating, i'd use like hstringtemplate
12:57:17 <Luke> sure sure. ok thanks
12:57:28 <Luke> you coming to hacphi?
12:57:31 <sclv_> and if you want to shove generated js in, then use a template system + jmacro
12:57:37 <sclv_> yeah, gonna be at hacphi
12:57:44 <Luke> ok cool - see you tomorrow then =)
12:57:48 <Luke> or sat
12:58:10 <FreeFull> I bet kappabot has vulnerabilities
12:58:18 <sclv_> also, its maybe much saner just to generate and name your substitutions using jmacro, then include that script before the script that just makes reference to the bits defined in jmacro
12:58:41 <Luke> sclv_ that's what my next approach was going to be
12:58:41 <sclv_> that's probably the most elegant solution
12:58:51 <sclv_> cool -- see you there
12:58:55 <Luke> that way I can generate the whole thing separately
12:58:58 <Gracenotes> hacphi, eh
12:59:02 <Gracenotes> I coulda made that, probably
12:59:11 <Gracenotes> well, if I wasn't very busy packing and whatnot
12:59:15 <FreeFull> > fail "3"
12:59:17 <kappabot>   No instance for (GHC.Show.Show (m0 a0))
12:59:17 <kappabot>    arising from a use of `M98064497...
12:59:22 <FreeFull> > fail "3" :: IO ()
12:59:23 <kappabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
12:59:24 <kappabot>    arising from a use of ...
12:59:49 <Gracenotes> λ > κ
13:01:33 <FreeFull> > 'λ' > 'κ'
13:01:35 <kappabot>   True
13:01:43 <FreeFull> Gracenotes: I guess you're right
13:04:57 * hackagebot yesod-platform 1.2.1 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.1 (MichaelSnoyman)
13:24:58 * hackagebot pipes-aeson 0.1.0.0 - Encode and decode JSON streams using aeson and pipes.  http://hackage.haskell.org/package/pipes-aeson-0.1.0.0 (RenzoCarbonara)
13:27:40 <magicman> ... beautiful.
13:27:55 <magicman> pipes-aeson. Yet another thing I was hoping would exist.
13:30:37 <alpounet> there even is a pipes-postgresql-simple in the works
13:30:59 * byorgey is waiting for  lens-yesod-pipes-snap
13:31:31 <magicman> :D
13:32:11 <alpounet> yeah
13:32:20 <alpounet> why not name a package after the list of its dependencies, right?
13:32:37 <magicman> Because base.
13:33:04 <ocharles> alpounet: sssssh
13:33:05 <ocharles> :)
13:33:22 <elliott> byorgey: that package would have a single definition
13:33:26 <elliott> but its type would run to three pages
13:33:32 <elliott> (its documentation, three lines)
13:33:38 <ocharles> elliott: is "halfLife3"?
13:33:40 <ocharles> is it*
13:33:59 <elliott> ocharles: "dwim"
13:34:29 <ocharles> the magical "left as exercise for reader" solver
13:47:37 <magicman> Type signatures of three pages. Makes http://hackage.haskell.org/packages/archive/AspectAG/0.3.6.1/doc/html/Language-Grammars-AspectAG.html#v:graft look like a cakewalk.
13:49:37 <elliott> magicman: ha, jeez
13:49:39 <elliott> it's not even inferred
13:51:46 <sclv_> reminds me of that fake article describing haskell as having exactly one operator, with the type signature:
13:51:50 <sclv_> pSwitch :: Functor col         => (forall sf. (in -> col sf -> col (ext, sf)))         -> col (SF ext out)         -> SF (in, col out) (Event mng)         -> (col (SF ext out) -> mng -> SF in (col out))         -> SF in (col out)
13:52:42 <magicman> *please* tell me you copy-pasted that.
13:53:21 <ciaranm> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
13:53:23 <kappabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
13:53:23 <kappabot> t63 t64 t65 t66 t67 t68 t69. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -
13:53:23 <kappabot> > t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 ->
13:53:23 <kappabot> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40,
13:53:23 <kappabot>  t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64, t65, t66, t67, t68, t69)
13:53:27 <josephle> magicman: I can't imagine he'd deliberately add that many spaces
13:53:35 <magicman> True :p
13:53:51 <hseg> Hey, what happened to lambdabot?
13:54:38 <sclv_> if we had proper syntax for the hlisty stuff that AspectAG does, then that wouldn't look to bad, actually
13:54:41 <geekosaur> got lost during yesterday's netsplits, and nobody's had a chance to restart it yet. I think
13:55:19 <hseg> OK, so kappabot is the secondary lambdabot?
13:55:27 <sclv_> oh and rule itself is a total mess: http://hackage.haskell.org/packages/archive/AspectAG/0.3.6.1/doc/html/Language-Grammars-AspectAG.html#t:Rule
13:56:20 <magicman> No, that's nice and symmetric.
13:56:27 <sclv_> no one type should have all those variables
13:57:05 <magicman> Yeah, I understand why it has that many, but Fam doesn't seem that mad.
13:57:17 <magicman> Wait. Fam is basically a 4-tuple.
13:57:32 <magicman> With a bunch of instances.
13:57:55 <sclv_> hahaah
13:58:13 <sclv_> stuff like this is where i feel like if you didn't have papers to write, you really should have just stopped
13:58:33 <magicman> (instances that make a horizontal scroll bar appear, sure, but hey)
14:05:00 * hackagebot rdioh 0.1.2 - A Haskell wrapper for Rdio's API.  http://hackage.haskell.org/package/rdioh-0.1.2 (AdityaBhargava)
14:20:01 * hackagebot hlint 1.8.46 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.46 (NeilMitchell)
14:24:12 <kayloos> I got a question that I've been wrestling with for a few hours: How do I unpack an IO (Either Fail a) type in a function of type :: IO (), and *just* bind it to a variable, instead of putting everything inside the (case). I have put an example here: http://hpaste.org/89443
14:25:12 <ParahSailin> you gotta use >>=
14:26:03 <johnw> bind the result of runQuery to another variable, and then "case" on that, like: let nrPosts = case myVar of ...
14:26:25 <kayloos> ahh
14:26:30 <johnw> oh, I see, you did just that above :)
14:26:32 <kayloos> use let? ok. let me see if i can figure it out
14:26:34 <johnw> anyway, that's how I would do it
14:26:51 <johnw> there is no "caseM", which is what you're wanting
14:27:00 <johnw> (I've wanted it many times too, so I know just where you're coming from)
14:27:07 <ParahSailin> runQuery pipe countPosts >> \x -> case x of ...
14:30:08 <elliott> >>= not >>
14:30:11 <kayloos> ParahSailin: the idea is that i want several runQuery statements (do multiple different queries), have them each in a bound variable, and then render a template with all the variables in a dictionary. Isn't what you're suggesting only allowing for 1 such variable?
14:33:42 <kayloos> johnw: so: do { let nrPosts = runQuery ... ; nrPosts' <- case nrPosts of ... ; use vars here } ?
14:34:10 <ParahSailin> thats isomorphic
14:34:55 <kayloos> ??
14:36:22 <ludovica> bye!!!!!!!!!!!Do you speack italian?
14:38:43 <kayloos> ??
14:38:49 <kayloos> sry wrong window
14:39:05 <ParahSailin> liftIO $ do { q <- runQuery ...; case q of {...} }
14:39:40 <koninkje> augur_: a journal about what?
14:40:16 <augur_> koninkje: foundational issues in linguistic theory/s-side stuff
14:41:06 <koninkje> hmm. could be interesting
14:41:34 <augur_> koninkje: and itll be totally beautiful, of course
14:41:45 <augur_> great design, great typesetting
14:43:07 <koninkje> :)
14:43:18 <koninkje> I am a sucker for good typesetting
14:43:47 <kayloos> ParahSailin: Ahh thanks, that seems like a nice way of doing it.
14:44:03 <augur_> koninkje: ive been trying to figure out how to state the core of syntactic theory in a formalism-neutral way. its really difficult
14:44:16 <kayloos> and i mean thanks, i've been like a airhockey puck lost in hackage.haskell.org
14:44:50 <koninkje> augur_: talking about the difficulties of doing so would make for a good opening post
14:45:11 <augur_> koninkje: i dont even know how to talk about the difficulties. lol
14:45:19 <koninkje> lol
14:46:10 <augur_> koninkje: so little in this domain has been thought about. its really easy to just throw around formalisms that foundational stuff is completely bipassed usually
14:47:15 * koninkje nods
14:50:03 * hackagebot rdioh 0.1.3 - A Haskell wrapper for Rdio's API.  http://hackage.haskell.org/package/rdioh-0.1.3 (AdityaBhargava)
14:51:19 <yogert> Hey, sorry for the question, but i can't seem to find an explanation of this anywhere else.. How can I compile when using libraries provided by cabal-dev? I've to use the -i flag on GHC, but that doesn't seem to be the correct way
14:52:34 <bitonic> yogert: ‘cabal-dev build’?
14:54:33 <yogert> well what if I want to compile a single file in the directory… ? I apologize if this is a bad question, I probably haven't acquainted myself  well enough with how packaging in Haskell works out.
14:54:48 <deggis> yogert: or if you have a cabal-dev folder full of compiled libs you want to use elsewhere with, use ghc -package-db=/path/to/cabal-dev/packages-7.6.2.conf File.hs
14:55:03 <yogert> ah package db
14:55:12 <yogert> okay thanks for the tip
14:55:29 <deggis> i use package-db frequently with ghci as "cabal-dev ghci" didn't work always
14:58:04 <yogert> deggis: did you mean -package-conf?
14:58:20 <yogert> db doesn't appear to be an option, and conf worked for me
14:59:37 <deggis> woops, with ghc 7.4.* it was package-conf? forgot that
15:00:05 <deggis> close, but no cigar :)
15:00:23 <yogert> whats the latest version?
15:00:33 <yogert> oh 7.6.2?
15:01:22 <geekosaur> 7.6.3
15:08:04 <Xaseron> hi, i have problem with my program and i don't understand the compile error :-( could someon help? http://pastebin.com/nbSL8ZR1
15:08:10 <mauke> The paste nbSL8ZR1 has been copied to http://hpaste.org/89447
15:08:34 <mauke> what error?
15:09:47 <geekosaur> or do you mean the hlint error (which is not a compile erorr; it's just pointing out that do { t
15:09:49 <geekosaur> oops
15:10:04 * hackagebot monadcryptorandom 0.5.2 - A monad for using CryptoRandomGen  http://hackage.haskell.org/package/monadcryptorandom-0.5.2 (ThomasDuBuisson)
15:10:20 <Xaseron> http://hpaste.org/89448
15:10:30 <geekosaur> do { t' <- intifyTree t'; return t' } is the same as intifyTree t'
15:10:33 <geekosaur> er
15:10:38 <geekosaur> I canot type today
15:10:43 <geekosaur> do { t' <- intifyTree t; return t' } is the same as intifyTree t
15:10:51 <monochrom> which line is line "98"?
15:11:33 <FreeFull> You could even rewrite infityList as    intifyList = (>>= intifyTree)
15:13:19 <monochrom> err, "95"
15:14:40 <DanBurton> hrm, why doesn't hlint suggest "do {x <- m; return x}" ==> "m"
15:15:06 <monochrom> because hlint is incomplete or inconsistent
15:15:55 <Xaseron> http://hpaste.org/89450 http://hpaste.org/89451
15:17:30 <DanBurton> what's with the impredicative types extension?
15:17:44 <shachaf> It doesn't work.
15:18:00 <shachaf> Or rather it works differently in every GHC release, mostly by accident or something.
15:18:10 <shachaf> Impredicative types would be great. :-(
15:18:36 <DanBurton> which is why I raise an eyebrow upon seeing the extension enabled in that hpasted code
15:19:35 <Xaseron> without the extension i get the same error
15:22:48 <DanBurton> intifyList = (>>= intifyTree) expects a State input, which does not match the provided type signature
15:23:10 <shachaf> Oh, you were asking about the code.
15:24:17 <monochrom> it is the same kind of type errors you would get from: [1,2,3] >>= runState blah blah
15:24:59 <monochrom> it is not making up your mind whether you want the [] monad or the State Whathaveyou monad.
15:40:05 --- mode: cameron.freenode.net set +o ChanServ
15:42:23 <johnw> > 2 `asTypeOf` 1.0
15:42:24 <kappabot>   2.0
15:42:41 <eikke> :t asTypeOf
15:42:42 <kappabot> forall a. a -> a -> a
15:42:54 <eikke> > () `asTypeOf` 1
15:42:55 <kappabot>   No instance for (GHC.Num.Num ())
15:42:55 <kappabot>    arising from the literal `1'
15:42:55 <kappabot>  Possible ...
15:44:10 <Ghoul_> :t Ptr ()
15:44:11 <kappabot>     Not in scope: data constructor `Ptr'
15:44:11 <kappabot>     Perhaps you meant one of these:
15:44:12 <kappabot>       `Str' (imported from Text.PrettyPrint.HughesPJ),
15:44:16 <Xaseron> DanBurton: thx for your help. i didn't know that i can't mix monads. my code is working now :-)
15:44:29 <Ghoul_> Is it valid to make a void ptr
15:44:41 <hpc> Xaseron: when in doubt, use the types
15:44:50 <hseg> Xaseron: The fact that you can't mix monads arises from the type signatures of most monadic combinators.
15:44:51 <hpc> Ghoul_: a pointer of () is very different from a void pointer
15:45:01 <Ghoul_> How so
15:45:25 <DanBurton> Xaseron: =) However, you can "mix" monads via monad transformers. A learning topic for another day, perhaps.
15:45:36 <Ghoul_> I'm talking about C void pointer or void*
15:45:44 <hpc> if we go for its intended purpose in C, as a nasty form of polymorphism
15:45:45 <Ghoul_> :)
15:45:58 <hpc> a better analogy would be forall a. Ptr a
15:46:04 <hseg> For example, (>=>) :: (a -> m b) -> (b -> m c) -> (a -> m c). Since the m is the same in all three components, the monad all three components use must be the same
15:46:13 <Ghoul_> Oh just because I only want to use it for pointer arith
15:46:39 <hpc> i don't think Ptr does pointer arithmetic
15:47:05 <Ghoul_> I don't know how to use the for all stuff
15:47:42 <Siod> s
15:48:35 <DanBurton> @hoogle plusPtr
15:48:35 <kappabot> Foreign.Ptr plusPtr :: Ptr a -> Int -> Ptr b
15:48:49 <DanBurton> wheeee pointer arithmetic
15:49:25 <c_wraith> I'm a little confused that it's also pointer type conversion
15:49:31 <Ghoul_> Oh wow it gives a cast ptr too
15:49:39 <Ghoul_> Did not expect that
15:49:58 <hpc> i suppose at that low a level, no types are sacred
15:50:16 <Ghoul_> Look s dangerous
15:50:20 <c_wraith> Ghoul_: the FFI really does let you write C in haskell. It's just incredibly verbose.
15:50:27 <josephle> hpc: assembly is the one true language, and void* is its prophet.
15:50:28 <c_wraith> Ghoul_: and, well, yes.  As dangerous as C
15:50:31 <DanBurton> yeah, that API is pretty much no-type-safety-land.
15:51:01 <Ghoul_> Does it generate code as fast as the c equivalent
15:51:07 <Ghoul_> -
15:51:59 <KingofFerrets> I'm /pretty sure/ you're wrong and assembly is Satanic, josephle.
15:52:12 <FreeFull> I have written assembly and it's not satanic
15:52:33 <josephle> KingofFerrets: assembly does *exactly* what you tell it to do
15:52:47 <DanBurton> just like every other well-defined language
15:52:48 <josephle> full programmer control! what could go wrong?
15:52:55 <KingofFerrets> It's totally satanic.
15:52:57 * Ghoul_ is a reverse engineer and disagrees assembly is evil
15:54:40 <hpc> does a reverse engineer take a working system and turn it into a critical problem?
15:56:39 --- mode: cameron.freenode.net set +o ChanServ
15:56:49 <FreeFull> So instead the programmers optimise their code themselves and you end up with horrible code
15:57:03 <Ghoul_> Hmm hope it's not too bad :p
15:57:14 <hpc> i missed a lot of that in the netsplit
15:57:18 <hpc> 19:01  * Ghoul_ is a reverse engineer and disagrees assembly is evil
15:57:21 <hpc> 19:01 -!- Netsplit *.net <-> *.split quits: lahwran, kixcereal, monochrom, ousado, pdxleif, dgpratt, redjohn, brixen, saiam, Sebastien-L,  (+962 more, use /NETSPLIT to show all of them)
15:57:25 <hpc> 19:03 < hpc> does a reverse engineer take a working system and turn it into a critical problem?
15:57:34 <DanBurton> Speaking of manually-optimized ugly code.. have you seen the lens library source lately? >.>
15:57:56 <shachaf> DanBurton: Which source in particular?
15:57:59 <FreeFull> I've never looked at lens's source code
15:58:05 <shachaf> There's a lot of room for optimization left.
15:58:18 <c_wraith> Good libraries in any language tend towards ugly. The important part is the public interface they provide
15:58:26 <shachaf> In one place we have a solution which is asymptotically better but has a 1000x constant factor for the common case. :-(
15:58:39 <Peaker> shachaf, where is that?
15:58:45 <shachaf> lastOf
15:59:18 <FreeFull> shachaf: Can't you just switch algorithms based on if the case is common or not
15:59:29 <johnw> shachaf: your (Co)Yoneda explanation is being retold to others :)  I would love a blog post to point them to!
15:59:53 <Ghoul_> hpc: I'm dealing with binary files
15:59:54 <shachaf> https://github.com/ekmett/lens/issues/245
15:59:59 <shachaf> FreeFull: Nope.
16:00:00 <Ghoul_> Not hand optimization
16:00:37 <Ghoul_> (Memory mapped)
16:00:40 <FreeFull> I don't see why binary files would be hard with Haskell
16:01:04 <Ghoul_> Not hard just had questions about the ptr type...
16:01:14 <Ghoul_> Anyway adios
16:03:18 <shachaf> johnw: If I was wise, I would write it up on a web page somewhere.
16:13:41 <josephle> !slap bgates
16:13:41 <josephle> oops
16:13:41 <josephle> wrong channel
16:13:41 <elliott> shachaf: put it on the wiki
16:13:41 <shachaf> elliott: I don't "do" wikis.
16:13:42 * tabemann feels disgusted that he has to expose a Ptr type to the outside world in his wrapper around OpenGL he is using (he could force the user to marshal data into ByteStrings and import those, but that would be significantly less efficient)
16:13:42 <tabemann> s/using/creating
16:13:43 <tabemann> hmm
16:13:43 <tabemann> are there functions to generate arbitrary, properly byte-ordered ByteStrings from Storable types?
16:15:08 <Ghoul_> Haskell basically destroys Java in the single core benchmark game
16:15:35 <Peaker> Ghoul_, really? I remember differently
16:15:38 <josephle> Ghoul_: is this a recent event?
16:15:47 <Ghoul_> Only 2 programs where it runs slower and its significant enough to skew
16:16:00 <Ghoul_> Uhh I was looking last night
16:16:24 <josephle> the java JIT compiler is pretty damn good iirc
16:17:19 <josephle> huh, you're right
16:17:31 * tabemann can't find anything for Storable a => a -> ByteString
16:17:41 <tabemann> anything that is close to that, that is
16:18:06 <Ghoul_> http://benchmarksgame.alioth.debian.org/u32/haskell.php
16:18:24 <Ghoul_> X86 single core Haskell destroys
16:18:37 <Ghoul_> Except the last few
16:19:08 <KoF> Really? I've always heard Haskell wasn't the language to use for speed.
16:19:33 <hpc> KoF: what you have heard is comparisons between haskell and C
16:19:41 <tabemann> it seems that Haskell invariably uses less memory there, which is contrary to what I had heard about Haskell
16:19:54 <josephle> KoF: if you wanted speed, use ATS! Fast and typesafe!
16:20:15 <josephle> ignore the fact that the documentation is poor
16:20:20 <Ghoul_> Haskell has always used a much less than Java in those benches
16:20:28 <Ghoul_> Java is ridiculous
16:20:41 <KoF> Oh, right. I've also heard Java is terrible for speed. <.<
16:20:56 <Ghoul_> Memory*
16:26:31 <tabemann> is there any way to marshal a Storable directly into a ByteString?
16:26:34 * tabemann isn't finding it
16:28:12 <tabemann> and not by doing an unsafe conversion of a ByteString into a Ptr and then poking values into that either
16:29:02 <johnw> tabemann: you could poke your Storable to a malloc'd memory block, and then use ByteString.Unsafe.unsafeUseCString
16:29:12 <johnw> but you'll have to be very careful about lifetimes
16:29:32 <johnw> oh, and use unsafePeekCStringLen
16:29:35 <tabemann> I was thinking of that, but I wanted a way to construct an arbitrary octet sequence that didn't involve using Ptrs openly
16:30:24 <johnw> there's the binary library
16:30:33 <johnw> i know it doesn't work with Storable
16:31:21 <tabemann> that looks like what I'm looking for, even though it spits out *lazy* ByteStrings (but I figure there's a way I could convert those into normal ones)
16:31:40 <johnw> fromChunks
16:32:17 <tabemann> too bad it doesn't look like Binary supplies any means for marshaling Floats into Builders
16:32:31 <tabemann> so I need to find a way to turn a Float into a Word32 first
16:33:55 <johnw> you want just the bits?
16:34:18 <tabemann> Hoogle isn't finding anything that looks like Float -> Word32
16:34:23 <tabemann> yeah
16:34:28 <johnw> unsafeCoerce will reinterpret a Float's bits as a Word32
16:34:46 <johnw> but translation happens, so this is a very unsafe function generally
16:34:53 <johnw> but your case might actually be a valid use
16:34:58 <johnw> no translation*
16:35:29 * tabemann doesn't like the idea of making the user use unsafeCoerce
16:35:38 <johnw> your user!  heck no
16:36:41 <tabemann> why must Haskell make this hard... I'm so used to doing such non-conversions in C and C++...
16:37:01 <johnw> write it in C then, and use the FFI to import your function
16:37:28 <tabemann> technically the user in this case is myself, but I like to write API-ish code as if someone else were going to use it
16:37:40 <johnw> also, can't you hide the valid unsafeCoerce behind a function?
16:38:28 * tabemann thought there were some inefficiencies in calling C code from Haskell, whether with unsafe (stops all threads in all CPUs) or safe (something vague I'm not sure about)
16:38:45 <tabemann> hmm... I could probably do that, but I want to try to find some preexisting "safe" way to do it
16:39:46 <tabemann> ooh good
16:40:18 <tabemann> Data.ByteString.Builder has what I'm looking for
16:41:33 <johnw> ah, yes, of course
16:42:45 <tabemann> Binary really looks like a very incomplete version of Data.ByteString.Builder
16:43:38 <tabemann> of course Data.ByteString.Builder can also generate non-/binary/ ByteString content as well
16:45:22 <johnw> Binary can go in the other direction, though
16:45:27 <tabemann> now, time to rewrite my code to not use Ptrs and to use Builders (I could use ByteStrings, but I would have to make the user explicitly convert a lazy ByteString generated from a Builder into a strict ByteString
16:45:35 <johnw> and it divides Get from Put, unlike Storable
16:46:24 <tabemann> oh I was looking at Data.Binary.Builder, not Data.Binary
16:48:58 <Michael__> I'm trying to figure out why I'm getting a type error in a fold, can anyone help me? In this little snippet: https://gist.github.com/mfine15/293bb8898fba7548354d
16:51:23 <tabemann> hmm maybe Data.Binary (not Data.Binary.Builder) would work for me
16:52:01 <josephle> @ty (+) . ((1/) . fromIntegral)
16:52:03 <kappabot> forall b a. (Fractional b, Integral a) => a -> b -> b
16:52:52 <josephle> @ty (+) . ((1/) . fromIntegral) . length
16:52:53 <kappabot> forall b a. Fractional b => [a] -> b -> b
16:53:37 <nexx> Michael__ foldr1 :: (a -> a -> a) -> [a] -> a
16:54:00 <Michael__> nexx: Oh, so I should just use foldr?
16:54:20 <tabemann> use foldr with 0 as a starting value
16:54:43 <nexx> I think that should work
16:55:04 <josephle> yeah, that'll probably do it
17:07:04 <tabemann> random question
17:07:14 <tabemann> does toForeignPtr copy the ByteString you feed it?
17:07:28 <tabemann> or does it do a no-copy conversion
17:11:29 <ezyang> Remind me; if I want my state counter not to get reset on failure, do I put the state monad on the inside or outside of the transformer stack?
17:11:29 <kappabot> ezyang: You have 1 new message. '/msg kappabot @messages' to read it.
17:11:51 <shachaf> @unmtl StateT Int Maybe a
17:11:51 <kappabot> Int -> Maybe (a, Int)
17:12:02 <shachaf> @unmtl MaybeT (State Int) a
17:12:03 <kappabot> Int -> (Maybe a, Int)
17:12:14 <ezyang> Hmk, inside, ti seems
17:12:19 <shachaf> Yep.
17:12:56 <Peaker> Maybe a good way to remember it, is that if you have a "State s", there's no way to inject effects between (s->) and the result s.  whereas StateT lets anyone inject stuff that prevent the result s
17:13:41 <ezyang> well, you could hold onto old "monadic contexts" and then use those instead.
17:15:30 <Peaker> well, none of the transformers know anything about the State type
17:15:50 <ezyang> yeppers
17:16:16 <ezyang> but this sort of thing shows up when you're doing morph style things, IIRC
17:16:46 <DanBurton> So Control.Category is getting kind polymorphism... what about Control.Arrow?
17:17:14 <shachaf> What about it?
17:17:22 <DanBurton> shouldn't it get the same?
17:17:25 <shachaf> @src Arrow
17:17:25 <kappabot> class Arrow a where
17:17:25 <kappabot>     arr, pure   :: (b -> c) -> a b c
17:17:27 <kappabot>     (>>>)       :: a b c -> a c d -> a b d
17:17:29 <kappabot>     first       :: a b c -> a (b,d) (c,d)
17:17:31 <kappabot>     second      :: a b c -> a (d,b) (d,c)
17:17:33 <kappabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
17:17:36 <kappabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
17:17:46 <DanBurton> oh we would need to ditch "arr" to make that work though, right?
17:17:55 <shachaf> Yes, it won't work with arr.
17:17:58 <shachaf> Lots of things don't.
17:18:08 <shachaf> Arrow. :-(
17:18:47 <Peaker> wihout "arr", Arrow class could be nice, but it'd need a few more combinators that are currently depending on "arr"
17:19:14 <Peaker> Also, if (,) is parameterized, it could be a sum rather than a product which is also useful for some compositions
17:19:21 <hpc> i wish i could say idris' DSLs were any better...
17:19:52 <johnw> how (un)popular are monad comprehensions?
17:20:17 <johnw> on a spectrum from Arrow to Lens, I wonder where they rate
17:20:51 <DanBurton> I usually hear people wishing for Applicative comprehensions
17:21:09 <shachaf> GHC has a comprehension syntax compatible with Applicative semantics.
17:21:10 <DanBurton> or something
17:21:20 <shachaf> But it's used with a different class.
17:21:49 <mm_freak> that raises an interesting question…  could we make (->) kind-polymorphic?
17:22:10 <johnw> I was reading Wadler's paper, and it was interesting how he began his presentation on monads by evolving list comprehensions to monad comprehensions; I'd never seen that approach beforfe
17:22:41 <shachaf> I'd like to see comonad mprehensions in GHC.
17:22:45 <startling> I really don't like comprehension syntax. It seems deliberately obscure to me.
17:22:47 <johnw> lol
17:22:54 <DanBurton> shachaf: patches welcome
17:23:07 <johnw> shachaf: you just need a distributive law for that
17:23:51 <DanBurton> mm_freak: huh? (->) currently has a very specific meaning, just like Either
17:24:06 <DanBurton> mm_freak: I don't see what a kind-polymorphic version would mean
17:24:20 <kvda> startling, i agree, more than 2-3 deep and it's just to hard to 'comprehend'
17:24:21 <ion> shachaf: You should n SPJ to implementing that.
17:24:30 <mm_freak> DanBurton: think of data kinds
17:24:58 <mm_freak> good: Zero -> Succ Zero
17:25:07 <mm_freak> kind error:  Zero -> Integer
17:25:26 <Peaker> don't know why mathematicians like their comprehensions reversed.. I think a do block reads better
17:25:47 <DanBurton> not sure I follow
17:25:47 <Peaker> and it's nice not to have to be point-ful about the result value
17:26:08 <Peaker> do { x <- a ; y <- b ; return (x*y) }   vs.  [ x*y | x <- a; y <- b ]
17:26:36 <mm_freak> DanBurton: think of a hypothetical kind class TypeLike:  (Typelike a) => a -> a -> *
17:26:41 <Peaker> I like a top-down or bottom-up order, rather than mixed order
17:26:52 <shachaf> [x*y | x <- a | y <- b]
17:26:59 <shachaf> Peaker: Mathematicians also write (a + b), to be fair.
17:27:05 * DanBurton is thinking
17:27:21 <shachaf> (For example when a and b are functions.)
17:27:44 <shachaf> (Or vectors that are zipped together.)
17:28:52 <mm_freak> DanBurton: i didn't think this through, so it may not make sense at all
17:28:56 <DanBurton> the part I don't get is how "Zero -> Succ Zero" is good. What function can have that type? What are the inhabitants of Zero?
17:29:13 <copumpkin> () -> ()
17:29:50 <mm_freak> DanBurton: but the idea is to allow the programmer to constrain the possible function types for certain kinds
17:29:52 <DanBurton> I don't think all promoted data kinds should be treated as synonymous with (). If anything, they should be Void.
17:30:09 <DanBurton> since they are essentially Empty Data Decls in disguise
17:30:22 <mm_freak> but yeah, with the promotion mechanism this doesn't really make sense
17:30:47 <DanBurton> that's what I'm thinking
17:43:32 <Ghoul_> Hah never thought about do blocks as comprehensions
17:43:43 <Ghoul_> That's so cool
17:44:02 <hpc> Ghoul_: other way around ;)
17:44:50 <mm_freak> > do x; y; z
17:44:51 <kappabot>   Couldn't match expected type `m0 a0'
17:44:52 <kappabot>              with actual type `SimpleR...
17:44:56 <Ghoul_> So hoiw would you express something that grabs the first element from a comprehension that fulfills a predicate
17:45:13 <mm_freak> do do-blocks apply (>>) left- or right-associatively?
17:45:20 <mm_freak> i'd assume right
17:45:22 <shachaf> Right.
17:45:24 <shachaf> They have to.
17:45:27 <hpc> mm_freak: either
17:45:38 <shachaf> do { blah; ... } = blah >> (do { ... })
17:45:48 <mm_freak> shachaf: that's what i thought
17:45:52 <mm_freak> thanks
17:45:52 <hpc> by definition, it doesn't matter how it associates
17:45:59 <shachaf> By the monad laws, not by definition.
17:46:07 <mm_freak> hpc: it doesn't matter denotationally
17:46:40 <mm_freak> but i often rely on right-associative application of (>>) for performance
17:47:19 <shachaf> Codensity to the rescue!
17:47:30 <mm_freak> > execWriter (forever (tell "a"))
17:47:32 <kappabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
17:49:16 <mm_freak> Ghoul_: head [ … ]?
17:49:44 <mm_freak> or alternatively:  listToMaybe [ … ]
17:52:35 <shachaf> kappabot: @admin + copumpkin
17:52:36 <mm_freak> in this particular case the reason i asked is whether Seq may be better than [] for my Writer
17:52:40 <mm_freak> but i'll go with []
17:52:57 <copumpkin> kappabot: @join #haskell-lens
17:55:03 <satc> Does making an argument of a function strict has any effect if I am inlining that function like foo !(Tree n lt rt) = undefined {-# INLINE foo #-} ??
17:56:08 <Cale> satc: sure
17:56:21 <mm_freak> satc: using a bang is equivalent to adding a forcing guard, so that guard becomes part of the inlined function
17:57:14 <mm_freak> btw, the bang has no effect in your example
17:57:18 <satc> mm_freak: So it will force the argument to be evaluated even when the function is inlined
17:57:25 <mm_freak> satc: sure
17:57:33 <satc> mm_freak: Why it has no effect here??
17:57:48 <mm_freak> satc: because constructor pattern matches are always strict
17:57:58 <mm_freak> bangs only make sense on variables
17:58:25 <satc> mm_freak: I didn't know that. Where is the source for this ??
17:58:40 <mm_freak> satc: common sense
17:58:54 <mm_freak> satc: case x of Just y -> …; Nothing -> …
17:58:59 <startling> satc, how would you match (Just a) without first evaluating it to know it's not Nothing?
17:58:59 <mm_freak> when is the Nothing case reached?
17:59:01 <Cale> satc: You can't tell if an expression matches Tree n lt rt without evaluating it.
17:59:54 <satc> Ok what about foo :: Int -> Int -> Int ; foo !x !y = x + y ; {-# INLINE foo #-}
18:00:04 <mm_freak> satc: x and y are variables in that case
18:00:12 <Cale> satc: The bangs are also quite pointless there
18:00:19 <mm_freak> but what Cale said
18:00:21 <Cale> Because (+) is strict on Int
18:00:22 <mm_freak> (+) is already strict
18:01:12 <satc> ohh thanks. That clarified a lot of things.
18:01:17 <Cale> My advice generally would be not to use bangs anywhere until you actually spot a place where evaluation is happening too late.
18:01:54 <Cale> (i.e. you're building up large expressions without pattern matching until the very end of some process)
18:03:07 <mm_freak> satc: pattern matches are the primary mechanism to force evaluation, because decisions need to be made based on the pattern of a value
18:03:15 <mm_freak> case mx of Just x -> y
18:03:31 <mm_freak> when y is reached, you can be sure that mx has been evaluated at least to its (Just _) pattern
18:05:12 * hackagebot magma 0.1.0.1 - magma is an algebraic structure consisting a set together with an binary operation.  http://hackage.haskell.org/package/magma-0.1.0.1 (KatsutoshiItoh)
18:11:30 <mm_freak> is there an efficient order-preserving set data structure?  like a Set with an index
18:12:01 <shachaf> Index?
18:12:36 <mm_freak> nevermind, i'll do it differently
18:15:44 <carter> mm_freak oooo context?
18:21:52 <johnw> mm_freak: isn't that just a Map?
18:22:02 <johnw> or do you want unique values only
18:22:30 <carter> johnw youre right
18:22:34 <carter> it is
18:22:39 <shachaf> It is possible that mm_freak wants Int indexing.
18:22:44 <johnw> IntMap :)
18:22:46 <carter> IntMap
18:22:48 <shachaf> No.
18:22:59 <shachaf> Int indexing by order, key indexing by key.
18:23:04 <carter> both?
18:23:05 <shachaf> Which oddly enough Map provides and Set does not.
18:23:09 <shachaf> Yes, both.
18:23:13 <carter> ok
18:23:16 <mm_freak> what shachaf said
18:23:16 <johnw> ah, I see
18:23:27 <carter> you could easily mod Map to do that
18:23:34 <monochrom> I propose psqueue
18:23:35 <johnw> i think actually edwardk has something along those lines
18:23:51 <carter> johnw the succint stuff isn't quite that i think...
18:23:52 <mm_freak> Map does it by itself actually
18:24:00 <carter> cool
18:24:23 <mm_freak> :t M.elemAt
18:24:24 <kappabot> forall k a. Int -> M.Map k a -> (k, a)
18:24:27 <johnw> ah
18:24:35 <carter> thats EXISTS?
18:24:36 <carter> cool
18:25:07 <shachaf> > let (==>) = (,); m = M.fromList ["a" ==> "hi", "b" ==> "ho", "z" ==> "hm"] in M.elemAt 1 m
18:25:09 <kappabot>   ("b","ho")
18:25:28 <mm_freak> can i safely assume that foldMap will always apply (<>) right-associatively for []?
18:25:43 <monochrom> binary search is the best thing since slicing bread binarily
18:26:00 <johnw> since bisecting bread
18:26:08 <shachaf> mm_freak: That's the implementation for [], yes.
18:26:09 <monochrom> oh!
18:26:18 <shachaf> What you assume is up to you. It's not required by the laws.
18:26:50 <mm_freak> well, it isn't required that foldMap must be implementable in terms of foldr — unfortunately
18:27:34 <mm_freak> currently i do this all the time:  foldr (\x y -> f x <> y) mempty
18:27:48 <shachaf> mm_freak: ?
18:27:55 <shachaf> foldMap should not be right-associative in general.
18:28:05 <shachaf> It should be balanced like your data type's structure.
18:28:19 <shachaf> As it happens, [] is right-associative, so foldMap for it is right-associative.
18:28:28 <shachaf> But for a balanced tree foldMap had better be balanced!
18:28:47 <johnw> foldr ((<>) . f) mempty... I think I've seen this pattern very recently
18:29:33 <roconnor> @type foldMap
18:29:34 <kappabot>     Not in scope: `foldMap'
18:29:34 <kappabot>     Perhaps you meant one of these:
18:29:34 <kappabot>       `Data.Foldable.foldMap' (imported from Data.Foldable),
18:29:41 <roconnor> @type Data.Foldable.foldMap
18:29:41 <mm_freak> is it a safe assumption that it will be right-associating forever?  after all left-associating doesn't really make sense
18:29:42 <kappabot> forall (t :: * -> *) m a. (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
18:29:45 <johnw> ah, I was thinking of the fold definition of map
18:29:51 <johnw> foldr ((:) . f) []
18:29:58 <shachaf> mm_freak: I would feel safe assuming it.
18:30:04 <mm_freak> alright, thanks
18:30:30 <shachaf> But not, y'know, the kind of safe where I'd be OK with my life depending on it.
18:30:40 <byorgey> why does the associativity matter? are you using a non-associative monoid?
18:30:44 <shachaf> I wouldn't make huge bets on it or anything.
18:31:08 <byorgey> if you really care about it being right-associated you can use a "difference monoid"
18:31:23 <shachaf> Yes, a "difference monoid" is how you turn foldMap into foldr or foldl.
18:31:27 <byorgey> i.e. first do  (fmap (<>)) to go from  m  to  m -> m  and then fold with (.)
18:31:33 <shachaf> But you can't go the other way around.
18:31:38 <shachaf> Therefore foldMap is superior.
18:31:42 <byorgey> indeed.
18:32:08 <shachaf> To turn foldMap into foldr' or foldl', you use *two* "difference monoids"!
18:32:33 <byorgey> oh?
18:32:37 <byorgey> how does that work?
18:32:51 <shachaf> See e.g. https://github.com/ekmett/lens/blob/master/src/Control/Lens/Fold.hs#L1405
18:33:24 * byorgey looks
18:34:21 <shachaf> Or, for that matter, http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/src/Data-Foldable.html#line-126
18:34:47 <shachaf> You can get foldl' out of foldr, and foldr' out of foldl (where they make sense).
18:38:18 <carter> shachaf so we can have parallel versions fo foldmap
18:38:23 <carter> right?
18:38:43 <shachaf> help how do you write show instances :'(
18:38:52 <carter> huh?
18:38:55 <shachaf> All this parenthesis nonsense.
18:38:58 <shachaf> carter: ?
18:39:02 <shachaf> foldMap can go in parallel, sure.
18:39:05 <carter> yes
18:39:09 <carter> thats what i mean
18:39:17 <shachaf> Though it would be a weird Monoid instance. Maybe a good use for reflection.
18:39:26 <carter> associative monoid?
18:39:29 <johnw> shachaf: use one of the pretty printing libraries?
18:39:35 <carter> balanced tree monoid?
18:40:24 <shachaf> good monoid
18:41:42 <carter> itd have mroe work to build up
18:41:48 <carter> but could be evaluated very nicely
18:42:13 <johnw> carter: have you seen the reducers library?
18:42:23 <carter> yes, i've just never gotten to using it :)
18:42:29 <carter> @hackage reducers
18:42:29 <kappabot> http://hackage.haskell.org/package/reducers
18:43:19 <carter> i should stare at it more some time
18:43:23 <sclv> you could do it w. `par` pretty easily actually.
18:43:29 <carter> yeah
18:43:32 <carter> par is awesome
18:43:37 <carter> using it for some of my hacking
18:44:20 <carter> need to track down a monad par related bug i found in my criterion code recently
18:44:31 <johnw> 2012-06-25 04:18:06 +0200, <carter>, so maybe reducers is a better thing to stare at.
18:44:33 <johnw> heh
18:45:01 <carter> johnw what was the context when I was being told to look at it by kmett?
18:45:05 <elliott> newtype Par a = Par { runPar :: a }; instance Applicative Par where pure = Par; Par f <*> Par x = Par (x `par` f x); instance Monoid a => Monoid (Par a) where mempty = pure mempty; mappend = liftA2 mappend
18:45:13 <elliott> i think that parallelises any monoid
18:45:14 <johnw> http://chrisdone.com:10001/browse/haskell/?events_page=116&events_per_page=25&q=carter
18:45:47 <carter> johnw i don't see reducers there
18:46:01 <johnw> huh, then google excerpt is wrong
18:46:21 <carter> http://chrisdone.com:10001/browse/haskell/?id=13696766&timestamp=1340590686#t1340590686
18:46:50 <carter> some bits are missing
18:47:17 <carter> i need to mess with multipass some more once i get numerics out
18:47:25 <carter> i  was meaning to help clean it up
18:47:28 <carter> but just didn't have the time
18:47:34 <shachaf> > foldMap NLeaf (S.fromList [1,2,3,4,5,6,7])
18:47:36 <kappabot>   (((((mempty * 1) * mempty) * 2) * ((mempty * 3) * mempty)) * 4) * ((((mempt...
18:47:39 <shachaf> > foldMap NLeaf (S.fromList [1,2,3,4])
18:47:40 <kappabot>   (((mempty * 1) * mempty) * 2) * ((mempty * 3) * ((mempty * 4) * mempty))
18:47:58 <shachaf> Hmm, Data.Set's Foldable instance uses mempty a lot.
18:50:27 <sclv> ew
18:55:28 <shachaf> > foldMap NLeaf (S.fromList [1,2,3,4])
18:55:30 <kappabot>   (((𝟏 ∙ 1) ∙ 𝟏) ∙ 2) ∙ ((𝟏 ∙ 3) ∙ ((𝟏 ∙ 4) ∙ ...
18:55:31 <shachaf> Is that too confusing?
18:55:57 <shachaf> That's 1D7CF   MATHEMATICAL BOLD DIGIT ONE     [𝟏]
18:57:35 <startling> :t NLeaf
18:57:36 <h4199> ωατ
18:57:36 <kappabot> forall a. a -> Nonoid a
18:57:49 <startling> h4199: indeed
18:57:49 <nan`> what is the best way to do short-circuit && / || -style evaluation with monadic values? I don't want the rhs to be forced to be inner bool unless it itself is used as a lhs
18:58:08 <startling> nan`: <|> maybe
18:58:37 <nan`> :t (<|>)
18:58:38 <kappabot> forall (f :: * -> *) a. Alternative f => f a -> f a -> f a
18:58:38 <startling> that is, "(<|>)" for "(||)", perhaps, depending on what you mean
18:58:52 <startling> nan`: you can also do (||) <$> a <*> b
18:59:03 <shachaf> startling: No, that won't "short-circuit"
18:59:09 <nan`> startling: yes
18:59:11 <nan`> what he said
18:59:18 <shachaf> You can't "short-circuit" with Applicative; you need Monad or at least something more.
18:59:24 <nan`> right!
18:59:27 <startling> shachaf: oh, right
18:59:27 <nan`> are there builtins for this
18:59:39 <shachaf> No.
18:59:41 <johnw> > Just 10 <|> Just 20
18:59:41 <johnw> > Just 10 *> Just 20
18:59:41 <startling> <|> does short-circuit, though, doesn't it?
18:59:42 <kappabot>   Just 10
18:59:42 <kappabot>   can't find file: L.hs
18:59:48 <nan`> startling: the reason is because the app one will force bool on rhs
19:00:06 <shachaf> Help, what's a good codepoint for monoid unit?
19:00:17 <startling> (but for empty, not for m False)
19:00:44 <shachaf> nan`: I think your concern is with executing the action, not with forcing the Bool.
19:01:00 <nan`> both actually
19:01:06 <shachaf> liftA2 (||) won't force the Bool. But it'll execute the action that yields the Bool.
19:01:10 <nan`> i want to be able to do an arbitrary action as the final 'else'
19:01:10 <johnw> shachaf: ε?
19:01:22 <nan`> shachaf: not just bool-returning action, and also to not execute
19:01:25 <startling> shachaf, 0
19:01:46 <carter> shachaf zero
19:02:01 <johnw> "unit"
19:02:07 <shachaf> Perhaps I'll go with ∅... That's a bit of an abuse, though.
19:02:30 <johnw> that seems biased wrt the nature of the monoid
19:02:38 <carter> http://www.cis.upenn.edu/~eir/papers/2013/fckinds/fckinds-extended.pdf has a neat polykinded zero
19:02:40 <nan`> shachaf: By force do you mean the rightmost doesn't have to be m (Bool)? Because i was finding that it did
19:02:41 <shachaf> So does the name "mempty"
19:02:47 <johnw> no argument here
19:03:00 <nan`> shachaf:  (with liftA2 (||))
19:03:02 <shachaf> nan`: No, I mean "force" in the usual sense of the word.
19:03:23 <shachaf> Thunks etc., or however you like to think of things.
19:03:37 <nan`> oh ok, so i have two requirements
19:03:54 <nan`> i guess i can just write this
19:04:03 <nan`> i think i know what i want
19:04:34 <shachaf> > foldMap NLeaf "hello"
19:04:36 <kappabot>   'h' ∙ ('e' ∙ ('l' ∙ ('l' ∙ ('o' ∙ ∅))))
19:05:08 <startling> shachaf, ⛾
19:05:08 <nan`> anyway the two requirements are type freedom for rhs and rhs not evaluated unless necessary
19:05:28 <startling> "type freedom"?
19:05:30 <nan`> lol
19:05:33 <johnw> shachaf: ☃
19:05:40 <nan`> i need to be more careful, inner type can be something other than bool
19:05:44 <nan`> ugh
19:05:51 <startling> shachaf, ⛽
19:06:07 <nan`> lol
19:06:10 <shachaf> > foldMap NLeaf (IM.fromList . map (join (,)) $ [1,2,3,4,5,30,100])
19:06:12 <kappabot>   (((1 ∙ (2 ∙ 3)) ∙ (4 ∙ 5)) ∙ 30) ∙ 100
19:06:17 <monochrom> what is going on?
19:06:34 <startling> monochrom, shachaf asked what codepoint to use for mempty
19:06:42 <h4199> I define ☕  to be undefined in all my Haskell files
19:06:52 <nan`> hahaha
19:08:15 <startling> > NLeaf 'a'
19:08:17 <kappabot>   'a'
19:08:32 <startling> > NLeaf 'a' <> NLeaf 'b'
19:08:34 <kappabot>   'a' ∙ 'b'
19:08:53 <startling> heh
19:09:36 <shachaf> > (NLeaf 'a' <> (mempty <> mempty)) <> ((mempty <> mempty) <> NLeaf 'b')
19:09:38 <kappabot>   ('a' ∙ (∅ ∙ ∅)) ∙ ((∅ ∙ ∅) ∙ 'b')
19:09:40 <shachaf> That's for byorgey.
19:09:57 <shachaf> Lecturing me about "monoid laws"!
19:10:53 <startling> > fold [a, b]
19:10:54 <kappabot>   Not in scope: `fold'
19:10:55 <kappabot>  Perhaps you meant one of these:
19:10:55 <kappabot>    `Data.Foldable.fol...
19:11:05 <startling> > Data.Foldable.fold [a, b]
19:11:06 <kappabot>   No instance for (Data.Monoid.Monoid SimpleReflect.Expr)
19:11:06 <kappabot>    arising from a u...
19:11:18 <startling> > a >>= b
19:11:19 <kappabot>   Couldn't match expected type `m0 a0'
19:11:19 <kappabot>              with actual type `SimpleR...
19:12:08 <startling> aw.
19:21:48 <lispy> hello my fello denizens of the free node.
19:21:58 <lispy> That's quite the unicode you have there
19:22:15 <lispy> shachaf: that's quite cute
19:23:42 <shachaf> i love breaking laws
19:23:50 <shachaf> breaking the Applicative laws now
19:23:55 * johnw sounds the Haskell alert siren
19:24:10 <johnw> lispy: hello!
19:24:36 <lispy> johnw: howdy
19:25:02 <DigitalKiwi> johnw showed up to save the day
19:25:39 * lispy relaxes
19:32:54 <satc> Is there a NFDate instance for bytestring
19:33:58 <shachaf> Is someone messing with kappabot in /msg?
19:34:09 <dmwit> satc: Did you check the documentation?
19:34:47 <dmwit> shachaf: If you haven't upgraded to new-lambdabot, kappabot's stdout will tell you that.
19:35:04 <dmwit> or
19:35:07 <dmwit> not really, never mind
19:35:13 <shachaf> It just tells me about joins and parts and things.
19:35:18 <shachaf> > renoid (NLeaf 'a' <> NLeaf 'b' <> mempty) [1,2]
19:35:20 <kappabot>   "ab"
19:35:23 <shachaf> Hooray!
19:35:42 <dmwit> It should at least also tell about > evaluations.
19:35:43 <Hermit> :t renoid
19:35:44 <kappabot> Not in scope: `renoid'
19:35:56 <Hermit> wtf
19:35:56 <shachaf> OK, NLeaf is renamed to N.
19:36:17 <sclv> ?ty renoid
19:36:18 <kappabot> forall (t :: * -> *) b a. Traversable t => Nonoid b -> t a -> t b
19:36:22 <dmwit> Hermit: presumably renoid :: Monoid a => SomeCustomType a -> a
19:36:42 <shachaf> Renoid will take a monoid tree and stick it back into a Traversable value.
19:36:45 <Hermit> nonoid? what?
19:37:02 <sclv> > renoid (NLeaf 'a' <> NLeaf 'b' <> mempty) [(),()]
19:37:03 <kappabot>   Not in scope: data constructor `NLeaf'Not in scope: data constructor `NLeaf'
19:37:11 <shachaf> It's called N now.
19:37:16 <sclv> > renoid (N 'a' <> N 'b' <> mempty) [(),()]
19:37:17 <kappabot>   <hint>:1:19: lexical error at character '\FS'
19:37:32 <shachaf> renoid (N 'a' <> N 'b' <> mempty) [(),()]
19:37:34 <dmwit> > renoid (N 'a' <> N 'b' <> mempty) [(),()]
19:37:36 <kappabot>   "ab"
19:37:41 <dmwit> > renoid (N 'a' <> N 'b' <> mempty) [(),(),()]
19:37:43 <kappabot>   "ab*Exception: Renoid (<*>): invalid structure (expected NAppend)
19:37:49 <dmwit> > renoid (N 'a' <> N 'b' <> mempty) [()]
19:37:51 <kappabot>   "a"
19:37:58 <shachaf> This is like partsOf or magma in lens.
19:38:01 <shachaf> > foldMap N (S.fromList [1,2])
19:38:03 <kappabot>   (∅ ∙ 1) ∙ ((∅ ∙ 2) ∙ ∅)
19:38:30 <shachaf> Er, can't traverse that.
19:38:48 <shachaf> > foldMap N (M.fromList . map (join (,)) $ [1,2])
19:38:50 <kappabot>   (∅ ∙ 1) ∙ ((∅ ∙ 2) ∙ ∅)
19:39:21 <dmwit> > renoid (foldMap N (S.fromList [1,2])) [(),()]
19:39:22 <kappabot>   [*Exception: renoid: invalid Nonoid structure (expected N)
19:39:30 <dmwit> uh huh
19:39:41 <shachaf> > renoid ((mempty <> N 'a') <> ((mempty <> N 'b') <> mempty)) (M.fromList [(1,1),(2,2)])
19:39:43 <kappabot>   fromList [(1,'a'),(2,'b')]
19:39:56 <shachaf> dmwit: It has to match the structure exactly.
19:40:02 <shachaf> Breaking laws all over the place.
19:40:03 <dmwit> Wait, Map is traversable?
19:40:08 <shachaf> Sure, on the values.
19:40:15 <shachaf> You can't change the structure that way.
19:40:17 <dmwit> Oh, Set isn't traversable, but that's because it's Set.
19:40:19 <dmwit> Okay.
19:41:42 <shachaf> > nonoid $ Node 'a' [Node 'b' [], Node 'c' [Node 'd' [], Node 'e' []]]
19:41:44 <kappabot>   'a' ∙ (('b' ∙ ∅) ∙ (('c' ∙ (('d' ∙ ∅) ∙ (('e' ∙ ∅) ∙ ...
19:41:55 <shachaf> > nonoid $ Node 'a' [Node 'b' [], Node 'c' [Node 'd' []]]
19:41:56 <kappabot>   'a' ∙ (('b' ∙ ∅) ∙ (('c' ∙ (('d' ∙ ∅) ∙ ∅)) ∙ ∅))
19:42:06 <shachaf> etc.
19:44:46 <carter> thoughtpolice woah: the huffingtonpost.com thing
19:46:38 <DigitalKiwi> what thing
19:48:28 <carter> the world is crazy
19:48:31 <carter> just
19:48:35 <carter> all the articles
19:48:42 <carter> are all… real.......
19:49:06 <carter> but i keep on thinking as i scrolll "i wish this was the onion"
19:52:20 <tomjack> is it unacceptable for a newtype of the free monad of a copointed functor to give Eq and Ord instances which retract and extract before comparison?
19:53:17 <tomjack> vs the Free in free in which (Pure a) is always less than (Free fa)
19:54:07 <carter> tomjack would be easier if you hpasted an example :)
19:56:46 <sclv> there doesn't need to be any relationship between eqs and ords on newtypes and their base types
19:56:56 <sclv> just satisfy the eq and ord laws and nobody cares
19:57:37 <tomjack> cool, was just wondering if there is a good reason I don't know for the instances free provides
19:57:52 <shachaf> Well, often you want to not export the constructors if you have your own Eq instance.
19:57:58 <shachaf> So that equal values aren't distinguishable.
20:00:06 <tomjack> ah, didn't consider that, makes sense here I think
20:00:40 <hoqhuuep> Through my newbie eyes, it appears that currying imposes an unnessary order on the parameters for partial application. "flip" and other workarounds feel very imperative to me as they describe *how* to partially apply to a latter argument rather than just *what* you're trying to achieve. In Python, you can use named parameters with functools.partial to partially apply a function on any argument(s), this feels much more declarative.
20:01:17 <shachaf> You can make something like named parameters in Haskell too with records, though it's not really the same.
20:01:27 <shachaf> But this isn't really very related to currying.
20:02:20 <jmcarthur> hoqhuuep: most of the time there is some argument ordering you can choose for a functions such that you don't have to rearrange things most of the time
20:02:36 <jmcarthur> yes, i intended there to be two "most of the time"s in that sentence
20:03:03 <hoqhuuep> mhmm, most of the time
20:03:11 <shachaf> My antícheirocracy is to never use flip.
20:03:24 <jmcarthur> for the rest, i don't like flip that much, but most other little combinators and stuff i don't mind
20:03:27 <jmcarthur> not sure why i hate on flip
20:03:41 <shachaf> Because it's awful.
20:03:49 <shachaf> Even (`foo` x) is much better.
20:04:00 <zRecursive> but sometimes flip is essential
20:04:06 <jmcarthur> i don't see why it's any worse than S or K, which i use a lot
20:04:43 <shachaf> flip is never essential.
20:04:49 <hoqhuuep> may I as what "S" and "K" are?
20:04:55 <copumpkin> moo.
20:04:59 <shachaf> You're allowed to use lambdas. Point-free is not the law.
20:05:25 <shachaf> Oops, I need something alphanumeric for mempty.
20:05:26 <geekosaur> hoqhuuep, look up the SKI calculus.
20:05:28 <shachaf> ∅ won't do.
20:05:34 <jmcarthur> it's not fun to use BKW without C though ;)
20:05:53 <hoqhuuep> geekosaur: ta, will do
20:06:17 <zRecursive> shachaf: no flip some code will be ugly ?
20:07:10 <geekosaur> In haskell, the S combinator is ap, the K combinator is const, and the I combinator is id
20:07:34 <zRecursive> @ty ap
20:07:35 <kappabot> forall (m :: * -> *) a b. Monad m => m (a -> b) -> m a -> m b
20:07:46 <geekosaur> I think I got that right, it's been a while
20:08:43 <zRecursive> @ty const
20:08:45 <kappabot> forall a b. a -> b -> a
20:08:52 <geekosaur> yes, it'd ap
20:08:59 <zRecursive> @ty id
20:09:00 <kappabot> forall a. a -> a
20:10:20 <jmcarthur> geekosaur: yeah, and more interesting, K is pure. Applicative for functions is S and K
20:10:25 <hoqhuuep> @ty <*>
20:10:26 <kappabot> parse error on input `<*>'
20:10:34 <hoqhuuep> @ty (<*>)
20:10:35 <kappabot> forall (f :: * -> *) a b. Applicative f => f (a -> b) -> f a -> f b
20:13:53 <shachaf> > nonoid [Just 1, Nothing]
20:13:55 <kappabot>   N (Just 1) ∙ (N Nothing ∙ ø)
20:14:13 <shachaf> Should I add the N constructor and use ø instead of ∅ so you can copy-and-paste it?
20:14:24 <shachaf> > renoid (N (Just 1) ∙ (N Nothing ∙ ø)) "ab"
20:14:26 <kappabot>   [Just 1,Nothing]
20:18:37 <shachaf> OK, I'm going to take johnw's suggestion and use ε.
20:19:47 <dolio> Are you sure that's the right epsilon?
20:20:06 <shachaf> I want an alphanumeric epsilon so it can be an identifier.
20:20:27 <shachaf> Is there a better one?
20:20:28 <monochrom> there are two alphabetical epsilongs
20:20:43 <amosr> lunate?
20:20:51 <shachaf> Which one should I use?
20:21:01 <monochrom> toss a coin
20:21:02 <dolio> ϵ is the other one.
20:21:03 <shachaf> I want one that looks like http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
20:21:15 <shachaf> So I guess I'll stick with ε.
20:21:20 <shachaf> > nonoid "hello"
20:21:21 <kappabot>   N 'h' ◇ (N 'e' ◇ (N 'l' ◇ (N 'l' ◇ (N 'o' ◇ ε))))
20:21:32 <shachaf> > renoid (N 'h' ◇ (N 'e' ◇ (N 'l' ◇ (N 'l' ◇ (N 'o' ◇ ε))))) [1,2,3,4,5]
20:21:33 <kappabot>   "hello"
20:22:01 <tabemann> ... how are these symbols supposed to be valid operators and values in Haskell...?
20:22:17 <AfC> Beats the hell out of ~%=?
20:22:30 <Cale> tabemann: Problem?
20:22:43 <shachaf> hi Cale
20:22:46 <Cale> hi
20:22:50 * tabemann didn't know that Haskell accepted arbitrary Unicode for identifiers
20:22:51 <dolio> @type nonoid
20:22:52 <kappabot> forall (t :: * -> *) a. Foldable t => t a -> Nonoid a
20:22:57 <shachaf> Look at how advanced kappabot has gotten in lambdabot's absence!
20:23:01 <Cale> hehe
20:23:14 <shachaf> Unicode support (I patched mueval), @yow/@fortune
20:23:20 <dolio> @type yonoid
20:23:21 <kappabot>     Not in scope: `yonoid'
20:23:22 <kappabot>     Perhaps you meant one of these:
20:23:22 <kappabot>       `nonoid' (line 154), `renoid' (line 167)
20:24:20 <AfC> tabemann: http://hackage.haskell.org/package/base-unicode-symbols
20:24:36 <AfC> (pretty cool, actually)
20:25:34 * tabemann notes the UnicodeSyntax extension as well
20:25:57 <tabemann> the problem with Unicode, though, is typing it, as searching through character charts is not fun
20:26:30 <dolio> I wish we still had @yow
20:26:36 <startling> tabemann, if you use emacs, set-input-method tex is useful
20:26:36 <shachaf> @yow!
20:26:36 <kappabot> Are the STEWED PRUNES still in the HAIR DRYER?
20:26:45 <dolio> Oh man.
20:27:00 <startling> @yow
20:27:01 <kappabot> I KAISER ROLL?!  What good is a Kaiser Roll without a little COLE SLAW
20:27:01 <kappabot> on the SIDE?
20:27:17 <tabemann> startling: does that allow you to specify characters by the names one refers to them by in LaTeX?
20:27:24 <startling> tabemann: yes
20:30:58 <tabemann> stupid question
20:31:27 <tabemann> when using Data.ByteString.Lazy.toStrict, how expensive is it for a lazy ByteString smaller than or equal to one chunk?
20:31:39 <tabemann> one full chunk (IIRC 64K by default), that is
20:32:55 <shachaf> Very inexpensive.
20:32:56 <tabemann> as a lazy ByteString is implemented as essentially a linked list of strict ByteStrings, does it just return a reference to the internal strict ByteString, or does it actually copy it?
20:33:13 <shachaf> A lazy ByteString is just like a list of strict ByteStrings. So it's as cheap as (safe) head.
20:33:22 <shachaf> Why is the question stupid?
20:33:39 <tabemann> the answer seemed obvious, but I just wanted to make sure
20:33:49 <wewela> Hello, what's the mean of   ! in  "let !h = show $ md5 bs" ? thanks.
20:34:12 <shachaf> wewela: Hoogle is a good way to answer that.
20:34:14 <shachaf> @where hoogle
20:34:14 <kappabot> http://haskell.org/hoogle
20:34:22 <amosr> wewela: it's called a bang pattern, it makes 'h' strict
20:34:32 <shachaf> If you type ! and click on "keyword !", it'll tell you that it's part of an extension called BangPatterns.
20:36:28 <wewela> I seems cannot find out the usage of ! like in  "let !h = show $ md5 bs"
20:36:51 <amosr> wewela: it's called a bang pattern, it makes 'h' strict. mainly for optimisation
20:37:39 <tabemann> note that it does not fully evaluate data structures like lists, but only evaluates them so as to form (head : tail)
20:37:51 <tabemann> or the analogous for other data structures
20:41:18 <johnw> > let !h = undefined in (h,())
20:41:19 <kappabot>   *Exception: Prelude.undefined
20:41:24 <johnw> > let h = undefined in (h,())
20:41:26 <kappabot>   (*Exception: Prelude.undefined
20:41:29 <johnw> ah, because it's printing
20:41:43 <johnw> > let !h = undefined in ((),())
20:41:44 <kappabot>   *Exception: Prelude.undefined
20:41:46 <johnw> > let h = undefined in ((),())
20:41:47 <kappabot>   ((),())
20:42:24 <copumpkin> > let (a, b) = (undefined, undefined) in 5
20:42:25 <kappabot>   5
20:42:39 <copumpkin> > let ((a, b), (c, b)) = ((undefined, undefined), undefined) in 5
20:42:40 <kappabot>   Conflicting definitions for `b'
20:42:40 <kappabot>  Bound at: <interactive>:1:10
20:42:40 <kappabot>            <i...
20:42:45 <copumpkin> > let ((a, b), (c, d)) = ((undefined, undefined), undefined) in 5
20:42:46 <kappabot>   5
20:43:26 <copumpkin> > let (a, (c, d)) = (5, undefined) in a
20:43:27 <kappabot>   *Exception: Prelude.undefined
20:44:52 <shachaf> > let! a = undefined in a
20:44:53 <kappabot>   *Exception: Prelude.undefined
20:45:10 <shachaf> Well, not in a
20:45:18 <shachaf> OK, this isn't the channel for misleading syntax.
20:46:19 <tabemann> okay, when you're specifying bangs before entries when forming records, do you put the bang before the entry name or before the entry type?
20:46:32 <johnw> type
20:50:07 <shachaf> tabemann: Try it out!
20:51:01 <shachaf> Is lambdabot permanently down?
20:52:21 <tabemann> > type Foo = Foo { bar :: !Double }
20:52:22 <kappabot>   <hint>:1:1: parse error on input `type'
20:52:31 <tabemann> > data Foo = Foo { bar :: !Double }
20:52:32 <kappabot>   <hint>:1:1: parse error on input `data'
20:52:52 <shachaf> The lambdabot bit wasn't addressed to you.
20:52:55 <shachaf> Do you have ghci?
20:52:58 <shachaf> If not you should get ghci.
20:53:26 <tabemann> ghci parses it without complaint
20:53:40 <shachaf> Right.
20:53:44 <shachaf> So use ghci.
20:54:53 <Cale> shachaf: No, I just noticed you had kappabot running and that the network was still having issues, and let you take care of it :)
20:55:21 <Cale> Lambdabot still thinks it's connected :P
20:55:23 <shachaf> OK.
20:55:48 <Cale> It's alarmingly bad at noticing that it's disconnected for some reason :P
20:55:58 <Cale> I wonder if the new version does anything to correct that.
20:57:19 <shachaf> I wonder if this magma thing should go into a little package.
20:58:05 <shachaf> I guess it's not generally useful.
20:58:41 <shachaf> I wonder whether Data.Set's instance should can be improved easily.
20:59:33 <shachaf> I guess it just reflects the structure of the tree.
21:00:05 * tabemann is wondering how to get data out of Put monads (and get data into Get monads)
21:00:08 <shachaf> Or does it?
21:01:21 <shachaf> Oh, it's all the Tips.
21:01:26 <shachaf> Since a leaf is Bin x Tip Tip
21:01:44 <Clint> tabemann: run them?
21:01:58 <shachaf> I wonder whether it would be good to make the Foldable instance do the same thing showTree does (check for Bin _ x Tip Tip in particular).
21:02:06 <shachaf> preflex: seen tibbe
21:02:06 <preflex>  tibbe was last seen on #haskell 16 days, 11 hours, 15 minutes and 38 seconds ago, saying: sendWith is a bit shorter
21:03:05 <tabemann> Clint: oh, it refers to the Get and Put monads in the Data.Binary module, but their running functions are in Data.Binary.Get and Data.Binary.Put respectively
21:03:13 <johnw> what would a GHC-generated function named s5M77_info relate to, or is there really no way to know?
21:03:14 <tabemann> and yes, there's run funtions
21:03:40 <Clint> well there you go
21:03:44 <shachaf> "relate to"?
21:04:05 <johnw> well, in C++ I can recognize certain special, compiler-generated functions by their name
21:04:08 <johnw> like a default destructor body, etc.
21:04:23 <Clint> predictable mangling
21:04:23 <johnw> I'm wondering if GHC has conventions for generated functions that someone here would recognize
21:04:31 <shachaf> Ah. No, I don't think so, beyond _info
21:04:39 <johnw> what is an _info function?
21:04:50 <shachaf> (Which means that it's a pointer to the info table, or in this case probably the end of the info table, i.e. the entry code.)
21:04:59 <shachaf> Maybe it means it's related to a variable called "s"?
21:05:11 <johnw> sounds like a good guess to me
21:05:34 <shachaf> Usually I figure things out from the Core as I read it.
21:05:50 <shachaf> The most helpful thing is to eliminate as much Core as possible.
21:06:05 <johnw> i'm in a situation right now where this binary and its symbols is the best I've got
21:06:15 <johnw> I'm gdb'ing the running process
21:06:20 <shachaf> Oh, you aren't reading Core?
21:06:23 <johnw> no
21:06:25 <yogert> I have a question regarding polymorphism, I would appreciate it if someone could take a look at this paste and offer me their thoughts: http://hpaste.org/89456
21:06:26 <johnw> assembly
21:06:39 <shachaf> Can you restart the program or is this running instance special?
21:06:44 <johnw> I can restart it
21:06:49 <shachaf> If you can get the Core and maybe Cmm your life will be much easier.
21:06:54 <johnw> ok, let me try that
21:13:17 <Ghoul_> Safe way to do [head x | x <- [1..z], pred x]?
21:13:50 <Ghoul_> Ie: what if x were empty
21:14:09 <johnw> x is not going to be a list
21:14:21 <nan`> i can't write this thing
21:14:35 <Ghoul_> Oh sorry pull out head
21:14:37 <johnw> x to the left of | will be all the x's for which pred is True, i.e., you're writing filter
21:14:58 <johnw> filter pred [1..z]
21:15:00 <Ghoul_> head [x | ...
21:15:30 <johnw> maybe you want find?
21:15:32 <johnw> :t find
21:15:33 <kappabot> forall a. (a -> Bool) -> [a] -> Maybe a
21:15:36 <Ghoul_> Hmm still only want the first
21:15:46 <Ghoul_> Ah ok
21:16:16 <Ghoul_> > find (==5) [1..8]
21:16:17 <kappabot>   Just 5
21:16:38 <flebron> Hi. So other than "dear god that's hideous", any comments on glaring inefficiencies in the following code? http://hpaste.org/89460 I'm especially looking for I/O inefficiencies, the code's just a simple loop (it's essentially calculating something similar to Fibonacci, with lots of caching.)
21:16:43 <Ghoul_> > find (==5) [1..4]
21:16:44 <kappabot>   Nothing
21:17:23 <flebron> (Don't worry about fromJust being partial, the input format is specified, this is for a programming competition.)
21:19:16 <arkeet> > filter pred [minBound..maxBound]
21:19:17 <kappabot>   *Exception: Prelude.Enum.Bool.pred: bad argument
21:19:20 <arkeet> doh
21:19:38 <arkeet> > filter succ [minBound..maxBound]
21:19:39 <kappabot>   [False*Exception: Prelude.Enum.Bool.succ: bad argument
21:20:29 <Ghoul_> Thanks johnw
21:21:00 <startling> arkeet: took me a minute. :)
21:21:02 <joelteon> I'm getting a crapload of these when using cabal-ghci. Look familiar? https://gist.github.com/joelteon/193996d3cb972dd56e1d
21:22:28 <shachaf> Is Milan Straka ever around here?
21:33:59 <tabemann> another stupid question
21:35:46 <travisb> another stupid question
21:35:48 <travisb> when you have instances of type classes, do they need to be exported to be seen, and then, how do you export them?
21:36:20 <shachaf> Why do you keep saying your questions are stupid?
21:36:49 <travisb> because I tend to feel that they are obvious, things I should probably know already, and the like
21:37:00 <johnw> we welcome all questions related to Haskell
21:37:02 <Cale> travisb: It's actually impossible not to export instances
21:37:22 <travisb> Cale: that was what I was thinking, but I just wanted to make sure
21:37:23 <Cale> and impossible not to import them
21:37:50 <Cale> (This can be a little annoying occasionally)
21:38:59 <TravisD> What are the chances that there'd be a travisb and a TravisD in the same channel? (Probably high, I was just surprised to see it :))
21:39:10 <shachaf> 100%, it would appear.
21:39:17 <shachaf> Oh.
21:39:24 <TravisD> that timing was priceless
21:39:55 <tabemann> I go by travisb on a different IRC network, and when I reconnected it set my nick on this one to the nick I was using on that one
21:40:35 <shachaf> Maybe "stupid" means that you're looking for advice on how to figure out the answer yourself, rather than just an answer?
21:40:49 <shachaf> If so: The first Google result for "haskell instance export" has the answer.
21:41:01 <shachaf> But I don't mind answering a question like that myself.
21:41:12 <tabemann> shachaf: ah, the old "harnessing the power of google" trick
21:41:29 <appliciative> tabemann: it has more consequences than it might seem to, this peculiarity
21:42:20 <tabemann> applicative: I would imagine it can result in unintended effects on whether certain function usages compile or not
21:42:22 <appliciative> generally an instance should either be in the module that defines the class or the one that defines the type instanced
21:42:39 <appliciative> i thinks a correct formulation^^
21:43:08 <tabemann> and in this case I'm adding an instance to a 3rd party module, for a behavior I wanted in the original type but which was overlooked when the type was specified originally
21:43:40 <tabemann> particularly making V0 V2 V3 V4 M22 M33 M44 in Linear members of the Binary type class
21:44:57 <genisage> In ghci, is there a way to give a function an explicit type declaration?
21:44:59 <appliciative> yes i see; this is a characteristic unpleasantness
21:45:19 <appliciative> let f :: Int -> Int ; f = (+1)
21:45:49 <genisage> Thank you.
21:46:31 <TravisD> is lambdabot offline?
21:48:04 <appliciative> tabemann: hm. you should edwardk what to do about it.  maybe a package linear-binary-instances like vector-binary-instances
21:48:29 <appliciative> the main thing is that there is an 'official' place for them
21:48:46 <appliciative> since people making them independenty leads to disaster
21:48:53 <tabemann> what complicates this is that for a given matrix, there are generally *two* different ways of representing it
21:49:08 <tabemann> I'm representing matrices the way OpenGL does by default, but someone else could represent them differently
21:49:35 <startling> TravisD, kappabot
21:50:49 <tabemann> a workaround for that would not have Binary instances for V22 V33 V44, but make two different newtypes for each of them, and make *those* instances of Binary
21:51:25 <tabemann> well, you could have two newtypes, one ColumnsFirst and one RowsFirst
21:51:46 <TravisD> startling: Thanks
21:52:01 <appliciative> yes, thats the alternative.  it's an example of the second possibility, making the instance where you make the type
21:52:14 <tabemann> so then you could define, say: instance Binary a => Binary (ColumnsFirst (M22 a)) where ...
21:52:55 <appliciative> Linear could just choose one, and then have a newtype for the unchosen one
21:53:05 <tabemann> there is that solution
21:53:43 <appliciative> put an issue on the linear page https://github.com/ekmett/linear/issues he is likely to have the correct advice
21:55:08 <tabemann> doing so now
21:59:51 <lispy> 
22:02:25 <tabemann> done
22:28:58 * lispy bumps into this bug...again: http://hackage.haskell.org/trac/ghc/ticket/2189
22:29:22 <tabemann> okay, this is weird... I'm doing "import qualified Data.ByteString.Lazy as L", and it is now complaining that "L.toStrict" is not in scope...
22:31:17 <lispy> tabemann: that's a relatively new function
22:31:29 <lispy> tabemann: probably your installed bytestring is too old to have it
22:31:46 <tabemann> ah; Debian testing came with GHC 7.4.1...
22:31:58 <tabemann> that's... convenient...
22:33:38 <tabemann> so without that, just *how* does one convert between strict and lazy ByteStrings without unpacking and packing again...
22:34:15 <johnw> lazy to strict is just an mconcat, essentially, and strict to lazy is a chunking operation
22:34:23 <johnw> neither requires packing and unpacking
22:34:43 <TravisD> Hey johnw, did you give one of those lightning sessions on Julia?
22:34:44 <tabemann> I was figuring I could do Data.ByteString.concat . Data.ByteString.Lazy.toChunks
22:34:53 <johnw> TravisD: no, was'nt me
22:34:53 <arkeet> that's what you do.
22:35:00 <TravisD> johnw: Ah, alright
22:35:00 <arkeet> strict to lazy is almost a no-op.
22:35:03 <lispy> tabemann: did you know you can read the source of things via haddock?
22:35:18 <tabemann> never used haddock myself
22:35:20 <shachaf> hi arkeet
22:35:23 <arkeet> hi
22:35:30 <johnw> yeah, strict to lazy is effectively just [strict]
22:35:41 <lispy> http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/src/Data-ByteString-Lazy.html#toStrict
22:35:56 <arkeet> lispy: that was introduced in 0.10
22:36:09 <lispy> arkeet: yes
22:36:10 <hoqhuuep> Can anyone help me get this dumb idea out of my head: http://hpaste.org/89461
22:36:13 <arkeet> so if you have 0.9 then that won't work.
22:36:19 <lispy> tabemann: In this case, toStrict has a really messy implementation
22:36:30 <arkeet> hoqhuuep: looks like it's already out of your head and into hpaste.
22:36:42 <lispy> tabemann: but normally, when you want to see how something works you can click the source link next to the definition in the haddocks
22:37:20 <lispy> arkeet: I'm not sure why you're telling me. I already pointed it out to tabemann that toStrict is newer than what is installed on tabemann's machine...
22:37:21 <hoqhuuep> arkeet: mmh, but it's driving me mad, I'm sure it's out there already, but I don't know what it is
22:37:31 <arkeet> lispy: I missed that, then.
22:38:02 <tabemann> now that I look at that, I totally missed those source links up to now
22:38:18 <lispy> tabemann: they're pretty handy if you don't mind reading the code
22:38:26 <lispy> tabemann: not so much in thise case, but normally they are
22:38:51 <tabemann> okay, the definition of toStrict is a little more complex than B.concat . L.toChunks ...
22:39:02 * lispy goes back to being bummed that on windows he can't get per-keypress updates on the console...
22:39:38 <lispy> so much for using that as a mechanism to play with FRP
22:45:26 * hackagebot accelerate-cuda 0.13.0.2 - Accelerate backend for NVIDIA GPUs  http://hackage.haskell.org/package/accelerate-cuda-0.13.0.2 (TrevorMcDonell)
22:45:28 * hackagebot accelerate 0.13.0.2 - An embedded language for accelerated array processing  http://hackage.haskell.org/package/accelerate-0.13.0.2 (TrevorMcDonell)
22:46:23 <johnw> tabemann: https://gist.github.com/5727297
22:46:39 <johnw> that's not my code, it came from yet another library
22:48:21 <lispy> I've used \b -> fromChunks [b], but it's not great for efficiency
22:49:57 <lispy> oh, sorry fromChunks is the wrong direction
22:52:05 <bz> did lambdabot die?
22:52:27 <bz> nvm.
22:53:08 <tabemann> johnw: I assume BI is Data.ByteString.Internal and BLI is Data.ByteString.Lazy.Internal?
22:53:20 <johnw> yep
22:56:15 * tabemann is taking that code
22:56:31 <johnw> enjoy :)
22:56:41 <johnw> right now it's in Stringable
22:58:45 <tabemann> thanks
23:01:55 <tabemann> time to go to sleep, thanks for the help everyone
23:08:42 <hoqhuuep> So, is this just nonsense? Or does it have a name? http://hpaste.org/89461
23:09:15 <hoqhuuep> Or is this the wrong place to ask?
23:09:19 <johnw> well, it looks like your <<*>> is fusing in a natural transformation
23:09:37 <johnw> a natural transformation from f (a -> b) to g (a -> b) would then let you apply <*> to the latter
23:13:11 <hoqhuuep> johnw: thanks! I'll do some reading about "natural transformation" :)
23:14:34 <TravisD> In a do block, is it good style to put "let" on every line in a consecutive chunk of lets?
23:14:39 <rofer> How does one go about debugging haskell? I'm getting: Prelude.(!!): index too large, but I'm not sure where it's coming from
23:14:52 <shachaf> TravisD: No need to, if you indent them all the same.
23:15:02 <flebron> rofer: Try Debug.Trace
23:15:03 <TravisD> shachaf: Yeah, is there a preferred style, though?
23:15:08 <shachaf> Not using partial functions is a good start, but it's a bit late for that.
23:15:14 <shachaf> @where rts-xc can help. Try that.
23:15:15 <kappabot> I know nothing about rts-xc.
23:15:15 <rofer> and I can't just throw print statements everywhere because of typing
23:15:20 <rofer> flebron: Ooh, that sounds useful
23:15:24 <shachaf> Blach.
23:15:27 <flebron> rofer: That's what Debug.Trace lets you do :)
23:15:44 <flebron> trace :: String -> a -> a
23:15:51 <shachaf> haskell/13.05.31:05:28:00 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
23:16:49 <flebron> So other than "dear god that's hideous", any comments on glaring inefficiencies in the following code? http://hpaste.org/89460 I'm especially looking for I/O inefficiencies, the code's just a simple loop (it's essentially calculating something similar to Fibonacci, with lots of caching.)
23:16:50 <rofer> flebron: That's excellent
23:16:55 <flebron> (Don't worry about fromJust being partial, the input format is specified, this is for a programming competition.)
23:17:15 <shachaf> I'm going to go ahead and worry about fromJust being partial.
23:17:27 <shachaf> Use fromMaybe (error "blah") instead of fromJust, so at least you don't run into rofer's problem.
23:17:28 <flebron> The input format is already specified, it will always succeed :p
23:17:34 <flebron> There's no possibility of error.
23:18:11 <flebron> (The code already passes the test cases, I'm just wanting to make it faster :))
23:18:16 <TravisD> flebron: What is the significance of those arrays of numbers? They look interesting
23:18:26 <flebron> If you replace line 16 with just returning 'a', f n = fibonacci_n.
23:18:35 <flebron> (mod m)
23:19:11 <flebron> Well, fibonacci_{2n} to be precise.
23:22:13 <notar> hey, I was trying to pipe haskell output through grcat for coloring, but it runs incredible slowly
23:22:25 <notar> compare to just "program" | grcat
23:22:42 <notar> if I use runInteractiveCommand (grcat etc.)
23:23:28 <notar> is the general way of doing this getting the handle from runInteractiveCommand, passing input into the input handle, and then pustr-ging the output handle?
23:23:40 <notar> or am I way off?
23:45:31 <flebron> (i've gotten some performance increases by using Data.Array.Base (unsafeAt) instead of !.)
